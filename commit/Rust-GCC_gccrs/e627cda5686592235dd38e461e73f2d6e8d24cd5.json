{"sha": "e627cda5686592235dd38e461e73f2d6e8d24cd5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTYyN2NkYTU2ODY1OTIyMzVkZDM4ZTQ2MWU3M2YyZDZlOGQyNGNkNQ==", "commit": {"author": {"name": "Ilya Leoshkevich", "email": "iii@linux.ibm.com", "date": "2020-09-21T11:31:05Z"}, "committer": {"name": "Ilya Leoshkevich", "email": "iii@linux.ibm.com", "date": "2020-11-10T11:13:37Z"}, "message": "IBM Z: Store long doubles in vector registers when possible\n\nOn z14+, there are instructions for working with 128-bit floats (long\ndoubles) in vector registers.  It's beneficial to use them instead of\ninstructions that operate on floating point register pairs, because it\nallows to store 4 times more data in registers at a time, relieving\nregister pressure.  The raw performance of the new instructions is\nalmost the same as that of the new ones.\n\nImplement by storing TFmode values in vector registers on z14+.  Since\nnot all operations are available with the new instructions, keep the\nold ones available using the new FPRX2 mode, and convert between it and\nTFmode when necessary (this is called \"forwarder\" expanders below).\nChange the existing TFmode expanders to call either new- or old-style\nones depending on whether we are on z14+ or older machines\n(\"dispatcher\" expanders).\n\ngcc/ChangeLog:\n\n2020-11-03  Ilya Leoshkevich  <iii@linux.ibm.com>\n\n\t* config/s390/s390-modes.def (FPRX2): New mode.\n\t* config/s390/s390-protos.h (s390_fma_allowed_p): New function.\n\t* config/s390/s390.c (s390_fma_allowed_p): Likewise.\n\t(s390_build_signbit_mask): Support 128-bit masks.\n\t(print_operand): Support printing the second word of a TFmode\n\toperand as vector register.\n\t(constant_modes): Add FPRX2mode.\n\t(s390_class_max_nregs): Return 1 for TFmode on z14+.\n\t(s390_is_fpr128): New function.\n\t(s390_is_vr128): Likewise.\n\t(s390_can_change_mode_class): Use s390_is_fpr128 and\n\ts390_is_vr128 in order to determine whether mode refers to a FPR\n\tpair or to a VR.\n\t(s390_emit_compare): Force TFmode operands into registers on\n\tz14+.\n\t* config/s390/s390.h (HAVE_TF): New macro.\n\t(EXPAND_MOVTF): New macro.\n\t(EXPAND_TF): Likewise.\n\t* config/s390/s390.md (PFPO_OP_TYPE_FPRX2): PFPO_OP_TYPE_TF\n\talias.\n\t(ALL): Add FPRX2.\n\t(FP_ALL): Add FPRX2 for z14+, restrict TFmode to z13-.\n\t(FP): Likewise.\n\t(FP_ANYTF): New mode iterator.\n\t(BFP): Add FPRX2 for z14+, restrict TFmode to z13-.\n\t(TD_TF): Likewise.\n\t(xde): Add FPRX2.\n\t(nBFP): Likewise.\n\t(nDFP): Likewise.\n\t(DSF): Likewise.\n\t(DFDI): Likewise.\n\t(SFSI): Likewise.\n\t(DF): Likewise.\n\t(SF): Likewise.\n\t(fT0): Likewise.\n\t(bt): Likewise.\n\t(_d): Likewise.\n\t(HALF_TMODE): Likewise.\n\t(tf_fpr): New mode_attr.\n\t(type): New mode_attr.\n\t(*cmp<mode>_ccz_0): Use type instead of mode with fsimp.\n\t(*cmp<mode>_ccs_0_fastmath): Likewise.\n\t(*cmptf_ccs): New pattern for wfcxb.\n\t(*cmptf_ccsfps): New pattern for wfkxb.\n\t(mov<mode>): Rename to mov<mode><tf_fpr>.\n\t(signbit<mode>2): Rename to signbit<mode>2<tf_fpr>.\n\t(isinf<mode>2): Renamed to isinf<mode>2<tf_fpr>.\n\t(*TDC_insn_<mode>): Use type instead of mode with fsimp.\n\t(fixuns_trunc<FP:mode><GPR:mode>2): Rename to\n\tfixuns_trunc<FP:mode><GPR:mode>2<FP:tf_fpr>.\n\t(fix_trunctf<mode>2): Rename to fix_trunctf<mode>2_fpr.\n\t(floatdi<mode>2): Rename to floatdi<mode>2<tf_fpr>, use type\n\tinstead of mode with itof.\n\t(floatsi<mode>2): Rename to floatsi<mode>2<tf_fpr>, use type\n\tinstead of mode with itof.\n\t(*floatuns<GPR:mode><FP:mode>2): Use type instead of mode for\n\titof.\n\t(floatuns<GPR:mode><FP:mode>2): Rename to\n\tfloatuns<GPR:mode><FP:mode>2<tf_fpr>.\n\t(trunctf<mode>2): Rename to trunctf<mode>2_fpr, use type instead\n\tof mode with fsimp.\n\t(extend<DSF:mode><BFP:mode>2): Rename to\n\textend<DSF:mode><BFP:mode>2<BFP:tf_fpr>.\n\t(<FPINT:fpint_name><BFP:mode>2): Rename to\n\t<FPINT:fpint_name><BFP:mode>2<BFP:tf_fpr>, use type instead of\n\tmode with fsimp.\n\t(rint<BFP:mode>2): Rename to rint<BFP:mode>2<BFP:tf_fpr>, use\n\ttype instead of mode with fsimp.\n\t(<FPINT:fpint_name><DFP:mode>2): Use type instead of mode for\n\tfsimp.\n\t(rint<DFP:mode>2): Likewise.\n\t(trunc<BFP:mode><DFP_ALL:mode>2): Rename to\n\ttrunc<BFP:mode><DFP_ALL:mode>2<BFP:tf_fpr>.\n\t(trunc<DFP_ALL:mode><BFP:mode>2): Rename to\n\ttrunc<DFP_ALL:mode><BFP:mode>2<BFP:tf_fpr>.\n\t(extend<BFP:mode><DFP_ALL:mode>2): Rename to\n\textend<BFP:mode><DFP_ALL:mode>2<BFP:tf_fpr>.\n\t(extend<DFP_ALL:mode><BFP:mode>2): Rename to\n\textend<DFP_ALL:mode><BFP:mode>2<BFP:tf_fpr>.\n\t(add<mode>3): Rename to add<mode>3<tf_fpr>, use type instead of\n\tmode with fsimp.\n\t(*add<mode>3_cc): Use type instead of mode with fsimp.\n\t(*add<mode>3_cconly): Likewise.\n\t(sub<mode>3): Rename to sub<mode>3<tf_fpr>, use type instead of\n\tmode with fsimp.\n\t(*sub<mode>3_cc): Use type instead of mode with fsimp.\n\t(*sub<mode>3_cconly): Likewise.\n\t(mul<mode>3): Rename to mul<mode>3<tf_fpr>, use type instead of\n\tmode with fsimp.\n\t(fma<mode>4): Restrict using s390_fma_allowed_p.\n\t(fms<mode>4): Restrict using s390_fma_allowed_p.\n\t(div<mode>3): Rename to div<mode>3<tf_fpr>, use type instead of\n\tmode with fdiv.\n\t(neg<mode>2): Rename to neg<mode>2<tf_fpr>.\n\t(*neg<mode>2_cc): Use type instead of mode with fsimp.\n\t(*neg<mode>2_cconly): Likewise.\n\t(*neg<mode>2_nocc): Likewise.\n\t(*neg<mode>2): Likeiwse.\n\t(abs<mode>2): Rename to abs<mode>2<tf_fpr>, use type instead of\n\tmode with fdiv.\n\t(*abs<mode>2_cc): Use type instead of mode with fsimp.\n\t(*abs<mode>2_cconly): Likewise.\n\t(*abs<mode>2_nocc): Likewise.\n\t(*abs<mode>2): Likewise.\n\t(*negabs<mode>2_cc): Likewise.\n\t(*negabs<mode>2_cconly): Likewise.\n\t(*negabs<mode>2_nocc): Likewise.\n\t(*negabs<mode>2): Likewise.\n\t(sqrt<mode>2): Rename to sqrt<mode>2<tf_fpr>, use type instead\n\tof mode with fsqrt.\n\t(cbranch<mode>4): Use FP_ANYTF instead of FP.\n\t(copysign<mode>3): Rename to copysign<mode>3<tf_fpr>, use type\n\tinstead of mode with fsimp.\n\t* config/s390/s390.opt (flag_vx_long_double_fma): New\n\tundocumented option.\n\t* config/s390/vector.md (V_HW): Add TF for z14+.\n\t(V_HW2): Likewise.\n\t(VFT): Likewise.\n\t(VF_HW): Likewise.\n\t(V_128): Likewise.\n\t(tf_vr): New mode_attr.\n\t(tointvec): Add TF.\n\t(mov<mode>): Rename to mov<mode><tf_vr>.\n\t(movetf): New dispatcher.\n\t(*vec_tf_to_v1tf): Rename to *vec_tf_to_v1tf_fpr, restrict to\n\tz13-.\n\t(*vec_tf_to_v1tf_vr): New pattern for z14+.\n\t(*fprx2_to_tf): Likewise.\n\t(*mov_tf_to_fprx2_0): Likewise.\n\t(*mov_tf_to_fprx2_1): Likewise.\n\t(add<mode>3): Rename to add<mode>3<tf_vr>.\n\t(addtf3): New dispatcher.\n\t(sub<mode>3): Rename to sub<mode>3<tf_vr>.\n\t(subtf3): New dispatcher.\n\t(mul<mode>3): Rename to mul<mode>3<tf_vr>.\n\t(multf3): New dispatcher.\n\t(div<mode>3): Rename to div<mode>3<tf_vr>.\n\t(divtf3): New dispatcher.\n\t(sqrt<mode>2): Rename to sqrt<mode>2<tf_vr>.\n\t(sqrttf2): New dispatcher.\n\t(fma<mode>4): Restrict using s390_fma_allowed_p.\n\t(fms<mode>4): Likewise.\n\t(neg_fma<mode>4): Likewise.\n\t(neg_fms<mode>4): Likewise.\n\t(neg<mode>2): Rename to neg<mode>2<tf_vr>.\n\t(negtf2): New dispatcher.\n\t(abs<mode>2): Rename to abs<mode>2<tf_vr>.\n\t(abstf2): New dispatcher.\n\t(float<mode>tf2_vr): New forwarder.\n\t(float<mode>tf2): New dispatcher.\n\t(floatuns<mode>tf2_vr): New forwarder.\n\t(floatuns<mode>tf2): New dispatcher.\n\t(fix_trunctf<mode>2_vr): New forwarder.\n\t(fix_trunctf<mode>2): New dispatcher.\n\t(fixuns_trunctf<mode>2_vr): New forwarder.\n\t(fixuns_trunctf<mode>2): New dispatcher.\n\t(<FPINT:fpint_name><VF_HW:mode>2<VF_HW:tf_vr>): New pattern.\n\t(<FPINT:fpint_name>tf2): New forwarder.\n\t(rint<mode>2<tf_vr>): New pattern.\n\t(rinttf2): New forwarder.\n\t(*trunctfdf2_vr): New pattern.\n\t(trunctfdf2_vr): New forwarder.\n\t(trunctfdf2): New dispatcher.\n\t(trunctfsf2_vr): New forwarder.\n\t(trunctfsf2): New dispatcher.\n\t(extenddftf2_vr): New pattern.\n\t(extenddftf2): New dispatcher.\n\t(extendsftf2_vr): New forwarder.\n\t(extendsftf2): New dispatcher.\n\t(signbittf2_vr): New forwarder.\n\t(signbittf2): New dispatchers.\n\t(isinftf2_vr): New forwarder.\n\t(isinftf2): New dispatcher.\n\t* config/s390/vx-builtins.md (*vftci<mode>_cconly): Use VF_HW\n\tinstead of VECF_HW, add missing constraint, add vw support.\n\t(vftci<mode>_intcconly): Use VF_HW instead of VECF_HW.\n\t(*vftci<mode>): Rename to vftci<mode>, use VF_HW instead of\n\tVECF_HW, and vw support.\n\t(vftci<mode>_intcc): Use VF_HW instead of VECF_HW.", "tree": {"sha": "b0203006c26c278a4c8845cb316c079da8dd9d5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b0203006c26c278a4c8845cb316c079da8dd9d5b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e627cda5686592235dd38e461e73f2d6e8d24cd5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e627cda5686592235dd38e461e73f2d6e8d24cd5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e627cda5686592235dd38e461e73f2d6e8d24cd5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e627cda5686592235dd38e461e73f2d6e8d24cd5/comments", "author": {"login": "iii-i", "id": 45998171, "node_id": "MDQ6VXNlcjQ1OTk4MTcx", "avatar_url": "https://avatars.githubusercontent.com/u/45998171?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iii-i", "html_url": "https://github.com/iii-i", "followers_url": "https://api.github.com/users/iii-i/followers", "following_url": "https://api.github.com/users/iii-i/following{/other_user}", "gists_url": "https://api.github.com/users/iii-i/gists{/gist_id}", "starred_url": "https://api.github.com/users/iii-i/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iii-i/subscriptions", "organizations_url": "https://api.github.com/users/iii-i/orgs", "repos_url": "https://api.github.com/users/iii-i/repos", "events_url": "https://api.github.com/users/iii-i/events{/privacy}", "received_events_url": "https://api.github.com/users/iii-i/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iii-i", "id": 45998171, "node_id": "MDQ6VXNlcjQ1OTk4MTcx", "avatar_url": "https://avatars.githubusercontent.com/u/45998171?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iii-i", "html_url": "https://github.com/iii-i", "followers_url": "https://api.github.com/users/iii-i/followers", "following_url": "https://api.github.com/users/iii-i/following{/other_user}", "gists_url": "https://api.github.com/users/iii-i/gists{/gist_id}", "starred_url": "https://api.github.com/users/iii-i/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iii-i/subscriptions", "organizations_url": "https://api.github.com/users/iii-i/orgs", "repos_url": "https://api.github.com/users/iii-i/repos", "events_url": "https://api.github.com/users/iii-i/events{/privacy}", "received_events_url": "https://api.github.com/users/iii-i/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "61dd8dab1f0b349fb4124cfd8e2a11a161f13e4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61dd8dab1f0b349fb4124cfd8e2a11a161f13e4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61dd8dab1f0b349fb4124cfd8e2a11a161f13e4a"}], "stats": {"total": 738, "additions": 604, "deletions": 134}, "files": [{"sha": "316ca5cf58b6a263708d07d4c897980f1f10aaf4", "filename": "gcc/config/s390/s390-modes.def", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e627cda5686592235dd38e461e73f2d6e8d24cd5/gcc%2Fconfig%2Fs390%2Fs390-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e627cda5686592235dd38e461e73f2d6e8d24cd5/gcc%2Fconfig%2Fs390%2Fs390-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-modes.def?ref=e627cda5686592235dd38e461e73f2d6e8d24cd5", "patch": "@@ -22,9 +22,12 @@ along with GCC; see the file COPYING3.  If not see\n /* 256-bit integer mode is needed for STACK_SAVEAREA_MODE.  */\n INT_MODE (OI, 32);\n \n-/* Define TFmode to work around reload problem PR 20927.  */\n+/* 128-bit float stored in a VR on z14+ or a FPR pair on older machines.  */\n FLOAT_MODE (TF, 16, ieee_quad_format);\n \n+/* 128-bit float stored in a FPR pair.  */\n+FLOAT_MODE (FPRX2, 16, ieee_quad_format);\n+\n /* Add any extra modes needed to represent the condition code.  */\n \n /*"}, {"sha": "ad2f7f77c180565aa75a22b3c1b32fa212bab1cb", "filename": "gcc/config/s390/s390-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e627cda5686592235dd38e461e73f2d6e8d24cd5/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e627cda5686592235dd38e461e73f2d6e8d24cd5/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-protos.h?ref=e627cda5686592235dd38e461e73f2d6e8d24cd5", "patch": "@@ -51,6 +51,7 @@ extern bool s390_hard_regno_rename_ok (unsigned int, unsigned int);\n extern int s390_class_max_nregs (enum reg_class, machine_mode);\n extern bool s390_function_arg_vector (machine_mode, const_tree);\n extern bool s390_return_addr_from_memory(void);\n+extern bool s390_fma_allowed_p (machine_mode);\n #if S390_USE_TARGET_ATTRIBUTE\n extern tree s390_valid_target_attribute_tree (tree args,\n \t\t\t\t\t      struct gcc_options *opts,"}, {"sha": "2300a517b641753ea4cafad11160f07789e436d4", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 49, "deletions": 8, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e627cda5686592235dd38e461e73f2d6e8d24cd5/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e627cda5686592235dd38e461e73f2d6e8d24cd5/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=e627cda5686592235dd38e461e73f2d6e8d24cd5", "patch": "@@ -456,6 +456,16 @@ s390_return_addr_from_memory ()\n   return cfun_gpr_save_slot(RETURN_REGNUM) == SAVE_SLOT_STACK;\n }\n \n+/* Return nonzero if it's OK to use fused multiply-add for MODE.  */\n+bool\n+s390_fma_allowed_p (machine_mode mode)\n+{\n+  if (TARGET_VXE && mode == TFmode)\n+    return flag_vx_long_double_fma;\n+\n+  return true;\n+}\n+\n /* Indicate which ABI has been used for passing vector args.\n    0 - no vector type arguments have been passed where the ABI is relevant\n    1 - the old ABI has been used\n@@ -1850,6 +1860,10 @@ s390_emit_compare (enum rtx_code code, rtx op0, rtx op1)\n   machine_mode mode = s390_select_ccmode (code, op0, op1);\n   rtx cc;\n \n+  /* Force OP1 into register in order to satisfy VXE TFmode patterns.  */\n+  if (TARGET_VXE && GET_MODE (op1) == TFmode)\n+    op1 = force_reg (TFmode, op1);\n+\n   if (GET_MODE_CLASS (GET_MODE (op0)) == MODE_CC)\n     {\n       /* Do not output a redundant compare instruction if a\n@@ -6959,6 +6973,13 @@ s390_expand_vec_init (rtx target, rtx vals)\n extern rtx\n s390_build_signbit_mask (machine_mode mode)\n {\n+  if (mode == TFmode && TARGET_VXE)\n+    {\n+      wide_int mask_val = wi::set_bit_in_zero (127, 128);\n+      rtx mask = immed_wide_int_const (mask_val, TImode);\n+      return gen_lowpart (TFmode, mask);\n+    }\n+\n   /* Generate the integral element mask value.  */\n   machine_mode inner_mode = GET_MODE_INNER (mode);\n   int inner_bitsize = GET_MODE_BITSIZE (inner_mode);\n@@ -7902,6 +7923,7 @@ print_operand_address (FILE *file, rtx addr)\n \t CONST_VECTOR: Generate a bitmask for vgbm instruction.\n     'x': print integer X as if it's an unsigned halfword.\n     'v': print register number as vector register (v1 instead of f1).\n+    'V': print the second word of a TFmode operand as vector register.\n */\n \n void\n@@ -8071,13 +8093,13 @@ print_operand (FILE *file, rtx x, int code)\n     case REG:\n       /* Print FP regs as fx instead of vx when they are accessed\n \t through non-vector mode.  */\n-      if (code == 'v'\n+      if ((code == 'v' || code == 'V')\n \t  || VECTOR_NOFP_REG_P (x)\n \t  || (FP_REG_P (x) && VECTOR_MODE_P (GET_MODE (x)))\n \t  || (VECTOR_REG_P (x)\n \t      && (GET_MODE_SIZE (GET_MODE (x)) /\n \t\t  s390_class_max_nregs (FP_REGS, GET_MODE (x))) > 8))\n-\tfprintf (file, \"%%v%s\", reg_names[REGNO (x)] + 2);\n+\tfprintf (file, \"%%v%s\", reg_names[REGNO (x) + (code == 'V')] + 2);\n       else\n \tfprintf (file, \"%s\", reg_names[REGNO (x)]);\n       break;\n@@ -8623,7 +8645,7 @@ replace_constant_pool_ref (rtx_insn *insn, rtx ref, rtx offset)\n \n static machine_mode constant_modes[] =\n {\n-  TFmode, TImode, TDmode,\n+  TFmode, FPRX2mode, TImode, TDmode,\n   V16QImode, V8HImode, V4SImode, V2DImode, V1TImode,\n   V4SFmode, V2DFmode, V1TFmode,\n   DFmode, DImode, DDmode,\n@@ -10418,7 +10440,8 @@ s390_class_max_nregs (enum reg_class rclass, machine_mode mode)\n \t full VRs.  */\n       if (TARGET_VX\n \t  && SCALAR_FLOAT_MODE_P (mode)\n-\t  && GET_MODE_SIZE (mode) >= 16)\n+\t  && GET_MODE_SIZE (mode) >= 16\n+\t  && !(TARGET_VXE && mode == TFmode))\n \treg_pair_required_p = true;\n \n       /* Even if complex types would fit into a single FPR/VR we force\n@@ -10441,6 +10464,24 @@ s390_class_max_nregs (enum reg_class rclass, machine_mode mode)\n   return (GET_MODE_SIZE (mode) + reg_size - 1) / reg_size;\n }\n \n+/* Return nonzero if mode M describes a 128-bit float in a floating point\n+   register pair.  */\n+\n+static bool\n+s390_is_fpr128 (machine_mode m)\n+{\n+  return m == FPRX2mode || (!TARGET_VXE && m == TFmode);\n+}\n+\n+/* Return nonzero if mode M describes a 128-bit float in a vector\n+   register.  */\n+\n+static bool\n+s390_is_vr128 (machine_mode m)\n+{\n+  return m == V1TFmode || (TARGET_VXE && m == TFmode);\n+}\n+\n /* Implement TARGET_CAN_CHANGE_MODE_CLASS.  */\n \n static bool\n@@ -10451,11 +10492,11 @@ s390_can_change_mode_class (machine_mode from_mode,\n   machine_mode small_mode;\n   machine_mode big_mode;\n \n-  /* V1TF and TF have different representations in vector\n-     registers.  */\n+  /* 128-bit values have different representations in floating point and\n+     vector registers.  */\n   if (reg_classes_intersect_p (VEC_REGS, rclass)\n-      && ((from_mode == V1TFmode && to_mode == TFmode)\n-\t  || (from_mode == TFmode && to_mode == V1TFmode)))\n+      && ((s390_is_fpr128 (from_mode) && s390_is_vr128 (to_mode))\n+\t  || (s390_is_vr128 (from_mode) && s390_is_fpr128 (to_mode))))\n     return false;\n \n   if (GET_MODE_SIZE (from_mode) == GET_MODE_SIZE (to_mode))"}, {"sha": "8c028317b6babe4a6fe585f6d5856dd179436d94", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e627cda5686592235dd38e461e73f2d6e8d24cd5/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e627cda5686592235dd38e461e73f2d6e8d24cd5/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=e627cda5686592235dd38e461e73f2d6e8d24cd5", "patch": "@@ -1186,5 +1186,40 @@ struct GTY(()) machine_function\n \n #define TARGET_INDIRECT_BRANCH_TABLE s390_indirect_branch_table\n \n+#ifdef GENERATOR_FILE\n+/* gencondmd.c is built before insn-flags.h.  */\n+#define HAVE_TF(icode) true\n+#else\n+#define HAVE_TF(icode) (HAVE_##icode##_fpr || HAVE_##icode##_vr)\n+#endif\n+\n+/* Dispatcher for movtf.  */\n+#define EXPAND_MOVTF(icode)                                                   \\\n+  do                                                                          \\\n+    {                                                                         \\\n+      if (TARGET_VXE)                                                         \\\n+\temit_insn (gen_##icode##_vr (operands[0], operands[1]));              \\\n+      else                                                                    \\\n+\temit_insn (gen_##icode##_fpr (operands[0], operands[1]));             \\\n+      DONE;                                                                   \\\n+    }                                                                         \\\n+  while (false)\n+\n+/* Like EXPAND_MOVTF, but also legitimizes operands.  */\n+#define EXPAND_TF(icode, nops)                                                \\\n+  do                                                                          \\\n+    {                                                                         \\\n+      const size_t __nops = (nops);                                           \\\n+      expand_operand ops[__nops];                                             \\\n+      create_output_operand (&ops[0], operands[0], GET_MODE (operands[0]));   \\\n+      for (size_t i = 1; i < __nops; i++)                                     \\\n+\tcreate_input_operand (&ops[i], operands[i], GET_MODE (operands[i]));  \\\n+      if (TARGET_VXE)                                                         \\\n+\texpand_insn (CODE_FOR_##icode##_vr, __nops, ops);                     \\\n+      else                                                                    \\\n+\texpand_insn (CODE_FOR_##icode##_fpr, __nops, ops);                    \\\n+      DONE;                                                                   \\\n+    }                                                                         \\\n+  while (false)\n \n #endif /* S390_H */"}, {"sha": "a2c033b2515f89c37e7423728c75d2eed0b3ad85", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 127, "deletions": 82, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e627cda5686592235dd38e461e73f2d6e8d24cd5/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e627cda5686592235dd38e461e73f2d6e8d24cd5/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=e627cda5686592235dd38e461e73f2d6e8d24cd5", "patch": "@@ -405,6 +405,7 @@\n    (PFPO_OP_TYPE_SF             0x5)\n    (PFPO_OP_TYPE_DF             0x6)\n    (PFPO_OP_TYPE_TF             0x7)\n+   (PFPO_OP_TYPE_FPRX2          0x7)\n    (PFPO_OP_TYPE_SD             0x8)\n    (PFPO_OP_TYPE_DD             0x9)\n    (PFPO_OP_TYPE_TD             0xa)\n@@ -627,20 +628,29 @@\n \n ;; Iterators\n \n-(define_mode_iterator ALL [TI DI SI HI QI TF DF SF TD DD SD V1QI V2QI V4QI V8QI V16QI V1HI V2HI V4HI V8HI V1SI V2SI V4SI V1DI V2DI V1SF V2SF V4SF V1TI V1DF V2DF V1TF])\n+(define_mode_iterator ALL [TI DI SI HI QI TF FPRX2 DF SF TD DD SD V1QI V2QI\n+\t\t\t   V4QI V8QI V16QI V1HI V2HI V4HI V8HI V1SI V2SI V4SI\n+\t\t\t   V1DI V2DI V1SF V2SF V4SF V1TI V1DF V2DF V1TF])\n \n ;; These mode iterators allow floating point patterns to be generated from the\n ;; same template.\n-(define_mode_iterator FP_ALL [TF DF SF (TD \"TARGET_HARD_DFP\") (DD \"TARGET_HARD_DFP\")\n+(define_mode_iterator FP_ALL [(TF \"!TARGET_VXE\") (FPRX2 \"TARGET_VXE\") DF SF\n+\t\t\t      (TD \"TARGET_HARD_DFP\") (DD \"TARGET_HARD_DFP\")\n                               (SD \"TARGET_HARD_DFP\")])\n-(define_mode_iterator FP [TF DF SF (TD \"TARGET_HARD_DFP\") (DD \"TARGET_HARD_DFP\")])\n-(define_mode_iterator BFP [TF DF SF])\n+(define_mode_iterator FP [(TF \"!TARGET_VXE\") (FPRX2 \"TARGET_VXE\") DF SF\n+\t\t\t  (TD \"TARGET_HARD_DFP\") (DD \"TARGET_HARD_DFP\")])\n+;; Like FP, but without a condition on TF. Useful for expanders that must be\n+;; the same for FP and VR variants of TF.\n+(define_mode_iterator FP_ANYTF [TF (FPRX2 \"TARGET_VXE\") DF SF\n+\t\t\t\t(TD \"TARGET_HARD_DFP\")\n+\t\t\t\t(DD \"TARGET_HARD_DFP\")])\n+(define_mode_iterator BFP [(TF \"!TARGET_VXE\") (FPRX2 \"TARGET_VXE\") DF SF])\n (define_mode_iterator DFP [TD DD])\n (define_mode_iterator DFP_ALL [TD DD SD])\n (define_mode_iterator DSF [DF SF])\n (define_mode_iterator SD_SF [SF SD])\n (define_mode_iterator DD_DF [DF DD])\n-(define_mode_iterator TD_TF [TF TD])\n+(define_mode_iterator TD_TF [(TF \"!TARGET_VXE\") (FPRX2 \"TARGET_VXE\") TD])\n \n ; 32 bit int<->fp conversion instructions are available since VXE2 (z15).\n (define_mode_iterator VX_CONV_BFP [DF (SF \"TARGET_VXE2\")])\n@@ -714,7 +724,8 @@\n \n ;; In FP templates, a string like \"lt<de>br\" will expand to \"ltxbr\" in\n ;; TF/TDmode, \"ltdbr\" in DF/DDmode, and \"ltebr\" in SF/SDmode.\n-(define_mode_attr xde [(TF \"x\") (DF \"d\") (SF \"e\") (TD \"x\") (DD \"d\") (SD \"e\") (V4SF \"e\") (V2DF \"d\")])\n+(define_mode_attr xde [(TF \"x\") (FPRX2 \"x\") (DF \"d\") (SF \"e\") (TD \"x\")\n+\t\t       (DD \"d\") (SD \"e\") (V4SF \"e\") (V2DF \"d\")])\n \n ;; In FP templates, a <dee> in \"m<dee><bt>r\" will expand to \"mx<bt>r\" in\n ;; TF/TDmode, \"md<bt>r\" in DF/DDmode, \"mee<bt>r\" in SFmode and \"me<bt>r in\n@@ -727,19 +738,22 @@\n \n ;; These mode attributes are supposed to be used in the `enabled' insn\n ;; attribute to disable certain alternatives for certain modes.\n-(define_mode_attr nBFP [(TF \"0\") (DF \"0\") (SF \"0\") (TD \"*\") (DD \"*\") (DD \"*\")])\n-(define_mode_attr nDFP [(TF \"*\") (DF \"*\") (SF \"*\") (TD \"0\") (DD \"0\") (DD \"0\")])\n-(define_mode_attr DSF [(TF \"0\") (DF \"*\") (SF \"*\") (TD \"0\") (DD \"0\") (SD \"0\")])\n-(define_mode_attr DFDI [(TF \"0\") (DF \"*\") (SF \"0\")\n+(define_mode_attr nBFP [(TF \"0\") (FPRX2 \"0\") (DF \"0\") (SF \"0\") (TD \"*\")\n+\t\t\t(DD \"*\") (DD \"*\")])\n+(define_mode_attr nDFP [(TF \"*\") (FPRX2 \"*\") (DF \"*\") (SF \"*\") (TD \"0\")\n+\t\t\t(DD \"0\") (DD \"0\")])\n+(define_mode_attr DSF [(TF \"0\") (FPRX2 \"0\") (DF \"*\") (SF \"*\") (TD \"0\")\n+\t\t       (DD \"0\") (SD \"0\")])\n+(define_mode_attr DFDI [(TF \"0\") (FPRX2 \"0\") (DF \"*\") (SF \"0\")\n \t\t\t(TD \"0\") (DD \"0\") (DD \"0\")\n \t\t\t(TI \"0\") (DI \"*\") (SI \"0\")])\n-(define_mode_attr SFSI [(TF \"0\") (DF \"0\") (SF \"*\")\n+(define_mode_attr SFSI [(TF \"0\") (FPRX2 \"0\") (DF \"0\") (SF \"*\")\n \t\t\t(TD \"0\") (DD \"0\") (DD \"0\")\n \t\t\t(TI \"0\") (DI \"0\") (SI \"*\")])\n-(define_mode_attr DF [(TF \"0\") (DF \"*\") (SF \"0\")\n+(define_mode_attr DF [(TF \"0\") (FPRX2 \"0\") (DF \"*\") (SF \"0\")\n \t\t      (TD \"0\") (DD \"0\") (DD \"0\")\n \t\t      (TI \"0\") (DI \"0\") (SI \"0\")])\n-(define_mode_attr SF [(TF \"0\") (DF \"0\") (SF \"*\")\n+(define_mode_attr SF [(TF \"0\") (FPRX2 \"0\") (DF \"0\") (SF \"*\")\n \t\t      (TD \"0\") (DD \"0\") (DD \"0\")\n \t\t      (TI \"0\") (DI \"0\") (SI \"0\")])\n \n@@ -749,15 +763,17 @@\n ;; sign bit instructions only handle single source and target fp registers\n ;; these instructions can only be used for TFmode values if the source and\n ;; target operand uses the same fp register.\n-(define_mode_attr fT0 [(TF \"0\") (DF \"f\") (SF \"f\")])\n+(define_mode_attr fT0 [(TF \"0\") (FPRX2 \"0\") (DF \"f\") (SF \"f\")])\n \n ;; This attribute adds b for bfp instructions and t for dfp instructions and is used\n ;; within instruction mnemonics.\n-(define_mode_attr bt [(TF \"b\") (DF \"b\") (SF \"b\") (TD \"t\") (DD \"t\") (SD \"t\")])\n+(define_mode_attr bt [(TF \"b\") (FPRX2 \"b\") (DF \"b\") (SF \"b\") (TD \"t\") (DD \"t\")\n+\t\t      (SD \"t\")])\n \n ;; This attribute is used within instruction mnemonics.  It evaluates to d for dfp\n ;; modes and to an empty string for bfp modes.\n-(define_mode_attr _d [(TF \"\") (DF \"\") (SF \"\") (TD \"d\") (DD \"d\") (SD \"d\")])\n+(define_mode_attr _d [(TF \"\") (FPRX2 \"\") (DF \"\") (SF \"\") (TD \"d\") (DD \"d\")\n+\t\t      (SD \"d\")])\n \n ;; In GPR and P templates, a constraint like \"<d0>\" will expand to \"d\" in DImode\n ;; and \"0\" in SImode. This allows to combine instructions of which the 31bit\n@@ -829,7 +845,7 @@\n \n ;; This attribute expands to DF for TFmode and to DD for TDmode .  It is\n ;; used for Txmode splitters splitting a Txmode copy into 2 Dxmode copies.\n-(define_mode_attr HALF_TMODE [(TF \"DF\") (TD \"DD\")])\n+(define_mode_attr HALF_TMODE [(TF \"DF\") (FPRX2 \"DF\") (TD \"DD\")])\n \n ;; Maximum unsigned integer that fits in MODE.\n (define_mode_attr max_uint [(HI \"65535\") (QI \"255\")])\n@@ -850,6 +866,13 @@\n ;; Allow return and simple_return to be defined from a single template.\n (define_code_iterator ANY_RETURN [return simple_return])\n \n+;; Facilitate dispatching TFmode expanders on z14+.\n+(define_mode_attr tf_fpr [(TF \"_fpr\") (FPRX2 \"\") (DF \"\") (SF \"\") (TD \"\")\n+\t\t\t  (DD \"\") (SD \"\")])\n+\n+;; Mode names as seen in type mode_attr values.\n+(define_mode_attr type [(TF \"tf\") (FPRX2 \"tf\") (DF \"df\") (SF \"sf\") (TD \"td\")\n+\t\t\t(DD \"dd\") (SD \"sd\")])\n \n \n ; Condition code modes generated by vector fp comparisons.  These will\n@@ -1421,7 +1444,7 @@\n   \"TARGET_HARD_FLOAT\"\n   \"lt<xde><bt>r\\t%0,%0\"\n    [(set_attr \"op_type\" \"RRE\")\n-    (set_attr \"type\"  \"fsimp<mode>\")])\n+    (set_attr \"type\" \"fsimp<type>\")])\n \n (define_insn \"*cmp<mode>_ccs_0_fastmath\"\n   [(set (reg CC_REGNUM)\n@@ -1433,7 +1456,7 @@\n    && !flag_signaling_nans\"\n   \"lt<xde><bt>r\\t%0,%0\"\n   [(set_attr \"op_type\" \"RRE\")\n-   (set_attr \"type\" \"fsimp<mode>\")])\n+   (set_attr \"type\" \"fsimp<type>\")])\n \n ; VX: TFmode in FPR pairs: use cxbr instead of wfcxb\n ; cxtr, cdtr, cxbr, cdbr, cebr, cdb, ceb, wfcsb, wfcdb\n@@ -1451,6 +1474,18 @@\n    (set_attr \"cpu_facility\" \"*,*,vx,vxe\")\n    (set_attr \"enabled\" \"*,<DSF>,<DF>,<SF>\")])\n \n+; VX: TFmode in VR: use wfcxb\n+(define_insn \"*cmptf_ccs\"\n+  [(set (reg CC_REGNUM)\n+\t(compare (match_operand:TF 0 \"register_operand\" \"v\")\n+                 (match_operand:TF 1 \"register_operand\" \"v\")))]\n+  \"s390_match_ccmode(insn, CCSmode) && TARGET_VXE\"\n+  \"wfcxb\\t%0,%1\"\n+  [(set_attr \"op_type\" \"VRR\")\n+   (set_attr \"cpu_facility\" \"vxe\")])\n+\n+; VX: TFmode in FPR pairs: use kxbr instead of wfkxb\n+; kxtr, kdtr, kxbr, kdbr, kebr, kdb, keb, wfksb, wfkdb\n (define_insn \"*cmp<mode>_ccsfps\"\n   [(set (reg CC_REGNUM)\n \t(compare (match_operand:FP 0 \"register_operand\" \"f,f,v,v\")\n@@ -1465,6 +1500,16 @@\n    (set_attr \"cpu_facility\" \"*,*,vx,vxe\")\n    (set_attr \"enabled\" \"*,<DSF>,<DF>,<SF>\")])\n \n+; VX: TFmode in VR: use wfkxb\n+(define_insn \"*cmptf_ccsfps\"\n+  [(set (reg CC_REGNUM)\n+\t(compare (match_operand:TF 0 \"register_operand\" \"v\")\n+                 (match_operand:TF 1 \"register_operand\" \"v\")))]\n+  \"s390_match_ccmode (insn, CCSFPSmode) && TARGET_VXE\"\n+  \"wfkxb\\t%0,%1\"\n+  [(set_attr \"op_type\" \"VRR\")\n+   (set_attr \"cpu_facility\" \"vxe\")])\n+\n ; Compare and Branch instructions\n \n ; cij, cgij, crj, cgrj, cfi, cgfi, cr, cgr\n@@ -2489,7 +2534,7 @@\n ; mov(tf|td) instruction pattern(s).\n ;\n \n-(define_expand \"mov<mode>\"\n+(define_expand \"mov<mode><tf_fpr>\"\n   [(set (match_operand:TD_TF 0 \"nonimmediate_operand\" \"\")\n         (match_operand:TD_TF 1 \"general_operand\"      \"\"))]\n   \"\"\n@@ -3418,7 +3463,7 @@\n ; Test data class.\n ;\n \n-(define_expand \"signbit<mode>2\"\n+(define_expand \"signbit<mode>2<tf_fpr>\"\n   [(set (reg:CCZ CC_REGNUM)\n         (unspec:CCZ [(match_operand:FP_ALL 1 \"register_operand\" \"f\")\n                      (match_dup 2)]\n@@ -3430,7 +3475,7 @@\n   operands[2] = GEN_INT (S390_TDC_SIGNBIT_SET);\n })\n \n-(define_expand \"isinf<mode>2\"\n+(define_expand \"isinf<mode>2<tf_fpr>\"\n   [(set (reg:CCZ CC_REGNUM)\n         (unspec:CCZ [(match_operand:FP_ALL 1 \"register_operand\" \"f\")\n                      (match_dup 2)]\n@@ -3468,7 +3513,7 @@\n   \"TARGET_HARD_FLOAT\"\n   \"t<_d>c<xde><bt>\\t%0,%1\"\n    [(set_attr \"op_type\" \"RXE\")\n-    (set_attr \"type\"  \"fsimp<mode>\")])\n+    (set_attr \"type\"    \"fsimp<type>\")])\n \n \n \n@@ -4984,7 +5029,7 @@\n ; This is the only entry point for fixuns_trunc.  It multiplexes the\n ; expansion to either the *_emu expanders below for pre z196 machines\n ; or emits the default pattern otherwise.\n-(define_expand \"fixuns_trunc<FP:mode><GPR:mode>2\"\n+(define_expand \"fixuns_trunc<FP:mode><GPR:mode>2<FP:tf_fpr>\"\n   [(parallel\n     [(set (match_operand:GPR 0 \"register_operand\" \"\")\n \t  (unsigned_fix:GPR (match_operand:FP 1 \"register_operand\" \"\")))\n@@ -5247,12 +5292,12 @@\n ; fix_trunctf(si|di)2 instruction pattern(s).\n ;\n \n-(define_expand \"fix_trunctf<mode>2\"\n+(define_expand \"fix_trunctf<mode>2_fpr\"\n   [(parallel [(set (match_operand:GPR 0 \"register_operand\" \"\")\n \t\t   (fix:GPR (match_operand:TF 1 \"register_operand\" \"\")))\n \t      (unspec:GPR [(const_int BFP_RND_TOWARD_0)] UNSPEC_ROUND)\n \t      (clobber (reg:CC CC_REGNUM))])]\n-  \"TARGET_HARD_FLOAT\"\n+  \"TARGET_HARD_FLOAT && !TARGET_VXE\"\n   \"\")\n \n \n@@ -5261,28 +5306,28 @@\n ;\n \n ; cxgbr, cdgbr, cegbr, cxgtr, cdgtr\n-(define_insn \"floatdi<mode>2\"\n+(define_insn \"floatdi<mode>2<tf_fpr>\"\n   [(set (match_operand:FP           0 \"register_operand\" \"=f,v\")\n         (float:FP (match_operand:DI 1 \"register_operand\"  \"d,v\")))]\n   \"TARGET_ZARCH && TARGET_HARD_FLOAT\"\n   \"@\n    c<xde>g<bt>r\\t%0,%1\n    wcdgb\\t%v0,%v1,0,0\"\n   [(set_attr \"op_type\"      \"RRE,VRR\")\n-   (set_attr \"type\"         \"itof<mode>\" )\n+   (set_attr \"type\"         \"itof<type>\" )\n    (set_attr \"cpu_facility\" \"*,vx\")\n    (set_attr \"enabled\"      \"*,<DFDI>\")])\n \n ; cxfbr, cdfbr, cefbr, wcefb\n-(define_insn \"floatsi<mode>2\"\n+(define_insn \"floatsi<mode>2<tf_fpr>\"\n   [(set (match_operand:BFP           0 \"register_operand\" \"=f,v\")\n         (float:BFP (match_operand:SI 1 \"register_operand\"  \"d,v\")))]\n   \"TARGET_HARD_FLOAT\"\n   \"@\n    c<xde>fbr\\t%0,%1\n    wcefb\\t%v0,%v1,0,0\"\n   [(set_attr \"op_type\"      \"RRE,VRR\")\n-   (set_attr \"type\"         \"itof<mode>\" )\n+   (set_attr \"type\"         \"itof<type>\" )\n    (set_attr \"cpu_facility\" \"*,vxe2\")\n    (set_attr \"enabled\"      \"*,<SFSI>\")])\n \n@@ -5293,7 +5338,7 @@\n   \"TARGET_Z196 && TARGET_HARD_FLOAT\"\n   \"c<xde>ftr\\t%0,0,%1,0\"\n   [(set_attr \"op_type\" \"RRE\")\n-   (set_attr \"type\"   \"itof<mode>\" )])\n+   (set_attr \"type\"    \"itof<type>\")])\n \n ;\n ; floatuns(si|di)(tf|df|sf|td|dd)2 instruction pattern(s).\n@@ -5319,9 +5364,9 @@\n    && (!TARGET_VX || <FP:MODE>mode != DFmode || <GPR:MODE>mode != DImode)\"\n   \"c<FP:xde>l<GPR:gf><FP:bt>r\\t%0,0,%1,0\"\n   [(set_attr \"op_type\" \"RRE\")\n-   (set_attr \"type\"    \"itof<FP:mode>\")])\n+   (set_attr \"type\"    \"itof<FP:type>\")])\n \n-(define_expand \"floatuns<GPR:mode><FP:mode>2\"\n+(define_expand \"floatuns<GPR:mode><FP:mode>2<tf_fpr>\"\n   [(set (match_operand:FP                     0 \"register_operand\" \"\")\n         (unsigned_float:FP (match_operand:GPR 1 \"register_operand\" \"\")))]\n   \"TARGET_Z196 && TARGET_HARD_FLOAT\")\n@@ -5347,7 +5392,7 @@\n ;\n \n ; ldxbr, lexbr\n-(define_insn \"trunctf<mode>2\"\n+(define_insn \"trunctf<mode>2_fpr\"\n   [(set (match_operand:DSF 0 \"register_operand\" \"=f\")\n         (float_truncate:DSF (match_operand:TF 1 \"register_operand\" \"f\")))\n    (clobber (match_scratch:TF 2 \"=f\"))]\n@@ -5427,9 +5472,9 @@\n    l<BFP:xde><DSF:xde>br\\t%0,%1\n    l<BFP:xde><DSF:xde>b\\t%0,%1\"\n   [(set_attr \"op_type\" \"RRE,RXE\")\n-   (set_attr \"type\"    \"fsimp<BFP:mode>, fload<BFP:mode>\")])\n+   (set_attr \"type\"    \"fsimp<BFP:type>, fload<BFP:type>\")])\n \n-(define_expand \"extend<DSF:mode><BFP:mode>2\"\n+(define_expand \"extend<DSF:mode><BFP:mode>2<BFP:tf_fpr>\"\n   [(set (match_operand:BFP                   0 \"register_operand\"     \"\")\n         (float_extend:BFP (match_operand:DSF 1 \"nonimmediate_operand\" \"\")))]\n   \"TARGET_HARD_FLOAT\n@@ -5471,27 +5516,27 @@\n ; For all of them the inexact exceptions are suppressed.\n \n ; fiebra, fidbra, fixbra\n-(define_insn \"<FPINT:fpint_name><BFP:mode>2\"\n+(define_insn \"<FPINT:fpint_name><BFP:mode>2<BFP:tf_fpr>\"\n   [(set (match_operand:BFP 0 \"register_operand\" \"=f\")\n \t(unspec:BFP [(match_operand:BFP 1 \"register_operand\" \"f\")]\n \t\t    FPINT))]\n   \"TARGET_Z196\"\n   \"fi<BFP:xde>bra\\t%0,<FPINT:fpint_roundingmode>,%1,4\"\n   [(set_attr \"op_type\"   \"RRF\")\n-   (set_attr \"type\"      \"fsimp<BFP:mode>\")])\n+   (set_attr \"type\"      \"fsimp<BFP:type>\")])\n \n ; rint is supposed to raise an inexact exception so we can use the\n ; older instructions.\n \n ; fiebr, fidbr, fixbr\n-(define_insn \"rint<BFP:mode>2\"\n+(define_insn \"rint<BFP:mode>2<BFP:tf_fpr>\"\n   [(set (match_operand:BFP 0 \"register_operand\" \"=f\")\n \t(unspec:BFP [(match_operand:BFP 1 \"register_operand\" \"f\")]\n \t\t    UNSPEC_FPINT_RINT))]\n   \"\"\n   \"fi<BFP:xde>br\\t%0,0,%1\"\n   [(set_attr \"op_type\"   \"RRF\")\n-   (set_attr \"type\"      \"fsimp<BFP:mode>\")])\n+   (set_attr \"type\"      \"fsimp<BFP:type>\")])\n \n \n ; Decimal Floating Point - load fp integer\n@@ -5504,7 +5549,7 @@\n   \"TARGET_HARD_DFP\"\n   \"fi<DFP:xde>tr\\t%0,<FPINT:fpint_roundingmode>,%1,4\"\n   [(set_attr \"op_type\"   \"RRF\")\n-   (set_attr \"type\"      \"fsimp<DFP:mode>\")])\n+   (set_attr \"type\"      \"fsimp<DFP:type>\")])\n \n ; fidtr, fixtr\n (define_insn \"rint<DFP:mode>2\"\n@@ -5514,7 +5559,7 @@\n   \"TARGET_HARD_DFP\"\n   \"fi<DFP:xde>tr\\t%0,0,%1,0\"\n   [(set_attr \"op_type\"   \"RRF\")\n-   (set_attr \"type\"      \"fsimp<DFP:mode>\")])\n+   (set_attr \"type\"      \"fsimp<DFP:type>\")])\n \n ;\n ; Binary <-> Decimal floating point trunc patterns\n@@ -5538,7 +5583,7 @@\n   \"TARGET_HARD_DFP\"\n   \"pfpo\")\n \n-(define_expand \"trunc<BFP:mode><DFP_ALL:mode>2\"\n+(define_expand \"trunc<BFP:mode><DFP_ALL:mode>2<BFP:tf_fpr>\"\n   [(set (reg:BFP FPR4_REGNUM) (match_operand:BFP 1 \"nonimmediate_operand\" \"\"))\n    (set (reg:SI GPR0_REGNUM) (match_dup 2))\n    (parallel\n@@ -5565,7 +5610,7 @@\n   operands[2] = GEN_INT (flags);\n })\n \n-(define_expand \"trunc<DFP_ALL:mode><BFP:mode>2\"\n+(define_expand \"trunc<DFP_ALL:mode><BFP:mode>2<BFP:tf_fpr>\"\n   [(set (reg:DFP_ALL FPR4_REGNUM)\n         (match_operand:DFP_ALL 1 \"nonimmediate_operand\" \"\"))\n    (set (reg:SI GPR0_REGNUM) (match_dup 2))\n@@ -5611,7 +5656,7 @@\n   \"TARGET_HARD_DFP\"\n   \"pfpo\")\n \n-(define_expand \"extend<BFP:mode><DFP_ALL:mode>2\"\n+(define_expand \"extend<BFP:mode><DFP_ALL:mode>2<BFP:tf_fpr>\"\n   [(set (reg:BFP FPR4_REGNUM) (match_operand:BFP 1 \"nonimmediate_operand\" \"\"))\n    (set (reg:SI GPR0_REGNUM) (match_dup 2))\n    (parallel\n@@ -5638,7 +5683,7 @@\n   operands[2] = GEN_INT (flags);\n })\n \n-(define_expand \"extend<DFP_ALL:mode><BFP:mode>2\"\n+(define_expand \"extend<DFP_ALL:mode><BFP:mode>2<BFP:tf_fpr>\"\n   [(set (reg:DFP_ALL FPR4_REGNUM)\n         (match_operand:DFP_ALL 1 \"nonimmediate_operand\" \"\"))\n    (set (reg:SI GPR0_REGNUM) (match_dup 2))\n@@ -6117,7 +6162,7 @@\n \n ; axbr, adbr, aebr, axb, adb, aeb, adtr, axtr\n ; FIXME: wfadb does not clobber cc\n-(define_insn \"add<mode>3\"\n+(define_insn \"add<mode>3<tf_fpr>\"\n   [(set (match_operand:FP          0 \"register_operand\"     \"=f,f,f,v,v\")\n         (plus:FP (match_operand:FP 1 \"nonimmediate_operand\" \"%f,0,0,v,v\")\n \t\t (match_operand:FP 2 \"general_operand\"       \"f,f,R,v,v\")))\n@@ -6130,7 +6175,7 @@\n    wfadb\\t%v0,%v1,%v2\n    wfasb\\t%v0,%v1,%v2\"\n   [(set_attr \"op_type\"      \"RRF,RRE,RXE,VRR,VRR\")\n-   (set_attr \"type\"         \"fsimp<mode>\")\n+   (set_attr \"type\"         \"fsimp<type>\")\n    (set_attr \"cpu_facility\" \"*,*,*,vx,vxe\")\n    (set_attr \"enabled\"      \"<nBFP>,<nDFP>,<DSF>,<DF>,<SF>\")])\n \n@@ -6148,7 +6193,7 @@\n    a<xde>br\\t%0,%2\n    a<xde>b\\t%0,%2\"\n   [(set_attr \"op_type\"  \"RRF,RRE,RXE\")\n-   (set_attr \"type\"     \"fsimp<mode>\")\n+   (set_attr \"type\"     \"fsimp<type>\")\n    (set_attr \"enabled\"  \"<nBFP>,<nDFP>,<DSF>\")])\n \n ; axbr, adbr, aebr, axb, adb, aeb, adtr, axtr\n@@ -6164,7 +6209,7 @@\n    a<xde>br\\t%0,%2\n    a<xde>b\\t%0,%2\"\n   [(set_attr \"op_type\"  \"RRF,RRE,RXE\")\n-   (set_attr \"type\"     \"fsimp<mode>\")\n+   (set_attr \"type\"     \"fsimp<type>\")\n    (set_attr \"enabled\"  \"<nBFP>,<nDFP>,<DSF>\")])\n \n ;\n@@ -6562,7 +6607,7 @@\n \n ; FIXME: (clobber (match_scratch:CC 3 \"=c,c,c,X,X\")) does not work - why?\n ; sxbr, sdbr, sebr, sdb, seb, sxtr, sdtr\n-(define_insn \"sub<mode>3\"\n+(define_insn \"sub<mode>3<tf_fpr>\"\n   [(set (match_operand:FP           0 \"register_operand\" \"=f,f,f,v,v\")\n         (minus:FP (match_operand:FP 1 \"register_operand\"  \"f,0,0,v,v\")\n \t\t  (match_operand:FP 2 \"general_operand\"   \"f,f,R,v,v\")))\n@@ -6575,7 +6620,7 @@\n    wfsdb\\t%v0,%v1,%v2\n    wfssb\\t%v0,%v1,%v2\"\n   [(set_attr \"op_type\"      \"RRF,RRE,RXE,VRR,VRR\")\n-   (set_attr \"type\"         \"fsimp<mode>\")\n+   (set_attr \"type\"         \"fsimp<type>\")\n    (set_attr \"cpu_facility\" \"*,*,*,vx,vxe\")\n    (set_attr \"enabled\"      \"<nBFP>,<nDFP>,<DSF>,<DF>,<SF>\")])\n \n@@ -6593,7 +6638,7 @@\n    s<xde>br\\t%0,%2\n    s<xde>b\\t%0,%2\"\n   [(set_attr \"op_type\"  \"RRF,RRE,RXE\")\n-   (set_attr \"type\"     \"fsimp<mode>\")\n+   (set_attr \"type\"     \"fsimp<type>\")\n    (set_attr \"enabled\"  \"<nBFP>,<nDFP>,<DSF>\")])\n \n ; sxbr, sdbr, sebr, sdb, seb, sxtr, sdtr\n@@ -6609,7 +6654,7 @@\n    s<xde>br\\t%0,%2\n    s<xde>b\\t%0,%2\"\n   [(set_attr \"op_type\"  \"RRF,RRE,RXE\")\n-   (set_attr \"type\"     \"fsimp<mode>\")\n+   (set_attr \"type\"     \"fsimp<type>\")\n    (set_attr \"enabled\"  \"<nBFP>,<nDFP>,<DSF>\")])\n \n \n@@ -7143,7 +7188,7 @@\n ;\n \n ; mxbr, mdbr, meebr, mxb, mxb, meeb, mdtr, mxtr\n-(define_insn \"mul<mode>3\"\n+(define_insn \"mul<mode>3<tf_fpr>\"\n   [(set (match_operand:FP          0 \"register_operand\"     \"=f,f,f,v,v\")\n         (mult:FP (match_operand:FP 1 \"nonimmediate_operand\" \"%f,0,0,v,v\")\n \t\t (match_operand:FP 2 \"general_operand\"       \"f,f,R,v,v\")))]\n@@ -7155,7 +7200,7 @@\n    wfmdb\\t%v0,%v1,%v2\n    wfmsb\\t%v0,%v1,%v2\"\n   [(set_attr \"op_type\"      \"RRF,RRE,RXE,VRR,VRR\")\n-   (set_attr \"type\"         \"fmul<mode>\")\n+   (set_attr \"type\"         \"fmul<type>\")\n    (set_attr \"cpu_facility\" \"*,*,*,vx,vxe\")\n    (set_attr \"enabled\"      \"<nBFP>,<nDFP>,<DSF>,<DF>,<SF>\")])\n \n@@ -7165,7 +7210,7 @@\n \t(fma:DSF (match_operand:DSF 1 \"nonimmediate_operand\" \"%f,f,v,v\")\n \t\t (match_operand:DSF 2 \"nonimmediate_operand\"  \"f,R,v,v\")\n \t\t (match_operand:DSF 3 \"register_operand\"      \"0,0,v,v\")))]\n-  \"TARGET_HARD_FLOAT\"\n+  \"TARGET_HARD_FLOAT && s390_fma_allowed_p (<MODE>mode)\"\n   \"@\n    ma<xde>br\\t%0,%1,%2\n    ma<xde>b\\t%0,%1,%2\n@@ -7182,7 +7227,7 @@\n \t(fma:DSF (match_operand:DSF          1 \"nonimmediate_operand\" \"%f,f,v,v\")\n \t\t (match_operand:DSF          2 \"nonimmediate_operand\"  \"f,R,v,v\")\n \t\t (neg:DSF (match_operand:DSF 3 \"register_operand\"      \"0,0,v,v\"))))]\n-  \"TARGET_HARD_FLOAT\"\n+  \"TARGET_HARD_FLOAT && s390_fma_allowed_p (<MODE>mode)\"\n   \"@\n    ms<xde>br\\t%0,%1,%2\n    ms<xde>b\\t%0,%1,%2\n@@ -7448,7 +7493,7 @@\n ;\n \n ; dxbr, ddbr, debr, dxb, ddb, deb, ddtr, dxtr\n-(define_insn \"div<mode>3\"\n+(define_insn \"div<mode>3<tf_fpr>\"\n   [(set (match_operand:FP         0 \"register_operand\" \"=f,f,f,v,v\")\n         (div:FP (match_operand:FP 1 \"register_operand\"  \"f,0,0,v,v\")\n \t\t(match_operand:FP 2 \"general_operand\"   \"f,f,R,v,v\")))]\n@@ -7460,7 +7505,7 @@\n    wfddb\\t%v0,%v1,%v2\n    wfdsb\\t%v0,%v1,%v2\"\n   [(set_attr \"op_type\"      \"RRF,RRE,RXE,VRR,VRR\")\n-   (set_attr \"type\"         \"fdiv<mode>\")\n+   (set_attr \"type\"         \"fdiv<type>\")\n    (set_attr \"cpu_facility\" \"*,*,*,vx,vxe\")\n    (set_attr \"enabled\"      \"<nBFP>,<nDFP>,<DSF>,<DF>,<SF>\")])\n \n@@ -8777,10 +8822,10 @@\n    operands[6] = gen_label_rtx ();\")\n \n ;\n-; neg(df|sf)2 instruction pattern(s).\n+; neg(tf|df|sf)2 instruction pattern(s).\n ;\n \n-(define_expand \"neg<mode>2\"\n+(define_expand \"neg<mode>2<tf_fpr>\"\n   [(parallel\n     [(set (match_operand:BFP          0 \"register_operand\")\n           (neg:BFP (match_operand:BFP 1 \"register_operand\")))\n@@ -8797,7 +8842,7 @@\n   \"s390_match_ccmode (insn, CCSmode) && TARGET_HARD_FLOAT\"\n   \"lc<xde>br\\t%0,%1\"\n   [(set_attr \"op_type\"  \"RRE\")\n-   (set_attr \"type\"     \"fsimp<mode>\")])\n+   (set_attr \"type\"     \"fsimp<type>\")])\n \n ; lcxbr, lcdbr, lcebr\n (define_insn \"*neg<mode>2_cconly\"\n@@ -8808,7 +8853,7 @@\n   \"s390_match_ccmode (insn, CCSmode) && TARGET_HARD_FLOAT\"\n   \"lc<xde>br\\t%0,%1\"\n   [(set_attr \"op_type\"  \"RRE\")\n-   (set_attr \"type\"     \"fsimp<mode>\")])\n+   (set_attr \"type\"     \"fsimp<type>\")])\n \n ; lcdfr\n (define_insn \"*neg<mode>2_nocc\"\n@@ -8817,7 +8862,7 @@\n   \"TARGET_DFP\"\n   \"lcdfr\\t%0,%1\"\n   [(set_attr \"op_type\"  \"RRE\")\n-   (set_attr \"type\"     \"fsimp<mode>\")])\n+   (set_attr \"type\"     \"fsimp<type>\")])\n \n ; lcxbr, lcdbr, lcebr\n ; FIXME: wflcdb does not clobber cc\n@@ -8833,7 +8878,7 @@\n    wflcsb\\t%0,%1\"\n   [(set_attr \"op_type\"      \"RRE,VRR,VRR\")\n    (set_attr \"cpu_facility\" \"*,vx,vxe\")\n-   (set_attr \"type\"         \"fsimp<mode>,*,*\")\n+   (set_attr \"type\"         \"fsimp<type>,*,*\")\n    (set_attr \"enabled\"      \"*,<DF>,<SF>\")])\n \n \n@@ -8901,10 +8946,10 @@\n    (set_attr \"z10prop\" \"z10_c\")])\n \n ;\n-; abs(df|sf)2 instruction pattern(s).\n+; abs(tf|df|sf)2 instruction pattern(s).\n ;\n \n-(define_expand \"abs<mode>2\"\n+(define_expand \"abs<mode>2<tf_fpr>\"\n   [(parallel\n     [(set (match_operand:BFP 0 \"register_operand\" \"=f\")\n           (abs:BFP (match_operand:BFP 1 \"register_operand\" \"f\")))\n@@ -8922,7 +8967,7 @@\n   \"s390_match_ccmode (insn, CCSmode) && TARGET_HARD_FLOAT\"\n   \"lp<xde>br\\t%0,%1\"\n   [(set_attr \"op_type\"  \"RRE\")\n-   (set_attr \"type\"     \"fsimp<mode>\")])\n+   (set_attr \"type\"     \"fsimp<type>\")])\n \n ; lpxbr, lpdbr, lpebr\n (define_insn \"*abs<mode>2_cconly\"\n@@ -8933,7 +8978,7 @@\n   \"s390_match_ccmode (insn, CCSmode) && TARGET_HARD_FLOAT\"\n   \"lp<xde>br\\t%0,%1\"\n   [(set_attr \"op_type\"  \"RRE\")\n-   (set_attr \"type\"     \"fsimp<mode>\")])\n+   (set_attr \"type\"     \"fsimp<type>\")])\n \n ; lpdfr\n (define_insn \"*abs<mode>2_nocc\"\n@@ -8942,7 +8987,7 @@\n   \"TARGET_DFP\"\n   \"lpdfr\\t%0,%1\"\n   [(set_attr \"op_type\"  \"RRE\")\n-   (set_attr \"type\"     \"fsimp<mode>\")])\n+   (set_attr \"type\"     \"fsimp<type>\")])\n \n ; lpxbr, lpdbr, lpebr\n ; FIXME: wflpdb does not clobber cc\n@@ -8956,7 +9001,7 @@\n     wflpdb\\t%0,%1\"\n   [(set_attr \"op_type\"      \"RRE,VRR\")\n    (set_attr \"cpu_facility\" \"*,vx\")\n-   (set_attr \"type\"         \"fsimp<mode>,*\")\n+   (set_attr \"type\"         \"fsimp<type>,*\")\n    (set_attr \"enabled\"      \"*,<DFDI>\")])\n \n \n@@ -9038,7 +9083,7 @@\n   \"s390_match_ccmode (insn, CCSmode) && TARGET_HARD_FLOAT\"\n   \"ln<xde>br\\t%0,%1\"\n   [(set_attr \"op_type\"  \"RRE\")\n-   (set_attr \"type\"     \"fsimp<mode>\")])\n+   (set_attr \"type\"     \"fsimp<type>\")])\n \n ; lnxbr, lndbr, lnebr\n (define_insn \"*negabs<mode>2_cconly\"\n@@ -9049,7 +9094,7 @@\n   \"s390_match_ccmode (insn, CCSmode) && TARGET_HARD_FLOAT\"\n   \"ln<xde>br\\t%0,%1\"\n   [(set_attr \"op_type\"  \"RRE\")\n-   (set_attr \"type\"     \"fsimp<mode>\")])\n+   (set_attr \"type\"     \"fsimp<type>\")])\n \n ; lndfr\n (define_insn \"*negabs<mode>2_nocc\"\n@@ -9058,7 +9103,7 @@\n   \"TARGET_DFP\"\n   \"lndfr\\t%0,%1\"\n   [(set_attr \"op_type\"  \"RRE\")\n-   (set_attr \"type\"     \"fsimp<mode>\")])\n+   (set_attr \"type\"     \"fsimp<type>\")])\n \n ; lnxbr, lndbr, lnebr\n ; FIXME: wflndb does not clobber cc\n@@ -9072,7 +9117,7 @@\n    wflndb\\t%0,%1\"\n   [(set_attr \"op_type\"      \"RRE,VRR\")\n    (set_attr \"cpu_facility\" \"*,vx\")\n-   (set_attr \"type\"         \"fsimp<mode>,*\")\n+   (set_attr \"type\"         \"fsimp<type>,*\")\n    (set_attr \"enabled\"      \"*,<DFDI>\")])\n \n ;;\n@@ -9084,7 +9129,7 @@\n ;\n \n ; sqxbr, sqdbr, sqebr, sqdb, sqeb\n-(define_insn \"sqrt<mode>2\"\n+(define_insn \"sqrt<mode>2<tf_fpr>\"\n   [(set (match_operand:BFP           0 \"register_operand\" \"=f,f,v\")\n \t(sqrt:BFP (match_operand:BFP 1 \"general_operand\"   \"f,R,v\")))]\n   \"TARGET_HARD_FLOAT\"\n@@ -9093,7 +9138,7 @@\n    sq<xde>b\\t%0,%1\n    wfsqdb\\t%v0,%v1\"\n   [(set_attr \"op_type\"      \"RRE,RXE,VRR\")\n-   (set_attr \"type\"         \"fsqrt<mode>\")\n+   (set_attr \"type\"         \"fsqrt<type>\")\n    (set_attr \"cpu_facility\" \"*,*,vx\")\n    (set_attr \"enabled\"      \"*,<DSF>,<DFDI>\")])\n \n@@ -9294,8 +9339,8 @@\n (define_expand \"cbranch<mode>4\"\n   [(set (pc)\n         (if_then_else (match_operator 0 \"comparison_operator\"\n-        \t       [(match_operand:FP 1 \"register_operand\" \"\")\n-                        (match_operand:FP 2 \"general_operand\" \"\")])\n+\t\t       [(match_operand:FP_ANYTF 1 \"register_operand\" \"\")\n+\t\t\t(match_operand:FP_ANYTF 2 \"general_operand\" \"\")])\n \t\t      (label_ref (match_operand 3 \"\" \"\"))\n                       (pc)))]\n   \"TARGET_HARD_FLOAT\"\n@@ -11790,15 +11835,15 @@\n ;;- Copy sign instructions\n ;;\n \n-(define_insn \"copysign<mode>3\"\n+(define_insn \"copysign<mode>3<tf_fpr>\"\n   [(set (match_operand:FP 0 \"register_operand\" \"=f\")\n       (unspec:FP [(match_operand:FP 1 \"register_operand\" \"<fT0>\")\n                   (match_operand:FP 2 \"register_operand\" \"f\")]\n                   UNSPEC_COPYSIGN))]\n   \"TARGET_Z196\"\n   \"cpsdr\\t%0,%2,%1\"\n   [(set_attr \"op_type\"  \"RRF\")\n-   (set_attr \"type\"     \"fsimp<mode>\")])\n+   (set_attr \"type\"     \"fsimp<type>\")])\n \n \n ;;"}, {"sha": "0afcea3c3febe29d093e011e8dc9543db66ce6cf", "filename": "gcc/config/s390/s390.opt", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e627cda5686592235dd38e461e73f2d6e8d24cd5/gcc%2Fconfig%2Fs390%2Fs390.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e627cda5686592235dd38e461e73f2d6e8d24cd5/gcc%2Fconfig%2Fs390%2Fs390.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.opt?ref=e627cda5686592235dd38e461e73f2d6e8d24cd5", "patch": "@@ -304,3 +304,14 @@ mnop-mcount\n Target Report Var(flag_nop_mcount)\n Generate mcount/__fentry__ calls as nops. To activate they need to be\n patched in.\n+\n+mvx-long-double-fma\n+Target Report Undocumented Var(flag_vx_long_double_fma)\n+Emit fused multiply-add instructions for long doubles in vector registers\n+(wfmaxb, wfmsxb, wfnmaxb, wfnmsxb).  Reassociation pass does not handle\n+fused multiply-adds, therefore code generated by the middle-end is prone to\n+having long fused multiply-add chains.  This is not pipeline-friendly,\n+and the default behavior is to emit separate multiplication and addition\n+instructions for long doubles in vector registers, because measurements show\n+that this improves performance.  This option allows overriding it for testing\n+purposes."}, {"sha": "31d323930b203785ea4f348bb74009c3a73f23d7", "filename": "gcc/config/s390/vector.md", "status": "modified", "additions": 358, "deletions": 24, "changes": 382, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e627cda5686592235dd38e461e73f2d6e8d24cd5/gcc%2Fconfig%2Fs390%2Fvector.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e627cda5686592235dd38e461e73f2d6e8d24cd5/gcc%2Fconfig%2Fs390%2Fvector.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fvector.md?ref=e627cda5686592235dd38e461e73f2d6e8d24cd5", "patch": "@@ -27,10 +27,14 @@\n    V2SF V4SF V1DF V2DF V1TF V1TI TI])\n \n ; All modes directly supported by the hardware having full vector reg size\n-; V_HW2 is duplicate of V_HW for having two iterators expanding\n-; independently e.g. vcond\n-(define_mode_iterator V_HW  [V16QI V8HI V4SI V2DI (V1TI \"TARGET_VXE\") V2DF (V4SF \"TARGET_VXE\") (V1TF \"TARGET_VXE\")])\n-(define_mode_iterator V_HW2 [V16QI V8HI V4SI V2DI V2DF (V4SF \"TARGET_VXE\") (V1TF \"TARGET_VXE\")])\n+; V_HW2 is for having two iterators expanding independently e.g. vcond.\n+; It's similar to V_HW, but not fully identical: V1TI is not included, because\n+; there are no 128-bit compares.\n+(define_mode_iterator V_HW  [V16QI V8HI V4SI V2DI (V1TI \"TARGET_VXE\") V2DF\n+\t\t\t     (V4SF \"TARGET_VXE\") (V1TF \"TARGET_VXE\")\n+\t\t\t     (TF \"TARGET_VXE\")])\n+(define_mode_iterator V_HW2 [V16QI V8HI V4SI V2DI V2DF (V4SF \"TARGET_VXE\")\n+\t\t\t     (V1TF \"TARGET_VXE\") (TF \"TARGET_VXE\")])\n \n (define_mode_iterator V_HW_64 [V2DI V2DF])\n (define_mode_iterator VT_HW_HSDT [V8HI V4SI V4SF V2DI V2DF V1TI V1TF TI TF])\n@@ -55,19 +59,20 @@\n \n (define_mode_iterator VFT [(V1SF \"TARGET_VXE\") (V2SF \"TARGET_VXE\") (V4SF \"TARGET_VXE\")\n \t\t\t   V1DF V2DF\n-\t\t\t   (V1TF \"TARGET_VXE\")])\n+\t\t\t   (V1TF \"TARGET_VXE\") (TF \"TARGET_VXE\")])\n \n ; FP vector modes directly supported by the HW.  This does not include\n ; vector modes using only part of a vector register and should be used\n ; for instructions which might trigger IEEE exceptions.\n-(define_mode_iterator VF_HW [(V4SF \"TARGET_VXE\") V2DF (V1TF \"TARGET_VXE\")])\n+(define_mode_iterator VF_HW [(V4SF \"TARGET_VXE\") V2DF (V1TF \"TARGET_VXE\")\n+\t\t\t     (TF \"TARGET_VXE\")])\n \n (define_mode_iterator V_8   [V1QI])\n (define_mode_iterator V_16  [V2QI  V1HI])\n (define_mode_iterator V_32  [V4QI  V2HI V1SI V1SF])\n (define_mode_iterator V_64  [V8QI  V4HI V2SI V2SF V1DI V1DF])\n-(define_mode_iterator V_128 [V16QI V8HI V4SI V4SF V2DI V2DF V1TI V1TF])\n-\n+(define_mode_iterator V_128 [V16QI V8HI V4SI V4SF V2DI V2DF V1TI V1TF\n+\t\t\t     (TF \"TARGET_VXE\")])\n (define_mode_iterator V_128_NOSINGLE [V16QI V8HI V4SI V4SF V2DI V2DF])\n \n ; 32 bit int<->fp vector conversion instructions are available since VXE2 (z15).\n@@ -86,6 +91,11 @@\n \t\t       (V1DF \"\")  (V2DF \"\")\n \t\t       (V1TF \"\")  (TF \"\")])\n \n+;; Facilitate dispatching TFmode expanders on z14+.\n+(define_mode_attr tf_vr [(TF \"_vr\") (V4SF \"\") (V2DF \"\") (V1TF \"\") (V1SF \"\")\n+\t\t\t (V2SF \"\") (V1DF \"\") (V16QI \"\") (V8HI \"\") (V4SI \"\")\n+\t\t\t (V2DI \"\") (V1TI \"\")])\n+\n ; The element type of the vector.\n (define_mode_attr non_vec[(V1QI \"QI\") (V2QI \"QI\") (V4QI \"QI\") (V8QI \"QI\") (V16QI \"QI\")\n \t\t\t  (V1HI \"HI\") (V2HI \"HI\") (V4HI \"HI\") (V8HI \"HI\")\n@@ -134,7 +144,7 @@\n \t\t\t    (V1TI \"V1TI\")\n \t\t\t    (V1SF \"V1SI\") (V2SF \"V2SI\") (V4SF \"V4SI\")\n \t\t\t    (V1DF \"V1DI\") (V2DF \"V2DI\")\n-\t\t\t    (V1TF \"V1TI\")])\n+\t\t\t    (V1TF \"V1TI\") (TF \"V1TI\")])\n (define_mode_attr vw [(SF \"w\") (V1SF \"w\") (V2SF \"v\") (V4SF \"v\")\n \t\t      (DF \"w\") (V1DF \"w\") (V2DF \"v\")\n \t\t      (TF \"w\") (V1TF \"w\")])\n@@ -194,7 +204,7 @@\n ; for TImode (use double-int for the calculations)\n \n ; vgmb, vgmh, vgmf, vgmg, vrepib, vrepih, vrepif, vrepig\n-(define_insn \"mov<mode>\"\n+(define_insn \"mov<mode><tf_vr>\"\n   [(set (match_operand:V_128 0 \"nonimmediate_operand\" \"=v,v,R,  v,  v,  v,  v,  v,v,*d,*d,?o\")\n \t(match_operand:V_128 1 \"general_operand\"      \" v,R,v,j00,jm1,jyy,jxx,jKK,d, v,dT,*d\"))]\n   \"\"\n@@ -214,6 +224,12 @@\n   [(set_attr \"cpu_facility\" \"vx,vx,vx,vx,vx,vx,vx,vx,vx,vx,*,*\")\n    (set_attr \"op_type\"      \"VRR,VRX,VRX,VRI,VRI,VRI,VRI,VRI,VRR,*,*,*\")])\n \n+(define_expand \"movtf\"\n+  [(match_operand:TF 0 \"nonimmediate_operand\" \"\")\n+   (match_operand:TF 1 \"general_operand\"      \"\")]\n+  \"\"\n+  { EXPAND_MOVTF(movtf); })\n+\n ; VR -> GPR, no instruction so split it into 64 element sets.\n (define_split\n   [(set (match_operand:V_128 0 \"register_operand\" \"\")\n@@ -565,10 +581,10 @@\n \n ; A TFmode operand resides in FPR register pairs while V1TF is in a\n ; single vector register.\n-(define_insn \"*vec_tf_to_v1tf\"\n+(define_insn \"*vec_tf_to_v1tf_fpr\"\n   [(set (match_operand:V1TF                   0 \"nonimmediate_operand\" \"=v,v,R,v,v\")\n \t(vec_duplicate:V1TF (match_operand:TF 1 \"general_operand\"       \"f,R,f,G,d\")))]\n-  \"TARGET_VX\"\n+  \"TARGET_VX && !TARGET_VXE\"\n   \"@\n    vmrhg\\t%v0,%1,%N1\n    vl\\t%v0,%1%A1\n@@ -577,6 +593,26 @@\n    vlvgp\\t%v0,%1,%N1\"\n   [(set_attr \"op_type\" \"VRR,VRX,VRX,VRI,VRR\")])\n \n+; Both TFmode and V1TFmode operands reside in vector registers.\n+(define_insn \"*vec_tf_to_v1tf_vr\"\n+  [(set (match_operand:V1TF                   0 \"nonimmediate_operand\" \"=v,v,R,v,v\")\n+\t(vec_duplicate:V1TF (match_operand:TF 1 \"general_operand\"       \"v,R,v,G,d\")))]\n+  \"TARGET_VXE\"\n+  \"@\n+   vlr\\t%v0,%1\n+   vl\\t%v0,%1%A1\n+   vst\\t%v1,%0%A0\n+   vzero\\t%v0\n+   vlvgp\\t%v0,%1,%N1\"\n+  [(set_attr \"op_type\" \"VRR,VRX,VRX,VRI,VRR\")])\n+\n+(define_insn \"*fprx2_to_tf\"\n+  [(set (match_operand:TF               0 \"nonimmediate_operand\" \"=v\")\n+\t(subreg:TF (match_operand:FPRX2 1 \"general_operand\"       \"f\") 0))]\n+  \"TARGET_VXE\"\n+  \"vmrhg\\t%v0,%1,%N1\"\n+  [(set_attr \"op_type\" \"VRR\")])\n+\n (define_insn \"*vec_ti_to_v1ti\"\n   [(set (match_operand:V1TI                   0 \"nonimmediate_operand\" \"=v,v,R,  v,  v,v\")\n \t(vec_duplicate:V1TI (match_operand:TI 1 \"general_operand\"       \"v,R,v,j00,jm1,d\")))]\n@@ -691,6 +727,21 @@\n   \"vperm\\t%v0,%v1,%v2,%v3\"\n   [(set_attr \"op_type\" \"VRR\")])\n \n+(define_insn \"*mov_tf_to_fprx2_0\"\n+  [(set (subreg:DF (match_operand:FPRX2 0 \"nonimmediate_operand\" \"=f\") 0)\n+\t(subreg:DF (match_operand:TF    1 \"general_operand\"       \"v\") 0))]\n+  \"TARGET_VXE\"\n+  ; M4 == 1 corresponds to %v0[0] = %v1[0]; %v0[1] = %v0[1];\n+  \"vpdi\\t%v0,%v1,%v0,1\"\n+  [(set_attr \"op_type\" \"VRR\")])\n+\n+(define_insn \"*mov_tf_to_fprx2_1\"\n+  [(set (subreg:DF (match_operand:FPRX2 0 \"nonimmediate_operand\" \"=f\") 8)\n+\t(subreg:DF (match_operand:TF    1 \"general_operand\"       \"v\") 8))]\n+  \"TARGET_VXE\"\n+  ; M4 == 5 corresponds to %V0[0] = %v1[1]; %V0[1] = %V0[1];\n+  \"vpdi\\t%V0,%v1,%V0,5\"\n+  [(set_attr \"op_type\" \"VRR\")])\n \n ; vec_perm_const for V2DI using vpdi?\n \n@@ -1253,56 +1304,90 @@\n ;;\n \n ; vfasb, vfadb, wfasb, wfadb, wfaxb\n-(define_insn \"add<mode>3\"\n+(define_insn \"add<mode>3<tf_vr>\"\n   [(set (match_operand:VF_HW             0 \"register_operand\" \"=v\")\n \t(plus:VF_HW (match_operand:VF_HW 1 \"register_operand\"  \"v\")\n \t\t    (match_operand:VF_HW 2 \"register_operand\"  \"v\")))]\n   \"TARGET_VX\"\n   \"<vw>fa<sdx>b\\t%v0,%v1,%v2\"\n   [(set_attr \"op_type\" \"VRR\")])\n \n+(define_expand \"addtf3\"\n+  [(match_operand:TF 0 \"register_operand\"     \"\")\n+   (match_operand:TF 1 \"nonimmediate_operand\" \"\")\n+   (match_operand:TF 2 \"general_operand\"      \"\")]\n+  \"HAVE_TF (addtf3)\"\n+  { EXPAND_TF (addtf3, 3); })\n+\n ; vfssb, vfsdb, wfssb, wfsdb, wfsxb\n-(define_insn \"sub<mode>3\"\n+(define_insn \"sub<mode>3<tf_vr>\"\n   [(set (match_operand:VF_HW              0 \"register_operand\" \"=v\")\n \t(minus:VF_HW (match_operand:VF_HW 1 \"register_operand\"  \"v\")\n \t\t     (match_operand:VF_HW 2 \"register_operand\"  \"v\")))]\n   \"TARGET_VX\"\n   \"<vw>fs<sdx>b\\t%v0,%v1,%v2\"\n   [(set_attr \"op_type\" \"VRR\")])\n \n+(define_expand \"subtf3\"\n+  [(match_operand:TF 0 \"register_operand\" \"\")\n+   (match_operand:TF 1 \"register_operand\" \"\")\n+   (match_operand:TF 2 \"general_operand\"  \"\")]\n+  \"HAVE_TF (subtf3)\"\n+  { EXPAND_TF (subtf3, 3); })\n+\n ; vfmsb, vfmdb, wfmsb, wfmdb, wfmxb\n-(define_insn \"mul<mode>3\"\n+(define_insn \"mul<mode>3<tf_vr>\"\n   [(set (match_operand:VF_HW             0 \"register_operand\" \"=v\")\n \t(mult:VF_HW (match_operand:VF_HW 1 \"register_operand\"  \"v\")\n \t\t    (match_operand:VF_HW 2 \"register_operand\"  \"v\")))]\n   \"TARGET_VX\"\n   \"<vw>fm<sdx>b\\t%v0,%v1,%v2\"\n   [(set_attr \"op_type\" \"VRR\")])\n \n+(define_expand \"multf3\"\n+  [(match_operand:TF 0 \"register_operand\"     \"\")\n+   (match_operand:TF 1 \"nonimmediate_operand\" \"\")\n+   (match_operand:TF 2 \"general_operand\"      \"\")]\n+  \"HAVE_TF (multf3)\"\n+  { EXPAND_TF (multf3, 3); })\n+\n ; vfdsb, vfddb, wfdsb, wfddb, wfdxb\n-(define_insn \"div<mode>3\"\n+(define_insn \"div<mode>3<tf_vr>\"\n   [(set (match_operand:VF_HW            0 \"register_operand\" \"=v\")\n \t(div:VF_HW (match_operand:VF_HW 1 \"register_operand\"  \"v\")\n \t\t   (match_operand:VF_HW 2 \"register_operand\"  \"v\")))]\n   \"TARGET_VX\"\n   \"<vw>fd<sdx>b\\t%v0,%v1,%v2\"\n   [(set_attr \"op_type\" \"VRR\")])\n \n+(define_expand \"divtf3\"\n+  [(match_operand:TF 0 \"register_operand\" \"\")\n+   (match_operand:TF 1 \"register_operand\" \"\")\n+   (match_operand:TF 2 \"general_operand\"  \"\")]\n+  \"HAVE_TF (divtf3)\"\n+  { EXPAND_TF (divtf3, 3); })\n+\n ; vfsqsb, vfsqdb, wfsqsb, wfsqdb, wfsqxb\n-(define_insn \"sqrt<mode>2\"\n-  [(set (match_operand:VF_HW           0 \"register_operand\" \"=v\")\n+(define_insn \"sqrt<mode>2<tf_vr>\"\n+  [(set (match_operand:VF_HW             0 \"register_operand\" \"=v\")\n \t(sqrt:VF_HW (match_operand:VF_HW 1 \"register_operand\"  \"v\")))]\n   \"TARGET_VX\"\n   \"<vw>fsq<sdx>b\\t%v0,%v1\"\n   [(set_attr \"op_type\" \"VRR\")])\n \n+(define_expand \"sqrttf2\"\n+  [(match_operand:TF 0 \"register_operand\" \"\")\n+   (match_operand:TF 1 \"general_operand\"  \"\")]\n+  \"HAVE_TF (sqrttf2)\"\n+  { EXPAND_TF (sqrttf2, 2); })\n+\n ; vfmasb, vfmadb, wfmasb, wfmadb, wfmaxb\n (define_insn \"fma<mode>4\"\n   [(set (match_operand:VF_HW            0 \"register_operand\" \"=v\")\n \t(fma:VF_HW (match_operand:VF_HW 1 \"register_operand\"  \"v\")\n \t\t   (match_operand:VF_HW 2 \"register_operand\"  \"v\")\n \t\t   (match_operand:VF_HW 3 \"register_operand\"  \"v\")))]\n-  \"TARGET_VX\"\n+  \"TARGET_VX && s390_fma_allowed_p (<MODE>mode)\"\n   \"<vw>fma<sdx>b\\t%v0,%v1,%v2,%v3\"\n   [(set_attr \"op_type\" \"VRR\")])\n \n@@ -1312,7 +1397,7 @@\n \t(fma:VF_HW (match_operand:VF_HW          1 \"register_operand\"  \"v\")\n \t\t   (match_operand:VF_HW          2 \"register_operand\"  \"v\")\n \t\t (neg:VF_HW (match_operand:VF_HW 3 \"register_operand\"  \"v\"))))]\n-  \"TARGET_VX\"\n+  \"TARGET_VX && s390_fma_allowed_p (<MODE>mode)\"\n   \"<vw>fms<sdx>b\\t%v0,%v1,%v2,%v3\"\n   [(set_attr \"op_type\" \"VRR\")])\n \n@@ -1323,7 +1408,7 @@\n \t (fma:VF_HW (match_operand:VF_HW 1 \"register_operand\"  \"v\")\n \t\t    (match_operand:VF_HW 2 \"register_operand\"  \"v\")\n \t\t    (match_operand:VF_HW 3 \"register_operand\"  \"v\"))))]\n-  \"TARGET_VXE\"\n+  \"TARGET_VXE && s390_fma_allowed_p (<MODE>mode)\"\n   \"<vw>fnma<sdx>b\\t%v0,%v1,%v2,%v3\"\n   [(set_attr \"op_type\" \"VRR\")])\n \n@@ -1334,26 +1419,38 @@\n \t (fma:VF_HW (match_operand:VF_HW          1 \"register_operand\"  \"v\")\n \t\t    (match_operand:VF_HW          2 \"register_operand\"  \"v\")\n \t\t  (neg:VF_HW (match_operand:VF_HW 3 \"register_operand\"  \"v\")))))]\n-  \"TARGET_VXE\"\n+  \"TARGET_VXE && s390_fma_allowed_p (<MODE>mode)\"\n   \"<vw>fnms<sdx>b\\t%v0,%v1,%v2,%v3\"\n   [(set_attr \"op_type\" \"VRR\")])\n \n ; vflcsb, vflcdb, wflcsb, wflcdb, wflcxb\n-(define_insn \"neg<mode>2\"\n+(define_insn \"neg<mode>2<tf_vr>\"\n   [(set (match_operand:VFT          0 \"register_operand\" \"=v\")\n \t(neg:VFT (match_operand:VFT 1 \"register_operand\"  \"v\")))]\n   \"TARGET_VX\"\n   \"<vw>flc<sdx>b\\t%v0,%v1\"\n   [(set_attr \"op_type\" \"VRR\")])\n \n+(define_expand \"negtf2\"\n+  [(match_operand:TF 0 \"register_operand\" \"\")\n+   (match_operand:TF 1 \"register_operand\" \"\")]\n+  \"HAVE_TF (negtf2)\"\n+  { EXPAND_TF (negtf2, 2); })\n+\n ; vflpsb, vflpdb, wflpsb, wflpdb, wflpxb\n-(define_insn \"abs<mode>2\"\n+(define_insn \"abs<mode>2<tf_vr>\"\n   [(set (match_operand:VFT          0 \"register_operand\" \"=v\")\n \t(abs:VFT (match_operand:VFT 1 \"register_operand\"  \"v\")))]\n   \"TARGET_VX\"\n   \"<vw>flp<sdx>b\\t%v0,%v1\"\n   [(set_attr \"op_type\" \"VRR\")])\n \n+(define_expand \"abstf2\"\n+  [(match_operand:TF 0 \"register_operand\" \"\")\n+   (match_operand:TF 1 \"register_operand\" \"\")]\n+  \"HAVE_TF (abstf2)\"\n+  { EXPAND_TF (abstf2, 2); })\n+\n ; vflnsb, vflndb, wflnsb, wflndb, wflnxb\n (define_insn \"negabs<mode>2\"\n   [(set (match_operand:VFT                   0 \"register_operand\" \"=v\")\n@@ -2152,6 +2249,24 @@\n   \"vc<VX_VEC_CONV_BFP:xde><VX_VEC_CONV_INT:bhfgq>b\\t%v0,%v1,0,0\"\n   [(set_attr \"op_type\" \"VRR\")])\n \n+; There is no instruction for loading a signed integer into an extended BFP\n+; operand in a VR, therefore we need to load it into a FPR pair first.\n+(define_expand \"float<mode>tf2_vr\"\n+  [(set (match_dup 2)\n+\t(float:FPRX2 (match_operand:DSI 1 \"register_operand\" \"\")))\n+   (set (match_operand:TF               0 \"register_operand\" \"\")\n+\t(subreg:TF (match_dup 2) 0))]\n+  \"TARGET_VXE\"\n+{\n+  operands[2] = gen_reg_rtx (FPRX2mode);\n+})\n+\n+(define_expand \"float<mode>tf2\"\n+  [(match_operand:TF  0 \"register_operand\" \"\")\n+   (match_operand:DSI 1 \"register_operand\" \"\")]\n+  \"HAVE_TF (float<mode>tf2)\"\n+  { EXPAND_TF (float<mode>tf2, 2); })\n+\n ; unsigned integer to floating point\n \n ; op2: inexact exception not suppressed (IEEE 754 2008)\n@@ -2165,6 +2280,24 @@\n   \"vc<VX_VEC_CONV_BFP:xde>l<VX_VEC_CONV_INT:bhfgq>b\\t%v0,%v1,0,0\"\n   [(set_attr \"op_type\" \"VRR\")])\n \n+; There is no instruction for loading an unsigned integer into an extended BFP\n+; operand in a VR, therefore load it into a FPR pair first.\n+(define_expand \"floatuns<mode>tf2_vr\"\n+  [(set (match_dup 2)\n+\t(unsigned_float:FPRX2 (match_operand:GPR 1 \"register_operand\" \"\")))\n+   (set (match_operand:TF                        0 \"register_operand\" \"\")\n+\t(subreg:TF (match_dup 2) 0))]\n+  \"TARGET_VXE\"\n+{\n+  operands[2] = gen_reg_rtx (FPRX2mode);\n+})\n+\n+(define_expand \"floatuns<mode>tf2\"\n+  [(match_operand:TF  0 \"register_operand\" \"\")\n+   (match_operand:GPR 1 \"register_operand\" \"\")]\n+  \"HAVE_TF (floatuns<mode>tf2)\"\n+  { EXPAND_TF (floatuns<mode>tf2, 2); })\n+\n ; floating point to signed integer\n \n ; op2: inexact exception not suppressed (IEEE 754 2008)\n@@ -2178,6 +2311,27 @@\n   \"vc<VX_VEC_CONV_INT:bhfgq><VX_VEC_CONV_BFP:xde>b\\t%v0,%v1,0,5\"\n   [(set_attr \"op_type\" \"VRR\")])\n \n+; There is no instruction for rounding an extended BFP operand in a VR into\n+; a signed integer, therefore copy it into a FPR pair first.\n+(define_expand \"fix_trunctf<mode>2_vr\"\n+  [(set (subreg:DF (match_dup 2) 0)\n+\t(subreg:DF (match_operand:TF 1 \"register_operand\" \"\") 0))\n+   (set (subreg:DF (match_dup 2) 8) (subreg:DF (match_dup 1) 8))\n+   (parallel [(set (match_operand:GPR 0 \"register_operand\" \"\")\n+\t\t   (fix:GPR (match_dup 2)))\n+\t      (unspec:GPR [(const_int BFP_RND_TOWARD_0)] UNSPEC_ROUND)\n+\t      (clobber (reg:CC CC_REGNUM))])]\n+  \"TARGET_VXE\"\n+{\n+  operands[2] = gen_reg_rtx (FPRX2mode);\n+})\n+\n+(define_expand \"fix_trunctf<mode>2\"\n+  [(match_operand:GPR 0 \"register_operand\" \"\")\n+   (match_operand:TF  1 \"register_operand\" \"\")]\n+  \"HAVE_TF (fix_trunctf<mode>2)\"\n+  { EXPAND_TF (fix_trunctf<mode>2, 2); })\n+\n ; floating point to unsigned integer\n \n ; op2: inexact exception not suppressed (IEEE 754 2008)\n@@ -2191,6 +2345,186 @@\n   \"vcl<VX_VEC_CONV_INT:bhfgq><VX_VEC_CONV_BFP:xde>b\\t%v0,%v1,0,5\"\n   [(set_attr \"op_type\" \"VRR\")])\n \n+; There is no instruction for rounding an extended BFP operand in a VR into\n+; an unsigned integer, therefore copy it into a FPR pair first.\n+(define_expand \"fixuns_trunctf<mode>2_vr\"\n+  [(set (subreg:DF (match_dup 2) 0)\n+\t(subreg:DF (match_operand:TF 1 \"register_operand\" \"\") 0))\n+   (set (subreg:DF (match_dup 2) 8) (subreg:DF (match_dup 1) 8))\n+   (parallel [(set (match_operand:GPR 0 \"register_operand\" \"\")\n+\t\t   (unsigned_fix:GPR (match_dup 2)))\n+\t      (unspec:GPR [(const_int BFP_RND_TOWARD_0)] UNSPEC_ROUND)\n+\t      (clobber (reg:CC CC_REGNUM))])]\n+  \"TARGET_VXE\"\n+{\n+  operands[2] = gen_reg_rtx (FPRX2mode);\n+})\n+\n+(define_expand \"fixuns_trunctf<mode>2\"\n+  [(match_operand:GPR 0 \"register_operand\" \"\")\n+   (match_operand:TF  1 \"register_operand\" \"\")]\n+  \"HAVE_TF (fixuns_trunctf<mode>2)\"\n+  { EXPAND_TF (fixuns_trunctf<mode>2, 2); })\n+\n+; load fp integer\n+\n+; vfisb, wfisb, vfidb, wfidb, wfixb; suppress inexact exceptions\n+(define_insn \"<FPINT:fpint_name><VF_HW:mode>2<VF_HW:tf_vr>\"\n+  [(set (match_operand:VF_HW                0 \"register_operand\" \"=v\")\n+\t(unspec:VF_HW [(match_operand:VF_HW 1 \"register_operand\"  \"v\")]\n+\t\t      FPINT))]\n+  \"TARGET_VX\"\n+  \"<vw>fi<VF_HW:sdx>b\\t%v0,%v1,4,<FPINT:fpint_roundingmode>\"\n+  [(set_attr \"op_type\" \"VRR\")])\n+\n+(define_expand \"<FPINT:fpint_name>tf2\"\n+  [(match_operand:TF 0 \"register_operand\" \"\")\n+   (match_operand:TF 1 \"register_operand\" \"\")\n+   ; recognize FPINT as an iterator\n+   (unspec:TF [(match_dup 1)] FPINT)]\n+  \"HAVE_TF (<FPINT:fpint_name>tf2)\"\n+  { EXPAND_TF (<FPINT:fpint_name>tf2, 2); })\n+\n+; vfisb, wfisb, vfidb, wfidb, wfixb; raise inexact exceptions\n+(define_insn \"rint<mode>2<tf_vr>\"\n+  [(set (match_operand:VF_HW                0 \"register_operand\" \"=v\")\n+\t(unspec:VF_HW [(match_operand:VF_HW 1 \"register_operand\"  \"v\")]\n+\t\t      UNSPEC_FPINT_RINT))]\n+  \"TARGET_VX\"\n+  \"<vw>fi<sdx>b\\t%v0,%v1,0,0\"\n+  [(set_attr \"op_type\" \"VRR\")])\n+\n+(define_expand \"rinttf2\"\n+  [(match_operand:TF 0 \"register_operand\" \"\")\n+   (match_operand:TF 1 \"register_operand\" \"\")]\n+  \"HAVE_TF (rinttf2)\"\n+  { EXPAND_TF (rinttf2, 2); })\n+\n+; load rounded\n+\n+; wflrx\n+(define_insn \"*trunctfdf2_vr\"\n+  [(set (match_operand:DF                    0 \"register_operand\" \"=f\")\n+\t(float_truncate:DF (match_operand:TF 1 \"register_operand\"  \"v\")))\n+   (unspec:DF [(match_operand                2 \"const_int_operand\" \"\")]\n+\t       UNSPEC_ROUND)]\n+  \"TARGET_VXE\"\n+  \"wflrx\\t%v0,%v1,0,%2\"\n+  [(set_attr \"op_type\" \"VRR\")])\n+\n+(define_expand \"trunctfdf2_vr\"\n+  [(parallel [\n+     (set (match_operand:DF                    0 \"register_operand\" \"\")\n+\t  (float_truncate:DF (match_operand:TF 1 \"register_operand\" \"\")))\n+     (unspec:DF [(const_int BFP_RND_CURRENT)] UNSPEC_ROUND)])]\n+  \"TARGET_VXE\")\n+\n+(define_expand \"trunctfdf2\"\n+  [(match_operand:DF 0 \"register_operand\" \"\")\n+   (match_operand:TF 1 \"register_operand\" \"\")]\n+  \"HAVE_TF (trunctfdf2)\"\n+  { EXPAND_TF (trunctfdf2, 2); })\n+\n+; wflrx + (ledbr|wledb)\n+(define_expand \"trunctfsf2_vr\"\n+  [(parallel [\n+     (set (match_dup 2)\n+\t  (float_truncate:DF (match_operand:TF 1 \"register_operand\" \"\")))\n+     (unspec:DF [(const_int BFP_RND_PREP_FOR_SHORT_PREC)] UNSPEC_ROUND)])\n+   (set (match_operand:SF                    0 \"register_operand\" \"\")\n+\t(float_truncate:SF (match_dup 2)))]\n+  \"TARGET_VXE\"\n+{\n+  operands[2] = gen_reg_rtx(DFmode);\n+})\n+\n+(define_expand \"trunctfsf2\"\n+  [(match_operand:SF 0 \"register_operand\" \"\")\n+   (match_operand:TF 1 \"register_operand\" \"\")]\n+  \"HAVE_TF (trunctfsf2)\"\n+  { EXPAND_TF (trunctfsf2, 2); })\n+\n+; load lengthened\n+\n+(define_insn \"extenddftf2_vr\"\n+  [(set (match_operand:TF                  0 \"register_operand\" \"=v\")\n+\t(float_extend:TF (match_operand:DF 1 \"register_operand\"  \"f\")))]\n+  \"TARGET_VXE\"\n+  \"wflld\\t%v0,%v1\"\n+  [(set_attr \"op_type\" \"VRR\")])\n+\n+(define_expand \"extenddftf2\"\n+  [(match_operand:TF 0 \"register_operand\" \"\")\n+   (match_operand:DF 1 \"nonimmediate_operand\" \"\")]\n+  \"HAVE_TF (extenddftf2)\"\n+  { EXPAND_TF (extenddftf2, 2); })\n+\n+(define_expand \"extendsftf2_vr\"\n+  [(set (match_dup 2)\n+\t(float_extend:DF (match_operand:SF 1 \"nonimmediate_operand\" \"\")))\n+   (set (match_operand:TF                  0 \"register_operand\"     \"\")\n+\t(float_extend:TF (match_dup 2)))]\n+  \"TARGET_VXE\"\n+{\n+  operands[2] = gen_reg_rtx(DFmode);\n+})\n+\n+(define_expand \"extendsftf2\"\n+  [(match_operand:TF 0 \"register_operand\" \"\")\n+   (match_operand:SF 1 \"nonimmediate_operand\" \"\")]\n+  \"HAVE_TF (extendsftf2)\"\n+  { EXPAND_TF (extendsftf2, 2); })\n+\n+; test data class\n+\n+(define_expand \"signbittf2_vr\"\n+  [(parallel\n+    [(set (reg:CCRAW CC_REGNUM)\n+\t  (unspec:CCRAW [(match_operand:TF 1 \"register_operand\" \"\")\n+\t\t\t (match_dup        2)]\n+\t\t\tUNSPEC_VEC_VFTCICC))\n+     (clobber (scratch:V1TI))])\n+   (set (match_operand:SI                  0 \"register_operand\" \"\")\n+\t(const_int 0))\n+   (set (match_dup                         0)\n+\t(if_then_else:SI (eq (reg:CCRAW CC_REGNUM) (const_int 8))\n+\t\t\t (const_int 1)\n+\t\t\t (match_dup        0)))]\n+  \"TARGET_VXE\"\n+{\n+  operands[2] = GEN_INT (S390_TDC_SIGNBIT_SET);\n+})\n+\n+(define_expand \"signbittf2\"\n+  [(match_operand:SI 0 \"register_operand\" \"\")\n+   (match_operand:TF 1 \"register_operand\" \"\")]\n+  \"HAVE_TF (signbittf2)\"\n+  { EXPAND_TF (signbittf2, 2); })\n+\n+(define_expand \"isinftf2_vr\"\n+  [(parallel\n+    [(set (reg:CCRAW CC_REGNUM)\n+\t  (unspec:CCRAW [(match_operand:TF 1 \"register_operand\" \"\")\n+\t\t\t (match_dup        2)]\n+\t\t\tUNSPEC_VEC_VFTCICC))\n+     (clobber (scratch:V1TI))])\n+   (set (match_operand:SI                  0 \"register_operand\" \"\")\n+\t(const_int 0))\n+   (set (match_dup                         0)\n+\t(if_then_else:SI (eq (reg:CCRAW CC_REGNUM) (const_int 8))\n+\t\t\t (const_int 1)\n+\t\t\t (match_dup        0)))]\n+  \"TARGET_VXE\"\n+{\n+  operands[2] = GEN_INT (S390_TDC_INFINITY);\n+})\n+\n+(define_expand \"isinftf2\"\n+  [(match_operand:SI 0 \"register_operand\" \"\")\n+   (match_operand:TF 1 \"register_operand\" \"\")]\n+  \"HAVE_TF (isinftf2)\"\n+  { EXPAND_TF (isinftf2, 2); })\n+\n ;\n ; Vector byte swap patterns\n ;"}, {"sha": "010db4d1115679723b5c594eb764151590c94a61", "filename": "gcc/config/s390/vx-builtins.md", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e627cda5686592235dd38e461e73f2d6e8d24cd5/gcc%2Fconfig%2Fs390%2Fvx-builtins.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e627cda5686592235dd38e461e73f2d6e8d24cd5/gcc%2Fconfig%2Fs390%2Fvx-builtins.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fvx-builtins.md?ref=e627cda5686592235dd38e461e73f2d6e8d24cd5", "patch": "@@ -1940,22 +1940,22 @@\n ; These ignore the vector result and only want CC stored to an int\n ; pointer.\n \n-; vftcisb, vftcidb\n+; vftcisb, vftcidb, wftcixb\n (define_insn \"*vftci<mode>_cconly\"\n   [(set (reg:CCRAW CC_REGNUM)\n-\t(unspec:CCRAW [(match_operand:VECF_HW 1 \"register_operand\")\n-\t\t       (match_operand:HI      2 \"const_int_operand\")]\n+\t(unspec:CCRAW [(match_operand:VF_HW 1 \"register_operand\"  \"v\")\n+\t\t       (match_operand:HI    2 \"const_int_operand\" \"J\")]\n \t\t      UNSPEC_VEC_VFTCICC))\n-   (clobber (match_scratch:<tointvec> 0))]\n+   (clobber (match_scratch:<tointvec> 0 \"=v\"))]\n   \"TARGET_VX && CONST_OK_FOR_CONSTRAINT_P (INTVAL (operands[2]), 'J', \\\"J\\\")\"\n-  \"vftci<sdx>b\\t%v0,%v1,%x2\"\n+  \"<vw>ftci<sdx>b\\t%v0,%v1,%x2\"\n   [(set_attr \"op_type\" \"VRR\")])\n \n (define_expand \"vftci<mode>_intcconly\"\n   [(parallel\n     [(set (reg:CCRAW CC_REGNUM)\n-\t  (unspec:CCRAW [(match_operand:VECF_HW 0 \"register_operand\")\n-\t\t\t (match_operand:HI      1 \"const_int_operand\")]\n+\t  (unspec:CCRAW [(match_operand:VF_HW 0 \"register_operand\")\n+\t\t\t (match_operand:HI    1 \"const_int_operand\")]\n \t\t\tUNSPEC_VEC_VFTCICC))\n      (clobber (scratch:<tointvec>))])\n    (set (match_operand:SI 2 \"register_operand\" \"\")\n@@ -1965,27 +1965,27 @@\n ; vec_fp_test_data_class wants the result vector and the CC stored to\n ; an int pointer.\n \n-; vftcisb, vftcidb\n-(define_insn \"*vftci<mode>\"\n-  [(set (match_operand:VECF_HW                  0 \"register_operand\"  \"=v\")\n-\t(unspec:VECF_HW [(match_operand:VECF_HW 1 \"register_operand\"   \"v\")\n-\t\t\t (match_operand:HI      2 \"const_int_operand\"  \"J\")]\n-\t\t\tUNSPEC_VEC_VFTCI))\n+; vftcisb, vftcidb, wftcixb\n+(define_insn \"vftci<mode>\"\n+  [(set (match_operand:VF_HW                0 \"register_operand\"  \"=v\")\n+\t(unspec:VF_HW [(match_operand:VF_HW 1 \"register_operand\"   \"v\")\n+\t\t       (match_operand:HI    2 \"const_int_operand\"  \"J\")]\n+\t\t      UNSPEC_VEC_VFTCI))\n    (set (reg:CCRAW CC_REGNUM)\n \t(unspec:CCRAW [(match_dup 1) (match_dup 2)] UNSPEC_VEC_VFTCICC))]\n   \"TARGET_VX && CONST_OK_FOR_CONSTRAINT_P (INTVAL (operands[2]), 'J', \\\"J\\\")\"\n-  \"vftci<sdx>b\\t%v0,%v1,%x2\"\n+  \"<vw>ftci<sdx>b\\t%v0,%v1,%x2\"\n   [(set_attr \"op_type\" \"VRR\")])\n \n (define_expand \"vftci<mode>_intcc\"\n   [(parallel\n-    [(set (match_operand:VECF_HW                  0 \"register_operand\")\n-\t  (unspec:VECF_HW [(match_operand:VECF_HW 1 \"register_operand\")\n-\t\t\t   (match_operand:HI      2 \"const_int_operand\")]\n-\t\t\t  UNSPEC_VEC_VFTCI))\n+    [(set (match_operand:VF_HW                0 \"register_operand\")\n+\t  (unspec:VF_HW [(match_operand:VF_HW 1 \"register_operand\")\n+\t\t\t (match_operand:HI    2 \"const_int_operand\")]\n+\t\t\tUNSPEC_VEC_VFTCI))\n      (set (reg:CCRAW CC_REGNUM)\n \t  (unspec:CCRAW [(match_dup 1) (match_dup 2)] UNSPEC_VEC_VFTCICC))])\n-   (set (match_operand:SI 3 \"memory_operand\" \"\")\n+   (set (match_operand:SI                     3 \"nonimmediate_operand\")\n \t(unspec:SI [(reg:CCRAW CC_REGNUM)] UNSPEC_CC_TO_INT))]\n   \"TARGET_VX && CONST_OK_FOR_CONSTRAINT_P (INTVAL (operands[2]), 'J', \\\"J\\\")\")\n "}]}