{"sha": "cf7c4aa6af680063a0c08b79ce59cc3d0032cc9b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2Y3YzRhYTZhZjY4MDA2M2EwYzA4Yjc5Y2U1OWNjM2QwMDMyY2M5Yg==", "commit": {"author": {"name": "Hans-Peter Nilsson", "email": "hp@axis.com", "date": "2007-09-09T04:41:58Z"}, "committer": {"name": "Hans-Peter Nilsson", "email": "hp@gcc.gnu.org", "date": "2007-09-09T04:41:58Z"}, "message": "Divide REG_LABEL notes into REG_LABEL_OPERAND and REG_LABEL_TARGET.\n\n\t* doc/rtl.texi (Insns): Specify when a label_ref makes a jump_insn.\n\tSimilar for what label_refs can go in the JUMP_TARGET field.  Split\n\tREG_LABEL documentation into REG_LABEL_TARGET and REG_LABEL_OPERAND.\n\t* reload.c (find_reloads): Generate REG_LABEL_OPERAND, not\n\tREG_LABEL when replacing an operand with a LABEL_REF for a\n\tnon-jump insn.\n\t(subst_reloads): When replacing a LABEL_REG with a register,\n\tinstead of generating a REG_LABEL note, assert that there already\n\tis one or that the label is a known target for the insn.\n\t* rtlanal.c (computed_jump_p): Instead of looking for a REG_LABEL\n\tnote, check the JUMP_LABEL field.  Remove \"else\" after return.\n\t* reorg.c (emit_delay_sequence): Replace case for REG_LABEL with\n\tcases for REG_LABEL_OPERAND and REG_LABEL_TARGET.\n\t(fill_slots_from_thread): Handle both REG_LABEL_OPERAND and\n\tREG_LABEL_TARGET notes, including the JUMP_TARGET field on JUMP_P\n\tinsns.  Iterate over all notes; don't assume there's only one.\n\t* cse.c (recorded_label_ref): Adjust comment to refer to\n\tREG_LABEL_OPERAND.\n\t(cse_extended_basic_block): Do LABEL_REF check for all INSN_P\n\tinsns, not just NONJUMP_INSN_P.\n\t(check_for_label_ref): For JUMP_P insns, check that the LABEL_REF\n\tisn't a jump target.\n\t* jump.c (rebuild_jump_labels): Adjust head comment.\n\t(init_label_info): Ditto.  Remove REG_LABEL_OPERAND notes only;\n\tdon't reset REG_LABEL_TARGET notes, including the JUMP_LABEL field.\n\t(mark_all_labels): For JUMP_P insns without a target, check if the\n\tthe target is noted on the previous nonjump insn.\n\t(mark_jump_label_1): New function, guts from mark_jump_label.\n\t<case IF_THEN_ELSE>: Handle first operand as a non-target when\n\tmarking jump target labels.\n\t<case LABEL_REF>: Adjust for whether to generate a\n\tREG_LABEL_TARGET or a REG_LABEL_OPERAND note.\n\tFor 'E' format rtl, iterate in descending element order.\n\t(delete_related_insns): Handle both REG_LABEL_TARGET and\n\tREG_LABEL_OPERAND notes.  For JUMP_P insns with labels with zero\n\treference count, delete and fallthrough.  Move finding-next-\n\tnon-deleted insn last in the function.  Look at all INSN_P insns\n\tfor REG_LABEL_OPERAND notes.\n\t(redirect_jump_2): Assert that OLABEL equals the old JUMP_LABEL of\n\tJUMP.\n\t* print-rtl.c (print_rtx): For JUMP_P insns and a non-NULL\n\tJUMP_LABEL, output the INSN_UID of it.\n\t* gcse.c: Adjust comments as appropriate to say REG_LABEL_OPERAND\n\tand/or REG_LABEL_TARGET.\n\t(add_label_notes): Only add REG_LABEL_OPERAND notes.  Put in line\n\twith jump.c copy by only adding notes for labels actually\n\treferenced in the insn.\n\t* emit-rtl.c (try_split): Don't assume only NONJUMP_INSN_P need\n\tusage count increment; handle all INSN_P trial insns.\n\t(emit_copy_of_insn_after): Change to not copy REG_LABEL_OPERAND\n\tnotes.\n\t* rtl.h (struct rtx_def) <volatil>: Adjust to mention\n\tREG_LABEL_TARGET and REG_LABEL_OPERAND.\n\t(LABEL_REF_NONLOCAL_P): Allow REG_LABEL_TARGET and\n\tREG_LABEL_OPERAND.\n\t* combine.c (distribute_notes): Adjust for REG_LABEL_TARGET on\n\tJUMP_P insns and REG_LABEL_OPERAND everywhere.\n\t* sched-rgn.c (is_cfg_nonregular): Check for REG_LABEL_OPERANDS\n\ton all INSN_P insns.\n\t* reg-notes.def (LABEL_TARGET, LABEL_OPERAND): Split from LABEL.\n\t* cfgrtl.c (delete_insn): Adjust to handle REG_LABEL_TARGET and\n\tREG_LABEL_OPERAND notes.\n\t* reload1.c (calculate_needs_all_insns): Adjust comments.\n\t(set_label_offsets): Adjust to look for REG_LABEL_OPERAND notes.\n\t* config/alpha/alpha.md (split for load of an address into a\n\tfour-insn sequence on Unicos/Mk): Adjust to use\n\tREG_LABEL_OPERAND.\n\t* config/sh/sh.md (sh_reorg, final_prescan_insn): Ditto.\n\nFrom-SVN: r128287", "tree": {"sha": "23db0441b293cca445046c70fba12a335a0c4ff2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/23db0441b293cca445046c70fba12a335a0c4ff2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cf7c4aa6af680063a0c08b79ce59cc3d0032cc9b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf7c4aa6af680063a0c08b79ce59cc3d0032cc9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf7c4aa6af680063a0c08b79ce59cc3d0032cc9b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf7c4aa6af680063a0c08b79ce59cc3d0032cc9b/comments", "author": {"login": "hpataxisdotcom", "id": 80339731, "node_id": "MDQ6VXNlcjgwMzM5NzMx", "avatar_url": "https://avatars.githubusercontent.com/u/80339731?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hpataxisdotcom", "html_url": "https://github.com/hpataxisdotcom", "followers_url": "https://api.github.com/users/hpataxisdotcom/followers", "following_url": "https://api.github.com/users/hpataxisdotcom/following{/other_user}", "gists_url": "https://api.github.com/users/hpataxisdotcom/gists{/gist_id}", "starred_url": "https://api.github.com/users/hpataxisdotcom/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hpataxisdotcom/subscriptions", "organizations_url": "https://api.github.com/users/hpataxisdotcom/orgs", "repos_url": "https://api.github.com/users/hpataxisdotcom/repos", "events_url": "https://api.github.com/users/hpataxisdotcom/events{/privacy}", "received_events_url": "https://api.github.com/users/hpataxisdotcom/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "97c954f700eaf9b67909a322dcd780f6168b3aba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97c954f700eaf9b67909a322dcd780f6168b3aba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97c954f700eaf9b67909a322dcd780f6168b3aba"}], "stats": {"total": 642, "additions": 439, "deletions": 203}, "files": [{"sha": "6f3056329b9772b9f6e85cb6db1c30d1e2fb9e45", "filename": "gcc/ChangeLog", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf7c4aa6af680063a0c08b79ce59cc3d0032cc9b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf7c4aa6af680063a0c08b79ce59cc3d0032cc9b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cf7c4aa6af680063a0c08b79ce59cc3d0032cc9b", "patch": "@@ -1,3 +1,75 @@\n+2007-09-09  Hans-Peter Nilsson  <hp@axis.com>\n+\n+\tDivide REG_LABEL notes into REG_LABEL_OPERAND and REG_LABEL_TARGET.\n+\t* doc/rtl.texi (Insns): Specify when a label_ref makes a jump_insn.\n+\tSimilar for what label_refs can go in the JUMP_TARGET field.  Split\n+\tREG_LABEL documentation into REG_LABEL_TARGET and REG_LABEL_OPERAND.\n+\t* reload.c (find_reloads): Generate REG_LABEL_OPERAND, not\n+\tREG_LABEL when replacing an operand with a LABEL_REF for a\n+\tnon-jump insn.\n+\t(subst_reloads): When replacing a LABEL_REG with a register,\n+\tinstead of generating a REG_LABEL note, assert that there already\n+\tis one or that the label is a known target for the insn.\n+\t* rtlanal.c (computed_jump_p): Instead of looking for a REG_LABEL\n+\tnote, check the JUMP_LABEL field.  Remove \"else\" after return.\n+\t* reorg.c (emit_delay_sequence): Replace case for REG_LABEL with\n+\tcases for REG_LABEL_OPERAND and REG_LABEL_TARGET.\n+\t(fill_slots_from_thread): Handle both REG_LABEL_OPERAND and\n+\tREG_LABEL_TARGET notes, including the JUMP_TARGET field on JUMP_P\n+\tinsns.  Iterate over all notes; don't assume there's only one.\n+\t* cse.c (recorded_label_ref): Adjust comment to refer to\n+\tREG_LABEL_OPERAND.\n+\t(cse_extended_basic_block): Do LABEL_REF check for all INSN_P\n+\tinsns, not just NONJUMP_INSN_P.\n+\t(check_for_label_ref): For JUMP_P insns, check that the LABEL_REF\n+\tisn't a jump target.\n+\t* jump.c (rebuild_jump_labels): Adjust head comment.\n+\t(init_label_info): Ditto.  Remove REG_LABEL_OPERAND notes only;\n+\tdon't reset REG_LABEL_TARGET notes, including the JUMP_LABEL field.\n+\t(mark_all_labels): For JUMP_P insns without a target, check if the\n+\tthe target is noted on the previous nonjump insn.\n+\t(mark_jump_label_1): New function, guts from mark_jump_label.\n+\t<case IF_THEN_ELSE>: Handle first operand as a non-target when\n+\tmarking jump target labels.\n+\t<case LABEL_REF>: Adjust for whether to generate a\n+\tREG_LABEL_TARGET or a REG_LABEL_OPERAND note.\n+\tFor 'E' format rtl, iterate in descending element order.\n+\t(delete_related_insns): Handle both REG_LABEL_TARGET and\n+\tREG_LABEL_OPERAND notes.  For JUMP_P insns with labels with zero\n+\treference count, delete and fallthrough.  Move finding-next-\n+\tnon-deleted insn last in the function.  Look at all INSN_P insns\n+\tfor REG_LABEL_OPERAND notes.\n+\t(redirect_jump_2): Assert that OLABEL equals the old JUMP_LABEL of\n+\tJUMP.\n+\t* print-rtl.c (print_rtx): For JUMP_P insns and a non-NULL\n+\tJUMP_LABEL, output the INSN_UID of it.\n+\t* gcse.c: Adjust comments as appropriate to say REG_LABEL_OPERAND\n+\tand/or REG_LABEL_TARGET.\n+\t(add_label_notes): Only add REG_LABEL_OPERAND notes.  Put in line\n+\twith jump.c copy by only adding notes for labels actually\n+\treferenced in the insn.\n+\t* emit-rtl.c (try_split): Don't assume only NONJUMP_INSN_P need\n+\tusage count increment; handle all INSN_P trial insns.\n+\t(emit_copy_of_insn_after): Change to not copy REG_LABEL_OPERAND\n+\tnotes.\n+\t* rtl.h (struct rtx_def) <volatil>: Adjust to mention\n+\tREG_LABEL_TARGET and REG_LABEL_OPERAND.\n+\t(LABEL_REF_NONLOCAL_P): Allow REG_LABEL_TARGET and\n+\tREG_LABEL_OPERAND.\n+\t* combine.c (distribute_notes): Adjust for REG_LABEL_TARGET on\n+\tJUMP_P insns and REG_LABEL_OPERAND everywhere.\n+\t* sched-rgn.c (is_cfg_nonregular): Check for REG_LABEL_OPERANDS\n+\ton all INSN_P insns.\n+\t* reg-notes.def (LABEL_TARGET, LABEL_OPERAND): Split from LABEL.\n+\t* cfgrtl.c (delete_insn): Adjust to handle REG_LABEL_TARGET and\n+\tREG_LABEL_OPERAND notes.\n+\t* reload1.c (calculate_needs_all_insns): Adjust comments.\n+\t(set_label_offsets): Adjust to look for REG_LABEL_OPERAND notes.\n+\t* config/alpha/alpha.md (split for load of an address into a\n+\tfour-insn sequence on Unicos/Mk): Adjust to use\n+\tREG_LABEL_OPERAND.\n+\t* config/sh/sh.md (sh_reorg, final_prescan_insn): Ditto.\n+\n 2007-09-09  Laurynas Biveinis  <laurynas.biveinis@gmail.com>\n \n \tRevert:"}, {"sha": "2893c837051424fb93c7d6312d2855a0367bae8e", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf7c4aa6af680063a0c08b79ce59cc3d0032cc9b/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf7c4aa6af680063a0c08b79ce59cc3d0032cc9b/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=cf7c4aa6af680063a0c08b79ce59cc3d0032cc9b", "patch": "@@ -138,22 +138,30 @@ delete_insn (rtx insn)\n \n   /* If deleting a jump, decrement the use count of the label.  Deleting\n      the label itself should happen in the normal course of block merging.  */\n-  if (JUMP_P (insn)\n-      && JUMP_LABEL (insn)\n-      && LABEL_P (JUMP_LABEL (insn)))\n-    LABEL_NUSES (JUMP_LABEL (insn))--;\n-\n-  /* Also if deleting an insn that references a label.  */\n-  else\n+  if (JUMP_P (insn))\n     {\n-      while ((note = find_reg_note (insn, REG_LABEL, NULL_RTX)) != NULL_RTX\n+      if (JUMP_LABEL (insn)\n+\t  && LABEL_P (JUMP_LABEL (insn)))\n+\tLABEL_NUSES (JUMP_LABEL (insn))--;\n+\n+      /* If there are more targets, remove them too.  */\n+      while ((note\n+\t      = find_reg_note (insn, REG_LABEL_TARGET, NULL_RTX)) != NULL_RTX\n \t     && LABEL_P (XEXP (note, 0)))\n \t{\n \t  LABEL_NUSES (XEXP (note, 0))--;\n \t  remove_note (insn, note);\n \t}\n     }\n \n+  /* Also if deleting any insn that references a label as an operand.  */\n+  while ((note = find_reg_note (insn, REG_LABEL_OPERAND, NULL_RTX)) != NULL_RTX\n+\t && LABEL_P (XEXP (note, 0)))\n+    {\n+      LABEL_NUSES (XEXP (note, 0))--;\n+      remove_note (insn, note);\n+    }\n+\n   if (JUMP_P (insn)\n       && (GET_CODE (PATTERN (insn)) == ADDR_VEC\n \t  || GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC))"}, {"sha": "319c5325870760afae1bcbd7b923d5cc665b7194", "filename": "gcc/combine.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf7c4aa6af680063a0c08b79ce59cc3d0032cc9b/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf7c4aa6af680063a0c08b79ce59cc3d0032cc9b/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=cf7c4aa6af680063a0c08b79ce59cc3d0032cc9b", "patch": "@@ -12408,7 +12408,8 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2, rtx elim_i2,\n \t    }\n \t  break;\n \n-\tcase REG_LABEL:\n+\tcase REG_LABEL_TARGET:\n+\tcase REG_LABEL_OPERAND:\n \t  /* This can show up in several ways -- either directly in the\n \t     pattern, or hidden off in the constant pool with (or without?)\n \t     a REG_EQUAL note.  */\n@@ -12431,34 +12432,33 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2, rtx elim_i2,\n \t\tplace = i2;\n \t    }\n \n-\t  /* Don't attach REG_LABEL note to a JUMP_INSN.  Add\n-\t     a JUMP_LABEL instead or decrement LABEL_NUSES.  */\n-\t  if (place && JUMP_P (place))\n+\t  /* For REG_LABEL_TARGET on a JUMP_P, we prefer to put the note\n+\t     as a JUMP_LABEL or decrement LABEL_NUSES if it's already\n+\t     there.  */\n+\t  if (place && JUMP_P (place)\n+\t      && REG_NOTE_KIND (note) == REG_LABEL_TARGET\n+\t      && (JUMP_LABEL (place) == NULL\n+\t\t  || JUMP_LABEL (place) == XEXP (note, 0)))\n \t    {\n \t      rtx label = JUMP_LABEL (place);\n \n \t      if (!label)\n \t\tJUMP_LABEL (place) = XEXP (note, 0);\n-\t      else\n-\t\t{\n-\t\t  gcc_assert (label == XEXP (note, 0));\n-\t\t  if (LABEL_P (label))\n-\t\t    LABEL_NUSES (label)--;\n-\t\t}\n-\t      place = 0;\n+\t      else if (LABEL_P (label))\n+\t\tLABEL_NUSES (label)--;\n \t    }\n-\t  if (place2 && JUMP_P (place2))\n+\n+\t  if (place2 && JUMP_P (place2)\n+\t      && REG_NOTE_KIND (note) == REG_LABEL_TARGET\n+\t      && (JUMP_LABEL (place2) == NULL\n+\t\t  || JUMP_LABEL (place2) == XEXP (note, 0)))\n \t    {\n \t      rtx label = JUMP_LABEL (place2);\n \n \t      if (!label)\n \t\tJUMP_LABEL (place2) = XEXP (note, 0);\n-\t      else\n-\t\t{\n-\t\t  gcc_assert (label == XEXP (note, 0));\n-\t\t  if (LABEL_P (label))\n-\t\t    LABEL_NUSES (label)--;\n-\t\t}\n+\t      else if (LABEL_P (label))\n+\t\tLABEL_NUSES (label)--;\n \t      place2 = 0;\n \t    }\n \t  break;"}, {"sha": "f4f3eb3a8df7f847d9385590fd71edc6c8963e3d", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf7c4aa6af680063a0c08b79ce59cc3d0032cc9b/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf7c4aa6af680063a0c08b79ce59cc3d0032cc9b/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=cf7c4aa6af680063a0c08b79ce59cc3d0032cc9b", "patch": "@@ -5375,9 +5375,9 @@\n \n ;; Split the load of an address into a four-insn sequence on Unicos/Mk.\n ;; Always generate a REG_EQUAL note for the last instruction to facilitate\n-;; optimizations. If the symbolic operand is a label_ref, generate REG_LABEL\n-;; notes and update LABEL_NUSES because this is not done automatically.\n-;; Labels may be incorrectly deleted if we don't do this.\n+;; optimizations. If the symbolic operand is a label_ref, generate\n+;; REG_LABEL_OPERAND notes and update LABEL_NUSES because this is not done\n+;; automatically.  Labels may be incorrectly deleted if we don't do this.\n ;;\n ;; Describing what the individual instructions do correctly is too complicated\n ;; so use UNSPECs for each of the three parts of an address.\n@@ -5401,11 +5401,11 @@\n       rtx label;\n \n       label = XEXP (operands[1], 0);\n-      REG_NOTES (insn1) = gen_rtx_EXPR_LIST (REG_LABEL, label,\n+      REG_NOTES (insn1) = gen_rtx_EXPR_LIST (REG_LABEL_OPERAND, label,\n \t\t\t\t\t     REG_NOTES (insn1));\n-      REG_NOTES (insn2) = gen_rtx_EXPR_LIST (REG_LABEL, label,\n+      REG_NOTES (insn2) = gen_rtx_EXPR_LIST (REG_LABEL_OPERAND, label,\n \t\t\t\t\t     REG_NOTES (insn2));\n-      REG_NOTES (insn3) = gen_rtx_EXPR_LIST (REG_LABEL, label,\n+      REG_NOTES (insn3) = gen_rtx_EXPR_LIST (REG_LABEL_OPERAND, label,\n \t\t\t\t\t     REG_NOTES (insn3));\n       LABEL_NUSES (label) += 3;\n     }"}, {"sha": "ad9dd2263cc36c206565940a44c89435d79fd466", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf7c4aa6af680063a0c08b79ce59cc3d0032cc9b/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf7c4aa6af680063a0c08b79ce59cc3d0032cc9b/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=cf7c4aa6af680063a0c08b79ce59cc3d0032cc9b", "patch": "@@ -4716,8 +4716,8 @@ sh_reorg (void)\n   mdep_reorg_phase = SH_INSERT_USES_LABELS;\n   if (TARGET_RELAX)\n     {\n-      /* Remove all REG_LABEL notes.  We want to use them for our own\n-\t purposes.  This works because none of the remaining passes\n+      /* Remove all REG_LABEL_OPERAND notes.  We want to use them for our\n+\t own purposes.  This works because none of the remaining passes\n \t need to look at them.\n \n \t ??? But it may break in the future.  We should use a machine\n@@ -4728,7 +4728,8 @@ sh_reorg (void)\n \t    {\n \t      rtx note;\n \n-\t      while ((note = find_reg_note (insn, REG_LABEL, NULL_RTX)) != 0)\n+\t      while ((note = find_reg_note (insn, REG_LABEL_OPERAND,\n+\t\t\t\t\t    NULL_RTX)) != 0)\n \t\tremove_note (insn, note);\n \t    }\n \t}\n@@ -4879,16 +4880,16 @@ sh_reorg (void)\n \t      continue;\n \t    }\n \n-\t  /* Create a code label, and put it in a REG_LABEL note on\n-             the insn which sets the register, and on each call insn\n-             which uses the register.  In final_prescan_insn we look\n-             for the REG_LABEL notes, and output the appropriate label\n+\t  /* Create a code label, and put it in a REG_LABEL_OPERAND note\n+             on the insn which sets the register, and on each call insn\n+             which uses the register.  In final_prescan_insn we look for\n+             the REG_LABEL_OPERAND notes, and output the appropriate label\n              or pseudo-op.  */\n \n \t  label = gen_label_rtx ();\n-\t  REG_NOTES (link) = gen_rtx_INSN_LIST (REG_LABEL, label,\n+\t  REG_NOTES (link) = gen_rtx_INSN_LIST (REG_LABEL_OPERAND, label,\n \t\t\t\t\t\tREG_NOTES (link));\n-\t  REG_NOTES (insn) = gen_rtx_INSN_LIST (REG_LABEL, label,\n+\t  REG_NOTES (insn) = gen_rtx_INSN_LIST (REG_LABEL_OPERAND, label,\n \t\t\t\t\t\tREG_NOTES (insn));\n \t  if (rescan)\n \t    {\n@@ -4904,7 +4905,8 @@ sh_reorg (void)\n \t\t\t  || ((reg2 = sfunc_uses_reg (scan))\n \t\t\t      && REGNO (reg2) == REGNO (reg))))\n \t\t    REG_NOTES (scan)\n-\t\t      = gen_rtx_INSN_LIST (REG_LABEL, label, REG_NOTES (scan));\n+\t\t      = gen_rtx_INSN_LIST (REG_LABEL_OPERAND, label,\n+\t\t\t\t\t   REG_NOTES (scan));\n \t\t}\n \t      while (scan != dies);\n \t    }\n@@ -5405,7 +5407,7 @@ final_prescan_insn (rtx insn, rtx *opvec ATTRIBUTE_UNUSED,\n     {\n       rtx note;\n \n-      note = find_reg_note (insn, REG_LABEL, NULL_RTX);\n+      note = find_reg_note (insn, REG_LABEL_OPERAND, NULL_RTX);\n       if (note)\n \t{\n \t  rtx pattern;"}, {"sha": "7e766611e6e5e2e4813411e79afd9d71b7600018", "filename": "gcc/cse.c", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf7c4aa6af680063a0c08b79ce59cc3d0032cc9b/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf7c4aa6af680063a0c08b79ce59cc3d0032cc9b/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=cf7c4aa6af680063a0c08b79ce59cc3d0032cc9b", "patch": "@@ -353,8 +353,9 @@ static HARD_REG_SET hard_regs_in_table;\n \n static int cse_jumps_altered;\n \n-/* Nonzero if we put a LABEL_REF into the hash table for an INSN without a\n-   REG_LABEL, we have to rerun jump after CSE to put in the note.  */\n+/* Nonzero if we put a LABEL_REF into the hash table for an INSN\n+   without a REG_LABEL_OPERAND, we have to rerun jump after CSE to put\n+   in the note.  */\n static int recorded_label_ref;\n \n /* canon_hash stores 1 in do_not_record\n@@ -6091,7 +6092,7 @@ cse_extended_basic_block (struct cse_basic_block_data *ebb_data)\n \t    \n \t      /* If we haven't already found an insn where we added a LABEL_REF,\n \t\t check this one.  */\n-\t      if (NONJUMP_INSN_P (insn) && ! recorded_label_ref\n+\t      if (INSN_P (insn) && ! recorded_label_ref\n \t\t  && for_each_rtx (&PATTERN (insn), check_for_label_ref,\n \t\t\t\t   (void *) insn))\n \t\trecorded_label_ref = 1;\n@@ -6277,23 +6278,26 @@ cse_main (rtx f ATTRIBUTE_UNUSED, int nregs)\n   return cse_jumps_altered || recorded_label_ref;\n }\n \f\n-/* Called via for_each_rtx to see if an insn is using a LABEL_REF for which\n-   there isn't a REG_LABEL note.  Return one if so.  DATA is the insn.  */\n+/* Called via for_each_rtx to see if an insn is using a LABEL_REF for\n+   which there isn't a REG_LABEL_OPERAND note.\n+   Return one if so.  DATA is the insn.  */\n \n static int\n check_for_label_ref (rtx *rtl, void *data)\n {\n   rtx insn = (rtx) data;\n \n-  /* If this insn uses a LABEL_REF and there isn't a REG_LABEL note for it,\n-     we must rerun jump since it needs to place the note.  If this is a\n-     LABEL_REF for a CODE_LABEL that isn't in the insn chain, don't do this\n-     since no REG_LABEL will be added.  */\n+  /* If this insn uses a LABEL_REF and there isn't a REG_LABEL_OPERAND\n+     note for it, we must rerun jump since it needs to place the note.  If\n+     this is a LABEL_REF for a CODE_LABEL that isn't in the insn chain,\n+     don't do this since no REG_LABEL_OPERAND will be added.  */\n   return (GET_CODE (*rtl) == LABEL_REF\n \t  && ! LABEL_REF_NONLOCAL_P (*rtl)\n+\t  && (!JUMP_P (insn)\n+\t      || !label_is_jump_target_p (XEXP (*rtl, 0), insn))\n \t  && LABEL_P (XEXP (*rtl, 0))\n \t  && INSN_UID (XEXP (*rtl, 0)) != 0\n-\t  && ! find_reg_note (insn, REG_LABEL, XEXP (*rtl, 0)));\n+\t  && ! find_reg_note (insn, REG_LABEL_OPERAND, XEXP (*rtl, 0)));\n }\n \f\n /* Count the number of times registers are used (not set) in X."}, {"sha": "639aabe885afdc25fec08f27ba24d16ccb65b141", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 27, "deletions": 13, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf7c4aa6af680063a0c08b79ce59cc3d0032cc9b/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf7c4aa6af680063a0c08b79ce59cc3d0032cc9b/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=cf7c4aa6af680063a0c08b79ce59cc3d0032cc9b", "patch": "@@ -3201,9 +3201,10 @@ mandatory ones listed above.  These four are described in a table below.\n @findex jump_insn\n @item jump_insn\n The expression code @code{jump_insn} is used for instructions that may\n-jump (or, more generally, may contain @code{label_ref} expressions).  If\n-there is an instruction to return from the current function, it is\n-recorded as a @code{jump_insn}.\n+jump (or, more generally, may contain @code{label_ref} expressions to\n+which @code{pc} can be set in that instruction).  If there is an\n+instruction to return from the current function, it is recorded as a\n+@code{jump_insn}.\n \n @findex JUMP_LABEL\n @code{jump_insn} insns have the same extra fields as @code{insn} insns,\n@@ -3213,9 +3214,11 @@ accessed in the same way and in addition contain a field\n For simple conditional and unconditional jumps, this field contains\n the @code{code_label} to which this insn will (possibly conditionally)\n branch.  In a more complex jump, @code{JUMP_LABEL} records one of the\n-labels that the insn refers to; the only way to find the others is to\n-scan the entire body of the insn.  In an @code{addr_vec},\n-@code{JUMP_LABEL} is @code{NULL_RTX}.\n+labels that the insn refers to; other jump target labels are recorded\n+as @code{REG_LABEL_TARGET} notes.  The exception is @code{addr_vec}\n+and @code{addr_diff_vec}, where @code{JUMP_LABEL} is @code{NULL_RTX}\n+and the only way to find the labels is to scan the entire body of the\n+insn.\n \n Return insns count as jumps, but since they do not refer to any\n labels, their @code{JUMP_LABEL} is @code{NULL_RTX}.\n@@ -3531,14 +3534,25 @@ note giving the expression being computed.  This block is encapsulated\n with @code{REG_LIBCALL} and @code{REG_RETVAL} notes on the first and\n last insns, respectively.\n \n-@findex REG_LABEL\n-@item REG_LABEL\n+@findex REG_LABEL_OPERAND\n+@item REG_LABEL_OPERAND\n This insn uses @var{op}, a @code{code_label} or a @code{note} of type\n-@code{NOTE_INSN_DELETED_LABEL}, but is not a\n-@code{jump_insn}, or it is a @code{jump_insn} that required the label to\n-be held in a register.  The presence of this note allows jump\n-optimization to be aware that @var{op} is, in fact, being used, and flow\n-optimization to build an accurate flow graph.\n+@code{NOTE_INSN_DELETED_LABEL}, but is not a @code{jump_insn}, or it\n+is a @code{jump_insn} that refers to the operand as an ordinary\n+operand.  The label may still eventually be a jump target, but if so\n+in an indirect jump in a subsequent insn.  The presence of this note\n+allows jump optimization to be aware that @var{op} is, in fact, being\n+used, and flow optimization to build an accurate flow graph.\n+\n+@findex REG_LABEL_TARGET\n+@item REG_LABEL_TARGET\n+This insn is a @code{jump_insn} but not a @code{addr_vec} or\n+@code{addr_diff_vec}.  It uses @var{op}, a @code{code_label} as a\n+direct or indirect jump target.  Its purpose is similar to that of\n+@code{REG_LABEL_OPERAND}.  This note is only present if the insn has\n+multiple targets; the last label in the insn (in the highest numbered\n+insn-field) goes into the @code{JUMP_LABEL} field and does not have a\n+@code{REG_LABEL_TARGET} note.  @xref{Insns, JUMP_LABEL}.\n \n @findex REG_CROSSING_JUMP\n @item REG_CROSSING_JUMP"}, {"sha": "8d1b1c7e85a71a06bd3db72389928d2f5ac08e92", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf7c4aa6af680063a0c08b79ce59cc3d0032cc9b/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf7c4aa6af680063a0c08b79ce59cc3d0032cc9b/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=cf7c4aa6af680063a0c08b79ce59cc3d0032cc9b", "patch": "@@ -3355,11 +3355,12 @@ try_split (rtx pat, rtx trial, int last)\n \n   /* If there are LABELS inside the split insns increment the\n      usage count so we don't delete the label.  */\n-  if (NONJUMP_INSN_P (trial))\n+  if (INSN_P (trial))\n     {\n       insn = insn_last;\n       while (insn != NULL_RTX)\n \t{\n+\t  /* JUMP_P insns have already been \"marked\" above.  */\n \t  if (NONJUMP_INSN_P (insn))\n \t    mark_label_nuses (PATTERN (insn));\n \n@@ -5529,10 +5530,11 @@ emit_copy_of_insn_after (rtx insn, rtx after)\n      which may be duplicated by the basic block reordering code.  */\n   RTX_FRAME_RELATED_P (new) = RTX_FRAME_RELATED_P (insn);\n \n-  /* Copy all REG_NOTES except REG_LABEL since mark_jump_label will\n-     make them.  */\n+  /* Copy all REG_NOTES except REG_LABEL_OPERAND since mark_jump_label\n+     will make them.  REG_LABEL_TARGETs are created there too, but are\n+     supposed to be sticky, so we copy them.  */\n   for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n-    if (REG_NOTE_KIND (link) != REG_LABEL)\n+    if (REG_NOTE_KIND (link) != REG_LABEL_OPERAND)\n       {\n \tif (GET_CODE (link) == EXPR_LIST)\n \t  REG_NOTES (new)"}, {"sha": "e3ffae0d05cc09b1dfcf9a4bf7bb27ff38ef941c", "filename": "gcc/gcse.c", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf7c4aa6af680063a0c08b79ce59cc3d0032cc9b/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf7c4aa6af680063a0c08b79ce59cc3d0032cc9b/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=cf7c4aa6af680063a0c08b79ce59cc3d0032cc9b", "patch": "@@ -4584,14 +4584,15 @@ one_pre_gcse_pass (int pass)\n   return changed;\n }\n \f\n-/* If X contains any LABEL_REF's, add REG_LABEL notes for them to INSN.\n-   If notes are added to an insn which references a CODE_LABEL, the\n-   LABEL_NUSES count is incremented.  We have to add REG_LABEL notes,\n-   because the following loop optimization pass requires them.  */\n+/* If X contains any LABEL_REF's, add REG_LABEL_OPERAND notes for them\n+   to INSN.  If such notes are added to an insn which references a\n+   CODE_LABEL, the LABEL_NUSES count is incremented.  We have to add\n+   that note, because the following loop optimization pass requires\n+   them.  */\n \n /* ??? If there was a jump optimization pass after gcse and before loop,\n    then we would not need to do this here, because jump would add the\n-   necessary REG_LABEL notes.  */\n+   necessary REG_LABEL_OPERAND and REG_LABEL_TARGET notes.  */\n \n static void\n add_label_notes (rtx x, rtx insn)\n@@ -4608,10 +4609,18 @@ add_label_notes (rtx x, rtx insn)\n \t We no longer ignore such label references (see LABEL_REF handling in\n \t mark_jump_label for additional information).  */\n \n-      REG_NOTES (insn) = gen_rtx_INSN_LIST (REG_LABEL, XEXP (x, 0),\n-\t\t\t\t\t    REG_NOTES (insn));\n-      if (LABEL_P (XEXP (x, 0)))\n-\tLABEL_NUSES (XEXP (x, 0))++;\n+\tif (reg_mentioned_p (XEXP (x, 0), insn))\n+\t  {\n+\t    /* There's no reason for current users to emit jump-insns\n+\t       with such a LABEL_REF, so we don't have to handle\n+\t       REG_LABEL_TARGET notes.  */\n+\t    gcc_assert (!JUMP_P (insn));\n+\t    REG_NOTES (insn)\n+\t      = gen_rtx_INSN_LIST (REG_LABEL_OPERAND, XEXP (x, 0),\n+\t\t\t\t   REG_NOTES (insn));\n+\t    if (LABEL_P (XEXP (x, 0)))\n+\t      LABEL_NUSES (XEXP (x, 0))++;\n+\t  }\n       return;\n     }\n "}, {"sha": "e62024fbc7198a9e4380f58be59259ce966bce43", "filename": "gcc/jump.c", "status": "modified", "additions": 159, "deletions": 74, "changes": 233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf7c4aa6af680063a0c08b79ce59cc3d0032cc9b/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf7c4aa6af680063a0c08b79ce59cc3d0032cc9b/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=cf7c4aa6af680063a0c08b79ce59cc3d0032cc9b", "patch": "@@ -67,13 +67,15 @@ along with GCC; see the file COPYING3.  If not see\n \n static void init_label_info (rtx);\n static void mark_all_labels (rtx);\n+static void mark_jump_label_1 (rtx, rtx, bool, bool);\n static void redirect_exp_1 (rtx *, rtx, rtx, rtx);\n static int invert_exp_1 (rtx, rtx);\n static int returnjump_p_1 (rtx *, void *);\n \f\n-/* Alternate entry into the jump optimizer.  This entry point only rebuilds\n-   the JUMP_LABEL field in jumping insns and REG_LABEL notes in non-jumping\n-   instructions.  */\n+/* This function rebuilds the JUMP_LABEL field and REG_LABEL_TARGET\n+   notes in jumping insns and REG_LABEL_OPERAND notes in non-jumping\n+   instructions and jumping insns that have labels as operands\n+   (e.g. cbranchsi4).  */\n void\n rebuild_jump_labels (rtx f)\n {\n@@ -138,31 +140,43 @@ struct tree_opt_pass pass_cleanup_barriers =\n };\n \n \f\n-/* Initialize LABEL_NUSES and JUMP_LABEL fields.  Delete any REG_LABEL\n-   notes whose labels don't occur in the insn any more.  Returns the\n-   largest INSN_UID found.  */\n+/* Initialize LABEL_NUSES and JUMP_LABEL fields, add REG_LABEL_TARGET\n+   for remaining targets for JUMP_P.  Delete any REG_LABEL_OPERAND\n+   notes whose labels don't occur in the insn any more.  */\n+\n static void\n init_label_info (rtx f)\n {\n   rtx insn;\n \n   for (insn = f; insn; insn = NEXT_INSN (insn))\n-    if (LABEL_P (insn))\n-      LABEL_NUSES (insn) = (LABEL_PRESERVE_P (insn) != 0);\n-    else if (JUMP_P (insn))\n-      JUMP_LABEL (insn) = 0;\n-    else if (NONJUMP_INSN_P (insn) || CALL_P (insn))\n-      {\n-\trtx note, next;\n+    {\n+      if (LABEL_P (insn))\n+\tLABEL_NUSES (insn) = (LABEL_PRESERVE_P (insn) != 0);\n+\n+      /* REG_LABEL_TARGET notes (including the JUMP_LABEL field) are\n+\t sticky and not reset here; that way we won't lose association\n+\t with a label when e.g. the source for a target register\n+\t disappears out of reach for targets that may use jump-target\n+\t registers.  Jump transformations are supposed to transform\n+\t any REG_LABEL_TARGET notes.  The target label reference in a\n+\t branch may disappear from the branch (and from the\n+\t instruction before it) for other reasons, like register\n+\t allocation.  */\n+\n+      if (INSN_P (insn))\n+\t{\n+\t  rtx note, next;\n \n-\tfor (note = REG_NOTES (insn); note; note = next)\n-\t  {\n-\t    next = XEXP (note, 1);\n-\t    if (REG_NOTE_KIND (note) == REG_LABEL\n-\t\t&& ! reg_mentioned_p (XEXP (note, 0), PATTERN (insn)))\n-\t      remove_note (insn, note);\n-\t  }\n-      }\n+\t  for (note = REG_NOTES (insn); note; note = next)\n+\t    {\n+\t      next = XEXP (note, 1);\n+\t      if (REG_NOTE_KIND (note) == REG_LABEL_OPERAND\n+\t\t  && ! reg_mentioned_p (XEXP (note, 0), PATTERN (insn)))\n+\t\tremove_note (insn, note);\n+\t    }\n+\t}\n+    }\n }\n \n /* Mark the label each jump jumps to.\n@@ -172,34 +186,69 @@ static void\n mark_all_labels (rtx f)\n {\n   rtx insn;\n+  rtx prev_nonjump_insn = NULL;\n \n   for (insn = f; insn; insn = NEXT_INSN (insn))\n     if (INSN_P (insn))\n       {\n \tmark_jump_label (PATTERN (insn), insn, 0);\n-\tif (! INSN_DELETED_P (insn) && JUMP_P (insn))\n+\n+\t/* If the previous non-jump insn sets something to a label,\n+\t   something that this jump insn uses, make that label the primary\n+\t   target of this insn if we don't yet have any.  That previous\n+\t   insn must be a single_set and not refer to more than one label.\n+\t   The jump insn must not refer to other labels as jump targets\n+\t   and must be a plain (set (pc) ...), maybe in a parallel, and\n+\t   may refer to the item being set only directly or as one of the\n+\t   arms in an IF_THEN_ELSE.  */\n+\tif (! INSN_DELETED_P (insn)\n+\t    && JUMP_P (insn)\n+\t    && JUMP_LABEL (insn) == NULL)\n \t  {\n-\t    /* When we know the LABEL_REF contained in a REG used in\n-\t       an indirect jump, we'll have a REG_LABEL note so that\n-\t       flow can tell where it's going.  */\n-\t    if (JUMP_LABEL (insn) == 0)\n+\t    rtx label_note = NULL;\n+\t    rtx pc = pc_set (insn);\n+\t    rtx pc_src = pc != NULL ? SET_SRC (pc) : NULL;\n+\n+\t    if (prev_nonjump_insn != NULL)\n+\t      label_note\n+\t\t= find_reg_note (prev_nonjump_insn, REG_LABEL_OPERAND, NULL);\n+\n+\t    if (label_note != NULL && pc_src != NULL)\n \t      {\n-\t\trtx label_note = find_reg_note (insn, REG_LABEL, NULL_RTX);\n-\t\tif (label_note)\n+\t\trtx label_set = single_set (prev_nonjump_insn);\n+\t\trtx label_dest\n+\t\t  = label_set != NULL ? SET_DEST (label_set) : NULL;\n+\n+\t\tif (label_set != NULL\n+\t\t    /* The source must be the direct LABEL_REF, not a\n+\t\t       PLUS, UNSPEC, IF_THEN_ELSE etc.  */\n+\t\t    && GET_CODE (SET_SRC (label_set)) == LABEL_REF\n+\t\t    && (rtx_equal_p (label_dest, pc_src)\n+\t\t\t|| (GET_CODE (pc_src) == IF_THEN_ELSE\n+\t\t\t    && (rtx_equal_p (label_dest, XEXP (pc_src, 1))\n+\t\t\t\t|| rtx_equal_p (label_dest,\n+\t\t\t\t\t\tXEXP (pc_src, 2))))))\n+\t\t\t\t\n \t\t  {\n-\t\t    /* But a LABEL_REF around the REG_LABEL note, so\n-\t\t       that we can canonicalize it.  */\n-\t\t    rtx label_ref = gen_rtx_LABEL_REF (Pmode,\n-\t\t\t\t\t\t       XEXP (label_note, 0));\n-\n-\t\t    mark_jump_label (label_ref, insn, 0);\n-\t\t    XEXP (label_note, 0) = XEXP (label_ref, 0);\n-\t\t    JUMP_LABEL (insn) = XEXP (label_note, 0);\n+\t\t    /* The CODE_LABEL referred to in the note must be the\n+\t\t       CODE_LABEL in the LABEL_REF of the \"set\".  We can\n+\t\t       conveniently use it for the marker function, which\n+\t\t       requires a LABEL_REF wrapping.  */\n+\t\t    gcc_assert (XEXP (label_note, 0)\n+\t\t\t\t== XEXP (SET_SRC (label_set), 0));\n+\n+\t\t    mark_jump_label_1 (label_set, insn, false, true);\n+\t\t    gcc_assert (JUMP_LABEL (insn)\n+\t\t\t\t== XEXP (SET_SRC (label_set), 0));\n \t\t  }\n \t      }\n \t  }\n+\telse if (! INSN_DELETED_P (insn))\n+\t  prev_nonjump_insn = insn;\n       }\n-  \n+    else if (LABEL_P (insn))\n+      prev_nonjump_insn = NULL;\n+\n   /* If we are in cfglayout mode, there may be non-insns between the\n      basic blocks.  If those non-insns represent tablejump data, they\n      contain label references that we must record.  */\n@@ -904,12 +953,14 @@ sets_cc0_p (const_rtx x)\n }\n #endif\n \f\n-/* Find all CODE_LABELs referred to in X, and increment their use counts.\n-   If INSN is a JUMP_INSN and there is at least one CODE_LABEL referenced\n-   in INSN, then store one of them in JUMP_LABEL (INSN).\n-   If INSN is an INSN or a CALL_INSN and there is at least one CODE_LABEL\n-   referenced in INSN, add a REG_LABEL note containing that label to INSN.\n-   Also, when there are consecutive labels, canonicalize on the last of them.\n+/* Find all CODE_LABELs referred to in X, and increment their use\n+   counts.  If INSN is a JUMP_INSN and there is at least one\n+   CODE_LABEL referenced in INSN as a jump target, then store the last\n+   one in JUMP_LABEL (INSN).  For a tablejump, this must be the label\n+   for the ADDR_VEC.  Store any other jump targets as REG_LABEL_TARGET\n+   notes.  If INSN is an INSN or a CALL_INSN or non-target operands of\n+   a JUMP_INSN, and there is at least one CODE_LABEL referenced in\n+   INSN, add a REG_LABEL_OPERAND note containing that label to INSN.\n \n    Note that two labels separated by a loop-beginning note\n    must be kept distinct if we have not yet done loop-optimization,\n@@ -919,6 +970,19 @@ sets_cc0_p (const_rtx x)\n \n void\n mark_jump_label (rtx x, rtx insn, int in_mem)\n+{\n+  mark_jump_label_1 (x, insn, in_mem != 0,\n+\t\t     (insn != NULL && x == PATTERN (insn) && JUMP_P (insn)));\n+}\n+\n+/* Worker function for mark_jump_label.  IN_MEM is TRUE when X occurrs\n+   within a (MEM ...).  IS_TARGET is TRUE when X is to be treated as a\n+   jump-target; when the JUMP_LABEL field of INSN should be set or a\n+   REG_LABEL_TARGET note should be added, not a REG_LABEL_OPERAND\n+   note.  */\n+\n+static void\n+mark_jump_label_1 (rtx x, rtx insn, bool in_mem, bool is_target)\n {\n   RTX_CODE code = GET_CODE (x);\n   int i;\n@@ -936,7 +1000,7 @@ mark_jump_label (rtx x, rtx insn, int in_mem)\n       return;\n \n     case MEM:\n-      in_mem = 1;\n+      in_mem = true;\n       break;\n \n     case SEQUENCE:\n@@ -951,9 +1015,19 @@ mark_jump_label (rtx x, rtx insn, int in_mem)\n \n       /* If this is a constant-pool reference, see if it is a label.  */\n       if (CONSTANT_POOL_ADDRESS_P (x))\n-\tmark_jump_label (get_pool_constant (x), insn, in_mem);\n+\tmark_jump_label_1 (get_pool_constant (x), insn, in_mem, is_target);\n       break;\n \n+      /* Handle operands in the condition of an if-then-else as for a\n+\t non-jump insn.  */\n+    case IF_THEN_ELSE:\n+      if (!is_target)\n+\tbreak;\n+      mark_jump_label_1 (XEXP (x, 0), insn, in_mem, false);\n+      mark_jump_label_1 (XEXP (x, 1), insn, in_mem, true);\n+      mark_jump_label_1 (XEXP (x, 2), insn, in_mem, true);\n+      return;\n+\n     case LABEL_REF:\n       {\n \trtx label = XEXP (x, 0);\n@@ -976,17 +1050,21 @@ mark_jump_label (rtx x, rtx insn, int in_mem)\n \n \tif (insn)\n \t  {\n-\t    if (JUMP_P (insn))\n+\t    if (is_target\n+\t\t&& (JUMP_LABEL (insn) == NULL || JUMP_LABEL (insn) == label))\n \t      JUMP_LABEL (insn) = label;\n \t    else\n \t      {\n-\t\t/* Add a REG_LABEL note for LABEL unless there already\n-\t\t   is one.  All uses of a label, except for labels\n-\t\t   that are the targets of jumps, must have a\n-\t\t   REG_LABEL note.  */\n-\t\tif (! find_reg_note (insn, REG_LABEL, label))\n-\t\t  REG_NOTES (insn) = gen_rtx_INSN_LIST (REG_LABEL, label,\n-\t\t\t\t\t\t\tREG_NOTES (insn));\n+\t\tenum reg_note kind\n+\t\t  = is_target ? REG_LABEL_TARGET : REG_LABEL_OPERAND;\n+\n+\t\t/* Add a REG_LABEL_OPERAND or REG_LABEL_TARGET note\n+\t\t   for LABEL unless there already is one.  All uses of\n+\t\t   a label, except for the primary target of a jump,\n+\t\t   must have such a note.  */\n+\t\tif (! find_reg_note (insn, kind, label))\n+\t\t  REG_NOTES (insn)\n+\t\t    = gen_rtx_INSN_LIST (kind, label, REG_NOTES (insn));\n \t      }\n \t  }\n \treturn;\n@@ -1001,7 +1079,8 @@ mark_jump_label (rtx x, rtx insn, int in_mem)\n \t  int eltnum = code == ADDR_DIFF_VEC ? 1 : 0;\n \n \t  for (i = 0; i < XVECLEN (x, eltnum); i++)\n-\t    mark_jump_label (XVECEXP (x, eltnum, i), NULL_RTX, in_mem);\n+\t    mark_jump_label_1 (XVECEXP (x, eltnum, i), NULL_RTX, in_mem,\n+\t\t\t       is_target);\n \t}\n       return;\n \n@@ -1010,15 +1089,21 @@ mark_jump_label (rtx x, rtx insn, int in_mem)\n     }\n \n   fmt = GET_RTX_FORMAT (code);\n+\n+  /* The primary target of a tablejump is the label of the ADDR_VEC,\n+     which is canonically mentioned *last* in the insn.  To get it\n+     marked as JUMP_LABEL, we iterate over items in reverse order.  */\n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n     {\n       if (fmt[i] == 'e')\n-\tmark_jump_label (XEXP (x, i), insn, in_mem);\n+\tmark_jump_label_1 (XEXP (x, i), insn, in_mem, is_target);\n       else if (fmt[i] == 'E')\n \t{\n \t  int j;\n-\t  for (j = 0; j < XVECLEN (x, i); j++)\n-\t    mark_jump_label (XVECEXP (x, i, j), insn, in_mem);\n+\n+\t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n+\t    mark_jump_label_1 (XVECEXP (x, i, j), insn, in_mem,\n+\t\t\t       is_target);\n \t}\n     }\n }\n@@ -1062,20 +1147,10 @@ delete_related_insns (rtx insn)\n       rtx lab = JUMP_LABEL (insn), lab_next;\n \n       if (LABEL_NUSES (lab) == 0)\n-\t{\n-\t  /* This can delete NEXT or PREV,\n-\t     either directly if NEXT is JUMP_LABEL (INSN),\n-\t     or indirectly through more levels of jumps.  */\n-\t  delete_related_insns (lab);\n-\n-\t  /* I feel a little doubtful about this loop,\n-\t     but I see no clean and sure alternative way\n-\t     to find the first insn after INSN that is not now deleted.\n-\t     I hope this works.  */\n-\t  while (next && INSN_DELETED_P (next))\n-\t    next = NEXT_INSN (next);\n-\t  return next;\n-\t}\n+\t/* This can delete NEXT or PREV,\n+\t   either directly if NEXT is JUMP_LABEL (INSN),\n+\t   or indirectly through more levels of jumps.  */\n+\tdelete_related_insns (lab);\n       else if (tablejump_p (insn, NULL, &lab_next))\n \t{\n \t  /* If we're deleting the tablejump, delete the dispatch table.\n@@ -1104,10 +1179,12 @@ delete_related_insns (rtx insn)\n       return next;\n     }\n \n-  /* Likewise for an ordinary INSN / CALL_INSN with a REG_LABEL note.  */\n-  if (NONJUMP_INSN_P (insn) || CALL_P (insn))\n+  /* Likewise for any JUMP_P / INSN / CALL_INSN with a\n+     REG_LABEL_OPERAND or REG_LABEL_TARGET note.  */\n+  if (INSN_P (insn))\n     for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n-      if (REG_NOTE_KIND (note) == REG_LABEL\n+      if ((REG_NOTE_KIND (note) == REG_LABEL_OPERAND\n+\t   || REG_NOTE_KIND (note) == REG_LABEL_TARGET)\n \t  /* This could also be a NOTE_INSN_DELETED_LABEL note.  */\n \t  && LABEL_P (XEXP (note, 0)))\n \tif (LABEL_NUSES (XEXP (note, 0)) == 0)\n@@ -1151,6 +1228,12 @@ delete_related_insns (rtx insn)\n \t}\n     }\n \n+  /* I feel a little doubtful about this loop,\n+     but I see no clean and sure alternative way\n+     to find the first insn after INSN that is not now deleted.\n+     I hope this works.  */\n+  while (next && INSN_DELETED_P (next))\n+    next = NEXT_INSN (next);\n   return next;\n }\n \f\n@@ -1307,6 +1390,8 @@ redirect_jump_2 (rtx jump, rtx olabel, rtx nlabel, int delete_unused,\n {\n   rtx note;\n \n+  gcc_assert (JUMP_LABEL (jump) == olabel);\n+\n   /* Negative DELETE_UNUSED used to be used to signalize behavior on\n      moving FUNCTION_END note.  Just sanity check that no user still worry\n      about this.  */"}, {"sha": "d77645573f3fbb953d7275a60c63315b5849c71b", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf7c4aa6af680063a0c08b79ce59cc3d0032cc9b/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf7c4aa6af680063a0c08b79ce59cc3d0032cc9b/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=cf7c4aa6af680063a0c08b79ce59cc3d0032cc9b", "patch": "@@ -335,6 +335,9 @@ print_rtx (const_rtx in_rtx)\n \t\tbreak;\n \t      }\n \t  }\n+\telse if (i == 9 && JUMP_P (in_rtx) && XEXP (in_rtx, i) != NULL)\n+\t  /* Output the JUMP_LABEL reference.  */\n+\t  fprintf (outfile, \"\\n -> %d\", INSN_UID (XEXP (in_rtx, i)));\n \tbreak;\n \n       case 'e':"}, {"sha": "713bc2878e530c3a1c238c0076fb4ecf4dc26d92", "filename": "gcc/reg-notes.def", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf7c4aa6af680063a0c08b79ce59cc3d0032cc9b/gcc%2Freg-notes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf7c4aa6af680063a0c08b79ce59cc3d0032cc9b/gcc%2Freg-notes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-notes.def?ref=cf7c4aa6af680063a0c08b79ce59cc3d0032cc9b", "patch": "@@ -91,10 +91,16 @@ REG_NOTE (UNUSED)\n REG_NOTE (CC_SETTER)\n REG_NOTE (CC_USER)\n \n-/* Points to a CODE_LABEL.  Used by non-JUMP_INSNs to say that the\n-   CODE_LABEL contained in the REG_LABEL note is used by the insn.\n-   This note is an INSN_LIST.  */\n-REG_NOTE (LABEL)\n+/* Points to a CODE_LABEL.  Used by JUMP_INSNs to say that the CODE_LABEL\n+   contained in the REG_LABEL_TARGET note is a possible jump target of\n+   this insn.  This note is an INSN_LIST.  */\n+REG_NOTE (LABEL_TARGET)\n+\n+/* Points to a CODE_LABEL.  Used by any insn to say that the CODE_LABEL\n+   contained in the REG_LABEL_OPERAND note is used by the insn, but as an\n+   operand, not as a jump target (though it may indirectly be a jump\n+   target for a later jump insn).  This note is an INSN_LIST.  */\n+REG_NOTE (LABEL_OPERAND)\n \n /* REG_DEP_OUTPUT and REG_DEP_ANTI are used in scheduler dependencies lists\n    to represent write-after-write and write-after-read dependencies"}, {"sha": "e88a82de7c42e6e9bd05430d5aba9cfec43ca086", "filename": "gcc/reload.c", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf7c4aa6af680063a0c08b79ce59cc3d0032cc9b/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf7c4aa6af680063a0c08b79ce59cc3d0032cc9b/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=cf7c4aa6af680063a0c08b79ce59cc3d0032cc9b", "patch": "@@ -4103,13 +4103,18 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \n \t  *recog_data.operand_loc[i] = substitution;\n \n-\t  /* If we're replacing an operand with a LABEL_REF, we need\n-\t     to make sure that there's a REG_LABEL note attached to\n+\t  /* If we're replacing an operand with a LABEL_REF, we need to\n+\t     make sure that there's a REG_LABEL_OPERAND note attached to\n \t     this instruction.  */\n-\t  if (!JUMP_P (insn)\n-\t      && GET_CODE (substitution) == LABEL_REF\n-\t      && !find_reg_note (insn, REG_LABEL, XEXP (substitution, 0)))\n-\t    REG_NOTES (insn) = gen_rtx_INSN_LIST (REG_LABEL,\n+\t  if (GET_CODE (substitution) == LABEL_REF\n+\t      && !find_reg_note (insn, REG_LABEL_OPERAND,\n+\t\t\t\t XEXP (substitution, 0))\n+\t      /* For a JUMP_P, if it was a branch target it must have\n+\t\t already been recorded as such.  */\n+\t      && (!JUMP_P (insn)\n+\t\t  || !label_is_jump_target_p (XEXP (substitution, 0),\n+\t\t\t\t\t      insn)))\n+\t    REG_NOTES (insn) = gen_rtx_INSN_LIST (REG_LABEL_OPERAND,\n \t\t\t\t\t\t  XEXP (substitution, 0),\n \t\t\t\t\t\t  REG_NOTES (insn));\n \t}\n@@ -6123,17 +6128,15 @@ subst_reloads (rtx insn)\n \t    }\n #endif /* DEBUG_RELOAD */\n \n-\t  /* If we're replacing a LABEL_REF with a register, add a\n-\t     REG_LABEL note to indicate to flow which label this\n+\t  /* If we're replacing a LABEL_REF with a register, there must\n+\t     already be an indication (to e.g. flow) which label this\n \t     register refers to.  */\n-\t  if (GET_CODE (*r->where) == LABEL_REF\n-\t      && JUMP_P (insn))\n-\t    {\n-\t      REG_NOTES (insn) = gen_rtx_INSN_LIST (REG_LABEL,\n-\t\t\t\t\t\t    XEXP (*r->where, 0),\n-\t\t\t\t\t\t    REG_NOTES (insn));\n-\t      JUMP_LABEL (insn) = XEXP (*r->where, 0);\n-\t   }\n+\t  gcc_assert (GET_CODE (*r->where) != LABEL_REF\n+\t\t      || !JUMP_P (insn)\n+\t\t      || find_reg_note (insn,\n+\t\t\t\t\tREG_LABEL_OPERAND,\n+\t\t\t\t\tXEXP (*r->where, 0))\n+\t\t      || label_is_jump_target_p (XEXP (*r->where, 0), insn));\n \n \t  /* Encapsulate RELOADREG so its machine mode matches what\n \t     used to be there.  Note that gen_lowpart_common will"}, {"sha": "9021050c409ef02d48ce6710e3bf80841dd3acf3", "filename": "gcc/reload1.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf7c4aa6af680063a0c08b79ce59cc3d0032cc9b/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf7c4aa6af680063a0c08b79ce59cc3d0032cc9b/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=cf7c4aa6af680063a0c08b79ce59cc3d0032cc9b", "patch": "@@ -1539,8 +1539,8 @@ calculate_needs_all_insns (int global)\n       chain->need_operand_change = 0;\n \n       /* If this is a label, a JUMP_INSN, or has REG_NOTES (which might\n-\t include REG_LABEL), we need to see what effects this has on the\n-\t known offsets at labels.  */\n+\t include REG_LABEL_OPERAND and REG_LABEL_TARGET), we need to see\n+\t what effects this has on the known offsets at labels.  */\n \n       if (LABEL_P (insn) || JUMP_P (insn)\n \t  || (INSN_P (insn) && REG_NOTES (insn) != 0))\n@@ -2295,10 +2295,11 @@ set_label_offsets (rtx x, rtx insn, int initial_p)\n \n     case INSN:\n     case CALL_INSN:\n-      /* Any labels mentioned in REG_LABEL notes can be branched to indirectly\n-\t and hence must have all eliminations at their initial offsets.  */\n+      /* Any labels mentioned in REG_LABEL_OPERAND notes can be branched\n+\t to indirectly and hence must have all eliminations at their\n+\t initial offsets.  */\n       for (tem = REG_NOTES (x); tem; tem = XEXP (tem, 1))\n-\tif (REG_NOTE_KIND (tem) == REG_LABEL)\n+\tif (REG_NOTE_KIND (tem) == REG_LABEL_OPERAND)\n \t  set_label_offsets (XEXP (tem, 0), insn, 1);\n       return;\n \n@@ -8049,7 +8050,7 @@ gen_reload (rtx out, rtx in, int opnum, enum reload_type type)\n   else if (OBJECT_P (in) || GET_CODE (in) == SUBREG)\n     {\n       tem = emit_insn (gen_move_insn (out, in));\n-      /* IN may contain a LABEL_REF, if so add a REG_LABEL note.  */\n+      /* IN may contain a LABEL_REF, if so add a REG_LABEL_OPERAND note.  */\n       mark_jump_label (in, tem, 0);\n     }\n "}, {"sha": "291e1aad3b19aa290070d1f9da487a6108bc487a", "filename": "gcc/reorg.c", "status": "modified", "additions": 32, "deletions": 5, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf7c4aa6af680063a0c08b79ce59cc3d0032cc9b/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf7c4aa6af680063a0c08b79ce59cc3d0032cc9b/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=cf7c4aa6af680063a0c08b79ce59cc3d0032cc9b", "patch": "@@ -541,7 +541,8 @@ emit_delay_sequence (rtx insn, rtx list, int length)\n \t      remove_note (tem, note);\n \t      break;\n \n-\t    case REG_LABEL:\n+\t    case REG_LABEL_OPERAND:\n+\t    case REG_LABEL_TARGET:\n \t      /* Keep the label reference count up to date.  */\n \t      if (LABEL_P (XEXP (note, 0)))\n \t\tLABEL_NUSES (XEXP (note, 0)) ++;\n@@ -2736,14 +2737,40 @@ fill_slots_from_thread (rtx insn, rtx condition, rtx thread,\n \t\t      /* We are moving this insn, not deleting it.  We must\n \t\t\t temporarily increment the use count on any referenced\n \t\t\t label lest it be deleted by delete_related_insns.  */\n-\t\t      note = find_reg_note (trial, REG_LABEL, 0);\n-\t\t      /* REG_LABEL could be NOTE_INSN_DELETED_LABEL too.  */\n-\t\t      if (note && LABEL_P (XEXP (note, 0)))\n+\t\t      for (note = REG_NOTES (trial);\n+\t\t\t   note != NULL;\n+\t\t\t   note = XEXP (note, 1))\n+\t\t\tif (REG_NOTE_KIND (note) == REG_LABEL_OPERAND\n+\t\t\t    || REG_NOTE_KIND (note) == REG_LABEL_TARGET)\n+\t\t\t  {\n+\t\t\t    /* REG_LABEL_OPERAND could be\n+\t\t\t       NOTE_INSN_DELETED_LABEL too.  */\n+\t\t\t    if (LABEL_P (XEXP (note, 0)))\n+\t\t\t      LABEL_NUSES (XEXP (note, 0))++;\n+\t\t\t    else\n+\t\t\t      gcc_assert (REG_NOTE_KIND (note)\n+\t\t\t\t\t  == REG_LABEL_OPERAND);\n+\t\t\t  }\n+\t\t      if (JUMP_P (trial) && JUMP_LABEL (trial))\n \t\t\tLABEL_NUSES (XEXP (note, 0))++;\n \n \t\t      delete_related_insns (trial);\n \n-\t\t      if (note && LABEL_P (XEXP (note, 0)))\n+\t\t      for (note = REG_NOTES (trial);\n+\t\t\t   note != NULL;\n+\t\t\t   note = XEXP (note, 1))\n+\t\t\tif (REG_NOTE_KIND (note) == REG_LABEL_OPERAND\n+\t\t\t    || REG_NOTE_KIND (note) == REG_LABEL_TARGET)\n+\t\t\t  {\n+\t\t\t    /* REG_LABEL_OPERAND could be\n+\t\t\t       NOTE_INSN_DELETED_LABEL too.  */\n+\t\t\t    if (LABEL_P (XEXP (note, 0)))\n+\t\t\t      LABEL_NUSES (XEXP (note, 0))--;\n+\t\t\t    else\n+\t\t\t      gcc_assert (REG_NOTE_KIND (note)\n+\t\t\t\t\t  == REG_LABEL_OPERAND);\n+\t\t\t  }\n+\t\t      if (JUMP_P (trial) && JUMP_LABEL (trial))\n \t\t\tLABEL_NUSES (XEXP (note, 0))--;\n \t\t    }\n \t\t  else"}, {"sha": "3473fb3c34abce3b249fdc82e1031157142e5de6", "filename": "gcc/rtl.h", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf7c4aa6af680063a0c08b79ce59cc3d0032cc9b/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf7c4aa6af680063a0c08b79ce59cc3d0032cc9b/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=cf7c4aa6af680063a0c08b79ce59cc3d0032cc9b", "patch": "@@ -265,7 +265,8 @@ struct rtx_def GTY((chain_next (\"RTX_NEXT (&%h)\"),\n      1 in a REG expression if corresponds to a variable declared by the user,\n      0 for an internally generated temporary.\n      1 in a SUBREG with a negative value.\n-     1 in a LABEL_REF or in a REG_LABEL note for a non-local label.\n+     1 in a LABEL_REF, REG_LABEL_TARGET or REG_LABEL_OPERAND note for a\n+     non-local label.\n      In a SYMBOL_REF, this flag is used for machine-specific purposes.  */\n   unsigned int volatil : 1;\n   /* 1 in a MEM referring to a field of an aggregate.\n@@ -1224,10 +1225,11 @@ do {\t\t\t\t\t\t\\\n    MEM_ATTRS (LHS) = MEM_ATTRS (RHS))\n \n /* 1 if RTX is a label_ref for a nonlocal label.  */\n-/* Likewise in an expr_list for a reg_label note.  */\n+/* Likewise in an expr_list for a REG_LABEL_OPERAND or\n+   REG_LABEL_TARGET note.  */\n #define LABEL_REF_NONLOCAL_P(RTX)\t\t\t\t\t\\\n-  (RTL_FLAG_CHECK2(\"LABEL_REF_NONLOCAL_P\", (RTX), LABEL_REF,\t\t\\\n-\t\t   REG_LABEL)->volatil)\n+  (RTL_FLAG_CHECK3(\"LABEL_REF_NONLOCAL_P\", (RTX), LABEL_REF,\t\t\\\n+\t\t   REG_LABEL_OPERAND, REG_LABEL_TARGET)->volatil)\n \n /* 1 if RTX is a code_label that should always be considered to be needed.  */\n #define LABEL_PRESERVE_P(RTX)\t\t\t\t\t\t\\"}, {"sha": "a47c36f0b099c8e86e5cbf824fdf261a348c6db0", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf7c4aa6af680063a0c08b79ce59cc3d0032cc9b/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf7c4aa6af680063a0c08b79ce59cc3d0032cc9b/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=cf7c4aa6af680063a0c08b79ce59cc3d0032cc9b", "patch": "@@ -2703,9 +2703,11 @@ computed_jump_p (const_rtx insn)\n     {\n       rtx pat = PATTERN (insn);\n \n-      if (find_reg_note (insn, REG_LABEL, NULL_RTX))\n+      /* If we have a JUMP_LABEL set, we're not a computed jump.  */\n+      if (JUMP_LABEL (insn) != NULL)\n \treturn 0;\n-      else if (GET_CODE (pat) == PARALLEL)\n+\n+      if (GET_CODE (pat) == PARALLEL)\n \t{\n \t  int len = XVECLEN (pat, 0);\n \t  int has_use_labelref = 0;"}, {"sha": "0ca1a472fa311fafaf4b464563b5501fda881fd4", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf7c4aa6af680063a0c08b79ce59cc3d0032cc9b/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf7c4aa6af680063a0c08b79ce59cc3d0032cc9b/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=cf7c4aa6af680063a0c08b79ce59cc3d0032cc9b", "patch": "@@ -315,24 +315,20 @@ is_cfg_nonregular (void)\n   if (current_function_has_exception_handlers ())\n     return 1;\n \n-  /* If we have non-jumping insns which refer to labels, then we consider\n-     the cfg not well structured.  */\n+  /* If we have insns which refer to labels as non-jumped-to operands,\n+     then we consider the cfg not well structured.  */\n   FOR_EACH_BB (b)\n     FOR_BB_INSNS (b, insn)\n       {\n-\t/* Check for labels referred by non-jump insns.  */\n-\tif (NONJUMP_INSN_P (insn) || CALL_P (insn))\n-\t  {\n-\t    rtx note = find_reg_note (insn, REG_LABEL, NULL_RTX);\n-\t    if (note\n-\t\t&& ! (JUMP_P (NEXT_INSN (insn))\n-\t\t      && find_reg_note (NEXT_INSN (insn), REG_LABEL,\n-\t\t\t\t\tXEXP (note, 0))))\n-\t      return 1;\n-\t  }\n+\t/* Check for labels referred to but (at least not directly) as\n+\t   jump targets.  */\n+\tif (INSN_P (insn)\n+\t    && find_reg_note (insn, REG_LABEL_OPERAND, NULL_RTX))\n+\t  return 1;\n+\n \t/* If this function has a computed jump, then we consider the cfg\n \t   not well structured.  */\n-\telse if (JUMP_P (insn) && computed_jump_p (insn))\n+\tif (JUMP_P (insn) && computed_jump_p (insn))\n \t  return 1;\n       }\n "}]}