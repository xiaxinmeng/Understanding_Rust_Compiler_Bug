{"sha": "1107b970c6701a65fbf0e74ad6dbfe329a580352", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTEwN2I5NzBjNjcwMWE2NWZiZjBlNzRhZDZkYmZlMzI5YTU4MDM1Mg==", "commit": {"author": {"name": "Paul Brook", "email": "pbrook@gcc.gnu.org", "date": "2004-07-03T23:25:46Z"}, "committer": {"name": "Paul Brook", "email": "pbrook@gcc.gnu.org", "date": "2004-07-03T23:25:46Z"}, "message": "decl.c (gfc_match_implicit_range): Don't use typespec.\n\n\t* decl.c (gfc_match_implicit_range): Don't use typespec.\n\t(gfc_match_implicit): Handle character selectors.\n\t* gfortran.h (gfc_set_implicit): Remove prototype.\n\t(gfc_add_new_implicit_range, gfc_merge_new_implicit): Update.\n\t* parse.c (accept_statement): Don't call gfc_set_implicit.\n\t* symbol.c (new_ts): Remove.\n\t(gfc_set_implicit_none): Use same loop bounds as other functions.\n\t(gfc_set_implicit): Remove.\n\t(gfc_clear_new_implicit, gfc_add_new_implicit_range): Only set flags.\n\t(gfc_merge_new_implicit): Combine with gfc_set_implicit.\ntestsuite/\n\t* gfortran.fortran-torture/compile/implicit_1.f90: New test.\n\nFrom-SVN: r84063", "tree": {"sha": "1136b6ff2a39b0f1c3c84d79290dcd083129c622", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1136b6ff2a39b0f1c3c84d79290dcd083129c622"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1107b970c6701a65fbf0e74ad6dbfe329a580352", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1107b970c6701a65fbf0e74ad6dbfe329a580352", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1107b970c6701a65fbf0e74ad6dbfe329a580352", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1107b970c6701a65fbf0e74ad6dbfe329a580352/comments", "author": null, "committer": null, "parents": [{"sha": "614ed70a597544644d86a8346e0158acec5886c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/614ed70a597544644d86a8346e0158acec5886c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/614ed70a597544644d86a8346e0158acec5886c1"}], "stats": {"total": 211, "additions": 126, "deletions": 85}, "files": [{"sha": "a477814081ba56caa01353360120ec20291f6e43", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1107b970c6701a65fbf0e74ad6dbfe329a580352/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1107b970c6701a65fbf0e74ad6dbfe329a580352/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=1107b970c6701a65fbf0e74ad6dbfe329a580352", "patch": "@@ -1,3 +1,16 @@\n+2004-07-04  Paul Brook  <paul@codesourcery.com>\n+\n+\t* decl.c (gfc_match_implicit_range): Don't use typespec.\n+\t(gfc_match_implicit): Handle character selectors.\n+\t* gfortran.h (gfc_set_implicit): Remove prototype.\n+\t(gfc_add_new_implicit_range, gfc_merge_new_implicit): Update.\n+\t* parse.c (accept_statement): Don't call gfc_set_implicit.\n+\t* symbol.c (new_ts): Remove.\n+\t(gfc_set_implicit_none): Use same loop bounds as other functions.\n+\t(gfc_set_implicit): Remove.\n+\t(gfc_clear_new_implicit, gfc_add_new_implicit_range): Only set flags.\n+\t(gfc_merge_new_implicit): Combine with gfc_set_implicit.\n+\n 2004-06-30  Richard Henderson  <rth@redhat.com>\n \n \t* match.c (var_element): Remove unused variable."}, {"sha": "94573ac9df57443a2c4cf41eab189a7de4361880", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 44, "deletions": 29, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1107b970c6701a65fbf0e74ad6dbfe329a580352/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1107b970c6701a65fbf0e74ad6dbfe329a580352/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=1107b970c6701a65fbf0e74ad6dbfe329a580352", "patch": "@@ -1001,7 +1001,7 @@ gfc_match_implicit_none (void)\n /* Match the letter range(s) of an IMPLICIT statement.  */\n \n static match\n-match_implicit_range (gfc_typespec * ts)\n+match_implicit_range (void)\n {\n   int c, c1, c2, inner;\n   locus cur_loc;\n@@ -1068,7 +1068,7 @@ match_implicit_range (gfc_typespec * ts)\n          conflicts with whatever earlier IMPLICIT statements may have\n          set.  This is done when we've successfully finished matching\n          the current one.  */\n-      if (gfc_add_new_implicit_range (c1, c2, ts) != SUCCESS)\n+      if (gfc_add_new_implicit_range (c1, c2) != SUCCESS)\n \tgoto bad;\n     }\n \n@@ -1116,11 +1116,11 @@ gfc_match_implicit (void)\n       return MATCH_ERROR;\n     }\n \n-  /* First cleanup.  */\n-  gfc_clear_new_implicit ();\n-\n   do\n     {\n+      /* First cleanup.  */\n+      gfc_clear_new_implicit ();\n+\n       /* A basic type is mandatory here.  */\n       m = match_type_spec (&ts, 1);\n       if (m == MATCH_ERROR)\n@@ -1129,39 +1129,56 @@ gfc_match_implicit (void)\n \tgoto syntax;\n \n       cur_loc = gfc_current_locus;\n-      m = match_implicit_range (&ts);\n-\n-      if (m != MATCH_YES && ts.type == BT_CHARACTER)\n-\t{\n-\t  /* looks like we are matching CHARACTER (<len>) (<range>)  */\n-\t  m = match_char_spec (&ts);\n-\t}\t  \n+      m = match_implicit_range ();\n \n       if (m == MATCH_YES)\n \t{\n-\t  /* Looks like we have the <TYPE> (<RANGE>).  */\n+\t  /* We may have <TYPE> (<RANGE>).  */\n \t  gfc_gobble_whitespace ();\n \t  c = gfc_next_char ();\n \t  if ((c == '\\n') || (c == ','))\n-\t    continue;\n+\t    {\n+\t      /* Check for CHARACTER with no length parameter.  */\n+\t      if (ts.type == BT_CHARACTER && !ts.cl)\n+\t\t{\n+\t\t  ts.kind = gfc_default_character_kind ();\n+\t\t  ts.cl = gfc_get_charlen ();\n+\t\t  ts.cl->next = gfc_current_ns->cl_list;\n+\t\t  gfc_current_ns->cl_list = ts.cl;\n+\t\t  ts.cl->length = gfc_int_expr (1);\n+\t\t}\n+\n+\t      /* Record the Successful match.  */\n+\t      if (gfc_merge_new_implicit (&ts) != SUCCESS)\n+\t\treturn MATCH_ERROR;\n+\t      continue;\n+\t    }\n \n \t  gfc_current_locus = cur_loc;\n \t}\n \n-      /* Last chance -- check <TYPE> (<KIND>) (<RANGE>).  */\n-      m = gfc_match_kind_spec (&ts);\n-      if (m == MATCH_ERROR)\n-\tgoto error;\n-      if (m == MATCH_NO)\n+      /* Discard the (incorrectly) matched range.  */\n+      gfc_clear_new_implicit ();\n+\n+      /* Last chance -- check <TYPE> <SELECTOR> (<RANGE>).  */\n+      if (ts.type == BT_CHARACTER)\n+\tm = match_char_spec (&ts);\n+      else\n \t{\n-\t  m = gfc_match_old_kind_spec (&ts);\n-\t  if (m == MATCH_ERROR)\n-\t    goto error;\n+\t  m = gfc_match_kind_spec (&ts);\n \t  if (m == MATCH_NO)\n-\t    goto syntax;\n+\t    {\n+\t      m = gfc_match_old_kind_spec (&ts);\n+\t      if (m == MATCH_ERROR)\n+\t\tgoto error;\n+\t      if (m == MATCH_NO)\n+\t\tgoto syntax;\n+\t    }\n \t}\n+      if (m == MATCH_ERROR)\n+\tgoto error;\n \n-      m = match_implicit_range (&ts);\n+      m = match_implicit_range ();\n       if (m == MATCH_ERROR)\n \tgoto error;\n       if (m == MATCH_NO)\n@@ -1172,14 +1189,12 @@ gfc_match_implicit (void)\n       if ((c != '\\n') && (c != ','))\n \tgoto syntax;\n \n+      if (gfc_merge_new_implicit (&ts) != SUCCESS)\n+\treturn MATCH_ERROR;\n     }\n   while (c == ',');\n \n-  /* All we need to now is try to merge the new implicit types back\n-     into the existing types.  This will fail if another implicit\n-     type is already defined for a letter.  */\n-  return (gfc_merge_new_implicit () == SUCCESS) ?\n-      MATCH_YES : MATCH_ERROR;\n+  return MATCH_YES;\n \n syntax:\n   gfc_syntax_error (ST_IMPLICIT);"}, {"sha": "86113ad0495a9933307851efc8fa874d575e6b57", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1107b970c6701a65fbf0e74ad6dbfe329a580352/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1107b970c6701a65fbf0e74ad6dbfe329a580352/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=1107b970c6701a65fbf0e74ad6dbfe329a580352", "patch": "@@ -1435,10 +1435,9 @@ extern int gfc_index_integer_kind;\n \n /* symbol.c */\n void gfc_clear_new_implicit (void);\n-try gfc_add_new_implicit_range (int, int, gfc_typespec *);\n-try gfc_merge_new_implicit (void);\n+try gfc_add_new_implicit_range (int, int);\n+try gfc_merge_new_implicit (gfc_typespec *);\n void gfc_set_implicit_none (void);\n-void gfc_set_implicit (void);\n \n gfc_typespec *gfc_get_default_type (gfc_symbol *, gfc_namespace *);\n try gfc_set_default_type (gfc_symbol *, int, gfc_namespace *);"}, {"sha": "15a53ea3e457bd59650b62c54a5ab0d60f5ed26c", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1107b970c6701a65fbf0e74ad6dbfe329a580352/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1107b970c6701a65fbf0e74ad6dbfe329a580352/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=1107b970c6701a65fbf0e74ad6dbfe329a580352", "patch": "@@ -1019,7 +1019,6 @@ accept_statement (gfc_statement st)\n       break;\n \n     case ST_IMPLICIT:\n-      gfc_set_implicit ();\n       break;\n \n     case ST_FUNCTION:"}, {"sha": "9208d2205d9eafa4d8f276b428eab99232721a62", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 27, "deletions": 48, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1107b970c6701a65fbf0e74ad6dbfe329a580352/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1107b970c6701a65fbf0e74ad6dbfe329a580352/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=1107b970c6701a65fbf0e74ad6dbfe329a580352", "patch": "@@ -96,13 +96,9 @@ static gfc_symbol *changed_syms = NULL;\n \n /*********** IMPLICIT NONE and IMPLICIT statement handlers ***********/\n \n-/* The following static variables hold the default types set by\n-   IMPLICIT statements.  We have to store kind information because of\n-   IMPLICIT DOUBLE PRECISION statements.  IMPLICIT NONE stores a\n-   BT_UNKNOWN into all elements.  The arrays of flags indicate whether\n-   a particular element has been explicitly set or not.  */\n+/* The following static variable indicates whether a particular element has\n+   been explicitly set or not.  */\n \n-static gfc_typespec new_ts[GFC_LETTERS];\n static int new_flag[GFC_LETTERS];\n \n \n@@ -113,48 +109,30 @@ gfc_set_implicit_none (void)\n {\n   int i;\n \n-  for (i = 'a'; i <= 'z'; i++)\n+  for (i = 0; i < GFC_LETTERS; i++)\n     {\n-      gfc_clear_ts (&gfc_current_ns->default_type[i - 'a']);\n-      gfc_current_ns->set_flag[i - 'a'] = 1;\n+      gfc_clear_ts (&gfc_current_ns->default_type[i]);\n+      gfc_current_ns->set_flag[i] = 1;\n     }\n }\n \n \n-/* Sets the implicit types parsed by gfc_match_implicit().  */\n+/* Reset the implicit range flags.  */\n \n void\n-gfc_set_implicit (void)\n-{\n-  int i;\n-\n-  for (i = 0; i < GFC_LETTERS; i++)\n-    if (new_flag[i])\n-      {\n-\tgfc_current_ns->default_type[i] = new_ts[i];\n-\tgfc_current_ns->set_flag[i] = 1;\n-      }\n-}\n-\n-\n-/* Wipe anything a previous IMPLICIT statement may have tried to do.  */\n-void gfc_clear_new_implicit (void)\n+gfc_clear_new_implicit (void)\n {\n   int i;\n \n   for (i = 0; i < GFC_LETTERS; i++)\n-    {\n-      gfc_clear_ts (&new_ts[i]);\n-      if (new_flag[i])\n-\tnew_flag[i] = 0;\n-    }\n+    new_flag[i] = 0;\n }\n \n \n-/* Prepare for a new implicit range. Sets flags in new_flag[] and\n-   copies the typespec to new_ts[].  */\n+/* Prepare for a new implicit range.  Sets flags in new_flag[].  */\n \n-try gfc_add_new_implicit_range (int c1, int c2, gfc_typespec * ts)\n+try\n+gfc_add_new_implicit_range (int c1, int c2)\n {\n   int i;\n \n@@ -170,35 +148,36 @@ try gfc_add_new_implicit_range (int c1, int c2, gfc_typespec * ts)\n \t  return FAILURE;\n \t}\n \n-      new_ts[i] = *ts;\n       new_flag[i] = 1;\n     }\n \n   return SUCCESS;\n }\n \n \n-/* Add a matched implicit range for gfc_set_implicit().  An implicit\n-   statement has been fully matched at this point.  We now need to\n-   check if merging the new implicit types back into the existing\n-   types will work.  */\n+/* Add a matched implicit range for gfc_set_implicit().  Check if merging\n+   the new implicit types back into the existing types will work.  */\n \n try\n-gfc_merge_new_implicit (void)\n+gfc_merge_new_implicit (gfc_typespec * ts)\n {\n   int i;\n \n   for (i = 0; i < GFC_LETTERS; i++)\n-    if (new_flag[i])\n-      {\n-\tif (gfc_current_ns->set_flag[i])\n-\t  {\n-\t    gfc_error (\"Letter %c already has an IMPLICIT type at %C\",\n-\t\t       i + 'A');\n-\t    return FAILURE;\n-\t  }\n-      }\n+    {\n+      if (new_flag[i])\n+\t{\n \n+\t  if (gfc_current_ns->set_flag[i])\n+\t    {\n+\t      gfc_error (\"Letter %c already has an IMPLICIT type at %C\",\n+\t\t\t i + 'A');\n+\t      return FAILURE;\n+\t    }\n+\t  gfc_current_ns->default_type[i] = *ts;\n+\t  gfc_current_ns->set_flag[i] = 1;\n+\t}\n+    }\n   return SUCCESS;\n }\n "}, {"sha": "1ca7e1a0a1f73d2d5de26efc757d497bd5a03f0e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1107b970c6701a65fbf0e74ad6dbfe329a580352/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1107b970c6701a65fbf0e74ad6dbfe329a580352/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1107b970c6701a65fbf0e74ad6dbfe329a580352", "patch": "@@ -1,7 +1,11 @@\n-2004-07-03  Scott Brumbaugh  <scottb.lists@verizon.net>\r\n-\r\n-\tPR c++/3761\r\n-\t* g++.dg/lookup/crash4.C: New test.\r\n+2004-07-04  Paul Brook  <paul@codesourcery.com>\n+\n+\t* gfortran.fortran-torture/compile/implicit_1.f90: New test.\n+\n+2004-07-03  Scott Brumbaugh  <scottb.lists@verizon.net>\n+\n+\tPR c++/3761\n+\t* g++.dg/lookup/crash4.C: New test.\n \n 2004-07-02  Zack Weinberg  <zack@codesourcery.com>\n "}, {"sha": "f56bd63b462b894e7c5219daa62355936dfda5bd", "filename": "gcc/testsuite/gfortran.fortran-torture/compile/implicit_1.f90", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1107b970c6701a65fbf0e74ad6dbfe329a580352/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fcompile%2Fimplicit_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1107b970c6701a65fbf0e74ad6dbfe329a580352/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fcompile%2Fimplicit_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fcompile%2Fimplicit_1.f90?ref=1107b970c6701a65fbf0e74ad6dbfe329a580352", "patch": "@@ -0,0 +1,32 @@\n+! Test implicit character declarations.\n+! This requires some coordination between the typespec and variable name range\n+! matchers to get it right.\n+module implicit_1\n+  integer, parameter :: x = 10\n+  integer, parameter :: y = 6\n+  integer, parameter :: z = selected_int_kind(4)\n+end module\n+subroutine foo(n)\n+  use implicit_1\n+  ! Test various combinations with and without character length\n+  ! and type kind specifiers\n+  implicit character(len=5) (a)\n+  implicit character(n) (b)\n+  implicit character*6 (c-d)\n+  implicit character (e)\n+  implicit character(x-y) (f)\n+  implicit integer(z) (g)\n+  implicit character (z)\n+\n+  a1 = 'Hello'\n+  b1 = 'world'\n+  c1 = 'wibble'\n+  d1 = 'hmmm'\n+  e1 = 'n'\n+  f1 = 'test'\n+  g1 = 1\n+  x1 = 1.0\n+  y1 = 2.0\n+  z1 = 'A'\n+end\n+"}]}