{"sha": "e08341bb0e026ef019a3b201ea26ecdc4a9233ea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTA4MzQxYmIwZTAyNmVmMDE5YTNiMjAxZWEyNmVjZGM0YTkyMzNlYQ==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2018-09-14T18:23:58Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2018-09-14T18:23:58Z"}, "message": "builtins.c (unterminated_array): New.\n\n\t* builtins.c (unterminated_array): New.\n\t(expand_builtin_strcpy): Adjust.\n\t(expand_builtin_strcpy_args): Detect unterminated arrays.\n\t* gimple-fold.c (get_maxval_strlen): Add argument.  Detect\n\tunterminated arrays.\n\t* gimple-fold.h (get_maxval_strlen): Add argument.\n\t(gimple_fold_builtin_strcpy): Detec unterminated arrays.\n\n\t* gimple-fold.c (get_range_strlen): Add argument.\n\t(get_maxval_strlen): Adjust.\n\t* gimple-fold.h (get_range_strlen): Add argument.\n\n\t* gcc.dg/warn-strcpy-no-nul.c: New test.\n\nCo-Authored-By: Jeff Law <law@redhat.com>\n\nFrom-SVN: r264327", "tree": {"sha": "85a654a129f0c74bd85567d343cb3ba067c3c9c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/85a654a129f0c74bd85567d343cb3ba067c3c9c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e08341bb0e026ef019a3b201ea26ecdc4a9233ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e08341bb0e026ef019a3b201ea26ecdc4a9233ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e08341bb0e026ef019a3b201ea26ecdc4a9233ea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e08341bb0e026ef019a3b201ea26ecdc4a9233ea/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "dd98382b8b016c9af092f77b47dfb7eaf35db426", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd98382b8b016c9af092f77b47dfb7eaf35db426", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd98382b8b016c9af092f77b47dfb7eaf35db426"}], "stats": {"total": 469, "additions": 449, "deletions": 20}, "files": [{"sha": "84578a331d7d0f418f5032c92b6a95ec19cc7bbc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e08341bb0e026ef019a3b201ea26ecdc4a9233ea/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e08341bb0e026ef019a3b201ea26ecdc4a9233ea/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e08341bb0e026ef019a3b201ea26ecdc4a9233ea", "patch": "@@ -1,3 +1,18 @@\n+2018-09-14  Martin Sebor  <msebor@redhat.com>\n+\t    Jeff Law  <law@redhat.com>\n+\n+\t* builtins.c (unterminated_array): New.\n+\t(expand_builtin_strcpy): Adjust.\n+\t(expand_builtin_strcpy_args): Detect unterminated arrays.\n+\t* gimple-fold.c (get_maxval_strlen): Add argument.  Detect\n+\tunterminated arrays.\n+\t* gimple-fold.h (get_maxval_strlen): Add argument.\n+\t(gimple_fold_builtin_strcpy): Detec unterminated arrays.\n+\n+\t* gimple-fold.c (get_range_strlen): Add argument.\n+\t(get_maxval_strlen): Adjust.\n+\t* gimple-fold.h (get_range_strlen): Add argument.\n+\n 2018-09-14  Wei Xiao  <wei3.xiao@intel.com>\n \n \t* config/i386/movdirintrin.h: Fix copyright year."}, {"sha": "be813db46b8de8bcb026a910a98345907b38be9e", "filename": "gcc/builtins.c", "status": "modified", "additions": 41, "deletions": 4, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e08341bb0e026ef019a3b201ea26ecdc4a9233ea/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e08341bb0e026ef019a3b201ea26ecdc4a9233ea/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=e08341bb0e026ef019a3b201ea26ecdc4a9233ea", "patch": "@@ -132,7 +132,7 @@ static rtx expand_builtin_mempcpy (tree, rtx);\n static rtx expand_builtin_mempcpy_args (tree, tree, tree, rtx, tree, int);\n static rtx expand_builtin_strcat (tree, rtx);\n static rtx expand_builtin_strcpy (tree, rtx);\n-static rtx expand_builtin_strcpy_args (tree, tree, rtx);\n+static rtx expand_builtin_strcpy_args (tree, tree, tree, rtx);\n static rtx expand_builtin_stpcpy (tree, rtx, machine_mode);\n static rtx expand_builtin_stpncpy (tree, rtx);\n static rtx expand_builtin_strncat (tree, rtx);\n@@ -563,6 +563,34 @@ warn_string_no_nul (location_t loc, const char *fn, tree arg, tree decl)\n     }\n }\n \n+/* If EXP refers to an unterminated constant character array return\n+   the declaration of the object of which the array is a member or\n+   element.  Otherwise return null.  */\n+\n+static tree\n+unterminated_array (tree exp)\n+{\n+  if (TREE_CODE (exp) == SSA_NAME)\n+    {\n+      gimple *stmt = SSA_NAME_DEF_STMT (exp);\n+      if (!is_gimple_assign (stmt))\n+\treturn NULL_TREE;\n+\n+      tree rhs1 = gimple_assign_rhs1 (stmt);\n+      tree_code code = gimple_assign_rhs_code (stmt);\n+      if (code != POINTER_PLUS_EXPR)\n+\treturn NULL_TREE;\n+\n+      exp = rhs1;\n+    }\n+\n+  tree nonstr = NULL;\n+  if (c_strlen (exp, 1, &nonstr, 1) == NULL && nonstr)\n+    return nonstr;\n+\n+  return NULL_TREE;\n+}\n+\n /* Compute the length of a null-terminated character string or wide\n    character string handling character sizes of 1, 2, and 4 bytes.\n    TREE_STRING_LENGTH is not the right way because it evaluates to\n@@ -3879,7 +3907,7 @@ expand_builtin_strcpy (tree exp, rtx target)\n \t\t    src, destsize);\n     }\n \n-  if (rtx ret = expand_builtin_strcpy_args (dest, src, target))\n+  if (rtx ret = expand_builtin_strcpy_args (exp, dest, src, target))\n     {\n       /* Check to see if the argument was declared attribute nonstring\n \t and if so, issue a warning since at this point it's not known\n@@ -3899,8 +3927,17 @@ expand_builtin_strcpy (tree exp, rtx target)\n    expand_builtin_strcpy.  */\n \n static rtx\n-expand_builtin_strcpy_args (tree dest, tree src, rtx target)\n+expand_builtin_strcpy_args (tree exp, tree dest, tree src, rtx target)\n {\n+  /* Detect strcpy calls with unterminated arrays..  */\n+  if (tree nonstr = unterminated_array (src))\n+    {\n+      /* NONSTR refers to the non-nul terminated constant array.  */\n+      if (!TREE_NO_WARNING (exp))\n+\twarn_string_no_nul (EXPR_LOCATION (exp), \"strcpy\", src, nonstr);\n+      return NULL_RTX;\n+    }\n+\n   return expand_movstr (dest, src, target, /*endp=*/0);\n }\n \n@@ -3960,7 +3997,7 @@ expand_builtin_stpcpy_1 (tree exp, rtx target, machine_mode mode)\n \n \t  if (CONST_INT_P (len_rtx))\n \t    {\n-\t      ret = expand_builtin_strcpy_args (dst, src, target);\n+\t      ret = expand_builtin_strcpy_args (exp, dst, src, target);\n \n \t      if (ret)\n \t\t{"}, {"sha": "e8733204b445ae844b04199f8a17e79bee0edec2", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 61, "deletions": 14, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e08341bb0e026ef019a3b201ea26ecdc4a9233ea/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e08341bb0e026ef019a3b201ea26ecdc4a9233ea/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=e08341bb0e026ef019a3b201ea26ecdc4a9233ea", "patch": "@@ -1280,12 +1280,13 @@ gimple_fold_builtin_memset (gimple_stmt_iterator *gsi, tree c, tree len)\n    obtained from the upper bound of an array at the end of a struct.\n    Such an array may hold a string that's longer than its upper bound\n    due to it being used as a poor-man's flexible array member.\n+   Pass NONSTR through to children.\n    ELTSIZE is 1 for normal single byte character strings, and 2 or\n    4 for wide characer strings.  ELTSIZE is by default 1.  */\n \n static bool\n get_range_strlen (tree arg, tree length[2], bitmap *visited, int type,\n-\t\t  int fuzzy, bool *flexp, unsigned eltsize = 1)\n+\t\t  int fuzzy, bool *flexp, unsigned eltsize, tree *nonstr)\n {\n   tree var, val = NULL_TREE;\n   gimple *def_stmt;\n@@ -1307,7 +1308,8 @@ get_range_strlen (tree arg, tree length[2], bitmap *visited, int type,\n \t      if (TREE_CODE (aop0) == INDIRECT_REF\n \t\t  && TREE_CODE (TREE_OPERAND (aop0, 0)) == SSA_NAME)\n \t\treturn get_range_strlen (TREE_OPERAND (aop0, 0), length,\n-\t\t\t\t\t visited, type, fuzzy, flexp, eltsize);\n+\t\t\t\t\t visited, type, fuzzy, flexp,\n+\t\t\t\t\t eltsize, nonstr);\n \t    }\n \t  else if (TREE_CODE (TREE_OPERAND (op, 0)) == COMPONENT_REF && fuzzy)\n \t    {\n@@ -1335,13 +1337,14 @@ get_range_strlen (tree arg, tree length[2], bitmap *visited, int type,\n \t    return false;\n \t}\n       else\n-\tval = c_strlen (arg, 1, NULL, eltsize);\n+\tval = c_strlen (arg, 1, nonstr, eltsize);\n \n       if (!val && fuzzy)\n \t{\n \t  if (TREE_CODE (arg) == ADDR_EXPR)\n \t    return get_range_strlen (TREE_OPERAND (arg, 0), length,\n-\t\t\t\t     visited, type, fuzzy, flexp, eltsize);\n+\t\t\t\t     visited, type, fuzzy, flexp,\n+\t\t\t\t     eltsize, nonstr);\n \n \t  if (TREE_CODE (arg) == ARRAY_REF)\n \t    {\n@@ -1484,7 +1487,7 @@ get_range_strlen (tree arg, tree length[2], bitmap *visited, int type,\n           {\n             tree rhs = gimple_assign_rhs1 (def_stmt);\n \t    return get_range_strlen (rhs, length, visited, type, fuzzy, flexp,\n-\t\t\t\t     eltsize);\n+\t\t\t\t     eltsize, nonstr);\n           }\n \telse if (gimple_assign_rhs_code (def_stmt) == COND_EXPR)\n \t  {\n@@ -1493,7 +1496,7 @@ get_range_strlen (tree arg, tree length[2], bitmap *visited, int type,\n \n \t    for (unsigned int i = 0; i < 2; i++)\n \t      if (!get_range_strlen (ops[i], length, visited, type, fuzzy,\n-\t\t\t\t     flexp, eltsize))\n+\t\t\t\t     flexp, eltsize, nonstr))\n \t\t{\n \t\t  if (fuzzy == 2)\n \t\t    *maxlen = build_all_ones_cst (size_type_node);\n@@ -1521,7 +1524,7 @@ get_range_strlen (tree arg, tree length[2], bitmap *visited, int type,\n               continue;\n \n \t    if (!get_range_strlen (arg, length, visited, type, fuzzy, flexp,\n-\t\t\t\t   eltsize))\n+\t\t\t\t   eltsize, nonstr))\n \t      {\n \t\tif (fuzzy == 2)\n \t\t  *maxlen = build_all_ones_cst (size_type_node);\n@@ -1554,21 +1557,30 @@ get_range_strlen (tree arg, tree length[2], bitmap *visited, int type,\n    if we can determine string length minimum and maximum; it will use\n    the minimum from the ones where it can be determined.\n    STRICT false should be only used for warning code.\n+   When non-null, clear *NONSTR if ARG refers to a constant array\n+   that is known not be nul-terminated.  Otherwise set it to\n+   the declaration of the constant non-terminated array.\n \n    ELTSIZE is 1 for normal single byte character strings, and 2 or\n    4 for wide characer strings.  ELTSIZE is by default 1.  */\n \n bool\n-get_range_strlen (tree arg, tree minmaxlen[2], unsigned eltsize, bool strict)\n+get_range_strlen (tree arg, tree minmaxlen[2], unsigned eltsize,\n+\t\t  bool strict, tree *nonstr /* = NULL */)\n {\n   bitmap visited = NULL;\n \n   minmaxlen[0] = NULL_TREE;\n   minmaxlen[1] = NULL_TREE;\n \n+  tree nonstrbuf;\n+  if (!nonstr)\n+    nonstr = &nonstrbuf;\n+  *nonstr = NULL_TREE;\n+\n   bool flexarray = false;\n   if (!get_range_strlen (arg, minmaxlen, &visited, 1, strict ? 1 : 2,\n-\t\t\t &flexarray, eltsize))\n+\t\t\t &flexarray, eltsize, nonstr))\n     {\n       minmaxlen[0] = NULL_TREE;\n       minmaxlen[1] = NULL_TREE;\n@@ -1580,19 +1592,39 @@ get_range_strlen (tree arg, tree minmaxlen[2], unsigned eltsize, bool strict)\n   return flexarray;\n }\n \n+/* Return the maximum string length for ARG, counting by TYPE\n+   (1, 2 or 4 for normal or wide chars).  NONSTR indicates\n+   if the caller is prepared to handle unterminated strings.\n+\n+   If an unterminated string is discovered and our caller handles\n+   unterminated strings, then bubble up the offending DECL and\n+   return the maximum size.  Otherwise return NULL.  */\n+\n tree\n-get_maxval_strlen (tree arg, int type)\n+get_maxval_strlen (tree arg, int type, tree *nonstr /* = NULL */)\n {\n   bitmap visited = NULL;\n   tree len[2] = { NULL_TREE, NULL_TREE };\n \n   bool dummy;\n-  if (!get_range_strlen (arg, len, &visited, type, 0, &dummy))\n+  /* Set to non-null if ARG refers to an untermianted array.  */\n+  tree mynonstr = NULL_TREE;\n+  if (!get_range_strlen (arg, len, &visited, type, 0, &dummy, 1, &mynonstr))\n     len[1] = NULL_TREE;\n   if (visited)\n     BITMAP_FREE (visited);\n \n-  return len[1];\n+  if (nonstr)\n+    {\n+      /* For callers prepared to handle unterminated arrays set\n+\t *NONSTR to point to the declaration of the array and return\n+\t the maximum length/size. */\n+      *nonstr = mynonstr;\n+      return len[1];\n+    }\n+\n+  /* Fail if the constant array isn't nul-terminated.  */\n+  return mynonstr ? NULL_TREE : len[1];\n }\n \n \n@@ -1635,7 +1667,19 @@ gimple_fold_builtin_strcpy (gimple_stmt_iterator *gsi,\n   if (!fn)\n     return false;\n \n-  tree len = get_maxval_strlen (src, 0);\n+  /* Set to non-null if ARG refers to an unterminated array.  */\n+  tree nonstr = NULL;\n+  tree len = get_maxval_strlen (src, 0, &nonstr);\n+\n+  if (nonstr)\n+    {\n+      /* Avoid folding calls with unterminated arrays.  */\n+      if (!gimple_no_warning_p (stmt))\n+\twarn_string_no_nul (loc, \"strcpy\", src, nonstr);\n+      gimple_set_no_warning (stmt, true);\n+      return false;\n+    }\n+\n   if (!len)\n     return false;\n \n@@ -3506,12 +3550,15 @@ static bool\n gimple_fold_builtin_strlen (gimple_stmt_iterator *gsi)\n {\n   gimple *stmt = gsi_stmt (*gsi);\n+  tree arg = gimple_call_arg (stmt, 0);\n \n   wide_int minlen;\n   wide_int maxlen;\n \n+  /* Set to non-null if ARG refers to an unterminated array.  */\n+  tree nonstr;\n   tree lenrange[2];\n-  if (!get_range_strlen (gimple_call_arg (stmt, 0), lenrange, 1, true)\n+  if (!get_range_strlen (arg, lenrange, 1, true, &nonstr)\n       && lenrange[0] && TREE_CODE (lenrange[0]) == INTEGER_CST\n       && lenrange[1] && TREE_CODE (lenrange[1]) == INTEGER_CST)\n     {"}, {"sha": "26e27272249ccf6e1d84d110de070bd5f14a3540", "filename": "gcc/gimple-fold.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e08341bb0e026ef019a3b201ea26ecdc4a9233ea/gcc%2Fgimple-fold.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e08341bb0e026ef019a3b201ea26ecdc4a9233ea/gcc%2Fgimple-fold.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.h?ref=e08341bb0e026ef019a3b201ea26ecdc4a9233ea", "patch": "@@ -25,8 +25,9 @@ along with GCC; see the file COPYING3.  If not see\n extern tree create_tmp_reg_or_ssa_name (tree, gimple *stmt = NULL);\n extern tree canonicalize_constructor_val (tree, tree);\n extern tree get_symbol_constant_value (tree);\n-extern bool get_range_strlen (tree, tree[2], unsigned = 1, bool = false);\n-extern tree get_maxval_strlen (tree, int);\n+extern bool get_range_strlen (tree, tree[2], unsigned = 1,\n+\t\t\t      bool = false, tree * = NULL);\n+extern tree get_maxval_strlen (tree, int, tree * = NULL);\n extern void gimplify_and_update_call_from_tree (gimple_stmt_iterator *, tree);\n extern bool fold_stmt (gimple_stmt_iterator *);\n extern bool fold_stmt (gimple_stmt_iterator *, tree (*) (tree));"}, {"sha": "df6c9046c29cfab54018db3ec2166331cf12dabd", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e08341bb0e026ef019a3b201ea26ecdc4a9233ea/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e08341bb0e026ef019a3b201ea26ecdc4a9233ea/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e08341bb0e026ef019a3b201ea26ecdc4a9233ea", "patch": "@@ -1,3 +1,8 @@\n+2018-09-14  Martin Sebor  <msebor@redhat.com>\n+\t    Jeff Law  <law@redhat.com>\n+\n+\t* gcc.dg/warn-strcpy-no-nul.c: New test.\n+\n 2018-09-14  Martin Sebor  <msebor@redhat.com>\n \n \tc++/61941"}, {"sha": "b5ed21dc19550e622070eac8977cbdaf2eae2f57", "filename": "gcc/testsuite/gcc.dg/warn-strcpy-no-nul.c", "status": "added", "additions": 324, "deletions": 0, "changes": 324, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e08341bb0e026ef019a3b201ea26ecdc4a9233ea/gcc%2Ftestsuite%2Fgcc.dg%2Fwarn-strcpy-no-nul.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e08341bb0e026ef019a3b201ea26ecdc4a9233ea/gcc%2Ftestsuite%2Fgcc.dg%2Fwarn-strcpy-no-nul.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fwarn-strcpy-no-nul.c?ref=e08341bb0e026ef019a3b201ea26ecdc4a9233ea", "patch": "@@ -0,0 +1,324 @@\n+/* PR tree-optimization/86552 - missing warning for reading past the end\n+   of non-string arrays\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -Wno-array-bounds -ftrack-macro-expansion=0\" } */\n+\n+extern char* strcpy (char*, const char*);\n+\n+const char a[5] = \"12345\";   /* { dg-message \"declared here\" } */\n+\n+int v0 = 0;\n+int v1 = 1;\n+int v2 = 1;\n+int v3 = 1;\n+\n+void sink (char*, ...);\n+\n+#define T(str) sink (strcpy (d, str))\n+\n+void test_one_dim_array (char *d)\n+{\n+  T (a);                /* { dg-warning \"argument missing terminating nul\" } */\n+  T (&a[0]);            /* { dg-warning \"nul\" } */\n+  T (&a[0] + 1);        /* { dg-warning \"nul\" } */\n+  T (&a[1]);            /* { dg-warning \"nul\" } */\n+\n+  int i0 = 0;\n+  int i1 = i0 + 1;\n+\n+  T (&a[i0]);           /* { dg-warning \"nul\" } */\n+  T (&a[i0] + 1);       /* { dg-warning \"nul\" } */\n+  T (&a[i1]);           /* { dg-warning \"nul\" } */\n+\n+  T (&a[v0]);           /* { dg-warning \"nul\" } */\n+  T (&a[v0] + 1);       /* { dg-warning \"nul\" } */\n+  T (&a[v0] + v1);      /* { dg-warning \"nul\" } */\n+}\n+\n+const char b[][5] = { /* { dg-message \"declared here\" } */\n+  \"12\", \"123\", \"1234\", \"54321\"\n+};\n+\n+void test_two_dim_array (char *d)\n+{\n+  int i0 = 0;\n+  int i1 = i0 + 1;\n+  int i2 = i1 + 1;\n+  int i3 = i2 + 1;\n+\n+  T (b[0]);\n+  T (b[1]);\n+  T (b[2]);\n+  T (b[3]);             /* { dg-warning \"nul\" } */\n+  T (b[i0]);\n+  T (b[i1]);\n+  T (b[i2]);\n+  T (b[i3]);            /* { dg-warning \"nul\" } */\n+  T (b[v0]);\n+  T (b[v3]);\n+\n+  T (&b[2][1]);\n+  T (&b[2][1] + 1);\n+  T (&b[2][v0]);\n+  T (&b[2][1] + v0);\n+\n+  T (&b[i2][i1]);\n+  T (&b[i2][i1] + i1);\n+  T (&b[i2][v0]);\n+  T (&b[i2][i1] + v0);\n+\n+  T (&b[3][1]);         /* { dg-warning \"nul\" } */\n+  T (&b[3][1] + 1);     /* { dg-warning \"nul\" } */\n+  T (&b[3][v0]);        /* { dg-warning \"nul\" } */\n+  T (&b[3][1] + v0);    /* { dg-warning \"nul\" } */\n+  T (&b[3][v0] + v1);   /* { dg-warning \"nul\" \"bug ???\" { xfail *-*-* } } */\n+\n+  T (&b[i3][i1]);       /* { dg-warning \"nul\" } */\n+  T (&b[i3][i1] + i1);  /* { dg-warning \"nul\" } */\n+  T (&b[i3][v0]);       /* { dg-warning \"nul\" } */\n+  T (&b[i3][i1] + v0);  /* { dg-warning \"nul\" } */\n+  T (&b[i3][v0] + v1);  /* { dg-warning \"nul\" \"bug ???\" { xfail *-*-* } } */\n+\n+  T (v0 ? \"\" : b[0]);\n+  T (v0 ? \"\" : b[1]);\n+  T (v0 ? \"\" : b[2]);\n+  T (v0 ? \"\" : b[3]);               /* { dg-warning \"nul\" } */\n+  T (v0 ? b[0] : \"\");\n+  T (v0 ? b[1] : \"\");\n+  T (v0 ? b[2] : \"\");\n+  T (v0 ? b[3] : \"\");               /* { dg-warning \"nul\" } */\n+\n+  T (v0 ? \"1234\" : b[3]);           /* { dg-warning \"nul\" } */\n+  T (v0 ? b[3] : \"1234\");           /* { dg-warning \"nul\" } */\n+\n+  T (v0 ? a : b[3]);                /* { dg-warning \"nul\" } */\n+  T (v0 ? b[0] : b[2]);\n+  T (v0 ? b[2] : b[3]);             /* { dg-warning \"nul\" } */\n+  T (v0 ? b[3] : b[2]);             /* { dg-warning \"nul\" } */\n+\n+  T (v0 ? b[0] : &b[3][0] + 1);     /* { dg-warning \"nul\" } */\n+  T (v0 ? b[1] : &b[3][1] + v0);    /* { dg-warning \"nul\" } */\n+\n+  /* It's possible to detect the missing nul in the following\n+     expression but GCC doesn't do it yet.  */\n+  T (v0 ? &b[3][1] + v0 : b[2]);    /* { dg-warning \"nul\" \"bug ???\" { xfail *-*-* } } */\n+  T (v0 ? &b[3][v0] : &b[3][v1]);   /* { dg-warning \"nul\" } */\n+}\n+\n+struct A { char a[5], b[5]; };\n+\n+const struct A s = { \"1234\", \"12345\" };\n+\n+void test_struct_member (char *d)\n+{\n+  int i0 = 0;\n+  int i1 = i0 + 1;\n+\n+  T (s.a);\n+  T (&s.a[0]);\n+  T (&s.a[0] + 1);\n+  T (&s.a[0] + i0);\n+  T (&s.a[1]);\n+  T (&s.a[1] + 1);\n+  T (&s.a[1] + i0);\n+\n+  T (&s.a[i0]);\n+  T (&s.a[i0] + 1);\n+  T (&s.a[i0] + v0);\n+  T (&s.a[i1]);\n+  T (&s.a[i1] + 1);\n+  T (&s.a[i1] + v0);\n+\n+  T (s.a);\n+  T (&s.a[0]);\n+  T (&s.a[0] + 1);\n+  T (&s.a[0] + v0);\n+  T (&s.a[1]);\n+  T (&s.a[1] + 1);\n+  T (&s.a[1] + v0);\n+\n+  T (&s.a[i0]);\n+  T (&s.a[i0] + 1);\n+  T (&s.a[i0] + v0);\n+  T (&s.a[i1]);\n+  T (&s.a[i1] + 1);\n+  T (&s.a[i1] + v0);\n+\n+  T (&s.a[v0]);\n+  T (&s.a[v0] + 1);\n+  T (&s.a[v0] + v0);\n+  T (&s.a[v1]);\n+  T (&s.a[v1] + 1);\n+  T (&s.a[v1] + v0);\n+\n+  T (s.b);              /* { dg-warning \"nul\" } */\n+  T (&s.b[0]);          /* { dg-warning \"nul\" } */\n+  T (&s.b[0] + 1);      /* { dg-warning \"nul\" } */\n+  T (&s.b[0] + i0);     /* { dg-warning \"nul\" } */\n+  T (&s.b[1]);          /* { dg-warning \"nul\" } */\n+  T (&s.b[1] + 1);      /* { dg-warning \"nul\" } */\n+  T (&s.b[1] + i0);     /* { dg-warning \"nul\" } */\n+\n+  T (s.b);              /* { dg-warning \"nul\" } */\n+  T (&s.b[0]);          /* { dg-warning \"nul\" } */\n+  T (&s.b[0] + 1);      /* { dg-warning \"nul\" } */\n+  T (&s.b[0] + v0);     /* { dg-warning \"nul\" } */\n+  T (&s.b[1]);          /* { dg-warning \"nul\" } */\n+  T (&s.b[1] + 1);      /* { dg-warning \"nul\" } */\n+  T (&s.b[1] + v0);     /* { dg-warning \"nul\" } */\n+\n+  T (s.b);              /* { dg-warning \"nul\" } */\n+  T (&s.b[v0]);         /* { dg-warning \"nul\" \"bug ???\" { xfail *-*-* } } */\n+  T (&s.b[v0] + 1);     /* { dg-warning \"nul\" \"bug ???\" { xfail *-*-* } } */\n+  T (&s.b[v0] + v0);    /* { dg-warning \"nul\" \"bug ???\" { xfail *-*-* } } */\n+  T (&s.b[v1]);         /* { dg-warning \"nul\" \"bug ???\" { xfail *-*-* } } */\n+  T (&s.b[v1] + 1);     /* { dg-warning \"nul\" \"bug ???\" { xfail *-*-* } } */\n+  T (&s.b[v1] + v0);    /* { dg-warning \"nul\" \"bug ???\" { xfail *-*-* } } */\n+}\n+\n+struct B { struct A a[2]; };\n+\n+const struct B ba[] = {\n+  { { { \"123\", \"12345\" }, { \"12345\", \"123\" } } },\n+  { { { \"12345\", \"123\" }, { \"123\", \"12345\" } } },\n+  { { { \"1\", \"12\" },      { \"123\", \"1234\" } } },\n+  { { { \"123\", \"1234\" },  { \"12345\", \"12\" } } }\n+};\n+\n+void test_array_of_structs (char *d)\n+{\n+  T (ba[0].a[0].a);\n+  T (&ba[0].a[0].a[0]);\n+  T (&ba[0].a[0].a[0] + 1);\n+  T (&ba[0].a[0].a[0] + v0);\n+  T (&ba[0].a[0].a[1]);\n+  T (&ba[0].a[0].a[1] + 1);\n+  T (&ba[0].a[0].a[1] + v0);\n+\n+  T (ba[0].a[0].b);           /* { dg-warning \"nul\" } */\n+  T (&ba[0].a[0].b[0]);       /* { dg-warning \"nul\" } */\n+  T (&ba[0].a[0].b[0] + 1);   /* { dg-warning \"nul\" } */\n+  T (&ba[0].a[0].b[0] + v0);  /* { dg-warning \"nul\" } */\n+  T (&ba[0].a[0].b[1]);       /* { dg-warning \"nul\" } */\n+  T (&ba[0].a[0].b[1] + 1);   /* { dg-warning \"nul\" } */\n+  T (&ba[0].a[0].b[1] + v0);  /* { dg-warning \"nul\" } */\n+\n+  T (ba[0].a[1].a);           /* { dg-warning \"nul\" } */\n+  T (&ba[0].a[1].a[0]);       /* { dg-warning \"nul\" } */\n+  T (&ba[0].a[1].a[0] + 1);   /* { dg-warning \"nul\" } */\n+  T (&ba[0].a[1].a[0] + v0);  /* { dg-warning \"nul\" } */\n+  T (&ba[0].a[1].a[1]);       /* { dg-warning \"nul\" } */\n+  T (&ba[0].a[1].a[1] + 1);   /* { dg-warning \"nul\" } */\n+  T (&ba[0].a[1].a[1] + v0);  /* { dg-warning \"nul\" } */\n+\n+  T (ba[0].a[1].b);\n+  T (&ba[0].a[1].b[0]);\n+  T (&ba[0].a[1].b[0] + 1);\n+  T (&ba[0].a[1].b[0] + v0);\n+  T (&ba[0].a[1].b[1]);\n+  T (&ba[0].a[1].b[1] + 1);\n+  T (&ba[0].a[1].b[1] + v0);\n+\n+\n+  T (ba[1].a[0].a);           /* { dg-warning \"nul\" } */\n+  T (&ba[1].a[0].a[0]);       /* { dg-warning \"nul\" } */\n+  T (&ba[1].a[0].a[0] + 1);   /* { dg-warning \"nul\" } */\n+  T (&ba[1].a[0].a[0] + v0);  /* { dg-warning \"nul\" } */\n+  T (&ba[1].a[0].a[1]);       /* { dg-warning \"nul\" } */\n+  T (&ba[1].a[0].a[1] + 1);   /* { dg-warning \"nul\" } */\n+  T (&ba[1].a[0].a[1] + v0);  /* { dg-warning \"nul\" } */\n+\n+  T (ba[1].a[0].b);\n+  T (&ba[1].a[0].b[0]);\n+  T (&ba[1].a[0].b[0] + 1);\n+  T (&ba[1].a[0].b[0] + v0);\n+  T (&ba[1].a[0].b[1]);\n+  T (&ba[1].a[0].b[1] + 1);\n+  T (&ba[1].a[0].b[1] + v0);\n+\n+  T (ba[1].a[1].a);\n+  T (&ba[1].a[1].a[0]);\n+  T (&ba[1].a[1].a[0] + 1);\n+  T (&ba[1].a[1].a[0] + v0);\n+  T (&ba[1].a[1].a[1]);\n+  T (&ba[1].a[1].a[1] + 1);\n+  T (&ba[1].a[1].a[1] + v0);\n+\n+  T (ba[1].a[1].b);           /* { dg-warning \"nul\" } */\n+  T (&ba[1].a[1].b[0]);       /* { dg-warning \"nul\" } */\n+  T (&ba[1].a[1].b[0] + 1);   /* { dg-warning \"nul\" } */\n+  T (&ba[1].a[1].b[0] + v0);  /* { dg-warning \"nul\" } */\n+  T (&ba[1].a[1].b[1]);       /* { dg-warning \"nul\" } */\n+  T (&ba[1].a[1].b[1] + 1);   /* { dg-warning \"nul\" } */\n+  T (&ba[1].a[1].b[1] + v0);  /* { dg-warning \"nul\" } */\n+\n+\n+  T (ba[2].a[0].a);\n+  T (&ba[2].a[0].a[0]);\n+  T (&ba[2].a[0].a[0] + 1);\n+  T (&ba[2].a[0].a[0] + v0);\n+  T (&ba[2].a[0].a[1]);\n+  T (&ba[2].a[0].a[1] + 1);\n+  T (&ba[2].a[0].a[1] + v0);\n+\n+  T (ba[2].a[0].b);\n+  T (&ba[2].a[0].b[0]);\n+  T (&ba[2].a[0].b[0] + 1);\n+  T (&ba[2].a[0].b[0] + v0);\n+  T (&ba[2].a[0].b[1]);\n+  T (&ba[2].a[0].b[1] + 1);\n+  T (&ba[2].a[0].b[1] + v0);\n+\n+  T (ba[2].a[1].a);\n+  T (&ba[2].a[1].a[0]);\n+  T (&ba[2].a[1].a[0] + 1);\n+  T (&ba[2].a[1].a[0] + v0);\n+  T (&ba[2].a[1].a[1]);\n+  T (&ba[2].a[1].a[1] + 1);\n+  T (&ba[2].a[1].a[1] + v0);\n+\n+\n+  T (ba[3].a[0].a);\n+  T (&ba[3].a[0].a[0]);\n+  T (&ba[3].a[0].a[0] + 1);\n+  T (&ba[3].a[0].a[0] + v0);\n+  T (&ba[3].a[0].a[1]);\n+  T (&ba[3].a[0].a[1] + 1);\n+  T (&ba[3].a[0].a[1] + v0);\n+\n+  T (ba[3].a[0].b);\n+  T (&ba[3].a[0].b[0]);\n+  T (&ba[3].a[0].b[0] + 1);\n+  T (&ba[3].a[0].b[0] + v0);\n+  T (&ba[3].a[0].b[1]);\n+  T (&ba[3].a[0].b[1] + 1);\n+  T (&ba[3].a[0].b[1] + v0);\n+\n+  T (ba[3].a[1].a);           /* { dg-warning \"nul\" } */\n+  T (&ba[3].a[1].a[0]);\t      /* { dg-warning \"nul\" } */\n+  T (&ba[3].a[1].a[0] + 1);   /* { dg-warning \"nul\" } */\n+  T (&ba[3].a[1].a[0] + v0);  /* { dg-warning \"nul\" } */\n+  T (&ba[3].a[1].a[1]);\t      /* { dg-warning \"nul\" } */\n+  T (&ba[3].a[1].a[1] + 1);   /* { dg-warning \"nul\" } */\n+  T (&ba[3].a[1].a[1] + v0);  /* { dg-warning \"nul\" } */\n+\n+  T (ba[3].a[1].b);\n+  T (&ba[3].a[1].b[0]);\t\n+  T (&ba[3].a[1].b[0] + 1);\n+  T (&ba[3].a[1].b[0] + v0);\n+  T (&ba[3].a[1].b[1]);\t\n+  T (&ba[3].a[1].b[1] + 1);\n+  T (&ba[3].a[1].b[1] + v0);\n+\n+\n+  T (v0 ? ba[0].a[0].a : ba[0].a[0].b);           /* { dg-warning \"nul\" \"bug ???\" } */\n+  T (v0 ? ba[0].a[0].a : ba[0].a[0].b);           /* { dg-warning \"nul\" \"bug ???\" } */\n+\n+  T (v0 ? &ba[0].a[0].a[0] : &ba[3].a[1].a[0]);   /* { dg-warning \"nul\" \"bug ???\" } */\n+  T (v0 ? &ba[3].a[1].a[1] :  ba[0].a[0].a);      /* { dg-warning \"nul\" \"bug ???\" } */\n+\n+  T (v0 ? ba[0].a[0].a : ba[0].a[1].b);\n+  T (v0 ? ba[0].a[1].b : ba[0].a[0].a);\n+}\n+\n+/* { dg-prune-output \" reading \\[1-9\\]\\[0-9\\]? bytes from a region \" } */"}]}