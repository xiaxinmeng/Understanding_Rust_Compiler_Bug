{"sha": "f8d0aee5c105df1c5d073a9a91fb467cd603f600", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjhkMGFlZTVjMTA1ZGYxYzVkMDczYTlhOTFmYjQ2N2NkNjAzZjYwMA==", "commit": {"author": {"name": "Tobias Schl\u00fcter", "email": "tobias.schlueter@physik.uni-muenchen.de", "date": "2004-08-22T20:01:22Z"}, "committer": {"name": "Tobias Schl\u00fcter", "email": "tobi@gcc.gnu.org", "date": "2004-08-22T20:01:22Z"}, "message": "* trans-const.c, trans-decl.c, trans-expr.c: Spelling fixes.\n\nFrom-SVN: r86385", "tree": {"sha": "d8756e9d59b2bfdd8c7bea29dc44580fc4330896", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d8756e9d59b2bfdd8c7bea29dc44580fc4330896"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f8d0aee5c105df1c5d073a9a91fb467cd603f600", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8d0aee5c105df1c5d073a9a91fb467cd603f600", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8d0aee5c105df1c5d073a9a91fb467cd603f600", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8d0aee5c105df1c5d073a9a91fb467cd603f600/comments", "author": {"login": "TobiSchluter", "id": 11887541, "node_id": "MDQ6VXNlcjExODg3NTQx", "avatar_url": "https://avatars.githubusercontent.com/u/11887541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TobiSchluter", "html_url": "https://github.com/TobiSchluter", "followers_url": "https://api.github.com/users/TobiSchluter/followers", "following_url": "https://api.github.com/users/TobiSchluter/following{/other_user}", "gists_url": "https://api.github.com/users/TobiSchluter/gists{/gist_id}", "starred_url": "https://api.github.com/users/TobiSchluter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TobiSchluter/subscriptions", "organizations_url": "https://api.github.com/users/TobiSchluter/orgs", "repos_url": "https://api.github.com/users/TobiSchluter/repos", "events_url": "https://api.github.com/users/TobiSchluter/events{/privacy}", "received_events_url": "https://api.github.com/users/TobiSchluter/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TobiSchluter", "id": 11887541, "node_id": "MDQ6VXNlcjExODg3NTQx", "avatar_url": "https://avatars.githubusercontent.com/u/11887541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TobiSchluter", "html_url": "https://github.com/TobiSchluter", "followers_url": "https://api.github.com/users/TobiSchluter/followers", "following_url": "https://api.github.com/users/TobiSchluter/following{/other_user}", "gists_url": "https://api.github.com/users/TobiSchluter/gists{/gist_id}", "starred_url": "https://api.github.com/users/TobiSchluter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TobiSchluter/subscriptions", "organizations_url": "https://api.github.com/users/TobiSchluter/orgs", "repos_url": "https://api.github.com/users/TobiSchluter/repos", "events_url": "https://api.github.com/users/TobiSchluter/events{/privacy}", "received_events_url": "https://api.github.com/users/TobiSchluter/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "44e91562edc08fc064375d7e39b6ab704e89da1b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44e91562edc08fc064375d7e39b6ab704e89da1b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44e91562edc08fc064375d7e39b6ab704e89da1b"}], "stats": {"total": 131, "additions": 73, "deletions": 58}, "files": [{"sha": "623a8d0916b2d1a01d3f58256c4cb2c4a21156e5", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d0aee5c105df1c5d073a9a91fb467cd603f600/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d0aee5c105df1c5d073a9a91fb467cd603f600/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=f8d0aee5c105df1c5d073a9a91fb467cd603f600", "patch": "@@ -1,3 +1,7 @@\n+2004-08-22  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n+\n+\t* trans-const.c, trans-decl.c, trans-expr.c: Spelling fixes.\n+\n 2004-08-22  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n \n \t* check.c (gfc_check_reduction): Rename to ..."}, {"sha": "9f03f2ed2e3f3602a20212fd40ae46f416ecb88c", "filename": "gcc/fortran/trans-const.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d0aee5c105df1c5d073a9a91fb467cd603f600/gcc%2Ffortran%2Ftrans-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d0aee5c105df1c5d073a9a91fb467cd603f600/gcc%2Ffortran%2Ftrans-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-const.c?ref=f8d0aee5c105df1c5d073a9a91fb467cd603f600", "patch": "@@ -46,6 +46,7 @@ tree gfc_strconst_current_filename;\n tree gfc_rank_cst[GFC_MAX_DIMENSIONS + 1];\n \n /* Build a constant with given type from an int_cst.  */\n+\n tree\n gfc_build_const (tree type, tree intval)\n {\n@@ -175,7 +176,7 @@ gfc_conv_mpz_to_tree (mpz_t i, int kind)\n   char *q;\n   int n;\n \n-  /* TODO: could be wrong if sizeof(HOST_WIDE_INT) |= SIZEOF (int).  */\n+  /* TODO: could be wrong if sizeof(HOST_WIDE_INT) != SIZEOF (int).  */\n   if (mpz_fits_slong_p (i))\n     {\n       val = mpz_get_si (i);\n@@ -229,6 +230,7 @@ gfc_conv_mpz_to_tree (mpz_t i, int kind)\n \n /* Converts a real constant into backend form.  Uses an intermediate string\n    representation.  */\n+\n tree\n gfc_conv_mpfr_to_tree (mpfr_t f, int kind)\n {\n@@ -343,7 +345,7 @@ gfc_conv_constant_to_tree (gfc_expr * expr)\n }\n \n \n-/* Like gfc_conv_contrant_to_tree, but for a simplified expression.\n+/* Like gfc_conv_constant_to_tree, but for a simplified expression.\n    We can handle character literal constants here as well.  */\n \n void\n@@ -366,7 +368,7 @@ gfc_conv_constant (gfc_se * se, gfc_expr * expr)\n   /* Translate the constant and put it in the simplifier structure.  */\n   se->expr = gfc_conv_constant_to_tree (expr);\n \n-  /* If this is a CHARACTER string, set it's length in the simplifier\n+  /* If this is a CHARACTER string, set its length in the simplifier\n      structure, too.  */\n   if (expr->ts.type == BT_CHARACTER)\n     se->string_length = TYPE_MAX_VALUE (TYPE_DOMAIN (TREE_TYPE (se->expr)));"}, {"sha": "344966358fa1a8f0bb0f75de22207dfbbcba5af6", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d0aee5c105df1c5d073a9a91fb467cd603f600/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d0aee5c105df1c5d073a9a91fb467cd603f600/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=f8d0aee5c105df1c5d073a9a91fb467cd603f600", "patch": "@@ -238,7 +238,7 @@ gfc_get_label_decl (gfc_st_label * lp)\n       label_decl = gfc_build_label_decl (get_identifier (label_name));\n \n       /* Tell the debugger where the label came from.  */\n-      if (lp->value <= MAX_LABEL_VALUE)\t/* An internal label */\n+      if (lp->value <= MAX_LABEL_VALUE)\t/* An internal label.  */\n \t{\n \t  DECL_SOURCE_LINE (label_decl) = lp->where.lb->linenum;\n \t  DECL_SOURCE_FILE (label_decl) = lp->where.lb->file->filename;\n@@ -258,6 +258,7 @@ gfc_get_label_decl (gfc_st_label * lp)\n static tree\n gfc_sym_identifier (gfc_symbol * sym)\n {\n+\n   return (get_identifier (sym->name));\n }\n \n@@ -375,7 +376,7 @@ gfc_finish_decl (tree decl, tree init)\n static void\n gfc_finish_var_decl (tree decl, gfc_symbol * sym)\n {\n-  /* TREE_ADDRESSABLE means the address of this variable is acualy needed.\n+  /* TREE_ADDRESSABLE means the address of this variable is actually needed.\n      This is the equivalent of the TARGET variables.\n      We also need to set this if the variable is passed by reference in a\n      CALL statement.  */\n@@ -427,6 +428,7 @@ gfc_finish_var_decl (tree decl, gfc_symbol * sym)\n void\n gfc_allocate_lang_decl (tree decl)\n {\n+\n   DECL_LANG_SPECIFIC (decl) = (struct lang_decl *)\n     ggc_alloc_cleared (sizeof (struct lang_decl));\n }\n@@ -555,7 +557,7 @@ gfc_build_dummy_array_decl (gfc_symbol * sym, tree dummy)\n   assert (TREE_CODE (dummy) == PARM_DECL\n \t  && POINTER_TYPE_P (type));\n \n-  /* Do we know the element size. */\n+  /* Do we know the element size?  */\n   known_size = sym->ts.type != BT_CHARACTER\n \t  || INTEGER_CST_P (sym->ts.cl->backend_decl);\n   \n@@ -758,7 +760,7 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n   /* Create the decl for the variable.  */\n   decl = build_decl (VAR_DECL, gfc_sym_identifier (sym), gfc_sym_type (sym));\n \n-  /* Symbols from modules have its assembler name should be mangled.\n+  /* Symbols from modules should have their assembler names mangled.\n      This is done here rather than in gfc_finish_var_decl because it\n      is different for string length variables.  */\n   if (sym->module[0])\n@@ -931,13 +933,13 @@ gfc_get_extern_function_decl (gfc_symbol * sym)\n     }\n   else\n     {\n-      /* Global declaration, eg. intrinsic subroutine.  */\n+      /* Global declaration, e.g. intrinsic subroutine.  */\n       DECL_CONTEXT (fndecl) = NULL_TREE;\n     }\n \n   DECL_EXTERNAL (fndecl) = 1;\n \n-  /* This specifies if a function is globaly addressable, ie. it is\n+  /* This specifies if a function is globally addressable, i.e. it is\n      the opposite of declaring static in C.  */\n   TREE_PUBLIC (fndecl) = 1;\n \n@@ -991,7 +993,7 @@ build_function_decl (gfc_symbol * sym)\n     SET_DECL_ASSEMBLER_NAME (fndecl, gfc_sym_mangled_function_id (sym));\n \n   /* Figure out the return type of the declared function, and build a\n-     RESULT_DECL for it.  If this is subroutine with alternate\n+     RESULT_DECL for it.  If this is a subroutine with alternate\n      returns, build a RESULT_DECL for it.  */\n   attr = sym->attr;\n \n@@ -1035,7 +1037,7 @@ build_function_decl (gfc_symbol * sym)\n   DECL_RESULT (fndecl) = result_decl;\n \n   /* Don't call layout_decl for a RESULT_DECL.\n-     layout_decl (result_decl, 0); */\n+     layout_decl (result_decl, 0);  */\n \n   /* If the return type is a pointer, avoid alias issues by setting\n      DECL_IS_MALLOC to nonzero. This means that the function should be\n@@ -1048,7 +1050,7 @@ build_function_decl (gfc_symbol * sym)\n   DECL_CONTEXT (fndecl) = current_function_decl;\n   DECL_EXTERNAL (fndecl) = 0;\n \n-  /* This specifies if a function is globaly visible, ie. it is\n+  /* This specifies if a function is globaly visible, i.e. it is\n      the opposite of declaring static in C.  */\n   if (DECL_CONTEXT (fndecl) == NULL_TREE\n       && !sym->attr.entry_master)\n@@ -1057,7 +1059,7 @@ build_function_decl (gfc_symbol * sym)\n   /* TREE_STATIC means the function body is defined here.  */\n   TREE_STATIC (fndecl) = 1;\n \n-  /* Set attributes for PURE functions. A call to PURE function in the\n+  /* Set attributes for PURE functions. A call to a PURE function in the\n      Fortran 95 sense is both pure and without side effects in the C\n      sense.  */\n   if (attr.pure || attr.elemental)\n@@ -1153,7 +1155,7 @@ create_function_arglist (gfc_symbol * sym)\n \n   for (f = sym->formal; f; f = f->next)\n     {\n-      if (f->sym != NULL)\t/* ignore alternate returns. */\n+      if (f->sym != NULL)\t/* ignore alternate returns.  */\n \t{\n \t  length = NULL_TREE;\n \n@@ -1284,22 +1286,22 @@ trans_function_start (gfc_symbol * sym)\n \n   fndecl = sym->backend_decl;\n \n-  /* let GCC know the current scope is this function */\n+  /* Let GCC know the current scope is this function.  */\n   current_function_decl = fndecl;\n \n-  /* Let the world know what e're about to do.  */\n+  /* Let the world know what we're about to do.  */\n   announce_function (fndecl);\n \n   if (DECL_CONTEXT (fndecl) == NULL_TREE)\n     {\n-      /* create RTL for function declaration */\n+      /* Create RTL for function declaration.  */\n       rest_of_decl_compilation (fndecl, 1, 0);\n     }\n \n-  /* create RTL for function definition */\n+  /* Create RTL for function definition.  */\n   make_decl_rtl (fndecl);\n \n-  /* Set the line and filename.  sym->decalred_at seems to point to the\n+  /* Set the line and filename.  sym->declared_at seems to point to the\n      last statement for subroutines, but it'll do for now.  */\n   gfc_set_backend_locus (&sym->declared_at);\n \n@@ -1311,7 +1313,7 @@ trans_function_start (gfc_symbol * sym)\n      not safe to try to expand expressions involving them.  */\n   cfun->x_dont_save_pending_sizes_p = 1;\n \n-  /* function.c requires a push at the start of the function */\n+  /* function.c requires a push at the start of the function.  */\n   pushlevel (0);\n }\n \n@@ -1333,7 +1335,7 @@ build_entry_thunks (gfc_namespace * ns)\n   /* This should always be a toplevel function.  */\n   assert (current_function_decl == NULL_TREE);\n \n-  /* Remeber the master function argument decls.  */\n+  /* Remember the master function argument decls.  */\n   for (formal = ns->proc_name->formal; formal; formal = formal->next)\n     {\n     }\n@@ -1351,7 +1353,7 @@ build_entry_thunks (gfc_namespace * ns)\n \n       gfc_start_block (&body);\n \n-      /* Pass extra parater identifying this entry point.  */\n+      /* Pass extra parameter identifying this entry point.  */\n       tmp = build_int_cst (gfc_array_index_type, el->id, 0);\n       args = tree_cons (NULL_TREE, tmp, NULL_TREE);\n       string_args = NULL_TREE;\n@@ -1448,7 +1450,7 @@ gfc_create_function_decl (gfc_namespace * ns)\n   /* Create a declaration for the master function.  */\n   build_function_decl (ns->proc_name);\n \n-  /* Compile teh entry thunks.  */\n+  /* Compile the entry thunks.  */\n   if (ns->entries)\n     build_entry_thunks (ns);\n \n@@ -1873,7 +1875,7 @@ gfc_trans_auto_character_variable (gfc_symbol * sym, tree fnbody)\n \n /* Generate function entry and exit code, and add it to the function body.\n    This includes:\n-    Allocation and initialisation of array variables.\n+    Allocation and initialization of array variables.\n     Allocation of character string variables.\n     Initialization and possibly repacking of dummy arrays.  */\n \n@@ -2088,7 +2090,7 @@ generate_local_decl (gfc_symbol * sym)\n           if (warn_unused_parameter)\n             warning (\"unused parameter `%s'\", sym->name);\n         }\n-      /* warn for unused variables, but not if they're inside a common\n+      /* Warn for unused variables, but not if they're inside a common\n \t block or are use_associated.  */\n       else if (warn_unused_variable\n \t       && !(sym->attr.in_common || sym->attr.use_assoc))\n@@ -2239,7 +2241,7 @@ gfc_generate_function_code (gfc_namespace * ns)\n \twarning (\"Function return value not set\");\n       else\n \t{\n-\t  /* Set the return value to the the dummy result variable.  */\n+\t  /* Set the return value to the dummy result variable.  */\n \t  tmp = build (MODIFY_EXPR, TREE_TYPE (result),\n \t\t       DECL_RESULT (fndecl), result);\n \t  tmp = build_v (RETURN_EXPR, tmp);"}, {"sha": "127a820754f2982289fa8192918b210d25470c3b", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 39, "deletions": 32, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d0aee5c105df1c5d073a9a91fb467cd603f600/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d0aee5c105df1c5d073a9a91fb467cd603f600/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=f8d0aee5c105df1c5d073a9a91fb467cd603f600", "patch": "@@ -55,7 +55,7 @@ gfc_copy_se_loopvars (gfc_se * dest, gfc_se * src)\n }\n \n \n-/* Initialise a simple expression holder.\n+/* Initialize a simple expression holder.\n \n    Care must be taken when multiple se are created with the same parent.\n    The child se must be kept in sync.  The easiest way is to delay creation\n@@ -76,7 +76,7 @@ gfc_init_se (gfc_se * se, gfc_se * parent)\n \n \n /* Advances to the next SS in the chain.  Use this rather than setting\n-   se->ss = se->ss->next because all the parent needs to be kept in sync.\n+   se->ss = se->ss->next because all the parents needs to be kept in sync.\n    See gfc_init_se.  */\n \n void\n@@ -90,7 +90,7 @@ gfc_advance_se_ss_chain (gfc_se * se)\n   /* Walk down the parent chain.  */\n   while (p != NULL)\n     {\n-      /* Simple consistancy check.  */\n+      /* Simple consistency check.  */\n       assert (p->parent == NULL || p->parent->ss == p->ss);\n \n       p->ss = p->ss->next;\n@@ -111,7 +111,7 @@ gfc_make_safe_expr (gfc_se * se)\n   if (TREE_CODE_CLASS (TREE_CODE (se->expr)) == 'c')\n     return;\n \n-  /* we need a temporary for this result */\n+  /* We need a temporary for this result.  */\n   var = gfc_create_var (TREE_TYPE (se->expr), NULL);\n   gfc_add_modify_expr (&se->pre, var, se->expr);\n   se->expr = var;\n@@ -158,6 +158,7 @@ gfc_trans_init_string_length (gfc_charlen * cl, stmtblock_t * pblock)\n   gfc_add_modify_expr (pblock, tmp, se.expr);\n }\n \n+\n static void\n gfc_conv_substring (gfc_se * se, gfc_ref * ref, int kind)\n {\n@@ -345,7 +346,7 @@ gfc_conv_variable (gfc_se * se, gfc_expr * expr)\n       ref = ref->next;\n     }\n   /* Pointer assignment, allocation or pass by reference.  Arrays are handled\n-     seperately.  */\n+     separately.  */\n   if (se->want_pointer)\n     {\n       if (expr->ts.type == BT_CHARACTER)\n@@ -376,7 +377,7 @@ gfc_conv_unary_op (enum tree_code code, gfc_se * se, gfc_expr * expr)\n \n   /* TRUTH_NOT_EXPR is not a \"true\" unary operator in GCC.\n      We must convert it to a compare to 0 (e.g. EQ_EXPR (op1, 0)).\n-     All other unary operators have an equivalent GIMPLE unary operator  */\n+     All other unary operators have an equivalent GIMPLE unary operator.  */\n   if (code == TRUTH_NOT_EXPR)\n     se->expr = build (EQ_EXPR, type, operand.expr,\n \t\t      convert (type, integer_zero_node));\n@@ -386,7 +387,7 @@ gfc_conv_unary_op (enum tree_code code, gfc_se * se, gfc_expr * expr)\n }\n \n /* Expand power operator to optimal multiplications when a value is raised\n-   to an constant integer n. See section 4.6.3, \"Evaluation of Powers\" of\n+   to a constant integer n. See section 4.6.3, \"Evaluation of Powers\" of\n    Donald E. Knuth, \"Seminumerical Algorithms\", Vol. 2, \"The Art of Computer\n    Programming\", 3rd Edition, 1998.  */\n \n@@ -397,7 +398,7 @@ gfc_conv_unary_op (enum tree_code code, gfc_se * se, gfc_expr * expr)\n    with the first node being one.  */\n #define POWI_TABLE_SIZE 256\n \n-/* The table is from Builtins.c.  */\n+/* The table is from builtins.c.  */\n static const unsigned char powi_table[POWI_TABLE_SIZE] =\n   {\n       0,   1,   1,   2,   2,   3,   3,   4,  /*   0 -   7 */\n@@ -434,11 +435,12 @@ static const unsigned char powi_table[POWI_TABLE_SIZE] =\n     124, 166, 125, 214, 126, 138, 127, 153,  /* 248 - 255 */\n   };\n \n-/* If n is larger than lookup table's max index, we use \"window method\".  */\n+/* If n is larger than lookup table's max index, we use the \"window \n+   method\".  */\n #define POWI_WINDOW_SIZE 3\n \n-/* Recursive function to expand power operator. The temporary values are put\n-   in tmpvar. The function return tmpvar[1] ** n.  */\n+/* Recursive function to expand the power operator. The temporary \n+   values are put in tmpvar. The function returns tmpvar[1] ** n.  */\n static tree\n gfc_conv_powi (gfc_se * se, int n, tree * tmpvar)\n {\n@@ -476,8 +478,10 @@ gfc_conv_powi (gfc_se * se, int n, tree * tmpvar)\n   return tmp;\n }\n \n-/* Expand lhs ** rhs. rhs is an constant integer. If expand successfully,\n-   return 1. Else return 0 and will call runtime library functions.  */\n+\n+/* Expand lhs ** rhs. rhs is a constant integer. If it expands successfully,\n+   return 1. Else return 0 and a call to runtime library functions\n+   will have to be built.  */\n static int\n gfc_conv_cst_int_power (gfc_se * se, tree lhs, tree rhs)\n {\n@@ -509,7 +513,7 @@ gfc_conv_cst_int_power (gfc_se * se, tree lhs, tree rhs)\n       cond = build (EQ_EXPR, boolean_type_node, lhs,\n \t\t    convert (TREE_TYPE (lhs), integer_one_node));\n \n-      /* If rhs is an even,\n+      /* If rhs is even,\n \t result = (lhs == 1 || lhs == -1) ? 1 : 0.  */\n       if ((n & 1) == 0)\n         {\n@@ -519,7 +523,7 @@ gfc_conv_cst_int_power (gfc_se * se, tree lhs, tree rhs)\n \t\t\t    convert (type, integer_zero_node));\n \t  return 1;\n \t}\n-      /* If rhs is an odd,\n+      /* If rhs is odd,\n \t result = (lhs == 1) ? 1 : (lhs == -1) ? -1 : 0.  */\n       tmp = build (COND_EXPR, type, tmp,\n \t\t   convert (type, integer_minus_one_node),\n@@ -777,9 +781,9 @@ gfc_conv_concat_op (gfc_se * se, gfc_expr * expr)\n /* Translates an op expression. Common (binary) cases are handled by this\n    function, others are passed on. Recursion is used in either case.\n    We use the fact that (op1.ts == op2.ts) (except for the power\n-   operand **).\n+   operator **).\n    Operators need no special handling for scalarized expressions as long as\n-   they call gfc_conv_siple_val to get their operands.\n+   they call gfc_conv_simple_val to get their operands.\n    Character strings get special handling.  */\n \n static void\n@@ -900,7 +904,7 @@ gfc_conv_expr_op (gfc_se * se, gfc_expr * expr)\n       return;\n     }\n \n-  /* The only exception to this is **, which is handled seperately anyway.  */\n+  /* The only exception to this is **, which is handled separately anyway.  */\n   assert (expr->op1->ts.type == expr->op2->ts.type);\n \n   if (checkstring && expr->op1->ts.type != BT_CHARACTER)\n@@ -946,12 +950,12 @@ gfc_conv_expr_op (gfc_se * se, gfc_expr * expr)\n   else\n     se->expr = fold (build (code, type, lse.expr, rse.expr));\n \n-\n   /* Add the post blocks.  */\n   gfc_add_block_to_block (&se->post, &rse.post);\n   gfc_add_block_to_block (&se->post, &lse.post);\n }\n \n+\n static void\n gfc_conv_function_val (gfc_se * se, gfc_symbol * sym)\n {\n@@ -1125,11 +1129,13 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n             }\n \t  else\n \t    {\n-\t      /* If the procedure requires explicit interface, actual argument\n-\t         is passed according to corresponing formal argument.  We\n-\t\t do not use g77 method and the address of array descriptor\n-\t\t is passed if corresponing formal is pointer or\n-\t\t assumed-shape,  Otherwise use g77 method.  */\n+\t      /* If the procedure requires an explicit interface, the\n+\t\t actual argument is passed according to the\n+\t\t corresponding formal argument.  If the corresponding\n+\t\t formal argument is a POINTER or assumed shape, we do\n+\t\t not use g77's calling aonvention, and pass the\n+\t\t address of the array descriptor instead. Otherwise we\n+\t\t use g77's calling convention.  */\n \t      int f;\n \t      f = (formal != NULL)\n \t\t  && !formal->sym->attr.pointer\n@@ -1164,8 +1170,8 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n   se->expr = build (CALL_EXPR, TREE_TYPE (fntype), se->expr,\n \t\t    arglist, NULL_TREE);\n \n-/* A pure function may still have side-effects - it may modify its\n-   parameters.  */\n+  /* A pure function may still have side-effects - it may modify its\n+     parameters.  */\n   TREE_SIDE_EFFECTS (se->expr) = 1;\n #if 0\n   if (!sym->attr.pure)\n@@ -1324,7 +1330,7 @@ gfc_conv_statement_function (gfc_se * se, gfc_expr * expr)\n       se->string_length = sym->ts.cl->backend_decl;\n     }\n \n-  /* Resore the original variables.  */\n+  /* Restore the original variables.  */\n   for (fargs = sym->formal, n = 0; fargs; fargs = fargs->next, n++)\n     gfc_restore_sym (fargs->sym, &saved_vars[n]);\n   gfc_free (saved_vars);\n@@ -1344,7 +1350,7 @@ gfc_conv_function_expr (gfc_se * se, gfc_expr * expr)\n       return;\n     }\n \n-  /* We distinguish the statement function from general function to improve\n+  /* We distinguish statement functions from general functions to improve\n      runtime performance.  */\n   if (expr->symtree->n.sym->attr.proc == PROC_ST_FUNCTION)\n     {\n@@ -1360,6 +1366,7 @@ gfc_conv_function_expr (gfc_se * se, gfc_expr * expr)\n   gfc_conv_function_call (se, sym, expr->value.function.actual);\n }\n \n+\n static void\n gfc_conv_array_constructor_expr (gfc_se * se, gfc_expr * expr)\n {\n@@ -1372,8 +1379,8 @@ gfc_conv_array_constructor_expr (gfc_se * se, gfc_expr * expr)\n \n \n /* Build a static initializer.  EXPR is the expression for the initial value.\n-   The other parameters describe the variable of component being initialized.\n-   EXPR may be null.  */\n+   The other parameters describe the variable of the component being \n+   initialized. EXPR may be null.  */\n \n tree\n gfc_conv_initializer (gfc_expr * expr, gfc_typespec * ts, tree type,\n@@ -1673,7 +1680,7 @@ gfc_conv_structure (gfc_se * se, gfc_expr * expr, int init)\n }\n \n \n-/*translate a substring expression */\n+/* Translate a substring expression.  */\n \n static void\n gfc_conv_substring_expr (gfc_se * se, gfc_expr * expr)\n@@ -1780,7 +1787,7 @@ gfc_conv_expr_type (gfc_se * se, gfc_expr * expr, tree type)\n }\n \n \n-/* Converts an expression so that it can be passed by refernece.  Scalar\n+/* Converts an expression so that it can be passed by reference.  Scalar\n    values only.  */\n \n void"}]}