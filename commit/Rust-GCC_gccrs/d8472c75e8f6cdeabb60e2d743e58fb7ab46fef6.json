{"sha": "d8472c75e8f6cdeabb60e2d743e58fb7ab46fef6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDg0NzJjNzVlOGY2Y2RlYWJiNjBlMmQ3NDNlNThmYjdhYjQ2ZmVmNg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2004-07-18T05:44:18Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2004-07-18T05:44:18Z"}, "message": "re PR tree-optimization/16115 (double-destruction problem with argument passing via temporary (breaks auto_ptr))\n\n        PR c++/16115\n        * stor-layout.c (relayout_decl): New fn.\n        * tree.h: Declare it.\n        (DECL_BY_REFERENCE): New macro.\n        * cp/call.c (type_passed_as): Make the invisible reference type\n        __restrict.\n        * cp/cp-gimplify.c (gimplify_cleanup_stmt): Rename to\n        cp_genericize_r.  Handle invisible reference lowering.\n        (is_invisiref_parm): New fn.\n        (cp_genericize): Adjust the types of invisible reference parms.\n        Don't repeat the walk for clones.\n        * cp/decl.c (store_parm_decls): Don't generate any code for clones.\n\nFrom-SVN: r84887", "tree": {"sha": "c1f40776f7d9fdfe9b7691b28cc55470e406ddcc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c1f40776f7d9fdfe9b7691b28cc55470e406ddcc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d8472c75e8f6cdeabb60e2d743e58fb7ab46fef6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8472c75e8f6cdeabb60e2d743e58fb7ab46fef6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8472c75e8f6cdeabb60e2d743e58fb7ab46fef6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8472c75e8f6cdeabb60e2d743e58fb7ab46fef6/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b52cf5a74395bb7b39ded04dd7dd1fd756dd99e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b52cf5a74395bb7b39ded04dd7dd1fd756dd99e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b52cf5a74395bb7b39ded04dd7dd1fd756dd99e3"}], "stats": {"total": 148, "additions": 130, "deletions": 18}, "files": [{"sha": "e279ea24f10cc4682c153e22754c29ea2d876489", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8472c75e8f6cdeabb60e2d743e58fb7ab46fef6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8472c75e8f6cdeabb60e2d743e58fb7ab46fef6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d8472c75e8f6cdeabb60e2d743e58fb7ab46fef6", "patch": "@@ -1,3 +1,10 @@\n+2004-07-17  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/16115\n+\t* stor-layout.c (relayout_decl): New fn.\n+\t* tree.h: Declare it.\n+\t(DECL_BY_REFERENCE): New macro.\n+\n 2004-07-17  Eric Botcazou  <ebotcazou@act-europe.fr>\n \n \t* libgcc2.c (__enable_execute_stack): New symbol."}, {"sha": "0108c2954940d0b4b58dee9ab1a1938b25b2234d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8472c75e8f6cdeabb60e2d743e58fb7ab46fef6/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8472c75e8f6cdeabb60e2d743e58fb7ab46fef6/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=d8472c75e8f6cdeabb60e2d743e58fb7ab46fef6", "patch": "@@ -1,3 +1,15 @@\n+2004-07-17  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/16115\n+\t* call.c (type_passed_as): Make the invisible reference type\n+\t__restrict.\n+\t* cp-gimplify.c (gimplify_cleanup_stmt): Rename to\n+\tcp_genericize_r.  Handle invisible reference lowering.\n+\t(is_invisiref_parm): New fn.\n+\t(cp_genericize): Adjust the types of invisible reference parms.\n+\tDon't repeat the walk for clones.\n+\t* decl.c (store_parm_decls): Don't generate any code for clones.\n+\n 2004-07-17  Joseph S. Myers  <jsm@polyomino.org.uk>\n \n \t* cp-tree.h (builtin_function): Declare."}, {"sha": "0e734b80179143e14d34c33ab5e6be39c455c2cc", "filename": "gcc/cp/call.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8472c75e8f6cdeabb60e2d743e58fb7ab46fef6/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8472c75e8f6cdeabb60e2d743e58fb7ab46fef6/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=d8472c75e8f6cdeabb60e2d743e58fb7ab46fef6", "patch": "@@ -4503,7 +4503,11 @@ type_passed_as (tree type)\n {\n   /* Pass classes with copy ctors by invisible reference.  */\n   if (TREE_ADDRESSABLE (type))\n-    type = build_reference_type (type);\n+    {\n+      type = build_reference_type (type);\n+      /* There are no other pointers to this temporary.  */\n+      type = build_qualified_type (type, TYPE_QUAL_RESTRICT);\n+    }\n   else if (targetm.calls.promote_prototypes (type)\n \t   && INTEGRAL_TYPE_P (type)\n \t   && COMPLETE_TYPE_P (type)"}, {"sha": "ed0a6a19d41901f7d8de08e34f768e760b8ad4bb", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 67, "deletions": 10, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8472c75e8f6cdeabb60e2d743e58fb7ab46fef6/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8472c75e8f6cdeabb60e2d743e58fb7ab46fef6/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=d8472c75e8f6cdeabb60e2d743e58fb7ab46fef6", "patch": "@@ -29,7 +29,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"c-common.h\"\n #include \"toplev.h\"\n #include \"tree-gimple.h\"\n-\n+#include \"hashtab.h\"\n \n /* Genericize a TRY_BLOCK.  */\n \n@@ -264,31 +264,88 @@ cp_gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p)\n   return ret;\n }\n \n-/* Genericize a CLEANUP_STMT.  This just turns into a TRY_FINALLY or\n-   TRY_CATCH depending on whether it's EH-only.  */\n+static inline bool\n+is_invisiref_parm (tree t)\n+{\n+  return (TREE_CODE (t) == PARM_DECL\n+\t  && DECL_BY_REFERENCE (t));\n+}\n+\n+/* Perform any pre-gimplification lowering of C++ front end trees to\n+   GENERIC.  */\n \n static tree\n-gimplify_cleanup_stmt (tree *stmt_p, int *walk_subtrees,\n-\t\t       void *data ATTRIBUTE_UNUSED)\n+cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)\n {\n   tree stmt = *stmt_p;\n+  htab_t htab = (htab_t) data;\n+  void **slot;\n \n-  if (DECL_P (stmt) || TYPE_P (stmt))\n+  if (is_invisiref_parm (stmt))\n+    {\n+      *stmt_p = build_fold_indirect_ref (stmt);\n+      *walk_subtrees = 0;\n+      return NULL;\n+    }\n+\n+  /* Other than invisiref parms, don't walk the same tree twice.  */\n+  slot = htab_find_slot (htab, stmt, INSERT);\n+  if (*slot)\n+    {\n+      *walk_subtrees = 0;\n+      return NULL_TREE;\n+    }\n+\n+  if (TREE_CODE (stmt) == ADDR_EXPR\n+      && is_invisiref_parm (TREE_OPERAND (stmt, 0)))\n+    {\n+      *stmt_p = convert (TREE_TYPE (stmt), TREE_OPERAND (stmt, 0));\n+      *walk_subtrees = 0;\n+    }\n+  else if (DECL_P (stmt) || TYPE_P (stmt))\n     *walk_subtrees = 0;\n+\n+  /* Due to the way voidify_wrapper_expr is written, we don't get a chance\n+     to lower this construct before scanning it, so we need to lower these\n+     before doing anything else.  */\n   else if (TREE_CODE (stmt) == CLEANUP_STMT)\n     *stmt_p = build (CLEANUP_EH_ONLY (stmt) ? TRY_CATCH_EXPR : TRY_FINALLY_EXPR,\n \t\t     void_type_node, CLEANUP_BODY (stmt), CLEANUP_EXPR (stmt));\n \n+  *slot = *stmt_p;\n   return NULL;\n }\n \n void\n cp_genericize (tree fndecl)\n {\n-  /* Due to the way voidify_wrapper_expr is written, we don't get a chance\n-     to lower this construct before scanning it.  So we need to lower these\n-     before doing anything else.  */\n-  walk_tree (&DECL_SAVED_TREE (fndecl), gimplify_cleanup_stmt, NULL, NULL);\n+  tree t;\n+  htab_t htab;\n+\n+  /* Fix up the types of parms passed by invisible reference.  */\n+  for (t = DECL_ARGUMENTS (fndecl); t; t = TREE_CHAIN (t))\n+    {\n+      if (DECL_BY_REFERENCE (t))\n+\tabort ();\n+      if (TREE_ADDRESSABLE (TREE_TYPE (t)))\n+\t{\n+\t  if (DECL_ARG_TYPE (t) == TREE_TYPE (t))\n+\t    abort ();\n+\t  DECL_BY_REFERENCE (t) = 1;\n+\t  TREE_TYPE (t) = DECL_ARG_TYPE (t);\n+\t  relayout_decl (t);\n+\t}\n+    }\n+\n+  /* If we're a clone, the body is already GIMPLE.  */\n+  if (DECL_CLONED_FUNCTION_P (fndecl))\n+    return;\n+\n+  /* We do want to see every occurrence of the parms, so we can't just use\n+     walk_tree's hash functionality.  */\n+  htab = htab_create (37, htab_hash_pointer, htab_eq_pointer, NULL);\n+  walk_tree (&DECL_SAVED_TREE (fndecl), cp_genericize_r, htab, NULL);\n+  htab_delete (htab);\n \n   /* Do everything else.  */\n   c_genericize (fndecl);"}, {"sha": "874cfcba1508843a0fa3d45d0891bb5a64831409", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8472c75e8f6cdeabb60e2d743e58fb7ab46fef6/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8472c75e8f6cdeabb60e2d743e58fb7ab46fef6/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=d8472c75e8f6cdeabb60e2d743e58fb7ab46fef6", "patch": "@@ -9991,11 +9991,16 @@ store_parm_decls (tree current_function_parms)\n      DECL_ARGUMENTS is not modified.  */\n   current_binding_level->names = chainon (nonparms, DECL_ARGUMENTS (fndecl));\n \n-  /* Do the starting of the exception specifications, if we have any.  */\n-  if (flag_exceptions && !processing_template_decl\n-      && flag_enforce_eh_specs\n-      && TYPE_RAISES_EXCEPTIONS (TREE_TYPE (current_function_decl)))\n-    current_eh_spec_block = begin_eh_spec_block ();\n+  /* For a cloned function, we've already got all the code we need;\n+     there's no need to add any extra bits.  */\n+  if (!DECL_CLONED_FUNCTION_P (fndecl))\n+    {\n+      /* Do the starting of the exception specifications, if we have any.  */\n+      if (flag_exceptions && !processing_template_decl\n+\t  && flag_enforce_eh_specs\n+\t  && TYPE_RAISES_EXCEPTIONS (TREE_TYPE (current_function_decl)))\n+\tcurrent_eh_spec_block = begin_eh_spec_block ();\n+    }\n }\n \n \f"}, {"sha": "0ca26c238f766baafe5f8a9dcdf057fa3234418e", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8472c75e8f6cdeabb60e2d743e58fb7ab46fef6/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8472c75e8f6cdeabb60e2d743e58fb7ab46fef6/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=d8472c75e8f6cdeabb60e2d743e58fb7ab46fef6", "patch": "@@ -524,6 +524,20 @@ layout_decl (tree decl, unsigned int known_align)\n       SET_DECL_RTL (decl, rtl);\n     }\n }\n+\n+/* Given a VAR_DECL, PARM_DECL or RESULT_DECL, clears the results of\n+   a previous call to layout_decl and calls it again.  */\n+\n+void\n+relayout_decl (tree decl)\n+{\n+  DECL_SIZE (decl) = DECL_SIZE_UNIT (decl) = 0;\n+  DECL_MODE (decl) = VOIDmode;\n+  DECL_ALIGN (decl) = 0;\n+  SET_DECL_RTL (decl, 0);\n+\n+  layout_decl (decl, 0);\n+}\n \f\n /* Hook for a front-end function that can modify the record layout as needed\n    immediately before it is finalized.  */"}, {"sha": "9871387c7e390afa930f4ffa97dec6c216bf4485", "filename": "gcc/tree.h", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8472c75e8f6cdeabb60e2d743e58fb7ab46fef6/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8472c75e8f6cdeabb60e2d743e58fb7ab46fef6/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=d8472c75e8f6cdeabb60e2d743e58fb7ab46fef6", "patch": "@@ -234,6 +234,8 @@ struct tree_common GTY(())\n            ..._DECL\n        CALL_EXPR_HAS_RETURN_SLOT_ADDR in\n            CALL_EXPR\n+       DECL_BY_REFERENCE in\n+           PARM_DECL, RESULT_DECL\n \n    protected_flag:\n \n@@ -855,6 +857,10 @@ extern void tree_operand_check_failed (int, enum tree_code,\n    argument list.  */\n #define CALL_EXPR_HAS_RETURN_SLOT_ADDR(NODE) ((NODE)->common.private_flag)\n \n+/* In a RESULT_DECL or PARM_DECL, means that it is passed by invisible\n+   reference (and the TREE_TYPE is a pointer to the true type).  */\n+#define DECL_BY_REFERENCE(NODE) (DECL_CHECK (NODE)->common.private_flag)\n+\n /* In a CALL_EXPR, means that the call is the jump from a thunk to the\n    thunked-to function.  */\n #define CALL_FROM_THUNK_P(NODE) ((NODE)->common.protected_flag)\n@@ -2976,6 +2982,11 @@ extern tree type_hash_canon (unsigned int, tree);\n \n extern void layout_decl (tree, unsigned);\n \n+/* Given a VAR_DECL, PARM_DECL or RESULT_DECL, clears the results of\n+   a previous call to layout_decl and calls it again.  */\n+\n+extern void relayout_decl (tree);\n+\n /* Return the mode for data of a given size SIZE and mode class CLASS.\n    If LIMIT is nonzero, then don't use modes bigger than MAX_FIXED_MODE_SIZE.\n    The value is BLKmode if no other mode is found.  This is like\n@@ -3659,11 +3670,13 @@ extern void dwarf2out_return_save (const char *, HOST_WIDE_INT);\n \n extern void dwarf2out_return_reg (const char *, unsigned);\n \n+/* In tree-inline.c  */\n+\n /* The type of a callback function for walking over tree structure.  */\n \n typedef tree (*walk_tree_fn) (tree *, int *, void *);\n-tree walk_tree (tree*, walk_tree_fn, void*, void*);\n-tree walk_tree_without_duplicates (tree*, walk_tree_fn, void*);\n+extern tree walk_tree (tree*, walk_tree_fn, void*, void*);\n+extern tree walk_tree_without_duplicates (tree*, walk_tree_fn, void*);\n \n /* In tree-dump.c */\n "}]}