{"sha": "7d882b8356b9ee3e6844bf4898a996289223fab2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2Q4ODJiODM1NmI5ZWUzZTY4NDRiZjQ4OThhOTk2Mjg5MjIzZmFiMg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2009-06-16T14:24:40Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2009-06-16T14:24:40Z"}, "message": "c-common.c (skip_evaluation): Don't define.\n\n./:\t* c-common.c (skip_evaluation): Don't define.\n\t(c_inhibit_evaluation_warnings): Define global variable.\n\t(overflow_warning): Check c_inhibit_evaluation_warnings rather\n\tthan skip_evaluation.\n\t(convert_and_check, warn_for_div_by_zero): Likewise.\n\t* c-common.h (skip_evaluation): Don't declare.\n\t(c_inhibit_evaluation_warnings): Declare.\n\t* c-parser.c (c_parser_typeof_specifier): Set\n\tc_inhibit_evaluation_warnings rather than skip_evaluation.\n\t(c_parser_conditional_expression): Likewise.\n\t(c_parser_binary_expression): Likewise.\n\t(c_parser_sizeof_expression): Likewise.\n\t(c_parser_alignof_expression): Likewise.\n\t* c-typeck.c (build_indirect_ref): Check\n\tc_inhibit_evaluation_warnings rather than skip_evaluation.\n\t(build_conditional_expr, build_binary_op): Likewise.\ncp/:\n\t* parser.c (cp_unevaluated_operand): Define global variable.\n\t(cp_parser_question_colon_clause): Increment\n\tc_inhibit_evaluation_warnings when evaluating an expression which\n\twill never be executed.\n\t(cp_parser_decltype): Increment cp_unevaluated_operand and\n\tc_inhibit_evaluation_warnings, not skip_evaluation.\n\t(cp_parser_sizeof_operand): Likewise.\n\t(cp_parser_enclosed_template_argument_list): Save\n\tcp_unevaluated_operand and c_inhibit_evaluation_warnings, not\n\tskip_evaluation.\n\t* cp-tree.h (struct saved_scope): Remove skip_evaluation field.\n\tAdd unevaluated_operand and inhibit_evaluation_warnings fields.\n\t(cp_unevaluated_operand): Declare.\n\t* name-lookup.c (push_to_top_level): Save cp_unevaluated_operand\n\tand c_inhibit_evaluation_warnings rather than skip_evaluation.\n\t(pop_from_top_level): Restore cp_unevaluated_operand and\n\tc_inhibit_evaluation_warnings rather than skip_evaluation.\n\t* class.c (build_base_path): Check cp_unevaluated_operand rather\n\tthan skip_evaluation.\n\t* typeck.c (build_class_member_access_expr): Likewise.\n\t(cp_build_binary_op): Don't warn about bad shift counts if\n\tc_inhibit_evaluation_warnings is non-zero.\n\t* pt.c (coerce_template_parms): Save state of\n\tcp_unevaluated_operand and c_inhibit_evaluation_warnings, not\n\tskip_evaluation.\n\t(tsubst_aggr_type): Likewise.\n\t(tsubst_pack_expansion): Check cp_unevaluated_operand rather than\n\tskip_evaluation.\n\t(tsubst_copy): Likewise.\n\t(tsubst): Set cp_unevaluated_operand and\n\tc_inhibit_evaluation_warnings, not skip_evaluation.\n\t(tsubst_copy_and_build): Likewise.\n\t* call.c (convert_arg_to_ellipsis): Check cp_unevaluated_operand\n\trather than skip_evaluation.\n\t* decl2.c (mark_used): Likewise.\n\t* semantics.c (finish_non_static_data_member): Likewise.\n\t* cvt.c (cp_convert_and_check): Check\n\tc_inhibit_evaluation_warnings rather than skip_evaluation.\n\t* mangle.c (write_type): Set cp_unevaluated_operand rather than\n\tskip_evaluation.\ntestsuite/:\n\t* g++.dg/warn/skip-1.C: New testcase.\n\nFrom-SVN: r148535", "tree": {"sha": "7a42ffff9a8ca843cf87a59b7858690a5f169948", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7a42ffff9a8ca843cf87a59b7858690a5f169948"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7d882b8356b9ee3e6844bf4898a996289223fab2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d882b8356b9ee3e6844bf4898a996289223fab2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d882b8356b9ee3e6844bf4898a996289223fab2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d882b8356b9ee3e6844bf4898a996289223fab2/comments", "author": null, "committer": null, "parents": [{"sha": "2e4078422e64a42224ca69daa70604885698a942", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e4078422e64a42224ca69daa70604885698a942", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e4078422e64a42224ca69daa70604885698a942"}], "stats": {"total": 313, "additions": 231, "deletions": 82}, "files": [{"sha": "6c525da5d3652dd3a5969e43c170e67576b3473f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d882b8356b9ee3e6844bf4898a996289223fab2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d882b8356b9ee3e6844bf4898a996289223fab2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7d882b8356b9ee3e6844bf4898a996289223fab2", "patch": "@@ -1,3 +1,22 @@\n+2009-06-16  Ian Lance Taylor  <iant@google.com>\n+\n+\t* c-common.c (skip_evaluation): Don't define.\n+\t(c_inhibit_evaluation_warnings): Define global variable.\n+\t(overflow_warning): Check c_inhibit_evaluation_warnings rather\n+\tthan skip_evaluation.\n+\t(convert_and_check, warn_for_div_by_zero): Likewise.\n+\t* c-common.h (skip_evaluation): Don't declare.\n+\t(c_inhibit_evaluation_warnings): Declare.\n+\t* c-parser.c (c_parser_typeof_specifier): Set\n+\tc_inhibit_evaluation_warnings rather than skip_evaluation.\n+\t(c_parser_conditional_expression): Likewise.\n+\t(c_parser_binary_expression): Likewise.\n+\t(c_parser_sizeof_expression): Likewise.\n+\t(c_parser_alignof_expression): Likewise.\n+\t* c-typeck.c (build_indirect_ref): Check\n+\tc_inhibit_evaluation_warnings rather than skip_evaluation.\n+\t(build_conditional_expr, build_binary_op): Likewise.\n+\n 2009-06-16  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-ssa-alias.c (is_escape_site): Remove."}, {"sha": "43b2c13daed23e1a28889f5e625e04a8ea36796e", "filename": "gcc/c-common.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d882b8356b9ee3e6844bf4898a996289223fab2/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d882b8356b9ee3e6844bf4898a996289223fab2/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=7d882b8356b9ee3e6844bf4898a996289223fab2", "patch": "@@ -442,9 +442,9 @@ tree *ridpointers;\n \n tree (*make_fname_decl) (location_t, tree, int);\n \n-/* Nonzero means the expression being parsed will never be evaluated.\n-   This is a count, since unevaluated expressions can nest.  */\n-int skip_evaluation;\n+/* Nonzero means don't warn about problems that occur when the code is\n+   executed.  */\n+int c_inhibit_evaluation_warnings;\n \n /* Whether lexing has been completed, so subsequent preprocessor\n    errors should use the compiler's input_location.  */\n@@ -1507,7 +1507,8 @@ constant_expression_error (tree value)\n void\n overflow_warning (location_t loc, tree value)\n {\n-  if (skip_evaluation) return;\n+  if (c_inhibit_evaluation_warnings != 0)\n+    return;\n \n   switch (TREE_CODE (value))\n     {\n@@ -2225,7 +2226,9 @@ convert_and_check (tree type, tree expr)\n   \n   result = convert (type, expr);\n \n-  if (!skip_evaluation && !TREE_OVERFLOW_P (expr) && result != error_mark_node)\n+  if (c_inhibit_evaluation_warnings == 0\n+      && !TREE_OVERFLOW_P (expr)\n+      && result != error_mark_node)\n     warnings_for_convert_and_check (type, expr_for_warning, result);\n \n   return result;\n@@ -8952,7 +8955,7 @@ warn_for_div_by_zero (location_t loc, tree divisor)\n      about division by zero.  Do not issue a warning if DIVISOR has a\n      floating-point type, since we consider 0.0/0.0 a valid way of\n      generating a NaN.  */\n-  if (skip_evaluation == 0\n+  if (c_inhibit_evaluation_warnings == 0\n       && (integer_zerop (divisor) || fixed_zerop (divisor)))\n     warning_at (loc, OPT_Wdiv_by_zero, \"division by zero\");\n }"}, {"sha": "04a194597f72efa8e1d16159f72e90c42ea46845", "filename": "gcc/c-common.h", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d882b8356b9ee3e6844bf4898a996289223fab2/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d882b8356b9ee3e6844bf4898a996289223fab2/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=7d882b8356b9ee3e6844bf4898a996289223fab2", "patch": "@@ -719,10 +719,13 @@ extern int warn_strict_null_sentinel;\n \n extern int max_tinst_depth;\n \n-/* Nonzero means the expression being parsed will never be evaluated.\n-   This is a count, since unevaluated expressions can nest.  */\n+/* Nonzero means that we should not issue warnings about problems that\n+   occur when the code is executed, because the code being processed\n+   is not expected to be executed.  This is set during parsing.  This\n+   is used for cases like sizeof() and \"0 ? a : b\".  This is a count,\n+   not a bool, because unexecuted expressions can nest.  */\n \n-extern int skip_evaluation;\n+extern int c_inhibit_evaluation_warnings;\n \n /* Whether lexing has been completed, so subsequent preprocessor\n    errors should use the compiler's input_location.  */"}, {"sha": "2b78c3042fa24fb759b95f2b8d687580ffc46588", "filename": "gcc/c-parser.c", "status": "modified", "additions": 29, "deletions": 24, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d882b8356b9ee3e6844bf4898a996289223fab2/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d882b8356b9ee3e6844bf4898a996289223fab2/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=7d882b8356b9ee3e6844bf4898a996289223fab2", "patch": "@@ -2102,18 +2102,18 @@ c_parser_typeof_specifier (c_parser *parser)\n   ret.expr_const_operands = true;\n   gcc_assert (c_parser_next_token_is_keyword (parser, RID_TYPEOF));\n   c_parser_consume_token (parser);\n-  skip_evaluation++;\n+  c_inhibit_evaluation_warnings++;\n   in_typeof++;\n   if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n     {\n-      skip_evaluation--;\n+      c_inhibit_evaluation_warnings--;\n       in_typeof--;\n       return ret;\n     }\n   if (c_parser_next_token_starts_typename (parser))\n     {\n       struct c_type_name *type = c_parser_type_name (parser);\n-      skip_evaluation--;\n+      c_inhibit_evaluation_warnings--;\n       in_typeof--;\n       if (type != NULL)\n \t{\n@@ -2126,7 +2126,7 @@ c_parser_typeof_specifier (c_parser *parser)\n       bool was_vm;\n       location_t here = c_parser_peek_token (parser)->location;\n       struct c_expr expr = c_parser_expression (parser);\n-      skip_evaluation--;\n+      c_inhibit_evaluation_warnings--;\n       in_typeof--;\n       if (TREE_CODE (expr.value) == COMPONENT_REF\n \t  && DECL_C_BIT_FIELD (TREE_OPERAND (expr.value, 1)))\n@@ -4568,23 +4568,24 @@ c_parser_conditional_expression (c_parser *parser, struct c_expr *after)\n \texp1.value = build1 (EXCESS_PRECISION_EXPR, eptype, exp1.value);\n       exp1.original_type = NULL;\n       cond.value = c_objc_common_truthvalue_conversion (cond_loc, exp1.value);\n-      skip_evaluation += cond.value == truthvalue_true_node;\n+      c_inhibit_evaluation_warnings += cond.value == truthvalue_true_node;\n     }\n   else\n     {\n       cond.value\n \t= c_objc_common_truthvalue_conversion\n \t(cond_loc, default_conversion (cond.value));\n-      skip_evaluation += cond.value == truthvalue_false_node;\n+      c_inhibit_evaluation_warnings += cond.value == truthvalue_false_node;\n       exp1 = c_parser_expression_conv (parser);\n-      skip_evaluation += ((cond.value == truthvalue_true_node)\n-\t\t\t  - (cond.value == truthvalue_false_node));\n+      c_inhibit_evaluation_warnings +=\n+\t((cond.value == truthvalue_true_node)\n+\t - (cond.value == truthvalue_false_node));\n     }\n \n   colon_loc = c_parser_peek_token (parser)->location;\n   if (!c_parser_require (parser, CPP_COLON, \"expected %<:%>\"))\n     {\n-      skip_evaluation -= cond.value == truthvalue_true_node;\n+      c_inhibit_evaluation_warnings -= cond.value == truthvalue_true_node;\n       ret.value = error_mark_node;\n       ret.original_code = ERROR_MARK;\n       ret.original_type = NULL;\n@@ -4595,7 +4596,7 @@ c_parser_conditional_expression (c_parser *parser, struct c_expr *after)\n     exp2 = c_parser_conditional_expression (parser, NULL);\n     exp2 = default_function_array_conversion (exp2_loc, exp2);\n   }\n-  skip_evaluation -= cond.value == truthvalue_true_node;\n+  c_inhibit_evaluation_warnings -= cond.value == truthvalue_true_node;\n   ret.value = build_conditional_expr (colon_loc, cond.value,\n \t\t\t\t      cond.original_code == C_MAYBE_CONST_EXPR,\n \t\t\t\t      exp1.value, exp2.value);\n@@ -4696,8 +4697,8 @@ c_parser_binary_expression (c_parser *parser, struct c_expr *after)\n      the stack has lower precedence than the new operator or there is\n      only one element on the stack; then the top expression is the LHS\n      of the new operator.  In the case of logical AND and OR\n-     expressions, we also need to adjust skip_evaluation as\n-     appropriate when the operators are pushed and popped.  */\n+     expressions, we also need to adjust c_inhibit_evaluation_warnings\n+     as appropriate when the operators are pushed and popped.  */\n \n   /* The precedence levels, where 0 is a dummy lowest level used for\n      the bottom of the stack.  */\n@@ -4734,10 +4735,12 @@ c_parser_binary_expression (c_parser *parser, struct c_expr *after)\n     switch (stack[sp].op)\t\t\t\t\t\t      \\\n       {\t\t\t\t\t\t\t\t\t      \\\n       case TRUTH_ANDIF_EXPR:\t\t\t\t\t\t      \\\n-\tskip_evaluation -= stack[sp - 1].expr.value == truthvalue_false_node; \\\n+\tc_inhibit_evaluation_warnings -= (stack[sp - 1].expr.value\t      \\\n+\t\t\t\t\t  == truthvalue_false_node);\t      \\\n \tbreak;\t\t\t\t\t\t\t\t      \\\n       case TRUTH_ORIF_EXPR:\t\t\t\t\t\t      \\\n-\tskip_evaluation -= stack[sp - 1].expr.value == truthvalue_true_node;  \\\n+\tc_inhibit_evaluation_warnings -= (stack[sp - 1].expr.value\t      \\\n+\t\t\t\t\t  == truthvalue_true_node);\t      \\\n \tbreak;\t\t\t\t\t\t\t\t      \\\n       default:\t\t\t\t\t\t\t\t      \\\n \tbreak;\t\t\t\t\t\t\t\t      \\\n@@ -4855,15 +4858,17 @@ c_parser_binary_expression (c_parser *parser, struct c_expr *after)\n \t\t\t\t\t\t stack[sp].expr);\n \t  stack[sp].expr.value = c_objc_common_truthvalue_conversion\n \t    (stack[sp].loc, default_conversion (stack[sp].expr.value));\n-\t  skip_evaluation += stack[sp].expr.value == truthvalue_false_node;\n+\t  c_inhibit_evaluation_warnings += (stack[sp].expr.value\n+\t\t\t\t\t    == truthvalue_false_node);\n \t  break;\n \tcase TRUTH_ORIF_EXPR:\n \t  stack[sp].expr\n \t    = default_function_array_conversion (stack[sp].loc,\n \t\t\t\t\t\t stack[sp].expr);\n \t  stack[sp].expr.value = c_objc_common_truthvalue_conversion\n \t    (stack[sp].loc, default_conversion (stack[sp].expr.value));\n-\t  skip_evaluation += stack[sp].expr.value == truthvalue_true_node;\n+\t  c_inhibit_evaluation_warnings += (stack[sp].expr.value\n+\t\t\t\t\t    == truthvalue_true_node);\n \t  break;\n \tdefault:\n \t  break;\n@@ -5086,7 +5091,7 @@ c_parser_sizeof_expression (c_parser *parser)\n   location_t expr_loc;\n   gcc_assert (c_parser_next_token_is_keyword (parser, RID_SIZEOF));\n   c_parser_consume_token (parser);\n-  skip_evaluation++;\n+  c_inhibit_evaluation_warnings++;\n   in_sizeof++;\n   if (c_parser_next_token_is (parser, CPP_OPEN_PAREN)\n       && c_token_starts_typename (c_parser_peek_2nd_token (parser)))\n@@ -5101,7 +5106,7 @@ c_parser_sizeof_expression (c_parser *parser)\n       if (type_name == NULL)\n \t{\n \t  struct c_expr ret;\n-\t  skip_evaluation--;\n+\t  c_inhibit_evaluation_warnings--;\n \t  in_sizeof--;\n \t  ret.value = error_mark_node;\n \t  ret.original_code = ERROR_MARK;\n@@ -5116,7 +5121,7 @@ c_parser_sizeof_expression (c_parser *parser)\n \t  goto sizeof_expr;\n \t}\n       /* sizeof ( type-name ).  */\n-      skip_evaluation--;\n+      c_inhibit_evaluation_warnings--;\n       in_sizeof--;\n       return c_expr_sizeof_type (expr_loc, type_name);\n     }\n@@ -5125,7 +5130,7 @@ c_parser_sizeof_expression (c_parser *parser)\n       expr_loc = c_parser_peek_token (parser)->location;\n       expr = c_parser_unary_expression (parser);\n     sizeof_expr:\n-      skip_evaluation--;\n+      c_inhibit_evaluation_warnings--;\n       in_sizeof--;\n       if (TREE_CODE (expr.value) == COMPONENT_REF\n \t  && DECL_C_BIT_FIELD (TREE_OPERAND (expr.value, 1)))\n@@ -5143,7 +5148,7 @@ c_parser_alignof_expression (c_parser *parser)\n   location_t loc = c_parser_peek_token (parser)->location;\n   gcc_assert (c_parser_next_token_is_keyword (parser, RID_ALIGNOF));\n   c_parser_consume_token (parser);\n-  skip_evaluation++;\n+  c_inhibit_evaluation_warnings++;\n   in_alignof++;\n   if (c_parser_next_token_is (parser, CPP_OPEN_PAREN)\n       && c_token_starts_typename (c_parser_peek_2nd_token (parser)))\n@@ -5160,7 +5165,7 @@ c_parser_alignof_expression (c_parser *parser)\n       if (type_name == NULL)\n \t{\n \t  struct c_expr ret;\n-\t  skip_evaluation--;\n+\t  c_inhibit_evaluation_warnings--;\n \t  in_alignof--;\n \t  ret.value = error_mark_node;\n \t  ret.original_code = ERROR_MARK;\n@@ -5175,7 +5180,7 @@ c_parser_alignof_expression (c_parser *parser)\n \t  goto alignof_expr;\n \t}\n       /* alignof ( type-name ).  */\n-      skip_evaluation--;\n+      c_inhibit_evaluation_warnings--;\n       in_alignof--;\n       ret.value = c_alignof (loc, groktypename (type_name, NULL, NULL));\n       ret.original_code = ERROR_MARK;\n@@ -5187,7 +5192,7 @@ c_parser_alignof_expression (c_parser *parser)\n       struct c_expr ret;\n       expr = c_parser_unary_expression (parser);\n     alignof_expr:\n-      skip_evaluation--;\n+      c_inhibit_evaluation_warnings--;\n       in_alignof--;\n       ret.value = c_alignof_expr (loc, expr.value);\n       ret.original_code = ERROR_MARK;"}, {"sha": "07d51a4d5d82b7bb6c8bfe078f44a2f2e0600a0d", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d882b8356b9ee3e6844bf4898a996289223fab2/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d882b8356b9ee3e6844bf4898a996289223fab2/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=7d882b8356b9ee3e6844bf4898a996289223fab2", "patch": "@@ -2079,7 +2079,7 @@ build_indirect_ref (location_t loc, tree ptr, const char *errorstring)\n \t      error_at (loc, \"dereferencing pointer to incomplete type\");\n \t      return error_mark_node;\n \t    }\n-\t  if (VOID_TYPE_P (t) && skip_evaluation == 0)\n+\t  if (VOID_TYPE_P (t) && c_inhibit_evaluation_warnings == 0)\n \t    warning_at (loc, 0, \"dereferencing %<void *%> pointer\");\n \n \t  /* We *must* set TREE_READONLY when dereferencing a pointer to const,\n@@ -3864,7 +3864,7 @@ build_conditional_expr (location_t colon_loc, tree ifexp, bool ifexp_bcp,\n \t and later code won't know it used to be different.\n \t Do this check on the original types, so that explicit casts\n \t will be considered, but default promotions won't.  */\n-      if (!skip_evaluation)\n+      if (c_inhibit_evaluation_warnings == 0)\n \t{\n \t  int unsigned_op1 = TYPE_UNSIGNED (TREE_TYPE (orig_op1));\n \t  int unsigned_op2 = TYPE_UNSIGNED (TREE_TYPE (orig_op2));\n@@ -9074,7 +9074,7 @@ build_binary_op (location_t location, enum tree_code code,\n \t      if (tree_int_cst_sgn (op1) < 0)\n \t\t{\n \t\t  int_const = false;\n-\t\t  if (skip_evaluation == 0)\n+\t\t  if (c_inhibit_evaluation_warnings == 0)\n \t\t    warning (0, \"right shift count is negative\");\n \t\t}\n \t      else\n@@ -9085,7 +9085,7 @@ build_binary_op (location_t location, enum tree_code code,\n \t\t  if (compare_tree_int (op1, TYPE_PRECISION (type0)) >= 0)\n \t\t    {\n \t\t      int_const = false;\n-\t\t      if (skip_evaluation == 0)\n+\t\t      if (c_inhibit_evaluation_warnings == 0)\n \t\t\twarning (0, \"right shift count >= width of type\");\n \t\t    }\n \t\t}\n@@ -9111,14 +9111,14 @@ build_binary_op (location_t location, enum tree_code code,\n \t      if (tree_int_cst_sgn (op1) < 0)\n \t\t{\n \t\t  int_const = false;\n-\t\t  if (skip_evaluation == 0)\n+\t\t  if (c_inhibit_evaluation_warnings == 0)\n \t\t    warning (0, \"left shift count is negative\");\n \t\t}\n \n \t      else if (compare_tree_int (op1, TYPE_PRECISION (type0)) >= 0)\n \t\t{\n \t\t  int_const = false;\n-\t\t  if (skip_evaluation == 0)\n+\t\t  if (c_inhibit_evaluation_warnings == 0)\n \t\t    warning (0, \"left shift count >= width of type\");\n \t\t}\n \t    }\n@@ -9458,7 +9458,7 @@ build_binary_op (location_t location, enum tree_code code,\n \t  converted = 1;\n \t  resultcode = xresultcode;\n \n-\t  if (!skip_evaluation)\n+\t  if (c_inhibit_evaluation_warnings == 0)\n \t    {\n \t      bool op0_maybe_const = true;\n \t      bool op1_maybe_const = true;"}, {"sha": "391268843d0cc8675208e8fa48f4fe9944289155", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d882b8356b9ee3e6844bf4898a996289223fab2/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d882b8356b9ee3e6844bf4898a996289223fab2/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=7d882b8356b9ee3e6844bf4898a996289223fab2", "patch": "@@ -1,3 +1,46 @@\n+2009-06-16  Ian Lance Taylor  <iant@google.com>\n+\n+\t* parser.c (cp_unevaluated_operand): Define global variable.\n+\t(cp_parser_question_colon_clause): Increment\n+\tc_inhibit_evaluation_warnings when evaluating an expression which\n+\twill never be executed.\n+\t(cp_parser_decltype): Increment cp_unevaluated_operand and\n+\tc_inhibit_evaluation_warnings, not skip_evaluation.\n+\t(cp_parser_sizeof_operand): Likewise.\n+\t(cp_parser_enclosed_template_argument_list): Save\n+\tcp_unevaluated_operand and c_inhibit_evaluation_warnings, not\n+\tskip_evaluation.\n+\t* cp-tree.h (struct saved_scope): Remove skip_evaluation field.\n+\tAdd unevaluated_operand and inhibit_evaluation_warnings fields.\n+\t(cp_unevaluated_operand): Declare.\n+\t* name-lookup.c (push_to_top_level): Save cp_unevaluated_operand\n+\tand c_inhibit_evaluation_warnings rather than skip_evaluation.\n+\t(pop_from_top_level): Restore cp_unevaluated_operand and\n+\tc_inhibit_evaluation_warnings rather than skip_evaluation.\n+\t* class.c (build_base_path): Check cp_unevaluated_operand rather\n+\tthan skip_evaluation.\n+\t* typeck.c (build_class_member_access_expr): Likewise.\n+\t(cp_build_binary_op): Don't warn about bad shift counts if\n+\tc_inhibit_evaluation_warnings is non-zero.\n+\t* pt.c (coerce_template_parms): Save state of\n+\tcp_unevaluated_operand and c_inhibit_evaluation_warnings, not\n+\tskip_evaluation.\n+\t(tsubst_aggr_type): Likewise.\n+\t(tsubst_pack_expansion): Check cp_unevaluated_operand rather than\n+\tskip_evaluation.\n+\t(tsubst_copy): Likewise.\n+\t(tsubst): Set cp_unevaluated_operand and\n+\tc_inhibit_evaluation_warnings, not skip_evaluation.\n+\t(tsubst_copy_and_build): Likewise.\n+\t* call.c (convert_arg_to_ellipsis): Check cp_unevaluated_operand\n+\trather than skip_evaluation.\n+\t* decl2.c (mark_used): Likewise.\n+\t* semantics.c (finish_non_static_data_member): Likewise.\n+\t* cvt.c (cp_convert_and_check): Check\n+\tc_inhibit_evaluation_warnings rather than skip_evaluation.\n+\t* mangle.c (write_type): Set cp_unevaluated_operand rather than\n+\tskip_evaluation.\n+\n 2009-06-15  Ian Lance Taylor  <iant@google.com>\n \n \t* parser.c (cp_parser_direct_declarator): Add braces around"}, {"sha": "e89d5857edcfd60c93b9765b2ec163600fe54ba9", "filename": "gcc/cp/call.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d882b8356b9ee3e6844bf4898a996289223fab2/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d882b8356b9ee3e6844bf4898a996289223fab2/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=7d882b8356b9ee3e6844bf4898a996289223fab2", "patch": "@@ -5064,7 +5064,7 @@ convert_arg_to_ellipsis (tree arg)\n \t If the call appears in the context of a sizeof expression,\n \t there is no need to emit a warning, since the expression won't be\n \t evaluated. We keep the builtin_trap just as a safety check.  */\n-      if (!skip_evaluation)\n+      if (cp_unevaluated_operand == 0)\n \twarning (0, \"cannot pass objects of non-POD type %q#T through %<...%>; \"\n \t\t \"call will abort at runtime\", TREE_TYPE (arg));\n       arg = call_builtin_trap ();"}, {"sha": "b762019cf8374032b7c4b15accae1077237f6e6d", "filename": "gcc/cp/class.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d882b8356b9ee3e6844bf4898a996289223fab2/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d882b8356b9ee3e6844bf4898a996289223fab2/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=7d882b8356b9ee3e6844bf4898a996289223fab2", "patch": "@@ -295,7 +295,7 @@ build_base_path (enum tree_code code,\n \n   /* Don't bother with the calculations inside sizeof; they'll ICE if the\n      source type is incomplete and the pointer value doesn't matter.  */\n-  if (skip_evaluation)\n+  if (cp_unevaluated_operand != 0)\n     {\n       expr = build_nop (build_pointer_type (target_type), expr);\n       if (!want_pointer)"}, {"sha": "8c45b8a3a6854b51f0df6038765becf485436a4c", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d882b8356b9ee3e6844bf4898a996289223fab2/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d882b8356b9ee3e6844bf4898a996289223fab2/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=7d882b8356b9ee3e6844bf4898a996289223fab2", "patch": "@@ -755,7 +755,9 @@ struct GTY(()) saved_scope {\n   int x_processing_specialization;\n   BOOL_BITFIELD x_processing_explicit_instantiation : 1;\n   BOOL_BITFIELD need_pop_function_context : 1;\n-  BOOL_BITFIELD skip_evaluation : 1;\n+\n+  int unevaluated_operand;\n+  int inhibit_evaluation_warnings;\n \n   struct stmt_tree_s x_stmt_tree;\n \n@@ -3621,6 +3623,14 @@ extern GTY(()) tree integer_three_node;\n    function, two inside the body of a function in a local class, etc.)  */\n extern int function_depth;\n \n+/* In parser.c.  */\n+\n+/* Nonzero if we are parsing an unevaluated operand: an operand to\n+   sizeof, typeof, or alignof.  This is a count since operands to\n+   sizeof can be nested.  */\n+\n+extern int cp_unevaluated_operand;\n+\n /* in pt.c  */\n \n /* These values are used for the `STRICT' parameter to type_unification and"}, {"sha": "dfd0ea81e7527cbab182236416c3f446812e3dfa", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d882b8356b9ee3e6844bf4898a996289223fab2/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d882b8356b9ee3e6844bf4898a996289223fab2/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=7d882b8356b9ee3e6844bf4898a996289223fab2", "patch": "@@ -565,7 +565,9 @@ cp_convert_and_check (tree type, tree expr)\n   \n   result = cp_convert (type, expr);\n \n-  if (!skip_evaluation && !TREE_OVERFLOW_P (expr) && result != error_mark_node)\n+  if (c_inhibit_evaluation_warnings == 0\n+      && !TREE_OVERFLOW_P (expr)\n+      && result != error_mark_node)\n     warnings_for_convert_and_check (type, expr, result);\n \n   return result;"}, {"sha": "308f767cc096a1b85b16692a4244ca51a6e55ae8", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d882b8356b9ee3e6844bf4898a996289223fab2/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d882b8356b9ee3e6844bf4898a996289223fab2/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=7d882b8356b9ee3e6844bf4898a996289223fab2", "patch": "@@ -3815,7 +3815,7 @@ mark_used (tree decl)\n       return;\n     }\n   /* If we don't need a value, then we don't need to synthesize DECL.  */\n-  if (skip_evaluation)\n+  if (cp_unevaluated_operand != 0)\n     return;\n \n   /* If within finish_function, defer the rest until that function"}, {"sha": "f7d9d4169885cec27e2bb2d918257e5774fe9cda", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d882b8356b9ee3e6844bf4898a996289223fab2/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d882b8356b9ee3e6844bf4898a996289223fab2/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=7d882b8356b9ee3e6844bf4898a996289223fab2", "patch": "@@ -1684,9 +1684,9 @@ write_type (tree type)\n                 write_char ('t');\n               else\n                 write_char ('T');\n-\t      ++skip_evaluation;\n+\t      ++cp_unevaluated_operand;\n               write_expression (DECLTYPE_TYPE_EXPR (type));\n-\t      --skip_evaluation;\n+\t      --cp_unevaluated_operand;\n               write_char ('E');\n               break;\n "}, {"sha": "143fcf3156882172ef556e18c2f13d0f882473f9", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d882b8356b9ee3e6844bf4898a996289223fab2/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d882b8356b9ee3e6844bf4898a996289223fab2/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=7d882b8356b9ee3e6844bf4898a996289223fab2", "patch": "@@ -5319,15 +5319,17 @@ push_to_top_level (void)\n   s->bindings = b;\n   s->need_pop_function_context = need_pop;\n   s->function_decl = current_function_decl;\n-  s->skip_evaluation = skip_evaluation;\n+  s->unevaluated_operand = cp_unevaluated_operand;\n+  s->inhibit_evaluation_warnings = c_inhibit_evaluation_warnings;\n \n   scope_chain = s;\n   current_function_decl = NULL_TREE;\n   current_lang_base = VEC_alloc (tree, gc, 10);\n   current_lang_name = lang_name_cplusplus;\n   current_namespace = global_namespace;\n   push_class_stack ();\n-  skip_evaluation = 0;\n+  cp_unevaluated_operand = 0;\n+  c_inhibit_evaluation_warnings = 0;\n   timevar_pop (TV_NAME_LOOKUP);\n }\n \n@@ -5360,7 +5362,8 @@ pop_from_top_level (void)\n   if (s->need_pop_function_context)\n     pop_function_context ();\n   current_function_decl = s->function_decl;\n-  skip_evaluation = s->skip_evaluation;\n+  cp_unevaluated_operand = s->unevaluated_operand;\n+  c_inhibit_evaluation_warnings = s->inhibit_evaluation_warnings;\n   timevar_pop (TV_NAME_LOOKUP);\n }\n "}, {"sha": "bdf305827f0c005585333b5e0120bd4663733659", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 36, "deletions": 12, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d882b8356b9ee3e6844bf4898a996289223fab2/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d882b8356b9ee3e6844bf4898a996289223fab2/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=7d882b8356b9ee3e6844bf4898a996289223fab2", "patch": "@@ -247,6 +247,10 @@ static void cp_parser_initial_pragma\n static FILE *cp_lexer_debug_stream;\n #endif /* ENABLE_CHECKING */\n \n+/* Nonzero if we are parsing an unevaluated operand: an operand to\n+   sizeof, typeof, or alignof.  */\n+int cp_unevaluated_operand;\n+\n /* Create a new main C++ lexer, the lexer that gets tokens from the\n    preprocessor.  */\n \n@@ -6385,16 +6389,26 @@ cp_parser_question_colon_clause (cp_parser* parser, tree logical_or_expr)\n   cp_lexer_consume_token (parser->lexer);\n   if (cp_parser_allow_gnu_extensions_p (parser)\n       && cp_lexer_next_token_is (parser->lexer, CPP_COLON))\n-    /* Implicit true clause.  */\n-    expr = NULL_TREE;\n+    {\n+      /* Implicit true clause.  */\n+      expr = NULL_TREE;\n+      c_inhibit_evaluation_warnings += logical_or_expr == truthvalue_true_node;\n+    }\n   else\n-    /* Parse the expression.  */\n-    expr = cp_parser_expression (parser, /*cast_p=*/false, NULL);\n+    {\n+      /* Parse the expression.  */\n+      c_inhibit_evaluation_warnings += logical_or_expr == truthvalue_false_node;\n+      expr = cp_parser_expression (parser, /*cast_p=*/false, NULL);\n+      c_inhibit_evaluation_warnings +=\n+\t((logical_or_expr == truthvalue_true_node)\n+\t - (logical_or_expr == truthvalue_false_node));\n+    }\n \n   /* The next token should be a `:'.  */\n   cp_parser_require (parser, CPP_COLON, \"%<:%>\");\n   /* Parse the assignment-expression.  */\n   assignment_expr = cp_parser_assignment_expression (parser, /*cast_p=*/false, NULL);\n+  c_inhibit_evaluation_warnings -= logical_or_expr == truthvalue_true_node;\n \n   /* Build the conditional-expression.  */\n   return build_x_conditional_expr (logical_or_expr,\n@@ -8857,7 +8871,10 @@ cp_parser_decltype (cp_parser *parser)\n   parser->integral_constant_expression_p = false;\n \n   /* Do not actually evaluate the expression.  */\n-  ++skip_evaluation;\n+  ++cp_unevaluated_operand;\n+\n+  /* Do not warn about problems with the expression.  */\n+  ++c_inhibit_evaluation_warnings;\n \n   /* Parse the opening `('.  */\n   if (!cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\"))\n@@ -8961,7 +8978,8 @@ cp_parser_decltype (cp_parser *parser)\n     }\n \n   /* Go back to evaluating expressions.  */\n-  --skip_evaluation;\n+  --cp_unevaluated_operand;\n+  --c_inhibit_evaluation_warnings;\n \n   /* Restore the old message and the integral constant expression\n      flags.  */\n@@ -18188,7 +18206,8 @@ cp_parser_enclosed_template_argument_list (cp_parser* parser)\n   tree saved_qualifying_scope;\n   tree saved_object_scope;\n   bool saved_greater_than_is_operator_p;\n-  bool saved_skip_evaluation;\n+  int saved_unevaluated_operand;\n+  int saved_inhibit_evaluation_warnings;\n \n   /* [temp.names]\n \n@@ -18205,8 +18224,10 @@ cp_parser_enclosed_template_argument_list (cp_parser* parser)\n   saved_object_scope = parser->object_scope;\n   /* We need to evaluate the template arguments, even though this\n      template-id may be nested within a \"sizeof\".  */\n-  saved_skip_evaluation = skip_evaluation;\n-  skip_evaluation = false;\n+  saved_unevaluated_operand = cp_unevaluated_operand;\n+  cp_unevaluated_operand = 0;\n+  saved_inhibit_evaluation_warnings = c_inhibit_evaluation_warnings;\n+  c_inhibit_evaluation_warnings = 0;\n   /* Parse the template-argument-list itself.  */\n   if (cp_lexer_next_token_is (parser->lexer, CPP_GREATER)\n       || cp_lexer_next_token_is (parser->lexer, CPP_RSHIFT))\n@@ -18273,7 +18294,8 @@ cp_parser_enclosed_template_argument_list (cp_parser* parser)\n   parser->scope = saved_scope;\n   parser->qualifying_scope = saved_qualifying_scope;\n   parser->object_scope = saved_object_scope;\n-  skip_evaluation = saved_skip_evaluation;\n+  cp_unevaluated_operand = saved_unevaluated_operand;\n+  c_inhibit_evaluation_warnings = saved_inhibit_evaluation_warnings;\n \n   return arguments;\n }\n@@ -18507,7 +18529,8 @@ cp_parser_sizeof_operand (cp_parser* parser, enum rid keyword)\n     }\n \n   /* Do not actually evaluate the expression.  */\n-  ++skip_evaluation;\n+  ++cp_unevaluated_operand;\n+  ++c_inhibit_evaluation_warnings;\n   /* If it's a `(', then we might be looking at the type-id\n      construction.  */\n   if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_PAREN))\n@@ -18556,7 +18579,8 @@ cp_parser_sizeof_operand (cp_parser* parser, enum rid keyword)\n     expr = make_pack_expansion (expr);\n \n   /* Go back to evaluating expressions.  */\n-  --skip_evaluation;\n+  --cp_unevaluated_operand;\n+  --c_inhibit_evaluation_warnings;\n \n   /* Free the message we created.  */\n   free (tmp);"}, {"sha": "5645b23e27f6f0bc23e785a6fbafcc585bbf446c", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 26, "deletions": 14, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d882b8356b9ee3e6844bf4898a996289223fab2/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d882b8356b9ee3e6844bf4898a996289223fab2/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=7d882b8356b9ee3e6844bf4898a996289223fab2", "patch": "@@ -5264,7 +5264,8 @@ coerce_template_parms (tree parms,\n   tree inner_args;\n   tree new_args;\n   tree new_inner_args;\n-  bool saved_skip_evaluation;\n+  int saved_unevaluated_operand;\n+  int saved_inhibit_evaluation_warnings;\n \n   /* When used as a boolean value, indicates whether this is a\n      variadic template parameter list. Since it's an int, we can also\n@@ -5322,8 +5323,10 @@ coerce_template_parms (tree parms,\n \n   /* We need to evaluate the template arguments, even though this\n      template-id may be nested within a \"sizeof\".  */\n-  saved_skip_evaluation = skip_evaluation;\n-  skip_evaluation = false;\n+  saved_unevaluated_operand = cp_unevaluated_operand;\n+  cp_unevaluated_operand = 0;\n+  saved_inhibit_evaluation_warnings = c_inhibit_evaluation_warnings;\n+  c_inhibit_evaluation_warnings = 0;\n   new_inner_args = make_tree_vec (nparms);\n   new_args = add_outermost_template_args (args, new_inner_args);\n   for (parm_idx = 0, arg_idx = 0; parm_idx < nparms; parm_idx++, arg_idx++)\n@@ -5416,7 +5419,8 @@ coerce_template_parms (tree parms,\n \tlost++;\n       TREE_VEC_ELT (new_inner_args, arg_idx) = arg;\n     }\n-  skip_evaluation = saved_skip_evaluation;\n+  cp_unevaluated_operand = saved_unevaluated_operand;\n+  c_inhibit_evaluation_warnings = saved_inhibit_evaluation_warnings;\n \n   if (lost)\n     return error_mark_node;\n@@ -7553,7 +7557,7 @@ tsubst_pack_expansion (tree t, tree args, tsubst_flags_t complain,\n \t      /* This can happen for a parameter name used later in a function\n \t\t declaration (such as in a late-specified return type).  Just\n \t\t make a dummy decl, since it's only used for its type.  */\n-\t      gcc_assert (skip_evaluation);\n+\t      gcc_assert (cp_unevaluated_operand != 0);\n \t      arg_pack = tsubst_decl (parm_pack, args, complain);\n \t      arg_pack = make_fnparm_pack (arg_pack);\n \t    }\n@@ -7944,11 +7948,14 @@ tsubst_aggr_type (tree t,\n \t  tree argvec;\n \t  tree context;\n \t  tree r;\n-\t  bool saved_skip_evaluation;\n+\t  int saved_unevaluated_operand;\n+\t  int saved_inhibit_evaluation_warnings;\n \n \t  /* In \"sizeof(X<I>)\" we need to evaluate \"I\".  */\n-\t  saved_skip_evaluation = skip_evaluation;\n-\t  skip_evaluation = false;\n+\t  saved_unevaluated_operand = cp_unevaluated_operand;\n+\t  cp_unevaluated_operand = 0;\n+\t  saved_inhibit_evaluation_warnings = c_inhibit_evaluation_warnings;\n+\t  c_inhibit_evaluation_warnings = 0;\n \n \t  /* First, determine the context for the type we are looking\n \t     up.  */\n@@ -7983,7 +7990,8 @@ tsubst_aggr_type (tree t,\n \t      r = cp_build_qualified_type_real (r, TYPE_QUALS (t), complain);\n \t    }\n \n-\t  skip_evaluation = saved_skip_evaluation;\n+\t  cp_unevaluated_operand = saved_unevaluated_operand;\n+\t  c_inhibit_evaluation_warnings = saved_inhibit_evaluation_warnings;\n \n \t  return r;\n \t}\n@@ -9782,13 +9790,15 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n       {\n \ttree type;\n \n-\t++skip_evaluation;\n+\t++cp_unevaluated_operand;\n+\t++c_inhibit_evaluation_warnings;\n \n \ttype = tsubst_expr (DECLTYPE_TYPE_EXPR (t), args,\n \t\t\t    complain, in_decl,\n \t\t\t    /*integral_constant_expression_p=*/false);\n \n-\t--skip_evaluation;\n+\t--cp_unevaluated_operand;\n+\t--c_inhibit_evaluation_warnings;\n \n \ttype =\n           finish_decltype_type (type,\n@@ -10047,7 +10057,7 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t  /* This can happen for a parameter name used later in a function\n \t     declaration (such as in a late-specified return type).  Just\n \t     make a dummy decl, since it's only used for its type.  */\n-\t  gcc_assert (skip_evaluation);\t  \n+\t  gcc_assert (cp_unevaluated_operand != 0);\n \t  /* We copy T because want to tsubst the PARM_DECL only,\n \t     not the following PARM_DECLs that are chained to T.  */\n \t  c = copy_node (t);\n@@ -11407,11 +11417,13 @@ tsubst_copy_and_build (tree t,\n \t}\n       else\n \t{\n-\t  ++skip_evaluation;\n+\t  ++cp_unevaluated_operand;\n+\t  ++c_inhibit_evaluation_warnings;\n \t  op1 = tsubst_copy_and_build (op1, args, complain, in_decl,\n \t\t\t\t       /*function_p=*/false,\n \t\t\t\t       /*integral_constant_expression_p=*/false);\n-\t  --skip_evaluation;\n+\t  --cp_unevaluated_operand;\n+\t  --c_inhibit_evaluation_warnings;\n \t}\n       if (TYPE_P (op1))\n \treturn cxx_sizeof_or_alignof_type (op1, TREE_CODE (t), "}, {"sha": "9a43863c6bbc33093445657fa1ce757ad42e36e2", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d882b8356b9ee3e6844bf4898a996289223fab2/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d882b8356b9ee3e6844bf4898a996289223fab2/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=7d882b8356b9ee3e6844bf4898a996289223fab2", "patch": "@@ -1423,7 +1423,7 @@ finish_non_static_data_member (tree decl, tree object, tree qualifying_scope)\n {\n   gcc_assert (TREE_CODE (decl) == FIELD_DECL);\n \n-  if (!object && skip_evaluation)\n+  if (!object && cp_unevaluated_operand != 0)\n     {\n       /* DR 613: Can use non-static data members without an associated\n          object in sizeof/decltype/alignof.  */"}, {"sha": "e3ed871f718f0a5b863615be31be0bc4d1cc736c", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d882b8356b9ee3e6844bf4898a996289223fab2/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d882b8356b9ee3e6844bf4898a996289223fab2/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=7d882b8356b9ee3e6844bf4898a996289223fab2", "patch": "@@ -2019,7 +2019,7 @@ build_class_member_access_expr (tree object, tree member,\n       if (null_object_p && warn_invalid_offsetof\n \t  && CLASSTYPE_NON_POD_P (object_type)\n \t  && !DECL_FIELD_IS_BASE (member)\n-\t  && !skip_evaluation\n+\t  && cp_unevaluated_operand == 0\n \t  && (complain & tf_warning))\n \t{\n \t  warning (OPT_Winvalid_offsetof, \n@@ -3559,13 +3559,15 @@ cp_build_binary_op (location_t location,\n \t    {\n \t      if (tree_int_cst_lt (op1, integer_zero_node))\n \t\t{\n-\t\t  if (complain & tf_warning)\n+\t\t  if ((complain & tf_warning)\n+\t\t      && c_inhibit_evaluation_warnings == 0)\n \t\t    warning (0, \"right shift count is negative\");\n \t\t}\n \t      else\n \t\t{\n \t\t  if (compare_tree_int (op1, TYPE_PRECISION (type0)) >= 0\n-\t\t      && (complain & tf_warning))\n+\t\t      && (complain & tf_warning)\n+\t\t      && c_inhibit_evaluation_warnings == 0)\n \t\t    warning (0, \"right shift count >= width of type\");\n \t\t}\n \t    }\n@@ -3586,12 +3588,14 @@ cp_build_binary_op (location_t location,\n \t    {\n \t      if (tree_int_cst_lt (op1, integer_zero_node))\n \t\t{\n-\t\t  if (complain & tf_warning)\n+\t\t  if ((complain & tf_warning)\n+\t\t      && c_inhibit_evaluation_warnings == 0)\n \t\t    warning (0, \"left shift count is negative\");\n \t\t}\n \t      else if (compare_tree_int (op1, TYPE_PRECISION (type0)) >= 0)\n \t\t{\n-\t\t  if (complain & tf_warning)\n+\t\t  if ((complain & tf_warning)\n+\t\t      && c_inhibit_evaluation_warnings == 0)\n \t\t    warning (0, \"left shift count >= width of type\");\n \t\t}\n \t    }"}, {"sha": "020d8a381892fb1a62498b0f5ed2f33eef0eca90", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d882b8356b9ee3e6844bf4898a996289223fab2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d882b8356b9ee3e6844bf4898a996289223fab2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7d882b8356b9ee3e6844bf4898a996289223fab2", "patch": "@@ -1,3 +1,7 @@\n+2009-06-16  Ian Lance Taylor  <iant@google.com>\n+\n+\t* g++.dg/warn/skip-1.C: New testcase.\n+\n 2009-06-16  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/40446"}, {"sha": "027c405d4625b2ac314cc1dbb23b5c76c859a0e6", "filename": "gcc/testsuite/g++.dg/warn/skip-1.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d882b8356b9ee3e6844bf4898a996289223fab2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fskip-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d882b8356b9ee3e6844bf4898a996289223fab2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fskip-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fskip-1.C?ref=7d882b8356b9ee3e6844bf4898a996289223fab2", "patch": "@@ -0,0 +1,17 @@\n+// { dg-do compile }\n+// { dg-options \"-Wall\" }\n+\n+// Check that we don't warn about code that will not be executed.\n+extern int f2(int);\n+void\n+f1(int i)\n+{\n+  f2(1 == 1 ? 0 : f2(i >> -10));\n+  f2(1 == 1 ? 0 : f2(i >> 128));\n+  f2(1 == 1 ? 0 : f2(i << -10));\n+  f2(1 == 1 ? 0 : f2(1 << 128));\n+  f2(1 != 1 ? f2(i >> -10) : 0);\n+  f2(1 != 1 ? f2(i >> 128) : 0);\n+  f2(1 != 1 ? f2(i << -10) : 0);\n+  f2(1 != 1 ? f2(1 << 128) : 0);\n+}"}]}