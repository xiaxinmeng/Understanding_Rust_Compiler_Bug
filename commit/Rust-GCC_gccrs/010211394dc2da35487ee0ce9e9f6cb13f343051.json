{"sha": "010211394dc2da35487ee0ce9e9f6cb13f343051", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDEwMjExMzk0ZGMyZGEzNTQ4N2VlMGNlOWU5ZjZjYjEzZjM0MzA1MQ==", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2018-11-27T21:21:51Z"}, "committer": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2018-11-27T21:21:51Z"}, "message": "re PR libstdc++/88199 (memory leak on unordered container move assignment)\n\n2018-11-27  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n\n\tPR libstdc++/88199\n\t* include/bits/hashtable.h (_Hashtable<>::_M_assign_elements): New.\n\t(_Hashtable<>::operator=(const _Hashtable&)): Use latter.\n\t(_Hashtable<>::_M_move_assign(_Hashtable&&, false_type)): Likewise.\n\t* testsuite/23_containers/unordered_set/allocator/move_assign.cc\n\t(test03): New.\n\nFrom-SVN: r266528", "tree": {"sha": "ac94886f1681f0af90312d40a7c7fb979eaf65ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ac94886f1681f0af90312d40a7c7fb979eaf65ae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/010211394dc2da35487ee0ce9e9f6cb13f343051", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/010211394dc2da35487ee0ce9e9f6cb13f343051", "html_url": "https://github.com/Rust-GCC/gccrs/commit/010211394dc2da35487ee0ce9e9f6cb13f343051", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/010211394dc2da35487ee0ce9e9f6cb13f343051/comments", "author": null, "committer": null, "parents": [{"sha": "d15a79696738d4f81b17774af7f7d7a80f429d5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d15a79696738d4f81b17774af7f7d7a80f429d5c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d15a79696738d4f81b17774af7f7d7a80f429d5c"}], "stats": {"total": 281, "additions": 169, "deletions": 112}, "files": [{"sha": "4de7cc8517496cfd9a69c519167448d492e01925", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/010211394dc2da35487ee0ce9e9f6cb13f343051/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/010211394dc2da35487ee0ce9e9f6cb13f343051/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=010211394dc2da35487ee0ce9e9f6cb13f343051", "patch": "@@ -1,3 +1,12 @@\n+2018-11-27  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n+\n+\tPR libstdc++/88199\n+\t* include/bits/hashtable.h (_Hashtable<>::_M_assign_elements): New.\n+\t(_Hashtable<>::operator=(const _Hashtable&)): Use latter.\n+\t(_Hashtable<>::_M_move_assign(_Hashtable&&, false_type)): Likewise.\n+\t* testsuite/23_containers/unordered_set/allocator/move_assign.cc\n+\t(test03): New.\n+\n 2018-11-26  Jonathan Wakely  <jwakely@redhat.com>\n \n \t* testsuite/26_numerics/complex/requirements/more_constexpr.cc: Fix\n@@ -20,7 +29,7 @@\n \tmore_constexpr.cc: New test.\n \t* testsuite/26_numerics/headers/complex/synopsis.cc:\n \tAdd _GLIBCXX20_CONSTEXPR to applicable operators; Add missing proj().\n-\t* testsuite/26_numerics/headers/complex/synopsis.cc: \n+\t* testsuite/26_numerics/headers/complex/synopsis.cc:\n \tAdd _GLIBCXX20_CONSTEXPR to relevant decls.\n \n 2018-11-23  Martin Sebor  <msebor@redhat.com>"}, {"sha": "f6912db3e69277b8d3d2292d4e3fd6e7ff2b93bc", "filename": "libstdc++-v3/include/bits/hashtable.h", "status": "modified", "additions": 64, "deletions": 78, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/010211394dc2da35487ee0ce9e9f6cb13f343051/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/010211394dc2da35487ee0ce9e9f6cb13f343051/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h?ref=010211394dc2da35487ee0ce9e9f6cb13f343051", "patch": "@@ -388,6 +388,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _M_begin() const\n       { return static_cast<__node_type*>(_M_before_begin._M_nxt); }\n \n+      // Assign *this using another _Hashtable instance. Either elements\n+      // are copy or move depends on the _NodeGenerator.\n+      template<typename _Ht, typename _NodeGenerator>\n+\tvoid\n+\t_M_assign_elements(_Ht&&, const _NodeGenerator&);\n+\n       template<typename _NodeGenerator>\n \tvoid\n \t_M_assign(const _Hashtable&, const _NodeGenerator&);\n@@ -1042,49 +1048,64 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t}\n \n       // Reuse allocated buckets and nodes.\n-      __bucket_type* __former_buckets = nullptr;\n-      std::size_t __former_bucket_count = _M_bucket_count;\n-      const __rehash_state& __former_state = _M_rehash_policy._M_state();\n+      _M_assign_elements(__ht,\n+\t[](const __reuse_or_alloc_node_type& __roan, const __node_type* __n)\n+\t{ return __roan(__n->_M_v()); });\n+      return *this;\n+    }\n \n-      if (_M_bucket_count != __ht._M_bucket_count)\n-\t{\n-\t  __former_buckets = _M_buckets;\n-\t  _M_buckets = _M_allocate_buckets(__ht._M_bucket_count);\n-\t  _M_bucket_count = __ht._M_bucket_count;\n-\t}\n-      else\n-\t__builtin_memset(_M_buckets, 0,\n-\t\t\t _M_bucket_count * sizeof(__bucket_type));\n+  template<typename _Key, typename _Value,\n+\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   typename _Traits>\n+    template<typename _Ht, typename _NodeGenerator>\n+      void\n+      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t\t _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n+      _M_assign_elements(_Ht&& __ht, const _NodeGenerator& __node_gen)\n+      {\n+\t__bucket_type* __former_buckets = nullptr;\n+\tstd::size_t __former_bucket_count = _M_bucket_count;\n+\tconst __rehash_state& __former_state = _M_rehash_policy._M_state();\n \n-      __try\n-\t{\n-\t  __hashtable_base::operator=(__ht);\n-\t  _M_element_count = __ht._M_element_count;\n-\t  _M_rehash_policy = __ht._M_rehash_policy;\n-\t  __reuse_or_alloc_node_type __roan(_M_begin(), *this);\n-\t  _M_before_begin._M_nxt = nullptr;\n-\t  _M_assign(__ht,\n-\t\t    [&__roan](const __node_type* __n)\n-\t\t    { return __roan(__n->_M_v()); });\n-\t  if (__former_buckets)\n-\t    _M_deallocate_buckets(__former_buckets, __former_bucket_count);\n-\t}\n-      __catch(...)\n-\t{\n-\t  if (__former_buckets)\n-\t    {\n-\t      // Restore previous buckets.\n-\t      _M_deallocate_buckets();\n-\t      _M_rehash_policy._M_reset(__former_state);\n-\t      _M_buckets = __former_buckets;\n-\t      _M_bucket_count = __former_bucket_count;\n-\t    }\n+\tif (_M_bucket_count != __ht._M_bucket_count)\n+\t  {\n+\t    __former_buckets = _M_buckets;\n+\t    _M_buckets = _M_allocate_buckets(__ht._M_bucket_count);\n+\t    _M_bucket_count = __ht._M_bucket_count;\n+\t  }\n+\telse\n \t  __builtin_memset(_M_buckets, 0,\n \t\t\t   _M_bucket_count * sizeof(__bucket_type));\n-\t  __throw_exception_again;\n-\t}\n-      return *this;\n-    }\n+\n+\t__try\n+\t  {\n+\t    __hashtable_base::operator=(std::forward<_Ht>(__ht));\n+\t    _M_element_count = __ht._M_element_count;\n+\t    _M_rehash_policy = __ht._M_rehash_policy;\n+\t    __reuse_or_alloc_node_type __roan(_M_begin(), *this);\n+\t    _M_before_begin._M_nxt = nullptr;\n+\t    _M_assign(__ht,\n+\t\t      [&__node_gen, &__roan](__node_type* __n)\n+\t\t      { return __node_gen(__roan, __n); });\n+\t    if (__former_buckets)\n+\t      _M_deallocate_buckets(__former_buckets, __former_bucket_count);\n+\t  }\n+\t__catch(...)\n+\t  {\n+\t    if (__former_buckets)\n+\t      {\n+\t\t// Restore previous buckets.\n+\t\t_M_deallocate_buckets();\n+\t\t_M_rehash_policy._M_reset(__former_state);\n+\t\t_M_buckets = __former_buckets;\n+\t\t_M_bucket_count = __former_bucket_count;\n+\t      }\n+\t    __builtin_memset(_M_buckets, 0,\n+\t\t\t     _M_bucket_count * sizeof(__bucket_type));\n+\t    __throw_exception_again;\n+\t  }\n+      }\n \n   template<typename _Key, typename _Value,\n \t   typename _Alloc, typename _ExtractKey, typename _Equal,\n@@ -1198,45 +1219,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       else\n \t{\n \t  // Can't move memory, move elements then.\n-\t  __bucket_type* __former_buckets = nullptr;\n-\t  size_type __former_bucket_count = _M_bucket_count;\n-\t  const __rehash_state& __former_state = _M_rehash_policy._M_state();\n-\n-\t  if (_M_bucket_count != __ht._M_bucket_count)\n-\t    {\n-\t      __former_buckets = _M_buckets;\n-\t      _M_buckets = _M_allocate_buckets(__ht._M_bucket_count);\n-\t      _M_bucket_count = __ht._M_bucket_count;\n-\t    }\n-\t  else\n-\t    __builtin_memset(_M_buckets, 0,\n-\t\t\t     _M_bucket_count * sizeof(__bucket_type));\n-\n-\t  __try\n-\t    {\n-\t      __hashtable_base::operator=(std::move(__ht));\n-\t      _M_element_count = __ht._M_element_count;\n-\t      _M_rehash_policy = __ht._M_rehash_policy;\n-\t      __reuse_or_alloc_node_type __roan(_M_begin(), *this);\n-\t      _M_before_begin._M_nxt = nullptr;\n-\t      _M_assign(__ht,\n-\t\t\t[&__roan](__node_type* __n)\n-\t\t\t{ return __roan(std::move_if_noexcept(__n->_M_v())); });\n-\t      __ht.clear();\n-\t    }\n-\t  __catch(...)\n-\t    {\n-\t      if (__former_buckets)\n-\t\t{\n-\t\t  _M_deallocate_buckets();\n-\t\t  _M_rehash_policy._M_reset(__former_state);\n-\t\t  _M_buckets = __former_buckets;\n-\t\t  _M_bucket_count = __former_bucket_count;\n-\t\t}\n-\t      __builtin_memset(_M_buckets, 0,\n-\t\t\t       _M_bucket_count * sizeof(__bucket_type));\n-\t      __throw_exception_again;\n-\t    }\n+\t  _M_assign_elements(std::move(__ht),\n+\t\t[](const __reuse_or_alloc_node_type& __roan, __node_type* __n)\n+\t\t{ return __roan(std::move_if_noexcept(__n->_M_v())); });\n+\t  __ht.clear();\n \t}\n     }\n "}, {"sha": "3a5538975812e853abe78f5d6080907eab362520", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/allocator/move_assign.cc", "status": "modified", "additions": 95, "deletions": 33, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/010211394dc2da35487ee0ce9e9f6cb13f343051/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fallocator%2Fmove_assign.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/010211394dc2da35487ee0ce9e9f6cb13f343051/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fallocator%2Fmove_assign.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fallocator%2Fmove_assign.cc?ref=010211394dc2da35487ee0ce9e9f6cb13f343051", "patch": "@@ -18,71 +18,133 @@\n // { dg-do run { target c++11 } }\n \n #include <unordered_set>\n+\n #include <testsuite_hooks.h>\n #include <testsuite_allocator.h>\n #include <testsuite_counter_type.h>\n \n using __gnu_test::propagating_allocator;\n using __gnu_test::counter_type;\n+using __gnu_test::tracker_allocator;\n+using __gnu_test::tracker_allocator_counter;\n \n void test01()\n {\n-  typedef propagating_allocator<counter_type, false> alloc_type;\n-  typedef __gnu_test::counter_type_hasher hash;\n-  typedef std::unordered_set<counter_type, hash,\n-\t\t\t     std::equal_to<counter_type>,\n-\t\t\t     alloc_type> test_type;\n+  tracker_allocator_counter::reset();\n+  {\n+    typedef propagating_allocator<counter_type, false,\n+\t\t\t\t  tracker_allocator<counter_type>> alloc_type;\n+    typedef __gnu_test::counter_type_hasher hash;\n+    typedef std::unordered_set<counter_type, hash,\n+\t\t\t       std::equal_to<counter_type>,\n+\t\t\t       alloc_type> test_type;\n+\n+    test_type v1(alloc_type(1));\n+    v1.emplace(0);\n \n-  test_type v1(alloc_type(1));\n-  v1.emplace(0);\n+    test_type v2(alloc_type(2));\n+    v2.emplace(1);\n \n-  test_type v2(alloc_type(2));\n-  v2.emplace(1);\n+    counter_type::reset();\n \n-  counter_type::reset();\n+    v2 = std::move(v1);\n \n-  v2 = std::move(v1);\n+    VERIFY( 1 == v1.get_allocator().get_personality() );\n+    VERIFY( 2 == v2.get_allocator().get_personality() );\n \n-  VERIFY( 1 == v1.get_allocator().get_personality() );\n-  VERIFY( 2 == v2.get_allocator().get_personality() );\n+    VERIFY( counter_type::move_count == 1  );\n+    VERIFY( counter_type::destructor_count == 2 );\n+  }\n \n-  VERIFY( counter_type::move_count == 1  );\n-  VERIFY( counter_type::destructor_count == 2 );\n+  // Check there's nothing left allocated or constructed.\n+  VERIFY( tracker_allocator_counter::get_construct_count()\n+\t  == tracker_allocator_counter::get_destruct_count() );\n+  VERIFY( tracker_allocator_counter::get_allocation_count()\n+\t  == tracker_allocator_counter::get_deallocation_count() );\n }\n \n void test02()\n {\n-  typedef propagating_allocator<counter_type, true> alloc_type;\n-  typedef __gnu_test::counter_type_hasher hash;\n-  typedef std::unordered_set<counter_type, hash,\n-\t\t\t     std::equal_to<counter_type>,\n-\t\t\t     alloc_type> test_type;\n+  tracker_allocator_counter::reset();\n+  {\n+    typedef propagating_allocator<counter_type, true,\n+\t\t\t\t  tracker_allocator<counter_type>> alloc_type;\n+    typedef __gnu_test::counter_type_hasher hash;\n+    typedef std::unordered_set<counter_type, hash,\n+\t\t\t       std::equal_to<counter_type>,\n+\t\t\t       alloc_type> test_type;\n+\n+    test_type v1(alloc_type(1));\n+    v1.emplace(0);\n \n-  test_type v1(alloc_type(1));\n-  v1.emplace(0);\n+    auto it = v1.begin();\n \n-  auto it = v1.begin();\n+    test_type v2(alloc_type(2));\n+    v2.emplace(0);\n \n-  test_type v2(alloc_type(2));\n-  v2.emplace(0);\n+    counter_type::reset();\n \n-  counter_type::reset();\n+    v2 = std::move(v1);\n \n-  v2 = std::move(v1);\n+    VERIFY(0 == v1.get_allocator().get_personality());\n+    VERIFY(1 == v2.get_allocator().get_personality());\n \n-  VERIFY(0 == v1.get_allocator().get_personality());\n-  VERIFY(1 == v2.get_allocator().get_personality());\n+    VERIFY( counter_type::move_count == 0 );\n+    VERIFY( counter_type::copy_count == 0 );\n+    VERIFY( counter_type::destructor_count == 1 );\n \n-  VERIFY( counter_type::move_count == 0 );\n-  VERIFY( counter_type::copy_count == 0 );\n-  VERIFY( counter_type::destructor_count == 1 );\n+    VERIFY( it == v2.begin() );\n+  }\n \n-  VERIFY( it == v2.begin() );\n+  // Check there's nothing left allocated or constructed.\n+  VERIFY( tracker_allocator_counter::get_construct_count()\n+\t  == tracker_allocator_counter::get_destruct_count() );\n+  VERIFY( tracker_allocator_counter::get_allocation_count()\n+\t  == tracker_allocator_counter::get_deallocation_count() );\n+}\n+\n+void test03()\n+{\n+  tracker_allocator_counter::reset();\n+  {\n+    typedef propagating_allocator<counter_type, false,\n+\t\t\t\t  tracker_allocator<counter_type>> alloc_type;\n+    typedef __gnu_test::counter_type_hasher hash;\n+    typedef std::unordered_set<counter_type, hash,\n+\t\t\t       std::equal_to<counter_type>,\n+\t\t\t       alloc_type> test_type;\n+\n+    test_type v1(alloc_type(1));\n+    v1.emplace(0);\n+\n+    test_type v2(alloc_type(2));\n+    int i = 0;\n+    v2.emplace(i++);\n+    for (; v2.bucket_count() == v1.bucket_count(); ++i)\n+      v2.emplace(i);\n+\n+    counter_type::reset();\n+\n+    v2 = std::move(v1);\n+\n+    VERIFY( 1 == v1.get_allocator().get_personality() );\n+    VERIFY( 2 == v2.get_allocator().get_personality() );\n+\n+    VERIFY( counter_type::move_count == 1  );\n+    VERIFY( counter_type::destructor_count == i + 1 );\n+  }\n+\n+  // Check there's nothing left allocated or constructed.\n+  VERIFY( tracker_allocator_counter::get_construct_count()\n+\t  == tracker_allocator_counter::get_destruct_count() );\n+  VERIFY( tracker_allocator_counter::get_allocation_count()\n+\t  == tracker_allocator_counter::get_deallocation_count() );\n }\n \n int main()\n {\n   test01();\n   test02();\n+  test03();\n   return 0;\n }"}]}