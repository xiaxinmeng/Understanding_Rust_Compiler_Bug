{"sha": "bc35512f0998b6cc547ef6466cd9865c1e927e44", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmMzNTUxMmYwOTk4YjZjYzU0N2VmNjQ2NmNkOTg2NWMxZTkyN2U0NA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2003-07-03T18:40:29Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2003-07-03T18:40:29Z"}, "message": "basic-block.h (create_basic_block, [...]): Kill.\n\n\t* basic-block.h (create_basic_block, merge_blocks_nomove): Kill.\n\t* cfgcleanup.c (merge_blocks): Rename to merge_blocks_move.\n\t(merge_blocks_move_predecessor_nojumps,\n\t merge_blocks_move_successor_nojumps): Use merge_blocks.\n\t(try_optimize_cfg): Use merge_blocks_move.\n\t* cfgrtl.c (create_basic_block): Rename to rtl_create_basic_block.\n\t(merge_blocks_nomove): Rename to rtl_merge_blocks.\n\t(cfg_layout_create_basic_block): New.\n\t(rtl_can_merge_blocks): New.\n\t(cfg_layout_split_block): Do not alloc aux by hand.\n\t* cfghooks.h (cfg_hooks): Add create_basic_block, can_merge_blocks_p,\n\tmerge_blocks.\n\t(create_basic_block, can_merge_blocks_p, merge_blocks): New macros.\n\t* cfglayout.c (cfg_layout_duplicate_bb): Do not allocate aux by hand.\n\t* cfgloopmanip.c (loop_split_edge_with): Likewise.\n\t* ifcvt.c (merge_if_block): Use merge_blocks_nomove.\n\n\t* basic-block.h (basic_block_def): Add field 'rbi'.\n\t* bb-reorder.c (find_traces, rotate_loop, mark_bb_visited,\n\tfind_traces_1_round, copy_bb, connect_traces): Update use of rbi.\n\t* cfg.c (entry_exit_blocks): Add new field.\n\t* cfglayout.c: Include alloc-pool.h;\n\t(cfg_layout_pool): New.\n\t(record_effective_endpoints, fixup_reorder_chain,\n\tfixup_fallthru_exit_predecessor, cfg_layout_duplicate_bb): Update use\n\tof rbi.\n\t(cfg_layout_initialize_rbi): New function.\n\t(cfg_layout_initialize): Use it.\n\t(cfg_layout_finalize): Clear rbi fields.\n\t* cfglayout.h (RBI): Kill.\n\t(cfg_layout_initialize_rbi): Declare.\n\t* cfgloopmanip.c (copy_bbs): Use rbi.\n\t(record_exit_edges): Likewise.\n\t(duplicate_loop_to_header_edge): Likewise.\n\t* cfgrtl.c (cfg_layout_create_basic_block): Use\n\tcfg_layout_initialize_rbi.\n\t(cfg_layout_split_block): Use rbi.\n\t(cfg_layout_delete_block): Likewise.\n\t* loop-init.c (loop_optimizer_finalize): Likewise.\n\t* loop-unswitch.c (unswitch_loop): Likewise.\n\t* tracer.c (seen, tail_duplicate, layout_superblocks): Likewise.\n\n\t* cfgrtl.c: Update comments.\n\t(try_redirect_by_replacing_jump): New argument.\n\t(redirect_branch_edge): Break out from ...\n\t(rtl_redirect_edge_and_branch): ... this one.\n\t(update_cfg_after_block_merging): Break out from ...\n\t(rtl_merge_blocks): ... this one.\n\t(cfg_layout_split_edge): New.\n\t(cfg_layout_merge_blocks): New.\n\t(cfg_layout_can_merge_blocks_p): New.\n\t(cfg_layout_redirect_edge_and_branch): Reorganize.\n\t(cfg_layout_rtl_cfg_hooks): Fill in.\n\t(cfg_layout_delete_block): Kill barriers.\n\t* cfganal.c (can_fallthru): Deal with exit blocks\n\t* cfglayout.c (cfg_layout_function_header): New function\n\t(record_effective_endpoints): Record function header.\n\t(fixup_reorder_chain): Fixup dead jumptables; place header\n\n\t* basic-block.h (CLEANUP_CFGLAYOUT): New flag.\n\t* bb-reorder.c (cfg_layout_initialize): Update call.\n\t* cfgcleanup.c (try_optimize_cfg): Supress optimizations of fallthru\n\tedges in cfglayout mode.\n\t* cfglayout.c (cleanup_unconditional_jumps): Kill.\n\t(cfg_layout_initialize): Kill agrument loops; use cfgcleanup.\n\t* cfglayout.h (cfg_layout_initialize): Update prototype.\n\t* cfgloop.h (CP_INSIDE_CFGLAYOUT): Kill.\n\t* cfgloopmanip.c (loop_split_edge_with): Use split_edge.\n\t* flow.c (propagate_block): Do not crash when basic block ends\n\tby first insn in the chain.\n\t* loop-init.c (loop_optimizer_init):  First enter cfglayout mode; later\n\tdo loop discovery.\n\t* tracer.c (tracer): Update call of cfg_layout_initialize.\n\nFrom-SVN: r68899", "tree": {"sha": "315cee76b1488868b1d0dacd4aee43ace2470db6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/315cee76b1488868b1d0dacd4aee43ace2470db6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bc35512f0998b6cc547ef6466cd9865c1e927e44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc35512f0998b6cc547ef6466cd9865c1e927e44", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc35512f0998b6cc547ef6466cd9865c1e927e44", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc35512f0998b6cc547ef6466cd9865c1e927e44/comments", "author": null, "committer": null, "parents": [{"sha": "9b269fc7bc405c83aa1af45680a9e07e35cf2395", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b269fc7bc405c83aa1af45680a9e07e35cf2395", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b269fc7bc405c83aa1af45680a9e07e35cf2395"}], "stats": {"total": 1006, "additions": 666, "deletions": 340}, "files": [{"sha": "77765f004daf2f7678c8a407f2ef5da80978401e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc35512f0998b6cc547ef6466cd9865c1e927e44/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc35512f0998b6cc547ef6466cd9865c1e927e44/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bc35512f0998b6cc547ef6466cd9865c1e927e44", "patch": "@@ -1,3 +1,79 @@\n+Thu Jul  3 20:36:47 CEST 2003  Jan Hubicka  <jh@suse.cz>\n+\n+\t* basic-block.h (create_basic_block, merge_blocks_nomove): Kill.\n+\t* cfgcleanup.c (merge_blocks): Rename to merge_blocks_move.\n+\t(merge_blocks_move_predecessor_nojumps,\n+\t merge_blocks_move_successor_nojumps): Use merge_blocks.\n+\t(try_optimize_cfg): Use merge_blocks_move.\n+\t* cfgrtl.c (create_basic_block): Rename to rtl_create_basic_block.\n+\t(merge_blocks_nomove): Rename to rtl_merge_blocks.\n+\t(cfg_layout_create_basic_block): New.\n+\t(rtl_can_merge_blocks): New.\n+\t(cfg_layout_split_block): Do not alloc aux by hand.\n+\t* cfghooks.h (cfg_hooks): Add create_basic_block, can_merge_blocks_p,\n+\tmerge_blocks.\n+\t(create_basic_block, can_merge_blocks_p, merge_blocks): New macros.\n+\t* cfglayout.c (cfg_layout_duplicate_bb): Do not allocate aux by hand.\n+\t* cfgloopmanip.c (loop_split_edge_with): Likewise.\n+\t* ifcvt.c (merge_if_block): Use merge_blocks_nomove.\n+\n+\t* basic-block.h (basic_block_def): Add field 'rbi'.\n+\t* bb-reorder.c (find_traces, rotate_loop, mark_bb_visited,\n+\tfind_traces_1_round, copy_bb, connect_traces): Update use of rbi.\n+\t* cfg.c (entry_exit_blocks): Add new field.\n+\t* cfglayout.c: Include alloc-pool.h;\n+\t(cfg_layout_pool): New.\n+\t(record_effective_endpoints, fixup_reorder_chain,\n+\tfixup_fallthru_exit_predecessor, cfg_layout_duplicate_bb): Update use\n+\tof rbi.\n+\t(cfg_layout_initialize_rbi): New function.\n+\t(cfg_layout_initialize): Use it.\n+\t(cfg_layout_finalize): Clear rbi fields.\n+\t* cfglayout.h (RBI): Kill.\n+\t(cfg_layout_initialize_rbi): Declare.\n+\t* cfgloopmanip.c (copy_bbs): Use rbi.\n+\t(record_exit_edges): Likewise.\n+\t(duplicate_loop_to_header_edge): Likewise.\n+\t* cfgrtl.c (cfg_layout_create_basic_block): Use\n+\tcfg_layout_initialize_rbi.\n+\t(cfg_layout_split_block): Use rbi.\n+\t(cfg_layout_delete_block): Likewise.\n+\t* loop-init.c (loop_optimizer_finalize): Likewise.\n+\t* loop-unswitch.c (unswitch_loop): Likewise.\n+\t* tracer.c (seen, tail_duplicate, layout_superblocks): Likewise.\n+\n+\t* cfgrtl.c: Update comments.\n+\t(try_redirect_by_replacing_jump): New argument.\n+\t(redirect_branch_edge): Break out from ...\n+\t(rtl_redirect_edge_and_branch): ... this one.\n+\t(update_cfg_after_block_merging): Break out from ...\n+\t(rtl_merge_blocks): ... this one.\n+\t(cfg_layout_split_edge): New.\n+\t(cfg_layout_merge_blocks): New.\n+\t(cfg_layout_can_merge_blocks_p): New.\n+\t(cfg_layout_redirect_edge_and_branch): Reorganize.\n+\t(cfg_layout_rtl_cfg_hooks): Fill in.\n+\t(cfg_layout_delete_block): Kill barriers.\n+\t* cfganal.c (can_fallthru): Deal with exit blocks\n+\t* cfglayout.c (cfg_layout_function_header): New function\n+\t(record_effective_endpoints): Record function header.\n+\t(fixup_reorder_chain): Fixup dead jumptables; place header\n+\n+\t* basic-block.h (CLEANUP_CFGLAYOUT): New flag.\n+\t* bb-reorder.c (cfg_layout_initialize): Update call.\n+\t* cfgcleanup.c (try_optimize_cfg): Supress optimizations of fallthru\n+\tedges in cfglayout mode.\n+\t* cfglayout.c (cleanup_unconditional_jumps): Kill.\n+\t(cfg_layout_initialize): Kill agrument loops; use cfgcleanup.\n+\t* cfglayout.h (cfg_layout_initialize): Update prototype.\n+\t* cfgloop.h (CP_INSIDE_CFGLAYOUT): Kill.\n+\t* cfgloopmanip.c (loop_split_edge_with): Use split_edge.\n+\t* flow.c (propagate_block): Do not crash when basic block ends\n+\tby first insn in the chain.\n+\t* loop-init.c (loop_optimizer_init):  First enter cfglayout mode; later\n+\tdo loop discovery.\n+\t* tracer.c (tracer): Update call of cfg_layout_initialize.\n+\n 2003-07-03  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* Makefile.in: Use dependency variables in lieu of explicit"}, {"sha": "cdefca3b22965ff190a92aa4eb7505bc6394a2a9", "filename": "gcc/basic-block.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc35512f0998b6cc547ef6466cd9865c1e927e44/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc35512f0998b6cc547ef6466cd9865c1e927e44/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=bc35512f0998b6cc547ef6466cd9865c1e927e44", "patch": "@@ -241,6 +241,9 @@ typedef struct basic_block_def {\n \n   /* Various flags.  See BB_* below.  */\n   int flags;\n+\n+  /* Additional data maintained by cfg_layout routines.  */\n+  struct reorder_block_def *rbi;\n } *basic_block;\n \n #define BB_FREQ_MAX 10000\n@@ -362,9 +365,7 @@ extern void redirect_edge_succ\t\tPARAMS ((edge, basic_block));\n extern edge redirect_edge_succ_nodup\tPARAMS ((edge, basic_block));\n extern void redirect_edge_pred\t\tPARAMS ((edge, basic_block));\n extern basic_block create_basic_block_structure PARAMS ((rtx, rtx, rtx, basic_block));\n-extern basic_block create_basic_block\tPARAMS ((rtx, rtx, basic_block));\n extern void clear_bb_flags\t\tPARAMS ((void));\n-extern void merge_blocks_nomove\t\tPARAMS ((basic_block, basic_block));\n extern void tidy_fallthru_edge\t\tPARAMS ((edge, basic_block,\n \t\t\t\t\t\t basic_block));\n extern void tidy_fallthru_edges\t\tPARAMS ((void));\n@@ -500,6 +501,7 @@ enum update_life_extent\n #define CLEANUP_THREADING\t64\t/* Do jump threading.  */\n #define CLEANUP_NO_INSN_DEL\t128\t/* Do not try to delete trivially dead\n \t\t\t\t\t   insns.  */\n+#define CLEANUP_CFGLAYOUT\t256\t/* Do cleanup in cfglayout mode.  */\n extern void life_analysis\tPARAMS ((rtx, FILE *, int));\n extern int update_life_info\tPARAMS ((sbitmap, enum update_life_extent,\n \t\t\t\t\t int));"}, {"sha": "e75958e8b748894dbd48c905a34f56a79328e7dc", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc35512f0998b6cc547ef6466cd9865c1e927e44/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc35512f0998b6cc547ef6466cd9865c1e927e44/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=bc35512f0998b6cc547ef6466cd9865c1e927e44", "patch": "@@ -205,7 +205,7 @@ find_traces (int *n_traces, struct trace *traces)\n \t  basic_block bb;\n \t  fprintf (rtl_dump_file, \"Trace %d (round %d):  \", i + 1,\n \t\t   traces[i].round + 1);\n-\t  for (bb = traces[i].first; bb != traces[i].last; bb = RBI (bb)->next)\n+\t  for (bb = traces[i].first; bb != traces[i].last; bb = bb->rbi->next)\n \t    fprintf (rtl_dump_file, \"%d [%d] \", bb->index, bb->frequency);\n \t  fprintf (rtl_dump_file, \"%d [%d]\\n\", bb->index, bb->frequency);\n \t}\n@@ -237,14 +237,14 @@ rotate_loop (edge back_edge, struct trace *trace, int trace_n)\n       edge e;\n       for (e = bb->succ; e; e = e->succ_next)\n \tif (e->dest != EXIT_BLOCK_PTR\n-\t    && RBI (e->dest)->visited != trace_n\n+\t    && e->dest->rbi->visited != trace_n\n \t    && (e->flags & EDGE_CAN_FALLTHRU)\n \t    && !(e->flags & EDGE_COMPLEX))\n \t{\n \t  if (is_preferred)\n \t    {\n \t      /* The best edge is preferred.  */\n-\t      if (!RBI (e->dest)->visited\n+\t      if (!e->dest->rbi->visited\n \t\t  || bbd[e->dest->index].start_of_trace >= 0)\n \t\t{\n \t\t  /* The current edge E is also preferred.  */\n@@ -260,7 +260,7 @@ rotate_loop (edge back_edge, struct trace *trace, int trace_n)\n \t    }\n \t  else\n \t    {\n-\t      if (!RBI (e->dest)->visited\n+\t      if (!e->dest->rbi->visited\n \t\t  || bbd[e->dest->index].start_of_trace >= 0)\n \t\t{\n \t\t  /* The current edge E is preferred.  */\n@@ -283,7 +283,7 @@ rotate_loop (edge back_edge, struct trace *trace, int trace_n)\n \t\t}\n \t    }\n \t}\n-      bb = RBI (bb)->next;\n+      bb = bb->rbi->next;\n     }\n   while (bb != back_edge->dest);\n \n@@ -293,17 +293,17 @@ rotate_loop (edge back_edge, struct trace *trace, int trace_n)\n \t the trace.  */\n       if (back_edge->dest == trace->first)\n \t{\n-\t  trace->first = RBI (best_bb)->next;\n+\t  trace->first = best_bb->rbi->next;\n \t}\n       else\n \t{\n \t  basic_block prev_bb;\n \n \t  for (prev_bb = trace->first;\n-\t       RBI (prev_bb)->next != back_edge->dest;\n-\t       prev_bb = RBI (prev_bb)->next)\n+\t       prev_bb->rbi->next != back_edge->dest;\n+\t       prev_bb = prev_bb->rbi->next)\n \t    ;\n-\t  RBI (prev_bb)->next = RBI (best_bb)->next;\n+\t  prev_bb->rbi->next = best_bb->rbi->next;\n \n \t  /* Try to get rid of uncond jump to cond jump.  */\n \t  if (prev_bb->succ && !prev_bb->succ->succ_next)\n@@ -324,7 +324,7 @@ rotate_loop (edge back_edge, struct trace *trace, int trace_n)\n       /* We have not found suitable loop tail so do no rotation.  */\n       best_bb = back_edge->src;\n     }\n-  RBI (best_bb)->next = NULL;\n+  best_bb->rbi->next = NULL;\n   return best_bb;\n }\n \n@@ -333,7 +333,7 @@ rotate_loop (edge back_edge, struct trace *trace, int trace_n)\n static void\n mark_bb_visited (basic_block bb, int trace)\n {\n-  RBI (bb)->visited = trace;\n+  bb->rbi->visited = trace;\n   if (bbd[bb->index].heap)\n     {\n       fibheap_delete_node (bbd[bb->index].heap, bbd[bb->index].node);\n@@ -420,8 +420,8 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t      if (e->dest == EXIT_BLOCK_PTR)\n \t\tcontinue;\n \n-\t      if (RBI (e->dest)->visited\n-\t\t  && RBI (e->dest)->visited != *n_traces)\n+\t      if (e->dest->rbi->visited\n+\t\t  && e->dest->rbi->visited != *n_traces)\n \t\tcontinue;\n \n \t      prob = e->probability;\n@@ -453,7 +453,7 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t    {\n \t      if (e == best_edge\n \t\t  || e->dest == EXIT_BLOCK_PTR\n-\t\t  || RBI (e->dest)->visited)\n+\t\t  || e->dest->rbi->visited)\n \t\tcontinue;\n \n \t      key = bb_to_key (e->dest);\n@@ -508,7 +508,7 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \n \t  if (best_edge) /* Suitable successor was found.  */\n \t    {\n-\t      if (RBI (best_edge->dest)->visited == *n_traces)\n+\t      if (best_edge->dest->rbi->visited == *n_traces)\n \t\t{\n \t\t  /* We do nothing with one basic block loops.  */\n \t\t  if (best_edge->dest != bb)\n@@ -528,7 +528,7 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t\t\t\t\t   \"Rotating loop %d - %d\\n\",\n \t\t\t\t\t   best_edge->dest->index, bb->index);\n \t\t\t\t}\n-\t\t\t      RBI (bb)->next = best_edge->dest;\n+\t\t\t      bb->rbi->next = best_edge->dest;\n \t\t\t      bb = rotate_loop (best_edge, trace, *n_traces);\n \t\t\t    }\n \t\t\t}\n@@ -583,7 +583,7 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t\t    if (e != best_edge\n \t\t\t&& (e->flags & EDGE_CAN_FALLTHRU)\n \t\t\t&& !(e->flags & EDGE_COMPLEX)\n-\t\t\t&& !RBI (e->dest)->visited\n+\t\t\t&& !e->dest->rbi->visited\n \t\t\t&& !e->dest->pred->pred_next\n \t\t\t&& e->dest->succ\n \t\t\t&& (e->dest->succ->flags & EDGE_CAN_FALLTHRU)\n@@ -599,7 +599,7 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t\t\tbreak;\n \t\t      }\n \n-\t\t  RBI (bb)->next = best_edge->dest;\n+\t\t  bb->rbi->next = best_edge->dest;\n \t\t  bb = best_edge->dest;\n \t\t}\n \t    }\n@@ -615,7 +615,7 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n       for (e = bb->succ; e; e = e->succ_next)\n \t{\n \t  if (e->dest == EXIT_BLOCK_PTR\n-\t      || RBI (e->dest)->visited)\n+\t      || e->dest->rbi->visited)\n \t    continue;\n \n \t  if (bbd[e->dest->index].heap)\n@@ -656,15 +656,15 @@ copy_bb (basic_block old_bb, edge e, basic_block bb, int trace)\n   new_bb = cfg_layout_duplicate_bb (old_bb, e);\n   if (e->dest != new_bb)\n     abort ();\n-  if (RBI (e->dest)->visited)\n+  if (e->dest->rbi->visited)\n     abort ();\n   if (rtl_dump_file)\n     fprintf (rtl_dump_file,\n \t     \"Duplicated bb %d (created bb %d)\\n\",\n \t     old_bb->index, new_bb->index);\n-  RBI (new_bb)->visited = trace;\n-  RBI (new_bb)->next = RBI (bb)->next;\n-  RBI (bb)->next = new_bb;\n+  new_bb->rbi->visited = trace;\n+  new_bb->rbi->next = bb->rbi->next;\n+  bb->rbi->next = new_bb;\n \n   if (new_bb->index >= array_size || last_basic_block > array_size)\n     {\n@@ -826,7 +826,7 @@ connect_traces (int n_traces, struct trace *traces)\n \t    }\n \t  if (best)\n \t    {\n-\t      RBI (best->src)->next = best->dest;\n+\t      best->src->rbi->next = best->dest;\n \t      t2 = bbd[best->src->index].end_of_trace;\n \t      connected[t2] = true;\n \t      if (rtl_dump_file)\n@@ -840,7 +840,7 @@ connect_traces (int n_traces, struct trace *traces)\n \t}\n \n       if (last_trace >= 0)\n-\tRBI (traces[last_trace].last)->next = traces[t2].first;\n+\ttraces[last_trace].last->rbi->next = traces[t2].first;\n       last_trace = t;\n \n       /* Find the successor traces.  */\n@@ -876,7 +876,7 @@ connect_traces (int n_traces, struct trace *traces)\n \t\t\t   best->src->index, best->dest->index);\n \t\t}\n \t      t = bbd[best->dest->index].start_of_trace;\n-\t      RBI (traces[last_trace].last)->next = traces[t].first;\n+\t      traces[last_trace].last->rbi->next = traces[t].first;\n \t      connected[t] = true;\n \t      last_trace = t;\n \t    }\n@@ -964,7 +964,7 @@ connect_traces (int n_traces, struct trace *traces)\n \t\t  if (next_bb && next_bb != EXIT_BLOCK_PTR)\n \t\t    {\n \t\t      t = bbd[next_bb->index].start_of_trace;\n-\t\t      RBI (traces[last_trace].last)->next = traces[t].first;\n+\t\t      traces[last_trace].last->rbi->next = traces[t].first;\n \t\t      connected[t] = true;\n \t\t      last_trace = t;\n \t\t    }\n@@ -982,7 +982,7 @@ connect_traces (int n_traces, struct trace *traces)\n       basic_block bb;\n \n       fprintf (rtl_dump_file, \"Final order:\\n\");\n-      for (bb = traces[0].first; bb; bb = RBI (bb)->next)\n+      for (bb = traces[0].first; bb; bb = bb->rbi->next)\n \tfprintf (rtl_dump_file, \"%d \", bb->index);\n       fprintf (rtl_dump_file, \"\\n\");\n       fflush (rtl_dump_file);\n@@ -1064,7 +1064,7 @@ reorder_basic_blocks (void)\n   if ((* targetm.cannot_modify_jumps_p) ())\n     return;\n \n-  cfg_layout_initialize (NULL);\n+  cfg_layout_initialize ();\n \n   set_edge_can_fallthru_flag ();\n   mark_dfs_back_edges ();"}, {"sha": "ced99a3909e962af76a686ac18c501fe6bf3f2d0", "filename": "gcc/cfg.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc35512f0998b6cc547ef6466cd9865c1e927e44/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc35512f0998b6cc547ef6466cd9865c1e927e44/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=bc35512f0998b6cc547ef6466cd9865c1e927e44", "patch": "@@ -113,7 +113,8 @@ struct basic_block_def entry_exit_blocks[2]\n     NULL,                       /* loop_father */\n     0,\t\t\t\t/* count */\n     0,\t\t\t\t/* frequency */\n-    0\t\t\t\t/* flags */\n+    0,\t\t\t\t/* flags */\n+    NULL\t\t\t/* rbi */\n   },\n   {\n     NULL,\t\t\t/* head */\n@@ -134,7 +135,8 @@ struct basic_block_def entry_exit_blocks[2]\n     NULL,                       /* loop_father */\n     0,\t\t\t\t/* count */\n     0,\t\t\t\t/* frequency */\n-    0\t\t\t\t/* flags */\n+    0,\t\t\t\t/* flags */\n+    NULL\t\t\t/* rbi */\n   }\n };\n "}, {"sha": "d3383c0646d2b122d51d3c85c73e06f554cb0b2a", "filename": "gcc/cfganal.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc35512f0998b6cc547ef6466cd9865c1e927e44/gcc%2Fcfganal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc35512f0998b6cc547ef6466cd9865c1e927e44/gcc%2Fcfganal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.c?ref=bc35512f0998b6cc547ef6466cd9865c1e927e44", "patch": "@@ -104,12 +104,12 @@ bool\n can_fallthru (basic_block src, basic_block target)\n {\n   rtx insn = src->end;\n-  rtx insn2 = target->head;\n+  rtx insn2 = target == EXIT_BLOCK_PTR ? NULL : target->head;\n \n   if (src->next_bb != target)\n     return 0;\n \n-  if (!active_insn_p (insn2))\n+  if (insn2 && !active_insn_p (insn2))\n     insn2 = next_active_insn (insn2);\n \n   /* ??? Later we may add code to move jump tables offline.  */"}, {"sha": "da874f7726891c4191f4f772499eecfef7991b88", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 47, "deletions": 20, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc35512f0998b6cc547ef6466cd9865c1e927e44/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc35512f0998b6cc547ef6466cd9865c1e927e44/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=bc35512f0998b6cc547ef6466cd9865c1e927e44", "patch": "@@ -77,7 +77,6 @@ static bool label_is_jump_target_p (rtx, rtx);\n static bool tail_recursion_label_p (rtx);\n static void merge_blocks_move_predecessor_nojumps (basic_block, basic_block);\n static void merge_blocks_move_successor_nojumps (basic_block, basic_block);\n-static basic_block merge_blocks (edge,basic_block,basic_block, int);\n static bool try_optimize_cfg (int);\n static bool try_simplify_condjump (basic_block);\n static bool try_forward_edges (int, basic_block);\n@@ -704,7 +703,7 @@ merge_blocks_move_predecessor_nojumps (basic_block a, basic_block b)\n   link_block (a, b->prev_bb);\n \n   /* Now blocks A and B are contiguous.  Merge them.  */\n-  merge_blocks_nomove (a, b);\n+  merge_blocks (a, b);\n }\n \n /* Blocks A and B are to be merged into a single block.  B has no outgoing\n@@ -758,7 +757,7 @@ merge_blocks_move_successor_nojumps (basic_block a, basic_block b)\n \t     b->index, a->index);\n \n   /* Now blocks A and B are contiguous.  Merge them.  */\n-  merge_blocks_nomove (a, b);\n+  merge_blocks (a, b);\n }\n \n /* Attempt to merge basic blocks that are potentially non-adjacent.\n@@ -774,7 +773,7 @@ merge_blocks_move_successor_nojumps (basic_block a, basic_block b)\n    relative ordering of these two.  Hopefully it is not too common.  */\n \n static basic_block\n-merge_blocks (edge e, basic_block b, basic_block c, int mode)\n+merge_blocks_move (edge e, basic_block b, basic_block c, int mode)\n {\n   basic_block next;\n   /* If C has a tail recursion label, do not merge.  There is no\n@@ -790,7 +789,7 @@ merge_blocks (edge e, basic_block b, basic_block c, int mode)\n   if (e->flags & EDGE_FALLTHRU)\n     {\n       int b_index = b->index, c_index = c->index;\n-      merge_blocks_nomove (b, c);\n+      merge_blocks (b, c);\n       update_forwarder_flag (b);\n \n       if (rtl_dump_file)\n@@ -1686,7 +1685,8 @@ try_optimize_cfg (int mode)\n \t\t\t     b->index);\n \n \t\t  delete_block (b);\n-\t\t  changed = true;\n+\t\t  if (!(mode & CLEANUP_CFGLAYOUT))\n+\t\t    changed = true;\n \t\t  b = c;\n \t\t}\n \n@@ -1712,15 +1712,24 @@ try_optimize_cfg (int mode)\n \t\t{\n \t\t  rtx label = b->head;\n \n-\t\t  b->head = NEXT_INSN (b->head);\n \t\t  delete_insn_chain (label, label);\n+\t\t  /* In the case label is undeletable, move it after the\n+\t\t     BASIC_BLOCK note.  */\n+\t\t  if (NOTE_LINE_NUMBER (b->head) == NOTE_INSN_DELETED_LABEL)\n+\t\t    {\n+\t\t      rtx bb_note = NEXT_INSN (b->head);\n+\n+\t\t      reorder_insns_nobb (label, label, bb_note);\n+\t\t      b->head = bb_note;\n+\t\t    }\n \t\t  if (rtl_dump_file)\n \t\t    fprintf (rtl_dump_file, \"Deleted label in block %i.\\n\",\n \t\t\t     b->index);\n \t\t}\n \n \t      /* If we fall through an empty block, we can remove it.  */\n-\t      if (b->pred->pred_next == NULL\n+\t      if (!(mode & CLEANUP_CFGLAYOUT)\n+\t\t  && b->pred->pred_next == NULL\n \t\t  && (b->pred->flags & EDGE_FALLTHRU)\n \t\t  && GET_CODE (b->head) != CODE_LABEL\n \t\t  && FORWARDER_BLOCK_P (b)\n@@ -1746,21 +1755,39 @@ try_optimize_cfg (int mode)\n \t\t  && !(s->flags & EDGE_COMPLEX)\n \t\t  && (c = s->dest) != EXIT_BLOCK_PTR\n \t\t  && c->pred->pred_next == NULL\n-\t\t  && b != c\n-\t\t  /* If the jump insn has side effects,\n-\t\t     we can't kill the edge.  */\n-\t\t  && (GET_CODE (b->end) != JUMP_INSN\n-\t\t      || (flow2_completed\n-\t\t\t  ? simplejump_p (b->end)\n-\t\t\t  : onlyjump_p (b->end)))\n-\t\t  && (next = merge_blocks (s, b, c, mode)))\n-\t        {\n-\t\t  b = next;\n-\t\t  changed_here = true;\n+\t\t  && b != c)\n+\t\t{\n+\t\t  /* When not in cfg_layout mode use code aware of reordering\n+\t\t     INSN.  This code possibly creates new basic blocks so it\n+\t\t     does not fit merge_blocks interface and is kept here in\n+\t\t     hope that it will become useless once more of compiler\n+\t\t     is transformed to use cfg_layout mode.  */\n+\t\t     \n+\t\t  if ((mode & CLEANUP_CFGLAYOUT)\n+\t\t      && can_merge_blocks_p (b, c))\n+\t\t    {\n+\t\t      merge_blocks (b, c);\n+\t\t      update_forwarder_flag (b);\n+\t\t      changed_here = true;\n+\t\t    }\n+\t\t  else if (!(mode & CLEANUP_CFGLAYOUT)\n+\t\t\t   /* If the jump insn has side effects,\n+\t\t\t      we can't kill the edge.  */\n+\t\t\t   && (GET_CODE (b->end) != JUMP_INSN\n+\t\t\t       || (flow2_completed\n+\t\t\t\t   ? simplejump_p (b->end)\n+\t\t\t\t   : onlyjump_p (b->end)))\n+\t\t\t   && (next = merge_blocks_move (s, b, c, mode)))\n+\t\t      {\n+\t\t\tb = next;\n+\t\t\tchanged_here = true;\n+\t\t      }\n \t\t}\n \n \t      /* Simplify branch over branch.  */\n-\t      if ((mode & CLEANUP_EXPENSIVE) && try_simplify_condjump (b))\n+\t      if ((mode & CLEANUP_EXPENSIVE)\n+\t\t   && !(mode & CLEANUP_CFGLAYOUT)\n+\t\t   && try_simplify_condjump (b))\n \t\tchanged_here = true;\n \n \t      /* If B has a single outgoing edge, but uses a"}, {"sha": "a44a208a33722915969790c8295bb83b32b769f9", "filename": "gcc/cfghooks.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc35512f0998b6cc547ef6466cd9865c1e927e44/gcc%2Fcfghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc35512f0998b6cc547ef6466cd9865c1e927e44/gcc%2Fcfghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.h?ref=bc35512f0998b6cc547ef6466cd9865c1e927e44", "patch": "@@ -31,6 +31,9 @@ struct cfg_hooks\n \n   /* Basic CFG manipulation.  */\n \n+  /* Return new basic block */\n+  basic_block (*create_basic_block)\tPARAMS ((void *head, void *end, basic_block after));\n+\n   /* Redirect edge E to the given basic block B and update underlying program\n      representation.  Returns false when edge is not easily redirectable for\n      whatever reason.  */\n@@ -47,6 +50,12 @@ struct cfg_hooks\n   /* Split basic block B after specified instruction I.  */\n   edge (*split_block) (basic_block b, void * i);\n \n+  /* Return true when blocks A and B can be merged into single basic block.  */\n+  bool (*can_merge_blocks_p)\t\tPARAMS ((basic_block a, basic_block b));\n+\n+  /* Merge blocks A and B.  */\n+  void (*merge_blocks)\t\t\tPARAMS ((basic_block a, basic_block b));\n+\n   /* Higher level functions representable by primitive operations above if\n      we didn't have some oddities in RTL and Tree representations.  */\n   basic_block (*cfgh_split_edge) (edge);\n@@ -57,6 +66,9 @@ struct cfg_hooks\n #define split_block(e,i)                     cfg_hooks->split_block (e,i)\n #define delete_block(b)\t\t\t     cfg_hooks->delete_block (b)\n #define split_edge(e)                        cfg_hooks->cfgh_split_edge (e)\n+#define create_basic_block(h,e,a)            cfg_hooks->create_basic_block (h,e,a)\n+#define can_merge_blocks_p(a,b)\t\t     cfg_hooks->can_merge_blocks_p (a,b)\n+#define merge_blocks(a,b)\t\t     cfg_hooks->merge_blocks (a,b)\n \n /* Hooks containers.  */\n extern struct cfg_hooks rtl_cfg_hooks;"}, {"sha": "a576f0e12690a5ee9c14b81454877a2ce5beb80f", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 112, "deletions": 134, "changes": 246, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc35512f0998b6cc547ef6466cd9865c1e927e44/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc35512f0998b6cc547ef6466cd9865c1e927e44/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=bc35512f0998b6cc547ef6466cd9865c1e927e44", "patch": "@@ -34,13 +34,16 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"cfgloop.h\"\n #include \"target.h\"\n #include \"ggc.h\"\n+#include \"alloc-pool.h\"\n \n /* The contents of the current function definition are allocated\n    in this obstack, and all are freed at the end of the function.  */\n extern struct obstack flow_obstack;\n \n+alloc_pool cfg_layout_pool;\n+\n /* Holds the interesting trailing notes for the function.  */\n-rtx cfg_layout_function_footer;\n+rtx cfg_layout_function_footer, cfg_layout_function_header;\n \n static rtx skip_insns_after_block (basic_block);\n static void record_effective_endpoints (void);\n@@ -51,7 +54,6 @@ static void set_block_levels (tree, int);\n static void change_scope (rtx, tree, tree);\n \n void verify_insn_chain (void);\n-static void cleanup_unconditional_jumps (struct loops *);\n static void fixup_fallthru_exit_predecessor (void);\n static rtx duplicate_insn_chain (rtx, rtx);\n static void break_superblocks (void);\n@@ -189,19 +191,38 @@ label_for_bb (basic_block bb)\n static void\n record_effective_endpoints (void)\n {\n-  rtx next_insn = get_insns ();\n+  rtx next_insn;\n   basic_block bb;\n+  rtx insn;\n+\n+  for (insn = get_insns ();\n+       NEXT_INSN (insn) && GET_CODE (insn) == NOTE;\n+       insn = NEXT_INSN (insn))\n+    {\n+      if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BASIC_BLOCK)\n+\t{\n+\t  insn = NULL;\n+\t  break;\n+\t }\n+      if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_FUNCTION_BEG)\n+\tbreak;\n+    }\n+  if (insn)\n+    cfg_layout_function_header = unlink_insn_chain (get_insns (), insn);\n+  else\n+    cfg_layout_function_header = NULL_RTX;\n \n+  next_insn = get_insns ();\n   FOR_EACH_BB (bb)\n     {\n       rtx end;\n \n       if (PREV_INSN (bb->head) && next_insn != bb->head)\n-\tRBI (bb)->header = unlink_insn_chain (next_insn,\n+\tbb->rbi->header = unlink_insn_chain (next_insn,\n \t\t\t\t\t      PREV_INSN (bb->head));\n       end = skip_insns_after_block (bb);\n       if (NEXT_INSN (bb->end) && bb->end != end)\n-\tRBI (bb)->footer = unlink_insn_chain (NEXT_INSN (bb->end), end);\n+\tbb->rbi->footer = unlink_insn_chain (NEXT_INSN (bb->end), end);\n       next_insn = NEXT_INSN (bb->end);\n     }\n \n@@ -529,21 +550,29 @@ fixup_reorder_chain (void)\n   int index;\n   rtx insn = NULL;\n \n+  if (cfg_layout_function_header)\n+    {\n+      set_first_insn (cfg_layout_function_header);\n+      insn = cfg_layout_function_header;\n+      while (NEXT_INSN (insn))\n+\tinsn = NEXT_INSN (insn);\n+    }\n+\n   /* First do the bulk reordering -- rechain the blocks without regard to\n      the needed changes to jumps and labels.  */\n \n   for (bb = ENTRY_BLOCK_PTR->next_bb, index = 0;\n        bb != 0;\n-       bb = RBI (bb)->next, index++)\n+       bb = bb->rbi->next, index++)\n     {\n-      if (RBI (bb)->header)\n+      if (bb->rbi->header)\n \t{\n \t  if (insn)\n-\t    NEXT_INSN (insn) = RBI (bb)->header;\n+\t    NEXT_INSN (insn) = bb->rbi->header;\n \t  else\n-\t    set_first_insn (RBI (bb)->header);\n-\t  PREV_INSN (RBI (bb)->header) = insn;\n-\t  insn = RBI (bb)->header;\n+\t    set_first_insn (bb->rbi->header);\n+\t  PREV_INSN (bb->rbi->header) = insn;\n+\t  insn = bb->rbi->header;\n \t  while (NEXT_INSN (insn))\n \t    insn = NEXT_INSN (insn);\n \t}\n@@ -553,10 +582,10 @@ fixup_reorder_chain (void)\n \tset_first_insn (bb->head);\n       PREV_INSN (bb->head) = insn;\n       insn = bb->end;\n-      if (RBI (bb)->footer)\n+      if (bb->rbi->footer)\n \t{\n-\t  NEXT_INSN (insn) = RBI (bb)->footer;\n-\t  PREV_INSN (RBI (bb)->footer) = insn;\n+\t  NEXT_INSN (insn) = bb->rbi->footer;\n+\t  PREV_INSN (bb->rbi->footer) = insn;\n \t  while (NEXT_INSN (insn))\n \t    insn = NEXT_INSN (insn);\n \t}\n@@ -580,7 +609,7 @@ fixup_reorder_chain (void)\n   /* Now add jumps and labels as needed to match the blocks new\n      outgoing edges.  */\n \n-  for (bb = ENTRY_BLOCK_PTR->next_bb; bb ; bb = RBI (bb)->next)\n+  for (bb = ENTRY_BLOCK_PTR->next_bb; bb ; bb = bb->rbi->next)\n     {\n       edge e_fall, e_taken, e;\n       rtx bb_end_insn;\n@@ -604,8 +633,8 @@ fixup_reorder_chain (void)\n \t  if (any_condjump_p (bb_end_insn))\n \t    {\n \t      /* If the old fallthru is still next, nothing to do.  */\n-\t      if (RBI (bb)->next == e_fall->dest\n-\t          || (!RBI (bb)->next\n+\t      if (bb->rbi->next == e_fall->dest\n+\t          || (!bb->rbi->next\n \t\t      && e_fall->dest == EXIT_BLOCK_PTR))\n \t\tcontinue;\n \n@@ -645,7 +674,7 @@ fixup_reorder_chain (void)\n \t\t such as happens at the very end of a function, then we'll\n \t\t need to add a new unconditional jump.  Choose the taken\n \t\t edge based on known or assumed probability.  */\n-\t      else if (RBI (bb)->next != e_taken->dest)\n+\t      else if (bb->rbi->next != e_taken->dest)\n \t\t{\n \t\t  rtx note = find_reg_note (bb_end_insn, REG_BR_PROB, 0);\n \n@@ -684,7 +713,7 @@ fixup_reorder_chain (void)\n #ifdef CASE_DROPS_THROUGH\n \t      /* Except for VAX.  Since we didn't have predication for the\n \t\t tablejump, the fallthru block should not have moved.  */\n-\t      if (RBI (bb)->next == e_fall->dest)\n+\t      if (bb->rbi->next == e_fall->dest)\n \t\tcontinue;\n \t      bb_end_insn = skip_insns_after_block (bb);\n #else\n@@ -701,22 +730,22 @@ fixup_reorder_chain (void)\n \t    continue;\n \n \t  /* If the fallthru block is still next, nothing to do.  */\n-\t  if (RBI (bb)->next == e_fall->dest)\n+\t  if (bb->rbi->next == e_fall->dest)\n \t    continue;\n \n \t  /* A fallthru to exit block.  */\n-\t  if (!RBI (bb)->next && e_fall->dest == EXIT_BLOCK_PTR)\n+\t  if (!bb->rbi->next && e_fall->dest == EXIT_BLOCK_PTR)\n \t    continue;\n \t}\n \n       /* We got here if we need to add a new jump insn.  */\n       nb = force_nonfallthru (e_fall);\n       if (nb)\n \t{\n-\t  alloc_aux_for_block (nb, sizeof (struct reorder_block_def));\n-\t  RBI (nb)->visited = 1;\n-\t  RBI (nb)->next = RBI (bb)->next;\n-\t  RBI (bb)->next = nb;\n+\t  cfg_layout_initialize_rbi (nb);\n+\t  nb->rbi->visited = 1;\n+\t  nb->rbi->next = bb->rbi->next;\n+\t  bb->rbi->next = nb;\n \t  /* Don't process this new block.  */\n \t  bb = nb;\n \t}\n@@ -727,12 +756,12 @@ fixup_reorder_chain (void)\n   if (rtl_dump_file)\n     {\n       fprintf (rtl_dump_file, \"Reordered sequence:\\n\");\n-      for (bb = ENTRY_BLOCK_PTR->next_bb, index = 0; bb; bb = RBI (bb)->next, index ++)\n+      for (bb = ENTRY_BLOCK_PTR->next_bb, index = 0; bb; bb = bb->rbi->next, index ++)\n \t{\n \t  fprintf (rtl_dump_file, \" %i \", index);\n-\t  if (RBI (bb)->original)\n+\t  if (bb->rbi->original)\n \t    fprintf (rtl_dump_file, \"duplicate of %i \",\n-\t\t     RBI (bb)->original->index);\n+\t\t     bb->rbi->original->index);\n \t  else if (forwarder_block_p (bb) && GET_CODE (bb->head) != CODE_LABEL)\n \t    fprintf (rtl_dump_file, \"compensation \");\n \t  else\n@@ -745,7 +774,7 @@ fixup_reorder_chain (void)\n   bb = ENTRY_BLOCK_PTR->next_bb;\n   index = 0;\n \n-  for (; bb; prev_bb = bb, bb = RBI (bb)->next, index ++)\n+  for (; bb; prev_bb = bb, bb = bb->rbi->next, index ++)\n     {\n       bb->index = index;\n       BASIC_BLOCK (index) = bb;\n@@ -755,6 +784,16 @@ fixup_reorder_chain (void)\n     }\n   prev_bb->next_bb = EXIT_BLOCK_PTR;\n   EXIT_BLOCK_PTR->prev_bb = prev_bb;\n+\n+  /* Anoying special case - jump around dead jumptables left in the code.  */\n+  FOR_EACH_BB (bb)\n+    {\n+      edge e;\n+      for (e = bb->succ; e && !(e->flags & EDGE_FALLTHRU); e = e->succ_next)\n+\tcontinue;\n+      if (e && !can_fallthru (e->src, e->dest))\n+\tforce_nonfallthru (e);\n+    }\n }\n \f\n /* Perform sanity checks on the insn chain.\n@@ -788,87 +827,6 @@ verify_insn_chain (void)\n     abort ();\n }\n \f\n-/* Remove any unconditional jumps and forwarder block creating fallthru\n-   edges instead.  During BB reordering, fallthru edges are not required\n-   to target next basic block in the linear CFG layout, so the unconditional\n-   jumps are not needed.  If LOOPS is not null, also update loop structure &\n-   dominators.  */\n-\n-static void\n-cleanup_unconditional_jumps (struct loops *loops)\n-{\n-  basic_block bb;\n-\n-  FOR_EACH_BB (bb)\n-    {\n-      if (!bb->succ)\n-\tcontinue;\n-      if (bb->succ->flags & EDGE_FALLTHRU)\n-\tcontinue;\n-      if (!bb->succ->succ_next)\n-\t{\n-\t  rtx insn;\n-\t  if (GET_CODE (bb->head) != CODE_LABEL && forwarder_block_p (bb)\n-\t      && bb->prev_bb != ENTRY_BLOCK_PTR)\n-\t    {\n-\t      basic_block prev = bb->prev_bb;\n-\n-\t      if (rtl_dump_file)\n-\t\tfprintf (rtl_dump_file, \"Removing forwarder BB %i\\n\",\n-\t\t\t bb->index);\n-\n-\t      if (loops)\n-\t\t{\n-\t\t  /* bb cannot be loop header, as it only has one entry\n-\t\t     edge.  It could be a loop latch.  */\n-\t\t  if (bb->loop_father->header == bb)\n-\t\t    abort ();\n-\n-\t\t  if (bb->loop_father->latch == bb)\n-\t\t    bb->loop_father->latch = bb->pred->src;\n-\n-\t\t  if (get_immediate_dominator\n-\t\t      (loops->cfg.dom, bb->succ->dest) == bb)\n-\t\t    set_immediate_dominator\n-\t\t      (loops->cfg.dom, bb->succ->dest, bb->pred->src);\n-\n-\t\t  remove_bb_from_loops (bb);\n-\t\t  delete_from_dominance_info (loops->cfg.dom, bb);\n-\t\t}\n-\n-\t      redirect_edge_succ_nodup (bb->pred, bb->succ->dest);\n-\t      delete_block (bb);\n-\t      bb = prev;\n-\t    }\n-\t  else if (simplejump_p (bb->end))\n-\t    {\n-\t      rtx jump = bb->end;\n-\n-\t      if (rtl_dump_file)\n-\t\tfprintf (rtl_dump_file, \"Removing jump %i in BB %i\\n\",\n-\t\t\t INSN_UID (jump), bb->index);\n-\t      delete_insn (jump);\n-\t      bb->succ->flags |= EDGE_FALLTHRU;\n-\t    }\n-\t  else\n-\t    continue;\n-\n-\t  insn = NEXT_INSN (bb->end);\n-\t  while (insn\n-\t\t && (GET_CODE (insn) != NOTE\n-\t\t     || NOTE_LINE_NUMBER (insn) != NOTE_INSN_BASIC_BLOCK))\n-\t    {\n-\t      rtx next = NEXT_INSN (insn);\n-\n-\t      if (GET_CODE (insn) == BARRIER)\n-\t\tdelete_barrier (insn);\n-\n-\t      insn = next;\n-\t    }\n-\t}\n-    }\n-}\n-\f\n /* The block falling through to exit must be the last one in the\n    reordered chain.  Ensure that this condition is met.  */\n static void\n@@ -881,19 +839,19 @@ fixup_fallthru_exit_predecessor (void)\n     if (e->flags & EDGE_FALLTHRU)\n       bb = e->src;\n \n-  if (bb && RBI (bb)->next)\n+  if (bb && bb->rbi->next)\n     {\n       basic_block c = ENTRY_BLOCK_PTR->next_bb;\n \n-      while (RBI (c)->next != bb)\n-\tc = RBI (c)->next;\n+      while (c->rbi->next != bb)\n+\tc = c->rbi->next;\n \n-      RBI (c)->next = RBI (bb)->next;\n-      while (RBI (c)->next)\n-\tc = RBI (c)->next;\n+      c->rbi->next = bb->rbi->next;\n+      while (c->rbi->next)\n+\tc = c->rbi->next;\n \n-      RBI (c)->next = bb;\n-      RBI (bb)->next = NULL;\n+      c->rbi->next = bb;\n+      bb->rbi->next = NULL;\n     }\n }\n \f\n@@ -1050,26 +1008,25 @@ cfg_layout_duplicate_bb (basic_block bb, edge e)\n   new_bb = create_basic_block (insn,\n \t\t\t       insn ? get_last_insn () : NULL,\n \t\t\t       EXIT_BLOCK_PTR->prev_bb);\n-  alloc_aux_for_block (new_bb, sizeof (struct reorder_block_def));\n \n-  if (RBI (bb)->header)\n+  if (bb->rbi->header)\n     {\n-      insn = RBI (bb)->header;\n+      insn = bb->rbi->header;\n       while (NEXT_INSN (insn))\n \tinsn = NEXT_INSN (insn);\n-      insn = duplicate_insn_chain (RBI (bb)->header, insn);\n+      insn = duplicate_insn_chain (bb->rbi->header, insn);\n       if (insn)\n-\tRBI (new_bb)->header = unlink_insn_chain (insn, get_last_insn ());\n+\tnew_bb->rbi->header = unlink_insn_chain (insn, get_last_insn ());\n     }\n \n-  if (RBI (bb)->footer)\n+  if (bb->rbi->footer)\n     {\n-      insn = RBI (bb)->footer;\n+      insn = bb->rbi->footer;\n       while (NEXT_INSN (insn))\n \tinsn = NEXT_INSN (insn);\n-      insn = duplicate_insn_chain (RBI (bb)->footer, insn);\n+      insn = duplicate_insn_chain (bb->rbi->footer, insn);\n       if (insn)\n-\tRBI (new_bb)->footer = unlink_insn_chain (insn, get_last_insn ());\n+\tnew_bb->rbi->footer = unlink_insn_chain (insn, get_last_insn ());\n     }\n \n   if (bb->global_live_at_start)\n@@ -1113,25 +1070,42 @@ cfg_layout_duplicate_bb (basic_block bb, edge e)\n   if (bb->frequency < 0)\n     bb->frequency = 0;\n \n-  RBI (new_bb)->original = bb;\n-  RBI (bb)->copy = new_bb;\n+  new_bb->rbi->original = bb;\n+  bb->rbi->copy = new_bb;\n   return new_bb;\n }\n \f\n+void\n+cfg_layout_initialize_rbi (bb)\n+     basic_block bb;\n+{\n+  if (bb->rbi)\n+    abort ();\n+  bb->rbi = pool_alloc (cfg_layout_pool);\n+  memset (bb->rbi, 0, sizeof (struct reorder_block_def));\n+}\n+\f\n /* Main entry point to this module - initialize the datastructures for\n    CFG layout changes.  It keeps LOOPS up-to-date if not null.  */\n \n void\n-cfg_layout_initialize (struct loops *loops)\n+cfg_layout_initialize ()\n {\n+  basic_block bb;\n+\n   /* Our algorithm depends on fact that there are now dead jumptables\n      around the code.  */\n-  alloc_aux_for_blocks (sizeof (struct reorder_block_def));\n-  cfg_layout_rtl_register_cfg_hooks ();\n+  cfg_layout_pool =\n+    create_alloc_pool (\"cfg layout pool\", sizeof (struct reorder_block_def),\n+\t\t       n_basic_blocks + 2);\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n+    cfg_layout_initialize_rbi (bb);\n \n-  cleanup_unconditional_jumps (loops);\n+  cfg_layout_rtl_register_cfg_hooks ();\n \n   record_effective_endpoints ();\n+\n+  cleanup_cfg (CLEANUP_CFGLAYOUT);\n }\n \n /* Splits superblocks.  */\n@@ -1169,6 +1143,8 @@ break_superblocks (void)\n void\n cfg_layout_finalize (void)\n {\n+  basic_block bb;\n+\n #ifdef ENABLE_CHECKING\n   verify_flow_info ();\n #endif\n@@ -1180,7 +1156,9 @@ cfg_layout_finalize (void)\n   verify_insn_chain ();\n #endif\n \n-  free_aux_for_blocks ();\n+  free_alloc_pool (cfg_layout_pool);\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n+    bb->rbi = NULL;\n \n   break_superblocks ();\n "}, {"sha": "1602289ac05d1908f119dc5d3125d0b84e868acc", "filename": "gcc/cfglayout.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc35512f0998b6cc547ef6466cd9865c1e927e44/gcc%2Fcfglayout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc35512f0998b6cc547ef6466cd9865c1e927e44/gcc%2Fcfglayout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.h?ref=bc35512f0998b6cc547ef6466cd9865c1e927e44", "patch": "@@ -33,13 +33,12 @@ typedef struct reorder_block_def\n   int visited;\n } *reorder_block_def;\n \n-#define RBI(BB)\t((reorder_block_def) (BB)->aux)\n-\n extern rtx cfg_layout_function_footer;\n \n-extern void cfg_layout_initialize (struct loops *);\n+extern void cfg_layout_initialize (void);\n extern void cfg_layout_finalize (void);\n extern bool cfg_layout_can_duplicate_bb_p (basic_block);\n extern basic_block cfg_layout_duplicate_bb (basic_block, edge);\n extern void insn_locators_initialize (void);\n extern void reemit_insn_block_notes (void);\n+extern void cfg_layout_initialize_rbi\t(basic_block);"}, {"sha": "3fdc609582fae548cb7dd4dbefca426a148b5c8e", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc35512f0998b6cc547ef6466cd9865c1e927e44/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc35512f0998b6cc547ef6466cd9865c1e927e44/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=bc35512f0998b6cc547ef6466cd9865c1e927e44", "patch": "@@ -294,8 +294,7 @@ extern int fix_loop_placement (struct loop *);\n \n enum\n {\n-  CP_SIMPLE_PREHEADERS = 1,\n-  CP_INSIDE_CFGLAYOUT = 2\n+  CP_SIMPLE_PREHEADERS = 1\n };\n \n extern void create_preheaders (struct loops *, int);"}, {"sha": "c627ea0634826f5bd65538decd337036b362a37b", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 15, "deletions": 28, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc35512f0998b6cc547ef6466cd9865c1e927e44/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc35512f0998b6cc547ef6466cd9865c1e927e44/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=bc35512f0998b6cc547ef6466cd9865c1e927e44", "patch": "@@ -860,7 +860,7 @@ copy_bbs (basic_block *bbs, int n, edge entry, edge latch_edge,\n       /* Duplicate.  */\n       bb = bbs[i];\n       new_bb = (*new_bbs)[i] = cfg_layout_duplicate_bb (bb, NULL);\n-      RBI (new_bb)->duplicated = 1;\n+      new_bb->rbi->duplicated = 1;\n       /* Add to loop.  */\n       add_bb_to_loop (new_bb, bb->loop_father->copy);\n       add_to_dominance_info (loops->cfg.dom, new_bb);\n@@ -886,7 +886,7 @@ copy_bbs (basic_block *bbs, int n, edge entry, edge latch_edge,\n \t{\n \t  /* For anything else than loop header, just copy it.  */\n \t  dom_bb = get_immediate_dominator (loops->cfg.dom, bb);\n-\t  dom_bb = RBI (dom_bb)->copy;\n+\t  dom_bb = dom_bb->rbi->copy;\n \t}\n       else\n \t{\n@@ -910,7 +910,7 @@ copy_bbs (basic_block *bbs, int n, edge entry, edge latch_edge,\n \n \t  e_pred = e->pred_next;\n \n-\t  if (!RBI (src)->duplicated)\n+\t  if (!src->rbi->duplicated)\n \t    continue;\n \n \t  /* Leads to copied loop and it is not latch edge, redirect it.  */\n@@ -919,24 +919,24 @@ copy_bbs (basic_block *bbs, int n, edge entry, edge latch_edge,\n \n \t  if (add_irreducible_flag\n \t      && (bb->loop_father == header->loop_father\n-\t\t  || RBI (src)->original->loop_father == header->loop_father))\n+\t\t  || src->rbi->original->loop_father == header->loop_father))\n \t    e->flags |= EDGE_IRREDUCIBLE_LOOP;\n \t}\n     }\n \n   /* Redirect header edge.  */\n-  bb = RBI (latch_edge->src)->copy;\n+  bb = latch_edge->src->rbi->copy;\n   for (e = bb->succ; e->dest != latch_edge->dest; e = e->succ_next);\n   *header_edge = e;\n   loop_redirect_edge (*header_edge, header);\n \n   /* Redirect entry to copy of header.  */\n-  loop_redirect_edge (entry, RBI (header)->copy);\n+  loop_redirect_edge (entry, header->rbi->copy);\n   *copy_header_edge = entry;\n \n   /* Clear information about duplicates.  */\n   for (i = 0; i < n; i++)\n-    RBI ((*new_bbs)[i])->duplicated = 0;\n+    (*new_bbs)[i]->rbi->duplicated = 0;\n }\n \n /* Check whether LOOP's body can be duplicated.  */\n@@ -995,7 +995,7 @@ record_exit_edges (edge orig, basic_block *bbs, int nbbs, edge *to_remove,\n \t  return;\n \t}\n \n-      for (e = RBI (orig->src)->copy->succ; e; e = e->succ_next)\n+      for (e = orig->src->rbi->copy->succ; e; e = e->succ_next)\n \tif (e->dest == orig->dest)\n \t  break;\n       if (!e)\n@@ -1175,7 +1175,7 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e, struct loops *loops,\n       copy_bbs (bbs, n, e, latch_edge, &new_bbs, loops,\n \t\t&e, &he, add_irreducible_flag);\n       if (is_latch)\n-\tloop->latch = RBI (latch)->copy;\n+\tloop->latch = latch->rbi->copy;\n \n       /* Record exit edges in this copy.  */\n       if (TEST_BIT (wont_exit, j + 1))\n@@ -1209,19 +1209,19 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e, struct loops *loops,\n       if (!first_active_latch)\n \t{\n \t  memcpy (first_active, new_bbs, n * sizeof (basic_block));\n-\t  first_active_latch = RBI (latch)->copy;\n+\t  first_active_latch = latch->rbi->copy;\n \t}\n \n       free (new_bbs);\n \n       /* Original loop header is dominated by latch copy\n \t if we duplicated on its only entry edge.  */\n       if (!is_latch && !header->pred->pred_next->pred_next)\n-\tset_immediate_dominator (loops->cfg.dom, header, RBI (latch)->copy);\n+\tset_immediate_dominator (loops->cfg.dom, header, latch->rbi->copy);\n       if (is_latch && j == 0)\n \t{\n \t  /* Update edge from latch.  */\n-\t  for (latch_edge = RBI (header)->copy->pred;\n+\t  for (latch_edge = header->rbi->copy->pred;\n \t       latch_edge->src != latch;\n \t       latch_edge = latch_edge->pred_next);\n \t}\n@@ -1409,33 +1409,20 @@ loop_split_edge_with (edge e, rtx insns, struct loops *loops)\n \n   /* Create basic block for it.  */\n \n-  new_bb = create_basic_block (NULL_RTX, NULL_RTX, EXIT_BLOCK_PTR->prev_bb);\n+  new_bb = split_edge (e);\n   add_to_dominance_info (loops->cfg.dom, new_bb);\n   add_bb_to_loop (new_bb, loop_c);\n   new_bb->flags = insns ? BB_SUPERBLOCK : 0;\n \n-  new_e = make_edge (new_bb, dest, EDGE_FALLTHRU);\n-  new_e->probability = REG_BR_PROB_BASE;\n-  new_e->count = e->count;\n+  new_e = new_bb->succ;\n   if (e->flags & EDGE_IRREDUCIBLE_LOOP)\n     {\n       new_bb->flags |= BB_IRREDUCIBLE_LOOP;\n       new_e->flags |= EDGE_IRREDUCIBLE_LOOP;\n     }\n \n-  new_bb->count = e->count;\n-  new_bb->frequency = EDGE_FREQUENCY (e);\n-  redirect_edge_and_branch_force (e, new_bb);\n-\n-  alloc_aux_for_block (new_bb, sizeof (struct reorder_block_def));\n   if (insns)\n-    {\n-      start_sequence ();\n-      emit_insn (insns);\n-      insns = get_insns ();\n-      end_sequence ();\n-      emit_insn_after (insns, new_bb->end);\n-    }\n+    emit_insn_after (insns, new_bb->end);\n \n   set_immediate_dominator (loops->cfg.dom, new_bb, src);\n   set_immediate_dominator (loops->cfg.dom, dest,"}, {"sha": "1f878ee203ed06b238794562b3b88a7571145748", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 325, "deletions": 91, "changes": 416, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc35512f0998b6cc547ef6466cd9865c1e927e44/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc35512f0998b6cc547ef6466cd9865c1e927e44/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=bc35512f0998b6cc547ef6466cd9865c1e927e44", "patch": "@@ -23,20 +23,19 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    that are aware of the RTL intermediate language.\n \n    Available functionality:\n+     - Basic CFG/RTL manipulation API documented in cfghooks.h\n      - CFG-aware instruction chain manipulation\n \t delete_insn, delete_insn_chain\n-     - Basic block manipulation\n-\t create_basic_block, rtl_delete_block,rtl_split_block,\n-\t merge_blocks_nomove\n+     - Edge splitting and committing to edges\n+\t insert_insn_on_edge, commit_edge_insertions\n+     - CFG updating after insn simplification\n+\t purge_dead_edges, purge_all_dead_edges\n+\n+   Functions not supposed for generic use:\n      - Infrastructure to determine quickly basic block for insn\n \t compute_bb_for_insn, update_bb_for_insn, set_block_for_insn,\n      - Edge redirection with updating and optimizing of insn chain\n-\t block_label, redirect_edge_and_branch,\n-\t redirect_edge_and_branch_force, tidy_fallthru_edge, force_nonfallthru\n-     - Edge splitting and committing to edges\n-\t split_edge, insert_insn_on_edge, commit_edge_insertions\n-     - CFG updating after constant propagation\n-\t purge_dead_edges, purge_all_dead_edges   */\n+\t block_label, tidy_fallthru_edge, force_nonfallthru  */\n \f\n #include \"config.h\"\n #include \"system.h\"\n@@ -73,7 +72,6 @@ rtx tail_recursion_label_list;\n static int can_delete_note_p (rtx);\n static int can_delete_label_p (rtx);\n static void commit_one_edge_insertion (edge, int);\n-static bool try_redirect_by_replacing_jump (edge, basic_block);\n static rtx last_loop_beg_note (rtx);\n static bool back_edge_of_syntactic_loop_p (basic_block, basic_block);\n basic_block force_nonfallthru_and_redirect (edge, basic_block);\n@@ -326,9 +324,10 @@ create_basic_block_structure (rtx head, rtx end, rtx bb_note, basic_block after)\n    create new empty basic block before HEAD.  Both END and HEAD can be NULL to\n    create basic block at the end of INSN chain.  */\n \n-basic_block\n-create_basic_block (rtx head, rtx end, basic_block after)\n+static basic_block\n+rtl_create_basic_block (void *headp, void *endp, basic_block after)\n {\n+  rtx head = headp, end = endp;\n   basic_block bb;\n \n   /* Place the new block just after the end.  */\n@@ -340,6 +339,15 @@ create_basic_block (rtx head, rtx end, basic_block after)\n   bb->aux = NULL;\n   return bb;\n }\n+\n+static basic_block\n+cfg_layout_create_basic_block (void *head, void *end, basic_block after)\n+{\n+  basic_block newbb = rtl_create_basic_block (head, end, after);\n+\n+  cfg_layout_initialize_rbi (newbb);\n+  return newbb;\n+}\n \f\n /* Delete the insns in a (non-live) block.  We physically delete every\n    non-deleted-note insn, and update the flow graph appropriately.\n@@ -517,16 +525,42 @@ rtl_split_block (basic_block bb, void *insnp)\n   return new_edge;\n }\n \n+/* Assume that the code of basic block B has been merged into A.\n+   Do corresponding CFG updates:  redirect edges accordingly etc.  */\n+static void\n+update_cfg_after_block_merging (basic_block a, basic_block b)\n+{\n+  edge e;\n+\n+  /* Normally there should only be one successor of A and that is B, but\n+     partway though the merge of blocks for conditional_execution we'll\n+     be merging a TEST block with THEN and ELSE successors.  Free the\n+     whole lot of them and hope the caller knows what they're doing.  */\n+  while (a->succ)\n+    remove_edge (a->succ);\n+\n+  /* Adjust the edges out of B for the new owner.  */\n+  for (e = b->succ; e; e = e->succ_next)\n+    e->src = a;\n+  a->succ = b->succ;\n+  a->flags |= b->flags;\n+\n+  /* B hasn't quite yet ceased to exist.  Attempt to prevent mishap.  */\n+  b->pred = b->succ = NULL;\n+  a->global_live_at_end = b->global_live_at_end;\n+\n+  expunge_block (b);\n+}\n+\n /* Blocks A and B are to be merged into a single block A.  The insns\n-   are already contiguous, hence `nomove'.  */\n+   are already contiguous.  */\n \n-void\n-merge_blocks_nomove (basic_block a, basic_block b)\n+static void\n+rtl_merge_blocks (basic_block a, basic_block b)\n {\n   rtx b_head = b->head, b_end = b->end, a_end = a->end;\n   rtx del_first = NULL_RTX, del_last = NULL_RTX;\n   int b_empty = 0;\n-  edge e;\n \n   /* If there was a CODE_LABEL beginning B, delete it.  */\n   if (GET_CODE (b_head) == CODE_LABEL)\n@@ -585,24 +619,7 @@ merge_blocks_nomove (basic_block a, basic_block b)\n   else if (GET_CODE (NEXT_INSN (a_end)) == BARRIER)\n     del_first = NEXT_INSN (a_end);\n \n-  /* Normally there should only be one successor of A and that is B, but\n-     partway though the merge of blocks for conditional_execution we'll\n-     be merging a TEST block with THEN and ELSE successors.  Free the\n-     whole lot of them and hope the caller knows what they're doing.  */\n-  while (a->succ)\n-    remove_edge (a->succ);\n-\n-  /* Adjust the edges out of B for the new owner.  */\n-  for (e = b->succ; e; e = e->succ_next)\n-    e->src = a;\n-  a->succ = b->succ;\n-  a->flags |= b->flags;\n-\n-  /* B hasn't quite yet ceased to exist.  Attempt to prevent mishap.  */\n-  b->pred = b->succ = NULL;\n-  a->global_live_at_end = b->global_live_at_end;\n-\n-  expunge_block (b);\n+  update_cfg_after_block_merging (a, b);\n \n   /* Delete everything marked above as well as crap that might be\n      hanging out between the two blocks.  */\n@@ -623,6 +640,24 @@ merge_blocks_nomove (basic_block a, basic_block b)\n \n   a->end = a_end;\n }\n+\n+/* Return true when block A and B can be merged.  */\n+static bool\n+rtl_can_merge_blocks (basic_block a,basic_block b)\n+{\n+  /* There must be exactly one edge in between the blocks.  */\n+  return (a->succ && !a->succ->succ_next && a->succ->dest == b\n+\t  && !b->pred->pred_next && a != b\n+\t  /* Must be simple edge.  */\n+\t  && !(a->succ->flags & EDGE_COMPLEX)\n+\t  && a->next_bb == b\n+\t  && a != ENTRY_BLOCK_PTR && b != EXIT_BLOCK_PTR\n+\t  /* If the jump insn has side effects,\n+\t     we can't kill the edge.  */\n+\t  && (GET_CODE (a->end) != JUMP_INSN\n+\t      || (flow2_completed\n+\t\t  ? simplejump_p (a->end) : onlyjump_p (a->end))));\n+}\n \f\n /* Return the label in the head of basic block BLOCK.  Create one if it doesn't\n    exist.  */\n@@ -647,7 +682,7 @@ block_label (basic_block block)\n    return values are equivalent to redirect_edge_and_branch.  */\n \n static bool\n-try_redirect_by_replacing_jump (edge e, basic_block target)\n+try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n {\n   basic_block src = e->src;\n   rtx insn = src->end, kill_from;\n@@ -679,14 +714,38 @@ try_redirect_by_replacing_jump (edge e, basic_block target)\n #endif\n \n   /* See if we can create the fallthru edge.  */\n-  if (can_fallthru (src, target))\n+  if (in_cfglayout || can_fallthru (src, target))\n     {\n       if (rtl_dump_file)\n \tfprintf (rtl_dump_file, \"Removing jump %i.\\n\", INSN_UID (insn));\n       fallthru = 1;\n \n       /* Selectively unlink whole insn chain.  */\n-      delete_insn_chain (kill_from, PREV_INSN (target->head));\n+      if (in_cfglayout)\n+\t{\n+\t  rtx insn = src->rbi->footer;\n+\n+          delete_insn_chain (kill_from, src->end);\n+\n+\t  /* Remove barriers but keep jumptables.  */\n+\t  while (insn)\n+\t    {\n+\t      if (GET_CODE (insn) == BARRIER)\n+\t\t{\n+\t\t  if (PREV_INSN (insn))\n+\t\t    NEXT_INSN (PREV_INSN (insn)) = NEXT_INSN (insn);\n+\t\t  else\n+\t\t    src->rbi->footer = NEXT_INSN (insn);\n+\t\t  if (NEXT_INSN (insn))\n+\t\t    PREV_INSN (NEXT_INSN (insn)) = PREV_INSN (insn);\n+\t\t}\n+\t      if (GET_CODE (insn) == CODE_LABEL)\n+\t\tbreak;\n+\t      insn = NEXT_INSN (insn);\n+\t    }\n+\t}\n+      else\n+        delete_insn_chain (kill_from, PREV_INSN (target->head));\n     }\n \n   /* If this already is simplejump, redirect it.  */\n@@ -782,36 +841,15 @@ last_loop_beg_note (rtx insn)\n   return last;\n }\n \n-/* Attempt to change code to redirect edge E to TARGET.  Don't do that on\n-   expense of adding new instructions or reordering basic blocks.\n-\n-   Function can be also called with edge destination equivalent to the TARGET.\n-   Then it should try the simplifications and do nothing if none is possible.\n-\n-   Return true if transformation succeeded.  We still return false in case E\n-   already destinated TARGET and we didn't managed to simplify instruction\n-   stream.  */\n-\n+/* Redirect edge representing branch of (un)conditional jump or tablejump.  */\n static bool\n-rtl_redirect_edge_and_branch (edge e, basic_block target)\n+redirect_branch_edge (edge e, basic_block target)\n {\n   rtx tmp;\n   rtx old_label = e->dest->head;\n   basic_block src = e->src;\n   rtx insn = src->end;\n \n-  if (e->flags & (EDGE_ABNORMAL_CALL | EDGE_EH))\n-    return false;\n-\n-  if (try_redirect_by_replacing_jump (e, target))\n-    return true;\n-\n-  /* Do this fast path late, as we want above code to simplify for cases\n-     where called on single edge leaving basic block containing nontrivial\n-     jump insn.  */\n-  else if (e->dest == target)\n-    return false;\n-\n   /* We can only redirect non-fallthru edges of jump insn.  */\n   if (e->flags & EDGE_FALLTHRU)\n     return false;\n@@ -884,6 +922,37 @@ rtl_redirect_edge_and_branch (edge e, basic_block target)\n \n   if (e->dest != target)\n     redirect_edge_succ_nodup (e, target);\n+  return true;\n+}\n+\n+/* Attempt to change code to redirect edge E to TARGET.  Don't do that on\n+   expense of adding new instructions or reordering basic blocks.\n+\n+   Function can be also called with edge destination equivalent to the TARGET.\n+   Then it should try the simplifications and do nothing if none is possible.\n+\n+   Return true if transformation succeeded.  We still return false in case E\n+   already destinated TARGET and we didn't managed to simplify instruction\n+   stream.  */\n+\n+static bool\n+rtl_redirect_edge_and_branch (e, target)\n+     edge e;\n+     basic_block target;\n+{\n+  if (e->flags & (EDGE_ABNORMAL_CALL | EDGE_EH))\n+    return false;\n+\n+  if (try_redirect_by_replacing_jump (e, target, false))\n+    return true;\n+\n+  /* Do this fast path late, as we want above code to simplify for cases\n+     where called on single edge leaving basic block containing nontrivial\n+     jump insn.  */\n+  else if (e->dest == target)\n+    return false;\n+  else if (!redirect_branch_edge (e, target))\n+    return false;\n \n   return true;\n }\n@@ -2323,9 +2392,8 @@ cfg_layout_split_block (basic_block bb, void *insnp)\n \n   edge fallthru = rtl_split_block (bb, insn);\n \n-  alloc_aux_for_block (fallthru->dest, sizeof (struct reorder_block_def));\n-  RBI (fallthru->dest)->footer = RBI (fallthru->src)->footer;\n-  RBI (fallthru->src)->footer = NULL;\n+  fallthru->dest->rbi->footer = fallthru->src->rbi->footer;\n+  fallthru->src->rbi->footer = NULL;\n   return fallthru;\n }\n \n@@ -2335,14 +2403,33 @@ static bool\n cfg_layout_redirect_edge_and_branch (edge e, basic_block dest)\n {\n   basic_block src = e->src;\n-  basic_block old_next_bb = src->next_bb;\n   bool ret;\n \n+  if (e->flags & (EDGE_ABNORMAL_CALL | EDGE_EH))\n+    return false;\n+\n+  if (e->src != ENTRY_BLOCK_PTR\n+      && try_redirect_by_replacing_jump (e, dest, true))\n+    return true;\n+\n+  if (e->dest == dest)\n+    return true;\n+\n+  if (e->src == ENTRY_BLOCK_PTR\n+      && (e->flags & EDGE_FALLTHRU) && !(e->flags & EDGE_COMPLEX))\n+    {\n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file, \"Redirecting entry edge from bb %i to %i\\n\",\n+\t\t e->src->index, dest->index);\n+\n+      redirect_edge_succ (e, dest);\n+      return true;\n+    }\n+\n   /* Redirect_edge_and_branch may decide to turn branch into fallthru edge\n      in the case the basic block appears to be in sequence.  Avoid this\n      transformation.  */\n \n-  src->next_bb = NULL;\n   if (e->flags & EDGE_FALLTHRU)\n     {\n       /* Redirect any branch edges unified with the fallthru one.  */\n@@ -2364,20 +2451,18 @@ cfg_layout_redirect_edge_and_branch (edge e, basic_block dest)\n \t    delete_insn (src->end);\n \t}\n       redirect_edge_succ_nodup (e, dest);\n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file, \"Fallthru edge %i->%i redirected to %i\\n\",\n+\t\t e->src->index, e->dest->index, dest->index);\n \n       ret = true;\n     }\n   else\n-    ret = rtl_redirect_edge_and_branch (e, dest);\n+    ret = redirect_branch_edge (e, dest);\n \n   /* We don't want simplejumps in the insn stream during cfglayout.  */\n   if (simplejump_p (src->end))\n-    {\n-      delete_insn (src->end);\n-      delete_barrier (NEXT_INSN (src->end));\n-      src->succ->flags |= EDGE_FALLTHRU;\n-    }\n-  src->next_bb = old_next_bb;\n+    abort ();\n \n   return ret;\n }\n@@ -2397,36 +2482,55 @@ cfg_layout_delete_block (basic_block bb)\n {\n   rtx insn, next, prev = PREV_INSN (bb->head), *to, remaints;\n \n-  if (RBI (bb)->header)\n+  if (bb->rbi->header)\n     {\n       next = bb->head;\n       if (prev)\n-\tNEXT_INSN (prev) = RBI (bb)->header;\n+\tNEXT_INSN (prev) = bb->rbi->header;\n       else\n-\tset_first_insn (RBI (bb)->header);\n-      PREV_INSN (RBI (bb)->header) = prev;\n-      insn = RBI (bb)->header;\n+\tset_first_insn (bb->rbi->header);\n+      PREV_INSN (bb->rbi->header) = prev;\n+      insn = bb->rbi->header;\n       while (NEXT_INSN (insn))\n \tinsn = NEXT_INSN (insn);\n       NEXT_INSN (insn) = next;\n       PREV_INSN (next) = insn;\n     }\n   next = NEXT_INSN (bb->end);\n-  if (RBI (bb)->footer)\n+  if (bb->rbi->footer)\n     {\n-      insn = bb->end;\n-      NEXT_INSN (insn) = RBI (bb)->footer;\n-      PREV_INSN (RBI (bb)->footer) = insn;\n-      while (NEXT_INSN (insn))\n-\tinsn = NEXT_INSN (insn);\n-      NEXT_INSN (insn) = next;\n-      if (next)\n-\tPREV_INSN (next) = insn;\n-      else\n-\tset_last_insn (insn);\n+      insn = bb->rbi->footer;\n+      while (insn)\n+\t{\n+\t  if (GET_CODE (insn) == BARRIER)\n+\t    {\n+\t      if (PREV_INSN (insn))\n+\t\tNEXT_INSN (PREV_INSN (insn)) = NEXT_INSN (insn);\n+\t      else\n+\t\tbb->rbi->footer = NEXT_INSN (insn);\n+\t      if (NEXT_INSN (insn))\n+\t\tPREV_INSN (NEXT_INSN (insn)) = PREV_INSN (insn);\n+\t    }\n+\t  if (GET_CODE (insn) == CODE_LABEL)\n+\t    break;\n+\t  insn = NEXT_INSN (insn);\n+\t}\n+      if (bb->rbi->footer)\n+\t{\n+\t  insn = bb->end;\n+\t  NEXT_INSN (insn) = bb->rbi->footer;\n+\t  PREV_INSN (bb->rbi->footer) = insn;\n+\t  while (NEXT_INSN (insn))\n+\t    insn = NEXT_INSN (insn);\n+\t  NEXT_INSN (insn) = next;\n+\t  if (next)\n+\t    PREV_INSN (next) = insn;\n+\t  else\n+\t    set_last_insn (insn);\n+\t}\n     }\n   if (bb->next_bb != EXIT_BLOCK_PTR)\n-    to = &RBI(bb->next_bb)->header;\n+    to = &bb->next_bb->rbi->header;\n   else\n     to = &cfg_layout_function_footer;\n   rtl_delete_block (bb);\n@@ -2453,14 +2557,141 @@ cfg_layout_delete_block (basic_block bb)\n     }\n }\n \n+/* return true when blocks A and B can be safely merged.  */\n+static bool\n+cfg_layout_can_merge_blocks_p (basic_block a, basic_block b)\n+{\n+  /* There must be exactly one edge in between the blocks.  */\n+  return (a->succ && !a->succ->succ_next && a->succ->dest == b\n+\t  && !b->pred->pred_next && a != b\n+\t  /* Must be simple edge.  */\n+\t  && !(a->succ->flags & EDGE_COMPLEX)\n+\t  && a != ENTRY_BLOCK_PTR && b != EXIT_BLOCK_PTR\n+\t  /* If the jump insn has side effects,\n+\t     we can't kill the edge.  */\n+\t  && (GET_CODE (a->end) != JUMP_INSN\n+\t      || (flow2_completed\n+\t\t  ? simplejump_p (a->end) : onlyjump_p (a->end))));\n+}\n+\n+/* Merge block A and B, abort when it is not possible.  */\n+static void\n+cfg_layout_merge_blocks (basic_block a, basic_block b)\n+{\n+#ifdef ENABLE_CHECKING\n+  if (!cfg_layout_can_merge_blocks_p (a, b))\n+    abort ();\n+#endif\n+\n+  /* If there was a CODE_LABEL beginning B, delete it.  */\n+  if (GET_CODE (b->head) == CODE_LABEL)\n+    delete_insn (b->head);\n+\n+  /* We should have fallthru edge in a, or we can do dummy redirection to get\n+     it cleaned up.  */\n+  if (GET_CODE (a->end) == JUMP_INSN)\n+    redirect_edge_and_branch (a->succ, b);\n+  if (GET_CODE (a->end) == JUMP_INSN)\n+    abort ();\n+\n+  /* Possible line number notes should appear in between.  */\n+  if (b->rbi->header)\n+    {\n+      rtx first = a->end, last;\n+\n+      last = emit_insn_after (b->rbi->header, a->end);\n+      delete_insn_chain (NEXT_INSN (first), last);\n+      b->rbi->header = NULL;\n+    }\n+\n+  /* In the case basic blocks are not adjacent, move them around.  */\n+  if (NEXT_INSN (a->end) != b->head)\n+    {\n+      rtx first = unlink_insn_chain (b->head, b->end);\n+\n+      emit_insn_after (first, a->end);\n+      /* Skip possible DELETED_LABEL insn.  */\n+      if (!NOTE_INSN_BASIC_BLOCK_P (first))\n+\tfirst = NEXT_INSN (first);\n+      if (!NOTE_INSN_BASIC_BLOCK_P (first))\n+\tabort ();\n+      b->head = NULL;\n+      delete_insn (first);\n+    }\n+  /* Otherwise just re-associate the instructions.  */\n+  else\n+    {\n+      rtx insn;\n+\n+      for (insn = b->head; insn != NEXT_INSN (b->end); insn = NEXT_INSN (insn))\n+\tset_block_for_insn (insn, a);\n+      insn = b->head;\n+      /* Skip possible DELETED_LABEL insn.  */\n+      if (!NOTE_INSN_BASIC_BLOCK_P (insn))\n+\tinsn = NEXT_INSN (insn);\n+      if (!NOTE_INSN_BASIC_BLOCK_P (insn))\n+\tabort ();\n+      b->head = NULL;\n+      a->end = b->end;\n+      delete_insn (insn);\n+    }\n+\n+  /* Possible tablejumps and barriers should appear after the block.  */\n+  if (b->rbi->footer)\n+    {\n+      if (!a->rbi->footer)\n+\ta->rbi->footer = b->rbi->footer;\n+      else\n+\t{\n+\t  rtx last = a->rbi->footer;\n+\n+\t  while (NEXT_INSN (last))\n+\t    last = NEXT_INSN (last);\n+\t  NEXT_INSN (last) = b->rbi->footer;\n+\t  PREV_INSN (b->rbi->footer) = last;\n+\t}\n+      b->rbi->footer = NULL;\n+    }\n+\n+  if (rtl_dump_file)\n+    fprintf (rtl_dump_file, \"Merged blocks %d and %d.\\n\",\n+\t     a->index, b->index);\n+\n+  update_cfg_after_block_merging (a, b);\n+}\n+\n+/* Split edge E.  */\n+static basic_block\n+cfg_layout_split_edge (edge e)\n+{\n+  edge new_e;\n+  basic_block new_bb =\n+    create_basic_block (e->src != ENTRY_BLOCK_PTR\n+\t\t\t? NEXT_INSN (e->src-> end) : get_insns (),\n+\t\t\tNULL_RTX, e->src);\n+\n+  new_bb->count = e->count;\n+  new_bb->frequency = EDGE_FREQUENCY (e);\n+\n+  new_e = make_edge (new_bb, e->dest, EDGE_FALLTHRU);\n+  new_e->probability = REG_BR_PROB_BASE;\n+  new_e->count = e->count;\n+  redirect_edge_and_branch_force (e, new_bb);\n+\n+  return new_bb;\n+}\n+\n /* Implementation of CFG manipulation for linearized RTL.  */\n struct cfg_hooks rtl_cfg_hooks = {\n   rtl_verify_flow_info,\n   rtl_dump_bb,\n+  rtl_create_basic_block,\n   rtl_redirect_edge_and_branch,\n   rtl_redirect_edge_and_branch_force,\n   rtl_delete_block,\n   rtl_split_block,\n+  rtl_can_merge_blocks,  /* can_merge_blocks_p */\n+  rtl_merge_blocks,\n   rtl_split_edge\n };\n \n@@ -2469,11 +2700,14 @@ struct cfg_hooks rtl_cfg_hooks = {\n    This representation will hopefully become the default one in future\n    version of the compiler.  */\n struct cfg_hooks cfg_layout_rtl_cfg_hooks = {\n-  rtl_verify_flow_info_1,   /* verify_flow_info.  */\n+  rtl_verify_flow_info_1,\n   rtl_dump_bb,\n+  cfg_layout_create_basic_block,\n   cfg_layout_redirect_edge_and_branch,\n   cfg_layout_redirect_edge_and_branch_force,\n   cfg_layout_delete_block,\n   cfg_layout_split_block,\n-  NULL  /* split_edge.  */\n+  cfg_layout_can_merge_blocks_p,\n+  cfg_layout_merge_blocks,\n+  cfg_layout_split_edge\n };"}, {"sha": "4fab7b357df93408a2ba6ac5bf834181985d1222", "filename": "gcc/flow.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc35512f0998b6cc547ef6466cd9865c1e927e44/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc35512f0998b6cc547ef6466cd9865c1e927e44/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=bc35512f0998b6cc547ef6466cd9865c1e927e44", "patch": "@@ -2063,7 +2063,10 @@ propagate_block (basic_block bb, regset live, regset local_set,\n \tIOR_REG_SET (regs_live_at_setjmp, pbi->reg_live);\n \n       prev = propagate_one_insn (pbi, insn);\n-      changed |= NEXT_INSN (prev) != insn;\n+      if (!prev)\n+        changed |= insn != get_insns ();\n+      else\n+        changed |= NEXT_INSN (prev) != insn;\n \n       if (insn == bb->head)\n \tbreak;"}, {"sha": "9c1beec056f7946c9f439d642c99d8a3d6ec2c23", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc35512f0998b6cc547ef6466cd9865c1e927e44/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc35512f0998b6cc547ef6466cd9865c1e927e44/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=bc35512f0998b6cc547ef6466cd9865c1e927e44", "patch": "@@ -2016,7 +2016,7 @@ merge_if_block (ce_info)\n \t  fallthru = block_fallthru (bb);\n \t  if (post_dominators)\n \t    delete_from_dominance_info (post_dominators, bb);\n-\t  merge_blocks_nomove (combo_bb, bb);\n+\t  merge_blocks (combo_bb, bb);\n \t  num_removed_blocks++;\n \t}\n       while (bb != last_test_bb);\n@@ -2033,7 +2033,7 @@ merge_if_block (ce_info)\n \t\t      then_bb->global_live_at_end);\n       if (post_dominators)\n \tdelete_from_dominance_info (post_dominators, then_bb);\n-      merge_blocks_nomove (combo_bb, then_bb);\n+      merge_blocks (combo_bb, then_bb);\n       num_removed_blocks++;\n     }\n \n@@ -2044,7 +2044,7 @@ merge_if_block (ce_info)\n     {\n       if (post_dominators)\n \tdelete_from_dominance_info (post_dominators, else_bb);\n-      merge_blocks_nomove (combo_bb, else_bb);\n+      merge_blocks (combo_bb, else_bb);\n       num_removed_blocks++;\n     }\n \n@@ -2101,7 +2101,7 @@ merge_if_block (ce_info)\n \n       if (post_dominators)\n \tdelete_from_dominance_info (post_dominators, join_bb);\n-      merge_blocks_nomove (combo_bb, join_bb);\n+      merge_blocks (combo_bb, join_bb);\n       num_removed_blocks++;\n     }\n   else\n@@ -3129,7 +3129,7 @@ if_convert (x_life_data_ok)\n   life_data_ok = (x_life_data_ok != 0);\n \n   /* Free up basic_block_for_insn so that we don't have to keep it\n-     up to date, either here or in merge_blocks_nomove.  */\n+     up to date, either here or in merge_blocks.  */\n   free_basic_block_vars (1);\n \n   /* Compute postdominators if we think we'll use them.  */"}, {"sha": "a04faefaf336ae2bd45014cac13927f00d24bfd5", "filename": "gcc/loop-init.c", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc35512f0998b6cc547ef6466cd9865c1e927e44/gcc%2Floop-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc35512f0998b6cc547ef6466cd9865c1e927e44/gcc%2Floop-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-init.c?ref=bc35512f0998b6cc547ef6466cd9865c1e927e44", "patch": "@@ -37,6 +37,9 @@ loop_optimizer_init (dumpfile)\n   struct loops *loops = xcalloc (1, sizeof (struct loops));\n   edge e;\n \n+  /* Initialize structures for layout changes.  */\n+  cfg_layout_initialize ();\n+\n   /* Avoid annoying special cases of edges going to exit\n      block.  */\n   for (e = EXIT_BLOCK_PTR->pred; e; e = e->pred_next)\n@@ -47,9 +50,16 @@ loop_optimizer_init (dumpfile)\n \n   if (flow_loops_find (loops, LOOP_TREE) <= 1)\n     {\n+      basic_block bb;\n+\n       /* No loops.  */\n       flow_loops_free (loops);\n       free (loops);\n+      /* Make chain.  */\n+      FOR_EACH_BB (bb)\n+\tif (bb->next_bb != EXIT_BLOCK_PTR)\n+\t  bb->rbi->next = bb->next_bb;\n+\t  cfg_layout_finalize ();\n       return NULL;\n     }\n \n@@ -59,11 +69,8 @@ loop_optimizer_init (dumpfile)\n   free (loops->cfg.dfs_order);\n   loops->cfg.dfs_order = NULL;\n \n-  /* Initialize structures for layout changes.  */\n-  cfg_layout_initialize (loops);\n-\n   /* Create pre-headers.  */\n-  create_preheaders (loops, CP_SIMPLE_PREHEADERS | CP_INSIDE_CFGLAYOUT);\n+  create_preheaders (loops, CP_SIMPLE_PREHEADERS);\n \n   /* Force all latches to have only single successor.  */\n   force_single_succ_latches (loops);\n@@ -94,7 +101,7 @@ loop_optimizer_finalize (loops, dumpfile)\n   /* Make chain.  */\n   FOR_EACH_BB (bb)\n     if (bb->next_bb != EXIT_BLOCK_PTR)\n-      RBI (bb)->next = bb->next_bb;\n+      bb->rbi->next = bb->next_bb;\n \n   /* Another dump.  */\n   flow_loops_dump (loops, dumpfile, NULL, 1);"}, {"sha": "202cbffcb8dfdcc1982fb3b1e1187ce5012068c1", "filename": "gcc/loop-unswitch.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc35512f0998b6cc547ef6466cd9865c1e927e44/gcc%2Floop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc35512f0998b6cc547ef6466cd9865c1e927e44/gcc%2Floop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unswitch.c?ref=bc35512f0998b6cc547ef6466cd9865c1e927e44", "patch": "@@ -377,7 +377,7 @@ unswitch_loop (loops, loop, unswitch_on)\n   entry->flags |= irred_flag;\n \n   /* Record the block with condition we unswitch on.  */\n-  unswitch_on_alt = RBI (unswitch_on)->copy;\n+  unswitch_on_alt = unswitch_on->rbi->copy;\n \n   /* Make a copy of the block containing the condition; we will use\n      it as switch to decide which loop we want to use.  */\n@@ -395,14 +395,14 @@ unswitch_loop (loops, loop, unswitch_on)\n       switch_bb->succ->succ_next->flags &= ~EDGE_IRREDUCIBLE_LOOP;\n     }\n   add_to_dominance_info (loops->cfg.dom, switch_bb);\n-  RBI (unswitch_on)->copy = unswitch_on_alt;\n+  unswitch_on->rbi->copy = unswitch_on_alt;\n \n   /* Loopify from the copy of LOOP body, constructing the new loop.  */\n-  for (latch_edge = RBI (loop->latch)->copy->succ;\n+  for (latch_edge = loop->latch->rbi->copy->succ;\n        latch_edge->dest != loop->header;\n        latch_edge = latch_edge->succ_next);\n   nloop = loopify (loops, latch_edge,\n-\t\t   RBI (loop->header)->copy->pred, switch_bb);\n+\t\t   loop->header->rbi->copy->pred, switch_bb);\n \n   /* Remove branches that are now unreachable in new loops.  We rely on the\n      fact that cfg_layout_duplicate_bb reverses list of edges.  */"}, {"sha": "ba1f09e4bddac2e7fe3d01dfce79f3655c74375d", "filename": "gcc/tracer.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc35512f0998b6cc547ef6466cd9865c1e927e44/gcc%2Ftracer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc35512f0998b6cc547ef6466cd9865c1e927e44/gcc%2Ftracer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftracer.c?ref=bc35512f0998b6cc547ef6466cd9865c1e927e44", "patch": "@@ -64,7 +64,7 @@ static int branch_ratio_cutoff;\n /* Return true if BB has been seen - it is connected to some trace\n    already.  */\n \n-#define seen(bb) (RBI (bb)->visited || RBI (bb)->next)\n+#define seen(bb) (bb->rbi->visited || bb->rbi->next)\n \n /* Return true if we should ignore the basic block for purposes of tracing.  */\n static bool\n@@ -295,8 +295,8 @@ tail_duplicate ()\n \t\tfprintf (rtl_dump_file, \"Duplicated %i as %i [%i]\\n\",\n \t\t\t old->index, bb2->index, bb2->frequency);\n \t    }\n-\t  RBI (bb)->next = bb2;\n-\t  RBI (bb2)->visited = 1;\n+\t  bb->rbi->next = bb2;\n+\t  bb2->rbi->visited = 1;\n \t  bb = bb2;\n \t  /* In case the trace became infrequent, stop duplicating.  */\n \t  if (ignore_bb_p (bb))\n@@ -330,28 +330,28 @@ layout_superblocks ()\n   while (bb != EXIT_BLOCK_PTR)\n     {\n       edge e, best = NULL;\n-      while (RBI (end)->next)\n-\tend = RBI (end)->next;\n+      while (end->rbi->next)\n+\tend = end->rbi->next;\n \n       for (e = end->succ; e; e = e->succ_next)\n \tif (e->dest != EXIT_BLOCK_PTR\n \t    && e->dest != ENTRY_BLOCK_PTR->succ->dest\n-\t    && !RBI (e->dest)->visited\n+\t    && !e->dest->rbi->visited\n \t    && (!best || EDGE_FREQUENCY (e) > EDGE_FREQUENCY (best)))\n \t  best = e;\n \n       if (best)\n \t{\n-\t  RBI (end)->next = best->dest;\n-\t  RBI (best->dest)->visited = 1;\n+\t  end->rbi->next = best->dest;\n+\t  best->dest->rbi->visited = 1;\n \t}\n       else\n \tfor (; bb != EXIT_BLOCK_PTR; bb = bb->next_bb)\n \t  {\n-\t    if (!RBI (bb)->visited)\n+\t    if (!bb->rbi->visited)\n \t      {\n-\t\tRBI (end)->next = bb;\n-\t\tRBI (bb)->visited = 1;\n+\t\tend->rbi->next = bb;\n+\t\tbb->rbi->visited = 1;\n \t\tbreak;\n \t      }\n \t  }\n@@ -365,7 +365,7 @@ tracer ()\n {\n   if (n_basic_blocks <= 1)\n     return;\n-  cfg_layout_initialize (NULL);\n+  cfg_layout_initialize ();\n   mark_dfs_back_edges ();\n   if (rtl_dump_file)\n     dump_flow_info (rtl_dump_file);"}]}