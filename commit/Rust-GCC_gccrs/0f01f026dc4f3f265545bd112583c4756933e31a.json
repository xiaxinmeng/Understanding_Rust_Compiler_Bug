{"sha": "0f01f026dc4f3f265545bd112583c4756933e31a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGYwMWYwMjZkYzRmM2YyNjU1NDViZDExMjU4M2M0NzU2OTMzZTMxYQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard@codesourcery.com", "date": "2006-01-23T07:50:42Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2006-01-23T07:50:42Z"}, "message": "gengtype.c (new_structure): Return the structure.\n\n\t* gengtype.c (new_structure): Return the structure.\n\t(create_option): Add an extra \"next\" argument.\n\t(create_field): New function.\n\t(adjust_field_rtx_def): Use create_option and create_field.\n\tRemove a now-unnecessary call to find_structure.\n\t(adjust_field_tree_def): Likewise.\n\t(note_yacc_type): Remove an unnecessary call to find_structure.\n\t* gengtype.h (new_structure): Return the structure.\n\t(create_option): Add an extra argument.\n\t* gengtype-yacc.y (type): Remove unnecessary calls to find_structure.\n\t(option): Adjust calls to create_option.\n\nFrom-SVN: r110108", "tree": {"sha": "184f3fa2aa5272e63450577fd51e2d79c160ae17", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/184f3fa2aa5272e63450577fd51e2d79c160ae17"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0f01f026dc4f3f265545bd112583c4756933e31a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f01f026dc4f3f265545bd112583c4756933e31a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f01f026dc4f3f265545bd112583c4756933e31a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f01f026dc4f3f265545bd112583c4756933e31a/comments", "author": null, "committer": null, "parents": [{"sha": "cda7004bb4836fa9e3c7f892c0fc0de3c81d176f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cda7004bb4836fa9e3c7f892c0fc0de3c81d176f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cda7004bb4836fa9e3c7f892c0fc0de3c81d176f"}], "stats": {"total": 194, "additions": 87, "deletions": 107}, "files": [{"sha": "a665bbe028f11c6690f513a81a1a4d1083da1b4e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f01f026dc4f3f265545bd112583c4756933e31a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f01f026dc4f3f265545bd112583c4756933e31a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0f01f026dc4f3f265545bd112583c4756933e31a", "patch": "@@ -1,3 +1,17 @@\n+2006-01-23  Richard Sandiford  <richard@codesourcery.com>\n+\n+\t* gengtype.c (new_structure): Return the structure.\n+\t(create_option): Add an extra \"next\" argument.\n+\t(create_field): New function.\n+\t(adjust_field_rtx_def): Use create_option and create_field.\n+\tRemove a now-unnecessary call to find_structure.\n+\t(adjust_field_tree_def): Likewise.\n+\t(note_yacc_type): Remove an unnecessary call to find_structure.\n+\t* gengtype.h (new_structure): Return the structure.\n+\t(create_option): Add an extra argument.\n+\t* gengtype-yacc.y (type): Remove unnecessary calls to find_structure.\n+\t(option): Adjust calls to create_option.\n+\n 2006-01-22  David Edelsohn  <edelsohn@gnu.org>\n \n \t* config/rs6000/aix.h (STACK_BOUNDARY): Define."}, {"sha": "8bdf983e06b79055421b9e7fca6295f10de28a25", "filename": "gcc/gengtype-yacc.y", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f01f026dc4f3f265545bd112583c4756933e31a/gcc%2Fgengtype-yacc.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f01f026dc4f3f265545bd112583c4756933e31a/gcc%2Fgengtype-yacc.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype-yacc.y?ref=0f01f026dc4f3f265545bd112583c4756933e31a", "patch": "@@ -232,17 +232,11 @@ type: SCALAR\n       | type '*'\n          { $$ = create_pointer ($1); }\n       | STRUCT ID '{' struct_fields '}'\n-         {\n-\t   new_structure ($2, 0, &lexer_line, $4, NULL);\n-           $$ = find_structure ($2, 0);\n-\t }\n+         { $$ = new_structure ($2, 0, &lexer_line, $4, NULL); }\n       | STRUCT ID\n          { $$ = find_structure ($2, 0); }\n       | UNION ID '{' struct_fields '}'\n-         {\n-\t   new_structure ($2, 1, &lexer_line, $4, NULL);\n-           $$ = find_structure ($2, 1);\n-\t }\n+         { $$ = new_structure ($2, 1, &lexer_line, $4, NULL); }\n       | UNION ID\n          { $$ = find_structure ($2, 1); }\n       | ENUM ID\n@@ -275,19 +269,19 @@ type_option : ALIAS\n \t      ;\n \n option:   ID\n-\t    { $$ = create_option ($1, (void *)\"\"); }\n+\t    { $$ = create_option (NULL, $1, (void *)\"\"); }\n         | ID '(' stringseq ')'\n-            { $$ = create_option ($1, (void *)$3); }\n+            { $$ = create_option (NULL, $1, (void *)$3); }\n \t| type_option '(' type ')'\n-\t    { $$ = create_option ($1, adjust_field_type ($3, NULL)); }\n+\t    { $$ = create_option (NULL, $1, adjust_field_type ($3, NULL)); }\n \t| NESTED_PTR '(' type ',' stringseq ',' stringseq ')'\n \t    {\n \t      struct nested_ptr_data d;\n \n \t      d.type = adjust_field_type ($3, NULL);\n \t      d.convert_to = $5;\n \t      d.convert_from = $7;\n-\t      $$ = create_option (\"nested_ptr\",\n+\t      $$ = create_option (NULL, \"nested_ptr\",\n \t\t\t\t  xmemdup (&d, sizeof (d), sizeof (d)));\n \t    }\n \t;"}, {"sha": "0a915230e12d0f22f7f74f6bcf175649104222d9", "filename": "gcc/gengtype.c", "status": "modified", "additions": 63, "deletions": 91, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f01f026dc4f3f265545bd112583c4756933e31a/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f01f026dc4f3f265545bd112583c4756933e31a/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=0f01f026dc4f3f265545bd112583c4756933e31a", "patch": "@@ -143,10 +143,10 @@ resolve_typedef (const char *s, struct fileloc *pos)\n   return create_scalar_type (\"char\", 4);\n }\n \n-/* Create a new structure with tag NAME (or a union iff ISUNION is nonzero),\n-   at POS with fields FIELDS and options O.  */\n+/* Create and return a new structure with tag NAME (or a union iff\n+   ISUNION is nonzero), at POS with fields FIELDS and options O.  */\n \n-void\n+type_p\n new_structure (const char *name, int isunion, struct fileloc *pos,\n \t       pair_p fields, options_p o)\n {\n@@ -214,6 +214,8 @@ new_structure (const char *name, int isunion, struct fileloc *pos,\n   s->u.s.bitmap = bitmap;\n   if (s->u.s.lang_struct)\n     s->u.s.lang_struct->u.s.bitmap |= bitmap;\n+\n+  return s;\n }\n \n /* Return the previously-defined structure with tag NAME (or a union\n@@ -305,11 +307,14 @@ create_array (type_p t, const char *len)\n   return v;\n }\n \n-/* Return an options structure with name NAME and info INFO.  */\n+/* Return an options structure with name NAME and info INFO.  NEXT is the\n+   next option in the chain.  */\n+\n options_p\n-create_option (const char *name, void *info)\n+create_option (options_p next, const char *name, const void *info)\n {\n   options_p o = XNEW (struct options);\n+  o->next = next;\n   o->name = name;\n   o->info = (const char*) info;\n   return o;\n@@ -331,6 +336,24 @@ note_variable (const char *s, type_p t, options_p o, struct fileloc *pos)\n   variables = n;\n }\n \n+/* Create a fake field with the given type and name.  NEXT is the next\n+   field in the chain.  */\n+\n+static pair_p\n+create_field (pair_p next, type_p type, const char *name)\n+{\n+  pair_p field;\n+\n+  field = XNEW (struct pair);\n+  field->next = next;\n+  field->type = type;\n+  field->name = name;\n+  field->opt = NULL;\n+  field->line.file = __FILE__;\n+  field->line.line = __LINE__;\n+  return field;\n+}\n+\n /* We don't care how long a CONST_DOUBLE is.  */\n #define CONST_DOUBLE_FORMAT \"ww\"\n /* We don't want to see codes that are only for generator files.  */\n@@ -440,10 +463,7 @@ adjust_field_rtx_def (type_p t, options_p ARG_UNUSED (opt))\n       return &string_type;\n     }\n \n-  nodot = XNEW (struct options);\n-  nodot->next = NULL;\n-  nodot->name = \"dot\";\n-  nodot->info = \"\";\n+  nodot = create_option (NULL, \"dot\", \"\");\n \n   rtx_tp = create_pointer (find_structure (\"rtx_def\", 0));\n   rtvec_tp = create_pointer (find_structure (\"rtvec_def\", 0));\n@@ -460,61 +480,46 @@ adjust_field_rtx_def (type_p t, options_p ARG_UNUSED (opt))\n \n     for (c = 0; c <= NOTE_INSN_MAX; c++)\n       {\n-\tpair_p old_note_flds = note_flds;\n-\n-\tnote_flds = XNEW (struct pair);\n-\tnote_flds->line.file = __FILE__;\n-\tnote_flds->line.line = __LINE__;\n-\tnote_flds->opt = XNEW (struct options);\n-\tnote_flds->opt->next = nodot;\n-\tnote_flds->opt->name = \"tag\";\n-\tnote_flds->opt->info = note_insn_name[c];\n-\tnote_flds->next = old_note_flds;\n-\n \tswitch (c)\n \t  {\n-\t    /* NOTE_INSN_MAX is used as the default field for line\n-\t       number notes.  */\n \t  case NOTE_INSN_MAX:\n-\t    note_flds->opt->name = \"default\";\n-\t    note_flds->name = \"rt_str\";\n-\t    note_flds->type = &string_type;\n+\t    note_flds = create_field (note_flds, &string_type, \"rt_str\");\n \t    break;\n \n \t  case NOTE_INSN_BLOCK_BEG:\n \t  case NOTE_INSN_BLOCK_END:\n-\t    note_flds->name = \"rt_tree\";\n-\t    note_flds->type = tree_tp;\n+\t    note_flds = create_field (note_flds, tree_tp, \"rt_tree\");\n \t    break;\n \n \t  case NOTE_INSN_EXPECTED_VALUE:\n \t  case NOTE_INSN_VAR_LOCATION:\n-\t    note_flds->name = \"rt_rtx\";\n-\t    note_flds->type = rtx_tp;\n+\t    note_flds = create_field (note_flds, rtx_tp, \"rt_rtx\");\n \t    break;\n \n \t  default:\n-\t    note_flds->name = \"rt_int\";\n-\t    note_flds->type = scalar_tp;\n+\t    note_flds = create_field (note_flds, scalar_tp, \"rt_int\");\n \t    break;\n \t  }\n+\t/* NOTE_INSN_MAX is used as the default field for line\n+\t   number notes.  */\n+\tif (c == NOTE_INSN_MAX)\n+\t  note_flds->opt = create_option (nodot, \"default\", \"\");\n+\telse\n+\t  note_flds->opt = create_option (nodot, \"tag\", note_insn_name[c]);\n       }\n-    new_structure (\"rtx_def_note_subunion\", 1, &lexer_line, note_flds, NULL);\n+    note_union_tp = new_structure (\"rtx_def_note_subunion\", 1,\n+\t\t\t\t   &lexer_line, note_flds, NULL);\n   }\n-\n-  note_union_tp = find_structure (\"rtx_def_note_subunion\", 1);\n-\n   for (i = 0; i < NUM_RTX_CODE; i++)\n     {\n-      pair_p old_flds = flds;\n       pair_p subfields = NULL;\n       size_t aindex, nmindex;\n       const char *sname;\n+      type_p substruct;\n       char *ftag;\n \n       for (aindex = 0; aindex < strlen (rtx_format[i]); aindex++)\n \t{\n-\t  pair_p old_subf = subfields;\n \t  type_p t;\n \t  const char *subname;\n \n@@ -614,43 +619,28 @@ adjust_field_rtx_def (type_p t, options_p ARG_UNUSED (opt))\n \t      break;\n \t    }\n \n-\t  subfields = XNEW (struct pair);\n-\t  subfields->next = old_subf;\n-\t  subfields->type = t;\n-\t  subfields->name = xasprintf (\".fld[%lu].%s\", (unsigned long)aindex,\n-\t\t\t\t       subname);\n-\t  subfields->line.file = __FILE__;\n-\t  subfields->line.line = __LINE__;\n+\t  subfields = create_field (subfields, t,\n+\t\t\t\t    xasprintf (\".fld[%lu].%s\",\n+\t\t\t\t\t       (unsigned long) aindex,\n+\t\t\t\t\t       subname));\n+\t  subfields->opt = nodot;\n \t  if (t == note_union_tp)\n-\t    {\n-\t      subfields->opt = XNEW (struct options);\n-\t      subfields->opt->next = nodot;\n-\t      subfields->opt->name = \"desc\";\n-\t      subfields->opt->info = \"NOTE_LINE_NUMBER (&%0)\";\n-\t    }\n-\t  else\n-\t    subfields->opt = nodot;\n+\t    subfields->opt = create_option (subfields->opt, \"desc\",\n+\t\t\t\t\t    \"NOTE_LINE_NUMBER (&%0)\");\n \t}\n \n-      flds = XNEW (struct pair);\n-      flds->next = old_flds;\n-      flds->name = \"\";\n       sname = xasprintf (\"rtx_def_%s\", rtx_name[i]);\n-      new_structure (sname, 0, &lexer_line, subfields, NULL);\n-      flds->type = find_structure (sname, 0);\n-      flds->line.file = __FILE__;\n-      flds->line.line = __LINE__;\n-      flds->opt = XNEW (struct options);\n-      flds->opt->next = nodot;\n-      flds->opt->name = \"tag\";\n+      substruct = new_structure (sname, 0, &lexer_line, subfields, NULL);\n+\n       ftag = xstrdup (rtx_name[i]);\n       for (nmindex = 0; nmindex < strlen (ftag); nmindex++)\n \tftag[nmindex] = TOUPPER (ftag[nmindex]);\n-      flds->opt->info = ftag;\n+\n+      flds = create_field (flds, substruct, \"\");\n+      flds->opt = create_option (nodot, \"tag\", ftag);\n     }\n \n-  new_structure (\"rtx_def_subunion\", 1, &lexer_line, flds, nodot);\n-  return find_structure (\"rtx_def_subunion\", 1);\n+  return new_structure (\"rtx_def_subunion\", 1, &lexer_line, flds, nodot);\n }\n \n /* Handle `special(\"tree_exp\")'.  This is a special case for\n@@ -672,31 +662,14 @@ adjust_field_tree_exp (type_p t, options_p opt ATTRIBUTE_UNUSED)\n       return &string_type;\n     }\n \n-  nodot = XNEW (struct options);\n-  nodot->next = NULL;\n-  nodot->name = \"dot\";\n-  nodot->info = \"\";\n-\n-  flds = XNEW (struct pair);\n-  flds->next = NULL;\n-  flds->name = \"\";\n-  flds->type = t;\n-  flds->line.file = __FILE__;\n-  flds->line.line = __LINE__;\n-  flds->opt = XNEW (struct options);\n-  flds->opt->next = nodot;\n-  flds->opt->name = \"length\";\n-  flds->opt->info = \"TREE_CODE_LENGTH (TREE_CODE ((tree) &%0))\";\n-  {\n-    options_p oldopt = flds->opt;\n-    flds->opt = XNEW (struct options);\n-    flds->opt->next = oldopt;\n-    flds->opt->name = \"default\";\n-    flds->opt->info = \"\";\n-  }\n+  nodot = create_option (NULL, \"dot\", \"\");\n+\n+  flds = create_field (NULL, t, \"\");\n+  flds->opt = create_option (nodot, \"length\",\n+\t\t\t     \"TREE_CODE_LENGTH (TREE_CODE ((tree) &%0))\");\n+  flds->opt = create_option (flds->opt, \"default\", \"\");\n \n-  new_structure (\"tree_exp_subunion\", 1, &lexer_line, flds, nodot);\n-  return find_structure (\"tree_exp_subunion\", 1);\n+  return new_structure (\"tree_exp_subunion\", 1, &lexer_line, flds, nodot);\n }\n \n /* Perform any special processing on a type T, about to become the type\n@@ -841,8 +814,7 @@ note_yacc_type (options_p o, pair_p fields, pair_p typeinfo,\n \tp_p = &p->next;\n     }\n \n-  new_structure (\"yy_union\", 1, pos, typeinfo, o);\n-  do_typedef (\"YYSTYPE\", find_structure (\"yy_union\", 1), pos);\n+  do_typedef (\"YYSTYPE\", new_structure (\"yy_union\", 1, pos, typeinfo, o), pos);\n }\n \f\n static void process_gc_options (options_p, enum gc_used_enum,"}, {"sha": "cb44b97fcc814994c5f2d35c063574da46b38b8e", "filename": "gcc/gengtype.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f01f026dc4f3f265545bd112583c4756933e31a/gcc%2Fgengtype.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f01f026dc4f3f265545bd112583c4756933e31a/gcc%2Fgengtype.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.h?ref=0f01f026dc4f3f265545bd112583c4756933e31a", "patch": "@@ -133,14 +133,14 @@ extern char * xasprintf (const char *, ...)\n /* Constructor routines for types.  */\n extern void do_typedef (const char *s, type_p t, struct fileloc *pos);\n extern type_p resolve_typedef (const char *s, struct fileloc *pos);\n-extern void new_structure (const char *name, int isunion, \n-\t\t\t   struct fileloc *pos, pair_p fields, \n-\t\t\t   options_p o);\n+extern type_p new_structure (const char *name, int isunion,\n+\t\t\t     struct fileloc *pos, pair_p fields,\n+\t\t\t     options_p o);\n extern type_p find_structure (const char *s, int isunion);\n extern type_p create_scalar_type (const char *name, size_t name_len);\n extern type_p create_pointer (type_p t);\n extern type_p create_array (type_p t, const char *len);\n-extern options_p create_option (const char *name, void *info);\n+extern options_p create_option (options_p, const char *name, const void *info);\n extern type_p adjust_field_type (type_p, options_p);\n extern void note_variable (const char *s, type_p t, options_p o,\n \t\t\t   struct fileloc *pos);"}]}