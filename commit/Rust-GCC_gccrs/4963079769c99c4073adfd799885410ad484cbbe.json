{"sha": "4963079769c99c4073adfd799885410ad484cbbe", "node_id": "C_kwDOANBUbNoAKDQ5NjMwNzk3NjljOTljNDA3M2FkZmQ3OTk4ODU0MTBhZDQ4NGNiYmU", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2022-02-15T18:09:33Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2022-02-15T18:09:33Z"}, "message": "vect+aarch64: Fix ldp_stp_* regressions\n\nldp_stp_1.c, ldp_stp_4.c and ldp_stp_5.c have been failing since\nvectorisation was enabled at -O2.  In all three cases SLP is\ngenerating vector code when scalar code would be better.\n\nThe problem is that the target costs do not model whether STP could\nbe used for the scalar or vector code, so the normal latency-based\ncosts for store-heavy code can be way off.  It would be good to fix\nthat \u201cproperly\u201d at some point, but it isn't easy; see the existing\ndiscussion in aarch64_sve_adjust_stmt_cost for more details.\n\nThis patch therefore adds an on-the-side check for whether the\ncode is doing nothing more than set-up+stores.  It then applies\nSTP-based costs to those cases only, in addition to the normal\nlatency-based costs.  (That is, the vector code has to win on\nboth counts rather than on one count individually.)\n\nHowever, at the moment, SLP costs one vector set-up instruction\nfor every vector in an SLP node, even if the contents are the\nsame as a previous vector in the same node.  Fixing the STP costs\nwithout fixing that would regress other cases, tested in the patch.\n\nThe patch therefore makes the SLP costing code check for duplicates\nwithin a node.  Ideally we'd check for duplicates more globally,\nbut that would require a more global approach to costs: the cost\nof an initialisation should be amoritised across all trees that\nuse the initialisation, rather than fully counted against one\narbitrarily-chosen subtree.\n\nBack on aarch64: an earlier version of the patch tried to apply\nthe new heuristic to constant stores.  However, that didn't work\ntoo well in practice; see the comments for details.  The patch\ntherefore just tests the status quo for constant cases, leaving out\na match if the current choice is dubious.\n\nldp_stp_5.c was affected by the same thing.  The test would be\nworth vectorising if we generated better vector code, but:\n\n(1) We do a bad job of moving the { -1, 1 } constant, given that\n    we have { -1, -1 } and { 1, 1 } to hand.\n\n(2) The vector code has 6 pairable stores to misaligned offsets.\n    We have peephole patterns to handle such misalignment for\n    4 pairable stores, but not 6.\n\nSo the SLP decision isn't wrong as such.  It's just being let\ndown by later codegen.\n\nThe patch therefore adds -mstrict-align to preserve the original\nintention of the test while adding ldp_stp_19.c to check for the\npreferred vector code (XFAILed for now).\n\ngcc/\n\t* tree-vectorizer.h (vect_scalar_ops_slice): New struct.\n\t(vect_scalar_ops_slice_hash): Likewise.\n\t(vect_scalar_ops_slice::op): New function.\n\t* tree-vect-slp.cc (vect_scalar_ops_slice::all_same_p): New function.\n\t(vect_scalar_ops_slice_hash::hash): Likewise.\n\t(vect_scalar_ops_slice_hash::equal): Likewise.\n\t(vect_prologue_cost_for_slp): Check for duplicate vectors.\n\t* config/aarch64/aarch64.cc\n\t(aarch64_vector_costs::m_stp_sequence_cost): New member variable.\n\t(aarch64_aligned_constant_offset_p): New function.\n\t(aarch64_stp_sequence_cost): Likewise.\n\t(aarch64_vector_costs::add_stmt_cost): Handle new STP heuristic.\n\t(aarch64_vector_costs::finish_cost): Likewise.\n\ngcc/testsuite/\n\t* gcc.target/aarch64/ldp_stp_5.c: Require -mstrict-align.\n\t* gcc.target/aarch64/ldp_stp_14.h,\n\t* gcc.target/aarch64/ldp_stp_14.c: New test.\n\t* gcc.target/aarch64/ldp_stp_15.c: Likewise.\n\t* gcc.target/aarch64/ldp_stp_16.c: Likewise.\n\t* gcc.target/aarch64/ldp_stp_17.c: Likewise.\n\t* gcc.target/aarch64/ldp_stp_18.c: Likewise.\n\t* gcc.target/aarch64/ldp_stp_19.c: Likewise.", "tree": {"sha": "ec53951399724d809c6296a30e7a06e81d3e72a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ec53951399724d809c6296a30e7a06e81d3e72a8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4963079769c99c4073adfd799885410ad484cbbe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4963079769c99c4073adfd799885410ad484cbbe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4963079769c99c4073adfd799885410ad484cbbe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4963079769c99c4073adfd799885410ad484cbbe/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "63a9328cb8c601377fe73e214b708c4ae0441847", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63a9328cb8c601377fe73e214b708c4ae0441847", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63a9328cb8c601377fe73e214b708c4ae0441847"}], "stats": {"total": 910, "additions": 884, "deletions": 26}, "files": [{"sha": "1a460d4bac0322b98f774e5f81009e14c9fa3a15", "filename": "gcc/config/aarch64/aarch64.cc", "status": "modified", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4963079769c99c4073adfd799885410ad484cbbe/gcc%2Fconfig%2Faarch64%2Faarch64.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4963079769c99c4073adfd799885410ad484cbbe/gcc%2Fconfig%2Faarch64%2Faarch64.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.cc?ref=4963079769c99c4073adfd799885410ad484cbbe", "patch": "@@ -14932,6 +14932,31 @@ class aarch64_vector_costs : public vector_costs\n      - If M_VEC_FLAGS & VEC_ANY_SVE is nonzero then we're costing SVE code.  */\n   unsigned int m_vec_flags = 0;\n \n+  /* At the moment, we do not model LDP and STP in the vector and scalar costs.\n+     This means that code such as:\n+\n+\ta[0] = x;\n+\ta[1] = x;\n+\n+     will be costed as two scalar instructions and two vector instructions\n+     (a scalar_to_vec and an unaligned_store).  For SLP, the vector form\n+     wins if the costs are equal, because of the fact that the vector costs\n+     include constant initializations whereas the scalar costs don't.\n+     We would therefore tend to vectorize the code above, even though\n+     the scalar version can use a single STP.\n+\n+     We should eventually fix this and model LDP and STP in the main costs;\n+     see the comment in aarch64_sve_adjust_stmt_cost for some of the problems.\n+     Until then, we look specifically for code that does nothing more than\n+     STP-like operations.  We cost them on that basis in addition to the\n+     normal latency-based costs.\n+\n+     If the scalar or vector code could be a sequence of STPs +\n+     initialization, this variable counts the cost of the sequence,\n+     with 2 units per instruction.  The variable is ~0U for other\n+     kinds of code.  */\n+  unsigned int m_stp_sequence_cost = 0;\n+\n   /* On some CPUs, SVE and Advanced SIMD provide the same theoretical vector\n      throughput, such as 4x128 Advanced SIMD vs. 2x256 SVE.  In those\n      situations, we try to predict whether an Advanced SIMD implementation\n@@ -15724,6 +15749,104 @@ aarch64_vector_costs::count_ops (unsigned int count, vect_cost_for_stmt kind,\n     }\n }\n \n+/* Return true if STMT_INFO contains a memory access and if the constant\n+   component of the memory address is aligned to SIZE bytes.  */\n+static bool\n+aarch64_aligned_constant_offset_p (stmt_vec_info stmt_info,\n+\t\t\t\t   poly_uint64 size)\n+{\n+  if (!STMT_VINFO_DATA_REF (stmt_info))\n+    return false;\n+\n+  if (auto first_stmt = DR_GROUP_FIRST_ELEMENT (stmt_info))\n+    stmt_info = first_stmt;\n+  tree constant_offset = DR_INIT (STMT_VINFO_DATA_REF (stmt_info));\n+  /* Needed for gathers & scatters, for example.  */\n+  if (!constant_offset)\n+    return false;\n+\n+  return multiple_p (wi::to_poly_offset (constant_offset), size);\n+}\n+\n+/* Check if a scalar or vector stmt could be part of a region of code\n+   that does nothing more than store values to memory, in the scalar\n+   case using STP.  Return the cost of the stmt if so, counting 2 for\n+   one instruction.  Return ~0U otherwise.\n+\n+   The arguments are a subset of those passed to add_stmt_cost.  */\n+unsigned int\n+aarch64_stp_sequence_cost (unsigned int count, vect_cost_for_stmt kind,\n+\t\t\t   stmt_vec_info stmt_info, tree vectype)\n+{\n+  /* Code that stores vector constants uses a vector_load to create\n+     the constant.  We don't apply the heuristic to that case for two\n+     main reasons:\n+\n+     - At the moment, STPs are only formed via peephole2, and the\n+       constant scalar moves would often come between STRs and so\n+       prevent STP formation.\n+\n+     - The scalar code also has to load the constant somehow, and that\n+       isn't costed.  */\n+  switch (kind)\n+    {\n+    case scalar_to_vec:\n+      /* Count 2 insns for a GPR->SIMD dup and 1 insn for a FPR->SIMD dup.  */\n+      return (FLOAT_TYPE_P (vectype) ? 2 : 4) * count;\n+\n+    case vec_construct:\n+      if (FLOAT_TYPE_P (vectype))\n+\t/* Count 1 insn for the maximum number of FP->SIMD INS\n+\t   instructions.  */\n+\treturn (vect_nunits_for_cost (vectype) - 1) * 2 * count;\n+\n+      /* Count 2 insns for a GPR->SIMD move and 2 insns for the\n+\t maximum number of GPR->SIMD INS instructions.  */\n+      return vect_nunits_for_cost (vectype) * 4 * count;\n+\n+    case vector_store:\n+    case unaligned_store:\n+      /* Count 1 insn per vector if we can't form STP Q pairs.  */\n+      if (aarch64_sve_mode_p (TYPE_MODE (vectype)))\n+\treturn count * 2;\n+      if (aarch64_tune_params.extra_tuning_flags\n+\t  & AARCH64_EXTRA_TUNE_NO_LDP_STP_QREGS)\n+\treturn count * 2;\n+\n+      if (stmt_info)\n+\t{\n+\t  /* Assume we won't be able to use STP if the constant offset\n+\t     component of the address is misaligned.  ??? This could be\n+\t     removed if we formed STP pairs earlier, rather than relying\n+\t     on peephole2.  */\n+\t  auto size = GET_MODE_SIZE (TYPE_MODE (vectype));\n+\t  if (!aarch64_aligned_constant_offset_p (stmt_info, size))\n+\t    return count * 2;\n+\t}\n+      return CEIL (count, 2) * 2;\n+\n+    case scalar_store:\n+      if (stmt_info && STMT_VINFO_DATA_REF (stmt_info))\n+\t{\n+\t  /* Check for a mode in which STP pairs can be formed.  */\n+\t  auto size = GET_MODE_SIZE (TYPE_MODE (aarch64_dr_type (stmt_info)));\n+\t  if (maybe_ne (size, 4) && maybe_ne (size, 8))\n+\t    return ~0U;\n+\n+\t  /* Assume we won't be able to use STP if the constant offset\n+\t     component of the address is misaligned.  ??? This could be\n+\t     removed if we formed STP pairs earlier, rather than relying\n+\t     on peephole2.  */\n+\t  if (!aarch64_aligned_constant_offset_p (stmt_info, size))\n+\t    return ~0U;\n+\t}\n+      return count;\n+\n+    default:\n+      return ~0U;\n+    }\n+}\n+\n unsigned\n aarch64_vector_costs::add_stmt_cost (int count, vect_cost_for_stmt kind,\n \t\t\t\t     stmt_vec_info stmt_info, tree vectype,\n@@ -15747,6 +15870,14 @@ aarch64_vector_costs::add_stmt_cost (int count, vect_cost_for_stmt kind,\n       m_analyzed_vinfo = true;\n     }\n \n+  /* Apply the heuristic described above m_stp_sequence_cost.  */\n+  if (m_stp_sequence_cost != ~0U)\n+    {\n+      uint64_t cost = aarch64_stp_sequence_cost (count, kind,\n+\t\t\t\t\t\t stmt_info, vectype);\n+      m_stp_sequence_cost = MIN (m_stp_sequence_cost + cost, ~0U);\n+    }\n+\n   /* Try to get a more accurate cost by looking at STMT_INFO instead\n      of just looking at KIND.  */\n   if (stmt_info && aarch64_use_new_vector_costs_p ())\n@@ -16017,6 +16148,15 @@ aarch64_vector_costs::finish_cost (const vector_costs *uncast_scalar_costs)\n     m_costs[vect_body] = adjust_body_cost (loop_vinfo, scalar_costs,\n \t\t\t\t\t   m_costs[vect_body]);\n \n+  /* Apply the heuristic described above m_stp_sequence_cost.  Prefer\n+     the scalar code in the event of a tie, since there is more chance\n+     of scalar code being optimized with surrounding operations.  */\n+  if (!loop_vinfo\n+      && scalar_costs\n+      && m_stp_sequence_cost != ~0U\n+      && m_stp_sequence_cost >= scalar_costs->m_stp_sequence_cost)\n+    m_costs[vect_body] = 2 * scalar_costs->total_cost ();\n+\n   vector_costs::finish_cost (scalar_costs);\n }\n "}, {"sha": "c7b5f7d6b391ed7f81f0a2c0691c6ab53dff6696", "filename": "gcc/testsuite/gcc.target/aarch64/ldp_stp_14.c", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4963079769c99c4073adfd799885410ad484cbbe/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4963079769c99c4073adfd799885410ad484cbbe/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_14.c?ref=4963079769c99c4073adfd799885410ad484cbbe", "patch": "@@ -0,0 +1,89 @@\n+/* { dg-options \"-O2 -fno-tree-loop-distribute-patterns\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" \"\" { target lp64 } } } */\n+\n+#include \"ldp_stp_14.h\"\n+\n+/*\n+** const_2_int16_t_0:\n+**\tstr\twzr, \\[x0\\]\n+**\tret\n+*/\n+CONST_FN (2, int16_t, 0);\n+\n+/*\n+** const_4_int16_t_0:\n+**\tstr\txzr, \\[x0\\]\n+**\tret\n+*/\n+CONST_FN (4, int16_t, 0);\n+\n+/*\n+** const_8_int16_t_0:\n+**\tstp\txzr, xzr, \\[x0\\]\n+**\tret\n+*/\n+CONST_FN (8, int16_t, 0);\n+\n+/* No preference between vectorizing or not vectorizing here.  */\n+CONST_FN (16, int16_t, 0);\n+\n+/*\n+** const_32_int16_t_0:\n+**\tmovi\tv([0-9]+)\\.4s, .*\n+**\tstp\tq\\1, q\\1, \\[x0\\]\n+**\tstp\tq\\1, q\\1, \\[x0, #?32\\]\n+**\tret\n+*/\n+CONST_FN (32, int16_t, 0);\n+\n+/* No preference between vectorizing or not vectorizing here.  */\n+CONST_FN (2, int16_t, 1);\n+\n+/*\n+** const_4_int16_t_1:\n+**\tmovi\tv([0-9]+)\\.4h, .*\n+**\tstr\td\\1, \\[x0\\]\n+**\tret\n+*/\n+CONST_FN (4, int16_t, 1);\n+\n+/*\n+** const_8_int16_t_1:\n+**\tmovi\tv([0-9]+)\\.8h, .*\n+**\tstr\tq\\1, \\[x0\\]\n+**\tret\n+*/\n+CONST_FN (8, int16_t, 1);\n+\n+/* Fuzzy match due to PR104387.  */\n+/*\n+** dup_2_int16_t:\n+**\t...\n+**\tstrh\tw1, \\[x0, #?2\\]\n+**\tret\n+*/\n+DUP_FN (2, int16_t);\n+\n+/*\n+** dup_4_int16_t:\n+**\tdup\tv([0-9]+)\\.4h, w1\n+**\tstr\td\\1, \\[x0\\]\n+**\tret\n+*/\n+DUP_FN (4, int16_t);\n+\n+/*\n+** dup_8_int16_t:\n+**\tdup\tv([0-9]+)\\.8h, w1\n+**\tstr\tq\\1, \\[x0\\]\n+**\tret\n+*/\n+DUP_FN (8, int16_t);\n+\n+/*\n+** cons2_1_int16_t:\n+**\tstrh\tw1, \\[x0\\]\n+**\tstrh\tw2, \\[x0, #?2\\]\n+**\tret\n+*/\n+CONS2_FN (1, int16_t);"}, {"sha": "39c463ff2401af350748e74d6b21aab7db5d40d6", "filename": "gcc/testsuite/gcc.target/aarch64/ldp_stp_14.h", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4963079769c99c4073adfd799885410ad484cbbe/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_14.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4963079769c99c4073adfd799885410ad484cbbe/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_14.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_14.h?ref=4963079769c99c4073adfd799885410ad484cbbe", "patch": "@@ -0,0 +1,50 @@\n+#include <stdint.h>\n+\n+#define PRAGMA(X) _Pragma (#X)\n+#define UNROLL(COUNT) PRAGMA (GCC unroll (COUNT))\n+\n+#define CONST_FN(COUNT, TYPE, VAL)\t\t\\\n+  void\t\t\t\t\t\t\\\n+  const_##COUNT##_##TYPE##_##VAL (TYPE *x)\t\\\n+  {\t\t\t\t\t\t\\\n+    UNROLL (COUNT)\t\t\t\t\\\n+    for (int i = 0; i < COUNT; ++i)\t\t\\\n+      x[i] = VAL;\t\t\t\t\\\n+  }\n+\n+#define DUP_FN(COUNT, TYPE)\t\t\t\\\n+  void\t\t\t\t\t\t\\\n+  dup_##COUNT##_##TYPE (TYPE *x, TYPE val)\t\\\n+  {\t\t\t\t\t\t\\\n+    UNROLL (COUNT)\t\t\t\t\\\n+    for (int i = 0; i < COUNT; ++i)\t\t\\\n+      x[i] = val;\t\t\t\t\\\n+  }\n+\n+#define CONS2_FN(COUNT, TYPE)\t\t\t\t\t\\\n+  void\t\t\t\t\t\t\t\t\\\n+  cons2_##COUNT##_##TYPE (TYPE *x, TYPE val0, TYPE val1)\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    UNROLL (COUNT)\t\t\t\t\t\t\\\n+    for (int i = 0; i < COUNT * 2; i += 2)\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tx[i + 0] = val0;\t\t\t\t\t\\\n+\tx[i + 1] = val1;\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  }\n+\n+#define CONS4_FN(COUNT, TYPE)\t\t\t\t\t\\\n+  void\t\t\t\t\t\t\t\t\\\n+  cons4_##COUNT##_##TYPE (TYPE *x, TYPE val0, TYPE val1,\t\\\n+\t\t\t  TYPE val2, TYPE val3)\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    UNROLL (COUNT)\t\t\t\t\t\t\\\n+    for (int i = 0; i < COUNT * 4; i += 4)\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tx[i + 0] = val0;\t\t\t\t\t\\\n+\tx[i + 1] = val1;\t\t\t\t\t\\\n+\tx[i + 2] = val2;\t\t\t\t\t\\\n+\tx[i + 3] = val3;\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  }\n+"}, {"sha": "131cd0a63c83f37f441f816f8745110c80704e02", "filename": "gcc/testsuite/gcc.target/aarch64/ldp_stp_15.c", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4963079769c99c4073adfd799885410ad484cbbe/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4963079769c99c4073adfd799885410ad484cbbe/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_15.c?ref=4963079769c99c4073adfd799885410ad484cbbe", "patch": "@@ -0,0 +1,137 @@\n+/* { dg-options \"-O2 -fno-tree-loop-distribute-patterns\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" \"\" { target lp64 } } } */\n+\n+#include \"ldp_stp_14.h\"\n+\n+/*\n+** const_2_int32_t_0:\n+**\tstr\txzr, \\[x0\\]\n+**\tret\n+*/\n+CONST_FN (2, int32_t, 0);\n+\n+/*\n+** const_4_int32_t_0:\n+**\tstp\txzr, xzr, \\[x0\\]\n+**\tret\n+*/\n+CONST_FN (4, int32_t, 0);\n+\n+/* No preference between vectorizing or not vectorizing here.  */\n+CONST_FN (8, int32_t, 0);\n+\n+/*\n+** const_16_int32_t_0:\n+**\tmovi\tv([0-9]+)\\.4s, .*\n+**\tstp\tq\\1, q\\1, \\[x0\\]\n+**\tstp\tq\\1, q\\1, \\[x0, #?32\\]\n+**\tret\n+*/\n+CONST_FN (16, int32_t, 0);\n+\n+/* No preference between vectorizing or not vectorizing here.  */\n+CONST_FN (2, int32_t, 1);\n+\n+/*\n+** const_4_int32_t_1:\n+**\tmovi\tv([0-9]+)\\.4s, .*\n+**\tstr\tq\\1, \\[x0\\]\n+**\tret\n+*/\n+CONST_FN (4, int32_t, 1);\n+\n+/*\n+** const_8_int32_t_1:\n+**\tmovi\tv([0-9]+)\\.4s, .*\n+**\tstp\tq\\1, q\\1, \\[x0\\]\n+**\tret\n+*/\n+CONST_FN (8, int32_t, 1);\n+\n+/*\n+** dup_2_int32_t:\n+**\tstp\tw1, w1, \\[x0\\]\n+**\tret\n+*/\n+DUP_FN (2, int32_t);\n+\n+/*\n+** dup_4_int32_t:\n+**\tstp\tw1, w1, \\[x0\\]\n+**\tstp\tw1, w1, \\[x0, #?8\\]\n+**\tret\n+*/\n+DUP_FN (4, int32_t);\n+\n+/*\n+** dup_8_int32_t:\n+**\tdup\tv([0-9]+)\\.4s, w1\n+**\tstp\tq\\1, q\\1, \\[x0\\]\n+**\tret\n+*/\n+DUP_FN (8, int32_t);\n+\n+/*\n+** cons2_1_int32_t:\n+**\tstp\tw1, w2, \\[x0\\]\n+**\tret\n+*/\n+CONS2_FN (1, int32_t);\n+\n+/*\n+** cons2_2_int32_t:\n+**\tstp\tw1, w2, \\[x0\\]\n+**\tstp\tw1, w2, \\[x0, #?8\\]\n+**\tret\n+*/\n+CONS2_FN (2, int32_t);\n+\n+/*\n+** cons2_4_int32_t:\n+**\tstp\tw1, w2, \\[x0\\]\n+**\tstp\tw1, w2, \\[x0, #?8\\]\n+**\tstp\tw1, w2, \\[x0, #?16\\]\n+**\tstp\tw1, w2, \\[x0, #?24\\]\n+**\tret\n+*/\n+CONS2_FN (4, int32_t);\n+\n+/* No preference between vectorizing or not vectorizing here.  */\n+CONS2_FN (8, int32_t);\n+\n+/*\n+** cons2_16_int32_t:\n+**\t...\n+**\tstp\tq[0-9]+, .*\n+**\tret\n+*/\n+CONS2_FN (16, int32_t);\n+\n+/*\n+** cons4_1_int32_t:\n+**\tstp\tw1, w2, \\[x0\\]\n+**\tstp\tw3, w4, \\[x0, #?8\\]\n+**\tret\n+*/\n+CONS4_FN (1, int32_t);\n+\n+/*\n+** cons4_2_int32_t:\n+**\tstp\tw1, w2, \\[x0\\]\n+**\tstp\tw3, w4, \\[x0, #?8\\]\n+**\tstp\tw1, w2, \\[x0, #?16\\]\n+**\tstp\tw3, w4, \\[x0, #?24\\]\n+**\tret\n+*/\n+CONS4_FN (2, int32_t);\n+\n+/* No preference between vectorizing or not vectorizing here.  */\n+CONS4_FN (4, int32_t);\n+\n+/*\n+** cons4_8_int32_t:\n+**\t...\n+**\tstp\tq[0-9]+, .*\n+**\tret\n+*/\n+CONS4_FN (8, int32_t);"}, {"sha": "8ab117c4dcd7a731abc7e1b039e1faf0dfa09a5d", "filename": "gcc/testsuite/gcc.target/aarch64/ldp_stp_16.c", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4963079769c99c4073adfd799885410ad484cbbe/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4963079769c99c4073adfd799885410ad484cbbe/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_16.c?ref=4963079769c99c4073adfd799885410ad484cbbe", "patch": "@@ -0,0 +1,133 @@\n+/* { dg-options \"-O2 -fno-tree-loop-distribute-patterns\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" \"\" { target lp64 } } } */\n+\n+#include \"ldp_stp_14.h\"\n+\n+/*\n+** const_2_float_0:\n+**\tstr\txzr, \\[x0\\]\n+**\tret\n+*/\n+CONST_FN (2, float, 0);\n+\n+/*\n+** const_4_float_0:\n+**\tstp\txzr, xzr, \\[x0\\]\n+**\tret\n+*/\n+CONST_FN (4, float, 0);\n+\n+/* No preference between vectorizing or not vectorizing here.  */\n+CONST_FN (8, float, 0);\n+\n+/*\n+** const_16_float_0:\n+**\tmovi\tv([0-9]+)\\.4s, .*\n+**\tstp\tq\\1, q\\1, \\[x0\\]\n+**\tstp\tq\\1, q\\1, \\[x0, #?32\\]\n+**\tret\n+*/\n+CONST_FN (16, float, 0);\n+\n+/*\n+** const_2_float_1:\n+**\tfmov\tv([0-9]+)\\.2s, .*\n+**\tstr\td\\1, \\[x0\\]\n+**\tret\n+*/\n+CONST_FN (2, float, 1);\n+\n+/*\n+** const_4_float_1:\n+**\tfmov\tv([0-9]+)\\.4s, .*\n+**\tstr\tq\\1, \\[x0\\]\n+**\tret\n+*/\n+CONST_FN (4, float, 1);\n+\n+/*\n+** dup_2_float:\n+**\tstp\ts0, s0, \\[x0\\]\n+**\tret\n+*/\n+DUP_FN (2, float);\n+\n+/* No preference between vectorizing or not vectorizing here.  */\n+DUP_FN (4, float);\n+\n+/*\n+** dup_8_float:\n+**\tdup\tv([0-9]+)\\.4s, v0.s\\[0\\]\n+**\tstp\tq\\1, q\\1, \\[x0\\]\n+**\tret\n+*/\n+DUP_FN (8, float);\n+\n+/*\n+** cons2_1_float:\n+**\tstp\ts0, s1, \\[x0\\]\n+**\tret\n+*/\n+CONS2_FN (1, float);\n+\n+/*\n+** cons2_2_float:\n+**\tstp\ts0, s1, \\[x0\\]\n+**\tstp\ts0, s1, \\[x0, #?8\\]\n+**\tret\n+*/\n+CONS2_FN (2, float);\n+\n+/*\n+** cons2_4_float:\t{ target aarch64_little_endian }\n+**\tins\tv0.s\\[1\\], v1.s\\[0\\]\n+**\tstp\td0, d0, \\[x0\\]\n+**\tstp\td0, d0, \\[x0, #?16\\]\n+**\tret\n+*/\n+/*\n+** cons2_4_float:\t{ target aarch64_big_endian }\n+**\tins\tv1.s\\[1\\], v0.s\\[0\\]\n+**\tstp\td1, d1, \\[x0\\]\n+**\tstp\td1, d1, \\[x0, #?16\\]\n+**\tret\n+*/\n+CONS2_FN (4, float);\n+\n+/*\n+** cons2_8_float:\n+**\tdup\tv([0-9]+)\\.4s, .*\n+**\t...\n+**\tstp\tq\\1, q\\1, \\[x0\\]\n+**\tstp\tq\\1, q\\1, \\[x0, #?32\\]\n+**\tret\n+*/\n+CONS2_FN (8, float);\n+\n+/*\n+** cons4_1_float:\n+**\tstp\ts0, s1, \\[x0\\]\n+**\tstp\ts2, s3, \\[x0, #?8\\]\n+**\tret\n+*/\n+CONS4_FN (1, float);\n+\n+/*\n+** cons4_2_float:\n+**\tstp\ts0, s1, \\[x0\\]\n+**\tstp\ts2, s3, \\[x0, #?8\\]\n+**\tstp\ts0, s1, \\[x0, #?16\\]\n+**\tstp\ts2, s3, \\[x0, #?24\\]\n+**\tret\n+*/\n+CONS4_FN (2, float);\n+\n+/*\n+** cons4_4_float:\n+**\tins\tv([0-9]+)\\.s.*\n+**\t...\n+**\tstp\tq\\1, q\\1, \\[x0\\]\n+**\tstp\tq\\1, q\\1, \\[x0, #?32\\]\n+**\tret\n+*/\n+CONS4_FN (4, float);"}, {"sha": "c1122fc07d5ba32b5b4d9b07eead044506084379", "filename": "gcc/testsuite/gcc.target/aarch64/ldp_stp_17.c", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4963079769c99c4073adfd799885410ad484cbbe/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4963079769c99c4073adfd799885410ad484cbbe/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_17.c?ref=4963079769c99c4073adfd799885410ad484cbbe", "patch": "@@ -0,0 +1,120 @@\n+/* { dg-options \"-O2 -fno-tree-loop-distribute-patterns\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" \"\" { target lp64 } } } */\n+\n+#include \"ldp_stp_14.h\"\n+\n+/*\n+** const_2_int64_t_0:\n+**\tstp\txzr, xzr, \\[x0\\]\n+**\tret\n+*/\n+CONST_FN (2, int64_t, 0);\n+\n+/* No preference between vectorizing or not vectorizing here.  */\n+CONST_FN (4, int64_t, 0);\n+\n+/*\n+** const_8_int64_t_0:\n+**\tmovi\tv([0-9]+)\\.4s, .*\n+**\tstp\tq\\1, q\\1, \\[x0\\]\n+**\tstp\tq\\1, q\\1, \\[x0, #?32\\]\n+**\tret\n+*/\n+CONST_FN (8, int64_t, 0);\n+\n+/*\n+** dup_2_int64_t:\n+**\tstp\tx1, x1, \\[x0\\]\n+**\tret\n+*/\n+DUP_FN (2, int64_t);\n+\n+/*\n+** dup_4_int64_t:\n+**\tstp\tx1, x1, \\[x0\\]\n+**\tstp\tx1, x1, \\[x0, #?16\\]\n+**\tret\n+*/\n+DUP_FN (4, int64_t);\n+\n+/* No preference between vectorizing or not vectorizing here.  */\n+DUP_FN (8, int64_t);\n+\n+/*\n+** dup_16_int64_t:\n+**\tdup\tv([0-9])\\.2d, x1\n+**\tstp\tq\\1, q\\1, \\[x0\\]\n+**\tstp\tq\\1, q\\1, \\[x0, #?32\\]\n+**\tstp\tq\\1, q\\1, \\[x0, #?64\\]\n+**\tstp\tq\\1, q\\1, \\[x0, #?96\\]\n+**\tret\n+*/\n+DUP_FN (16, int64_t);\n+\n+/*\n+** cons2_1_int64_t:\n+**\tstp\tx1, x2, \\[x0\\]\n+**\tret\n+*/\n+CONS2_FN (1, int64_t);\n+\n+/*\n+** cons2_2_int64_t:\n+**\tstp\tx1, x2, \\[x0\\]\n+**\tstp\tx1, x2, \\[x0, #?16\\]\n+**\tret\n+*/\n+CONS2_FN (2, int64_t);\n+\n+/*\n+** cons2_4_int64_t:\n+**\tstp\tx1, x2, \\[x0\\]\n+**\tstp\tx1, x2, \\[x0, #?16\\]\n+**\tstp\tx1, x2, \\[x0, #?32\\]\n+**\tstp\tx1, x2, \\[x0, #?48\\]\n+**\tret\n+*/\n+CONS2_FN (4, int64_t);\n+\n+/* No preference between vectorizing or not vectorizing here.  */\n+CONS2_FN (8, int64_t);\n+\n+/*\n+** cons2_16_int64_t:\n+**\t...\n+**\tstp\tq[0-9]+, .*\n+**\tret\n+*/\n+CONS2_FN (16, int64_t);\n+\n+/*\n+** cons4_1_int64_t:\n+**\tstp\tx1, x2, \\[x0\\]\n+**\tstp\tx3, x4, \\[x0, #?16\\]\n+**\tret\n+*/\n+CONS4_FN (1, int64_t);\n+\n+/*\n+** cons4_2_int64_t:\n+**\tstp\tx1, x2, \\[x0\\]\n+**\tstp\tx3, x4, \\[x0, #?16\\]\n+**\tstp\tx1, x2, \\[x0, #?32\\]\n+**\tstp\tx3, x4, \\[x0, #?48\\]\n+**\tret\n+*/\n+CONS4_FN (2, int64_t);\n+\n+/* No preference between vectorizing or not vectorizing here.  */\n+CONS4_FN (4, int64_t);\n+\n+/* We should probably vectorize this, but currently don't.  */\n+CONS4_FN (8, int64_t);\n+\n+/*\n+** cons4_16_int64_t:\n+**\t...\n+**\tstp\tq[0-9]+, .*\n+**\tret\n+*/\n+CONS4_FN (16, int64_t);"}, {"sha": "eaa855c3859a736012871584b0906bf93bc3d36c", "filename": "gcc/testsuite/gcc.target/aarch64/ldp_stp_18.c", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4963079769c99c4073adfd799885410ad484cbbe/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4963079769c99c4073adfd799885410ad484cbbe/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_18.c?ref=4963079769c99c4073adfd799885410ad484cbbe", "patch": "@@ -0,0 +1,123 @@\n+/* { dg-options \"-O2 -fno-tree-loop-distribute-patterns\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" \"\" { target lp64 } } } */\n+\n+#include \"ldp_stp_14.h\"\n+\n+/*\n+** const_2_double_0:\n+**\tstp\txzr, xzr, \\[x0\\]\n+**\tret\n+*/\n+CONST_FN (2, double, 0);\n+\n+/* No preference between vectorizing or not vectorizing here.  */\n+CONST_FN (4, double, 0);\n+\n+/*\n+** const_8_double_0:\n+**\tmovi\tv([0-9]+)\\.2d, .*\n+**\tstp\tq\\1, q\\1, \\[x0\\]\n+**\tstp\tq\\1, q\\1, \\[x0, #?32\\]\n+**\tret\n+*/\n+CONST_FN (8, double, 0);\n+\n+/*\n+** dup_2_double:\n+**\tstp\td0, d0, \\[x0\\]\n+**\tret\n+*/\n+DUP_FN (2, double);\n+\n+/*\n+** dup_4_double:\n+**\tstp\td0, d0, \\[x0\\]\n+**\tstp\td0, d0, \\[x0, #?16\\]\n+**\tret\n+*/\n+DUP_FN (4, double);\n+\n+/*\n+** dup_8_double:\n+**\tdup\tv([0-9])\\.2d, v0\\.d\\[0\\]\n+**\tstp\tq\\1, q\\1, \\[x0\\]\n+**\tstp\tq\\1, q\\1, \\[x0, #?32\\]\n+**\tret\n+*/\n+DUP_FN (8, double);\n+\n+/*\n+** dup_16_double:\n+**\tdup\tv([0-9])\\.2d, v0\\.d\\[0\\]\n+**\tstp\tq\\1, q\\1, \\[x0\\]\n+**\tstp\tq\\1, q\\1, \\[x0, #?32\\]\n+**\tstp\tq\\1, q\\1, \\[x0, #?64\\]\n+**\tstp\tq\\1, q\\1, \\[x0, #?96\\]\n+**\tret\n+*/\n+DUP_FN (16, double);\n+\n+/*\n+** cons2_1_double:\n+**\tstp\td0, d1, \\[x0\\]\n+**\tret\n+*/\n+CONS2_FN (1, double);\n+\n+/*\n+** cons2_2_double:\n+**\tstp\td0, d1, \\[x0\\]\n+**\tstp\td0, d1, \\[x0, #?16\\]\n+**\tret\n+*/\n+CONS2_FN (2, double);\n+\n+/*\n+** cons2_4_double:\n+**\t...\n+**\tstp\tq[0-9]+, .*\n+**\tret\n+*/\n+CONS2_FN (4, double);\n+\n+/*\n+** cons2_8_double:\n+**\t...\n+**\tstp\tq[0-9]+, .*\n+**\tret\n+*/\n+CONS2_FN (8, double);\n+\n+/*\n+** cons4_1_double:\n+**\tstp\td0, d1, \\[x0\\]\n+**\tstp\td2, d3, \\[x0, #?16\\]\n+**\tret\n+*/\n+CONS4_FN (1, double);\n+\n+/*\n+** cons4_2_double:\n+**\tstp\td0, d1, \\[x0\\]\n+**\tstp\td2, d3, \\[x0, #?16\\]\n+**\tstp\td0, d1, \\[x0, #?32\\]\n+**\tstp\td2, d3, \\[x0, #?48\\]\n+**\tret\n+*/\n+CONS4_FN (2, double);\n+\n+/*\n+** cons2_8_double:\n+**\t...\n+**\tstp\tq[0-9]+, .*\n+**\tret\n+*/\n+CONS4_FN (4, double);\n+\n+/*\n+** cons2_8_double:\n+**\t...\n+**\tstp\tq[0-9]+, .*\n+**\tret\n+*/\n+CONS4_FN (8, double);"}, {"sha": "9eb41636477473aada2774a48b9cf2108a40d154", "filename": "gcc/testsuite/gcc.target/aarch64/ldp_stp_19.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4963079769c99c4073adfd799885410ad484cbbe/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_19.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4963079769c99c4073adfd799885410ad484cbbe/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_19.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_19.c?ref=4963079769c99c4073adfd799885410ad484cbbe", "patch": "@@ -0,0 +1,6 @@\n+/* { dg-options \"-O2 -mstrict-align\" } */\n+\n+#include \"ldp_stp_5.c\"\n+\n+/* { dg-final { scan-assembler-times {stp\\tq[0-9]+, q[0-9]} 3 { xfail *-*-* } } } */\n+/* { dg-final { scan-assembler-times {str\\tq[0-9]+} 1 { xfail *-*-* } } } */"}, {"sha": "56d1d3cc555bdaa27789a160705c8c7623cdba5e", "filename": "gcc/testsuite/gcc.target/aarch64/ldp_stp_5.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4963079769c99c4073adfd799885410ad484cbbe/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4963079769c99c4073adfd799885410ad484cbbe/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_5.c?ref=4963079769c99c4073adfd799885410ad484cbbe", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-options \"-O2\" } */\n+/* { dg-options \"-O2 -mstrict-align\" } */\n \n double arr[4][4];\n "}, {"sha": "c6b5a0696a2ef2d04e027abd2f665eced439f2ff", "filename": "gcc/tree-vect-slp.cc", "status": "modified", "additions": 50, "deletions": 25, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4963079769c99c4073adfd799885410ad484cbbe/gcc%2Ftree-vect-slp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4963079769c99c4073adfd799885410ad484cbbe/gcc%2Ftree-vect-slp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.cc?ref=4963079769c99c4073adfd799885410ad484cbbe", "patch": "@@ -4533,6 +4533,37 @@ vect_slp_convert_to_external (vec_info *vinfo, slp_tree node,\n   return true;\n }\n \n+/* Return true if all elements of the slice are the same.  */\n+bool\n+vect_scalar_ops_slice::all_same_p () const\n+{\n+  for (unsigned int i = 1; i < length; ++i)\n+    if (!operand_equal_p (op (0), op (i)))\n+      return false;\n+  return true;\n+}\n+\n+hashval_t\n+vect_scalar_ops_slice_hash::hash (const value_type &s)\n+{\n+  hashval_t hash = 0;\n+  for (unsigned i = 0; i < s.length; ++i)\n+    hash = iterative_hash_expr (s.op (i), hash);\n+  return hash;\n+}\n+\n+bool\n+vect_scalar_ops_slice_hash::equal (const value_type &s1,\n+\t\t\t\t   const compare_type &s2)\n+{\n+  if (s1.length != s2.length)\n+    return false;\n+  for (unsigned i = 0; i < s1.length; ++i)\n+    if (!operand_equal_p (s1.op (i), s2.op (i)))\n+      return false;\n+  return true;\n+}\n+\n /* Compute the prologue cost for invariant or constant operands represented\n    by NODE.  */\n \n@@ -4549,45 +4580,39 @@ vect_prologue_cost_for_slp (slp_tree node,\n      When all elements are the same we can use a splat.  */\n   tree vectype = SLP_TREE_VECTYPE (node);\n   unsigned group_size = SLP_TREE_SCALAR_OPS (node).length ();\n-  unsigned num_vects_to_check;\n   unsigned HOST_WIDE_INT const_nunits;\n   unsigned nelt_limit;\n+  auto ops = &SLP_TREE_SCALAR_OPS (node);\n+  auto_vec<unsigned int> starts (SLP_TREE_NUMBER_OF_VEC_STMTS (node));\n   if (TYPE_VECTOR_SUBPARTS (vectype).is_constant (&const_nunits)\n       && ! multiple_p (const_nunits, group_size))\n     {\n-      num_vects_to_check = SLP_TREE_NUMBER_OF_VEC_STMTS (node);\n       nelt_limit = const_nunits;\n+      hash_set<vect_scalar_ops_slice_hash> vector_ops;\n+      for (unsigned int i = 0; i < SLP_TREE_NUMBER_OF_VEC_STMTS (node); ++i)\n+\tif (!vector_ops.add ({ ops, i * const_nunits, const_nunits }))\n+\t  starts.quick_push (i * const_nunits);\n     }\n   else\n     {\n       /* If either the vector has variable length or the vectors\n \t are composed of repeated whole groups we only need to\n \t cost construction once.  All vectors will be the same.  */\n-      num_vects_to_check = 1;\n       nelt_limit = group_size;\n+      starts.quick_push (0);\n     }\n-  tree elt = NULL_TREE;\n-  unsigned nelt = 0;\n-  for (unsigned j = 0; j < num_vects_to_check * nelt_limit; ++j)\n-    {\n-      unsigned si = j % group_size;\n-      if (nelt == 0)\n-\telt = SLP_TREE_SCALAR_OPS (node)[si];\n-      /* ???  We're just tracking whether all operands of a single\n-\t vector initializer are the same, ideally we'd check if\n-\t we emitted the same one already.  */\n-      else if (elt != SLP_TREE_SCALAR_OPS (node)[si])\n-\telt = NULL_TREE;\n-      nelt++;\n-      if (nelt == nelt_limit)\n-\t{\n-\t  record_stmt_cost (cost_vec, 1,\n-\t\t\t    SLP_TREE_DEF_TYPE (node) == vect_external_def\n-\t\t\t    ? (elt ? scalar_to_vec : vec_construct)\n-\t\t\t    : vector_load,\n-\t\t\t    NULL, vectype, 0, vect_prologue);\n-\t  nelt = 0;\n-\t}\n+  /* ???  We're just tracking whether vectors in a single node are the same.\n+     Ideally we'd do something more global.  */\n+  for (unsigned int start : starts)\n+    {\n+      vect_cost_for_stmt kind;\n+      if (SLP_TREE_DEF_TYPE (node) == vect_constant_def)\n+\tkind = vector_load;\n+      else if (vect_scalar_ops_slice { ops, start, nelt_limit }.all_same_p ())\n+\tkind = scalar_to_vec;\n+      else\n+\tkind = vec_construct;\n+      record_stmt_cost (cost_vec, 1, kind, NULL, vectype, 0, vect_prologue);\n     }\n }\n "}, {"sha": "ddd0637185ce92e25e9acf2385d7c5ee2d98b58e", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4963079769c99c4073adfd799885410ad484cbbe/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4963079769c99c4073adfd799885410ad484cbbe/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=4963079769c99c4073adfd799885410ad484cbbe", "patch": "@@ -113,6 +113,41 @@ typedef hash_map<tree_operand_hash,\n \t\t std::pair<stmt_vec_info, innermost_loop_behavior *> >\n \t  vec_base_alignments;\n \n+/* Represents elements [START, START + LENGTH) of cyclical array OPS*\n+   (i.e. OPS repeated to give at least START + LENGTH elements)  */\n+struct vect_scalar_ops_slice\n+{\n+  tree op (unsigned int i) const;\n+  bool all_same_p () const;\n+\n+  vec<tree> *ops;\n+  unsigned int start;\n+  unsigned int length;\n+};\n+\n+/* Return element I of the slice.  */\n+inline tree\n+vect_scalar_ops_slice::op (unsigned int i) const\n+{\n+  return (*ops)[(i + start) % ops->length ()];\n+}\n+\n+/* Hash traits for vect_scalar_ops_slice.  */\n+struct vect_scalar_ops_slice_hash : typed_noop_remove<vect_scalar_ops_slice>\n+{\n+  typedef vect_scalar_ops_slice value_type;\n+  typedef vect_scalar_ops_slice compare_type;\n+\n+  static const bool empty_zero_p = true;\n+\n+  static void mark_deleted (value_type &s) { s.length = ~0U; }\n+  static void mark_empty (value_type &s) { s.length = 0; }\n+  static bool is_deleted (const value_type &s) { return s.length == ~0U; }\n+  static bool is_empty (const value_type &s) { return s.length == 0; }\n+  static hashval_t hash (const value_type &);\n+  static bool equal (const value_type &, const compare_type &);\n+};\n+\n /************************************************************************\n   SLP\n  ************************************************************************/"}]}