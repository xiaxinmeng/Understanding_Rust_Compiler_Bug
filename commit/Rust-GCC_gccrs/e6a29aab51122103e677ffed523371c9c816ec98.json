{"sha": "e6a29aab51122103e677ffed523371c9c816ec98", "node_id": "C_kwDOANBUbNoAKGU2YTI5YWFiNTExMjIxMDNlNjc3ZmZlZDUyMzM3MWM5YzgxNmVjOTg", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2022-10-25T00:36:32Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2022-10-25T16:38:26Z"}, "message": "c++: constexpr-evaluate more assumes\n\nThe initial [[assume]] support avoided evaluating assumes with\nTREE_SIDE_EFFECTS set, such as calls, because we don't want any side-effects\nthat change the constexpr state.  This patch allows us to evaluate\nexpressions with that flag set by tracking which variables the evaluation is\nallowed to modify, and giving up if it tries to touch any others.\n\nI considered allowing changes to other variables and then rolling them back,\nbut that seems like a rare enough situation that it doesn't seem worth\nworking to handle nicely at this point.\n\ngcc/cp/ChangeLog:\n\n\t* constexpr.cc (class constexpr_global_ctx): Add modifiable field,\n\tget_value, get_value_ptr, put_value, remove_value, flush_modifiable\n\tmember functions.\n\t(class modifiable_tracker): New.\n\t(cxx_eval_internal_function): Use it.\n\t(diagnose_failing_condition): Strip CLEANUP_POINT_EXPR.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp23/attr-assume9.C: New test.\n\t* g++.dg/cpp23/attr-assume10.C: New test.", "tree": {"sha": "54f053da8bde4ffac115f19216fee5d14ce45573", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/54f053da8bde4ffac115f19216fee5d14ce45573"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e6a29aab51122103e677ffed523371c9c816ec98", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6a29aab51122103e677ffed523371c9c816ec98", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6a29aab51122103e677ffed523371c9c816ec98", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6a29aab51122103e677ffed523371c9c816ec98/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac8f92c18886057261d61d45b8d339629464c77e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac8f92c18886057261d61d45b8d339629464c77e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac8f92c18886057261d61d45b8d339629464c77e"}], "stats": {"total": 177, "additions": 133, "deletions": 44}, "files": [{"sha": "39bb023b79c27bfcecad065220bc7b781b696305", "filename": "gcc/cp/constexpr.cc", "status": "modified", "additions": 92, "deletions": 44, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6a29aab51122103e677ffed523371c9c816ec98/gcc%2Fcp%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6a29aab51122103e677ffed523371c9c816ec98/gcc%2Fcp%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.cc?ref=e6a29aab51122103e677ffed523371c9c816ec98", "patch": "@@ -1092,10 +1092,11 @@ enum constexpr_switch_state {\n    cxx_eval_outermost_constant_expr invocation.  VALUES is a map of values of\n    variables initialized within the expression.  */\n \n-struct constexpr_global_ctx {\n+class constexpr_global_ctx {\n   /* Values for any temporaries or local variables within the\n      constant-expression. */\n   hash_map<tree,tree> values;\n+public:\n   /* Number of cxx_eval_constant_expression calls (except skipped ones,\n      on simple constants or location wrappers) encountered during current\n      cxx_eval_outermost_constant_expr call.  */\n@@ -1105,11 +1106,61 @@ struct constexpr_global_ctx {\n   auto_vec<tree, 16> heap_vars;\n   /* Cleanups that need to be evaluated at the end of CLEANUP_POINT_EXPR.  */\n   vec<tree> *cleanups;\n+  /* If non-null, only allow modification of existing values of the variables\n+     in this set.  Set by modifiable_tracker, below.  */\n+  hash_set<tree> *modifiable;\n   /* Number of heap VAR_DECL deallocations.  */\n   unsigned heap_dealloc_count;\n   /* Constructor.  */\n   constexpr_global_ctx ()\n-    : constexpr_ops_count (0), cleanups (NULL), heap_dealloc_count (0) {}\n+    : constexpr_ops_count (0), cleanups (NULL), modifiable (nullptr),\n+      heap_dealloc_count (0) {}\n+\n+ tree get_value (tree t)\n+  {\n+    if (tree *p = values.get (t))\n+      return *p;\n+    return NULL_TREE;\n+  }\n+  tree *get_value_ptr (tree t)\n+  {\n+    if (modifiable && !modifiable->contains (t))\n+      return nullptr;\n+    return values.get (t);\n+  }\n+  void put_value (tree t, tree v)\n+  {\n+    bool already_in_map = values.put (t, v);\n+    if (!already_in_map && modifiable)\n+      modifiable->add (t);\n+  }\n+  void remove_value (tree t) { values.remove (t); }\n+};\n+\n+/* Helper class for constexpr_global_ctx.  In some cases we want to avoid\n+   side-effects from evaluation of a particular subexpression of a\n+   constant-expression.  In such cases we use modifiable_tracker to prevent\n+   modification of variables created outside of that subexpression.\n+\n+   ??? We could change the hash_set to a hash_map, allow and track external\n+   modifications, and roll them back in the destructor.  It's not clear to me\n+   that this would be worthwhile.  */\n+\n+class modifiable_tracker\n+{\n+  hash_set<tree> set;\n+  constexpr_global_ctx *global;\n+public:\n+  modifiable_tracker (constexpr_global_ctx *g): global(g)\n+  {\n+    global->modifiable = &set;\n+  }\n+  ~modifiable_tracker ()\n+  {\n+    for (tree t: set)\n+      global->remove_value (t);\n+    global->modifiable = nullptr;\n+  }\n };\n \n /* The constexpr expansion context.  CALL is the current function\n@@ -1653,7 +1704,7 @@ addr_of_non_const_var (tree *tp, int *walk_subtrees, void *data)\n \t    return var;\n \n \t  constexpr_global_ctx *global = (constexpr_global_ctx *) data;\n-\t  if (global->values.get (var))\n+\t  if (global->get_value (var))\n \t    return var;\n \t}\n   if (TYPE_P (*tp))\n@@ -1865,6 +1916,8 @@ diagnose_failing_condition (tree bad, location_t cloc, bool show_expr_p,\n {\n   /* Nobody wants to see the artificial (bool) cast.  */\n   bad = tree_strip_nop_conversions (bad);\n+  if (TREE_CODE (bad) == CLEANUP_POINT_EXPR)\n+    bad = TREE_OPERAND (bad, 0);\n \n   /* Actually explain the failure if this is a concept check or a\n      requires-expression.  */\n@@ -1902,18 +1955,14 @@ cxx_eval_internal_function (const constexpr_ctx *ctx, tree t,\n       return void_node;\n \n     case IFN_ASSUME:\n-      /* For now, restrict constexpr evaluation of [[assume (cond)]]\n-\t only to the cases which don't have side-effects.  Evaluating\n-\t it even when it does would mean we'd need to somehow undo\n-\t all the side-effects e.g. in ctx->global->values.  */\n-      if (!TREE_SIDE_EFFECTS (CALL_EXPR_ARG (t, 0))\n-\t  /* And it needs to be a potential constant expression.  */\n-\t  && potential_rvalue_constant_expression (CALL_EXPR_ARG (t, 0)))\n+      if (potential_rvalue_constant_expression (CALL_EXPR_ARG (t, 0)))\n \t{\n \t  constexpr_ctx new_ctx = *ctx;\n \t  new_ctx.quiet = true;\n \t  tree arg = CALL_EXPR_ARG (t, 0);\n \t  bool new_non_constant_p = false, new_overflow_p = false;\n+\t  /* Avoid modification of existing values.  */\n+\t  modifiable_tracker ms (new_ctx.global);\n \t  arg = cxx_eval_constant_expression (&new_ctx, arg, vc_prvalue,\n \t\t\t\t\t      &new_non_constant_p,\n \t\t\t\t\t      &new_overflow_p);\n@@ -2613,7 +2662,7 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n \t      // See PR98988 and PR99031.\n \t      varpool_node::finalize_decl (var);\n \t      ctx->global->heap_vars.safe_push (var);\n-\t      ctx->global->values.put (var, NULL_TREE);\n+\t      ctx->global->put_value (var, NULL_TREE);\n \t      return fold_convert (ptr_type_node, build_address (var));\n \t    }\n \t  else\n@@ -2641,7 +2690,7 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n \t\t\t  return t;\n \t\t\t}\n \t\t      DECL_NAME (var) = heap_deleted_identifier;\n-\t\t      ctx->global->values.remove (var);\n+\t\t      ctx->global->remove_value (var);\n \t\t      ctx->global->heap_dealloc_count++;\n \t\t      return void_node;\n \t\t    }\n@@ -2663,7 +2712,7 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n \t\t\t  return t;\n \t\t\t}\n \t\t      DECL_NAME (var) = heap_deleted_identifier;\n-\t\t      ctx->global->values.remove (var);\n+\t\t      ctx->global->remove_value (var);\n \t\t      ctx->global->heap_dealloc_count++;\n \t\t      return void_node;\n \t\t    }\n@@ -2726,7 +2775,7 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n       new_ctx.object = AGGR_INIT_EXPR_SLOT (t);\n       tree ctor = new_ctx.ctor = build_constructor (DECL_CONTEXT (fun), NULL);\n       CONSTRUCTOR_NO_CLEARING (ctor) = true;\n-      ctx->global->values.put (new_ctx.object, ctor);\n+      ctx->global->put_value (new_ctx.object, ctor);\n       ctx = &new_ctx;\n     }\n \n@@ -2949,12 +2998,12 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n \t\t  if (TREE_CODE (arg) == CONSTRUCTOR)\n \t\t    vec_safe_push (ctors, arg);\n \t\t}\n-\t      ctx->global->values.put (remapped, arg);\n+\t      ctx->global->put_value (remapped, arg);\n \t      remapped = DECL_CHAIN (remapped);\n \t    }\n \t  /* Add the RESULT_DECL to the values map, too.  */\n \t  gcc_assert (!DECL_BY_REFERENCE (res));\n-\t  ctx->global->values.put (res, NULL_TREE);\n+\t  ctx->global->put_value (res, NULL_TREE);\n \n \t  /* Track the callee's evaluated SAVE_EXPRs and TARGET_EXPRs so that\n \t     we can forget their values after the call.  */\n@@ -3009,7 +3058,7 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n \t    result = void_node;\n \t  else\n \t    {\n-\t      result = *ctx->global->values.get (res);\n+\t      result = ctx->global->get_value (res);\n \t      if (result == NULL_TREE && !*non_constant_p\n \t\t  && !DECL_DESTRUCTOR_P (fun))\n \t\t{\n@@ -3031,15 +3080,15 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n \t  /* Forget the saved values of the callee's SAVE_EXPRs and\n \t     TARGET_EXPRs.  */\n \t  for (tree save_expr : save_exprs)\n-\t    ctx->global->values.remove (save_expr);\n+\t    ctx->global->remove_value (save_expr);\n \n \t  /* Remove the parms/result from the values map.  Is it worth\n \t     bothering to do this when the map itself is only live for\n \t     one constexpr evaluation?  If so, maybe also clear out\n \t     other vars from call, maybe in BIND_EXPR handling?  */\n-\t  ctx->global->values.remove (res);\n+\t  ctx->global->remove_value (res);\n \t  for (tree parm = parms; parm; parm = TREE_CHAIN (parm))\n-\t    ctx->global->values.remove (parm);\n+\t    ctx->global->remove_value (parm);\n \n \t  /* Free any parameter CONSTRUCTORs we aren't returning directly.  */\n \t  while (!ctors->is_empty ())\n@@ -4876,7 +4925,7 @@ verify_ctor_sanity (const constexpr_ctx *ctx, tree type)\n \t\t\t  (TREE_TYPE (type), TREE_TYPE (otype)))));\n     }\n   gcc_assert (!ctx->object || !DECL_P (ctx->object)\n-\t      || *(ctx->global->values.get (ctx->object)) == ctx->ctor);\n+\t      || ctx->global->get_value (ctx->object) == ctx->ctor);\n }\n \n /* Subroutine of cxx_eval_constant_expression.\n@@ -5198,7 +5247,7 @@ cxx_eval_vec_init (const constexpr_ctx *ctx, tree t,\n \t  new_ctx.object = VEC_INIT_EXPR_SLOT (t);\n \t  tree ctor = new_ctx.ctor = build_constructor (atype, NULL);\n \t  CONSTRUCTOR_NO_CLEARING (ctor) = true;\n-\t  ctx->global->values.put (new_ctx.object, ctor);\n+\t  ctx->global->put_value (new_ctx.object, ctor);\n \t  ctx = &new_ctx;\n \t}\n       init = expand_vec_init_expr (ctx->object, t, complain);\n@@ -5884,7 +5933,7 @@ cxx_eval_store_expression (const constexpr_ctx *ctx, tree t,\n      we're initializing.  */\n   tree *valp;\n   if (DECL_P (object))\n-    valp = ctx->global->values.get (object);\n+    valp = ctx->global->get_value_ptr (object);\n   else\n     valp = NULL;\n   if (!valp)\n@@ -6116,7 +6165,7 @@ cxx_eval_store_expression (const constexpr_ctx *ctx, tree t,\n       /* The hash table might have moved since the get earlier, and the\n \t initializer might have mutated the underlying CONSTRUCTORs, so we must\n \t recompute VALP. */\n-      valp = ctx->global->values.get (object);\n+      valp = ctx->global->get_value_ptr (object);\n       for (unsigned i = 0; i < vec_safe_length (indexes); i++)\n \t{\n \t  ctors[i] = valp;\n@@ -6546,7 +6595,7 @@ cxx_eval_loop_expr (const constexpr_ctx *ctx, tree t,\n \n       /* Forget saved values of SAVE_EXPRs and TARGET_EXPRs.  */\n       for (tree save_expr : save_exprs)\n-\tctx->global->values.remove (save_expr);\n+\tctx->global->remove_value (save_expr);\n       save_exprs.truncate (0);\n \n       if (++count >= constexpr_loop_limit)\n@@ -6568,7 +6617,7 @@ cxx_eval_loop_expr (const constexpr_ctx *ctx, tree t,\n \n   /* Forget saved values of SAVE_EXPRs and TARGET_EXPRs.  */\n   for (tree save_expr : save_exprs)\n-    ctx->global->values.remove (save_expr);\n+    ctx->global->remove_value (save_expr);\n \n   return NULL_TREE;\n }\n@@ -6865,8 +6914,8 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n       /* We ask for an rvalue for the RESULT_DECL when indirecting\n \t through an invisible reference, or in named return value\n \t optimization.  */\n-      if (tree *p = ctx->global->values.get (t))\n-\treturn *p;\n+      if (tree v = ctx->global->get_value (t))\n+\treturn v;\n       else\n \t{\n \t  if (!ctx->quiet)\n@@ -6909,10 +6958,9 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n       else if (t == ctx->object)\n \treturn ctx->ctor;\n       if (VAR_P (t))\n-\tif (tree *p = ctx->global->values.get (t))\n-\t  if (*p != NULL_TREE)\n+\tif (tree v = ctx->global->get_value (t))\n \t    {\n-\t      r = *p;\n+\t      r = v;\n \t      break;\n \t    }\n       if (ctx->manifestly_const_eval)\n@@ -6955,8 +7003,8 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n     case PARM_DECL:\n       if (lval && !TYPE_REF_P (TREE_TYPE (t)))\n \t/* glvalue use.  */;\n-      else if (tree *p = ctx->global->values.get (r))\n-\tr = *p;\n+      else if (tree v = ctx->global->get_value (r))\n+\tr = v;\n       else if (lval)\n \t/* Defer in case this is only used for its type.  */;\n       else if (COMPLETE_TYPE_P (TREE_TYPE (t))\n@@ -7015,7 +7063,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t    new_ctx.object = r;\n \t    new_ctx.ctor = build_constructor (TREE_TYPE (r), NULL);\n \t    CONSTRUCTOR_NO_CLEARING (new_ctx.ctor) = true;\n-\t    ctx->global->values.put (r, new_ctx.ctor);\n+\t    ctx->global->put_value (r, new_ctx.ctor);\n \t    ctx = &new_ctx;\n \t  }\n \n@@ -7030,12 +7078,12 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t    if (CLASS_TYPE_P (TREE_TYPE (r))\n \t\t&& CP_TYPE_CONST_P (TREE_TYPE (r)))\n \t      TREE_READONLY (init) = true;\n-\t    ctx->global->values.put (r, init);\n+\t    ctx->global->put_value (r, init);\n \t  }\n \telse if (ctx == &new_ctx)\n \t  /* We gave it a CONSTRUCTOR above.  */;\n \telse\n-\t  ctx->global->values.put (r, NULL_TREE);\n+\t  ctx->global->put_value (r, NULL_TREE);\n       }\n       break;\n \n@@ -7058,11 +7106,11 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \tgcc_checking_assert (!TARGET_EXPR_DIRECT_INIT_P (t));\n \t/* Avoid evaluating a TARGET_EXPR more than once.  */\n \ttree slot = TARGET_EXPR_SLOT (t);\n-\tif (tree *p = ctx->global->values.get (slot))\n+\tif (tree v = ctx->global->get_value (slot))\n \t  {\n \t    if (lval)\n \t      return slot;\n-\t    r = *p;\n+\t    r = v;\n \t    break;\n \t  }\n \tif ((AGGREGATE_TYPE_P (type) || VECTOR_TYPE_P (type)))\n@@ -7078,7 +7126,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t    new_ctx.ctor = build_constructor (type, NULL);\n \t    CONSTRUCTOR_NO_CLEARING (new_ctx.ctor) = true;\n \t    new_ctx.object = slot;\n-\t    ctx->global->values.put (new_ctx.object, new_ctx.ctor);\n+\t    ctx->global->put_value (new_ctx.object, new_ctx.ctor);\n \t    ctx = &new_ctx;\n \t  }\n \t/* Pass vc_prvalue because this indicates\n@@ -7092,7 +7140,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \tif (TARGET_EXPR_CLEANUP (t) && !CLEANUP_EH_ONLY (t))\n \t  ctx->global->cleanups->safe_push (TARGET_EXPR_CLEANUP (t));\n \tr = unshare_constructor (r);\n-\tctx->global->values.put (slot, r);\n+\tctx->global->put_value (slot, r);\n \tif (ctx->save_exprs)\n \t  ctx->save_exprs->safe_push (slot);\n \tif (lval)\n@@ -7135,15 +7183,15 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \n     case SAVE_EXPR:\n       /* Avoid evaluating a SAVE_EXPR more than once.  */\n-      if (tree *p = ctx->global->values.get (t))\n-\tr = *p;\n+      if (tree v = ctx->global->get_value (t))\n+\tr = v;\n       else\n \t{\n \t  r = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 0), vc_prvalue,\n \t\t\t\t\t    non_constant_p, overflow_p);\n \t  if (*non_constant_p)\n \t    break;\n-\t  ctx->global->values.put (t, r);\n+\t  ctx->global->put_value (t, r);\n \t  if (ctx->save_exprs)\n \t    ctx->save_exprs->safe_push (t);\n \t}\n@@ -8078,7 +8126,7 @@ cxx_eval_outermost_constant_expr (tree t, bool allow_non_constant,\n \tgcc_assert (same_type_ignoring_top_level_qualifiers_p\n \t\t    (type, TREE_TYPE (object)));\n       if (object && DECL_P (object))\n-\tglobal_ctx.values.put (object, ctx.ctor);\n+\tglobal_ctx.put_value (object, ctx.ctor);\n       if (TREE_CODE (r) == TARGET_EXPR)\n \t/* Avoid creating another CONSTRUCTOR when we expand the\n \t   TARGET_EXPR.  */"}, {"sha": "475555ac415ddeb989eadf5701e8df3fc1cc66b5", "filename": "gcc/testsuite/g++.dg/cpp23/attr-assume10.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6a29aab51122103e677ffed523371c9c816ec98/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fattr-assume10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6a29aab51122103e677ffed523371c9c816ec98/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fattr-assume10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fattr-assume10.C?ref=e6a29aab51122103e677ffed523371c9c816ec98", "patch": "@@ -0,0 +1,22 @@\n+// Test that s.i is not modified by the assume.\n+// { dg-do compile { target c++17 } }\n+\n+struct string\n+{\n+  const char *p;\n+  int i;\n+  constexpr string (const char *p): p(p), i(0) { }\n+  constexpr int length () { ++i; return __builtin_strlen (p); }\n+};\n+\n+constexpr int f()\n+{\n+  string s (\"foobar\");\n+  [[assume (s.length () > 0)]];\n+  if (s.i != 0) __builtin_abort();\n+  int len = s.length ();\n+  if (s.i != 1) __builtin_abort();\n+  return len;\n+}\n+\n+static_assert (f());"}, {"sha": "cbd681516920ec64c610502feb656c4036d5d997", "filename": "gcc/testsuite/g++.dg/cpp23/attr-assume9.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6a29aab51122103e677ffed523371c9c816ec98/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fattr-assume9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6a29aab51122103e677ffed523371c9c816ec98/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fattr-assume9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fattr-assume9.C?ref=e6a29aab51122103e677ffed523371c9c816ec98", "patch": "@@ -0,0 +1,19 @@\n+// Diagnose failed assumptions involving a function call.\n+// { dg-do compile { target c++17 } }\n+\n+struct string\n+{\n+  const char *p;\n+  constexpr string (const char *p): p(p) { }\n+  constexpr int length () { return __builtin_strlen (p); }\n+};\n+\n+constexpr int f()\n+{\n+  string s (\"foobar\");\n+  [[assume (s.length () == 0)]]; // { dg-error \"assume\" }\n+  // { dg-message \"6 == 0\" \"\" { target *-*-* } .-1 }\n+  return s.length ();\n+}\n+\n+static_assert (f());\t\t// { dg-error \"non-constant\" }"}]}