{"sha": "aa2c50d6b341f534d56526bc330f9bd7e15baf4d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWEyYzUwZDZiMzQxZjUzNGQ1NjUyNmJjMzMwZjliZDdlMTViYWY0ZA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-03-12T04:43:44Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-03-12T04:43:44Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r452", "tree": {"sha": "817850060157e676561d99129da67d650ef7a10a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/817850060157e676561d99129da67d650ef7a10a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa2c50d6b341f534d56526bc330f9bd7e15baf4d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa2c50d6b341f534d56526bc330f9bd7e15baf4d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa2c50d6b341f534d56526bc330f9bd7e15baf4d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa2c50d6b341f534d56526bc330f9bd7e15baf4d/comments", "author": null, "committer": null, "parents": [{"sha": "4e4b555d33d1df5259f13dc13dec59361920b9f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e4b555d33d1df5259f13dc13dec59361920b9f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e4b555d33d1df5259f13dc13dec59361920b9f2"}], "stats": {"total": 64, "additions": 14, "deletions": 50}, "files": [{"sha": "2f2ccc3e53616519822690c25eee13f261728bd6", "filename": "gcc/reload1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa2c50d6b341f534d56526bc330f9bd7e15baf4d/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa2c50d6b341f534d56526bc330f9bd7e15baf4d/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=aa2c50d6b341f534d56526bc330f9bd7e15baf4d", "patch": "@@ -3231,7 +3231,7 @@ reload_as_needed (first, live_known)\n       register rtx next = NEXT_INSN (insn);\n \n       /* Notice when we move to a new basic block.  */\n-      if (live_known && basic_block_needs && this_block + 1 < n_basic_blocks\n+      if (live_known && this_block + 1 < n_basic_blocks\n \t  && insn == basic_block_head[this_block+1])\n \t++this_block;\n "}, {"sha": "6147be91a6e1fb7f2606c225b2bf0b9945dd6d3d", "filename": "gcc/reorg.c", "status": "modified", "additions": 13, "deletions": 49, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa2c50d6b341f534d56526bc330f9bd7e15baf4d/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa2c50d6b341f534d56526bc330f9bd7e15baf4d/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=aa2c50d6b341f534d56526bc330f9bd7e15baf4d", "patch": "@@ -1758,71 +1758,35 @@ find_basic_block (insn)\n   return -1;\n }\n \f\n-/* Used for communication between the following two routines, contains\n-   the block number that insn was in.  */\n-\n-static int current_block_number;\n-\n-/* Called via note_stores from update_block_status.  It marks the\n-   registers set in this insn as live at the start of the block whose\n-   number is in current_block_number.  */\n-\n-static void\n-update_block_from_store (dest, x)\n-     rtx dest;\n-     rtx x;\n-{\n-  int first_regno, last_regno;\n-  int offset = 0;\n-  int i;\n-\n-  if (GET_CODE (x) != SET\n-      || (GET_CODE (dest) != REG && (GET_CODE (dest) != SUBREG\n-\t\t\t\t     || GET_CODE (SUBREG_REG (dest)) != REG)))\n-    return;\n-\n-  if (GET_CODE (dest) == SUBREG)\n-    first_regno = REGNO (SUBREG_REG (dest)) + SUBREG_WORD (dest);\n-  else\n-    first_regno = REGNO (dest);\n-\n-  last_regno = first_regno + HARD_REGNO_NREGS (first_regno, GET_MODE (dest));\n-  for (i = first_regno; i < last_regno; i++)\n-    basic_block_live_at_start[current_block_number][i / HOST_BITS_PER_INT]\n-      |= (1 << (i % HOST_BITS_PER_INT));\n-}\n-\n /* Called when INSN is being moved from a location near the target of a jump.\n-   If WHERE is the first active insn at the start of its basic block, we can\n-   just mark the registers set in INSN as live at the start of the basic block\n-   that starts immediately before INSN.\n-\n-   Otherwise, we leave a marker of the form (use (INSN)) immediately in front\n+   We leave a marker of the form (use (INSN)) immediately in front\n    of WHERE for mark_target_live_regs.  These markers will be deleted when\n-   reorg finishes.  */\n+   reorg finishes.\n+\n+   We used to try to update the live status of registers if WHERE is at\n+   the start of a basic block, but that can't work since we may remove a\n+   BARRIER in relax_delay_slots.  */\n \n static void\n update_block (insn, where)\n      rtx insn;\n      rtx where;\n {\n+  int b;\n+\n   /* Ignore if this was in a delay slot and it came from the target of \n      a branch.  */\n   if (INSN_FROM_TARGET_P (insn))\n     return;\n \n-  current_block_number = find_basic_block (insn);\n-  if (current_block_number == -1)\n-    return;\n-\n-  if (where == next_active_insn (basic_block_head[current_block_number]))\n-    note_stores (PATTERN (insn), update_block_from_store);\n-  else\n-    emit_insn_before (gen_rtx (USE, VOIDmode, insn), where);\n+  emit_insn_before (gen_rtx (USE, VOIDmode, insn), where);\n \n   /* INSN might be making a value live in a block where it didn't use to\n      be.  So recompute liveness information for this block.  */\n-  bb_ticks[current_block_number]++;\n+\n+  b = find_basic_block (insn);\n+  if (b != -1)\n+    bb_ticks[b]++;\n }\n \f\n /* Marks registers possibly live at the current place being scanned by"}]}