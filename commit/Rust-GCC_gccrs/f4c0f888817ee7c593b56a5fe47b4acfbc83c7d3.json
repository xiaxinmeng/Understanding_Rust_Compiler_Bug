{"sha": "f4c0f888817ee7c593b56a5fe47b4acfbc83c7d3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjRjMGY4ODg4MTdlZTdjNTkzYjU2YTVmZTQ3YjRhY2ZiYzgzYzdkMw==", "commit": {"author": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2018-11-23T20:42:03Z"}, "committer": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2018-11-23T20:42:03Z"}, "message": "Make recursion_check work for multiple threads\n\nWith multiple threads, using an unprotected static variable to check\nwhether recursion has occured isn't valid, as one thread might have\nmodified the variable, thus causing another thread to incorrectly\nconclude that recursion has occured.  This patch avoids this problem\nby using a thread-specific variable for the recursion check.\n\nRegtested on x86_64-pc-linux-gnu.\n\nlibgfortran/ChangeLog:\n\n2018-11-23  Janne Blomqvist  <jb@gcc.gnu.org>\n\n\t* runtime/error.c (MAGIC): Remove.\n\t(recursion_key): New variable.\n\t(recursion_check): Use thread-specific variable for recursion\n\tcheck if threads are active.\n\t(constructor_recursion_check): New function.\n\t(destructor_recursion_check): New funcion.\n\nFrom-SVN: r266419", "tree": {"sha": "4ab252c7af94ffd81381887e7c0c7777d36818c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4ab252c7af94ffd81381887e7c0c7777d36818c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f4c0f888817ee7c593b56a5fe47b4acfbc83c7d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4c0f888817ee7c593b56a5fe47b4acfbc83c7d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4c0f888817ee7c593b56a5fe47b4acfbc83c7d3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4c0f888817ee7c593b56a5fe47b4acfbc83c7d3/comments", "author": null, "committer": null, "parents": [{"sha": "70c70369ce868fd8b049f710c01a899e502f6f68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70c70369ce868fd8b049f710c01a899e502f6f68", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70c70369ce868fd8b049f710c01a899e502f6f68"}], "stats": {"total": 52, "additions": 45, "deletions": 7}, "files": [{"sha": "d9397623ee1a4dd3c1d1c74ecd0f482b19c2d262", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4c0f888817ee7c593b56a5fe47b4acfbc83c7d3/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4c0f888817ee7c593b56a5fe47b4acfbc83c7d3/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=f4c0f888817ee7c593b56a5fe47b4acfbc83c7d3", "patch": "@@ -1,3 +1,12 @@\n+2018-11-23  Janne Blomqvist  <jb@gcc.gnu.org>\n+\n+\t* runtime/error.c (MAGIC): Remove.\n+\t(recursion_key): New variable.\n+\t(recursion_check): Use thread-specific variable for recursion\n+\tcheck if threads are active.\n+\t(constructor_recursion_check): New function.\n+\t(destructor_recursion_check): New funcion.\n+\n 2018-11-22  Janne Blomqvist  <jb@gcc.gnu.org>\n \n \t* acinclude.m4 (LIBGFOR_CHECK_ATOMIC_FETCH_ADD): Rename and test"}, {"sha": "7c52733c19c56983596f8a5a69a7eb2279720aa5", "filename": "libgfortran/runtime/error.c", "status": "modified", "additions": 36, "deletions": 7, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4c0f888817ee7c593b56a5fe47b4acfbc83c7d3/libgfortran%2Fruntime%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4c0f888817ee7c593b56a5fe47b4acfbc83c7d3/libgfortran%2Fruntime%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Ferror.c?ref=f4c0f888817ee7c593b56a5fe47b4acfbc83c7d3", "patch": "@@ -332,21 +332,50 @@ show_locus (st_parameter_common *cmp)\n \n /* recursion_check()-- It's possible for additional errors to occur\n  * during fatal error processing.  We detect this condition here and\n- * exit with code 4 immediately. */\n+ * abort immediately. */\n \n-#define MAGIC 0x20DE8101\n+static __gthread_key_t recursion_key;\n \n static void\n recursion_check (void)\n {\n-  static int magic = 0;\n+  if (__gthread_active_p ())\n+    {\n+      bool* p = __gthread_getspecific (recursion_key);\n+      if (!p)\n+        {\n+          p = xcalloc (1, sizeof (bool));\n+          __gthread_setspecific (recursion_key, p);\n+        }\n+      if (*p)\n+\tsys_abort ();\n+      *p = true;\n+    }\n+  else\n+    {\n+      static bool recur;\n+      if (recur)\n+\tsys_abort ();\n+      recur = true;\n+    }\n+}\n \n-  /* Don't even try to print something at this point */\n-  if (magic == MAGIC)\n-    sys_abort ();\n+#ifdef __GTHREADS\n+static void __attribute__((constructor))\n+constructor_recursion_check (void)\n+{\n+  if (__gthread_active_p ())\n+    __gthread_key_create (&recursion_key, &free);\n+}\n \n-  magic = MAGIC;\n+static void __attribute__((destructor))\n+destructor_recursion_check (void)\n+{\n+  if (__gthread_active_p ())\n+    __gthread_key_delete (recursion_key);\n }\n+#endif\n+\n \n \n #define STRERR_MAXSZ 256"}]}