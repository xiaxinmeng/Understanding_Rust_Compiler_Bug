{"sha": "ca0b06f86fd44bd6067563dcbf4a2c021f2a79a5", "node_id": "C_kwDOANBUbNoAKGNhMGIwNmY4NmZkNDRiZDYwNjc1NjNkY2JmNGEyYzAyMWYyYTc5YTU", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-10-30T12:30:50Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-10-30T12:30:50Z"}, "message": "Merge #780\n\n780: No side effects in 'assert' expressions r=philberty a=tschwinge\n\nUsually, if 'assert'ions are disabled, 'assert' expressions are not evaluated,\r\nso in that case won't effect any side effects.\r\n\r\nVia spurious ICEs/test suite FAILs, this may be observed in GCC/Rust, for\r\nexample, if configuring with '--enable-checking=no' and disabling a \"more\r\nforgiving\" 'gcc/system.h:gcc_assert' definition, so that '0 && (EXPR)' gets\r\nused:\r\n\r\n     /* Use gcc_assert(EXPR) to test invariants.  */\r\n     #if ENABLE_ASSERT_CHECKING\r\n     #define gcc_assert(EXPR)                                               \\\r\n        ((void)(!(EXPR) ? fancy_abort (__FILE__, __LINE__, __FUNCTION__), 0 : 0))\r\n    -#elif (GCC_VERSION >= 4005)\r\n    +#elif (0) //GCC_VERSION >= 4005)\r\n     #define gcc_assert(EXPR)                                               \\\r\n       ((void)(__builtin_expect (!(EXPR), 0) ? __builtin_unreachable (), 0 : 0))\r\n     #else\r\n     /* Include EXPR, so that unused variable warnings do not occur.  */\r\n     #define gcc_assert(EXPR) ((void)(0 && (EXPR)))\r\n     #endif\r\n\r\nAs that one does cause some issues in GCC proper (that I shall fix separately),\r\nmay use this change to 'gcc/rust/rust-system.h:rust_assert' instead:\r\n\r\n    +#if 0\r\n     #define rust_assert(EXPR) gcc_assert (EXPR)\r\n    +#else\r\n    +#define rust_assert(EXPR) ((void) (0 && (EXPR)))\r\n    +#endif\r\n\r\nTo fix these, use the same pattern as is already used in a lot of existing\r\nGCC/Rust code:\r\n\r\n    bool ok = [expression with side effects];\r\n    rust_assert (ok);\r\n\r\nI've only done a quick manual review; maybe there is a tool for doing this?\r\n\n\nCo-authored-by: Thomas Schwinge <thomas@codesourcery.com>", "tree": {"sha": "a79768a42ca7543bd5e078243ebf4e3a23b14e0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a79768a42ca7543bd5e078243ebf4e3a23b14e0e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca0b06f86fd44bd6067563dcbf4a2c021f2a79a5", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhfTr6CRBK7hj4Ov3rIwAAvrwIADTRjAJLZzH+hT8cURs+Xs2t\nXPmNhcnksAjb5IC1Y5Vr4V/iDM+zljPTSf8DO8QoVIf1GBCiQzDiuJrGJ87+Umgm\nPIFVMXpsoyU83YQgw7YpdibmyxHXN83pQc63j9iL1d6t88TU+A3d+EP+qMG5H3S1\n8lcOF6yUId65xSEO9XCEcpTQTo/l80YV7kRgTQ5vjrExx3EnJxB4OFNM6YyT7naI\nrzHvIW/kMs7UtvOhQTVaW4yhEAsrhosuVsKTu2IueP0GTz8GEympNwLYFsWH55EJ\n5swzUXCdiyAhhoMhKApYiYmAlBCjeNM9xY+O1GJtfxYQedbj+gSjTlQGnXFGKRE=\n=/JJK\n-----END PGP SIGNATURE-----\n", "payload": "tree a79768a42ca7543bd5e078243ebf4e3a23b14e0e\nparent a9daecd2a35f7caebb02feb4dbb2dc89f3165cdb\nparent f569984bb80c7b7b15baccdc596c71938f49315a\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1635597050 +0000\ncommitter GitHub <noreply@github.com> 1635597050 +0000\n\nMerge #780\n\n780: No side effects in 'assert' expressions r=philberty a=tschwinge\n\nUsually, if 'assert'ions are disabled, 'assert' expressions are not evaluated,\r\nso in that case won't effect any side effects.\r\n\r\nVia spurious ICEs/test suite FAILs, this may be observed in GCC/Rust, for\r\nexample, if configuring with '--enable-checking=no' and disabling a \"more\r\nforgiving\" 'gcc/system.h:gcc_assert' definition, so that '0 && (EXPR)' gets\r\nused:\r\n\r\n     /* Use gcc_assert(EXPR) to test invariants.  */\r\n     #if ENABLE_ASSERT_CHECKING\r\n     #define gcc_assert(EXPR)                                               \\\r\n        ((void)(!(EXPR) ? fancy_abort (__FILE__, __LINE__, __FUNCTION__), 0 : 0))\r\n    -#elif (GCC_VERSION >= 4005)\r\n    +#elif (0) //GCC_VERSION >= 4005)\r\n     #define gcc_assert(EXPR)                                               \\\r\n       ((void)(__builtin_expect (!(EXPR), 0) ? __builtin_unreachable (), 0 : 0))\r\n     #else\r\n     /* Include EXPR, so that unused variable warnings do not occur.  */\r\n     #define gcc_assert(EXPR) ((void)(0 && (EXPR)))\r\n     #endif\r\n\r\nAs that one does cause some issues in GCC proper (that I shall fix separately),\r\nmay use this change to 'gcc/rust/rust-system.h:rust_assert' instead:\r\n\r\n    +#if 0\r\n     #define rust_assert(EXPR) gcc_assert (EXPR)\r\n    +#else\r\n    +#define rust_assert(EXPR) ((void) (0 && (EXPR)))\r\n    +#endif\r\n\r\nTo fix these, use the same pattern as is already used in a lot of existing\r\nGCC/Rust code:\r\n\r\n    bool ok = [expression with side effects];\r\n    rust_assert (ok);\r\n\r\nI've only done a quick manual review; maybe there is a tool for doing this?\r\n\n\nCo-authored-by: Thomas Schwinge <thomas@codesourcery.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca0b06f86fd44bd6067563dcbf4a2c021f2a79a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca0b06f86fd44bd6067563dcbf4a2c021f2a79a5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca0b06f86fd44bd6067563dcbf4a2c021f2a79a5/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a9daecd2a35f7caebb02feb4dbb2dc89f3165cdb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9daecd2a35f7caebb02feb4dbb2dc89f3165cdb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9daecd2a35f7caebb02feb4dbb2dc89f3165cdb"}, {"sha": "f569984bb80c7b7b15baccdc596c71938f49315a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f569984bb80c7b7b15baccdc596c71938f49315a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f569984bb80c7b7b15baccdc596c71938f49315a"}], "stats": {"total": 53, "additions": 31, "deletions": 22}, "files": [{"sha": "2b2018f1c2cc97db10088113a08f6803a61a7b6d", "filename": "gcc/rust/backend/rust-compile-context.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca0b06f86fd44bd6067563dcbf4a2c021f2a79a5/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca0b06f86fd44bd6067563dcbf4a2c021f2a79a5/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-context.h?ref=ca0b06f86fd44bd6067563dcbf4a2c021f2a79a5", "patch": "@@ -53,11 +53,12 @@ class Context\n     for (auto it = builtins.begin (); it != builtins.end (); it++)\n       {\n \tHirId ref;\n-\trust_assert (\n-\t  tyctx->lookup_type_by_node_id ((*it)->get_node_id (), &ref));\n+\tbool ok = tyctx->lookup_type_by_node_id ((*it)->get_node_id (), &ref);\n+\trust_assert (ok);\n \n \tTyTy::BaseType *lookup;\n-\trust_assert (tyctx->lookup_type (ref, &lookup));\n+\tok = tyctx->lookup_type (ref, &lookup);\n+\trust_assert (ok);\n \n \tBtype *compiled = TyTyCompile::compile (backend, lookup);\n \tcompiled_type_map.insert (std::pair<HirId, Btype *> (ref, compiled));"}, {"sha": "a78cf197358730c29d9d9038eed25cecb8566baa", "filename": "gcc/rust/backend/rust-compile-implitem.h", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca0b06f86fd44bd6067563dcbf4a2c021f2a79a5/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca0b06f86fd44bd6067563dcbf4a2c021f2a79a5/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h?ref=ca0b06f86fd44bd6067563dcbf4a2c021f2a79a5", "patch": "@@ -67,9 +67,10 @@ class CompileInherentImplItem : public HIRCompileBase\n     Bexpression *value = CompileExpr::Compile (constant.get_expr (), ctx);\n \n     const Resolver::CanonicalPath *canonical_path = nullptr;\n-    rust_assert (ctx->get_mappings ()->lookup_canonical_path (\n+    ok = ctx->get_mappings ()->lookup_canonical_path (\n       constant.get_mappings ().get_crate_num (),\n-      constant.get_mappings ().get_nodeid (), &canonical_path));\n+      constant.get_mappings ().get_nodeid (), &canonical_path);\n+    rust_assert (ok);\n \n     std::string ident = canonical_path->get ();\n     Bexpression *const_expr = ctx->get_backend ()->named_constant_expression (\n@@ -148,9 +149,10 @@ class CompileInherentImplItem : public HIRCompileBase\n       flags |= Backend::function_is_visible;\n \n     const Resolver::CanonicalPath *canonical_path = nullptr;\n-    rust_assert (ctx->get_mappings ()->lookup_canonical_path (\n+    bool ok = ctx->get_mappings ()->lookup_canonical_path (\n       function.get_mappings ().get_crate_num (),\n-      function.get_mappings ().get_nodeid (), &canonical_path));\n+      function.get_mappings ().get_nodeid (), &canonical_path);\n+    rust_assert (ok);\n \n     std::string ir_symbol_name\n       = canonical_path->get () + fntype->subst_as_string ();\n@@ -260,7 +262,7 @@ class CompileInherentImplItem : public HIRCompileBase\n       }\n \n     std::vector<Bvariable *> locals;\n-    bool ok = compile_locals_for_block (*rib, fndecl, locals);\n+    ok = compile_locals_for_block (*rib, fndecl, locals);\n     rust_assert (ok);\n \n     Bblock *enclosing_scope = NULL;\n@@ -358,9 +360,10 @@ class CompileTraitItem : public HIRCompileBase\n       = CompileExpr::Compile (constant.get_expr ().get (), ctx);\n \n     const Resolver::CanonicalPath *canonical_path = nullptr;\n-    rust_assert (ctx->get_mappings ()->lookup_canonical_path (\n+    bool ok = ctx->get_mappings ()->lookup_canonical_path (\n       constant.get_mappings ().get_crate_num (),\n-      constant.get_mappings ().get_nodeid (), &canonical_path));\n+      constant.get_mappings ().get_nodeid (), &canonical_path);\n+    rust_assert (ok);\n \n     std::string ident = canonical_path->get ();\n     Bexpression *const_expr = ctx->get_backend ()->named_constant_expression (\n@@ -413,9 +416,10 @@ class CompileTraitItem : public HIRCompileBase\n     unsigned int flags = 0;\n \n     const Resolver::CanonicalPath *canonical_path = nullptr;\n-    rust_assert (ctx->get_mappings ()->lookup_canonical_path (\n+    bool ok = ctx->get_mappings ()->lookup_canonical_path (\n       func.get_mappings ().get_crate_num (), func.get_mappings ().get_nodeid (),\n-      &canonical_path));\n+      &canonical_path);\n+    rust_assert (ok);\n \n     std::string fn_identifier = canonical_path->get ();\n     std::string asm_name = ctx->mangle_item (fntype, *canonical_path);\n@@ -522,7 +526,7 @@ class CompileTraitItem : public HIRCompileBase\n       }\n \n     std::vector<Bvariable *> locals;\n-    bool ok = compile_locals_for_block (*rib, fndecl, locals);\n+    ok = compile_locals_for_block (*rib, fndecl, locals);\n     rust_assert (ok);\n \n     Bblock *enclosing_scope = NULL;"}, {"sha": "b64f6f0ed92283c7149e4e88ff8c69e90845ddea", "filename": "gcc/rust/backend/rust-compile-item.h", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca0b06f86fd44bd6067563dcbf4a2c021f2a79a5/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca0b06f86fd44bd6067563dcbf4a2c021f2a79a5/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-item.h?ref=ca0b06f86fd44bd6067563dcbf4a2c021f2a79a5", "patch": "@@ -68,9 +68,10 @@ class CompileItem : public HIRCompileBase\n     Bexpression *value = CompileExpr::Compile (var.get_expr (), ctx);\n \n     const Resolver::CanonicalPath *canonical_path = nullptr;\n-    rust_assert (ctx->get_mappings ()->lookup_canonical_path (\n+    ok = ctx->get_mappings ()->lookup_canonical_path (\n       var.get_mappings ().get_crate_num (), var.get_mappings ().get_nodeid (),\n-      &canonical_path));\n+      &canonical_path);\n+    rust_assert (ok);\n \n     std::string name = canonical_path->get ();\n     std::string asm_name = ctx->mangle_item (resolved_type, *canonical_path);\n@@ -103,9 +104,10 @@ class CompileItem : public HIRCompileBase\n     Bexpression *value = CompileExpr::Compile (constant.get_expr (), ctx);\n \n     const Resolver::CanonicalPath *canonical_path = nullptr;\n-    rust_assert (ctx->get_mappings ()->lookup_canonical_path (\n+    ok = ctx->get_mappings ()->lookup_canonical_path (\n       constant.get_mappings ().get_crate_num (),\n-      constant.get_mappings ().get_nodeid (), &canonical_path));\n+      constant.get_mappings ().get_nodeid (), &canonical_path);\n+    rust_assert (ok);\n \n     std::string ident = canonical_path->get ();\n     Bexpression *const_expr\n@@ -186,9 +188,10 @@ class CompileItem : public HIRCompileBase\n       flags |= Backend::function_is_visible;\n \n     const Resolver::CanonicalPath *canonical_path = nullptr;\n-    rust_assert (ctx->get_mappings ()->lookup_canonical_path (\n+    bool ok = ctx->get_mappings ()->lookup_canonical_path (\n       function.get_mappings ().get_crate_num (),\n-      function.get_mappings ().get_nodeid (), &canonical_path));\n+      function.get_mappings ().get_nodeid (), &canonical_path);\n+    rust_assert (ok);\n \n     std::string ir_symbol_name\n       = canonical_path->get () + fntype->subst_as_string ();\n@@ -259,7 +262,7 @@ class CompileItem : public HIRCompileBase\n       }\n \n     std::vector<Bvariable *> locals;\n-    bool ok = compile_locals_for_block (*rib, fndecl, locals);\n+    ok = compile_locals_for_block (*rib, fndecl, locals);\n     rust_assert (ok);\n \n     Bblock *enclosing_scope = NULL;"}, {"sha": "754c5d25126ee2e7c7c396f5f1e60e698a867652", "filename": "gcc/rust/backend/rust-compile-stmt.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca0b06f86fd44bd6067563dcbf4a2c021f2a79a5/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca0b06f86fd44bd6067563dcbf4a2c021f2a79a5/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h?ref=ca0b06f86fd44bd6067563dcbf4a2c021f2a79a5", "patch": "@@ -60,9 +60,10 @@ class CompileStmt : public HIRCompileBase\n     Bexpression *value = CompileExpr::Compile (constant.get_expr (), ctx);\n \n     const Resolver::CanonicalPath *canonical_path = nullptr;\n-    rust_assert (ctx->get_mappings ()->lookup_canonical_path (\n+    ok = ctx->get_mappings ()->lookup_canonical_path (\n       constant.get_mappings ().get_crate_num (),\n-      constant.get_mappings ().get_nodeid (), &canonical_path));\n+      constant.get_mappings ().get_nodeid (), &canonical_path);\n+    rust_assert (ok);\n \n     std::string ident = canonical_path->get ();\n     Bexpression *const_expr"}]}