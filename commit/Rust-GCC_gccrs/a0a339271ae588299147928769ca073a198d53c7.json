{"sha": "a0a339271ae588299147928769ca073a198d53c7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTBhMzM5MjcxYWU1ODgyOTkxNDc5Mjg3NjljYTA3M2ExOThkNTNjNw==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1994-06-03T21:42:31Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1994-06-03T21:42:31Z"}, "message": "39th Cygnus<->FSF merge\n\nFrom-SVN: r7439", "tree": {"sha": "2bfb1009d1a11061dfd6aad7e84a40e551c0af50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2bfb1009d1a11061dfd6aad7e84a40e551c0af50"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a0a339271ae588299147928769ca073a198d53c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0a339271ae588299147928769ca073a198d53c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0a339271ae588299147928769ca073a198d53c7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0a339271ae588299147928769ca073a198d53c7/comments", "author": null, "committer": null, "parents": [{"sha": "5345f91a0be605ab09f2f42abecd1a0fc5083f47", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5345f91a0be605ab09f2f42abecd1a0fc5083f47", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5345f91a0be605ab09f2f42abecd1a0fc5083f47"}], "stats": {"total": 1672, "additions": 1080, "deletions": 592}, "files": [{"sha": "385d239cb7842e8b10103cceebf4135a827a928c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 286, "deletions": 11, "changes": 297, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0a339271ae588299147928769ca073a198d53c7/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0a339271ae588299147928769ca073a198d53c7/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a0a339271ae588299147928769ca073a198d53c7", "patch": "@@ -1,3 +1,289 @@\n+Fri Jun  3 02:10:56 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* cvt.c (cp_convert): Replace constants with their values before\n+\tconverting.\n+\n+Thu Jun  2 03:53:30 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* typeck2.c (build_x_arrow): Resolve OFFSET_REFs first.\n+\n+Wed Jun  1 18:57:35 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* typeck2.c (digest_init): Handle initializing a pmf with an\n+\toverloaded method.\n+\t* typeck.c (build_ptrmemfunc): Handle overloaded methods.\n+\n+\t* decl.c (pushtag): Use build_decl to make TYPE_DECLs.\n+\t(xref_defn_tag): Ditto.\n+\t* pt.c (process_template_parm): Ditto.\n+\t(lookup_template_class): Ditto.\n+\t(push_template_decls): Ditto.\n+\t(instantiate_class_template): Ditto.\n+\t(create_nested_upt): Ditto.\n+\t* class.c (finish_struct): Don't try to set DECL_CLASS_CONTEXT on\n+\tTYPE_DECLs.\n+\n+\t* typeck.c (convert_arguments): Make sure type is not NULL before\n+\tchecking its TREE_CODE.\n+\n+Wed Jun  1 17:40:39 1994  Mike Stump  (mrs@cygnus.com)\n+\n+\t* class.c (get_derived_offset): New routine.\n+\t* class.c (finish_base_struct): Make sure we set BINFO_VTABLE and\n+\tBINFO_VIRTUALS when we choose a new base class to inherit from.\n+\t* class.c (modify_one_vtable): Use get_derived_offset to get the\n+\toffset to the most base class subobject that we derived this binfo\n+\tfrom.\n+\t* class.c (finish_struct): Move code to calculate the\n+\tDECL_FIELD_BITPOS of the vfield up, as we need might need it for\n+\tnew calls to get_derived_offset in modify_one_vtable.\n+\n+Wed Jun  1 16:50:59 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* init.c (build_member_call): Use build_pointer_type instead of\n+\tTYPE_POINTER_TO.\n+\n+Wed Jun  1 11:11:15 1994  Brendan Kehoe  (brendan@lisa.cygnus.com)\n+\n+\t* decl.c (grokdeclarator): Make sure we have a DNAME set before we\n+\ttry to use it in an error.\n+\n+Wed Jun  1 09:48:49 1994  Mike Stump  (mrs@cygnus.com)\n+\n+\t* typeck.c (convert_arguments, convert_for_initialization): Don't\n+\tstrip NOP_EXPRs, when we are converting to a reference.\n+\n+Wed Jun  1 01:11:38 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* typeck.c (build_modify_expr): Don't dereference references when\n+\tinitializing them.\n+\n+\t* decl2.c (grokfield): Don't check for grokdeclarator returning\n+\terror_mark_node any more.\n+\n+\t* decl.c (grokfndecl): Return NULL_TREE instead of error_mark_node.\n+\t(start_method): Return void_type_node instead of error_mark_node.\n+\n+\t* typeck.c (build_modify_expr): Resolve offset refs earlier.\n+\n+Tue May 31 16:06:58 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* call.c (build_method_call): Resolve OFFSET_REFs in the object.\n+\n+\t* typeck.c (build_modify_expr): Dereference references before trying\n+\tto assign to them.\n+\n+\t* call.c (build_method_call): Don't confuse type conversion\n+\toperators with constructors.\n+\t* typeck2.c (build_functional_cast): Just call build_c_cast if there\n+\twas only one parameter.\n+\t* method.c (build_typename_overload): Don't set\n+\tIDENTIFIER_GLOBAL_VALUE on these identifiers.\n+\t* decl.c (grok_op_properties): Warn about defining a type conversion\n+\toperator that converts to a base class (or reference to it).\n+\t* cvt.c (cp_convert): Don't try to use a type conversion operator\n+\twhen converting to a base class.\n+\t(build_type_conversion_1): Don't call constructor_name_full on an\n+\tidentifier.\n+\t* cp-tree.h (DERIVED_FROM_P): Should be self-explanatory.\n+\n+\t* decl.c (start_decl): Don't complain that error_mark_node is an\n+\tincomplete type.\n+\t(finish_decl): Check for type == error_mark_node.\n+\n+Mon May 30 23:38:55 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* decl.c (start_function): Set DECL_DEFER_OUTPUT on implicit\n+\tinstantiations and inline members.\n+\n+\t* spew.c (yylex): Set looking_for_template if the next token is a '<'.\n+\n+\t* lex.h: Declare looking_for_template.\n+\n+\t* decl.c (lookup_name_real): Use looking_for_template to arbitrate\n+\tbetween type and template interpretations of an identifier.\n+\n+Sat May 28 04:07:40 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* pt.c (instantiate_template): Zero out p if we found a\n+\tspecialization.\n+\n+\t* decl.c (grokdeclarator): Elucidate warning.\n+\t(grokdeclarator): If pedantic AND -ansi, complain about long long.\n+\n+\tMake explicit instantiation work reasonably.  It is now appropriate\n+\tto deprecate the use of -fexternal-templates.\n+\t* pt.c (instantiate_template): Set DECL_TEMPLATE_SPECIALIZATION or\n+\tDECL_IMPLICIT_INSTANTIATION on fndecl as appropriate.\n+\t(end_template_instantiation): Reflect changes in USE_TEMPLATE\n+\tsemantics.\n+\t(do_pending_expansions): if (!flag_implicit_templates) DECIDE(0);\n+\t(do_function_instantiation): Don't set EXPLICIT_INST if\n+\tflag_external_templates is set.  Do set TREE_PUBLIC and DECL_EXTERN\n+\tappropriately otherwise.\n+\t(do_type_instantiation): Set interface info for class.  Set\n+\tTREE_PUBLIC and DECL_EXTERN for methods.  Do none of this if\n+\tflag_external_templates is set.\n+\t* parse.y: Reflect changes in USE_TEMPLATE semantics.\n+\t* decl2.c: New flag flag_implicit_templates determines whether or\n+\tnot implicit instantiations get emitted.  This flag currently\n+\tdefaults to true, and must be true for -fexternal-templates to work.\n+\t(finish_file): Consider flag_implement_inlines when\n+\tsetting DECL_EXTERNAL.  Consider flag_implicit_templates when\n+\tdeciding whether or not to emit a static copy.\n+\t* decl.c (start_function): Set TREE_PUBLIC and DECL_EXTERNAL\n+\tproperly for template instantiations.\n+\t(start_method): Set DECL_IMPLICIT_INSTANTIATION on methods of a\n+\ttemplate class.\n+\t* cp-tree.h (CLASSTYPE_USE_TEMPLATE): Change semantics.\n+\t(DECL_USE_TEMPLATE): Parallel macro for FUNCTION and VAR_DECLs.\n+\t(various others): Accessor macros for the above.\n+\n+Fri May 27 13:57:40 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* typeck.c (build_binary_op_nodefault): Division by constant zero is\n+\tan error.\n+\n+Fri May 27 13:50:15 1994  Mike Stump  (mrs@cygnus.com)\n+\n+\t* class.c (override_one_vtable): Don't modify things we don't own.\n+\n+Fri May 27 01:42:58 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* decl.c (finish_decl): Don't postpone processing the initializer of\n+\ta decl with DECL_EXTERNAL set, and do call rest_of_compilation for a\n+\tPUBLIC const at toplevel.\n+\t(grokdeclarator): pedwarn about initializing non-const or\n+\tnon-integral statics in the class body.\n+\n+\t* decl.c (pushtag): Don't try to set DECL_CLASS_CONTEXT on a\n+\tTYPE_DECL.\n+\n+\t* call.c (convert_harshness): Dereference reference on rhs before\n+\tproceeding, properly grok passing const things to non-const\n+\treferences.\n+\n+\t* typeck.c (build_unary_op): Soften error about taking the address\n+\tof main() to a pedwarn.\n+\n+\t* lex.c (default_copy_constructor_body): Unambiguously specify base\n+\tclasses (i.e. A((const class ::A&)_ctor_arg) ).\n+\t(default_assign_ref_body): Ditto.\n+\n+Thu May 26 13:13:55 1994  Gerald Baumgartner  (gb@mexican.cygnus.com)\n+\n+\t* decl2.c (grokfield): Don't complain about local signature\n+\tmethod declaration without definition.\n+\n+\t* call.c (convert_harshness): If `type' is a signature pointer\n+\tand `parmtype' is a pointer to a signature, just return 0.  We\n+\tdon't really convert in this case; it's a result of making the\n+\t`this' parameter of a signature method a signature pointer.\n+\n+\t* call.c (build_method_call): Distinguish calling the default copy\n+\tconstructor of a signature pointer/reference from a signature\n+\tmember function call.\n+\n+Thu May 26 12:56:25 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* decl2.c (grokfield): Don't set TREE_PUBLIC on member function\n+\tdeclarations.\n+\n+\t* decl.c (duplicate_decls): A previous function declaration as\n+\tstatic overrides a subsequent non-static definition.\n+\t(grokdeclarator): Don't set TREE_PUBLIC on inline method\n+\tdeclarations.\n+\n+Wed May 25 14:36:38 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* decl.c (grokdeclarator): Handle initialization of static const\n+\tmembers.\n+\t(finish_decl): Ditto.\n+\n+\t* decl2.c (grokfield): Allow initialization of static const members\n+\teven when pedantic.\n+\n+\t* decl2.c (grokfield): Deal with grokdeclarator returning\n+\terror_mark_node.\n+\n+\t* decl.c (grok_ctor_properties): Return 0 for A(A) constructor.\n+\t(grokfndecl): Check the return value of grok_ctor_properties.\n+\t(start_method): Ditto.\n+\n+\t* parse.y (absdcl): Expand type_quals inline.\n+\n+Tue May 24 19:10:32 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* decl.c (pushtag): Use IS_AGGR_TYPE rather than checking for a\n+\tRECORD_TYPE.\n+\n+Tue May 24 18:09:16 1994  Per Bothner  (bothner@kalessin.cygnus.com)\n+\n+\t* cp-tree.h (VTABLE_NAME_FORMAT):  If flag_vtable_thunks,\n+\talways use \"__vt_%s\".\n+\t* decl2.c (finish_vtable_vardecl):  Don't consider abstract virtuals\n+\twhen looking for a \"sentinal\" method (to decide on emitting vtables).\n+\t* decl2.c (finish_file):  Scan all decls for thunks that need\n+\tto be emitted.\n+\t* decl2.c (finish_vtable_vardecl):  Don't bother calling emit_thunk.\n+\t* method.c (make_thunk):  Use a more meaningful label.  If there\n+\texists a matching top-level THUNK_DECL re-use it;  otherwise\n+\tcreate a new THUNK_DECL (and declare it).\n+\t* method.c (emit_thunk):  Make thunk external/public depending\n+\ton the underlying method.\n+\n+Tue May 24 00:22:04 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* pt.c (tsubst): Use lookup_name_nonclass to find guiding decls, not\n+\tlookup_name.\n+\n+\t* call.c (build_overload_call_real): Don't immediately pick a\n+\tfunction which matches perfectly.\n+\n+\t* decl.c (grokdeclarator): Use c_build_type_variant for arrays.\n+\t(grokdeclarator): Warn about, and throw away, cv-quals attached to a\n+\treference (like 'int &const j').\n+\n+\t* typeck.c (convert_arguments): Don't mess with i for methods.\n+\t* call.c (build_method_call): Pass the function decl to\n+\tconvert_arguments.\n+\n+\t* typeck.c (comp_ptr_ttypes_real): New function.  Implements the\n+\tchecking for which multi-level pointer conversions are allowed.\n+\t(comp_target_types): Call it.\n+\t(convert_for_assignment): Check const parity on the ultimate target\n+\ttype, too.  And make those warnings pedwarns.\n+\n+Mon May 23 14:11:24 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* error.c (dump_char): Use TARGET_* for character constants.\n+\n+Mon May 23 13:03:03 1994  Brendan Kehoe  (brendan@lisa.cygnus.com)\n+\n+\t* tree.c (debug_no_list_hash): Make static.\n+\n+\t* decl.c (decls_match): Say the types don't match if newdecl ends up\n+\twith a null type, after we've checked if olddecl does.\n+\t(pushdecl): Check if the decls themselves match before looking for\n+\tan extern redeclared as static, to avoid inappropriate and incorrect\n+\twarnings.\n+\n+Fri May 20 14:04:34 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* decl.c (grokdeclarator): Make warning about duplicate short, etc.\n+\ta pedwarn.\n+\n+\t* typeck.c (build_c_cast): Casting to function or method type is an\n+\terror.\n+\n+\t* class.c (finish_struct): Make warning for anonymous class with no\n+\tinstances a pedwarn.\n+\n+\t* Makefile.in (stamp-parse): Expect a s/r conflict.\n+\n+\t* typeck.c (build_modify_expr): pedwarn about using a non-lvalue\n+\tcast as an lvalue.\n+\n Thu May 19 12:08:48 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \n \t* cvt.c (type_promotes_to): Make sure bool promotes to int rather\n@@ -30,17 +316,6 @@ Wed May 18 14:27:06 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \n \t* class.c (finish_struct): Allow bool bitfields.\n \n-Wed May 18 14:41:59 1994  Mike Stump  (mrs@cygnus.com)\n-\n-\t* class.c (finish_base_struct): Make sure we set BINFO_VTABLE and\n-\tBINFO_VIRTUALS when we choose a new base class to inherit from.\n-\t* class.c (modify_one_vtable): Use get_vfield_offset to get the\n-\toffset to the most base class subobject that we derived this binfo\n-\tfrom.\n-\t* class.c (finish_struct): Move code to calculate the\n-\tDECL_FIELD_BITPOS of the vfield up, as we need might need it for\n-\tnew calls to get_vfield_offset in modify_one_vtable.\n-\n Wed May 18 12:35:27 1994  Ian Lance Taylor  (ian@tweedledumb.cygnus.com)\n \n \t* Make-lang.in (c++.install-man): Get g++.1 from $(srcdir)/cp."}, {"sha": "b8882897dc2dcf26610e65512ddc72cc30482c8e", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 23, "deletions": 12, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0a339271ae588299147928769ca073a198d53c7/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0a339271ae588299147928769ca073a198d53c7/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=a0a339271ae588299147928769ca073a198d53c7", "patch": "@@ -41,6 +41,15 @@ CXX_FLAGS_TO_PASS = \\\n \t\"CXXFLAGS=$(CXXFLAGS)\" \\\n \t\"CXX_FOR_TARGET=$(CXX_FOR_TARGET)\"\n \n+# Actual names to use when installing a native compiler.\n+CXX_INSTALL_NAME = c++\n+GXX_INSTALL_NAME = g++\n+\n+# Actual names to use when installing a cross-compiler.\n+CXX_CROSS_NAME = $(target)-c++\n+GXX_CROSS_NAME = $(target)-g++\n+\n+\f\n # Define the names for selecting c++ in LANGUAGES.\n # Note that it would be nice to move the dependency on g++\n # into the C++ rule, but that needs a little bit of work\n@@ -90,17 +99,17 @@ c++.install-normal:\n c++.install-common:\n \t-if [ -f cc1plus ] ; then \\\n \t  if [ -f g++-cross ] ; then \\\n-\t    rm -f $(bindir)/$(target)-g++; \\\n-\t    $(INSTALL_PROGRAM) g++-cross $(bindir)/$(target)-g++; \\\n-\t    chmod a+x $(bindir)/$(target)-g++; \\\n-\t    rm -f $(bindir)/$(target)-c++; \\\n-\t    ln $(bindir)/$(target)-g++ $(bindir)/$(target)-c++; \\\n+\t    rm -f $(bindir)/$(GXX_CROSS_NAME); \\\n+\t    $(INSTALL_PROGRAM) g++-cross $(bindir)/$(GXX_CROSS_NAME); \\\n+\t    chmod a+x $(bindir)/$(GXX_CROSS_NAME); \\\n+\t    rm -f $(bindir)/$(CXX_CROSS_NAME); \\\n+\t    ln $(bindir)/$(GXX_CROSS_NAME) $(bindir)/$(CXX_CROSS_NAME); \\\n \t  else \\\n-\t    rm -f $(bindir)/g++; \\\n-\t    $(INSTALL_PROGRAM) g++ $(bindir)/g++; \\\n-\t    chmod a+x $(bindir)/g++; \\\n-\t    rm -f $(bindir)/c++; \\\n-\t    ln $(bindir)/g++ $(bindir)/c++; \\\n+\t    rm -f $(bindir)/$(GXX_INSTALL_NAME); \\\n+\t    $(INSTALL_PROGRAM) g++ $(bindir)/$(GXX_INSTALL_NAME); \\\n+\t    chmod a+x $(bindir)/$(GXX_INSTALL_NAME); \\\n+\t    rm -f $(bindir)/$(CXX_INSTALL_NAME); \\\n+\t    ln $(bindir)/$(GXX_INSTALL_NAME) $(bindir)/$(CXX_INSTALL_NAME); \\\n \t  fi ; \\\n \tfi\n \n@@ -113,8 +122,10 @@ c++.install-man: $(srcdir)/cp/g++.1\n \telse true; fi\n \n c++.uninstall:\n-\t-rm -rf $(bindir)/g++ $(bindir)/c++\n-\t-rm -rf $(bindir)/$(target)-g++ $(bindir)/$(target)-c++\n+\t-rm -rf $(bindir)/$(CXX_INSTALL_NAME)\n+\t-rm -rf $(bindir)/$(CXX_CROSS_NAME)\n+\t-rm -rf $(bindir)/$(GXX_INSTALL_NAME)\n+\t-rm -rf $(bindir)/$(GXX_CROSS_NAME)\n \t-rm -rf $(mandir)/g++$(manext)\n \f\n # Clean hooks:"}, {"sha": "231d1a31e3158ee12fbc529e77159f7f5f2be3bc", "filename": "gcc/cp/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0a339271ae588299147928769ca073a198d53c7/gcc%2Fcp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0a339271ae588299147928769ca073a198d53c7/gcc%2Fcp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMakefile.in?ref=a0a339271ae588299147928769ca073a198d53c7", "patch": "@@ -193,7 +193,7 @@ parse.o : $(srcdir)/parse.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h lex.h\n   `echo $(srcdir)/parse.c | sed 's,^\\./,,'`\n \n $(srcdir)/parse.c $(srcdir)/parse.h : $(srcdir)/parse.y\n-\t@echo expect 33 reduce/reduce conflicts.\n+\t@echo expect 1 shift/reduce confict and 33 reduce/reduce conflicts.\n \tcd $(srcdir); $(BISON) $(BISONFLAGS) -d -o parse.c parse.y\n \tcd $(srcdir); grep '^#define[ \t]*YYEMPTY' parse.c >>parse.h\n "}, {"sha": "6d2b26c86099cbfab7faa93ae84437a7c1ba08ba", "filename": "gcc/cp/call.c", "status": "modified", "additions": 140, "deletions": 197, "changes": 337, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0a339271ae588299147928769ca073a198d53c7/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0a339271ae588299147928769ca073a198d53c7/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=a0a339271ae588299147928769ca073a198d53c7", "patch": "@@ -131,6 +131,13 @@ convert_harshness (type, parmtype, parm)\n   if (TYPE_PTRMEMFUNC_P (parmtype))\n     parmtype = TYPE_PTRMEMFUNC_FN_TYPE (parmtype);\n \n+  if (TREE_CODE (parmtype) == REFERENCE_TYPE)\n+    {\n+      if (parm)\n+\tparm = convert_from_reference (parm);\n+      parmtype = TREE_TYPE (parmtype);\n+    }\n+\n   codel = TREE_CODE (type);\n   coder = TREE_CODE (parmtype);\n \n@@ -474,196 +481,138 @@ convert_harshness (type, parmtype, parm)\n \t}\n     }\n \n-  /* C++: one of the types must be a reference type.  */\n-  {\n-    tree ttl, ttr;\n-    register tree intype = TYPE_MAIN_VARIANT (parmtype);\n-    register enum tree_code form = TREE_CODE (intype);\n-    int penalty = 0;\n-\n-    if (codel == REFERENCE_TYPE || coder == REFERENCE_TYPE)\n-      {\n-\tttl = TYPE_MAIN_VARIANT (type);\n-\n-\tif (codel == REFERENCE_TYPE)\n-\t  {\n-\t    ttl = TREE_TYPE (ttl);\n+  /* C++: Since the `this' parameter of a signature member function\n+     is represented as a signature pointer to handle default implementations\n+     correctly, we can have the case that `type' is a signature pointer\n+     while `parmtype' is a pointer to a signature table.  We don't really\n+     do any conversions in this case, so just return 0.  */\n \n-\t    /* When passing a non-const argument into a const reference,\n-\t       dig it a little, so a non-const reference is preferred over\n-\t       this one. (mrs) */\n-\t    if (parm && TREE_READONLY (ttl) && ! TREE_READONLY (parm))\n-\t      penalty = 2;\n-\t    else\n-\t      penalty = 0;\n+  if (codel == RECORD_TYPE && coder == POINTER_TYPE\n+      && IS_SIGNATURE_POINTER (type) && IS_SIGNATURE (TREE_TYPE (parmtype)))\n+    return ZERO_RETURN (h);\n \n-\t    ttl = TYPE_MAIN_VARIANT (ttl);\n+  if (codel == REFERENCE_TYPE)\n+    {\n+      tree ttl, ttr;\n+      int constp = parm ? TREE_READONLY (parm) : TYPE_READONLY (parmtype);\n+      int volatilep = (parm ? TREE_THIS_VOLATILE (parm)\n+\t\t       : TYPE_VOLATILE (parmtype));\n+      register tree intype = TYPE_MAIN_VARIANT (parmtype);\n+      register enum tree_code form = TREE_CODE (intype);\n+      int penalty = 0;\n+\n+      ttl = TREE_TYPE (type);\n+\n+      /* When passing a non-const argument into a const reference (or vice\n+\t versa), dig it a little, so a non-const reference is preferred\n+\t over this one. (mrs) */\n+      if (TYPE_READONLY (ttl) != constp\n+\t  || TYPE_VOLATILE (ttl) != volatilep)\n+\tpenalty = 2;\n+      else\n+\tpenalty = 0;\n \n-\t    if (form == OFFSET_TYPE)\n-\t      {\n-\t\tintype = TREE_TYPE (intype);\n-\t\tform = TREE_CODE (intype);\n-\t      }\n+      ttl = TYPE_MAIN_VARIANT (ttl);\n \n-\t    if (form == REFERENCE_TYPE)\n-\t      {\n-\t\tintype = TYPE_MAIN_VARIANT (TREE_TYPE (intype));\n+      if (form == OFFSET_TYPE)\n+\t{\n+\t  intype = TREE_TYPE (intype);\n+\t  form = TREE_CODE (intype);\n+\t}\n \n-\t\tif (ttl == intype)\n-\t\t  return ZERO_RETURN (h);\n-\t\tpenalty = 2;\n-\t      }\n-\t    else\n-\t      {\n-\t\t/* Can reference be built up?  */\n-\t\tif (ttl == intype && penalty == 0) {\n-\t\t  /* Because the READONLY and VIRTUAL bits are not always in\n-\t\t     the type, this extra check is necessary.  The problem\n-\t\t     should be fixed someplace else, and this extra code\n-\t\t     removed.\n-\n-\t\t     Also, if type if a reference, the readonly bits could\n-\t\t     either be in the outer type (with reference) or on the\n-\t\t     inner type (the thing being referenced).  (mrs)  */\n-\t\t  if (parm\n-\t\t      && ((TREE_READONLY (parm)\n-\t\t\t   && ! (TYPE_READONLY (type)\n-\t\t\t\t || (TREE_CODE (type) == REFERENCE_TYPE\n-\t\t\t\t     && TYPE_READONLY (TREE_TYPE (type)))))\n-\t\t\t  || (TREE_SIDE_EFFECTS (parm)\n-\t\t\t      && ! (TYPE_VOLATILE (type)\n-\t\t\t\t    || (TREE_CODE (type) == REFERENCE_TYPE\n-\t\t\t\t\t&& TYPE_VOLATILE (TREE_TYPE (type)))))))\n-\t\t    penalty = 2;\n-\t\t  else\n-\t\t    return ZERO_RETURN (h);\n-\t\t}\n-\t\telse\n-\t\t  penalty = 2;\n-\t      }\n-\t  }\n-\telse if (form == REFERENCE_TYPE)\n-\t  {\n-\t    if (parm)\n-\t      {\n-\t\ttree tmp = convert_from_reference (parm);\n-\t\tintype = TYPE_MAIN_VARIANT (TREE_TYPE (tmp));\n-\t      }\n-\t    else\n-\t      {\n-\t\tintype = parmtype;\n-\t\tdo\n-\t\t  intype = TREE_TYPE (intype);\n-\t\twhile (TREE_CODE (intype) == REFERENCE_TYPE);\n-\t\tintype = TYPE_MAIN_VARIANT (intype);\n-\t      }\n-\n-\t    if (ttl == intype)\n-\t      return ZERO_RETURN (h);\n-\t    else\n-\t      penalty = 2;\n-\t  }\n+      if (ttl == intype && penalty == 0)\n+\treturn ZERO_RETURN (h);\n+      else\n+\tpenalty = 2;\n \n-\tif (TREE_UNSIGNED (ttl) ^ TREE_UNSIGNED (intype))\n-\t  {\n-\t    ttl = unsigned_type (ttl);\n-\t    intype = unsigned_type (intype);\n-\t    penalty += 2;\n-\t  }\n+      if (TREE_UNSIGNED (ttl) ^ TREE_UNSIGNED (intype))\n+\t{\n+\t  ttl = unsigned_type (ttl);\n+\t  intype = unsigned_type (intype);\n+\t  penalty += 2;\n+\t}\n \n-\tttr = intype;\n+      ttr = intype;\n \n-\t/* If the initializer is not an lvalue, then it does not\n-\t   matter if we make life easier for the programmer\n-\t   by creating a temporary variable with which to\n-\t   hold the result.  */\n-\tif (parm && (INTEGRAL_CODE_P (coder)\n-\t\t     || coder == REAL_TYPE)\n-\t    && ! lvalue_p (parm))\n-\t  {\n-\t    h = convert_harshness (ttl, ttr, NULL_TREE);\n-\t    if (penalty > 2 || h.code != 0)\n-\t      h.code |= STD_CODE;\n-\t    else\n-\t      h.code |= TRIVIAL_CODE;\n-\t    h.distance = 0;\n-\t    return h;\n-\t  }\n+      /* If the initializer is not an lvalue, then it does not\n+\t matter if we make life easier for the programmer\n+\t by creating a temporary variable with which to\n+\t hold the result.  */\n+      if (parm && (INTEGRAL_CODE_P (coder)\n+\t\t   || coder == REAL_TYPE)\n+\t  && ! lvalue_p (parm))\n+\t{\n+\t  h = convert_harshness (ttl, ttr, NULL_TREE);\n+\t  if (penalty > 2 || h.code != 0)\n+\t    h.code |= STD_CODE;\n+\t  else\n+\t    h.code |= TRIVIAL_CODE;\n+\t  h.distance = 0;\n+\t  return h;\n+\t}\n \n-\tif (ttl == ttr)\n-\t  {\n-\t    if (penalty > 2)\n-\t      {\n-\t\th.code = STD_CODE;\n-\t\th.distance = 0;\n-\t      }\n-\t    else\n-\t      {\n-\t\th.code = TRIVIAL_CODE;\n-\t\t/* We set this here so that build_overload_call_real will be\n-\t\t   able to see the penalty we found, rather than just looking\n-\t\t   at a TRIVIAL_CODE with no other information.  */\n-\t\th.int_penalty = penalty;\n-\t      }\n-\t    return h;\n-\t  }\n+      if (ttl == ttr)\n+\t{\n+\t  if (penalty > 2)\n+\t    {\n+\t      h.code = STD_CODE;\n+\t      h.distance = 0;\n+\t    }\n+\t  else\n+\t    {\n+\t      h.code = TRIVIAL_CODE;\n+\t      /* We set this here so that build_overload_call_real will be\n+\t\t able to see the penalty we found, rather than just looking\n+\t\t at a TRIVIAL_CODE with no other information.  */\n+\t      h.int_penalty = penalty;\n+\t    }\n+\t  return h;\n+\t}\n \n-\t/* Pointers to voids always convert for pointers.  But\n-\t   make them less natural than more specific matches.  */\n-\tif (TREE_CODE (ttl) == POINTER_TYPE && TREE_CODE (ttr) == POINTER_TYPE)\n-\t  {\n-\t    if (TREE_TYPE (ttl) == void_type_node\n-\t\t|| TREE_TYPE (ttr) == void_type_node)\n-\t      {\n-\t\th.code = STD_CODE;\n-\t\th.distance = 0;\n-\t\treturn h;\n-\t      }\n-\t  }\n+      /* Pointers to voids always convert for pointers.  But\n+\t make them less natural than more specific matches.  */\n+      if (TREE_CODE (ttl) == POINTER_TYPE && TREE_CODE (ttr) == POINTER_TYPE)\n+\t{\n+\t  if (TREE_TYPE (ttl) == void_type_node\n+\t      || TREE_TYPE (ttr) == void_type_node)\n+\t    {\n+\t      h.code = STD_CODE;\n+\t      h.distance = 0;\n+\t      return h;\n+\t    }\n+\t}\n \n-\tif (parm && codel != REFERENCE_TYPE)\n-\t  {\n-\t    h = convert_harshness (ttl, ttr, NULL_TREE);\n-\t    if (penalty == 2)\n-\t      h.code |= QUAL_CODE;\n-\t    else if (penalty == 4)\n-\t      h.code |= STD_CODE;\n-\t    h.distance = 0;\n-\t    return h;\n-\t  }\n+      /* Here it does matter.  If this conversion is from derived to base,\n+\t allow it.  Otherwise, types must be compatible in the strong sense.  */\n+      if (TREE_CODE (ttl) == RECORD_TYPE && TREE_CODE (ttr) == RECORD_TYPE)\n+\t{\n+\t  int b_or_d = get_base_distance (ttl, ttr, 0, 0);\n+\t  if (b_or_d < 0)\n+\t    {\n+\t      b_or_d = get_base_distance (ttr, ttl, 0, 0);\n+\t      if (b_or_d < 0)\n+\t\treturn EVIL_RETURN (h);\n+\t      h.distance = -b_or_d;\n+\t    }\n+\t  /* Say that this conversion is relatively painless.\n+\t     If it turns out that there is a user-defined X(X&)\n+\t     constructor, then that will be invoked, but that's\n+\t     preferable to dealing with other user-defined conversions\n+\t     that may produce surprising results.  */\n+\t  else\n+\t    h.distance = b_or_d;\n+\t  h.code = STD_CODE;\n+\t  return h;\n+\t}\n \n-\t/* Here it does matter.  If this conversion is from derived to base,\n-\t   allow it.  Otherwise, types must be compatible in the strong sense.  */\n-\tif (TREE_CODE (ttl) == RECORD_TYPE && TREE_CODE (ttr) == RECORD_TYPE)\n-\t  {\n-\t    int b_or_d = get_base_distance (ttl, ttr, 0, 0);\n-\t    if (b_or_d < 0)\n-\t      {\n-\t\tb_or_d = get_base_distance (ttr, ttl, 0, 0);\n-\t\tif (b_or_d < 0)\n-\t\t  return EVIL_RETURN (h);\n-\t\th.distance = -b_or_d;\n-\t      }\n-\t    /* Say that this conversion is relatively painless.\n-\t       If it turns out that there is a user-defined X(X&)\n-\t       constructor, then that will be invoked, but that's\n-\t       preferable to dealing with other user-defined conversions\n-\t       that may produce surprising results.  */\n-\t    else\n-\t      h.distance = b_or_d;\n+      if (comp_target_types (ttl, intype, 1))\n+\t{\n+\t  if (penalty)\n \t    h.code = STD_CODE;\n-\t    return h;\n-\t  }\n-\n-\tif (comp_target_types (ttl, intype, 1))\n-\t  {\n-\t    if (penalty)\n-\t      h.code = STD_CODE;\n-\t    h.distance = 0;\n-\t    return h;\n-\t  }\n-      }\n-  }\n+\t  h.distance = 0;\n+\t  return h;\n+\t}\n+    }\n   if (codel == RECORD_TYPE && coder == RECORD_TYPE)\n     {\n       int b_or_d = get_base_distance (type, parmtype, 0, 0);\n@@ -1789,6 +1738,9 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t && TREE_CODE (TREE_OPERAND (instance, 0)) == NOP_EXPR\n \t && TREE_OPERAND (TREE_OPERAND (instance, 0), 0) == error_mark_node);\n \n+      if (TREE_CODE (instance) == OFFSET_REF)\n+\tinstance = resolve_offset_ref (instance);\n+\n       /* the base type of an instance variable is pointer to class */\n       basetype = TREE_TYPE (instance);\n \n@@ -1808,8 +1760,12 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t  if (! IS_AGGR_TYPE (basetype))\n \t    goto non_aggr_error;\n \n-\t  if (IS_SIGNATURE_POINTER (basetype)\n-\t      || IS_SIGNATURE_REFERENCE (basetype))\n+\t  /* If `instance' is a signature pointer/reference and `name' is\n+\t     not a constructor, we are calling a signature member function.\n+\t     In that case set the `basetype' to the signature type.  */\n+\t  if ((IS_SIGNATURE_POINTER (basetype)\n+\t       || IS_SIGNATURE_REFERENCE (basetype))\n+\t      && TYPE_IDENTIFIER (basetype) != name)\n \t    basetype = SIGNATURE_TYPE (basetype);\n \n \t  if ((IS_SIGNATURE (basetype)\n@@ -2001,8 +1957,9 @@ build_method_call (instance, name, parms, basetype_path, flags)\n   /* Look up function name in the structure type definition.  */\n \n   if ((IDENTIFIER_HAS_TYPE_VALUE (name)\n+       && ! IDENTIFIER_OPNAME_P (name)\n        && IS_AGGR_TYPE (IDENTIFIER_TYPE_VALUE (name))\n-       && TREE_CODE(IDENTIFIER_TYPE_VALUE (name)) != UNINSTANTIATED_P_TYPE)\n+       && TREE_CODE (IDENTIFIER_TYPE_VALUE (name)) != UNINSTANTIATED_P_TYPE)\n       || name == constructor_name (basetype))\n     {\n       tree tmp = NULL_TREE;\n@@ -2494,11 +2451,9 @@ build_method_call (instance, name, parms, basetype_path, flags)\n       return error_mark_node;\n     }\n \n-  /* We do not pass FUNCTION into `convert_arguments', because by\n-     now everything should be ok.  If not, then we have a serious error.  */\n   if (DECL_STATIC_FUNCTION_P (function))\n     parms = convert_arguments (NULL_TREE, TYPE_ARG_TYPES (fntype),\n-\t\t\t       TREE_CHAIN (parms), NULL_TREE, LOOKUP_NORMAL);\n+\t\t\t       TREE_CHAIN (parms), function, LOOKUP_NORMAL);\n   else if (need_vtbl == unneeded)\n     {\n       int sub_flags = DECL_CONSTRUCTOR_P (function) ? flags : LOOKUP_NORMAL;\n@@ -2511,7 +2466,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t  instance = build_indirect_ref (instance_ptr, NULL_PTR);\n \t}\n       parms = tree_cons (NULL_TREE, instance_ptr,\n-\t\t\t convert_arguments (NULL_TREE, TREE_CHAIN (TYPE_ARG_TYPES (fntype)), TREE_CHAIN (parms), NULL_TREE, sub_flags));\n+\t\t\t convert_arguments (NULL_TREE, TREE_CHAIN (TYPE_ARG_TYPES (fntype)), TREE_CHAIN (parms), function, sub_flags));\n     }\n   else\n     {\n@@ -2559,7 +2514,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t    instance = build_indirect_ref (instance_ptr, NULL_PTR);\n \t}\n       parms = tree_cons (NULL_TREE, instance_ptr,\n-\t\t\t convert_arguments (NULL_TREE, TREE_CHAIN (TYPE_ARG_TYPES (fntype)), TREE_CHAIN (parms), NULL_TREE, LOOKUP_NORMAL));\n+\t\t\t convert_arguments (NULL_TREE, TREE_CHAIN (TYPE_ARG_TYPES (fntype)), TREE_CHAIN (parms), function, LOOKUP_NORMAL));\n     }\n \n #if 0\n@@ -2861,18 +2816,6 @@ build_overload_call_real (fnname, parms, flags, final_cp, buildxxx)\n \t  if ((cp[0].h.code & EVIL_CODE) == 0)\n \t    {\n \t      cp[1].h.code = EVIL_CODE;\n-\n-\t      /* int_penalty is set by convert_harshness_ansi for cases\n-\t\t where we need to know about any penalties that would\n-\t\t otherwise make a TRIVIAL_CODE pass.  */\n-\t      if (final_cp\n-\t\t  && template_cost == 0\n-\t\t  && cp[0].h.code <= TRIVIAL_CODE\n-\t\t  && cp[0].h.int_penalty == 0)\n-\t\t{\n-\t\t  final_cp[0].h = cp[0].h;\n-\t\t  return function;\n-\t\t}\n \t      cp++;\n \t    }\n \t}"}, {"sha": "638fedfb9c6149bec9696866cc4a008cd199bf57", "filename": "gcc/cp/class.c", "status": "modified", "additions": 61, "deletions": 31, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0a339271ae588299147928769ca073a198d53c7/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0a339271ae588299147928769ca073a198d53c7/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=a0a339271ae588299147928769ca073a198d53c7", "patch": "@@ -1123,6 +1123,24 @@ get_vfield_offset (binfo)\n \t\t     BINFO_OFFSET (binfo));\n }\n \n+/* Get the offset to the start of the original binfo that we derived this\n+   binfo from.  */\n+tree get_derived_offset (binfo)\n+     tree binfo;\n+{\n+  tree offset1 = get_vfield_offset (TYPE_BINFO (BINFO_TYPE (binfo)));\n+  tree offset2;\n+  int i;\n+  while (BINFO_BASETYPES (binfo)\n+\t && (i=CLASSTYPE_VFIELD_PARENT (BINFO_TYPE (binfo))) != -1)\n+    {\n+      tree binfos = BINFO_BASETYPES (binfo);\n+      binfo = TREE_VEC_ELT (binfos, i);\n+    }\n+  offset2 = get_vfield_offset (TYPE_BINFO (BINFO_TYPE (binfo)));\n+  return size_binop (MINUS_EXPR, offset1, offset2);\n+}\n+\n /* If FOR_TYPE needs to reinitialize virtual function table pointers\n    for TYPE's sub-objects, add such reinitializations to BASE_INIT_LIST.\n    Returns BASE_INIT_LIST appropriately modified.  */\n@@ -2171,8 +2189,13 @@ modify_one_vtable (binfo, t, fndecl, pfn)\n \t  /* Find the right offset for the this pointer based on the\n \t     base class we just found.  We have to take into\n \t     consideration the virtual base class pointers that we\n-\t     stick in before the virtual function table pointer.  */\n-\t  base_offset = get_vfield_offset (binfo);\n+\t     stick in before the virtual function table pointer.\n+\n+\t     Also, we want just the delta bewteen the most base class\n+\t     that we derived this vfield from and us.  */\n+\t  base_offset = size_binop (PLUS_EXPR,\n+\t\t\t\t    get_derived_offset (binfo),\n+\t\t\t\t    BINFO_OFFSET (binfo));\n \t  this_offset = size_binop (MINUS_EXPR, offset, base_offset);\n \n \t  /* Make sure we can modify the derived association with immunity.  */\n@@ -2374,8 +2397,8 @@ override_one_vtable (binfo, old, t)\n \t\t  override_one_vtable (binfo, old, t);\n \t\t  return;\n \t\t}\n+\t      TREE_VALUE (virtuals) = TREE_VALUE (old_virtuals);\n \t    }\n-\t  TREE_VALUE (virtuals) = TREE_VALUE (old_virtuals);\n \t}\n       else\n \t{\n@@ -2547,7 +2570,7 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n   int ref_sans_init = 0;\n   int nonprivate_method = 0;\n   tree t_binfo = TYPE_BINFO (t);\n-  tree access_decls = 0;\n+  tree access_decls = NULL_TREE;\n \n   if (TREE_CODE (name) == TYPE_DECL)\n     {\n@@ -2578,7 +2601,7 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n     }\n \n   if (warn_anon && code != UNION_TYPE && ANON_AGGRNAME_P (name))\n-    warning (\"anonymous class type not used to declare any objects\");\n+    pedwarn (\"anonymous class type not used to declare any objects\");\n \n   if (TYPE_SIZE (t))\n     {\n@@ -2599,7 +2622,7 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n   /* If this type was previously laid out as a forward reference,\n      make sure we lay it out again.  */\n \n-  TYPE_SIZE (t) = 0;\n+  TYPE_SIZE (t) = NULL_TREE;\n   CLASSTYPE_GOT_SEMICOLON (t) = 0;\n \n   /* A signature type will contain the fields of the signature table.\n@@ -3025,7 +3048,7 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n \t\t      \n \t\t  if (code == UNION_TYPE)\n \t\t    {\n-\t\t      char * fie = 0;\n+\t\t      char *fie = NULL;\n \t\t      if (TYPE_NEEDS_CONSTRUCTING (type))\n \t\t\tfie = \"constructor\";\n \t\t      else if (TYPE_NEEDS_DESTRUCTOR (type))\n@@ -3252,9 +3275,9 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n \t  if (DECL_NAME (TREE_VEC_ELT (method_vec, i)) == name)\n \t    {\n \t      cp_error (\"cannot adjust access to `%#D' in `%#T'\", fdecl, t);\n-\t      cp_error_at (\"because of local method `%#D' with same name\",\n+\t      cp_error_at (\"  because of local method `%#D' with same name\",\n \t\t\t   TREE_VEC_ELT (method_vec, i));\n-\t      fdecl = 0;\n+\t      fdecl = NULL_TREE;\n \t      break;\n \t    }\n \n@@ -3265,8 +3288,8 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n \t  if (DECL_NAME (tmp) == name)\n \t    {\n \t      cp_error (\"cannot adjust access to `%#D' in `%#T'\", fdecl, t);\n-\t      cp_error_at (\"because of local field `%#D' with same name\", tmp);\n-\t      fdecl = 0;\n+\t      cp_error_at (\"  because of local field `%#D' with same name\", tmp);\n+\t      fdecl = NULL_TREE;\n \t      break;\n \t    }\n \n@@ -3315,7 +3338,7 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n \t}\n       else if (last_x)\n \t{\n-\t  my_friendly_assert (TREE_CHAIN (last_x) == 0, 175);\n+\t  my_friendly_assert (TREE_CHAIN (last_x) == NULL_TREE, 175);\n \t  TREE_CHAIN (last_x) = vfield;\n \t  last_x = vfield;\n \t}\n@@ -3378,7 +3401,7 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n \t   moved into the type of this field, but nothing seems to break\n \t   by doing this.  */\n \n-\tif (DECL_NAME (field) == 0\n+\tif (DECL_NAME (field) == NULL_TREE\n \t    && TREE_CODE (TREE_TYPE (field)) == UNION_TYPE)\n \t  {\n \t    tree uelt = TYPE_FIELDS (TREE_TYPE (field));\n@@ -3405,7 +3428,7 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n       TYPE_ALIGN (pseudo_basetype) = CLASSTYPE_ALIGN (t);\n       DECL_ALIGN (base_layout_decl) = TYPE_ALIGN (pseudo_basetype);\n       /* Don't re-use old size. */\n-      DECL_SIZE (base_layout_decl) = 0;\n+      DECL_SIZE (base_layout_decl) = NULL_TREE;\n     }\n \n   layout_type (t);\n@@ -3432,7 +3455,7 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n \t   moved into the type of this field, but nothing seems to break\n \t   by doing this.  */\n \n-\tif (DECL_NAME (field) == 0\n+\tif (DECL_NAME (field) == NULL_TREE\n \t    && TREE_CODE (TREE_TYPE (field)) == UNION_TYPE)\n \t  {\n \t    tree uelt = TYPE_FIELDS (TREE_TYPE (field));\n@@ -3709,12 +3732,11 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n       while (x)\n \t{\n #if 0 /* What's wrong with using the decl the type already has? */\n-\t  tree tag = build_lang_decl (TYPE_DECL, TREE_PURPOSE (x), TREE_VALUE (x));\n+\t  tree tag = build_decl (TYPE_DECL, TREE_PURPOSE (x), TREE_VALUE (x));\n \t  DECL_CONTEXT (tag) = t;\n #else\n \t  tree tag = TYPE_NAME (TREE_VALUE (x));\n #endif\n-\t  DECL_CLASS_CONTEXT (tag) = t;\n \n #ifdef DWARF_DEBUGGING_INFO\n \t  if (write_symbols == DWARF_DEBUG)\n@@ -3729,7 +3751,7 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n \t  x = TREE_CHAIN (x);\n \t  last_x = chainon (last_x, tag);\n \t}\n-      if (TYPE_FIELDS (t) == 0)\n+      if (TYPE_FIELDS (t) == NULL_TREE)\n \tTYPE_FIELDS (t) = last_x;\n       CLASSTYPE_LOCAL_TYPEDECLS (t) = 1;\n     }\n@@ -4220,7 +4242,9 @@ popclass (modify)\n     {\n       if (CLASSTYPE_VTBL_PTR (current_class_type))\n \t{\n-\t  current_vtable_decl = lookup_name (DECL_NAME (CLASSTYPE_VTBL_PTR (current_class_type)), 0);\n+\t  current_vtable_decl\n+\t    = lookup_name (DECL_NAME (CLASSTYPE_VTBL_PTR (current_class_type)),\n+\t\t\t   0);\n \t  if (current_vtable_decl)\n \t    current_vtable_decl = build_indirect_ref (current_vtable_decl,\n \t\t\t\t\t\t      NULL_PTR);\n@@ -4525,9 +4549,10 @@ instantiate_type (lhstype, rhs, complain)\n \t\t  {\n \t\t    if (complain)\n \t\t      {\n-\t\t\tcp_error (\"cannot resolve overload to target type `%#T';\", lhstype);\n-\t\t\tcp_error_at (\"ambiguity between `%#D'\", save_elem);\n-\t\t\tcp_error_at (\"and `%#D', at least\", elem);\n+\t\t\tcp_error (\"cannot resolve overload to target type `%#T'\",\n+\t\t\t\t  lhstype);\n+\t\t\tcp_error_at (\"  ambiguity between `%#D'\", save_elem);\n+\t\t\tcp_error_at (\"  and `%#D', at least\", elem);\n \t\t      }\n \t\t    return error_mark_node;\n \t\t  }\n@@ -4547,9 +4572,9 @@ instantiate_type (lhstype, rhs, complain)\n \t      }\n \t    if (complain)\n \t      {\n-\t\tcp_error (\"cannot resolve overload to target type `%#T';\",\n+\t\tcp_error (\"cannot resolve overload to target type `%#T'\",\n \t\t\t  lhstype);\n-\t\tcp_error (\"no suitable overload of function `%D' exists\",\n+\t\tcp_error (\"  because no suitable overload of function `%D' exists\",\n \t\t\t  TREE_PURPOSE (rhs));\n \t      }\n \t    return error_mark_node;\n@@ -4631,10 +4656,12 @@ instantiate_type (lhstype, rhs, complain)\n     case PLUS_EXPR:\n     case MINUS_EXPR:\n     case COMPOUND_EXPR:\n-      TREE_OPERAND (rhs, 0) = instantiate_type (lhstype, TREE_OPERAND (rhs, 0), complain);\n+      TREE_OPERAND (rhs, 0)\n+\t= instantiate_type (lhstype, TREE_OPERAND (rhs, 0), complain);\n       if (TREE_OPERAND (rhs, 0) == error_mark_node)\n \treturn error_mark_node;\n-      TREE_OPERAND (rhs, 1) = instantiate_type (lhstype, TREE_OPERAND (rhs, 1), complain);\n+      TREE_OPERAND (rhs, 1)\n+\t= instantiate_type (lhstype, TREE_OPERAND (rhs, 1), complain);\n       if (TREE_OPERAND (rhs, 1) == error_mark_node)\n \treturn error_mark_node;\n \n@@ -4701,18 +4728,21 @@ instantiate_type (lhstype, rhs, complain)\n \t    error (\"not enough type information\");\n \t  return error_mark_node;\n \t}\n-      TREE_OPERAND (rhs, 1) = instantiate_type (lhstype, TREE_OPERAND (rhs, 1), complain);\n+      TREE_OPERAND (rhs, 1)\n+\t= instantiate_type (lhstype, TREE_OPERAND (rhs, 1), complain);\n       if (TREE_OPERAND (rhs, 1) == error_mark_node)\n \treturn error_mark_node;\n-      TREE_OPERAND (rhs, 2) = instantiate_type (lhstype, TREE_OPERAND (rhs, 2), complain);\n+      TREE_OPERAND (rhs, 2)\n+\t= instantiate_type (lhstype, TREE_OPERAND (rhs, 2), complain);\n       if (TREE_OPERAND (rhs, 2) == error_mark_node)\n \treturn error_mark_node;\n \n       TREE_TYPE (rhs) = lhstype;\n       return rhs;\n \n     case MODIFY_EXPR:\n-      TREE_OPERAND (rhs, 1) = instantiate_type (lhstype, TREE_OPERAND (rhs, 1), complain);\n+      TREE_OPERAND (rhs, 1)\n+\t= instantiate_type (lhstype, TREE_OPERAND (rhs, 1), complain);\n       if (TREE_OPERAND (rhs, 1) == error_mark_node)\n \treturn error_mark_node;\n \n@@ -4730,8 +4760,8 @@ instantiate_type (lhstype, rhs, complain)\n \t}\n       TREE_TYPE (rhs) = lhstype;\n       lhstype = TREE_TYPE (lhstype);\n-      TREE_OPERAND (rhs, 0) = instantiate_type (lhstype, TREE_OPERAND (rhs, 0),\n-\t\t\t\t\t\tcomplain);\n+      TREE_OPERAND (rhs, 0)\n+\t= instantiate_type (lhstype, TREE_OPERAND (rhs, 0), complain);\n       if (TREE_OPERAND (rhs, 0) == error_mark_node)\n \treturn error_mark_node;\n "}, {"sha": "7ae511fc4ea7b7bedcb16006df6bb0ede246add3", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 57, "deletions": 13, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0a339271ae588299147928769ca073a198d53c7/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0a339271ae588299147928769ca073a198d53c7/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=a0a339271ae588299147928769ca073a198d53c7", "patch": "@@ -362,6 +362,7 @@ enum languages { lang_c, lang_cplusplus };\n #define UNIQUELY_DERIVED_FROM_P(PARENT, TYPE) (get_base_distance (PARENT, TYPE, 0, (tree *)0) >= 0)\n #define ACCESSIBLY_DERIVED_FROM_P(PARENT, TYPE) (get_base_distance (PARENT, TYPE, -1, (tree *)0) >= 0)\n #define ACCESSIBLY_UNIQUELY_DERIVED_P(PARENT, TYPE) (get_base_distance (PARENT, TYPE, 1, (tree *)0) >= 0)\n+#define DERIVED_FROM_P(PARENT, TYPE) (get_base_distance (PARENT, TYPE, 0, (tree *)0) != -1)\n \f\n enum conversion_type { ptr_conv, constptr_conv, int_conv,\n \t\t       real_conv, last_conversion_type };\n@@ -497,8 +498,11 @@ struct lang_type\n   union tree_node *signature_reference_to;\n };\n \n-/* Indicates whether a template should be (or has been) expanded for this\n-   class definition.  0=do, 1=did, 2=don't, 3=didn't.  */\n+/* Indicates whether or not (and how) a template was expanded for this class.\n+     0=no information yet/non-template class\n+     1=implicit template instantiation\n+     2=explicit template specialization\n+     3=explicit template instantiation  */\n #define CLASSTYPE_USE_TEMPLATE(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.use_template)\n \n /* Fields used for storing information before the class is defined.\n@@ -931,7 +935,9 @@ struct lang_decl_flags\n   unsigned mutable_flag : 1;\n   unsigned is_default_implementation : 1;\n   unsigned saved_inline : 1;\n-  unsigned dummy : 10;\n+  unsigned use_template : 2;\n+\n+  unsigned dummy : 8;\n \n   tree access;\n   tree context;\n@@ -1101,7 +1107,7 @@ struct lang_decl\n \n #if 0\n /* Same, but tells if this field is private in current context.  */\n-#define DECL_PRIVATE(NODE) NOTHING\n+#define DECL_PRIVATE(NODE) (DECL_LANG_FLAG_5 (NODE))\n \n /* Same, but tells if this field is private in current context.  */\n #define DECL_PROTECTED(NODE) (DECL_LANG_FLAG_6 (NODE))\n@@ -1266,11 +1272,39 @@ struct lang_decl\n #define DECL_TEMPLATE_RESULT(NODE)      DECL_RESULT(NODE)\n #define DECL_TEMPLATE_INSTANTIATIONS(NODE) DECL_VINDEX(NODE)\n \n-/* Macros for a DECL or TYPE generated from a template to indicate that it\n-   was explicitly instantiated.  */\n-#define DECL_EXPLICITLY_INSTANTIATED(NODE) (DECL_LANG_FLAG_5 (NODE))\n-#define CLASSTYPE_EXPLICITLY_INSTANTIATED(NODE) \\\n-  (DECL_EXPLICITLY_INSTANTIATED (TYPE_NAME (NODE)))\n+/* Indicates whether or not (and how) a template was expanded for this\n+   FUNCTION_DECL or VAR_DECL.\n+     0=normal declaration, e.g. int min (int, int);\n+     1=implicit template instantiation\n+     2=explicit template specialization, e.g. int min<int> (int, int);\n+     3=explicit template instantiation, e.g. template int min<int> (int, int);\n+ */\n+#define DECL_USE_TEMPLATE(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.use_template)\n+\n+#define DECL_TEMPLATE_INSTANTIATION(NODE) (DECL_USE_TEMPLATE (NODE) & 1)\n+#define CLASSTYPE_TEMPLATE_INSTANTIATION(NODE) \\\n+  (CLASSTYPE_USE_TEMPLATE (NODE) & 1)\n+\n+#define DECL_TEMPLATE_SPECIALIZATION(NODE) (DECL_USE_TEMPLATE (NODE) == 2)\n+#define SET_DECL_TEMPLATE_SPECIALIZATION(NODE) (DECL_USE_TEMPLATE (NODE) = 2)\n+#define CLASSTYPE_TEMPLATE_SPECIALIZATION(NODE) \\\n+  (CLASSTYPE_USE_TEMPLATE (NODE) == 2)\n+#define SET_CLASSTYPE_TEMPLATE_SPECIALIZATION(NODE) \\\n+  (CLASSTYPE_USE_TEMPLATE (NODE) = 2)\n+\n+#define DECL_IMPLICIT_INSTANTIATION(NODE) (DECL_USE_TEMPLATE (NODE) == 1)\n+#define SET_DECL_IMPLICIT_INSTANTIATION(NODE) (DECL_USE_TEMPLATE (NODE) = 1)\n+#define CLASSTYPE_IMPLICIT_INSTANTIATION(NODE) \\\n+  (CLASSTYPE_USE_TEMPLATE(NODE) == 1)\n+#define SET_CLASSTYPE_IMPLICIT_INSTANTIATION(NODE) \\\n+  (CLASSTYPE_USE_TEMPLATE(NODE) = 1)\n+\n+#define DECL_EXPLICIT_INSTANTIATION(NODE) (DECL_USE_TEMPLATE (NODE) == 3)\n+#define SET_DECL_EXPLICIT_INSTANTIATION(NODE) (DECL_USE_TEMPLATE (NODE) = 3)\n+#define CLASSTYPE_EXPLICIT_INSTANTIATION(NODE) \\\n+  (CLASSTYPE_USE_TEMPLATE(NODE) == 3)\n+#define SET_CLASSTYPE_EXPLICIT_INSTANTIATION(NODE) \\\n+  (CLASSTYPE_USE_TEMPLATE(NODE) = 3)\n \n #define THUNK_DELTA(DECL) ((DECL)->decl.frame_size.i)\n \n@@ -1309,6 +1343,7 @@ extern void check_function_format\t\tPROTO((tree, tree, tree));\n /* Print an error message for invalid operands to arith operation CODE.\n    NOP_EXPR is used as a special case (see truthvalue_conversion).  */\n extern void binary_op_error                     PROTO((enum tree_code));\n+extern tree c_build_type_variant                PROTO((tree, int, int));\n extern void c_expand_expr_stmt                  PROTO((tree));\n /* Validate the expression after `case' and apply default promotions.  */\n extern tree check_case_value                    PROTO((tree));\n@@ -1462,7 +1497,7 @@ extern int current_function_parms_stored;\n #define AUTO_TEMP_NAME \"_$tmp_\"\n #define AUTO_TEMP_FORMAT \"_$tmp_%d\"\n #define VTABLE_BASE \"$vb\"\n-#define VTABLE_NAME_FORMAT (flag_vtable_thunks ? \"_VT$%s\" : \"_vt$%s\")\n+#define VTABLE_NAME_FORMAT (flag_vtable_thunks ? \"__vt_%s\" : \"_vt$%s\")\n #define VFIELD_BASE \"$vf\"\n #define VFIELD_NAME \"_vptr$\"\n #define VFIELD_NAME_FORMAT \"_vptr$%s\"\n@@ -1484,7 +1519,7 @@ extern int current_function_parms_stored;\n #define AUTO_TEMP_NAME \"_.tmp_\"\n #define AUTO_TEMP_FORMAT \"_.tmp_%d\"\n #define VTABLE_BASE \".vb\"\n-#define VTABLE_NAME_FORMAT (flag_vtable_thunks ? \"_VT.%s\" : \"_vt.%s\")\n+#define VTABLE_NAME_FORMAT (flag_vtable_thunks ? \"__vt_%s\" : \"_vt.%s\")\n #define VFIELD_BASE \".vf\"\n #define VFIELD_NAME \"_vptr.\"\n #define VFIELD_NAME_FORMAT \"_vptr.%s\"\n@@ -1513,7 +1548,7 @@ extern int current_function_parms_stored;\n #define AUTO_TEMP_FORMAT \"__tmp_%d\"\n #define VTABLE_BASE \"__vtb\"\n #define VTABLE_NAME \"__vt_\"\n-#define VTABLE_NAME_FORMAT (flag_vtable_thunks ? \"_VT_%s\" : \"_vt_%s\")\n+#define VTABLE_NAME_FORMAT (flag_vtable_thunks ? \"__vt_%s\" : \"_vt_%s\")\n #define VTABLE_NAME_P(ID_NODE) \\\n   (!strncmp (IDENTIFIER_POINTER (ID_NODE), VTABLE_NAME, \\\n \t     sizeof (VTABLE_NAME) - 1))\n@@ -1668,6 +1703,11 @@ extern int flag_gc;\n \n extern int flag_dossier;\n \n+/* Nonzero means do emit exported implementations of functions even if\n+   they can be inlined.  */\n+\n+extern int flag_implement_inlines;\n+\n /* Nonzero means templates obey #pragma interface and implementation.  */\n \n extern int flag_external_templates;\n@@ -1676,6 +1716,10 @@ extern int flag_external_templates;\n \n extern int flag_alt_external_templates;\n \n+/* Nonzero means implicit template instantatiations are emitted.  */\n+\n+extern int flag_implicit_templates;\n+\n /* Current end of entries in the gc obstack for stack pointer variables.  */\n \n extern int current_function_obstack_index;\n@@ -1875,7 +1919,7 @@ extern tree lookup_name_current_level\t\tPROTO((tree));\n extern void init_decl_processing\t\tPROTO((void));\n /* skipped define_function */\n extern void shadow_tag\t\t\t\tPROTO((tree));\n-extern void grok_ctor_properties\t\tPROTO((tree, tree));\n+extern int grok_ctor_properties\t\t\tPROTO((tree, tree));\n extern tree groktypename\t\t\tPROTO((tree));\n extern tree start_decl\t\t\t\tPROTO((tree, tree, int, tree));\n extern void finish_decl\t\t\t\tPROTO((tree, tree, tree, int));"}, {"sha": "fc8d261b0efc2e333654412cd7a9ad447093ba2a", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0a339271ae588299147928769ca073a198d53c7/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0a339271ae588299147928769ca073a198d53c7/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=a0a339271ae588299147928769ca073a198d53c7", "patch": "@@ -1226,6 +1226,9 @@ cp_convert (type, expr, convtype, flags)\n   else if (TREE_CODE (TREE_TYPE (e)) == REFERENCE_TYPE)\n     e = convert_from_reference (e);\n \n+  if (TREE_READONLY_DECL_P (e))\n+    e = decl_constant_value (e);\n+\n   if (INTEGRAL_CODE_P (code))\n     {\n       tree intype = TREE_TYPE (expr);\n@@ -1332,8 +1335,12 @@ cp_convert (type, expr, convtype, flags)\n \t{\n \t  tree binfo;\n \n-\t  tree conversion = TYPE_HAS_CONVERSION (dtype)\n-\t    ? build_type_conversion (CONVERT_EXPR, type, e, 1) : NULL_TREE;\n+\t  tree conversion;\n+\n+\t  if (! DERIVED_FROM_P (type, dtype) && TYPE_HAS_CONVERSION (dtype))\n+\t    conversion = build_type_conversion (CONVERT_EXPR, type, e, 1);\n+\t  else\n+\t    conversion = NULL_TREE;\n \n \t  if (TYPE_HAS_CONSTRUCTOR (type))\n \t    {\n@@ -1493,8 +1500,7 @@ build_type_conversion_1 (xtype, basetype, expr, typename, for_sure)\n   else\n     flags = LOOKUP_NORMAL;\n \n-  rval = build_method_call (first_arg, constructor_name_full (typename),\n-\t\t\t    NULL_TREE, NULL_TREE, flags);\n+  rval = build_method_call (first_arg, typename, NULL_TREE, NULL_TREE, flags);\n   if (rval == error_mark_node)\n     {\n       if (for_sure == 0)"}, {"sha": "10e9d0e63f2a889d895f9ceae8c5ae8a361ddb63", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 154, "deletions": 84, "changes": 238, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0a339271ae588299147928769ca073a198d53c7/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0a339271ae588299147928769ca073a198d53c7/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=a0a339271ae588299147928769ca073a198d53c7", "patch": "@@ -410,11 +410,6 @@ extern int flag_short_double;\n \n extern int flag_no_builtin;\n \n-/* Nonzero means do emit exported implementations of functions even if\n-   they can be inlined.  */\n-\n-extern int flag_implement_inlines;\n-\n /* Nonzero means disable GNU extensions.  */\n \n extern int flag_ansi;\n@@ -1791,7 +1786,7 @@ pushtag (name, type, globalize)\n \t    {\n \t      /* Make nested declarations go into class-level scope.  */\n \t      newdecl = 1;\n-\t      d = build_lang_field_decl (TYPE_DECL, name, type);\n+\t      d = build_decl (TYPE_DECL, name, type);\n #ifdef DWARF_DEBUGGING_INFO\n \t      if (write_symbols == DWARF_DEBUG)\n \t\t{\n@@ -1832,14 +1827,13 @@ pushtag (name, type, globalize)\n \t    }\n /*        else if (TYPE_SIZE (current_class_type) == NULL_TREE)\n */\n-\t  else if (context && TREE_CODE (context) == RECORD_TYPE)\n+\t  else if (context && IS_AGGR_TYPE (context))\n \t    {\n \t      /* Class-nested class.  */\n \t      set_nested_typename (d, DECL_NESTED_TYPENAME (c_decl),\n \t\t\t\t   name, type);\n \t      /* This builds the links for classes nested in type scope.  */\n \t      DECL_CONTEXT (d) = context;\n-\t      DECL_CLASS_CONTEXT (d) = context;\n \t    }\n \t  TYPE_CONTEXT (type) = DECL_CONTEXT (d);\n \t  if (newdecl)\n@@ -2021,6 +2015,8 @@ decls_match (newdecl, olddecl)\n \ttypes_match = TREE_TYPE (olddecl) == error_mark_node;\n       else if (TREE_TYPE (olddecl) == NULL_TREE)\n \ttypes_match = TREE_TYPE (newdecl) == NULL_TREE;\n+      else if (TREE_TYPE (newdecl) == NULL_TREE)\n+\ttypes_match = 0;\n       else\n \ttypes_match = comptypes (TREE_TYPE (newdecl), TREE_TYPE (olddecl), 1);\n     }\n@@ -2441,18 +2437,7 @@ duplicate_decls (newdecl, olddecl)\n       TREE_STATIC (newdecl) = TREE_STATIC (olddecl);\n       DECL_EXTERNAL (newdecl) = DECL_EXTERNAL (olddecl);\n \n-      /* For functions, static overrides non-static.  */\n-      if (TREE_CODE (newdecl) == FUNCTION_DECL)\n-\t{\n-\t  TREE_PUBLIC (newdecl) &= TREE_PUBLIC (olddecl);\n-\t  /* This is since we don't automatically\n-\t     copy the attributes of NEWDECL into OLDDECL.  */\n-\t  TREE_PUBLIC (olddecl) = TREE_PUBLIC (newdecl);\n-\t  /* If this clears `static', clear it in the identifier too.  */\n-\t  if (! TREE_PUBLIC (olddecl))\n-\t    TREE_PUBLIC (DECL_ASSEMBLER_NAME (olddecl)) = 0;\n-\t}\n-      else\n+      if (TREE_CODE (newdecl) != FUNCTION_DECL)\n \tTREE_PUBLIC (newdecl) = TREE_PUBLIC (olddecl);\n     }\n   else\n@@ -2464,7 +2449,20 @@ duplicate_decls (newdecl, olddecl)\n \t  && TREE_READONLY (newdecl) && TREE_STATIC (newdecl)\n \t  && ! DECL_THIS_EXTERN (newdecl))\n \tTREE_PUBLIC (newdecl) = 0;\n+      else if (TREE_CODE (newdecl) != FUNCTION_DECL)\n+\tTREE_PUBLIC (olddecl) = TREE_PUBLIC (newdecl);\n+    }\n+\n+  /* For functions, static overrides non-static.  */\n+  if (TREE_CODE (newdecl) == FUNCTION_DECL)\n+    {\n+      TREE_PUBLIC (newdecl) &= TREE_PUBLIC (olddecl);\n+      /* This is since we don't automatically\n+\t copy the attributes of NEWDECL into OLDDECL.  */\n       TREE_PUBLIC (olddecl) = TREE_PUBLIC (newdecl);\n+      /* If this clears `static', clear it in the identifier too.  */\n+      if (! TREE_PUBLIC (olddecl))\n+\tTREE_PUBLIC (DECL_ASSEMBLER_NAME (olddecl)) = 0;\n     }\n \n   /* If either decl says `inline', this fn is inline,\n@@ -2854,7 +2852,8 @@ pushdecl (x)\n \n \t  /* If new decl is `static' and an `extern' was seen previously,\n \t     warn about it.  */\n-\t  warn_extern_redeclared_static (x, t);\n+\t  if (x != NULL_TREE && t != NULL_TREE && decls_match (x, t))\n+\t    warn_extern_redeclared_static (x, t);\n \t}\n       else\n \t{\n@@ -3964,20 +3963,13 @@ lookup_name_real (name, prefer_type, nonclass)\n  done:\n   if (val)\n     {\n-      /* Arbitrate between finding a TYPE_DECL and finding\n-\t other kinds of _DECLs.  */\n-      if (TREE_CODE (val) == TYPE_DECL || prefer_type < 0)\n+      if ((TREE_CODE (val) == TEMPLATE_DECL && looking_for_template)\n+\t  || TREE_CODE (val) == TYPE_DECL || prefer_type <= 0)\n \treturn val;\n \n       if (IDENTIFIER_HAS_TYPE_VALUE (name))\n-\t{\n-\t  register tree val_as_type = TYPE_NAME (IDENTIFIER_TYPE_VALUE (name));\n-\n-\t  if (val == val_as_type || prefer_type > 0)\n-\t    return val_as_type;\n+\treturn TYPE_NAME (IDENTIFIER_TYPE_VALUE (name));\n \n-\t  return val;\n-\t}\n       if (TREE_TYPE (val) == error_mark_node)\n \treturn error_mark_node;\n     }\n@@ -5312,7 +5304,9 @@ start_decl (declarator, declspecs, initialized, raises)\n       default:\n \t/* Don't allow initializations for incomplete types except for\n \t   arrays which might be completed by the initialization.  */\n-\tif (TYPE_SIZE (type) != NULL_TREE)\n+\tif (type == error_mark_node)\n+\t  ;\t\t\t/* Don't complain again.  */\n+\telse if (TYPE_SIZE (type) != NULL_TREE)\n \t  ;                     /* A complete type is ok.  */\n \telse if (TREE_CODE (type) != ARRAY_TYPE)\n \t  {\n@@ -5768,7 +5762,8 @@ finish_decl (decl, init, asmspec_tree, need_pop)\n \t  TREE_TYPE (decl) = type = TREE_TYPE (init);\n \t  DECL_INITIAL (decl) = init = NULL_TREE;\n \t}\n-      if (IS_AGGR_TYPE (type) && DECL_NAME (decl))\n+      if (type != error_mark_node\n+\t  && IS_AGGR_TYPE (type) && DECL_NAME (decl))\n \t{\n \t  if (TREE_TYPE (DECL_NAME (decl)) && TREE_TYPE (decl) != type)\n \t    cp_warning (\"shadowing previous type declaration of `%#D'\", decl);\n@@ -5856,7 +5851,7 @@ finish_decl (decl, init, asmspec_tree, need_pop)\n \n   GNU_xref_decl (current_function_decl, decl);\n \n-  if (TREE_CODE (decl) == FIELD_DECL || DECL_EXTERNAL (decl))\n+  if (TREE_CODE (decl) == FIELD_DECL)\n     ;\n   else if (TREE_CODE (decl) == CONST_DECL)\n     {\n@@ -5960,6 +5955,8 @@ finish_decl (decl, init, asmspec_tree, need_pop)\n \t    DECL_INITIAL (decl) = error_mark_node;\n \t}\n     }\n+  else if (DECL_EXTERNAL (decl))\n+    ;\n   else if (TREE_CODE_CLASS (TREE_CODE (type)) == 't'\n \t   && (IS_AGGR_TYPE (type) || TYPE_NEEDS_CONSTRUCTING (type)))\n     {\n@@ -6185,11 +6182,11 @@ finish_decl (decl, init, asmspec_tree, need_pop)\n \t      store_expr (DECL_INITIAL (decl), DECL_RTL (decl), 0);\n \t      TREE_ASM_WRITTEN (decl) = 1;\n \t    }\n-\t  else if (toplev)\n+\t  else if (toplev && ! TREE_PUBLIC (decl))\n \t    {\n \t      /* If this is a static const, change its apparent linkage\n \t\t if it belongs to a #pragma interface.  */\n-\t      if (TREE_STATIC (decl) && !interface_unknown)\n+\t      if (!interface_unknown)\n \t\t{\n \t\t  TREE_PUBLIC (decl) = 1;\n \t\t  DECL_EXTERNAL (decl) = interface_only;\n@@ -6681,7 +6678,9 @@ grokfndecl (ctype, type, declarator, virtualp, flags, quals,\n       grokclassfn (ctype, declarator, decl, flags, quals);\n       if (check)\n \tcheck_classfn (ctype, declarator, decl);\n-      grok_ctor_properties (ctype, decl);\n+      if (! grok_ctor_properties (ctype, decl))\n+\treturn NULL_TREE;\n+\n       if (check == 0 && ! current_function_decl)\n \t{\n \t  /* FIXME: this should only need to look at\n@@ -7393,18 +7392,15 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t\t{\n \t\t  if (i == (int) RID_LONG && RIDBIT_SETP (i, specbits))\n \t\t    {\n-#if 0\n-\t\t      if (pedantic)\n-\t\t\tpedwarn (\"duplicate `%s'\", IDENTIFIER_POINTER (id));\n-\t\t      else\n-#endif\n-\t\t\tif (longlong)\n-\t\t        error (\"`long long long' is too long for GCC\");\n+\t\t      if (pedantic && flag_ansi)\n+\t\t\tpedwarn (\"duplicate `long'\");\n+\t\t      else if (longlong)\n+\t\t\terror (\"`long long long' is too long for GCC\");\n \t\t      else\n \t\t\tlonglong = 1;\n \t\t    }\n \t\t  else if (RIDBIT_SETP (i, specbits))\n-\t\t    warning (\"duplicate `%s'\", IDENTIFIER_POINTER (id));\n+\t\t    pedwarn (\"duplicate `%s'\", IDENTIFIER_POINTER (id));\n \t\t  RIDBIT_SET (i, specbits);\n \t\t  goto found;\n \t\t}\n@@ -7619,7 +7615,6 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n     warning (\"duplicate `volatile'\");\n   virtualp = RIDBIT_SETP (RID_VIRTUAL, specbits);\n \n-  /* operators new and delete are implicitly static.  */\n   if (RIDBIT_SETP (RID_STATIC, specbits))\n     staticp = 1 + (decl_context == FIELD);\n \n@@ -8049,8 +8044,13 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t\telse\n \t\t  {\n \t\t    if (flag_ansi)\n-\t\t      cp_pedwarn (\"ANSI C++ forbids variable-size array `%D'\",\n-\t\t\t\t  dname);\n+\t\t      {\n+\t\t\tif (dname)\n+\t\t\t  cp_pedwarn (\"ANSI C++ forbids variable-size array `%D'\",\n+\t\t\t\t      dname);\n+\t\t\telse\n+\t\t\t  cp_pedwarn (\"ANSI C++ forbids variable-size array\");\n+\t\t      }\n \t\t  dont_grok_size:\n \t\t    itype =\n \t\t      build_binary_op (MINUS_EXPR, size, integer_one_node, 1);\n@@ -8070,8 +8070,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \n \t    type = build_cplus_array_type (type, itype);\n \t    if (constp || volatilep)\n-\t      /* Should this be c_build_type_variant? -jason */\n-\t      type = build_type_variant (type, constp, volatilep);\n+\t      type = c_build_type_variant (type, constp, volatilep);\n \n \t    ctype = NULL_TREE;\n \t  }\n@@ -8383,9 +8382,18 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t\t    }\n \t\t}\n \t      if (constp > 1)\n-\t\twarning (\"duplicate `const'\");\n+\t\tpedwarn (\"duplicate `const'\");\n \t      if (volatilep > 1)\n-\t\twarning (\"duplicate `volatile'\");\n+\t\tpedwarn (\"duplicate `volatile'\");\n+\t      if (TREE_CODE (declarator) == ADDR_EXPR\n+\t\t  && (constp || volatilep))\n+\t\t{\n+\t\t  if (constp)\n+\t\t    warning (\"discarding `const' applied to a reference\");\n+\t\t  if (volatilep)\n+\t\t    warning (\"discarding `volatile' applied to a reference\");\n+\t\t  constp = volatilep = 0;\n+\t\t}\n \t    }\n \t  declarator = TREE_OPERAND (declarator, 0);\n \t  ctype = NULL_TREE;\n@@ -8841,7 +8849,9 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \n \t    /* Tell grokfndecl if it needs to set TREE_PUBLIC on the node.  */\n \t    publicp = (RIDBIT_SETP (RID_EXTERN, specbits)\n-\t\t       || (ctype != NULL_TREE && funcdef_flag >= 0)\n+\t\t       || (ctype != NULL_TREE\n+\t\t\t   && funcdef_flag >= 0\n+\t\t\t   && RIDBIT_NOTSETP (RID_INLINE, specbits))\n \t\t       || (friendp\n \t\t\t   && ! funcdef_flag\n \t\t\t   && RIDBIT_NOTSETP (RID_STATIC, specbits)\n@@ -8921,24 +8931,37 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \n \tif (decl == NULL_TREE)\n \t  {\n-\t    /* ANSI C++ June 5 1992 WP 9.2.2 and 9.4.2.  A member-declarator\n-\t       cannot have an initializer, and a static member declaration must\n-\t       be defined elsewhere.  */\n \t    if (initialized)\n \t      {\n+\t\t/* Motion 10 at San Diego: If a static const integral data\n+\t\t   member is initialized with an integral constant\n+\t\t   expression, the initializer may appear either in the\n+\t\t   declaration (within the class), or in the definition,\n+\t\t   but not both.  If it appears in the class, the member is\n+\t\t   a member constant.  The file-scope definition is always\n+\t\t   required.  */\n \t\tif (staticp)\n-\t\t  error (\"static member `%s' must be defined separately from its declaration\",\n-\t\t\t  IDENTIFIER_POINTER (declarator));\n+\t\t  {\n+\t\t    if (pedantic)\n+\t\t      {\n+\t\t\tif (! constp)\n+\t\t\t  cp_pedwarn (\"ANSI C++ forbids in-class initialization of non-const static member `%D'\",\n+\t\t\t\t      declarator);\n+\n+\t\t\telse if (! INTEGRAL_TYPE_P (type))\n+\t\t\t  cp_pedwarn (\"ANSI C++ forbids member constant `%D' of non-integral type `%T'\", declarator, type);\n+\t\t      }\n+\t\t  }\n+\n \t\t/* Note that initialization of const members is prohibited\n \t\t   by the draft ANSI standard, though it appears to be in\n \t\t   common practice.  12.6.2: The argument list is used to\n \t\t   initialize the named nonstatic member....  This (or an\n \t\t   initializer list) is the only way to initialize\n \t\t   nonstatic const and reference members.  */\n \t\telse if (flag_ansi || ! constp)\n-\t\t  pedwarn (\"ANSI C++ forbids initialization of %s `%s'\",\n-\t\t\t   constp ? \"const member\" : \"member\",\n-\t\t\t   IDENTIFIER_POINTER (declarator));\n+\t\t  cp_pedwarn (\"ANSI C++ forbids initialization of %s `%D'\",\n+\t\t\t      constp ? \"const member\" : \"member\", declarator);\n \t      }\n \n \t    if (staticp || (constp && initialized))\n@@ -8952,7 +8975,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t\t  TREE_STATIC (decl) = 1;\n \t\t/* In class context, static means public access.  */\n \t\tTREE_PUBLIC (decl) = 1;\n-\t\tDECL_EXTERNAL (decl) = !initialized;\n+\t\tDECL_EXTERNAL (decl) = !!staticp;\n \t      }\n \t    else\n \t      {\n@@ -9472,7 +9495,7 @@ grokparms (first_parm, funcdef_flag)\n    `grok_op_properties' takes notice of the various forms of\n    operator= which are defined, as well as what sorts of type conversion\n    may apply.  Both functions take a FUNCTION_DECL as an argument.  */\n-void\n+int\n grok_ctor_properties (ctype, decl)\n      tree ctype, decl;\n {\n@@ -9509,14 +9532,21 @@ grok_ctor_properties (ctype, decl)\n     {\n       if (TREE_CHAIN (parmtypes) != NULL_TREE\n \t  && TREE_CHAIN (parmtypes) == void_list_node)\n-\tcp_error (\"invalid constructor; you probably meant `%T (%T&)'\",\n-\t\t  ctype, ctype);\n-      SET_IDENTIFIER_ERROR_LOCUS (DECL_NAME (decl), ctype);\n-      TYPE_GETS_INIT_AGGR (ctype) = 1;\n+\t{\n+\t  cp_error (\"invalid constructor; you probably meant `%T (%T&)'\",\n+\t\t    ctype, ctype);\n+\t  SET_IDENTIFIER_ERROR_LOCUS (DECL_NAME (decl), ctype);\n+\n+\t  return 0;\n+\t}\n+      else\n+\tTYPE_GETS_INIT_AGGR (ctype) = 1;\n     }\n   else if (TREE_CODE (parmtype) == VOID_TYPE\n \t   || TREE_PURPOSE (parmtypes) != NULL_TREE)\n     TYPE_HAS_DEFAULT_CONSTRUCTOR (ctype) = 1;\n+\n+  return 1;\n }\n \n /* An operator with this name can be either unary or binary.  */\n@@ -9660,10 +9690,30 @@ grok_op_properties (decl, virtualp, friendp)\n \t  || name == ansi_opname[(int) METHOD_CALL_EXPR])\n \treturn;\t\t\t/* no restrictions on args */\n \n-      if (IDENTIFIER_TYPENAME_P (name)\n-\t  && TREE_CODE (TREE_TYPE (name)) == VOID_TYPE)\n-\terror (\"void is not a valid type conversion operator\");\n-      \n+      if (IDENTIFIER_TYPENAME_P (name))\n+\t{\n+\t  tree t = TREE_TYPE (name);\n+\t  if (TREE_CODE (t) == VOID_TYPE)\n+\t    pedwarn (\"void is not a valid type conversion operator\");\n+\t  else if (! friendp)\n+\t    {\n+\t      int ref = (TREE_CODE (t) == REFERENCE_TYPE);\n+\t      char *what = 0;\n+\t      if (ref)\n+\t\tt = TYPE_MAIN_VARIANT (TREE_TYPE (t));\n+\n+\t      if (t == current_class_type)\n+\t\twhat = \"the same type\";\n+\t      else if (IS_AGGR_TYPE (t)\n+\t\t       && DERIVED_FROM_P (t, current_class_type))\n+\t\twhat = \"a base class\";\n+\n+\t      if (what)\n+\t\twarning (\"conversion to %s%s will never use a type conversion operator\",\n+\t\t\t ref ? \"a reference to \" : \"\", what);\n+\t    }\n+\t}\n+\n       if (name == ansi_opname[(int) MODIFY_EXPR])\n \t{\n \t  tree parmtype;\n@@ -9810,12 +9860,12 @@ xref_defn_tag (code_type_node, name, binfo)\n #endif\n #if 0\n       IDENTIFIER_LOCAL_VALUE (name) =\n-\tbuild_lang_decl (TYPE_DECL, ncp, NULL_TREE);\n+\tbuild_decl (TYPE_DECL, ncp, NULL_TREE);\n #endif\n       rv = xref_tag (code_type_node, name, binfo, 0);\n       if (! ANON_AGGRNAME_P (name))\n       {\n-\tregister tree type_decl = build_lang_decl (TYPE_DECL, ncp, rv);\n+\tregister tree type_decl = build_decl (TYPE_DECL, ncp, rv);\n #ifdef DWARF_DEBUGGING_INFO\n \t/* Mark the TYPE_DECL node created just above as a gratuitous one\n \t   so that dwarfout.c will know not to generate a TAG_typedef DIE\n@@ -9875,10 +9925,10 @@ xref_tag (code_type_node, name, binfo, globalize)\n \n   /* If a cross reference is requested, look up the type\n      already defined for this tag and return it.  */\n-  if ((t = IDENTIFIER_TYPE_VALUE(name)))\n-    {\n-       if (TREE_CODE(t) != code) t = NULL_TREE;\n-    }\n+  t = IDENTIFIER_TYPE_VALUE (name);\n+  if (t && TREE_CODE (t) != code)\n+    t = NULL_TREE;\n+\n   if (xref_next_defn)\n     {\n       /* If we know we are defining this tag, only look it up in this scope\n@@ -10694,15 +10744,29 @@ start_function (declspecs, declarator, raises, pre_parsed_p)\n     {\n       TREE_PUBLIC (decl1) = 1;\n       DECL_EXTERNAL (decl1)\n-\t= ((interface_only && !DECL_EXPLICITLY_INSTANTIATED (decl1))\n+\t= (interface_only\n \t   || (DECL_INLINE (decl1) && ! flag_implement_inlines));\n     }\n+  else if (DECL_EXPLICIT_INSTANTIATION (decl1))\n+    {\n+      TREE_PUBLIC (decl1) = 1;\n+      DECL_EXTERNAL (decl1) = (DECL_INLINE (decl1)\n+\t\t\t       && ! flag_implement_inlines);\n+    }\n   else\n-    /* This is a definition, not a reference.\n-       So normally clear DECL_EXTERNAL.\n-       However, `extern inline' acts like a declaration except for\n-       defining how to inline.  So set DECL_EXTERNAL in that case.  */\n-    DECL_EXTERNAL (decl1) = current_extern_inline;\n+    {\n+      /* This is a definition, not a reference.\n+\t So normally clear DECL_EXTERNAL.\n+\t However, `extern inline' acts like a declaration except for\n+\t defining how to inline.  So set DECL_EXTERNAL in that case.  */\n+      DECL_EXTERNAL (decl1) = current_extern_inline;\n+\n+#if 0\n+      DECL_DEFER_OUTPUT (decl1)\n+\t= (DECL_INLINE (decl1) && (DECL_IMPLICIT_INSTANTIATION (decl1)\n+\t\t\t\t   || DECL_FUNCTION_MEMBER_P (decl1)));\n+#endif\n+    }\n \n   /* Record the decl so that the function name is defined.\n      If we already have a decl for this name, and it is a FUNCTION_DECL,\n@@ -11703,6 +11767,9 @@ start_method (declspecs, declarator, raises)\n   if (flag_default_inline)\n     DECL_INLINE (fndecl) = 1;\n \n+  if (processing_template_defn)\n+    SET_DECL_IMPLICIT_INSTANTIATION (fndecl);\n+\n   /* We read in the parameters on the maybepermanent_obstack,\n      but we won't be getting back to them until after we\n      may have clobbered them.  So the call to preserve_data\n@@ -11726,7 +11793,10 @@ start_method (declspecs, declarator, raises)\n \t}\n \n       if (DECL_CONSTRUCTOR_P (fndecl))\n-\tgrok_ctor_properties (current_class_type, fndecl);\n+\t{\n+\t  if (! grok_ctor_properties (current_class_type, fndecl))\n+\t    return void_type_node;\n+\t}\n       else if (IDENTIFIER_OPNAME_P (DECL_NAME (fndecl)))\n \tgrok_op_properties (fndecl, DECL_VIRTUAL_P (fndecl), 0);\n     }"}, {"sha": "fa05063fcabbe9a6167f2bbda556c608e184385b", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 26, "deletions": 34, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0a339271ae588299147928769ca073a198d53c7/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0a339271ae588299147928769ca073a198d53c7/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=a0a339271ae588299147928769ca073a198d53c7", "patch": "@@ -116,6 +116,10 @@ int flag_external_templates = 0;\n \n int flag_alt_external_templates = 0;\n \n+/* Nonzero means that implicit instantiations will be emitted if needed.  */\n+\n+int flag_implicit_templates = 1;\n+\n /* Nonzero means warn about implicit declarations.  */\n \n int warn_implicit = 1;\n@@ -352,6 +356,7 @@ static struct { char *string; int *variable; int on_value;} lang_f_options[] =\n   {\"nonnull-objects\", &flag_assume_nonnull_objects, 1},\n   {\"implement-inlines\", &flag_implement_inlines, 1},\n   {\"external-templates\", &flag_external_templates, 1},\n+  {\"implicit-templates\", &flag_implicit_templates, 1},\n   {\"huge-objects\", &flag_huge_objects, 1},\n   {\"conserve-space\", &flag_conserve_space, 1},\n   {\"vtable-thunks\", &flag_vtable_thunks, 1},\n@@ -1181,7 +1186,7 @@ grokfield (declarator, declspecs, raises, init, asmspec_tree)\n \n   value = grokdeclarator (declarator, declspecs, FIELD, init != 0, raises);\n   if (! value)\n-    return NULL_TREE; /* friends went bad.  */\n+    return value; /* friend or constructor went bad.  */\n \n   /* Pass friendly classes back.  */\n   if (TREE_CODE (value) == VOID_TYPE)\n@@ -1236,21 +1241,13 @@ grokfield (declarator, declspecs, raises, init, asmspec_tree)\n \t  grok_function_init (value, init);\n \t  init = NULL_TREE;\n \t}\n-      else if (pedantic)\n-\t{\n-#if 0\n-\t  /* Already warned in grokdeclarator.  */\n-\t  if (DECL_NAME (value))\n-\t    pedwarn (\"ANSI C++ forbids initialization of member `%s'\",\n-\t\t     IDENTIFIER_POINTER (DECL_NAME (value)));\n-\t  else\n-\t    pedwarn (\"ANSI C++ forbids initialization of fields\");\n-#endif\n-\t  init = NULL_TREE;\n-\t}\n+      else if (pedantic && ! TREE_STATIC (value))\n+\t/* Already complained in grokdeclarator.  */\n+\tinit = NULL_TREE;\n       else\n \t{\n-\t  /* We allow initializers to become parameters to base initializers.  */\n+\t  /* We allow initializers to become parameters to base\n+             initializers.  */\n \t  if (TREE_CODE (init) == TREE_LIST)\n \t    {\n \t      if (TREE_CHAIN (init) == NULL_TREE)\n@@ -1352,8 +1349,6 @@ grokfield (declarator, declspecs, raises, init, asmspec_tree)\n     }\n   if (TREE_CODE (value) == FUNCTION_DECL)\n     {\n-      /* grokdeclarator defers setting this.  */\n-      TREE_PUBLIC (value) = 1;\n       if (DECL_CHAIN (value) != NULL_TREE)\n \t{\n \t  /* Need a fresh node here so that we don't get circularity\n@@ -1368,7 +1363,7 @@ grokfield (declarator, declspecs, raises, init, asmspec_tree)\n       if (DECL_FRIEND_P (value))\n \treturn void_type_node;\n \n-      if (current_function_decl)\n+      if (current_function_decl && ! IS_SIGNATURE (current_class_type))\n \tcp_error (\"method `%#D' of local class must be defined in class body\",\n \t\t  value);\n \n@@ -2345,7 +2340,8 @@ finish_vtable_vardecl (prev, vars)\n       for (method = CLASSTYPE_METHODS (ctype); method != NULL_TREE;\n \t   method = DECL_NEXT_METHOD (method))\n \t{\n-\t  if (DECL_VINDEX (method) != NULL_TREE && !DECL_SAVED_INSNS (method))\n+\t  if (DECL_VINDEX (method) != NULL_TREE && !DECL_SAVED_INSNS (method)\n+\t      && !DECL_ABSTRACT_VIRTUAL_P (method))\n \t    {\n \t      SET_CLASSTYPE_INTERFACE_KNOWN (ctype);\n \t      CLASSTYPE_INTERFACE_ONLY (ctype) = DECL_EXTERNAL (method);\n@@ -2376,20 +2372,6 @@ finish_vtable_vardecl (prev, vars)\n       mark_vtable_entries (vars);\n       if (TREE_TYPE (DECL_INITIAL (vars)) == 0)\n \t  store_init_value (vars, DECL_INITIAL (vars));\n-      if (flag_vtable_thunks)\n-\t{\n-\t  tree list = CONSTRUCTOR_ELTS (DECL_INITIAL (vars));\n-\t  for (; list; list = TREE_CHAIN (list))\n-\t    {\n-\t      tree vfunc = TREE_VALUE (list);\n-\t      if (TREE_CODE (vfunc) == ADDR_EXPR)\n-\t\t{\n-\t\t  vfunc = TREE_OPERAND (vfunc, 0);\n-\t\t  if (TREE_CODE (vfunc) == THUNK_DECL)\n-\t\t    emit_thunk (vfunc);\n-\t\t}\n-\t    }\n-\t}\n \n #ifdef DWARF_DEBUGGING_INFO\n       if (write_symbols == DWARF_DEBUG)\n@@ -2737,6 +2719,12 @@ finish_file ()\n \n   walk_vtables ((void (*)())0, finish_vtable_vardecl);\n \n+  for (vars = getdecls (); vars; vars = TREE_CHAIN (vars))\n+    {\n+      if (TREE_CODE (vars) == THUNK_DECL)\n+\temit_thunk (vars);\n+    }\n+\n   /* Now write out inline functions which had their addresses taken\n      and which were not declared virtual and which were not declared\n      `extern inline'.  */\n@@ -2752,12 +2740,16 @@ finish_file ()\n \t  if (CLASSTYPE_INTERFACE_KNOWN (ctype))\n \t    {\n \t      TREE_PUBLIC (decl) = 1;\n-\t      DECL_EXTERNAL (decl) = CLASSTYPE_INTERFACE_ONLY (ctype);\n+\t      DECL_EXTERNAL (decl)\n+\t\t= (CLASSTYPE_INTERFACE_ONLY (ctype)\n+\t\t   || (DECL_INLINE (decl) && ! flag_implement_inlines));\n \t    }\n \t}\n       if (TREE_PUBLIC (decl) || TREE_ADDRESSABLE (decl))\n \t{\n-\t  if (DECL_EXTERNAL (decl))\n+\t  if (DECL_EXTERNAL (decl)\n+\t      || (DECL_IMPLICIT_INSTANTIATION (decl)\n+\t\t  && ! flag_implicit_templates))\n \t    assemble_external (decl);\n \t  else\n \t    {\t"}, {"sha": "f431f6a3a11b40c63a4e95203b99f66c89a2feff", "filename": "gcc/cp/error.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0a339271ae588299147928769ca073a198d53c7/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0a339271ae588299147928769ca073a198d53c7/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=a0a339271ae588299147928769ca073a198d53c7", "patch": "@@ -837,25 +837,25 @@ dump_char (c)\n {\n   switch (c)\n     {\n-    case '\\n':\n+    case TARGET_NEWLINE:\n       OB_PUTS (\"\\\\n\");\n       break;\n-    case '\\t':\n+    case TARGET_TAB:\n       OB_PUTS (\"\\\\t\");\n       break;\n-    case '\\v':\n+    case TARGET_VT:\n       OB_PUTS (\"\\\\v\");\n       break;\n-    case '\\b':\n+    case TARGET_BS:\n       OB_PUTS (\"\\\\b\");\n       break;\n-    case '\\r':\n+    case TARGET_CR:\n       OB_PUTS (\"\\\\r\");\n       break;\n-    case '\\f':\n+    case TARGET_FF:\n       OB_PUTS (\"\\\\f\");\n       break;\n-    case '\\a':\n+    case TARGET_BELL:\n       OB_PUTS (\"\\\\a\");\n       break;\n     case '\\\\':"}, {"sha": "084eebd0386f33d62be2e185bb21d307e941b5e7", "filename": "gcc/cp/init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0a339271ae588299147928769ca073a198d53c7/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0a339271ae588299147928769ca073a198d53c7/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=a0a339271ae588299147928769ca073a198d53c7", "patch": "@@ -1866,7 +1866,7 @@ build_member_call (cname, name, parmlist)\n \t{\n \t  tree newtype = build_type_variant (type, TYPE_READONLY (oldtype),\n \t\t\t\t\t     TYPE_VOLATILE (oldtype));\n-\t  decl = convert_force (TYPE_POINTER_TO (newtype), olddecl);\n+\t  decl = convert_force (build_pointer_type (newtype), olddecl);\n \t}\n       else\n \tdecl = olddecl;"}, {"sha": "68f801e1f9858f9f02cae3bb4c966fb46815e06a", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0a339271ae588299147928769ca073a198d53c7/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0a339271ae588299147928769ca073a198d53c7/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=a0a339271ae588299147928769ca073a198d53c7", "patch": "@@ -1936,15 +1936,17 @@ default_assign_ref_body (bufp, lenp, type, fields)\n \t  name = TYPE_NESTED_NAME (btype);\n \t  s = IDENTIFIER_POINTER (name);\n \n-\t  tneed = (2 * strlen (s)) + 33;\n+\t  tneed = (2 * strlen (s)) + 42;\n \t  if (tgot < tneed)\n \t    {\n \t      tgot = tneed;\n \t      tbuf = (char *) alloca (tgot);\n \t    }\n \n-\t  sprintf (tbuf, \"%s::operator=((%s%s&)_ctor_arg);\", s,\n-\t\t   TYPE_READONLY (type) ? \"const \" : \"\", s);\n+\t  sprintf (tbuf, \"%s::operator=((%s%s ::%s&)_ctor_arg);\", s,\n+\t\t   TYPE_READONLY (type) ? \"const \" : \"\",\n+\t\t   CLASSTYPE_DECLARED_CLASS (btype) ? \"class\" : \"struct\",\n+\t\t   s);\n \t  obstack_grow (&body, tbuf, strlen (tbuf));\n \t}\n     }\n@@ -2101,15 +2103,17 @@ default_copy_constructor_body (bufp, lenp, type, fields)\n \t  name = TYPE_NESTED_NAME (btype);\n \t  s = IDENTIFIER_POINTER (name);\n \n-\t  tneed = (2 * strlen (s)) + 30;\n+\t  tneed = (2 * strlen (s)) + 39;\n \t  if (tgot < tneed)\n \t    {\n \t      tgot = tneed;\n \t      tbuf = (char *) alloca (tgot);\n \t    }\n \n-\t  sprintf (tbuf, \"%c%s((%s%s&)_ctor_arg)\", sep, s,\n-\t\t   TYPE_READONLY (type) ? \"const \" : \"\", s);\n+\t  sprintf (tbuf, \"%c%s((%s%s ::%s&)_ctor_arg)\", sep, s,\n+\t\t   TYPE_READONLY (type) ? \"const \" : \"\",\n+\t\t   CLASSTYPE_DECLARED_CLASS (btype) ? \"class\" : \"struct\",\n+\t\t   s);\n \t  sep = ',';\n \t  obstack_grow (&prologue, tbuf, strlen (tbuf));\n \t}"}, {"sha": "3da46356afcc84e24ee47f6d74330b416e452350", "filename": "gcc/cp/lex.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0a339271ae588299147928769ca073a198d53c7/gcc%2Fcp%2Flex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0a339271ae588299147928769ca073a198d53c7/gcc%2Fcp%2Flex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.h?ref=a0a339271ae588299147928769ca073a198d53c7", "patch": "@@ -115,6 +115,7 @@ extern char *token_buffer;\t/* Pointer to token buffer.  */\n \n /* Back-door communication channel to the lexer.  */\n extern int looking_for_typename;\n+extern int looking_for_template;\n \n /* Tell the lexer where to look for names.  */\n extern tree got_scope;"}, {"sha": "bdc040c8095d25eb76fc0a28f06035b9466d500a", "filename": "gcc/cp/method.c", "status": "modified", "additions": 37, "deletions": 15, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0a339271ae588299147928769ca073a198d53c7/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0a339271ae588299147928769ca073a198d53c7/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=a0a339271ae588299147928769ca073a198d53c7", "patch": "@@ -938,7 +938,9 @@ build_typename_overload (type)\n   build_overload_name (type, 0, 1);\n   id = get_identifier (obstack_base (&scratch_obstack));\n   IDENTIFIER_OPNAME_P (id) = 1;\n+#if 0\n   IDENTIFIER_GLOBAL_VALUE (id) = TYPE_NAME (type);\n+#endif\n   TREE_TYPE (id) = type;\n   return id;\n }\n@@ -1676,23 +1678,36 @@ make_thunk (function, delta)\n      int delta;\n {\n   char buffer[250];\n-  tree thunk_fndecl;\n+  tree thunk_fndecl, thunk_id;\n   tree thunk;\n+  char *func_name;\n   static int thunk_number = 0;\n   tree func_decl;\n   if (TREE_CODE (function) != ADDR_EXPR)\n     abort ();\n   func_decl = TREE_OPERAND (function, 0);\n   if (TREE_CODE (func_decl) != FUNCTION_DECL)\n     abort ();\n-  sprintf (buffer, \"__thunk_%d_%d\", -delta, thunk_number++);\n-  thunk = build_decl (THUNK_DECL, get_identifier (buffer),\n-\t\t      TREE_TYPE (func_decl));\n-  DECL_RESULT (thunk)\n-    = build_decl (RESULT_DECL, NULL_TREE, TREE_TYPE (vtable_entry_type));\n-  make_function_rtl (thunk);\n-  DECL_INITIAL (thunk) = function;\n-  THUNK_DELTA (thunk) = delta;\n+  func_name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (func_decl));\n+  sprintf (buffer, \"__thunk_%d_%s\", -delta, func_name);\n+  thunk_id = get_identifier (buffer);\n+  thunk = IDENTIFIER_GLOBAL_VALUE (thunk_id);\n+  if (thunk && TREE_CODE (thunk) != THUNK_DECL)\n+    {\n+      error_with_decl (\"implementation-reserved name `%s' used\");\n+      IDENTIFIER_GLOBAL_VALUE (thunk_id) = thunk = NULL_TREE;\n+    }\n+  if (thunk == NULL_TREE)\n+    {\n+      thunk = build_decl (THUNK_DECL, thunk_id, TREE_TYPE (func_decl));\n+      DECL_RESULT (thunk)\n+\t= build_decl (RESULT_DECL, NULL_TREE, TREE_TYPE (vtable_entry_type));\n+      make_function_rtl (thunk);\n+      DECL_INITIAL (thunk) = function;\n+      THUNK_DELTA (thunk) = delta;\n+      /* So that finish_file can write out any thunks that need to be: */\n+      pushdecl_top_level (thunk);\n+    }\n   return thunk;\n }\n \n@@ -1725,6 +1740,19 @@ emit_thunk (thunk_fndecl)\n   if (TREE_ASM_WRITTEN (thunk_fndecl))\n     return;\n \n+  TREE_ASM_WRITTEN (thunk_fndecl) = 1;\n+\n+  if (TREE_PUBLIC (function))\n+    {\n+      TREE_PUBLIC (thunk_fndecl) = 1;\n+      if (DECL_EXTERNAL (function))\n+\t{\n+\t  DECL_EXTERNAL (thunk_fndecl) = 1;\n+\t  assemble_external (thunk_fndecl);\n+\t  return;\n+\t}\n+    }\n+\n   decl_printable_name = thunk_printable_name;\n   if (current_function_decl)\n     abort ();\n@@ -1833,8 +1861,6 @@ emit_thunk (thunk_fndecl)\n   expand_end_bindings (NULL, 1, 0);\n   poplevel (0, 0, 0);\n \n-  TREE_ASM_WRITTEN (thunk_fndecl) = 1;\n-\n   /* From now on, allocate rtl in current_obstack, not in saveable_obstack.\n      Note that that may have been done above, in save_for_inline_copying.\n      The call to resume_temporary_allocation near the end of this function\n@@ -1848,10 +1874,6 @@ emit_thunk (thunk_fndecl)\n \n   unshare_all_rtl (insns);\n \n-  /* Instantiate all virtual registers.  */\n-\n-  instantiate_virtual_regs (current_function_decl, get_insns ());\n-\n   /* We are no longer anticipating cse in this function, at least.  */\n \n   cse_not_expected = 1;"}, {"sha": "cb2046d21001cc2254954bfc5b244eb87dc19d84", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0a339271ae588299147928769ca073a198d53c7/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0a339271ae588299147928769ca073a198d53c7/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=a0a339271ae588299147928769ca073a198d53c7", "patch": "@@ -543,11 +543,12 @@ datadef:\n \t\t&& TREE_PURPOSE (t) == NULL_TREE)\n \t      {\n \t\tt = TREE_VALUE (t);\n-\t\tif (TREE_CODE (t) == RECORD_TYPE)\n+\t\tif (IS_AGGR_TYPE (t)\n+\t\t    && IDENTIFIER_TEMPLATE (TYPE_IDENTIFIER (t)))\n \t\t  {\n \t\t    if (CLASSTYPE_USE_TEMPLATE (t) == 0)\n-\t\t      CLASSTYPE_USE_TEMPLATE (t) = 2;\n-\t\t    else if (CLASSTYPE_USE_TEMPLATE (t) == 1)\n+\t\t      SET_CLASSTYPE_TEMPLATE_SPECIALIZATION (t);\n+\t\t    else if (CLASSTYPE_TEMPLATE_INSTANTIATION (t))\n \t\t      error (\"override declaration for already-expanded template\");\n \t\t  }\n \t      }\n@@ -2914,14 +2915,18 @@ absdcl:\n \t\t{ $$ = make_pointer_declarator ($2, $3); }\n \t| '*' absdcl\n \t\t{ $$ = make_pointer_declarator (NULL_TREE, $2); }\n-\t| '*' type_quals  %prec EMPTY\n+\t| '*' nonempty_type_quals  %prec EMPTY\n \t\t{ $$ = make_pointer_declarator ($2, NULL_TREE); }\n+\t| '*' %prec EMPTY\n+\t\t{ $$ = make_pointer_declarator (NULL_TREE, NULL_TREE); }\n \t| '&' nonempty_type_quals absdcl\n \t\t{ $$ = make_reference_declarator ($2, $3); }\n \t| '&' absdcl\n \t\t{ $$ = make_reference_declarator (NULL_TREE, $2); }\n-\t| '&' type_quals %prec EMPTY\n+\t| '&' nonempty_type_quals %prec EMPTY\n \t\t{ $$ = make_reference_declarator ($2, NULL_TREE); }\n+\t| '&' %prec EMPTY\n+\t\t{ $$ = make_reference_declarator (NULL_TREE, NULL_TREE); }\n \t| ptr_to_mem type_quals %prec EMPTY\n \t\t{ tree arg = make_pointer_declarator ($2, NULL_TREE);\n \t\t  $$ = build_parse_node (SCOPE_REF, $1, arg);"}, {"sha": "36248be80edaea1904fa36f1797ebf85ef9a6b59", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 37, "deletions": 13, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0a339271ae588299147928769ca073a198d53c7/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0a339271ae588299147928769ca073a198d53c7/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=a0a339271ae588299147928769ca073a198d53c7", "patch": "@@ -116,7 +116,7 @@ process_template_parm (list, next)\n   else\n     {\n       tree t = make_node (TEMPLATE_TYPE_PARM);\n-      decl = build_lang_decl (TYPE_DECL, TREE_PURPOSE (parm), t);\n+      decl = build_decl (TYPE_DECL, TREE_PURPOSE (parm), t);\n       TYPE_NAME (t) = decl;\n       TREE_VALUE (parm) = t;\n     }\n@@ -581,7 +581,7 @@ lookup_template_class (d1, arglist, in_decl)\n       tree t = make_lang_type (UNINSTANTIATED_P_TYPE);\n       tree d;\n       id = make_anon_name ();\n-      d = build_lang_decl (TYPE_DECL, id, t);\n+      d = build_decl (TYPE_DECL, id, t);\n       TYPE_NAME (t) = d;\n       TYPE_VALUES (t) = build_tree_list (template, arglist);\n       pushdecl_top_level (d);\n@@ -635,7 +635,7 @@ push_template_decls (parmlist, arglist, class_level)\n \t    }\n \t  decl = arg;\n \t  my_friendly_assert (TREE_CODE_CLASS (TREE_CODE (decl)) == 't', 273);\n-\t  decl = build_lang_decl (TYPE_DECL, parm, decl);\n+\t  decl = build_decl (TYPE_DECL, parm, decl);\n \t}\n       else\n \t{\n@@ -987,7 +987,7 @@ instantiate_class_template (classname, setup_parse)\n       if (!TREE_TYPE (classname))\n \t{\n \t  tree t = make_lang_type (RECORD_TYPE);\n-\t  tree d = build_lang_decl (TYPE_DECL, classname, t);\n+\t  tree d = build_decl (TYPE_DECL, classname, t);\n \t  DECL_NAME (d) = classname;\n \t  TYPE_NAME (t) = d;\n \t  pushdecl (d);\n@@ -1320,7 +1320,7 @@ tsubst (t, args, nargs, in_decl)\n \t      tree decls;\n \t      int got_it = 0;\n \n-\t      decls = lookup_name (r, 0);\n+\t      decls = lookup_name_nonclass (r);\n \t      if (decls == NULL_TREE)\n \t\t/* no match */;\n \t      else if (TREE_CODE (decls) == TREE_LIST)\n@@ -1645,11 +1645,18 @@ instantiate_template (tmpl, targ_ptr)\n       DECL_ARGUMENTS (fndecl) = TREE_CHAIN (DECL_ARGUMENTS (fndecl));\n     }\n      \n+  t = DECL_TEMPLATE_INFO (tmpl);\n+\n   /* If we have a preexisting version of this function, don't expand\n      the template version, use the other instead.  */\n-  t = DECL_TEMPLATE_INFO (tmpl);\n-  if (t->text && !(DECL_INLINE (fndecl) && DECL_SAVED_INSNS (fndecl)))\n+  if (DECL_INLINE (fndecl) && DECL_SAVED_INSNS (fndecl))\n     {\n+      SET_DECL_TEMPLATE_SPECIALIZATION (fndecl);\n+      p = (struct pending_inline *)0;\n+    }\n+  else if (t->text)\n+    {\n+      SET_DECL_IMPLICIT_INSTANTIATION (fndecl);\n       p = (struct pending_inline *) permalloc (sizeof (struct pending_inline));\n       p->parm_vec = t->parm_vec;\n       p->bindings = targs;\n@@ -1819,7 +1826,7 @@ end_template_instantiation (name)\n   my_friendly_assert (t != NULL_TREE\n \t\t      && TREE_CODE_CLASS (TREE_CODE (t)) == 't',\n \t\t      287);\n-  CLASSTYPE_USE_TEMPLATE (t) = 2;\n+  SET_CLASSTYPE_IMPLICIT_INSTANTIATION (t);\n   /* Make methods of template classes static, unless\n      -fexternal-templates is given.  */\n   if (!flag_external_templates)\n@@ -2227,8 +2234,10 @@ do_pending_expansions ()\n       if (TREE_ASM_WRITTEN (t))\n \tDECIDE (0);\n \n-      if (DECL_EXPLICITLY_INSTANTIATED (t))\n+      if (DECL_EXPLICIT_INSTANTIATION (t))\n \tDECIDE (1);\n+      else if (! flag_implicit_templates)\n+\tDECIDE (0);\n \n       /* If it's a method, let the class type decide it.\n \t @@ What if the method template is in a separate file?\n@@ -2357,7 +2366,12 @@ do_function_instantiation (declspecs, declarator)\n   if (! result)\n     cp_error (\"no matching template for `%D' found\", decl);\n \n-  DECL_EXPLICITLY_INSTANTIATED (result) = 1;\n+  if (flag_external_templates)\n+    return;\n+\n+  SET_DECL_EXPLICIT_INSTANTIATION (result);\n+  TREE_PUBLIC (result) = 1;\n+  DECL_EXTERNAL (result) = DECL_INLINE (result) && ! flag_implement_inlines;\n }\n \n void\n@@ -2366,14 +2380,24 @@ do_type_instantiation (name)\n {\n   tree t = TREE_TYPE (name);\n \n-  CLASSTYPE_EXPLICITLY_INSTANTIATED (t) = 1;\n+  if (flag_external_templates)\n+    return;\n+\n+  SET_CLASSTYPE_EXPLICIT_INSTANTIATION (t);\n   CLASSTYPE_VTABLE_NEEDS_WRITING (t) = 1;\n+  SET_CLASSTYPE_INTERFACE_KNOWN (t);\n+  CLASSTYPE_INTERFACE_ONLY (t) = 0;\n \n   /* this should really be done by instantiate_member_templates */\n   {\n     tree method = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (t), 0);\n     for (; method; method = TREE_CHAIN (method))\n-      DECL_EXPLICITLY_INSTANTIATED (method) = 1;\n+      {\n+\tSET_DECL_EXPLICIT_INSTANTIATION (method);\n+\tTREE_PUBLIC (method) = 1;\n+\tDECL_EXTERNAL (method) = (DECL_INLINE (method)\n+\t\t\t\t  && ! flag_implement_inlines);\n+      }\n   }\n \n   /* and data member templates, too */\n@@ -2384,7 +2408,7 @@ create_nested_upt (scope, name)\n      tree scope, name;\n {\n   tree t = make_lang_type (UNINSTANTIATED_P_TYPE);\n-  tree d = build_lang_decl (TYPE_DECL, name, t);\n+  tree d = build_decl (TYPE_DECL, name, t);\n \n   TYPE_NAME (t) = d;\n   TYPE_VALUES (t) = TYPE_VALUES (scope);"}, {"sha": "cd2eead5c04ec7312c869c634e26c7ce52dfa81b", "filename": "gcc/cp/sig.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0a339271ae588299147928769ca073a198d53c7/gcc%2Fcp%2Fsig.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0a339271ae588299147928769ca073a198d53c7/gcc%2Fcp%2Fsig.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsig.c?ref=a0a339271ae588299147928769ca073a198d53c7", "patch": "@@ -512,8 +512,8 @@ build_signature_table_constructor (sig_ty, rhs)\n \t{\n \t  if (! IS_DEFAULT_IMPLEMENTATION (sig_method))\n \t    {\n-\t      cp_error (\"class `%T' does not contain method `%s'\",\n-\t\t\trhstype, (int) IDENTIFIER_POINTER (sig_mname));\n+\t      cp_error (\"class `%T' does not contain method `%D'\",\n+\t\t\trhstype, sig_mname);\n \t      undo_casts (sig_ty);\n \t      return error_mark_node;\n \t    }"}, {"sha": "ea00ba273b373cb9dfc0b2bbbb89318e2a601459", "filename": "gcc/cp/spew.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0a339271ae588299147928769ca073a198d53c7/gcc%2Fcp%2Fspew.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0a339271ae588299147928769ca073a198d53c7/gcc%2Fcp%2Fspew.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fspew.c?ref=a0a339271ae588299147928769ca073a198d53c7", "patch": "@@ -236,6 +236,7 @@ probe_obstack (h, obj, nlevels)\n    a typename (when it may be a local variable or a class variable).\n    Value is 0 if we treat this name in a default fashion. */\n extern int looking_for_typename;\n+int looking_for_template;\n \n extern struct obstack *current_obstack, *saveable_obstack;\n tree got_scope;\n@@ -298,6 +299,8 @@ yylex()\n       if (nth_token (1)->yychar == SCOPE)\n \t/* Don't interfere with the setting from an 'aggr' prefix.  */\n \tlooking_for_typename++;\n+      else if (nth_token (1)->yychar == '<')\n+\tlooking_for_template = 1;\n \n       trrr = lookup_name (tmp_token.yylval.ttype, -2);\n \n@@ -334,6 +337,7 @@ yylex()\n       consume_token ();\n       if (looking_for_typename > 0)\n \tlooking_for_typename--;\n+      looking_for_template = 0;\n       break;\n \n     case SCSPEC:"}, {"sha": "98cbd41d5a8fc13026b500d64769b1ba638da1f4", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0a339271ae588299147928769ca073a198d53c7/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0a339271ae588299147928769ca073a198d53c7/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=a0a339271ae588299147928769ca073a198d53c7", "patch": "@@ -860,7 +860,7 @@ list_hash_add (hashcode, list)\n    This function frees the list you pass in if it is a duplicate.  */\n \n /* Set to 1 to debug without canonicalization.  Never set by program.  */\n-int debug_no_list_hash = 0;\n+static int debug_no_list_hash = 0;\n \n tree\n list_hash_canon (hashcode, list)"}, {"sha": "ffc6fd74cd6143a039b52f2284318862eeea7f1a", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 169, "deletions": 63, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0a339271ae588299147928769ca073a198d53c7/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0a339271ae588299147928769ca073a198d53c7/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=a0a339271ae588299147928769ca073a198d53c7", "patch": "@@ -542,7 +542,9 @@ comp_array_types (cmp, t1, t2, strict)\n \t2 : strict, except that if one type is a reference and\n \t    the other is not, compare the target type of the\n \t    reference to the type that's not a reference (ARM, p308).\n+\t    This is used for checking for illegal overloading.\n \t1 : strict (compared according to ANSI C)\n+\t    This is used for checking whether two function decls match.\n \t0 : <= (compared according to C++)\n \t-1: <= or >= (relaxed)\n \n@@ -608,7 +610,7 @@ comptypes (type1, type2, strict)\n \n   if (TYPE_READONLY (t1) != TYPE_READONLY (t2))\n     return 0;\n-  if (TREE_THIS_VOLATILE (t1) != TREE_THIS_VOLATILE (t2))\n+  if (TYPE_VOLATILE (t1) != TYPE_VOLATILE (t2))\n     return 0;\n \n   /* Allow for two different type nodes which have essentially the same\n@@ -739,7 +741,13 @@ comp_target_types (ttl, ttr, nptrs)\n     return 0;\n \n   if (TREE_CODE (ttr) == POINTER_TYPE)\n-    return comp_target_types (TREE_TYPE (ttl), TREE_TYPE (ttr), nptrs - 1);\n+    {\n+      if (TREE_CODE (TREE_TYPE (ttl)) == POINTER_TYPE\n+\t  || TREE_CODE (TREE_TYPE (ttl)) == ARRAY_TYPE)\n+\treturn comp_ptr_ttypes (TREE_TYPE (ttl), TREE_TYPE (ttr));\n+      else\n+\treturn comp_target_types (TREE_TYPE (ttl), TREE_TYPE (ttr), nptrs - 1);\n+    }\n \n   if (TREE_CODE (ttr) == REFERENCE_TYPE)\n     return comp_target_types (TREE_TYPE (ttl), TREE_TYPE (ttr), nptrs);\n@@ -2425,12 +2433,9 @@ convert_arguments (return_loc, typelist, values, fndecl, flags)\n \t    called_thing = \"constructor\";\n \t  else\n \t    called_thing = \"member function\";\n-\t  i -= 1;\n \t}\n       else\n-\t{\n-\t  called_thing = \"function\";\n-\t}\n+\tcalled_thing = \"function\";\n     }\n \n   for (valtail = values, typetail = typelist;\n@@ -2510,7 +2515,8 @@ convert_arguments (return_loc, typelist, values, fndecl, flags)\n       /* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.\n \t Strip such NOP_EXPRs, since VAL is used in non-lvalue context.  */\n       if (TREE_CODE (val) == NOP_EXPR\n-\t  && TREE_TYPE (val) == TREE_TYPE (TREE_OPERAND (val, 0)))\n+\t  && TREE_TYPE (val) == TREE_TYPE (TREE_OPERAND (val, 0))\n+\t  && (type == 0 || TREE_CODE (type) != REFERENCE_TYPE))\n \tval = TREE_OPERAND (val, 0);\n \n       if ((type == 0 || TREE_CODE (type) != REFERENCE_TYPE)\n@@ -2886,6 +2892,17 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n       if ((code0 == INTEGER_TYPE || code0 == REAL_TYPE)\n \t  && (code1 == INTEGER_TYPE || code1 == REAL_TYPE))\n \t{\n+\t  if (TREE_CODE (op1) == INTEGER_CST && integer_zerop (op1))\n+\t    {\n+\t      error (\"division by zero\");\n+\t      op1 = integer_one_node;\n+\t    }\n+\t  else if (TREE_CODE (op1) == REAL_CST && real_zerop (op1))\n+\t    {\n+\t      error (\"division by zero\");\n+\t      op1 = build_real (TREE_TYPE (op1), dconst1);\n+\t    }\n+\t      \n \t  if (!(code0 == INTEGER_TYPE && code1 == INTEGER_TYPE))\n \t    resultcode = RDIV_EXPR;\n \t  else\n@@ -2936,6 +2953,17 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \n     case TRUNC_MOD_EXPR:\n     case FLOOR_MOD_EXPR:\n+      if (code1 == INTEGER_TYPE && integer_zerop (op1))\n+\t{\n+\t  error (\"division by zero\");\n+\t  op1 = integer_one_node;\n+\t}\n+      else if (code1 == REAL_TYPE && real_zerop (op1))\n+\t{\n+\t  error (\"division by zero\");\n+\t  op1 = build_real (TREE_TYPE (op1), dconst1);\n+\t}\n+      \n       if (code0 == INTEGER_TYPE && code1 == INTEGER_TYPE)\n \t{\n \t  /* Although it would be tempting to shorten always here, that loses\n@@ -4001,17 +4029,15 @@ build_unary_op (code, xarg, noconvert)\n \t  TREE_REFERENCE_EXPR (arg) = 1;\n \t  return arg;\n \t}\n-      else if (TREE_CODE (arg) == FUNCTION_DECL\n+      else if (pedantic\n+\t       && TREE_CODE (arg) == FUNCTION_DECL\n \t       && DECL_NAME (arg)\n \t       && DECL_CONTEXT (arg) == NULL_TREE\n \t       && IDENTIFIER_LENGTH (DECL_NAME (arg)) == 4\n \t       && IDENTIFIER_POINTER (DECL_NAME (arg))[0] == 'm'\n \t       && ! strcmp (IDENTIFIER_POINTER (DECL_NAME (arg)), \"main\"))\n-\t{\n-\t  /* ARM $3.4 */\n-\t  error (\"attempt to take address of function `main'\");\n-\t  return error_mark_node;\n-\t}\n+\t/* ARM $3.4 */\n+\tpedwarn (\"taking address of function `main'\");\n \n       /* Let &* cancel out to simplify resulting code.  */\n       if (TREE_CODE (arg) == INDIRECT_REF)\n@@ -4911,6 +4937,13 @@ build_c_cast (type, expr)\n \t}\n     }\n \n+  if (TREE_CODE (type) == FUNCTION_TYPE\n+      || TREE_CODE (type) == METHOD_TYPE)\n+    {\n+      cp_error (\"casting to function type `%T'\", type);\n+      return error_mark_node;\n+    }\n+\n   if (IS_SIGNATURE (type))\n     {\n       error (\"cast specifies signature type\");\n@@ -5396,6 +5429,33 @@ build_modify_expr (lhs, modifycode, rhs)\n       }\n     }\n \n+  if (TREE_CODE (lhs) == OFFSET_REF)\n+    {\n+      if (TREE_OPERAND (lhs, 0) == NULL_TREE)\n+\t{\n+\t  /* Static class member?  */\n+\t  tree member = TREE_OPERAND (lhs, 1);\n+\t  if (TREE_CODE (member) == VAR_DECL)\n+\t    lhs = member;\n+\t  else\n+\t    {\n+\t      compiler_error (\"invalid static class member\");\n+\t      return error_mark_node;\n+\t    }\n+\t}\n+      else\n+\tlhs = resolve_offset_ref (lhs);\n+\n+      olhstype = lhstype = TREE_TYPE (lhs);\n+    }\n+\n+  if (TREE_CODE (lhstype) == REFERENCE_TYPE\n+      && modifycode != INIT_EXPR)\n+    {\n+      lhs = convert_from_reference (lhs);\n+      olhstype = lhstype = TREE_TYPE (lhs);\n+    }\n+\n   /* If a binary op has been requested, combine the old LHS value with the RHS\n      producing the value we should actually store into the LHS.  */\n \n@@ -5413,9 +5473,6 @@ build_modify_expr (lhs, modifycode, rhs)\n     }\n   else if (modifycode == NOP_EXPR)\n     {\n-      /* must deal with overloading of `operator=' here.  */\n-      if (TREE_CODE (lhstype) == REFERENCE_TYPE)\n-\tlhstype = TREE_TYPE (lhstype);\n #if 1\n       /* `operator=' is not an inheritable operator.  */\n       if (TYPE_LANG_SPECIFIC (lhstype) && TYPE_HAS_ASSIGNMENT (lhstype))\n@@ -5490,7 +5547,6 @@ build_modify_expr (lhs, modifycode, rhs)\n       newrhs = build_binary_op (modifycode, lhs, rhs, 1);\n     }\n \n-#if 0\n   /* Handle a cast used as an \"lvalue\".\n      We have already performed any binary operator using the value as cast.\n      Now convert the result to the cast type of the lhs,\n@@ -5515,6 +5571,9 @@ build_modify_expr (lhs, modifycode, rhs)\n       {\n \ttree inner_lhs = TREE_OPERAND (lhs, 0);\n \ttree result;\n+\tif (! lvalue_p (lhs) && pedantic)\n+\t  pedwarn (\"cast to non-reference type used as lvalue\");\n+\n \tresult = build_modify_expr (inner_lhs, NOP_EXPR,\n \t\t\t\t    convert (TREE_TYPE (inner_lhs),\n \t\t\t\t\t     convert (lhstype, newrhs)));\n@@ -5523,25 +5582,6 @@ build_modify_expr (lhs, modifycode, rhs)\n \treturn convert_force (TREE_TYPE (lhs), result);\n       }\n     }\n-#endif\n-\n-  if (TREE_CODE (lhs) == OFFSET_REF)\n-    {\n-      if (TREE_OPERAND (lhs, 0) == NULL_TREE)\n-\t{\n-\t  /* Static class member?  */\n-\t  tree member = TREE_OPERAND (lhs, 1);\n-\t  if (TREE_CODE (member) == VAR_DECL)\n-\t    lhs = member;\n-\t  else\n-\t    {\n-\t      compiler_error (\"invalid static class member\");\n-\t      return error_mark_node;\n-\t    }\n-\t}\n-      else\n-\tlhs = resolve_offset_ref (lhs);\n-    }\n \n   /* Now we have handled acceptable kinds of LHS that are not truly lvalues.\n      Reject anything strange now.  */\n@@ -5576,7 +5616,18 @@ build_modify_expr (lhs, modifycode, rhs)\n       && (TREE_CODE (lhstype) == INTEGER_TYPE\n \t  || TREE_CODE (lhstype) == REAL_TYPE\n \t  || TREE_CODE (lhstype) == ENUMERAL_TYPE))\n-    lhstype = TREE_TYPE (get_unwidened (lhs, 0));\n+    {\n+      lhstype = TREE_TYPE (get_unwidened (lhs, 0));\n+\n+      /* If storing in a field that is in actuality a short or narrower\n+\t than one, we must store in the field in its actual type.  */\n+\n+      if (lhstype != TREE_TYPE (lhs))\n+\t{\n+\t  lhs = copy_node (lhs);\n+\t  TREE_TYPE (lhs) = lhstype;\n+\t}\n+    }\n \n   /* check to see if there is an assignment to `this' */\n   if (lhs == current_class_decl)\n@@ -5734,15 +5785,6 @@ build_modify_expr (lhs, modifycode, rhs)\n #endif\n     }\n \n-  /* If storing in a field that is in actuality a short or narrower than one,\n-     we must store in the field in its actual type.  */\n-\n-  if (lhstype != TREE_TYPE (lhs))\n-    {\n-      lhs = copy_node (lhs);\n-      TREE_TYPE (lhs) = lhstype;\n-    }\n-\n   /* Convert new value to destination type.  */\n \n   if (TREE_CODE (lhstype) == ARRAY_TYPE)\n@@ -6081,6 +6123,14 @@ build_ptrmemfunc (type, pfn, force)\n       return digest_init (TYPE_GET_PTRMEMFUNC_TYPE (type), u, (tree*)0);\n     }\n \n+  if (TREE_CODE (pfn) == TREE_LIST)\n+    {\n+      pfn = instantiate_type (type, pfn, 1);\n+      if (pfn == error_mark_node)\n+\treturn error_mark_node;\n+      pfn = build_unary_op (ADDR_EXPR, pfn, 0);\n+    }\n+\n   /* Allow pointer to member conversions here. */\n   delta = get_delta_difference (TYPE_METHOD_BASETYPE (TREE_TYPE (TREE_TYPE (pfn))),\n \t\t\t\tTYPE_METHOD_BASETYPE (TREE_TYPE (type)),\n@@ -6399,45 +6449,63 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n \t}\n       else\n \t{\n-\t  int const_parity = TYPE_READONLY (type) ^ TYPE_READONLY (rhstype);\n-\t  int volatile_parity = TYPE_VOLATILE (type) ^ TYPE_VOLATILE (rhstype);\n+\t  int add_quals = 0, const_parity = 0, volatile_parity = 0;\n+\t  int left_const = 1;\n \t  int unsigned_parity;\n \t  int nptrs = 0;\n \n-\t  while (TREE_CODE (ttl) == POINTER_TYPE\n-\t\t && TREE_CODE (ttr) == POINTER_TYPE)\n+\t  /* This code is basically a duplicate of comp_ptr_ttypes_real.  */\n+\t  for (; ; ttl = TREE_TYPE (ttl), ttr = TREE_TYPE (ttr))\n \t    {\n \t      nptrs -= 1;\n-\t      const_parity |= TYPE_READONLY (ttl) ^ TYPE_READONLY (ttr);\n-\t      volatile_parity |= TYPE_VOLATILE (ttl) ^ TYPE_VOLATILE (ttr);\n-\t      ttl = TREE_TYPE (ttl);\n-\t      ttr = TREE_TYPE (ttr);\n+\t      const_parity |= TYPE_READONLY (ttl) < TYPE_READONLY (ttr);\n+\t      volatile_parity |= TYPE_VOLATILE (ttl) < TYPE_VOLATILE (ttr);\n+\n+\t      if (! left_const\n+\t\t  && (TYPE_READONLY (ttl) > TYPE_READONLY (ttr)\n+\t\t      || TYPE_VOLATILE (ttl) > TYPE_VOLATILE (ttr)))\n+\t\tadd_quals = 1;\n+\t      left_const &= TYPE_READONLY (ttl);\n+\n+\t      if (TREE_CODE (ttl) != POINTER_TYPE)\n+\t\tbreak;\n \t    }\n \t  unsigned_parity = TREE_UNSIGNED (ttl) - TREE_UNSIGNED (ttr);\n \t  if (unsigned_parity)\n-\t    if (TREE_UNSIGNED (ttl))\n-\t      ttr = unsigned_type (ttr);\n-\t    else\n-\t      ttl = unsigned_type (ttl);\n+\t    {\n+\t      if (TREE_UNSIGNED (ttl))\n+\t\tttr = unsigned_type (ttr);\n+\t      else\n+\t\tttl = unsigned_type (ttl);\n+\t    }\n \n \t  if (comp_target_types (ttl, ttr, nptrs))\n \t    {\n+\t      if (add_quals)\n+\t\t{\n+\t\t  if (fndecl)\n+\t\t    cp_pedwarn (\"passing `%T' as argument %P of `%D' adds cv-quals without intervening `const'\",\n+\t\t\t\trhstype, parmnum, fndecl);\n+\t\t  else\n+\t\t    cp_pedwarn (\"%s to `%T' from `%T' adds cv-quals without intervening `const'\",\n+\t\t\t\terrtype, type, rhstype);\n+\t\t}\n \t      if (const_parity)\n \t\t{\n \t\t  if (fndecl)\n-\t\t    cp_warning (\"passing `%T' as argument %P of `%D' discards const\",\n+\t\t    cp_pedwarn (\"passing `%T' as argument %P of `%D' discards const\",\n \t\t\t\trhstype, parmnum, fndecl);\n \t\t  else\n-\t\t    cp_warning (\"%s to `%T' from `%T' discards const\",\n+\t\t    cp_pedwarn (\"%s to `%T' from `%T' discards const\",\n \t\t\t\terrtype, type, rhstype);\n \t\t}\n \t      if (volatile_parity)\n \t\t{\n \t\t  if (fndecl)\n-\t\t    cp_warning (\"passing `%T' as argument %P of `%D' discards volatile\",\n+\t\t    cp_pedwarn (\"passing `%T' as argument %P of `%D' discards volatile\",\n \t\t\t\trhstype, parmnum, fndecl);\n \t\t  else\n-\t\t    cp_warning (\"%s to `%T' from `%T' discards volatile\",\n+\t\t    cp_pedwarn (\"%s to `%T' from `%T' discards volatile\",\n \t\t\t\terrtype, type, rhstype);\n \t\t}\n \t      if (unsigned_parity > 0)\n@@ -6591,7 +6659,8 @@ convert_for_initialization (exp, type, rhs, flags, errtype, fndecl, parmnum)\n   /* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.\n      Strip such NOP_EXPRs, since RHS is used in non-lvalue context.  */\n   if (TREE_CODE (rhs) == NOP_EXPR\n-      && TREE_TYPE (rhs) == TREE_TYPE (TREE_OPERAND (rhs, 0)))\n+      && TREE_TYPE (rhs) == TREE_TYPE (TREE_OPERAND (rhs, 0))\n+      && codel != REFERENCE_TYPE)\n     rhs = TREE_OPERAND (rhs, 0);\n \n   if (rhs == error_mark_node\n@@ -7143,3 +7212,40 @@ c_expand_start_case (exp)\n \n   return exp;\n }\n+\n+/* CONSTP remembers whether or not all the intervening pointers in the `to'\n+   type have been const.  */\n+int\n+comp_ptr_ttypes_real (to, from, constp)\n+     tree to, from;\n+     int constp;\n+{\n+  for (; ; to = TREE_TYPE (to), from = TREE_TYPE (from))\n+    {\n+      if (TREE_CODE (to) != TREE_CODE (from))\n+\treturn 0;\n+\n+      if (TYPE_READONLY (from) > TYPE_READONLY (to)\n+\t  || TYPE_VOLATILE (from) > TYPE_VOLATILE (to))\n+\treturn 0;\n+\n+      if (! constp\n+\t  && (TYPE_READONLY (to) > TYPE_READONLY (from)\n+\t      || TYPE_VOLATILE (to) > TYPE_READONLY (from)))\n+\treturn 0;\n+      constp &= TYPE_READONLY (to);\n+\n+      if (TREE_CODE (to) != POINTER_TYPE)\n+\treturn comptypes (TYPE_MAIN_VARIANT (to), TYPE_MAIN_VARIANT (from), 1);\n+    }\n+}\n+\n+/* When comparing, say, char ** to char const **, this function takes the\n+   'char *' and 'char const *'.  Do not pass non-pointer types to this\n+   function.  */\n+int\n+comp_ptr_ttypes (to, from)\n+     tree to, from;\n+{\n+  return comp_ptr_ttypes_real (to, from, 1);\n+}"}, {"sha": "237d02a0f843dffb6d29d281a57f66af62216114", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 43, "deletions": 92, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0a339271ae588299147928769ca073a198d53c7/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0a339271ae588299147928769ca073a198d53c7/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=a0a339271ae588299147928769ca073a198d53c7", "patch": "@@ -655,6 +655,7 @@ digest_init (type, init, tail)\n       && ((TREE_CODE (init) == ADDR_EXPR\n \t   && TREE_CODE (TREE_TYPE (init)) == POINTER_TYPE\n \t   && TREE_CODE (TREE_TYPE (TREE_TYPE (init))) == METHOD_TYPE)\n+\t  || TREE_CODE (init) == TREE_LIST\n \t  || integer_zerop (init)\n \t  || (TREE_TYPE (init) && TYPE_PTRMEMFUNC_P (TREE_TYPE (init)))))\n     {\n@@ -1237,6 +1238,12 @@ build_x_arrow (datum)\n   if (type == error_mark_node)\n     return error_mark_node;\n \n+  if (TREE_CODE (rval) == OFFSET_REF)\n+    {\n+      rval = resolve_offset_ref (datum);\n+      type = TREE_TYPE (rval);\n+    }\n+\n   if (TREE_CODE (type) == REFERENCE_TYPE)\n     {\n       rval = convert_from_reference (rval);\n@@ -1268,7 +1275,6 @@ build_x_arrow (datum)\n   else\n     last_rval = default_conversion (rval);\n \n- more:\n   /* Signature pointers are not dereferenced.  */\n   if (TYPE_LANG_SPECIFIC (TREE_TYPE (last_rval))\n       && IS_SIGNATURE_POINTER (TREE_TYPE (last_rval)))\n@@ -1277,20 +1283,6 @@ build_x_arrow (datum)\n   if (TREE_CODE (TREE_TYPE (last_rval)) == POINTER_TYPE)\n     return build_indirect_ref (last_rval, NULL_PTR);\n \n-  if (TREE_CODE (TREE_TYPE (last_rval)) == OFFSET_TYPE)\n-    {\n-      if (TREE_CODE (last_rval) == OFFSET_REF\n-\t  && TREE_STATIC (TREE_OPERAND (last_rval, 1)))\n-\t{\n-\t  last_rval = TREE_OPERAND (last_rval, 1);\n-\t  if (TREE_CODE (TREE_TYPE (last_rval)) == REFERENCE_TYPE)\n-\t    last_rval = convert_from_reference (last_rval);\n-\t  goto more;\n-\t}\n-      compiler_error (\"invalid member type in build_x_arrow\");\n-      return error_mark_node;\n-    }\n-\n   if (types_memoized)\n     error (\"result of `operator->()' yields non-pointer result\");\n   else\n@@ -1372,7 +1364,6 @@ build_functional_cast (exp, parms)\n      or a C cast in C++'s `functional' notation.  */\n   tree type, name = NULL_TREE;\n   tree expr_as_ctor = NULL_TREE;\n-  tree expr_as_conversion = NULL_TREE;\n \n   if (exp == error_mark_node || parms == error_mark_node)\n     return error_mark_node;\n@@ -1423,7 +1414,12 @@ build_functional_cast (exp, parms)\n       /* this must build a C cast */\n       if (parms == NULL_TREE)\n \treturn build1 (NOP_EXPR, type, integer_zero_node);\n-      return build_c_cast (type, build_compound_expr (parms));\n+      else if (TREE_CHAIN (parms) != NULL_TREE)\n+\t{\n+\t  pedwarn (\"initializer list being treated as compound expression\");\n+\t  parms = build_compound_expr (parms);\n+\t}\n+      return build_c_cast (type, parms);\n     }\n \n   if (TYPE_SIZE (type) == NULL_TREE)\n@@ -1433,90 +1429,45 @@ build_functional_cast (exp, parms)\n     }\n \n   if (parms && TREE_CHAIN (parms) == NULL_TREE)\n-    expr_as_conversion\n-      = build_type_conversion (CONVERT_EXPR, type, TREE_VALUE (parms), 0);\n-    \n-  if (! TYPE_HAS_CONSTRUCTOR (type) && parms != NULL_TREE)\n-    {\n-      char *msg = 0;\n+    return build_c_cast (type, parms);\n \n-      if (parms == NULL_TREE)\n-\tmsg = \"argument missing in cast to `%T' type\";\n-      else if (TREE_CHAIN (parms) == NULL_TREE)\n-\t{\n-\t  if (expr_as_conversion == NULL_TREE)\n-\t    msg = \"conversion to type `%T' failed\";\n-\t}\n-      else msg = \"type `%T' does not have a constructor\";\n+  expr_as_ctor = build_method_call (NULL_TREE, name, parms,\n+\t\t\t\t    NULL_TREE, LOOKUP_NORMAL);\n \n-      if (expr_as_conversion)\n-\treturn expr_as_conversion;\n+  if (expr_as_ctor == error_mark_node)\n+    return error_mark_node;\n \n-      cp_error (msg, type);\n-      return error_mark_node;\n-    }\n+  if (current_function_decl)\n+    return build_cplus_new (type, expr_as_ctor, 0);\n \n   {\n-    int flags = LOOKUP_SPECULATIVELY|LOOKUP_NORMAL;\n-\n-    if (parms && TREE_CHAIN (parms) == NULL_TREE)\n-      flags |= LOOKUP_NO_CONVERSION;\n+    register tree parm = TREE_OPERAND (expr_as_ctor, 1);\n \n-    expr_as_ctor = build_method_call (NULL_TREE, name, parms,\n-\t\t\t\t      NULL_TREE, flags);\n-\n-    if (expr_as_ctor == error_mark_node)\n-      return error_mark_node;\n-\n-    else if (expr_as_ctor)\n-      {\n-\tif (expr_as_conversion && expr_as_conversion != error_mark_node)\n-\t  {\n-\t    /* ANSI C++ June 5 1992 WP 12.3.2.6.1 */\n-\t    cp_error (\"ambiguity between conversion to `%T' and constructor\",\n-\t\t      type);\n-\t    return error_mark_node;\n-\t  }\n-\n-\tif (current_function_decl)\n-\t  return build_cplus_new (type, expr_as_ctor, 0);\n-\n-\t{\n-\t  register tree parm = TREE_OPERAND (expr_as_ctor, 1);\n-\n-\t  /* Initializers for static variables and parameters have\n-\t     to handle doing the initialization and cleanup themselves.  */\n-\t  my_friendly_assert (TREE_CODE (expr_as_ctor) == CALL_EXPR, 322);\n+    /* Initializers for static variables and parameters have\n+       to handle doing the initialization and cleanup themselves.  */\n+    my_friendly_assert (TREE_CODE (expr_as_ctor) == CALL_EXPR, 322);\n #if 0\n-\t  /* The following assertion fails in cases where we are initializing\n-\t     a static member variable of a particular instance of a template\n-\t     class with a call to a constructor of the given instance, as in:\n-\n-\t\tTMPL<int> object = TMPL<int>();\n-\n-\t     Curiously, the assertion does not fail if we do the same thing\n-\t     for a static member of a non-template class, as in:\n-\n-\t\tT object = T();\n-\n-\t     I can't see why we should care here whether or not the initializer\n-\t     expression involves a call to `new', so for the time being, it\n-\t     seems best to just avoid doing this assertion.  */\n-\t  my_friendly_assert (TREE_CALLS_NEW (TREE_VALUE (parm)), 323);\n+    /* The following assertion fails in cases where we are initializing\n+       a static member variable of a particular instance of a template\n+       class with a call to a constructor of the given instance, as in:\n+       \n+       TMPL<int> object = TMPL<int>();\n+       \n+       Curiously, the assertion does not fail if we do the same thing\n+       for a static member of a non-template class, as in:\n+       \n+       T object = T();\n+       \n+       I can't see why we should care here whether or not the initializer\n+       expression involves a call to `new', so for the time being, it\n+       seems best to just avoid doing this assertion.  */\n+    my_friendly_assert (TREE_CALLS_NEW (TREE_VALUE (parm)), 323);\n #endif\n-\t  TREE_VALUE (parm) = NULL_TREE;\n-\t  expr_as_ctor = build_indirect_ref (expr_as_ctor, NULL_PTR);\n-\t  TREE_HAS_CONSTRUCTOR (expr_as_ctor) = 1;\n-\t}\n-\treturn expr_as_ctor;\n-      }\n-\n-    if (expr_as_conversion)\n-      return expr_as_conversion;\n-\n-    cp_error (\"no suitable conversion to `%T' exists\", type);\n-    return error_mark_node;\n+    TREE_VALUE (parm) = NULL_TREE;\n+    expr_as_ctor = build_indirect_ref (expr_as_ctor, NULL_PTR);\n+    TREE_HAS_CONSTRUCTOR (expr_as_ctor) = 1;\n   }\n+  return expr_as_ctor;\n }\n \f\n /* Return the character string for the name that encodes the"}]}