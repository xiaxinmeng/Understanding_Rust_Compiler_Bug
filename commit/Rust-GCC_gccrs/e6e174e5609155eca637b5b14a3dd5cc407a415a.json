{"sha": "e6e174e5609155eca637b5b14a3dd5cc407a415a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTZlMTc0ZTU2MDkxNTVlY2E2MzdiNWIxNGEzZGQ1Y2M0MDdhNDE1YQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1998-10-27T22:33:40Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-10-27T22:33:40Z"}, "message": "call.c (standard_conversion): instantiate_type here.\n\n\t* call.c (standard_conversion): instantiate_type here.\n\t(reference_binding): And here.\n\t(implicit_conversion): Not here.\n\t(build_op_delete_call): No need to cons up an OVERLOAD.\n\t* cvt.c (cp_convert_to_pointer): instantiate_type here.\n\t(convert_to_reference): And here.\n\t* decl.c (grok_reference_init): Not here.\n\t(grokparms): Or here.\n\t* typeck2.c (digest_init): Or here.\n\t* typeck.c (decay_conversion): Take the address of overloaded\n\tfunctions, too.\n\t(require_instantiated_type): Lose.\n\t(convert_arguments): Don't handle unknown types here.\n\t(build_c_cast): Likewise.\n\t(build_binary_op): Gut.\n\t(build_conditional_expr): Don't require_instantiated_type.\n\t(build_modify_expr): Likewise.\n\t(build_static_cast): Don't instantiate_type.\n\t(build_reinterpret_cast): Likewise.\n\t(build_const_cast): Likewise.\n\t(convert_for_initialization): Likewise.\n\t(build_ptrmemfunc): Use type_unknown_p.\n\t(convert_for_assignment): Also do default_conversion on overloaded\n\tfunctions.  Hand them off to ocp_convert.\n\t* pt.c (convert_nontype_argument): Tell instantiate_type to complain.\n\tDo complain about overload resolution producing a non-public fn.\n\nFrom-SVN: r23373", "tree": {"sha": "e789a16e8f98d4349de8a3dcb9b0a52db49e1f6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e789a16e8f98d4349de8a3dcb9b0a52db49e1f6b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e6e174e5609155eca637b5b14a3dd5cc407a415a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6e174e5609155eca637b5b14a3dd5cc407a415a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6e174e5609155eca637b5b14a3dd5cc407a415a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6e174e5609155eca637b5b14a3dd5cc407a415a/comments", "author": null, "committer": null, "parents": [{"sha": "950ad3c380028795a85da9e841dc9cc52a06118a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/950ad3c380028795a85da9e841dc9cc52a06118a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/950ad3c380028795a85da9e841dc9cc52a06118a"}], "stats": {"total": 437, "additions": 172, "deletions": 265}, "files": [{"sha": "f21a5e98ad9f7d1fc890a1d12344cfeaef8bf6fd", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6e174e5609155eca637b5b14a3dd5cc407a415a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6e174e5609155eca637b5b14a3dd5cc407a415a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e6e174e5609155eca637b5b14a3dd5cc407a415a", "patch": "@@ -1,3 +1,32 @@\n+1998-10-27  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* call.c (standard_conversion): instantiate_type here.\n+\t(reference_binding): And here.\n+\t(implicit_conversion): Not here.\n+\t(build_op_delete_call): No need to cons up an OVERLOAD.\n+\t* cvt.c (cp_convert_to_pointer): instantiate_type here.\n+\t(convert_to_reference): And here.\n+\t* decl.c (grok_reference_init): Not here.\n+\t(grokparms): Or here.\n+\t* typeck2.c (digest_init): Or here.\n+\t* typeck.c (decay_conversion): Take the address of overloaded\n+\tfunctions, too.\n+\t(require_instantiated_type): Lose.\n+\t(convert_arguments): Don't handle unknown types here.\n+\t(build_c_cast): Likewise.\n+\t(build_binary_op): Gut.\n+\t(build_conditional_expr): Don't require_instantiated_type.\n+\t(build_modify_expr): Likewise.\n+\t(build_static_cast): Don't instantiate_type.\n+\t(build_reinterpret_cast): Likewise.\n+\t(build_const_cast): Likewise.\n+\t(convert_for_initialization): Likewise.\n+\t(build_ptrmemfunc): Use type_unknown_p.\n+\t(convert_for_assignment): Also do default_conversion on overloaded\n+\tfunctions.  Hand them off to ocp_convert.\n+\t* pt.c (convert_nontype_argument): Tell instantiate_type to complain.\n+\tDo complain about overload resolution producing a non-public fn.\n+\n 1998-10-26  Mark Mitchell  <mark@markmitchell.com>\n \n \t* error.c (dump_decl): Deal with TEMPLATE_DECLs that are"}, {"sha": "8e074b6d9c9453ca82706c3a02f3b5fd6e824f86", "filename": "gcc/cp/call.c", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6e174e5609155eca637b5b14a3dd5cc407a415a/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6e174e5609155eca637b5b14a3dd5cc407a415a/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=e6e174e5609155eca637b5b14a3dd5cc407a415a", "patch": "@@ -803,6 +803,15 @@ standard_conversion (to, from, expr)\n   to = strip_top_quals (to);\n   from = strip_top_quals (from);\n \n+  if ((TYPE_PTRFN_P (to) || TYPE_PTRMEMFUNC_P (to))\n+      && expr && type_unknown_p (expr))\n+    {\n+      expr = instantiate_type (to, expr, 0);\n+      if (expr == error_mark_node)\n+\treturn NULL_TREE;\n+      from = TREE_TYPE (expr);\n+    }\n+\n   fcode = TREE_CODE (from);\n   tcode = TREE_CODE (to);\n \n@@ -968,6 +977,14 @@ reference_binding (rto, rfrom, expr, flags)\n   tree from = rfrom;\n   int related;\n \n+  if (TREE_CODE (to) == FUNCTION_TYPE && expr && type_unknown_p (expr))\n+    {\n+      expr = instantiate_type (to, expr, 0);\n+      if (expr == error_mark_node)\n+\treturn NULL_TREE;\n+      from = TREE_TYPE (expr);\n+    }\n+\n   if (TREE_CODE (from) == REFERENCE_TYPE)\n     from = TREE_TYPE (from);\n   else if (! expr || ! real_lvalue_p (expr))\n@@ -1032,14 +1049,6 @@ implicit_conversion (to, from, expr, flags)\n   tree conv;\n   struct z_candidate *cand;\n \n-  if (expr && type_unknown_p (expr))\n-    {\n-      expr = instantiate_type (to, expr, 0);\n-      if (expr == error_mark_node)\n-\treturn 0;\n-      from = TREE_TYPE (expr);\n-    }\n-\n   if (TREE_CODE (to) == REFERENCE_TYPE)\n     conv = reference_binding (to, from, expr, flags);\n   else\n@@ -1049,7 +1058,7 @@ implicit_conversion (to, from, expr, flags)\n     ;\n   else if (expr != NULL_TREE\n \t   && (IS_AGGR_TYPE (non_reference (from))\n-\t    || IS_AGGR_TYPE (non_reference (to)))\n+\t       || IS_AGGR_TYPE (non_reference (to)))\n \t   && (flags & LOOKUP_NO_CONVERSION) == 0)\n     {\n       cand = build_user_type_conversion_1\n@@ -2907,11 +2916,6 @@ build_op_delete_call (code, addr, size, flags, placement)\n   if (type != TYPE_MAIN_VARIANT (type))\n     addr = cp_convert (build_pointer_type (TYPE_MAIN_VARIANT (type)), addr);\n \n-  /* instantiate_type will always return a plain function; pretend it's\n-     overloaded.  */\n-  if (TREE_CODE (fns) == FUNCTION_DECL)\n-    fns = scratch_ovl_cons (fns, NULL_TREE);\n-\n   fn = instantiate_type (fntype, fns, 0);\n \n   if (fn != error_mark_node)"}, {"sha": "c5d67e57ed52651df833150a1e17f68168e1c73e", "filename": "gcc/cp/class.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6e174e5609155eca637b5b14a3dd5cc407a415a/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6e174e5609155eca637b5b14a3dd5cc407a415a/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=e6e174e5609155eca637b5b14a3dd5cc407a415a", "patch": "@@ -4968,8 +4968,8 @@ validate_lhs (lhstype, complain)\n    try many possible instantiations, in hopes that at least one will\n    work.\n \n-   This function is used in build_modify_expr, convert_arguments,\n-   build_c_cast, and compute_conversion_costs.  */\n+   For non-recursive calls, LHSTYPE should be a function, pointer to\n+   function, or a pointer to member function.  */\n \n tree\n instantiate_type (lhstype, rhs, complain)\n@@ -5132,8 +5132,8 @@ instantiate_type (lhstype, rhs, complain)\n \t  {\n \t    if (complain)\n \t      cp_error(\"cannot resolve overloaded function `%D' \" \n-\t\t       \"based on non-function type\", \n-\t\t       DECL_NAME (OVL_FUNCTION (rhs)));\n+\t\t       \"based on non-function type `%T'\", \n+\t\t       DECL_NAME (OVL_FUNCTION (rhs)), lhstype);\n \t    return error_mark_node;\n \t  }\n \t"}, {"sha": "b96246a9385342f04b40e78ab3c77cf2f3530842", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6e174e5609155eca637b5b14a3dd5cc407a415a/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6e174e5609155eca637b5b14a3dd5cc407a415a/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=e6e174e5609155eca637b5b14a3dd5cc407a415a", "patch": "@@ -3136,7 +3136,6 @@ extern tree complete_type\t\t\tPROTO((tree));\n extern tree complete_type_or_else               PROTO((tree));\n extern int type_unknown_p\t\t\tPROTO((tree));\n extern int fntype_p\t\t\t\tPROTO((tree));\n-extern tree require_instantiated_type\t\tPROTO((tree, tree, tree));\n extern tree commonparms\t\t\t\tPROTO((tree, tree));\n extern tree original_type\t\t\tPROTO((tree));\n extern tree common_type\t\t\t\tPROTO((tree, tree));"}, {"sha": "30fb33479fef1b51b6b84cc2c7d0167c4905baac", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6e174e5609155eca637b5b14a3dd5cc407a415a/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6e174e5609155eca637b5b14a3dd5cc407a415a/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=e6e174e5609155eca637b5b14a3dd5cc407a415a", "patch": "@@ -249,6 +249,9 @@ cp_convert_to_pointer (type, expr)\n       return convert_to_pointer (type, expr);\n     }\n \n+  if (type_unknown_p (expr))\n+    return instantiate_type (type, expr, 1);\n+\n   cp_error (\"cannot convert `%E' from type `%T' to type `%T'\",\n \t    expr, intype, type);\n   return error_mark_node;\n@@ -407,6 +410,12 @@ convert_to_reference (reftype, expr, convtype, flags, decl)\n   tree rval_as_conversion = NULL_TREE;\n   int i;\n \n+  if (TREE_CODE (type) == FUNCTION_TYPE && intype == unknown_type_node)\n+    {\n+      expr = instantiate_type (type, expr, 0);\n+      intype = TREE_TYPE (expr);\n+    }\n+\n   if (TREE_CODE (intype) == REFERENCE_TYPE)\n     my_friendly_abort (364);\n "}, {"sha": "9a7ecc711c67a1593cb2d50d9d9452ff79860348", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6e174e5609155eca637b5b14a3dd5cc407a415a/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6e174e5609155eca637b5b14a3dd5cc407a415a/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=e6e174e5609155eca637b5b14a3dd5cc407a415a", "patch": "@@ -6921,10 +6921,6 @@ grok_reference_init (decl, type, init)\n       return;\n     }\n \n-  if (TREE_TYPE (init) && TREE_CODE (TREE_TYPE (init)) == UNKNOWN_TYPE)\n-    /* decay_conversion is probably wrong for references to functions.  */\n-    init = decay_conversion (instantiate_type (TREE_TYPE (type), init, 1));\n-\n   if (TREE_CODE (init) == TREE_LIST)\n     init = build_compound_expr (init);\n \n@@ -11146,8 +11142,12 @@ grokparms (first_parm, funcdef_flag)\n \t\t\t  else if (TREE_READONLY_DECL_P (init))\n \t\t\t    init = decl_constant_value (init);\n \t\t\t}\n-\t\t      else\n-\t\t\tinit = require_instantiated_type (type, init, integer_zero_node);\n+\t\t      else if (TREE_TYPE (init) == NULL_TREE)\n+\t\t\t{\n+\t\t\t  error (\"argument list may not have an initializer list\");\n+\t\t\t  init = error_mark_node;\n+\t\t\t}\n+\n \t\t      if (! processing_template_decl\n \t\t\t  && init != error_mark_node\n \t\t\t  && TREE_CODE (init) != DEFAULT_ARG"}, {"sha": "1efbd19ebfdd3300d4988ac9acd339ebdfcf3bc5", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6e174e5609155eca637b5b14a3dd5cc407a415a/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6e174e5609155eca637b5b14a3dd5cc407a415a/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=e6e174e5609155eca637b5b14a3dd5cc407a415a", "patch": "@@ -2510,7 +2510,7 @@ convert_nontype_argument (type, expr)\n \t    else\n \t      fns = expr;\n \n-\t    fn = instantiate_type (type_pointed_to, fns, 0);\n+\t    fn = instantiate_type (type_pointed_to, fns, 1);\n \n \t    if (fn == error_mark_node)\n \t      return error_mark_node;\n@@ -2567,22 +2567,24 @@ convert_nontype_argument (type, expr)\n \t    tree fns = expr;\n \t    tree fn;\n \n-\t    fn = instantiate_type (type_referred_to, fns, 0);\n+\t    fn = instantiate_type (type_referred_to, fns, 1);\n+\n+\t    if (fn == error_mark_node)\n+\t      return error_mark_node;\n \n \t    if (!TREE_PUBLIC (fn))\n \t      {\n+#if 0\n \t\tif (really_overloaded_fn (fns))\n \t\t  /* Don't issue an error here; we might get a different\n \t\t     function if the overloading had worked out\n \t\t     differently.  */\n \t\t  return error_mark_node;\n \t\telse\n+#endif\n \t\t  goto bad_argument;\n \t      }\n \n-\t    if (fn == error_mark_node)\n-\t      return error_mark_node;\n-\n \t    my_friendly_assert (comptypes (type_referred_to, TREE_TYPE (fn), 1),\n \t\t\t\t0);\n \n@@ -2646,7 +2648,7 @@ convert_nontype_argument (type, expr)\n \tfns = TREE_OPERAND (expr, 0);\n \t\n \tfn = instantiate_type (TREE_TYPE (TREE_TYPE (type)), \n-\t\t\t       fns, 0);\n+\t\t\t       fns, 1);\n \t\n \tif (fn == error_mark_node)\n \t  return error_mark_node;"}, {"sha": "1e391ea79e1ac14acc074e41b39a24becc537a7b", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 98, "deletions": 227, "changes": 325, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6e174e5609155eca637b5b14a3dd5cc407a415a/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6e174e5609155eca637b5b14a3dd5cc407a415a/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=e6e174e5609155eca637b5b14a3dd5cc407a415a", "patch": "@@ -206,32 +206,6 @@ fntype_p (t)\n \t\t  || TREE_CODE (TREE_TYPE (t)) == METHOD_TYPE)));\n }\n \n-/* Do `exp = require_instantiated_type (type, exp);' to make sure EXP\n-   does not have an uninstantiated type.\n-   TYPE is type to instantiate with, if uninstantiated.  */\n-\n-tree\n-require_instantiated_type (type, exp, errval)\n-     tree type, exp, errval;\n-{\n-  if (TREE_TYPE (exp) == NULL_TREE)\n-    {\n-      error (\"argument list may not have an initializer list\");\n-      return errval;\n-    }\n-\n-  if (TREE_CODE (exp) == OVERLOAD\n-      || TREE_TYPE (exp) == unknown_type_node\n-      || (TREE_CODE (TREE_TYPE (exp)) == OFFSET_TYPE\n-\t  && TREE_TYPE (TREE_TYPE (exp)) == unknown_type_node))\n-    {\n-      exp = instantiate_type (type, exp, 1);\n-      if (TREE_TYPE (exp) == error_mark_node)\n-\treturn errval;\n-    }\n-  return exp;\n-}\n-\n /* Return a variant of TYPE which has all the type qualifiers of LIKE\n    as well as those of TYPE.  */\n \n@@ -1690,13 +1664,13 @@ decay_conversion (exp)\n       error (\"void value not ignored as it ought to be\");\n       return error_mark_node;\n     }\n-  if (code == FUNCTION_TYPE)\n+  if (code == METHOD_TYPE)\n     {\n+      cp_pedwarn (\"assuming & on `%E'\", exp);\n       return build_unary_op (ADDR_EXPR, exp, 0);\n     }\n-  if (code == METHOD_TYPE)\n+  if (code == FUNCTION_TYPE || is_overloaded_fn (exp))\n     {\n-      cp_pedwarn (\"assuming & on `%E'\", exp);\n       return build_unary_op (ADDR_EXPR, exp, 0);\n     }\n   if (code == ARRAY_TYPE)\n@@ -3045,25 +3019,7 @@ convert_arguments (typelist, values, fndecl, flags)\n \t  break;\n \t}\n \n-      /* The tree type of the parameter being passed may not yet be\n-\t known.  In this case, its type is TYPE_UNKNOWN, and will\n-\t be instantiated by the type given by TYPE.  If TYPE\n-\t is also NULL, the tree type of VAL is ERROR_MARK_NODE.  */\n-      if (type && type_unknown_p (val))\n-\tval = require_instantiated_type (type, val, integer_zero_node);\n-      else if (type_unknown_p (val))\n-\t{\n-\t  /* Strip the `&' from an overloaded FUNCTION_DECL.  */\n-\t  if (TREE_CODE (val) == ADDR_EXPR)\n-\t    val = TREE_OPERAND (val, 0);\n-\t  if (really_overloaded_fn (val))\n-\t    cp_error (\"insufficient type information to resolve address of overloaded function `%D'\",\n-\t\t      DECL_NAME (get_first_fn (val)));\n-\t  else\n-\t    error (\"insufficient type information in parameter list\");\n-\t  val = integer_zero_node;\n-\t}\n-      else if (TREE_CODE (val) == OFFSET_REF)\n+      if (TREE_CODE (val) == OFFSET_REF)\n \tval = resolve_offset_ref (val);\n \n       /* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.\n@@ -3188,39 +3144,7 @@ build_binary_op (code, arg1, arg2, convert_p)\n      tree arg1, arg2;\n      int convert_p;\n {\n-  tree args[2];\n-\n-  args[0] = arg1;\n-  args[1] = arg2;\n-\n-  if (convert_p)\n-    {\n-      tree type0, type1;\n-      args[0] = decay_conversion (args[0]);\n-      args[1] = decay_conversion (args[1]);\n-\n-      if (args[0] == error_mark_node || args[1] == error_mark_node)\n-\treturn error_mark_node;\n-\n-      type0 = TREE_TYPE (args[0]);\n-      type1 = TREE_TYPE (args[1]);\n-\n-      if (type_unknown_p (args[0]))\n-\t{\n-\t  args[0] = instantiate_type (type1, args[0], 1);\n-\t  args[0] = decay_conversion (args[0]);\n-\t}\n-      else if (type_unknown_p (args[1]))\n-\t{\n-\t  args[1] = require_instantiated_type (type0, args[1],\n-\t\t\t\t\t       error_mark_node);\n-\t  args[1] = decay_conversion (args[1]);\n-\t}\n-\n-      if (IS_AGGR_TYPE (type0) || IS_AGGR_TYPE (type1))\n-\tmy_friendly_abort (754867);\n-    }\n-  return build_binary_op_nodefault (code, args[0], args[1], code);\n+  return build_binary_op_nodefault (code, arg1, arg2, code);\n }\n \n /* Build a binary-operation expression without default conversions.\n@@ -5026,13 +4950,6 @@ build_conditional_expr (ifexp, op1, op2)\n   if (TREE_CODE (ifexp) == ERROR_MARK)\n     return error_mark_node;\n \n-  op1 = require_instantiated_type (TREE_TYPE (op2), op1, error_mark_node);\n-  if (op1 == error_mark_node)\n-    return error_mark_node;\n-  op2 = require_instantiated_type (TREE_TYPE (op1), op2, error_mark_node);\n-  if (op2 == error_mark_node)\n-    return error_mark_node;\n-\n   /* C++: REFERENCE_TYPES must be dereferenced.  */\n   type1 = TREE_TYPE (op1);\n   code1 = TREE_CODE (type1);\n@@ -5229,6 +5146,10 @@ build_conditional_expr (ifexp, op1, op2)\n       pedwarn (\"pointer/integer type mismatch in conditional expression\");\n       result_type = type2;\n     }\n+  if (type2 == unknown_type_node)\n+    result_type = type1;\n+  else if (type1 == unknown_type_node)\n+    result_type = type2;\n \n   if (!result_type)\n     {\n@@ -5431,13 +5352,6 @@ build_static_cast (type, expr)\n   if (TREE_CODE (type) == VOID_TYPE)\n     return build1 (CONVERT_EXPR, type, expr);\n \n-  if (type_unknown_p (expr))\n-    {\n-      expr = instantiate_type (type, expr, 1);\n-      if (expr == error_mark_node)\n-\treturn error_mark_node;\n-    }\n-\n   if (TREE_CODE (type) == REFERENCE_TYPE)\n     return (convert_from_reference\n \t    (convert_to_reference (type, expr, CONV_STATIC|CONV_IMPLICIT,\n@@ -5521,13 +5435,6 @@ build_reinterpret_cast (type, expr)\n \texpr = TREE_OPERAND (expr, 0);\n     }\n \n-  if (type_unknown_p (expr))\n-    {\n-      expr = instantiate_type (type, expr, 1);\n-      if (expr == error_mark_node)\n-\treturn error_mark_node;\n-    }\n-\n   intype = TREE_TYPE (expr);\n \n   if (TREE_CODE (type) == REFERENCE_TYPE)\n@@ -5622,13 +5529,6 @@ build_const_cast (type, expr)\n \texpr = TREE_OPERAND (expr, 0);\n     }\n \n-  if (type_unknown_p (expr))\n-    {\n-      expr = instantiate_type (type, expr, 1);\n-      if (expr == error_mark_node)\n-\treturn error_mark_node;\n-    }\n-\n   intype = TREE_TYPE (expr);\n \n   if (comptypes (TYPE_MAIN_VARIANT (intype), TYPE_MAIN_VARIANT (type), 1))\n@@ -5667,6 +5567,7 @@ build_c_cast (type, expr)\n      tree type, expr;\n {\n   register tree value = expr;\n+  tree otype;\n \n   if (type == error_mark_node || expr == error_mark_node)\n     return error_mark_node;\n@@ -5721,109 +5622,94 @@ build_c_cast (type, expr)\n       return t;\n     }\n \n-  if (TREE_CODE (type) == VOID_TYPE)\n-    value = build1 (CONVERT_EXPR, type, value);\n-  else if (TREE_TYPE (value) == NULL_TREE\n-\t   || type_unknown_p (value))\n-    {\n-      value = instantiate_type (type, value, 1);\n-      /* Did we lose?  */\n-      if (value == error_mark_node)\n-\treturn error_mark_node;\n-    }\n-  else\n-    {\n-      tree otype;\n-\n-      /* Convert functions and arrays to pointers and\n-\t convert references to their expanded types,\n-\t but don't convert any other types.  If, however, we are\n-\t casting to a class type, there's no reason to do this: the\n-\t cast will only succeed if there is a converting constructor,\n-\t and the default conversions will be done at that point.  In\n-\t fact, doing the default conversion here is actually harmful\n-\t in cases like this:\n-\n-\t     typedef int A[2];\n-             struct S { S(const A&); };\n-\n-         since we don't want the array-to-pointer conversion done.  */\n-      if (!IS_AGGR_TYPE (type))\n-\t{\n-\t  if (TREE_CODE (TREE_TYPE (value)) == FUNCTION_TYPE\n-\t      || (TREE_CODE (TREE_TYPE (value)) == METHOD_TYPE\n-\t\t  /* Don't do the default conversion if we want a\n-\t\t     pointer to a function.  */\n-\t\t  && ! (TREE_CODE (type) == POINTER_TYPE\n-\t\t\t&& TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE))\n-\t      || TREE_CODE (TREE_TYPE (value)) == ARRAY_TYPE\n-\t      || TREE_CODE (TREE_TYPE (value)) == REFERENCE_TYPE)\n-\t  value = default_conversion (value);\n-\t}\n-      else if (TREE_CODE (TREE_TYPE (value)) == REFERENCE_TYPE)\n-\t/* However, even for class types, we still need to strip away\n-\t   the reference type, since the call to convert_force below\n-\t   does not expect the input expression to be of reference\n-\t   type.  */\n-\tvalue = convert_from_reference (value);\n+  /* Convert functions and arrays to pointers and\n+     convert references to their expanded types,\n+     but don't convert any other types.  If, however, we are\n+     casting to a class type, there's no reason to do this: the\n+     cast will only succeed if there is a converting constructor,\n+     and the default conversions will be done at that point.  In\n+     fact, doing the default conversion here is actually harmful\n+     in cases like this:\n+\n+     typedef int A[2];\n+     struct S { S(const A&); };\n+\n+     since we don't want the array-to-pointer conversion done.  */\n+  if (!IS_AGGR_TYPE (type))\n+    {\n+      if (TREE_CODE (TREE_TYPE (value)) == FUNCTION_TYPE\n+\t  || (TREE_CODE (TREE_TYPE (value)) == METHOD_TYPE\n+\t      /* Don't do the default conversion if we want a\n+\t\t pointer to a function.  */\n+\t      && ! (TREE_CODE (type) == POINTER_TYPE\n+\t\t    && TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE))\n+\t  || TREE_CODE (TREE_TYPE (value)) == ARRAY_TYPE\n+\t  || TREE_CODE (TREE_TYPE (value)) == REFERENCE_TYPE)\n+\tvalue = default_conversion (value);\n+    }\n+  else if (TREE_CODE (TREE_TYPE (value)) == REFERENCE_TYPE)\n+    /* However, even for class types, we still need to strip away\n+       the reference type, since the call to convert_force below\n+       does not expect the input expression to be of reference\n+       type.  */\n+    value = convert_from_reference (value);\n \t\n-      otype = TREE_TYPE (value);\n-\n-      /* Optionally warn about potentially worrisome casts.  */\n-\n-      if (warn_cast_qual\n-\t  && TREE_CODE (type) == POINTER_TYPE\n-\t  && TREE_CODE (otype) == POINTER_TYPE\n-\t  && !at_least_as_qualified_p (TREE_TYPE (type),\n-\t\t\t\t       TREE_TYPE (otype)))\n-\tcp_warning (\"cast discards qualifiers from pointer target type\");\n-\n-      /* Warn about possible alignment problems.  */\n-      if (STRICT_ALIGNMENT && warn_cast_align\n-\t  && TREE_CODE (type) == POINTER_TYPE\n-\t  && TREE_CODE (otype) == POINTER_TYPE\n-\t  && TREE_CODE (TREE_TYPE (otype)) != VOID_TYPE\n-\t  && TREE_CODE (TREE_TYPE (otype)) != FUNCTION_TYPE\n-\t  && TYPE_ALIGN (TREE_TYPE (type)) > TYPE_ALIGN (TREE_TYPE (otype)))\n-\twarning (\"cast increases required alignment of target type\");\n+  otype = TREE_TYPE (value);\n+\n+  /* Optionally warn about potentially worrisome casts.  */\n+\n+  if (warn_cast_qual\n+      && TREE_CODE (type) == POINTER_TYPE\n+      && TREE_CODE (otype) == POINTER_TYPE\n+      && !at_least_as_qualified_p (TREE_TYPE (type),\n+\t\t\t\t   TREE_TYPE (otype)))\n+    cp_warning (\"cast discards qualifiers from pointer target type\");\n+\n+  /* Warn about possible alignment problems.  */\n+  if (STRICT_ALIGNMENT && warn_cast_align\n+      && TREE_CODE (type) == POINTER_TYPE\n+      && TREE_CODE (otype) == POINTER_TYPE\n+      && TREE_CODE (TREE_TYPE (otype)) != VOID_TYPE\n+      && TREE_CODE (TREE_TYPE (otype)) != FUNCTION_TYPE\n+      && TYPE_ALIGN (TREE_TYPE (type)) > TYPE_ALIGN (TREE_TYPE (otype)))\n+    warning (\"cast increases required alignment of target type\");\n \n #if 0\n-      /* We should see about re-enabling these, they seem useful to\n-         me.  */\n-      if (TREE_CODE (type) == INTEGER_TYPE\n-\t  && TREE_CODE (otype) == POINTER_TYPE\n-\t  && TYPE_PRECISION (type) != TYPE_PRECISION (otype))\n-\twarning (\"cast from pointer to integer of different size\");\n-\n-      if (TREE_CODE (type) == POINTER_TYPE\n-\t  && TREE_CODE (otype) == INTEGER_TYPE\n-\t  && TYPE_PRECISION (type) != TYPE_PRECISION (otype)\n-\t  /* Don't warn about converting 0 to pointer,\n-\t     provided the 0 was explicit--not cast or made by folding.  */\n-\t  && !(TREE_CODE (value) == INTEGER_CST && integer_zerop (value)))\n-\twarning (\"cast to pointer from integer of different size\");\n+  /* We should see about re-enabling these, they seem useful to\n+     me.  */\n+  if (TREE_CODE (type) == INTEGER_TYPE\n+      && TREE_CODE (otype) == POINTER_TYPE\n+      && TYPE_PRECISION (type) != TYPE_PRECISION (otype))\n+    warning (\"cast from pointer to integer of different size\");\n+\n+  if (TREE_CODE (type) == POINTER_TYPE\n+      && TREE_CODE (otype) == INTEGER_TYPE\n+      && TYPE_PRECISION (type) != TYPE_PRECISION (otype)\n+      /* Don't warn about converting 0 to pointer,\n+\t provided the 0 was explicit--not cast or made by folding.  */\n+      && !(TREE_CODE (value) == INTEGER_CST && integer_zerop (value)))\n+    warning (\"cast to pointer from integer of different size\");\n #endif\n \n-      if (TREE_CODE (type) == REFERENCE_TYPE)\n-\tvalue = (convert_from_reference\n-\t\t (convert_to_reference (type, value, CONV_C_CAST,\n-\t\t\t\t\tLOOKUP_COMPLAIN, NULL_TREE)));\n-      else\n-\t{\n-\t  tree ovalue;\n+  if (TREE_CODE (type) == REFERENCE_TYPE)\n+    value = (convert_from_reference\n+\t     (convert_to_reference (type, value, CONV_C_CAST,\n+\t\t\t\t    LOOKUP_COMPLAIN, NULL_TREE)));\n+  else\n+    {\n+      tree ovalue;\n \n-\t  if (TREE_READONLY_DECL_P (value))\n-\t    value = decl_constant_value (value);\n+      if (TREE_READONLY_DECL_P (value))\n+\tvalue = decl_constant_value (value);\n \n-\t  ovalue = value;\n-\t  value = convert_force (type, value, CONV_C_CAST);\n+      ovalue = value;\n+      value = convert_force (type, value, CONV_C_CAST);\n \n-\t  /* Ignore any integer overflow caused by the cast.  */\n-\t  if (TREE_CODE (value) == INTEGER_CST)\n-\t    {\n-\t      TREE_OVERFLOW (value) = TREE_OVERFLOW (ovalue);\n-\t      TREE_CONSTANT_OVERFLOW (value) = TREE_CONSTANT_OVERFLOW (ovalue);\n-\t    }\n+      /* Ignore any integer overflow caused by the cast.  */\n+      if (TREE_CODE (value) == INTEGER_CST)\n+\t{\n+\t  TREE_OVERFLOW (value) = TREE_OVERFLOW (ovalue);\n+\t  TREE_CONSTANT_OVERFLOW (value) = TREE_CONSTANT_OVERFLOW (ovalue);\n \t}\n     }\n \n@@ -6107,14 +5993,6 @@ build_modify_expr (lhs, modifycode, rhs)\n       current_function_just_assigned_this = 1;\n     }\n \n-  /* The TREE_TYPE of RHS may be TYPE_UNKNOWN.  This can happen\n-     when the type of RHS is not yet known, i.e. its type\n-     is inherited from LHS.  */\n-  rhs = require_instantiated_type (lhstype, newrhs, error_mark_node);\n-  if (rhs == error_mark_node)\n-    return error_mark_node;\n-  newrhs = rhs;\n-\n   if (modifycode != INIT_EXPR)\n     {\n       /* Make modifycode now either a NOP_EXPR or an INIT_EXPR.  */\n@@ -6529,9 +6407,7 @@ build_ptrmemfunc (type, pfn, force)\n \t\t\t\tpfn, NULL_TREE);\n     }\n \n-  if (TREE_CODE (pfn) == TREE_LIST\n-      || (TREE_CODE (pfn) == ADDR_EXPR\n-\t  && TREE_CODE (TREE_OPERAND (pfn, 0)) == TREE_LIST))\n+  if (type_unknown_p (pfn))\n     return instantiate_type (type, pfn, 1);\n \n   if (!force \n@@ -6608,9 +6484,6 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n   if (ARITHMETIC_TYPE_P (type) && rhs == null_node)\n     cp_warning (\"converting NULL to non-pointer type\");\n \n-  if (coder == UNKNOWN_TYPE)\n-    rhs = instantiate_type (type, rhs, 1);\n-\n   if (coder == ERROR_MARK)\n     return error_mark_node;\n \n@@ -6640,12 +6513,17 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n     }\n \n   if (TREE_CODE (TREE_TYPE (rhs)) == ARRAY_TYPE\n-      || TREE_CODE (TREE_TYPE (rhs)) == FUNCTION_TYPE\n-      || TREE_CODE (TREE_TYPE (rhs)) == METHOD_TYPE)\n+      || is_overloaded_fn (rhs))\n     rhs = default_conversion (rhs);\n   else if (TREE_CODE (TREE_TYPE (rhs)) == REFERENCE_TYPE)\n     rhs = convert_from_reference (rhs);\n \n+  /* If rhs is some sort of overloaded function, ocp_convert will either\n+     do the right thing or complain; we don't need to check anything else.\n+     So just hand off.  */\n+  if (type_unknown_p (rhs))\n+    return ocp_convert (type, rhs, CONV_IMPLICIT, LOOKUP_NORMAL);\n+\n   rhstype = TREE_TYPE (rhs);\n   coder = TREE_CODE (rhstype);\n \n@@ -7067,13 +6945,6 @@ convert_for_initialization (exp, type, rhs, flags, errtype, fndecl, parmnum)\n   rhstype = TREE_TYPE (rhs);\n   coder = TREE_CODE (rhstype);\n \n-  if (coder == UNKNOWN_TYPE)\n-    {\n-      rhs = instantiate_type (type, rhs, 1);\n-      rhstype = TREE_TYPE (rhs);\n-      coder = TREE_CODE (rhstype);\n-    }\n-\n   if (coder == ERROR_MARK)\n     return error_mark_node;\n "}, {"sha": "c88082001faf32b91752df69ff0ca39a6ed27956", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6e174e5609155eca637b5b14a3dd5cc407a415a/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6e174e5609155eca637b5b14a3dd5cc407a415a/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=e6e174e5609155eca637b5b14a3dd5cc407a415a", "patch": "@@ -646,13 +646,6 @@ store_init_value (decl, init)\n \t  else\n \t    init = TREE_VALUE (init);\n \t}\n-      else if (TREE_TYPE (init) != 0\n-\t       && TREE_CODE (TREE_TYPE (init)) == OFFSET_TYPE)\n-\t{\n-\t  /* Use the type of our variable to instantiate\n-\t     the type of our initializer.  */\n-\t  init = instantiate_type (type, init, 1);\n-\t}\n       else if (TREE_CODE (init) == TREE_LIST\n \t       && TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE)\n \t{"}]}