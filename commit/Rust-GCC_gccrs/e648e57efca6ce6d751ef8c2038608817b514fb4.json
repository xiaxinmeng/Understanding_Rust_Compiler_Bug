{"sha": "e648e57efca6ce6d751ef8c2038608817b514fb4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTY0OGU1N2VmY2E2Y2U2ZDc1MWVmOGMyMDM4NjA4ODE3YjUxNGZiNA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-01-18T12:41:48Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-01-27T10:53:35Z"}, "message": "lra: Stop registers being incorrectly marked live [PR92989]\n\nlra_assign has an assert to make sure that no pseudo is allocated\nto a conflicting hard register.  It used to be restricted to\n!flag_ipa_ra, but in g:a1e6ee38e708ef2bdef4 I'd enabled it for\nflag_ipa_ra too.  It then tripped while building libstdc++\nfor mips-mti-linux.\n\nThe failure was due to code at the end of process_bb_lives.  For an\nabnormal/EH edge, we need to make sure that all pseudos that are live\non entry to the destination conflict with all hard registers that are\nclobbered by an abnormal call return.  The usual way to do this would\nbe to simulate a clobber of the hard registers, by making them live and\nthem making them dead again.  Making the registers live creates the\nconflict; making them dead again restores the correct live set for\nwhatever follows.\n\nHowever, process_bb_lives skips the second step (making the registers\ndead again) at the start of a BB, presumably on the basis that there's\nno further code that needs a correct live set.  The problem for the PR\nis that that wasn't quite true in practice.  There was code further\ndown process_bb_lives that updated the live-in set of the BB for some\nregisters, and this live set was \"contaminated\" by registers that\nweren't live but that created conflicts.  This information then got\npropagated to other blocks, so that registers that were made live\npurely to create a conflict at the start of the EH receiver then became\nneedlessly live throughout preceding blocks.  This in turn created a\nfake conflict with pseudos in those blocks, invalidating the choices\nmade by IRA.\n\nThe easiest fix seems to be to update the live-in set *before* adding\nthe fake live registers.  An alternative would be to simulate the full\nclobber, but that seems a bit wasteful.\n\n2020-01-27  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\tPR rtl-optimization/92989\n\t* lra-lives.c (process_bb_lives): Update the live-in set before\n\tprocessing additional clobbers.", "tree": {"sha": "ff7b9ee6a3e7cf26d5e69879b49944a56cc9c99f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff7b9ee6a3e7cf26d5e69879b49944a56cc9c99f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e648e57efca6ce6d751ef8c2038608817b514fb4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e648e57efca6ce6d751ef8c2038608817b514fb4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e648e57efca6ce6d751ef8c2038608817b514fb4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e648e57efca6ce6d751ef8c2038608817b514fb4/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "150760dd6dd1899705790183d646fa5fc004554e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/150760dd6dd1899705790183d646fa5fc004554e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/150760dd6dd1899705790183d646fa5fc004554e"}], "stats": {"total": 102, "additions": 57, "deletions": 45}, "files": [{"sha": "91dfcd71a4b213de59d5153ec53e664eac3c900c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e648e57efca6ce6d751ef8c2038608817b514fb4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e648e57efca6ce6d751ef8c2038608817b514fb4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e648e57efca6ce6d751ef8c2038608817b514fb4", "patch": "@@ -1,3 +1,9 @@\n+2020-01-27  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\tPR rtl-optimization/92989\n+\t* lra-lives.c (process_bb_lives): Update the live-in set before\n+\tprocessing additional clobbers.\n+\n 2020-01-27  Richard Sandiford  <richard.sandiford@arm.com>\n \n \tPR rtl-optimization/93170"}, {"sha": "f439e8993957c45384abe73b7c47e9ec8e8ed219", "filename": "gcc/lra-lives.c", "status": "modified", "additions": 51, "deletions": 45, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e648e57efca6ce6d751ef8c2038608817b514fb4/gcc%2Flra-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e648e57efca6ce6d751ef8c2038608817b514fb4/gcc%2Flra-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-lives.c?ref=e648e57efca6ce6d751ef8c2038608817b514fb4", "patch": "@@ -1023,6 +1023,57 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n \tmake_hard_regno_live (regno);\n       }\n \n+  bool live_change_p = false;\n+  /* Check if bb border live info was changed.  */\n+  unsigned int live_pseudos_num = 0;\n+  EXECUTE_IF_SET_IN_BITMAP (df_get_live_in (bb),\n+\t\t\t    FIRST_PSEUDO_REGISTER, j, bi)\n+    {\n+      live_pseudos_num++;\n+      if (! sparseset_bit_p (pseudos_live, j))\n+\t{\n+\t  live_change_p = true;\n+\t  if (lra_dump_file != NULL)\n+\t    fprintf (lra_dump_file,\n+\t\t     \"  r%d is removed as live at bb%d start\\n\", j, bb->index);\n+\t  break;\n+\t}\n+    }\n+  if (! live_change_p\n+      && sparseset_cardinality (pseudos_live) != live_pseudos_num)\n+    {\n+      live_change_p = true;\n+      if (lra_dump_file != NULL)\n+\tEXECUTE_IF_SET_IN_SPARSESET (pseudos_live, j)\n+\t  if (! bitmap_bit_p (df_get_live_in (bb), j))\n+\t    fprintf (lra_dump_file,\n+\t\t     \"  r%d is added to live at bb%d start\\n\", j, bb->index);\n+    }\n+\n+  /* The order of this code and the code below is important.  At this\n+     point hard_regs_live does genuinely contain only live registers.\n+     Below we pretend other hard registers are live in order to create\n+     conflicts with pseudos, but this fake live set shouldn't leak out\n+     into the df info.  */\n+  for (i = 0; HARD_REGISTER_NUM_P (i); ++i)\n+    {\n+      if (!TEST_HARD_REG_BIT (hard_regs_live, i))\n+\tcontinue;\n+\n+      if (!TEST_HARD_REG_BIT (hard_regs_spilled_into, i))\n+\tcontinue;\n+\n+      if (bitmap_bit_p (df_get_live_in (bb), i))\n+\tcontinue;\n+\n+      live_change_p = true;\n+      if (lra_dump_file)\n+\tfprintf (lra_dump_file,\n+\t\t \"  hard reg r%d is added to live at bb%d start\\n\", i,\n+\t\t bb->index);\n+      bitmap_set_bit (df_get_live_in (bb), i);\n+    }\n+\n   /* Pseudos can't go in stack regs at the start of a basic block that\n      is reached by an abnormal edge.  Likewise for registers that are at\n      least partly call clobbered, because caller-save, fixup_abnormal_edges\n@@ -1057,32 +1108,6 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n \t    make_hard_regno_live (px);\n     }\n \n-  bool live_change_p = false;\n-  /* Check if bb border live info was changed.  */\n-  unsigned int live_pseudos_num = 0;\n-  EXECUTE_IF_SET_IN_BITMAP (df_get_live_in (bb),\n-\t\t\t    FIRST_PSEUDO_REGISTER, j, bi)\n-    {\n-      live_pseudos_num++;\n-      if (! sparseset_bit_p (pseudos_live, j))\n-\t{\n-\t  live_change_p = true;\n-\t  if (lra_dump_file != NULL)\n-\t    fprintf (lra_dump_file,\n-\t\t     \"  r%d is removed as live at bb%d start\\n\", j, bb->index);\n-\t  break;\n-\t}\n-    }\n-  if (! live_change_p\n-      && sparseset_cardinality (pseudos_live) != live_pseudos_num)\n-    {\n-      live_change_p = true;\n-      if (lra_dump_file != NULL)\n-\tEXECUTE_IF_SET_IN_SPARSESET (pseudos_live, j)\n-\t  if (! bitmap_bit_p (df_get_live_in (bb), j))\n-\t    fprintf (lra_dump_file,\n-\t\t     \"  r%d is added to live at bb%d start\\n\", j, bb->index);\n-    }\n   /* See if we'll need an increment at the end of this basic block.\n      An increment is needed if the PSEUDOS_LIVE set is not empty,\n      to make sure the finish points are set up correctly.  */\n@@ -1102,25 +1127,6 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n \tcheck_pseudos_live_through_calls (j, last_call_abi);\n     }\n \n-  for (i = 0; HARD_REGISTER_NUM_P (i); ++i)\n-    {\n-      if (!TEST_HARD_REG_BIT (hard_regs_live, i))\n-\tcontinue;\n-\n-      if (!TEST_HARD_REG_BIT (hard_regs_spilled_into, i))\n-\tcontinue;\n-\n-      if (bitmap_bit_p (df_get_live_in (bb), i))\n-\tcontinue;\n-\n-      live_change_p = true;\n-      if (lra_dump_file)\n-\tfprintf (lra_dump_file,\n-\t\t \"  hard reg r%d is added to live at bb%d start\\n\", i,\n-\t\t bb->index);\n-      bitmap_set_bit (df_get_live_in (bb), i);\n-    }\n-\n   if (need_curr_point_incr)\n     next_program_point (curr_point, freq);\n "}]}