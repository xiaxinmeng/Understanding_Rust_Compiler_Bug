{"sha": "37da591f6ad57e549e0f010836b5d26d673a2860", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzdkYTU5MWY2YWQ1N2U1NDllMGYwMTA4MzZiNWQyNmQ2NzNhMjg2MA==", "commit": {"author": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2012-02-02T23:10:55Z"}, "committer": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2012-02-02T23:10:55Z"}, "message": "re PR fortran/41587 ([OOP] ICE with ALLOCATABLE CLASS components)\n\n2012-02-02  Mikael Morin  <mikael@gcc.gnu.org>\n\n\tPR fortran/41587\n\tPR fortran/46356\n\tPR fortran/51754\n\tPR fortran/50981\n\t* class.c (insert_component_ref, class_data_ref_missing,\n\tgfc_fix_class_refs): New functions.\n\t* gfortran.h (gfc_fix_class_refs): New prototype.\n\t* trans-expr.c (gfc_conv_expr): Remove special case handling and call\n\tgfc_fix_class_refs instead.\n\n2012-02-02  Mikael Morin  <mikael@gcc.gnu.org>\n\n\tPR fortran/41587\n\t* gfortran.dg/class_array_10.f03: New test.\n\n\tPR fortran/46356\n\t* gfortran.dg/class_array_11.f03: New test.\n\n\tPR fortran/51754\n\t* gfortran.dg/class_array_12.f03: New test.\n\nFrom-SVN: r183853", "tree": {"sha": "f25ee1669f956ef1cf3aa31c4b85c34886f33c7b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f25ee1669f956ef1cf3aa31c4b85c34886f33c7b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/37da591f6ad57e549e0f010836b5d26d673a2860", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37da591f6ad57e549e0f010836b5d26d673a2860", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37da591f6ad57e549e0f010836b5d26d673a2860", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37da591f6ad57e549e0f010836b5d26d673a2860/comments", "author": null, "committer": null, "parents": [{"sha": "1c69e5e28ad0829ba71198317bd4771f643e337d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c69e5e28ad0829ba71198317bd4771f643e337d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c69e5e28ad0829ba71198317bd4771f643e337d"}], "stats": {"total": 230, "additions": 224, "deletions": 6}, "files": [{"sha": "db369ab0feb701146b71925b01c8ff357a9ba711", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37da591f6ad57e549e0f010836b5d26d673a2860/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37da591f6ad57e549e0f010836b5d26d673a2860/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=37da591f6ad57e549e0f010836b5d26d673a2860", "patch": "@@ -1,3 +1,15 @@\n+2012-02-02  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\tPR fortran/41587\n+\tPR fortran/46356\n+\tPR fortran/51754\n+\tPR fortran/50981\n+\t* class.c (insert_component_ref, class_data_ref_missing,\n+\tgfc_fix_class_refs): New functions.\n+\t* gfortran.h (gfc_fix_class_refs): New prototype.\n+\t* trans-expr.c (gfc_conv_expr): Remove special case handling and call\n+\tgfc_fix_class_refs instead.\n+\n 2012-02-02  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/52012\n@@ -22,7 +34,7 @@\n \t(mio_typebound_proc): Read/write is_operator from/to the\n \t.mod file.\n \n-2012-02-01  Tobias Burnus\n+2012-02-01  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/52059\n \t* trans-expr.c (gfc_conv_procedure_call): Add array ref"}, {"sha": "bfa8740288a6d6c3731fdb7c144302b83e0e53b4", "filename": "gcc/fortran/class.c", "status": "modified", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37da591f6ad57e549e0f010836b5d26d673a2860/gcc%2Ffortran%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37da591f6ad57e549e0f010836b5d26d673a2860/gcc%2Ffortran%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fclass.c?ref=37da591f6ad57e549e0f010836b5d26d673a2860", "patch": "@@ -52,6 +52,129 @@ along with GCC; see the file COPYING3.  If not see\n #include \"constructor.h\"\n \n \n+/* Inserts a derived type component reference in a data reference chain.\n+    TS: base type of the ref chain so far, in which we will pick the component\n+    REF: the address of the GFC_REF pointer to update\n+    NAME: name of the component to insert\n+   Note that component insertion makes sense only if we are at the end of\n+   the chain (*REF == NULL) or if we are adding a missing \"_data\" component\n+   to access the actual contents of a class object.  */\n+\n+static void\n+insert_component_ref (gfc_typespec *ts, gfc_ref **ref, const char * const name)\n+{\n+  gfc_symbol *type_sym;\n+  gfc_ref *new_ref;\n+\n+  gcc_assert (ts->type == BT_DERIVED || ts->type == BT_CLASS);\n+  type_sym = ts->u.derived;\n+\n+  new_ref = gfc_get_ref ();\n+  new_ref->type = REF_COMPONENT;\n+  new_ref->next = *ref;\n+  new_ref->u.c.sym = type_sym;\n+  new_ref->u.c.component = gfc_find_component (type_sym, name, true, true);\n+  gcc_assert (new_ref->u.c.component);\n+\n+  if (new_ref->next)\n+    {\n+      gfc_ref *next = NULL;\n+\n+      /* We need to update the base type in the trailing reference chain to\n+\t that of the new component.  */\n+\n+      gcc_assert (strcmp (name, \"_data\") == 0);\n+\n+      if (new_ref->next->type == REF_COMPONENT)\n+\tnext = new_ref->next;\n+      else if (new_ref->next->type == REF_ARRAY\n+\t       && new_ref->next->next\n+\t       && new_ref->next->next->type == REF_COMPONENT)\n+\tnext = new_ref->next->next;\n+\n+      if (next != NULL)\n+\t{\n+\t  gcc_assert (new_ref->u.c.component->ts.type == BT_CLASS\n+\t\t      || new_ref->u.c.component->ts.type == BT_DERIVED);\n+\t  next->u.c.sym = new_ref->u.c.component->ts.u.derived;\n+\t}\n+    }\n+\n+  *ref = new_ref;\n+}\n+\n+\n+/* Tells whether we need to add a \"_data\" reference to access REF subobject\n+   from an object of type TS.  If FIRST_REF_IN_CHAIN is set, then the base\n+   object accessed by REF is a variable; in other words it is a full object,\n+   not a subobject.  */\n+\n+static bool\n+class_data_ref_missing (gfc_typespec *ts, gfc_ref *ref, bool first_ref_in_chain)\n+{\n+  /* Only class containers may need the \"_data\" reference.  */\n+  if (ts->type != BT_CLASS)\n+    return false;\n+\n+  /* Accessing a class container with an array reference is certainly wrong.  */\n+  if (ref->type != REF_COMPONENT)\n+    return true;\n+\n+  /* Accessing the class container's fields is fine.  */\n+  if (ref->u.c.component->name[0] == '_')\n+    return false;\n+\n+  /* At this point we have a class container with a non class container's field\n+     component reference.  We don't want to add the \"_data\" component if we are\n+     at the first reference and the symbol's type is an extended derived type.\n+     In that case, conv_parent_component_references will do the right thing so\n+     it is not absolutely necessary.  Omitting it prevents a regression (see\n+     class_41.f03) in the interface mapping mechanism.  When evaluating string\n+     lengths depending on dummy arguments, we create a fake symbol with a type\n+     equal to that of the dummy type.  However, because of type extension,\n+     the backend type (corresponding to the actual argument) can have a\n+     different (extended) type.  Adding the \"_data\" component explicitly, using\n+     the base type, confuses the gfc_conv_component_ref code which deals with\n+     the extended type.  */\n+  if (first_ref_in_chain && ts->u.derived->attr.extension)\n+    return false;\n+\n+  /* We have a class container with a non class container's field component\n+     reference that doesn't fall into the above.  */\n+  return true;\n+}\n+\n+\n+/* Browse through a data reference chain and add the missing \"_data\" references\n+   when a subobject of a class object is accessed without it.\n+   Note that it doesn't add the \"_data\" reference when the class container\n+   is the last element in the reference chain.  */\n+\n+void\n+gfc_fix_class_refs (gfc_expr *e)\n+{\n+  gfc_typespec *ts;\n+  gfc_ref **ref;\n+\n+  if ((e->expr_type != EXPR_VARIABLE\n+       && e->expr_type != EXPR_FUNCTION)\n+      || (e->expr_type == EXPR_FUNCTION\n+\t  && e->value.function.isym != NULL))\n+    return;\n+\n+  ts = &e->symtree->n.sym->ts;\n+\n+  for (ref = &e->ref; *ref != NULL; ref = &(*ref)->next)\n+    {\n+      if (class_data_ref_missing (ts, *ref, ref == &e->ref))\n+\tinsert_component_ref (ts, ref, \"_data\");\n+\n+      if ((*ref)->type == REF_COMPONENT)\n+\tts = &(*ref)->u.c.component->ts;\n+    }\n+}\n+\n+\n /* Insert a reference to the component of the given name.\n    Only to be used with CLASS containers and vtables.  */\n "}, {"sha": "a5edd1306ad40c0a2a30699fd44ad4d3ad11ac69", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37da591f6ad57e549e0f010836b5d26d673a2860/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37da591f6ad57e549e0f010836b5d26d673a2860/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=37da591f6ad57e549e0f010836b5d26d673a2860", "patch": "@@ -2919,6 +2919,7 @@ gfc_try gfc_calculate_transfer_sizes (gfc_expr*, gfc_expr*, gfc_expr*,\n \t\t\t\t      size_t*, size_t*, size_t*);\n \n /* class.c */\n+void gfc_fix_class_refs (gfc_expr *e);\n void gfc_add_component_ref (gfc_expr *, const char *);\n void gfc_add_class_array_ref (gfc_expr *);\n #define gfc_add_data_component(e)     gfc_add_component_ref(e,\"_data\")"}, {"sha": "608e85fa32db70bd9dc784506b6aa8796fd73bc2", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37da591f6ad57e549e0f010836b5d26d673a2860/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37da591f6ad57e549e0f010836b5d26d673a2860/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=37da591f6ad57e549e0f010836b5d26d673a2860", "patch": "@@ -5486,10 +5486,7 @@ gfc_conv_expr (gfc_se * se, gfc_expr * expr)\n         }\n     }\n \n-  /* TODO: make this work for general class array expressions.  */\n-  if (expr->ts.type == BT_CLASS\n-\t&& expr->ref && expr->ref->type == REF_ARRAY)\n-    gfc_add_component_ref (expr, \"_data\");\n+  gfc_fix_class_refs (expr);\n \n   switch (expr->expr_type)\n     {"}, {"sha": "e47725a0681c2f1aa4ca6d1f26ae1db0f312ef16", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37da591f6ad57e549e0f010836b5d26d673a2860/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37da591f6ad57e549e0f010836b5d26d673a2860/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=37da591f6ad57e549e0f010836b5d26d673a2860", "patch": "@@ -1,3 +1,14 @@\n+2012-02-02  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\tPR fortran/41587\n+\t* gfortran.dg/class_array_10.f03: New test.\n+\n+\tPR fortran/46356\n+\t* gfortran.dg/class_array_11.f03: New test.\n+\n+\tPR fortran/51754\n+\t* gfortran.dg/class_array_12.f03: New test.\n+\n 2012-02-02  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/52012\n@@ -42,7 +53,7 @@\n \tPR fortran/52024\n \t* gfortran.dg/typebound_operator_14.f90: New.\n \n-2012-02-01  Tobias Burnus\n+2012-02-01  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/52059\n \t* gfortran.dg/elemental_function_1.f90: New."}, {"sha": "8ca8e0b59664d6556692e4d3c99329d3a6ca6519", "filename": "gcc/testsuite/gfortran.dg/class_array_10.f03", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37da591f6ad57e549e0f010836b5d26d673a2860/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_array_10.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37da591f6ad57e549e0f010836b5d26d673a2860/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_array_10.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_array_10.f03?ref=37da591f6ad57e549e0f010836b5d26d673a2860", "patch": "@@ -0,0 +1,18 @@\n+! { dg-do compile}\n+!\n+! PR fortran/41587\n+! This program was leading to an ICE related to class allocatable arrays\n+!\n+! Contributed by Dominique D'Humieres <dominiq@lps.ens.fr>\n+\n+type t0\n+  integer :: j = 42\n+end type t0\n+type t\n+  integer :: i\n+  class(t0), allocatable :: foo(:)\n+end type t\n+type(t) :: k\n+allocate(t0 :: k%foo(3))\n+print *, k%foo%j\n+end"}, {"sha": "6e1bdb07ebdee5e06cafb5cf70dd78a8929330b9", "filename": "gcc/testsuite/gfortran.dg/class_array_11.f03", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37da591f6ad57e549e0f010836b5d26d673a2860/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_array_11.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37da591f6ad57e549e0f010836b5d26d673a2860/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_array_11.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_array_11.f03?ref=37da591f6ad57e549e0f010836b5d26d673a2860", "patch": "@@ -0,0 +1,23 @@\n+! { dg-do compile }\n+!\n+! PR fortran/46356\n+! This program was leading to an ICE related to class arrays\n+!\n+! Original testcase by Ian Harvey <ian_harvey@bigpond.com>\n+! Reduced by Janus Weil <Janus@gcc.gnu.org>\n+\n+  IMPLICIT NONE\n+\n+  TYPE :: ParentVector\n+    INTEGER :: a\n+  END TYPE ParentVector  \n+\n+CONTAINS       \n+\n+  SUBROUTINE vector_operation(pvec)     \n+    CLASS(ParentVector), INTENT(INOUT) :: pvec(:)\n+    print *,pvec(1)%a\n+  END SUBROUTINE\n+\n+END\n+"}, {"sha": "2a1e440636ef3b94139738b332b322bb6920acac", "filename": "gcc/testsuite/gfortran.dg/class_array_12.f03", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37da591f6ad57e549e0f010836b5d26d673a2860/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_array_12.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37da591f6ad57e549e0f010836b5d26d673a2860/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_array_12.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_array_12.f03?ref=37da591f6ad57e549e0f010836b5d26d673a2860", "patch": "@@ -0,0 +1,33 @@\n+! { dg-do compile }\n+!\n+! PR fortran/51754\n+! This program was leading to an ICE related to class arrays\n+!\n+! Contributed by Andrew Benson <abenson@caltech.edu>\n+\n+module test\n+  private\n+\n+  type :: componentB\n+  end type componentB\n+\n+  type :: treeNode\n+     class(componentB), allocatable, dimension(:) :: componentB\n+  end type treeNode\n+\n+contains\n+\n+  function BGet(self)\n+    implicit none\n+    class(componentB), pointer :: BGet\n+    class(treeNode), target, intent(in) :: self\n+    select type (self)\n+    class is (treeNode)\n+       BGet => self%componentB(1)\n+    end select\n+    return\n+  end function BGet\n+\n+end module test\n+\n+! { dg-final { cleanup-modules \"test\" } }"}]}