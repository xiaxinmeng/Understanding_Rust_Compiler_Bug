{"sha": "c7b852c8a60d46ba79c50b9d2a4f3cba4847c896", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzdiODUyYzhhNjBkNDZiYTc5YzUwYjlkMmE0ZjNjYmE0ODQ3Yzg5Ng==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2007-04-09T06:51:43Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2007-04-09T06:51:43Z"}, "message": "cfgloopmanip.c (create_preheader): Do not use loop_preheader_edge.\n\n\t* cfgloopmanip.c (create_preheader): Do not use loop_preheader_edge.\n\t(create_preheaders): Check that loops are available.\n\t(fix_loop_structure): Clean up, improve comments.\n\t* tree-ssa-loop-manip.c (rewrite_into_loop_closed_ssa):\n\tCheck that loops are available.  Set LOOP_CLOSED_SSA to the loops\n\tstate flags.\n\t* tree-scalar-evolution.c (scev_finalize): Clear scalar_evolution_info.\n\t* predict.c (tree_estimate_probability): Do not call\n\tcalculate_dominance_info.  Call create_preheaders.\n\t* tree-cfgcleanup.c (cleanup_tree_cfg_loop): Only call\n\trewrite_into_loop_closed_ssa if LOOP_CLOSED_SSA is set in loops state\n\tflags.\n\t* cfgloop.c (loop_preheader_edge): Assert that loops have preheaders.\n\t* cfgloop.h (LOOP_CLOSED_SSA): New constant.\n\t* tree-cfg.c (tree_split_edge): Make an assert more precise.\n\t* tree-ssa-threadedge.c (thread_across_edge): Comment the function\n\targuments.\n\nFrom-SVN: r123670", "tree": {"sha": "f5af72013d20563b8340bcf3462e935b8ad07bef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f5af72013d20563b8340bcf3462e935b8ad07bef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c7b852c8a60d46ba79c50b9d2a4f3cba4847c896", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7b852c8a60d46ba79c50b9d2a4f3cba4847c896", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7b852c8a60d46ba79c50b9d2a4f3cba4847c896", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7b852c8a60d46ba79c50b9d2a4f3cba4847c896/comments", "author": null, "committer": null, "parents": [{"sha": "782c9150c34a05791f425af5af81c8198cf49176", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/782c9150c34a05791f425af5af81c8198cf49176", "html_url": "https://github.com/Rust-GCC/gccrs/commit/782c9150c34a05791f425af5af81c8198cf49176"}], "stats": {"total": 142, "additions": 109, "deletions": 33}, "files": [{"sha": "0309e9fa92fc9107aa5bb43bbf2628e0d576a88a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7b852c8a60d46ba79c50b9d2a4f3cba4847c896/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7b852c8a60d46ba79c50b9d2a4f3cba4847c896/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c7b852c8a60d46ba79c50b9d2a4f3cba4847c896", "patch": "@@ -1,3 +1,23 @@\n+2007-04-09  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\t* cfgloopmanip.c (create_preheader): Do not use loop_preheader_edge.\n+\t(create_preheaders): Check that loops are available.\n+\t(fix_loop_structure): Clean up, improve comments.\n+\t* tree-ssa-loop-manip.c (rewrite_into_loop_closed_ssa):\n+\tCheck that loops are available.  Set LOOP_CLOSED_SSA to the loops\n+\tstate flags.\n+\t* tree-scalar-evolution.c (scev_finalize): Clear scalar_evolution_info.\n+\t* predict.c (tree_estimate_probability): Do not call\n+\tcalculate_dominance_info.  Call create_preheaders.\n+\t* tree-cfgcleanup.c (cleanup_tree_cfg_loop): Only call\n+\trewrite_into_loop_closed_ssa if LOOP_CLOSED_SSA is set in loops state\n+\tflags.\n+\t* cfgloop.c (loop_preheader_edge): Assert that loops have preheaders.\n+\t* cfgloop.h (LOOP_CLOSED_SSA): New constant.\n+\t* tree-cfg.c (tree_split_edge): Make an assert more precise.\n+\t* tree-ssa-threadedge.c (thread_across_edge): Comment the function\n+\targuments.\n+\n 2007-04-08  Jan Hubicka  <jh@suse.cz>\n \n \t* tree.h (maybe_fold_offset_to_component_ref): Declare."}, {"sha": "b30e3527a6c46808ebc0a612e0015ff493e94f92", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7b852c8a60d46ba79c50b9d2a4f3cba4847c896/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7b852c8a60d46ba79c50b9d2a4f3cba4847c896/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=c7b852c8a60d46ba79c50b9d2a4f3cba4847c896", "patch": "@@ -1548,6 +1548,8 @@ loop_preheader_edge (const struct loop *loop)\n   edge e;\n   edge_iterator ei;\n \n+  gcc_assert ((current_loops->state & LOOPS_HAVE_PREHEADERS) != 0);\n+\n   FOR_EACH_EDGE (e, ei, loop->header->preds)\n     if (e->src != loop->latch)\n       break;"}, {"sha": "15d55890f6a10c6d69b2d91d9799369965f64715", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7b852c8a60d46ba79c50b9d2a4f3cba4847c896/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7b852c8a60d46ba79c50b9d2a4f3cba4847c896/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=c7b852c8a60d46ba79c50b9d2a4f3cba4847c896", "patch": "@@ -169,7 +169,8 @@ enum\n   LOOPS_HAVE_SIMPLE_LATCHES = 2,\n   LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS = 4,\n   LOOPS_HAVE_RECORDED_EXITS = 8,\n-  LOOPS_MAY_HAVE_MULTIPLE_LATCHES = 16\n+  LOOPS_MAY_HAVE_MULTIPLE_LATCHES = 16,\n+  LOOP_CLOSED_SSA = 32\n };\n \n #define LOOPS_NORMAL (LOOPS_HAVE_PREHEADERS | LOOPS_HAVE_SIMPLE_LATCHES \\"}, {"sha": "0e876e566e1ea0a824a68ad97969f5c0026abe79", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 54, "deletions": 25, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7b852c8a60d46ba79c50b9d2a4f3cba4847c896/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7b852c8a60d46ba79c50b9d2a4f3cba4847c896/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=c7b852c8a60d46ba79c50b9d2a4f3cba4847c896", "patch": "@@ -1105,7 +1105,7 @@ create_preheader (struct loop *loop, int flags)\n   int nentry = 0;\n   bool irred = false;\n   bool latch_edge_was_fallthru;\n-  edge one_succ_pred = 0;\n+  edge one_succ_pred = NULL, single_entry = NULL;\n   edge_iterator ei;\n \n   FOR_EACH_EDGE (e, ei, loop->header->preds)\n@@ -1114,21 +1114,20 @@ create_preheader (struct loop *loop, int flags)\n \tcontinue;\n       irred |= (e->flags & EDGE_IRREDUCIBLE_LOOP) != 0;\n       nentry++;\n+      single_entry = e;\n       if (single_succ_p (e->src))\n \tone_succ_pred = e;\n     }\n   gcc_assert (nentry);\n   if (nentry == 1)\n     {\n-      e = loop_preheader_edge (loop);\n-\n       if (/* We do not allow entry block to be the loop preheader, since we\n \t     cannot emit code there.  */\n-\t  e->src != ENTRY_BLOCK_PTR\n+\t  single_entry->src != ENTRY_BLOCK_PTR\n \t  /* If we want simple preheaders, also force the preheader to have\n \t     just a single successor.  */\n \t  && !((flags & CP_SIMPLE_PREHEADERS)\n-\t       && !single_succ_p (e->src)))\n+\t       && !single_succ_p (single_entry->src)))\n \treturn NULL;\n     }\n \n@@ -1177,6 +1176,9 @@ create_preheaders (int flags)\n   loop_iterator li;\n   struct loop *loop;\n \n+  if (!current_loops)\n+    return;\n+\n   FOR_EACH_LOOP (li, loop, 0)\n     create_preheader (loop, flags);\n   current_loops->state |= LOOPS_HAVE_PREHEADERS;\n@@ -1380,19 +1382,33 @@ fix_loop_structure (bitmap changed_bbs)\n   basic_block bb;\n   struct loop *loop, *ploop;\n   loop_iterator li;\n+  bool record_exits = false;\n+  struct loop **superloop = XNEWVEC (struct loop *, number_of_loops ());\n \n-  /* Remove the old bb -> loop mapping.  */\n+  gcc_assert (current_loops->state & LOOPS_HAVE_SIMPLE_LATCHES);\n+\n+  /* Remove the old bb -> loop mapping.  Remember the depth of the blocks in\n+     the loop hierarchy, so that we can recognize blocks whose loop nesting\n+     relationship has changed.  */\n   FOR_EACH_BB (bb)\n     {\n-      bb->aux = (void *) (size_t) bb->loop_father->depth;\n+      if (changed_bbs)\n+\tbb->aux = (void *) (size_t) bb->loop_father->depth;\n       bb->loop_father = current_loops->tree_root;\n     }\n \n-  /* Remove the dead loops from structures.  */\n-  current_loops->tree_root->num_nodes = n_basic_blocks;\n-  FOR_EACH_LOOP (li, loop, 0)\n+  if (current_loops->state & LOOPS_HAVE_RECORDED_EXITS)\n+    {\n+      release_recorded_exits ();\n+      record_exits = true;\n+    }\n+\n+  /* Remove the dead loops from structures.  We start from the innermost\n+     loops, so that when we remove the loops, we know that the loops inside\n+     are preserved, and do not waste time relinking loops that will be\n+     removed later.  */\n+  FOR_EACH_LOOP (li, loop, LI_FROM_INNERMOST)\n     {\n-      loop->num_nodes = 0;\n       if (loop->header)\n \tcontinue;\n \n@@ -1407,39 +1423,52 @@ fix_loop_structure (bitmap changed_bbs)\n       delete_loop (loop);\n     }\n \n-  /* Rescan the bodies of loops, starting from the outermost.  */\n+  /* Rescan the bodies of loops, starting from the outermost ones.  We assume\n+     that no optimization interchanges the order of the loops, i.e., it cannot\n+     happen that L1 was superloop of L2 before and it is subloop of L2 now\n+     (without explicitly updating loop information).  At the same time, we also\n+     determine the new loop structure.  */\n+  current_loops->tree_root->num_nodes = n_basic_blocks;\n   FOR_EACH_LOOP (li, loop, 0)\n     {\n+      superloop[loop->num] = loop->header->loop_father;\n       loop->num_nodes = flow_loop_nodes_find (loop->header, loop);\n     }\n \n   /* Now fix the loop nesting.  */\n   FOR_EACH_LOOP (li, loop, 0)\n     {\n-      bb = loop_preheader_edge (loop)->src;\n-      if (bb->loop_father != loop->outer)\n+      ploop = superloop[loop->num];\n+      if (ploop != loop->outer)\n \t{\n \t  flow_loop_tree_node_remove (loop);\n-\t  flow_loop_tree_node_add (bb->loop_father, loop);\n+\t  flow_loop_tree_node_add (ploop, loop);\n \t}\n     }\n+  free (superloop);\n \n   /* Mark the blocks whose loop has changed.  */\n-  FOR_EACH_BB (bb)\n+  if (changed_bbs)\n     {\n-      if (changed_bbs\n-\t  && (void *) (size_t) bb->loop_father->depth != bb->aux)\n-\tbitmap_set_bit (changed_bbs, bb->index);\n+      FOR_EACH_BB (bb)\n+\t{\n+\t  if ((void *) (size_t) bb->loop_father->depth != bb->aux)\n+\t    bitmap_set_bit (changed_bbs, bb->index);\n \n-      bb->aux = NULL;\n+    \t  bb->aux = NULL;\n+\t}\n     }\n \n+  if (current_loops->state & LOOPS_HAVE_PREHEADERS)\n+    create_preheaders (CP_SIMPLE_PREHEADERS);\n+\n   if (current_loops->state & LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS)\n     mark_irreducible_loops ();\n \n-  if (current_loops->state & LOOPS_HAVE_RECORDED_EXITS)\n-    {\n-      release_recorded_exits ();\n-      record_loop_exits ();\n-    }\n+  if (record_exits)\n+    record_loop_exits ();\n+\n+#ifdef ENABLE_CHECKING\n+  verify_loop_structure ();\n+#endif\n }"}, {"sha": "7cae1b720ed3aa496da05b7c0f2020d8bf73a69e", "filename": "gcc/predict.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7b852c8a60d46ba79c50b9d2a4f3cba4847c896/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7b852c8a60d46ba79c50b9d2a4f3cba4847c896/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=c7b852c8a60d46ba79c50b9d2a4f3cba4847c896", "patch": "@@ -1290,7 +1290,9 @@ tree_estimate_probability (void)\n \n   add_noreturn_fake_exit_edges ();\n   connect_infinite_loops_to_exit ();\n-  calculate_dominance_info (CDI_DOMINATORS);\n+  /* We use loop_niter_by_eval, which requires that the loops have\n+     preheaders.  */\n+  create_preheaders (CP_SIMPLE_PREHEADERS);\n   calculate_dominance_info (CDI_POST_DOMINATORS);\n \n   tree_bb_level_predictions ();"}, {"sha": "a0af80442e8f30fb7b3118029cc0d2f10c540802", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7b852c8a60d46ba79c50b9d2a4f3cba4847c896/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7b852c8a60d46ba79c50b9d2a4f3cba4847c896/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=c7b852c8a60d46ba79c50b9d2a4f3cba4847c896", "patch": "@@ -3118,7 +3118,7 @@ tree_split_edge (edge edge_in)\n   new_edge->count = edge_in->count;\n \n   e = redirect_edge_and_branch (edge_in, new_bb);\n-  gcc_assert (e);\n+  gcc_assert (e == edge_in);\n   reinstall_phi_args (new_edge, e);\n \n   return new_bb;"}, {"sha": "39dcfe7c3abf1caffa65badd75cf32e46a4dde26", "filename": "gcc/tree-cfgcleanup.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7b852c8a60d46ba79c50b9d2a4f3cba4847c896/gcc%2Ftree-cfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7b852c8a60d46ba79c50b9d2a4f3cba4847c896/gcc%2Ftree-cfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfgcleanup.c?ref=c7b852c8a60d46ba79c50b9d2a4f3cba4847c896", "patch": "@@ -599,7 +599,7 @@ cleanup_tree_cfg_loop (void)\n {\n   bool changed = cleanup_tree_cfg ();\n \n-  if (changed)\n+  if (changed && current_loops != NULL)\n     {\n       bitmap changed_bbs = BITMAP_ALLOC (NULL);\n       calculate_dominance_info (CDI_DOMINATORS);\n@@ -608,7 +608,8 @@ cleanup_tree_cfg_loop (void)\n       /* This usually does nothing.  But sometimes parts of cfg that originally\n \t were inside a loop get out of it due to edge removal (since they\n \t become unreachable by back edges from latch).  */\n-      rewrite_into_loop_closed_ssa (changed_bbs, TODO_update_ssa);\n+      if ((current_loops->state & LOOP_CLOSED_SSA) != 0)\n+\trewrite_into_loop_closed_ssa (changed_bbs, TODO_update_ssa);\n \n       BITMAP_FREE (changed_bbs);\n "}, {"sha": "955240b68952296fb7b0bc431a5c29e28d52f9d7", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7b852c8a60d46ba79c50b9d2a4f3cba4847c896/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7b852c8a60d46ba79c50b9d2a4f3cba4847c896/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=c7b852c8a60d46ba79c50b9d2a4f3cba4847c896", "patch": "@@ -2862,6 +2862,7 @@ scev_finalize (void)\n {\n   htab_delete (scalar_evolution_info);\n   BITMAP_FREE (already_instantiated);\n+  scalar_evolution_info = NULL;\n }\n \n /* Replace ssa names for that scev can prove they are constant by the"}, {"sha": "30f853469fceed67fca120d9d2320e05cfcd7daa", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7b852c8a60d46ba79c50b9d2a4f3cba4847c896/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7b852c8a60d46ba79c50b9d2a4f3cba4847c896/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=c7b852c8a60d46ba79c50b9d2a4f3cba4847c896", "patch": "@@ -355,10 +355,16 @@ find_uses_to_rename (bitmap changed_bbs, bitmap *use_blocks, bitmap need_phis)\n void\n rewrite_into_loop_closed_ssa (bitmap changed_bbs, unsigned update_flag)\n {\n-  bitmap loop_exits = get_loops_exits ();\n+  bitmap loop_exits;\n   bitmap *use_blocks;\n   unsigned i, old_num_ssa_names;\n-  bitmap names_to_rename = BITMAP_ALLOC (NULL);\n+  bitmap names_to_rename;\n+\n+  if (!current_loops)\n+    return;\n+\n+  loop_exits = get_loops_exits ();\n+  names_to_rename = BITMAP_ALLOC (NULL);\n \n   /* If the pass has caused the SSA form to be out-of-date, update it\n      now.  */\n@@ -383,6 +389,8 @@ rewrite_into_loop_closed_ssa (bitmap changed_bbs, unsigned update_flag)\n   /* Fix up all the names found to be used outside their original\n      loops.  */\n   update_ssa (TODO_update_ssa);\n+\n+  current_loops->state |= LOOP_CLOSED_SSA;\n }\n \n /* Check invariants of the loop closed ssa form for the USE in BB.  */"}, {"sha": "86b265627543b6c86f95daa6c4c26639395a8367", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7b852c8a60d46ba79c50b9d2a4f3cba4847c896/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7b852c8a60d46ba79c50b9d2a4f3cba4847c896/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=c7b852c8a60d46ba79c50b9d2a4f3cba4847c896", "patch": "@@ -488,7 +488,19 @@ simplify_control_stmt_condition (edge e,\n    Note it is quite common for the first block inside a loop to\n    end with a conditional which is either always true or always\n    false when reached via the loop backedge.  Thus we do not want\n-   to blindly disable threading across a loop backedge.  */\n+   to blindly disable threading across a loop backedge.\n+ \n+   DUMMY_COND is a shared cond_expr used by condition simplification as scratch,\n+   to avoid allocating memory.\n+ \n+   HANDLE_DOMINATING_ASSERTS is true if we should try to replace operands of\n+   the simplified condition with left-hand sides of ASSERT_EXPRs they are\n+   used in.\n+ \n+   STACK is used to undo temporary equivalences created during the walk of\n+   E->dest.\n+\n+   SIMPLIFY is a pass-specific function used to simplify statements.  */\n \n void\n thread_across_edge (tree dummy_cond,"}]}