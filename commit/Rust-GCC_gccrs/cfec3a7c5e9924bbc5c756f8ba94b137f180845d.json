{"sha": "cfec3a7c5e9924bbc5c756f8ba94b137f180845d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2ZlYzNhN2M1ZTk5MjRiYmM1Yzc1NmY4YmE5NGIxMzdmMTgwODQ1ZA==", "commit": {"author": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2010-11-02T18:08:44Z"}, "committer": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2010-11-02T18:08:44Z"}, "message": "Emit vzerouppers after reload.\n\ngcc/\n\n2010-11-02  Uros Bizjak  <ubizjak@gmail.com>\n\t    H.J. Lu  <hongjiu.lu@intel.com>\n\n\t* config/i386/i386-protos.h (ix86_split_call_vzeroupper): New.\n\t(ix86_split_call_pop_vzeroupper): Likewise.\n\n\t* config/i386/i386.c (move_or_delete_vzeroupper_2): Rewrite\n\tthe loop.\n\t(ix86_expand_call): Use UNSPEC_CALL_NEEDS_VZEROUPPER.\n\t(ix86_split_call_vzeroupper): New.\n\t(ix86_split_call_pop_vzeroupper): Likewise.\n\n\t* config/i386/i386.md (UNSPEC_CALL_NEEDS_VZEROUPPER): New.\n\t(*call_pop_0_vzeroupper): Likewise.\n\t(*call_pop_1_vzeroupper): Likewise.\n\t(*sibcall_pop_1_vzeroupper): Likewise.\n\t(*call_0_vzeroupper): Likewise.\n\t(*call_1_vzeroupper): Likewise.\n\t(*sibcall_1_vzeroupper): Likewise.\n\t(*call_1_rex64_vzeroupper): Likewise.\n\t(*call_1_rex64_ms_sysv_vzeroupper): New.\n\t(*call_1_rex64_large_vzeroupper): Likewise.\n\t(*sibcall_1_rex64_vzeroupper): Likewise.\n\t(*call_value_pop_0_vzeroupper): New.\n\t(*call_value_pop_1_vzeroupper): Likewise.\n\t(*sibcall_value_pop_1_vzeroupper): Likewise.\n\t(*call_value_0_vzeroupper): New.\n\t(*call_value_0_rex64_vzeroupper): Use\n\t(*call_value_0_rex64_ms_sysv_vzeroupper): Likewise.\n\t(*call_value_1_vzeroupper): Likewise.\n\t(*sibcall_value_1_vzeroupper): Likewise.\n\t(*call_value_1_rex64_vzeroupper): Likewise.\n\t(*call_value_1_rex64_ms_sysv_vzeroupper): Likewise.\n\t(*call_value_1_rex64_large_vzeroupper): Likewise.\n\t(*sibcall_value_1_rex64_vzeroupper): Likewise.\n\ngcc/testsuite/\n\n2010-11-02  H.J. Lu  <hongjiu.lu@intel.com>\n\n\t* gcc.target/i386/avx-vzeroupper-15.c: New.\n\t* gcc.target/i386/avx-vzeroupper-16.c: Likewise.\n\t* gcc.target/i386/avx-vzeroupper-17.c: Likewise.\n\t* gcc.target/i386/avx-vzeroupper-18.c: Likewise.\n\n\tPR target/46253\n\t* gcc.target/i386/pr46253.c: New.\n\nFrom-SVN: r166208", "tree": {"sha": "59669319f991c638bee0da8835955fbfd3f86fde", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/59669319f991c638bee0da8835955fbfd3f86fde"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cfec3a7c5e9924bbc5c756f8ba94b137f180845d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfec3a7c5e9924bbc5c756f8ba94b137f180845d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cfec3a7c5e9924bbc5c756f8ba94b137f180845d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfec3a7c5e9924bbc5c756f8ba94b137f180845d/comments", "author": null, "committer": null, "parents": [{"sha": "12243af614b0bddb0119a4860fccc27f54e92ed7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12243af614b0bddb0119a4860fccc27f54e92ed7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12243af614b0bddb0119a4860fccc27f54e92ed7"}], "stats": {"total": 674, "additions": 563, "deletions": 111}, "files": [{"sha": "a852af3bdee564c323387b806c902a6218d3d995", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfec3a7c5e9924bbc5c756f8ba94b137f180845d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfec3a7c5e9924bbc5c756f8ba94b137f180845d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cfec3a7c5e9924bbc5c756f8ba94b137f180845d", "patch": "@@ -1,3 +1,39 @@\n+2010-11-02  Uros Bizjak  <ubizjak@gmail.com>\n+\t    H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\t* config/i386/i386-protos.h (ix86_split_call_vzeroupper): New.\n+\t(ix86_split_call_pop_vzeroupper): Likewise.\n+\n+\t* config/i386/i386.c (move_or_delete_vzeroupper_2): Rewrite\n+\tthe loop.\n+\t(ix86_expand_call): Use UNSPEC_CALL_NEEDS_VZEROUPPER.\n+\t(ix86_split_call_vzeroupper): New.\n+\t(ix86_split_call_pop_vzeroupper): Likewise.\n+\n+\t* config/i386/i386.md (UNSPEC_CALL_NEEDS_VZEROUPPER): New.\n+\t(*call_pop_0_vzeroupper): Likewise.\n+\t(*call_pop_1_vzeroupper): Likewise.\n+\t(*sibcall_pop_1_vzeroupper): Likewise.\n+\t(*call_0_vzeroupper): Likewise.\n+\t(*call_1_vzeroupper): Likewise.\n+\t(*sibcall_1_vzeroupper): Likewise.\n+\t(*call_1_rex64_vzeroupper): Likewise.\n+\t(*call_1_rex64_ms_sysv_vzeroupper): New.\n+\t(*call_1_rex64_large_vzeroupper): Likewise.\n+\t(*sibcall_1_rex64_vzeroupper): Likewise.\n+\t(*call_value_pop_0_vzeroupper): New.\n+\t(*call_value_pop_1_vzeroupper): Likewise.\n+\t(*sibcall_value_pop_1_vzeroupper): Likewise.\n+\t(*call_value_0_vzeroupper): New.\n+\t(*call_value_0_rex64_vzeroupper): Use\n+\t(*call_value_0_rex64_ms_sysv_vzeroupper): Likewise.\n+\t(*call_value_1_vzeroupper): Likewise.\n+\t(*sibcall_value_1_vzeroupper): Likewise.\n+\t(*call_value_1_rex64_vzeroupper): Likewise.\n+\t(*call_value_1_rex64_ms_sysv_vzeroupper): Likewise.\n+\t(*call_value_1_rex64_large_vzeroupper): Likewise.\n+\t(*sibcall_value_1_rex64_vzeroupper): Likewise.\n+\n 2010-11-02  Ian Lance Taylor  <iant@google.com>\n \n \tPR lto/46273"}, {"sha": "c64135bb8d659835e19059fd71ad3e6d7240051b", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfec3a7c5e9924bbc5c756f8ba94b137f180845d/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfec3a7c5e9924bbc5c756f8ba94b137f180845d/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=cfec3a7c5e9924bbc5c756f8ba94b137f180845d", "patch": "@@ -119,6 +119,8 @@ extern void ix86_expand_sse_unpack (rtx[], bool, bool);\n extern void ix86_expand_sse4_unpack (rtx[], bool, bool);\n extern bool ix86_expand_int_addcc (rtx[]);\n extern rtx ix86_expand_call (rtx, rtx, rtx, rtx, rtx, int);\n+extern void ix86_split_call_vzeroupper (rtx, rtx);\n+extern void ix86_split_call_pop_vzeroupper (rtx, rtx);\n extern void x86_initialize_trampoline (rtx, rtx, rtx);\n extern rtx ix86_zero_extend_to_Pmode (rtx);\n extern void ix86_split_long_move (rtx[]);"}, {"sha": "a5beb8324dacddb792eb16a95e4468ffbda5d432", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 91, "deletions": 111, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfec3a7c5e9924bbc5c756f8ba94b137f180845d/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfec3a7c5e9924bbc5c756f8ba94b137f180845d/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=cfec3a7c5e9924bbc5c756f8ba94b137f180845d", "patch": "@@ -108,163 +108,119 @@ check_avx256_stores (rtx dest, const_rtx set, void *data)\n static void\n move_or_delete_vzeroupper_2 (basic_block bb, bool upper_128bits_set)\n {\n-  rtx curr_insn, next_insn, prev_insn, insn;\n+  rtx insn;\n+  rtx vzeroupper_insn = NULL_RTX;\n+  rtx pat;\n+  int avx256;\n \n   if (dump_file)\n     fprintf (dump_file, \" BB [%i] entry: upper 128bits: %d\\n\",\n \t     bb->index, upper_128bits_set);\n \n-  for (curr_insn = BB_HEAD (bb);\n-       curr_insn && curr_insn != NEXT_INSN (BB_END (bb));\n-       curr_insn = next_insn)\n+  insn = BB_HEAD (bb);\n+  while (insn != BB_END (bb))\n     {\n-      int avx256;\n+      insn = NEXT_INSN (insn);\n \n-      next_insn = NEXT_INSN (curr_insn);\n-\n-      if (!NONDEBUG_INSN_P (curr_insn))\n+      if (!NONDEBUG_INSN_P (insn))\n \tcontinue;\n \n-      /* Search for vzeroupper.  */\n-      insn = PATTERN (curr_insn);\n-      if (GET_CODE (insn) == UNSPEC_VOLATILE\n-\t  && XINT (insn, 1) == UNSPECV_VZEROUPPER)\n+      /* Move vzeroupper before jump/call.  */\n+      if (JUMP_P (insn) || CALL_P (insn))\n+\t{\n+\t  if (!vzeroupper_insn)\n+\t    continue;\n+\n+\t  if (PREV_INSN (insn) != vzeroupper_insn)\n+\t    {\n+\t      if (dump_file)\n+\t\t{\n+\t\t  fprintf (dump_file, \"Move vzeroupper after:\\n\");\n+\t\t  print_rtl_single (dump_file, PREV_INSN (insn));\n+\t\t  fprintf (dump_file, \"before:\\n\");\n+\t\t  print_rtl_single (dump_file, insn);\n+\t\t}\n+\t      reorder_insns_nobb (vzeroupper_insn, vzeroupper_insn,\n+\t\t\t\t  PREV_INSN (insn));\n+\t    }\n+\t  vzeroupper_insn = NULL_RTX;\n+\t  continue;\n+\t}\n+\n+      pat = PATTERN (insn);\n+\n+      /* Check insn for vzeroupper intrinsic.  */\n+      if (GET_CODE (pat) == UNSPEC_VOLATILE\n+\t  && XINT (pat, 1) == UNSPECV_VZEROUPPER)\n \t{\n-\t  /* Found vzeroupper.  */\n \t  if (dump_file)\n \t    {\n+\t      /* Found vzeroupper intrinsic.  */\n \t      fprintf (dump_file, \"Found vzeroupper:\\n\");\n-\t      print_rtl_single (dump_file, curr_insn);\n+\t      print_rtl_single (dump_file, insn);\n \t    }\n \t}\n       else\n \t{\n-\t  /* Check vzeroall intrinsic.  */\n-\t  if (GET_CODE (insn) == PARALLEL\n-\t      && GET_CODE (XVECEXP (insn, 0, 0)) == UNSPEC_VOLATILE\n-\t      && XINT (XVECEXP (insn, 0, 0), 1) == UNSPECV_VZEROALL)\n-\t    upper_128bits_set = false;\n-\t  else if (!upper_128bits_set)\n+\t  /* Check insn for vzeroall intrinsic.  */\n+\t  if (GET_CODE (pat) == PARALLEL\n+\t      && GET_CODE (XVECEXP (pat, 0, 0)) == UNSPEC_VOLATILE\n+\t      && XINT (XVECEXP (pat, 0, 0), 1) == UNSPECV_VZEROALL)\n \t    {\n-\t      /* Check if upper 128bits of AVX registers are used.  */\n-\t      note_stores (insn, check_avx256_stores,\n-\t\t\t   &upper_128bits_set);\n+\t      upper_128bits_set = false;\n+\n+\t      /* Delete pending vzeroupper insertion.  */\n+\t      if (vzeroupper_insn)\n+\t\t{\n+\t\t  delete_insn (vzeroupper_insn);\n+\t\t  vzeroupper_insn = NULL_RTX;\n+\t\t}\n \t    }\n+\t  else if (!upper_128bits_set)\n+\t    note_stores (pat, check_avx256_stores, &upper_128bits_set);\n \t  continue;\n \t}\n \n-      avx256 = INTVAL (XVECEXP (insn, 0, 0));\n+      /* Process vzeroupper intrinsic.  */\n+      avx256 = INTVAL (XVECEXP (pat, 0, 0));\n \n       if (!upper_128bits_set)\n \t{\n \t  /* Since the upper 128bits are cleared, callee must not pass\n \t     256bit AVX register.  We only need to check if callee\n \t     returns 256bit AVX register.  */\n-\t  upper_128bits_set = avx256 == callee_return_avx256;\n+\t  upper_128bits_set = (avx256 == callee_return_avx256);\n \n-\t  /* Remove unnecessary vzeroupper since upper 128bits are\n-\t     cleared.  */\n+\t  /* Remove unnecessary vzeroupper since\n+\t     upper 128bits are cleared.  */\n \t  if (dump_file)\n \t    {\n \t      fprintf (dump_file, \"Delete redundant vzeroupper:\\n\");\n-\t      print_rtl_single (dump_file, curr_insn);\n+\t      print_rtl_single (dump_file, insn);\n \t    }\n-\t  delete_insn (curr_insn);\n-\t  continue;\n+\t  delete_insn (insn);\n \t}\n       else if (avx256 == callee_return_pass_avx256\n \t       || avx256 == callee_pass_avx256)\n \t{\n \t  /* Callee passes 256bit AVX register.  Check if callee\n \t     returns 256bit AVX register.  */\n-\t  upper_128bits_set = avx256 == callee_return_pass_avx256;\n+\t  upper_128bits_set = (avx256 == callee_return_pass_avx256);\n \n-\t  /* Must remove vzeroupper since callee passes 256bit AVX\n-\t     register.  */\n+\t  /* Must remove vzeroupper since\n+\t     callee passes in 256bit AVX register.  */\n \t  if (dump_file)\n \t    {\n \t      fprintf (dump_file, \"Delete callee pass vzeroupper:\\n\");\n-\t      print_rtl_single (dump_file, curr_insn);\n-\t    }\n-\t  delete_insn (curr_insn);\n-\t  continue;\n-\t}\n-\n-      /* Find the jump after vzeroupper.  */\n-      prev_insn = curr_insn;\n-      if (avx256 == vzeroupper_intrinsic)\n-\t{\n-\t  /* For vzeroupper intrinsic, check if there is another\n-\t     vzeroupper.  */\n-\t  insn = NEXT_INSN (curr_insn);\n-\t  while (insn)\n-\t    {\n-\t      if (NONJUMP_INSN_P (insn)\n-\t\t  && GET_CODE (PATTERN (insn)) == UNSPEC_VOLATILE\n-\t\t  && XINT (PATTERN (insn), 1) == UNSPECV_VZEROUPPER)\n-\t\t{\n-\t\t  if (dump_file)\n-\t\t    {\n-\t\t      fprintf (dump_file,\n-\t\t\t       \"Delete redundant vzeroupper intrinsic:\\n\");\n-\t\t      print_rtl_single (dump_file, curr_insn);\n-\t\t    }\n-\t\t  delete_insn (curr_insn);\n-\t\t  insn = NULL;\n-\t\t  continue;\n-\t\t}\n-\n-\t      if (JUMP_P (insn) || CALL_P (insn))\n-\t\tbreak;\n-\t      prev_insn = insn;\n-\t      insn = NEXT_INSN (insn);\n-\t      if (insn == NEXT_INSN (BB_END (bb)))\n-\t\tbreak;\n+\t      print_rtl_single (dump_file, insn);\n \t    }\n-\n-\t  /* Continue if redundant vzeroupper intrinsic is deleted.  */\n-\t  if (!insn)\n-\t    continue;\n+\t  delete_insn (insn);\n \t}\n       else\n \t{\n-\t  /* Find the next jump/call.  */\n-\t  insn = NEXT_INSN (curr_insn);\n-\t  while (insn)\n-\t    {\n-\t      if (JUMP_P (insn) || CALL_P (insn))\n-\t\tbreak;\n-\t      prev_insn = insn;\n-\t      insn = NEXT_INSN (insn);\n-\t      if (insn == NEXT_INSN (BB_END (bb)))\n-\t\tbreak;\n-\t    }\n-\n-\t  if (!insn)\n-\t    gcc_unreachable();\n+\t  upper_128bits_set = false;\n+\t  vzeroupper_insn = insn;\n \t}\n-\n-      /* Keep vzeroupper.  */\n-      upper_128bits_set = false;\n-\n-      /* Also allow label as the next instruction.  */\n-      if (insn == NEXT_INSN (BB_END (bb)) && !LABEL_P (insn))\n-\tgcc_unreachable();\n-\n-      /* Move vzeroupper before jump/call if neeeded.  */\n-      if (curr_insn != prev_insn)\n-\t{\n-\t  reorder_insns_nobb (curr_insn, curr_insn, prev_insn);\n-\t  if (dump_file)\n-\t    {\n-\t      fprintf (dump_file, \"Move vzeroupper after:\\n\");\n-\t      print_rtl_single (dump_file, prev_insn);\n-\t      fprintf (dump_file, \"before:\\n\");\n-\t      print_rtl_single (dump_file, insn);\n-\t    }\n-\t}\n-\n-      next_insn = NEXT_INSN (insn);\n     }\n \n   BLOCK_INFO (bb)->upper_128bits_set = upper_128bits_set;\n@@ -21565,10 +21521,12 @@ ix86_expand_call (rtx retval, rtx fnaddr, rtx callarg1,\n \t\t\t       + 2, vec));\n     }\n \n-  /* Emit vzeroupper if needed.  */\n+  /* Add UNSPEC_CALL_NEEDS_VZEROUPPER decoration.  */\n   if (TARGET_VZEROUPPER && cfun->machine->use_avx256_p)\n     {\n+      rtx unspec;\n       int avx256;\n+\n       cfun->machine->use_vzeroupper_p = 1;\n       if (cfun->machine->callee_pass_avx256_p)\n \t{\n@@ -21581,7 +21539,11 @@ ix86_expand_call (rtx retval, rtx fnaddr, rtx callarg1,\n \tavx256 = callee_return_avx256;\n       else\n \tavx256 = call_no_avx256;\n-      emit_insn (gen_avx_vzeroupper (GEN_INT (avx256))); \n+\n+      unspec = gen_rtx_UNSPEC (VOIDmode,\n+\t\t\t       gen_rtvec (1, GEN_INT (avx256)),\n+\t\t\t       UNSPEC_CALL_NEEDS_VZEROUPPER);\n+      call = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, call, unspec));\n     }\n \n   call = emit_call_insn (call);\n@@ -21591,6 +21553,24 @@ ix86_expand_call (rtx retval, rtx fnaddr, rtx callarg1,\n   return call;\n }\n \n+void\n+ix86_split_call_vzeroupper (rtx insn, rtx vzeroupper)\n+{\n+  rtx call = XVECEXP (PATTERN (insn), 0, 0);\n+  emit_insn (gen_avx_vzeroupper (vzeroupper));\n+  emit_call_insn (call);\n+}\n+\n+void\n+ix86_split_call_pop_vzeroupper (rtx insn, rtx vzeroupper)\n+{\n+  rtx call = XVECEXP (PATTERN (insn), 0, 0);\n+  rtx pop = XVECEXP (PATTERN (insn), 0, 1);\n+  emit_insn (gen_avx_vzeroupper (vzeroupper));\n+  emit_call_insn (gen_rtx_PARALLEL (VOIDmode,\n+\t\t\t\t    gen_rtvec (2, call, pop)));\n+}\n+\n /* Output the assembly for a call instruction.  */\n \n const char *"}, {"sha": "278bd77a3662599ba648b37e6681f93a4fcd3062", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 339, "deletions": 0, "changes": 339, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfec3a7c5e9924bbc5c756f8ba94b137f180845d/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfec3a7c5e9924bbc5c756f8ba94b137f180845d/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=cfec3a7c5e9924bbc5c756f8ba94b137f180845d", "patch": "@@ -105,6 +105,7 @@\n   UNSPEC_LD_MPIC\t; load_macho_picbase\n   UNSPEC_TRUNC_NOOP\n   UNSPEC_DIV_ALREADY_SPLIT\n+  UNSPEC_CALL_NEEDS_VZEROUPPER\n \n   ;; For SSE/MMX support:\n   UNSPEC_FIX_NOTRUNC\n@@ -11260,6 +11261,21 @@\n   DONE;\n })\n \n+(define_insn_and_split \"*call_pop_0_vzeroupper\"\n+  [(call (mem:QI (match_operand:SI 0 \"constant_call_address_operand\" \"\"))\n+\t (match_operand:SI 1 \"\" \"\"))\n+   (set (reg:SI SP_REG)\n+\t(plus:SI (reg:SI SP_REG)\n+\t\t (match_operand:SI 2 \"immediate_operand\" \"\")))\n+   (unspec [(match_operand 3 \"const_int_operand\" \"\")]\n+   \t   UNSPEC_CALL_NEEDS_VZEROUPPER)]\n+  \"TARGET_VZEROUPPER && !TARGET_64BIT\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+  \"ix86_split_call_pop_vzeroupper (curr_insn, operands[3]); DONE;\"\n+  [(set_attr \"type\" \"call\")])\n+\n (define_insn \"*call_pop_0\"\n   [(call (mem:QI (match_operand:SI 0 \"constant_call_address_operand\" \"\"))\n \t (match_operand:SI 1 \"\" \"\"))\n@@ -11275,6 +11291,21 @@\n }\n   [(set_attr \"type\" \"call\")])\n \n+(define_insn_and_split \"*call_pop_1_vzeroupper\"\n+  [(call (mem:QI (match_operand:SI 0 \"call_insn_operand\" \"lsm\"))\n+\t (match_operand:SI 1 \"\" \"\"))\n+   (set (reg:SI SP_REG)\n+\t(plus:SI (reg:SI SP_REG)\n+\t\t (match_operand:SI 2 \"immediate_operand\" \"i\")))\n+   (unspec [(match_operand 3 \"const_int_operand\" \"\")]\n+   \t   UNSPEC_CALL_NEEDS_VZEROUPPER)]\n+  \"TARGET_VZEROUPPER && !TARGET_64BIT && !SIBLING_CALL_P (insn)\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+  \"ix86_split_call_pop_vzeroupper (curr_insn, operands[3]); DONE;\"\n+  [(set_attr \"type\" \"call\")])\n+\n (define_insn \"*call_pop_1\"\n   [(call (mem:QI (match_operand:SI 0 \"call_insn_operand\" \"lsm\"))\n \t (match_operand:SI 1 \"\" \"\"))\n@@ -11289,6 +11320,21 @@\n }\n   [(set_attr \"type\" \"call\")])\n \n+(define_insn_and_split \"*sibcall_pop_1_vzeroupper\"\n+  [(call (mem:QI (match_operand:SI 0 \"sibcall_insn_operand\" \"s,U\"))\n+\t (match_operand:SI 1 \"\" \"\"))\n+   (set (reg:SI SP_REG)\n+\t(plus:SI (reg:SI SP_REG)\n+\t\t (match_operand:SI 2 \"immediate_operand\" \"i,i\")))\n+   (unspec [(match_operand 3 \"const_int_operand\" \"\")]\n+   \t   UNSPEC_CALL_NEEDS_VZEROUPPER)]\n+  \"TARGET_VZEROUPPER && !TARGET_64BIT && SIBLING_CALL_P (insn)\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+  \"ix86_split_call_pop_vzeroupper (curr_insn, operands[3]); DONE;\"\n+  [(set_attr \"type\" \"call\")])\n+\n (define_insn \"*sibcall_pop_1\"\n   [(call (mem:QI (match_operand:SI 0 \"sibcall_insn_operand\" \"s,U\"))\n \t (match_operand:SI 1 \"\" \"\"))\n@@ -11321,27 +11367,76 @@\n   DONE;\n })\n \n+(define_insn_and_split \"*call_0_vzeroupper\"\n+  [(call (mem:QI (match_operand 0 \"constant_call_address_operand\" \"\"))\n+\t (match_operand 1 \"\" \"\"))\n+   (unspec [(match_operand 2 \"const_int_operand\" \"\")]\n+   \t   UNSPEC_CALL_NEEDS_VZEROUPPER)]\n+  \"TARGET_VZEROUPPER\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+  \"ix86_split_call_vzeroupper (curr_insn, operands[2]); DONE;\"\n+  [(set_attr \"type\" \"call\")])\n+\n (define_insn \"*call_0\"\n   [(call (mem:QI (match_operand 0 \"constant_call_address_operand\" \"\"))\n \t (match_operand 1 \"\" \"\"))]\n   \"\"\n   { return ix86_output_call_insn (insn, operands[0], 0); }\n   [(set_attr \"type\" \"call\")])\n \n+(define_insn_and_split \"*call_1_vzeroupper\"\n+  [(call (mem:QI (match_operand:SI 0 \"call_insn_operand\" \"lsm\"))\n+\t (match_operand 1 \"\" \"\"))\n+   (unspec [(match_operand 2 \"const_int_operand\" \"\")]\n+   \t   UNSPEC_CALL_NEEDS_VZEROUPPER)]\n+  \"TARGET_VZEROUPPER && !TARGET_64BIT && !SIBLING_CALL_P (insn)\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+  \"ix86_split_call_vzeroupper (curr_insn, operands[2]); DONE;\"\n+  [(set_attr \"type\" \"call\")])\n+\n (define_insn \"*call_1\"\n   [(call (mem:QI (match_operand:SI 0 \"call_insn_operand\" \"lsm\"))\n \t (match_operand 1 \"\" \"\"))]\n   \"!TARGET_64BIT && !SIBLING_CALL_P (insn)\"\n   { return ix86_output_call_insn (insn, operands[0], 0); }\n   [(set_attr \"type\" \"call\")])\n \n+(define_insn_and_split \"*sibcall_1_vzeroupper\"\n+  [(call (mem:QI (match_operand:SI 0 \"sibcall_insn_operand\" \"s,U\"))\n+\t (match_operand 1 \"\" \"\"))\n+   (unspec [(match_operand 2 \"const_int_operand\" \"\")]\n+   \t   UNSPEC_CALL_NEEDS_VZEROUPPER)]\n+  \"TARGET_VZEROUPPER && !TARGET_64BIT && SIBLING_CALL_P (insn)\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+  \"ix86_split_call_vzeroupper (curr_insn, operands[2]); DONE;\"\n+  [(set_attr \"type\" \"call\")])\n+\n (define_insn \"*sibcall_1\"\n   [(call (mem:QI (match_operand:SI 0 \"sibcall_insn_operand\" \"s,U\"))\n \t (match_operand 1 \"\" \"\"))]\n   \"!TARGET_64BIT && SIBLING_CALL_P (insn)\"\n   { return ix86_output_call_insn (insn, operands[0], 0); }\n   [(set_attr \"type\" \"call\")])\n \n+(define_insn_and_split \"*call_1_rex64_vzeroupper\"\n+  [(call (mem:QI (match_operand:DI 0 \"call_insn_operand\" \"rsm\"))\n+\t (match_operand 1 \"\" \"\"))\n+   (unspec [(match_operand 2 \"const_int_operand\" \"\")]\n+   \t   UNSPEC_CALL_NEEDS_VZEROUPPER)]\n+  \"TARGET_VZEROUPPER && TARGET_64BIT && !SIBLING_CALL_P (insn)\n+   && ix86_cmodel != CM_LARGE && ix86_cmodel != CM_LARGE_PIC\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+  \"ix86_split_call_vzeroupper (curr_insn, operands[2]); DONE;\"\n+  [(set_attr \"type\" \"call\")])\n+\n (define_insn \"*call_1_rex64\"\n   [(call (mem:QI (match_operand:DI 0 \"call_insn_operand\" \"rsm\"))\n \t (match_operand 1 \"\" \"\"))]\n@@ -11350,6 +11445,32 @@\n   { return ix86_output_call_insn (insn, operands[0], 0); }\n   [(set_attr \"type\" \"call\")])\n \n+(define_insn_and_split \"*call_1_rex64_ms_sysv_vzeroupper\"\n+  [(parallel\n+    [(call (mem:QI (match_operand:DI 0 \"call_insn_operand\" \"rsm\"))\n+\t   (match_operand 1 \"\" \"\"))\n+     (unspec [(const_int 0)] UNSPEC_MS_TO_SYSV_CALL)\n+     (clobber (reg:TI XMM6_REG))\n+     (clobber (reg:TI XMM7_REG))\n+     (clobber (reg:TI XMM8_REG))\n+     (clobber (reg:TI XMM9_REG))\n+     (clobber (reg:TI XMM10_REG))\n+     (clobber (reg:TI XMM11_REG))\n+     (clobber (reg:TI XMM12_REG))\n+     (clobber (reg:TI XMM13_REG))\n+     (clobber (reg:TI XMM14_REG))\n+     (clobber (reg:TI XMM15_REG))\n+     (clobber (reg:DI SI_REG))\n+     (clobber (reg:DI DI_REG))])\n+   (unspec [(match_operand 2 \"const_int_operand\" \"\")]\n+   \t   UNSPEC_CALL_NEEDS_VZEROUPPER)]\n+  \"TARGET_VZEROUPPER && TARGET_64BIT && !SIBLING_CALL_P (insn)\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+  \"ix86_split_call_vzeroupper (curr_insn, operands[2]); DONE;\"\n+  [(set_attr \"type\" \"call\")])\n+\n (define_insn \"*call_1_rex64_ms_sysv\"\n   [(call (mem:QI (match_operand:DI 0 \"call_insn_operand\" \"rsm\"))\n \t (match_operand 1 \"\" \"\"))\n@@ -11370,13 +11491,37 @@\n   { return ix86_output_call_insn (insn, operands[0], 0); }\n   [(set_attr \"type\" \"call\")])\n \n+(define_insn_and_split \"*call_1_rex64_large_vzeroupper\"\n+  [(call (mem:QI (match_operand:DI 0 \"call_insn_operand\" \"rm\"))\n+\t (match_operand 1 \"\" \"\"))\n+   (unspec [(match_operand 2 \"const_int_operand\" \"\")]\n+   \t   UNSPEC_CALL_NEEDS_VZEROUPPER)]\n+  \"TARGET_VZEROUPPER && TARGET_64BIT && !SIBLING_CALL_P (insn)\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+  \"ix86_split_call_vzeroupper (curr_insn, operands[2]); DONE;\"\n+  [(set_attr \"type\" \"call\")])\n+\n (define_insn \"*call_1_rex64_large\"\n   [(call (mem:QI (match_operand:DI 0 \"call_insn_operand\" \"rm\"))\n \t (match_operand 1 \"\" \"\"))]\n   \"TARGET_64BIT && !SIBLING_CALL_P (insn)\"\n   { return ix86_output_call_insn (insn, operands[0], 0); }\n   [(set_attr \"type\" \"call\")])\n \n+(define_insn_and_split \"*sibcall_1_rex64_vzeroupper\"\n+  [(call (mem:QI (match_operand:DI 0 \"sibcall_insn_operand\" \"s,U\"))\n+\t (match_operand 1 \"\" \"\"))\n+   (unspec [(match_operand 2 \"const_int_operand\" \"\")]\n+   \t   UNSPEC_CALL_NEEDS_VZEROUPPER)]\n+  \"TARGET_VZEROUPPER && TARGET_64BIT && !SIBLING_CALL_P (insn)\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+  \"ix86_split_call_vzeroupper (curr_insn, operands[2]); DONE;\"\n+  [(set_attr \"type\" \"call\")])\n+\n (define_insn \"*sibcall_1_rex64\"\n   [(call (mem:QI (match_operand:DI 0 \"sibcall_insn_operand\" \"s,U\"))\n \t (match_operand 1 \"\" \"\"))]\n@@ -17123,6 +17268,22 @@\n ;; Call-value patterns last so that the wildcard operand does not\n ;; disrupt insn-recog's switch tables.\n \n+(define_insn_and_split \"*call_value_pop_0_vzeroupper\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (mem:QI (match_operand:SI 1 \"constant_call_address_operand\" \"\"))\n+\t      (match_operand:SI 2 \"\" \"\")))\n+   (set (reg:SI SP_REG)\n+\t(plus:SI (reg:SI SP_REG)\n+\t\t (match_operand:SI 3 \"immediate_operand\" \"\")))\n+   (unspec [(match_operand 4 \"const_int_operand\" \"\")]\n+   \t   UNSPEC_CALL_NEEDS_VZEROUPPER)]\n+  \"TARGET_VZEROUPPER && !TARGET_64BIT\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+  \"ix86_split_call_pop_vzeroupper (curr_insn, operands[4]); DONE;\"\n+  [(set_attr \"type\" \"callv\")])\n+\n (define_insn \"*call_value_pop_0\"\n   [(set (match_operand 0 \"\" \"\")\n \t(call (mem:QI (match_operand:SI 1 \"constant_call_address_operand\" \"\"))\n@@ -17134,6 +17295,22 @@\n   { return ix86_output_call_insn (insn, operands[1], 1); }\n   [(set_attr \"type\" \"callv\")])\n \n+(define_insn_and_split \"*call_value_pop_1_vzeroupper\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (mem:QI (match_operand:SI 1 \"call_insn_operand\" \"lsm\"))\n+\t      (match_operand:SI 2 \"\" \"\")))\n+   (set (reg:SI SP_REG)\n+\t(plus:SI (reg:SI SP_REG)\n+\t\t (match_operand:SI 3 \"immediate_operand\" \"i\")))\n+   (unspec [(match_operand 4 \"const_int_operand\" \"\")]\n+   \t   UNSPEC_CALL_NEEDS_VZEROUPPER)]\n+  \"TARGET_VZEROUPPER && !TARGET_64BIT && !SIBLING_CALL_P (insn)\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+  \"ix86_split_call_pop_vzeroupper (curr_insn, operands[4]); DONE;\"\n+  [(set_attr \"type\" \"callv\")])\n+\n (define_insn \"*call_value_pop_1\"\n   [(set (match_operand 0 \"\" \"\")\n \t(call (mem:QI (match_operand:SI 1 \"call_insn_operand\" \"lsm\"))\n@@ -17145,6 +17322,22 @@\n   { return ix86_output_call_insn (insn, operands[1], 1); }\n   [(set_attr \"type\" \"callv\")])\n \n+(define_insn_and_split \"*sibcall_value_pop_1_vzeroupper\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (mem:QI (match_operand:SI 1 \"sibcall_insn_operand\" \"s,U\"))\n+\t      (match_operand:SI 2 \"\" \"\")))\n+   (set (reg:SI SP_REG)\n+\t(plus:SI (reg:SI SP_REG)\n+\t\t (match_operand:SI 3 \"immediate_operand\" \"i,i\")))\n+   (unspec [(match_operand 4 \"const_int_operand\" \"\")]\n+   \t   UNSPEC_CALL_NEEDS_VZEROUPPER)]\n+  \"TARGET_VZEROUPPER && !TARGET_64BIT && SIBLING_CALL_P (insn)\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+  \"ix86_split_call_pop_vzeroupper (curr_insn, operands[4]); DONE;\"\n+  [(set_attr \"type\" \"callv\")])\n+\n (define_insn \"*sibcall_value_pop_1\"\n   [(set (match_operand 0 \"\" \"\")\n \t(call (mem:QI (match_operand:SI 1 \"sibcall_insn_operand\" \"s,U\"))\n@@ -17156,6 +17349,19 @@\n   { return ix86_output_call_insn (insn, operands[1], 1); }\n   [(set_attr \"type\" \"callv\")])\n \n+(define_insn_and_split \"*call_value_0_vzeroupper\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (mem:QI (match_operand:SI 1 \"constant_call_address_operand\" \"\"))\n+\t      (match_operand:SI 2 \"\" \"\")))\n+   (unspec [(match_operand 3 \"const_int_operand\" \"\")]\n+   \t   UNSPEC_CALL_NEEDS_VZEROUPPER)]\n+  \"TARGET_VZEROUPPER && !TARGET_64BIT\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+  \"ix86_split_call_vzeroupper (curr_insn, operands[3]); DONE;\"\n+  [(set_attr \"type\" \"callv\")])\n+\n (define_insn \"*call_value_0\"\n   [(set (match_operand 0 \"\" \"\")\n \t(call (mem:QI (match_operand:SI 1 \"constant_call_address_operand\" \"\"))\n@@ -17164,6 +17370,19 @@\n   { return ix86_output_call_insn (insn, operands[1], 1); }\n   [(set_attr \"type\" \"callv\")])\n \n+(define_insn_and_split \"*call_value_0_rex64_vzeroupper\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (mem:QI (match_operand:DI 1 \"constant_call_address_operand\" \"\"))\n+\t      (match_operand:DI 2 \"const_int_operand\" \"\")))\n+   (unspec [(match_operand 3 \"const_int_operand\" \"\")]\n+   \t   UNSPEC_CALL_NEEDS_VZEROUPPER)]\n+  \"TARGET_VZEROUPPER && TARGET_64BIT\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+  \"ix86_split_call_vzeroupper (curr_insn, operands[3]); DONE;\"\n+  [(set_attr \"type\" \"callv\")])\n+\n (define_insn \"*call_value_0_rex64\"\n   [(set (match_operand 0 \"\" \"\")\n \t(call (mem:QI (match_operand:DI 1 \"constant_call_address_operand\" \"\"))\n@@ -17172,6 +17391,33 @@\n   { return ix86_output_call_insn (insn, operands[1], 1); }\n   [(set_attr \"type\" \"callv\")])\n \n+(define_insn_and_split \"*call_value_0_rex64_ms_sysv_vzeroupper\"\n+  [(parallel\n+    [(set (match_operand 0 \"\" \"\")\n+\t  (call (mem:QI (match_operand:DI 1 \"constant_call_address_operand\" \"\"))\n+\t\t(match_operand:DI 2 \"const_int_operand\" \"\")))\n+     (unspec [(const_int 0)] UNSPEC_MS_TO_SYSV_CALL)\n+     (clobber (reg:TI XMM6_REG))\n+     (clobber (reg:TI XMM7_REG))\n+     (clobber (reg:TI XMM8_REG))\n+     (clobber (reg:TI XMM9_REG))\n+     (clobber (reg:TI XMM10_REG))\n+     (clobber (reg:TI XMM11_REG))\n+     (clobber (reg:TI XMM12_REG))\n+     (clobber (reg:TI XMM13_REG))\n+     (clobber (reg:TI XMM14_REG))\n+     (clobber (reg:TI XMM15_REG))\n+     (clobber (reg:DI SI_REG))\n+     (clobber (reg:DI DI_REG))])\n+   (unspec [(match_operand 3 \"const_int_operand\" \"\")]\n+   \t   UNSPEC_CALL_NEEDS_VZEROUPPER)]\n+  \"TARGET_VZEROUPPER && TARGET_64BIT && !SIBLING_CALL_P (insn)\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+  \"ix86_split_call_vzeroupper (curr_insn, operands[3]); DONE;\"\n+  [(set_attr \"type\" \"callv\")])\n+\n (define_insn \"*call_value_0_rex64_ms_sysv\"\n   [(set (match_operand 0 \"\" \"\")\n \t(call (mem:QI (match_operand:DI 1 \"constant_call_address_operand\" \"\"))\n@@ -17193,6 +17439,19 @@\n   { return ix86_output_call_insn (insn, operands[1], 1); }\n   [(set_attr \"type\" \"callv\")])\n \n+(define_insn_and_split \"*call_value_1_vzeroupper\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (mem:QI (match_operand:SI 1 \"call_insn_operand\" \"lsm\"))\n+\t      (match_operand:SI 2 \"\" \"\")))\n+   (unspec [(match_operand 3 \"const_int_operand\" \"\")]\n+   \t   UNSPEC_CALL_NEEDS_VZEROUPPER)]\n+  \"TARGET_VZEROUPPER && !TARGET_64BIT && !SIBLING_CALL_P (insn)\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+  \"ix86_split_call_vzeroupper (curr_insn, operands[3]); DONE;\"\n+  [(set_attr \"type\" \"callv\")])\n+\n (define_insn \"*call_value_1\"\n   [(set (match_operand 0 \"\" \"\")\n \t(call (mem:QI (match_operand:SI 1 \"call_insn_operand\" \"lsm\"))\n@@ -17201,6 +17460,19 @@\n   { return ix86_output_call_insn (insn, operands[1], 1); }\n   [(set_attr \"type\" \"callv\")])\n \n+(define_insn_and_split \"*sibcall_value_1_vzeroupper\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (mem:QI (match_operand:SI 1 \"sibcall_insn_operand\" \"s,U\"))\n+\t      (match_operand:SI 2 \"\" \"\")))\n+   (unspec [(match_operand 3 \"const_int_operand\" \"\")]\n+   \t   UNSPEC_CALL_NEEDS_VZEROUPPER)]\n+  \"TARGET_VZEROUPPER && !TARGET_64BIT && SIBLING_CALL_P (insn)\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+  \"ix86_split_call_vzeroupper (curr_insn, operands[3]); DONE;\"\n+  [(set_attr \"type\" \"callv\")])\n+\n (define_insn \"*sibcall_value_1\"\n   [(set (match_operand 0 \"\" \"\")\n \t(call (mem:QI (match_operand:SI 1 \"sibcall_insn_operand\" \"s,U\"))\n@@ -17209,6 +17481,20 @@\n   { return ix86_output_call_insn (insn, operands[1], 1); }\n   [(set_attr \"type\" \"callv\")])\n \n+(define_insn_and_split \"*call_value_1_rex64_vzeroupper\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (mem:QI (match_operand:DI 1 \"call_insn_operand\" \"rsm\"))\n+\t      (match_operand:DI 2 \"\" \"\")))\n+   (unspec [(match_operand 3 \"const_int_operand\" \"\")]\n+   \t   UNSPEC_CALL_NEEDS_VZEROUPPER)]\n+  \"TARGET_VZEROUPPER && TARGET_64BIT && !SIBLING_CALL_P (insn)\n+   && ix86_cmodel != CM_LARGE && ix86_cmodel != CM_LARGE_PIC\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+  \"ix86_split_call_vzeroupper (curr_insn, operands[3]); DONE;\"\n+  [(set_attr \"type\" \"callv\")])\n+\n (define_insn \"*call_value_1_rex64\"\n   [(set (match_operand 0 \"\" \"\")\n \t(call (mem:QI (match_operand:DI 1 \"call_insn_operand\" \"rsm\"))\n@@ -17218,6 +17504,33 @@\n   { return ix86_output_call_insn (insn, operands[1], 1); }\n   [(set_attr \"type\" \"callv\")])\n \n+(define_insn_and_split \"*call_value_1_rex64_ms_sysv_vzeroupper\"\n+  [(parallel\n+    [(set (match_operand 0 \"\" \"\")\n+\t  (call (mem:QI (match_operand:DI 1 \"call_insn_operand\" \"rsm\"))\n+\t\t(match_operand:DI 2 \"\" \"\")))\n+     (unspec [(const_int 0)] UNSPEC_MS_TO_SYSV_CALL)\n+     (clobber (reg:TI XMM6_REG))\n+     (clobber (reg:TI XMM7_REG))\n+     (clobber (reg:TI XMM8_REG))\n+     (clobber (reg:TI XMM9_REG))\n+     (clobber (reg:TI XMM10_REG))\n+     (clobber (reg:TI XMM11_REG))\n+     (clobber (reg:TI XMM12_REG))\n+     (clobber (reg:TI XMM13_REG))\n+     (clobber (reg:TI XMM14_REG))\n+     (clobber (reg:TI XMM15_REG))\n+     (clobber (reg:DI SI_REG))\n+     (clobber (reg:DI DI_REG))])\n+   (unspec [(match_operand 3 \"const_int_operand\" \"\")]\n+   \t   UNSPEC_CALL_NEEDS_VZEROUPPER)]\n+  \"TARGET_VZEROUPPER && TARGET_64BIT && !SIBLING_CALL_P (insn)\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+  \"ix86_split_call_vzeroupper (curr_insn, operands[3]); DONE;\"\n+  [(set_attr \"type\" \"callv\")])\n+\n (define_insn \"*call_value_1_rex64_ms_sysv\"\n   [(set (match_operand 0 \"\" \"\")\n \t(call (mem:QI (match_operand:DI 1 \"call_insn_operand\" \"rsm\"))\n@@ -17239,6 +17552,19 @@\n   { return ix86_output_call_insn (insn, operands[1], 1); }\n   [(set_attr \"type\" \"callv\")])\n \n+(define_insn_and_split \"*call_value_1_rex64_large_vzeroupper\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (mem:QI (match_operand:DI 1 \"call_insn_operand\" \"rm\"))\n+\t      (match_operand:DI 2 \"\" \"\")))\n+   (unspec [(match_operand 3 \"const_int_operand\" \"\")]\n+   \t   UNSPEC_CALL_NEEDS_VZEROUPPER)]\n+  \"TARGET_VZEROUPPER && TARGET_64BIT && !SIBLING_CALL_P (insn)\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+  \"ix86_split_call_vzeroupper (curr_insn, operands[3]); DONE;\"\n+  [(set_attr \"type\" \"callv\")])\n+\n (define_insn \"*call_value_1_rex64_large\"\n   [(set (match_operand 0 \"\" \"\")\n \t(call (mem:QI (match_operand:DI 1 \"call_insn_operand\" \"rm\"))\n@@ -17247,6 +17573,19 @@\n   { return ix86_output_call_insn (insn, operands[1], 1); }\n   [(set_attr \"type\" \"callv\")])\n \n+(define_insn_and_split \"*sibcall_value_1_rex64_vzeroupper\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (mem:QI (match_operand:DI 1 \"sibcall_insn_operand\" \"s,U\"))\n+\t      (match_operand:DI 2 \"\" \"\")))\n+   (unspec [(match_operand 3 \"const_int_operand\" \"\")]\n+   \t   UNSPEC_CALL_NEEDS_VZEROUPPER)]\n+  \"TARGET_VZEROUPPER && TARGET_64BIT && SIBLING_CALL_P (insn)\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+  \"ix86_split_call_vzeroupper (curr_insn, operands[3]); DONE;\"\n+  [(set_attr \"type\" \"callv\")])\n+\n (define_insn \"*sibcall_value_1_rex64\"\n   [(set (match_operand 0 \"\" \"\")\n \t(call (mem:QI (match_operand:DI 1 \"sibcall_insn_operand\" \"s,U\"))"}, {"sha": "c4841177d2b359cff0830944d47c4f1a40214ecd", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfec3a7c5e9924bbc5c756f8ba94b137f180845d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfec3a7c5e9924bbc5c756f8ba94b137f180845d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cfec3a7c5e9924bbc5c756f8ba94b137f180845d", "patch": "@@ -1,3 +1,13 @@\n+2010-11-02  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\t* gcc.target/i386/avx-vzeroupper-15.c: New.\n+\t* gcc.target/i386/avx-vzeroupper-16.c: Likewise.\n+\t* gcc.target/i386/avx-vzeroupper-17.c: Likewise.\n+\t* gcc.target/i386/avx-vzeroupper-18.c: Likewise.\n+\n+\tPR target/46253\n+\t* gcc.target/i386/pr46253.c: New.\n+\n 2010-11-02  Steven G. Kargl  < kargl@gcc.gnu.org>\n \t    Tobias Burnus  <burnus@net-b.de>\n "}, {"sha": "134a3dd09ab4457db521fe98a17e0f0069b246a2", "filename": "gcc/testsuite/gcc.target/i386/avx-vzeroupper-15.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfec3a7c5e9924bbc5c756f8ba94b137f180845d/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfec3a7c5e9924bbc5c756f8ba94b137f180845d/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-15.c?ref=cfec3a7c5e9924bbc5c756f8ba94b137f180845d", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -mavx -mtune=generic -dp\" } */\n+\n+#include <immintrin.h>\n+\n+extern __m256 x, y;\n+extern void (*bar) (void);\n+\n+void\n+foo ()\n+{\n+  x = y;\n+  bar ();\n+}\n+\n+/* { dg-final { scan-assembler-times \"avx_vzeroupper\" 1 } } */"}, {"sha": "3fb099de75cb4d4d3c485fa5a1a3df5fd1dc640e", "filename": "gcc/testsuite/gcc.target/i386/avx-vzeroupper-16.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfec3a7c5e9924bbc5c756f8ba94b137f180845d/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfec3a7c5e9924bbc5c756f8ba94b137f180845d/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-16.c?ref=cfec3a7c5e9924bbc5c756f8ba94b137f180845d", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-options \"-O0 -mavx -mabi=ms -mtune=generic -dp\" } */\n+\n+typedef float __m256 __attribute__ ((__vector_size__ (32), __may_alias__));\n+\n+extern __m256 x;\n+\n+extern __m256 __attribute__ ((sysv_abi))  bar (__m256);\n+\n+void\n+foo (void)\n+{\n+  bar (x);\n+}\n+\n+/* { dg-final { scan-assembler-times \"avx_vzeroupper\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\\\*call_value_0_rex64_ms_sysv\" 1 } } */"}, {"sha": "2f3cfd2e2770219476ed1d2acd30d06f3b66f214", "filename": "gcc/testsuite/gcc.target/i386/avx-vzeroupper-17.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfec3a7c5e9924bbc5c756f8ba94b137f180845d/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfec3a7c5e9924bbc5c756f8ba94b137f180845d/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-17.c?ref=cfec3a7c5e9924bbc5c756f8ba94b137f180845d", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-options \"-O0 -mavx -mabi=ms -mtune=generic -dp\" } */\n+\n+typedef float __m256 __attribute__ ((__vector_size__ (32), __may_alias__));\n+\n+extern __m256 x;\n+\n+extern __m256 __attribute__ ((sysv_abi)) (*bar) (__m256);\n+\n+void\n+foo (void)\n+{\n+  bar (x);\n+}\n+\n+/* { dg-final { scan-assembler-times \"avx_vzeroupper\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\\\*call_value_1_rex64_ms_sysv\" 1 } } */"}, {"sha": "541f77d767588c3a59d58eb73a8b8a31f9a993a5", "filename": "gcc/testsuite/gcc.target/i386/avx-vzeroupper-18.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfec3a7c5e9924bbc5c756f8ba94b137f180845d/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfec3a7c5e9924bbc5c756f8ba94b137f180845d/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-18.c?ref=cfec3a7c5e9924bbc5c756f8ba94b137f180845d", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-options \"-O0 -mavx -mabi=ms -mtune=generic -dp\" } */\n+\n+typedef float __m256 __attribute__ ((__vector_size__ (32), __may_alias__));\n+\n+extern __m256 x;\n+\n+extern void __attribute__ ((sysv_abi))  bar (__m256);\n+\n+void\n+foo (void)\n+{\n+  bar (x);\n+}\n+\n+/* { dg-final { scan-assembler-not \"avx_vzeroupper\" } } */\n+/* { dg-final { scan-assembler-times \"\\\\*call_1_rex64_ms_sysv\" 1 } } */"}, {"sha": "406790aba6e99e5ab1dfbb5439cb5c77ef541396", "filename": "gcc/testsuite/gcc.target/i386/pr46253.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfec3a7c5e9924bbc5c756f8ba94b137f180845d/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr46253.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfec3a7c5e9924bbc5c756f8ba94b137f180845d/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr46253.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr46253.c?ref=cfec3a7c5e9924bbc5c756f8ba94b137f180845d", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -g -mf16c -mtune=generic -dp\" } */\n+\n+typedef __m256i __attribute__ ((__vector_size__ (32)));\n+\n+__m256i bar (void);\n+void foo (void)\n+{\n+  int i = 0;\n+  bar ();\n+  __builtin_ia32_vzeroupper ();\n+  while (++i);\n+}\n+\n+/* { dg-final { scan-assembler-times \"avx_vzeroupper\" 1 } } */"}]}