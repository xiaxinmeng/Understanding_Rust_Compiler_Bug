{"sha": "d037d9ad323ec9eef3e50c6e2cbc1e31191daa5d", "node_id": "C_kwDOANBUbNoAKGQwMzdkOWFkMzIzZWM5ZWVmM2U1MGM2ZTJjYmMxZTMxMTkxZGFhNWQ", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2022-04-06T07:56:07Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2022-04-06T07:56:07Z"}, "message": "vect: Fix mask handling for SLP gathers [PR103761]\n\ncheck_load_store_for_partial_vectors predates the support for SLP\ngathers and so had a hard-coded assumption that gathers/scatters\n(and load/stores lanes) would be non-SLP operations.  This patch\npasses down the slp_node so that the routine can work out how\nmany vectors are needed in both the SLP and non-SLP cases.\n\ngcc/\n\tPR tree-optimization/103761\n\t* tree-vect-stmts.cc (check_load_store_for_partial_vectors): Replace\n\tthe ncopies parameter with an slp_node parameter.  Calculate the\n\tnumber of vectors based on it and vectype.  Rename lambda to\n\tgroup_memory_nvectors.\n\t(vectorizable_store, vectorizable_load): Update calls accordingly.\n\ngcc/testsuite/\n\tPR tree-optimization/103761\n\t* gcc.dg/vect/pr103761.c: New test.\n\t* gcc.target/aarch64/sve/pr103761.c: Likewise.", "tree": {"sha": "0be7d39ffefc8d74f893438bd6d011711a2ff925", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0be7d39ffefc8d74f893438bd6d011711a2ff925"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d037d9ad323ec9eef3e50c6e2cbc1e31191daa5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d037d9ad323ec9eef3e50c6e2cbc1e31191daa5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d037d9ad323ec9eef3e50c6e2cbc1e31191daa5d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d037d9ad323ec9eef3e50c6e2cbc1e31191daa5d/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f0d29224558e1d625a3d0d13019e2059c56f5b82", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0d29224558e1d625a3d0d13019e2059c56f5b82", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0d29224558e1d625a3d0d13019e2059c56f5b82"}], "stats": {"total": 63, "additions": 50, "deletions": 13}, "files": [{"sha": "0982a63eb6abe0d45533617d769d151eabb3e602", "filename": "gcc/testsuite/gcc.dg/vect/pr103761.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d037d9ad323ec9eef3e50c6e2cbc1e31191daa5d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr103761.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d037d9ad323ec9eef3e50c6e2cbc1e31191daa5d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr103761.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr103761.c?ref=d037d9ad323ec9eef3e50c6e2cbc1e31191daa5d", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+\n+void f(long *restrict x, int *restrict y, short *restrict z, int *restrict a)\n+{\n+  for (int i = 0; i < 100; i += 4)\n+    {\n+      x[i] = (long) y[z[i]] + 1;\n+      x[i + 1] = (long) y[z[i + 1]] + 2;\n+      x[i + 2] = (long) y[z[i + 2]] + 3;\n+      x[i + 3] = (long) y[z[i + 3]] + 4;\n+      a[i] += 1;\n+    }\n+}"}, {"sha": "001b4d407abd5ee3786703bc52a3fb0d6e7eda0f", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pr103761.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d037d9ad323ec9eef3e50c6e2cbc1e31191daa5d/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpr103761.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d037d9ad323ec9eef3e50c6e2cbc1e31191daa5d/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpr103761.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpr103761.c?ref=d037d9ad323ec9eef3e50c6e2cbc1e31191daa5d", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-options \"-O3\" } */\n+\n+void f(long *restrict x, int *restrict y, short *restrict z, int *restrict a)\n+{\n+  for (int i = 0; i < 100; i += 4)\n+    {\n+      x[i] = (long) y[z[i]] + 1;\n+      x[i + 1] = (long) y[z[i + 1]] + 2;\n+      x[i + 2] = (long) y[z[i + 2]] + 3;\n+      x[i + 3] = (long) y[z[i + 3]] + 4;\n+      a[i] += 1;\n+    }\n+}"}, {"sha": "c0107c8c489ac2dc173a4ba0633798ec61fe73da", "filename": "gcc/tree-vect-stmts.cc", "status": "modified", "additions": 24, "deletions": 13, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d037d9ad323ec9eef3e50c6e2cbc1e31191daa5d/gcc%2Ftree-vect-stmts.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d037d9ad323ec9eef3e50c6e2cbc1e31191daa5d/gcc%2Ftree-vect-stmts.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.cc?ref=d037d9ad323ec9eef3e50c6e2cbc1e31191daa5d", "patch": "@@ -1690,7 +1690,8 @@ static tree permute_vec_elements (vec_info *, tree, tree, tree, stmt_vec_info,\n    as well as whether the target does.\n \n    VLS_TYPE says whether the statement is a load or store and VECTYPE\n-   is the type of the vector being loaded or stored.  MEMORY_ACCESS_TYPE\n+   is the type of the vector being loaded or stored.  SLP_NODE is the SLP\n+   node that contains the statement, or null if none.  MEMORY_ACCESS_TYPE\n    says how the load or store is going to be implemented and GROUP_SIZE\n    is the number of load or store statements in the containing group.\n    If the access is a gather load or scatter store, GS_INFO describes\n@@ -1703,18 +1704,24 @@ static tree permute_vec_elements (vec_info *, tree, tree, tree, stmt_vec_info,\n \n static void\n check_load_store_for_partial_vectors (loop_vec_info loop_vinfo, tree vectype,\n+\t\t\t\t      slp_tree slp_node,\n \t\t\t\t      vec_load_store_type vls_type,\n \t\t\t\t      int group_size,\n \t\t\t\t      vect_memory_access_type\n \t\t\t\t      memory_access_type,\n-\t\t\t\t      unsigned int ncopies,\n \t\t\t\t      gather_scatter_info *gs_info,\n \t\t\t\t      tree scalar_mask)\n {\n   /* Invariant loads need no special support.  */\n   if (memory_access_type == VMAT_INVARIANT)\n     return;\n \n+  unsigned int nvectors;\n+  if (slp_node)\n+    nvectors = SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node);\n+  else\n+    nvectors = vect_get_num_copies (loop_vinfo, vectype);\n+\n   vec_loop_masks *masks = &LOOP_VINFO_MASKS (loop_vinfo);\n   machine_mode vecmode = TYPE_MODE (vectype);\n   bool is_load = (vls_type == VLS_LOAD);\n@@ -1732,7 +1739,8 @@ check_load_store_for_partial_vectors (loop_vec_info loop_vinfo, tree vectype,\n \t  LOOP_VINFO_CAN_USE_PARTIAL_VECTORS_P (loop_vinfo) = false;\n \t  return;\n \t}\n-      vect_record_loop_mask (loop_vinfo, masks, ncopies, vectype, scalar_mask);\n+      vect_record_loop_mask (loop_vinfo, masks, nvectors, vectype,\n+\t\t\t     scalar_mask);\n       return;\n     }\n \n@@ -1754,7 +1762,8 @@ check_load_store_for_partial_vectors (loop_vec_info loop_vinfo, tree vectype,\n \t  LOOP_VINFO_CAN_USE_PARTIAL_VECTORS_P (loop_vinfo) = false;\n \t  return;\n \t}\n-      vect_record_loop_mask (loop_vinfo, masks, ncopies, vectype, scalar_mask);\n+      vect_record_loop_mask (loop_vinfo, masks, nvectors, vectype,\n+\t\t\t     scalar_mask);\n       return;\n     }\n \n@@ -1784,7 +1793,7 @@ check_load_store_for_partial_vectors (loop_vec_info loop_vinfo, tree vectype,\n   /* We might load more scalars than we need for permuting SLP loads.\n      We checked in get_group_load_store_type that the extra elements\n      don't leak into a new vector.  */\n-  auto get_valid_nvectors = [] (poly_uint64 size, poly_uint64 nunits)\n+  auto group_memory_nvectors = [](poly_uint64 size, poly_uint64 nunits)\n   {\n     unsigned int nvectors;\n     if (can_div_away_from_zero_p (size, nunits, &nvectors))\n@@ -1799,15 +1808,15 @@ check_load_store_for_partial_vectors (loop_vec_info loop_vinfo, tree vectype,\n   if (targetm.vectorize.get_mask_mode (vecmode).exists (&mask_mode)\n       && can_vec_mask_load_store_p (vecmode, mask_mode, is_load))\n     {\n-      unsigned int nvectors = get_valid_nvectors (group_size * vf, nunits);\n+      nvectors = group_memory_nvectors (group_size * vf, nunits);\n       vect_record_loop_mask (loop_vinfo, masks, nvectors, vectype, scalar_mask);\n       using_partial_vectors_p = true;\n     }\n \n   machine_mode vmode;\n   if (get_len_load_store_mode (vecmode, is_load).exists (&vmode))\n     {\n-      unsigned int nvectors = get_valid_nvectors (group_size * vf, nunits);\n+      nvectors = group_memory_nvectors (group_size * vf, nunits);\n       vec_loop_lens *lens = &LOOP_VINFO_LENS (loop_vinfo);\n       unsigned factor = (vecmode == vmode) ? 1 : GET_MODE_UNIT_SIZE (vecmode);\n       vect_record_loop_len (loop_vinfo, lens, nvectors, vectype, factor);\n@@ -7571,9 +7580,10 @@ vectorizable_store (vec_info *vinfo,\n \n       if (loop_vinfo\n \t  && LOOP_VINFO_CAN_USE_PARTIAL_VECTORS_P (loop_vinfo))\n-\tcheck_load_store_for_partial_vectors (loop_vinfo, vectype, vls_type,\n-\t\t\t\t\t      group_size, memory_access_type,\n-\t\t\t\t\t      ncopies, &gs_info, mask);\n+\tcheck_load_store_for_partial_vectors (loop_vinfo, vectype, slp_node,\n+\t\t\t\t\t      vls_type, group_size,\n+\t\t\t\t\t      memory_access_type, &gs_info,\n+\t\t\t\t\t      mask);\n \n       if (slp_node\n \t  && !vect_maybe_update_slp_op_vectype (SLP_TREE_CHILDREN (slp_node)[0],\n@@ -8921,9 +8931,10 @@ vectorizable_load (vec_info *vinfo,\n \n       if (loop_vinfo\n \t  && LOOP_VINFO_CAN_USE_PARTIAL_VECTORS_P (loop_vinfo))\n-\tcheck_load_store_for_partial_vectors (loop_vinfo, vectype, VLS_LOAD,\n-\t\t\t\t\t      group_size, memory_access_type,\n-\t\t\t\t\t      ncopies, &gs_info, mask);\n+\tcheck_load_store_for_partial_vectors (loop_vinfo, vectype, slp_node,\n+\t\t\t\t\t      VLS_LOAD, group_size,\n+\t\t\t\t\t      memory_access_type, &gs_info,\n+\t\t\t\t\t      mask);\n \n       if (dump_enabled_p ()\n \t  && memory_access_type != VMAT_ELEMENTWISE"}]}