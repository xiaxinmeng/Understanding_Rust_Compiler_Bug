{"sha": "6c1657116a2c9cf7c0c14b6dfa7f8bbb7672d3c8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmMxNjU3MTE2YTJjOWNmN2MwYzE0YjZkZmE3ZjhiYmI3NjcyZDNjOA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2019-07-11T08:01:35Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-07-11T08:01:35Z"}, "message": "[Ada] New Repinfo.Input unit to read back JSON representation info.\n\nFor some time the Repinfo unit has been able to output the\nrepresentation information in the JSON data interchange format in\naddition to the usual text and binary formats.\n\nThe new Repinfo.Input unit makes it possible to read back this\ninformation under this format and make it available to clients, the main\none being ASIS.\n\nThe big advantage of using this approach over manipulating a binary blob\nis that the writer and the reader of the JSON representation need not be\nbinary compatible, i.e. in practice need not be the same version of the\ncompiler or ASIS for the same target.\n\nThe patch also adds a -gnatd_j switch to read back the information in\nthe compiler itself, which makes it easy to keep the writer and the\nreader in sync using only one tool, namely the compiler.  The typical\nusage is:\n\n  gcc -c p.ads -gnatR4js\n  gcc -c p.ads -gnatd_j\n\nto exercise respectively the writer and the reader from the compiler.\n\n2019-07-11  Eric Botcazou  <ebotcazou@adacore.com>\n\ngcc/ada/\n\n\t* alloc.ads (Rep_JSON_Table_Initial): New constant.\n\t(Rep_JSON_Table_Increment): Likewise.\n\t* debug.adb: Document -gnatd_j switch.\n\t* gcc-interface/Make-lang.in (GNAT_ADA_OBJS): Add\n\trepinfo-input.o.\n\t* gnat1drv.adb: Add with clause for Repinfo.Input.\n\tAdd with and use clauses for Sinput.\n\t(Read_JSON_Files_For_Repinfo): New procedure.\n\t(Gnat1drv1): Deal with -gnatd_j switch.\n\t* repinfo-input.ad[sb]: New unit.\n\t* snames.ads-tmpl (Name_Discriminant): New constant.\n\t(Name_Operands): Likewise.\n\nFrom-SVN: r273382", "tree": {"sha": "572be91ebc39f65aecaf91662cfea4f628aef40b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/572be91ebc39f65aecaf91662cfea4f628aef40b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6c1657116a2c9cf7c0c14b6dfa7f8bbb7672d3c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c1657116a2c9cf7c0c14b6dfa7f8bbb7672d3c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c1657116a2c9cf7c0c14b6dfa7f8bbb7672d3c8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c1657116a2c9cf7c0c14b6dfa7f8bbb7672d3c8/comments", "author": null, "committer": null, "parents": [{"sha": "ccf173059688499749a30b3252cc3c4ea4ab0d0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccf173059688499749a30b3252cc3c4ea4ab0d0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ccf173059688499749a30b3252cc3c4ea4ab0d0c"}], "stats": {"total": 1505, "additions": 1503, "deletions": 2}, "files": [{"sha": "48c72d6c92eff6f9ae9df205ebd68463c420fcdd", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c1657116a2c9cf7c0c14b6dfa7f8bbb7672d3c8/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c1657116a2c9cf7c0c14b6dfa7f8bbb7672d3c8/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=6c1657116a2c9cf7c0c14b6dfa7f8bbb7672d3c8", "patch": "@@ -1,3 +1,18 @@\n+2019-07-11  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* alloc.ads (Rep_JSON_Table_Initial): New constant.\n+\t(Rep_JSON_Table_Increment): Likewise.\n+\t* debug.adb: Document -gnatd_j switch.\n+\t* gcc-interface/Make-lang.in (GNAT_ADA_OBJS): Add\n+\trepinfo-input.o.\n+\t* gnat1drv.adb: Add with clause for Repinfo.Input.\n+\tAdd with and use clauses for Sinput.\n+\t(Read_JSON_Files_For_Repinfo): New procedure.\n+\t(Gnat1drv1): Deal with -gnatd_j switch.\n+\t* repinfo-input.ad[sb]: New unit.\n+\t* snames.ads-tmpl (Name_Discriminant): New constant.\n+\t(Name_Operands): Likewise.\n+\n 2019-07-11  Justin Squirek  <squirek@adacore.com>\n \n \t* checks.adb (Apply_Accessibility_Check): Add check for constant"}, {"sha": "f5faecb1c50e9efda2db35759fec15a88ab55ec3", "filename": "gcc/ada/alloc.ads", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c1657116a2c9cf7c0c14b6dfa7f8bbb7672d3c8/gcc%2Fada%2Falloc.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c1657116a2c9cf7c0c14b6dfa7f8bbb7672d3c8/gcc%2Fada%2Falloc.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Falloc.ads?ref=6c1657116a2c9cf7c0c14b6dfa7f8bbb7672d3c8", "patch": "@@ -116,6 +116,9 @@ package Alloc is\n    Rep_Table_Initial                : constant := 1000;       -- Repinfo\n    Rep_Table_Increment              : constant := 200;\n \n+   Rep_JSON_Table_Initial           : constant := 10;          -- Repinfo\n+   Rep_JSON_Table_Increment         : constant := 200;\n+\n    Scope_Stack_Initial              : constant := 10;         -- Sem\n    Scope_Stack_Increment            : constant := 200;\n "}, {"sha": "6df3d6fab9cfc8089fcf620f90b09f96fdff66c8", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c1657116a2c9cf7c0c14b6dfa7f8bbb7672d3c8/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c1657116a2c9cf7c0c14b6dfa7f8bbb7672d3c8/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=6c1657116a2c9cf7c0c14b6dfa7f8bbb7672d3c8", "patch": "@@ -154,7 +154,7 @@ package body Debug is\n    --  d_g\n    --  d_h\n    --  d_i  Ignore activations and calls to instances for elaboration\n-   --  d_j\n+   --  d_j  Read JSON files and populate Repinfo tables (opposite of -gnatRjs)\n    --  d_k\n    --  d_l\n    --  d_m\n@@ -988,6 +988,10 @@ package body Debug is\n    --       subprogram or task type defined in an external instance for both\n    --       the static and dynamic elaboration models.\n \n+   --  d_j  The compiler reads JSON files that would be generated by the same\n+   --       compilation session if -gnatRjs was passed, in order to populate\n+   --       the internal tables of the Repinfo unit from them.\n+\n    --  d_p  The compiler ignores calls to subprograms which verify the run-time\n    --       semantics of invariants and postconditions in both the static and\n    --       dynamic elaboration models."}, {"sha": "b6a337a1091995f097699199eae9081c76ad2cb0", "filename": "gcc/ada/gcc-interface/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c1657116a2c9cf7c0c14b6dfa7f8bbb7672d3c8/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c1657116a2c9cf7c0c14b6dfa7f8bbb7672d3c8/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMake-lang.in?ref=6c1657116a2c9cf7c0c14b6dfa7f8bbb7672d3c8", "patch": "@@ -355,6 +355,7 @@ GNAT_ADA_OBJS =\t\\\n  ada/prep.o\t\\\n  ada/prepcomp.o\t\\\n  ada/put_scos.o\t\\\n+ ada/repinfo-input.o\t\\\n  ada/repinfo.o\t\\\n  ada/restrict.o\t\\\n  ada/rident.o\t\\"}, {"sha": "2e4204b472bea83f3ec0d319dbd4a176bb4087f1", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 46, "deletions": 1, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c1657116a2c9cf7c0c14b6dfa7f8bbb7672d3c8/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c1657116a2c9cf7c0c14b6dfa7f8bbb7672d3c8/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=6c1657116a2c9cf7c0c14b6dfa7f8bbb7672d3c8", "patch": "@@ -51,6 +51,7 @@ with Output;    use Output;\n with Par_SCO;\n with Prepcomp;\n with Repinfo;\n+with Repinfo.Input;\n with Restrict;\n with Rident;    use Rident;\n with Rtsfind;\n@@ -66,6 +67,7 @@ with Sem_SPARK; use Sem_SPARK;\n with Sem_Type;\n with Set_Targ;\n with Sinfo;     use Sinfo;\n+with Sinput;    use Sinput;\n with Sinput.L;  use Sinput.L;\n with Snames;    use Snames;\n with Sprint;    use Sprint;\n@@ -114,6 +116,12 @@ procedure Gnat1drv is\n    --  the information provided by the back end in back annotation of declared\n    --  entities (e.g. actual size and alignment values chosen by the back end).\n \n+   procedure Read_JSON_Files_For_Repinfo;\n+   --  This procedure exercises the JSON parser of Repinfo by reading back the\n+   --  JSON files generated by -gnatRjs in a previous compilation session. It\n+   --  is intended to make sure that the JSON generator and the JSON parser are\n+   --  kept synchronized when the JSON format evolves.\n+\n    ----------------------------\n    -- Adjust_Global_Switches --\n    ----------------------------\n@@ -1037,6 +1045,38 @@ procedure Gnat1drv is\n       --  end if;\n    end Post_Compilation_Validation_Checks;\n \n+   -----------------------------------\n+   --  Read_JSON_Files_For_Repinfo  --\n+   -----------------------------------\n+\n+   procedure Read_JSON_Files_For_Repinfo is\n+   begin\n+      --  This is the same loop construct as in Repinfo.List_Rep_Info\n+\n+      for U in Main_Unit .. Last_Unit loop\n+         if In_Extended_Main_Source_Unit (Cunit_Entity (U)) then\n+            declare\n+               Nam : constant String :=\n+                     Get_Name_String (File_Name (Source_Index (U))) & \".json\";\n+               Namid : constant File_Name_Type := Name_Enter (Nam);\n+               Index : constant Source_File_Index := Load_Config_File (Namid);\n+\n+            begin\n+               if Index = No_Source_File then\n+                  Write_Str (\"cannot locate \");\n+                  Write_Line (Nam);\n+                  raise Unrecoverable_Error;\n+               end if;\n+\n+               Repinfo.Input.Read_JSON_Stream (Source_Text (Index).all, Nam);\n+            exception\n+               when Repinfo.Input.Invalid_JSON_Stream =>\n+                  raise Unrecoverable_Error;\n+            end;\n+         end if;\n+      end loop;\n+   end Read_JSON_Files_For_Repinfo;\n+\n    --  Local variables\n \n    Back_End_Mode : Back_End.Back_End_Mode_Type;\n@@ -1103,7 +1143,6 @@ begin\n          --  Acquire target parameters from system.ads (package System source)\n \n          Targparm_Acquire : declare\n-            use Sinput;\n \n             S : Source_File_Index;\n             N : File_Name_Type;\n@@ -1571,6 +1610,12 @@ begin\n          Par_SCO.SCO_Record_Filtered;\n       end if;\n \n+      --  If -gnatd_j is specified, exercise the JSON parser of Repinfo\n+\n+      if Debug_Flag_Underscore_J then\n+         Read_JSON_Files_For_Repinfo;\n+      end if;\n+\n       --  Back end needs to explicitly unlock tables it needs to touch\n \n       Atree.Lock;"}, {"sha": "92ca5101fe7da4d7c0c81338f7c47b3ae0ce53e7", "filename": "gcc/ada/repinfo-input.adb", "status": "added", "additions": 1350, "deletions": 0, "changes": 1350, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c1657116a2c9cf7c0c14b6dfa7f8bbb7672d3c8/gcc%2Fada%2Frepinfo-input.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c1657116a2c9cf7c0c14b6dfa7f8bbb7672d3c8/gcc%2Fada%2Frepinfo-input.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frepinfo-input.adb?ref=6c1657116a2c9cf7c0c14b6dfa7f8bbb7672d3c8", "patch": "@@ -0,0 +1,1350 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                         R E P I N F O - I N P U T                        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 2018-2019, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Alloc;\n+with Csets;    use Csets;\n+with Hostparm; use Hostparm;\n+with Namet;    use Namet;\n+with Output;   use Output;\n+with Snames;   use Snames;\n+with Table;\n+\n+package body Repinfo.Input is\n+\n+   SSU : constant := 8;\n+   --  Value for Storage_Unit, we do not want to get this from TTypes, since\n+   --  this introduces problematic dependencies in ASIS, and in any case this\n+   --  value is assumed to be 8 for the implementation of the DDA.\n+\n+   type JSON_Entity_Kind is (JE_Record_Type, JE_Array_Type, JE_Other);\n+   --  Kind of an entiy\n+\n+   type JSON_Entity_Node (Kind : JSON_Entity_Kind := JE_Other) is record\n+      Esize   : Node_Ref_Or_Val;\n+      RM_Size : Node_Ref_Or_Val;\n+      case Kind is\n+         when JE_Record_Type => Variant        : Nat;\n+         when JE_Array_Type  => Component_Size : Node_Ref_Or_Val;\n+         when JE_Other       => Dummy          : Boolean;\n+      end case;\n+   end record;\n+   pragma Unchecked_Union (JSON_Entity_Node);\n+   --  Record to represent an entity\n+\n+   package JSON_Entity_Table is new Table.Table (\n+      Table_Component_Type => JSON_Entity_Node,\n+      Table_Index_Type     => Nat,\n+      Table_Low_Bound      => 1,\n+      Table_Initial        => Alloc.Rep_JSON_Table_Initial,\n+      Table_Increment      => Alloc.Rep_JSON_Table_Increment,\n+      Table_Name           => \"JSON_Entity_Table\");\n+   --  Table of entities\n+\n+   type JSON_Component_Node is record\n+      Bit_Offset : Node_Ref_Or_Val;\n+      Esize      : Node_Ref_Or_Val;\n+   end record;\n+   --  Record to represent a component\n+\n+   package JSON_Component_Table is new Table.Table (\n+      Table_Component_Type => JSON_Component_Node,\n+      Table_Index_Type     => Nat,\n+      Table_Low_Bound      => 1,\n+      Table_Initial        => Alloc.Rep_JSON_Table_Initial,\n+      Table_Increment      => Alloc.Rep_JSON_Table_Increment,\n+      Table_Name           => \"JSON_Component_Table\");\n+   --  Table of components\n+\n+   type JSON_Variant_Node is record\n+      Present : Node_Ref_Or_Val;\n+      Variant : Nat;\n+      Next    : Nat;\n+   end record;\n+   --  Record to represent a variant\n+\n+   package JSON_Variant_Table is new Table.Table (\n+      Table_Component_Type => JSON_Variant_Node,\n+      Table_Index_Type     => Nat,\n+      Table_Low_Bound      => 1,\n+      Table_Initial        => Alloc.Rep_JSON_Table_Initial,\n+      Table_Increment      => Alloc.Rep_JSON_Table_Increment,\n+      Table_Name           => \"JSON_Variant_Table\");\n+   --  Table of variants\n+\n+   -------------------------------------\n+   --  Get_JSON_Component_Bit_Offset  --\n+   -------------------------------------\n+\n+   function Get_JSON_Component_Bit_Offset\n+     (Name        : String;\n+      Record_Name : String) return Node_Ref_Or_Val\n+   is\n+      Namid : constant Valid_Name_Id := Name_Find (Record_Name & '.' & Name);\n+      Index : constant Int := Get_Name_Table_Int (Namid);\n+\n+   begin\n+      --  Return No_Uint if no information is available for the component\n+\n+      if Index = 0 then\n+         return No_Uint;\n+      end if;\n+\n+      return JSON_Component_Table.Table (Index).Bit_Offset;\n+   end Get_JSON_Component_Bit_Offset;\n+\n+   -------------------------------\n+   --  Get_JSON_Component_Size  --\n+   -------------------------------\n+\n+   function Get_JSON_Component_Size (Name : String) return Node_Ref_Or_Val is\n+      Namid : constant Valid_Name_Id := Name_Find (Name);\n+      Index : constant Int := Get_Name_Table_Int (Namid);\n+\n+   begin\n+      --  Return No_Uint if no information is available for the component\n+\n+      if Index = 0 then\n+         return No_Uint;\n+      end if;\n+\n+      return JSON_Entity_Table.Table (Index).Component_Size;\n+   end Get_JSON_Component_Size;\n+\n+   ----------------------\n+   --  Get_JSON_Esize  --\n+   ----------------------\n+\n+   function Get_JSON_Esize (Name : String) return Node_Ref_Or_Val is\n+      Namid : constant Valid_Name_Id := Name_Find (Name);\n+      Index : constant Int := Get_Name_Table_Int (Namid);\n+\n+   begin\n+      --  Return No_Uint if no information is available for the entity\n+\n+      if Index = 0 then\n+         return No_Uint;\n+      end if;\n+\n+      return JSON_Entity_Table.Table (Index).Esize;\n+   end Get_JSON_Esize;\n+\n+   ----------------------\n+   --  Get_JSON_Esize  --\n+   ----------------------\n+\n+   function Get_JSON_Esize\n+     (Name        : String;\n+      Record_Name : String) return Node_Ref_Or_Val\n+   is\n+      Namid : constant Valid_Name_Id := Name_Find (Record_Name & '.' & Name);\n+      Index : constant Int := Get_Name_Table_Int (Namid);\n+\n+   begin\n+      --  Return No_Uint if no information is available for the entity\n+\n+      if Index = 0 then\n+         return No_Uint;\n+      end if;\n+\n+      return JSON_Component_Table.Table (Index).Esize;\n+   end Get_JSON_Esize;\n+\n+   ------------------------\n+   --  Get_JSON_RM_Size  --\n+   ------------------------\n+\n+   function Get_JSON_RM_Size (Name : String) return Node_Ref_Or_Val is\n+      Namid : constant Valid_Name_Id := Name_Find (Name);\n+      Index : constant Int := Get_Name_Table_Int (Namid);\n+\n+   begin\n+      --  Return No_Uint if no information is available for the entity\n+\n+      if Index = 0 then\n+         return No_Uint;\n+      end if;\n+\n+      return JSON_Entity_Table.Table (Index).RM_Size;\n+   end Get_JSON_RM_Size;\n+\n+   -----------------------\n+   --  Read_JSON_Stream --\n+   -----------------------\n+\n+   procedure Read_JSON_Stream (Text : Text_Buffer; File_Name : String) is\n+\n+      type Text_Position is record\n+         Index  : Text_Ptr := 0;\n+         Line   : Natural := 0;\n+         Column : Natural := 0;\n+      end record;\n+      --  Record to represent position in the text\n+\n+      type Token_Kind is\n+        (J_NULL,\n+         J_TRUE,\n+         J_FALSE,\n+         J_NUMBER,\n+         J_INTEGER,\n+         J_STRING,\n+         J_ARRAY,\n+         J_OBJECT,\n+         J_ARRAY_END,\n+         J_OBJECT_END,\n+         J_COMMA,\n+         J_COLON,\n+         J_EOF);\n+      --  JSON Token kind. Note that in ECMA 404 there is no notion of integer.\n+      --  Only numbers are supported. In our implementation we return J_INTEGER\n+      --  if there is no decimal part in the number. The semantic is that this\n+      --  is a J_NUMBER token that might be represented as an integer. Special\n+      --  token J_EOF means that end of stream has been reached.\n+\n+      function Decode_Integer (Lo, Hi : Text_Ptr) return Uint;\n+      --  Decode and return the integer in Text (Lo .. Hi)\n+\n+      function Decode_Name (Lo, Hi : Text_Ptr) return Valid_Name_Id;\n+      --  Decode and return the name in Text (Lo .. Hi)\n+\n+      function Decode_Symbol (Lo, Hi : Text_Ptr) return TCode;\n+      --  Decode and return the expression symbol in Text (Lo .. Hi)\n+\n+      procedure Error (Msg : String);\n+      pragma No_Return (Error);\n+      --  Print an error message and raise an exception\n+\n+      procedure Read_Entity;\n+      --  Read an entity\n+\n+      function Read_Name return Valid_Name_Id;\n+      --  Read a name\n+\n+      function Read_Name_With_Prefix return Valid_Name_Id;\n+      --  Read a name and prepend a prefix\n+\n+      function Read_Number return Uint;\n+      --  Read a number\n+\n+      function Read_Numerical_Expr return Node_Ref_Or_Val;\n+      --  Read a numerical expression\n+\n+      procedure Read_Record;\n+      --  Read a record\n+\n+      function Read_String return Valid_Name_Id;\n+      --  Read a string\n+\n+      procedure Read_Token\n+        (Kind        : out Token_Kind;\n+         Token_Start : out Text_Position;\n+         Token_End   : out Text_Position);\n+      --  Read a token and return it (this is a standard JSON lexer)\n+\n+      procedure Read_Token_And_Error\n+        (TK          : Token_Kind;\n+         Token_Start : out Text_Position;\n+         Token_End   : out Text_Position);\n+      pragma Inline (Read_Token_And_Error);\n+      --  Read a specified token and error out on failure\n+\n+      function Read_Variant_Part return Nat;\n+      --  Read a variant part\n+\n+      procedure Skip_Value;\n+      --  Skip a value\n+\n+      Pos : Text_Position := (Text'First, 1, 1);\n+      --  The current position in the text buffer\n+\n+      Name_Buffer : Bounded_String (4 * Max_Name_Length);\n+      --  The buffer used to build full qualifed names\n+\n+      Prefix_Len : Natural := 0;\n+      --  The length of the prefix present in Name_Buffer\n+\n+      ----------------------\n+      --  Decode_Integer  --\n+      ----------------------\n+\n+      function Decode_Integer (Lo, Hi : Text_Ptr) return Uint is\n+         Len  : constant Nat := Int (Hi) - Int (Lo) + 1;\n+\n+      begin\n+         --  Decode up to 9 characters manually, otherwise call into Uint\n+\n+         if Len < 10 then\n+            declare\n+               Val : Int := 0;\n+\n+            begin\n+               for J in Lo .. Hi loop\n+                  Val := Val * 10\n+                           + Character'Pos (Text (J)) - Character'Pos ('0');\n+               end loop;\n+               return UI_From_Int (Val);\n+            end;\n+\n+         else\n+            declare\n+               Val : Uint := Uint_0;\n+\n+            begin\n+               for J in Lo .. Hi loop\n+                  Val := Val * 10\n+                           + Character'Pos (Text (J)) - Character'Pos ('0');\n+               end loop;\n+               return Val;\n+            end;\n+         end if;\n+      end Decode_Integer;\n+\n+      -------------------\n+      --  Decode_Name  --\n+      -------------------\n+\n+      function Decode_Name (Lo, Hi : Text_Ptr) return Valid_Name_Id is\n+      begin\n+         --  Names are stored in lower case so fold them if need be\n+\n+         if Is_Upper_Case_Letter (Text (Lo)) then\n+            declare\n+               S : String (Integer (Lo) .. Integer (Hi));\n+\n+            begin\n+               for J in Lo .. Hi loop\n+                  S (Integer (J)) := Fold_Lower (Text (J));\n+               end loop;\n+\n+               return Name_Find (S);\n+            end;\n+\n+         else\n+            declare\n+               S : String (Integer (Lo) .. Integer (Hi));\n+               for S'Address use Text (Lo)'Address;\n+\n+            begin\n+               return Name_Find (S);\n+            end;\n+         end if;\n+      end Decode_Name;\n+\n+      ---------------------\n+      --  Decode_Symbol  --\n+      ---------------------\n+\n+      function Decode_Symbol (Lo, Hi : Text_Ptr) return TCode is\n+\n+         function Cmp12 (A, B : Character) return Boolean;\n+         pragma Inline (Cmp12);\n+         --  Compare Text (Lo + 1 .. Lo + 2) with A & B.\n+\n+         -------------\n+         --  Cmp12  --\n+         -------------\n+\n+         function Cmp12 (A, B : Character) return Boolean is\n+         begin\n+            return Text (Lo + 1) = A and then Text (Lo + 2) = B;\n+         end Cmp12;\n+\n+         Len : constant Nat := Int (Hi) - Int (Lo) + 1;\n+\n+      --  Start of processing for Decode_Symbol\n+\n+      begin\n+         case Len is\n+            when 1 =>\n+               case Text (Lo) is\n+                  when '+' =>\n+                     return Plus_Expr;\n+                  when '-' =>\n+                     return Minus_Expr; -- or Negate_Expr\n+                  when '*' =>\n+                     return Mult_Expr;\n+                  when '<' =>\n+                     return Lt_Expr;\n+                  when '>' =>\n+                     return Gt_Expr;\n+                  when '&' =>\n+                     return Bit_And_Expr;\n+                  when '#' =>\n+                     return Discrim_Val;\n+                  when others =>\n+                     null;\n+               end case;\n+            when 2 =>\n+               if Text (Lo) = '/' then\n+                  case Text (Lo + 1) is\n+                     when 't' =>\n+                        return Trunc_Div_Expr;\n+                     when 'c' =>\n+                        return Ceil_Div_Expr;\n+                     when 'f' =>\n+                        return Floor_Div_Expr;\n+                     when 'e' =>\n+                        return Exact_Div_Expr;\n+                     when others =>\n+                        null;\n+                  end case;\n+               elsif Text (Lo + 1) = '=' then\n+                  case Text (Lo) is\n+                     when '<' =>\n+                        return Le_Expr;\n+                     when '>' =>\n+                        return Ge_Expr;\n+                     when '=' =>\n+                        return Eq_Expr;\n+                     when '!' =>\n+                        return Ne_Expr;\n+                     when others =>\n+                        null;\n+                  end case;\n+               elsif Text (Lo) = 'o' and then Text (Lo + 1) = 'r' then\n+                  return Truth_Or_Expr;\n+               end if;\n+            when 3 =>\n+               case Text (Lo) is\n+                  when '?' =>\n+                     if Cmp12 ('<', '>') then\n+                        return Cond_Expr;\n+                     end if;\n+                  when 'a' =>\n+                     if Cmp12 ('b', 's') then\n+                        return Abs_Expr;\n+                     elsif Cmp12 ('n', 'd') then\n+                        return Truth_And_Expr;\n+                     end if;\n+                  when 'm' =>\n+                     if Cmp12 ('a', 'x') then\n+                        return Max_Expr;\n+                     elsif Cmp12 ('i', 'n') then\n+                        return Min_Expr;\n+                     end if;\n+                  when 'n' =>\n+                     if Cmp12 ('o', 't') then\n+                        return Truth_Not_Expr;\n+                     end if;\n+                  when 'x' =>\n+                     if Cmp12 ('o', 'r') then\n+                        return Truth_Xor_Expr;\n+                     end if;\n+                  when 'v' =>\n+                     if Cmp12 ('a', 'r') then\n+                        return Dynamic_Val;\n+                     end if;\n+                  when others =>\n+                     null;\n+               end case;\n+            when 4 =>\n+               if Text (Lo) = 'm'\n+                 and then Text (Lo + 1) = 'o'\n+                 and then Text (Lo + 2) = 'd'\n+               then\n+                  case Text (Lo + 3) is\n+                     when 't' =>\n+                        return Trunc_Mod_Expr;\n+                     when 'c' =>\n+                        return Ceil_Mod_Expr;\n+                     when 'f' =>\n+                        return Floor_Mod_Expr;\n+                     when others =>\n+                        null;\n+                  end case;\n+               end if;\n+\n+               pragma Annotate\n+                 (CodePeer, Intentional,\n+                  \"condition predetermined\", \"Error called as defensive code\");\n+\n+            when others =>\n+               null;\n+         end case;\n+\n+         Error (\"unknown symbol\");\n+      end Decode_Symbol;\n+\n+      -----------\n+      -- Error --\n+      -----------\n+\n+      procedure Error (Msg : String) is\n+         L : constant String := Pos.Line'Img;\n+         C : constant String := Pos.Column'Img;\n+\n+      begin\n+         Set_Standard_Error;\n+         Write_Eol;\n+         Write_Str (File_Name);\n+         Write_Char (':');\n+         Write_Str (L (L'First + 1 .. L'Last));\n+         Write_Char (':');\n+         Write_Str (C (C'First + 1 .. C'Last));\n+         Write_Char (':');\n+         Write_Line (Msg);\n+         raise Invalid_JSON_Stream;\n+      end Error;\n+\n+      ------------------\n+      --  Read_Entity --\n+      ------------------\n+\n+      procedure Read_Entity is\n+         Ent         : JSON_Entity_Node;\n+         Nam         : Name_Id := No_Name;\n+         Siz         : Node_Ref_Or_Val;\n+         Token_Start : Text_Position;\n+         Token_End   : Text_Position;\n+         TK          : Token_Kind;\n+\n+      begin\n+         Ent.Esize          := No_Uint;\n+         Ent.RM_Size        := No_Uint;\n+         Ent.Component_Size := No_Uint;\n+\n+         --  Read the members as string : value pairs\n+\n+         loop\n+            case Read_String is\n+               when Name_Name =>\n+                  Nam := Read_Name;\n+               when Name_Record =>\n+                  if Nam = No_Name then\n+                     Error (\"name expected\");\n+                  end if;\n+                  Ent.Variant := 0;\n+                  Prefix_Len := Natural (Length_Of_Name (Nam));\n+                  Name_Buffer.Chars (1 .. Prefix_Len) := Get_Name_String (Nam);\n+                  Read_Record;\n+               when Name_Variant =>\n+                  Ent.Variant := Read_Variant_Part;\n+               when Name_Size =>\n+                  Siz := Read_Numerical_Expr;\n+                  Ent.Esize := Siz;\n+                  Ent.RM_Size := Siz;\n+               when Name_Object_Size =>\n+                  Ent.Esize := Read_Numerical_Expr;\n+               when Name_Value_Size =>\n+                  Ent.RM_Size := Read_Numerical_Expr;\n+               when Name_Component_Size =>\n+                  Ent.Component_Size := Read_Numerical_Expr;\n+               when others =>\n+                  Skip_Value;\n+            end case;\n+\n+            Read_Token (TK, Token_Start, Token_End);\n+            if TK = J_OBJECT_END then\n+               exit;\n+            elsif TK /= J_COMMA then\n+               Error (\"comma expected\");\n+            end if;\n+         end loop;\n+\n+         --  Store the entity into the table\n+\n+         JSON_Entity_Table.Append (Ent);\n+\n+         --  Associate the name with the entity\n+\n+         if Nam = No_Name then\n+            Error (\"name expected\");\n+         end if;\n+\n+         Set_Name_Table_Int (Nam, JSON_Entity_Table.Last);\n+      end Read_Entity;\n+\n+      -----------------\n+      --  Read_Name  --\n+      -----------------\n+\n+      function Read_Name return Valid_Name_Id is\n+         Token_Start : Text_Position;\n+         Token_End   : Text_Position;\n+\n+      begin\n+         --  Read a single string\n+\n+         Read_Token_And_Error (J_STRING, Token_Start, Token_End);\n+\n+         return Decode_Name (Token_Start.Index + 1, Token_End.Index - 1);\n+      end Read_Name;\n+\n+      -----------------------------\n+      --  Read_Name_With_Prefix  --\n+      -----------------------------\n+\n+      function Read_Name_With_Prefix return Valid_Name_Id is\n+         Len         : Natural;\n+         Lo, Hi      : Text_Ptr;\n+         Token_Start : Text_Position;\n+         Token_End   : Text_Position;\n+\n+      begin\n+         --  Read a single string\n+\n+         Read_Token_And_Error (J_STRING, Token_Start, Token_End);\n+         Lo := Token_Start.Index + 1;\n+         Hi := Token_End.Index - 1;\n+\n+         --  Prepare for the concatenation with the prefix\n+\n+         Len := Integer (Hi) - Integer (Lo) + 1;\n+         if Prefix_Len + 1 + Len > Name_Buffer.Max_Length then\n+            Error (\"Name buffer too small\");\n+         end if;\n+\n+         Name_Buffer.Length := Prefix_Len + 1 + Len;\n+         Name_Buffer.Chars (Prefix_Len + 1) := '.';\n+\n+         --  Names are stored in lower case so fold them if need be\n+\n+         if Is_Upper_Case_Letter (Text (Lo)) then\n+            for J in Lo .. Hi loop\n+               Name_Buffer.Chars (Prefix_Len + 2 + Integer (J - Lo)) :=\n+                                                         Fold_Lower (Text (J));\n+            end loop;\n+\n+         else\n+            declare\n+               S : String (Integer (Lo) .. Integer (Hi));\n+               for S'Address use Text (Lo)'Address;\n+\n+            begin\n+               Name_Buffer.Chars (Prefix_Len + 2 .. Prefix_Len + 1 + Len) := S;\n+            end;\n+         end if;\n+\n+         return Name_Find (Name_Buffer);\n+      end Read_Name_With_Prefix;\n+\n+      ------------------\n+      --  Read_Number --\n+      ------------------\n+\n+      function Read_Number return Uint is\n+         Token_Start : Text_Position;\n+         Token_End   : Text_Position;\n+\n+      begin\n+         --  Only integers are to be expected here\n+\n+         Read_Token_And_Error (J_INTEGER, Token_Start, Token_End);\n+\n+         return Decode_Integer (Token_Start.Index, Token_End.Index);\n+      end Read_Number;\n+\n+      --------------------------\n+      --  Read_Numerical_Expr --\n+      --------------------------\n+\n+      function Read_Numerical_Expr return Node_Ref_Or_Val is\n+         Code        : TCode;\n+         Nop         : Integer;\n+         Ops         : array (1 .. 3) of Node_Ref_Or_Val;\n+         TK          : Token_Kind;\n+         Token_Start : Text_Position;\n+         Token_End   : Text_Position;\n+\n+      begin\n+         --  Read either an integer or an expression\n+\n+         Read_Token (TK, Token_Start, Token_End);\n+         if TK = J_INTEGER then\n+            return Decode_Integer (Token_Start.Index, Token_End.Index);\n+\n+         elsif TK = J_OBJECT then\n+            --  Read the code of the expression and decode it\n+\n+            if Read_String /= Name_Code then\n+               Error (\"name expected\");\n+            end if;\n+\n+            Read_Token_And_Error (J_STRING, Token_Start, Token_End);\n+            Code := Decode_Symbol (Token_Start.Index + 1, Token_End.Index - 1);\n+            Read_Token_And_Error (J_COMMA, Token_Start, Token_End);\n+\n+            --  Read the array of operands\n+\n+            if Read_String /= Name_Operands then\n+               Error (\"operands expected\");\n+            end if;\n+\n+            Read_Token_And_Error (J_ARRAY, Token_Start, Token_End);\n+\n+            Nop := 0;\n+            Ops := (others => No_Uint);\n+            loop\n+               Nop := Nop + 1;\n+               Ops (Nop) := Read_Numerical_Expr;\n+               Read_Token (TK, Token_Start, Token_End);\n+               if TK = J_ARRAY_END then\n+                  exit;\n+               elsif TK /= J_COMMA then\n+                  Error (\"comma expected\");\n+               end if;\n+            end loop;\n+\n+            Read_Token_And_Error (J_OBJECT_END, Token_Start, Token_End);\n+\n+            --  Resolve the ambiguity for '-' now\n+\n+            if Code = Minus_Expr and then Nop = 1 then\n+               Code := Negate_Expr;\n+            end if;\n+\n+            return Create_Node (Code, Ops (1), Ops (2), Ops (3));\n+\n+         else\n+            Error (\"numerical expression expected\");\n+         end if;\n+      end Read_Numerical_Expr;\n+\n+      -------------------\n+      --  Read_Record  --\n+      -------------------\n+\n+      procedure Read_Record is\n+         Comp        : JSON_Component_Node;\n+         First_Bit   : Node_Ref_Or_Val := No_Uint;\n+         Is_First    : Boolean := True;\n+         Nam         : Name_Id := No_Name;\n+         Position    : Node_Ref_Or_Val := No_Uint;\n+         TK          : Token_Kind;\n+         Token_Start : Text_Position;\n+         Token_End   : Text_Position;\n+\n+      begin\n+         --  Read a possibly empty array of components\n+\n+         Read_Token_And_Error (J_ARRAY, Token_Start, Token_End);\n+\n+         loop\n+            Read_Token (TK, Token_Start, Token_End);\n+            if Is_First and then TK = J_ARRAY_END then\n+               exit;\n+            elsif TK /= J_OBJECT then\n+               Error (\"object expected\");\n+            end if;\n+\n+            --  Read the members as string : value pairs\n+\n+            loop\n+               case Read_String is\n+                  when Name_Name =>\n+                     Nam := Read_Name_With_Prefix;\n+                  when Name_Discriminant =>\n+                     Skip_Value;\n+                  when Name_Position =>\n+                     Position := Read_Numerical_Expr;\n+                  when Name_First_Bit =>\n+                     First_Bit := Read_Number;\n+                  when Name_Size =>\n+                     Comp.Esize := Read_Numerical_Expr;\n+                  when others =>\n+                     Error (\"invalid component\");\n+               end case;\n+\n+               Read_Token (TK, Token_Start, Token_End);\n+               if TK = J_OBJECT_END then\n+                  exit;\n+               elsif TK /= J_COMMA then\n+                  Error (\"comma expected\");\n+               end if;\n+            end loop;\n+\n+            --  Compute Component_Bit_Offset from Position and First_Bit,\n+            --  either symbolically or literally depending on Position.\n+\n+            if Position = No_Uint or else First_Bit = No_Uint then\n+               Error (\"bit offset expected\");\n+            end if;\n+\n+            if Position < Uint_0 then\n+               declare\n+                  Bit_Position : constant Node_Ref_Or_Val :=\n+                          Create_Node (Mult_Expr, Position, UI_From_Int (SSU));\n+               begin\n+                  if First_Bit = Uint_0 then\n+                     Comp.Bit_Offset := Bit_Position;\n+                  else\n+                     Comp.Bit_Offset :=\n+                              Create_Node (Plus_Expr, Bit_Position, First_Bit);\n+                  end if;\n+               end;\n+            else\n+               Comp.Bit_Offset := Position * SSU + First_Bit;\n+            end if;\n+\n+            --  Store the component into the table\n+\n+            JSON_Component_Table.Append (Comp);\n+\n+            --  Associate the name with the component\n+\n+            if Nam = No_Name then\n+               Error (\"name expected\");\n+            end if;\n+\n+            Set_Name_Table_Int (Nam, JSON_Component_Table.Last);\n+\n+            Read_Token (TK, Token_Start, Token_End);\n+            if TK = J_ARRAY_END then\n+               exit;\n+            elsif TK /= J_COMMA then\n+               Error (\"comma expected\");\n+            end if;\n+\n+            Is_First := False;\n+         end loop;\n+      end Read_Record;\n+\n+      ------------------\n+      --  Read_String --\n+      ------------------\n+\n+      function Read_String return Valid_Name_Id is\n+         Token_Start : Text_Position;\n+         Token_End   : Text_Position;\n+         Nam         : Valid_Name_Id;\n+\n+      begin\n+         --  Read the string and the following colon\n+\n+         Read_Token_And_Error (J_STRING, Token_Start, Token_End);\n+         Nam := Decode_Name (Token_Start.Index + 1, Token_End.Index - 1);\n+         Read_Token_And_Error (J_COLON, Token_Start, Token_End);\n+\n+         return Nam;\n+      end Read_String;\n+\n+      ------------------\n+      --  Read_Token  --\n+      ------------------\n+\n+      procedure Read_Token\n+        (Kind        : out Token_Kind;\n+         Token_Start : out Text_Position;\n+         Token_End   : out Text_Position)\n+      is\n+         procedure Next_Char;\n+         --  Update Pos to point to next char\n+\n+         function Is_Whitespace return Boolean;\n+         pragma Inline (Is_Whitespace);\n+         --  Return True of current character is a whitespace\n+\n+         function Is_Structural_Token return Boolean;\n+         pragma Inline (Is_Structural_Token);\n+         --  Return True if current character is one of the structural tokens\n+\n+         function Is_Token_Sep return Boolean;\n+         pragma Inline (Is_Token_Sep);\n+         --  Return True if current character is a token separator\n+\n+         procedure Delimit_Keyword (Kw : String);\n+         --  Helper function to parse tokens such as null, false and true\n+\n+         ---------------\n+         -- Next_Char --\n+         ---------------\n+\n+         procedure Next_Char is\n+         begin\n+            if Pos.Index > Text'Last then\n+               Pos.Column := Pos.Column + 1;\n+            elsif Text (Pos.Index) = ASCII.LF then\n+               Pos.Column := 1;\n+               Pos.Line := Pos.Line + 1;\n+            else\n+               Pos.Column := Pos.Column + 1;\n+            end if;\n+            Pos.Index := Pos.Index + 1;\n+         end Next_Char;\n+\n+         -------------------\n+         -- Is_Whitespace --\n+         -------------------\n+\n+         function Is_Whitespace return Boolean is\n+         begin\n+            return\n+              Pos.Index <= Text'Last\n+                and then\n+              (Text (Pos.Index) = ASCII.LF\n+                 or else\n+               Text (Pos.Index) = ASCII.CR\n+                 or else\n+               Text (Pos.Index) = ASCII.HT\n+                 or else\n+               Text (Pos.Index) = ' ');\n+         end Is_Whitespace;\n+\n+         -------------------------\n+         -- Is_Structural_Token --\n+         -------------------------\n+\n+         function Is_Structural_Token return Boolean is\n+         begin\n+            return\n+              Pos.Index <= Text'Last\n+                and then\n+              (Text (Pos.Index) = '['\n+                 or else\n+               Text (Pos.Index) = ']'\n+                 or else\n+               Text (Pos.Index) = '{'\n+                 or else\n+               Text (Pos.Index) = '}'\n+                 or else\n+               Text (Pos.Index) = ','\n+                 or else\n+               Text (Pos.Index) = ':');\n+         end Is_Structural_Token;\n+\n+         ------------------\n+         -- Is_Token_Sep --\n+         ------------------\n+\n+         function Is_Token_Sep return Boolean is\n+         begin\n+            return\n+              Pos.Index > Text'Last\n+                or else\n+              Is_Whitespace\n+                or else\n+              Is_Structural_Token;\n+         end Is_Token_Sep;\n+\n+         ---------------------\n+         -- Delimit_Keyword --\n+         ---------------------\n+\n+         procedure Delimit_Keyword (Kw : String) is\n+            pragma Unreferenced (Kw);\n+         begin\n+            while not Is_Token_Sep loop\n+               Token_End := Pos;\n+               Next_Char;\n+            end loop;\n+         end Delimit_Keyword;\n+\n+         CC             : Character;\n+         Can_Be_Integer : Boolean := True;\n+\n+      --  Start of processing for Read_Token\n+\n+      begin\n+         --  Skip leading whitespaces\n+\n+         while Is_Whitespace loop\n+            Next_Char;\n+         end loop;\n+\n+         --  Initialize token delimiters\n+\n+         Token_Start := Pos;\n+         Token_End   := Pos;\n+\n+         --  End of stream reached\n+\n+         if Pos.Index > Text'Last then\n+            Kind := J_EOF;\n+            return;\n+         end if;\n+\n+         CC := Text (Pos.Index);\n+\n+         if CC = '[' then\n+            Next_Char;\n+            Kind := J_ARRAY;\n+            return;\n+         elsif CC = ']' then\n+            Next_Char;\n+            Kind := J_ARRAY_END;\n+            return;\n+         elsif CC = '{' then\n+            Next_Char;\n+            Kind := J_OBJECT;\n+            return;\n+         elsif CC = '}' then\n+            Next_Char;\n+            Kind := J_OBJECT_END;\n+            return;\n+         elsif CC = ',' then\n+            Next_Char;\n+            Kind := J_COMMA;\n+            return;\n+         elsif CC = ':' then\n+            Next_Char;\n+            Kind := J_COLON;\n+            return;\n+         elsif CC = 'n' then\n+            Delimit_Keyword (\"null\");\n+            Kind := J_NULL;\n+            return;\n+         elsif CC = 'f' then\n+            Delimit_Keyword (\"false\");\n+            Kind := J_FALSE;\n+            return;\n+         elsif CC = 't' then\n+            Delimit_Keyword (\"true\");\n+            Kind := J_TRUE;\n+            return;\n+         elsif CC = '\"' then\n+            --  We expect a string\n+            --  Just scan till the end the of the string but do not attempt\n+            --  to decode it. This means that even if we get a string token\n+            --  it might not be a valid string from the ECMA 404 point of\n+            --  view.\n+\n+            Next_Char;\n+            while Pos.Index <= Text'Last and then Text (Pos.Index) /= '\"' loop\n+               if Text (Pos.Index) in ASCII.NUL .. ASCII.US then\n+                  Error (\"control character not allowed in string\");\n+               end if;\n+\n+               if Text (Pos.Index) = '\\' then\n+                  Next_Char;\n+                  if Pos.Index > Text'Last then\n+                     Error (\"non terminated string token\");\n+                  end if;\n+\n+                  case Text (Pos.Index) is\n+                     when 'u' =>\n+                        for Idx in 1 .. 4 loop\n+                           Next_Char;\n+                           if Pos.Index > Text'Last\n+                             or else (Text (Pos.Index) not in 'a' .. 'f'\n+                                        and then\n+                                      Text (Pos.Index) not in 'A' .. 'F'\n+                                        and then\n+                                      Text (Pos.Index) not in '0' .. '9')\n+                           then\n+                              Error (\"invalid unicode escape sequence\");\n+                           end if;\n+                        end loop;\n+                     when '\\' | '/' | '\"' | 'b' | 'f' | 'n' | 'r' | 't' =>\n+                        null;\n+                     when others =>\n+                        Error (\"invalid escape sequence\");\n+                  end case;\n+               end if;\n+               Next_Char;\n+            end loop;\n+\n+            --  No quote found report and error\n+\n+            if Pos.Index > Text'Last then\n+               Error (\"non terminated string token\");\n+            end if;\n+\n+            Token_End := Pos;\n+\n+            --  Go to next char and ensure that this is separator. Indeed\n+            --  construction such as \"string1\"\"string2\" are not allowed\n+\n+            Next_Char;\n+            if not Is_Token_Sep then\n+               Error (\"invalid syntax\");\n+            end if;\n+            Kind := J_STRING;\n+            return;\n+         elsif CC = '-' or else CC in '0' .. '9' then\n+            --  We expect a number\n+            if CC = '-' then\n+               Next_Char;\n+            end if;\n+\n+            if Pos.Index > Text'Last then\n+               Error (\"invalid number\");\n+            end if;\n+\n+            --  Parse integer part of a number. Superfluous leading zeros are\n+            --  not allowed.\n+\n+            if Text (Pos.Index) = '0' then\n+               Token_End := Pos;\n+               Next_Char;\n+            elsif Text (Pos.Index) in '1' .. '9' then\n+               Token_End := Pos;\n+               Next_Char;\n+               while Pos.Index <= Text'Last\n+                 and then Text (Pos.Index) in '0' .. '9'\n+               loop\n+                  Token_End := Pos;\n+                  Next_Char;\n+               end loop;\n+            else\n+               Error (\"invalid number\");\n+            end if;\n+\n+            if Is_Token_Sep then\n+               --  Valid integer number\n+\n+               Kind := J_INTEGER;\n+               return;\n+            elsif Text (Pos.Index) /= '.'\n+              and then Text (Pos.Index) /= 'e'\n+              and then Text (Pos.Index) /= 'E'\n+            then\n+               Error (\"invalid number\");\n+            end if;\n+\n+            --  Check for a fractional part\n+\n+            if Text (Pos.Index) = '.' then\n+               Can_Be_Integer := False;\n+               Token_End := Pos;\n+               Next_Char;\n+               if Pos.Index > Text'Last\n+                 or else Text (Pos.Index) not in '0' .. '9'\n+               then\n+                  Error (\"invalid number\");\n+               end if;\n+\n+               while Pos.Index <= Text'Last\n+                 and then Text (Pos.Index) in '0' .. '9'\n+               loop\n+                  Token_End := Pos;\n+                  Next_Char;\n+               end loop;\n+\n+            end if;\n+\n+            --  Check for exponent part\n+\n+            if Pos.Index <= Text'Last\n+              and then (Text (Pos.Index) = 'e' or else Text (Pos.Index) = 'E')\n+            then\n+               Token_End := Pos;\n+               Next_Char;\n+               if Pos.Index > Text'Last then\n+                  Error (\"invalid number\");\n+               end if;\n+\n+               if Text (Pos.Index) = '-' then\n+                  --  Also a few corner cases can lead to an integer, assume\n+                  --  that the number is not an integer.\n+\n+                  Can_Be_Integer := False;\n+               end if;\n+\n+               if Text (Pos.Index) = '-' or else Text (Pos.Index) = '+' then\n+                  Next_Char;\n+               end if;\n+\n+               if Pos.Index > Text'Last\n+                 or else Text (Pos.Index) not in '0' .. '9'\n+               then\n+                  Error (\"invalid number\");\n+               end if;\n+\n+               while Pos.Index <= Text'Last\n+                 and then Text (Pos.Index) in '0' .. '9'\n+               loop\n+                  Token_End := Pos;\n+                  Next_Char;\n+               end loop;\n+            end if;\n+\n+            if Is_Token_Sep then\n+               --  Valid decimal number\n+\n+               if Can_Be_Integer then\n+                  Kind := J_INTEGER;\n+               else\n+                  Kind := J_NUMBER;\n+               end if;\n+               return;\n+            else\n+               Error (\"invalid number\");\n+            end if;\n+         elsif CC = EOF then\n+            Kind := J_EOF;\n+         else\n+            Error (\"Unexpected character\");\n+         end if;\n+      end Read_Token;\n+\n+      ----------------------------\n+      --  Read_Token_And_Error  --\n+      ----------------------------\n+\n+      procedure Read_Token_And_Error\n+        (TK          : Token_Kind;\n+         Token_Start : out Text_Position;\n+         Token_End   : out Text_Position)\n+      is\n+         Kind : Token_Kind;\n+\n+      begin\n+         --  Read a token and errout out if not of the expected kind\n+\n+         Read_Token (Kind, Token_Start, Token_End);\n+         if Kind /= TK then\n+            Error (\"specific token expected\");\n+         end if;\n+      end Read_Token_And_Error;\n+\n+      -------------------------\n+      --  Read_Variant_Part  --\n+      -------------------------\n+\n+      function Read_Variant_Part return Nat is\n+         Next        : Nat := 0;\n+         TK          : Token_Kind;\n+         Token_Start : Text_Position;\n+         Token_End   : Text_Position;\n+         Var         : JSON_Variant_Node;\n+\n+      begin\n+         --  Read a non-empty array of components\n+\n+         Read_Token_And_Error (J_ARRAY, Token_Start, Token_End);\n+\n+         loop\n+            Read_Token_And_Error (J_OBJECT, Token_Start, Token_End);\n+\n+            Var.Variant := 0;\n+\n+            --  Read the members as string : value pairs\n+\n+            loop\n+               case Read_String is\n+                  when Name_Present =>\n+                     Var.Present := Read_Numerical_Expr;\n+                  when Name_Record =>\n+                     Read_Record;\n+                  when Name_Variant =>\n+                     Var.Variant := Read_Variant_Part;\n+                  when others =>\n+                     Error (\"invalid variant\");\n+               end case;\n+\n+               Read_Token (TK, Token_Start, Token_End);\n+               if TK = J_OBJECT_END then\n+                  exit;\n+               elsif TK /= J_COMMA then\n+                  Error (\"comma expected\");\n+               end if;\n+            end loop;\n+\n+            --  Chain the variant and store it into the table\n+\n+            Var.Next := Next;\n+            JSON_Variant_Table.Append (Var);\n+            Next := JSON_Variant_Table.Last;\n+\n+            Read_Token (TK, Token_Start, Token_End);\n+            if TK = J_ARRAY_END then\n+               exit;\n+            elsif TK /= J_COMMA then\n+               Error (\"comma expected\");\n+            end if;\n+         end loop;\n+\n+         return Next;\n+      end Read_Variant_Part;\n+\n+      ------------------\n+      --  Skip_Value  --\n+      ------------------\n+\n+      procedure Skip_Value is\n+         Array_Depth  : Natural := 0;\n+         Object_Depth : Natural := 0;\n+         TK           : Token_Kind;\n+         Token_Start  : Text_Position;\n+         Token_End    : Text_Position;\n+\n+      begin\n+         --  Read a value without recursing\n+\n+         loop\n+            Read_Token (TK, Token_Start, Token_End);\n+\n+            case TK is\n+               when J_STRING | J_INTEGER | J_NUMBER =>\n+                  null;\n+               when J_ARRAY =>\n+                  Array_Depth := Array_Depth + 1;\n+               when J_ARRAY_END =>\n+                  Array_Depth := Array_Depth - 1;\n+               when J_OBJECT =>\n+                  Object_Depth := Object_Depth + 1;\n+               when J_OBJECT_END =>\n+                  Object_Depth := Object_Depth - 1;\n+               when J_COLON | J_COMMA =>\n+                  if Array_Depth = 0 and then Object_Depth = 0 then\n+                     Error (\"value expected\");\n+                  end if;\n+               when others =>\n+                  Error (\"value expected\");\n+            end case;\n+\n+            exit when Array_Depth = 0 and then Object_Depth = 0;\n+         end loop;\n+      end Skip_Value;\n+\n+      Token_Start : Text_Position;\n+      Token_End   : Text_Position;\n+      TK          : Token_Kind;\n+      Is_First    : Boolean := True;\n+\n+   --  Start of processing for Read_JSON_Stream\n+\n+   begin\n+      --  Read a possibly empty array of entities\n+\n+      Read_Token_And_Error (J_ARRAY, Token_Start, Token_End);\n+\n+      loop\n+         Read_Token (TK, Token_Start, Token_End);\n+         if Is_First and then TK = J_ARRAY_END then\n+            exit;\n+         elsif TK /= J_OBJECT then\n+            Error (\"object expected\");\n+         end if;\n+\n+         Read_Entity;\n+\n+         Read_Token (TK, Token_Start, Token_End);\n+         if TK = J_ARRAY_END then\n+            exit;\n+         elsif TK /= J_COMMA then\n+            Error (\"comma expected\");\n+         end if;\n+\n+         Is_First := False;\n+      end loop;\n+   end Read_JSON_Stream;\n+\n+end Repinfo.Input;"}, {"sha": "e418feb7ee599dff4fe00305b488d510fdea2392", "filename": "gcc/ada/repinfo-input.ads", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c1657116a2c9cf7c0c14b6dfa7f8bbb7672d3c8/gcc%2Fada%2Frepinfo-input.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c1657116a2c9cf7c0c14b6dfa7f8bbb7672d3c8/gcc%2Fada%2Frepinfo-input.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frepinfo-input.ads?ref=6c1657116a2c9cf7c0c14b6dfa7f8bbb7672d3c8", "patch": "@@ -0,0 +1,78 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                         R E P I N F O - I N P U T                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 2018-2019, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package provides an alternate way of populating the internal tables\n+--  of Repinfo from a JSON input rather than the binary blob of the tree file.\n+--  Note that this is an additive mechanism, i.e. nothing is destroyed in the\n+--  internal state of the unit when it is used.\n+\n+--  The first step is to feed the unit with a JSON stream of a specified format\n+--  (see the spec of Repinfo for its description) by means of Read_JSON_Stream.\n+--  Then, for each entity whose representation information is present in the\n+--  JSON stream, the appropriate Get_JSON_* routines can be invoked to override\n+--  the eponymous fields of the entity in the tree.\n+\n+package Repinfo.Input is\n+\n+   function Get_JSON_Esize (Name : String) return Node_Ref_Or_Val;\n+   --  Returns the Esize value of the entity specified by Name, which is not\n+   --  the component of a record type, or else No_Uint if no representation\n+   --  information was supplied for the entity. Name is the full qualified name\n+   --  of the entity in lower case letters.\n+\n+   function Get_JSON_RM_Size (Name : String) return Node_Ref_Or_Val;\n+   --  Likewise for the RM_Size\n+\n+   function Get_JSON_Component_Size (Name : String) return Node_Ref_Or_Val;\n+   --  Likewise for the Component_Size of an array type\n+\n+   function Get_JSON_Component_Bit_Offset\n+     (Name        : String;\n+      Record_Name : String) return Node_Ref_Or_Val;\n+   --  Returns the Component_Bit_Offset of the component specified by Name,\n+   --  which is declared in the record type specified by Record_Name, or else\n+   --  No_Uint if no representation information was supplied for the component.\n+   --  Name is the unqualified name of the component whereas Record_Name is the\n+   --  full qualified name of the record type, both in lower case letters.\n+\n+   function Get_JSON_Esize\n+     (Name        : String;\n+      Record_Name : String) return Node_Ref_Or_Val;\n+   --  Likewise for the Esize\n+\n+   Invalid_JSON_Stream : exception;\n+   --  Raised if a format error is detected in the JSON stream\n+\n+   procedure Read_JSON_Stream (Text : Text_Buffer; File_Name : String);\n+   --  Reads a JSON stream and populates internal tables from it. File_Name is\n+   --  only used in error messages issued by the JSON parser.\n+\n+end Repinfo.Input;"}, {"sha": "27153101d626236e093cc435719003a323e7e8ba", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c1657116a2c9cf7c0c14b6dfa7f8bbb7672d3c8/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c1657116a2c9cf7c0c14b6dfa7f8bbb7672d3c8/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=6c1657116a2c9cf7c0c14b6dfa7f8bbb7672d3c8", "patch": "@@ -1511,6 +1511,11 @@ package Snames is\n    Name_Runtime_Library_Dir              : constant Name_Id := N + $;\n    Name_Runtime_Source_Dir               : constant Name_Id := N + $;\n \n+   --  Additional names used by the Repinfo unit\n+\n+   Name_Discriminant                     : constant Name_Id := N + $;\n+   Name_Operands                         : constant Name_Id := N + $;\n+\n    --  Other miscellaneous names used in front end\n \n    Name_Unaligned_Valid                  : constant Name_Id := N + $;"}]}