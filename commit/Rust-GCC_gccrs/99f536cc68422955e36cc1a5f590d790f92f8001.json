{"sha": "99f536cc68422955e36cc1a5f590d790f92f8001", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTlmNTM2Y2M2ODQyMjk1NWUzNmNjMWE1ZjU5MGQ3OTBmOTJmODAwMQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2008-08-13T14:22:19Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2008-08-13T14:22:19Z"}, "message": "tree.h (maybe_fold_offset_to_address): Declare.\n\n2008-08-13  Richard Guenther  <rguenther@suse.de>\n\n\t* tree.h (maybe_fold_offset_to_address): Declare.\n\t* tree-ssa-ccp.c (surely_varying_stmt_p): Fix typo in last commit.\n\t(ccp_fold): Handle pointer conversions the same as fold_stmt.\n\tLikewise for POINTER_PLUS_EXPR.\n\t(maybe_fold_offset_to_reference): Enable disabled code.\n\t(maybe_fold_offset_to_address): New function.\n\t(fold_stmt_r): Use it.\n\t(fold_gimple_assign): Likewise.\n\t* gimplify.c (gimplify_conversion): Use maybe_fold_offset_to_address.\n\t(gimplify_expr): Likewise.\n\n\t* gcc.dg/tree-ssa/ssa-ccp-21.c: New testcase.\n\t* gcc.dg/tree-ssa/ssa-ccp-22.c: Likewise.\n\t* gcc.dg/tree-ssa/ssa-ccp-23.c: Likewise.\n\nFrom-SVN: r139061", "tree": {"sha": "a132b33918fa2aabf5676cd2cede6a9b1320407a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a132b33918fa2aabf5676cd2cede6a9b1320407a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/99f536cc68422955e36cc1a5f590d790f92f8001", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99f536cc68422955e36cc1a5f590d790f92f8001", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99f536cc68422955e36cc1a5f590d790f92f8001", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99f536cc68422955e36cc1a5f590d790f92f8001/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e3f05c4e92cbf9464253d7886899204fe7b9e0b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3f05c4e92cbf9464253d7886899204fe7b9e0b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3f05c4e92cbf9464253d7886899204fe7b9e0b8"}], "stats": {"total": 249, "additions": 192, "deletions": 57}, "files": [{"sha": "fa88d55ee27f45576a4dd7548551d7be2b0623f5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99f536cc68422955e36cc1a5f590d790f92f8001/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99f536cc68422955e36cc1a5f590d790f92f8001/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=99f536cc68422955e36cc1a5f590d790f92f8001", "patch": "@@ -1,3 +1,16 @@\n+2008-08-13  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree.h (maybe_fold_offset_to_address): Declare.\n+\t* tree-ssa-ccp.c (surely_varying_stmt_p): Fix typo in last commit.\n+\t(ccp_fold): Handle pointer conversions the same as fold_stmt.\n+\tLikewise for POINTER_PLUS_EXPR.\n+\t(maybe_fold_offset_to_reference): Enable disabled code.\n+\t(maybe_fold_offset_to_address): New function.\n+\t(fold_stmt_r): Use it.\n+\t(fold_gimple_assign): Likewise.\n+\t* gimplify.c (gimplify_conversion): Use maybe_fold_offset_to_address.\n+\t(gimplify_expr): Likewise.\n+\n 2008-08-13  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n \n \t* toplev.h (pedwarn_at): Fix declaration."}, {"sha": "43c8df991fce732ed3484d6e732fa399344b29b3", "filename": "gcc/gimplify.c", "status": "modified", "additions": 13, "deletions": 23, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99f536cc68422955e36cc1a5f590d790f92f8001/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99f536cc68422955e36cc1a5f590d790f92f8001/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=99f536cc68422955e36cc1a5f590d790f92f8001", "patch": "@@ -1842,17 +1842,13 @@ gimplify_conversion (tree *expr_p)\n   /* Attempt to avoid NOP_EXPR by producing reference to a subtype.\n      For example this fold (subclass *)&A into &A->subclass avoiding\n      a need for statement.  */\n-  if (TREE_CODE (*expr_p) == NOP_EXPR\n+  if (CONVERT_EXPR_P (*expr_p)\n       && POINTER_TYPE_P (TREE_TYPE (*expr_p))\n       && POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (*expr_p, 0)))\n-      && (tem = maybe_fold_offset_to_reference\n+      && (tem = maybe_fold_offset_to_address\n \t\t  (TREE_OPERAND (*expr_p, 0),\n-\t\t   integer_zero_node, TREE_TYPE (TREE_TYPE (*expr_p)))))\n-    {\n-      tree ptr_type = build_pointer_type (TREE_TYPE (tem));\n-      if (useless_type_conversion_p (TREE_TYPE (*expr_p), ptr_type))\n-        *expr_p = build_fold_addr_expr_with_type (tem, ptr_type);\n-    }\n+\t\t   integer_zero_node, TREE_TYPE (*expr_p))) != NULL_TREE)\n+    *expr_p = tem;\n \n   /* If we still have a conversion at the toplevel,\n      then canonicalize some constructs.  */\n@@ -6735,30 +6731,24 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t     The second is gimple immediate saving a need for extra statement.\n \t   */\n \t  if (TREE_CODE (TREE_OPERAND (*expr_p, 1)) == INTEGER_CST\n-\t      && (tmp = maybe_fold_offset_to_reference\n+\t      && (tmp = maybe_fold_offset_to_address\n \t\t\t (TREE_OPERAND (*expr_p, 0), TREE_OPERAND (*expr_p, 1),\n-\t\t   \t  TREE_TYPE (TREE_TYPE (*expr_p)))))\n-\t     {\n-\t       tree ptr_type = build_pointer_type (TREE_TYPE (tmp));\n-\t       if (useless_type_conversion_p (TREE_TYPE (*expr_p), ptr_type))\n-\t\t {\n-                   *expr_p = build_fold_addr_expr_with_type (tmp, ptr_type);\n-\t\t   break;\n-\t\t }\n-\t     }\n+\t\t   \t  TREE_TYPE (*expr_p))))\n+\t    {\n+\t      *expr_p = tmp;\n+\t      break;\n+\t    }\n \t  /* Convert (void *)&a + 4 into (void *)&a[1].  */\n \t  if (TREE_CODE (TREE_OPERAND (*expr_p, 0)) == NOP_EXPR\n \t      && TREE_CODE (TREE_OPERAND (*expr_p, 1)) == INTEGER_CST\n \t      && POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (TREE_OPERAND (*expr_p,\n \t\t\t\t\t\t\t\t\t0),0)))\n-\t      && (tmp = maybe_fold_offset_to_reference\n+\t      && (tmp = maybe_fold_offset_to_address\n \t\t\t (TREE_OPERAND (TREE_OPERAND (*expr_p, 0), 0),\n \t\t\t  TREE_OPERAND (*expr_p, 1),\n-\t\t   \t  TREE_TYPE (TREE_TYPE\n-\t\t\t\t  (TREE_OPERAND (TREE_OPERAND (*expr_p, 0),\n-\t\t\t\t\t\t 0))))))\n+\t\t   \t  TREE_TYPE (TREE_OPERAND (TREE_OPERAND (*expr_p, 0),\n+\t\t\t\t\t\t   0)))))\n \t     {\n-               tmp = build_fold_addr_expr (tmp);\n                *expr_p = fold_convert (TREE_TYPE (*expr_p), tmp);\n \t       break;\n \t     }"}, {"sha": "951f82ea67bfd610b00ad35109c5ad7da8fbae69", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99f536cc68422955e36cc1a5f590d790f92f8001/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99f536cc68422955e36cc1a5f590d790f92f8001/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=99f536cc68422955e36cc1a5f590d790f92f8001", "patch": "@@ -1,3 +1,9 @@\n+2008-08-13  Richard Guenther  <rguenther@suse.de>\n+\n+\t* gcc.dg/tree-ssa/ssa-ccp-21.c: New testcase.\n+\t* gcc.dg/tree-ssa/ssa-ccp-22.c: Likewise.\n+\t* gcc.dg/tree-ssa/ssa-ccp-23.c: Likewise.\n+\n 2008-08-13  Samuel Tardieu  <sam@rfc1149.net>\n \n \tPR ada/36777"}, {"sha": "3b23c36238e7d57b34013992de28e59d3f21b6f3", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-21.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99f536cc68422955e36cc1a5f590d790f92f8001/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-21.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99f536cc68422955e36cc1a5f590d790f92f8001/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-21.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-21.c?ref=99f536cc68422955e36cc1a5f590d790f92f8001", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-ccp1\" } */\n+\n+struct A {\n+    struct B {\n+\tint i;\n+    } b;\n+} a;\n+\n+int foo (void)\n+{\n+  struct B *p = &a.b;\n+  struct A *q = (struct A *) p;\n+  return q->b.i;\n+}\n+\n+int bar (void)\n+{\n+  struct A *p = &a;\n+  struct B *q = (struct B *) p;\n+  return q->i;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"a.b.i\" 2 \"ccp1\" } } */\n+/* { dg-final { cleanup-tree-dump \"ccp1\" } } */"}, {"sha": "01d11ecac87d8df0c3c50c1b12fa8432d50d4a84", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-22.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99f536cc68422955e36cc1a5f590d790f92f8001/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-22.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99f536cc68422955e36cc1a5f590d790f92f8001/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-22.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-22.c?ref=99f536cc68422955e36cc1a5f590d790f92f8001", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-ccp1\" } */\n+\n+/* Make sure we propagate through builtins.  */\n+\n+int foo (unsigned b)\n+{\n+  unsigned t = -1;\n+  int x = b <= t;\n+  long l = __builtin_expect (x, 0);\n+  return l;\n+}\n+\n+/* { dg-final { scan-tree-dump \"return 1;\" \"ccp1\" } } */\n+/* { dg-final { cleanup-tree-dump \"ccp1\" } } */"}, {"sha": "ac7f068cfd14eec9c09ab6c0294927962635c326", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-23.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99f536cc68422955e36cc1a5f590d790f92f8001/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-23.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99f536cc68422955e36cc1a5f590d790f92f8001/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-23.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-23.c?ref=99f536cc68422955e36cc1a5f590d790f92f8001", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-ccp1\" } */\n+\n+/* Make sure we propagate through POINTER_PLUS_EXPRs.  */\n+\n+struct A {\n+  int i[2];\n+} a;\n+\n+int foo (void)\n+{\n+  struct A *p = &a;\n+  int *q = (int *)p;\n+  int *x = q + 1;\n+  return *x;\n+}\n+\n+/* { dg-final { scan-tree-dump \"a.i\\\\\\[1\\\\\\]\" \"ccp1\" } } */\n+/* { dg-final { cleanup-tree-dump \"ccp1\" } } */"}, {"sha": "ff8af4f14dd6d10444ec6b06c08ea78e1fe1c60e", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 100, "deletions": 34, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99f536cc68422955e36cc1a5f590d790f92f8001/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99f536cc68422955e36cc1a5f590d790f92f8001/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=99f536cc68422955e36cc1a5f590d790f92f8001", "patch": "@@ -630,7 +630,7 @@ surely_varying_stmt_p (gimple stmt)\n       tree fndecl;\n       if (!gimple_call_lhs (stmt)\n \t  || ((fndecl = gimple_call_fndecl (stmt)) != NULL_TREE\n-\t      && DECL_BUILT_IN (fndecl)))\n+\t      && !DECL_BUILT_IN (fndecl)))\n \treturn true;\n     }\n \n@@ -988,18 +988,26 @@ ccp_fold (gimple stmt)\n \t\t useless_type_conversion_p places for pointer type conversions\n \t\t do not apply here.  Substitution later will only substitute to\n \t\t allowed places.  */\n-              if ((subcode == NOP_EXPR || subcode == CONVERT_EXPR)\n-\t\t  && ((POINTER_TYPE_P (TREE_TYPE (lhs))\n-\t\t       && POINTER_TYPE_P (TREE_TYPE (op0))\n-\t\t       /* Do not allow differences in volatile qualification\n-\t\t\t  as this might get us confused as to whether a\n-\t\t\t  propagation destination statement is volatile\n-\t\t\t  or not.  See PR36988.  */\n-\t\t       && (TYPE_VOLATILE (TREE_TYPE (TREE_TYPE (lhs)))\n-\t\t\t   == TYPE_VOLATILE (TREE_TYPE (TREE_TYPE (op0)))))\n-\t\t      || useless_type_conversion_p (TREE_TYPE (lhs),\n-\t\t\t\t\t\t    TREE_TYPE (op0))))\n-                return op0;\n+\t      if (IS_CONVERT_EXPR_CODE_P (subcode)\n+\t\t  && POINTER_TYPE_P (TREE_TYPE (lhs))\n+\t\t  && POINTER_TYPE_P (TREE_TYPE (op0))\n+\t\t  /* Do not allow differences in volatile qualification\n+\t\t     as this might get us confused as to whether a\n+\t\t     propagation destination statement is volatile\n+\t\t     or not.  See PR36988.  */\n+\t\t  && (TYPE_VOLATILE (TREE_TYPE (TREE_TYPE (lhs)))\n+\t\t      == TYPE_VOLATILE (TREE_TYPE (TREE_TYPE (op0)))))\n+\t\t{\n+\t\t  tree tem;\n+\t\t  /* Still try to generate a constant of correct type.  */\n+\t\t  if (!useless_type_conversion_p (TREE_TYPE (lhs),\n+\t\t\t\t\t\t  TREE_TYPE (op0))\n+\t\t      && ((tem = maybe_fold_offset_to_address\n+\t\t\t\t   (op0, integer_zero_node, TREE_TYPE (lhs)))\n+\t\t\t  != NULL_TREE))\n+\t\t    return tem;\n+\t\t  return op0;\n+\t\t}\n \n               return fold_unary (subcode, gimple_expr_type (stmt), op0);\n             }  \n@@ -1025,6 +1033,18 @@ ccp_fold (gimple stmt)\n                     op1 = val->value;\n                 }\n \n+\t      /* Fold &foo + CST into an invariant reference if possible.  */\n+\t      if (gimple_assign_rhs_code (stmt) == POINTER_PLUS_EXPR\n+\t\t  && TREE_CODE (op0) == ADDR_EXPR\n+\t\t  && TREE_CODE (op1) == INTEGER_CST)\n+\t\t{\n+\t\t  tree lhs = gimple_assign_lhs (stmt);\n+\t\t  tree tem = maybe_fold_offset_to_address (op0, op1,\n+\t\t\t\t\t\t\t   TREE_TYPE (lhs));\n+\t\t  if (tem != NULL_TREE)\n+\t\t    return tem;\n+\t\t}\n+\n               return fold_binary (subcode, gimple_expr_type (stmt), op0, op1);\n             }\n \n@@ -1948,15 +1968,15 @@ maybe_fold_offset_to_reference (tree base, tree offset, tree orig_type)\n \t so it needs to be removed and new COMPONENT_REF constructed.\n \t The wrong COMPONENT_REF are often constructed by folding the\n \t (type *)&object within the expression (type *)&object+offset  */\n-      if (handled_component_p (base) && 0)\n+      if (handled_component_p (base))\n \t{\n           HOST_WIDE_INT sub_offset, size, maxsize;\n \t  tree newbase;\n \t  newbase = get_ref_base_and_extent (base, &sub_offset,\n \t\t\t\t\t     &size, &maxsize);\n \t  gcc_assert (newbase);\n-\t  gcc_assert (!(sub_offset & (BITS_PER_UNIT - 1)));\n-\t  if (size == maxsize)\n+\t  if (size == maxsize\n+\t      && !(sub_offset & (BITS_PER_UNIT - 1)))\n \t    {\n \t      base = newbase;\n \t      if (sub_offset)\n@@ -1988,6 +2008,63 @@ maybe_fold_offset_to_reference (tree base, tree offset, tree orig_type)\n   return ret;\n }\n \n+/* Attempt to express (ORIG_TYPE)&BASE+OFFSET as &BASE->field_of_orig_type\n+   or &BASE[index] or by combination of those.\n+\n+   Before attempting the conversion strip off existing component refs.  */\n+\n+tree\n+maybe_fold_offset_to_address (tree addr, tree offset, tree orig_type)\n+{\n+  tree t;\n+\n+  gcc_assert (POINTER_TYPE_P (TREE_TYPE (addr))\n+\t      && POINTER_TYPE_P (orig_type));\n+\n+  t = maybe_fold_offset_to_reference (addr, offset, TREE_TYPE (orig_type));\n+  if (t != NULL_TREE)\n+    {\n+      tree orig = addr;\n+      tree ptr_type;\n+\n+      /* For __builtin_object_size to function correctly we need to\n+         make sure not to fold address arithmetic so that we change\n+\t reference from one array to another.  This would happen for\n+\t example for\n+\n+\t   struct X { char s1[10]; char s2[10] } s;\n+\t   char *foo (void) { return &s.s2[-4]; }\n+\n+\t where we need to avoid generating &s.s1[6].  As the C and\n+\t C++ frontends create different initial trees\n+\t (char *) &s.s1 + -4  vs.  &s.s1[-4]  we have to do some\n+\t sophisticated comparisons here.  Note that checking for the\n+\t condition after the fact is easier than trying to avoid doing\n+\t the folding.  */\n+      STRIP_NOPS (orig);\n+      if (TREE_CODE (orig) == ADDR_EXPR)\n+\torig = TREE_OPERAND (orig, 0);\n+      if ((TREE_CODE (orig) == ARRAY_REF\n+\t   || (TREE_CODE (orig) == COMPONENT_REF\n+\t       && TREE_CODE (TREE_TYPE (TREE_OPERAND (orig, 1))) == ARRAY_TYPE))\n+\t  && (TREE_CODE (t) == ARRAY_REF\n+\t      || (TREE_CODE (t) == COMPONENT_REF\n+\t\t  && TREE_CODE (TREE_TYPE (TREE_OPERAND (t, 1))) == ARRAY_TYPE))\n+\t  && !operand_equal_p (TREE_CODE (orig) == ARRAY_REF\n+\t\t\t       ? TREE_OPERAND (orig, 0) : orig,\n+\t\t\t       TREE_CODE (t) == ARRAY_REF\n+\t\t\t       ? TREE_OPERAND (t, 0) : t, 0))\n+\treturn NULL_TREE;\n+\n+      ptr_type = build_pointer_type (TREE_TYPE (t));\n+      if (!useless_type_conversion_p (orig_type, ptr_type))\n+\treturn NULL_TREE;\n+      return build_fold_addr_expr_with_type (t, ptr_type);\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n /* A subroutine of fold_stmt_r.  Attempt to simplify *(BASE+OFFSET).\n    Return the simplified expression, or NULL if nothing could be done.  */\n \n@@ -2223,16 +2300,10 @@ fold_stmt_r (tree *expr_p, int *walk_subtrees, void *data)\n \n       if (POINTER_TYPE_P (TREE_TYPE (expr))\n \t  && POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (expr, 0)))\n-\t  && (t = maybe_fold_offset_to_reference\n-\t\t      (TREE_OPERAND (expr, 0),\n-\t\t       integer_zero_node,\n-\t\t       TREE_TYPE (TREE_TYPE (expr)))))\n-\t{\n-\t  tree ptr_type = build_pointer_type (TREE_TYPE (t));\n-\t  if (!useless_type_conversion_p (TREE_TYPE (expr), ptr_type))\n-\t    return NULL_TREE;\n-          t = build_fold_addr_expr_with_type (t, ptr_type);\n-\t}\n+\t  && (t = maybe_fold_offset_to_address (TREE_OPERAND (expr, 0),\n+\t\t\t\t\t\tinteger_zero_node,\n+\t\t\t\t\t\tTREE_TYPE (TREE_TYPE (expr)))))\n+\treturn t;\n       break;\n \n       /* ??? Could handle more ARRAY_REFs here, as a variant of INDIRECT_REF.\n@@ -2715,15 +2786,10 @@ fold_gimple_assign (gimple_stmt_iterator *si)\n \t       && POINTER_TYPE_P (TREE_TYPE (gimple_assign_rhs1 (stmt))))\n \t{\n \t  tree type = gimple_expr_type (stmt);\n-\t  tree t = maybe_fold_offset_to_reference (gimple_assign_rhs1 (stmt),\n-\t\t\t\t\t\t   integer_zero_node,\n-\t\t\t\t\t\t   TREE_TYPE (type));\n+\t  tree t = maybe_fold_offset_to_address (gimple_assign_rhs1 (stmt),\n+\t\t\t\t\t\t integer_zero_node, type);\n \t  if (t)\n-\t    {\n-\t      tree ptr_type = build_pointer_type (TREE_TYPE (t));\n-\t      if (useless_type_conversion_p (type, ptr_type))\n-\t\treturn build_fold_addr_expr_with_type (t, ptr_type);\n-\t    }\n+\t    return t;\n \t}\n       break;\n "}, {"sha": "3f8065da736effba7057256a889e4cc9cc6d632d", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99f536cc68422955e36cc1a5f590d790f92f8001/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99f536cc68422955e36cc1a5f590d790f92f8001/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=99f536cc68422955e36cc1a5f590d790f92f8001", "patch": "@@ -4744,6 +4744,7 @@ extern void fold_undefer_overflow_warnings (bool, const_gimple, int);\n extern void fold_undefer_and_ignore_overflow_warnings (void);\n extern bool fold_deferring_overflow_warnings_p (void);\n extern tree maybe_fold_offset_to_reference (tree, tree, tree);\n+extern tree maybe_fold_offset_to_address (tree, tree, tree);\n extern tree maybe_fold_stmt_addition (tree, tree, tree);\n \n extern tree force_fit_type_double (tree, unsigned HOST_WIDE_INT, HOST_WIDE_INT,"}]}