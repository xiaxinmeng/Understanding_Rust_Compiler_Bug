{"sha": "aa79a1e1c8bc73e1b5efcfa9de532f8c6b2e3151", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWE3OWExZTFjOGJjNzNlMWI1ZWZjZmE5ZGU1MzJmOGM2YjJlMzE1MQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2014-10-10T12:15:30Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2014-10-10T12:15:30Z"}, "message": "re PR tree-optimization/63464 (compare one character to many: faster)\n\n\tPR tree-optimization/63464\n\t* tree-switch-conversion.c (struct case_bit_test): Remove\n\thi and lo fields, add wide_int mask field.\n\t(emit_case_bit_tests): Add MAXVAL argument, rewrite uses of\n\thi/lo fields into wide_int mask operations, optimize by pretending\n\tminval to be 0 if maxval is small enough.\n\t(process_switch): Adjust caller.\n\nFrom-SVN: r216072", "tree": {"sha": "04dd8d6f9599125815f4e49100134fff987c996f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/04dd8d6f9599125815f4e49100134fff987c996f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa79a1e1c8bc73e1b5efcfa9de532f8c6b2e3151", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa79a1e1c8bc73e1b5efcfa9de532f8c6b2e3151", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa79a1e1c8bc73e1b5efcfa9de532f8c6b2e3151", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa79a1e1c8bc73e1b5efcfa9de532f8c6b2e3151/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f1485e5b24f83af957e3d528dc80cd88b67acdc5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1485e5b24f83af957e3d528dc80cd88b67acdc5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1485e5b24f83af957e3d528dc80cd88b67acdc5"}], "stats": {"total": 66, "additions": 48, "deletions": 18}, "files": [{"sha": "f91582b93cebad9948781b9767404c8e352a0dde", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa79a1e1c8bc73e1b5efcfa9de532f8c6b2e3151/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa79a1e1c8bc73e1b5efcfa9de532f8c6b2e3151/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=aa79a1e1c8bc73e1b5efcfa9de532f8c6b2e3151", "patch": "@@ -1,3 +1,13 @@\n+2014-10-10  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/63464\n+\t* tree-switch-conversion.c (struct case_bit_test): Remove\n+\thi and lo fields, add wide_int mask field.\n+\t(emit_case_bit_tests): Add MAXVAL argument, rewrite uses of\n+\thi/lo fields into wide_int mask operations, optimize by pretending\n+\tminval to be 0 if maxval is small enough.\n+\t(process_switch): Adjust caller.\n+\n 2014-10-10  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/63379"}, {"sha": "ae5853b87046f01760e7be7c35439048ccca433c", "filename": "gcc/tree-switch-conversion.c", "status": "modified", "additions": 38, "deletions": 18, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa79a1e1c8bc73e1b5efcfa9de532f8c6b2e3151/gcc%2Ftree-switch-conversion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa79a1e1c8bc73e1b5efcfa9de532f8c6b2e3151/gcc%2Ftree-switch-conversion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-switch-conversion.c?ref=aa79a1e1c8bc73e1b5efcfa9de532f8c6b2e3151", "patch": "@@ -246,8 +246,7 @@ This transformation was contributed by Roger Sayle, see this e-mail:\n \n struct case_bit_test\n {\n-  HOST_WIDE_INT hi;\n-  HOST_WIDE_INT lo;\n+  wide_int mask;\n   edge target_edge;\n   tree label;\n   int bits;\n@@ -294,13 +293,14 @@ case_bit_test_cmp (const void *p1, const void *p2)\n     are not guaranteed to be of the same type as INDEX_EXPR\n     (the gimplifier doesn't change the type of case label values,\n     and MINVAL and RANGE are derived from those values).\n+    MAXVAL is MINVAL + RANGE.\n \n     There *MUST* be MAX_CASE_BIT_TESTS or less unique case\n     node targets.  */\n \n static void\n emit_case_bit_tests (gimple swtch, tree index_expr,\n-\t\t     tree minval, tree range)\n+\t\t     tree minval, tree range, tree maxval)\n {\n   struct case_bit_test test[MAX_CASE_BIT_TESTS];\n   unsigned int i, j, k;\n@@ -324,6 +324,8 @@ emit_case_bit_tests (gimple swtch, tree index_expr,\n   tree word_type_node = lang_hooks.types.type_for_mode (word_mode, 1);\n   tree word_mode_zero = fold_convert (word_type_node, integer_zero_node);\n   tree word_mode_one = fold_convert (word_type_node, integer_one_node);\n+  int prec = TYPE_PRECISION (word_type_node);\n+  wide_int wone = wi::one (prec);\n \n   memset (&test, 0, sizeof (test));\n \n@@ -348,8 +350,7 @@ emit_case_bit_tests (gimple swtch, tree index_expr,\n       if (k == count)\n \t{\n \t  gcc_checking_assert (count < MAX_CASE_BIT_TESTS);\n-\t  test[k].hi = 0;\n-\t  test[k].lo = 0;\n+\t  test[k].mask = wi::zero (prec);\n \t  test[k].target_edge = e;\n \t  test[k].label = label;\n \t  test[k].bits = 1;\n@@ -367,14 +368,39 @@ emit_case_bit_tests (gimple swtch, tree index_expr,\n \t\t\t\t\t    CASE_HIGH (cs), minval));\n \n       for (j = lo; j <= hi; j++)\n-        if (j >= HOST_BITS_PER_WIDE_INT)\n-\t  test[k].hi |= (HOST_WIDE_INT) 1 << (j - HOST_BITS_PER_INT);\n-\telse\n-\t  test[k].lo |= (HOST_WIDE_INT) 1 << j;\n+\ttest[k].mask |= wi::lshift (wone, j);\n     }\n \n   qsort (test, count, sizeof (*test), case_bit_test_cmp);\n \n+  /* If all values are in the 0 .. BITS_PER_WORD-1 range, we can get rid of\n+     the minval subtractions, but it might make the mask constants more\n+     expensive.  So, compare the costs.  */\n+  if (compare_tree_int (minval, 0) > 0\n+      && compare_tree_int (maxval, GET_MODE_BITSIZE (word_mode)) < 0)\n+    {\n+      int cost_diff;\n+      HOST_WIDE_INT m = tree_to_uhwi (minval);\n+      rtx reg = gen_raw_REG (word_mode, 10000);\n+      bool speed_p = optimize_bb_for_speed_p (gimple_bb (swtch));\n+      cost_diff = set_rtx_cost (gen_rtx_PLUS (word_mode, reg,\n+\t\t\t\t\t      GEN_INT (-m)), speed_p);\n+      for (i = 0; i < count; i++)\n+\t{\n+\t  rtx r = immed_wide_int_const (test[i].mask, word_mode);\n+\t  cost_diff += set_src_cost (gen_rtx_AND (word_mode, reg, r), speed_p);\n+\t  r = immed_wide_int_const (wi::lshift (test[i].mask, m), word_mode);\n+\t  cost_diff -= set_src_cost (gen_rtx_AND (word_mode, reg, r), speed_p);\n+\t}\n+      if (cost_diff > 0)\n+\t{\n+\t  for (i = 0; i < count; i++)\n+\t    test[i].mask = wi::lshift (test[i].mask, m);\n+\t  minval = build_zero_cst (TREE_TYPE (minval));\n+\t  range = maxval;\n+\t}\n+    }\n+\n   /* We generate two jumps to the default case label.\n      Split the default edge, so that we don't have to do any PHI node\n      updating.  */\n@@ -446,13 +472,7 @@ emit_case_bit_tests (gimple swtch, tree index_expr,\n         if (const & csui) goto target  */\n   for (k = 0; k < count; k++)\n     {\n-      HOST_WIDE_INT a[2];\n-\n-      a[0] = test[k].lo;\n-      a[1] = test[k].hi;\n-      tmp = wide_int_to_tree (word_type_node,\n-\t\t\t      wide_int::from_array (a, 2,\n-\t\t\t\t\t\t    TYPE_PRECISION (word_type_node)));\n+      tmp = wide_int_to_tree (word_type_node, test[k].mask);\n       tmp = fold_build2 (BIT_AND_EXPR, word_type_node, csui, tmp);\n       tmp = force_gimple_operand_gsi (&gsi, tmp,\n \t\t\t\t      /*simple=*/true, NULL_TREE,\n@@ -1369,8 +1389,8 @@ process_switch (gimple swtch)\n \t{\n \t  if (dump_file)\n \t    fputs (\"  expanding as bit test is preferable\\n\", dump_file);\n-\t  emit_case_bit_tests (swtch, info.index_expr,\n-\t\t\t       info.range_min, info.range_size);\n+\t  emit_case_bit_tests (swtch, info.index_expr, info.range_min,\n+\t\t\t       info.range_size, info.range_max);\n \t  loops_state_set (LOOPS_NEED_FIXUP);\n \t  return NULL;\n \t}"}]}