{"sha": "c24db30451c80100f6431dec406702fefa549ec6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzI0ZGIzMDQ1MWM4MDEwMGY2NDMxZGVjNDA2NzAyZmVmYTU0OWVjNg==", "commit": {"author": {"name": "Douglas B Rupp", "email": "rupp@gnat.com", "date": "2009-08-14T20:38:36Z"}, "committer": {"name": "Douglas Rupp", "email": "rupp@gcc.gnu.org", "date": "2009-08-14T20:38:36Z"}, "message": "config.gcc (ia64-hp-*vms*): Insert ia64/t-ia64 in tmake_file.\n\n\n\t* config.gcc (ia64-hp-*vms*): Insert ia64/t-ia64 in tmake_file.\n\t* config/ia64/t-vms: New file.\n\t* config/ia64/vms64.h: New file.\n\t* config/ia64/vms.h: New file.\n\t* config/ia64/vms-crtinit.asm: New file.\n\t* config/ia64/vms_symvec_libgcc_s.opt: New file.\n\t* config/ia64/vms-unwind.h: New file.\n\n\nCo-Authored-By: Tristan Gingold <gingold@adacore.com>\n\nFrom-SVN: r150776", "tree": {"sha": "28a3d660410a5c5bc96ff71f4c9fb51b71482887", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/28a3d660410a5c5bc96ff71f4c9fb51b71482887"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c24db30451c80100f6431dec406702fefa549ec6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c24db30451c80100f6431dec406702fefa549ec6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c24db30451c80100f6431dec406702fefa549ec6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c24db30451c80100f6431dec406702fefa549ec6/comments", "author": null, "committer": null, "parents": [{"sha": "9d3458531a0a177e9a83f19481f691a139bc4ae7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d3458531a0a177e9a83f19481f691a139bc4ae7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d3458531a0a177e9a83f19481f691a139bc4ae7"}], "stats": {"total": 754, "additions": 753, "deletions": 1}, "files": [{"sha": "f89660bbc205660c6af353d53d7f8e9db4492907", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c24db30451c80100f6431dec406702fefa549ec6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c24db30451c80100f6431dec406702fefa549ec6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c24db30451c80100f6431dec406702fefa549ec6", "patch": "@@ -1,3 +1,14 @@\n+2009-08-14  Douglas B Rupp  <rupp@gnat.com>\n+\t    Tristan Gingold  <gingold@adacore.com>\n+\n+\t* config.gcc (ia64-hp-*vms*): Insert ia64/t-ia64 in tmake_file.\n+\t* config/ia64/t-vms: New file.\n+\t* config/ia64/vms64.h: New file.\n+\t* config/ia64/vms.h: New file.\n+\t* config/ia64/vms-crtinit.asm: New file.\n+\t* config/ia64/vms_symvec_libgcc_s.opt: New file.\n+\t* config/ia64/vms-unwind.h: New file.\n+\n 2009-08-14  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/alpha/alpha.c (alpha_emit_conditional_move): Handle"}, {"sha": "c8eb88e166561ed4b7104a8bbcf6fac7bb53193b", "filename": "gcc/config.gcc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c24db30451c80100f6431dec406702fefa549ec6/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c24db30451c80100f6431dec406702fefa549ec6/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=c24db30451c80100f6431dec406702fefa549ec6", "patch": "@@ -1424,7 +1424,7 @@ ia64*-*-hpux*)\n ia64-hp-*vms*)\n \ttm_file=\"${tm_file} elfos.h ia64/sysv4.h ia64/elf.h ia64/vms.h ia64/vms64.h\"\n \txm_file=\"vms/xm-vms.h vms/xm-vms64.h\"\n-\ttmake_file=\"vms/t-vms vms/t-vms64 ia64/t-vms\"\n+\ttmake_file=\"vms/t-vms vms/t-vms64 ia64/t-ia64 ia64/t-vms\"\n \txmake_file=vms/x-vms\n \ttarget_cpu_default=\"0\"\n \tif test x$gas = xyes"}, {"sha": "d77a2cf37968fa1407266206f7fd0cd011fb2d79", "filename": "gcc/config/ia64/t-vms", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c24db30451c80100f6431dec406702fefa549ec6/gcc%2Fconfig%2Fia64%2Ft-vms", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c24db30451c80100f6431dec406702fefa549ec6/gcc%2Fconfig%2Fia64%2Ft-vms", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Ft-vms?ref=c24db30451c80100f6431dec406702fefa549ec6", "patch": "@@ -0,0 +1,49 @@\n+# Copyright (C) 2009\n+# Free Software Foundation, Inc.\n+#\n+# This file is part of GCC.\n+#\n+# GCC is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3, or (at your option)\n+# any later version.\n+#\n+# GCC is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# Enable the crtbegin/end rules disabled in t-ia64\n+T =\n+\n+# VMS_EXTRA_PARTS is defined in x-vms and represent object files that\n+# are only needed for VMS targets, but can only be compiled on a VMS host\n+# (because they need DEC C).\n+EXTRA_PARTS = $(VMS_EXTRA_PARTS) crtbegin.o crtbeginS.o crtend.o crtendS.o crtinitS.o\n+\n+CRTSTUFF_T_CFLAGS = -O0\n+CRTSTUFF_T_CFLAGS_S = -O0\n+\n+$(T)crtinitS.o: $(srcdir)/config/ia64/vms-crtinit.asm $(GCC_PASSES)\n+\t$(GCC_FOR_TARGET) -I. -c -o $(T)crtinitS.o -x assembler-with-cpp \\\n+\t\t$(srcdir)/config/ia64/vms-crtinit.asm\n+\n+LIB2ADDEH += $(srcdir)/config/ia64/fde-vms.c $(srcdir)/gthr-gnat.c\n+\n+# Shared library macros\n+shlib_version:=$(shell echo $(BASEVER_c) | sed -e 's/\\./,/' -e 's/\\.//g')\n+SHLIB_EXT = .exe\n+SHLIB_OBJS = @shlib_objs@\n+SHLIB_NAME = @shlib_base_name@.exe\n+SHLIB_MULTILIB =\n+SHLIB_INSTALL = $(INSTALL_DATA) $(SHLIB_NAME) $$(DESTDIR)$$(libsubdir)/$(SHLIB_ NAME)\n+SHLIB_LINK = \\\n+  $(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) -nodefaultlibs \\\n+  -shared --for-linker=/noinform -o $(SHLIB_NAME) $(SHLIB_OBJS) \\\n+  --for-linker=$(srcdir)/config/ia64/VMS_SYMVEC_@shlib_base_name@.opt \\\n+  --for-linker=gsmatch=equal,$(shlib_version)\n+"}, {"sha": "322b29273479477374f45cf6c73230f6ee25f741", "filename": "gcc/config/ia64/vms-crtinit.asm", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c24db30451c80100f6431dec406702fefa549ec6/gcc%2Fconfig%2Fia64%2Fvms-crtinit.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c24db30451c80100f6431dec406702fefa549ec6/gcc%2Fconfig%2Fia64%2Fvms-crtinit.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fvms-crtinit.asm?ref=c24db30451c80100f6431dec406702fefa549ec6", "patch": "@@ -0,0 +1,24 @@\n+/* Copyright (C) 2009 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+\t.global LIB$INITIALIZE#"}, {"sha": "41c76ae768c0ba2c112081e36fca36fa29f074ec", "filename": "gcc/config/ia64/vms-unwind.h", "status": "added", "additions": 307, "deletions": 0, "changes": 307, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c24db30451c80100f6431dec406702fefa549ec6/gcc%2Fconfig%2Fia64%2Fvms-unwind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c24db30451c80100f6431dec406702fefa549ec6/gcc%2Fconfig%2Fia64%2Fvms-unwind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fvms-unwind.h?ref=c24db30451c80100f6431dec406702fefa549ec6", "patch": "@@ -0,0 +1,307 @@\n+/* DWARF2 EH unwinding support for IA64 VMS.\n+   Copyright (C) 2005-2009 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include <vms/libicb.h>\n+#include <vms/chfdef.h>\n+#include <vms/chfctxdef.h>\n+\n+#define __int64 long long\n+#include <vms/intstkdef.h>\n+\n+#include <stdio.h>\n+#include <string.h>\n+\n+#define DYN$C_SSENTRY 66\n+/* ??? would rather get the proper header file.  */\n+\n+#define MD_FALLBACK_FRAME_STATE_FOR ia64_vms_fallback_frame_state\n+\n+extern INVO_CONTEXT_BLK * LIB$I64_CREATE_INVO_CONTEXT (void);\n+\n+extern int LIB$I64_IS_EXC_DISPATCH_FRAME (void *);\n+extern int LIB$I64_IS_AST_DISPATCH_FRAME (void *);\n+\n+extern int LIB$I64_INIT_INVO_CONTEXT (INVO_CONTEXT_BLK *, int, int);\n+extern int LIB$I64_GET_CURR_INVO_CONTEXT (INVO_CONTEXT_BLK *);\n+extern int LIB$I64_GET_PREV_INVO_CONTEXT (INVO_CONTEXT_BLK *);\n+\n+typedef unsigned long ulong;\n+typedef unsigned int uint;\n+typedef unsigned long uw_reg;\n+typedef uw_reg * uw_loc;\n+\n+typedef char fp_reg[16];\n+\n+#define DENOTES_VMS_DISPATCHER_FRAME(icb) \\\n+(LIB$I64_IS_EXC_DISPATCH_FRAME (&(icb)->libicb$ih_pc))\n+\n+#define DENOTES_BOTTOM_OF_STACK(icb) ((icb)->libicb$v_bottom_of_stack)\n+\n+#define FAIL_IF(COND) \\\n+   do { if (COND) { context->rp = 0; return _URC_END_OF_STACK; } } while (0)\n+/* Clearing context->rp is required to prevent the ia64 gcc unwinder from\n+   attempting to keep on walking the call chain.  */\n+\n+static int\n+ia64_vms_fallback_frame_state (struct _Unwind_Context *context,\n+\t\t\t       _Unwind_FrameState *fs)\n+{\n+  int i, status;\n+\n+  INVO_CONTEXT_BLK local_icb;\n+  INVO_CONTEXT_BLK *icb = &local_icb;\n+    \n+  CHFCTX * chfctx;\n+  CHF$MECH_ARRAY * chfmech;\n+  CHF64$SIGNAL_ARRAY *chfsig64;\n+  INTSTK * intstk;\n+\n+  static int eh_debug = -1;\n+  int try_bs_copy = 0;\n+  /* Non zero to attempt copy of alternate backing store contents for\n+     dirty partition in interrupted context. ??? Alpha code, only activated\n+     on specific request via specific bit in EH_DEBUG.  */\n+\n+  if (eh_debug == -1)\n+    {\n+      char * EH_DEBUG = getenv (\"EH_DEBUG\");\n+      const uint try_bs_copy_mask = (1 << 16);\n+\n+      eh_debug = EH_DEBUG ? atoi (EH_DEBUG) : 0;\n+      \n+      /* Fetch and clear the try_bs_copy bit.  */\n+      try_bs_copy = (uint)eh_debug & try_bs_copy_mask;\n+      eh_debug &= ~try_bs_copy_mask;\n+    }\n+\n+  /* We're called to attempt unwinding through a frame for which no unwind\n+     info is available, typical of an operating system exception dispatcher\n+     frame.  The code below knows how to handle this case, and only this one,\n+     returning a failure code if it finds it is not in this situation.\n+\n+     Note that we're called from deep down in the exception propagation call\n+     chain, possibly below an exception dispatcher but for a frame above it\n+     like some os entry point.  */\n+\n+  if (eh_debug)\n+    printf (\"FALLBACK - ctxt->rp=0x%lx, sp=0x%lx, psp=0x%lx, bsp=0x%lx\\n\",\n+\t    context->rp, context->sp, context->psp, context->bsp);\n+\n+  /* Step 0 :\n+     -------------------------------------------------------------------------\n+     VMS-unwind up until we reach a VMS dispatcher frame corresponding to the\n+     context we are trying to unwind through. Fail if get past this context or\n+     if we reach the bottom of stack along the way.\n+     -------------------------------------------------------------------------\n+  */\n+\n+  status = LIB$I64_INIT_INVO_CONTEXT (icb, LIBICB$K_INVO_CONTEXT_VERSION, 0);\n+  FAIL_IF (status == 0);\n+\n+  status = LIB$I64_GET_CURR_INVO_CONTEXT (icb);\n+\n+  /* Beware: we might be unwinding through nested condition handlers, so the\n+     dispatcher frame we seek might not be the first one on the way up.  Loop\n+     thus.  */     \n+  do {\n+    \n+    /* Seek the next dispatcher frame up the \"current\" point.  Stop if we\n+       either get past the target context or hit the bottom-of-stack along\n+       the way.  */\n+    status = LIB$I64_GET_PREV_INVO_CONTEXT (icb);\n+    FAIL_IF (status == 0);\n+    FAIL_IF ((uw_reg)icb->libicb$ih_sp > (uw_reg)context->psp\n+\t     || DENOTES_BOTTOM_OF_STACK (icb));\n+    \n+    if (eh_debug)\n+      printf (\"frame%s sp @ 0x%llx, pc @ 0x%llx bsp=0x%llx\\n\",\n+\t      DENOTES_VMS_DISPATCHER_FRAME (icb) ? \" (dispatcher)\" : \"\",\n+\t      icb->libicb$ih_sp, icb->libicb$ih_pc, icb->libicb$ih_bsp);\n+\n+    /* Continue until the target frame is found.  */\n+  } while ((uw_reg)icb->libicb$ih_bsp != (uw_reg)context->bsp);\n+\n+  /* If this is not a dispatcher frame, this is certainly a frame for a leaf\n+     subprogram.  Use default unwind information.  */\n+  if (! DENOTES_VMS_DISPATCHER_FRAME (icb))\n+    return _URC_END_OF_STACK;\n+\n+  /* At this point, we know we are really trying to unwind past an exception\n+     dispatcher frame, and have it described in ICB.  Proceed.  */\n+\n+  /* Step 1 :\n+     ------------------------------------------------------------------------\n+     We have the VMS dispatcher frame ICB handy and know we are trying to\n+     unwind past it.  Fetch pointers to useful datastructures from there, then\n+     unwind one step further up to the interrupted user context from which\n+     some required values will be easily accessible.\n+     ------------------------------------------------------------------------\n+  */\n+\n+  chfctx = icb->libicb$ph_chfctx_addr;\n+  FAIL_IF (chfctx == 0);\n+  \n+  chfmech = (CHF$MECH_ARRAY *)chfctx->chfctx$q_mcharglst;\n+  FAIL_IF (chfmech == 0);\n+\n+  chfsig64 = (CHF64$SIGNAL_ARRAY *)chfmech->chf$ph_mch_sig64_addr;\n+  FAIL_IF (chfsig64 == 0);\n+ \n+  intstk = (INTSTK *)chfmech->chf$q_mch_esf_addr;\n+  FAIL_IF (intstk == 0 || intstk->intstk$b_subtype == DYN$C_SSENTRY);\n+\n+  status = LIB$I64_GET_PREV_INVO_CONTEXT (icb);\n+  FAIL_IF (status == 0);\n+\n+  if (eh_debug)\n+    printf (\"User frame, \"\n+\t    \"chfmech @ 0x%lx, chfsig64 @ 0x%lx, intstk @ 0x%lx\\n\",\n+\t    (ulong)chfmech, (ulong)chfsig64, (ulong)intstk);\n+\n+  /* Step 2 :\n+     ------------------------------------------------------------------------\n+     Point the GCC context locations/values required for further unwinding at\n+     their corresponding locations/values in the datastructures at hand.\n+     ------------------------------------------------------------------------\n+  */\n+\n+  /* Static General Register locations, including scratch registers in case\n+     the unwinder needs to refer to a value stored in one of them.  */\n+  {\n+    uw_reg * ctxregs = (uw_reg *)&intstk->intstk$q_regbase;\n+\n+    for (i = 2; i <= 3; i++)\n+      context->ireg[i - 2].loc = (uw_loc)&ctxregs[i];\n+    for (i = 8; i <= 11; i++)\n+      context->ireg[i - 2].loc = (uw_loc)&ctxregs[i];\n+    for (i = 14; i <= 31; i++)\n+      context->ireg[i - 2].loc = (uw_loc)&ctxregs[i];\n+  }\n+\n+  /* Static Floating Point Register locations, as available from the\n+     mechargs array, which happens to include all the to be preserved\n+     ones + others.  */\n+  {\n+    fp_reg * ctxregs;\n+\n+    ctxregs = (fp_reg *)&chfmech->chf$fh_mch_savf2;\n+    for (i = 2; i <= 5 ; i++)\n+      context->fr_loc[i - 2] = (uw_loc)&ctxregs[i - 2];\n+\n+    ctxregs = (fp_reg *)&chfmech->chf$fh_mch_savf12;\n+    for (i = 12; i <= 31 ; i++)\n+      context->fr_loc[i - 2] = (uw_loc)&ctxregs[i - 12];\n+  }\n+\n+  /* Relevant application register locations.  */\n+\n+  context->fpsr_loc = (uw_loc)&intstk->intstk$q_fpsr;\n+  context->lc_loc   = (uw_loc)&intstk->intstk$q_lc;\n+  context->unat_loc = (uw_loc)&intstk->intstk$q_unat;\n+\n+  /* Branch register locations.  */\n+  \n+  {\n+    uw_reg * ctxregs = (uw_reg *)&intstk->intstk$q_b0;\n+\n+    for (i = 0; i < 8; i++)\n+      context->br_loc[i] = (uw_loc)&ctxregs[i];\n+  }\n+\n+  /* Necessary register values.  */\n+\n+  /* ??? Still unclear if we need to account for possible flushes to an\n+     alternate backing store (maybe the unwinding performed above did the\n+     trick already) and how this would be handled.  Blind alpha tentative\n+     below for experimentation purposes in malfunctioning cases.  */\n+  {\n+    ulong q_bsp      = (ulong) intstk->intstk$q_bsp;\n+    ulong q_bspstore = (ulong) intstk->intstk$q_bspstore;\n+    ulong q_bspbase  = (ulong) intstk->intstk$q_bspbase;\n+    ulong ih_bspbase = (ulong) icb->libicb$ih_bspbase;\n+    \n+    if (eh_debug)\n+      printf (\"q_bspstore = 0x%lx, q_bsp = 0x%lx, q_bspbase = 0x%lx\\n\"\n+\t      \"ih_bspbase = 0x%lx\\n\",\n+\t      q_bspstore, q_bsp, q_bspbase, ih_bspbase);\n+\n+    /* We witness many situations where q_bspbase is set while ih_bspbase is\n+       null, and every attempt made with q_bspbase badly failed while doing\n+       nothing resulted in proper behavior.  */\n+    if (q_bspstore < q_bsp && ih_bspbase && try_bs_copy)\n+      {\n+\tulong dirty_size = q_bsp - q_bspstore;\n+\tulong q_rnat = (ulong) intstk->intstk$q_rnat;\n+\n+\tif (eh_debug)\n+\t  printf (\"Attempting an alternate backing store copy ...\\n\");\n+\n+\tia64_copy_rbs\n+\t  (context, q_bspstore, ih_bspbase, dirty_size, q_rnat);\n+\t/* Not clear if these are the proper arguments here.  This is what\n+\t   looked the closest to what is performed in the Linux case.  */\n+      }\n+    \n+  }\n+\n+  context->bsp = (uw_reg)intstk->intstk$q_bsp;\n+  fs->no_reg_stack_frame = 1;\n+\n+  context->pr  = (uw_reg)intstk->intstk$q_preds;\n+  context->gp  = (uw_reg)intstk->intstk$q_gp;\n+\n+  /* We're directly setting up the \"context\" for a VMS exception handler.\n+     The \"previous SP\" for it is the SP upon the handler's entry, that is\n+     the SP at the condition/interruption/exception point.  */  \n+  context->psp = (uw_reg)icb->libicb$ih_sp;\n+\n+  /* Previous Frame State location.  What eventually ends up in pfs_loc is\n+     installed with ar.pfs = pfs_loc; br.ret; so setup to target intstk->q_ifs\n+     to have the interrupted context restored and not that of its caller if\n+     we happen to have a handler in the interrupted context itself.  */\n+  fs->curr.reg[UNW_REG_PFS].where = UNW_WHERE_PSPREL;\n+  fs->curr.reg[UNW_REG_PFS].val\n+    = (uw_reg)&intstk->intstk$q_ifs - (uw_reg)context->psp;\n+  fs->curr.reg[UNW_REG_PFS].when = -1;\n+\n+  /* If we need to unwind further up, past the interrupted context, we need to\n+     hand out the interrupted context's pfs, still.  */\n+  context->signal_pfs_loc = (uw_loc) &intstk->intstk$q_pfs;\n+\n+  /* Finally, rules for RP .  */\n+  {\n+    uw_reg * post_sigarray\n+      = (uw_reg *)chfsig64 + 1 + chfsig64->chf64$l_sig_args;\n+\n+    uw_reg * ih_pc_loc = post_sigarray - 2;\n+\n+    fs->curr.reg[UNW_REG_RP].where = UNW_WHERE_PSPREL;\n+    fs->curr.reg[UNW_REG_RP].val\n+      = (uw_reg)ih_pc_loc - (uw_reg)context->psp;\n+    fs->curr.reg[UNW_REG_RP].when = -1;\n+  }\n+\n+  return _URC_NO_REASON;\n+}\n+     "}, {"sha": "da47320999b71243890dae7616005ac8497b78f5", "filename": "gcc/config/ia64/vms.h", "status": "added", "additions": 231, "deletions": 0, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c24db30451c80100f6431dec406702fefa549ec6/gcc%2Fconfig%2Fia64%2Fvms.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c24db30451c80100f6431dec406702fefa549ec6/gcc%2Fconfig%2Fia64%2Fvms.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fvms.h?ref=c24db30451c80100f6431dec406702fefa549ec6", "patch": "@@ -0,0 +1,231 @@\n+/* Definitions of target machine GNU compiler. IA64-VMS version.\n+   Copyright (C) 2003-2009 Free Software Foundation, Inc.\n+   Contributed by Douglas B Rupp (rupp@gnat.com).\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#define TARGET_OBJECT_SUFFIX \".obj\"\n+#define TARGET_EXECUTABLE_SUFFIX \".exe\"\n+\n+#define OBJECT_FORMAT_ELF\n+\n+#define TARGET_OS_CPP_BUILTINS()\t\t\\\n+    do {\t\t\t\t\t\\\n+\tbuiltin_define_std (\"vms\");\t\t\\\n+\tbuiltin_define_std (\"VMS\");\t\t\\\n+\tbuiltin_define (\"__IA64\");\t\t\\\n+\tbuiltin_assert (\"system=vms\");\t\t\\\n+\tbuiltin_define (\"__IEEE_FLOAT\");\t\\\n+    } while (0)\n+\n+/* By default, allow $ to be part of an identifier.  */\n+#define DOLLARS_IN_IDENTIFIERS 2\n+\n+#undef TARGET_ABI_OPEN_VMS\n+#define TARGET_ABI_OPEN_VMS 1\n+\n+#undef TARGET_NAME   \n+#define TARGET_NAME \"OpenVMS/IA64\"\n+#undef TARGET_VERSION\n+#define TARGET_VERSION fprintf (stderr, \" (%s)\", TARGET_NAME);           \n+\n+/* Need .debug_line info generated from gcc and gas.  */\n+#undef TARGET_DEFAULT\n+#define TARGET_DEFAULT (MASK_DWARF2_ASM | MASK_GNU_AS)\n+\n+#define VMS_DEBUG_MAIN_POINTER \"TRANSFER$BREAK$GO\"\n+\n+/* \"long\" is 32 bits, but 64 bits for Ada.  */\n+#undef LONG_TYPE_SIZE\n+#define LONG_TYPE_SIZE 32\n+#define ADA_LONG_TYPE_SIZE 64\n+\n+/* Pointer is 32 bits but the hardware has 64-bit addresses, sign extended.  */\n+#undef POINTER_SIZE\n+#define POINTER_SIZE 32\n+#define POINTERS_EXTEND_UNSIGNED 0\n+\n+#undef MAX_OFILE_ALIGNMENT\n+#define MAX_OFILE_ALIGNMENT 524288  /* 8 x 2^16 by DEC Ada Test CD40VRA */\n+\n+/* Widest floating-point type efficiently supported by hardware and OS.  */\n+#undef WIDEST_HARDWARE_FP_SIZE\n+#define WIDEST_HARDWARE_FP_SIZE 64\n+\n+/* HP OpenVMS Calling Standard dated June, 2004, that describes\n+   HP OpenVMS I64 Version 8.2EFT\n+   chapter 4 \"OpenVMS I64 Conventions\"\n+   section 4.7 \"Procedure Linkage\"\n+   subsection 4.7.5.2, \"Normal Register Parameters\"\n+\n+   \"Unsigned integral (except unsigned 32-bit), set, and VAX\n+   floating-point values passed in registers are zero-filled;\n+   signed integral values as well as unsigned 32-bit integral\n+   values are sign-extended to 64 bits.  For all other types\n+   passed in the general registers, unused bits are undefined.\"  */\n+#define PROMOTE_FUNCTION_MODE(MODE,UNSIGNEDP,TYPE)\t\\\n+  if (GET_MODE_CLASS (MODE) == MODE_INT\t\t\t\\\n+      && GET_MODE_SIZE (MODE) < UNITS_PER_WORD)\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      if ((MODE) == SImode)\t\t\t\t\\\n+\t(UNSIGNEDP) = 0;\t\t\t\t\\\n+      (MODE) = DImode;\t\t\t\t\t\\\n+    }\n+\n+/* The structure return address arrives as an \"argument\" on VMS.  */\n+#undef PCC_STATIC_STRUCT_RETURN\n+\n+/* Turn on VMS specific Dwarf2 features.  */\n+#define VMS_DEBUGGING_INFO 1\n+\n+#define ASM_OUTPUT_DWARF_DELTA_UNITS(FILE,SIZE,LABEL1,LABEL2,UNITS) \\\n+do {                                \\\n+  fprintf (FILE, \"\\tdata4.ua\\t (\"); \\\n+  assemble_name (FILE, LABEL1);     \\\n+  fprintf (FILE, \"-\");              \\\n+  assemble_name (FILE, LABEL2);     \\\n+  fprintf (FILE, \")/16*3\");         \\\n+} while (0)\n+\n+#undef STARTFILE_SPEC\n+#define STARTFILE_SPEC \\\n+\"%{!shared:%{mvms-return-codes:vcrt0.o%s} %{!mvms-return-codes:pcrt0.o%s} \\\n+    crtbegin.o%s} \\\n+ %{!static:%{shared:crtinitS.o%s crtbeginS.o%s}}\"\n+\n+#undef ENDFILE_SPEC\n+#define ENDFILE_SPEC \\\n+\"%{!shared:crtend.o%s} %{!static:%{shared:crtendS.o%s}}\"\n+\n+#define LINK_GCC_C_SEQUENCE_SPEC \"%G\"\n+\n+#undef LINK_SPEC\n+#define LINK_SPEC \"%{g*} %{map} %{save-temps} %{shared} %{v}\"\n+\n+#undef LIB_SPEC\n+#define LIB_SPEC \"\"\n+\n+#undef ASM_SPEC\n+#define ASM_SPEC \\\n+\"%{mno-gnu-as:-N so -N vms_upcase -W DVLoc_off} %{mconstant-gp:-M const_gp} \\\n+ %{mauto-pic:-M no_plabel} %{source-listing:-ahdl=%b.lis}\"\n+\n+#undef ASM_OUTPUT_EXTERNAL_LIBCALL\n+#define ASM_OUTPUT_EXTERNAL_LIBCALL(FILE, FUN)\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\\\n+  (*targetm.asm_out.globalize_label) (FILE, XSTR (FUN, 0));\t\\\n+  ASM_OUTPUT_TYPE_DIRECTIVE (FILE, XSTR (FUN, 0), \"function\");\t\\\n+} while (0)\n+\n+/* Set the function to change the names of the division and modulus\n+   functions.   */\n+#undef TARGET_INIT_LIBFUNCS\n+#define TARGET_INIT_LIBFUNCS ia64_vms_init_libfuncs\n+\n+#define NAME__MAIN \"__gccmain\"\n+#define SYMBOL__MAIN __gccmain\n+\n+#define CTOR_LIST_BEGIN asm (\".global\\tLIB$INITIALIZE#\\n\");                  \\\n+STATIC func_ptr __CTOR_LIST__[1]                                             \\\n+  __attribute__ ((__unused__, section(\".ctors\"), aligned(sizeof(func_ptr)))) \\\n+  = { (func_ptr) (-1) };\n+\n+#undef INIT_SECTION_ASM_OP\n+#define INIT_SECTION_ASM_OP \".section\\tLIB$INITIALIZE#,\\\"a\\\",@progbits\"\n+\n+#define CRT_CALL_STATIC_FUNCTION(SECTION_OP, FUNC)      \\\n+  asm (SECTION_OP \"\\n\\tdata4 @fptr(\" #FUNC\"#)\\n\");      \\\n+  FORCE_CODE_SECTION_ALIGN                            \\\n+  asm (TEXT_SECTION_ASM_OP);\n+\n+#undef FINI_SECTION_ASM_OP\n+\n+/* Maybe same as HPUX?  Needs to be checked.  */\n+#define JMP_BUF_SIZE  (8 * 76)\n+\n+typedef struct crtl_name_spec\n+{\n+  const char *const name;\n+  const char *deccname;\n+  int referenced;\n+} crtl_name_spec;\n+\n+#include \"config/vms/vms-crtl.h\"\n+\n+/* Alias CRTL names to 32/64bit DECCRTL functions.\n+   Fixme: This should do a binary search.  */\n+#define DO_CRTL_NAMES                                                      \\\n+  do                                                                       \\\n+    {                                                                      \\\n+      int i;                                                               \\\n+      static crtl_name_spec vms_crtl_names[] = CRTL_NAMES;                 \\\n+      static int malloc64_init = 0;                                        \\\n+                                                                           \\\n+      if ((malloc64_init == 0) && TARGET_MALLOC64)                         \\\n+\t{                                                                  \\\n+          for (i=0; vms_crtl_names [i].name; i++)                          \\\n+            {                                                              \\\n+\t      if (strcmp (\"calloc\", vms_crtl_names [i].name) == 0)         \\\n+                vms_crtl_names [i].deccname = \"decc$_calloc64\";            \\\n+              else                                                         \\\n+\t      if (strcmp (\"malloc\", vms_crtl_names [i].name) == 0)         \\\n+                vms_crtl_names [i].deccname = \"decc$_malloc64\";            \\\n+              else                                                         \\\n+\t      if (strcmp (\"realloc\", vms_crtl_names [i].name) == 0)        \\\n+                vms_crtl_names [i].deccname = \"decc$_realloc64\";           \\\n+              else                                                         \\\n+\t      if (strcmp (\"strdup\", vms_crtl_names [i].name) == 0)         \\\n+                vms_crtl_names [i].deccname = \"decc$_strdup64\";            \\\n+\t    }                                                              \\\n+            malloc64_init = 1;                                             \\\n+        }                                                                  \\\n+      for (i=0; vms_crtl_names [i].name; i++)                              \\\n+\tif (!vms_crtl_names [i].referenced &&                              \\\n+\t    (strcmp (name, vms_crtl_names [i].name) == 0))                 \\\n+\t  {                                                                \\\n+\t    fprintf (file, \"\\t.alias %s, \\\"%s\\\"\\n\",                        \\\n+\t\t     name, vms_crtl_names [i].deccname);                   \\\n+\t    vms_crtl_names [i].referenced = 1;                             \\\n+\t  }                                                                \\\n+    } while (0)\n+\n+#undef OPTIMIZATION_OPTIONS\n+#define OPTIMIZATION_OPTIONS(LEVEL,SIZE)                   \\\n+  do {                                                     \\\n+       flag_merge_constants = 0;                           \\\n+       ia64_optimization_options ((LEVEL), (SIZE));        \\\n+  } while (0)\n+\n+/* Define this to be nonzero if static stack checking is supported.  */\n+#define STACK_CHECK_STATIC_BUILTIN 1\n+\n+#define MD_UNWIND_SUPPORT \"config/ia64/vms-unwind.h\"\n+\n+#define UNW_IVMS_MODE(HEADER) (((HEADER) >> 44) & 0x3L)\n+#define MD_UNW_COMPATIBLE_PERSONALITY_P(HEADER) (!UNW_IVMS_MODE (HEADER))\n+\n+/* Minimum amount of stack required to recover from an anticipated stack\n+   overflow detection.  The default value conveys an estimate of the amount\n+   of stack required to propagate an exception.  */\n+#define STACK_CHECK_PROTECT (24 * 1024)\n+\n+#undef ASM_OUTPUT_ALIGNED_DECL_COMMON\n+#define ASM_OUTPUT_ALIGNED_DECL_COMMON(FILE, DECL, NAME, SIZE, ALIGN) \\\n+  ia64_vms_output_aligned_decl_common (FILE, DECL, NAME, SIZE, ALIGN)\n+\n+#undef TARGET_ASM_NAMED_SECTION\n+#define TARGET_ASM_NAMED_SECTION ia64_vms_elf_asm_named_section"}, {"sha": "ac1d7a50799afd584dbccdeacb7cfbbf7686e2a8", "filename": "gcc/config/ia64/vms64.h", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c24db30451c80100f6431dec406702fefa549ec6/gcc%2Fconfig%2Fia64%2Fvms64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c24db30451c80100f6431dec406702fefa549ec6/gcc%2Fconfig%2Fia64%2Fvms64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fvms64.h?ref=c24db30451c80100f6431dec406702fefa549ec6", "patch": "@@ -0,0 +1,41 @@\n+/* Definitions of target machine GNU compiler. 64bit IA64-VMS version.\n+   Copyright (C) 2004-2009 Free Software Foundation, Inc.\n+   Contributed by Douglas B Rupp (rupp@gnat.com).\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#undef TARGET_OS_CPP_BUILTINS\n+#define TARGET_OS_CPP_BUILTINS()\t\t\\\n+    do {\t\t\t\t\t\\\n+\tbuiltin_define_std (\"vms\");\t\t\\\n+\tbuiltin_define_std (\"VMS\");\t\t\\\n+\tbuiltin_define (\"__IA64\");\t\t\\\n+\tbuiltin_assert (\"system=vms\");\t\t\\\n+\tbuiltin_define (\"__IEEE_FLOAT\");\t\\\n+\tbuiltin_define (\"__LONG_POINTERS=1\");\t\\\n+    } while (0)\n+\n+#undef LONG_TYPE_SIZE\n+#define LONG_TYPE_SIZE 64\n+\n+#undef POINTER_SIZE\n+#define POINTER_SIZE 64\n+\n+#undef TARGET_DEFAULT\n+#define TARGET_DEFAULT (MASK_DWARF2_ASM | MASK_GNU_AS | MASK_MALLOC64)\n+\n+#include \"config/vms/vms-crtl-64.h\""}, {"sha": "88b46dfda6ca4633b64b7ce0f03dd27610b415a6", "filename": "gcc/config/ia64/vms_symvec_libgcc_s.opt", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c24db30451c80100f6431dec406702fefa549ec6/gcc%2Fconfig%2Fia64%2Fvms_symvec_libgcc_s.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c24db30451c80100f6431dec406702fefa549ec6/gcc%2Fconfig%2Fia64%2Fvms_symvec_libgcc_s.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fvms_symvec_libgcc_s.opt?ref=c24db30451c80100f6431dec406702fefa549ec6", "patch": "@@ -0,0 +1,89 @@\n+! Symbol vector listing all the universal symbols to be exported when\n+! building libgcc_s.exe shareable image on IVMS for Gcc 3.4.5.\n+! It would be better to auto-generate this file.\n+\n+case_sensitive=yes\n+SYMBOL_VECTOR=(__divdf3=PROCEDURE)\n+SYMBOL_VECTOR=(__divdi3=PROCEDURE)\n+SYMBOL_VECTOR=(__divsf3=PROCEDURE)\n+SYMBOL_VECTOR=(__divsi3=PROCEDURE)\n+SYMBOL_VECTOR=(__divxf3=PROCEDURE)\n+SYMBOL_VECTOR=(__moddi3=PROCEDURE)\n+SYMBOL_VECTOR=(__modsi3=PROCEDURE)\n+SYMBOL_VECTOR=(__ia64_nonlocal_goto=PROCEDURE)\n+SYMBOL_VECTOR=(__ia64_restore_stack_nonlocal=PROCEDURE)\n+SYMBOL_VECTOR=(__ia64_save_stack_nonlocal=PROCEDURE)\n+SYMBOL_VECTOR=(__ia64_trampoline=PROCEDURE)\n+SYMBOL_VECTOR=(__udivdi3=PROCEDURE)\n+SYMBOL_VECTOR=(__udivsi3=PROCEDURE)\n+SYMBOL_VECTOR=(__umoddi3=PROCEDURE)\n+SYMBOL_VECTOR=(__umodsi3=PROCEDURE)\n+SYMBOL_VECTOR=(__absvti2=PROCEDURE)\n+SYMBOL_VECTOR=(__absvdi2=PROCEDURE)\n+SYMBOL_VECTOR=(__absvsi2=PROCEDURE)\n+SYMBOL_VECTOR=(__addvti3=PROCEDURE)\n+SYMBOL_VECTOR=(__addvdi3=PROCEDURE)\n+SYMBOL_VECTOR=(__addvsi3=PROCEDURE)\n+SYMBOL_VECTOR=(__ashlti3=PROCEDURE)\n+SYMBOL_VECTOR=(__ashrti3=PROCEDURE)\n+SYMBOL_VECTOR=(__clear_cache=PROCEDURE)\n+SYMBOL_VECTOR=(__clzti2=PROCEDURE)\n+SYMBOL_VECTOR=(__clzdi2=PROCEDURE)\n+SYMBOL_VECTOR=(__cmpti2=PROCEDURE)\n+SYMBOL_VECTOR=(__ctzti2=PROCEDURE)\n+SYMBOL_VECTOR=(__ctzdi2=PROCEDURE)\n+SYMBOL_VECTOR=(__divti3=PROCEDURE)\n+SYMBOL_VECTOR=(__enable_execute_stack=PROCEDURE)\n+SYMBOL_VECTOR=(__ffsti2=PROCEDURE)\n+SYMBOL_VECTOR=(__ffsdi2=PROCEDURE)\n+SYMBOL_VECTOR=(__fixdfti=PROCEDURE)\n+SYMBOL_VECTOR=(__fixsfti=PROCEDURE)\n+SYMBOL_VECTOR=(__fixunsdfti=PROCEDURE)\n+SYMBOL_VECTOR=(__fixunsdfdi=PROCEDURE)\n+SYMBOL_VECTOR=(__fixunssfti=PROCEDURE)\n+SYMBOL_VECTOR=(__fixunssfdi=PROCEDURE)\n+SYMBOL_VECTOR=(__floattidf=PROCEDURE)\n+SYMBOL_VECTOR=(__floattisf=PROCEDURE)\n+SYMBOL_VECTOR=(__lshrti3=PROCEDURE)\n+SYMBOL_VECTOR=(__modti3=PROCEDURE)\n+SYMBOL_VECTOR=(__multi3=PROCEDURE)\n+SYMBOL_VECTOR=(__mulvti3=PROCEDURE)\n+SYMBOL_VECTOR=(__mulvdi3=PROCEDURE)\n+SYMBOL_VECTOR=(__mulvsi3=PROCEDURE)\n+SYMBOL_VECTOR=(__negti2=PROCEDURE)\n+SYMBOL_VECTOR=(__negvti2=PROCEDURE)\n+SYMBOL_VECTOR=(__negvdi2=PROCEDURE)\n+SYMBOL_VECTOR=(__negvsi2=PROCEDURE)\n+SYMBOL_VECTOR=(__parityti2=PROCEDURE)\n+SYMBOL_VECTOR=(__paritydi2=PROCEDURE)\n+SYMBOL_VECTOR=(__popcountti2=PROCEDURE)\n+SYMBOL_VECTOR=(__popcountdi2=PROCEDURE)\n+SYMBOL_VECTOR=(__subvti3=PROCEDURE)\n+SYMBOL_VECTOR=(__subvdi3=PROCEDURE)\n+SYMBOL_VECTOR=(__subvsi3=PROCEDURE)\n+SYMBOL_VECTOR=(__ucmpti2=PROCEDURE)\n+SYMBOL_VECTOR=(__udiv_w_sdiv=PROCEDURE)\n+SYMBOL_VECTOR=(__udivti3=PROCEDURE)\n+SYMBOL_VECTOR=(__udivmodti4=PROCEDURE)\n+SYMBOL_VECTOR=(__umodti3=PROCEDURE)\n+SYMBOL_VECTOR=(__gthread_active_p=PROCEDURE)\n+SYMBOL_VECTOR=(__gthread_mutex_lock=PROCEDURE)\n+SYMBOL_VECTOR=(__gthread_mutex_unlock=PROCEDURE)\n+SYMBOL_VECTOR=(__gcc_personality_v0=PROCEDURE)\n+SYMBOL_VECTOR=(_Unwind_GetGR=PROCEDURE)\n+SYMBOL_VECTOR=(_Unwind_SetGR=PROCEDURE)\n+SYMBOL_VECTOR=(_Unwind_GetIP=PROCEDURE)\n+SYMBOL_VECTOR=(_Unwind_GetIPInfo=PROCEDURE)\n+SYMBOL_VECTOR=(_Unwind_SetIP=PROCEDURE)\n+SYMBOL_VECTOR=(_Unwind_GetLanguageSpecificData=PROCEDURE)\n+SYMBOL_VECTOR=(_Unwind_GetRegionStart=PROCEDURE)\n+SYMBOL_VECTOR=(_Unwind_FindEnclosingFunction=PROCEDURE)\n+SYMBOL_VECTOR=(_Unwind_GetCFA=PROCEDURE)\n+SYMBOL_VECTOR=(_Unwind_GetBSP=PROCEDURE)\n+SYMBOL_VECTOR=(_Unwind_RaiseException=PROCEDURE)\n+SYMBOL_VECTOR=(_Unwind_ForcedUnwind=PROCEDURE)\n+SYMBOL_VECTOR=(_Unwind_Resume=PROCEDURE)\n+SYMBOL_VECTOR=(_Unwind_Resume_or_Rethrow=PROCEDURE)\n+SYMBOL_VECTOR=(_Unwind_DeleteException=PROCEDURE)\n+SYMBOL_VECTOR=(_Unwind_Backtrace=PROCEDURE)\n+case_sensitive=NO"}]}