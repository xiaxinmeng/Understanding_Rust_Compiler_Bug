{"sha": "ad28cff7c180b612f54512fd7f7ed7b11f09fc05", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWQyOGNmZjdjMTgwYjYxMmY1NDUxMmZkN2Y3ZWQ3YjExZjA5ZmMwNQ==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.co.uk", "date": "2002-07-18T22:08:35Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2002-07-18T22:08:35Z"}, "message": "cppexp.c (cpp_num_mul): Remove unused parameter.\n\n\t* cppexp.c (cpp_num_mul): Remove unused parameter.\n\t(UNARY, BINARY, OTHER, binary_handler): Remove.\n\t(ALWAYS_EVAL): New.\n\t(optab): Update.\n\t(reduce): Refactor to a large switch, don't use a function\n\tpointer.\n\nFrom-SVN: r55570", "tree": {"sha": "c35620c4cc551b15ba8490f87b29651264d6244a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c35620c4cc551b15ba8490f87b29651264d6244a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ad28cff7c180b612f54512fd7f7ed7b11f09fc05", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad28cff7c180b612f54512fd7f7ed7b11f09fc05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad28cff7c180b612f54512fd7f7ed7b11f09fc05", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad28cff7c180b612f54512fd7f7ed7b11f09fc05/comments", "author": {"login": "neilb-xx", "id": 160762, "node_id": "MDQ6VXNlcjE2MDc2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/160762?v=4", "gravatar_id": "", "url": "https://api.github.com/users/neilb-xx", "html_url": "https://github.com/neilb-xx", "followers_url": "https://api.github.com/users/neilb-xx/followers", "following_url": "https://api.github.com/users/neilb-xx/following{/other_user}", "gists_url": "https://api.github.com/users/neilb-xx/gists{/gist_id}", "starred_url": "https://api.github.com/users/neilb-xx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/neilb-xx/subscriptions", "organizations_url": "https://api.github.com/users/neilb-xx/orgs", "repos_url": "https://api.github.com/users/neilb-xx/repos", "events_url": "https://api.github.com/users/neilb-xx/events{/privacy}", "received_events_url": "https://api.github.com/users/neilb-xx/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "139b7f86861245f14f1231326dd9ab9b7e1f1bea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/139b7f86861245f14f1231326dd9ab9b7e1f1bea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/139b7f86861245f14f1231326dd9ab9b7e1f1bea"}], "stats": {"total": 253, "additions": 148, "deletions": 105}, "files": [{"sha": "bf1171f90b4d30abb3bfe512e69eb9ffe41e505c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad28cff7c180b612f54512fd7f7ed7b11f09fc05/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad28cff7c180b612f54512fd7f7ed7b11f09fc05/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ad28cff7c180b612f54512fd7f7ed7b11f09fc05", "patch": "@@ -1,3 +1,12 @@\n+2002-07-18  Neil Booth  <neil@daikokuya.co.uk>\n+\n+\t* cppexp.c (cpp_num_mul): Remove unused parameter.\n+\t(UNARY, BINARY, OTHER, binary_handler): Remove.\n+\t(ALWAYS_EVAL): New.\n+\t(optab): Update.\n+\t(reduce): Refactor to a large switch, don't use a function\n+\tpointer.\n+\n 2002-07-18  Bo Thorsen  <bo@berlioz.suse.de>\n \n \t* config/i386/linux64.h (STARTFILE_PREFIX_SPEC): Define this always."}, {"sha": "92916a8a41d861beb60620125f1b07320420c0f5", "filename": "gcc/cppexp.c", "status": "modified", "additions": 139, "deletions": 105, "changes": 244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad28cff7c180b612f54512fd7f7ed7b11f09fc05/gcc%2Fcppexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad28cff7c180b612f54512fd7f7ed7b11f09fc05/gcc%2Fcppexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppexp.c?ref=ad28cff7c180b612f54512fd7f7ed7b11f09fc05", "patch": "@@ -30,7 +30,7 @@ Boston, MA 02111-1307, USA.  */\n \n struct op\n {\n-  cpp_num value;\t\t     /* The value logically \"right\" of op.  */\n+  cpp_num value;\t\t/* The value logically \"right\" of op.  */\n   enum cpp_ttype op;\n };\n \n@@ -52,8 +52,7 @@ static cpp_num num_inequality_op PARAMS ((cpp_reader *, cpp_num, cpp_num,\n \t\t\t\t\t  enum cpp_ttype));\n static cpp_num num_equality_op PARAMS ((cpp_reader *, cpp_num, cpp_num,\n \t\t\t\t\tenum cpp_ttype));\n-static cpp_num num_mul PARAMS ((cpp_reader *, cpp_num, cpp_num,\n-\t\t\t\tenum cpp_ttype));\n+static cpp_num num_mul PARAMS ((cpp_reader *, cpp_num, cpp_num));\n static cpp_num num_div_op PARAMS ((cpp_reader *, cpp_num, cpp_num,\n \t\t\t\t   enum cpp_ttype));\n static cpp_num num_lshift PARAMS ((cpp_num, size_t, size_t));\n@@ -631,60 +630,54 @@ The parser assumes all shifted operators require a left operand unless\n the flag NO_L_OPERAND is set.  These semantics are automatic; any\n extra semantics need to be handled with operator-specific code.  */\n \n-/* Flags.  */\n+/* Flags.  ALWAYS_EVAL is for operators that should be evaluated even\n+   if skip_eval is true; perhaps they are invalid and require a\n+   diagnostic, or they might modify skip_eval.  */\n #define NO_L_OPERAND\t(1 << 0)\n #define LEFT_ASSOC\t(1 << 1)\n+#define ALWAYS_EVAL\t(1 << 2)\n \n-/* Arity. */\n-#define UNARY\t\t(1 << 0)\n-#define BINARY\t\t(1 << 1)\n-#define OTHER\t\t(1 << 2)\n-\n-typedef cpp_num (*binary_handler) PARAMS ((cpp_reader *, cpp_num, cpp_num,\n-\t\t\t\t\t   enum cpp_ttype));\n /* Operator to priority map.  Must be in the same order as the first\n    N entries of enum cpp_ttype.  */\n static const struct operator\n {\n   uchar prio;\n   uchar flags;\n-  uchar arity;\n-  binary_handler handler;\n } optab[] =\n {\n-  /* EQ */\t\t{0, 0, OTHER, NULL},\t/* Shouldn't happen.  */\n-  /* NOT */\t\t{16, NO_L_OPERAND, UNARY, NULL},\n-  /* GREATER */\t\t{12, LEFT_ASSOC, BINARY, num_inequality_op},\n-  /* LESS */\t\t{12, LEFT_ASSOC, BINARY, num_inequality_op},\n-  /* PLUS */\t\t{14, LEFT_ASSOC, BINARY, num_binary_op},\n-  /* MINUS */\t\t{14, LEFT_ASSOC, BINARY, num_binary_op},\n-  /* MULT */\t\t{15, LEFT_ASSOC, BINARY, num_mul},\n-  /* DIV */\t\t{15, LEFT_ASSOC, BINARY, num_div_op},\n-  /* MOD */\t\t{15, LEFT_ASSOC, BINARY, num_div_op},\n-  /* AND */\t\t{9, LEFT_ASSOC, BINARY, num_bitwise_op},\n-  /* OR */\t\t{7, LEFT_ASSOC, BINARY, num_bitwise_op},\n-  /* XOR */\t\t{8, LEFT_ASSOC, BINARY, num_bitwise_op},\n-  /* RSHIFT */\t\t{13, LEFT_ASSOC, BINARY, num_binary_op},\n-  /* LSHIFT */\t\t{13, LEFT_ASSOC, BINARY, num_binary_op},\n-\n-  /* MIN */\t\t{10, LEFT_ASSOC, BINARY, num_binary_op},\n-  /* MAX */\t\t{10, LEFT_ASSOC, BINARY, num_binary_op},\n-\n-  /* COMPL */\t\t{16, NO_L_OPERAND, UNARY, NULL},\n-  /* AND_AND */\t\t{6, LEFT_ASSOC, OTHER, NULL},\n-  /* OR_OR */\t\t{5, LEFT_ASSOC, OTHER, NULL},\n-  /* QUERY */\t\t{3, 0, OTHER, NULL},\n-  /* COLON */\t\t{4, LEFT_ASSOC, OTHER, NULL},\n-  /* COMMA */\t\t{2, LEFT_ASSOC, BINARY, num_binary_op},\n-  /* OPEN_PAREN */\t{1, NO_L_OPERAND, OTHER, NULL},\n-  /* CLOSE_PAREN */\t{0, 0, OTHER, NULL},\n-  /* EOF */\t\t{0, 0, OTHER, NULL},\n-  /* EQ_EQ */\t\t{11, LEFT_ASSOC, BINARY, num_equality_op},\n-  /* NOT_EQ */\t\t{11, LEFT_ASSOC, BINARY, num_equality_op},\n-  /* GREATER_EQ */\t{12, LEFT_ASSOC, BINARY, num_inequality_op},\n-  /* LESS_EQ */\t\t{12, LEFT_ASSOC, BINARY, num_inequality_op},\n-  /* UPLUS */\t\t{16, NO_L_OPERAND, UNARY, NULL},\n-  /* UMINUS */\t\t{16, NO_L_OPERAND, UNARY, NULL}\n+  /* EQ */\t\t{0, 0},\t/* Shouldn't happen.  */\n+  /* NOT */\t\t{16, NO_L_OPERAND},\n+  /* GREATER */\t\t{12, LEFT_ASSOC},\n+  /* LESS */\t\t{12, LEFT_ASSOC},\n+  /* PLUS */\t\t{14, LEFT_ASSOC},\n+  /* MINUS */\t\t{14, LEFT_ASSOC},\n+  /* MULT */\t\t{15, LEFT_ASSOC},\n+  /* DIV */\t\t{15, LEFT_ASSOC},\n+  /* MOD */\t\t{15, LEFT_ASSOC},\n+  /* AND */\t\t{9, LEFT_ASSOC},\n+  /* OR */\t\t{7, LEFT_ASSOC},\n+  /* XOR */\t\t{8, LEFT_ASSOC},\n+  /* RSHIFT */\t\t{13, LEFT_ASSOC},\n+  /* LSHIFT */\t\t{13, LEFT_ASSOC},\n+\n+  /* MIN */\t\t{10, LEFT_ASSOC},\n+  /* MAX */\t\t{10, LEFT_ASSOC},\n+\n+  /* COMPL */\t\t{16, NO_L_OPERAND},\n+  /* AND_AND */\t\t{6, LEFT_ASSOC | ALWAYS_EVAL},\n+  /* OR_OR */\t\t{5, LEFT_ASSOC | ALWAYS_EVAL},\n+  /* QUERY */\t\t{3, ALWAYS_EVAL},\n+  /* COLON */\t\t{4, LEFT_ASSOC | ALWAYS_EVAL},\n+  /* COMMA */\t\t{2, LEFT_ASSOC},\n+  /* OPEN_PAREN */\t{1, NO_L_OPERAND | ALWAYS_EVAL},\n+  /* CLOSE_PAREN */\t{0, 0},\n+  /* EOF */\t\t{0, 0},\n+  /* EQ_EQ */\t\t{11, LEFT_ASSOC},\n+  /* NOT_EQ */\t\t{11, LEFT_ASSOC},\n+  /* GREATER_EQ */\t{12, LEFT_ASSOC},\n+  /* LESS_EQ */\t\t{12, LEFT_ASSOC},\n+  /* UPLUS */\t\t{16, NO_L_OPERAND},\n+  /* UMINUS */\t\t{16, NO_L_OPERAND}\n };\n \n /* Parse and evaluate a C expression, reading from PFILE.\n@@ -870,70 +863,112 @@ reduce (pfile, top, op)\n   prio = optab[op].prio - ((optab[op].flags & LEFT_ASSOC) != 0);\n   while (prio < optab[top->op].prio)\n     {\n-      if (optab[top->op].arity == UNARY)\n-\t{\n-\t  if (!pfile->state.skip_eval)\n+      if (!pfile->state.skip_eval || optab[top->op].flags & ALWAYS_EVAL)\n+\tswitch (top->op)\n+\t  {\n+\t  case CPP_UPLUS:\n+\t  case CPP_UMINUS:\n+\t  case CPP_NOT:\n+\t  case CPP_COMPL:\n \t    top[-1].value = num_unary_op (pfile, top->value, top->op);\n-\t  top--;\n-\t}\n-      else if (optab[top->op].arity == BINARY)\n-\t{\n-\t  if (!pfile->state.skip_eval)\n-\t    top[-1].value = (* (binary_handler) optab[top->op].handler)\n-\t      (pfile, top[-1].value, top->value, top->op);\n-\t  top--;\n-\t}\n-      /* Anything changing skip_eval has to be handled here.  */\n-      else switch (top--->op)\n-\t{\n-\tcase CPP_OR_OR:\n-\t  if (!num_zerop (top->value))\n-\t    pfile->state.skip_eval--;\n-\t  top->value.low = !num_zerop (top->value) || !num_zerop (top[1].value);\n-\t  top->value.high = 0;\n-\t  top->value.unsignedp = false;\n-\t  top->value.overflow = false;\n-\t  break;\n+\t    break;\n \n-\tcase CPP_AND_AND:\n-\t  if (num_zerop (top->value))\n-\t    pfile->state.skip_eval--;\n-\t  top->value.low = !num_zerop (top->value) && !num_zerop (top[1].value);\n-\t  top->value.high = 0;\n-\t  top->value.unsignedp = false;\n-\t  top->value.overflow = false;\n-\t  break;\n+\t  case CPP_PLUS:\n+\t  case CPP_MINUS:\n+\t  case CPP_RSHIFT:\n+\t  case CPP_LSHIFT:\n+\t  case CPP_MIN:\n+\t  case CPP_MAX:\n+\t  case CPP_COMMA:\n+\t    top[-1].value = num_binary_op (pfile, top[-1].value,\n+\t\t\t\t\t   top->value, top->op);\n+\t    break;\n \n-\tcase CPP_OPEN_PAREN:\n-\t  if (op != CPP_CLOSE_PAREN)\n-\t    {\n-\t      cpp_error (pfile, DL_ERROR, \"missing ')' in expression\");\n-\t      return 0;\n-\t    }\n-\t  top->value = top[1].value;\n-\t  return top;\n+\t  case CPP_GREATER:\n+\t  case CPP_LESS:\n+\t  case CPP_GREATER_EQ:\n+\t  case CPP_LESS_EQ:\n+\t    top[-1].value\n+\t      = num_inequality_op (pfile, top[-1].value, top->value, top->op);\n+\t    break;\n \n-\tcase CPP_COLON:\n-\t  top--;\n-\t  if (!num_zerop (top->value))\n-\t    {\n-\t      pfile->state.skip_eval--;\n-\t      top->value = top[1].value;\n-\t    }\n-\t  else\n-\t    top->value = top[2].value;\n-\t  top->value.unsignedp = (top[1].value.unsignedp\n-\t\t\t\t  || top[2].value.unsignedp);\n-\t  break;\n+\t  case CPP_EQ_EQ:\n+\t  case CPP_NOT_EQ:\n+\t    top[-1].value\n+\t      = num_equality_op (pfile, top[-1].value, top->value, top->op);\n+\t    break;\n \n-\tcase CPP_QUERY:\n-\t  cpp_error (pfile, DL_ERROR, \"'?' without following ':'\");\n-\t  return 0;\n+\t  case CPP_AND:\n+\t  case CPP_OR:\n+\t  case CPP_XOR:\n+\t    top[-1].value\n+\t      = num_bitwise_op (pfile, top[-1].value, top->value, top->op);\n+\t    break;\n \n-\tdefault:\n-\t  goto bad_op;\n-\t}\n+\t  case CPP_MULT:\n+\t    top[-1].value = num_mul (pfile, top[-1].value, top->value);\n+\t    break;\n+\n+\t  case CPP_DIV:\n+\t  case CPP_MOD:\n+\t    top[-1].value = num_div_op (pfile, top[-1].value,\n+\t\t\t\t\ttop->value, top->op);\n+\t    break;\n+\n+\t  case CPP_OR_OR:\n+\t    top--;\n+\t    if (!num_zerop (top->value))\n+\t      pfile->state.skip_eval--;\n+\t    top->value.low = (!num_zerop (top->value)\n+\t\t\t      || !num_zerop (top[1].value));\n+\t    top->value.high = 0;\n+\t    top->value.unsignedp = false;\n+\t    top->value.overflow = false;\n+\t    continue;\n+\n+\t  case CPP_AND_AND:\n+\t    top--;\n+\t    if (num_zerop (top->value))\n+\t      pfile->state.skip_eval--;\n+\t    top->value.low = (!num_zerop (top->value)\n+\t\t\t      && !num_zerop (top[1].value));\n+\t    top->value.high = 0;\n+\t    top->value.unsignedp = false;\n+\t    top->value.overflow = false;\n+\t    continue;\n+\n+\t  case CPP_OPEN_PAREN:\n+\t    if (op != CPP_CLOSE_PAREN)\n+\t      {\n+\t\tcpp_error (pfile, DL_ERROR, \"missing ')' in expression\");\n+\t\treturn 0;\n+\t      }\n+\t    top--;\n+\t    top->value = top[1].value;\n+\t    return top;\n+\n+\t  case CPP_COLON:\n+\t    top -= 2;\n+\t    if (!num_zerop (top->value))\n+\t      {\n+\t\tpfile->state.skip_eval--;\n+\t\ttop->value = top[1].value;\n+\t      }\n+\t    else\n+\t      top->value = top[2].value;\n+\t    top->value.unsignedp = (top[1].value.unsignedp\n+\t\t\t\t    || top[2].value.unsignedp);\n+\t    continue;\n+\n+\t  case CPP_QUERY:\n+\t    cpp_error (pfile, DL_ERROR, \"'?' without following ':'\");\n+\t    return 0;\n+\n+\t  default:\n+\t    goto bad_op;\n+\t  }\n \n+      top--;\n       if (top->value.overflow && !pfile->state.skip_eval)\n \tcpp_error (pfile, DL_PEDWARN,\n \t\t   \"integer overflow in preprocessor expression\");\n@@ -1383,10 +1418,9 @@ num_part_mul (lhs, rhs)\n \n /* Multiply two preprocessing numbers.  */\n static cpp_num\n-num_mul (pfile, lhs, rhs, op)\n+num_mul (pfile, lhs, rhs)\n      cpp_reader *pfile;\n      cpp_num lhs, rhs;\n-     enum cpp_ttype op ATTRIBUTE_UNUSED;\n {\n   cpp_num result, temp;\n   bool unsignedp = lhs.unsignedp || rhs.unsignedp;"}]}