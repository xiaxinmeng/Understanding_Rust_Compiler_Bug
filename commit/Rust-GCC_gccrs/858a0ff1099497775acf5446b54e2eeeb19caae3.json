{"sha": "858a0ff1099497775acf5446b54e2eeeb19caae3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODU4YTBmZjEwOTk0OTc3NzVhY2Y1NDQ2YjU0ZTJlZWViMTljYWFlMw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-10-19T17:40:48Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-10-19T17:40:48Z"}, "message": "method.c (PARM_CAN_BE_ARRAY_TYPE): Remove.\n\n\t* method.c (PARM_CAN_BE_ARRAY_TYPE): Remove.\n\t(mangling_flags): New type.\n\t(build_overload_int): Change prototype.\n\t(build_overload_value): Likewise.\n\t(numeric_output_need_bar): Improve comment.\n\t(mangle_expression): New function, broken out from ...\n\t(build_overload_int): Here.\n\t(build_overload_value): Adjust for use of mangling flags.  Don't\n\twarn about real-valued template parameters here.  Do handle\n\tcomplex expressions involving real-valued template parameters.\n\t(build_template_parm_names): Encase non-type template parameters\n\tin underscores, if necessary.\n\t(process_overload_item): Remove conditional on\n\tPARM_CAN_BE_ARRAY_TYPE.\n\nFrom-SVN: r30090", "tree": {"sha": "4e9cd9c8532081cb216ff537118ff1cde0e91fa9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4e9cd9c8532081cb216ff537118ff1cde0e91fa9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/858a0ff1099497775acf5446b54e2eeeb19caae3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/858a0ff1099497775acf5446b54e2eeeb19caae3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/858a0ff1099497775acf5446b54e2eeeb19caae3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/858a0ff1099497775acf5446b54e2eeeb19caae3/comments", "author": null, "committer": null, "parents": [{"sha": "9ce71c6fbd07e2d71d9e921e40b53d944f1f64d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ce71c6fbd07e2d71d9e921e40b53d944f1f64d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ce71c6fbd07e2d71d9e921e40b53d944f1f64d4"}], "stats": {"total": 319, "additions": 214, "deletions": 105}, "files": [{"sha": "5a1d0e3293ab057f7b3790b227d07644287058e8", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/858a0ff1099497775acf5446b54e2eeeb19caae3/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/858a0ff1099497775acf5446b54e2eeeb19caae3/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=858a0ff1099497775acf5446b54e2eeeb19caae3", "patch": "@@ -1,3 +1,20 @@\n+1999-10-19  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* method.c (PARM_CAN_BE_ARRAY_TYPE): Remove.\n+\t(mangling_flags): New type.\n+\t(build_overload_int): Change prototype.\n+\t(build_overload_value): Likewise.\n+\t(numeric_output_need_bar): Improve comment.\n+\t(mangle_expression): New function, broken out from ...\n+\t(build_overload_int): Here.\n+\t(build_overload_value): Adjust for use of mangling flags.  Don't\n+\twarn about real-valued template parameters here.  Do handle\n+\tcomplex expressions involving real-valued template parameters.\n+\t(build_template_parm_names): Encase non-type template parameters\n+\tin underscores, if necessary.\n+\t(process_overload_item): Remove conditional on\n+\tPARM_CAN_BE_ARRAY_TYPE.\n+\n 1999-10-17  Mark Mitchell  <mark@codesourcery.com>\n \n \t* dump.c (dequeue_and_dump): Handle CLEANUP_POINT_EXPR."}, {"sha": "fbe2cbb8a11df404639ae3e0100817e1dd5136a1", "filename": "gcc/cp/NEWS", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/858a0ff1099497775acf5446b54e2eeeb19caae3/gcc%2Fcp%2FNEWS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/858a0ff1099497775acf5446b54e2eeeb19caae3/gcc%2Fcp%2FNEWS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FNEWS?ref=858a0ff1099497775acf5446b54e2eeeb19caae3", "patch": "@@ -1,5 +1,12 @@\n *** Changes in GCC 3.0:\n \n+* In some obscure cases, functions with the same type could have the\n+  same mangled name.  This bug caused compiler crashes, link-time clashes,\n+  and debugger crahses.  Fixing this bug required breaking ABI\n+  compatibility for the functions involved.  The functions in questions\n+  are those whose types involve non-type template arguments whose\n+  mangled representations require more than one digit.\n+\n * Support for assignment to `this' has been removed.  This idiom \n   was used in the very early days of C++, before users were allowed\n   to overload `operator new'; it is no longer allowed by the C++"}, {"sha": "b1882816fa212537a6e95665b48d271933168fc4", "filename": "gcc/cp/method.c", "status": "modified", "additions": 161, "deletions": 105, "changes": 266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/858a0ff1099497775acf5446b54e2eeeb19caae3/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/858a0ff1099497775acf5446b54e2eeeb19caae3/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=858a0ff1099497775acf5446b54e2eeeb19caae3", "patch": "@@ -25,10 +25,6 @@ Boston, MA 02111-1307, USA.  */\n #define __inline\n #endif\n \n-#ifndef PARM_CAN_BE_ARRAY_TYPE\n-#define PARM_CAN_BE_ARRAY_TYPE 1\n-#endif\n-\n /* Handle method declarations.  */\n #include \"config.h\"\n #include \"system.h\"\n@@ -44,6 +40,24 @@ Boston, MA 02111-1307, USA.  */\n #include \"ggc.h\"\n #include \"tm_p.h\"\n \n+/* Various flags to control the mangling process.  */\n+\n+enum mangling_flags\n+{\n+  /* No flags.  */\n+  mf_none = 0,\n+  /* The thing we are presently mangling is part of a template type,\n+     rather than a fully instantiated type.  Therefore, we may see\n+     complex expressions where we would normally expect to see a\n+     simple integer constant.  */\n+  mf_maybe_uninstantiated = 1,\n+  /* When mangling a numeric value, use the form `_XX_' (instead of\n+     just `XX') if the value has more than one digit.  */\n+  mf_use_underscores_around_value = 2,\n+};\n+\n+typedef enum mangling_flags mangling_flags;\n+\n /* TREE_LIST of the current inline functions that need to be\n    processed.  */\n struct pending_inline *pending_inlines;\n@@ -61,10 +75,11 @@ static int old_backref_index PROTO((tree));\n static int flush_repeats PROTO((int, tree));\n static void build_overload_identifier PROTO((tree));\n static void build_overload_nested_name PROTO((tree));\n-static void build_overload_int PROTO((tree, int));\n+static void mangle_expression PROTO((tree));\n+static void build_overload_int PROTO((tree, mangling_flags));\n static void build_overload_identifier PROTO((tree));\n static void build_qualified_name PROTO((tree));\n-static void build_overload_value PROTO((tree, tree, int));\n+static void build_overload_value PROTO((tree, tree, mangling_flags));\n static void issue_nrepeats PROTO((int, tree));\n static char *build_mangled_name PROTO((tree,int,int));\n static void process_modifiers PROTO((tree));\n@@ -197,8 +212,8 @@ do_inline_function_hair (type, friend_list)\n /* Nonzero if we should not try folding parameter types.  */\n static int nofold;\n \n-/* This appears to be set to true if an underscore is required to be\n-   comcatenated before another number can be outputed. */\n+/* Nonzero if an underscore is required before adding a digit to the\n+   mangled name currently being built.  */\n static int numeric_output_need_bar;\n \n static __inline void\n@@ -546,104 +561,141 @@ build_overload_scope_ref (value)\n   build_overload_identifier (TREE_OPERAND (value, 1));\n }\n \n-/* Encoding for an INTEGER_CST value.  */\n+/* VALUE is a complex expression.  Produce an appropriate mangling.\n+   (We are forced to mangle complex expressions when dealing with\n+   templates, and an expression involving template parameters appears\n+   in the type of a function parameter.)  */\n \n static void\n-build_overload_int (value, in_template)\n+mangle_expression (value)\n      tree value;\n-     int in_template;\n {\n-  if (in_template && TREE_CODE (value) != INTEGER_CST)\n+  if (TREE_CODE (value) == SCOPE_REF)\n     {\n-      if (TREE_CODE (value) == SCOPE_REF)\n-\t{\n-\t  build_overload_scope_ref (value);\n-\t  return;\n-\t}\n+      build_overload_scope_ref (value);\n+      return;\n+    }\n \n-      OB_PUTC ('E');\n-      numeric_output_need_bar = 0;\n+  OB_PUTC ('E');\n+  numeric_output_need_bar = 0;\n \n-      if (IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (TREE_CODE (value))))\n+  if (IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (TREE_CODE (value))))\n+    {\n+      int i;\n+      int operands = tree_code_length[(int) TREE_CODE (value)];\n+      tree id;\n+      const char *name;\n+\n+      id = ansi_opname [(int) TREE_CODE (value)];\n+      my_friendly_assert (id != NULL_TREE, 0);\n+      name = IDENTIFIER_POINTER (id);\n+      if (name[0] != '_' || name[1] != '_')\n+\t/* On some erroneous inputs, we can get here with VALUE a\n+\t   LOOKUP_EXPR.  In that case, the NAME will be the\n+\t   identifier for \"<invalid operator>\".  We must survive\n+\t   this routine in order to issue a sensible error\n+\t   message, so we fall through to the case below.  */\n+\tgoto bad_value;\n+\n+      for (i = 0; i < operands; ++i)\n \t{\n-\t  int i;\n-\t  int operands = tree_code_length[(int) TREE_CODE (value)];\n-\t  tree id;\n-\t  const char *name;\n-\n-\t  id = ansi_opname [(int) TREE_CODE (value)];\n-\t  my_friendly_assert (id != NULL_TREE, 0);\n-\t  name = IDENTIFIER_POINTER (id);\n-\t  if (name[0] != '_' || name[1] != '_')\n-\t    /* On some erroneous inputs, we can get here with VALUE a\n-\t       LOOKUP_EXPR.  In that case, the NAME will be the\n-\t       identifier for \"<invalid operator>\".  We must survive\n-\t       this routine in order to issue a sensible error\n-\t       message, so we fall through to the case below.  */\n-\t    goto bad_value;\n-\n-\t  for (i = 0; i < operands; ++i)\n-\t    {\n-\t      tree operand;\n-\t      enum tree_code tc;\n+\t  tree operand;\n+\t  enum tree_code tc;\n \n-\t      /* We just outputted either the `E' or the name of the\n-\t\t operator.  */\n-\t      numeric_output_need_bar = 0;\n+\t  /* We just outputted either the `E' or the name of the\n+\t     operator.  */\n+\t  numeric_output_need_bar = 0;\n \n-\t      if (i != 0)\n-\t\t/* Skip the leading underscores.  */\n-\t\tOB_PUTCP (name + 2);\n+\t  if (i != 0)\n+\t    /* Skip the leading underscores.  */\n+\t    OB_PUTCP (name + 2);\n \n-\t      operand = TREE_OPERAND (value, i);\n-\t      tc = TREE_CODE (operand);\n+\t  operand = TREE_OPERAND (value, i);\n+\t  tc = TREE_CODE (operand);\n \n-\t      if (TREE_CODE_CLASS (tc) == 't')\n-\t\t/* We can get here with sizeof, e.g.:\n+\t  if (TREE_CODE_CLASS (tc) == 't')\n+\t    /* We can get here with sizeof, e.g.:\n \t\t     \n-\t\t   template <class T> void f(A<sizeof(T)>);  */\n-\t\tbuild_mangled_name_for_type (operand);\n-\t      else if (IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (tc)))\n-\t\tbuild_overload_int (operand, in_template);\n-\t      else\n-\t\tbuild_overload_value (TREE_TYPE (operand),\n-\t\t\t\t      operand,\n-\t\t\t\t      in_template);\n-\t    }\n+\t       template <class T> void f(A<sizeof(T)>);  */\n+\t    build_mangled_name_for_type (operand);\n+\t  else\n+\t    build_overload_value (TREE_TYPE (operand),\n+\t\t\t\t  operand,\n+\t\t\t\t  mf_maybe_uninstantiated);\n \t}\n-      else\n-\t{\n-\t  /* We don't ever want this output, but it's\n-\t     inconvenient not to be able to build the string.\n-\t     This should cause assembler errors we'll notice.  */\n+    }\n+  else\n+    {\n+      /* We don't ever want this output, but it's\n+\t inconvenient not to be able to build the string.\n+\t This should cause assembler errors we'll notice.  */\n \t    \n-\t  static int n;\n-\tbad_value:\n-\t  sprintf (digit_buffer, \" *%d\", n++);\n-\t  OB_PUTCP (digit_buffer);\n-\t}\n+      static int n;\n+    bad_value:\n+      sprintf (digit_buffer, \" *%d\", n++);\n+      OB_PUTCP (digit_buffer);\n+    }\n \n-      OB_PUTC ('W');\n-      numeric_output_need_bar = 0;\n+  OB_PUTC ('W');\n+  numeric_output_need_bar = 0;\n+}\n+\n+/* Encoding for an INTEGER_CST value.  */\n+\n+static void\n+build_overload_int (value, flags)\n+     tree value;\n+     mangling_flags flags;\n+{\n+  int multiple_words_p = 0;\n+  int multiple_digits_p = 0;\n+\n+  if ((flags & mf_maybe_uninstantiated) && TREE_CODE (value) != INTEGER_CST)\n+    {\n+      mangle_expression (value);\n       return;\n     }\n \n+  /* Unless we were looking at an uninstantiated template, integers\n+     should always be represented by constants.  */\n   my_friendly_assert (TREE_CODE (value) == INTEGER_CST, 243);\n-  if (TYPE_PRECISION (TREE_TYPE (value)) == 2 * HOST_BITS_PER_WIDE_INT)\n+\n+  /* If the high-order word is not merely a sign-extension of the\n+     low-order word, we must use a special output routine that can\n+     deal with this.  */\n+  if (TREE_INT_CST_HIGH (value)\n+      != (TREE_INT_CST_LOW (value) >> (HOST_BITS_PER_WIDE_INT - 1)))\n     {\n-      if (TREE_INT_CST_HIGH (value)\n-\t  != (TREE_INT_CST_LOW (value) >> (HOST_BITS_PER_WIDE_INT - 1)))\n-\t{\n-\t  /* need to print a DImode value in decimal */\n-\t  dicat (TREE_INT_CST_LOW (value), TREE_INT_CST_HIGH (value));\n-\t  numeric_output_need_bar = 1;\n-\t  return;\n-\t}\n-      /* else fall through to print in smaller mode */\n+      multiple_words_p = 1;\n+      /* And there is certainly going to be more than one digit.  */\n+      multiple_digits_p = 1;\n+    }\n+  else \n+    multiple_digits_p = (TREE_INT_CST_LOW (value) > 9\n+\t\t\t || TREE_INT_CST_LOW (value) < -9);\n+\n+  /* If necessary, add a leading underscore.  */\n+  if (multiple_digits_p && (flags & mf_use_underscores_around_value))\n+    OB_PUTC ('_');\n+\n+  /* Output the number itself.  */\n+  if (multiple_words_p)\n+    dicat (TREE_INT_CST_LOW (value), TREE_INT_CST_HIGH (value));\n+  else\n+    icat (TREE_INT_CST_LOW (value));\n+\n+  if (flags & mf_use_underscores_around_value)\n+    {\n+      if (multiple_digits_p)\n+\tOB_PUTC ('_');\n+      /* Whether or not there were multiple digits, we don't need an\n+\t underscore.  We've either terminated the number with an\n+\t underscore, or else it only had one digit.  */\n+      numeric_output_need_bar = 0;\n     }\n-  /* Wordsize or smaller */\n-  icat (TREE_INT_CST_LOW (value));\n-  numeric_output_need_bar = 1;\n+  else\n+    /* We just output a numeric value.  */\n+    numeric_output_need_bar = 1;\n }\n \n \n@@ -701,9 +753,9 @@ build_mangled_C9x_name (bits)\n #endif\n \n static void\n-build_overload_value (type, value, in_template)\n+build_overload_value (type, value, flags)\n      tree type, value;\n-     int in_template;\n+     mangling_flags flags;\n {\n   my_friendly_assert (TREE_CODE_CLASS (TREE_CODE (type)) == 't', 0);\n \n@@ -738,24 +790,31 @@ build_overload_value (type, value, in_template)\n       build_overload_identifier (DECL_NAME (value));\n       return;\n     }\n+  else if (INTEGRAL_TYPE_P (type))\n+    {\n+      build_overload_int (value, flags);\n+      return;\n+    }\n+\n+  /* The only case where we use the extra underscores here is when\n+     forming the mangling for an integral non-type template argument.\n+     If that didn't happen, stop now.  */\n+  flags &= ~mf_use_underscores_around_value;\n \n   switch (TREE_CODE (type))\n     {\n-    case INTEGER_TYPE:\n-    case ENUMERAL_TYPE:\n-    case BOOLEAN_TYPE:\n-      {\n-\tbuild_overload_int (value, in_template);\n-\treturn;\n-      }\n     case REAL_TYPE:\n       {\n \tREAL_VALUE_TYPE val;\n \tchar *bufp = digit_buffer;\n \n-\tpedwarn (\"ANSI C++ forbids floating-point template arguments\");\n+\t/* We must handle non-constants in templates.  */\n+\tif (TREE_CODE (value) != REAL_CST)\n+\t  {\n+\t    mangle_expression (value);\n+\t    break;\n+\t  }\n \n-\tmy_friendly_assert (TREE_CODE (value) == REAL_CST, 244);\n \tval = TREE_REAL_CST (value);\n \tif (REAL_VALUE_ISNAN (val))\n \t  {\n@@ -817,7 +876,7 @@ build_overload_value (type, value, in_template)\n     case POINTER_TYPE:\n       if (TREE_CODE (value) == INTEGER_CST)\n \t{\n-\t  build_overload_int (value, in_template);\n+\t  build_overload_int (value, flags);\n \t  return;\n \t}\n       else if (TREE_CODE (value) == TEMPLATE_PARM_INDEX)\n@@ -877,9 +936,9 @@ build_overload_value (type, value, in_template)\n \tmy_friendly_assert (TREE_CODE (value) == PTRMEM_CST, 0);\n \n \texpand_ptrmemfunc_cst (value, &delta, &idx, &pfn, &delta2);\n-\tbuild_overload_int (delta, in_template);\n+\tbuild_overload_int (delta, flags);\n \tOB_PUTC ('_');\n-\tbuild_overload_int (idx, in_template);\n+\tbuild_overload_int (idx, flags);\n \tOB_PUTC ('_');\n \tif (pfn)\n \t  {\n@@ -890,7 +949,7 @@ build_overload_value (type, value, in_template)\n \telse\n \t  {\n \t    OB_PUTC ('i');\n-\t    build_overload_int (delta2, in_template);\n+\t    build_overload_int (delta2, flags);\n \t  }\n       }\n       break;\n@@ -983,7 +1042,9 @@ build_template_parm_names (parmlist, arglist)\n \t  /* It's a PARM_DECL.  */\n \t  build_mangled_name_for_type (TREE_TYPE (parm));\n \t  build_overload_value (TREE_TYPE (parm), arg, \n-\t\t\t\tuses_template_parms (arglist));\n+\t\t\t\t((mf_maybe_uninstantiated \n+\t\t\t\t  * uses_template_parms (arglist))\n+\t\t\t\t | mf_use_underscores_around_value));\n \t}\n     }\n  }\n@@ -1317,7 +1378,6 @@ process_overload_item (parmtype, extra_Gcode)\n       goto more;\n \n     case ARRAY_TYPE:\n-#if PARM_CAN_BE_ARRAY_TYPE\n       {\n         OB_PUTC ('A');\n         if (TYPE_DOMAIN (parmtype) == NULL_TREE)\n@@ -1337,10 +1397,6 @@ process_overload_item (parmtype, extra_Gcode)\n \t  OB_PUTC ('_');\n         goto more;\n       }\n-#else\n-      OB_PUTC ('P');\n-      goto more;\n-#endif\n \n     case POINTER_TYPE:\n       OB_PUTC ('P');"}, {"sha": "7e8ea9164bcf8d4c7de25e0dad2b9ecec82e0f5e", "filename": "gcc/testsuite/g++.old-deja/g++.ext/realpt1.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/858a0ff1099497775acf5446b54e2eeeb19caae3/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.ext%2Frealpt1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/858a0ff1099497775acf5446b54e2eeeb19caae3/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.ext%2Frealpt1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.ext%2Frealpt1.C?ref=858a0ff1099497775acf5446b54e2eeeb19caae3", "patch": "@@ -0,0 +1,19 @@\n+// Build don't link:\n+// Special g++ Options:\n+// Origin: Mark Mitchell <mark@codesourcery.com>\n+\n+template <double d>\n+struct S;\n+\n+template <double d, double e>\n+void f (S<d>*, S<e>*, S<d + e>*);\n+\n+void g ()\n+{\n+  S<2.0>* s1;\n+  S<3.7>* s2;\n+  S<5.7>* s3;\n+  \n+  f (s1, s2, s3);\n+}\n+"}, {"sha": "fdebc0cd964e25334e0a14a4da96ccbfc24daf6d", "filename": "gcc/testsuite/g++.old-deja/g++.pt/mangle1.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/858a0ff1099497775acf5446b54e2eeeb19caae3/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmangle1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/858a0ff1099497775acf5446b54e2eeeb19caae3/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmangle1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmangle1.C?ref=858a0ff1099497775acf5446b54e2eeeb19caae3", "patch": "@@ -0,0 +1,10 @@\n+// Build don't link:\n+// Origin: Mark Mitchell <mark@codesourcery.com>\n+\n+typedef enum {} i;\n+\n+template <int II>\n+class Bar {};\n+\n+void f (Bar<21>, int) {}\n+void f (Bar<2>, i) {}"}]}