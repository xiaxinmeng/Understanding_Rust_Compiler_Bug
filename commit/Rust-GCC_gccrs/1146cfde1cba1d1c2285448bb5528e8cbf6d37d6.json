{"sha": "1146cfde1cba1d1c2285448bb5528e8cbf6d37d6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTE0NmNmZGUxY2JhMWQxYzIyODU0NDhiYjU1MjhlOGNiZjZkMzdkNg==", "commit": {"author": {"name": "Gerald Pfeifer", "email": "pfeifer@dbai.tuwien.ac.at", "date": "2000-10-09T13:19:20Z"}, "committer": {"name": "Gerald Pfeifer", "email": "gerald@gcc.gnu.org", "date": "2000-10-09T13:19:20Z"}, "message": "README.NS32K: Remove file.\n\n\t* README.NS32K: Remove file.\n\t* README-bugs: Remove file.\n\nFrom-SVN: r36807", "tree": {"sha": "550614d7331a7195098dd41a5770b41f7ca54447", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/550614d7331a7195098dd41a5770b41f7ca54447"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1146cfde1cba1d1c2285448bb5528e8cbf6d37d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1146cfde1cba1d1c2285448bb5528e8cbf6d37d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1146cfde1cba1d1c2285448bb5528e8cbf6d37d6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1146cfde1cba1d1c2285448bb5528e8cbf6d37d6/comments", "author": null, "committer": null, "parents": [{"sha": "3ec840ea2e865e4a69965fb132256dbc88449a94", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ec840ea2e865e4a69965fb132256dbc88449a94", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ec840ea2e865e4a69965fb132256dbc88449a94"}], "stats": {"total": 331, "additions": 8, "deletions": 323}, "files": [{"sha": "dd3cdb73a8c22e47624a46279f6137b7e9a47c14", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1146cfde1cba1d1c2285448bb5528e8cbf6d37d6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1146cfde1cba1d1c2285448bb5528e8cbf6d37d6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1146cfde1cba1d1c2285448bb5528e8cbf6d37d6", "patch": "@@ -1,3 +1,11 @@\n+2000-10-09  Gerald Pfeifer  <pfeifer@dbai.tuwien.ac.at>\n+\n+\t* README.NS32K: Remove file.\n+\n+2000-10-09  Gerald Pfeifer  <pfeifer@dbai.tuwien.ac.at>\n+\n+\t* README-bugs: Remove file.\n+\n 2000-10-08  Philipp Thomas  <pthomas@suse.de>\n \t* aclocal.m4 (AM_GNU_GETTEXT): Fix non portable use of == operator\n \tfor test."}, {"sha": "06e15bb8af708d6ab812b58b75d79798f2e8e9e9", "filename": "gcc/README-bugs", "status": "removed", "additions": 0, "deletions": 144, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec840ea2e865e4a69965fb132256dbc88449a94/gcc%2FREADME-bugs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec840ea2e865e4a69965fb132256dbc88449a94/gcc%2FREADME-bugs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FREADME-bugs?ref=3ec840ea2e865e4a69965fb132256dbc88449a94", "patch": "@@ -1,144 +0,0 @@\n-The purpose of GCC pretesting is to verify that the new GCC\n-distribution, about to be released, works properly on your system *with\n-no change whatever*, when installed following the precise\n-recommendations that come with the distribution.\n-\n-Here are some guidelines on how to do pretesting so as to make it\n-helpful.  All of them follow from common sense together with the\n-nature of the purpose and the situation.\n-\n-* It is absolutely vital that you mention even the smallest change or\n-departure from the standard sources and installation procedure.\n-\n-Otherwise, you are not testing the same program that I wrote.  Testing\n-a different program is usually of no use whatever.  It can even cause\n-trouble if you fail to tell me that you tested some other program\n-instead of what I know as GCC.  I might think that GCC works, when in\n-fact it has not been properly tried, and might have a glaring fault.\n-\n-* Even changing the compilation options counts as a change in the\n-program.  The GCC sources specify which compilation options to use.\n-Some of them are specified in makefiles, and some in machine-specific\n-configuration files.\n-\n-You have ways to override this--but if you do, then you are not\n-testing what ordinary users will do.  Therefore, when pretesting, it\n-is vital to test with the default compilation options.\n-\n-(It is okay to test with nonstandard options as well as testing with\n-the standard ones.)\n-\n-* The machine and system configuration files of GCC are parts of\n-GCC.  So when you test GCC, you need to do it with the\n-configuration files that come with GCC.\n-\n-If GCC does not come with configuration files for a certain machine,\n-and you test it with configuration files that don't come with GCC,\n-this is effectively changing GCC.  Because the crucial fact about\n-the planned release is that, without changes, it doesn't work on that\n-machine.\n-\n-To make GCC work on that machine, I would need to install new\n-configuration files.  That is not out of the question, since it is\n-safe--it certainly won't break any other machines that already work.\n-But you will have to rush me the legal papers to give the FSF\n-permission to use a large piece of text.\n-\n-* Look for recommendations for your system.\n-\n-You can find these recommendations in the Installation node of the\n-manual, and in the file INSTALL.  (These two files have the same text.)\n-\n-These files say which configuration name to use for your machine, so\n-use the ones that are recommended.  If you guess, you might guess\n-wrong and encounter spurious difficulties.  What's more, if you don't\n-follow the recommendations then you aren't helping to test that its\n-recommendations are valid.\n-\n-These files may describe other things that you need to do to make GCC\n-work on your machine.  If so, you should follow these recommendations\n-also, for the same reason.\n-\n-Also look at the Trouble chapter of the manual for items that\n-pertain to your machine.\n-\n-* Don't delay sending information.\n-\n-When you find a problem, please double check it if you can do so\n-quickly.  But don't spend a long time double-checking.  A good rule is\n-always to tell me about every problem on the same day you encounter\n-it, even if that means you can't find a solution before you report the\n-problem.\n-\n-I'd much rather hear about a problem today and a solution tomorrow\n-than get both of them tomorrow at the same time.\n-\n-* Make each bug report self-contained.\n-\n-If you refer back to another message, whether from you or from someone\n-else, then it will be necessary for anyone who wants to investigate\n-the bug to find the other message.  This may be difficult, it is\n-probably time-consuming.\n-\n-To help me save time, simply copy the relevant parts of any previous\n-messages into your own bug report.\n-\n-In particular, if I ask you for more information because a bug report\n-was incomplete, it is best to send me the *entire* collection of\n-relevant information, all together.  If you send just the additional\n-information, that makes me do extra work.  There is even a risk that\n-I won't remember what question you are sending me the answer to.\n-\n-* Always be precise when talking about changes you have made.  Show\n-things rather than describing them.  Use exact filenames (relative to\n-the main directory of the distribution), not partial ones.  For\n-example, say \"I changed Makefile\" rather than \"I changed the\n-makefile\".  Instead of saying \"I defined the MUMBLE macro\", send a\n-diff that shows your change.\n-\n-* Always use `diff -c' to make diffs.  If you don't include context,\n-it may be hard for me to figure out where you propose to make the\n-changes.  I might have to ignore your patch because I can't tell what\n-it means.\n-\n-* When you write a fix, keep in mind that I can't install a change\n-that would break other systems.\n-\n-People often suggest fixing a problem by changing machine-independent\n-files such as toplev.c to do something special that a particular\n-system needs.  Sometimes it is totally obvious that such changes would\n-break GCC for almost all users.  I can't possibly make a change like\n-that.  All I can do is send it back to you and ask you to find a fix\n-that is safe to install.\n-\n-Sometimes people send fixes that *might* be an improvement in\n-general--but it is hard to be sure of this.  I can install such\n-changes some of the time, but not during pretest, when I am trying to\n-get a new version to work reliably as quickly as possible.\n-\n-The safest changes for me to install are changes to the configuration\n-files for a particular machine.  At least I know those can't create\n-bugs on other machines.\n-\n-* Don't try changing GCC unless it fails to work if you don't change it.\n-\n-* Don't even suggest changes that would only make GCC cleaner.\n-Every change I install could introduce a bug, so I won't install\n-a change unless I see it is necessary.\n-\n-* If you would like to suggest changes for purposes other than fixing\n-serious bugs, don't wait till pretest time.  Instead, send them just\n-after I make a release.  That's the best time for me to install them.\n-\n-* In some cases, if you don't follow these guidelines, your\n-information might still be useful, but I might have to do more work to\n-make use of it.  Unfortunately, I am so far behind in my work that I\n-just can't get the job done unless you help me to do it efficiently.\n-\n-\n-\t\t\t\tThank you\n-\t\t\t\t   rms\n-\f\n-Local Variables:\n-mode: text\n-End:"}, {"sha": "8e3610e33b5ec9713a98079202c90e7c7e7f9827", "filename": "gcc/README.NS32K", "status": "removed", "additions": 0, "deletions": 179, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec840ea2e865e4a69965fb132256dbc88449a94/gcc%2FREADME.NS32K", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec840ea2e865e4a69965fb132256dbc88449a94/gcc%2FREADME.NS32K", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FREADME.NS32K?ref=3ec840ea2e865e4a69965fb132256dbc88449a94", "patch": "@@ -1,179 +0,0 @@\n-This file describes the implementation notes of the GNU C Compiler for\n-the National Semiconductor 32032 chip (and 32000 family).\n-\n-Much of this file was obsolete. It described restrictions caused by\n-bugs in early versions of of the ns32032 chip and by bugs in sequent\n-assemblers and linkers of the time.\n-\n-Many (all?) of the chip bugs were fixed in later revisions and\n-certainly fixed by later chips in the same series (ns32332 and\n-ns32532).\n-\n-Conditional code to support sequent assembler and/or linker restrictions\n-has not been removed deliberately, but has probably not been tested in\n-a *very* long time.\n-\n-Support for one sequent assembler bug has *not* been retained.\n-It was necessary to say:\n-\n-\taddr _x,rn\n-\tcmpd _p,rn\n-\n-rather than:\n-\n-\tcmpd _p,@_x\n-\n-\n-This used to be forced by the use of \"rmn\" register constraints rather\n-than \"g\". This is bad for other platforms which do not have this\n-restraint.\n-\n-It is likely that there are no Balance 8000's still in operation, but\n-if there are and the assembler bug was never fixed then the easiest\n-way to run gcc would be to also run gas.\n-\n-The code required by the sequent assembler is still generated when the\n--fpic flag is in effect and this is forced by the appropriate\n-definition of LEGITIMATE_PIC_OPERAND_P. If support for the old sequent\n-assembler bug is required, then this could be achieved by adding the\n-test from LEGITIMATE_PIC_OPERAND to the GO_IF_LEGITIMATE_ADDRESS\n-definition. Of course, this should be conditional on something in the\n-sequent.h config file.\n-\n-The original contents of this file appear below as an historical note.\n-SEQUENT_ADDRESS_BUG mentioned below has been replaced by\n-INDEX_RATHER_THAN_BASE. Note that merlin.h still defines\n-SEQUENT_ADDRESS_BUG even though it is not used anywhere. Since it has\n-been like this for a long time, presumably either the\n-SEQUENT_ADDRESS_BUG is not required for the merlin, or no one is using\n-gcc on the merlin anymore.\n-\n-HISTORICAL NOTE\n-\n-The 32032 machine description and configuration file for this compiler\n-is, for NS32000 family machine, primarily machine independent.\n-However, since this release still depends on vendor-supplied\n-assemblers and linkers, the compiler must obey the existing\n-conventions of the actual machine to which this compiler is targeted.\n-In this case, the actual machine which this compiler was targeted to\n-is a Sequent Balance 8000, running DYNIX 2.1.\n-\n-The assembler for DYNIX 2.1 (and DYNIX 3.0, alas) does not cope with\n-the full generality of the addressing mode REGISTER RELATIVE.\n-Specifically, it generates incorrect code for operands of the\n-following form:\n-\n-\tsym(rn)\n-\n-Where `rn' is one of the general registers.  Correct code is generated\n-for operands of the form\n-\n-\tsym(pn)\n-\n-where `pn' is one of the special processor registers (sb, fp, or sp).\n-\n-An equivalent operand can be generated by the form\n-\n-\tsym[rn:b]\n-\n-although this addressing mode is about twice as slow on the 32032.\n-\n-The more efficient addressing mode is controlled by defining the\n-constant SEQUENT_ADDRESS_BUG to 0.  It is currently defined to be 1.\n-\n-Another bug in the assembler makes it impossible to compute with\n-explicit addresses.  In order to compute with a symbolic address, it\n-is necessary to load that address into a register using the \"addr\"\n-instruction.  For example, it is not possible to say\n-\n-\tcmpd _p,@_x\n-\n-Rather one must say\n-\n-\taddr _x,rn\n-\tcmpd _p,rn\n-\n-\n-The ns32032 chip has a number of known bugs.  Any attempt to make the\n-compiler unaware of these deficiencies will surely bring disaster.\n-The current list of know bugs are as follows (list provided by Richard\n-Stallman):\n-\n-1) instructions with two overlapping operands in memory\n-(unlikely in C code, perhaps impossible).\n-\n-2) floating point conversion instructions with constant\n-operands (these may never happen, but I'm not certain).\n-\n-3) operands crossing a page boundary.  These can be prevented\n-by setting the flag in tm.h that requires strict alignment.\n-\n-4) Scaled indexing in an insn following an insn that has a read-write\n-operand in memory.  This can be prevented by placing a no-op in\n-between.  I, Michael Tiemann, do not understand what exactly is meant\n-by `read-write operand in memory'.  If this is referring to the special\n-TOS mode, for example \"addd 5,tos\" then one need not fear, since this\n-will never be generated.  However, is this includes \"addd 5,-4(fp)\"\n-then there is room for disaster.  The Sequent compiler does not insert\n-a no-op for code involving the latter, and I have been informed that\n-Sequent is aware of this list of bugs, so I must assume that it is not\n-a problem.\n-\n-5) The 32032 cannot shift by 32 bits.  It shifts modulo the word size\n-of the operand.  Therefore, for 32-bit operations, 32-bit shifts are\n-interpreted as zero bit shifts.  32-bit shifts have been removed from\n-the compiler, but future hackers must be careful not to reintroduce\n-them.\n-\n-6) The ns32032 is a very slow chip; however, some instructions are\n-still very much slower than one might expect.  For example, it is\n-almost always faster to double a quantity by adding it to itself than\n-by shifting it by one, even if that quantity is deep in memory.  The\n-MOVM instruction has a 20-cycle setup time, after which it moves data\n-at about the speed that normal moves would.  It is also faster to use\n-address generation instructions than shift instructions for left\n-shifts less than 4.  I do not claim that I generate optimal code for all\n-given patterns, but where I did escape from National's \"clean\n-architecture\", I did so because the timing specification from the data\n-book says that I will win if I do.  I suppose this is called the\n-\"performance gap\".\n-\n-\n-Signed bitfield extraction has not been implemented.  It is not\n-provided by the NS32032, and while it is most certainly possible to do\n-better than the standard shift-left/shift-right sequence, it is also\n-quite hairy.  Also, since signed bitfields do not yet exist in C, this\n-omission seems relatively harmless.\n-\n-\n-Zero extractions could be better implemented if it were possible in\n-GCC to provide sized zero extractions: i.e. a byte zero extraction\n-would be allowed to yield a byte result.  The current implementation\n-of GCC manifests 68000-ist thinking, where bitfields are extracted\n-into a register, and automatically sign/zero extended to fill the\n-register.  See comments in ns32k.md around the \"extzv\" insn for more\n-details.\n-\n-\n-It should be noted that while the NS32000 family was designed to\n-provide odd-aligned addressing capability for multi-byte data (also\n-provided by the 68020, but not by the 68000 or 68010), many machines\n-do not opt to take advantage of this.  For example, on the sequent,\n-although there is no advantage to long-word aligning word data, shorts\n-must be int-aligned in structs.  This is an example of another\n-machine-specific machine dependency.\n-\n-\n-Because the ns32032 is has a coherent byte-order/bit-order\n-architecture, many instructions which would be different for\n-68000-style machines, fold into the same instruction for the 32032.\n-The classic case is push effective address, where it does not matter\n-whether one is pushing a long, word, or byte address.  They all will\n-push the same address.\n-\n-\n-The macro FUNCTION_VALUE_REGNO_P is probably not sufficient, what is\n-needed is FUNCTION_VALUE_P, which also takes a MODE parameter.  In\n-this way it will be possible to determine more exactly whether a\n-register is really a function value register, or just one that happens\n-to look right."}]}