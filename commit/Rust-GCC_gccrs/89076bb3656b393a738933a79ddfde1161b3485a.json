{"sha": "89076bb3656b393a738933a79ddfde1161b3485a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODkwNzZiYjM2NTZiMzkzYTczODkzM2E3OWRkZmRlMTE2MWIzNDg1YQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2002-02-28T18:32:12Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-02-28T18:32:12Z"}, "message": "haifa-sched.c (sched_emit_insn): New.\n\n        * haifa-sched.c (sched_emit_insn): New.\n        (schedule_block): Use last_scheduled_insn to track last insn.\n        * sched-int.h (sched_emit_insn): Prototype.\n        * config/ia64/ia64.c (last_issued): Remove.\n        (ia64_variable_issue): Don't set it.\n        (nop_cycles_until): Use sched_emit_insn.\n\nFrom-SVN: r50153", "tree": {"sha": "a5565c15b0b052513a333444454a04a0102ff0ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a5565c15b0b052513a333444454a04a0102ff0ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/89076bb3656b393a738933a79ddfde1161b3485a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89076bb3656b393a738933a79ddfde1161b3485a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89076bb3656b393a738933a79ddfde1161b3485a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89076bb3656b393a738933a79ddfde1161b3485a/comments", "author": null, "committer": null, "parents": [{"sha": "e3aaacf47148d9853760c4adec1f93e41afc3bdb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3aaacf47148d9853760c4adec1f93e41afc3bdb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3aaacf47148d9853760c4adec1f93e41afc3bdb"}], "stats": {"total": 88, "additions": 42, "deletions": 46}, "files": [{"sha": "03f44212a9d9195e0ea5e068aeaf54391eba162f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89076bb3656b393a738933a79ddfde1161b3485a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89076bb3656b393a738933a79ddfde1161b3485a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=89076bb3656b393a738933a79ddfde1161b3485a", "patch": "@@ -1,3 +1,12 @@\n+2002-02-28  Richard Henderson  <rth@redhat.com>\n+\n+\t* haifa-sched.c (sched_emit_insn): New.\n+\t(schedule_block): Use last_scheduled_insn to track last insn.\n+\t* sched-int.h (sched_emit_insn): Prototype.\n+\t* config/ia64/ia64.c (last_issued): Remove.\n+\t(ia64_variable_issue): Don't set it.\n+\t(nop_cycles_until): Use sched_emit_insn.\n+\n 2002-02-28  Andrew MacLeod  <amacleod@redhat.com>\n \n \t* config/sparc/sparc.c (sparc64_initialize_trampoline): Generate sign"}, {"sha": "0b1fb344d79d0b7ce91507b732b3f0cfdcbb2e63", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 12, "deletions": 34, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89076bb3656b393a738933a79ddfde1161b3485a/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89076bb3656b393a738933a79ddfde1161b3485a/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=89076bb3656b393a738933a79ddfde1161b3485a", "patch": "@@ -6074,12 +6074,6 @@ static int prev_cycle;\n    value of sched_data.first_slot.  */\n static int prev_first;\n \n-/* The last insn that has been scheduled.  At the start of a new cycle\n-   we know that we can emit new insns after it; the main scheduling code\n-   has already emitted a cycle_display insn after it and is using that\n-   as its current last insn.  */\n-static rtx last_issued;\n-\n /* Emit NOPs to fill the delay between PREV_CYCLE and CLOCK_VAR.  Used to\n    pad out the delay between MM (shifts, etc.) and integer operations.  */\n \n@@ -6095,8 +6089,7 @@ nop_cycles_until (clock_var, dump)\n   /* Finish the previous cycle; pad it out with NOPs.  */\n   if (sched_data.cur == 3)\n     {\n-      rtx t = gen_insn_group_barrier (GEN_INT (3));\n-      last_issued = emit_insn_after (t, last_issued);\n+      sched_emit_insn (gen_insn_group_barrier (GEN_INT (3)));\n       did_stop = true;\n       maybe_rotate (dump);\n     }\n@@ -6116,12 +6109,9 @@ nop_cycles_until (clock_var, dump)\n \t  int i;\n \t  for (i = sched_data.cur; i < split; i++)\n \t    {\n-\t      rtx t;\n-\n-\t      t = gen_nop_type (sched_data.packet->t[i]);\n-\t      last_issued = emit_insn_after (t, last_issued);\n+\t      rtx t = sched_emit_insn (gen_nop_type (sched_data.packet->t[i]));\n \t      sched_data.types[i] = sched_data.packet->t[sched_data.cur];\n-\t      sched_data.insns[i] = last_issued;\n+\t      sched_data.insns[i] = t;\n \t      sched_data.stopbit[i] = 0;\n \t    }\n \t  sched_data.cur = split;\n@@ -6133,12 +6123,9 @@ nop_cycles_until (clock_var, dump)\n \t  int i;\n \t  for (i = sched_data.cur; i < 6; i++)\n \t    {\n-\t      rtx t;\n-\n-\t      t = gen_nop_type (sched_data.packet->t[i]);\n-\t      last_issued = emit_insn_after (t, last_issued);\n+\t      rtx t = sched_emit_insn (gen_nop_type (sched_data.packet->t[i]));\n \t      sched_data.types[i] = sched_data.packet->t[sched_data.cur];\n-\t      sched_data.insns[i] = last_issued;\n+\t      sched_data.insns[i] = t;\n \t      sched_data.stopbit[i] = 0;\n \t    }\n \t  sched_data.cur = 6;\n@@ -6148,8 +6135,7 @@ nop_cycles_until (clock_var, dump)\n \n       if (need_stop || sched_data.cur == 6)\n \t{\n-\t  rtx t = gen_insn_group_barrier (GEN_INT (3));\n-\t  last_issued = emit_insn_after (t, last_issued);\n+\t  sched_emit_insn (gen_insn_group_barrier (GEN_INT (3)));\n \t  did_stop = true;\n \t}\n       maybe_rotate (dump);\n@@ -6158,22 +6144,16 @@ nop_cycles_until (clock_var, dump)\n   cycles_left--;\n   while (cycles_left > 0)\n     {\n-      rtx t = gen_bundle_selector (GEN_INT (0));\n-      last_issued = emit_insn_after (t, last_issued);\n-      t = gen_nop_type (TYPE_M);\n-      last_issued = emit_insn_after (t, last_issued);\n-      t = gen_nop_type (TYPE_I);\n-      last_issued = emit_insn_after (t, last_issued);\n+      sched_emit_insn (gen_bundle_selector (GEN_INT (0)));\n+      sched_emit_insn (gen_nop_type (TYPE_M));\n+      sched_emit_insn (gen_nop_type (TYPE_I));\n       if (cycles_left > 1)\n \t{\n-\t  t = gen_insn_group_barrier (GEN_INT (2));\n-\t  last_issued = emit_insn_after (t, last_issued);\n+\t  sched_emit_insn (gen_insn_group_barrier (GEN_INT (2)));\n \t  cycles_left--;\n \t}\n-      t = gen_nop_type (TYPE_I);\n-      last_issued = emit_insn_after (t, last_issued);\n-      t = gen_insn_group_barrier (GEN_INT (3));\n-      last_issued = emit_insn_after (t, last_issued);\n+      sched_emit_insn (gen_nop_type (TYPE_I));\n+      sched_emit_insn (gen_insn_group_barrier (GEN_INT (3)));\n       did_stop = true;\n       cycles_left--;\n     }\n@@ -6493,8 +6473,6 @@ ia64_variable_issue (dump, sched_verbose, insn, can_issue_more)\n {\n   enum attr_type t = ia64_safe_type (insn);\n \n-  last_issued = insn;\n-\n   if (sched_data.last_was_stop)\n     {\n       int t = sched_data.first_slot;"}, {"sha": "686369d418f4717084db6f2ec243d44d00bf4548", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89076bb3656b393a738933a79ddfde1161b3485a/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89076bb3656b393a738933a79ddfde1161b3485a/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=89076bb3656b393a738933a79ddfde1161b3485a", "patch": "@@ -1617,6 +1617,18 @@ move_insn (insn, last)\n   return retval;\n }\n \n+/* Called from backends from targetm.sched.reorder to emit stuff into\n+   the instruction stream.  */\n+\n+rtx\n+sched_emit_insn (pat)\n+     rtx pat;\n+{\n+  rtx insn = emit_insn_after (pat, last_scheduled_insn);\n+  last_scheduled_insn = insn;\n+  return insn;\n+}\n+\n /* Use forward list scheduling to rearrange insns of block B in region RGN,\n    possibly bringing insns from subsequent blocks in the same region.  */\n \n@@ -1625,7 +1637,6 @@ schedule_block (b, rgn_n_insns)\n      int b;\n      int rgn_n_insns;\n {\n-  rtx last;\n   struct ready_list ready;\n   int can_issue_more;\n \n@@ -1673,8 +1684,8 @@ schedule_block (b, rgn_n_insns)\n   if (targetm.sched.md_init)\n     (*targetm.sched.md_init) (sched_dump, sched_verbose, ready.veclen);\n \n-  /* No insns scheduled in this block yet.  */\n-  last_scheduled_insn = 0;\n+  /* We start inserting insns after PREV_HEAD.  */\n+  last_scheduled_insn = prev_head;\n \n   /* Initialize INSN_QUEUE.  Q_SIZE is the total number of insns in the\n      queue.  */\n@@ -1686,9 +1697,6 @@ schedule_block (b, rgn_n_insns)\n   /* Start just before the beginning of time.  */\n   clock_var = -1;\n \n-  /* We start inserting insns after PREV_HEAD.  */\n-  last = prev_head;\n-\n   /* Loop until all the insns in BB are scheduled.  */\n   while ((*current_sched_info->schedule_more_p) ())\n     {\n@@ -1700,9 +1708,6 @@ schedule_block (b, rgn_n_insns)\n          list.  */\n       queue_to_ready (&ready);\n \n-      if (sched_verbose && targetm.sched.cycle_display)\n-\tlast = (*targetm.sched.cycle_display) (clock_var, last);\n-\n       if (ready.n_ready == 0)\n \tabort ();\n \n@@ -1725,6 +1730,10 @@ schedule_block (b, rgn_n_insns)\n       else\n \tcan_issue_more = issue_rate;\n \n+      if (sched_verbose && targetm.sched.cycle_display)\n+\tlast_scheduled_insn\n+\t  = (*targetm.sched.cycle_display) (clock_var, last_scheduled_insn);\n+\n       if (sched_verbose)\n \t{\n \t  fprintf (sched_dump, \"\\n;;\\tReady list (t =%3d):  \", clock_var);\n@@ -1749,8 +1758,7 @@ schedule_block (b, rgn_n_insns)\n \t  if (! (*current_sched_info->can_schedule_ready_p) (insn))\n \t    goto next;\n \n-\t  last_scheduled_insn = insn;\n-\t  last = move_insn (insn, last);\n+\t  last_scheduled_insn = move_insn (insn, last_scheduled_insn);\n \n \t  if (targetm.sched.variable_issue)\n \t    can_issue_more =\n@@ -1798,7 +1806,7 @@ schedule_block (b, rgn_n_insns)\n \n   /* Update head/tail boundaries.  */\n   head = NEXT_INSN (prev_head);\n-  tail = last;\n+  tail = last_scheduled_insn;\n \n   /* Restore-other-notes: NOTE_LIST is the end of a chain of notes\n      previously found among the insns.  Insert them at the beginning"}, {"sha": "f5a880809c879ffb6608a5a9fd1969f9d4aae372", "filename": "gcc/sched-int.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89076bb3656b393a738933a79ddfde1161b3485a/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89076bb3656b393a738933a79ddfde1161b3485a/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=89076bb3656b393a738933a79ddfde1161b3485a", "patch": "@@ -294,6 +294,7 @@ extern void rm_other_notes PARAMS ((rtx, rtx));\n extern int insn_issue_delay PARAMS ((rtx));\n extern int set_priorities PARAMS ((rtx, rtx));\n \n+extern rtx sched_emit_insn PARAMS ((rtx));\n extern void schedule_block PARAMS ((int, int));\n extern void sched_init PARAMS ((FILE *));\n extern void sched_finish PARAMS ((void));"}]}