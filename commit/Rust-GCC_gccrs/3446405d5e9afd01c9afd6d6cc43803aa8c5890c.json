{"sha": "3446405d5e9afd01c9afd6d6cc43803aa8c5890c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzQ0NjQwNWQ1ZTlhZmQwMWM5YWZkNmQ2Y2M0MzgwM2FhOGM1ODkwYw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-08-17T13:45:59Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-08-17T13:45:59Z"}, "message": "final.c: Undo my previous accidental checkin.\n\n\t* final.c: Undo my previous accidental checkin.\n\t* output.h: Likewise.\n\t* tm.texi: Likewise.\n\nFrom-SVN: r44960", "tree": {"sha": "08b563d7aff17fe2722febc45e84ebe5f7d46180", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/08b563d7aff17fe2722febc45e84ebe5f7d46180"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3446405d5e9afd01c9afd6d6cc43803aa8c5890c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3446405d5e9afd01c9afd6d6cc43803aa8c5890c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3446405d5e9afd01c9afd6d6cc43803aa8c5890c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3446405d5e9afd01c9afd6d6cc43803aa8c5890c/comments", "author": null, "committer": null, "parents": [{"sha": "823e2b91bbec7d05748d0c0f9b08652e511808ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/823e2b91bbec7d05748d0c0f9b08652e511808ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/823e2b91bbec7d05748d0c0f9b08652e511808ef"}], "stats": {"total": 197, "additions": 64, "deletions": 133}, "files": [{"sha": "1212a519ecfdc4f53a6530e739c06cf5efe1b817", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3446405d5e9afd01c9afd6d6cc43803aa8c5890c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3446405d5e9afd01c9afd6d6cc43803aa8c5890c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3446405d5e9afd01c9afd6d6cc43803aa8c5890c", "patch": "@@ -1,3 +1,9 @@\n+Fri Aug 17 15:41:35 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* final.c: Undo my previous accidental checkin.\n+\t* output.h: Likewise.\n+\t* tm.texi: Likewise.\n+\n 2001-08-16  Richard Henderson  <rth@redhat.com>\n \n \t* varasm.c (named_section_flags): Remove align parameter."}, {"sha": "538888b16d496927d882913661be7b0ef6aecdaa", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3446405d5e9afd01c9afd6d6cc43803aa8c5890c/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3446405d5e9afd01c9afd6d6cc43803aa8c5890c/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=3446405d5e9afd01c9afd6d6cc43803aa8c5890c", "patch": "@@ -7137,20 +7137,6 @@ the target supports DWARF 2 frame unwind information.\n This describes commands for alignment.\n \n @table @code\n-@findex JUMP_ALIGN_AFTER_BARRIER\n-@item JUMP_ALIGN (@var{label})\n-The alignment (log base 2) to put in front of @var{label}, which is\n-a common destination of jumps and has no fallthru incomming edge.\n-\n-This macro need not be defined if you don't want any special alignment\n-to be done at such a time.  Most machine descriptions do not currently\n-define the macro.\n-\n-Unless it's necessary to inspect the @var{label} parameter, it is better\n-to set the variable @var{align_jumps} in the target's\n-@code{OVERRIDE_OPTIONS}.  Otherwise, you should try to honour the user's\n-selection in @var{align_jumps} in a @code{JUMP_ALIGN} implementation.\n-\n @findex LABEL_ALIGN_AFTER_BARRIER\n @item LABEL_ALIGN_AFTER_BARRIER (@var{label})\n The alignment (log base 2) to put in front of @var{label}, which follows\n@@ -7160,6 +7146,12 @@ This macro need not be defined if you don't want any special alignment\n to be done at such a time.  Most machine descriptions do not currently\n define the macro.\n \n+Unless it's necessary to inspect the @var{label} parameter, it is better\n+to set the variable @var{align_jumps} in the target's\n+@code{OVERRIDE_OPTIONS}.  Otherwise, you should try to honour the user's\n+selection in @var{align_jumps} in a @code{LABEL_ALIGN_AFTER_BARRIER}\n+implementation.\n+\n @findex LABEL_ALIGN_AFTER_BARRIER_MAX_SKIP\n @item LABEL_ALIGN_AFTER_BARRIER_MAX_SKIP\n The maximum number of bytes to skip when applying"}, {"sha": "d32248196a0066c1045a5b4e90766203d6c2e670", "filename": "gcc/final.c", "status": "modified", "additions": 52, "deletions": 116, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3446405d5e9afd01c9afd6d6cc43803aa8c5890c/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3446405d5e9afd01c9afd6d6cc43803aa8c5890c/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=3446405d5e9afd01c9afd6d6cc43803aa8c5890c", "patch": "@@ -632,6 +632,11 @@ static struct label_alignment *label_align;\n void\n init_insn_lengths ()\n {\n+  if (label_align)\n+    {\n+      free (label_align);\n+      label_align = 0;\n+    }\n   if (uid_shuid)\n     {\n       free (uid_shuid);\n@@ -775,19 +780,11 @@ get_attr_length (insn)\n #endif\n \n #ifndef LABEL_ALIGN_AFTER_BARRIER\n-#define LABEL_ALIGN_AFTER_BARRIER(LABEL) 1\n+#define LABEL_ALIGN_AFTER_BARRIER(LABEL) align_jumps_log\n #endif\n \n #ifndef LABEL_ALIGN_AFTER_BARRIER_MAX_SKIP\n-#define LABEL_ALIGN_AFTER_BARRIER_MAX_SKIP 0\n-#endif\n-\n-#ifndef JUMP_ALIGN\n-#define JUMP_ALIGN(LABEL) align_jumps_log\n-#endif\n-\n-#ifndef JUMP_ALIGN_MAX_SKIP\n-#define JUMP_ALIGN_MAX_SKIP (align_jumps-1)\n+#define LABEL_ALIGN_AFTER_BARRIER_MAX_SKIP (align_jumps-1)\n #endif\n \n #ifndef ADDR_VEC_ALIGN\n@@ -938,85 +935,6 @@ insn_current_reference_address (branch)\n }\n #endif /* HAVE_ATTR_length */\n \f\n-void\n-compute_alignments ()\n-{\n-  int i;\n-  int log, max_skip, max_log;\n-\n-  if (label_align)\n-    {\n-      free (label_align);\n-      label_align = 0;\n-    }\n-\n-  max_labelno = max_label_num ();\n-  min_labelno = get_first_label_num ();\n-  label_align = (struct label_alignment *) xcalloc ((max_labelno - min_labelno + 1),\n-\t     sizeof (struct label_alignment));\n-\n-  /* If not optimizing or optimizing for size, don't assign any alignments.  */\n-  for (i = 0; i < n_basic_blocks; i++)\n-    {\n-      basic_block bb = BASIC_BLOCK (i);\n-      rtx label = bb->head;\n-      int fallthru_frequency = 0, branch_frequency = 0, has_fallthru = 0;\n-      edge e;\n-\n-      if (GET_CODE (label) != CODE_LABEL)\n-\tcontinue;\n-      max_log = LABEL_ALIGN (label);\n-      max_skip = LABEL_ALIGN_MAX_SKIP;\n-\n-      for (e = bb->pred; e; e = e->pred_next)\n-\t{\n-\t  if (e->flags & EDGE_FALLTHRU)\n-\t    has_fallthru = 1, fallthru_frequency += EDGE_FREQUENCY (e);\n-\t  else\n-\t    branch_frequency += EDGE_FREQUENCY (e);\n-\t}\n-\n-      /* There are two purposes to align block with no fallthru incomming edge:\n-\t 1) to avoid fetch stalls when branch destination is near cache boundary\n-\t 2) to improve cache effciency in case the previous block is not executed\n-\t    (so it does not need to be in the cache).\n-\n-\t We to catch first case, we align frequently executed blocks.\n-\t To catch the second, we align blocks that are executed more frequently\n-\t than the predecesor and the predecesor is likely to not be executed\n-\t when function is called.  */\n-\n-      if (!has_fallthru\n-\t  && (branch_frequency > BB_FREQ_MAX / 10\n-\t      || (bb->frequency > BASIC_BLOCK (i - 1)->frequency * 10\n-\t\t  && (BASIC_BLOCK (i - 1)->frequency\n-\t\t      <= ENTRY_BLOCK_PTR->frequency / 2))))\n-\t{\n-\t  log = JUMP_ALIGN (label);\n-\t  if (max_log < log)\n-\t    {\n-\t      max_log = log;\n-\t      max_skip = JUMP_ALIGN_MAX_SKIP;\n-\t    }\n-\t}\n-      /* In case block is frequent and reached mostly by non-fallthru edge,\n-\t align it.  It is most likely an first block of loop.  */\n-      if (has_fallthru\n-\t  && branch_frequency + fallthru_frequency > BB_FREQ_MAX / 10\n-\t  && branch_frequency > fallthru_frequency * 5)\n-\t{\n-\t  log = LOOP_ALIGN (label);\n-\t  if (max_log < log)\n-\t    {\n-\t      max_log = log;\n-\t      max_skip = LOOP_ALIGN_MAX_SKIP;\n-\t    }\n-\t}\n-      LABEL_TO_ALIGNMENT (label) = max_log;\n-      LABEL_TO_MAX_SKIP (label) = max_skip;\n-    }\n-}\n-\f\n /* Make a pass over all insns and compute their actual lengths by shortening\n    any branches of variable length if possible.  */\n \n@@ -1054,29 +972,20 @@ shorten_branches (first)\n \n #endif\n \n-  /* Compute maximum UID and allocate label_align / uid_shuid.  */\n-  max_uid = get_max_uid ();\n+  /* We must do some computations even when not actually shortening, in\n+     order to get the alignment information for the labels.  */\n \n-  uid_shuid = (int *) xmalloc (max_uid * sizeof *uid_shuid);\n+  init_insn_lengths ();\n \n-  if (max_labelno != max_label_num ())\n-    {\n-      int old = max_labelno;\n-      int n_labels;\n-      int n_old_labels;\n-\n-      max_labelno = max_label_num ();\n-\n-      n_labels = max_labelno - min_labelno + 1;\n-      n_old_labels = old - min_labelno + 1;\n+  /* Compute maximum UID and allocate label_align / uid_shuid.  */\n+  max_uid = get_max_uid ();\n \n-      label_align = (struct label_alignment *) xrealloc\n-\t(label_align, n_labels * sizeof (struct label_alignment));\n+  max_labelno = max_label_num ();\n+  min_labelno = get_first_label_num ();\n+  label_align = (struct label_alignment *)\n+    xcalloc ((max_labelno - min_labelno + 1), sizeof (struct label_alignment));\n \n-      if (n_old_labels < n_labels)\n-\tmemset (label_align + n_old_labels, 0,\n-\t\t(n_labels - n_old_labels) * sizeof (struct label_alignment));\n-    }\n+  uid_shuid = (int *) xmalloc (max_uid * sizeof *uid_shuid);\n \n   /* Initialize label_align and set up uid_shuid to be strictly\n      monotonically rising with insn order.  */\n@@ -1103,14 +1012,6 @@ shorten_branches (first)\n       else if (GET_CODE (insn) == CODE_LABEL)\n \t{\n \t  rtx next;\n-\t  \n-\t  /* Merge in alignments computed by compute_alignments.  */\n-\t  log = LABEL_TO_ALIGNMENT (insn);\n-\t  if (max_log < log)\n-\t    {\n-\t      max_log = log;\n-\t      max_skip = LABEL_TO_MAX_SKIP (insn);\n-\t    }\n \n \t  log = LABEL_ALIGN (insn);\n \t  if (max_log < log)\n@@ -1162,6 +1063,41 @@ shorten_branches (first)\n \t\tbreak;\n \t      }\n \t}\n+      /* Again, we allow NOTE_INSN_LOOP_BEG - INSN - CODE_LABEL\n+\t sequences in order to handle reorg output efficiently.  */\n+      else if (GET_CODE (insn) == NOTE\n+\t       && NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG)\n+\t{\n+\t  rtx label;\n+\t  int nest = 0;\n+\n+\t  /* Search for the label that starts the loop.\n+\t     Don't skip past the end of the loop, since that could\n+\t     lead to putting an alignment where it does not belong.\n+\t     However, a label after a nested (non-)loop would be OK.  */\n+\t  for (label = insn; label; label = NEXT_INSN (label))\n+\t    {\n+\t      if (GET_CODE (label) == NOTE\n+\t\t  && NOTE_LINE_NUMBER (label) == NOTE_INSN_LOOP_BEG)\n+\t\tnest++;\n+\t      else if (GET_CODE (label) == NOTE\n+\t\t       && NOTE_LINE_NUMBER (label) == NOTE_INSN_LOOP_END\n+\t\t       && --nest == 0)\n+\t\tbreak;\n+\t      else if (GET_CODE (label) == CODE_LABEL)\n+\t\t{\n+\t\t  log = LOOP_ALIGN (label);\n+\t\t  if (max_log < log)\n+\t\t    {\n+\t\t      max_log = log;\n+\t\t      max_skip = LOOP_ALIGN_MAX_SKIP;\n+\t\t    }\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\tcontinue;\n     }\n #ifdef HAVE_ATTR_length\n "}, {"sha": "b5aea51efedac32af0d15281c5cdc647754136d7", "filename": "gcc/output.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3446405d5e9afd01c9afd6d6cc43803aa8c5890c/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3446405d5e9afd01c9afd6d6cc43803aa8c5890c/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=3446405d5e9afd01c9afd6d6cc43803aa8c5890c", "patch": "@@ -20,9 +20,6 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-/* Compute branch alignments based on frequency information in the CFG.  */\n-extern void compute_alignments  PARAMS ((void));\n-\n /* Initialize data in final at the beginning of a compilation.  */\n extern void init_final\t\tPARAMS ((const char *));\n "}]}