{"sha": "2b5d3dc22c321e1c8928735c47733806a1163827", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmI1ZDNkYzIyYzMyMWUxYzg5Mjg3MzVjNDc3MzM4MDZhMTE2MzgyNw==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2020-01-09T11:59:41Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2020-01-09T11:59:41Z"}, "message": "PR middle-end/93200 - spurious -Wstringop-overflow due to assignment vectorization to multiple members\n\nPR middle-end/93200 - spurious -Wstringop-overflow due to assignment vectorization to multiple members\nPR fortran/92956 - 'libgomp.fortran/examples-4/async_target-2.f90' fails with offloading due to bogus -Wstringop-overflow warning\n\ngcc/testsuite/ChangeLog:\n\n\tPR middle-end/93200\n\t* gcc.dg/Wstringop-overflow-30.c: New test.\n\ngcc/ChangeLog:\n\n\tPR middle-end/93200\n\tPR fortran/92956\n\t* builtins.c (compute_objsize): Avoid handling MEM_REFs of vector type.\n\nFrom-SVN: r280041", "tree": {"sha": "68f2fb21ea9fe277bee0ee7ad514cb539661b535", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/68f2fb21ea9fe277bee0ee7ad514cb539661b535"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2b5d3dc22c321e1c8928735c47733806a1163827", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b5d3dc22c321e1c8928735c47733806a1163827", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b5d3dc22c321e1c8928735c47733806a1163827", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b5d3dc22c321e1c8928735c47733806a1163827/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fdfd7f53ba8f363c31a1cbb5310f92ecfc52cbfe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdfd7f53ba8f363c31a1cbb5310f92ecfc52cbfe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fdfd7f53ba8f363c31a1cbb5310f92ecfc52cbfe"}], "stats": {"total": 103, "additions": 103, "deletions": 0}, "files": [{"sha": "bddbf8cc4d39b17ea9672b813cdf0f648668d052", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b5d3dc22c321e1c8928735c47733806a1163827/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b5d3dc22c321e1c8928735c47733806a1163827/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2b5d3dc22c321e1c8928735c47733806a1163827", "patch": "@@ -1,3 +1,9 @@\n+2020-01-09  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/93200\n+\tPR fortran/92956\n+\t* builtins.c (compute_objsize): Avoid handling MEM_REFs of vector type.\n+\n 2020-01-09  Martin Liska  <mliska@suse.cz>\n \n \t* auto-profile.c (auto_profile): Use opt_for_fn"}, {"sha": "e4a8694054e2bbd98c0d8361689c17e607a28364", "filename": "gcc/builtins.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b5d3dc22c321e1c8928735c47733806a1163827/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b5d3dc22c321e1c8928735c47733806a1163827/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=2b5d3dc22c321e1c8928735c47733806a1163827", "patch": "@@ -3966,6 +3966,18 @@ compute_objsize (tree dest, int ostype, tree *pdecl /* = NULL */,\n       || TREE_CODE (dest) == MEM_REF)\n     {\n       tree ref = TREE_OPERAND (dest, 0);\n+      tree reftype = TREE_TYPE (ref);\n+      if (TREE_CODE (dest) == MEM_REF && TREE_CODE (reftype) == POINTER_TYPE)\n+\t{\n+\t  /* Give up for MEM_REFs of vector types; those may be synthesized\n+\t     from multiple assignments to consecutive data members.  See PR\n+\t     93200.\n+\t     FIXME: Deal with this more generally, e.g., by marking up such\n+\t     MEM_REFs at the time they're created.  */\n+\t  reftype = TREE_TYPE (reftype);\n+\t  if (TREE_CODE (reftype) == VECTOR_TYPE)\n+\t    return NULL_TREE;\n+\t}\n       tree off = TREE_OPERAND (dest, 1);\n       if (tree size = compute_objsize (ref, ostype, pdecl, poff))\n \t{"}, {"sha": "db6e9602cdacecff5cafd2f72df66c5b90f61093", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b5d3dc22c321e1c8928735c47733806a1163827/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b5d3dc22c321e1c8928735c47733806a1163827/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2b5d3dc22c321e1c8928735c47733806a1163827", "patch": "@@ -1,3 +1,8 @@\n+2020-01-09  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/93200\n+\t* gcc.dg/Wstringop-overflow-30.c: New test.\n+\n 2020-01-09  Richard Biener  <rguenther@suse.de>\n \n \tPR middle-end/93054"}, {"sha": "a9eee9902d3cbd2ca0274b84c905967b2a7e10c7", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-30.c", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b5d3dc22c321e1c8928735c47733806a1163827/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-30.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b5d3dc22c321e1c8928735c47733806a1163827/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-30.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-30.c?ref=2b5d3dc22c321e1c8928735c47733806a1163827", "patch": "@@ -0,0 +1,80 @@\n+/* PR middle-end/93200 - spurious -Wstringop-overflow due to assignment\n+   vectorization to multiple members\n+   { dg-do compile }\n+   { dg-options \"-O3 -Wall\" } */\n+\n+typedef __INT8_TYPE__  int8_t;\n+typedef __INT16_TYPE__ int16_t;\n+typedef __INT32_TYPE__ int32_t;\n+typedef __INT64_TYPE__ int64_t;\n+\n+struct A { char b, c; };\n+struct B1A { int8_t i8; struct A a; };\n+struct B2A { int16_t i16; struct A a; };\n+struct B3A { int16_t i16; int8_t i8; struct A a; };\n+struct B4A { int64_t i64; struct A a; };\n+\n+void ba1 (struct B1A *p)\n+{\n+  p->a.b = 0; p->a.c = 1;\n+}\n+\n+void b2a (struct B2A *p)\n+{\n+  /* This results in:\n+     vector(2) char *vectp.14_6 = &p_2(D)->a.b;\n+     MEM <vector(2) char> [(char *)vectp.14_6] = { 4, 5 };  */\n+\n+  p->a.b = 4;       // { dg-bogus \"-Wstringop-overflow\" }\n+  p->a.c = 5;\n+}\n+\n+void b3a (struct B3A *p)\n+{\n+  p->a.b = 4; p->a.c = 5;\n+}\n+\n+void b4a (struct B4A *p)\n+{\n+  /* This results in:\n+     vector(2) char *vectp.22_6 = &p_2(D)->a.b;\n+     MEM <vector(2) char> [(char *)vectp.22_6] = { 6, 7 };  */\n+\n+  p->a.b = 6;       // { dg-bogus \"-Wstringop-overflow\" }\n+  p->a.c = 7;\n+}\n+\n+\n+struct Aa { char a[2], b[2]; };\n+struct B1Aa { int8_t i8; struct Aa a; };\n+struct B2Aa { int16_t i16; struct Aa a; };\n+struct B3Aa { int16_t i16; int8_t i8; struct Aa a; };\n+struct B4Aa { int64_t i64; struct Aa a; };\n+\n+void b1aa (struct B1Aa *p)\n+{\n+  p->a.a[0] = 0; p->a.a[1] = 1;\n+  p->a.b[0] = 0; p->a.b[1] = 1;\n+}\n+\n+void b2aa (struct B2Aa *p)\n+{\n+  p->a.a[0] = 2; p->a.a[1] = 3;\n+  p->a.b[0] = 2; p->a.b[1] = 3;\n+}\n+\n+void b3aa (struct B3Aa *p)\n+{\n+  p->a.a[0] = 4; p->a.a[1] = 5;\n+  p->a.b[0] = 4; p->a.b[1] = 5;\n+}\n+\n+void b4aa (struct B4Aa *p)\n+{\n+  /* This results in:\n+     vector(4) char *vectp.36_8 = &p_2(D)->a.a[0];\n+     MEM <vector(4) char> [(char *)vectp.36_8] = { 6, 7, 6, 7 };  */\n+\n+  p->a.a[0] = 6; p->a.a[1] = 7;\n+  p->a.b[0] = 6; p->a.b[1] = 7;\n+}"}]}