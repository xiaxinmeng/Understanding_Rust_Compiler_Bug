{"sha": "65312dfc64744405326a9f4c243f1b4c8f21de1b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjUzMTJkZmM2NDc0NDQwNTMyNmE5ZjRjMjQzZjFiNGM4ZjIxZGUxYg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-12-04T09:54:45Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-12-04T09:54:45Z"}, "message": "dwarf: Add -gdwarf{32,64} options\n\nThe following patch makes the choice between 32-bit and 64-bit DWARF formats\nselectable by command line switch, rather than being hardcoded through\nDWARF_OFFSET_SIZE macro.\n\nThe options themselves don't turn on debug info themselves, so one needs\nto use -g -gdwarf64 or similar.\n\n2020-12-04  Jakub Jelinek  <jakub@redhat.com>\n\n\t* common.opt (-gdwarf32, -gdwarf64): New options.\n\t* config/rs6000/rs6000.c (rs6000_option_override_internal): Default\n\tdwarf_offset_size to 8 if not overridden from the command line.\n\t* dwarf2out.c: Change all occurrences of DWARF_OFFSET_SIZE to\n\tdwarf_offset_size.\n\t* doc/invoke.texi (-gdwarf32, -gdwarf64): Document.", "tree": {"sha": "e9c5a9cae5d303385de694fe1b32e1c12a1e9fc0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e9c5a9cae5d303385de694fe1b32e1c12a1e9fc0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/65312dfc64744405326a9f4c243f1b4c8f21de1b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65312dfc64744405326a9f4c243f1b4c8f21de1b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65312dfc64744405326a9f4c243f1b4c8f21de1b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65312dfc64744405326a9f4c243f1b4c8f21de1b/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "485b40a5270cf50a7304a9e5cb8aff96bfa3d901", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/485b40a5270cf50a7304a9e5cb8aff96bfa3d901", "html_url": "https://github.com/Rust-GCC/gccrs/commit/485b40a5270cf50a7304a9e5cb8aff96bfa3d901"}], "stats": {"total": 216, "additions": 121, "deletions": 95}, "files": [{"sha": "6645539f5e52f90f2bc9054de44612c8ac384408", "filename": "gcc/common.opt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65312dfc64744405326a9f4c243f1b4c8f21de1b/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65312dfc64744405326a9f4c243f1b4c8f21de1b/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=65312dfc64744405326a9f4c243f1b4c8f21de1b", "patch": "@@ -3178,6 +3178,14 @@ gdwarf-\n Common Driver Joined UInteger Var(dwarf_version) Init(4) Negative(gstabs)\n Generate debug information in DWARF v2 (or later) format.\n \n+gdwarf32\n+Common Driver Var(dwarf_offset_size,4) Init(4) RejectNegative\n+Use 32-bit DWARF format when emitting DWARF debug information.\n+\n+gdwarf64\n+Common Driver Var(dwarf_offset_size,8) RejectNegative\n+Use 64-bit DWARF format when emitting DWARF debug information.\n+\n ggdb\n Common Driver JoinedOrMissing\n Generate debug information in default extended format."}, {"sha": "d2666039ab1e4e9f4b1af72b8df4cca0dce4c86c", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65312dfc64744405326a9f4c243f1b4c8f21de1b/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65312dfc64744405326a9f4c243f1b4c8f21de1b/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=65312dfc64744405326a9f4c243f1b4c8f21de1b", "patch": "@@ -3864,6 +3864,12 @@ rs6000_option_override_internal (bool global_init_p)\n   if (TARGET_DEBUG_REG || TARGET_DEBUG_TARGET)\n     rs6000_print_isa_options (stderr, 0, \"before defaults\", rs6000_isa_flags);\n \n+#ifdef XCOFF_DEBUGGING_INFO\n+  /* For AIX default to 64-bit DWARF.  */\n+  if (!global_options_set.x_dwarf_offset_size)\n+    dwarf_offset_size = PTR_SIZE;\n+#endif\n+\n   /* Handle explicit -mno-{altivec,vsx,power8-vector,power9-vector} and turn\n      off all of the options that depend on those flags.  */\n   ignore_masks = rs6000_disable_incompatible_switches ();"}, {"sha": "671b29702eae666f7226f94e6cb9577b04a29393", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65312dfc64744405326a9f4c243f1b4c8f21de1b/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65312dfc64744405326a9f4c243f1b4c8f21de1b/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=65312dfc64744405326a9f4c243f1b4c8f21de1b", "patch": "@@ -453,7 +453,7 @@ Objective-C and Objective-C++ Dialects}.\n -gstabs  -gstabs+  -gstrict-dwarf  -gno-strict-dwarf @gol\n -gas-loc-support  -gno-as-loc-support @gol\n -gas-locview-support  -gno-as-locview-support @gol\n--gcolumn-info  -gno-column-info @gol\n+-gcolumn-info  -gno-column-info  -gdwarf32  -gdwarf64 @gol\n -gstatement-frontiers  -gno-statement-frontiers @gol\n -gvariable-location-views  -gno-variable-location-views @gol\n -ginternal-reset-location-views  -gno-internal-reset-location-views @gol\n@@ -9654,6 +9654,18 @@ information as possible into a separate output file with the extension\n debug information.  To be useful, this option requires a debugger capable of\n reading @file{.dwo} files.\n \n+@item -gdwarf32\n+@itemx -gdwarf64\n+@opindex gdwarf32\n+@opindex gdwarf64\n+If DWARF debugging information is enabled, the @option{-gdwarf32} selects\n+the 32-bit DWARF format and the @option{-gdwarf64} selects the 64-bit\n+DWARF format.  The default is target specific, on most targets it is\n+@option{-gdwarf32} though.  The 32-bit DWARF format is smaller, but\n+can't support more than 2GiB of debug information in any of the DWARF\n+debug information sections.  The 64-bit DWARF format allows larger debug\n+information and might not be well supported by all consumers yet.\n+\n @item -gdescribe-dies\n @opindex gdescribe-dies\n Add description attributes to some DWARF DIEs that have no name attribute,"}, {"sha": "7b340baf42236a8dfb0278f5faa6167ca8992440", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 94, "deletions": 94, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65312dfc64744405326a9f4c243f1b4c8f21de1b/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65312dfc64744405326a9f4c243f1b4c8f21de1b/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=65312dfc64744405326a9f4c243f1b4c8f21de1b", "patch": "@@ -182,14 +182,14 @@ static GTY(()) section *debug_frame_section;\n    bytes.\n \n    However, the SGI/MIPS ABI uses an initial length which is equal to\n-   DWARF_OFFSET_SIZE.  It is defined (elsewhere) accordingly.  */\n+   dwarf_offset_size.  It is defined (elsewhere) accordingly.  */\n \n #ifndef DWARF_INITIAL_LENGTH_SIZE\n-#define DWARF_INITIAL_LENGTH_SIZE (DWARF_OFFSET_SIZE == 4 ? 4 : 12)\n+#define DWARF_INITIAL_LENGTH_SIZE (dwarf_offset_size == 4 ? 4 : 12)\n #endif\n \n #ifndef DWARF_INITIAL_LENGTH_SIZE_STR\n-#define DWARF_INITIAL_LENGTH_SIZE_STR (DWARF_OFFSET_SIZE == 4 ? \"-4\" : \"-12\")\n+#define DWARF_INITIAL_LENGTH_SIZE_STR (dwarf_offset_size == 4 ? \"-4\" : \"-12\")\n #endif\n \n /* Round SIZE up to the nearest BOUNDARY.  */\n@@ -199,7 +199,7 @@ static GTY(()) section *debug_frame_section;\n /* CIE identifier.  */\n #if HOST_BITS_PER_WIDE_INT >= 64\n #define DWARF_CIE_ID \\\n-  (unsigned HOST_WIDE_INT) (DWARF_OFFSET_SIZE == 4 ? DW_CIE_ID : DW64_CIE_ID)\n+  (unsigned HOST_WIDE_INT) (dwarf_offset_size == 4 ? DW_CIE_ID : DW64_CIE_ID)\n #else\n #define DWARF_CIE_ID DW_CIE_ID\n #endif\n@@ -287,8 +287,8 @@ static GTY(()) bool do_eh_frame = false;\n static unsigned int rnglist_idx;\n \n /* Data and reference forms for relocatable data.  */\n-#define DW_FORM_data (DWARF_OFFSET_SIZE == 8 ? DW_FORM_data8 : DW_FORM_data4)\n-#define DW_FORM_ref (DWARF_OFFSET_SIZE == 8 ? DW_FORM_ref8 : DW_FORM_ref4)\n+#define DW_FORM_data (dwarf_offset_size == 8 ? DW_FORM_data8 : DW_FORM_data4)\n+#define DW_FORM_ref (dwarf_offset_size == 8 ? DW_FORM_ref8 : DW_FORM_ref4)\n \n #ifndef DEBUG_FRAME_SECTION\n #define DEBUG_FRAME_SECTION\t\".debug_frame\"\n@@ -602,18 +602,18 @@ output_fde (dw_fde_ref fde, bool for_eh, bool second,\n   ASM_GENERATE_INTERNAL_LABEL (l2, FDE_END_LABEL, for_eh + j);\n   if (!XCOFF_DEBUGGING_INFO || for_eh)\n     {\n-      if (DWARF_INITIAL_LENGTH_SIZE - DWARF_OFFSET_SIZE == 4 && !for_eh)\n+      if (DWARF_INITIAL_LENGTH_SIZE - dwarf_offset_size == 4 && !for_eh)\n \tdw2_asm_output_data (4, 0xffffffff, \"Initial length escape value\"\n \t\t\t     \" indicating 64-bit DWARF extension\");\n-      dw2_asm_output_delta (for_eh ? 4 : DWARF_OFFSET_SIZE, l2, l1,\n+      dw2_asm_output_delta (for_eh ? 4 : dwarf_offset_size, l2, l1,\n \t\t\t    \"FDE Length\");\n     }\n   ASM_OUTPUT_LABEL (asm_out_file, l1);\n \n   if (for_eh)\n     dw2_asm_output_delta (4, l1, section_start_label, \"FDE CIE offset\");\n   else\n-    dw2_asm_output_offset (DWARF_OFFSET_SIZE, section_start_label,\n+    dw2_asm_output_offset (dwarf_offset_size, section_start_label,\n \t\t\t   debug_frame_section, \"FDE CIE offset\");\n \n   begin = second ? fde->dw_fde_second_begin : fde->dw_fde_begin;\n@@ -806,17 +806,17 @@ output_call_frame_info (int for_eh)\n   ASM_GENERATE_INTERNAL_LABEL (l2, CIE_END_LABEL, for_eh);\n   if (!XCOFF_DEBUGGING_INFO || for_eh)\n     {\n-      if (DWARF_INITIAL_LENGTH_SIZE - DWARF_OFFSET_SIZE == 4 && !for_eh)\n+      if (DWARF_INITIAL_LENGTH_SIZE - dwarf_offset_size == 4 && !for_eh)\n \tdw2_asm_output_data (4, 0xffffffff,\n \t  \"Initial length escape value indicating 64-bit DWARF extension\");\n-      dw2_asm_output_delta (for_eh ? 4 : DWARF_OFFSET_SIZE, l2, l1,\n+      dw2_asm_output_delta (for_eh ? 4 : dwarf_offset_size, l2, l1,\n \t\t\t    \"Length of Common Information Entry\");\n     }\n   ASM_OUTPUT_LABEL (asm_out_file, l1);\n \n   /* Now that the CIE pointer is PC-relative for EH,\n      use 0 to identify the CIE.  */\n-  dw2_asm_output_data ((for_eh ? 4 : DWARF_OFFSET_SIZE),\n+  dw2_asm_output_data ((for_eh ? 4 : dwarf_offset_size),\n \t\t       (for_eh ? 0 : DWARF_CIE_ID),\n \t\t       \"CIE Identifier Tag\");\n \n@@ -1623,7 +1623,7 @@ loc_list_plus_const (dw_loc_list_ref list_head, poly_int64 offset)\n }\n \n #define DWARF_REF_SIZE\t\\\n-  (dwarf_version == 2 ? DWARF2_ADDR_SIZE : DWARF_OFFSET_SIZE)\n+  (dwarf_version == 2 ? DWARF2_ADDR_SIZE : dwarf_offset_size)\n \n /* The number of bits that can be encoded by largest DW_FORM_dataN.\n    In DWARF4 and earlier it is DW_FORM_data8 with 64 bits, in DWARF5\n@@ -3229,33 +3229,33 @@ skeleton_chain_node;\n \n /* Fixed size portion of the DWARF compilation unit header.  */\n #define DWARF_COMPILE_UNIT_HEADER_SIZE \\\n-  (DWARF_INITIAL_LENGTH_SIZE + DWARF_OFFSET_SIZE\t\t\t\\\n+  (DWARF_INITIAL_LENGTH_SIZE + dwarf_offset_size\t\t\t\\\n    + (dwarf_version >= 5 ? 4 : 3))\n \n /* Fixed size portion of the DWARF comdat type unit header.  */\n #define DWARF_COMDAT_TYPE_UNIT_HEADER_SIZE \\\n   (DWARF_COMPILE_UNIT_HEADER_SIZE\t\t\t\t\t\\\n-   + DWARF_TYPE_SIGNATURE_SIZE + DWARF_OFFSET_SIZE)\n+   + DWARF_TYPE_SIGNATURE_SIZE + dwarf_offset_size)\n \n /* Fixed size portion of the DWARF skeleton compilation unit header.  */\n #define DWARF_COMPILE_UNIT_SKELETON_HEADER_SIZE \\\n   (DWARF_COMPILE_UNIT_HEADER_SIZE + (dwarf_version >= 5 ? 8 : 0))\n \n /* Fixed size portion of public names info.  */\n-#define DWARF_PUBNAMES_HEADER_SIZE (2 * DWARF_OFFSET_SIZE + 2)\n+#define DWARF_PUBNAMES_HEADER_SIZE (2 * dwarf_offset_size + 2)\n \n /* Fixed size portion of the address range info.  */\n #define DWARF_ARANGES_HEADER_SIZE\t\t\t\t\t\\\n-  (DWARF_ROUND (DWARF_INITIAL_LENGTH_SIZE + DWARF_OFFSET_SIZE + 4,\t\\\n+  (DWARF_ROUND (DWARF_INITIAL_LENGTH_SIZE + dwarf_offset_size + 4,\t\\\n \t\tDWARF2_ADDR_SIZE * 2)\t\t\t\t\t\\\n    - DWARF_INITIAL_LENGTH_SIZE)\n \n /* Size of padding portion in the address range info.  It must be\n    aligned to twice the pointer size.  */\n #define DWARF_ARANGES_PAD_SIZE \\\n-  (DWARF_ROUND (DWARF_INITIAL_LENGTH_SIZE + DWARF_OFFSET_SIZE + 4, \\\n+  (DWARF_ROUND (DWARF_INITIAL_LENGTH_SIZE + dwarf_offset_size + 4, \\\n \t\tDWARF2_ADDR_SIZE * 2)\t\t\t\t   \\\n-   - (DWARF_INITIAL_LENGTH_SIZE + DWARF_OFFSET_SIZE + 4))\n+   - (DWARF_INITIAL_LENGTH_SIZE + dwarf_offset_size + 4))\n \n /* Use assembler line directives if available.  */\n #ifndef DWARF2_ASM_LINE_DEBUG_INFO\n@@ -4787,15 +4787,15 @@ find_string_form (struct indirect_string_node *node)\n \n   /* If the string is shorter or equal to the size of the reference, it is\n      always better to put it inline.  */\n-  if (len <= DWARF_OFFSET_SIZE || node->refcount == 0)\n+  if (len <= (unsigned) dwarf_offset_size || node->refcount == 0)\n     return node->form = DW_FORM_string;\n \n   /* If we cannot expect the linker to merge strings in .debug_str\n      section, only put it into .debug_str if it is worth even in this\n      single module.  */\n   if (DWARF2_INDIRECT_STRING_SUPPORT_MISSING_ON_TARGET\n       || ((debug_str_section->common.flags & SECTION_MERGE) == 0\n-\t  && (len - DWARF_OFFSET_SIZE) * node->refcount <= len))\n+\t  && (len - dwarf_offset_size) * node->refcount <= len))\n     return node->form = DW_FORM_string;\n \n   set_indirect_string (node);\n@@ -8892,7 +8892,7 @@ output_loclists_offsets (dw_die_ref die)\n \tdw_loc_list_ref l = AT_loc_list (a);\n \tif (l->offset_emitted)\n \t  continue;\n-\tdw2_asm_output_delta (DWARF_OFFSET_SIZE, l->ll_symbol,\n+\tdw2_asm_output_delta (dwarf_offset_size, l->ll_symbol,\n \t\t\t      loc_section_label, NULL);\n \tgcc_assert (l->hash == loc_list_idx);\n \tloc_list_idx++;\n@@ -9400,7 +9400,7 @@ size_of_die (dw_die_ref die)\n             size += DWARF2_ADDR_SIZE;\n \t  break;\n \tcase dw_val_class_offset:\n-\t  size += DWARF_OFFSET_SIZE;\n+\t  size += dwarf_offset_size;\n \t  break;\n \tcase dw_val_class_loc:\n \t  {\n@@ -9421,10 +9421,10 @@ size_of_die (dw_die_ref die)\n \t      size += size_of_uleb128 (AT_loc_list (a)->hash);\n \t    }\n           else\n-            size += DWARF_OFFSET_SIZE;\n+            size += dwarf_offset_size;\n \t  break;\n \tcase dw_val_class_view_list:\n-\t  size += DWARF_OFFSET_SIZE;\n+\t  size += dwarf_offset_size;\n \t  break;\n \tcase dw_val_class_range_list:\n \t  if (value_format (a) == DW_FORM_rnglistx)\n@@ -9434,7 +9434,7 @@ size_of_die (dw_die_ref die)\n \t      size += size_of_uleb128 (r->idx);\n \t    }\n \t  else\n-\t    size += DWARF_OFFSET_SIZE;\n+\t    size += dwarf_offset_size;\n \t  break;\n \tcase dw_val_class_const:\n \t  size += size_of_sleb128 (AT_int (a));\n@@ -9508,13 +9508,13 @@ size_of_die (dw_die_ref die)\n \t      else if (dwarf_version == 2)\n \t\tsize += DWARF2_ADDR_SIZE;\n \t      else\n-\t\tsize += DWARF_OFFSET_SIZE;\n+\t\tsize += dwarf_offset_size;\n \t    }\n \t  else\n-\t    size += DWARF_OFFSET_SIZE;\n+\t    size += dwarf_offset_size;\n \t  break;\n \tcase dw_val_class_fde_ref:\n-\t  size += DWARF_OFFSET_SIZE;\n+\t  size += dwarf_offset_size;\n \t  break;\n \tcase dw_val_class_lbl_id:\n           if (dwarf_split_debug_info && AT_index (a) != NOT_INDEXED)\n@@ -9528,12 +9528,12 @@ size_of_die (dw_die_ref die)\n \tcase dw_val_class_lineptr:\n \tcase dw_val_class_macptr:\n \tcase dw_val_class_loclistsptr:\n-\t  size += DWARF_OFFSET_SIZE;\n+\t  size += dwarf_offset_size;\n \t  break;\n \tcase dw_val_class_str:\n           form = AT_string_form (a);\n \t  if (form == DW_FORM_strp || form == DW_FORM_line_strp)\n-\t    size += DWARF_OFFSET_SIZE;\n+\t    size += dwarf_offset_size;\n \t  else if (form == dwarf_FORM (DW_FORM_strx))\n \t    size += size_of_uleb128 (AT_index (a));\n \t  else\n@@ -9546,7 +9546,7 @@ size_of_die (dw_die_ref die)\n \t  size += 8;\n \t  break;\n \tcase dw_val_class_vms_delta:\n-\t  size += DWARF_OFFSET_SIZE;\n+\t  size += dwarf_offset_size;\n \t  break;\n \tcase dw_val_class_high_pc:\n \t  size += DWARF2_ADDR_SIZE;\n@@ -9724,9 +9724,9 @@ size_of_pubnames (vec<pubname_entry, va_gc> *names)\n   size = DWARF_PUBNAMES_HEADER_SIZE;\n   FOR_EACH_VEC_ELT (*names, i, p)\n     if (include_pubname_in_output (names, p))\n-      size += strlen (p->name) + DWARF_OFFSET_SIZE + 1 + space_for_flags;\n+      size += strlen (p->name) + dwarf_offset_size + 1 + space_for_flags;\n \n-  size += DWARF_OFFSET_SIZE;\n+  size += dwarf_offset_size;\n   return size;\n }\n \n@@ -9823,7 +9823,7 @@ value_format (dw_attr_node *a)\n       /* FALLTHRU */\n     case dw_val_class_vms_delta:\n     case dw_val_class_offset:\n-      switch (DWARF_OFFSET_SIZE)\n+      switch (dwarf_offset_size)\n \t{\n \tcase 4:\n \t  return DW_FORM_data4;\n@@ -10525,15 +10525,15 @@ output_range_list_offset (dw_attr_node *a)\n       if (dwarf_version >= 5)\n \t{\n \t  dw_ranges *r = &(*ranges_table)[a->dw_attr_val.v.val_offset];\n-\t  dw2_asm_output_offset (DWARF_OFFSET_SIZE, r->label,\n+\t  dw2_asm_output_offset (dwarf_offset_size, r->label,\n \t\t\t\t debug_ranges_section, \"%s\", name);\n \t}\n       else\n \t{\n \t  char *p = strchr (ranges_section_label, '\\0');\n \t  sprintf (p, \"+\" HOST_WIDE_INT_PRINT_HEX,\n \t\t   a->dw_attr_val.v.val_offset * 2 * DWARF2_ADDR_SIZE);\n-\t  dw2_asm_output_offset (DWARF_OFFSET_SIZE, ranges_section_label,\n+\t  dw2_asm_output_offset (dwarf_offset_size, ranges_section_label,\n \t\t\t\t debug_ranges_section, \"%s\", name);\n \t  *p = '\\0';\n \t}\n@@ -10545,7 +10545,7 @@ output_range_list_offset (dw_attr_node *a)\n       dw2_asm_output_data_uleb128 (r->idx, \"%s\", name);\n     }\n   else\n-    dw2_asm_output_data (DWARF_OFFSET_SIZE,\n+    dw2_asm_output_data (dwarf_offset_size,\n \t\t\t a->dw_attr_val.v.val_offset * 2 * DWARF2_ADDR_SIZE,\n                          \"%s (offset from %s)\", name, ranges_section_label);\n }\n@@ -10559,7 +10559,7 @@ output_loc_list_offset (dw_attr_node *a)\n \n   gcc_assert (sym);\n   if (!dwarf_split_debug_info)\n-    dw2_asm_output_offset (DWARF_OFFSET_SIZE, sym, debug_loc_section,\n+    dw2_asm_output_offset (dwarf_offset_size, sym, debug_loc_section,\n                            \"%s\", dwarf_attr_name (a->dw_attr));\n   else if (dwarf_version >= 5)\n     {\n@@ -10569,7 +10569,7 @@ output_loc_list_offset (dw_attr_node *a)\n \t\t\t\t   sym);\n     }\n   else\n-    dw2_asm_output_delta (DWARF_OFFSET_SIZE, sym, loc_section_label,\n+    dw2_asm_output_delta (dwarf_offset_size, sym, loc_section_label,\n \t\t\t  \"%s\", dwarf_attr_name (a->dw_attr));\n }\n \n@@ -10582,10 +10582,10 @@ output_view_list_offset (dw_attr_node *a)\n \n   gcc_assert (sym);\n   if (dwarf_split_debug_info)\n-    dw2_asm_output_delta (DWARF_OFFSET_SIZE, sym, loc_section_label,\n+    dw2_asm_output_delta (dwarf_offset_size, sym, loc_section_label,\n                           \"%s\", dwarf_attr_name (a->dw_attr));\n   else\n-    dw2_asm_output_offset (DWARF_OFFSET_SIZE, sym, debug_loc_section,\n+    dw2_asm_output_offset (dwarf_offset_size, sym, debug_loc_section,\n                            \"%s\", dwarf_attr_name (a->dw_attr));\n }\n \n@@ -10663,7 +10663,7 @@ output_die (dw_die_ref die)\n \t  break;\n \n \tcase dw_val_class_offset:\n-\t  dw2_asm_output_data (DWARF_OFFSET_SIZE, a->dw_attr_val.v.val_offset,\n+\t  dw2_asm_output_data (dwarf_offset_size, a->dw_attr_val.v.val_offset,\n \t\t\t       \"%s\", name);\n \t  break;\n \n@@ -10857,7 +10857,7 @@ output_die (dw_die_ref die)\n \t\t  if (dwarf_version == 2)\n \t\t    size = DWARF2_ADDR_SIZE;\n \t\t  else\n-\t\t    size = DWARF_OFFSET_SIZE;\n+\t\t    size = dwarf_offset_size;\n \t\t  /* ???  We cannot unconditionally output die_offset if\n \t\t     non-zero - others might create references to those\n \t\t     DIEs via symbols.\n@@ -10877,7 +10877,7 @@ output_die (dw_die_ref die)\n \t  else\n \t    {\n \t      gcc_assert (AT_ref (a)->die_offset);\n-\t      dw2_asm_output_data (DWARF_OFFSET_SIZE, AT_ref (a)->die_offset,\n+\t      dw2_asm_output_data (dwarf_offset_size, AT_ref (a)->die_offset,\n \t\t\t\t   \"%s\", name);\n \t    }\n \t  break;\n@@ -10888,18 +10888,18 @@ output_die (dw_die_ref die)\n \n \t    ASM_GENERATE_INTERNAL_LABEL (l1, FDE_LABEL,\n \t\t\t\t\t a->dw_attr_val.v.val_fde_index * 2);\n-\t    dw2_asm_output_offset (DWARF_OFFSET_SIZE, l1, debug_frame_section,\n+\t    dw2_asm_output_offset (dwarf_offset_size, l1, debug_frame_section,\n \t\t\t\t   \"%s\", name);\n \t  }\n \t  break;\n \n \tcase dw_val_class_vms_delta:\n #ifdef ASM_OUTPUT_DWARF_VMS_DELTA\n-\t  dw2_asm_output_vms_delta (DWARF_OFFSET_SIZE,\n+\t  dw2_asm_output_vms_delta (dwarf_offset_size,\n \t\t\t\t    AT_vms_delta2 (a), AT_vms_delta1 (a),\n \t\t\t\t    \"%s\", name);\n #else\n-\t  dw2_asm_output_delta (DWARF_OFFSET_SIZE,\n+\t  dw2_asm_output_delta (dwarf_offset_size,\n \t\t\t\tAT_vms_delta2 (a), AT_vms_delta1 (a),\n \t\t\t\t\"%s\", name);\n #endif\n@@ -10910,28 +10910,28 @@ output_die (dw_die_ref die)\n \t  break;\n \n \tcase dw_val_class_lineptr:\n-\t  dw2_asm_output_offset (DWARF_OFFSET_SIZE, AT_lbl (a),\n+\t  dw2_asm_output_offset (dwarf_offset_size, AT_lbl (a),\n \t\t\t\t debug_line_section, \"%s\", name);\n \t  break;\n \n \tcase dw_val_class_macptr:\n-\t  dw2_asm_output_offset (DWARF_OFFSET_SIZE, AT_lbl (a),\n+\t  dw2_asm_output_offset (dwarf_offset_size, AT_lbl (a),\n \t\t\t\t debug_macinfo_section, \"%s\", name);\n \t  break;\n \n \tcase dw_val_class_loclistsptr:\n-\t  dw2_asm_output_offset (DWARF_OFFSET_SIZE, AT_lbl (a),\n+\t  dw2_asm_output_offset (dwarf_offset_size, AT_lbl (a),\n \t\t\t\t debug_loc_section, \"%s\", name);\n \t  break;\n \n \tcase dw_val_class_str:\n           if (a->dw_attr_val.v.val_str->form == DW_FORM_strp)\n-            dw2_asm_output_offset (DWARF_OFFSET_SIZE,\n+            dw2_asm_output_offset (dwarf_offset_size,\n                                    a->dw_attr_val.v.val_str->label,\n                                    debug_str_section,\n                                    \"%s: \\\"%s\\\"\", name, AT_string (a));\n \t  else if (a->dw_attr_val.v.val_str->form == DW_FORM_line_strp)\n-\t    dw2_asm_output_offset (DWARF_OFFSET_SIZE,\n+\t    dw2_asm_output_offset (dwarf_offset_size,\n \t\t\t\t   a->dw_attr_val.v.val_str->label,\n \t\t\t\t   debug_line_str_section,\n \t\t\t\t   \"%s: \\\"%s\\\"\", name, AT_string (a));\n@@ -11048,10 +11048,10 @@ output_compilation_unit_header (enum dwarf_unit_type ut)\n {\n   if (!XCOFF_DEBUGGING_INFO)\n     {\n-      if (DWARF_INITIAL_LENGTH_SIZE - DWARF_OFFSET_SIZE == 4)\n+      if (DWARF_INITIAL_LENGTH_SIZE - dwarf_offset_size == 4)\n \tdw2_asm_output_data (4, 0xffffffff,\n \t  \"Initial length escape value indicating 64-bit DWARF extension\");\n-      dw2_asm_output_data (DWARF_OFFSET_SIZE,\n+      dw2_asm_output_data (dwarf_offset_size,\n \t\t\t   next_die_offset - DWARF_INITIAL_LENGTH_SIZE,\n \t\t\t   \"Length of Compilation Unit Info\");\n     }\n@@ -11071,7 +11071,7 @@ output_compilation_unit_header (enum dwarf_unit_type ut)\n       dw2_asm_output_data (1, ut, \"%s\", name);\n       dw2_asm_output_data (1, DWARF2_ADDR_SIZE, \"Pointer Size (in bytes)\");\n     }\n-  dw2_asm_output_offset (DWARF_OFFSET_SIZE, abbrev_section_label,\n+  dw2_asm_output_offset (dwarf_offset_size, abbrev_section_label,\n \t\t\t debug_abbrev_section,\n \t\t\t \"Offset Into Abbrev. Section\");\n   if (dwarf_version < 5)\n@@ -11261,12 +11261,12 @@ output_skeleton_debug_sections (dw_die_ref comp_unit,\n   /* Produce the skeleton compilation-unit header.  This one differs enough from\n      a normal CU header that it's better not to call output_compilation_unit\n      header.  */\n-  if (DWARF_INITIAL_LENGTH_SIZE - DWARF_OFFSET_SIZE == 4)\n+  if (DWARF_INITIAL_LENGTH_SIZE - dwarf_offset_size == 4)\n     dw2_asm_output_data (4, 0xffffffff,\n \t\t\t \"Initial length escape value indicating 64-bit \"\n \t\t\t \"DWARF extension\");\n \n-  dw2_asm_output_data (DWARF_OFFSET_SIZE,\n+  dw2_asm_output_data (dwarf_offset_size,\n \t\t       DWARF_COMPILE_UNIT_SKELETON_HEADER_SIZE\n                        - DWARF_INITIAL_LENGTH_SIZE\n                        + size_of_die (comp_unit),\n@@ -11277,7 +11277,7 @@ output_skeleton_debug_sections (dw_die_ref comp_unit,\n       dw2_asm_output_data (1, DW_UT_skeleton, \"DW_UT_skeleton\");\n       dw2_asm_output_data (1, DWARF2_ADDR_SIZE, \"Pointer Size (in bytes)\");\n     }\n-  dw2_asm_output_offset (DWARF_OFFSET_SIZE, debug_skeleton_abbrev_section_label,\n+  dw2_asm_output_offset (dwarf_offset_size, debug_skeleton_abbrev_section_label,\n \t\t\t debug_skeleton_abbrev_section,\n                          \"Offset Into Abbrev. Section\");\n   if (dwarf_version < 5)\n@@ -11362,7 +11362,7 @@ output_comdat_type_unit (comdat_type_node *node,\n   output_compilation_unit_header (dwarf_split_debug_info\n \t\t\t\t  ? DW_UT_split_type : DW_UT_type);\n   output_signature (node->signature, \"Type Signature\");\n-  dw2_asm_output_data (DWARF_OFFSET_SIZE, node->type_die->die_offset,\n+  dw2_asm_output_data (dwarf_offset_size, node->type_die->die_offset,\n \t\t       \"Offset to Type DIE\");\n   output_die (node->root_die);\n \n@@ -11491,7 +11491,7 @@ output_pubname (dw_offset die_offset, pubname_entry *entry)\n   dw_die_ref die = entry->die;\n   int is_static = get_AT_flag (die, DW_AT_external) ? 0 : 1;\n \n-  dw2_asm_output_data (DWARF_OFFSET_SIZE, die_offset, \"DIE offset\");\n+  dw2_asm_output_data (dwarf_offset_size, die_offset, \"DIE offset\");\n \n   if (debug_generate_pub_sections == 2)\n     {\n@@ -11565,25 +11565,25 @@ output_pubnames (vec<pubname_entry, va_gc> *names)\n \n   if (!XCOFF_DEBUGGING_INFO)\n     {\n-      if (DWARF_INITIAL_LENGTH_SIZE - DWARF_OFFSET_SIZE == 4)\n+      if (DWARF_INITIAL_LENGTH_SIZE - dwarf_offset_size == 4)\n \tdw2_asm_output_data (4, 0xffffffff,\n \t  \"Initial length escape value indicating 64-bit DWARF extension\");\n-      dw2_asm_output_data (DWARF_OFFSET_SIZE, pubnames_length,\n+      dw2_asm_output_data (dwarf_offset_size, pubnames_length,\n \t\t\t   \"Pub Info Length\");\n     }\n \n   /* Version number for pubnames/pubtypes is independent of dwarf version.  */\n   dw2_asm_output_data (2, 2, \"DWARF pubnames/pubtypes version\");\n \n   if (dwarf_split_debug_info)\n-    dw2_asm_output_offset (DWARF_OFFSET_SIZE, debug_skeleton_info_section_label,\n+    dw2_asm_output_offset (dwarf_offset_size, debug_skeleton_info_section_label,\n                            debug_skeleton_info_section,\n                            \"Offset of Compilation Unit Info\");\n   else\n-    dw2_asm_output_offset (DWARF_OFFSET_SIZE, debug_info_section_label,\n+    dw2_asm_output_offset (dwarf_offset_size, debug_info_section_label,\n                            debug_info_section,\n                            \"Offset of Compilation Unit Info\");\n-  dw2_asm_output_data (DWARF_OFFSET_SIZE, next_die_offset,\n+  dw2_asm_output_data (dwarf_offset_size, next_die_offset,\n \t\t       \"Compilation Unit Length\");\n \n   FOR_EACH_VEC_ELT (*names, i, pub)\n@@ -11614,7 +11614,7 @@ output_pubnames (vec<pubname_entry, va_gc> *names)\n \t}\n     }\n \n-  dw2_asm_output_data (DWARF_OFFSET_SIZE, 0, NULL);\n+  dw2_asm_output_data (dwarf_offset_size, 0, NULL);\n }\n \n /* Output public names and types tables if necessary.  */\n@@ -11647,21 +11647,21 @@ output_aranges (void)\n   \n   if (!XCOFF_DEBUGGING_INFO)\n     {\n-      if (DWARF_INITIAL_LENGTH_SIZE - DWARF_OFFSET_SIZE == 4)\n+      if (DWARF_INITIAL_LENGTH_SIZE - dwarf_offset_size == 4)\n \tdw2_asm_output_data (4, 0xffffffff,\n \t  \"Initial length escape value indicating 64-bit DWARF extension\");\n-      dw2_asm_output_data (DWARF_OFFSET_SIZE, aranges_length,\n+      dw2_asm_output_data (dwarf_offset_size, aranges_length,\n \t\t\t   \"Length of Address Ranges Info\");\n     }\n \n   /* Version number for aranges is still 2, even up to DWARF5.  */\n   dw2_asm_output_data (2, 2, \"DWARF aranges version\");\n   if (dwarf_split_debug_info)\n-    dw2_asm_output_offset (DWARF_OFFSET_SIZE, debug_skeleton_info_section_label,\n+    dw2_asm_output_offset (dwarf_offset_size, debug_skeleton_info_section_label,\n                            debug_skeleton_info_section,\n                            \"Offset of Compilation Unit Info\");\n   else\n-    dw2_asm_output_offset (DWARF_OFFSET_SIZE, debug_info_section_label,\n+    dw2_asm_output_offset (dwarf_offset_size, debug_info_section_label,\n                            debug_info_section,\n                            \"Offset of Compilation Unit Info\");\n   dw2_asm_output_data (1, DWARF2_ADDR_SIZE, \"Size of Address\");\n@@ -11936,11 +11936,11 @@ output_rnglists (unsigned generation)\n \t\t\t       2 + generation * 4);\n   ASM_GENERATE_INTERNAL_LABEL (l2, DEBUG_RANGES_SECTION_LABEL,\n \t\t\t       3 + generation * 4);\n-  if (DWARF_INITIAL_LENGTH_SIZE - DWARF_OFFSET_SIZE == 4)\n+  if (DWARF_INITIAL_LENGTH_SIZE - dwarf_offset_size == 4)\n     dw2_asm_output_data (4, 0xffffffff,\n \t\t\t \"Initial length escape value indicating \"\n \t\t\t \"64-bit DWARF extension\");\n-  dw2_asm_output_delta (DWARF_OFFSET_SIZE, l2, l1,\n+  dw2_asm_output_delta (dwarf_offset_size, l2, l1,\n \t\t\t\"Length of Range Lists\");\n   ASM_OUTPUT_LABEL (asm_out_file, l1);\n   output_dwarf_version ();\n@@ -11959,7 +11959,7 @@ output_rnglists (unsigned generation)\n       ASM_OUTPUT_LABEL (asm_out_file, ranges_base_label);\n       FOR_EACH_VEC_SAFE_ELT (ranges_table, i, r)\n \tif (r->label)\n-\t  dw2_asm_output_delta (DWARF_OFFSET_SIZE, r->label,\n+\t  dw2_asm_output_delta (dwarf_offset_size, r->label,\n \t\t\t\tranges_base_label, NULL);\n     }\n \n@@ -12219,7 +12219,7 @@ output_line_string (enum dwarf_form form, const char *str,\n       node = find_AT_string_in_table (str, debug_line_str_hash);\n       set_indirect_string (node);\n       node->form = form;\n-      dw2_asm_output_offset (DWARF_OFFSET_SIZE, node->label,\n+      dw2_asm_output_offset (dwarf_offset_size, node->label,\n \t\t\t     debug_line_str_section, \"%s: %#x: \\\"%s\\\"\",\n \t\t\t     entry_kind, 0, node->str);\n       break;\n@@ -12728,10 +12728,10 @@ output_line_info (bool prologue_only)\n \n   if (!XCOFF_DEBUGGING_INFO)\n     {\n-      if (DWARF_INITIAL_LENGTH_SIZE - DWARF_OFFSET_SIZE == 4)\n+      if (DWARF_INITIAL_LENGTH_SIZE - dwarf_offset_size == 4)\n \tdw2_asm_output_data (4, 0xffffffff,\n \t  \"Initial length escape value indicating 64-bit DWARF extension\");\n-      dw2_asm_output_delta (DWARF_OFFSET_SIZE, l2, l1,\n+      dw2_asm_output_delta (dwarf_offset_size, l2, l1,\n \t\t\t    \"Length of Source Line Info\");\n     }\n \n@@ -12743,7 +12743,7 @@ output_line_info (bool prologue_only)\n       dw2_asm_output_data (1, DWARF2_ADDR_SIZE, \"Address Size\");\n       dw2_asm_output_data (1, 0, \"Segment Size\");\n     }\n-  dw2_asm_output_delta (DWARF_OFFSET_SIZE, p2, p1, \"Prolog Length\");\n+  dw2_asm_output_delta (dwarf_offset_size, p2, p1, \"Prolog Length\");\n   ASM_OUTPUT_LABEL (asm_out_file, p1);\n \n   /* Define the architecture-dependent minimum instruction length (in bytes).\n@@ -28208,7 +28208,7 @@ output_macinfo_op (macinfo_entry *ref)\n     case DW_MACINFO_undef:\n       len = strlen (ref->info) + 1;\n       if (!dwarf_strict\n-\t  && len > DWARF_OFFSET_SIZE\n+\t  && len > (size_t) dwarf_offset_size\n \t  && !DWARF2_INDIRECT_STRING_SUPPORT_MISSING_ON_TARGET\n \t  && (debug_str_section->common.flags & SECTION_MERGE) != 0)\n \t{\n@@ -28249,7 +28249,7 @@ output_macinfo_op (macinfo_entry *ref)\n       dw2_asm_output_data_uleb128 (ref->lineno, \"At line number %lu\",\n \t\t\t\t   (unsigned long) ref->lineno);\n       if (node->form == DW_FORM_strp)\n-        dw2_asm_output_offset (DWARF_OFFSET_SIZE, node->label,\n+        dw2_asm_output_offset (dwarf_offset_size, node->label,\n                                debug_str_section, \"The macro: \\\"%s\\\"\",\n                                ref->info);\n       else\n@@ -28261,7 +28261,7 @@ output_macinfo_op (macinfo_entry *ref)\n       ASM_GENERATE_INTERNAL_LABEL (label,\n \t\t\t\t   DEBUG_MACRO_SECTION_LABEL,\n \t\t\t\t   ref->lineno + macinfo_label_base);\n-      dw2_asm_output_offset (DWARF_OFFSET_SIZE, label, NULL, NULL);\n+      dw2_asm_output_offset (dwarf_offset_size, label, NULL, NULL);\n       break;\n     default:\n       fprintf (asm_out_file, \"%s unrecognized macinfo code %lu\\n\",\n@@ -28345,7 +28345,7 @@ optimize_macinfo_range (unsigned int idx, vec<macinfo_entry, va_gc> *files,\n   /* The group name format is: wmN.[<encoded filename>.]<lineno>.<md5sum>  */\n   grp_name = XALLOCAVEC (char, 4 + encoded_filename_len + linebuf_len + 1\n \t\t\t + 16 * 2 + 1);\n-  memcpy (grp_name, DWARF_OFFSET_SIZE == 4 ? \"wm4.\" : \"wm8.\", 4);\n+  memcpy (grp_name, dwarf_offset_size == 4 ? \"wm4.\" : \"wm8.\", 4);\n   tail = grp_name + 4;\n   if (encoded_filename_len)\n     {\n@@ -28416,7 +28416,7 @@ save_macinfo_strings (void)\n           case DW_MACINFO_undef:\n             len = strlen (ref->info) + 1;\n             if (!dwarf_strict\n-                && len > DWARF_OFFSET_SIZE\n+                && len > (unsigned) dwarf_offset_size\n                 && !DWARF2_INDIRECT_STRING_SUPPORT_MISSING_ON_TARGET\n                 && (debug_str_section->common.flags & SECTION_MERGE) != 0)\n               set_indirect_string (find_AT_string (ref->info));\n@@ -28469,11 +28469,11 @@ output_macinfo (const char *debug_line_label, bool early_lto_debug)\n     {\n       dw2_asm_output_data (2, dwarf_version >= 5 ? 5 : 4,\n \t\t\t   \"DWARF macro version number\");\n-      if (DWARF_OFFSET_SIZE == 8)\n+      if (dwarf_offset_size == 8)\n \tdw2_asm_output_data (1, 3, \"Flags: 64-bit, lineptr present\");\n       else\n \tdw2_asm_output_data (1, 2, \"Flags: 32-bit, lineptr present\");\n-      dw2_asm_output_offset (DWARF_OFFSET_SIZE, debug_line_label,\n+      dw2_asm_output_offset (dwarf_offset_size, debug_line_label,\n                              debug_line_section, NULL);\n     }\n \n@@ -28562,7 +28562,7 @@ output_macinfo (const char *debug_line_label, bool early_lto_debug)\n \t  ref->info = NULL;\n \t  dw2_asm_output_data (2, dwarf_version >= 5 ? 5 : 4,\n \t\t\t       \"DWARF macro version number\");\n-\t  if (DWARF_OFFSET_SIZE == 8)\n+\t  if (dwarf_offset_size == 8)\n \t    dw2_asm_output_data (1, 1, \"Flags: 64-bit\");\n \t  else\n \t    dw2_asm_output_data (1, 0, \"Flags: 32-bit\");\n@@ -28899,7 +28899,7 @@ output_index_string_offset (indirect_string_node **h, unsigned int *offset)\n       /* Assert that this node has been assigned an index.  */\n       gcc_assert (node->index != NO_INDEX_ASSIGNED\n                   && node->index != NOT_INDEXED);\n-      dw2_asm_output_data (DWARF_OFFSET_SIZE, *offset,\n+      dw2_asm_output_data (dwarf_offset_size, *offset,\n                            \"indexed string 0x%x: %s\", node->index, node->str);\n       *offset += strlen (node->str) + 1;\n     }\n@@ -28993,11 +28993,11 @@ output_indirect_strings (void)\n \n \t  debug_str_hash->traverse_noresize\n \t    <unsigned int *, count_index_strings> (&last_idx);\n-\t  str_offsets_length = last_idx * DWARF_OFFSET_SIZE + 4;\n-\t  if (DWARF_INITIAL_LENGTH_SIZE - DWARF_OFFSET_SIZE == 4)\n+\t  str_offsets_length = last_idx * dwarf_offset_size + 4;\n+\t  if (DWARF_INITIAL_LENGTH_SIZE - dwarf_offset_size == 4)\n \t    dw2_asm_output_data (4, 0xffffffff,\n \t\t\t\t \"Escape value for 64-bit DWARF extension\");\n-\t  dw2_asm_output_data (DWARF_OFFSET_SIZE, str_offsets_length,\n+\t  dw2_asm_output_data (dwarf_offset_size, str_offsets_length,\n \t\t\t       \"Length of string offsets unit\");\n \t  dw2_asm_output_data (2, 5, \"DWARF string offsets version\");\n \t  dw2_asm_output_data (2, 0, \"Header zero padding\");\n@@ -29087,10 +29087,10 @@ output_addr_table (void)\n \t<unsigned int *, count_index_addrs> (&last_idx);\n       addrs_length = last_idx * DWARF2_ADDR_SIZE + 4;\n \n-      if (DWARF_INITIAL_LENGTH_SIZE - DWARF_OFFSET_SIZE == 4)\n+      if (DWARF_INITIAL_LENGTH_SIZE - dwarf_offset_size == 4)\n \tdw2_asm_output_data (4, 0xffffffff,\n \t\t\t     \"Escape value for 64-bit DWARF extension\");\n-      dw2_asm_output_data (DWARF_OFFSET_SIZE, addrs_length,\n+      dw2_asm_output_data (dwarf_offset_size, addrs_length,\n \t\t\t   \"Length of Address Unit\");\n       dw2_asm_output_data (2, 5, \"DWARF addr version\");\n       dw2_asm_output_data (1, DWARF2_ADDR_SIZE, \"Size of Address\");\n@@ -31649,11 +31649,11 @@ dwarf2out_finish (const char *filename)\n \t{\n \t  ASM_GENERATE_INTERNAL_LABEL (l1, DEBUG_LOC_SECTION_LABEL, 2);\n \t  ASM_GENERATE_INTERNAL_LABEL (l2, DEBUG_LOC_SECTION_LABEL, 3);\n-\t  if (DWARF_INITIAL_LENGTH_SIZE - DWARF_OFFSET_SIZE == 4)\n+\t  if (DWARF_INITIAL_LENGTH_SIZE - dwarf_offset_size == 4)\n \t    dw2_asm_output_data (4, 0xffffffff,\n \t\t\t\t \"Initial length escape value indicating \"\n \t\t\t\t \"64-bit DWARF extension\");\n-\t  dw2_asm_output_delta (DWARF_OFFSET_SIZE, l2, l1,\n+\t  dw2_asm_output_delta (dwarf_offset_size, l2, l1,\n \t\t\t    \"Length of Location Lists\");\n \t  ASM_OUTPUT_LABEL (asm_out_file, l1);\n \t  output_dwarf_version ();"}]}