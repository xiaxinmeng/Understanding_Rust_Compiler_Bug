{"sha": "0b7f0f0e87a381ab6aaa84b512bf8165115c5874", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGI3ZjBmMGU4N2EzODFhYjZhYWE4NGI1MTJiZjgxNjUxMTVjNTg3NA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-02-19T11:12:05Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-02-19T11:12:05Z"}, "message": "[multiple changes]\n\n2014-02-19  Robert Dewar  <dewar@adacore.com>\n\n\t* par-ch6.adb (P_Return): For extended return, end column lines\n\tup with RETURN.\n\t* par.adb: Minor documentation clarification.\n\n2014-02-19  Yannick Moy  <moy@adacore.com>\n\n\t* sem_prag.adb (Check_Loop_Pragma_Placement): Add check\n\tthat Loop_Invariant and Loop_Variant appear consecutively.\n\t* gnat_rm.texi Update documentation of Loop_Invariant and\n\tLoop_Variant pragmas.\n\n2014-02-19  Robert Dewar  <dewar@adacore.com>\n\n\t* debug.adb: Document -gnatd.X.\n\t* par-ch5.adb (P_If_Statement): Always check THEN, even if not\n\tfirst token\n\t(Check_Then_Column): Ditto.\n\t* styleg.adb (Check_Then): Allow THEN on line after IF.\n\t(Check_Then): Check THEN placement under control of -gnatd.X\n\t* styleg.ads (Check_Then): Now called even if THEN is not first\n\ttoken on line.\n\t* stylesw.ads (Style_Check_If_Then_Layout): Document new\n\trelaxed rules.\n\t* gnat_ugn.texi: For -gnatyi, THEN can now be on line after IF.\n\n2014-02-19  Robert Dewar  <dewar@adacore.com>\n\n\t* a-cfhama.adb, a-cfhase.adb, a-cforse.adb, a-cofove.adb, a-ngcefu.adb,\n\ta-teioed.adb, a-wtedit.adb, a-ztedit.adb, exp_ch5.adb, inline.adb,\n\tprj-pp.adb, prj-tree.adb, sem_ch12.adb, sem_ch8.adb,\n\tvms_conv.adb: Fix bad layout of IF statements\n\nFrom-SVN: r207893", "tree": {"sha": "4b251dd34ac027c2b9fc4f1c8b26a9994b34fbe3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4b251dd34ac027c2b9fc4f1c8b26a9994b34fbe3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0b7f0f0e87a381ab6aaa84b512bf8165115c5874", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b7f0f0e87a381ab6aaa84b512bf8165115c5874", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b7f0f0e87a381ab6aaa84b512bf8165115c5874", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b7f0f0e87a381ab6aaa84b512bf8165115c5874/comments", "author": null, "committer": null, "parents": [{"sha": "e7cff5af6f0cde046419d93873b92a9290076ef9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7cff5af6f0cde046419d93873b92a9290076ef9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7cff5af6f0cde046419d93873b92a9290076ef9"}], "stats": {"total": 417, "additions": 333, "deletions": 84}, "files": [{"sha": "9b3a28af6d0e3d17da660dbd938f981e295a5801", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b7f0f0e87a381ab6aaa84b512bf8165115c5874/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b7f0f0e87a381ab6aaa84b512bf8165115c5874/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=0b7f0f0e87a381ab6aaa84b512bf8165115c5874", "patch": "@@ -1,3 +1,37 @@\n+2014-02-19  Robert Dewar  <dewar@adacore.com>\n+\n+\t* par-ch6.adb (P_Return): For extended return, end column lines\n+\tup with RETURN.\n+\t* par.adb: Minor documentation clarification.\n+\n+2014-02-19  Yannick Moy  <moy@adacore.com>\n+\n+\t* sem_prag.adb (Check_Loop_Pragma_Placement): Add check\n+\tthat Loop_Invariant and Loop_Variant appear consecutively.\n+\t* gnat_rm.texi Update documentation of Loop_Invariant and\n+\tLoop_Variant pragmas.\n+\n+2014-02-19  Robert Dewar  <dewar@adacore.com>\n+\n+\t* debug.adb: Document -gnatd.X.\n+\t* par-ch5.adb (P_If_Statement): Always check THEN, even if not\n+\tfirst token\n+\t(Check_Then_Column): Ditto.\n+\t* styleg.adb (Check_Then): Allow THEN on line after IF.\n+\t(Check_Then): Check THEN placement under control of -gnatd.X\n+\t* styleg.ads (Check_Then): Now called even if THEN is not first\n+\ttoken on line.\n+\t* stylesw.ads (Style_Check_If_Then_Layout): Document new\n+\trelaxed rules.\n+\t* gnat_ugn.texi: For -gnatyi, THEN can now be on line after IF.\n+\n+2014-02-19  Robert Dewar  <dewar@adacore.com>\n+\n+\t* a-cfhama.adb, a-cfhase.adb, a-cforse.adb, a-cofove.adb, a-ngcefu.adb,\n+\ta-teioed.adb, a-wtedit.adb, a-ztedit.adb, exp_ch5.adb, inline.adb,\n+\tprj-pp.adb, prj-tree.adb, sem_ch12.adb, sem_ch8.adb,\n+\tvms_conv.adb: Fix bad layout of IF statements\n+\n 2014-02-19  Robert Dewar  <dewar@adacore.com>\n \n \t* exp_util.adb (Side_Effect_Free): Scalar if expressions can be SEF."}, {"sha": "365221259e585de28e95d65864ce55718f7606b0", "filename": "gcc/ada/a-cfhama.adb", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b7f0f0e87a381ab6aaa84b512bf8165115c5874/gcc%2Fada%2Fa-cfhama.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b7f0f0e87a381ab6aaa84b512bf8165115c5874/gcc%2Fada%2Fa-cfhama.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfhama.adb?ref=0b7f0f0e87a381ab6aaa84b512bf8165115c5874", "patch": "@@ -459,12 +459,13 @@ package body Ada.Containers.Formal_Hashed_Maps is\n \n    function Has_Element (Container : Map; Position : Cursor) return Boolean is\n    begin\n-      if Position.Node = 0 or else\n-        not Container.Nodes (Position.Node).Has_Element then\n+      if Position.Node = 0\n+        or else not Container.Nodes (Position.Node).Has_Element\n+      then\n          return False;\n+      else\n+         return True;\n       end if;\n-\n-      return True;\n    end Has_Element;\n \n    ---------------\n@@ -858,12 +859,12 @@ package body Ada.Containers.Formal_Hashed_Maps is\n          return False;\n       end if;\n \n-      while CuL.Node /= 0 or CuR.Node /= 0 loop\n-         if CuL.Node /= CuR.Node or else\n-           (Left.Nodes (CuL.Node).Element /=\n-              Right.Nodes (CuR.Node).Element or\n-              Left.Nodes (CuL.Node).Key /=\n-              Right.Nodes (CuR.Node).Key) then\n+      while CuL.Node /= 0 or else CuR.Node /= 0 loop\n+         if CuL.Node /= CuR.Node\n+           or else\n+             Left.Nodes (CuL.Node).Element /= Right.Nodes (CuR.Node).Element\n+           or else Left.Nodes (CuL.Node).Key /= Right.Nodes (CuR.Node).Key\n+         then\n             return False;\n          end if;\n "}, {"sha": "398fa774f75b2cd555413889ffddbf6112ee7452", "filename": "gcc/ada/a-cfhase.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b7f0f0e87a381ab6aaa84b512bf8165115c5874/gcc%2Fada%2Fa-cfhase.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b7f0f0e87a381ab6aaa84b512bf8165115c5874/gcc%2Fada%2Fa-cfhase.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfhase.adb?ref=0b7f0f0e87a381ab6aaa84b512bf8165115c5874", "patch": "@@ -474,8 +474,9 @@ package body Ada.Containers.Formal_Hashed_Sets is\n                return False;\n             end if;\n \n-            if Equivalent_Elements (L_Node.Element,\n-                                    RN (R_Node).Element) then\n+            if Equivalent_Elements\n+                 (L_Node.Element, RN (R_Node).Element)\n+            then\n                return True;\n             end if;\n "}, {"sha": "9064e7ba0c6a7c99cc7711fa09c75baad8eaf3b5", "filename": "gcc/ada/a-cforse.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b7f0f0e87a381ab6aaa84b512bf8165115c5874/gcc%2Fada%2Fa-cforse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b7f0f0e87a381ab6aaa84b512bf8165115c5874/gcc%2Fada%2Fa-cforse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cforse.adb?ref=0b7f0f0e87a381ab6aaa84b512bf8165115c5874", "patch": "@@ -1454,8 +1454,7 @@ package body Ada.Containers.Formal_Ordered_Sets is\n             return True;\n          end if;\n \n-         if Left.Nodes (LNode).Element /=\n-           Right.Nodes (RNode).Element then\n+         if Left.Nodes (LNode).Element /= Right.Nodes (RNode).Element then\n             exit;\n          end if;\n "}, {"sha": "d76055cc341f58b4aee75fe0924d2148eca69822", "filename": "gcc/ada/a-cofove.adb", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b7f0f0e87a381ab6aaa84b512bf8165115c5874/gcc%2Fada%2Fa-cofove.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b7f0f0e87a381ab6aaa84b512bf8165115c5874/gcc%2Fada%2Fa-cofove.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofove.adb?ref=0b7f0f0e87a381ab6aaa84b512bf8165115c5874", "patch": "@@ -1281,8 +1281,9 @@ package body Ada.Containers.Formal_Vectors is\n          return;\n       end if;\n \n-      if Position.Index > Index_Type'First and\n-        Position.Index <= Last_Index (Container) then\n+      if Position.Index > Index_Type'First\n+        and then Position.Index <= Last_Index (Container)\n+      then\n          Position.Index := Position.Index - 1;\n       else\n          Position := No_Element;\n@@ -1295,8 +1296,9 @@ package body Ada.Containers.Formal_Vectors is\n          return No_Element;\n       end if;\n \n-      if Position.Index > Index_Type'First and\n-        Position.Index <= Last_Index (Container) then\n+      if Position.Index > Index_Type'First\n+        and then Position.Index <= Last_Index (Container)\n+      then\n          return (True, Position.Index - 1);\n       end if;\n "}, {"sha": "87a1dc9e1604d6a646851b72924774be4ecdd00d", "filename": "gcc/ada/a-ngcefu.adb", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b7f0f0e87a381ab6aaa84b512bf8165115c5874/gcc%2Fada%2Fa-ngcefu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b7f0f0e87a381ab6aaa84b512bf8165115c5874/gcc%2Fada%2Fa-ngcefu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ngcefu.adb?ref=0b7f0f0e87a381ab6aaa84b512bf8165115c5874", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -541,8 +541,10 @@ package body Ada.Numerics.Generic_Complex_Elementary_Functions is\n \n    function Sin (X : Complex) return Complex is\n    begin\n-      if abs Re (X) < Square_Root_Epsilon and then\n-         abs Im (X) < Square_Root_Epsilon then\n+      if abs Re (X) < Square_Root_Epsilon\n+           and then\n+         abs Im (X) < Square_Root_Epsilon\n+      then\n          return X;\n       end if;\n "}, {"sha": "734917940fb78fbf8b6844120868d512d789462c", "filename": "gcc/ada/a-teioed.adb", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b7f0f0e87a381ab6aaa84b512bf8165115c5874/gcc%2Fada%2Fa-teioed.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b7f0f0e87a381ab6aaa84b512bf8165115c5874/gcc%2Fada%2Fa-teioed.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-teioed.adb?ref=0b7f0f0e87a381ab6aaa84b512bf8165115c5874", "patch": "@@ -629,8 +629,9 @@ package body Ada.Text_IO.Editing is\n       end if;\n \n       for J in Position .. Answer'Last loop\n-         if Pic.Start_Currency /= Invalid_Position and then\n-            Answer (Pic.Start_Currency) = '#' then\n+         if Pic.Start_Currency /= Invalid_Position\n+           and then Answer (Pic.Start_Currency) = '#'\n+         then\n             Currency_Pos := 1;\n          end if;\n \n@@ -705,8 +706,9 @@ package body Ada.Text_IO.Editing is\n             Last := Last - 1 + Currency_Symbol'Length;\n          end if;\n \n-         if Pic.Radix_Position /= Invalid_Position and then\n-            Answer (Pic.Radix_Position) = 'V' then\n+         if Pic.Radix_Position /= Invalid_Position\n+           and then Answer (Pic.Radix_Position) = 'V'\n+         then\n             Last := Last - 1;\n          end if;\n "}, {"sha": "4524f7ff6ccb3d62857c2e8bc1aab702f7c1aae9", "filename": "gcc/ada/a-wtedit.adb", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b7f0f0e87a381ab6aaa84b512bf8165115c5874/gcc%2Fada%2Fa-wtedit.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b7f0f0e87a381ab6aaa84b512bf8165115c5874/gcc%2Fada%2Fa-wtedit.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-wtedit.adb?ref=0b7f0f0e87a381ab6aaa84b512bf8165115c5874", "patch": "@@ -792,8 +792,9 @@ package body Ada.Wide_Text_IO.Editing is\n       end if;\n \n       for J in Position .. Answer'Last loop\n-         if Pic.Start_Currency /= Invalid_Position and then\n-            Answer (Pic.Start_Currency) = '#' then\n+         if Pic.Start_Currency /= Invalid_Position\n+           and then Answer (Pic.Start_Currency) = '#'\n+         then\n             Currency_Pos := 1;\n          end if;\n \n@@ -860,8 +861,9 @@ package body Ada.Wide_Text_IO.Editing is\n             Last := Last - 1 + Currency_Symbol'Length;\n          end if;\n \n-         if Pic.Radix_Position /= Invalid_Position and then\n-            Answer (Pic.Radix_Position) = 'V' then\n+         if Pic.Radix_Position /= Invalid_Position\n+           and then Answer (Pic.Radix_Position) = 'V'\n+         then\n             Last := Last - 1;\n          end if;\n "}, {"sha": "5c7c9b4c3ddd29fddcbaa307da789f9dde4ad87f", "filename": "gcc/ada/a-ztedit.adb", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b7f0f0e87a381ab6aaa84b512bf8165115c5874/gcc%2Fada%2Fa-ztedit.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b7f0f0e87a381ab6aaa84b512bf8165115c5874/gcc%2Fada%2Fa-ztedit.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ztedit.adb?ref=0b7f0f0e87a381ab6aaa84b512bf8165115c5874", "patch": "@@ -793,8 +793,9 @@ package body Ada.Wide_Wide_Text_IO.Editing is\n       end if;\n \n       for J in Position .. Answer'Last loop\n-         if Pic.Start_Currency /= Invalid_Position and then\n-            Answer (Pic.Start_Currency) = '#' then\n+         if Pic.Start_Currency /= Invalid_Position\n+           and then Answer (Pic.Start_Currency) = '#'\n+         then\n             Currency_Pos := 1;\n          end if;\n \n@@ -861,8 +862,9 @@ package body Ada.Wide_Wide_Text_IO.Editing is\n             Last := Last - 1 + Currency_Symbol'Length;\n          end if;\n \n-         if Pic.Radix_Position /= Invalid_Position and then\n-            Answer (Pic.Radix_Position) = 'V' then\n+         if Pic.Radix_Position /= Invalid_Position\n+           and then Answer (Pic.Radix_Position) = 'V'\n+         then\n             Last := Last - 1;\n          end if;\n "}, {"sha": "2ab5735329ef1752c37ba643c1ef1d8e6df1fdba", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b7f0f0e87a381ab6aaa84b512bf8165115c5874/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b7f0f0e87a381ab6aaa84b512bf8165115c5874/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=0b7f0f0e87a381ab6aaa84b512bf8165115c5874", "patch": "@@ -141,7 +141,7 @@ package body Debug is\n    --  d.U  Ignore indirect calls for static elaboration\n    --  d.V\n    --  d.W  Print out debugging information for Walk_Library_Items\n-   --  d.X\n+   --  d.X  Activate check on THEN appearing in wrong place\n    --  d.Y\n    --  d.Z\n \n@@ -664,6 +664,10 @@ package body Debug is\n    --       the order in which units are walked. This is primarily for use in\n    --       debugging CodePeer mode.\n \n+   --  d.X  Activates check for proper placement of THEN in -gnatyi mode. A\n+   --       THEN keyword must appear on the same line as IF, or on a separate\n+   --       line all on its own, lined up with the IF.\n+\n    --  d1   Error messages have node numbers where possible. Normally error\n    --       messages have only source locations. This option is useful when\n    --       debugging errors caused by expanded code, where the source location"}, {"sha": "823e76e4fc46bc451cb06013bcaf09fc1d5d26e0", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b7f0f0e87a381ab6aaa84b512bf8165115c5874/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b7f0f0e87a381ab6aaa84b512bf8165115c5874/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=0b7f0f0e87a381ab6aaa84b512bf8165115c5874", "patch": "@@ -1933,7 +1933,8 @@ package body Exp_Ch5 is\n \n       if Is_Access_Type (Typ)\n         and then Is_Entity_Name (Lhs)\n-        and then Present (Effective_Extra_Accessibility (Entity (Lhs))) then\n+        and then Present (Effective_Extra_Accessibility (Entity (Lhs)))\n+      then\n          declare\n             function Lhs_Entity return Entity_Id;\n             --  Look through renames to find the underlying entity."}, {"sha": "eff462fee609f825189beb0a0d8a8af4a55bb454", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b7f0f0e87a381ab6aaa84b512bf8165115c5874/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b7f0f0e87a381ab6aaa84b512bf8165115c5874/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=0b7f0f0e87a381ab6aaa84b512bf8165115c5874", "patch": "@@ -4348,11 +4348,17 @@ except that in an @code{Assertion_Policy} pragma, the identifier\n (or disabled).\n \n @code{Loop_Invariant} can only appear as one of the items in the sequence\n-of statements of a loop body. The intention is that it be used to\n+of statements of a loop body, or nested inside block statements that\n+appear in the sequence of statements of a loop body.\n+The intention is that it be used to\n represent a \"loop invariant\" assertion, i.e. something that is true each\n time through the loop, and which can be used to show that the loop is\n achieving its purpose.\n \n+Multiple @code{Loop_Invariant} and @code{Loop_Variant} pragmas that\n+apply to the same loop should be grouped in the same sequence of\n+statements, with only the same pragmas in between.\n+\n To aid in writing such invariants, the special attribute @code{Loop_Entry}\n may be used to refer to the value of an expression on entry to the loop. This\n attribute can only be used within the expression of a @code{Loop_Invariant}\n@@ -4420,8 +4426,10 @@ CHANGE_DIRECTION ::= Increases | Decreases\n @end smallexample\n \n @noindent\n-This pragma must appear immediately within the sequence of statements of a\n-loop statement. It allows the specification of quantities which must always\n+@code{Loop_Variant} can only appear as one of the items in the sequence\n+of statements of a loop body, or nested inside block statements that\n+appear in the sequence of statements of a loop body.\n+It allows the specification of quantities which must always\n decrease or increase in successive iterations of the loop. In its simplest\n form, just one expression is specified, whose value must increase or decrease\n on each iteration of the loop.\n@@ -4446,6 +4454,10 @@ to ignore the check (in which case the pragma has no effect on the program),\n or @code{Disable} in which case the pragma is not even checked for correct\n syntax.\n \n+Multiple @code{Loop_Invariant} and @code{Loop_Variant} pragmas that\n+apply to the same loop should be grouped in the same sequence of\n+statements, with only the same pragmas in between.\n+\n The @code{Loop_Entry} attribute may be used within the expressions of the\n @code{Loop_Variant} pragma to refer to values on entry to the loop.\n "}, {"sha": "b97ece0fd96f83b9b9c33b5dcda5f31685dc362d", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b7f0f0e87a381ab6aaa84b512bf8165115c5874/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b7f0f0e87a381ab6aaa84b512bf8165115c5874/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=0b7f0f0e87a381ab6aaa84b512bf8165115c5874", "patch": "@@ -6353,8 +6353,7 @@ source tokens.\n @emph{Check if-then layout.}\n The keyword @code{then} must appear either on the same\n line as corresponding @code{if}, or on a line on its own, lined\n-up under the @code{if} with at least one non-blank line in between\n-containing all or part of the condition to be tested.\n+up under the @code{if}.\n \n @item ^I^IN_MODE^\n @emph{check mode IN keywords.}"}, {"sha": "99e73e13a099cb21fde9f17e84542ef88690e7c2", "filename": "gcc/ada/inline.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b7f0f0e87a381ab6aaa84b512bf8165115c5874/gcc%2Fada%2Finline.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b7f0f0e87a381ab6aaa84b512bf8165115c5874/gcc%2Fada%2Finline.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finline.adb?ref=0b7f0f0e87a381ab6aaa84b512bf8165115c5874", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1160,7 +1160,8 @@ package body Inline is\n \n          elsif Ekind (Scop) = E_Task_Type\n            or else Ekind (Scop) = E_Entry\n-           or else Ekind (Scop) = E_Entry_Family then\n+           or else Ekind (Scop) = E_Entry_Family\n+         then\n             return True;\n          end if;\n "}, {"sha": "517e58a3d4e970b23a8798b03039424f54a532a3", "filename": "gcc/ada/par-ch5.adb", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b7f0f0e87a381ab6aaa84b512bf8165115c5874/gcc%2Fada%2Fpar-ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b7f0f0e87a381ab6aaa84b512bf8165115c5874/gcc%2Fada%2Fpar-ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch5.adb?ref=0b7f0f0e87a381ab6aaa84b512bf8165115c5874", "patch": "@@ -1103,8 +1103,7 @@ package body Ch5 is\n       procedure Check_Then_Column;\n       --  This procedure carries out the style checks for a THEN token\n       --  Note that the caller has set Loc to the Source_Ptr value for\n-      --  the previous IF or ELSIF token. These checks apply only to a\n-      --  THEN at the start of a line.\n+      --  the previous IF or ELSIF token.\n \n       function Else_Should_Be_Elsif return Boolean;\n       --  An internal routine used to do a special error recovery check when\n@@ -1142,7 +1141,7 @@ package body Ch5 is\n \n       procedure Check_Then_Column is\n       begin\n-         if Token_Is_At_Start_Of_Line and then Token = Tok_Then then\n+         if Token = Tok_Then then\n             Check_If_Column;\n \n             if Style_Check then"}, {"sha": "5307f851d836c620b34889579101efd1250fb32f", "filename": "gcc/ada/par-ch6.adb", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b7f0f0e87a381ab6aaa84b512bf8165115c5874/gcc%2Fada%2Fpar-ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b7f0f0e87a381ab6aaa84b512bf8165115c5874/gcc%2Fada%2Fpar-ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch6.adb?ref=0b7f0f0e87a381ab6aaa84b512bf8165115c5874", "patch": "@@ -1828,9 +1828,9 @@ package body Ch6 is\n       --  The caller has checked that the initial token is RETURN\n \n       function Is_Simple return Boolean;\n-      --  Scan state is just after RETURN (and is left that way).\n-      --  Determine whether this is a simple or extended return statement\n-      --  by looking ahead for \"identifier :\", which implies extended.\n+      --  Scan state is just after RETURN (and is left that way). Determine\n+      --  whether this is a simple or extended return statement by looking\n+      --  ahead for \"identifier :\", which implies extended.\n \n       ---------------\n       -- Is_Simple --\n@@ -1855,8 +1855,9 @@ package body Ch6 is\n          return Result;\n       end Is_Simple;\n \n-      Return_Sloc : constant Source_Ptr := Token_Ptr;\n-      Return_Node : Node_Id;\n+      Ret_Sloc : constant Source_Ptr := Token_Ptr;\n+      Ret_Strt : constant Column_Number := Start_Column;\n+      Ret_Node : Node_Id;\n \n    --  Start of processing for P_Return_Statement\n \n@@ -1868,7 +1869,7 @@ package body Ch6 is\n \n       if Token = Tok_Semicolon then\n          Scan; -- past ;\n-         Return_Node := New_Node (N_Simple_Return_Statement, Return_Sloc);\n+         Ret_Node := New_Node (N_Simple_Return_Statement, Ret_Sloc);\n \n       --  Non-trivial case\n \n@@ -1880,10 +1881,10 @@ package body Ch6 is\n          --  message is probably that we have a missing semicolon.\n \n          if Is_Simple then\n-            Return_Node := New_Node (N_Simple_Return_Statement, Return_Sloc);\n+            Ret_Node := New_Node (N_Simple_Return_Statement, Ret_Sloc);\n \n             if Token not in Token_Class_Eterm then\n-               Set_Expression (Return_Node, P_Expression_No_Right_Paren);\n+               Set_Expression (Ret_Node, P_Expression_No_Right_Paren);\n             end if;\n \n          --  Extended_return_statement (Ada 2005 only -- AI-318):\n@@ -1895,19 +1896,19 @@ package body Ch6 is\n                Error_Msg_SP (\"\\unit must be compiled with -gnat05 switch\");\n             end if;\n \n-            Return_Node := New_Node (N_Extended_Return_Statement, Return_Sloc);\n+            Ret_Node := New_Node (N_Extended_Return_Statement, Ret_Sloc);\n             Set_Return_Object_Declarations\n-              (Return_Node, New_List (P_Return_Object_Declaration));\n+              (Ret_Node, New_List (P_Return_Object_Declaration));\n \n             if Token = Tok_Do then\n                Push_Scope_Stack;\n                Scope.Table (Scope.Last).Etyp := E_Return;\n-               Scope.Table (Scope.Last).Ecol := Start_Column;\n-               Scope.Table (Scope.Last).Sloc := Return_Sloc;\n+               Scope.Table (Scope.Last).Ecol := Ret_Strt;\n+               Scope.Table (Scope.Last).Sloc := Ret_Sloc;\n \n                Scan; -- past DO\n                Set_Handled_Statement_Sequence\n-                 (Return_Node, P_Handled_Sequence_Of_Statements);\n+                 (Ret_Node, P_Handled_Sequence_Of_Statements);\n                End_Statements;\n \n                --  Do we need to handle Error_Resync here???\n@@ -1917,7 +1918,7 @@ package body Ch6 is\n          TF_Semicolon;\n       end if;\n \n-      return Return_Node;\n+      return Ret_Node;\n    end P_Return_Statement;\n \n end Ch6;"}, {"sha": "fc5e6ad402e8d2d3b81a94f9023cbf923c493504", "filename": "gcc/ada/par.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b7f0f0e87a381ab6aaa84b512bf8165115c5874/gcc%2Fada%2Fpar.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b7f0f0e87a381ab6aaa84b512bf8165115c5874/gcc%2Fada%2Fpar.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar.adb?ref=0b7f0f0e87a381ab6aaa84b512bf8165115c5874", "patch": "@@ -467,7 +467,7 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n       --  expected column of the end assuming normal Ada indentation usage. If\n       --  the RM_Column_Check mode is set, this value is used for generating\n       --  error messages about indentation. Otherwise it is used only to\n-      --  control heuristic error recovery actions.\n+      --  control heuristic error recovery actions. This value is zero origin.\n \n       Labl : Node_Id;\n       --  This field is used to provide the name of the construct being parsed"}, {"sha": "15e3dcf651ed304faf7218767e1321561d58fd9b", "filename": "gcc/ada/prj-pp.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b7f0f0e87a381ab6aaa84b512bf8165115c5874/gcc%2Fada%2Fprj-pp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b7f0f0e87a381ab6aaa84b512bf8165115c5874/gcc%2Fada%2Fprj-pp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-pp.adb?ref=0b7f0f0e87a381ab6aaa84b512bf8165115c5874", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2001-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2001-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -280,7 +280,8 @@ package body Prj.PP is\n       procedure Write_Empty_Line (Always : Boolean := False) is\n       begin\n          if (Always or else not Minimize_Empty_Lines)\n-           and then not Last_Line_Is_Empty then\n+           and then not Last_Line_Is_Empty\n+         then\n             Write_Eol.all;\n             Column := 0;\n             Last_Line_Is_Empty := True;"}, {"sha": "b831ea0c6ba373a3a002bb93d4d2da89be5197eb", "filename": "gcc/ada/prj-tree.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b7f0f0e87a381ab6aaa84b512bf8165115c5874/gcc%2Fada%2Fprj-tree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b7f0f0e87a381ab6aaa84b512bf8165115c5874/gcc%2Fada%2Fprj-tree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-tree.adb?ref=0b7f0f0e87a381ab6aaa84b512bf8165115c5874", "patch": "@@ -1679,13 +1679,15 @@ package body Prj.Tree is\n                Empty_Line := False;\n \n             when others =>\n+\n                --  If there are comments, where the first comment is not\n                --  following an empty line, put the initial uninterrupted\n                --  comment zone with the node of the preceding line (either\n                --  a Previous_Line or a Previous_End node), if any.\n \n                if Comments.Last > 0 and then\n-                 not Comments.Table (1).Follows_Empty_Line then\n+                 not Comments.Table (1).Follows_Empty_Line\n+               then\n                   if Present (Previous_Line_Node) then\n                      Add_Comments\n                        (To      => Previous_Line_Node,"}, {"sha": "0cd00c7ef03ae0f946f1fce47b4e2b3745f836c9", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b7f0f0e87a381ab6aaa84b512bf8165115c5874/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b7f0f0e87a381ab6aaa84b512bf8165115c5874/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=0b7f0f0e87a381ab6aaa84b512bf8165115c5874", "patch": "@@ -10638,8 +10638,7 @@ package body Sem_Ch12 is\n             Desig_Act := Available_View (Desig_Act);\n          end if;\n \n-         if not Subtypes_Match\n-           (Desig_Type, Desig_Act) then\n+         if not Subtypes_Match (Desig_Type, Desig_Act) then\n             Error_Msg_NE\n               (\"designated type of actual does not match that of formal &\",\n                  Actual, Gen_T);"}, {"sha": "b3721f2009a90bf7d124c16ab2445ef810a6ff01", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b7f0f0e87a381ab6aaa84b512bf8165115c5874/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b7f0f0e87a381ab6aaa84b512bf8165115c5874/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=0b7f0f0e87a381ab6aaa84b512bf8165115c5874", "patch": "@@ -4587,7 +4587,8 @@ package body Sem_Ch8 is\n                   Get_Name_String (Chars (Lit));\n \n                   if Chars (Lit) /= Chars (N)\n-                    and then Is_Bad_Spelling_Of (Chars (N), Chars (Lit)) then\n+                    and then Is_Bad_Spelling_Of (Chars (N), Chars (Lit))\n+                  then\n                      Error_Msg_Node_2 := Lit;\n                      Error_Msg_N -- CODEFIX\n                        (\"& is undefined, assume misspelling of &\", N);"}, {"sha": "a554e84d2a20ee5f32842fb92431df990eaa3bad", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 175, "deletions": 4, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b7f0f0e87a381ab6aaa84b512bf8165115c5874/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b7f0f0e87a381ab6aaa84b512bf8165115c5874/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=0b7f0f0e87a381ab6aaa84b512bf8165115c5874", "patch": "@@ -3104,7 +3104,9 @@ package body Sem_Prag is\n \n       procedure Check_Loop_Pragma_Placement;\n       --  Verify whether pragma Loop_Invariant or Loop_Optimize or Loop_Variant\n-      --  appear immediately within a construct restricted to loops.\n+      --  appear immediately within a construct restricted to loops, and that\n+      --  pragmas Loop_Invariant and Loop_Variant applying to the same loop all\n+      --  appear grouped in the same sequence of statements.\n \n       procedure Check_Is_In_Decl_Part_Or_Package_Spec;\n       --  Check that pragma appears in a declarative part, or in a package\n@@ -4580,6 +4582,11 @@ package body Sem_Prag is\n          --  encountered an illegal relation between enclosing constructs. Emit\n          --  an error depending on what Constr was.\n \n+         function Prev_In_Loop (Stmt : Node_Id) return Node_Id;\n+         --  Returns the statement or declaration preceding Stmt in the\n+         --  same loop, or Empty if the head of the loop is reached. Block\n+         --  statements are entered during this traversal.\n+\n          ---------------------\n          -- Placement_Error --\n          ---------------------\n@@ -4605,14 +4612,111 @@ package body Sem_Prag is\n             end if;\n          end Placement_Error;\n \n+         ------------------\n+         -- Prev_In_Loop --\n+         ------------------\n+\n+         function Prev_In_Loop (Stmt : Node_Id) return Node_Id is\n+            Prev : Node_Id;\n+            Reach_Inside_Blocks : Boolean;\n+\n+         begin\n+            Reach_Inside_Blocks := True;\n+\n+            --  Try the previous statement in the same list\n+\n+            Prev := Nlists.Prev (Stmt);\n+\n+            --  Otherwise reach to the previous statement through the parent\n+\n+            if No (Prev) then\n+\n+               --  If we're inside the statements of a block which contains\n+               --  declarations, continue with the last declaration of the\n+               --  block if any.\n+\n+               if Nkind (Parent (Stmt)) = N_Handled_Sequence_Of_Statements\n+                 and then Nkind (Parent (Parent (Stmt))) = N_Block_Statement\n+                 and then Present (Declarations (Parent (Parent (Stmt))))\n+               then\n+                  Prev := Last (Declarations (Parent (Parent (Stmt))));\n+\n+               --  Ignore a handled statement sequence\n+\n+               elsif\n+                 Nkind (Parent (Stmt)) = N_Handled_Sequence_Of_Statements\n+               then\n+                  Reach_Inside_Blocks := False;\n+                  Prev := Parent (Parent (Stmt));\n+\n+               --  Do not reach past the head of the current loop\n+\n+               elsif Nkind (Parent (Stmt)) = N_Loop_Statement then\n+                  null;\n+\n+               --  Otherwise use the parent statement\n+\n+               else\n+                  Reach_Inside_Blocks := False;\n+                  Prev := Parent (Stmt);\n+               end if;\n+            end if;\n+\n+            --  Skip block statements\n+\n+            while Nkind (Prev) = N_Block_Statement loop\n+\n+               --  If a block is reached from statements that follow it, then\n+               --  we should reach inside the block to its last contained\n+               --  statement.\n+\n+               if Reach_Inside_Blocks then\n+                  Prev :=\n+                    Last (Statements (Handled_Statement_Sequence (Prev)));\n+\n+               --  If a block is reached from statements and declarations\n+               --  inside it, continue with the statements preceding the\n+               --  block if any.\n+\n+               elsif Present (Nlists.Prev (Prev)) then\n+                  Reach_Inside_Blocks := True;\n+                  Prev := Nlists.Prev (Prev);\n+\n+               --  Ignore a handled statement sequence\n+\n+               elsif\n+                 Nkind (Parent (Prev)) = N_Handled_Sequence_Of_Statements\n+               then\n+                  Prev := Parent (Parent (Prev));\n+\n+               --  Do not reach past the head of the current loop\n+\n+               elsif Nkind (Parent (Prev)) = N_Loop_Statement then\n+                  Prev := Empty;\n+\n+               --  Otherwise use the parent statement\n+\n+               else\n+                  Prev := Parent (Prev);\n+               end if;\n+            end loop;\n+\n+            return Prev;\n+         end Prev_In_Loop;\n+\n          --  Local declarations\n \n-         Prev : Node_Id;\n-         Stmt : Node_Id;\n+         Prev                 : Node_Id;\n+         Stmt                 : Node_Id;\n+         Orig_Stmt            : Node_Id;\n+         Within_Same_Sequence : Boolean;\n \n       --  Start of processing for Check_Loop_Pragma_Placement\n \n       begin\n+         --  Check that pragma appears immediately within a loop statement,\n+         --  ignoring intervening block statements.\n+\n          Prev := N;\n          Stmt := Parent (N);\n          while Present (Stmt) loop\n@@ -4649,7 +4753,7 @@ package body Sem_Prag is\n                --  Stop the traversal because we reached the innermost loop\n                --  regardless of whether we encountered an error or not.\n \n-               return;\n+               exit;\n \n             --  Ignore a handled statement sequence. Note that this node may\n             --  be related to a subprogram body in which case we will emit an\n@@ -4666,6 +4770,73 @@ package body Sem_Prag is\n                return;\n             end if;\n          end loop;\n+\n+         --  For a Loop_Invariant or Loop_Variant pragma, check that previous\n+         --  Loop_Invariant and Loop_Variant pragmas for the same loop appear\n+         --  in the same sequence of statements, with only intervening similar\n+         --  pragmas.\n+\n+         if Prag_Id = Pragma_Loop_Invariant\n+              or else\n+            Prag_Id = Pragma_Loop_Variant\n+         then\n+            Stmt := Prev_In_Loop (N);\n+            Within_Same_Sequence := True;\n+\n+            while Present (Stmt) loop\n+\n+               --  The pragma may have been rewritten as a null statement if\n+               --  assertions are not enabled, in which case the original node\n+               --  should be used.\n+\n+               Orig_Stmt := Original_Node (Stmt);\n+\n+               --  Issue an error on a non-consecutive Loop_Invariant or\n+               --  Loop_Variant pragma.\n+\n+               if Nkind (Orig_Stmt) = N_Pragma then\n+                  declare\n+                     Stmt_Prag_Id : constant Pragma_Id :=\n+                                      Get_Pragma_Id (Pragma_Name (Orig_Stmt));\n+\n+                  begin\n+                     if Stmt_Prag_Id = Pragma_Loop_Invariant\n+                          or else\n+                        Stmt_Prag_Id = Pragma_Loop_Variant\n+                     then\n+                        if List_Containing (Stmt) /= List_Containing (N)\n+                          or else not Within_Same_Sequence\n+                        then\n+                           Error_Msg_Sloc := Sloc (Orig_Stmt);\n+                           Error_Pragma\n+                             (\"pragma% must appear immediately after pragma#\");\n+\n+                        --  Continue searching for previous Loop_Invariant and\n+                        --  Loop_Variant pragmas even after finding a previous\n+                        --  correct pragma, so that an error is also issued\n+                        --  for the current pragma in case there is a previous\n+                        --  non-consecutive pragma.\n+\n+                        else\n+                           null;\n+                        end if;\n+\n+                     --  Mark the end of the consecutive sequence of pragmas\n+\n+                     else\n+                        Within_Same_Sequence := False;\n+                     end if;\n+                  end;\n+\n+               --  Mark the end of the consecutive sequence of pragmas\n+\n+               else\n+                  Within_Same_Sequence := False;\n+               end if;\n+\n+               Stmt := Prev_In_Loop (Stmt);\n+            end loop;\n+         end if;\n       end Check_Loop_Pragma_Placement;\n \n       -------------------------------------------"}, {"sha": "67af2fcc58ac5191b47ed56d45d82a828e6e01a2", "filename": "gcc/ada/styleg.adb", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b7f0f0e87a381ab6aaa84b512bf8165115c5874/gcc%2Fada%2Fstyleg.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b7f0f0e87a381ab6aaa84b512bf8165115c5874/gcc%2Fada%2Fstyleg.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fstyleg.adb?ref=0b7f0f0e87a381ab6aaa84b512bf8165115c5874", "patch": "@@ -30,6 +30,7 @@\n with Atree;    use Atree;\n with Casing;   use Casing;\n with Csets;    use Csets;\n+with Debug;    use Debug;\n with Einfo;    use Einfo;\n with Err_Vars; use Err_Vars;\n with Opt;      use Opt;\n@@ -1005,17 +1006,25 @@ package body Styleg is\n \n    --  In check if then layout mode (-gnatyi), we expect a THEN keyword\n    --  to appear either on the same line as the IF, or on a separate line\n-   --  after multiple conditions. In any case, it may not appear on the\n-   --  line immediately following the line with the IF.\n+   --  if the IF statement extends for more than one line.\n \n    procedure Check_Then (If_Loc : Source_Ptr) is\n    begin\n       if Style_Check_If_Then_Layout then\n-         if Get_Physical_Line_Number (Token_Ptr) =\n-            Get_Physical_Line_Number (If_Loc) + 1\n-         then\n-            Error_Msg_SC (\"(style) misplaced THEN\");\n-         end if;\n+         declare\n+            If_Line   : constant Physical_Line_Number :=\n+              Get_Physical_Line_Number (If_Loc);\n+            Then_Line : constant Physical_Line_Number :=\n+              Get_Physical_Line_Number (Token_Ptr);\n+         begin\n+            if If_Line = Then_Line then\n+               null;\n+            elsif Debug_Flag_Dot_XX\n+              and then Token_Ptr /= First_Non_Blank_Location\n+            then\n+               Error_Msg_SC (\"(style) misplaced THEN\");\n+            end if;\n+         end;\n       end if;\n    end Check_Then;\n "}, {"sha": "2369281b0f6dccbcff0f86ad6092c734883be773", "filename": "gcc/ada/styleg.ads", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b7f0f0e87a381ab6aaa84b512bf8165115c5874/gcc%2Fada%2Fstyleg.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b7f0f0e87a381ab6aaa84b512bf8165115c5874/gcc%2Fada%2Fstyleg.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fstyleg.ads?ref=0b7f0f0e87a381ab6aaa84b512bf8165115c5874", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -134,8 +134,7 @@ package Styleg is\n    procedure Check_Then (If_Loc : Source_Ptr);\n    --  Called to check that THEN and IF keywords are appropriately positioned.\n    --  The parameters show the first characters of the two keywords. This\n-   --  procedure is called only if THEN appears at the start of a line with\n-   --  Token_Ptr pointing to the THEN keyword.\n+   --  procedure is called with Token_Ptr pointing to the THEN keyword.\n \n    procedure Check_Separate_Stmt_Lines;\n    pragma Inline (Check_Separate_Stmt_Lines);"}, {"sha": "bb24f278b982f5ccb6d845cf0074f515f745a9b5", "filename": "gcc/ada/stylesw.ads", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b7f0f0e87a381ab6aaa84b512bf8165115c5874/gcc%2Fada%2Fstylesw.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b7f0f0e87a381ab6aaa84b512bf8165115c5874/gcc%2Fada%2Fstylesw.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fstylesw.ads?ref=0b7f0f0e87a381ab6aaa84b512bf8165115c5874", "patch": "@@ -127,8 +127,8 @@ package Stylesw is\n \n    Style_Check_If_Then_Layout : Boolean := False;\n    --  This can be set True by using the -gnatyi switch. If it is True, then a\n-   --  THEN keyword may not appear on the line that immediately follows the\n-   --  line containing the corresponding IF.\n+   --  THEN keyword must either appear on the same line as the IF, or on a line\n+   --  all on its own.\n    --\n    --  This permits one of two styles for IF-THEN layout. Either the IF and\n    --  THEN keywords are on the same line, where the condition is short enough,\n@@ -141,10 +141,13 @@ package Stylesw is\n    --      and then Y < Z\n    --    then\n    --\n+   --    if X > Y and then Z > 0\n+   --    then\n+   --\n    --  are allowed, but\n    --\n    --    if X > Y\n-   --    then\n+   --      and then B > C then\n    --\n    --  is not allowed.\n "}, {"sha": "fbb19e58b01a1e09c16adb7a1d5c5541be68be29", "filename": "gcc/ada/vms_conv.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b7f0f0e87a381ab6aaa84b512bf8165115c5874/gcc%2Fada%2Fvms_conv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b7f0f0e87a381ab6aaa84b512bf8165115c5874/gcc%2Fada%2Fvms_conv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fvms_conv.adb?ref=0b7f0f0e87a381ab6aaa84b512bf8165115c5874", "patch": "@@ -1784,7 +1784,9 @@ package body VMS_Conv is\n                      --  so process the compiler switch.\n \n                   elsif Command.Name.all = \"MAKE\"\n-                    or else Command.Name.all = \"CHOP\" then\n+                          or else\n+                        Command.Name.all = \"CHOP\"\n+                  then\n                      Sw :=\n                        Matching_Name\n                          (Arg (Arg'First .. SwP),"}]}