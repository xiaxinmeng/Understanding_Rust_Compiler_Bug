{"sha": "29b39d4b0e44d350a35e5f25d9faeb9f9aac38e4", "node_id": "C_kwDOANBUbNoAKDI5YjM5ZDRiMGU0NGQzNTBhMzVlNWYyNWQ5ZmFlYjlmOWFhYzM4ZTQ", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-09-15T17:16:51Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-09-15T17:16:51Z"}, "message": "libstdc++: Implement ranges::chunk_by_view from P2443R1\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/bits/ranges_algo.h (__adjacent_find_fn, adjacent_find):\n\tMove to ...\n\t* include/bits/ranges_util.h: ... here.\n\t* include/std/ranges (chunk_by_view): Define.\n\t(chunk_by_view::_Iterator): Define.\n\t(__detail::__can_chunk_by_view): Define.\n\t(_ChunkBy, chunk_by): Define.\n\t* testsuite/std/ranges/adaptors/chunk_by/1.cc: New test.", "tree": {"sha": "2ea5ad8efcff577ae06ac3dd49b45677876ea230", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2ea5ad8efcff577ae06ac3dd49b45677876ea230"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/29b39d4b0e44d350a35e5f25d9faeb9f9aac38e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29b39d4b0e44d350a35e5f25d9faeb9f9aac38e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29b39d4b0e44d350a35e5f25d9faeb9f9aac38e4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29b39d4b0e44d350a35e5f25d9faeb9f9aac38e4/comments", "author": null, "committer": null, "parents": [{"sha": "db58fa0b053327acfa42fbe6ca673e6eddd7852b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db58fa0b053327acfa42fbe6ca673e6eddd7852b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db58fa0b053327acfa42fbe6ca673e6eddd7852b"}], "stats": {"total": 327, "additions": 290, "deletions": 37}, "files": [{"sha": "228e10b62bffedd530bfc57f29226f805574aa87", "filename": "libstdc++-v3/include/bits/ranges_algo.h", "status": "modified", "additions": 1, "deletions": 37, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29b39d4b0e44d350a35e5f25d9faeb9f9aac38e4/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29b39d4b0e44d350a35e5f25d9faeb9f9aac38e4/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algo.h?ref=29b39d4b0e44d350a35e5f25d9faeb9f9aac38e4", "patch": "@@ -506,43 +506,7 @@ namespace ranges\n \n   inline constexpr __find_end_fn find_end{};\n \n-  struct __adjacent_find_fn\n-  {\n-    template<forward_iterator _Iter, sentinel_for<_Iter> _Sent,\n-\t     typename _Proj = identity,\n-\t     indirect_binary_predicate<projected<_Iter, _Proj>,\n-\t\t\t\t       projected<_Iter, _Proj>> _Pred\n-\t       = ranges::equal_to>\n-      constexpr _Iter\n-      operator()(_Iter __first, _Sent __last,\n-\t\t _Pred __pred = {}, _Proj __proj = {}) const\n-      {\n-\tif (__first == __last)\n-\t  return __first;\n-\tauto __next = __first;\n-\tfor (; ++__next != __last; __first = __next)\n-\t  {\n-\t    if (std::__invoke(__pred,\n-\t\t\t      std::__invoke(__proj, *__first),\n-\t\t\t      std::__invoke(__proj, *__next)))\n-\t      return __first;\n-\t  }\n-\treturn __next;\n-      }\n-\n-    template<forward_range _Range, typename _Proj = identity,\n-\t     indirect_binary_predicate<\n-\t       projected<iterator_t<_Range>, _Proj>,\n-\t       projected<iterator_t<_Range>, _Proj>> _Pred = ranges::equal_to>\n-      constexpr borrowed_iterator_t<_Range>\n-      operator()(_Range&& __r, _Pred __pred = {}, _Proj __proj = {}) const\n-      {\n-\treturn (*this)(ranges::begin(__r), ranges::end(__r),\n-\t\t       std::move(__pred), std::move(__proj));\n-      }\n-  };\n-\n-  inline constexpr __adjacent_find_fn adjacent_find{};\n+  // adjacent_find is defined in <bits/ranges_util.h>.\n \n   struct __is_permutation_fn\n   {"}, {"sha": "85ddea68407f50a675068e6ab59bebf2c4300cf1", "filename": "libstdc++-v3/include/bits/ranges_util.h", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29b39d4b0e44d350a35e5f25d9faeb9f9aac38e4/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_util.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29b39d4b0e44d350a35e5f25d9faeb9f9aac38e4/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_util.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_util.h?ref=29b39d4b0e44d350a35e5f25d9faeb9f9aac38e4", "patch": "@@ -704,6 +704,44 @@ namespace ranges\n \n   inline constexpr __min_fn min{};\n \n+  struct __adjacent_find_fn\n+  {\n+    template<forward_iterator _Iter, sentinel_for<_Iter> _Sent,\n+\t     typename _Proj = identity,\n+\t     indirect_binary_predicate<projected<_Iter, _Proj>,\n+\t\t\t\t       projected<_Iter, _Proj>> _Pred\n+\t       = ranges::equal_to>\n+      constexpr _Iter\n+      operator()(_Iter __first, _Sent __last,\n+\t\t _Pred __pred = {}, _Proj __proj = {}) const\n+      {\n+\tif (__first == __last)\n+\t  return __first;\n+\tauto __next = __first;\n+\tfor (; ++__next != __last; __first = __next)\n+\t  {\n+\t    if (std::__invoke(__pred,\n+\t\t\t      std::__invoke(__proj, *__first),\n+\t\t\t      std::__invoke(__proj, *__next)))\n+\t      return __first;\n+\t  }\n+\treturn __next;\n+      }\n+\n+    template<forward_range _Range, typename _Proj = identity,\n+\t     indirect_binary_predicate<\n+\t       projected<iterator_t<_Range>, _Proj>,\n+\t       projected<iterator_t<_Range>, _Proj>> _Pred = ranges::equal_to>\n+      constexpr borrowed_iterator_t<_Range>\n+      operator()(_Range&& __r, _Pred __pred = {}, _Proj __proj = {}) const\n+      {\n+\treturn (*this)(ranges::begin(__r), ranges::end(__r),\n+\t\t       std::move(__pred), std::move(__proj));\n+      }\n+  };\n+\n+  inline constexpr __adjacent_find_fn adjacent_find{};\n+\n } // namespace ranges\n \n   using ranges::get;"}, {"sha": "53093a3762f999a03da54153b466051cbc33ecd6", "filename": "libstdc++-v3/include/std/ranges", "status": "modified", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29b39d4b0e44d350a35e5f25d9faeb9f9aac38e4/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29b39d4b0e44d350a35e5f25d9faeb9f9aac38e4/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges?ref=29b39d4b0e44d350a35e5f25d9faeb9f9aac38e4", "patch": "@@ -6676,6 +6676,199 @@ namespace views::__adaptor\n \n     inline constexpr _Slide slide;\n   }\n+\n+  template<forward_range _Vp,\n+\t   indirect_binary_predicate<iterator_t<_Vp>, iterator_t<_Vp>> _Pred>\n+    requires view<_Vp> && is_object_v<_Pred>\n+  class chunk_by_view : public view_interface<chunk_by_view<_Vp, _Pred>>\n+  {\n+    _Vp _M_base = _Vp();\n+    __detail::__box<_Pred> _M_pred = _Pred();\n+    __detail::_CachedPosition<_Vp> _M_cached_begin;\n+\n+    constexpr iterator_t<_Vp>\n+    _M_find_next(iterator_t<_Vp> __current)\n+    {\n+      __glibcxx_assert(_M_pred.has_value());\n+      auto __pred = [this]<typename _Tp>(_Tp&& __x, _Tp&& __y) {\n+\treturn !bool((*_M_pred)(std::forward<_Tp>(__x), std::forward<_Tp>(__y)));\n+      };\n+      auto __it = ranges::adjacent_find(__current, ranges::end(_M_base), __pred);\n+      return ranges::next(__it, 1, ranges::end(_M_base));\n+    }\n+\n+    constexpr iterator_t<_Vp>\n+    _M_find_prev(iterator_t<_Vp> __current) requires bidirectional_range<_Vp>\n+    {\n+      __glibcxx_assert(_M_pred.has_value());\n+      auto __pred = [this]<typename _Tp>(_Tp&& __x, _Tp&& __y) {\n+\treturn !bool((*_M_pred)(std::forward<_Tp>(__y), std::forward<_Tp>(__x)));\n+      };\n+      auto __rbegin = std::make_reverse_iterator(__current);\n+      auto __rend = std::make_reverse_iterator(ranges::begin(_M_base));\n+      __glibcxx_assert(__rbegin != __rend);\n+      auto __it = ranges::adjacent_find(__rbegin, __rend, __pred).base();\n+      return ranges::prev(__it, 1, ranges::begin(_M_base));\n+    }\n+\n+    class _Iterator;\n+\n+  public:\n+    chunk_by_view() requires (default_initializable<_Vp>\n+\t\t\t      && default_initializable<_Pred>)\n+      = default;\n+\n+    constexpr explicit\n+    chunk_by_view(_Vp __base, _Pred __pred)\n+    : _M_base(std::move(__base)), _M_pred(std::move(__pred))\n+    { }\n+\n+    constexpr _Vp\n+    base() const & requires copy_constructible<_Vp>\n+    { return _M_base; }\n+\n+    constexpr _Vp\n+    base() &&\n+    { return std::move(_M_base); }\n+\n+    constexpr const _Pred&\n+    pred() const\n+    { return *_M_pred; }\n+\n+    constexpr _Iterator\n+    begin()\n+    {\n+      __glibcxx_assert(_M_pred.has_value());\n+      iterator_t<_Vp> __it;\n+      if (_M_cached_begin._M_has_value())\n+\t__it = _M_cached_begin._M_get(_M_base);\n+      else\n+\t{\n+\t  __it = _M_find_next(ranges::begin(_M_base));\n+\t  _M_cached_begin._M_set(_M_base, __it);\n+\t}\n+      return _Iterator(*this, ranges::begin(_M_base), __it);\n+    }\n+\n+    constexpr auto\n+    end()\n+    {\n+      if constexpr (common_range<_Vp>)\n+\treturn _Iterator(*this, ranges::end(_M_base), ranges::end(_M_base));\n+      else\n+\treturn default_sentinel;\n+    }\n+  };\n+\n+  template<typename _Range, typename _Pred>\n+    chunk_by_view(_Range&&, _Pred) -> chunk_by_view<views::all_t<_Range>, _Pred>;\n+\n+  template<forward_range _Vp,\n+\t   indirect_binary_predicate<iterator_t<_Vp>, iterator_t<_Vp>> _Pred>\n+    requires view<_Vp> && is_object_v<_Pred>\n+  class chunk_by_view<_Vp, _Pred>::_Iterator\n+  {\n+    chunk_by_view* _M_parent = nullptr;\n+    iterator_t<_Vp> _M_current = iterator_t<_Vp>();\n+    iterator_t<_Vp> _M_next = iterator_t<_Vp>();\n+\n+    constexpr\n+    _Iterator(chunk_by_view& __parent, iterator_t<_Vp> __current, iterator_t<_Vp> __next)\n+    : _M_parent(std::__addressof(__parent)), _M_current(__current), _M_next(__next)\n+    { }\n+\n+    static auto\n+    _S_iter_concept()\n+    {\n+      if constexpr (bidirectional_range<_Vp>)\n+\treturn bidirectional_iterator_tag{};\n+      else\n+\treturn forward_iterator_tag{};\n+    }\n+\n+    friend chunk_by_view;\n+\n+  public:\n+    using value_type = subrange<iterator_t<_Vp>>;\n+    using difference_type = range_difference_t<_Vp>;\n+    using iterator_category = input_iterator_tag;\n+    using iterator_concept = decltype(_S_iter_concept());\n+\n+    _Iterator() = default;\n+\n+    constexpr value_type\n+    operator*() const\n+    {\n+      __glibcxx_assert(_M_current != _M_next);\n+      return ranges::subrange(_M_current, _M_next);\n+    }\n+\n+    constexpr _Iterator&\n+    operator++()\n+    {\n+      __glibcxx_assert(_M_current != _M_next);\n+      _M_current = _M_next;\n+      _M_next = _M_parent->_M_find_next(_M_current);\n+      return *this;\n+    }\n+\n+    constexpr _Iterator\n+    operator++(int)\n+    {\n+      auto __tmp = *this;\n+      ++*this;\n+      return __tmp;\n+    }\n+\n+    constexpr _Iterator&\n+    operator--() requires bidirectional_range<_Vp>\n+    {\n+      _M_next = _M_current;\n+      _M_current = _M_parent->_M_find_prev(_M_next);\n+      return *this;\n+    }\n+\n+    constexpr _Iterator\n+    operator--(int) requires bidirectional_range<_Vp>\n+    {\n+      auto __tmp = *this;\n+      --*this;\n+      return __tmp;\n+    }\n+\n+    friend constexpr bool\n+    operator==(const _Iterator& __x, const _Iterator& __y)\n+    { return __x._M_current == __y._M_current; }\n+\n+    friend constexpr bool\n+    operator==(const _Iterator& __x, default_sentinel_t)\n+    { return __x._M_current == __x._M_next; }\n+  };\n+\n+  namespace views\n+  {\n+    namespace __detail\n+    {\n+      template<typename _Range, typename _Pred>\n+\tconcept __can_chunk_by_view\n+\t  = requires { chunk_by_view(std::declval<_Range>(), std::declval<_Pred>()); };\n+    }\n+\n+    struct _ChunkBy : __adaptor::_RangeAdaptor<_ChunkBy>\n+    {\n+      template<viewable_range _Range, typename _Pred>\n+\trequires __detail::__can_chunk_by_view<_Range, _Pred>\n+\tconstexpr auto\n+\toperator() [[nodiscard]] (_Range&& __r, _Pred&& __pred) const\n+\t{ return chunk_by_view(std::forward<_Range>(__r), std::forward<_Pred>(__pred)); }\n+\n+      using __adaptor::_RangeAdaptor<_ChunkBy>::operator();\n+      static constexpr int _S_arity = 2;\n+      static constexpr bool _S_has_simple_extra_args = true;\n+    };\n+\n+    inline constexpr _ChunkBy chunk_by;\n+  }\n #endif // C++23\n } // namespace ranges\n "}, {"sha": "d57b127fbc8d7b4c924be53722f8745ab524194d", "filename": "libstdc++-v3/testsuite/std/ranges/adaptors/chunk_by/1.cc", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29b39d4b0e44d350a35e5f25d9faeb9f9aac38e4/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fchunk_by%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29b39d4b0e44d350a35e5f25d9faeb9f9aac38e4/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fchunk_by%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fchunk_by%2F1.cc?ref=29b39d4b0e44d350a35e5f25d9faeb9f9aac38e4", "patch": "@@ -0,0 +1,58 @@\n+// { dg-options \"-std=gnu++23\" }\n+// { dg-do run { target c++23 } }\n+\n+#include <ranges>\n+#include <algorithm>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+namespace ranges = std::ranges;\n+namespace views = std::views;\n+\n+constexpr bool\n+test01()\n+{\n+  int x[] = {1, 2, 2, 3, 0, 4, 5, 2};\n+  auto v = x | views::chunk_by(ranges::less_equal{});\n+  static_assert(ranges::bidirectional_range<decltype(v)>\n+\t\t&& ranges::common_range<decltype(v)>);\n+  VERIFY( ranges::equal(v, (std::initializer_list<int>[]){{1, 2, 2, 3}, {0, 4, 5}, {2}},\n+\t\t\tranges::equal) );\n+  VERIFY( ranges::equal(v | views::reverse,\n+\t\t\t(std::initializer_list<int>[]){{2}, {0, 4, 5}, {1, 2, 2, 3}},\n+\t\t\tranges::equal) );\n+  VERIFY( ranges::equal(v | views::join, x) );\n+  auto i = v.begin();\n+  auto j = i;\n+  j++;\n+  VERIFY( i == i && i != v.end() );\n+  VERIFY( j == j && j != v.end() );\n+  VERIFY( j != i );\n+  j--;\n+  VERIFY( j == i );\n+\n+  return true;\n+}\n+\n+void\n+test02()\n+{\n+  int x[] = {1, 2, 3};\n+  __gnu_test::test_forward_range<int> rx(x);\n+  auto v = rx | views::chunk_by(ranges::equal_to{});\n+  static_assert(!ranges::bidirectional_range<decltype(v)>\n+\t\t&& !ranges::common_range<decltype(v)>);\n+  VERIFY( ranges::equal(v, x | views::transform(views::single), ranges::equal) );\n+  auto i = v.begin();\n+  VERIFY( i != v.end() );\n+  ranges::advance(i, 3);\n+  VERIFY( i == v.end() );\n+}\n+\n+int\n+main()\n+{\n+  static_assert(test01());\n+  test02();\n+}"}]}