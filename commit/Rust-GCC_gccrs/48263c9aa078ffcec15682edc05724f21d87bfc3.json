{"sha": "48263c9aa078ffcec15682edc05724f21d87bfc3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDgyNjNjOWFhMDc4ZmZjZWMxNTY4MmVkYzA1NzI0ZjIxZDg3YmZjMw==", "commit": {"author": {"name": "Emmanuel Briot", "email": "briot@adacore.com", "date": "2009-10-30T13:44:40Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-10-30T13:44:40Z"}, "message": "2009-10-30  Emmanuel Briot  <briot@adacore.com>\n\n\t* make.adb, adaint.c, adaint.h, osint.adb, osint.ads, bcheck.adb\n\t(*_attr): new subprograms.\n\t(File_Length, File_Time_Stamp, Is_Writable_File): new subprograms\n\t(Read_Library_Info_From_Full, Full_Library_Info_Name,\n\tFull_Source_Name): Now benefit from a previous cache of the file\n\tattributes, to further save on system calls.\n\t(Smart_Find_File): now also cache the file attributes. This makes the\n\tpackage File_Stamp_Hash_Table useless, and it was removed.\n\t(Compile_Sources): create subprograms for the various steps of the main\n\tloop, for readibility and to avoid sharing variables between the\n\tvarious steps.\n\nFrom-SVN: r153747", "tree": {"sha": "0346c1c344442f3994e788215edf3d88a6b9224d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0346c1c344442f3994e788215edf3d88a6b9224d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/48263c9aa078ffcec15682edc05724f21d87bfc3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48263c9aa078ffcec15682edc05724f21d87bfc3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48263c9aa078ffcec15682edc05724f21d87bfc3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48263c9aa078ffcec15682edc05724f21d87bfc3/comments", "author": {"login": "briot", "id": 42402, "node_id": "MDQ6VXNlcjQyNDAy", "avatar_url": "https://avatars.githubusercontent.com/u/42402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/briot", "html_url": "https://github.com/briot", "followers_url": "https://api.github.com/users/briot/followers", "following_url": "https://api.github.com/users/briot/following{/other_user}", "gists_url": "https://api.github.com/users/briot/gists{/gist_id}", "starred_url": "https://api.github.com/users/briot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/briot/subscriptions", "organizations_url": "https://api.github.com/users/briot/orgs", "repos_url": "https://api.github.com/users/briot/repos", "events_url": "https://api.github.com/users/briot/events{/privacy}", "received_events_url": "https://api.github.com/users/briot/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b11cb5fd9eb07c4989081f533feca1bf262f0e81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b11cb5fd9eb07c4989081f533feca1bf262f0e81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b11cb5fd9eb07c4989081f533feca1bf262f0e81"}], "stats": {"total": 2045, "additions": 1300, "deletions": 745}, "files": [{"sha": "517b01fb6edc95fc61b92e0632073fdb46f8efd7", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48263c9aa078ffcec15682edc05724f21d87bfc3/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48263c9aa078ffcec15682edc05724f21d87bfc3/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=48263c9aa078ffcec15682edc05724f21d87bfc3", "patch": "@@ -1,3 +1,17 @@\n+2009-10-30  Emmanuel Briot  <briot@adacore.com>\n+\n+\t* make.adb, adaint.c, adaint.h, osint.adb, osint.ads, bcheck.adb\n+\t(*_attr): new subprograms.\n+\t(File_Length, File_Time_Stamp, Is_Writable_File): new subprograms\n+\t(Read_Library_Info_From_Full, Full_Library_Info_Name,\n+\tFull_Source_Name): Now benefit from a previous cache of the file\n+\tattributes, to further save on system calls.\n+\t(Smart_Find_File): now also cache the file attributes. This makes the\n+\tpackage File_Stamp_Hash_Table useless, and it was removed.\n+\t(Compile_Sources): create subprograms for the various steps of the main\n+\tloop, for readibility and to avoid sharing variables between the\n+\tvarious steps.\n+\n 2009-10-30  Emmanuel Briot  <briot@adacore.com>\n \n \t* make.adb, osint.adb, osint.ads (Library_File_Stamp): Removed, since"}, {"sha": "e26f3ca15822e7d86e779dbf6ed064bbfc57aa08", "filename": "gcc/ada/adaint.c", "status": "modified", "additions": 336, "deletions": 207, "changes": 543, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48263c9aa078ffcec15682edc05724f21d87bfc3/gcc%2Fada%2Fadaint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48263c9aa078ffcec15682edc05724f21d87bfc3/gcc%2Fada%2Fadaint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.c?ref=48263c9aa078ffcec15682edc05724f21d87bfc3", "patch": "@@ -324,6 +324,12 @@ const int __gnat_vmsp = 0;\n \n #endif\n \n+/* Used for Ada bindings */\n+const int size_of_file_attributes = sizeof (struct file_attributes);\n+\n+/* Reset the file attributes as if no system call had been performed */\n+void __gnat_stat_to_attr (int fd, char* name, struct file_attributes* attr);\n+\n /* The __gnat_max_path_len variable is used to export the maximum\n    length of a path name to Ada code. max_path_len is also provided\n    for compatibility with older GNAT versions, please do not use\n@@ -371,6 +377,24 @@ to_ptr32 (char **ptr64)\n #define MAYBE_TO_PTR32(argv) argv\n #endif\n \n+void\n+reset_attributes\n+  (struct file_attributes* attr)\n+{\n+  attr->exists     = -1;\n+\n+  attr->writable   = -1;\n+  attr->readable   = -1;\n+  attr->executable = -1;\n+\n+  attr->regular    = -1;\n+  attr->symbolic_link = -1;\n+  attr->directory = -1;\n+\n+  attr->timestamp = (OS_Time)-2;\n+  attr->file_length = -1;\n+}\n+\n OS_Time\n __gnat_current_time\n   (void)\n@@ -1036,42 +1060,89 @@ __gnat_open_new_temp (char *path, int fmode)\n   return fd < 0 ? -1 : fd;\n }\n \n-/* Return the number of bytes in the specified file.  */\n+/****************************************************************\n+ ** Perform a call to GNAT_STAT or GNAT_FSTAT, and extract as much information\n+ ** as possible from it, storing the result in a cache for later reuse\n+ ****************************************************************/\n \n-long\n-__gnat_file_length (int fd)\n+void\n+__gnat_stat_to_attr (int fd, char* name, struct file_attributes* attr)\n {\n-  int ret;\n   GNAT_STRUCT_STAT statbuf;\n+  int ret;\n \n-  ret = GNAT_FSTAT (fd, &statbuf);\n-  if (ret || !S_ISREG (statbuf.st_mode))\n-    return 0;\n+  if (fd != -1)\n+    ret = GNAT_FSTAT (fd, &statbuf);\n+  else\n+    ret = __gnat_stat (name, &statbuf);\n+\n+  attr->regular   = (!ret && S_ISREG (statbuf.st_mode));\n+  attr->directory = (!ret && S_ISDIR (statbuf.st_mode));\n \n-  /* st_size may be 32 bits, or 64 bits which is converted to long. We\n-     don't return a useful value for files larger than 2 gigabytes in\n-     either case. */\n+  if (!attr->regular)\n+    attr->file_length = 0;\n+  else\n+    /* st_size may be 32 bits, or 64 bits which is converted to long. We\n+       don't return a useful value for files larger than 2 gigabytes in\n+       either case. */\n+    attr->file_length = statbuf.st_size;  /* all systems */\n+\n+#ifndef __MINGW32__\n+  /* on Windows requires extra system call, see comment in __gnat_file_exists_attr */\n+  attr->exists = !ret;\n+#endif\n+\n+#if !defined (_WIN32) || defined (RTX)\n+  /* on Windows requires extra system call, see __gnat_is_readable_file_attr */\n+  attr->readable   = (!ret && (statbuf.st_mode & S_IRUSR));\n+  attr->writable   = (!ret && (statbuf.st_mode & S_IWUSR));\n+  attr->executable = (!ret && (statbuf.st_mode & S_IXUSR));\n+#endif\n+\n+#if !defined (__EMX__) && !defined (MSDOS) && (!defined (_WIN32) || defined (RTX))\n+  /* on Windows requires extra system call, see __gnat_file_time_name_attr */\n+  if (ret != 0) {\n+     attr->timestamp = (OS_Time)-1;\n+  } else {\n+#ifdef VMS\n+     /* VMS has file versioning.  */\n+     attr->timestamp = (OS_Time)statbuf.st_ctime;\n+#else\n+     attr->timestamp = (OS_Time)statbuf.st_mtime;\n+#endif\n+  }\n+#endif\n \n-  return (statbuf.st_size);\n }\n \n-/* Return the number of bytes in the specified named file.  */\n+/****************************************************************\n+ ** Return the number of bytes in the specified file\n+ ****************************************************************/\n \n long\n-__gnat_named_file_length (char *name)\n+__gnat_file_length_attr (int fd, char* name, struct file_attributes* attr)\n {\n-  int ret;\n-  GNAT_STRUCT_STAT statbuf;\n+  if (attr->file_length == -1) {\n+    __gnat_stat_to_attr (fd, name, attr);\n+  }\n \n-  ret = __gnat_stat (name, &statbuf);\n-  if (ret || !S_ISREG (statbuf.st_mode))\n-    return 0;\n+  return attr->file_length;\n+}\n \n-  /* st_size may be 32 bits, or 64 bits which is converted to long. We\n-     don't return a useful value for files larger than 2 gigabytes in\n-     either case. */\n+long\n+__gnat_file_length (int fd)\n+{\n+  struct file_attributes attr;\n+  reset_attributes (&attr);\n+  return __gnat_file_length_attr (fd, NULL, &attr);\n+}\n \n-  return (statbuf.st_size);\n+long\n+__gnat_named_file_length (char *name)\n+{\n+  struct file_attributes attr;\n+  reset_attributes (&attr);\n+  return __gnat_file_length_attr (-1, name, &attr);\n }\n \n /* Create a temporary filename and put it in string pointed to by\n@@ -1266,137 +1337,136 @@ win32_filetime (HANDLE h)\n /* Return a GNAT time stamp given a file name.  */\n \n OS_Time\n-__gnat_file_time_name (char *name)\n+__gnat_file_time_name_attr (char* name, struct file_attributes* attr)\n {\n-\n+   if (attr->timestamp == (OS_Time)-2) {\n #if defined (__EMX__) || defined (MSDOS)\n-  int fd = open (name, O_RDONLY | O_BINARY);\n-  time_t ret = __gnat_file_time_fd (fd);\n-  close (fd);\n-  return (OS_Time)ret;\n+      int fd = open (name, O_RDONLY | O_BINARY);\n+      time_t ret = __gnat_file_time_fd (fd);\n+      close (fd);\n+      attr->timestamp = (OS_Time)ret;\n \n #elif defined (_WIN32) && !defined (RTX)\n-  time_t ret = -1;\n-  TCHAR wname[GNAT_MAX_PATH_LEN];\n-\n-  S2WSC (wname, name, GNAT_MAX_PATH_LEN);\n+      time_t ret = -1;\n+      TCHAR wname[GNAT_MAX_PATH_LEN];\n+      S2WSC (wname, name, GNAT_MAX_PATH_LEN);\n \n-  HANDLE h = CreateFile\n-    (wname, GENERIC_READ, FILE_SHARE_READ, 0,\n-     OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, 0);\n+      HANDLE h = CreateFile\n+        (wname, GENERIC_READ, FILE_SHARE_READ, 0,\n+         OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, 0);\n \n-  if (h != INVALID_HANDLE_VALUE)\n-    {\n-      ret = win32_filetime (h);\n-      CloseHandle (h);\n-    }\n-  return (OS_Time) ret;\n-#else\n-  GNAT_STRUCT_STAT statbuf;\n-  if (__gnat_stat (name, &statbuf) != 0) {\n-     return (OS_Time)-1;\n-  } else {\n-#ifdef VMS\n-     /* VMS has file versioning.  */\n-     return (OS_Time)statbuf.st_ctime;\n+      if (h != INVALID_HANDLE_VALUE) {\n+         ret = win32_filetime (h);\n+         CloseHandle (h);\n+      }\n+      attr->timestamp = (OS_Time) ret;\n #else\n-     return (OS_Time)statbuf.st_mtime;\n+      __gnat_stat_to_attr (-1, name, attr);\n #endif\n   }\n-#endif\n+  return attr->timestamp;\n+}\n+\n+OS_Time\n+__gnat_file_time_name (char *name)\n+{\n+   struct file_attributes attr;\n+   reset_attributes (&attr);\n+   return __gnat_file_time_name_attr (name, &attr);\n }\n \n /* Return a GNAT time stamp given a file descriptor.  */\n \n OS_Time\n-__gnat_file_time_fd (int fd)\n+__gnat_file_time_fd_attr (int fd, struct file_attributes* attr)\n {\n-  /* The following workaround code is due to the fact that under EMX and\n-     DJGPP fstat attempts to convert time values to GMT rather than keep the\n-     actual OS timestamp of the file. By using the OS2/DOS functions directly\n-     the GNAT timestamp are independent of this behavior, which is desired to\n-     facilitate the distribution of GNAT compiled libraries.  */\n+   if (attr->timestamp == (OS_Time)-2) {\n+     /* The following workaround code is due to the fact that under EMX and\n+        DJGPP fstat attempts to convert time values to GMT rather than keep the\n+        actual OS timestamp of the file. By using the OS2/DOS functions directly\n+        the GNAT timestamp are independent of this behavior, which is desired to\n+        facilitate the distribution of GNAT compiled libraries.  */\n \n #if defined (__EMX__) || defined (MSDOS)\n #ifdef __EMX__\n \n-  FILESTATUS fs;\n-  int ret = DosQueryFileInfo (fd, 1, (unsigned char *) &fs,\n-                                sizeof (FILESTATUS));\n+     FILESTATUS fs;\n+     int ret = DosQueryFileInfo (fd, 1, (unsigned char *) &fs,\n+                                   sizeof (FILESTATUS));\n \n-  unsigned file_year  = fs.fdateLastWrite.year;\n-  unsigned file_month = fs.fdateLastWrite.month;\n-  unsigned file_day   = fs.fdateLastWrite.day;\n-  unsigned file_hour  = fs.ftimeLastWrite.hours;\n-  unsigned file_min   = fs.ftimeLastWrite.minutes;\n-  unsigned file_tsec  = fs.ftimeLastWrite.twosecs;\n+     unsigned file_year  = fs.fdateLastWrite.year;\n+     unsigned file_month = fs.fdateLastWrite.month;\n+     unsigned file_day   = fs.fdateLastWrite.day;\n+     unsigned file_hour  = fs.ftimeLastWrite.hours;\n+     unsigned file_min   = fs.ftimeLastWrite.minutes;\n+     unsigned file_tsec  = fs.ftimeLastWrite.twosecs;\n \n #else\n-  struct ftime fs;\n-  int ret = getftime (fd, &fs);\n+     struct ftime fs;\n+     int ret = getftime (fd, &fs);\n \n-  unsigned file_year  = fs.ft_year;\n-  unsigned file_month = fs.ft_month;\n-  unsigned file_day   = fs.ft_day;\n-  unsigned file_hour  = fs.ft_hour;\n-  unsigned file_min   = fs.ft_min;\n-  unsigned file_tsec  = fs.ft_tsec;\n+     unsigned file_year  = fs.ft_year;\n+     unsigned file_month = fs.ft_month;\n+     unsigned file_day   = fs.ft_day;\n+     unsigned file_hour  = fs.ft_hour;\n+     unsigned file_min   = fs.ft_min;\n+     unsigned file_tsec  = fs.ft_tsec;\n #endif\n \n-  /* Calculate the seconds since epoch from the time components. First count\n-     the whole days passed.  The value for years returned by the DOS and OS2\n-     functions count years from 1980, so to compensate for the UNIX epoch which\n-     begins in 1970 start with 10 years worth of days and add days for each\n-     four year period since then.  */\n+     /* Calculate the seconds since epoch from the time components. First count\n+        the whole days passed.  The value for years returned by the DOS and OS2\n+        functions count years from 1980, so to compensate for the UNIX epoch which\n+        begins in 1970 start with 10 years worth of days and add days for each\n+        four year period since then.  */\n \n-  time_t tot_secs;\n-  int cum_days[12] = {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334};\n-  int days_passed = 3652 + (file_year / 4) * 1461;\n-  int years_since_leap = file_year % 4;\n+     time_t tot_secs;\n+     int cum_days[12] = {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334};\n+     int days_passed = 3652 + (file_year / 4) * 1461;\n+     int years_since_leap = file_year % 4;\n \n-  if (years_since_leap == 1)\n-    days_passed += 366;\n-  else if (years_since_leap == 2)\n-    days_passed += 731;\n-  else if (years_since_leap == 3)\n-    days_passed += 1096;\n+     if (years_since_leap == 1)\n+       days_passed += 366;\n+     else if (years_since_leap == 2)\n+       days_passed += 731;\n+     else if (years_since_leap == 3)\n+       days_passed += 1096;\n \n-  if (file_year > 20)\n-    days_passed -= 1;\n+     if (file_year > 20)\n+       days_passed -= 1;\n \n-  days_passed += cum_days[file_month - 1];\n-  if (years_since_leap == 0 && file_year != 20 && file_month > 2)\n-    days_passed++;\n+     days_passed += cum_days[file_month - 1];\n+     if (years_since_leap == 0 && file_year != 20 && file_month > 2)\n+       days_passed++;\n \n-  days_passed += file_day - 1;\n+     days_passed += file_day - 1;\n \n-  /* OK - have whole days.  Multiply -- then add in other parts.  */\n+     /* OK - have whole days.  Multiply -- then add in other parts.  */\n \n-  tot_secs  = days_passed * 86400;\n-  tot_secs += file_hour * 3600;\n-  tot_secs += file_min * 60;\n-  tot_secs += file_tsec * 2;\n-  return (OS_Time) tot_secs;\n+     tot_secs  = days_passed * 86400;\n+     tot_secs += file_hour * 3600;\n+     tot_secs += file_min * 60;\n+     tot_secs += file_tsec * 2;\n+     attr->timestamp = (OS_Time) tot_secs;\n \n #elif defined (_WIN32) && !defined (RTX)\n-  HANDLE h = (HANDLE) _get_osfhandle (fd);\n-  time_t ret = win32_filetime (h);\n-  return (OS_Time) ret;\n+     HANDLE h = (HANDLE) _get_osfhandle (fd);\n+     time_t ret = win32_filetime (h);\n+     attr->timestamp = (OS_Time) ret;\n \n #else\n-  GNAT_STRUCT_STAT statbuf;\n-\n-  if (GNAT_FSTAT (fd, &statbuf) != 0) {\n-     return (OS_Time) -1;\n-  } else {\n-#ifdef VMS\n-     /* VMS has file versioning.  */\n-     return (OS_Time) statbuf.st_ctime;\n-#else\n-     return (OS_Time) statbuf.st_mtime;\n-#endif\n-  }\n+     __gnat_stat_to_attr (fd, NULL, attr);\n #endif\n+   }\n+\n+   return attr->timestamp;\n+}\n+\n+OS_Time\n+__gnat_file_time_fd (int fd)\n+{\n+   struct file_attributes attr;\n+   reset_attributes (&attr);\n+   return __gnat_file_time_fd_attr (fd, &attr);\n }\n \n /* Set the file time stamp.  */\n@@ -1722,24 +1792,41 @@ __gnat_stat (char *name, GNAT_STRUCT_STAT *statbuf)\n #endif\n }\n \n+/*************************************************************************\n+ ** Check whether a file exists\n+ *************************************************************************/\n+\n int\n-__gnat_file_exists (char *name)\n+__gnat_file_exists_attr (char* name, struct file_attributes* attr)\n {\n+   if (attr->exists == -1) {\n #ifdef __MINGW32__\n-  /*  On Windows do not use __gnat_stat() because a bug in Microsoft\n-  _stat() routine. When the system time-zone is set with a negative\n-  offset the _stat() routine fails on specific files like CON:  */\n-  TCHAR wname [GNAT_MAX_PATH_LEN + 2];\n-\n-  S2WSC (wname, name, GNAT_MAX_PATH_LEN + 2);\n-  return GetFileAttributes (wname) != INVALID_FILE_ATTRIBUTES;\n+      /*  On Windows do not use __gnat_stat() because of a bug in Microsoft\n+         _stat() routine. When the system time-zone is set with a negative\n+         offset the _stat() routine fails on specific files like CON:  */\n+      TCHAR wname [GNAT_MAX_PATH_LEN + 2];\n+      S2WSC (wname, name, GNAT_MAX_PATH_LEN + 2);\n+      attr->exists = GetFileAttributes (wname) != INVALID_FILE_ATTRIBUTES;\n #else\n-  GNAT_STRUCT_STAT statbuf;\n-\n-  return !__gnat_stat (name, &statbuf);\n+      __gnat_stat_to_attr (-1, name, attr);\n #endif\n+   }\n+\n+   return attr->exists;\n }\n \n+int\n+__gnat_file_exists (char *name)\n+{\n+   struct file_attributes attr;\n+   reset_attributes (&attr);\n+   return __gnat_file_exists_attr (name, &attr);\n+}\n+\n+/**********************************************************************\n+ ** Whether name is an absolute path\n+ **********************************************************************/\n+\n int\n __gnat_is_absolute_path (char *name, int length)\n {\n@@ -1775,24 +1862,40 @@ __gnat_is_absolute_path (char *name, int length)\n #endif\n }\n \n+int\n+__gnat_is_regular_file_attr (char* name, struct file_attributes* attr)\n+{\n+   if (attr->regular == -1) {\n+      __gnat_stat_to_attr (-1, name, attr);\n+   }\n+\n+   return attr->regular;\n+}\n+\n int\n __gnat_is_regular_file (char *name)\n {\n-  int ret;\n-  GNAT_STRUCT_STAT statbuf;\n+   struct file_attributes attr;\n+   reset_attributes (&attr);\n+   return __gnat_is_regular_file_attr (name, &attr);\n+}\n \n-  ret = __gnat_stat (name, &statbuf);\n-  return (!ret && S_ISREG (statbuf.st_mode));\n+int\n+__gnat_is_directory_attr (char* name, struct file_attributes* attr)\n+{\n+   if (attr->directory == -1) {\n+      __gnat_stat_to_attr (-1, name, attr);\n+   }\n+\n+   return attr->directory;\n }\n \n int\n __gnat_is_directory (char *name)\n {\n-  int ret;\n-  GNAT_STRUCT_STAT statbuf;\n-\n-  ret = __gnat_stat (name, &statbuf);\n-  return (!ret && S_ISDIR (statbuf.st_mode));\n+   struct file_attributes attr;\n+   reset_attributes (&attr);\n+   return __gnat_is_directory_attr (name, &attr);\n }\n \n #if defined (_WIN32) && !defined (RTX)\n@@ -1986,95 +2089,111 @@ __gnat_can_use_acl (TCHAR *wname)\n #endif /* defined (_WIN32) && !defined (RTX) */\n \n int\n-__gnat_is_readable_file (char *name)\n+__gnat_is_readable_file_attr (char* name, struct file_attributes* attr)\n {\n+   if (attr->readable == -1) {\n #if defined (_WIN32) && !defined (RTX)\n-  TCHAR wname [GNAT_MAX_PATH_LEN + 2];\n-  GENERIC_MAPPING GenericMapping;\n-\n-  S2WSC (wname, name, GNAT_MAX_PATH_LEN + 2);\n+     TCHAR wname [GNAT_MAX_PATH_LEN + 2];\n+     GENERIC_MAPPING GenericMapping;\n \n-  if (__gnat_can_use_acl (wname))\n-    {\n-      ZeroMemory (&GenericMapping, sizeof (GENERIC_MAPPING));\n-      GenericMapping.GenericRead = GENERIC_READ;\n-\n-      return __gnat_check_OWNER_ACL (wname, FILE_READ_DATA, GenericMapping);\n-    }\n-  else\n-    return GetFileAttributes (wname) != INVALID_FILE_ATTRIBUTES;\n+     S2WSC (wname, name, GNAT_MAX_PATH_LEN + 2);\n \n+     if (__gnat_can_use_acl (wname))\n+     {\n+        ZeroMemory (&GenericMapping, sizeof (GENERIC_MAPPING));\n+        GenericMapping.GenericRead = GENERIC_READ;\n+        attr->readable = __gnat_check_OWNER_ACL (wname, FILE_READ_DATA, GenericMapping);\n+     }\n+     else\n+        attr->readable = GetFileAttributes (wname) != INVALID_FILE_ATTRIBUTES;\n #else\n-  int ret;\n-  int mode;\n-  GNAT_STRUCT_STAT statbuf;\n-\n-  ret = GNAT_STAT (name, &statbuf);\n-  mode = statbuf.st_mode & S_IRUSR;\n-  return (!ret && mode);\n+     __gnat_stat_to_attr (-1, name, attr);\n #endif\n+   }\n+\n+   return attr->readable;\n }\n \n int\n-__gnat_is_writable_file (char *name)\n+__gnat_is_readable_file (char *name)\n {\n+   struct file_attributes attr;\n+   reset_attributes (&attr);\n+   return __gnat_is_readable_file_attr (name, &attr);\n+}\n+\n+int\n+__gnat_is_writable_file_attr (char* name, struct file_attributes* attr)\n+{\n+   if (attr->writable == -1) {\n #if defined (_WIN32) && !defined (RTX)\n-  TCHAR wname [GNAT_MAX_PATH_LEN + 2];\n-  GENERIC_MAPPING GenericMapping;\n+     TCHAR wname [GNAT_MAX_PATH_LEN + 2];\n+     GENERIC_MAPPING GenericMapping;\n \n-  S2WSC (wname, name, GNAT_MAX_PATH_LEN + 2);\n+     S2WSC (wname, name, GNAT_MAX_PATH_LEN + 2);\n \n-  if (__gnat_can_use_acl (wname))\n-    {\n-      ZeroMemory (&GenericMapping, sizeof (GENERIC_MAPPING));\n-      GenericMapping.GenericWrite = GENERIC_WRITE;\n+     if (__gnat_can_use_acl (wname))\n+       {\n+         ZeroMemory (&GenericMapping, sizeof (GENERIC_MAPPING));\n+         GenericMapping.GenericWrite = GENERIC_WRITE;\n \n-      return __gnat_check_OWNER_ACL\n-\t(wname, FILE_WRITE_DATA | FILE_APPEND_DATA, GenericMapping)\n-\t&& !(GetFileAttributes (wname) & FILE_ATTRIBUTE_READONLY);\n-    }\n-  else\n-    return !(GetFileAttributes (wname) & FILE_ATTRIBUTE_READONLY);\n+         attr->writable = __gnat_check_OWNER_ACL\n+   \t     (wname, FILE_WRITE_DATA | FILE_APPEND_DATA, GenericMapping)\n+   \t     && !(GetFileAttributes (wname) & FILE_ATTRIBUTE_READONLY);\n+       }\n+     else\n+       attr->writable = !(GetFileAttributes (wname) & FILE_ATTRIBUTE_READONLY);\n \n #else\n-  int ret;\n-  int mode;\n-  GNAT_STRUCT_STAT statbuf;\n-\n-  ret = GNAT_STAT (name, &statbuf);\n-  mode = statbuf.st_mode & S_IWUSR;\n-  return (!ret && mode);\n+     __gnat_stat_to_attr (-1, name, attr);\n #endif\n+   }\n+\n+   return attr->writable;\n }\n \n int\n-__gnat_is_executable_file (char *name)\n+__gnat_is_writable_file (char *name)\n {\n+   struct file_attributes attr;\n+   reset_attributes (&attr);\n+   return __gnat_is_writable_file_attr (name, &attr);\n+}\n+\n+int\n+__gnat_is_executable_file_attr (char* name, struct file_attributes* attr)\n+{\n+   if (attr->executable == -1) {\n #if defined (_WIN32) && !defined (RTX)\n-  TCHAR wname [GNAT_MAX_PATH_LEN + 2];\n-  GENERIC_MAPPING GenericMapping;\n+     TCHAR wname [GNAT_MAX_PATH_LEN + 2];\n+     GENERIC_MAPPING GenericMapping;\n \n-  S2WSC (wname, name, GNAT_MAX_PATH_LEN + 2);\n+     S2WSC (wname, name, GNAT_MAX_PATH_LEN + 2);\n \n-  if (__gnat_can_use_acl (wname))\n-    {\n-      ZeroMemory (&GenericMapping, sizeof (GENERIC_MAPPING));\n-      GenericMapping.GenericExecute = GENERIC_EXECUTE;\n+     if (__gnat_can_use_acl (wname))\n+       {\n+         ZeroMemory (&GenericMapping, sizeof (GENERIC_MAPPING));\n+         GenericMapping.GenericExecute = GENERIC_EXECUTE;\n \n-      return __gnat_check_OWNER_ACL (wname, FILE_EXECUTE, GenericMapping);\n-    }\n-  else\n-    return GetFileAttributes (wname) != INVALID_FILE_ATTRIBUTES\n-      && _tcsstr (wname, _T(\".exe\")) - wname == (int) (_tcslen (wname) - 4);\n+         attr->executable = __gnat_check_OWNER_ACL (wname, FILE_EXECUTE, GenericMapping);\n+       }\n+     else\n+       attr->executable = GetFileAttributes (wname) != INVALID_FILE_ATTRIBUTES\n+         && _tcsstr (wname, _T(\".exe\")) - wname == (int) (_tcslen (wname) - 4);\n #else\n-  int ret;\n-  int mode;\n-  GNAT_STRUCT_STAT statbuf;\n-\n-  ret = GNAT_STAT (name, &statbuf);\n-  mode = statbuf.st_mode & S_IXUSR;\n-  return (!ret && mode);\n+     __gnat_stat_to_attr (-1, name, attr);\n #endif\n+   }\n+\n+   return attr->executable;\n+}\n+\n+int\n+__gnat_is_executable_file (char *name)\n+{\n+   struct file_attributes attr;\n+   reset_attributes (&attr);\n+   return __gnat_is_executable_file_attr (name, &attr);\n }\n \n void\n@@ -2193,21 +2312,31 @@ __gnat_set_non_readable (char *name)\n }\n \n int\n-__gnat_is_symbolic_link (char *name ATTRIBUTE_UNUSED)\n+__gnat_is_symbolic_link_attr (char* name, struct file_attributes* attr)\n {\n+   if (attr->symbolic_link == -1) {\n #if defined (__vxworks) || defined (__nucleus__)\n-  return 0;\n+      attr->symbolic_link = 0;\n \n #elif defined (_AIX) || defined (__APPLE__) || defined (__unix__)\n-  int ret;\n-  GNAT_STRUCT_STAT statbuf;\n-\n-  ret = GNAT_LSTAT (name, &statbuf);\n-  return (!ret && S_ISLNK (statbuf.st_mode));\n-\n+      int ret;\n+      GNAT_STRUCT_STAT statbuf;\n+      ret = GNAT_LSTAT (name, &statbuf);\n+      attr->symbolic_link = (!ret && S_ISLNK (statbuf.st_mode));\n #else\n-  return 0;\n+      attr->symbolic_link = 0;\n #endif\n+   }\n+   return attr->symbolic_link;\n+}\n+\n+int\n+__gnat_is_symbolic_link (char *name ATTRIBUTE_UNUSED)\n+{\n+   struct file_attributes attr;\n+   reset_attributes (&attr);\n+   return __gnat_is_symbolic_link_attr (name, &attr);\n+\n }\n \n #if defined (sun) && defined (__SVR4)"}, {"sha": "fbdb4ff613235b1a03f2481dff7b4027a6594f63", "filename": "gcc/ada/adaint.h", "status": "modified", "additions": 44, "deletions": 7, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48263c9aa078ffcec15682edc05724f21d87bfc3/gcc%2Fada%2Fadaint.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48263c9aa078ffcec15682edc05724f21d87bfc3/gcc%2Fada%2Fadaint.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.h?ref=48263c9aa078ffcec15682edc05724f21d87bfc3", "patch": "@@ -68,6 +68,30 @@ typedef long long OS_Time;\n typedef long OS_Time;\n #endif\n \n+/* A lazy cache for the attributes of a file. On some systems, a single call to\n+   stat() will give all this information, so it is better than doing a system\n+   call every time. On other systems this require several system calls.\n+*/\n+\n+struct file_attributes {\n+  short exists;\n+\n+  short writable;\n+  short readable;\n+  short executable;\n+\n+  short symbolic_link;\n+  short regular;\n+  short directory;\n+\n+  OS_Time timestamp;\n+  long file_length;\n+};\n+/* WARNING: changing the size here might require changing the constant\n+ * File_Attributes_Size in osint.ads (which should be big enough to\n+ * fit the above struct on any system)\n+ */\n+\n extern int    __gnat_max_path_len;\n extern OS_Time __gnat_current_time\t\t   (void);\n extern void   __gnat_current_time_string           (char *);\n@@ -121,15 +145,28 @@ extern OS_Time __gnat_file_time_fd                  (int);\n \n extern void   __gnat_set_file_time_name\t\t   (char *, time_t);\n \n-extern int    __gnat_dup\t\t\t   (int);\n-extern int    __gnat_dup2\t\t\t   (int, int);\n-extern int    __gnat_file_exists\t\t   (char *);\n-extern int    __gnat_is_regular_file               (char *);\n-extern int    __gnat_is_absolute_path              (char *,int);\n-extern int    __gnat_is_directory\t\t   (char *);\n+extern int    __gnat_dup\t\t\t            (int);\n+extern int    __gnat_dup2\t\t\t            (int, int);\n+extern int    __gnat_file_exists\t\t         (char *);\n+extern int    __gnat_is_regular_file         (char *);\n+extern int    __gnat_is_absolute_path        (char *,int);\n+extern int    __gnat_is_directory\t\t      (char *);\n extern int    __gnat_is_writable_file\t\t   (char *);\n extern int    __gnat_is_readable_file\t\t   (char *name);\n-extern int    __gnat_is_executable_file            (char *name);\n+extern int    __gnat_is_executable_file      (char *name);\n+\n+extern void reset_attributes (struct file_attributes* attr);\n+extern long   __gnat_file_length_attr        (int, char *, struct file_attributes *);\n+extern OS_Time __gnat_file_time_name_attr    (char *, struct file_attributes *);\n+extern OS_Time __gnat_file_time_fd_attr      (int,    struct file_attributes *);\n+extern int    __gnat_file_exists_attr        (char *, struct file_attributes *);\n+extern int    __gnat_is_regular_file_attr    (char *, struct file_attributes *);\n+extern int    __gnat_is_directory_attr       (char *, struct file_attributes *);\n+extern int    __gnat_is_readable_file_attr   (char *, struct file_attributes *);\n+extern int    __gnat_is_writable_file_attr   (char *, struct file_attributes *);\n+extern int    __gnat_is_executable_file_attr (char *, struct file_attributes *);\n+extern int    __gnat_is_symbolic_link_attr   (char *, struct file_attributes *);\n+\n extern void   __gnat_set_non_writable              (char *name);\n extern void   __gnat_set_writable                  (char *name);\n extern void   __gnat_set_executable                (char *name);"}, {"sha": "18739e878edc953433e57432137df09a5233f41d", "filename": "gcc/ada/bcheck.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48263c9aa078ffcec15682edc05724f21d87bfc3/gcc%2Fada%2Fbcheck.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48263c9aa078ffcec15682edc05724f21d87bfc3/gcc%2Fada%2Fbcheck.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbcheck.adb?ref=48263c9aa078ffcec15682edc05724f21d87bfc3", "patch": "@@ -190,7 +190,7 @@ package body Bcheck is\n \n                else\n                   ALI_Path_Id :=\n-                    Osint.Find_File ((ALIs.Table (A).Afile), Osint.Library);\n+                    Osint.Full_Lib_File_Name (ALIs.Table (A).Afile);\n                   if Osint.Is_Readonly_Library (ALI_Path_Id) then\n                      if Tolerate_Consistency_Errors then\n                         Error_Msg (\"?{ should be recompiled\");"}, {"sha": "7037d6432a8cedfeceac816b58aec2101c8cef26", "filename": "gcc/ada/make.adb", "status": "modified", "additions": 522, "deletions": 458, "changes": 980, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48263c9aa078ffcec15682edc05724f21d87bfc3/gcc%2Fada%2Fmake.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48263c9aa078ffcec15682edc05724f21d87bfc3/gcc%2Fada%2Fmake.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmake.adb?ref=48263c9aa078ffcec15682edc05724f21d87bfc3", "patch": "@@ -106,13 +106,17 @@ package body Make is\n       Full_Source_File : File_Name_Type;\n       Lib_File         : File_Name_Type;\n       Source_Unit      : Unit_Name_Type;\n+      Full_Lib_File    : File_Name_Type;\n+      Lib_File_Attr    : aliased File_Attributes;\n       Mapping_File     : Natural := No_Mapping_File;\n       Project          : Project_Id := No_Project;\n-      Syntax_Only      : Boolean := False;\n-      Output_Is_Object : Boolean := True;\n    end record;\n    --  Data recorded for each compilation process spawned\n \n+   No_Compilation_Data : constant Compilation_Data :=\n+     (Invalid_Pid, No_File, No_File, No_Unit_Name, No_File, Unknown_Attributes,\n+      No_Mapping_File, No_Project);\n+\n    type Comp_Data_Arr is array (Positive range <>) of Compilation_Data;\n    type Comp_Data_Ptr is access Comp_Data_Arr;\n    Running_Compile : Comp_Data_Ptr;\n@@ -741,6 +745,7 @@ package body Make is\n       The_Args       : Argument_List;\n       Lib_File       : File_Name_Type;\n       Full_Lib_File  : File_Name_Type;\n+      Lib_File_Attr  : access File_Attributes;\n       Read_Only      : Boolean;\n       ALI            : out ALI_Id;\n       O_File         : out File_Name_Type;\n@@ -752,7 +757,9 @@ package body Make is\n    --  up-to-date, then the corresponding source file needs to be recompiled.\n    --  In this case ALI = No_ALI_Id.\n    --  Full_Lib_File must be the result of calling Osint.Full_Lib_File_Name on\n-   --  Lib_File. Precomputing it saves system calls.\n+   --  Lib_File. Precomputing it saves system calls. Lib_File_Attr is the\n+   --  initialized attributes of that file, which is also used to save on\n+   --  system calls (it can safely be initialized to Unknown_Attributes).\n \n    procedure Check_Linker_Options\n      (E_Stamp : Time_Stamp_Type;\n@@ -1418,6 +1425,7 @@ package body Make is\n       The_Args       : Argument_List;\n       Lib_File       : File_Name_Type;\n       Full_Lib_File  : File_Name_Type;\n+      Lib_File_Attr  : access File_Attributes;\n       Read_Only      : Boolean;\n       ALI            : out ALI_Id;\n       O_File         : out File_Name_Type;\n@@ -1577,12 +1585,12 @@ package body Make is\n                                                Check_Object_Consistency;\n          begin\n             Check_Object_Consistency := False;\n-            Text := Read_Library_Info_From_Full (Full_Lib_File);\n+            Text := Read_Library_Info_From_Full (Full_Lib_File, Lib_File_Attr);\n             Check_Object_Consistency := Saved_Check_Object_Consistency;\n          end;\n \n       else\n-         Text := Read_Library_Info_From_Full (Full_Lib_File);\n+         Text := Read_Library_Info_From_Full (Full_Lib_File, Lib_File_Attr);\n       end if;\n \n       Full_Obj_File := Full_Object_File_Name;\n@@ -2418,62 +2426,22 @@ package body Make is\n       Initialize_ALI_Data   : Boolean  := True;\n       Max_Process           : Positive := 1)\n    is\n-      Source_Unit : Unit_Name_Type;\n-      --  Current source unit\n-\n-      Source_File : File_Name_Type;\n-      --  Current source file\n-\n-      Full_Source_File : File_Name_Type;\n-      --  Full name of the current source file\n-\n-      Lib_File : File_Name_Type;\n-      --  Current library file\n-\n-      Full_Lib_File : File_Name_Type;\n-      --  Full name of the current library file\n-\n-      Obj_File : File_Name_Type;\n-      --  Full name of the object file corresponding to Lib_File\n-\n-      Obj_Stamp : Time_Stamp_Type;\n-      --  Time stamp of the current object file\n-\n-      Sfile : File_Name_Type;\n-      --  Contains the source file of the units withed by Source_File\n-\n-      Uname : Unit_Name_Type;\n-      --  Contains the unit name of the units withed by Source_File\n-\n-      ALI : ALI_Id;\n-      --  ALI Id of the current ALI file\n-\n-      --  Comment following declarations ???\n-\n-      Read_Only : Boolean := False;\n-\n-      Compilation_OK  : Boolean;\n-      Need_To_Compile : Boolean;\n-\n-      Pid  : Process_Id;\n-      Text : Text_Buffer_Ptr;\n-\n-      Mfile : Natural := No_Mapping_File;\n+      Mfile            : Natural := No_Mapping_File;\n+      Mapping_File_Arg : String_Access;\n+      --  Info on the mapping file\n \n       Need_To_Check_Standard_Library : Boolean :=\n                                          Check_Readonly_Files\n                                            and not Unique_Compile;\n \n-      Mapping_File_Arg : String_Access;\n-\n-      Process_Created : Boolean := False;\n-\n       procedure Add_Process\n-        (Pid   : Process_Id;\n-         Sfile : File_Name_Type;\n-         Afile : File_Name_Type;\n-         Uname : Unit_Name_Type;\n-         Mfile : Natural := No_Mapping_File);\n+        (Pid           : Process_Id;\n+         Sfile         : File_Name_Type;\n+         Afile         : File_Name_Type;\n+         Uname         : Unit_Name_Type;\n+         Full_Lib_File : File_Name_Type;\n+         Lib_File_Attr : File_Attributes;\n+         Mfile         : Natural := No_Mapping_File);\n       --  Adds process Pid to the current list of outstanding compilation\n       --  processes and record the full name of the source file Sfile that\n       --  we are compiling, the name of its library file Afile and the\n@@ -2482,27 +2450,32 @@ package body Make is\n       --  array The_Mapping_File_Names.\n \n       procedure Await_Compile\n-        (Sfile : out File_Name_Type;\n-         Afile : out File_Name_Type;\n-         Uname : out Unit_Name_Type;\n+        (Data  : out Compilation_Data;\n          OK    : out Boolean);\n       --  Awaits that an outstanding compilation process terminates. When\n-      --  it does set Sfile to the name of the source file that was compiled\n-      --  Afile to the name of its library file and Uname to the name of its\n-      --  unit. Note that this time stamp can be used to check whether the\n+      --  it does set Data to the information registered for the corresponding\n+      --  call to Add_Process.\n+      --  Note that this time stamp can be used to check whether the\n       --  compilation did generate an object file. OK is set to True if the\n-      --  compilation succeeded. Note that Sfile, Afile and Uname could be\n-      --  resp. No_File, No_File and No_Name  if there were no compilations\n-      --  to wait for.\n+      --  compilation succeeded.\n+      --  Data could be No_Compilation_Data if there was no compilation to wait\n+      --  for.\n \n       function Bad_Compilation_Count return Natural;\n       --  Returns the number of compilation failures\n \n       procedure Check_Standard_Library;\n       --  Check if s-stalib.adb needs to be compiled\n \n-      procedure Collect_Arguments_And_Compile (Source_Index : Int);\n-      --  Collect arguments from project file (if any) and compile\n+      procedure Collect_Arguments_And_Compile\n+        (Full_Source_File : File_Name_Type;\n+         Lib_File         : File_Name_Type;\n+         Source_Index     : Int;\n+         Pid              : out Process_Id;\n+         Process_Created  : out Boolean);\n+      --  Collect arguments from project file (if any) and compile.\n+      --  If no compilation was attempted, Processed_Created is set to False,\n+      --  and the value of Pid is unknown.\n \n       function Compile\n         (Project      : Project_Id;\n@@ -2545,31 +2518,57 @@ package body Make is\n       procedure Record_Good_ALI (A : ALI_Id);\n       --  Records in the previous set the Id of an ALI file\n \n+      function Must_Exit_Because_Of_Error return Boolean;\n+      --  Return True if there were errors and the user decided to exit in such\n+      --  a case. This waits for any outstanding compilation.\n+\n+      function Start_Compile_If_Possible (Args : Argument_List) return Boolean;\n+      --  Check if there is more work that we can do (i.e. the Queue is non\n+      --  empty). If there is, do it only if we have not yet used up all the\n+      --  available processes.\n+      --  Returns True if we should exit the main loop\n+\n+      procedure Wait_For_Available_Slot;\n+      --  Check if we should wait for a compilation to finish. This is the case\n+      --  if all the available processes are busy compiling sources or there is\n+      --  nothing else to do (that is the Q is empty and there are no good ALIs\n+      --  to process).\n+\n+      procedure Fill_Queue_From_ALI_Files;\n+      --  Check if we recorded good ALI files. If yes process them now in the\n+      --  order in which they have been recorded. There are two occasions in\n+      --  which we record good ali files. The first is in phase 1 when, after\n+      --  scanning an existing ALI file we realize it is up-to-date, the second\n+      --  instance is after a successful compilation.\n+\n       -----------------\n       -- Add_Process --\n       -----------------\n \n       procedure Add_Process\n-        (Pid   : Process_Id;\n-         Sfile : File_Name_Type;\n-         Afile : File_Name_Type;\n-         Uname : Unit_Name_Type;\n-         Mfile : Natural := No_Mapping_File)\n+        (Pid           : Process_Id;\n+         Sfile         : File_Name_Type;\n+         Afile         : File_Name_Type;\n+         Uname         : Unit_Name_Type;\n+         Full_Lib_File : File_Name_Type;\n+         Lib_File_Attr : File_Attributes;\n+         Mfile         : Natural := No_Mapping_File)\n       is\n          OC1 : constant Positive := Outstanding_Compiles + 1;\n \n       begin\n          pragma Assert (OC1 <= Max_Process);\n          pragma Assert (Pid /= Invalid_Pid);\n \n-         Running_Compile (OC1).Pid              := Pid;\n-         Running_Compile (OC1).Full_Source_File := Sfile;\n-         Running_Compile (OC1).Lib_File         := Afile;\n-         Running_Compile (OC1).Source_Unit      := Uname;\n-         Running_Compile (OC1).Mapping_File     := Mfile;\n-         Running_Compile (OC1).Project          := Arguments_Project;\n-         Running_Compile (OC1).Syntax_Only      := Syntax_Only;\n-         Running_Compile (OC1).Output_Is_Object := Output_Is_Object;\n+         Running_Compile (OC1) :=\n+           (Pid => Pid,\n+            Full_Source_File => Sfile,\n+            Lib_File         => Afile,\n+            Full_Lib_File    => Full_Lib_File,\n+            Lib_File_Attr    => Lib_File_Attr,\n+            Source_Unit      => Uname,\n+            Mapping_File     => Mfile,\n+            Project          => Arguments_Project);\n \n          Outstanding_Compiles := OC1;\n       end Add_Process;\n@@ -2579,21 +2578,17 @@ package body Make is\n       -------------------\n \n       procedure Await_Compile\n-        (Sfile  : out File_Name_Type;\n-         Afile  : out File_Name_Type;\n-         Uname  : out Unit_Name_Type;\n-         OK     : out Boolean)\n+        (Data  : out Compilation_Data;\n+         OK    : out Boolean)\n       is\n          Pid     : Process_Id;\n          Project : Project_Id;\n-         Data    : Project_Compilation_Access;\n+         Comp_Data : Project_Compilation_Access;\n \n       begin\n          pragma Assert (Outstanding_Compiles > 0);\n \n-         Sfile := No_File;\n-         Afile := No_File;\n-         Uname := No_Unit_Name;\n+         Data  := No_Compilation_Data;\n          OK    := False;\n \n          --  The loop here is a work-around for a problem on VMS; in some\n@@ -2611,21 +2606,19 @@ package body Make is\n \n             for J in Running_Compile'First .. Outstanding_Compiles loop\n                if Pid = Running_Compile (J).Pid then\n-                  Sfile := Running_Compile (J).Full_Source_File;\n-                  Afile := Running_Compile (J).Lib_File;\n-                  Uname := Running_Compile (J).Source_Unit;\n-                  Syntax_Only := Running_Compile (J).Syntax_Only;\n-                  Output_Is_Object := Running_Compile (J).Output_Is_Object;\n+                  Data  := Running_Compile (J);\n                   Project := Running_Compile (J).Project;\n \n                   --  If a mapping file was used by this compilation,\n                   --  get its file name for reuse by a subsequent compilation\n \n                   if Running_Compile (J).Mapping_File /= No_Mapping_File then\n-                     Data := Project_Compilation_Htable.Get\n+                     Comp_Data := Project_Compilation_Htable.Get\n                        (Project_Compilation, Project);\n-                     Data.Last_Free_Indices := Data.Last_Free_Indices + 1;\n-                     Data.Free_Mapping_File_Indices (Data.Last_Free_Indices) :=\n+                     Comp_Data.Last_Free_Indices :=\n+                       Comp_Data.Last_Free_Indices + 1;\n+                     Comp_Data.Free_Mapping_File_Indices\n+                       (Comp_Data.Last_Free_Indices) :=\n                        Running_Compile (J).Mapping_File;\n                   end if;\n \n@@ -2707,11 +2700,13 @@ package body Make is\n       -- Collect_Arguments_And_Compile --\n       -----------------------------------\n \n-      procedure Collect_Arguments_And_Compile (Source_Index : Int) is\n+      procedure Collect_Arguments_And_Compile\n+        (Full_Source_File : File_Name_Type;\n+         Lib_File         : File_Name_Type;\n+         Source_Index     : Int;\n+         Pid              : out Process_Id;\n+         Process_Created  : out Boolean) is\n       begin\n-         --  Process_Created will be set True if an attempt is made to compile\n-         --  the source, that is if it is not in an externally built project.\n-\n          Process_Created := False;\n \n          --  If we use mapping file (-P or -C switches), then get one\n@@ -2759,11 +2754,11 @@ package body Make is\n \n                Pid :=\n                  Compile\n-                   (Arguments_Project,\n-                    File_Name_Type (Arguments_Path_Name),\n-                    Lib_File,\n-                    Source_Index,\n-                    Arguments (1 .. Last_Argument));\n+                   (Project       => Arguments_Project,\n+                    S             => File_Name_Type (Arguments_Path_Name),\n+                    L             => Lib_File,\n+                    Source_Index  => Source_Index,\n+                    Args          => Arguments (1 .. Last_Argument));\n                Process_Created := True;\n             end if;\n \n@@ -2773,11 +2768,11 @@ package body Make is\n \n             Pid :=\n               Compile\n-                (Main_Project,\n-                 Full_Source_File,\n-                 Lib_File,\n-                 Source_Index,\n-                 Arguments (1 .. Last_Argument));\n+                (Project        => Main_Project,\n+                 S              => Full_Source_File,\n+                 L              => Lib_File,\n+                 Source_Index   => Source_Index,\n+                 Args           => Arguments (1 .. Last_Argument));\n             Process_Created := True;\n          end if;\n       end Collect_Arguments_And_Compile;\n@@ -2994,6 +2989,119 @@ package body Make is\n              (Gcc_Path.all, Comp_Args (Args'First .. Comp_Last));\n       end Compile;\n \n+      -------------------------------\n+      -- Fill_Queue_From_ALI_Files --\n+      -------------------------------\n+\n+      procedure Fill_Queue_From_ALI_Files is\n+         ALI          : ALI_Id;\n+         Source_Index : Int;\n+         Sfile        : File_Name_Type;\n+         Uname        : Unit_Name_Type;\n+         Unit_Name    : Name_Id;\n+         Uid          : Prj.Unit_Index;\n+      begin\n+         while Good_ALI_Present loop\n+            ALI          := Get_Next_Good_ALI;\n+            Source_Index := Unit_Index_Of (ALIs.Table (ALI).Afile);\n+\n+            --  If we are processing the library file corresponding to the\n+            --  main source file check if this source can be a main unit.\n+\n+            if ALIs.Table (ALI).Sfile = Main_Source\n+              and then Source_Index = Main_Index\n+            then\n+               Main_Unit := ALIs.Table (ALI).Main_Program /= None;\n+            end if;\n+\n+            --  The following adds the standard library (s-stalib) to the\n+            --  list of files to be handled by gnatmake: this file and any\n+            --  files it depends on are always included in every bind,\n+            --  even if they are not in the explicit dependency list.\n+            --  Of course, it is not added if Suppress_Standard_Library\n+            --  is True.\n+\n+            --  However, to avoid annoying output about s-stalib.ali being\n+            --  read only, when \"-v\" is used, we add the standard library\n+            --  only when \"-a\" is used.\n+\n+            if Need_To_Check_Standard_Library then\n+               Check_Standard_Library;\n+            end if;\n+\n+            --  Now insert in the Q the unmarked source files (i.e. those\n+            --  which have never been inserted in the Q and hence never\n+            --  considered). Only do that if Unique_Compile is False.\n+\n+            if not Unique_Compile then\n+               for J in\n+                 ALIs.Table (ALI).First_Unit .. ALIs.Table (ALI).Last_Unit\n+               loop\n+                  for K in\n+                    Units.Table (J).First_With .. Units.Table (J).Last_With\n+                  loop\n+                     Sfile := Withs.Table (K).Sfile;\n+                     Uname := Withs.Table (K).Uname;\n+\n+                     --  If project files are used, find the proper source\n+                     --  to compile, in case Sfile is the spec, but there\n+                     --  is a body.\n+\n+                     if Main_Project /= No_Project then\n+                        Get_Name_String (Uname);\n+                        Name_Len  := Name_Len - 2;\n+                        Unit_Name := Name_Find;\n+                        Uid :=\n+                          Units_Htable.Get (Project_Tree.Units_HT, Unit_Name);\n+\n+                        if Uid /= Prj.No_Unit_Index then\n+                           if Uid.File_Names (Impl) /= null\n+                             and then not Uid.File_Names (Impl).Locally_Removed\n+                           then\n+                              Sfile        := Uid.File_Names (Impl).File;\n+                              Source_Index := Uid.File_Names (Impl).Index;\n+\n+                           elsif Uid.File_Names (Spec) /= null\n+                             and then not Uid.File_Names (Spec).Locally_Removed\n+                           then\n+                              Sfile        := Uid.File_Names (Spec).File;\n+                              Source_Index := Uid.File_Names (Spec).Index;\n+                           end if;\n+                        end if;\n+                     end if;\n+\n+                     Dependencies.Append ((ALIs.Table (ALI).Sfile, Sfile));\n+\n+                     if Is_In_Obsoleted (Sfile) then\n+                        Executable_Obsolete := True;\n+                     end if;\n+\n+                     if Sfile = No_File then\n+                        Debug_Msg (\"Skipping generic:\", Withs.Table (K).Uname);\n+\n+                     else\n+                        Source_Index := Unit_Index_Of (Withs.Table (K).Afile);\n+\n+                        if Is_Marked (Sfile, Source_Index) then\n+                           Debug_Msg (\"Skipping marked file:\", Sfile);\n+\n+                        elsif not Check_Readonly_Files\n+                          and then Is_Internal_File_Name (Sfile, False)\n+                        then\n+                           Debug_Msg (\"Skipping internal file:\", Sfile);\n+\n+                        else\n+                           Insert_Q\n+                             (Sfile, Withs.Table (K).Uname, Source_Index);\n+                           Mark (Sfile, Source_Index);\n+                        end if;\n+                     end if;\n+                  end loop;\n+               end loop;\n+            end if;\n+         end loop;\n+      end Fill_Queue_From_ALI_Files;\n+\n       ----------------------\n       -- Get_Mapping_File --\n       ----------------------\n@@ -3049,6 +3157,29 @@ package body Make is\n          return Good_ALI.First <= Good_ALI.Last;\n       end Good_ALI_Present;\n \n+      --------------------------------\n+      -- Must_Exit_Because_Of_Error --\n+      --------------------------------\n+\n+      function Must_Exit_Because_Of_Error return Boolean is\n+         Data        : Compilation_Data;\n+         Success     : Boolean;\n+      begin\n+         if Bad_Compilation_Count > 0 and then not Keep_Going then\n+            while Outstanding_Compiles > 0 loop\n+               Await_Compile (Data, Success);\n+\n+               if not Success then\n+                  Record_Failure (Data.Full_Source_File, Data.Source_Unit);\n+               end if;\n+            end loop;\n+\n+            return True;\n+         end if;\n+\n+         return False;\n+      end Must_Exit_Because_Of_Error;\n+\n       --------------------\n       -- Record_Failure --\n       --------------------\n@@ -3073,295 +3204,284 @@ package body Make is\n          Good_ALI.Table (Good_ALI.Last) := A;\n       end Record_Good_ALI;\n \n-   --  Start of processing for Compile_Sources\n-\n-   begin\n-      pragma Assert (Args'First = 1);\n-\n-      Outstanding_Compiles := 0;\n-      Running_Compile := new Comp_Data_Arr (1 .. Max_Process);\n-\n-      --  Package and Queue initializations\n-\n-      Good_ALI.Init;\n-\n-      if First_Q_Initialization then\n-         Init_Q;\n-      end if;\n+      -------------------------------\n+      -- Start_Compile_If_Possible --\n+      -------------------------------\n \n-      if Initialize_ALI_Data then\n-         Initialize_ALI;\n-         Initialize_ALI_Source;\n-      end if;\n-\n-      --  The following two flags affect the behavior of ALI.Set_Source_Table.\n-      --  We set Check_Source_Files to True to ensure that source file\n-      --  time stamps are checked, and we set All_Sources to False to\n-      --  avoid checking the presence of the source files listed in the\n-      --  source dependency section of an ali file (which would be a mistake\n-      --  since the ali file may be obsolete).\n-\n-      Check_Source_Files := True;\n-      All_Sources        := False;\n+      function Start_Compile_If_Possible\n+        (Args : Argument_List) return Boolean\n+      is\n+         In_Lib_Dir       : Boolean;\n+         Need_To_Compile  : Boolean;\n+         Pid              : Process_Id;\n+         Process_Created  : Boolean;\n+\n+         Source_File      : File_Name_Type;\n+         Full_Source_File : File_Name_Type;\n+         Source_File_Attr : aliased File_Attributes;\n+         --  The full name of the source file, and its attributes (size,...)\n+\n+         Source_Unit      : Unit_Name_Type;\n+         Source_Index     : Int;\n+         --  Index of the current unit in the current source file\n+\n+         Lib_File         : File_Name_Type;\n+         Full_Lib_File    : File_Name_Type;\n+         Lib_File_Attr    : aliased File_Attributes;\n+         Read_Only        : Boolean := False;\n+         ALI              : ALI_Id;\n+         --  The ALI file and its attributes (size, stamp,...)\n+\n+         Obj_File         : File_Name_Type;\n+         Obj_Stamp        : Time_Stamp_Type;\n+         --  The object file\n \n-      --  Only insert in the Q if it is not already done, to avoid simultaneous\n-      --  compilations if -jnnn is used.\n+      begin\n+         if not Empty_Q and then Outstanding_Compiles < Max_Process then\n+            Extract_From_Q (Source_File, Source_Unit, Source_Index);\n \n-      if not Is_Marked (Main_Source, Main_Index) then\n-         Insert_Q (Main_Source, Index => Main_Index);\n-         Mark (Main_Source, Main_Index);\n-      end if;\n+            Osint.Full_Source_Name\n+              (Source_File,\n+               Full_File => Full_Source_File,\n+               Attr      => Source_File_Attr'Access);\n \n-      First_Compiled_File   := No_File;\n-      Most_Recent_Obj_File  := No_File;\n-      Most_Recent_Obj_Stamp := Empty_Time_Stamp;\n-      Main_Unit             := False;\n+            Lib_File := Osint.Lib_File_Name (Source_File, Source_Index);\n+            Osint.Full_Lib_File_Name\n+              (Lib_File,\n+               Lib_File => Full_Lib_File,\n+               Attr     => Lib_File_Attr);\n \n-      --  Keep looping until there is no more work to do (the Q is empty)\n-      --  and all the outstanding compilations have terminated\n+            --  If this source has already been compiled, the executable is\n+            --  obsolete.\n \n-      Make_Loop : while not Empty_Q or else Outstanding_Compiles > 0 loop\n+            if Is_In_Obsoleted (Source_File) then\n+               Executable_Obsolete := True;\n+            end if;\n \n-         --  If the user does not want to keep going in case of errors then\n-         --  wait for the remaining outstanding compiles and then exit.\n+            In_Lib_Dir := Full_Lib_File /= No_File\n+              and then In_Ada_Lib_Dir (Full_Lib_File);\n \n-         if Bad_Compilation_Count > 0 and then not Keep_Going then\n-            while Outstanding_Compiles > 0 loop\n-               Await_Compile\n-                 (Full_Source_File, Lib_File, Source_Unit, Compilation_OK);\n+            --  Since the following requires a system call, we precompute it\n+            --  when needed\n \n-               if not Compilation_OK then\n-                  Record_Failure (Full_Source_File, Source_Unit);\n+            if not In_Lib_Dir then\n+               if Full_Lib_File /= No_File\n+                 and then not Check_Readonly_Files\n+               then\n+                  Get_Name_String (Full_Lib_File);\n+                  Name_Buffer (Name_Len + 1) := ASCII.NUL;\n+                  Read_Only := not Is_Writable_File\n+                    (Name_Buffer'Address, Lib_File_Attr'Access);\n+               else\n+                  Read_Only := False;\n                end if;\n-            end loop;\n-\n-            exit Make_Loop;\n-         end if;\n-\n-         --  PHASE 1: Check if there is more work that we can do (i.e. the Q\n-         --  is non empty). If there is, do it only if we have not yet used\n-         --  up all the available processes.\n-\n-         if not Empty_Q and then Outstanding_Compiles < Max_Process then\n-            declare\n-               In_Lib_Dir   : Boolean;\n-\n-               Source_Index : Int;\n-               --  Index of the current unit in the current source file\n+            end if;\n \n-            begin\n-               Extract_From_Q (Source_File, Source_Unit, Source_Index);\n-               Full_Source_File := Osint.Full_Source_Name (Source_File);\n-               Lib_File         := Osint.Lib_File_Name\n-                 (Source_File, Source_Index);\n+            --  If the library file is an Ada library skip it\n \n-               --  Compute the location of Lib_File (involves system calls)\n-               --  ??? Can we compute at the same time if the file is\n-               --  writable, which would save a system call on some systems\n-               --  (when calling Is_Readonly_Library below)\n+            if In_Lib_Dir then\n+               Verbose_Msg\n+                 (Lib_File,\n+                  \"is in an Ada library\",\n+                  Prefix => \"  \",\n+                  Minimum_Verbosity => Opt.High);\n \n-               Full_Lib_File    := Osint.Full_Lib_File_Name (Lib_File);\n+               --  If the library file is a read-only library skip it, but\n+               --  only if, when using project files, this library file is\n+               --  in the right object directory (a read-only ALI file\n+               --  in the object directory of a project being extended\n+               --  should not be skipped).\n \n-               --  If this source has already been compiled, the executable is\n-               --  obsolete.\n+            elsif Read_Only\n+              and then Is_In_Object_Directory (Source_File, Full_Lib_File)\n+            then\n+               Verbose_Msg\n+                 (Lib_File,\n+                  \"is a read-only library\",\n+                  Prefix => \"  \",\n+                  Minimum_Verbosity => Opt.High);\n \n-               if Is_In_Obsoleted (Source_File) then\n-                  Executable_Obsolete := True;\n-               end if;\n+               --  The source file that we are checking cannot be located\n \n-               In_Lib_Dir := Full_Lib_File /= No_File\n-                 and then In_Ada_Lib_Dir (Full_Lib_File);\n+            elsif Full_Source_File = No_File then\n+               Record_Failure (Source_File, Source_Unit, False);\n \n-               --  Since the following requires a system call, we precompute it\n-               --  when needed\n+               --  Source and library files can be located but are internal\n+               --  files\n \n-               if not In_Lib_Dir then\n-                  Read_Only :=\n-                    Full_Lib_File /= No_File\n-                    and then not Check_Readonly_Files\n-                    and then Is_Readonly_Library (Full_Lib_File);\n+            elsif not Check_Readonly_Files\n+              and then Full_Lib_File /= No_File\n+              and then Is_Internal_File_Name (Source_File, False)\n+            then\n+               if Force_Compilations then\n+                  Fail\n+                    (\"not allowed to compile \"\"\" &\n+                     Get_Name_String (Source_File) &\n+                     \"\"\"; use -a switch, or compile file with \" &\n+                     \"\"\"-gnatg\"\" switch\");\n                end if;\n \n-               --  If the library file is an Ada library skip it\n-\n-               if In_Lib_Dir then\n-                  Verbose_Msg\n-                    (Lib_File,\n-                     \"is in an Ada library\",\n-                     Prefix => \"  \",\n-                     Minimum_Verbosity => Opt.High);\n-\n-                  --  If the library file is a read-only library skip it, but\n-                  --  only if, when using project files, this library file is\n-                  --  in the right object directory (a read-only ALI file\n-                  --  in the object directory of a project being extended\n-                  --  should not be skipped).\n-\n-               elsif Read_Only\n-                 and then Is_In_Object_Directory (Source_File, Full_Lib_File)\n-               then\n-                  Verbose_Msg\n-                    (Lib_File,\n-                     \"is a read-only library\",\n-                     Prefix => \"  \",\n-                     Minimum_Verbosity => Opt.High);\n+               Verbose_Msg\n+                 (Lib_File,\n+                  \"is an internal library\",\n+                  Prefix => \"  \",\n+                  Minimum_Verbosity => Opt.High);\n \n-                  --  The source file that we are checking cannot be located\n+               --  The source file that we are checking can be located\n \n-               elsif Full_Source_File = No_File then\n-                  Record_Failure (Source_File, Source_Unit, False);\n+            else\n+               Collect_Arguments (Source_File, Source_Index,\n+                                  Source_File = Main_Source, Args);\n \n-                  --  Source and library files can be located but are internal\n-                  --  files\n+               --  Do nothing if project of source is externally built\n \n-               elsif not Check_Readonly_Files\n-                 and then Full_Lib_File /= No_File\n-                 and then Is_Internal_File_Name (Source_File, False)\n+               if Arguments_Project = No_Project\n+                 or else not Arguments_Project.Externally_Built\n                then\n-                  if Force_Compilations then\n-                     Fail\n-                       (\"not allowed to compile \"\"\" &\n-                        Get_Name_String (Source_File) &\n-                        \"\"\"; use -a switch, or compile file with \" &\n-                        \"\"\"-gnatg\"\" switch\");\n+                  --  Don't waste any time if we have to recompile anyway\n+\n+                  Obj_Stamp       := Empty_Time_Stamp;\n+                  Need_To_Compile := Force_Compilations;\n+\n+                  if not Force_Compilations then\n+                     Check (Source_File    => Source_File,\n+                            Source_Index   => Source_Index,\n+                            Is_Main_Source => Source_File = Main_Source,\n+                            The_Args       => Args,\n+                            Lib_File       => Lib_File,\n+                            Full_Lib_File  => Full_Lib_File,\n+                            Lib_File_Attr  => Lib_File_Attr'Access,\n+                            Read_Only      => Read_Only,\n+                            ALI            => ALI,\n+                            O_File         => Obj_File,\n+                            O_Stamp        => Obj_Stamp);\n+                     Need_To_Compile := (ALI = No_ALI_Id);\n                   end if;\n \n-                  Verbose_Msg\n-                    (Lib_File,\n-                     \"is an internal library\",\n-                     Prefix => \"  \",\n-                     Minimum_Verbosity => Opt.High);\n-\n-               --  The source file that we are checking can be located\n+                  if not Need_To_Compile then\n+                     --  The ALI file is up-to-date. Record its Id\n \n-               else\n-                  Collect_Arguments (Source_File, Source_Index,\n-                                     Source_File = Main_Source, Args);\n+                     Record_Good_ALI (ALI);\n \n-                  --  Do nothing if project of source is externally built\n+                     --  Record the time stamp of the most recent object\n+                     --  file as long as no (re)compilations are needed.\n \n-                  if Arguments_Project = No_Project\n-                    or else not Arguments_Project.Externally_Built\n-                  then\n-                     --  Don't waste any time if we have to recompile anyway\n-\n-                     Obj_Stamp       := Empty_Time_Stamp;\n-                     Need_To_Compile := Force_Compilations;\n-\n-                     if not Force_Compilations then\n-                        Check (Source_File    => Source_File,\n-                               Source_Index   => Source_Index,\n-                               Is_Main_Source => Source_File = Main_Source,\n-                               The_Args       => Args,\n-                               Lib_File       => Lib_File,\n-                               Full_Lib_File  => Full_Lib_File,\n-                               Read_Only      => Read_Only,\n-                               ALI            => ALI,\n-                               O_File         => Obj_File,\n-                               O_Stamp        => Obj_Stamp);\n-                        Need_To_Compile := (ALI = No_ALI_Id);\n+                     if First_Compiled_File = No_File\n+                       and then (Most_Recent_Obj_File = No_File\n+                                 or else Obj_Stamp > Most_Recent_Obj_Stamp)\n+                     then\n+                        Most_Recent_Obj_File  := Obj_File;\n+                        Most_Recent_Obj_Stamp := Obj_Stamp;\n                      end if;\n \n-                     if not Need_To_Compile then\n-                        --  The ALI file is up-to-date. Record its Id\n-\n-                        Record_Good_ALI (ALI);\n-\n-                        --  Record the time stamp of the most recent object\n-                        --  file as long as no (re)compilations are needed.\n-\n-                        if First_Compiled_File = No_File\n-                          and then (Most_Recent_Obj_File = No_File\n-                                    or else Obj_Stamp > Most_Recent_Obj_Stamp)\n-                        then\n-                           Most_Recent_Obj_File  := Obj_File;\n-                           Most_Recent_Obj_Stamp := Obj_Stamp;\n-                        end if;\n-\n-                     else\n-                        --  Check that switch -x has been used if a source\n-                        --  outside of project files need to be compiled.\n+                  else\n+                     --  Check that switch -x has been used if a source\n+                     --  outside of project files need to be compiled.\n \n-                        if Main_Project /= No_Project\n-                          and then Arguments_Project = No_Project\n-                          and then not External_Unit_Compilation_Allowed\n-                        then\n-                           Make_Failed (\"external source (\"\n-                                        & Get_Name_String (Source_File)\n-                                        & \") is not part of any project;\"\n-                                        & \" cannot be compiled without\"\n-                                        & \" gnatmake switch -x\");\n-                        end if;\n+                     if Main_Project /= No_Project\n+                       and then Arguments_Project = No_Project\n+                       and then not External_Unit_Compilation_Allowed\n+                     then\n+                        Make_Failed (\"external source (\"\n+                                     & Get_Name_String (Source_File)\n+                                     & \") is not part of any project;\"\n+                                     & \" cannot be compiled without\"\n+                                     & \" gnatmake switch -x\");\n+                     end if;\n \n-                        --  Is this the first file we have to compile?\n+                     --  Is this the first file we have to compile?\n \n-                        if First_Compiled_File = No_File then\n-                           First_Compiled_File  := Full_Source_File;\n-                           Most_Recent_Obj_File := No_File;\n+                     if First_Compiled_File = No_File then\n+                        First_Compiled_File  := Full_Source_File;\n+                        Most_Recent_Obj_File := No_File;\n \n-                           if Do_Not_Execute then\n-                              exit Make_Loop;\n-                           end if;\n+                        if Do_Not_Execute then\n+                           --  Exit the main loop\n+                           return True;\n                         end if;\n+                     end if;\n \n-                        if In_Place_Mode then\n+                     if In_Place_Mode then\n+                        if Full_Lib_File = No_File then\n                            --  If the library file was not found, then save\n                            --  the library file near the source file.\n \n-                           if Full_Lib_File = No_File then\n-                              Lib_File := Osint.Lib_File_Name\n-                                (Full_Source_File, Source_Index);\n-                              Full_Lib_File := Lib_File;\n+                           Lib_File := Osint.Lib_File_Name\n+                             (Full_Source_File, Source_Index);\n+                           Full_Lib_File := Lib_File;\n \n-                              --  If the library file was found, then save the\n-                              --  library file in the same place.\n+                        else\n+                           --  If the library file was found, then save the\n+                           --  library file in the same place.\n \n-                           else\n-                              Lib_File := Full_Lib_File;\n-                           end if;\n+                           Lib_File := Full_Lib_File;\n                         end if;\n \n-                        --  Start the compilation and record it. We can do\n-                        --  this because there is at least one free process.\n+                        Lib_File_Attr := Unknown_Attributes;\n \n-                        Collect_Arguments_And_Compile (Source_Index);\n+                     else\n+                        --  We will recompile, so we'll have to guess the\n+                        --  location of the object file based on the command\n+                        --  line switches and object_dir\n \n-                        --  Make sure we could successfully start\n-                        --  the Compilation.\n+                        Full_Lib_File := No_File;\n+                        Lib_File_Attr := Unknown_Attributes;\n+                     end if;\n \n-                        if Process_Created then\n-                           if Pid = Invalid_Pid then\n-                              Record_Failure (Full_Source_File, Source_Unit);\n-                           else\n-                              Add_Process\n-                                (Pid,\n-                                 Full_Source_File,\n-                                 Lib_File,\n-                                 Source_Unit,\n-                                 Mfile);\n-                           end if;\n+                     --  Start the compilation and record it. We can do\n+                     --  this because there is at least one free process.\n+\n+                     Collect_Arguments_And_Compile\n+                       (Full_Source_File => Full_Source_File,\n+                        Lib_File         => Lib_File,\n+                        Source_Index     => Source_Index,\n+                        Pid              => Pid,\n+                        Process_Created  => Process_Created);\n+\n+                     --  Make sure we could successfully start\n+                     --  the Compilation.\n+\n+                     if Process_Created then\n+                        if Pid = Invalid_Pid then\n+                           Record_Failure (Full_Source_File, Source_Unit);\n+                        else\n+                           Add_Process\n+                             (Pid              => Pid,\n+                              Sfile            => Full_Source_File,\n+                              Afile            => Lib_File,\n+                              Uname            => Source_Unit,\n+                              Mfile            => Mfile,\n+                              Full_Lib_File    => Full_Lib_File,\n+                              Lib_File_Attr    => Lib_File_Attr);\n                         end if;\n                      end if;\n                   end if;\n                end if;\n-            end;\n+            end if;\n          end if;\n+         return False;\n+      end Start_Compile_If_Possible;\n \n-         --  PHASE 2: Now check if we should wait for a compilation to\n-         --  finish. This is the case if all the available processes are\n-         --  busy compiling sources or there is nothing else to do\n-         --  (that is the Q is empty and there are no good ALIs to process).\n+      -----------------------------\n+      -- Wait_For_Available_Slot --\n+      -----------------------------\n \n+      procedure Wait_For_Available_Slot is\n+         Compilation_OK   : Boolean;\n+         Text             : Text_Buffer_Ptr;\n+         ALI              : ALI_Id;\n+         Data             : Compilation_Data;\n+\n+      begin\n          if Outstanding_Compiles = Max_Process\n            or else (Empty_Q\n-                     and then not Good_ALI_Present\n-                     and then Outstanding_Compiles > 0)\n+                    and then not Good_ALI_Present\n+                    and then Outstanding_Compiles > 0)\n          then\n-            Await_Compile\n-              (Full_Source_File, Lib_File, Source_Unit, Compilation_OK);\n+            Await_Compile (Data, Compilation_OK);\n \n             if not Compilation_OK then\n-               Record_Failure (Full_Source_File, Source_Unit);\n+               Record_Failure (Data.Full_Source_File, Data.Source_Unit);\n             end if;\n \n             if Compilation_OK or else Keep_Going then\n@@ -3382,7 +3502,7 @@ package body Make is\n                     and Compilation_OK\n                     and (Output_Is_Object or Do_Bind_Step);\n \n-                  if Full_Lib_File = No_File then\n+                  if Data.Full_Lib_File = No_File then\n                      --  Compute the expected location of the ALI file. This\n                      --  can be from several places:\n                      --    -i => in place mode. In such a case, Full_Lib_File\n@@ -3396,14 +3516,21 @@ package body Make is\n                      if Object_Directory_Path /= null then\n                         Name_Len := 0;\n                         Add_Str_To_Name_Buffer (Object_Directory_Path.all);\n-                        Add_Str_To_Name_Buffer (Get_Name_String (Lib_File));\n-                        Full_Lib_File := Name_Find;\n+                        Add_Str_To_Name_Buffer\n+                          (Get_Name_String (Data.Lib_File));\n+                        Data.Full_Lib_File := Name_Find;\n                      else\n-                        Full_Lib_File := Lib_File;\n+                        Data.Full_Lib_File := Data.Lib_File;\n                      end if;\n+\n+                     --  Invalidate the cache for the attributes, since the\n+                     --  file was just created\n+\n+                     Data.Lib_File_Attr := Unknown_Attributes;\n                   end if;\n \n-                  Text := Read_Library_Info_From_Full (Full_Lib_File);\n+                  Text := Read_Library_Info_From_Full\n+                    (Data.Full_Lib_File, Data.Lib_File_Attr'Access);\n \n                   --  Restore Check_Object_Consistency to its initial value\n \n@@ -3417,24 +3544,27 @@ package body Make is\n                --  the unit just compiled.\n \n                if Text /= null then\n-                  ALI :=\n-                    Scan_ALI (Lib_File, Text, Ignore_ED => False, Err => True);\n+                  ALI := Scan_ALI\n+                    (Data.Lib_File, Text, Ignore_ED => False, Err => True);\n \n                   if ALI = No_ALI_Id then\n \n                      --  Record a failure only if not already done\n \n                      if Compilation_OK then\n                         Inform\n-                          (Lib_File,\n+                          (Data.Lib_File,\n                            \"incompatible ALI file, please recompile\");\n-                        Record_Failure (Full_Source_File, Source_Unit);\n+                        Record_Failure\n+                          (Data.Full_Source_File, Data.Source_Unit);\n                      end if;\n+\n                   else\n-                     Free (Text);\n                      Record_Good_ALI (ALI);\n                   end if;\n \n+                  Free (Text);\n+\n                --  If we could not read the ALI file that was just generated\n                --  then there could be a problem reading either the ALI or the\n                --  corresponding object file (if Check_Object_Consistency is\n@@ -3445,137 +3575,71 @@ package body Make is\n                else\n                   if Compilation_OK and not Syntax_Only then\n                      Inform\n-                       (Lib_File,\n+                       (Data.Lib_File,\n                         \"WARNING: ALI or object file not found after compile\");\n-                     Record_Failure (Full_Source_File, Source_Unit);\n+                     Record_Failure (Data.Full_Source_File, Data.Source_Unit);\n                   end if;\n                end if;\n             end if;\n          end if;\n+      end Wait_For_Available_Slot;\n \n-         --  PHASE 3: Check if we recorded good ALI files. If yes process\n-         --  them now in the order in which they have been recorded. There\n-         --  are two occasions in which we record good ali files. The first is\n-         --  in phase 1 when, after scanning an existing ALI file we realize\n-         --  it is up-to-date, the second instance is after a successful\n-         --  compilation.\n-\n-         while Good_ALI_Present loop\n-            ALI := Get_Next_Good_ALI;\n-\n-            declare\n-               Source_Index : Int := Unit_Index_Of (ALIs.Table (ALI).Afile);\n-\n-            begin\n-               --  If we are processing the library file corresponding to the\n-               --  main source file check if this source can be a main unit.\n-\n-               if ALIs.Table (ALI).Sfile = Main_Source and then\n-                 Source_Index = Main_Index\n-               then\n-                  Main_Unit := ALIs.Table (ALI).Main_Program /= None;\n-               end if;\n+   --  Start of processing for Compile_Sources\n \n-               --  The following adds the standard library (s-stalib) to the\n-               --  list of files to be handled by gnatmake: this file and any\n-               --  files it depends on are always included in every bind,\n-               --  even if they are not in the explicit dependency list.\n-               --  Of course, it is not added if Suppress_Standard_Library\n-               --  is True.\n+   begin\n+      pragma Assert (Args'First = 1);\n \n-               --  However, to avoid annoying output about s-stalib.ali being\n-               --  read only, when \"-v\" is used, we add the standard library\n-               --  only when \"-a\" is used.\n+      Outstanding_Compiles := 0;\n+      Running_Compile := new Comp_Data_Arr (1 .. Max_Process);\n \n-               if Need_To_Check_Standard_Library then\n-                  Check_Standard_Library;\n-               end if;\n+      --  Package and Queue initializations\n \n-               --  Now insert in the Q the unmarked source files (i.e. those\n-               --  which have never been inserted in the Q and hence never\n-               --  considered). Only do that if Unique_Compile is False.\n+      Good_ALI.Init;\n \n-               if not Unique_Compile then\n-                  for J in\n-                    ALIs.Table (ALI).First_Unit .. ALIs.Table (ALI).Last_Unit\n-                  loop\n-                     for K in\n-                       Units.Table (J).First_With .. Units.Table (J).Last_With\n-                     loop\n-                        Sfile := Withs.Table (K).Sfile;\n-                        Uname := Withs.Table (K).Uname;\n+      if First_Q_Initialization then\n+         Init_Q;\n+      end if;\n \n-                        --  If project files are used, find the proper source\n-                        --  to compile, in case Sfile is the spec, but there\n-                        --  is a body.\n+      if Initialize_ALI_Data then\n+         Initialize_ALI;\n+         Initialize_ALI_Source;\n+      end if;\n \n-                        if Main_Project /= No_Project then\n-                           declare\n-                              Unit_Name : Name_Id;\n-                              Uid       : Prj.Unit_Index;\n+      --  The following two flags affect the behavior of ALI.Set_Source_Table.\n+      --  We set Check_Source_Files to True to ensure that source file\n+      --  time stamps are checked, and we set All_Sources to False to\n+      --  avoid checking the presence of the source files listed in the\n+      --  source dependency section of an ali file (which would be a mistake\n+      --  since the ali file may be obsolete).\n \n-                           begin\n-                              Get_Name_String (Uname);\n-                              Name_Len := Name_Len - 2;\n-                              Unit_Name := Name_Find;\n-                              Uid :=\n-                                Units_Htable.Get\n-                                  (Project_Tree.Units_HT, Unit_Name);\n-\n-                              if Uid /= Prj.No_Unit_Index then\n-                                 if Uid.File_Names (Impl) /= null\n-                                   and then\n-                                     not Uid.File_Names (Impl).Locally_Removed\n-                                 then\n-                                    Sfile := Uid.File_Names (Impl).File;\n-                                    Source_Index :=\n-                                      Uid.File_Names (Impl).Index;\n-\n-                                 elsif Uid.File_Names (Spec) /= null\n-                                   and then\n-                                     not Uid.File_Names (Spec).Locally_Removed\n-                                 then\n-                                    Sfile := Uid.File_Names (Spec).File;\n-                                    Source_Index :=\n-                                      Uid.File_Names (Spec).Index;\n-                                 end if;\n-                              end if;\n-                           end;\n-                        end if;\n+      Check_Source_Files := True;\n+      All_Sources        := False;\n \n-                        Dependencies.Append ((ALIs.Table (ALI).Sfile, Sfile));\n+      --  Only insert in the Q if it is not already done, to avoid simultaneous\n+      --  compilations if -jnnn is used.\n \n-                        if Is_In_Obsoleted (Sfile) then\n-                           Executable_Obsolete := True;\n-                        end if;\n+      if not Is_Marked (Main_Source, Main_Index) then\n+         Insert_Q (Main_Source, Index => Main_Index);\n+         Mark (Main_Source, Main_Index);\n+      end if;\n \n-                        if Sfile = No_File then\n-                           Debug_Msg\n-                             (\"Skipping generic:\", Withs.Table (K).Uname);\n+      First_Compiled_File   := No_File;\n+      Most_Recent_Obj_File  := No_File;\n+      Most_Recent_Obj_Stamp := Empty_Time_Stamp;\n+      Main_Unit             := False;\n \n-                        else\n-                           Source_Index :=\n-                             Unit_Index_Of (Withs.Table (K).Afile);\n+      --  Keep looping until there is no more work to do (the Q is empty)\n+      --  and all the outstanding compilations have terminated\n \n-                           if Is_Marked (Sfile, Source_Index) then\n-                              Debug_Msg (\"Skipping marked file:\", Sfile);\n+      Make_Loop : while not Empty_Q or else Outstanding_Compiles > 0 loop\n+         exit Make_Loop when Must_Exit_Because_Of_Error;\n+         exit Make_Loop when Start_Compile_If_Possible (Args);\n \n-                           elsif not Check_Readonly_Files\n-                             and then Is_Internal_File_Name (Sfile, False)\n-                           then\n-                              Debug_Msg (\"Skipping internal file:\", Sfile);\n+         Wait_For_Available_Slot;\n \n-                           else\n-                              Insert_Q\n-                                (Sfile, Withs.Table (K).Uname, Source_Index);\n-                              Mark (Sfile, Source_Index);\n-                           end if;\n-                        end if;\n-                     end loop;\n-                  end loop;\n-               end if;\n-            end;\n-         end loop;\n+         --  ??? Should be done as soon as we add a Good_ALI, wouldn't it avoid\n+         --  the need for a list of good ALI ?\n+         Fill_Queue_From_ALI_Files;\n \n          if Display_Compilation_Progress then\n             Write_Str (\"completed \");"}, {"sha": "a47c5944751d02fdd3a431529111583f3607eee4", "filename": "gcc/ada/osint.adb", "status": "modified", "additions": 310, "deletions": 71, "changes": 381, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48263c9aa078ffcec15682edc05724f21d87bfc3/gcc%2Fada%2Fosint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48263c9aa078ffcec15682edc05724f21d87bfc3/gcc%2Fada%2Fosint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fosint.adb?ref=48263c9aa078ffcec15682edc05724f21d87bfc3", "patch": "@@ -94,16 +94,39 @@ package body Osint is\n    --  Update the specified path to replace the prefix with the location\n    --  where GNAT is installed. See the file prefix.c in GCC for details.\n \n-   function Locate_File\n-     (N    : File_Name_Type;\n-      T    : File_Type;\n-      Dir  : Natural;\n-      Name : String) return File_Name_Type;\n+   procedure Locate_File\n+     (N     : File_Name_Type;\n+      T     : File_Type;\n+      Dir   : Natural;\n+      Name  : String;\n+      Found : out File_Name_Type;\n+      Attr  : access File_Attributes);\n    --  See if the file N whose name is Name exists in directory Dir. Dir is an\n    --  index into the Lib_Search_Directories table if T = Library. Otherwise\n    --  if T = Source, Dir is an index into the Src_Search_Directories table.\n    --  Returns the File_Name_Type of the full file name if file found, or\n    --  No_File if not found.\n+   --  On exit, Found is set to the file that was found, and Attr to a cache of\n+   --  its attributes (at least those that have been computed so far). Reusing\n+   --  the cache will save some system calls.\n+   --  Attr is always reset in this call to Unknown_Attributes, even in case of\n+   --  failure\n+\n+   procedure Find_File\n+     (N     : File_Name_Type;\n+      T     : File_Type;\n+      Found : out File_Name_Type;\n+      Attr  : access File_Attributes);\n+   --  A version of Find_File that also returns a cache of the file attributes\n+   --  for later reuse\n+\n+   procedure Smart_Find_File\n+     (N     : File_Name_Type;\n+      T     : File_Type;\n+      Found : out File_Name_Type;\n+      Attr  : out File_Attributes);\n+   --  A version of Smart_Find_File that also returns a cache of the file\n+   --  attributes for later reuse\n \n    function C_String_Length (S : Address) return Integer;\n    --  Returns length of a C string (zero for a null address)\n@@ -212,18 +235,17 @@ package body Osint is\n    function File_Hash (F : File_Name_Type) return File_Hash_Num;\n    --  Compute hash index for use by Simple_HTable\n \n-   package File_Name_Hash_Table is new GNAT.HTable.Simple_HTable (\n-     Header_Num => File_Hash_Num,\n-     Element    => File_Name_Type,\n-     No_Element => No_File,\n-     Key        => File_Name_Type,\n-     Hash       => File_Hash,\n-     Equal      => \"=\");\n+   type File_Info_Cache is record\n+      File : File_Name_Type;\n+      Attr : aliased File_Attributes;\n+   end record;\n+   No_File_Info_Cache : constant File_Info_Cache :=\n+     (No_File, Unknown_Attributes);\n \n-   package File_Stamp_Hash_Table is new GNAT.HTable.Simple_HTable (\n+   package File_Name_Hash_Table is new GNAT.HTable.Simple_HTable (\n      Header_Num => File_Hash_Num,\n-     Element    => Time_Stamp_Type,\n-     No_Element => Empty_Time_Stamp,\n+     Element    => File_Info_Cache,\n+     No_Element => No_File_Info_Cache,\n      Key        => File_Name_Type,\n      Hash       => File_Hash,\n      Equal      => \"=\");\n@@ -959,6 +981,33 @@ package body Osint is\n       return File_Hash_Num (Int (F) rem File_Hash_Num'Range_Length);\n    end File_Hash;\n \n+   -----------------\n+   -- File_Length --\n+   -----------------\n+\n+   function File_Length\n+     (Name : C_File_Name; Attr : access File_Attributes) return Long_Integer\n+   is\n+      function Internal\n+        (F : Integer; N : C_File_Name; A : System.Address) return Long_Integer;\n+      pragma Import (C, Internal, \"__gnat_file_length_attr\");\n+   begin\n+      return Internal (-1, Name, Attr.all'Address);\n+   end File_Length;\n+\n+   ---------------------\n+   -- File_Time_Stamp --\n+   ---------------------\n+\n+   function File_Time_Stamp\n+     (Name : C_File_Name; Attr : access File_Attributes) return OS_Time\n+   is\n+      function Internal (N : C_File_Name; A : System.Address) return OS_Time;\n+      pragma Import (C, Internal, \"__gnat_file_time_name_attr\");\n+   begin\n+      return Internal (Name, Attr.all'Address);\n+   end File_Time_Stamp;\n+\n    ----------------\n    -- File_Stamp --\n    ----------------\n@@ -993,6 +1042,22 @@ package body Osint is\n      (N : File_Name_Type;\n       T : File_Type) return File_Name_Type\n    is\n+      Attr  : aliased File_Attributes;\n+      Found : File_Name_Type;\n+   begin\n+      Find_File (N, T, Found, Attr'Access);\n+      return Found;\n+   end Find_File;\n+\n+   ---------------\n+   -- Find_File --\n+   ---------------\n+\n+   procedure Find_File\n+     (N     : File_Name_Type;\n+      T     : File_Type;\n+      Found : out File_Name_Type;\n+      Attr  : access File_Attributes) is\n    begin\n       Get_Name_String (N);\n \n@@ -1016,15 +1081,18 @@ package body Osint is\n                        (Hostparm.OpenVMS and then\n                         Name_Buffer (Name_Len - 2 .. Name_Len) = \"_dg\")))\n          then\n-            return N;\n+            Found := N;\n+            Attr.all  := Unknown_Attributes;\n+            return;\n \n          --  If we are trying to find the current main file just look in the\n          --  directory where the user said it was.\n \n          elsif Look_In_Primary_Directory_For_Current_Main\n            and then Current_Main = N\n          then\n-            return Locate_File (N, T, Primary_Directory, File_Name);\n+            Locate_File (N, T, Primary_Directory, File_Name, Found, Attr);\n+            return;\n \n          --  Otherwise do standard search for source file\n \n@@ -1042,21 +1110,23 @@ package body Osint is\n                --  return No_File, indicating the file is not a source.\n \n                if File = Error_File_Name then\n-                  return No_File;\n-\n+                  Found := No_File;\n                else\n-                  return File;\n+                  Found := File;\n                end if;\n+\n+               Attr.all := Unknown_Attributes;\n+               return;\n             end if;\n \n             --  First place to look is in the primary directory (i.e. the same\n             --  directory as the source) unless this has been disabled with -I-\n \n             if Opt.Look_In_Primary_Dir then\n-               File := Locate_File (N, T, Primary_Directory, File_Name);\n+               Locate_File (N, T, Primary_Directory, File_Name, Found, Attr);\n \n-               if File /= No_File then\n-                  return File;\n+               if Found /= No_File then\n+                  return;\n                end if;\n             end if;\n \n@@ -1069,14 +1139,15 @@ package body Osint is\n             end if;\n \n             for D in Primary_Directory + 1 .. Last_Dir loop\n-               File := Locate_File (N, T, D, File_Name);\n+               Locate_File (N, T, D, File_Name, Found, Attr);\n \n-               if File /= No_File then\n-                  return File;\n+               if Found /= No_File then\n+                  return;\n                end if;\n             end loop;\n \n-            return No_File;\n+            Attr.all := Unknown_Attributes;\n+            Found := No_File;\n          end if;\n       end;\n    end Find_File;\n@@ -1148,9 +1219,28 @@ package body Osint is\n    -- Full_Lib_File_Name --\n    ------------------------\n \n+   procedure Full_Lib_File_Name\n+     (N        : File_Name_Type;\n+      Lib_File : out File_Name_Type;\n+      Attr     : out File_Attributes)\n+   is\n+      A : aliased File_Attributes;\n+   begin\n+      --  ??? seems we could use Smart_Find_File here\n+      Find_File (N, Library, Lib_File, A'Access);\n+      Attr := A;\n+   end Full_Lib_File_Name;\n+\n+   ------------------------\n+   -- Full_Lib_File_Name --\n+   ------------------------\n+\n    function Full_Lib_File_Name (N : File_Name_Type) return File_Name_Type is\n+      Attr : File_Attributes;\n+      File : File_Name_Type;\n    begin\n-      return Find_File (N, Library);\n+      Full_Lib_File_Name (N, File, Attr);\n+      return File;\n    end Full_Lib_File_Name;\n \n    ----------------------------\n@@ -1189,6 +1279,18 @@ package body Osint is\n       return Smart_Find_File (N, Source);\n    end Full_Source_Name;\n \n+   ----------------------\n+   -- Full_Source_Name --\n+   ----------------------\n+\n+   procedure Full_Source_Name\n+     (N         : File_Name_Type;\n+      Full_File : out File_Name_Type;\n+      Attr      : access File_Attributes) is\n+   begin\n+      Smart_Find_File (N, Source, Full_File, Attr.all);\n+   end Full_Source_Name;\n+\n    -------------------\n    -- Get_Directory --\n    -------------------\n@@ -1470,6 +1572,19 @@ package body Osint is\n       Lib_Search_Directories.Table (Primary_Directory) := new String'(\"\");\n    end Initialize;\n \n+   ------------------\n+   -- Is_Directory --\n+   ------------------\n+\n+   function Is_Directory\n+     (Name : C_File_Name; Attr : access File_Attributes) return Boolean\n+   is\n+      function Internal (N : C_File_Name; A : System.Address) return Integer;\n+      pragma Import (C, Internal, \"__gnat_is_directory_attr\");\n+   begin\n+      return Internal (Name, Attr.all'Address) /= 0;\n+   end Is_Directory;\n+\n    ----------------------------\n    -- Is_Directory_Separator --\n    ----------------------------\n@@ -1501,6 +1616,71 @@ package body Osint is\n       return not Is_Writable_File (Name_Buffer (1 .. Name_Len));\n    end Is_Readonly_Library;\n \n+   ------------------------\n+   -- Is_Executable_File --\n+   ------------------------\n+\n+   function Is_Executable_File\n+     (Name : C_File_Name; Attr : access File_Attributes) return Boolean\n+   is\n+      function Internal (N : C_File_Name; A : System.Address) return Integer;\n+      pragma Import (C, Internal, \"__gnat_is_executable_file_attr\");\n+   begin\n+      return Internal (Name, Attr.all'Address) /= 0;\n+   end Is_Executable_File;\n+\n+   ----------------------\n+   -- Is_Readable_File --\n+   ----------------------\n+\n+   function Is_Readable_File\n+     (Name : C_File_Name; Attr : access File_Attributes) return Boolean\n+   is\n+      function Internal (N : C_File_Name; A : System.Address) return Integer;\n+      pragma Import (C, Internal, \"__gnat_is_readable_file_attr\");\n+   begin\n+      return Internal (Name, Attr.all'Address) /= 0;\n+   end Is_Readable_File;\n+\n+   ---------------------\n+   -- Is_Regular_File --\n+   ---------------------\n+\n+   function Is_Regular_File\n+     (Name : C_File_Name; Attr : access File_Attributes) return Boolean\n+   is\n+      function Internal (N : C_File_Name; A : System.Address) return Integer;\n+      pragma Import (C, Internal, \"__gnat_is_regular_file_attr\");\n+   begin\n+      return Internal (Name, Attr.all'Address) /= 0;\n+   end Is_Regular_File;\n+\n+   ----------------------\n+   -- Is_Symbolic_Link --\n+   ----------------------\n+\n+   function Is_Symbolic_Link\n+     (Name : C_File_Name; Attr : access File_Attributes) return Boolean\n+   is\n+      function Internal (N : C_File_Name; A : System.Address) return Integer;\n+      pragma Import (C, Internal, \"__gnat_is_symbolic_link_attr\");\n+   begin\n+      return Internal (Name, Attr.all'Address) /= 0;\n+   end Is_Symbolic_Link;\n+\n+   ----------------------\n+   -- Is_Writable_File --\n+   ----------------------\n+\n+   function Is_Writable_File\n+     (Name : C_File_Name; Attr : access File_Attributes) return Boolean\n+   is\n+      function Internal (N : C_File_Name; A : System.Address) return Integer;\n+      pragma Import (C, Internal, \"__gnat_is_writable_file_attr\");\n+   begin\n+      return Internal (Name, Attr.all'Address) /= 0;\n+   end Is_Writable_File;\n+\n    -------------------\n    -- Lib_File_Name --\n    -------------------\n@@ -1533,11 +1713,13 @@ package body Osint is\n    -- Locate_File --\n    -----------------\n \n-   function Locate_File\n-     (N    : File_Name_Type;\n-      T    : File_Type;\n-      Dir  : Natural;\n-      Name : String) return File_Name_Type\n+   procedure Locate_File\n+     (N     : File_Name_Type;\n+      T     : File_Type;\n+      Dir   : Natural;\n+      Name  : String;\n+      Found : out File_Name_Type;\n+      Attr  : access File_Attributes)\n    is\n       Dir_Name : String_Ptr;\n \n@@ -1555,24 +1737,28 @@ package body Osint is\n       end if;\n \n       declare\n-         Full_Name : String (1 .. Dir_Name'Length + Name'Length);\n+         Full_Name : String (1 .. Dir_Name'Length + Name'Length + 1);\n \n       begin\n          Full_Name (1 .. Dir_Name'Length) := Dir_Name.all;\n-         Full_Name (Dir_Name'Length + 1 .. Full_Name'Length) := Name;\n+         Full_Name (Dir_Name'Length + 1 .. Full_Name'Last - 1) := Name;\n+         Full_Name (Full_Name'Last) := ASCII.NUL;\n+\n+         Attr.all := Unknown_Attributes;\n \n-         if not Is_Regular_File (Full_Name) then\n-            return No_File;\n+         if not Is_Regular_File (Full_Name'Address, Attr) then\n+            Found := No_File;\n \n          else\n             --  If the file is in the current directory then return N itself\n \n             if Dir_Name'Length = 0 then\n-               return N;\n+               Found := N;\n             else\n-               Name_Len := Full_Name'Length;\n-               Name_Buffer (1 .. Name_Len) := Full_Name;\n-               return Name_Enter;\n+               Name_Len := Full_Name'Length - 1;\n+               Name_Buffer (1 .. Name_Len) :=\n+                 Full_Name (1 .. Full_Name'Last - 1);\n+               Found := Name_Find;  --  ??? Was Name_Enter, no obvious reason\n             end if;\n          end if;\n       end;\n@@ -1592,11 +1778,13 @@ package body Osint is\n       declare\n          File_Name : constant String := Name_Buffer (1 .. Name_Len);\n          File      : File_Name_Type := No_File;\n+         Attr      : aliased File_Attributes;\n          Last_Dir  : Natural;\n \n       begin\n          if Opt.Look_In_Primary_Dir then\n-            File := Locate_File (N, Source, Primary_Directory, File_Name);\n+            Locate_File\n+              (N, Source, Primary_Directory, File_Name, File, Attr'Access);\n \n             if File /= No_File and then T = File_Stamp (N) then\n                return File;\n@@ -1606,7 +1794,7 @@ package body Osint is\n          Last_Dir := Src_Search_Directories.Last;\n \n          for D in Primary_Directory + 1 .. Last_Dir loop\n-            File := Locate_File (N, Source, D, File_Name);\n+            Locate_File (N, Source, D, File_Name, File, Attr'Access);\n \n             if File /= No_File and then T = File_Stamp (File) then\n                return File;\n@@ -2110,10 +2298,15 @@ package body Osint is\n \n    function Read_Library_Info\n      (Lib_File  : File_Name_Type;\n-      Fatal_Err : Boolean := False) return Text_Buffer_Ptr is\n+      Fatal_Err : Boolean := False) return Text_Buffer_Ptr\n+   is\n+      File : File_Name_Type;\n+      Attr : aliased File_Attributes;\n    begin\n+      Find_File (Lib_File, Library, File, Attr'Access);\n       return Read_Library_Info_From_Full\n-        (Full_Lib_File => Find_File (Lib_File, Library),\n+        (Full_Lib_File => File,\n+         Lib_File_Attr => Attr'Access,\n          Fatal_Err     => Fatal_Err);\n    end Read_Library_Info;\n \n@@ -2123,12 +2316,17 @@ package body Osint is\n \n    function Read_Library_Info_From_Full\n      (Full_Lib_File : File_Name_Type;\n+      Lib_File_Attr : access File_Attributes;\n       Fatal_Err     : Boolean := False) return Text_Buffer_Ptr\n    is\n       Lib_FD : File_Descriptor;\n       --  The file descriptor for the current library file. A negative value\n       --  indicates failure to open the specified source file.\n \n+      Len : Integer;\n+      --  Length of source file text (ALI). If it doesn't fit in an integer\n+      --  we're probably stuck anyway (>2 gigs of source seems a lot!)\n+\n       Text : Text_Buffer_Ptr;\n       --  Allocated text buffer\n \n@@ -2168,17 +2366,32 @@ package body Osint is\n          end if;\n       end if;\n \n+      --  Compute the length of the file (potentially also preparing other data\n+      --  like the timestamp and whether the file is read-only, for future use)\n+\n+      Len := Integer (File_Length (Name_Buffer'Address, Lib_File_Attr));\n+\n       --  Check for object file consistency if requested\n \n       if Opt.Check_Object_Consistency then\n-         Current_Full_Lib_Stamp := File_Stamp (Current_Full_Lib_Name);\n+         --  On most systems, this does not result in an extra system call\n+         Current_Full_Lib_Stamp := OS_Time_To_GNAT_Time\n+           (File_Time_Stamp (Name_Buffer'Address, Lib_File_Attr));\n+\n+         --  ??? One system call here\n          Current_Full_Obj_Stamp := File_Stamp (Current_Full_Obj_Name);\n \n          if Current_Full_Obj_Stamp (1) = ' ' then\n \n             --  When the library is readonly always assume object is consistent\n+            --  The call to Is_Writable_File only results in a system call on\n+            --  some systems, but in most cases it has already been computed as\n+            --  part of the call to File_Length above.\n+\n+            Get_Name_String (Current_Full_Lib_Name);\n+            Name_Buffer (Name_Len + 1) := ASCII.NUL;\n \n-            if Is_Readonly_Library (Current_Full_Lib_Name) then\n+            if not Is_Writable_File (Name_Buffer'Address, Lib_File_Attr) then\n                Current_Full_Obj_Stamp := Current_Full_Lib_Stamp;\n \n             elsif Fatal_Err then\n@@ -2203,10 +2416,6 @@ package body Osint is\n       --  Read data from the file\n \n       declare\n-         Len : constant Integer := Integer (File_Length (Lib_FD));\n-         --  Length of source file text. If it doesn't fit in an integer\n-         --  we're probably stuck anyway (>2 gigs of source seems a lot!)\n-\n          Actual_Len : Integer := 0;\n \n          Lo : constant Text_Ptr := 0;\n@@ -2482,21 +2691,23 @@ package body Osint is\n      (N : File_Name_Type;\n       T : File_Type) return Time_Stamp_Type\n    is\n-      Time_Stamp : Time_Stamp_Type;\n-\n+      File : File_Name_Type;\n+      Attr : aliased File_Attributes;\n    begin\n       if not File_Cache_Enabled then\n-         return File_Stamp (Find_File (N, T));\n+         Find_File (N, T, File, Attr'Access);\n+      else\n+         Smart_Find_File (N, T, File, Attr);\n       end if;\n \n-      Time_Stamp := File_Stamp_Hash_Table.Get (N);\n-\n-      if Time_Stamp (1) = ' ' then\n-         Time_Stamp := File_Stamp (Smart_Find_File (N, T));\n-         File_Stamp_Hash_Table.Set (N, Time_Stamp);\n+      if File = No_File then\n+         return Empty_Time_Stamp;\n+      else\n+         Get_Name_String (File);\n+         Name_Buffer (Name_Len + 1) := ASCII.NUL;\n+         return OS_Time_To_GNAT_Time\n+           (File_Time_Stamp (Name_Buffer'Address, Attr'Access));\n       end if;\n-\n-      return Time_Stamp;\n    end Smart_File_Stamp;\n \n    ---------------------\n@@ -2507,21 +2718,38 @@ package body Osint is\n      (N : File_Name_Type;\n       T : File_Type) return File_Name_Type\n    is\n-      Full_File_Name : File_Name_Type;\n-\n+      File : File_Name_Type;\n+      Attr : File_Attributes;\n    begin\n-      if not File_Cache_Enabled then\n-         return Find_File (N, T);\n-      end if;\n+      Smart_Find_File (N, T, File, Attr);\n+      return File;\n+   end Smart_Find_File;\n \n-      Full_File_Name := File_Name_Hash_Table.Get (N);\n+   ---------------------\n+   -- Smart_Find_File --\n+   ---------------------\n \n-      if Full_File_Name = No_File then\n-         Full_File_Name := Find_File (N, T);\n-         File_Name_Hash_Table.Set (N, Full_File_Name);\n+   procedure Smart_Find_File\n+     (N     : File_Name_Type;\n+      T     : File_Type;\n+      Found : out File_Name_Type;\n+      Attr  : out File_Attributes)\n+   is\n+      Info : File_Info_Cache;\n+\n+   begin\n+      if not File_Cache_Enabled then\n+         Find_File (N, T, Info.File, Info.Attr'Access);\n+      else\n+         Info := File_Name_Hash_Table.Get (N);\n+         if Info.File = No_File then\n+            Find_File (N, T, Info.File, Info.Attr'Access);\n+            File_Name_Hash_Table.Set (N, Info);\n+         end if;\n       end if;\n \n-      return Full_File_Name;\n+      Found := Info.File;\n+      Attr  := Info.Attr;\n    end Smart_Find_File;\n \n    ----------------------\n@@ -2951,6 +3179,9 @@ package body Osint is\n -- Package Initialization --\n ----------------------------\n \n+   procedure Reset_File_Attributes (Attr : System.Address);\n+   pragma Import (C, Reset_File_Attributes, \"reset_attributes\");\n+\n begin\n    Initialization : declare\n \n@@ -2966,7 +3197,15 @@ begin\n                     \"__gnat_get_maximum_file_name_length\");\n       --  Function to get maximum file name length for system\n \n+      Sizeof_File_Attributes : Integer;\n+      pragma Import (C, Sizeof_File_Attributes,\n+                     \"size_of_file_attributes\");\n+\n    begin\n+      pragma Assert (Sizeof_File_Attributes <= File_Attributes_Size);\n+\n+      Reset_File_Attributes (Unknown_Attributes'Address);\n+\n       Identifier_Character_Set := Get_Default_Identifier_Character_Set;\n       Maximum_File_Name_Length := Get_Maximum_File_Name_Length;\n "}, {"sha": "741b28a9da283d81f62572fc7456f9c75088217d", "filename": "gcc/ada/osint.ads", "status": "modified", "additions": 73, "deletions": 1, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48263c9aa078ffcec15682edc05724f21d87bfc3/gcc%2Fada%2Fosint.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48263c9aa078ffcec15682edc05724f21d87bfc3/gcc%2Fada%2Fosint.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fosint.ads?ref=48263c9aa078ffcec15682edc05724f21d87bfc3", "patch": "@@ -29,6 +29,7 @@\n with Namet; use Namet;\n with Types; use Types;\n \n+with System.Storage_Elements;\n with System.OS_Lib; use System.OS_Lib;\n with System;        use System;\n \n@@ -230,6 +231,47 @@ package Osint is\n    --  this routine called with Name set to \"gnat\" will return \"-lgnat-5.02\"\n    --  on UNIX and Windows and -lgnat_5_02 on VMS.\n \n+   ---------------------\n+   -- File attributes --\n+   ---------------------\n+   --  The following subprograms offer services similar to those found in\n+   --  System.OS_Lib, but with the ability to extra multiple information from\n+   --  a single system call, depending on the system. This can result in fewer\n+   --  system calls when reused.\n+   --  In all these subprograms, the requested value is either read from the\n+   --  File_Attributes parameter (resulting in no system call), or computed\n+   --  from the disk and then cached in the File_Attributes parameter (possibly\n+   --  along with other values).\n+\n+   type File_Attributes is private;\n+   Unknown_Attributes : constant File_Attributes;\n+   --  A cache for various attributes for a file (length, accessibility,...)\n+   --  This must be initialized to Unknown_Attributes prior to the first call.\n+\n+   function Is_Directory\n+     (Name : C_File_Name; Attr : access File_Attributes) return Boolean;\n+   function Is_Regular_File\n+     (Name : C_File_Name; Attr : access File_Attributes) return Boolean;\n+   function Is_Symbolic_Link\n+     (Name : C_File_Name; Attr : access File_Attributes) return Boolean;\n+   --  Return the type of the file,\n+\n+   function File_Length\n+     (Name : C_File_Name; Attr : access File_Attributes) return Long_Integer;\n+   --  Return the length (number of bytes) of the file\n+\n+   function File_Time_Stamp\n+     (Name : C_File_Name; Attr : access File_Attributes) return OS_Time;\n+   --  Return the time stamp of the file\n+\n+   function Is_Readable_File\n+     (Name : C_File_Name; Attr : access File_Attributes) return Boolean;\n+   function Is_Executable_File\n+     (Name : C_File_Name; Attr : access File_Attributes) return Boolean;\n+   function Is_Writable_File\n+     (Name : C_File_Name; Attr : access File_Attributes) return Boolean;\n+   --  Return the access rights for the file\n+\n    -------------------------\n    -- Search Dir Routines --\n    -------------------------\n@@ -380,6 +422,10 @@ package Osint is\n    --  using Read_Source_File. Calling this routine entails no source file\n    --  directory lookup penalty.\n \n+   procedure Full_Source_Name\n+     (N         : File_Name_Type;\n+      Full_File : out File_Name_Type;\n+      Attr      : access File_Attributes);\n    function Full_Source_Name (N : File_Name_Type) return File_Name_Type;\n    function Source_File_Stamp (N : File_Name_Type) return Time_Stamp_Type;\n    --  Returns the full name/time stamp of the source file whose simple name\n@@ -390,6 +436,8 @@ package Osint is\n    --  The source file directory lookup penalty is incurred every single time\n    --  the routines are called unless you have previously called\n    --  Source_File_Data (Cache => True). See below.\n+   --  The procedural version also returns some file attributes for the ALI\n+   --  file (to save on system calls later on).\n \n    function Current_File_Index return Int;\n    --  Return the index in its source file of the current main unit\n@@ -488,10 +536,14 @@ package Osint is\n \n    function Read_Library_Info_From_Full\n      (Full_Lib_File : File_Name_Type;\n+      Lib_File_Attr : access File_Attributes;\n       Fatal_Err     : Boolean := False) return Text_Buffer_Ptr;\n    --  Same as Read_Library_Info, except Full_Lib_File must contains the full\n    --  path to the library file (instead of having Read_Library_Info recompute\n-   --  it)\n+   --  it).\n+   --  Lib_File_Attr should be an initialized set of attributes for the\n+   --  library file (it can be initialized to Unknown_Attributes, but in\n+   --  general will have been initialized by a previous call to Find_File).\n \n    function Full_Library_Info_Name return File_Name_Type;\n    function Full_Object_File_Name return File_Name_Type;\n@@ -508,13 +560,19 @@ package Osint is\n    --  It is an error to call Current_Object_File_Stamp if\n    --  Opt.Check_Object_Consistency is set to False.\n \n+   procedure Full_Lib_File_Name\n+     (N        : File_Name_Type;\n+      Lib_File : out File_Name_Type;\n+      Attr     : out File_Attributes);\n    function Full_Lib_File_Name (N : File_Name_Type) return File_Name_Type;\n    --  Returns the full name of library file N. N should not include\n    --  path information. Note that if the file cannot be located No_File is\n    --  returned for the first routine and an all blank time stamp is returned\n    --  for the second (this is not an error situation). The full name includes\n    --  the appropriate directory information. The library file directory lookup\n    --  penalty is incurred every single time this routine is called.\n+   --  The procedural version also returns some file attributes for the ALI\n+   --  file (to save on system calls later on).\n \n    function Lib_File_Name\n      (Source_File : File_Name_Type;\n@@ -660,4 +718,18 @@ private\n    --  detected, the file being written is deleted, and a fatal error is\n    --  signalled.\n \n+   File_Attributes_Size : constant Integer := 50;\n+   --  This should be big enough to fit a \"struct file_attributes\" on any\n+   --  system. It doesn't matter if it is too big (which avoids the need for\n+   --  either mapping the struct exactly or importing the sizeof from C, which\n+   --  would result in dynamic code)\n+\n+   type File_Attributes is\n+     array (1 .. File_Attributes_Size)\n+     of System.Storage_Elements.Storage_Element;\n+\n+   Unknown_Attributes : constant File_Attributes := (others => 0);\n+   --  Will be initialized properly at elaboration (for efficiency later on,\n+   --  avoid function calls every time we want to reset the attributes).\n+\n end Osint;"}]}