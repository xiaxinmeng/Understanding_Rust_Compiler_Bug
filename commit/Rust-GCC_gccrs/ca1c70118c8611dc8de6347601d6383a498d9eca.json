{"sha": "ca1c70118c8611dc8de6347601d6383a498d9eca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2ExYzcwMTE4Yzg2MTFkYzhkZTYzNDc2MDFkNjM4M2E0OThkOWVjYQ==", "commit": {"author": {"name": "Gawain Bolton", "email": "gp.bolton@computer.org", "date": "2003-07-09T20:58:32Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2003-07-09T20:58:32Z"}, "message": "stl_tree.h: Move larger member functions in _Rb_tree_base_iterator and _Rb_tree_node to...\n\n\n2003-07-09  Gawain Bolton  <gp.bolton@computer.org>\n\n\t* include/bits/stl_tree.h: Move larger member functions in\n\t_Rb_tree_base_iterator and _Rb_tree_node to...\n\t* src/stl_tree.cc: Here.\n\t* src/Makefile.in: Add stl_tree.cc.\n\t* src/Makefile.in: Regenerated.\n\t* config/linker-map.gnu: Add symbols here.\n\nFrom-SVN: r69150", "tree": {"sha": "2563a91854f242ee20cb5e919aa383edf7350c59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2563a91854f242ee20cb5e919aa383edf7350c59"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca1c70118c8611dc8de6347601d6383a498d9eca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca1c70118c8611dc8de6347601d6383a498d9eca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca1c70118c8611dc8de6347601d6383a498d9eca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca1c70118c8611dc8de6347601d6383a498d9eca/comments", "author": null, "committer": null, "parents": [{"sha": "c2f82a8421c641148bbec355702b2a3563546c1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2f82a8421c641148bbec355702b2a3563546c1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2f82a8421c641148bbec355702b2a3563546c1d"}], "stats": {"total": 782, "additions": 470, "deletions": 312}, "files": [{"sha": "a5392b4db9d4632cbb7c47685ff4a4f5910093b6", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca1c70118c8611dc8de6347601d6383a498d9eca/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca1c70118c8611dc8de6347601d6383a498d9eca/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=ca1c70118c8611dc8de6347601d6383a498d9eca", "patch": "@@ -1,11 +1,20 @@\n+2003-07-09  Gawain Bolton  <gp.bolton@computer.org>\n+\n+\t* include/bits/stl_tree.h: Move larger member functions in\n+\t_Rb_tree_base_iterator and _Rb_tree_node to...\n+\t* src/stl_tree.cc: Here.\n+\t* src/Makefile.in: Add stl_tree.cc.\n+\t* src/Makefile.in: Regenerated.\n+\t* config/linker-map.gnu: Add symbols here.\n+\n 2003-07-08  Benjamin Kosnik  <bkoz@redhat.com>\n \n \t* testsuite/ext/pod_char_traits.cc: New.\n \t* include/ext/pod_char_traits.h: New.\n \t* include/Makefile.am (ext_headers): Add pod_char_traits.h.\n \t* include/Makefile.in: Regenerate.\n \t* docs/html/21_strings/howto.html: Update.\n-\t\n+\t\t\n 2003-07-08  Gawain Bolton  <gp.bolton@computer.org>\n \n \t* testsuite/performance/list_create_fill_sort.cc: New."}, {"sha": "b633567ddd671fc6d60b797196a9f647928a0787", "filename": "libstdc++-v3/config/linker-map.gnu", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca1c70118c8611dc8de6347601d6383a498d9eca/libstdc%2B%2B-v3%2Fconfig%2Flinker-map.gnu", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca1c70118c8611dc8de6347601d6383a498d9eca/libstdc%2B%2B-v3%2Fconfig%2Flinker-map.gnu", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Flinker-map.gnu?ref=ca1c70118c8611dc8de6347601d6383a498d9eca", "patch": "@@ -73,6 +73,14 @@ GLIBCXX_3.4 {\n     # bool has_facet \n     _ZSt9has_facet*;\n \n+    # _Rb_tree\n+    _ZNSt22_Rb_tree_base_iterator12_M_decrementEv;\n+    _ZNSt22_Rb_tree_base_iterator12_M_incrementEv;\n+    _ZSt18_Rb_tree_rebalancePSt18_Rb_tree_node_baseRS0_;\n+    _ZSt20_Rb_tree_rotate_leftPSt18_Rb_tree_node_baseRS0_;\n+    _ZSt21_Rb_tree_rotate_rightPSt18_Rb_tree_node_baseRS0_;\n+    _ZSt28_Rb_tree_rebalance_for_erasePSt18_Rb_tree_node_baseRS_;\n+\n     # virtual table\n     _ZTVNSt8ios_base7failureE;\n     _ZTVNSt6locale5facetE;"}, {"sha": "9ce52f336e0717b68a1fd27c8f5f6eecb0c24864", "filename": "libstdc++-v3/include/bits/stl_tree.h", "status": "modified", "additions": 11, "deletions": 291, "changes": 302, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca1c70118c8611dc8de6347601d6383a498d9eca/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca1c70118c8611dc8de6347601d6383a498d9eca/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h?ref=ca1c70118c8611dc8de6347601d6383a498d9eca", "patch": "@@ -132,51 +132,10 @@ namespace std\n     _Base_ptr _M_node;\n \n     void \n-    _M_increment()\n-    {\n-      if (_M_node->_M_right != 0) \n-\t{\n-\t  _M_node = _M_node->_M_right;\n-\t  while (_M_node->_M_left != 0)\n-\t    _M_node = _M_node->_M_left;\n-\t}\n-      else \n-\t{\n-\t  _Base_ptr __y = _M_node->_M_parent;\n-\t  while (_M_node == __y->_M_right) \n-\t    {\n-\t      _M_node = __y;\n-\t      __y = __y->_M_parent;\n-\t    }\n-\t  if (_M_node->_M_right != __y)\n-\t    _M_node = __y;\n-\t}\n-    }\n+    _M_increment();\n \n     void \n-    _M_decrement()\n-    {\n-      if (_M_node->_M_color == _S_red \n-\t  && _M_node->_M_parent->_M_parent == _M_node)\n-\t_M_node = _M_node->_M_right;\n-      else if (_M_node->_M_left != 0) \n-\t{\n-\t  _Base_ptr __y = _M_node->_M_left;\n-\t  while (__y->_M_right != 0)\n-\t    __y = __y->_M_right;\n-\t  _M_node = __y;\n-\t}\n-      else \n-\t{\n-\t  _Base_ptr __y = _M_node->_M_parent;\n-\t  while (_M_node == __y->_M_left) \n-\t    {\n-\t      _M_node = __y;\n-\t      __y = __y->_M_parent;\n-\t    }\n-\t  _M_node = __y;\n-\t}\n-    }\n+    _M_decrement();\n   };\n \n   template<typename _Val, typename _Ref, typename _Ptr>\n@@ -264,255 +223,18 @@ namespace std\n \t       const _Rb_tree_iterator<_Val, const _Val&, const _Val*>& __y) \n     { return __x._M_node != __y._M_node; }\n \n-  inline void \n-  _Rb_tree_rotate_left(_Rb_tree_node_base* const __x, _Rb_tree_node_base*& __root)\n-  {\n-    _Rb_tree_node_base* const __y = __x->_M_right;\n-    __x->_M_right = __y->_M_left;\n-    if (__y->_M_left !=0)\n-      __y->_M_left->_M_parent = __x;\n-    __y->_M_parent = __x->_M_parent;\n-    \n-    if (__x == __root)\n-      __root = __y;\n-    else if (__x == __x->_M_parent->_M_left)\n-      __x->_M_parent->_M_left = __y;\n-    else\n-      __x->_M_parent->_M_right = __y;\n-    __y->_M_left = __x;\n-    __x->_M_parent = __y;\n-  }\n+  void \n+  _Rb_tree_rotate_left(_Rb_tree_node_base* const __x, _Rb_tree_node_base*& __root);\n \n-  inline void \n-  _Rb_tree_rotate_right(_Rb_tree_node_base* const __x, _Rb_tree_node_base*& __root)\n-  {\n-    _Rb_tree_node_base* const __y = __x->_M_left;\n-    __x->_M_left = __y->_M_right;\n-    if (__y->_M_right != 0)\n-      __y->_M_right->_M_parent = __x;\n-    __y->_M_parent = __x->_M_parent;\n-\n-    if (__x == __root)\n-      __root = __y;\n-    else if (__x == __x->_M_parent->_M_right)\n-      __x->_M_parent->_M_right = __y;\n-    else\n-      __x->_M_parent->_M_left = __y;\n-    __y->_M_right = __x;\n-    __x->_M_parent = __y;\n-  }\n-\n-  inline void \n-  _Rb_tree_rebalance(_Rb_tree_node_base* __x, _Rb_tree_node_base*& __root)\n-  {\n-    __x->_M_color = _S_red;\n-    while (__x != __root \n-\t   && __x->_M_parent->_M_color == _S_red) \n-      {\n-\t_Rb_tree_node_base* const __xpp = __x->_M_parent->_M_parent;\n+  void \n+  _Rb_tree_rotate_right(_Rb_tree_node_base* const __x, _Rb_tree_node_base*& __root);\n \n-\tif (__x->_M_parent == __xpp->_M_left) \n-\t  {\n-\t    _Rb_tree_node_base* const __y = __xpp->_M_right;\n-\t    if (__y && __y->_M_color == _S_red) \n-\t      {\n-\t\t__x->_M_parent->_M_color = _S_black;\n-\t\t__y->_M_color = _S_black;\n-\t\t__xpp->_M_color = _S_red;\n-\t\t__x = __xpp;\n-\t      }\n-\t    else \n-\t      {\n-\t\tif (__x == __x->_M_parent->_M_right) \n-\t\t  {\n-\t\t    __x = __x->_M_parent;\n-\t\t    _Rb_tree_rotate_left(__x, __root);\n-\t\t  }\n-\t\t__x->_M_parent->_M_color = _S_black;\n-\t\t__xpp->_M_color = _S_red;\n-\t\t_Rb_tree_rotate_right(__xpp, __root);\n-\t      }\n-\t  }\n-\telse \n-\t  {\n-\t    _Rb_tree_node_base* const __y = __xpp->_M_left;\n-\t    if (__y && __y->_M_color == _S_red) \n-\t      {\n-\t\t__x->_M_parent->_M_color = _S_black;\n-\t\t__y->_M_color = _S_black;\n-\t\t__xpp->_M_color = _S_red;\n-\t\t__x = __xpp;\n-\t      }\n-\t    else \n-\t      {\n-\t\tif (__x == __x->_M_parent->_M_left) \n-\t\t  {\n-\t\t    __x = __x->_M_parent;\n-\t\t    _Rb_tree_rotate_right(__x, __root);\n-\t\t  }\n-\t\t__x->_M_parent->_M_color = _S_black;\n-\t\t__xpp->_M_color = _S_red;\n-\t\t_Rb_tree_rotate_left(__xpp, __root);\n-\t      }\n-\t  }\n-      }\n-    __root->_M_color = _S_black;\n-  }\n+  void \n+  _Rb_tree_rebalance(_Rb_tree_node_base* __x, _Rb_tree_node_base*& __root);\n \n-  inline _Rb_tree_node_base*\n+  _Rb_tree_node_base*\n   _Rb_tree_rebalance_for_erase(_Rb_tree_node_base* const __z, \n-\t\t\t       _Rb_tree_node_base*& \t __root,\n-\t\t\t       _Rb_tree_node_base*& \t __leftmost,\n-\t\t\t       _Rb_tree_node_base*& \t __rightmost)\n-  {\n-    _Rb_tree_node_base* __y = __z;\n-    _Rb_tree_node_base* __x = 0;\n-    _Rb_tree_node_base* __x_parent = 0;\n-    if (__y->_M_left == 0)     // __z has at most one non-null child. y == z.\n-      __x = __y->_M_right;     // __x might be null.\n-    else\n-      if (__y->_M_right == 0)  // __z has exactly one non-null child. y == z.\n-\t__x = __y->_M_left;    // __x is not null.\n-      else \n-\t{\n-\t  // __z has two non-null children.  Set __y to\n-\t  __y = __y->_M_right;   //   __z's successor.  __x might be null.\n-\t  while (__y->_M_left != 0)\n-\t    __y = __y->_M_left;\n-\t  __x = __y->_M_right;\n-\t}\n-    if (__y != __z) \n-      {\n-\t// relink y in place of z.  y is z's successor\n-\t__z->_M_left->_M_parent = __y; \n-\t__y->_M_left = __z->_M_left;\n-\tif (__y != __z->_M_right) \n-\t  {\n-\t    __x_parent = __y->_M_parent;\n-\t    if (__x) __x->_M_parent = __y->_M_parent;\n-\t    __y->_M_parent->_M_left = __x;   // __y must be a child of _M_left\n-\t    __y->_M_right = __z->_M_right;\n-\t    __z->_M_right->_M_parent = __y;\n-\t  }\n-\telse\n-\t  __x_parent = __y;  \n-\tif (__root == __z)\n-\t  __root = __y;\n-\telse if (__z->_M_parent->_M_left == __z)\n-\t  __z->_M_parent->_M_left = __y;\n-\telse \n-\t  __z->_M_parent->_M_right = __y;\n-\t__y->_M_parent = __z->_M_parent;\n-\tstd::swap(__y->_M_color, __z->_M_color);\n-\t__y = __z;\n-\t// __y now points to node to be actually deleted\n-      }\n-    else \n-      {                        // __y == __z\n-\t__x_parent = __y->_M_parent;\n-\tif (__x) \n-\t  __x->_M_parent = __y->_M_parent;   \n-\tif (__root == __z)\n-\t  __root = __x;\n-\telse \n-\t  if (__z->_M_parent->_M_left == __z)\n-\t    __z->_M_parent->_M_left = __x;\n-\t  else\n-\t    __z->_M_parent->_M_right = __x;\n-\tif (__leftmost == __z) \n-\t  if (__z->_M_right == 0)        // __z->_M_left must be null also\n-\t    __leftmost = __z->_M_parent;\n-\t// makes __leftmost == _M_header if __z == __root\n-\t  else\n-\t    __leftmost = _Rb_tree_node_base::_S_minimum(__x);\n-\tif (__rightmost == __z)  \n-\t  if (__z->_M_left == 0)         // __z->_M_right must be null also\n-\t    __rightmost = __z->_M_parent;  \n-\t// makes __rightmost == _M_header if __z == __root\n-\t  else                      // __x == __z->_M_left\n-\t    __rightmost = _Rb_tree_node_base::_S_maximum(__x);\n-      }\n-    if (__y->_M_color != _S_red) \n-      { \n-\twhile (__x != __root && (__x == 0 || __x->_M_color == _S_black))\n-\t  if (__x == __x_parent->_M_left) \n-\t    {\n-\t      _Rb_tree_node_base* __w = __x_parent->_M_right;\n-\t      if (__w->_M_color == _S_red) \n-\t\t{\n-\t\t  __w->_M_color = _S_black;\n-\t\t  __x_parent->_M_color = _S_red;\n-\t\t  _Rb_tree_rotate_left(__x_parent, __root);\n-\t\t  __w = __x_parent->_M_right;\n-\t\t}\n-\t      if ((__w->_M_left == 0 || \n-\t\t   __w->_M_left->_M_color == _S_black) &&\n-\t\t  (__w->_M_right == 0 || \n-\t\t   __w->_M_right->_M_color == _S_black)) \n-\t\t{\n-\t\t  __w->_M_color = _S_red;\n-\t\t  __x = __x_parent;\n-\t\t  __x_parent = __x_parent->_M_parent;\n-\t\t} \n-\t      else \n-\t\t{\n-\t\t  if (__w->_M_right == 0 \n-\t\t      || __w->_M_right->_M_color == _S_black) \n-\t\t    {\n-\t\t      __w->_M_left->_M_color = _S_black;\n-\t\t      __w->_M_color = _S_red;\n-\t\t      _Rb_tree_rotate_right(__w, __root);\n-\t\t      __w = __x_parent->_M_right;\n-\t\t    }\n-\t\t  __w->_M_color = __x_parent->_M_color;\n-\t\t  __x_parent->_M_color = _S_black;\n-\t\t  if (__w->_M_right) \n-\t\t    __w->_M_right->_M_color = _S_black;\n-\t\t  _Rb_tree_rotate_left(__x_parent, __root);\n-\t\t  break;\n-\t\t}\n-\t    } \n-\t  else \n-\t    {   \n-\t      // same as above, with _M_right <-> _M_left.\n-\t      _Rb_tree_node_base* __w = __x_parent->_M_left;\n-\t      if (__w->_M_color == _S_red) \n-\t\t{\n-\t\t  __w->_M_color = _S_black;\n-\t\t  __x_parent->_M_color = _S_red;\n-\t\t  _Rb_tree_rotate_right(__x_parent, __root);\n-\t\t  __w = __x_parent->_M_left;\n-\t\t}\n-\t      if ((__w->_M_right == 0 || \n-\t\t   __w->_M_right->_M_color == _S_black) &&\n-\t\t  (__w->_M_left == 0 || \n-\t\t   __w->_M_left->_M_color == _S_black)) \n-\t\t{\n-\t\t  __w->_M_color = _S_red;\n-\t\t  __x = __x_parent;\n-\t\t  __x_parent = __x_parent->_M_parent;\n-\t\t} \n-\t      else \n-\t\t{\n-\t\t  if (__w->_M_left == 0 || __w->_M_left->_M_color == _S_black) \n-\t\t    {\n-\t\t      __w->_M_right->_M_color = _S_black;\n-\t\t      __w->_M_color = _S_red;\n-\t\t      _Rb_tree_rotate_left(__w, __root);\n-\t\t      __w = __x_parent->_M_left;\n-\t\t    }\n-\t\t  __w->_M_color = __x_parent->_M_color;\n-\t\t  __x_parent->_M_color = _S_black;\n-\t\t  if (__w->_M_left) \n-\t\t    __w->_M_left->_M_color = _S_black;\n-\t\t  _Rb_tree_rotate_right(__x_parent, __root);\n-\t\t  break;\n-\t\t}\n-\t    }\n-\tif (__x) __x->_M_color = _S_black;\n-      }\n-    return __y;\n-  }\n+\t\t\t       _Rb_tree_node_base& \t __header);\n \n   // Base class to encapsulate the differences between old SGI-style\n   // allocators and standard-conforming allocators.  In order to avoid\n@@ -1209,9 +931,7 @@ namespace std\n     {\n       _Link_type __y = \n \t(_Link_type) _Rb_tree_rebalance_for_erase(__position._M_node,\n-\t\t\t\t\t\t  this->_M_header._M_parent,\n-\t\t\t\t\t\t  this->_M_header._M_left,\n-\t\t\t\t\t\t  this->_M_header._M_right);\n+\t\t\t\t\t\t  this->_M_header);\n       destroy_node(__y);\n       --_M_node_count;\n     }"}, {"sha": "33d17196b40bd37623d50a3b7ebc5788a60f24b4", "filename": "libstdc++-v3/src/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca1c70118c8611dc8de6347601d6383a498d9eca/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca1c70118c8611dc8de6347601d6383a498d9eca/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am?ref=ca1c70118c8611dc8de6347601d6383a498d9eca", "patch": "@@ -144,6 +144,7 @@ sources = \\\n \tostream-inst.cc \\\n \tsstream-inst.cc \\\n \tstdexcept.cc \\\n+\tstl_tree.cc \\\n \tstreambuf-inst.cc \\\n \tstring-inst.cc \\\n \tstrstream.cc \\"}, {"sha": "7548e58f671cd44b053119297f7bc7eabc84e4d8", "filename": "libstdc++-v3/src/Makefile.in", "status": "modified", "additions": 75, "deletions": 20, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca1c70118c8611dc8de6347601d6383a498d9eca/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca1c70118c8611dc8de6347601d6383a498d9eca/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in?ref=ca1c70118c8611dc8de6347601d6383a498d9eca", "patch": "@@ -149,8 +149,8 @@ toolexeclibdir = @glibcxx_toolexeclibdir@\n toolexeclib_LTLIBRARIES = libstdc++.la\n \n # Symbol versioning for shared libraries.\n-@GLIBCXX_BUILD_VERSIONED_SHLIB_TRUE@port_specific_symbol_file = @port_specific_symbol_file@\n-@GLIBCXX_BUILD_VERSIONED_SHLIB_TRUE@version_arg = -Wl,--version-script=libstdc++-symbol.ver\n+@GLIBCXX_BUILD_VERSIONED_SHLIB_TRUE@port_specific_symbol_file = @GLIBCXX_BUILD_VERSIONED_SHLIB_TRUE@@port_specific_symbol_file@\n+@GLIBCXX_BUILD_VERSIONED_SHLIB_TRUE@version_arg = @GLIBCXX_BUILD_VERSIONED_SHLIB_TRUE@-Wl,--version-script=libstdc++-symbol.ver\n @GLIBCXX_BUILD_VERSIONED_SHLIB_FALSE@version_arg = \n \n # Compile flags that should be constant throughout the build, both for\n@@ -159,11 +159,13 @@ OPTIMIZE_CXXFLAGS = @OPTIMIZE_CXXFLAGS@\n \n # These bits are all figured out from configure. Look in acinclude.m4\n # or configure.in to see how they are set. See GLIBCXX_EXPORT_FLAGS\n-CONFIG_CXXFLAGS =  \t@SECTION_FLAGS@ @EXTRA_CXX_FLAGS@\n+CONFIG_CXXFLAGS = \\\n+\t@SECTION_FLAGS@ @EXTRA_CXX_FLAGS@\n \n \n # Warning flags to use.\n-WARN_CXXFLAGS =  \t@WARN_FLAGS@ $(WERROR) -fdiagnostics-show-location=once\n+WARN_CXXFLAGS = \\\n+\t@WARN_FLAGS@ $(WERROR) -fdiagnostics-show-location=once\n \n \n # Use common includes from acinclude.m4/GLIBCXX_EXPORT_INCLUDES\n@@ -172,33 +174,79 @@ LIBMATH_INCLUDES = @LIBMATH_INCLUDES@\n LIBSUPCXX_INCLUDES = @LIBSUPCXX_INCLUDES@\n TOPLEVEL_INCLUDES = @TOPLEVEL_INCLUDES@\n \n-INCLUDES =  \t-nostdinc++ \t$(GLIBCXX_INCLUDES) \t$(LIBSUPCXX_INCLUDES) $(LIBMATH_INCLUDES) \t$(TOPLEVEL_INCLUDES)\n+INCLUDES = \\\n+\t-nostdinc++ \\\n+\t$(GLIBCXX_INCLUDES) \\\n+\t$(LIBSUPCXX_INCLUDES) $(LIBMATH_INCLUDES) \\\n+\t$(TOPLEVEL_INCLUDES)\n \n \n # Source files linked in via configuration/make substitution for a\n # particular host.\n-host_sources =  \tcodecvt_members.cc \tcollate_members.cc \tctype_members.cc \tmessages_members.cc \tmonetary_members.cc \tnumeric_members.cc \ttime_members.cc\n+host_sources = \\\n+\tcodecvt_members.cc \\\n+\tcollate_members.cc \\\n+\tctype_members.cc \\\n+\tmessages_members.cc \\\n+\tmonetary_members.cc \\\n+\tnumeric_members.cc \\\n+\ttime_members.cc\n \n \n # Source files linked in via configuration/make substitution for a\n # particular host, but with ad hoc naming rules.\n-host_sources_extra =  \tbasic_file.cc \tc++locale.cc\n+host_sources_extra = \\\n+\tbasic_file.cc \\\n+\tc++locale.cc\n \n \n # Sources present in the src directory.\n-sources =  \tallocator-inst.cc \tcodecvt.cc \tcomplex_io.cc \tconcept-inst.cc \tctype.cc \tdemangle.cc \text-inst.cc \tfstream-inst.cc \tfunctexcept.cc \tglobals.cc \tio-inst.cc \tios.cc \tistream-inst.cc \tlimits.cc \tlocale.cc \tlocale-inst.cc \tlocalename.cc \tmisc-inst.cc \tostream-inst.cc \tsstream-inst.cc \tstdexcept.cc \tstreambuf-inst.cc \tstring-inst.cc \tstrstream.cc \tvalarray-inst.cc \twstring-inst.cc \t${host_sources} \t${host_sources_extra}\n+sources = \\\n+\tallocator-inst.cc \\\n+\tcodecvt.cc \\\n+\tcomplex_io.cc \\\n+\tconcept-inst.cc \\\n+\tctype.cc \\\n+\tdemangle.cc \\\n+\text-inst.cc \\\n+\tfstream-inst.cc \\\n+\tfunctexcept.cc \\\n+\tglobals.cc \\\n+\tio-inst.cc \\\n+\tios.cc \\\n+\tistream-inst.cc \\\n+\tlimits.cc \\\n+\tlocale.cc \\\n+\tlocale-inst.cc \\\n+\tlocalename.cc \\\n+\tmisc-inst.cc \\\n+\tostream-inst.cc \\\n+\tsstream-inst.cc \\\n+\tstdexcept.cc \\\n+\tstl_tree.cc \\\n+\tstreambuf-inst.cc \\\n+\tstring-inst.cc \\\n+\tstrstream.cc \\\n+\tvalarray-inst.cc \\\n+\twstring-inst.cc \\\n+\t${host_sources} \\\n+\t${host_sources_extra}\n \n \n VPATH = $(top_srcdir)/src:$(top_srcdir)\n \n libstdc___la_SOURCES = $(sources)\n \n-libstdc___la_LIBADD =  \t$(top_builddir)/libmath/libmath.la \t$(top_builddir)/libsupc++/libsupc++convenience.la\n+libstdc___la_LIBADD = \\\n+\t$(top_builddir)/libmath/libmath.la \\\n+\t$(top_builddir)/libsupc++/libsupc++convenience.la\n \n \n libstdc___la_DEPENDENCIES = libstdc++-symbol.ver $(libstdc___la_LIBADD)\n \n-libstdc___la_LDFLAGS =  \t-version-info @libtool_VERSION@ ${version_arg} \t-lm @LIBUNWIND_FLAG@\n+libstdc___la_LDFLAGS = \\\n+\t-version-info @libtool_VERSION@ ${version_arg} \\\n+\t-lm @LIBUNWIND_FLAG@\n \n \n # Use special rules for the deprecated source files so that they find\n@@ -210,7 +258,12 @@ GLIBCXX_INCLUDE_DIR = @glibcxx_builddir@/include\n # set this option because CONFIG_CXXFLAGS has to be after\n # OPTIMIZE_CXXFLAGS on the compile line so that -O2 can be overridden\n # as the occasion calls for it.\n-AM_CXXFLAGS =  \t-fno-implicit-templates \t$(LIBSUPCXX_CXXFLAGS) \t$(WARN_CXXFLAGS) \t$(OPTIMIZE_CXXFLAGS) \t$(CONFIG_CXXFLAGS)\n+AM_CXXFLAGS = \\\n+\t-fno-implicit-templates \\\n+\t$(LIBSUPCXX_CXXFLAGS) \\\n+\t$(WARN_CXXFLAGS) \\\n+\t$(OPTIMIZE_CXXFLAGS) \\\n+\t$(CONFIG_CXXFLAGS)\n \n \n # libstdc++ libtool notes\n@@ -231,7 +284,8 @@ AM_CXXFLAGS =  \t-fno-implicit-templates \t$(LIBSUPCXX_CXXFLAGS) \t$(WARN_CXXFLAGS)\n # correct solution is to add `--tag CXX' to LTCXXCOMPILE and maybe\n # CXXLINK, just after $(LIBTOOL), so that libtool doesn't have to\n # attempt to infer which configuration to use\n-LTCXXCOMPILE = $(LIBTOOL) --tag CXX --mode=compile $(CXX) $(INCLUDES) \t       $(AM_CPPFLAGS) $(CPPFLAGS) $(CXXFLAGS) $(AM_CXXFLAGS)\n+LTCXXCOMPILE = $(LIBTOOL) --tag CXX --mode=compile $(CXX) $(INCLUDES) \\\n+\t       $(AM_CPPFLAGS) $(CPPFLAGS) $(CXXFLAGS) $(AM_CXXFLAGS)\n \n \n # 3) We'd have a problem when building the shared libstdc++ object if\n@@ -240,7 +294,8 @@ LTCXXCOMPILE = $(LIBTOOL) --tag CXX --mode=compile $(CXX) $(INCLUDES) \t       $(\n # course is problematic at this point.  So, we get the top-level\n # directory to configure libstdc++-v3 to use gcc as the C++\n # compilation driver.\n-CXXLINK = $(LIBTOOL) --tag CXX --mode=link $(CXX) \t  @OPT_LDFLAGS@ @SECTION_LDFLAGS@ $(AM_CXXFLAGS) $(LDFLAGS) -o $@\n+CXXLINK = $(LIBTOOL) --tag CXX --mode=link $(CXX) \\\n+\t  @OPT_LDFLAGS@ @SECTION_LDFLAGS@ $(AM_CXXFLAGS) $(LDFLAGS) -o $@\n \n \n debugdir = debug\n@@ -257,11 +312,11 @@ libstdc___la_OBJECTS =  allocator-inst.lo codecvt.lo complex_io.lo \\\n concept-inst.lo ctype.lo demangle.lo ext-inst.lo fstream-inst.lo \\\n functexcept.lo globals.lo io-inst.lo ios.lo istream-inst.lo limits.lo \\\n locale.lo locale-inst.lo localename.lo misc-inst.lo ostream-inst.lo \\\n-sstream-inst.lo stdexcept.lo streambuf-inst.lo string-inst.lo \\\n-strstream.lo valarray-inst.lo wstring-inst.lo codecvt_members.lo \\\n-collate_members.lo ctype_members.lo messages_members.lo \\\n-monetary_members.lo numeric_members.lo time_members.lo basic_file.lo \\\n-c++locale.lo\n+sstream-inst.lo stdexcept.lo stl_tree.lo streambuf-inst.lo \\\n+string-inst.lo strstream.lo valarray-inst.lo wstring-inst.lo \\\n+codecvt_members.lo collate_members.lo ctype_members.lo \\\n+messages_members.lo monetary_members.lo numeric_members.lo \\\n+time_members.lo basic_file.lo c++locale.lo\n CXXFLAGS = @CXXFLAGS@\n CXXCOMPILE = $(CXX) $(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)\n CXXLD = $(CXX)\n@@ -270,7 +325,7 @@ DIST_COMMON =  Makefile.am Makefile.in\n \n DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) $(TEXINFOS) $(EXTRA_DIST)\n \n-TAR = tar\n+TAR = gtar\n GZIP_ENV = --best\n SOURCES = $(libstdc___la_SOURCES)\n OBJECTS = $(libstdc___la_OBJECTS)\n@@ -382,7 +437,7 @@ TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) $(LISP)\n \t  awk '    { files[$$0] = 1; } \\\n \t       END { for (i in files) print i; }'`; \\\n \ttest -z \"$(ETAGS_ARGS)$$unique$(LISP)$$tags\" \\\n-\t  || (cd $(srcdir) && etags -o $$here/TAGS $(ETAGS_ARGS) $$tags  $$unique $(LISP))\n+\t  || (cd $(srcdir) && etags $(ETAGS_ARGS) $$tags  $$unique $(LISP) -o $$here/TAGS)\n \n mostlyclean-tags:\n "}, {"sha": "99f8143df1d1d016ca2b477aa30fd9245957bda0", "filename": "libstdc++-v3/src/stl_tree.cc", "status": "added", "additions": 365, "deletions": 0, "changes": 365, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca1c70118c8611dc8de6347601d6383a498d9eca/libstdc%2B%2B-v3%2Fsrc%2Fstl_tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca1c70118c8611dc8de6347601d6383a498d9eca/libstdc%2B%2B-v3%2Fsrc%2Fstl_tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fstl_tree.cc?ref=ca1c70118c8611dc8de6347601d6383a498d9eca", "patch": "@@ -0,0 +1,365 @@\n+// RB tree utilities implementation -*- C++ -*-\n+\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/*\n+ *\n+ * Copyright (c) 1996,1997\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ *\n+ */\n+\n+#include <bits/stl_tree.h>\n+\n+namespace std\n+{\n+  void \n+  _Rb_tree_base_iterator::_M_increment()\n+  {\n+    if (_M_node->_M_right != 0) \n+      {\n+        _M_node = _M_node->_M_right;\n+        while (_M_node->_M_left != 0)\n+          _M_node = _M_node->_M_left;\n+      }\n+    else \n+      {\n+        _Base_ptr __y = _M_node->_M_parent;\n+        while (_M_node == __y->_M_right) \n+          {\n+            _M_node = __y;\n+            __y = __y->_M_parent;\n+          }\n+        if (_M_node->_M_right != __y)\n+          _M_node = __y;\n+      }\n+  }\n+\n+  void \n+  _Rb_tree_base_iterator::_M_decrement()\n+  {\n+    if (_M_node->_M_color == _S_red \n+        && _M_node->_M_parent->_M_parent == _M_node)\n+      _M_node = _M_node->_M_right;\n+    else if (_M_node->_M_left != 0) \n+      {\n+        _Base_ptr __y = _M_node->_M_left;\n+        while (__y->_M_right != 0)\n+          __y = __y->_M_right;\n+        _M_node = __y;\n+      }\n+    else \n+      {\n+        _Base_ptr __y = _M_node->_M_parent;\n+        while (_M_node == __y->_M_left) \n+          {\n+            _M_node = __y;\n+            __y = __y->_M_parent;\n+          }\n+        _M_node = __y;\n+      }\n+  }\n+\n+  void \n+  _Rb_tree_rotate_left(_Rb_tree_node_base* const __x, \n+\t\t       _Rb_tree_node_base*& __root)\n+  {\n+    _Rb_tree_node_base* const __y = __x->_M_right;\n+\n+    __x->_M_right = __y->_M_left;\n+    if (__y->_M_left !=0)\n+      __y->_M_left->_M_parent = __x;\n+    __y->_M_parent = __x->_M_parent;\n+    \n+    if (__x == __root)\n+      __root = __y;\n+    else if (__x == __x->_M_parent->_M_left)\n+      __x->_M_parent->_M_left = __y;\n+    else\n+      __x->_M_parent->_M_right = __y;\n+    __y->_M_left = __x;\n+    __x->_M_parent = __y;\n+  }\n+\n+  void \n+  _Rb_tree_rotate_right(_Rb_tree_node_base* const __x, \n+\t\t\t_Rb_tree_node_base*& __root)\n+  {\n+    _Rb_tree_node_base* const __y = __x->_M_left;\n+\n+    __x->_M_left = __y->_M_right;\n+    if (__y->_M_right != 0)\n+      __y->_M_right->_M_parent = __x;\n+    __y->_M_parent = __x->_M_parent;\n+\n+    if (__x == __root)\n+      __root = __y;\n+    else if (__x == __x->_M_parent->_M_right)\n+      __x->_M_parent->_M_right = __y;\n+    else\n+      __x->_M_parent->_M_left = __y;\n+    __y->_M_right = __x;\n+    __x->_M_parent = __y;\n+  }\n+\n+  void \n+  _Rb_tree_rebalance(_Rb_tree_node_base* __x, _Rb_tree_node_base*& __root)\n+  {\n+    __x->_M_color = _S_red;\n+\n+    while (__x != __root \n+\t   && __x->_M_parent->_M_color == _S_red) \n+      {\n+\t_Rb_tree_node_base* const __xpp = __x->_M_parent->_M_parent;\n+\n+\tif (__x->_M_parent == __xpp->_M_left) \n+\t  {\n+\t    _Rb_tree_node_base* const __y = __xpp->_M_right;\n+\t    if (__y && __y->_M_color == _S_red) \n+\t      {\n+\t\t__x->_M_parent->_M_color = _S_black;\n+\t\t__y->_M_color = _S_black;\n+\t\t__xpp->_M_color = _S_red;\n+\t\t__x = __xpp;\n+\t      }\n+\t    else \n+\t      {\n+\t\tif (__x == __x->_M_parent->_M_right) \n+\t\t  {\n+\t\t    __x = __x->_M_parent;\n+\t\t    _Rb_tree_rotate_left(__x, __root);\n+\t\t  }\n+\t\t__x->_M_parent->_M_color = _S_black;\n+\t\t__xpp->_M_color = _S_red;\n+\t\t_Rb_tree_rotate_right(__xpp, __root);\n+\t      }\n+\t  }\n+\telse \n+\t  {\n+\t    _Rb_tree_node_base* const __y = __xpp->_M_left;\n+\t    if (__y && __y->_M_color == _S_red) \n+\t      {\n+\t\t__x->_M_parent->_M_color = _S_black;\n+\t\t__y->_M_color = _S_black;\n+\t\t__xpp->_M_color = _S_red;\n+\t\t__x = __xpp;\n+\t      }\n+\t    else \n+\t      {\n+\t\tif (__x == __x->_M_parent->_M_left) \n+\t\t  {\n+\t\t    __x = __x->_M_parent;\n+\t\t    _Rb_tree_rotate_right(__x, __root);\n+\t\t  }\n+\t\t__x->_M_parent->_M_color = _S_black;\n+\t\t__xpp->_M_color = _S_red;\n+\t\t_Rb_tree_rotate_left(__xpp, __root);\n+\t      }\n+\t  }\n+      }\n+    __root->_M_color = _S_black;\n+  }\n+\n+  _Rb_tree_node_base*\n+  _Rb_tree_rebalance_for_erase(_Rb_tree_node_base* const __z, \n+\t\t\t       _Rb_tree_node_base& __header)\n+  {\n+    _Rb_tree_node_base *& __root = __header._M_parent;\n+    _Rb_tree_node_base *& __leftmost = __header._M_left;\n+    _Rb_tree_node_base *& __rightmost = __header._M_right;\n+    _Rb_tree_node_base* __y = __z;\n+    _Rb_tree_node_base* __x = 0;\n+    _Rb_tree_node_base* __x_parent = 0;\n+\n+    if (__y->_M_left == 0)     // __z has at most one non-null child. y == z.\n+      __x = __y->_M_right;     // __x might be null.\n+    else\n+      if (__y->_M_right == 0)  // __z has exactly one non-null child. y == z.\n+\t__x = __y->_M_left;    // __x is not null.\n+      else \n+\t{\n+\t  // __z has two non-null children.  Set __y to\n+\t  __y = __y->_M_right;   //   __z's successor.  __x might be null.\n+\t  while (__y->_M_left != 0)\n+\t    __y = __y->_M_left;\n+\t  __x = __y->_M_right;\n+\t}\n+    if (__y != __z) \n+      {\n+\t// relink y in place of z.  y is z's successor\n+\t__z->_M_left->_M_parent = __y; \n+\t__y->_M_left = __z->_M_left;\n+\tif (__y != __z->_M_right) \n+\t  {\n+\t    __x_parent = __y->_M_parent;\n+\t    if (__x) __x->_M_parent = __y->_M_parent;\n+\t    __y->_M_parent->_M_left = __x;   // __y must be a child of _M_left\n+\t    __y->_M_right = __z->_M_right;\n+\t    __z->_M_right->_M_parent = __y;\n+\t  }\n+\telse\n+\t  __x_parent = __y;  \n+\tif (__root == __z)\n+\t  __root = __y;\n+\telse if (__z->_M_parent->_M_left == __z)\n+\t  __z->_M_parent->_M_left = __y;\n+\telse \n+\t  __z->_M_parent->_M_right = __y;\n+\t__y->_M_parent = __z->_M_parent;\n+\tstd::swap(__y->_M_color, __z->_M_color);\n+\t__y = __z;\n+\t// __y now points to node to be actually deleted\n+      }\n+    else \n+      {                        // __y == __z\n+\t__x_parent = __y->_M_parent;\n+\tif (__x) \n+\t  __x->_M_parent = __y->_M_parent;   \n+\tif (__root == __z)\n+\t  __root = __x;\n+\telse \n+\t  if (__z->_M_parent->_M_left == __z)\n+\t    __z->_M_parent->_M_left = __x;\n+\t  else\n+\t    __z->_M_parent->_M_right = __x;\n+\tif (__leftmost == __z) \n+\t  if (__z->_M_right == 0)        // __z->_M_left must be null also\n+\t    __leftmost = __z->_M_parent;\n+\t// makes __leftmost == _M_header if __z == __root\n+\t  else\n+\t    __leftmost = _Rb_tree_node_base::_S_minimum(__x);\n+\tif (__rightmost == __z)  \n+\t  if (__z->_M_left == 0)         // __z->_M_right must be null also\n+\t    __rightmost = __z->_M_parent;  \n+\t// makes __rightmost == _M_header if __z == __root\n+\t  else                      // __x == __z->_M_left\n+\t    __rightmost = _Rb_tree_node_base::_S_maximum(__x);\n+      }\n+    if (__y->_M_color != _S_red) \n+      { \n+\twhile (__x != __root && (__x == 0 || __x->_M_color == _S_black))\n+\t  if (__x == __x_parent->_M_left) \n+\t    {\n+\t      _Rb_tree_node_base* __w = __x_parent->_M_right;\n+\t      if (__w->_M_color == _S_red) \n+\t\t{\n+\t\t  __w->_M_color = _S_black;\n+\t\t  __x_parent->_M_color = _S_red;\n+\t\t  _Rb_tree_rotate_left(__x_parent, __root);\n+\t\t  __w = __x_parent->_M_right;\n+\t\t}\n+\t      if ((__w->_M_left == 0 || \n+\t\t   __w->_M_left->_M_color == _S_black) &&\n+\t\t  (__w->_M_right == 0 || \n+\t\t   __w->_M_right->_M_color == _S_black)) \n+\t\t{\n+\t\t  __w->_M_color = _S_red;\n+\t\t  __x = __x_parent;\n+\t\t  __x_parent = __x_parent->_M_parent;\n+\t\t} \n+\t      else \n+\t\t{\n+\t\t  if (__w->_M_right == 0 \n+\t\t      || __w->_M_right->_M_color == _S_black) \n+\t\t    {\n+\t\t      __w->_M_left->_M_color = _S_black;\n+\t\t      __w->_M_color = _S_red;\n+\t\t      _Rb_tree_rotate_right(__w, __root);\n+\t\t      __w = __x_parent->_M_right;\n+\t\t    }\n+\t\t  __w->_M_color = __x_parent->_M_color;\n+\t\t  __x_parent->_M_color = _S_black;\n+\t\t  if (__w->_M_right) \n+\t\t    __w->_M_right->_M_color = _S_black;\n+\t\t  _Rb_tree_rotate_left(__x_parent, __root);\n+\t\t  break;\n+\t\t}\n+\t    } \n+\t  else \n+\t    {   \n+\t      // same as above, with _M_right <-> _M_left.\n+\t      _Rb_tree_node_base* __w = __x_parent->_M_left;\n+\t      if (__w->_M_color == _S_red) \n+\t\t{\n+\t\t  __w->_M_color = _S_black;\n+\t\t  __x_parent->_M_color = _S_red;\n+\t\t  _Rb_tree_rotate_right(__x_parent, __root);\n+\t\t  __w = __x_parent->_M_left;\n+\t\t}\n+\t      if ((__w->_M_right == 0 || \n+\t\t   __w->_M_right->_M_color == _S_black) &&\n+\t\t  (__w->_M_left == 0 || \n+\t\t   __w->_M_left->_M_color == _S_black)) \n+\t\t{\n+\t\t  __w->_M_color = _S_red;\n+\t\t  __x = __x_parent;\n+\t\t  __x_parent = __x_parent->_M_parent;\n+\t\t} \n+\t      else \n+\t\t{\n+\t\t  if (__w->_M_left == 0 || __w->_M_left->_M_color == _S_black) \n+\t\t    {\n+\t\t      __w->_M_right->_M_color = _S_black;\n+\t\t      __w->_M_color = _S_red;\n+\t\t      _Rb_tree_rotate_left(__w, __root);\n+\t\t      __w = __x_parent->_M_left;\n+\t\t    }\n+\t\t  __w->_M_color = __x_parent->_M_color;\n+\t\t  __x_parent->_M_color = _S_black;\n+\t\t  if (__w->_M_left) \n+\t\t    __w->_M_left->_M_color = _S_black;\n+\t\t  _Rb_tree_rotate_right(__x_parent, __root);\n+\t\t  break;\n+\t\t}\n+\t    }\n+\tif (__x) __x->_M_color = _S_black;\n+      }\n+    return __y;\n+  }\n+} // namespace std "}]}