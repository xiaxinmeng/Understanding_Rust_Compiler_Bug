{"sha": "6f12117afc93e5af5f2cdb1cfc99e285a15f9a91", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmYxMjExN2FmYzkzZTVhZjVmMmNkYjFjZmM5OWUyODVhMTVmOWE5MQ==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2009-07-15T09:59:16Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-07-15T09:59:16Z"}, "message": "debug.adb: Add -gnatd.O to output SCO table\n\n2009-07-15  Robert Dewar  <dewar@adacore.com>\n\n\t* debug.adb: Add -gnatd.O to output SCO table\n\n\t* lib-writ.adb (Write_Unit_Information): Use SCO_Output to output SCO\n\tinformation.\n\n\t* lib-writ.ads: Document addition of SCO lines to ALI file\n\n\t* par_sco.ads, par_sco.adb: New files.\n\n\t* opt.ads (Generate_SCO): New switch\n\n\t* par.adb (Par): Call SCO_Record to record SCO information\n\n\t* sem_warn.adb (Warn_On_Constant_Condition): Adjust SCO condition\n\n\t* switch-c.adb: Recognize -gnateS to generate SCO information\n\n\t* usage.adb: Add line for -gnateS\n\n\t* gcc-interface/Make-lang.in: Add dependency on par_sco.o for gnat1\n\nFrom-SVN: r149669", "tree": {"sha": "7269667b0fc6e29ea066148c0a41903f090ce070", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7269667b0fc6e29ea066148c0a41903f090ce070"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6f12117afc93e5af5f2cdb1cfc99e285a15f9a91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f12117afc93e5af5f2cdb1cfc99e285a15f9a91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f12117afc93e5af5f2cdb1cfc99e285a15f9a91", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f12117afc93e5af5f2cdb1cfc99e285a15f9a91/comments", "author": null, "committer": null, "parents": [{"sha": "3a3362620167fd31b30aa391bf6d84c45a3d6af2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a3362620167fd31b30aa391bf6d84c45a3d6af2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a3362620167fd31b30aa391bf6d84c45a3d6af2"}], "stats": {"total": 1279, "additions": 1270, "deletions": 9}, "files": [{"sha": "bc2ccb0c7b1f3de3b1f906b5483c99b2d6b458e9", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f12117afc93e5af5f2cdb1cfc99e285a15f9a91/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f12117afc93e5af5f2cdb1cfc99e285a15f9a91/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=6f12117afc93e5af5f2cdb1cfc99e285a15f9a91", "patch": "@@ -1,3 +1,26 @@\n+2009-07-15  Robert Dewar  <dewar@adacore.com>\n+\n+\t* debug.adb: Add -gnatd.O to output SCO table\n+\n+\t* lib-writ.adb (Write_Unit_Information): Use SCO_Output to output SCO\n+\tinformation.\n+\n+\t* lib-writ.ads: Document addition of SCO lines to ALI file\n+\n+\t* par_sco.ads, par_sco.adb: New files.\n+\n+\t* opt.ads (Generate_SCO): New switch\n+\n+\t* par.adb (Par): Call SCO_Record to record SCO information\n+\n+\t* sem_warn.adb (Warn_On_Constant_Condition): Adjust SCO condition\n+\n+\t* switch-c.adb: Recognize -gnateS to generate SCO information\n+\n+\t* usage.adb: Add line for -gnateS\n+\n+\t* gcc-interface/Make-lang.in: Add dependency on par_sco.o for gnat1\n+\n 2009-07-15  Sergey Rybin  <rybin@adacore.com>\n \n \t* tree_in.ads, tree_io.ads: Add pragma Warnings Off/On for with clause"}, {"sha": "5ae3979ee8ba686f0e72ac1a0d25d645194c1288", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f12117afc93e5af5f2cdb1cfc99e285a15f9a91/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f12117afc93e5af5f2cdb1cfc99e285a15f9a91/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=6f12117afc93e5af5f2cdb1cfc99e285a15f9a91", "patch": "@@ -126,13 +126,13 @@ package body Debug is\n    --  d.F\n    --  d.G\n    --  d.H\n-   --  d.I  Inspector mode\n+   --  d.I  SCIL generation mode\n    --  d.J\n    --  d.K\n    --  d.L\n    --  d.M\n    --  d.N\n-   --  d.O\n+   --  d.O  Dump internal SCO table\n    --  d.P\n    --  d.Q\n    --  d.R\n@@ -559,6 +559,8 @@ package body Debug is\n    --       byte code, even in case of unsupported construct, for the sake\n    --       of static analysis tools.\n \n+   --  d.O  Dump internal SCO (Source Coverage Obligation) table in Par_Sco\n+\n    --  d.S  Force Optimize_Alignment (Space) mode as the default\n \n    --  d.T  Force Optimize_Alignment (Time) mode as the default"}, {"sha": "1dcb12ff71176619a2082b0cb8a65c89a22bc1a1", "filename": "gcc/ada/gcc-interface/Make-lang.in", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f12117afc93e5af5f2cdb1cfc99e285a15f9a91/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f12117afc93e5af5f2cdb1cfc99e285a15f9a91/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMake-lang.in?ref=6f12117afc93e5af5f2cdb1cfc99e285a15f9a91", "patch": "@@ -139,7 +139,7 @@ GNAT_ADA_OBJS = ada/s-bitops.o ada/ada.o ada/a-charac.o ada/a-chlat1.o ada/a-exc\n  ada/lib-load.o ada/lib-util.o ada/lib-xref.o ada/lib-writ.o ada/live.o \\\n  ada/namet.o ada/namet-sp.o \\\n  ada/nlists.o ada/nmake.o ada/opt.o ada/osint.o ada/osint-c.o \\\n- ada/output.o \\\n+ ada/output.o ada/par_sco.o \\\n  ada/par.o ada/prep.o ada/prepcomp.o ada/repinfo.o ada/restrict.o \\\n  ada/rident.o ada/rtsfind.o \\\n  ada/s-addope.o ada/s-assert.o ada/s-parame.o ada/s-stache.o \\\n@@ -2765,6 +2765,11 @@ ada/par.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads ada/a-uncdea.ads \\\n    ada/unchconv.ads ada/unchdeal.ads ada/urealp.ads ada/validsw.ads \\\n    ada/widechar.ads \n \n+ada/par_sco.o : ada/par_sco.ads ada/par_sco.adb ada/types.ads \\\n+   ada/atree.ads ada/debug.ads ada/lib.ads ada/lib-util.ads ada/nlists.ads \\\n+   ada/output.ads ada/sinfo.ads ada/sinput.ads ada/table.ads \\\n+   ada/g-htable.ads ada/snames.ads\n+\n ada/prep.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/a-uncdea.ads ada/alloc.ads ada/casing.ads ada/csets.ads \\\n    ada/debug.ads ada/err_vars.ads ada/gnat.ads ada/g-dyntab.ads \\"}, {"sha": "44d8b336918219350e35b3e1de544b5e01c0c6de", "filename": "gcc/ada/lib-writ.adb", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f12117afc93e5af5f2cdb1cfc99e285a15f9a91/gcc%2Fada%2Flib-writ.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f12117afc93e5af5f2cdb1cfc99e285a15f9a91/gcc%2Fada%2Flib-writ.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.adb?ref=6f12117afc93e5af5f2cdb1cfc99e285a15f9a91", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -38,6 +38,7 @@ with Opt;      use Opt;\n with Osint;    use Osint;\n with Osint.C;  use Osint.C;\n with Par;\n+with Par_SCO;  use Par_SCO;\n with Restrict; use Restrict;\n with Rident;   use Rident;\n with Scn;      use Scn;\n@@ -631,6 +632,12 @@ package body Lib.Writ is\n                end if;\n             end;\n          end loop;\n+\n+         --  Output SCO information if present\n+\n+         if Generate_SCO then\n+            SCO_Output (Unit_Num);\n+         end if;\n       end Write_Unit_Information;\n \n       ----------------------"}, {"sha": "2195f0541a88890f715a17b22d6871299be0bcac", "filename": "gcc/ada/lib-writ.ads", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f12117afc93e5af5f2cdb1cfc99e285a15f9a91/gcc%2Fada%2Flib-writ.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f12117afc93e5af5f2cdb1cfc99e285a15f9a91/gcc%2Fada%2Flib-writ.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.ads?ref=6f12117afc93e5af5f2cdb1cfc99e285a15f9a91", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -579,6 +579,14 @@ package Lib.Writ is\n    --      the source file, so that this order is preserved by the binder\n    --      in constructing the set of linker arguments.\n \n+   --  ------------------------------------\n+   --  -- C  Source Coverage Obligations --\n+   --  -------------------------------------\n+\n+   --  Following the L lines (if any) are the SCO (Source Coverage Obligation)\n+   --  lines if they are being generated. For the full format of these lines,\n+   --  see the spec of Par_SCO.\n+\n    ---------------------\n    -- Reference Lines --\n    ---------------------"}, {"sha": "ca5d7fb27555f78226e2b889065faa7533864e25", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f12117afc93e5af5f2cdb1cfc99e285a15f9a91/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f12117afc93e5af5f2cdb1cfc99e285a15f9a91/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=6f12117afc93e5af5f2cdb1cfc99e285a15f9a91", "patch": "@@ -550,6 +550,12 @@ package Opt is\n    --  True when switch -gnateG is used. When True, create in a file\n    --  <source>.prep, if the source is preprocessed.\n \n+   Generate_SCO : Boolean := False;\n+   --  GNAT\n+   --  True when switch -gnateS is used. When True, Source Coverage Obligation\n+   --  (SCO) information is generated and output in the ALI file. See unit\n+   --  Sem_SCO for full details.\n+\n    Generating_Code : Boolean := False;\n    --  GNAT\n    --  True if the frontend finished its work and has called the backend to"}, {"sha": "03580407b9467b72c3425e199b8da3e194ed18a7", "filename": "gcc/ada/par.adb", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f12117afc93e5af5f2cdb1cfc99e285a15f9a91/gcc%2Fada%2Fpar.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f12117afc93e5af5f2cdb1cfc99e285a15f9a91/gcc%2Fada%2Fpar.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar.adb?ref=6f12117afc93e5af5f2cdb1cfc99e285a15f9a91", "patch": "@@ -35,6 +35,7 @@ with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n with Opt;      use Opt;\n with Output;   use Output;\n+with Par_SCO;  use Par_SCO;\n with Scans;    use Scans;\n with Scn;      use Scn;\n with Sinput;   use Sinput;\n@@ -51,6 +52,7 @@ with Tbuild;   use Tbuild;\n ---------\n \n function Par (Configuration_Pragmas : Boolean) return List_Id is\n+\n    Num_Library_Units : Natural := 0;\n    --  Count number of units parsed (relevant only in syntax check only mode,\n    --  since in semantics check mode only a single unit is permitted anyway)\n@@ -1453,9 +1455,17 @@ begin\n \n       pragma Assert (Scope.Last = 0);\n \n-      --  Remaining steps are to create implicit label declarations and to\n-      --  load required subsidiary sources. These steps are required only\n-      --  if we are doing semantic checking.\n+      --  This is where we generate SCO output if required\n+\n+      if Generate_SCO\n+        and then Operating_Mode = Generate_Code\n+      then\n+         SCO_Record (Current_Source_Unit);\n+      end if;\n+\n+      --  Remaining steps are to create implicit label declarations and to load\n+      --  required subsidiary sources. These steps are required only if we are\n+      --  doing semantic checking.\n \n       if Operating_Mode /= Check_Syntax or else Debug_Flag_F then\n          Par.Labl;"}, {"sha": "3161c53bfdc92d8f303de1a5d2e2a9d8e847d970", "filename": "gcc/ada/par_sco.adb", "status": "added", "additions": 956, "deletions": 0, "changes": 956, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f12117afc93e5af5f2cdb1cfc99e285a15f9a91/gcc%2Fada%2Fpar_sco.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f12117afc93e5af5f2cdb1cfc99e285a15f9a91/gcc%2Fada%2Fpar_sco.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar_sco.adb?ref=6f12117afc93e5af5f2cdb1cfc99e285a15f9a91", "patch": "@@ -0,0 +1,956 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              P A R _ S C O                               --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--             Copyright (C) 2009, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Atree;    use Atree;\n+with Debug;    use Debug;\n+with Lib;      use Lib;\n+with Lib.Util; use Lib.Util;\n+with Nlists;   use Nlists;\n+with Output;   use Output;\n+with Sinfo;    use Sinfo;\n+with Sinput;   use Sinput;\n+with Table;\n+\n+with GNAT.HTable; use GNAT.HTable;\n+\n+package body Par_SCO is\n+\n+   ---------------\n+   -- SCO_Table --\n+   ---------------\n+\n+   --  Internal table used to store recorded SCO values. Table is populated by\n+   --  calls to SCO_Record, and entries may be modified by Set_SCO_Condition.\n+\n+   type SCO_Table_Entry is record\n+      From : Source_Ptr;\n+      To   : Source_Ptr;\n+      C1   : Character;\n+      C2   : Character;\n+      Last : Boolean;\n+   end record;\n+\n+   package SCO_Table is new Table.Table (\n+     Table_Component_Type => SCO_Table_Entry,\n+     Table_Index_Type     => Nat,\n+     Table_Low_Bound      => 1,\n+     Table_Initial        => 500,\n+     Table_Increment      => 300,\n+     Table_Name           => \"SCO_Table_Entry\");\n+\n+   --  The SCO_Table_Entry values appear as follows:\n+\n+   --    Statements\n+   --      C1   = 'S'\n+   --      C2   = ' '\n+   --      From = starting sloc\n+   --      To   = ending sloc\n+   --      Last = unused\n+\n+   --    Entry\n+   --      C1   = 'Y'\n+   --      C2   = ' '\n+   --      From = starting sloc\n+   --      To   = ending sloc\n+   --      Last = unused\n+\n+   --    Exit\n+   --      C1   = 'T'\n+   --      C2   = ' '\n+   --      From = starting sloc\n+   --      To   = ending sloc\n+   --      Last = unused\n+\n+   --    Simple Decision\n+   --      C1   = 'I', 'E', 'W', 'X' (if/exit/while/expression)\n+   --      C2   = 'c', 't', or 'f'\n+   --      From = starting sloc\n+   --      To   = ending sloc\n+   --      Last = True\n+\n+   --    Complex Decision\n+   --      C1   = 'I', 'E', 'W', 'X' (if/exit/while/expression)\n+   --      C2   = ' '\n+   --      From = No_Location\n+   --      To   = No_Location\n+   --      Last = False\n+\n+   --    Operator\n+   --      C1   = '!', '^', '&', '|'\n+   --      C2   = ' '\n+   --      From = No_Location\n+   --      To   = No_Location\n+   --      Last = False\n+\n+   --    Element\n+   --      C1   = ' '\n+   --      C2   = 'c', 't', or 'f' (condition/true/false)\n+   --      From = starting sloc\n+   --      To   = ending sloc\n+   --      Last = False for all but the last entry, True for last entry\n+\n+   --    Note: the sequence starting with a decision, and continuing with\n+   --    operators and elements up to and including the first one labeled with\n+   --    Last=True, indicate the sequence to be output for a complex decision\n+   --    on a single CD decision line.\n+\n+   ----------------\n+   -- Unit Table --\n+   ----------------\n+\n+   --  This table keeps track of the units and the corresponding starting index\n+   --  in the SCO table. The ending index is either one less than the starting\n+   --  index of the next table entry, or, for the last table entry, it is\n+   --  SCO_Table.Last.\n+\n+   type SCO_Unit_Table_Entry is record\n+      Unit  : Unit_Number_Type;\n+      Index : Int;\n+   end record;\n+\n+   package SCO_Unit_Table is new Table.Table (\n+     Table_Component_Type => SCO_Unit_Table_Entry,\n+     Table_Index_Type     => Int,\n+     Table_Low_Bound      => 1,\n+     Table_Initial        => 20,\n+     Table_Increment      => 200,\n+     Table_Name           => \"SCO_Unit_Table_Entry\");\n+\n+   --------------------------\n+   -- Condition Hash Table --\n+   --------------------------\n+\n+   --  We need to be able to get to conditions quickly for handling the calls\n+   --  to Set_SCO_Condition efficiently. For this purpose we identify the\n+   --  conditions in the table by their starting sloc, and use the following\n+   --  hash table to map from these starting sloc values to SCO_Table indexes.\n+\n+   type Header_Num is new Integer range 0 .. 996;\n+   --  Type for hash table headers\n+\n+   function Hash (F : Source_Ptr) return Header_Num;\n+   --  Function to Hash source pointer value\n+\n+   function Equal (F1, F2 : Source_Ptr) return Boolean;\n+   --  Function to test two keys for equality\n+\n+   package Condition_Hash_Table is new Simple_HTable\n+     (Header_Num, Int, 0, Source_Ptr, Hash, Equal);\n+   --  The actual hash table\n+\n+   --------------------------\n+   -- Internal Subprograms --\n+   --------------------------\n+\n+   function Has_Decision (N : Node_Id) return Boolean;\n+   --  N is the node for a subexpression. Returns True if the subexpression\n+   --  contains a nested decision (i.e. either is a logical operator, or\n+   --  contains a logical operator in its subtree).\n+\n+   function Is_Logical_Operator (N : Node_Id) return Boolean;\n+   --  N is the node for a subexpression. This procedure just tests N to see\n+   --  if it is a logical operator (including short circuit conditions) and\n+   --  returns True if so, False otherwise, it does no other processing.\n+\n+   procedure Process_Decisions (N : Node_Id; T : Character);\n+   --  If N is Empty, has no effect. Otherwise scans the tree for the node N,\n+   --  to output any decisions it contains. T is one of IEWX (for context of\n+   --  expresion: if/while/when-exit/expression). If T is other than X, then\n+   --  the node is always a decision a decision is always present (at the very\n+   --  least a simple decision is present at the top level).\n+\n+   procedure Set_Table_Entry\n+     (C1   : Character;\n+      C2   : Character;\n+      From : Source_Ptr;\n+      To   : Source_Ptr;\n+      Last : Boolean);\n+   --  Append an entry to SCO_Table with fields set as per arguments\n+\n+   procedure Traverse_Declarations_Or_Statements (L : List_Id);\n+   procedure Traverse_Handled_Statement_Sequence (N : Node_Id);\n+   procedure Traverse_Package_Body               (N : Node_Id);\n+   procedure Traverse_Package_Declaration        (N : Node_Id);\n+   procedure Traverse_Subprogram_Body            (N : Node_Id);\n+   --  Traverse the corresponding construct, generating SCO table entries\n+\n+   procedure dsco;\n+   --  Debug routine to dump SCO table\n+\n+   ----------\n+   -- dsco --\n+   ----------\n+\n+   procedure dsco is\n+   begin\n+      Write_Line (\"SCO Unit Table\");\n+      Write_Line (\"--------------\");\n+\n+      for Index in SCO_Unit_Table.First .. SCO_Unit_Table.Last loop\n+         Write_Str (\"  \");\n+         Write_Int (Index);\n+         Write_Str (\".  Unit = \");\n+         Write_Int (Int (SCO_Unit_Table.Table (Index).Unit));\n+         Write_Str (\"  Index = \");\n+         Write_Int (Int (SCO_Unit_Table.Table (Index).Index));\n+         Write_Eol;\n+      end loop;\n+\n+      Write_Eol;\n+      Write_Line (\"SCO Table\");\n+      Write_Line (\"---------\");\n+\n+      for Index in SCO_Table.First .. SCO_Table.Last loop\n+         declare\n+            T : SCO_Table_Entry renames SCO_Table.Table (Index);\n+\n+         begin\n+            Write_Str (\"  \");\n+            Write_Int (Index);\n+            Write_Str (\".  C1 = '\");\n+            Write_Char (T.C1);\n+            Write_Str (\"' C2 = '\");\n+            Write_Char (T.C2);\n+            Write_Str (\"' From = \");\n+            Write_Location (T.From);\n+            Write_Str (\"  To = \");\n+            Write_Location (T.To);\n+            Write_Str (\" Last = \");\n+\n+            if T.Last then\n+               Write_Str (\" True\");\n+            else\n+               Write_Str (\" False\");\n+            end if;\n+\n+            Write_Eol;\n+         end;\n+      end loop;\n+   end dsco;\n+\n+   -----------\n+   -- Equal --\n+   -----------\n+\n+   function Equal (F1, F2 : Source_Ptr) return Boolean is\n+   begin\n+      return F1 = F2;\n+   end Equal;\n+\n+   ------------------\n+   -- Has_Decision --\n+   ------------------\n+\n+   function Has_Decision (N : Node_Id) return Boolean is\n+\n+      function Check_Node (N : Node_Id) return Traverse_Result;\n+\n+      ----------------\n+      -- Check_Node --\n+      ----------------\n+\n+      function Check_Node (N : Node_Id) return Traverse_Result is\n+      begin\n+         if Is_Logical_Operator (N) then\n+            return Abandon;\n+         else\n+            return OK;\n+         end if;\n+      end Check_Node;\n+\n+      function Traverse is new Traverse_Func (Check_Node);\n+\n+   --  Start of processing for Has_Decision\n+\n+   begin\n+      return Traverse (N) = Abandon;\n+   end Has_Decision;\n+\n+   ----------\n+   -- Hash --\n+   ----------\n+\n+   function Hash (F : Source_Ptr) return Header_Num is\n+   begin\n+      return Header_Num (Nat (F) mod 997);\n+   end Hash;\n+\n+   ----------\n+   -- Init --\n+   ----------\n+\n+   procedure Init is\n+   begin\n+      null;\n+   end Init;\n+\n+   -------------------------\n+   -- Is_Logical_Operator --\n+   -------------------------\n+\n+   function Is_Logical_Operator (N : Node_Id) return Boolean is\n+   begin\n+      return Nkind_In (N, N_Op_And,\n+                          N_Op_Or,\n+                          N_Op_Xor,\n+                          N_Op_Not,\n+                          N_And_Then,\n+                          N_Or_Else);\n+   end Is_Logical_Operator;\n+\n+   -----------------------\n+   -- Process_Decisions --\n+   -----------------------\n+\n+   procedure Process_Decisions\n+     (N : Node_Id;\n+      T : Character)\n+   is\n+      function Process_Node (N : Node_Id) return Traverse_Result;\n+      --  Processes one node in the traversal, looking for logical operators,\n+      --  and if one is found, outputs the appropriate table entries.\n+\n+      procedure Output_Decision_Operand (N : Node_Id);\n+      --  The node N is the top level logical operator of a decision, or it is\n+      --  one of the operands of a logical operator belonging to a single\n+      --  complex decision. This routine outputs the sequence of table entries\n+      --  corresponding to the node. Note that we do not process the sub-\n+      --  operands to look for further decisions, that processing is done in\n+      --  Process_Decision_Operand, because we can't get decisions mixed up in\n+      --  the global table. Call has no effect if N is Empty.\n+\n+      procedure Output_Element (N : Node_Id; T : Character);\n+      --  Node N is an operand of a logical operator that is not itself a\n+      --  logical operator, or it is a simple decision. This routine outputs\n+      --  the table entry for the element, with C1 set to T (' ' for one of\n+      --  the elements of a complex decision, or 'I'/'W'/'E' for a simple\n+      --  decision (from an IF, WHILE, or EXIT WHEN). Last is set to False,\n+      --  and an entry is made in the condition hash table.\n+\n+      procedure Process_Decision_Operand (N : Node_Id);\n+      --  This is called on node N, the top level node of a decision, or on one\n+      --  of its operands or suboperands after generating the full output for\n+      --  the complex decision. It process the suboperands of the decision\n+      --  looking for nested decisions.\n+\n+      -----------------------------\n+      -- Output_Decision_Operand --\n+      -----------------------------\n+\n+      procedure Output_Decision_Operand (N : Node_Id) is\n+         C : Character;\n+         L : Node_Id;\n+\n+         FSloc : Source_Ptr;\n+         LSloc : Source_Ptr;\n+\n+      begin\n+         if No (N) then\n+            return;\n+\n+         --  Logical operator\n+\n+         elsif Is_Logical_Operator (N) then\n+            if Nkind (N) = N_Op_Not then\n+               C := '!';\n+               L := Empty;\n+\n+            else\n+               L := Left_Opnd (N);\n+\n+               if Nkind (N) = N_Op_Xor then\n+                  C := '^';\n+               elsif Nkind_In (N, N_Op_Or, N_Or_Else) then\n+                  C := '|';\n+               else\n+                  C := '&';\n+               end if;\n+            end if;\n+\n+            Sloc_Range (N, FSloc, LSloc);\n+            Set_Table_Entry (C, ' ', FSloc, LSloc, False);\n+\n+            Output_Decision_Operand (L);\n+            Output_Decision_Operand (Right_Opnd (N));\n+\n+         --  Not a logical operator\n+\n+         else\n+            Output_Element (N, ' ');\n+         end if;\n+      end Output_Decision_Operand;\n+\n+      --------------------\n+      -- Output_Element --\n+      --------------------\n+\n+      procedure Output_Element (N : Node_Id; T : Character) is\n+         FSloc : Source_Ptr;\n+         LSloc : Source_Ptr;\n+      begin\n+         Sloc_Range (N, FSloc, LSloc);\n+         Set_Table_Entry (T, 'c', FSloc, LSloc, False);\n+         Condition_Hash_Table.Set (FSloc, SCO_Table.Last);\n+      end Output_Element;\n+\n+      ------------------------------\n+      -- Process_Decision_Operand --\n+      ------------------------------\n+\n+      procedure Process_Decision_Operand (N : Node_Id) is\n+      begin\n+         if Is_Logical_Operator (N) then\n+            if Nkind (N) /= N_Op_Not then\n+               Process_Decision_Operand (Left_Opnd (N));\n+            end if;\n+\n+            Process_Decision_Operand (Right_Opnd (N));\n+\n+         else\n+            Process_Decisions (N, 'X');\n+         end if;\n+      end Process_Decision_Operand;\n+\n+      ------------------\n+      -- Process_Node --\n+      ------------------\n+\n+      function Process_Node (N : Node_Id) return Traverse_Result is\n+      begin\n+         case Nkind (N) is\n+\n+               --  Logical operators and short circuit forms, output table\n+               --  entries and then process operands recursively to deal with\n+               --  nested conditions.\n+\n+            when N_And_Then                    |\n+                 N_Or_Else                     |\n+                 N_Op_And                      |\n+                 N_Op_Or                       |\n+                 N_Op_Xor                      |\n+                 N_Op_Not                      =>\n+\n+               declare\n+                  T : Character;\n+\n+               begin\n+                  --  If outer level, then type comes from call, otherwise it\n+                  --  is more deeply nested and counts as X for expression.\n+\n+                  if N = Process_Decisions.N then\n+                     T := Process_Decisions.T;\n+                  else\n+                     T := 'X';\n+                  end if;\n+\n+                  --  Output header for sequence\n+\n+                  Set_Table_Entry (T, ' ', No_Location, No_Location, False);\n+\n+                  --  Output the decision\n+\n+                  Output_Decision_Operand (N);\n+\n+                  --  Change Last in last table entry to True to mark end\n+\n+                  SCO_Table.Table (SCO_Table.Last).Last := True;\n+\n+                  --  Process any embedded decisions\n+\n+                  Process_Decision_Operand (N);\n+                  return Skip;\n+               end;\n+\n+            --  Conditional expression, processed like an if statement\n+\n+            when N_Conditional_Expression      =>\n+               declare\n+                  Cond : constant Node_Id := First (Expressions (N));\n+                  Thnx : constant Node_Id := Next (Cond);\n+                  Elsx : constant Node_Id := Next (Thnx);\n+               begin\n+                  Process_Decisions (Cond, 'I');\n+                  Process_Decisions (Thnx, 'X');\n+                  Process_Decisions (Elsx, 'X');\n+                  return Skip;\n+               end;\n+\n+            --  All other cases, continue scan\n+\n+            when others =>\n+               return OK;\n+\n+         end case;\n+      end Process_Node;\n+\n+      procedure Traverse is new Traverse_Proc (Process_Node);\n+\n+   --  Start of processing for Process_Decisions\n+\n+   begin\n+      if No (N) then\n+         return;\n+      end if;\n+\n+      --  See if we have simple decision at outer level and if so then\n+      --  generate the decision entry for this simple decision. A simple\n+      --  decision is a boolean expression (which is not a logical operator\n+      --  or short circuit form) appearing as the operand of an IF, WHILE\n+      --  or EXIT WHEN construct.\n+\n+      if T /= 'X' and then not Is_Logical_Operator (N) then\n+         Output_Element (N, T);\n+\n+         --  Change Last in last table entry to True to mark end of\n+         --  sequence, which is this case is only one element long.\n+\n+         SCO_Table.Table (SCO_Table.Last).Last := True;\n+      end if;\n+\n+      Traverse (N);\n+   end Process_Decisions;\n+\n+   ----------------\n+   -- SCO_Output --\n+   ----------------\n+\n+   procedure SCO_Output (U : Unit_Number_Type) is\n+      Start : Nat;\n+      Stop  : Nat;\n+\n+      procedure Output_Range (From : Source_Ptr; To : Source_Ptr);\n+      --  Outputs Sloc range in line:col-line:col format (for now we do not\n+      --  worry about generic instantiations???)\n+\n+      ------------------\n+      -- Output_Range --\n+      ------------------\n+\n+      procedure Output_Range (From : Source_Ptr; To : Source_Ptr) is\n+      begin\n+         Write_Info_Nat (Int (Get_Logical_Line_Number (From)));\n+         Write_Info_Char (':');\n+         Write_Info_Nat (Int (Get_Column_Number (From)));\n+         Write_Info_Char ('-');\n+         Write_Info_Nat (Int (Get_Logical_Line_Number (To)));\n+         Write_Info_Char (':');\n+         Write_Info_Nat (Int (Get_Column_Number (To)));\n+      end Output_Range;\n+\n+   --  Start of processing for SCO_Output\n+\n+   begin\n+      if Debug_Flag_Dot_OO then\n+         dsco;\n+      end if;\n+\n+      --  Find entry in unit table and set Start/Stop bounds in SCO table\n+\n+      for J in SCO_Unit_Table.First .. SCO_Unit_Table.Last loop\n+         if U = SCO_Unit_Table.Table (J).Unit then\n+            Start := SCO_Unit_Table.Table (J).Index;\n+\n+            if J = SCO_Unit_Table.Last then\n+               Stop := SCO_Table.Last;\n+            else\n+               Stop := SCO_Unit_Table.Table (J + 1).Index - 1;\n+            end if;\n+\n+            exit;\n+         end if;\n+\n+         --  Seems like we should find the unit, but for now ignore ???\n+\n+         return;\n+      end loop;\n+\n+      --  Loop through relevant entries in SCO table, outputting C lines\n+\n+      while Start <= Stop loop\n+         declare\n+            T : SCO_Table_Entry renames SCO_Table.Table (Start);\n+\n+         begin\n+            Write_Info_Initiate ('C');\n+            Write_Info_Char (T.C1);\n+\n+            case T.C1 is\n+\n+               --  Statements, entry, exit\n+\n+               when 'S' | 'Y' | 'T' =>\n+                  Write_Info_Char (' ');\n+                  Output_Range (T.From, T.To);\n+\n+               --  Decision\n+\n+               when 'I' | 'E' | 'W' | 'X' =>\n+                  if T.C2 = ' ' then\n+                     Start := Start + 1;\n+                  end if;\n+\n+                  --  Loop through table entries for this decision\n+\n+                  loop\n+                     declare\n+                        T : SCO_Table_Entry renames SCO_Table.Table (Start);\n+\n+                     begin\n+                        Write_Info_Char (' ');\n+\n+                        if T.C1 = '!' or else\n+                           T.C1 = '^' or else\n+                           T.C1 = '&' or else\n+                           T.C1 = '|'\n+                        then\n+                           Write_Info_Char (T.C1);\n+\n+                        else\n+                           Write_Info_Char (T.C2);\n+                           Output_Range (T.From, T.To);\n+                        end if;\n+\n+                        exit when T.Last;\n+                        Start := Start + 1;\n+                     end;\n+                  end loop;\n+\n+               when others =>\n+                  raise Program_Error;\n+            end case;\n+\n+            Write_Info_Terminate;\n+         end;\n+\n+         exit when Start = Stop;\n+         Start := Start + 1;\n+\n+         pragma Assert (Start <= Stop);\n+      end loop;\n+   end SCO_Output;\n+\n+   ----------------\n+   -- SCO_Record --\n+   ----------------\n+\n+   procedure SCO_Record (U : Unit_Number_Type) is\n+      Cu : constant Node_Id := Cunit (U);\n+      Lu : constant Node_Id := Unit (Cu);\n+\n+   begin\n+      SCO_Unit_Table.Append ((Unit => U, Index => SCO_Table.Last + 1));\n+\n+      --  Traverse the unit\n+\n+      if Nkind (Lu) = N_Subprogram_Body then\n+         Traverse_Subprogram_Body (Lu);\n+\n+      elsif Nkind (Lu) = N_Package_Declaration then\n+         Traverse_Package_Declaration (Lu);\n+\n+      elsif Nkind (Lu) = N_Package_Body then\n+         Traverse_Package_Body (Lu);\n+\n+      --  Ignore subprogram specifications\n+      --  Also for now, ignore generic declarations and instantiations\n+\n+      else\n+         null;\n+      end if;\n+   end SCO_Record;\n+\n+   -----------------------\n+   -- Set_SCO_Condition --\n+   -----------------------\n+\n+   procedure Set_SCO_Condition (First_Loc : Source_Ptr; Typ : Character) is\n+      Index : constant Nat := Condition_Hash_Table.Get (First_Loc);\n+   begin\n+      if Index /= 0 then\n+         SCO_Table.Table (Index).C2 := Typ;\n+      end if;\n+   end Set_SCO_Condition;\n+\n+   ---------------------\n+   -- Set_Table_Entry --\n+   ---------------------\n+\n+   procedure Set_Table_Entry\n+     (C1   : Character;\n+      C2   : Character;\n+      From : Source_Ptr;\n+      To   : Source_Ptr;\n+      Last : Boolean)\n+   is\n+   begin\n+      SCO_Table.Append ((C1   => C1,\n+                         C2   => C2,\n+                         From => From,\n+                         To   => To,\n+                         Last => Last));\n+   end Set_Table_Entry;\n+\n+   -----------------------------------------\n+   -- Traverse_Declarations_Or_Statements --\n+   -----------------------------------------\n+\n+   procedure Traverse_Declarations_Or_Statements (L : List_Id) is\n+      N     : Node_Id;\n+      Start : Source_Ptr;\n+      Dummy : Source_Ptr;\n+      Stop  : Source_Ptr;\n+      From  : Source_Ptr;\n+      To    : Source_Ptr;\n+\n+      Term  : Boolean;\n+      --  Set False if current entity terminates statement list\n+\n+      procedure Set_Statement_Entry;\n+      --  If Start is No_Location, does nothing, otherwise outputs a SCO_Table\n+      --  statement entry for the range Start-Stop and then sets both Start\n+      --  and Stop to No_Location. Unconditionally sets Term to True. This is\n+      --  called when we find a statement or declaration that generates its\n+      --  own table entry, so that we must end the current statement sequence.\n+\n+      -------------------------\n+      -- Set_Statement_Entry --\n+      -------------------------\n+\n+      procedure Set_Statement_Entry is\n+      begin\n+         Term := True;\n+\n+         if Start /= No_Location then\n+            Set_Table_Entry ('S', ' ', Start, Stop, False);\n+            Start := No_Location;\n+            Stop  := No_Location;\n+         end if;\n+      end Set_Statement_Entry;\n+\n+   --  Start of processing for Traverse_Declarations_Or_Statements\n+\n+   begin\n+      if Is_Non_Empty_List (L) then\n+         N := First (L);\n+         Start := No_Location;\n+\n+         --  Loop through statements or declarations\n+\n+         while Present (N) loop\n+            Term := False;\n+\n+            case Nkind (N) is\n+\n+               --  Package declaration\n+\n+               when N_Package_Declaration =>\n+                  Set_Statement_Entry;\n+                  Traverse_Package_Declaration (N);\n+\n+               --  Package body\n+\n+               when N_Package_Body =>\n+                  Set_Statement_Entry;\n+                  Traverse_Package_Body (N);\n+\n+               --  Subprogram_Body\n+\n+               when N_Subprogram_Body =>\n+                  Set_Statement_Entry;\n+                  Traverse_Subprogram_Body (N);\n+\n+               --  Exit statement\n+\n+               when N_Exit_Statement =>\n+                  Set_Statement_Entry;\n+                  Process_Decisions (Condition (N), 'E');\n+\n+                  --  This is an exit point\n+\n+                  Sloc_Range (N, From, To);\n+                  Set_Table_Entry ('T', ' ', From, To, False);\n+\n+               --  Block statement\n+\n+               when N_Block_Statement =>\n+                  Set_Statement_Entry;\n+                  Traverse_Declarations_Or_Statements (Declarations (N));\n+                  Traverse_Handled_Statement_Sequence\n+                    (Handled_Statement_Sequence (N));\n+\n+               --  If statement\n+\n+               when N_If_Statement =>\n+                  Set_Statement_Entry;\n+                  Process_Decisions (Condition (N), 'I');\n+                  Traverse_Declarations_Or_Statements (Then_Statements (N));\n+\n+                  if Present (Elsif_Parts (N)) then\n+                     declare\n+                        Elif : Node_Id := First (Elsif_Parts (N));\n+                     begin\n+                        while Present (Elif) loop\n+                           Process_Decisions (Condition (Elif), 'I');\n+                           Traverse_Declarations_Or_Statements\n+                             (Then_Statements (Elif));\n+                           Next (Elif);\n+                        end loop;\n+                     end;\n+                  end if;\n+\n+                  Traverse_Declarations_Or_Statements (Else_Statements (N));\n+\n+                  --  Unconditional exit points\n+\n+               when N_Requeue_Statement |\n+                    N_Goto_Statement    |\n+                    N_Raise_Statement   =>\n+                  Set_Statement_Entry;\n+                  Sloc_Range (N, From, To);\n+                  Set_Table_Entry ('T', ' ', From, To, False);\n+\n+               --  Simple return statement\n+\n+               when N_Simple_Return_Statement =>\n+                  Set_Statement_Entry;\n+\n+                  --  Process possible return expression\n+\n+                  Process_Decisions (Expression (N), 'X');\n+\n+                  --  Return is an exit point\n+\n+                  Sloc_Range (N, From, To);\n+                  Set_Table_Entry ('T', ' ', From, To, False);\n+\n+               --  Extended return statement\n+\n+               when N_Extended_Return_Statement =>\n+                  Set_Statement_Entry;\n+                  Traverse_Declarations_Or_Statements\n+                    (Return_Object_Declarations (N));\n+                  Traverse_Handled_Statement_Sequence\n+                    (Handled_Statement_Sequence (N));\n+\n+                  --  Return is an exit point\n+\n+                  Sloc_Range (N, From, To);\n+                  Set_Table_Entry ('T', ' ', From, To, False);\n+\n+               --  Loop\n+\n+               when N_Loop_Statement =>\n+\n+                  --  Even if not a while loop, we want a new statement seq\n+\n+                  Set_Statement_Entry;\n+\n+                  if Present (Iteration_Scheme (N)) then\n+                     Process_Decisions\n+                       (Condition (Iteration_Scheme (N)), 'W');\n+                  end if;\n+\n+                  Traverse_Declarations_Or_Statements (Statements (N));\n+\n+               --  All other cases\n+\n+               when others =>\n+                  if Has_Decision (N) then\n+                     Set_Statement_Entry;\n+                     Process_Decisions (N, 'X');\n+                  end if;\n+            end case;\n+\n+            --  If that element did not terminate the current sequence of\n+            --  statements, then establish or extend this sequence.\n+\n+            if not Term then\n+               if Start = No_Location then\n+                  Sloc_Range (N, Start, Stop);\n+               else\n+                  Sloc_Range (N, Dummy, Stop);\n+               end if;\n+            end if;\n+\n+            Next (N);\n+         end loop;\n+\n+         Set_Statement_Entry;\n+      end if;\n+   end Traverse_Declarations_Or_Statements;\n+\n+   -----------------------------------------\n+   -- Traverse_Handled_Statement_Sequence --\n+   -----------------------------------------\n+\n+   procedure Traverse_Handled_Statement_Sequence (N : Node_Id) is\n+      Handler : Node_Id;\n+\n+   begin\n+      if Present (N) then\n+         Traverse_Declarations_Or_Statements (Statements (N));\n+\n+         if Present (Exception_Handlers (N)) then\n+            Handler := First (Exception_Handlers (N));\n+            while Present (Handler) loop\n+               Traverse_Declarations_Or_Statements (Statements (Handler));\n+               Next (Handler);\n+            end loop;\n+         end if;\n+      end if;\n+   end Traverse_Handled_Statement_Sequence;\n+\n+   ---------------------------\n+   -- Traverse_Package_Body --\n+   ---------------------------\n+\n+   procedure Traverse_Package_Body (N : Node_Id) is\n+   begin\n+      Traverse_Declarations_Or_Statements (Declarations (N));\n+      Traverse_Handled_Statement_Sequence (Handled_Statement_Sequence (N));\n+   end Traverse_Package_Body;\n+\n+   ----------------------------------\n+   -- Traverse_Package_Declaration --\n+   ----------------------------------\n+\n+   procedure Traverse_Package_Declaration (N : Node_Id) is\n+      Spec : constant Node_Id := Specification (N);\n+   begin\n+      Traverse_Declarations_Or_Statements (Visible_Declarations (Spec));\n+      Traverse_Declarations_Or_Statements (Private_Declarations (Spec));\n+   end Traverse_Package_Declaration;\n+\n+   ------------------------------\n+   -- Traverse_Subprogram_Body --\n+   ------------------------------\n+\n+   procedure Traverse_Subprogram_Body (N : Node_Id) is\n+   begin\n+      Traverse_Declarations_Or_Statements (Declarations (N));\n+      Traverse_Handled_Statement_Sequence (Handled_Statement_Sequence (N));\n+   end Traverse_Subprogram_Body;\n+\n+end Par_SCO;"}, {"sha": "273c11c72be6ad878d52d4a741205ee34dc7b29f", "filename": "gcc/ada/par_sco.ads", "status": "added", "additions": 200, "deletions": 0, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f12117afc93e5af5f2cdb1cfc99e285a15f9a91/gcc%2Fada%2Fpar_sco.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f12117afc93e5af5f2cdb1cfc99e285a15f9a91/gcc%2Fada%2Fpar_sco.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar_sco.ads?ref=6f12117afc93e5af5f2cdb1cfc99e285a15f9a91", "patch": "@@ -0,0 +1,200 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              P A R _ S C O                               --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--             Copyright (C) 2009, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains the routines used to deal with generation and output\n+--  of Soure Coverage Obligations (SCO's) used for coverage analysis purposes.\n+\n+with Types; use Types;\n+\n+package Par_SCO is\n+\n+   ----------------\n+   -- SCO Format --\n+   ----------------\n+\n+   --  Source coverage obligations are generated on a unit-by-unit basis in the\n+   --  ALI file, using lines that start with the identifying character C. These\n+   --  lines are generated if the -gnatC switch is set.\n+\n+   --  Sloc Ranges\n+\n+   --    In several places in the SCO lines, Sloc ranges appear. These are used\n+   --    to indicate the first and last Sloc of some construct in the tree and\n+   --    they have the form:\n+\n+   --      line:col-line:col    ??? do we need generic instantiation stuff ???\n+\n+   --  Statements\n+\n+   --    For the purpose of SCO generation, the notion of statement includes\n+   --    simple statements and also the following declaration types:\n+\n+   --      type_declaration\n+   --      subtype_declaration\n+   --      object_declaration\n+   --      renaming_declaration\n+   --      generic_instantiation\n+\n+   --      ??? is this list complete ???\n+\n+   --    ??? what is the exact story on complex statements such as blocks ???\n+   --    ??? are the simple statements inside sufficient ???\n+\n+   --  Statement lines\n+\n+   --    These lines correspond to a sequence of one or more statements which\n+   --    are always exeecuted in sequence, The first statement may be an entry\n+   --    point (e.g. statement after a label), and the last statement may be\n+   --    an exit point (e.g. an exit statement), but no other entry or exit\n+   --    points may occur within the sequence of statements. The idea is that\n+   --    the sequence can be treated as a single unit from a coverage point of\n+   --    view, if any of the code for the statement sequence is executed, this\n+   --    corresponds to coverage of the entire statement sequence. The form of\n+   --    a statement line in the ALI file is:\n+\n+   --      CS sloc-range\n+\n+   --  Entry points\n+\n+   --    An entry point is a statement to which control may be passed other\n+   --    than by falling into the statement for above. Examples are the first\n+   --    statement of the body of a loop, and the statement following a label.\n+   --    The form of an entry point in the ALI file is:\n+\n+   --      CY sloc-range\n+\n+   --  Exit points\n+\n+   --    An exit point is a statement that causes transfer of control. Examples\n+   --    are exit statements, raise statements and return statements. The form\n+   --    of an exit point in the ALI file is:\n+\n+   --      CT sloc-range\n+\n+   --  Decisions\n+\n+   --    Decisions represent the most significant section of the SCO lines\n+\n+   --    Note: in the following description, logical operator includes the\n+   --    short circuited forms (so can be any of AND, OR, XOR, NOT, AND THEN,\n+   --    or OR ELSE).\n+\n+   --    Decisions are either simple or complex. A simple decision is a boolean\n+   --    expresssion that occurs in the context of a control structure in the\n+   --    source program, including WHILE, IF, EXIT WHEN. Note that a boolean\n+   --    expression in any other context, e.g. on the right side of an\n+   --    assignment, is not considered to be a decision.\n+\n+   --    A complex decision is an occurrence of a logical operator which is not\n+   --    itself an operand of some other logical operator. If any operand of\n+   --    the logical operator is itself a logical operator, this is not a\n+   --    separate decision, it is part of the same decision.\n+\n+   --    So for example, if we have\n+\n+   --        A, B, C, D : Boolean;\n+   --        function F (Arg : Boolean) return Boolean);\n+   --        ...\n+   --        A and then (B or else F (C and then D))\n+\n+   --    There are two (complex) decisions here:\n+\n+   --        1. X and then (Y or else Z)\n+\n+   --           where X = A, Y = B, and Z = F (C and then D)\n+\n+   --        2. C and then D\n+\n+   --    For each decision, a decision line is generated with the form:\n+\n+   --      C* expression\n+\n+   --    Here * is one of the following characters:\n+\n+   --      I  decision in IF statement or conditional expression\n+   --      E  decision in EXIT WHEN statement\n+   --      W  decision in WHILE iteration scheme\n+   --      X  decision appearing in some other expression context\n+\n+   --    The expression is a prefix polish form indicating the structure of\n+   --    the decision, including logical operators and short circuit forms.\n+   --    The following is a grammar showing the structure of expression:\n+\n+   --      expression ::= term             (if expr is not logical operator)\n+   --      expression ::= & term term      (if expr is AND or AND THEN)\n+   --      expression ::= | term term      (if expr is OR or OR ELSE)\n+   --      expression ::= ^ term term      (if expr is XOR)\n+   --      expression ::= !term            (if expr is NOT)\n+\n+   --      term ::= element\n+   --      term ::= expression\n+\n+   --      element ::= outcome sloc-range\n+\n+   --    outcome is one of the following letters:\n+\n+   --      c  condition\n+   --      t  true condition\n+   --      f  false condition\n+\n+   --      where t/f are used to mark a condition that has been recognized by\n+   --      the compiler as always being true or false.\n+\n+   --    & indicates either AND or AND THEN connecting two conditions. In the\n+   --    context of couverture we only permit AND THEN in the source in any\n+   --    case, so & can always be understood to be AND THEN.\n+\n+   --    | indicates either OR or OR ELSE connection two conditions. In the\n+   --    context of couverture we only permit OR ELSE in the source in any\n+   --    case, so | can always be understood to be OR ELSE.\n+\n+   --    ^ indicates XOR connecting two conditions. In the context of\n+   --    couverture, we do not permit XOR, so this will never appear.\n+\n+   --    ! indicates NOT applied to the expression.\n+\n+   -----------------\n+   -- Subprograms --\n+   -----------------\n+\n+   procedure Init;\n+   --  Initialize internal tables for a new compilation\n+\n+   procedure SCO_Record (U : Unit_Number_Type);\n+   --  This procedure scans the tree for the unit identified by U, populating\n+   --  internal tables recording the SCO information. Note that this is done\n+   --  before any semantic analysis/expansion happens.\n+\n+   procedure Set_SCO_Condition (First_Loc : Source_Ptr; Typ : Character);\n+   --  This procedure is called during semantic analysis to record a condition\n+   --  which has been identified as always True (Typ = 't') or always False\n+   --  (Typ = 'f') by the compiler. The condition is identified by the\n+   --  First_Sloc value in the original tree.\n+\n+   procedure SCO_Output (U : Unit_Number_Type);\n+   --  Outputs SCO lines for unit U in the ALI file, as recorded by a previous\n+   --  call to SCO_Record, possibly modified by calls to Set_SCO_Condition.\n+\n+end Par_SCO;"}, {"sha": "2b7ecf3fc78fa45270e578f10f7f0d1314072ac0", "filename": "gcc/ada/sem_warn.adb", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f12117afc93e5af5f2cdb1cfc99e285a15f9a91/gcc%2Fada%2Fsem_warn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f12117afc93e5af5f2cdb1cfc99e285a15f9a91/gcc%2Fada%2Fsem_warn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_warn.adb?ref=6f12117afc93e5af5f2cdb1cfc99e285a15f9a91", "patch": "@@ -33,6 +33,7 @@ with Lib;      use Lib;\n with Namet;    use Namet;\n with Nlists;   use Nlists;\n with Opt;      use Opt;\n+with Par_SCO;  use Par_SCO;\n with Rtsfind;  use Rtsfind;\n with Sem;      use Sem;\n with Sem_Ch8;  use Sem_Ch8;\n@@ -3307,7 +3308,8 @@ package body Sem_Warn is\n    -----------------------------\n \n    procedure Warn_On_Known_Condition (C : Node_Id) is\n-      P : Node_Id;\n+      P    : Node_Id;\n+      Orig : constant Node_Id := Original_Node (C);\n \n       procedure Track (N : Node_Id; Loc : Node_Id);\n       --  Adds continuation warning(s) pointing to reason (assignment or test)\n@@ -3356,6 +3358,35 @@ package body Sem_Warn is\n    --  Start of processing for Warn_On_Known_Condition\n \n    begin\n+      --  Adjust SCO condition if from source\n+\n+      if Comes_From_Source (Orig) then\n+         declare\n+            Start : Source_Ptr;\n+            Dummy : Source_Ptr;\n+            Typ   : Character;\n+            Atrue : Boolean;\n+\n+         begin\n+            Sloc_Range (Orig, Start, Dummy);\n+            Atrue := Entity (C) = Standard_True;\n+\n+            if Present (Parent (C))\n+              and then Nkind (Parent (C)) = N_Op_Not\n+            then\n+               Atrue := not Atrue;\n+            end if;\n+\n+            if Atrue then\n+               Typ := 't';\n+            else\n+               Typ := 'f';\n+            end if;\n+\n+            Set_SCO_Condition (Start, Typ);\n+         end;\n+      end if;\n+\n       --  Argument replacement in an inlined body can make conditions static.\n       --  Do not emit warnings in this case.\n "}, {"sha": "6825f4ec038efddb251f5dea1be897a90d377b68", "filename": "gcc/ada/switch-c.adb", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f12117afc93e5af5f2cdb1cfc99e285a15f9a91/gcc%2Fada%2Fswitch-c.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f12117afc93e5af5f2cdb1cfc99e285a15f9a91/gcc%2Fada%2Fswitch-c.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch-c.adb?ref=6f12117afc93e5af5f2cdb1cfc99e285a15f9a91", "patch": "@@ -462,11 +462,19 @@ package body Switch.C is\n \n                      Ptr := Max + 1;\n \n+                  --  -gnatez ???\n+\n                   when 'z' =>\n                      Store_Switch := False;\n                      Disable_Switch_Storing;\n                      Ptr := Ptr + 1;\n \n+                  --  -gnateS (Store SCO information)\n+\n+                  when 'S' =>\n+                     Generate_SCO := True;\n+                     Ptr := Ptr + 1;\n+\n                   --  All other -gnate? switches are unassigned\n \n                   when others =>"}, {"sha": "6b87db9a91f140445789b0d8a09b2381dfb94e7f", "filename": "gcc/ada/usage.adb", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f12117afc93e5af5f2cdb1cfc99e285a15f9a91/gcc%2Fada%2Fusage.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f12117afc93e5af5f2cdb1cfc99e285a15f9a91/gcc%2Fada%2Fusage.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fusage.adb?ref=6f12117afc93e5af5f2cdb1cfc99e285a15f9a91", "patch": "@@ -202,6 +202,11 @@ begin\n    Write_Switch_Char (\"ep=?\");\n    Write_Line (\"Specify preprocessing data file, e.g. -gnatep=prep.data\");\n \n+   --  Line for -gnateS switch\n+\n+   Write_Switch_Char (\"eS\");\n+   Write_Line (\"Generate SCO (Source Coverage Obligation) information\");\n+\n    --  Line for -gnatE switch\n \n    Write_Switch_Char (\"E\");"}]}