{"sha": "caf93cb0d55b2a7d00eee250b5880a53205eef7c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2FmOTNjYjBkNTViMmE3ZDAwZWVlMjUwYjU4ODBhNTMyMDVlZWY3Yw==", "commit": {"author": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2004-07-21T19:23:03Z"}, "committer": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2004-07-21T19:23:03Z"}, "message": "builtins.c (expand_builtin_setjmp_receiver): Fix comment for code removal.\n\n2004-07-21  Eric Christopher  <echristo@redhat.com>\n\n\t* builtins.c (expand_builtin_setjmp_receiver): Fix comment for code\n\tremoval.\n\t* c-decl.c (pop_scope): Ditto.\n\t* calls.c (expand_call): Remove call to current_nesting_level,\n\tupdate comment accordingly. Remove calls to expand_start_target_temps\n\tand expand_end_target_temps.\n\t* cfgexpand.c (construct_init_block): Remove call to\n\texpand_start_bindings_and_block.\n\t(construct_exit_block): Remove call to expand_end_bindings.\n\t* expr.c (safe_from_p): Remove BIND_EXPR handling.\n\t(expand_expr_real_1): Ditto. Fix formatting.\n\t(expand_vars): Delete.\n\t* stmt.c (POPSTACK): Remove block_stack.\n\t(stmt_status): Remove x_block_stack.\n\t(block_stack): Delete.\n\t(expand_start_bindings_and_block): Ditto.\n\t(expand_start_target_temps): Ditto.\n\t(expand_end_target_temps): Ditto.\n\t(current_nesting_level): Ditto.\n\t(warn_about_unused_variables): Ditto.\n\t(expand_end_bindings): Ditto.\n\t* tree.h: Remove declarations for above.\n\n2004-07-21  Eric Christopher  <echristo@redhat.com>\n\n\t* decl.c (poplevel): Inline unused variable checking.\n\tChange formatting.\n\nFrom-SVN: r85019", "tree": {"sha": "62d1d9e6aa0313957234dd1e34bd0b74115418e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/62d1d9e6aa0313957234dd1e34bd0b74115418e7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/caf93cb0d55b2a7d00eee250b5880a53205eef7c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/caf93cb0d55b2a7d00eee250b5880a53205eef7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/caf93cb0d55b2a7d00eee250b5880a53205eef7c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/caf93cb0d55b2a7d00eee250b5880a53205eef7c/comments", "author": null, "committer": null, "parents": [{"sha": "d942072cb0b0ffebeff215e3ee182e882ffcbf9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d942072cb0b0ffebeff215e3ee182e882ffcbf9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d942072cb0b0ffebeff215e3ee182e882ffcbf9e"}], "stats": {"total": 806, "additions": 294, "deletions": 512}, "files": [{"sha": "1904899db2f183a5d058db4064919cadd743c109", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caf93cb0d55b2a7d00eee250b5880a53205eef7c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caf93cb0d55b2a7d00eee250b5880a53205eef7c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=caf93cb0d55b2a7d00eee250b5880a53205eef7c", "patch": "@@ -1,3 +1,28 @@\n+2004-07-21  Eric Christopher  <echristo@redhat.com>\n+\n+\t* builtins.c (expand_builtin_setjmp_receiver): Fix comment for code\n+\tremoval.\n+\t* c-decl.c (pop_scope): Ditto.\n+\t* calls.c (expand_call): Remove call to current_nesting_level,\n+\tupdate comment accordingly. Remove calls to expand_start_target_temps\n+\tand expand_end_target_temps.\n+\t* cfgexpand.c (construct_init_block): Remove call to\n+\texpand_start_bindings_and_block.\n+\t(construct_exit_block): Remove call to expand_end_bindings.\n+\t* expr.c (safe_from_p): Remove BIND_EXPR handling.\n+\t(expand_expr_real_1): Ditto. Fix formatting.\n+\t(expand_vars): Delete.\n+\t* stmt.c (POPSTACK): Remove block_stack.\n+\t(stmt_status): Remove x_block_stack.\n+\t(block_stack): Delete.\n+\t(expand_start_bindings_and_block): Ditto.\n+\t(expand_start_target_temps): Ditto.\n+\t(expand_end_target_temps): Ditto.\n+\t(current_nesting_level): Ditto.\n+\t(warn_about_unused_variables): Ditto.\n+\t(expand_end_bindings): Ditto.\n+\t* tree.h: Remove declarations for above.\n+\n 2004-07-21  Steven Bosscher  <stevenb@suse.de>\n \n \t* rtl.h (insn_note): Remove NOTE_INSN_PREDICTION.\n@@ -125,7 +150,6 @@\n \tfor EXTRA_SECTION_FUNCTIONS.\n \t* doc/install.texi: Update binutils requirements.\n \n->>>>>>> 2.4622\n 2004-07-20  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* vec.h (VEC_T_length, VEC_T_index, VEC_T_iterate, VEC_T_truncate,"}, {"sha": "2d3d440ea678003cfc047758f9bdaf175237aaba", "filename": "gcc/builtins.c", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caf93cb0d55b2a7d00eee250b5880a53205eef7c/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caf93cb0d55b2a7d00eee250b5880a53205eef7c/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=caf93cb0d55b2a7d00eee250b5880a53205eef7c", "patch": "@@ -571,8 +571,7 @@ expand_builtin_setjmp_receiver (rtx receiver_label ATTRIBUTE_UNUSED)\n   emit_insn (gen_rtx_CLOBBER (VOIDmode, static_chain_rtx));\n \n   /* Now put in the code to restore the frame pointer, and argument\n-     pointer, if needed.  The code below is from expand_end_bindings\n-     in stmt.c; see detailed documentation there.  */\n+     pointer, if needed.  */\n #ifdef HAVE_nonlocal_goto\n   if (! HAVE_nonlocal_goto)\n #endif\n@@ -814,22 +813,22 @@ expand_builtin_nonlocal_goto (tree arglist)\n       emit_insn (gen_rtx_CLOBBER (VOIDmode,\n \t\t\t\t  gen_rtx_MEM (BLKmode,\n \t\t\t\t\t       hard_frame_pointer_rtx)));\n- \n+\n       /* Restore frame pointer for containing function.\n \t This sets the actual hard register used for the frame pointer\n \t to the location of the function's incoming static chain info.\n \t The non-local goto handler will then adjust it to contain the\n \t proper value and reload the argument pointer, if needed.  */\n       emit_move_insn (hard_frame_pointer_rtx, r_fp);\n       emit_stack_restore (SAVE_NONLOCAL, r_sp, NULL_RTX);\n- \n+\n       /* USE of hard_frame_pointer_rtx added for consistency;\n \t not clear if really needed.  */\n       emit_insn (gen_rtx_USE (VOIDmode, hard_frame_pointer_rtx));\n       emit_insn (gen_rtx_USE (VOIDmode, stack_pointer_rtx));\n       emit_indirect_jump (r_label);\n     }\n- \n+\n   /* Search backwards to the jump insn and mark it as a\n      non-local goto.  */\n   for (insn = get_last_insn (); insn; insn = PREV_INSN (insn))\n@@ -2038,7 +2037,7 @@ expand_builtin_mathfn_3 (tree exp, rtx target, rtx subtarget)\n \t    case BUILT_IN_SIN:\n \t    case BUILT_IN_SINF:\n \t    case BUILT_IN_SINL:\n-\t      if (!expand_twoval_unop (builtin_optab, op0, 0, target, 0))    \n+\t      if (!expand_twoval_unop (builtin_optab, op0, 0, target, 0))\n \t\tabort();\n \t      break;\n \t    case BUILT_IN_COS:\n@@ -7576,13 +7575,13 @@ fold_builtin_isascii (tree arglist)\n     {\n       /* Transform isascii(c) -> ((c & ~0x7f) == 0).  */\n       tree arg = TREE_VALUE (arglist);\n-      \n+\n       arg = fold (build2 (EQ_EXPR, integer_type_node,\n \t\t\t  build2 (BIT_AND_EXPR, integer_type_node, arg,\n \t\t\t\t  build_int_2 (~ (unsigned HOST_WIDE_INT) 0x7f,\n \t\t\t\t\t       ~ (HOST_WIDE_INT) 0)),\n \t\t\t  integer_zero_node));\n-      \n+\n       if (in_gimple_form && !TREE_CONSTANT (arg))\n         return NULL_TREE;\n       else\n@@ -7601,7 +7600,7 @@ fold_builtin_toascii (tree arglist)\n     {\n       /* Transform toascii(c) -> (c & 0x7f).  */\n       tree arg = TREE_VALUE (arglist);\n-      \n+\n       return fold (build2 (BIT_AND_EXPR, integer_type_node, arg,\n \t\t\t   build_int_2 (0x7f, 0)));\n     }\n@@ -7950,15 +7949,15 @@ fold_builtin_1 (tree exp, bool ignore)\n \t  if (flag_unsafe_math_optimizations && BUILTIN_ROOT_P (fcode))\n \t    {\n \t      tree powfn = mathfn_built_in (type, BUILT_IN_POW);\n-\t      \n+\n \t      if (powfn)\n \t        {\n \t\t  tree arg0 = TREE_VALUE (TREE_OPERAND (arg, 1));\n \t\t  tree tree_root;\n \t\t  /* The inner root was either sqrt or cbrt.  */\n \t\t  REAL_VALUE_TYPE dconstroot =\n \t\t    BUILTIN_SQRT_P (fcode) ? dconsthalf : dconstthird;\n-\t\t  \n+\n \t\t  /* Adjust for the outer root.  */\n \t\t  SET_REAL_EXP (&dconstroot, REAL_EXP (&dconstroot) - 1);\n \t\t  dconstroot = real_value_truncate (TYPE_MODE (type), dconstroot);\n@@ -8032,7 +8031,7 @@ fold_builtin_1 (tree exp, bool ignore)\n \t\t\t\t       build_tree_list (NULL_TREE, tree_root));\n \t\t  return build_function_call_expr (powfn, arglist);\n \t\t}\n-\t      \n+\n \t    }\n \t}\n       break;\n@@ -8431,7 +8430,7 @@ fold_builtin_1 (tree exp, bool ignore)\n }\n \n /* A wrapper function for builtin folding that prevents warnings for\n-   \"statement without effect\" and the like, caused by removing the \n+   \"statement without effect\" and the like, caused by removing the\n    call node earlier than the warning is generated.  */\n \n tree\n@@ -8540,7 +8539,7 @@ readonly_data_expr (tree exp)\n   /* Make sure we call decl_readonly_section only for trees it\n      can handle (since it returns true for everything it doesn't\n      understand).  */\n-  if (TREE_CODE (exp) == STRING_CST \n+  if (TREE_CODE (exp) == STRING_CST\n       || TREE_CODE (exp) == CONSTRUCTOR\n       || (TREE_CODE (exp) == VAR_DECL && TREE_STATIC (exp)))\n     return decl_readonly_section (exp, 0);"}, {"sha": "c5b50a263123799a88e4f920bbfb089e85e478ef", "filename": "gcc/c-decl.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caf93cb0d55b2a7d00eee250b5880a53205eef7c/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caf93cb0d55b2a7d00eee250b5880a53205eef7c/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=caf93cb0d55b2a7d00eee250b5880a53205eef7c", "patch": "@@ -746,9 +746,7 @@ pop_scope (void)\n \t  goto common_symbol;\n \n \tcase VAR_DECL:\n-\t  /* Warnings for unused variables.  Keep this in sync with\n-\t     stmt.c:warn_about_unused_variables, which we cannot use\n-\t     since it expects a different data structure.  */\n+\t  /* Warnings for unused variables.  */\n \t  if (warn_unused_variable\n \t      && !TREE_USED (p)\n \t      && !DECL_IN_SYSTEM_HEADER (p)\n@@ -1951,7 +1949,7 @@ pushdecl (tree x)\n \t  bind (name, x, file_scope, /*invisible=*/true, /*nested=*/false);\n \t  nested = true;\n \t}\n-    }      \n+    }\n \n   warn_if_shadowing (x);\n \n@@ -4516,7 +4514,7 @@ grokdeclarator (tree declarator, tree declspecs,\n \t  DECL_EXTERNAL (decl) = 0;\n \telse\n \t  DECL_EXTERNAL (decl) = 1;\n-\t   \n+\n \t/* Record absence of global scope for `static' or `auto'.  */\n \tTREE_PUBLIC (decl)\n \t  = !(specbits & ((1 << (int) RID_STATIC) | (1 << (int) RID_AUTO)));"}, {"sha": "d83b419c4bb5a981ff1a40de5d7202d8ec038fd1", "filename": "gcc/calls.c", "status": "modified", "additions": 1, "deletions": 22, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caf93cb0d55b2a7d00eee250b5880a53205eef7c/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caf93cb0d55b2a7d00eee250b5880a53205eef7c/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=caf93cb0d55b2a7d00eee250b5880a53205eef7c", "patch": "@@ -2232,15 +2232,11 @@ expand_call (tree exp, rtx target, int ignore)\n      finished with regular parsing.  Which means that some of the\n      machinery we use to generate tail-calls is no longer in place.\n      This is most often true of sjlj-exceptions, which we couldn't\n-     tail-call to anyway.\n+     tail-call to anyway.  */\n \n-     If current_nesting_level () == 0, we're being called after\n-     the function body has been expanded.  This can happen when\n-     setting up trampolines in expand_function_end.  */\n   if (currently_expanding_call++ != 0\n       || !flag_optimize_sibling_calls\n       || !rtx_equal_function_value_matters\n-      || current_nesting_level () == 0\n       || args_size.var\n       || lookup_stmt_eh_region (exp) >= 0)\n     try_tail_call = 0;\n@@ -2372,15 +2368,6 @@ expand_call (tree exp, rtx target, int ignore)\n \t sibcall_failure instead of continuing the loop.  */\n       start_sequence ();\n \n-      if (pass == 0)\n-\t{\n-\t  /* We know at this point that there are not currently any\n-\t     pending cleanups.  If, however, in the process of evaluating\n-\t     the arguments we were to create some, we'll need to be\n-\t     able to get rid of them.  */\n-\t  expand_start_target_temps ();\n-\t}\n-\n       /* Don't let pending stack adjusts add up to too much.\n \t Also, do all pending adjustments now if there is any chance\n \t this might be a call to alloca or if we are expanding a sibling\n@@ -3093,14 +3080,6 @@ expand_call (tree exp, rtx target, int ignore)\n \tif (args[i].aligned_regs)\n \t  free (args[i].aligned_regs);\n \n-      if (pass == 0)\n-\t{\n-\t  /* Undo the fake expand_start_target_temps we did earlier.  If\n-\t     there had been any cleanups created, we've already set\n-\t     sibcall_failure.  */\n-\t  expand_end_target_temps ();\n-\t}\n-\n       /* If this function is returning into a memory location marked as\n \t readonly, it means it is initializing that location. We normally treat\n \t functions as not clobbering such locations, so we need to specify that"}, {"sha": "5bcb59cde1ac9b3473523afa2177787e70d0b4c5", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caf93cb0d55b2a7d00eee250b5880a53205eef7c/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caf93cb0d55b2a7d00eee250b5880a53205eef7c/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=caf93cb0d55b2a7d00eee250b5880a53205eef7c", "patch": "@@ -210,7 +210,7 @@ expand_gimple_basic_block (basic_block bb, FILE * dump_file)\n \n       expand_expr_stmt (stmt);\n \n-      /* Java emits line number notes in the top of labels. \n+      /* Java emits line number notes in the top of labels.\n          ??? Make this go away once line number notes are obsoleted.  */\n       BB_HEAD (bb) = NEXT_INSN (last);\n       if (NOTE_P (BB_HEAD (bb)))\n@@ -275,7 +275,7 @@ expand_gimple_basic_block (basic_block bb, FILE * dump_file)\n   if (JUMP_TABLE_DATA_P (last))\n     last = PREV_INSN (PREV_INSN (last));\n   BB_END (bb) = last;\n- \n+\n   if (dump_file)\n     dump_bb (bb, dump_file, 0);\n   update_bb_for_insn (bb);\n@@ -292,8 +292,6 @@ construct_init_block (void)\n   basic_block init_block, first_block;\n   edge e;\n \n-  expand_start_bindings_and_block (0, NULL_TREE);\n-\n   for (e = ENTRY_BLOCK_PTR->succ; e; e = e->succ_next)\n     if (e->dest == ENTRY_BLOCK_PTR->next_bb)\n       break;\n@@ -329,7 +327,7 @@ construct_exit_block (void)\n   basic_block exit_block;\n   edge e, e2, next;\n \n-  /* Make sure the locus is set to the end of the function, so that \n+  /* Make sure the locus is set to the end of the function, so that\n      epilogue line numbers and warnings are set properly.  */\n #ifdef USE_MAPPED_LOCATION\n   if (cfun->function_end_locus != UNKNOWN_LOCATION)\n@@ -341,8 +339,6 @@ construct_exit_block (void)\n   /* The following insns belong to the top scope.  */\n   record_block_change (DECL_INITIAL (current_function_decl));\n \n-  expand_end_bindings (NULL_TREE, 1, 0);\n-\n   /* Generate rtl for function exit.  */\n   expand_function_end ();\n "}, {"sha": "080de524c4f42950d08050f3dad2bed6676effe6", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caf93cb0d55b2a7d00eee250b5880a53205eef7c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caf93cb0d55b2a7d00eee250b5880a53205eef7c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=caf93cb0d55b2a7d00eee250b5880a53205eef7c", "patch": "@@ -1,3 +1,8 @@\n+2004-07-21  Eric Christopher  <echristo@redhat.com>\n+\n+\t* decl.c (poplevel): Inline unused variable checking.\n+\tChange formatting.\n+\n 2004-07-21  Paolo Bonzini  <bonzini@gnu.org>\n \n \t* typeck.c (build_binary_op): Do not use RDIV_EXPR for\n@@ -114,7 +119,7 @@\n 2004-07-19  Mark Mitchell  <mark@codesourcery.com>\n \n \tRevert patch for PR c++/16623.\n-\t\n+\n 2004-07-19  Kelley Cook  <kcook@gcc.gnu.org>\n \n \t* except.c: Remove two spurious carriage returns.\n@@ -315,8 +320,8 @@\n \t(copy_binfo): Declare.\n \n 2004-07-15  Mark Mitchell  <mark@codesourcery.com>\n-\t\n-\t* name-lookup.c (set_inherited_value_binding_p): Add class_type \n+\n+\t* name-lookup.c (set_inherited_value_binding_p): Add class_type\n \tparameter.\n \t(get_class_binding): Adjust.\n \t(push_class_level_binding): Don't use set_inherited_value_binding_p.\n@@ -378,7 +383,7 @@\n \t(dfs_push_type_decls): Remove.\n \t(dfs_push_decls): Remove.\n \t(push_class_decls): Remove.\n-\t\n+\n 2004-07-13  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/16518"}, {"sha": "e39ceb10c1bfd9324284a2c1ec9f24ea35c86fde", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 209, "deletions": 204, "changes": 413, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caf93cb0d55b2a7d00eee250b5880a53205eef7c/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caf93cb0d55b2a7d00eee250b5880a53205eef7c/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=caf93cb0d55b2a7d00eee250b5880a53205eef7c", "patch": "@@ -64,7 +64,7 @@ static tree grok_reference_init (tree, tree, tree, tree *);\n static tree grokfndecl (tree, tree, tree, tree, tree, int,\n \t\t\tenum overload_flags, cp_cv_quals,\n \t\t\ttree, int, int, int, int, int, int, tree);\n-static tree grokvardecl (tree, tree, const cp_decl_specifier_seq *, \n+static tree grokvardecl (tree, tree, const cp_decl_specifier_seq *,\n \t\t\t int, int, tree);\n static void record_unknown_type (tree, const char *);\n static tree builtin_function_1 (const char *, tree, tree, int,\n@@ -110,7 +110,7 @@ static tree start_cleanup_fn (void);\n static void end_cleanup_fn (void);\n static tree cp_make_fname_decl (tree, int);\n static void initialize_predefined_identifiers (void);\n-static tree check_special_function_return_type \n+static tree check_special_function_return_type\n \t(special_function_kind, tree, tree);\n static tree push_cp_library_fn (enum tree_code, tree);\n static tree build_cp_library_fn (tree, enum tree_code, tree);\n@@ -234,7 +234,7 @@ int function_depth;\n    with __attribute__((deprecated)).  An object declared as\n    __attribute__((deprecated)) suppresses warnings of uses of other\n    deprecated items.  */\n-   \n+\n enum deprecated_states {\n   DEPRECATED_NORMAL,\n   DEPRECATED_SUPPRESS\n@@ -266,8 +266,8 @@ current_tmpl_spec_kind (int n_class_scopes)\n   struct cp_binding_level *b;\n \n   /* Scan through the template parameter scopes.  */\n-  for (b = current_binding_level; \n-       b->kind == sk_template_parms; \n+  for (b = current_binding_level;\n+       b->kind == sk_template_parms;\n        b = b->level_chain)\n     {\n       /* If we see a specialization scope inside a parameter scope,\n@@ -444,7 +444,7 @@ poplevel (int keep, int reverse, int functionbody)\n \t\t       ? ((functionbody = 0), tmp) : functionbody);\n   subblocks = functionbody >= 0 ? current_binding_level->blocks : 0;\n \n-  my_friendly_assert (VEC_length(cp_class_binding, \n+  my_friendly_assert (VEC_length(cp_class_binding,\n \t\t\t\t current_binding_level->class_shadowed) == 0,\n \t\t      19990414);\n \n@@ -502,14 +502,6 @@ poplevel (int keep, int reverse, int functionbody)\n   else\n     decls = current_binding_level->names;\n \n-  /* When not in function-at-a-time mode, expand_end_bindings will\n-     warn about unused variables.  But, in function-at-a-time mode\n-     expand_end_bindings is not passed the list of variables in the\n-     current scope, and therefore no warning is emitted.  So, we\n-     explicitly warn here.  */\n-  if (!processing_template_decl)\n-    warn_about_unused_variables (getdecls ());\n-\n   /* If there were any declarations or structure tags in that level,\n      or if this level is a function body,\n      create a BLOCK to record them for the life of this function.  */\n@@ -534,6 +526,16 @@ poplevel (int keep, int reverse, int functionbody)\n   leaving_for_scope\n     = current_binding_level->kind == sk_for && flag_new_for_scope == 1;\n \n+  /* Before we remove the declarations first check for unused variables.  */\n+  if (warn_unused_variable\n+      && !processing_template_decl)\n+    for (decl = getdecls (); decl; decl = TREE_CHAIN (decl))\n+      if (TREE_CODE (decl) == VAR_DECL\n+\t  && ! TREE_USED (decl)\n+\t  && ! DECL_IN_SYSTEM_HEADER (decl)\n+\t  && DECL_NAME (decl) && ! DECL_ARTIFICIAL (decl))\n+\twarning (\"%Junused variable '%D'\", decl, decl);\n+\n   /* Remove declarations for all the DECLs in this level.  */\n   for (link = decls; link; link = TREE_CHAIN (link))\n     {\n@@ -595,16 +597,18 @@ poplevel (int keep, int reverse, int functionbody)\n \n \t      /* Although we don't pop the cxx_binding, we do clear\n \t\t its SCOPE since the scope is going away now.  */\n-\t      IDENTIFIER_BINDING (name)->scope \n+\t      IDENTIFIER_BINDING (name)->scope\n \t\t= current_binding_level->level_chain;\n \t    }\n \t}\n       else\n \t{\n \t  /* Remove the binding.  */\n \t  decl = link;\n+\n \t  if (TREE_CODE (decl) == TREE_LIST)\n \t    decl = TREE_VALUE (decl);\n+\n \t  if (DECL_P (decl))\n \t    pop_binding (DECL_NAME (decl), decl);\n \t  else if (TREE_CODE (decl) == OVERLOAD)\n@@ -787,9 +791,9 @@ walk_vtables_r (tree namespace, void* data)\n    returns a nonzero value, return a nonzero value.  */\n bool\n walk_vtables (walk_globals_pred p, walk_globals_fn f, void *data)\n-{    \n+{\n   struct walk_globals_data wgd;\n-  wgd.p = p;    \n+  wgd.p = p;\n   wgd.f = f;\n   wgd.data = data;\n \n@@ -803,7 +807,7 @@ static int\n walk_namespaces_r (tree namespace, walk_namespaces_fn f, void* data)\n {\n   int result = 0;\n-  tree current = NAMESPACE_LEVEL (namespace)->namespaces;     \n+  tree current = NAMESPACE_LEVEL (namespace)->namespaces;\n \n   result |= (*f) (namespace, data);\n \n@@ -1410,7 +1414,7 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t In a declarative region, a namespace-alias-definition can be\n \t used to redefine a namespace-alias declared in that declarative\n \t region to refer only to the namespace to which it already\n-\t refers.  \n+\t refers.\n \n       Therefore, if we encounter a second alias directive for the same\n       alias, we can just ignore the second directive.  */\n@@ -1486,7 +1490,7 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t\t  }\n \t      }\n \n-\t  if (DECL_DECLARED_INLINE_P (newdecl) \n+\t  if (DECL_DECLARED_INLINE_P (newdecl)\n \t      && ! DECL_DECLARED_INLINE_P (olddecl)\n \t      && TREE_ADDRESSABLE (olddecl) && warn_inline)\n \t    {\n@@ -1580,7 +1584,7 @@ duplicate_decls (tree newdecl, tree olddecl)\n       if (DECL_INITIAL (DECL_TEMPLATE_RESULT (olddecl)) == NULL_TREE\n \t  && DECL_INITIAL (DECL_TEMPLATE_RESULT (newdecl)) != NULL_TREE)\n \t{\n-\t  DECL_SOURCE_LOCATION (olddecl) \n+\t  DECL_SOURCE_LOCATION (olddecl)\n \t    = DECL_SOURCE_LOCATION (DECL_TEMPLATE_RESULT (olddecl))\n \t    = DECL_SOURCE_LOCATION (newdecl);\n \t  if (DECL_FUNCTION_TEMPLATE_P (newdecl))\n@@ -1590,7 +1594,7 @@ duplicate_decls (tree newdecl, tree olddecl)\n \n       if (DECL_FUNCTION_TEMPLATE_P (newdecl))\n \t{\n-\t  DECL_INLINE (DECL_TEMPLATE_RESULT (olddecl)) \n+\t  DECL_INLINE (DECL_TEMPLATE_RESULT (olddecl))\n \t    |= DECL_INLINE (DECL_TEMPLATE_RESULT (newdecl));\n \t  DECL_DECLARED_INLINE_P (DECL_TEMPLATE_RESULT (olddecl))\n \t    |= DECL_DECLARED_INLINE_P (DECL_TEMPLATE_RESULT (newdecl));\n@@ -1700,7 +1704,7 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t  /* Keep the old RTL.  */\n \t  COPY_DECL_RTL (olddecl, newdecl);\n \t}\n-      else if (TREE_CODE (newdecl) == VAR_DECL \n+      else if (TREE_CODE (newdecl) == VAR_DECL\n \t       && (DECL_SIZE (olddecl) || !DECL_SIZE (newdecl)))\n \t{\n \t  /* Keep the old RTL.  We cannot keep the old RTL if the old\n@@ -1745,7 +1749,7 @@ duplicate_decls (tree newdecl, tree olddecl)\n       /* Don't really know how much of the language-specific\n \t values we should copy from old to new.  */\n       DECL_IN_AGGR_P (newdecl) = DECL_IN_AGGR_P (olddecl);\n-      DECL_LANG_SPECIFIC (newdecl)->decl_flags.u2 = \n+      DECL_LANG_SPECIFIC (newdecl)->decl_flags.u2 =\n \tDECL_LANG_SPECIFIC (olddecl)->decl_flags.u2;\n       DECL_NONCONVERTING_P (newdecl) = DECL_NONCONVERTING_P (olddecl);\n       DECL_TEMPLATE_INFO (newdecl) = DECL_TEMPLATE_INFO (olddecl);\n@@ -1802,7 +1806,7 @@ duplicate_decls (tree newdecl, tree olddecl)\n \n \t  DECL_DECLARED_INLINE_P (newdecl) |= DECL_DECLARED_INLINE_P (olddecl);\n \n-\t  /* If either decl says `inline', this fn is inline, unless \n+\t  /* If either decl says `inline', this fn is inline, unless\n \t     its definition was passed already.  */\n \t  if (DECL_INLINE (newdecl) && DECL_INITIAL (olddecl) == NULL_TREE)\n \t    DECL_INLINE (olddecl) = 1;\n@@ -1906,8 +1910,8 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t   olddecl, and not newdecl, is on the list of\n \t   instantiations so that if we try to do the instantiation\n \t   again we won't get the clobbered declaration.  */\n-\treregister_specialization (newdecl, \n-\t\t\t\t   DECL_TI_TEMPLATE (newdecl), \n+\treregister_specialization (newdecl,\n+\t\t\t\t   DECL_TI_TEMPLATE (newdecl),\n \t\t\t\t   olddecl);\n     }\n   else\n@@ -1929,7 +1933,7 @@ duplicate_decls (tree newdecl, tree olddecl)\n   /* If OLDDECL had its DECL_RTL instantiated, re-invoke make_decl_rtl\n     so that encode_section_info has a chance to look at the new decl\n     flags and attributes.  */\n-  if (DECL_RTL_SET_P (olddecl) \n+  if (DECL_RTL_SET_P (olddecl)\n       && (TREE_CODE (olddecl) == FUNCTION_DECL\n \t  || (TREE_CODE (olddecl) == VAR_DECL\n \t      && TREE_STATIC (olddecl))))\n@@ -1998,7 +2002,7 @@ redeclaration_error_message (tree newdecl, tree olddecl)\n \t}\n \n       if (TREE_CODE (DECL_TEMPLATE_RESULT (newdecl)) != FUNCTION_DECL\n-\t  || (DECL_TEMPLATE_RESULT (newdecl) \n+\t  || (DECL_TEMPLATE_RESULT (newdecl)\n \t      == DECL_TEMPLATE_RESULT (olddecl)))\n \treturn NULL;\n \n@@ -2343,8 +2347,8 @@ define_label (location_t location, tree name)\n \n   /* After labels, make any new cleanups in the function go into their\n      own new (temporary) binding contour.  */\n-  for (p = current_binding_level; \n-       p->kind != sk_function_parms; \n+  for (p = current_binding_level;\n+       p->kind != sk_function_parms;\n        p = p->level_chain)\n     p->more_cleanups_ok = 0;\n \n@@ -2451,8 +2455,8 @@ finish_case_label (tree low_value, tree high_value)\n \n   /* After labels, make any new cleanups in the function go into their\n      own new (temporary) binding contour.  */\n-  for (p = current_binding_level; \n-       p->kind != sk_function_parms; \n+  for (p = current_binding_level;\n+       p->kind != sk_function_parms;\n        p = p->level_chain)\n     p->more_cleanups_ok = 0;\n \n@@ -2515,7 +2519,7 @@ build_typename_type (tree context, tree name, tree fullname)\n \n   if (typename_htab == NULL)\n     {\n-      typename_htab = htab_create_ggc (61, &typename_hash, \n+      typename_htab = htab_create_ggc (61, &typename_hash,\n \t\t\t\t       &typename_compare, NULL);\n     }\n \n@@ -2587,7 +2591,7 @@ make_typename_type (tree context, tree name, tsubst_flags_t complain)\n       return error_mark_node;\n     }\n   my_friendly_assert (TREE_CODE (name) == IDENTIFIER_NODE, 20030802);\n-  \n+\n   if (TREE_CODE (context) == NAMESPACE_DECL)\n     {\n       /* We can get here from typename_sub0 in the explicit_template_type\n@@ -2649,7 +2653,7 @@ make_typename_type (tree context, tree name, tsubst_flags_t complain)\n \n \t      if (DECL_ARTIFICIAL (t) || !(complain & tf_keep_type_decl))\n \t\tt = TREE_TYPE (t);\n-\t      \n+\n \t      return t;\n \t    }\n \t}\n@@ -2700,7 +2704,7 @@ make_unbound_class_template (tree context, tree name, tsubst_flags_t complain)\n \t    error (\"no class template named `%#T' in `%#T'\", name, context);\n \t  return error_mark_node;\n \t}\n-      \n+\n       if (complain & tf_error)\n \tperform_or_defer_access_check (TYPE_BINFO (context), tmpl);\n \n@@ -2730,8 +2734,8 @@ make_unbound_class_template (tree context, tree name, tsubst_flags_t complain)\n    type.  TYPE is the _TYPE node for the builtin type.  */\n \n void\n-record_builtin_type (enum rid rid_index, \n-                     const char* name, \n+record_builtin_type (enum rid rid_index,\n+                     const char* name,\n                      tree type)\n {\n   tree rname = NULL_TREE, tname = NULL_TREE;\n@@ -2965,7 +2969,7 @@ cxx_init_decl_processing (void)\n   void_ftype = build_function_type (void_type_node, void_list_node);\n   void_ftype_ptr = build_function_type (void_type_node,\n \t\t\t\t\ttree_cons (NULL_TREE,\n-\t\t\t\t\t\t   ptr_type_node, \n+\t\t\t\t\t\t   ptr_type_node,\n \t\t\t\t\t\t   void_list_node));\n   void_ftype_ptr\n     = build_exception_variant (void_ftype_ptr, empty_except_spec);\n@@ -3025,13 +3029,13 @@ cxx_init_decl_processing (void)\n     bad_alloc_id = get_identifier (\"bad_alloc\");\n     bad_alloc_type_node = make_aggr_type (RECORD_TYPE);\n     TYPE_CONTEXT (bad_alloc_type_node) = current_namespace;\n-    bad_alloc_decl \n+    bad_alloc_decl\n       = create_implicit_typedef (bad_alloc_id, bad_alloc_type_node);\n     DECL_CONTEXT (bad_alloc_decl) = current_namespace;\n     TYPE_STUB_DECL (bad_alloc_type_node) = bad_alloc_decl;\n     pop_namespace ();\n- \n-    ptr_ftype_sizetype \n+\n+    ptr_ftype_sizetype\n       = build_function_type (ptr_type_node,\n \t\t\t     tree_cons (NULL_TREE,\n \t\t\t\t\tsize_type_node,\n@@ -3085,17 +3089,17 @@ cp_fname_init (const char* name, tree *type_p)\n       domain = build_index_type (size_int (length));\n       init = build_string (length + 1, name);\n     }\n-  \n+\n   type = build_qualified_type (char_type_node, TYPE_QUAL_CONST);\n   type = build_cplus_array_type (type, domain);\n \n   *type_p = type;\n-  \n+\n   if (init)\n     TREE_TYPE (init) = type;\n   else\n     init = error_mark_node;\n-  \n+\n   return init;\n }\n \n@@ -3120,12 +3124,12 @@ cp_make_fname_decl (tree id, int type_dep)\n   /* As we're using pushdecl_with_scope, we must set the context.  */\n   DECL_CONTEXT (decl) = current_function_decl;\n   DECL_PRETTY_FUNCTION_P (decl) = type_dep;\n-      \n+\n   TREE_STATIC (decl) = 1;\n   TREE_READONLY (decl) = 1;\n   DECL_ARTIFICIAL (decl) = 1;\n   DECL_INITIAL (decl) = init;\n-  \n+\n   TREE_USED (decl) = 1;\n \n   if (current_function_decl)\n@@ -3138,7 +3142,7 @@ cp_make_fname_decl (tree id, int type_dep)\n     }\n   else\n     pushdecl_top_level_and_finish (decl, init);\n-      \n+\n   return decl;\n }\n \n@@ -3424,7 +3428,7 @@ check_tag_decl (cp_decl_specifier_seq *declspecs)\n     }\n \n   if (TYPE_P (declspecs->type)\n-      && ((TREE_CODE (declspecs->type) != TYPENAME_TYPE \n+      && ((TREE_CODE (declspecs->type) != TYPENAME_TYPE\n \t   && IS_AGGR_TYPE (declspecs->type))\n \t  || TREE_CODE (declspecs->type) == ENUMERAL_TYPE))\n     declared_type = declspecs->type;\n@@ -3460,7 +3464,7 @@ check_tag_decl (cp_decl_specifier_seq *declspecs)\n       /* Anonymous unions are objects, so they can have specifiers.  */;\n       SET_ANON_AGGR_TYPE_P (declared_type);\n \n-      if (TREE_CODE (declared_type) != UNION_TYPE && pedantic \n+      if (TREE_CODE (declared_type) != UNION_TYPE && pedantic\n \t  && !in_system_header)\n \tpedwarn (\"ISO C++ prohibits anonymous structs\");\n     }\n@@ -3469,11 +3473,11 @@ check_tag_decl (cp_decl_specifier_seq *declspecs)\n     {\n       if (declspecs->specs[(int)ds_inline]\n \t  || declspecs->specs[(int)ds_virtual])\n-\terror (\"`%s' can only be specified for functions\", \n-\t       declspecs->specs[(int)ds_inline] \n+\terror (\"`%s' can only be specified for functions\",\n+\t       declspecs->specs[(int)ds_inline]\n \t       ? \"inline\" : \"virtual\");\n       else if (saw_friend\n-\t       && (!current_class_type \n+\t       && (!current_class_type\n \t\t   || current_scope () != current_class_type))\n \terror (\"`friend' can only be specified inside a class\");\n       else if (declspecs->specs[(int)ds_explicit])\n@@ -3501,7 +3505,7 @@ check_tag_decl (cp_decl_specifier_seq *declspecs)\n    Otherwise, it is an error.\n \n    C++: may have to grok the declspecs to learn about static,\n-   complain for anonymous unions.  \n+   complain for anonymous unions.\n \n    Returns the TYPE declared -- or NULL_TREE if none.  */\n \n@@ -3526,7 +3530,7 @@ shadow_tag (cp_decl_specifier_seq *declspecs)\n \n       if (TYPE_FIELDS (t))\n \t{\n-\t  tree decl = grokdeclarator (/*declarator=*/NULL, \n+\t  tree decl = grokdeclarator (/*declarator=*/NULL,\n \t\t\t\t      declspecs, NORMAL, 0, NULL);\n \t  finish_anon_union (decl);\n \t}\n@@ -3538,7 +3542,7 @@ shadow_tag (cp_decl_specifier_seq *declspecs)\n /* Decode a \"typename\", such as \"int **\", returning a ..._TYPE node.  */\n \n tree\n-groktypename (cp_decl_specifier_seq *type_specifiers, \n+groktypename (cp_decl_specifier_seq *type_specifiers,\n \t      const cp_declarator *declarator)\n {\n   tree attrs;\n@@ -3567,10 +3571,10 @@ groktypename (cp_decl_specifier_seq *type_specifiers,\n    grokfield and not through here.  */\n \n tree\n-start_decl (const cp_declarator *declarator, \n+start_decl (const cp_declarator *declarator,\n \t    cp_decl_specifier_seq *declspecs,\n-            int initialized, \n-            tree attributes, \n+            int initialized,\n+            tree attributes,\n             tree prefix_attributes)\n {\n   tree decl;\n@@ -3955,10 +3959,10 @@ layout_var_decl (tree decl)\n      `extern X x' for some incomplete type `X'.)  */\n   if (!DECL_EXTERNAL (decl))\n     complete_type (type);\n-  if (!DECL_SIZE (decl) \n+  if (!DECL_SIZE (decl)\n       && TREE_TYPE (decl) != error_mark_node\n       && (COMPLETE_TYPE_P (type)\n-\t  || (TREE_CODE (type) == ARRAY_TYPE \n+\t  || (TREE_CODE (type) == ARRAY_TYPE\n \t      && !TYPE_DOMAIN (type)\n \t      && COMPLETE_TYPE_P (TREE_TYPE (type)))))\n     layout_decl (decl, 0);\n@@ -4015,7 +4019,7 @@ maybe_commonize_var (tree decl)\n       && DECL_FUNCTION_SCOPE_P (decl)\n       /* Unfortunately, import_export_decl has not always been called\n \t before the function is processed, so we cannot simply check\n-\t DECL_COMDAT.  */ \n+\t DECL_COMDAT.  */\n       && (DECL_COMDAT (DECL_CONTEXT (decl))\n \t  || ((DECL_DECLARED_INLINE_P (DECL_CONTEXT (decl))\n \t       || DECL_TEMPLATE_INSTANTIATION (DECL_CONTEXT (decl)))\n@@ -4098,7 +4102,7 @@ next_initializable_field (tree field)\n    *INITP is one of a list of initializers describing a brace-enclosed\n    initializer for an entity of the indicated aggregate TYPE.  It may\n    not presently match the shape of the TYPE; for example:\n-   \n+\n      struct S { int a; int b; };\n      struct S a[] = { 1, 2, 3, 4 };\n \n@@ -4157,7 +4161,7 @@ reshape_init (tree type, tree *initp)\n \t    else\n \t      old_init = error_mark_node;\n \t  }\n-\t\n+\n \treturn old_init;\n       }\n \n@@ -4195,7 +4199,7 @@ reshape_init (tree type, tree *initp)\n     }\n   else\n     {\n-      /* Build a CONSTRUCTOR to hold the contents of the aggregate.  */  \n+      /* Build a CONSTRUCTOR to hold the contents of the aggregate.  */\n       new_init = build_constructor (NULL_TREE, NULL_TREE);\n \n       if (CLASS_TYPE_P (type))\n@@ -4207,7 +4211,7 @@ reshape_init (tree type, tree *initp)\n \t  if (!field)\n \t    {\n \t      /* [dcl.init.aggr]\n-\t      \n+\n \t\t An initializer for an aggregate member that is an\n \t\t empty class shall have the form of an empty\n \t\t initializer-list {}.  */\n@@ -4245,7 +4249,7 @@ reshape_init (tree type, tree *initp)\n \t\t    return error_mark_node;\n \t\t  TREE_CHAIN (field_init) = CONSTRUCTOR_ELTS (new_init);\n \t\t  CONSTRUCTOR_ELTS (new_init) = field_init;\n-\t\t  /* [dcl.init.aggr] \n+\t\t  /* [dcl.init.aggr]\n \n \t\t     When a union  is  initialized with a brace-enclosed\n \t\t     initializer, the braces shall only contain an\n@@ -4355,7 +4359,7 @@ check_initializer (tree decl, tree init, int flags, tree *cleanup)\n   if (type == error_mark_node)\n     /* We will have already complained.  */\n     init = NULL_TREE;\n-  else if (init && COMPLETE_TYPE_P (type) \n+  else if (init && COMPLETE_TYPE_P (type)\n \t   && !TREE_CONSTANT (TYPE_SIZE (type)))\n     {\n       error (\"variable-sized object `%D' may not be initialized\", decl);\n@@ -4387,15 +4391,15 @@ check_initializer (tree decl, tree init, int flags, tree *cleanup)\n     init = grok_reference_init (decl, type, init, cleanup);\n   else if (init)\n     {\n-      if (TREE_CODE (init) == CONSTRUCTOR \n+      if (TREE_CODE (init) == CONSTRUCTOR\n \t  && BRACE_ENCLOSED_INITIALIZER_P (init))\n \t{\n \t  /* [dcl.init] paragraph 13,\n \t     If T is a scalar type, then a declaration of the form\n \t     T x = { a };\n \t     is equivalent to\n \t     T x = a;\n-\t     \n+\n \t     reshape_init will complain about the extra braces,\n \t     and doesn't do anything useful in the case where TYPE is\n \t     scalar, so just don't call it.  */\n@@ -4573,7 +4577,7 @@ initialize_local_var (tree decl, tree init)\n   tree cleanup;\n \n   my_friendly_assert (TREE_CODE (decl) == VAR_DECL\n-\t\t      || TREE_CODE (decl) == RESULT_DECL, \n+\t\t      || TREE_CODE (decl) == RESULT_DECL,\n \t\t      20021010);\n   my_friendly_assert (!TREE_STATIC (decl), 20021010);\n \n@@ -4662,7 +4666,7 @@ cp_finish_decl (tree decl, tree init, tree asmspec_tree, int flags)\n   /* If a name was specified, get the string.  */\n   if (global_scope_p (current_binding_level))\n     asmspec_tree = maybe_apply_renaming_pragma (decl, asmspec_tree);\n-  if (asmspec_tree) \n+  if (asmspec_tree)\n     asmspec = TREE_STRING_POINTER (asmspec_tree);\n \n   if (init && TREE_CODE (init) == NAMESPACE_DECL)\n@@ -4740,15 +4744,15 @@ cp_finish_decl (tree decl, tree init, tree asmspec_tree, int flags)\n   if (TREE_CODE (decl) != FUNCTION_DECL)\n     ttype = target_type (type);\n \n-  \n+\n   /* Currently, GNU C++ puts constants in text space, making them\n      impossible to initialize.  In the future, one would hope for\n      an operating system which understood the difference between\n      initialization and the running of a program.  */\n   if (! DECL_EXTERNAL (decl) && TREE_READONLY (decl))\n     {\n       was_readonly = 1;\n-      if (TYPE_NEEDS_CONSTRUCTING (type) \n+      if (TYPE_NEEDS_CONSTRUCTING (type)\n \t  || TREE_CODE (type) == REFERENCE_TYPE)\n \tTREE_READONLY (decl) = 0;\n     }\n@@ -4778,13 +4782,13 @@ cp_finish_decl (tree decl, tree init, tree asmspec_tree, int flags)\n \t      init = NULL_TREE;\n \t    }\n \t  /* Handle:\n-\t     \n+\n \t     [dcl.init]\n-\t     \n+\n \t     The memory occupied by any object of static storage\n \t     duration is zero-initialized at program startup before\n \t     any other initialization takes place.\n-\t     \n+\n \t     We cannot create an appropriate initializer until after\n \t     the type of DECL is finalized.  If DECL_INITIAL is set,\n \t     then the DECL is statically initialized, and any\n@@ -4833,7 +4837,7 @@ cp_finish_decl (tree decl, tree init, tree asmspec_tree, int flags)\n       else\n \tabstract_virtuals_error (decl, type);\n \n-      if (TREE_CODE (decl) == FUNCTION_DECL \n+      if (TREE_CODE (decl) == FUNCTION_DECL\n \t  || TREE_TYPE (decl) == error_mark_node)\n \t/* No initialization required.  */\n \t;\n@@ -5117,7 +5121,7 @@ register_dtor_fn (tree decl)\n      to the original function, rather than the anonymous one.  That\n      will make the back-end think that nested functions are in use,\n      which causes confusion.  */\n-  \n+\n   push_deferring_access_checks (dk_no_check);\n   fcall = build_cleanup (decl);\n   pop_deferring_access_checks ();\n@@ -5134,7 +5138,7 @@ register_dtor_fn (tree decl)\n   cleanup = build_unary_op (ADDR_EXPR, cleanup, 0);\n   if (flag_use_cxa_atexit)\n     {\n-      args = tree_cons (NULL_TREE, \n+      args = tree_cons (NULL_TREE,\n \t\t\tbuild_unary_op (ADDR_EXPR, get_dso_handle_node (), 0),\n \t\t\tNULL_TREE);\n       args = tree_cons (NULL_TREE, null_pointer_node, args);\n@@ -5156,7 +5160,7 @@ expand_static_init (tree decl, tree init)\n   my_friendly_assert (TREE_STATIC (decl), 20021010);\n \n   /* Some variables require no initialization.  */\n-  if (!init \n+  if (!init\n       && !TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (decl))\n       && TYPE_HAS_TRIVIAL_DESTRUCTOR (TREE_TYPE (decl)))\n     return;\n@@ -5326,7 +5330,7 @@ complete_array_type (tree type, tree initial_value, int do_default)\n       TYPE_NEEDS_CONSTRUCTING (type)\n \t= TYPE_NEEDS_CONSTRUCTING (TYPE_MAIN_VARIANT (elt_type));\n       TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type)\n-\t= TYPE_HAS_NONTRIVIAL_DESTRUCTOR (TYPE_MAIN_VARIANT (elt_type));      \n+\t= TYPE_HAS_NONTRIVIAL_DESTRUCTOR (TYPE_MAIN_VARIANT (elt_type));\n     }\n \n   /* Lay out the type now that we can get the real answer.  */\n@@ -5404,7 +5408,7 @@ bad_specifiers (tree object,\n    applicable error messages.  */\n \n static tree\n-grokfndecl (tree ctype, \n+grokfndecl (tree ctype,\n             tree type,\n             tree declarator,\n \t    tree parms,\n@@ -5413,11 +5417,11 @@ grokfndecl (tree ctype,\n             enum overload_flags flags,\n \t    cp_cv_quals quals,\n             tree raises,\n-            int check, \n-            int friendp, \n-            int publicp, \n-            int inlinep, \n-            int funcdef_flag, \n+            int check,\n+            int friendp,\n+            int publicp,\n+            int inlinep,\n+            int funcdef_flag,\n             int template_count,\n             tree in_namespace)\n {\n@@ -5701,7 +5705,7 @@ grokfndecl (tree ctype,\n   return decl;\n }\n \n-/* Create a VAR_DECL named NAME with the indicated TYPE.  \n+/* Create a VAR_DECL named NAME with the indicated TYPE.\n \n    If SCOPE is non-NULL, it is the class type or namespace containing\n    the variable.  If SCOPE is NULL, the variable should is created in\n@@ -5717,7 +5721,7 @@ grokvardecl (tree type,\n {\n   tree decl;\n \n-  my_friendly_assert (!name || TREE_CODE (name) == IDENTIFIER_NODE, \n+  my_friendly_assert (!name || TREE_CODE (name) == IDENTIFIER_NODE,\n \t\t      20020808);\n \n   /* Compute the scope in which to place the variable.  */\n@@ -5741,7 +5745,7 @@ grokvardecl (tree type,\n \t  (TREE_CODE (scope) == NAMESPACE_DECL && processing_template_decl)\n \t  /* Similarly for namespace-scope variables with language linkage\n \t     other than C++.  */\n-\t  || (TREE_CODE (scope) == NAMESPACE_DECL \n+\t  || (TREE_CODE (scope) == NAMESPACE_DECL\n \t      && current_lang_name != lang_name_cplusplus)\n \t  /* Similarly for static data members.  */\n \t  || TYPE_P (scope)))\n@@ -5854,19 +5858,19 @@ build_ptrmemfunc_type (tree type)\n \n   t = make_aggr_type (RECORD_TYPE);\n   xref_basetypes (t, NULL_TREE);\n-  \n+\n   /* Let the front-end know this is a pointer to member function...  */\n   TYPE_PTRMEMFUNC_FLAG (t) = 1;\n   /* ... and not really an aggregate.  */\n   SET_IS_AGGR_TYPE (t, 0);\n \n   field = build_decl (FIELD_DECL, pfn_identifier, type);\n   fields = field;\n-  \n+\n   field = build_decl (FIELD_DECL, delta_identifier, delta_type_node);\n   TREE_CHAIN (field) = fields;\n   fields = field;\n-  \n+\n   finish_builtin_struct (t, \"__ptrmemfunc_type\", fields, ptr_type_node);\n \n   /* Zap out the name so that the back-end will give us the debugging\n@@ -5902,11 +5906,11 @@ build_ptrmem_type (tree class_type, tree member_type)\n       tree arg_types;\n \n       arg_types = TYPE_ARG_TYPES (member_type);\n-      class_type = (cp_build_qualified_type \n+      class_type = (cp_build_qualified_type\n \t\t    (class_type,\n \t\t     cp_type_quals (TREE_TYPE (TREE_VALUE (arg_types)))));\n-      member_type \n-\t= build_method_type_directly (class_type, \n+      member_type\n+\t= build_method_type_directly (class_type,\n \t\t\t\t      TREE_TYPE (member_type),\n \t\t\t\t      TREE_CHAIN (arg_types));\n       return build_ptrmemfunc_type (build_pointer_type (member_type));\n@@ -6261,7 +6265,7 @@ grokdeclarator (const cp_declarator *declarator,\n   int explicit_char = 0;\n   int defaulted_int = 0;\n   tree dependant_name = NULL_TREE;\n-  \n+\n   tree typedef_decl = NULL_TREE;\n   const char *name = NULL;\n   tree typedef_type = NULL_TREE;\n@@ -6298,7 +6302,7 @@ grokdeclarator (const cp_declarator *declarator,\n   /* The NAMESPACE_DECL for the namespace in which this entity is\n      located.  If an unqualified name is used to declare the entity,\n      this value will be NULL_TREE, even if the entity is located at\n-     namespace scope.  */ \n+     namespace scope.  */\n   tree in_namespace = NULL_TREE;\n   cp_decl_spec ds;\n   cp_storage_class storage_class;\n@@ -6319,8 +6323,8 @@ grokdeclarator (const cp_declarator *declarator,\n \n   /* Look inside a declarator for the name being declared\n      and get it as a string, for an error message.  */\n-  for (id_declarator = declarator; \n-       id_declarator; \n+  for (id_declarator = declarator;\n+       id_declarator;\n        id_declarator = id_declarator->declarator)\n     {\n       if (id_declarator->kind != cdk_id)\n@@ -6359,17 +6363,17 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t Therefore, we do as well.  */\n \t\tif (qualifying_scope && TYPE_P (qualifying_scope))\n \t\t  {\n-\t\t    ctype = TYPE_MAIN_VARIANT (qualifying_scope); \n+\t\t    ctype = TYPE_MAIN_VARIANT (qualifying_scope);\n \t\t    if (innermost_code != cdk_function\n \t\t\t&& current_class_type\n-\t\t\t&& !UNIQUELY_DERIVED_FROM_P (ctype, \n+\t\t\t&& !UNIQUELY_DERIVED_FROM_P (ctype,\n \t\t\t\t\t\t     current_class_type))\n \t\t      {\n \t\t\terror (\"type `%T' is not derived from type `%T'\",\n \t\t\t       ctype, current_class_type);\n \t\t\tctype = NULL_TREE;\n \t\t      }\n-\t\t    TREE_OPERAND (decl, 0) = ctype; \n+\t\t    TREE_OPERAND (decl, 0) = ctype;\n \t\t  }\n \t\telse if (TREE_CODE (qualifying_scope) == NAMESPACE_DECL)\n \t\t  in_namespace = qualifying_scope;\n@@ -6528,12 +6532,12 @@ grokdeclarator (const cp_declarator *declarator,\n   explicit_char = declspecs->explicit_char_p;\n \n   /* Check for repeated decl-specifiers.  */\n-  for (ds = ds_first; ds != ds_last; ++ds) \n+  for (ds = ds_first; ds != ds_last; ++ds)\n     {\n       unsigned count = declspecs->specs[(int)ds];\n       if (count < 2)\n \tcontinue;\n-      /* The \"long\" specifier is a special case because of \n+      /* The \"long\" specifier is a special case because of\n \t \"long long\".  */\n       if (ds == ds_long)\n \t{\n@@ -6543,7 +6547,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t    pedwarn (\"ISO C++ does not support `long long'\");\n \t  else\n \t    longlong = 1;\n-\t} \n+\t}\n       else if (declspecs->specs[(int)ds] > 1)\n \t{\n \t  static const char *const decl_spec_names[] = {\n@@ -6603,7 +6607,7 @@ grokdeclarator (const cp_declarator *declarator,\n \n       type = integer_type_node;\n     }\n-  \n+\n   ctype = NULL_TREE;\n \n   /* Now process the modifiers that were specified\n@@ -6743,7 +6747,7 @@ grokdeclarator (const cp_declarator *declarator,\n  \t\t\t ? tf_ignore_bad_quals : 0) | tf_error | tf_warning));\n   /* We might have ignored or rejected some of the qualifiers.  */\n   type_quals = cp_type_quals (type);\n-  \n+\n   staticp = 0;\n   inlinep = !! declspecs->specs[(int)ds_inline];\n   virtualp = !! declspecs->specs[(int)ds_virtual];\n@@ -6797,15 +6801,15 @@ grokdeclarator (const cp_declarator *declarator,\n   if (declspecs->multiple_storage_classes_p)\n     error (\"multiple storage classes in declaration of `%s'\", name);\n   else if (thread_p\n-\t   && ((storage_class \n+\t   && ((storage_class\n \t\t&& storage_class != sc_extern\n \t\t&& storage_class != sc_static)\n \t       || declspecs->specs[(int)ds_typedef]))\n     {\n       error (\"multiple storage classes in declaration of `%s'\", name);\n       thread_p = false;\n     }\n-  else if (decl_context != NORMAL \n+  else if (decl_context != NORMAL\n \t   && ((storage_class != sc_none\n \t\t&& storage_class != sc_mutable)\n \t       || thread_p))\n@@ -6863,7 +6867,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t    storage_class = sc_none;\n \t}\n     }\n-  else if (storage_class == sc_extern && initialized \n+  else if (storage_class == sc_extern && initialized\n \t   && !funcdef_flag)\n     {\n       if (toplevel_bindings_p ())\n@@ -6908,27 +6912,27 @@ grokdeclarator (const cp_declarator *declarator,\n       switch (TREE_CODE (unqualified_id))\n \t{\n \tcase BIT_NOT_EXPR:\n-\t  unqualified_id \n+\t  unqualified_id\n \t    = constructor_name (TREE_OPERAND (unqualified_id, 0));\n \t  break;\n-\t  \n+\n \tcase TYPE_DECL:\n-\t  unqualified_id \n+\t  unqualified_id\n \t    = constructor_name (TREE_TYPE (unqualified_id));\n \t  break;\n \n \tcase IDENTIFIER_NODE:\n \tcase TEMPLATE_ID_EXPR:\n \t  break;\n-\t\n+\n \tdefault:\n \t  abort ();\n \t}\n     }\n \n   /* Determine the type of the entity declared by recurring on the\n      declarator.  */\n-  for (; \n+  for (;\n        declarator && declarator->kind != cdk_id;\n        declarator = declarator->declarator)\n     {\n@@ -6944,7 +6948,7 @@ grokdeclarator (const cp_declarator *declarator,\n       if (attrs)\n \t{\n \t  int attr_flags;\n-\t  \n+\n \t  attr_flags = 0;\n \t  if (declarator == NULL || declarator->kind == cdk_id)\n \t    attr_flags |= (int) ATTR_FLAG_DECL_NEXT;\n@@ -6960,7 +6964,7 @@ grokdeclarator (const cp_declarator *declarator,\n       switch (declarator->kind)\n \t{\n \tcase cdk_array:\n-\t  type = create_array_type_for_decl (dname, type, \n+\t  type = create_array_type_for_decl (dname, type,\n \t\t\t\t\t     declarator->u.array.bounds);\n \t  if (inner_declarator\n \t      && (inner_declarator->kind == cdk_pointer\n@@ -7093,7 +7097,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t\t    name);\n \t      }\n \n-\t    arg_types = grokparms (declarator->u.function.parameters, \n+\t    arg_types = grokparms (declarator->u.function.parameters,\n \t\t\t\t   &parms);\n \n \t    if (inner_declarator\n@@ -7105,7 +7109,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t\targ_types = void_list_node;\n \t\tparms = NULL_TREE;\n \t      }\n-\t    \n+\n \t    type = build_function_type (type, arg_types);\n \t  }\n \t  break;\n@@ -7140,7 +7144,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t  || (quals && TREE_CODE (type) == METHOD_TYPE)))\n \t    {\n \t      tree dummy = build_decl (TYPE_DECL, NULL_TREE, type);\n-\t      grok_method_quals (declarator->u.pointer.class_type, \n+\t      grok_method_quals (declarator->u.pointer.class_type,\n \t\t\t\t dummy, quals);\n \t      type = TREE_TYPE (dummy);\n \t      quals = TYPE_UNQUALIFIED;\n@@ -7154,7 +7158,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t  else if (TREE_CODE (type) == METHOD_TYPE)\n \t    type = build_ptrmemfunc_type (build_pointer_type (type));\n \t  else if (declarator->kind == cdk_ptrmem)\n-\t    type = build_ptrmem_type (declarator->u.pointer.class_type, \n+\t    type = build_ptrmem_type (declarator->u.pointer.class_type,\n \t\t\t\t      type);\n \t  else\n \t    type = build_pointer_type (type);\n@@ -7164,8 +7168,8 @@ grokdeclarator (const cp_declarator *declarator,\n \n \t  if (declarator->u.pointer.qualifiers)\n \t    {\n-\t      type \n-\t\t= cp_build_qualified_type (type, \n+\t      type\n+\t\t= cp_build_qualified_type (type,\n \t\t\t\t\t   declarator->u.pointer.qualifiers);\n \t      type_quals = cp_type_quals (type);\n \t    }\n@@ -7179,19 +7183,19 @@ grokdeclarator (const cp_declarator *declarator,\n \t  abort ();\n \t}\n     }\n-  \n+\n   if (unqualified_id && TREE_CODE (unqualified_id) == TEMPLATE_ID_EXPR\n       && TREE_CODE (type) != FUNCTION_TYPE\n       && TREE_CODE (type) != METHOD_TYPE)\n     {\n-      error (\"template-id `%D' used as a declarator\", \n+      error (\"template-id `%D' used as a declarator\",\n \t     unqualified_id);\n       unqualified_id = dname;\n     }\n \n   /* If DECLARATOR is non-NULL, we know it is a cdk_id declarator;\n      otherwise, we would not have exited the loop above.  */\n-  if (declarator \n+  if (declarator\n       && TREE_CODE (declarator->u.id.name) == SCOPE_REF\n       /* If the qualifying scope was invalid, it will have been set to\n \t NULL_TREE above.  */\n@@ -7248,8 +7252,8 @@ grokdeclarator (const cp_declarator *declarator,\n \t       are always static functions.  */\n \t    ;\n \t  else if (current_class_type == NULL_TREE || friendp)\n-\t    type \n-\t      = build_method_type_directly (ctype, \n+\t    type\n+\t      = build_method_type_directly (ctype,\n \t\t\t\t\t    TREE_TYPE (type),\n \t\t\t\t\t    TYPE_ARG_TYPES (type));\n \t  else\n@@ -7304,7 +7308,7 @@ grokdeclarator (const cp_declarator *declarator,\n     }\n \n   if ((decl_context == FIELD || decl_context == PARM)\n-      && !processing_template_decl \n+      && !processing_template_decl\n       && variably_modified_type_p (type, NULL_TREE))\n     {\n       if (decl_context == FIELD)\n@@ -7377,7 +7381,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t  if (!current_function_decl)\n \t    DECL_CONTEXT (decl) = FROB_CONTEXT (current_namespace);\n \t}\n-      \n+\n       /* If the user declares \"typedef struct {...} foo\" then the\n \t struct will have an anonymous name.  Fill that name in now.\n \t Nothing can refer to it, so nothing needs know about the name\n@@ -7432,7 +7436,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t  || (typedef_decl && C_TYPEDEF_EXPLICITLY_SIGNED (typedef_decl)))\n \tC_TYPEDEF_EXPLICITLY_SIGNED (decl) = 1;\n \n-      bad_specifiers (decl, \"type\", virtualp, quals != TYPE_UNQUALIFIED, \n+      bad_specifiers (decl, \"type\", virtualp, quals != TYPE_UNQUALIFIED,\n \t\t      inlinep, friendp, raises != NULL_TREE);\n \n       return decl;\n@@ -7450,7 +7454,7 @@ grokdeclarator (const cp_declarator *declarator,\n \n   /* Detect where we're using a typedef of function type to declare a\n      function. PARMS will not be set, so we must create it now.  */\n-  \n+\n   if (type == typedef_type && TREE_CODE (type) == FUNCTION_TYPE)\n     {\n       tree decls = NULL_TREE;\n@@ -7463,7 +7467,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t  TREE_CHAIN (decl) = decls;\n \t  decls = decl;\n \t}\n-      \n+\n       parms = nreverse (decls);\n     }\n \n@@ -7668,7 +7672,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t      }\n \t\t  }\n \t\telse if (staticp < 2)\n-\t\t  type = build_method_type_directly (ctype, \n+\t\t  type = build_method_type_directly (ctype,\n \t\t\t\t\t\t     TREE_TYPE (type),\n \t\t\t\t\t\t     TYPE_ARG_TYPES (type));\n \t      }\n@@ -7784,7 +7788,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t    if (decl == error_mark_node)\n \t\t      return error_mark_node;\n \t\t  }\n-\t\t\n+\n \t\tdecl = do_friend (ctype, unqualified_id, decl,\n \t\t\t\t  *attrlist, flags, quals, funcdef_flag);\n \t\treturn decl;\n@@ -7901,7 +7905,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t  }\n \telse if (TREE_CODE (type) == FUNCTION_TYPE && staticp < 2\n \t\t && !NEW_DELETE_OPNAME_P (original_name))\n-\t  type = build_method_type_directly (ctype, \n+\t  type = build_method_type_directly (ctype,\n \t\t\t\t\t     TREE_TYPE (type),\n \t\t\t\t\t     TYPE_ARG_TYPES (type));\n \n@@ -7948,7 +7952,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t/* It's a variable.  */\n \n \t/* An uninitialized decl with `extern' is a reference.  */\n-\tdecl = grokvardecl (type, unqualified_id, \n+\tdecl = grokvardecl (type, unqualified_id,\n \t\t\t    declspecs,\n \t\t\t    initialized,\n \t\t\t    (type_quals & TYPE_QUAL_CONST) != 0,\n@@ -8273,7 +8277,7 @@ copy_fn_p (tree d)\n   tree args;\n   tree arg_type;\n   int result = 1;\n-  \n+\n   my_friendly_assert (DECL_FUNCTION_MEMBER_P (d), 20011208);\n \n   if (DECL_TEMPLATE_INFO (d) && is_member_template (DECL_TI_TEMPLATE (d)))\n@@ -8282,7 +8286,7 @@ copy_fn_p (tree d)\n        represented as template functions internally, and we must\n        accept those as copy functions.  */\n     return 0;\n-    \n+\n   args = FUNCTION_FIRST_USER_PARMTYPE (d);\n   if (!args)\n     return 0;\n@@ -8302,7 +8306,7 @@ copy_fn_p (tree d)\n     }\n   else\n     return 0;\n-  \n+\n   args = TREE_CHAIN (args);\n \n   if (args && args != void_list_node && !TREE_PURPOSE (args))\n@@ -8321,11 +8325,11 @@ void grok_special_member_properties (tree decl)\n   else if (DECL_CONSTRUCTOR_P (decl))\n     {\n       int ctor = copy_fn_p (decl);\n-      \n+\n       if (ctor > 0)\n \t{\n \t  /* [class.copy]\n-\t      \n+\n      \t     A non-template constructor for class X is a copy\n      \t     constructor if its first parameter is of type X&, const\n      \t     X&, volatile X& or const volatile X&, and either there\n@@ -8341,13 +8345,13 @@ void grok_special_member_properties (tree decl)\n   else if (DECL_OVERLOADED_OPERATOR_P (decl) == NOP_EXPR)\n     {\n       /* [class.copy]\n-\t  \n+\n      \t A non-template assignment operator for class X is a copy\n      \t assignment operator if its parameter is of type X, X&, const\n      \t X&, volatile X& or const volatile X&.  */\n-      \n+\n       int assop = copy_fn_p (decl);\n-      \n+\n       if (assop)\n \t{\n \t  TYPE_HAS_ASSIGN_REF (DECL_CONTEXT (decl)) = 1;\n@@ -8368,12 +8372,12 @@ grok_ctor_properties (tree ctype, tree decl)\n   if (ctor_parm < 0)\n     {\n       /* [class.copy]\n-\t  \n+\n      \t A declaration of a constructor for a class X is ill-formed if\n      \t its first parameter is of type (optionally cv-qualified) X\n      \t and either there are no other parameters or else all other\n      \t parameters have default arguments.\n-\t  \n+\n      \t We *don't* complain about member template instantiations that\n      \t have this form, though; they can occur as we try to decide\n      \t what constructor to use during overload resolution.  Since\n@@ -8386,7 +8390,7 @@ grok_ctor_properties (tree ctype, tree decl)\n \t\tctype, ctype);\n       return 0;\n     }\n-  \n+\n   return 1;\n }\n \n@@ -8791,7 +8795,7 @@ check_elaborated_type_specifier (enum tag_types tag_code,\n \n   type = TREE_TYPE (decl);\n \n-  /*   [dcl.type.elab] \n+  /*   [dcl.type.elab]\n \n        If the identifier resolves to a typedef-name or a template\n        type-parameter, the elaborated-type-specifier is ill-formed.\n@@ -8804,7 +8808,7 @@ check_elaborated_type_specifier (enum tag_types tag_code,\n       error (\"using typedef-name `%D' after `%s'\", decl, tag_name (tag_code));\n       return IS_AGGR_TYPE (type) ? type : error_mark_node;\n     }\n-    \n+\n   if (TREE_CODE (type) == TEMPLATE_TYPE_PARM)\n     {\n       error (\"using template type parameter `%T' after `%s'\",\n@@ -8995,7 +8999,7 @@ xref_tag (enum tag_types tag_code, tree name,\n     {\n       if (!globalize && processing_template_decl && IS_AGGR_TYPE (t))\n \tredeclare_class_template (t, current_template_parms);\n-      else if (!processing_template_decl \n+      else if (!processing_template_decl\n \t       && CLASS_TYPE_P (t)\n \t       && CLASSTYPE_IS_TEMPLATE (t))\n \t{\n@@ -9052,11 +9056,11 @@ xref_basetypes (tree ref, tree base_list)\n      instantiated.  This ensures that if we call ourselves recursively\n      we do not get confused about which classes are marked and which\n      are not.  */\n-  basep = &base_list; \n-  while (*basep) \n+  basep = &base_list;\n+  while (*basep)\n     {\n       tree basetype = TREE_VALUE (*basep);\n-      \n+\n       if (!(processing_template_decl && uses_template_parms (basetype))\n \t  && !complete_type_or_else (basetype, NULL))\n \t/* An incomplete type.  Remove it from the list.  */\n@@ -9078,41 +9082,42 @@ xref_basetypes (tree ref, tree base_list)\n      redefinition.  */\n   my_friendly_assert (!TYPE_BINFO (ref) || TYPE_SIZE (ref), 20040706);\n   my_friendly_assert (TYPE_MAIN_VARIANT (ref) == ref, 20040712);\n-  \n+\n   binfo = make_tree_binfo (max_bases);\n+\n   TYPE_BINFO (ref) = binfo;\n   BINFO_OFFSET (binfo) = size_zero_node;\n   BINFO_TYPE (binfo) = ref;\n-  \n+\n   if (max_bases)\n     {\n       BINFO_BASE_ACCESSES (binfo) = make_tree_vec (max_bases);\n       /* An aggregate cannot have baseclasses.  */\n       CLASSTYPE_NON_AGGREGATE (ref) = 1;\n-      \n+\n       if (TREE_CODE (ref) == UNION_TYPE)\n \terror (\"derived union `%T' invalid\", ref);\n     }\n-      \n+\n   if (max_bases > 1)\n     {\n       TYPE_USES_MULTIPLE_INHERITANCE (ref) = 1;\n       /* If there is more than one non-empty they cannot be at the\n \t same address.  */\n       TYPE_BASE_CONVS_MAY_REQUIRE_CODE_P (ref) = 1;\n-      \n+\n       if (TYPE_FOR_JAVA (ref))\n \terror (\"Java class '%T' cannot have multiple bases\", ref);\n     }\n-  \n+\n   if (max_vbases)\n     {\n       CLASSTYPE_VBASECLASSES (ref) = VEC_alloc (tree, max_vbases);\n       TYPE_USES_VIRTUAL_BASECLASSES (ref) = 1;\n       /* Converting to a virtual base class requires looking up the\n \t offset of the virtual base.  */\n       TYPE_BASE_CONVS_MAY_REQUIRE_CODE_P (ref) = 1;\n-      \n+\n       if (TYPE_FOR_JAVA (ref))\n \terror (\"Java class '%T' cannot have virtual bases\", ref);\n     }\n@@ -9122,10 +9127,10 @@ xref_basetypes (tree ref, tree base_list)\n       tree access = TREE_PURPOSE (base_list);\n       int via_virtual = TREE_TYPE (base_list) != NULL_TREE;\n       tree basetype = TREE_VALUE (base_list);\n-      \n+\n       if (access == access_default_node)\n \taccess = default_access;\n-\t  \n+\n       if (TREE_CODE (basetype) == TYPE_DECL)\n \tbasetype = TREE_TYPE (basetype);\n       if (TREE_CODE (basetype) != RECORD_TYPE\n@@ -9137,7 +9142,7 @@ xref_basetypes (tree ref, tree base_list)\n \t\t basetype);\n \t  continue;\n \t}\n-      \n+\n       if (CLASSTYPE_MARKED (basetype))\n \t{\n \t  if (basetype == ref)\n@@ -9147,7 +9152,7 @@ xref_basetypes (tree ref, tree base_list)\n \t  continue;\n \t}\n       SET_CLASSTYPE_MARKED (basetype);\n-      \n+\n       if (TYPE_FOR_JAVA (basetype) && (current_lang_depth () == 0))\n \tTYPE_FOR_JAVA (ref) = 1;\n \n@@ -9157,7 +9162,7 @@ xref_basetypes (tree ref, tree base_list)\n \t  base_binfo = TYPE_BINFO (basetype);\n \t  /* The orignal basetype could have been a typedef'd type.  */\n \t  basetype = BINFO_TYPE (base_binfo);\n-\t  \n+\n \t  /* Inherit flags from the base.  */\n \t  TYPE_HAS_NEW_OPERATOR (ref)\n \t    |= TYPE_HAS_NEW_OPERATOR (basetype);\n@@ -9170,7 +9175,7 @@ xref_basetypes (tree ref, tree base_list)\n \t    |= TYPE_BASE_CONVS_MAY_REQUIRE_CODE_P (basetype);\n \t  TYPE_HAS_CONVERSION (ref) |= TYPE_HAS_CONVERSION (basetype);\n \t}\n-      \n+\n       base_binfo = copy_binfo (base_binfo, basetype, ref,\n \t\t\t       &igo_prev, via_virtual);\n       if (!BINFO_INHERITANCE_CHAIN (base_binfo))\n@@ -9186,7 +9191,7 @@ xref_basetypes (tree ref, tree base_list)\n        slots.  */\n     TREE_VEC_LENGTH (BINFO_BASE_ACCESSES (binfo))\n       = BINFO_N_BASE_BINFOS (binfo);\n-  \n+\n   /* Unmark all the types.  */\n   for (i = 0; BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n     CLEAR_CLASSTYPE_MARKED (BINFO_TYPE (base_binfo));\n@@ -9244,7 +9249,7 @@ finish_enum (tree enumtype)\n   tree t;\n   bool unsignedp;\n   int lowprec;\n-  int highprec; \n+  int highprec;\n   int precision;\n   integer_type_kind itk;\n   tree underlying_type = NULL_TREE;\n@@ -9258,8 +9263,8 @@ finish_enum (tree enumtype)\n      works.  */\n   if (processing_template_decl)\n     {\n-      for (values = TYPE_VALUES (enumtype); \n-\t   values; \n+      for (values = TYPE_VALUES (enumtype);\n+\t   values;\n \t   values = TREE_CHAIN (values))\n \tTREE_TYPE (TREE_VALUE (values)) = enumtype;\n       if (at_function_scope_p ())\n@@ -9272,8 +9277,8 @@ finish_enum (tree enumtype)\n     {\n       minnode = maxnode = NULL_TREE;\n \n-      for (values = TYPE_VALUES (enumtype); \n-\t   values; \n+      for (values = TYPE_VALUES (enumtype);\n+\t   values;\n \t   values = TREE_CHAIN (values))\n \t{\n \t  decl = TREE_VALUE (values);\n@@ -9331,13 +9336,13 @@ finish_enum (tree enumtype)\n        enumeration.  It is implementation-defined which integral type is\n        used as the underlying type for an enumeration except that the\n        underlying type shall not be larger than int unless the value of\n-       an enumerator cannot fit in an int or unsigned int.  \n+       an enumerator cannot fit in an int or unsigned int.\n \n      We use \"int\" or an \"unsigned int\" as the underlying type, even if\n      a smaller integral type would work, unless the user has\n      explicitly requested that we use the smallest possible type.  */\n-  for (itk = (flag_short_enums ? itk_char : itk_int); \n-       itk != itk_none; \n+  for (itk = (flag_short_enums ? itk_char : itk_int);\n+       itk != itk_none;\n        itk++)\n     {\n       underlying_type = integer_types[itk];\n@@ -9357,7 +9362,7 @@ finish_enum (tree enumtype)\n       underlying_type = integer_types[itk_unsigned_long_long];\n     }\n \n-  /* Compute the minium and maximum values for the type.  \n+  /* Compute the minium and maximum values for the type.\n \n      [dcl.enum]\n \n@@ -9370,7 +9375,7 @@ finish_enum (tree enumtype)\n   set_min_and_max_values_for_integral_type (enumtype, precision, unsignedp);\n \n   /* [dcl.enum]\n-     \n+\n      The value of sizeof() applied to an enumeration type, an object\n      of an enumeration type, or an enumerator, is the value of sizeof()\n      applied to the underlying type.  */\n@@ -9591,13 +9596,13 @@ start_preparsed_function (tree decl1, tree attrs, int flags)\n   fntype = TREE_TYPE (decl1);\n   if (TREE_CODE (fntype) == METHOD_TYPE)\n     ctype = TYPE_METHOD_BASETYPE (fntype);\n-  \n+\n   /* ISO C++ 11.4/5.  A friend function defined in a class is in\n      the (lexical) scope of the class in which it is defined.  */\n   if (!ctype && DECL_FRIEND_P (decl1))\n     {\n       ctype = DECL_FRIEND_CONTEXT (decl1);\n-      \n+\n       /* CTYPE could be null here if we're dealing with a template;\n \t for example, `inline friend float foo()' inside a template\n \t will have no CTYPE set.  */\n@@ -9718,7 +9723,7 @@ start_preparsed_function (tree decl1, tree attrs, int flags)\n     {\n       /* A specialization is not used to guide overload resolution.  */\n       if (!DECL_FUNCTION_MEMBER_P (decl1)\n-\t  && !(DECL_USE_TEMPLATE (decl1) && \n+\t  && !(DECL_USE_TEMPLATE (decl1) &&\n \t       PRIMARY_TEMPLATE_P (DECL_TI_TEMPLATE (decl1))))\n \t{\n \t  tree olddecl = pushdecl (decl1);\n@@ -9805,13 +9810,13 @@ start_preparsed_function (tree decl1, tree attrs, int flags)\n   else if (interface_unknown == 0\n \t   && ! DECL_TEMPLATE_INSTANTIATION (decl1))\n     {\n-      if (DECL_DECLARED_INLINE_P (decl1) \n+      if (DECL_DECLARED_INLINE_P (decl1)\n \t  || DECL_TEMPLATE_INSTANTIATION (decl1)\n \t  || processing_template_decl)\n \t{\n \t  DECL_EXTERNAL (decl1)\n \t    = (interface_only\n-\t       || (DECL_DECLARED_INLINE_P (decl1) \n+\t       || (DECL_DECLARED_INLINE_P (decl1)\n \t\t   && ! flag_implement_inlines\n \t\t   && !DECL_VINDEX (decl1)));\n \n@@ -9842,7 +9847,7 @@ start_preparsed_function (tree decl1, tree attrs, int flags)\n \t So clear DECL_EXTERNAL.  */\n       DECL_EXTERNAL (decl1) = 0;\n \n-      if ((DECL_DECLARED_INLINE_P (decl1) \n+      if ((DECL_DECLARED_INLINE_P (decl1)\n \t   || DECL_TEMPLATE_INSTANTIATION (decl1))\n \t  && ! DECL_INTERFACE_KNOWN (decl1)\n \t  /* Don't try to defer nested functions for now.  */\n@@ -9863,7 +9868,7 @@ start_preparsed_function (tree decl1, tree attrs, int flags)\n     }\n \n   start_fname_decls ();\n-  \n+\n   store_parm_decls (current_function_parms);\n }\n \n@@ -9876,7 +9881,7 @@ start_preparsed_function (tree decl1, tree attrs, int flags)\n    yyparse to report a parse error.  */\n \n int\n-start_function (cp_decl_specifier_seq *declspecs, \n+start_function (cp_decl_specifier_seq *declspecs,\n \t\tconst cp_declarator *declarator,\n \t\ttree attrs)\n {\n@@ -9888,19 +9893,19 @@ start_function (cp_decl_specifier_seq *declspecs,\n       /* This should only be done once on the outermost decl.  */\n       have_extern_spec = false;\n     }\n-  \n+\n   decl1 = grokdeclarator (declarator, declspecs, FUNCDEF, 1, &attrs);\n   /* If the declarator is not suitable for a function definition,\n      cause a syntax error.  */\n   if (decl1 == NULL_TREE || TREE_CODE (decl1) != FUNCTION_DECL)\n     return 0;\n-  \n+\n   cplus_decl_attributes (&decl1, attrs, 0);\n-  \n+\n   /* If #pragma weak was used, mark the decl weak now.  */\n   if (global_scope_p (current_binding_level))\n     maybe_apply_pragma_weak (decl1);\n-  \n+\n   if (DECL_MAIN_P (decl1))\n     {\n       /* If this doesn't return integer_type, or a typedef to\n@@ -10070,7 +10075,7 @@ begin_destructor_body (void)\n   if_stmt = begin_if_stmt ();\n \n   /* If it is not safe to avoid setting up the vtables, then\n-     someone will change the condition to be boolean_true_node.  \n+     someone will change the condition to be boolean_true_node.\n      (Actually, for now, we do not have code to set the condition\n      appropriately, so we just assume that we always need to\n      initialize the vtables.)  */\n@@ -10117,7 +10122,7 @@ finish_destructor_body (void)\n       be looked up in the scope of the destructor's class and if\n       found shall be accessible and unambiguous.  */\n       exprstmt = build_op_delete_call\n-\t(DELETE_EXPR, current_class_ptr, virtual_size, \n+\t(DELETE_EXPR, current_class_ptr, virtual_size,\n \t /*global_p=*/false, NULL_TREE);\n \n       if_stmt = begin_if_stmt ();\n@@ -10183,7 +10188,7 @@ finish_function_body (tree compstmt)\n     finish_constructor_body ();\n   else if (DECL_DESTRUCTOR_P (current_function_decl))\n     finish_destructor_body ();\n-}  \n+}\n \n /* Finish up a function declaration and compile that function\n    all the way to assembler language output.  The free the storage\n@@ -10225,7 +10230,7 @@ finish_function (int flags)\n       which then got a warning when stored in a ptr-to-function variable.  */\n \n   my_friendly_assert (building_stmt_tree (), 20000911);\n-  \n+\n   /* For a cloned function, we've already got all the code we need;\n      there's no need to add any extra bits.  */\n   if (!DECL_CLONED_FUNCTION_P (fndecl))\n@@ -10263,7 +10268,7 @@ finish_function (int flags)\n   /* This must come after expand_function_end because cleanups might\n      have declarations (from inline functions) that need to go into\n      this function's blocks.  */\n-  \n+\n   /* If the current binding level isn't the outermost binding level\n      for this function, either there is a bug, or we have experienced\n      syntax errors and the statement tree is malformed.  */\n@@ -10406,7 +10411,7 @@ finish_function (int flags)\n    CHANGES TO CODE IN `grokfield'.  */\n \n tree\n-start_method (cp_decl_specifier_seq *declspecs, \n+start_method (cp_decl_specifier_seq *declspecs,\n               const cp_declarator *declarator, tree attrlist)\n {\n   tree fndecl = grokdeclarator (declarator, declspecs, MEMFUNCDEF, 0,\n@@ -10540,15 +10545,15 @@ maybe_register_incomplete_var (tree var)\n   my_friendly_assert (TREE_CODE (var) == VAR_DECL, 20020406);\n \n   /* Keep track of variables with incomplete types.  */\n-  if (!processing_template_decl && TREE_TYPE (var) != error_mark_node \n+  if (!processing_template_decl && TREE_TYPE (var) != error_mark_node\n       && DECL_EXTERNAL (var))\n     {\n       tree inner_type = TREE_TYPE (var);\n-      \n+\n       while (TREE_CODE (inner_type) == ARRAY_TYPE)\n \tinner_type = TREE_TYPE (inner_type);\n       inner_type = TYPE_MAIN_VARIANT (inner_type);\n-      \n+\n       if ((!COMPLETE_TYPE_P (inner_type) && CLASS_TYPE_P (inner_type))\n \t  /* RTTI TD entries are created while defining the type_info.  */\n \t  || (TYPE_LANG_SPECIFIC (inner_type)\n@@ -10567,7 +10572,7 @@ complete_vars (tree type)\n   tree *list = &incomplete_vars;\n \n   my_friendly_assert (CLASS_TYPE_P (type), 20020406);\n-  while (*list) \n+  while (*list)\n     {\n       if (same_type_p (type, TREE_PURPOSE (*list)))\n \t{\n@@ -10682,7 +10687,7 @@ cxx_push_function_context (struct function * f)\n \t  *cp_function_chain = *DECL_SAVED_FUNCTION_DATA (fn);\n \n \t  /* We don't need the saved data anymore.  Unless this is an inline\n-\t     function; we need the named return value info for \n+\t     function; we need the named return value info for\n \t     declare_return_variable.  */\n \t  if (! DECL_INLINE (fn))\n \t    DECL_SAVED_FUNCTION_DATA (fn) = NULL;"}, {"sha": "348d286c97eeecda0f5ba4f69adc0e0bdc675d6e", "filename": "gcc/expr.c", "status": "modified", "additions": 17, "deletions": 63, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caf93cb0d55b2a7d00eee250b5880a53205eef7c/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caf93cb0d55b2a7d00eee250b5880a53205eef7c/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=caf93cb0d55b2a7d00eee250b5880a53205eef7c", "patch": "@@ -3948,7 +3948,7 @@ store_expr (tree exp, rtx target, int want_value)\n   else\n     {\n       temp = expand_expr_real (exp, target, GET_MODE (target),\n-\t\t\t       (want_value & 2 \n+\t\t\t       (want_value & 2\n \t\t\t\t? EXPAND_STACK_PARM : EXPAND_NORMAL),\n \t\t\t       &alt_rtl);\n       /* Return TARGET if it's a specified hardware register.\n@@ -4142,7 +4142,7 @@ categorize_ctor_elements_1 (tree ctor, HOST_WIDE_INT *p_nz_elts,\n \n   nz_elts = 0;\n   nc_elts = 0;\n-  \n+\n   for (list = CONSTRUCTOR_ELTS (ctor); list; list = TREE_CHAIN (list))\n     {\n       tree value = TREE_VALUE (list);\n@@ -4297,7 +4297,7 @@ int\n mostly_zeros_p (tree exp)\n {\n   if (TREE_CODE (exp) == CONSTRUCTOR)\n-    \n+\n     {\n       HOST_WIDE_INT nz_elts, nc_elts, elts;\n \n@@ -4831,12 +4831,12 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n       if (REG_P (target) && VECTOR_MODE_P (GET_MODE (target)))\n \t{\n \t  enum machine_mode mode = GET_MODE (target);\n-\t  \n+\n \t  icode = (int) vec_init_optab->handlers[mode].insn_code;\n \t  if (icode != CODE_FOR_nothing)\n \t    {\n \t      unsigned int i;\n-\t      \n+\n \t      vector = alloca (n_elts);\n \t      for (i = 0; i < n_elts; i++)\n \t\tvector [i] = CONST0_RTX (GET_MODE_INNER (mode));\n@@ -5479,7 +5479,7 @@ array_ref_element_size (tree exp)\n     return size_binop (MULT_EXPR, aligned_size,\n \t\t       size_int (TYPE_ALIGN (elmt_type) / BITS_PER_UNIT));\n \n-  /* Otherwise, take the size from that of the element type.  Substitute \n+  /* Otherwise, take the size from that of the element type.  Substitute\n      any PLACEHOLDER_EXPR that we have.  */\n   else\n     return SUBSTITUTE_PLACEHOLDER_IN_EXPR (TYPE_SIZE_UNIT (elmt_type), exp);\n@@ -5539,7 +5539,7 @@ component_ref_field_offset (tree exp)\n     return size_binop (MULT_EXPR, aligned_offset,\n \t\t       size_int (DECL_OFFSET_ALIGN (field) / BITS_PER_UNIT));\n \n-  /* Otherwise, take the offset from that of the field.  Substitute \n+  /* Otherwise, take the offset from that of the field.  Substitute\n      any PLACEHOLDER_EXPR that we have.  */\n   else\n     return SUBSTITUTE_PLACEHOLDER_IN_EXPR (DECL_FIELD_OFFSET (field), exp);\n@@ -5861,11 +5861,6 @@ safe_from_p (rtx x, tree exp, int top_p)\n \tcase SAVE_EXPR:\n \t  return safe_from_p (x, TREE_OPERAND (exp, 0), 0);\n \n-\tcase BIND_EXPR:\n-\t  /* The only operand we look at is operand 1.  The rest aren't\n-\t     part of the expression.  */\n-\t  return safe_from_p (x, TREE_OPERAND (exp, 1), 0);\n-\n \tdefault:\n \t  break;\n \t}\n@@ -6037,7 +6032,7 @@ expand_var (tree var)\n \t{\n \t  /* Prepare a mem & address for the decl.  */\n \t  rtx x;\n-\t\t    \n+\n \t  if (TREE_STATIC (var))\n \t    abort ();\n \n@@ -6063,23 +6058,6 @@ expand_var (tree var)\n     }\n }\n \n-/* Expands declarations of variables in list VARS.  */\n-\n-static void\n-expand_vars (tree vars)\n-{\n-  for (; vars; vars = TREE_CHAIN (vars))\n-    {\n-      tree var = vars;\n-\n-      if (DECL_EXTERNAL (var))\n-\tcontinue;\n-\n-      expand_var (var);\n-      expand_decl_init (var);\n-    }\n-}\n-\n /* Subroutine of expand_expr.  Expand the two operands of a binary\n    expression EXP0 and EXP1 placing the results in OP0 and OP1.\n    The value may be stored in TARGET if TARGET is nonzero.  The\n@@ -6148,7 +6126,7 @@ expand_operands (tree exp0, tree exp1, rtx target, rtx *op0, rtx *op1,\n    marked TARGET so that it's safe from being trashed by libcalls.  We\n    don't want to use TARGET for anything but the final result;\n    Intermediate values must go elsewhere.   Additionally, calls to\n-   emit_block_move will be flagged with BLOCK_OP_CALL_PARM.  \n+   emit_block_move will be flagged with BLOCK_OP_CALL_PARM.\n \n    If EXP is a VAR_DECL whose DECL_RTL was a MEM with an invalid\n    address, and ALT_RTL is non-NULL, then *ALT_RTL is set to the\n@@ -6183,19 +6161,19 @@ expand_expr_real (tree exp, rtx target, enum machine_mode tmode,\n     }\n \n   /* If this is an expression of some kind and it has an associated line\n-     number, then emit the line number before expanding the expression. \n+     number, then emit the line number before expanding the expression.\n \n      We need to save and restore the file and line information so that\n      errors discovered during expansion are emitted with the right\n-     information.  It would be better of the diagnostic routines \n+     information.  It would be better of the diagnostic routines\n      used the file/line information embedded in the tree nodes rather\n      than globals.  */\n   if (cfun && EXPR_HAS_LOCATION (exp))\n     {\n       location_t saved_location = input_location;\n       input_location = EXPR_LOCATION (exp);\n       emit_line_note (input_location);\n-      \n+\n       /* Record where the insns produced belong.  */\n       record_block_change (TREE_BLOCK (exp));\n \n@@ -6212,9 +6190,9 @@ expand_expr_real (tree exp, rtx target, enum machine_mode tmode,\n      expand_call() will mark CALL_INSNs before we get to this code,\n      but it doesn't handle libcalls, and these may trap.  */\n   if (rn >= 0)\n-    {\t\n+    {\n       rtx insn;\n-      for (insn = next_real_insn (last); insn; \n+      for (insn = next_real_insn (last); insn;\n \t   insn = next_real_insn (insn))\n \t{\n \t  if (! find_reg_note (insn, REG_EH_REGION, NULL_RTX)\n@@ -6501,7 +6479,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       if (GET_MODE_CLASS (TYPE_MODE (TREE_TYPE (exp))) == MODE_VECTOR_INT\n \t  || GET_MODE_CLASS (TYPE_MODE (TREE_TYPE (exp))) == MODE_VECTOR_FLOAT)\n \treturn const_vector_from_tree (exp);\n-      else \n+      else\n \treturn expand_expr (build1 (CONSTRUCTOR, TREE_TYPE (exp),\n \t\t\t\t    TREE_VECTOR_CST_ELTS (exp)),\n \t\t\t    ignore ? const0_rtx : target, tmode, modifier);\n@@ -6624,31 +6602,6 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       expand_goto (LABELED_BLOCK_LABEL (EXIT_BLOCK_LABELED_BLOCK (exp)));\n       return const0_rtx;\n \n-    case BIND_EXPR:\n-      {\n-\ttree block = BIND_EXPR_BLOCK (exp);\n-\tint mark_ends;\n-\n-\t/* If we're in functions-as-trees mode, this BIND_EXPR represents\n-\t   the block, so we need to emit NOTE_INSN_BLOCK_* notes.  */\n-\tmark_ends = (block != NULL_TREE);\n-\texpand_start_bindings_and_block (mark_ends ? 0 : 2, block);\n-\n-\t/* If VARS have not yet been expanded, expand them now.  */\n-\texpand_vars (BIND_EXPR_VARS (exp));\n-\n-\t/* TARGET was clobbered early in this function.  The correct\n-\t   indicator or whether or not we need the value of this \n-\t   expression is the IGNORE variable.  */\n-\ttemp = expand_expr (BIND_EXPR_BODY (exp),\n-\t\t\t    ignore ? const0_rtx : target,\n-\t\t\t    tmode, modifier);\n-\n-\texpand_end_bindings (BIND_EXPR_VARS (exp), mark_ends, 0);\n-\n-\treturn temp;\n-      }\n-\n     case CONSTRUCTOR:\n       /* If we don't need the result, just ensure we evaluate any\n \t subexpressions.  */\n@@ -8617,6 +8570,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n     case TARGET_EXPR:\n     case CASE_LABEL_EXPR:\n     case VA_ARG_EXPR:\n+    case BIND_EXPR:\n       /* Lowered by gimplify.c.  */\n       abort ();\n \n@@ -8740,7 +8694,7 @@ is_aligning_offset (tree offset, tree exp)\n      power of 2 and which is larger than BIGGEST_ALIGNMENT.  */\n   if (TREE_CODE (offset) != BIT_AND_EXPR\n       || !host_integerp (TREE_OPERAND (offset, 1), 1)\n-      || compare_tree_int (TREE_OPERAND (offset, 1), \n+      || compare_tree_int (TREE_OPERAND (offset, 1),\n \t\t\t   BIGGEST_ALIGNMENT / BITS_PER_UNIT) <= 0\n       || !exact_log2 (tree_low_cst (TREE_OPERAND (offset, 1), 1) + 1) < 0)\n     return 0;"}, {"sha": "b29b41ca84b425d129203862a459813db9f38dad", "filename": "gcc/stmt.c", "status": "modified", "additions": 3, "deletions": 174, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caf93cb0d55b2a7d00eee250b5880a53205eef7c/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caf93cb0d55b2a7d00eee250b5880a53205eef7c/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=caf93cb0d55b2a7d00eee250b5880a53205eef7c", "patch": "@@ -212,8 +212,6 @@ do { struct nesting *target = STACK;\t\t\t\\\n      do { this = nesting_stack;\t\t\t\t\\\n \t  if (cond_stack == this)\t\t\t\\\n \t    cond_stack = cond_stack->next;\t\t\\\n-\t  if (block_stack == this)\t\t\t\\\n-\t    block_stack = block_stack->next;\t\t\\\n \t  if (case_stack == this)\t\t\t\\\n \t    case_stack = case_stack->next;\t\t\\\n \t  nesting_depth = nesting_stack->depth - 1;\t\\\n@@ -223,9 +221,6 @@ do { struct nesting *target = STACK;\t\t\t\\\n \n struct stmt_status GTY(())\n {\n-  /* Chain of all pending binding contours.  */\n-  struct nesting * x_block_stack;\n-\n   /* If any new stacks are added here, add them to POPSTACKS too.  */\n \n   /* Chain of all pending conditional statements.  */\n@@ -249,7 +244,6 @@ struct stmt_status GTY(())\n   location_t x_emit_locus;\n };\n \n-#define block_stack (cfun->stmt->x_block_stack)\n #define cond_stack (cfun->stmt->x_cond_stack)\n #define case_stack (cfun->stmt->x_case_stack)\n #define nesting_stack (cfun->stmt->x_nesting_stack)\n@@ -410,7 +404,7 @@ expand_label (tree label)\n \n   if (FORCED_LABEL (label))\n     forced_labels = gen_rtx_EXPR_LIST (VOIDmode, label_r, forced_labels);\n-      \n+\n   if (DECL_NONLOCAL (label) || FORCED_LABEL (label))\n     maybe_set_first_label_num (label_r);\n }\n@@ -1436,7 +1430,7 @@ resolve_asm_operand_names (tree string, tree outputs, tree inputs)\n \t than 999 operands.  */\n       buffer = xstrdup (TREE_STRING_POINTER (string));\n       p = buffer + (c - TREE_STRING_POINTER (string));\n-      \n+\n       while ((p = strchr (p, '%')) != NULL)\n \t{\n \t  if (p[1] == '[')\n@@ -1561,7 +1555,7 @@ expand_expr_stmt (tree exp)\n }\n \n /* Warn if EXP contains any computations whose results are not used.\n-   Return 1 if a warning is printed; 0 otherwise.  LOCUS is the \n+   Return 1 if a warning is printed; 0 otherwise.  LOCUS is the\n    (potential) location of the expression.  */\n \n int\n@@ -2061,98 +2055,6 @@ expand_return (tree retval)\n     }\n }\n \f\n-/* Generate the RTL code for entering a binding contour.\n-   The variables are declared one by one, by calls to `expand_decl'.\n-\n-   FLAGS is a bitwise or of the following flags:\n-\n-     1 - Nonzero if this construct should be visible to\n-         `exit_something'.\n-\n-     2 - Nonzero if this contour does not require a\n-\t NOTE_INSN_BLOCK_BEG note.  Virtually all calls from\n-\t language-independent code should set this flag because they\n-\t will not create corresponding BLOCK nodes.  (There should be\n-\t a one-to-one correspondence between NOTE_INSN_BLOCK_BEG notes\n-\t and BLOCKs.)  If this flag is set, MARK_ENDS should be zero\n-\t when expand_end_bindings is called.\n-\n-    If we are creating a NOTE_INSN_BLOCK_BEG note, a BLOCK may\n-    optionally be supplied.  If so, it becomes the NOTE_BLOCK for the\n-    note.  */\n-\n-void\n-expand_start_bindings_and_block (int flags, tree block)\n-{\n-  struct nesting *thisblock = ALLOC_NESTING ();\n-  rtx note;\n-  int exit_flag = ((flags & 1) != 0);\n-  int block_flag = ((flags & 2) == 0);\n-\n-  /* If a BLOCK is supplied, then the caller should be requesting a\n-     NOTE_INSN_BLOCK_BEG note.  */\n-  if (!block_flag && block)\n-    abort ();\n-\n-  /* Create a note to mark the beginning of the block.  */\n-  note = emit_note (NOTE_INSN_DELETED);\n-\n-  /* Make an entry on block_stack for the block we are entering.  */\n-\n-  thisblock->desc = BLOCK_NESTING;\n-  thisblock->next = block_stack;\n-  thisblock->all = nesting_stack;\n-  thisblock->depth = ++nesting_depth;\n-  thisblock->data.block.block_target_temp_slot_level = target_temp_slot_level;\n-\n-  /* When we insert instructions after the last unconditional cleanup,\n-     we don't adjust last_insn.  That means that a later add_insn will\n-     clobber the instructions we've just added.  The easiest way to\n-     fix this is to just insert another instruction here, so that the\n-     instructions inserted after the last unconditional cleanup are\n-     never the last instruction.  */\n-  emit_note (NOTE_INSN_DELETED);\n-\n-  thisblock->data.block.first_insn = note;\n-  thisblock->data.block.block_start_count = ++current_block_start_count;\n-  thisblock->exit_label = exit_flag ? gen_label_rtx () : 0;\n-  block_stack = thisblock;\n-  nesting_stack = thisblock;\n-\n-  /* Make a new level for allocating stack slots.  */\n-  push_temp_slots ();\n-}\n-\n-/* Specify the scope of temporaries created by TARGET_EXPRs.  Similar\n-   to CLEANUP_POINT_EXPR, but handles cases when a series of calls to\n-   expand_expr are made.  After we end the region, we know that all\n-   space for all temporaries that were created by TARGET_EXPRs will be\n-   destroyed and their space freed for reuse.  */\n-\n-void\n-expand_start_target_temps (void)\n-{\n-  /* This is so that even if the result is preserved, the space\n-     allocated will be freed, as we know that it is no longer in use.  */\n-  push_temp_slots ();\n-\n-  /* Start a new binding layer that will keep track of all cleanup\n-     actions to be performed.  */\n-  expand_start_bindings (2);\n-\n-  target_temp_slot_level = temp_slot_level;\n-}\n-\n-void\n-expand_end_target_temps (void)\n-{\n-  expand_end_bindings (NULL_TREE, 0, 0);\n-\n-  /* This is so that even if the result is preserved, the space\n-     allocated will be freed, as we know that it is no longer in use.  */\n-  pop_temp_slots ();\n-}\n-\n /* Given a pointer to a BLOCK node return nonzero if (and only if) the node\n    in question represents the outermost pair of curly braces (i.e. the \"body\n    block\") of a function or method.\n@@ -2185,15 +2087,6 @@ is_body_block (tree stmt)\n   return 0;\n }\n \n-/* Return an opaque pointer to the current nesting level, so frontend code\n-   can check its own sanity.  */\n-\n-struct nesting *\n-current_nesting_level (void)\n-{\n-  return cfun ? block_stack : 0;\n-}\n-\n /* Emit code to restore vital registers at the beginning of a nonlocal goto\n    handler.  */\n static void\n@@ -2263,70 +2156,6 @@ expand_nl_goto_receiver (void)\n      insn.  */\n   emit_insn (gen_rtx_ASM_INPUT (VOIDmode, \"\"));\n }\n-\n-/* Warn about any unused VARS (which may contain nodes other than\n-   VAR_DECLs, but such nodes are ignored).  The nodes are connected\n-   via the TREE_CHAIN field.  */\n-\n-void\n-warn_about_unused_variables (tree vars)\n-{\n-  tree decl;\n-\n-  if (warn_unused_variable)\n-    for (decl = vars; decl; decl = TREE_CHAIN (decl))\n-      if (TREE_CODE (decl) == VAR_DECL\n-\t  && ! TREE_USED (decl)\n-\t  && ! DECL_IN_SYSTEM_HEADER (decl)\n-\t  && DECL_NAME (decl) && ! DECL_ARTIFICIAL (decl))\n-\twarning (\"%Junused variable '%D'\", decl, decl);\n-}\n-\n-/* Generate RTL code to terminate a binding contour.\n-\n-   VARS is the chain of VAR_DECL nodes for the variables bound in this\n-   contour.  There may actually be other nodes in this chain, but any\n-   nodes other than VAR_DECLS are ignored.\n-\n-   MARK_ENDS is nonzero if we should put a note at the beginning\n-   and end of this binding contour.\n-\n-   DONT_JUMP_IN is positive if it is not valid to jump into this contour,\n-   zero if we can jump into this contour only if it does not have a saved\n-   stack level, and negative if we are not to check for invalid use of\n-   labels (because the front end does that).  */\n-\n-void\n-expand_end_bindings (tree vars, int mark_ends ATTRIBUTE_UNUSED,\n-\t\t     int dont_jump_in ATTRIBUTE_UNUSED)\n-{\n-  struct nesting *thisblock = block_stack;\n-\n-  /* If any of the variables in this scope were not used, warn the\n-     user.  */\n-  warn_about_unused_variables (vars);\n-\n-  if (thisblock->exit_label)\n-    {\n-      do_pending_stack_adjust ();\n-      emit_label (thisblock->exit_label);\n-    }\n-\n-  /* Mark the beginning and end of the scope if requested.  */\n-\n-  /* Get rid of the beginning-mark if we don't make an end-mark.  */\n-  NOTE_LINE_NUMBER (thisblock->data.block.first_insn) = NOTE_INSN_DELETED;\n-\n-  /* Restore the temporary level of TARGET_EXPRs.  */\n-  target_temp_slot_level = thisblock->data.block.block_target_temp_slot_level;\n-\n-  /* Restore block_stack level for containing block.  */\n-\n-  POPSTACK (block_stack);\n-\n-  /* Pop the stack slot nesting and free any slots at this level.  */\n-  pop_temp_slots ();\n-}\n \f\n /* Generate RTL for the automatic variable declaration DECL.\n    (Other kinds of declarations are simply ignored if seen here.)  */"}, {"sha": "ff5d5eaa72a009d41d51da81b770c2b2c4e13d89", "filename": "gcc/tree.h", "status": "modified", "additions": 11, "deletions": 18, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caf93cb0d55b2a7d00eee250b5880a53205eef7c/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caf93cb0d55b2a7d00eee250b5880a53205eef7c/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=caf93cb0d55b2a7d00eee250b5880a53205eef7c", "patch": "@@ -248,7 +248,7 @@ struct tree_common GTY(())\n            BLOCK\n \t   ..._DECL\n        CALL_FROM_THUNK_P in\n-           CALL_EXPR \n+           CALL_EXPR\n \n    side_effects_flag:\n \n@@ -569,7 +569,7 @@ extern void tree_operand_check_failed (int, enum tree_code,\n   TREE_CHECK3 (T, RECORD_TYPE, UNION_TYPE, QUAL_UNION_TYPE)\n #define NOT_RECORD_OR_UNION_CHECK(T) \\\n   TREE_NOT_CHECK3 (T, RECORD_TYPE, UNION_TYPE, QUAL_UNION_TYPE)\n-    \n+\n #define NUMERICAL_TYPE_CHECK(T)\t\t\t\t\t\\\n   TREE_CHECK5 (T, INTEGER_TYPE, ENUMERAL_TYPE, BOOLEAN_TYPE,\t\\\n \t       CHAR_TYPE, REAL_TYPE)\n@@ -764,7 +764,7 @@ extern void tree_operand_check_failed (int, enum tree_code,\n /* In an INTEGER_CST, REAL_CST, COMPLEX_CST, or VECTOR_CST, this means\n    there was an overflow in folding, and no warning has been issued\n    for this subexpression.  TREE_OVERFLOW implies TREE_CONSTANT_OVERFLOW,\n-   but not vice versa. \n+   but not vice versa.\n \n    ??? Apparently, lots of code assumes this is defined in all\n    expressions.  */\n@@ -806,7 +806,7 @@ extern void tree_operand_check_failed (int, enum tree_code,\n    accessing the memory pointed to won't generate a trap.  However,\n    this only applies to an object when used appropriately: it doesn't\n    mean that writing a READONLY mem won't trap.\n-   \n+\n    In ARRAY_REF and ARRAY_RANGE_REF means that we know that the index\n    (or slice of the array) always belongs to the range of the array.\n    I.e. that the access will not trap, provided that the access to\n@@ -843,7 +843,7 @@ extern void tree_operand_check_failed (int, enum tree_code,\n    to be compiled separately.\n    Nonzero in a RECORD_TYPE, UNION_TYPE, QUAL_UNION_TYPE or ENUMERAL_TYPE\n    if the sdb debugging info for the type has been written.\n-   In a BLOCK node, nonzero if reorder_blocks has already seen this block. \n+   In a BLOCK node, nonzero if reorder_blocks has already seen this block.\n    In an SSA_NAME node, nonzero if the SSA_NAME occurs in an abnormal\n    PHI node.  */\n #define TREE_ASM_WRITTEN(NODE) ((NODE)->common.asm_written_flag)\n@@ -1163,7 +1163,7 @@ struct tree_vec GTY(())\n \n /* VDEF_EXPR accessors are specified in tree-flow.h, along with the other\n    accessors for SSA operands.  */\n-   \n+\n /* CATCH_EXPR accessors.  */\n #define CATCH_TYPES(NODE)\tTREE_OPERAND (CATCH_EXPR_CHECK (NODE), 0)\n #define CATCH_BODY(NODE)\tTREE_OPERAND (CATCH_EXPR_CHECK (NODE), 1)\n@@ -1227,7 +1227,7 @@ struct tree_exp GTY(())\n /* Auxiliary pass-specific data.  */\n #define SSA_NAME_AUX(N) \\\n    SSA_NAME_CHECK (N)->ssa_name.aux\n-   \n+\n #ifndef _TREE_FLOW_H\n struct ptr_info_def;\n #endif\n@@ -1245,7 +1245,7 @@ struct tree_ssa_name GTY(())\n   /* Pointer attributes used for alias analysis.  */\n   struct ptr_info_def *ptr_info;\n \n-  /* Value for SSA name used by GVN.  */ \n+  /* Value for SSA name used by GVN.  */\n   tree GTY((skip)) value_handle;\n \n   /* Auxiliary information stored with the ssa name.  */\n@@ -3360,11 +3360,6 @@ extern void expand_stack_alloc (tree, tree);\n extern rtx expand_stack_save (void);\n extern void expand_stack_restore (tree);\n extern void expand_return (tree);\n-extern void expand_start_bindings_and_block (int, tree);\n-#define expand_start_bindings(flags) \\\n-  expand_start_bindings_and_block(flags, NULL_TREE)\n-extern void expand_end_bindings (tree, int, int);\n-extern void warn_about_unused_variables (tree);\n extern int is_body_block (tree);\n \n extern struct nesting * current_nesting_level (void);\n@@ -3632,8 +3627,6 @@ extern void expand_asm_expr (tree);\n extern bool asm_op_is_mem_input (tree, tree);\n extern tree resolve_asm_operand_names (tree, tree, tree);\n extern void init_stmt_for_function (void);\n-extern void expand_start_target_temps (void);\n-extern void expand_end_target_temps (void);\n extern void expand_elseif (tree);\n extern void expand_decl (tree);\n extern void expand_anon_union_decl (tree, tree, tree);\n@@ -3702,7 +3695,7 @@ enum tree_dump_index\n   TDI_nested,\t\t\t/* dump each function after unnesting it */\n   TDI_inlined,\t\t\t/* dump each function after inlining\n \t\t\t\t   within it.  */\n-  TDI_vcg,\t\t\t/* create a VCG graph file for each \n+  TDI_vcg,\t\t\t/* create a VCG graph file for each\n \t\t\t\t   function's flowgraph.  */\n   TDI_xml,                      /* dump function call graph.  */\n   TDI_all,\t\t\t/* enable all the dumps.  */\n@@ -3749,7 +3742,7 @@ extern void fancy_abort (const char *, int, const char *)\n     ATTRIBUTE_NORETURN;\n #define abort() fancy_abort (__FILE__, __LINE__, __FUNCTION__)\n \n-/* Enum and arrays used for tree allocation stats. \n+/* Enum and arrays used for tree allocation stats.\n    Keep in sync with tree.c:tree_node_kind_names.  */\n typedef enum\n {\n@@ -3780,7 +3773,7 @@ extern int tree_node_sizes[];\n    be restricted.  False if we are not in gimple form and folding is not\n    restricted to creating gimple expressions.  */\n extern bool in_gimple_form;\n-    \n+\n /* In tree-ssa-loop-niter.c.  */\n \n tree lower_bound_in_type (tree, tree);"}]}