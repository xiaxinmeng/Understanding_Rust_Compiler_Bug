{"sha": "fc50d9a252c89c1bac78192bd0884ff23f2bf48b", "node_id": "C_kwDOANBUbNoAKGZjNTBkOWEyNTJjODljMWJhYzc4MTkyYmQwODg0ZmYyM2YyYmY0OGI", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2022-03-25T17:13:35Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2022-03-28T14:57:08Z"}, "message": "c++: hash table ICE with variadic alias [PR105003]\n\nFor PR104008 we thought it might be enough to keep strip_typedefs from\nremoving this alias template specialization, but this PR demonstrates that\nother parts of the compiler also need to know to consider it dependent.\n\nSo, this patch changes complex_alias_template_p to no longer consider\ntemplate parameters used when their only use appears in a pack expansion,\nunless they are the parameter packs being expanded.\n\nTo do that I also needed to change it to use cp_walk_tree instead of\nfor_each_template_parm.  It occurs to me that find_template_parameters\nshould probably also use cp_walk_tree, but I'm not messing with that now.\n\n\tPR c++/105003\n\tPR c++/104008\n\tPR c++/102869\n\ngcc/cp/ChangeLog:\n\n\t* pt.cc (complex_alias_template_r): walk_tree callback,\treplacing\n\tuses_all_template_parms_r, complex_pack_expansion_r.\n\t(complex_alias_template_p): Adjust.\n\t* tree.cc (strip_typedefs): Revert r12-7710 change.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp0x/variadic-alias6.C: New test.\n\t* g++.dg/cpp0x/variadic-alias7.C: New test.", "tree": {"sha": "39af0141a157f237413eb184d164565540188dde", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/39af0141a157f237413eb184d164565540188dde"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fc50d9a252c89c1bac78192bd0884ff23f2bf48b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc50d9a252c89c1bac78192bd0884ff23f2bf48b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc50d9a252c89c1bac78192bd0884ff23f2bf48b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc50d9a252c89c1bac78192bd0884ff23f2bf48b/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "875342766d42988fa2f8eb7d34ef562ba69e340a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/875342766d42988fa2f8eb7d34ef562ba69e340a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/875342766d42988fa2f8eb7d34ef562ba69e340a"}], "stats": {"total": 121, "additions": 85, "deletions": 36}, "files": [{"sha": "3df509bbed01fba942f8aebd05fde6fad052eefc", "filename": "gcc/cp/pt.cc", "status": "modified", "additions": 48, "deletions": 24, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc50d9a252c89c1bac78192bd0884ff23f2bf48b/gcc%2Fcp%2Fpt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc50d9a252c89c1bac78192bd0884ff23f2bf48b/gcc%2Fcp%2Fpt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.cc?ref=fc50d9a252c89c1bac78192bd0884ff23f2bf48b", "patch": "@@ -6460,42 +6460,44 @@ alias_template_specialization_p (const_tree t,\n   return NULL_TREE;\n }\n \n-/* An alias template is complex from a SFINAE perspective if a template-id\n-   using that alias can be ill-formed when the expansion is not, as with\n-   the void_t template.  We determine this by checking whether the\n-   expansion for the alias template uses all its template parameters.  */\n+/* Data structure for complex_alias_template_*.  */\n \n struct uses_all_template_parms_data\n {\n   int level;\n   bool *seen;\n };\n \n-static int\n-uses_all_template_parms_r (tree t, void *data_)\n+/* walk_tree callback for complex_alias_template_p.  */\n+\n+static tree\n+complex_alias_template_r (tree *tp, int *walk_subtrees, void *data_)\n {\n-  struct uses_all_template_parms_data &data\n-    = *(struct uses_all_template_parms_data*)data_;\n-  tree idx = get_template_parm_index (t);\n+  tree t = *tp;\n+  auto &data = *(struct uses_all_template_parms_data*)data_;\n \n-  if (TEMPLATE_PARM_LEVEL (idx) == data.level)\n-    data.seen[TEMPLATE_PARM_IDX (idx)] = true;\n-  return 0;\n-}\n+  switch (TREE_CODE (t))\n+    {\n+    case TEMPLATE_TYPE_PARM:\n+    case TEMPLATE_PARM_INDEX:\n+    case TEMPLATE_TEMPLATE_PARM:\n+    case BOUND_TEMPLATE_TEMPLATE_PARM:\n+      {\n+\ttree idx = get_template_parm_index (t);\n+\tif (TEMPLATE_PARM_LEVEL (idx) == data.level)\n+\t  data.seen[TEMPLATE_PARM_IDX (idx)] = true;\n+      }\n \n-/* for_each_template_parm any_fn callback for complex_alias_template_p.  */\n+    default:;\n+    }\n+\n+  if (!PACK_EXPANSION_P (t))\n+    return 0;\n \n-static int\n-complex_pack_expansion_r (tree t, void *data_)\n-{\n   /* An alias template with a pack expansion that expands a pack from the\n      enclosing class needs to be considered complex, to avoid confusion with\n      the same pack being used as an argument to the alias's own template\n      parameter (91966).  */\n-  if (!PACK_EXPANSION_P (t))\n-    return 0;\n-  struct uses_all_template_parms_data &data\n-    = *(struct uses_all_template_parms_data*)data_;\n   for (tree pack = PACK_EXPANSION_PARAMETER_PACKS (t); pack;\n        pack = TREE_CHAIN (pack))\n     {\n@@ -6505,11 +6507,34 @@ complex_pack_expansion_r (tree t, void *data_)\n       int idx, level;\n       template_parm_level_and_index (parm_pack, &level, &idx);\n       if (level < data.level)\n-\treturn 1;\n+\treturn t;\n+\n+      /* Consider the expanded packs to be used outside the expansion...  */\n+      data.seen[idx] = true;\n     }\n+\n+  /* ...but don't walk into the pattern.  Consider PR104008:\n+\n+     template <typename T, typename... Ts>\n+     using IsOneOf = disjunction<is_same<T, Ts>...>;\n+\n+     where IsOneOf seemingly uses all of its template parameters in its\n+     expansion (and does not expand a pack from the enclosing class), so the\n+     alias was not marked as complex.  However, if it is used like\n+     \"IsOneOf<T>\", the empty pack for Ts means that T no longer appears in the\n+     expansion.  So only Ts is considered used by the pack expansion.  */\n+  *walk_subtrees = false;\n+\n   return 0;\n }\n \n+/* An alias template is complex from a SFINAE perspective if a template-id\n+   using that alias can be ill-formed when the expansion is not, as with\n+   the void_t template.\n+\n+   Returns 1 if always complex, 0 if not complex, -1 if complex iff any of the\n+   template arguments are empty packs.  */\n+\n static bool\n complex_alias_template_p (const_tree tmpl)\n {\n@@ -6530,8 +6555,7 @@ complex_alias_template_p (const_tree tmpl)\n   for (int i = 0; i < len; ++i)\n     data.seen[i] = false;\n \n-  if (for_each_template_parm (pat, uses_all_template_parms_r, &data,\n-\t\t\t      NULL, true, complex_pack_expansion_r))\n+  if (cp_walk_tree_without_duplicates (&pat, complex_alias_template_r, &data))\n     return true;\n   for (int i = 0; i < len; ++i)\n     if (!data.seen[i])"}, {"sha": "780a8d89165e212ddcc11ac0f4cb475beea8f301", "filename": "gcc/cp/tree.cc", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc50d9a252c89c1bac78192bd0884ff23f2bf48b/gcc%2Fcp%2Ftree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc50d9a252c89c1bac78192bd0884ff23f2bf48b/gcc%2Fcp%2Ftree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.cc?ref=fc50d9a252c89c1bac78192bd0884ff23f2bf48b", "patch": "@@ -1778,18 +1778,7 @@ strip_typedefs (tree t, bool *remove_attributes, unsigned int flags)\n \tif (TYPE_P (pat))\n \t  {\n \t    type = strip_typedefs (pat, remove_attributes, flags);\n-\t    /* Empty packs can thwart our efforts here.  Consider\n-\n-\t\ttemplate <typename T, typename... Ts>\n-\t\tusing IsOneOf = disjunction<is_same<T, Ts>...>;\n-\n-\t      where IsOneOf seemingly uses all of its template parameters in\n-\t      its expansion (and does not expand a pack from the enclosing\n-\t      class), so the alias is not marked as complex.  However, it may\n-\t      be used as in \"IsOneOf<Ts>\", where Ts is an empty parameter pack,\n-\t      and stripping it down into \"disjunction<>\" here would exclude the\n-\t      Ts pack, resulting in an error.  */\n-\t    if (type != pat && uses_parameter_packs (type))\n+\t    if (type != pat)\n \t      {\n \t\tresult = build_distinct_type_copy (t);\n \t\tPACK_EXPANSION_PATTERN (result) = type;"}, {"sha": "c095bc537d78c374d848fe446905e8a3ad089534", "filename": "gcc/testsuite/g++.dg/cpp0x/variadic-alias6.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc50d9a252c89c1bac78192bd0884ff23f2bf48b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic-alias6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc50d9a252c89c1bac78192bd0884ff23f2bf48b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic-alias6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic-alias6.C?ref=fc50d9a252c89c1bac78192bd0884ff23f2bf48b", "patch": "@@ -0,0 +1,20 @@\n+// PR c++/105003\n+// { dg-do compile { target c++11 } }\n+\n+template <class T> struct A;\n+template <class T, class U> struct B { };\n+template <class... Ts> struct C { };\n+\n+// Fn is not complex, since T is used outside the pack expansion, so the two\n+// partial specializations are equivalent.\n+template <class T, class... Ts> using Fn = T(Ts...);\n+template <class T, class... Ts> struct A<Fn<T,Ts...>*> { };\n+template <class T, class... Ts> struct A<T(*)(Ts...)> { }; // { dg-error \"redefinition\" }\n+\n+// CB is complex, since T is only used in the pack expansion, so the two\n+// partial specializations are functionally equivalent but not equivalent.\n+template <class T, class ...Ts> using CB = C<B<T,Ts>...>;\n+template <class T, class ...Ts> struct A<CB<T,Ts...>*> { };\n+template <class T, class ...Ts> struct A<C<B<T,Ts>...>*> { }; // IFNDR\n+A<C<B<int,int>>*> a;\t\t// { dg-error \"ambiguous\" }\n+// { dg-prune-output \"incomplete\" }"}, {"sha": "41a432a8e4103b31098bdb05479acb5b55377bbf", "filename": "gcc/testsuite/g++.dg/cpp0x/variadic-alias7.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc50d9a252c89c1bac78192bd0884ff23f2bf48b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic-alias7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc50d9a252c89c1bac78192bd0884ff23f2bf48b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic-alias7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic-alias7.C?ref=fc50d9a252c89c1bac78192bd0884ff23f2bf48b", "patch": "@@ -0,0 +1,16 @@\n+// PR c++/102869\n+// { dg-do compile { target c++11 } }\n+\n+template<int...> struct integer_sequence;\n+\n+template<int _Num>\n+using make_index_sequence = integer_sequence<__integer_pack(_Num)...>;\n+\n+template<class...> struct Tuple;\n+\n+template<int... Is> using tuple_t = Tuple<make_index_sequence<Is>...>;\n+\n+template<int... Is>\n+void f() {\n+  tuple_t<Is...> t;\n+}"}]}