{"sha": "70866e3d4aa272fecea2aceadc2847ad94301a17", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzA4NjZlM2Q0YWEyNzJmZWNlYTJhY2VhZGMyODQ3YWQ5NDMwMWExNw==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2016-07-22T00:12:28Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2016-07-22T00:12:28Z"}, "message": "vec-extract.h: New files to check the vec_extract built-in functions for all vector types...\n\n2016-07-21  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* gcc.target/powerpc/vec-extract.h: New files to check the\n\tvec_extract built-in functions for all vector types, testing\n\taccessing each element, both with constant and variable element\n\tnumbers.\n\t* gcc.target/powerpc/vec-extract-v16qi.c: Likewise.\n\t* gcc.target/powerpc/vec-extract-v16qiu.c: Likewise.\n\t* gcc.target/powerpc/vec-extract-v2df.c: Likewise.\n\t* gcc.target/powerpc/vec-extract-v2di.c: Likewise.\n\t* gcc.target/powerpc/vec-extract-v4sf.c: Likewise.\n\t* gcc.target/powerpc/vec-extract-v4si.c: Likewise.\n\t* gcc.target/powerpc/vec-extract-v4siu.c: Likewise.\n\t* gcc.target/powerpc/vec-extract-v8hi.c: Likewise.\n\t* gcc.target/powerpc/vec-extract-v8hiu.c: Likewise.\n\nFrom-SVN: r238613", "tree": {"sha": "d7655a1c542de722103ee61d0af314c1cb76ac96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d7655a1c542de722103ee61d0af314c1cb76ac96"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/70866e3d4aa272fecea2aceadc2847ad94301a17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70866e3d4aa272fecea2aceadc2847ad94301a17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70866e3d4aa272fecea2aceadc2847ad94301a17", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70866e3d4aa272fecea2aceadc2847ad94301a17/comments", "author": null, "committer": null, "parents": [{"sha": "8b649cd3ba1c5799f682455aaa77587374be1524", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b649cd3ba1c5799f682455aaa77587374be1524", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b649cd3ba1c5799f682455aaa77587374be1524"}], "stats": {"total": 1224, "additions": 1224, "deletions": 0}, "files": [{"sha": "0a5a0329bcfb3437666e6d12e0d07f61cc2c8d7b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70866e3d4aa272fecea2aceadc2847ad94301a17/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70866e3d4aa272fecea2aceadc2847ad94301a17/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=70866e3d4aa272fecea2aceadc2847ad94301a17", "patch": "@@ -1,3 +1,19 @@\n+2016-07-21  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* gcc.target/powerpc/vec-extract.h: New files to check the\n+\tvec_extract built-in functions for all vector types, testing\n+\taccessing each element, both with constant and variable element\n+\tnumbers.\n+\t* gcc.target/powerpc/vec-extract-v16qi.c: Likewise.\n+\t* gcc.target/powerpc/vec-extract-v16qiu.c: Likewise.\n+\t* gcc.target/powerpc/vec-extract-v2df.c: Likewise.\n+\t* gcc.target/powerpc/vec-extract-v2di.c: Likewise.\n+\t* gcc.target/powerpc/vec-extract-v4sf.c: Likewise.\n+\t* gcc.target/powerpc/vec-extract-v4si.c: Likewise.\n+\t* gcc.target/powerpc/vec-extract-v4siu.c: Likewise.\n+\t* gcc.target/powerpc/vec-extract-v8hi.c: Likewise.\n+\t* gcc.target/powerpc/vec-extract-v8hiu.c: Likewise.\n+\n 2016-07-21  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/71728"}, {"sha": "a28cb2f986a8c437295f605213d329defd1fcfa8", "filename": "gcc/testsuite/gcc.target/powerpc/vec-extract-v16qi.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70866e3d4aa272fecea2aceadc2847ad94301a17/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-v16qi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70866e3d4aa272fecea2aceadc2847ad94301a17/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-v16qi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-v16qi.c?ref=70866e3d4aa272fecea2aceadc2847ad94301a17", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do run { target { powerpc*-*-linux* } } } */\n+/* { dg-require-effective-target vsx_hw } */\n+/* { dg-options \"-O2 -mvsx\" } */\n+\n+#define TYPE signed char\n+#define ELEMENTS 16\n+#define INITIAL \\\n+  {  10,  -20,  30,  -40, 50, -60, 70, -80, \\\n+     90, -100, 110, -120, 30, -40, 50, -60 }\n+\n+#include \"vec-extract.h\""}, {"sha": "431e6fc7fa75bd46b28f9a803ecfbc5be2fd800c", "filename": "gcc/testsuite/gcc.target/powerpc/vec-extract-v16qiu.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70866e3d4aa272fecea2aceadc2847ad94301a17/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-v16qiu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70866e3d4aa272fecea2aceadc2847ad94301a17/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-v16qiu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-v16qiu.c?ref=70866e3d4aa272fecea2aceadc2847ad94301a17", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do run { target { powerpc*-*-linux* } } } */\n+/* { dg-require-effective-target vsx_hw } */\n+/* { dg-options \"-O2 -mvsx\" } */\n+\n+#define TYPE unsigned char\n+#define ELEMENTS 16\n+#define INITIAL \\\n+  {  1, 2, 3, 4, 5, 6, 7, 8, 240, 241, 242, 243, 244, 245, 246, 247 }\n+\n+#include \"vec-extract.h\""}, {"sha": "a8b255cc55637f9069ee1174e1ba6fdec1368c60", "filename": "gcc/testsuite/gcc.target/powerpc/vec-extract-v2df.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70866e3d4aa272fecea2aceadc2847ad94301a17/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-v2df.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70866e3d4aa272fecea2aceadc2847ad94301a17/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-v2df.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-v2df.c?ref=70866e3d4aa272fecea2aceadc2847ad94301a17", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do run { target { powerpc*-*-linux* } } } */\n+/* { dg-require-effective-target vsx_hw } */\n+/* { dg-options \"-O2 -mvsx\" } */\n+\n+#define TYPE double\n+#define ELEMENTS 2\n+#define INITIAL { 10.0, -20.0 }\n+\n+#include \"vec-extract.h\""}, {"sha": "1e6f6661fe7b35f1e5a2917f56782a434bfc901a", "filename": "gcc/testsuite/gcc.target/powerpc/vec-extract-v2di.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70866e3d4aa272fecea2aceadc2847ad94301a17/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-v2di.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70866e3d4aa272fecea2aceadc2847ad94301a17/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-v2di.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-v2di.c?ref=70866e3d4aa272fecea2aceadc2847ad94301a17", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do run { target { powerpc*-*-linux* && lp64 } } } */\n+/* { dg-require-effective-target vsx_hw } */\n+/* { dg-options \"-O2 -mvsx\" } */\n+\n+#define TYPE long\n+#define ELEMENTS 2\n+#define INITIAL { 10, -20 }\n+\n+#include \"vec-extract.h\""}, {"sha": "93e8b10680ab82fbba9eb98cd1c4703713dfd7e0", "filename": "gcc/testsuite/gcc.target/powerpc/vec-extract-v4sf.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70866e3d4aa272fecea2aceadc2847ad94301a17/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-v4sf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70866e3d4aa272fecea2aceadc2847ad94301a17/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-v4sf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-v4sf.c?ref=70866e3d4aa272fecea2aceadc2847ad94301a17", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do run { target { powerpc*-*-linux* } } } */\n+/* { dg-require-effective-target vsx_hw } */\n+/* { dg-options \"-O2 -mvsx\" } */\n+\n+#define TYPE float\n+#define ELEMENTS 4\n+#define INITIAL { 10.0f, -20.0f, 30.0f, -40.0f }\n+\n+#include \"vec-extract.h\""}, {"sha": "cf38423f6833417160828e59ad032f50f265de85", "filename": "gcc/testsuite/gcc.target/powerpc/vec-extract-v4si.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70866e3d4aa272fecea2aceadc2847ad94301a17/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-v4si.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70866e3d4aa272fecea2aceadc2847ad94301a17/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-v4si.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-v4si.c?ref=70866e3d4aa272fecea2aceadc2847ad94301a17", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do run { target { powerpc*-*-linux* } } } */\n+/* { dg-require-effective-target vsx_hw } */\n+/* { dg-options \"-O2 -mvsx\" } */\n+\n+#define TYPE int\n+#define ELEMENTS 4\n+#define INITIAL { 10, -20, 30, -40 }\n+\n+#include \"vec-extract.h\""}, {"sha": "1b85f901c9cff27e699f45d0bd74fbb7fb5edd19", "filename": "gcc/testsuite/gcc.target/powerpc/vec-extract-v4siu.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70866e3d4aa272fecea2aceadc2847ad94301a17/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-v4siu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70866e3d4aa272fecea2aceadc2847ad94301a17/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-v4siu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-v4siu.c?ref=70866e3d4aa272fecea2aceadc2847ad94301a17", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do run { target { powerpc*-*-linux* } } } */\n+/* { dg-require-effective-target vsx_hw } */\n+/* { dg-options \"-O2 -mvsx\" } */\n+\n+#define TYPE unsigned int\n+#define ELEMENTS 4\n+#define INITIAL { 1, 2, 0xff03, 0xff04 }\n+\n+#include \"vec-extract.h\""}, {"sha": "ba1e338d0ba03048cfa184604bcaccf2513b4353", "filename": "gcc/testsuite/gcc.target/powerpc/vec-extract-v8hi.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70866e3d4aa272fecea2aceadc2847ad94301a17/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-v8hi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70866e3d4aa272fecea2aceadc2847ad94301a17/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-v8hi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-v8hi.c?ref=70866e3d4aa272fecea2aceadc2847ad94301a17", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do run { target { powerpc*-*-linux* } } } */\n+/* { dg-require-effective-target vsx_hw } */\n+/* { dg-options \"-O2 -mvsx\" } */\n+\n+#define TYPE short\n+#define ELEMENTS 8\n+#define INITIAL { 10, -20, 30, -40, 50, -60, 70, 80 }\n+\n+#include \"vec-extract.h\""}, {"sha": "82581e1581445aae589cf926f754b23125d608cd", "filename": "gcc/testsuite/gcc.target/powerpc/vec-extract-v8hiu.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70866e3d4aa272fecea2aceadc2847ad94301a17/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-v8hiu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70866e3d4aa272fecea2aceadc2847ad94301a17/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-v8hiu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-v8hiu.c?ref=70866e3d4aa272fecea2aceadc2847ad94301a17", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do run { target { powerpc*-*-linux* } } } */\n+/* { dg-require-effective-target vsx_hw } */\n+/* { dg-options \"-O2 -mvsx\" } */\n+\n+#define TYPE unsigned short\n+#define ELEMENTS 8\n+#define INITIAL { 1, 2, 3, 4, 0xf1, 0xf2, 0xf3, 0xf4 }\n+\n+#include \"vec-extract.h\""}, {"sha": "fcb4a403d6195dc1068030e1fdc117f21e117db3", "filename": "gcc/testsuite/gcc.target/powerpc/vec-extract.h", "status": "added", "additions": 1124, "deletions": 0, "changes": 1124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70866e3d4aa272fecea2aceadc2847ad94301a17/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70866e3d4aa272fecea2aceadc2847ad94301a17/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract.h?ref=70866e3d4aa272fecea2aceadc2847ad94301a17", "patch": "@@ -0,0 +1,1124 @@\n+#include <stdlib.h>\n+#include <stddef.h>\n+#include <altivec.h>\n+\n+static void\n+check (TYPE expected, TYPE got)\n+{\n+  if (expected != got)\n+    abort ();\n+}\n+\n+static vector TYPE  deoptimize     (vector TYPE)\t__attribute__((__noinline__));\n+static vector TYPE *deoptimize_ptr (vector TYPE *)\t__attribute__((__noinline__));\n+\n+static vector TYPE\n+deoptimize (vector TYPE a)\n+{\n+  __asm__ (\" # %x0\" : \"+wa\" (a));\n+  return a;\n+}\n+\n+static vector TYPE *\n+deoptimize_ptr (vector TYPE *p)\n+{\n+  __asm__ (\" # %0\" : \"+r\" (p));\n+  return p;\n+}\n+\n+\f\n+/* Tests for the normal case of vec_extract where the vector is in a register\n+   and returning the result in a register as a return value.  */\n+TYPE\n+get_auto_n (vector TYPE a, ssize_t n)\n+{\n+  return vec_extract (a, n);\n+}\n+\n+TYPE\n+get_auto_0 (vector TYPE a)\n+{\n+  return vec_extract (a, 0);\n+}\n+\n+TYPE\n+get_auto_1 (vector TYPE a)\n+{\n+  return vec_extract (a, 1);\n+}\n+\n+#if ELEMENTS >= 4\n+TYPE\n+get_auto_2 (vector TYPE a)\n+{\n+  return vec_extract (a, 2);\n+}\n+\n+TYPE\n+get_auto_3 (vector TYPE a)\n+{\n+  return vec_extract (a, 3);\n+}\n+\n+#if ELEMENTS >= 8\n+TYPE\n+get_auto_4 (vector TYPE a)\n+{\n+  return vec_extract (a, 4);\n+}\n+\n+TYPE\n+get_auto_5 (vector TYPE a)\n+{\n+  return vec_extract (a, 5);\n+}\n+\n+TYPE\n+get_auto_6 (vector TYPE a)\n+{\n+  return vec_extract (a, 6);\n+}\n+\n+TYPE\n+get_auto_7 (vector TYPE a)\n+{\n+  return vec_extract (a, 7);\n+}\n+\n+#if ELEMENTS >= 16\n+TYPE\n+get_auto_8 (vector TYPE a)\n+{\n+  return vec_extract (a, 8);\n+}\n+\n+TYPE\n+get_auto_9 (vector TYPE a)\n+{\n+  return vec_extract (a, 9);\n+}\n+\n+TYPE\n+get_auto_10 (vector TYPE a)\n+{\n+  return vec_extract (a, 10);\n+}\n+\n+TYPE\n+get_auto_11 (vector TYPE a)\n+{\n+  return vec_extract (a, 11);\n+}\n+\n+TYPE\n+get_auto_12 (vector TYPE a)\n+{\n+  return vec_extract (a, 12);\n+}\n+\n+TYPE\n+get_auto_13 (vector TYPE a)\n+{\n+  return vec_extract (a, 13);\n+}\n+\n+TYPE\n+get_auto_14 (vector TYPE a)\n+{\n+  return vec_extract (a, 14);\n+}\n+\n+TYPE\n+get_auto_15 (vector TYPE a)\n+{\n+  return vec_extract (a, 15);\n+}\n+\n+#endif\n+#endif\n+#endif\n+\n+typedef TYPE (*auto_func_type) (vector TYPE);\n+\n+static auto_func_type get_auto_const[] = {\n+  get_auto_0,\n+  get_auto_1,\n+#if ELEMENTS >= 4\n+  get_auto_2,\n+  get_auto_3,\n+#if ELEMENTS >= 8\n+  get_auto_4,\n+  get_auto_5,\n+  get_auto_6,\n+  get_auto_7,\n+#if ELEMENTS >= 16\n+  get_auto_8,\n+  get_auto_9,\n+  get_auto_10,\n+  get_auto_11,\n+  get_auto_12,\n+  get_auto_13,\n+  get_auto_14,\n+  get_auto_15,\n+#endif\n+#endif\n+#endif\n+};\n+\n+extern void do_auto (vector TYPE a) __attribute__((__noinline__));\n+\n+void\n+do_auto (vector TYPE a)\n+{\n+  size_t i;\n+\n+  for (i = 0; i < sizeof (get_auto_const) / sizeof (get_auto_const[0]); i++)\n+    check (get_auto_n (a, i),  (get_auto_const[i]) (a));\n+}\n+\n+\f\n+/* Tests for vec_extract of a vector in a register, but storing the result\n+   (there is an optimization where an element can be stored to memory if it is\n+   in the right position to use a scalar store).  */\n+\n+void\n+get_store_n (TYPE *p, vector TYPE a, ssize_t n)\n+{\n+  *p = vec_extract (a, n);\n+}\n+\n+void\n+get_store_0 (TYPE *p, vector TYPE a)\n+{\n+  *p = vec_extract (a, 0);\n+}\n+\n+void\n+get_store_1 (TYPE *p, vector TYPE a)\n+{\n+  *p = vec_extract (a, 1);\n+}\n+\n+#if ELEMENTS >= 4\n+void\n+get_store_2 (TYPE *p, vector TYPE a)\n+{\n+  *p = vec_extract (a, 2);\n+}\n+\n+void\n+get_store_3 (TYPE *p, vector TYPE a)\n+{\n+  *p = vec_extract (a, 3);\n+}\n+\n+#if ELEMENTS >= 8\n+void\n+get_store_4 (TYPE *p, vector TYPE a)\n+{\n+  *p = vec_extract (a, 4);\n+}\n+\n+void\n+get_store_5 (TYPE *p, vector TYPE a)\n+{\n+  *p = vec_extract (a, 5);\n+}\n+\n+void\n+get_store_6 (TYPE *p, vector TYPE a)\n+{\n+  *p = vec_extract (a, 6);\n+}\n+\n+void\n+get_store_7 (TYPE *p, vector TYPE a)\n+{\n+  *p = vec_extract (a, 7);\n+}\n+\n+#if ELEMENTS >= 16\n+void\n+get_store_8 (TYPE *p, vector TYPE a)\n+{\n+  *p = vec_extract (a, 8);\n+}\n+\n+void\n+get_store_9 (TYPE *p, vector TYPE a)\n+{\n+  *p = vec_extract (a, 9);\n+}\n+\n+void\n+get_store_10 (TYPE *p, vector TYPE a)\n+{\n+  *p = vec_extract (a, 10);\n+}\n+\n+void\n+get_store_11 (TYPE *p, vector TYPE a)\n+{\n+  *p = vec_extract (a, 11);\n+}\n+\n+void\n+get_store_12 (TYPE *p, vector TYPE a)\n+{\n+  *p = vec_extract (a, 12);\n+}\n+\n+void\n+get_store_13 (TYPE *p, vector TYPE a)\n+{\n+  *p = vec_extract (a, 13);\n+}\n+\n+void\n+get_store_14 (TYPE *p, vector TYPE a)\n+{\n+  *p = vec_extract (a, 14);\n+}\n+\n+void\n+get_store_15 (TYPE *p, vector TYPE a)\n+{\n+  *p = vec_extract (a, 15);\n+}\n+\n+#endif\n+#endif\n+#endif\n+\n+typedef void (*store_func_type) (TYPE *, vector TYPE);\n+\n+static store_func_type get_store_const[] = {\n+  get_store_0,\n+  get_store_1,\n+#if ELEMENTS >= 4\n+  get_store_2,\n+  get_store_3,\n+#if ELEMENTS >= 8\n+  get_store_4,\n+  get_store_5,\n+  get_store_6,\n+  get_store_7,\n+#if ELEMENTS >= 16\n+  get_store_8,\n+  get_store_9,\n+  get_store_10,\n+  get_store_11,\n+  get_store_12,\n+  get_store_13,\n+  get_store_14,\n+  get_store_15,\n+#endif\n+#endif\n+#endif\n+};\n+\n+extern void do_store (vector TYPE a) __attribute__((__noinline__));\n+\n+void\n+do_store (vector TYPE a)\n+{\n+  size_t i;\n+  TYPE result_var, result_const;\n+\n+  for (i = 0; i < sizeof (get_store_const) / sizeof (get_store_const[0]); i++)\n+    {\n+      get_store_n (&result_var, a, i);\n+      (get_store_const[i]) (&result_const, a);\n+      check (result_var, result_const);\n+    }\n+}\n+\n+\f\n+/* Tests for vec_extract where the vector comes from memory (the compiler can\n+   optimize this by doing a scalar load without having to load the whole\n+   vector).  */\n+TYPE\n+get_pointer_n (vector TYPE *p, ssize_t n)\n+{\n+  return vec_extract (*p, n);\n+}\n+\n+TYPE\n+get_pointer_0 (vector TYPE *p)\n+{\n+  return vec_extract (*p, 0);\n+}\n+\n+TYPE\n+get_pointer_1 (vector TYPE *p)\n+{\n+  return vec_extract (*p, 1);\n+}\n+\n+#if ELEMENTS >= 4\n+TYPE\n+get_pointer_2 (vector TYPE *p)\n+{\n+  return vec_extract (*p, 2);\n+}\n+\n+TYPE\n+get_pointer_3 (vector TYPE *p)\n+{\n+  return vec_extract (*p, 3);\n+}\n+\n+#if ELEMENTS >= 8\n+TYPE\n+get_pointer_4 (vector TYPE *p)\n+{\n+  return vec_extract (*p, 4);\n+}\n+\n+static TYPE\n+get_pointer_5 (vector TYPE *p)\n+{\n+  return vec_extract (*p, 5);\n+}\n+\n+TYPE\n+get_pointer_6 (vector TYPE *p)\n+{\n+  return vec_extract (*p, 6);\n+}\n+\n+TYPE\n+get_pointer_7 (vector TYPE *p)\n+{\n+  return vec_extract (*p, 7);\n+}\n+\n+#if ELEMENTS >= 16\n+TYPE\n+get_pointer_8 (vector TYPE *p)\n+{\n+  return vec_extract (*p, 8);\n+}\n+\n+TYPE\n+get_pointer_9 (vector TYPE *p)\n+{\n+  return vec_extract (*p, 9);\n+}\n+\n+TYPE\n+get_pointer_10 (vector TYPE *p)\n+{\n+  return vec_extract (*p, 10);\n+}\n+\n+TYPE\n+get_pointer_11 (vector TYPE *p)\n+{\n+  return vec_extract (*p, 11);\n+}\n+\n+TYPE\n+get_pointer_12 (vector TYPE *p)\n+{\n+  return vec_extract (*p, 12);\n+}\n+\n+TYPE\n+get_pointer_13 (vector TYPE *p)\n+{\n+  return vec_extract (*p, 13);\n+}\n+\n+TYPE\n+get_pointer_14 (vector TYPE *p)\n+{\n+  return vec_extract (*p, 14);\n+}\n+\n+TYPE\n+get_pointer_15 (vector TYPE *p)\n+{\n+  return vec_extract (*p, 15);\n+}\n+\n+#endif\n+#endif\n+#endif\n+\n+typedef TYPE (*pointer_func_type) (vector TYPE *);\n+\n+static pointer_func_type get_pointer_const[] = {\n+  get_pointer_0,\n+  get_pointer_1,\n+#if ELEMENTS >= 4\n+  get_pointer_2,\n+  get_pointer_3,\n+#if ELEMENTS >= 8\n+  get_pointer_4,\n+  get_pointer_5,\n+  get_pointer_6,\n+  get_pointer_7,\n+#if ELEMENTS >= 16\n+  get_pointer_8,\n+  get_pointer_9,\n+  get_pointer_10,\n+  get_pointer_11,\n+  get_pointer_12,\n+  get_pointer_13,\n+  get_pointer_14,\n+  get_pointer_15,\n+#endif\n+#endif\n+#endif\n+};\n+\n+extern void do_pointer (vector TYPE *p) __attribute__((__noinline__));\n+\n+void\n+do_pointer (vector TYPE *p)\n+{\n+  size_t i;\n+\n+  for (i = 0; i < sizeof (get_pointer_const) / sizeof (get_pointer_const[0]); i++)\n+    check (get_pointer_n (p, i),  (get_pointer_const[i]) (p));\n+}\n+\n+\f\n+/* Test for vec_extract where the vector comes from an indexed memory\n+   operation.  This is to make sure that if the compiler optimizes vec_extract\n+   from memory to be a scalar load, the address is correctly adjusted.  */\n+\n+TYPE\n+get_indexed_n (vector TYPE *p, size_t x, ssize_t n)\n+{\n+  return vec_extract (p[x], n);\n+}\n+\n+TYPE\n+get_indexed_0 (vector TYPE *p, size_t x)\n+{\n+  return vec_extract (p[x], 0);\n+}\n+\n+TYPE\n+get_indexed_1 (vector TYPE *p, size_t x)\n+{\n+  return vec_extract (p[x], 1);\n+}\n+\n+#if ELEMENTS >= 4\n+TYPE\n+get_indexed_2 (vector TYPE *p, size_t x)\n+{\n+  return vec_extract (p[x], 2);\n+}\n+\n+TYPE\n+get_indexed_3 (vector TYPE *p, size_t x)\n+{\n+  return vec_extract (p[x], 3);\n+}\n+\n+#if ELEMENTS >= 8\n+TYPE\n+get_indexed_4 (vector TYPE *p, size_t x)\n+{\n+  return vec_extract (p[x], 4);\n+}\n+\n+static TYPE\n+get_indexed_5 (vector TYPE *p, size_t x)\n+{\n+  return vec_extract (p[x], 5);\n+}\n+\n+TYPE\n+get_indexed_6 (vector TYPE *p, size_t x)\n+{\n+  return vec_extract (p[x], 6);\n+}\n+\n+TYPE\n+get_indexed_7 (vector TYPE *p, size_t x)\n+{\n+  return vec_extract (p[x], 7);\n+}\n+\n+#if ELEMENTS >= 16\n+TYPE\n+get_indexed_8 (vector TYPE *p, size_t x)\n+{\n+  return vec_extract (p[x], 8);\n+}\n+\n+TYPE\n+get_indexed_9 (vector TYPE *p, size_t x)\n+{\n+  return vec_extract (p[x], 9);\n+}\n+\n+TYPE\n+get_indexed_10 (vector TYPE *p, size_t x)\n+{\n+  return vec_extract (p[x], 10);\n+}\n+\n+TYPE\n+get_indexed_11 (vector TYPE *p, size_t x)\n+{\n+  return vec_extract (p[x], 11);\n+}\n+\n+TYPE\n+get_indexed_12 (vector TYPE *p, size_t x)\n+{\n+  return vec_extract (p[x], 12);\n+}\n+\n+TYPE\n+get_indexed_13 (vector TYPE *p, size_t x)\n+{\n+  return vec_extract (p[x], 13);\n+}\n+\n+TYPE\n+get_indexed_14 (vector TYPE *p, size_t x)\n+{\n+  return vec_extract (p[x], 14);\n+}\n+\n+TYPE\n+get_indexed_15 (vector TYPE *p, size_t x)\n+{\n+  return vec_extract (p[x], 15);\n+}\n+\n+#endif\n+#endif\n+#endif\n+\n+typedef TYPE (*indexed_func_type) (vector TYPE *, size_t);\n+\n+static indexed_func_type get_indexed_const[] = {\n+  get_indexed_0,\n+  get_indexed_1,\n+#if ELEMENTS >= 4\n+  get_indexed_2,\n+  get_indexed_3,\n+#if ELEMENTS >= 8\n+  get_indexed_4,\n+  get_indexed_5,\n+  get_indexed_6,\n+  get_indexed_7,\n+#if ELEMENTS >= 16\n+  get_indexed_8,\n+  get_indexed_9,\n+  get_indexed_10,\n+  get_indexed_11,\n+  get_indexed_12,\n+  get_indexed_13,\n+  get_indexed_14,\n+  get_indexed_15,\n+#endif\n+#endif\n+#endif\n+};\n+\n+extern void do_indexed (vector TYPE *p, size_t x) __attribute__((__noinline__));\n+\n+void\n+do_indexed (vector TYPE *p, size_t x)\n+{\n+  size_t i;\n+\n+  for (i = 0; i < sizeof (get_indexed_const) / sizeof (get_indexed_const[0]); i++)\n+    check (get_indexed_n (p, x, i),  (get_indexed_const[i]) (p, x));\n+}\n+\n+\f\n+/* Test for vec_extract where the vector comes from memory using an address\n+   with a pointer and a constant offset.  This will occur in ISA 3.0 which\n+   added d-form memory addressing for vectors.  */\n+\n+TYPE\n+get_ptr_plus1_n (vector TYPE *p, ssize_t n)\n+{\n+  return vec_extract (p[1], n);\n+}\n+\n+TYPE\n+get_ptr_plus1_0 (vector TYPE *p)\n+{\n+  return vec_extract (p[1], 0);\n+}\n+\n+TYPE\n+get_ptr_plus1_1 (vector TYPE *p)\n+{\n+  return vec_extract (p[1], 1);\n+}\n+\n+#if ELEMENTS >= 4\n+TYPE\n+get_ptr_plus1_2 (vector TYPE *p)\n+{\n+  return vec_extract (p[1], 2);\n+}\n+\n+TYPE\n+get_ptr_plus1_3 (vector TYPE *p)\n+{\n+  return vec_extract (p[1], 3);\n+}\n+\n+#if ELEMENTS >= 8\n+TYPE\n+get_ptr_plus1_4 (vector TYPE *p)\n+{\n+  return vec_extract (p[1], 4);\n+}\n+\n+static TYPE\n+get_ptr_plus1_5 (vector TYPE *p)\n+{\n+  return vec_extract (p[1], 5);\n+}\n+\n+TYPE\n+get_ptr_plus1_6 (vector TYPE *p)\n+{\n+  return vec_extract (p[1], 6);\n+}\n+\n+TYPE\n+get_ptr_plus1_7 (vector TYPE *p)\n+{\n+  return vec_extract (p[1], 7);\n+}\n+\n+#if ELEMENTS >= 16\n+TYPE\n+get_ptr_plus1_8 (vector TYPE *p)\n+{\n+  return vec_extract (p[1], 8);\n+}\n+\n+TYPE\n+get_ptr_plus1_9 (vector TYPE *p)\n+{\n+  return vec_extract (p[1], 9);\n+}\n+\n+TYPE\n+get_ptr_plus1_10 (vector TYPE *p)\n+{\n+  return vec_extract (p[1], 10);\n+}\n+\n+TYPE\n+get_ptr_plus1_11 (vector TYPE *p)\n+{\n+  return vec_extract (p[1], 11);\n+}\n+\n+TYPE\n+get_ptr_plus1_12 (vector TYPE *p)\n+{\n+  return vec_extract (p[1], 12);\n+}\n+\n+TYPE\n+get_ptr_plus1_13 (vector TYPE *p)\n+{\n+  return vec_extract (p[1], 13);\n+}\n+\n+TYPE\n+get_ptr_plus1_14 (vector TYPE *p)\n+{\n+  return vec_extract (p[1], 14);\n+}\n+\n+TYPE\n+get_ptr_plus1_15 (vector TYPE *p)\n+{\n+  return vec_extract (p[1], 15);\n+}\n+\n+#endif\n+#endif\n+#endif\n+\n+typedef TYPE (*pointer_func_type) (vector TYPE *);\n+\n+static pointer_func_type get_ptr_plus1_const[] = {\n+  get_ptr_plus1_0,\n+  get_ptr_plus1_1,\n+#if ELEMENTS >= 4\n+  get_ptr_plus1_2,\n+  get_ptr_plus1_3,\n+#if ELEMENTS >= 8\n+  get_ptr_plus1_4,\n+  get_ptr_plus1_5,\n+  get_ptr_plus1_6,\n+  get_ptr_plus1_7,\n+#if ELEMENTS >= 16\n+  get_ptr_plus1_8,\n+  get_ptr_plus1_9,\n+  get_ptr_plus1_10,\n+  get_ptr_plus1_11,\n+  get_ptr_plus1_12,\n+  get_ptr_plus1_13,\n+  get_ptr_plus1_14,\n+  get_ptr_plus1_15,\n+#endif\n+#endif\n+#endif\n+};\n+\n+extern void do_ptr_plus1 (vector TYPE *p) __attribute__((__noinline__));\n+\n+void\n+do_ptr_plus1 (vector TYPE *p)\n+{\n+  size_t i;\n+\n+  for (i = 0; i < sizeof (get_ptr_plus1_const) / sizeof (get_ptr_plus1_const[0]); i++)\n+    check (get_ptr_plus1_n (p, i),  (get_ptr_plus1_const[i]) (p));\n+}\n+\n+\f\n+/* Test for vec_extract where the vector comes from a static variable.  */\n+\n+static vector TYPE s;\n+\n+TYPE\n+get_static_n (ssize_t n)\n+{\n+  return vec_extract (s, n);\n+}\n+\n+TYPE\n+get_static_0 (void)\n+{\n+  return vec_extract (s, 0);\n+}\n+\n+TYPE\n+get_static_1 (void)\n+{\n+  return vec_extract (s, 1);\n+}\n+\n+#if ELEMENTS >= 4\n+TYPE\n+get_static_2 (void)\n+{\n+  return vec_extract (s, 2);\n+}\n+\n+TYPE\n+get_static_3 (void)\n+{\n+  return vec_extract (s, 3);\n+}\n+\n+#if ELEMENTS >= 8\n+TYPE\n+get_static_4 (void)\n+{\n+  return vec_extract (s, 4);\n+}\n+\n+TYPE\n+get_static_5 (void)\n+{\n+  return vec_extract (s, 5);\n+}\n+\n+TYPE\n+get_static_6 (void)\n+{\n+  return vec_extract (s, 6);\n+}\n+\n+TYPE\n+get_static_7 (void)\n+{\n+  return vec_extract (s, 7);\n+}\n+\n+#if ELEMENTS >= 16\n+TYPE\n+get_static_8 (void)\n+{\n+  return vec_extract (s, 8);\n+}\n+\n+TYPE\n+get_static_9 (void)\n+{\n+  return vec_extract (s, 9);\n+}\n+\n+TYPE\n+get_static_10 (void)\n+{\n+  return vec_extract (s, 10);\n+}\n+\n+TYPE\n+get_static_11 (void)\n+{\n+  return vec_extract (s, 11);\n+}\n+\n+TYPE\n+get_static_12 (void)\n+{\n+  return vec_extract (s, 12);\n+}\n+\n+TYPE\n+get_static_13 (void)\n+{\n+  return vec_extract (s, 13);\n+}\n+\n+TYPE\n+get_static_14 (void)\n+{\n+  return vec_extract (s, 14);\n+}\n+\n+TYPE\n+get_static_15 (void)\n+{\n+  return vec_extract (s, 15);\n+}\n+\n+#endif\n+#endif\n+#endif\n+\n+typedef TYPE (*static_func_type) (void);\n+\n+static static_func_type get_static_const[] = {\n+  get_static_0,\n+  get_static_1,\n+#if ELEMENTS >= 4\n+  get_static_2,\n+  get_static_3,\n+#if ELEMENTS >= 8\n+  get_static_4,\n+  get_static_5,\n+  get_static_6,\n+  get_static_7,\n+#if ELEMENTS >= 16\n+  get_static_8,\n+  get_static_9,\n+  get_static_10,\n+  get_static_11,\n+  get_static_12,\n+  get_static_13,\n+  get_static_14,\n+  get_static_15,\n+#endif\n+#endif\n+#endif\n+};\n+\n+extern void do_static (void) __attribute__((__noinline__));\n+\n+void\n+do_static (void)\n+{\n+  size_t i;\n+\n+  for (i = 0; i < sizeof (get_static_const) / sizeof (get_static_const[0]); i++)\n+    check (get_static_n (i),  (get_static_const[i]) ());\n+}\n+\n+\f\n+/* Test for vec_extract where the vector is in a global variable.  */\n+\n+vector TYPE g;\n+\n+TYPE\n+get_global_n (ssize_t n)\n+{\n+  return vec_extract (g, n);\n+}\n+\n+TYPE\n+get_global_0 (void)\n+{\n+  return vec_extract (g, 0);\n+}\n+\n+TYPE\n+get_global_1 (void)\n+{\n+  return vec_extract (g, 1);\n+}\n+\n+#if ELEMENTS >= 4\n+TYPE\n+get_global_2 (void)\n+{\n+  return vec_extract (g, 2);\n+}\n+\n+TYPE\n+get_global_3 (void)\n+{\n+  return vec_extract (g, 3);\n+}\n+\n+#if ELEMENTS >= 8\n+TYPE\n+get_global_4 (void)\n+{\n+  return vec_extract (g, 4);\n+}\n+\n+TYPE\n+get_global_5 (void)\n+{\n+  return vec_extract (g, 5);\n+}\n+\n+TYPE\n+get_global_6 (void)\n+{\n+  return vec_extract (g, 6);\n+}\n+\n+TYPE\n+get_global_7 (void)\n+{\n+  return vec_extract (g, 7);\n+}\n+\n+#if ELEMENTS >= 16\n+TYPE\n+get_global_8 (void)\n+{\n+  return vec_extract (g, 8);\n+}\n+\n+TYPE\n+get_global_9 (void)\n+{\n+  return vec_extract (g, 9);\n+}\n+\n+TYPE\n+get_global_10 (void)\n+{\n+  return vec_extract (g, 10);\n+}\n+\n+TYPE\n+get_global_11 (void)\n+{\n+  return vec_extract (g, 11);\n+}\n+\n+TYPE\n+get_global_12 (void)\n+{\n+  return vec_extract (g, 12);\n+}\n+\n+TYPE\n+get_global_13 (void)\n+{\n+  return vec_extract (g, 13);\n+}\n+\n+TYPE\n+get_global_14 (void)\n+{\n+  return vec_extract (g, 14);\n+}\n+\n+TYPE\n+get_global_15 (void)\n+{\n+  return vec_extract (g, 15);\n+}\n+\n+#endif\n+#endif\n+#endif\n+\n+typedef TYPE (*global_func_type) (void);\n+\n+static global_func_type get_global_const[] = {\n+  get_global_0,\n+  get_global_1,\n+#if ELEMENTS >= 4\n+  get_global_2,\n+  get_global_3,\n+#if ELEMENTS >= 8\n+  get_global_4,\n+  get_global_5,\n+  get_global_6,\n+  get_global_7,\n+#if ELEMENTS >= 16\n+  get_global_8,\n+  get_global_9,\n+  get_global_10,\n+  get_global_11,\n+  get_global_12,\n+  get_global_13,\n+  get_global_14,\n+  get_global_15,\n+#endif\n+#endif\n+#endif\n+};\n+\n+extern void do_global (void) __attribute__((__noinline__));\n+\n+void\n+do_global (void)\n+{\n+  size_t i;\n+\n+  for (i = 0; i < sizeof (get_global_const) / sizeof (get_global_const[0]); i++)\n+    check (get_global_n (i),  (get_global_const[i]) ());\n+}\n+\n+\f\n+/* Main program to test all of the possibilities.  */\n+\n+int\n+main (void)\n+{\n+  size_t i;\n+  vector TYPE x = INITIAL;\n+  vector TYPE *p, *p2, a, y;\n+  vector TYPE z[2];\n+\n+  a = deoptimize (x);\n+  s = deoptimize (x);\n+  g = deoptimize (x);\n+  y = deoptimize (x);\n+  z[0] = deoptimize (x);\n+  z[1] = deoptimize (x);\n+  p = deoptimize_ptr (&y);\n+  p2 = deoptimize_ptr (&z[0]);\n+\n+  do_auto (a);\n+  do_store (a);\n+  do_pointer (p);\n+  for (i = 0; i < 2; i++)\n+    do_indexed (p2, i);\n+  do_ptr_plus1 (p2);\n+  do_static ();\n+  do_global ();\n+  return 0;\n+}"}]}