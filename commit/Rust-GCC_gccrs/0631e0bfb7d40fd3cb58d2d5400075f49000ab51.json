{"sha": "0631e0bfb7d40fd3cb58d2d5400075f49000ab51", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDYzMWUwYmZiN2Q0MGZkM2NiNThkMmQ1NDAwMDc1ZjQ5MDAwYWI1MQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-06-04T18:04:36Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-06-04T18:04:36Z"}, "message": "rtlanal.c (operand_preference): Fix preference for objects.\n\n\t* rtlanal.c (operand_preference): Fix preference for objects.\n\n\t* gcse.c (handle_avail_expr): Be prepared to handle single_set\n\tparallels.\n\n\t* combine.c (if_then_else_cond): Use simplify_subreg instead\n\tof operand_subword.\n\t* integreate.c (sub_constants): Likewise.\n\n\t* emit-rtl.c (constant_subword): Deprecate; remove most of code\n\tand use simplify_gen_subreg.\n\nMon Jun  4 19:55:23 CEST 2001  Lars Brinkhoff  <lars@nocrew.org>\n\n\t* sibcall.c (skip_copy_to_return_value): recognize the situation\n\twhen the called function's return value is copied into an\n\tintermediate pseudo, and then into the calling functions return\n\tvalue register.\n\nFrom-SVN: r42864", "tree": {"sha": "829c85ccd2ce524faa3bdeb601db3f7f80cc282f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/829c85ccd2ce524faa3bdeb601db3f7f80cc282f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0631e0bfb7d40fd3cb58d2d5400075f49000ab51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0631e0bfb7d40fd3cb58d2d5400075f49000ab51", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0631e0bfb7d40fd3cb58d2d5400075f49000ab51", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0631e0bfb7d40fd3cb58d2d5400075f49000ab51/comments", "author": null, "committer": null, "parents": [{"sha": "5c626f5260d6e2f48bdbd5461b74d11fdd02afe0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c626f5260d6e2f48bdbd5461b74d11fdd02afe0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c626f5260d6e2f48bdbd5461b74d11fdd02afe0"}], "stats": {"total": 220, "additions": 92, "deletions": 128}, "files": [{"sha": "7498981726ca1767251bf1c690c3f31b2e0ce67e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0631e0bfb7d40fd3cb58d2d5400075f49000ab51/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0631e0bfb7d40fd3cb58d2d5400075f49000ab51/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0631e0bfb7d40fd3cb58d2d5400075f49000ab51", "patch": "@@ -1,3 +1,30 @@\n+Mon Jun  4 20:03:05 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* rtlanal.c (operand_preference): Fix preference for objects.\n+\n+Mon Jun  4 20:00:40 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gcse.c (handle_avail_expr): Be prepared to handle single_set\n+\tparallels.\n+\n+Mon Jun  4 19:59:46 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* combine.c (if_then_else_cond): Use simplify_subreg instead\n+\tof operand_subword.\n+\t* integreate.c (sub_constants): Likewise.\n+\n+Mon Jun  4 19:59:12 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\t\n+\t* emit-rtl.c (constant_subword): Deprecate; remove most of code\n+\tand use simplify_gen_subreg.\n+\n+Mon Jun  4 19:55:23 CEST 2001  Lars Brinkhoff  <lars@nocrew.org>\n+\n+\t* sibcall.c (skip_copy_to_return_value): recognize the situation\n+\twhen the called function's return value is copied into an\n+\tintermediate pseudo, and then into the calling functions return\n+\tvalue register.\n+\n Mon Jun  4 16:50:33 CEST 2001  Jan Hubicka  <jh@suse.cz>\n \n \t* simplify_rtx.c (simplify_subreg): Keep subregs on return values,"}, {"sha": "d3c70c31dccc5cb803076cfb18fd7b040f268e45", "filename": "gcc/combine.c", "status": "modified", "additions": 7, "deletions": 20, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0631e0bfb7d40fd3cb58d2d5400075f49000ab51/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0631e0bfb7d40fd3cb58d2d5400075f49000ab51/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=0631e0bfb7d40fd3cb58d2d5400075f49000ab51", "patch": "@@ -7293,29 +7293,16 @@ if_then_else_cond (x, ptrue, pfalse)\n \treturn cond0;\n     }\n \n-  /* If X is a normal SUBREG with both inner and outer modes integral,\n-     we can narrow both the true and false values of the inner expression,\n-     if there is a condition.  */\n-  else if (code == SUBREG && GET_MODE_CLASS (mode) == MODE_INT\n-\t   && GET_MODE_CLASS (GET_MODE (SUBREG_REG (x))) == MODE_INT\n-\t   && GET_MODE_SIZE (mode) <= GET_MODE_SIZE (GET_MODE (SUBREG_REG (x)))\n+  /* If X is a SUBREG, we can narrow both the true and false values\n+     if the inner expression, if there is a condition.  */\n+  else if (code == SUBREG\n \t   && 0 != (cond0 = if_then_else_cond (SUBREG_REG (x),\n \t\t\t\t\t       &true0, &false0)))\n     {\n-      if ((GET_CODE (SUBREG_REG (x)) == REG\n-\t   || GET_CODE (SUBREG_REG (x)) == MEM\n-\t   || CONSTANT_P (SUBREG_REG (x)))\n-\t  && GET_MODE_SIZE (GET_MODE (SUBREG_REG (x))) > UNITS_PER_WORD\n-\t  && (WORDS_BIG_ENDIAN || SUBREG_BYTE (x) >= UNITS_PER_WORD))\n-\t{\n-\t  true0 = operand_subword (true0, SUBREG_BYTE (x) / UNITS_PER_WORD, 0,\n-\t\t\t\t   GET_MODE (SUBREG_REG (x)));\n-\t  false0 = operand_subword (false0, SUBREG_BYTE (x) / UNITS_PER_WORD, 0,\n-\t\t\t\t    GET_MODE (SUBREG_REG (x)));\n-\t}\n-      *ptrue = force_to_mode (true0, mode, ~(HOST_WIDE_INT) 0, NULL_RTX, 0);\n-      *pfalse\n-\t= force_to_mode (false0, mode, ~(HOST_WIDE_INT) 0, NULL_RTX, 0);\n+      *ptrue = simplify_gen_subreg (mode, true0,\n+\t\t\t\t    GET_MODE (SUBREG_REG (x)), SUBREG_BYTE (x));\n+      *pfalse = simplify_gen_subreg (mode, false0,\n+\t\t\t\t     GET_MODE (SUBREG_REG (x)), SUBREG_BYTE (x));\n \n       return cond0;\n     }"}, {"sha": "e352d073efddaf3c2c1615ff474bdf379a4845f1", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0631e0bfb7d40fd3cb58d2d5400075f49000ab51/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0631e0bfb7d40fd3cb58d2d5400075f49000ab51/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=0631e0bfb7d40fd3cb58d2d5400075f49000ab51", "patch": "@@ -1414,7 +1414,7 @@ const248_operand (op, mode)\n int\n incdec_operand (op, mode)\n      register rtx op;\n-     enum machine_mode mode;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   /* On Pentium4, the inc and dec operations causes extra dependancy on flag\n      registers, since carry flag is not set.  */"}, {"sha": "f7dec2874e23259f6e7a19db2dce64d898354a0c", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 7, "deletions": 79, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0631e0bfb7d40fd3cb58d2d5400075f49000ab51/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0631e0bfb7d40fd3cb58d2d5400075f49000ab51/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=0631e0bfb7d40fd3cb58d2d5400075f49000ab51", "patch": "@@ -1430,7 +1430,10 @@ constant_subword (op, offset, mode)\n    ??? This is still rather broken for some cases.  The problem for the\n    moment is that all callers of this thing provide no 'goal mode' to\n    tell us to work with.  This exists because all callers were written\n-   in a word based SUBREG world.  */\n+   in a word based SUBREG world.\n+   Now use of this function can be deprecated by simplify_subreg in most\n+   cases.\n+ */\n \n rtx\n operand_subword (op, offset, validate_address, mode)\n@@ -1439,6 +1442,7 @@ operand_subword (op, offset, validate_address, mode)\n      int validate_address;\n      enum machine_mode mode;\n {\n+  rtx new;\n   if (mode == VOIDmode)\n     mode = GET_MODE (op);\n \n@@ -1455,82 +1459,6 @@ operand_subword (op, offset, validate_address, mode)\n       && (offset + 1) * UNITS_PER_WORD > GET_MODE_SIZE (mode))\n     return const0_rtx;\n \n-  switch (GET_CODE (op))\n-    {\n-    case REG:\n-    case SUBREG:\n-    case CONCAT:\n-    case MEM:\n-      break;\n-\n-    default:\n-      /* The only remaining cases are when OP is a constant.  If the host and\n-\t target floating formats are the same, handling two-word floating\n-\t constants are easy.  Note that REAL_VALUE_TO_TARGET_{SINGLE,DOUBLE}\n-\t are defined as returning one or two 32 bit values, respectively,\n-\t and not values of BITS_PER_WORD bits.  */\n-      return constant_subword (op, offset, mode);\n-    }\n-\n-  /* If OP is already an integer word, return it.  */\n-  if (GET_MODE_CLASS (mode) == MODE_INT\n-      && GET_MODE_SIZE (mode) == UNITS_PER_WORD)\n-    return op;\n-\n-  /* If OP is a REG or SUBREG, we can handle it very simply.  */\n-  if (GET_CODE (op) == REG)\n-    {\n-      if (REGNO (op) < FIRST_PSEUDO_REGISTER)\n-\t{\n-\t  int final_regno = REGNO (op) +\n-\t    subreg_regno_offset (REGNO (op), GET_MODE (op),\n-\t\t\t\toffset * UNITS_PER_WORD,\n-\t\t\t\tword_mode);\n-\n-\t  /* If the register is not valid for MODE, return 0.  If we don't\n-\t     do this, there is no way to fix up the resulting REG later.  */\n-\t  if (! HARD_REGNO_MODE_OK (final_regno, word_mode))\n-\t    return 0;\n-\n-\t  /* integrate.c can't handle parts of a return value register.\n-\t     ??? Then integrate.c should be fixed!\n-\t     ??? What about CLASS_CANNOT_CHANGE_SIZE?  */\n-\t  if ((! REG_FUNCTION_VALUE_P (op)\n-\t       || ! rtx_equal_function_value_matters)\n-\t      /* ??? What about CLASS_CANNOT_CHANGE_SIZE?  */\n-\t      /* We want to keep the stack, frame, and arg pointers\n-\t\t special.  */\n-\t      && op != frame_pointer_rtx\n-#if FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM\n-\t      && op != arg_pointer_rtx\n-#endif\n-\t      && op != stack_pointer_rtx)\n-\t    return gen_rtx_REG (word_mode, final_regno);\n-\t}\n-\n-      /* Just return a normal SUBREG.  */\n-      return gen_rtx_SUBREG (word_mode, op,\n-\t\t\t     (offset * UNITS_PER_WORD));\n-    }\n-  else if (GET_CODE (op) == SUBREG)\n-    {\n-      int final_offset = ((offset * UNITS_PER_WORD) + SUBREG_BYTE (op));\n-\n-      /* When working with SUBREGs the rule is that the byte\n-\t offset must be a multiple of the SUBREG's mode.  */\n-      final_offset = (final_offset / GET_MODE_SIZE (word_mode));\n-      final_offset = (final_offset * GET_MODE_SIZE (word_mode));\n-      return gen_rtx_SUBREG (word_mode, SUBREG_REG (op), final_offset);\n-    }\n-  else if (GET_CODE (op) == CONCAT)\n-    {\n-      unsigned int partwords = GET_MODE_UNIT_SIZE (GET_MODE (op)) / UNITS_PER_WORD;\n-      if (offset < partwords)\n-\treturn operand_subword (XEXP (op, 0), offset, validate_address, mode);\n-      return operand_subword (XEXP (op, 1), offset - partwords,\n-\t\t\t      validate_address, mode);\n-    }\n-\n   /* Form a new MEM at the requested address.  */\n   if (GET_CODE (op) == MEM)\n     {\n@@ -1553,8 +1481,8 @@ operand_subword (op, offset, validate_address, mode)\n       return new;\n     }\n \n-  /* Unreachable... (famous last words) */\n-  abort ();\n+  /* Rest can be handled by simplify_subreg.  */\n+  return simplify_gen_subreg (word_mode, op, mode, (offset * UNITS_PER_WORD));\n }\n \n /* Similar to `operand_subword', but never return 0.  If we can't extract"}, {"sha": "82f2787c6a3cdd599ffe33a5ae79b375e6ce3d71", "filename": "gcc/gcse.c", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0631e0bfb7d40fd3cb58d2d5400075f49000ab51/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0631e0bfb7d40fd3cb58d2d5400075f49000ab51/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=0631e0bfb7d40fd3cb58d2d5400075f49000ab51", "patch": "@@ -3472,7 +3472,7 @@ handle_avail_expr (insn, expr)\n      rtx insn;\n      struct expr *expr;\n {\n-  rtx pat, insn_computes_expr;\n+  rtx pat, insn_computes_expr, expr_set;\n   rtx to;\n   struct reg_set *this_reg;\n   int found_setting, use_src;\n@@ -3483,19 +3483,22 @@ handle_avail_expr (insn, expr)\n   insn_computes_expr = computing_insn (expr, insn);\n   if (insn_computes_expr == NULL)\n     return 0;\n+  expr_set = single_set (insn_computes_expr);\n+  if (!expr_set)\n+    abort ();\n \n   found_setting = 0;\n   use_src = 0;\n \n   /* At this point we know only one computation of EXPR outside of this\n      block reaches this insn.  Now try to find a register that the\n      expression is computed into.  */\n-  if (GET_CODE (SET_SRC (PATTERN (insn_computes_expr))) == REG)\n+  if (GET_CODE (SET_SRC (expr_set)) == REG)\n     {\n       /* This is the case when the available expression that reaches\n \t here has already been handled as an available expression.  */\n       unsigned int regnum_for_replacing\n-\t= REGNO (SET_SRC (PATTERN (insn_computes_expr)));\n+\t= REGNO (SET_SRC (expr_set));\n \n       /* If the register was created by GCSE we can't use `reg_set_table',\n \t however we know it's set only once.  */\n@@ -3514,7 +3517,7 @@ handle_avail_expr (insn, expr)\n   if (!found_setting)\n     {\n       unsigned int regnum_for_replacing\n-\t= REGNO (SET_DEST (PATTERN (insn_computes_expr)));\n+\t= REGNO (SET_DEST (expr_set));\n \n       /* This shouldn't happen.  */\n       if (regnum_for_replacing >= max_gcse_regno)\n@@ -3533,9 +3536,9 @@ handle_avail_expr (insn, expr)\n     {\n       pat = PATTERN (insn);\n       if (use_src)\n-\tto = SET_SRC (PATTERN (insn_computes_expr));\n+\tto = SET_SRC (expr_set);\n       else\n-\tto = SET_DEST (PATTERN (insn_computes_expr));\n+\tto = SET_DEST (expr_set);\n       changed = validate_change (insn, &SET_SRC (pat), to, 0);\n \n       /* We should be able to ignore the return code from validate_change but\n@@ -3563,15 +3566,14 @@ handle_avail_expr (insn, expr)\n \t replace all uses of REGB with REGN.  */\n       rtx new_insn;\n \n-      to = gen_reg_rtx (GET_MODE (SET_DEST (PATTERN (insn_computes_expr))));\n+      to = gen_reg_rtx (GET_MODE (SET_DEST (expr_set)));\n \n       /* Generate the new insn.  */\n       /* ??? If the change fails, we return 0, even though we created\n \t an insn.  I think this is ok.  */\n       new_insn\n \t= emit_insn_after (gen_rtx_SET (VOIDmode, to,\n-\t\t\t\t\tSET_DEST (PATTERN\n-\t\t\t\t\t\t  (insn_computes_expr))),\n+\t\t\t\t\tSET_DEST (expr_set)),\n \t\t\t   insn_computes_expr);\n \n       /* Keep block number table up to date.  */"}, {"sha": "ff9d33f20c41c0ed0e19f71d12020fac0612eb7f", "filename": "gcc/integrate.c", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0631e0bfb7d40fd3cb58d2d5400075f49000ab51/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0631e0bfb7d40fd3cb58d2d5400075f49000ab51/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=0631e0bfb7d40fd3cb58d2d5400075f49000ab51", "patch": "@@ -2411,19 +2411,14 @@ subst_constants (loc, insn, map, memonly)\n \t     valid.  We handle two cases: extracting a full word in an\n \t     integral mode and extracting the low part.  */\n \t  subst_constants (&inner, NULL_RTX, map, 0);\n-\n-\t  if (GET_MODE_CLASS (GET_MODE (x)) == MODE_INT\n-\t      && GET_MODE_SIZE (GET_MODE (x)) == UNITS_PER_WORD\n-\t      && GET_MODE (SUBREG_REG (x)) != VOIDmode)\n-\t    new = operand_subword (inner, SUBREG_BYTE (x) / UNITS_PER_WORD,\n-\t\t\t\t   0, GET_MODE (SUBREG_REG (x)));\n-\n-\t  cancel_changes (num_changes);\n-\t  if (new == 0 && subreg_lowpart_p (x))\n-\t    new = gen_lowpart_common (GET_MODE (x), inner);\n+\t  new = simplify_gen_subreg (GET_MODE (x), inner,\n+\t\t\t \t     GET_MODE (SUBREG_REG (x)),\n+\t\t\t\t     SUBREG_BYTE (x));\n \n \t  if (new)\n \t    validate_change (insn, loc, new, 1);\n+\t  else\n+\t    cancel_changes (num_changes);\n \n \t  return;\n \t}"}, {"sha": "ca144159cec511f4b35d010cf904230037e3394d", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0631e0bfb7d40fd3cb58d2d5400075f49000ab51/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0631e0bfb7d40fd3cb58d2d5400075f49000ab51/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=0631e0bfb7d40fd3cb58d2d5400075f49000ab51", "patch": "@@ -2515,16 +2515,16 @@ operand_preference (op)\n {\n   /* Constants always come the second operand.  Prefer \"nice\" constants.  */\n   if (GET_CODE (op) == CONST_INT)\n-    return -4;\n+    return -5;\n   if (GET_CODE (op) == CONST_DOUBLE)\n-    return -3;\n+    return -4;\n   if (CONSTANT_P (op))\n-    return -2;\n+    return -3;\n \n   /* SUBREGs of objects should come second.  */\n   if (GET_CODE (op) == SUBREG\n       && GET_RTX_CLASS (GET_CODE (SUBREG_REG (op))) == 'o')\n-    return -1;\n+    return -2;\n \n   /* If only one operand is a `neg', `not',\n     `mult', `plus', or `minus' expression, it will be the first\n@@ -2534,9 +2534,10 @@ operand_preference (op)\n       || GET_CODE (op) == MINUS)\n     return 2;\n \n-  /* Complex expressions should be the first.  */\n+  /* Complex expressions should be the first, so decrease priority\n+     of objects.  */\n   if (GET_RTX_CLASS (GET_CODE (op)) == 'o')\n-    return 1;\n+    return -1;\n   return 0;\n }\n "}, {"sha": "53ce4317c960ed6bf048b15a8793d0a4ed31868a", "filename": "gcc/sibcall.c", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0631e0bfb7d40fd3cb58d2d5400075f49000ab51/gcc%2Fsibcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0631e0bfb7d40fd3cb58d2d5400075f49000ab51/gcc%2Fsibcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsibcall.c?ref=0631e0bfb7d40fd3cb58d2d5400075f49000ab51", "patch": "@@ -169,6 +169,30 @@ skip_copy_to_return_value (orig_insn)\n       && SET_SRC (set) == softret)\n     return insn;\n \n+  /* Recognize the situation when the called function's return value\n+     is copied in two steps: first into an intermediate pseudo, then\n+     the into the calling functions return value register.  */\n+\n+  if (REG_P (SET_DEST (set))\n+      && SET_SRC (set) == softret)\n+    {\n+      rtx x = SET_DEST (set);\n+\n+      insn = next_nonnote_insn (insn);\n+      if (! insn)\n+\treturn orig_insn;\n+\n+      set = single_set (insn);\n+      if (! set)\n+\treturn orig_insn;\n+\n+      if (SET_DEST (set) == current_function_return_rtx\n+\t  && REG_P (SET_DEST (set))\n+\t  && OUTGOING_REGNO (REGNO (SET_DEST (set))) == REGNO (hardret)\n+\t  && SET_SRC (set) == x)\n+\treturn insn;\n+    }\n+\n   /* It did not look like a copy of the return value, so return the\n      same insn we were passed.  */\n   return orig_insn;"}, {"sha": "574513f59357da8f5927df15c3af8834d0c00334", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0631e0bfb7d40fd3cb58d2d5400075f49000ab51/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0631e0bfb7d40fd3cb58d2d5400075f49000ab51/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=0631e0bfb7d40fd3cb58d2d5400075f49000ab51", "patch": "@@ -2227,9 +2227,9 @@ simplify_subreg (outermode, op, innermode, byte)\n \t  && GET_MODE_SIZE (innermode) > UNITS_PER_WORD\n \t  && GET_MODE_CLASS (outermode) == MODE_INT)\n \t{\n-\t  rtx new = operand_subword (op,\n-\t\t\t\t     (byte / UNITS_PER_WORD),\n-\t\t\t\t     0, innermode);\n+\t  rtx new = constant_subword (op,\n+\t\t\t\t      (byte / UNITS_PER_WORD),\n+\t\t\t\t      innermode);\n \t  if (new)\n \t    return new;\n \t}"}]}