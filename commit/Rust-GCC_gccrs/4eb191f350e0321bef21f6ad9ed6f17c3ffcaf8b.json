{"sha": "4eb191f350e0321bef21f6ad9ed6f17c3ffcaf8b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGViMTkxZjM1MGUwMzIxYmVmMjFmNmFkOWVkNmYxN2MzZmZjYWY4Yg==", "commit": {"author": {"name": "Neil Booth", "email": "neilb@earthling.net", "date": "2000-12-02T16:04:14Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2000-12-02T16:04:14Z"}, "message": "tradcpp.c (struct answer, [...]): New.\n\n        * tradcpp.c (struct answer, parse_assertion, parse_answer,\n        canonicalize_text, find_answer): New.\n        (do_assert, do_unassert): Provide appropriate function bodies.\n        (union hashval): New member answers.\n\nFrom-SVN: r37953", "tree": {"sha": "310c6728b7c092464fd33ced40ad561acc88fbdf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/310c6728b7c092464fd33ced40ad561acc88fbdf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4eb191f350e0321bef21f6ad9ed6f17c3ffcaf8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4eb191f350e0321bef21f6ad9ed6f17c3ffcaf8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4eb191f350e0321bef21f6ad9ed6f17c3ffcaf8b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4eb191f350e0321bef21f6ad9ed6f17c3ffcaf8b/comments", "author": null, "committer": null, "parents": [{"sha": "1b83352ef7515f3468d296de64f28037f114627e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b83352ef7515f3468d296de64f28037f114627e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b83352ef7515f3468d296de64f28037f114627e"}], "stats": {"total": 244, "additions": 238, "deletions": 6}, "files": [{"sha": "17307b5cbf74e550d0a6f8c393222328abc2ce61", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4eb191f350e0321bef21f6ad9ed6f17c3ffcaf8b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4eb191f350e0321bef21f6ad9ed6f17c3ffcaf8b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4eb191f350e0321bef21f6ad9ed6f17c3ffcaf8b", "patch": "@@ -1,3 +1,10 @@\n+2000-12-02  Neil Booth  <neilb@earthling.net>\n+\n+        * tradcpp.c (struct answer, parse_assertion, parse_answer,\n+        canonicalize_text, find_answer): New.\n+        (do_assert, do_unassert): Provide appropriate function bodies.\n+        (union hashval): New member answers.\n+\n 2000-11-23  Marek Michalkiewicz  <marekm@linux.org.pl>\n \n \t* config/avr/avr.md: Document UNSPEC usage."}, {"sha": "51c8aff2b0f273f6d8fefc6c8478e8d8451cc5af", "filename": "gcc/tradcpp.c", "status": "modified", "additions": 231, "deletions": 6, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4eb191f350e0321bef21f6ad9ed6f17c3ffcaf8b/gcc%2Ftradcpp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4eb191f350e0321bef21f6ad9ed6f17c3ffcaf8b/gcc%2Ftradcpp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftradcpp.c?ref=4eb191f350e0321bef21f6ad9ed6f17c3ffcaf8b", "patch": "@@ -188,14 +188,22 @@ struct definition {\n   const U_CHAR *argnames;\n };\n \n+/* Chained list of answers to an assertion.  */\n+struct answer\n+{\n+  struct answer *next;\n+  const unsigned char *answer;\n+  size_t len;\n+};\n+\n /* different kinds of things that can appear in the value field\n    of a hash node.  Actually, this may be useless now. */\n union hashval {\n   const char *cpval;\n   DEFINITION *defn;\n+  struct answer *answers;\n };\n \n-\n /* The structure of a node in the hash table.  The hash table\n    has entries for all tokens defined by #define commands (type T_MACRO),\n    plus some special tokens like __LINE__ (these each have their own\n@@ -244,6 +252,17 @@ struct hashnode {\n \n typedef struct hashnode HASHNODE;\n \n+static HASHNODE *parse_assertion PARAMS ((const unsigned char *,\n+\t\t\t\t\t  const unsigned char *,\n+\t\t\t\t\t  struct answer **, int));\n+static struct answer **find_answer PARAMS ((HASHNODE *,\n+\t\t\t\t\t    const struct answer *));\n+static int parse_answer PARAMS ((const unsigned char *, const unsigned char *,\n+\t\t\t\t struct answer **, int));\n+static unsigned char *canonicalize_text PARAMS ((const unsigned char *,\n+\t\t\t\t\t\t const unsigned char *,\n+\t\t\t\t\t\t const unsigned char **));\n+\n /* Some definitions for the hash table.  The hash function MUST be\n    computed as shown in hashf () below.  That is because the rescan\n    loop computes the hash value `on the fly' for most tokens,\n@@ -3021,22 +3040,228 @@ do_undef (buf, limit, op)\n   }\n }\n \n-/* Function body to be provided later.  */\n+/* Read the tokens of the answer into the macro pool.  Only commit the\n+   memory if we intend it as permanent storage, i.e. the #assert case.\n+   Returns 0 on success.  */\n+\n+static int\n+parse_answer (buf, limit, answerp, type)\n+     const unsigned char *buf, *limit;\n+     struct answer **answerp;\n+     int type;\n+{\n+  const unsigned char *start;\n+\n+  /* Skip leading whitespace.  */\n+  if (buf < limit && *buf == ' ')\n+    buf++;\n+\n+  /* Parentheses are optional here.  */\n+  if (buf == limit && (type == T_IF || type == T_UNASSERT))\n+    return 0;\n+\n+  if (buf == limit || *buf++ != '(')\n+    {\n+      error (\"missing '(' after predicate\");\n+      return 1;\n+    }\n+\n+  /* Drop whitespace at start.  */\n+  while (buf < limit && *buf == ' ')\n+    buf++;\n+\n+  start = buf;\n+  while (buf < limit && *buf != ')')\n+    buf++;\n+\n+  if (buf == limit)\n+    {\n+      error (\"missing ')' to complete answer\");\n+      return 1;\n+    }\n+\n+  if (buf == start)\n+    {\n+      error (\"predicate's answer is empty\");\n+      return 1;\n+    }\n+\n+  if ((type == T_ASSERT || type == T_UNASSERT) && buf + 1 != limit)\n+    {\n+      error (\"extra text at end of directive\");\n+      return 1;\n+    }\n+\n+  /* Lose trailing whitespace.  */\n+  if (buf[-1] == ' ')\n+    buf--;\n+\n+  *answerp = (struct answer *) xmalloc (sizeof (struct answer));\n+  (*answerp)->answer = start;\n+  (*answerp)->len = buf - start;\n+\n+  return 0;\n+}\n+\n+/* Parses an assertion, returning a pointer to the hash node of the\n+   predicate, or 0 on error.  If an answer was supplied, it is placed\n+   in ANSWERP, otherwise it is set to 0.  */\n+static HASHNODE *\n+parse_assertion (buf, limit, answerp, type)\n+     const unsigned char *buf, *limit;\n+     struct answer **answerp;\n+     int type;\n+{\n+  HASHNODE *result = 0;\n+  const unsigned char *climit;\n+  unsigned char *bp, *symname = canonicalize_text (buf, limit, &climit);\n+  unsigned int len;\n+\n+  bp = symname;\n+  while (bp < climit && is_idchar[*bp])\n+    bp++;\n+  len = bp - symname;\n+\n+  *answerp = 0;\n+  if (len == 0)\n+    {\n+      if (symname == climit)\n+\terror (\"assertion without predicate\");\n+      else\n+\terror (\"predicate must be an identifier\");\n+    }\n+  else if (parse_answer (bp, climit, answerp, type) == 0)\n+    {\n+      unsigned char *sym = alloca (len + 1);\n+      int hashcode;\n+      \n+      /* Prefix '#' to get it out of macro namespace.  */\n+      sym[0] = '#';\n+      memcpy (sym + 1, symname, len);\n+\n+      hashcode = hashf (sym, len + 1, HASHSIZE);\n+      result = lookup (sym, len + 1, hashcode);\n+      if (result == 0)\n+\tresult = install (sym, len + 1, T_UNUSED, hashcode);\n+    }\n+\n+  return result;\n+}\n+\n+/* Handle a #assert directive.  */\n static void\n do_assert (buf, limit, op)\n-     U_CHAR *buf ATTRIBUTE_UNUSED;\n-     U_CHAR *limit ATTRIBUTE_UNUSED;\n+     U_CHAR *buf;\n+     U_CHAR *limit;\n      FILE_BUF *op ATTRIBUTE_UNUSED;\n {\n+  struct answer *new_answer;\n+  HASHNODE *node;\n+  \n+  node = parse_assertion (buf, limit, &new_answer, T_ASSERT);\n+  if (node)\n+    {\n+      /* Place the new answer in the answer list.  First check there\n+         is not a duplicate.  */\n+      new_answer->next = 0;\n+      if (node->type == T_ASSERT)\n+\t{\n+\t  if (*find_answer (node, new_answer))\n+\t    {\n+\t      free (new_answer);\n+\t      warning (\"\\\"%s\\\" re-asserted\", node->name + 1);\n+\t      return;\n+\t    }\n+\t  new_answer->next = node->value.answers;\n+\t}\n+      node->type = T_ASSERT;\n+      node->value.answers = new_answer;\n+    }\n }\n \n /* Function body to be provided later.  */\n static void\n do_unassert (buf, limit, op)\n-     U_CHAR *buf ATTRIBUTE_UNUSED;\n-     U_CHAR *limit ATTRIBUTE_UNUSED;\n+     U_CHAR *buf;\n+     U_CHAR *limit;\n      FILE_BUF *op ATTRIBUTE_UNUSED;\n {\n+  HASHNODE *node;\n+  struct answer *answer;\n+  \n+  node = parse_assertion (buf, limit, &answer, T_UNASSERT);\n+  /* It isn't an error to #unassert something that isn't asserted.  */\n+  if (node)\n+    {\n+      if (node->type == T_ASSERT)\n+\t{\n+\t  if (answer)\n+\t    {\n+\t      struct answer **p = find_answer (node, answer), *temp;\n+\n+\t      /* Remove the answer from the list.  */\n+\t      temp = *p;\n+\t      if (temp)\n+\t\t*p = temp->next;\n+\n+\t      /* Did we free the last answer?  */\n+\t      if (node->value.answers == 0)\n+\t\tdelete_macro (node);\n+\t    }\n+\t  else\n+\t    delete_macro (node);\n+\t}\n+\n+      free (answer);\n+    }\n+}\n+\n+/* Returns a pointer to the pointer to the answer in the answer chain,\n+   or a pointer to NULL if the answer is not in the chain.  */\n+static struct answer **\n+find_answer (node, candidate)\n+     HASHNODE *node;\n+     const struct answer *candidate;\n+{\n+  struct answer **result;\n+\n+  for (result = &node->value.answers; *result; result = &(*result)->next)\n+    {\n+      struct answer *answer = *result;\n+\n+      if (answer->len == candidate->len\n+\t  && !memcmp (answer->answer, candidate->answer, answer->len))\n+\tbreak;\n+    }\n+\n+  return result;\n+}\n+\n+/* Return a malloced buffer with leading and trailing whitespace\n+   removed, and all instances of internal whitespace reduced to a\n+   single space.  */\n+static unsigned char *\n+canonicalize_text (buf, limit, climit)\n+     const unsigned char *buf, *limit, **climit;\n+{\n+  unsigned int len = limit - buf;\n+  unsigned char *result = (unsigned char *) xmalloc (len), *dest;\n+\n+  for (dest = result; buf < limit;)\n+    {\n+      if (! is_space[*buf])\n+\t*dest++ = *buf++;\n+      else\n+\t{\n+\t  while (++buf < limit && is_space [*buf])\n+\t    ;\n+\t  if (dest != result && buf != limit)\n+\t    *dest++ = ' ';\n+\t}\n+    }\n+\n+  *climit = dest;\n+  return result;\n }\n \n /*"}]}