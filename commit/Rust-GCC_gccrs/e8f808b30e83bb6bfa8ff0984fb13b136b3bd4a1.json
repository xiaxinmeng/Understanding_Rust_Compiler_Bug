{"sha": "e8f808b30e83bb6bfa8ff0984fb13b136b3bd4a1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZThmODA4YjMwZTgzYmI2YmZhOGZmMDk4NGZiMTNiMTM2YjNiZDRhMQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2012-07-13T11:21:39Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2012-07-13T11:21:39Z"}, "message": "re PR tree-optimization/53922 (VRP: semantic conflict between range_includes_zero_p and value_inside_range)\n\n2012-07-13  Richard Guenther  <rguenther@suse.de>\n\n\tPR tree-optimization/53922\n\t* tree-vrp.c (value_inside_range): Change prototype to take\n\tmin/max instead of value-range.\n\t(range_includes_zero_p): Likewise.  Return the result from\n\tvalue_inside_range.\n\t(extract_range_from_binary_expr_1): Adjust to handle dont-know\n\treturn value from range_includes_zero_p.\n\t(extract_range_from_unary_expr_1): Likewise.\n\t(compare_range_with_value): Likewise.\n\t(vrp_meet_1): Likewise.\n\n\t* gcc.dg/torture/pr53922.c: New testcase.\n\nFrom-SVN: r189461", "tree": {"sha": "bb828fb1d805b42eb14a3c239b82bce7717d3d6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bb828fb1d805b42eb14a3c239b82bce7717d3d6e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e8f808b30e83bb6bfa8ff0984fb13b136b3bd4a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8f808b30e83bb6bfa8ff0984fb13b136b3bd4a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8f808b30e83bb6bfa8ff0984fb13b136b3bd4a1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8f808b30e83bb6bfa8ff0984fb13b136b3bd4a1/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c3e7ee4191ea60b02af9fff0ccc15d060961fde4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3e7ee4191ea60b02af9fff0ccc15d060961fde4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3e7ee4191ea60b02af9fff0ccc15d060961fde4"}], "stats": {"total": 118, "additions": 66, "deletions": 52}, "files": [{"sha": "f7b303a9f3c3154eae9438d9321abe49932e6396", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8f808b30e83bb6bfa8ff0984fb13b136b3bd4a1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8f808b30e83bb6bfa8ff0984fb13b136b3bd4a1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e8f808b30e83bb6bfa8ff0984fb13b136b3bd4a1", "patch": "@@ -1,3 +1,16 @@\n+2012-07-13  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/53922\n+\t* tree-vrp.c (value_inside_range): Change prototype to take\n+\tmin/max instead of value-range.\n+\t(range_includes_zero_p): Likewise.  Return the result from\n+\tvalue_inside_range.\n+\t(extract_range_from_binary_expr_1): Adjust to handle dont-know\n+\treturn value from range_includes_zero_p.\n+\t(extract_range_from_unary_expr_1): Likewise.\n+\t(compare_range_with_value): Likewise.\n+\t(vrp_meet_1): Likewise.\n+\n 2012-07-13  Bill Schmidt  <wschmidt@linux.ibm.com>\n \n \t* doc/tm.texi: Regenerate."}, {"sha": "c6286636b148018ac2ceb3abbdebabdc020e953a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8f808b30e83bb6bfa8ff0984fb13b136b3bd4a1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8f808b30e83bb6bfa8ff0984fb13b136b3bd4a1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e8f808b30e83bb6bfa8ff0984fb13b136b3bd4a1", "patch": "@@ -1,3 +1,8 @@\n+2012-07-13  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/53922\n+\t* gcc.dg/torture/pr53922.c: New testcase.\n+\n 2012-07-13  Hans-Peter Nilsson  <hp@axis.com>\n \n \tPR rtl-optimization/53908"}, {"sha": "e42d1c788c7313f1422e01ce5b98476bc04e77b1", "filename": "gcc/testsuite/gcc.dg/torture/pr53922.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8f808b30e83bb6bfa8ff0984fb13b136b3bd4a1/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr53922.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8f808b30e83bb6bfa8ff0984fb13b136b3bd4a1/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr53922.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr53922.c?ref=e8f808b30e83bb6bfa8ff0984fb13b136b3bd4a1", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do run } */\n+/* { dg-require-weak \"\" } */\n+\n+int x(int a)\n+{\n+  return a;\n+}\n+int y(int a) __attribute__ ((weak));\n+int g = 0;\n+int main()\n+{\n+  int (*scan_func)(int);\n+  if (g)\n+    scan_func = x;\n+  else\n+    scan_func = y;\n+\n+  if (scan_func)\n+    g = scan_func(10);\n+\n+  return 0;\n+}"}, {"sha": "0ce9a74c2712bb4a90069cd6790e704081588345", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 26, "deletions": 52, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8f808b30e83bb6bfa8ff0984fb13b136b3bd4a1/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8f808b30e83bb6bfa8ff0984fb13b136b3bd4a1/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=e8f808b30e83bb6bfa8ff0984fb13b136b3bd4a1", "patch": "@@ -1339,41 +1339,25 @@ compare_values (tree val1, tree val2)\n }\n \n \n-/* Return 1 if VAL is inside value range VR (VR->MIN <= VAL <= VR->MAX),\n-          0 if VAL is not inside VR,\n+/* Return 1 if VAL is inside value range MIN <= VAL <= MAX,\n+          0 if VAL is not inside [MIN, MAX],\n \t -2 if we cannot tell either way.\n \n-   FIXME, the current semantics of this functions are a bit quirky\n-\t  when taken in the context of VRP.  In here we do not care\n-\t  about VR's type.  If VR is the anti-range ~[3, 5] the call\n-\t  value_inside_range (4, VR) will return 1.\n-\n-\t  This is counter-intuitive in a strict sense, but the callers\n-\t  currently expect this.  They are calling the function\n-\t  merely to determine whether VR->MIN <= VAL <= VR->MAX.  The\n-\t  callers are applying the VR_RANGE/VR_ANTI_RANGE semantics\n-\t  themselves.\n-\n-\t  This also applies to value_ranges_intersect_p and\n-\t  range_includes_zero_p.  The semantics of VR_RANGE and\n-\t  VR_ANTI_RANGE should be encoded here, but that also means\n-\t  adapting the users of these functions to the new semantics.\n-\n    Benchmark compile/20001226-1.c compilation time after changing this\n    function.  */\n \n static inline int\n-value_inside_range (tree val, value_range_t * vr)\n+value_inside_range (tree val, tree min, tree max)\n {\n   int cmp1, cmp2;\n \n-  cmp1 = operand_less_p (val, vr->min);\n+  cmp1 = operand_less_p (val, min);\n   if (cmp1 == -2)\n     return -2;\n   if (cmp1 == 1)\n     return 0;\n \n-  cmp2 = operand_less_p (vr->max, val);\n+  cmp2 = operand_less_p (max, val);\n   if (cmp2 == -2)\n     return -2;\n \n@@ -1402,23 +1386,14 @@ value_ranges_intersect_p (value_range_t *vr0, value_range_t *vr1)\n }\n \n \n-/* Return true if VR includes the value zero, false otherwise.  FIXME,\n-   currently this will return false for an anti-range like ~[-4, 3].\n-   This will be wrong when the semantics of value_inside_range are\n-   modified (currently the users of this function expect these\n-   semantics).  */\n+/* Return 1 if [MIN, MAX] includes the value zero, 0 if it does not\n+   include the value zero, -2 if we cannot tell.  */\n \n-static inline bool\n-range_includes_zero_p (value_range_t *vr)\n+static inline int\n+range_includes_zero_p (tree min, tree max)\n {\n-  tree zero;\n-\n-  gcc_assert (vr->type != VR_UNDEFINED\n-              && vr->type != VR_VARYING\n-\t      && !symbolic_range_p (vr));\n-\n-  zero = build_int_cst (TREE_TYPE (vr->min), 0);\n-  return (value_inside_range (zero, vr) == 1);\n+  tree zero = build_int_cst (TREE_TYPE (min), 0);\n+  return value_inside_range (zero, min, max);\n }\n \n /* Return true if *VR is know to only contain nonnegative values.  */\n@@ -2641,7 +2616,7 @@ extract_range_from_binary_expr_1 (value_range_t *vr,\n \t     gives [min / 4, max / 4] range.  */\n \t  if (vr1.type == VR_RANGE\n \t      && !symbolic_range_p (&vr1)\n-\t      && !range_includes_zero_p (&vr1))\n+\t      && range_includes_zero_p (vr1.min, vr1.max) == 0)\n \t    {\n \t      vr0.type = type = VR_RANGE;\n \t      vr0.min = vrp_val_min (expr_type);\n@@ -2658,8 +2633,7 @@ extract_range_from_binary_expr_1 (value_range_t *vr,\n \t not eliminate a division by zero.  */\n       if (cfun->can_throw_non_call_exceptions\n \t  && (vr1.type != VR_RANGE\n-\t      || symbolic_range_p (&vr1)\n-\t      || range_includes_zero_p (&vr1)))\n+\t      || range_includes_zero_p (vr1.min, vr1.max) != 0))\n \t{\n \t  set_value_range_to_varying (vr);\n \t  return;\n@@ -2670,8 +2644,7 @@ extract_range_from_binary_expr_1 (value_range_t *vr,\n \t include 0.  */\n       if (vr0.type == VR_RANGE\n \t  && (vr1.type != VR_RANGE\n-\t      || symbolic_range_p (&vr1)\n-\t      || range_includes_zero_p (&vr1)))\n+\t      || range_includes_zero_p (vr1.min, vr1.max) != 0))\n \t{\n \t  tree zero = build_int_cst (TREE_TYPE (vr0.min), 0);\n \t  int cmp;\n@@ -2723,8 +2696,7 @@ extract_range_from_binary_expr_1 (value_range_t *vr,\n   else if (code == TRUNC_MOD_EXPR)\n     {\n       if (vr1.type != VR_RANGE\n-\t  || symbolic_range_p (&vr1)\n-\t  || range_includes_zero_p (&vr1)\n+\t  || range_includes_zero_p (vr1.min, vr1.max) != 0\n \t  || vrp_val_is_min (vr1.min))\n \t{\n \t  set_value_range_to_varying (vr);\n@@ -3159,7 +3131,7 @@ extract_range_from_unary_expr_1 (value_range_t *vr,\n \t ~[-INF, min(MIN, MAX)].  */\n       if (vr0.type == VR_ANTI_RANGE)\n \t{\n-\t  if (range_includes_zero_p (&vr0))\n+\t  if (range_includes_zero_p (vr0.min, vr0.max) == 1)\n \t    {\n \t      /* Take the lower of the two values.  */\n \t      if (cmp != 1)\n@@ -3210,7 +3182,7 @@ extract_range_from_unary_expr_1 (value_range_t *vr,\n \n       /* If the range contains zero then we know that the minimum value in the\n          range will be zero.  */\n-      else if (range_includes_zero_p (&vr0))\n+      else if (range_includes_zero_p (vr0.min, vr0.max) == 1)\n \t{\n \t  if (cmp == 1)\n \t    max = min;\n@@ -3812,7 +3784,7 @@ compare_range_with_value (enum tree_code comp, value_range_t *vr, tree val,\n \treturn NULL_TREE;\n \n       /* ~[VAL_1, VAL_2] OP VAL is known if VAL_1 <= VAL <= VAL_2.  */\n-      if (value_inside_range (val, vr) == 1)\n+      if (value_inside_range (val, vr->min, vr->max) == 1)\n \treturn (comp == NE_EXPR) ? boolean_true_node : boolean_false_node;\n \n       return NULL_TREE;\n@@ -7548,12 +7520,14 @@ vrp_meet_1 (value_range_t *vr0, value_range_t *vr1)\n \t anti-range.  FIXME, all this nonsense about distinguishing\n \t anti-ranges from ranges is necessary because of the odd\n \t semantics of range_includes_zero_p and friends.  */\n-      if (!symbolic_range_p (&saved)\n-\t  && ((saved.type == VR_RANGE && !range_includes_zero_p (&saved))\n-\t      || (saved.type == VR_ANTI_RANGE && range_includes_zero_p (&saved)))\n-\t  && !symbolic_range_p (vr1)\n-\t  && ((vr1->type == VR_RANGE && !range_includes_zero_p (vr1))\n-\t      || (vr1->type == VR_ANTI_RANGE && range_includes_zero_p (vr1))))\n+      if (((saved.type == VR_RANGE\n+\t    && range_includes_zero_p (saved.min, saved.max) == 0)\n+\t   || (saved.type == VR_ANTI_RANGE\n+\t       && range_includes_zero_p (saved.min, saved.max) == 1))\n+\t  && ((vr1->type == VR_RANGE\n+\t       && range_includes_zero_p (vr1->min, vr1->max) == 0)\n+\t      || (vr1->type == VR_ANTI_RANGE\n+\t\t  && range_includes_zero_p (vr1->min, vr1->max) == 1)))\n \t{\n \t  set_value_range_to_nonnull (vr0, TREE_TYPE (saved.min));\n "}]}