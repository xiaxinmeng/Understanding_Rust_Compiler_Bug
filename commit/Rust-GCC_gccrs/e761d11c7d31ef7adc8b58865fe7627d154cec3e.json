{"sha": "e761d11c7d31ef7adc8b58865fe7627d154cec3e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTc2MWQxMWM3ZDMxZWY3YWRjOGI1ODg2NWZlNzYyN2QxNTRjZWMzZQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-03-07T14:45:51Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-03-07T14:45:51Z"}, "message": "[multiple changes]\n\n2012-03-07  Gary Dismukes  <dismukes@adacore.com>\n\n\t* exp_ch4.adb (Apply_Accessibility_Check): Call\n\tRemove_Side_Effects in the build-in-place case, to ensure that\n\twe capture the call and don't end up with two calls.\n\n2012-03-07  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_ch6.adb (Expand_Inlined_Call): Skip inlining of functions\n\tthat return unconstrained types using an extended return statement\n\tsince the support for inlining these functions has not been yet\n\tadded to the frontend.\n\t* s-vaflop.adb, s-vaflop-vms-alpha.adb: Code reorganization.\n\t* a-ngrear.ads: Replace all the Inline_Always pragmas by pragma\n\tInline.\n\t* a-ngrear.adb (Eigenvalues, Transpose): Restructured to use\n\textended return statement.\n\t* a-strsup.adb, a-stzsup.adb, a-stwisu.adb (Concat, Super_Slice,\n\tSuper_To_String): Restructured to use extended return statement.\n\t* a-chahan.adb (To_Basic, To_Lower, To_Upper): Restructured to\n\tuse extended return statement.\n\t* s-gearop.adb (Diagonal, Matrix_Elementwise_Operation,\n\tVector_Elementwise_Operation, Matrix_Elementwise_Operation,\n\tMatrix_Matrix_Scalar_Elementwise_Operation,\n\tVector_Vector_Elementwise_Operation,\n\tVector_Vector_Scalar_Elementwise_Operation,\n\tMatrix_Scalar_Elementwise_Operation,\n\tVector_Scalar_Elementwise_Operation,\n\tScalar_Matrix_Elementwise_Operation,\n\tScalar_Vector_Elementwise_Operation, Matrix_Matrix_Product,\n\tMatrix_Vector_Product, Outer_Product, Unit_Matrix, Unit_Vector,\n\tVector_Matrix_Product): Restructured to use extended return\n\tstatement.\n\n2012-03-07  Vincent Pucci  <pucci@adacore.com>\n\n\t* sem_ch5.adb (One_Bound): Minor reformatting.\n\n2012-03-07  Tristan Gingold  <gingold@adacore.com>\n\n\t* s-osinte-vms-ia64.adb, s-osinte-vms-ia64.ads, s-osinte-vms.adb,\n\ts-osinte-vms.ads, gcc-interface/Makefile.in: Merge s-osinte-vms and\n\ts-osinte-vms-ia64.\n\nFrom-SVN: r185051", "tree": {"sha": "547ce03558b4baf7b4fb08c1682c061d275f1ccc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/547ce03558b4baf7b4fb08c1682c061d275f1ccc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e761d11c7d31ef7adc8b58865fe7627d154cec3e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e761d11c7d31ef7adc8b58865fe7627d154cec3e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e761d11c7d31ef7adc8b58865fe7627d154cec3e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e761d11c7d31ef7adc8b58865fe7627d154cec3e/comments", "author": null, "committer": null, "parents": [{"sha": "62db841a08b9e833bd30e5fe7d8de00d5a250b74", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62db841a08b9e833bd30e5fe7d8de00d5a250b74", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62db841a08b9e833bd30e5fe7d8de00d5a250b74"}], "stats": {"total": 1835, "additions": 579, "deletions": 1256}, "files": [{"sha": "e92726a3aee13bb99fdef4913232234da3f0b12e", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e761d11c7d31ef7adc8b58865fe7627d154cec3e/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e761d11c7d31ef7adc8b58865fe7627d154cec3e/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=e761d11c7d31ef7adc8b58865fe7627d154cec3e", "patch": "@@ -1,3 +1,47 @@\n+2012-03-07  Gary Dismukes  <dismukes@adacore.com>\n+\n+\t* exp_ch4.adb (Apply_Accessibility_Check): Call\n+\tRemove_Side_Effects in the build-in-place case, to ensure that\n+\twe capture the call and don't end up with two calls.\n+\n+2012-03-07  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_ch6.adb (Expand_Inlined_Call): Skip inlining of functions\n+\tthat return unconstrained types using an extended return statement\n+\tsince the support for inlining these functions has not been yet\n+\tadded to the frontend.\n+\t* s-vaflop.adb, s-vaflop-vms-alpha.adb: Code reorganization.\n+\t* a-ngrear.ads: Replace all the Inline_Always pragmas by pragma\n+\tInline.\n+\t* a-ngrear.adb (Eigenvalues, Transpose): Restructured to use\n+\textended return statement.\n+\t* a-strsup.adb, a-stzsup.adb, a-stwisu.adb (Concat, Super_Slice,\n+\tSuper_To_String): Restructured to use extended return statement.\n+\t* a-chahan.adb (To_Basic, To_Lower, To_Upper): Restructured to\n+\tuse extended return statement.\n+\t* s-gearop.adb (Diagonal, Matrix_Elementwise_Operation,\n+\tVector_Elementwise_Operation, Matrix_Elementwise_Operation,\n+\tMatrix_Matrix_Scalar_Elementwise_Operation,\n+\tVector_Vector_Elementwise_Operation,\n+\tVector_Vector_Scalar_Elementwise_Operation,\n+\tMatrix_Scalar_Elementwise_Operation,\n+\tVector_Scalar_Elementwise_Operation,\n+\tScalar_Matrix_Elementwise_Operation,\n+\tScalar_Vector_Elementwise_Operation, Matrix_Matrix_Product,\n+\tMatrix_Vector_Product, Outer_Product, Unit_Matrix, Unit_Vector,\n+\tVector_Matrix_Product): Restructured to use extended return\n+\tstatement.\n+\n+2012-03-07  Vincent Pucci  <pucci@adacore.com>\n+\n+\t* sem_ch5.adb (One_Bound): Minor reformatting.\n+\n+2012-03-07  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* s-osinte-vms-ia64.adb, s-osinte-vms-ia64.ads, s-osinte-vms.adb,\n+\ts-osinte-vms.ads, gcc-interface/Makefile.in: Merge s-osinte-vms and\n+\ts-osinte-vms-ia64.\n+\n 2012-03-07  Ed Schonberg  <schonberg@adacore.com>\n \n \t* checks.adb (Apply_Predicate_Check): Do not generate a predicate"}, {"sha": "c7a77ea57dca2e40e3e26e93b350ee999ffa5be5", "filename": "gcc/ada/a-chahan.adb", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e761d11c7d31ef7adc8b58865fe7627d154cec3e/gcc%2Fada%2Fa-chahan.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e761d11c7d31ef7adc8b58865fe7627d154cec3e/gcc%2Fada%2Fa-chahan.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-chahan.adb?ref=e761d11c7d31ef7adc8b58865fe7627d154cec3e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -422,14 +422,12 @@ package body Ada.Characters.Handling is\n    end To_Basic;\n \n    function To_Basic (Item : String) return String is\n-      Result : String (1 .. Item'Length);\n-\n    begin\n-      for J in Item'Range loop\n-         Result (J - (Item'First - 1)) := Value (Basic_Map, Item (J));\n-      end loop;\n-\n-      return Result;\n+      return Result : String (1 .. Item'Length) do\n+         for J in Item'Range loop\n+            Result (J - (Item'First - 1)) := Value (Basic_Map, Item (J));\n+         end loop;\n+      end return;\n    end To_Basic;\n \n    ------------------\n@@ -485,14 +483,12 @@ package body Ada.Characters.Handling is\n    end To_Lower;\n \n    function To_Lower (Item : String) return String is\n-      Result : String (1 .. Item'Length);\n-\n    begin\n-      for J in Item'Range loop\n-         Result (J - (Item'First - 1)) := Value (Lower_Case_Map, Item (J));\n-      end loop;\n-\n-      return Result;\n+      return Result : String (1 .. Item'Length) do\n+         for J in Item'Range loop\n+            Result (J - (Item'First - 1)) := Value (Lower_Case_Map, Item (J));\n+         end loop;\n+      end return;\n    end To_Lower;\n \n    ---------------\n@@ -527,14 +523,12 @@ package body Ada.Characters.Handling is\n    function To_Upper\n      (Item : String) return String\n    is\n-      Result : String (1 .. Item'Length);\n-\n    begin\n-      for J in Item'Range loop\n-         Result (J - (Item'First - 1)) := Value (Upper_Case_Map, Item (J));\n-      end loop;\n-\n-      return Result;\n+      return Result : String (1 .. Item'Length) do\n+         for J in Item'Range loop\n+            Result (J - (Item'First - 1)) := Value (Upper_Case_Map, Item (J));\n+         end loop;\n+      end return;\n    end To_Upper;\n \n    -----------------------"}, {"sha": "68d536513addb498caff1e3a8bc6745cf5df9b1a", "filename": "gcc/ada/a-ngrear.adb", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e761d11c7d31ef7adc8b58865fe7627d154cec3e/gcc%2Fada%2Fa-ngrear.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e761d11c7d31ef7adc8b58865fe7627d154cec3e/gcc%2Fada%2Fa-ngrear.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ngrear.adb?ref=e761d11c7d31ef7adc8b58865fe7627d154cec3e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2006-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2006-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -482,12 +482,15 @@ package body Ada.Numerics.Generic_Real_Arrays is\n    -----------------\n \n    function Eigenvalues (A : Real_Matrix) return Real_Vector is\n-      Values  : Real_Vector (A'Range (1));\n-      Vectors : Real_Matrix (1 .. 0, 1 .. 0);\n    begin\n-      Jacobi (A, Values, Vectors, Compute_Vectors => False);\n-      Sort_Eigensystem (Values, Vectors);\n-      return Values;\n+      return Values : Real_Vector (A'Range (1)) do\n+         declare\n+            Vectors : Real_Matrix (1 .. 0, 1 .. 0);\n+         begin\n+            Jacobi (A, Values, Vectors, Compute_Vectors => False);\n+            Sort_Eigensystem (Values, Vectors);\n+         end;\n+      end return;\n    end Eigenvalues;\n \n    -------------\n@@ -742,10 +745,10 @@ package body Ada.Numerics.Generic_Real_Arrays is\n    ---------------\n \n    function Transpose (X : Real_Matrix) return Real_Matrix is\n-      R : Real_Matrix (X'Range (2), X'Range (1));\n    begin\n-      Transpose (X, R);\n-      return R;\n+      return R : Real_Matrix (X'Range (2), X'Range (1)) do\n+         Transpose (X, R);\n+      end return;\n    end Transpose;\n \n    -----------------"}, {"sha": "f03ee37df0a2d9fab908eef9a7a83e8a5ebf0387", "filename": "gcc/ada/a-ngrear.ads", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e761d11c7d31ef7adc8b58865fe7627d154cec3e/gcc%2Fada%2Fa-ngrear.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e761d11c7d31ef7adc8b58865fe7627d154cec3e/gcc%2Fada%2Fa-ngrear.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ngrear.ads?ref=e761d11c7d31ef7adc8b58865fe7627d154cec3e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---            Copyright (C) 2009, Free Software Foundation, Inc.            --\n+--          Copyright (C) 2009-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -125,15 +125,15 @@ private\n    --  front end always inline these, the expense of the unconstrained returns\n    --  can be avoided.\n \n-   pragma Inline_Always (\"+\");\n-   pragma Inline_Always (\"-\");\n-   pragma Inline_Always (\"*\");\n-   pragma Inline_Always (\"/\");\n-   pragma Inline_Always (\"abs\");\n-   pragma Inline_Always (Eigenvalues);\n-   pragma Inline_Always (Inverse);\n-   pragma Inline_Always (Solve);\n-   pragma Inline_Always (Transpose);\n-   pragma Inline_Always (Unit_Matrix);\n-   pragma Inline_Always (Unit_Vector);\n+   pragma Inline (\"+\");\n+   pragma Inline (\"-\");\n+   pragma Inline (\"*\");\n+   pragma Inline (\"/\");\n+   pragma Inline (\"abs\");\n+   pragma Inline (Eigenvalues);\n+   pragma Inline (Inverse);\n+   pragma Inline (Solve);\n+   pragma Inline (Transpose);\n+   pragma Inline (Unit_Matrix);\n+   pragma Inline (Unit_Vector);\n end Ada.Numerics.Generic_Real_Arrays;"}, {"sha": "ed14e58964c789c2776017d93038eccc736db849", "filename": "gcc/ada/a-strsup.adb", "status": "modified", "additions": 88, "deletions": 79, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e761d11c7d31ef7adc8b58865fe7627d154cec3e/gcc%2Fada%2Fa-strsup.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e761d11c7d31ef7adc8b58865fe7627d154cec3e/gcc%2Fada%2Fa-strsup.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-strsup.adb?ref=e761d11c7d31ef7adc8b58865fe7627d154cec3e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2003-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2003-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -42,100 +42,107 @@ package body Ada.Strings.Superbounded is\n      (Left  : Super_String;\n       Right : Super_String) return Super_String\n    is\n-      Result : Super_String (Left.Max_Length);\n-      Llen   : constant Natural := Left.Current_Length;\n-      Rlen   : constant Natural := Right.Current_Length;\n-      Nlen   : constant Natural := Llen + Rlen;\n-\n    begin\n-      if Nlen > Left.Max_Length then\n-         raise Ada.Strings.Length_Error;\n-      else\n-         Result.Current_Length := Nlen;\n-         Result.Data (1 .. Llen) := Left.Data (1 .. Llen);\n-         Result.Data (Llen + 1 .. Nlen) := Right.Data (1 .. Rlen);\n-      end if;\n+      return Result : Super_String (Left.Max_Length) do\n+         declare\n+            Llen : constant Natural := Left.Current_Length;\n+            Rlen : constant Natural := Right.Current_Length;\n+            Nlen : constant Natural := Llen + Rlen;\n+         begin\n+            if Nlen > Left.Max_Length then\n+               raise Ada.Strings.Length_Error;\n+            end if;\n \n-      return Result;\n+            Result.Current_Length := Nlen;\n+            Result.Data (1 .. Llen) := Left.Data (1 .. Llen);\n+            Result.Data (Llen + 1 .. Nlen) := Right.Data (1 .. Rlen);\n+         end;\n+      end return;\n    end Concat;\n \n    function Concat\n      (Left  : Super_String;\n       Right : String) return Super_String\n    is\n-      Result : Super_String (Left.Max_Length);\n-      Llen   : constant Natural := Left.Current_Length;\n-\n-      Nlen   : constant Natural := Llen + Right'Length;\n-\n    begin\n-      if Nlen > Left.Max_Length then\n-         raise Ada.Strings.Length_Error;\n-      else\n-         Result.Current_Length := Nlen;\n-         Result.Data (1 .. Llen) := Left.Data (1 .. Llen);\n-         Result.Data (Llen + 1 .. Nlen) := Right;\n-      end if;\n-      return Result;\n+      return Result : Super_String (Left.Max_Length) do\n+         declare\n+            Llen   : constant Natural := Left.Current_Length;\n+            Nlen   : constant Natural := Llen + Right'Length;\n+         begin\n+            if Nlen > Left.Max_Length then\n+               raise Ada.Strings.Length_Error;\n+            end if;\n+\n+            Result.Current_Length := Nlen;\n+            Result.Data (1 .. Llen) := Left.Data (1 .. Llen);\n+            Result.Data (Llen + 1 .. Nlen) := Right;\n+         end;\n+      end return;\n    end Concat;\n \n    function Concat\n      (Left  : String;\n       Right : Super_String) return Super_String\n    is\n-      Result : Super_String (Right.Max_Length);\n-      Llen   : constant Natural := Left'Length;\n-      Rlen   : constant Natural := Right.Current_Length;\n-      Nlen   : constant Natural := Llen + Rlen;\n \n    begin\n-      if Nlen > Right.Max_Length then\n-         raise Ada.Strings.Length_Error;\n-      else\n-         Result.Current_Length := Nlen;\n-         Result.Data (1 .. Llen) := Left;\n-         Result.Data (Llen + 1 .. Nlen) := Right.Data (1 .. Rlen);\n-      end if;\n+      return Result : Super_String (Right.Max_Length) do\n+         declare\n+            Llen : constant Natural := Left'Length;\n+            Rlen : constant Natural := Right.Current_Length;\n+            Nlen : constant Natural := Llen + Rlen;\n+         begin\n+            if Nlen > Right.Max_Length then\n+               raise Ada.Strings.Length_Error;\n+            end if;\n \n-      return Result;\n+            Result.Current_Length := Nlen;\n+            Result.Data (1 .. Llen) := Left;\n+            Result.Data (Llen + 1 .. Nlen) := Right.Data (1 .. Rlen);\n+         end;\n+      end return;\n    end Concat;\n \n    function Concat\n      (Left  : Super_String;\n       Right : Character) return Super_String\n    is\n-      Result : Super_String (Left.Max_Length);\n-      Llen   : constant Natural := Left.Current_Length;\n-\n    begin\n-      if Llen = Left.Max_Length then\n-         raise Ada.Strings.Length_Error;\n-      else\n-         Result.Current_Length := Llen + 1;\n-         Result.Data (1 .. Llen) := Left.Data (1 .. Llen);\n-         Result.Data (Result.Current_Length) := Right;\n-      end if;\n+      return Result : Super_String (Left.Max_Length) do\n+         declare\n+            Llen : constant Natural := Left.Current_Length;\n+         begin\n+            if Llen = Left.Max_Length then\n+               raise Ada.Strings.Length_Error;\n+            end if;\n \n-      return Result;\n+            Result.Current_Length := Llen + 1;\n+            Result.Data (1 .. Llen) := Left.Data (1 .. Llen);\n+            Result.Data (Result.Current_Length) := Right;\n+         end;\n+      end return;\n    end Concat;\n \n    function Concat\n      (Left  : Character;\n       Right : Super_String) return Super_String\n    is\n-      Result : Super_String (Right.Max_Length);\n-      Rlen   : constant Natural := Right.Current_Length;\n-\n    begin\n-      if Rlen = Right.Max_Length then\n-         raise Ada.Strings.Length_Error;\n-      else\n-         Result.Current_Length := Rlen + 1;\n-         Result.Data (1) := Left;\n-         Result.Data (2 .. Result.Current_Length) := Right.Data (1 .. Rlen);\n-      end if;\n+      return Result : Super_String (Right.Max_Length) do\n+         declare\n+            Rlen : constant Natural := Right.Current_Length;\n+         begin\n+            if Rlen = Right.Max_Length then\n+               raise Ada.Strings.Length_Error;\n+            end if;\n \n-      return Result;\n+            Result.Current_Length := Rlen + 1;\n+            Result.Data (1) := Left;\n+            Result.Data (2 .. Result.Current_Length) :=\n+              Right.Data (1 .. Rlen);\n+         end;\n+      end return;\n    end Concat;\n \n    -----------\n@@ -1459,33 +1466,33 @@ package body Ada.Strings.Superbounded is\n    begin\n       --  Note: test of High > Length is in accordance with AI95-00128\n \n-      if Low > Source.Current_Length + 1\n-        or else High > Source.Current_Length\n-      then\n-         raise Index_Error;\n-      else\n-         return Source.Data (Low .. High);\n-      end if;\n+      return R : String (Low .. High) do\n+         if Low > Source.Current_Length + 1\n+           or else High > Source.Current_Length\n+         then\n+            raise Index_Error;\n+         end if;\n+\n+         R := Source.Data (Low .. High);\n+      end return;\n    end Super_Slice;\n \n    function Super_Slice\n      (Source : Super_String;\n       Low    : Positive;\n       High   : Natural) return Super_String\n    is\n-      Result : Super_String (Source.Max_Length);\n-\n    begin\n-      if Low > Source.Current_Length + 1\n-        or else High > Source.Current_Length\n-      then\n-         raise Index_Error;\n-      else\n+      return Result : Super_String (Source.Max_Length) do\n+         if Low > Source.Current_Length + 1\n+           or else High > Source.Current_Length\n+         then\n+            raise Index_Error;\n+         end if;\n+\n          Result.Current_Length := High - Low + 1;\n          Result.Data (1 .. Result.Current_Length) := Source.Data (Low .. High);\n-      end if;\n-\n-      return Result;\n+      end return;\n    end Super_Slice;\n \n    procedure Super_Slice\n@@ -1615,7 +1622,9 @@ package body Ada.Strings.Superbounded is\n \n    function Super_To_String (Source : Super_String) return String is\n    begin\n-      return Source.Data (1 .. Source.Current_Length);\n+      return R : String (1 .. Source.Current_Length) do\n+         R := Source.Data (1 .. Source.Current_Length);\n+      end return;\n    end Super_To_String;\n \n    ---------------------"}, {"sha": "10c2b237b8f578b9f3ebbd83a77bce39b260144b", "filename": "gcc/ada/a-stwisu.adb", "status": "modified", "additions": 93, "deletions": 80, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e761d11c7d31ef7adc8b58865fe7627d154cec3e/gcc%2Fada%2Fa-stwisu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e761d11c7d31ef7adc8b58865fe7627d154cec3e/gcc%2Fada%2Fa-stwisu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stwisu.adb?ref=e761d11c7d31ef7adc8b58865fe7627d154cec3e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2003-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2003-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -42,100 +42,111 @@ package body Ada.Strings.Wide_Superbounded is\n      (Left  : Super_String;\n       Right : Super_String) return Super_String\n    is\n-      Result : Super_String (Left.Max_Length);\n-      Llen   : constant Natural := Left.Current_Length;\n-      Rlen   : constant Natural := Right.Current_Length;\n-      Nlen   : constant Natural := Llen + Rlen;\n-\n    begin\n-      if Nlen > Left.Max_Length then\n-         raise Ada.Strings.Length_Error;\n-      else\n-         Result.Current_Length := Nlen;\n-         Result.Data (1 .. Llen) := Left.Data (1 .. Llen);\n-         Result.Data (Llen + 1 .. Nlen) := Right.Data (1 .. Rlen);\n-      end if;\n+      return Result : Super_String (Left.Max_Length) do\n+         declare\n+            Llen : constant Natural := Left.Current_Length;\n+            Rlen : constant Natural := Right.Current_Length;\n+            Nlen : constant Natural := Llen + Rlen;\n \n-      return Result;\n+         begin\n+            if Nlen > Left.Max_Length then\n+               raise Ada.Strings.Length_Error;\n+            else\n+               Result.Current_Length := Nlen;\n+               Result.Data (1 .. Llen) := Left.Data (1 .. Llen);\n+               Result.Data (Llen + 1 .. Nlen) := Right.Data (1 .. Rlen);\n+            end if;\n+         end;\n+      end return;\n    end Concat;\n \n    function Concat\n      (Left  : Super_String;\n       Right : Wide_String) return Super_String\n    is\n-      Result : Super_String (Left.Max_Length);\n-      Llen   : constant Natural := Left.Current_Length;\n-\n-      Nlen   : constant Natural := Llen + Right'Length;\n-\n    begin\n-      if Nlen > Left.Max_Length then\n-         raise Ada.Strings.Length_Error;\n-      else\n-         Result.Current_Length := Nlen;\n-         Result.Data (1 .. Llen) := Left.Data (1 .. Llen);\n-         Result.Data (Llen + 1 .. Nlen) := Right;\n-      end if;\n-      return Result;\n+      return Result : Super_String (Left.Max_Length) do\n+         declare\n+            Llen : constant Natural := Left.Current_Length;\n+            Nlen : constant Natural := Llen + Right'Length;\n+\n+         begin\n+            if Nlen > Left.Max_Length then\n+               raise Ada.Strings.Length_Error;\n+            else\n+               Result.Current_Length := Nlen;\n+               Result.Data (1 .. Llen) := Left.Data (1 .. Llen);\n+               Result.Data (Llen + 1 .. Nlen) := Right;\n+            end if;\n+         end;\n+      end return;\n    end Concat;\n \n    function Concat\n      (Left  : Wide_String;\n       Right : Super_String) return Super_String\n    is\n-      Result : Super_String (Right.Max_Length);\n-      Llen   : constant Natural := Left'Length;\n-      Rlen   : constant Natural := Right.Current_Length;\n-      Nlen   : constant Natural := Llen + Rlen;\n-\n    begin\n-      if Nlen > Right.Max_Length then\n-         raise Ada.Strings.Length_Error;\n-      else\n-         Result.Current_Length := Nlen;\n-         Result.Data (1 .. Llen) := Left;\n-         Result.Data (Llen + 1 .. Nlen) := Right.Data (1 .. Rlen);\n-      end if;\n+      return Result : Super_String (Right.Max_Length) do\n+         declare\n+            Llen : constant Natural := Left'Length;\n+            Rlen : constant Natural := Right.Current_Length;\n+            Nlen : constant Natural := Llen + Rlen;\n \n-      return Result;\n+         begin\n+            if Nlen > Right.Max_Length then\n+               raise Ada.Strings.Length_Error;\n+            else\n+               Result.Current_Length := Nlen;\n+               Result.Data (1 .. Llen) := Left;\n+               Result.Data (Llen + 1 .. Nlen) := Right.Data (1 .. Rlen);\n+            end if;\n+         end;\n+      end return;\n    end Concat;\n \n    function Concat\n      (Left  : Super_String;\n       Right : Wide_Character) return Super_String\n    is\n-      Result : Super_String (Left.Max_Length);\n-      Llen   : constant Natural := Left.Current_Length;\n-\n    begin\n-      if Llen = Left.Max_Length then\n-         raise Ada.Strings.Length_Error;\n-      else\n-         Result.Current_Length := Llen + 1;\n-         Result.Data (1 .. Llen) := Left.Data (1 .. Llen);\n-         Result.Data (Result.Current_Length) := Right;\n-      end if;\n+      return Result : Super_String (Left.Max_Length) do\n+         declare\n+            Llen : constant Natural := Left.Current_Length;\n \n-      return Result;\n+         begin\n+            if Llen = Left.Max_Length then\n+               raise Ada.Strings.Length_Error;\n+            else\n+               Result.Current_Length := Llen + 1;\n+               Result.Data (1 .. Llen) := Left.Data (1 .. Llen);\n+               Result.Data (Result.Current_Length) := Right;\n+            end if;\n+         end;\n+      end return;\n    end Concat;\n \n    function Concat\n      (Left  : Wide_Character;\n       Right : Super_String) return Super_String\n    is\n-      Result : Super_String (Right.Max_Length);\n-      Rlen   : constant Natural := Right.Current_Length;\n-\n    begin\n-      if Rlen = Right.Max_Length then\n-         raise Ada.Strings.Length_Error;\n-      else\n-         Result.Current_Length := Rlen + 1;\n-         Result.Data (1) := Left;\n-         Result.Data (2 .. Result.Current_Length) := Right.Data (1 .. Rlen);\n-      end if;\n+      return Result : Super_String (Right.Max_Length) do\n+         declare\n+            Rlen : constant Natural := Right.Current_Length;\n \n-      return Result;\n+         begin\n+            if Rlen = Right.Max_Length then\n+               raise Ada.Strings.Length_Error;\n+            else\n+               Result.Current_Length := Rlen + 1;\n+               Result.Data (1) := Left;\n+               Result.Data (2 .. Result.Current_Length) :=\n+                 Right.Data (1 .. Rlen);\n+            end if;\n+         end;\n+      end return;\n    end Concat;\n \n    -----------\n@@ -1462,33 +1473,33 @@ package body Ada.Strings.Wide_Superbounded is\n    begin\n       --  Note: test of High > Length is in accordance with AI95-00128\n \n-      if Low > Source.Current_Length + 1\n-        or else High > Source.Current_Length\n-      then\n-         raise Index_Error;\n-      else\n-         return Source.Data (Low .. High);\n-      end if;\n+      return R : Wide_String (Low .. High) do\n+         if Low > Source.Current_Length + 1\n+           or else High > Source.Current_Length\n+         then\n+            raise Index_Error;\n+         end if;\n+\n+         R := Source.Data (Low .. High);\n+      end return;\n    end Super_Slice;\n \n    function Super_Slice\n      (Source : Super_String;\n       Low    : Positive;\n       High   : Natural) return Super_String\n    is\n-      Result : Super_String (Source.Max_Length);\n-\n    begin\n-      if Low > Source.Current_Length + 1\n-        or else High > Source.Current_Length\n-      then\n-         raise Index_Error;\n-      else\n+      return Result : Super_String (Source.Max_Length) do\n+         if Low > Source.Current_Length + 1\n+           or else High > Source.Current_Length\n+         then\n+            raise Index_Error;\n+         end if;\n+\n          Result.Current_Length := High - Low + 1;\n          Result.Data (1 .. Result.Current_Length) := Source.Data (Low .. High);\n-      end if;\n-\n-      return Result;\n+      end return;\n    end Super_Slice;\n \n    procedure Super_Slice\n@@ -1618,7 +1629,9 @@ package body Ada.Strings.Wide_Superbounded is\n \n    function Super_To_String (Source : Super_String) return Wide_String is\n    begin\n-      return Source.Data (1 .. Source.Current_Length);\n+      return R : Wide_String (1 .. Source.Current_Length) do\n+         R := Source.Data (1 .. Source.Current_Length);\n+      end return;\n    end Super_To_String;\n \n    ---------------------"}, {"sha": "a79dfa0cce5e486f172f4c89dd6dc70ea6bd80f4", "filename": "gcc/ada/a-stzsup.adb", "status": "modified", "additions": 96, "deletions": 82, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e761d11c7d31ef7adc8b58865fe7627d154cec3e/gcc%2Fada%2Fa-stzsup.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e761d11c7d31ef7adc8b58865fe7627d154cec3e/gcc%2Fada%2Fa-stzsup.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stzsup.adb?ref=e761d11c7d31ef7adc8b58865fe7627d154cec3e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2003-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2003-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -42,100 +42,111 @@ package body Ada.Strings.Wide_Wide_Superbounded is\n      (Left  : Super_String;\n       Right : Super_String) return Super_String\n    is\n-      Result : Super_String (Left.Max_Length);\n-      Llen   : constant Natural := Left.Current_Length;\n-      Rlen   : constant Natural := Right.Current_Length;\n-      Nlen   : constant Natural := Llen + Rlen;\n-\n    begin\n-      if Nlen > Left.Max_Length then\n-         raise Ada.Strings.Length_Error;\n-      else\n-         Result.Current_Length := Nlen;\n-         Result.Data (1 .. Llen) := Left.Data (1 .. Llen);\n-         Result.Data (Llen + 1 .. Nlen) := Right.Data (1 .. Rlen);\n-      end if;\n+      return Result : Super_String (Left.Max_Length) do\n+         declare\n+            Llen : constant Natural := Left.Current_Length;\n+            Rlen : constant Natural := Right.Current_Length;\n+            Nlen : constant Natural := Llen + Rlen;\n \n-      return Result;\n+         begin\n+            if Nlen > Left.Max_Length then\n+               raise Ada.Strings.Length_Error;\n+            else\n+               Result.Current_Length := Nlen;\n+               Result.Data (1 .. Llen) := Left.Data (1 .. Llen);\n+               Result.Data (Llen + 1 .. Nlen) := Right.Data (1 .. Rlen);\n+            end if;\n+         end;\n+      end return;\n    end Concat;\n \n    function Concat\n      (Left  : Super_String;\n       Right : Wide_Wide_String) return Super_String\n    is\n-      Result : Super_String (Left.Max_Length);\n-      Llen   : constant Natural := Left.Current_Length;\n-\n-      Nlen   : constant Natural := Llen + Right'Length;\n-\n    begin\n-      if Nlen > Left.Max_Length then\n-         raise Ada.Strings.Length_Error;\n-      else\n-         Result.Current_Length := Nlen;\n-         Result.Data (1 .. Llen) := Left.Data (1 .. Llen);\n-         Result.Data (Llen + 1 .. Nlen) := Right;\n-      end if;\n-      return Result;\n+      return Result : Super_String (Left.Max_Length) do\n+         declare\n+            Llen : constant Natural := Left.Current_Length;\n+            Nlen : constant Natural := Llen + Right'Length;\n+\n+         begin\n+            if Nlen > Left.Max_Length then\n+               raise Ada.Strings.Length_Error;\n+            else\n+               Result.Current_Length := Nlen;\n+               Result.Data (1 .. Llen) := Left.Data (1 .. Llen);\n+               Result.Data (Llen + 1 .. Nlen) := Right;\n+            end if;\n+         end;\n+      end return;\n    end Concat;\n \n    function Concat\n      (Left  : Wide_Wide_String;\n       Right : Super_String) return Super_String\n    is\n-      Result : Super_String (Right.Max_Length);\n-      Llen   : constant Natural := Left'Length;\n-      Rlen   : constant Natural := Right.Current_Length;\n-      Nlen   : constant Natural := Llen + Rlen;\n-\n    begin\n-      if Nlen > Right.Max_Length then\n-         raise Ada.Strings.Length_Error;\n-      else\n-         Result.Current_Length := Nlen;\n-         Result.Data (1 .. Llen) := Left;\n-         Result.Data (Llen + 1 .. Nlen) := Right.Data (1 .. Rlen);\n-      end if;\n+      return Result : Super_String (Right.Max_Length) do\n+         declare\n+            Llen : constant Natural := Left'Length;\n+            Rlen : constant Natural := Right.Current_Length;\n+            Nlen : constant Natural := Llen + Rlen;\n \n-      return Result;\n+         begin\n+            if Nlen > Right.Max_Length then\n+               raise Ada.Strings.Length_Error;\n+            else\n+               Result.Current_Length := Nlen;\n+               Result.Data (1 .. Llen) := Left;\n+               Result.Data (Llen + 1 .. Nlen) := Right.Data (1 .. Rlen);\n+            end if;\n+         end;\n+      end return;\n    end Concat;\n \n    function Concat\n      (Left  : Super_String;\n       Right : Wide_Wide_Character) return Super_String\n    is\n-      Result : Super_String (Left.Max_Length);\n-      Llen   : constant Natural := Left.Current_Length;\n-\n    begin\n-      if Llen = Left.Max_Length then\n-         raise Ada.Strings.Length_Error;\n-      else\n-         Result.Current_Length := Llen + 1;\n-         Result.Data (1 .. Llen) := Left.Data (1 .. Llen);\n-         Result.Data (Result.Current_Length) := Right;\n-      end if;\n+      return Result : Super_String (Left.Max_Length) do\n+         declare\n+            Llen : constant Natural := Left.Current_Length;\n \n-      return Result;\n+         begin\n+            if Llen = Left.Max_Length then\n+               raise Ada.Strings.Length_Error;\n+            else\n+               Result.Current_Length := Llen + 1;\n+               Result.Data (1 .. Llen) := Left.Data (1 .. Llen);\n+               Result.Data (Result.Current_Length) := Right;\n+            end if;\n+         end;\n+      end return;\n    end Concat;\n \n    function Concat\n      (Left  : Wide_Wide_Character;\n       Right : Super_String) return Super_String\n    is\n-      Result : Super_String (Right.Max_Length);\n-      Rlen   : constant Natural := Right.Current_Length;\n-\n    begin\n-      if Rlen = Right.Max_Length then\n-         raise Ada.Strings.Length_Error;\n-      else\n-         Result.Current_Length := Rlen + 1;\n-         Result.Data (1) := Left;\n-         Result.Data (2 .. Result.Current_Length) := Right.Data (1 .. Rlen);\n-      end if;\n+      return Result : Super_String (Right.Max_Length) do\n+         declare\n+            Rlen : constant Natural := Right.Current_Length;\n \n-      return Result;\n+         begin\n+            if Rlen = Right.Max_Length then\n+               raise Ada.Strings.Length_Error;\n+            else\n+               Result.Current_Length := Rlen + 1;\n+               Result.Data (1) := Left;\n+               Result.Data (2 .. Result.Current_Length) :=\n+                 Right.Data (1 .. Rlen);\n+            end if;\n+         end;\n+      end return;\n    end Concat;\n \n    -----------\n@@ -1469,33 +1480,34 @@ package body Ada.Strings.Wide_Wide_Superbounded is\n    begin\n       --  Note: test of High > Length is in accordance with AI95-00128\n \n-      if Low > Source.Current_Length + 1\n-        or else High > Source.Current_Length\n-      then\n-         raise Index_Error;\n-      else\n-         return Source.Data (Low .. High);\n-      end if;\n+      return R : Wide_Wide_String (Low .. High) do\n+         if Low > Source.Current_Length + 1\n+           or else High > Source.Current_Length\n+         then\n+            raise Index_Error;\n+         end if;\n+\n+         R := Source.Data (Low .. High);\n+      end return;\n    end Super_Slice;\n \n    function Super_Slice\n      (Source : Super_String;\n       Low    : Positive;\n       High   : Natural) return Super_String\n    is\n-      Result : Super_String (Source.Max_Length);\n-\n    begin\n-      if Low > Source.Current_Length + 1\n-        or else High > Source.Current_Length\n-      then\n-         raise Index_Error;\n-      else\n-         Result.Current_Length := High - Low + 1;\n-         Result.Data (1 .. Result.Current_Length) := Source.Data (Low .. High);\n-      end if;\n-\n-      return Result;\n+      return Result : Super_String (Source.Max_Length) do\n+         if Low > Source.Current_Length + 1\n+           or else High > Source.Current_Length\n+         then\n+            raise Index_Error;\n+         else\n+            Result.Current_Length := High - Low + 1;\n+            Result.Data (1 .. Result.Current_Length) :=\n+              Source.Data (Low .. High);\n+         end if;\n+      end return;\n    end Super_Slice;\n \n    procedure Super_Slice\n@@ -1627,7 +1639,9 @@ package body Ada.Strings.Wide_Wide_Superbounded is\n      (Source : Super_String) return Wide_Wide_String\n    is\n    begin\n-      return Source.Data (1 .. Source.Current_Length);\n+      return R : Wide_Wide_String (1 .. Source.Current_Length) do\n+         R := Source.Data (1 .. Source.Current_Length);\n+      end return;\n    end Super_To_String;\n \n    ---------------------"}, {"sha": "07885c2ce7994543620516502295b24e27e477da", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e761d11c7d31ef7adc8b58865fe7627d154cec3e/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e761d11c7d31ef7adc8b58865fe7627d154cec3e/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=e761d11c7d31ef7adc8b58865fe7627d154cec3e", "patch": "@@ -702,13 +702,16 @@ package body Exp_Ch4 is\n                  (Is_Class_Wide_Type (Etype (Exp))\n                    and then Scope (PtrT) /= Current_Scope))\n          then\n-            --  If the allocator was built in place Ref is already a reference\n+            --  If the allocator was built in place, Ref is already a reference\n             --  to the access object initialized to the result of the allocator\n-            --  (see Exp_Ch6.Make_Build_In_Place_Call_In_Allocator). Otherwise\n-            --  it is the entity associated with the object containing the\n-            --  address of the allocated object.\n+            --  (see Exp_Ch6.Make_Build_In_Place_Call_In_Allocator). We call\n+            --  Remove_Side_Effects for cases where the build-in-place call may\n+            --  still be the prefix of the reference (to avoid generating\n+            --  duplicate calls). Otherwise, it is the entity associated with\n+            --  the object containing the address of the allocated object.\n \n             if Built_In_Place then\n+               Remove_Side_Effects (Ref);\n                New_Node := New_Copy (Ref);\n             else\n                New_Node := New_Reference_To (Ref, Loc);"}, {"sha": "1299b15b0d223ef1e389013a78d3afbaf7f1f894", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e761d11c7d31ef7adc8b58865fe7627d154cec3e/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e761d11c7d31ef7adc8b58865fe7627d154cec3e/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=e761d11c7d31ef7adc8b58865fe7627d154cec3e", "patch": "@@ -4243,6 +4243,23 @@ package body Exp_Ch6 is\n          Error_Msg_N (\"call to recursive subprogram cannot be inlined?\", N);\n          Set_Is_Inlined (Subp, False);\n          return;\n+\n+      --  Skip inlining if this is not a true inlining since the attribute\n+      --  Body_To_Inline is also set for renamings (see sinfo.ads)\n+\n+      elsif Nkind (Orig_Bod) in N_Entity then\n+         return;\n+\n+      --  Skip inlining if the function returns an unconstrained type using\n+      --  an extended return statement since this part of the new model of\n+      --  inlining which is not yet supported by the current implementation.\n+\n+      elsif Is_Unc\n+        and then\n+          Nkind (First (Statements (Handled_Statement_Sequence (Orig_Bod))))\n+            = N_Extended_Return_Statement\n+      then\n+         return;\n       end if;\n \n       if Nkind (Orig_Bod) = N_Defining_Identifier"}, {"sha": "901ee2bc1f8a1c8d722924865de73bb205b10680", "filename": "gcc/ada/gcc-interface/Makefile.in", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e761d11c7d31ef7adc8b58865fe7627d154cec3e/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e761d11c7d31ef7adc8b58865fe7627d154cec3e/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMakefile.in?ref=e761d11c7d31ef7adc8b58865fe7627d154cec3e", "patch": "@@ -1515,6 +1515,8 @@ ifeq ($(strip $(filter-out alpha64 ia64 dec hp vms% openvms% alphavms%,$(targ)))\n     s-memory.ads<s-memory-vms_64.ads \\\n     s-osprim.adb<s-osprim-vms.adb \\\n     s-osprim.ads<s-osprim-vms.ads \\\n+    s-osinte.adb<s-osinte-vms.adb \\\n+    s-osinte.ads<s-osinte-vms.ads \\\n     s-taprop.adb<s-taprop-vms.adb \\\n     s-tasdeb.adb<s-tasdeb-vms.adb \\\n     s-taspri.ads<s-taspri-vms.ads \\\n@@ -1528,8 +1530,6 @@ ifeq ($(strip $(filter-out alpha64 ia64 dec hp vms% openvms% alphavms%,$(targ)))\n       g-trasym.adb<g-trasym-vms-ia64.adb \\\n       s-asthan.adb<s-asthan-vms-ia64.adb \\\n       s-auxdec.adb<s-auxdec-vms-ia64.adb \\\n-      s-osinte.adb<s-osinte-vms-ia64.adb \\\n-      s-osinte.ads<s-osinte-vms-ia64.ads \\\n       s-vaflop.adb<s-vaflop-vms-ia64.adb \\\n       system.ads<system-vms-ia64.ads \\\n       s-parame.ads<s-parame-vms-ia64.ads \\\n@@ -1547,8 +1547,6 @@ ifeq ($(strip $(filter-out alpha64 ia64 dec hp vms% openvms% alphavms%,$(targ)))\n         g-trasym.adb<g-trasym-vms-alpha.adb \\\n         s-asthan.adb<s-asthan-vms-alpha.adb \\\n         s-auxdec.adb<s-auxdec-vms-alpha.adb \\\n-        s-osinte.adb<s-osinte-vms.adb \\\n-        s-osinte.ads<s-osinte-vms.ads \\\n         s-traent.adb<s-traent-vms.adb \\\n         s-traent.ads<s-traent-vms.ads \\\n         s-vaflop.adb<s-vaflop-vms-alpha.adb \\"}, {"sha": "3d9e4bffdd40d925494d2d54783a281c430e4121", "filename": "gcc/ada/s-gearop.adb", "status": "modified", "additions": 163, "deletions": 193, "changes": 356, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e761d11c7d31ef7adc8b58865fe7627d154cec3e/gcc%2Fada%2Fs-gearop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e761d11c7d31ef7adc8b58865fe7627d154cec3e/gcc%2Fada%2Fs-gearop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-gearop.adb?ref=e761d11c7d31ef7adc8b58865fe7627d154cec3e", "patch": "@@ -51,14 +51,12 @@ package body System.Generic_Array_Operations is\n \n    function Diagonal (A : Matrix) return Vector is\n       N : constant Natural := Natural'Min (A'Length (1), A'Length (2));\n-      R : Vector (A'First (1) .. A'First (1) + N - 1);\n-\n    begin\n-      for J in 0 .. N - 1 loop\n-         R (R'First + J) := A (A'First (1) + J, A'First (2) + J);\n-      end loop;\n-\n-      return R;\n+      return R : Vector (A'First (1) .. A'First (1) + N - 1) do\n+         for J in 0 .. N - 1 loop\n+            R (R'First + J) := A (A'First (1) + J, A'First (2) + J);\n+         end loop;\n+      end return;\n    end Diagonal;\n \n    --------------------------\n@@ -386,31 +384,27 @@ package body System.Generic_Array_Operations is\n    ----------------------------------\n \n    function Matrix_Elementwise_Operation (X : X_Matrix) return Result_Matrix is\n-      R : Result_Matrix (X'Range (1), X'Range (2));\n-\n    begin\n-      for J in R'Range (1) loop\n-         for K in R'Range (2) loop\n-            R (J, K) := Operation (X (J, K));\n+      return R : Result_Matrix (X'Range (1), X'Range (2)) do\n+         for J in R'Range (1) loop\n+            for K in R'Range (2) loop\n+               R (J, K) := Operation (X (J, K));\n+            end loop;\n          end loop;\n-      end loop;\n-\n-      return R;\n+      end return;\n    end Matrix_Elementwise_Operation;\n \n    ----------------------------------\n    -- Vector_Elementwise_Operation --\n    ----------------------------------\n \n    function Vector_Elementwise_Operation (X : X_Vector) return Result_Vector is\n-      R : Result_Vector (X'Range);\n-\n    begin\n-      for J in R'Range loop\n-         R (J) := Operation (X (J));\n-      end loop;\n-\n-      return R;\n+      return R : Result_Vector (X'Range) do\n+         for J in R'Range loop\n+            R (J) := Operation (X (J));\n+         end loop;\n+      end return;\n    end Vector_Elementwise_Operation;\n \n    -----------------------------------------\n@@ -421,29 +415,27 @@ package body System.Generic_Array_Operations is\n      (Left  : Left_Matrix;\n       Right : Right_Matrix) return Result_Matrix\n    is\n-      R : Result_Matrix (Left'Range (1), Left'Range (2));\n-\n    begin\n-      if Left'Length (1) /= Right'Length (1)\n+      return R : Result_Matrix (Left'Range (1), Left'Range (2)) do\n+         if Left'Length (1) /= Right'Length (1)\n            or else\n-         Left'Length (2) /= Right'Length (2)\n-      then\n-         raise Constraint_Error with\n-           \"matrices are of different dimension in elementwise operation\";\n-      end if;\n+             Left'Length (2) /= Right'Length (2)\n+         then\n+            raise Constraint_Error with\n+              \"matrices are of different dimension in elementwise operation\";\n+         end if;\n \n-      for J in R'Range (1) loop\n-         for K in R'Range (2) loop\n-            R (J, K) :=\n-              Operation\n-                (Left (J, K),\n-                 Right\n-                   (J - R'First (1) + Right'First (1),\n-                    K - R'First (2) + Right'First (2)));\n+         for J in R'Range (1) loop\n+            for K in R'Range (2) loop\n+               R (J, K) :=\n+                 Operation\n+                   (Left (J, K),\n+                    Right\n+                      (J - R'First (1) + Right'First (1),\n+                       K - R'First (2) + Right'First (2)));\n+            end loop;\n          end loop;\n-      end loop;\n-\n-      return R;\n+      end return;\n    end Matrix_Matrix_Elementwise_Operation;\n \n    ------------------------------------------------\n@@ -453,31 +445,28 @@ package body System.Generic_Array_Operations is\n    function Matrix_Matrix_Scalar_Elementwise_Operation\n      (X    : X_Matrix;\n       Y    : Y_Matrix;\n-      Z    : Z_Scalar) return Result_Matrix\n-   is\n-      R : Result_Matrix (X'Range (1), X'Range (2));\n-\n+      Z    : Z_Scalar) return Result_Matrix is\n    begin\n-      if X'Length (1) /= Y'Length (1)\n+      return R : Result_Matrix (X'Range (1), X'Range (2)) do\n+         if X'Length (1) /= Y'Length (1)\n            or else\n-         X'Length (2) /= Y'Length (2)\n-      then\n-         raise Constraint_Error with\n-           \"matrices are of different dimension in elementwise operation\";\n-      end if;\n+             X'Length (2) /= Y'Length (2)\n+         then\n+            raise Constraint_Error with\n+              \"matrices are of different dimension in elementwise operation\";\n+         end if;\n \n-      for J in R'Range (1) loop\n-         for K in R'Range (2) loop\n-            R (J, K) :=\n-              Operation\n-                (X (J, K),\n-                 Y (J - R'First (1) + Y'First (1),\n-                    K - R'First (2) + Y'First (2)),\n-                 Z);\n+         for J in R'Range (1) loop\n+            for K in R'Range (2) loop\n+               R (J, K) :=\n+                 Operation\n+                   (X (J, K),\n+                    Y (J - R'First (1) + Y'First (1),\n+                       K - R'First (2) + Y'First (2)),\n+                    Z);\n+            end loop;\n          end loop;\n-      end loop;\n-\n-      return R;\n+      end return;\n    end Matrix_Matrix_Scalar_Elementwise_Operation;\n \n    -----------------------------------------\n@@ -488,19 +477,17 @@ package body System.Generic_Array_Operations is\n      (Left  : Left_Vector;\n       Right : Right_Vector) return Result_Vector\n    is\n-      R : Result_Vector (Left'Range);\n-\n    begin\n-      if Left'Length /= Right'Length then\n-         raise Constraint_Error with\n-           \"vectors are of different length in elementwise operation\";\n-      end if;\n-\n-      for J in R'Range loop\n-         R (J) := Operation (Left (J), Right (J - R'First + Right'First));\n-      end loop;\n+      return R : Result_Vector (Left'Range) do\n+         if Left'Length /= Right'Length then\n+            raise Constraint_Error with\n+              \"vectors are of different length in elementwise operation\";\n+         end if;\n \n-      return R;\n+         for J in R'Range loop\n+            R (J) := Operation (Left (J), Right (J - R'First + Right'First));\n+         end loop;\n+      end return;\n    end Vector_Vector_Elementwise_Operation;\n \n    ------------------------------------------------\n@@ -510,21 +497,18 @@ package body System.Generic_Array_Operations is\n    function Vector_Vector_Scalar_Elementwise_Operation\n      (X : X_Vector;\n       Y : Y_Vector;\n-      Z : Z_Scalar) return Result_Vector\n-   is\n-      R : Result_Vector (X'Range);\n-\n+      Z : Z_Scalar) return Result_Vector is\n    begin\n-      if X'Length /= Y'Length then\n-         raise Constraint_Error with\n-           \"vectors are of different length in elementwise operation\";\n-      end if;\n-\n-      for J in R'Range loop\n-         R (J) := Operation (X (J), Y (J - X'First + Y'First), Z);\n-      end loop;\n+      return R : Result_Vector (X'Range) do\n+         if X'Length /= Y'Length then\n+            raise Constraint_Error with\n+              \"vectors are of different length in elementwise operation\";\n+         end if;\n \n-      return R;\n+         for J in R'Range loop\n+            R (J) := Operation (X (J), Y (J - X'First + Y'First), Z);\n+         end loop;\n+      end return;\n    end Vector_Vector_Scalar_Elementwise_Operation;\n \n    -----------------------------------------\n@@ -535,16 +519,14 @@ package body System.Generic_Array_Operations is\n      (Left  : Left_Matrix;\n       Right : Right_Scalar) return Result_Matrix\n    is\n-      R : Result_Matrix (Left'Range (1), Left'Range (2));\n-\n    begin\n-      for J in R'Range (1) loop\n-         for K in R'Range (2) loop\n-            R (J, K) := Operation (Left (J, K), Right);\n+      return R : Result_Matrix (Left'Range (1), Left'Range (2)) do\n+         for J in R'Range (1) loop\n+            for K in R'Range (2) loop\n+               R (J, K) := Operation (Left (J, K), Right);\n+            end loop;\n          end loop;\n-      end loop;\n-\n-      return R;\n+      end return;\n    end Matrix_Scalar_Elementwise_Operation;\n \n    -----------------------------------------\n@@ -555,14 +537,12 @@ package body System.Generic_Array_Operations is\n      (Left  : Left_Vector;\n       Right : Right_Scalar) return Result_Vector\n    is\n-      R : Result_Vector (Left'Range);\n-\n    begin\n-      for J in R'Range loop\n-         R (J) := Operation (Left (J), Right);\n-      end loop;\n-\n-      return R;\n+      return R : Result_Vector (Left'Range) do\n+         for J in R'Range loop\n+            R (J) := Operation (Left (J), Right);\n+         end loop;\n+      end return;\n    end Vector_Scalar_Elementwise_Operation;\n \n    -----------------------------------------\n@@ -573,16 +553,14 @@ package body System.Generic_Array_Operations is\n      (Left  : Left_Scalar;\n       Right : Right_Matrix) return Result_Matrix\n    is\n-      R : Result_Matrix (Right'Range (1), Right'Range (2));\n-\n    begin\n-      for J in R'Range (1) loop\n-         for K in R'Range (2) loop\n-            R (J, K) := Operation (Left, Right (J, K));\n+      return R : Result_Matrix (Right'Range (1), Right'Range (2)) do\n+         for J in R'Range (1) loop\n+            for K in R'Range (2) loop\n+               R (J, K) := Operation (Left, Right (J, K));\n+            end loop;\n          end loop;\n-      end loop;\n-\n-      return R;\n+      end return;\n    end Scalar_Matrix_Elementwise_Operation;\n \n    -----------------------------------------\n@@ -593,14 +571,12 @@ package body System.Generic_Array_Operations is\n      (Left  : Left_Scalar;\n       Right : Right_Vector) return Result_Vector\n    is\n-      R : Result_Vector (Right'Range);\n-\n    begin\n-      for J in R'Range loop\n-         R (J) := Operation (Left, Right (J));\n-      end loop;\n-\n-      return R;\n+      return R : Result_Vector (Right'Range) do\n+         for J in R'Range loop\n+            R (J) := Operation (Left, Right (J));\n+         end loop;\n+      end return;\n    end Scalar_Vector_Elementwise_Operation;\n \n    ----------\n@@ -662,31 +638,30 @@ package body System.Generic_Array_Operations is\n      (Left  : Left_Matrix;\n       Right : Right_Matrix) return Result_Matrix\n    is\n-      R : Result_Matrix (Left'Range (1), Right'Range (2));\n-\n    begin\n-      if Left'Length (2) /= Right'Length (1) then\n-         raise Constraint_Error with\n-           \"incompatible dimensions in matrix multiplication\";\n-      end if;\n+      return R : Result_Matrix (Left'Range (1), Right'Range (2)) do\n+         if Left'Length (2) /= Right'Length (1) then\n+            raise Constraint_Error with\n+              \"incompatible dimensions in matrix multiplication\";\n+         end if;\n \n-      for J in R'Range (1) loop\n-         for K in R'Range (2) loop\n-            declare\n-               S : Result_Scalar := Zero;\n+         for J in R'Range (1) loop\n+            for K in R'Range (2) loop\n+               declare\n+                  S : Result_Scalar := Zero;\n \n-            begin\n-               for M in Left'Range (2) loop\n-                  S := S + Left (J, M) *\n-                             Right (M - Left'First (2) + Right'First (1), K);\n-               end loop;\n+               begin\n+                  for M in Left'Range (2) loop\n+                     S := S + Left (J, M) *\n+                                Right\n+                                  (M - Left'First (2) + Right'First (1), K);\n+                  end loop;\n \n-               R (J, K) := S;\n-            end;\n+                  R (J, K) := S;\n+               end;\n+            end loop;\n          end loop;\n-      end loop;\n-\n-      return R;\n+      end return;\n    end  Matrix_Matrix_Product;\n \n    ----------------------------\n@@ -766,28 +741,27 @@ package body System.Generic_Array_Operations is\n      (Left  : Matrix;\n       Right : Right_Vector) return Result_Vector\n    is\n-      R : Result_Vector (Left'Range (1));\n-\n    begin\n-      if Left'Length (2) /= Right'Length then\n-         raise Constraint_Error with\n-            \"incompatible dimensions in matrix-vector multiplication\";\n-      end if;\n-\n-      for J in Left'Range (1) loop\n-         declare\n-            S : Result_Scalar := Zero;\n+      return R : Result_Vector (Left'Range (1)) do\n+         if Left'Length (2) /= Right'Length then\n+            raise Constraint_Error with\n+              \"incompatible dimensions in matrix-vector multiplication\";\n+         end if;\n \n-         begin\n-            for K in Left'Range (2) loop\n-               S := S + Left (J, K) * Right (K - Left'First (2) + Right'First);\n-            end loop;\n+         for J in Left'Range (1) loop\n+            declare\n+               S : Result_Scalar := Zero;\n \n-            R (J) := S;\n-         end;\n-      end loop;\n+            begin\n+               for K in Left'Range (2) loop\n+                  S := S + Left (J, K)\n+                         * Right (K - Left'First (2) + Right'First);\n+               end loop;\n \n-      return R;\n+               R (J) := S;\n+            end;\n+         end loop;\n+      end return;\n    end Matrix_Vector_Product;\n \n    -------------------\n@@ -798,16 +772,14 @@ package body System.Generic_Array_Operations is\n      (Left  : Left_Vector;\n       Right : Right_Vector) return Matrix\n    is\n-      R : Matrix (Left'Range, Right'Range);\n-\n    begin\n-      for J in R'Range (1) loop\n-         for K in R'Range (2) loop\n-            R (J, K) := Left (J) * Right (K);\n+      return R : Matrix (Left'Range, Right'Range) do\n+         for J in R'Range (1) loop\n+            for K in R'Range (2) loop\n+               R (J, K) := Left (J) * Right (K);\n+            end loop;\n          end loop;\n-      end loop;\n-\n-      return R;\n+      end return;\n    end Outer_Product;\n \n    -----------------\n@@ -884,17 +856,16 @@ package body System.Generic_Array_Operations is\n       First_1 : Integer := 1;\n       First_2 : Integer := 1) return Matrix\n    is\n-      R : Matrix (First_1 .. Check_Unit_Last (First_1, Order, First_1),\n-                  First_2 .. Check_Unit_Last (First_2, Order, First_2));\n-\n    begin\n-      R := (others => (others => Zero));\n+      return R : Matrix (First_1 .. Check_Unit_Last (First_1, Order, First_1),\n+                         First_2 .. Check_Unit_Last (First_2, Order, First_2))\n+      do\n+         R := (others => (others => Zero));\n \n-      for J in 0 .. Order - 1 loop\n-         R (First_1 + J, First_2 + J) := One;\n-      end loop;\n-\n-      return R;\n+         for J in 0 .. Order - 1 loop\n+            R (First_1 + J, First_2 + J) := One;\n+         end loop;\n+      end return;\n    end Unit_Matrix;\n \n    -----------------\n@@ -906,11 +877,11 @@ package body System.Generic_Array_Operations is\n       Order : Positive;\n       First : Integer := 1) return Vector\n    is\n-      R : Vector (First .. Check_Unit_Last (Index, Order, First));\n    begin\n-      R := (others => Zero);\n-      R (Index) := One;\n-      return R;\n+      return R : Vector (First .. Check_Unit_Last (Index, Order, First)) do\n+         R := (others => Zero);\n+         R (Index) := One;\n+      end return;\n    end Unit_Vector;\n \n    ---------------------------\n@@ -921,28 +892,27 @@ package body System.Generic_Array_Operations is\n      (Left  : Left_Vector;\n       Right : Matrix) return Result_Vector\n    is\n-      R : Result_Vector (Right'Range (2));\n-\n    begin\n-      if Left'Length /= Right'Length (2) then\n-         raise Constraint_Error with\n-           \"incompatible dimensions in vector-matrix multiplication\";\n-      end if;\n-\n-      for J in Right'Range (2) loop\n-         declare\n-            S : Result_Scalar := Zero;\n+      return R : Result_Vector (Right'Range (2)) do\n+         if Left'Length /= Right'Length (2) then\n+            raise Constraint_Error with\n+              \"incompatible dimensions in vector-matrix multiplication\";\n+         end if;\n \n-         begin\n-            for K in Right'Range (1) loop\n-               S := S + Left (J - Right'First (1) + Left'First) * Right (K, J);\n-            end loop;\n+         for J in Right'Range (2) loop\n+            declare\n+               S : Result_Scalar := Zero;\n \n-            R (J) := S;\n-         end;\n-      end loop;\n+            begin\n+               for K in Right'Range (1) loop\n+                  S := S + Left (J - Right'First (1)\n+                                   + Left'First) * Right (K, J);\n+               end loop;\n \n-      return R;\n+               R (J) := S;\n+            end;\n+         end loop;\n+      end return;\n    end Vector_Matrix_Product;\n \n end System.Generic_Array_Operations;"}, {"sha": "e37d3d20b2f06e2dd416ebd45bbbc3234ae03b1c", "filename": "gcc/ada/s-osinte-vms-ia64.adb", "status": "removed", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62db841a08b9e833bd30e5fe7d8de00d5a250b74/gcc%2Fada%2Fs-osinte-vms-ia64.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62db841a08b9e833bd30e5fe7d8de00d5a250b74/gcc%2Fada%2Fs-osinte-vms-ia64.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-vms-ia64.adb?ref=62db841a08b9e833bd30e5fe7d8de00d5a250b74", "patch": "@@ -1,58 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n---                                                                          --\n---                   S Y S T E M . O S _ I N T E R F A C E                  --\n---                                                                          --\n---                                  B o d y                                 --\n---                                                                          --\n---          Copyright (C) 2003-2010, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNARL was developed by the GNARL team at Florida State University.       --\n--- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is a OpenVMS/IA64 version of this package\n-\n---  This package encapsulates all direct interfaces to OS services\n---  that are needed by children of System.\n-\n-pragma Polling (Off);\n---  Turn off polling, we do not want ATC polling to take place during\n---  tasking operations. It causes infinite loops and other problems.\n-\n-with Interfaces.C; use Interfaces.C;\n-\n-package body System.OS_Interface is\n-\n-   -----------------\n-   -- sched_yield --\n-   -----------------\n-\n-   function sched_yield return int is\n-      procedure sched_yield_base;\n-      pragma Import (C, sched_yield_base, \"PTHREAD_YIELD_NP\");\n-\n-   begin\n-      sched_yield_base;\n-      return 0;\n-   end sched_yield;\n-\n-end System.OS_Interface;"}, {"sha": "99b91aa345577db5082ccbb70d85405f56e86d87", "filename": "gcc/ada/s-osinte-vms-ia64.ads", "status": "removed", "additions": 0, "deletions": 652, "changes": 652, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62db841a08b9e833bd30e5fe7d8de00d5a250b74/gcc%2Fada%2Fs-osinte-vms-ia64.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62db841a08b9e833bd30e5fe7d8de00d5a250b74/gcc%2Fada%2Fs-osinte-vms-ia64.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-vms-ia64.ads?ref=62db841a08b9e833bd30e5fe7d8de00d5a250b74", "patch": "@@ -1,652 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n---                                                                          --\n---                   S Y S T E M . O S _ I N T E R F A C E                  --\n---                                                                          --\n---                                  S p e c                                 --\n---                                                                          --\n---             Copyright (C) 1991-1994, Florida State University            --\n---          Copyright (C) 1995-2010, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNARL was developed by the GNARL team at Florida State University.       --\n--- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is a OpenVMS/IA64 version of this package\n-\n---  This package encapsulates all direct interfaces to OS services\n---  that are needed by the tasking run-time (libgnarl).\n-\n---  PLEASE DO NOT add any with-clauses to this package or remove the pragma\n---  Preelaborate. This package is designed to be a bottom-level (leaf) package.\n-\n-with Interfaces.C;\n-\n-with Ada.Unchecked_Conversion;\n-\n-with System.Aux_DEC;\n-\n-package System.OS_Interface is\n-   pragma Preelaborate;\n-\n-   pragma Linker_Options (\"--for-linker=ia64$library:pthread$rtl.exe\");\n-   --  Link in the DEC threads library\n-\n-   --  pragma Linker_Options (\"--for-linker=/threads_enable\");\n-   --  Enable upcalls and multiple kernel threads.\n-\n-   subtype int            is Interfaces.C.int;\n-   subtype short          is Interfaces.C.short;\n-   subtype long           is Interfaces.C.long;\n-   subtype unsigned       is Interfaces.C.unsigned;\n-   subtype unsigned_short is Interfaces.C.unsigned_short;\n-   subtype unsigned_long  is Interfaces.C.unsigned_long;\n-   subtype unsigned_char  is Interfaces.C.unsigned_char;\n-   subtype plain_char     is Interfaces.C.plain_char;\n-   subtype size_t         is Interfaces.C.size_t;\n-\n-   -----------------------------\n-   -- Signals (Interrupt IDs) --\n-   -----------------------------\n-\n-   --  Type signal has an arbitrary limit of 31\n-\n-   Max_Interrupt : constant := 31;\n-   type Signal is new unsigned range 0 .. Max_Interrupt;\n-   for Signal'Size use unsigned'Size;\n-\n-   type sigset_t is array (Signal) of Boolean;\n-   pragma Pack (sigset_t);\n-\n-   --  Interrupt_Number_Type\n-   --  Unsigned long integer denoting the number of an interrupt\n-\n-   subtype Interrupt_Number_Type is unsigned_long;\n-\n-   --  OpenVMS system services return values of type Cond_Value_Type\n-\n-   subtype Cond_Value_Type is unsigned_long;\n-   subtype Short_Cond_Value_Type is unsigned_short;\n-\n-   type IO_Status_Block_Type is record\n-      Status   : Short_Cond_Value_Type;\n-      Count    : unsigned_short;\n-      Dev_Info : unsigned_long;\n-   end record;\n-\n-   type AST_Handler is access procedure (Param : Address);\n-   pragma Convention (C, AST_Handler);\n-   No_AST_Handler : constant AST_Handler := null;\n-\n-   CMB_M_READONLY  : constant := 16#00000001#;\n-   CMB_M_WRITEONLY : constant := 16#00000002#;\n-   AGN_M_READONLY  : constant := 16#00000001#;\n-   AGN_M_WRITEONLY : constant := 16#00000002#;\n-\n-   IO_WRITEVBLK : constant := 48;  --  WRITE VIRTUAL BLOCK\n-   IO_READVBLK  : constant := 49;  --  READ VIRTUAL BLOCK\n-\n-   ----------------\n-   -- Sys_Assign --\n-   ----------------\n-   --\n-   --  Assign I/O Channel\n-   --\n-   --  Status = returned status\n-   --  Devnam = address  of  device  name  or  logical  name   string\n-   --               descriptor\n-   --  Chan   = address of word to receive channel number assigned\n-   --  Acmode = access mode associated with channel\n-   --  Mbxnam = address of mailbox logical name string descriptor, if\n-   --               mailbox associated with device\n-   --  Flags  = optional channel flags longword for specifying options\n-   --           for the $ASSIGN operation\n-   --\n-\n-   procedure Sys_Assign\n-     (Status : out Cond_Value_Type;\n-      Devnam : String;\n-      Chan   : out unsigned_short;\n-      Acmode : unsigned_short := 0;\n-      Mbxnam : String := String'Null_Parameter;\n-      Flags  : unsigned_long := 0);\n-   pragma Interface (External, Sys_Assign);\n-   pragma Import_Valued_Procedure\n-     (Sys_Assign, \"SYS$ASSIGN\",\n-      (Cond_Value_Type, String,         unsigned_short,\n-       unsigned_short,  String,         unsigned_long),\n-      (Value,           Descriptor (s), Reference,\n-       Value,           Descriptor (s), Value),\n-      Flags);\n-\n-   ----------------\n-   -- Sys_Cantim --\n-   ----------------\n-   --\n-   --  Cancel Timer\n-   --\n-   --  Status  = returned status\n-   --  Reqidt  = ID of timer to be cancelled\n-   --  Acmode  = Access mode\n-   --\n-   procedure Sys_Cantim\n-     (Status : out Cond_Value_Type;\n-      Reqidt : Address;\n-      Acmode : unsigned);\n-   pragma Interface (External, Sys_Cantim);\n-   pragma Import_Valued_Procedure\n-     (Sys_Cantim, \"SYS$CANTIM\",\n-      (Cond_Value_Type, Address, unsigned),\n-      (Value,           Value,   Value));\n-\n-   ----------------\n-   -- Sys_Crembx --\n-   ----------------\n-   --\n-   --  Create mailbox\n-   --\n-   --     Status  = returned status\n-   --     Prmflg  = permanent flag\n-   --     Chan    = channel\n-   --     Maxmsg  = maximum message\n-   --     Bufquo  = buufer quote\n-   --     Promsk  = protection mast\n-   --     Acmode  = access mode\n-   --     Lognam  = logical name\n-   --     Flags   = flags\n-   --\n-   procedure Sys_Crembx\n-     (Status : out Cond_Value_Type;\n-      Prmflg : unsigned_char;\n-      Chan   : out unsigned_short;\n-      Maxmsg : unsigned_long := 0;\n-      Bufquo : unsigned_long := 0;\n-      Promsk : unsigned_short := 0;\n-      Acmode : unsigned_short := 0;\n-      Lognam : String;\n-      Flags  : unsigned_long := 0);\n-   pragma Interface (External, Sys_Crembx);\n-   pragma Import_Valued_Procedure\n-     (Sys_Crembx, \"SYS$CREMBX\",\n-      (Cond_Value_Type, unsigned_char,  unsigned_short,\n-       unsigned_long,   unsigned_long,  unsigned_short,\n-       unsigned_short,  String,         unsigned_long),\n-      (Value,           Value,          Reference,\n-       Value,           Value,          Value,\n-       Value,           Descriptor (s), Value));\n-\n-   -------------\n-   -- Sys_QIO --\n-   -------------\n-   --\n-   --    Queue I/O\n-   --\n-   --     Status = Returned status of call\n-   --     EFN    = event flag to be set when I/O completes\n-   --     Chan   = channel\n-   --     Func   = function\n-   --     Iosb   = I/O status block\n-   --     Astadr = system trap to be generated when I/O completes\n-   --     Astprm = AST parameter\n-   --     P1-6   = optional parameters\n-\n-   procedure Sys_QIO\n-     (Status : out Cond_Value_Type;\n-      EFN    : unsigned_long := 0;\n-      Chan   : unsigned_short;\n-      Func   : unsigned_long := 0;\n-      Iosb   : out IO_Status_Block_Type;\n-      Astadr : AST_Handler := No_AST_Handler;\n-      Astprm : Address := Null_Address;\n-      P1     : unsigned_long := 0;\n-      P2     : unsigned_long := 0;\n-      P3     : unsigned_long := 0;\n-      P4     : unsigned_long := 0;\n-      P5     : unsigned_long := 0;\n-      P6     : unsigned_long := 0);\n-\n-   procedure Sys_QIO\n-     (Status : out Cond_Value_Type;\n-      EFN    : unsigned_long := 0;\n-      Chan   : unsigned_short;\n-      Func   : unsigned_long := 0;\n-      Iosb   : Address := Null_Address;\n-      Astadr : AST_Handler := No_AST_Handler;\n-      Astprm : Address := Null_Address;\n-      P1     : unsigned_long := 0;\n-      P2     : unsigned_long := 0;\n-      P3     : unsigned_long := 0;\n-      P4     : unsigned_long := 0;\n-      P5     : unsigned_long := 0;\n-      P6     : unsigned_long := 0);\n-\n-   pragma Interface (External, Sys_QIO);\n-   pragma Import_Valued_Procedure\n-     (Sys_QIO, \"SYS$QIO\",\n-      (Cond_Value_Type,      unsigned_long, unsigned_short, unsigned_long,\n-       IO_Status_Block_Type, AST_Handler,   Address,\n-       unsigned_long,        unsigned_long, unsigned_long,\n-       unsigned_long,        unsigned_long, unsigned_long),\n-      (Value,                Value,         Value,          Value,\n-       Reference,            Value,         Value,\n-       Value,                Value,         Value,\n-       Value,                Value,         Value));\n-\n-   pragma Import_Valued_Procedure\n-     (Sys_QIO, \"SYS$QIO\",\n-      (Cond_Value_Type, unsigned_long, unsigned_short, unsigned_long,\n-       Address,         AST_Handler,   Address,\n-       unsigned_long,   unsigned_long, unsigned_long,\n-       unsigned_long,   unsigned_long, unsigned_long),\n-      (Value,           Value,         Value,          Value,\n-       Value,           Value,         Value,\n-       Value,           Value,         Value,\n-       Value,           Value,         Value));\n-\n-   ----------------\n-   -- Sys_Setimr --\n-   ----------------\n-   --\n-   --    Set Timer\n-   --\n-   --     Status = Returned status of call\n-   --     EFN    = event flag to be set when timer expires\n-   --     Tim    = expiration time\n-   --     AST    = system trap to be generated when timer expires\n-   --     Redidt = returned ID of timer (e.g. to cancel timer)\n-   --     Flags  = flags\n-   --\n-   procedure Sys_Setimr\n-     (Status : out Cond_Value_Type;\n-      EFN    : unsigned_long;\n-      Tim    : Long_Integer;\n-      AST    : AST_Handler;\n-      Reqidt : Address;\n-      Flags  : unsigned_long);\n-   pragma Interface (External, Sys_Setimr);\n-   pragma Import_Valued_Procedure\n-     (Sys_Setimr, \"SYS$SETIMR\",\n-      (Cond_Value_Type, unsigned_long,     Long_Integer,\n-       AST_Handler,     Address,           unsigned_long),\n-      (Value,           Value,             Reference,\n-       Value,           Value,             Value));\n-\n-   Interrupt_ID_0   : constant  := 0;\n-   Interrupt_ID_1   : constant  := 1;\n-   Interrupt_ID_2   : constant  := 2;\n-   Interrupt_ID_3   : constant  := 3;\n-   Interrupt_ID_4   : constant  := 4;\n-   Interrupt_ID_5   : constant  := 5;\n-   Interrupt_ID_6   : constant  := 6;\n-   Interrupt_ID_7   : constant  := 7;\n-   Interrupt_ID_8   : constant  := 8;\n-   Interrupt_ID_9   : constant  := 9;\n-   Interrupt_ID_10  : constant  := 10;\n-   Interrupt_ID_11  : constant  := 11;\n-   Interrupt_ID_12  : constant  := 12;\n-   Interrupt_ID_13  : constant  := 13;\n-   Interrupt_ID_14  : constant  := 14;\n-   Interrupt_ID_15  : constant  := 15;\n-   Interrupt_ID_16  : constant  := 16;\n-   Interrupt_ID_17  : constant  := 17;\n-   Interrupt_ID_18  : constant  := 18;\n-   Interrupt_ID_19  : constant  := 19;\n-   Interrupt_ID_20  : constant  := 20;\n-   Interrupt_ID_21  : constant  := 21;\n-   Interrupt_ID_22  : constant  := 22;\n-   Interrupt_ID_23  : constant  := 23;\n-   Interrupt_ID_24  : constant  := 24;\n-   Interrupt_ID_25  : constant  := 25;\n-   Interrupt_ID_26  : constant  := 26;\n-   Interrupt_ID_27  : constant  := 27;\n-   Interrupt_ID_28  : constant  := 28;\n-   Interrupt_ID_29  : constant  := 29;\n-   Interrupt_ID_30  : constant  := 30;\n-   Interrupt_ID_31  : constant  := 31;\n-\n-   -----------\n-   -- Errno --\n-   -----------\n-\n-   function errno return int;\n-   pragma Import (C, errno, \"__get_errno\");\n-\n-   EINTR  : constant := 4;   --  Interrupted system call\n-   EAGAIN : constant := 11;  --  No more processes\n-   ENOMEM : constant := 12;  --  Not enough core\n-\n-   -------------------------\n-   -- Priority Scheduling --\n-   -------------------------\n-\n-   SCHED_FIFO  : constant := 1;\n-   SCHED_RR    : constant := 2;\n-   SCHED_OTHER : constant := 3;\n-   SCHED_BG    : constant := 4;\n-   SCHED_LFI   : constant := 5;\n-   SCHED_LRR   : constant := 6;\n-\n-   -------------\n-   -- Process --\n-   -------------\n-\n-   type pid_t is private;\n-\n-   function kill (pid : pid_t; sig : Signal) return int;\n-   pragma Import (C, kill);\n-\n-   function getpid return pid_t;\n-   pragma Import (C, getpid);\n-\n-   -------------\n-   -- Threads --\n-   -------------\n-\n-   type Thread_Body is access\n-     function (arg : System.Address) return System.Address;\n-   pragma Convention (C, Thread_Body);\n-\n-   function Thread_Body_Access is new\n-     Ada.Unchecked_Conversion (System.Aux_DEC.Short_Address, Thread_Body);\n-\n-   type pthread_t           is private;\n-   subtype Thread_Id        is pthread_t;\n-\n-   type pthread_mutex_t     is limited private;\n-   type pthread_cond_t      is limited private;\n-   type pthread_attr_t      is limited private;\n-   type pthread_mutexattr_t is limited private;\n-   type pthread_condattr_t  is limited private;\n-   type pthread_key_t       is private;\n-\n-   PTHREAD_CREATE_JOINABLE     : constant := 0;\n-   PTHREAD_CREATE_DETACHED     : constant := 1;\n-\n-   PTHREAD_CANCEL_DISABLE      : constant := 0;\n-   PTHREAD_CANCEL_ENABLE       : constant := 1;\n-\n-   PTHREAD_CANCEL_DEFERRED     : constant := 0;\n-   PTHREAD_CANCEL_ASYNCHRONOUS : constant := 1;\n-\n-   --  Don't use ERRORCHECK mutexes, they don't work when a thread is not\n-   --  the owner.  AST's, at least, unlock others threads mutexes. Even\n-   --  if the error is ignored, they don't work.\n-   PTHREAD_MUTEX_NORMAL_NP     : constant := 0;\n-   PTHREAD_MUTEX_RECURSIVE_NP  : constant := 1;\n-   PTHREAD_MUTEX_ERRORCHECK_NP : constant := 2;\n-\n-   PTHREAD_INHERIT_SCHED       : constant := 0;\n-   PTHREAD_EXPLICIT_SCHED      : constant := 1;\n-\n-   function pthread_cancel (thread : pthread_t) return int;\n-   pragma Import (C, pthread_cancel, \"PTHREAD_CANCEL\");\n-\n-   procedure pthread_testcancel;\n-   pragma Import (C, pthread_testcancel, \"PTHREAD_TESTCANCEL\");\n-\n-   function pthread_setcancelstate\n-     (newstate : int; oldstate : access int) return int;\n-   pragma Import (C, pthread_setcancelstate, \"PTHREAD_SETCANCELSTATE\");\n-\n-   function pthread_setcanceltype\n-     (newtype : int; oldtype : access int) return int;\n-   pragma Import (C, pthread_setcanceltype, \"PTHREAD_SETCANCELTYPE\");\n-\n-   -------------------------\n-   -- POSIX.1c  Section 3 --\n-   -------------------------\n-\n-   function pthread_lock_global_np return int;\n-   pragma Import (C, pthread_lock_global_np, \"PTHREAD_LOCK_GLOBAL_NP\");\n-\n-   function pthread_unlock_global_np return int;\n-   pragma Import (C, pthread_unlock_global_np, \"PTHREAD_UNLOCK_GLOBAL_NP\");\n-\n-   --------------------------\n-   -- POSIX.1c  Section 11 --\n-   --------------------------\n-\n-   function pthread_mutexattr_init\n-     (attr : access pthread_mutexattr_t) return int;\n-   pragma Import (C, pthread_mutexattr_init, \"PTHREAD_MUTEXATTR_INIT\");\n-\n-   function pthread_mutexattr_destroy\n-     (attr : access pthread_mutexattr_t) return int;\n-   pragma Import (C, pthread_mutexattr_destroy, \"PTHREAD_MUTEXATTR_DESTROY\");\n-\n-   function pthread_mutexattr_settype_np\n-     (attr      : access pthread_mutexattr_t;\n-      mutextype : int) return int;\n-   pragma Import (C, pthread_mutexattr_settype_np,\n-                     \"PTHREAD_MUTEXATTR_SETTYPE_NP\");\n-\n-   function pthread_mutex_init\n-     (mutex : access pthread_mutex_t;\n-      attr  : access pthread_mutexattr_t) return int;\n-   pragma Import (C, pthread_mutex_init, \"PTHREAD_MUTEX_INIT\");\n-\n-   function pthread_mutex_destroy (mutex : access pthread_mutex_t) return int;\n-   pragma Import (C, pthread_mutex_destroy, \"PTHREAD_MUTEX_DESTROY\");\n-\n-   function pthread_mutex_lock (mutex : access pthread_mutex_t) return int;\n-   pragma Import (C, pthread_mutex_lock, \"PTHREAD_MUTEX_LOCK\");\n-\n-   function pthread_mutex_unlock (mutex : access pthread_mutex_t) return int;\n-   pragma Import (C, pthread_mutex_unlock, \"PTHREAD_MUTEX_UNLOCK\");\n-\n-   function pthread_condattr_init\n-     (attr : access pthread_condattr_t) return int;\n-   pragma Import (C, pthread_condattr_init, \"PTHREAD_CONDATTR_INIT\");\n-\n-   function pthread_condattr_destroy\n-     (attr : access pthread_condattr_t) return int;\n-   pragma Import (C, pthread_condattr_destroy, \"PTHREAD_CONDATTR_DESTROY\");\n-\n-   function pthread_cond_init\n-     (cond : access pthread_cond_t;\n-      attr : access pthread_condattr_t) return int;\n-   pragma Import (C, pthread_cond_init, \"PTHREAD_COND_INIT\");\n-\n-   function pthread_cond_destroy (cond : access pthread_cond_t) return int;\n-   pragma Import (C, pthread_cond_destroy, \"PTHREAD_COND_DESTROY\");\n-\n-   function pthread_cond_signal (cond : access pthread_cond_t) return int;\n-   pragma Import (C, pthread_cond_signal, \"PTHREAD_COND_SIGNAL\");\n-\n-   function pthread_cond_signal_int_np\n-     (cond : access pthread_cond_t) return int;\n-   pragma Import (C, pthread_cond_signal_int_np,\n-                  \"PTHREAD_COND_SIGNAL_INT_NP\");\n-\n-   function pthread_cond_wait\n-     (cond  : access pthread_cond_t;\n-      mutex : access pthread_mutex_t) return int;\n-   pragma Import (C, pthread_cond_wait, \"PTHREAD_COND_WAIT\");\n-\n-   --------------------------\n-   -- POSIX.1c  Section 13 --\n-   --------------------------\n-\n-   function pthread_mutexattr_setprotocol\n-     (attr : access pthread_mutexattr_t; protocol : int) return int;\n-   pragma Import (C, pthread_mutexattr_setprotocol,\n-                     \"PTHREAD_MUTEXATTR_SETPROTOCOL\");\n-\n-   type struct_sched_param is record\n-      sched_priority : int;  --  scheduling priority\n-   end record;\n-   for struct_sched_param'Size use 8*4;\n-   pragma Convention (C, struct_sched_param);\n-\n-   function pthread_setschedparam\n-     (thread : pthread_t;\n-      policy : int;\n-      param  : access struct_sched_param) return int;\n-   pragma Import (C, pthread_setschedparam, \"PTHREAD_SETSCHEDPARAM\");\n-\n-   function pthread_attr_setscope\n-     (attr            : access pthread_attr_t;\n-      contentionscope : int) return int;\n-   pragma Import (C, pthread_attr_setscope, \"PTHREAD_ATTR_SETSCOPE\");\n-\n-   function pthread_attr_setinheritsched\n-     (attr            : access pthread_attr_t;\n-      inheritsched : int) return int;\n-   pragma Import (C, pthread_attr_setinheritsched,\n-                     \"PTHREAD_ATTR_SETINHERITSCHED\");\n-\n-   function pthread_attr_setschedpolicy\n-     (attr : access pthread_attr_t; policy : int) return int;\n-   pragma Import (C, pthread_attr_setschedpolicy,\n-                     \"PTHREAD_ATTR_SETSCHEDPOLICY\");\n-\n-   function pthread_attr_setschedparam\n-     (attr        : access pthread_attr_t;\n-      sched_param : int) return int;\n-   pragma Import (C, pthread_attr_setschedparam, \"PTHREAD_ATTR_SETSCHEDPARAM\");\n-\n-   function sched_yield return int;\n-\n-   --------------------------\n-   -- P1003.1c  Section 16 --\n-   --------------------------\n-\n-   function pthread_attr_init (attributes : access pthread_attr_t) return int;\n-   pragma Import (C, pthread_attr_init, \"PTHREAD_ATTR_INIT\");\n-\n-   function pthread_attr_destroy\n-     (attributes : access pthread_attr_t) return int;\n-   pragma Import (C, pthread_attr_destroy, \"PTHREAD_ATTR_DESTROY\");\n-\n-   function pthread_attr_setdetachstate\n-     (attr        : access pthread_attr_t;\n-      detachstate : int) return int;\n-   pragma Import (C, pthread_attr_setdetachstate,\n-                     \"PTHREAD_ATTR_SETDETACHSTATE\");\n-\n-   function pthread_attr_setstacksize\n-     (attr      : access pthread_attr_t;\n-      stacksize : size_t) return int;\n-   pragma Import (C, pthread_attr_setstacksize, \"PTHREAD_ATTR_SETSTACKSIZE\");\n-\n-   function pthread_create\n-     (thread        : access pthread_t;\n-      attributes    : access pthread_attr_t;\n-      start_routine : Thread_Body;\n-      arg           : System.Address) return int;\n-   pragma Import (C, pthread_create, \"PTHREAD_CREATE\");\n-\n-   procedure pthread_exit (status : System.Address);\n-   pragma Import (C, pthread_exit, \"PTHREAD_EXIT\");\n-\n-   function pthread_self return pthread_t;\n-   pragma Import (C, pthread_self, \"PTHREAD_SELF\");\n-   --  ??? This can be inlined, see pthread.h\n-\n-   --------------------------\n-   -- POSIX.1c  Section 17 --\n-   --------------------------\n-\n-   function pthread_setspecific\n-     (key   : pthread_key_t;\n-      value : System.Address) return  int;\n-   pragma Import (C, pthread_setspecific, \"PTHREAD_SETSPECIFIC\");\n-\n-   function pthread_getspecific (key : pthread_key_t) return System.Address;\n-   pragma Import (C, pthread_getspecific, \"PTHREAD_GETSPECIFIC\");\n-\n-   type destructor_pointer is access procedure (arg : System.Address);\n-   pragma Convention (C, destructor_pointer);\n-\n-   function pthread_key_create\n-     (key        : access pthread_key_t;\n-      destructor : destructor_pointer) return int;\n-   pragma Import (C, pthread_key_create, \"PTHREAD_KEY_CREATE\");\n-\n-private\n-\n-   type pid_t is new int;\n-\n-   type pthreadLongAddr_p is mod 2 ** Long_Integer'Size;\n-\n-   type pthreadLongAddr_t is mod 2 ** Long_Integer'Size;\n-   type pthreadLongAddr_t_ptr is mod 2 ** Long_Integer'Size;\n-\n-   type pthreadLongString_t is mod 2 ** Long_Integer'Size;\n-\n-   type pthreadLongUint_t is mod 2 ** Long_Integer'Size;\n-   type pthreadLongUint_array is array (Natural range <>)\n-     of pthreadLongUint_t;\n-\n-   type pthread_t is mod 2 ** Long_Integer'Size;\n-\n-   type pthread_cond_t is record\n-      state    : unsigned;\n-      valid    : unsigned;\n-      name     : pthreadLongString_t;\n-      arg      : unsigned;\n-      sequence : unsigned;\n-      block    : pthreadLongAddr_t_ptr;\n-   end record;\n-   for pthread_cond_t'Size use 8*32;\n-   pragma Convention (C, pthread_cond_t);\n-\n-   type pthread_attr_t is record\n-      valid    : long;\n-      name     : pthreadLongString_t;\n-      arg      : pthreadLongUint_t;\n-      reserved : pthreadLongUint_array (0 .. 18);\n-   end record;\n-   for pthread_attr_t'Size use 8*176;\n-   pragma Convention (C, pthread_attr_t);\n-\n-   type pthread_mutex_t is record\n-      lock     : unsigned;\n-      valid    : unsigned;\n-      name     : pthreadLongString_t;\n-      arg      : unsigned;\n-      sequence : unsigned;\n-      block    : pthreadLongAddr_p;\n-      owner    : unsigned;\n-      depth    : unsigned;\n-   end record;\n-   for pthread_mutex_t'Size use 8*40;\n-   pragma Convention (C, pthread_mutex_t);\n-\n-   type pthread_mutexattr_t is record\n-      valid    : long;\n-      reserved : pthreadLongUint_array (0 .. 14);\n-   end record;\n-   for pthread_mutexattr_t'Size use 8*128;\n-   pragma Convention (C, pthread_mutexattr_t);\n-\n-   type pthread_condattr_t is record\n-      valid    : long;\n-      reserved : pthreadLongUint_array (0 .. 12);\n-   end record;\n-   for pthread_condattr_t'Size use 8*112;\n-   pragma Convention (C, pthread_condattr_t);\n-\n-   type pthread_key_t is new unsigned;\n-\n-   pragma Inline (pthread_self);\n-\n-end System.OS_Interface;"}, {"sha": "ae8fc38c98441530122fec016a5233e71bf7b659", "filename": "gcc/ada/s-osinte-vms.adb", "status": "modified", "additions": 2, "deletions": 20, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e761d11c7d31ef7adc8b58865fe7627d154cec3e/gcc%2Fada%2Fs-osinte-vms.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e761d11c7d31ef7adc8b58865fe7627d154cec3e/gcc%2Fada%2Fs-osinte-vms.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-vms.adb?ref=e761d11c7d31ef7adc8b58865fe7627d154cec3e", "patch": "@@ -7,7 +7,7 @@\n --                                  B o d y                                 --\n --                                                                          --\n --             Copyright (C) 1991-1994, Florida State University            --\n---                     Copyright (C) 1995-2010, AdaCore                     --\n+--                     Copyright (C) 1995-2012, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -30,7 +30,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This is a OpenVMS/Alpha version of this package\n+--  This is the OpenVMS version of this package\n \n --  This package encapsulates all direct interfaces to OS services\n --  that are needed by children of System.\n@@ -40,27 +40,9 @@ pragma Polling (Off);\n --  tasking operations. It causes infinite loops and other problems.\n \n with Interfaces.C; use Interfaces.C;\n-with System.Machine_Code; use System.Machine_Code;\n \n package body System.OS_Interface is\n \n-   ------------------\n-   -- pthread_self --\n-   ------------------\n-\n-   function pthread_self return pthread_t is\n-      use ASCII;\n-      Self : pthread_t;\n-\n-   begin\n-      Asm (\"call_pal 0x9e\" & LF & HT &\n-           \"bis $31, $0, %0\",\n-           Outputs  => pthread_t'Asm_Output (\"=r\", Self),\n-           Clobber  => \"$0\",\n-           Volatile => True);\n-      return Self;\n-   end pthread_self;\n-\n    -----------------\n    -- sched_yield --\n    -----------------"}, {"sha": "e325d0e947c48e4cb8b02ccc8adbfcdaf53a4bd5", "filename": "gcc/ada/s-osinte-vms.ads", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e761d11c7d31ef7adc8b58865fe7627d154cec3e/gcc%2Fada%2Fs-osinte-vms.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e761d11c7d31ef7adc8b58865fe7627d154cec3e/gcc%2Fada%2Fs-osinte-vms.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-vms.ads?ref=e761d11c7d31ef7adc8b58865fe7627d154cec3e", "patch": "@@ -7,7 +7,7 @@\n --                                  S p e c                                 --\n --                                                                          --\n --             Copyright (C) 1991-1994, Florida State University            --\n---          Copyright (C) 1995-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1995-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -30,7 +30,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This is a OpenVMS/Alpha version of this package\n+--  This is the OpenVMS version of this package\n \n --  This package encapsulates all direct interfaces to OS services\n --  that are needed by the tasking run-time (libgnarl).\n@@ -47,9 +47,6 @@ with System.Aux_DEC;\n package System.OS_Interface is\n    pragma Preelaborate;\n \n-   pragma Linker_Options (\"--for-linker=sys$library:pthread$rtl.exe\");\n-   --  Link in the DEC threads library\n-\n    --  pragma Linker_Options (\"--for-linker=/threads_enable\");\n    --  Enable upcalls and multiple kernel threads.\n \n@@ -558,6 +555,7 @@ package System.OS_Interface is\n    pragma Import (C, pthread_exit, \"PTHREAD_EXIT\");\n \n    function pthread_self return pthread_t;\n+   pragma Import (C, pthread_self, \"PTHREAD_SELF\");\n \n    --------------------------\n    -- POSIX.1c  Section 17 --"}, {"sha": "51571720b67d863c6588c80a5e64a802b4269792", "filename": "gcc/ada/s-vaflop-vms-alpha.adb", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e761d11c7d31ef7adc8b58865fe7627d154cec3e/gcc%2Fada%2Fs-vaflop-vms-alpha.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e761d11c7d31ef7adc8b58865fe7627d154cec3e/gcc%2Fada%2Fs-vaflop-vms-alpha.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-vaflop-vms-alpha.adb?ref=e761d11c7d31ef7adc8b58865fe7627d154cec3e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1997-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1997-2012, Free Software Foundation, Inc.         --\n --                       (Version for Alpha OpenVMS)                        --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n@@ -201,15 +201,6 @@ package body System.Vax_Float_Operations is\n       return B;\n    end S_To_F;\n \n-   ------------\n-   -- T_To_D --\n-   ------------\n-\n-   function T_To_D (X : T) return D is\n-   begin\n-      return G_To_D (T_To_G (X));\n-   end T_To_D;\n-\n    ------------\n    -- T_To_G --\n    ------------\n@@ -223,6 +214,15 @@ package body System.Vax_Float_Operations is\n       return B;\n    end T_To_G;\n \n+   ------------\n+   -- T_To_D --\n+   ------------\n+\n+   function T_To_D (X : T) return D is\n+   begin\n+      return G_To_D (T_To_G (X));\n+   end T_To_D;\n+\n    -----------\n    -- Abs_F --\n    -----------"}, {"sha": "221506f244053d3de5d9e74c724282c17deba2d7", "filename": "gcc/ada/s-vaflop.adb", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e761d11c7d31ef7adc8b58865fe7627d154cec3e/gcc%2Fada%2Fs-vaflop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e761d11c7d31ef7adc8b58865fe7627d154cec3e/gcc%2Fada%2Fs-vaflop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-vaflop.adb?ref=e761d11c7d31ef7adc8b58865fe7627d154cec3e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1997-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1997-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -444,22 +444,22 @@ package body System.Vax_Float_Operations is\n    end Sub_G;\n \n    ------------\n-   -- T_To_D --\n+   -- T_To_G --\n    ------------\n \n-   function T_To_D (X : T) return D is\n+   function T_To_G (X : T) return G is\n    begin\n-      return G_To_D (T_To_G (X));\n-   end T_To_D;\n+      return G (X);\n+   end T_To_G;\n \n    ------------\n-   -- T_To_G --\n+   -- T_To_D --\n    ------------\n \n-   function T_To_G (X : T) return G is\n+   function T_To_D (X : T) return D is\n    begin\n-      return G (X);\n-   end T_To_G;\n+      return G_To_D (T_To_G (X));\n+   end T_To_D;\n \n    -------------\n    -- Valid_D --"}, {"sha": "e776b58d80d96ba38f33c3e197000f4a28d4a0c0", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 5, "deletions": 17, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e761d11c7d31ef7adc8b58865fe7627d154cec3e/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e761d11c7d31ef7adc8b58865fe7627d154cec3e/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=e761d11c7d31ef7adc8b58865fe7627d154cec3e", "patch": "@@ -1654,10 +1654,9 @@ package body Sem_Ch5 is\n            (Original_Bound : Node_Id;\n             Analyzed_Bound : Node_Id) return Node_Id\n          is\n-            Assign : Node_Id;\n-            Id     : Entity_Id;\n-            Decl   : Node_Id;\n-\n+            Assign        : Node_Id;\n+            Decl          : Node_Id;\n+            Id            : Entity_Id;\n          begin\n             --  If the bound is a constant or an object, no need for a separate\n             --  declaration. If the bound is the result of previous expansion\n@@ -1677,10 +1676,6 @@ package body Sem_Ch5 is\n                return Original_Bound;\n             end if;\n \n-            --  Here we need to capture the value\n-\n-            Analyze_And_Resolve (Original_Bound, Typ);\n-\n             --  Normally, the best approach is simply to generate a constant\n             --  declaration that captures the bound. However, there is a nasty\n             --  case where this is wrong. If the bound is complex, and has a\n@@ -1692,7 +1687,8 @@ package body Sem_Ch5 is\n             --  proper trace of the value, useful in optimizations that get rid\n             --  of junk range checks.\n \n-            if not Has_Call_Using_Secondary_Stack (Original_Bound) then\n+            if not Has_Call_Using_Secondary_Stack (Analyzed_Bound) then\n+               Analyze_And_Resolve (Original_Bound, Typ);\n                Force_Evaluation (Original_Bound);\n                return Original_Bound;\n             end if;\n@@ -1712,14 +1708,6 @@ package body Sem_Ch5 is\n                 Name        => New_Occurrence_Of (Id, Loc),\n                 Expression  => Relocate_Node (Original_Bound));\n \n-            --  We must recursively clean in the relocated expression the flag\n-            --  analyzed to ensure that the expression is reanalyzed. Required\n-            --  to ensure that the transient scope is established now (because\n-            --  Establish_Transient_Scope discarded generating transient scopes\n-            --  in the analysis of the iteration scheme).\n-\n-            Reset_Analyzed_Flags (Expression (Assign));\n-\n             Insert_Actions (Parent (N), New_List (Decl, Assign));\n \n             --  Now that this temporary variable is initialized we decorate it"}]}