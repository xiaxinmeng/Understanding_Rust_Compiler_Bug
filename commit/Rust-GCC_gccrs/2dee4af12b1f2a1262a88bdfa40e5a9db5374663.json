{"sha": "2dee4af12b1f2a1262a88bdfa40e5a9db5374663", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmRlZTRhZjEyYjFmMmExMjYyYTg4YmRmYTQwZTVhOWRiNTM3NDY2Mw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2000-11-09T09:07:44Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2000-11-09T09:07:44Z"}, "message": "builtins.c (c_strlen): Use TREE_STRING_LENGTH - 1 for max.\n\n\t* builtins.c (c_strlen): Use TREE_STRING_LENGTH - 1 for max.\n\t(c_getstr): New function.\n\t(expand_builtin_strstr): Do nothing if -fcheck-memory-usage.\n\tIf both arguments are constant string, optimize out.\n\t(expand_builtin_strchr, expand_builtin_strrchr): New functions.\n\t(expand_builtin_strpbrk): Use c_getstr, do nothing if\n\t-fcheck-memory-usage.\n\t(expand_builtin_fputs): Likewise.\n\t(expand_builtin_strcmp): Add MODE argument.\n\tUse even if !HAVE_cmpstrsi.\n\tOptimize the case when both arguments are constant strings.\n\t(expand_builtin): Adjust expand_builtin_strcmp caller.\n\tCall expand_builtin_strchr and expand_builtin_strrchr.\n\t* c-common.c (c_common_nodes_and_builtins): Add strchr and strrchr\n\tbuiltins.\n\t* builtins.def (BUILT_IN_STRRCHR): Add.\n\n\t* gcc.c-torture/execute/string-opt-1.c: Add test for strstr\n\twith both arguments constant strings.\n\t* gcc.c-torture/execute/string-opt-3.c: New test.\n\t* gcc.c-torture/execute/string-opt-4.c: New test.\n\t* gcc.c-torture/execute/string-opt-5.c: New test.\n\nFrom-SVN: r37338", "tree": {"sha": "7e4c441f58d15d9c8077a944d506d9f9d2da8ba7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7e4c441f58d15d9c8077a944d506d9f9d2da8ba7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2dee4af12b1f2a1262a88bdfa40e5a9db5374663", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2dee4af12b1f2a1262a88bdfa40e5a9db5374663", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2dee4af12b1f2a1262a88bdfa40e5a9db5374663", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2dee4af12b1f2a1262a88bdfa40e5a9db5374663/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "54d87db8696d7dd6307ba7f5e54ec27a22d42348", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54d87db8696d7dd6307ba7f5e54ec27a22d42348", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54d87db8696d7dd6307ba7f5e54ec27a22d42348"}], "stats": {"total": 626, "additions": 496, "deletions": 130}, "files": [{"sha": "2f6938dd6e8ffbd695f93bb411678cee429663c4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dee4af12b1f2a1262a88bdfa40e5a9db5374663/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dee4af12b1f2a1262a88bdfa40e5a9db5374663/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2dee4af12b1f2a1262a88bdfa40e5a9db5374663", "patch": "@@ -1,3 +1,22 @@\n+2000-11-09  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* builtins.c (c_strlen): Use TREE_STRING_LENGTH - 1 for max.\n+\t(c_getstr): New function.\n+\t(expand_builtin_strstr): Do nothing if -fcheck-memory-usage.\n+\tIf both arguments are constant string, optimize out.\n+\t(expand_builtin_strchr, expand_builtin_strrchr): New functions.\n+\t(expand_builtin_strpbrk): Use c_getstr, do nothing if\n+\t-fcheck-memory-usage.\n+\t(expand_builtin_fputs): Likewise.\n+\t(expand_builtin_strcmp): Add MODE argument.\n+\tUse even if !HAVE_cmpstrsi.\n+\tOptimize the case when both arguments are constant strings.\n+\t(expand_builtin): Adjust expand_builtin_strcmp caller.\n+\tCall expand_builtin_strchr and expand_builtin_strrchr.\n+\t* c-common.c (c_common_nodes_and_builtins): Add strchr and strrchr\n+\tbuiltins.\n+\t* builtins.def (BUILT_IN_STRRCHR): Add.\n+\n 2000-11-08  Gerald Pfeifer  <pfeifer@dbai.tuwien.ac.at>\n \n \t* fixinc/gnu-regex.c: Rename EGCS LOCAL markers to GCC LOCAL."}, {"sha": "8430a23f82eeb0891daa152e5b4682ea60d48738", "filename": "gcc/builtins.c", "status": "modified", "additions": 282, "deletions": 129, "changes": 411, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dee4af12b1f2a1262a88bdfa40e5a9db5374663/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dee4af12b1f2a1262a88bdfa40e5a9db5374663/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=2dee4af12b1f2a1262a88bdfa40e5a9db5374663", "patch": "@@ -80,6 +80,7 @@ tree (*lang_type_promotes_to) PARAMS ((tree));\n \n static int get_pointer_alignment\tPARAMS ((tree, unsigned));\n static tree c_strlen\t\t\tPARAMS ((tree));\n+static const char *c_getstr\t\tPARAMS ((tree));\n static rtx get_memory_rtx\t\tPARAMS ((tree));\n static int apply_args_size\t\tPARAMS ((void));\n static int apply_result_size\t\tPARAMS ((void));\n@@ -100,8 +101,9 @@ static rtx expand_builtin_va_end\tPARAMS ((tree));\n static rtx expand_builtin_va_copy\tPARAMS ((tree));\n #ifdef HAVE_cmpstrsi\n static rtx expand_builtin_memcmp\tPARAMS ((tree, tree, rtx));\n-static rtx expand_builtin_strcmp\tPARAMS ((tree, rtx));\n #endif\n+static rtx expand_builtin_strcmp\tPARAMS ((tree, rtx,\n+\t\t\t\t\t\t enum machine_mode));\n static rtx expand_builtin_memcpy\tPARAMS ((tree));\n static rtx expand_builtin_strcpy\tPARAMS ((tree));\n static rtx expand_builtin_memset\tPARAMS ((tree));\n@@ -111,6 +113,10 @@ static rtx expand_builtin_strstr\tPARAMS ((tree, rtx,\n \t\t\t\t\t\t enum machine_mode));\n static rtx expand_builtin_strpbrk\tPARAMS ((tree, rtx,\n \t\t\t\t\t\t enum machine_mode));\n+static rtx expand_builtin_strchr\tPARAMS ((tree, rtx,\n+\t\t\t\t\t\t enum machine_mode));\n+static rtx expand_builtin_strrchr\tPARAMS ((tree, rtx,\n+\t\t\t\t\t\t enum machine_mode));\n static rtx expand_builtin_alloca\tPARAMS ((tree, rtx));\n static rtx expand_builtin_ffs\t\tPARAMS ((tree, rtx, rtx));\n static rtx expand_builtin_frame_address\tPARAMS ((tree));\n@@ -210,7 +216,7 @@ c_strlen (src)\n   if (src == 0)\n     return 0;\n \n-  max = TREE_STRING_LENGTH (src);\n+  max = TREE_STRING_LENGTH (src) - 1;\n   ptr = TREE_STRING_POINTER (src);\n \n   if (offset_node && TREE_CODE (offset_node) != INTEGER_CST)\n@@ -263,6 +269,41 @@ c_strlen (src)\n   return ssize_int (strlen (ptr + offset));\n }\n \n+/* Return a char pointer for a C string if it is a string constant\n+   or sum of string constant and integer constant.  */\n+\n+static const char *\n+c_getstr (src)\n+     tree src;\n+{\n+  tree offset_node;\n+  int offset, max;\n+  char *ptr;\n+\n+  src = string_constant (src, &offset_node);\n+  if (src == 0)\n+    return 0;\n+\n+  max = TREE_STRING_LENGTH (src) - 1;\n+  ptr = TREE_STRING_POINTER (src);\n+\n+  if (!offset_node)\n+    offset = 0;\n+  else if (TREE_CODE (offset_node) != INTEGER_CST)\n+    return 0;\n+  else\n+    {\n+      /* Did we get a long long offset?  If so, punt.  */\n+      if (TREE_INT_CST_HIGH (offset_node) != 0)\n+\treturn 0;\n+      offset = TREE_INT_CST_LOW (offset_node);\n+      if (offset < 0 || offset > max)\n+\treturn 0;\n+    }\n+\n+  return (const char *) ptr + offset;\n+}\n+\n /* Given TEM, a pointer to a stack frame, follow the dynamic chain COUNT\n    times to get the address of either a higher stack frame, or a return\n    address located within it (depending on FNDECL_CODE).  */\n@@ -1416,142 +1457,224 @@ expand_builtin_strstr (arglist, target, mode)\n   if (arglist == 0\n       || TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) != POINTER_TYPE\n       || TREE_CHAIN (arglist) == 0\n-      || TREE_CODE (TREE_TYPE (TREE_VALUE (TREE_CHAIN (arglist)))) != POINTER_TYPE)\n+      || TREE_CODE (TREE_TYPE (TREE_VALUE (TREE_CHAIN (arglist)))) != POINTER_TYPE\n+      || current_function_check_memory_usage)\n     return 0;\n   else\n     {\n       tree s1 = TREE_VALUE (arglist), s2 = TREE_VALUE (TREE_CHAIN (arglist));\n-      tree len = c_strlen (s2);\n+      tree call_expr, fn;\n+      const char *p1, *p2;\n \n-      if (!len)\n+      p2 = c_getstr (s2);\n+      if (p2 == NULL)\n \treturn 0;\n \n-      switch (compare_tree_int (len, 1))\n-        {\n-\tcase -1: /* length is 0, return s1.  */\n-\t  return expand_expr (s1, target, mode, EXPAND_NORMAL);\n-\tcase 0: /* length is 1, return strchr(s1, s2[0]).  */\n-\t  {\n-\t    tree call_expr, fn = built_in_decls[BUILT_IN_STRCHR];\n+      p1 = c_getstr (s1);\n+      if (p1 != NULL)\n+\t{\n+\t  const char *r = strstr (p1, p2);\n \n-\t    if (!fn)\n-\t      return 0;\n-\t    STRIP_NOPS (s2);\n-\t    if (s2 && TREE_CODE (s2) == ADDR_EXPR)\n-\t      s2 = TREE_OPERAND (s2, 0);\n+\t  if (r == NULL)\n+\t    return const0_rtx;\n \n-\t    /* New argument list transforming strstr(s1, s2) to\n-\t       strchr(s1, s2[0]).  */\n-\t    arglist =\n-\t      build_tree_list (NULL_TREE,\n-\t\t\t       build_int_2 (TREE_STRING_POINTER (s2)[0], 0));\n-\t    arglist = tree_cons (NULL_TREE, s1, arglist);\n-\t    call_expr = build1 (ADDR_EXPR,\n-\t\t\t\tbuild_pointer_type (TREE_TYPE (fn)), fn);\n-\t    call_expr = build (CALL_EXPR, TREE_TYPE (TREE_TYPE (fn)),\n-\t\t\t       call_expr, arglist, NULL_TREE);\n-\t    TREE_SIDE_EFFECTS (call_expr) = 1;\n-\t    return expand_expr (call_expr, target, mode, EXPAND_NORMAL);\n-\t  }\n-\tcase 1: /* length is greater than 1, really call strstr.  */\n-\t  return 0;\n-\tdefault:\n-\t  abort();\n+\t  /* Return an offset into the constant string argument.  */\n+\t  return expand_expr (fold (build (PLUS_EXPR, TREE_TYPE (s1),\n+\t\t\t\t\t   s1, ssize_int (r - p1))),\n+\t\t\t      target, mode, EXPAND_NORMAL);\n \t}\n+\n+      if (p2[0] == '\\0')\n+\treturn expand_expr (s1, target, mode, EXPAND_NORMAL);\n+\n+      if (p2[1] != '\\0')\n+\treturn 0;\n+\n+      fn = built_in_decls[BUILT_IN_STRCHR];\n+      if (!fn)\n+\treturn 0;\n+\n+      /* New argument list transforming strstr(s1, s2) to\n+\t strchr(s1, s2[0]).  */\n+      arglist =\n+\tbuild_tree_list (NULL_TREE, build_int_2 (p2[0], 0));\n+      arglist = tree_cons (NULL_TREE, s1, arglist);\n+      call_expr = build1 (ADDR_EXPR,\n+\t\t\t  build_pointer_type (TREE_TYPE (fn)), fn);\n+      call_expr = build (CALL_EXPR, TREE_TYPE (TREE_TYPE (fn)),\n+\t\t\t call_expr, arglist, NULL_TREE);\n+      TREE_SIDE_EFFECTS (call_expr) = 1;\n+      return expand_expr (call_expr, target, mode, EXPAND_NORMAL);\n     }\n }\n \n-/* Expand a call to the strpbrk builtin.  Return 0 if we failed the\n+/* Expand a call to the strchr builtin.  Return 0 if we failed the\n    caller should emit a normal call, otherwise try to get the result\n    in TARGET, if convenient (and in mode MODE if that's convenient).  */\n \n static rtx\n-expand_builtin_strpbrk (arglist, target, mode)\n+expand_builtin_strchr (arglist, target, mode)\n      tree arglist;\n      rtx target;\n      enum machine_mode mode;\n {\n   if (arglist == 0\n       || TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) != POINTER_TYPE\n       || TREE_CHAIN (arglist) == 0\n-      || TREE_CODE (TREE_TYPE (TREE_VALUE (TREE_CHAIN (arglist)))) != POINTER_TYPE)\n+      || TREE_CODE (TREE_TYPE (TREE_VALUE (TREE_CHAIN (arglist)))) != INTEGER_TYPE\n+      || current_function_check_memory_usage)\n     return 0;\n   else\n     {\n       tree s1 = TREE_VALUE (arglist), s2 = TREE_VALUE (TREE_CHAIN (arglist));\n-      tree len1 = c_strlen (s1), len2 = c_strlen (s2);\n-      tree stripped_s1 = s1, stripped_s2 = s2;\n-\n-      STRIP_NOPS (stripped_s1);\n-      if (stripped_s1 && TREE_CODE (stripped_s1) == ADDR_EXPR)\n-\tstripped_s1 = TREE_OPERAND (stripped_s1, 0);\n-      STRIP_NOPS (stripped_s2);\n-      if (stripped_s2 && TREE_CODE (stripped_s2) == ADDR_EXPR)\n-\tstripped_s2 = TREE_OPERAND (stripped_s2, 0);\n-\n-      /* If both arguments are constants, calculate the result now.  */\n-      if (len1 && len2\n-\t  && TREE_CODE (stripped_s1) == STRING_CST\n-\t  && TREE_CODE (stripped_s2) == STRING_CST)\n-        {\n-\t  const char *const result =\n-\t    strpbrk (TREE_STRING_POINTER (stripped_s1),\n-\t\t     TREE_STRING_POINTER (stripped_s2));\n-\n-\t  if (result)\n-\t    {\n-\t      long offset = result - TREE_STRING_POINTER (stripped_s1);\n+      const char *p1;\n \n-\t      /* Return an offset into the constant string argument.  */\n-\t      return expand_expr (fold (build (PLUS_EXPR, TREE_TYPE (s1),\n-\t\t\t\t\t       s1, ssize_int (offset))),\n-\t\t\t\t  target, mode, EXPAND_NORMAL);\n-\t    }\n-\t  else\n+      if (TREE_CODE (s2) != INTEGER_CST)\n+\treturn 0;\n+\n+      p1 = c_getstr (s1);\n+      if (p1 != NULL)\n+\t{\n+\t  const char *r = strchr (p1, (char) TREE_INT_CST_LOW (s2));\n+\n+\t  if (r == NULL)\n \t    return const0_rtx;\n+\n+\t  /* Return an offset into the constant string argument.  */\n+\t  return expand_expr (fold (build (PLUS_EXPR, TREE_TYPE (s1),\n+\t\t\t\t\t   s1, ssize_int (r - p1))),\n+\t\t\t      target, mode, EXPAND_NORMAL);\n \t}\n \n-      /* We must have been able to figure out the second argument's\n-         length to do anything else.  */\n-      if (!len2)\n+      /* FIXME: Should use here strchrM optab so that ports can optimize\n+\t this.  */\n+      return 0;\n+    }\n+}\n+\n+/* Expand a call to the strrchr builtin.  Return 0 if we failed the\n+   caller should emit a normal call, otherwise try to get the result\n+   in TARGET, if convenient (and in mode MODE if that's convenient).  */\n+\n+static rtx\n+expand_builtin_strrchr (arglist, target, mode)\n+     tree arglist;\n+     rtx target;\n+     enum machine_mode mode;\n+{\n+  if (arglist == 0\n+      || TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) != POINTER_TYPE\n+      || TREE_CHAIN (arglist) == 0\n+      || TREE_CODE (TREE_TYPE (TREE_VALUE (TREE_CHAIN (arglist)))) != INTEGER_TYPE\n+      || current_function_check_memory_usage)\n+    return 0;\n+  else\n+    {\n+      tree s1 = TREE_VALUE (arglist), s2 = TREE_VALUE (TREE_CHAIN (arglist));\n+      tree call_expr, fn;\n+      const char *p1;\n+\n+      if (TREE_CODE (s2) != INTEGER_CST)\n \treturn 0;\n \n-      /* OK, handle some cases.  */\n-      switch (compare_tree_int (len2, 1))\n-        {\n-\tcase -1: /* length is 0, return NULL.  */\n-\t  {\n-\t    /* Evaluate and ignore the arguments in case they had\n-\t       side-effects.  */\n-\t    expand_expr (s1, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-\t    expand_expr (s2, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+      p1 = c_getstr (s1);\n+      if (p1 != NULL)\n+\t{\n+\t  const char *r = strrchr (p1, (char) TREE_INT_CST_LOW (s2));\n+\n+\t  if (r == NULL)\n \t    return const0_rtx;\n-\t  }\n-\tcase 0: /* length is 1, return strchr(s1, s2[0]).  */\n-\t  {\n-\t    tree call_expr, fn = built_in_decls[BUILT_IN_STRCHR];\n \n-\t    if (!fn)\n-\t      return 0;\n+\t  /* Return an offset into the constant string argument.  */\n+\t  return expand_expr (fold (build (PLUS_EXPR, TREE_TYPE (s1),\n+\t\t\t\t\t   s1, ssize_int (r - p1))),\n+\t\t\t      target, mode, EXPAND_NORMAL);\n+\t}\n \n-\t    /* New argument list transforming strpbrk(s1, s2) to\n-\t       strchr(s1, s2[0]).  */\n-\t    arglist =\n-\t      build_tree_list (NULL_TREE, build_int_2\n-\t\t\t       (TREE_STRING_POINTER (stripped_s2)[0], 0));\n-\t    arglist = tree_cons (NULL_TREE, s1, arglist);\n-\t    call_expr = build1 (ADDR_EXPR,\n-\t\t\t\tbuild_pointer_type (TREE_TYPE (fn)), fn);\n-\t    call_expr = build (CALL_EXPR, TREE_TYPE (TREE_TYPE (fn)),\n-\t\t\t       call_expr, arglist, NULL_TREE);\n-\t    TREE_SIDE_EFFECTS (call_expr) = 1;\n-\t    return expand_expr (call_expr, target, mode, EXPAND_NORMAL);\n-\t  }\n-\tcase 1: /* length is greater than 1, really call strpbrk.  */\n-\t  return 0;\n-\tdefault:\n-\t  abort();\n+      if (! integer_zerop (s2))\n+\treturn 0;\n+\n+      fn = built_in_decls[BUILT_IN_STRCHR];\n+      if (!fn)\n+\treturn 0;\n+\n+      /* Transform strrchr(s1, '\\0') to strchr(s1, '\\0').  */\n+      call_expr = build1 (ADDR_EXPR,\n+\t\t\t  build_pointer_type (TREE_TYPE (fn)), fn);\n+      call_expr = build (CALL_EXPR, TREE_TYPE (TREE_TYPE (fn)),\n+\t\t\t call_expr, arglist, NULL_TREE);\n+      TREE_SIDE_EFFECTS (call_expr) = 1;\n+      return expand_expr (call_expr, target, mode, EXPAND_NORMAL);\n+    }\n+}\n+\n+/* Expand a call to the strpbrk builtin.  Return 0 if we failed the\n+   caller should emit a normal call, otherwise try to get the result\n+   in TARGET, if convenient (and in mode MODE if that's convenient).  */\n+\n+static rtx\n+expand_builtin_strpbrk (arglist, target, mode)\n+     tree arglist;\n+     rtx target;\n+     enum machine_mode mode;\n+{\n+  if (arglist == 0\n+      || TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) != POINTER_TYPE\n+      || TREE_CHAIN (arglist) == 0\n+      || TREE_CODE (TREE_TYPE (TREE_VALUE (TREE_CHAIN (arglist)))) != POINTER_TYPE\n+      || current_function_check_memory_usage)\n+    return 0;\n+  else\n+    {\n+      tree s1 = TREE_VALUE (arglist), s2 = TREE_VALUE (TREE_CHAIN (arglist));\n+      tree call_expr, fn;\n+      const char *p1, *p2;\n+\n+      p2 = c_getstr (s2);\n+      if (p2 == NULL)\n+\treturn 0;\n+\n+      p1 = c_getstr (s1);\n+      if (p1 != NULL)\n+\t{\n+\t  const char *r = strpbrk (p1, p2);\n+\n+\t  if (r == NULL)\n+\t    return const0_rtx;\n+\n+\t  /* Return an offset into the constant string argument.  */\n+\t  return expand_expr (fold (build (PLUS_EXPR, TREE_TYPE (s1),\n+\t\t\t\t\t   s1, ssize_int (r - p1))),\n+\t\t\t      target, mode, EXPAND_NORMAL);\n \t}\n+\n+      if (p2[0] == '\\0')\n+\t{\n+\t  /* strpbrk(x, \"\") == NULL.\n+\t     Evaluate and ignore the arguments in case they had\n+\t     side-effects.  */\n+\t  expand_expr (s1, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\t  return const0_rtx;\n+\t}\n+\n+      if (p2[1] != '\\0')\n+\treturn 0;  /* Really call strpbrk.  */\n+\n+      fn = built_in_decls[BUILT_IN_STRCHR];\n+      if (!fn)\n+\treturn 0;\n+\n+      /* New argument list transforming strpbrk(s1, s2) to\n+\t strchr(s1, s2[0]).  */\n+      arglist =\n+\tbuild_tree_list (NULL_TREE, build_int_2 (p2[0], 0));\n+      arglist = tree_cons (NULL_TREE, s1, arglist);\n+      call_expr = build1 (ADDR_EXPR,\n+\t\t\t  build_pointer_type (TREE_TYPE (fn)), fn);\n+      call_expr = build (CALL_EXPR, TREE_TYPE (TREE_TYPE (fn)),\n+\t\t\t call_expr, arglist, NULL_TREE);\n+      TREE_SIDE_EFFECTS (call_expr) = 1;\n+      return expand_expr (call_expr, target, mode, EXPAND_NORMAL);\n     }\n }\n \n@@ -1832,17 +1955,21 @@ expand_builtin_memcmp (exp, arglist, target)\n       return convert_to_mode (mode, result, 0);\n   }\n }\n+#endif\n \n /* Expand expression EXP, which is a call to the strcmp builtin.  Return 0\n    if we failed the caller should emit a normal call, otherwise try to get\n    the result in TARGET, if convenient.  */\n \n static rtx\n-expand_builtin_strcmp (exp, target)\n+expand_builtin_strcmp (exp, target, mode)\n      tree exp;\n      rtx target;\n+     enum machine_mode mode;\n {\n   tree arglist = TREE_OPERAND (exp, 1);\n+  tree arg1, arg2;\n+  const char *p1, *p2;\n \n   /* If we need to check memory accesses, call the library function.  */\n   if (current_function_check_memory_usage)\n@@ -1856,11 +1983,27 @@ expand_builtin_strcmp (exp, target)\n \t  != POINTER_TYPE))\n     return 0;\n \n-  else if (! HAVE_cmpstrsi)\n+  arg1 = TREE_VALUE (arglist);\n+  arg2 = TREE_VALUE (TREE_CHAIN (arglist));\n+\n+  p1 = c_getstr (arg1);\n+  p2 = c_getstr (arg2);\n+\n+  if (p1 && p2)\n+    {\n+      int i = strcmp (p1, p2);\n+\n+      return expand_expr (i < 0 ? build_int_2 (-1, -1)\n+\t\t\t\t: i == 0 ? integer_zero_node\n+\t\t\t\t\t : integer_one_node,\n+\t\t\t  target, mode, EXPAND_NORMAL);\n+    }\n+\n+#ifdef HAVE_cmpstrsi\n+  if (! HAVE_cmpstrsi)\n     return 0;\n+\n   {\n-    tree arg1 = TREE_VALUE (arglist);\n-    tree arg2 = TREE_VALUE (TREE_CHAIN (arglist));\n     tree len = c_strlen (arg1);\n     tree len2 = c_strlen (arg2);\n     rtx result;\n@@ -1900,8 +2043,10 @@ expand_builtin_strcmp (exp, target)\n \n     return result;\n   }\n-}\n+#else\n+  return 0;\n #endif\n+}\n \n /* Expand a call to __builtin_saveregs, generating the result in TARGET,\n    if that's convenient.  */\n@@ -2464,7 +2609,8 @@ expand_builtin_fputs (arglist, ignore)\n       || (TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) != POINTER_TYPE)\n       || TREE_CHAIN (arglist) == 0\n       || (TREE_CODE (TREE_TYPE (TREE_VALUE (TREE_CHAIN (arglist))))\n-\t  != POINTER_TYPE))\n+\t  != POINTER_TYPE)\n+      || current_function_check_memory_usage)\n     return 0;\n \n   /* Get the length of the string passed to fputs.  If the length\n@@ -2484,23 +2630,21 @@ expand_builtin_fputs (arglist, ignore)\n       }\n     case 0: /* length is 1, call fputc.  */\n       {\n-\ttree stripped_string = TREE_VALUE (arglist);\n+\tconst char *p = c_getstr (TREE_VALUE (arglist));\n \n-\tSTRIP_NOPS (stripped_string);\n-\tif (stripped_string && TREE_CODE (stripped_string) == ADDR_EXPR)\n-\t  stripped_string = TREE_OPERAND (stripped_string, 0);\n-      \n-\t/* New argument list transforming fputs(string, stream) to\n-\t   fputc(string[0], stream).  */\n-\targlist =\n-\t  build_tree_list (NULL_TREE, TREE_VALUE (TREE_CHAIN (arglist)));\n-\targlist =\n-\t  tree_cons (NULL_TREE, \n-\t\t     build_int_2 (TREE_STRING_POINTER (stripped_string)[0], 0),\n-\t\t     arglist);\n-\tfn = fn_fputc;\n-\tbreak;\n+\tif (p != NULL)\n+\t  {      \n+\t    /* New argument list transforming fputs(string, stream) to\n+\t       fputc(string[0], stream).  */\n+\t    arglist =\n+\t      build_tree_list (NULL_TREE, TREE_VALUE (TREE_CHAIN (arglist)));\n+\t    arglist =\n+\t      tree_cons (NULL_TREE, build_int_2 (p[0], 0), arglist);\n+\t    fn = fn_fputc;\n+\t    break;\n+\t  }\n       }\n+      /* FALLTHROUGH */\n     case 1: /* length is greater than 1, call fwrite.  */\n       {\n \ttree string_arg = TREE_VALUE (arglist);\n@@ -2740,6 +2884,18 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n \treturn target;\n       break;\n       \n+    case BUILT_IN_STRCHR:\n+      target = expand_builtin_strchr (arglist, target, mode);\n+      if (target)\n+\treturn target;\n+      break;\n+\n+    case BUILT_IN_STRRCHR:\n+      target = expand_builtin_strrchr (arglist, target, mode);\n+      if (target)\n+\treturn target;\n+      break;\n+\n     case BUILT_IN_MEMCPY:\n       target = expand_builtin_memcpy (arglist);\n       if (target)\n@@ -2758,24 +2914,23 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n \treturn target;\n       break;\n \n-/* These comparison functions need an instruction that returns an actual\n-   index.  An ordinary compare that just sets the condition codes\n-   is not enough.  */\n-#ifdef HAVE_cmpstrsi\n     case BUILT_IN_STRCMP:\n-      target = expand_builtin_strcmp (exp, target);\n+      target = expand_builtin_strcmp (exp, target, mode);\n       if (target)\n \treturn target;\n       break;\n \n+/* These comparison functions need an instruction that returns an actual\n+   index.  An ordinary compare that just sets the condition codes\n+   is not enough.  */\n+#ifdef HAVE_cmpstrsi\n     case BUILT_IN_BCMP:\n     case BUILT_IN_MEMCMP:\n       target = expand_builtin_memcmp (exp, arglist, target);\n       if (target)\n \treturn target;\n       break;\n #else\n-    case BUILT_IN_STRCMP:\n     case BUILT_IN_BCMP:\n     case BUILT_IN_MEMCMP:\n       break;\n@@ -2833,9 +2988,7 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n     case BUILT_IN_PUTS:\n     case BUILT_IN_FPUTC:\n     case BUILT_IN_FWRITE:\n-    case BUILT_IN_STRCHR:\n       break;\n-      \n     case BUILT_IN_FPUTS:\n       target = expand_builtin_fputs (arglist, ignore);\n       if (target)"}, {"sha": "980099c1b9682e6ed2d4cfc80d20e1c6ff1d4247", "filename": "gcc/builtins.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dee4af12b1f2a1262a88bdfa40e5a9db5374663/gcc%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dee4af12b1f2a1262a88bdfa40e5a9db5374663/gcc%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.def?ref=2dee4af12b1f2a1262a88bdfa40e5a9db5374663", "patch": "@@ -42,6 +42,7 @@ DEF_BUILTIN(BUILT_IN_STRLEN)\n DEF_BUILTIN(BUILT_IN_STRSTR)\n DEF_BUILTIN(BUILT_IN_STRPBRK)\n DEF_BUILTIN(BUILT_IN_STRCHR)\n+DEF_BUILTIN(BUILT_IN_STRRCHR)\n DEF_BUILTIN(BUILT_IN_FSQRT)\n DEF_BUILTIN(BUILT_IN_SIN)\n DEF_BUILTIN(BUILT_IN_COS)"}, {"sha": "0482a83eee16b5436a2c59718142ea5fd59f2c70", "filename": "gcc/c-common.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dee4af12b1f2a1262a88bdfa40e5a9db5374663/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dee4af12b1f2a1262a88bdfa40e5a9db5374663/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=2dee4af12b1f2a1262a88bdfa40e5a9db5374663", "patch": "@@ -5179,6 +5179,8 @@ c_common_nodes_and_builtins ()\n   built_in_decls[BUILT_IN_STRCHR] =\n     builtin_function (\"__builtin_strchr\", string_ftype_string_int,\n \t\t    BUILT_IN_STRCHR, BUILT_IN_NORMAL, \"strchr\");\n+  builtin_function (\"__builtin_strrchr\", string_ftype_string_int,\n+\t\t    BUILT_IN_STRRCHR, BUILT_IN_NORMAL, \"strrchr\");\n   builtin_function (\"__builtin_strcpy\", string_ftype_ptr_ptr,\n \t\t    BUILT_IN_STRCPY, BUILT_IN_NORMAL, \"strcpy\");\n   builtin_function (\"__builtin_strlen\", strlen_ftype,\n@@ -5249,6 +5251,10 @@ c_common_nodes_and_builtins ()\n \t\t\tBUILT_IN_NORMAL, NULL_PTR);\n       builtin_function (\"strstr\", string_ftype_string_string, BUILT_IN_STRSTR,\n \t\t\tBUILT_IN_NORMAL, NULL_PTR);\n+      builtin_function (\"strchr\", string_ftype_string_int, BUILT_IN_STRCHR,\n+\t\t\tBUILT_IN_NORMAL, NULL_PTR);\n+      builtin_function (\"strrchr\", string_ftype_string_int, BUILT_IN_STRRCHR,\n+\t\t\tBUILT_IN_NORMAL, NULL_PTR);\n       builtin_function (\"strpbrk\", string_ftype_string_string, BUILT_IN_STRPBRK,\n \t\t\tBUILT_IN_NORMAL, NULL_PTR);\n       builtin_function (\"strcpy\", string_ftype_ptr_ptr, BUILT_IN_STRCPY,"}, {"sha": "2757aeac53b3a9865939e1237dd01db93decd9b9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dee4af12b1f2a1262a88bdfa40e5a9db5374663/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dee4af12b1f2a1262a88bdfa40e5a9db5374663/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2dee4af12b1f2a1262a88bdfa40e5a9db5374663", "patch": "@@ -1,3 +1,11 @@\n+2000-11-09  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* gcc.c-torture/execute/string-opt-1.c: Add test for strstr\n+\twith both arguments constant strings.\n+\t* gcc.c-torture/execute/string-opt-3.c: New test.\n+\t* gcc.c-torture/execute/string-opt-4.c: New test.\n+\t* gcc.c-torture/execute/string-opt-5.c: New test.\n+\n 2000-11-08  Nick Clifton  <nickc@redhat.com>\n \n \t* gcc.c-torture/execute/20001108-1.c: New test case.  Checks"}, {"sha": "3bbc471f850865b05fedc4b5ebd3cd4607aa6c63", "filename": "gcc/testsuite/gcc.c-torture/execute/string-opt-1.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dee4af12b1f2a1262a88bdfa40e5a9db5374663/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstring-opt-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dee4af12b1f2a1262a88bdfa40e5a9db5374663/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstring-opt-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstring-opt-1.c?ref=2dee4af12b1f2a1262a88bdfa40e5a9db5374663", "patch": "@@ -22,7 +22,9 @@ int main()\n     abort();\n   if (strstr (foo + 6, \"o\") != foo + 7)\n     abort();\n-  \n+  if (strstr (foo + 1, \"world\") != foo + 6)\n+    abort();\n+\n   return 0;\n }\n "}, {"sha": "b2b9e1fe7d938455a0c8ae0cf6509350bbc9ca5f", "filename": "gcc/testsuite/gcc.c-torture/execute/string-opt-3.c", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dee4af12b1f2a1262a88bdfa40e5a9db5374663/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstring-opt-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dee4af12b1f2a1262a88bdfa40e5a9db5374663/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstring-opt-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstring-opt-3.c?ref=2dee4af12b1f2a1262a88bdfa40e5a9db5374663", "patch": "@@ -0,0 +1,83 @@\n+/* Copyright (C) 2000  Free Software Foundation.\n+\n+   Ensure all expected transformations of builtin strlen, strcmp and strrchr\n+   occur and perform correctly.\n+\n+   Written by Jakub Jelinek, 11/7/2000.  */\n+\n+extern void abort (void);\n+extern __SIZE_TYPE__ strlen (const char *);\n+extern int strcmp (const char *, const char *);\n+extern char *strrchr (const char *, int);\n+\n+int x = 6;\n+char *bar = \"hi world\";\n+\n+int main()\n+{\n+  const char *const foo = \"hello world\";\n+\n+  if (strlen (foo) != 11)\n+    abort ();\n+  if (strlen (foo + 4) != 7)\n+    abort ();\n+  if (strlen (foo + (x++ & 7)) != 5)\n+    abort ();\n+  if (x != 7)\n+    abort ();\n+  if (strcmp (foo, \"hello\") <= 0)\n+    abort ();\n+  if (strcmp (foo + 2, \"llo\") <= 0)\n+    abort ();\n+  if (strcmp (foo, foo) != 0)\n+    abort ();\n+  if (strcmp (foo, \"hello world \") >= 0)\n+    abort ();\n+  if (strcmp (foo + 10, \"dx\") >= 0)\n+    abort ();\n+  if (strcmp (10 + foo, \"dx\") >= 0)\n+    abort ();\n+  if (strrchr (foo, 'x'))\n+    abort ();\n+  if (strrchr (foo, 'o') != foo + 7)\n+    abort ();\n+  if (strrchr (foo, 'e') != foo + 1)\n+    abort ();\n+  if (strrchr (foo + 3, 'e'))\n+    abort ();\n+  if (strrchr (foo, '\\0') != foo + 11)\n+    abort ();\n+  if (strrchr (bar, '\\0') != bar + 8)\n+    abort ();\n+  if (strrchr (bar + 4, '\\0') != bar + 8)\n+    abort ();\n+  if (strrchr (bar + (x++ & 3), '\\0') != bar + 8)\n+    abort ();\n+  if (x != 8)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+#ifdef __OPTIMIZE__\n+/* When optimizing, all the above cases should be transformed into\n+   something else.  So any remaining calls to the original function\n+   should abort.  */\n+__SIZE_TYPE__\n+strlen (const char *s)\n+{\n+  abort ();\n+}\n+\n+int\n+strcmp (const char *s1, const char *s2)\n+{\n+  abort ();\n+}\n+\n+char *\n+strrchr (const char *s, int c)\n+{\n+  abort ();\n+}\n+#endif"}, {"sha": "a4c70cfda6bd857ef6aabe957ea30388956e5c44", "filename": "gcc/testsuite/gcc.c-torture/execute/string-opt-4.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dee4af12b1f2a1262a88bdfa40e5a9db5374663/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstring-opt-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dee4af12b1f2a1262a88bdfa40e5a9db5374663/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstring-opt-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstring-opt-4.c?ref=2dee4af12b1f2a1262a88bdfa40e5a9db5374663", "patch": "@@ -0,0 +1,36 @@\n+/* Copyright (C) 2000  Free Software Foundation.\n+\n+   Ensure all expected transformations of builtin strchr occur and\n+   perform correctly.\n+\n+   Written by Jakub Jelinek, 11/7/2000.  */\n+\n+extern void abort (void);\n+extern char *strchr (const char *, int);\n+\n+int main()\n+{\n+  const char *const foo = \"hello world\";\n+\n+  if (strchr (foo, 'x'))\n+    abort ();\n+  if (strchr (foo, 'o') != foo + 4)\n+    abort ();\n+  if (strchr (foo + 5, 'o') != foo + 7)\n+    abort ();\n+  if (strchr (foo, '\\0')  != foo + 11)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+#ifdef __OPTIMIZE__\n+/* When optimizing, all the above cases should be transformed into\n+   something else.  So any remaining calls to the original function\n+   should abort.  */\n+char *\n+strchr (const char *s, int c)\n+{\n+  abort ();\n+}\n+#endif"}, {"sha": "79b451d7f79d3dccf8748aec0f389d3e48de5130", "filename": "gcc/testsuite/gcc.c-torture/execute/string-opt-5.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dee4af12b1f2a1262a88bdfa40e5a9db5374663/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstring-opt-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dee4af12b1f2a1262a88bdfa40e5a9db5374663/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstring-opt-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstring-opt-5.c?ref=2dee4af12b1f2a1262a88bdfa40e5a9db5374663", "patch": "@@ -0,0 +1,58 @@\n+/* Copyright (C) 2000  Free Software Foundation.\n+\n+   Ensure builtin strlen, strcmp, strchr and strrchr perform correctly.\n+\n+   Written by Jakub Jelinek, 11/7/2000.  */\n+\n+extern void abort (void);\n+extern __SIZE_TYPE__ strlen (const char *);\n+extern int strcmp (const char *, const char *);\n+extern char *strchr (const char *, int);\n+extern char *strrchr (const char *, int);\n+\n+int x = 6;\n+char *bar = \"hi world\";\n+\n+int main()\n+{\n+  const char *const foo = \"hello world\";\n+\n+  if (strlen (bar) != 8)\n+    abort ();\n+  if (strlen (bar + (++x & 2)) != 6)\n+    abort ();\n+  if (x != 7)\n+    abort ();\n+  if (strlen (foo + (x++, 6)) != 5)\n+    abort ();\n+  if (x != 8)\n+    abort ();\n+  if (strlen (foo + (++x & 1)) != 10)\n+    abort ();\n+  if (x != 9)\n+    abort ();\n+  if (strcmp (foo + (x -= 6), \"lo world\"))\n+    abort ();\n+  if (x != 3)\n+    abort ();\n+  if (strcmp (foo, bar) >= 0)\n+    abort ();\n+  if (strcmp (foo, bar + (x++ & 1)) >= 0)\n+    abort ();\n+  if (x != 4)\n+    abort ();\n+  if (strchr (foo + (x++ & 7), 'l') != foo + 9)\n+    abort ();\n+  if (x != 5)\n+    abort ();\n+  if (strchr (bar, 'o') != bar + 4)\n+    abort ();\n+  if (strchr (bar, '\\0')  != bar + 8)\n+    abort ();\n+  if (strrchr (bar, 'x'))\n+    abort ();\n+  if (strrchr (bar, 'o') != bar + 4)\n+    abort ();\n+\n+  return 0;\n+}"}]}