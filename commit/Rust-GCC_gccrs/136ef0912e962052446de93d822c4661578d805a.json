{"sha": "136ef0912e962052446de93d822c4661578d805a", "node_id": "C_kwDOANBUbNoAKDEzNmVmMDkxMmU5NjIwNTI0NDZkZTkzZDgyMmM0NjYxNTc4ZDgwNWE", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2023-05-10T01:08:37Z"}, "committer": {"name": "CohenArthur", "email": "arthur.cohen@embecosm.com", "date": "2023-05-15T14:48:41Z"}, "message": "gccrs: Fix parsing of block expressions followed by `.`\n\n`{ ... }.f;` is parsed as a single statement in rust. This means that we can't\ndetermine whether an expression statement will need a semicolon terminator\nuntil we finish parsing it. To handle this we change expression parsing to\ncheck for this case by inspecting the expression returned from null_denotation\nand looking ahead for a `.` or `?` token.\n\ngcc/rust/ChangeLog:\n\n\t* ast/rust-ast.h (Expr::as_expr_without_block): Remove.\n\t(Expr::set_outer_attrs): Make public in base class.\n\t* expand/rust-macro-expand.cc:\n\tAdd fixme comment for pre-existing bug.\n\t* hir/tree/rust-hir.h: Remove Expr::as_expr_without_block.\n\t* parse/rust-parse-impl.h (Parser::parse_lifetime): Use lifetime_from_token.\n\t(Parser::lifetime_from_token): New method.\n\t(Parser::null_denotation): Handle labelled loop expressions and for loop expressions.\n\t(Parser::parse_loop_label): Make initial token a parameter.\n\t(Parser::parse_labelled_loop_expr): Likewise.\n\t(Parser::parse_for_loop_expr): Allow FOR token to already be skipped.\n\t(Parser::parse_expr): Handle expr_can_be_stmt.\n\t(Parser::parse_expr_with_block): Remove.\n\t(Parser::parse_expr_stmt_with_block): Remove.\n\t(Parser::parse_expr_stmt_without_block): Remove.\n\t(Parser::parse_expr_without_block): Remove.\n\t(Parser::parse_stmt_or_expr_with_block): Remove.\n\t(Parser::parse_expr_stmt): Use parse_expr directly.\n\t(Parser::parse_match_expr): Likewise.\n\t(Parser::parse_stmt): Use parse_expr_stmt in more cases.\n\t(Parser::parse_stmt_or_expr):\n\tRename from parse_stmt_or_expr_without_block, use parse_expr directly.\n\t(Parser::parse_block_expr): Update error message.\n\t* parse/rust-parse.h: Update declarations.\n\ngcc/testsuite/ChangeLog:\n\n\t* rust/compile/for_expr.rs: New test.\n\t* rust/compile/issue-407-2.rs: Update compiler output.\n\t* rust/compile/issue-407.rs: Update compiler output.\n\t* rust/compile/issue-867.rs: Update compiler output.\n\t* rust/compile/issue-2189.rs: New test.\n\t* rust/compile/macro_call_statement.rs: New test.\n\t* rust/compile/stmt_with_block_dot.rs: New test.\n\t* rust/compile/torture/loop8.rs: New test.\n\nSigned-off-by: Matthew Jasper <mjjasper1@gmail.com>", "tree": {"sha": "db2ea85cd61fb84218a1bb418b1bd6d70d502d40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db2ea85cd61fb84218a1bb418b1bd6d70d502d40"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/136ef0912e962052446de93d822c4661578d805a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/136ef0912e962052446de93d822c4661578d805a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/136ef0912e962052446de93d822c4661578d805a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/136ef0912e962052446de93d822c4661578d805a/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4cd88c4cd60bce7a2fd14191334a56ab08ea5181", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cd88c4cd60bce7a2fd14191334a56ab08ea5181", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4cd88c4cd60bce7a2fd14191334a56ab08ea5181"}], "stats": {"total": 715, "additions": 186, "deletions": 529}, "files": [{"sha": "ccc09251dbd78c51361a4a6032b378e438c04d72", "filename": "gcc/rust/ast/rust-ast.h", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/136ef0912e962052446de93d822c4661578d805a/gcc%2Frust%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/136ef0912e962052446de93d822c4661578d805a/gcc%2Frust%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.h?ref=136ef0912e962052446de93d822c4661578d805a", "patch": "@@ -960,10 +960,6 @@ class Expr : public Node\n    * for some?\n    *  - evaluate() - evaluates expression if constant? can_evaluate()? */\n \n-  /* HACK: downcasting without dynamic_cast (if possible) via polymorphism -\n-   * overrided in subclasses of ExprWithoutBlock */\n-  virtual ExprWithoutBlock *as_expr_without_block () const { return nullptr; }\n-\n   virtual std::string as_string () const = 0;\n \n   virtual ~Expr () {}\n@@ -986,17 +982,17 @@ class Expr : public Node\n \n   virtual Expr *to_stmt () const { return clone_expr_impl (); }\n \n+  // TODO: think of less hacky way to implement this kind of thing\n+  // Sets outer attributes.\n+  virtual void set_outer_attrs (std::vector<Attribute>) = 0;\n+\n protected:\n   // Constructor\n   Expr () : node_id (Analysis::Mappings::get ()->get_next_node_id ()) {}\n \n   // Clone function implementation as pure virtual method\n   virtual Expr *clone_expr_impl () const = 0;\n \n-  // TODO: think of less hacky way to implement this kind of thing\n-  // Sets outer attributes.\n-  virtual void set_outer_attrs (std::vector<Attribute>) = 0;\n-\n   NodeId node_id;\n };\n \n@@ -1023,13 +1019,6 @@ class ExprWithoutBlock : public Expr\n   {\n     return std::unique_ptr<ExprWithoutBlock> (clone_expr_without_block_impl ());\n   }\n-\n-  /* downcasting hack from expr to use pratt parsing with\n-   * parse_expr_without_block */\n-  ExprWithoutBlock *as_expr_without_block () const final override\n-  {\n-    return clone_expr_without_block_impl ();\n-  }\n };\n \n /* HACK: IdentifierExpr, delete when figure out identifier vs expr problem in"}, {"sha": "c76a3539d8bb25dc65d3c5c965570242c8a91ef3", "filename": "gcc/rust/expand/rust-macro-expand.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/136ef0912e962052446de93d822c4661578d805a/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/136ef0912e962052446de93d822c4661578d805a/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc?ref=136ef0912e962052446de93d822c4661578d805a", "patch": "@@ -1034,6 +1034,8 @@ MacroExpander::transcribe_rule (\n   bool reached_end_of_stream = did_delimit && parser.skip_token (END_OF_FILE);\n   if (!reached_end_of_stream)\n     {\n+      // FIXME: rustc has some cases it accepts this with a warning due to\n+      // backwards compatibility.\n       const_TokenPtr current_token = parser.peek_current_token ();\n       rust_error_at (current_token->get_locus (),\n \t\t     \"tokens here and after are unparsed\");"}, {"sha": "777289c7fd1871d87fc8b15be168ad10c77e11e4", "filename": "gcc/rust/hir/tree/rust-hir.h", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/136ef0912e962052446de93d822c4661578d805a/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/136ef0912e962052446de93d822c4661578d805a/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h?ref=136ef0912e962052446de93d822c4661578d805a", "patch": "@@ -288,10 +288,6 @@ class Expr : public Node\n     return std::unique_ptr<Expr> (clone_expr_impl ());\n   }\n \n-  /* HACK: downcasting without dynamic_cast (if possible) via polymorphism -\n-   * overrided in subclasses of ExprWithoutBlock */\n-  virtual ExprWithoutBlock *as_expr_without_block () const { return nullptr; }\n-\n   // TODO: make pure virtual if move out outer attributes to derived classes\n   virtual std::string as_string () const;\n \n@@ -354,13 +350,6 @@ class ExprWithoutBlock : public Expr\n     return std::unique_ptr<ExprWithoutBlock> (clone_expr_without_block_impl ());\n   }\n \n-  /* downcasting hack from expr to use pratt parsing with\n-   * parse_expr_without_block */\n-  ExprWithoutBlock *as_expr_without_block () const override\n-  {\n-    return clone_expr_without_block_impl ();\n-  }\n-\n   BlockType get_block_expr_type () const final override\n   {\n     return BlockType::WITHOUT_BLOCK;"}, {"sha": "cf1fd9f413f115313d38bb08434af69049d5cfd8", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 110, "deletions": 466, "changes": 576, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/136ef0912e962052446de93d822c4661578d805a/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/136ef0912e962052446de93d822c4661578d805a/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=136ef0912e962052446de93d822c4661578d805a", "patch": "@@ -4019,15 +4019,22 @@ AST::Lifetime\n Parser<ManagedTokenSource>::parse_lifetime ()\n {\n   const_TokenPtr lifetime_tok = lexer.peek_token ();\n-  Location locus = lifetime_tok->get_locus ();\n   // create error lifetime if doesn't exist\n   if (lifetime_tok->get_id () != LIFETIME)\n     {\n       return AST::Lifetime::error ();\n     }\n   lexer.skip_token ();\n \n-  std::string lifetime_ident = lifetime_tok->get_str ();\n+  return lifetime_from_token (lifetime_tok);\n+}\n+\n+template <typename ManagedTokenSource>\n+AST::Lifetime\n+Parser<ManagedTokenSource>::lifetime_from_token (const_TokenPtr tok)\n+{\n+  Location locus = tok->get_locus ();\n+  std::string lifetime_ident = tok->get_str ();\n \n   if (lifetime_ident == \"'static\")\n     {\n@@ -6218,13 +6225,6 @@ Parser<ManagedTokenSource>::parse_stmt (ParseRestrictions restrictions)\n \t  return parse_vis_item (std::move (outer_attrs));\n \t}\n       break;\n-    case SUPER:\n-    case SELF:\n-    case CRATE:\n-    case DOLLAR_SIGN:\n-      // almost certainly macro invocation semi\n-      return parse_macro_invocation_semi (std::move (outer_attrs));\n-      break;\n     // crappy hack to do union \"keyword\"\n     case IDENTIFIER:\n       if (t->get_str () == \"union\"\n@@ -7228,315 +7228,42 @@ Parser<ManagedTokenSource>::parse_method ()\n \t\t      AST::Visibility::create_error (), AST::AttrVec (), locus);\n }\n \n-/* Parses an expression statement (disambiguates to expression with or without\n- * block statement). */\n+/* Parses an expression statement. */\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::ExprStmt>\n Parser<ManagedTokenSource>::parse_expr_stmt (AST::AttrVec outer_attrs,\n \t\t\t\t\t     ParseRestrictions restrictions)\n {\n-  /* potential thoughts - define new virtual method \"has_block()\" on expr.\n-   * parse expr and then determine whether semicolon is needed as a result of\n-   * this method. but then this would require dynamic_cast, which is not\n-   * allowed. */\n-\n-  /* okay new thought - big switch to disambiguate exprs with blocks - either\n-   * block expr, async block expr, unsafe block expr, loop expr, if expr, if\n-   * let expr, or match expr. So all others are exprs without block. */\n-  /* new thought: possible initial tokens: 'loop', 'while', 'for', lifetime\n-   * (and then ':' and then loop), 'if', 'match', '{', 'async', 'unsafe' (and\n-   * then\n-   * '{')). This seems to have no ambiguity. */\n-\n-  const_TokenPtr t = lexer.peek_token ();\n-  /* TODO: should the switch just directly call the individual parse methods\n-   * rather than adding another layer of indirection with\n-   * parse_expr_stmt_with_block()? */\n-  switch (t->get_id ())\n-    {\n-    case LOOP:\n-    case WHILE:\n-    case FOR:\n-    case IF:\n-    case MATCH_TOK:\n-    case LEFT_CURLY:\n-    case ASYNC:\n-      // expression with block\n-      return parse_expr_stmt_with_block (std::move (outer_attrs));\n-      case LIFETIME: {\n-\t/* FIXME: are there any expressions without blocks that can have\n-\t * lifetime as their first token? Or is loop expr the only one? */\n-\t// safe side for now:\n-\tif (lexer.peek_token (1)->get_id () == COLON\n-\t    && lexer.peek_token (2)->get_id () == LOOP)\n-\t  {\n-\t    return parse_expr_stmt_with_block (std::move (outer_attrs));\n-\t  }\n-\telse\n-\t  {\n-\t    return parse_expr_stmt_without_block (std::move (outer_attrs),\n-\t\t\t\t\t\t  restrictions);\n-\t  }\n-      }\n-      case UNSAFE: {\n-\t// unsafe block\n-\t// https://doc.rust-lang.org/reference/unsafe-keyword.html\n-\treturn parse_expr_stmt_with_block (std::move (outer_attrs));\n-      }\n-    default:\n-      // not a parse expr with block, so must be expr without block\n-      /* TODO: if possible, be more selective about possible expr without\n-       * block initial tokens in order to prevent more syntactical errors at\n-       * parse time. */\n-      return parse_expr_stmt_without_block (std::move (outer_attrs),\n-\t\t\t\t\t    restrictions);\n-    }\n-}\n-\n-template <typename ManagedTokenSource>\n-std::unique_ptr<AST::ExprWithBlock>\n-Parser<ManagedTokenSource>::parse_expr_with_block (AST::AttrVec outer_attrs)\n-{\n-  std::unique_ptr<AST::ExprWithBlock> expr_parsed = nullptr;\n-\n-  const_TokenPtr t = lexer.peek_token ();\n-  switch (t->get_id ())\n-    {\n-    case IF:\n-      // if or if let, so more lookahead to find out\n-      if (lexer.peek_token (1)->get_id () == LET)\n-\t{\n-\t  // if let expr\n-\t  expr_parsed = parse_if_let_expr (std::move (outer_attrs));\n-\t  break;\n-\t}\n-      else\n-\t{\n-\t  // if expr\n-\t  expr_parsed = parse_if_expr (std::move (outer_attrs));\n-\t  break;\n-\t}\n-    case LOOP:\n-      // infinite loop\n-      expr_parsed = parse_loop_expr (std::move (outer_attrs));\n-      break;\n-    case FOR:\n-      // \"for\" iterator loop\n-      expr_parsed = parse_for_loop_expr (std::move (outer_attrs));\n-      break;\n-      case WHILE: {\n-\t// while or while let, so more lookahead to find out\n-\tif (lexer.peek_token (1)->get_id () == LET)\n-\t  {\n-\t    // while let loop expr\n-\t    expr_parsed = parse_while_let_loop_expr (std::move (outer_attrs));\n-\t    break;\n-\t  }\n-\telse\n-\t  {\n-\t    // while loop expr\n-\t    expr_parsed = parse_while_loop_expr (std::move (outer_attrs));\n-\t    break;\n-\t  }\n-      }\n-    case MATCH_TOK:\n-      // match expression\n-      expr_parsed = parse_match_expr (std::move (outer_attrs));\n-      break;\n-    case LEFT_CURLY:\n-      // block expression\n-      expr_parsed = parse_block_expr (std::move (outer_attrs));\n-      break;\n-    case ASYNC:\n-      // async block expression\n-      expr_parsed = parse_async_block_expr (std::move (outer_attrs));\n-      break;\n-    case UNSAFE:\n-      // unsafe block expression\n-      expr_parsed = parse_unsafe_block_expr (std::move (outer_attrs));\n-      break;\n-    case LIFETIME:\n-      // some kind of loop expr (with loop label)\n-      expr_parsed = parse_labelled_loop_expr (std::move (outer_attrs));\n-      break;\n-    default:\n-      add_error (Error (\n-\tt->get_locus (),\n-\t\"could not recognise expr beginning with %qs as an expr with block in\"\n-\t\" parsing expr statement\",\n-\tt->get_token_description ()));\n-\n-      skip_after_next_block ();\n-      return nullptr;\n-    }\n-\n-  // ensure expr parsed exists\n-  if (expr_parsed == nullptr)\n-    {\n-      Error error (t->get_locus (),\n-\t\t   \"failed to parse expr with block in parsing expr statement\");\n-      add_error (std::move (error));\n-\n-      skip_after_end_block ();\n-      return nullptr;\n-    }\n-\n-  return expr_parsed;\n-}\n-\n-/* Parses a expression statement containing an expression with block.\n- * Disambiguates internally. */\n-template <typename ManagedTokenSource>\n-std::unique_ptr<AST::ExprStmt>\n-Parser<ManagedTokenSource>::parse_expr_stmt_with_block (\n-  AST::AttrVec outer_attrs)\n-{\n-  auto expr_parsed = parse_expr_with_block (std::move (outer_attrs));\n-  auto locus = expr_parsed->get_locus ();\n-\n-  // return expr stmt created from expr\n-  return std::unique_ptr<AST::ExprStmt> (\n-    new AST::ExprStmt (std::move (expr_parsed), locus,\n-\t\t       lexer.peek_token ()->get_id () == SEMICOLON));\n-}\n-\n-/* Parses an expression statement containing an expression without block.\n- * Disambiguates further. */\n-template <typename ManagedTokenSource>\n-std::unique_ptr<AST::ExprStmt>\n-Parser<ManagedTokenSource>::parse_expr_stmt_without_block (\n-  AST::AttrVec outer_attrs, ParseRestrictions restrictions)\n-{\n-  /* TODO: maybe move more logic for expr without block in here for better\n-   * error handling */\n-\n-  // attempt to parse via parse_expr_without_block - seems to work\n-  std::unique_ptr<AST::ExprWithoutBlock> expr = nullptr;\n   Location locus = lexer.peek_token ()->get_locus ();\n \n   restrictions.expr_can_be_stmt = true;\n \n-  expr = parse_expr_without_block (std::move (outer_attrs), restrictions);\n+  // attempt to parse via parse_expr_without_block - seems to work\n+  std::unique_ptr<AST::Expr> expr\n+    = parse_expr (std::move (outer_attrs), restrictions);\n   if (expr == nullptr)\n     {\n       // expr is required, error\n       Error error (lexer.peek_token ()->get_locus (),\n-\t\t   \"failed to parse expr without block in expr statement\");\n+\t\t   \"failed to parse expr in expr statement\");\n       add_error (std::move (error));\n \n       skip_after_semicolon ();\n       return nullptr;\n     }\n \n-  if (restrictions.consume_semi)\n-    if (!skip_token (SEMICOLON))\n-      return nullptr;\n-\n-  return std::unique_ptr<AST::ExprStmt> (\n-    new AST::ExprStmt (std::move (expr), locus, true));\n-}\n-\n-/* Parses an expression without a block associated with it (further\n- * disambiguates). */\n-template <typename ManagedTokenSource>\n-std::unique_ptr<AST::ExprWithoutBlock>\n-Parser<ManagedTokenSource>::parse_expr_without_block (\n-  AST::AttrVec outer_attrs, ParseRestrictions restrictions)\n-{\n-  /* Notes on types of expr without block:\n-   *  - literal expr          tokens that are literals\n-   *  - path expr             path_in_expr or qual_path_in_expr\n-   *  - operator expr         many different types\n-   *     unary:\n-   *      borrow expr         ( '&' | '&&' ) 'mut'? expr\n-   *      dereference expr    '*' expr\n-   *      error propagation   expr '?'\n-   *      negation            '-' expr\n-   *      not                 '!' expr\n-   *     binary: all start with expr\n-   *  - grouped/paren expr    '(' inner_attributes expr ')'\n-   *  - array expr            '[' inner_attributes array_elems? ']'\n-   *  - await expr            expr '.' 'await'\n-   *  - (array/slice) index expr  expr '[' expr ']'\n-   *  - tuple expr            '(' inner_attributes tuple_elems? ')'\n-   *      note that a single elem tuple is distinguished from a grouped expr\n-   * by a trailing comma, i.e. a grouped expr is preferred over a tuple expr\n-   *  - tuple index expr      expr '.' tuple_index\n-   *  - struct expr           path_in_expr (and optional other stuff)\n-   *  - enum variant expr     path_in_expr (and optional other stuff)\n-   *      this means that there is no syntactic difference between an enum\n-   * variant and a struct\n-   *      - only name resolution can tell the difference. Thus, maybe rework\n-   * AST to take this into account (\"struct or enum\" nodes?)\n-   *  - (function) call expr  expr '(' call_params? ')'\n-   *  - method call expr      expr '.' path_expr_segment '(' call_params? ')'\n-   *  - field expr            expr '.' identifier\n-   *      note that method call expr is preferred, i.e. field expr must not be\n-   * followed by parenthesised expression sequence.\n-   *  - closure expr          'move'? ( '||' | '|' closure_params? '|' ) (\n-   * expr | '->' type_no_bounds block_expr )\n-   *  - continue expr         'continue' labelled_lifetime?\n-   *  - break expr            'break' labelled_lifetime? expr?\n-   *  - range expr            many different types but all involve '..' or\n-   * '..='\n-   *  - return expr           'return' as 1st tok\n-   *  - macro invocation      identifier then :: or identifier then !\n-   * (simple_path '!')\n-   *\n-   * any that have rules beginning with 'expr' should probably be\n-   * pratt-parsed,\n-   * with parsing type to use determined by token AND lookahead. */\n+  bool has_semi = false;\n \n-  // ok well at least can do easy ones\n-  const_TokenPtr t = lexer.peek_token ();\n-  switch (t->get_id ())\n+  if (restrictions.consume_semi)\n     {\n-    case RETURN_TOK:\n-      // return expr\n-      return parse_return_expr (std::move (outer_attrs));\n-    case BREAK:\n-      // break expr\n-      return parse_break_expr (std::move (outer_attrs));\n-    case CONTINUE:\n-      // continue expr\n-      return parse_continue_expr (std::move (outer_attrs));\n-    case MOVE:\n-      // closure expr (though not all closure exprs require this)\n-      return parse_closure_expr (std::move (outer_attrs));\n-      default: {\n-\t/* HACK: piggyback on pratt parsed expr and abuse polymorphism to\n-\t * essentially downcast */\n-\n-\tstd::unique_ptr<AST::Expr> expr\n-\t  = parse_expr (std::move (outer_attrs), restrictions);\n-\n-\tif (expr == nullptr)\n-\t  {\n-\t    Error error (t->get_locus (),\n-\t\t\t \"failed to parse expression for expression without \"\n-\t\t\t \"block (pratt-parsed expression is null)\");\n-\t    add_error (std::move (error));\n-\n-\t    return nullptr;\n-\t  }\n-\n-\tstd::unique_ptr<AST::ExprWithoutBlock> expr_without_block (\n-\t  expr->as_expr_without_block ());\n-\n-\tif (expr_without_block != nullptr)\n-\t  {\n-\t    return expr_without_block;\n-\t  }\n-\telse\n-\t  {\n-\t    Error error (t->get_locus (),\n-\t\t\t \"converted expr without block is null\");\n-\t    add_error (std::move (error));\n-\n-\t    return nullptr;\n-\t  }\n-      }\n+      if (skip_token (SEMICOLON))\n+\thas_semi = true;\n+      else if (expr->is_expr_without_block ())\n+\treturn nullptr;\n     }\n+\n+  return std::unique_ptr<AST::ExprStmt> (\n+    new AST::ExprStmt (std::move (expr), locus, has_semi));\n }\n \n // Parses a block expression, including the curly braces at start and end.\n@@ -7565,12 +7292,12 @@ Parser<ManagedTokenSource>::parse_block_expr (AST::AttrVec outer_attrs,\n   const_TokenPtr t = lexer.peek_token ();\n   while (t->get_id () != RIGHT_CURLY)\n     {\n-      ExprOrStmt expr_or_stmt = parse_stmt_or_expr_without_block ();\n+      ExprOrStmt expr_or_stmt = parse_stmt_or_expr ();\n       if (expr_or_stmt.is_error ())\n \t{\n-\t  Error error (t->get_locus (),\n-\t\t       \"failed to parse statement or expression without \"\n-\t\t       \"block in block expression\");\n+\t  Error error (\n+\t    t->get_locus (),\n+\t    \"failed to parse statement or expression in block expression\");\n \t  add_error (std::move (error));\n \n \t  return nullptr;\n@@ -7926,26 +7653,25 @@ Parser<ManagedTokenSource>::parse_continue_expr (AST::AttrVec outer_attrs,\n // Parses a loop label used in loop expressions.\n template <typename ManagedTokenSource>\n AST::LoopLabel\n-Parser<ManagedTokenSource>::parse_loop_label ()\n+Parser<ManagedTokenSource>::parse_loop_label (const_TokenPtr tok)\n {\n   // parse lifetime - if doesn't exist, assume no label\n-  const_TokenPtr t = lexer.peek_token ();\n-  if (t->get_id () != LIFETIME)\n+  if (tok->get_id () != LIFETIME)\n     {\n       // not necessarily an error\n       return AST::LoopLabel::error ();\n     }\n   /* FIXME: check for named lifetime requirement here? or check in semantic\n    * analysis phase? */\n-  AST::Lifetime label = parse_lifetime ();\n+  AST::Lifetime label = lifetime_from_token (tok);\n \n   if (!skip_token (COLON))\n     {\n       // skip somewhere?\n       return AST::LoopLabel::error ();\n     }\n \n-  return AST::LoopLabel (std::move (label), t->get_locus ());\n+  return AST::LoopLabel (std::move (label), tok->get_locus ());\n }\n \n /* Parses an if expression of any kind, including with else, else if, else if\n@@ -8496,7 +8222,7 @@ Parser<ManagedTokenSource>::parse_for_loop_expr (AST::AttrVec outer_attrs,\n     locus = lexer.peek_token ()->get_locus ();\n   else\n     locus = label.get_locus ();\n-  skip_token (FOR);\n+  maybe_skip_token (FOR);\n \n   // parse pattern, which is required\n   std::unique_ptr<AST::Pattern> pattern = parse_pattern ();\n@@ -8553,26 +8279,27 @@ Parser<ManagedTokenSource>::parse_for_loop_expr (AST::AttrVec outer_attrs,\n // Parses a loop expression with label (any kind of loop - disambiguates).\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::BaseLoopExpr>\n-Parser<ManagedTokenSource>::parse_labelled_loop_expr (AST::AttrVec outer_attrs)\n+Parser<ManagedTokenSource>::parse_labelled_loop_expr (const_TokenPtr tok,\n+\t\t\t\t\t\t      AST::AttrVec outer_attrs)\n {\n   /* TODO: decide whether it should not work if there is no label, or parse it\n    * with no label at the moment, I will make it not work with no label\n    * because that's the implication. */\n \n-  if (lexer.peek_token ()->get_id () != LIFETIME)\n+  if (tok->get_id () != LIFETIME)\n     {\n-      Error error (lexer.peek_token ()->get_locus (),\n+      Error error (tok->get_locus (),\n \t\t   \"expected lifetime in labelled loop expr (to parse loop \"\n \t\t   \"label) - found %qs\",\n-\t\t   lexer.peek_token ()->get_token_description ());\n+\t\t   tok->get_token_description ());\n       add_error (std::move (error));\n \n       // skip?\n       return nullptr;\n     }\n \n   // parse loop label (required)\n-  AST::LoopLabel label = parse_loop_label ();\n+  AST::LoopLabel label = parse_loop_label (tok);\n   if (label.is_error ())\n     {\n       Error error (lexer.peek_token ()->get_locus (),\n@@ -8683,10 +8410,9 @@ Parser<ManagedTokenSource>::parse_match_expr (AST::AttrVec outer_attrs,\n       restrictions.expr_can_be_stmt = true;\n       restrictions.consume_semi = false;\n \n-      std::unique_ptr<AST::ExprStmt> expr_stmt\n-\t= parse_expr_stmt ({}, restrictions);\n+      std::unique_ptr<AST::Expr> expr = parse_expr ({}, restrictions);\n \n-      if (expr_stmt == nullptr)\n+      if (expr == nullptr)\n \t{\n \t  Error error (lexer.peek_token ()->get_locus (),\n \t\t       \"failed to parse expr in match arm in match expr\");\n@@ -8696,9 +8422,7 @@ Parser<ManagedTokenSource>::parse_match_expr (AST::AttrVec outer_attrs,\n \t  return nullptr;\n \t}\n \n-      std::unique_ptr<AST::Expr> expr = expr_stmt->get_expr ()->clone_expr ();\n-      bool is_expr_without_block\n-\t= expr_stmt->get_expr ()->is_expr_without_block ();\n+      bool is_expr_without_block = expr->is_expr_without_block ();\n \n       match_arms.push_back (AST::MatchCase (std::move (arm), std::move (expr)));\n \n@@ -11759,38 +11483,12 @@ Parser<ManagedTokenSource>::parse_struct_pattern_field_partial (\n     }\n }\n \n-template <typename ManagedTokenSource>\n-ExprOrStmt\n-Parser<ManagedTokenSource>::parse_stmt_or_expr_with_block (\n-  AST::AttrVec outer_attrs)\n-{\n-  auto expr = parse_expr_with_block (std::move (outer_attrs));\n-  if (expr == nullptr)\n-    return ExprOrStmt::create_error ();\n-\n-  auto tok = lexer.peek_token ();\n-\n-  // tail expr in a block expr\n-  if (tok->get_id () == RIGHT_CURLY)\n-    return ExprOrStmt (std::move (expr));\n-\n-  // internal block expr must either have semicolons followed, or evaluate to\n-  // ()\n-  auto locus = expr->get_locus ();\n-  std::unique_ptr<AST::ExprStmt> stmt (\n-    new AST::ExprStmt (std::move (expr), locus, tok->get_id () == SEMICOLON));\n-  if (tok->get_id () == SEMICOLON)\n-    lexer.skip_token ();\n-\n-  return ExprOrStmt (std::move (stmt));\n-}\n-\n /* Parses a statement or expression (depending on whether a trailing semicolon\n  * exists). Useful for block expressions where it cannot be determined through\n  * lookahead whether it is a statement or expression to be parsed. */\n template <typename ManagedTokenSource>\n ExprOrStmt\n-Parser<ManagedTokenSource>::parse_stmt_or_expr_without_block ()\n+Parser<ManagedTokenSource>::parse_stmt_or_expr ()\n {\n   // quick exit for empty statement\n   const_TokenPtr t = lexer.peek_token ();\n@@ -11804,6 +11502,8 @@ Parser<ManagedTokenSource>::parse_stmt_or_expr_without_block ()\n \n   // parse outer attributes\n   AST::AttrVec outer_attrs = parse_outer_attributes ();\n+  ParseRestrictions restrictions;\n+  restrictions.expr_can_be_stmt = true;\n \n   // parsing this will be annoying because of the many different possibilities\n   /* best may be just to copy paste in parse_item switch, and failing that try\n@@ -11855,8 +11555,8 @@ Parser<ManagedTokenSource>::parse_stmt_or_expr_without_block ()\n \tswitch (t2->get_id ())\n \t  {\n \t    case LEFT_CURLY: {\n-\t      // unsafe block\n-\t      return parse_stmt_or_expr_with_block (std::move (outer_attrs));\n+\t      // unsafe block: parse as expression\n+\t      break;\n \t    }\n \t  case AUTO:\n \t    case TRAIT: {\n@@ -11887,75 +11587,14 @@ Parser<ManagedTokenSource>::parse_stmt_or_expr_without_block ()\n \t    // skip somewhere?\n \t    return ExprOrStmt::create_error ();\n \t  }\n-      }\n-    case SUPER:\n-    case SELF:\n-    case CRATE:\n-      case DOLLAR_SIGN: {\n-\t/* path-based thing so struct/enum or path or macro invocation of a\n-\t * kind. however, the expressions are composable (i think) */\n-\n-\tstd::unique_ptr<AST::ExprWithoutBlock> expr\n-\t  = parse_expr_without_block ();\n-\n-\tif (lexer.peek_token ()->get_id () == SEMICOLON)\n-\t  {\n-\t    // must be expression statement\n-\t    lexer.skip_token ();\n-\n-\t    std::unique_ptr<AST::ExprStmt> stmt (\n-\t      new AST::ExprStmt (std::move (expr), t->get_locus (), true));\n-\t    return ExprOrStmt (std::move (stmt));\n-\t  }\n-\n-\t// return expression\n-\treturn ExprOrStmt (std::move (expr));\n+\tbreak;\n       }\n       /* FIXME: this is either a macro invocation or macro invocation semi.\n        * start parsing to determine which one it is. */\n       // FIXME: or this is another path-based thing - struct/enum or path\n       // itself return parse_path_based_stmt_or_expr(std::move(outer_attrs));\n       // FIXME: old code there\n-    case LOOP:\n-    case WHILE:\n-    case FOR:\n-    case IF:\n-    case MATCH_TOK:\n-    case LEFT_CURLY:\n-      case ASYNC: {\n-\treturn parse_stmt_or_expr_with_block (std::move (outer_attrs));\n-      }\n-      case LIFETIME: {\n-\t/* FIXME: are there any expressions without blocks that can have\n-\t * lifetime as their first token? Or is loop expr the only one? */\n-\t// safe side for now:\n-\tconst_TokenPtr t2 = lexer.peek_token (2);\n-\tif (lexer.peek_token (1)->get_id () == COLON\n-\t    && (t2->get_id () == LOOP || t2->get_id () == WHILE\n-\t\t|| t2->get_id () == FOR))\n-\t  {\n-\t    return parse_stmt_or_expr_with_block (std::move (outer_attrs));\n-\t  }\n-\telse\n-\t  {\n-\t    // should be expr without block\n-\t    std::unique_ptr<AST::ExprWithoutBlock> expr\n-\t      = parse_expr_without_block (std::move (outer_attrs));\n \n-\t    if (lexer.peek_token ()->get_id () == SEMICOLON)\n-\t      {\n-\t\t// must be expression statement\n-\t\tlexer.skip_token ();\n-\n-\t\tstd::unique_ptr<AST::ExprStmt> stmt (\n-\t\t  new AST::ExprStmt (std::move (expr), t->get_locus (), true));\n-\t\treturn ExprOrStmt (std::move (stmt));\n-\t      }\n-\n-\t    // return expression\n-\t    return ExprOrStmt (std::move (expr));\n-\t  }\n-      }\n     // crappy hack to do union \"keyword\"\n     case IDENTIFIER:\n       if (t->get_str () == \"union\"\n@@ -11973,62 +11612,49 @@ Parser<ManagedTokenSource>::parse_stmt_or_expr_without_block ()\n \t    parse_macro_rules_def (std::move (outer_attrs)));\n \t  return ExprOrStmt (std::move (item));\n \t}\n-      else if (lexer.peek_token (1)->get_id () == SCOPE_RESOLUTION\n-\t       || lexer.peek_token (1)->get_id () == EXCLAM\n-\t       || lexer.peek_token (1)->get_id () == LEFT_CURLY)\n+      else\n \t{\n-\t  /* path (probably) or macro invocation or struct or enum, so\n-\t   * probably a macro invocation semi decide how to parse - probably\n-\t   * parse path and then get macro from it */\n+\t  break;\n+\t}\n+    default:\n+      break;\n+    }\n \n-\t  // FIXME: old code was good until composability was required\n-\t  // return parse_path_based_stmt_or_expr(std::move(outer_attrs));\n-\t  std::unique_ptr<AST::ExprWithoutBlock> expr\n-\t    = parse_expr_without_block (std::move (outer_attrs));\n+  /* expression statement or expression itself - parse\n+   * expression then make it statement if semi afterwards */\n \n-\t  if (lexer.peek_token ()->get_id () == SEMICOLON)\n-\t    {\n-\t      // must be expression statement\n-\t      lexer.skip_token ();\n+  std::unique_ptr<AST::Expr> expr\n+    = parse_expr (std::move (outer_attrs), restrictions);\n \n-\t      std::unique_ptr<AST::ExprStmt> stmt (\n-\t\tnew AST::ExprStmt (std::move (expr), t->get_locus (), true));\n-\t      return ExprOrStmt (std::move (stmt));\n-\t    }\n+  const_TokenPtr after_expr = lexer.peek_token ();\n+  if (after_expr->get_id () == SEMICOLON)\n+    {\n+      // must be expression statement\n+      lexer.skip_token ();\n \n-\t  // return expression\n-\t  return ExprOrStmt (std::move (expr));\n+      if (expr)\n+\t{\n+\t  std::unique_ptr<AST::ExprStmt> stmt (\n+\t    new AST::ExprStmt (std::move (expr), t->get_locus (), true));\n+\t  return ExprOrStmt (std::move (stmt));\n \t}\n-      gcc_fallthrough ();\n-      // TODO: find out how to disable gcc \"implicit fallthrough\" warning\n-      default: {\n-\t/* expression statement (without block) or expression itself - parse\n-\t * expression then make it statement if semi afterwards */\n-\n-\tstd::unique_ptr<AST::ExprWithoutBlock> expr\n-\t  = parse_expr_without_block (std::move (outer_attrs));\n-\n-\tif (lexer.peek_token ()->get_id () == SEMICOLON)\n-\t  {\n-\t    // must be expression statement\n-\t    lexer.skip_token ();\n-\n-\t    if (expr)\n-\t      {\n-\t\tstd::unique_ptr<AST::ExprStmt> stmt (\n-\t\t  new AST::ExprStmt (std::move (expr), t->get_locus (), true));\n-\t\treturn ExprOrStmt (std::move (stmt));\n-\t      }\n-\t    else\n-\t      {\n-\t\treturn ExprOrStmt::create_error ();\n-\t      }\n-\t  }\n+      else\n+\t{\n+\t  return ExprOrStmt::create_error ();\n+\t}\n+    }\n \n-\t// return expression\n-\treturn ExprOrStmt (std::move (expr));\n-      }\n+  if (expr && !expr->is_expr_without_block ()\n+      && after_expr->get_id () != RIGHT_CURLY)\n+    {\n+      // block expression statement.\n+      std::unique_ptr<AST::ExprStmt> stmt (\n+\tnew AST::ExprStmt (std::move (expr), t->get_locus (), false));\n+      return ExprOrStmt (std::move (stmt));\n     }\n+\n+  // return expression\n+  return ExprOrStmt (std::move (expr));\n }\n \n /* Parses a statement or expression beginning with a path (i.e. macro,\n@@ -12655,9 +12281,7 @@ Parser<ManagedTokenSource>::skip_after_end_attribute ()\n }\n \n /* Pratt parser impl of parse_expr. FIXME: this is only provisional and\n- * probably will be changed.\n- * FIXME: this may only parse expressions without blocks as they are the only\n- * expressions to have precedence? */\n+ * probably will be changed. */\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::Expr>\n Parser<ManagedTokenSource>::parse_expr (int right_binding_power,\n@@ -12686,6 +12310,9 @@ Parser<ManagedTokenSource>::parse_expr (int right_binding_power,\n \n   lexer.skip_token ();\n \n+  bool expr_can_be_stmt = restrictions.expr_can_be_stmt;\n+  restrictions.expr_can_be_stmt = false;\n+\n   // parse null denotation (unary part of expression)\n   std::unique_ptr<AST::Expr> expr\n     = null_denotation (current_token, {}, restrictions);\n@@ -12697,12 +12324,23 @@ Parser<ManagedTokenSource>::parse_expr (int right_binding_power,\n       return nullptr;\n     }\n \n+  current_token = lexer.peek_token ();\n+\n+  if (expr_can_be_stmt && !expr->is_expr_without_block ()\n+      && current_token->get_id () != DOT\n+      && current_token->get_id () != QUESTION_MARK)\n+    {\n+      rust_debug (\"statement expression with block\");\n+      expr->set_outer_attrs (std::move (outer_attrs));\n+      return expr;\n+    }\n+\n   // stop parsing if find lower priority token - parse higher priority first\n-  while (right_binding_power < left_binding_power (lexer.peek_token ()))\n+  while (right_binding_power < left_binding_power (current_token))\n     {\n-      current_token = lexer.peek_token ();\n       lexer.skip_token ();\n \n+      // FIXME attributes should generally be applied to the null denotation.\n       expr = left_denotation (current_token, std::move (expr),\n \t\t\t      std::move (outer_attrs), restrictions);\n \n@@ -12713,6 +12351,8 @@ Parser<ManagedTokenSource>::parse_expr (int right_binding_power,\n \n \t  return nullptr;\n \t}\n+\n+      current_token = lexer.peek_token ();\n     }\n \n   return expr;\n@@ -12727,10 +12367,7 @@ Parser<ManagedTokenSource>::parse_expr (AST::AttrVec outer_attrs,\n   return parse_expr (LBP_LOWEST, std::move (outer_attrs), restrictions);\n }\n \n-/* Determines action to take when finding token at beginning of expression.\n- * FIXME: this may only apply to precedence-capable expressions (which are all\n- * expressions without blocks), so make return type ExprWithoutBlock? It would\n- * simplify stuff. */\n+/* Determines action to take when finding token at beginning of expression. */\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::Expr>\n Parser<ManagedTokenSource>::null_denotation (const_TokenPtr tok,\n@@ -13144,6 +12781,8 @@ Parser<ManagedTokenSource>::null_denotation (const_TokenPtr tok,\n \t  // if expr\n \t  return parse_if_expr (std::move (outer_attrs), tok->get_locus ());\n \t}\n+    case LIFETIME:\n+      return parse_labelled_loop_expr (tok, std::move (outer_attrs));\n     case LOOP:\n       return parse_loop_expr (std::move (outer_attrs), AST::LoopLabel::error (),\n \t\t\t      tok->get_locus ());\n@@ -13158,6 +12797,9 @@ Parser<ManagedTokenSource>::null_denotation (const_TokenPtr tok,\n \t\t\t\t\tAST::LoopLabel::error (),\n \t\t\t\t\ttok->get_locus ());\n \t}\n+    case FOR:\n+      return parse_for_loop_expr (std::move (outer_attrs),\n+\t\t\t\t  AST::LoopLabel::error ());\n     case MATCH_TOK:\n       // also an expression with block\n       return parse_match_expr (std::move (outer_attrs), tok->get_locus ());\n@@ -14700,7 +14342,9 @@ Parser<ManagedTokenSource>::parse_macro_invocation_partial (\n \n   return AST::MacroInvocation::Regular (\n     AST::MacroInvocData (std::move (converted_path), std::move (tok_tree)),\n-    std::move (outer_attrs), macro_locus, restrictions.expr_can_be_stmt);\n+    std::move (outer_attrs), macro_locus,\n+    restrictions.expr_can_be_stmt\n+      && lexer.peek_token ()->get_id () == SEMICOLON);\n }\n \n /* Parses a struct expr struct with a path in expression already parsed (but"}, {"sha": "1e7e5262eec5882b81948488de9cd64591161ff0", "filename": "gcc/rust/parse/rust-parse.h", "status": "modified", "additions": 5, "deletions": 17, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/136ef0912e962052446de93d822c4661578d805a/gcc%2Frust%2Fparse%2Frust-parse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/136ef0912e962052446de93d822c4661578d805a/gcc%2Frust%2Fparse%2Frust-parse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse.h?ref=136ef0912e962052446de93d822c4661578d805a", "patch": "@@ -276,6 +276,7 @@ template <typename ManagedTokenSource> class Parser\n   template <typename EndTokenPred>\n   std::vector<AST::Lifetime> parse_lifetime_bounds (EndTokenPred is_end_token);\n   AST::Lifetime parse_lifetime ();\n+  AST::Lifetime lifetime_from_token (const_TokenPtr tok);\n   std::unique_ptr<AST::ExternalTypeItem>\n   parse_external_type_item (AST::Visibility vis, AST::AttrVec outer_attrs);\n   std::unique_ptr<AST::TypeAlias> parse_type_alias (AST::Visibility vis,\n@@ -531,13 +532,6 @@ template <typename ManagedTokenSource> class Parser\n     AST::AttrVec outer_attrs,\n     ParseRestrictions restrictions = ParseRestrictions ());\n \n-  // Expression-related (non-Pratt parsed)\n-  std::unique_ptr<AST::ExprWithBlock>\n-  parse_expr_with_block (AST::AttrVec outer_attrs);\n-  std::unique_ptr<AST::ExprWithoutBlock>\n-  parse_expr_without_block (AST::AttrVec outer_attrs = AST::AttrVec (),\n-\t\t\t    ParseRestrictions restrictions\n-\t\t\t    = ParseRestrictions ());\n   // When given a pratt_parsed_loc, use it as the location of the\n   // first token parsed in the expression (the parsing of that first\n   // token should be skipped).\n@@ -569,8 +563,9 @@ template <typename ManagedTokenSource> class Parser\n   std::vector<std::unique_ptr<AST::Pattern> >\n   parse_match_arm_patterns (TokenId end_token_id);\n   std::unique_ptr<AST::BaseLoopExpr>\n-  parse_labelled_loop_expr (AST::AttrVec outer_attrs = AST::AttrVec ());\n-  AST::LoopLabel parse_loop_label ();\n+  parse_labelled_loop_expr (const_TokenPtr tok,\n+\t\t\t    AST::AttrVec outer_attrs = AST::AttrVec ());\n+  AST::LoopLabel parse_loop_label (const_TokenPtr tok);\n   std::unique_ptr<AST::AsyncBlockExpr>\n   parse_async_block_expr (AST::AttrVec outer_attrs = AST::AttrVec ());\n   std::unique_ptr<AST::GroupedExpr> parse_grouped_expr (AST::AttrVec outer_attrs\n@@ -637,14 +632,7 @@ template <typename ManagedTokenSource> class Parser\n   std::unique_ptr<AST::ExprStmt> parse_expr_stmt (AST::AttrVec outer_attrs,\n \t\t\t\t\t\t  ParseRestrictions restrictions\n \t\t\t\t\t\t  = ParseRestrictions ());\n-  std::unique_ptr<AST::ExprStmt>\n-  parse_expr_stmt_with_block (AST::AttrVec outer_attrs);\n-  std::unique_ptr<AST::ExprStmt>\n-  parse_expr_stmt_without_block (AST::AttrVec outer_attrs,\n-\t\t\t\t ParseRestrictions restrictions\n-\t\t\t\t = ParseRestrictions ());\n-  ExprOrStmt parse_stmt_or_expr_without_block ();\n-  ExprOrStmt parse_stmt_or_expr_with_block (AST::AttrVec outer_attrs);\n+  ExprOrStmt parse_stmt_or_expr ();\n   ExprOrStmt parse_macro_invocation_maybe_semi (AST::AttrVec outer_attrs);\n   ExprOrStmt parse_path_based_stmt_or_expr (AST::AttrVec outer_attrs);\n "}, {"sha": "95dcf2ef50554f5cba51e3fc2c5eb5598ce3301d", "filename": "gcc/testsuite/rust/compile/for_expr.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/136ef0912e962052446de93d822c4661578d805a/gcc%2Ftestsuite%2Frust%2Fcompile%2Ffor_expr.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/136ef0912e962052446de93d822c4661578d805a/gcc%2Ftestsuite%2Frust%2Fcompile%2Ffor_expr.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ffor_expr.rs?ref=136ef0912e962052446de93d822c4661578d805a", "patch": "@@ -0,0 +1,6 @@\n+// { dg-options \"-fsyntax-only\" }\n+\n+fn main() {\n+    for a in 0..10 {}\n+    (for b in 0..10 {})\n+}"}, {"sha": "96bb9c167734e91e8dda68cec58b94569c2c5edb", "filename": "gcc/testsuite/rust/compile/issue-2189.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/136ef0912e962052446de93d822c4661578d805a/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-2189.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/136ef0912e962052446de93d822c4661578d805a/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-2189.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-2189.rs?ref=136ef0912e962052446de93d822c4661578d805a", "patch": "@@ -0,0 +1,5 @@\n+#[allow(unused_unsafe)]\n+\n+pub fn foo() {\n+    unsafe { (0, 1) }.0;\n+}"}, {"sha": "2d60d6d72b89ae02056e3635084e958e58e10475", "filename": "gcc/testsuite/rust/compile/issue-407-2.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/136ef0912e962052446de93d822c4661578d805a/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-407-2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/136ef0912e962052446de93d822c4661578d805a/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-407-2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-407-2.rs?ref=136ef0912e962052446de93d822c4661578d805a", "patch": "@@ -1,21 +1,18 @@\n // #407\n pub fn loopy()  {\n     let mut a = 1;\n-    // { dg-error {failed to parse expr with block in parsing expr statement} \"\" { target *-*-* } .+2 }\n-    // { dg-error {failed to parse statement or expression without block in block expression} \"\" { target *-*-* } .+1 }\n     loop {\n-        // { dg-error {failed to parse expr with block in parsing expr statement} \"\" { target *-*-* } .+2 }\n-        // { dg-error {failed to parse statement or expression without block in block expression} \"\" { target *-*-* } .+1 }\n-\tif a < 40 {\n-\t    a + = 1; // { dg-error \"found unexpected token '=' in null denotation\" }\n-            // { dg-error {failed to parse expression for expression without block \\(pratt-parsed expression is null\\)} \"\" { target *-*-* } .-1 }\n-            // { dg-error {failed to parse statement or expression without block in block expression} \"\" { target *-*-* } .-2 }\n-            // { dg-error {failed to parse if body block expression in if expression} \"\" { target *-*-* } .-3 }\n-            // { dg-error {could not parse loop body in \\(infinite\\) loop expression} \"\" { target *-*-* } .+1 }\n-\t} else {\n-\t    break;\n-\t}\n+        // { dg-error {failed to parse statement or expression in block expression} \"\" { target *-*-* } .-1 }\n+        if a < 40 {\n+            // { dg-error {failed to parse statement or expression in block expression} \"\" { target *-*-* } .-1 }\n+            a + = 1; // { dg-error \"found unexpected token '=' in null denotation\" }\n+            // { dg-error {failed to parse statement or expression in block expression} \"\" { target *-*-* } .-1 }\n+            // { dg-error {failed to parse if body block expression in if expression} \"\" { target *-*-* } .-2 }\n+            // { dg-error {could not parse loop body in \\(infinite\\) loop expression} \"\" { target *-*-* } .-3 }\n+            // { dg-error {unrecognised token 'integer literal' for start of item} \"\" { target *-*-* } .-4 }\n+            // { dg-error {failed to parse item in crate} \"\" { target *-*-* } .-5 }\n+        } else {\n+            break;\n+        }\n     }\n }\n-// { dg-error {unrecognised token '\\}' for start of item} \"\" { target *-*-* } .-1 }\n-// { dg-error {failed to parse item in crate} \"\" { target *-*-* } .-2 }"}, {"sha": "bd0d3069b10993942ba7aa7de9e77aba9a0ea1bc", "filename": "gcc/testsuite/rust/compile/issue-407.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/136ef0912e962052446de93d822c4661578d805a/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-407.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/136ef0912e962052446de93d822c4661578d805a/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-407.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-407.rs?ref=136ef0912e962052446de93d822c4661578d805a", "patch": "@@ -2,8 +2,7 @@\n fn test()  {\n     let mut a = 1;\n     a + = 1; // { dg-error \"found unexpected token '=' in null denotation\" }\n-    // { dg-error {failed to parse expression for expression without block \\(pratt-parsed expression is null\\)} \"\" { target *-*-* } .-1 }\n-    // { dg-error {failed to parse statement or expression without block in block expression} \"\" { target *-*-* } .-2 }\n-    // { dg-error {unrecognised token 'integer literal' for start of item} \"\" { target *-*-* } .-3 }\n-    // { dg-error {failed to parse item in crate} \"\" { target *-*-* } .-4 }\n+    // { dg-error {failed to parse statement or expression in block expression} \"\" { target *-*-* } .-1 }\n+    // { dg-error {unrecognised token 'integer literal' for start of item} \"\" { target *-*-* } .-2 }\n+    // { dg-error {failed to parse item in crate} \"\" { target *-*-* } .-3 }\n }"}, {"sha": "e5f9b29bd59550f96dbbef6d193506b48672ee1f", "filename": "gcc/testsuite/rust/compile/issue-867.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/136ef0912e962052446de93d822c4661578d805a/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-867.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/136ef0912e962052446de93d822c4661578d805a/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-867.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-867.rs?ref=136ef0912e962052446de93d822c4661578d805a", "patch": "@@ -2,7 +2,7 @@ fn main() {\n     let _ = 42;\n     let a = _ + 123; // { dg-error \"use of '_' is not allowed on the right-side of an assignment\" }\n                      // { dg-error {failed to parse expression in let statement} \"\" { target *-*-* } .-1  }\n-                     // { dg-error {failed to parse statement or expression without block in block expression} \"\" { target *-*-* } .-2 }\n+                     // { dg-error {failed to parse statement or expression in block expression} \"\" { target *-*-* } .-2 }\n                      // { dg-error {unrecognised token '\\}' for start of item} \"\" { target *-*-* } .+2 }\n                      // { dg-error {failed to parse item in crate} \"\" { target *-*-* } .+1 }\n }"}, {"sha": "3d18cc94a2262f5c33273ad5872f7a08bbcd59ca", "filename": "gcc/testsuite/rust/compile/macro_call_statement.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/136ef0912e962052446de93d822c4661578d805a/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro_call_statement.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/136ef0912e962052446de93d822c4661578d805a/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro_call_statement.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro_call_statement.rs?ref=136ef0912e962052446de93d822c4661578d805a", "patch": "@@ -0,0 +1,11 @@\n+fn f() {}\n+\n+macro_rules! panic {\n+    () => (\n+        crate::f()\n+    );\n+}\n+\n+fn main() {\n+    panic!();\n+}"}, {"sha": "ae623c345579620a9e332aec254dab9be8ce8d33", "filename": "gcc/testsuite/rust/compile/stmt_with_block_dot.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/136ef0912e962052446de93d822c4661578d805a/gcc%2Ftestsuite%2Frust%2Fcompile%2Fstmt_with_block_dot.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/136ef0912e962052446de93d822c4661578d805a/gcc%2Ftestsuite%2Frust%2Fcompile%2Fstmt_with_block_dot.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fstmt_with_block_dot.rs?ref=136ef0912e962052446de93d822c4661578d805a", "patch": "@@ -0,0 +1,20 @@\n+pub struct A(i32, i32);\n+\n+trait Clone {\n+    fn clone(&self) -> Self;\n+}\n+\n+impl Clone for A {\n+    fn clone(&self) -> A {\n+        A(self.0, self.1)\n+    }\n+}\n+\n+pub fn foo(c: bool, d: i32) {\n+    { (0, 1) }.0 + 1;\n+    if c { A(4, 5) } else { A(12, 23) }.clone().0 * 5;\n+    match d { 1 => A(-5, 0), _ => A(-23, -6) }.clone();\n+    match d {\n+        _ => { (4, 5) }.1 / 3,\n+    };\n+}"}, {"sha": "ef6ea94d4cea2f7d7752046099e7bc6db8495aa5", "filename": "gcc/testsuite/rust/compile/torture/loop8.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/136ef0912e962052446de93d822c4661578d805a/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Floop8.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/136ef0912e962052446de93d822c4661578d805a/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Floop8.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Floop8.rs?ref=136ef0912e962052446de93d822c4661578d805a", "patch": "@@ -0,0 +1,7 @@\n+fn main() {\n+    ('outer: loop {\n+        'inner: loop {\n+            break 'outer;\n+        }\n+    })\n+}"}]}