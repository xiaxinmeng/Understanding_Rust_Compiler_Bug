{"sha": "7dcc645ccd085045f628a25760788221cb83c504", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2RjYzY0NWNjZDA4NTA0NWY2MjhhMjU3NjA3ODgyMjFjYjgzYzUwNA==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2017-03-10T15:29:38Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2017-03-10T15:29:38Z"}, "message": "P0604R0 add invoke_result, is_invocable etc. for C++17\n\n\t* include/bits/invoke.h (__invoke): Use __invoke_result instead of\n\tresult_of, and __is_nothrow_invocable instead of\n\t__is_nothrow_callable.\n\t* include/bits/shared_ptr_base.h (__shared_ptr): Use __is_invocable\n\tinstead of __is_callable.\n\t* include/std/functional (invoke): use invoke_result_t instead of\n\tresult_of_t and is_nothrow_invocable instead of is_nothrow_callable.\n\t(_Not_fn): Use __invoke_result instead of result_of.\n\t* include/std/type_traits (__result_of_memobj, __result_of_memfun):\n\tRemove partial specializations for reference_wrapper types.\n\t(__result_of_impl): Use __inv_unwrap to strip reference_wrapper.\n\t(__invoke_result): Define replacement for result_of and then use it to\n\tdefine result_of.\n\t(__is_callable_impl, __is_callable, __is_nothrow_callable): Replace\n\twith __is_invocable_impl, __is_invocable, and __is_nothrow_invocable\n\trespectively.\n\t(invoke_result, invoke_result_t): Define for C++17.\n\t(is_callable, is_nothrow_callable): Replace with is_invocable,\n\tis_invocable_r, is_nothrow_invocable, and is_nothrow_invocable_r.\n\t(is_callable_v, is_nothrow_callable_v): Replace with is_invocable_v,\n\tis_invocable_r_v, is_nothrow_invocable_v, and is_nothrow_invocable_r_v.\n\t* include/std/variant (hash<variant<T...>>): Use is_nothrow_invocable_v\n\tinstead of is_nothrow_callable_v.\n\t* testsuite/20_util/function_objects/invoke/59768.cc: Remove unused\n\tmain function.\n\t* testsuite/20_util/function_objects/not_fn/1.cc: Use is_invocable\n\tinstead of is_callable.\n\t* testsuite/20_util/is_callable/*: Rename directory and adjust tests\n\tto use new traits.\n\t* testsuite/20_util/is_notjrow_callable/*: Likewise.\n\t* testsuite/20_util/optional/hash.cc: Use is_invocable_v instead of\n\tis_callable.\n\t* testsuite/20_util/variant/hash.cc: Likewise.\n\nFrom-SVN: r246036", "tree": {"sha": "4ad614b7e968ead7b07abb7d482f04d23bc2ee2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4ad614b7e968ead7b07abb7d482f04d23bc2ee2c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7dcc645ccd085045f628a25760788221cb83c504", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7dcc645ccd085045f628a25760788221cb83c504", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7dcc645ccd085045f628a25760788221cb83c504", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7dcc645ccd085045f628a25760788221cb83c504/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a147ef113d5c6c0fd44e2de7149c8fbd1e2a7882", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a147ef113d5c6c0fd44e2de7149c8fbd1e2a7882", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a147ef113d5c6c0fd44e2de7149c8fbd1e2a7882"}], "stats": {"total": 955, "additions": 511, "deletions": 444}, "files": [{"sha": "a6ae03da06789b2ad996903e7e923a7a148bc585", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dcc645ccd085045f628a25760788221cb83c504/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dcc645ccd085045f628a25760788221cb83c504/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=7dcc645ccd085045f628a25760788221cb83c504", "patch": "@@ -1,3 +1,39 @@\n+2017-03-10  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\t* include/bits/invoke.h (__invoke): Use __invoke_result instead of\n+\tresult_of, and __is_nothrow_invocable instead of\n+\t__is_nothrow_callable.\n+\t* include/bits/shared_ptr_base.h (__shared_ptr): Use __is_invocable\n+\tinstead of __is_callable.\n+\t* include/std/functional (invoke): use invoke_result_t instead of\n+\tresult_of_t and is_nothrow_invocable instead of is_nothrow_callable.\n+\t(_Not_fn): Use __invoke_result instead of result_of.\n+\t* include/std/type_traits (__result_of_memobj, __result_of_memfun):\n+\tRemove partial specializations for reference_wrapper types.\n+\t(__result_of_impl): Use __inv_unwrap to strip reference_wrapper.\n+\t(__invoke_result): Define replacement for result_of and then use it to\n+\tdefine result_of.\n+\t(__is_callable_impl, __is_callable, __is_nothrow_callable): Replace\n+\twith __is_invocable_impl, __is_invocable, and __is_nothrow_invocable\n+\trespectively.\n+\t(invoke_result, invoke_result_t): Define for C++17.\n+\t(is_callable, is_nothrow_callable): Replace with is_invocable,\n+\tis_invocable_r, is_nothrow_invocable, and is_nothrow_invocable_r.\n+\t(is_callable_v, is_nothrow_callable_v): Replace with is_invocable_v,\n+\tis_invocable_r_v, is_nothrow_invocable_v, and is_nothrow_invocable_r_v.\n+\t* include/std/variant (hash<variant<T...>>): Use is_nothrow_invocable_v\n+\tinstead of is_nothrow_callable_v.\n+\t* testsuite/20_util/function_objects/invoke/59768.cc: Remove unused\n+\tmain function.\n+\t* testsuite/20_util/function_objects/not_fn/1.cc: Use is_invocable\n+\tinstead of is_callable.\n+\t* testsuite/20_util/is_callable/*: Rename directory and adjust tests\n+\tto use new traits.\n+\t* testsuite/20_util/is_notjrow_callable/*: Likewise.\n+\t* testsuite/20_util/optional/hash.cc: Use is_invocable_v instead of\n+\tis_callable.\n+\t* testsuite/20_util/variant/hash.cc: Likewise.\n+\n 2017-03-10  George Lander  <george.lander@arm.com>\n \n \t* acinclude.m4 (glibcxx_cv_obsolete_isnan): Define"}, {"sha": "eba8707435b06d80da1c54a2786a31d1ab88985d", "filename": "libstdc++-v3/include/bits/invoke.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dcc645ccd085045f628a25760788221cb83c504/libstdc%2B%2B-v3%2Finclude%2Fbits%2Finvoke.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dcc645ccd085045f628a25760788221cb83c504/libstdc%2B%2B-v3%2Finclude%2Fbits%2Finvoke.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Finvoke.h?ref=7dcc645ccd085045f628a25760788221cb83c504", "patch": "@@ -85,13 +85,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   /// Invoke a callable object.\n   template<typename _Callable, typename... _Args>\n-    constexpr typename result_of<_Callable&&(_Args&&...)>::type\n+    constexpr typename __invoke_result<_Callable, _Args...>::type\n     __invoke(_Callable&& __fn, _Args&&... __args)\n-    noexcept(__is_nothrow_callable<_Callable&&(_Args&&...)>::value)\n+    noexcept(__is_nothrow_invocable<_Callable, _Args...>::value)\n     {\n-      using __result_of = result_of<_Callable&&(_Args&&...)>;\n-      using __type = typename __result_of::type;\n-      using __tag = typename __result_of::__invoke_type;\n+      using __result = __invoke_result<_Callable, _Args...>;\n+      using __type = typename __result::type;\n+      using __tag = typename __result::__invoke_type;\n       return std::__invoke_impl<__type>(__tag{}, std::forward<_Callable>(__fn),\n \t\t\t\t\tstd::forward<_Args>(__args)...);\n     }"}, {"sha": "a203f42c5151291b4be840b6a66cfeb8c82b76a3", "filename": "libstdc++-v3/include/bits/shared_ptr_base.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dcc645ccd085045f628a25760788221cb83c504/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dcc645ccd085045f628a25760788221cb83c504/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr_base.h?ref=7dcc645ccd085045f628a25760788221cb83c504", "patch": "@@ -1085,7 +1085,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t__shared_ptr(_Yp* __p, _Deleter __d)\n \t: _M_ptr(__p), _M_refcount(__p, __d)\n \t{\n-\t  static_assert(__is_callable<_Deleter&(_Yp*&)>::value,\n+\t  static_assert(__is_invocable<_Deleter&, _Yp*&>::value,\n \t      \"deleter expression d(p) is well-formed\");\n \t  _M_enable_shared_from_this_with(__p);\n \t}\n@@ -1095,7 +1095,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t__shared_ptr(_Yp* __p, _Deleter __d, _Alloc __a)\n \t: _M_ptr(__p), _M_refcount(__p, __d, std::move(__a))\n \t{\n-\t  static_assert(__is_callable<_Deleter&(_Yp*&)>::value,\n+\t  static_assert(__is_invocable<_Deleter&, _Yp*&>::value,\n \t      \"deleter expression d(p) is well-formed\");\n \t  _M_enable_shared_from_this_with(__p);\n \t}"}, {"sha": "ae5bc0a3bf9388972f9a2301918d6aca13197d6d", "filename": "libstdc++-v3/include/std/functional", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dcc645ccd085045f628a25760788221cb83c504/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dcc645ccd085045f628a25760788221cb83c504/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional?ref=7dcc645ccd085045f628a25760788221cb83c504", "patch": "@@ -73,9 +73,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   /// Invoke a callable object.\n   template<typename _Callable, typename... _Args>\n-    inline result_of_t<_Callable&&(_Args&&...)>\n+    inline invoke_result_t<_Callable, _Args...>\n     invoke(_Callable&& __fn, _Args&&... __args)\n-    noexcept(is_nothrow_callable_v<_Callable&&(_Args&&...)>)\n+    noexcept(is_nothrow_invocable_v<_Callable, _Args...>)\n     {\n       return std::__invoke(std::forward<_Callable>(__fn),\n \t\t\t   std::forward<_Args>(__args)...);\n@@ -903,7 +903,7 @@ _GLIBCXX_MEM_FN_TRAITS(&&, false_type, true_type)\n     class _Not_fn\n     {\n       template<typename _Fn2, typename... _Args>\n-\tusing __inv_res_t = result_of_t<_Fn2(_Args&&...)>;\n+\tusing __inv_res_t = typename __invoke_result<_Fn2, _Args...>::type;\n \n       template<typename _Tp>\n \tstatic decltype(!std::declval<_Tp>())"}, {"sha": "7d067cabd72e5b9e6ed0e9e76314ca4de3449960", "filename": "libstdc++-v3/include/std/type_traits", "status": "modified", "additions": 89, "deletions": 110, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dcc645ccd085045f628a25760788221cb83c504/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dcc645ccd085045f628a25760788221cb83c504/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits?ref=7dcc645ccd085045f628a25760788221cb83c504", "patch": "@@ -2392,59 +2392,18 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   // 2219.  INVOKE-ing a pointer to member with a reference_wrapper\n   //        as the object expression\n \n-  template<typename _Res, typename _Class, typename _Arg>\n-    struct __result_of_memobj<_Res _Class::*, reference_wrapper<_Arg>>\n-    : __result_of_memobj_ref<_Res _Class::*, _Arg&>\n-    { };\n-\n-  template<typename _Res, typename _Class, typename _Arg>\n-    struct __result_of_memobj<_Res _Class::*, reference_wrapper<_Arg>&>\n-    : __result_of_memobj_ref<_Res _Class::*, _Arg&>\n-    { };\n-\n-  template<typename _Res, typename _Class, typename _Arg>\n-    struct __result_of_memobj<_Res _Class::*, const reference_wrapper<_Arg>&>\n-    : __result_of_memobj_ref<_Res _Class::*, _Arg&>\n-    { };\n-\n-  template<typename _Res, typename _Class, typename _Arg>\n-    struct __result_of_memobj<_Res _Class::*, reference_wrapper<_Arg>&&>\n-    : __result_of_memobj_ref<_Res _Class::*, _Arg&>\n-    { };\n-\n-  template<typename _Res, typename _Class, typename _Arg>\n-    struct __result_of_memobj<_Res _Class::*, const reference_wrapper<_Arg>&&>\n-    : __result_of_memobj_ref<_Res _Class::*, _Arg&>\n-    { };\n-\n-  template<typename _Res, typename _Class, typename _Arg, typename... _Args>\n-    struct __result_of_memfun<_Res _Class::*, reference_wrapper<_Arg>, _Args...>\n-    : __result_of_memfun_ref<_Res _Class::*, _Arg&, _Args...>\n-    { };\n-\n-  template<typename _Res, typename _Class, typename _Arg, typename... _Args>\n-    struct __result_of_memfun<_Res _Class::*, reference_wrapper<_Arg>&,\n-\t\t\t      _Args...>\n-    : __result_of_memfun_ref<_Res _Class::*, _Arg&, _Args...>\n-    { };\n-\n-  template<typename _Res, typename _Class, typename _Arg, typename... _Args>\n-    struct __result_of_memfun<_Res _Class::*, const reference_wrapper<_Arg>&,\n-\t\t\t      _Args...>\n-    : __result_of_memfun_ref<_Res _Class::*, _Arg&, _Args...>\n-    { };\n-\n-  template<typename _Res, typename _Class, typename _Arg, typename... _Args>\n-    struct __result_of_memfun<_Res _Class::*, reference_wrapper<_Arg>&&,\n-\t\t\t      _Args...>\n-    : __result_of_memfun_ref<_Res _Class::*, _Arg&, _Args...>\n-    { };\n+  // Used by result_of, invoke etc. to unwrap a reference_wrapper.\n+  template<typename _Tp, typename _Up = typename decay<_Tp>::type>\n+    struct __inv_unwrap\n+    {\n+      using type = _Tp;\n+    };\n \n-  template<typename _Res, typename _Class, typename _Arg, typename... _Args>\n-    struct __result_of_memfun<_Res _Class::*, const reference_wrapper<_Arg>&&,\n-\t\t\t      _Args...>\n-    : __result_of_memfun_ref<_Res _Class::*, _Arg&, _Args...>\n-    { };\n+  template<typename _Tp, typename _Up>\n+    struct __inv_unwrap<_Tp, reference_wrapper<_Up>>\n+    {\n+      using type = _Up&;\n+    };\n \n   template<bool, bool, typename _Functor, typename... _ArgTypes>\n     struct __result_of_impl\n@@ -2454,12 +2413,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   template<typename _MemPtr, typename _Arg>\n     struct __result_of_impl<true, false, _MemPtr, _Arg>\n-    : public __result_of_memobj<typename decay<_MemPtr>::type, _Arg>\n+    : public __result_of_memobj<typename decay<_MemPtr>::type,\n+\t\t\t\ttypename __inv_unwrap<_Arg>::type>\n     { };\n \n   template<typename _MemPtr, typename _Arg, typename... _Args>\n     struct __result_of_impl<false, true, _MemPtr, _Arg, _Args...>\n-    : public __result_of_memfun<typename decay<_MemPtr>::type, _Arg, _Args...>\n+    : public __result_of_memfun<typename decay<_MemPtr>::type,\n+\t\t\t\ttypename __inv_unwrap<_Arg>::type, _Args...>\n     { };\n \n   // [func.require] paragraph 1 bullet 5:\n@@ -2481,19 +2442,25 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       typedef decltype(_S_test<_Functor, _ArgTypes...>(0)) type;\n     };\n \n+  // __invoke_result (std::invoke_result for C++11)\n   template<typename _Functor, typename... _ArgTypes>\n-    struct result_of<_Functor(_ArgTypes...)>\n+    struct __invoke_result\n     : public __result_of_impl<\n         is_member_object_pointer<\n           typename remove_reference<_Functor>::type\n         >::value,\n         is_member_function_pointer<\n           typename remove_reference<_Functor>::type\n         >::value,\n-\t    _Functor, _ArgTypes...\n+\t_Functor, _ArgTypes...\n       >::type\n     { };\n \n+  template<typename _Functor, typename... _ArgTypes>\n+    struct result_of<_Functor(_ArgTypes...)>\n+    : public __invoke_result<_Functor, _ArgTypes...>\n+    { };\n+\n #if __cplusplus > 201103L\n   /// Alias template for aligned_storage\n   template<size_t _Len, size_t _Align =\n@@ -2781,37 +2748,21 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n #endif// c++1z or gnu++11\n \n-  // __is_callable (std::is_callable for C++11)\n+  // __is_invocable (std::is_invocable for C++11)\n \n-  template<typename _Result, typename _Ret, typename = __void_t<>>\n-    struct __is_callable_impl : false_type { };\n+  template<typename _Result, typename _Ret, typename = void>\n+    struct __is_invocable_impl : false_type { };\n \n   template<typename _Result, typename _Ret>\n-    struct __is_callable_impl<_Result, _Ret, __void_t<typename _Result::type>>\n+    struct __is_invocable_impl<_Result, _Ret, __void_t<typename _Result::type>>\n     : __or_<is_void<_Ret>, is_convertible<typename _Result::type, _Ret>>::type\n     { };\n \n-  template<typename, typename _Ret = void>\n-    struct __is_callable; // not defined\n-\n-  template<typename _Fn, typename... _ArgTypes, typename _Ret>\n-    struct __is_callable<_Fn(_ArgTypes...), _Ret>\n-    : __is_callable_impl<result_of<_Fn(_ArgTypes...)>, _Ret>::type\n+  template<typename _Fn, typename... _ArgTypes>\n+    struct __is_invocable\n+    : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>::type\n     { };\n \n-  // Used by __invoke and __is_nothrow_callable to unwrap a reference_wrapper.\n-  template<typename _Tp, typename _Up = typename decay<_Tp>::type>\n-    struct __inv_unwrap\n-    {\n-      using type = _Tp;\n-    };\n-\n-  template<typename _Tp, typename _Up>\n-    struct __inv_unwrap<_Tp, reference_wrapper<_Up>>\n-    {\n-      using type = _Up&;\n-    };\n-\n   template<typename _Fn, typename _Tp, typename... _Args>\n     constexpr bool __call_is_nt(__invoke_memfun_ref)\n     {\n@@ -2846,21 +2797,22 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return noexcept(std::declval<_Fn>()(std::declval<_Args>()...));\n     }\n \n-  template<typename _ResultOf, typename _Fn, typename... _Args>\n+  template<typename _Result, typename _Fn, typename... _Args>\n     struct __call_is_nothrow\n     : __bool_constant<\n-      std::__call_is_nt<_Fn, _Args...>(typename _ResultOf::__invoke_type{})>\n+\tstd::__call_is_nt<_Fn, _Args...>(typename _Result::__invoke_type{})\n+      >\n     { };\n \n-  // __is_nothrow_callable (std::is_nothrow_callable for C++11)\n-\n-  template<typename, typename _Ret = void>\n-    struct __is_nothrow_callable; // not defined\n+  template<typename _Fn, typename... _Args>\n+    using __call_is_nothrow_\n+      = __call_is_nothrow<__invoke_result<_Fn, _Args...>, _Fn, _Args...>;\n \n-  template<typename _Fn, typename... _Args, typename _Ret>\n-    struct __is_nothrow_callable<_Fn(_Args...), _Ret>\n-    : __and_<__is_callable<_Fn(_Args...), _Ret>,\n-             __call_is_nothrow<result_of<_Fn(_Args...)>, _Fn, _Args...>>::type\n+  // __is_nothrow_invocable (std::is_nothrow_invocable for C++11)\n+  template<typename _Fn, typename... _Args>\n+    struct __is_nothrow_invocable\n+    : __and_<__is_invocable<_Fn, _Args...>,\n+             __call_is_nothrow_<_Fn, _Args...>>::type\n     { };\n \n   struct __nonesuch {\n@@ -2871,36 +2823,63 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   };\n \n #if __cplusplus > 201402L\n-# define __cpp_lib_is_callable 201603\n+# define __cpp_lib_is_invocable 201703\n+\n+  /// std::invoke_result\n+  template<typename _Functor, typename... _ArgTypes>\n+    struct invoke_result\n+    : public __invoke_result<_Functor, _ArgTypes...>\n+    { };\n+\n+  /// std::invoke_result_t\n+  template<typename _Fn, typename... _Args>\n+    using invoke_result_t = typename invoke_result<_Fn, _Args...>::type;\n \n-  /// std::is_callable\n-  template<typename, typename _Ret = void>\n-    struct is_callable; // not defined\n+  /// std::is_invocable\n+  template<typename _Fn, typename... _ArgTypes>\n+    struct is_invocable\n+    : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>::type\n+    { };\n \n-  template<typename _Fn, typename... _ArgTypes, typename _Ret>\n-    struct is_callable<_Fn(_ArgTypes...), _Ret>\n-    : __is_callable<_Fn(_ArgTypes...), _Ret>::type\n+  /// std::is_invocable_r\n+  template<typename _Ret, typename _Fn, typename... _ArgTypes>\n+    struct is_invocable_r\n+    : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, _Ret>::type\n     { };\n \n-  /// std::is_nothrow_callable\n-  template<typename, typename _Ret = void>\n-    struct is_nothrow_callable; // not defined\n+  /// std::is_nothrow_invocable\n+  template<typename _Fn, typename... _ArgTypes>\n+    struct is_nothrow_invocable\n+    : __and_<__is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>,\n+             __call_is_nothrow_<_Fn, _ArgTypes...>>::type\n+    { };\n \n-  template<typename _Fn, typename... _ArgTypes, typename _Ret>\n-    struct is_nothrow_callable<_Fn(_ArgTypes...), _Ret>\n-    : __is_nothrow_callable<_Fn(_ArgTypes...), _Ret>::type\n+  /// std::is_nothrow_invocable_r\n+  template<typename _Ret, typename _Fn, typename... _ArgTypes>\n+    struct is_nothrow_invocable_r\n+    : __and_<__is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, _Ret>,\n+             __call_is_nothrow_<_Fn, _ArgTypes...>>::type\n     { };\n \n-  /// std::is_callable_v\n-  template<typename _Tp, typename _Ret = void>\n-    constexpr bool is_callable_v = is_callable<_Tp, _Ret>::value;\n+  /// std::is_invocable_v\n+  template<typename _Fn, typename... _Args>\n+    inline constexpr bool is_invocable_v = is_invocable<_Fn, _Args...>::value;\n \n-  /// std::is_nothrow_callable_v\n-  template<typename _Tp, typename _Ret = void>\n-    constexpr bool is_nothrow_callable_v\n-      = is_nothrow_callable<_Tp, _Ret>::value;\n-#endif // C++17\n+  /// std::is_nothrow_invocable_v\n+  template<typename _Fn, typename... _Args>\n+    inline constexpr bool is_nothrow_invocable_v\n+      = is_nothrow_invocable<_Fn, _Args...>::value;\n \n+  /// std::is_invocable_r_v\n+  template<typename _Fn, typename... _Args>\n+    inline constexpr bool is_invocable_r_v\n+      = is_invocable_r<_Fn, _Args...>::value;\n+\n+  /// std::is_nothrow_invocable_r_v\n+  template<typename _Fn, typename... _Args>\n+    inline constexpr bool is_nothrow_invocable_r_v\n+      = is_nothrow_invocable_r<_Fn, _Args...>::value;\n+#endif // C++17\n \n #if __cplusplus > 201402L\n # define __cpp_lib_type_trait_variable_templates 201510L"}, {"sha": "46d7b92adcfeb62decc12f38d9fd319e234f1b3e", "filename": "libstdc++-v3/include/std/variant", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dcc645ccd085045f628a25760788221cb83c504/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvariant", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dcc645ccd085045f628a25760788221cb83c504/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvariant", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvariant?ref=7dcc645ccd085045f628a25760788221cb83c504", "patch": "@@ -1236,7 +1236,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     {\n       size_t\n       operator()(const variant<_Types...>& __t) const\n-      noexcept((is_nothrow_callable_v<hash<decay_t<_Types>>(_Types)> && ...))\n+      noexcept((is_nothrow_invocable_v<hash<decay_t<_Types>>, _Types> && ...))\n       {\n \tif (!__t.valueless_by_exception())\n \t  {"}, {"sha": "823e9e0612c953a9621b149a278e1d964cc59b7e", "filename": "libstdc++-v3/testsuite/20_util/function_objects/invoke/59768.cc", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dcc645ccd085045f628a25760788221cb83c504/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction_objects%2Finvoke%2F59768.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dcc645ccd085045f628a25760788221cb83c504/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction_objects%2Finvoke%2F59768.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction_objects%2Finvoke%2F59768.cc?ref=7dcc645ccd085045f628a25760788221cb83c504", "patch": "@@ -35,9 +35,3 @@ test01()\n   std::invoke(&A::foo, refc, 100);\t\t// const lvalue\n   std::invoke(&A::foo, std::move(refc), 100);\t// const rvalue\n }\n-\n-int\n-main()\n-{\n-  test01();\n-}"}, {"sha": "f3cae38ee9a34c917cf9dc9c759ce7329fd36c98", "filename": "libstdc++-v3/testsuite/20_util/function_objects/not_fn/1.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dcc645ccd085045f628a25760788221cb83c504/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction_objects%2Fnot_fn%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dcc645ccd085045f628a25760788221cb83c504/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction_objects%2Fnot_fn%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction_objects%2Fnot_fn%2F1.cc?ref=7dcc645ccd085045f628a25760788221cb83c504", "patch": "@@ -103,7 +103,7 @@ test06()\n   F f;\n   auto notf = std::not_fn(f);\n   using NotF = decltype(notf);\n-  static_assert( std::is_callable<NotF()>::value, \"cannot negate\" );\n+  static_assert( std::is_invocable<NotF>::value, \"cannot negate\" );\n   static_assert( !noexcept(notf()), \"conversion to bool affects noexcept\" );\n }\n \n@@ -117,7 +117,7 @@ test07()\n   F f;\n   auto notf = std::not_fn(f);\n   using NotF = decltype(notf);\n-  static_assert( !std::is_callable<NotF()>::value, \"cannot negate\" );\n+  static_assert( !std::is_invocable<NotF>::value, \"cannot negate\" );\n }\n \n int"}, {"sha": "e0bb815848889e502d2846bc8fa35d80a16df925", "filename": "libstdc++-v3/testsuite/20_util/is_callable/value.cc", "status": "removed", "additions": 0, "deletions": 191, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a147ef113d5c6c0fd44e2de7149c8fbd1e2a7882/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_callable%2Fvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a147ef113d5c6c0fd44e2de7149c8fbd1e2a7882/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_callable%2Fvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_callable%2Fvalue.cc?ref=a147ef113d5c6c0fd44e2de7149c8fbd1e2a7882", "patch": "@@ -1,191 +0,0 @@\n-// Copyright (C) 2016-2017 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 3, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING3.  If not see\n-// <http://www.gnu.org/licenses/>.\n-\n-// { dg-options \"-std=gnu++17\" }\n-// { dg-do compile }\n-\n-#include <type_traits>\n-\n-#ifndef IS_CALLABLE_DEFINED\n-template<typename T, typename R = void>\n-  constexpr bool is_callable()\n-  {\n-    static_assert(std::is_callable<T, R>::value == std::is_callable_v<T, R>);\n-    return std::is_callable_v<T, R>;\n-  }\n-#endif\n-\n-void test01()\n-{\n-  using func_type_v0 = void(*)();\n-\n-  static_assert(   is_callable< func_type_v0() >(),\t    \"\");\n-  static_assert(   is_callable< func_type_v0(), void  >(),  \"\");\n-  static_assert( ! is_callable< func_type_v0(), void* >(),  \"\");\n-  static_assert( ! is_callable< func_type_v0(), int   >(),  \"\");\n-\n-  static_assert( ! is_callable< func_type_v0(int) >(),\t      \"\");\n-  static_assert( ! is_callable< func_type_v0(int), void  >(), \"\");\n-  static_assert( ! is_callable< func_type_v0(int), void* >(), \"\");\n-  static_assert( ! is_callable< func_type_v0(int), int   >(), \"\");\n-\n-  using func_type_i0 = int(*)();\n-\n-  static_assert(   is_callable< func_type_i0() >(),\t  \"\");\n-  static_assert(   is_callable< func_type_i0(), void >(), \"\");\n-  static_assert(   is_callable< func_type_i0(), int  >(), \"\");\n-  static_assert( ! is_callable< func_type_i0(), int& >(), \"\");\n-  static_assert(   is_callable< func_type_i0(), long >(), \"\");\n-\n-  static_assert( ! is_callable< func_type_i0(int) >(),\t     \"\");\n-  static_assert( ! is_callable< func_type_i0(int), void >(), \"\");\n-  static_assert( ! is_callable< func_type_i0(int), int  >(), \"\");\n-  static_assert( ! is_callable< func_type_i0(int), int& >(), \"\");\n-  static_assert( ! is_callable< func_type_i0(int), long >(), \"\");\n-\n-  using func_type_l0 = int&(*)();\n-\n-  static_assert(   is_callable< func_type_l0() >(),\t    \"\");\n-  static_assert(   is_callable< func_type_l0(), void >(),   \"\");\n-  static_assert(   is_callable< func_type_l0(), int >(),    \"\");\n-  static_assert(   is_callable< func_type_l0(), int& >(),   \"\");\n-  static_assert( ! is_callable< func_type_l0(), int&& >(),  \"\");\n-  static_assert(   is_callable< func_type_l0(), long >(),   \"\");\n-  static_assert( ! is_callable< func_type_l0(), long& >(),  \"\");\n-\n-  static_assert( ! is_callable< func_type_l0(int) >(),\t      \"\");\n-  static_assert( ! is_callable< func_type_l0(int), void >(),  \"\");\n-  static_assert( ! is_callable< func_type_l0(int), int  >(),  \"\");\n-  static_assert( ! is_callable< func_type_l0(int), int& >(),  \"\");\n-  static_assert( ! is_callable< func_type_l0(int), long >(),  \"\");\n-\n-  using func_type_ii = int(*)(int);\n-\n-  static_assert( ! is_callable< func_type_ii() >(),\t  \"\");\n-  static_assert( ! is_callable< func_type_ii(), int  >(), \"\");\n-  static_assert( ! is_callable< func_type_ii(), int& >(), \"\");\n-  static_assert( ! is_callable< func_type_ii(), long >(), \"\");\n-\n-  static_assert(   is_callable< func_type_ii(int) >(),\t      \"\");\n-  static_assert(   is_callable< func_type_ii(int), int  >(),  \"\");\n-  static_assert( ! is_callable< func_type_ii(int), int& >(),  \"\");\n-  static_assert(   is_callable< func_type_ii(int), long >(),  \"\");\n-\n-  using func_type_il = int(*)(int&);\n-\n-  static_assert( ! is_callable< func_type_il() >(),\t  \"\");\n-\n-  static_assert( ! is_callable< func_type_il(int) >(),\t      \"\");\n-  static_assert( ! is_callable< func_type_il(int), int  >(),  \"\");\n-  static_assert( ! is_callable< func_type_il(int), int& >(),  \"\");\n-  static_assert( ! is_callable< func_type_il(int), long >(),  \"\");\n-\n-  static_assert(   is_callable< func_type_il(int&) >(),\t      \"\");\n-  static_assert(   is_callable< func_type_il(int&), int  >(), \"\");\n-  static_assert( ! is_callable< func_type_il(int&), int& >(), \"\");\n-  static_assert(   is_callable< func_type_il(int&), long >(), \"\");\n-\n-  using func_type_ir = int(*)(int&&);\n-\n-  static_assert( ! is_callable< func_type_ir() >(),\t  \"\");\n-\n-  static_assert(   is_callable< func_type_ir(int) >(),\t      \"\");\n-  static_assert(   is_callable< func_type_ir(int), int  >(),  \"\");\n-  static_assert( ! is_callable< func_type_ir(int), int& >(),  \"\");\n-  static_assert(   is_callable< func_type_ir(int), long >(),  \"\");\n-\n-  static_assert( ! is_callable< func_type_ir(int&) >(),\t      \"\");\n-  static_assert( ! is_callable< func_type_ir(int&), int  >(), \"\");\n-  static_assert( ! is_callable< func_type_ir(int&), int& >(), \"\");\n-  static_assert( ! is_callable< func_type_ir(int&), long >(), \"\");\n-\n-  struct X { };\n-\n-  using mem_type_i = int X::*;\n-\n-  static_assert( ! is_callable< mem_type_i() >(),\t  \"\");\n-\n-  static_assert( ! is_callable< mem_type_i(int) >(),\t    \"\");\n-  static_assert( ! is_callable< mem_type_i(int), int  >(),  \"\");\n-  static_assert( ! is_callable< mem_type_i(int), int& >(),  \"\");\n-  static_assert( ! is_callable< mem_type_i(int), long >(),  \"\");\n-\n-  static_assert( ! is_callable< mem_type_i(int&) >(),\t    \"\");\n-  static_assert( ! is_callable< mem_type_i(int&), int  >(), \"\");\n-  static_assert( ! is_callable< mem_type_i(int&), int& >(), \"\");\n-  static_assert( ! is_callable< mem_type_i(int&), long >(), \"\");\n-\n-  static_assert(   is_callable< mem_type_i(X&) >(),\t  \"\");\n-  static_assert(   is_callable< mem_type_i(X&), int  >(), \"\");\n-  static_assert(   is_callable< mem_type_i(X&), int& >(), \"\");\n-  static_assert(   is_callable< mem_type_i(X&), long >(), \"\");\n-\n-  using memfun_type_i = int (X::*)();\n-\n-  static_assert( ! is_callable< memfun_type_i() >(),\t \"\");\n-\n-  static_assert( ! is_callable< memfun_type_i(int) >(),\t \"\");\n-\n-  static_assert( ! is_callable< memfun_type_i(int&) >(), \"\");\n-\n-  static_assert(   is_callable< memfun_type_i(X&) >(),\t      \"\");\n-  static_assert(   is_callable< memfun_type_i(X&), int  >(),  \"\");\n-  static_assert( ! is_callable< memfun_type_i(X&), int& >(),  \"\");\n-  static_assert(   is_callable< memfun_type_i(X&), long >(),  \"\");\n-  static_assert(   is_callable< memfun_type_i(X*) >(),\t      \"\");\n-\n-  static_assert( ! is_callable< memfun_type_i(const X&) >(),\t      \"\");\n-  static_assert( ! is_callable< memfun_type_i(const X&), int  >(),  \"\");\n-  static_assert( ! is_callable< memfun_type_i(X&, int) >(), \"\");\n-\n-  using memfun_type_iic = int& (X::*)(int&) const;\n-\n-  static_assert( ! is_callable< memfun_type_iic() >(),\t\t      \"\");\n-  static_assert( ! is_callable< memfun_type_iic(int)  >(),\t      \"\");\n-  static_assert( ! is_callable< memfun_type_iic(int&) >(),\t      \"\");\n-  static_assert( ! is_callable< memfun_type_iic(X&, int) >(),\t      \"\");\n-  static_assert( ! is_callable< memfun_type_iic(const X&, int) >(),  \"\");\n-  static_assert( ! is_callable< memfun_type_iic(const X&, int&, int)  >(), \"\");\n-\n-  static_assert(   is_callable< memfun_type_iic(const X&, int&)  >(),\t   \"\");\n-  static_assert(   is_callable< memfun_type_iic(const X&, int&), int  >(), \"\");\n-  static_assert(   is_callable< memfun_type_iic(const X&, int&), int& >(), \"\");\n-  static_assert(   is_callable< memfun_type_iic(const X&, int&), long >(), \"\");\n-  static_assert( ! is_callable< memfun_type_iic(const X&, int&), long& >(),\"\");\n-  static_assert(   is_callable< memfun_type_iic(const X*, int&)  >(),\t   \"\");\n-\n-  struct F {\n-    int& operator()();\n-    long& operator()() const;\n-    short& operator()(int) &&;\n-    char& operator()(int) const&;\n-  private:\n-    void operator()(int, int);\n-  };\n-  using CF = const F;\n-\n-  static_assert(   is_callable< F(),   int&   >(), \"\");\n-  static_assert(   is_callable< F&(),  int&   >(), \"\");\n-  static_assert(   is_callable< CF(),  long& >(), \"\");\n-  static_assert(   is_callable< CF&(), long& >(), \"\");\n-  static_assert(   is_callable< F(int),\t  short& >(), \"\");\n-  static_assert(   is_callable< F&(int),  char& >(), \"\");\n-  static_assert(   is_callable< CF(int),  char& >(), \"\");\n-  static_assert(   is_callable< CF&(int), char& >(), \"\");\n-\n-  static_assert( ! is_callable< F(int, int) >(), \"\");\n-}"}, {"sha": "da4d480a6cffff06851cdcba679a10f3ad0e376b", "filename": "libstdc++-v3/testsuite/20_util/is_invocable/requirements/explicit_instantiation.cc", "status": "renamed", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dcc645ccd085045f628a25760788221cb83c504/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_invocable%2Frequirements%2Fexplicit_instantiation.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dcc645ccd085045f628a25760788221cb83c504/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_invocable%2Frequirements%2Fexplicit_instantiation.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_invocable%2Frequirements%2Fexplicit_instantiation.cc?ref=7dcc645ccd085045f628a25760788221cb83c504", "patch": "@@ -25,5 +25,6 @@\n namespace std\n {\n   struct test_type { };\n-  template struct is_callable<test_type(), int>;\n+  template struct is_invocable<test_type>;\n+  template struct is_invocable_r<int, test_type>;\n }", "previous_filename": "libstdc++-v3/testsuite/20_util/is_callable/requirements/explicit_instantiation.cc"}, {"sha": "d91d765cbeb0d1a5e72cb435bd4ed42a98c51531", "filename": "libstdc++-v3/testsuite/20_util/is_invocable/requirements/explicit_instantiation_ext.cc", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dcc645ccd085045f628a25760788221cb83c504/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_invocable%2Frequirements%2Fexplicit_instantiation_ext.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dcc645ccd085045f628a25760788221cb83c504/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_invocable%2Frequirements%2Fexplicit_instantiation_ext.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_invocable%2Frequirements%2Fexplicit_instantiation_ext.cc?ref=7dcc645ccd085045f628a25760788221cb83c504", "patch": "@@ -24,5 +24,5 @@\n namespace std\n {\n   struct test_type { };\n-  template struct __is_callable<test_type(), int>;\n+  template struct __is_invocable<test_type>;\n }", "previous_filename": "libstdc++-v3/testsuite/20_util/is_callable/requirements/explicit_instantiation_ext.cc"}, {"sha": "9b4208017b4a2fb86b322c175cdc90bee60f17ef", "filename": "libstdc++-v3/testsuite/20_util/is_invocable/requirements/typedefs.cc", "status": "renamed", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dcc645ccd085045f628a25760788221cb83c504/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_invocable%2Frequirements%2Ftypedefs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dcc645ccd085045f628a25760788221cb83c504/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_invocable%2Frequirements%2Ftypedefs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_invocable%2Frequirements%2Ftypedefs.cc?ref=7dcc645ccd085045f628a25760788221cb83c504", "patch": "@@ -25,6 +25,13 @@\n void test01()\n {\n   // Check for required typedefs\n-  typedef std::is_nothrow_callable<int(), void>       test_type;\n+  typedef std::is_invocable<int>       test_type;\n+  static_assert( std::is_base_of_v<std::false_type, test_type> );\n+}\n+\n+void test02()\n+{\n+  // Check for required typedefs\n+  typedef std::is_invocable_r<void, int>       test_type;\n   static_assert( std::is_base_of_v<std::false_type, test_type> );\n }", "previous_filename": "libstdc++-v3/testsuite/20_util/is_nothrow_callable/requirements/typedefs.cc"}, {"sha": "10d4f9de7c49d9e4dfda8600e4c3bd564cb79115", "filename": "libstdc++-v3/testsuite/20_util/is_invocable/requirements/typedefs_ext.cc", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dcc645ccd085045f628a25760788221cb83c504/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_invocable%2Frequirements%2Ftypedefs_ext.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dcc645ccd085045f628a25760788221cb83c504/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_invocable%2Frequirements%2Ftypedefs_ext.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_invocable%2Frequirements%2Ftypedefs_ext.cc?ref=7dcc645ccd085045f628a25760788221cb83c504", "patch": "@@ -24,6 +24,6 @@\n void test01()\n {\n   // Check for required typedefs\n-  typedef std::__is_callable<int(), void>     test_type;\n+  typedef std::__is_invocable<int>     test_type;\n   static_assert( std::is_base_of<std::false_type, test_type>::value, \"\" );\n }", "previous_filename": "libstdc++-v3/testsuite/20_util/is_callable/requirements/typedefs_ext.cc"}, {"sha": "adfa87976fb330cdc48c122b6743b247af7b55be", "filename": "libstdc++-v3/testsuite/20_util/is_invocable/value.cc", "status": "added", "additions": 200, "deletions": 0, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dcc645ccd085045f628a25760788221cb83c504/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_invocable%2Fvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dcc645ccd085045f628a25760788221cb83c504/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_invocable%2Fvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_invocable%2Fvalue.cc?ref=7dcc645ccd085045f628a25760788221cb83c504", "patch": "@@ -0,0 +1,200 @@\n+// Copyright (C) 2016-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do compile }\n+\n+#include <type_traits>\n+\n+#ifndef IS_INVOCABLE_DEFINED\n+template<typename... T>\n+  constexpr bool is_invocable()\n+  {\n+    constexpr bool result = std::is_invocable_v<T...>;\n+    static_assert(std::is_invocable<T...>::value == result);\n+    return result;\n+  }\n+\n+template<typename R, typename... T>\n+  constexpr bool is_invocable_r()\n+  {\n+    constexpr bool result = std::is_invocable_r_v<R, T...>;\n+    static_assert(std::is_invocable_r<R, T...>::value == result);\n+    return result;\n+  }\n+#endif\n+\n+void test01()\n+{\n+  using func_type_v0 = void(*)();\n+\n+  static_assert(   is_invocable< func_type_v0 >(),\t    \"\");\n+  static_assert(   is_invocable_r<void,  func_type_v0 >(),  \"\");\n+  static_assert( ! is_invocable_r<void*, func_type_v0 >(),  \"\");\n+  static_assert( ! is_invocable_r<int,   func_type_v0 >(),  \"\");\n+\n+  static_assert( ! is_invocable< func_type_v0, int >(),\t      \"\");\n+  static_assert( ! is_invocable_r< void,  func_type_v0, int >(), \"\");\n+  static_assert( ! is_invocable_r< void*, func_type_v0, int >(), \"\");\n+  static_assert( ! is_invocable_r< int,   func_type_v0, int >(), \"\");\n+\n+  using func_type_i0 = int(*)();\n+\n+  static_assert(   is_invocable< func_type_i0 >(),\t  \"\");\n+  static_assert(   is_invocable_r<void, func_type_i0 >(), \"\");\n+  static_assert(   is_invocable_r<int,  func_type_i0 >(), \"\");\n+  static_assert( ! is_invocable_r<int&, func_type_i0 >(), \"\");\n+  static_assert(   is_invocable_r<long, func_type_i0 >(), \"\");\n+\n+  static_assert( ! is_invocable< func_type_i0, int >(),\t     \"\");\n+  static_assert( ! is_invocable_r< void, func_type_i0, int >(), \"\");\n+  static_assert( ! is_invocable_r< int,  func_type_i0, int >(), \"\");\n+  static_assert( ! is_invocable_r< int&, func_type_i0, int >(), \"\");\n+  static_assert( ! is_invocable_r< long, func_type_i0, int >(), \"\");\n+\n+  using func_type_l0 = int&(*)();\n+\n+  static_assert(   is_invocable< func_type_l0 >(),\t    \"\");\n+  static_assert(   is_invocable_r< void,  func_type_l0 >(),   \"\");\n+  static_assert(   is_invocable_r< int,   func_type_l0 >(),    \"\");\n+  static_assert(   is_invocable_r< int&,  func_type_l0 >(),   \"\");\n+  static_assert( ! is_invocable_r< int&&, func_type_l0 >(),  \"\");\n+  static_assert(   is_invocable_r< long,  func_type_l0 >(),   \"\");\n+  static_assert( ! is_invocable_r< long&, func_type_l0 >(),  \"\");\n+\n+  static_assert( ! is_invocable< func_type_l0(int) >(),\t      \"\");\n+  static_assert( ! is_invocable_r< void, func_type_l0, int >(),  \"\");\n+  static_assert( ! is_invocable_r< int,  func_type_l0, int >(),  \"\");\n+  static_assert( ! is_invocable_r< int&, func_type_l0, int >(),  \"\");\n+  static_assert( ! is_invocable_r< long, func_type_l0, int >(),  \"\");\n+\n+  using func_type_ii = int(*)(int);\n+\n+  static_assert( ! is_invocable< func_type_ii >(),\t  \"\");\n+  static_assert( ! is_invocable_r< int,  func_type_ii >(), \"\");\n+  static_assert( ! is_invocable_r< int&, func_type_ii >(), \"\");\n+  static_assert( ! is_invocable_r< long, func_type_ii >(), \"\");\n+\n+  static_assert(   is_invocable< func_type_ii, int >(),\t      \"\");\n+  static_assert(   is_invocable_r< int,  func_type_ii, int >(),  \"\");\n+  static_assert( ! is_invocable_r< int&, func_type_ii, int >(),  \"\");\n+  static_assert(   is_invocable_r< long, func_type_ii, int >(),  \"\");\n+\n+  using func_type_il = int(*)(int&);\n+\n+  static_assert( ! is_invocable< func_type_il >(),\t  \"\");\n+\n+  static_assert( ! is_invocable< func_type_il, int >(),\t      \"\");\n+  static_assert( ! is_invocable_r< int,  func_type_il, int >(),  \"\");\n+  static_assert( ! is_invocable_r< int&, func_type_il, int >(),  \"\");\n+  static_assert( ! is_invocable_r< long, func_type_il, int >(),  \"\");\n+\n+  static_assert(   is_invocable< func_type_il, int& >(),\t      \"\");\n+  static_assert(   is_invocable_r< int,  func_type_il, int& >(), \"\");\n+  static_assert( ! is_invocable_r< int&, func_type_il, int& >(), \"\");\n+  static_assert(   is_invocable_r< long, func_type_il, int& >(), \"\");\n+\n+  using func_type_ir = int(*)(int&&);\n+\n+  static_assert( ! is_invocable< func_type_ir >(),\t  \"\");\n+\n+  static_assert(   is_invocable< func_type_ir, int >(),\t      \"\");\n+  static_assert(   is_invocable_r< int,  func_type_ir, int >(),  \"\");\n+  static_assert( ! is_invocable_r< int&, func_type_ir, int >(),  \"\");\n+  static_assert(   is_invocable_r< long, func_type_ir, int >(),  \"\");\n+\n+  static_assert( ! is_invocable< func_type_ir, int& >(),\t      \"\");\n+  static_assert( ! is_invocable_r< int,  func_type_ir, int& >(), \"\");\n+  static_assert( ! is_invocable_r< int&, func_type_ir, int& >(), \"\");\n+  static_assert( ! is_invocable_r< long, func_type_ir, int& >(), \"\");\n+\n+  struct X { };\n+\n+  using mem_type_i = int X::*;\n+\n+  static_assert( ! is_invocable< mem_type_i >(),\t  \"\");\n+\n+  static_assert( ! is_invocable< mem_type_i, int >(),\t    \"\");\n+  static_assert( ! is_invocable_r< int,  mem_type_i, int >(),  \"\");\n+  static_assert( ! is_invocable_r< int&, mem_type_i, int >(),  \"\");\n+  static_assert( ! is_invocable_r< long, mem_type_i, int >(),  \"\");\n+\n+  static_assert( ! is_invocable< mem_type_i, int& >(),\t    \"\");\n+  static_assert( ! is_invocable_r< int,  mem_type_i, int& >(), \"\");\n+  static_assert( ! is_invocable_r< int&, mem_type_i, int& >(), \"\");\n+  static_assert( ! is_invocable_r< long, mem_type_i, int& >(), \"\");\n+\n+  static_assert(   is_invocable< mem_type_i, X& >(),\t  \"\");\n+  static_assert(   is_invocable_r< int,  mem_type_i, X& >(), \"\");\n+  static_assert(   is_invocable_r< int&, mem_type_i, X& >(), \"\");\n+  static_assert(   is_invocable_r< long, mem_type_i, X& >(), \"\");\n+\n+  using memfun_type_i = int (X::*)();\n+\n+  static_assert( ! is_invocable< memfun_type_i >(),\t \"\");\n+\n+  static_assert( ! is_invocable< memfun_type_i, int >(),\t \"\");\n+\n+  static_assert( ! is_invocable< memfun_type_i, int& >(), \"\");\n+\n+  static_assert(   is_invocable< memfun_type_i, X& >(),\t      \"\");\n+  static_assert(   is_invocable_r< int,  memfun_type_i, X& >(),  \"\");\n+  static_assert( ! is_invocable_r< int&, memfun_type_i, X& >(),  \"\");\n+  static_assert(   is_invocable_r< long, memfun_type_i, X& >(),  \"\");\n+  static_assert(   is_invocable< memfun_type_i, X* >(),\t      \"\");\n+\n+  static_assert( ! is_invocable< memfun_type_i, const X& >(),\t      \"\");\n+  static_assert( ! is_invocable_r< int,  memfun_type_i, const X& >(),  \"\");\n+  static_assert( ! is_invocable< memfun_type_i, X&, int >(), \"\");\n+\n+  using memfun_type_iic = int& (X::*)(int&) const;\n+\n+  static_assert( ! is_invocable< memfun_type_iic >(),\t\t      \"\");\n+  static_assert( ! is_invocable< memfun_type_iic, int  >(),\t      \"\");\n+  static_assert( ! is_invocable< memfun_type_iic, int& >(),\t      \"\");\n+  static_assert( ! is_invocable< memfun_type_iic, X&, int >(),\t      \"\");\n+  static_assert( ! is_invocable< memfun_type_iic, const X&, int >(),  \"\");\n+  static_assert( ! is_invocable< memfun_type_iic, const X&, int&, int  >(), \"\");\n+\n+  static_assert(   is_invocable< memfun_type_iic, const X&, int&  >(),\t   \"\");\n+  static_assert(   is_invocable_r< int,  memfun_type_iic, const X&, int& >(), \"\");\n+  static_assert(   is_invocable_r< int&, memfun_type_iic, const X&, int& >(), \"\");\n+  static_assert(   is_invocable_r< long, memfun_type_iic, const X&, int& >(), \"\");\n+  static_assert( ! is_invocable_r< long&, memfun_type_iic, const X&, int& >(),\"\");\n+  static_assert(   is_invocable< memfun_type_iic, const X*, int&  >(),\t   \"\");\n+\n+  struct F {\n+    int& operator()();\n+    long& operator()() const;\n+    short& operator()(int) &&;\n+    char& operator()(int) const&;\n+  private:\n+    void operator()(int, int);\n+  };\n+  using CF = const F;\n+\n+  static_assert(   is_invocable_r< int&,   F        >(), \"\");\n+  static_assert(   is_invocable_r< int&,   F&       >(), \"\");\n+  static_assert(   is_invocable_r< long&,  CF       >(), \"\");\n+  static_assert(   is_invocable_r< long&,  CF&      >(), \"\");\n+  static_assert(   is_invocable_r< short&, F,   int >(), \"\");\n+  static_assert(   is_invocable_r< char&,  F&,  int >(), \"\");\n+  static_assert(   is_invocable_r< char&,  CF,  int >(), \"\");\n+  static_assert(   is_invocable_r< char&,  CF&, int >(), \"\");\n+\n+  static_assert( ! is_invocable< F, int, int >(), \"\");\n+}"}, {"sha": "d167cfa635acf624d8ed831cff01c5fac5d32877", "filename": "libstdc++-v3/testsuite/20_util/is_invocable/value_ext.cc", "status": "renamed", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dcc645ccd085045f628a25760788221cb83c504/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_invocable%2Fvalue_ext.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dcc645ccd085045f628a25760788221cb83c504/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_invocable%2Fvalue_ext.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_invocable%2Fvalue_ext.cc?ref=7dcc645ccd085045f628a25760788221cb83c504", "patch": "@@ -19,8 +19,22 @@\n \n #include <type_traits>\n \n-template<typename T, typename R = void>\n-  constexpr bool is_callable() { return std::__is_callable<T, R>::value; }\n+template<typename... T>\n+  constexpr bool is_invocable() { return std::__is_invocable<T...>::value; }\n \n-#define IS_CALLABLE_DEFINED\n+template<typename R, typename... T>\n+  constexpr bool is_invocable_conv(std::true_type)\n+  {\n+    using result_type = typename std::__invoke_result<T...>::type;\n+    return std::is_void<R>::value || std::is_convertible<result_type, R>::value;\n+  }\n+\n+template<typename R, typename... T>\n+  constexpr bool is_invocable_conv(std::false_type) { return false; }\n+\n+template<typename R, typename... T>\n+  constexpr bool is_invocable_r()\n+  { return is_invocable_conv<R, T...>(std::__is_invocable<T...>{}); }\n+\n+#define IS_INVOCABLE_DEFINED\n #include \"value.cc\"", "previous_filename": "libstdc++-v3/testsuite/20_util/is_callable/value_ext.cc"}, {"sha": "16b55dad7cc7d0a1eb60ae156926e8742d717074", "filename": "libstdc++-v3/testsuite/20_util/is_nothrow_callable/value.cc", "status": "removed", "additions": 0, "deletions": 92, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a147ef113d5c6c0fd44e2de7149c8fbd1e2a7882/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_callable%2Fvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a147ef113d5c6c0fd44e2de7149c8fbd1e2a7882/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_callable%2Fvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_callable%2Fvalue.cc?ref=a147ef113d5c6c0fd44e2de7149c8fbd1e2a7882", "patch": "@@ -1,92 +0,0 @@\n-// Copyright (C) 2016-2017 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 3, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING3.  If not see\n-// <http://www.gnu.org/licenses/>.\n-\n-// { dg-options \"-std=gnu++17\" }\n-// { dg-do compile }\n-\n-#include <type_traits>\n-\n-#ifndef IS_NT_CALLABLE_DEFINED\n-template<typename T, typename R = void>\n-  constexpr bool is_nt_callable()\n-  {\n-    static_assert(std::is_nothrow_callable<T, R>::value\n-                  == std::is_nothrow_callable_v<T, R>);\n-    return std::is_nothrow_callable_v<T, R>;\n-  }\n-#endif\n-\n-void test01()\n-{\n-  using func_type = void(*)();\n-  static_assert( ! is_nt_callable< func_type() >(),     \"\");\n-\n-#if __cpp_noexcept_function_type\n-  using func_type_nt = void(*)() noexcept;\n-  static_assert(   is_nt_callable< func_type_nt() >(),  \"\");\n-#endif\n-\n-  struct X { };\n-  using mem_type = int X::*;\n-\n-  static_assert( ! is_nt_callable< mem_type() >(),\t\"\");\n-  static_assert( ! is_nt_callable< mem_type(int) >(),   \"\");\n-  static_assert( ! is_nt_callable< mem_type(int&) >(),\t\"\");\n-\n-  static_assert(   is_nt_callable< mem_type(X&) >(),       \"\");\n-  static_assert(   is_nt_callable< mem_type(X&), int  >(), \"\");\n-  static_assert(   is_nt_callable< mem_type(X&), int& >(), \"\");\n-  static_assert(   is_nt_callable< mem_type(X&), long >(), \"\");\n-  static_assert(   is_nt_callable< mem_type(X*), int& >(), \"\");\n-\n-  using memfun_type = int (X::*)();\n-\n-  static_assert( ! is_nt_callable< memfun_type() >(),     \"\");\n-  static_assert( ! is_nt_callable< memfun_type(int) >(),  \"\");\n-  static_assert( ! is_nt_callable< memfun_type(int&) >(), \"\");\n-  static_assert( ! is_nt_callable< memfun_type(X&) >(),   \"\");\n-  static_assert( ! is_nt_callable< memfun_type(X*) >(),   \"\");\n-\n-#if __cpp_noexcept_function_type\n-  using memfun_type_nt = int (X::*)() noexcept;\n-\n-  static_assert( ! is_nt_callable< memfun_type_nt() >(),\t    \"\");\n-  static_assert( ! is_nt_callable< memfun_type_nt(int) >(),  \"\");\n-  static_assert( ! is_nt_callable< memfun_type_nt(int&) >(), \"\");\n-  static_assert(   is_nt_callable< memfun_type_nt(X&) >(),   \"\");\n-  static_assert(   is_nt_callable< memfun_type_nt(X*) >(),   \"\");\n-#endif\n-\n-  struct F {\n-    int& operator()();\n-    long& operator()() const noexcept;\n-    short& operator()(int) &&;\n-    char& operator()(int) const& noexcept;\n-  private:\n-    void operator()(int, int) noexcept;\n-  };\n-  using CF = const F;\n-\n-  static_assert( ! is_nt_callable< F(),   int&   >(), \"\");\n-  static_assert(   is_nt_callable< CF(),  long& >(),  \"\");\n-  static_assert( ! is_nt_callable< F(int),    short& >(), \"\");\n-  static_assert(   is_nt_callable< F&(int),   char& >(),  \"\");\n-  static_assert(   is_nt_callable< CF(int),   char& >(),  \"\");\n-  static_assert(   is_nt_callable< CF&(int),  char& >(),  \"\");\n-\n-  static_assert( ! is_nt_callable< F(int, int) >(), \"\");\n-}"}, {"sha": "0232698dd5dddf5d1ad2938b2bc1dbb6cb6aeb85", "filename": "libstdc++-v3/testsuite/20_util/is_nothrow_invocable/requirements/explicit_instantiation.cc", "status": "renamed", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dcc645ccd085045f628a25760788221cb83c504/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_invocable%2Frequirements%2Fexplicit_instantiation.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dcc645ccd085045f628a25760788221cb83c504/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_invocable%2Frequirements%2Fexplicit_instantiation.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_invocable%2Frequirements%2Fexplicit_instantiation.cc?ref=7dcc645ccd085045f628a25760788221cb83c504", "patch": "@@ -25,5 +25,6 @@\n namespace std\n {\n   struct test_type { };\n-  template struct is_nothrow_callable<test_type(), int>;\n+  template struct is_nothrow_invocable<test_type>;\n+  template struct is_nothrow_invocable_r<int, test_type>;\n }", "previous_filename": "libstdc++-v3/testsuite/20_util/is_nothrow_callable/requirements/explicit_instantiation.cc"}, {"sha": "f9afed692283ee59491933324f8c0887ee795180", "filename": "libstdc++-v3/testsuite/20_util/is_nothrow_invocable/requirements/explicit_instantiation_ext.cc", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dcc645ccd085045f628a25760788221cb83c504/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_invocable%2Frequirements%2Fexplicit_instantiation_ext.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dcc645ccd085045f628a25760788221cb83c504/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_invocable%2Frequirements%2Fexplicit_instantiation_ext.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_invocable%2Frequirements%2Fexplicit_instantiation_ext.cc?ref=7dcc645ccd085045f628a25760788221cb83c504", "patch": "@@ -24,5 +24,5 @@\n namespace std\n {\n   struct test_type { };\n-  template struct __is_nothrow_callable<test_type(), int>;\n+  template struct __is_nothrow_invocable<test_type>;\n }", "previous_filename": "libstdc++-v3/testsuite/20_util/is_nothrow_callable/requirements/explicit_instantiation_ext.cc"}, {"sha": "3b31675307f73772f7cbf1dc2e6944f84b7de74a", "filename": "libstdc++-v3/testsuite/20_util/is_nothrow_invocable/requirements/typedefs.cc", "status": "renamed", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dcc645ccd085045f628a25760788221cb83c504/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_invocable%2Frequirements%2Ftypedefs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dcc645ccd085045f628a25760788221cb83c504/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_invocable%2Frequirements%2Ftypedefs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_invocable%2Frequirements%2Ftypedefs.cc?ref=7dcc645ccd085045f628a25760788221cb83c504", "patch": "@@ -25,6 +25,13 @@\n void test01()\n {\n   // Check for required typedefs\n-  typedef std::is_callable<int(), void>       test_type;\n+  typedef std::is_nothrow_invocable<int>       test_type;\n+  static_assert( std::is_base_of_v<std::false_type, test_type> );\n+}\n+\n+void test02()\n+{\n+  // Check for required typedefs\n+  typedef std::is_nothrow_invocable_r<void, int>       test_type;\n   static_assert( std::is_base_of_v<std::false_type, test_type> );\n }", "previous_filename": "libstdc++-v3/testsuite/20_util/is_callable/requirements/typedefs.cc"}, {"sha": "db2ad61660e303b142b8a2fb613f4c14ddcca50e", "filename": "libstdc++-v3/testsuite/20_util/is_nothrow_invocable/requirements/typedefs_ext.cc", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dcc645ccd085045f628a25760788221cb83c504/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_invocable%2Frequirements%2Ftypedefs_ext.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dcc645ccd085045f628a25760788221cb83c504/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_invocable%2Frequirements%2Ftypedefs_ext.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_invocable%2Frequirements%2Ftypedefs_ext.cc?ref=7dcc645ccd085045f628a25760788221cb83c504", "patch": "@@ -24,6 +24,6 @@\n void test01()\n {\n   // Check for required typedefs\n-  typedef std::__is_nothrow_callable<int(), void>     test_type;\n+  typedef std::__is_nothrow_invocable<int>     test_type;\n   static_assert( std::is_base_of<std::false_type, test_type>::value, \"\" );\n }", "previous_filename": "libstdc++-v3/testsuite/20_util/is_nothrow_callable/requirements/typedefs_ext.cc"}, {"sha": "4ccb459e0f5c22585453ffdd60e48f971c8189ff", "filename": "libstdc++-v3/testsuite/20_util/is_nothrow_invocable/value.cc", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dcc645ccd085045f628a25760788221cb83c504/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_invocable%2Fvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dcc645ccd085045f628a25760788221cb83c504/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_invocable%2Fvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_invocable%2Fvalue.cc?ref=7dcc645ccd085045f628a25760788221cb83c504", "patch": "@@ -0,0 +1,100 @@\n+// Copyright (C) 2016-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do compile }\n+\n+#include <type_traits>\n+\n+#ifndef IS_NT_INVOCABLE_DEFINED\n+template<typename... T>\n+  constexpr bool is_nt_invocable()\n+  {\n+    constexpr bool result = std::is_nothrow_invocable_v<T...>;\n+    static_assert(std::is_nothrow_invocable<T...>::value == result);\n+    return result;\n+  }\n+\n+template<typename R, typename... T>\n+  constexpr bool is_nt_invocable_r()\n+  {\n+    constexpr bool result = std::is_nothrow_invocable_r_v<R, T...>;\n+    static_assert(std::is_nothrow_invocable_r<R, T...>::value == result);\n+    return result;\n+  }\n+#endif\n+\n+void test01()\n+{\n+  using func_type = void(*)();\n+  static_assert( ! is_nt_invocable< func_type>(),     \"\");\n+\n+#if __cpp_noexcept_function_type\n+  using func_type_nt = void(*)() noexcept;\n+  static_assert(   is_nt_invocable< func_type_nt >(),  \"\");\n+#endif\n+\n+  struct X { };\n+  using mem_type = int X::*;\n+\n+  static_assert( ! is_nt_invocable< mem_type >(),\t\"\");\n+  static_assert( ! is_nt_invocable< mem_type, int >(),   \"\");\n+  static_assert( ! is_nt_invocable< mem_type, int& >(),\t\"\");\n+\n+  static_assert(   is_nt_invocable< mem_type, X& >(),       \"\");\n+  static_assert(   is_nt_invocable_r< int,  mem_type, X& >(), \"\");\n+  static_assert(   is_nt_invocable_r< int&, mem_type, X& >(), \"\");\n+  static_assert(   is_nt_invocable_r< long, mem_type, X& >(), \"\");\n+  static_assert(   is_nt_invocable_r< int&, mem_type, X* >(), \"\");\n+\n+  using memfun_type = int (X::*)();\n+\n+  static_assert( ! is_nt_invocable< memfun_type >(),     \"\");\n+  static_assert( ! is_nt_invocable< memfun_type, int >(),  \"\");\n+  static_assert( ! is_nt_invocable< memfun_type, int& >(), \"\");\n+  static_assert( ! is_nt_invocable< memfun_type, X& >(),   \"\");\n+  static_assert( ! is_nt_invocable< memfun_type, X* >(),   \"\");\n+\n+#if __cpp_noexcept_function_type\n+  using memfun_type_nt = int (X::*)() noexcept;\n+\n+  static_assert( ! is_nt_invocable< memfun_type_nt >(),\t    \"\");\n+  static_assert( ! is_nt_invocable< memfun_type_nt, int >(),  \"\");\n+  static_assert( ! is_nt_invocable< memfun_type_nt, int& >(), \"\");\n+  static_assert(   is_nt_invocable< memfun_type_nt, X& >(),   \"\");\n+  static_assert(   is_nt_invocable< memfun_type_nt, X* >(),   \"\");\n+#endif\n+\n+  struct F {\n+    int& operator()();\n+    long& operator()() const noexcept;\n+    short& operator()(int) &&;\n+    char& operator()(int) const& noexcept;\n+  private:\n+    void operator()(int, int) noexcept;\n+  };\n+  using CF = const F;\n+\n+  static_assert( ! is_nt_invocable_r< int&,  F  >(), \"\");\n+  static_assert(   is_nt_invocable_r< long&, CF >(),  \"\");\n+  static_assert( ! is_nt_invocable_r< short&, F,   int >(), \"\" );\n+  static_assert(   is_nt_invocable_r< char&,  F&,  int >(), \"\" );\n+  static_assert(   is_nt_invocable_r< char&,  CF,  int >(), \"\" );\n+  static_assert(   is_nt_invocable_r< char&,  CF&, int >(), \"\" );\n+\n+  static_assert( ! is_nt_invocable< F, int, int >(), \"\");\n+}"}, {"sha": "7217324e1b3d5e86e0ea54e91d8e1094a00bfbd4", "filename": "libstdc++-v3/testsuite/20_util/is_nothrow_invocable/value_ext.cc", "status": "renamed", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dcc645ccd085045f628a25760788221cb83c504/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_invocable%2Fvalue_ext.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dcc645ccd085045f628a25760788221cb83c504/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_invocable%2Fvalue_ext.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_invocable%2Fvalue_ext.cc?ref=7dcc645ccd085045f628a25760788221cb83c504", "patch": "@@ -19,9 +19,25 @@\n \n #include <type_traits>\n \n-template<typename T, typename R = void>\n-  constexpr bool is_nt_callable()\n-  { return std::__is_nothrow_callable<T, R>::value; }\n+template<typename... T>\n+  constexpr bool is_nt_invocable()\n+  { return std::__is_nothrow_invocable<T...>::value; }\n \n-#define IS_NT_CALLABLE_DEFINED\n+  template<typename R, typename... T>\n+  constexpr bool is_nt_invocable_conv(std::true_type)\n+  {\n+    using result_type = typename std::__invoke_result<T...>::type;\n+    return std::is_void<R>::value || std::is_convertible<result_type, R>::value;\n+  }\n+\n+template<typename R, typename... T>\n+  constexpr bool is_nt_invocable_conv(std::false_type) { return false; }\n+\n+template<typename R, typename... T>\n+  constexpr bool is_nt_invocable_r()\n+  {\n+    return is_nt_invocable_conv<R, T...>(std::__is_nothrow_invocable<T...>{});\n+  }\n+\n+#define IS_NT_INVOCABLE_DEFINED\n #include \"value.cc\"", "previous_filename": "libstdc++-v3/testsuite/20_util/is_nothrow_callable/value_ext.cc"}, {"sha": "c16f0b20fb263e1d15ca3fdb3b7ae7a8dd19417f", "filename": "libstdc++-v3/testsuite/20_util/optional/hash.cc", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dcc645ccd085045f628a25760788221cb83c504/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fhash.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dcc645ccd085045f628a25760788221cb83c504/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fhash.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fhash.cc?ref=7dcc645ccd085045f628a25760788221cb83c504", "patch": "@@ -29,12 +29,10 @@ template<class T>\n auto f(...) -> decltype(std::false_type());\n \n static_assert(!decltype(f<S>(0))::value, \"\");\n-static_assert(!std::is_callable<\n-\t      std::hash<std::optional<S>>&\n-\t      (std::optional<S> const&)>::value, \"\");\n-static_assert(std::is_callable<\n-\t      std::hash<std::optional<int>>&\n-\t      (std::optional<int> const&)>::value, \"\");\n+static_assert(!std::is_invocable_v<\n+    std::hash<std::optional<S>>&, std::optional<S> const&> );\n+static_assert(std::is_invocable_v<\n+    std::hash<std::optional<int>>&, std::optional<int> const&> );\n \n int main()\n {"}, {"sha": "d747e104d69f33974bbb869d806261d3bb03a2aa", "filename": "libstdc++-v3/testsuite/20_util/variant/hash.cc", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dcc645ccd085045f628a25760788221cb83c504/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariant%2Fhash.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dcc645ccd085045f628a25760788221cb83c504/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariant%2Fhash.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariant%2Fhash.cc?ref=7dcc645ccd085045f628a25760788221cb83c504", "patch": "@@ -33,17 +33,14 @@ static_assert(!decltype(f<std::variant<S>>(0))::value, \"\");\n static_assert(!decltype(f<std::variant<S, S>>(0))::value, \"\");\n static_assert(decltype(f<std::variant<int>>(0))::value, \"\");\n static_assert(decltype(f<std::variant<int, int>>(0))::value, \"\");\n-static_assert(!std::is_callable<\n-\t      std::hash<std::variant<S>>&(std::variant<S> const&)>::value, \"\");\n-static_assert(!std::is_callable<\n-\t      std::hash<std::variant<S, int>>&\n-\t      (std::variant<S, int> const&)>::value, \"\");\n-static_assert(std::is_callable<\n-\t      std::hash<std::variant<int>>&\n-\t      (std::variant<int> const&)>::value, \"\");\n-static_assert(std::is_callable<\n-\t      std::hash<std::variant<int, int>>&\n-\t      (std::variant<int, int> const&)>::value, \"\");\n+static_assert(!std::is_invocable_v<\n+    std::hash<std::variant<S>>&, std::variant<S> const&> );\n+static_assert(!std::is_invocable_v<\n+    std::hash<std::variant<S, int>>&, std::variant<S, int> const&> );\n+static_assert(std::is_invocable_v<\n+    std::hash<std::variant<int>>&, std::variant<int> const&> );\n+static_assert(std::is_invocable_v<\n+    std::hash<std::variant<int, int>>&, std::variant<int, int> const&> );\n \n int main()\n {"}]}