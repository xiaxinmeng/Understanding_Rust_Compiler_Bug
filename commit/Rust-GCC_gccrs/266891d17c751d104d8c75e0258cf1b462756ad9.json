{"sha": "266891d17c751d104d8c75e0258cf1b462756ad9", "node_id": "C_kwDOANBUbNoAKDI2Njg5MWQxN2M3NTFkMTA0ZDhjNzVlMDI1OGNmMWI0NjI3NTZhZDk", "commit": {"author": {"name": "Faisal Abbas", "email": "90.abbasfaisal@gmail.com", "date": "2022-07-30T17:24:42Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-08-25T11:40:26Z"}, "message": "rust-constexpr.cc: port VIEW_CONVERT_EXPR and CONVERT_EXPR cases to\neval_constant_expression(). Throws away code under UNARY_PLUS_EXPR\nand PTRMEM_CST as those tree codes come from cp-tree.def.", "tree": {"sha": "15b7600afa59e77cca4105cf859d066f961e3e30", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/15b7600afa59e77cca4105cf859d066f961e3e30"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/266891d17c751d104d8c75e0258cf1b462756ad9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/266891d17c751d104d8c75e0258cf1b462756ad9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/266891d17c751d104d8c75e0258cf1b462756ad9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/266891d17c751d104d8c75e0258cf1b462756ad9/comments", "author": {"login": "abbasfaisal", "id": 9428333, "node_id": "MDQ6VXNlcjk0MjgzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/9428333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/abbasfaisal", "html_url": "https://github.com/abbasfaisal", "followers_url": "https://api.github.com/users/abbasfaisal/followers", "following_url": "https://api.github.com/users/abbasfaisal/following{/other_user}", "gists_url": "https://api.github.com/users/abbasfaisal/gists{/gist_id}", "starred_url": "https://api.github.com/users/abbasfaisal/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/abbasfaisal/subscriptions", "organizations_url": "https://api.github.com/users/abbasfaisal/orgs", "repos_url": "https://api.github.com/users/abbasfaisal/repos", "events_url": "https://api.github.com/users/abbasfaisal/events{/privacy}", "received_events_url": "https://api.github.com/users/abbasfaisal/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fdbe92d898f11a4d395b5ee9a547707675edf442", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdbe92d898f11a4d395b5ee9a547707675edf442", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fdbe92d898f11a4d395b5ee9a547707675edf442"}], "stats": {"total": 204, "additions": 204, "deletions": 0}, "files": [{"sha": "ebd6ddec89db04b759c09167cbf2cbbc7cefb5c4", "filename": "gcc/rust/backend/rust-constexpr.cc", "status": "modified", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/266891d17c751d104d8c75e0258cf1b462756ad9/gcc%2Frust%2Fbackend%2Frust-constexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/266891d17c751d104d8c75e0258cf1b462756ad9/gcc%2Frust%2Fbackend%2Frust-constexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-constexpr.cc?ref=266891d17c751d104d8c75e0258cf1b462756ad9", "patch": "@@ -574,6 +574,18 @@ fold_expr (tree expr)\n   return folded;\n }\n \n+static bool\n+same_type_ignoring_tlq_and_bounds_p (tree type1, tree type2)\n+{\n+  while (TREE_CODE (type1) == ARRAY_TYPE && TREE_CODE (type2) == ARRAY_TYPE\n+\t && (!TYPE_DOMAIN (type1) || !TYPE_DOMAIN (type2)))\n+    {\n+      type1 = TREE_TYPE (type1);\n+      type2 = TREE_TYPE (type2);\n+    }\n+  return same_type_ignoring_top_level_qualifiers_p (type1, type2);\n+}\n+\n static tree\n eval_constant_expression (const constexpr_ctx *ctx, tree t, bool lval,\n \t\t\t  bool *non_constant_p, bool *overflow_p,\n@@ -848,6 +860,135 @@ eval_constant_expression (const constexpr_ctx *ctx, tree t, bool lval,\n \t\t\t\t       jump_target);\n       break;\n \n+      /* FALLTHROUGH.  */\n+    case CONVERT_EXPR:\n+      case VIEW_CONVERT_EXPR: {\n+\ttree oldop = TREE_OPERAND (t, 0);\n+\n+\ttree op = eval_constant_expression (ctx, oldop, lval, non_constant_p,\n+\t\t\t\t\t    overflow_p);\n+\tif (*non_constant_p)\n+\t  return t;\n+\ttree type = TREE_TYPE (t);\n+\n+\tif (VOID_TYPE_P (type))\n+\t  return void_node;\n+\n+\tif (TREE_CODE (t) == CONVERT_EXPR && ARITHMETIC_TYPE_P (type)\n+\t    && INDIRECT_TYPE_P (TREE_TYPE (op)) && ctx->manifestly_const_eval)\n+\t  {\n+\t    if (!ctx->quiet)\n+\t      error_at (loc,\n+\t\t\t\"conversion from pointer type %qT to arithmetic type \"\n+\t\t\t\"%qT in a constant expression\",\n+\t\t\tTREE_TYPE (op), type);\n+\t    *non_constant_p = true;\n+\t    return t;\n+\t  }\n+\n+\tif (TYPE_PTROB_P (type) && TYPE_PTR_P (TREE_TYPE (op))\n+\t    && VOID_TYPE_P (TREE_TYPE (TREE_TYPE (op))))\n+\t  {\n+\t    /* Likewise, don't error when casting from void* when OP is\n+\t       &heap uninit and similar.  */\n+\t    tree sop = tree_strip_nop_conversions (op);\n+\t    if (TREE_CODE (sop) == ADDR_EXPR && VAR_P (TREE_OPERAND (sop, 0))\n+\t\t&& DECL_ARTIFICIAL (TREE_OPERAND (sop, 0)))\n+\t      /* OK */;\n+\t    else\n+\t      {\n+\t\tif (!ctx->quiet)\n+\t\t  error_at (loc, \"cast from %qT is not allowed\",\n+\t\t\t    TREE_TYPE (op));\n+\t\t*non_constant_p = true;\n+\t\treturn t;\n+\t      }\n+\t  }\n+\n+\tif (INDIRECT_TYPE_P (type) && TREE_CODE (op) == INTEGER_CST)\n+\t  {\n+\t    if (integer_zerop (op))\n+\t      {\n+\t\tif (TYPE_REF_P (type))\n+\t\t  {\n+\t\t    if (!ctx->quiet)\n+\t\t      error_at (loc, \"dereferencing a null pointer\");\n+\t\t    *non_constant_p = true;\n+\t\t    return t;\n+\t\t  }\n+\t      }\n+\t    else\n+\t      {\n+\t\t/* This detects for example:\n+\t\t     reinterpret_cast<void*>(sizeof 0)\n+\t\t*/\n+\t\tif (!ctx->quiet)\n+\t\t  error_at (loc,\n+\t\t\t    \"%<reinterpret_cast<%T>(%E)%> is not \"\n+\t\t\t    \"a constant expression\",\n+\t\t\t    type, op);\n+\t\t*non_constant_p = true;\n+\t\treturn t;\n+\t      }\n+\t  }\n+\n+\tif (INDIRECT_TYPE_P (type) && TREE_CODE (op) == NOP_EXPR\n+\t    && TREE_TYPE (op) == ptr_type_node\n+\t    && TREE_CODE (TREE_OPERAND (op, 0)) == ADDR_EXPR\n+\t    && VAR_P (TREE_OPERAND (TREE_OPERAND (op, 0), 0))\n+\t    && (DECL_NAME (TREE_OPERAND (TREE_OPERAND (op, 0), 0))\n+\t\t  == heap_uninit_identifier\n+\t\t|| DECL_NAME (TREE_OPERAND (TREE_OPERAND (op, 0), 0))\n+\t\t     == heap_vec_uninit_identifier))\n+\t  {\n+\t    tree var = TREE_OPERAND (TREE_OPERAND (op, 0), 0);\n+\t    tree var_size = TYPE_SIZE_UNIT (TREE_TYPE (var));\n+\t    tree elt_type = TREE_TYPE (type);\n+\t    tree cookie_size = NULL_TREE;\n+\t    if (TREE_CODE (elt_type) == RECORD_TYPE\n+\t\t&& TYPE_NAME (elt_type) == heap_identifier)\n+\t      {\n+\t\ttree fld1 = TYPE_FIELDS (elt_type);\n+\t\ttree fld2 = DECL_CHAIN (fld1);\n+\t\telt_type = TREE_TYPE (TREE_TYPE (fld2));\n+\t\tcookie_size = TYPE_SIZE_UNIT (TREE_TYPE (fld1));\n+\t      }\n+\t    DECL_NAME (var) = (DECL_NAME (var) == heap_uninit_identifier\n+\t\t\t\t ? heap_identifier\n+\t\t\t\t : heap_vec_identifier);\n+\t    TREE_TYPE (var)\n+\t      = build_new_constexpr_heap_type (elt_type, cookie_size, var_size);\n+\t    TREE_TYPE (TREE_OPERAND (op, 0))\n+\t      = build_pointer_type (TREE_TYPE (var));\n+\t  }\n+\n+\tif (op == oldop)\n+\t  /* We didn't fold at the top so we could check for ptr-int\n+\t     conversion.  */\n+\t  return fold (t);\n+\n+\ttree sop;\n+\n+\t/* Handle an array's bounds having been deduced after we built\n+\t   the wrapping expression.  */\n+\tif (same_type_ignoring_tlq_and_bounds_p (type, TREE_TYPE (op)))\n+\t  r = op;\n+\telse if (sop = tree_strip_nop_conversions (op),\n+\t\t sop != op\n+\t\t   && (same_type_ignoring_tlq_and_bounds_p (type,\n+\t\t\t\t\t\t\t    TREE_TYPE (sop))))\n+\t  r = sop;\n+\telse\n+\t  r = fold_build1 (tcode, type, op);\n+\n+\t/* Conversion of an out-of-range value has implementation-defined\n+\t   behavior; the language considers it different from arithmetic\n+\t   overflow, which is undefined.  */\n+\tif (TREE_OVERFLOW_P (r) && !TREE_OVERFLOW_P (op))\n+\t  TREE_OVERFLOW (r) = false;\n+      }\n+      break;\n+\n     default:\n       break;\n     }"}, {"sha": "82b58459d6fa94597dc1af34259e716898b1109b", "filename": "gcc/rust/backend/rust-tree.cc", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/266891d17c751d104d8c75e0258cf1b462756ad9/gcc%2Frust%2Fbackend%2Frust-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/266891d17c751d104d8c75e0258cf1b462756ad9/gcc%2Frust%2Fbackend%2Frust-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-tree.cc?ref=266891d17c751d104d8c75e0258cf1b462756ad9", "patch": "@@ -4033,4 +4033,50 @@ location_of (tree t)\n   return EXPR_LOCATION (t);\n }\n \n+/* For element type ELT_TYPE, return the appropriate type of the heap object\n+   containing such element(s).  COOKIE_SIZE is NULL or the size of cookie\n+   in bytes.  FULL_SIZE is NULL if it is unknown how big the heap allocation\n+   will be, otherwise size of the heap object.  If COOKIE_SIZE is NULL,\n+   return array type ELT_TYPE[FULL_SIZE / sizeof(ELT_TYPE)], otherwise return\n+   struct { size_t[COOKIE_SIZE/sizeof(size_t)]; ELT_TYPE[N]; }\n+   where N is nothing (flexible array member) if FULL_SIZE is NULL, otherwise\n+   it is computed such that the size of the struct fits into FULL_SIZE.  */\n+\n+tree\n+build_new_constexpr_heap_type (tree elt_type, tree cookie_size, tree full_size)\n+{\n+  gcc_assert (cookie_size == NULL_TREE || tree_fits_uhwi_p (cookie_size));\n+  gcc_assert (full_size == NULL_TREE || tree_fits_uhwi_p (full_size));\n+  unsigned HOST_WIDE_INT csz = cookie_size ? tree_to_uhwi (cookie_size) : 0;\n+  tree itype2 = NULL_TREE;\n+  if (full_size)\n+    {\n+      unsigned HOST_WIDE_INT fsz = tree_to_uhwi (full_size);\n+      gcc_assert (fsz >= csz);\n+      fsz -= csz;\n+      fsz /= int_size_in_bytes (elt_type);\n+      itype2 = build_index_type (size_int (fsz - 1));\n+      if (!cookie_size)\n+\treturn build_cplus_array_type (elt_type, itype2);\n+    }\n+  else\n+    gcc_assert (cookie_size);\n+  csz /= int_size_in_bytes (sizetype);\n+  tree itype1 = build_index_type (size_int (csz - 1));\n+  tree atype1 = build_cplus_array_type (sizetype, itype1);\n+  tree atype2 = build_cplus_array_type (elt_type, itype2);\n+  tree rtype = cxx_make_type (RECORD_TYPE);\n+  TYPE_NAME (rtype) = heap_identifier;\n+  tree fld1 = build_decl (UNKNOWN_LOCATION, FIELD_DECL, NULL_TREE, atype1);\n+  tree fld2 = build_decl (UNKNOWN_LOCATION, FIELD_DECL, NULL_TREE, atype2);\n+  DECL_FIELD_CONTEXT (fld1) = rtype;\n+  DECL_FIELD_CONTEXT (fld2) = rtype;\n+  DECL_ARTIFICIAL (fld1) = true;\n+  DECL_ARTIFICIAL (fld2) = true;\n+  TYPE_FIELDS (rtype) = fld1;\n+  DECL_CHAIN (fld1) = fld2;\n+  layout_type (rtype);\n+  return rtype;\n+}\n+\n } // namespace Rust"}, {"sha": "d4b7d8671fe2c209ce94eb54329ea54ea8cb3d55", "filename": "gcc/rust/backend/rust-tree.h", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/266891d17c751d104d8c75e0258cf1b462756ad9/gcc%2Frust%2Fbackend%2Frust-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/266891d17c751d104d8c75e0258cf1b462756ad9/gcc%2Frust%2Fbackend%2Frust-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-tree.h?ref=266891d17c751d104d8c75e0258cf1b462756ad9", "patch": "@@ -1248,6 +1248,21 @@ extern GTY (()) tree cp_global_trees[CPTI_MAX];\n    are not constexprs.  Other NOP_EXPRs are.  */\n #define REINTERPRET_CAST_P(NODE) TREE_LANG_FLAG_0 (NOP_EXPR_CHECK (NODE))\n \n+/* Returns true if NODE is an object type:\n+\n+     [basic.types]\n+\n+     An object type is a (possibly cv-qualified) type that is not a\n+     function type, not a reference type, and not a void type.\n+\n+   Keep these checks in ascending order, for speed.  */\n+#define TYPE_OBJ_P(NODE)                                                       \\\n+  (!TYPE_REF_P (NODE) && !VOID_TYPE_P (NODE) && !FUNC_OR_METHOD_TYPE_P (NODE))\n+\n+/* Returns true if NODE is a pointer to an object.  Keep these checks\n+   in ascending tree code order.  */\n+#define TYPE_PTROB_P(NODE) (TYPE_PTR_P (NODE) && TYPE_OBJ_P (TREE_TYPE (NODE)))\n+\n #if defined ENABLE_TREE_CHECKING\n \n #define LANG_DECL_MIN_CHECK(NODE)                                              \\\n@@ -2582,6 +2597,8 @@ extern bool require_deduced_type (tree, tsubst_flags_t = tf_warning_or_error);\n \n extern bool decl_constant_var_p (tree);\n \n+extern tree build_new_constexpr_heap_type (tree, tree, tree);\n+\n // forked from gcc/cp/cp-tree.h\n \n enum"}]}