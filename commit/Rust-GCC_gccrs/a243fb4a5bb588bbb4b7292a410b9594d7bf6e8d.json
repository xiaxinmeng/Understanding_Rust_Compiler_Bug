{"sha": "a243fb4a5bb588bbb4b7292a410b9594d7bf6e8d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTI0M2ZiNGE1YmI1ODhiYmI0YjcyOTJhNDEwYjk1OTRkN2JmNmU4ZA==", "commit": {"author": {"name": "Manuel L\u00f3pez-Ib\u00e1\u00f1ez", "email": "manu@gcc.gnu.org", "date": "2009-05-15T20:08:21Z"}, "committer": {"name": "Manuel L\u00f3pez-Ib\u00e1\u00f1ez", "email": "manu@gcc.gnu.org", "date": "2009-05-15T20:08:21Z"}, "message": "re PR c/16302 (gcc fails to warn about some common logic errors)\n\n2009-05-15  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n\n\tPR 16302\n\t* fold-const.c (make_range,build_range_check,merge_ranges): Move\n\tdeclaration to...\n\t(merge_ranges): Returns bool. \n\t* tree.h (make_range): .. to here.\n\t(build_range_check): Likewise.\n\t(merge_ranges): Likewise. Renamed from merge_ranges.\n\t* c-typeck.c (parser_build_binary_op): Update calls to\n\twarn_logical_operator.\n\t* c-common.c (warn_logical_operator): Add new warning.\n\t* c-common.h (warn_logical_operator): Update declaration.\ncp/\n\t* call.c (build_new_op): Update calls to warn_logical_operator.\n\t\ntestsuite/\n\t* gcc.dg/pr16302.c: New.\n\t* g++.dg/warn/pr16302.C: New.\n\nFrom-SVN: r147596", "tree": {"sha": "6ee4203c725a3a87b87a38848ee077c8ed6e23a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6ee4203c725a3a87b87a38848ee077c8ed6e23a3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a243fb4a5bb588bbb4b7292a410b9594d7bf6e8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a243fb4a5bb588bbb4b7292a410b9594d7bf6e8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a243fb4a5bb588bbb4b7292a410b9594d7bf6e8d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a243fb4a5bb588bbb4b7292a410b9594d7bf6e8d/comments", "author": null, "committer": null, "parents": [{"sha": "1b53c5f35fc8175a6dc1462c4b920c58377b13f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b53c5f35fc8175a6dc1462c4b920c58377b13f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b53c5f35fc8175a6dc1462c4b920c58377b13f1"}], "stats": {"total": 269, "additions": 253, "deletions": 16}, "files": [{"sha": "f1070865ca3945b3818dc63cbdd694c39421534f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a243fb4a5bb588bbb4b7292a410b9594d7bf6e8d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a243fb4a5bb588bbb4b7292a410b9594d7bf6e8d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a243fb4a5bb588bbb4b7292a410b9594d7bf6e8d", "patch": "@@ -1,3 +1,17 @@\n+2009-05-15  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n+\n+\tPR 16302\n+\t* fold-const.c (make_range,build_range_check,merge_ranges): Move\n+\tdeclaration to...\n+\t(merge_ranges): Returns bool. \n+\t* tree.h (make_range): .. to here.\n+\t(build_range_check): Likewise.\n+\t(merge_ranges): Likewise. Renamed from merge_ranges.\n+\t* c-typeck.c (parser_build_binary_op): Update calls to\n+\twarn_logical_operator.\n+\t* c-common.c (warn_logical_operator): Add new warning.\n+\t* c-common.h (warn_logical_operator): Update declaration.\n+\t\n 2009-05-15  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n \n \t* ira-conflicts.c (add_insn_allocno_copies): Fix wrong"}, {"sha": "e5c3d0d2eeef380248b177854f58bd426ccefec1", "filename": "gcc/c-common.c", "status": "modified", "additions": 61, "deletions": 5, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a243fb4a5bb588bbb4b7292a410b9594d7bf6e8d/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a243fb4a5bb588bbb4b7292a410b9594d7bf6e8d/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=a243fb4a5bb588bbb4b7292a410b9594d7bf6e8d", "patch": "@@ -1716,14 +1716,18 @@ overflow_warning (tree value)\n /* Warn about uses of logical || / && operator in a context where it\n    is likely that the bitwise equivalent was intended by the\n    programmer.  We have seen an expression in which CODE is a binary\n-   operator used to combine expressions OP_LEFT and OP_RIGHT, which\n-   before folding had CODE_LEFT and CODE_RIGHT.  */\n-\n+   operator used to combine expressions OP_LEFT and OP_RIGHT, which before folding\n+   had CODE_LEFT and CODE_RIGHT, into an expression of type TYPE.  */\n void\n-warn_logical_operator (location_t location, enum tree_code code,\n+warn_logical_operator (location_t location, enum tree_code code, tree type,\n \t\t       enum tree_code code_left, tree op_left, \n \t\t       enum tree_code ARG_UNUSED (code_right), tree op_right)\n {\n+  int or_op = (code == TRUTH_ORIF_EXPR || code == TRUTH_OR_EXPR);\n+  int in0_p, in1_p, in_p;\n+  tree low0, low1, low, high0, high1, high, lhs, rhs, tem;\n+  bool strict_overflow_p = false;\n+\n   if (code != TRUTH_ANDIF_EXPR\n       && code != TRUTH_AND_EXPR\n       && code != TRUTH_ORIF_EXPR\n@@ -1743,13 +1747,65 @@ warn_logical_operator (location_t location, enum tree_code code,\n       && !integer_zerop (op_right)\n       && !integer_onep (op_right))\n     {\n-      if (code == TRUTH_ORIF_EXPR || code == TRUTH_OR_EXPR)\n+      if (or_op)\n \twarning_at (location, OPT_Wlogical_op, \"logical %<or%>\"\n \t\t    \" applied to non-boolean constant\");\n       else\n \twarning_at (location, OPT_Wlogical_op, \"logical %<and%>\"\n \t\t    \" applied to non-boolean constant\");\n       TREE_NO_WARNING (op_left) = true;\n+      return;\n+    }\n+\n+  /* We do not warn for constants because they are typical of macro\n+     expansions that test for features.  */\n+  if (CONSTANT_CLASS_P (op_left) || CONSTANT_CLASS_P (op_right))\n+    return;\n+\n+  /* This warning only makes sense with logical operands.  */\n+  if (!(truth_value_p (TREE_CODE (op_left))\n+\t|| INTEGRAL_TYPE_P (TREE_TYPE (op_left)))\n+      || !(truth_value_p (TREE_CODE (op_right))\n+\t   || INTEGRAL_TYPE_P (TREE_TYPE (op_right))))\n+    return;\n+\n+  lhs = make_range (op_left, &in0_p, &low0, &high0, &strict_overflow_p);\n+  rhs = make_range (op_right, &in1_p, &low1, &high1, &strict_overflow_p);\n+\n+  if (lhs && TREE_CODE (lhs) == C_MAYBE_CONST_EXPR)\n+    lhs = C_MAYBE_CONST_EXPR_EXPR (lhs);\n+\n+  if (rhs && TREE_CODE (rhs) == C_MAYBE_CONST_EXPR)\n+    rhs = C_MAYBE_CONST_EXPR_EXPR (rhs);\n+  \n+  /* If this is an OR operation, invert both sides; we will invert\n+     again at the end.  */\n+  if (or_op)\n+    in0_p = !in0_p, in1_p = !in1_p;\n+  \n+  /* If both expressions are the same, if we can merge the ranges, and we\n+     can build the range test, return it or it inverted.  If one of the\n+     ranges is always true or always false, consider it to be the same\n+     expression as the other.  */\n+  if ((lhs == 0 || rhs == 0 || operand_equal_p (lhs, rhs, 0))\n+      && merge_ranges (&in_p, &low, &high, in0_p, low0, high0,\n+\t\t       in1_p, low1, high1)\n+      && 0 != (tem = build_range_check (type,\n+\t\t\t\t\tlhs != 0 ? lhs\n+\t\t\t\t\t: rhs != 0 ? rhs : integer_zero_node,\n+\t\t\t\t\tin_p, low, high)))\n+    {\n+      if (TREE_CODE (tem) != INTEGER_CST)\n+\treturn;\n+\n+      if (or_op)\n+        warning_at (location, OPT_Wlogical_op,\n+                    \"logical %<or%> \"\n+                    \"of collectively exhaustive tests is always true\");\n+      else\n+        warning_at (location, OPT_Wlogical_op,\n+                    \"logical %<and%> \"\n+                    \"of mutually exclusive tests is always false\");\n     }\n }\n "}, {"sha": "c4fba4d9b0f74a969454547664930f3f1fc569b1", "filename": "gcc/c-common.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a243fb4a5bb588bbb4b7292a410b9594d7bf6e8d/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a243fb4a5bb588bbb4b7292a410b9594d7bf6e8d/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=a243fb4a5bb588bbb4b7292a410b9594d7bf6e8d", "patch": "@@ -804,7 +804,7 @@ extern bool strict_aliasing_warning (tree, tree, tree);\n extern void warnings_for_convert_and_check (tree, tree, tree);\n extern tree convert_and_check (tree, tree);\n extern void overflow_warning (tree);\n-extern void warn_logical_operator (location_t, enum tree_code,\n+extern void warn_logical_operator (location_t, enum tree_code, tree,\n \t\t\t\t   enum tree_code, tree, enum tree_code, tree);\n extern void check_main_parameter_types (tree decl);\n extern bool c_determine_visibility (tree);"}, {"sha": "62b5ee913afd563212181eefbe561fe7b9bd9462", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a243fb4a5bb588bbb4b7292a410b9594d7bf6e8d/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a243fb4a5bb588bbb4b7292a410b9594d7bf6e8d/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=a243fb4a5bb588bbb4b7292a410b9594d7bf6e8d", "patch": "@@ -2961,7 +2961,7 @@ parser_build_binary_op (location_t location, enum tree_code code,\n     warn_about_parentheses (code, code1, arg1.value, code2, arg2.value);\n \n   if (warn_logical_op)\n-    warn_logical_operator (input_location, code,\n+    warn_logical_operator (input_location, code, TREE_TYPE (result.value),\n \t\t\t   code1, arg1.value, code2, arg2.value);\n \n   /* Warn about comparisons against string literals, with the exception"}, {"sha": "b4d782610a1bf632d678e46a7a97b4d2f730d6ee", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a243fb4a5bb588bbb4b7292a410b9594d7bf6e8d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a243fb4a5bb588bbb4b7292a410b9594d7bf6e8d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a243fb4a5bb588bbb4b7292a410b9594d7bf6e8d", "patch": "@@ -1,3 +1,8 @@\n+2009-05-15  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n+\n+\tPR 16302\n+\t* call.c (build_new_op): Update calls to warn_logical_operator.\n+\n 2009-05-14  Ian Lance Taylor  <iant@google.com>\n \n \t* class.c (layout_class_type): Change itk to unsigned int."}, {"sha": "607e3edc4f5acab9c1b9dcf38def5b5047452207", "filename": "gcc/cp/call.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a243fb4a5bb588bbb4b7292a410b9594d7bf6e8d/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a243fb4a5bb588bbb4b7292a410b9594d7bf6e8d/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=a243fb4a5bb588bbb4b7292a410b9594d7bf6e8d", "patch": "@@ -4161,7 +4161,7 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n \t      /* We need to call warn_logical_operator before\n \t\t converting arg2 to a boolean_type.  */\n \t      if (complain & tf_warning)\n-\t\twarn_logical_operator (input_location, code,\n+\t\twarn_logical_operator (input_location, code, boolean_type_node,\n \t\t\t\t       code_orig_arg1, arg1,\n \t\t\t\t       code_orig_arg2, arg2);\n \n@@ -4202,7 +4202,7 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n     case TRUTH_ORIF_EXPR:\n     case TRUTH_AND_EXPR:\n     case TRUTH_OR_EXPR:\n-      warn_logical_operator (input_location, code,\n+      warn_logical_operator (input_location, code, boolean_type_node,\n \t\t\t     code_orig_arg1, arg1, code_orig_arg2, arg2);\n       /* Fall through.  */\n     case PLUS_EXPR:"}, {"sha": "4b8fe3894af5d7a81dd480e8f1dfeb3a2abc8556", "filename": "gcc/fold-const.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a243fb4a5bb588bbb4b7292a410b9594d7bf6e8d/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a243fb4a5bb588bbb4b7292a410b9594d7bf6e8d/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=a243fb4a5bb588bbb4b7292a410b9594d7bf6e8d", "patch": "@@ -119,10 +119,10 @@ static int simple_operand_p (const_tree);\n static tree range_binop (enum tree_code, tree, tree, int, tree, int);\n static tree range_predecessor (tree);\n static tree range_successor (tree);\n-static tree make_range (tree, int *, tree *, tree *, bool *);\n-static tree build_range_check (tree, tree, int, tree, tree);\n-static int merge_ranges (int *, tree *, tree *, int, tree, tree, int, tree,\n-\t\t\t tree);\n+extern tree make_range (tree, int *, tree *, tree *, bool *);\n+extern tree build_range_check (tree, tree, int, tree, tree);\n+extern bool merge_ranges (int *, tree *, tree *, int, tree, tree, int,\n+\t\t\t  tree, tree);\n static tree fold_range_test (enum tree_code, tree, tree, tree);\n static tree fold_cond_expr_with_comparison (tree, tree, tree, tree);\n static tree unextend (tree, int, int, tree);\n@@ -4414,7 +4414,7 @@ range_binop (enum tree_code code, tree type, tree arg0, int upper0_p,\n    because signed overflow is undefined; otherwise, do not change\n    *STRICT_OVERFLOW_P.  */\n \n-static tree\n+tree\n make_range (tree exp, int *pin_p, tree *plow, tree *phigh,\n \t    bool *strict_overflow_p)\n {\n@@ -4706,7 +4706,7 @@ make_range (tree exp, int *pin_p, tree *plow, tree *phigh,\n    type, TYPE, return an expression to test if EXP is in (or out of, depending\n    on IN_P) the range.  Return 0 if the test couldn't be created.  */\n \n-static tree\n+tree\n build_range_check (tree type, tree exp, int in_p, tree low, tree high)\n {\n   tree etype = TREE_TYPE (exp), value;\n@@ -4877,7 +4877,7 @@ range_successor (tree val)\n /* Given two ranges, see if we can merge them into one.  Return 1 if we\n    can, 0 if we can't.  Set the output range into the specified parameters.  */\n \n-static int\n+bool\n merge_ranges (int *pin_p, tree *plow, tree *phigh, int in0_p, tree low0,\n \t      tree high0, int in1_p, tree low1, tree high1)\n {"}, {"sha": "3a8f4ab3cb43a0d67ec4955cdd35002d197307b9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a243fb4a5bb588bbb4b7292a410b9594d7bf6e8d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a243fb4a5bb588bbb4b7292a410b9594d7bf6e8d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a243fb4a5bb588bbb4b7292a410b9594d7bf6e8d", "patch": "@@ -1,3 +1,9 @@\n+2009-05-15  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n+\n+\tPR 16302\n+\t* gcc.dg/pr16302.c: New.\n+\t* g++.dg/warn/pr16302.C: New.\n+\n 2009-05-15  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* gcc.dg/torture/builtin-math-5.c: New."}, {"sha": "a6f1a457407d7b80376db269fb97201dd8e18265", "filename": "gcc/testsuite/g++.dg/warn/pr16302.C", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a243fb4a5bb588bbb4b7292a410b9594d7bf6e8d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fpr16302.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a243fb4a5bb588bbb4b7292a410b9594d7bf6e8d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fpr16302.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fpr16302.C?ref=a243fb4a5bb588bbb4b7292a410b9594d7bf6e8d", "patch": "@@ -0,0 +1,76 @@\n+// PR 16302\n+/* { dg-do compile } */\n+/* { dg-options \"-Wlogical-op\" } */\n+void bar (int);\n+int\n+foo (int argc, char *argv[])\n+{\n+  if (argc != 1 || argc != 2) return 1; /* { dg-warning \"'or' of collectively exhaustive tests is always true\" } */\n+  if (argc < 0 && argc > 10) return 1; /* { dg-warning \"'and' of mutually exclusive tests is always false\" } */\n+  if (argc || !argc) return 1; /* { dg-warning \"'or' of collectively exhaustive tests is always true\" } */\n+  if (argc && !argc) return 1; /* { dg-warning \"'and' of mutually exclusive tests is always false\" } */\n+  bar (argc != 1 || argc != 2); /* { dg-warning \"'or' of collectively exhaustive tests is always true\" } */\n+  bar (argc < 0 && argc > 10); /* { dg-warning \"'and' of mutually exclusive tests is always false\" } */\n+  bar (argc || !argc); /* { dg-warning \"'or' of collectively exhaustive tests is always true\" } */\n+  bar (argc && !argc); /* { dg-warning \"'and' of mutually exclusive tests is always false\" } */\n+  return (argc != 1 || argc != 2) ? 1 : 0 ; /* { dg-warning \"'or' of collectively exhaustive tests is always true\" } */\n+  return (argc < 0 && argc > 10) ? 1 : 0; /* { dg-warning \"'and' of mutually exclusive tests is always false\" } */\n+  return (argc || !argc) ? 1 : 0; /* { dg-warning \"'or' of collectively exhaustive tests is always true\" } */\n+  return (argc && !argc) ? 1 : 0; /* { dg-warning \"'and' of mutually exclusive tests is always false\" } */\n+\n+  if (argc == 2 && argc == 1) return 1; /* { dg-warning \"'and' of mutually exclusive tests is always false\" } */\n+  if (argc < 0 && argc > 10) return 1; /* { dg-warning \"'and' of mutually exclusive tests is always false\" } */\n+  if (argc || !argc) return 1; /* { dg-warning \"'or' of collectively exhaustive tests is always true\" } */\n+  if (argc && !argc) return 1; /* { dg-warning \"'and' of mutually exclusive tests is always false\" } */\n+  bar (argc == 2 && argc == 1); /* { dg-warning \"'and' of mutually exclusive tests is always false\" } */\n+  bar (argc < 0 && argc > 10); /* { dg-warning \"'and' of mutually exclusive tests is always false\" } */\n+  bar (argc || !argc); /* { dg-warning \"'or' of collectively exhaustive tests is always true\" } */\n+  bar (argc && !argc); /* { dg-warning \"'and' of mutually exclusive tests is always false\" } */\n+  return (argc == 2 && argc == 1) ? 1 : 0 ; /* { dg-warning \"'and' of mutually exclusive tests is always false\" } */\n+  return (argc < 0 && argc > 10) ? 1 : 0; /* { dg-warning \"'and' of mutually exclusive tests is always false\" } */\n+  return (argc || !argc) ? 1 : 0; /* { dg-warning \"'or' of collectively exhaustive tests is always true\" } */\n+  return (argc && !argc) ? 1 : 0; /* { dg-warning \"'and' of mutually exclusive tests is always false\" } */\n+\n+  if (argc == 2 && argc == 1) return 1; /* { dg-warning \"'and' of mutually exclusive tests is always false\" } */\n+  if (argc < 0 && argc > 10) return 1; /* { dg-warning \"'and' of mutually exclusive tests is always false\" } */\n+  if (!argc || argc) return 1; /* { dg-warning \"'or' of collectively exhaustive tests is always true\" } */\n+  if (!argc && argc) return 1; /* { dg-warning \"'and' of mutually exclusive tests is always false\" } */\n+  bar (argc == 2 && argc == 1); /* { dg-warning \"'and' of mutually exclusive tests is always false\" } */\n+  bar (argc < 0 && argc > 10); /* { dg-warning \"'and' of mutually exclusive tests is always false\" } */\n+  bar (!argc || argc); /* { dg-warning \"'or' of collectively exhaustive tests is always true\" } */\n+  bar (!argc && argc); /* { dg-warning \"'and' of mutually exclusive tests is always false\" } */\n+  return (argc == 2 && argc == 1) ? 1 : 0 ; /* { dg-warning \"'and' of mutually exclusive tests is always false\" } */\n+  return (argc < 0 && argc > 10) ? 1 : 0; /* { dg-warning \"'and' of mutually exclusive tests is always false\" } */\n+  return (!argc || argc) ? 1 : 0; /* { dg-warning \"'or' of collectively exhaustive tests is always true\" } */\n+  return (!argc && argc) ? 1 : 0; /* { dg-warning \"'and' of mutually exclusive tests is always false\" } */\n+\n+  return 0;\n+}\n+\n+int\n+foo2 (int argc)\n+{\n+  if (5 != 1 || 5 != 2) return 1;\n+  if (5 < 0 && 5 > 10) return 1;\n+  if (1 || 0) return 1;\n+  if (0 && 1) return 1;\n+  if (2 || !2) return 1;\n+  if (2 && !2) return 1;\n+  if (!(!2) || !(2)) return 1;\n+  if (!(!2) && !(2)) return 1;\n+  bar (5 != 1 || 5 != 2);\n+  bar (5 < 0 && 5 > 10);\n+  bar (1 || 0);\n+  bar (0 && 1);\n+  bar (2 || !2);\n+  bar (2 && !2);\n+  return (5 != 1 || 5 != 2) ? 1 : 0 ;\n+  return (5 < 0 && 5 > 10) ? 1 : 0;\n+  return (1 || 0) ? 1 : 0 ;\n+  return (0 && 1) ? 1 : 0;\n+  return (2 || !2) ? 1 : 0;\n+  return (2 && !2) ? 1 : 0;\n+\n+  return 0;\n+}\n+"}, {"sha": "0daa513ffb2a87117bc91888a412885b8c67901c", "filename": "gcc/testsuite/gcc.dg/pr16302.c", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a243fb4a5bb588bbb4b7292a410b9594d7bf6e8d/gcc%2Ftestsuite%2Fgcc.dg%2Fpr16302.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a243fb4a5bb588bbb4b7292a410b9594d7bf6e8d/gcc%2Ftestsuite%2Fgcc.dg%2Fpr16302.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr16302.c?ref=a243fb4a5bb588bbb4b7292a410b9594d7bf6e8d", "patch": "@@ -0,0 +1,76 @@\n+/* PR 16302 */\n+/* { dg-do compile } */\n+/* { dg-options \"-Wlogical-op\" } */\n+void bar (int);\n+int\n+foo (int argc, char *argv[])\n+{\n+  if (argc != 1 || argc != 2) return 1; /* { dg-warning \"'or' of collectively exhaustive tests is always true\" } */\n+  if (argc < 0 && argc > 10) return 1; /* { dg-warning \"'and' of mutually exclusive tests is always false\" } */\n+  if (argc || !argc) return 1; /* { dg-warning \"'or' of collectively exhaustive tests is always true\" } */\n+  if (argc && !argc) return 1; /* { dg-warning \"'and' of mutually exclusive tests is always false\" } */\n+  bar (argc != 1 || argc != 2); /* { dg-warning \"'or' of collectively exhaustive tests is always true\" } */\n+  bar (argc < 0 && argc > 10); /* { dg-warning \"'and' of mutually exclusive tests is always false\" } */\n+  bar (argc || !argc); /* { dg-warning \"'or' of collectively exhaustive tests is always true\" } */\n+  bar (argc && !argc); /* { dg-warning \"'and' of mutually exclusive tests is always false\" } */\n+  return (argc != 1 || argc != 2) ? 1 : 0 ; /* { dg-warning \"'or' of collectively exhaustive tests is always true\" } */\n+  return (argc < 0 && argc > 10) ? 1 : 0; /* { dg-warning \"'and' of mutually exclusive tests is always false\" } */\n+  return (argc || !argc) ? 1 : 0; /* { dg-warning \"'or' of collectively exhaustive tests is always true\" } */\n+  return (argc && !argc) ? 1 : 0; /* { dg-warning \"'and' of mutually exclusive tests is always false\" } */\n+\n+  if (argc == 2 && argc == 1) return 1; /* { dg-warning \"'and' of mutually exclusive tests is always false\" } */\n+  if (argc < 0 && argc > 10) return 1; /* { dg-warning \"'and' of mutually exclusive tests is always false\" } */\n+  if (argc || !argc) return 1; /* { dg-warning \"'or' of collectively exhaustive tests is always true\" } */\n+  if (argc && !argc) return 1; /* { dg-warning \"'and' of mutually exclusive tests is always false\" } */\n+  bar (argc == 2 && argc == 1); /* { dg-warning \"'and' of mutually exclusive tests is always false\" } */\n+  bar (argc < 0 && argc > 10); /* { dg-warning \"'and' of mutually exclusive tests is always false\" } */\n+  bar (argc || !argc); /* { dg-warning \"'or' of collectively exhaustive tests is always true\" } */\n+  bar (argc && !argc); /* { dg-warning \"'and' of mutually exclusive tests is always false\" } */\n+  return (argc == 2 && argc == 1) ? 1 : 0 ; /* { dg-warning \"'and' of mutually exclusive tests is always false\" } */\n+  return (argc < 0 && argc > 10) ? 1 : 0; /* { dg-warning \"'and' of mutually exclusive tests is always false\" } */\n+  return (argc || !argc) ? 1 : 0; /* { dg-warning \"'or' of collectively exhaustive tests is always true\" } */\n+  return (argc && !argc) ? 1 : 0; /* { dg-warning \"'and' of mutually exclusive tests is always false\" } */\n+\n+  if (argc == 2 && argc == 1) return 1; /* { dg-warning \"'and' of mutually exclusive tests is always false\" } */\n+  if (argc < 0 && argc > 10) return 1; /* { dg-warning \"'and' of mutually exclusive tests is always false\" } */\n+  if (!argc || argc) return 1; /* { dg-warning \"'or' of collectively exhaustive tests is always true\" } */\n+  if (!argc && argc) return 1; /* { dg-warning \"'and' of mutually exclusive tests is always false\" } */\n+  bar (argc == 2 && argc == 1); /* { dg-warning \"'and' of mutually exclusive tests is always false\" } */\n+  bar (argc < 0 && argc > 10); /* { dg-warning \"'and' of mutually exclusive tests is always false\" } */\n+  bar (!argc || argc); /* { dg-warning \"'or' of collectively exhaustive tests is always true\" } */\n+  bar (!argc && argc); /* { dg-warning \"'and' of mutually exclusive tests is always false\" } */\n+  return (argc == 2 && argc == 1) ? 1 : 0 ; /* { dg-warning \"'and' of mutually exclusive tests is always false\" } */\n+  return (argc < 0 && argc > 10) ? 1 : 0; /* { dg-warning \"'and' of mutually exclusive tests is always false\" } */\n+  return (!argc || argc) ? 1 : 0; /* { dg-warning \"'or' of collectively exhaustive tests is always true\" } */\n+  return (!argc && argc) ? 1 : 0; /* { dg-warning \"'and' of mutually exclusive tests is always false\" } */\n+\n+  return 0;\n+}\n+\n+int\n+foo2 (int argc)\n+{\n+  if (5 != 1 || 5 != 2) return 1;\n+  if (5 < 0 && 5 > 10) return 1;\n+  if (1 || 0) return 1;\n+  if (0 && 1) return 1;\n+  if (2 || !2) return 1;\n+  if (2 && !2) return 1;\n+  if (!(!2) || !(2)) return 1;\n+  if (!(!2) && !(2)) return 1;\n+  bar (5 != 1 || 5 != 2);\n+  bar (5 < 0 && 5 > 10);\n+  bar (1 || 0);\n+  bar (0 && 1);\n+  bar (2 || !2);\n+  bar (2 && !2);\n+  return (5 != 1 || 5 != 2) ? 1 : 0 ;\n+  return (5 < 0 && 5 > 10) ? 1 : 0;\n+  return (1 || 0) ? 1 : 0 ;\n+  return (0 && 1) ? 1 : 0;\n+  return (2 || !2) ? 1 : 0;\n+  return (2 && !2) ? 1 : 0;\n+\n+  return 0;\n+}\n+"}, {"sha": "66d4e25fe2d7fe78d7bf4958c3df3acbf2dc05aa", "filename": "gcc/tree.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a243fb4a5bb588bbb4b7292a410b9594d7bf6e8d/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a243fb4a5bb588bbb4b7292a410b9594d7bf6e8d/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=a243fb4a5bb588bbb4b7292a410b9594d7bf6e8d", "patch": "@@ -4820,6 +4820,10 @@ extern bool is_builtin_name (const char*);\n extern int get_object_alignment (tree, unsigned int, unsigned int);\n extern tree fold_call_stmt (gimple, bool);\n extern tree gimple_fold_builtin_snprintf_chk (gimple, tree, enum built_in_function);\n+extern tree make_range (tree, int *, tree *, tree *, bool *);\n+extern tree build_range_check (tree, tree, int, tree, tree);\n+extern bool merge_ranges (int *, tree *, tree *, int, tree, tree, int, \n+\t\t\t  tree, tree);\n \n /* In convert.c */\n extern tree strip_float_extensions (tree);"}]}