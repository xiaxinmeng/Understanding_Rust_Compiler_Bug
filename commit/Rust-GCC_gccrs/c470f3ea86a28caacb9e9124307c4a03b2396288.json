{"sha": "c470f3ea86a28caacb9e9124307c4a03b2396288", "node_id": "C_kwDOANBUbNoAKGM0NzBmM2VhODZhMjhjYWFjYjllOTEyNDMwN2M0YTAzYjIzOTYyODg", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-05-12T13:18:06Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-05-13T19:39:59Z"}, "message": "libstdc++: Make std::rethrow_if_nested work without RTTI\n\nThis allows std::rethrow_if_nested to work with -fno-rtti by not\nattempting the dynamic_cast if it requires RTTI, since that's ill-formed\nwith -fno-rtti. The cast will still work if a static upcast to\nstd::nested_exception is allowed.\n\nAlso use if-constexpr to avoid the compile-time overload resolution (and\nSFINAE) and run-time dispatching for std::rethrow_if_nested and\nstd::throw_with_nested.\n\nAlso add better doxygen comments throughout the file.\n\nlibstdc++-v3/ChangeLog:\n\n\t* libsupc++/nested_exception.h (throw_with_nested) [C++17]: Use\n\tif-constexpr instead of tag dispatching.\n\t(rethrow_if_nested) [C++17]: Likewise.\n\t(rethrow_if_nested) [!__cpp_rtti]: Do not use dynamic_cast if it\n\twould require RTTI.\n\t* testsuite/18_support/nested_exception/rethrow_if_nested-term.cc:\n\tNew test.", "tree": {"sha": "5fe55f44b217038f4ff32e08a2daf5387186ac31", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5fe55f44b217038f4ff32e08a2daf5387186ac31"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c470f3ea86a28caacb9e9124307c4a03b2396288", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c470f3ea86a28caacb9e9124307c4a03b2396288", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c470f3ea86a28caacb9e9124307c4a03b2396288", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c470f3ea86a28caacb9e9124307c4a03b2396288/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e97e99296505e6015bc9e281364818bb89ca8a49", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e97e99296505e6015bc9e281364818bb89ca8a49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e97e99296505e6015bc9e281364818bb89ca8a49"}], "stats": {"total": 149, "additions": 130, "deletions": 19}, "files": [{"sha": "dec3c0c2a053dfd5eba0082de27513821665fae3", "filename": "libstdc++-v3/libsupc++/nested_exception.h", "status": "modified", "additions": 97, "deletions": 19, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c470f3ea86a28caacb9e9124307c4a03b2396288/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fnested_exception.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c470f3ea86a28caacb9e9124307c4a03b2396288/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fnested_exception.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fnested_exception.h?ref=c470f3ea86a28caacb9e9124307c4a03b2396288", "patch": "@@ -35,6 +35,7 @@\n #else\n \n #include <bits/move.h>\n+#include <bits/exception_ptr.h>\n \n extern \"C++\" {\n \n@@ -45,12 +46,22 @@ namespace std _GLIBCXX_VISIBILITY(default)\n    * @{\n    */\n \n-  /// Exception class with exception_ptr data member.\n+  /** Mixin class that stores the current exception.\n+   *\n+   * This type can be used via `std::throw_with_nested` to store\n+   * the current exception nested within another exception.\n+   *\n+   * @headerfile exception\n+   * @since C++11\n+   * @see std::throw_with_nested\n+   * @ingroup exceptions\n+   */\n   class nested_exception\n   {\n     exception_ptr _M_ptr;\n \n   public:\n+    /// The default constructor stores the current exception (if any).\n     nested_exception() noexcept : _M_ptr(current_exception()) { }\n \n     nested_exception(const nested_exception&) noexcept = default;\n@@ -59,6 +70,7 @@ namespace std _GLIBCXX_VISIBILITY(default)\n \n     virtual ~nested_exception() noexcept;\n \n+    /// Rethrow the stored exception, or terminate if none was stored.\n     [[noreturn]]\n     void\n     rethrow_nested() const\n@@ -68,6 +80,7 @@ namespace std _GLIBCXX_VISIBILITY(default)\n       std::terminate();\n     }\n \n+    /// Access the stored exception.\n     exception_ptr\n     nested_ptr() const noexcept\n     { return _M_ptr; }\n@@ -87,6 +100,7 @@ namespace std _GLIBCXX_VISIBILITY(default)\n       { }\n     };\n \n+#if __cplusplus < 201703L || ! defined __cpp_if_constexpr\n   // [except.nested]/8\n   // Throw an exception of unspecified type that is publicly derived from\n   // both remove_reference_t<_Tp> and nested_exception.\n@@ -95,20 +109,39 @@ namespace std _GLIBCXX_VISIBILITY(default)\n     inline void\n     __throw_with_nested_impl(_Tp&& __t, true_type)\n     {\n-      using _Up = typename remove_reference<_Tp>::type;\n-      throw _Nested_exception<_Up>{std::forward<_Tp>(__t)};\n+      throw _Nested_exception<__remove_cvref_t<_Tp>>{std::forward<_Tp>(__t)};\n     }\n \n   template<typename _Tp>\n     [[noreturn]]\n     inline void\n     __throw_with_nested_impl(_Tp&& __t, false_type)\n     { throw std::forward<_Tp>(__t); }\n+#endif\n \n   /// @endcond\n \n-  /// If @p __t is derived from nested_exception, throws @p __t.\n-  /// Else, throws an implementation-defined object derived from both.\n+  /** Throw an exception that also stores the currently active exception.\n+   *\n+   * If `_Tp` is derived from `std::nested_exception` or is not usable\n+   * as a base-class, throws a copy of `__t`.\n+   * Otherwise, throws an object of an implementation-defined type derived\n+   * from both `_Tp` and `std::nested_exception`, containing a copy of `__t`\n+   * and the result of `std::current_exception()`.\n+   *\n+   * In other words, throws the argument as a new exception that contains\n+   * the currently active exception nested within it. This is intended for\n+   * use in a catch handler to replace the caught exception with a different\n+   * type, while still preserving the original exception. When the new\n+   * exception is caught, the nested exception can be rethrown by using\n+   * `std::rethrow_if_nested`.\n+   *\n+   * This can be used at API boundaries, for example to catch a library's\n+   * internal exception type and rethrow it nested with a `std::runtime_error`,\n+   * or vice versa.\n+   *\n+   * @since C++11\n+   */\n   template<typename _Tp>\n     [[noreturn]]\n     inline void\n@@ -119,42 +152,87 @@ namespace std _GLIBCXX_VISIBILITY(default)\n \t= __and_<is_copy_constructible<_Up>, is_move_constructible<_Up>>;\n       static_assert(_CopyConstructible::value,\n \t  \"throw_with_nested argument must be CopyConstructible\");\n+\n+#if __cplusplus >= 201703L && __cpp_if_constexpr\n+      if constexpr (is_class_v<_Up>)\n+\tif constexpr (!is_final_v<_Up>)\n+\t  if constexpr (!is_base_of_v<nested_exception, _Up>)\n+\t    throw _Nested_exception<_Up>{std::forward<_Tp>(__t)};\n+      throw std::forward<_Tp>(__t);\n+#else\n       using __nest = __and_<is_class<_Up>, __bool_constant<!__is_final(_Up)>,\n \t\t\t    __not_<is_base_of<nested_exception, _Up>>>;\n       std::__throw_with_nested_impl(std::forward<_Tp>(__t), __nest{});\n+#endif\n     }\n \n+#if __cplusplus < 201703L || ! defined __cpp_if_constexpr\n   /// @cond undocumented\n \n-  // Determine if dynamic_cast<const nested_exception&> would be well-formed.\n-  template<typename _Tp>\n-    using __rethrow_if_nested_cond = typename enable_if<\n-      __and_<is_polymorphic<_Tp>,\n-\t     __or_<__not_<is_base_of<nested_exception, _Tp>>,\n-\t\t   is_convertible<_Tp*, nested_exception*>>>::value\n-    >::type;\n-\n   // Attempt dynamic_cast to nested_exception and call rethrow_nested().\n   template<typename _Ex>\n-    inline __rethrow_if_nested_cond<_Ex>\n-    __rethrow_if_nested_impl(const _Ex* __ptr)\n+    inline void\n+    __rethrow_if_nested_impl(const _Ex* __ptr, true_type)\n     {\n       if (auto __ne_ptr = dynamic_cast<const nested_exception*>(__ptr))\n \t__ne_ptr->rethrow_nested();\n     }\n \n   // Otherwise, no effects.\n   inline void\n-  __rethrow_if_nested_impl(const void*)\n+  __rethrow_if_nested_impl(const void*, false_type)\n   { }\n \n   /// @endcond\n-\n-  /// If @p __ex is derived from nested_exception, @p __ex.rethrow_nested().\n+#endif\n+\n+  /** Rethrow a nested exception\n+   *\n+   * If `__ex` contains a `std::nested_exception` object, call its\n+   * `rethrow_nested()` member to rethrow the stored exception.\n+   *\n+   * After catching an exception thrown by a call to `std::throw_with_nested`\n+   * this function can be used to rethrow the exception that was active when\n+   * `std::throw_with_nested` was called.\n+   *\n+   * @since C++11\n+   */\n+  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+  // 2484. rethrow_if_nested() is doubly unimplementable\n+  // 2784. Resolution to LWG 2484 is missing \"otherwise, no effects\" and [...]\n   template<typename _Ex>\n+# if ! __cpp_rtti\n+    [[__gnu__::__always_inline__]]\n+#endif\n     inline void\n     rethrow_if_nested(const _Ex& __ex)\n-    { std::__rethrow_if_nested_impl(std::__addressof(__ex)); }\n+    {\n+      const _Ex* __ptr = __builtin_addressof(__ex);\n+#if __cplusplus < 201703L || ! defined __cpp_if_constexpr\n+# if __cpp_rtti\n+      using __cast = __and_<is_polymorphic<_Ex>,\n+\t\t\t    __or_<__not_<is_base_of<nested_exception, _Ex>>,\n+\t\t\t\t  is_convertible<_Ex*, nested_exception*>>>;\n+# else\n+      using __cast = __and_<is_polymorphic<_Ex>,\n+\t\t\t    is_base_of<nested_exception, _Ex>,\n+\t\t\t    is_convertible<_Ex*, nested_exception*>>;\n+# endif\n+      std::__rethrow_if_nested_impl(__ptr, __cast{});\n+#else\n+      if constexpr (!is_polymorphic_v<_Ex>)\n+\treturn;\n+      else if constexpr (is_base_of_v<nested_exception, _Ex>\n+\t\t\t && !is_convertible_v<_Ex*, nested_exception*>)\n+\treturn; // nested_exception base class is inaccessible or ambiguous.\n+# if ! __cpp_rtti\n+      else if constexpr (!is_base_of_v<nested_exception, _Ex>)\n+\treturn; // Cannot do polymorphic casts without RTTI.\n+# endif\n+      else if (auto __ne_ptr = dynamic_cast<const nested_exception*>(__ptr))\n+\t__ne_ptr->rethrow_nested();\n+#endif\n+    }\n \n   /// @} group exceptions\n } // namespace std"}, {"sha": "5913392bd461a9e4c9b30f4d2b01aa543faa3dfb", "filename": "libstdc++-v3/testsuite/18_support/nested_exception/rethrow_if_nested-term.cc", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c470f3ea86a28caacb9e9124307c4a03b2396288/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fnested_exception%2Frethrow_if_nested-term.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c470f3ea86a28caacb9e9124307c4a03b2396288/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fnested_exception%2Frethrow_if_nested-term.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fnested_exception%2Frethrow_if_nested-term.cc?ref=c470f3ea86a28caacb9e9124307c4a03b2396288", "patch": "@@ -0,0 +1,33 @@\n+// { dg-do run { target c++11 } }\n+// { dg-skip-if \"\" { *-*-* } { \"-fno-exceptions\" } }\n+\n+#include <exception>\n+#include <cstdlib>\n+\n+[[noreturn]] void terminate_cleanly() noexcept { std::exit(0); }\n+\n+struct A { virtual ~A() = default; };\n+\n+int main()\n+{\n+  try\n+  {\n+    // At this point std::current_exception() == nullptr so the\n+    // std::nested_exception object is empty.\n+    std::throw_with_nested(A{});\n+  }\n+  catch (const A& a)\n+  {\n+    std::set_terminate(terminate_cleanly);\n+    std::rethrow_if_nested(a);\n+#if __cpp_rtti\n+    // No nested exception, so trying to rethrow it calls std::terminate()\n+    // which calls std::exit(0). Shoud not reach this point.\n+    std::abort();\n+#else\n+    // Without RTTI we can't dynamic_cast<const std::nested_exception*>(&a)\n+    // so std::rethrow_if_nested(a) just returns normally.\n+    return 0;\n+#endif\n+  }\n+}"}]}