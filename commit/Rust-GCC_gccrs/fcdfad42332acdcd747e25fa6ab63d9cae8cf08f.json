{"sha": "fcdfad42332acdcd747e25fa6ab63d9cae8cf08f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmNkZmFkNDIzMzJhY2RjZDc0N2UyNWZhNmFiNjNkOWNhZThjZjA4Zg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-07-09T00:02:54Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-07-09T00:02:54Z"}, "message": "iq2000-protos.h (iq2000_va_arg): Remove.\n\n        * config/iq2000/iq2000-protos.h (iq2000_va_arg): Remove.\n        * config/iq2000/iq2000.c (TARGET_GIMPLIFY_VA_ARG_EXPR): New.\n        (iq2000_gimplify_va_arg_expr): Rewrite from iq2000_va_arg.\n        * config/iq2000/iq2000.h (EXPAND_BUILTIN_VA_ARG): Remove.\n\nFrom-SVN: r84330", "tree": {"sha": "28ba60771c0c7a5ef46abea5adfff1c587e57358", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/28ba60771c0c7a5ef46abea5adfff1c587e57358"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fcdfad42332acdcd747e25fa6ab63d9cae8cf08f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fcdfad42332acdcd747e25fa6ab63d9cae8cf08f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fcdfad42332acdcd747e25fa6ab63d9cae8cf08f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fcdfad42332acdcd747e25fa6ab63d9cae8cf08f/comments", "author": null, "committer": null, "parents": [{"sha": "28cb76675ea1383deb22651d8f3459bb76d8b2bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28cb76675ea1383deb22651d8f3459bb76d8b2bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28cb76675ea1383deb22651d8f3459bb76d8b2bf"}], "stats": {"total": 210, "additions": 13, "deletions": 197}, "files": [{"sha": "330f1756a95fb3a906f92b47c69ad3ab6b1f30f9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcdfad42332acdcd747e25fa6ab63d9cae8cf08f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcdfad42332acdcd747e25fa6ab63d9cae8cf08f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fcdfad42332acdcd747e25fa6ab63d9cae8cf08f", "patch": "@@ -1,5 +1,10 @@\n 2004-07-08  Richard Henderson  <rth@redhat.com>\n \n+\t* config/iq2000/iq2000-protos.h (iq2000_va_arg): Remove.\n+\t* config/iq2000/iq2000.c (TARGET_GIMPLIFY_VA_ARG_EXPR): New.\n+\t(iq2000_gimplify_va_arg_expr): Rewrite from iq2000_va_arg.\n+\t* config/iq2000/iq2000.h (EXPAND_BUILTIN_VA_ARG): Remove.\n+\n \t* config/frv/frv-protos.h (frv_expand_builtin_va_arg): Remove.\n \t* config/frv/frv.c (TARGET_GIMPLIFY_VA_ARG_EXPR): New.\n \t(frv_gimplify_va_arg_expr): Rewrite from frv_expand_builtin_va_arg."}, {"sha": "60c34bc37abd678c868c667cd11b60999a48252f", "filename": "gcc/config/iq2000/iq2000-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcdfad42332acdcd747e25fa6ab63d9cae8cf08f/gcc%2Fconfig%2Fiq2000%2Fiq2000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcdfad42332acdcd747e25fa6ab63d9cae8cf08f/gcc%2Fconfig%2Fiq2000%2Fiq2000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000-protos.h?ref=fcdfad42332acdcd747e25fa6ab63d9cae8cf08f", "patch": "@@ -52,7 +52,6 @@ extern void             function_arg_advance (CUMULATIVE_ARGS *, enum machine_mo\n extern struct rtx_def * function_arg (CUMULATIVE_ARGS *, enum machine_mode, tree, int);\n extern int              function_arg_partial_nregs (CUMULATIVE_ARGS *, enum machine_mode, tree, int);\n extern void             iq2000_va_start (tree, rtx);\n-extern rtx              iq2000_va_arg (tree, tree);\n extern rtx              iq2000_function_value (tree, tree);\n #endif\n "}, {"sha": "ab7a7b52d11203d08554b694c48958764a647cc8", "filename": "gcc/config/iq2000/iq2000.c", "status": "modified", "additions": 8, "deletions": 192, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcdfad42332acdcd747e25fa6ab63d9cae8cf08f/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcdfad42332acdcd747e25fa6ab63d9cae8cf08f/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.c?ref=fcdfad42332acdcd747e25fa6ab63d9cae8cf08f", "patch": "@@ -171,6 +171,7 @@ static bool iq2000_rtx_costs          (rtx, int, int, int *);\n static int  iq2000_address_cost       (rtx);\n static void iq2000_select_section     (tree, int, unsigned HOST_WIDE_INT);\n static bool iq2000_return_in_memory   (tree, tree);\n+static tree iq2000_gimplify_va_arg_expr (tree, tree, tree *, tree *);\n \n #undef  TARGET_INIT_BUILTINS\n #define TARGET_INIT_BUILTINS \t\tiq2000_init_builtins\n@@ -199,6 +200,8 @@ static bool iq2000_return_in_memory   (tree, tree);\n #define TARGET_SETUP_INCOMING_VARARGS\tiq2000_setup_incoming_varargs\n #undef  TARGET_STRICT_ARGUMENT_NAMING\n #define TARGET_STRICT_ARGUMENT_NAMING\thook_bool_CUMULATIVE_ARGS_true\n+#undef  TARGET_GIMPLIFY_VA_ARG_EXPR\n+#define TARGET_GIMPLIFY_VA_ARG_EXPR\tiq2000_gimplify_va_arg_expr\n \n #undef TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE\n #define TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE hook_int_void_1\n@@ -1590,200 +1593,13 @@ iq2000_va_start (tree valist, rtx nextarg)\n \n /* Implement va_arg.  */\n \n-rtx\n-iq2000_va_arg (tree valist, tree type)\n+static tree\n+iq2000_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p, tree *post_p)\n {\n-  HOST_WIDE_INT size, rsize;\n-  rtx addr_rtx;\n-  tree t;\n-  int indirect;\n-  rtx r, lab_over = NULL_RTX, lab_false;\n-  tree f_ovfl, f_gtop, f_ftop, f_goff, f_foff;\n-  tree ovfl, gtop, ftop, goff, foff;\n-\n-  size = int_size_in_bytes (type);\n-  rsize = (size + UNITS_PER_WORD - 1) & -UNITS_PER_WORD;\n-  indirect\n-    = function_arg_pass_by_reference (NULL, TYPE_MODE (type), type, 0);\n-  if (indirect)\n-    {\n-      size = POINTER_SIZE / BITS_PER_UNIT;\n-      rsize = UNITS_PER_WORD;\n-    }\n-\n-  addr_rtx = gen_reg_rtx (Pmode);\n-\n-  {\n-    /* Case of all args in a merged stack. No need to check bounds,\n-       just advance valist along the stack.  */\n-    tree gpr = valist;\n-\n-    if (! indirect\n-\t&& TYPE_ALIGN (type) > (unsigned) BITS_PER_WORD)\n-      {\n-\tt = build (PLUS_EXPR, TREE_TYPE (gpr), gpr,\n-\t\t   build_int_2 (2*UNITS_PER_WORD - 1, 0));\n-\tt = build (BIT_AND_EXPR, TREE_TYPE (t), t,\n-\t\t   build_int_2 (-2*UNITS_PER_WORD, -1));\n-\tt = build (MODIFY_EXPR, TREE_TYPE (gpr), gpr, t);\n-\texpand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-      }\n-\n-    t = build (POSTINCREMENT_EXPR, TREE_TYPE (gpr), gpr,\n-\t       size_int (rsize));\n-    r = expand_expr (t, addr_rtx, Pmode, EXPAND_NORMAL);\n-    if (r != addr_rtx)\n-      emit_move_insn (addr_rtx, r);\n-\n-    /* Flush the POSTINCREMENT.  */\n-    emit_queue();\n-\n-    if (indirect)\n-      {\n-\tr = gen_rtx_MEM (Pmode, addr_rtx);\n-\tset_mem_alias_set (r, get_varargs_alias_set ());\n-\temit_move_insn (addr_rtx, r);\n-      }\n-    else\n-      {\n-\tif (BYTES_BIG_ENDIAN && rsize != size)\n-\t  addr_rtx = plus_constant (addr_rtx, rsize - size);\n-      }\n-    return addr_rtx;\n-  }\n-\n-  /* Not a simple merged stack.  Need ptrs and indexes left by va_start.  */\n-  f_ovfl  = TYPE_FIELDS (va_list_type_node);\n-  f_gtop = TREE_CHAIN (f_ovfl);\n-  f_ftop = TREE_CHAIN (f_gtop);\n-  f_goff = TREE_CHAIN (f_ftop);\n-  f_foff = TREE_CHAIN (f_goff);\n-\n-  ovfl = build (COMPONENT_REF, TREE_TYPE (f_ovfl), valist, f_ovfl, NULL_TREE);\n-  gtop = build (COMPONENT_REF, TREE_TYPE (f_gtop), valist, f_gtop, NULL_TREE);\n-  ftop = build (COMPONENT_REF, TREE_TYPE (f_ftop), valist, f_ftop, NULL_TREE);\n-  goff = build (COMPONENT_REF, TREE_TYPE (f_goff), valist, f_goff, NULL_TREE);\n-  foff = build (COMPONENT_REF, TREE_TYPE (f_foff), valist, f_foff, NULL_TREE);\n-\n-  lab_false = gen_label_rtx ();\n-  lab_over = gen_label_rtx ();\n-\n-  if (TREE_CODE (type) == REAL_TYPE)\n-    {\n-      /* Emit code to branch if foff == 0.  */\n-      r = expand_expr (foff, NULL_RTX, TYPE_MODE (TREE_TYPE (foff)),\n-\t\t       EXPAND_NORMAL);\n-      emit_cmp_and_jump_insns (r, const0_rtx, EQ,\n-\t\t\t       const1_rtx, GET_MODE (r), 1, lab_false);\n-\n-      /* Emit code for addr_rtx = ftop - foff.  */\n-      t = build (MINUS_EXPR, TREE_TYPE (ftop), ftop, foff );\n-      r = expand_expr (t, addr_rtx, Pmode, EXPAND_NORMAL);\n-      if (r != addr_rtx)\n-\temit_move_insn (addr_rtx, r);\n-\n-      /* Emit code for foff-=8.\n-\t Advances the offset up FPR save area by one double.  */\n-      t = build (MINUS_EXPR, TREE_TYPE (foff), foff, build_int_2 (8, 0));\n-      t = build (MODIFY_EXPR, TREE_TYPE (foff), foff, t);\n-      expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-\n-      emit_queue ();\n-      emit_jump (lab_over);\n-      emit_barrier ();\n-      emit_label (lab_false);\n-\n-      /* If a 4-byte int is followed by an 8-byte float, then\n-\t natural alignment causes a 4 byte gap.\n-\t So, dynamically adjust ovfl up to a multiple of 8.  */\n-      t = build (BIT_AND_EXPR, TREE_TYPE (ovfl), ovfl,\n-\t\t build_int_2 (7, 0));\n-      t = build (PLUS_EXPR, TREE_TYPE (ovfl), ovfl, t);\n-      t = build (MODIFY_EXPR, TREE_TYPE (ovfl), ovfl, t);\n-      expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-\n-      /* Emit code for addr_rtx = the ovfl pointer into overflow area.\n-\t Postincrement the ovfl pointer by 8.  */\n-      t = build (POSTINCREMENT_EXPR, TREE_TYPE(ovfl), ovfl,\n-\t\t size_int (8));\n-      r = expand_expr (t, addr_rtx, Pmode, EXPAND_NORMAL);\n-      if (r != addr_rtx)\n-\temit_move_insn (addr_rtx, r);\n-\n-      emit_queue();\n-      emit_label (lab_over);\n-      return addr_rtx;\n-    }\n+  if (function_arg_pass_by_reference (NULL, TYPE_MODE (type), type, 0))\n+    return ind_gimplify_va_arg_expr (valist, type, pre_p, post_p);\n   else\n-    {\n-      /* Not REAL_TYPE.  */\n-      int step_size;\n-\n-      if (TREE_CODE (type) == INTEGER_TYPE\n-\t  && TYPE_PRECISION (type) == 64)\n-\t{\n-\t  /* int takes 32 bits of the GPR save area, but\n-\t     longlong takes an aligned 64 bits.  So, emit code\n-\t     to zero the low order bits of goff, thus aligning\n-\t     the later calculation of (gtop-goff) upwards.  */\n-\t  t = build (BIT_AND_EXPR, TREE_TYPE (goff), goff,\n-\t\t     build_int_2 (-8, -1));\n-\t  t = build (MODIFY_EXPR, TREE_TYPE (goff), goff, t);\n-\t  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-\t}\n-\n-      /* Emit code to branch if goff == 0.  */\n-      r = expand_expr (goff, NULL_RTX, TYPE_MODE (TREE_TYPE (goff)),\n-\t\t       EXPAND_NORMAL);\n-      emit_cmp_and_jump_insns (r, const0_rtx, EQ,\n-\t\t\t       const1_rtx, GET_MODE (r), 1, lab_false);\n-\n-      /* Emit code for addr_rtx = gtop - goff.  */\n-      t = build (MINUS_EXPR, TREE_TYPE (gtop), gtop, goff);\n-      r = expand_expr (t, addr_rtx, Pmode, EXPAND_NORMAL);\n-      if (r != addr_rtx)\n-\temit_move_insn (addr_rtx, r);\n-      \n-      if (TYPE_PRECISION (type) == 64)\n-\tstep_size = 8;\n-      else\n-\tstep_size = UNITS_PER_WORD;\n-\n-      /* Emit code for goff = goff - step_size.\n-\t Advances the offset up GPR save area over the item.  */\n-      t = build (MINUS_EXPR, TREE_TYPE (goff), goff,\n-\t\t build_int_2 (step_size, 0));\n-      t = build (MODIFY_EXPR, TREE_TYPE (goff), goff, t);\n-      expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-      \n-      emit_queue();\n-      emit_jump (lab_over);\n-      emit_barrier ();\n-      emit_label (lab_false);\n-\n-      /* Emit code for addr_rtx -> overflow area, postinc by step_size.  */\n-      t = build (POSTINCREMENT_EXPR, TREE_TYPE(ovfl), ovfl,\n-\t\t size_int (step_size));\n-      r = expand_expr (t, addr_rtx, Pmode, EXPAND_NORMAL);\n-      if (r != addr_rtx)\n-\temit_move_insn (addr_rtx, r);\n-\n-      emit_queue();\n-      emit_label (lab_over);\n-\n-      if (indirect)\n-\t{\n-\t  r = gen_rtx_MEM (Pmode, addr_rtx);\n-\t  set_mem_alias_set (r, get_varargs_alias_set ());\n-\t  emit_move_insn (addr_rtx, r);\n-\t}\n-      else\n-\t{\n-\t  if (BYTES_BIG_ENDIAN && rsize != size)\n-\t    addr_rtx = plus_constant (addr_rtx, rsize - size);\n-\t}\n-      return addr_rtx;\n-    }\n+    return std_gimplify_va_arg_expr (valist, type, pre_p, post_p);\n }\n \f\n /* Allocate a chunk of memory for per-function machine-dependent data.  */"}, {"sha": "d4e27c1aae3d04e27a5046942567032855a6bcf9", "filename": "gcc/config/iq2000/iq2000.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcdfad42332acdcd747e25fa6ab63d9cae8cf08f/gcc%2Fconfig%2Fiq2000%2Fiq2000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcdfad42332acdcd747e25fa6ab63d9cae8cf08f/gcc%2Fconfig%2Fiq2000%2Fiq2000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.h?ref=fcdfad42332acdcd747e25fa6ab63d9cae8cf08f", "patch": "@@ -544,10 +544,6 @@ typedef struct iq2000_args\n #define EXPAND_BUILTIN_VA_START(valist, nextarg) \\\n   iq2000_va_start (valist, nextarg)\n \n-/* Implement `va_arg'.  */\n-#define EXPAND_BUILTIN_VA_ARG(valist, type) \\\n-  iq2000_va_arg (valist, type)\n-\n \f\n /* Trampolines for Nested Functions.  */\n "}]}