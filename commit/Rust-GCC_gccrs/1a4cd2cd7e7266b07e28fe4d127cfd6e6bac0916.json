{"sha": "1a4cd2cd7e7266b07e28fe4d127cfd6e6bac0916", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWE0Y2QyY2Q3ZTcyNjZiMDdlMjhmZTRkMTI3Y2ZkNmU2YmFjMDkxNg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2015-06-10T15:17:57Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2015-06-10T15:17:57Z"}, "message": "re PR c++/66289 (\"error: ambiguous template instantiation\" with partial specialization defined in terms of alias template)\n\n\tPR c++/66289\n\t* cp-tree.h (TEMPLATE_DECL_COMPLEX_ALIAS_P): New.\n\t* pt.c (push_template_decl_real): Set it.\n\t(dependent_alias_template_spec_p): Use it.\n\t(dependent_type_p_r): Use dependent_alias_template_spec_p.\n\t(uses_all_template_parms_data, uses_all_template_parms_r)\n\t(complex_alias_template_p): New.\n\t(get_template_parm_index): Handle BOUND_TEMPLATE_TEMPLATE_PARM.\n\nFrom-SVN: r224331", "tree": {"sha": "22325591562920d7d55ce475ed6285db1487f725", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/22325591562920d7d55ce475ed6285db1487f725"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a4cd2cd7e7266b07e28fe4d127cfd6e6bac0916", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a4cd2cd7e7266b07e28fe4d127cfd6e6bac0916", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a4cd2cd7e7266b07e28fe4d127cfd6e6bac0916", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a4cd2cd7e7266b07e28fe4d127cfd6e6bac0916/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "768b666466931611b0b39f125cb0645b1cf3d102", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/768b666466931611b0b39f125cb0645b1cf3d102", "html_url": "https://github.com/Rust-GCC/gccrs/commit/768b666466931611b0b39f125cb0645b1cf3d102"}], "stats": {"total": 85, "additions": 81, "deletions": 4}, "files": [{"sha": "a3dd1db9157d37a58f06f0099b2b59dd48ac9f7b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a4cd2cd7e7266b07e28fe4d127cfd6e6bac0916/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a4cd2cd7e7266b07e28fe4d127cfd6e6bac0916/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=1a4cd2cd7e7266b07e28fe4d127cfd6e6bac0916", "patch": "@@ -1,3 +1,14 @@\n+2015-06-10  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/66289\n+\t* cp-tree.h (TEMPLATE_DECL_COMPLEX_ALIAS_P): New.\n+\t* pt.c (push_template_decl_real): Set it.\n+\t(dependent_alias_template_spec_p): Use it.\n+\t(dependent_type_p_r): Use dependent_alias_template_spec_p.\n+\t(uses_all_template_parms_data, uses_all_template_parms_r)\n+\t(complex_alias_template_p): New.\n+\t(get_template_parm_index): Handle BOUND_TEMPLATE_TEMPLATE_PARM.\n+\n 2015-06-09  Jason Merrill  <jason@redhat.com>\n \n \tDR 1467"}, {"sha": "1eac6367d25083b55464c98d4ba919a00e1a3f6e", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a4cd2cd7e7266b07e28fe4d127cfd6e6bac0916/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a4cd2cd7e7266b07e28fe4d127cfd6e6bac0916/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=1a4cd2cd7e7266b07e28fe4d127cfd6e6bac0916", "patch": "@@ -155,6 +155,7 @@ c-common.h, not after.\n       LABEL_DECL_CONTINUE (in LABEL_DECL)\n    2: DECL_THIS_EXTERN (in VAR_DECL or FUNCTION_DECL).\n       DECL_IMPLICIT_TYPEDEF_P (in a TYPE_DECL)\n+      TEMPLATE_DECL_COMPLEX_ALIAS_P (in TEMPLATE_DECL)\n    3: DECL_IN_AGGR_P.\n    4: DECL_C_BIT_FIELD (in a FIELD_DECL)\n       DECL_ANON_UNION_VAR_P (in a VAR_DECL)\n@@ -2732,6 +2733,10 @@ extern void decl_shadowed_for_var_insert (tree, tree);\n #define TYPE_DECL_ALIAS_P(NODE) \\\n   DECL_LANG_FLAG_6 (TYPE_DECL_CHECK (NODE))\n \n+/* Nonzero for TEMPLATE_DECL means that it is a 'complex' alias template.  */\n+#define TEMPLATE_DECL_COMPLEX_ALIAS_P(NODE) \\\n+  DECL_LANG_FLAG_2 (TEMPLATE_DECL_CHECK (NODE))\n+\n /* Nonzero for a type which is an alias for another type; i.e, a type\n    which declaration was written 'using name-of-type =\n    another-type'.  */"}, {"sha": "7f04fe618b48d1b89ad2b1179b3ab6e1d0218d96", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 52, "deletions": 4, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a4cd2cd7e7266b07e28fe4d127cfd6e6bac0916/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a4cd2cd7e7266b07e28fe4d127cfd6e6bac0916/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=1a4cd2cd7e7266b07e28fe4d127cfd6e6bac0916", "patch": "@@ -211,6 +211,7 @@ static tree template_parm_to_arg (tree t);\n static tree current_template_args (void);\n static tree tsubst_template_parm (tree, tree, tsubst_flags_t);\n static tree instantiate_alias_template (tree, tree, tsubst_flags_t);\n+static bool complex_alias_template_p (const_tree tmpl);\n \n /* Make the current scope suitable for access checking when we are\n    processing T.  T can be FUNCTION_DECL for instantiated function\n@@ -4420,6 +4421,7 @@ get_template_parm_index (tree parm)\n \t   || TREE_CODE (parm) == TEMPLATE_DECL)\n     parm = TREE_TYPE (parm);\n   if (TREE_CODE (parm) == TEMPLATE_TYPE_PARM\n+      || TREE_CODE (parm) == BOUND_TEMPLATE_TEMPLATE_PARM\n       || TREE_CODE (parm) == TEMPLATE_TEMPLATE_PARM)\n     parm = TEMPLATE_TYPE_PARM_INDEX (parm);\n   gcc_assert (TREE_CODE (parm) == TEMPLATE_PARM_INDEX);\n@@ -5096,6 +5098,11 @@ template arguments to %qD do not match original template %qD\",\n \t  if (TREE_CODE (parm) == TEMPLATE_DECL)\n \t    DECL_CONTEXT (parm) = tmpl;\n \t}\n+\n+      if (TREE_CODE (decl) == TYPE_DECL\n+\t  && TYPE_DECL_ALIAS_P (decl)\n+\t  && complex_alias_template_p (tmpl))\n+\tTEMPLATE_DECL_COMPLEX_ALIAS_P (tmpl) = true;\n     }\n \n   /* The DECL_TI_ARGS of DECL contains full set of arguments referring\n@@ -5353,13 +5360,56 @@ alias_template_specialization_p (const_tree t)\n   return false;\n }\n \n-/* Return TRUE iff T is a specialization of an alias template with\n+/* An alias template is complex from a SFINAE perspective if a template-id\n+   using that alias can be ill-formed when the expansion is not, as with\n+   the void_t template.  We determine this by checking whether the\n+   expansion for the alias template uses all its template parameters.  */\n+\n+struct uses_all_template_parms_data\n+{\n+  int level;\n+  bool *seen;\n+};\n+\n+static int\n+uses_all_template_parms_r (tree t, void *data_)\n+{\n+  struct uses_all_template_parms_data &data\n+    = *(struct uses_all_template_parms_data*)data_;\n+  tree idx = get_template_parm_index (t);\n+\n+  if (TEMPLATE_PARM_LEVEL (idx) == data.level)\n+    data.seen[TEMPLATE_PARM_IDX (idx)] = true;\n+  return 0;\n+}\n+\n+static bool\n+complex_alias_template_p (const_tree tmpl)\n+{\n+  struct uses_all_template_parms_data data;\n+  tree pat = DECL_ORIGINAL_TYPE (DECL_TEMPLATE_RESULT (tmpl));\n+  tree parms = DECL_TEMPLATE_PARMS (tmpl);\n+  data.level = TMPL_PARMS_DEPTH (parms);\n+  int len = TREE_VEC_LENGTH (INNERMOST_TEMPLATE_PARMS (parms));\n+  data.seen = XALLOCAVEC (bool, len);\n+  for (int i = 0; i < len; ++i)\n+    data.seen[i] = false;\n+\n+  for_each_template_parm (pat, uses_all_template_parms_r, &data, NULL, true);\n+  for (int i = 0; i < len; ++i)\n+    if (!data.seen[i])\n+      return true;\n+  return false;\n+}\n+\n+/* Return TRUE iff T is a specialization of a complex alias template with\n    dependent template-arguments.  */\n \n bool\n dependent_alias_template_spec_p (const_tree t)\n {\n   return (alias_template_specialization_p (t)\n+\t  && TEMPLATE_DECL_COMPLEX_ALIAS_P (DECL_TI_TEMPLATE (TYPE_NAME (t)))\n \t  && (any_dependent_template_arguments_p\n \t      (INNERMOST_TEMPLATE_ARGS (TYPE_TI_ARGS (t)))));\n }\n@@ -20951,9 +21001,7 @@ dependent_type_p_r (tree type)\n     return true;\n   /* For an alias template specialization, check the arguments both to the\n      class template and the alias template.  */\n-  else if (alias_template_specialization_p (type)\n-\t   && (any_dependent_template_arguments_p\n-\t       (INNERMOST_TEMPLATE_ARGS (TYPE_TI_ARGS (type)))))\n+  else if (dependent_alias_template_spec_p (type))\n     return true;\n \n   /* All TYPEOF_TYPEs, DECLTYPE_TYPEs, and UNDERLYING_TYPEs are"}, {"sha": "8d5eb23de8be4c750561c7c0e2e78a5bddf7b6be", "filename": "gcc/testsuite/g++.dg/cpp0x/alias-decl-48.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a4cd2cd7e7266b07e28fe4d127cfd6e6bac0916/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-48.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a4cd2cd7e7266b07e28fe4d127cfd6e6bac0916/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-48.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-48.C?ref=1a4cd2cd7e7266b07e28fe4d127cfd6e6bac0916", "patch": "@@ -0,0 +1,13 @@\n+// PR c++/66289\n+// { dg-do compile { target c++11 } }\n+\n+template<typename T> struct A {};\n+\n+template<typename T> struct shared_ptr { };\n+template<typename T> using APtr = shared_ptr<A<T>>;\n+\n+template<typename T> struct foo;\n+template<typename T> struct foo<shared_ptr<T>> { };\n+template<typename T> struct foo<APtr<T>> { };\n+\n+foo<shared_ptr<A<int>>> aa;"}]}