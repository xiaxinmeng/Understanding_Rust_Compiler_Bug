{"sha": "77a989d1b601bacbd84158982df1721e80a7c918", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzdhOTg5ZDFiNjAxYmFjYmQ4NDE1ODk4MmRmMTcyMWU4MGE3YzkxOA==", "commit": {"author": {"name": "Stan Cox", "email": "coxs@gnu.org", "date": "1996-05-17T15:51:43Z"}, "committer": {"name": "Stan Cox", "email": "coxs@gnu.org", "date": "1996-05-17T15:51:43Z"}, "message": "(function_prologue, ix86_expand_prologue,\n\nfunction_epilogue, ix86_expand_epilogue): Generate prologue and\nepilogue as RTL (prior to scheduling) instead of emitting asm.\n(override_options): If only -march is given, make it the default -mcpu.\n\nFrom-SVN: r11988", "tree": {"sha": "150f3e6594708e8555ed49ca737d6ef1f972e844", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/150f3e6594708e8555ed49ca737d6ef1f972e844"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/77a989d1b601bacbd84158982df1721e80a7c918", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77a989d1b601bacbd84158982df1721e80a7c918", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77a989d1b601bacbd84158982df1721e80a7c918", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77a989d1b601bacbd84158982df1721e80a7c918/comments", "author": null, "committer": null, "parents": [{"sha": "21d4969d08a183a0ca8a7c6c5275b7c6672ac04a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21d4969d08a183a0ca8a7c6c5275b7c6672ac04a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21d4969d08a183a0ca8a7c6c5275b7c6672ac04a"}], "stats": {"total": 158, "additions": 114, "deletions": 44}, "files": [{"sha": "d4e000185d6b6286609b3b7924286b80bc980e84", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 114, "deletions": 44, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77a989d1b601bacbd84158982df1721e80a7c918/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77a989d1b601bacbd84158982df1721e80a7c918/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=77a989d1b601bacbd84158982df1721e80a7c918", "patch": "@@ -147,7 +147,6 @@ int i386_align_loops;\t\t\t\t/* power of two alignment for loops */\n int i386_align_jumps;\t\t\t\t/* power of two alignment for non-loop jumps */\n int i386_align_funcs;\t\t\t\t/* power of two alignment for functions */\n \n-\f\n /* Sometimes certain combinations of command options do not make\n    sense on a particular target machine.  You can define a macro\n    `OVERRIDE_OPTIONS' to take account of this.  This macro, if\n@@ -219,6 +218,8 @@ override_options ()\n     if (! strcmp (ix86_isa_string, processor_target_table[i].name))\n       {\n \tix86_isa = processor_target_table[i].processor;\n+\tif (ix86_cpu_string == (char *)0)\n+\t  ix86_cpu_string = processor_target_table[i].name;\n \tbreak;\n       }\n \n@@ -229,9 +230,6 @@ override_options ()\n       ix86_isa = PROCESSOR_DEFAULT;\n     }\n \n-  if (ix86_cpu_string == (char *)0)\n-    ix86_cpu_string = PROCESSOR_DEFAULT_STRING;\n-\n   for (j = 0; j < ptt_size; j++)\n     if (! strcmp (ix86_cpu_string, processor_target_table[j].name))\n       {\n@@ -293,6 +291,9 @@ override_options ()\n     }\n   else\n     i386_align_funcs = def_align;\n+\n+  if (TARGET_OMIT_LEAF_FRAME_POINTER)\t/* keep nonleaf frame pointers */\n+    flag_omit_frame_pointer = 1;\n }\n \f\n /* A C statement (sans semicolon) to choose the order in which to\n@@ -1690,41 +1691,62 @@ asm_output_function_prefix (file, name)\n   xops[0] = pic_offset_table_rtx;\n   xops[1] = stack_pointer_rtx;\n \n+  /* deep branch prediction favors having a return for every call */\n   if (pic_reg_used && TARGET_DEEP_BRANCH_PREDICTION)\n     {\n+      if (pic_label_rtx == 0)\n       pic_label_rtx = (rtx) gen_label_rtx ();\n       ASM_OUTPUT_INTERNAL_LABEL (file, \"L\", CODE_LABEL_NUMBER (pic_label_rtx));\n       output_asm_insn (\"movl (%1),%0\", xops);\n       output_asm_insn (\"ret\", xops);\n     }\n }\n \n-/* This function generates the assembly code for function entry.\n-   FILE is an stdio stream to output the code to.\n-   SIZE is an int: how many units of temporary storage to allocate. */\n+/* Set up the stack and frame (if desired) for the function.  */\n \n void\n function_prologue (file, size)\n      FILE *file;\n      int size;\n+{\n+}\n+\n+/* This function generates the assembly code for function entry.\n+   FILE is an stdio stream to output the code to.\n+   SIZE is an int: how many units of temporary storage to allocate. */\n+\n+void\n+ix86_expand_prologue ()\n {\n   register int regno;\n   int limit;\n   rtx xops[4];\n   int pic_reg_used = flag_pic && (current_function_uses_pic_offset_table\n \t\t\t\t  || current_function_uses_const_pool);\n+  long tsize = get_frame_size ();\n \n   xops[0] = stack_pointer_rtx;\n   xops[1] = frame_pointer_rtx;\n-  xops[2] = GEN_INT (size);\n+  xops[2] = GEN_INT (tsize);\n   if (frame_pointer_needed)\n     {\n-      output_asm_insn (\"push%L1 %1\", xops);\n-      output_asm_insn (AS2 (mov%L0,%0,%1), xops);\n+      emit_insn (gen_rtx (SET, 0,\n+\t\t\t  gen_rtx (MEM, SImode,\n+\t\t\t\t   gen_rtx (PRE_DEC, SImode, stack_pointer_rtx)),\n+\t\t\t  frame_pointer_rtx));\n+      emit_move_insn (xops[1], xops[0]);\n+/*      output_asm_insn (\"push%L1 %1\", xops); */\n+/*      output_asm_insn (AS2 (mov%L0,%0,%1), xops); */\n     }\n \n-  if (size)\n-    output_asm_insn (AS2 (sub%L0,%2,%0), xops);\n+  if (tsize)\n+    emit_insn (gen_rtx (SET, SImode,\n+\t\t\t  xops[0],\n+\t\t\t  gen_rtx (MINUS, SImode,\n+\t\t\t\t   xops[0],\n+\t\t\t\t   xops[2])));\n+\n+/*    output_asm_insn (AS2 (sub%L0,%2,%0), xops);*/\n \n   /* Note If use enter it is NOT reversed args.\n      This one is not reversed from intel!!\n@@ -1741,40 +1763,68 @@ function_prologue (file, size)\n \t|| (regno == PIC_OFFSET_TABLE_REGNUM && pic_reg_used))\n       {\n \txops[0] = gen_rtx (REG, SImode, regno);\n-\toutput_asm_insn (\"push%L0 %0\", xops);\n+\temit_insn (gen_rtx (SET, 0,\n+\t\t\t    gen_rtx (MEM, SImode,\n+\t\t\t\t     gen_rtx (PRE_DEC, SImode, stack_pointer_rtx)),\n+\t\t\t  xops[0]));\n+/*\toutput_asm_insn (\"push%L0 %0\", xops);*/\n       }\n \n-  if (pic_reg_used && TARGET_PENTIUMPRO)\n+  if (pic_reg_used && TARGET_DEEP_BRANCH_PREDICTION)\n     {\n       xops[0] = pic_offset_table_rtx;\n+      if (pic_label_rtx == 0)\n+\tpic_label_rtx = (rtx) gen_label_rtx ();\n       xops[1] = pic_label_rtx;\n \n-      output_asm_insn (AS1 (call,%P1), xops);\n-      output_asm_insn (\"addl $_GLOBAL_OFFSET_TABLE_,%0\", xops);\n+      emit_insn (gen_prologue_get_pc (xops[0], gen_rtx (CONST_INT, Pmode, CODE_LABEL_NUMBER(xops[1]))));\n+/*      output_asm_insn (AS1 (call,%P1), xops);*/\n+      emit_insn (gen_prologue_set_got (xops[0], \n+\t\t gen_rtx (SYMBOL_REF, Pmode, \"$_GLOBAL_OFFSET_TABLE_\"), \n+\t\t gen_rtx (CONST_INT, Pmode, CODE_LABEL_NUMBER(xops[1]))));\n+/*      output_asm_insn (\"addl $_GLOBAL_OFFSET_TABLE_,%0\", xops);*/\n     }\n-  else {\n+  else if (pic_reg_used)\n+    {\n     xops[0] = pic_offset_table_rtx;\n     xops[1] = (rtx) gen_label_rtx ();\n  \n-    output_asm_insn (AS1 (call,%P1), xops);\n-    ASM_OUTPUT_INTERNAL_LABEL (file, \"L\", CODE_LABEL_NUMBER (xops[1]));\n-    output_asm_insn (AS1 (pop%L0,%0), xops);\n-    output_asm_insn (\"addl $_GLOBAL_OFFSET_TABLE_+[.-%P1],%0\", xops);\n+      emit_insn (gen_prologue_get_pc (xops[0], gen_rtx (CONST_INT, Pmode, CODE_LABEL_NUMBER(xops[1]))));\n+      SCHED_GROUP_P (get_last_insn()) = 1;\n+/*      output_asm_insn (AS1 (call,%P1), xops);*/\n+/*      ASM_OUTPUT_INTERNAL_LABEL (file, \"L\", CODE_LABEL_NUMBER (xops[1]));*/\n+      emit_insn (gen_pop (xops[0]));\n+/*      output_asm_insn (AS1 (pop%L0,%0), xops);*/\n+      emit_insn (gen_prologue_set_got (xops[0], \n+\t\t gen_rtx (SYMBOL_REF, Pmode, \"$_GLOBAL_OFFSET_TABLE_\"), \n+\t\t gen_rtx (CONST_INT, Pmode, CODE_LABEL_NUMBER (xops[1]))));\n+/*      output_asm_insn (\"addl $_GLOBAL_OFFSET_TABLE_+[.-%P1],%0\", xops);*/\n   } \n }\n \n+/* Restore function stack, frame, and registers. */ \n+\n+void\n+function_epilogue (file, size)\n+     FILE *file;\n+     int size;\n+{\n+}\n+\n /* Return 1 if it is appropriate to emit `ret' instructions in the\n    body of a function.  Do this only if the epilogue is simple, needing a\n    couple of insns.  Prior to reloading, we can't tell how many registers\n-   must be saved, so return 0 then.\n+   must be saved, so return 0 then.  Return 0 if there is no frame \n+   marker to de-allocate.\n \n    If NON_SAVING_SETJMP is defined and true, then it is not possible\n    for the epilogue to be simple, so return 0.  This is a special case\n-   since NON_SAVING_SETJMP will not cause regs_ever_live to change until\n-   final, but jump_optimize may need to know sooner if a `return' is OK.  */\n+   since NON_SAVING_SETJMP will not cause regs_ever_live to change\n+   until final, but jump_optimize may need to know sooner if a\n+   `return' is OK.  */\n \n int\n-simple_386_epilogue ()\n+ix86_can_use_return_insn_p ()\n {\n   int regno;\n   int nregs = 0;\n@@ -1805,16 +1855,15 @@ simple_386_epilogue ()\n    SIZE is an int: how many units of temporary storage to deallocate. */\n \n void\n-function_epilogue (file, size)\n-     FILE *file;\n-     int size;\n+ix86_expand_epilogue ()\n {\n   register int regno;\n   register int nregs, limit;\n   int offset;\n   rtx xops[3];\n   int pic_reg_used = flag_pic && (current_function_uses_pic_offset_table\n \t\t\t\t  || current_function_uses_const_pool);\n+  long tsize = get_frame_size ();\n \n   /* Compute the number of registers to pop */\n \n@@ -1838,24 +1887,26 @@ function_epilogue (file, size)\n      leal, this is faster.  For now restore multiple registers the old\n      way. */\n \n-  offset = -size - (nregs * UNITS_PER_WORD);\n+  offset = -tsize - (nregs * UNITS_PER_WORD);\n \n   xops[2] = stack_pointer_rtx;\n \n   if (nregs > 1 || ! frame_pointer_needed)\n     {\n       if (frame_pointer_needed)\n \t{\n-\t  xops[0] = adj_offsettable_operand (AT_BP (Pmode), offset);\n-\t  output_asm_insn (AS2 (lea%L2,%0,%2), xops);\n+\t  xops[0] = adj_offsettable_operand (AT_BP (QImode), offset);\n+\t  emit_insn (gen_movsi_lea (xops[2], XEXP (xops[0], 0)));\n+/*\t  output_asm_insn (AS2 (lea%L2,%0,%2), xops);*/\n \t}\n \n       for (regno = 0; regno < limit; regno++)\n \tif ((regs_ever_live[regno] && ! call_used_regs[regno])\n \t    || (regno == PIC_OFFSET_TABLE_REGNUM && pic_reg_used))\n \t  {\n \t    xops[0] = gen_rtx (REG, SImode, regno);\n-\t    output_asm_insn (\"pop%L0 %0\", xops);\n+\t    emit_insn (gen_pop (xops[0]));\n+/*\t    output_asm_insn (\"pop%L0 %0\", xops);*/\n \t  }\n     }\n   else\n@@ -1865,7 +1916,8 @@ function_epilogue (file, size)\n \t{\n \t  xops[0] = gen_rtx (REG, SImode, regno);\n \t  xops[1] = adj_offsettable_operand (AT_BP (Pmode), offset);\n-\t  output_asm_insn (AS2 (mov%L0,%1,%0), xops);\n+\t  emit_move_insn (xops[0], xops[1]);\n+/*\t  output_asm_insn (AS2 (mov%L0,%1,%0), xops);*/\n \t  offset += 4;\n \t}\n \n@@ -1874,20 +1926,29 @@ function_epilogue (file, size)\n       /* If not an i386, mov & pop is faster than \"leave\". */\n \n       if (TARGET_USE_LEAVE)\n-\toutput_asm_insn (\"leave\", xops);\n+\temit_insn (gen_leave());\n+/*\toutput_asm_insn (\"leave\", xops);*/\n       else\n \t{\n \t  xops[0] = frame_pointer_rtx;\n-\t  output_asm_insn (AS2 (mov%L2,%0,%2), xops);\n-\t  output_asm_insn (\"pop%L0 %0\", xops);\n+\t  xops[1] = stack_pointer_rtx;\n+\t  emit_move_insn (xops[1], xops[0]); /* final ignores this */\n+/*\t  output_asm_insn (AS2 (mov%L2,%0,%2), xops);*/\n+\t  emit_insn (gen_pop (xops[0]));\n+/*\t  output_asm_insn (\"pop%L0 %0\", xops);*/\n \t}\n     }\n-  else if (size)\n+  else if (tsize)\n     {\n       /* If there is no frame pointer, we must still release the frame. */\n \n-      xops[0] = GEN_INT (size);\n-      output_asm_insn (AS2 (add%L2,%0,%2), xops);\n+      xops[0] = GEN_INT (tsize);\n+      emit_insn (gen_rtx (SET, SImode,\n+\t\t\t  xops[2],\n+\t\t\t  gen_rtx (PLUS, SImode,\n+\t\t\t\t   xops[2],\n+\t\t\t\t   xops[0])));\n+/*      output_asm_insn (AS2 (add%L2,%0,%2), xops);*/\n     }\n \n #ifdef FUNCTION_BLOCK_PROFILER_EXIT\n@@ -1909,15 +1970,24 @@ function_epilogue (file, size)\n \t{\n \t  /* ??? Which register to use here? */\n \t  xops[0] = gen_rtx (REG, SImode, 2);\n-\t  output_asm_insn (\"pop%L0 %0\", xops);\n-\t  output_asm_insn (AS2 (add%L2,%1,%2), xops);\n-\t  output_asm_insn (\"jmp %*%0\", xops);\n+\t  emit_insn (gen_pop (xops[0]));\n+/*\t  output_asm_insn (\"pop%L0 %0\", xops);*/\n+\t  emit_insn (gen_rtx (SET, SImode,\n+\t\t\t      xops[2],\n+\t\t\t      gen_rtx (PLUS, SImode,\n+\t\t\t\t       xops[1],\n+\t\t\t\t       xops[2])));\n+/*\t  output_asm_insn (AS2 (add%L2,%1,%2), xops);*/\n+\t  emit_jump_insn (xops[0]);\n+/*\t  output_asm_insn (\"jmp %*%0\", xops);*/\n \t}\n       else\n-\t  output_asm_insn (\"ret %1\", xops);\n+\temit_jump_insn (gen_return_internal ());\n+/*\t  output_asm_insn (\"ret %1\", xops);*/\n     }\n   else\n-    output_asm_insn (\"ret\", xops);\n+/*    output_asm_insn (\"ret\", xops);*/;\n+ emit_jump_insn (gen_return_internal ());\n }\n \n \f"}]}