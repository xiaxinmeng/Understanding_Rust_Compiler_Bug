{"sha": "35d965d5c95e8c50c9cc5220f03db1fe774f78f4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzVkOTY1ZDVjOTVlOGM1MGM5Y2M1MjIwZjAzZGIxZmU3NzRmNzhmNA==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1991-12-06T02:11:44Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1991-12-06T02:11:44Z"}, "message": "Initial revision\n\nFrom-SVN: r103", "tree": {"sha": "1dd1652b8b1970266e9898c1252ad5f5952c0c56", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1dd1652b8b1970266e9898c1252ad5f5952c0c56"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/35d965d5c95e8c50c9cc5220f03db1fe774f78f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35d965d5c95e8c50c9cc5220f03db1fe774f78f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35d965d5c95e8c50c9cc5220f03db1fe774f78f4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35d965d5c95e8c50c9cc5220f03db1fe774f78f4/comments", "author": null, "committer": null, "parents": [{"sha": "93980385e675fa6f9cfaa6583ecc86cf12245838", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93980385e675fa6f9cfaa6583ecc86cf12245838", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93980385e675fa6f9cfaa6583ecc86cf12245838"}], "stats": {"total": 1549, "additions": 1549, "deletions": 0}, "files": [{"sha": "547919c8042662e36cc93cd003d0f313d90751a7", "filename": "gcc/config/arm/arm.h", "status": "added", "additions": 1309, "deletions": 0, "changes": 1309, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35d965d5c95e8c50c9cc5220f03db1fe774f78f4/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35d965d5c95e8c50c9cc5220f03db1fe774f78f4/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=35d965d5c95e8c50c9cc5220f03db1fe774f78f4", "patch": "@@ -0,0 +1,1309 @@\n+/* Definitions of target machine for GNU compiler, for Acorn RISC Machine.\n+   Copyright (C) 1991 Free Software Foundation, Inc.\n+   Contributed by Pieter `Tiggr' Schoenmakers (rcpieter@win.tue.nl)\n+              and Martin Simmons (@harleqn.co.uk).\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* Sometimes the directive `riscos' is check.  This does not imply that this\n+   tm file can be used unchanged to build a GCC for RISC OS.\n+   (Since in fact, it can't.)  */\n+\n+extern void output_prologue ();\n+extern void output_epilogue ();\n+extern char *arm_output_asm_insn ();\n+extern char *arm_output_llc ();\n+extern char *output_add_immediate ();\n+extern char *output_call ();\n+extern char *output_move_double ();\n+extern char *output_mov_double_fpu_from_arm ();\n+extern char *output_mov_double_arm_from_fpu ();\n+extern char *output_mov_immediate ();\n+extern char *output_multi_immediate ();\n+extern char *output_shifted_move ();\n+\f\n+/* Translation to find startup files.  On RISCiX boxes, gcrt0.o is in\n+   /usr/lib.  */\n+#define STARTFILE_SPEC  \\\n+  \"%{pg:/usr/lib/gcrt0.o%s}%{!pg:%{p:mcrt0.o%s}%{!p:crt0.o%s}}\"\n+\n+#ifdef riscos\n+#define CPP_PREDEFINES  \"-Darm -Driscos\"\n+#else\n+#define CPP_PREDEFINES  \"-Darm -Driscix -Dunix\"\n+#endif\n+\f\n+/* Run-time Target Specification.  */\n+#define TARGET_VERSION  \\\n+  fputs (\" (ARM/RISCiX)\", stderr);\n+\n+/* Run-time compilation parameters selecting different hardware subsets.\n+   On the ARM, misuse it in a different way.  */\n+extern int target_flags;\n+\n+/* Nonzero if the function prologue (and epilogue) should obey\n+   the ARM Procedure Call Standard.  */\n+#define TARGET_APCS\t(target_flags & 1)\n+\n+/* Nonzero if the function prologue should output the function name to enable\n+   the post mortem debugger to print a backtrace (very useful on RISCOS,\n+   unused on RISCiX).  Specifying this flag also enables -mapcs.\n+   XXX Must still be implemented in the prologue.  */\n+#define TARGET_POKE_FUNCTION_NAME\t(target_flags & 2)\n+\n+/* Nonzero if floating point instructions are emulated by the FPE, in which\n+   case instruction scheduling becomes very uninteresting.  */\n+#define TARGET_FPE\t(target_flags & 4)\n+\n+#define TARGET_SWITCHES  \\\n+{                         \t\t\t\\\n+  {\"apcs\",\t\t 1},\t\t\t\\\n+  {\"poke-function-name\", 2},\t\t\t\\\n+  {\"fpe\",\t\t 4},\t\t\t\\\n+  {\"\",   \t\t TARGET_DEFAULT }\t\\\n+}\n+\n+#define TARGET_DEFAULT  0\n+\n+#define TARGET_MEM_FUNCTIONS 1\n+\n+/* OVERRIDE_OPTIONS takes care of the following:\n+   - if -mpoke-function-name, then -mapcs.\n+   - if doing debugging, then -mapcs; if RISCOS, then -mpoke-function-name.\n+   - if floating point is done by emulation, forget about instruction\n+     scheduling.  Note that this only saves compilation time; it doesn't\n+     matter for the final code.  */\n+#ifdef riscos\n+#define TARGET_WHEN_DEBUGING  3\n+#else\n+#define TARGET_WHEN_DEBUGING  1\n+#endif\n+\n+#define OVERRIDE_OPTIONS  \\\n+{\t\t\t\t\t\t\t\t\\\n+  if (write_symbols != NO_DEBUG)\t\t\t\t\\\n+    target_flags |= TARGET_WHEN_DEBUGING;\t\t\t\\\n+  else if (TARGET_POKE_FUNCTION_NAME)\t\t\t\t\\\n+    target_flags |= 1;\t\t\t\t\t\t\\\n+  if (TARGET_FPE)\t\t\t\t\t\t\\\n+    flag_schedule_insns = flag_schedule_insns_after_reload = 0;\t\\\n+}\n+\n+/* Omitting the frame pointer is a very good idea on the ARM, especially if\n+   not TARGET_APCS, in which case all that pushing on function entry isn't\n+   mandatory anymore.  */\n+#define OPTIMIZATION_OPTIONS(OPTIMIZE)  \\\n+{\t\t\t\t\t\\\n+  if (OPTIMIZE)\t\t\t\t\\\n+    flag_omit_frame_pointer = 1;\t\\\n+}\n+\f\n+/* Target machine storage Layout.  */\n+\n+/* Define this if most significant bit is lowest numbered\n+   in instructions that operate on numbered bit-fields.  */\n+#define BITS_BIG_ENDIAN  0\n+\n+/* Define this if most significant byte of a word is the lowest numbered.  */\n+#define BYTES_BIG_ENDIAN  0\n+\n+/* Define this if most significant word of a multiword number is the lowest\n+   numbered.  */\n+#define WORDS_BIG_ENDIAN  0\n+\n+/* Number of bits in an addressible storage unit */\n+#define BITS_PER_UNIT  8\n+\n+#define BITS_PER_WORD  32\n+\n+#define UNITS_PER_WORD\t4\n+\n+#define POINTER_SIZE  32\n+\n+#define PARM_BOUNDARY  \t32\n+\n+#define STACK_BOUNDARY  32\n+\n+#define FUNCTION_BOUNDARY  32\n+\n+#define EMPTY_FIELD_BOUNDARY  32\n+\n+#define BIGGEST_ALIGNMENT  32\n+\n+#define STRICT_ALIGNMENT 1\n+\n+/* Define number of bits in most basic integer type.\n+   (If undefined, default is BITS_PER_WORD).  */\n+/* #define INT_TYPE_SIZE */\n+\f\n+/* Standard register usage.  */\n+\n+/* Register allocation in ARM Procedure Call Standard (as used on RISCiX):\n+   (S - saved over call).\n+\n+\tr0\t   *\targument word/integer result\n+\tr1-r3\t\targument word\n+\n+\tr4-r8\t     S\tregister variable\n+\tr9\t     S\t(rfp) register variable (real frame pointer)\n+\n+\tr10  \t   F S\t(sl) stack limit (not currently used)\n+\tr11 \t   F S\t(fp) argument pointer\n+\tr12\t\t(ip) temp workspace\n+\tr13  \t   F S\t(sp) lower end of current stack frame\n+\tr14\t\t(lr) link address/workspace\n+\tr15\t   F\t(pc) program counter\n+\n+\tf0\t\tfloating point result\n+\tf1-f3\t\tfloating point scratch\n+\n+\tf4-f7\t     S\tfloating point variable\n+\n+   *: See CONDITIONAL_REGISTER_USAGE  */\n+\n+/* The number of hard registers is 16 ARM + 8 FPU.  */\n+#define FIRST_PSEUDO_REGISTER  24\n+\n+/* 1 for registers that have pervasive standard uses\n+   and are not available for the register allocator.  */\n+#define FIXED_REGISTERS  \\\n+{                        \\\n+  0,0,0,0,0,0,0,0,\t \\\n+  0,0,1,1,0,1,0,1,\t \\\n+  0,0,0,0,0,0,0,0\t \\\n+}\n+\n+/* 1 for registers not available across function calls.\n+   These must include the FIXED_REGISTERS and also any\n+   registers that can be used without being saved.\n+   The latter must include the registers where values are returned\n+   and the register where structure-value addresses are passed.\n+   Aside from that, you can include as many other registers as you like.  */\n+#define CALL_USED_REGISTERS  \\\n+{                            \\\n+  1,1,1,1,0,0,0,0,\t     \\\n+  0,0,1,1,1,1,1,1,\t     \\\n+  1,1,1,1,0,0,0,0\t     \\\n+}\n+\n+/* If doing stupid life analysis, avoid a bug causing a return value r0 to be\n+   trampled.  This effectively reduces the number of available registers by 1.\n+   XXX It is a hack, I know.\n+   XXX Is this still needed?  */\n+#define CONDITIONAL_REGISTER_USAGE  \\\n+{\t\t\t\\\n+  if (obey_regdecls)\t\\\n+    fixed_regs[0] = 1;\t\\\n+}\n+\n+/* Return number of consecutive hard regs needed starting at reg REGNO\n+   to hold something of mode MODE.\n+   This is ordinarily the length in words of a value of mode MODE\n+   but can be less for certain modes in special long registers.\n+\n+   On the ARM regs are UNITS_PER_WORD bits wide; FPU regs can hold any FP\n+   mode.  */\n+#define HARD_REGNO_NREGS(REGNO, MODE)  \\\n+    ((REGNO) >= 16 ? 1\t\t\t\t\t\t\t\\\n+     : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n+\n+/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n+   This is TRUE for ARM regs since they can hold anything, and TRUE for FPU\n+   regs holding FP.  */\n+#define HARD_REGNO_MODE_OK(REGNO, MODE)  \\\n+  ((REGNO) < 16 || GET_MODE_CLASS (MODE) == MODE_FLOAT)\n+\n+/* Value is 1 if it is a good idea to tie two pseudo registers\n+   when one has mode MODE1 and one has mode MODE2.\n+   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n+   for any hard reg, then this must be 0 for correct output.  */\n+#define MODES_TIEABLE_P(MODE1, MODE2)  \\\n+  (((MODE1) == SFmode || (MODE1) == DFmode)      \\\n+   == ((MODE2) == SFmode || (MODE2) == DFmode))\n+\n+/* Specify the registers used for certain standard purposes.\n+   The values of these macros are register numbers.  */\n+\n+/* Define this if the program counter is overloaded on a register.  */\n+#define PC_REGNUM\t\t15\n+\n+/* Register to use for pushing function arguments.  */\n+#define STACK_POINTER_REGNUM\t13\n+\n+/* Base register for access to local variables of the function.  */\n+#define FRAME_POINTER_REGNUM\t9\n+\n+/* Value should be nonzero if functions must have frame pointers.\n+   Zero means the frame pointer need not be set up (and parms may be accessed\n+   via the stack pointer) in functions that seem suitable.  */\n+#define FRAME_POINTER_REQUIRED\t0\n+\n+/* Base register for access to arguments of the function.  */\n+#define ARG_POINTER_REGNUM\t11\n+\n+/* The native (Norcroft) Pascal compiler for the ARM passes the static chain\n+   as an invisible last argument (possible since varargs don't exist in\n+   Pascal), so the following is not true.  */\n+#define STATIC_CHAIN_REGNUM\t8\n+\n+/* Register in which address to store a structure value\n+   is passed to a function.  */\n+#define STRUCT_VALUE_REGNUM\t0\n+\n+/* The order in which register should be allocated.  It is good to use ip\n+   since no saving is required (though calls clobber it).  It is quite good to\n+   use lr since other calls may clobber it anyway.  */\n+#define REG_ALLOC_ORDER  \\\n+{                                   \\\n+    0, 1, 2, 3, 12, 14,\t4, 5,       \\\n+    6, 7, 8, 10, 9, 11, 13, 15,     \\\n+    16, 17, 18, 19, 20, 21, 22, 23  \\\n+}\n+\f\n+/* Register and constant classes.  */\n+\n+/* Register classes: all ARM regs or all FPU regs---simple! */\n+enum reg_class\n+{\n+  NO_REGS,\n+  FPU_REGS,\n+  GENERAL_REGS,\n+  ALL_REGS,\n+  LIM_REG_CLASSES\n+};\n+\n+#define N_REG_CLASSES  (int) LIM_REG_CLASSES\n+\n+/* Give names of register classes as strings for dump file.   */\n+#define REG_CLASS_NAMES  \\\n+{\t\t\t\\\n+  \"NO_REGS\",\t\t\\\n+  \"FPU_REGS\",\t\t\\\n+  \"GENERAL_REGS\",\t\\\n+  \"ALL_REGS\",\t\t\\\n+}\n+\n+/* Define which registers fit in which classes.\n+   This is an initializer for a vector of HARD_REG_SET\n+   of length N_REG_CLASSES.  */\n+#define REG_CLASS_CONTENTS  \\\n+{\t\t\t\t\\\n+  0x000000,  /* NO_REGS  */\t\\\n+  0xFF0000,  /* FPU_REGS */\t\\\n+  0x00FFFF,  /* GENERAL_REGS */\t\\\n+  0xFFFFFF   /* ALL_REGS */\t\\\n+}\n+\n+/* The same information, inverted:\n+   Return the class number of the smallest class containing\n+   reg number REGNO.  This could be a conditional expression\n+   or could index an array.  */\n+#define REGNO_REG_CLASS(REGNO)  \\\n+  ((REGNO) < 16 ? GENERAL_REGS : FPU_REGS)\n+\n+/* The class value for index registers, and the one for base regs.  */\n+#define INDEX_REG_CLASS  GENERAL_REGS\n+#define BASE_REG_CLASS\tGENERAL_REGS\n+\n+/* Get reg_class from a letter such as appears in the machine description.\n+   We only need constraint `f' for FPU_REGS (`r' == GENERAL_REGS).  */\n+#define REG_CLASS_FROM_LETTER(C)  \\\n+  ((C)=='f' ? FPU_REGS : NO_REGS)\n+\n+/* The letters I, J, K, L and M in a register constraint string\n+   can be used to stand for particular ranges of immediate operands.\n+   This macro defines what the ranges are.\n+   C is the letter, and VALUE is a constant value.\n+   Return 1 if VALUE is in the range specified by C.\n+\tI: immediate arithmetic operand (i.e. 8 bits shifted as requried).\n+\tJ: valid indexing constants.  */\n+#define CONST_OK_FOR_LETTER_P(VALUE, C)  \\\n+  ((C) == 'I' ? const_ok_for_arm (VALUE) :\t\t\\\n+   (C) == 'J' ? (abs (VALUE) < 4096) : 0)\n+\n+/* Constaint letter 'G' for the FPU immediate constants. */\n+#define CONST_DOUBLE_OK_FOR_LETTER_P(X,C)\t\\\n+    ((C) == 'G' ? const_double_rtx_ok_for_fpu (X) : 0)\n+\n+/* Given an rtx X being reloaded into a reg required to be\n+   in class CLASS, return the class of reg to actually use.\n+   In general this is just CLASS; but on some machines\n+   in some cases it is preferable to use a more restrictive class.  */\n+#define PREFERRED_RELOAD_CLASS(X, CLASS)  (CLASS)\n+\n+/* Return the maximum number of consecutive registers\n+   needed to represent mode MODE in a register of class CLASS.\n+   ARM regs are UNITS_PER_WORD bits while FPU regs can hold any FP mode */\n+#define CLASS_MAX_NREGS(CLASS, MODE)  \\\n+    ((CLASS) == FPU_REGS ? 1\t\t\t\t\t       \\\n+     : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n+\n+/* Moves between FPU_REGS and GENERAL_REGS are two insns.  */\n+#define REGISTER_MOVE_COST(CLASS1, CLASS2)  \\\n+  ((((CLASS1) == FPU_REGS && (CLASS2) != FPU_REGS)\t\\\n+    || ((CLASS2) == FPU_REGS && (CLASS1) != FPU_REGS))\t\\\n+   ? 4 : 2)\n+\f\n+/* Stack layout; function entry, exit and calling.  */\n+\n+/* Define this if pushing a word on the stack\n+   makes the stack pointer a smaller address.  */\n+#define STACK_GROWS_DOWNWARD  1\n+\n+/* Define this if the nominal address of the stack frame\n+   is at the high-address end of the local variables;\n+   that is, each additional local variable allocated\n+   goes at a more negative offset in the frame.  */\n+#define FRAME_GROWS_DOWNWARD 1\n+\n+/* Offset within stack frame to start allocating local variables at.\n+   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n+   first local allocated.  Otherwise, it is the offset to the BEGINNING\n+   of the first local allocated.  */\n+#define STARTING_FRAME_OFFSET  0\n+\n+/* If we generate an insn to push BYTES bytes,\n+   this says how many the stack pointer really advances by.  */\n+#define PUSH_ROUNDING(NPUSHED)  (((NPUSHED) + 3) & ~3)\n+\n+/* Offset of first parameter from the argument pointer register value.  */\n+#define FIRST_PARM_OFFSET(FNDECL)  4\n+\n+/* Value is the number of byte of arguments automatically\n+   popped when returning from a subroutine call.\n+   FUNTYPE is the data type of the function (as a tree),\n+   or for a library call it is an identifier node for the subroutine name.\n+   SIZE is the number of bytes of arguments passed on the stack.\n+\n+   On the ARM, the caller does not pop any of its arguments that were passed\n+   on the stack.  */\n+#define RETURN_POPS_ARGS(FUNTYPE, SIZE)  0\n+\n+/* Define how to find the value returned by a function.\n+   VALTYPE is the data type of the value (as a tree).\n+   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n+   otherwise, FUNC is 0.  */\n+#define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n+  (GET_MODE_CLASS (TYPE_MODE (VALTYPE)) == MODE_FLOAT  \\\n+   ? gen_rtx (REG, TYPE_MODE (VALTYPE), 16)            \\\n+   : gen_rtx (REG, TYPE_MODE (VALTYPE), 0))\n+\n+/* Define how to find the value returned by a library function\n+   assuming the value has mode MODE.  */\n+#define LIBCALL_VALUE(MODE)  \\\n+  (GET_MODE_CLASS (MODE) == MODE_FLOAT  \\\n+   ? gen_rtx (REG, MODE, 16)\t\t\\\n+   : gen_rtx (REG, MODE, 0))\n+\n+/* 1 if N is a possible register number for a function value.\n+   On the ARM, only r0 and f0 can return results.  */\n+#define FUNCTION_VALUE_REGNO_P(REGNO)  \\\n+  ((REGNO) == 0 || (REGNO) == 16)\n+\n+/* Define where to put the arguments to a function.\n+   Value is zero to push the argument on the stack,\n+   or a hard register in which to store the argument.\n+\n+   MODE is the argument's machine mode.\n+   TYPE is the data type of the argument (as a tree).\n+    This is null for libcalls where that information may\n+    not be available.\n+   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n+    the preceding args and about the function being called.\n+   NAMED is nonzero if this argument is a named parameter\n+    (otherwise it is an extra parameter matching an ellipsis).\n+\n+   On the ARM, normally the first 16 bytes are passed in registers r0-r3; all\n+   other arguments are passed on the stack.  If (NAMED == 0) (which happens\n+   only in assign_parms, since SETUP_INCOMING_VARARGS is defined), say it is\n+   passed in the stack (function_prologue will indeed make it pass in the\n+   stack if necessary).  */\n+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED)  \\\n+  ((NAMED)\t\t\t\t\t\t\\\n+   ? ((CUM) >= 16 ? 0 : gen_rtx (REG, MODE, (CUM) / 4))\t\\\n+   : 0)\n+\n+/* For an arg passed partly in registers and partly in memory,\n+   this is the number of registers used.\n+   For args passed entirely in registers or entirely in memory, zero.  */\n+#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED)  \\\n+  ((CUM) < 16 && 16 < (CUM) + ((MODE) != BLKmode            \\\n+\t\t\t       ? GET_MODE_SIZE (MODE)       \\\n+\t\t\t       : int_size_in_bytes (TYPE))  \\\n+   ? 4 - (CUM) / 4 : 0)\n+\n+/* A C type for declaring a variable that is used as the first argument of\n+   `FUNCTION_ARG' and other related values.  For some target machines, the\n+   type `int' suffices and can hold the number of bytes of argument so far.\n+\n+   On the ARM, this is the number of bytes of arguments scanned so far.  */\n+#define CUMULATIVE_ARGS  int\n+\n+/* Initialize a variable CUM of type CUMULATIVE_ARGS\n+   for a call to a function whose data type is FNTYPE.\n+   For a library call, FNTYPE is 0.\n+   On the ARM, the offset starts at 0.  */\n+#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME)  \\\n+  ((CUM) = (((FNTYPE) && aggregate_value_p (FNTYPE)) ? 4 : 0))\n+\n+/* Update the data in CUM to advance over an argument\n+   of mode MODE and data type TYPE.\n+   (TYPE is null for libcalls where that information may not be available.)  */\n+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)  \\\n+  (CUM) += ((MODE) != BLKmode                       \\\n+\t    ? (GET_MODE_SIZE (MODE) + 3) & ~3       \\\n+\t    : (int_size_in_bytes (TYPE) + 3) & ~3)  \\\n+\n+/* 1 if N is a possible register number for function argument passing.\n+   On the ARM, r0-r3 are used to pass args.  */\n+#define FUNCTION_ARG_REGNO_P(REGNO)  \\\n+  ((REGNO) >= 0 && (REGNO) <= 3)\n+\n+/* Perform any actions needed for a function that is receiving a variable\n+   number of arguments.  CUM is as above.  MODE and TYPE are the mode and type\n+   of the current parameter.  PRETEND_SIZE is a variable that should be set to\n+   the amount of stack that must be pushed by the prolog to pretend that our\n+   caller pushed it.\n+\n+   Normally, this macro will push all remaining incoming registers on the\n+   stack and set PRETEND_SIZE to the length of the registers pushed.\n+\n+   On the ARM, PRETEND_SIZE is set in order to have the prologue push the last\n+   named arg and all anonymous args onto the stack.\n+   XXX I know the prologue shouldn't be pushing registers, but it is faster\n+   that way.  */\n+#define SETUP_INCOMING_VARARGS(CUM, MODE, TYPE, PRETEND_SIZE, NO_RTL)  \\\n+{\t\t\t\t\t\t\t\t\t\\\n+  extern int current_function_anonymous_args;\t\t\t\t\\\n+  current_function_anonymous_args = 1;\t\t\t\t\t\\\n+  if ((CUM) < 16)\t\t\t\t\t\t\t\\\n+    (PRETEND_SIZE) = 16 - (CUM);\t\t\t\t\t\\\n+}\n+\n+/* Generate assembly output for the start of a function.  */\n+#define FUNCTION_PROLOGUE(STREAM, SIZE)  \\\n+  output_prologue ((STREAM), (SIZE))\n+\n+/* Call the function profiler with a given profile label.  The Acorn compiler\n+   puts this BEFORE the prolog but gcc pust it afterwards.  The ``mov ip,lr''\n+   seems like a good idea to stick with cc convention.  ``prof'' doesn't seem\n+   to mind about this!  */\n+#define FUNCTION_PROFILER(STREAM,LABELNO)  \\\n+{\t\t\t\t\t\t\t\\\n+    fprintf(STREAM, \"\\tmov\\tip, lr\\n\");\t\t\t\\\n+    fprintf(STREAM, \"\\tbl\\tmcount\\n\");\t\t\t\\\n+    fprintf(STREAM, \"\\t.word\\tLP%d\\n\", (LABELNO));\t\\\n+    arm_increase_location (12);\t\t\t\t\\\n+}\n+\n+/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n+   the stack pointer does not matter.  The value is tested only in\n+   functions that have frame pointers.\n+   No definition is equivalent to always zero.\n+\n+   On the ARM, the function epilogue recovers the stack pointer from the\n+   frame.  */\n+#define EXIT_IGNORE_STACK 1\n+\n+/* Generate the assembly code for function exit. */\n+#define FUNCTION_EPILOGUE(STREAM, SIZE)  \\\n+  output_epilogue ((STREAM), (SIZE))\n+\n+/* Determine if the epilogue should be output as RTL.\n+   You should override this if you define FUNCTION_EXTRA_EPILOGUE.  */\n+/* #define USE_RETURN_INSN use_return_insn () */\n+\n+/* Store in the variable DEPTH the initial difference between the frame\n+   pointer reg contents and the stack pointer reg contents, as of the start of\n+   the function body.  This depends on the layout of the fixed parts of the\n+   stack frame and on how registers are saved.  */\n+#define INITIAL_FRAME_POINTER_OFFSET(DEPTH)  \\\n+  (DEPTH) = (get_frame_size () + 3) & ~3;\n+\n+/* Output assembler code for a block containing the constant parts\n+   of a trampoline, leaving space for the variable parts.\n+\n+   On the ARM, (if r8 is the static chain regnum, and remembering that\n+   referencing pc adds an offset of 8) the trampoline looks like:\n+\t   ldr \t\tr8, [pc, #0]\n+\t   ldr\t\tpc, [pc]\n+\t   .word\tstatic chain value\n+\t   .word\tfunction's address  */\n+#define TRAMPOLINE_TEMPLATE(FILE)  \\\n+{\t\t\t\t\t\t\\\n+  fprintf ((FILE), \"\\tldr\\tr8, [pc, #0]\\n\");\t\\\n+  fprintf ((FILE), \"\\tldr\\tpc, [pc, #0]\\n\");\t\\\n+  fprintf ((FILE), \"\\t.word\\t0\\n\");\t\t\\\n+  fprintf ((FILE), \"\\t.word\\t0\\n\");\t\t\\\n+}\n+\n+/* Length in units of the trampoline for entering a nested function.  */\n+#define TRAMPOLINE_SIZE  16\n+\n+/* Alignment required for a trampoline in units.  */\n+#define TRAMPOLINE_ALIGN  4\n+\n+/* Emit RTL insns to initialize the variable parts of a trampoline.\n+   FNADDR is an RTX for the address of the function's pure code.\n+   CXT is an RTX for the static chain value for the function.  */\n+#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)  \\\n+{\t\t\t\t\t\t\t\t\t\\\n+  emit_move_insn (gen_rtx (MEM, SImode, plus_constant ((TRAMP), 8)),\t\\\n+\t\t  (CXT));\t\t\t\t\t\t\\\n+  emit_move_insn (gen_rtx (MEM, SImode, plus_constant ((TRAMP), 12)),\t\\\n+\t\t  (FNADDR));\t\t\t\t\t\t\\\n+}\n+\n+/* Call the function profiler with a given profile label.  The Acorn compiler\n+   puts this BEFORE the prolog but gcc pust it afterwards.  The ``mov ip,lr''\n+   seems like a good idea to stick with cc convention.  ``prof'' doesn't seem\n+   to mind about this!  */\n+#define FUNCTION_PROFILER(STREAM,LABELNO)  \\\n+{\t\t\t\t\t\t\t\\\n+    fprintf(STREAM, \"\\tmov\\tip, lr\\n\");\t\t\t\\\n+    fprintf(STREAM, \"\\tbl\\tmcount\\n\");\t\t\t\\\n+    fprintf(STREAM, \"\\t.word\\tLP%d\\n\", (LABELNO));\t\\\n+    arm_increase_location (12);\t\t\t\t\\\n+}\n+\f\n+/* Addressing modes, and classification of registers for them.  */\n+\n+#define HAVE_POST_INCREMENT  1\n+#define HAVE_PRE_INCREMENT  1\n+#define HAVE_POST_DECREMENT  1\n+#define HAVE_PRE_DECREMENT  1\n+\n+/* Macros to check register numbers against specific register classes.  */\n+\n+/* These assume that REGNO is a hard or pseudo reg number.\n+   They give nonzero only if REGNO is a hard reg of the suitable class\n+   or a pseudo reg currently allocated to a suitable hard reg.\n+   Since they use reg_renumber, they are safe only once reg_renumber\n+   has been allocated, which happens in local-alloc.c.\n+\n+   On the ARM, don't allow the pc to be used.  */\n+#define REGNO_OK_FOR_BASE_P(REGNO)  \\\n+  ((REGNO) < 15 || (unsigned) reg_renumber[(REGNO)] < 15)\n+#define REGNO_OK_FOR_INDEX_P(REGNO)  \\\n+  REGNO_OK_FOR_BASE_P(REGNO)\n+\n+/* Maximum number of registers that can appear in a valid memory address.\n+   The addressing mode [ra,rb, <shift> rc] uses the greatest number of\n+   registers.  */\n+#define MAX_REGS_PER_ADDRESS 3\n+\n+/* Recognize any constant value that is a valid address.  */\n+/* XXX We can address any constant, eventually...  */\n+#if 0\n+#define CONSTANT_ADDRESS_P(X)\t\\\n+    ( GET_CODE(X) == LABEL_REF\t\\\n+  ||  GET_CODE(X) == SYMBOL_REF \\\n+  ||  GET_CODE(X) == CONST_INT\t\\\n+  ||  GET_CODE(X) == CONST )\n+#endif\n+\n+#define CONSTANT_ADDRESS_P(X)  \\\n+  (GET_CODE (X) == SYMBOL_REF && CONSTANT_POOL_ADDRESS_P (X))\n+\n+/* Nonzero if the constant value X is a legitimate general operand.\n+   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.\n+\n+   On the ARM, allow any integer (invalid ones are removed later by insn\n+   patterns), nice doubles and symbol_refs which refer to the function's\n+   constant pool XXX.  */\n+#define LEGITIMATE_CONSTANT_P(X)\t\t\t\t\\\n+  (GET_CODE (X) == CONST_INT\t\t\t\t\t\\\n+   || (GET_CODE (X) == CONST_DOUBLE\t\t\t\t\\\n+       &&  const_double_rtx_ok_for_fpu (X)))\n+#if 0\n+   || GET_CODE(X) == SYMBOL_REF && CONSTANT_POOL_ADDRESS_P(X))\n+#endif\n+\n+/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n+   and check its validity for a certain class.\n+   We have two alternate definitions for each of them.\n+   The usual definition accepts all pseudo regs; the other rejects\n+   them unless they have been allocated suitable hard regs.\n+   The symbol REG_OK_STRICT causes the latter definition to be used.  */\n+#ifndef REG_OK_STRICT\n+/* Nonzero if X is a hard reg that can be used as a base reg\n+   or if it is a pseudo reg.  */\n+#define REG_OK_FOR_BASE_P(X)  \\\n+  (REGNO (X) < 16 || REGNO (X) >= 24)\n+/* Nonzero if X is a hard reg that can be used as an index\n+   or if it is a pseudo reg.  */\n+#define REG_OK_FOR_INDEX_P(X)  \\\n+  REG_OK_FOR_BASE_P(X)\n+#define REG_OK_FOR_PRE_POST_P(X)  \\\n+  (REGNO (X) < 16 || REGNO (X) >= FIRST_PSEUDO_REGISTER)\n+#else\n+/* Nonzero if X is a hard reg that can be used as a base reg.  */\n+#define REG_OK_FOR_BASE_P(X)  REGNO_OK_FOR_BASE_P (REGNO (X))\n+/* Nonzero if X is a hard reg that can be used as an index.  */\n+#define REG_OK_FOR_INDEX_P(X)  REGNO_OK_FOR_INDEX_P (REGNO (X))\n+#define REG_OK_FOR_PRE_POST_P(X)  \\\n+  (REGNO (X) < 16 || (unsigned) reg_renumber[REGNO (X)] < 16)\n+#endif\n+\f\n+/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n+   that is a valid memory address for an instruction.\n+   The MODE argument is the machine mode for the MEM expression\n+   that wants to use this address.\n+\n+   The other macros defined here are used only in GO_IF_LEGITIMATE_ADDRESS.  */\n+#define BASE_REGISTER_RTX_P(X)  \\\n+  (GET_CODE (X) == REG && REG_OK_FOR_BASE_P (X))\n+\n+#define INDEX_REGISTER_RTX_P(X)  \\\n+  (GET_CODE (X) == REG && REG_OK_FOR_INDEX_P (X))\n+\n+/* A C statement (sans semicolon) to jump to LABEL for legitimate index RTXs\n+   used by the macro GO_IF_LEGITIMATE_ADDRESS.  Floating point indices can\n+   only be small constants. */\n+#define GO_IF_LEGITIMATE_INDEX(MODE, BASE_REGNO, INDEX, LABEL)  \\\n+do \\\n+{\t\t\t\t\t\t\t\t\t\t      \\\n+  int range;\t\t\t\t\t\t\t\t\t      \\\n+\t\t\t\t\t\t\t\t\t\t      \\\n+  if (GET_MODE_CLASS (MODE) == MODE_FLOAT)\t\t\t\t\t      \\\n+    range = 1024;\t\t\t\t\t\t\t\t      \\\n+  else\t\t\t\t\t\t\t\t\t\t      \\\n+    {\t\t\t\t\t\t\t\t\t\t      \\\n+      if (INDEX_REGISTER_RTX_P (INDEX))\t\t\t\t\t\t      \\\n+\tgoto LABEL;\t\t\t\t\t\t\t\t      \\\n+      if (GET_MODE_SIZE (MODE) <= 4  &&  GET_CODE (INDEX) == MULT)\t\t      \\\n+\t{\t\t\t\t\t\t\t\t\t      \\\n+\t  rtx xiop0 = XEXP (INDEX, 0);\t\t\t\t\t\t      \\\n+\t  rtx xiop1 = XEXP (INDEX, 1);\t\t\t\t\t\t      \\\n+\t  if (INDEX_REGISTER_RTX_P (xiop0) &&  power_of_two_operand (xiop1, SImode))  \\\n+\t    goto LABEL;\t\t\t\t\t\t\t\t      \\\n+\t  if (INDEX_REGISTER_RTX_P (xiop1) &&  power_of_two_operand (xiop0, SImode))  \\\n+\t    goto LABEL;\t\t\t\t\t\t\t\t      \\\n+\t}\t\t\t\t\t\t\t\t\t      \\\n+      range = 4096;\t\t\t\t\t\t\t\t      \\\n+    }\t\t\t\t\t\t\t\t\t\t      \\\n+\t\t\t\t\t\t\t\t\t\t      \\\n+    if (GET_CODE (INDEX) == CONST_INT && abs (INTVAL (INDEX)) < range)  \t      \\\n+      goto LABEL;\t\t\t\t\t\t\t\t      \\\n+} while (0)\n+\n+/* Jump to LABEL if X is a valid address RTX.  This must also take\n+   REG_OK_STRICT into account when deciding about valid registers, but it uses\n+   the above macros so we are in luck.  Allow REG, REG+REG, REG+INDEX,\n+   INDEX+REG, REG-INDEX, and non floating SYMBOL_REF to the constant pool.\n+   Allow REG-only and AUTINC-REG if handling TImode.  Other symbol refs must\n+   be forced though a static cell to ensure addressability.  */\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, LABEL)  \\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (BASE_REGISTER_RTX_P (X))\t\t\t\t\t\t\\\n+    goto LABEL;\t\t\t\t\t\t\t\t\\\n+  else if ((GET_CODE (X) == POST_INC || GET_CODE (X) == PRE_DEC)\t\\\n+\t   && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\\\n+\t   && REG_OK_FOR_PRE_POST_P (XEXP (X, 0)))\t\t\t\\\n+    goto LABEL;\t\t\t\t\t\t\t\t\\\n+  else if ((MODE) == TImode)\t\t\t\t\t\t\\\n+    ;\t\t\t\t\t\t\t\t\t\\\n+  else if (GET_CODE (X) == PLUS)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      rtx xop0 = XEXP(X,0);\t\t\t\t\t\t\\\n+      rtx xop1 = XEXP(X,1);\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      if (BASE_REGISTER_RTX_P (xop0))\t\t\t\t\t\\\n+\tGO_IF_LEGITIMATE_INDEX (MODE, REGNO (xop0), xop1, LABEL);\t\\\n+      else if (BASE_REGISTER_RTX_P (xop1))\t\t\t\t\\\n+\tGO_IF_LEGITIMATE_INDEX (MODE, REGNO (xop1), xop0, LABEL);\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else if (GET_CODE (X) == MINUS)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      rtx xop0 = XEXP (X,0);\t\t\t\t\t\t\\\n+      rtx xop1 = XEXP (X,1);\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      if (BASE_REGISTER_RTX_P (xop0))\t\t\t\t\t\\\n+\tGO_IF_LEGITIMATE_INDEX (MODE, -1, xop1, LABEL);\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else if (GET_MODE_CLASS (MODE) != MODE_FLOAT\t\t\t\t\\\n+\t   && GET_CODE (X) == SYMBOL_REF\t\t\t\t\\\n+\t   && CONSTANT_POOL_ADDRESS_P (X))\t\t\t\t\\\n+    goto LABEL;\t\t\t\t\t\t\t\t\\\n+  else if ((GET_CODE (X) == PRE_INC || GET_CODE (X) == POST_DEC)\t\\\n+\t   && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\\\n+\t   && REG_OK_FOR_PRE_POST_P (XEXP (X, 0)))\t\t\t\\\n+    goto LABEL;\t\t\t\t\t\t\t\t\\\n+}\n+\f\n+/* Try machine-dependent ways of modifying an illegitimate address\n+   to be legitimate.  If we find one, return the new, valid address.\n+   This macro is used in only one place: `memory_address' in explow.c.\n+\n+   OLDX is the address as it was before break_out_memory_refs was called.\n+   In some cases it is useful to look at this to decide what needs to be done.\n+\n+   MODE and WIN are passed so that this macro can use\n+   GO_IF_LEGITIMATE_ADDRESS.\n+\n+   It is always safe for this macro to do nothing.  It exists to recognize\n+   opportunities to optimize the output.\n+\n+   On the ARM, try to convert [REG, #BIGCONST]\n+   into ADD BASE, REG, #UPPERCONST and [BASE, #VALIDCONST],\n+   where VALIDCONST == 0 in case of TImode.  */\n+#define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)  \\\n+{\t\t\t\t\t\t        \t\t     \\\n+  if (GET_CODE (X) == PLUS)\t\t\t        \t\t     \\\n+    {\t\t\t\t\t\t        \t\t     \\\n+      rtx xop0 = XEXP (X, 0);\t\t\t        \t\t     \\\n+      rtx xop1 = XEXP (X, 1);\t\t\t        \t\t     \\\n+\t\t\t\t\t\t        \t\t     \\\n+      if (BASE_REGISTER_RTX_P (xop0) && GET_CODE (xop1) == CONST_INT)\t     \\\n+\t{\t\t\t\t\t        \t\t     \\\n+\t  int n = INTVAL (xop1);\t\t        \t\t     \\\n+\t  int low_n = ((MODE) == TImode ? 0\t        \t\t     \\\n+\t\t       : n >= 0 ? (n & 0xFFF) : -((-n) & 0xFFF));\t     \\\n+\t  rtx base_reg = gen_reg_rtx (SImode);\t        \t\t     \\\n+\t  rtx val = force_operand (gen_rtx (PLUS, SImode, xop0,\t\t     \\\n+\t\t\t\t\t    gen_rtx (CONST_INT,\t\t     \\\n+\t\t\t\t\t\t     VOIDmode, n - low_n)),  \\\n+\t\t\t\t   0);\t\t\t\t\t     \\\n+          emit_move_insn (base_reg, val);\t\t\t\t     \\\n+\t  (X) = (low_n == 0 ? base_reg\t\t\t\t\t     \\\n+\t\t : gen_rtx (PLUS, SImode, base_reg,\t\t\t     \\\n+\t\t\t    gen_rtx (CONST_INT, VOIDmode, low_n)));\t     \\\n+\t}\t\t\t\t\t\t\t\t     \\\n+      else if (BASE_REGISTER_RTX_P (xop1) && GET_CODE (xop0) == CONST_INT)   \\\n+\t{\t\t\t\t\t\t\t\t     \\\n+\t  int n = INTVAL (xop0);\t\t\t\t\t     \\\n+\t  int low_n = ((MODE) == TImode ? 0\t\t\t\t     \\\n+\t\t       : n >= 0 ? (n & 0xFFF) : -((-n) & 0xFFF));\t     \\\n+\t  rtx base_reg = gen_reg_rtx (SImode);\t\t\t\t     \\\n+\t  rtx val = force_operand (gen_rtx (PLUS, SImode, xop1,\t\t     \\\n+\t\t\t\t\t    gen_rtx (CONST_INT,\t\t     \\\n+\t\t\t\t\t\t     VOIDmode, n - low_n)),  \\\n+\t\t\t\t   0);\t\t\t\t\t     \\\n+\t  emit_move_insn (base_reg, val);\t\t\t\t     \\\n+\t  (X) = (low_n == 0 ? base_reg\t\t\t\t\t     \\\n+\t\t : gen_rtx (PLUS, SImode, base_reg,\t\t\t     \\\n+\t\t\t    gen_rtx (CONST_INT, VOIDmode, low_n)));\t     \\\n+\t}\t\t\t\t\t\t\t\t     \\\n+    }\t\t\t\t\t\t\t\t\t     \\\n+  if (memory_address_p (MODE, X))\t\t\t\t\t     \\\n+    goto win;\t\t\t\t\t\t\t\t     \\\n+}\n+\n+/* Go to LABEL if ADDR (a legitimate address expression)\n+   has an effect that depends on the machine mode it is used for.  */\n+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)  \\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (GET_CODE(ADDR) == PRE_DEC || GET_CODE(ADDR) == POST_DEC\t\t\\\n+      || GET_CODE(ADDR) == PRE_INC || GET_CODE(ADDR) == POST_INC)\t\\\n+    goto LABEL;\t\t\t\t\t\t\t\t\\\n+}\n+\f\n+/* Specify the machine mode that this machine uses\n+   for the index in the tablejump instruction.  */\n+#define CASE_VECTOR_MODE SImode\n+\n+/* Define this if the tablejump instruction expects the table\n+   to contain offsets from the address of the table.\n+   Do not define this if the table should contain absolute addresses.  */\n+/* #define CASE_VECTOR_PC_RELATIVE */\n+\n+/* Specify the tree operation to be used to convert reals to integers.  */\n+#define IMPLICIT_FIX_EXPR  FIX_ROUND_EXPR\n+\n+/* This is the kind of divide that is easiest to do in the general case.  */\n+#define EASY_DIV_EXPR  TRUNC_DIV_EXPR\n+\n+/* 'char' is signed by default on RISCiX, unsigned on RISCOS.  */\n+#ifdef riscos\n+#define DEFAULT_SIGNED_CHAR  0\n+#else\n+#define DEFAULT_SIGNED_CHAR  1\n+#endif\n+\n+/* Don't cse the address of the function being compiled.  */\n+#define NO_RECURSIVE_FUNCTION_CSE 1\n+\n+/* Max number of bytes we can move from memory to memory\n+   in one reasonably fast instruction.\n+   On the ARM, there are no instructions which move memory to memory!  */\n+#define MOVE_MAX  0\n+\n+/* Define if normal loads of shorter-than-word items from memory clears\n+   the rest of the bigs in the register.\n+   On the ARM, movhi does a garbage extend.  */\n+/* #define BYTE_LOADS_ZERO_EXTEND */\n+\n+/* Define this if zero-extension is slow (more than one real instruction).\n+   On the ARM, it is more than one instruction only if not fetching from\n+   memory.  */\n+/* #define SLOW_ZERO_EXTEND */\n+\n+/* Nonzero if access to memory by bytes is slow and undesirable.  */\n+#define SLOW_BYTE_ACCESS 0\n+\n+/* Immediate shift counts are truncated by the output routines (or was it\n+   the assembler?).  Shift counts in a register are truncated by ARM.  Note\n+   that the native compiler puts too large (> 32) immediate shift counts\n+   into a register and shifts by the register, letting the ARM decide what\n+   to do instead of doing that itself.  */\n+#define SHIFT_COUNT_TRUNCATED 1\n+\n+/* We have the vprintf function.  */\n+#define HAVE_VPRINTF 1\n+\n+/* XX This is not true, is it?  */\n+/* All integers have the same format so truncation is easy.  */\n+#define TRULY_NOOP_TRUNCATION(OUTPREC,INPREC)  1\n+\n+/* Calling from registers is a massive pain.  */\n+#define NO_FUNCTION_CSE 1\n+\n+/* Chars and shorts should be passed as ints.  */\n+#define PROMOTE_PROTOTYPES 1\n+\n+/* There is no support for s<cond> insns at present */\n+#define STORE_FLAG_VALUE  0\n+\n+/* The machine modes of pointers and functions */\n+#define Pmode  SImode\n+#define FUNCTION_MODE  Pmode\n+\n+/* The structure type of the machine dependent info field of insns\n+   No uses for this yet.  */\n+/* #define INSN_MACHINE_INFO  struct machine_info  */\n+\n+/* The relative costs of various types of constants.  Note that cse.c defines\n+   REG = 1, SUBREG = 2, any node = (2 + sum of subnodes).  */\n+#define CONST_COSTS(RTX, CODE)  \\\n+  case CONST_INT:\t\t\t\t\\\n+    if (const_ok_for_arm (INTVAL (RTX)))\t\\\n+      return (2);\t\t\t\t\\\n+    else\t\t\t\t\t\\\n+      return (5);\t\t\t\t\\\n+\t\t\t\t\t\t\\\n+  case CONST: \t\t\t\t\t\\\n+  case LABEL_REF:\t\t\t\t\\\n+  case SYMBOL_REF:\t\t\t\t\\\n+    return (6);\t\t\t\t\t\\\n+\t\t\t\t\t\t\\\n+  case CONST_DOUBLE:\t\t\t\t\\\n+    if (const_double_rtx_ok_for_fpu (RTX))\t\\\n+      return(2);\t\t\t\t\\\n+    else\t\t\t\t\t\\\n+      return(7);\n+\f\n+/* Condition code information.  */\n+\n+/* Store in cc_status the expressions\n+   that the condition codes will describe\n+   after execution of an instruction whose pattern is EXP.\n+   Do not alter them if the instruction would not alter the cc's.  */\n+\n+/* On the ARM nothing sets the condition code implicitly---apart from DImode\n+   operations excluding moves---but we have to watch for registers in the\n+   condition code value being clobbered.  This clobbering includes (alas)\n+   function calls.  XXX They could just be considered to clobber regs 0-3 and\n+   10-15 with extra work.  */\n+#define NOTICE_UPDATE_CC(EXP, INSN)  \\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (GET_MODE (EXP) == DImode\t\t\t\t\t\t\\\n+      && GET_CODE (EXP) == SET\t\t\t\t\t\t\\\n+      && GET_CODE (SET_SRC (EXP)) != REG\t\t\t\t\\\n+      && GET_CODE (SET_SRC (EXP)) != MEM\t\t\t\t\\\n+      && GET_CODE (SET_SRC (EXP)) != CONST_INT)\t\t\t\t\\\n+    CC_STATUS_INIT;\t\t\t\t\t\t\t\\\n+  else if (GET_CODE (EXP) == SET)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      rtx dest = SET_DEST (EXP);\t\t\t\t\t\\\n+      if (dest == cc0_rtx)\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  cc_status.flags = 0;\t\t\t\t\t\t\\\n+\t  cc_status.value1 = SET_DEST (EXP);\t\t\t\t\\\n+\t  cc_status.value2 = SET_SRC (EXP);\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      if (BASE_REGISTER_RTX_P (dest))\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  if (cc_status.value1\t\t\t\t\t\t\\\n+\t      && reg_overlap_mentioned_p (dest, cc_status.value1))\t\\\n+\t    cc_status.value1 = 0;\t\t\t\t\t\\\n+\t  if (cc_status.value2\t\t\t\t\t\t\\\n+\t      && reg_overlap_mentioned_p (dest, cc_status.value2)) \t\\\n+\t    cc_status.value2 = 0;\t\t\t\t        \\\n+\t}\t\t\t\t\t\t\t        \\\n+    }\t\t\t\t\t\t\t\t        \\\n+  else if (GET_CODE (INSN) != JUMP_INSN && GET_CODE (EXP) == PARALLEL)\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      CC_STATUS_INIT;\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\f\n+/* Assembler output control */\n+\n+/* The text to go at the start of the assembler file */\n+#define ASM_FILE_START(STREAM)  \\\n+{                                                                             \\\n+  extern char *version_string;                                                \\\n+                                                                              \\\n+  fprintf (STREAM,\"@ Generated by gcc %s for ARM/RISCiX\\n\", version_string);  \\\n+  fprintf (STREAM,\"rfp\\t.req\\tr9\\n\");                                         \\\n+  fprintf (STREAM,\"fp\\t.req\\tr11\\n\");\t\t\t\t              \\\n+  fprintf (STREAM,\"ip\\t.req\\tr12\\n\");\t\t\t\t              \\\n+  fprintf (STREAM,\"sp\\t.req\\tr13\\n\");\t\t\t\t              \\\n+  fprintf (STREAM,\"lr\\t.req\\tr14\\n\");\t\t\t\t\t      \\\n+  fprintf (STREAM,\"pc\\t.req\\tr15\\n\");\t\t\t\t              \\\n+}\n+\n+#define ASM_APP_ON  \"\"\n+#define ASM_APP_OFF  \"\"\n+\n+/* Switch to the text or data segment.  */\n+#define TEXT_SECTION_ASM_OP  \"\\n\\t.text\\n\"\n+#define DATA_SECTION_ASM_OP  \"\\n\\t.data\\n\"\n+\n+/* The assembler's names for the registers.  RFP need not always be used as\n+   the Real framepointer; it can also be used as a normal general register.\n+   Note that the name `fp' is horribly misleading since `fp' is in fact only\n+   the argument-and-return-context pointer.  */\n+#define REGISTER_NAMES  \\\n+{\t\t\t\t                   \\\n+  \"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\",  \\\n+  \"r8\",\"rfp\", \"sl\", \"fp\", \"ip\", \"sp\", \"lr\", \"pc\",  \\\n+  \"f0\", \"f1\", \"f2\", \"f3\", \"f4\", \"f5\", \"f6\", \"f7\"   \\\n+}\n+\n+/* DBX register number for a given compiler register number */\n+#define DBX_REGISTER_NUMBER(REGNO)  (REGNO)\n+\n+/* Generate DBX debugging information.  */\n+#define DBX_DEBUGGING_INFO  1\n+\n+/* Acorn dbx moans about continuation chars, so don't use any.  */\n+#define DBX_CONTIN_LENGTH  0\n+\n+/* Output a label definition.  */\n+#define ASM_OUTPUT_LABEL(STREAM,NAME)  \\\n+  arm_asm_output_label ((STREAM), (NAME))\n+\n+/* Output a function label definition.  */\n+#define ASM_DECLARE_FUNCTION_NAME(STREAM,NAME,DECL) \\\n+    ASM_OUTPUT_LABEL(STREAM, NAME)\n+\n+/* Output a globalising directive for a label.  */\n+#define ASM_GLOBALIZE_LABEL(STREAM,NAME)  \\\n+  (fprintf (STREAM, \"\\t.global\\t\"),\t  \\\n+   assemble_name (STREAM, NAME),\t  \\\n+   fputc ('\\n',STREAM))                   \\\n+\n+/* Output a reference to a label.  */\n+#define ASM_OUTPUT_LABELREF(STREAM,NAME)  \\\n+  fprintf (STREAM, \"_%s\", NAME)\n+\n+/* Make an internal label into a string.  */\n+#define ASM_GENERATE_INTERNAL_LABEL(STRING, PREFIX, NUM)  \\\n+  sprintf (STRING, \"*%s%d\", PREFIX, NUM)\n+\n+/* Output an internal label definition.  */\n+#define ASM_OUTPUT_INTERNAL_LABEL(STREAM, PREFIX, NUM)  \\\n+  do                                    \t      \t   \t\t\\\n+    {\t\t\t\t\t\t      \t   \t\t\\\n+      char *s = (char *) alloca (11 + strlen (PREFIX));\t   \t\t\\\n+      extern int arm_target_label, arm_ccfsm_state;\t   \t\t\\\n+\t\t\t\t\t\t           \t\t\\\n+      if (arm_ccfsm_state == 3 && arm_target_label == (NUM))   \t\t\\\n+\tarm_ccfsm_state = 0;\t\t\t\t        \t\\\n+      strcpy (s, \"*\");\t\t\t\t           \t\t\\\n+      sprintf (&s[strlen (s)], \"%s%d\", (PREFIX), (NUM));   \t\t\\\n+      arm_asm_output_label (STREAM, s);\t\t                        \\\n+    } while (0)\n+\n+/* Nothing special is done about jump tables */\n+/* #define ASM_OUTPUT_CASE_LABEL(STREAM,PREFIX,NUM,TABLE)   */\n+/* #define ASM_OUTPUT_CASE_END(STREAM,NUM,TABLE)\t    */\n+\n+/* Construct a private name.  */\n+#define ASM_FORMAT_PRIVATE_NAME(OUTVAR,NAME,NUMBER)  \\\n+  ((OUTVAR) = (char *) alloca (strlen (NAME) + 10),  \\\n+   sprintf ((OUTVAR), \"%s.%d\", (NAME), (NUMBER)))\n+\n+/* Output a push or a pop instruction (only used when profiling).  */\n+#define ASM_OUTPUT_REG_PUSH(STREAM,REGNO)   \\\n+  (arm_increase_location (4)                                   \\\n+   , fprintf(STREAM,\"\\tstmfd\\tsp!,{%s}\\n\", reg_names[REGNO]))\n+\n+#define ASM_OUTPUT_REG_POP(STREAM,REGNO)   \\\n+  (arm_increase_location (4)                                   \\\n+   , fprintf(STREAM,\"\\tldmfd\\tsp!,{%s}\\n\", reg_names[REGNO]))\n+\n+/* Output a relative address. Not needed since jump tables are absolute\n+   but we must define it anyway.  */\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(STREAM,VALUE,REL)  \\\n+  fputs (\"- - - ASM_OUTPUT_ADDR_DIFF_ELT called!\\n\", STREAM)\n+\n+/* Output an element of a dispatch table.  */\n+#define ASM_OUTPUT_ADDR_VEC_ELT(STREAM,VALUE)  \\\n+  (arm_increase_location (4)                     \\\n+   , fprintf (STREAM, \"\\t.word\\tL%d\\n\", VALUE))\n+\n+/* Output various types of constants.  */\n+#define ASM_OUTPUT_DOUBLE(STREAM, VALUE)  \\\n+  (arm_increase_location (sizeof (double))        \\\n+   , fprintf (STREAM, \"\\t.double\\t%20.20f\\n\", VALUE))\n+\n+#define ASM_OUTPUT_FLOAT(STREAM, VALUE)\t\\\n+  (arm_increase_location (sizeof (float))        \\\n+   , fprintf (STREAM, \"\\t.float\\t%20.20f\\n\", VALUE))\n+\n+#define ASM_OUTPUT_INT(STREAM, EXP)  \\\n+  (fprintf (STREAM, \"\\t.word\\t\"),      \\\n+   output_addr_const (STREAM, (EXP)),  \\\n+   arm_increase_location (4),          \\\n+   fputc ('\\n', STREAM))\n+\n+#define ASM_OUTPUT_SHORT(STREAM, EXP)  \\\n+  (fprintf (STREAM, \"\\t.short\\t\"),     \\\n+   output_addr_const (STREAM, (EXP)),  \\\n+   arm_increase_location (2),          \\\n+   fputc ('\\n', STREAM))\n+\n+#define ASM_OUTPUT_CHAR(STREAM, EXP)  \\\n+  (fprintf (STREAM, \"\\t.byte\\t\"),      \\\n+   output_addr_const (STREAM, (EXP)),  \\\n+   arm_increase_location (1),          \\\n+   fputc ('\\n', STREAM))\n+\n+#define ASM_OUTPUT_BYTE(STREAM, VALUE)  \\\n+  (fprintf (STREAM, \"\\t.byte\\t%d\\n\", VALUE),  \\\n+   arm_increase_location (1))\n+\n+#define ASM_OUTPUT_ASCII(STREAM, PTR, LEN)  \\\n+  output_ascii_pseudo_op ((STREAM), (PTR), (LEN))\n+\n+/* Output a gap.  In fact we fill it with nulls.  */\n+#define ASM_OUTPUT_SKIP(STREAM, NBYTES)  \\\n+  (arm_increase_location (NBYTES),              \\\n+   fprintf (STREAM, \"\\t.space\\t%d\\n\", NBYTES))\n+\n+/* Align output to a power of two.  Horrible /bin/as.  */\n+#define ASM_OUTPUT_ALIGN(STREAM, POWER)  \\\n+  do                                                           \\\n+    {                                                          \\\n+      register int amount = 1 << (POWER);                      \\\n+      extern int arm_text_location;\t\t\t       \\\n+                                                               \\\n+      if (amount == 2)                                         \\\n+\tfprintf (STREAM, \"\\t.even\\n\");                         \\\n+      else                                                     \\\n+\tfprintf (STREAM, \"\\t.align\\t%d\\n\", amount - 4);        \\\n+                                                               \\\n+      if (in_text_section ())                                  \\\n+\tarm_text_location = ((arm_text_location + amount - 1)  \\\n+\t\t\t     & ~(amount - 1));                 \\\n+    } while (0)\n+\n+/* Output a common block */\n+#define ASM_OUTPUT_COMMON(STREAM, NAME, SIZE, ROUNDED)  \\\n+  (fprintf (STREAM, \"\\t.comm\\t\"), \t\t     \\\n+   assemble_name ((STREAM), (NAME)),\t\t     \\\n+   fprintf(STREAM, \", %d\\t@%d\\n\", ROUNDED, SIZE))\n+\n+/* Output a local common block.  /bin/as can't do this, so hack a `.space' into\n+   the bss segment.  Note that this is *bad* practice.  */\n+#define ASM_OUTPUT_LOCAL(STREAM,NAME,SIZE,ROUNDED)  \\\n+  output_lcomm_directive (STREAM, NAME, SIZE, ROUNDED)\n+\n+/* Output a source filename for the debugger. RISCiX dbx insists that the\n+   ``desc'' field is set to compiler version number >= 315 (sic).  */\n+#if 0\n+#define ASM_OUTPUT_SOURCE_FILENAME(STREAM,NAME)\t \\\n+  fprintf (STREAM, \"\\t.stabs\\t\\\"%s\\\", %d, 0, 315, Ltext\\n\", (NAME), N_SOL)\n+#endif\n+\n+/* Output a source line for the debugger.  */\n+/* #define ASM_OUTPUT_SOURCE_LINE(STREAM,LINE) */\n+\n+/* Output a #ident directive.  */\n+#define ASM_OUTPUT_IDENT(STREAM,STRING)  \\\n+  fprintf (STREAM,\"- - - ident %s\\n\",STRING)\n+\n+/* The assembler's parentheses characters.  */\n+#define ASM_OPEN_PAREN \"(\"\n+#define ASM_CLOSE_PAREN \")\"\n+\n+/* Target characters.  */\n+#define TARGET_BELL\t007\n+#define TARGET_BS\t010\n+#define TARGET_TAB\t011\n+#define TARGET_NEWLINE\t012\n+#define TARGET_VT\t013\n+#define TARGET_FF\t014\n+#define TARGET_CR\t015\n+\f\n+/* FINAL_PRESCAN_INSN is used to take a look at the insns, in order to delete\n+   small-distance conditional branches and have ASM_OUTPUT_OPCODE make the\n+   instructions conditional.  Suffixes like s (affect flags) and b (bytewise\n+   load/store) need to stay suffixes, so the possible condition code comes\n+   before these suffixes.  */\n+#define ASM_OUTPUT_OPCODE(STREAM, PTR)  \\\n+  {\t\t\t\t\t        \t\t      \\\n+    extern int arm_ccfsm_state, arm_current_cc;\t\t\t      \\\n+    extern char *arm_condition_codes[];\t\t\t\t      \\\n+    int i;\t\t\t\t\t\t\t      \\\n+\t\t\t\t\t\t\t\t      \\\n+    fflush (STREAM);\t    /* XXX for dubugging only.  */\t      \\\n+    if (arm_ccfsm_state == 1 || arm_ccfsm_state == 2)   \t      \\\n+      {\t\t\t\t                        \t      \\\n+\tfprintf (STREAM, \"@ \\t\");\t\t\t\t      \\\n+\tarm_ccfsm_state += 2;\t\t        \t\t      \\\n+      }\t\t\t\t\t        \t\t             \\\n+    else if (arm_ccfsm_state == 3 || arm_ccfsm_state == 4)\t             \\\n+      {\t\t\t\t\t        \t\t             \\\n+\tfor (i = 0; *(PTR) != ' ' && *(PTR) != '\\t' && i < 3; i++, (PTR)++)  \\\n+\t  putc (*(PTR), STREAM);\t        \t\t             \\\n+\tfprintf (STREAM, \"%s\", arm_condition_codes[arm_current_cc]);         \\\n+\tfor (; *(PTR) != ' ' && *(PTR) != '\\t'; (PTR)++)\t\t     \\\n+\t  putc (*(PTR), STREAM);\t\t\t\t\t     \\\n+      }\t\t\t\t\t\t\t\t             \\\n+  }\n+\n+/* Only perform branch elimination (by making instructions conditional) if\n+   we're optimising.  Otherwise it's of no use anyway.  */\n+#define FINAL_PRESCAN_INSN(INSN, OPVEC, NOPERANDS)  \\\n+  if (optimize)\t\t\t\t\t    \\\n+    final_prescan_insn (INSN, OPVEC, NOPERANDS)\n+\n+/* Output an operand of an instruction.  If X is a REG and CODE is `M', output\n+   a ldm/stm style multi-reg.  */\n+#define PRINT_OPERAND(STREAM, X, CODE)  \\\n+{\t\t\t\t\t        \t\t\\\n+  if ((CODE) == 'R')\t\t\t        \t\t\\\n+    fputs (reg_names[REGNO (X) + 1], (STREAM));\t\t\t\\\n+  else if (GET_CODE (X) == REG)\t\t        \t\t\\\n+    {\t\t\t\t\t        \t\t\\\n+      if ((CODE) != 'M')\t\t\t\t\t\\\n+\tfputs (reg_names[REGNO (X)], (STREAM));\t\t\t\\\n+      else\t\t\t\t        \t\t\\\n+\tfprintf ((STREAM), \"{%s-%s}\",\t        \t\t\\\n+\t\t reg_names[REGNO (X)],\t        \t\t\\\n+\t\t reg_names[REGNO (X) - 1        \t\t\\\n+\t\t\t   + ((GET_MODE_SIZE (GET_MODE (X))\t\\\n+\t\t\t       + GET_MODE_SIZE (SImode) - 1)\t\\\n+\t\t\t      / GET_MODE_SIZE (SImode))]);\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  else if (GET_CODE (X) == MEM)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      extern int output_memory_reference_mode;\t\t\t\\\n+      output_memory_reference_mode = GET_MODE (X);\t\t\\\n+      output_address (XEXP (X, 0));\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  else if (GET_CODE(X) == CONST_DOUBLE)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      union real_extract u;\t\t\t\t\t\\\n+      u.i[0] = CONST_DOUBLE_LOW (X);\t\t\t\t\\\n+      u.i[1] = CONST_DOUBLE_HIGH (X);\t\t\t\t\\\n+      fprintf(STREAM,\"#%20.20f\",u.d);\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  else if (GET_CODE (X) == NEG)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      fputc ('-', (STREAM));\t\t\t\t\t\\\n+      output_operand ((X), 0);\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      fputc('#', STREAM);\t\t\t\t\t\\\n+      output_addr_const(STREAM, X);\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+}\n+\n+/* Output the address of an operand.  */\n+#define PRINT_OPERAND_ADDRESS(STREAM,X)  \\\n+{\t\t\t\t\t\t\t\t\t\\\n+    int is_minus = GET_CODE (X) == MINUS;\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    if (GET_CODE (X) == REG)\t\t\t\t\t\t\\\n+\tfprintf (STREAM, \"[%s, #0]\", reg_names[REGNO (X)]);\t\t\\\n+    else if (GET_CODE (X) == PLUS || is_minus)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\trtx base = XEXP (X, 0);\t\t\t\t\t\t\\\n+\trtx index = XEXP (X, 1);\t\t\t\t\t\\\n+\tchar *base_reg_name;\t\t\t\t\t\t\\\n+\tint offset = 0; \t\t\t\t\t\t\\\n+\tint shift;\t\t\t\t\t\t\t\\\n+\tif (GET_CODE (base) != REG)\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    /* Ensure that BASE is a register (one of them must be). */\t\\\n+\t    rtx temp = base;\t\t\t\t\t\t\\\n+\t    base = index;\t\t\t\t\t\t\\\n+\t    index = temp;\t\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+\tbase_reg_name = reg_names[REGNO (base)];\t\t\t\\\n+\tswitch (GET_CODE (index))\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t  case CONST_INT:\t\t\t\t\t\t\\\n+\t    offset = INTVAL (index);\t\t\t\t\t\\\n+\t    if (is_minus)\t\t\t\t\t\t\\\n+\t      offset = -offset;\t\t\t\t\t\t\\\n+\t    fprintf (STREAM, \"[%s, #%d]\", base_reg_name, offset);\t\\\n+\t    break;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t  case REG:\t\t\t\t\t\t\t\\\n+\t    fprintf (STREAM, \"[%s, %s%s]\", base_reg_name,\t\t\\\n+\t\t     is_minus ? \"-\" : \"\", reg_names[REGNO (index)] );\t\\\n+\t    break;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t  case MULT:\t\t\t\t\t\t\t\\\n+\t    if (GET_CODE (XEXP (index,0)) == CONST_INT)\t\t\t\\\n+\t      {\t\t\t\t\t\t\t\t\\\n+\t\tshift = int_log2 (INTVAL (XEXP (index, 0)));\t\t\\\n+\t\tindex = XEXP (index, 1);\t\t\t\t\\\n+\t      }\t\t\t\t\t\t\t\t\\\n+\t    else if (GET_CODE(XEXP(index,1)) == CONST_INT)\t\t\\\n+\t      {\t\t\t\t\t\t\t\t\\\n+\t\tshift = int_log2 (INTVAL (XEXP (index, 1)));\t\t\\\n+\t\tindex = XEXP (index, 0);\t\t\t\t\\\n+\t      }\t\t\t\t\t\t\t\t\\\n+\t    else\t\t\t\t\t\t\t\\\n+\t\tabort();\t\t\t\t\t\t\\\n+\t    fprintf (STREAM, \"[%s, %s%s, asl#%d]\", base_reg_name,\t\\\n+\t\t     is_minus ? \"-\" : \"\", reg_names[REGNO (index)],\t\\\n+\t\t     shift);\t\t\t\t\t\t\\\n+\t    break;\t\t\t\t\t\t\t\\\n+\t    \t\t\t\t\t\t\t\t\\\n+\t  default:\t\t\t\t\t\t\t\\\n+\t    abort();\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t        \t\\\n+  else if (GET_CODE (X) == PRE_INC || GET_CODE (X) == POST_INC\t\t\\\n+\t   || GET_CODE (X) == PRE_DEC || GET_CODE (X) == POST_DEC)\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      extern int output_memory_reference_mode;\t\t\t\t\\\n+      \t\t\t\t\t\t\t\t\t\\\n+      if (GET_CODE (XEXP (X, 0)) != REG)\t\t\t\t\\\n+\tabort ();\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      if (GET_CODE (X) == PRE_DEC || GET_CODE (X) == PRE_INC)\t\t\\\n+\tfprintf (STREAM, \"[%s, #%s%d]!\", reg_names[REGNO (XEXP (X, 0))],\\\n+\t\t GET_CODE (X) == PRE_DEC ? \"-\" : \"\",\t\t\t\\\n+\t\t GET_MODE_SIZE (output_memory_reference_mode));\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\tfprintf (STREAM, \"[%s], #%s%d\", reg_names[REGNO (XEXP (X, 0))],\t\\\n+\t\t GET_CODE (X) == POST_DEC ? \"-\" : \"\",\t\t\t\\\n+\t\t GET_MODE_SIZE (output_memory_reference_mode));\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else output_addr_const(STREAM, X);\t\t\t\t\t\\\n+}\n+\n+/* EOF arm.h */"}, {"sha": "c35c603cee947dc7034193aff7611e804611b3f8", "filename": "gcc/config/ns32k/encore.h", "status": "added", "additions": 240, "deletions": 0, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35d965d5c95e8c50c9cc5220f03db1fe774f78f4/gcc%2Fconfig%2Fns32k%2Fencore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35d965d5c95e8c50c9cc5220f03db1fe774f78f4/gcc%2Fconfig%2Fns32k%2Fencore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fencore.h?ref=35d965d5c95e8c50c9cc5220f03db1fe774f78f4", "patch": "@@ -0,0 +1,240 @@\n+/* Definitions of target machine for GNU compiler.  ENCORE NS32000 version.\n+   Copyright (C) 1988 Free Software Foundation, Inc.\n+   Adapted by Robert Brown (brown@harvard.harvard.edu) from the Sequent\n+     version by Michael Tiemann (tiemann@mcc.com).\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+/*\n+ *  Looks like all multiprocessors have this bug!\n+ */\n+\n+#define SEQUENT_ADDRESS_BUG 1\n+\n+#include \"ns32k.h\"\n+\n+#define SDB_DEBUGGING_INFO\n+#undef DBX_REGISTER_NUMBER\n+#define DBX_REGISTER_NUMBER(REGNO) (REGNO)\n+\n+/* Cause long-jump assembler to be used,\n+   since otherwise some files fail to be assembled right.  */\n+#define ASM_SPEC \"-j\"\n+\n+#undef ASM_FILE_START\n+#undef ASM_GENERATE_INTERNAL_LABEL\n+#undef ASM_OUTPUT_ADDR_DIFF_ELT\n+#undef ASM_OUTPUT_ALIGN\n+#undef ASM_OUTPUT_ASCII\n+#undef ASM_OUTPUT_DOUBLE\n+#undef ASM_OUTPUT_INT\n+#undef ASM_OUTPUT_INTERNAL_LABEL\n+#undef ASM_OUTPUT_LOCAL\n+#undef CPP_PREDEFINES\n+#undef FUNCTION_BOUNDARY\n+#undef PRINT_OPERAND\n+#undef PRINT_OPERAND_ADDRESS\n+#undef TARGET_VERSION\n+#undef FUNCTION_PROFILER\n+#undef ASM_OUTPUT_LABELREF_AS_INT\n+\n+#define TARGET_DEFAULT 25  /* 32532 with 32081 (guessing) */\n+#define TARGET_VERSION fprintf (stderr, \" (32000, Encore syntax)\");\n+/* Note Encore does not standardly do -Dencore.  */\n+/* budd: should have a -ns32332 (or -apc) switch! but no harm for now */\n+#define CPP_PREDEFINES \"-Dns32000 -Dn16 -Dns16000 -Dns32332 -Dunix\"\n+\n+/* Ignore certain cpp directives used in header files on sysV.  */\n+#define SCCS_DIRECTIVE\n+\n+/* Output #ident as a .ident.  */\n+#define ASM_OUTPUT_IDENT(FILE, NAME) fprintf (FILE, \"\\t.ident \\\"%s\\\"\\n\", NAME);\n+\n+/* The .file command should always begin the output.  */\n+#define ASM_FILE_START(FILE) \\\n+output_file_directive ((FILE), main_input_filename)\n+\n+#define FUNCTION_BOUNDARY 128\t\t/* speed optimization */\n+\n+/*\n+ *  The Encore assembler uses \".align 2\" to align on 2-byte boundaries.\n+ */\n+\n+#define ASM_OUTPUT_ALIGN(FILE,LOG)\t\t\t\t\t\\\n+\tfprintf (FILE, \"\\t.align %d\\n\", 1 << (LOG))\n+\n+/*\n+ *  Internal labels are prefixed with a period.\n+ */\n+\n+#define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)\t\t\t\\\n+\tsprintf (LABEL, \"*.%s%d\", PREFIX, NUM)\n+#define ASM_OUTPUT_INTERNAL_LABEL(FILE,PREFIX,NUM)\t\t\t\\\n+\tfprintf (FILE, \".%s%d:\\n\", PREFIX, NUM)\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)\t\t\t\\\n+\tfprintf (FILE, \"\\t.word .L%d-.LI%d\\n\", VALUE, REL)\n+\n+/*\n+ *  Different syntax for integer constants, double constants, and\n+ *  uninitialized locals.\n+ */\n+\n+#define ASM_OUTPUT_INT(FILE,VALUE)\t\t\t\t\\\n+( fprintf (FILE, \"\\t.double \"),\t\t\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+#define ASM_OUTPUT_LABELREF_AS_INT(STREAM, NAME)\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  fprintf (STREAM, \"\\t.double\\t\");\t\t\t\t\t\\\n+  ASM_OUTPUT_LABELREF (STREAM, NAME);\t\t\t\t\t\\\n+  fprintf (STREAM, \"\\n\");\t\t\t\t\t\t\\\n+} while (0)\n+\n+\n+#define ASM_OUTPUT_DOUBLE(FILE,VALUE)\t\t\t\t\\\n+ fprintf (FILE, \"\\t.long 0f%.20e\\n\", (VALUE))\n+\n+#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)\t\t\\\n+( fputs (\"\\t.bss \", (FILE)),\t\t\t\t\t\\\n+  assemble_name ((FILE), (NAME)),\t\t\t\t\\\n+  fprintf ((FILE), \",%u,%u\\n\", (SIZE), (ROUNDED)))\n+\n+ /*\n+  *  Encore assembler can't handle huge string constants like the one in\n+  *  gcc.c.  If the default routine in varasm.c were more conservative, this\n+  *  code could be eliminated.  It starts a new .ascii directive every 40\n+  *  characters.\n+  */\n+\n+#define ASM_OUTPUT_ASCII(file, p, size)\t\t\t\\\n+{\t\t\t\t\t\t\t\\\n+  for (i = 0; i < (size); i++)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      register int c = (p)[i];\t\t\t\t\\\n+      if ((i / 40) * 40 == i)\t\t\t\t\\\n+      if (i == 0)\t\t\t\t\t\\\n+        fprintf ((file), \"\\t.ascii \\\"\");\t\t\\\n+      else\t\t\t\t\t\t\\\n+        fprintf ((file), \"\\\"\\n\\t.ascii \\\"\");\t\t\\\n+      if (c == '\\\"' || c == '\\\\')\t\t\t\\\n+        putc ('\\\\', (file));\t\t\t\t\\\n+      if (c >= ' ' && c < 0177)\t\t\t\t\\\n+        putc (c, (file));\t\t\t\t\\\n+      else\t\t\t\t\t\t\\\n+        {\t\t\t\t\t\t\\\n+          fprintf ((file), \"\\\\%o\", c);\t\t\t\\\n+          if (i < (size) - 1 \t\t\t\t\\\n+              && (p)[i + 1] >= '0' && (p)[i + 1] <= '9')\\\n+          fprintf ((file), \"\\\"\\n\\t.ascii \\\"\");\t\t\\\n+        }\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  fprintf ((file), \"\\\"\\n\");\t\t\t\t\\\n+}\n+\n+ /*\n+  *  Dollar signs are required before immediate operands, double\n+  *  floating point constants use $0f syntax, and external addresses\n+  *  should be prefixed with a question mark to avoid assembler warnings\n+  *  about undefined symbols.\n+  */\n+\n+#define PRINT_OPERAND(FILE, X, CODE)\t\t\t\t\t\\\n+{ if (CODE == '$') putc ('$', FILE);\t\t\t\t\t\\\n+  else if (CODE == '?') fputc ('?', FILE);\t\t\t\t\\\n+  else if (GET_CODE (X) == REG)\t\t\t\t\t\t\\\n+    fprintf (FILE, \"%s\", reg_names[REGNO (X)]);\t\t\t\t\\\n+  else if (GET_CODE (X) == MEM)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      rtx xfoo;\t\t\t\t\t\t\t\t\\\n+      xfoo = XEXP (X, 0);\t\t\t\t\t\t\\\n+      switch (GET_CODE (xfoo))\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\tcase MEM:\t\t\t\t\t\t\t\\\n+\t  if (GET_CODE (XEXP (xfoo, 0)) == REG)\t\t\t\t\\\n+\t    if (REGNO (XEXP (xfoo, 0)) == STACK_POINTER_REGNUM)\t\t\\\n+\t      fprintf (FILE, \"0(0(sp))\");\t\t\t\t\\\n+\t    else fprintf (FILE, \"0(0(%s))\",\t\t\t\t\\\n+\t\t\t  reg_names[REGNO (XEXP (xfoo, 0))]);\t\t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      fprintf (FILE, \"0(\");\t\t\t\t\t\\\n+\t      output_address (xfoo);\t\t\t\t\t\\\n+\t      putc (')', FILE);\t\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\t\\\n+\tcase REG:\t\t\t\t\t\t\t\\\n+\t  fprintf (FILE, \"0(%s)\", reg_names[REGNO (xfoo)]);\t\t\\\n+\t  break;\t\t\t\t\t\t\t\\\n+\tcase PRE_DEC:\t\t\t\t\t\t\t\\\n+\tcase POST_INC:\t\t\t\t\t\t\t\\\n+\t  fprintf (FILE, \"tos\");\t\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\t\\\n+\tcase CONST_INT:\t\t\t\t\t\t\t\\\n+\t  fprintf (FILE, \"@%d\", INTVAL (xfoo));\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\t\\\n+\tdefault:\t\t\t\t\t\t\t\\\n+\t  output_address (xfoo);\t\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else if (GET_CODE (X) == CONST_DOUBLE && GET_MODE (X) != DImode)\t\\\n+    if (GET_MODE (X) == DFmode)\t\t\t\t\t\t\\\n+      { union { double d; int i[2]; } u;\t\t\t\t\\\n+\tu.i[0] = CONST_DOUBLE_LOW (X); u.i[1] = CONST_DOUBLE_HIGH (X);\t\\\n+\tfprintf (FILE, \"$0f%.20e\", u.d); }\t\t\t\t\\\n+    else { union { double d; int i[2]; } u;\t\t\t\t\\\n+\t   u.i[0] = CONST_DOUBLE_LOW (X); u.i[1] = CONST_DOUBLE_HIGH (X); \\\n+\t   fprintf (FILE, \"$0f%.20e\", u.d); }\t\t\t\t\\\n+  else if (GET_CODE (X) == CONST)\t\t\t\t\t\\\n+    output_addr_const (FILE, X);\t\t\t\t\t\\\n+  else { putc ('$', FILE); output_addr_const (FILE, X); }}\n+\n+#define PRINT_OPERAND_ADDRESS(FILE, ADDR)  print_operand_address(FILE, ADDR)\n+\f\n+/* Change the way in which data is allocated and initialized on the\n+   encore so that both private and shared data are supported.  Shared data\n+   that is initialized must be contained in the \".shrdata\" section\n+   of the program.  This is accomplished by defining the SHARED_SECTION_ASM_OP\n+   macro.  Share data that is simply allocated, and not initialized must\n+   be prefixed with the \".shrcomm\" or \".shrbss\" pseudo op, for common or\n+   local data respectively.  This is accomplished by redefining the\n+   ASM_OUTPUT_COMMON and ASM_OUTPUT_LOCAL macros. */\n+    \n+/* Assembler pseudo-op for shared data segment. */\n+\n+#define SHARED_SECTION_ASM_OP \".shrdata\"\n+\n+/* This says how to output an assembler line\n+   to define a shared common symbol. */\n+\n+#define ASM_OUTPUT_SHARED_COMMON(FILE, NAME, SIZE, ROUNDED) \\\n+( fputs (\".shrcomm \", (FILE)),\t\t\t\\\n+  assemble_name ((FILE), (NAME)),\t\t\\\n+  fprintf ((FILE), \",%d\\n\", (ROUNDED)))\n+\n+/* This says how to output an assembler line\n+   to define a shared local symbol. */\n+\n+#define ASM_OUTPUT_SHARED_LOCAL(FILE, NAME, SIZE, ROUNDED) \\\n+( fputs (\"\\t.shrbss \", (FILE)),\t\t\t\t\\\n+  assemble_name ((FILE), (NAME)),\t\t\t\\\n+  fprintf ((FILE), \",%d,%d\\n\", (SIZE), (ROUNDED)))\n+\n+#define FUNCTION_PROFILER(FILE, LABELNO)  \\\n+   fprintf (FILE, \"\\taddr .LP%d,r0\\n\\tjsr mcount\\n\", (LABELNO))"}]}