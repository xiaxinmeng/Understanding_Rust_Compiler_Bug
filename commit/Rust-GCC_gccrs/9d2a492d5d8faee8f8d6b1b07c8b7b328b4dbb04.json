{"sha": "9d2a492d5d8faee8f8d6b1b07c8b7b328b4dbb04", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWQyYTQ5MmQ1ZDhmYWVlOGY4ZDZiMWIwN2M4YjdiMzI4YjRkYmIwNA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2004-03-19T19:36:52Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2004-03-19T19:36:52Z"}, "message": "* tree.c (substitute_in_expr): Rewrite to simplify and be more generic.\n\nFrom-SVN: r79696", "tree": {"sha": "9a291b530e41e1969003caca9701822e571a77a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9a291b530e41e1969003caca9701822e571a77a6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9d2a492d5d8faee8f8d6b1b07c8b7b328b4dbb04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d2a492d5d8faee8f8d6b1b07c8b7b328b4dbb04", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d2a492d5d8faee8f8d6b1b07c8b7b328b4dbb04", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d2a492d5d8faee8f8d6b1b07c8b7b328b4dbb04/comments", "author": null, "committer": null, "parents": [{"sha": "8268bba6f884dfcbcda28ab0f1500551d75399e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8268bba6f884dfcbcda28ab0f1500551d75399e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8268bba6f884dfcbcda28ab0f1500551d75399e7"}], "stats": {"total": 221, "additions": 78, "deletions": 143}, "files": [{"sha": "9fc58b7ea7fb4e9174b32941fa68e1684567055e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d2a492d5d8faee8f8d6b1b07c8b7b328b4dbb04/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d2a492d5d8faee8f8d6b1b07c8b7b328b4dbb04/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9d2a492d5d8faee8f8d6b1b07c8b7b328b4dbb04", "patch": "@@ -1,3 +1,7 @@\n+2004-03-19  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* tree.c (substitute_in_expr): Rewrite to simplify and be more generic.\n+\n 2004-03-19  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* fold-const.c (negate_expr): Move the handling of constants"}, {"sha": "1e386528e2b20c9deda8b7fdc22bcc9ecf599eb6", "filename": "gcc/tree.c", "status": "modified", "additions": 74, "deletions": 143, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d2a492d5d8faee8f8d6b1b07c8b7b328b4dbb04/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d2a492d5d8faee8f8d6b1b07c8b7b328b4dbb04/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=9d2a492d5d8faee8f8d6b1b07c8b7b328b4dbb04", "patch": "@@ -1951,165 +1951,96 @@ substitute_in_expr (tree exp, tree f, tree r)\n   tree new;\n   tree inner;\n \n-  switch (TREE_CODE_CLASS (code))\n+  /* We handle TREE_LIST and COMPONENT_REF separately.  */\n+  if (code == TREE_LIST)\n     {\n-    case 'c':\n-    case 'd':\n-      return exp;\n-\n-    case 'x':\n-      if (code == PLACEHOLDER_EXPR)\n+      op0 = (TREE_CHAIN (exp) == 0\n+\t     ? 0 : substitute_in_expr (TREE_CHAIN (exp), f, r));\n+      op1 = substitute_in_expr (TREE_VALUE (exp), f, r);\n+      if (op0 == TREE_CHAIN (exp) && op1 == TREE_VALUE (exp))\n \treturn exp;\n-      else if (code == TREE_LIST)\n-\t{\n-\t  op0 = (TREE_CHAIN (exp) == 0\n-\t\t ? 0 : substitute_in_expr (TREE_CHAIN (exp), f, r));\n-\t  op1 = substitute_in_expr (TREE_VALUE (exp), f, r);\n-\t  if (op0 == TREE_CHAIN (exp) && op1 == TREE_VALUE (exp))\n-\t    return exp;\n \n-\t  return tree_cons (TREE_PURPOSE (exp), op1, op0);\n-\t}\n-\n-      abort ();\n+      return tree_cons (TREE_PURPOSE (exp), op1, op0);\n+    }\n+  else if (code == COMPONENT_REF)\n+   {\n+     /* If this expression is getting a value from a PLACEHOLDER_EXPR\n+\tand it is the right field, replace it with R.  */\n+     for (inner = TREE_OPERAND (exp, 0);\n+\t  TREE_CODE_CLASS (TREE_CODE (inner)) == 'r';\n+\t  inner = TREE_OPERAND (inner, 0))\n+       ;\n+     if (TREE_CODE (inner) == PLACEHOLDER_EXPR\n+\t && TREE_OPERAND (exp, 1) == f)\n+       return r;\n+\n+     /* If this expression hasn't been completed let, leave it\n+\talone.  */\n+     if (TREE_CODE (inner) == PLACEHOLDER_EXPR && TREE_TYPE (inner) == 0)\n+       return exp;\n+\n+     op0 = substitute_in_expr (TREE_OPERAND (exp, 0), f, r);\n+     if (op0 == TREE_OPERAND (exp, 0))\n+       return exp;\n+\n+     new = fold (build (code, TREE_TYPE (exp), op0, TREE_OPERAND (exp, 1)));\n+   }\n+  else\n+    switch (TREE_CODE_CLASS (code))\n+      {\n+      case 'c':\n+      case 'd':\n+\treturn exp;\n \n-    case '1':\n-    case '2':\n-    case '<':\n-    case 'e':\n-      switch (TREE_CODE_LENGTH (code))\n-\t{\n-\tcase 1:\n-\t  op0 = substitute_in_expr (TREE_OPERAND (exp, 0), f, r);\n-\t  if (op0 == TREE_OPERAND (exp, 0))\n+      case 'x':\n+      case '1':\n+      case '2':\n+      case '<':\n+      case 'e':\n+      case 'r':\n+\tswitch (first_rtl_op (code))\n+\t  {\n+\t  case 0:\n \t    return exp;\n \n-\t  if (code == NON_LVALUE_EXPR)\n-\t    return op0;\n-\n-\t  new = fold (build1 (code, TREE_TYPE (exp), op0));\n-\t  break;\n+\t  case 1:\n+\t    op0 = substitute_in_expr (TREE_OPERAND (exp, 0), f, r);\n+\t    if (op0 == TREE_OPERAND (exp, 0))\n+\t      return exp;\n \n-\tcase 2:\n-\t  /* An RTL_EXPR cannot contain a PLACEHOLDER_EXPR; a CONSTRUCTOR\n-\t     could, but we don't support it.  */\n-\t  if (code == RTL_EXPR)\n-\t    return exp;\n-\t  else if (code == CONSTRUCTOR)\n-\t    abort ();\n+\t    new = fold (build1 (code, TREE_TYPE (exp), op0));\n+\t    break;\n \n-\t  op0 = TREE_OPERAND (exp, 0);\n-\t  op1 = TREE_OPERAND (exp, 1);\n-\t  if (CONTAINS_PLACEHOLDER_P (op0))\n-\t    op0 = substitute_in_expr (op0, f, r);\n-\t  if (CONTAINS_PLACEHOLDER_P (op1))\n-\t    op1 = substitute_in_expr (op1, f, r);\n+\t  case 2:\n+\t    op0 = substitute_in_expr (TREE_OPERAND (exp, 0), f, r);\n+\t    op1 = substitute_in_expr (TREE_OPERAND (exp, 1), f, r);\n \n-\t  if (op0 == TREE_OPERAND (exp, 0) && op1 == TREE_OPERAND (exp, 1))\n-\t    return exp;\n+\t    if (op0 == TREE_OPERAND (exp, 0) && op1 == TREE_OPERAND (exp, 1))\n+\t      return exp;\n \n-\t  new = fold (build (code, TREE_TYPE (exp), op0, op1));\n-\t  break;\n+\t    new = fold (build2 (code, TREE_TYPE (exp), op0, op1));\n+\t    break;\n \n-\tcase 3:\n-\t  /* It cannot be that anything inside a SAVE_EXPR contains a\n-\t     PLACEHOLDER_EXPR.  */\n-\t  if (code == SAVE_EXPR)\n-\t    return exp;\n+\t  case 3:\n+\t    op0 = substitute_in_expr (TREE_OPERAND (exp, 0), f, r);\n+\t    op1 = substitute_in_expr (TREE_OPERAND (exp, 1), f, r);\n+\t    op2 = substitute_in_expr (TREE_OPERAND (exp, 2), f, r);\n \n-\t  else if (code == CALL_EXPR)\n-\t    {\n-\t      op1 = substitute_in_expr (TREE_OPERAND (exp, 1), f, r);\n-\t      if (op1 == TREE_OPERAND (exp, 1))\n-\t\treturn exp;\n+\t    if (op0 == TREE_OPERAND (exp, 0) && op1 == TREE_OPERAND (exp, 1)\n+\t\t&& op2 == TREE_OPERAND (exp, 2))\n+\t      return exp;\n \n-\t      return build (code, TREE_TYPE (exp),\n-\t\t\t    TREE_OPERAND (exp, 0), op1, NULL_TREE);\n-\t    }\n+\t    new = fold (build3 (code, TREE_TYPE (exp), op0, op1, op2));\n+\t    break;\n \n-\t  else if (code != COND_EXPR)\n+\t  default:\n \t    abort ();\n+\t  }\n+\tbreak;\n \n-\t  op0 = TREE_OPERAND (exp, 0);\n-\t  op1 = TREE_OPERAND (exp, 1);\n-\t  op2 = TREE_OPERAND (exp, 2);\n-\n-\t  if (CONTAINS_PLACEHOLDER_P (op0))\n-\t    op0 = substitute_in_expr (op0, f, r);\n-\t  if (CONTAINS_PLACEHOLDER_P (op1))\n-\t    op1 = substitute_in_expr (op1, f, r);\n-\t  if (CONTAINS_PLACEHOLDER_P (op2))\n-\t    op2 = substitute_in_expr (op2, f, r);\n-\n-\t  if (op0 == TREE_OPERAND (exp, 0) && op1 == TREE_OPERAND (exp, 1)\n-\t      && op2 == TREE_OPERAND (exp, 2))\n-\t    return exp;\n-\n-\t  new = fold (build (code, TREE_TYPE (exp), op0, op1, op2));\n-\t  break;\n-\n-\tdefault:\n-\t  abort ();\n-\t}\n-\n-      break;\n-\n-    case 'r':\n-      switch (code)\n-\t{\n-\tcase COMPONENT_REF:\n-\t  /* If this expression is getting a value from a PLACEHOLDER_EXPR\n-\t     and it is the right field, replace it with R.  */\n-\t  for (inner = TREE_OPERAND (exp, 0);\n-\t       TREE_CODE_CLASS (TREE_CODE (inner)) == 'r';\n-\t       inner = TREE_OPERAND (inner, 0))\n-\t    ;\n-\t  if (TREE_CODE (inner) == PLACEHOLDER_EXPR\n-\t      && TREE_OPERAND (exp, 1) == f)\n-\t    return r;\n-\n-\t  /* If this expression hasn't been completed let, leave it\n-\t     alone.  */\n-\t  if (TREE_CODE (inner) == PLACEHOLDER_EXPR\n-\t      && TREE_TYPE (inner) == 0)\n-\t    return exp;\n-\n-\t  op0 = substitute_in_expr (TREE_OPERAND (exp, 0), f, r);\n-\t  if (op0 == TREE_OPERAND (exp, 0))\n-\t    return exp;\n-\n-\t  new = fold (build (code, TREE_TYPE (exp), op0,\n-\t\t\t     TREE_OPERAND (exp, 1)));\n-\t  break;\n-\n-\tcase BIT_FIELD_REF:\n-\t  op0 = substitute_in_expr (TREE_OPERAND (exp, 0), f, r);\n-\t  op1 = substitute_in_expr (TREE_OPERAND (exp, 1), f, r);\n-\t  op2 = substitute_in_expr (TREE_OPERAND (exp, 2), f, r);\n-\t  if (op0 == TREE_OPERAND (exp, 0) && op1 == TREE_OPERAND (exp, 1)\n-\t      && op2 == TREE_OPERAND (exp, 2))\n-\t    return exp;\n-\n-\t  new = fold (build (code, TREE_TYPE (exp), op0, op1, op2));\n-\t  break;\n-\n-\tcase INDIRECT_REF:\n-\tcase BUFFER_REF:\n-\t  op0 = substitute_in_expr (TREE_OPERAND (exp, 0), f, r);\n-\t  if (op0 == TREE_OPERAND (exp, 0))\n-\t    return exp;\n-\n-\t  new = fold (build1 (code, TREE_TYPE (exp), op0));\n-\t  break;\n-\n-\tdefault:\n-\t  abort ();\n-\t}\n-      break;\n-\n-    default:\n-      abort ();\n-    }\n+      default:\n+\tabort ();\n+      }\n \n   TREE_READONLY (new) = TREE_READONLY (exp);\n   return new;"}]}