{"sha": "d64f5a781f50a7c7625e91d2304359907f768eaa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDY0ZjVhNzgxZjUwYTdjNzYyNWU5MWQyMzA0MzU5OTA3Zjc2OGVhYQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-06-01T03:11:11Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-06-01T03:11:11Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r1133", "tree": {"sha": "3746aee78d0d132debe75282cb46b6c16dcd9eee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3746aee78d0d132debe75282cb46b6c16dcd9eee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d64f5a781f50a7c7625e91d2304359907f768eaa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d64f5a781f50a7c7625e91d2304359907f768eaa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d64f5a781f50a7c7625e91d2304359907f768eaa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d64f5a781f50a7c7625e91d2304359907f768eaa/comments", "author": null, "committer": null, "parents": [{"sha": "2f4aa534294046582e026d67f9e74d01124b66cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f4aa534294046582e026d67f9e74d01124b66cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f4aa534294046582e026d67f9e74d01124b66cb"}], "stats": {"total": 105, "additions": 89, "deletions": 16}, "files": [{"sha": "02f60ca867cbdd2a685e83e8ede098255c1ea1c3", "filename": "gcc/calls.c", "status": "modified", "additions": 89, "deletions": 16, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d64f5a781f50a7c7625e91d2304359907f768eaa/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d64f5a781f50a7c7625e91d2304359907f768eaa/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=d64f5a781f50a7c7625e91d2304359907f768eaa", "patch": "@@ -53,7 +53,10 @@ struct arg_data\n   /* Number of registers to use.  0 means put the whole arg in registers.\n      Also 0 if not passed in registers.  */\n   int partial;\n-  /* Non-zero if argument must be passed on stack.  */\n+  /* Non-zero if argument must be passed on stack.\n+     Note that some arguments may be passed on the stack\n+     even though pass_on_stack is zero, just because FUNCTION_ARG says so.\n+     pass_on_stack identifies arguments that *cannot* go in registers.  */\n   int pass_on_stack;\n   /* Offset of this argument from beginning of stack-args.  */\n   struct args_size offset;\n@@ -595,6 +598,14 @@ expand_call (exp, target, ignore)\n \t{\n \t  int i;\n \n+\t  /* Perform all cleanups needed for the arguments of this call\n+\t     (i.e. destructors in C++).  It is ok if these destructors\n+\t     clobber RETURN_VALUE_REG, because the only time we care about\n+\t     this is when TARGET is that register.  But in C++, we take\n+\t     care to never return that register directly.  */\n+\t  expand_cleanups_to (old_cleanups);\n+\n+#ifdef ACCUMULATE_OUTGOING_ARGS\n \t  /* If the outgoing argument list must be preserved, push\n \t     the stack before executing the inlined function if it\n \t     makes any calls.  */\n@@ -605,33 +616,52 @@ expand_call (exp, target, ignore)\n \n \t  if (stack_arg_under_construction || i >= 0)\n \t    {\n-\t      rtx insn, seq;\n+\t      rtx insn = NEXT_INSN (before_call), seq;\n \n-\t      for (insn = NEXT_INSN (before_call); insn;\n-\t\t   insn = NEXT_INSN (insn))\n-\t\tif (GET_CODE (insn) == CALL_INSN)\n-\t\t  break;\n+\t      /* Look for a call in the inline function code.\n+\t\t If OUTGOING_ARGS_SIZE (DECL_SAVED_INSNS (fndecl)) is\n+\t\t nonzero then there is a call and it is not necessary\n+\t\t to scan the insns.  */\n+\n+\t      if (OUTGOING_ARGS_SIZE (DECL_SAVED_INSNS (fndecl)) == 0)\n+\t\tfor (; insn; insn = NEXT_INSN (insn))\n+\t\t  if (GET_CODE (insn) == CALL_INSN)\n+\t\t    break;\n \n \t      if (insn)\n \t\t{\n+\t\t  /* Reserve enough stack space so that the largest\n+\t\t     argument list of any function call in the inline\n+\t\t     function does not overlap the argument list being\n+\t\t     evaluated.  This is usually an overestimate because\n+\t\t     allocate_dynamic_stack_space reserves space for an\n+\t\t     outgoing argument list in addition to the requested\n+\t\t     space, but there is no way to ask for stack space such\n+\t\t     that an argument list of a certain length can be\n+\t\t     safely constructed.  */\n+\n+\t\t  int adjust = OUTGOING_ARGS_SIZE (DECL_SAVED_INSNS (fndecl));\n+#ifdef REG_PARM_STACK_SPACE\n+\t\t  /* Add the stack space reserved for register arguments\n+\t\t     in the inline function.  What is really needed is the\n+\t\t     largest value of reg_parm_stack_space in the inline\n+\t\t     function, but that is not available.  Using the current\n+\t\t     value of reg_parm_stack_space is wrong, but gives\n+\t\t     correct results on all supported machines.  */\n+\t\t  adjust += reg_parm_stack_space;\n+#endif\n \t\t  start_sequence ();\n \t\t  emit_stack_save (SAVE_BLOCK, &old_stack_level, 0);\n \t\t  allocate_dynamic_stack_space (gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t\t\t\t highest_outgoing_arg_in_use),\n+\t\t\t\t\t\t\t adjust),\n \t\t\t\t\t\t0, BITS_PER_UNIT);\n \t\t  seq = get_insns ();\n \t\t  end_sequence ();\n \t\t  emit_insns_before (seq, NEXT_INSN (before_call));\n \t\t  emit_stack_restore (SAVE_BLOCK, old_stack_level, 0);\n \t\t}\n \t    }\n-\n-\t  /* Perform all cleanups needed for the arguments of this call\n-\t     (i.e. destructors in C++).  It is ok if these destructors\n-\t     clobber RETURN_VALUE_REG, because the only time we care about\n-\t     this is when TARGET is that register.  But in C++, we take\n-\t     care to never return that register directly.  */\n-\t  expand_cleanups_to (old_cleanups);\n+#endif\n \n \t  /* If the result is equivalent to TARGET, return TARGET to simplify\n \t     checks in store_expr.  They can be equivalent but not equal in the\n@@ -743,11 +773,16 @@ expand_call (exp, target, ignore)\n      as if it were an extra parameter.  */\n   if (structure_value_addr && struct_value_rtx == 0)\n     {\n+#ifdef ACCUMULATE_OUTGOING_ARGS\n       /* If the stack will be adjusted, make sure the structure address\n \t does not refer to virtual_outgoing_args_rtx.  */\n       rtx temp = (stack_arg_under_construction\n \t\t  ? copy_addr_to_reg (structure_value_addr)\n \t\t  : force_reg (Pmode, structure_value_addr));\n+#else\n+      rtx temp = force_reg (Pmode, structure_value_addr);\n+#endif\n+\n       actparms\n \t= tree_cons (error_mark_node,\n \t\t     make_tree (build_pointer_type (TREE_TYPE (funtype)),\n@@ -1111,11 +1146,13 @@ expand_call (exp, target, ignore)\n \t  emit_stack_save (SAVE_BLOCK, &old_stack_level, 0);\n \t  old_pending_adj = pending_stack_adjust;\n \t  pending_stack_adjust = 0;\n+#ifdef ACCUMULATE_OUTGOING_ARGS\n \t  /* stack_arg_under_construction says whether a stack arg is\n \t     being constructed at the old stack level.  Pushing the stack\n \t     gets a clean outgoing argument block.  */\n \t  old_stack_arg_under_construction = stack_arg_under_construction;\n \t  stack_arg_under_construction = 0;\n+#endif\n \t}\n       argblock = push_block (ARGS_SIZE_RTX (args_size), 0, 0);\n     }\n@@ -1273,13 +1310,18 @@ expand_call (exp, target, ignore)\n #endif\n #endif\n \n+#ifdef ACCUMULATE_OUTGOING_ARGS\n   /* The save/restore code in store_one_arg handles all cases except one:\n      a constructor call (including a C function returning a BLKmode struct)\n      to initialize an argument.  */\n   if (stack_arg_under_construction)\n     {\n+#if defined(REG_PARM_STACK_SPACE) && ! defined(OUTGOING_REG_PARM_STACK_SPACE)\n       rtx push_size = gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t       highest_outgoing_arg_in_use);\n+\t\t\t       reg_parm_stack_space + args_size.constant);\n+#else\n+      rtx push_size = gen_rtx (CONST_INT, VOIDmode, args_size.constant);\n+#endif\n       if (old_stack_level == 0)\n \t{\n \t  emit_stack_save (SAVE_BLOCK, &old_stack_level, 0);\n@@ -1297,6 +1339,7 @@ expand_call (exp, target, ignore)\n \t}\n       allocate_dynamic_stack_space (push_size, 0, BITS_PER_UNIT);\n     }\n+#endif\n \n   /* Don't try to defer pops if preallocating, not even from the first arg,\n      since ARGBLOCK probably refers to the SP.  */\n@@ -1635,9 +1678,11 @@ expand_call (exp, target, ignore)\n     {\n       emit_stack_restore (SAVE_BLOCK, old_stack_level, 0);\n       pending_stack_adjust = old_pending_adj;\n+#ifdef ACCUMULATE_OUTGOING_ARGS\n       stack_arg_under_construction = old_stack_arg_under_construction;\n       highest_outgoing_arg_in_use = initial_highest_arg_in_use;\n       stack_usage_map = initial_stack_usage_map;\n+#endif\n     }\n #ifdef ACCUMULATE_OUTGOING_ARGS\n   else\n@@ -1849,7 +1894,35 @@ store_one_arg (arg, argblock, may_be_alloca, variable_size, fndecl,\n   /* If this is being passes partially in a register, we can't evaluate\n      it directly into its stack slot.  Otherwise, we can.  */\n   if (arg->value == 0)\n-    arg->value = expand_expr (pval, partial ? 0 : arg->stack, VOIDmode, 0);\n+    {\n+#ifdef ACCUMULATE_OUTGOING_ARGS\n+      /* stack_arg_under_construction is nonzero if a function argument is\n+\t being evaluated directly into the outgoing argument list and\n+\t expand_call must take special action to preserve the argument list\n+\t if it is called recursively.\n+\n+\t For scalar function arguments stack_usage_map is sufficient to\n+\t determine which stack slots must be saved and restored.  Scalar\n+\t arguments in general have pass_on_stack == 0.\n+\n+\t If this argument is initialized by a function which takes the\n+\t address of the argument (a C++ constructor or a C function\n+\t returning a BLKmode structure), then stack_usage_map is\n+\t insufficient and expand_call must push the stack around the\n+\t function call.  Such arguments have pass_on_stack == 1.\n+\n+\t Note that it is always safe to set stack_arg_under_construction,\n+\t but this generates suboptimal code if set when not needed.  */\n+\n+      if (arg->pass_on_stack)\n+\tstack_arg_under_construction++;\n+#endif\n+      arg->value = expand_expr (pval, partial ? 0 : arg->stack, VOIDmode, 0);\n+#ifdef ACCUMULATE_OUTGOING_ARGS\n+      if (arg->pass_on_stack)\n+\tstack_arg_under_construction--;\n+#endif\n+    }\n \n   /* Don't allow anything left on stack from computation\n      of argument to alloca.  */"}]}