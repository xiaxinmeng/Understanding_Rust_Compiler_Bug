{"sha": "804a8ee0f5472206a89b2fe3f958a35c0b49adf5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODA0YThlZTBmNTQ3MjIwNmE4OWIyZmUzZjk1OGEzNWMwYjQ5YWRmNQ==", "commit": {"author": {"name": "Stan Cox", "email": "coxs@gnu.org", "date": "1996-08-02T21:27:07Z"}, "committer": {"name": "Stan Cox", "email": "coxs@gnu.org", "date": "1996-08-02T21:27:07Z"}, "message": "(output_float_compare): fcomi should be followed by the correct conditional jump instead of fcom/pfstsw/and/jne\n\n(output_float_compare): fcomi should be followed by the\ncorrect conditional jump instead of fcom/pfstsw/and/jne\n(override_options): Added -mbranch-cost to set BRANCH_COST.\n\nFrom-SVN: r12585", "tree": {"sha": "ea311272e6c81d4eafd2f08c59f79d2a48ac3287", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ea311272e6c81d4eafd2f08c59f79d2a48ac3287"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/804a8ee0f5472206a89b2fe3f958a35c0b49adf5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/804a8ee0f5472206a89b2fe3f958a35c0b49adf5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/804a8ee0f5472206a89b2fe3f958a35c0b49adf5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/804a8ee0f5472206a89b2fe3f958a35c0b49adf5/comments", "author": null, "committer": null, "parents": [{"sha": "e2a606cb27a100bb5fd96dcd62da9b2c1e2f4b57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2a606cb27a100bb5fd96dcd62da9b2c1e2f4b57", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2a606cb27a100bb5fd96dcd62da9b2c1e2f4b57"}], "stats": {"total": 21, "additions": 21, "deletions": 0}, "files": [{"sha": "8a84fe198fa39cffda2fc1edf73862d4c409684d", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/804a8ee0f5472206a89b2fe3f958a35c0b49adf5/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/804a8ee0f5472206a89b2fe3f958a35c0b49adf5/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=804a8ee0f5472206a89b2fe3f958a35c0b49adf5", "patch": "@@ -143,10 +143,12 @@ int i386_regparm;\t\t\t\t/* i386_regparm_string as a number */\n char *i386_align_loops_string;\t\t\t/* power of two alignment for loops */\n char *i386_align_jumps_string;\t\t\t/* power of two alignment for non-loop jumps */\n char *i386_align_funcs_string;\t\t\t/* power of two alignment for functions */\n+char *i386_branch_cost_string;\t\t\t/* values 1-5: see jump.c */\n \n int i386_align_loops;\t\t\t\t/* power of two alignment for loops */\n int i386_align_jumps;\t\t\t\t/* power of two alignment for non-loop jumps */\n int i386_align_funcs;\t\t\t\t/* power of two alignment for functions */\n+int i386_branch_cost;\t\t\t\t/* values 1-5: see jump.c */\n \n /* Sometimes certain combinations of command options do not make\n    sense on a particular target machine.  You can define a macro\n@@ -293,6 +295,17 @@ override_options ()\n   else\n     i386_align_funcs = def_align;\n \n+  /* Validate -mbranch-cost= value, or provide default */\n+  if (i386_branch_cost_string)\n+    {\n+      i386_branch_cost = atoi (i386_branch_cost_string);\n+      if (i386_branch_cost < 0 || i386_branch_cost > 5)\n+\tfatal (\"-mbranch-cost=%d is not between 0 and 5\",\n+\t       i386_branch_cost);\n+    }\n+  else\n+    i386_branch_cost = TARGET_PENTIUMPRO ? 4 : 1;\n+\n   if (TARGET_OMIT_LEAF_FRAME_POINTER)\t/* keep nonleaf frame pointers */\n     flag_omit_frame_pointer = 1;\n \n@@ -3549,6 +3562,7 @@ output_float_compare (insn, operands)\n   rtx body = XVECEXP (PATTERN (insn), 0, 0);\n   int unordered_compare = GET_MODE (SET_SRC (body)) == CCFPEQmode;\n   int target_fcomi = TARGET_CMOVE && STACK_REG_P (operands[1]);\n+  int target_fcomi = TARGET_CMOVE && STACK_REG_P (operands[1]);\n \n   rtx tmp;\n   if (! STACK_TOP_P (operands[0]))\n@@ -3598,6 +3612,13 @@ output_float_compare (insn, operands)\n \tstrcat (buf, \"p\");\n \n       if (NON_STACK_REG_P (operands[1]))\n+      else if (target_fcomi) \n+\t{\n+\t  rtx xops[] = {operands[0], operands[1], operands[0]};\n+\t  \n+\t  output_asm_insn (strcat (buf, AS2 (%z1,%y1,%2)), xops);\n+\t  RET;\n+\t}\n \toutput_op_from_reg (operands[1], strcat (buf, AS1 (%z0,%1)));\n       else if (target_fcomi) \n \t{"}]}