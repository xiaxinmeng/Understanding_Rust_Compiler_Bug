{"sha": "bf52625270191076a533142d3dbfb611ef0f16e4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmY1MjYyNTI3MDE5MTA3NmE1MzMxNDJkM2RiZmI2MTFlZjBmMTZlNA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-07-31T12:18:06Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-07-31T12:18:06Z"}, "message": "(reposition_prologue_and_epilogue_notes): Search for the notes without using...\n\n(reposition_prologue_and_epilogue_notes): Search for the notes without\nusing basic_block_end[0] or basic_block_head[N-1].\n\nFrom-SVN: r1735", "tree": {"sha": "138d55fdb9dffd8e8340ec5f3b4b48bd239137ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/138d55fdb9dffd8e8340ec5f3b4b48bd239137ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bf52625270191076a533142d3dbfb611ef0f16e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf52625270191076a533142d3dbfb611ef0f16e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf52625270191076a533142d3dbfb611ef0f16e4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf52625270191076a533142d3dbfb611ef0f16e4/comments", "author": null, "committer": null, "parents": [{"sha": "6842690ec1e2d820ee646395fac65be4ad7e79c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6842690ec1e2d820ee646395fac65be4ad7e79c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6842690ec1e2d820ee646395fac65be4ad7e79c2"}], "stats": {"total": 82, "additions": 49, "deletions": 33}, "files": [{"sha": "92502eb9369395c4fd4a10938a0d6992c756cacb", "filename": "gcc/function.c", "status": "modified", "additions": 49, "deletions": 33, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf52625270191076a533142d3dbfb611ef0f16e4/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf52625270191076a533142d3dbfb611ef0f16e4/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=bf52625270191076a533142d3dbfb611ef0f16e4", "patch": "@@ -4379,58 +4379,74 @@ reposition_prologue_and_epilogue_notes (f)\n   if (n_basic_blocks)\n     {\n       rtx next, prev;\n+      int len;\n \n       if (prologue)\n \t{\n-\t  register rtx insn, end_prologue;\n-\n-\t  /* From the end of the first basic block, search backward for a\n-\t     prologue insn.  */\n-\t  for (insn = NEXT_INSN (PREV_INSN (basic_block_end[0]));\n-\t       insn; insn = prev_nonnote_insn (insn))\n-\t    if (contains (insn, prologue))\n+\t  register rtx insn, note = 0;\n+\n+\t  /* Scan from the beginning until we reach the last prologue insn.\n+\t     We apparently can't depend on basic_block_{head,end} after\n+\t     reorg has run.  */\n+\t  for (len = 0; prologue[len]; len++)\n+\t    ;\n+\t  for (insn = f; insn; insn = NEXT_INSN (insn))\n+\t    if (GET_CODE (insn) == NOTE)\n+\t      {\n+\t\tif (NOTE_LINE_NUMBER (insn) == NOTE_INSN_PROLOGUE_END)\n+\t\t  note = insn;\n+\t      }\n+\t    else if (contains (insn, prologue) && --len == 0)\n \t      {\n-\t\tend_prologue = insn;\n-\t\t/* Find the prologue-end note and move it to just after the\n-\t\t   last prologue insn.  */\n-\t\tfor (insn = f; insn; insn = NEXT_INSN (insn))\n-\t\t  if (GET_CODE (insn) == NOTE\n-\t\t      && NOTE_LINE_NUMBER (insn) == NOTE_INSN_PROLOGUE_END)\n-\t\t    break;\n-\t\tnext = NEXT_INSN (insn);\n-\t\tprev = PREV_INSN (insn);\n+\t\t/* Find the prologue-end note if we haven't already, and\n+\t\t   move it to just after the last prologue insn.  */\n+\t\tif (note == 0)\n+\t\t  for (note = insn; note = NEXT_INSN (note);)\n+\t\t    if (GET_CODE (note) == NOTE\n+\t\t\t&& NOTE_LINE_NUMBER (note) == NOTE_INSN_PROLOGUE_END)\n+\t\t      break;\n+\t\tnext = NEXT_INSN (note);\n+\t\tprev = PREV_INSN (note);\n \t\tif (prev)\n \t\t  NEXT_INSN (prev) = next;\n \t\tif (next)\n \t\t  PREV_INSN (next) = prev;\n-\t\tadd_insn_after (insn, end_prologue);\n+\t\tadd_insn_after (note, insn);\n \t\tbreak;\n \t      }\n \t}\n \n       if (epilogue)\n \t{\n-\t  register rtx insn, beg_epilogue;\n-\n-\t  /* From the start of the last basic block, search forward for an\n-\t     epilogue insn.  */\n-\t  for (insn = PREV_INSN (NEXT_INSN (basic_block_head[n_basic_blocks - 1]));\n-\t       insn; insn = next_nonnote_insn (insn))\n-\t    if (beg_epilogue = contains (insn, epilogue))\n+\t  register rtx insn, note = 0;\n+\n+\t  /* Scan from the end until we reach the first epilogue insn.\n+\t     We apparently can't depend on basic_block_{head,end} after\n+\t     reorg has run.  */\n+\t  for (len = 0; epilogue[len]; len++)\n+\t    ;\n+\t  for (insn = get_last_insn (); insn; insn = PREV_INSN (insn))\n+\t    if (GET_CODE (insn) == NOTE)\n+\t      {\n+\t\tif (NOTE_LINE_NUMBER (insn) == NOTE_INSN_EPILOGUE_BEG)\n+\t\t  note = insn;\n+\t      }\n+\t    else if (contains (insn, epilogue) && --len == 0)\n \t      {\n-\t\t/* Find the epilogue-begin note and move it to just before\n-\t\t   the first epilogue insn.  */\n-\t\tfor (insn = get_last_insn (); insn; insn = PREV_INSN (insn))\n-\t\t  if (GET_CODE (insn) == NOTE\n-\t\t      && NOTE_LINE_NUMBER (insn) == NOTE_INSN_EPILOGUE_BEG)\n-\t\t    break;\n-\t\tnext = NEXT_INSN (insn);\n-\t\tprev = PREV_INSN (insn);\n+\t\t/* Find the epilogue-begin note if we haven't already, and\n+\t\t   move it to just before the first epilogue insn.  */\n+\t\tif (note == 0)\n+\t\t  for (note = insn; note = PREV_INSN (note);)\n+\t\t    if (GET_CODE (note) == NOTE\n+\t\t\t&& NOTE_LINE_NUMBER (note) == NOTE_INSN_EPILOGUE_BEG)\n+\t\t      break;\n+\t\tnext = NEXT_INSN (note);\n+\t\tprev = PREV_INSN (note);\n \t\tif (prev)\n \t\t  NEXT_INSN (prev) = next;\n \t\tif (next)\n \t\t  PREV_INSN (next) = prev;\n-\t\tadd_insn_after (insn, PREV_INSN (beg_epilogue));\n+\t\tadd_insn_after (note, PREV_INSN (insn));\n \t\tbreak;\n \t      }\n \t}"}]}