{"sha": "bf7b5747bb33b0333786dfcc015e0f23136e5f18", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmY3YjU3NDdiYjMzYjAzMzM3ODZkZmNjMDE1ZTBmMjMxMzZlNWYxOA==", "commit": {"author": {"name": "Sriraman Tallam", "email": "tmsriram@google.com", "date": "2013-10-15T21:43:21Z"}, "committer": {"name": "Sriraman Tallam", "email": "tmsriram@gcc.gnu.org", "date": "2013-10-15T21:43:21Z"}, "message": "re PR target/57756 (Function target attribute is retaining  state of previously seen function)\n\nPR target/57756\n\nThe root-cause of this PR is that global_options is not restored to\ndefault before calling ix86_valid_target_attribute_tree and hence\ntarget attributes are incorrectly processed sometimes.\n\nThis patch refactors code in i386.c in functions in the call-chain of \nix86_valid_target_attribute_tree to use any gcc_options struct passed\nas a parameter. It replaces existing code which always uses the\nglobal_options struct.\n\n2013-10-15 Sriraman Tallam  <tmsriram@google.com>\n\n\tPR target/57756\n\t* optc-save-gen.awk: Add extra parameter to the save and restore\n\ttarget calls.\n\t* opth-gen.awk: Generate new TARGET_* macros  to accept a parameter.\n\t* tree.c (build_optimization_node): New parameter.  Add extra parameter\n\tto call to cl_optimization_save.\n\t(build_target_option_node): New parameter. Add extra parameter\n\tto call to cl_target_option_save.\n\t* tree.h (build_optimization_node): New parameter.\n\t(build_target_option_node): New parameter.\n\t* c-family/c-common.c (handle_optimize_attribute): Fix calls to\n\tbuild_optimization_node and build_target_option_node.\n\t* c-family/c-pragma.c (handle_pragma_optimize): Ditto.\n\t(handle_pragma_push_options): Ditto.\n\t* toplev.c (process_options): Ditto.\n\t* opts.c (init_options_struct): Check for opts_set non-null.\n\t* target.def (target_option.save): New parameter.\n\t(target_option.restore): New parameter.\n\t* tm.texi: Generate.\n\t* config/i386/i386-c.c (ix86_target_macros_internal): Ditto.\n\t(ix86_pragma_target_parse): Ditto.\n\t* config/i386/i386-protos.h (ix86_valid_target_attribute_tree): New\n\tparameters.\n\t* config/rs6000/rs6000.c (rs6000_option_override_internal): Fix calls\n\tto  build_optimization_node and build_target_option_node.\n\t(rs6000_valid_attribute_p): Ditto.\n\t(rs6000_pragma_target_parse): Ditto.\n\t* config/i386/i386.opt (x_ix86_target_flags_explicit): New TargetSave\n\tdata.\n\t* config/i386/i386.h:\n\tTARGET_64BIT_P: New Macro\n\tTARGET_MMX_P: New Macro.\n\tTARGET_3DNOW_P: New Macro.\n\tTARGET_3DNOW_A_P: New Macro.\n\tTARGET_SSE_P: New Macro.\n\tTARGET_SSE2_P: New Macro.\n\tTARGET_SSE3_P: New Macro.\n\tTARGET_SSSE3_P: New Macro.\n\tTARGET_SSE4_1_P: New Macro.\n\tTARGET_SSE4_2_P: New Macro.\n\tTARGET_AVX_P: New Macro.\n\tTARGET_AVX2_P: New Macro.\n\tTARGET_AVX512F_P: New Macro.\n\tTARGET_AVX512PF_P: New Macro.\n\tTARGET_AVX512ER_P: New Macro.\n\tTARGET_AVX512CD_P: New Macro.\n\tTARGET_FMA_P: New Macro.\n\tTARGET_SSE4A_P: New Macro.\n\tTARGET_FMA4_P: New Macro.\n\tTARGET_XOP_P: New Macro.\n\tTARGET_LWP_P: New Macro.\n\tTARGET_ABM_P: New Macro.\n\tTARGET_BMI_P: New Macro.\n\tTARGET_BMI2_P: New Macro.\n\tTARGET_LZCNT_P: New Macro.\n\tTARGET_TBM_P: New Macro.\n\tTARGET_POPCNT_P: New Macro.\n\tTARGET_SAHF_P: New Macro.\n\tTARGET_MOVBE_P: New Macro.\n\tTARGET_CRC32_P: New Macro.\n\tTARGET_AES_P: New Macro.\n\tTARGET_PCLMUL_P: New Macro.\n\tTARGET_CMPXCHG16B_P: New Macro.\n\tTARGET_FSGSBASE_P: New Macro.\n\tTARGET_RDRND_P: New Macro.\n\tTARGET_F16C_P: New Macro.\n\tTARGET_RTM_P: New Macro.\n\tTARGET_HLE_P: New Macro.\n\tTARGET_RDSEED_P: New Macro.\n\tTARGET_PRFCHW_P: New Macro.\n\tTARGET_ADX_P: New Macro.\n\tTARGET_FXSR_P: New Macro.\n\tTARGET_XSAVE_P: New Macro.\n\tTARGET_XSAVEOPT_P: New Macro.\n\tTARGET_LP64_P: New Macro.\n\tTARGET_X32_P: New Macro.\n\tTARGET_FPMATH_DEFAULT_P: New Macro.\n\tTARGET_FLOAT_RETURNS_IN_80387_P: New Macro.\n\t* config/i386/i386.c (ix86_option_override_internal): New parameters.\n\topts and opts_set.\n\tChange ix86_tune_string to access opts->x_ix86_tune_string.\n\tChange ix86_isa_flags to access opts->x_ix86_isa_flags.\n\tChange ix86_arch_string to access opts->x_ix86_arch_string.\n\tChange ix86_stringop_alg to access opts->x_ix86_stringop_alg.\n\tChange ix86_pmode to access opts->x_ix86_pmode.\n\tChange ix86_abi to access opts->x_ix86_abi.\n\tChange ix86_cmodel to access opts->x_ix86_cmodel.\n\tChange ix86_asm_dialect to access opts->x_ix86_asm_dialect.\n\tChange ix86_isa_flags_explicit to access\n\topts->x_ix86_isa_flags_explicit.\n\tChange ix86_dump_tunes to access opts->x_ix86_dump_tunes.\n\tChange ix86_regparm to access opts->x_ix86_regparm.\n\tChange ix86_branch_cost to access opts->x_ix86_branch_cost.\n\tChange ix86_preferred_stack_boundary_arg to access\n\topts->x_ix86_preferred_stack_boundary_arg.\n\tChange ix86_force_align_arg_pointer to access\n\topts->x_ix86_force_align_arg_pointer.\n\tChange ix86_incoming_stack_boundar_arg to access\n\topts->x_ix86_incoming_stack_boundar_arg.\n\tChange ix86_fpmath to access opts->x_ix86_fpmath.\n\tChange ix86_veclibabi_type to access opts->x_ix86_veclibabi_type.\n\tChange ix86_recip_name to access opts->x_ix86_recip_name.\n\tChange ix86_stack_protector_guard to access\n\topts->x_ix86_stack_protector_guard.\n\tChange ix86_tune_memcpy_strategy to access\n\topts->x_ix86_tune_memcpy_strategy.\n\tChange ix86_tune_memset_strategy to access\n\topts->x_ix86_tune_memset_strategy.\n\tChange global_options to access opts.\n\tChange global_options_set to access opts_set.\n        Change TARGET_64BIT to TARGET_64BIT_P (opts->...)\n        Change TARGET_MMX to TARGET_MMX_P (opts->...)\n        Change TARGET_3DNOW to TARGET_3DNOW_P (opts->...)\n        Change TARGET_3DNOW_A to TARGET_3DNOW_A_P (opts->...)\n        Change TARGET_SSE to TARGET_SSE_P (opts->...)\n        Change TARGET_SSE2 to TARGET_SSE2_P (opts->...)\n        Change TARGET_SSE3 to TARGET_SSE3_P (opts->...)\n        Change TARGET_SSSE3 to TARGET_SSSE3_P (opts->...)\n        Change TARGET_SSE4_1 to TARGET_SSE4_1_P (opts->...)\n        Change TARGET_SSE4_2 to TARGET_SSE4_2_P (opts->...)\n        Change TARGET_AVX to TARGET_AVX_P (opts->...)\n        Change TARGET_AVX2 to TARGET_AVX2_P (opts->...)\n        Change TARGET_AVX512F to TARGET_AVX512F_P (opts->...)\n        Change TARGET_AVX512PF to TARGET_AVX512PF_P (opts->...)\n        Change TARGET_AVX512ER to TARGET_AVX512ER_P (opts->...)\n        Change TARGET_AVX512CD to TARGET_AVX512CD_P (opts->...)\n        Change TARGET_FMA to TARGET_FMA_P (opts->...)\n        Change TARGET_SSE4A to TARGET_SSE4A_P (opts->...)\n        Change TARGET_FMA4 to TARGET_FMA4_P (opts->...)\n        Change TARGET_XOP to TARGET_XOP_P (opts->...)\n        Change TARGET_LWP to TARGET_LWP_P (opts->...)\n        Change TARGET_ABM to TARGET_ABM_P (opts->...)\n        Change TARGET_BMI to TARGET_BMI_P (opts->...)\n        Change TARGET_BMI2 to TARGET_BMI2_P (opts->...)\n        Change TARGET_LZCNT to TARGET_LZCNT_P (opts->...)\n        Change TARGET_TBM to TARGET_TBM_P (opts->...)\n        Change TARGET_POPCNT to TARGET_POPCNT_P (opts->...)\n        Change TARGET_SAHF to TARGET_SAHF_P (opts->...)\n        Change TARGET_MOVBE to TARGET_MOVBE_P (opts->...)\n        Change TARGET_CRC32 to TARGET_CRC32_P (opts->...)\n        Change TARGET_AES to TARGET_AES_P (opts->...)\n        Change TARGET_PCLMUL to TARGET_PCLMUL_P (opts->...)\n        Change TARGET_CMPXCHG16B to TARGET_CMPXCHG16B_P (opts->...)\n        Change TARGET_FSGSBASE to TARGET_FSGSBASE_P (opts->...)\n        Change TARGET_RDRND to TARGET_RDRND_P (opts->...)\n        Change TARGET_F16C to TARGET_F16C_P (opts->...)\n        Change TARGET_RTM to TARGET_RTM_P (opts->...)\n        Change TARGET_HLE to TARGET_HLE_P (opts->...)\n        Change TARGET_RDSEED to TARGET_RDSEED_P (opts->...)\n        Change TARGET_PRFCHW to TARGET_PRFCHW_P (opts->...)\n        Change TARGET_ADX to TARGET_ADX_P (opts->...)\n        Change TARGET_FXSR to TARGET_FXSR_P (opts->...)\n        Change TARGET_XSAVE to TARGET_XSAVE_P (opts->...)\n        Change TARGET_XSAVEOPT to TARGET_XSAVEOPT_P (opts->...)\n        Change TARGET_LP64 to TARGET_LP64_P (opts->...)\n        Change TARGET_X32 to TARGET_X32_P (opts->...)\n        Change TARGET_FPMATH_DEFAULT to TARGET_FPMATH_DEFAULT_P (opts->...)\n        Change TARGET_FLOAT_RETURNS_IN_80387 to\n\t TARGET_FLOAT_RETURNS_IN_80387_P (opts->...)\n\t(ix86_function_specific_save): New parameter. Use opts-> fields\n\tto replace global fields.\n\t(ix86_function_specific_restore): Ditto.\n\t(ix86_valid_target_attribute_inner_p): New parameters.\n\tFix recursive call.\n\tFix call to ix86_handle_option and set_option.\n\t(ix86_valid_target_attribute_tree): New parameters.\n\tChange global_options to access opts.\n\tChange global_options_set to access opts_set.\n\tFix call to ix86_valid_target_attribute_inner_p.\n\tChange ix86_tune_string to access opts->x_ix86_tune_string.\n\tChange ix86_arch_string to access opts->x_ix86_arch_string.\n\tChange ix86_fpmath to access opts->x_ix86_fpmath\n\tFix call to ix86_option_override_internal.\n\tFix call to ix86_add_new_builtins.\n\tFix calls to build_optimization_node and build_target_option_node.\n\t(ix86_valid_target_attribute_p): Remove access to global_options.\n\tUse new gcc_options structure func_options.\n\tFix call to ix86_valid_target_attribute_tree.\n\tFix call to  build_optimization_node.\n\t(get_builtin_code_for_version):\tFix call to\n\tix86_valid_target_attribute_tree.\n\n\tPR target/57756\n\t* gcc.target/i386/pr57756.c: New test.\n\t* gcc.target/i386/pr57756_2.c: New test.\n\nFrom-SVN: r203634", "tree": {"sha": "a477f9a27d48ee4ba1cc4467851ca422df60df96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a477f9a27d48ee4ba1cc4467851ca422df60df96"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bf7b5747bb33b0333786dfcc015e0f23136e5f18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf7b5747bb33b0333786dfcc015e0f23136e5f18", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf7b5747bb33b0333786dfcc015e0f23136e5f18", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf7b5747bb33b0333786dfcc015e0f23136e5f18/comments", "author": {"login": "tmsri", "id": 38991943, "node_id": "MDQ6VXNlcjM4OTkxOTQz", "avatar_url": "https://avatars.githubusercontent.com/u/38991943?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmsri", "html_url": "https://github.com/tmsri", "followers_url": "https://api.github.com/users/tmsri/followers", "following_url": "https://api.github.com/users/tmsri/following{/other_user}", "gists_url": "https://api.github.com/users/tmsri/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmsri/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmsri/subscriptions", "organizations_url": "https://api.github.com/users/tmsri/orgs", "repos_url": "https://api.github.com/users/tmsri/repos", "events_url": "https://api.github.com/users/tmsri/events{/privacy}", "received_events_url": "https://api.github.com/users/tmsri/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a7d35bd6bd6622f7a972c4cbab7c26a0b1ef4f98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7d35bd6bd6622f7a972c4cbab7c26a0b1ef4f98", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7d35bd6bd6622f7a972c4cbab7c26a0b1ef4f98"}], "stats": {"total": 1271, "additions": 863, "deletions": 408}, "files": [{"sha": "69974613ea09dac338c3c561d59be992443450ea", "filename": "gcc/ChangeLog", "status": "modified", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf7b5747bb33b0333786dfcc015e0f23136e5f18/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf7b5747bb33b0333786dfcc015e0f23136e5f18/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bf7b5747bb33b0333786dfcc015e0f23136e5f18", "patch": "@@ -1,3 +1,187 @@\n+2013-10-15 Sriraman Tallam  <tmsriram@google.com>\n+\n+\tPR target/57756\n+\t* optc-save-gen.awk: Add extra parameter to the save and restore\n+\ttarget calls.\n+\t* opth-gen.awk: Generate new TARGET_* macros  to accept a parameter.\n+\t* tree.c (build_optimization_node): New parameter.  Add extra parameter\n+\tto call to cl_optimization_save.\n+\t(build_target_option_node): New parameter. Add extra parameter\n+\tto call to cl_target_option_save.\n+\t* tree.h (build_optimization_node): New parameter.\n+\t(build_target_option_node): New parameter.\n+\t* c-family/c-common.c (handle_optimize_attribute): Fix calls to\n+\tbuild_optimization_node and build_target_option_node.\n+\t* c-family/c-pragma.c (handle_pragma_optimize): Ditto.\n+\t(handle_pragma_push_options): Ditto.\n+\t* toplev.c (process_options): Ditto.\n+\t* opts.c (init_options_struct): Check for opts_set non-null.\n+\t* target.def (target_option.save): New parameter.\n+\t(target_option.restore): New parameter.\n+\t* tm.texi: Generate.\n+\t* config/i386/i386-c.c (ix86_target_macros_internal): Ditto.\n+\t(ix86_pragma_target_parse): Ditto.\n+\t* config/i386/i386-protos.h (ix86_valid_target_attribute_tree): New\n+\tparameters.\n+\t* config/rs6000/rs6000.c (rs6000_option_override_internal): Fix calls\n+\tto  build_optimization_node and build_target_option_node.\n+\t(rs6000_valid_attribute_p): Ditto.\n+\t(rs6000_pragma_target_parse): Ditto.\n+\t* config/i386/i386.opt (x_ix86_target_flags_explicit): New TargetSave\n+\tdata.\n+\t* config/i386/i386.h:\n+\tTARGET_64BIT_P: New Macro\n+\tTARGET_MMX_P: New Macro.\n+\tTARGET_3DNOW_P: New Macro.\n+\tTARGET_3DNOW_A_P: New Macro.\n+\tTARGET_SSE_P: New Macro.\n+\tTARGET_SSE2_P: New Macro.\n+\tTARGET_SSE3_P: New Macro.\n+\tTARGET_SSSE3_P: New Macro.\n+\tTARGET_SSE4_1_P: New Macro.\n+\tTARGET_SSE4_2_P: New Macro.\n+\tTARGET_AVX_P: New Macro.\n+\tTARGET_AVX2_P: New Macro.\n+\tTARGET_AVX512F_P: New Macro.\n+\tTARGET_AVX512PF_P: New Macro.\n+\tTARGET_AVX512ER_P: New Macro.\n+\tTARGET_AVX512CD_P: New Macro.\n+\tTARGET_FMA_P: New Macro.\n+\tTARGET_SSE4A_P: New Macro.\n+\tTARGET_FMA4_P: New Macro.\n+\tTARGET_XOP_P: New Macro.\n+\tTARGET_LWP_P: New Macro.\n+\tTARGET_ABM_P: New Macro.\n+\tTARGET_BMI_P: New Macro.\n+\tTARGET_BMI2_P: New Macro.\n+\tTARGET_LZCNT_P: New Macro.\n+\tTARGET_TBM_P: New Macro.\n+\tTARGET_POPCNT_P: New Macro.\n+\tTARGET_SAHF_P: New Macro.\n+\tTARGET_MOVBE_P: New Macro.\n+\tTARGET_CRC32_P: New Macro.\n+\tTARGET_AES_P: New Macro.\n+\tTARGET_PCLMUL_P: New Macro.\n+\tTARGET_CMPXCHG16B_P: New Macro.\n+\tTARGET_FSGSBASE_P: New Macro.\n+\tTARGET_RDRND_P: New Macro.\n+\tTARGET_F16C_P: New Macro.\n+\tTARGET_RTM_P: New Macro.\n+\tTARGET_HLE_P: New Macro.\n+\tTARGET_RDSEED_P: New Macro.\n+\tTARGET_PRFCHW_P: New Macro.\n+\tTARGET_ADX_P: New Macro.\n+\tTARGET_FXSR_P: New Macro.\n+\tTARGET_XSAVE_P: New Macro.\n+\tTARGET_XSAVEOPT_P: New Macro.\n+\tTARGET_LP64_P: New Macro.\n+\tTARGET_X32_P: New Macro.\n+\tTARGET_FPMATH_DEFAULT_P: New Macro.\n+\tTARGET_FLOAT_RETURNS_IN_80387_P: New Macro.\n+\t* config/i386/i386.c (ix86_option_override_internal): New parameters.\n+\topts and opts_set.\n+\tChange ix86_tune_string to access opts->x_ix86_tune_string.\n+\tChange ix86_isa_flags to access opts->x_ix86_isa_flags.\n+\tChange ix86_arch_string to access opts->x_ix86_arch_string.\n+\tChange ix86_stringop_alg to access opts->x_ix86_stringop_alg.\n+\tChange ix86_pmode to access opts->x_ix86_pmode.\n+\tChange ix86_abi to access opts->x_ix86_abi.\n+\tChange ix86_cmodel to access opts->x_ix86_cmodel.\n+\tChange ix86_asm_dialect to access opts->x_ix86_asm_dialect.\n+\tChange ix86_isa_flags_explicit to access\n+\topts->x_ix86_isa_flags_explicit.\n+\tChange ix86_dump_tunes to access opts->x_ix86_dump_tunes.\n+\tChange ix86_regparm to access opts->x_ix86_regparm.\n+\tChange ix86_branch_cost to access opts->x_ix86_branch_cost.\n+\tChange ix86_preferred_stack_boundary_arg to access\n+\topts->x_ix86_preferred_stack_boundary_arg.\n+\tChange ix86_force_align_arg_pointer to access\n+\topts->x_ix86_force_align_arg_pointer.\n+\tChange ix86_incoming_stack_boundar_arg to access\n+\topts->x_ix86_incoming_stack_boundar_arg.\n+\tChange ix86_fpmath to access opts->x_ix86_fpmath.\n+\tChange ix86_veclibabi_type to access opts->x_ix86_veclibabi_type.\n+\tChange ix86_recip_name to access opts->x_ix86_recip_name.\n+\tChange ix86_stack_protector_guard to access\n+\topts->x_ix86_stack_protector_guard.\n+\tChange ix86_tune_memcpy_strategy to access\n+\topts->x_ix86_tune_memcpy_strategy.\n+\tChange ix86_tune_memset_strategy to access\n+\topts->x_ix86_tune_memset_strategy.\n+\tChange global_options to access opts.\n+\tChange global_options_set to access opts_set.\n+        Change TARGET_64BIT to TARGET_64BIT_P (opts->...)\n+        Change TARGET_MMX to TARGET_MMX_P (opts->...)\n+        Change TARGET_3DNOW to TARGET_3DNOW_P (opts->...)\n+        Change TARGET_3DNOW_A to TARGET_3DNOW_A_P (opts->...)\n+        Change TARGET_SSE to TARGET_SSE_P (opts->...)\n+        Change TARGET_SSE2 to TARGET_SSE2_P (opts->...)\n+        Change TARGET_SSE3 to TARGET_SSE3_P (opts->...)\n+        Change TARGET_SSSE3 to TARGET_SSSE3_P (opts->...)\n+        Change TARGET_SSE4_1 to TARGET_SSE4_1_P (opts->...)\n+        Change TARGET_SSE4_2 to TARGET_SSE4_2_P (opts->...)\n+        Change TARGET_AVX to TARGET_AVX_P (opts->...)\n+        Change TARGET_AVX2 to TARGET_AVX2_P (opts->...)\n+        Change TARGET_AVX512F to TARGET_AVX512F_P (opts->...)\n+        Change TARGET_AVX512PF to TARGET_AVX512PF_P (opts->...)\n+        Change TARGET_AVX512ER to TARGET_AVX512ER_P (opts->...)\n+        Change TARGET_AVX512CD to TARGET_AVX512CD_P (opts->...)\n+        Change TARGET_FMA to TARGET_FMA_P (opts->...)\n+        Change TARGET_SSE4A to TARGET_SSE4A_P (opts->...)\n+        Change TARGET_FMA4 to TARGET_FMA4_P (opts->...)\n+        Change TARGET_XOP to TARGET_XOP_P (opts->...)\n+        Change TARGET_LWP to TARGET_LWP_P (opts->...)\n+        Change TARGET_ABM to TARGET_ABM_P (opts->...)\n+        Change TARGET_BMI to TARGET_BMI_P (opts->...)\n+        Change TARGET_BMI2 to TARGET_BMI2_P (opts->...)\n+        Change TARGET_LZCNT to TARGET_LZCNT_P (opts->...)\n+        Change TARGET_TBM to TARGET_TBM_P (opts->...)\n+        Change TARGET_POPCNT to TARGET_POPCNT_P (opts->...)\n+        Change TARGET_SAHF to TARGET_SAHF_P (opts->...)\n+        Change TARGET_MOVBE to TARGET_MOVBE_P (opts->...)\n+        Change TARGET_CRC32 to TARGET_CRC32_P (opts->...)\n+        Change TARGET_AES to TARGET_AES_P (opts->...)\n+        Change TARGET_PCLMUL to TARGET_PCLMUL_P (opts->...)\n+        Change TARGET_CMPXCHG16B to TARGET_CMPXCHG16B_P (opts->...)\n+        Change TARGET_FSGSBASE to TARGET_FSGSBASE_P (opts->...)\n+        Change TARGET_RDRND to TARGET_RDRND_P (opts->...)\n+        Change TARGET_F16C to TARGET_F16C_P (opts->...)\n+        Change TARGET_RTM to TARGET_RTM_P (opts->...)\n+        Change TARGET_HLE to TARGET_HLE_P (opts->...)\n+        Change TARGET_RDSEED to TARGET_RDSEED_P (opts->...)\n+        Change TARGET_PRFCHW to TARGET_PRFCHW_P (opts->...)\n+        Change TARGET_ADX to TARGET_ADX_P (opts->...)\n+        Change TARGET_FXSR to TARGET_FXSR_P (opts->...)\n+        Change TARGET_XSAVE to TARGET_XSAVE_P (opts->...)\n+        Change TARGET_XSAVEOPT to TARGET_XSAVEOPT_P (opts->...)\n+        Change TARGET_LP64 to TARGET_LP64_P (opts->...)\n+        Change TARGET_X32 to TARGET_X32_P (opts->...)\n+        Change TARGET_FPMATH_DEFAULT to TARGET_FPMATH_DEFAULT_P (opts->...)\n+        Change TARGET_FLOAT_RETURNS_IN_80387 to\n+\t TARGET_FLOAT_RETURNS_IN_80387_P (opts->...)\n+\t(ix86_function_specific_save): New parameter. Use opts-> fields\n+\tto replace global fields.\n+\t(ix86_function_specific_restore): Ditto.\n+\t(ix86_valid_target_attribute_inner_p): New parameters.\n+\tFix recursive call.\n+\tFix call to ix86_handle_option and set_option.\n+\t(ix86_valid_target_attribute_tree): New parameters.\n+\tChange global_options to access opts.\n+\tChange global_options_set to access opts_set.\n+\tFix call to ix86_valid_target_attribute_inner_p.\n+\tChange ix86_tune_string to access opts->x_ix86_tune_string.\n+\tChange ix86_arch_string to access opts->x_ix86_arch_string.\n+\tChange ix86_fpmath to access opts->x_ix86_fpmath\n+\tFix call to ix86_option_override_internal.\n+\tFix call to ix86_add_new_builtins.\n+\tFix calls to build_optimization_node and build_target_option_node.\n+\t(ix86_valid_target_attribute_p): Remove access to global_options.\n+\tUse new gcc_options structure func_options.\n+\tFix call to ix86_valid_target_attribute_tree.\n+\tFix call to  build_optimization_node.\n+\t(get_builtin_code_for_version):\tFix call to\n+\tix86_valid_target_attribute_tree.\n+\n 2013-10-15  David Malcolm  <dmalcolm@redhat.com>\n \n \t* Makefile.in (PICFLAG): New."}, {"sha": "d830288864e04d2f64ff84fa6e6fc326b5ca8f53", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf7b5747bb33b0333786dfcc015e0f23136e5f18/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf7b5747bb33b0333786dfcc015e0f23136e5f18/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=bf7b5747bb33b0333786dfcc015e0f23136e5f18", "patch": "@@ -9049,7 +9049,7 @@ handle_optimize_attribute (tree *node, tree name, tree args,\n       /* Parse options, and update the vector.  */\n       parse_optimize_options (args, true);\n       DECL_FUNCTION_SPECIFIC_OPTIMIZATION (*node)\n-\t= build_optimization_node ();\n+\t= build_optimization_node (&global_options);\n \n       /* Restore current options.  */\n       cl_optimization_restore (&global_options, &cur_opts);"}, {"sha": "be5748b1c53ca81581e53e9afcde99dbfdc2710c", "filename": "gcc/c-family/c-pragma.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf7b5747bb33b0333786dfcc015e0f23136e5f18/gcc%2Fc-family%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf7b5747bb33b0333786dfcc015e0f23136e5f18/gcc%2Fc-family%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pragma.c?ref=bf7b5747bb33b0333786dfcc015e0f23136e5f18", "patch": "@@ -872,7 +872,7 @@ handle_pragma_optimize (cpp_reader *ARG_UNUSED(dummy))\n \n       parse_optimize_options (args, false);\n       current_optimize_pragma = chainon (current_optimize_pragma, args);\n-      optimization_current_node = build_optimization_node ();\n+      optimization_current_node = build_optimization_node (&global_options);\n       c_cpp_builtins_optimize_pragma (parse_in,\n \t\t\t\t      optimization_previous_node,\n \t\t\t\t      optimization_current_node);\n@@ -914,8 +914,8 @@ handle_pragma_push_options (cpp_reader *ARG_UNUSED(dummy))\n   options_stack = p;\n \n   /* Save optimization and target flags in binary format.  */\n-  p->optimize_binary = build_optimization_node ();\n-  p->target_binary = build_target_option_node ();\n+  p->optimize_binary = build_optimization_node (&global_options);\n+  p->target_binary = build_target_option_node (&global_options);\n \n   /* Save optimization and target flags in string list format.  */\n   p->optimize_strings = copy_list (current_optimize_pragma);"}, {"sha": "8a41fb0ddf7474a6feda6fbc4a14cec714b16a52", "filename": "gcc/config/i386/i386-c.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf7b5747bb33b0333786dfcc015e0f23136e5f18/gcc%2Fconfig%2Fi386%2Fi386-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf7b5747bb33b0333786dfcc015e0f23136e5f18/gcc%2Fconfig%2Fi386%2Fi386-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-c.c?ref=bf7b5747bb33b0333786dfcc015e0f23136e5f18", "patch": "@@ -368,7 +368,7 @@ ix86_target_macros_internal (HOST_WIDE_INT isa_flag,\n static bool\n ix86_pragma_target_parse (tree args, tree pop_target)\n {\n-  tree prev_tree = build_target_option_node ();\n+  tree prev_tree = build_target_option_node (&global_options);\n   tree cur_tree;\n   struct cl_target_option *prev_opt;\n   struct cl_target_option *cur_opt;\n@@ -388,7 +388,8 @@ ix86_pragma_target_parse (tree args, tree pop_target)\n     }\n   else\n     {\n-      cur_tree = ix86_valid_target_attribute_tree (args);\n+      cur_tree = ix86_valid_target_attribute_tree (args, &global_options,\n+\t\t\t\t\t\t   &global_options_set);\n       if (!cur_tree || cur_tree == error_mark_node)\n        {\n          cl_target_option_restore (&global_options,"}, {"sha": "df388765497baae1647451b56d1c3d27f8067a40", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf7b5747bb33b0333786dfcc015e0f23136e5f18/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf7b5747bb33b0333786dfcc015e0f23136e5f18/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=bf7b5747bb33b0333786dfcc015e0f23136e5f18", "patch": "@@ -220,7 +220,9 @@ extern int ix86_constant_alignment (tree, int);\n extern tree ix86_handle_shared_attribute (tree *, tree, tree, int, bool *);\n extern tree ix86_handle_selectany_attribute (tree *, tree, tree, int, bool *);\n extern int x86_field_alignment (tree, int);\n-extern tree ix86_valid_target_attribute_tree (tree);\n+extern tree ix86_valid_target_attribute_tree (tree,\n+\t\t\t\t\t      struct gcc_options *,\n+\t\t\t\t\t      struct gcc_options *);\n extern unsigned int ix86_get_callcvt (const_tree);\n \n #endif"}, {"sha": "b5796db25a24594f0859d38892a46b7d3805797e", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 414, "deletions": 369, "changes": 783, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf7b5747bb33b0333786dfcc015e0f23136e5f18/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf7b5747bb33b0333786dfcc015e0f23136e5f18/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=bf7b5747bb33b0333786dfcc015e0f23136e5f18", "patch": "@@ -2248,12 +2248,16 @@ enum ix86_function_specific_strings\n \n static char *ix86_target_string (HOST_WIDE_INT, int, const char *,\n \t\t\t\t const char *, enum fpmath_unit, bool);\n-static void ix86_function_specific_save (struct cl_target_option *);\n-static void ix86_function_specific_restore (struct cl_target_option *);\n+static void ix86_function_specific_save (struct cl_target_option *,\n+\t\t\t\t\t struct gcc_options *opts);\n+static void ix86_function_specific_restore (struct gcc_options *opts,\n+\t\t\t\t\t    struct cl_target_option *);\n static void ix86_function_specific_print (FILE *, int,\n \t\t\t\t\t  struct cl_target_option *);\n static bool ix86_valid_target_attribute_p (tree, tree, tree, int);\n static bool ix86_valid_target_attribute_inner_p (tree, char *[],\n+\t\t\t\t\t\t struct gcc_options *,\n+\t\t\t\t\t\t struct gcc_options *,\n \t\t\t\t\t\t struct gcc_options *);\n static bool ix86_can_inline_p (tree, tree);\n static void ix86_set_current_function (tree);\n@@ -2917,11 +2921,13 @@ set_ix86_tune_features (enum processor_type ix86_tune, bool dump)\n    attributes.  */\n \n static void\n-ix86_option_override_internal (bool main_args_p)\n+ix86_option_override_internal (bool main_args_p,\n+\t\t\t       struct gcc_options *opts,\n+\t\t\t       struct gcc_options *opts_set)\n {\n   int i;\n   unsigned int ix86_arch_mask, ix86_tune_mask;\n-  const bool ix86_tune_specified = (ix86_tune_string != NULL);\n+  const bool ix86_tune_specified = (opts->x_ix86_tune_string != NULL);\n   const char *prefix;\n   const char *suffix;\n   const char *sw;\n@@ -3153,8 +3159,8 @@ ix86_option_override_internal (bool main_args_p)\n \n   /* Turn off both OPTION_MASK_ABI_64 and OPTION_MASK_ABI_X32 if\n      TARGET_64BIT_DEFAULT is true and TARGET_64BIT is false.  */\n-  if (TARGET_64BIT_DEFAULT && !TARGET_64BIT)\n-    ix86_isa_flags &= ~(OPTION_MASK_ABI_64 | OPTION_MASK_ABI_X32);\n+  if (TARGET_64BIT_DEFAULT && !TARGET_64BIT_P (opts->x_ix86_isa_flags))\n+    opts->x_ix86_isa_flags &= ~(OPTION_MASK_ABI_64 | OPTION_MASK_ABI_X32);\n #ifdef TARGET_BI_ARCH\n   else\n     {\n@@ -3163,32 +3169,32 @@ ix86_option_override_internal (bool main_args_p)\n \t is on and OPTION_MASK_ABI_X32 is off.  We turn off\n \t OPTION_MASK_ABI_64 if OPTION_MASK_ABI_X32 is turned on by\n \t -mx32.  */\n-      if (TARGET_X32)\n-\tix86_isa_flags &= ~OPTION_MASK_ABI_64;\n+      if (TARGET_X32_P (opts->x_ix86_isa_flags))\n+\topts->x_ix86_isa_flags &= ~OPTION_MASK_ABI_64;\n #else\n       /* When TARGET_BI_ARCH == 2, by default, OPTION_MASK_ABI_X32 is\n \t on and OPTION_MASK_ABI_64 is off.  We turn off\n \t OPTION_MASK_ABI_X32 if OPTION_MASK_ABI_64 is turned on by\n \t -m64.  */\n-      if (TARGET_LP64)\n-\tix86_isa_flags &= ~OPTION_MASK_ABI_X32;\n+      if (TARGET_LP64_P (opts->x_ix86_isa_flags))\n+\topts->x_ix86_isa_flags &= ~OPTION_MASK_ABI_X32;\n #endif\n     }\n #endif\n \n-  if (TARGET_X32)\n+  if (TARGET_X32_P (opts->x_ix86_isa_flags))\n     {\n       /* Always turn on OPTION_MASK_ISA_64BIT and turn off\n \t OPTION_MASK_ABI_64 for TARGET_X32.  */\n-      ix86_isa_flags |= OPTION_MASK_ISA_64BIT;\n-      ix86_isa_flags &= ~OPTION_MASK_ABI_64;\n+      opts->x_ix86_isa_flags |= OPTION_MASK_ISA_64BIT;\n+      opts->x_ix86_isa_flags &= ~OPTION_MASK_ABI_64;\n     }\n-  else if (TARGET_LP64)\n+  else if (TARGET_LP64_P (opts->x_ix86_isa_flags))\n     {\n       /* Always turn on OPTION_MASK_ISA_64BIT and turn off\n \t OPTION_MASK_ABI_X32 for TARGET_LP64.  */\n-      ix86_isa_flags |= OPTION_MASK_ISA_64BIT;\n-      ix86_isa_flags &= ~OPTION_MASK_ABI_X32;\n+      opts->x_ix86_isa_flags |= OPTION_MASK_ISA_64BIT;\n+      opts->x_ix86_isa_flags &= ~OPTION_MASK_ABI_X32;\n     }\n \n #ifdef SUBTARGET_OVERRIDE_OPTIONS\n@@ -3200,138 +3206,144 @@ ix86_option_override_internal (bool main_args_p)\n #endif\n \n   /* -fPIC is the default for x86_64.  */\n-  if (TARGET_MACHO && TARGET_64BIT)\n-    flag_pic = 2;\n+  if (TARGET_MACHO && TARGET_64BIT_P (opts->x_ix86_isa_flags))\n+    opts->x_flag_pic = 2;\n \n   /* Need to check -mtune=generic first.  */\n-  if (ix86_tune_string)\n+  if (opts->x_ix86_tune_string)\n     {\n-      if (!strcmp (ix86_tune_string, \"generic\")\n-\t  || !strcmp (ix86_tune_string, \"i686\")\n+      if (!strcmp (opts->x_ix86_tune_string, \"generic\")\n+\t  || !strcmp (opts->x_ix86_tune_string, \"i686\")\n \t  /* As special support for cross compilers we read -mtune=native\n \t     as -mtune=generic.  With native compilers we won't see the\n \t     -mtune=native, as it was changed by the driver.  */\n-\t  || !strcmp (ix86_tune_string, \"native\"))\n+\t  || !strcmp (opts->x_ix86_tune_string, \"native\"))\n \t{\n-\t  ix86_tune_string = \"generic\";\n+\t  opts->x_ix86_tune_string = \"generic\";\n \t}\n       /* If this call is for setting the option attribute, allow the\n \t generic that was previously set.  */\n       else if (!main_args_p\n-\t       && !strcmp (ix86_tune_string, \"generic\"))\n+\t       && !strcmp (opts->x_ix86_tune_string, \"generic\"))\n \t;\n-      else if (!strncmp (ix86_tune_string, \"generic\", 7))\n+      else if (!strncmp (opts->x_ix86_tune_string, \"generic\", 7))\n         error (\"bad value (%s) for %stune=%s %s\",\n-\t       ix86_tune_string, prefix, suffix, sw);\n-      else if (!strcmp (ix86_tune_string, \"x86-64\"))\n+\t       opts->x_ix86_tune_string, prefix, suffix, sw);\n+      else if (!strcmp (opts->x_ix86_tune_string, \"x86-64\"))\n         warning (OPT_Wdeprecated, \"%stune=x86-64%s is deprecated; use \"\n                  \"%stune=k8%s or %stune=generic%s instead as appropriate\",\n                  prefix, suffix, prefix, suffix, prefix, suffix);\n     }\n   else\n     {\n-      if (ix86_arch_string)\n-\tix86_tune_string = ix86_arch_string;\n-      if (!ix86_tune_string)\n+      if (opts->x_ix86_arch_string)\n+\topts->x_ix86_tune_string = opts->x_ix86_arch_string;\n+      if (!opts->x_ix86_tune_string)\n \t{\n-\t  ix86_tune_string = cpu_names[TARGET_CPU_DEFAULT];\n+\t  opts->x_ix86_tune_string = cpu_names[TARGET_CPU_DEFAULT];\n \t  ix86_tune_defaulted = 1;\n \t}\n \n-      /* ix86_tune_string is set to ix86_arch_string or defaulted.  We\n-\t need to use a sensible tune option.  */\n-      if (!strcmp (ix86_tune_string, \"generic\")\n-\t  || !strcmp (ix86_tune_string, \"x86-64\")\n-\t  || !strcmp (ix86_tune_string, \"i686\"))\n+      /* opts->x_ix86_tune_string is set to opts->x_ix86_arch_string\n+\t or defaulted.  We need to use a sensible tune option.  */\n+      if (!strcmp (opts->x_ix86_tune_string, \"generic\")\n+\t  || !strcmp (opts->x_ix86_tune_string, \"x86-64\")\n+\t  || !strcmp (opts->x_ix86_tune_string, \"i686\"))\n \t{\n-\t  ix86_tune_string = \"generic\";\n+\t  opts->x_ix86_tune_string = \"generic\";\n \t}\n     }\n \n-  if (ix86_stringop_alg == rep_prefix_8_byte && !TARGET_64BIT)\n+  if (opts->x_ix86_stringop_alg == rep_prefix_8_byte\n+      && !TARGET_64BIT_P (opts->x_ix86_isa_flags))\n     {\n       /* rep; movq isn't available in 32-bit code.  */\n       error (\"-mstringop-strategy=rep_8byte not supported for 32-bit code\");\n-      ix86_stringop_alg = no_stringop;\n+      opts->x_ix86_stringop_alg = no_stringop;\n     }\n \n-  if (!ix86_arch_string)\n-    ix86_arch_string = TARGET_64BIT ? \"x86-64\" : SUBTARGET32_DEFAULT_CPU;\n+  if (!opts->x_ix86_arch_string)\n+    opts->x_ix86_arch_string\n+      = TARGET_64BIT_P (opts->x_ix86_isa_flags)\n+\t? \"x86-64\" : SUBTARGET32_DEFAULT_CPU;\n   else\n     ix86_arch_specified = 1;\n \n-  if (global_options_set.x_ix86_pmode)\n+  if (opts_set->x_ix86_pmode)\n     {\n-      if ((TARGET_LP64 && ix86_pmode == PMODE_SI)\n-\t   || (!TARGET_64BIT && ix86_pmode == PMODE_DI))\n+      if ((TARGET_LP64_P (opts->x_ix86_isa_flags)\n+\t   && opts->x_ix86_pmode == PMODE_SI)\n+\t  || (!TARGET_64BIT_P (opts->x_ix86_isa_flags)\n+\t       && opts->x_ix86_pmode == PMODE_DI))\n \terror (\"address mode %qs not supported in the %s bit mode\",\n-\t       TARGET_64BIT ? \"short\" : \"long\",\n-\t       TARGET_64BIT ? \"64\" : \"32\");\n+\t       TARGET_64BIT_P (opts->x_ix86_isa_flags) ? \"short\" : \"long\",\n+\t       TARGET_64BIT_P (opts->x_ix86_isa_flags) ? \"64\" : \"32\");\n     }\n   else\n-    ix86_pmode = TARGET_LP64 ? PMODE_DI : PMODE_SI;\n+    opts->x_ix86_pmode = TARGET_LP64_P (opts->x_ix86_isa_flags)\n+\t\t\t ? PMODE_DI : PMODE_SI;\n \n-  if (!global_options_set.x_ix86_abi)\n-    ix86_abi = DEFAULT_ABI;\n+  if (!opts_set->x_ix86_abi)\n+    opts->x_ix86_abi = DEFAULT_ABI;\n \n   /* For targets using ms ABI enable ms-extensions, if not\n      explicit turned off.  For non-ms ABI we turn off this\n      option.  */\n-  if (!global_options_set.x_flag_ms_extensions)\n-    flag_ms_extensions = (MS_ABI == DEFAULT_ABI);\n+  if (!opts_set->x_flag_ms_extensions)\n+    opts->x_flag_ms_extensions = (MS_ABI == DEFAULT_ABI);\n \n-  if (global_options_set.x_ix86_cmodel)\n+  if (opts_set->x_ix86_cmodel)\n     {\n-      switch (ix86_cmodel)\n+      switch (opts->x_ix86_cmodel)\n \t{\n \tcase CM_SMALL:\n \tcase CM_SMALL_PIC:\n-\t  if (flag_pic)\n-\t    ix86_cmodel = CM_SMALL_PIC;\n-\t  if (!TARGET_64BIT)\n+\t  if (opts->x_flag_pic)\n+\t    opts->x_ix86_cmodel = CM_SMALL_PIC;\n+\t  if (!TARGET_64BIT_P (opts->x_ix86_isa_flags))\n \t    error (\"code model %qs not supported in the %s bit mode\",\n \t\t   \"small\", \"32\");\n \t  break;\n \n \tcase CM_MEDIUM:\n \tcase CM_MEDIUM_PIC:\n-\t  if (flag_pic)\n-\t    ix86_cmodel = CM_MEDIUM_PIC;\n-\t  if (!TARGET_64BIT)\n+\t  if (opts->x_flag_pic)\n+\t    opts->x_ix86_cmodel = CM_MEDIUM_PIC;\n+\t  if (!TARGET_64BIT_P (opts->x_ix86_isa_flags))\n \t    error (\"code model %qs not supported in the %s bit mode\",\n \t\t   \"medium\", \"32\");\n-\t  else if (TARGET_X32)\n+\t  else if (TARGET_X32_P (opts->x_ix86_isa_flags))\n \t    error (\"code model %qs not supported in x32 mode\",\n \t\t   \"medium\");\n \t  break;\n \n \tcase CM_LARGE:\n \tcase CM_LARGE_PIC:\n-\t  if (flag_pic)\n-\t    ix86_cmodel = CM_LARGE_PIC;\n-\t  if (!TARGET_64BIT)\n+\t  if (opts->x_flag_pic)\n+\t    opts->x_ix86_cmodel = CM_LARGE_PIC;\n+\t  if (!TARGET_64BIT_P (opts->x_ix86_isa_flags))\n \t    error (\"code model %qs not supported in the %s bit mode\",\n \t\t   \"large\", \"32\");\n-\t  else if (TARGET_X32)\n+\t  else if (TARGET_X32_P (opts->x_ix86_isa_flags))\n \t    error (\"code model %qs not supported in x32 mode\",\n \t\t   \"large\");\n \t  break;\n \n \tcase CM_32:\n-\t  if (flag_pic)\n+\t  if (opts->x_flag_pic)\n \t    error (\"code model %s does not support PIC mode\", \"32\");\n-\t  if (TARGET_64BIT)\n+\t  if (TARGET_64BIT_P (opts->x_ix86_isa_flags))\n \t    error (\"code model %qs not supported in the %s bit mode\",\n \t\t   \"32\", \"64\");\n \t  break;\n \n \tcase CM_KERNEL:\n-\t  if (flag_pic)\n+\t  if (opts->x_flag_pic)\n \t    {\n \t      error (\"code model %s does not support PIC mode\", \"kernel\");\n-\t      ix86_cmodel = CM_32;\n+\t      opts->x_ix86_cmodel = CM_32;\n \t    }\n-\t  if (!TARGET_64BIT)\n+\t  if (!TARGET_64BIT_P (opts->x_ix86_isa_flags))\n \t    error (\"code model %qs not supported in the %s bit mode\",\n \t\t   \"kernel\", \"32\");\n \t  break;\n@@ -3346,191 +3358,195 @@ ix86_option_override_internal (bool main_args_p)\n \t use of rip-relative addressing.  This eliminates fixups that\n \t would otherwise be needed if this object is to be placed in a\n \t DLL, and is essentially just as efficient as direct addressing.  */\n-      if (TARGET_64BIT && (TARGET_RDOS || TARGET_PECOFF))\n-\tix86_cmodel = CM_MEDIUM_PIC, flag_pic = 1;\n-      else if (TARGET_64BIT)\n-\tix86_cmodel = flag_pic ? CM_SMALL_PIC : CM_SMALL;\n+      if (TARGET_64BIT_P (opts->x_ix86_isa_flags)\n+\t  && (TARGET_RDOS || TARGET_PECOFF))\n+\topts->x_ix86_cmodel = CM_MEDIUM_PIC, opts->x_flag_pic = 1;\n+      else if (TARGET_64BIT_P (opts->x_ix86_isa_flags))\n+\topts->x_ix86_cmodel = opts->x_flag_pic ? CM_SMALL_PIC : CM_SMALL;\n       else\n-\tix86_cmodel = CM_32;\n+\topts->x_ix86_cmodel = CM_32;\n     }\n-  if (TARGET_MACHO && ix86_asm_dialect == ASM_INTEL)\n+  if (TARGET_MACHO && opts->x_ix86_asm_dialect == ASM_INTEL)\n     {\n       error (\"-masm=intel not supported in this configuration\");\n-      ix86_asm_dialect = ASM_ATT;\n+      opts->x_ix86_asm_dialect = ASM_ATT;\n     }\n-  if ((TARGET_64BIT != 0) != ((ix86_isa_flags & OPTION_MASK_ISA_64BIT) != 0))\n+  if ((TARGET_64BIT_P (opts->x_ix86_isa_flags) != 0)\n+      != ((opts->x_ix86_isa_flags & OPTION_MASK_ISA_64BIT) != 0))\n     sorry (\"%i-bit mode not compiled in\",\n-\t   (ix86_isa_flags & OPTION_MASK_ISA_64BIT) ? 64 : 32);\n+\t   (opts->x_ix86_isa_flags & OPTION_MASK_ISA_64BIT) ? 64 : 32);\n \n   for (i = 0; i < pta_size; i++)\n-    if (! strcmp (ix86_arch_string, processor_alias_table[i].name))\n+    if (! strcmp (opts->x_ix86_arch_string, processor_alias_table[i].name))\n       {\n \tix86_schedule = processor_alias_table[i].schedule;\n \tix86_arch = processor_alias_table[i].processor;\n \t/* Default cpu tuning to the architecture.  */\n \tix86_tune = ix86_arch;\n \n-\tif (TARGET_64BIT && !(processor_alias_table[i].flags & PTA_64BIT))\n+\tif (TARGET_64BIT_P (opts->x_ix86_isa_flags)\n+\t    && !(processor_alias_table[i].flags & PTA_64BIT))\n \t  error (\"CPU you selected does not support x86-64 \"\n \t\t \"instruction set\");\n \n \tif (processor_alias_table[i].flags & PTA_MMX\n-\t    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_MMX))\n-\t  ix86_isa_flags |= OPTION_MASK_ISA_MMX;\n+\t    && !(opts->x_ix86_isa_flags_explicit & OPTION_MASK_ISA_MMX))\n+\t  opts->x_ix86_isa_flags |= OPTION_MASK_ISA_MMX;\n \tif (processor_alias_table[i].flags & PTA_3DNOW\n-\t    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_3DNOW))\n-\t  ix86_isa_flags |= OPTION_MASK_ISA_3DNOW;\n+\t    && !(opts->x_ix86_isa_flags_explicit & OPTION_MASK_ISA_3DNOW))\n+\t  opts->x_ix86_isa_flags |= OPTION_MASK_ISA_3DNOW;\n \tif (processor_alias_table[i].flags & PTA_3DNOW_A\n-\t    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_3DNOW_A))\n-\t  ix86_isa_flags |= OPTION_MASK_ISA_3DNOW_A;\n+\t    && !(opts->x_ix86_isa_flags_explicit & OPTION_MASK_ISA_3DNOW_A))\n+\t  opts->x_ix86_isa_flags |= OPTION_MASK_ISA_3DNOW_A;\n \tif (processor_alias_table[i].flags & PTA_SSE\n-\t    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_SSE))\n-\t  ix86_isa_flags |= OPTION_MASK_ISA_SSE;\n+\t    && !(opts->x_ix86_isa_flags_explicit & OPTION_MASK_ISA_SSE))\n+\t  opts->x_ix86_isa_flags |= OPTION_MASK_ISA_SSE;\n \tif (processor_alias_table[i].flags & PTA_SSE2\n-\t    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_SSE2))\n-\t  ix86_isa_flags |= OPTION_MASK_ISA_SSE2;\n+\t    && !(opts->x_ix86_isa_flags_explicit & OPTION_MASK_ISA_SSE2))\n+\t  opts->x_ix86_isa_flags |= OPTION_MASK_ISA_SSE2;\n \tif (processor_alias_table[i].flags & PTA_SSE3\n-\t    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_SSE3))\n-\t  ix86_isa_flags |= OPTION_MASK_ISA_SSE3;\n+\t    && !(opts->x_ix86_isa_flags_explicit & OPTION_MASK_ISA_SSE3))\n+\t  opts->x_ix86_isa_flags |= OPTION_MASK_ISA_SSE3;\n \tif (processor_alias_table[i].flags & PTA_SSSE3\n-\t    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_SSSE3))\n-\t  ix86_isa_flags |= OPTION_MASK_ISA_SSSE3;\n+\t    && !(opts->x_ix86_isa_flags_explicit & OPTION_MASK_ISA_SSSE3))\n+\t  opts->x_ix86_isa_flags |= OPTION_MASK_ISA_SSSE3;\n \tif (processor_alias_table[i].flags & PTA_SSE4_1\n-\t    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_SSE4_1))\n-\t  ix86_isa_flags |= OPTION_MASK_ISA_SSE4_1;\n+\t    && !(opts->x_ix86_isa_flags_explicit & OPTION_MASK_ISA_SSE4_1))\n+\t  opts->x_ix86_isa_flags |= OPTION_MASK_ISA_SSE4_1;\n \tif (processor_alias_table[i].flags & PTA_SSE4_2\n-\t    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_SSE4_2))\n-\t  ix86_isa_flags |= OPTION_MASK_ISA_SSE4_2;\n+\t    && !(opts->x_ix86_isa_flags_explicit & OPTION_MASK_ISA_SSE4_2))\n+\t  opts->x_ix86_isa_flags |= OPTION_MASK_ISA_SSE4_2;\n \tif (processor_alias_table[i].flags & PTA_AVX\n-\t    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_AVX))\n-\t  ix86_isa_flags |= OPTION_MASK_ISA_AVX;\n+\t    && !(opts->x_ix86_isa_flags_explicit & OPTION_MASK_ISA_AVX))\n+\t  opts->x_ix86_isa_flags |= OPTION_MASK_ISA_AVX;\n \tif (processor_alias_table[i].flags & PTA_AVX2\n-\t    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_AVX2))\n-\t  ix86_isa_flags |= OPTION_MASK_ISA_AVX2;\n+\t    && !(opts->x_ix86_isa_flags_explicit & OPTION_MASK_ISA_AVX2))\n+\t  opts->x_ix86_isa_flags |= OPTION_MASK_ISA_AVX2;\n \tif (processor_alias_table[i].flags & PTA_FMA\n-\t    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_FMA))\n-\t  ix86_isa_flags |= OPTION_MASK_ISA_FMA;\n+\t    && !(opts->x_ix86_isa_flags_explicit & OPTION_MASK_ISA_FMA))\n+\t  opts->x_ix86_isa_flags |= OPTION_MASK_ISA_FMA;\n \tif (processor_alias_table[i].flags & PTA_SSE4A\n-\t    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_SSE4A))\n-\t  ix86_isa_flags |= OPTION_MASK_ISA_SSE4A;\n+\t    && !(opts->x_ix86_isa_flags_explicit & OPTION_MASK_ISA_SSE4A))\n+\t  opts->x_ix86_isa_flags |= OPTION_MASK_ISA_SSE4A;\n \tif (processor_alias_table[i].flags & PTA_FMA4\n-\t    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_FMA4))\n-\t  ix86_isa_flags |= OPTION_MASK_ISA_FMA4;\n+\t    && !(opts->x_ix86_isa_flags_explicit & OPTION_MASK_ISA_FMA4))\n+\t  opts->x_ix86_isa_flags |= OPTION_MASK_ISA_FMA4;\n \tif (processor_alias_table[i].flags & PTA_XOP\n-\t    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_XOP))\n-\t  ix86_isa_flags |= OPTION_MASK_ISA_XOP;\n+\t    && !(opts->x_ix86_isa_flags_explicit & OPTION_MASK_ISA_XOP))\n+\t  opts->x_ix86_isa_flags |= OPTION_MASK_ISA_XOP;\n \tif (processor_alias_table[i].flags & PTA_LWP\n-\t    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_LWP))\n-\t  ix86_isa_flags |= OPTION_MASK_ISA_LWP;\n+\t    && !(opts->x_ix86_isa_flags_explicit & OPTION_MASK_ISA_LWP))\n+\t  opts->x_ix86_isa_flags |= OPTION_MASK_ISA_LWP;\n \tif (processor_alias_table[i].flags & PTA_ABM\n-\t    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_ABM))\n-\t  ix86_isa_flags |= OPTION_MASK_ISA_ABM;\n+\t    && !(opts->x_ix86_isa_flags_explicit & OPTION_MASK_ISA_ABM))\n+\t  opts->x_ix86_isa_flags |= OPTION_MASK_ISA_ABM;\n \tif (processor_alias_table[i].flags & PTA_BMI\n-\t    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_BMI))\n-\t  ix86_isa_flags |= OPTION_MASK_ISA_BMI;\n+\t    && !(opts->x_ix86_isa_flags_explicit & OPTION_MASK_ISA_BMI))\n+\t  opts->x_ix86_isa_flags |= OPTION_MASK_ISA_BMI;\n \tif (processor_alias_table[i].flags & (PTA_LZCNT | PTA_ABM)\n-\t    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_LZCNT))\n-\t  ix86_isa_flags |= OPTION_MASK_ISA_LZCNT;\n+\t    && !(opts->x_ix86_isa_flags_explicit & OPTION_MASK_ISA_LZCNT))\n+\t  opts->x_ix86_isa_flags |= OPTION_MASK_ISA_LZCNT;\n \tif (processor_alias_table[i].flags & PTA_TBM\n-\t    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_TBM))\n-\t  ix86_isa_flags |= OPTION_MASK_ISA_TBM;\n+\t    && !(opts->x_ix86_isa_flags_explicit & OPTION_MASK_ISA_TBM))\n+\t  opts->x_ix86_isa_flags |= OPTION_MASK_ISA_TBM;\n \tif (processor_alias_table[i].flags & PTA_BMI2\n-\t    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_BMI2))\n-\t  ix86_isa_flags |= OPTION_MASK_ISA_BMI2;\n+\t    && !(opts->x_ix86_isa_flags_explicit & OPTION_MASK_ISA_BMI2))\n+\t  opts->x_ix86_isa_flags |= OPTION_MASK_ISA_BMI2;\n \tif (processor_alias_table[i].flags & PTA_CX16\n-\t    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_CX16))\n-\t  ix86_isa_flags |= OPTION_MASK_ISA_CX16;\n+\t    && !(opts->x_ix86_isa_flags_explicit & OPTION_MASK_ISA_CX16))\n+\t  opts->x_ix86_isa_flags |= OPTION_MASK_ISA_CX16;\n \tif (processor_alias_table[i].flags & (PTA_POPCNT | PTA_ABM)\n-\t    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_POPCNT))\n-\t  ix86_isa_flags |= OPTION_MASK_ISA_POPCNT;\n-\tif (!(TARGET_64BIT && (processor_alias_table[i].flags & PTA_NO_SAHF))\n-\t    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_SAHF))\n-\t  ix86_isa_flags |= OPTION_MASK_ISA_SAHF;\n+\t    && !(opts->x_ix86_isa_flags_explicit & OPTION_MASK_ISA_POPCNT))\n+\t  opts->x_ix86_isa_flags |= OPTION_MASK_ISA_POPCNT;\n+\tif (!(TARGET_64BIT_P (opts->x_ix86_isa_flags)\n+\t    && (processor_alias_table[i].flags & PTA_NO_SAHF))\n+\t    && !(opts->x_ix86_isa_flags_explicit & OPTION_MASK_ISA_SAHF))\n+\t  opts->x_ix86_isa_flags |= OPTION_MASK_ISA_SAHF;\n \tif (processor_alias_table[i].flags & PTA_MOVBE\n-\t    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_MOVBE))\n-\t  ix86_isa_flags |= OPTION_MASK_ISA_MOVBE;\n+\t    && !(opts->x_ix86_isa_flags_explicit & OPTION_MASK_ISA_MOVBE))\n+\t  opts->x_ix86_isa_flags |= OPTION_MASK_ISA_MOVBE;\n \tif (processor_alias_table[i].flags & PTA_AES\n-\t    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_AES))\n-\t  ix86_isa_flags |= OPTION_MASK_ISA_AES;\n+\t    && !(opts->x_ix86_isa_flags_explicit & OPTION_MASK_ISA_AES))\n+\t  opts->x_ix86_isa_flags |= OPTION_MASK_ISA_AES;\n \tif (processor_alias_table[i].flags & PTA_PCLMUL\n-\t    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_PCLMUL))\n-\t  ix86_isa_flags |= OPTION_MASK_ISA_PCLMUL;\n+\t    && !(opts->x_ix86_isa_flags_explicit & OPTION_MASK_ISA_PCLMUL))\n+\t  opts->x_ix86_isa_flags |= OPTION_MASK_ISA_PCLMUL;\n \tif (processor_alias_table[i].flags & PTA_FSGSBASE\n-\t    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_FSGSBASE))\n-\t  ix86_isa_flags |= OPTION_MASK_ISA_FSGSBASE;\n+\t    && !(opts->x_ix86_isa_flags_explicit & OPTION_MASK_ISA_FSGSBASE))\n+\t  opts->x_ix86_isa_flags |= OPTION_MASK_ISA_FSGSBASE;\n \tif (processor_alias_table[i].flags & PTA_RDRND\n-\t    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_RDRND))\n-\t  ix86_isa_flags |= OPTION_MASK_ISA_RDRND;\n+\t    && !(opts->x_ix86_isa_flags_explicit & OPTION_MASK_ISA_RDRND))\n+\t  opts->x_ix86_isa_flags |= OPTION_MASK_ISA_RDRND;\n \tif (processor_alias_table[i].flags & PTA_F16C\n-\t    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_F16C))\n-\t  ix86_isa_flags |= OPTION_MASK_ISA_F16C;\n+\t    && !(opts->x_ix86_isa_flags_explicit & OPTION_MASK_ISA_F16C))\n+\t  opts->x_ix86_isa_flags |= OPTION_MASK_ISA_F16C;\n \tif (processor_alias_table[i].flags & PTA_RTM\n-\t    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_RTM))\n-\t  ix86_isa_flags |= OPTION_MASK_ISA_RTM;\n+\t    && !(opts->x_ix86_isa_flags_explicit & OPTION_MASK_ISA_RTM))\n+\t  opts->x_ix86_isa_flags |= OPTION_MASK_ISA_RTM;\n \tif (processor_alias_table[i].flags & PTA_HLE\n-\t    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_HLE))\n-\t  ix86_isa_flags |= OPTION_MASK_ISA_HLE;\n+\t    && !(opts->x_ix86_isa_flags_explicit & OPTION_MASK_ISA_HLE))\n+\t  opts->x_ix86_isa_flags |= OPTION_MASK_ISA_HLE;\n \tif (processor_alias_table[i].flags & PTA_PRFCHW\n-\t    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_PRFCHW))\n-\t  ix86_isa_flags |= OPTION_MASK_ISA_PRFCHW;\n+\t    && !(opts->x_ix86_isa_flags_explicit & OPTION_MASK_ISA_PRFCHW))\n+\t  opts->x_ix86_isa_flags |= OPTION_MASK_ISA_PRFCHW;\n \tif (processor_alias_table[i].flags & PTA_RDSEED\n-\t    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_RDSEED))\n-\t  ix86_isa_flags |= OPTION_MASK_ISA_RDSEED;\n+\t    && !(opts->x_ix86_isa_flags_explicit & OPTION_MASK_ISA_RDSEED))\n+\t  opts->x_ix86_isa_flags |= OPTION_MASK_ISA_RDSEED;\n \tif (processor_alias_table[i].flags & PTA_ADX\n-\t    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_ADX))\n-\t  ix86_isa_flags |= OPTION_MASK_ISA_ADX;\n+\t    && !(opts->x_ix86_isa_flags_explicit & OPTION_MASK_ISA_ADX))\n+\t  opts->x_ix86_isa_flags |= OPTION_MASK_ISA_ADX;\n \tif (processor_alias_table[i].flags & PTA_FXSR\n-\t    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_FXSR))\n-\t  ix86_isa_flags |= OPTION_MASK_ISA_FXSR;\n+\t    && !(opts->x_ix86_isa_flags_explicit & OPTION_MASK_ISA_FXSR))\n+\t  opts->x_ix86_isa_flags |= OPTION_MASK_ISA_FXSR;\n \tif (processor_alias_table[i].flags & PTA_XSAVE\n-\t    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_XSAVE))\n-\t  ix86_isa_flags |= OPTION_MASK_ISA_XSAVE;\n+\t    && !(opts->x_ix86_isa_flags_explicit & OPTION_MASK_ISA_XSAVE))\n+\t  opts->x_ix86_isa_flags |= OPTION_MASK_ISA_XSAVE;\n \tif (processor_alias_table[i].flags & PTA_XSAVEOPT\n-\t    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_XSAVEOPT))\n-\t  ix86_isa_flags |= OPTION_MASK_ISA_XSAVEOPT;\n+\t    && !(opts->x_ix86_isa_flags_explicit & OPTION_MASK_ISA_XSAVEOPT))\n+\t  opts->x_ix86_isa_flags |= OPTION_MASK_ISA_XSAVEOPT;\n \tif (processor_alias_table[i].flags & PTA_AVX512F\n-\t    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_AVX512F))\n-\t  ix86_isa_flags |= OPTION_MASK_ISA_AVX512F;\n+\t    && !(opts->x_ix86_isa_flags_explicit & OPTION_MASK_ISA_AVX512F))\n+\t  opts->x_ix86_isa_flags |= OPTION_MASK_ISA_AVX512F;\n \tif (processor_alias_table[i].flags & PTA_AVX512ER\n-\t    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_AVX512ER))\n-\t  ix86_isa_flags |= OPTION_MASK_ISA_AVX512ER;\n+\t    && !(opts->x_ix86_isa_flags_explicit & OPTION_MASK_ISA_AVX512ER))\n+\t  opts->x_ix86_isa_flags |= OPTION_MASK_ISA_AVX512ER;\n \tif (processor_alias_table[i].flags & PTA_AVX512PF\n-\t    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_AVX512PF))\n-\t  ix86_isa_flags |= OPTION_MASK_ISA_AVX512PF;\n+\t    && !(opts->x_ix86_isa_flags_explicit & OPTION_MASK_ISA_AVX512PF))\n+\t  opts->x_ix86_isa_flags |= OPTION_MASK_ISA_AVX512PF;\n \tif (processor_alias_table[i].flags & PTA_AVX512CD\n-\t    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_AVX512CD))\n-\t  ix86_isa_flags |= OPTION_MASK_ISA_AVX512CD;\n+\t    && !(opts->x_ix86_isa_flags_explicit & OPTION_MASK_ISA_AVX512CD))\n+\t  opts->x_ix86_isa_flags |= OPTION_MASK_ISA_AVX512CD;\n \tif (processor_alias_table[i].flags & (PTA_PREFETCH_SSE | PTA_SSE))\n \t  x86_prefetch_sse = true;\n \n \tbreak;\n       }\n \n-  if (!strcmp (ix86_arch_string, \"generic\"))\n+  if (!strcmp (opts->x_ix86_arch_string, \"generic\"))\n     error (\"generic CPU can be used only for %stune=%s %s\",\n \t   prefix, suffix, sw);\n-  else if (!strncmp (ix86_arch_string, \"generic\", 7) || i == pta_size)\n+  else if (!strncmp (opts->x_ix86_arch_string, \"generic\", 7) || i == pta_size)\n     error (\"bad value (%s) for %sarch=%s %s\",\n-\t   ix86_arch_string, prefix, suffix, sw);\n+\t   opts->x_ix86_arch_string, prefix, suffix, sw);\n \n   ix86_arch_mask = 1u << ix86_arch;\n   for (i = 0; i < X86_ARCH_LAST; ++i)\n     ix86_arch_features[i] = !!(initial_ix86_arch_features[i] & ix86_arch_mask);\n \n   for (i = 0; i < pta_size; i++)\n-    if (! strcmp (ix86_tune_string, processor_alias_table[i].name))\n+    if (! strcmp (opts->x_ix86_tune_string, processor_alias_table[i].name))\n       {\n \tix86_schedule = processor_alias_table[i].schedule;\n \tix86_tune = processor_alias_table[i].processor;\n-\tif (TARGET_64BIT)\n+\tif (TARGET_64BIT_P (opts->x_ix86_isa_flags))\n \t  {\n \t    if (!(processor_alias_table[i].flags & PTA_64BIT))\n \t      {\n \t\tif (ix86_tune_defaulted)\n \t\t  {\n-\t\t    ix86_tune_string = \"x86-64\";\n+\t\t    opts->x_ix86_tune_string = \"x86-64\";\n \t\t    for (i = 0; i < pta_size; i++)\n-\t\t      if (! strcmp (ix86_tune_string,\n+\t\t      if (! strcmp (opts->x_ix86_tune_string,\n \t\t\t\t    processor_alias_table[i].name))\n \t\t\tbreak;\n \t\t    ix86_schedule = processor_alias_table[i].schedule;\n@@ -3554,9 +3570,9 @@ ix86_option_override_internal (bool main_args_p)\n \n   if (ix86_tune_specified && i == pta_size)\n     error (\"bad value (%s) for %stune=%s %s\",\n-\t   ix86_tune_string, prefix, suffix, sw);\n+\t   opts->x_ix86_tune_string, prefix, suffix, sw);\n \n-  set_ix86_tune_features (ix86_tune, ix86_dump_tunes);\n+  set_ix86_tune_features (ix86_tune, opts->x_ix86_dump_tunes);\n \n #ifndef USE_IX86_FRAME_POINTER\n #define USE_IX86_FRAME_POINTER 0\n@@ -3568,27 +3584,29 @@ ix86_option_override_internal (bool main_args_p)\n \n   /* Set the default values for switches whose default depends on TARGET_64BIT\n      in case they weren't overwritten by command line options.  */\n-  if (TARGET_64BIT)\n+  if (TARGET_64BIT_P (opts->x_ix86_isa_flags))\n     {\n-      if (optimize >= 1 && !global_options_set.x_flag_omit_frame_pointer)\n-\tflag_omit_frame_pointer = !USE_X86_64_FRAME_POINTER;\n-      if (flag_asynchronous_unwind_tables == 2)\n-\tflag_unwind_tables = flag_asynchronous_unwind_tables = 1;\n-      if (flag_pcc_struct_return == 2)\n-\tflag_pcc_struct_return = 0;\n+      if (opts->x_optimize >= 1 && !opts_set->x_flag_omit_frame_pointer)\n+\topts->x_flag_omit_frame_pointer = !USE_X86_64_FRAME_POINTER;\n+      if (opts->x_flag_asynchronous_unwind_tables == 2)\n+\topts->x_flag_unwind_tables\n+\t  = opts->x_flag_asynchronous_unwind_tables = 1;\n+      if (opts->x_flag_pcc_struct_return == 2)\n+\topts->x_flag_pcc_struct_return = 0;\n     }\n   else\n     {\n-      if (optimize >= 1 && !global_options_set.x_flag_omit_frame_pointer)\n-\tflag_omit_frame_pointer = !(USE_IX86_FRAME_POINTER || optimize_size);\n-      if (flag_asynchronous_unwind_tables == 2)\n-\tflag_asynchronous_unwind_tables = !USE_IX86_FRAME_POINTER;\n-      if (flag_pcc_struct_return == 2)\n-\tflag_pcc_struct_return = DEFAULT_PCC_STRUCT_RETURN;\n+      if (opts->x_optimize >= 1 && !opts_set->x_flag_omit_frame_pointer)\n+\topts->x_flag_omit_frame_pointer\n+\t  = !(USE_IX86_FRAME_POINTER || opts->x_optimize_size);\n+      if (opts->x_flag_asynchronous_unwind_tables == 2)\n+\topts->x_flag_asynchronous_unwind_tables = !USE_IX86_FRAME_POINTER;\n+      if (opts->x_flag_pcc_struct_return == 2)\n+\topts->x_flag_pcc_struct_return = DEFAULT_PCC_STRUCT_RETURN;\n     }\n \n   ix86_tune_cost = processor_target_table[ix86_tune].cost;\n-  if (optimize_size)\n+  if (opts->x_optimize_size)\n     ix86_cost = &ix86_size_cost;\n   else\n     ix86_cost = ix86_tune_cost;\n@@ -3597,148 +3615,160 @@ ix86_option_override_internal (bool main_args_p)\n   init_machine_status = ix86_init_machine_status;\n \n   /* Validate -mregparm= value.  */\n-  if (global_options_set.x_ix86_regparm)\n+  if (opts_set->x_ix86_regparm)\n     {\n-      if (TARGET_64BIT)\n+      if (TARGET_64BIT_P (opts->x_ix86_isa_flags))\n \twarning (0, \"-mregparm is ignored in 64-bit mode\");\n-      if (ix86_regparm > REGPARM_MAX)\n+      if (opts->x_ix86_regparm > REGPARM_MAX)\n \t{\n \t  error (\"-mregparm=%d is not between 0 and %d\",\n-\t\t ix86_regparm, REGPARM_MAX);\n-\t  ix86_regparm = 0;\n+\t\t opts->x_ix86_regparm, REGPARM_MAX);\n+\t  opts->x_ix86_regparm = 0;\n \t}\n     }\n-  if (TARGET_64BIT)\n-    ix86_regparm = REGPARM_MAX;\n+  if (TARGET_64BIT_P (opts->x_ix86_isa_flags))\n+    opts->x_ix86_regparm = REGPARM_MAX;\n \n   /* Default align_* from the processor table.  */\n-  if (align_loops == 0)\n+  if (opts->x_align_loops == 0)\n     {\n-      align_loops = processor_target_table[ix86_tune].align_loop;\n+      opts->x_align_loops = processor_target_table[ix86_tune].align_loop;\n       align_loops_max_skip = processor_target_table[ix86_tune].align_loop_max_skip;\n     }\n-  if (align_jumps == 0)\n+  if (opts->x_align_jumps == 0)\n     {\n-      align_jumps = processor_target_table[ix86_tune].align_jump;\n+      opts->x_align_jumps = processor_target_table[ix86_tune].align_jump;\n       align_jumps_max_skip = processor_target_table[ix86_tune].align_jump_max_skip;\n     }\n-  if (align_functions == 0)\n+  if (opts->x_align_functions == 0)\n     {\n-      align_functions = processor_target_table[ix86_tune].align_func;\n+      opts->x_align_functions = processor_target_table[ix86_tune].align_func;\n     }\n \n   /* Provide default for -mbranch-cost= value.  */\n-  if (!global_options_set.x_ix86_branch_cost)\n-    ix86_branch_cost = ix86_cost->branch_cost;\n+  if (!opts_set->x_ix86_branch_cost)\n+    opts->x_ix86_branch_cost = ix86_cost->branch_cost;\n \n-  if (TARGET_64BIT)\n+  if (TARGET_64BIT_P (opts->x_ix86_isa_flags))\n     {\n-      target_flags |= TARGET_SUBTARGET64_DEFAULT & ~target_flags_explicit;\n+      opts->x_target_flags\n+\t|= TARGET_SUBTARGET64_DEFAULT & ~opts_set->x_target_flags;\n \n       /* Enable by default the SSE and MMX builtins.  Do allow the user to\n \t explicitly disable any of these.  In particular, disabling SSE and\n \t MMX for kernel code is extremely useful.  */\n       if (!ix86_arch_specified)\n-      ix86_isa_flags\n+      opts->x_ix86_isa_flags\n \t|= ((OPTION_MASK_ISA_SSE2 | OPTION_MASK_ISA_SSE | OPTION_MASK_ISA_MMX\n-\t     | TARGET_SUBTARGET64_ISA_DEFAULT) & ~ix86_isa_flags_explicit);\n+\t     | TARGET_SUBTARGET64_ISA_DEFAULT)\n+            & ~opts->x_ix86_isa_flags_explicit);\n \n-      if (TARGET_RTD)\n+      if (TARGET_RTD_P (opts->x_target_flags))\n \twarning (0, \"%srtd%s is ignored in 64bit mode\", prefix, suffix);\n     }\n   else\n     {\n-      target_flags |= TARGET_SUBTARGET32_DEFAULT & ~target_flags_explicit;\n+      opts->x_target_flags\n+\t|= TARGET_SUBTARGET32_DEFAULT & ~opts_set->x_target_flags;\n \n       if (!ix86_arch_specified)\n-      ix86_isa_flags\n-\t|= TARGET_SUBTARGET32_ISA_DEFAULT & ~ix86_isa_flags_explicit;\n+        opts->x_ix86_isa_flags\n+\t  |= TARGET_SUBTARGET32_ISA_DEFAULT & ~opts->x_ix86_isa_flags_explicit;\n \n       /* i386 ABI does not specify red zone.  It still makes sense to use it\n          when programmer takes care to stack from being destroyed.  */\n-      if (!(target_flags_explicit & MASK_NO_RED_ZONE))\n-        target_flags |= MASK_NO_RED_ZONE;\n+      if (!(opts_set->x_target_flags & MASK_NO_RED_ZONE))\n+        opts->x_target_flags |= MASK_NO_RED_ZONE;\n     }\n \n   /* Keep nonleaf frame pointers.  */\n-  if (flag_omit_frame_pointer)\n-    target_flags &= ~MASK_OMIT_LEAF_FRAME_POINTER;\n-  else if (TARGET_OMIT_LEAF_FRAME_POINTER)\n-    flag_omit_frame_pointer = 1;\n+  if (opts->x_flag_omit_frame_pointer)\n+    opts->x_target_flags &= ~MASK_OMIT_LEAF_FRAME_POINTER;\n+  else if (TARGET_OMIT_LEAF_FRAME_POINTER_P (opts->x_target_flags))\n+    opts->x_flag_omit_frame_pointer = 1;\n \n   /* If we're doing fast math, we don't care about comparison order\n      wrt NaNs.  This lets us use a shorter comparison sequence.  */\n-  if (flag_finite_math_only)\n-    target_flags &= ~MASK_IEEE_FP;\n+  if (opts->x_flag_finite_math_only)\n+    opts->x_target_flags &= ~MASK_IEEE_FP;\n \n   /* If the architecture always has an FPU, turn off NO_FANCY_MATH_387,\n      since the insns won't need emulation.  */\n   if (x86_arch_always_fancy_math_387 & ix86_arch_mask)\n-    target_flags &= ~MASK_NO_FANCY_MATH_387;\n+    opts->x_target_flags &= ~MASK_NO_FANCY_MATH_387;\n \n   /* Likewise, if the target doesn't have a 387, or we've specified\n      software floating point, don't use 387 inline intrinsics.  */\n-  if (!TARGET_80387)\n-    target_flags |= MASK_NO_FANCY_MATH_387;\n+  if (!TARGET_80387_P (opts->x_target_flags))\n+    opts->x_target_flags |= MASK_NO_FANCY_MATH_387;\n \n   /* Turn on MMX builtins for -msse.  */\n-  if (TARGET_SSE)\n-    ix86_isa_flags |= OPTION_MASK_ISA_MMX & ~ix86_isa_flags_explicit;\n+  if (TARGET_SSE_P (opts->x_ix86_isa_flags))\n+    opts->x_ix86_isa_flags\n+      |= OPTION_MASK_ISA_MMX & ~opts->x_ix86_isa_flags_explicit;\n \n   /* Enable SSE prefetch.  */\n-  if (TARGET_SSE || (TARGET_PRFCHW && !TARGET_3DNOW))\n+  if (TARGET_SSE_P (opts->x_ix86_isa_flags)\n+      || (TARGET_PRFCHW && !TARGET_3DNOW_P (opts->x_ix86_isa_flags)))\n     x86_prefetch_sse = true;\n \n   /* Enable prefetch{,w} instructions for -m3dnow.  */\n-  if (TARGET_3DNOW)\n-    ix86_isa_flags |= OPTION_MASK_ISA_PRFCHW & ~ix86_isa_flags_explicit;\n+  if (TARGET_3DNOW_P (opts->x_ix86_isa_flags))\n+    opts->x_ix86_isa_flags\n+      |= OPTION_MASK_ISA_PRFCHW & ~opts->x_ix86_isa_flags_explicit;\n \n   /* Enable popcnt instruction for -msse4.2 or -mabm.  */\n-  if (TARGET_SSE4_2 || TARGET_ABM)\n-    ix86_isa_flags |= OPTION_MASK_ISA_POPCNT & ~ix86_isa_flags_explicit;\n+  if (TARGET_SSE4_2_P (opts->x_ix86_isa_flags)\n+      || TARGET_ABM_P (opts->x_ix86_isa_flags))\n+    opts->x_ix86_isa_flags\n+      |= OPTION_MASK_ISA_POPCNT & ~opts->x_ix86_isa_flags_explicit;\n \n   /* Enable lzcnt instruction for -mabm.  */\n-  if (TARGET_ABM)\n-    ix86_isa_flags |= OPTION_MASK_ISA_LZCNT & ~ix86_isa_flags_explicit;\n+  if (TARGET_ABM_P(opts->x_ix86_isa_flags))\n+    opts->x_ix86_isa_flags\n+      |= OPTION_MASK_ISA_LZCNT & ~opts->x_ix86_isa_flags_explicit;\n \n   /* Validate -mpreferred-stack-boundary= value or default it to\n      PREFERRED_STACK_BOUNDARY_DEFAULT.  */\n   ix86_preferred_stack_boundary = PREFERRED_STACK_BOUNDARY_DEFAULT;\n-  if (global_options_set.x_ix86_preferred_stack_boundary_arg)\n+  if (opts_set->x_ix86_preferred_stack_boundary_arg)\n     {\n-      int min = (TARGET_64BIT ? (TARGET_SSE ? 4 : 3) : 2);\n+      int min = (TARGET_64BIT_P (opts->x_ix86_isa_flags)\n+\t\t ? (TARGET_SSE_P (opts->x_ix86_isa_flags) ? 4 : 3) : 2);\n       int max = (TARGET_SEH ? 4 : 12);\n \n-      if (ix86_preferred_stack_boundary_arg < min\n-\t  || ix86_preferred_stack_boundary_arg > max)\n+      if (opts->x_ix86_preferred_stack_boundary_arg < min\n+\t  || opts->x_ix86_preferred_stack_boundary_arg > max)\n \t{\n \t  if (min == max)\n \t    error (\"-mpreferred-stack-boundary is not supported \"\n \t\t   \"for this target\");\n \t  else\n \t    error (\"-mpreferred-stack-boundary=%d is not between %d and %d\",\n-\t\t   ix86_preferred_stack_boundary_arg, min, max);\n+\t\t   opts->x_ix86_preferred_stack_boundary_arg, min, max);\n \t}\n       else\n \tix86_preferred_stack_boundary\n-\t  = (1 << ix86_preferred_stack_boundary_arg) * BITS_PER_UNIT;\n+\t  = (1 << opts->x_ix86_preferred_stack_boundary_arg) * BITS_PER_UNIT;\n     }\n \n   /* Set the default value for -mstackrealign.  */\n-  if (ix86_force_align_arg_pointer == -1)\n-    ix86_force_align_arg_pointer = STACK_REALIGN_DEFAULT;\n+  if (opts->x_ix86_force_align_arg_pointer == -1)\n+    opts->x_ix86_force_align_arg_pointer = STACK_REALIGN_DEFAULT;\n \n   ix86_default_incoming_stack_boundary = PREFERRED_STACK_BOUNDARY;\n \n   /* Validate -mincoming-stack-boundary= value or default it to\n      MIN_STACK_BOUNDARY/PREFERRED_STACK_BOUNDARY.  */\n   ix86_incoming_stack_boundary = ix86_default_incoming_stack_boundary;\n-  if (global_options_set.x_ix86_incoming_stack_boundary_arg)\n+  if (opts_set->x_ix86_incoming_stack_boundary_arg)\n     {\n-      if (ix86_incoming_stack_boundary_arg < (TARGET_64BIT ? 4 : 2)\n+      if (ix86_incoming_stack_boundary_arg\n+\t  < (TARGET_64BIT_P (opts->x_ix86_isa_flags) ? 4 : 2)\n \t  || ix86_incoming_stack_boundary_arg > 12)\n \terror (\"-mincoming-stack-boundary=%d is not between %d and 12\",\n-\t       ix86_incoming_stack_boundary_arg, TARGET_64BIT ? 4 : 2);\n+\t       ix86_incoming_stack_boundary_arg,\n+\t       TARGET_64BIT_P (opts->x_ix86_isa_flags) ? 4 : 2);\n       else\n \t{\n \t  ix86_user_incoming_stack_boundary\n@@ -3749,23 +3779,24 @@ ix86_option_override_internal (bool main_args_p)\n     }\n \n   /* Accept -msseregparm only if at least SSE support is enabled.  */\n-  if (TARGET_SSEREGPARM\n-      && ! TARGET_SSE)\n+  if (TARGET_SSEREGPARM_P (opts->x_target_flags)\n+      && ! TARGET_SSE_P (opts->x_ix86_isa_flags))\n     error (\"%ssseregparm%s used without SSE enabled\", prefix, suffix);\n \n-  if (global_options_set.x_ix86_fpmath)\n+  if (opts_set->x_ix86_fpmath)\n     {\n-      if (ix86_fpmath & FPMATH_SSE)\n+      if (opts->x_ix86_fpmath & FPMATH_SSE)\n \t{\n-\t  if (!TARGET_SSE)\n+\t  if (!TARGET_SSE_P (opts->x_ix86_isa_flags))\n \t    {\n \t      warning (0, \"SSE instruction set disabled, using 387 arithmetics\");\n-\t      ix86_fpmath = FPMATH_387;\n+\t      opts->x_ix86_fpmath = FPMATH_387;\n \t    }\n-\t  else if ((ix86_fpmath & FPMATH_387) && !TARGET_80387)\n+\t  else if ((opts->x_ix86_fpmath & FPMATH_387)\n+\t\t   && !TARGET_80387_P (opts->x_target_flags))\n \t    {\n \t      warning (0, \"387 instruction set disabled, using SSE arithmetics\");\n-\t      ix86_fpmath = FPMATH_SSE;\n+\t      opts->x_ix86_fpmath = FPMATH_SSE;\n \t    }\n \t}\n     }\n@@ -3783,15 +3814,15 @@ ix86_option_override_internal (bool main_args_p)\n \t   && TARGET_SSE2)\n     ix86_fpmath = FPMATH_SSE;\n   else\n-    ix86_fpmath = TARGET_FPMATH_DEFAULT;\n+    opts->x_ix86_fpmath = TARGET_FPMATH_DEFAULT_P (opts->x_ix86_isa_flags);\n \n   /* If the i387 is disabled, then do not return values in it. */\n-  if (!TARGET_80387)\n-    target_flags &= ~MASK_FLOAT_RETURNS;\n+  if (!TARGET_80387_P (opts->x_target_flags))\n+    opts->x_target_flags &= ~MASK_FLOAT_RETURNS;\n \n   /* Use external vectorized library in vectorizing intrinsics.  */\n-  if (global_options_set.x_ix86_veclibabi_type)\n-    switch (ix86_veclibabi_type)\n+  if (opts_set->x_ix86_veclibabi_type)\n+    switch (opts->x_ix86_veclibabi_type)\n       {\n       case ix86_veclibabi_type_svml:\n \tix86_veclib_handler = ix86_veclibabi_svml;\n@@ -3807,20 +3838,20 @@ ix86_option_override_internal (bool main_args_p)\n \n   ix86_tune_mask = 1u << ix86_tune;\n   if ((x86_accumulate_outgoing_args & ix86_tune_mask)\n-      && !(target_flags_explicit & MASK_ACCUMULATE_OUTGOING_ARGS)\n-      && !optimize_size)\n-    target_flags |= MASK_ACCUMULATE_OUTGOING_ARGS;\n+      && !(opts_set->x_target_flags & MASK_ACCUMULATE_OUTGOING_ARGS)\n+      && !opts->x_optimize_size)\n+    opts->x_target_flags |= MASK_ACCUMULATE_OUTGOING_ARGS;\n \n   /* If stack probes are required, the space used for large function\n      arguments on the stack must also be probed, so enable\n      -maccumulate-outgoing-args so this happens in the prologue.  */\n-  if (TARGET_STACK_PROBE\n-      && !(target_flags & MASK_ACCUMULATE_OUTGOING_ARGS))\n+  if (TARGET_STACK_PROBE_P (opts->x_target_flags)\n+      && !(opts->x_target_flags & MASK_ACCUMULATE_OUTGOING_ARGS))\n     {\n-      if (target_flags_explicit & MASK_ACCUMULATE_OUTGOING_ARGS)\n+      if (opts_set->x_target_flags & MASK_ACCUMULATE_OUTGOING_ARGS)\n \twarning (0, \"stack probing requires %saccumulate-outgoing-args%s \"\n \t\t \"for correctness\", prefix, suffix);\n-      target_flags |= MASK_ACCUMULATE_OUTGOING_ARGS;\n+      opts->x_target_flags |= MASK_ACCUMULATE_OUTGOING_ARGS;\n     }\n \n   /* Figure out what ASM_GENERATE_INTERNAL_LABEL builds as a prefix.  */\n@@ -3835,38 +3866,38 @@ ix86_option_override_internal (bool main_args_p)\n   /* When scheduling description is not available, disable scheduler pass\n      so it won't slow down the compilation and make x87 code slower.  */\n   if (!TARGET_SCHEDULE)\n-    flag_schedule_insns_after_reload = flag_schedule_insns = 0;\n+    opts->x_flag_schedule_insns_after_reload = opts->x_flag_schedule_insns = 0;\n \n   maybe_set_param_value (PARAM_SIMULTANEOUS_PREFETCHES,\n \t\t\t ix86_tune_cost->simultaneous_prefetches,\n-\t\t\t global_options.x_param_values,\n-\t\t\t global_options_set.x_param_values);\n+\t\t\t opts->x_param_values,\n+\t\t\t opts_set->x_param_values);\n   maybe_set_param_value (PARAM_L1_CACHE_LINE_SIZE,\n \t\t\t ix86_tune_cost->prefetch_block,\n-\t\t\t global_options.x_param_values,\n-\t\t\t global_options_set.x_param_values);\n+\t\t\t opts->x_param_values,\n+\t\t\t opts_set->x_param_values);\n   maybe_set_param_value (PARAM_L1_CACHE_SIZE,\n \t\t\t ix86_tune_cost->l1_cache_size,\n-\t\t\t global_options.x_param_values,\n-\t\t\t global_options_set.x_param_values);\n+\t\t\t opts->x_param_values,\n+\t\t\t opts_set->x_param_values);\n   maybe_set_param_value (PARAM_L2_CACHE_SIZE,\n \t\t\t ix86_tune_cost->l2_cache_size,\n-\t\t\t global_options.x_param_values,\n-\t\t\t global_options_set.x_param_values);\n+\t\t\t opts->x_param_values,\n+\t\t\t opts_set->x_param_values);\n \n   /* Enable sw prefetching at -O3 for CPUS that prefetching is helpful.  */\n-  if (flag_prefetch_loop_arrays < 0\n+  if (opts->x_flag_prefetch_loop_arrays < 0\n       && HAVE_prefetch\n-      && (optimize >= 3 || flag_profile_use)\n+      && (opts->x_optimize >= 3 || opts->x_flag_profile_use)\n       && TARGET_SOFTWARE_PREFETCHING_BENEFICIAL)\n-    flag_prefetch_loop_arrays = 1;\n+    opts->x_flag_prefetch_loop_arrays = 1;\n \n   /* If using typedef char *va_list, signal that __builtin_va_start (&ap, 0)\n-     can be optimized to ap = __builtin_next_arg (0).  */\n-  if (!TARGET_64BIT && !flag_split_stack)\n+     can be opts->x_optimized to ap = __builtin_next_arg (0).  */\n+  if (!TARGET_64BIT_P (opts->x_ix86_isa_flags) && !opts->x_flag_split_stack)\n     targetm.expand_builtin_va_start = NULL;\n \n-  if (TARGET_64BIT)\n+  if (TARGET_64BIT_P (opts->x_ix86_isa_flags))\n     {\n       ix86_gen_leave = gen_leave_rex64;\n       if (Pmode == DImode)\n@@ -3912,56 +3943,56 @@ ix86_option_override_internal (bool main_args_p)\n \n #ifdef USE_IX86_CLD\n   /* Use -mcld by default for 32-bit code if configured with --enable-cld.  */\n-  if (!TARGET_64BIT)\n-    target_flags |= MASK_CLD & ~target_flags_explicit;\n+  if (!TARGET_64BIT_P (opts->x_ix86_isa_flags))\n+    opts->x_target_flags |= MASK_CLD & ~opts_set->x_target_flags;\n #endif\n \n-  if (!TARGET_64BIT && flag_pic)\n+  if (!TARGET_64BIT_P (opts->x_ix86_isa_flags) && opts->x_flag_pic)\n     {\n-      if (flag_fentry > 0)\n+      if (opts->x_flag_fentry > 0)\n         sorry (\"-mfentry isn%'t supported for 32-bit in combination \"\n \t       \"with -fpic\");\n-      flag_fentry = 0;\n+      opts->x_flag_fentry = 0;\n     }\n   else if (TARGET_SEH)\n     {\n-      if (flag_fentry == 0)\n+      if (opts->x_flag_fentry == 0)\n \tsorry (\"-mno-fentry isn%'t compatible with SEH\");\n-      flag_fentry = 1;\n+      opts->x_flag_fentry = 1;\n     }\n-  else if (flag_fentry < 0)\n+  else if (opts->x_flag_fentry < 0)\n    {\n #if defined(PROFILE_BEFORE_PROLOGUE)\n-     flag_fentry = 1;\n+     opts->x_flag_fentry = 1;\n #else\n-     flag_fentry = 0;\n+     opts->x_flag_fentry = 0;\n #endif\n    }\n \n-  /* When not optimize for size, enable vzeroupper optimization for\n+  /* When not opts->x_optimize for size, enable vzeroupper optimization for\n      TARGET_AVX with -fexpensive-optimizations and split 32-byte\n      AVX unaligned load/store.  */\n-  if (!optimize_size)\n+  if (!opts->x_optimize_size)\n     {\n       if (flag_expensive_optimizations\n-\t  && !(target_flags_explicit & MASK_VZEROUPPER))\n-\ttarget_flags |= MASK_VZEROUPPER;\n+\t  && !(opts_set->x_target_flags & MASK_VZEROUPPER))\n+\topts->x_target_flags |= MASK_VZEROUPPER;\n       if ((x86_avx256_split_unaligned_load & ix86_tune_mask)\n-\t  && !(target_flags_explicit & MASK_AVX256_SPLIT_UNALIGNED_LOAD))\n-\ttarget_flags |= MASK_AVX256_SPLIT_UNALIGNED_LOAD;\n+\t  && !(opts_set->x_target_flags & MASK_AVX256_SPLIT_UNALIGNED_LOAD))\n+\topts->x_target_flags |= MASK_AVX256_SPLIT_UNALIGNED_LOAD;\n       if ((x86_avx256_split_unaligned_store & ix86_tune_mask)\n-\t  && !(target_flags_explicit & MASK_AVX256_SPLIT_UNALIGNED_STORE))\n-\ttarget_flags |= MASK_AVX256_SPLIT_UNALIGNED_STORE;\n+\t  && !(opts_set->x_target_flags & MASK_AVX256_SPLIT_UNALIGNED_STORE))\n+\topts->x_target_flags |= MASK_AVX256_SPLIT_UNALIGNED_STORE;\n       /* Enable 128-bit AVX instruction generation\n          for the auto-vectorizer.  */\n       if (TARGET_AVX128_OPTIMAL\n-\t  && !(target_flags_explicit & MASK_PREFER_AVX128))\n-\ttarget_flags |= MASK_PREFER_AVX128;\n+\t  && !(opts_set->x_target_flags & MASK_PREFER_AVX128))\n+\topts->x_target_flags |= MASK_PREFER_AVX128;\n     }\n \n-  if (ix86_recip_name)\n+  if (opts->x_ix86_recip_name)\n     {\n-      char *p = ASTRDUP (ix86_recip_name);\n+      char *p = ASTRDUP (opts->x_ix86_recip_name);\n       char *q;\n       unsigned int mask, i;\n       bool invert;\n@@ -3996,45 +4027,46 @@ ix86_option_override_internal (bool main_args_p)\n \t\t}\n \t    }\n \n-\t  recip_mask_explicit |= mask;\n+\t  opts->x_recip_mask_explicit |= mask;\n \t  if (invert)\n-\t    recip_mask &= ~mask;\n+\t    opts->x_recip_mask &= ~mask;\n \t  else\n-\t    recip_mask |= mask;\n+\t    opts->x_recip_mask |= mask;\n \t}\n     }\n \n-  if (TARGET_RECIP)\n-    recip_mask |= RECIP_MASK_ALL & ~recip_mask_explicit;\n-  else if (target_flags_explicit & MASK_RECIP)\n-    recip_mask &= ~(RECIP_MASK_ALL & ~recip_mask_explicit);\n+  if (TARGET_RECIP_P (opts->x_target_flags))\n+    opts->x_recip_mask |= RECIP_MASK_ALL & ~opts->x_recip_mask_explicit;\n+  else if (opts_set->x_target_flags & MASK_RECIP)\n+    opts->x_recip_mask &= ~(RECIP_MASK_ALL & ~opts->x_recip_mask_explicit);\n \n   /* Default long double to 64-bit for Bionic.  */\n   if (TARGET_HAS_BIONIC\n-      && !(target_flags_explicit & MASK_LONG_DOUBLE_64))\n-    target_flags |= MASK_LONG_DOUBLE_64;\n+      && !(opts_set->x_target_flags & MASK_LONG_DOUBLE_64))\n+    opts->x_target_flags |= MASK_LONG_DOUBLE_64;\n \n   /* Save the initial options in case the user does function specific\n      options.  */\n   if (main_args_p)\n     target_option_default_node = target_option_current_node\n-      = build_target_option_node ();\n+      = build_target_option_node (opts);\n \n   /* Handle stack protector */\n-  if (!global_options_set.x_ix86_stack_protector_guard)\n-    ix86_stack_protector_guard = TARGET_HAS_BIONIC ? SSP_GLOBAL : SSP_TLS;\n+  if (!opts_set->x_ix86_stack_protector_guard)\n+    opts->x_ix86_stack_protector_guard\n+      = TARGET_HAS_BIONIC ? SSP_GLOBAL : SSP_TLS;\n \n   /* Handle -mmemcpy-strategy= and -mmemset-strategy=  */\n-  if (ix86_tune_memcpy_strategy)\n+  if (opts->x_ix86_tune_memcpy_strategy)\n     {\n-      char *str = xstrdup (ix86_tune_memcpy_strategy);\n+      char *str = xstrdup (opts->x_ix86_tune_memcpy_strategy);\n       ix86_parse_stringop_strategy_string (str, false);\n       free (str);\n     }\n \n-  if (ix86_tune_memset_strategy)\n+  if (opts->x_ix86_tune_memset_strategy)\n     {\n-      char *str = xstrdup (ix86_tune_memset_strategy);\n+      char *str = xstrdup (opts->x_ix86_tune_memset_strategy);\n       ix86_parse_stringop_strategy_string (str, true);\n       free (str);\n     }\n@@ -4051,7 +4083,7 @@ ix86_option_override (void)\n \t1, PASS_POS_INSERT_AFTER\n       };\n \n-  ix86_option_override_internal (true);\n+  ix86_option_override_internal (true, &global_options, &global_options_set);\n \n \n   /* This needs to be done at start up.  It's convenient to do it here.  */\n@@ -4136,17 +4168,18 @@ ix86_conditional_register_usage (void)\n /* Save the current options */\n \n static void\n-ix86_function_specific_save (struct cl_target_option *ptr)\n+ix86_function_specific_save (struct cl_target_option *ptr,\n+\t\t\t     struct gcc_options *opts)\n {\n   ptr->arch = ix86_arch;\n   ptr->schedule = ix86_schedule;\n   ptr->tune = ix86_tune;\n   ptr->branch_cost = ix86_branch_cost;\n   ptr->tune_defaulted = ix86_tune_defaulted;\n   ptr->arch_specified = ix86_arch_specified;\n-  ptr->x_ix86_isa_flags_explicit = ix86_isa_flags_explicit;\n-  ptr->ix86_target_flags_explicit = target_flags_explicit;\n-  ptr->x_recip_mask_explicit = recip_mask_explicit;\n+  ptr->x_ix86_isa_flags_explicit = opts->x_ix86_isa_flags_explicit;\n+  ptr->x_ix86_target_flags_explicit = opts->x_ix86_target_flags_explicit;\n+  ptr->x_recip_mask_explicit = opts->x_recip_mask_explicit;\n \n   /* The fields are char but the variables are not; make sure the\n      values fit in the fields.  */\n@@ -4159,7 +4192,8 @@ ix86_function_specific_save (struct cl_target_option *ptr)\n /* Restore the current options */\n \n static void\n-ix86_function_specific_restore (struct cl_target_option *ptr)\n+ix86_function_specific_restore (struct gcc_options *opts,\n+\t\t\t\tstruct cl_target_option *ptr)\n {\n   enum processor_type old_tune = ix86_tune;\n   enum processor_type old_arch = ix86_arch;\n@@ -4169,12 +4203,12 @@ ix86_function_specific_restore (struct cl_target_option *ptr)\n   ix86_arch = (enum processor_type) ptr->arch;\n   ix86_schedule = (enum attr_cpu) ptr->schedule;\n   ix86_tune = (enum processor_type) ptr->tune;\n-  ix86_branch_cost = ptr->branch_cost;\n+  opts->x_ix86_branch_cost = ptr->branch_cost;\n   ix86_tune_defaulted = ptr->tune_defaulted;\n   ix86_arch_specified = ptr->arch_specified;\n-  ix86_isa_flags_explicit = ptr->x_ix86_isa_flags_explicit;\n-  target_flags_explicit = ptr->ix86_target_flags_explicit;\n-  recip_mask_explicit = ptr->x_recip_mask_explicit;\n+  opts->x_ix86_isa_flags_explicit = ptr->x_ix86_isa_flags_explicit;\n+  opts->x_ix86_target_flags_explicit = ptr->x_ix86_target_flags_explicit;\n+  opts->x_recip_mask_explicit = ptr->x_recip_mask_explicit;\n \n   /* Recreate the arch feature tests if the arch changed */\n   if (old_arch != ix86_arch)\n@@ -4230,6 +4264,8 @@ ix86_function_specific_print (FILE *file, int indent,\n \n static bool\n ix86_valid_target_attribute_inner_p (tree args, char *p_strings[],\n+\t\t\t\t     struct gcc_options *opts,\n+\t\t\t\t     struct gcc_options *opts_set,\n \t\t\t\t     struct gcc_options *enum_opts_set)\n {\n   char *next_optstr;\n@@ -4346,7 +4382,8 @@ ix86_valid_target_attribute_inner_p (tree args, char *p_strings[],\n       for (; args; args = TREE_CHAIN (args))\n \tif (TREE_VALUE (args)\n \t    && !ix86_valid_target_attribute_inner_p (TREE_VALUE (args),\n-\t\t\t\t\t\t     p_strings, enum_opts_set))\n+\t\t\t\t\t\t     p_strings, opts, opts_set,\n+\t\t\t\t\t\t     enum_opts_set))\n \t  ret = false;\n \n       return ret;\n@@ -4429,7 +4466,7 @@ ix86_valid_target_attribute_inner_p (tree args, char *p_strings[],\n \t  struct cl_decoded_option decoded;\n \n \t  generate_option (opt, NULL, opt_set_p, CL_TARGET, &decoded);\n-\t  ix86_handle_option (&global_options, &global_options_set,\n+\t  ix86_handle_option (opts, opts_set,\n \t\t\t      &decoded, input_location);\n \t}\n \n@@ -4439,9 +4476,9 @@ ix86_valid_target_attribute_inner_p (tree args, char *p_strings[],\n \t    opt_set_p = !opt_set_p;\n \n \t  if (opt_set_p)\n-\t    target_flags |= mask;\n+\t    opts->x_target_flags |= mask;\n \t  else\n-\t    target_flags &= ~mask;\n+\t    opts->x_target_flags &= ~mask;\n \t}\n \n       else if (type == ix86_opt_str)\n@@ -4462,7 +4499,7 @@ ix86_valid_target_attribute_inner_p (tree args, char *p_strings[],\n \n \t  arg_ok = opt_enum_arg_to_value (opt, p + opt_len, &value, CL_TARGET);\n \t  if (arg_ok)\n-\t    set_option (&global_options, enum_opts_set, opt, value,\n+\t    set_option (opts, enum_opts_set, opt, value,\n \t\t\tp + opt_len, DK_UNSPECIFIED, input_location,\n \t\t\tglobal_dc);\n \t  else\n@@ -4482,11 +4519,13 @@ ix86_valid_target_attribute_inner_p (tree args, char *p_strings[],\n /* Return a TARGET_OPTION_NODE tree of the target options listed or NULL.  */\n \n tree\n-ix86_valid_target_attribute_tree (tree args)\n+ix86_valid_target_attribute_tree (tree args,\n+\t\t\t\t  struct gcc_options *opts,\n+\t\t\t\t  struct gcc_options *opts_set)\n {\n   const char *orig_arch_string = ix86_arch_string;\n   const char *orig_tune_string = ix86_tune_string;\n-  enum fpmath_unit orig_fpmath_set = global_options_set.x_ix86_fpmath;\n+  enum fpmath_unit orig_fpmath_set = opts_set->x_ix86_fpmath;\n   int orig_tune_defaulted = ix86_tune_defaulted;\n   int orig_arch_specified = ix86_arch_specified;\n   char *option_strings[IX86_FUNCTION_SPECIFIC_MAX] = { NULL, NULL };\n@@ -4499,54 +4538,54 @@ ix86_valid_target_attribute_tree (tree args)\n   memset (&enum_opts_set, 0, sizeof (enum_opts_set));\n \n   /* Process each of the options on the chain.  */\n-  if (! ix86_valid_target_attribute_inner_p (args, option_strings,\n-\t\t\t\t\t     &enum_opts_set))\n+  if (! ix86_valid_target_attribute_inner_p (args, option_strings, opts,\n+\t\t\t\t\t     opts_set, &enum_opts_set))\n     return error_mark_node;\n \n   /* If the changed options are different from the default, rerun\n      ix86_option_override_internal, and then save the options away.\n      The string options are are attribute options, and will be undone\n      when we copy the save structure.  */\n-  if (ix86_isa_flags != def->x_ix86_isa_flags\n-      || target_flags != def->x_target_flags\n+  if (opts->x_ix86_isa_flags != def->x_ix86_isa_flags\n+      || opts->x_target_flags != def->x_target_flags\n       || option_strings[IX86_FUNCTION_SPECIFIC_ARCH]\n       || option_strings[IX86_FUNCTION_SPECIFIC_TUNE]\n       || enum_opts_set.x_ix86_fpmath)\n     {\n       /* If we are using the default tune= or arch=, undo the string assigned,\n \t and use the default.  */\n       if (option_strings[IX86_FUNCTION_SPECIFIC_ARCH])\n-\tix86_arch_string = option_strings[IX86_FUNCTION_SPECIFIC_ARCH];\n+\topts->x_ix86_arch_string = option_strings[IX86_FUNCTION_SPECIFIC_ARCH];\n       else if (!orig_arch_specified)\n-\tix86_arch_string = NULL;\n+\topts->x_ix86_arch_string = NULL;\n \n       if (option_strings[IX86_FUNCTION_SPECIFIC_TUNE])\n-\tix86_tune_string = option_strings[IX86_FUNCTION_SPECIFIC_TUNE];\n+\topts->x_ix86_tune_string = option_strings[IX86_FUNCTION_SPECIFIC_TUNE];\n       else if (orig_tune_defaulted)\n-\tix86_tune_string = NULL;\n+\topts->x_ix86_tune_string = NULL;\n \n       /* If fpmath= is not set, and we now have sse2 on 32-bit, use it.  */\n       if (enum_opts_set.x_ix86_fpmath)\n-\tglobal_options_set.x_ix86_fpmath = (enum fpmath_unit) 1;\n+\topts_set->x_ix86_fpmath = (enum fpmath_unit) 1;\n       else if (!TARGET_64BIT && TARGET_SSE)\n \t{\n-\t  ix86_fpmath = (enum fpmath_unit) (FPMATH_SSE | FPMATH_387);\n-\t  global_options_set.x_ix86_fpmath = (enum fpmath_unit) 1;\n+\t  opts->x_ix86_fpmath = (enum fpmath_unit) (FPMATH_SSE | FPMATH_387);\n+\t  opts_set->x_ix86_fpmath = (enum fpmath_unit) 1;\n \t}\n \n       /* Do any overrides, such as arch=xxx, or tune=xxx support.  */\n-      ix86_option_override_internal (false);\n+      ix86_option_override_internal (false, opts, opts_set);\n \n       /* Add any builtin functions with the new isa if any.  */\n-      ix86_add_new_builtins (ix86_isa_flags);\n+      ix86_add_new_builtins (opts->x_ix86_isa_flags);\n \n       /* Save the current options unless we are validating options for\n \t #pragma.  */\n-      t = build_target_option_node ();\n+      t = build_target_option_node (opts);\n \n-      ix86_arch_string = orig_arch_string;\n-      ix86_tune_string = orig_tune_string;\n-      global_options_set.x_ix86_fpmath = orig_fpmath_set;\n+      opts->x_ix86_arch_string = orig_arch_string;\n+      opts->x_ix86_tune_string = orig_tune_string;\n+      opts_set->x_ix86_fpmath = orig_fpmath_set;\n \n       /* Free up memory allocated to hold the strings */\n       for (i = 0; i < IX86_FUNCTION_SPECIFIC_MAX; i++)\n@@ -4564,7 +4603,8 @@ ix86_valid_target_attribute_p (tree fndecl,\n \t\t\t       tree args,\n \t\t\t       int ARG_UNUSED (flags))\n {\n-  struct cl_target_option cur_target;\n+  struct gcc_options func_options;\n+  tree new_target, new_optimize;\n   bool ret = true;\n \n   /* attribute((target(\"default\"))) does nothing, beyond\n@@ -4575,21 +4615,31 @@ ix86_valid_target_attribute_p (tree fndecl,\n       && strcmp (TREE_STRING_POINTER (TREE_VALUE (args)), \"default\") == 0)\n     return true;\n \n-  tree old_optimize = build_optimization_node ();\n-  tree new_target, new_optimize;\n+  tree old_optimize = build_optimization_node (&global_options);\n+\n+  /* Get the optimization options of the current function.  */  \n   tree func_optimize = DECL_FUNCTION_SPECIFIC_OPTIMIZATION (fndecl);\n+ \n+  if (!func_optimize)\n+    func_optimize = old_optimize;\n+\n+  /* Init func_options.  */\n+  memset (&func_options, 0, sizeof (func_options));\n+  init_options_struct (&func_options, NULL);\n+  lang_hooks.init_options_struct (&func_options);\n+ \n+  cl_optimization_restore (&func_options,\n+\t\t\t   TREE_OPTIMIZATION (func_optimize));\n \n-  /* If the function changed the optimization levels as well as setting target\n-     options, start with the optimizations specified.  */\n-  if (func_optimize && func_optimize != old_optimize)\n-    cl_optimization_restore (&global_options,\n-\t\t\t     TREE_OPTIMIZATION (func_optimize));\n+  /* Initialize func_options to the default before its target options can\n+     be set.  */\n+  cl_target_option_restore (&func_options,\n+\t\t\t    TREE_TARGET_OPTION (target_option_default_node));\n \n-  /* The target attributes may also change some optimization flags, so update\n-     the optimization options if necessary.  */\n-  cl_target_option_save (&cur_target, &global_options);\n-  new_target = ix86_valid_target_attribute_tree (args);\n-  new_optimize = build_optimization_node ();\n+  new_target = ix86_valid_target_attribute_tree (args, &func_options,\n+\t\t\t\t\t\t &global_options_set);\n+\n+  new_optimize = build_optimization_node (&func_options);\n \n   if (new_target == error_mark_node)\n     ret = false;\n@@ -4602,12 +4652,6 @@ ix86_valid_target_attribute_p (tree fndecl,\n \tDECL_FUNCTION_SPECIFIC_OPTIMIZATION (fndecl) = new_optimize;\n     }\n \n-  cl_target_option_restore (&global_options, &cur_target);\n-\n-  if (old_optimize != new_optimize)\n-    cl_optimization_restore (&global_options,\n-\t\t\t     TREE_OPTIMIZATION (old_optimize));\n-\n   return ret;\n }\n \n@@ -29309,7 +29353,8 @@ get_builtin_code_for_version (tree decl, tree *predicate_list)\n   if (strstr (attrs_str, \"arch=\") != NULL)\n     {\n       cl_target_option_save (&cur_target, &global_options);\n-      target_node = ix86_valid_target_attribute_tree (attrs);\n+      target_node = ix86_valid_target_attribute_tree (attrs, &global_options,\n+\t\t\t\t\t\t      &global_options_set);\n     \n       gcc_assert (target_node);\n       new_target = TREE_TARGET_OPTION (target_node);"}, {"sha": "10f7ff096c354d7819cb5bb7b434a829c2fb5980", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf7b5747bb33b0333786dfcc015e0f23136e5f18/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf7b5747bb33b0333786dfcc015e0f23136e5f18/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=bf7b5747bb33b0333786dfcc015e0f23136e5f18", "patch": "@@ -40,53 +40,99 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n /* Redefines for option macros.  */\n \n #define TARGET_64BIT\tTARGET_ISA_64BIT\n+#define TARGET_64BIT_P(x)\tTARGET_ISA_64BIT_P(x)\n #define TARGET_MMX\tTARGET_ISA_MMX\n+#define TARGET_MMX_P(x)\tTARGET_ISA_MMX_P(x)\n #define TARGET_3DNOW\tTARGET_ISA_3DNOW\n+#define TARGET_3DNOW_P(x)\tTARGET_ISA_3DNOW_P(x)\n #define TARGET_3DNOW_A\tTARGET_ISA_3DNOW_A\n+#define TARGET_3DNOW_A_P(x)\tTARGET_ISA_3DNOW_A_P(x)\n #define TARGET_SSE\tTARGET_ISA_SSE\n+#define TARGET_SSE_P(x)\tTARGET_ISA_SSE_P(x)\n #define TARGET_SSE2\tTARGET_ISA_SSE2\n+#define TARGET_SSE2_P(x)\tTARGET_ISA_SSE2_P(x)\n #define TARGET_SSE3\tTARGET_ISA_SSE3\n+#define TARGET_SSE3_P(x)\tTARGET_ISA_SSE3_P(x)\n #define TARGET_SSSE3\tTARGET_ISA_SSSE3\n+#define TARGET_SSSE3_P(x)\tTARGET_ISA_SSSE3_P(x)\n #define TARGET_SSE4_1\tTARGET_ISA_SSE4_1\n+#define TARGET_SSE4_1_P(x)\tTARGET_ISA_SSE4_1_P(x)\n #define TARGET_SSE4_2\tTARGET_ISA_SSE4_2\n+#define TARGET_SSE4_2_P(x)\tTARGET_ISA_SSE4_2_P(x)\n #define TARGET_AVX\tTARGET_ISA_AVX\n+#define TARGET_AVX_P(x)\tTARGET_ISA_AVX_P(x)\n #define TARGET_AVX2\tTARGET_ISA_AVX2\n+#define TARGET_AVX2_P(x)\tTARGET_ISA_AVX2_P(x)\n #define TARGET_AVX512F  TARGET_ISA_AVX512F\n+#define TARGET_AVX512F_P(x)  TARGET_ISA_AVX512F_P(x)\n #define TARGET_AVX512PF TARGET_ISA_AVX512PF\n+#define TARGET_AVX512PF_P(x) TARGET_ISA_AVX512PF_P(x)\n #define TARGET_AVX512ER TARGET_ISA_AVX512ER\n+#define TARGET_AVX512ER_P(x) TARGET_ISA_AVX512ER_P(x)\n #define TARGET_AVX512CD TARGET_ISA_AVX512CD\n+#define TARGET_AVX512CD_P(x) TARGET_ISA_AVX512CD_P(x)\n #define TARGET_FMA\tTARGET_ISA_FMA\n+#define TARGET_FMA_P(x)\tTARGET_ISA_FMA_P(x)\n #define TARGET_SSE4A\tTARGET_ISA_SSE4A\n+#define TARGET_SSE4A_P(x)\tTARGET_ISA_SSE4A_P(x)\n #define TARGET_FMA4\tTARGET_ISA_FMA4\n+#define TARGET_FMA4_P(x)\tTARGET_ISA_FMA4_P(x)\n #define TARGET_XOP\tTARGET_ISA_XOP\n+#define TARGET_XOP_P(x)\tTARGET_ISA_XOP_P(x)\n #define TARGET_LWP\tTARGET_ISA_LWP\n+#define TARGET_LWP_P(x)\tTARGET_ISA_LWP_P(x)\n #define TARGET_ROUND\tTARGET_ISA_ROUND\n #define TARGET_ABM\tTARGET_ISA_ABM\n+#define TARGET_ABM_P(x)\tTARGET_ISA_ABM_P(x)\n #define TARGET_BMI\tTARGET_ISA_BMI\n+#define TARGET_BMI_P(x)\tTARGET_ISA_BMI_P(x)\n #define TARGET_BMI2\tTARGET_ISA_BMI2\n+#define TARGET_BMI2_P(x)\tTARGET_ISA_BMI2_P(x)\n #define TARGET_LZCNT\tTARGET_ISA_LZCNT\n+#define TARGET_LZCNT_P(x)\tTARGET_ISA_LZCNT_P(x)\n #define TARGET_TBM\tTARGET_ISA_TBM\n+#define TARGET_TBM_P(x)\tTARGET_ISA_TBM_P(x)\n #define TARGET_POPCNT\tTARGET_ISA_POPCNT\n+#define TARGET_POPCNT_P(x)\tTARGET_ISA_POPCNT_P(x)\n #define TARGET_SAHF\tTARGET_ISA_SAHF\n+#define TARGET_SAHF_P(x)\tTARGET_ISA_SAHF_P(x)\n #define TARGET_MOVBE\tTARGET_ISA_MOVBE\n+#define TARGET_MOVBE_P(x)\tTARGET_ISA_MOVBE_P(x)\n #define TARGET_CRC32\tTARGET_ISA_CRC32\n+#define TARGET_CRC32_P(x)\tTARGET_ISA_CRC32_P(x)\n #define TARGET_AES\tTARGET_ISA_AES\n+#define TARGET_AES_P(x)\tTARGET_ISA_AES_P(x)\n #define TARGET_PCLMUL\tTARGET_ISA_PCLMUL\n+#define TARGET_PCLMUL_P(x)\tTARGET_ISA_PCLMUL_P(x)\n #define TARGET_CMPXCHG16B TARGET_ISA_CX16\n+#define TARGET_CMPXCHG16B_P(x) TARGET_ISA_CX16_P(x)\n #define TARGET_FSGSBASE\tTARGET_ISA_FSGSBASE\n+#define TARGET_FSGSBASE_P(x)\tTARGET_ISA_FSGSBASE_P(x)\n #define TARGET_RDRND\tTARGET_ISA_RDRND\n+#define TARGET_RDRND_P(x)\tTARGET_ISA_RDRND_P(x)\n #define TARGET_F16C\tTARGET_ISA_F16C\n+#define TARGET_F16C_P(x)\tTARGET_ISA_F16C_P(x)\n #define TARGET_RTM      TARGET_ISA_RTM\n+#define TARGET_RTM_P(x)      TARGET_ISA_RTM_P(x)\n #define TARGET_HLE\tTARGET_ISA_HLE\n+#define TARGET_HLE_P(x)\tTARGET_ISA_HLE_P(x)\n #define TARGET_RDSEED\tTARGET_ISA_RDSEED\n+#define TARGET_RDSEED_P(x)\tTARGET_ISA_RDSEED_P(x)\n #define TARGET_PRFCHW\tTARGET_ISA_PRFCHW\n+#define TARGET_PRFCHW_P(x)\tTARGET_ISA_PRFCHW_P(x)\n #define TARGET_ADX\tTARGET_ISA_ADX\n+#define TARGET_ADX_P(x)\tTARGET_ISA_ADX_P(x)\n #define TARGET_FXSR\tTARGET_ISA_FXSR\n+#define TARGET_FXSR_P(x)\tTARGET_ISA_FXSR_P(x)\n #define TARGET_XSAVE\tTARGET_ISA_XSAVE\n+#define TARGET_XSAVE_P(x)\tTARGET_ISA_XSAVE_P(x)\n #define TARGET_XSAVEOPT\tTARGET_ISA_XSAVEOPT\n+#define TARGET_XSAVEOPT_P(x)\tTARGET_ISA_XSAVEOPT_P(x)\n \n #define TARGET_LP64\tTARGET_ABI_64\n+#define TARGET_LP64_P(x)\tTARGET_ABI_64_P(x)\n #define TARGET_X32\tTARGET_ABI_X32\n+#define TARGET_X32_P(x)\tTARGET_ABI_X32_P(x)\n \n /* SSE4.1 defines round instructions */\n #define\tOPTION_MASK_ISA_ROUND\tOPTION_MASK_ISA_SSE4_1\n@@ -212,7 +258,13 @@ extern const struct processor_costs ix86_size_cost;\n   (TARGET_64BIT && TARGET_SSE ? FPMATH_SSE : FPMATH_387)\n #endif\n \n+#ifndef TARGET_FPMATH_DEFAULT_P\n+#define TARGET_FPMATH_DEFAULT_P(x) \\\n+  (TARGET_64BIT_P(x) && TARGET_SSE_P(x) ? FPMATH_SSE : FPMATH_387)\n+#endif\n+\n #define TARGET_FLOAT_RETURNS_IN_80387 TARGET_FLOAT_RETURNS\n+#define TARGET_FLOAT_RETURNS_IN_80387_P(x) TARGET_FLOAT_RETURNS_P(x)\n \n /* 64bit Sledgehammer mode.  For libgcc2 we make sure this is a\n    compile-time constant.  */"}, {"sha": "1e624ab02222ddd8dfe7a4cb645779749f3424a4", "filename": "gcc/config/i386/i386.opt", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf7b5747bb33b0333786dfcc015e0f23136e5f18/gcc%2Fconfig%2Fi386%2Fi386.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf7b5747bb33b0333786dfcc015e0f23136e5f18/gcc%2Fconfig%2Fi386%2Fi386.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.opt?ref=bf7b5747bb33b0333786dfcc015e0f23136e5f18", "patch": "@@ -61,9 +61,13 @@ TargetSave\n HOST_WIDE_INT x_ix86_isa_flags_explicit\n \n ;; which flags were passed by the user\n-TargetSave\n+Variable\n int ix86_target_flags_explicit\n \n+;; which flags were passed by the user\n+TargetSave\n+HOST_WIDE_INT x_ix86_target_flags_explicit\n+\n ;; whether -mtune was not specified\n TargetSave\n unsigned char tune_defaulted"}, {"sha": "f4b65501166a5dea17168a903bedfcf5255d5359", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf7b5747bb33b0333786dfcc015e0f23136e5f18/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf7b5747bb33b0333786dfcc015e0f23136e5f18/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=bf7b5747bb33b0333786dfcc015e0f23136e5f18", "patch": "@@ -3716,7 +3716,7 @@ rs6000_option_override_internal (bool global_init_p)\n   /* Save the initial options in case the user does function specific options */\n   if (global_init_p)\n     target_option_default_node = target_option_current_node\n-      = build_target_option_node ();\n+      = build_target_option_node (&global_options);\n \n   /* If not explicitly specified via option, decide whether to generate the\n      extra blr's required to preserve the link stack on some cpus (eg, 476).  */\n@@ -29751,7 +29751,7 @@ rs6000_valid_attribute_p (tree fndecl,\n {\n   struct cl_target_option cur_target;\n   bool ret;\n-  tree old_optimize = build_optimization_node ();\n+  tree old_optimize = build_optimization_node (&global_options);\n   tree new_target, new_optimize;\n   tree func_optimize = DECL_FUNCTION_SPECIFIC_OPTIMIZATION (fndecl);\n \n@@ -29778,7 +29778,7 @@ rs6000_valid_attribute_p (tree fndecl,\n       fprintf (stderr, \"--------------------\\n\");\n     }\n \n-  old_optimize = build_optimization_node ();\n+  old_optimize = build_optimization_node (&global_options);\n   func_optimize = DECL_FUNCTION_SPECIFIC_OPTIMIZATION (fndecl);\n \n   /* If the function changed the optimization levels as well as setting target\n@@ -29797,12 +29797,12 @@ rs6000_valid_attribute_p (tree fndecl,\n   if (ret)\n     {\n       ret = rs6000_option_override_internal (false);\n-      new_target = build_target_option_node ();\n+      new_target = build_target_option_node (&global_options);\n     }\n   else\n     new_target = NULL;\n \n-  new_optimize = build_optimization_node ();\n+  new_optimize = build_optimization_node (&global_options);\n \n   if (!new_target)\n     ret = false;\n@@ -29832,7 +29832,7 @@ rs6000_valid_attribute_p (tree fndecl,\n bool\n rs6000_pragma_target_parse (tree args, tree pop_target)\n {\n-  tree prev_tree = build_target_option_node ();\n+  tree prev_tree = build_target_option_node (&global_options);\n   tree cur_tree;\n   struct cl_target_option *prev_opt, *cur_opt;\n   HOST_WIDE_INT prev_flags, cur_flags, diff_flags;\n@@ -29869,7 +29869,8 @@ rs6000_pragma_target_parse (tree args, tree pop_target)\n       rs6000_cpu_index = rs6000_tune_index = -1;\n       if (!rs6000_inner_target_options (args, false)\n \t  || !rs6000_option_override_internal (false)\n-\t  || (cur_tree = build_target_option_node ()) == NULL_TREE)\n+\t  || (cur_tree = build_target_option_node (&global_options))\n+\t     == NULL_TREE)\n \t{\n \t  if (TARGET_DEBUG_BUILTIN || TARGET_DEBUG_TARGET)\n \t    fprintf (stderr, \"invalid pragma\\n\");"}, {"sha": "f96764dbb66d159c0c6151f8f8175a81735a5c58", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf7b5747bb33b0333786dfcc015e0f23136e5f18/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf7b5747bb33b0333786dfcc015e0f23136e5f18/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=bf7b5747bb33b0333786dfcc015e0f23136e5f18", "patch": "@@ -9853,17 +9853,17 @@ the function declaration to hold a pointer to a target-specific\n @code{struct cl_target_option} structure.\n @end deftypefn\n \n-@deftypefn {Target Hook} void TARGET_OPTION_SAVE (struct cl_target_option *@var{ptr})\n+@deftypefn {Target Hook} void TARGET_OPTION_SAVE (struct cl_target_option *@var{ptr}, struct gcc_options *@var{opts})\n This hook is called to save any additional target-specific information\n in the @code{struct cl_target_option} structure for function-specific\n-options.\n+options from the @code{struct gcc_options} structure.\n @xref{Option file format}.\n @end deftypefn\n \n-@deftypefn {Target Hook} void TARGET_OPTION_RESTORE (struct cl_target_option *@var{ptr})\n+@deftypefn {Target Hook} void TARGET_OPTION_RESTORE (struct gcc_options *@var{opts}, struct cl_target_option *@var{ptr})\n This hook is called to restore any additional target-specific\n information in the @code{struct cl_target_option} structure for\n-function-specific options.\n+function-specific options to the @code{struct gcc_options} structure.\n @end deftypefn\n \n @deftypefn {Target Hook} void TARGET_OPTION_PRINT (FILE *@var{file}, int @var{indent}, struct cl_target_option *@var{ptr})"}, {"sha": "b822a0b11581b853c0b5c6547093b699d9a953f9", "filename": "gcc/optc-save-gen.awk", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf7b5747bb33b0333786dfcc015e0f23136e5f18/gcc%2Foptc-save-gen.awk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf7b5747bb33b0333786dfcc015e0f23136e5f18/gcc%2Foptc-save-gen.awk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptc-save-gen.awk?ref=bf7b5747bb33b0333786dfcc015e0f23136e5f18", "patch": "@@ -284,7 +284,7 @@ if (have_assert)\n \tprint \"\";\n \n print \"  if (targetm.target_option.save)\";\n-print \"    targetm.target_option.save (ptr);\";\n+print \"    targetm.target_option.save (ptr, opts);\";\n print \"\";\n \n for (i = 0; i < n_extra_target_vars; i++) {\n@@ -347,7 +347,7 @@ for (i = 0; i < n_target_char; i++) {\n # variables.\n print \"\";\n print \"  if (targetm.target_option.restore)\";\n-print \"    targetm.target_option.restore (ptr);\";\n+print \"    targetm.target_option.restore (opts, ptr);\";\n \n print \"}\";\n "}, {"sha": "01c5ab65f410c38970dc4b0efec215015bcdbde6", "filename": "gcc/opth-gen.awk", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf7b5747bb33b0333786dfcc015e0f23136e5f18/gcc%2Fopth-gen.awk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf7b5747bb33b0333786dfcc015e0f23136e5f18/gcc%2Fopth-gen.awk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopth-gen.awk?ref=bf7b5747bb33b0333786dfcc015e0f23136e5f18", "patch": "@@ -114,7 +114,6 @@ print \"};\"\n print \"extern struct gcc_options global_options;\"\n print \"extern const struct gcc_options global_options_init;\"\n print \"extern struct gcc_options global_options_set;\"\n-print \"#define target_flags_explicit global_options_set.x_target_flags\"\n print \"#endif\"\n print \"#endif\"\n print \"\"\n@@ -382,6 +381,8 @@ for (i = 0; i < n_opts; i++) {\n \t\t}\n \t\tprint \"#define TARGET_\" name \\\n \t\t      \" ((\" vname \" & \" mask name \") != 0)\"\n+\t\tprint \"#define TARGET_\" name \"_P(\" vname \")\" \\\n+\t\t      \" ((\" vname \" & \" mask name \") != 0)\"\n \t}\n }\n for (i = 0; i < n_extra_masks; i++) {"}, {"sha": "728d36d9fff751439470796129aa7151574c1423", "filename": "gcc/opts.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf7b5747bb33b0333786dfcc015e0f23136e5f18/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf7b5747bb33b0333786dfcc015e0f23136e5f18/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=bf7b5747bb33b0333786dfcc015e0f23136e5f18", "patch": "@@ -279,10 +279,15 @@ init_options_struct (struct gcc_options *opts, struct gcc_options *opts_set)\n   gcc_obstack_init (&opts_obstack);\n \n   *opts = global_options_init;\n-  memset (opts_set, 0, sizeof (*opts_set));\n+\n+  if (opts_set)\n+    memset (opts_set, 0, sizeof (*opts_set));\n \n   opts->x_param_values = XNEWVEC (int, num_params);\n-  opts_set->x_param_values = XCNEWVEC (int, num_params);\n+\n+  if (opts_set)\n+    opts_set->x_param_values = XCNEWVEC (int, num_params);\n+\n   init_param_values (opts->x_param_values);\n \n   /* Initialize whether `char' is signed.  */"}, {"sha": "912632f04f6469a745c95d5d5fa0ebfa25244b36", "filename": "gcc/target.def", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf7b5747bb33b0333786dfcc015e0f23136e5f18/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf7b5747bb33b0333786dfcc015e0f23136e5f18/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=bf7b5747bb33b0333786dfcc015e0f23136e5f18", "patch": "@@ -4964,18 +4964,18 @@ DEFHOOK\n (save,\n  \"This hook is called to save any additional target-specific information\\n\\\n in the @code{struct cl_target_option} structure for function-specific\\n\\\n-options.\\n\\\n+options from the @code{struct gcc_options} structure.\\n\\\n @xref{Option file format}.\",\n- void, (struct cl_target_option *ptr), NULL)\n+ void, (struct cl_target_option *ptr, struct gcc_options *opts), NULL)\n \n /* Function to restore any extra target state from the target options\n    structure.  */\n DEFHOOK\n (restore,\n  \"This hook is called to restore any additional target-specific\\n\\\n information in the @code{struct cl_target_option} structure for\\n\\\n-function-specific options.\",\n- void, (struct cl_target_option *ptr), NULL)\n+function-specific options to the @code{struct gcc_options} structure.\",\n+ void, (struct gcc_options *opts, struct cl_target_option *ptr), NULL)\n \n /* Function to print any extra target state from the target options\n    structure.  */"}, {"sha": "8098aa3bb35d9f3da710d6e76af531ef1124f5a4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf7b5747bb33b0333786dfcc015e0f23136e5f18/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf7b5747bb33b0333786dfcc015e0f23136e5f18/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bf7b5747bb33b0333786dfcc015e0f23136e5f18", "patch": "@@ -1,3 +1,9 @@\n+2013-10-15 Sriraman Tallam  <tmsriram@google.com>\n+\n+\tPR target/57756\n+\t* gcc.target/i386/pr57756.c: New test.\n+\t* gcc.target/i386/pr57756_2.c: New test.\n+\n 2013-10-15  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* gcc.dg/torture/builtin-self.c: New file."}, {"sha": "81d53bfd565d6d20e93aae8681d6f1841e8feed0", "filename": "gcc/testsuite/gcc.target/i386/pr57756.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf7b5747bb33b0333786dfcc015e0f23136e5f18/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr57756.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf7b5747bb33b0333786dfcc015e0f23136e5f18/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr57756.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr57756.c?ref=bf7b5747bb33b0333786dfcc015e0f23136e5f18", "patch": "@@ -0,0 +1,22 @@\n+/* callee cannot be inlined into caller because it has a higher\n+   target ISA.  */\n+/* { dg-do compile } */\n+\n+__attribute__((always_inline,target(\"sse4.2\")))\n+__inline int callee () /* { dg-error \"inlining failed in call to always_inline\" }  */\n+{\n+  return 0;\n+}\n+\n+__attribute__((target(\"sse\")))\n+__inline int caller ()\n+{\n+  return callee(); /* { dg-error \"called from here\" }  */\n+}\n+\n+int main ()\n+{\n+  return caller();\n+}\n+/* callee cannot be inlined into caller because it has a higher\n+   target ISA.  */"}, {"sha": "0227d8ff402da273071d7f4479e4f11982daa591", "filename": "gcc/testsuite/gcc.target/i386/pr57756_2.c", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf7b5747bb33b0333786dfcc015e0f23136e5f18/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr57756_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf7b5747bb33b0333786dfcc015e0f23136e5f18/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr57756_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr57756_2.c?ref=bf7b5747bb33b0333786dfcc015e0f23136e5f18", "patch": "@@ -0,0 +1,132 @@\n+/* { dg-do run } */\n+/* { dg-options \"-mno-sse2 -mno-popcnt -mno-avx\" } */\n+\n+\n+__attribute__((always_inline,target(\"avx2\")))\n+__inline int c1 ()\n+{\n+  return 0;\n+}\n+\n+__attribute__((always_inline,target(\"avx\")))\n+__inline int c2 ()\n+{\n+  return 0;\n+}\n+\n+__attribute__((always_inline,target(\"popcnt\")))\n+__inline int c3 ()\n+{\n+  return 0;\n+}\n+\n+__attribute__((always_inline,target(\"sse4.2\")))\n+__inline int c4 ()\n+{\n+  return 0;\n+}\n+\n+__attribute__((always_inline,target(\"sse4.1\")))\n+__inline int c5 ()\n+{\n+  return 0;\n+}\n+\n+__attribute__((always_inline,target(\"ssse3\")))\n+__inline int c6 ()\n+{\n+  return 0;\n+}\n+\n+__attribute__((always_inline,target(\"sse3\")))\n+__inline int c7 ()\n+{\n+  return 0;\n+}\n+\n+__attribute__((always_inline,target(\"sse2\")))\n+__inline int c8 ()\n+{\n+  return 0;\n+}\n+\n+int nop ()\n+{\n+  return 1;\n+}\n+\n+#pragma GCC push_options\n+#pragma GCC target(\"sse2\")\n+int C8 ()\n+{\n+  return c8 ();\n+}\n+#pragma GCC pop_options\n+\n+\n+#pragma GCC push_options\n+#pragma GCC target(\"sse3\")\n+int C7 ()\n+{\n+  return c7 ();\n+}\n+#pragma GCC pop_options\n+\n+\n+#pragma GCC push_options\n+#pragma GCC target(\"ssse3\")\n+int C6 ()\n+{\n+  return c6 ();\n+}\n+#pragma GCC pop_options\n+\n+\n+#pragma GCC push_options\n+#pragma GCC target(\"sse4.1\")\n+int C5 ()\n+{\n+  return c5 ();\n+}\n+#pragma GCC pop_options\n+\n+\n+#pragma GCC push_options\n+#pragma GCC target(\"sse4.2\")\n+int C4 ()\n+{\n+  return c4 ();\n+}\n+#pragma GCC pop_options\n+\n+\n+#pragma GCC push_options\n+#pragma GCC target(\"popcnt\")\n+int C3 ()\n+{\n+  return c3 ();\n+}\n+#pragma GCC pop_options\n+\n+\n+#pragma GCC push_options\n+#pragma GCC target(\"avx\")\n+int C2 ()\n+{\n+  return c2 ();\n+}\n+#pragma GCC pop_options\n+\n+\n+#pragma GCC push_options\n+#pragma GCC target(\"avx2\")\n+int C1 ()\n+{\n+  return c1 ();\n+}\n+#pragma GCC pop_options\n+\n+int main ()\n+{\n+  return C1 () + C2 () + C3 () + C4 () + C5 () + C6 () + C7 () + C8 ();\n+}"}, {"sha": "cc8e905cd1f4b336223e825598402494bb3df8a1", "filename": "gcc/toplev.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf7b5747bb33b0333786dfcc015e0f23136e5f18/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf7b5747bb33b0333786dfcc015e0f23136e5f18/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=bf7b5747bb33b0333786dfcc015e0f23136e5f18", "patch": "@@ -1575,7 +1575,7 @@ process_options (void)\n                                     DK_ERROR, UNKNOWN_LOCATION);\n \n   /* Save the current optimization options.  */\n-  optimization_default_node = build_optimization_node ();\n+  optimization_default_node = build_optimization_node (&global_options);\n   optimization_current_node = optimization_default_node;\n }\n "}, {"sha": "8b7490dcd9889f0f7842e56ea255ce9fd5ca1da6", "filename": "gcc/tree.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf7b5747bb33b0333786dfcc015e0f23136e5f18/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf7b5747bb33b0333786dfcc015e0f23136e5f18/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=bf7b5747bb33b0333786dfcc015e0f23136e5f18", "patch": "@@ -11598,18 +11598,18 @@ cl_option_hash_eq (const void *x, const void *y)\n   return (memcmp (xp, yp, len) == 0);\n }\n \n-/* Build an OPTIMIZATION_NODE based on the current options.  */\n+/* Build an OPTIMIZATION_NODE based on the options in OPTS.  */\n \n tree\n-build_optimization_node (void)\n+build_optimization_node (struct gcc_options *opts)\n {\n   tree t;\n   void **slot;\n \n   /* Use the cache of optimization nodes.  */\n \n   cl_optimization_save (TREE_OPTIMIZATION (cl_optimization_node),\n-\t\t\t&global_options);\n+\t\t\topts);\n \n   slot = htab_find_slot (cl_option_hash_table, cl_optimization_node, INSERT);\n   t = (tree) *slot;\n@@ -11626,18 +11626,18 @@ build_optimization_node (void)\n   return t;\n }\n \n-/* Build a TARGET_OPTION_NODE based on the current options.  */\n+/* Build a TARGET_OPTION_NODE based on the options in OPTS.  */\n \n tree\n-build_target_option_node (void)\n+build_target_option_node (struct gcc_options *opts)\n {\n   tree t;\n   void **slot;\n \n   /* Use the cache of optimization nodes.  */\n \n   cl_target_option_save (TREE_TARGET_OPTION (cl_target_option_node),\n-\t\t\t &global_options);\n+\t\t\t opts);\n \n   slot = htab_find_slot (cl_option_hash_table, cl_target_option_node, INSERT);\n   t = (tree) *slot;"}, {"sha": "6cae818af793fc54a44a6ccd9c66e0946d6b34de", "filename": "gcc/tree.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf7b5747bb33b0333786dfcc015e0f23136e5f18/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf7b5747bb33b0333786dfcc015e0f23136e5f18/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=bf7b5747bb33b0333786dfcc015e0f23136e5f18", "patch": "@@ -2654,16 +2654,16 @@ extern vec<tree, va_gc> **decl_debug_args_insert (tree);\n #define TREE_OPTIMIZATION_BASE_OPTABS(NODE) \\\n   (OPTIMIZATION_NODE_CHECK (NODE)->optimization.base_optabs)\n \n-/* Return a tree node that encapsulates the current optimization options.  */\n-extern tree build_optimization_node (void);\n+/* Return a tree node that encapsulates the optimization options in OPTS.  */\n+extern tree build_optimization_node (struct gcc_options *opts);\n \n extern void init_tree_optimization_optabs (tree);\n \n #define TREE_TARGET_OPTION(NODE) \\\n   (&TARGET_OPTION_NODE_CHECK (NODE)->target_option.opts)\n \n-/* Return a tree node that encapsulates the current target options.  */\n-extern tree build_target_option_node (void);\n+/* Return a tree node that encapsulates the target options in OPTS.  */\n+extern tree build_target_option_node (struct gcc_options *opts);\n \n #if defined ENABLE_TREE_CHECKING && (GCC_VERSION >= 2007)\n "}]}