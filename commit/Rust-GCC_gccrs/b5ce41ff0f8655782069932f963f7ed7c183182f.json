{"sha": "b5ce41ff0f8655782069932f963f7ed7c183182f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjVjZTQxZmYwZjg2NTU3ODIwNjk5MzJmOTYzZjdlZDdjMTgzMTgyZg==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1999-03-10T21:29:44Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-03-10T21:29:44Z"}, "message": "gcse.c: More comments, whitespace and similar fixes.\n\n        * gcse.c: More comments, whitespace and similar fixes.\n        (dump_cuid_table, maybe_set_rd_gen, dump_cprop_data): Delete.\n        (dump_pre_data, compute_cprop_local_properties): Likewise.\n        (one_classic_gcse_pass): Lose unused argument.  All callers changed.\n        (compute_hash_table, compute_expr_hash_table): Likewise.\n        (compute_set_hash_table, one_pre_gcse_pass, mark_call): Likewise.\n        (cprop_insn, cprop, one_cprop_pass): Add new argument ALTER_JUMPS.\n        All callers changed.  Only alter jumps if ALTER_JUMPS is nonzero.\n        Lose unused argument.\n        (gcse_main): Always run a cprop pass after finishing global cse.\n        (compute_local_properties): New function.\n        (hash_scan_pat, hash_scan_insn): No longer call maybe_set_rd_gen.\n        (compute_cprop_data): Use compute_local_properties.\n\nFrom-SVN: r25677", "tree": {"sha": "05aac004bf319741fe1e9e8533b242c9c4bf14b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/05aac004bf319741fe1e9e8533b242c9c4bf14b9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b5ce41ff0f8655782069932f963f7ed7c183182f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5ce41ff0f8655782069932f963f7ed7c183182f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5ce41ff0f8655782069932f963f7ed7c183182f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5ce41ff0f8655782069932f963f7ed7c183182f/comments", "author": null, "committer": null, "parents": [{"sha": "878f32c33e0bdaa914c395f54c24c930d3c88911", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/878f32c33e0bdaa914c395f54c24c930d3c88911", "html_url": "https://github.com/Rust-GCC/gccrs/commit/878f32c33e0bdaa914c395f54c24c930d3c88911"}], "stats": {"total": 481, "additions": 215, "deletions": 266}, "files": [{"sha": "bd42221a3e21b97a2a32bf2fb101b35ddbd3b0bb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ce41ff0f8655782069932f963f7ed7c183182f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ce41ff0f8655782069932f963f7ed7c183182f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b5ce41ff0f8655782069932f963f7ed7c183182f", "patch": "@@ -22,6 +22,20 @@ Wed Mar 10 23:11:19 1999  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n Wed Mar 10 20:28:29 1999  Jeffrey A Law  (law@cygnus.com)\n \n+\t* gcse.c: More comments, whitespace and similar fixes.\n+\t(dump_cuid_table, maybe_set_rd_gen, dump_cprop_data): Delete.\n+\t(dump_pre_data, compute_cprop_local_properties): Likewise.\n+\t(one_classic_gcse_pass): Lose unused argument.  All callers changed.\n+\t(compute_hash_table, compute_expr_hash_table): Likewise.\n+\t(compute_set_hash_table, one_pre_gcse_pass, mark_call): Likewise.\n+\t(cprop_insn, cprop, one_cprop_pass): Add new argument ALTER_JUMPS.\n+\tAll callers changed.  Only alter jumps if ALTER_JUMPS is nonzero.\n+\tLose unused argument.\n+\t(gcse_main): Always run a cprop pass after finishing global cse.\n+\t(compute_local_properties): New function.\n+\t(hash_scan_pat, hash_scan_insn): No longer call maybe_set_rd_gen.\n+\t(compute_cprop_data): Use compute_local_properties.\n+\n \t* gcse.c: Update various comments.\n \t(current_function_calls_longjmp): Delete declaration.\n "}, {"sha": "ede35b4ca1ca8db9cffeff85c6b4684969577409", "filename": "gcc/gcse.c", "status": "modified", "additions": 201, "deletions": 266, "changes": 467, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ce41ff0f8655782069932f963f7ed7c183182f/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ce41ff0f8655782069932f963f7ed7c183182f/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=b5ce41ff0f8655782069932f963f7ed7c183182f", "patch": "@@ -509,6 +509,7 @@ static sbitmap *rd_kill, *rd_gen, *reaching_defs, *rd_out;\n \n /* for available exprs */\n static sbitmap *ae_kill, *ae_gen, *ae_in, *ae_out;\n+\n \f\n static void compute_can_copy\t  PROTO ((void));\n \n@@ -517,8 +518,6 @@ static char *grealloc\t\t PROTO ((char *, unsigned int));\n static char *gcse_alloc\t       PROTO ((unsigned long));\n static void alloc_gcse_mem\t    PROTO ((rtx));\n static void free_gcse_mem\t     PROTO ((void));\n-extern void dump_cuid_table\t   PROTO ((FILE *));\n-\n static void alloc_reg_set_mem\t PROTO ((int));\n static void free_reg_set_mem\t  PROTO ((void));\n static void record_one_set\t    PROTO ((int, rtx));\n@@ -529,78 +528,55 @@ static void hash_scan_insn\t    PROTO ((rtx, int, int));\n static void hash_scan_set\t     PROTO ((rtx, rtx, int));\n static void hash_scan_clobber\t PROTO ((rtx, rtx));\n static void hash_scan_call\t    PROTO ((rtx, rtx));\n-static void maybe_set_rd_gen\t  PROTO ((int, rtx));\n static int want_to_gcse_p\t     PROTO ((rtx));\n static int oprs_unchanged_p\t   PROTO ((rtx, rtx, int));\n static int oprs_anticipatable_p       PROTO ((rtx, rtx));\n static int oprs_available_p\t   PROTO ((rtx, rtx));\n-static void insert_expr_in_table      PROTO ((rtx, enum machine_mode, rtx, int, int));\n+static void insert_expr_in_table      PROTO ((rtx, enum machine_mode,\n+\t\t\t\t\t      rtx, int, int));\n static void insert_set_in_table       PROTO ((rtx, rtx));\n-static unsigned int hash_expr\t PROTO ((rtx, enum machine_mode, int *, int));\n+static unsigned int hash_expr\t PROTO ((rtx, enum machine_mode,\n+\t\t\t\t\t int *, int));\n static unsigned int hash_expr_1       PROTO ((rtx, enum machine_mode, int *));\n static unsigned int hash_set\t  PROTO ((int, int));\n static int expr_equiv_p\t       PROTO ((rtx, rtx));\n static void record_last_reg_set_info  PROTO ((rtx, int));\n static void record_last_mem_set_info  PROTO ((rtx));\n static void record_last_set_info      PROTO ((rtx, rtx));\n-static void compute_hash_table\tPROTO ((rtx, int));\n+static void compute_hash_table\tPROTO ((int));\n static void alloc_set_hash_table      PROTO ((int));\n static void free_set_hash_table       PROTO ((void));\n-static void compute_set_hash_table    PROTO ((rtx));\n+static void compute_set_hash_table    PROTO ((void));\n static void alloc_expr_hash_table     PROTO ((int));\n static void free_expr_hash_table      PROTO ((void));\n-static void compute_expr_hash_table   PROTO ((rtx));\n+static void compute_expr_hash_table   PROTO ((void));\n static void dump_hash_table\t   PROTO ((FILE *, const char *, struct expr **, int, int));\n static struct expr *lookup_expr       PROTO ((rtx));\n static struct expr *lookup_set\tPROTO ((int, rtx));\n static struct expr *next_set\t  PROTO ((int, struct expr *));\n static void reset_opr_set_tables      PROTO ((void));\n static int oprs_not_set_p\t     PROTO ((rtx, rtx));\n-static void mark_call\t\t PROTO ((rtx, rtx));\n+static void mark_call\t\t PROTO ((rtx));\n static void mark_set\t\t  PROTO ((rtx, rtx));\n static void mark_clobber\t      PROTO ((rtx, rtx));\n static void mark_oprs_set\t     PROTO ((rtx));\n \n-static void alloc_rd_mem\t      PROTO ((int, int));\n-static void free_rd_mem\t       PROTO ((void));\n-static void compute_kill_rd\t   PROTO ((void));\n-static void handle_rd_kill_set\tPROTO ((rtx, int, int));\n-static void compute_rd\t\tPROTO ((void));\n-extern void dump_rd_table\t     PROTO ((FILE *, char *, sbitmap *));\n-\n-static void alloc_avail_expr_mem      PROTO ((int, int));\n-static void free_avail_expr_mem       PROTO ((void));\n-static void compute_ae_gen\t    PROTO ((void));\n-static void compute_ae_kill\t   PROTO ((void));\n-static int expr_killed_p\t      PROTO ((rtx, int));\n-static void compute_available\t PROTO ((void));\n-\n-static int expr_reaches_here_p\tPROTO ((struct occr *, struct expr *,\n-\t\t\t\t\t      int, int, char *));\n-static rtx computing_insn\t     PROTO ((struct expr *, rtx));\n-static int def_reaches_here_p\t PROTO ((rtx, rtx));\n-static int can_disregard_other_sets   PROTO ((struct reg_set **, rtx, int));\n-static int handle_avail_expr\t  PROTO ((rtx, struct expr *));\n-static int classic_gcse\t       PROTO ((void));\n-static int one_classic_gcse_pass      PROTO ((rtx, int));\n-\n static void alloc_cprop_mem\t   PROTO ((int, int));\n static void free_cprop_mem\t    PROTO ((void));\n-extern void dump_cprop_data\t   PROTO ((FILE *));\n static void compute_transp\t    PROTO ((rtx, int, sbitmap *, int));\n-static void compute_cprop_local_properties PROTO ((void));\n+static void compute_local_properties  PROTO ((sbitmap *, sbitmap *,\n+\t\t\t\t\t      sbitmap *, int));\n static void compute_cprop_avinout     PROTO ((void));\n static void compute_cprop_data\tPROTO ((void));\n static void find_used_regs\t    PROTO ((rtx));\n static int try_replace_reg\t    PROTO ((rtx, rtx, rtx));\n static struct expr *find_avail_set    PROTO ((int, rtx));\n-static int cprop_insn\t\t PROTO ((rtx));\n-static int cprop\t\t      PROTO ((void));\n-static int one_cprop_pass\t     PROTO ((rtx, int));\n+static int cprop_insn\t\t PROTO ((rtx, int));\n+static int cprop\t\t      PROTO ((int));\n+static int one_cprop_pass\t     PROTO ((int, int));\n \n static void alloc_pre_mem\t     PROTO ((int, int));\n static void free_pre_mem\t      PROTO ((void));\n-extern void dump_pre_data\t     PROTO ((FILE *));\n static void compute_pre_local_properties PROTO ((void));\n static void compute_pre_avinout       PROTO ((void));\n static void compute_pre_antinout      PROTO ((void));\n@@ -615,9 +591,30 @@ static void pre_insert_copy_insn      PROTO ((struct expr *, rtx));\n static void pre_insert_copies\t PROTO ((void));\n static int pre_delete\t\t PROTO ((void));\n static int pre_gcse\t\t   PROTO ((void));\n-static int one_pre_gcse_pass\t  PROTO ((rtx, int));\n+static int one_pre_gcse_pass\t  PROTO ((int));\n \n static void add_label_notes\t      PROTO ((rtx, rtx));\n+\n+static void alloc_rd_mem\t      PROTO ((int, int));\n+static void free_rd_mem\t       PROTO ((void));\n+static void handle_rd_kill_set\tPROTO ((rtx, int, int));\n+static void compute_kill_rd\t   PROTO ((void));\n+static void compute_rd\t\tPROTO ((void));\n+static void alloc_avail_expr_mem      PROTO ((int, int));\n+static void free_avail_expr_mem       PROTO ((void));\n+static void compute_ae_gen\t    PROTO ((void));\n+static int expr_killed_p\t      PROTO ((rtx, int));\n+static void compute_ae_kill\t   PROTO ((void));\n+static void compute_available\t PROTO ((void));\n+static int expr_reaches_here_p\tPROTO ((struct occr *, struct expr *,\n+\t\t\t\t\t      int, int, char *));\n+static rtx computing_insn\t     PROTO ((struct expr *, rtx));\n+static int def_reaches_here_p\t PROTO ((rtx, rtx));\n+static int can_disregard_other_sets   PROTO ((struct reg_set **, rtx, int));\n+static int handle_avail_expr\t  PROTO ((rtx, struct expr *));\n+static int classic_gcse\t       PROTO ((void));\n+static int one_classic_gcse_pass      PROTO ((int));\n+\n \f\n /* Entry point for global common subexpression elimination.\n    F is the first instruction in the function.  */\n@@ -635,16 +632,20 @@ gcse_main (f, file)\n   /* Point to release obstack data from for each pass.  */\n   char *gcse_obstack_bottom;\n \n-  run_jump_opt_after_gcse = 0;\n-\n-  /* It's impossible to construct a correct control flow graph in the\n-     presense of setjmp, so just punt to be safe.  */\n+  /* We do not construct an accurate cfg in functions which call\n+     setjmp, so just punt to be safe.  */\n   if (current_function_calls_setjmp)\n     return 0;\n    \n+  /* Assume that we do not need to run jump optimizations after gcse.  */\n+  run_jump_opt_after_gcse = 0;\n+\n   /* For calling dump_foo fns from gdb.  */\n   debug_stderr = stderr;\n+  gcse_file = file;\n \n+  /* Identify the basic block information for this function, including\n+     successors and predecessors.  */\n   max_gcse_regno = max_reg_num ();\n   find_basic_blocks (f, max_gcse_regno, file);\n \n@@ -665,8 +666,6 @@ gcse_main (f, file)\n \n   gcc_obstack_init (&gcse_obstack);\n \n-  gcse_file = file;\n-\n   /* Allocate and compute predecessors/successors.  */\n \n   s_preds = (int_list_ptr *) alloca (n_basic_blocks * sizeof (int_list_ptr));\n@@ -681,9 +680,13 @@ gcse_main (f, file)\n \n   /* Record where pseudo-registers are set.\n      This data is kept accurate during each pass.\n-     ??? We could also record hard-reg and memory information here\n+     ??? We could also record hard-reg information here\n      [since it's unchanging], however it is currently done during\n-     hash table computation.  */\n+     hash table computation.\n+\n+     It may be tempting to compute MEM set information here too, but MEM\n+     sets will be subject to code motion one day and thus we need to compute\n+     information about memory sets when we build the hash tables.  */\n \n   alloc_reg_set_mem (max_gcse_regno);\n   compute_sets (f);\n@@ -708,12 +711,14 @@ gcse_main (f, file)\n \n       alloc_gcse_mem (f);\n \n-      changed = one_cprop_pass (f, pass + 1);\n+      /* Don't allow constant propagation to modify jumps\n+\t during this pass.  */\n+      changed = one_cprop_pass (pass + 1, 0);\n \n       if (optimize_size)\n-\tchanged |= one_classic_gcse_pass (f, pass + 1);\n+\tchanged |= one_classic_gcse_pass (pass + 1);\n       else\n-\tchanged |= one_pre_gcse_pass (f, pass + 1);\n+\tchanged |= one_pre_gcse_pass (pass + 1);\n \n       if (max_pass_bytes < bytes_used)\n \tmax_pass_bytes = bytes_used;\n@@ -729,14 +734,14 @@ gcse_main (f, file)\n       pass++;\n     }\n \n-  /* If we're doing PRE, do one last pass of copy propagation.  */\n-  if (! optimize_size)\n-    {\n-      max_gcse_regno = max_reg_num ();\n-      alloc_gcse_mem (f);\n-      one_cprop_pass (f, pass + 1);\n-      free_gcse_mem ();\n-    }\n+  /* Do one last pass of copy propagation, including cprop into\n+     conditional jumps.  */\n+\n+  max_gcse_regno = max_reg_num ();\n+  alloc_gcse_mem (f);\n+  /* This time, go ahead and allow cprop to alter jumps.  */\n+  one_cprop_pass (pass + 1, 1);\n+  free_gcse_mem ();\n \n   if (file)\n     {\n@@ -899,23 +904,113 @@ free_gcse_mem ()\n   free (mem_set_in_block);\n }\n \n-void\n-dump_cuid_table (file)\n-     FILE *file;\n-{\n-  int i;\n+\f\n+/* Compute the local properties of each recorded expression.\n+   Local properties are those that are defined by the block, irrespective\n+   of other blocks.\n+\n+   An expression is transparent in a block if its operands are not modified\n+   in the block.\n+\n+   An expression is computed (locally available) in a block if it is computed\n+   at least once and expression would contain the same value if the\n+   computation was moved to the end of the block.\n+\n+   An expression is locally anticipatable in a block if it is computed at\n+   least once and expression would contain the same value if the computation\n+   was moved to the beginning of the block.\n+\n+   We call this routine for cprop, pre and code hoisting.  They all\n+   compute basically the same information and thus can easily share\n+   this code.\n \n-  fprintf (file, \"CUID table\\n\");\n-  for (i = 0; i < max_cuid; i++)\n+   TRANSP, COMP, and ANTLOC are destination sbitmaps for recording\n+   local properties.  If NULL, then it is not necessary to compute\n+   or record that particular property.\n+\n+   SETP controls which hash table to look at.  If zero, this routine\n+   looks at the expr hash table; if nonzero this routine looks at\n+   the set hash table.  */\n+ \n+static void\n+compute_local_properties (transp, comp, antloc, setp)\n+     sbitmap *transp;\n+     sbitmap *comp;\n+     sbitmap *antloc;\n+     int setp;\n+{\n+  int i, hash_table_size;\n+  struct expr **hash_table;\n+  \n+  /* Initialize any bitmaps that were passed in.  */\n+  if (transp)\n+    sbitmap_vector_ones (transp, n_basic_blocks);\n+  if (comp)\n+    sbitmap_vector_zero (comp, n_basic_blocks);\n+  if (antloc)\n+    sbitmap_vector_zero (antloc, n_basic_blocks);\n+\n+  /* We use the same code for cprop, pre and hoisting.  For cprop\n+     we care about the set hash table, for pre and hoisting we\n+     care about the expr hash table.  */\n+  hash_table_size = setp ? set_hash_table_size : expr_hash_table_size;\n+  hash_table = setp ? set_hash_table : expr_hash_table;\n+\n+  for (i = 0; i < hash_table_size; i++)\n     {\n-      rtx insn = CUID_INSN (i);\n-      if (i != 0 && i % 10 == 0)\n-\tfprintf (file, \"\\n\");\n-      if (insn != NULL)\n-\tfprintf (file, \" %d\", INSN_UID (insn));\n+      struct expr *expr;\n+\n+      for (expr = hash_table[i]; expr != NULL; expr = expr->next_same_hash)\n+\t{\n+\t  struct occr *occr;\n+\t  int indx = expr->bitmap_index;\n+\n+\t  /* The expression is transparent in this block if it is not killed.\n+\t     We start by assuming all are transparent [none are killed], and\n+\t     then reset the bits for those that are.  */\n+\n+\t  if (transp)\n+\t    compute_transp (expr->expr, indx, transp, setp);\n+\n+\t  /* The occurrences recorded in antic_occr are exactly those that\n+\t     we want to set to non-zero in ANTLOC.  */\n+\n+\t  if (antloc)\n+\t    {\n+\t      for (occr = expr->antic_occr; occr != NULL; occr = occr->next)\n+\t\t{\n+\t\t  int bb = BLOCK_NUM (occr->insn);\n+\t\t  SET_BIT (antloc[bb], indx);\n+\n+\t\t  /* While we're scanning the table, this is a good place to\n+\t\t     initialize this.  */\n+\t\t  occr->deleted_p = 0;\n+\t\t}\n+\t    }\n+\n+\t  /* The occurrences recorded in avail_occr are exactly those that\n+\t     we want to set to non-zero in COMP.  */\n+\t  if (comp)\n+\t    {\n+\t\n+\t      for (occr = expr->avail_occr; occr != NULL; occr = occr->next)\n+\t\t{\n+\t\t  int bb = BLOCK_NUM (occr->insn);\n+\t\t  SET_BIT (comp[bb], indx);\n+\n+\t\t  /* While we're scanning the table, this is a good place to\n+\t\t     initialize this.  */\n+\t\t  occr->copied_p = 0;\n+\t\t}\n+\t    }\n+\n+\t  /* While we're scanning the table, this is a good place to\n+\t     initialize this.  */\n+\t  expr->reaching_reg = 0;\n+\t}\n     }\n-  fprintf (file, \"\\n\\n\");\n }\n+\n \f\n /* Register set information.\n \n@@ -1047,18 +1142,6 @@ static int *reg_last_set;\n static int mem_first_set;\n static int mem_last_set;\n \n-/* Set the appropriate bit in `rd_gen' [the gen for reaching defs] if the\n-   register set in this insn is not set after this insn in this block.  */\n-\n-static void\n-maybe_set_rd_gen (regno, insn)\n-     int regno;\n-     rtx insn;\n-{\n-  if (reg_last_set[regno] <= INSN_CUID (insn))\n-    SET_BIT (rd_gen[BLOCK_NUM (insn)], INSN_CUID (insn));\n-}\n-\n /* Perform a quick check whether X, the source of a set, is something\n    we want to consider for GCSE.  */\n \n@@ -1787,22 +1870,6 @@ hash_scan_set (pat, insn, set_p)\n \t\t       && oprs_available_p (pat, tmp))))\n \tinsert_set_in_table (pat, insn);\n     }\n-\n-  /* Check if first/last set in this block for classic gcse,\n-     but not for copy/constant propagation.  */\n-  if (optimize_size && !set_p)\n-      \n-    {\n-      rtx dest = SET_DEST (pat);\n-\n-      while (GET_CODE (dest) == SUBREG\n-\t     || GET_CODE (dest) == ZERO_EXTRACT\n-\t     || GET_CODE (dest) == SIGN_EXTRACT\n-\t     || GET_CODE (dest) == STRICT_LOW_PART)\n-\tdest = XEXP (dest, 0);\n-      if (GET_CODE (dest) == REG)\n-\tmaybe_set_rd_gen (REGNO (dest), insn);\n-    }\n }\n \n static void\n@@ -1857,21 +1924,6 @@ hash_scan_insn (insn, set_p, in_libcall_block)\n \t    {\n \t      if (GET_CODE (SET_SRC (x)) == CALL)\n \t\thash_scan_call (SET_SRC (x), insn);\n-\n-\t      /* Check if first/last set in this block for classic\n-\t\t gcse, but not for constant/copy propagation.  */\n-\t      if (optimize_size && !set_p)\n-\t\t{\n-\t\t  rtx dest = SET_DEST (x);\n-\n-\t\t  while (GET_CODE (dest) == SUBREG\n-\t\t\t || GET_CODE (dest) == ZERO_EXTRACT\n-\t\t\t || GET_CODE (dest) == SIGN_EXTRACT\n-\t\t\t || GET_CODE (dest) == STRICT_LOW_PART)\n-\t\t    dest = XEXP (dest, 0);\n-\t\t  if (GET_CODE (dest) == REG)\n-\t\t    maybe_set_rd_gen (REGNO (dest), insn);\n-\t\t}\n \t    }\n \t  else if (GET_CODE (x) == CLOBBER)\n \t    hash_scan_clobber (x, insn);\n@@ -1994,8 +2046,7 @@ record_last_set_info (dest, setter)\n    SET_P is non-zero for computing the assignment hash table.  */\n \n static void\n-compute_hash_table (f, set_p)\n-     rtx f ATTRIBUTE_UNUSED;\n+compute_hash_table (set_p)\n      int set_p;\n {\n   int bb;\n@@ -2130,14 +2181,13 @@ free_set_hash_table ()\n /* Compute the hash table for doing copy/const propagation.  */\n \n static void\n-compute_set_hash_table (f)\n-     rtx f;\n+compute_set_hash_table ()\n {\n   /* Initialize count of number of entries in hash table.  */\n   n_sets = 0;\n   bzero ((char *) set_hash_table, set_hash_table_size * sizeof (struct expr *));\n \n-  compute_hash_table (f, 1);\n+  compute_hash_table (1);\n }\n \n /* Allocate space for the expression hash table.\n@@ -2173,14 +2223,13 @@ free_expr_hash_table ()\n /* Compute the hash table for doing GCSE.  */\n \n static void\n-compute_expr_hash_table (f)\n-     rtx f;\n+compute_expr_hash_table ()\n {\n   /* Initialize count of number of entries in hash table.  */\n   n_exprs = 0;\n   bzero ((char *) expr_hash_table, expr_hash_table_size * sizeof (struct expr *));\n \n-  compute_hash_table (f, 0);\n+  compute_hash_table (0);\n }\n \f\n /* Expression tracking support.  */\n@@ -2345,8 +2394,8 @@ oprs_not_set_p (x, insn)\n /* Mark things set by a CALL.  */\n \n static void\n-mark_call (pat, insn)\n-     rtx pat ATTRIBUTE_UNUSED, insn;\n+mark_call (insn)\n+     rtx insn;\n {\n   mem_last_set = INSN_CUID (insn);\n }\n@@ -2371,7 +2420,7 @@ mark_set (pat, insn)\n     mem_last_set = INSN_CUID (insn);\n \n   if (GET_CODE (SET_SRC (pat)) == CALL)\n-    mark_call (SET_SRC (pat), insn);\n+    mark_call (insn);\n }\n \n /* Record things set by a CLOBBER.  */\n@@ -2415,14 +2464,15 @@ mark_oprs_set (insn)\n \t  else if (GET_CODE (x) == CLOBBER)\n \t    mark_clobber (x, insn);\n \t  else if (GET_CODE (x) == CALL)\n-\t    mark_call (x, insn);\n+\t    mark_call (insn);\n \t}\n     }\n   else if (GET_CODE (pat) == CLOBBER)\n     mark_clobber (pat, insn);\n   else if (GET_CODE (pat) == CALL)\n-    mark_call (pat, insn);\n+    mark_call (insn);\n }\n+\n \f\n /* Classic GCSE reaching definition support.  */\n \n@@ -2474,38 +2524,6 @@ handle_rd_kill_set (insn, regno, bb)\n     }\n }\n \n-void\n-dump_rd_table (file, title, bmap)\n-     FILE *file;\n-     char *title;\n-     sbitmap *bmap;\n-{\n-  int bb,cuid,i,j,n;\n-\n-  fprintf (file, \"%s\\n\", title);\n-  for (bb = 0; bb < n_basic_blocks; bb++)\n-    {\n-      fprintf (file, \"BB %d\\n\", bb);\n-      dump_sbitmap (file, bmap[bb]);\n-      for (i = n = cuid = 0; i < bmap[bb]->size; i++)\n-\t{\n-\t  for (j = 0; j < SBITMAP_ELT_BITS; j++, cuid++)\n-\t    {\n-\t      if ((bmap[bb]->elms[i] & (1 << j)) != 0)\n-\t\t{\n-\t\t  if (n % 10 == 0)\n-\t\t    fprintf (file, \" \");\n-\t\t  fprintf (file, \" %d\", INSN_UID (CUID_INSN (cuid)));\n-\t\t  n++;\n-\t\t}\n-\t    }\n-\t}\n-      if (n != 0)\n-\tfprintf (file, \"\\n\");\n-    }\n-  fprintf (file, \"\\n\");\n-}\n-\n /* Compute the set of kill's for reaching definitions.  */\n \n static void\n@@ -2807,8 +2825,7 @@ compute_available ()\n       changed = 0;\n       for (bb = 1; bb < n_basic_blocks; bb++)\n \t{\n-\t  sbitmap_intersect_of_predecessors (ae_in[bb], ae_out,\n-\t\t\t\t\t     bb, s_preds);\n+\t  sbitmap_intersect_of_predecessors (ae_in[bb], ae_out, bb, s_preds);\n \t  changed |= sbitmap_union_of_diff (ae_out[bb], ae_gen[bb],\n \t\t\t\t\t    ae_in[bb], ae_kill[bb]);\n \t}\n@@ -3263,8 +3280,7 @@ classic_gcse ()\n    Return non-zero if a change was made.  */\n \n static int\n-one_classic_gcse_pass (f, pass)\n-     rtx f;\n+one_classic_gcse_pass (pass)\n      int pass;\n {\n   int changed = 0;\n@@ -3274,7 +3290,7 @@ one_classic_gcse_pass (f, pass)\n \n   alloc_expr_hash_table (max_cuid);\n   alloc_rd_mem (n_basic_blocks, max_cuid);\n-  compute_expr_hash_table (f);\n+  compute_expr_hash_table ();\n   if (gcse_file)\n     dump_hash_table (gcse_file, \"Expression\", expr_hash_table,\n \t\t     expr_hash_table_size, n_exprs);\n@@ -3341,23 +3357,6 @@ free_cprop_mem ()\n   free (cprop_avout);\n }\n \n-/* Dump copy/const propagation data.  */\n-\n-void\n-dump_cprop_data (file)\n-     FILE *file;\n-{\n-  dump_sbitmap_vector (file, \"CPROP partially locally available sets\", \"BB\",\n-\t\t       cprop_pavloc, n_basic_blocks);\n-  dump_sbitmap_vector (file, \"CPROP absolutely altered sets\", \"BB\",\n-\t\t       cprop_absaltered, n_basic_blocks);\n-\n-  dump_sbitmap_vector (file, \"CPROP available incoming sets\", \"BB\",\n-\t\t       cprop_avin, n_basic_blocks);\n-  dump_sbitmap_vector (file, \"CPROP available outgoing sets\", \"BB\",\n-\t\t       cprop_avout, n_basic_blocks);\n-}\n-\n /* For each block, compute whether X is transparent.\n    X is either an expression or an assignment [though we don't care which,\n    for this context an assignment is treated as an expression].\n@@ -3484,42 +3483,11 @@ compute_transp (x, indx, bmap, set_p)\n     }\n }\n \n-static void\n-compute_cprop_local_properties ()\n-{\n-  int i;\n-\n-  sbitmap_vector_zero (cprop_absaltered, n_basic_blocks);\n-  sbitmap_vector_zero (cprop_pavloc, n_basic_blocks);\n-\n-  for (i = 0; i < set_hash_table_size; i++)\n-    {\n-      struct expr *expr;\n-\n-      for (expr = set_hash_table[i]; expr != NULL; expr = expr->next_same_hash)\n-\t{\n-\t  struct occr *occr;\n-\t  int indx = expr->bitmap_index;\n-\n-\t  /* The assignment is absolutely altered if any operand is modified\n-\t     by this block [excluding the assignment itself].\n-\t     We start by assuming all are transparent [none are killed], and\n-\t     then setting the bits for those that are.  */\n-\n-\t  compute_transp (expr->expr, indx, cprop_absaltered, 1);\n-\n-\t  /* The occurrences recorded in avail_occr are exactly those that\n-\t     we want to set to non-zero in PAVLOC.  */\n-\n-\t  for (occr = expr->avail_occr; occr != NULL; occr = occr->next)\n-\t    {\n-\t      int bb = BLOCK_NUM (occr->insn);\n-\t      SET_BIT (cprop_pavloc[bb], indx);\n-\t    }\n-\t}\n-    }\n-}\n-\n+/* Compute the available expressions at the start and end of each\n+   basic block for cprop.  This particular dataflow equation is\n+   used often enough that we might want to generalize it and make\n+   as a subroutine for other global optimizations that need available\n+   in/out information.  */\n static void\n compute_cprop_avinout ()\n {\n@@ -3536,8 +3504,8 @@ compute_cprop_avinout ()\n       for (bb = 0; bb < n_basic_blocks; bb++)\n \t{\n \t  if (bb != 0)\n-\t    sbitmap_intersect_of_predecessors (cprop_avin[bb], cprop_avout,\n-\t\t\t\t\t       bb, s_preds);\n+\t    sbitmap_intersect_of_predecessors (cprop_avin[bb],\n+\t\t\t\t\t       cprop_avout, bb, s_preds);\n \t  changed |= sbitmap_union_of_diff (cprop_avout[bb],\n \t\t\t\t\t    cprop_pavloc[bb],\n \t\t\t\t\t    cprop_avin[bb],\n@@ -3556,7 +3524,7 @@ compute_cprop_avinout ()\n static void\n compute_cprop_data ()\n {\n-  compute_cprop_local_properties ();\n+  compute_local_properties (cprop_absaltered, cprop_pavloc, NULL, 1);\n   compute_cprop_avinout ();\n }\n \f\n@@ -3700,8 +3668,9 @@ find_avail_set (regno, insn)\n    The result is non-zero if a change was made.  */\n \n static int\n-cprop_insn (insn)\n+cprop_insn (insn, alter_jumps)\n      rtx insn;\n+     int alter_jumps;\n {\n   struct reg_use *reg_used;\n   int changed = 0;\n@@ -3775,7 +3744,8 @@ cprop_insn (insn)\n \t     (set (pc) (if_then_else ...))\n \n \t     Note this does not currently handle machines which use cc0.  */\n-\t  else if (GET_CODE (insn) == JUMP_INSN && condjump_p (insn))\n+\t  else if (alter_jumps\n+\t\t   && GET_CODE (insn) == JUMP_INSN && condjump_p (insn))\n \t    {\n \t      /* We want a copy of the JUMP_INSN so we can modify it\n \t\t in-place as needed without effecting the original.  */\n@@ -3880,7 +3850,8 @@ cprop_insn (insn)\n    Return non-zero if a change was made.  */\n \n static int\n-cprop ()\n+cprop (alter_jumps)\n+     int alter_jumps;\n {\n   int bb, changed;\n   rtx insn;\n@@ -3900,7 +3871,7 @@ cprop ()\n \t{\n \t  if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n \t    {\n-\t      changed |= cprop_insn (insn);\n+\t      changed |= cprop_insn (insn, alter_jumps);\n \n \t      /* Keep track of everything modified by this insn.  */\n \t      /* ??? Need to be careful w.r.t. mods done to INSN.  */\n@@ -3920,25 +3891,25 @@ cprop ()\n    PASS is the pass count.  */\n \n static int\n-one_cprop_pass (f, pass)\n-     rtx f;\n+one_cprop_pass (pass, alter_jumps)\n      int pass;\n+     int alter_jumps;\n {\n   int changed = 0;\n \n   const_prop_count = 0;\n   copy_prop_count = 0;\n \n   alloc_set_hash_table (max_cuid);\n-  compute_set_hash_table (f);\n+  compute_set_hash_table ();\n   if (gcse_file)\n     dump_hash_table (gcse_file, \"SET\", set_hash_table, set_hash_table_size,\n \t\t     n_sets);\n   if (n_sets > 0)\n     {\n       alloc_cprop_mem (n_basic_blocks, n_sets);\n       compute_cprop_data ();\n-      changed = cprop ();\n+      changed = cprop (alter_jumps);\n       free_cprop_mem ();\n     }\n   free_set_hash_table ();\n@@ -4029,41 +4000,6 @@ free_pre_mem ()\n   free (pre_transpout);\n }\n \n-/* Dump PRE data.  */\n-\n-void\n-dump_pre_data (file)\n-     FILE *file;\n-{\n-  dump_sbitmap_vector (file, \"PRE locally transparent expressions\", \"BB\",\n-\t\t       pre_transp, n_basic_blocks);\n-  dump_sbitmap_vector (file, \"PRE locally available expressions\", \"BB\",\n-\t\t       pre_comp, n_basic_blocks);\n-  dump_sbitmap_vector (file, \"PRE locally anticipatable expressions\", \"BB\",\n-\t\t       pre_antloc, n_basic_blocks);\n-\n-  dump_sbitmap_vector (file, \"PRE available incoming expressions\", \"BB\",\n-\t\t       pre_avin, n_basic_blocks);\n-  dump_sbitmap_vector (file, \"PRE available outgoing expressions\", \"BB\",\n-\t\t       pre_avout, n_basic_blocks);\n-  dump_sbitmap_vector (file, \"PRE anticipatable incoming expressions\", \"BB\",\n-\t\t       pre_antin, n_basic_blocks);\n-  dump_sbitmap_vector (file, \"PRE anticipatable outgoing expressions\", \"BB\",\n-\t\t       pre_antout, n_basic_blocks);\n-\n-  dump_sbitmap_vector (file, \"PRE partially available incoming expressions\", \"BB\",\n-\t\t       pre_pavin, n_basic_blocks);\n-  dump_sbitmap_vector (file, \"PRE partially available outgoing expressions\", \"BB\",\n-\t\t       pre_pavout, n_basic_blocks);\n-  dump_sbitmap_vector (file, \"PRE placement possible on incoming\", \"BB\",\n-\t\t       pre_ppin, n_basic_blocks);\n-  dump_sbitmap_vector (file, \"PRE placement possible on outgoing\", \"BB\",\n-\t\t       pre_ppout, n_basic_blocks);\n-\n-  dump_sbitmap_vector (file, \"PRE transparent on outgoing\", \"BB\",\n-\t\t       pre_transpout, n_basic_blocks);\n-}\n-\n /* Compute the local properties of each recorded expression.\n    Local properties are those that are defined by the block, irrespective\n    of other blocks.\n@@ -4886,8 +4822,7 @@ pre_gcse ()\n    Return non-zero if a change was made.  */\n \n static int\n-one_pre_gcse_pass (f, pass)\n-     rtx f;\n+one_pre_gcse_pass (pass)\n      int pass;\n {\n   int changed = 0;\n@@ -4896,7 +4831,7 @@ one_pre_gcse_pass (f, pass)\n   gcse_create_count = 0;\n \n   alloc_expr_hash_table (max_cuid);\n-  compute_expr_hash_table (f);\n+  compute_expr_hash_table ();\n   if (gcse_file)\n     dump_hash_table (gcse_file, \"Expression\", expr_hash_table,\n \t\t     expr_hash_table_size, n_exprs);"}]}