{"sha": "57ed620ebfa4275d04efeec973e88f506b0e3ba8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTdlZDYyMGViZmE0Mjc1ZDA0ZWZlZWM5NzNlODhmNTA2YjBlM2JhOA==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-06-03T13:49:30Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-06-03T13:49:30Z"}, "message": "libstdc++: Simplify range adaptors' forwarding of bound args [PR100577]\n\nr11-8053 rewrote the range adaptor implementation in conformance with\nP2281R1, making partial application act like a SFINAE-friendly perfect\nforwarding call wrapper.  Making SFINAE-friendliness coexist with\nperfect forwarding here requires adding fallback deleted operator()\noverloads (as described in e.g. section 5.5 of P0847R6).  But\nunfortunately, as reported in PR100577, this necessary technique of\nusing of deleted overloads regresses diagnostics for ill-formed calls to\npartially applied range adaptors in GCC.\n\nAlthough GCC's diagnostics can arguably be improved here by having the\ncompiler explain why the other candidates weren't viable when overload\nresolution selects a deleted candidate, we can also largely work around\nthis on the library side (and achieve more concise diagnostics than by\na frontend-side improvement alone) if we take advantage of the\nobservation that not all range adaptors need perfect forwarding call\nwrapper semantics, in fact only views::split currently needs it, because\nall other range adaptors either take no extra arguments or only\narguments that are expected to be freely/cheaply copyable, e.g. function\nobjects and integer-like types.  (The discussion section in P2281R1 goes\ninto detail about why views::split is special.)\n\nTo that end, this introduces opt-in flags for denoting a range adaptor\nas having \"simple\" extra arguments (in the case of a range adaptor\nnon-closure) or having a \"simple\" call operator (in the case of a range\nadaptor closure).  These flags are then used to conditionally simplify\nthe operator() for the generic _Partial and _Pipe class templates, down\nfrom needing three overloads thereof (including one defined as deleted)\nto just needing a single overload.  The end result is that diagnostic\nquality is restored for all adaptors except for views::split, and\ndiagnostics for the adaptors are generally made more concise since\nthere's only a single _Partial/_Pipe overload to diagnose instead of\nthree of them.\n\nlibstdc++-v3/ChangeLog:\n\n\tPR libstdc++/100577\n\t* include/std/ranges (_RangeAdaptorClosure): Document\n\t_S_has_simple_call_op mechanism.\n\t(_RangeAdaptor): Document _S_has_simple_extra_args mechanism.\n\t(__closure_has_simple_call_op): New concept.\n\t(__adaptor_has_simple_extra_args): Likewise.\n\t(_Partial<_Adaptor, _Args...>): New partial specialization.\n\t(_Partial<_Adaptor, _Arg>): Likewise.\n\t(_Pipe<_Lhs, _Rhs>): Likewise.\n\t(views::_All::_S_has_simple_call_op): Define to true.\n\t(views::_Filter::_S_has_simple_extra_args): Likewise.\n\t(views::_Transform::_S_has_simple_extra_args): Likewise.\n\t(views::_Take::_S_has_simple_extra_args): Likewise.\n\t(views::_TakeWhile::_S_has_simple_extra_args): Likewise.\n\t(views::_Drop::_S_has_simple_extra_args): Likewise.\n\t(views::_DropWhile::_S_has_simple_extra_args): Likewise.\n\t(views::_Join::_S_has_simple_call_op): Likewise.\n\t(views::_Split): Document why we don't define\n\t_S_has_simple_extra_args to true for this adaptor.\n\t(views::_Common::_S_has_simple_call_op): Define to true.\n\t(views::_Reverse::_S_has_simple_call_op): Likewise.\n\t(views::_Elements::_S_has_simple_call_op): Likewise.\n\t* testsuite/std/ranges/adaptors/100577.cc: New test.", "tree": {"sha": "79971d6dd62cc630ee73c4d0495c7fa5f625841e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/79971d6dd62cc630ee73c4d0495c7fa5f625841e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/57ed620ebfa4275d04efeec973e88f506b0e3ba8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57ed620ebfa4275d04efeec973e88f506b0e3ba8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57ed620ebfa4275d04efeec973e88f506b0e3ba8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57ed620ebfa4275d04efeec973e88f506b0e3ba8/comments", "author": null, "committer": null, "parents": [{"sha": "d999d9b7e53b9a9cd2004a19e84c637e5e5013f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d999d9b7e53b9a9cd2004a19e84c637e5e5013f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d999d9b7e53b9a9cd2004a19e84c637e5e5013f5"}], "stats": {"total": 220, "additions": 219, "deletions": 1}, "files": [{"sha": "8bf359e477cb65e517b6c91e93b00fbf6821c71c", "filename": "libstdc++-v3/include/std/ranges", "status": "modified", "additions": 118, "deletions": 1, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57ed620ebfa4275d04efeec973e88f506b0e3ba8/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57ed620ebfa4275d04efeec973e88f506b0e3ba8/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges?ref=57ed620ebfa4275d04efeec973e88f506b0e3ba8", "patch": "@@ -760,6 +760,10 @@ namespace views::__adaptor\n     struct _Pipe;\n \n   // The base class of every range adaptor closure.\n+  //\n+  // The derived class should define the optional static data member\n+  // _S_has_simple_call_op to true if the behavior of this adaptor is\n+  // independent of the constness/value category of the adaptor object.\n   struct _RangeAdaptorClosure\n   {\n     // range | adaptor is equivalent to adaptor(range).\n@@ -785,6 +789,10 @@ namespace views::__adaptor\n   // The static data member _Derived::_S_arity must contain the total number of\n   // arguments that the adaptor takes, and the class _Derived must introduce\n   // _RangeAdaptor::operator() into the class scope via a using-declaration.\n+  //\n+  // The optional static data member _Derived::_S_has_simple_extra_args should\n+  // be defined to true if the behavior of this adaptor is independent of the\n+  // constness/value category of the extra arguments.\n   template<typename _Derived>\n     struct _RangeAdaptor\n     {\n@@ -799,6 +807,17 @@ namespace views::__adaptor\n \t}\n     };\n \n+  // True if the range adaptor closure _Adaptor has a simple operator(), i.e.\n+  // one that's not overloaded according to constness or value category of the\n+  // _Adaptor object.\n+  template<typename _Adaptor>\n+    concept __closure_has_simple_call_op = _Adaptor::_S_has_simple_call_op;\n+\n+  // True if the behavior of the range adaptor non-closure _Adaptor is\n+  // independent of the value category of its extra arguments.\n+  template<typename _Adaptor>\n+    concept __adaptor_has_simple_extra_args = _Adaptor::_S_has_simple_extra_args;\n+\n   // A range adaptor closure that represents partial application of\n   // the range adaptor _Adaptor with arguments _Args.\n   template<typename _Adaptor, typename... _Args>\n@@ -812,7 +831,7 @@ namespace views::__adaptor\n       { }\n \n       // Invoke _Adaptor with arguments __r, _M_args... according to the\n-      // value category of the range adaptor closure object.\n+      // value category of this _Partial object.\n       template<typename _Range>\n \trequires __adaptor_invocable<_Adaptor, _Range, const _Args&...>\n \tconstexpr auto\n@@ -869,6 +888,59 @@ namespace views::__adaptor\n \toperator()(_Range&& __r) const && = delete;\n     };\n \n+  // Partial specialization of the primary template for the case where the extra\n+  // arguments of the adaptor can always be safely forwarded by const reference.\n+  // This lets us get away with a single operator() overload, which makes\n+  // overload resolution failure diagnostics more concise.\n+  template<typename _Adaptor, typename... _Args>\n+    requires __adaptor_has_simple_extra_args<_Adaptor>\n+    struct _Partial<_Adaptor, _Args...> : _RangeAdaptorClosure\n+    {\n+      tuple<_Args...> _M_args;\n+\n+      constexpr\n+      _Partial(_Args... __args)\n+\t: _M_args(std::move(__args)...)\n+      { }\n+\n+      // Invoke _Adaptor with arguments __r, const _M_args&... regardless\n+      // of the value category of this _Partial object.\n+      template<typename _Range>\n+\trequires __adaptor_invocable<_Adaptor, _Range, const _Args&...>\n+\tconstexpr auto\n+\toperator()(_Range&& __r) const\n+\t{\n+\t  auto __forwarder = [&__r] (const auto&... __args) {\n+\t    return _Adaptor{}(std::forward<_Range>(__r), __args...);\n+\t  };\n+\t  return std::apply(__forwarder, _M_args);\n+\t}\n+\n+      static constexpr bool _S_has_simple_call_op = true;\n+    };\n+\n+  // A lightweight specialization of the above template for the common case\n+  // where _Adaptor accepts a single extra argument.\n+  template<typename _Adaptor, typename _Arg>\n+    requires __adaptor_has_simple_extra_args<_Adaptor>\n+    struct _Partial<_Adaptor, _Arg> : _RangeAdaptorClosure\n+    {\n+      _Arg _M_arg;\n+\n+      constexpr\n+      _Partial(_Arg __arg)\n+\t: _M_arg(std::move(__arg))\n+      { }\n+\n+      template<typename _Range>\n+\trequires __adaptor_invocable<_Adaptor, _Range, const _Arg&>\n+\tconstexpr auto\n+\toperator()(_Range&& __r) const\n+\t{ return _Adaptor{}(std::forward<_Range>(__r), _M_arg); }\n+\n+      static constexpr bool _S_has_simple_call_op = true;\n+    };\n+\n   template<typename _Lhs, typename _Rhs, typename _Range>\n     concept __pipe_invocable\n       = requires { std::declval<_Rhs>()(std::declval<_Lhs>()(std::declval<_Range>())); };\n@@ -904,6 +976,32 @@ namespace views::__adaptor\n \tconstexpr auto\n \toperator()(_Range&& __r) const && = delete;\n     };\n+\n+  // A partial specialization of the above primary template for the case where\n+  // both adaptor operands have a simple operator().  This in turn lets us\n+  // implement composition using a single simple operator(), which makes\n+  // overload resolution failure diagnostics more concise.\n+  template<typename _Lhs, typename _Rhs>\n+    requires __closure_has_simple_call_op<_Lhs>\n+      && __closure_has_simple_call_op<_Rhs>\n+    struct _Pipe<_Lhs, _Rhs> : _RangeAdaptorClosure\n+    {\n+      [[no_unique_address]] _Lhs _M_lhs;\n+      [[no_unique_address]] _Rhs _M_rhs;\n+\n+      constexpr\n+      _Pipe(_Lhs __lhs, _Rhs __rhs)\n+\t: _M_lhs(std::move(__lhs)), _M_rhs(std::move(__rhs))\n+      { }\n+\n+      template<typename _Range>\n+\trequires __pipe_invocable<const _Lhs&, const _Rhs&, _Range>\n+\tconstexpr auto\n+\toperator()(_Range&& __r) const\n+\t{ return _M_rhs(_M_lhs(std::forward<_Range>(__r))); }\n+\n+      static constexpr bool _S_has_simple_call_op = true;\n+    };\n } // namespace views::__adaptor\n \n   template<range _Range> requires is_object_v<_Range>\n@@ -985,6 +1083,8 @@ namespace views::__adaptor\n \t  else\n \t    return subrange{std::forward<_Range>(__r)};\n \t}\n+\n+      static constexpr bool _S_has_simple_call_op = true;\n     };\n \n     inline constexpr _All all;\n@@ -1438,6 +1538,7 @@ namespace views::__adaptor\n \n       using _RangeAdaptor<_Filter>::operator();\n       static constexpr int _S_arity = 2;\n+      static constexpr bool _S_has_simple_extra_args = true;\n     };\n \n     inline constexpr _Filter filter;\n@@ -1812,6 +1913,7 @@ namespace views::__adaptor\n \n       using _RangeAdaptor<_Transform>::operator();\n       static constexpr int _S_arity = 2;\n+      static constexpr bool _S_has_simple_extra_args = true;\n     };\n \n     inline constexpr _Transform transform;\n@@ -1992,6 +2094,7 @@ namespace views::__adaptor\n \n       using _RangeAdaptor<_Take>::operator();\n       static constexpr int _S_arity = 2;\n+      static constexpr bool _S_has_simple_extra_args = true;\n     };\n \n     inline constexpr _Take take;\n@@ -2111,6 +2214,7 @@ namespace views::__adaptor\n \n       using _RangeAdaptor<_TakeWhile>::operator();\n       static constexpr int _S_arity = 2;\n+      static constexpr bool _S_has_simple_extra_args = true;\n     };\n \n     inline constexpr _TakeWhile take_while;\n@@ -2230,6 +2334,7 @@ namespace views::__adaptor\n \n       using _RangeAdaptor<_Drop>::operator();\n       static constexpr int _S_arity = 2;\n+      static constexpr bool _S_has_simple_extra_args = true;\n     };\n \n     inline constexpr _Drop drop;\n@@ -2314,6 +2419,7 @@ namespace views::__adaptor\n \n       using _RangeAdaptor<_DropWhile>::operator();\n       static constexpr int _S_arity = 2;\n+      static constexpr bool _S_has_simple_extra_args = true;\n     };\n \n     inline constexpr _DropWhile drop_while;\n@@ -2671,6 +2777,8 @@ namespace views::__adaptor\n \t  // 3474. Nesting join_views is broken because of CTAD\n \t  return join_view<all_t<_Range>>{std::forward<_Range>(__r)};\n \t}\n+\n+      static constexpr bool _S_has_simple_call_op = true;\n     };\n \n     inline constexpr _Join join;\n@@ -3104,6 +3212,9 @@ namespace views::__adaptor\n \n       using _RangeAdaptor<_Split>::operator();\n       static constexpr int _S_arity = 2;\n+      // The second argument of views::split is _not_ simple -- it can be a\n+      // non-view range, the value category of which affects whether the call is\n+      // well-formed.  So we must not define _S_has_simple_extra_args to true.\n     };\n \n     inline constexpr _Split split;\n@@ -3243,6 +3354,8 @@ namespace views::__adaptor\n \t  else\n \t    return common_view{std::forward<_Range>(__r)};\n \t}\n+\n+      static constexpr bool _S_has_simple_call_op = true;\n     };\n \n     inline constexpr _Common common;\n@@ -3374,6 +3487,8 @@ namespace views::__adaptor\n \t  else\n \t    return reverse_view{std::forward<_Range>(__r)};\n \t}\n+\n+      static constexpr bool _S_has_simple_call_op = true;\n     };\n \n     inline constexpr _Reverse reverse;\n@@ -3757,6 +3872,8 @@ namespace views::__adaptor\n \t  {\n \t    return elements_view<all_t<_Range>, _Nm>{std::forward<_Range>(__r)};\n \t  }\n+\n+\tstatic constexpr bool _S_has_simple_call_op = true;\n       };\n \n     template<size_t _Nm>"}, {"sha": "29176c8b7b09b9e25d3e22c4a0adc9e702a2f97c", "filename": "libstdc++-v3/testsuite/std/ranges/adaptors/100577.cc", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57ed620ebfa4275d04efeec973e88f506b0e3ba8/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2F100577.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57ed620ebfa4275d04efeec973e88f506b0e3ba8/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2F100577.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2F100577.cc?ref=57ed620ebfa4275d04efeec973e88f506b0e3ba8", "patch": "@@ -0,0 +1,101 @@\n+// Copyright (C) 2021 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+// PR libstdc++/100577\n+\n+#include <ranges>\n+\n+namespace ranges = std::ranges;\n+namespace views = std::ranges::views;\n+\n+void\n+test01()\n+{\n+  // Verify all multi-argument adaptors except for views::split are denoted\n+  // to have simple extra arguments.\n+  using views::__adaptor::__adaptor_has_simple_extra_args;\n+  static_assert(__adaptor_has_simple_extra_args<decltype(views::transform)>);\n+  static_assert(__adaptor_has_simple_extra_args<decltype(views::filter)>);\n+  static_assert(__adaptor_has_simple_extra_args<decltype(views::drop)>);\n+  static_assert(__adaptor_has_simple_extra_args<decltype(views::take)>);\n+  static_assert(__adaptor_has_simple_extra_args<decltype(views::take_while)>);\n+  static_assert(__adaptor_has_simple_extra_args<decltype(views::drop_while)>);\n+  static_assert(!__adaptor_has_simple_extra_args<decltype(views::split)>);\n+\n+  // Verify all adaptor closures except for views::split(pattern) have a simple\n+  // operator().\n+  using views::__adaptor::__closure_has_simple_call_op;\n+  __closure_has_simple_call_op auto a00 = views::all;\n+  __closure_has_simple_call_op auto a01 = views::transform(std::identity{});\n+  __closure_has_simple_call_op auto a02 = views::filter(std::identity{});\n+  __closure_has_simple_call_op auto a03 = views::drop(42);\n+  __closure_has_simple_call_op auto a04 = views::take(42);\n+  __closure_has_simple_call_op auto a05 = views::take_while(std::identity{});\n+  __closure_has_simple_call_op auto a06 = views::drop_while(std::identity{});\n+  __closure_has_simple_call_op auto a07 = views::join;\n+  __closure_has_simple_call_op auto a08 = views::common;\n+  __closure_has_simple_call_op auto a09 = views::reverse;\n+  __closure_has_simple_call_op auto a10 = views::keys;\n+  // Verify composition of simple closures is simple.\n+  __closure_has_simple_call_op auto b\n+    = (a00 | a01) | (a02 | a03) | (a04 | a05 | a06) | (a07 | a08 | a09 | a10);\n+\n+  // Verify views::split is the exception.\n+  auto a11 = views::split(' ');\n+  static_assert(!__closure_has_simple_call_op<decltype(a11)>);\n+  static_assert(!__closure_has_simple_call_op<decltype(a11 | a00)>);\n+  static_assert(!__closure_has_simple_call_op<decltype(a00 | a11)>);\n+}\n+\n+void\n+test02()\n+{\n+  // Range adaptor closures with a simple operator() aren't implemented using a\n+  // fallback deleted overload, so when a call is ill-formed overload resolution\n+  // fails.\n+  extern int x[10];\n+  auto badarg = nullptr;\n+  views::transform(badarg)(x); // { dg-error \"no match\" }\n+  views::filter(badarg)(x); // { dg-error \"no match\" }\n+  views::take(badarg)(x); // { dg-error \"no match\" }\n+  views::drop(badarg)(x); // { dg-error \"no match\" }\n+  views::take_while(badarg)(x); // { dg-error \"no match\" }\n+  views::drop_while(badarg)(x); // { dg-error \"no match\" }\n+\n+  (views::transform(badarg) | views::all)(x); // { dg-error \"no match\" }\n+  (views::filter(badarg) | views::all)(x); // { dg-error \"no match\" }\n+  (views::take(badarg) | views::all)(x); // { dg-error \"no match\" }\n+  (views::drop(badarg) | views::all)(x); // { dg-error \"no match\" }\n+  (views::take_while(badarg) | views::all)(x); // { dg-error \"no match\" }\n+  (views::drop_while(badarg) | views::all)(x); // { dg-error \"no match\" }\n+\n+  // In practice, range adaptor closures with non-simple operator() are\n+  // implemented using a fallback deleted overload, so when a call is\n+  // ill-formed overload resolution succeeds but selects the deleted overload\n+  // (but only when the closure is invoked as an rvalue).\n+  views::split(badarg)(x); // { dg-error \"deleted function\" }\n+  (views::split(badarg) | views::all)(x); // { dg-error \"deleted function\" }\n+  auto a0 = views::split(badarg);\n+  a0(x); // { dg-error \"no match\" };\n+  auto a1 = a0 | views::all;\n+  a1(x); // { dg-error \"no match\" }\n+}\n+\n+// { dg-prune-output \"in requirements\" }"}]}