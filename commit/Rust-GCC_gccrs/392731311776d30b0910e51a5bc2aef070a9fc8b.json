{"sha": "392731311776d30b0910e51a5bc2aef070a9fc8b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzkyNzMxMzExNzc2ZDMwYjA5MTBlNTFhNWJjMmFlZjA3MGE5ZmM4Yg==", "commit": {"author": {"name": "Kyle Galloway", "email": "kgallowa@redhat.com", "date": "2007-01-29T22:05:56Z"}, "committer": {"name": "Kyle Galloway", "email": "kgallowa@gcc.gnu.org", "date": "2007-01-29T22:05:56Z"}, "message": "java-interp.h: Added _Jv_Frame class and its two subclasses _Jv_InterpFrame and _Jv_NativeFrame.\n\n2007-01-29  Kyle Galloway  <kgallowa@redhat.com>\n\n\t* include/java-interp.h:  Added _Jv_Frame class and its two\n\tsubclasses _Jv_InterpFrame and _Jv_NativeFrame.  Also moved\n\t_Jv_FrameType from java-stack.h.\n\t* include/java-stack.h: Removed _Jv_FrameType.\n\t* java/lang/Thread.java: Added frame member to hold new\n\tcomposite frame stack.\n\t* java/lang/Thread.h: Regenerated.\n\t* java/lang/Thread.class: Rebuilt.\n\t* jni.cc (_Jv_JNIMethod::call): Push a frame onto the stack when\n\tcalling a JNI method.\n\t* jvmti.cc (_Jv_JVMTI_GetStackTrace): New Method.\n\t(_Jv_JVMTI_GetFrameCount): New method.\n\t* stacktrace.cc (UnwindTraceFn): Modified to use new _Jv_Frame\n\tclasses.\n\t* testsuite/libjava.jvmti/interp/getstacktrace.jar: New test.\n\t* testsuite/libjava.jvmti/interp/natgetstacktrace.cc: New test.\n\t* testsuite/libjava.jvmti/interp/getstacktrace.h: New test.\n\t* testsuite/libjava.jvmti/interp/getstacktrace.jar: New test.\n\t* testsuite/libjava.jvmti/interp/getstacktrace.out: Output file\n\tfor test.\n\nFrom-SVN: r121314", "tree": {"sha": "832133e3bfa83e14520e76d3a01b7a61b1b3b20e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/832133e3bfa83e14520e76d3a01b7a61b1b3b20e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/392731311776d30b0910e51a5bc2aef070a9fc8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/392731311776d30b0910e51a5bc2aef070a9fc8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/392731311776d30b0910e51a5bc2aef070a9fc8b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/392731311776d30b0910e51a5bc2aef070a9fc8b/comments", "author": null, "committer": null, "parents": [{"sha": "d75bf843440e5d372411699e81d87b273d398da6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d75bf843440e5d372411699e81d87b273d398da6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d75bf843440e5d372411699e81d87b273d398da6"}], "stats": {"total": 564, "additions": 537, "deletions": 27}, "files": [{"sha": "037b1bb650d867e94356829e304f176d528e10f9", "filename": "libjava/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/392731311776d30b0910e51a5bc2aef070a9fc8b/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/392731311776d30b0910e51a5bc2aef070a9fc8b/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=392731311776d30b0910e51a5bc2aef070a9fc8b", "patch": "@@ -1,3 +1,26 @@\n+2007-01-29  Kyle Galloway  <kgallowa@redhat.com>\n+\n+\t* include/java-interp.h:  Added _Jv_Frame class and its two\n+\tsubclasses _Jv_InterpFrame and _Jv_NativeFrame.  Also moved\n+\t_Jv_FrameType from java-stack.h.\n+\t* include/java-stack.h: Removed _Jv_FrameType.\n+\t* java/lang/Thread.java: Added frame member to hold new\n+\tcomposite frame stack.\n+\t* java/lang/Thread.h: Regenerated.\n+\t* java/lang/Thread.class: Rebuilt.\n+\t* jni.cc (_Jv_JNIMethod::call): Push a frame onto the stack when\n+\tcalling a JNI method.\n+\t* jvmti.cc (_Jv_JVMTI_GetStackTrace): New Method.\n+\t(_Jv_JVMTI_GetFrameCount): New method.\n+\t* stacktrace.cc (UnwindTraceFn): Modified to use new _Jv_Frame\n+\tclasses.\n+\t* testsuite/libjava.jvmti/interp/getstacktrace.jar: New test.\n+\t* testsuite/libjava.jvmti/interp/natgetstacktrace.cc: New test.\n+\t* testsuite/libjava.jvmti/interp/getstacktrace.h: New test.\n+\t* testsuite/libjava.jvmti/interp/getstacktrace.jar: New test.\n+\t* testsuite/libjava.jvmti/interp/getstacktrace.out: Output file\n+\tfor test. \n+\n 2007-01-29  Tom Tromey  <tromey@redhat.com>\n \n \t* interpret.cc (run_debug): Remove comment."}, {"sha": "3ce018edd9c8b3d245b8578bcaff6d63be38e2de", "filename": "libjava/classpath/lib/java/lang/Thread$State.class", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/392731311776d30b0910e51a5bc2aef070a9fc8b/libjava%2Fclasspath%2Flib%2Fjava%2Flang%2FThread%24State.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/392731311776d30b0910e51a5bc2aef070a9fc8b/libjava%2Fclasspath%2Flib%2Fjava%2Flang%2FThread%24State.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Flib%2Fjava%2Flang%2FThread%24State.class?ref=392731311776d30b0910e51a5bc2aef070a9fc8b"}, {"sha": "8329bc1552397dbf899da826e2a5e7aacc7593b0", "filename": "libjava/classpath/lib/java/lang/Thread.class", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/392731311776d30b0910e51a5bc2aef070a9fc8b/libjava%2Fclasspath%2Flib%2Fjava%2Flang%2FThread.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/392731311776d30b0910e51a5bc2aef070a9fc8b/libjava%2Fclasspath%2Flib%2Fjava%2Flang%2FThread.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Flib%2Fjava%2Flang%2FThread.class?ref=392731311776d30b0910e51a5bc2aef070a9fc8b"}, {"sha": "3a43977747fec7c58a7cd9f48bff65a617bcb791", "filename": "libjava/include/java-interp.h", "status": "modified", "additions": 65, "deletions": 14, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/392731311776d30b0910e51a5bc2aef070a9fc8b/libjava%2Finclude%2Fjava-interp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/392731311776d30b0910e51a5bc2aef070a9fc8b/libjava%2Finclude%2Fjava-interp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjava-interp.h?ref=392731311776d30b0910e51a5bc2aef070a9fc8b", "patch": "@@ -205,11 +205,11 @@ class _Jv_InterpMethod : public _Jv_MethodBase\n   // number info is unavailable.\n   int get_source_line(pc_t mpc);\n \n+   public:\n+\n   // Convenience function for indexing bytecode PC/insn slots in\n   // line tables for JDWP\n   jlong insn_index (pc_t pc);\n-  \n-   public:\n    \n   /* Get the line table for this method.\n    * start  is the lowest index in the method\n@@ -315,35 +315,86 @@ class _Jv_JNIMethod : public _Jv_MethodBase\n   }\n };\n \n-// The interpreted call stack, represented by a linked list of frames.\n-struct _Jv_InterpFrame\n+enum _Jv_FrameType\n {\n+  frame_native,\n+  frame_interpreter,\n+  frame_proxy\n+};\n+\n+//  The composite call stack as represented by a linked list of frames\n+class _Jv_Frame\n+{\n+public:\n+  java::lang::Thread *thread;\n+\n   union\n   {\n+    _Jv_MethodBase *self;\n     void *meth;\n-    _Jv_InterpMethod *self;\n     _Jv_Method *proxyMethod;\n   };\n-  java::lang::Thread *thread;\n-  _Jv_InterpFrame *next;\n+  \n+  //The full list of frames, JNI and interpreted\n+  _Jv_Frame *next;\n+  _Jv_FrameType frame_type;\n+  \n+  _Jv_Frame (_Jv_MethodBase *s, java::lang::Thread *thr, _Jv_FrameType type)\n+  {\n+    self = s;\n+    frame_type = type;\n+    next = (_Jv_Frame *) thr->frame;\n+    thr->frame = (gnu::gcj::RawData *) this;\n+    thread = thr;\n+  }\n+\n+  ~_Jv_Frame ()\n+  {\n+    thread->frame = (gnu::gcj::RawData *) next;\n+  }\n+};\n+\n+// An interpreted frame in the call stack\n+class _Jv_InterpFrame : public _Jv_Frame\n+{\n+public:\n+  \n+  // Keep the purely interpreted list around so as not to break backtraces\n+  _Jv_InterpFrame *next_interp;\n+  \n   union\n   {\n     pc_t pc;\n     jclass proxyClass;\n   };\n-  \n-  _Jv_InterpFrame (void *meth, java::lang::Thread *thr, jclass proxyClass = NULL)\n+\n+  //Debug info for local variables.\n+  _Jv_word *locals;\n+  char *locals_type;\n+\n+  _Jv_InterpFrame (void *meth, java::lang::Thread *thr, jclass proxyCls = NULL)\n+  : _Jv_Frame (reinterpret_cast<_Jv_MethodBase *> (meth), thr,\n+\t             frame_interpreter)\n   {\n-    this->meth = meth;\n-    thread = thr;\n-    next = (_Jv_InterpFrame *) thr->interp_frame;\n+    next_interp = (_Jv_InterpFrame *) thr->interp_frame;\n+    proxyClass = proxyCls;\n     thr->interp_frame = (gnu::gcj::RawData *) this;\n-    this->proxyClass = proxyClass;\n   }\n \n   ~_Jv_InterpFrame ()\n   {\n-    thread->interp_frame = (gnu::gcj::RawData *) next;\n+    thread->interp_frame = (gnu::gcj::RawData *) next_interp;\n+  }\n+};\n+\n+// A native frame in the call stack really just a placeholder\n+class _Jv_NativeFrame : public _Jv_Frame\n+{\n+public:\n+\n+  _Jv_NativeFrame (_Jv_JNIMethod *s, java::lang::Thread *thr)\n+  : _Jv_Frame (s, thr, frame_native)\n+  {\n   }\n };\n "}, {"sha": "49e68412be63e63dccff96372fdf426152cb1066", "filename": "libjava/include/java-stack.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/392731311776d30b0910e51a5bc2aef070a9fc8b/libjava%2Finclude%2Fjava-stack.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/392731311776d30b0910e51a5bc2aef070a9fc8b/libjava%2Finclude%2Fjava-stack.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjava-stack.h?ref=392731311776d30b0910e51a5bc2aef070a9fc8b", "patch": "@@ -41,13 +41,6 @@ extern \"Java\"\n   }\n }\n \n-enum _Jv_FrameType\n-{\n-  frame_native,\n-  frame_interpreter,\n-  frame_proxy\n-};\n-\n #ifdef INTERPRETER\n struct _Jv_InterpFrameInfo\n {"}, {"sha": "d5fce8638771b992cd137fbe575d34657c200057", "filename": "libjava/java/lang/Thread.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/392731311776d30b0910e51a5bc2aef070a9fc8b/libjava%2Fjava%2Flang%2FThread.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/392731311776d30b0910e51a5bc2aef070a9fc8b/libjava%2Fjava%2Flang%2FThread.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FThread.h?ref=392731311776d30b0910e51a5bc2aef070a9fc8b", "patch": "@@ -144,7 +144,8 @@ class java::lang::Thread : public ::java::lang::Object\n   static const jbyte THREAD_PARK_DEAD = 3;\n   ::java::lang::Object * accessControlState;\n   ::gnu::gcj::RawData * interp_frame;\n-  jint volatile state;\n+  ::gnu::gcj::RawData * frame;\n+  volatile jint state;\n   ::gnu::gcj::RawDataManaged * data;\n public:\n   static ::java::lang::Class class$;"}, {"sha": "7216512530df0707b6ee06f75cccf23bec61b097", "filename": "libjava/java/lang/Thread.java", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/392731311776d30b0910e51a5bc2aef070a9fc8b/libjava%2Fjava%2Flang%2FThread.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/392731311776d30b0910e51a5bc2aef070a9fc8b/libjava%2Fjava%2Flang%2FThread.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FThread.java?ref=392731311776d30b0910e51a5bc2aef070a9fc8b", "patch": "@@ -182,6 +182,9 @@ public class Thread implements Runnable\n   \n   // This describes the top-most interpreter frame for this thread.\n   RawData interp_frame;\n+  \n+  // This describes the top most frame in the composite (interp + JNI) stack\n+  RawData frame;\n \n   // Current state.\n   volatile int state;"}, {"sha": "07ef71345409e865a9054c6ef1d489a4aec155d0", "filename": "libjava/jni.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/392731311776d30b0910e51a5bc2aef070a9fc8b/libjava%2Fjni.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/392731311776d30b0910e51a5bc2aef070a9fc8b/libjava%2Fjni.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni.cc?ref=392731311776d30b0910e51a5bc2aef070a9fc8b", "patch": "@@ -2339,6 +2339,10 @@ _Jv_JNIMethod::call (ffi_cif *, void *ret, ffi_raw *args, void *__this)\n \n   // Copy over passed-in arguments.\n   memcpy (&real_args[offset], args, _this->args_raw_size);\n+  \n+  // Add a frame to the composite (interpreted + JNI) call stack\n+  java::lang::Thread *thread = java::lang::Thread::currentThread();\n+  _Jv_NativeFrame nat_frame (_this, thread);\n \n   // The actual call to the JNI function.\n #if FFI_NATIVE_RAW_API"}, {"sha": "c9c7e7ba731a9893543c5489159a1b1277ae2486", "filename": "libjava/jvmti.cc", "status": "modified", "additions": 106, "deletions": 2, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/392731311776d30b0910e51a5bc2aef070a9fc8b/libjava%2Fjvmti.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/392731311776d30b0910e51a5bc2aef070a9fc8b/libjava%2Fjvmti.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjvmti.cc?ref=392731311776d30b0910e51a5bc2aef070a9fc8b", "patch": "@@ -236,6 +236,34 @@ _Jv_JVMTI_GetAllThreads(MAYBE_UNUSED jvmtiEnv *env, jint *thread_cnt,\n   return JVMTI_ERROR_NONE;\n }\n \n+static jvmtiError JNICALL\n+_Jv_JVMTI_GetFrameCount (MAYBE_UNUSED jvmtiEnv *env, jthread thread,\n+                         jint* frame_count)\n+{\n+  REQUIRE_PHASE (env, JVMTI_PHASE_LIVE);\n+  \n+  NULL_CHECK (frame_count);\n+\t\n+  using namespace java::lang;\n+  \n+  THREAD_DEFAULT_TO_CURRENT (thread);\n+  \n+  Thread *thr = reinterpret_cast<Thread *> (thread);\n+  THREAD_CHECK_VALID (thr);\n+  THREAD_CHECK_IS_ALIVE (thr);\n+   \n+  _Jv_Frame *frame = reinterpret_cast<_Jv_Frame *> (thr->frame);\n+  (*frame_count) = 0;\n+  \n+  while (frame != NULL)\n+    {\n+      (*frame_count)++;\n+      frame = frame->next;\n+    }\n+  \n+  return JVMTI_ERROR_NONE;\n+}\n+\n static jvmtiError JNICALL\n _Jv_JVMTI_CreateRawMonitor (MAYBE_UNUSED jvmtiEnv *env, const char *name,\n \t\t\t    jrawMonitorID *result)\n@@ -747,6 +775,82 @@ _Jv_JVMTI_GetClassLoaderClasses (MAYBE_UNUSED jvmtiEnv *env,\n   return JVMTI_ERROR_NONE;\n }\n \n+static jvmtiError JNICALL\n+_Jv_JVMTI_GetStackTrace (MAYBE_UNUSED jvmtiEnv *env, jthread thread,\n+                         jint start_depth, jint max_frames,\n+                         jvmtiFrameInfo *frames, jint *frame_count)\n+{\n+  REQUIRE_PHASE (env, JVMTI_PHASE_LIVE);\n+\n+  ILLEGAL_ARGUMENT (max_frames < 0);\n+  \n+  NULL_CHECK (frames);\n+  NULL_CHECK (frame_count);\n+\t\n+  using namespace java::lang;\n+  \n+  THREAD_DEFAULT_TO_CURRENT (thread);\n+  \n+  Thread *thr = reinterpret_cast<Thread *> (thread);\n+  THREAD_CHECK_VALID (thr);\n+  THREAD_CHECK_IS_ALIVE (thr);\n+    \n+  jvmtiError jerr = env->GetFrameCount (thread, frame_count);\n+  if (jerr != JVMTI_ERROR_NONE)\n+    return jerr;\n+  \n+  // start_depth can be either a positive number, indicating the depth of the\n+  // stack at which to begin the trace, or a negative number indicating the\n+  // number of frames at the bottom of the stack to exclude.  These checks\n+  // ensure that it is a valid value in either case\n+  \n+  ILLEGAL_ARGUMENT (start_depth >= (*frame_count));\n+  ILLEGAL_ARGUMENT (start_depth < (-(*frame_count)));\n+  \n+  _Jv_Frame *frame = reinterpret_cast<_Jv_Frame *> (thr->frame);\n+\n+  // If start_depth is negative use this to determine at what depth to start\n+  // the trace by adding it to the length of the call stack.  This allows the\n+  // use of the same frame \"discarding\" mechanism as for a positive start_depth\n+  if (start_depth < 0)\n+    start_depth = *frame_count + start_depth;\n+  \n+  // If start_depth > 0 \"remove\" start_depth frames from the beginning\n+  // of the stack before beginning the trace by moving along the frame list.\n+  while (start_depth > 0)\n+    {\n+      frame = frame->next;\n+      start_depth--;\n+      (*frame_count)--;\n+    }\n+  \n+  // Now check to see if the array supplied by the agent is large enough to\n+  // hold frame_count frames, after adjustment for start_depth.\n+  if ((*frame_count) > max_frames)\n+    (*frame_count) = max_frames;\n+  \n+  for (int i = 0; i < (*frame_count); i++)\n+    {\n+      frames[i].method = frame->self->get_method ();\n+      \n+      // Set the location in the frame, native frames have location = -1\n+      if (frame->frame_type == frame_interpreter)\n+        {\n+          _Jv_InterpMethod *imeth \n+            = static_cast<_Jv_InterpMethod *> (frame->self);\n+          _Jv_InterpFrame *interp_frame \n+            = static_cast<_Jv_InterpFrame *> (frame);\n+          frames[i].location = imeth->insn_index (interp_frame->pc);\n+        }\n+      else\n+        frames[i].location = -1;\n+        \n+      frame = frame->next;\n+    }\n+    \n+  return JVMTI_ERROR_NONE;\n+}\n+\n static jvmtiError JNICALL\n _Jv_JVMTI_ForceGarbageCollection (MAYBE_UNUSED jvmtiEnv *env)\n {\n@@ -1484,7 +1588,7 @@ struct _Jv_jvmtiEnv _Jv_JVMTI_Interface =\n   UNIMPLEMENTED,\t\t// GetTopThreadGroups\n   UNIMPLEMENTED,\t\t// GetThreadGroupInfo\n   UNIMPLEMENTED,\t\t// GetThreadGroupChildren\n-  UNIMPLEMENTED,\t\t// GetFrameCount\n+  _Jv_JVMTI_GetFrameCount,\t\t// GetFrameCount\n   UNIMPLEMENTED,\t\t// GetThreadState\n   RESERVED,\t\t\t// reserved18\n   UNIMPLEMENTED,\t\t// GetFrameLocation\n@@ -1572,7 +1676,7 @@ struct _Jv_jvmtiEnv _Jv_JVMTI_Interface =\n   UNIMPLEMENTED,\t\t// GetThreadListStackTraces\n   UNIMPLEMENTED,\t\t// GetThreadLocalStorage\n   UNIMPLEMENTED,\t\t// SetThreadLocalStorage\n-  UNIMPLEMENTED,\t\t// GetStackTrace\n+  _Jv_JVMTI_GetStackTrace,\t\t// GetStackTrace\n   RESERVED,\t\t\t// reserved105\n   UNIMPLEMENTED,\t\t// GetTag\n   UNIMPLEMENTED,\t\t// SetTag"}, {"sha": "c3fbdf4e6a43ae6b8095fa30bfd45ae0a163ac52", "filename": "libjava/stacktrace.cc", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/392731311776d30b0910e51a5bc2aef070a9fc8b/libjava%2Fstacktrace.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/392731311776d30b0910e51a5bc2aef070a9fc8b/libjava%2Fstacktrace.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fstacktrace.cc?ref=392731311776d30b0910e51a5bc2aef070a9fc8b", "patch": "@@ -131,9 +131,11 @@ _Jv_StackTrace::UnwindTraceFn (struct _Unwind_Context *context, void *state_ptr)\n   if (func_addr == UNWRAP_FUNCTION_DESCRIPTOR (interp_run))\n     {\n       state->frames[pos].type = frame_interpreter;\n-      state->frames[pos].interp.meth = state->interp_frame->self;\n+      _Jv_Frame *frame = static_cast<_Jv_Frame *> (state->interp_frame);\n+      state->frames[pos].interp.meth \n+        = static_cast<_Jv_InterpMethod *> (frame->self);\n       state->frames[pos].interp.pc = state->interp_frame->pc;\n-      state->interp_frame = state->interp_frame->next;\n+      state->interp_frame = state->interp_frame->next_interp;\n     }\n   else \n #endif\n@@ -143,7 +145,7 @@ _Jv_StackTrace::UnwindTraceFn (struct _Unwind_Context *context, void *state_ptr)\n       state->frames[pos].type = frame_proxy;\n       state->frames[pos].proxyClass = state->interp_frame->proxyClass;\n       state->frames[pos].proxyMethod = state->interp_frame->proxyMethod;\n-      state->interp_frame = state->interp_frame->next;\n+      state->interp_frame = state->interp_frame->next_interp;\n     }\n   else \n     {"}, {"sha": "6e5e8774e253fbd3d4d94dfdbd41215b23b40fd2", "filename": "libjava/testsuite/libjava.jvmti/interp/getstacktrace.h", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/392731311776d30b0910e51a5bc2aef070a9fc8b/libjava%2Ftestsuite%2Flibjava.jvmti%2Finterp%2Fgetstacktrace.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/392731311776d30b0910e51a5bc2aef070a9fc8b/libjava%2Ftestsuite%2Flibjava.jvmti%2Finterp%2Fgetstacktrace.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.jvmti%2Finterp%2Fgetstacktrace.h?ref=392731311776d30b0910e51a5bc2aef070a9fc8b", "patch": "@@ -0,0 +1,21 @@\n+/* DO NOT EDIT THIS FILE - it is machine generated */\n+\n+#ifndef __getstacktrace__\n+#define __getstacktrace__\n+\n+#include <jni.h>\n+\n+#ifdef __cplusplus\n+extern \"C\"\n+{\n+#endif\n+\n+JNIEXPORT void JNICALL Java_getstacktrace_natPlaceholder (JNIEnv *env, jobject);\n+JNIEXPORT void JNICALL Java_getstacktrace_natRunner (JNIEnv *env, jobject);\n+JNIEXPORT jint JNICALL Java_getstacktrace_do_1getstacktrace_1tests (JNIEnv *env, jclass, jobjectArray);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif /* __getstacktrace__ */"}, {"sha": "14b084a4de11b88f063a3ecea605f2d7e8705be4", "filename": "libjava/testsuite/libjava.jvmti/interp/getstacktrace.jar", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/392731311776d30b0910e51a5bc2aef070a9fc8b/libjava%2Ftestsuite%2Flibjava.jvmti%2Finterp%2Fgetstacktrace.jar", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/392731311776d30b0910e51a5bc2aef070a9fc8b/libjava%2Ftestsuite%2Flibjava.jvmti%2Finterp%2Fgetstacktrace.jar", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.jvmti%2Finterp%2Fgetstacktrace.jar?ref=392731311776d30b0910e51a5bc2aef070a9fc8b"}, {"sha": "21a21f0fbb10765e67757e276adf22b12419434e", "filename": "libjava/testsuite/libjava.jvmti/interp/getstacktrace.java", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/392731311776d30b0910e51a5bc2aef070a9fc8b/libjava%2Ftestsuite%2Flibjava.jvmti%2Finterp%2Fgetstacktrace.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/392731311776d30b0910e51a5bc2aef070a9fc8b/libjava%2Ftestsuite%2Flibjava.jvmti%2Finterp%2Fgetstacktrace.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.jvmti%2Finterp%2Fgetstacktrace.java?ref=392731311776d30b0910e51a5bc2aef070a9fc8b", "patch": "@@ -0,0 +1,88 @@\n+public class getstacktrace\n+  extends Thread\n+{\n+  public boolean done = false;\n+\n+  // num_frames is the number of frames > the original run () call so if\n+  // num_frames = 1, the thread will have 2 frames, the original Thread.run\n+  // call, plus one additional\n+  public int num_frames, thread_num;\n+\n+  public static int num_threads = 1;\n+\n+  static\n+    {\n+      System.loadLibrary(\"natgetstacktrace\");\n+    }\n+\n+  public void run ()\n+  {\n+    thread_num = num_threads++;\n+    num_frames = thread_num;\n+\n+    if (num_frames <= 1)\n+      {\n+        natRunner ();\n+      }\n+    else\n+      {\n+        if (thread_num % 2 == 0)\n+          natPlaceholder ();\n+        else\n+          placeholder ();\n+      }\n+  }\n+\n+  public void placeholder ()\n+  {\n+    num_frames--;\n+    if (num_frames <= 1)\n+      {\n+        if (thread_num % 2 == 1)\n+          natRunner ();\n+        else\n+          runner ();\n+      }\n+    else\n+      {\n+        if (thread_num % 2 == 0)\n+          natPlaceholder ();\n+        else\n+          placeholder ();\n+      }\n+  }\n+  \n+  public void runner ()\n+  {\n+    done = true;\n+    while (done)\n+      yield ();\n+  }\n+\n+  public native void natPlaceholder ();\n+  public native void natRunner ();\n+\n+  public static native int do_getstacktrace_tests (Thread[] threads);\n+\n+  public static void main (String[] args)\n+  {\n+    System.out.println (\"JVMTI GetStackTrace Interpreted Test\");\n+\n+    getstacktrace[] threads = new getstacktrace[10];\n+\n+    for (int i = 0; i < threads.length; i++)\n+      {\n+        threads[i] = new getstacktrace ();\n+        threads[i].start ();\n+        while (!threads[i].done)\n+          yield ();\n+      }\n+\n+    do_getstacktrace_tests (threads);\n+\n+    for (int i = 0; i < threads.length; i++)\n+      {\n+        threads[i].done = false;\n+      }\n+  }\n+}"}, {"sha": "5134e6eab78ed464bb5c4382409a6fb08e18baad", "filename": "libjava/testsuite/libjava.jvmti/interp/getstacktrace.out", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/392731311776d30b0910e51a5bc2aef070a9fc8b/libjava%2Ftestsuite%2Flibjava.jvmti%2Finterp%2Fgetstacktrace.out", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/392731311776d30b0910e51a5bc2aef070a9fc8b/libjava%2Ftestsuite%2Flibjava.jvmti%2Finterp%2Fgetstacktrace.out", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.jvmti%2Finterp%2Fgetstacktrace.out?ref=392731311776d30b0910e51a5bc2aef070a9fc8b", "patch": "@@ -0,0 +1,76 @@\n+JVMTI GetStackTrace Interpreted Test\n+Thread has 2 frames\n+Frame 0 is native\n+Frame 1 is interpreted\n+Thread has 3 frames\n+Frame 0 is interpreted\n+Frame 1 is native\n+Frame 2 is interpreted\n+Thread has 4 frames\n+Frame 0 is native\n+Frame 1 is interpreted\n+Frame 2 is interpreted\n+Frame 3 is interpreted\n+Thread has 5 frames\n+Frame 0 is interpreted\n+Frame 1 is native\n+Frame 2 is native\n+Frame 3 is native\n+Frame 4 is interpreted\n+Thread has 6 frames\n+Frame 0 is native\n+Frame 1 is interpreted\n+Frame 2 is interpreted\n+Frame 3 is interpreted\n+Frame 4 is interpreted\n+Frame 5 is interpreted\n+Thread has 7 frames\n+Frame 0 is interpreted\n+Frame 1 is native\n+Frame 2 is native\n+Frame 3 is native\n+Frame 4 is native\n+Frame 5 is native\n+Frame 6 is interpreted\n+Thread has 8 frames\n+Frame 0 is native\n+Frame 1 is interpreted\n+Frame 2 is interpreted\n+Frame 3 is interpreted\n+Frame 4 is interpreted\n+Frame 5 is interpreted\n+Frame 6 is interpreted\n+Frame 7 is interpreted\n+Thread has 9 frames\n+Frame 0 is interpreted\n+Frame 1 is native\n+Frame 2 is native\n+Frame 3 is native\n+Frame 4 is native\n+Frame 5 is native\n+Frame 6 is native\n+Frame 7 is native\n+Frame 8 is interpreted\n+Thread has 10 frames\n+Frame 0 is native\n+Frame 1 is interpreted\n+Frame 2 is interpreted\n+Frame 3 is interpreted\n+Frame 4 is interpreted\n+Frame 5 is interpreted\n+Frame 6 is interpreted\n+Frame 7 is interpreted\n+Frame 8 is interpreted\n+Frame 9 is interpreted\n+Thread has 11 frames\n+Frame 0 is interpreted\n+Frame 1 is native\n+Frame 2 is native\n+Frame 3 is native\n+Frame 4 is native\n+Frame 5 is native\n+Frame 6 is native\n+Frame 7 is native\n+Frame 8 is native\n+Frame 9 is native\n+Frame 10 is interpreted"}, {"sha": "e2c88ada40c4720849c6949e4a02e4d500808df2", "filename": "libjava/testsuite/libjava.jvmti/interp/natgetstacktrace.cc", "status": "added", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/392731311776d30b0910e51a5bc2aef070a9fc8b/libjava%2Ftestsuite%2Flibjava.jvmti%2Finterp%2Fnatgetstacktrace.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/392731311776d30b0910e51a5bc2aef070a9fc8b/libjava%2Ftestsuite%2Flibjava.jvmti%2Finterp%2Fnatgetstacktrace.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.jvmti%2Finterp%2Fnatgetstacktrace.cc?ref=392731311776d30b0910e51a5bc2aef070a9fc8b", "patch": "@@ -0,0 +1,144 @@\n+#include <jni.h>\n+\n+#include <jvmti.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+#include <unistd.h>\n+\n+#include \"getstacktrace.h\"\n+\n+void\n+printStackTrace (jvmtiFrameInfo *frames, jint frame_cnt)\n+{\n+  printf (\"Thread has %d frames\\n\", static_cast<int> (frame_cnt));\n+\n+  for (int i = 0; i < frame_cnt; i++)\n+    {\n+      jmethodID method = frames[i].method;\n+      jlocation location = frames[i].location;\n+\n+      if (location == -1)\n+        {\n+          printf (\"Frame %d is native\\n\", i);\n+        }\n+      else\n+        {\n+          printf (\"Frame %d is interpreted\\n\", i);\n+        }\n+    }\n+}\n+\n+\n+JNIEXPORT void JNICALL Java_getstacktrace_natPlaceholder (JNIEnv *env, jobject obj)\n+{\n+  jclass klass = env->GetObjectClass (obj);\n+  jfieldID done_id = env->GetFieldID (klass, \"done\", \"Z\");\n+  jfieldID num_frames_id = env->GetFieldID (klass, \"num_frames\", \"I\");\n+  jfieldID thread_num_id = env->GetFieldID (klass, \"thread_num\", \"I\");\n+\n+  // num_frames--\n+  jint n_frames = env->GetIntField (obj, num_frames_id);\n+  n_frames--;\n+  env->SetIntField (obj, num_frames_id, n_frames);\n+\n+  jint t_num = env->GetIntField (obj, thread_num_id);\n+\n+  if (n_frames <= 1)\n+    {\n+      if (t_num % 2 == 1)\n+        {\n+          jmethodID natRunner_id = env->GetMethodID (klass, \"natRunner\", \"()V\");\n+          env->CallVoidMethod (obj, natRunner_id);\n+        }\n+      else\n+        {\n+          jmethodID runner_id = env->GetMethodID (klass, \"runner\", \"()V\");\n+          env->CallVoidMethod (obj, runner_id);\n+        }\n+    }\n+  else\n+    {\n+      if (t_num % 2 == 0)\n+        {\n+          jmethodID natPlaceholder_id = env->GetMethodID (klass,\n+                                        \"natPlaceholder\",\n+                                        \"()V\");\n+          env->CallVoidMethod (obj, natPlaceholder_id);\n+        }\n+      else\n+        {\n+          jmethodID placeholder_id = env->GetMethodID (klass, \"placeholder\",\n+                                     \"()V\");\n+          env->CallVoidMethod (obj, placeholder_id);\n+        }\n+    }\n+}\n+\n+JNIEXPORT void JNICALL Java_getstacktrace_natRunner (JNIEnv *env, jobject obj)\n+{\n+  jclass klass = env->GetObjectClass (obj);\n+  jfieldID done_id = env->GetFieldID (klass, \"done\", \"Z\");\n+\n+\n+  jboolean done;\n+  done = true;\n+  env->SetBooleanField (obj, done_id, done);\n+\n+  do\n+    {\n+      done = env->GetBooleanField (obj, done_id);\n+      if (done == false)\n+        break;\n+      usleep (10);\n+    }\n+  while (done != false);\n+}\n+\n+JNIEXPORT jint JNICALL Java_getstacktrace_do_1getstacktrace_1tests\n+(JNIEnv *env, jclass klass, jobjectArray thr_arr)\n+{\n+  JavaVM *vm;\n+  jint err = env->GetJavaVM (&vm);\n+  if (err < 0)\n+    {\n+      fprintf (stderr, \"error getting VM\\n\");\n+      exit (1);\n+    }\n+\n+  jvmtiEnv *jvmti = NULL;\n+  vm->GetEnv ((void **) &jvmti, JVMTI_VERSION_1_0);\n+\n+  if (jvmti == NULL)\n+    {\n+      fprintf (stderr, \"error getting jvmti environment\\n\");\n+      exit (1);\n+    }\n+\n+  jint frame_cnt;\n+  jvmtiFrameInfo frames[30];\n+\n+  jvmtiError jerr;\n+  jthread thr;\n+\n+  jsize num_threads = env->GetArrayLength (thr_arr);\n+\n+  for (int i = 0; i < num_threads; i++)\n+    {\n+      thr = reinterpret_cast<jthread>\n+            (env->GetObjectArrayElement (thr_arr, static_cast<jsize> (i)));\n+      fflush (stdout);\n+      jerr = jvmti->GetStackTrace (thr, 0, 30, frames, &frame_cnt);\n+      if (jerr != JVMTI_ERROR_NONE)\n+        {\n+          char *error_name;\n+          jvmti->GetErrorName (jerr, &error_name);\n+          fprintf (stderr, \"JVMTI Error: %s\\n\", error_name);\n+          jvmti->Deallocate (reinterpret_cast<unsigned char *> (error_name));\n+        }\n+      else\n+        {\n+          printStackTrace (frames, frame_cnt);\n+        }\n+    }\n+}"}]}