{"sha": "3b70b82ab91b33eaa01866cce11853ff60ad780c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2I3MGI4MmFiOTFiMzNlYWEwMTg2NmNjZTExODUzZmY2MGFkNzgwYw==", "commit": {"author": {"name": "Dale Johannesen", "email": "dalej@gcc.gnu.org", "date": "2005-01-31T18:00:52Z"}, "committer": {"name": "Dale Johannesen", "email": "dalej@gcc.gnu.org", "date": "2005-01-31T18:00:52Z"}, "message": "re PR middle-end/19650 (miscompiling of array acess of (int)(a==2))\n\n2005-01-31  Roger Sayle  <roger@eyesopen.com>\n\t    Dale Johannesen  <dalej@apple.com>\n\n\tPR middle-end/19650\n\t* fold-const.c (fold_binary_op_with_conditional_arg):\n\tMake types match original operands, before STRIP_NOPS.\n\nFrom-SVN: r94485", "tree": {"sha": "c1d172e58eba26c1ee44c265c85f4c1494fbb719", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c1d172e58eba26c1ee44c265c85f4c1494fbb719"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3b70b82ab91b33eaa01866cce11853ff60ad780c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b70b82ab91b33eaa01866cce11853ff60ad780c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b70b82ab91b33eaa01866cce11853ff60ad780c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b70b82ab91b33eaa01866cce11853ff60ad780c/comments", "author": null, "committer": null, "parents": [{"sha": "c0736a9ddbfc1651bd3c5602cccade4e9f69f3bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0736a9ddbfc1651bd3c5602cccade4e9f69f3bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0736a9ddbfc1651bd3c5602cccade4e9f69f3bd"}], "stats": {"total": 112, "additions": 103, "deletions": 9}, "files": [{"sha": "132be3f9e6805a186bfcaad75db9b746967affa0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b70b82ab91b33eaa01866cce11853ff60ad780c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b70b82ab91b33eaa01866cce11853ff60ad780c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3b70b82ab91b33eaa01866cce11853ff60ad780c", "patch": "@@ -1,3 +1,10 @@\n+2005-01-31  Roger Sayle  <roger@eyesopen.com>\n+\t    Dale Johannesen  <dalej@apple.com>\n+\n+\tPR middle-end/19650\n+\t* fold-const.c (fold_binary_op_with_conditional_arg):\n+\tMake types match original operands, before STRIP_NOPS.\n+\n 2005-01-31  Alan Modra  <amodra@bigpond.net.au>\n \n \t* config/rs6000/linux-unwind.h (struct gcc_vregs): New."}, {"sha": "13c57e0ba6aea8a3be4e336fba0f93f9fae697c9", "filename": "gcc/fold-const.c", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b70b82ab91b33eaa01866cce11853ff60ad780c/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b70b82ab91b33eaa01866cce11853ff60ad780c/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=3b70b82ab91b33eaa01866cce11853ff60ad780c", "patch": "@@ -121,8 +121,8 @@ static tree optimize_minmax_comparison (tree);\n static tree extract_muldiv (tree, tree, enum tree_code, tree);\n static tree extract_muldiv_1 (tree, tree, enum tree_code, tree);\n static int multiple_of_p (tree, tree, tree);\n-static tree fold_binary_op_with_conditional_arg (enum tree_code, tree, tree,\n-\t\t\t\t\t\t tree, int);\n+static tree fold_binary_op_with_conditional_arg (tree, enum tree_code, \n+\t\t\t\t\t\t tree, tree, int);\n static bool fold_real_zero_addition_p (tree, tree, int);\n static tree fold_mathfn_compare (enum built_in_function, enum tree_code,\n \t\t\t\t tree, tree, tree);\n@@ -5435,9 +5435,14 @@ extract_array_ref (tree expr, tree *base, tree *offset)\n    possible.  */\n \n static tree\n-fold_binary_op_with_conditional_arg (enum tree_code code, tree type,\n-\t\t\t\t     tree cond, tree arg, int cond_first_p)\n+fold_binary_op_with_conditional_arg (tree t, enum tree_code code, tree cond,\n+\t\t\t\t     tree arg, int cond_first_p)\n {\n+  const tree type = TREE_TYPE (t);\n+  tree cond_type = cond_first_p ? TREE_TYPE (TREE_OPERAND (t, 0)) \n+\t\t\t\t: TREE_TYPE (TREE_OPERAND (t, 1));\n+  tree arg_type = cond_first_p ? TREE_TYPE (TREE_OPERAND (t, 1)) \n+\t\t\t       : TREE_TYPE (TREE_OPERAND (t, 0));\n   tree test, true_value, false_value;\n   tree lhs = NULL_TREE;\n   tree rhs = NULL_TREE;\n@@ -5469,12 +5474,19 @@ fold_binary_op_with_conditional_arg (enum tree_code code, tree type,\n       false_value = constant_boolean_node (false, testtype);\n     }\n \n+  arg = fold_convert (arg_type, arg);\n   if (lhs == 0)\n-    lhs = fold (cond_first_p ? build2 (code, type, true_value, arg)\n+    {\n+      true_value = fold_convert (cond_type, true_value);\n+      lhs = fold (cond_first_p ? build2 (code, type, true_value, arg)\n \t\t\t     : build2 (code, type, arg, true_value));\n+    }\n   if (rhs == 0)\n-    rhs = fold (cond_first_p ? build2 (code, type, false_value, arg)\n+    {\n+      false_value = fold_convert (cond_type, false_value);\n+      rhs = fold (cond_first_p ? build2 (code, type, false_value, arg)\n \t\t\t     : build2 (code, type, arg, false_value));\n+    }\n \n   test = fold (build3 (COND_EXPR, type, test, lhs, rhs));\n   return fold_convert (type, test);\n@@ -6516,16 +6528,16 @@ fold (tree expr)\n \n       if (TREE_CODE (arg0) == COND_EXPR || COMPARISON_CLASS_P (arg0))\n \t{\n-\t  tem = fold_binary_op_with_conditional_arg (code, type, arg0, arg1,\n+\t  tem = fold_binary_op_with_conditional_arg (t, code, arg0, arg1, \n \t\t\t\t\t\t     /*cond_first_p=*/1);\n \t  if (tem != NULL_TREE)\n \t    return tem;\n \t}\n \n       if (TREE_CODE (arg1) == COND_EXPR || COMPARISON_CLASS_P (arg1))\n \t{\n-\t  tem = fold_binary_op_with_conditional_arg (code, type, arg1, arg0,\n-\t\t\t\t\t\t     /*cond_first_p=*/0);\n+\t  tem = fold_binary_op_with_conditional_arg (t, code, arg1, arg0, \n+\t\t\t\t\t             /*cond_first_p=*/0);\n \t  if (tem != NULL_TREE)\n \t    return tem;\n \t}"}, {"sha": "cc1f201465d5badc0949896d4747aba11404980c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b70b82ab91b33eaa01866cce11853ff60ad780c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b70b82ab91b33eaa01866cce11853ff60ad780c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3b70b82ab91b33eaa01866cce11853ff60ad780c", "patch": "@@ -1,3 +1,7 @@\n+2005-01-31  Dale Johannesen  <dalej@apple.com>\n+\n+\t* g++.dg/opt/pr19650.C:  New test.\n+\n 2005-01-31  Richard Henderson  <rth@redhat.com>\n \n \t* gcc.c-torture/execute/ieee/copysign1.c: Special case sizeof"}, {"sha": "3a8d4b8c26956d6fbbefaf87bd958bd0024816d5", "filename": "gcc/testsuite/g++.dg/opt/pr19650.C", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b70b82ab91b33eaa01866cce11853ff60ad780c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr19650.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b70b82ab91b33eaa01866cce11853ff60ad780c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr19650.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr19650.C?ref=3b70b82ab91b33eaa01866cce11853ff60ad780c", "patch": "@@ -0,0 +1,71 @@\n+// { dg-options \"-O1\" }\n+// { dg-do \"run\" }\n+// Tests the fold bug described in PR 19650.\n+#include <stdio.h>\n+#include <stdlib.h>\n+#define test(a) ((a) ? 1 : 0)\n+\n+typedef int (*arg_cmp_func)();\n+\n+class Item_func \n+{\n+public:\n+    enum Functype { UNKNOWN_FUNC, EQ_FUNC, EQUAL_FUNC };\n+    virtual enum Functype functype() const { return UNKNOWN_FUNC; }\n+};\n+\n+class Item_bool_func2 : public Item_func\n+{\n+public:\n+    virtual enum Functype functype() const { return EQUAL_FUNC; }\n+};\n+\n+class Arg_comparator \n+{\n+public:\n+    Item_bool_func2 *owner;\n+    arg_cmp_func func;\n+    static arg_cmp_func comparator_matrix[4][2];\n+\n+    int Arg_comparator::set_compare_func(Item_bool_func2 *item, int type)\n+    {\n+        owner = item;\n+\n+        /****************** problematic line is here ************************/\n+\n+        func = comparator_matrix[type][test(owner->functype() == Item_func::EQUAL_FUNC)];\n+        return 0;\n+    }\n+};\n+\n+int compare_string() { return 0; }\n+int compare_e_string() { return 0; }\n+int compare_real() { return 0; }\n+int compare_e_real() { return 0; }\n+int compare_int_signed() { return 0; }\n+int compare_e_int() { return 0; }\n+int compare_row() { return 0; }\n+int compare_e_row() { return 0; }\n+\n+arg_cmp_func Arg_comparator::comparator_matrix[4][2] =\n+    {{&compare_string,     &compare_e_string},\n+     {&compare_real,       &compare_e_real},\n+     {&compare_int_signed, &compare_e_int},\n+     {&compare_row,        &compare_e_row}};\n+\n+void myfunc (const char*p, arg_cmp_func f1, arg_cmp_func f2) __attribute__((noinline));\n+void myfunc (const char*p, arg_cmp_func f1, arg_cmp_func f2)\n+{\n+    if (f1!=f2)\n+      abort ();\n+}\n+\n+int main()\n+{\n+    Arg_comparator cmp;\n+    Item_bool_func2 equal_func;\n+\n+    cmp.set_compare_func(&equal_func, 0);\n+    myfunc(\"cmp.func is %p (expected %p)\\n\", cmp.func, &compare_e_string);\n+}\n+"}]}