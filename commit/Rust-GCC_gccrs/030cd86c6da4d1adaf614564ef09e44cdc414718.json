{"sha": "030cd86c6da4d1adaf614564ef09e44cdc414718", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDMwY2Q4NmM2ZGE0ZDFhZGFmNjE0NTY0ZWYwOWU0NGNkYzQxNDcxOA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-10-26T20:10:03Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-10-26T20:10:03Z"}, "message": "lto.c (add_cgraph_node_to_partition, [...]): Add debug info.\n\n\n\t* lto.c (add_cgraph_node_to_partition,\n\tadd_varpool_node_to_partition): Add debug info.\n\t(lto_1_to_1_map, lto_balanced_map): Do not re-add already\n\tpartitioned nodes.\n\t(do_whole_program_analysis): Set function flags before dumping.\n\nFrom-SVN: r165984", "tree": {"sha": "9306f3b7f4e264560856b09fde7129b8a17ef417", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9306f3b7f4e264560856b09fde7129b8a17ef417"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/030cd86c6da4d1adaf614564ef09e44cdc414718", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/030cd86c6da4d1adaf614564ef09e44cdc414718", "html_url": "https://github.com/Rust-GCC/gccrs/commit/030cd86c6da4d1adaf614564ef09e44cdc414718", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/030cd86c6da4d1adaf614564ef09e44cdc414718/comments", "author": null, "committer": null, "parents": [{"sha": "859b9bfa86424f77efc86bb866cd0dace8148361", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/859b9bfa86424f77efc86bb866cd0dace8148361", "html_url": "https://github.com/Rust-GCC/gccrs/commit/859b9bfa86424f77efc86bb866cd0dace8148361"}], "stats": {"total": 42, "additions": 33, "deletions": 9}, "files": [{"sha": "e718fdbf458fd9ac5adb58752cd566ac64ce8452", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/030cd86c6da4d1adaf614564ef09e44cdc414718/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/030cd86c6da4d1adaf614564ef09e44cdc414718/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=030cd86c6da4d1adaf614564ef09e44cdc414718", "patch": "@@ -1,3 +1,11 @@\n+2010-10-22  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto.c (add_cgraph_node_to_partition,\n+\tadd_varpool_node_to_partition): Add debug info.\n+\t(lto_1_to_1_map, lto_balanced_map): Do not re-add already\n+\tpartitioned nodes.\n+\t(do_whole_program_analysis): Set function flags before dumping.\n+\n 2010-10-22  Richard Guenther  <rguenther@suse.de>\n \n \t* lto.c (lto_fixup_type): Fixup TYPE_CANONICAL again, via"}, {"sha": "0516efea4ce78f8123579ce1dd39568dbf662b58", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/030cd86c6da4d1adaf614564ef09e44cdc414718/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/030cd86c6da4d1adaf614564ef09e44cdc414718/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=030cd86c6da4d1adaf614564ef09e44cdc414718", "patch": "@@ -760,7 +760,12 @@ add_cgraph_node_to_partition (ltrans_partition part, struct cgraph_node *node)\n   part->insns += node->local.inline_summary.self_size;\n \n   if (node->aux)\n-    node->in_other_partition = 1;\n+    {\n+      node->in_other_partition = 1;\n+      if (cgraph_dump_file)\n+        fprintf (cgraph_dump_file, \"Node %s/%i now used in multiple partitions\\n\",\n+\t\t cgraph_node_name (node), node->uid);\n+    }\n   node->aux = (void *)((size_t)node->aux + 1);\n \n   cgraph_node_set_add (part->cgraph_set, node);\n@@ -785,7 +790,12 @@ add_varpool_node_to_partition (ltrans_partition part, struct varpool_node *vnode\n   varpool_node_set_add (part->varpool_set, vnode);\n \n   if (vnode->aux)\n-    vnode->in_other_partition = 1;\n+    {\n+      vnode->in_other_partition = 1;\n+      if (cgraph_dump_file)\n+        fprintf (cgraph_dump_file, \"Varpool node %s now used in multiple partitions\\n\",\n+\t\t varpool_node_name (vnode));\n+    }\n   vnode->aux = (void *)((size_t)vnode->aux + 1);\n \n   add_references_to_partition (part, &vnode->ref_list);\n@@ -856,6 +866,7 @@ partition_varpool_node_p (struct varpool_node *vnode)\n   /* Constant pool and comdat are always only in partitions they are needed.  */\n   if (DECL_IN_CONSTANT_POOL (vnode->decl)\n       || (DECL_COMDAT (vnode->decl)\n+\t  && !vnode->force_output\n \t  && !varpool_used_from_object_file_p (vnode)))\n     return false;\n   return true;\n@@ -911,7 +922,8 @@ lto_1_to_1_map (void)\n \t  npartitions++;\n \t}\n \n-      add_cgraph_node_to_partition (partition, node);\n+      if (!node->aux)\n+        add_cgraph_node_to_partition (partition, node);\n     }\n \n   for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n@@ -930,7 +942,8 @@ lto_1_to_1_map (void)\n \t  npartitions++;\n \t}\n \n-      add_varpool_node_to_partition (partition, vnode);\n+      if (!vnode->aux)\n+        add_varpool_node_to_partition (partition, vnode);\n     }\n   for (node = cgraph_nodes; node; node = node->next)\n     node->aux = NULL;\n@@ -1005,6 +1018,8 @@ lto_balanced_map (void)\n     INT_MAX, best_internal = 0;\n   int npartitions;\n \n+  for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n+    gcc_assert (!vnode->aux);\n   /* Until we have better ordering facility, use toplogical order.\n      Include only nodes we will partition and compute estimate of program\n      size.  Note that since nodes that are not partitioned might be put into\n@@ -1034,7 +1049,8 @@ lto_balanced_map (void)\n \n   for (i = 0; i < n_nodes; i++)\n     {\n-      add_cgraph_node_to_partition (partition, order[i]);\n+      if (!order[i]->aux)\n+        add_cgraph_node_to_partition (partition, order[i]);\n       total_size -= order[i]->global.size;\n \n       /* Once we added a new node to the partition, we also want to add\n@@ -1198,8 +1214,8 @@ lto_balanced_map (void)\n \t  best_total_size = total_size;\n \t}\n       if (cgraph_dump_file)\n-\tfprintf (cgraph_dump_file, \"Step %i: added %s, size %i, cost %i/%i best %i/%i, step %i\\n\", i,\n-\t\t cgraph_node_name (order[i]), partition->insns, cost, internal,\n+\tfprintf (cgraph_dump_file, \"Step %i: added %s/%i, size %i, cost %i/%i best %i/%i, step %i\\n\", i,\n+\t\t cgraph_node_name (order[i]), order[i]->uid, partition->insns, cost, internal,\n \t\t best_cost, best_internal, best_i);\n       /* Partition is too large, unwind into step when best cost was reached and\n \t start new partition.  */\n@@ -2314,13 +2330,13 @@ do_whole_program_analysis (void)\n       dump_memory_report (false);\n     }\n \n+  cgraph_function_flags_ready = true;\n+\n   if (cgraph_dump_file)\n     {\n       dump_cgraph (cgraph_dump_file);\n       dump_varpool (cgraph_dump_file);\n     }\n-\n-  cgraph_function_flags_ready = true;\n   bitmap_obstack_initialize (NULL);\n   ipa_register_cgraph_hooks ();\n   cgraph_state = CGRAPH_STATE_IPA_SSA;"}]}