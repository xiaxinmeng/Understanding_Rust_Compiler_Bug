{"sha": "903ff2758bdad932eee6ae84539361c18e6c45e9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTAzZmYyNzU4YmRhZDkzMmVlZTZhZTg0NTM5MzYxYzE4ZTZjNDVlOQ==", "commit": {"author": {"name": "Andrew Pinski", "email": "andrew_pinski@playstation.sony.com", "date": "2006-11-20T20:29:10Z"}, "committer": {"name": "Andrew Pinski", "email": "pinskia@gcc.gnu.org", "date": "2006-11-20T20:29:10Z"}, "message": "re PR target/25500 (SSE2 vectorized code is slower on 4.x.x than previous)\n\n2006-11-20  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n\n        PR tree-opt/25500\n        * tree-sra.c (single_scalar_field_in_record_p): New function.\n        (decide_block_copy): Use it.\n\n2006-11-20  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n\n        PR tree-opt/25500\n        * gcc.dg/tree-ssa/sra-4.c: New testcase.\n\nFrom-SVN: r119026", "tree": {"sha": "1853b5cc64ec5dcfeca725acbdb5d00dda2bf7f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1853b5cc64ec5dcfeca725acbdb5d00dda2bf7f2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/903ff2758bdad932eee6ae84539361c18e6c45e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/903ff2758bdad932eee6ae84539361c18e6c45e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/903ff2758bdad932eee6ae84539361c18e6c45e9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/903ff2758bdad932eee6ae84539361c18e6c45e9/comments", "author": null, "committer": null, "parents": [{"sha": "d7043acd94f8d8d6c93465ca4a98d07e5a2fb163", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7043acd94f8d8d6c93465ca4a98d07e5a2fb163", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7043acd94f8d8d6c93465ca4a98d07e5a2fb163"}], "stats": {"total": 67, "additions": 67, "deletions": 0}, "files": [{"sha": "2a6a7e276cc8e20e556d91abc6f4697768ffdc6a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/903ff2758bdad932eee6ae84539361c18e6c45e9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/903ff2758bdad932eee6ae84539361c18e6c45e9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=903ff2758bdad932eee6ae84539361c18e6c45e9", "patch": "@@ -1,3 +1,9 @@\n+2006-11-20  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\tPR tree-opt/25500\n+\t* tree-sra.c (single_scalar_field_in_record_p): New function.\n+\t(decide_block_copy): Use it.\n+\n 2006-11-20  David Daney  <ddaney@avtrex.com>\n \n \t* config/mips/linux-unwind.h (mips_fallback_frame_state): Adjust"}, {"sha": "57ce15b1a88a17fdd20044b975a0824c9267f5d9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/903ff2758bdad932eee6ae84539361c18e6c45e9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/903ff2758bdad932eee6ae84539361c18e6c45e9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=903ff2758bdad932eee6ae84539361c18e6c45e9", "patch": "@@ -1,3 +1,8 @@\n+2006-11-20  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\tPR tree-opt/25500\n+\t* gcc.dg/tree-ssa/sra-4.c: New testcase.\n+\n 2006-11-20  Tobias Burnus  <burnus@net-b.de>\n \n \t* gfortran.dg/volatile3.f90: Add conflict test."}, {"sha": "6fdf37ffb34cdd5e7ed92e87a302a1f67d688502", "filename": "gcc/testsuite/gcc.dg/tree-ssa/sra-4.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/903ff2758bdad932eee6ae84539361c18e6c45e9/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fsra-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/903ff2758bdad932eee6ae84539361c18e6c45e9/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fsra-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fsra-4.c?ref=903ff2758bdad932eee6ae84539361c18e6c45e9", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O1 -fdump-tree-optimized -w\" } */\n+/* Check that SRA does non block copies for structs that just contain vectors. */\n+\n+#define vector __attribute__((vector_size(16)))\n+\n+struct vt\n+{\n+  vector int t;\n+};\n+\n+\n+vector int f(vector int t1, vector int t2)\n+{\n+  struct vt st1, st2, st3;\n+  st1.t = t1;\n+  st2 = st1;\n+  st2.t += t2;\n+  st3 = st2;\n+  return st3.t;\n+}\n+\n+/* There should be no references to st as SRA should not have done block copy. */\n+/* { dg-final { scan-tree-dump-times \"st\" 0 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */\n+"}, {"sha": "a5ed161ed3e9d1260c5867fc2856ef808fc70947", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/903ff2758bdad932eee6ae84539361c18e6c45e9/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/903ff2758bdad932eee6ae84539361c18e6c45e9/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=903ff2758bdad932eee6ae84539361c18e6c45e9", "patch": "@@ -1351,6 +1351,32 @@ instantiate_missing_elements (struct sra_elt *elt)\n     }\n }\n \n+/* Return true if there is only one non aggregate field in the record, TYPE.\n+   Return false otherwise.  */\n+\n+static bool\n+single_scalar_field_in_record_p (tree type)\n+{\n+   int num_fields = 0;\n+   tree field;\n+   if (TREE_CODE (type) != RECORD_TYPE)\n+     return false;\n+\n+   for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+     if (TREE_CODE (field) == FIELD_DECL)\n+       {\n+         num_fields++;\n+\n+         if (num_fields == 2)\n+           return false;\n+\t \n+         if (AGGREGATE_TYPE_P (TREE_TYPE (field)))\n+           return false;\n+       }\n+\n+   return true;\n+}\n+\n /* Make one pass across an element tree deciding whether to perform block\n    or element copies.  If we decide on element copies, instantiate all\n    elements.  Return true if there are any instantiated sub-elements.  */\n@@ -1430,6 +1456,10 @@ decide_block_copy (struct sra_elt *elt)\n \t  full_count = count_type_elements (elt->type, false);\n \t  inst_count = sum_instantiated_sizes (elt, &inst_size);\n \n+\t  /* If there is only one scalar field in the record, don't block copy.  */\n+\t  if (single_scalar_field_in_record_p (elt->type))\n+\t    use_block_copy = false;\n+\n \t  /* ??? What to do here.  If there are two fields, and we've only\n \t     instantiated one, then instantiating the other is clearly a win.\n \t     If there are a large number of fields then the size of the copy"}]}