{"sha": "56fdfd3e85567d87889962e0b08d9190b53bbea1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTZmZGZkM2U4NTU2N2Q4Nzg4OTk2MmUwYjA4ZDkxOTBiNTNiYmVhMQ==", "commit": {"author": {"name": "Andi Kleen", "email": "ak@linux.intel.com", "date": "2014-07-25T13:39:36Z"}, "committer": {"name": "Andi Kleen", "email": "ak@gcc.gnu.org", "date": "2014-07-25T13:39:36Z"}, "message": "Convert the tree.c type hashing over to inchash\n\nv2: Use commutative interface. Be much nearer to the old\ncode.\n\ngcc/:\n\n2014-07-25  Andi Kleen  <ak@linux.intel.com>\n\n\t* tree.c (build_type_attribute_qual_variant): Use inchash.\n\t(type_hash_list): Dito.\n\t(attribute_hash_list): Dito\n\t(iterative_hstate_expr): Dito.\n\t(iterative_hash_expr): Dito.\n\t(build_range_type_1): Dito.\n\t(build_array_type_1): Dito.\n\t(build_function_type): Dito.\n\t(build_method_type_directly): Dito.\n\t(build_offset_type): Dito.\n\t(build_complex_type): Dito.\n\t(make_vector_type): Dito.\n\t* tree.h (iterative_hash_expr): Add compat wrapper.\n\t(iterative_hstate_expr): Add.\n\ngcc/lto/:\n\n2014-07-25  Andi Kleen  <ak@linux.intel.com>\n\n\t* lto.c (hash_canonical_type): Call iterative_hstate_expr.\n\nFrom-SVN: r213056", "tree": {"sha": "6647dfd08c4e561eeddc5c97f3e108674d6eac43", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6647dfd08c4e561eeddc5c97f3e108674d6eac43"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/56fdfd3e85567d87889962e0b08d9190b53bbea1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56fdfd3e85567d87889962e0b08d9190b53bbea1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56fdfd3e85567d87889962e0b08d9190b53bbea1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56fdfd3e85567d87889962e0b08d9190b53bbea1/comments", "author": null, "committer": null, "parents": [{"sha": "0bd8bb0476ac70d8beeddc9c6434771728df3831", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bd8bb0476ac70d8beeddc9c6434771728df3831", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0bd8bb0476ac70d8beeddc9c6434771728df3831"}], "stats": {"total": 222, "additions": 123, "deletions": 99}, "files": [{"sha": "9cf0c90659399f948589f37e88fe8cc9b3411d71", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56fdfd3e85567d87889962e0b08d9190b53bbea1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56fdfd3e85567d87889962e0b08d9190b53bbea1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=56fdfd3e85567d87889962e0b08d9190b53bbea1", "patch": "@@ -1,3 +1,20 @@\n+2014-07-25  Andi Kleen  <ak@linux.intel.com>\n+\n+\t* tree.c (build_type_attribute_qual_variant): Use inchash.\n+\t(type_hash_list): Dito.\n+\t(attribute_hash_list): Dito\n+\t(iterative_hstate_expr): Dito.\n+\t(iterative_hash_expr): Dito.\n+\t(build_range_type_1): Dito.\n+\t(build_array_type_1): Dito.\n+\t(build_function_type): Dito.\n+\t(build_method_type_directly): Dito.\n+\t(build_offset_type): Dito.\n+\t(build_complex_type): Dito.\n+\t(make_vector_type): Dito.\n+\t* tree.h (iterative_hash_expr): Add compat wrapper.\n+\t(iterative_hstate_expr): Add.\n+\n 2014-07-25  Andi Kleen  <ak@linux.intel.com>\n \n \t* Makefile.in (OBJS): Add inchash.o."}, {"sha": "8309ab97d5afe22aa993f8abf9c4c8331583e93e", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56fdfd3e85567d87889962e0b08d9190b53bbea1/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56fdfd3e85567d87889962e0b08d9190b53bbea1/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=56fdfd3e85567d87889962e0b08d9190b53bbea1", "patch": "@@ -1,3 +1,7 @@\n+2014-07-25  Andi Kleen  <ak@linux.intel.com>\n+\n+\t* lto.c (hash_canonical_type): Call iterative_hstate_expr.\n+\n 2014-07-25  Andi Kleen  <ak@linux.intel.com>\n \n \t* lto.c (hash_canonical_type): Convert to inchash."}, {"sha": "2de00fbf518185b4f60e375bd3b9e24612c7d84f", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56fdfd3e85567d87889962e0b08d9190b53bbea1/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56fdfd3e85567d87889962e0b08d9190b53bbea1/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=56fdfd3e85567d87889962e0b08d9190b53bbea1", "patch": "@@ -327,11 +327,9 @@ hash_canonical_type (tree type)\n       /* OMP lowering can introduce error_mark_node in place of\n \t random local decls in types.  */\n       if (TYPE_MIN_VALUE (TYPE_DOMAIN (type)) != error_mark_node)\n-\thstate.add_int (iterative_hash_expr (TYPE_MIN_VALUE (\n-\t\t\t\t\tTYPE_DOMAIN (type)), 0));\n+\titerative_hstate_expr (TYPE_MIN_VALUE (TYPE_DOMAIN (type)), hstate);\n       if (TYPE_MAX_VALUE (TYPE_DOMAIN (type)) != error_mark_node)\n-\thstate.add_int (iterative_hash_expr (TYPE_MAX_VALUE (\n-\t\t\t\t\tTYPE_DOMAIN (type)), 0));\n+\titerative_hstate_expr (TYPE_MAX_VALUE (TYPE_DOMAIN (type)), hstate);\n     }\n \n   /* Recurse for aggregates with a single element type.  */"}, {"sha": "6669a8466c0e349a7a188db581e8f89bdb955ebb", "filename": "gcc/tree.c", "status": "modified", "additions": 88, "deletions": 94, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56fdfd3e85567d87889962e0b08d9190b53bbea1/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56fdfd3e85567d87889962e0b08d9190b53bbea1/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=56fdfd3e85567d87889962e0b08d9190b53bbea1", "patch": "@@ -231,8 +231,8 @@ static void print_type_hash_statistics (void);\n static void print_debug_expr_statistics (void);\n static void print_value_expr_statistics (void);\n static int type_hash_marked_p (const void *);\n-static unsigned int type_hash_list (const_tree, hashval_t);\n-static unsigned int attribute_hash_list (const_tree, hashval_t);\n+static void type_hash_list (const_tree, inchash &);\n+static void attribute_hash_list (const_tree, inchash &);\n \n tree global_trees[TI_MAX];\n tree integer_types[itk_none];\n@@ -4593,7 +4593,7 @@ build_type_attribute_qual_variant (tree ttype, tree attribute, int quals)\n {\n   if (! attribute_list_equal (TYPE_ATTRIBUTES (ttype), attribute))\n     {\n-      hashval_t hashcode = 0;\n+      inchash hstate;\n       tree ntype;\n       int i;\n       tree t;\n@@ -4621,39 +4621,37 @@ build_type_attribute_qual_variant (tree ttype, tree attribute, int quals)\n \n       TYPE_ATTRIBUTES (ntype) = attribute;\n \n-      hashcode = iterative_hash_object (code, hashcode);\n+      hstate.add_int (code);\n       if (TREE_TYPE (ntype))\n-\thashcode = iterative_hash_object (TYPE_HASH (TREE_TYPE (ntype)),\n-\t\t\t\t\t  hashcode);\n-      hashcode = attribute_hash_list (attribute, hashcode);\n+\thstate.add_object (TYPE_HASH (TREE_TYPE (ntype)));\n+      attribute_hash_list (attribute, hstate);\n \n       switch (TREE_CODE (ntype))\n \t{\n \tcase FUNCTION_TYPE:\n-\t  hashcode = type_hash_list (TYPE_ARG_TYPES (ntype), hashcode);\n+\t  type_hash_list (TYPE_ARG_TYPES (ntype), hstate);\n \t  break;\n \tcase ARRAY_TYPE:\n \t  if (TYPE_DOMAIN (ntype))\n-\t    hashcode = iterative_hash_object (TYPE_HASH (TYPE_DOMAIN (ntype)),\n-\t\t\t\t\t      hashcode);\n+\t    hstate.add_object (TYPE_HASH (TYPE_DOMAIN (ntype)));\n \t  break;\n \tcase INTEGER_TYPE:\n \t  t = TYPE_MAX_VALUE (ntype);\n \t  for (i = 0; i < TREE_INT_CST_NUNITS (t); i++)\n-\t    hashcode = iterative_hash_object (TREE_INT_CST_ELT (t, i), hashcode);\n+\t    hstate.add_object (TREE_INT_CST_ELT (t, i));\n \t  break;\n \tcase REAL_TYPE:\n \tcase FIXED_POINT_TYPE:\n \t  {\n \t    unsigned int precision = TYPE_PRECISION (ntype);\n-\t    hashcode = iterative_hash_object (precision, hashcode);\n+\t    hstate.add_object (precision);\n \t  }\n \t  break;\n \tdefault:\n \t  break;\n \t}\n \n-      ntype = type_hash_canon (hashcode, ntype);\n+      ntype = type_hash_canon (hstate.end(), ntype);\n \n       /* If the target-dependent attributes make NTYPE different from\n \t its canonical type, we will need to use structural equality\n@@ -6632,17 +6630,14 @@ decl_debug_args_insert (tree from)\n    with types in the TREE_VALUE slots), by adding the hash codes\n    of the individual types.  */\n \n-static unsigned int\n-type_hash_list (const_tree list, hashval_t hashcode)\n+static void\n+type_hash_list (const_tree list, inchash &hstate)\n {\n   const_tree tail;\n \n   for (tail = list; tail; tail = TREE_CHAIN (tail))\n     if (TREE_VALUE (tail) != error_mark_node)\n-      hashcode = iterative_hash_object (TYPE_HASH (TREE_VALUE (tail)),\n-\t\t\t\t\thashcode);\n-\n-  return hashcode;\n+      hstate.add_object (TYPE_HASH (TREE_VALUE (tail)));\n }\n \n /* These are the Hashtable callback functions.  */\n@@ -6870,16 +6865,14 @@ print_type_hash_statistics (void)\n    with names in the TREE_PURPOSE slots and args in the TREE_VALUE slots),\n    by adding the hash codes of the individual attributes.  */\n \n-static unsigned int\n-attribute_hash_list (const_tree list, hashval_t hashcode)\n+static void\n+attribute_hash_list (const_tree list, inchash &hstate)\n {\n   const_tree tail;\n \n   for (tail = list; tail; tail = TREE_CHAIN (tail))\n     /* ??? Do we want to add in TREE_VALUE too? */\n-    hashcode = iterative_hash_object\n-      (IDENTIFIER_HASH_VALUE (get_attribute_name (tail)), hashcode);\n-  return hashcode;\n+    hstate.add_object (IDENTIFIER_HASH_VALUE (get_attribute_name (tail)));\n }\n \n /* Given two lists of attributes, return true if list l2 is\n@@ -7392,20 +7385,22 @@ commutative_ternary_tree_code (enum tree_code code)\n }\n \n /* Generate a hash value for an expression.  This can be used iteratively\n-   by passing a previous result as the VAL argument.\n+   by passing a previous result as the HSTATE argument.\n \n    This function is intended to produce the same hash for expressions which\n    would compare equal using operand_equal_p.  */\n-\n-hashval_t\n-iterative_hash_expr (const_tree t, hashval_t val)\n+void\n+iterative_hstate_expr (const_tree t, inchash &hstate)\n {\n   int i;\n   enum tree_code code;\n   enum tree_code_class tclass;\n \n   if (t == NULL_TREE)\n-    return iterative_hash_hashval_t (0, val);\n+    {\n+      hstate.merge_hash (0);\n+      return;\n+    }\n \n   code = TREE_CODE (t);\n \n@@ -7414,58 +7409,61 @@ iterative_hash_expr (const_tree t, hashval_t val)\n     /* Alas, constants aren't shared, so we can't rely on pointer\n        identity.  */\n     case VOID_CST:\n-      return iterative_hash_hashval_t (0, val);\n+      hstate.merge_hash (0);\n+      return;\n     case INTEGER_CST:\n       for (i = 0; i < TREE_INT_CST_NUNITS (t); i++)\n-\tval = iterative_hash_host_wide_int (TREE_INT_CST_ELT (t, i), val);\n-      return val;\n+\thstate.add_wide_int (TREE_INT_CST_ELT (t, i));\n+      return;\n     case REAL_CST:\n       {\n \tunsigned int val2 = real_hash (TREE_REAL_CST_PTR (t));\n-\n-\treturn iterative_hash_hashval_t (val2, val);\n+\thstate.merge_hash (val2);\n+\treturn;\n       }\n     case FIXED_CST:\n       {\n \tunsigned int val2 = fixed_hash (TREE_FIXED_CST_PTR (t));\n-\n-\treturn iterative_hash_hashval_t (val2, val);\n+\thstate.merge_hash (val2);\n+\treturn;\n       }\n     case STRING_CST:\n-      return iterative_hash (TREE_STRING_POINTER (t),\n-\t\t\t     TREE_STRING_LENGTH (t), val);\n+      hstate.add ((const void *) TREE_STRING_POINTER (t), TREE_STRING_LENGTH (t));\n+      return;\n     case COMPLEX_CST:\n-      val = iterative_hash_expr (TREE_REALPART (t), val);\n-      return iterative_hash_expr (TREE_IMAGPART (t), val);\n+      iterative_hstate_expr (TREE_REALPART (t), hstate);\n+      iterative_hstate_expr (TREE_IMAGPART (t), hstate);\n+      return;\n     case VECTOR_CST:\n       {\n \tunsigned i;\n \tfor (i = 0; i < VECTOR_CST_NELTS (t); ++i)\n-\t  val = iterative_hash_expr (VECTOR_CST_ELT (t, i), val);\n-\treturn val;\n+\t  iterative_hstate_expr (VECTOR_CST_ELT (t, i), hstate);\n+\treturn;\n       }\n     case SSA_NAME:\n       /* We can just compare by pointer.  */\n-      return iterative_hash_host_wide_int (SSA_NAME_VERSION (t), val);\n+      hstate.add_wide_int (SSA_NAME_VERSION (t));\n+      return;\n     case PLACEHOLDER_EXPR:\n       /* The node itself doesn't matter.  */\n-      return val;\n+      return;\n     case TREE_LIST:\n       /* A list of expressions, for a CALL_EXPR or as the elements of a\n \t VECTOR_CST.  */\n       for (; t; t = TREE_CHAIN (t))\n-\tval = iterative_hash_expr (TREE_VALUE (t), val);\n-      return val;\n+\titerative_hstate_expr (TREE_VALUE (t), hstate);\n+      return;\n     case CONSTRUCTOR:\n       {\n \tunsigned HOST_WIDE_INT idx;\n \ttree field, value;\n \tFOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (t), idx, field, value)\n \t  {\n-\t    val = iterative_hash_expr (field, val);\n-\t    val = iterative_hash_expr (value, val);\n+\t    iterative_hstate_expr (field, hstate);\n+\t    iterative_hstate_expr (value, hstate);\n \t  }\n-\treturn val;\n+\treturn;\n       }\n     case FUNCTION_DECL:\n       /* When referring to a built-in FUNCTION_DECL, use the __builtin__ form.\n@@ -7486,13 +7484,13 @@ iterative_hash_expr (const_tree t, hashval_t val)\n       if (tclass == tcc_declaration)\n \t{\n \t  /* DECL's have a unique ID */\n-\t  val = iterative_hash_host_wide_int (DECL_UID (t), val);\n+\t  hstate.add_wide_int (DECL_UID (t));\n \t}\n       else\n \t{\n \t  gcc_assert (IS_EXPR_CODE_CLASS (tclass));\n \n-\t  val = iterative_hash_object (code, val);\n+\t  hstate.add_object (code);\n \n \t  /* Don't hash the type, that can lead to having nodes which\n \t     compare equal according to operand_equal_p, but which\n@@ -7501,8 +7499,8 @@ iterative_hash_expr (const_tree t, hashval_t val)\n \t      || code == NON_LVALUE_EXPR)\n \t    {\n \t      /* Make sure to include signness in the hash computation.  */\n-\t      val += TYPE_UNSIGNED (TREE_TYPE (t));\n-\t      val = iterative_hash_expr (TREE_OPERAND (t, 0), val);\n+\t      hstate.add_int (TYPE_UNSIGNED (TREE_TYPE (t)));\n+\t      iterative_hstate_expr (TREE_OPERAND (t, 0), hstate);\n \t    }\n \n \t  else if (commutative_tree_code (code))\n@@ -7511,21 +7509,16 @@ iterative_hash_expr (const_tree t, hashval_t val)\n \t\t however it appears.  We do this by first hashing both operands\n \t\t and then rehashing based on the order of their independent\n \t\t hashes.  */\n-\t      hashval_t one = iterative_hash_expr (TREE_OPERAND (t, 0), 0);\n-\t      hashval_t two = iterative_hash_expr (TREE_OPERAND (t, 1), 0);\n-\t      hashval_t t;\n-\n-\t      if (one > two)\n-\t\tt = one, one = two, two = t;\n-\n-\t      val = iterative_hash_hashval_t (one, val);\n-\t      val = iterative_hash_hashval_t (two, val);\n+\t      inchash one, two;\n+\t      iterative_hstate_expr (TREE_OPERAND (t, 0), one);\n+\t      iterative_hstate_expr (TREE_OPERAND (t, 1), two);\n+\t      hstate.add_commutative (one, two);\n \t    }\n \t  else\n \t    for (i = TREE_OPERAND_LENGTH (t) - 1; i >= 0; --i)\n-\t      val = iterative_hash_expr (TREE_OPERAND (t, i), val);\n+\t      iterative_hstate_expr (TREE_OPERAND (t, i), hstate);\n \t}\n-      return val;\n+      return;\n     }\n }\n \n@@ -7718,7 +7711,7 @@ static tree\n build_range_type_1 (tree type, tree lowval, tree highval, bool shared)\n {\n   tree itype = make_node (INTEGER_TYPE);\n-  hashval_t hashcode = 0;\n+  inchash hstate;\n \n   TREE_TYPE (itype) = type;\n \n@@ -7746,10 +7739,10 @@ build_range_type_1 (tree type, tree lowval, tree highval, bool shared)\n       return itype;\n     }\n \n-  hashcode = iterative_hash_expr (TYPE_MIN_VALUE (itype), hashcode);\n-  hashcode = iterative_hash_expr (TYPE_MAX_VALUE (itype), hashcode);\n-  hashcode = iterative_hash_hashval_t (TYPE_HASH (type), hashcode);\n-  itype = type_hash_canon (hashcode, itype);\n+  iterative_hstate_expr (TYPE_MIN_VALUE (itype), hstate);\n+  iterative_hstate_expr (TYPE_MAX_VALUE (itype), hstate);\n+  hstate.merge_hash (TYPE_HASH (type));\n+  itype = type_hash_canon (hstate.end (), itype);\n \n   return itype;\n }\n@@ -7854,10 +7847,11 @@ build_array_type_1 (tree elt_type, tree index_type, bool shared)\n \n   if (shared)\n     {\n-      hashval_t hashcode = iterative_hash_object (TYPE_HASH (elt_type), 0);\n+      inchash hstate;\n+      hstate.add_object (TYPE_HASH (elt_type));\n       if (index_type)\n-\thashcode = iterative_hash_object (TYPE_HASH (index_type), hashcode);\n-      t = type_hash_canon (hashcode, t);\n+\thstate.add_object (TYPE_HASH (index_type));\n+      t = type_hash_canon (hstate.end (), t);\n     }\n \n   if (TYPE_CANONICAL (t) == t)\n@@ -7997,7 +7991,7 @@ tree\n build_function_type (tree value_type, tree arg_types)\n {\n   tree t;\n-  hashval_t hashcode = 0;\n+  inchash hstate;\n   bool any_structural_p, any_noncanonical_p;\n   tree canon_argtypes;\n \n@@ -8013,9 +8007,9 @@ build_function_type (tree value_type, tree arg_types)\n   TYPE_ARG_TYPES (t) = arg_types;\n \n   /* If we already have such a type, use the old one.  */\n-  hashcode = iterative_hash_object (TYPE_HASH (value_type), hashcode);\n-  hashcode = type_hash_list (arg_types, hashcode);\n-  t = type_hash_canon (hashcode, t);\n+  hstate.add_object (TYPE_HASH (value_type));\n+  type_hash_list (arg_types, hstate);\n+  t = type_hash_canon (hstate.end (), t);\n \n   /* Set up the canonical type. */\n   any_structural_p   = TYPE_STRUCTURAL_EQUALITY_P (value_type);\n@@ -8152,7 +8146,7 @@ build_method_type_directly (tree basetype,\n {\n   tree t;\n   tree ptype;\n-  int hashcode = 0;\n+  inchash hstate;\n   bool any_structural_p, any_noncanonical_p;\n   tree canon_argtypes;\n \n@@ -8169,10 +8163,10 @@ build_method_type_directly (tree basetype,\n   TYPE_ARG_TYPES (t) = argtypes;\n \n   /* If we already have such a type, use the old one.  */\n-  hashcode = iterative_hash_object (TYPE_HASH (basetype), hashcode);\n-  hashcode = iterative_hash_object (TYPE_HASH (rettype), hashcode);\n-  hashcode = type_hash_list (argtypes, hashcode);\n-  t = type_hash_canon (hashcode, t);\n+  hstate.add_object (TYPE_HASH (basetype));\n+  hstate.add_object (TYPE_HASH (rettype));\n+  type_hash_list (argtypes, hstate);\n+  t = type_hash_canon (hstate.end (), t);\n \n   /* Set up the canonical type. */\n   any_structural_p\n@@ -8220,7 +8214,7 @@ tree\n build_offset_type (tree basetype, tree type)\n {\n   tree t;\n-  hashval_t hashcode = 0;\n+  inchash hstate;\n \n   /* Make a node of the sort we want.  */\n   t = make_node (OFFSET_TYPE);\n@@ -8229,9 +8223,9 @@ build_offset_type (tree basetype, tree type)\n   TREE_TYPE (t) = type;\n \n   /* If we already have such a type, use the old one.  */\n-  hashcode = iterative_hash_object (TYPE_HASH (basetype), hashcode);\n-  hashcode = iterative_hash_object (TYPE_HASH (type), hashcode);\n-  t = type_hash_canon (hashcode, t);\n+  hstate.add_object (TYPE_HASH (basetype));\n+  hstate.add_object (TYPE_HASH (type));\n+  t = type_hash_canon (hstate.end (), t);\n \n   if (!COMPLETE_TYPE_P (t))\n     layout_type (t);\n@@ -8257,7 +8251,7 @@ tree\n build_complex_type (tree component_type)\n {\n   tree t;\n-  hashval_t hashcode;\n+  inchash hstate;\n \n   gcc_assert (INTEGRAL_TYPE_P (component_type)\n \t      || SCALAR_FLOAT_TYPE_P (component_type)\n@@ -8269,8 +8263,8 @@ build_complex_type (tree component_type)\n   TREE_TYPE (t) = TYPE_MAIN_VARIANT (component_type);\n \n   /* If we already have such a type, use the old one.  */\n-  hashcode = iterative_hash_object (TYPE_HASH (component_type), 0);\n-  t = type_hash_canon (hashcode, t);\n+  hstate.add_object (TYPE_HASH (component_type));\n+  t = type_hash_canon (hstate.end (), t);\n \n   if (!COMPLETE_TYPE_P (t))\n     layout_type (t);\n@@ -9409,7 +9403,7 @@ static tree\n make_vector_type (tree innertype, int nunits, enum machine_mode mode)\n {\n   tree t;\n-  hashval_t hashcode = 0;\n+  inchash hstate;\n \n   t = make_node (VECTOR_TYPE);\n   TREE_TYPE (t) = TYPE_MAIN_VARIANT (innertype);\n@@ -9425,11 +9419,11 @@ make_vector_type (tree innertype, int nunits, enum machine_mode mode)\n \n   layout_type (t);\n \n-  hashcode = iterative_hash_host_wide_int (VECTOR_TYPE, hashcode);\n-  hashcode = iterative_hash_host_wide_int (nunits, hashcode);\n-  hashcode = iterative_hash_host_wide_int (mode, hashcode);\n-  hashcode = iterative_hash_object (TYPE_HASH (TREE_TYPE (t)), hashcode);\n-  t = type_hash_canon (hashcode, t);\n+  hstate.add_wide_int (VECTOR_TYPE);\n+  hstate.add_wide_int (nunits);\n+  hstate.add_wide_int (mode);\n+  hstate.add_object (TYPE_HASH (TREE_TYPE (t)));\n+  t = type_hash_canon (hstate.end (), t);\n \n   /* We have built a main variant, based on the main variant of the\n      inner type. Use it to build the variant we return.  */"}, {"sha": "2bb6d1fc1855e5e0de3c183055c286686b55c923", "filename": "gcc/tree.h", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56fdfd3e85567d87889962e0b08d9190b53bbea1/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56fdfd3e85567d87889962e0b08d9190b53bbea1/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=56fdfd3e85567d87889962e0b08d9190b53bbea1", "patch": "@@ -22,6 +22,7 @@ along with GCC; see the file COPYING3.  If not see\n \n #include \"tree-core.h\"\n #include \"wide-int.h\"\n+#include \"inchash.h\"\n \n /* These includes are required here because they provide declarations\n    used by inline functions in this file.\n@@ -4283,7 +4284,17 @@ extern int tree_log2 (const_tree);\n extern int tree_floor_log2 (const_tree);\n extern unsigned int tree_ctz (const_tree);\n extern int simple_cst_equal (const_tree, const_tree);\n-extern hashval_t iterative_hash_expr (const_tree, hashval_t);\n+extern void iterative_hstate_expr (const_tree, inchash &);\n+\n+/* Compat version until all callers are converted. Return hash for\n+   TREE with SEED.  */\n+static inline hashval_t iterative_hash_expr(const_tree tree, hashval_t seed)\n+{\n+  inchash hstate (seed);\n+  iterative_hstate_expr (tree, hstate);\n+  return hstate.end ();\n+}\n+\n extern int compare_tree_int (const_tree, unsigned HOST_WIDE_INT);\n extern int type_list_equal (const_tree, const_tree);\n extern int chain_member (const_tree, const_tree);"}]}