{"sha": "160576e1ac9bbee90af9e09e1507f64d58473358", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTYwNTc2ZTFhYzliYmVlOTBhZjllMDllMTUwN2Y2NGQ1ODQ3MzM1OA==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2018-11-13T15:06:54Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2018-11-13T15:06:54Z"}, "message": "Improve -fprofile-report.\n\n2018-11-13  Martin Liska  <mliska@suse.cz>\n\n\tPR tree-optimization/87885\n\t* cfghooks.c (account_profile_record): Rename\n\tto ...\n\t(profile_record_check_consistency): ... this.\n\tCalculate missing num_mismatched_freq_in.\n\t(profile_record_account_profile): New function\n\tthat calculates time and size of a function.\n\t* cfghooks.h (struct profile_record): Remove\n\tall tuples.\n\t(struct cfg_hooks): Remove after_pass flag.\n\t(account_profile_record): Rename to ...\n\t(profile_record_check_consistency): ... this.\n\t(profile_record_account_profile): New.\n\t* cfgrtl.c (rtl_account_profile_record): Remove\n\tafter_pass flag.\n\t* passes.c (check_profile_consistency): Do only\n\tchecking.\n\t(account_profile): Calculate size and time of\n\tfunction only.\n\t(pass_manager::dump_profile_report): Reformat\n\toutput.\n\t(execute_one_ipa_transform_pass): Call\n\tconsistency check before clean upand call account_profile\n\tafter a clean up is done.\n\t(execute_one_pass): Call check_profile_consistency and\n\taccount_profile instead of using after_pass flag..\n\t* tree-cfg.c (gimple_account_profile_record): Likewise.\n\nFrom-SVN: r266074", "tree": {"sha": "6541a5a15b3bc6f875bc04aac0025283eb9d84a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6541a5a15b3bc6f875bc04aac0025283eb9d84a6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/160576e1ac9bbee90af9e09e1507f64d58473358", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/160576e1ac9bbee90af9e09e1507f64d58473358", "html_url": "https://github.com/Rust-GCC/gccrs/commit/160576e1ac9bbee90af9e09e1507f64d58473358", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/160576e1ac9bbee90af9e09e1507f64d58473358/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e4db210dd8683bf7b2a8ea828d6ea0b18967630a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4db210dd8683bf7b2a8ea828d6ea0b18967630a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4db210dd8683bf7b2a8ea828d6ea0b18967630a"}], "stats": {"total": 315, "additions": 191, "deletions": 124}, "files": [{"sha": "0b82b956ee449c516df898d15aeb9f3c9989b6d3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/160576e1ac9bbee90af9e09e1507f64d58473358/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/160576e1ac9bbee90af9e09e1507f64d58473358/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=160576e1ac9bbee90af9e09e1507f64d58473358", "patch": "@@ -1,3 +1,33 @@\n+2018-11-13  Martin Liska  <mliska@suse.cz>\n+\n+\tPR tree-optimization/87885\n+\t* cfghooks.c (account_profile_record): Rename\n+\tto ...\n+\t(profile_record_check_consistency): ... this.\n+\tCalculate missing num_mismatched_freq_in.\n+\t(profile_record_account_profile): New function\n+\tthat calculates time and size of a function.\n+\t* cfghooks.h (struct profile_record): Remove\n+\tall tuples.\n+\t(struct cfg_hooks): Remove after_pass flag.\n+\t(account_profile_record): Rename to ...\n+\t(profile_record_check_consistency): ... this.\n+\t(profile_record_account_profile): New.\n+\t* cfgrtl.c (rtl_account_profile_record): Remove\n+\tafter_pass flag.\n+\t* passes.c (check_profile_consistency): Do only\n+\tchecking.\n+\t(account_profile): Calculate size and time of\n+\tfunction only.\n+\t(pass_manager::dump_profile_report): Reformat\n+\toutput.\n+\t(execute_one_ipa_transform_pass): Call\n+\tconsistency check before clean upand call account_profile\n+\tafter a clean up is done.\n+\t(execute_one_pass): Call check_profile_consistency and\n+\taccount_profile instead of using after_pass flag..\n+\t* tree-cfg.c (gimple_account_profile_record): Likewise.\n+\n 2018-11-13  Martin Liska  <mliska@suse.cz>\n \n \tPR sanitizer/87930"}, {"sha": "824ab25929ae30389d774546b03cea42e5602487", "filename": "gcc/cfghooks.c", "status": "modified", "additions": 30, "deletions": 8, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/160576e1ac9bbee90af9e09e1507f64d58473358/gcc%2Fcfghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/160576e1ac9bbee90af9e09e1507f64d58473358/gcc%2Fcfghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.c?ref=160576e1ac9bbee90af9e09e1507f64d58473358", "patch": "@@ -1425,11 +1425,10 @@ split_block_before_cond_jump (basic_block bb)\n \n /* Work-horse for passes.c:check_profile_consistency.\n    Do book-keeping of the CFG for the profile consistency checker.\n-   If AFTER_PASS is 0, do pre-pass accounting, or if AFTER_PASS is 1\n-   then do post-pass accounting.  Store the counting in RECORD.  */\n+   Store the counting in RECORD.  */\n \n void\n-account_profile_record (struct profile_record *record, int after_pass)\n+profile_record_check_consistency (profile_record *record)\n {\n   basic_block bb;\n   edge_iterator ei;\n@@ -1445,26 +1444,49 @@ account_profile_record (struct profile_record *record, int after_pass)\n \t    sum += e->probability;\n \t  if (EDGE_COUNT (bb->succs)\n \t      && sum.differs_from_p (profile_probability::always ()))\n-\t    record->num_mismatched_freq_out[after_pass]++;\n+\t    record->num_mismatched_freq_out++;\n \t  profile_count lsum = profile_count::zero ();\n \t  FOR_EACH_EDGE (e, ei, bb->succs)\n \t    lsum += e->count ();\n \t  if (EDGE_COUNT (bb->succs) && (lsum.differs_from_p (bb->count)))\n-\t    record->num_mismatched_count_out[after_pass]++;\n+\t    record->num_mismatched_count_out++;\n \t}\n       if (bb != ENTRY_BLOCK_PTR_FOR_FN (cfun)\n \t  && profile_status_for_fn (cfun) != PROFILE_ABSENT)\n \t{\n+\t  profile_probability sum = profile_probability::never ();\n \t  profile_count lsum = profile_count::zero ();\n \t  FOR_EACH_EDGE (e, ei, bb->preds)\n-\t    lsum += e->count ();\n+\t    {\n+\t      sum += e->probability;\n+\t      lsum += e->count ();\n+\t    }\n+\t  if (EDGE_COUNT (bb->preds)\n+\t      && sum.differs_from_p (profile_probability::always ()))\n+\t    record->num_mismatched_freq_in++;\n \t  if (lsum.differs_from_p (bb->count))\n-\t    record->num_mismatched_count_in[after_pass]++;\n+\t    record->num_mismatched_count_in++;\n \t}\n       if (bb == ENTRY_BLOCK_PTR_FOR_FN (cfun)\n \t  || bb == EXIT_BLOCK_PTR_FOR_FN (cfun))\n \tcontinue;\n       gcc_assert (cfg_hooks->account_profile_record);\n-      cfg_hooks->account_profile_record (bb, after_pass, record);\n+      cfg_hooks->account_profile_record (bb, record);\n+   }\n+}\n+\n+/* Work-horse for passes.c:acount_profile.\n+   Do book-keeping of the CFG for the profile accounting.\n+   Store the counting in RECORD.  */\n+\n+void\n+profile_record_account_profile (profile_record *record)\n+{\n+  basic_block bb;\n+\n+  FOR_ALL_BB_FN (bb, cfun)\n+   {\n+      gcc_assert (cfg_hooks->account_profile_record);\n+      cfg_hooks->account_profile_record (bb, record);\n    }\n }"}, {"sha": "d1d2e70c3d4b69c603bca35de1a2269c74424110", "filename": "gcc/cfghooks.h", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/160576e1ac9bbee90af9e09e1507f64d58473358/gcc%2Fcfghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/160576e1ac9bbee90af9e09e1507f64d58473358/gcc%2Fcfghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.h?ref=160576e1ac9bbee90af9e09e1507f64d58473358", "patch": "@@ -38,18 +38,18 @@ struct profile_record\n {\n   /* The number of basic blocks where sum(freq) of the block's predecessors\n      doesn't match reasonably well with the incoming frequency.  */\n-  int num_mismatched_freq_in[2];\n+  int num_mismatched_freq_in;\n   /* Likewise for a basic block's successors.  */\n-  int num_mismatched_freq_out[2];\n+  int num_mismatched_freq_out;\n   /* The number of basic blocks where sum(count) of the block's predecessors\n      doesn't match reasonably well with the incoming frequency.  */\n-  int num_mismatched_count_in[2];\n+  int num_mismatched_count_in;\n   /* Likewise for a basic block's successors.  */\n-  int num_mismatched_count_out[2];\n+  int num_mismatched_count_out;\n   /* A weighted cost of the run-time of the function body.  */\n-  gcov_type time[2];\n+  gcov_type_unsigned time;\n   /* A weighted cost of the size of the function body.  */\n-  int size[2];\n+  int size;\n   /* True iff this pass actually was run.  */\n   bool run;\n };\n@@ -182,7 +182,7 @@ struct cfg_hooks\n   basic_block (*split_block_before_cond_jump) (basic_block);\n \n   /* Do book-keeping of a basic block for the profile consistency checker.  */\n-  void (*account_profile_record) (basic_block, int, struct profile_record *);\n+  void (*account_profile_record) (basic_block, struct profile_record *);\n };\n \n extern void verify_flow_info (void);\n@@ -254,7 +254,8 @@ extern void copy_bbs (basic_block *, unsigned, basic_block *,\n \t\t      edge *, unsigned, edge *, struct loop *,\n \t\t      basic_block, bool);\n \n-void account_profile_record (struct profile_record *, int);\n+void profile_record_check_consistency (profile_record *);\n+void profile_record_account_profile (profile_record *);\n \n /* Hooks containers.  */\n extern struct cfg_hooks gimple_cfg_hooks;"}, {"sha": "741a3120a971cbc8f9fa7c6cff442c4b76ece4ba", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/160576e1ac9bbee90af9e09e1507f64d58473358/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/160576e1ac9bbee90af9e09e1507f64d58473358/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=160576e1ac9bbee90af9e09e1507f64d58473358", "patch": "@@ -5068,22 +5068,20 @@ rtl_duplicate_bb (basic_block bb)\n }\n \n /* Do book-keeping of basic block BB for the profile consistency checker.\n-   If AFTER_PASS is 0, do pre-pass accounting, or if AFTER_PASS is 1\n-   then do post-pass accounting.  Store the counting in RECORD.  */\n+   Store the counting in RECORD.  */\n static void\n-rtl_account_profile_record (basic_block bb, int after_pass,\n-\t\t\t    struct profile_record *record)\n+rtl_account_profile_record (basic_block bb, struct profile_record *record)\n {\n   rtx_insn *insn;\n   FOR_BB_INSNS (bb, insn)\n     if (INSN_P (insn))\n       {\n-\trecord->size[after_pass] += insn_cost (insn, false);\n+\trecord->size += insn_cost (insn, false);\n \tif (bb->count.initialized_p ())\n-\t  record->time[after_pass]\n+\t  record->time\n \t    += insn_cost (insn, true) * bb->count.to_gcov_type ();\n \telse if (profile_status_for_fn (cfun) == PROFILE_GUESSED)\n-\t  record->time[after_pass]\n+\t  record->time\n \t    += insn_cost (insn, true) * bb->count.to_frequency (cfun);\n       }\n }"}, {"sha": "5d2372bac24408d9d1abf1085bcbe35ef82ef829", "filename": "gcc/passes.c", "status": "modified", "additions": 112, "deletions": 95, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/160576e1ac9bbee90af9e09e1507f64d58473358/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/160576e1ac9bbee90af9e09e1507f64d58473358/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=160576e1ac9bbee90af9e09e1507f64d58473358", "patch": "@@ -1738,12 +1738,31 @@ emergency_dump_function ()\n static struct profile_record *profile_record;\n \n /* Do profile consistency book-keeping for the pass with static number INDEX.\n-   If SUBPASS is zero, we run _before_ the pass, and if SUBPASS is one, then\n-   we run _after_ the pass.  RUN is true if the pass really runs, or FALSE\n+   RUN is true if the pass really runs, or FALSE\n    if we are only book-keeping on passes that may have selectively disabled\n    themselves on a given function.  */\n+\n+static void\n+check_profile_consistency (int index, bool run)\n+{\n+  pass_manager *passes = g->get_passes ();\n+  if (index == -1)\n+    return;\n+  if (!profile_record)\n+    profile_record = XCNEWVEC (struct profile_record,\n+\t\t\t       passes->passes_by_id_size);\n+  gcc_assert (index < passes->passes_by_id_size && index >= 0);\n+  profile_record[index].run |= run;\n+  profile_record_check_consistency (&profile_record[index]);\n+}\n+\n+/* Account profile the pass with static number INDEX.\n+   RUN is true if the pass really runs, or FALSE\n+   if we are only book-keeping on passes that may have selectively disabled\n+   themselves on a given function.  */\n+\n static void\n-check_profile_consistency (int index, int subpass, bool run)\n+account_profile (int index, bool run)\n {\n   pass_manager *passes = g->get_passes ();\n   if (index == -1)\n@@ -1752,9 +1771,8 @@ check_profile_consistency (int index, int subpass, bool run)\n     profile_record = XCNEWVEC (struct profile_record,\n \t\t\t       passes->passes_by_id_size);\n   gcc_assert (index < passes->passes_by_id_size && index >= 0);\n-  gcc_assert (subpass < 2);\n   profile_record[index].run |= run;\n-  account_profile_record (&profile_record[index], subpass);\n+  profile_record_account_profile (&profile_record[index]);\n }\n \n /* Output profile consistency.  */\n@@ -1768,7 +1786,6 @@ dump_profile_report (void)\n void\n pass_manager::dump_profile_report () const\n {\n-  int i, j;\n   int last_freq_in = 0, last_count_in = 0, last_freq_out = 0, last_count_out = 0;\n   gcov_type last_time = 0, last_size = 0;\n   double rel_time_change, rel_size_change;\n@@ -1777,86 +1794,86 @@ pass_manager::dump_profile_report () const\n   if (!profile_record)\n     return;\n   fprintf (stderr, \"\\nProfile consistency report:\\n\\n\");\n-  fprintf (stderr, \"Pass name                        |mismatch in |mismated out|Overall\\n\");\n-  fprintf (stderr, \"                                 |freq count  |freq count  |size      time\\n\");\n+  fprintf (stderr, \"                                 |mismatch     |mismatch     |                     |\\n\");\n+  fprintf (stderr, \"Pass name                        |IN    |IN    |OUT   |OUT   |overall              |\\n\");\n+  fprintf (stderr, \"                                 |freq  |count |freq  |count |size      |time      |\\n\");\n \t   \n-  for (i = 0; i < passes_by_id_size; i++)\n-    for (j = 0 ; j < 2; j++)\n-      if (profile_record[i].run)\n-\t{\n-\t  if (last_time)\n-\t    rel_time_change = (profile_record[i].time[j]\n-\t\t\t       - (double)last_time) * 100 / (double)last_time;\n-\t  else\n-\t    rel_time_change = 0;\n-\t  if (last_size)\n-\t    rel_size_change = (profile_record[i].size[j]\n-\t\t\t       - (double)last_size) * 100 / (double)last_size;\n-\t  else\n-\t    rel_size_change = 0;\n-\n-\t  if (profile_record[i].num_mismatched_freq_in[j] != last_freq_in\n-\t      || profile_record[i].num_mismatched_freq_out[j] != last_freq_out\n-\t      || profile_record[i].num_mismatched_count_in[j] != last_count_in\n-\t      || profile_record[i].num_mismatched_count_out[j] != last_count_out\n-\t      || rel_time_change || rel_size_change)\n-\t    {\n-\t      last_reported = i;\n-              fprintf (stderr, \"%-20s %s\",\n-\t\t       passes_by_id [i]->name,\n-\t\t       j ? \"(after TODO)\" : \"            \");\n-\t      if (profile_record[i].num_mismatched_freq_in[j] != last_freq_in)\n-\t\tfprintf (stderr, \"| %+5i\",\n-\t\t         profile_record[i].num_mismatched_freq_in[j]\n-\t\t\t  - last_freq_in);\n-\t      else\n-\t\tfprintf (stderr, \"|      \");\n-\t      if (profile_record[i].num_mismatched_count_in[j] != last_count_in)\n-\t\tfprintf (stderr, \" %+5i\",\n-\t\t         profile_record[i].num_mismatched_count_in[j]\n-\t\t\t  - last_count_in);\n-\t      else\n-\t\tfprintf (stderr, \"      \");\n-\t      if (profile_record[i].num_mismatched_freq_out[j] != last_freq_out)\n-\t\tfprintf (stderr, \"| %+5i\",\n-\t\t         profile_record[i].num_mismatched_freq_out[j]\n-\t\t\t  - last_freq_out);\n-\t      else\n-\t\tfprintf (stderr, \"|      \");\n-\t      if (profile_record[i].num_mismatched_count_out[j] != last_count_out)\n-\t\tfprintf (stderr, \" %+5i\",\n-\t\t         profile_record[i].num_mismatched_count_out[j]\n-\t\t\t  - last_count_out);\n-\t      else\n-\t\tfprintf (stderr, \"      \");\n-\n-\t      /* Size/time units change across gimple and RTL.  */\n-\t      if (i == pass_expand_1->static_pass_number)\n-\t\tfprintf (stderr, \"|----------\");\n-\t      else\n-\t\t{\n-\t\t  if (rel_size_change)\n-\t\t    fprintf (stderr, \"| %+8.4f%%\", rel_size_change);\n-\t\t  else\n-\t\t    fprintf (stderr, \"|          \");\n-\t\t  if (rel_time_change)\n-\t\t    fprintf (stderr, \" %+8.4f%%\", rel_time_change);\n-\t\t}\n-\t      fprintf (stderr, \"\\n\");\n-\t      last_freq_in = profile_record[i].num_mismatched_freq_in[j];\n-\t      last_freq_out = profile_record[i].num_mismatched_freq_out[j];\n-\t      last_count_in = profile_record[i].num_mismatched_count_in[j];\n-\t      last_count_out = profile_record[i].num_mismatched_count_out[j];\n-\t    }\n-\t  else if (j && last_reported != i)\n-\t    {\n-\t      last_reported = i;\n-              fprintf (stderr, \"%-20s ------------|            |            |\\n\",\n-\t\t       passes_by_id [i]->name);\n-\t    }\n-\t  last_time = profile_record[i].time[j];\n-\t  last_size = profile_record[i].size[j];\n-\t}\n+  for (int i = 1; i < passes_by_id_size; i++)\n+    if (profile_record[i].run)\n+      {\n+\tif (last_time)\n+\t  rel_time_change = (profile_record[i].time\n+\t\t\t     - (double)last_time) * 100 / (double)last_time;\n+\telse\n+\t  rel_time_change = 0;\n+\tif (last_size)\n+\t  rel_size_change = (profile_record[i].size\n+\t\t\t     - (double)last_size) * 100 / (double)last_size;\n+\telse\n+\t  rel_size_change = 0;\n+\n+\tif (profile_record[i].num_mismatched_freq_in != last_freq_in\n+\t    || profile_record[i].num_mismatched_freq_out != last_freq_out\n+\t    || profile_record[i].num_mismatched_count_in != last_count_in\n+\t    || profile_record[i].num_mismatched_count_out != last_count_out\n+\t    || rel_time_change || rel_size_change)\n+\t  {\n+\t    last_reported = i;\n+\t    fprintf (stderr, \"%-33s\", passes_by_id[i]->name);\n+\t    if (profile_record[i].num_mismatched_freq_in != last_freq_in)\n+\t      fprintf (stderr, \"| %+5i\",\n+\t\t       profile_record[i].num_mismatched_freq_in\n+\t\t       - last_freq_in);\n+\t    else\n+\t      fprintf (stderr, \"|      \");\n+\t    if (profile_record[i].num_mismatched_count_in != last_count_in)\n+\t      fprintf (stderr, \"| %+5i\",\n+\t\t       profile_record[i].num_mismatched_count_in\n+\t\t       - last_count_in);\n+\t    else\n+\t      fprintf (stderr, \"|      \");\n+\t    if (profile_record[i].num_mismatched_freq_out != last_freq_out)\n+\t      fprintf (stderr, \"| %+5i\",\n+\t\t       profile_record[i].num_mismatched_freq_out\n+\t\t       - last_freq_out);\n+\t    else\n+\t      fprintf (stderr, \"|      \");\n+\t    if (profile_record[i].num_mismatched_count_out != last_count_out)\n+\t      fprintf (stderr, \"| %+5i\",\n+\t\t       profile_record[i].num_mismatched_count_out\n+\t\t       - last_count_out);\n+\t    else\n+\t      fprintf (stderr, \"|      \");\n+\n+\t    /* Size/time units change across gimple and RTL.  */\n+\t    if (i == pass_expand_1->static_pass_number)\n+\t      fprintf (stderr, \"|----------|----------\");\n+\t    else\n+\t      {\n+\t\tif (rel_size_change)\n+\t\t  fprintf (stderr, \"| %+8.1f%%\", rel_size_change);\n+\t\telse\n+\t\t  fprintf (stderr, \"|          \");\n+\t\tif (rel_time_change)\n+\t\t  fprintf (stderr, \"| %+8.1f%%\", rel_time_change);\n+\t\telse\n+\t\t  fprintf (stderr, \"|          \");\n+\t      }\n+\t    fprintf (stderr, \"|\\n\");\n+\t    last_freq_in = profile_record[i].num_mismatched_freq_in;\n+\t    last_freq_out = profile_record[i].num_mismatched_freq_out;\n+\t    last_count_in = profile_record[i].num_mismatched_count_in;\n+\t    last_count_out = profile_record[i].num_mismatched_count_out;\n+\t  }\n+\telse if (last_reported != i)\n+\t  {\n+\t    last_reported = i;\n+\t    fprintf (stderr, \"%-20s ------------|      |      |      |      |          |          |\\n\",\n+\t\t     passes_by_id[i]->name);\n+\t  }\n+\tlast_time = profile_record[i].time;\n+\tlast_size = profile_record[i].size;\n+      }\n }\n \n /* Perform all TODO actions that ought to be done on each function.  */\n@@ -2163,20 +2180,20 @@ execute_one_ipa_transform_pass (struct cgraph_node *node,\n   if (pass->tv_id != TV_NONE)\n     timevar_push (pass->tv_id);\n \n+  if (profile_report && cfun && (cfun->curr_properties & PROP_cfg))\n+    check_profile_consistency (pass->static_pass_number, true);\n+\n   /* Run pre-pass verification.  */\n   execute_todo (ipa_pass->function_transform_todo_flags_start);\n \n   /* Do it!  */\n   todo_after = ipa_pass->function_transform (node);\n \n-  if (profile_report && cfun && (cfun->curr_properties & PROP_cfg))\n-    check_profile_consistency (pass->static_pass_number, 0, true);\n-\n   /* Run post-pass cleanup and verification.  */\n   execute_todo (todo_after);\n   verify_interpass_invariants ();\n   if (profile_report && cfun && (cfun->curr_properties & PROP_cfg))\n-    check_profile_consistency (pass->static_pass_number, 1, true);\n+    account_profile (pass->static_pass_number, true);\n \n   /* Stop timevar.  */\n   if (pass->tv_id != TV_NONE)\n@@ -2387,8 +2404,8 @@ execute_one_pass (opt_pass *pass)\n \t are not miscounted.  */\n       if (profile_report && cfun && (cfun->curr_properties & PROP_cfg))\n \t{\n-          check_profile_consistency (pass->static_pass_number, 0, false);\n-          check_profile_consistency (pass->static_pass_number, 1, false);\n+\t  check_profile_consistency (pass->static_pass_number, false);\n+\t  account_profile (pass->static_pass_number, false);\n \t}\n       current_pass = NULL;\n       return false;\n@@ -2417,6 +2434,9 @@ execute_one_pass (opt_pass *pass)\n   if (pass->tv_id != TV_NONE)\n     timevar_push (pass->tv_id);\n \n+  if (profile_report && cfun && (cfun->curr_properties & PROP_cfg))\n+    check_profile_consistency (pass->static_pass_number, true);\n+\n   /* Run pre-pass verification.  */\n   execute_todo (pass->todo_flags_start);\n \n@@ -2461,13 +2481,10 @@ execute_one_pass (opt_pass *pass)\n \n   do_per_function (update_properties_after_pass, pass);\n \n-  if (profile_report && cfun && (cfun->curr_properties & PROP_cfg))\n-    check_profile_consistency (pass->static_pass_number, 0, true);\n-\n   /* Run post-pass cleanup and verification.  */\n   execute_todo (todo_after | pass->todo_flags_finish | TODO_verify_il);\n   if (profile_report && cfun && (cfun->curr_properties & PROP_cfg))\n-    check_profile_consistency (pass->static_pass_number, 1, true);\n+    account_profile (pass->static_pass_number, true);\n \n   verify_interpass_invariants ();\n "}, {"sha": "3b646f7149b9f487d5b1debe6227c25ed0840d6b", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/160576e1ac9bbee90af9e09e1507f64d58473358/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/160576e1ac9bbee90af9e09e1507f64d58473358/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=160576e1ac9bbee90af9e09e1507f64d58473358", "patch": "@@ -8798,23 +8798,22 @@ gimple_lv_add_condition_to_bb (basic_block first_head ATTRIBUTE_UNUSED,\n \n \n /* Do book-keeping of basic block BB for the profile consistency checker.\n-   If AFTER_PASS is 0, do pre-pass accounting, or if AFTER_PASS is 1\n-   then do post-pass accounting.  Store the counting in RECORD.  */\n+   Store the counting in RECORD.  */\n static void\n-gimple_account_profile_record (basic_block bb, int after_pass,\n+gimple_account_profile_record (basic_block bb,\n \t\t\t       struct profile_record *record)\n {\n   gimple_stmt_iterator i;\n   for (i = gsi_start_bb (bb); !gsi_end_p (i); gsi_next (&i))\n     {\n-      record->size[after_pass]\n+      record->size\n \t+= estimate_num_insns (gsi_stmt (i), &eni_size_weights);\n       if (bb->count.initialized_p ())\n-\trecord->time[after_pass]\n+\trecord->time\n \t  += estimate_num_insns (gsi_stmt (i),\n \t\t\t\t &eni_time_weights) * bb->count.to_gcov_type ();\n       else if (profile_status_for_fn (cfun) == PROFILE_GUESSED)\n-\trecord->time[after_pass]\n+\trecord->time\n \t  += estimate_num_insns (gsi_stmt (i),\n \t\t\t\t &eni_time_weights) * bb->count.to_frequency (cfun);\n     }"}]}