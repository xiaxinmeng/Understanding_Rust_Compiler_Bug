{"sha": "f4cd2542becd2e4a9b648587693906a0e64531dd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjRjZDI1NDJiZWNkMmU0YTliNjQ4NTg3NjkzOTA2YTBlNjQ1MzFkZA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2009-07-11T20:52:28Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2009-07-11T20:52:28Z"}, "message": "checks.adb (Apply_Address_Clause_Check): Remove Size_Warning_Output local variable and do not test it in...\n\n\t* checks.adb (Apply_Address_Clause_Check): Remove Size_Warning_Output\n\tlocal variable and do not test it in Compile_Time_Bad_Alignment.\n\tDo not issue size or alignment warnings for the X'Address form.\n\t* sem_util.ads (Find_Overlaid_Object): Delete.\n\t(Find_Overlaid_Entity): New procedure.\n\t* sem_util.adb (Find_Overlaid_Object): Rename to...\n\t(Find_Overlaid_Entity): ...this and turn into a procedure.  Report\n\twhether the address is offseted within the overlaid entity.\n\t(Has_Compatible_Alignment): Track the offset globally instead of\n\tpassing it to Check_Offset.  For an indexed component, compute the\n\tfull offset when possible.  If the resulting offset is zero, only\n\tcheck the prefix.\n\t(Check_Offset): Delete.\n\t* sem_ch13.adb (Address_Clause_Check_Record): Add Off field.\n\t(Address_Aliased_Entity): Delete.\n\t(Analyze_Attribute_Definition_Clause) <Attribute_Address>: Call\n\tFind_Overlaid_Entity to find the overlaid entity and the offset.\n\tAdjust throughout for above change.\n\t(Validate_Address_Clauses): Always use attributes of entities, not of\n\ttheir type.  Tweak message for warning.  Call Has_Compatible_Alignment\n\tif the address is offseted to warn about incompatible alignments.\n\t* gcc-interface/gigi.h (annotate_object): Declare.\n\t* gcc-interface/decl.c (gnat_to_gnu_entity) <object>: Annotate renaming\n\tentity.  Call annotate_object instead of annotating manually objects.\n\t(annotate_object): New function.\n\t* gcc-interface/trans.c (Subprogram_Body_to_gnu): Annotate parameters\n\tat the end.\n\nFrom-SVN: r149520", "tree": {"sha": "5f43f396f64c2d468fbd26fc6394ff8b2d0734e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5f43f396f64c2d468fbd26fc6394ff8b2d0734e9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f4cd2542becd2e4a9b648587693906a0e64531dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4cd2542becd2e4a9b648587693906a0e64531dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4cd2542becd2e4a9b648587693906a0e64531dd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4cd2542becd2e4a9b648587693906a0e64531dd/comments", "author": null, "committer": null, "parents": [{"sha": "97c281dacf21dcec5ed4f75f089960c8bfa81b0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97c281dacf21dcec5ed4f75f089960c8bfa81b0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97c281dacf21dcec5ed4f75f089960c8bfa81b0a"}], "stats": {"total": 668, "additions": 361, "deletions": 307}, "files": [{"sha": "7f2c2e24d25cc2c032745759386618847062cb67", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4cd2542becd2e4a9b648587693906a0e64531dd/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4cd2542becd2e4a9b648587693906a0e64531dd/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f4cd2542becd2e4a9b648587693906a0e64531dd", "patch": "@@ -1,3 +1,33 @@\n+2009-07-11  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* checks.adb (Apply_Address_Clause_Check): Remove Size_Warning_Output\n+\tlocal variable and do not test it in Compile_Time_Bad_Alignment.\n+\tDo not issue size or alignment warnings for the X'Address form.\n+\t* sem_util.ads (Find_Overlaid_Object): Delete.\n+\t(Find_Overlaid_Entity): New procedure.\n+\t* sem_util.adb (Find_Overlaid_Object): Rename to...\n+\t(Find_Overlaid_Entity): ...this and turn into a procedure.  Report\n+\twhether the address is offseted within the overlaid entity.\n+\t(Has_Compatible_Alignment): Track the offset globally instead of\n+\tpassing it to Check_Offset.  For an indexed component, compute the\n+\tfull offset when possible.  If the resulting offset is zero, only\n+\tcheck the prefix.\n+\t(Check_Offset): Delete.\n+\t* sem_ch13.adb (Address_Clause_Check_Record): Add Off field.\n+\t(Address_Aliased_Entity): Delete.\n+\t(Analyze_Attribute_Definition_Clause) <Attribute_Address>: Call\n+\tFind_Overlaid_Entity to find the overlaid entity and the offset.\n+\tAdjust throughout for above change.\n+\t(Validate_Address_Clauses): Always use attributes of entities, not of\n+\ttheir type.  Tweak message for warning.  Call Has_Compatible_Alignment\n+\tif the address is offseted to warn about incompatible alignments.\n+\t* gcc-interface/gigi.h (annotate_object): Declare.\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity) <object>: Annotate renaming\n+\tentity.  Call annotate_object instead of annotating manually objects.\n+\t(annotate_object): New function.\n+\t* gcc-interface/trans.c (Subprogram_Body_to_gnu): Annotate parameters\n+\tat the end.\n+\n 2009-07-11  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/ada-tree.h: Minor reorganization."}, {"sha": "d08616193c43d34fdc0697b167628a456c0487ae", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 25, "deletions": 83, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4cd2542becd2e4a9b648587693906a0e64531dd/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4cd2542becd2e4a9b648587693906a0e64531dd/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=f4cd2542becd2e4a9b648587693906a0e64531dd", "patch": "@@ -532,26 +532,19 @@ package body Checks is\n       --  when Aexp is a reference to a constant, in which case Expr gets\n       --  reset to reference the value expression of the constant.\n \n-      Size_Warning_Output : Boolean := False;\n-      --  If we output a size warning we set this True, to stop generating\n-      --  what is likely to be an unuseful redundant alignment warning.\n-\n       procedure Compile_Time_Bad_Alignment;\n       --  Post error warnings when alignment is known to be incompatible. Note\n       --  that we do not go as far as inserting a raise of Program_Error since\n       --  this is an erroneous case, and it may happen that we are lucky and an\n-      --  underaligned address turns out to be OK after all. Also this warning\n-      --  is suppressed if we already complained about the size.\n+      --  underaligned address turns out to be OK after all.\n \n       --------------------------------\n       -- Compile_Time_Bad_Alignment --\n       --------------------------------\n \n       procedure Compile_Time_Bad_Alignment is\n       begin\n-         if not Size_Warning_Output\n-           and then Address_Clause_Overlay_Warnings\n-         then\n+         if Address_Clause_Overlay_Warnings then\n             Error_Msg_FE\n               (\"?specified address for& may be inconsistent with alignment \",\n                Aexp, E);\n@@ -565,7 +558,24 @@ package body Checks is\n    --  Start of processing for Apply_Address_Clause_Check\n \n    begin\n-      --  First obtain expression from address clause\n+      --  See if alignment check needed. Note that we never need a check if the\n+      --  maximum alignment is one, since the check will always succeed.\n+\n+      --  Note: we do not check for checks suppressed here, since that check\n+      --  was done in Sem_Ch13 when the address clause was processed. We are\n+      --  only called if checks were not suppressed. The reason for this is\n+      --  that we have to delay the call to Apply_Alignment_Check till freeze\n+      --  time (so that all types etc are elaborated), but we have to check\n+      --  the status of check suppressing at the point of the address clause.\n+\n+      if No (AC)\n+        or else not Check_Address_Alignment (AC)\n+        or else Maximum_Alignment = 1\n+      then\n+         return;\n+      end if;\n+\n+      --  Obtain expression from address clause\n \n       Expr := Expression (AC);\n \n@@ -603,69 +613,7 @@ package body Checks is\n          end if;\n       end loop;\n \n-      --  Output a warning if we have the situation of\n-\n-      --      for X'Address use Y'Address\n-\n-      --  and X and Y both have known object sizes, and Y is smaller than X\n-\n-      if Nkind (Expr) = N_Attribute_Reference\n-        and then Attribute_Name (Expr) = Name_Address\n-        and then Is_Entity_Name (Prefix (Expr))\n-      then\n-         declare\n-            Exp_Ent  : constant Entity_Id := Entity (Prefix (Expr));\n-            Obj_Size : Uint := No_Uint;\n-            Exp_Size : Uint := No_Uint;\n-\n-         begin\n-            if Known_Esize (E) then\n-               Obj_Size := Esize (E);\n-            elsif Known_Esize (Etype (E)) then\n-               Obj_Size := Esize (Etype (E));\n-            end if;\n-\n-            if Known_Esize (Exp_Ent) then\n-               Exp_Size := Esize (Exp_Ent);\n-            elsif Known_Esize (Etype (Exp_Ent)) then\n-               Exp_Size := Esize (Etype (Exp_Ent));\n-            end if;\n-\n-            if Obj_Size /= No_Uint\n-              and then Exp_Size /= No_Uint\n-              and then Obj_Size > Exp_Size\n-              and then not Has_Warnings_Off (E)\n-            then\n-               if Address_Clause_Overlay_Warnings then\n-                  Error_Msg_FE\n-                    (\"?& overlays smaller object\", Aexp, E);\n-                  Error_Msg_FE\n-                    (\"\\?program execution may be erroneous\", Aexp, E);\n-                  Size_Warning_Output := True;\n-                  Set_Address_Warning_Posted (AC);\n-               end if;\n-            end if;\n-         end;\n-      end if;\n-\n-      --  See if alignment check needed. Note that we never need a check if the\n-      --  maximum alignment is one, since the check will always succeed.\n-\n-      --  Note: we do not check for checks suppressed here, since that check\n-      --  was done in Sem_Ch13 when the address clause was processed. We are\n-      --  only called if checks were not suppressed. The reason for this is\n-      --  that we have to delay the call to Apply_Alignment_Check till freeze\n-      --  time (so that all types etc are elaborated), but we have to check\n-      --  the status of check suppressing at the point of the address clause.\n-\n-      if No (AC)\n-        or else not Check_Address_Alignment (AC)\n-        or else Maximum_Alignment = 1\n-      then\n-         return;\n-      end if;\n-\n-      --  See if we know that Expr is a bad alignment at compile time\n+      --  See if we know that Expr has a bad alignment at compile time\n \n       if Compile_Time_Known_Value (Expr)\n         and then (Known_Alignment (E) or else Known_Alignment (Typ))\n@@ -690,20 +638,14 @@ package body Checks is\n \n       --  If the expression has the form X'Address, then we can find out if\n       --  the object X has an alignment that is compatible with the object E.\n+      --  If it hasn't or we don't know, we defer issuing the warning until\n+      --  the end of the compilation to take into account back end annotations.\n \n       elsif Nkind (Expr) = N_Attribute_Reference\n         and then Attribute_Name (Expr) = Name_Address\n+        and then Has_Compatible_Alignment (E, Prefix (Expr)) = Known_Compatible\n       then\n-         declare\n-            AR : constant Alignment_Result :=\n-                   Has_Compatible_Alignment (E, Prefix (Expr));\n-         begin\n-            if AR = Known_Compatible then\n-               return;\n-            elsif AR = Known_Incompatible then\n-               Compile_Time_Bad_Alignment;\n-            end if;\n-         end;\n+         return;\n       end if;\n \n       --  Here we do not know if the value is acceptable. Stricly we don't have"}, {"sha": "67d8cd1b0c457d58407bd384af98559ba2af9f59", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 44, "deletions": 26, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4cd2542becd2e4a9b648587693906a0e64531dd/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4cd2542becd2e4a9b648587693906a0e64531dd/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=f4cd2542becd2e4a9b648587693906a0e64531dd", "patch": "@@ -905,6 +905,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t  mark_visited (&gnu_decl);\n \t\t\tsave_gnu_tree (gnat_entity, gnu_decl, true);\n \t\t\tsaved = true;\n+\t\t\tannotate_object (gnat_entity, gnu_type, NULL_TREE,\n+\t\t\t\t\t false);\n \t\t\tbreak;\n \t\t      }\n \n@@ -1382,32 +1384,15 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    && Exception_Mechanism != Back_End_Exceptions)\n \t  TREE_ADDRESSABLE (gnu_decl) = 1;\n \n-\tgnu_type = TREE_TYPE (gnu_decl);\n-\n-\t/* Back-annotate Alignment and Esize of the object if not already\n-\t   known, except for when the object is actually a pointer to the\n-\t   real object, since alignment and size of a pointer don't have\n-\t   anything to do with those of the designated object.  Note that\n-\t   we pick the values of the type, not those of the object, to\n-\t   shield ourselves from low-level platform-dependent adjustments\n-\t   like alignment promotion.  This is both consistent with all the\n-\t   treatment above, where alignment and size are set on the type of\n-\t   the object and not on the object directly, and makes it possible\n-\t   to support confirming representation clauses in all cases.  */\n-\n-\tif (!used_by_ref && Unknown_Alignment (gnat_entity))\n-\t  Set_Alignment (gnat_entity,\n-\t\t\t UI_From_Int (TYPE_ALIGN (gnu_type) / BITS_PER_UNIT));\n-\n-\tif (!used_by_ref && Unknown_Esize (gnat_entity))\n-\t  {\n-\t    if (TREE_CODE (gnu_type) == RECORD_TYPE\n-\t\t&& TYPE_CONTAINS_TEMPLATE_P (gnu_type))\n-\t      gnu_object_size\n-\t\t= TYPE_SIZE (TREE_TYPE (TREE_CHAIN (TYPE_FIELDS (gnu_type))));\n-\n-\t    Set_Esize (gnat_entity, annotate_value (gnu_object_size));\n-\t  }\n+\t/* Back-annotate Esize and Alignment of the object if not already\n+\t   known.  Note that we pick the values of the type, not those of\n+\t   the object, to shield ourselves from low-level platform-dependent\n+\t   adjustments like alignment promotion.  This is both consistent with\n+\t   all the treatment above, where alignment and size are set on the\n+\t   type of the object and not on the object directly, and makes it\n+\t   possible to support all confirming representation clauses.  */\n+\tannotate_object (gnat_entity, TREE_TYPE (gnu_decl), gnu_object_size,\n+\t\t\t used_by_ref);\n       }\n       break;\n \n@@ -7223,6 +7208,39 @@ annotate_value (tree gnu_size)\n   return ret;\n }\n \n+/* Given GNAT_ENTITY, an object (constant, variable, parameter, exception)\n+   and GNU_TYPE, its corresponding GCC type, set Esize and Alignment to the\n+   size and alignment used by Gigi.  Prefer SIZE over TYPE_SIZE if non-null.\n+   BY_REF is true if the object is used by reference.  */\n+\n+void\n+annotate_object (Entity_Id gnat_entity, tree gnu_type, tree size, bool by_ref)\n+{\n+  if (by_ref)\n+    {\n+      if (TYPE_FAT_POINTER_P (gnu_type))\n+\tgnu_type = TYPE_UNCONSTRAINED_ARRAY (gnu_type);\n+      else\n+\tgnu_type = TREE_TYPE (gnu_type);\n+    }\n+\n+  if (Unknown_Esize (gnat_entity))\n+    {\n+      if (TREE_CODE (gnu_type) == RECORD_TYPE\n+\t  && TYPE_CONTAINS_TEMPLATE_P (gnu_type))\n+\tsize = TYPE_SIZE (TREE_TYPE (TREE_CHAIN (TYPE_FIELDS (gnu_type))));\n+      else if (!size)\n+\tsize = TYPE_SIZE (gnu_type);\n+\n+      if (size)\n+\tSet_Esize (gnat_entity, annotate_value (size));\n+    }\n+\n+  if (Unknown_Alignment (gnat_entity))\n+    Set_Alignment (gnat_entity,\n+\t\t   UI_From_Int (TYPE_ALIGN (gnu_type) / BITS_PER_UNIT));\n+}\n+\n /* Given GNAT_ENTITY, a record type, and GNU_TYPE, its corresponding\n    GCC type, set Component_Bit_Offset and Esize to the position and size\n    used by Gigi.  */"}, {"sha": "de253b8d9390d77daec70d1c8c5c7f943827db62", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4cd2542becd2e4a9b648587693906a0e64531dd/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4cd2542becd2e4a9b648587693906a0e64531dd/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=f4cd2542becd2e4a9b648587693906a0e64531dd", "patch": "@@ -135,6 +135,13 @@ extern tree maybe_pad_type (tree type, tree size, unsigned int align,\n    the value passed against the list of choices.  */\n extern tree choices_to_gnu (tree operand, Node_Id choices);\n \n+/* Given GNAT_ENTITY, an object (constant, variable, parameter, exception)\n+   and GNU_TYPE, its corresponding GCC type, set Esize and Alignment to the\n+   size and alignment used by Gigi.  Prefer SIZE over TYPE_SIZE if non-null.\n+   BY_REF is true if the object is used by reference.  */\n+extern void annotate_object (Entity_Id gnat_entity, tree gnu_type, tree size,\n+\t\t\t     bool by_ref);\n+\n /* Given a type T, a FIELD_DECL F, and a replacement value R, return a new\n    type with all size expressions that contain F updated by replacing F\n    with R.  If F is NULL_TREE, always make a new RECORD_TYPE, even if"}, {"sha": "5b4e5e86318e8067f4f4552d07a3d9753d953479", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4cd2542becd2e4a9b648587693906a0e64531dd/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4cd2542becd2e4a9b648587693906a0e64531dd/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=f4cd2542becd2e4a9b648587693906a0e64531dd", "patch": "@@ -2328,13 +2328,18 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n \n   end_subprog_body (gnu_result, false);\n \n-  /* Disconnect the trees for parameters that we made variables for from the\n-     GNAT entities since these are unusable after we end the function.  */\n+  /* Finally annotate the parameters and disconnect the trees for parameters\n+     that we have turned into variables since they are now unusable.  */\n   for (gnat_param = First_Formal_With_Extras (gnat_subprog_id);\n        Present (gnat_param);\n        gnat_param = Next_Formal_With_Extras (gnat_param))\n-    if (TREE_CODE (get_gnu_tree (gnat_param)) == VAR_DECL)\n-      save_gnu_tree (gnat_param, NULL_TREE, false);\n+    {\n+      tree gnu_param = get_gnu_tree (gnat_param);\n+      annotate_object (gnat_param, TREE_TYPE (gnu_param), NULL_TREE,\n+\t\t       DECL_BY_REF_P (gnu_param));\n+      if (TREE_CODE (gnu_param) == VAR_DECL)\n+\tsave_gnu_tree (gnat_param, NULL_TREE, false);\n+    }\n \n   if (DECL_FUNCTION_STUB (gnu_subprog_decl))\n     build_function_stub (gnu_subprog_decl, gnat_subprog_id);"}, {"sha": "b763aa523cee0083569e89fb9c4e9aa46fb8c1cf", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 80, "deletions": 111, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4cd2542becd2e4a9b648587693906a0e64531dd/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4cd2542becd2e4a9b648587693906a0e64531dd/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=f4cd2542becd2e4a9b648587693906a0e64531dd", "patch": "@@ -87,9 +87,6 @@ package body Sem_Ch13 is\n    --  Attributes that do not specify a representation characteristic are\n    --  operational attributes.\n \n-   function Address_Aliased_Entity (N : Node_Id) return Entity_Id;\n-   --  If expression N is of the form E'Address, return E\n-\n    procedure New_Stream_Subprogram\n      (N    : Node_Id;\n       Ent  : Entity_Id;\n@@ -164,6 +161,9 @@ package body Sem_Ch13 is\n \n       Y : Entity_Id;\n       --  The entity of the object being overlaid\n+\n+      Off : Boolean;\n+      --  Whether the address is offseted within Y\n    end record;\n \n    package Address_Clause_Checks is new Table.Table (\n@@ -174,33 +174,6 @@ package body Sem_Ch13 is\n      Table_Increment      => 200,\n      Table_Name           => \"Address_Clause_Checks\");\n \n-   ----------------------------\n-   -- Address_Aliased_Entity --\n-   ----------------------------\n-\n-   function Address_Aliased_Entity (N : Node_Id) return Entity_Id is\n-   begin\n-      if Nkind (N) = N_Attribute_Reference\n-        and then Attribute_Name (N) = Name_Address\n-      then\n-         declare\n-            P : Node_Id;\n-\n-         begin\n-            P := Prefix (N);\n-            while Nkind_In (P, N_Selected_Component, N_Indexed_Component) loop\n-               P := Prefix (P);\n-            end loop;\n-\n-            if Is_Entity_Name (P) then\n-               return Entity (P);\n-            end if;\n-         end;\n-      end if;\n-\n-      return Empty;\n-   end Address_Aliased_Entity;\n-\n    -----------------------------------------\n    -- Adjust_Record_For_Reverse_Bit_Order --\n    -----------------------------------------\n@@ -906,24 +879,28 @@ package body Sem_Ch13 is\n               Ekind (U_Ent) = E_Constant\n             then\n                declare\n-                  Expr  : constant Node_Id   := Expression (N);\n-                  Aent  : constant Entity_Id := Address_Aliased_Entity (Expr);\n-                  Ent_Y : constant Entity_Id := Find_Overlaid_Object (N);\n+                  Expr  : constant Node_Id := Expression (N);\n+                  O_Ent : Entity_Id;\n+                  Off   : Boolean;\n \n                begin\n+\n                   --  Exported variables cannot have an address clause,\n                   --  because this cancels the effect of the pragma Export\n \n                   if Is_Exported (U_Ent) then\n                      Error_Msg_N\n                        (\"cannot export object with address clause\", Nam);\n                      return;\n+                  end if;\n+\n+                  Find_Overlaid_Entity (N, O_Ent, Off);\n \n                   --  Overlaying controlled objects is erroneous\n \n-                  elsif Present (Aent)\n-                    and then (Has_Controlled_Component (Etype (Aent))\n-                                or else Is_Controlled (Etype (Aent)))\n+                  if Present (O_Ent)\n+                    and then (Has_Controlled_Component (Etype (O_Ent))\n+                                or else Is_Controlled (Etype (O_Ent)))\n                   then\n                      Error_Msg_N\n                        (\"?cannot overlay with controlled object\", Expr);\n@@ -934,9 +911,9 @@ package body Sem_Ch13 is\n                          Reason => PE_Overlaid_Controlled_Object));\n                      return;\n \n-                  elsif Present (Aent)\n+                  elsif Present (O_Ent)\n                     and then Ekind (U_Ent) = E_Constant\n-                    and then not Is_Constant_Object (Aent)\n+                    and then not Is_Constant_Object (O_Ent)\n                   then\n                      Error_Msg_N (\"constant overlays a variable?\", Expr);\n \n@@ -964,10 +941,15 @@ package body Sem_Ch13 is\n                   --  Here we are checking for explicit overlap of one variable\n                   --  by another, and if we find this then mark the overlapped\n                   --  variable as also being volatile to prevent unwanted\n-                  --  optimizations.\n+                  --  optimizations. This is a significant pessimization so\n+                  --  avoid it when there is an offset, i.e. when the object\n+                  --  is composite; they cannot be optimized easily anyway.\n \n-                  if Present (Ent_Y) then\n-                     Set_Treat_As_Volatile (Ent_Y);\n+                  if Present (O_Ent)\n+                    and then Is_Object (O_Ent)\n+                    and then not Off\n+                  then\n+                     Set_Treat_As_Volatile (O_Ent);\n                   end if;\n \n                   --  Legality checks on the address clause for initialized\n@@ -1015,53 +997,42 @@ package body Sem_Ch13 is\n                   --  the variable, it is somewhere else.\n \n                   Kill_Size_Check_Code (U_Ent);\n-               end;\n-\n-               --  If the address clause is of the form:\n-\n-               --    for Y'Address use X'Address\n \n-               --  or\n+                  --  If the address clause is of the form:\n \n-               --    Const : constant Address := X'Address;\n-               --    ...\n-               --    for Y'Address use Const;\n+                  --    for Y'Address use X'Address\n \n-               --  then we make an entry in the table for checking the size and\n-               --  alignment of the overlaying variable. We defer this check\n-               --  till after code generation to take full advantage of the\n-               --  annotation done by the back end. This entry is only made if\n-               --  we have not already posted a warning about size/alignment\n-               --  (some warnings of this type are posted in Checks), and if\n-               --  the address clause comes from source.\n+                  --  or\n \n-               if Address_Clause_Overlay_Warnings\n-                 and then Comes_From_Source (N)\n-               then\n-                  declare\n-                     Ent_X : Entity_Id := Empty;\n-                     Ent_Y : Entity_Id := Empty;\n+                  --    Const : constant Address := X'Address;\n+                  --    ...\n+                  --    for Y'Address use Const;\n \n-                  begin\n-                     Ent_Y := Find_Overlaid_Object (N);\n+                  --  then we make an entry in the table for checking the size\n+                  --  and alignment of the overlaying variable. We defer this\n+                  --  check till after code generation to take full advantage\n+                  --  of the annotation done by the back end. This entry is\n+                  --  only made if the address clause comes from source.\n \n-                     if Present (Ent_Y) and then Is_Entity_Name (Name (N)) then\n-                        Ent_X := Entity (Name (N));\n-                        Address_Clause_Checks.Append ((N, Ent_X, Ent_Y));\n+                  if Address_Clause_Overlay_Warnings\n+                    and then Comes_From_Source (N)\n+                    and then Present (O_Ent)\n+                    and then Is_Object (O_Ent)\n+                  then\n+                     Address_Clause_Checks.Append ((N, U_Ent, O_Ent, Off));\n \n-                        --  If variable overlays a constant view, and we are\n-                        --  warning on overlays, then mark the variable as\n-                        --  overlaying a constant (we will give warnings later\n-                        --  if this variable is assigned).\n+                     --  If variable overlays a constant view, and we are\n+                     --  warning on overlays, then mark the variable as\n+                     --  overlaying a constant (we will give warnings later\n+                     --  if this variable is assigned).\n \n-                        if Is_Constant_Object (Ent_Y)\n-                          and then Ekind (Ent_X) = E_Variable\n-                        then\n-                           Set_Overlays_Constant (Ent_X);\n-                        end if;\n+                     if Is_Constant_Object (O_Ent)\n+                       and then Ekind (U_Ent) = E_Variable\n+                     then\n+                        Set_Overlays_Constant (U_Ent);\n                      end if;\n-                  end;\n-               end if;\n+                  end if;\n+               end;\n \n             --  Not a valid entity for an address clause\n \n@@ -4255,6 +4226,8 @@ package body Sem_Ch13 is\n             ACCR : Address_Clause_Check_Record\n                      renames Address_Clause_Checks.Table (J);\n \n+            Expr : Node_Id;\n+\n             X_Alignment : Uint;\n             Y_Alignment : Uint;\n \n@@ -4266,61 +4239,52 @@ package body Sem_Ch13 is\n \n             if not Address_Warning_Posted (ACCR.N) then\n \n-               --  Get alignments. Really we should always have the alignment\n-               --  of the objects properly back annotated, but right now the\n-               --  back end fails to back annotate for address clauses???\n+               Expr := Original_Node (Expression (ACCR.N));\n \n-               if Known_Alignment (ACCR.X) then\n-                  X_Alignment := Alignment (ACCR.X);\n-               else\n-                  X_Alignment := Alignment (Etype (ACCR.X));\n-               end if;\n+               --  Get alignments\n \n-               if Known_Alignment (ACCR.Y) then\n-                  Y_Alignment := Alignment (ACCR.Y);\n-               else\n-                  Y_Alignment := Alignment (Etype (ACCR.Y));\n-               end if;\n+               X_Alignment := Alignment (ACCR.X);\n+               Y_Alignment := Alignment (ACCR.Y);\n \n                --  Similarly obtain sizes\n \n-               if Known_Esize (ACCR.X) then\n-                  X_Size := Esize (ACCR.X);\n-               else\n-                  X_Size := Esize (Etype (ACCR.X));\n-               end if;\n-\n-               if Known_Esize (ACCR.Y) then\n-                  Y_Size := Esize (ACCR.Y);\n-               else\n-                  Y_Size := Esize (Etype (ACCR.Y));\n-               end if;\n+               X_Size := Esize (ACCR.X);\n+               Y_Size := Esize (ACCR.Y);\n \n                --  Check for large object overlaying smaller one\n \n                if Y_Size > Uint_0\n                  and then X_Size > Uint_0\n                  and then X_Size > Y_Size\n                then\n+                  Error_Msg_NE\n+                    (\"?& overlays smaller object\", ACCR.N, ACCR.X);\n                   Error_Msg_N\n-                    (\"?size for overlaid object is too small\", ACCR.N);\n+                    (\"\\?program execution may be erroneous\", ACCR.N);\n                   Error_Msg_Uint_1 := X_Size;\n                   Error_Msg_NE\n                     (\"\\?size of & is ^\", ACCR.N, ACCR.X);\n                   Error_Msg_Uint_1 := Y_Size;\n                   Error_Msg_NE\n                     (\"\\?size of & is ^\", ACCR.N, ACCR.Y);\n \n-                  --  Check for inadequate alignment. Again the defensive check\n-                  --  on Y_Alignment should not be needed, but because of the\n-                  --  failure in back end annotation, we can have an alignment\n-                  --  of 0 here???\n+               --  Check for inadequate alignment, both of the base object\n+               --  and of the offset, if any.\n \n-                  --  Note: we do not check alignments if we gave a size\n-                  --  warning, since it would likely be redundant.\n+               --  Note: we do not check the alignment if we gave a size\n+               --  warning, since it would likely be redundant.\n \n                elsif Y_Alignment /= Uint_0\n-                 and then Y_Alignment < X_Alignment\n+                 and then (Y_Alignment < X_Alignment\n+                             or else (ACCR.Off\n+                                        and then\n+                                          Nkind (Expr) = N_Attribute_Reference\n+                                        and then\n+                                          Attribute_Name (Expr) = Name_Address\n+                                        and then\n+                                          Has_Compatible_Alignment\n+                                            (ACCR.X, Prefix (Expr))\n+                                             /= Known_Compatible))\n                then\n                   Error_Msg_NE\n                     (\"?specified address for& may be inconsistent \"\n@@ -4337,6 +4301,11 @@ package body Sem_Ch13 is\n                   Error_Msg_NE\n                     (\"\\?alignment of & is ^\",\n                      ACCR.N, ACCR.Y);\n+                  if Y_Alignment >= X_Alignment then\n+                     Error_Msg_N\n+                      (\"\\?but offset is not multiple of alignment\",\n+                       ACCR.N);\n+                  end if;\n                end if;\n             end if;\n          end;"}, {"sha": "5ff2d7c034116c88ce608b0b72e2eb38f0f50941", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 117, "deletions": 77, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4cd2542becd2e4a9b648587693906a0e64531dd/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4cd2542becd2e4a9b648587693906a0e64531dd/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=f4cd2542becd2e4a9b648587693906a0e64531dd", "patch": "@@ -2892,11 +2892,15 @@ package body Sem_Util is\n    end Find_Corresponding_Discriminant;\n \n    --------------------------\n-   -- Find_Overlaid_Object --\n+   -- Find_Overlaid_Entity --\n    --------------------------\n \n-   function Find_Overlaid_Object (N : Node_Id) return Entity_Id is\n-      Expr  : Node_Id;\n+   procedure Find_Overlaid_Entity\n+     (N : Node_Id;\n+      Ent : out Entity_Id;\n+      Off : out Boolean)\n+   is\n+      Expr : Node_Id;\n \n    begin\n       --  We are looking for one of the two following forms:\n@@ -2912,24 +2916,25 @@ package body Sem_Util is\n       --  In the second case, the expr is either Y'Address, or recursively a\n       --  constant that eventually references Y'Address.\n \n+      Ent := Empty;\n+      Off := False;\n+\n       if Nkind (N) = N_Attribute_Definition_Clause\n         and then Chars (N) = Name_Address\n       then\n-         --  This loop checks the form of the expression for Y'Address where Y\n-         --  is an object entity name. The first loop checks the original\n-         --  expression in the attribute definition clause. Subsequent loops\n-         --  check referenced constants.\n-\n          Expr := Expression (N);\n+\n+         --  This loop checks the form of the expression for Y'Address,\n+         --  using recursion to deal with intermediate constants.\n+\n          loop\n-            --  Check for Y'Address where Y is an object entity\n+            --  Check for Y'Address\n \n             if Nkind (Expr) = N_Attribute_Reference\n               and then Attribute_Name (Expr) = Name_Address\n-              and then Is_Entity_Name (Prefix (Expr))\n-              and then Is_Object (Entity (Prefix (Expr)))\n             then\n-               return Entity (Prefix (Expr));\n+               Expr := Prefix (Expr);\n+               exit;\n \n                --  Check for Const where Const is a constant entity\n \n@@ -2941,13 +2946,36 @@ package body Sem_Util is\n             --  Anything else does not need checking\n \n             else\n-               exit;\n+               return;\n             end if;\n          end loop;\n-      end if;\n \n-      return Empty;\n-   end Find_Overlaid_Object;\n+         --  This loop checks the form of the prefix for an entity,\n+         --  using recursion to deal with intermediate components.\n+\n+         loop\n+            --  Check for Y where Y is an entity\n+\n+            if Is_Entity_Name (Expr) then\n+               Ent := Entity (Expr);\n+               return;\n+\n+            --  Check for components\n+\n+            elsif\n+               Nkind_In (Expr, N_Selected_Component, N_Indexed_Component) then\n+\n+               Expr := Prefix (Expr);\n+               Off := True;\n+\n+            --  Anything else does not need checking\n+\n+            else\n+               return;\n+            end if;\n+         end loop;\n+      end if;\n+   end Find_Overlaid_Entity;\n \n    -------------------------\n    -- Find_Parameter_Type --\n@@ -3829,16 +3857,16 @@ package body Sem_Util is\n          Default : Alignment_Result) return Alignment_Result\n       is\n          Result : Alignment_Result := Known_Compatible;\n-         --  Set to result if Problem_Prefix or Problem_Offset returns True.\n-         --  Note that once a value of Known_Incompatible is set, it is sticky\n-         --  and does not get changed to Unknown (the value in Result only gets\n-         --  worse as we go along, never better).\n+         --  Holds the current status of the result. Note that once a value of\n+         --  Known_Incompatible is set, it is sticky and does not get changed\n+         --  to Unknown (the value in Result only gets worse as we go along,\n+         --  never better).\n \n-         procedure Check_Offset (Offs : Uint);\n-         --  Called when Expr is a selected or indexed component with Offs set\n-         --  to resp Component_First_Bit or Component_Size. Checks that if the\n-         --  offset is specified it is compatible with the object alignment\n-         --  requirements. The value in Result is modified accordingly.\n+         Offs : Uint := No_Uint;\n+         --  Set to a factor of the offset from the base object when Expr is a\n+         --  selected or indexed component, based on Component_Bit_Offset and\n+         --  Component_Size respectively. A negative value is used to represent\n+         --  a value which is not known at compile time.\n \n          procedure Check_Prefix;\n          --  Checks the prefix recursively in the case where the expression\n@@ -3848,33 +3876,6 @@ package body Sem_Util is\n          --  If R represents a worse outcome (unknown instead of known\n          --  compatible, or known incompatible), then set Result to R.\n \n-         ------------------\n-         -- Check_Offset --\n-         ------------------\n-\n-         procedure Check_Offset (Offs : Uint) is\n-         begin\n-            --  Unspecified or zero offset is always OK\n-\n-            if Offs = No_Uint or else Offs = Uint_0 then\n-               null;\n-\n-            --  If we do not know required alignment, any non-zero offset is\n-            --  a potential problem (but certainly may be OK, so result is\n-            --  unknown).\n-\n-            elsif Unknown_Alignment (Obj) then\n-               Set_Result (Unknown);\n-\n-            --  If we know the required alignment, see if offset is compatible\n-\n-            else\n-               if Offs mod (System_Storage_Unit * Alignment (Obj)) /= 0 then\n-                  Set_Result (Known_Incompatible);\n-               end if;\n-            end if;\n-         end Check_Offset;\n-\n          ------------------\n          -- Check_Prefix --\n          ------------------\n@@ -3940,33 +3941,55 @@ package body Sem_Util is\n                Set_Result (Unknown);\n             end if;\n \n-            --  Check possible bad component offset and check prefix\n+            --  Check prefix and component offset\n \n-            Check_Offset\n-              (Component_Bit_Offset (Entity (Selector_Name (Expr))));\n             Check_Prefix;\n+            Offs := Component_Bit_Offset (Entity (Selector_Name (Expr)));\n \n          --  If Expr is an indexed component, we must make sure there is no\n          --  potentially troublesome Component_Size clause and that the array\n          --  is not bit-packed.\n \n          elsif Nkind (Expr) = N_Indexed_Component then\n+            declare\n+               Typ : constant Entity_Id := Etype (Prefix (Expr));\n+               Ind : constant Node_Id := First_Index (Typ);\n+            begin\n+               --  Bit packed array always generates unknown alignment\n \n-            --  Bit packed array always generates unknown alignment\n+               if Is_Bit_Packed_Array (Typ) then\n+                  Set_Result (Unknown);\n+               end if;\n \n-            if Is_Bit_Packed_Array (Etype (Prefix (Expr))) then\n-               Set_Result (Unknown);\n-            end if;\n+               --  Check prefix and component offset\n \n-            --  Check possible bad component size and check prefix\n+               Check_Prefix;\n+               Offs := Component_Size (Typ);\n \n-            Check_Offset (Component_Size (Etype (Prefix (Expr))));\n-            Check_Prefix;\n+               --  Small optimization: compute the full offset when possible\n+\n+               if Offs /= No_Uint\n+                 and then Offs > Uint_0\n+                 and then Present (Ind)\n+                 and then Nkind (Ind) = N_Range\n+                 and then Compile_Time_Known_Value (Low_Bound (Ind))\n+                 and then Compile_Time_Known_Value (First (Expressions (Expr)))\n+               then\n+                  Offs := Offs * (Expr_Value (First (Expressions (Expr)))\n+                                    - Expr_Value (Low_Bound ((Ind))));\n+               end if;\n+            end;\n          end if;\n \n+         --  If we have a null offset, the result is entirely determined by\n+         --  the base object and has already been computed recursively.\n+\n+         if Offs = Uint_0 then\n+            null;\n+\n          --  Case where we know the alignment of the object\n \n-         if Known_Alignment (Obj) then\n+         elsif Known_Alignment (Obj) then\n             declare\n                ObjA : constant Uint := Alignment (Obj);\n                ExpA : Uint := No_Uint;\n@@ -3981,9 +4004,16 @@ package body Sem_Util is\n                --  Alignment of Obj is greater than 1, so we need to check\n \n                else\n-                  --  See if Expr is an object with known alignment\n+                  --  If we have an offset, see if it is compatible\n \n-                  if Is_Entity_Name (Expr)\n+                  if Offs /= No_Uint and Offs > Uint_0 then\n+                     if Offs mod (System_Storage_Unit * ObjA) /= 0 then\n+                        Set_Result (Known_Incompatible);\n+                     end if;\n+\n+                     --  See if Expr is an object with known alignment\n+\n+                  elsif Is_Entity_Name (Expr)\n                     and then Known_Alignment (Entity (Expr))\n                   then\n                      ExpA := Alignment (Entity (Expr));\n@@ -3995,26 +4025,29 @@ package body Sem_Util is\n \n                   elsif Known_Alignment (Etype (Expr)) then\n                      ExpA := Alignment (Etype (Expr));\n+\n+                     --  Otherwise the alignment is unknown\n+\n+                  else\n+                     Set_Result (Default);\n                   end if;\n \n                   --  If we got an alignment, see if it is acceptable\n \n-                  if ExpA /= No_Uint then\n-                     if ExpA < ObjA then\n-                        Set_Result (Known_Incompatible);\n-                     end if;\n+                  if ExpA /= No_Uint and then ExpA < ObjA then\n+                     Set_Result (Known_Incompatible);\n+                  end if;\n \n-                     --  Case of Expr alignment unknown\n+                  --  If Expr is not a piece of a larger object, see if size\n+                  --  is given. If so, check that it is not too small for the\n+                  --  required alignment.\n \n-                  else\n-                     Set_Result (Default);\n-                  end if;\n+                  if Offs /= No_Uint then\n+                     null;\n \n-                  --  See if size is given. If so, check that it is not too\n-                  --  small for the required alignment.\n-                  --  See if Expr is an object with known alignment\n+                     --  See if Expr is an object with known size\n \n-                  if Is_Entity_Name (Expr)\n+                  elsif Is_Entity_Name (Expr)\n                     and then Known_Static_Esize (Entity (Expr))\n                   then\n                      SizA := Esize (Entity (Expr));\n@@ -4038,6 +4071,13 @@ package body Sem_Util is\n                end if;\n             end;\n \n+         --  If we do not know required alignment, any non-zero offset is\n+         --  a potential problem (but certainly may be OK, so result is\n+         --  unknown).\n+\n+         elsif Offs /= No_Uint then\n+            Set_Result (Unknown);\n+\n          --  If we can't find the result by direct comparison of alignment\n          --  values, then there is still one case that we can determine known\n          --  result, and that is when we can determine that the types are the"}, {"sha": "1d836843513b93e4ed4b989a91c5ab68dedfcbb1", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4cd2542becd2e4a9b648587693906a0e64531dd/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4cd2542becd2e4a9b648587693906a0e64531dd/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=f4cd2542becd2e4a9b648587693906a0e64531dd", "patch": "@@ -320,12 +320,16 @@ package Sem_Util is\n    --  denotes when analyzed. Subsequent uses of this id on a different\n    --  type denote the discriminant at the same position in this new type.\n \n-   function Find_Overlaid_Object (N : Node_Id) return Entity_Id;\n-   --  The node N should be an address representation clause. This function\n-   --  checks if the target expression is the address of some stand alone\n-   --  object (variable or constant), and if so, returns its entity. If N is\n-   --  not an address representation clause, or if it is not possible to\n-   --  determine that the address is of this form, then Empty is returned.\n+   procedure Find_Overlaid_Entity\n+     (N : Node_Id;\n+      Ent : out Entity_Id;\n+      Off : out Boolean);\n+   --  The node N should be an address representation clause. Determines if\n+   --  the target expression is the address of an entity with an optional\n+   --  offset. If so, set Ent to the entity and, if there is an offset, set\n+   --  Off to True, otherwise to False. If N is not an address representation\n+   --  clause, or if it is not possible to determine that the address is of\n+   --  this form, then set Ent to Empty.\n \n    function Find_Parameter_Type (Param : Node_Id) return Entity_Id;\n    --  Return the type of formal parameter Param as determined by its"}, {"sha": "5fd1d6b5cdb5047729bb6d6fa4b68d0da4a45735", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4cd2542becd2e4a9b648587693906a0e64531dd/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4cd2542becd2e4a9b648587693906a0e64531dd/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f4cd2542becd2e4a9b648587693906a0e64531dd", "patch": "@@ -1,3 +1,7 @@\n+2009-07-11  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/specs/addr1.ads: New test.\n+\n 2009-07-11  Jan Hubicka  <jh@suse.cz>\n \n \tPR middle-end/48388"}, {"sha": "83d432cff58406635966f06e5cdd10cd6d2e0632", "filename": "gcc/testsuite/gnat.dg/specs/addr1.ads", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4cd2542becd2e4a9b648587693906a0e64531dd/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Faddr1.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4cd2542becd2e4a9b648587693906a0e64531dd/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Faddr1.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Faddr1.ads?ref=f4cd2542becd2e4a9b648587693906a0e64531dd", "patch": "@@ -0,0 +1,35 @@\n+-- { dg-do compile }\n+\n+with Interfaces; use Interfaces;\n+\n+package Addr1 is\n+\n+  type Arr is array (Integer range <>) of Unsigned_16;\n+\n+  type Rec1 is record\n+    I1, I2: Integer;\n+  end record;\n+\n+  type Rec2 is record\n+    I1, I2: Integer;\n+  end record;\n+  for Rec2'Size use 64;\n+\n+  A: Arr (1 .. 12);\n+\n+  Obj1: Rec1;\n+  for Obj1'Address use A'Address; -- { dg-bogus \"alignment\" }\n+\n+  Obj2: Rec2;\n+  for Obj2'Address use A'Address; -- { dg-bogus \"alignment\" }\n+\n+  Obj3: Rec1;\n+  for Obj3'Address use A(1)'Address; -- { dg-bogus \"alignment\" }\n+\n+  Obj4: Rec1;\n+  for Obj4'Address use A(2)'Address; -- { dg-warning \"(alignment|erroneous)\" }\n+\n+  Obj5: Rec1;\n+  for Obj5'Address use A(3)'Address; -- { dg-bogus \"alignment\" }\n+\n+end Addr1;"}]}