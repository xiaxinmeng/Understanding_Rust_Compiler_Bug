{"sha": "7c34ced1a25f62ed12b1bf1158167fe157b60ae7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2MzNGNlZDFhMjVmNjJlZDEyYjFiZjExNTgxNjdmZTE1N2I2MGFlNw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-06-19T19:34:23Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-06-19T19:34:23Z"}, "message": "c-common.c, c-common.h (lang_gimplify_stmt): Remove.\n\n        * c-common.c, c-common.h (lang_gimplify_stmt): Remove.\n        * c-gimplify.c: Remove unnecessary prototypes.\n        (c_gimplify_stmt): Merge into ...\n        (c_gimplify_expr): ... here.  Don't play with prep_stmt.\n        * c-semantics.c (prep_stmt): Remove.\n        * gimplify.c (annotate_one_with_locus): Break out from ...\n        (annotate_all_with_locus): ... here.\n        (gimplify_expr): Add locus to expressions even if pre/post queues\n        are not present.\ncp/\n        * cp-gimplify.c: Remove unnecessary prototypes.\n        (cp_gimplify_stmt): Merge into ...\n        (cp_gimplify_expr): ... here.  Move to end of file.  Handle\n        stmts_are_full_exprs_p frobbing.\n        * cp-tree.h (cp_gimplify_stmt): Remove.\n        * pt.c (tsubst_expr): Merge prep_stmt and unify.\n        * tree.c (init_tree): Don't set lang_gimplify_stmt.\n\nFrom-SVN: r83397", "tree": {"sha": "8c9a0bb986a33bc83bc0dbbec28fa39603c3a2c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8c9a0bb986a33bc83bc0dbbec28fa39603c3a2c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7c34ced1a25f62ed12b1bf1158167fe157b60ae7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c34ced1a25f62ed12b1bf1158167fe157b60ae7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c34ced1a25f62ed12b1bf1158167fe157b60ae7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c34ced1a25f62ed12b1bf1158167fe157b60ae7/comments", "author": null, "committer": null, "parents": [{"sha": "ebca59c355524893ef3facf6ad12074e4661348e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebca59c355524893ef3facf6ad12074e4661348e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebca59c355524893ef3facf6ad12074e4661348e"}], "stats": {"total": 571, "additions": 225, "deletions": 346}, "files": [{"sha": "03764bbc62e9ff366d5f85ab4833f325adc86e06", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c34ced1a25f62ed12b1bf1158167fe157b60ae7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c34ced1a25f62ed12b1bf1158167fe157b60ae7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7c34ced1a25f62ed12b1bf1158167fe157b60ae7", "patch": "@@ -1,3 +1,15 @@\n+2004-04-19  Richard Henderson  <rth@redhat.com>\n+\n+\t* c-common.c, c-common.h (lang_gimplify_stmt): Remove.\n+\t* c-gimplify.c: Remove unnecessary prototypes.\n+\t(c_gimplify_stmt): Merge into ...\n+\t(c_gimplify_expr): ... here.  Don't play with prep_stmt.\n+\t* c-semantics.c (prep_stmt): Remove.\n+\t* gimplify.c (annotate_one_with_locus): Break out from ...\n+\t(annotate_all_with_locus): ... here.\n+\t(gimplify_expr): Add locus to expressions even if pre/post queues\n+\tare not present.\n+\n 2004-06-19  Richard Henderson  <rth@redhat.com>\n \n \tPR target/15941"}, {"sha": "a982852482d10dbf30f52bfb551e5efac381bc83", "filename": "gcc/c-common.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c34ced1a25f62ed12b1bf1158167fe157b60ae7/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c34ced1a25f62ed12b1bf1158167fe157b60ae7/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=7c34ced1a25f62ed12b1bf1158167fe157b60ae7", "patch": "@@ -690,11 +690,6 @@ tree (*make_fname_decl) (tree, int);\n    returns 1 for language-specific statement codes.  */\n int (*lang_statement_code_p) (enum tree_code);\n \n-/* If non-NULL, the address of a language-specific function that does any\n-   language-specific gimplification for _STMT nodes and returns 1 iff\n-   handled.  */\n-int (*lang_gimplify_stmt) (tree *);\n-\n /* If non-NULL, the address of a language-specific function that takes\n    any action required right before expand_function_end is called.  */\n void (*lang_expand_function_end) (void);"}, {"sha": "b1c49b1eed9e797acdbc0ceca4d84c9cdf2c2a36", "filename": "gcc/c-common.h", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c34ced1a25f62ed12b1bf1158167fe157b60ae7/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c34ced1a25f62ed12b1bf1158167fe157b60ae7/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=7c34ced1a25f62ed12b1bf1158167fe157b60ae7", "patch": "@@ -280,7 +280,6 @@ struct c_language_function GTY(()) {\n \n /* Language-specific hooks.  */\n \n-extern int (*lang_gimplify_stmt) (tree *);\n extern void (*lang_expand_function_end) (void);\n \n /* Callback that determines if it's ok for a function to have no\n@@ -299,7 +298,6 @@ extern void add_decl_stmt (tree);\n extern void push_cleanup (tree, tree, bool);\n \n extern tree walk_stmt_tree (tree *, walk_tree_fn, void *);\n-extern void prep_stmt (tree);\n extern int c_expand_decl (tree);\n \n extern int field_decl_cmp (const void *, const void *);\n@@ -1113,14 +1111,13 @@ extern void dump_time_statistics (void);\n \n extern bool c_dump_tree (void *, tree);\n \n-extern int c_gimplify_expr (tree *, tree *, tree *);\n extern tree c_walk_subtrees (tree*, int*, walk_tree_fn, void*, void*);\n \n extern void c_warn_unused_result (tree *);\n \n-/* In c-simplify.c  */\n+/* In c-gimplify.c  */\n extern void c_genericize (tree);\n-extern int c_gimplify_stmt (tree *);\n+extern int c_gimplify_expr (tree *, tree *, tree *);\n extern tree c_build_bind_expr (tree, tree);\n \n extern void pch_init (void);"}, {"sha": "1f8ce647b9d27c62e7a2ccd95917421efc983392", "filename": "gcc/c-gimplify.c", "status": "modified", "additions": 33, "deletions": 137, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c34ced1a25f62ed12b1bf1158167fe157b60ae7/gcc%2Fc-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c34ced1a25f62ed12b1bf1158167fe157b60ae7/gcc%2Fc-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-gimplify.c?ref=7c34ced1a25f62ed12b1bf1158167fe157b60ae7", "patch": "@@ -72,25 +72,9 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n /* Local declarations.  */\n \n-static enum gimplify_status gimplify_expr_stmt (tree *);\n-static enum gimplify_status gimplify_decl_stmt (tree *);\n-static enum gimplify_status gimplify_for_stmt (tree *, tree *);\n-static enum gimplify_status gimplify_while_stmt (tree *);\n-static enum gimplify_status gimplify_do_stmt (tree *);\n-static enum gimplify_status gimplify_if_stmt (tree *);\n-static enum gimplify_status gimplify_switch_stmt (tree *);\n-static enum gimplify_status gimplify_return_stmt (tree *);\n-static enum gimplify_status gimplify_compound_literal_expr (tree *);\n static void gimplify_cleanup_stmts (tree);\n-static tree gimplify_c_loop (tree, tree, tree, bool);\n-static void push_context (void);\n-static void pop_context (void);\n-static void add_block_to_enclosing (tree);\n \n enum bc_t { bc_break = 0, bc_continue = 1 };\n-static tree begin_bc_block (enum bc_t);\n-static tree finish_bc_block (tree, tree);\n-static tree build_bc_goto (enum bc_t);\n \n static struct c_gimplify_ctx\n {\n@@ -192,122 +176,6 @@ gimplify_cleanup_stmts (tree fndecl)\n   walk_tree (&DECL_SAVED_TREE (fndecl), gimplify_cleanup_stmt, NULL, NULL);\n }\n \n-/*  Entry point for the tree lowering pass.  Recursively scan\n-    *STMT_P and convert it to a GIMPLE tree.  */\n-\n-int\n-c_gimplify_stmt (tree *stmt_p)\n-{\n-  tree stmt = *stmt_p;\n-  tree pre, post;\n-  int saved_stmts_are_full_exprs_p;\n-  location_t stmt_locus;\n-  enum gimplify_status ret;\n-\n-  /* PRE and POST are tree chains that contain the side-effects of the\n-     gimplified tree.  For instance, given the expression tree:\n-\n-\t\tc = ++a * 3 + b++;\n-\n-     After gimplification, the tree will be re-written as:\n-\n-\t\ta = a + 1;\n-\t\tt1 = a * 3;\t<-- PRE\n-\t\tc = t1 + b;\n-\t\tb = b + 1;\t<-- POST  */\n-\n-  /* Set up context appropriately for handling this statement.  */\n-  saved_stmts_are_full_exprs_p = stmts_are_full_exprs_p ();\n-  prep_stmt (stmt);\n-  stmt_locus = input_location;\n-\n-  pre = NULL_TREE;\n-  post = NULL_TREE;\n-\n-  switch (TREE_CODE (stmt))\n-    {\n-    case FOR_STMT:\n-      ret = gimplify_for_stmt (&stmt, &pre);\n-      break;\n-\n-    case WHILE_STMT:\n-      ret = gimplify_while_stmt (&stmt);\n-      break;\n-\n-    case DO_STMT:\n-      ret = gimplify_do_stmt (&stmt);\n-      break;\n-\n-    case IF_STMT:\n-      ret = gimplify_if_stmt (&stmt);\n-      break;\n-\n-    case SWITCH_STMT:\n-      ret = gimplify_switch_stmt (&stmt);\n-      break;\n-\n-    case EXPR_STMT:\n-      ret = gimplify_expr_stmt (&stmt);\n-      break;\n-\n-    case RETURN_STMT:\n-      ret = gimplify_return_stmt (&stmt);\n-      break;\n-\n-    case DECL_STMT:\n-      ret = gimplify_decl_stmt (&stmt);\n-      break;\n-\n-    case CONTINUE_STMT:\n-      stmt = build_bc_goto (bc_continue);\n-      ret = GS_OK;\n-      break;\n-\n-    case BREAK_STMT:\n-      stmt = build_bc_goto (bc_break);\n-      ret = GS_OK;\n-      break;\n-\n-    default:\n-      if (lang_gimplify_stmt && (*lang_gimplify_stmt) (&stmt))\n-\t{\n-\t  ret = GS_OK;\n-\t  break;\n-\t}\n-\n-      fprintf (stderr, \"unhandled statement node in c_gimplify_stmt:\\n\");\n-      debug_tree (stmt);\n-      abort ();\n-      break;\n-    }\n-\n-  switch (ret)\n-    {\n-    case GS_ERROR:\n-      goto cont;\n-    case GS_OK:\n-      gimplify_stmt (&stmt);\n-      break;\n-    case GS_ALL_DONE:\n-      break;\n-    default:\n-      abort ();\n-    }\n-\n-  /* PRE and POST now contain a list of statements for all the\n-     side-effects in STMT.  */\n-\n-  append_to_statement_list (stmt, &pre);\n-  append_to_statement_list (post, &pre);\n-  annotate_all_with_locus (&pre, stmt_locus);\n- cont:\n-  /* Restore saved state.  */\n-  current_stmt_tree ()->stmts_are_full_exprs_p = saved_stmts_are_full_exprs_p;\n-  *stmt_p = pre;\n-\n-  return GS_ALL_DONE;\n-}\n-\n static void\n add_block_to_enclosing (tree block)\n {\n@@ -784,19 +652,47 @@ gimplify_compound_literal_expr (tree *expr_p)\n /* Do C-specific gimplification.  Args are as for gimplify_expr.  */\n \n int\n-c_gimplify_expr (tree *expr_p, tree *pre_p ATTRIBUTE_UNUSED,\n-\t\t tree *post_p ATTRIBUTE_UNUSED)\n+c_gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p ATTRIBUTE_UNUSED)\n {\n   enum tree_code code = TREE_CODE (*expr_p);\n \n-  if (STATEMENT_CODE_P (code))\n-    return c_gimplify_stmt (expr_p);\n-\n   switch (code)\n     {\n     case COMPOUND_LITERAL_EXPR:\n       return gimplify_compound_literal_expr (expr_p);\n \n+    case FOR_STMT:\n+      return gimplify_for_stmt (expr_p, pre_p);\n+\n+    case WHILE_STMT:\n+      return gimplify_while_stmt (expr_p);\n+\n+    case DO_STMT:\n+      return gimplify_do_stmt (expr_p);\n+\n+    case IF_STMT:\n+      return gimplify_if_stmt (expr_p);\n+\n+    case SWITCH_STMT:\n+      return gimplify_switch_stmt (expr_p);\n+\n+    case EXPR_STMT:\n+      return gimplify_expr_stmt (expr_p);\n+\n+    case RETURN_STMT:\n+      return gimplify_return_stmt (expr_p);\n+\n+    case DECL_STMT:\n+      return gimplify_decl_stmt (expr_p);\n+\n+    case CONTINUE_STMT:\n+      *expr_p = build_bc_goto (bc_continue);\n+      return GS_ALL_DONE;\n+\n+    case BREAK_STMT:\n+      *expr_p = build_bc_goto (bc_break);\n+      return GS_ALL_DONE;\n+\n     default:\n       return GS_UNHANDLED;\n     }"}, {"sha": "8a98e07b3a3d367fb99ff8f136a41f8c1b7d9c89", "filename": "gcc/c-semantics.c", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c34ced1a25f62ed12b1bf1158167fe157b60ae7/gcc%2Fc-semantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c34ced1a25f62ed12b1bf1158167fe157b60ae7/gcc%2Fc-semantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-semantics.c?ref=7c34ced1a25f62ed12b1bf1158167fe157b60ae7", "patch": "@@ -304,14 +304,3 @@ build_case_label (tree low_value, tree high_value, tree label_decl)\n {\n   return build_stmt (CASE_LABEL_EXPR, low_value, high_value, label_decl);\n }\n-\n-/* We're about to expand T, a statement.  Set up appropriate context\n-   for the substitution.  */\n-\n-void\n-prep_stmt (tree t)\n-{\n-  if (EXPR_LOCUS (t))\n-    input_location = *EXPR_LOCUS (t);\n-  current_stmt_tree ()->stmts_are_full_exprs_p = STMT_IS_FULL_EXPR_P (t);\n-}"}, {"sha": "73ead051906db0bc566b27dd16e1d785c0399571", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c34ced1a25f62ed12b1bf1158167fe157b60ae7/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c34ced1a25f62ed12b1bf1158167fe157b60ae7/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=7c34ced1a25f62ed12b1bf1158167fe157b60ae7", "patch": "@@ -1,3 +1,13 @@\n+2004-06-19  Richard Henderson  <rth@redhat.com>\n+\n+\t* cp-gimplify.c: Remove unnecessary prototypes.\n+\t(cp_gimplify_stmt): Merge into ...\n+\t(cp_gimplify_expr): ... here.  Move to end of file.  Handle\n+\tstmts_are_full_exprs_p frobbing.\n+\t* cp-tree.h (cp_gimplify_stmt): Remove.\n+\t* pt.c (tsubst_expr): Merge prep_stmt and unify.\n+\t* tree.c (init_tree): Don't set lang_gimplify_stmt.\n+\n 2004-06-18  Richard Henderson  <rth@redhat.com>\n \n \tPR c++/16034"}, {"sha": "99016434e42eb1a403a74d7a5c373e4265f16f15", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 96, "deletions": 85, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c34ced1a25f62ed12b1bf1158167fe157b60ae7/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c34ced1a25f62ed12b1bf1158167fe157b60ae7/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=7c34ced1a25f62ed12b1bf1158167fe157b60ae7", "patch": "@@ -30,43 +30,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"toplev.h\"\n #include \"tree-gimple.h\"\n \n-static void genericize_try_block (tree *);\n-static void genericize_catch_block (tree *);\n-static void genericize_eh_spec_block (tree *);\n-static void gimplify_must_not_throw_expr (tree *, tree *);\n-static void cp_gimplify_init_expr (tree *, tree *, tree *);\n-\n-/* Genericize a C++ _STMT.  Called from c_gimplify_stmt.  */\n-\n-int\n-cp_gimplify_stmt (tree *stmt_p)\n-{\n-  tree stmt = *stmt_p;\n-  switch (TREE_CODE (stmt))\n-    {\n-    case TRY_BLOCK:\n-      genericize_try_block (stmt_p);\n-      return 1;\n-\n-    case HANDLER:\n-      genericize_catch_block (stmt_p);\n-      return 1;\n-\n-    case EH_SPEC_BLOCK:\n-      genericize_eh_spec_block (stmt_p);\n-      return 1;\n-\n-    case USING_STMT:\n-      /* Just ignore for now.  Eventually we will want to pass this on to\n-\t the debugger.  */\n-      *stmt_p = build_empty_stmt ();\n-      return 1;\n-\n-    default:\n-      break;\n-    }\n-  return 0;\n-}\n \n /* Genericize a TRY_BLOCK.  */\n \n@@ -116,54 +79,6 @@ genericize_eh_spec_block (tree *stmt_p)\n   *stmt_p = gimple_build_eh_filter (body, allowed, failure);\n }\n \n-/* Do C++-specific gimplification.  Args are as for gimplify_expr.  */\n-\n-int\n-cp_gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p)\n-{\n-  switch (TREE_CODE (*expr_p))\n-    {\n-    case PTRMEM_CST:\n-      *expr_p = cplus_expand_constant (*expr_p);\n-      return GS_OK;\n-\n-    case AGGR_INIT_EXPR:\n-      simplify_aggr_init_expr (expr_p);\n-      return GS_OK;\n-\n-    case THROW_EXPR:\n-      /* FIXME communicate throw type to backend, probably by moving\n-\t THROW_EXPR into ../tree.def.  */\n-      *expr_p = TREE_OPERAND (*expr_p, 0);\n-      return GS_OK;\n-\n-    case MUST_NOT_THROW_EXPR:\n-      gimplify_must_not_throw_expr (expr_p, pre_p);\n-      return GS_OK;\n-\n-    case INIT_EXPR:\n-    case MODIFY_EXPR:\n-      cp_gimplify_init_expr (expr_p, pre_p, post_p);\n-      return GS_OK;\n-\n-    case EMPTY_CLASS_EXPR:\n-      {\n-\t/* Yes, an INTEGER_CST with RECORD_TYPE.  */\n-\ttree i = build_int_2 (0, 0);\n-\tTREE_TYPE (i) = TREE_TYPE (*expr_p);\n-\t*expr_p = i;\n-      }\n-      return GS_OK;\n-\n-    case BASELINK:\n-      *expr_p = BASELINK_FUNCTIONS (*expr_p);\n-      return GS_OK;\n-\n-    default:\n-      return c_gimplify_expr (expr_p, pre_p, post_p);\n-    }\n-}\n-\n /* Gimplify initialization from an AGGR_INIT_EXPR.  */\n \n static void\n@@ -225,3 +140,99 @@ gimplify_must_not_throw_expr (tree *expr_p, tree *pre_p)\n   else\n     *expr_p = stmt;\n }\n+\n+/* Do C++-specific gimplification.  Args are as for gimplify_expr.  */\n+\n+int\n+cp_gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p)\n+{\n+  int saved_stmts_are_full_exprs_p = 0;\n+  enum tree_code code = TREE_CODE (*expr_p);\n+  enum gimplify_status ret;\n+\n+  if (STATEMENT_CODE_P (code))\n+    {\n+      saved_stmts_are_full_exprs_p = stmts_are_full_exprs_p ();\n+      current_stmt_tree ()->stmts_are_full_exprs_p\n+\t= STMT_IS_FULL_EXPR_P (*expr_p);\n+    }\n+\n+  switch (code)\n+    {\n+    case PTRMEM_CST:\n+      *expr_p = cplus_expand_constant (*expr_p);\n+      ret = GS_OK;\n+      break;\n+\n+    case AGGR_INIT_EXPR:\n+      simplify_aggr_init_expr (expr_p);\n+      ret = GS_OK;\n+      break;\n+\n+    case THROW_EXPR:\n+      /* FIXME communicate throw type to backend, probably by moving\n+\t THROW_EXPR into ../tree.def.  */\n+      *expr_p = TREE_OPERAND (*expr_p, 0);\n+      ret = GS_OK;\n+      break;\n+\n+    case MUST_NOT_THROW_EXPR:\n+      gimplify_must_not_throw_expr (expr_p, pre_p);\n+      ret = GS_OK;\n+      break;\n+\n+    case INIT_EXPR:\n+    case MODIFY_EXPR:\n+      cp_gimplify_init_expr (expr_p, pre_p, post_p);\n+      ret = GS_OK;\n+      break;\n+\n+    case EMPTY_CLASS_EXPR:\n+      {\n+\t/* Yes, an INTEGER_CST with RECORD_TYPE.  */\n+\ttree i = build_int_2 (0, 0);\n+\tTREE_TYPE (i) = TREE_TYPE (*expr_p);\n+\t*expr_p = i;\n+      }\n+      ret = GS_OK;\n+      break;\n+\n+    case BASELINK:\n+      *expr_p = BASELINK_FUNCTIONS (*expr_p);\n+      ret = GS_OK;\n+      break;\n+\n+    case TRY_BLOCK:\n+      genericize_try_block (expr_p);\n+      ret = GS_OK;\n+      break;\n+\n+    case HANDLER:\n+      genericize_catch_block (expr_p);\n+      ret = GS_OK;\n+      break;\n+\n+    case EH_SPEC_BLOCK:\n+      genericize_eh_spec_block (expr_p);\n+      ret = GS_OK;\n+      break;\n+\n+    case USING_STMT:\n+      /* Just ignore for now.  Eventually we will want to pass this on to\n+\t the debugger.  */\n+      *expr_p = build_empty_stmt ();\n+      ret = GS_ALL_DONE;\n+      break;\n+\n+    default:\n+      ret = c_gimplify_expr (expr_p, pre_p, post_p);\n+      break;\n+    }\n+\n+  /* Restore saved state.  */\n+  if (STATEMENT_CODE_P (code))\n+    current_stmt_tree ()->stmts_are_full_exprs_p\n+      = saved_stmts_are_full_exprs_p;\n+\n+  return ret;\n+}"}, {"sha": "7a0c41d93051b0d1330e0ae78aa638b0910c101e", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c34ced1a25f62ed12b1bf1158167fe157b60ae7/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c34ced1a25f62ed12b1bf1158167fe157b60ae7/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=7c34ced1a25f62ed12b1bf1158167fe157b60ae7", "patch": "@@ -4305,7 +4305,6 @@ extern bool cp_dump_tree                         (void *, tree);\n \n /* in cp-simplify.c */\n extern int cp_gimplify_expr\t\t        (tree *, tree *, tree *);\n-extern int cp_gimplify_stmt\t\t        (tree *);\n \n /* -- end of C++ */\n "}, {"sha": "a73ef189f62cc3eadbab7dc0a8012c6e86423af4", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 58, "deletions": 97, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c34ced1a25f62ed12b1bf1158167fe157b60ae7/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c34ced1a25f62ed12b1bf1158167fe157b60ae7/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=7c34ced1a25f62ed12b1bf1158167fe157b60ae7", "patch": "@@ -7747,6 +7747,11 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n   if (t == NULL_TREE || t == error_mark_node)\n     return t;\n \n+  if (EXPR_LOCUS (t))\n+    input_location = *EXPR_LOCUS (t);\n+  if (STATEMENT_CODE_P (TREE_CODE (t)))\n+    current_stmt_tree ()->stmts_are_full_exprs_p = STMT_IS_FULL_EXPR_P (t);\n+\n   switch (TREE_CODE (t))\n     {\n     case STATEMENT_LIST:\n@@ -7758,13 +7763,11 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n       }\n \n     case CTOR_INITIALIZER:\n-      prep_stmt (t);\n       finish_mem_initializers (tsubst_initializer_list \n \t\t\t       (TREE_OPERAND (t, 0), args));\n       break;\n \n     case RETURN_STMT:\n-      prep_stmt (t);\n       finish_return_stmt (tsubst_expr (RETURN_STMT_EXPR (t),\n \t\t\t\t       args, complain, in_decl));\n       break;\n@@ -7783,21 +7786,14 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n       }\n \n     case EXPR_STMT:\n-      {\n-\ttree r;\n-\t\n-\tprep_stmt (t);\n-\n-\tr = tsubst_expr (EXPR_STMT_EXPR (t), args, complain, in_decl);\n-\tif (EXPR_STMT_STMT_EXPR_RESULT (t))\n-\t  finish_stmt_expr_expr (r, cur_stmt_expr);\n-\telse\n-\t  finish_expr_stmt (r);\n-\tbreak;\n-      }\n+      tmp = tsubst_expr (EXPR_STMT_EXPR (t), args, complain, in_decl);\n+      if (EXPR_STMT_STMT_EXPR_RESULT (t))\n+\tfinish_stmt_expr_expr (tmp, cur_stmt_expr);\n+      else\n+\tfinish_expr_stmt (tmp);\n+      break;\n \n     case USING_STMT:\n-      prep_stmt (t);\n       do_using_directive (tsubst_expr (USING_STMT_NAMESPACE (t),\n \t\t\t\t       args, complain, in_decl));\n       break;\n@@ -7807,7 +7803,6 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \ttree decl;\n \ttree init;\n \n-\tprep_stmt (t);\n \tdecl = DECL_STMT_DECL (t);\n \tif (TREE_CODE (decl) == LABEL_DECL)\n \t  finish_label_decl (DECL_NAME (decl));\n@@ -7870,122 +7865,92 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n       }\n \n     case FOR_STMT:\n-      {\n-\tprep_stmt (t);\n-\n-\tstmt = begin_for_stmt ();\n-\ttsubst_expr (FOR_INIT_STMT (t), args, complain, in_decl);\n-\tfinish_for_init_stmt (stmt);\n-\tfinish_for_cond (tsubst_expr (FOR_COND (t),\n-\t\t\t\t      args, complain, in_decl),\n-\t\t\t stmt);\n-\ttmp = tsubst_expr (FOR_EXPR (t), args, complain, in_decl);\n-\tfinish_for_expr (tmp, stmt);\n-\ttsubst_expr (FOR_BODY (t), args, complain, in_decl);\n-\tfinish_for_stmt (stmt);\n-      }\n+      stmt = begin_for_stmt ();\n+      tsubst_expr (FOR_INIT_STMT (t), args, complain, in_decl);\n+      finish_for_init_stmt (stmt);\n+      tmp = tsubst_expr (FOR_COND (t), args, complain, in_decl);\n+      finish_for_cond (tmp, stmt);\n+      tmp = tsubst_expr (FOR_EXPR (t), args, complain, in_decl);\n+      finish_for_expr (tmp, stmt);\n+      tsubst_expr (FOR_BODY (t), args, complain, in_decl);\n+      finish_for_stmt (stmt);\n       break;\n \n     case WHILE_STMT:\n-      {\n-\tprep_stmt (t);\n-\tstmt = begin_while_stmt ();\n-\tfinish_while_stmt_cond (tsubst_expr (WHILE_COND (t),\n-\t\t\t\t\t     args, complain, in_decl),\n-\t\t\t\tstmt);\n-\ttsubst_expr (WHILE_BODY (t), args, complain, in_decl);\n-\tfinish_while_stmt (stmt);\n-      }\n+      stmt = begin_while_stmt ();\n+      tmp = tsubst_expr (WHILE_COND (t), args, complain, in_decl);\n+      finish_while_stmt_cond (tmp, stmt);\n+      tsubst_expr (WHILE_BODY (t), args, complain, in_decl);\n+      finish_while_stmt (stmt);\n       break;\n \n     case DO_STMT:\n-      {\n-\tprep_stmt (t);\n-\tstmt = begin_do_stmt ();\n-\ttsubst_expr (DO_BODY (t), args, complain, in_decl);\n-\tfinish_do_body (stmt);\n-\tfinish_do_stmt (tsubst_expr (DO_COND (t),\n-\t\t\t\t     args, complain, in_decl),\n-\t\t\tstmt);\n-      }\n+      stmt = begin_do_stmt ();\n+      tsubst_expr (DO_BODY (t), args, complain, in_decl);\n+      finish_do_body (stmt);\n+      tmp = tsubst_expr (DO_COND (t), args, complain, in_decl);\n+      finish_do_stmt (tmp, stmt);\n       break;\n \n     case IF_STMT:\n-      {\n-\tprep_stmt (t);\n-\tstmt = begin_if_stmt ();\n-\tfinish_if_stmt_cond (tsubst_expr (IF_COND (t),\n-\t\t\t\t\t  args, complain, in_decl),\n-\t\t\t     stmt);\n-\ttsubst_expr (THEN_CLAUSE (t), args, complain, in_decl);\n-\tfinish_then_clause (stmt);\n-\n-\tif (ELSE_CLAUSE (t))\n-\t  {\n-\t    begin_else_clause (stmt);\n-\t    tsubst_expr (ELSE_CLAUSE (t), args, complain, in_decl);\n-\t    finish_else_clause (stmt);\n-\t  }\n+      stmt = begin_if_stmt ();\n+      tmp = tsubst_expr (IF_COND (t), args, complain, in_decl);\n+      finish_if_stmt_cond (tmp, stmt);\n+      tsubst_expr (THEN_CLAUSE (t), args, complain, in_decl);\n+      finish_then_clause (stmt);\n \n-\tfinish_if_stmt (stmt);\n-      }\n+      if (ELSE_CLAUSE (t))\n+\t{\n+\t  begin_else_clause (stmt);\n+\t  tsubst_expr (ELSE_CLAUSE (t), args, complain, in_decl);\n+\t  finish_else_clause (stmt);\n+\t}\n+\n+      finish_if_stmt (stmt);\n       break;\n \n     case BIND_EXPR:\n-      {\n-\tprep_stmt (t);\n-\tif (BIND_EXPR_BODY_BLOCK (t))\n-\t  stmt = begin_function_body ();\n-\telse\n-\t  stmt = begin_compound_stmt (BIND_EXPR_TRY_BLOCK (t)\n-\t\t\t\t      ? BCS_TRY_BLOCK : 0);\n+      if (BIND_EXPR_BODY_BLOCK (t))\n+\tstmt = begin_function_body ();\n+      else\n+\tstmt = begin_compound_stmt (BIND_EXPR_TRY_BLOCK (t)\n+\t\t\t\t    ? BCS_TRY_BLOCK : 0);\n \n-\ttsubst_expr (BIND_EXPR_BODY (t), args, complain, in_decl);\n+      tsubst_expr (BIND_EXPR_BODY (t), args, complain, in_decl);\n \n-\tif (BIND_EXPR_BODY_BLOCK (t))\n-\t  finish_function_body (stmt);\n-\telse\n-\t  finish_compound_stmt (stmt);\n-      }\n+      if (BIND_EXPR_BODY_BLOCK (t))\n+\tfinish_function_body (stmt);\n+      else\n+\tfinish_compound_stmt (stmt);\n       break;\n \n     case BREAK_STMT:\n-      prep_stmt (t);\n       finish_break_stmt ();\n       break;\n \n     case CONTINUE_STMT:\n-      prep_stmt (t);\n       finish_continue_stmt ();\n       break;\n \n     case SWITCH_STMT:\n-      {\n-\ttree val;\n-\n-\tprep_stmt (t);\n-\tstmt = begin_switch_stmt ();\n-\tval = tsubst_expr (SWITCH_COND (t), args, complain, in_decl);\n-\tfinish_switch_cond (val, stmt);\n-\ttsubst_expr (SWITCH_BODY (t), args, complain, in_decl);\n-\tfinish_switch_stmt (stmt);\n-      }\n+      stmt = begin_switch_stmt ();\n+      tmp = tsubst_expr (SWITCH_COND (t), args, complain, in_decl);\n+      finish_switch_cond (tmp, stmt);\n+      tsubst_expr (SWITCH_BODY (t), args, complain, in_decl);\n+      finish_switch_stmt (stmt);\n       break;\n \n     case CASE_LABEL_EXPR:\n-      prep_stmt (t);\n       finish_case_label (tsubst_expr (CASE_LOW (t), args, complain, in_decl),\n \t\t\t tsubst_expr (CASE_HIGH (t), args, complain,\n \t\t\t\t      in_decl));\n       break;\n \n     case LABEL_EXPR:\n-      prep_stmt (t);\n       finish_label_stmt (DECL_NAME (LABEL_EXPR_LABEL (t)));\n       break;\n \n     case GOTO_EXPR:\n-      prep_stmt (t);\n       tmp = GOTO_DESTINATION (t);\n       if (TREE_CODE (tmp) != LABEL_DECL)\n \t/* Computed goto's must be tsubst'd into.  On the other hand,\n@@ -7998,7 +7963,6 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n       break;\n \n     case ASM_EXPR:\n-      prep_stmt (t);\n       tmp = finish_asm_stmt\n \t(ASM_VOLATILE_P (t),\n \t tsubst_expr (ASM_STRING (t), args, complain, in_decl),\n@@ -8009,7 +7973,6 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n       break;\n \n     case TRY_BLOCK:\n-      prep_stmt (t);\n       if (CLEANUP_P (t))\n \t{\n \t  stmt = begin_try_block ();\n@@ -8045,7 +8008,6 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n       {\n \ttree decl;\n \n-\tprep_stmt (t);\n \tstmt = begin_handler ();\n \tif (HANDLER_PARMS (t))\n \t  {\n@@ -8065,7 +8027,6 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n       break;\n \n     case TAG_DEFN:\n-      prep_stmt (t);\n       tsubst (TREE_TYPE (t), args, complain, NULL_TREE);\n       break;\n "}, {"sha": "6b558800e682023a5743a7e08fbbfa1a1c25b97e", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c34ced1a25f62ed12b1bf1158167fe157b60ae7/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c34ced1a25f62ed12b1bf1158167fe157b60ae7/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=7c34ced1a25f62ed12b1bf1158167fe157b60ae7", "patch": "@@ -2196,7 +2196,6 @@ cp_update_decl_after_saving (tree fn,\n void\n init_tree (void)\n {\n-  lang_gimplify_stmt = cp_gimplify_stmt;\n   list_hash_table = htab_create_ggc (31, list_hash, list_hash_eq, NULL);\n }\n "}, {"sha": "92c52a9365b9191733c6fcfa274a80b3d8c2b53b", "filename": "gcc/gimplify.c", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c34ced1a25f62ed12b1bf1158167fe157b60ae7/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c34ced1a25f62ed12b1bf1158167fe157b60ae7/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=7c34ced1a25f62ed12b1bf1158167fe157b60ae7", "patch": "@@ -563,6 +563,15 @@ should_carry_locus_p (tree stmt)\n   return true;\n }\n \n+static void\n+annotate_one_with_locus (tree t, location_t locus)\n+{\n+  if (IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (TREE_CODE (t)))\n+      && ! EXPR_HAS_LOCATION (t)\n+      && should_carry_locus_p (t))\n+    annotate_with_locus (t, locus);\n+}\n+\n void\n annotate_all_with_locus (tree *stmt_p, location_t locus)\n {\n@@ -583,10 +592,7 @@ annotate_all_with_locus (tree *stmt_p, location_t locus)\n \t    abort ();\n #endif\n \n-      if (IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (TREE_CODE (t)))\n-\t  && ! EXPR_HAS_LOCATION (t)\n-\t  && should_carry_locus_p (t))\n-\tannotate_with_locus (t, locus);\n+      annotate_one_with_locus (t, locus);\n     }\n }\n \n@@ -3558,6 +3564,10 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \t  annotate_all_with_locus (&internal_pre, input_location);\n \t  *expr_p = internal_pre;\n \t}\n+      else if (TREE_CODE (*expr_p) == STATEMENT_LIST)\n+\tannotate_all_with_locus (expr_p, input_location);\n+      else\n+\tannotate_one_with_locus (*expr_p, input_location);\n       goto out;\n     }\n "}]}