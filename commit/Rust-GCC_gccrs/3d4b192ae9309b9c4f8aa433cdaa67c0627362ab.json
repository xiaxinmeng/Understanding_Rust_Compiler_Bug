{"sha": "3d4b192ae9309b9c4f8aa433cdaa67c0627362ab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Q0YjE5MmFlOTMwOWI5YzRmOGFhNDMzY2RhYTY3YzA2MjczNjJhYg==", "commit": {"author": {"name": "DJ Delorie", "email": "dj@redhat.com", "date": "2002-11-20T21:08:33Z"}, "committer": {"name": "DJ Delorie", "email": "dj@gcc.gnu.org", "date": "2002-11-20T21:08:33Z"}, "message": "stormy16.c (s16builtins, [...]): New.\n\n* config/stormy16/stormy16.c (s16builtins,\nxstormy16_init_builtins, xstormy16_expand_builtin): New.\n* config/stormy16/stormy16.md (divmodhi4, sdivlh, udivlh): New.\n\nFrom-SVN: r59312", "tree": {"sha": "2e2b987fef48e5cba83cf91215e22e93018f3c9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2e2b987fef48e5cba83cf91215e22e93018f3c9c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3d4b192ae9309b9c4f8aa433cdaa67c0627362ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d4b192ae9309b9c4f8aa433cdaa67c0627362ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d4b192ae9309b9c4f8aa433cdaa67c0627362ab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d4b192ae9309b9c4f8aa433cdaa67c0627362ab/comments", "author": null, "committer": null, "parents": [{"sha": "9a0a7d5dfad84220ef3b243fa8d231e7c30cc058", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a0a7d5dfad84220ef3b243fa8d231e7c30cc058", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a0a7d5dfad84220ef3b243fa8d231e7c30cc058"}], "stats": {"total": 165, "additions": 165, "deletions": 0}, "files": [{"sha": "31768edd41eb01503519ce4208289799f31f6d27", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d4b192ae9309b9c4f8aa433cdaa67c0627362ab/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d4b192ae9309b9c4f8aa433cdaa67c0627362ab/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3d4b192ae9309b9c4f8aa433cdaa67c0627362ab", "patch": "@@ -1,3 +1,9 @@\n+2002-11-20  DJ Delorie  <dj@redhat.com>\n+\n+\t* config/stormy16/stormy16.c (s16builtins,\n+\txstormy16_init_builtins, xstormy16_expand_builtin): New.\n+\t* config/stormy16/stormy16.md (divmodhi4, sdivlh, udivlh): New.\n+\n 2002-11-20  Hans-Peter Nilsson  <hp@bitrange.com>\n \n \t* Makefile.in (RUN_GEN, VALGRIND_DRIVER_DEFINES): New variables."}, {"sha": "417a8dc03ab6741955898990810d8dc96a5f2c26", "filename": "gcc/config/stormy16/stormy16.c", "status": "modified", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d4b192ae9309b9c4f8aa433cdaa67c0627362ab/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d4b192ae9309b9c4f8aa433cdaa67c0627362ab/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.c?ref=3d4b192ae9309b9c4f8aa433cdaa67c0627362ab", "patch": "@@ -53,6 +53,9 @@ static void xstormy16_encode_section_info PARAMS ((tree, int));\n static void xstormy16_asm_output_mi_thunk PARAMS ((FILE *, tree, HOST_WIDE_INT,\n \t\t\t\t\t\t   HOST_WIDE_INT, tree));\n \n+static void xstormy16_init_builtins PARAMS ((void));\n+static rtx xstormy16_expand_builtin PARAMS ((tree, rtx, rtx, enum machine_mode, int));\n+\n /* Define the information needed to generate branch and scc insns.  This is\n    stored from the compare operation.  */\n struct rtx_def * xstormy16_compare_op0;\n@@ -2027,6 +2030,126 @@ xstormy16_handle_interrupt_attribute (node, name, args, flags, no_add_attrs)\n \n   return NULL_TREE;\n }\n+\f\n+#undef TARGET_INIT_BUILTINS\n+#define TARGET_INIT_BUILTINS xstormy16_init_builtins\n+#undef TARGET_EXPAND_BUILTIN\n+#define TARGET_EXPAND_BUILTIN xstormy16_expand_builtin\n+\n+static struct {\n+  const char *name;\n+  int md_code;\n+  const char *arg_ops; /* 0..9, t for temp register, r for return value */\n+  const char *arg_types; /* s=short,l=long, upper case for unsigned */\n+} s16builtins[] = {\n+  { \"__sdivlh\", CODE_FOR_sdivlh, \"rt01\", \"sls\" },\n+  { \"__smodlh\", CODE_FOR_sdivlh, \"tr01\", \"sls\" },\n+  { \"__udivlh\", CODE_FOR_udivlh, \"rt01\", \"SLS\" },\n+  { \"__umodlh\", CODE_FOR_udivlh, \"tr01\", \"SLS\" },\n+  { 0, 0, 0, 0 }\n+};\n+\n+static void\n+xstormy16_init_builtins ()\n+{\n+  tree args, ret_type, arg;\n+  int i, a;\n+\n+  ret_type = void_type_node;\n+\n+  for (i=0; s16builtins[i].name; i++)\n+    {\n+      args = void_list_node;\n+      for (a=strlen (s16builtins[i].arg_types)-1; a>=0; a--)\n+\t{\n+\t  switch (s16builtins[i].arg_types[a])\n+\t    {\n+\t    case 's': arg = short_integer_type_node; break;\n+\t    case 'S': arg = short_unsigned_type_node; break;\n+\t    case 'l': arg = long_integer_type_node; break;\n+\t    case 'L': arg = long_unsigned_type_node; break;\n+\t    default: abort();\n+\t    }\n+\t  if (a == 0)\n+\t    ret_type = arg;\n+\t  else\n+\t    args = tree_cons (NULL_TREE, arg, args);\n+\t}\n+      builtin_function (s16builtins[i].name,\n+\t\t\tbuild_function_type (ret_type, args),\n+\t\t\ti, BUILT_IN_MD, NULL, NULL);\n+    }\n+}\n+\n+static rtx\n+xstormy16_expand_builtin(exp, target, subtarget, mode, ignore)\n+     tree exp;\n+     rtx target;\n+     rtx subtarget ATTRIBUTE_UNUSED;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n+     int ignore ATTRIBUTE_UNUSED;\n+{\n+  rtx op[10], args[10], pat, copyto[10], retval = 0;\n+  tree fndecl, argtree;\n+  int i, a, o, code;\n+\n+  fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n+  argtree = TREE_OPERAND (exp, 1);\n+  i = DECL_FUNCTION_CODE (fndecl);\n+  code = s16builtins[i].md_code;\n+\n+  for (a = 0; a < 10 && argtree; a++)\n+    {\n+      args[a] = expand_expr (TREE_VALUE (argtree), NULL_RTX, VOIDmode, 0);\n+      argtree = TREE_CHAIN (argtree);\n+    }\n+\n+  for (o = 0; s16builtins[i].arg_ops[o]; o++)\n+    {\n+      char ao = s16builtins[i].arg_ops[o];\n+      char c = insn_data[code].operand[o].constraint[0];\n+      int omode;\n+\n+      copyto[o] = 0;\n+\n+      omode = insn_data[code].operand[o].mode;\n+      if (ao == 'r')\n+\top[o] = target ? target : gen_reg_rtx (omode);\n+      else if (ao == 't')\n+\top[o] = gen_reg_rtx (omode);\n+      else\n+\top[o] = args[(int) hex_value (ao)];\n+\n+      if (! (*insn_data[code].operand[o].predicate) (op[o], GET_MODE (op[o])))\n+\t{\n+\t  if (c == '+' || c == '=')\n+\t    {\n+\t      copyto[o] = op[o];\n+\t      op[o] = gen_reg_rtx (omode);\n+\t    }\n+\t  else\n+\t    op[o] = copy_to_mode_reg (omode, op[o]);\n+\t}\n+\n+      if (ao == 'r')\n+\tretval = op[o];\n+    }\n+\n+  pat = GEN_FCN (code) (op[0], op[1], op[2], op[3], op[4],\n+\t\t\top[5], op[6], op[7], op[8], op[9]);\n+  emit_insn (pat);\n+\n+  for (o = 0; s16builtins[i].arg_ops[o]; o++)\n+    if (copyto[o])\n+      {\n+\temit_move_insn (copyto[o], op[o]);\n+\tif (op[o] == retval)\n+\t  retval = copyto[o];\n+      }\n+\n+  return retval;\n+}\n+\n \f\n #undef TARGET_ASM_ALIGNED_HI_OP\n #define TARGET_ASM_ALIGNED_HI_OP \"\\t.hword\\t\""}, {"sha": "56033d1969416667db39ede21bae738527c303b5", "filename": "gcc/config/stormy16/stormy16.md", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d4b192ae9309b9c4f8aa433cdaa67c0627362ab/gcc%2Fconfig%2Fstormy16%2Fstormy16.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d4b192ae9309b9c4f8aa433cdaa67c0627362ab/gcc%2Fconfig%2Fstormy16%2Fstormy16.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.md?ref=3d4b192ae9309b9c4f8aa433cdaa67c0627362ab", "patch": "@@ -435,6 +435,42 @@\n   \"div\"\n   [(set_attr \"psw_operand\" \"nop\")])\n \n+;; Signed division giving both quotient and remainder\n+(define_insn \"divmodhi4\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=a\")\n+\t(div:HI (match_operand:HI 1 \"register_operand\" \"a\")\n+\t\t (match_operand:HI 2 \"register_operand\" \"c\")))\n+   (set (match_operand:HI 3 \"register_operand\" \"=b\")\n+\t(mod:HI (match_dup 1)\n+\t\t (match_dup 2)))]\n+  \"\"\n+  \"sdiv\"\n+  [(set_attr \"psw_operand\" \"nop\")])\n+\n+;; Signed 32/16 division\n+(define_insn \"sdivlh\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=a\")\n+\t(div:HI (match_operand:SI 2 \"register_operand\" \"t\")\n+\t\t (match_operand:HI 3 \"register_operand\" \"c\")))\n+   (set (match_operand:HI 1 \"register_operand\" \"=b\")\n+\t(mod:HI (match_dup 2)\n+\t\t (match_dup 3)))]\n+  \"\"\n+  \"sdivlh\"\n+  [(set_attr \"psw_operand\" \"nop\")])\n+\n+;; Unsigned 32/16 division\n+(define_insn \"udivlh\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=a\")\n+\t(udiv:HI (match_operand:SI 2 \"register_operand\" \"t\")\n+\t\t (match_operand:HI 3 \"register_operand\" \"c\")))\n+   (set (match_operand:HI 1 \"register_operand\" \"=b\")\n+\t(umod:HI (match_dup 2)\n+\t\t (match_dup 3)))]\n+  \"\"\n+  \"divlh\"\n+  [(set_attr \"psw_operand\" \"nop\")])\n+\n ;; Negation\n \n (define_expand \"neghi2\""}]}