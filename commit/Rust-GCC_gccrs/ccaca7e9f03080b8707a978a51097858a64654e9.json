{"sha": "ccaca7e9f03080b8707a978a51097858a64654e9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2NhY2E3ZTlmMDMwODBiODcwN2E5NzhhNTEwOTc4NThhNjQ2NTRlOQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-11-25T15:09:38Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-11-25T15:09:38Z"}, "message": "[multiple changes]\n\n2015-11-25  Jerome Lambourg  <lambourg@adacore.com>\n\n\t* init.c: Enable the signal trampoline on x86_64-vx7\n\t* sigtramp-vxworks-target.inc: Implement the signal trampoline\n\tfor x86_64\n\t* tracebak.c: Remove the hook to use the generic\n\tunwinder on x86_64-vx7.\n\n2015-11-25  Vincent Celier  <celier@adacore.com>\n\n\t* gnatcmd.adb: When \"gnat name -P\" is called, invoke gprname\n\tdirectly if available.\n\nFrom-SVN: r230875", "tree": {"sha": "7fe5d12eb1558a1934d3e8456a183450acbc1e7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7fe5d12eb1558a1934d3e8456a183450acbc1e7a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ccaca7e9f03080b8707a978a51097858a64654e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccaca7e9f03080b8707a978a51097858a64654e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ccaca7e9f03080b8707a978a51097858a64654e9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccaca7e9f03080b8707a978a51097858a64654e9/comments", "author": null, "committer": null, "parents": [{"sha": "d75a7b1f3283c5c020aa51bf019b2d1e9548765e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d75a7b1f3283c5c020aa51bf019b2d1e9548765e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d75a7b1f3283c5c020aa51bf019b2d1e9548765e"}], "stats": {"total": 126, "additions": 116, "deletions": 10}, "files": [{"sha": "b7be5a5202b9c55d092515143632a9fd1c8fa443", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccaca7e9f03080b8707a978a51097858a64654e9/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccaca7e9f03080b8707a978a51097858a64654e9/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=ccaca7e9f03080b8707a978a51097858a64654e9", "patch": "@@ -1,3 +1,16 @@\n+2015-11-25  Jerome Lambourg  <lambourg@adacore.com>\n+\n+\t* init.c: Enable the signal trampoline on x86_64-vx7\n+\t* sigtramp-vxworks-target.inc: Implement the signal trampoline\n+\tfor x86_64\n+\t* tracebak.c: Remove the hook to use the generic\n+\tunwinder on x86_64-vx7.\n+\n+2015-11-25  Vincent Celier  <celier@adacore.com>\n+\n+\t* gnatcmd.adb: When \"gnat name -P\" is called, invoke gprname\n+\tdirectly if available.\n+\n 2015-11-25  Tristan Gingold  <gingold@adacore.com>\n \n \t* init.c (__gnat_is_stack_guard): Do not use mach calls for"}, {"sha": "df648319c5f6efed9bb15f1ac988aba3cbb94f8e", "filename": "gcc/ada/gnatcmd.adb", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccaca7e9f03080b8707a978a51097858a64654e9/gcc%2Fada%2Fgnatcmd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccaca7e9f03080b8707a978a51097858a64654e9/gcc%2Fada%2Fgnatcmd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatcmd.adb?ref=ccaca7e9f03080b8707a978a51097858a64654e9", "patch": "@@ -63,6 +63,9 @@ procedure GNATCmd is\n    Gprclean  : constant String := \"gprclean\";\n    Gnatclean : constant String := \"gnatclean\";\n \n+   Gprname  : constant String := \"gprname\";\n+   Gnatname : constant String := \"gnatname\";\n+\n    Normal_Exit : exception;\n    --  Raise this exception for normal program termination\n \n@@ -1183,8 +1186,12 @@ begin\n          --  If we want to invoke gnatmake/gnatclean with -P, then check if\n          --  gprbuild/gprclean is available; if it is, use gprbuild/gprclean\n          --  instead of gnatmake/gnatclean.\n+         --  Ditto for gnatname -> gprname.\n \n-         if Program.all = Gnatmake or else Program.all = Gnatclean then\n+         if Program.all = Gnatmake\n+            or else Program.all = Gnatclean\n+            or else Program.all = Gnatname\n+         then\n             declare\n                Project_File_Used : Boolean := False;\n                Switch            : String_Access;\n@@ -1209,6 +1216,11 @@ begin\n                     and then Locate_Exec_On_Path (Gprclean) /= null\n                   then\n                      Program := new String'(Gprclean);\n+\n+                  elsif Program.all = Gnatname\n+                    and then Locate_Exec_On_Path (Gprname) /= null\n+                  then\n+                     Program := new String'(Gprname);\n                   end if;\n                end if;\n             end;"}, {"sha": "06e366d7856db54bde40409b6406f97f42bb4c50", "filename": "gcc/ada/init.c", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccaca7e9f03080b8707a978a51097858a64654e9/gcc%2Fada%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccaca7e9f03080b8707a978a51097858a64654e9/gcc%2Fada%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finit.c?ref=ccaca7e9f03080b8707a978a51097858a64654e9", "patch": "@@ -1974,27 +1974,31 @@ __gnat_error_handler (int sig, siginfo_t *si, void *sc)\n   sigdelset (&mask, sig);\n   sigprocmask (SIG_SETMASK, &mask, NULL);\n \n-#if defined (__ARMEL__) || defined (__PPC__) || (defined (__i386__) && _WRS_VXWORKS_MAJOR < 7)\n+#if defined (__ARMEL__) || defined (__PPC__) || defined (__i386__) || defined (__x86_64__)\n   /* On certain targets, kernel mode, we process signals through a Call Frame\n      Info trampoline, voiding the need for myriads of fallback_frame_state\n      variants in the ZCX runtime.  We have no simple way to distinguish ZCX\n      from SJLJ here, so we do this for SJLJ as well even though this is not\n      necessary.  This only incurs a few extra instructions and a tiny\n      amount of extra stack usage.  */\n \n-#if defined (__i386__) && !defined (VTHREADS)\n+#ifdef HAVE_GNAT_ADJUST_CONTEXT_FOR_RAISE\n+  /* We need to sometimes to adjust the PC in case of signals so that it\n+     doesn't reference the exception that actually raised the signal but the\n+     instruction before it. */\n+  __gnat_adjust_context_for_raise (sig, sc);\n+#endif\n+\n+#if defined (__i386__) && !defined (VTHREADS) && (__WRS_VXWORKS_MAJOR < 7)\n    /* On x86, the vxsim signal context is subtly different and is processeed\n-      by a handler compiled especially for vxsim.  */\n+      by a handler compiled especially for vxsim.\n+      Vxsim is not supported anymore on our vxworks-7 port. */\n \n   if (is_vxsim)\n     __gnat_vxsim_error_handler (sig, si, sc);\n #endif\n \n-#ifdef HAVE_GNAT_ADJUST_CONTEXT_FOR_RAISE\n-  __gnat_adjust_context_for_raise (sig, sc);\n-#endif\n-\n-#include \"sigtramp.h\"\n+# include \"sigtramp.h\"\n \n   __gnat_sigtramp (sig, (void *)si, (void *)sc,\n \t\t   (__sigtramphandler_t *)&__gnat_map_signal);"}, {"sha": "fbb708ba2cadd3c45bf06a77c4aa17df9766a4a5", "filename": "gcc/ada/sigtramp-vxworks-target.inc", "status": "modified", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccaca7e9f03080b8707a978a51097858a64654e9/gcc%2Fada%2Fsigtramp-vxworks-target.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccaca7e9f03080b8707a978a51097858a64654e9/gcc%2Fada%2Fsigtramp-vxworks-target.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsigtramp-vxworks-target.inc?ref=ccaca7e9f03080b8707a978a51097858a64654e9", "patch": "@@ -139,6 +139,32 @@\n    the latter depends on the platform.\n */\n \n+#elif defined (__x86_64__)\n+\n+/* These are the cfi colunm numbers */\n+\n+#define REGNO_RAX 0\n+#define REGNO_RDX 1\n+#define REGNO_RCX 2\n+#define REGNO_RBX 3\n+#define REGNO_RSI 4\n+#define REGNO_RDI 5\n+#define REGNO_RBP 6\n+#define REGNO_RSP 7\n+#define REGNO_R8 8\n+#define REGNO_R9 9\n+#define REGNO_R10 10\n+#define REGNO_R11 11\n+#define REGNO_R12 12\n+#define REGNO_R13 13\n+#define REGNO_R14 14\n+#define REGNO_R15 15\n+#define REGNO_SET_PC 16 /* aka %rip */\n+#define REGNO_EFLAGS 49\n+#define REGNO_FS 54\n+\n+#define FUNCTION \"@function\"\n+\n #else\n Not_implemented;\n #endif /* REGNO constants */\n@@ -174,6 +200,11 @@ Not_implemented;\n \n #define CFA_REG 7\n \n+#elif defined (__x86_64__)\n+\n+/* R15 register */\n+#define CFA_REG 15\n+\n #else\n Not_implemented;\n #endif /* CFA setup block */\n@@ -366,6 +397,52 @@ TCR(\"popl\t%edi\") \\\n TCR(\"leave\") \\\n TCR(\"ret\")\n \n+#elif defined (__x86_64__)\n+\n+#define COMMON_CFI(REG) \\\n+  \".cfi_offset \" S(REGNO_##REG) \",\" S(REG_##REG)\n+#define PC_CFI(REG) \\\n+  \".cfi_offset \" S(REGNO_##REG) \",\" S(REG_##REG)\n+\n+#define CFI_COMMON_REGS \\\n+CR(\"# CFI for common registers\\n\") \\\n+TCR(COMMON_CFI(R15)) \\\n+TCR(COMMON_CFI(R14)) \\\n+TCR(COMMON_CFI(R13)) \\\n+TCR(COMMON_CFI(R12)) \\\n+TCR(COMMON_CFI(R11)) \\\n+TCR(COMMON_CFI(R10)) \\\n+TCR(COMMON_CFI(R9)) \\\n+TCR(COMMON_CFI(R8)) \\\n+TCR(COMMON_CFI(RDI)) \\\n+TCR(COMMON_CFI(RSI)) \\\n+TCR(COMMON_CFI(RBP)) \\\n+TCR(COMMON_CFI(RSP)) \\\n+TCR(COMMON_CFI(RBX)) \\\n+TCR(COMMON_CFI(RDX)) \\\n+TCR(COMMON_CFI(RCX)) \\\n+TCR(COMMON_CFI(RAX)) \\\n+TCR(COMMON_CFI(EFLAGS)) \\\n+TCR(COMMON_CFI(SET_PC)) \\\n+TCR(COMMON_CFI(FS)) \\\n+TCR(\".cfi_return_column \" S(REGNO_SET_PC))\n+\n+/* Trampoline body block\n+   ---------------------  */\n+\n+#define SIGTRAMP_BODY \\\n+CR(\"\") \\\n+TCR(\"# Allocate frame and save the non-volatile\") \\\n+TCR(\"# registers we're going to modify\") \\\n+TCR(\"subq\t$8, %rsp\") \\\n+TCR(\"# Setup CFA_REG = context, which we'll retrieve as our CFA value\") \\\n+TCR(\"movq\t%r8, %r15\") \\\n+TCR(\"# Call the real handler. The signo, siginfo and sigcontext\") \\\n+TCR(\"# arguments are the same as those we received\") \\\n+TCR(\"call\t*%rcx\") \\\n+TCR(\"# This part should never be executed\") \\\n+TCR(\"ret\")\n+\n #else\n Not_implemented;\n #endif /* CFI_COMMON_REGS and SIGTRAMP_BODY */"}, {"sha": "ff85ca5baf5befac6132384c02bf9030b534daaf", "filename": "gcc/ada/tracebak.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccaca7e9f03080b8707a978a51097858a64654e9/gcc%2Fada%2Ftracebak.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccaca7e9f03080b8707a978a51097858a64654e9/gcc%2Fada%2Ftracebak.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftracebak.c?ref=ccaca7e9f03080b8707a978a51097858a64654e9", "patch": "@@ -433,7 +433,7 @@ struct layout\n    but our only alternative is the generic unwinder which requires\n    compilation forcing a frame pointer to be reliable.  */\n \n-#if (defined (__x86_64__) || defined (__linux__)) && !defined (__USING_SJLJ_EXCEPTIONS__) && !defined (__vxworks)\n+#if (defined (__x86_64__) || defined (__linux__)) && !defined (__USING_SJLJ_EXCEPTIONS__)\n #define USE_GCC_UNWINDER\n #else\n #define USE_GENERIC_UNWINDER"}]}