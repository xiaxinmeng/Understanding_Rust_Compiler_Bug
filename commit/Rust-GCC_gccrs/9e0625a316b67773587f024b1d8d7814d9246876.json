{"sha": "9e0625a316b67773587f024b1d8d7814d9246876", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWUwNjI1YTMxNmI2Nzc3MzU4N2YwMjRiMWQ4ZDc4MTRkOTI0Njg3Ng==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2002-02-22T18:43:54Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2002-02-22T18:43:54Z"}, "message": "sol2.h: Don't include sys/mman.h.\n\n* config/sparc/sol2.h: Don't include sys/mman.h.\n* config/sparc/sparc.c (arith_operand): Use SMALL_INT32.\n(arith_4096_operand): Don't throw high bits away.\n(const64_operand): Take sign extension of CONST_INTs into account.\n(const64_high_operand, sparc_emit_set_const32): Likewise.\n(GEN_HIGHINT64): Likewise.\n(sparc_emit_set_const64_quick1): Likewise.\n(const64_is_2insns): Likewise.\n(print_operand): Use trunc_int_for_mode for sign extension.\n* config/sparc/sparc.h (SMALL_INT32): Likewise.\n* config/sparc/sparc.md (movqi): Sign-extend CONST_DOUBLE\nchars.  Assume CONST_INT is already properly sign-extended.\n(movdi split): Sign-extend each SImode part.\n(andsi3 split): Don't mask high bits off, so that result\nremains properly sign-extend.\n(iorsi3 split): Likewise.\n(xorsi3 split): Likewise.\n\nFrom-SVN: r49970", "tree": {"sha": "1ff4e2355d875fd9ebd73bf378918ea615738be7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1ff4e2355d875fd9ebd73bf378918ea615738be7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e0625a316b67773587f024b1d8d7814d9246876", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e0625a316b67773587f024b1d8d7814d9246876", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e0625a316b67773587f024b1d8d7814d9246876", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e0625a316b67773587f024b1d8d7814d9246876/comments", "author": null, "committer": null, "parents": [{"sha": "25c8b645eddd73483f4311b01e19e0196cf2c55b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25c8b645eddd73483f4311b01e19e0196cf2c55b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25c8b645eddd73483f4311b01e19e0196cf2c55b"}], "stats": {"total": 81, "additions": 48, "deletions": 33}, "files": [{"sha": "b4afe048bcbc3ea86976c5eb34472a2fd99f0ad8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e0625a316b67773587f024b1d8d7814d9246876/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e0625a316b67773587f024b1d8d7814d9246876/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9e0625a316b67773587f024b1d8d7814d9246876", "patch": "@@ -1,3 +1,23 @@\n+2002-02-22  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\t* config/sparc/sol2.h: Don't include sys/mman.h.\n+\t* config/sparc/sparc.c (arith_operand): Use SMALL_INT32.\n+\t(arith_4096_operand): Don't throw high bits away.\n+\t(const64_operand): Take sign extension of CONST_INTs into account.\n+\t(const64_high_operand, sparc_emit_set_const32): Likewise.\n+\t(GEN_HIGHINT64): Likewise.\n+\t(sparc_emit_set_const64_quick1): Likewise.\n+\t(const64_is_2insns): Likewise.\n+\t(print_operand): Use trunc_int_for_mode for sign extension.\n+\t* config/sparc/sparc.h (SMALL_INT32): Likewise.\n+\t* config/sparc/sparc.md (movqi): Sign-extend CONST_DOUBLE\n+\tchars.  Assume CONST_INT is already properly sign-extended.\n+\t(movdi split): Sign-extend each SImode part.\n+\t(andsi3 split): Don't mask high bits off, so that result\n+\tremains properly sign-extend.\n+\t(iorsi3 split): Likewise.\n+\t(xorsi3 split): Likewise.\n+\n 2002-02-22  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* fold-const.c (fold): Fix typo in comments."}, {"sha": "9f9ca235d2d1cb0d640808b6d7a6c77a1134d69f", "filename": "gcc/config/sparc/sol2.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e0625a316b67773587f024b1d8d7814d9246876/gcc%2Fconfig%2Fsparc%2Fsol2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e0625a316b67773587f024b1d8d7814d9246876/gcc%2Fconfig%2Fsparc%2Fsol2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsol2.h?ref=9e0625a316b67773587f024b1d8d7814d9246876", "patch": "@@ -243,7 +243,9 @@ Boston, MA 02111-1307, USA.  */\n \n /* This declares mprotect (used in TRANSFER_FROM_TRAMPOLINE) for\n    libgcc2.c.  */\n-#ifdef L_trampoline\n+/* We don't want to include this because sys/mman.h is not present on\n+   some non-Solaris configurations that use sol2.h.  */\n+#if 0 /* def L_trampoline */\n #include <sys/mman.h>\n #endif\n "}, {"sha": "ef2321b1aa3a45c2dc8352f2a244f14df24e2e1b", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e0625a316b67773587f024b1d8d7814d9246876/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e0625a316b67773587f024b1d8d7814d9246876/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=9e0625a316b67773587f024b1d8d7814d9246876", "patch": "@@ -950,13 +950,11 @@ arith_operand (op, mode)\n      rtx op;\n      enum machine_mode mode;\n {\n-  int val;\n   if (register_operand (op, mode))\n     return 1;\n   if (GET_CODE (op) != CONST_INT)\n     return 0;\n-  val = INTVAL (op) & 0xffffffff;\n-  return SPARC_SIMM13_P (val);\n+  return SMALL_INT32 (op);\n }\n \n /* Return true if OP is a constant 4096  */\n@@ -969,7 +967,6 @@ arith_4096_operand (op, mode)\n   int val;\n   if (GET_CODE (op) != CONST_INT)\n     return 0;\n-  val = INTVAL (op) & 0xffffffff;\n   return val == 4096;\n }\n \n@@ -998,7 +995,7 @@ const64_operand (op, mode)\n \t      && SPARC_SIMM13_P (CONST_DOUBLE_LOW (op))\n \t      && (CONST_DOUBLE_HIGH (op) ==\n \t\t  ((CONST_DOUBLE_LOW (op) & 0x80000000) != 0 ?\n-\t\t   (HOST_WIDE_INT)0xffffffff : 0)))\n+\t\t   (HOST_WIDE_INT)-1 : 0)))\n #endif\n \t  );\n }\n@@ -1010,7 +1007,7 @@ const64_high_operand (op, mode)\n      enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   return ((GET_CODE (op) == CONST_INT\n-\t   && (INTVAL (op) & 0xfffffc00) != 0\n+\t   && (INTVAL (op) & ~(HOST_WIDE_INT)0x3ff) != 0\n \t   && SPARC_SETHI_P (INTVAL (op))\n #if HOST_BITS_PER_WIDE_INT != 64\n \t   /* Must be positive on non-64bit host else the\n@@ -1021,7 +1018,7 @@ const64_high_operand (op, mode)\n \t   )\n \t  || (GET_CODE (op) == CONST_DOUBLE\n \t      && CONST_DOUBLE_HIGH (op) == 0\n-\t      && (CONST_DOUBLE_LOW (op) & 0xfffffc00) != 0\n+\t      && (CONST_DOUBLE_LOW (op) & ~(HOST_WIDE_INT)0x3ff) != 0\n \t      && SPARC_SETHI_P (CONST_DOUBLE_LOW (op))));\n }\n \n@@ -1335,11 +1332,13 @@ sparc_emit_set_const32 (op0, op1)\n \t  && (INTVAL (op1) & 0x80000000) != 0)\n \temit_insn (gen_rtx_SET\n \t\t   (VOIDmode, temp,\n-\t\t    gen_rtx_CONST_DOUBLE (VOIDmode, INTVAL (op1) & 0xfffffc00,\n+\t\t    gen_rtx_CONST_DOUBLE (VOIDmode,\n+\t\t\t\t\t  INTVAL (op1) & ~(HOST_WIDE_INT)0x3ff,\n \t\t\t\t\t  0)));\n       else\n \temit_insn (gen_rtx_SET (VOIDmode, temp,\n-\t\t\t\tGEN_INT (INTVAL (op1) & 0xfffffc00)));\n+\t\t\t\tGEN_INT (INTVAL (op1)\n+\t\t\t\t\t & ~(HOST_WIDE_INT)0x3ff)));\n \n       emit_insn (gen_rtx_SET (VOIDmode,\n \t\t\t      op0,\n@@ -1509,15 +1508,15 @@ static rtx gen_safe_OR64 PARAMS ((rtx, HOST_WIDE_INT));\n static rtx gen_safe_XOR64 PARAMS ((rtx, HOST_WIDE_INT));\n \n #if HOST_BITS_PER_WIDE_INT == 64\n-#define GEN_HIGHINT64(__x)\t\tGEN_INT ((__x) & 0xfffffc00)\n+#define GEN_HIGHINT64(__x)\t\tGEN_INT ((__x) & ~(HOST_WIDE_INT)0x3ff)\n #define GEN_INT64(__x)\t\t\tGEN_INT (__x)\n #else\n #define GEN_HIGHINT64(__x) \\\n-\tgen_rtx_CONST_DOUBLE (VOIDmode, (__x) & 0xfffffc00, 0)\n+\tgen_rtx_CONST_DOUBLE (VOIDmode, (__x) & ~(HOST_WIDE_INT)0x3ff, 0)\n #define GEN_INT64(__x) \\\n \tgen_rtx_CONST_DOUBLE (VOIDmode, (__x) & 0xffffffff, \\\n \t\t\t      ((__x) & 0x80000000 \\\n-\t\t\t       ? 0xffffffff : 0))\n+\t\t\t       ? -1 : 0))\n #endif\n \n /* The optimizer is not to assume anything about exactly\n@@ -1602,7 +1601,8 @@ sparc_emit_set_const64_quick1 (op0, temp, low_bits, is_neg)\n \t{\n \t  emit_insn (gen_rtx_SET (VOIDmode, op0,\n \t\t\t\t  gen_safe_XOR64 (temp,\n-\t\t\t\t\t\t  (-0x400 | (low_bits & 0x3ff)))));\n+\t\t\t\t\t\t  (-(HOST_WIDE_INT)0x400\n+\t\t\t\t\t\t   | (low_bits & 0x3ff)))));\n \t}\n     }\n }\n@@ -1835,7 +1835,7 @@ const64_is_2insns (high_bits, low_bits)\n   int highest_bit_set, lowest_bit_set, all_bits_between_are_set;\n \n   if (high_bits == 0\n-      || high_bits == 0xffffffff)\n+      || high_bits == -1)\n     return 1;\n \n   analyze_64bit_constant (high_bits, low_bits,\n@@ -6000,9 +6000,7 @@ print_operand (file, x, code)\n     case 'b':\n       {\n \t/* Print a sign-extended character.  */\n-\tint i = INTVAL (x) & 0xff;\n-\tif (i & 0x80)\n-\t  i |= 0xffffff00;\n+\tint i = trunc_int_for_mode (INTVAL (x), QImode);\n \tfprintf (file, \"%d\", i);\n \treturn;\n       }"}, {"sha": "368fd51d04b3dac9562c46fdbbe7b6ce3f53e800", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e0625a316b67773587f024b1d8d7814d9246876/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e0625a316b67773587f024b1d8d7814d9246876/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=9e0625a316b67773587f024b1d8d7814d9246876", "patch": "@@ -1402,7 +1402,8 @@ extern const char leaf_reg_remap[];\n    SMALL_INT is used throughout the port so we continue to use it.  */\n #define SMALL_INT(X) (SPARC_SIMM13_P (INTVAL (X)))\n /* 13 bit immediate, considering only the low 32 bits */\n-#define SMALL_INT32(X) (SPARC_SIMM13_P ((int)INTVAL (X) & 0xffffffff))\n+#define SMALL_INT32(X) (SPARC_SIMM13_P (trunc_int_for_mode \\\n+\t\t\t\t\t(INTVAL (X), SImode)))\n #define SPARC_SETHI_P(X) \\\n (((unsigned HOST_WIDE_INT) (X) & \\\n   (TARGET_ARCH64 ? ~(unsigned HOST_WIDE_INT) 0xfffffc00 : 0x3ff)) == 0)"}, {"sha": "2bad3b841ae674a668db1b2b4111075a0b26b289", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e0625a316b67773587f024b1d8d7814d9246876/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e0625a316b67773587f024b1d8d7814d9246876/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=9e0625a316b67773587f024b1d8d7814d9246876", "patch": "@@ -2053,14 +2053,8 @@\n      a double if needed.  */\n   if (GET_CODE (operands[1]) == CONST_DOUBLE)\n     {\n-      operands[1] = GEN_INT (CONST_DOUBLE_LOW (operands[1]) & 0xff);\n-    }\n-  else if (GET_CODE (operands[1]) == CONST_INT)\n-    {\n-      /* And further, we know for all QI cases that only the\n-\t low byte is significant, which we can always process\n-\t in a single insn.  So mask it now.  */\n-      operands[1] = GEN_INT (INTVAL (operands[1]) & 0xff);\n+      operands[1] = GEN_INT (trunc_int_for_mode\n+\t\t\t     (CONST_DOUBLE_LOW (operands[1]), QImode));\n     }\n \n   /* Handle sets of MEM first.  */\n@@ -2769,8 +2763,8 @@\n #else\n   unsigned int low, high;\n \n-  low = INTVAL (operands[1]) & 0xffffffff;\n-  high = (INTVAL (operands[1]) >> 32) & 0xffffffff;\n+  low = trunc_int_for_mode (INTVAL (operands[1]), SImode);\n+  high = trunc_int_for_mode (INTVAL (operands[1]) >> 32, SImode);\n   emit_insn (gen_movsi (gen_highpart (SImode, operands[0]), GEN_INT (high)));\n \n   /* Slick... but this trick loses if this subreg constant part\n@@ -6574,7 +6568,7 @@\n    (set (match_dup 0) (and:SI (not:SI (match_dup 3)) (match_dup 1)))]\n   \"\n {\n-  operands[4] = GEN_INT (~INTVAL (operands[2]) & 0xffffffff);\n+  operands[4] = GEN_INT (~INTVAL (operands[2]));\n }\")\n \n ;; Split DImode logical operations requiring two instructions.\n@@ -6717,7 +6711,7 @@\n    (set (match_dup 0) (ior:SI (not:SI (match_dup 3)) (match_dup 1)))]\n   \"\n {\n-  operands[4] = GEN_INT (~INTVAL (operands[2]) & 0xffffffff);\n+  operands[4] = GEN_INT (~INTVAL (operands[2]));\n }\")\n \n (define_insn \"*or_not_di_sp32\"\n@@ -6833,7 +6827,7 @@\n    (set (match_dup 0) (not:SI (xor:SI (match_dup 3) (match_dup 1))))]\n   \"\n {\n-  operands[4] = GEN_INT (~INTVAL (operands[2]) & 0xffffffff);\n+  operands[4] = GEN_INT (~INTVAL (operands[2]));\n }\")\n \n (define_split\n@@ -6848,7 +6842,7 @@\n    (set (match_dup 0) (xor:SI (match_dup 3) (match_dup 1)))]\n   \"\n {\n-  operands[4] = GEN_INT (~INTVAL (operands[2]) & 0xffffffff);\n+  operands[4] = GEN_INT (~INTVAL (operands[2]));\n }\")\n \n ;; xnor patterns.  Note that (a ^ ~b) == (~a ^ b) == ~(a ^ b)."}]}