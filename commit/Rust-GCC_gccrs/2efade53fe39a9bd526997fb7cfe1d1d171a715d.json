{"sha": "2efade53fe39a9bd526997fb7cfe1d1d171a715d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmVmYWRlNTNmZTM5YTliZDUyNjk5N2ZiN2NmZTFkMWQxNzFhNzE1ZA==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2018-10-23T08:27:14Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2018-10-23T08:27:14Z"}, "message": "re PR fortran/85603 (ICE with character array substring assignment)\n\n2018-10-23  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/85603\n\t* frontend-passes.c (get_len_call): New function to generate a\n\tcall to intrinsic LEN.\n\t(create_var): Use this to make length expressions for variable\n\trhs string lengths.\n\tClean up some white space issues.\n\n2018-10-23  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/85603\n\t* gfortran.dg/deferred_character_23.f90 : Check reallocation is\n\toccurring as it should and a regression caused by version 1 of\n\tthis patch.\n\nFrom-SVN: r265412", "tree": {"sha": "f88479b8fc010c44ef3124ad857c67a3949953bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f88479b8fc010c44ef3124ad857c67a3949953bf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2efade53fe39a9bd526997fb7cfe1d1d171a715d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2efade53fe39a9bd526997fb7cfe1d1d171a715d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2efade53fe39a9bd526997fb7cfe1d1d171a715d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2efade53fe39a9bd526997fb7cfe1d1d171a715d/comments", "author": null, "committer": null, "parents": [{"sha": "a847d2b7b142a86b02296a7766a1bc29f36cf7a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a847d2b7b142a86b02296a7766a1bc29f36cf7a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a847d2b7b142a86b02296a7766a1bc29f36cf7a8"}], "stats": {"total": 140, "additions": 121, "deletions": 19}, "files": [{"sha": "f3239d761022d4674741dd27f63277d231f4f7ab", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efade53fe39a9bd526997fb7cfe1d1d171a715d/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efade53fe39a9bd526997fb7cfe1d1d171a715d/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=2efade53fe39a9bd526997fb7cfe1d1d171a715d", "patch": "@@ -1,3 +1,12 @@\n+2018-10-23  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/85603\n+\t* frontend-passes.c (get_len_call): New function to generate a\n+\tcall to intrinsic LEN.\n+\t(create_var): Use this to make length expressions for variable\n+\trhs string lengths.\n+\tClean up some white space issues.\n+\n 2018-10-21  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/71880"}, {"sha": "d380dcfb3cb429cea9d5d98f6b7944589113b4b6", "filename": "gcc/fortran/frontend-passes.c", "status": "modified", "additions": 57, "deletions": 17, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efade53fe39a9bd526997fb7cfe1d1d171a715d/gcc%2Ffortran%2Ffrontend-passes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efade53fe39a9bd526997fb7cfe1d1d171a715d/gcc%2Ffortran%2Ffrontend-passes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ffrontend-passes.c?ref=2efade53fe39a9bd526997fb7cfe1d1d171a715d", "patch": "@@ -280,7 +280,7 @@ realloc_string_callback (gfc_code **c, int *walk_subtrees ATTRIBUTE_UNUSED,\n \t   && (expr2->expr_type != EXPR_OP\n \t       || expr2->value.op.op != INTRINSIC_CONCAT))\n     return 0;\n-  \n+\n   if (!gfc_check_dependency (expr1, expr2, true))\n     return 0;\n \n@@ -704,6 +704,41 @@ insert_block ()\n   return ns;\n }\n \n+\n+/* Insert a call to the intrinsic len. Use a different name for\n+   the symbol tree so we don't run into trouble when the user has\n+   renamed len for some reason.  */\n+\n+static gfc_expr*\n+get_len_call (gfc_expr *str)\n+{\n+  gfc_expr *fcn;\n+  gfc_actual_arglist *actual_arglist;\n+\n+  fcn = gfc_get_expr ();\n+  fcn->expr_type = EXPR_FUNCTION;\n+  fcn->value.function.isym = gfc_intrinsic_function_by_id (GFC_ISYM_LEN);\n+  actual_arglist = gfc_get_actual_arglist ();\n+  actual_arglist->expr = str;\n+\n+  fcn->value.function.actual = actual_arglist;\n+  fcn->where = str->where;\n+  fcn->ts.type = BT_INTEGER;\n+  fcn->ts.kind = gfc_charlen_int_kind;\n+\n+  gfc_get_sym_tree (\"__internal_len\", current_ns, &fcn->symtree, false);\n+  fcn->symtree->n.sym->ts = fcn->ts;\n+  fcn->symtree->n.sym->attr.flavor = FL_PROCEDURE;\n+  fcn->symtree->n.sym->attr.function = 1;\n+  fcn->symtree->n.sym->attr.elemental = 1;\n+  fcn->symtree->n.sym->attr.referenced = 1;\n+  fcn->symtree->n.sym->attr.access = ACCESS_PRIVATE;\n+  gfc_commit_symbol (fcn->symtree->n.sym);\n+\n+  return fcn;\n+}\n+\n+\n /* Returns a new expression (a variable) to be used in place of the old one,\n    with an optional assignment statement before the current statement to set\n    the value of the variable. Creates a new BLOCK for the statement if that\n@@ -786,6 +821,10 @@ create_var (gfc_expr * e, const char *vname)\n       length = constant_string_length (e);\n       if (length)\n \tsymbol->ts.u.cl->length = length;\n+      else if (e->expr_type == EXPR_VARIABLE\n+\t       && e->symtree->n.sym->ts.type == BT_CHARACTER\n+\t       && e->ts.u.cl->length)\n+\tsymbol->ts.u.cl->length = get_len_call (gfc_copy_expr (e));\n       else\n \t{\n \t  symbol->attr.allocatable = 1;\n@@ -1226,7 +1265,7 @@ traverse_io_block (gfc_code *code, bool *has_reached, gfc_code *prev)\n \t    {\n \t      /* Check for (a(i,i), i=1,3).  */\n \t      int j;\n-\t      \n+\n \t      for (j=0; j<i; j++)\n \t\tif (iters[j] && iters[j]->var->symtree == start->symtree)\n \t\t  return false;\n@@ -1286,7 +1325,7 @@ traverse_io_block (gfc_code *code, bool *has_reached, gfc_code *prev)\n \t\t      || var_in_expr (var, iters[j]->end)\n \t\t      || var_in_expr (var, iters[j]->step)))\n \t\t  return false;\n-\t    }\t\t  \n+\t    }\n \t}\n     }\n \n@@ -2019,6 +2058,7 @@ get_len_trim_call (gfc_expr *str, int kind)\n   return fcn;\n }\n \n+\n /* Optimize expressions for equality.  */\n \n static bool\n@@ -2626,7 +2666,7 @@ do_subscript (gfc_expr **e)\n \n \t      /* If we do not know about the stepsize, the loop may be zero trip.\n \t\t Do not warn in this case.  */\n-\t  \n+\n \t      if (dl->ext.iterator->step->expr_type == EXPR_CONSTANT)\n \t\tmpz_init_set (do_step, dl->ext.iterator->step->value.integer);\n \t      else\n@@ -2640,7 +2680,7 @@ do_subscript (gfc_expr **e)\n \t      else\n \t\thave_do_start = false;\n \n-\t  \n+\n \t      if (dl->ext.iterator->end->expr_type == EXPR_CONSTANT)\n \t\t{\n \t\t  have_do_end = true;\n@@ -2806,7 +2846,7 @@ matmul_to_var_expr (gfc_expr **ep, int *walk_subtrees ATTRIBUTE_UNUSED,\n {\n   gfc_expr *e, *n;\n   bool *found = (bool *) data;\n-  \n+\n   e = *ep;\n \n   if (e->expr_type != EXPR_FUNCTION\n@@ -2819,19 +2859,19 @@ matmul_to_var_expr (gfc_expr **ep, int *walk_subtrees ATTRIBUTE_UNUSED,\n     return 0;\n \n   /* Check if this is already in the form c = matmul(a,b).  */\n-  \n+\n   if ((*current_code)->expr2 == e)\n     return 0;\n \n   n = create_var (e, \"matmul\");\n-  \n+\n   /* If create_var is unable to create a variable (for example if\n      -fno-realloc-lhs is in force with a variable that does not have bounds\n      known at compile-time), just return.  */\n \n   if (n == NULL)\n     return 0;\n-  \n+\n   *ep = n;\n   *found = true;\n   return 0;\n@@ -2850,7 +2890,7 @@ matmul_to_var_code (gfc_code **c, int *walk_subtrees ATTRIBUTE_UNUSED,\n       inserted_block = NULL;\n       changed_statement = NULL;\n     }\n-  \n+\n   return 0;\n }\n \n@@ -2870,7 +2910,7 @@ matmul_temp_args (gfc_code **c, int *walk_subtrees ATTRIBUTE_UNUSED,\n   bool a_tmp, b_tmp;\n   gfc_expr *matrix_a, *matrix_b;\n   bool conjg_a, conjg_b, transpose_a, transpose_b;\n-  \n+\n   co = *c;\n \n   if (co->op != EXEC_ASSIGN)\n@@ -2920,7 +2960,7 @@ matmul_temp_args (gfc_code **c, int *walk_subtrees ATTRIBUTE_UNUSED,\n \n   if (!a_tmp && !b_tmp)\n     return 0;\n-  \n+\n   current_code = c;\n   inserted_block = NULL;\n   changed_statement = NULL;\n@@ -3648,7 +3688,7 @@ scalarized_expr (gfc_expr *e_in, gfc_expr **index, int count_index)\n \t\t      /* For assumed size, we need to keep around the final\n \t\t\t reference in order not to get an error on resolution\n \t\t\t below, and we cannot use AR_FULL.  */\n-\t\t\t \n+\n \t\t      if (ar->as->type == AS_ASSUMED_SIZE)\n \t\t\t{\n \t\t\t  ar->type = AR_SECTION;\n@@ -4604,7 +4644,7 @@ call_external_blas (gfc_code **c, int *walk_subtrees ATTRIBUTE_UNUSED,\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n-    }    \n+    }\n \n   /* Handle the reallocation, if needed.  */\n \n@@ -4756,7 +4796,7 @@ typedef struct {\n   int n[GFC_MAX_DIMENSIONS];\n } ind_type;\n \n-/* Callback function to determine if an expression is the \n+/* Callback function to determine if an expression is the\n    corresponding variable.  */\n \n static int\n@@ -4842,7 +4882,7 @@ index_interchange (gfc_code **c, int *walk_subtrees ATTRIBUTE_UNUSED,\n   gfc_forall_iterator *fa;\n   ind_type *ind;\n   int i, j;\n-  \n+\n   if (co->op != EXEC_FORALL && co->op != EXEC_DO_CONCURRENT)\n     return 0;\n \n@@ -5358,7 +5398,7 @@ gfc_code_walker (gfc_code **c, walk_code_fn_t codefn, walk_expr_fn_t exprfn,\n \n \t  if (co->op == EXEC_SELECT)\n \t    select_level --;\n-  \n+\n \t  in_omp_workshare = saved_in_omp_workshare;\n \t  in_where = saved_in_where;\n \t}"}, {"sha": "9441c26e06dc817b4c405a2edf4bd037062cc558", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efade53fe39a9bd526997fb7cfe1d1d171a715d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efade53fe39a9bd526997fb7cfe1d1d171a715d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2efade53fe39a9bd526997fb7cfe1d1d171a715d", "patch": "@@ -1,3 +1,10 @@\n+2018-10-23  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/85603\n+\t* gfortran.dg/deferred_character_23.f90 : Check reallocation is\n+\toccurring as it should and a regression caused by version 1 of\n+\tthis patch.\n+\n 2018-10-22  Yury Gribov  <tetra2005@gmail.com>\n \n \tPR tree-optimization/87633"}, {"sha": "5d8beca9dcd6c54234f6f1d280775291a6c42eb6", "filename": "gcc/testsuite/gfortran.dg/deferred_character_23.f90", "status": "modified", "additions": 48, "deletions": 2, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efade53fe39a9bd526997fb7cfe1d1d171a715d/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_23.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efade53fe39a9bd526997fb7cfe1d1d171a715d/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_23.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_23.f90?ref=2efade53fe39a9bd526997fb7cfe1d1d171a715d", "patch": "@@ -3,6 +3,29 @@\n ! Tests the fix for PR85603.\n !\n ! Contributed by Walt Spector  <w6ws@earthlink.net>\n+!_____________________________________________\n+! Module for a test against a regression that occurred with\n+! the first patch for this PR.\n+!\n+MODULE TN4\n+  IMPLICIT NONE\n+  PRIVATE\n+  INTEGER,PARAMETER::SH4=KIND('a')\n+  TYPE,PUBLIC::TOP\n+    CHARACTER(:,KIND=SH4),ALLOCATABLE::ROR\n+    CHARACTER(:,KIND=SH4),ALLOCATABLE::VI8\n+  CONTAINS\n+    PROCEDURE,NON_OVERRIDABLE::SB=>TPX\n+  END TYPE TOP\n+CONTAINS\n+  SUBROUTINE TPX(TP6,PP4)\n+    CLASS(TOP),INTENT(INOUT)::TP6\n+    INTEGER,INTENT(IN)::PP4\n+    TP6%ROR=TP6%ROR(:PP4-1)\n+    TP6%VI8=TP6%ROR(:PP4-1)\n+  END SUBROUTINE TPX\n+END MODULE TN4\n+!_____________________________________________\n !\n program strlen_bug\n   implicit none\n@@ -15,8 +38,31 @@ program strlen_bug\n       'somewhat longer' ]\n   maxlen = maxval (len_trim (strings))\n   if (maxlen .ne. 15) stop 1\n-  strings = strings(:)(:maxlen) ! Used to ICE\n-  if (any (strings .ne. ['short          ','somewhat longer'])) stop 2\n+\n+! Used to cause an ICE and in the later version of the problem did not reallocate.\n+  strings = strings(:)(:maxlen)\n+  if (any (strings .ne. ['short          ','somewhat longer' ])) stop 2\n+  if (len (strings) .ne. maxlen) stop 3\n+\n+! Try something a bit more complicated.\n+  strings = strings(:)(2:maxlen - 5)\n+  if (any (strings .ne. ['hort     ','omewhat l' ])) stop 4\n+  if (len (strings) .ne. maxlen - 6) stop 5\n \n   deallocate (strings)          ! To check for memory leaks\n+\n+! Test the regression, noted by Dominique d'Humieres is fixed.\n+! Referenced in https://groups.google.com/forum/#!topic/comp.lang.fortran/nV3TlRlVKBc\n+!\n+  call foo\n+contains\n+  subroutine foo\n+    USE TN4\n+    TYPE(TOP) :: Z\n+\n+    Z%ROR = 'abcd'\n+    call Z%SB (3)\n+    if (Z%VI8 .ne. 'ab') stop 6\n+end\n+\n end program"}]}