{"sha": "4e7c4b7301cfb6f74e398b9e86f63fadd4d82665", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGU3YzRiNzMwMWNmYjZmNzRlMzk4YjllODZmNjNmYWRkNGQ4MjY2NQ==", "commit": {"author": {"name": "Marc Glisse", "email": "marc.glisse@inria.fr", "date": "2012-08-03T12:21:14Z"}, "committer": {"name": "Marc Glisse", "email": "glisse@gcc.gnu.org", "date": "2012-08-03T12:21:14Z"}, "message": "re PR tree-optimization/30318 (VRP does not create ANTI_RANGEs on overflow)\n\ngcc/\n2012-08-03 Marc Glisse <marc.glisse@inria.fr>\n\n\tPR tree-optimization/30318\n\t* double-int.c (mul_double_wide_with_sign): New function.\n\t(mul_double_with_sign): Call the new function.\n\t* double-int.h (mul_double_wide_with_sign): Declare the new function.\n\t* tree-vrp.c (extract_range_from_binary_expr_1) [MULT_EXPR]:\n\tHandle integer types that wrap on overflow.\n\t(quad_int_cmp): New helper function.\n\t(quad_int_pair_sort): Likewise.\n\n\ngcc/testsuite/\n2012-08-03 Marc Glisse <marc.glisse@inria.fr>\n\n\tPR tree-optimization/30318\n\t* gcc.dg/tree-ssa/vrp77.c: New testcase.\n\nFrom-SVN: r190125", "tree": {"sha": "567eda01e87e579ad9caa799953466f4a2dfb161", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/567eda01e87e579ad9caa799953466f4a2dfb161"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4e7c4b7301cfb6f74e398b9e86f63fadd4d82665", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e7c4b7301cfb6f74e398b9e86f63fadd4d82665", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e7c4b7301cfb6f74e398b9e86f63fadd4d82665", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e7c4b7301cfb6f74e398b9e86f63fadd4d82665/comments", "author": {"login": "mglisse", "id": 10097863, "node_id": "MDQ6VXNlcjEwMDk3ODYz", "avatar_url": "https://avatars.githubusercontent.com/u/10097863?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mglisse", "html_url": "https://github.com/mglisse", "followers_url": "https://api.github.com/users/mglisse/followers", "following_url": "https://api.github.com/users/mglisse/following{/other_user}", "gists_url": "https://api.github.com/users/mglisse/gists{/gist_id}", "starred_url": "https://api.github.com/users/mglisse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mglisse/subscriptions", "organizations_url": "https://api.github.com/users/mglisse/orgs", "repos_url": "https://api.github.com/users/mglisse/repos", "events_url": "https://api.github.com/users/mglisse/events{/privacy}", "received_events_url": "https://api.github.com/users/mglisse/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "11f359257e79a5d8cd68458188b8c126f10b6fc9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11f359257e79a5d8cd68458188b8c126f10b6fc9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11f359257e79a5d8cd68458188b8c126f10b6fc9"}], "stats": {"total": 236, "additions": 229, "deletions": 7}, "files": [{"sha": "a8923b3885a685f7c8cf9ae8928df1f4766377a6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e7c4b7301cfb6f74e398b9e86f63fadd4d82665/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e7c4b7301cfb6f74e398b9e86f63fadd4d82665/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4e7c4b7301cfb6f74e398b9e86f63fadd4d82665", "patch": "@@ -1,3 +1,14 @@\n+2012-08-03 Marc Glisse <marc.glisse@inria.fr>\n+\n+\tPR tree-optimization/30318\n+\t* double-int.c (mul_double_wide_with_sign): New function.\n+\t(mul_double_with_sign): Call the new function.\n+\t* double-int.h (mul_double_wide_with_sign): Declare the new function.\n+\t* tree-vrp.c (extract_range_from_binary_expr_1) [MULT_EXPR]:\n+\tHandle integer types that wrap on overflow.\n+\t(quad_int_cmp): New helper function.\n+\t(quad_int_pair_sort): Likewise.\n+\n 2012-08-03  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-vect-loop-manip.c (vect_can_advance_ivs_p): Query"}, {"sha": "1204dc77aadf226699f8e6301e581abaadc6a1b6", "filename": "gcc/double-int.c", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e7c4b7301cfb6f74e398b9e86f63fadd4d82665/gcc%2Fdouble-int.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e7c4b7301cfb6f74e398b9e86f63fadd4d82665/gcc%2Fdouble-int.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdouble-int.c?ref=4e7c4b7301cfb6f74e398b9e86f63fadd4d82665", "patch": "@@ -134,14 +134,29 @@ mul_double_with_sign (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n \t\t      unsigned HOST_WIDE_INT l2, HOST_WIDE_INT h2,\n \t\t      unsigned HOST_WIDE_INT *lv, HOST_WIDE_INT *hv,\n \t\t      bool unsigned_p)\n+{\n+  unsigned HOST_WIDE_INT toplow;\n+  HOST_WIDE_INT tophigh;\n+\n+  return mul_double_wide_with_sign (l1, h1, l2, h2,\n+\t\t\t\t    lv, hv, &toplow, &tophigh,\n+\t\t\t\t    unsigned_p);\n+}\n+\n+int\n+mul_double_wide_with_sign (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n+\t\t\t   unsigned HOST_WIDE_INT l2, HOST_WIDE_INT h2,\n+\t\t\t   unsigned HOST_WIDE_INT *lv, HOST_WIDE_INT *hv,\n+\t\t\t   unsigned HOST_WIDE_INT *lw, HOST_WIDE_INT *hw,\n+\t\t\t   bool unsigned_p)\n {\n   HOST_WIDE_INT arg1[4];\n   HOST_WIDE_INT arg2[4];\n   HOST_WIDE_INT prod[4 * 2];\n   unsigned HOST_WIDE_INT carry;\n   int i, j, k;\n-  unsigned HOST_WIDE_INT toplow, neglow;\n-  HOST_WIDE_INT tophigh, neghigh;\n+  unsigned HOST_WIDE_INT neglow;\n+  HOST_WIDE_INT neghigh;\n \n   encode (arg1, l1, h1);\n   encode (arg2, l2, h2);\n@@ -165,25 +180,25 @@ mul_double_with_sign (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n     }\n \n   decode (prod, lv, hv);\n-  decode (prod + 4, &toplow, &tophigh);\n+  decode (prod + 4, lw, hw);\n \n   /* Unsigned overflow is immediate.  */\n   if (unsigned_p)\n-    return (toplow | tophigh) != 0;\n+    return (*lw | *hw) != 0;\n \n   /* Check for signed overflow by calculating the signed representation of the\n      top half of the result; it should agree with the low half's sign bit.  */\n   if (h1 < 0)\n     {\n       neg_double (l2, h2, &neglow, &neghigh);\n-      add_double (neglow, neghigh, toplow, tophigh, &toplow, &tophigh);\n+      add_double (neglow, neghigh, *lw, *hw, lw, hw);\n     }\n   if (h2 < 0)\n     {\n       neg_double (l1, h1, &neglow, &neghigh);\n-      add_double (neglow, neghigh, toplow, tophigh, &toplow, &tophigh);\n+      add_double (neglow, neghigh, *lw, *hw, lw, hw);\n     }\n-  return (*hv < 0 ? ~(toplow & tophigh) : toplow | tophigh) != 0;\n+  return (*hv < 0 ? ~(*lw & *hw) : *lw | *hw) != 0;\n }\n \n /* Shift the doubleword integer in L1, H1 right by COUNT places"}, {"sha": "4c4c1b3ecbd770847b162da4f34cebc5c2ff5d19", "filename": "gcc/double-int.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e7c4b7301cfb6f74e398b9e86f63fadd4d82665/gcc%2Fdouble-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e7c4b7301cfb6f74e398b9e86f63fadd4d82665/gcc%2Fdouble-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdouble-int.h?ref=4e7c4b7301cfb6f74e398b9e86f63fadd4d82665", "patch": "@@ -307,6 +307,11 @@ extern int mul_double_with_sign (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t\t unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t\t unsigned HOST_WIDE_INT *, HOST_WIDE_INT *,\n \t\t\t\t bool);\n+extern int mul_double_wide_with_sign (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t\t      unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t\t      unsigned HOST_WIDE_INT *, HOST_WIDE_INT *,\n+\t\t\t\t      unsigned HOST_WIDE_INT *, HOST_WIDE_INT *,\n+\t\t\t\t      bool);\n #define mul_double(l1,h1,l2,h2,lv,hv) \\\n   mul_double_with_sign (l1, h1, l2, h2, lv, hv, false)\n extern void lshift_double (unsigned HOST_WIDE_INT, HOST_WIDE_INT,"}, {"sha": "b7486f97c2828c6123ee8c3b053ee27b1c78ed94", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e7c4b7301cfb6f74e398b9e86f63fadd4d82665/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e7c4b7301cfb6f74e398b9e86f63fadd4d82665/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4e7c4b7301cfb6f74e398b9e86f63fadd4d82665", "patch": "@@ -1,3 +1,8 @@\n+2012-08-03 Marc Glisse <marc.glisse@inria.fr>\n+\n+\tPR tree-optimization/30318\n+\t* gcc.dg/tree-ssa/vrp77.c: New testcase.\n+\n 2012-08-03  Marc Glisse  <marc.glisse@inria.fr>\n \n \t* g++.dg/ext/vector17.C: New testcase."}, {"sha": "c0a8a865388da3310bcd71fdd118e3be795856f5", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp77.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e7c4b7301cfb6f74e398b9e86f63fadd4d82665/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp77.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e7c4b7301cfb6f74e398b9e86f63fadd4d82665/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp77.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp77.c?ref=4e7c4b7301cfb6f74e398b9e86f63fadd4d82665", "patch": "@@ -0,0 +1,47 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+#ifdef __SIZEOF_INT128__\n+#define T __int128\n+#else\n+#define T long long\n+#endif\n+\n+extern void impossible (void);\n+\n+void f(T x)\n+{\n+  unsigned T y;\n+  unsigned T z;\n+  if (x < -7)\n+    return;\n+  if (x > 2)\n+    return;\n+  y = x;\n+  z = y * y;\n+  if (z == 666)\n+    impossible ();\n+}\n+\n+void g(unsigned T x)\n+{\n+  unsigned T y;\n+  unsigned T z;\n+  unsigned T m = -1;\n+  m = m / 2;\n+  if (x < m-2)\n+    return;\n+  if (x > m-1)\n+    return;\n+  y = x;\n+  z = y * y;\n+  /* The product (ignoring it is a square) has only 3 possible values:\n+     4, 9 and 2^127+6.  At least one of the values 7, 666 and -666 is\n+     known to be impossible.  7 is the most logical in the current\n+     implementation.  */\n+  if (z == 7)\n+    impossible ();\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"impossible\" \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "0d41493a6b01c6196ad73f27f84d29e568c138c6", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e7c4b7301cfb6f74e398b9e86f63fadd4d82665/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e7c4b7301cfb6f74e398b9e86f63fadd4d82665/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=4e7c4b7301cfb6f74e398b9e86f63fadd4d82665", "patch": "@@ -2188,6 +2188,28 @@ extract_range_from_multiplicative_op_1 (value_range_t *vr,\n     set_value_range (vr, type, min, max, NULL);\n }\n \n+/* Some quadruple precision helpers.  */\n+static int\n+quad_int_cmp (double_int l0, double_int h0,\n+\t      double_int l1, double_int h1, bool uns)\n+{\n+  int c = double_int_cmp (h0, h1, uns);\n+  if (c != 0) return c;\n+  return double_int_ucmp (l0, l1);\n+}\n+\n+static void\n+quad_int_pair_sort (double_int *l0, double_int *h0,\n+\t\t    double_int *l1, double_int *h1, bool uns)\n+{\n+  if (quad_int_cmp (*l0, *h0, *l1, *h1, uns) > 0)\n+    {\n+      double_int tmp;\n+      tmp = *l0; *l0 = *l1; *l1 = tmp;\n+      tmp = *h0; *h0 = *h1; *h1 = tmp;\n+    }\n+}\n+\n /* Extract range information from a binary operation CODE based on\n    the ranges of each of its operands, *VR0 and *VR1 with resulting\n    type EXPR_TYPE.  The resulting range is stored in *VR.  */\n@@ -2569,6 +2591,123 @@ extract_range_from_binary_expr_1 (value_range_t *vr,\n     }\n   else if (code == MULT_EXPR)\n     {\n+      /* Fancy code so that with unsigned, [-3,-1]*[-3,-1] does not\n+\t drop to varying.  */\n+      if (range_int_cst_p (&vr0)\n+\t  && range_int_cst_p (&vr1)\n+\t  && TYPE_OVERFLOW_WRAPS (expr_type))\n+\t{\n+\t  double_int min0, max0, min1, max1, sizem1, size;\n+\t  double_int prod0l, prod0h, prod1l, prod1h,\n+\t\t     prod2l, prod2h, prod3l, prod3h;\n+\t  bool uns0, uns1, uns;\n+\n+\t  sizem1 = double_int_max_value (TYPE_PRECISION (expr_type), true);\n+\t  size = double_int_add (sizem1, double_int_one);\n+\n+\t  min0 = tree_to_double_int (vr0.min);\n+\t  max0 = tree_to_double_int (vr0.max);\n+\t  min1 = tree_to_double_int (vr1.min);\n+\t  max1 = tree_to_double_int (vr1.max);\n+\n+\t  uns0 = TYPE_UNSIGNED (expr_type);\n+\t  uns1 = uns0;\n+\n+\t  /* Canonicalize the intervals.  */\n+\t  if (TYPE_UNSIGNED (expr_type))\n+\t    {\n+\t      double_int min2 = double_int_sub (size, min0);\n+\t      if (double_int_cmp (min2, max0, true) < 0)\n+\t\t{\n+\t\t  min0 = double_int_neg (min2);\n+\t\t  max0 = double_int_sub (max0, size);\n+\t\t  uns0 = false;\n+\t\t}\n+\n+\t      min2 = double_int_sub (size, min1);\n+\t      if (double_int_cmp (min2, max1, true) < 0)\n+\t\t{\n+\t\t  min1 = double_int_neg (min2);\n+\t\t  max1 = double_int_sub (max1, size);\n+\t\t  uns1 = false;\n+\t\t}\n+\t    }\n+\t  uns = uns0 & uns1;\n+\n+\t  mul_double_wide_with_sign (min0.low, min0.high,\n+\t\t\t\t     min1.low, min1.high,\n+\t\t\t\t     &prod0l.low, &prod0l.high,\n+\t\t\t\t     &prod0h.low, &prod0h.high, true);\n+\t  if (!uns0 && double_int_negative_p (min0))\n+\t    prod0h = double_int_sub (prod0h, min1);\n+\t  if (!uns1 && double_int_negative_p (min1))\n+\t    prod0h = double_int_sub (prod0h, min0);\n+\n+\t  mul_double_wide_with_sign (min0.low, min0.high,\n+\t\t\t\t     max1.low, max1.high,\n+\t\t\t\t     &prod1l.low, &prod1l.high,\n+\t\t\t\t     &prod1h.low, &prod1h.high, true);\n+\t  if (!uns0 && double_int_negative_p (min0))\n+\t    prod1h = double_int_sub (prod1h, max1);\n+\t  if (!uns1 && double_int_negative_p (max1))\n+\t    prod1h = double_int_sub (prod1h, min0);\n+\n+\t  mul_double_wide_with_sign (max0.low, max0.high,\n+\t\t\t\t     min1.low, min1.high,\n+\t\t\t\t     &prod2l.low, &prod2l.high,\n+\t\t\t\t     &prod2h.low, &prod2h.high, true);\n+\t  if (!uns0 && double_int_negative_p (max0))\n+\t    prod2h = double_int_sub (prod2h, min1);\n+\t  if (!uns1 && double_int_negative_p (min1))\n+\t    prod2h = double_int_sub (prod2h, max0);\n+\n+\t  mul_double_wide_with_sign (max0.low, max0.high,\n+\t\t\t\t     max1.low, max1.high,\n+\t\t\t\t     &prod3l.low, &prod3l.high,\n+\t\t\t\t     &prod3h.low, &prod3h.high, true);\n+\t  if (!uns0 && double_int_negative_p (max0))\n+\t    prod3h = double_int_sub (prod3h, max1);\n+\t  if (!uns1 && double_int_negative_p (max1))\n+\t    prod3h = double_int_sub (prod3h, max0);\n+\n+\t  /* Sort the 4 products.  */\n+\t  quad_int_pair_sort (&prod0l, &prod0h, &prod3l, &prod3h, uns);\n+\t  quad_int_pair_sort (&prod1l, &prod1h, &prod2l, &prod2h, uns);\n+\t  quad_int_pair_sort (&prod0l, &prod0h, &prod1l, &prod1h, uns);\n+\t  quad_int_pair_sort (&prod2l, &prod2h, &prod3l, &prod3h, uns);\n+\n+\t  /* Max - min.  */\n+\t  if (double_int_zero_p (prod0l))\n+\t    {\n+\t      prod1l = double_int_zero;\n+\t      prod1h = double_int_neg (prod0h);\n+\t    }\n+\t  else\n+\t    {\n+\t      prod1l = double_int_neg (prod0l);\n+\t      prod1h = double_int_not (prod0h);\n+\t    }\n+\t  prod2l = double_int_add (prod3l, prod1l);\n+\t  prod2h = double_int_add (prod3h, prod1h);\n+\t  if (double_int_ucmp (prod2l, prod3l) < 0)\n+\t    prod2h = double_int_add (prod2h, double_int_one); /* carry */\n+\n+\t  if (!double_int_zero_p (prod2h)\n+\t      || double_int_cmp (prod2l, sizem1, true) >= 0)\n+\t    {\n+\t      /* the range covers all values.  */\n+\t      set_value_range_to_varying (vr);\n+\t      return;\n+\t    }\n+\n+\t  /* The following should handle the wrapping and selecting\n+\t     VR_ANTI_RANGE for us.  */\n+\t  min = double_int_to_tree (expr_type, prod0l);\n+\t  max = double_int_to_tree (expr_type, prod3l);\n+\t  set_and_canonicalize_value_range (vr, VR_RANGE, min, max, NULL);\n+\t  return;\n+\t}\n+\n       /* If we have an unsigned MULT_EXPR with two VR_ANTI_RANGEs,\n \t drop to VR_VARYING.  It would take more effort to compute a\n \t precise range for such a case.  For example, if we have"}]}