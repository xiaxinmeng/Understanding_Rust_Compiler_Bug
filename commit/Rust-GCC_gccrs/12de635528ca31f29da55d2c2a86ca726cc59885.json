{"sha": "12de635528ca31f29da55d2c2a86ca726cc59885", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTJkZTYzNTUyOGNhMzFmMjlkYTU1ZDJjMmE4NmNhNzI2Y2M1OTg4NQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2010-04-16T13:21:38Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2010-04-16T13:21:38Z"}, "message": "re PR tree-optimization/43572 (FAIL: gfortran.dg/PR19872.f execution test; formatted read - wrong numbers)\n\n2010-04-16  Richard Guenther  <rguenther@suse.de>\n\n\tPR tree-optimization/43572\n\t* tree-ssa-alias.h (call_may_clobber_ref_p): Declare.\n\t* tree-ssa-alias.c (call_may_clobber_ref_p): Export.\n\t* tree-flow.h (is_call_clobbered): Remove.\n\t* tree-flow-inline.h (is_call_clobbered): Likewise.\n\t* tree-dfa.c (dump_variable): Do not dump call clobber state.\n\t* tree-nrv.c (dest_safe_for_nrv_p): Use the alias oracle.\n\t(execute_return_slot_opt): Adjust.\n\t* tree-tailcall.c (suitable_for_tail_opt_p): Remove\n\tcheck for call clobbered vars here.\n\t(find_tail_calls): Move tailcall verification to the\n\tproper place.\n\n\t* gcc.dg/tree-ssa/tailcall-5.c: New testcase.\n\nFrom-SVN: r158418", "tree": {"sha": "640a4ede30c1f4cf1f9690d68ebfea15522967e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/640a4ede30c1f4cf1f9690d68ebfea15522967e3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/12de635528ca31f29da55d2c2a86ca726cc59885", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12de635528ca31f29da55d2c2a86ca726cc59885", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12de635528ca31f29da55d2c2a86ca726cc59885", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12de635528ca31f29da55d2c2a86ca726cc59885/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6ab643b5a439320654d52b678e19bdf21995b1d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ab643b5a439320654d52b678e19bdf21995b1d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ab643b5a439320654d52b678e19bdf21995b1d8"}], "stats": {"total": 115, "additions": 57, "deletions": 58}, "files": [{"sha": "bd2dc3c56bf9b22575e7475c3d69ee215b639ccf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12de635528ca31f29da55d2c2a86ca726cc59885/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12de635528ca31f29da55d2c2a86ca726cc59885/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=12de635528ca31f29da55d2c2a86ca726cc59885", "patch": "@@ -1,3 +1,18 @@\n+2010-04-16  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/43572\n+\t* tree-ssa-alias.h (call_may_clobber_ref_p): Declare.\n+\t* tree-ssa-alias.c (call_may_clobber_ref_p): Export.\n+\t* tree-flow.h (is_call_clobbered): Remove.\n+\t* tree-flow-inline.h (is_call_clobbered): Likewise.\n+\t* tree-dfa.c (dump_variable): Do not dump call clobber state.\n+\t* tree-nrv.c (dest_safe_for_nrv_p): Use the alias oracle.\n+\t(execute_return_slot_opt): Adjust.\n+\t* tree-tailcall.c (suitable_for_tail_opt_p): Remove\n+\tcheck for call clobbered vars here.\n+\t(find_tail_calls): Move tailcall verification to the\n+\tproper place.\n+\n 2010-04-16  Diego Novillo  <dnovillo@google.com>\n \n \t* doc/invoke.texi: Explain how are unrecognized -Wno- warnings"}, {"sha": "b58bb508e8812b3f4d5493362169cbbf13a67929", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12de635528ca31f29da55d2c2a86ca726cc59885/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12de635528ca31f29da55d2c2a86ca726cc59885/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=12de635528ca31f29da55d2c2a86ca726cc59885", "patch": "@@ -1,3 +1,8 @@\n+2010-04-16  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/43572\n+\t* gcc.dg/tree-ssa/tailcall-5.c: New testcase.\n+\n 2010-04-16  Olivier Hainque  <hainque@adacore.com>\n \n \t* gnat.dg/specs/discr_private.ads: New test."}, {"sha": "7aa433ecf7a47c04df583d22cef608c021f8e5c2", "filename": "gcc/testsuite/gcc.dg/tree-ssa/tailcall-5.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12de635528ca31f29da55d2c2a86ca726cc59885/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Ftailcall-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12de635528ca31f29da55d2c2a86ca726cc59885/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Ftailcall-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Ftailcall-5.c?ref=12de635528ca31f29da55d2c2a86ca726cc59885", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-tailc\" } */\n+\n+void\n+set_integer (void *dest, int value, int length)\n+{\n+  int tmp = value;\n+  __builtin_memcpy (dest, (void *) &tmp, length);\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"tail call\" \"tailc\" } } */\n+/* { dg-final { cleanup-tree-dump \"tailc\" } } */"}, {"sha": "5475d79254b8aaa4037b6f707aaf4a78f658dddb", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12de635528ca31f29da55d2c2a86ca726cc59885/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12de635528ca31f29da55d2c2a86ca726cc59885/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=12de635528ca31f29da55d2c2a86ca726cc59885", "patch": "@@ -284,9 +284,6 @@ dump_variable (FILE *file, tree var)\n   if (TREE_THIS_VOLATILE (var))\n     fprintf (file, \", is volatile\");\n \n-  if (is_call_clobbered (var))\n-    fprintf (file, \", call clobbered\");\n-\n   if (ann && ann->noalias_state == NO_ALIAS)\n     fprintf (file, \", NO_ALIAS (does not alias other NO_ALIAS symbols)\");\n   else if (ann && ann->noalias_state == NO_ALIAS_GLOBAL)"}, {"sha": "f7609ea7911cc51e7108586bbe3ccb283c4f9610", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12de635528ca31f29da55d2c2a86ca726cc59885/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12de635528ca31f29da55d2c2a86ca726cc59885/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=12de635528ca31f29da55d2c2a86ca726cc59885", "patch": "@@ -624,15 +624,6 @@ loop_containing_stmt (gimple stmt)\n }\n \n \n-/* Return true if VAR is clobbered by function calls.  */\n-static inline bool\n-is_call_clobbered (const_tree var)\n-{\n-  return (is_global_var (var)\n-\t  || (may_be_aliased (var)\n-\t      && pt_solution_includes (&cfun->gimple_df->escaped, var)));\n-}\n-\n /*  -----------------------------------------------------------------------  */\n \n /* The following set of routines are used to iterator over various type of"}, {"sha": "8f9ab5de0f1e7f711ed8f1bfea3f4b92b167c980", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12de635528ca31f29da55d2c2a86ca726cc59885/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12de635528ca31f29da55d2c2a86ca726cc59885/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=12de635528ca31f29da55d2c2a86ca726cc59885", "patch": "@@ -774,7 +774,6 @@ extern enum move_pos movement_possibility (gimple);\n char *get_lsm_tmp_name (tree, unsigned);\n \n /* In tree-flow-inline.h  */\n-static inline bool is_call_clobbered (const_tree);\n static inline void set_is_used (tree);\n static inline bool unmodifiable_var_p (const_tree);\n static inline bool ref_contains_array_ref (const_tree);"}, {"sha": "c2e49d32c170a3aa1dffed1465c518f9c7a251f3", "filename": "gcc/tree-nrv.c", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12de635528ca31f29da55d2c2a86ca726cc59885/gcc%2Ftree-nrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12de635528ca31f29da55d2c2a86ca726cc59885/gcc%2Ftree-nrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nrv.c?ref=12de635528ca31f29da55d2c2a86ca726cc59885", "patch": "@@ -291,23 +291,21 @@ struct gimple_opt_pass pass_nrv =\n    optimization, where DEST is expected to be the LHS of a modify\n    expression where the RHS is a function returning an aggregate.\n \n-   We search for a base VAR_DECL and look to see if it is call clobbered.\n-   Note that we could do better, for example, by\n-   attempting to doing points-to analysis on INDIRECT_REFs.  */\n+   DEST is available if it is not clobbered by the call.  */\n \n static bool\n-dest_safe_for_nrv_p (tree dest)\n+dest_safe_for_nrv_p (gimple call)\n {\n-  while (handled_component_p (dest))\n-    dest = TREE_OPERAND (dest, 0);\n+  tree dest = gimple_call_lhs (call);\n \n-  if (! SSA_VAR_P (dest))\n+  dest = get_base_address (dest);\n+  if (! dest)\n     return false;\n \n   if (TREE_CODE (dest) == SSA_NAME)\n-    dest = SSA_NAME_VAR (dest);\n+    return true;\n \n-  if (is_call_clobbered (dest))\n+  if (call_may_clobber_ref_p (call, dest))\n     return false;\n \n   return true;\n@@ -346,8 +344,8 @@ execute_return_slot_opt (void)\n \t     )\n \t    {\n \t      /* Check if the location being assigned to is\n-\t         call-clobbered.  */\n-\t      slot_opt_p = dest_safe_for_nrv_p (gimple_call_lhs (stmt));\n+\t         clobbered by the call.  */\n+\t      slot_opt_p = dest_safe_for_nrv_p (stmt);\n \t      gimple_call_set_return_slot_opt (stmt, slot_opt_p);\n \t    }\n \t}"}, {"sha": "67c669e8b4b59fe358e9406a7a870a8fc35b8330", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12de635528ca31f29da55d2c2a86ca726cc59885/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12de635528ca31f29da55d2c2a86ca726cc59885/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=12de635528ca31f29da55d2c2a86ca726cc59885", "patch": "@@ -1339,7 +1339,10 @@ call_may_clobber_ref_p_1 (gimple call, ao_ref *ref)\n   return true;\n }\n \n-static bool ATTRIBUTE_UNUSED\n+/* If the call in statement CALL may clobber the memory reference REF\n+   return true, otherwise return false.  */\n+\n+bool\n call_may_clobber_ref_p (gimple call, tree ref)\n {\n   bool res;"}, {"sha": "a2b532747c6dfe70890c7611ea9350cb41524b77", "filename": "gcc/tree-ssa-alias.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12de635528ca31f29da55d2c2a86ca726cc59885/gcc%2Ftree-ssa-alias.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12de635528ca31f29da55d2c2a86ca726cc59885/gcc%2Ftree-ssa-alias.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.h?ref=12de635528ca31f29da55d2c2a86ca726cc59885", "patch": "@@ -104,6 +104,7 @@ extern bool refs_output_dependent_p (tree, tree);\n extern bool ref_maybe_used_by_stmt_p (gimple, tree);\n extern bool stmt_may_clobber_ref_p (gimple, tree);\n extern bool stmt_may_clobber_ref_p_1 (gimple, ao_ref *);\n+extern bool call_may_clobber_ref_p (gimple, tree);\n extern tree get_continuation_for_phi (gimple, ao_ref *, bitmap *);\n extern void *walk_non_aliased_vuses (ao_ref *, tree,\n \t\t\t\t     void *(*)(ao_ref *, tree, void *),"}, {"sha": "ca3dffadc75981a18d707fb36db3c4116facacfd", "filename": "gcc/tree-tailcall.c", "status": "modified", "additions": 11, "deletions": 33, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12de635528ca31f29da55d2c2a86ca726cc59885/gcc%2Ftree-tailcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12de635528ca31f29da55d2c2a86ca726cc59885/gcc%2Ftree-tailcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-tailcall.c?ref=12de635528ca31f29da55d2c2a86ca726cc59885", "patch": "@@ -130,32 +130,9 @@ static void find_tail_calls (basic_block, struct tailcall **);\n static bool\n suitable_for_tail_opt_p (void)\n {\n-  referenced_var_iterator rvi;\n-  tree var;\n-\n   if (cfun->stdarg)\n     return false;\n \n-  /* No local variable nor structure field should escape to callees.  */\n-  FOR_EACH_REFERENCED_VAR (var, rvi)\n-    {\n-      if (!is_global_var (var)\n-\t  /* ???  We do not have a suitable predicate for escaping to\n-\t     callees.  With IPA-PTA the following might be incorrect.\n-\t     We want to catch\n-\t       foo {\n-\t         int i;\n-\t\t bar (&i);\n-\t\t foo ();\n-\t       }\n-\t     where bar might store &i somewhere and in the next\n-\t     recursion should not be able to tell if it got the\n-\t     same (with tail-recursion applied) or a different\n-\t     address.  */\n-\t  && is_call_clobbered (var))\n-\treturn false;\n-    }\n-\n   return true;\n }\n /* Returns false when the function is not suitable for tail call optimization\n@@ -387,6 +364,8 @@ find_tail_calls (basic_block bb, struct tailcall **ret)\n   tree m, a;\n   basic_block abb;\n   size_t idx;\n+  tree var;\n+  referenced_var_iterator rvi;\n \n   if (!single_succ_p (bb))\n     return;\n@@ -442,8 +421,7 @@ find_tail_calls (basic_block bb, struct tailcall **ret)\n   func = gimple_call_fndecl (call);\n   if (func == current_function_decl)\n     {\n-      tree arg, var;\n-      referenced_var_iterator rvi;\n+      tree arg;\n \n       for (param = DECL_ARGUMENTS (func), idx = 0;\n \t   param && idx < gimple_call_num_args (call);\n@@ -474,15 +452,15 @@ find_tail_calls (basic_block bb, struct tailcall **ret)\n \t}\n       if (idx == gimple_call_num_args (call) && !param)\n \ttail_recursion = true;\n+    }\n \n-      /* Make sure the tail invocation of this function does not refer\n-\t to local variables.  */\n-      FOR_EACH_REFERENCED_VAR (var, rvi)\n-\t{\n-\t  if (!is_global_var (var)\n-\t      && ref_maybe_used_by_stmt_p (call, var))\n-\t    return;\n-\t}\n+  /* Make sure the tail invocation of this function does not refer\n+     to local variables.  */\n+  FOR_EACH_REFERENCED_VAR (var, rvi)\n+    {\n+      if (!is_global_var (var)\n+\t  && ref_maybe_used_by_stmt_p (call, var))\n+\treturn;\n     }\n \n   /* Now check the statements after the call.  None of them has virtual"}]}