{"sha": "533effe0f3f49c144df3e1a918f422d2982d21bf", "node_id": "C_kwDOANBUbNoAKDUzM2VmZmUwZjNmNDljMTQ0ZGYzZTFhOTE4ZjQyMmQyOTgyZDIxYmY", "commit": {"author": {"name": "Faisal Abbas", "email": "90.abbasfaisal@gmail.com", "date": "2022-08-12T17:58:04Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-08-25T11:40:27Z"}, "message": "rust constexpr: port over cxx_eval_builtin_function_call().\n\nIt still needs potential_constant_expression_1() which will be continued\nto be ported over.\n\nSigned-off-by: Faisal Abbas <90.abbasfaisal@gmail.com>", "tree": {"sha": "8436531327e642d01ca71a0d69d5720f7ae2204d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8436531327e642d01ca71a0d69d5720f7ae2204d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/533effe0f3f49c144df3e1a918f422d2982d21bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/533effe0f3f49c144df3e1a918f422d2982d21bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/533effe0f3f49c144df3e1a918f422d2982d21bf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/533effe0f3f49c144df3e1a918f422d2982d21bf/comments", "author": {"login": "abbasfaisal", "id": 9428333, "node_id": "MDQ6VXNlcjk0MjgzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/9428333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/abbasfaisal", "html_url": "https://github.com/abbasfaisal", "followers_url": "https://api.github.com/users/abbasfaisal/followers", "following_url": "https://api.github.com/users/abbasfaisal/following{/other_user}", "gists_url": "https://api.github.com/users/abbasfaisal/gists{/gist_id}", "starred_url": "https://api.github.com/users/abbasfaisal/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/abbasfaisal/subscriptions", "organizations_url": "https://api.github.com/users/abbasfaisal/orgs", "repos_url": "https://api.github.com/users/abbasfaisal/repos", "events_url": "https://api.github.com/users/abbasfaisal/events{/privacy}", "received_events_url": "https://api.github.com/users/abbasfaisal/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c2da345e08b313dfd0548064cdb3813a7c86d5a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c2da345e08b313dfd0548064cdb3813a7c86d5a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c2da345e08b313dfd0548064cdb3813a7c86d5a"}], "stats": {"total": 519, "additions": 519, "deletions": 0}, "files": [{"sha": "190abc960702aa5c5222cbc9213efc023d2d0bc4", "filename": "gcc/rust/backend/rust-constexpr.cc", "status": "modified", "additions": 318, "deletions": 0, "changes": 318, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/533effe0f3f49c144df3e1a918f422d2982d21bf/gcc%2Frust%2Fbackend%2Frust-constexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/533effe0f3f49c144df3e1a918f422d2982d21bf/gcc%2Frust%2Fbackend%2Frust-constexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-constexpr.cc?ref=533effe0f3f49c144df3e1a918f422d2982d21bf", "patch": "@@ -1084,6 +1084,7 @@ init_subob_ctx (const constexpr_ctx *ctx, constexpr_ctx &new_ctx, tree index,\n \t/* There's no well-defined subobject for this index.  */\n \tnew_ctx.object = NULL_TREE;\n       else\n+\t// Faisal: commenting this out as not sure if it's needed and it's huge\n \t// new_ctx.object = build_ctor_subob_ref (index, type, ctx->object);\n \t;\n     }\n@@ -2761,6 +2762,217 @@ rs_bind_parameters_in_call (const constexpr_ctx *ctx, tree t, tree fun,\n   return binds;\n }\n \n+// forked from gcc/cp/constexpr.cc cxx_eval_builtin_function_call\n+\n+/* Attempt to evaluate T which represents a call to a builtin function.\n+   We assume here that all builtin functions evaluate to scalar types\n+   represented by _CST nodes.  */\n+\n+static tree\n+eval_builtin_function_call (const constexpr_ctx *ctx, tree t, tree fun,\n+\t\t\t    bool lval, bool *non_constant_p, bool *overflow_p)\n+{\n+  const int nargs = call_expr_nargs (t);\n+  tree *args = (tree *) alloca (nargs * sizeof (tree));\n+  tree new_call;\n+  int i;\n+\n+  /* Don't fold __builtin_constant_p within a constexpr function.  */\n+  bool bi_const_p = DECL_IS_BUILTIN_CONSTANT_P (fun);\n+\n+  /* If we aren't requiring a constant expression, defer __builtin_constant_p\n+     in a constexpr function until we have values for the parameters.  */\n+  if (bi_const_p && !ctx->manifestly_const_eval && current_function_decl\n+      && DECL_DECLARED_CONSTEXPR_P (current_function_decl))\n+    {\n+      *non_constant_p = true;\n+      return t;\n+    }\n+\n+  /* For __builtin_is_constant_evaluated, defer it if not\n+     ctx->manifestly_const_eval (as sometimes we try to constant evaluate\n+     without manifestly_const_eval even expressions or parts thereof which\n+     will later be manifestly const_eval evaluated), otherwise fold it to\n+     true.  */\n+  if (fndecl_built_in_p (fun, CP_BUILT_IN_IS_CONSTANT_EVALUATED,\n+\t\t\t BUILT_IN_FRONTEND))\n+    {\n+      if (!ctx->manifestly_const_eval)\n+\t{\n+\t  *non_constant_p = true;\n+\t  return t;\n+\t}\n+      return boolean_true_node;\n+    }\n+\n+  if (fndecl_built_in_p (fun, CP_BUILT_IN_SOURCE_LOCATION, BUILT_IN_FRONTEND))\n+    {\n+      temp_override<tree> ovr (current_function_decl);\n+      if (ctx->call && ctx->call->fundef)\n+\tcurrent_function_decl = ctx->call->fundef->decl;\n+      return fold_builtin_source_location (EXPR_LOCATION (t));\n+    }\n+\n+  int strops = 0;\n+  int strret = 0;\n+  if (fndecl_built_in_p (fun, BUILT_IN_NORMAL))\n+    switch (DECL_FUNCTION_CODE (fun))\n+      {\n+      case BUILT_IN_STRLEN:\n+      case BUILT_IN_STRNLEN:\n+\tstrops = 1;\n+\tbreak;\n+      case BUILT_IN_MEMCHR:\n+      case BUILT_IN_STRCHR:\n+      case BUILT_IN_STRRCHR:\n+\tstrops = 1;\n+\tstrret = 1;\n+\tbreak;\n+      case BUILT_IN_MEMCMP:\n+      case BUILT_IN_STRCMP:\n+\tstrops = 2;\n+\tbreak;\n+      case BUILT_IN_STRSTR:\n+\tstrops = 2;\n+\tstrret = 1;\n+\tbreak;\n+      case BUILT_IN_ASAN_POINTER_COMPARE:\n+      case BUILT_IN_ASAN_POINTER_SUBTRACT:\n+\t/* These builtins shall be ignored during constant expression\n+\t   evaluation.  */\n+\treturn void_node;\n+      default:\n+\tbreak;\n+      }\n+\n+  /* Be permissive for arguments to built-ins; __builtin_constant_p should\n+     return constant false for a non-constant argument.  */\n+  constexpr_ctx new_ctx = *ctx;\n+  new_ctx.quiet = true;\n+  for (i = 0; i < nargs; ++i)\n+    {\n+      tree arg = CALL_EXPR_ARG (t, i);\n+      tree oarg = arg;\n+\n+      /* To handle string built-ins we need to pass ADDR_EXPR<STRING_CST> since\n+\t expand_builtin doesn't know how to look in the values table.  */\n+      bool strop = i < strops;\n+      if (strop)\n+\t{\n+\t  STRIP_NOPS (arg);\n+\t  if (TREE_CODE (arg) == ADDR_EXPR)\n+\t    arg = TREE_OPERAND (arg, 0);\n+\t  else\n+\t    strop = false;\n+\t}\n+\n+      /* If builtin_valid_in_constant_expr_p is true,\n+\t potential_constant_expression_1 has not recursed into the arguments\n+\t of the builtin, verify it here.  */\n+      if (!builtin_valid_in_constant_expr_p (fun)\n+\t  || potential_constant_expression (arg))\n+\t{\n+\t  bool dummy1 = false, dummy2 = false;\n+\t  arg\n+\t    = eval_constant_expression (&new_ctx, arg, false, &dummy1, &dummy2);\n+\t}\n+\n+      if (bi_const_p)\n+\t/* For __builtin_constant_p, fold all expressions with constant values\n+\t   even if they aren't C++ constant-expressions.  */\n+\targ = cp_fold_rvalue (arg);\n+      else if (strop)\n+\t{\n+\t  if (TREE_CODE (arg) == CONSTRUCTOR)\n+\t    arg = braced_lists_to_strings (TREE_TYPE (arg), arg);\n+\t  if (TREE_CODE (arg) == STRING_CST)\n+\t    arg = build_address (arg);\n+\t  else\n+\t    arg = oarg;\n+\t}\n+\n+      args[i] = arg;\n+    }\n+\n+  bool save_ffbcp = force_folding_builtin_constant_p;\n+  force_folding_builtin_constant_p |= ctx->manifestly_const_eval;\n+  tree save_cur_fn = current_function_decl;\n+  /* Return name of ctx->call->fundef->decl for __builtin_FUNCTION ().  */\n+  if (fndecl_built_in_p (fun, BUILT_IN_FUNCTION) && ctx->call\n+      && ctx->call->fundef)\n+    current_function_decl = ctx->call->fundef->decl;\n+  if (fndecl_built_in_p (fun,\n+\t\t\t CP_BUILT_IN_IS_POINTER_INTERCONVERTIBLE_WITH_CLASS,\n+\t\t\t BUILT_IN_FRONTEND))\n+    {\n+      location_t loc = EXPR_LOCATION (t);\n+      if (nargs >= 1)\n+\tVERIFY_CONSTANT (args[0]);\n+      new_call\n+\t= fold_builtin_is_pointer_inverconvertible_with_class (loc, nargs,\n+\t\t\t\t\t\t\t       args);\n+    }\n+  else if (fndecl_built_in_p (fun, CP_BUILT_IN_IS_CORRESPONDING_MEMBER,\n+\t\t\t      BUILT_IN_FRONTEND))\n+    {\n+      location_t loc = EXPR_LOCATION (t);\n+      if (nargs >= 2)\n+\t{\n+\t  VERIFY_CONSTANT (args[0]);\n+\t  VERIFY_CONSTANT (args[1]);\n+\t}\n+      new_call = fold_builtin_is_corresponding_member (loc, nargs, args);\n+    }\n+  else\n+    new_call = fold_builtin_call_array (EXPR_LOCATION (t), TREE_TYPE (t),\n+\t\t\t\t\tCALL_EXPR_FN (t), nargs, args);\n+  current_function_decl = save_cur_fn;\n+  force_folding_builtin_constant_p = save_ffbcp;\n+  if (new_call == NULL)\n+    {\n+      if (!*non_constant_p && !ctx->quiet)\n+\t{\n+\t  /* Do not allow__builtin_unreachable in constexpr function.\n+\t     The __builtin_unreachable call with BUILTINS_LOCATION\n+\t     comes from cp_maybe_instrument_return.  */\n+\t  if (fndecl_built_in_p (fun, BUILT_IN_UNREACHABLE)\n+\t      && EXPR_LOCATION (t) == BUILTINS_LOCATION)\n+\t    error (\"%<constexpr%> call flows off the end of the function\");\n+\t  else\n+\t    {\n+\t      new_call = build_call_array_loc (EXPR_LOCATION (t), TREE_TYPE (t),\n+\t\t\t\t\t       CALL_EXPR_FN (t), nargs, args);\n+\t      error (\"%q+E is not a constant expression\", new_call);\n+\t    }\n+\t}\n+      *non_constant_p = true;\n+      return t;\n+    }\n+\n+  if (!potential_constant_expression (new_call))\n+    {\n+      if (!*non_constant_p && !ctx->quiet)\n+\terror (\"%q+E is not a constant expression\", new_call);\n+      *non_constant_p = true;\n+      return t;\n+    }\n+\n+  if (strret)\n+    {\n+      /* memchr returns a pointer into the first argument, but we replaced the\n+\t argument above with a STRING_CST; put it back it now.  */\n+      tree op = CALL_EXPR_ARG (t, strret - 1);\n+      STRIP_NOPS (new_call);\n+      if (TREE_CODE (new_call) == POINTER_PLUS_EXPR)\n+\tTREE_OPERAND (new_call, 0) = op;\n+      else if (TREE_CODE (new_call) == ADDR_EXPR)\n+\tnew_call = op;\n+    }\n+\n+  return eval_constant_expression (&new_ctx, new_call, lval, non_constant_p,\n+\t\t\t\t   overflow_p);\n+}\n+\n // Subroutine of cxx_eval_constant_expression.\n // Evaluate the call expression tree T in the context of OLD_CALL expression\n // evaluation.\n@@ -2792,6 +3004,10 @@ eval_call_expression (const constexpr_ctx *ctx, tree t, bool lval,\n       return t;\n     }\n \n+  if (fndecl_built_in_p (fun))\n+    return eval_builtin_function_call (ctx, t, fun, lval, non_constant_p,\n+\t\t\t\t       overflow_p);\n+\n   bool non_constant_args = false;\n   new_call.bindings\n     = rs_bind_parameters_in_call (ctx, t, fun, non_constant_p, overflow_p,\n@@ -4443,6 +4659,20 @@ is_static_init_expression (tree t)\n   // faisal: just return false for now to make it compile\n }\n \n+/* Like potential_constant_expression, but don't consider possible constexpr\n+   substitution of the current function.  That is, PARM_DECL qualifies under\n+   potential_constant_expression, but not here.\n+\n+   This is basically what you can check when any actual constant values might\n+   be value-dependent.  */\n+\n+bool\n+is_constant_expression (tree t)\n+{\n+  // return potential_constant_expression_1 (t, false, true, true, tf_none);\n+  // faisal: just return false for now to make it compile\n+}\n+\n /* Returns true if T is a potential static initializer expression that is not\n    instantiation-dependent.  */\n \n@@ -4497,6 +4727,94 @@ maybe_constant_init (tree t, tree decl, bool manifestly_const_eval)\n   return maybe_constant_init_1 (t, decl, true, manifestly_const_eval);\n }\n \n+/* Returns true if T is a potential constant expression that is not\n+   instantiation-dependent, and therefore a candidate for constant folding even\n+   in a template.  */\n+\n+bool\n+is_nondependent_constant_expression (tree t)\n+{\n+  return (!type_unknown_p (t) && is_constant_expression (t)\n+\t  && !instantiation_dependent_expression_p (t));\n+}\n+\n+// forked from gcc/cp/parser.cc cp_unevaluated_operand\n+\n+/* Nonzero if we are parsing an unevaluated operand: an operand to\n+   sizeof, typeof, or alignof.  */\n+int cp_unevaluated_operand;\n+\n+// forked from gcc/cp/constexpr.cc cv_cache\n+\n+/* If T is a constant expression, returns its reduced value.\n+   Otherwise, if T does not have TREE_CONSTANT set, returns T.\n+   Otherwise, returns a version of T without TREE_CONSTANT.\n+   MANIFESTLY_CONST_EVAL is true if T is manifestly const-evaluated\n+   as per P0595.  */\n+\n+static GTY ((deletable)) hash_map<tree, tree> *cv_cache;\n+\n+// forked from gcc/cp/constexpr.cc maybe_constant_value\n+\n+tree\n+maybe_constant_value (tree t, tree decl, bool manifestly_const_eval)\n+{\n+  tree r;\n+\n+  if (!is_nondependent_constant_expression (t))\n+    {\n+      if (TREE_OVERFLOW_P (t))\n+\t{\n+\t  t = build_nop (TREE_TYPE (t), t);\n+\t  TREE_CONSTANT (t) = false;\n+\t}\n+      return t;\n+    }\n+  else if (CONSTANT_CLASS_P (t))\n+    /* No caching or evaluation needed.  */\n+    return t;\n+\n+  if (manifestly_const_eval)\n+    return cxx_eval_outermost_constant_expr (t, true, true, true, false, decl);\n+\n+  if (cv_cache == NULL)\n+    cv_cache = hash_map<tree, tree>::create_ggc (101);\n+  if (tree *cached = cv_cache->get (t))\n+    {\n+      r = *cached;\n+      if (r != t)\n+\t{\n+\t  // Faisal: commenting this out as not sure if it's needed and it's\n+\t  // huge r = break_out_target_exprs (r, /*clear_loc*/true);\n+\t  protected_set_expr_location (r, EXPR_LOCATION (t));\n+\t}\n+      return r;\n+    }\n+\n+  /* Don't evaluate an unevaluated operand.  */\n+  if (cp_unevaluated_operand)\n+    return t;\n+\n+  uid_sensitive_constexpr_evaluation_checker c;\n+  r = cxx_eval_outermost_constant_expr (t, true, true, false, false, decl);\n+  gcc_checking_assert (\n+    r == t || CONVERT_EXPR_P (t) || TREE_CODE (t) == VIEW_CONVERT_EXPR\n+    || (TREE_CONSTANT (t) && !TREE_CONSTANT (r)) || !rs_tree_equal (r, t));\n+  if (!c.evaluation_restricted_p ())\n+    cv_cache->put (t, r);\n+  return r;\n+}\n+\n+// forked from gcc/cp/constexpr.cc\n+\n+bool\n+potential_constant_expression (tree t)\n+{\n+  // return potential_constant_expression_1 (t, false, true, false, tf_none);\n+  // Faisal: return false until we port above call to make the code compile\n+  return false;\n+}\n+\n // #include \"gt-rust-rust-constexpr.h\"\n \n } // namespace Compile"}, {"sha": "beb4711493d2f8384a1257c94acafe345b9130cb", "filename": "gcc/rust/backend/rust-tree.cc", "status": "modified", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/533effe0f3f49c144df3e1a918f422d2982d21bf/gcc%2Frust%2Fbackend%2Frust-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/533effe0f3f49c144df3e1a918f422d2982d21bf/gcc%2Frust%2Fbackend%2Frust-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-tree.cc?ref=533effe0f3f49c144df3e1a918f422d2982d21bf", "patch": "@@ -5257,6 +5257,8 @@ fold_builtin_is_pointer_inverconvertible_with_class (location_t loc, int nargs,\n \t\t      build_zero_cst (TREE_TYPE (arg)));\n }\n \n+// forked from gcc/c-family/c-common.cc registered_builtin_types\n+\n /* Used for communication between c_common_type_for_mode and\n    c_register_builtin_type.  */\n tree registered_builtin_types;\n@@ -5267,6 +5269,8 @@ tree registered_builtin_types;\n    If the mode is a fixed-point mode,\n    then UNSIGNEDP selects between saturating and nonsaturating types.  */\n \n+// forked from gcc/c-family/c-common.cc c_common_type_for_mode\n+\n tree\n c_common_type_for_mode (machine_mode mode, int unsignedp)\n {\n@@ -5487,6 +5491,8 @@ c_common_type_for_mode (machine_mode mode, int unsignedp)\n   return NULL_TREE;\n }\n \n+// forked from gcc/cp/semantics.cc finish_underlying_type\n+\n /* Implement the __underlying_type keyword: Return the underlying\n    type of TYPE, suitable for use as a type-specifier.  */\n \n@@ -5516,6 +5522,8 @@ finish_underlying_type (tree type)\n   return underlying_type;\n }\n \n+// forked from gcc/cp/typeck.cc layout_compatible_type_p\n+\n /* Return true if TYPE1 and TYPE2 are layout-compatible types.  */\n \n bool\n@@ -5619,6 +5627,8 @@ layout_compatible_type_p (tree type1, tree type2)\n   return same_type_p (type1, type2);\n }\n \n+// forked from gcc/cp/semnatics.cc is_corresponding_member_union\n+\n /* Helper function for is_corresponding_member_aggr.  Return true if\n    MEMBERTYPE pointer-to-data-member ARG can be found in anonymous\n    union or structure BASETYPE.  */\n@@ -5648,6 +5658,8 @@ is_corresponding_member_union (tree basetype, tree membertype, tree arg)\n   return false;\n }\n \n+// forked from gcc/cp/typeck.cc next_common_initial_seqence\n+\n /* Helper function for layout_compatible_type_p and\n    is_corresponding_member_aggr.  Advance to next members (NULL if\n    no further ones) and return true if those members are still part of\n@@ -5713,6 +5725,8 @@ next_common_initial_seqence (tree &memb1, tree &memb2)\n   return true;\n }\n \n+// forked from gcc/cp/semantics.cc is_corresponding_member_aggr\n+\n /* Helper function for fold_builtin_is_corresponding_member call.\n    Return boolean_false_node if MEMBERTYPE1 BASETYPE1::*ARG1 and\n    MEMBERTYPE2 BASETYPE2::*ARG2 aren't corresponding members,\n@@ -5833,6 +5847,8 @@ is_corresponding_member_aggr (location_t loc, tree basetype1, tree membertype1,\n   return ret;\n }\n \n+// forked from gcc/cp/call.cc null_member_pointer_value_p\n+\n /* Returns true iff T is a null member pointer value (4.11).  */\n \n bool\n@@ -5850,6 +5866,8 @@ null_member_pointer_value_p (tree t)\n     return false;\n }\n \n+// forked from gcc/cp/semantics.cc fold_builtin_is_corresponding_member\n+\n /* Fold __builtin_is_corresponding_member call.  */\n \n tree\n@@ -5937,4 +5955,82 @@ fold_builtin_is_corresponding_member (location_t loc, int nargs, tree *args)\n \t\t\t\t   fold_convert (TREE_TYPE (arg1), arg2)));\n }\n \n+// forked from gcc/cp/tree.cc lvalue_type\n+\n+/* The type of ARG when used as an lvalue.  */\n+\n+tree\n+lvalue_type (tree arg)\n+{\n+  tree type = TREE_TYPE (arg);\n+  return type;\n+}\n+\n+// forked from gcc/c-family/c-warn.cc lvalue_error\n+\n+/* Print an error message for an invalid lvalue.  USE says\n+   how the lvalue is being used and so selects the error message.  LOC\n+   is the location for the error.  */\n+\n+void\n+lvalue_error (location_t loc, enum lvalue_use use)\n+{\n+  switch (use)\n+    {\n+    case lv_assign:\n+      error_at (loc, \"lvalue required as left operand of assignment\");\n+      break;\n+    case lv_increment:\n+      error_at (loc, \"lvalue required as increment operand\");\n+      break;\n+    case lv_decrement:\n+      error_at (loc, \"lvalue required as decrement operand\");\n+      break;\n+    case lv_addressof:\n+      error_at (loc, \"lvalue required as unary %<&%> operand\");\n+      break;\n+    case lv_asm:\n+      error_at (loc, \"lvalue required in %<asm%> statement\");\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+// forked from gcc/cp/cp--gimplify.cc cp_fold_maybe_rvalue\n+\n+/* Fold expression X which is used as an rvalue if RVAL is true.  */\n+\n+tree\n+cp_fold_maybe_rvalue (tree x, bool rval)\n+{\n+  while (true)\n+    {\n+      x = fold (x);\n+      if (rval)\n+\tx = mark_rvalue_use (x);\n+      if (rval && DECL_P (x) && !TYPE_REF_P (TREE_TYPE (x)))\n+\t{\n+\t  tree v = decl_constant_value (x);\n+\t  if (v != x && v != error_mark_node)\n+\t    {\n+\t      x = v;\n+\t      continue;\n+\t    }\n+\t}\n+      break;\n+    }\n+  return x;\n+}\n+\n+// forked from gcc/cp/cp--gimplify.cc cp_fold_rvalue\n+\n+/* Fold expression X which is used as an rvalue.  */\n+\n+tree\n+cp_fold_rvalue (tree x)\n+{\n+  return cp_fold_maybe_rvalue (x, true);\n+}\n+\n } // namespace Rust"}, {"sha": "524569a985eda461e616c438ca61e07fa42a66bc", "filename": "gcc/rust/backend/rust-tree.h", "status": "modified", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/533effe0f3f49c144df3e1a918f422d2982d21bf/gcc%2Frust%2Fbackend%2Frust-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/533effe0f3f49c144df3e1a918f422d2982d21bf/gcc%2Frust%2Fbackend%2Frust-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-tree.h?ref=533effe0f3f49c144df3e1a918f422d2982d21bf", "patch": "@@ -1346,6 +1346,26 @@ extern GTY (()) tree cp_global_trees[CPTI_MAX];\n        of the enumeration is completed by finish_enum.  */\n #define ENUM_UNDERLYING_TYPE(TYPE) TREE_TYPE (ENUMERAL_TYPE_CHECK (TYPE))\n \n+/* Nonzero if this type is volatile-qualified.  */\n+#define CP_TYPE_VOLATILE_P(NODE)                                               \\\n+  ((rs_type_quals (NODE) & TYPE_QUAL_VOLATILE) != 0)\n+\n+/* Nonzero means that this type is either complete or being defined, so we\n+   can do lookup in it.  */\n+#define COMPLETE_OR_OPEN_TYPE_P(NODE)                                          \\\n+  (COMPLETE_TYPE_P (NODE) || (CLASS_TYPE_P (NODE) && TYPE_BEING_DEFINED (NODE)))\n+\n+/* Indicates when overload resolution may resolve to a pointer to\n+   member function. [expr.unary.op]/3 */\n+#define PTRMEM_OK_P(NODE)                                                      \\\n+  TREE_LANG_FLAG_0 (TREE_CHECK3 ((NODE), ADDR_EXPR, OFFSET_REF, SCOPE_REF))\n+\n+/* Returns nonzero iff NODE is a declaration for the global function\n+   `main'.  */\n+#define DECL_MAIN_P(NODE)                                                      \\\n+  (DECL_NAME (NODE) != NULL_TREE && MAIN_NAME_P (DECL_NAME (NODE))             \\\n+   && flag_hosted)\n+\n #if defined ENABLE_TREE_CHECKING\n \n #define LANG_DECL_MIN_CHECK(NODE)                                              \\\n@@ -1512,6 +1532,77 @@ extern GTY (()) tree cp_global_trees[CPTI_MAX];\n \n // Above macros are copied from gcc/cp/name-lookup.cc\n \n+/* Places where an lvalue, or modifiable lvalue, may be required.\n+   Used to select diagnostic messages in lvalue_error and\n+   readonly_error.  */\n+enum lvalue_use\n+{\n+  lv_assign,\n+  lv_increment,\n+  lv_decrement,\n+  lv_addressof,\n+  lv_asm\n+};\n+\n+/* A class for recording information about access failures (e.g. private\n+   fields), so that we can potentially supply a fix-it hint about\n+   an accessor (from a context in which the constness of the object\n+   is known).  */\n+\n+class access_failure_info\n+{\n+public:\n+  access_failure_info ()\n+    : m_was_inaccessible (false), m_basetype_path (NULL_TREE),\n+      m_decl (NULL_TREE), m_diag_decl (NULL_TREE)\n+  {}\n+\n+  void record_access_failure (tree basetype_path, tree decl, tree diag_decl);\n+\n+  bool was_inaccessible_p () const { return m_was_inaccessible; }\n+  tree get_decl () const { return m_decl; }\n+  tree get_diag_decl () const { return m_diag_decl; }\n+  tree get_any_accessor (bool const_p) const;\n+  void maybe_suggest_accessor (bool const_p) const;\n+  static void add_fixit_hint (rich_location *richloc, tree accessor);\n+\n+private:\n+  bool m_was_inaccessible;\n+  tree m_basetype_path;\n+  tree m_decl;\n+  tree m_diag_decl;\n+};\n+\n+/* The various kinds of access check during parsing.  */\n+enum deferring_kind\n+{\n+  dk_no_deferred = 0, /* Check access immediately */\n+  dk_deferred = 1,    /* Deferred check */\n+  dk_no_check = 2     /* No access check */\n+};\n+\n+/* The representation of a deferred access check.  */\n+\n+struct GTY (()) deferred_access_check\n+{\n+  /* The base class in which the declaration is referenced. */\n+  tree binfo;\n+  /* The declaration whose access must be checked.  */\n+  tree decl;\n+  /* The declaration that should be used in the error message.  */\n+  tree diag_decl;\n+  /* The location of this access.  */\n+  location_t loc;\n+};\n+\n+struct GTY (()) tree_template_info\n+{\n+  struct tree_base base;\n+  tree tmpl;\n+  tree args;\n+  vec<deferred_access_check, va_gc> *deferred_access_checks;\n+};\n+\n /* The various kinds of lvalues we distinguish.  */\n enum cp_lvalue_kind_flags\n {\n@@ -2819,6 +2910,18 @@ extern bool null_member_pointer_value_p (tree);\n extern tree\n fold_builtin_is_corresponding_member (location_t, int, tree *);\n \n+extern tree cp_fold_rvalue (tree);\n+\n+extern tree\n+maybe_constant_value (tree, tree = NULL_TREE, bool = false);\n+\n+extern tree lvalue_type (tree);\n+\n+extern void lvalue_error (location_t, enum lvalue_use);\n+\n+extern tree\n+cp_fold_maybe_rvalue (tree, bool);\n+\n // forked from gcc/cp/cp-tree.h\n \n enum\n@@ -3043,6 +3146,8 @@ set_implicit_rvalue_p (tree ot)\n namespace Compile {\n extern tree\n maybe_constant_init (tree, tree = NULL_TREE, bool = false);\n+\n+extern bool potential_constant_expression (tree);\n }\n \n } // namespace Rust"}]}