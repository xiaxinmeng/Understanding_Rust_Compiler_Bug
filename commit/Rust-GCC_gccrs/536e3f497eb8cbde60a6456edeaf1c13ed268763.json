{"sha": "536e3f497eb8cbde60a6456edeaf1c13ed268763", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTM2ZTNmNDk3ZWI4Y2JkZTYwYTY0NTZlZGVhZjFjMTNlZDI2ODc2Mw==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2011-07-26T12:00:33Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2011-07-26T12:00:33Z"}, "message": "re PR target/47381 ([x32] internal compiler error: in gen_lowpart_general, at rtlhooks.c:59)\n\n\tPR target/47381\n\tPR target/49832\n\tPR target/49833\n\t* config/i386/i386.md (i): Change SImode attribute to \"e\".\n\t(g): Change SImode attribute to \"rme\".\n\t(di): Change SImode attribute to \"nF\".\n\t(general_operand): Change SImode attribute to x86_64_general_operand.\n\t(general_szext_operand): Change SImode attribute to\n\tx86_64_szext_general_operand.\n\t(immediate_operand): Change SImode attribute to\n\tx86_64_immediate_operand.\n\t(nonmemory_operand): Change SImode attribute to\n\tx86_64_nonmemory_operand.\n\t(*movdi_internal_rex64): Remove mode from pic_32bit_operand check.\n\t(*movsi_internal): Ditto.  Use \"e\" constraint in alternative 2.\n\t(*lea_1): Use SWI48 mode iterator.\n\t(*lea_1_zext): New insn pattern.\n\t(testsi_ccno_1): Use x86_64_nonmemory_operand predicate for operand 2.\n\t(*bt<mode>): Ditto.\n\t(*add<mode>1): Use x86_64_general_operand predicate for operand 2.\n\tUpdate operand constraints.\n\t(addsi_1_zext): Ditto.\n\t(*add<mode>2): Ditto.\n\t(*addsi_3_zext): Ditto.\n\t(*subsi_1_zext): Ditto.\n\t(*subsi_2_zext): Ditto.\n\t(*subsi_3_zext): Ditto.\n\t(*addsi3_carry_zext): Ditto.\n\t(*<plusminus_insn>si3_zext_cc_overflow): Ditto.\n\t(*mulsi3_1_zext): Ditto.\n\t(*andsi_1): Ditto.\n\t(*andsi_1_zext): Ditto.\n\t(*andsi_2_zext): Ditto.\n\t(*<any_or:code>si_1_zext): Ditto.\n\t(*<any_or:code>si_2_zext): Ditto.\n\t(*test<mode>_1): Use <general_operand> predicate for operand 1.\n\t(*and<mode>_2): Ditto.\n\t(mov<mode>cc): Use  <general_operand> predicate for operands 1 and 2.\n\t(add->lea splitter): Check operand modes in insn constraint.  Extend\n\toperands less than SImode wide to SImode.\n\t(add->lea zext splitter): Do not extend input operands to DImode.\n\t(*lea_general_1): Handle only QImode and HImode operands.\n\t(*lea_general_2): Ditto.\n\t(*lea_general_3): Ditto.\n\t(*lea_general_1_zext): Remove.\n\t(*lea_general_2_zext): Ditto.\n\t(*lea_general_3_zext): Ditto.\n\t(*lea_general_4): Check operand modes in insn constraint.  Extend\n\toperands less than SImode wide to SImode.\n\t(ashift->lea splitter): Ditto.\n\t* config/i386/i386.c (ix86_print_operand_address): Print address\n\tregisters with 'q' modifier on 64bit targets.\n\t* config/i386/predicates.md (pic_32bit_opreand): Define as special\n\tpredicate.  Reject non-SI and non-DI modes.\n\nFrom-SVN: r176788", "tree": {"sha": "61cb278b53ee5babc91d745418eda7e15bf2c30e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/61cb278b53ee5babc91d745418eda7e15bf2c30e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/536e3f497eb8cbde60a6456edeaf1c13ed268763", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/536e3f497eb8cbde60a6456edeaf1c13ed268763", "html_url": "https://github.com/Rust-GCC/gccrs/commit/536e3f497eb8cbde60a6456edeaf1c13ed268763", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/536e3f497eb8cbde60a6456edeaf1c13ed268763/comments", "author": null, "committer": null, "parents": [{"sha": "af232d48a7e011bf85d12634644ce80c1ad6480d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af232d48a7e011bf85d12634644ce80c1ad6480d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af232d48a7e011bf85d12634644ce80c1ad6480d"}], "stats": {"total": 418, "additions": 211, "deletions": 207}, "files": [{"sha": "913e2028195b93e83cb5bd950578d5d97bbc9118", "filename": "gcc/ChangeLog", "status": "modified", "additions": 64, "deletions": 9, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/536e3f497eb8cbde60a6456edeaf1c13ed268763/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/536e3f497eb8cbde60a6456edeaf1c13ed268763/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=536e3f497eb8cbde60a6456edeaf1c13ed268763", "patch": "@@ -1,3 +1,61 @@\n+2011-07-26  Uros Bizjak  <ubizjak@gmail.com>\n+\t    H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\tPR target/47381\n+\tPR target/49832\n+\tPR target/49833\n+\t* config/i386/i386.md (i): Change SImode attribute to \"e\".\n+\t(g): Change SImode attribute to \"rme\".\n+\t(di): Change SImode attribute to \"nF\".\n+\t(general_operand): Change SImode attribute to x86_64_general_operand.\n+\t(general_szext_operand): Change SImode attribute to\n+\tx86_64_szext_general_operand.\n+\t(immediate_operand): Change SImode attribute to\n+\tx86_64_immediate_operand.\n+\t(nonmemory_operand): Change SImode attribute to\n+\tx86_64_nonmemory_operand.\n+\t(*movdi_internal_rex64): Remove mode from pic_32bit_operand check.\n+\t(*movsi_internal): Ditto.  Use \"e\" constraint in alternative 2.\n+\t(*lea_1): Use SWI48 mode iterator.\n+\t(*lea_1_zext): New insn pattern.\n+\t(testsi_ccno_1): Use x86_64_nonmemory_operand predicate for operand 2.\n+\t(*bt<mode>): Ditto.\n+\t(*add<mode>1): Use x86_64_general_operand predicate for operand 2.\n+\tUpdate operand constraints.\n+\t(addsi_1_zext): Ditto.\n+\t(*add<mode>2): Ditto.\n+\t(*addsi_3_zext): Ditto.\n+\t(*subsi_1_zext): Ditto.\n+\t(*subsi_2_zext): Ditto.\n+\t(*subsi_3_zext): Ditto.\n+\t(*addsi3_carry_zext): Ditto.\n+\t(*<plusminus_insn>si3_zext_cc_overflow): Ditto.\n+\t(*mulsi3_1_zext): Ditto.\n+\t(*andsi_1): Ditto.\n+\t(*andsi_1_zext): Ditto.\n+\t(*andsi_2_zext): Ditto.\n+\t(*<any_or:code>si_1_zext): Ditto.\n+\t(*<any_or:code>si_2_zext): Ditto.\n+\t(*test<mode>_1): Use <general_operand> predicate for operand 1.\n+\t(*and<mode>_2): Ditto.\n+\t(mov<mode>cc): Use  <general_operand> predicate for operands 1 and 2.\n+\t(add->lea splitter): Check operand modes in insn constraint.  Extend\n+\toperands less than SImode wide to SImode.\n+\t(add->lea zext splitter): Do not extend input operands to DImode.\n+\t(*lea_general_1): Handle only QImode and HImode operands.\n+\t(*lea_general_2): Ditto.\n+\t(*lea_general_3): Ditto.\n+\t(*lea_general_1_zext): Remove.\n+\t(*lea_general_2_zext): Ditto.\n+\t(*lea_general_3_zext): Ditto.\n+\t(*lea_general_4): Check operand modes in insn constraint.  Extend\n+\toperands less than SImode wide to SImode.\n+\t(ashift->lea splitter): Ditto.\n+\t* config/i386/i386.c (ix86_print_operand_address): Print address\n+\tregisters with 'q' modifier on 64bit targets.\n+\t* config/i386/predicates.md (pic_32bit_opreand): Define as special\n+\tpredicate.  Reject non-SI and non-DI modes.\n+\n 2011-07-25  Andrew Pinski  <apinski@cavium.com>\n \n \tPR tree-opt/49671\n@@ -68,13 +126,13 @@\n \t* config/mmix/mmix.c (mmix_print_operand_punct_valid_p): Make static.\n \tChange return type to bool. Change argument type to bool.\n \t(mmix_print_operand, mmix_print_operand_address): Make static.\n-\t(mmix_intval, mmix_output_condition): Change 'x' argument type \n+\t(mmix_intval, mmix_output_condition): Change 'x' argument type\n \tto const_rtx.\n \t(TARGET_PRINT_OPERAND, TARGET_PRINT_OPERAND_ADDRESS,\n \tTARGET_PRINT_OPERAND_PUNCT_VALID_P): Define.\n \n 2011-07-25  Georg-Johann Lay  <avr@gjlay.de>\n-\t\n+\n \tPR target/39386\n \t* config/avr/avr.c (out_shift_with_cnt): Use tmp_reg as\n \tshift counter for x << x and x >> x shifts.\n@@ -294,7 +352,7 @@\n \t(EDGE_ALL_FLAGS, EDGE_COMPLEX): Include it.\n \t* bb-reorder.c: Include except.h.\n \t(fix_up_crossing_landing_pad): New.\n-\t(find_rarely_executed_basic_blocks_and_crossing_edges): Place \n+\t(find_rarely_executed_basic_blocks_and_crossing_edges): Place\n \tlanding pads in the right partition.  Duplicate as necessary.\n \t(partition_hot_cold_basic_blocks): Fix up DF info after\n \tduplicating landing pads.\n@@ -357,8 +415,7 @@\n \t(producer_string): New variable.\n \t(gen_producer_string): New function.\n \t(gen_compile_unit_die): Use it.\n-\t(dwarf2out_finish): Fix up comp_unit_die () DW_AT_producer\n-\tif needed.\n+\t(dwarf2out_finish): Fix up comp_unit_die () DW_AT_producer if needed.\n \t* Makefile.in (dwarf2out.o): Depend on $(OPTS_H).\n \t* doc/invoke.texi: Document -grecord-gcc-switches and\n \t-gno-record-gcc-switches, add a -grecord-gcc-switches reference\n@@ -380,8 +437,7 @@\n \tMS ABI in x32 mode.\n \t(ix86_init_builtins): Call ix86_init_builtins_va_builtins_abi\n \tonly for TARGET_LP64.\n-\t(ix86_handle_abi_attribute): Check TARGET_LP64 instead of\n-\tTARGET_64BIT.\n+\t(ix86_handle_abi_attribute): Check TARGET_LP64 instead of TARGET_64BIT.\n \n 2011-07-22  Michael Meissner  <meissner@linux.vnet.ibm.com>\n \n@@ -392,8 +448,7 @@\n \n \tPR lto/49796\n \t* cgraphunit.c (verify_edge_corresponds_to_fndecl): Return false\n-\tif decl node is in another partition, call cgraph_get_node only\n-\tonce.\n+\tif decl node is in another partition, call cgraph_get_node only once.\n \n 2011-07-22  Uros Bizjak  <ubizjak@gmail.com>\n "}, {"sha": "3668357e290d13a82cf79d6a2ae74c10a7912ac0", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/536e3f497eb8cbde60a6456edeaf1c13ed268763/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/536e3f497eb8cbde60a6456edeaf1c13ed268763/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=536e3f497eb8cbde60a6456edeaf1c13ed268763", "patch": "@@ -14122,6 +14122,9 @@ ix86_print_operand_address (FILE *file, rtx addr)\n     }\n   else\n     {\n+      /* Print DImode registers on 64bit targets to avoid addr32 prefixes.  */\n+      int code = TARGET_64BIT ? 'q' : 0;\n+\n       if (ASSEMBLER_DIALECT == ASM_ATT)\n \t{\n \t  if (disp)\n@@ -14136,11 +14139,11 @@ ix86_print_operand_address (FILE *file, rtx addr)\n \n \t  putc ('(', file);\n \t  if (base)\n-\t    print_reg (base, 0, file);\n+\t    print_reg (base, code, file);\n \t  if (index)\n \t    {\n \t      putc (',', file);\n-\t      print_reg (index, 0, file);\n+\t      print_reg (index, code, file);\n \t      if (scale != 1)\n \t\tfprintf (file, \",%d\", scale);\n \t    }\n@@ -14175,7 +14178,7 @@ ix86_print_operand_address (FILE *file, rtx addr)\n \t  putc ('[', file);\n \t  if (base)\n \t    {\n-\t      print_reg (base, 0, file);\n+\t      print_reg (base, code, file);\n \t      if (offset)\n \t\t{\n \t\t  if (INTVAL (offset) >= 0)\n@@ -14191,7 +14194,7 @@ ix86_print_operand_address (FILE *file, rtx addr)\n \t  if (index)\n \t    {\n \t      putc ('+', file);\n-\t      print_reg (index, 0, file);\n+\t      print_reg (index, code, file);\n \t      if (scale != 1)\n \t\tfprintf (file, \"*%d\", scale);\n \t    }"}, {"sha": "98d60ec8ae1e819dd246cd8b06644b4259935ea7", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 135, "deletions": 193, "changes": 328, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/536e3f497eb8cbde60a6456edeaf1c13ed268763/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/536e3f497eb8cbde60a6456edeaf1c13ed268763/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=536e3f497eb8cbde60a6456edeaf1c13ed268763", "patch": "@@ -861,13 +861,13 @@\n (define_mode_attr r [(QI \"q\") (HI \"r\") (SI \"r\") (DI \"r\")])\n \n ;; Immediate operand constraint for integer modes.\n-(define_mode_attr i [(QI \"n\") (HI \"n\") (SI \"i\") (DI \"e\")])\n+(define_mode_attr i [(QI \"n\") (HI \"n\") (SI \"e\") (DI \"e\")])\n \n ;; General operand constraint for word modes.\n-(define_mode_attr g [(QI \"qmn\") (HI \"rmn\") (SI \"g\") (DI \"rme\")])\n+(define_mode_attr g [(QI \"qmn\") (HI \"rmn\") (SI \"rme\") (DI \"rme\")])\n \n ;; Immediate operand constraint for double integer modes.\n-(define_mode_attr di [(SI \"iF\") (DI \"e\")])\n+(define_mode_attr di [(SI \"nF\") (DI \"e\")])\n \n ;; Immediate operand constraint for shifts.\n (define_mode_attr S [(QI \"I\") (HI \"I\") (SI \"I\") (DI \"J\") (TI \"O\")])\n@@ -876,29 +876,29 @@\n (define_mode_attr general_operand\n \t[(QI \"general_operand\")\n \t (HI \"general_operand\")\n-\t (SI \"general_operand\")\n+\t (SI \"x86_64_general_operand\")\n \t (DI \"x86_64_general_operand\")\n \t (TI \"x86_64_general_operand\")])\n \n ;; General sign/zero extend operand predicate for integer modes.\n (define_mode_attr general_szext_operand\n \t[(QI \"general_operand\")\n \t (HI \"general_operand\")\n-\t (SI \"general_operand\")\n+\t (SI \"x86_64_szext_general_operand\")\n \t (DI \"x86_64_szext_general_operand\")])\n \n ;; Immediate operand predicate for integer modes.\n (define_mode_attr immediate_operand\n \t[(QI \"immediate_operand\")\n \t (HI \"immediate_operand\")\n-\t (SI \"immediate_operand\")\n+\t (SI \"x86_64_immediate_operand\")\n \t (DI \"x86_64_immediate_operand\")])\n \n ;; Nonmemory operand predicate for integer modes.\n (define_mode_attr nonmemory_operand\n \t[(QI \"nonmemory_operand\")\n \t (HI \"nonmemory_operand\")\n-\t (SI \"nonmemory_operand\")\n+\t (SI \"x86_64_nonmemory_operand\")\n \t (DI \"x86_64_nonmemory_operand\")])\n \n ;; Operand predicate for shifts.\n@@ -2039,7 +2039,7 @@\n \t      (const_string \"ssemov\")\n \t    (eq_attr \"alternative\" \"16,17\")\n \t      (const_string \"ssecvt\")\n- \t    (match_operand:DI 1 \"pic_32bit_operand\" \"\")\n+ \t    (match_operand 1 \"pic_32bit_operand\" \"\")\n \t      (const_string \"lea\")\n \t   ]\n \t   (const_string \"imov\")))\n@@ -2184,7 +2184,7 @@\n   [(set (match_operand:SI 0 \"nonimmediate_operand\"\n \t\t\t\"=r,m ,*y,*y,?rm,?*y,*x,*x,?r ,m ,?*Yi,*x\")\n \t(match_operand:SI 1 \"general_operand\"\n-\t\t\t\"g ,ri,C ,*y,*y ,rm ,C ,*x,*Yi,*x,r   ,m \"))]\n+\t\t\t\"g ,re,C ,*y,*y ,rm ,C ,*x,*Yi,*x,r   ,m \"))]\n   \"!(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n {\n   switch (get_attr_type (insn))\n@@ -2232,7 +2232,7 @@\n \t      (const_string \"sselog1\")\n \t    (eq_attr \"alternative\" \"7,8,9,10,11\")\n \t      (const_string \"ssemov\")\n- \t    (match_operand:DI 1 \"pic_32bit_operand\" \"\")\n+ \t    (match_operand 1 \"pic_32bit_operand\" \"\")\n \t      (const_string \"lea\")\n \t   ]\n \t   (const_string \"imov\")))\n@@ -5425,13 +5425,22 @@\n    (set_attr \"mode\" \"QI\")])\n \n (define_insn \"*lea_1\"\n-  [(set (match_operand:P 0 \"register_operand\" \"=r\")\n-\t(match_operand:P 1 \"no_seg_address_operand\" \"p\"))]\n+  [(set (match_operand:SWI48 0 \"register_operand\" \"=r\")\n+\t(match_operand:SWI48 1 \"no_seg_address_operand\" \"p\"))]\n   \"\"\n   \"lea{<imodesuffix>}\\t{%a1, %0|%0, %a1}\"\n   [(set_attr \"type\" \"lea\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n+(define_insn \"*lea_1_zext\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:DI\n+\t  (match_operand:SI 1 \"no_seg_address_operand\" \"p\")))]\n+  \"TARGET_64BIT\"\n+  \"lea{l}\\t{%a1, %k0|%k0, %a1}\"\n+  [(set_attr \"type\" \"lea\")\n+   (set_attr \"mode\" \"SI\")])\n+\n (define_insn \"*lea_2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(subreg:SI (match_operand:DI 1 \"no_seg_address_operand\" \"p\") 0))]\n@@ -5453,7 +5462,7 @@\n   [(set (match_operand:SWI48 0 \"nonimmediate_operand\" \"=r,rm,r,r\")\n \t(plus:SWI48\n \t  (match_operand:SWI48 1 \"nonimmediate_operand\" \"%0,0,r,r\")\n-\t  (match_operand:SWI48 2 \"<general_operand>\" \"<g>,r<i>,0,l<i>\")))\n+\t  (match_operand:SWI48 2 \"x86_64_general_operand\" \"rme,re,0,le\")))\n    (clobber (reg:CC FLAGS_REG))]\n   \"ix86_binary_operator_ok (PLUS, <MODE>mode, operands)\"\n {\n@@ -5512,7 +5521,7 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=r,r,r\")\n \t(zero_extend:DI\n \t  (plus:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0,r,r\")\n-\t\t   (match_operand:SI 2 \"general_operand\" \"g,0,li\"))))\n+\t\t   (match_operand:SI 2 \"x86_64_general_operand\" \"rme,0,le\"))))\n    (clobber (reg:CC FLAGS_REG))]\n   \"TARGET_64BIT && ix86_binary_operator_ok (PLUS, SImode, operands)\"\n {\n@@ -5794,39 +5803,36 @@\n         (const_string \"none\")))\n    (set_attr \"mode\" \"QI\")])\n \n-;; Convert lea to the lea pattern to avoid flags dependency.\n+;; Convert add to the lea pattern to avoid flags dependency.\n (define_split\n   [(set (match_operand 0 \"register_operand\" \"\")\n \t(plus (match_operand 1 \"register_operand\" \"\")\n               (match_operand 2 \"nonmemory_operand\" \"\")))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"reload_completed && ix86_lea_for_add_ok (insn, operands)\" \n+  \"GET_MODE (operands[0]) == GET_MODE (operands[1])\n+   && (GET_MODE (operands[0]) == GET_MODE (operands[2])\n+       || GET_MODE (operands[2]) == VOIDmode)\n+   && reload_completed && ix86_lea_for_add_ok (insn, operands)\" \n   [(const_int 0)]\n {\n-  rtx pat;\n   enum machine_mode mode = GET_MODE (operands[0]);\n-\n-  /* In -fPIC mode the constructs like (const (unspec [symbol_ref]))\n-     may confuse gen_lowpart.  */\n-  if (mode != Pmode)\n-    {\n-      operands[1] = gen_lowpart (Pmode, operands[1]);\n-      operands[2] = gen_lowpart (Pmode, operands[2]);\n-    }\n-\n-  pat = gen_rtx_PLUS (Pmode, operands[1], operands[2]);\n+  rtx pat;\n \n   if (GET_MODE_SIZE (mode) < GET_MODE_SIZE (SImode))\n-    operands[0] = gen_lowpart (SImode, operands[0]);\n+    { \n+      mode = SImode; \n+      operands[0] = gen_lowpart (mode, operands[0]);\n+      operands[1] = gen_lowpart (mode, operands[1]);\n+      operands[2] = gen_lowpart (mode, operands[2]);\n+    }\n \n-  if (TARGET_64BIT && mode != Pmode)\n-    pat = gen_rtx_SUBREG (SImode, pat, 0);\n+  pat = gen_rtx_PLUS (mode, operands[1], operands[2]);\n \n   emit_insn (gen_rtx_SET (VOIDmode, operands[0], pat));\n   DONE;\n })\n \n-;; Convert lea to the lea pattern to avoid flags dependency.\n+;; Convert add to the lea pattern to avoid flags dependency.\n ;; ??? This pattern handles immediate operands that do not satisfy immediate\n ;; operand predicate (TARGET_LEGITIMATE_CONSTANT_P) in the previous pattern.\n (define_split\n@@ -5839,7 +5845,7 @@\n   [(set (match_dup 0)\n \t(plus:DI (match_dup 1) (match_dup 2)))])\n \n-;; Convert lea to the lea pattern to avoid flags dependency.\n+;; Convert add to the lea pattern to avoid flags dependency.\n (define_split\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t(zero_extend:DI\n@@ -5849,11 +5855,7 @@\n   \"TARGET_64BIT && reload_completed\n    && ix86_lea_for_add_ok (insn, operands)\"\n   [(set (match_dup 0)\n-\t(zero_extend:DI (subreg:SI (plus:DI (match_dup 1) (match_dup 2)) 0)))]\n-{\n-  operands[1] = gen_lowpart (DImode, operands[1]);\n-  operands[2] = gen_lowpart (DImode, operands[2]);\n-})\n+\t(zero_extend:DI (plus:SI (match_dup 1) (match_dup 2))))])\n \n (define_insn \"*add<mode>_2\"\n   [(set (reg FLAGS_REG)\n@@ -5901,7 +5903,7 @@\n   [(set (reg FLAGS_REG)\n \t(compare\n \t  (plus:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0\")\n-\t\t   (match_operand:SI 2 \"general_operand\" \"g\"))\n+\t\t   (match_operand:SI 2 \"x86_64_general_operand\" \"rme\"))\n \t  (const_int 0)))\n    (set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(zero_extend:DI (plus:SI (match_dup 1) (match_dup 2))))]\n@@ -5979,7 +5981,7 @@\n (define_insn \"*addsi_3_zext\"\n   [(set (reg FLAGS_REG)\n \t(compare\n-\t  (neg:SI (match_operand:SI 2 \"general_operand\" \"g\"))\n+\t  (neg:SI (match_operand:SI 2 \"x86_64_general_operand\" \"rme\"))\n \t  (match_operand:SI 1 \"nonimmediate_operand\" \"%0\")))\n    (set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(zero_extend:DI (plus:SI (match_dup 1) (match_dup 2))))]\n@@ -6233,16 +6235,15 @@\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"mode\" \"QI\")])\n \n-;; The lea patterns for non-Pmodes needs to be matched by\n+;; The lea patterns for modes less than 32 bits need to be matched by\n ;; several insns converted to real lea by splitters.\n \n (define_insn_and_split \"*lea_general_1\"\n   [(set (match_operand 0 \"register_operand\" \"=r\")\n \t(plus (plus (match_operand 1 \"index_register_operand\" \"l\")\n \t\t    (match_operand 2 \"register_operand\" \"r\"))\n \t      (match_operand 3 \"immediate_operand\" \"i\")))]\n-  \"(GET_MODE (operands[0]) == QImode || GET_MODE (operands[0]) == HImode\n-    || (TARGET_64BIT && GET_MODE (operands[0]) == SImode))\n+  \"(GET_MODE (operands[0]) == QImode || GET_MODE (operands[0]) == HImode)\n    && (!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\n    && GET_MODE (operands[0]) == GET_MODE (operands[1])\n    && GET_MODE (operands[0]) == GET_MODE (operands[2])\n@@ -6252,188 +6253,129 @@\n   \"&& reload_completed\"\n   [(const_int 0)]\n {\n+  enum machine_mode mode = SImode;\n   rtx pat;\n-  operands[0] = gen_lowpart (SImode, operands[0]);\n-  operands[1] = gen_lowpart (Pmode, operands[1]);\n-  operands[2] = gen_lowpart (Pmode, operands[2]);\n-  operands[3] = gen_lowpart (Pmode, operands[3]);\n-  pat = gen_rtx_PLUS (Pmode, gen_rtx_PLUS (Pmode, operands[1], operands[2]),\n+\n+  operands[0] = gen_lowpart (mode, operands[0]);\n+  operands[1] = gen_lowpart (mode, operands[1]);\n+  operands[2] = gen_lowpart (mode, operands[2]);\n+  operands[3] = gen_lowpart (mode, operands[3]);\n+\n+  pat = gen_rtx_PLUS (mode, gen_rtx_PLUS (mode, operands[1], operands[2]),\n   \t\t      operands[3]);\n-  if (Pmode != SImode)\n-    pat = gen_rtx_SUBREG (SImode, pat, 0);\n+\n   emit_insn (gen_rtx_SET (VOIDmode, operands[0], pat));\n   DONE;\n }\n   [(set_attr \"type\" \"lea\")\n    (set_attr \"mode\" \"SI\")])\n \n-(define_insn_and_split \"*lea_general_1_zext\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(zero_extend:DI\n-\t  (plus:SI (plus:SI\n-\t\t     (match_operand:SI 1 \"index_register_operand\" \"l\")\n-\t\t     (match_operand:SI 2 \"register_operand\" \"r\"))\n-\t\t   (match_operand:SI 3 \"immediate_operand\" \"i\"))))]\n-  \"TARGET_64BIT\"\n-  \"#\"\n-  \"&& reload_completed\"\n-  [(set (match_dup 0)\n-\t(zero_extend:DI (subreg:SI (plus:DI (plus:DI (match_dup 1)\n-\t\t\t\t\t\t     (match_dup 2))\n-\t\t\t\t\t    (match_dup 3)) 0)))]\n-{\n-  operands[1] = gen_lowpart (Pmode, operands[1]);\n-  operands[2] = gen_lowpart (Pmode, operands[2]);\n-  operands[3] = gen_lowpart (Pmode, operands[3]);\n-}\n-  [(set_attr \"type\" \"lea\")\n-   (set_attr \"mode\" \"SI\")])\n-\n (define_insn_and_split \"*lea_general_2\"\n   [(set (match_operand 0 \"register_operand\" \"=r\")\n \t(plus (mult (match_operand 1 \"index_register_operand\" \"l\")\n-\t\t    (match_operand 2 \"const248_operand\" \"i\"))\n+\t\t    (match_operand 2 \"const248_operand\" \"n\"))\n \t      (match_operand 3 \"nonmemory_operand\" \"ri\")))]\n-  \"(GET_MODE (operands[0]) == QImode || GET_MODE (operands[0]) == HImode\n-    || (TARGET_64BIT && GET_MODE (operands[0]) == SImode))\n-   && (!TARGET_PARTIAL_REG_STALL\n-       || GET_MODE (operands[0]) == SImode\n-       || optimize_function_for_size_p (cfun))\n+  \"(GET_MODE (operands[0]) == QImode || GET_MODE (operands[0]) == HImode)\n+   && (!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\n    && GET_MODE (operands[0]) == GET_MODE (operands[1])\n    && (GET_MODE (operands[0]) == GET_MODE (operands[3])\n        || GET_MODE (operands[3]) == VOIDmode)\"\n   \"#\"\n   \"&& reload_completed\"\n   [(const_int 0)]\n {\n+  enum machine_mode mode = SImode;\n   rtx pat;\n-  operands[0] = gen_lowpart (SImode, operands[0]);\n-  operands[1] = gen_lowpart (Pmode, operands[1]);\n-  operands[3] = gen_lowpart (Pmode, operands[3]);\n-  pat = gen_rtx_PLUS (Pmode, gen_rtx_MULT (Pmode, operands[1], operands[2]),\n-  \t\t      operands[3]);\n-  if (Pmode != SImode)\n-    pat = gen_rtx_SUBREG (SImode, pat, 0);\n+\n+  operands[0] = gen_lowpart (mode, operands[0]);\n+  operands[1] = gen_lowpart (mode, operands[1]);\n+  operands[3] = gen_lowpart (mode, operands[3]);\n+\n+  pat = gen_rtx_PLUS (mode, gen_rtx_MULT (mode, operands[1], operands[2]),\n+\t\t      operands[3]);\n+\n   emit_insn (gen_rtx_SET (VOIDmode, operands[0], pat));\n   DONE;\n }\n   [(set_attr \"type\" \"lea\")\n    (set_attr \"mode\" \"SI\")])\n \n-(define_insn_and_split \"*lea_general_2_zext\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(zero_extend:DI\n-\t  (plus:SI (mult:SI\n-\t\t     (match_operand:SI 1 \"index_register_operand\" \"l\")\n-\t\t     (match_operand:SI 2 \"const248_operand\" \"n\"))\n-\t\t   (match_operand:SI 3 \"nonmemory_operand\" \"ri\"))))]\n-  \"TARGET_64BIT\"\n-  \"#\"\n-  \"&& reload_completed\"\n-  [(set (match_dup 0)\n-\t(zero_extend:DI (subreg:SI (plus:DI (mult:DI (match_dup 1)\n-\t\t\t\t\t\t     (match_dup 2))\n-\t\t\t\t\t    (match_dup 3)) 0)))]\n-{\n-  operands[1] = gen_lowpart (Pmode, operands[1]);\n-  operands[3] = gen_lowpart (Pmode, operands[3]);\n-}\n-  [(set_attr \"type\" \"lea\")\n-   (set_attr \"mode\" \"SI\")])\n-\n (define_insn_and_split \"*lea_general_3\"\n   [(set (match_operand 0 \"register_operand\" \"=r\")\n \t(plus (plus (mult (match_operand 1 \"index_register_operand\" \"l\")\n-\t\t\t  (match_operand 2 \"const248_operand\" \"i\"))\n+\t\t\t  (match_operand 2 \"const248_operand\" \"n\"))\n \t\t    (match_operand 3 \"register_operand\" \"r\"))\n \t      (match_operand 4 \"immediate_operand\" \"i\")))]\n-  \"(GET_MODE (operands[0]) == QImode || GET_MODE (operands[0]) == HImode\n-    || (TARGET_64BIT && GET_MODE (operands[0]) == SImode))\n-   && (!TARGET_PARTIAL_REG_STALL\n-       || GET_MODE (operands[0]) == SImode\n-       || optimize_function_for_size_p (cfun))\n+  \"(GET_MODE (operands[0]) == QImode || GET_MODE (operands[0]) == HImode)\n+   && (!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\n    && GET_MODE (operands[0]) == GET_MODE (operands[1])\n    && GET_MODE (operands[0]) == GET_MODE (operands[3])\"\n   \"#\"\n   \"&& reload_completed\"\n   [(const_int 0)]\n {\n+  enum machine_mode mode = SImode;\n   rtx pat;\n-  operands[0] = gen_lowpart (SImode, operands[0]);\n-  operands[1] = gen_lowpart (Pmode, operands[1]);\n-  operands[3] = gen_lowpart (Pmode, operands[3]);\n-  operands[4] = gen_lowpart (Pmode, operands[4]);\n-  pat = gen_rtx_PLUS (Pmode,\n-  \t\t      gen_rtx_PLUS (Pmode, gen_rtx_MULT (Pmode, operands[1],\n-\t\t      \t\t\t\t\t operands[2]),\n+\n+  operands[0] = gen_lowpart (mode, operands[0]);\n+  operands[1] = gen_lowpart (mode, operands[1]);\n+  operands[3] = gen_lowpart (mode, operands[3]);\n+  operands[4] = gen_lowpart (mode, operands[4]);\n+\n+  pat = gen_rtx_PLUS (mode,\n+  \t\t      gen_rtx_PLUS (mode,\n+\t\t\t\t    gen_rtx_MULT (mode, operands[1],\n+\t\t      \t\t\t\t\toperands[2]),\n \t\t\t\t    operands[3]),\n   \t\t      operands[4]);\n-  if (Pmode != SImode)\n-    pat = gen_rtx_SUBREG (SImode, pat, 0);\n+\n   emit_insn (gen_rtx_SET (VOIDmode, operands[0], pat));\n   DONE;\n }\n   [(set_attr \"type\" \"lea\")\n    (set_attr \"mode\" \"SI\")])\n \n-(define_insn_and_split \"*lea_general_3_zext\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(zero_extend:DI\n-\t  (plus:SI (plus:SI\n-\t\t     (mult:SI\n-\t\t       (match_operand:SI 1 \"index_register_operand\" \"l\")\n-\t\t       (match_operand:SI 2 \"const248_operand\" \"n\"))\n-\t\t     (match_operand:SI 3 \"register_operand\" \"r\"))\n-\t\t   (match_operand:SI 4 \"immediate_operand\" \"i\"))))]\n-  \"TARGET_64BIT\"\n-  \"#\"\n-  \"&& reload_completed\"\n-  [(set (match_dup 0)\n-\t(zero_extend:DI (subreg:SI (plus:DI (plus:DI (mult:DI (match_dup 1)\n-\t\t\t\t\t\t\t      (match_dup 2))\n-\t\t\t\t\t\t     (match_dup 3))\n-\t\t\t\t\t    (match_dup 4)) 0)))]\n-{\n-  operands[1] = gen_lowpart (Pmode, operands[1]);\n-  operands[3] = gen_lowpart (Pmode, operands[3]);\n-  operands[4] = gen_lowpart (Pmode, operands[4]);\n-}\n-  [(set_attr \"type\" \"lea\")\n-   (set_attr \"mode\" \"SI\")])\n-\n (define_insn_and_split \"*lea_general_4\"\n-  [(set (match_operand:SWI 0 \"register_operand\" \"=r\")\n-\t(any_or:SWI (ashift:SWI (match_operand:SWI 1 \"index_register_operand\" \"l\")\n-\t\t\t\t(match_operand:SWI 2 \"const_int_operand\" \"n\"))\n-\t\t    (match_operand 3 \"const_int_operand\" \"n\")))]\n-  \"(<MODE>mode == DImode\n-    || <MODE>mode == SImode\n-    || !TARGET_PARTIAL_REG_STALL\n-    || optimize_function_for_size_p (cfun))\n+  [(set (match_operand 0 \"register_operand\" \"=r\")\n+\t(any_or (ashift\n+\t\t  (match_operand 1 \"index_register_operand\" \"l\")\n+\t\t  (match_operand 2 \"const_int_operand\" \"n\"))\n+\t\t(match_operand 3 \"const_int_operand\" \"n\")))]\n+  \"(((GET_MODE (operands[0]) == QImode || GET_MODE (operands[0]) == HImode)\n+      && (!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun)))\n+    || GET_MODE (operands[0]) == SImode\n+    || (TARGET_64BIT && GET_MODE (operands[0]) == DImode))\n+   && GET_MODE (operands[0]) == GET_MODE (operands[1])\n    && ((unsigned HOST_WIDE_INT) INTVAL (operands[2])) - 1 < 3\n    && ((unsigned HOST_WIDE_INT) INTVAL (operands[3])\n        < ((unsigned HOST_WIDE_INT) 1 << INTVAL (operands[2])))\"\n   \"#\"\n   \"&& reload_completed\"\n   [(const_int 0)]\n {\n+  enum machine_mode mode = GET_MODE (operands[0]);\n   rtx pat;\n-  if (<MODE>mode != DImode)\n-    operands[0] = gen_lowpart (SImode, operands[0]);\n-  operands[1] = gen_lowpart (Pmode, operands[1]);\n+\n+  if (GET_MODE_SIZE (mode) < GET_MODE_SIZE (SImode))\n+    { \n+      mode = SImode; \n+      operands[0] = gen_lowpart (mode, operands[0]);\n+      operands[1] = gen_lowpart (mode, operands[1]);\n+    }\n+\n   operands[2] = GEN_INT (1 << INTVAL (operands[2]));\n-  pat = plus_constant (gen_rtx_MULT (Pmode, operands[1], operands[2]),\n+\n+  pat = plus_constant (gen_rtx_MULT (mode, operands[1], operands[2]),\n \t\t       INTVAL (operands[3]));\n-  if (Pmode != SImode && <MODE>mode != DImode)\n-    pat = gen_rtx_SUBREG (SImode, pat, 0);\n+\n   emit_insn (gen_rtx_SET (VOIDmode, operands[0], pat));\n   DONE;\n }\n   [(set_attr \"type\" \"lea\")\n    (set (attr \"mode\")\n-      (if_then_else (eq (symbol_ref \"<MODE>mode == DImode\") (const_int 0))\n-\t(const_string \"SI\")\n-\t(const_string \"DI\")))])\n+      (if_then_else (match_operand:DI 0 \"\" \"\")\n+\t(const_string \"DI\")\n+\t(const_string \"SI\")))])\n \f\n ;; Subtract instructions\n \n@@ -6481,7 +6423,7 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(zero_extend:DI\n \t  (minus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-\t\t    (match_operand:SI 2 \"general_operand\" \"g\"))))\n+\t\t    (match_operand:SI 2 \"x86_64_general_operand\" \"rme\"))))\n    (clobber (reg:CC FLAGS_REG))]\n   \"TARGET_64BIT && ix86_binary_operator_ok (MINUS, SImode, operands)\"\n   \"sub{l}\\t{%2, %k0|%k0, %2}\"\n@@ -6518,7 +6460,7 @@\n   [(set (reg FLAGS_REG)\n \t(compare\n \t  (minus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-\t\t    (match_operand:SI 2 \"general_operand\" \"g\"))\n+\t\t    (match_operand:SI 2 \"x86_64_general_operand\" \"rme\"))\n \t  (const_int 0)))\n    (set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(zero_extend:DI\n@@ -6545,7 +6487,7 @@\n (define_insn \"*subsi_3_zext\"\n   [(set (reg FLAGS_REG)\n \t(compare (match_operand:SI 1 \"register_operand\" \"0\")\n-\t\t (match_operand:SI 2 \"general_operand\" \"g\")))\n+\t\t (match_operand:SI 2 \"x86_64_general_operand\" \"rme\")))\n    (set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(zero_extend:DI\n \t  (minus:SI (match_dup 1)\n@@ -6592,7 +6534,7 @@\n \t  (plus:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0\")\n \t\t   (plus:SI (match_operator 3 \"ix86_carry_flag_operator\"\n \t\t\t     [(reg FLAGS_REG) (const_int 0)])\n-\t\t\t    (match_operand:SI 2 \"general_operand\" \"g\")))))\n+\t\t\t    (match_operand:SI 2 \"x86_64_general_operand\" \"rme\")))))\n    (clobber (reg:CC FLAGS_REG))]\n   \"TARGET_64BIT && ix86_binary_operator_ok (PLUS, SImode, operands)\"\n   \"adc{l}\\t{%2, %k0|%k0, %2}\"\n@@ -6607,7 +6549,7 @@\n \t  (minus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n \t\t    (plus:SI (match_operator 3 \"ix86_carry_flag_operator\"\n \t\t\t      [(reg FLAGS_REG) (const_int 0)])\n-\t\t\t     (match_operand:SI 2 \"general_operand\" \"g\")))))\n+\t\t\t     (match_operand:SI 2 \"x86_64_general_operand\" \"rme\")))))\n    (clobber (reg:CC FLAGS_REG))]\n   \"TARGET_64BIT && ix86_binary_operator_ok (MINUS, SImode, operands)\"\n   \"sbb{l}\\t{%2, %k0|%k0, %2}\"\n@@ -6661,7 +6603,7 @@\n \t(compare:CCC\n \t  (plusminus:SI\n \t    (match_operand:SI 1 \"nonimmediate_operand\" \"<comm>0\")\n-\t    (match_operand:SI 2 \"general_operand\" \"g\"))\n+\t    (match_operand:SI 2 \"x86_64_general_operand\" \"rme\"))\n \t  (match_dup 1)))\n    (set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(zero_extend:DI (plusminus:SI (match_dup 1) (match_dup 2))))]\n@@ -6748,7 +6690,7 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=r,r,r\")\n \t(zero_extend:DI\n \t  (mult:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%rm,rm,0\")\n-\t\t   (match_operand:SI 2 \"general_operand\" \"K,i,mr\"))))\n+\t\t   (match_operand:SI 2 \"x86_64_general_operand\" \"K,e,mr\"))))\n    (clobber (reg:CC FLAGS_REG))]\n   \"TARGET_64BIT\n    && !(MEM_P (operands[1]) && MEM_P (operands[2]))\"\n@@ -7374,7 +7316,7 @@\n   [(set (reg:CCNO FLAGS_REG)\n \t(compare:CCNO\n \t  (and:SI (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n-\t\t  (match_operand:SI 1 \"nonmemory_operand\" \"\"))\n+\t\t  (match_operand:SI 1 \"x86_64_nonmemory_operand\" \"\"))\n \t  (const_int 0)))])\n \n (define_expand \"testqi_ccz_1\"\n@@ -7440,7 +7382,7 @@\n \t(compare\n \t (and:SWI124\n \t  (match_operand:SWI124 0 \"nonimmediate_operand\" \"%!*a,<r>,<r>m\")\n-\t  (match_operand:SWI124 1 \"general_operand\" \"<i>,<i>,<r><i>\"))\n+\t  (match_operand:SWI124 1 \"<general_operand>\" \"<i>,<i>,<r><i>\"))\n \t (const_int 0)))]\n   \"ix86_match_ccmode (insn, CCNOmode)\n    && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n@@ -7730,7 +7672,7 @@\n (define_insn \"*andsi_1\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm,r,r\")\n \t(and:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0,0,qm\")\n-\t\t(match_operand:SI 2 \"general_operand\" \"ri,rm,L\")))\n+\t\t(match_operand:SI 2 \"x86_64_general_operand\" \"re,rm,L\")))\n    (clobber (reg:CC FLAGS_REG))]\n   \"ix86_binary_operator_ok (AND, SImode, operands)\"\n {\n@@ -7777,7 +7719,7 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(zero_extend:DI\n \t  (and:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0\")\n-\t\t  (match_operand:SI 2 \"general_operand\" \"g\"))))\n+\t\t  (match_operand:SI 2 \"x86_64_general_operand\" \"rme\"))))\n    (clobber (reg:CC FLAGS_REG))]\n   \"TARGET_64BIT && ix86_binary_operator_ok (AND, SImode, operands)\"\n   \"and{l}\\t{%2, %k0|%k0, %2}\"\n@@ -7925,7 +7867,7 @@\n   [(set (reg FLAGS_REG)\n \t(compare (and:SWI124\n \t\t  (match_operand:SWI124 1 \"nonimmediate_operand\" \"%0,0\")\n-\t\t  (match_operand:SWI124 2 \"general_operand\" \"<g>,<r><i>\"))\n+\t\t  (match_operand:SWI124 2 \"<general_operand>\" \"<g>,<r><i>\"))\n \t\t (const_int 0)))\n    (set (match_operand:SWI124 0 \"nonimmediate_operand\" \"=<r>,<r>m\")\n \t(and:SWI124 (match_dup 1) (match_dup 2)))]\n@@ -7940,7 +7882,7 @@\n   [(set (reg FLAGS_REG)\n \t(compare (and:SI\n \t\t  (match_operand:SI 1 \"nonimmediate_operand\" \"%0\")\n-\t\t  (match_operand:SI 2 \"general_operand\" \"g\"))\n+\t\t  (match_operand:SI 2 \"x86_64_general_operand\" \"rme\"))\n \t\t (const_int 0)))\n    (set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(zero_extend:DI (and:SI (match_dup 1) (match_dup 2))))]\n@@ -8157,7 +8099,7 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(zero_extend:DI\n \t (any_or:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0\")\n-\t\t    (match_operand:SI 2 \"general_operand\" \"g\"))))\n+\t\t    (match_operand:SI 2 \"x86_64_general_operand\" \"rme\"))))\n    (clobber (reg:CC FLAGS_REG))]\n   \"TARGET_64BIT && ix86_binary_operator_ok (<CODE>, SImode, operands)\"\n   \"<logic>{l}\\t{%2, %k0|%k0, %2}\"\n@@ -8205,7 +8147,7 @@\n (define_insn \"*<code>si_2_zext\"\n   [(set (reg FLAGS_REG)\n \t(compare (any_or:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0\")\n-\t\t\t    (match_operand:SI 2 \"general_operand\" \"g\"))\n+\t\t\t    (match_operand:SI 2 \"x86_64_general_operand\" \"rme\"))\n \t\t (const_int 0)))\n    (set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(zero_extend:DI (any_or:SI (match_dup 1) (match_dup 2))))]\n@@ -9395,36 +9337,36 @@\n        (const_string \"*\")))\n    (set_attr \"mode\" \"QI\")])\n \n-;; Convert lea to the lea pattern to avoid flags dependency.\n+;; Convert ashift to the lea pattern to avoid flags dependency.\n (define_split\n   [(set (match_operand 0 \"register_operand\" \"\")\n \t(ashift (match_operand 1 \"index_register_operand\" \"\")\n                 (match_operand:QI 2 \"const_int_operand\" \"\")))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"reload_completed\n+  \"GET_MODE (operands[0]) == GET_MODE (operands[1])\n+   && reload_completed\n    && true_regnum (operands[0]) != true_regnum (operands[1])\"\n   [(const_int 0)]\n {\n-  rtx pat;\n   enum machine_mode mode = GET_MODE (operands[0]);\n-\n-  if (mode != Pmode)\n-    operands[1] = gen_lowpart (Pmode, operands[1]);\n-  operands[2] = gen_int_mode (1 << INTVAL (operands[2]), Pmode);\n-\n-  pat = gen_rtx_MULT (Pmode, operands[1], operands[2]);\n+  rtx pat;\n \n   if (GET_MODE_SIZE (mode) < GET_MODE_SIZE (SImode))\n-    operands[0] = gen_lowpart (SImode, operands[0]);\n+    { \n+      mode = SImode; \n+      operands[0] = gen_lowpart (mode, operands[0]);\n+      operands[1] = gen_lowpart (mode, operands[1]);\n+    }\n+\n+  operands[2] = gen_int_mode (1 << INTVAL (operands[2]), mode);\n \n-  if (TARGET_64BIT && mode != Pmode)\n-    pat = gen_rtx_SUBREG (SImode, pat, 0);\n+  pat = gen_rtx_MULT (mode, operands[1], operands[2]);\n \n   emit_insn (gen_rtx_SET (VOIDmode, operands[0], pat));\n   DONE;\n })\n \n-;; Convert lea to the lea pattern to avoid flags dependency.\n+;; Convert ashift to the lea pattern to avoid flags dependency.\n (define_split\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t(zero_extend:DI\n@@ -10364,7 +10306,7 @@\n \t  (zero_extract:SWI48\n \t    (match_operand:SWI48 0 \"register_operand\" \"r\")\n \t    (const_int 1)\n-\t    (match_operand:SWI48 1 \"nonmemory_operand\" \"rN\"))\n+\t    (match_operand:SWI48 1 \"x86_64_nonmemory_operand\" \"rN\"))\n \t  (const_int 0)))]\n   \"TARGET_USE_BT || optimize_function_for_size_p (cfun)\"\n   \"bt{<imodesuffix>}\\t{%1, %0|%0, %1}\"\n@@ -16021,8 +15963,8 @@\n (define_expand \"mov<mode>cc\"\n   [(set (match_operand:SWIM 0 \"register_operand\" \"\")\n \t(if_then_else:SWIM (match_operand 1 \"ordered_comparison_operator\" \"\")\n-\t\t\t   (match_operand:SWIM 2 \"general_operand\" \"\")\n-\t\t\t   (match_operand:SWIM 3 \"general_operand\" \"\")))]\n+\t\t\t   (match_operand:SWIM 2 \"<general_operand>\" \"\")\n+\t\t\t   (match_operand:SWIM 3 \"<general_operand>\" \"\")))]\n   \"\"\n   \"if (ix86_expand_int_movcc (operands)) DONE; else FAIL;\")\n "}, {"sha": "051551999c18d20c3c268c666f846503698e5f01", "filename": "gcc/config/i386/predicates.md", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/536e3f497eb8cbde60a6456edeaf1c13ed268763/gcc%2Fconfig%2Fi386%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/536e3f497eb8cbde60a6456edeaf1c13ed268763/gcc%2Fconfig%2Fi386%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpredicates.md?ref=536e3f497eb8cbde60a6456edeaf1c13ed268763", "patch": "@@ -366,9 +366,13 @@\n \n ;; Return true when operand is PIC expression that can be computed by lea\n ;; operation.\n-(define_predicate \"pic_32bit_operand\"\n+(define_special_predicate \"pic_32bit_operand\"\n   (match_code \"const,symbol_ref,label_ref\")\n {\n+  if (GET_MODE (op) != SImode\n+      && GET_MODE (op) != DImode)\n+    return false;\n+\n   if (!flag_pic)\n     return false;\n   /* Rule out relocations that translate into 64bit constants.  */"}]}