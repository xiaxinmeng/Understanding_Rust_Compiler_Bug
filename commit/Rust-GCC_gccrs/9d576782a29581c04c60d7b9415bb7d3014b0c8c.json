{"sha": "9d576782a29581c04c60d7b9415bb7d3014b0c8c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWQ1NzY3ODJhMjk1ODFjMDRjNjBkN2I5NDE1YmI3ZDMwMTRiMGM4Yw==", "commit": {"author": {"name": "Tom de Vries", "email": "tdevries@suse.de", "date": "2019-01-17T13:42:09Z"}, "committer": {"name": "Tom de Vries", "email": "vries@gcc.gnu.org", "date": "2019-01-17T13:42:09Z"}, "message": "[libbacktrace] Add find_unit\n\nAdd a function that finds the unit given an offset into .debug_info.\n\n2019-01-17  Tom de Vries  <tdevries@suse.de>\n\n\t* dwarf.c (struct unit): Add low_offset and high_offset fields.\n\t(struct unit_vector): New type.\n\t(struct dwarf_data): Add units and units_counts fields.\n\t(find_unit): New function.\n\t(find_address_ranges): Add and handle unit_tag parameter.\n\t(build_address_map): Add and handle units_vec parameter.\n\t(build_dwarf_data): Pass units_vec to build_address_map.  Store resulting\n\tunits vector.\n\nFrom-SVN: r268030", "tree": {"sha": "ca71db3ecf4f1bac690f2a4126b030a5a06658ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ca71db3ecf4f1bac690f2a4126b030a5a06658ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9d576782a29581c04c60d7b9415bb7d3014b0c8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d576782a29581c04c60d7b9415bb7d3014b0c8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d576782a29581c04c60d7b9415bb7d3014b0c8c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d576782a29581c04c60d7b9415bb7d3014b0c8c/comments", "author": {"login": "vries", "id": 4057235, "node_id": "MDQ6VXNlcjQwNTcyMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4057235?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vries", "html_url": "https://github.com/vries", "followers_url": "https://api.github.com/users/vries/followers", "following_url": "https://api.github.com/users/vries/following{/other_user}", "gists_url": "https://api.github.com/users/vries/gists{/gist_id}", "starred_url": "https://api.github.com/users/vries/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vries/subscriptions", "organizations_url": "https://api.github.com/users/vries/orgs", "repos_url": "https://api.github.com/users/vries/repos", "events_url": "https://api.github.com/users/vries/events{/privacy}", "received_events_url": "https://api.github.com/users/vries/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "674931d2b7bd8886d142f31ea3d07a2ab2eb608a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/674931d2b7bd8886d142f31ea3d07a2ab2eb608a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/674931d2b7bd8886d142f31ea3d07a2ab2eb608a"}], "stats": {"total": 98, "additions": 87, "deletions": 11}, "files": [{"sha": "1fd307bf5128100e655dbfa155113483d8e7cfc5", "filename": "libbacktrace/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d576782a29581c04c60d7b9415bb7d3014b0c8c/libbacktrace%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d576782a29581c04c60d7b9415bb7d3014b0c8c/libbacktrace%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2FChangeLog?ref=9d576782a29581c04c60d7b9415bb7d3014b0c8c", "patch": "@@ -1,3 +1,14 @@\n+2019-01-17  Tom de Vries  <tdevries@suse.de>\n+\n+\t* dwarf.c (struct unit): Add low_offset and high_offset fields.\n+\t(struct unit_vector): New type.\n+\t(struct dwarf_data): Add units and units_counts fields.\n+\t(find_unit): New function.\n+\t(find_address_ranges): Add and handle unit_tag parameter.\n+\t(build_address_map): Add and handle units_vec parameter.\n+\t(build_dwarf_data): Pass units_vec to build_address_map.  Store resulting\n+\tunits vector.\n+\n 2019-01-17  Tom de Vries  <tdevries@suse.de>\n \n \tPR libbacktrace/82857"}, {"sha": "6f56c46774b7ef3920eec89258cfbf4fe4bc56be", "filename": "libbacktrace/dwarf.c", "status": "modified", "additions": 76, "deletions": 11, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d576782a29581c04c60d7b9415bb7d3014b0c8c/libbacktrace%2Fdwarf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d576782a29581c04c60d7b9415bb7d3014b0c8c/libbacktrace%2Fdwarf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fdwarf.c?ref=9d576782a29581c04c60d7b9415bb7d3014b0c8c", "patch": "@@ -281,6 +281,12 @@ struct unit\n   /* The offset of UNIT_DATA from the start of the information for\n      this compilation unit.  */\n   size_t unit_data_offset;\n+  /* Offset of the start of the compilation unit from the start of the\n+     .debug_info section.  */\n+  off_t low_offset;\n+  /* Offset of the end of the compilation unit from the start of the\n+     .debug_info section.  */\n+  off_t high_offset;\n   /* DWARF version.  */\n   int version;\n   /* Whether unit is DWARF64.  */\n@@ -339,6 +345,14 @@ struct unit_addrs_vector\n   size_t count;\n };\n \n+/* A growable vector of compilation unit pointer.  */\n+\n+struct unit_vector\n+{\n+  struct backtrace_vector vec;\n+  size_t count;\n+};\n+\n /* The information we need to map a PC to a file and line.  */\n \n struct dwarf_data\n@@ -353,6 +367,10 @@ struct dwarf_data\n   struct unit_addrs *addrs;\n   /* Number of address ranges in list.  */\n   size_t addrs_count;\n+  /* A sorted list of units.  */\n+  struct unit **units;\n+  /* Number of units in the list.  */\n+  size_t units_count;\n   /* The unparsed .debug_info section.  */\n   const unsigned char *dwarf_info;\n   size_t dwarf_info_size;\n@@ -866,6 +884,34 @@ read_attribute (enum dwarf_form form, struct dwarf_buf *buf,\n     }\n }\n \n+/* Compare a unit offset against a unit for bsearch.  */\n+\n+static int\n+units_search (const void *vkey, const void *ventry)\n+{\n+  const off_t *key = (const off_t *) vkey;\n+  const struct unit *entry = *((const struct unit *const *) ventry);\n+  off_t offset;\n+\n+  offset = *key;\n+  if (offset < entry->low_offset)\n+    return -1;\n+  else if (offset >= entry->high_offset)\n+    return 1;\n+  else\n+    return 0;\n+}\n+\n+/* Find a unit in PU containing OFFSET.  */\n+\n+static struct unit *\n+find_unit (struct unit **pu, size_t units_count, off_t offset)\n+{\n+  struct unit **u;\n+  u = bsearch (&offset, pu, units_count, sizeof (struct unit *), units_search);\n+  return u == NULL ? NULL : *u;\n+}\n+\n /* Compare function_addrs for qsort.  When ranges are nested, make the\n    smallest one sort last.  */\n \n@@ -1298,7 +1344,8 @@ find_address_ranges (struct backtrace_state *state, uintptr_t base_address,\n \t\t     size_t dwarf_ranges_size,\n \t\t     int is_bigendian, struct dwarf_data *altlink,\n \t\t     backtrace_error_callback error_callback, void *data,\n-\t\t     struct unit *u, struct unit_addrs_vector *addrs)\n+\t\t     struct unit *u, struct unit_addrs_vector *addrs,\n+\t\t     enum dwarf_tag *unit_tag)\n {\n   while (unit_buf->left > 0)\n     {\n@@ -1321,6 +1368,9 @@ find_address_ranges (struct backtrace_state *state, uintptr_t base_address,\n       if (abbrev == NULL)\n \treturn 0;\n \n+      if (unit_tag != NULL)\n+\t*unit_tag = abbrev->tag;\n+\n       lowpc = 0;\n       have_lowpc = 0;\n       highpc = 0;\n@@ -1433,7 +1483,7 @@ find_address_ranges (struct backtrace_state *state, uintptr_t base_address,\n \t\t\t\t    dwarf_str, dwarf_str_size,\n \t\t\t\t    dwarf_ranges, dwarf_ranges_size,\n \t\t\t\t    is_bigendian, altlink, error_callback, data,\n-\t\t\t\t    u, addrs))\n+\t\t\t\t    u, addrs, NULL))\n \t    return 0;\n \t}\n     }\n@@ -1453,17 +1503,21 @@ build_address_map (struct backtrace_state *state, uintptr_t base_address,\n \t\t   const unsigned char *dwarf_str, size_t dwarf_str_size,\n \t\t   int is_bigendian, struct dwarf_data *altlink,\n \t\t   backtrace_error_callback error_callback, void *data,\n-\t\t   struct unit_addrs_vector *addrs)\n+\t\t   struct unit_addrs_vector *addrs,\n+\t\t   struct unit_vector *unit_vec)\n {\n   struct dwarf_buf info;\n   struct backtrace_vector units;\n   size_t units_count;\n   size_t i;\n   struct unit **pu;\n   size_t prev_addrs_count;\n+  off_t unit_offset = 0;\n \n   memset (&addrs->vec, 0, sizeof addrs->vec);\n+  memset (&unit_vec->vec, 0, sizeof unit_vec->vec);\n   addrs->count = 0;\n+  unit_vec->count = 0;\n   prev_addrs_count = 0;\n \n   /* Read through the .debug_info section.  FIXME: Should we use the\n@@ -1492,6 +1546,7 @@ build_address_map (struct backtrace_state *state, uintptr_t base_address,\n       uint64_t abbrev_offset;\n       int addrsize;\n       struct unit *u;\n+      enum dwarf_tag unit_tag;\n \n       if (info.reported_underflow)\n \tgoto fail;\n@@ -1534,6 +1589,9 @@ build_address_map (struct backtrace_state *state, uintptr_t base_address,\n \n       addrsize = read_byte (&unit_buf);\n \n+      u->low_offset = unit_offset;\n+      unit_offset += len + (is_dwarf64 ? 12 : 4);\n+      u->high_offset = unit_offset;\n       u->unit_data = unit_buf.buf;\n       u->unit_data_len = unit_buf.left;\n       u->unit_data_offset = unit_buf.buf - unit_data_start;\n@@ -1555,13 +1613,13 @@ build_address_map (struct backtrace_state *state, uintptr_t base_address,\n \t\t\t\tdwarf_str, dwarf_str_size,\n \t\t\t\tdwarf_ranges, dwarf_ranges_size,\n \t\t\t\tis_bigendian, altlink, error_callback, data,\n-\t\t\t\tu, addrs))\n+\t\t\t\tu, addrs, &unit_tag))\n \tgoto fail;\n \n       if (unit_buf.reported_underflow)\n \tgoto fail;\n \n-      if (addrs->count > prev_addrs_count)\n+      if (addrs->count > prev_addrs_count || unit_tag == DW_TAG_partial_unit)\n \tprev_addrs_count = addrs->count;\n       else\n \t{\n@@ -1576,11 +1634,8 @@ build_address_map (struct backtrace_state *state, uintptr_t base_address,\n   if (info.reported_underflow)\n     goto fail;\n \n-  // We only kept the list of units to free them on failure.  On\n-  // success the units are retained, pointed to by the entries in\n-  // addrs.\n-  backtrace_vector_free (state, &units, error_callback, data);\n-\n+  unit_vec->vec = units;\n+  unit_vec->count = units_count;\n   return 1;\n \n  fail:\n@@ -3031,21 +3086,29 @@ build_dwarf_data (struct backtrace_state *state,\n   struct unit_addrs_vector addrs_vec;\n   struct unit_addrs *addrs;\n   size_t addrs_count;\n+  struct unit_vector units_vec;\n+  struct unit **units;\n+  size_t units_count;\n   struct dwarf_data *fdata;\n \n   if (!build_address_map (state, base_address, dwarf_info, dwarf_info_size,\n \t\t\t  dwarf_abbrev, dwarf_abbrev_size, dwarf_ranges,\n \t\t\t  dwarf_ranges_size, dwarf_str, dwarf_str_size,\n \t\t\t  is_bigendian, altlink, error_callback, data,\n-\t\t\t  &addrs_vec))\n+\t\t\t  &addrs_vec, &units_vec))\n     return NULL;\n \n   if (!backtrace_vector_release (state, &addrs_vec.vec, error_callback, data))\n     return NULL;\n+  if (!backtrace_vector_release (state, &units_vec.vec, error_callback, data))\n+    return NULL;\n   addrs = (struct unit_addrs *) addrs_vec.vec.base;\n+  units = (struct unit **) units_vec.vec.base;\n   addrs_count = addrs_vec.count;\n+  units_count = units_vec.count;\n   backtrace_qsort (addrs, addrs_count, sizeof (struct unit_addrs),\n \t\t   unit_addrs_compare);\n+  /* No qsort for units required, already sorted.  */\n \n   fdata = ((struct dwarf_data *)\n \t   backtrace_alloc (state, sizeof (struct dwarf_data),\n@@ -3058,6 +3121,8 @@ build_dwarf_data (struct backtrace_state *state,\n   fdata->base_address = base_address;\n   fdata->addrs = addrs;\n   fdata->addrs_count = addrs_count;\n+  fdata->units = units;\n+  fdata->units_count = units_count;\n   fdata->dwarf_info = dwarf_info;\n   fdata->dwarf_info_size = dwarf_info_size;\n   fdata->dwarf_line = dwarf_line;"}]}