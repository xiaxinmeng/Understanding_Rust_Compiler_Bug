{"sha": "1f6d3a0807da9185a1e160cfbeca42e42d97ac80", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWY2ZDNhMDgwN2RhOTE4NWExZTE2MGNmYmVjYTQyZTQyZDk3YWM4MA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-09-03T23:50:11Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-09-03T23:50:11Z"}, "message": "re PR middle-end/9997 (Coelesce stack slots for disjoint scopes.)\n\n        PR middle-end/9997\n        * cfgexpand.c (LOCAL_ALIGNMENT): Provide default.\n        (STACK_ALIGNMENT_NEEDED, FRAME_GROWS_DOWNWARD): Likewise.\n\t(struct stack_var, EOC, stack_vars, stack_vars_alloc, stack_vars_num,\n        stack_vars_sorted, stack_vars_conflict, stack_vars_conflict_alloc,\n        frame_phase, get_decl_align_unit, add_stack_var, triangular_index,\n        resize_stack_vars_conflict, add_stack_var_conflict,\n        stack_var_conflict_p, add_alias_set_conflicts, stack_var_size_cmp,\n        union_stack_vars, partition_stack_vars, dump_stack_var_partition,\n        expand_one_stack_var_at, expand_stack_vars, expand_one_stack_var,\n        expand_one_static_var, expand_one_hard_reg_var,\n        expand_one_register_var, expand_one_error_var, defer_stack_allocation,\n        expand_one_var, expand_used_vars_for_block, clear_tree_used): New.\n        (expand_used_vars): Rewrite.\n        * Makefile.in (cfgexpand.o): Update dependencies.\n\nFrom-SVN: r87064", "tree": {"sha": "9f144a6d80f8fc52b8b90ea3d2e81119a0a3b289", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9f144a6d80f8fc52b8b90ea3d2e81119a0a3b289"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1f6d3a0807da9185a1e160cfbeca42e42d97ac80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f6d3a0807da9185a1e160cfbeca42e42d97ac80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f6d3a0807da9185a1e160cfbeca42e42d97ac80", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f6d3a0807da9185a1e160cfbeca42e42d97ac80/comments", "author": null, "committer": null, "parents": [{"sha": "6983ea08a2e1b301f6f373eb49033e5d12475583", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6983ea08a2e1b301f6f373eb49033e5d12475583", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6983ea08a2e1b301f6f373eb49033e5d12475583"}], "stats": {"total": 774, "additions": 767, "deletions": 7}, "files": [{"sha": "7b541708dff7c63d2d0dd1ade2447c9ea21be2eb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f6d3a0807da9185a1e160cfbeca42e42d97ac80/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f6d3a0807da9185a1e160cfbeca42e42d97ac80/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1f6d3a0807da9185a1e160cfbeca42e42d97ac80", "patch": "@@ -1,3 +1,21 @@\n+2004-09-03  Richard Henderson  <rth@redhat.com>\n+\n+        PR middle-end/9997\n+        * cfgexpand.c (LOCAL_ALIGNMENT): Provide default.\n+        (STACK_ALIGNMENT_NEEDED, FRAME_GROWS_DOWNWARD): Likewise.\n+        (struct stack_var, EOC, stack_vars, stack_vars_alloc, stack_vars_num,\n+        stack_vars_sorted, stack_vars_conflict, stack_vars_conflict_alloc,\n+        frame_phase, get_decl_align_unit, add_stack_var, triangular_index,\n+        resize_stack_vars_conflict, add_stack_var_conflict,\n+        stack_var_conflict_p, add_alias_set_conflicts, stack_var_size_cmp,\n+        union_stack_vars, partition_stack_vars, dump_stack_var_partition,\n+        expand_one_stack_var_at, expand_stack_vars, expand_one_stack_var,\n+\texpand_one_static_var, expand_one_hard_reg_var,\n+\texpand_one_register_var, expand_one_error_var, defer_stack_allocation,\n+\texpand_one_var, expand_used_vars_for_block, clear_tree_used): New.\n+        (expand_used_vars): Rewrite.\n+\t* Makefile.in (cfgexpand.o): Update dependencies.\n+\n 2004-09-04  Jan Hubicka  <jh@suse.cz>\n \n \t* cfg.c (free_edge): Use ggc_free."}, {"sha": "3654ff09c8d5d42f218e9ca83a4ef8b0fe724f4f", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f6d3a0807da9185a1e160cfbeca42e42d97ac80/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f6d3a0807da9185a1e160cfbeca42e42d97ac80/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=1f6d3a0807da9185a1e160cfbeca42e42d97ac80", "patch": "@@ -1984,8 +1984,9 @@ cfg.o : cfg.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(FLAGS_H) in\n cfghooks.o: cfghooks.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \\\n    $(BASIC_BLOCK_H) $(CFGLAYOUT_H) $(TREE_FLOW_H) $(TIMEVAR_H) toplev.h\n cfgexpand.o : cfgexpand.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n-   $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) function.h $(TIMEVAR_H) $(TM_H) coretypes.h \\\n-   $(TREE_DUMP_H) except.h langhooks.h cfgloop.h gt-tree-cfg.h tree-pass.h $(RTL_H)\n+   $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) function.h $(TIMEVAR_H) $(TM_H) \\\n+   coretypes.h $(TREE_DUMP_H) except.h langhooks.h cfgloop.h tree-pass.h \\\n+   $(RTL_H) $(DIAGNOSTIC_H) toplev.h gt-tree-cfg.h\n cfgrtl.o : cfgrtl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(FLAGS_H) \\\n    insn-config.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h output.h toplev.h $(RECOG_H) \\\n    function.h except.h $(GGC_H) $(TM_P_H) insn-config.h $(EXPR_H)"}, {"sha": "68fd109e718c379074f11ba042dd66625becd592", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 746, "deletions": 5, "changes": 751, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f6d3a0807da9185a1e160cfbeca42e42d97ac80/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f6d3a0807da9185a1e160cfbeca42e42d97ac80/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=1f6d3a0807da9185a1e160cfbeca42e42d97ac80", "patch": "@@ -35,21 +35,762 @@ Boston, MA 02111-1307, USA.  */\n #include \"tree-pass.h\"\n #include \"except.h\"\n #include \"flags.h\"\n+#include \"diagnostic.h\"\n+#include \"toplev.h\"\n \n \n-/* Expand variables in the unexpanded_var_list.  */\n+#ifndef LOCAL_ALIGNMENT\n+#define LOCAL_ALIGNMENT(TYPE, ALIGNMENT) ALIGNMENT\n+#endif\n+\n+#ifndef STACK_ALIGNMENT_NEEDED\n+#define STACK_ALIGNMENT_NEEDED 1\n+#endif\n+\n+#ifdef FRAME_GROWS_DOWNWARD\n+# undef FRAME_GROWS_DOWNWARD\n+# define FRAME_GROWS_DOWNWARD 1\n+#else\n+# define FRAME_GROWS_DOWNWARD 0\n+#endif\n+\n+\n+/* This structure holds data relevant to one variable that will be\n+   placed in a stack slot.  */\n+struct stack_var\n+{\n+  /* The Variable.  */\n+  tree decl;\n+\n+  /* The offset of the variable.  During partitioning, this is the\n+     offset relative to the partition.  After partitioning, this\n+     is relative to the stack frame.  */\n+  HOST_WIDE_INT offset;\n+\n+  /* Initially, the size of the variable.  Later, the size of the partition,\n+     if this variable becomes it's partition's representative.  */\n+  HOST_WIDE_INT size;\n+\n+  /* The *byte* alignment required for this variable.  Or as, with the\n+     size, the alignment for this partition.  */\n+  unsigned int alignb;\n+\n+  /* The partition representative.  */\n+  size_t representative;\n+\n+  /* The next stack variable in the partition, or EOC.  */\n+  size_t next;\n+};\n+\n+#define EOC  ((size_t)-1)\n+\n+/* We have an array of such objects while deciding allocation.  */\n+static struct stack_var *stack_vars;\n+static size_t stack_vars_alloc;\n+static size_t stack_vars_num;\n+\n+/* An array of indicies such that stack_vars[stack_vars_sorted[i]].size\n+   is non-decreasing.  */\n+static size_t *stack_vars_sorted;\n+\n+/* We have an interference graph between such objects.  This graph\n+   is lower triangular.  */\n+static bool *stack_vars_conflict;\n+static size_t stack_vars_conflict_alloc;\n+\n+/* The phase of the stack frame.  This is the known misalignment of\n+   virtual_stack_vars_rtx from PREFERRED_STACK_BOUNDARY.  That is,\n+   (frame_offset+frame_phase) % PREFERRED_STACK_BOUNDARY == 0.  */\n+static int frame_phase;\n+\n+\n+/* Discover the byte alignment to use for DECL.  Ignore alignment\n+   we can't do with expected alignment of the stack boundary.  */\n+\n+static unsigned int\n+get_decl_align_unit (tree decl)\n+{\n+  unsigned int align;\n+\n+  align = DECL_ALIGN (decl);\n+  align = LOCAL_ALIGNMENT (TREE_TYPE (decl), align);\n+  if (align > PREFERRED_STACK_BOUNDARY)\n+    align = PREFERRED_STACK_BOUNDARY;\n+  if (cfun->stack_alignment_needed < align)\n+    cfun->stack_alignment_needed = align;\n+\n+  return align / BITS_PER_UNIT;\n+}\n+\n+/* Allocate SIZE bytes at byte alignment ALIGN from the stack frame.\n+   Return the frame offset.  */\n+\n+static HOST_WIDE_INT\n+alloc_stack_frame_space (HOST_WIDE_INT size, HOST_WIDE_INT align)\n+{\n+  HOST_WIDE_INT offset, new_frame_offset;\n+\n+  new_frame_offset = frame_offset;\n+  if (FRAME_GROWS_DOWNWARD)\n+    {\n+      new_frame_offset -= size + frame_phase;\n+      new_frame_offset &= -align;\n+      new_frame_offset += frame_phase;\n+      offset = new_frame_offset;\n+    }\n+  else\n+    {\n+      new_frame_offset -= frame_phase;\n+      new_frame_offset += align - 1;\n+      new_frame_offset &= -align;\n+      new_frame_offset += frame_phase;\n+      offset = new_frame_offset;\n+      new_frame_offset += size;\n+    }\n+  frame_offset = new_frame_offset;\n+\n+  return offset;\n+}\n+\n+/* Accumulate DECL into STACK_VARS.  */\n+\n+static void\n+add_stack_var (tree decl)\n+{\n+  if (stack_vars_num >= stack_vars_alloc)\n+    {\n+      if (stack_vars_alloc)\n+\tstack_vars_alloc = stack_vars_alloc * 3 / 2;\n+      else\n+\tstack_vars_alloc = 32;\n+      stack_vars\n+\t= XRESIZEVEC (struct stack_var, stack_vars, stack_vars_alloc);\n+    }\n+  stack_vars[stack_vars_num].decl = decl;\n+  stack_vars[stack_vars_num].offset = 0;\n+  stack_vars[stack_vars_num].size = tree_low_cst (DECL_SIZE_UNIT (decl), 1);\n+  stack_vars[stack_vars_num].alignb = get_decl_align_unit (decl);\n+\n+  /* All variables are initially in their own partition.  */\n+  stack_vars[stack_vars_num].representative = stack_vars_num;\n+  stack_vars[stack_vars_num].next = EOC;\n+\n+  /* Ensure that this decl doesn't get put onto the list twice.  */\n+  SET_DECL_RTL (decl, pc_rtx);\n+\n+  stack_vars_num++;\n+}\n+\n+/* Compute the linear index of a lower-triangular coordinate (I, J).  */\n+\n+static size_t\n+triangular_index (size_t i, size_t j)\n+{\n+  if (i < j)\n+    {\n+      size_t t;\n+      t = i, i = j, j = t;\n+    }\n+  return (i * (i + 1)) / 2 + j;\n+}\n+\n+/* Ensure that STACK_VARS_CONFLICT is large enough for N objects.  */\n+\n+static void\n+resize_stack_vars_conflict (size_t n)\n+{\n+  size_t size = triangular_index (n-1, n-1) + 1;\n+\n+  if (size <= stack_vars_conflict_alloc)\n+    return;\n+\n+  stack_vars_conflict = XRESIZEVEC (bool, stack_vars_conflict, size);\n+  memset (stack_vars_conflict + stack_vars_conflict_alloc, 0,\n+\t  (size - stack_vars_conflict_alloc) * sizeof (bool));\n+  stack_vars_conflict_alloc = size;\n+}\n+\n+/* Make the decls associated with luid's X and Y conflict.  */\n+\n+static void\n+add_stack_var_conflict (size_t x, size_t y)\n+{\n+  size_t index = triangular_index (x, y);\n+  gcc_assert (index < stack_vars_conflict_alloc);\n+  stack_vars_conflict[index] = true;\n+}\n+\n+/* Check whether the decls associated with luid's X and Y conflict.  */\n+\n+static bool\n+stack_var_conflict_p (size_t x, size_t y)\n+{\n+  size_t index = triangular_index (x, y);\n+  gcc_assert (index < stack_vars_conflict_alloc);\n+  return stack_vars_conflict[index];\n+}\n+  \n+/* A subroutine of expand_used_vars.  If two variables X and Y have alias\n+   sets that do not conflict, then do add a conflict for these variables\n+   in the interference graph.  We also have to mind MEM_IN_STRUCT_P and\n+   MEM_SCALAR_P.  */\n+\n+static void\n+add_alias_set_conflicts (void)\n+{\n+  size_t i, j, n = stack_vars_num;\n+\n+  for (i = 0; i < n; ++i)\n+    {\n+      bool aggr_i = AGGREGATE_TYPE_P (TREE_TYPE (stack_vars[i].decl));\n+      HOST_WIDE_INT set_i = get_alias_set (stack_vars[i].decl);\n+\n+      for (j = 0; j < i; ++j)\n+\t{\n+\t  bool aggr_j = AGGREGATE_TYPE_P (TREE_TYPE (stack_vars[j].decl));\n+\t  HOST_WIDE_INT set_j = get_alias_set (stack_vars[j].decl);\n+\t  if (aggr_i != aggr_j || !alias_sets_conflict_p (set_i, set_j))\n+\t    add_stack_var_conflict (i, j);\n+\t}\n+    }\n+}\n+\n+/* A subroutine of partition_stack_vars.  A comparison function for qsort,\n+   sorting an array of indicies by the size of the object.  */\n+\n+static int\n+stack_var_size_cmp (const void *a, const void *b)\n+{\n+  HOST_WIDE_INT sa = stack_vars[*(const size_t *)a].size;\n+  HOST_WIDE_INT sb = stack_vars[*(const size_t *)b].size;\n+\n+  if (sa < sb)\n+    return -1;\n+  if (sa > sb)\n+    return 1;\n+  return 0;\n+}\n+\n+/* A subroutine of partition_stack_vars.  The UNION portion of a UNION/FIND\n+   partitioning algorithm.  Partitions A and B are known to be non-conflicting.\n+   Merge them into a single partition A.\n+\n+   At the same time, add OFFSET to all variables in partition B.  At the end\n+   of the partitioning process we've have a nice block easy to lay out within\n+   the stack frame.  */\n+\n+static void\n+union_stack_vars (size_t a, size_t b, HOST_WIDE_INT offset)\n+{\n+  size_t i, last;\n+\n+  /* Update each element of partition B with the given offset,\n+     and merge them into partition A.  */\n+  for (last = i = b; i != EOC; last = i, i = stack_vars[i].next)\n+    {\n+      stack_vars[i].offset += offset;\n+      stack_vars[i].representative = a;\n+    }\n+  stack_vars[last].next = stack_vars[a].next;\n+  stack_vars[a].next = b;\n+\n+  /* Update the required alignment of partition A to account for B.  */\n+  if (stack_vars[a].alignb < stack_vars[b].alignb)\n+    stack_vars[a].alignb = stack_vars[b].alignb;\n+\n+  /* Update the interference graph and merge the conflicts.  */\n+  for (last = stack_vars_num, i = 0; i < last; ++i)\n+    if (stack_var_conflict_p (b, i))\n+      add_stack_var_conflict (a, i);\n+}\n+\n+/* A subroutine of expand_used_vars.  Binpack the variables into\n+   partitions constrained by the interference graph.  The overall\n+   algorithm used is as follows:\n+\n+\tSort the objects by size.\n+\tFor each object A {\n+\t  S = size(A)\n+\t  O = 0\n+\t  loop {\n+\t    Look for the largest non-conflicting object B with size <= S.\n+\t    UNION (A, B)\n+\t    offset(B) = O\n+\t    O += size(B)\n+\t    S -= size(B)\n+\t  }\n+\t}\n+*/\n+\n+static void\n+partition_stack_vars (void)\n+{\n+  size_t si, sj, n = stack_vars_num;\n+\n+  stack_vars_sorted = XNEWVEC (size_t, stack_vars_num);\n+  for (si = 0; si < n; ++si)\n+    stack_vars_sorted[si] = si;\n+\n+  if (n == 1)\n+    return;\n+\n+  qsort (stack_vars_sorted, n, sizeof (size_t), stack_var_size_cmp);\n+\n+  /* Special case: detect when all variables conflict, and thus we can't\n+     do anything during the partitioning loop.  It isn't uncommon (with\n+     C code at least) to declare all variables at the top of the function,\n+     and if we're not inlining, then all variables will be in the same scope.\n+     Take advantage of very fast libc routines for this scan.  */\n+  gcc_assert (sizeof(bool) == sizeof(char));\n+  if (memchr (stack_vars_conflict, false, stack_vars_conflict_alloc) == NULL)\n+    return;\n+\n+  for (si = 0; si < n; ++si)\n+    {\n+      size_t i = stack_vars_sorted[si];\n+      HOST_WIDE_INT isize = stack_vars[i].size;\n+      HOST_WIDE_INT offset = 0;\n+\n+      for (sj = si; sj-- > 0; )\n+\t{\n+\t  size_t j = stack_vars_sorted[sj];\n+\t  HOST_WIDE_INT jsize = stack_vars[j].size;\n+\t  unsigned int jalign = stack_vars[j].alignb;\n+\n+\t  /* Ignore objects that aren't partition representatives.  */\n+\t  if (stack_vars[j].representative != j)\n+\t    continue;\n+\n+\t  /* Ignore objects too large for the remaining space.  */\n+\t  if (isize < jsize)\n+\t    continue;\n+\n+\t  /* Ignore conflicting objects.  */\n+\t  if (stack_var_conflict_p (i, j))\n+\t    continue;\n+\n+\t  /* Refine the remaining space check to include alignment.  */\n+\t  if (offset & (jalign - 1))\n+\t    {\n+\t      HOST_WIDE_INT toff = offset;\n+\t      toff += jalign - 1;\n+\t      toff &= -(HOST_WIDE_INT)jalign;\n+\t      if (isize - (toff - offset) < jsize)\n+\t\tcontinue;\n+\n+\t      isize -= toff - offset;\n+\t      offset = toff;\n+\t    }\n+\n+\t  /* UNION the objects, placing J at OFFSET.  */\n+\t  union_stack_vars (i, j, offset);\n+\n+\t  isize -= jsize;\n+\t  if (isize == 0)\n+\t    break;\n+\t}\n+    }\n+}\n+\n+/* A debugging aid for expand_used_vars.  Dump the generated partitions.  */\n+\n+static void\n+dump_stack_var_partition (void)\n+{\n+  size_t si, i, j, n = stack_vars_num;\n+\n+  for (si = 0; si < n; ++si)\n+    {\n+      i = stack_vars_sorted[si];\n+\n+      /* Skip variables that aren't partition representatives, for now.  */\n+      if (stack_vars[i].representative != i)\n+\tcontinue;\n+\n+      fprintf (dump_file, \"Partition %lu: size \" HOST_WIDE_INT_PRINT_DEC\n+\t       \" align %u\\n\", (unsigned long) i, stack_vars[i].size,\n+\t       stack_vars[i].alignb);\n+\n+      for (j = i; j != EOC; j = stack_vars[j].next)\n+\t{\n+\t  fputc ('\\t', dump_file);\n+\t  print_generic_expr (dump_file, stack_vars[j].decl, dump_flags);\n+\t  fprintf (dump_file, \", offset \" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n+\t\t   stack_vars[i].offset);\n+\t}\n+    }\n+}\n+\n+/* Assign rtl to DECL at frame offset OFFSET.  */\n+\n+static void\n+expand_one_stack_var_at (tree decl, HOST_WIDE_INT offset)\n+{\n+  HOST_WIDE_INT align;\n+  rtx x;\n+  \n+  /* If this fails, we've overflowed the stack frame.  Error nicely?  */\n+  gcc_assert (offset == trunc_int_for_mode (offset, Pmode));\n+\n+  x = plus_constant (virtual_stack_vars_rtx, offset);\n+  x = gen_rtx_MEM (DECL_MODE (decl), x);\n+\n+  /* Set alignment we actually gave this decl.  */\n+  offset -= frame_phase;\n+  align = offset & -offset;\n+  align *= BITS_PER_UNIT;\n+  if (align > STACK_BOUNDARY || align == 0)\n+    align = STACK_BOUNDARY;\n+  DECL_ALIGN (decl) = align;\n+  DECL_USER_ALIGN (decl) = 0;\n+\n+  set_mem_attributes (x, decl, true);\n+  SET_DECL_RTL (decl, x);\n+}\n+\n+/* A subroutine of expand_used_vars.  Give each partition representative\n+   a unique location within the stack frame.  Update each partition member\n+   with that location.  */\n+\n+static void\n+expand_stack_vars (void)\n+{\n+  size_t si, i, j, n = stack_vars_num;\n+\n+  for (si = 0; si < n; ++si)\n+    {\n+      HOST_WIDE_INT offset;\n+\n+      i = stack_vars_sorted[si];\n+\n+      /* Skip variables that aren't partition representatives, for now.  */\n+      if (stack_vars[i].representative != i)\n+\tcontinue;\n+\n+      offset = alloc_stack_frame_space (stack_vars[i].size,\n+\t\t\t\t\tstack_vars[i].alignb);\n+\n+      /* Create rtl for each variable based on their location within the\n+\t partition.  */\n+      for (j = i; j != EOC; j = stack_vars[j].next)\n+\texpand_one_stack_var_at (stack_vars[j].decl,\n+\t\t\t\t stack_vars[j].offset + offset);\n+    }\n+}\n+\n+/* A subroutine of expand_one_var.  Called to immediately assign rtl\n+   to a variable to be allocated in the stack frame.  */\n+\n+static void\n+expand_one_stack_var (tree var)\n+{\n+  HOST_WIDE_INT size, offset, align;\n+\n+  size = tree_low_cst (DECL_SIZE_UNIT (var), 1);\n+  align = get_decl_align_unit (var);\n+  offset = alloc_stack_frame_space (size, align);\n+\n+  expand_one_stack_var_at (var, offset);\n+}\n+\n+/* A subroutine of expand_one_var.  Called to assign rtl\n+   to a TREE_STATIC VAR_DECL.  */\n+\n+static void\n+expand_one_static_var (tree var)\n+{\n+  /* If this is an inlined copy of a static local variable,\n+     look up the original.  */\n+  var = DECL_ORIGIN (var);\n+\n+  /* If we've already processed this variable because of that, do nothing.  */\n+  if (TREE_ASM_WRITTEN (var))\n+    return;\n+\n+  /* Give the front end a chance to do whatever.  In practice, this is\n+     resolving duplicate names for IMA in C.  */\n+  if (lang_hooks.expand_decl (var))\n+    return;\n+\n+  /* Otherwise, just emit the variable.  */\n+  rest_of_decl_compilation (var, 0, 0);\n+}\n+\n+/* A subroutine of expand_one_var.  Called to assign rtl to a VAR_DECL\n+   that will reside in a hard register.  */\n+\n+static void\n+expand_one_hard_reg_var (tree var)\n+{\n+  rest_of_decl_compilation (var, 0, 0);\n+}\n+\n+/* A subroutine of expand_one_var.  Called to assign rtl to a VAR_DECL\n+   that will reside in a pseudo register.  */\n+\n+static void\n+expand_one_register_var (tree var)\n+{\n+  tree type = TREE_TYPE (var);\n+  int unsignedp = TYPE_UNSIGNED (type);\n+  enum machine_mode reg_mode\n+    = promote_mode (type, DECL_MODE (var), &unsignedp, 0);\n+  rtx x = gen_reg_rtx (reg_mode);\n+\n+  SET_DECL_RTL (var, x);\n+\n+  /* Note if the object is a user variable.  */\n+  if (!DECL_ARTIFICIAL (var))\n+    {\n+      mark_user_reg (x);\n+\n+      /* Trust user variables which have a pointer type to really\n+\t be pointers.  Do not trust compiler generated temporaries\n+\t as our type system is totally busted as it relates to\n+\t pointer arithmetic which translates into lots of compiler\n+\t generated objects with pointer types, but which are not really\n+\t pointers.  */\n+      if (POINTER_TYPE_P (type))\n+\tmark_reg_pointer (x, TYPE_ALIGN (TREE_TYPE (TREE_TYPE (var))));\n+    }\n+}\n+\n+/* A subroutine of expand_one_var.  Called to assign rtl to a VAR_DECL that\n+   has some associated error, e.g. it's type is error-mark.  We just need\n+   to pick something that won't crash the rest of the compiler.  */\n+\n+static void\n+expand_one_error_var (tree var)\n+{\n+  enum machine_mode mode = DECL_MODE (var);\n+  rtx x;\n+\n+  if (mode == BLKmode)\n+    x = gen_rtx_MEM (BLKmode, const0_rtx);\n+  else if (mode == VOIDmode)\n+    x = const0_rtx;\n+  else\n+    x = gen_reg_rtx (mode);\n+\n+  SET_DECL_RTL (var, x);\n+}\n+\n+/* A subroutine of expand_one_var.  VAR is a variable that will be \n+   allocated to the local stack frame.  Return true if we wish to\n+   add VAR to STACK_VARS so that it will be coalesced with other\n+   variables.  Return false to allocate VAR immediately.\n+\n+   This function is used to reduce the number of variables considered\n+   for coalescing, which reduces the size of the quadratic problem.  */\n+\n+static bool\n+defer_stack_allocation (tree var, bool toplevel)\n+{\n+  /* Variables in the outermost scope automatically conflict with\n+     every other variable.  The only reason to want to defer them\n+     at all is that, after sorting, we can more efficiently pack\n+     small variables in the stack frame.  Continue to defer at -O2.  */\n+  if (toplevel && optimize < 2)\n+    return false;\n+\n+  /* Without optimization, *most* variables are allocated from the\n+     stack, which makes the quadratic problem large exactly when we\n+     want compilation to proceed as quickly as possible.  On the \n+     other hand, we don't want the function's stack frame size to\n+     get completely out of hand.  So we avoid adding scalars and\n+     \"small\" aggregates to the list at all.  */\n+  if (optimize == 0 && tree_low_cst (DECL_SIZE_UNIT (var), 1) < 32)\n+    return false;\n+\n+  return true;\n+}\n+\n+/* A subroutine of expand_used_vars.  Expand one variable according to\n+   its flavour.  Variables to be placed on the stack are not actually\n+   expanded yet, merely recorded.  */\n+\n+static void\n+expand_one_var (tree var, bool toplevel)\n+{\n+  if (TREE_CODE (var) != VAR_DECL)\n+    lang_hooks.expand_decl (var);\n+  else if (DECL_EXTERNAL (var))\n+    ;\n+  else if (DECL_VALUE_EXPR (var))\n+    ;\n+  else if (TREE_STATIC (var))\n+    expand_one_static_var (var);\n+  else if (DECL_RTL_SET_P (var))\n+    ;\n+  else if (TREE_TYPE (var) == error_mark_node)\n+    expand_one_error_var (var);\n+  else if (DECL_HARD_REGISTER (var))\n+    expand_one_hard_reg_var (var);\n+  else if (use_register_for_decl (var))\n+    expand_one_register_var (var);\n+  else if (defer_stack_allocation (var, toplevel))\n+    add_stack_var (var);\n+  else\n+    expand_one_stack_var (var);\n+}\n+\n+/* A subroutine of expand_used_vars.  Walk down through the BLOCK tree\n+   expanding variables.  Those variables that can be put into registers\n+   are allocated pseudos; those that can't are put on the stack.\n+\n+   TOPLEVEL is true if this is the outermost BLOCK.  */\n+\n+static void\n+expand_used_vars_for_block (tree block, bool toplevel)\n+{\n+  size_t i, j, old_sv_num, this_sv_num, new_sv_num;\n+  tree t;\n+\n+  old_sv_num = toplevel ? 0 : stack_vars_num;\n+\n+  /* Expand all variables at this level.  */\n+  for (t = BLOCK_VARS (block); t ; t = TREE_CHAIN (t))\n+    if (TREE_USED (t))\n+      expand_one_var (t, toplevel);\n+\n+  this_sv_num = stack_vars_num;\n+\n+  /* Expand all variables at containing levels.  */\n+  for (t = BLOCK_SUBBLOCKS (block); t ; t = BLOCK_CHAIN (t))\n+    expand_used_vars_for_block (t, false);\n+\n+  /* Since we do not track exact variable lifetimes (which is not even\n+     possible for varibles whose address escapes), we mirror the block\n+     tree in the interference graph.  Here we cause all variables at this\n+     level, and all sublevels, to conflict.  Do make certain that a\n+     variable conflicts with itself.  */\n+  if (old_sv_num < this_sv_num)\n+    {\n+      new_sv_num = stack_vars_num;\n+      resize_stack_vars_conflict (new_sv_num);\n+\n+      for (i = old_sv_num; i < new_sv_num; ++i)\n+\tfor (j = i < this_sv_num ? i : this_sv_num; ; --j)\n+\t  {\n+\t    add_stack_var_conflict (i, j);\n+\t    if (j == old_sv_num)\n+\t      break;\n+\t  }\n+    }\n+}\n+\n+/* A subroutine of expand_used_vars.  Walk down through the BLOCK tree\n+   and clear TREE_USED on all local variables.  */\n+\n+static void\n+clear_tree_used (tree block)\n+{\n+  tree t;\n+\n+  for (t = BLOCK_VARS (block); t ; t = TREE_CHAIN (t))\n+    /* if (!TREE_STATIC (t) && !DECL_EXTERNAL (t)) */\n+      TREE_USED (t) = 0;\n+\n+  for (t = BLOCK_SUBBLOCKS (block); t ; t = BLOCK_CHAIN (t))\n+    clear_tree_used (t);\n+}\n+\n+/* Expand all variables used in the function.  */\n \n static void\n expand_used_vars (void)\n {\n-  tree cell;\n+  tree t, outer_block = DECL_INITIAL (current_function_decl);\n \n-  cfun->unexpanded_var_list = nreverse (cfun->unexpanded_var_list);\n+  /* Compute the phase of the stack frame for this function.  */\n+  {\n+    int align = PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT;\n+    int off = STARTING_FRAME_OFFSET % align;\n+    frame_phase = off ? align - off : 0;\n+  }\n \n-  for (cell = cfun->unexpanded_var_list; cell; cell = TREE_CHAIN (cell))\n-    expand_var (TREE_VALUE (cell));\n+  /* Set TREE_USED on all variables in the unexpanded_var_list.  */\n+  for (t = cfun->unexpanded_var_list; t; t = TREE_CHAIN (t))\n+    TREE_USED (TREE_VALUE (t)) = 1;\n \n+  /* Clear TREE_USED on all variables associated with a block scope.  */\n+  clear_tree_used (outer_block);\n+\n+  /* At this point all variables on the unexpanded_var_list with TREE_USED\n+     set are not associated with any block scope.  Lay them out.  */\n+  for (t = cfun->unexpanded_var_list; t; t = TREE_CHAIN (t))\n+    {\n+      tree var = TREE_VALUE (t);\n+      bool expand_now = false;\n+\n+      /* We didn't set a block for static or extern because it's hard\n+\t to tell the difference between a global variable (re)declared\n+\t in a local scope, and one that's really declared there to\n+\t begin with.  And it doesn't really matter much, since we're\n+\t not giving them stack space.  Expand them now.  */\n+      if (TREE_STATIC (var) || DECL_EXTERNAL (var))\n+\texpand_now = true;\n+\n+      /* Any variable that could have been hoisted into an SSA_NAME\n+\t will have been propagated anywhere the optimizers chose,\n+\t i.e. not confined to their original block.  Allocate them\n+\t as if they were defined in the outermost scope.  */\n+      else if (is_gimple_reg (var))\n+\texpand_now = true;\n+\n+      /* If the variable is not associated with any block, then it\n+\t was created by the optimizers, and could be live anywhere\n+\t in the function.  */\n+      else if (TREE_USED (var))\n+\texpand_now = true;\n+\n+      /* Finally, mark all variables on the list as used.  We'll use\n+\t this in a moment when we expand those associated with scopes.  */\n+      TREE_USED (var) = 1;\n+\n+      if (expand_now)\n+\texpand_one_var (var, true);\n+    }\n   cfun->unexpanded_var_list = NULL_TREE;\n+\n+  /* At this point, all variables within the block tree with TREE_USED\n+     set are actually used by the optimized function.  Lay them out.  */\n+  expand_used_vars_for_block (outer_block, true);\n+\n+  if (stack_vars_num > 0)\n+    {\n+      /* Due to the way alias sets work, no variables with non-conflicting\n+\t alias sets may be assigned the same address.  Add conflicts to \n+\t reflect this.  */\n+      add_alias_set_conflicts ();\n+\n+      /* Now that we have collected all stack variables, and have computed a \n+\t minimal interference graph, attempt to save some stack space.  */\n+      partition_stack_vars ();\n+      if (dump_file)\n+\tdump_stack_var_partition ();\n+\n+      /* Assign rtl to each variable based on these partitions.  */\n+      expand_stack_vars ();\n+\n+      /* Free up stack variable graph data.  */\n+      XDELETEVEC (stack_vars);\n+      XDELETEVEC (stack_vars_sorted);\n+      XDELETEVEC (stack_vars_conflict);\n+      stack_vars = NULL;\n+      stack_vars_alloc = stack_vars_num = 0;\n+      stack_vars_conflict = NULL;\n+      stack_vars_conflict_alloc = 0;\n+    }\n+\n+  /* If the target requires that FRAME_OFFSET be aligned, do it.  */\n+  if (STACK_ALIGNMENT_NEEDED)\n+    {\n+      HOST_WIDE_INT align = PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT;\n+      if (!FRAME_GROWS_DOWNWARD)\n+\tframe_offset += align - 1;\n+      frame_offset &= -align;\n+    }\n }\n \n "}]}