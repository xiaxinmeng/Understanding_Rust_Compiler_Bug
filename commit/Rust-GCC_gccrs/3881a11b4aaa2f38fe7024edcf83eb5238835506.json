{"sha": "3881a11b4aaa2f38fe7024edcf83eb5238835506", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzg4MWExMWI0YWFhMmYzOGZlNzAyNGVkY2Y4M2ViNTIzODgzNTUwNg==", "commit": {"author": {"name": "Ranjit Mathew", "email": "rmathew@hotmail.com", "date": "2005-08-16T18:22:31Z"}, "committer": {"name": "Ranjit Mathew", "email": "rmathew@gcc.gnu.org", "date": "2005-08-16T18:22:31Z"}, "message": "re PR java/19870 (gcj -C doesn't generate accessors for private members across nested class boundaries)\n\n\tPR java/19870\n\t* parse.y (nested_field_access_p): Rename to nested_member_access_p\n\tand expand to handle method accesses across nested classes.\n\t(build_outer_method_access_method): Rename to\n\tbuild_nested_method_access_method.  Minor adjustments to comments.\n\t(resolve_expression_name): Use the newly-renamed\n\tnested_member_access_p method.\n\t(resolve_qualified_expression_name): Likewise.\n\t(patch_method_invocation): Also consider static methods for access\n\tmethod generation.  Minor adjustments to comments.\n\t(maybe_use_access_method): Use the more general\n\tnested_memeber_access_p to determine access across nested class\n\tboundaries.  Allow THIS_ARG to be NULL (for static methods).\n\nFrom-SVN: r103163", "tree": {"sha": "a47c1d1c9061c310088fa4a15ce0ad9df0fc2865", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a47c1d1c9061c310088fa4a15ce0ad9df0fc2865"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3881a11b4aaa2f38fe7024edcf83eb5238835506", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3881a11b4aaa2f38fe7024edcf83eb5238835506", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3881a11b4aaa2f38fe7024edcf83eb5238835506", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3881a11b4aaa2f38fe7024edcf83eb5238835506/comments", "author": null, "committer": null, "parents": [{"sha": "6ab9469a15aaa017a8d4c71f989fafef020cb0c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ab9469a15aaa017a8d4c71f989fafef020cb0c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ab9469a15aaa017a8d4c71f989fafef020cb0c3"}], "stats": {"total": 129, "additions": 79, "deletions": 50}, "files": [{"sha": "4985baab98c50f80b3a79f7dadb3e0d81e610e57", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3881a11b4aaa2f38fe7024edcf83eb5238835506/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3881a11b4aaa2f38fe7024edcf83eb5238835506/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=3881a11b4aaa2f38fe7024edcf83eb5238835506", "patch": "@@ -1,3 +1,19 @@\n+2005-08-16  Ranjit Mathew  <rmathew@hotmail.com>\n+\n+\tPR java/19870\n+\t* parse.y (nested_field_access_p): Rename to nested_member_access_p\n+\tand expand to handle method accesses across nested classes.\n+\t(build_outer_method_access_method): Rename to\n+\tbuild_nested_method_access_method.  Minor adjustments to comments.\n+\t(resolve_expression_name): Use the newly-renamed\n+\tnested_member_access_p method.\n+\t(resolve_qualified_expression_name): Likewise.\n+\t(patch_method_invocation): Also consider static methods for access\n+\tmethod generation.  Minor adjustments to comments.\n+\t(maybe_use_access_method): Use the more general\n+\tnested_memeber_access_p to determine access across nested class\n+\tboundaries.  Allow THIS_ARG to be NULL (for static methods).\n+\n 2005-08-15  Tom Tromey  <tromey@redhat.com>\n \n \tPR java/23300."}, {"sha": "b1de35fc7f0f2e1936f5a264c53ce934a1726472", "filename": "gcc/java/parse.y", "status": "modified", "additions": 63, "deletions": 50, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3881a11b4aaa2f38fe7024edcf83eb5238835506/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3881a11b4aaa2f38fe7024edcf83eb5238835506/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=3881a11b4aaa2f38fe7024edcf83eb5238835506", "patch": "@@ -326,10 +326,10 @@ static tree build_nested_field_access (tree, tree);\n static tree build_nested_field_access_methods (tree);\n static tree build_nested_field_access_method (tree, tree, tree, tree, tree);\n static tree build_nested_field_access_expr (int, tree, tree, tree, tree);\n-static tree build_outer_method_access_method (tree);\n+static tree build_nested_method_access_method (tree);\n static tree build_new_access_id (void);\n \n-static int nested_field_access_p (tree, tree);\n+static int nested_member_access_p (tree, tree);\n static int nested_field_expanded_access_p (tree, tree *, tree *, tree *);\n static tree nested_field_access_fix (tree, tree, tree);\n \n@@ -8371,31 +8371,35 @@ build_nested_field_access (tree id, tree decl)\n   return resolve_expression_name (access, NULL);\n }\n \n-/* Return a nonzero value if DECL describes a field access across nested\n+/* Return a nonzero value if DECL describes a member access across nested\n    class boundaries.  That is, DECL is in a class that either encloses,\n-   is enclosed by or shares a common enclosing class with, the class\n+   is enclosed by or shares a common enclosing class with the class\n    TYPE.  */\n \n static int\n-nested_field_access_p (tree type, tree decl)\n+nested_member_access_p (tree type, tree decl)\n {\n   bool is_static = false;\n   tree decl_type = DECL_CONTEXT (decl);\n   tree type_root, decl_type_root;\n \n   if (decl_type == type\n-      || (TREE_CODE (decl) != FIELD_DECL && TREE_CODE (decl) != VAR_DECL))\n+      || (TREE_CODE (decl) != FIELD_DECL\n+          && TREE_CODE (decl) != VAR_DECL\n+          && TREE_CODE (decl) != FUNCTION_DECL))\n     return 0;\n   \n   if (!INNER_CLASS_TYPE_P (type)\n       && !(TREE_CODE (decl_type) == RECORD_TYPE\n            && INNER_CLASS_TYPE_P (decl_type)))\n     return 0;\n \n-  is_static = FIELD_STATIC (decl);\n+  is_static = (TREE_CODE (decl) == FUNCTION_DECL)\n+              ? METHOD_STATIC (decl)\n+              : FIELD_STATIC (decl);\n \n   /* If TYPE extends the declaration context of the non-static\n-     field we're trying to access, then this isn't a nested field\n+     member we're trying to access, then this isn't a nested member\n      access we need to worry about.  */\n   if (!is_static && inherits_from_p (type, decl_type))\n     return 0;\n@@ -8672,10 +8676,10 @@ build_nested_field_access_method (tree class, tree type, tree name,\n \n \f\n /* This section deals with building access function necessary for\n-   certain kinds of method invocation from inner classes.  */\n+   certain kinds of method invocation across nested class boundaries.  */\n \n static tree\n-build_outer_method_access_method (tree decl)\n+build_nested_method_access_method (tree decl)\n {\n   tree saved_current_function_decl, mdecl;\n   tree args = NULL_TREE, call_args = NULL_TREE;\n@@ -8724,8 +8728,7 @@ build_outer_method_access_method (tree decl)\n   start_artificial_method_body (mdecl);\n \n   /* The actual method invocation uses the same args. When invoking a\n-     static methods that way, we don't want to skip the first\n-     argument. */\n+     static methods that way, we don't want to skip the first argument.  */\n   carg = args;\n   if (!METHOD_STATIC (decl))\n     carg = TREE_CHAIN (carg);\n@@ -8744,10 +8747,10 @@ build_outer_method_access_method (tree decl)\n   end_artificial_method_body (mdecl);\n   current_function_decl = saved_current_function_decl;\n \n-  /* Back tag the access function so it know what it accesses */\n+  /* Back tag the access function so it know what it accesses.  */\n   DECL_FUNCTION_ACCESS_DECL (decl) = mdecl;\n \n-  /* Tag the current method so it knows it has an access generated */\n+  /* Tag the current method so it knows it has an access generated.  */\n   return DECL_FUNCTION_INNER_ACCESS (decl) = mdecl;\n }\n \n@@ -9572,7 +9575,7 @@ resolve_expression_name (tree id, tree *orig)\n \t      /* If we're processing an inner class and we're trying\n \t\t to access a field belonging to an outer class, build\n \t\t the access to the field.  */\n-\t      if (nested_field_access_p (current_class, decl))\n+\t      if (nested_member_access_p (current_class, decl))\n \t\t{\n \t\t  if (!fs && CLASS_STATIC (TYPE_NAME (current_class)))\n \t\t    {\n@@ -10129,7 +10132,7 @@ resolve_qualified_expression_name (tree wfl, tree *found_decl,\n                           if (TREE_CODE (*where_found) == POINTER_TYPE)\n                             *where_found = TREE_TYPE (*where_found);\n                         }\n-                      if (nested_field_access_p (current_class, decl))\n+                      if (nested_member_access_p (current_class, decl))\n                         decl = build_nested_field_access (qual_wfl, decl);\n \t\t    }\n \t\t  else\n@@ -10272,7 +10275,7 @@ resolve_qualified_expression_name (tree wfl, tree *found_decl,\n               if (is_static\n                   && FIELD_PRIVATE (field_decl)\n                   && flag_emit_class_files\n-                  && nested_field_access_p (current_class, field_decl))\n+                  && nested_member_access_p (current_class, field_decl))\n                 field_decl = build_nested_field_access (qual_wfl, field_decl);\n \n \t      /* This is the decl found and eventually the next one to\n@@ -10572,16 +10575,22 @@ patch_method_invocation (tree patch, tree primary, tree where, int from_super,\n \t\t IDENTIFIER_POINTER (name));\n \t      PATCH_METHOD_RETURN_ERROR ();\n \t    }\n-\t  if (list && !METHOD_STATIC (list))\n+\t  if (list)\n \t    {\n-\t      char *fct_name = xstrdup (lang_printable_name (list, 2));\n-\t      parse_error_context\n-\t\t(identifier_wfl,\n-\t\t \"Can't make static reference to method %<%s %s%> in class %qs\",\n-\t\t lang_printable_name (TREE_TYPE (TREE_TYPE (list)), 0),\n-\t\t fct_name, IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type))));\n-\t      free (fct_name);\n-\t      PATCH_METHOD_RETURN_ERROR ();\n+              if (METHOD_STATIC (list))\n+                maybe_use_access_method (0, &list, NULL);\n+              else\n+                {\n+                  char *fct_name = xstrdup (lang_printable_name (list, 2));\n+                  parse_error_context\n+                    (identifier_wfl,\n+                     \"Can't make static reference to method %<%s %s%> in class %qs\",\n+                     lang_printable_name (TREE_TYPE (TREE_TYPE (list)), 0),\n+                     fct_name,\n+                     IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type))));\n+                  free (fct_name);\n+                  PATCH_METHOD_RETURN_ERROR ();\n+                }\n \t    }\n \t}\n       else\n@@ -10698,7 +10707,7 @@ patch_method_invocation (tree patch, tree primary, tree where, int from_super,\n           && DECL_NAME (list) == get_identifier (\"clone\"))\n         is_array_clone_call = 1;\n \n-      /* Check for static reference if non static methods */\n+      /* Check for static reference of non static methods.  */\n       if (check_for_static_method_reference (wfl, patch, list,\n \t\t\t\t\t     class_to_search, primary))\n \tPATCH_METHOD_RETURN_ERROR ();\n@@ -10718,8 +10727,8 @@ patch_method_invocation (tree patch, tree primary, tree where, int from_super,\n \t}\n \n       /* Non static methods are called with the current object extra\n-\t argument. If patch a `new TYPE()', the argument is the value\n-\t returned by the object allocator. If method is resolved as a\n+\t argument.  If PATCH is a `new TYPE()', the argument is the value\n+\t returned by the object allocator.  If method is resolved as a\n \t primary, use the primary otherwise use the current THIS. */\n       args = nreverse (args);\n       if (TREE_CODE (patch) != NEW_CLASS_EXPR)\n@@ -10731,16 +10740,16 @@ patch_method_invocation (tree patch, tree primary, tree where, int from_super,\n \n \t     1) We're not generating bytecodes:\n \n-\t     - LIST is non static. It's invocation is transformed from\n+\t     - LIST is non-static.  Its invocation is transformed from\n \t       x(a1,...,an) into this$<n>.x(a1,....an).\n-\t     - LIST is static. It's invocation is transformed from\n+\t     - LIST is static.  Its invocation is transformed from\n \t       x(a1,...,an) into TYPE_OF(this$<n>).x(a1,....an)\n \n \t     2) We're generating bytecodes:\n \n-\t     - LIST is non static. It's invocation is transformed from\n+\t     - LIST is non-static.  Its invocation is transformed from\n \t       x(a1,....,an) into access$<n>(this$<n>,a1,...,an).\n-\t     - LIST is static. It's invocation is transformed from\n+\t     - LIST is static.  Its invocation is transformed from\n \t       x(a1,....,an) into TYPE_OF(this$<n>).x(a1,....an).\n \n \t     Of course, this$<n> can be arbitrarily complex, ranging from\n@@ -10749,10 +10758,12 @@ patch_method_invocation (tree patch, tree primary, tree where, int from_super,\n \n \t     maybe_use_access_method returns a nonzero value if the\n \t     this_arg has to be moved into the (then generated) stub\n-\t     argument list. In the meantime, the selected function\n-\t     might have be replaced by a generated stub. */\n-\t  if (!primary &&\n-\t      maybe_use_access_method (is_super_init, &list, &this_arg))\n+\t     argument list.  In the meantime, the selected function\n+\t     might have been replaced by a generated stub.  */\n+          if (METHOD_STATIC (list))\n+            maybe_use_access_method (0, &list, NULL);\n+\t  else if (!primary &&\n+\t           maybe_use_access_method (is_super_init, &list, &this_arg))\n \t    {\n \t      args = tree_cons (NULL_TREE, this_arg, args);\n \t      this_arg = NULL_TREE; /* So it doesn't get chained twice */\n@@ -10920,34 +10931,35 @@ check_for_static_method_reference (tree wfl, tree node, tree method,\n   return 0;\n }\n \n-/* Fix the invocation of *MDECL if necessary in the case of a\n-   invocation from an inner class. *THIS_ARG might be modified\n+/* Fix the invocation of *MDECL if necessary in the case of an\n+   invocation across a nested class.  *THIS_ARG might be modified\n    appropriately and an alternative access to *MDECL might be\n    returned.  */\n \n static int\n maybe_use_access_method (int is_super_init, tree *mdecl, tree *this_arg)\n {\n   tree ctx;\n-  tree md = *mdecl, ta = *this_arg;\n+  tree md = *mdecl, ta = NULL_TREE;\n   int to_return = 0;\n   int non_static_context = !METHOD_STATIC (md);\n \n   if (is_super_init\n-      || DECL_CONTEXT (md) == current_class\n-      || !PURE_INNER_CLASS_TYPE_P (current_class)\n       || DECL_FINIT_P (md)\n-      || DECL_INSTINIT_P (md))\n+      || DECL_INSTINIT_P (md)\n+      || !nested_member_access_p (current_class, md))\n     return 0;\n \n   /* If we're calling a method found in an enclosing class, generate\n-     what it takes to retrieve the right this. Don't do that if we're\n-     invoking a static method. Note that if MD's type is unrelated to\n+     what it takes to retrieve the right `this'.  Don't do that if we're\n+     invoking a static method.  Note that if MD's type is unrelated to\n      CURRENT_CLASS, then the current this can be used. */\n \n   if (non_static_context \n-      && !inherits_from_p (current_class, DECL_CONTEXT (md)))\n+      && !inherits_from_p (current_class, DECL_CONTEXT (md))\n+      && DECL_CONTEXT (TYPE_NAME (current_class)))\n     {\n+      ta = *this_arg;\n       ctx = TREE_TYPE (DECL_CONTEXT (TYPE_NAME (current_class)));\n       if (inherits_from_p (ctx, DECL_CONTEXT (md)))\n \t{\n@@ -10973,16 +10985,17 @@ maybe_use_access_method (int is_super_init, tree *mdecl, tree *this_arg)\n     }\n \n   /* We might have to use an access method to get to MD. We can\n-     break the method access rule as far as we're not generating\n-     bytecode */\n+     break the method access rule as long as we're not generating\n+     bytecode.  */\n   if (METHOD_PRIVATE (md) && flag_emit_class_files)\n     {\n-      md = build_outer_method_access_method (md);\n+      md = build_nested_method_access_method (md);\n       to_return = 1;\n     }\n \n   *mdecl = md;\n-  *this_arg = ta;\n+  if (this_arg)\n+    *this_arg = ta;\n \n   /* Returning a nonzero value indicates we were doing a non static\n      method invocation that is now a static invocation. It will have"}]}