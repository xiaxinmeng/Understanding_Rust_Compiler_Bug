{"sha": "69029c61aa94cec4fb273dcfc7693f754d9b4452", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjkwMjljNjFhYTk0Y2VjNGZiMjczZGNmYzc2OTNmNzU0ZDliNDQ1Mg==", "commit": {"author": {"name": "Paul Brook", "email": "pbrook@gcc.gnu.org", "date": "2005-01-23T22:29:41Z"}, "committer": {"name": "Paul Brook", "email": "pbrook@gcc.gnu.org", "date": "2005-01-23T22:29:41Z"}, "message": "re PR fortran/17941 (gfortran: parser chokes on complex literal constant)\n\n2004-01-23  Paul Brook  <paul@codesourcery.com>\n\tSteven G. Kargl  <kargls@comcast.net>\n\n\tPR fortran/17941\n\t* arith.c (gfc_convert_real): Remove sign handling.\n\t* primary.c (match_digits): Allow whitespace after initial sign.\n\t(match_real_const): Handle signs here.  Allow whitespace after\n\tinitial sign.  Remove dead code.\n\t(match_const_complex_part): Remove.\n\t(match_complex_part): Use match_{real,integer}_const.\n\t(match_complex_constant): Cross-promote integer types.\ntestsuite/\n\t* gfortran.dg/real_const_1.f: New test.\n\t* gfortran.dg/real_const_2.f90: New test.\n\t* gfortran.dg/complex_int_1.f90: New test.\n\nFrom-SVN: r94127", "tree": {"sha": "482560991382bf4a800f1c23734d475bd99bc65d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/482560991382bf4a800f1c23734d475bd99bc65d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/69029c61aa94cec4fb273dcfc7693f754d9b4452", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69029c61aa94cec4fb273dcfc7693f754d9b4452", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69029c61aa94cec4fb273dcfc7693f754d9b4452", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69029c61aa94cec4fb273dcfc7693f754d9b4452/comments", "author": null, "committer": null, "parents": [{"sha": "708bde14eaf5568ecc2fdb23a4cb15762f117f7c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/708bde14eaf5568ecc2fdb23a4cb15762f117f7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/708bde14eaf5568ecc2fdb23a4cb15762f117f7c"}], "stats": {"total": 308, "additions": 135, "deletions": 173}, "files": [{"sha": "2cb19583aca76337afb96011f90206ea3f1198f5", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69029c61aa94cec4fb273dcfc7693f754d9b4452/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69029c61aa94cec4fb273dcfc7693f754d9b4452/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=69029c61aa94cec4fb273dcfc7693f754d9b4452", "patch": "@@ -1,3 +1,15 @@\n+2004-01-23  Paul Brook  <paul@codesourcery.com>\n+\tSteven G. Kargl  <kargls@comcast.net>\n+\n+\tPR fortran/17941\n+\t* arith.c (gfc_convert_real): Remove sign handling.\n+\t* primary.c (match_digits): Allow whitespace after initial sign.\n+\t(match_real_const): Handle signs here.  Allow whitespace after\n+\tinitial sign.  Remove dead code.\n+\t(match_const_complex_part): Remove.\n+\t(match_complex_part): Use match_{real,integer}_const.\n+\t(match_complex_constant): Cross-promote integer types.\n+\n 2005-01-23  James A. Morrison  <phython@gcc.gnu.org>\n \n \tPR fortran/19294"}, {"sha": "924eea0fb2fd5ec5a0901daa030a6e2f76cf2773", "filename": "gcc/fortran/arith.c", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69029c61aa94cec4fb273dcfc7693f754d9b4452/gcc%2Ffortran%2Farith.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69029c61aa94cec4fb273dcfc7693f754d9b4452/gcc%2Ffortran%2Farith.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farith.c?ref=69029c61aa94cec4fb273dcfc7693f754d9b4452", "patch": "@@ -1928,15 +1928,9 @@ gfc_expr *\n gfc_convert_real (const char *buffer, int kind, locus * where)\n {\n   gfc_expr *e;\n-  const char *t;\n \n   e = gfc_constant_result (BT_REAL, kind, where);\n-  /* A leading plus is allowed in Fortran, but not by mpfr_set_str */\n-  if (buffer[0] == '+')\n-    t = buffer + 1;\n-  else\n-    t = buffer;\n-  mpfr_set_str (e->value.real, t, 10, GFC_RND_MODE);\n+  mpfr_set_str (e->value.real, buffer, 10, GFC_RND_MODE);\n \n   return e;\n }"}, {"sha": "a2d1d1f5004fa3842dd51ebd572b29289997f660", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 51, "deletions": 166, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69029c61aa94cec4fb273dcfc7693f754d9b4452/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69029c61aa94cec4fb273dcfc7693f754d9b4452/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=69029c61aa94cec4fb273dcfc7693f754d9b4452", "patch": "@@ -144,6 +144,7 @@ match_digits (int signflag, int radix, char *buffer)\n     {\n       if (buffer != NULL)\n \t*buffer++ = c;\n+      gfc_gobble_whitespace ();\n       c = gfc_next_char ();\n       length++;\n     }\n@@ -329,7 +330,8 @@ match_boz_constant (gfc_expr ** result)\n }\n \n \n-/* Match a real constant of some sort.  */\n+/* Match a real constant of some sort.  Allow a signed constant if signflag\n+   is nonzero.  Allow integer constants if allow_int is true.  */\n \n static match\n match_real_constant (gfc_expr ** result, int signflag)\n@@ -338,6 +340,7 @@ match_real_constant (gfc_expr ** result, int signflag)\n   locus old_loc, temp_loc;\n   char *p, *buffer;\n   gfc_expr *e;\n+  bool negate;\n \n   old_loc = gfc_current_locus;\n   gfc_gobble_whitespace ();\n@@ -348,12 +351,16 @@ match_real_constant (gfc_expr ** result, int signflag)\n   seen_dp = 0;\n   seen_digits = 0;\n   exp_char = ' ';\n+  negate = FALSE;\n \n   c = gfc_next_char ();\n   if (signflag && (c == '+' || c == '-'))\n     {\n+      if (c == '-')\n+\tnegate = TRUE;\n+\n+      gfc_gobble_whitespace ();\n       c = gfc_next_char ();\n-      count++;\n     }\n \n   /* Scan significand.  */\n@@ -392,7 +399,8 @@ match_real_constant (gfc_expr ** result, int signflag)\n       break;\n     }\n \n-  if (!seen_digits || (c != 'e' && c != 'd' && c != 'q'))\n+  if (!seen_digits\n+      || (c != 'e' && c != 'd' && c != 'q'))\n     goto done;\n   exp_char = c;\n \n@@ -408,13 +416,6 @@ match_real_constant (gfc_expr ** result, int signflag)\n \n   if (!ISDIGIT (c))\n     {\n-      /* TODO: seen_digits is always true at this point */\n-      if (!seen_digits)\n-\t{\n-\t  gfc_current_locus = old_loc;\n-\t  return MATCH_NO;\t/* \".e\" can be something else */\n-\t}\n-\n       gfc_error (\"Missing exponent in real number at %C\");\n       return MATCH_ERROR;\n     }\n@@ -426,7 +427,7 @@ match_real_constant (gfc_expr ** result, int signflag)\n     }\n \n done:\n-  /* See what we've got!  */\n+  /* Check that we have a numeric constant.  */\n   if (!seen_digits || (!seen_dp && exp_char == ' '))\n     {\n       gfc_current_locus = old_loc;\n@@ -440,15 +441,26 @@ match_real_constant (gfc_expr ** result, int signflag)\n   buffer = alloca (count + 1);\n   memset (buffer, '\\0', count + 1);\n \n-  /* Hack for mpfr_set_str().  */\n   p = buffer;\n-  while (count > 0)\n+  c = gfc_next_char ();\n+  if (c == '+' || c == '-')\n     {\n-      *p = gfc_next_char ();\n-      if (*p == 'd' || *p == 'q')\n+      gfc_gobble_whitespace ();\n+      c = gfc_next_char ();\n+    }\n+\n+  /* Hack for mpfr_set_str().  */\n+  for (;;)\n+    {\n+      if (c == 'd' || c == 'q')\n \t*p = 'e';\n+      else\n+\t*p = c;\n       p++;\n-      count--;\n+      if (--count == 0)\n+\tbreak;\n+\n+      c = gfc_next_char ();\n     }\n \n   kind = get_kind ();\n@@ -489,6 +501,8 @@ match_real_constant (gfc_expr ** result, int signflag)\n     }\n \n   e = gfc_convert_real (buffer, kind, &gfc_current_locus);\n+  if (negate)\n+    mpfr_neg (e->value.real, e->value.real, GFC_RND_MODE);\n \n   switch (gfc_range_check (e))\n     {\n@@ -994,152 +1008,6 @@ match_sym_complex_part (gfc_expr ** result)\n }\n \n \n-/* Match the real and imaginary parts of a complex number.  This\n-   subroutine is essentially match_real_constant() modified in a\n-   couple of ways: A sign is always allowed and numbers that would\n-   look like an integer to match_real_constant() are automatically\n-   created as floating point numbers.  The messiness involved with\n-   making sure a decimal point belongs to the number and not a\n-   trailing operator is not necessary here either (Hooray!).  */\n-\n-static match\n-match_const_complex_part (gfc_expr ** result)\n-{\n-  int kind, seen_digits, seen_dp, count;\n-  char *p, c, exp_char, *buffer;\n-  locus old_loc;\n-\n-  old_loc = gfc_current_locus;\n-  gfc_gobble_whitespace ();\n-\n-  seen_dp = 0;\n-  seen_digits = 0;\n-  count = 0;\n-  exp_char = ' ';\n-\n-  c = gfc_next_char ();\n-  if (c == '-' || c == '+')\n-    {\n-      c = gfc_next_char ();\n-      count++;\n-    }\n-\n-  for (;; c = gfc_next_char (), count++)\n-    {\n-      if (c == '.')\n-\t{\n-\t  if (seen_dp)\n-\t    goto no_match;\n-\t  seen_dp = 1;\n-\t  continue;\n-\t}\n-\n-      if (ISDIGIT (c))\n-\t{\n-\t  seen_digits = 1;\n-\t  continue;\n-\t}\n-\n-      break;\n-    }\n-\n-  if (!seen_digits || (c != 'd' && c != 'e'))\n-    goto done;\n-  exp_char = c;\n-\n-  /* Scan exponent.  */\n-  c = gfc_next_char ();\n-  count++;\n-\n-  if (c == '+' || c == '-')\n-    {\t\t\t\t/* optional sign */\n-      c = gfc_next_char ();\n-      count++;\n-    }\n-\n-  if (!ISDIGIT (c))\n-    {\n-      gfc_error (\"Missing exponent in real number at %C\");\n-      return MATCH_ERROR;\n-    }\n-\n-  while (ISDIGIT (c))\n-    {\n-      c = gfc_next_char ();\n-      count++;\n-    }\n-\n-done:\n-  if (!seen_digits)\n-    goto no_match;\n-\n-  /* Convert the number.  */\n-  gfc_current_locus = old_loc;\n-  gfc_gobble_whitespace ();\n-\n-  buffer = alloca (count + 1);\n-  memset (buffer, '\\0', count + 1);\n-\n-  /* Hack for mpfr_set_str().  */\n-  p = buffer;\n-  while (count > 0)\n-    {\n-      c = gfc_next_char ();\n-      if (c == 'd' || c == 'q')\n-\tc = 'e';\n-      *p++ = c;\n-      count--;\n-    }\n-\n-  *p = '\\0';\n-\n-  kind = get_kind ();\n-  if (kind == -1)\n-    return MATCH_ERROR;\n-\n-  /* If the number looked like an integer, forget about a kind we may\n-     have seen, otherwise validate the kind against real kinds.  */\n-  if (seen_dp == 0 && exp_char == ' ')\n-    {\n-      if (kind == -2)\n-\tkind = gfc_default_integer_kind;\n-\n-    }\n-  else\n-    {\n-      if (exp_char == 'd')\n-\t{\n-\t  if (kind != -2)\n-\t    {\n-\t      gfc_error\n-\t\t(\"Real number at %C has a 'd' exponent and an explicit kind\");\n-\t      return MATCH_ERROR;\n-\t    }\n-\t  kind = gfc_default_double_kind;\n-\n-\t}\n-      else\n-\t{\n-\t  if (kind == -2)\n-\t    kind = gfc_default_real_kind;\n-\t}\n-\n-      if (gfc_validate_kind (BT_REAL, kind, true) < 0)\n-\t{\n-\t  gfc_error (\"Invalid real kind %d at %C\", kind);\n-\t  return MATCH_ERROR;\n-\t}\n-    }\n-\n-  *result = gfc_convert_real (buffer, kind, &gfc_current_locus);\n-  return MATCH_YES;\n-\n-no_match:\n-  gfc_current_locus = old_loc;\n-  return MATCH_NO;\n-}\n-\n-\n /* Match a real or imaginary part of a complex number.  */\n \n static match\n@@ -1151,7 +1019,11 @@ match_complex_part (gfc_expr ** result)\n   if (m != MATCH_NO)\n     return m;\n \n-  return match_const_complex_part (result);\n+  m = match_real_constant (result, 1);\n+  if (m != MATCH_NO)\n+    return m;\n+\n+  return match_integer_constant (result, 1);\n }\n \n \n@@ -1210,13 +1082,26 @@ match_complex_constant (gfc_expr ** result)\n     goto cleanup;\n \n   /* Decide on the kind of this complex number.  */\n-  kind = gfc_kind_max (real, imag);\n+  if (real->ts.type == BT_REAL)\n+    {\n+      if (imag->ts.type == BT_REAL)\n+\tkind = gfc_kind_max (real, imag);\n+      else\n+\tkind = real->ts.kind;\n+    }\n+  else\n+    {\n+      if (imag->ts.type == BT_REAL)\n+\tkind = imag->ts.kind;\n+      else\n+\tkind = gfc_default_real_kind;\n+    }\n   target.type = BT_REAL;\n   target.kind = kind;\n \n-  if (kind != real->ts.kind)\n+  if (real->ts.type != BT_REAL || kind != real->ts.kind)\n     gfc_convert_type (real, &target, 2);\n-  if (kind != imag->ts.kind)\n+  if (imag->ts.type != BT_REAL || kind != imag->ts.kind)\n     gfc_convert_type (imag, &target, 2);\n \n   e = gfc_convert_complex (real, imag, kind);"}, {"sha": "bb6cc256323a8c5d43141dcb2a74f2a3c7e1342a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69029c61aa94cec4fb273dcfc7693f754d9b4452/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69029c61aa94cec4fb273dcfc7693f754d9b4452/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=69029c61aa94cec4fb273dcfc7693f754d9b4452", "patch": "@@ -1,3 +1,11 @@\n+2004-01-23  Steven G. Kargl  <kargls@comcast.net>\n+\tPaul Brook  <paul@codesourcery.com>\n+\n+\tPR fortran/17941\n+\t* gfortran.dg/real_const_1.f: New test.\n+\t* gfortran.dg/real_const_2.f90: New test.\n+\t* gfortran.dg/complex_int_1.f90: New test.\n+\n 2005-01-23  Bud Davis  <bdavis9659@comcast.net>\n \n \tPR fortran/19313"}, {"sha": "f287d8cd6bb715c1768b16918ef83a70944261fb", "filename": "gcc/testsuite/gfortran.dg/complex_int_1.f90", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69029c61aa94cec4fb273dcfc7693f754d9b4452/gcc%2Ftestsuite%2Fgfortran.dg%2Fcomplex_int_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69029c61aa94cec4fb273dcfc7693f754d9b4452/gcc%2Ftestsuite%2Fgfortran.dg%2Fcomplex_int_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcomplex_int_1.f90?ref=69029c61aa94cec4fb273dcfc7693f754d9b4452", "patch": "@@ -0,0 +1,15 @@\n+! { dg-do compile }\n+! Complex constants with integer components should take ther kind from\n+! the real typed component, or default complex type if both components have\n+! integer type.\n+program prog\n+  call test1 ((1_8, 1.0_4))\n+  call test2 ((1_8, 2_8))\n+contains\n+subroutine test1(x)\n+  complex(4) :: x\n+end subroutine\n+subroutine test2(x)\n+  complex :: x\n+end subroutine\n+end program"}, {"sha": "97b7f278b87ae5f3cbd481add82cbbf78d52eb2c", "filename": "gcc/testsuite/gfortran.dg/real_const_1.f", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69029c61aa94cec4fb273dcfc7693f754d9b4452/gcc%2Ftestsuite%2Fgfortran.dg%2Freal_const_1.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69029c61aa94cec4fb273dcfc7693f754d9b4452/gcc%2Ftestsuite%2Fgfortran.dg%2Freal_const_1.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Freal_const_1.f?ref=69029c61aa94cec4fb273dcfc7693f754d9b4452", "patch": "@@ -0,0 +1,24 @@\n+c { dg-do run }\n+c\n+c Fixed form test program for PR 17941 (signed constants with spaces)\n+c\n+      program real_const_1\n+      complex c0, c1, c2, c3, c4\n+      real rp(4), rn(4)\n+      parameter (c0 = (-0.5, -     0.5))\n+      parameter (c1 = (-     0.5, +     0.5))\n+      parameter (c2 = (-    0.5E2, +0.5))\n+      parameter (c3 = (-0.5, +     0.5E-2))\n+      parameter (c4 = (-     1, +     1))\n+      data rn /- 1.0, - 1d0, - 1.d0, - 10.d-1/\n+      data rp /+ 1.0, + 1d0, + 1.d0, + 10.d-1/\n+      real, parameter :: del = 1.e-5\n+\n+      if (abs(c0 - cmplx(-0.5,-0.5)) > del) call abort\n+      if (abs(c1 - cmplx(-0.5,+0.5)) > del) call abort\n+      if (abs(c2 - cmplx(-0.5E2,+0.5)) > del) call abort\n+      if (abs(c3 - cmplx(-0.5,+0.5E-2)) > del) call abort\n+      if (abs(c4 - cmplx(-1.0,+1.0)) > del) call abort\n+      if (any (abs (rp - 1.0) > del)) call abort\n+      if (any (abs (rn + 1.0) > del)) call abort\n+      end program"}, {"sha": "552012e37b4a02ef589d4fb2f5300ec729a76101", "filename": "gcc/testsuite/gfortran.dg/real_const_2.f90", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69029c61aa94cec4fb273dcfc7693f754d9b4452/gcc%2Ftestsuite%2Fgfortran.dg%2Freal_const_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69029c61aa94cec4fb273dcfc7693f754d9b4452/gcc%2Ftestsuite%2Fgfortran.dg%2Freal_const_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Freal_const_2.f90?ref=69029c61aa94cec4fb273dcfc7693f754d9b4452", "patch": "@@ -0,0 +1,24 @@\n+! { dg-do run }\n+!\n+! Free form test program for PR 17941 (signed constants with spaces)\n+!\n+program real_const_2\n+  complex c0, c1, c2, c3, c4\n+  real rp(4), rn(4)\n+  parameter (c0 = (-0.5, -     0.5))\n+  parameter (c1 = (-     0.5, +     0.5))\n+  parameter (c2 = (-    0.5E2, +0.5))\n+  parameter (c3 = (-0.5, +     0.5E-2))\n+  parameter (c4 = (-     1, +     1))\n+  data rn /- 1.0, - 1d0, - 1.d0, - 10.d-1/\n+  data rp /+ 1.0, + 1d0, + 1.d0, + 10.d-1/\n+  real, parameter :: del = 1.e-5\n+\n+  if (abs(c0 - cmplx(-0.5,-0.5)) > del) call abort\n+  if (abs(c1 - cmplx(-0.5,+0.5)) > del) call abort\n+  if (abs(c2 - cmplx(-0.5E2,+0.5)) > del) call abort\n+  if (abs(c3 - cmplx(-0.5,+0.5E-2)) > del) call abort\n+  if (abs(c4 - cmplx(-1.0,+1.0)) > del) call abort\n+  if (any (abs (rp - 1.0) > del)) call abort\n+  if (any (abs (rn + 1.0) > del)) call abort\n+end program"}]}