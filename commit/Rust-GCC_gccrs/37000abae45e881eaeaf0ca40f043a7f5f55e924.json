{"sha": "37000abae45e881eaeaf0ca40f043a7f5f55e924", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzcwMDBhYmFlNDVlODgxZWFlYWYwY2E0MGYwNDNhN2Y1ZjU1ZTkyNA==", "commit": {"author": {"name": "Quentin Ochem", "email": "ochem@adacore.com", "date": "2007-06-06T10:48:27Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-06-06T10:48:27Z"}, "message": "s-stausa.ads, [...] (Initialize_Analyzer): Added parameter \"Overflow_Guard\".\n\n2007-04-20  Quentin Ochem  <ochem@adacore.com>\n\n\t* s-stausa.ads, s-stausa.adb (Initialize_Analyzer): Added parameter\n\t\"Overflow_Guard\".\n\t(Stack_Analyzer): Added field \"Overflow_Guard\"\n\t(Task_Result): Added field \"Overflow_Guard\".\n\t(Index_Str): New constant.\n\t(Task_Name_Str): New constant.\n\t(Actual_Size_Str): New constant.\n\t(Pattern_Array_Element_Size): New constant.\n\t(Get_Usage_Range): New subprogram.\n\t(Output_Result): Added parameter Max_Size_Len and Max_Actual_Use_Len.\n\tNow align the output.\n\tAdded comments.\n\t(Initialize): Added value for Overflow_Guard.\n\t(Fill_Stack): Use constant Pattern_Array_Elem_Size when relevant.\n\tUpdate the value of the overflow guard according to the actual\n\tbeginning of the pattern array.\n\t(Initialize_Analyzer): Added parameter Overflow_Guard.\n\tTake this parameter into accound when computing the max size.\n\t(Compute_Result): Use constant Pattern_Array_Elem_Size when relevant.\n\t(Report_Result): Removed extra useless procedure.\n\tUpdated call to Output_Result.\n\tMoved full computation of the Task_Result here.\n\nFrom-SVN: r125465", "tree": {"sha": "2963334ac055814edeb34cd4e3bd54fdef906f92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2963334ac055814edeb34cd4e3bd54fdef906f92"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/37000abae45e881eaeaf0ca40f043a7f5f55e924", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37000abae45e881eaeaf0ca40f043a7f5f55e924", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37000abae45e881eaeaf0ca40f043a7f5f55e924", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37000abae45e881eaeaf0ca40f043a7f5f55e924/comments", "author": {"login": "QuentinOchem", "id": 5612750, "node_id": "MDQ6VXNlcjU2MTI3NTA=", "avatar_url": "https://avatars.githubusercontent.com/u/5612750?v=4", "gravatar_id": "", "url": "https://api.github.com/users/QuentinOchem", "html_url": "https://github.com/QuentinOchem", "followers_url": "https://api.github.com/users/QuentinOchem/followers", "following_url": "https://api.github.com/users/QuentinOchem/following{/other_user}", "gists_url": "https://api.github.com/users/QuentinOchem/gists{/gist_id}", "starred_url": "https://api.github.com/users/QuentinOchem/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/QuentinOchem/subscriptions", "organizations_url": "https://api.github.com/users/QuentinOchem/orgs", "repos_url": "https://api.github.com/users/QuentinOchem/repos", "events_url": "https://api.github.com/users/QuentinOchem/events{/privacy}", "received_events_url": "https://api.github.com/users/QuentinOchem/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1513f9bf9b1805fcff1c5afbfcfdf7baf6f8cb5a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1513f9bf9b1805fcff1c5afbfcfdf7baf6f8cb5a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1513f9bf9b1805fcff1c5afbfcfdf7baf6f8cb5a"}], "stats": {"total": 449, "additions": 308, "deletions": 141}, "files": [{"sha": "a76660dc6b9e260640ffc786c1fef53b73c33814", "filename": "gcc/ada/s-stausa.adb", "status": "modified", "additions": 256, "deletions": 92, "changes": 348, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37000abae45e881eaeaf0ca40f043a7f5f55e924/gcc%2Fada%2Fs-stausa.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37000abae45e881eaeaf0ca40f043a7f5f55e924/gcc%2Fada%2Fs-stausa.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-stausa.adb?ref=37000abae45e881eaeaf0ca40f043a7f5f55e924", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---         Copyright (C) 2004-2006, Free Software Foundation, Inc.          --\n+--         Copyright (C) 2004-2007, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,24 +39,42 @@ package body System.Stack_Usage is\n    use System.Storage_Elements;\n    use System;\n    use System.IO;\n-\n-   procedure Output_Result (Result_Id : Natural; Result : Task_Result);\n-\n-   function Report_Result (Analyzer : Stack_Analyzer) return Natural;\n-\n-   function Inner_Than\n+   use Interfaces;\n+\n+   Index_Str               : constant String  := \"Index\";\n+   Task_Name_Str           : constant String  := \"Task Name\";\n+   Stack_Size_Str          : constant String  := \"Stack Size\";\n+   Actual_Size_Str         : constant String  := \"Stack usage [min - max]\";\n+   Pattern_Array_Elem_Size : constant Natural :=\n+                               (Unsigned_32_Size / Byte_Size);\n+\n+   function Get_Usage_Range (Result : Task_Result) return String;\n+   --  Return string representing the range of possible result of stack usage\n+\n+   procedure Output_Result\n+     (Result_Id          : Natural;\n+      Result             : Task_Result;\n+      Max_Stack_Size_Len : Natural;\n+      Max_Actual_Use_Len : Natural);\n+   --  Prints the result on the standard output. Result Id is the number of\n+   --  the result in the array, and Result the contents of the actual result.\n+   --  Max_Stack_Size_Len and Max_Actual_Use_Len are used for displaying the\n+   --  proper layout. They hold the maximum length of the string representing\n+   --  the Stack_Size and Actual_Use values.\n+\n+   function Closer_To_Bottom\n      (A1 : Stack_Address;\n       A2 : Stack_Address) return Boolean;\n-   pragma Inline (Inner_Than);\n+   pragma Inline (Closer_To_Bottom);\n    --  Return True if, according to the direction of the stack growth, A1 is\n-   --  inner than A2. Inlined to reduce the size of the stack used by the\n-   --  instrumentation code.\n+   --  closer to the bottom than A2. Inlined to reduce the size of the stack\n+   --  used by the instrumentation code.\n \n-   ----------------\n-   -- Inner_Than --\n-   ----------------\n+   ----------------------\n+   -- Closer_To_Bottom --\n+   ----------------------\n \n-   function Inner_Than\n+   function Closer_To_Bottom\n      (A1 : Stack_Address;\n       A2 : Stack_Address) return Boolean\n    is\n@@ -66,27 +84,29 @@ package body System.Stack_Usage is\n       else\n          return A2 > A1;\n       end if;\n-   end Inner_Than;\n+   end Closer_To_Bottom;\n \n    ----------------\n    -- Initialize --\n    ----------------\n \n-   --  Add comments to this procedure ???\n-   --  Other subprograms also need more comment in code???\n-\n    procedure Initialize (Buffer_Size : Natural) is\n-      Bottom_Of_Stack : aliased Integer;\n-\n+      Bottom_Of_Stack  : aliased Integer;\n       Stack_Size_Chars : System.Address;\n+\n    begin\n+      --  Initialize the buffered result array\n+\n       Result_Array := new Result_Array_Type (1 .. Buffer_Size);\n       Result_Array.all :=\n         (others =>\n-           (Task_Name =>\n-              (others => ASCII.NUL),\n-            Measure => 0,\n-            Max_Size => 0));\n+           (Task_Name      => (others => ASCII.NUL),\n+            Measure        => 0,\n+            Max_Size       => 0,\n+            Overflow_Guard => 0));\n+\n+      --  Set the Is_Enabled flag to true, so that the task wrapper knows that\n+      --  it has to handle dynamic stack analysis\n \n       Is_Enabled := True;\n \n@@ -104,11 +124,12 @@ package body System.Stack_Usage is\n          begin\n             Stack_Size := System.CRTL.atoi (Stack_Size_Chars) * 1024;\n \n-            Initialize_Analyzer (Environment_Task_Analyzer,\n-                                 \"ENVIRONMENT TASK\",\n-                                 Stack_Size,\n-                                 System.Storage_Elements.To_Integer\n-                                   (Bottom_Of_Stack'Address));\n+            Initialize_Analyzer\n+              (Environment_Task_Analyzer,\n+               \"ENVIRONMENT TASK\",\n+               Stack_Size,\n+               0,\n+               System.Storage_Elements.To_Integer (Bottom_Of_Stack'Address));\n \n             Fill_Stack (Environment_Task_Analyzer);\n \n@@ -133,64 +154,75 @@ package body System.Stack_Usage is\n       --  big, the more an \"instrumentation threshold at writing\" error is\n       --  likely to happen.\n \n-      type Word_32_Arr is\n-        array (1 .. Analyzer.Size / (Word_32_Size / Byte_Size)) of Word_32;\n-      pragma Pack (Word_32_Arr);\n+      type Unsigned_32_Arr is\n+        array (1 .. Analyzer.Size / Pattern_Array_Elem_Size) of Unsigned_32;\n+      for Unsigned_32_Arr'Component_Size use 32;\n \n       package Arr_Addr is\n-        new System.Address_To_Access_Conversions (Word_32_Arr);\n+        new System.Address_To_Access_Conversions (Unsigned_32_Arr);\n \n-      Arr : aliased Word_32_Arr;\n+      Arr : aliased Unsigned_32_Arr;\n \n    begin\n-      for J in Word_32_Arr'Range loop\n+      --  Fill the stack with the pattern\n+\n+      for J in Unsigned_32_Arr'Range loop\n          Arr (J) := Analyzer.Pattern;\n       end loop;\n+\n+      --  Initialize the analyzer value\n+\n       Analyzer.Array_Address := Arr_Addr.To_Address (Arr'Access);\n-      Analyzer.Inner_Pattern_Mark := To_Stack_Address (Arr (1)'Address);\n-      Analyzer.Outer_Pattern_Mark :=\n-        To_Stack_Address (Arr (Word_32_Arr'Last)'Address);\n-\n-      if Inner_Than (Analyzer.Outer_Pattern_Mark,\n-                     Analyzer.Inner_Pattern_Mark) then\n-         Analyzer.Inner_Pattern_Mark := Analyzer.Outer_Pattern_Mark;\n-         Analyzer.Outer_Pattern_Mark := To_Stack_Address (Arr (1)'Address);\n-         Analyzer.First_Is_Outermost := True;\n+      Analyzer.Bottom_Pattern_Mark := To_Stack_Address (Arr (1)'Address);\n+      Analyzer.Top_Pattern_Mark :=\n+        To_Stack_Address (Arr (Unsigned_32_Arr'Last)'Address);\n+\n+      if\n+        Closer_To_Bottom\n+          (Analyzer.Top_Pattern_Mark, Analyzer.Bottom_Pattern_Mark)\n+      then\n+         Analyzer.Bottom_Pattern_Mark := Analyzer.Top_Pattern_Mark;\n+         Analyzer.Top_Pattern_Mark := To_Stack_Address (Arr (1)'Address);\n+         Analyzer.First_Is_Topmost := True;\n       else\n-         Analyzer.First_Is_Outermost := False;\n+         Analyzer.First_Is_Topmost := False;\n       end if;\n \n       --  If Arr has been packed, the following assertion must be true (we add\n       --  the size of the element whose address is:\n-      --\n       --    Min (Analyzer.Inner_Pattern_Mark, Analyzer.Outer_Pattern_Mark)):\n \n       pragma Assert\n         (Analyzer.Size =\n            Stack_Size\n-             (Analyzer.Outer_Pattern_Mark, Analyzer.Inner_Pattern_Mark) +\n-           Word_32_Size / Byte_Size);\n+             (Analyzer.Top_Pattern_Mark, Analyzer.Bottom_Pattern_Mark));\n    end Fill_Stack;\n \n    -------------------------\n    -- Initialize_Analyzer --\n    -------------------------\n \n    procedure Initialize_Analyzer\n-     (Analyzer  : in out Stack_Analyzer;\n-      Task_Name : String;\n-      Size      : Natural;\n-      Bottom    : Stack_Address;\n-      Pattern   : Word_32 := 16#DEAD_BEEF#)\n+     (Analyzer       : in out Stack_Analyzer;\n+      Task_Name      : String;\n+      Size           : Natural;\n+      Overflow_Guard : Natural;\n+      Bottom         : Stack_Address;\n+      Pattern        : Unsigned_32 := 16#DEAD_BEEF#)\n    is\n    begin\n+      --  Initialize the analyzer fields\n+\n       Analyzer.Bottom_Of_Stack := Bottom;\n       Analyzer.Size := Size;\n       Analyzer.Pattern := Pattern;\n       Analyzer.Result_Id := Next_Id;\n \n       Analyzer.Task_Name := (others => ' ');\n \n+      --  Compute the task name, and truncate it if it's bigger than\n+      --  Task_Name_Length\n+\n       if Task_Name'Length <= Task_Name_Length then\n          Analyzer.Task_Name (1 .. Task_Name'Length) := Task_Name;\n       else\n@@ -199,11 +231,8 @@ package body System.Stack_Usage is\n                         Task_Name'First + Task_Name_Length - 1);\n       end if;\n \n-      if Next_Id in Result_Array'Range then\n-         Result_Array (Analyzer.Result_Id).Task_Name := Analyzer.Task_Name;\n-      end if;\n+      Analyzer.Overflow_Guard := Overflow_Guard;\n \n-      Result_Array (Analyzer.Result_Id).Max_Size := Size;\n       Next_Id := Next_Id + 1;\n    end Initialize_Analyzer;\n \n@@ -234,45 +263,81 @@ package body System.Stack_Usage is\n       --  is, the more an \"instrumentation threshold at reading\" error is\n       --  likely to happen.\n \n-      type Word_32_Arr is\n-        array (1 .. Analyzer.Size / (Word_32_Size / Byte_Size)) of Word_32;\n-      pragma Pack (Word_32_Arr);\n+      type Unsigned_32_Arr is\n+        array (1 .. Analyzer.Size / Pattern_Array_Elem_Size) of Unsigned_32;\n+      for Unsigned_32_Arr'Component_Size use 32;\n \n       package Arr_Addr is\n-        new System.Address_To_Access_Conversions (Word_32_Arr);\n+        new System.Address_To_Access_Conversions (Unsigned_32_Arr);\n \n       Arr_Access : Arr_Addr.Object_Pointer;\n \n    begin\n       Arr_Access := Arr_Addr.To_Pointer (Analyzer.Array_Address);\n-      Analyzer.Outermost_Touched_Mark := Analyzer.Inner_Pattern_Mark;\n+      Analyzer.Topmost_Touched_Mark := Analyzer.Bottom_Pattern_Mark;\n+\n+      --  Look backward from the end of the stack to the beginning. The first\n+      --  index not equals to the patterns marks the beginning of the used\n+      --  stack.\n \n-      for J in Word_32_Arr'Range loop\n+      for J in Unsigned_32_Arr'Range loop\n          if Arr_Access (J) /= Analyzer.Pattern then\n-            Analyzer.Outermost_Touched_Mark :=\n+            Analyzer.Topmost_Touched_Mark :=\n               To_Stack_Address (Arr_Access (J)'Address);\n \n-            if Analyzer.First_Is_Outermost then\n+            if Analyzer.First_Is_Topmost then\n                exit;\n             end if;\n          end if;\n       end loop;\n    end Compute_Result;\n \n+   ---------------------\n+   -- Get_Usage_Range --\n+   ---------------------\n+\n+   function Get_Usage_Range (Result : Task_Result) return String is\n+      Min_Used_Str : constant String :=\n+                       Natural'Image (Result.Measure);\n+      Max_Used_Str : constant String :=\n+                       Natural'Image (Result.Measure + Result.Overflow_Guard);\n+   begin\n+      return \"[\" & Min_Used_Str (2 .. Min_Used_Str'Last) & \" -\"\n+        & Max_Used_Str & \"]\";\n+   end Get_Usage_Range;\n+\n    ---------------------\n    --  Output_Result --\n    ---------------------\n \n-   procedure Output_Result (Result_Id : Natural; Result : Task_Result) is\n+   procedure Output_Result\n+     (Result_Id          : Natural;\n+      Result             : Task_Result;\n+      Max_Stack_Size_Len : Natural;\n+      Max_Actual_Use_Len : Natural)\n+   is\n+      Result_Id_Str  : constant String := Natural'Image (Result_Id);\n+      Stack_Size_Str : constant String := Natural'Image (Result.Max_Size);\n+      Actual_Use_Str : constant String := Get_Usage_Range (Result);\n+\n+      Result_Id_Blanks  : constant\n+        String (1 .. Index_Str'Length - Result_Id_Str'Length)    :=\n+          (others => ' ');\n+      Stack_Size_Blanks : constant\n+        String (1 .. Max_Stack_Size_Len - Stack_Size_Str'Length) :=\n+          (others => ' ');\n+      Actual_Use_Blanks : constant\n+        String (1 .. Max_Actual_Use_Len - Actual_Use_Str'Length) :=\n+          (others => ' ');\n    begin\n       Set_Output (Standard_Error);\n-      Put (Natural'Image (Result_Id));\n+      Put (Result_Id_Blanks & Natural'Image (Result_Id));\n       Put (\" | \");\n       Put (Result.Task_Name);\n       Put (\" | \");\n-      Put (Natural'Image (Result.Max_Size));\n+      Put (Stack_Size_Blanks & Stack_Size_Str);\n       Put (\" | \");\n-      Put (Natural'Image (Result.Measure));\n+      Put (Actual_Use_Blanks & Actual_Use_Str);\n       New_Line;\n    end Output_Result;\n \n@@ -281,49 +346,148 @@ package body System.Stack_Usage is\n    ---------------------\n \n    procedure Output_Results is\n+      Max_Stack_Size                         : Natural := 0;\n+      Max_Actual_Use_Result_Id               : Natural := Result_Array'First;\n+      Max_Stack_Size_Len, Max_Actual_Use_Len : Natural := 0;\n+\n+      Task_Name_Blanks :\n+        constant String (1 .. Task_Name_Length - Task_Name_Str'Length) :=\n+          (others => ' ');\n    begin\n+      Set_Output (Standard_Error);\n+\n       if Compute_Environment_Task then\n          Compute_Result (Environment_Task_Analyzer);\n          Report_Result (Environment_Task_Analyzer);\n       end if;\n \n-      Set_Output (Standard_Error);\n-      Put (\"Index | Task Name | Stack Size | Actual Use\");\n-      New_Line;\n+      if Result_Array'Length > 0 then\n+         --  Computes the size of the largest strings that will get displayed,\n+         --  in order to do correct column alignment.\n \n-      for J in Result_Array'Range loop\n-         exit when J >= Next_Id;\n+         for J in Result_Array'Range loop\n+            exit when J >= Next_Id;\n \n-         Output_Result (J, Result_Array (J));\n-      end loop;\n+            if Result_Array (J).Measure\n+              > Result_Array (Max_Actual_Use_Result_Id).Measure\n+            then\n+               Max_Actual_Use_Result_Id := J;\n+            end if;\n+\n+            if Result_Array (J).Max_Size > Max_Stack_Size then\n+               Max_Stack_Size := Result_Array (J).Max_Size;\n+            end if;\n+         end loop;\n+\n+         Max_Stack_Size_Len := Natural'Image (Max_Stack_Size)'Length;\n+\n+         Max_Actual_Use_Len :=\n+           Get_Usage_Range (Result_Array (Max_Actual_Use_Result_Id))'Length;\n+\n+         --  Display the output header. Blanks will be added in front of the\n+         --  labels if needed.\n+\n+         declare\n+            Stack_Size_Blanks  : constant\n+              String (1 .. Max_Stack_Size_Len - Stack_Size_Str'Length) :=\n+              (others => ' ');\n+            Stack_Usage_Blanks : constant\n+              String (1 .. Max_Actual_Use_Len - Actual_Size_Str'Length) :=\n+              (others => ' ');\n+\n+         begin\n+            if Stack_Size_Str'Length > Max_Stack_Size_Len then\n+               Max_Stack_Size_Len := Stack_Size_Str'Length;\n+            end if;\n+\n+            if Actual_Size_Str'Length > Max_Actual_Use_Len then\n+               Max_Actual_Use_Len := Actual_Size_Str'Length;\n+            end if;\n+\n+            Put\n+              (Index_Str & \" | \" & Task_Name_Str & Task_Name_Blanks & \" | \"\n+               & Stack_Size_Str & Stack_Size_Blanks & \" | \"\n+               & Stack_Usage_Blanks & Actual_Size_Str);\n+         end;\n+\n+         New_Line;\n+\n+         --  Now display the individual results\n+\n+         for J in Result_Array'Range loop\n+            exit when J >= Next_Id;\n+            Output_Result\n+              (J, Result_Array (J), Max_Stack_Size_Len, Max_Actual_Use_Len);\n+         end loop;\n+      else\n+         --  If there are no result stored, we'll still display the labels\n+\n+         Put\n+           (Index_Str & \" | \" & Task_Name_Str & Task_Name_Blanks & \" | \"\n+            & Stack_Size_Str & \" | \" & Actual_Size_Str);\n+         New_Line;\n+      end if;\n    end Output_Results;\n \n    -------------------\n    -- Report_Result --\n    -------------------\n \n    procedure Report_Result (Analyzer : Stack_Analyzer) is\n+      Result : constant Task_Result :=\n+        (Task_Name      => Analyzer.Task_Name,\n+         Max_Size       => Analyzer.Size + Analyzer.Overflow_Guard,\n+         Measure        => Stack_Size\n+                             (Analyzer.Topmost_Touched_Mark,\n+                              Analyzer.Bottom_Of_Stack),\n+         Overflow_Guard => Analyzer.Overflow_Guard -\n+                             Natural (Analyzer.Bottom_Of_Stack -\n+                               Analyzer.Bottom_Pattern_Mark));\n    begin\n       if Analyzer.Result_Id in Result_Array'Range then\n-         Result_Array (Analyzer.Result_Id).Measure := Report_Result (Analyzer);\n-      else\n-         Output_Result\n-           (Analyzer.Result_Id,\n-            (Task_Name => Analyzer.Task_Name,\n-             Max_Size  => Analyzer.Size,\n-             Measure   => Report_Result (Analyzer)));\n-      end if;\n-   end Report_Result;\n \n-   function Report_Result (Analyzer : Stack_Analyzer) return Natural is\n-   begin\n-      if Analyzer.Outermost_Touched_Mark = Analyzer.Inner_Pattern_Mark then\n-         return Stack_Size (Analyzer.Inner_Pattern_Mark,\n-                            Analyzer.Bottom_Of_Stack);\n+         --  If the result can be stored, then store it in Result_Array\n+\n+         Result_Array (Analyzer.Result_Id) := Result;\n \n       else\n-         return Stack_Size (Analyzer.Outermost_Touched_Mark,\n-                            Analyzer.Bottom_Of_Stack);\n+\n+         --  If the result cannot be stored, then we display it right away\n+\n+         declare\n+            Result_Str_Len : constant Natural :=\n+                               Get_Usage_Range (Result)'Length;\n+            Size_Str_Len   : constant Natural :=\n+                               Natural'Image (Analyzer.Size)'Length;\n+\n+            Max_Stack_Size_Len : Natural;\n+            Max_Actual_Use_Len : Natural;\n+\n+         begin\n+            --  Take either the label size or the number image size for the\n+            --  size of the column \"Stack Size\".\n+\n+            if Size_Str_Len > Stack_Size_Str'Length then\n+               Max_Stack_Size_Len := Size_Str_Len;\n+            else\n+               Max_Stack_Size_Len := Stack_Size_Str'Length;\n+            end if;\n+\n+            --  Take either the label size or the number image size for the\n+            --  size of the column \"Stack Usage\"\n+\n+            if Result_Str_Len > Actual_Size_Str'Length then\n+               Max_Actual_Use_Len := Result_Str_Len;\n+            else\n+               Max_Actual_Use_Len := Actual_Size_Str'Length;\n+            end if;\n+\n+            Output_Result\n+              (Analyzer.Result_Id,\n+               Result,\n+               Max_Stack_Size_Len,\n+               Max_Actual_Use_Len);\n+         end;\n       end if;\n    end Report_Result;\n "}, {"sha": "436988eccf55c45d54cca9d47855713adb72f7c2", "filename": "gcc/ada/s-stausa.ads", "status": "modified", "additions": 52, "deletions": 49, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37000abae45e881eaeaf0ca40f043a7f5f55e924/gcc%2Fada%2Fs-stausa.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37000abae45e881eaeaf0ca40f043a7f5f55e924/gcc%2Fada%2Fs-stausa.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-stausa.ads?ref=37000abae45e881eaeaf0ca40f043a7f5f55e924", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---         Copyright (C) 2004-2005, Free Software Foundation, Inc.          --\n+--         Copyright (C) 2004-2007, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -34,32 +34,26 @@\n with System;\n with System.Storage_Elements;\n with System.Address_To_Access_Conversions;\n+with Interfaces;\n \n package System.Stack_Usage is\n    pragma Preelaborate;\n \n    package SSE renames System.Storage_Elements;\n \n    Byte_Size : constant := 8;\n-   Word_32_Size : constant := 4 * Byte_Size;\n+   Unsigned_32_Size : constant := 4 * Byte_Size;\n \n-   type Word_32 is mod 2 ** Word_32_Size;\n-   for Word_32'Alignment use 4;\n+   --  The alignment clause seems dubious, what about architectures where\n+   --  the maximum alignment is less than 4???\n+   --  Anyway, why not use Interfaces.Unsigned_32???\n \n    subtype Stack_Address is SSE.Integer_Address;\n    --  Address on the stack\n-   --\n-   --  Note: in this package, when comparing two addresses on the stack, the\n-   --  comments use the terms \"outer\", \"inner\", \"outermost\" and \"innermost\"\n-   --  instead of the ambigous \"higher\", \"lower\", \"highest\" and \"lowest\".\n-   --  \"inner\" means \"closer to the bottom of stack\" and is the contrary of\n-   --  \"outer\". \"innermost\" means \"closest address to the bottom of stack\". The\n-   --  stack is growing from the inner to the outer.\n-\n-   --  Top/Bottom would be much better than inner and outer ???\n \n-   function To_Stack_Address (Value : System.Address) return Stack_Address\n-                              renames System.Storage_Elements.To_Integer;\n+   function To_Stack_Address\n+     (Value : System.Address) return Stack_Address\n+      renames System.Storage_Elements.To_Integer;\n \n    type Stack_Analyzer is private;\n    --  Type of the stack analyzer tool. It is used to fill a portion of\n@@ -88,6 +82,7 @@ package System.Stack_Usage is\n    --     Initialize_Analyzer (A,\n    --                          \"Task t\",\n    --                          A_Storage_Size - A_Guard,\n+   --                          A_Guard\n    --                          To_Stack_Address (Bottom_Of_Stack'Address));\n    --     Fill_Stack (A);\n    --     Some_User_Code;\n@@ -139,14 +134,14 @@ package System.Stack_Usage is\n \n    --   Pattern zone overflow:\n \n-   --     Description: The stack grows outer than the outermost bound of the\n-   --       pattern zone. In that case, the outermost region modified in the\n+   --     Description: The stack grows outer than the topmost bound of the\n+   --       pattern zone. In that case, the topmost region modified in the\n    --       pattern is not the maximum value of the stack pointer during the\n    --       execution.\n \n    --     Strategy: At the end of the execution, the difference between the\n-   --       outermost memory region modified in the pattern zone and the\n-   --       outermost bound of the pattern zone can be understood as the\n+   --       topmost memory region modified in the pattern zone and the\n+   --       topmost bound of the pattern zone can be understood as the\n    --       biggest allocation that the method could have detect, provided\n    --       that there is no \"Untouched allocated zone\" error and no \"Pattern\n    --       usage in user code\" error. If no object in the user code is likely\n@@ -165,7 +160,7 @@ package System.Stack_Usage is\n    --       changes the measure. Note that this error *very* rarely influence\n    --       the measure of the total stack usage: to have some influence, the\n    --       pattern has to be used in the object that has been allocated on the\n-   --       outermost address of the used stack.\n+   --       topmost address of the used stack.\n \n    --   Stack overflow:\n \n@@ -192,7 +187,7 @@ package System.Stack_Usage is\n    --       error is really rare, and it is most probably a bug in the user\n    --       code, e.g. some uninitialized variable. It is (most of the time)\n    --       harmless: it influences the measure only if the untouched allocated\n-   --       zone happens to be located at the outermost value of the stack\n+   --       zone happens to be located at the topmost value of the stack\n    --       pointer for the whole execution.\n \n    procedure Initialize (Buffer_Size : Natural);\n@@ -215,15 +210,16 @@ package System.Stack_Usage is\n    --  |  the end of the call)  |                                     |\n    --  ^                        |                                     |\n    --  Analyzer.Bottom_Of_Stack ^                                     |\n-   --                    Analyzer.Inner_Pattern_Mark                  ^\n-   --                                            Analyzer.Outer_Pattern_Mark\n+   --                    Analyzer.Bottom_Pattern_Mark                 ^\n+   --                                            Analyzer.Top_Pattern_Mark\n \n    procedure Initialize_Analyzer\n-     (Analyzer  : in out Stack_Analyzer;\n-      Task_Name : String;\n-      Size      : Natural;\n-      Bottom    : Stack_Address;\n-      Pattern   : Word_32 := 16#DEAD_BEEF#);\n+     (Analyzer       : in out Stack_Analyzer;\n+      Task_Name      : String;\n+      Size           : Natural;\n+      Overflow_Guard : Natural;\n+      Bottom         : Stack_Address;\n+      Pattern        : Interfaces.Unsigned_32 := 16#DEAD_BEEF#);\n    --  Should be called before any use of a Stack_Analyzer, to initialize it.\n    --  Size is the size of the pattern zone. Bottom should be a close\n    --  approximation of the caller base frame address.\n@@ -234,7 +230,7 @@ package System.Stack_Usage is\n    procedure Compute_Result (Analyzer : in out Stack_Analyzer);\n    --  Read the patern zone and deduce the stack usage. It should be called\n    --  from the same frame as Fill_Stack. If Analyzer.Probe is not null, an\n-   --  array of Word_32 with Analyzer.Probe elements is allocated on\n+   --  array of Unsigned_32 with Analyzer.Probe elements is allocated on\n    --  Compute_Result's stack frame. Probe can be used to detect  the error:\n    --  \"instrumentation threshold at reading\". See above. After the call\n    --  to this procedure, the memory will look like:\n@@ -247,11 +243,11 @@ package System.Stack_Usage is\n    --  |  (deallocated at       | elements       |  the      |    with   |\n    --  |  the end of the call)  |                | execution |  pattern  |\n    --  |                        ^                |           |           |\n-   --  |                   Inner_Pattern_Mark    |           |           |\n+   --  |                   Bottom_Pattern_Mark   |           |           |\n    --  |                                                     |           |\n    --  |<---------------------------------------------------->           |\n    --                  Stack used                                        ^\n-   --                                                     Outer_Pattern_Mark\n+   --                                                     Top_Pattern_Mark\n \n    procedure Report_Result (Analyzer : Stack_Analyzer);\n    --  Store the results of the computation in memory, at the address\n@@ -268,9 +264,11 @@ package System.Stack_Usage is\n private\n \n    Task_Name_Length : constant := 32;\n+   --  The maximum length of task name displayed.\n+   --  ??? Consider merging this variable with Max_Task_Image_Length.\n \n-   package Word_32_Addr is\n-     new System.Address_To_Access_Conversions (Word_32);\n+   package Unsigned_32_Addr is\n+     new System.Address_To_Access_Conversions (Interfaces.Unsigned_32);\n \n    type Stack_Analyzer is record\n       Task_Name : String (1 .. Task_Name_Length);\n@@ -279,46 +277,51 @@ private\n       Size : Natural;\n       --  Size of the pattern zone\n \n-      Pattern : Word_32;\n+      Pattern : Interfaces.Unsigned_32;\n       --  Pattern used to recognize untouched memory\n \n-      Inner_Pattern_Mark : Stack_Address;\n-      --  Innermost bound of the pattern area on the stack\n+      Bottom_Pattern_Mark : Stack_Address;\n+      --  Bound of the pattern area on the stack clostest to the bottom\n \n-      Outer_Pattern_Mark : Stack_Address;\n-      --  Outermost bound of the pattern area on the stack\n+      Top_Pattern_Mark : Stack_Address;\n+      --  Topmost bound of the pattern area on the stack\n \n-      Outermost_Touched_Mark : Stack_Address;\n-      --  Outermost address of the pattern area whose value it is pointing\n+      Topmost_Touched_Mark : Stack_Address;\n+      --  Topmost address of the pattern area whose value it is pointing\n       --  at has been modified during execution. If the systematic error are\n-      --  compensated, it is the outermost value of the stack pointer during\n+      --  compensated, it is the topmost value of the stack pointer during\n       --  the execution.\n \n       Bottom_Of_Stack : Stack_Address;\n       --  Address of the bottom of the stack, as given by the caller of\n       --  Initialize_Analyzer.\n \n       Array_Address : System.Address;\n-      --  Address of the array of Word_32 that represents the pattern zone\n+      --  Address of the array of Unsigned_32 that represents the pattern zone\n \n-      First_Is_Outermost : Boolean;\n-      --  Set to true if the first element of the array of Word_32 that\n-      --  represents the pattern zone is at the outermost address of the\n-      --  pattern zone; false if it is the innermost address.\n+      First_Is_Topmost : Boolean;\n+      --  Set to true if the first element of the array of Unsigned_32 that\n+      --  represents the pattern zone is at the topmost address of the\n+      --  pattern zone; false if it is the bottommost address.\n \n       Result_Id : Positive;\n       --  Id of the result. If less than value given to gnatbind -u corresponds\n       --  to the location in the result array of result for the current task.\n+\n+      Overflow_Guard : Natural;\n+      --  The amount of bytes that won't be analyzed in order to prevent\n+      --  writing out of the stack\n    end record;\n \n    Environment_Task_Analyzer : Stack_Analyzer;\n \n    Compute_Environment_Task  : Boolean;\n \n    type Task_Result is record\n-      Task_Name : String (1 .. Task_Name_Length);\n-      Measure   : Natural;\n-      Max_Size  : Natural;\n+      Task_Name      : String (1 .. Task_Name_Length);\n+      Measure        : Natural;\n+      Max_Size       : Natural;\n+      Overflow_Guard : Natural;\n    end record;\n \n    type Result_Array_Type is array (Positive range <>) of Task_Result;"}]}