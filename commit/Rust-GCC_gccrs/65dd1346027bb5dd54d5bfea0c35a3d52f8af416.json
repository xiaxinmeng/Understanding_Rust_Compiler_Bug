{"sha": "65dd1346027bb5dd54d5bfea0c35a3d52f8af416", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjVkZDEzNDYwMjdiYjVkZDU0ZDViZmVhMGMzNWEzZDUyZjhhZjQxNg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-13T17:59:08Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-13T17:59:08Z"}, "message": "Allow ADDR_EXPRs of TARGET_MEM_REFs\n\nThis patch allows ADDR_EXPR <TARGET_MEM_REF ...>, which is useful\nwhen calling internal functions that take pointers to memory that\nis conditionally loaded or stored.  This is a prerequisite to the\nfollowing ivopts patch.\n\n2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* expr.c (expand_expr_addr_expr_1): Handle ADDR_EXPRs of\n\tTARGET_MEM_REFs.\n\t* gimple-expr.h (is_gimple_addressable: Likewise.\n\t* gimple-expr.c (is_gimple_address): Likewise.\n\t* internal-fn.c (expand_call_mem_ref): New function.\n\t(expand_mask_load_optab_fn): Use it.\n\t(expand_mask_store_optab_fn): Likewise.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r256627", "tree": {"sha": "754f3d68a76e1f062c8029cd95e93079f9a75c10", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/754f3d68a76e1f062c8029cd95e93079f9a75c10"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/65dd1346027bb5dd54d5bfea0c35a3d52f8af416", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65dd1346027bb5dd54d5bfea0c35a3d52f8af416", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65dd1346027bb5dd54d5bfea0c35a3d52f8af416", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65dd1346027bb5dd54d5bfea0c35a3d52f8af416/comments", "author": null, "committer": null, "parents": [{"sha": "0972596e6d2573a2c7e922c66b017974ed03ad89", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0972596e6d2573a2c7e922c66b017974ed03ad89", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0972596e6d2573a2c7e922c66b017974ed03ad89"}], "stats": {"total": 78, "additions": 63, "deletions": 15}, "files": [{"sha": "79ddaf32d8988573dcb558a1f1ce04c9dd2e7433", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65dd1346027bb5dd54d5bfea0c35a3d52f8af416/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65dd1346027bb5dd54d5bfea0c35a3d52f8af416/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=65dd1346027bb5dd54d5bfea0c35a3d52f8af416", "patch": "@@ -1,3 +1,15 @@\n+2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* expr.c (expand_expr_addr_expr_1): Handle ADDR_EXPRs of\n+\tTARGET_MEM_REFs.\n+\t* gimple-expr.h (is_gimple_addressable: Likewise.\n+\t* gimple-expr.c (is_gimple_address): Likewise.\n+\t* internal-fn.c (expand_call_mem_ref): New function.\n+\t(expand_mask_load_optab_fn): Use it.\n+\t(expand_mask_store_optab_fn): Likewise.\n+\n 2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "42f889f318c2db11156791ad43ea3055897bb735", "filename": "gcc/expr.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65dd1346027bb5dd54d5bfea0c35a3d52f8af416/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65dd1346027bb5dd54d5bfea0c35a3d52f8af416/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=65dd1346027bb5dd54d5bfea0c35a3d52f8af416", "patch": "@@ -7885,6 +7885,9 @@ expand_expr_addr_expr_1 (tree exp, rtx target, scalar_int_mode tmode,\n \treturn expand_expr (tem, target, tmode, modifier);\n       }\n \n+    case TARGET_MEM_REF:\n+      return addr_for_mem_ref (exp, as, true);\n+\n     case CONST_DECL:\n       /* Expand the initializer like constants above.  */\n       result = XEXP (expand_expr_constant (DECL_INITIAL (exp),"}, {"sha": "56caacabba220f31a94af12fafa1f08870935271", "filename": "gcc/gimple-expr.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65dd1346027bb5dd54d5bfea0c35a3d52f8af416/gcc%2Fgimple-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65dd1346027bb5dd54d5bfea0c35a3d52f8af416/gcc%2Fgimple-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-expr.c?ref=65dd1346027bb5dd54d5bfea0c35a3d52f8af416", "patch": "@@ -631,7 +631,9 @@ is_gimple_address (const_tree t)\n       op = TREE_OPERAND (op, 0);\n     }\n \n-  if (CONSTANT_CLASS_P (op) || TREE_CODE (op) == MEM_REF)\n+  if (CONSTANT_CLASS_P (op)\n+      || TREE_CODE (op) == TARGET_MEM_REF\n+      || TREE_CODE (op) == MEM_REF)\n     return true;\n \n   switch (TREE_CODE (op))"}, {"sha": "96733bdd7b43b0ae2cb007016f499ea27654b7dc", "filename": "gcc/gimple-expr.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65dd1346027bb5dd54d5bfea0c35a3d52f8af416/gcc%2Fgimple-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65dd1346027bb5dd54d5bfea0c35a3d52f8af416/gcc%2Fgimple-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-expr.h?ref=65dd1346027bb5dd54d5bfea0c35a3d52f8af416", "patch": "@@ -119,6 +119,7 @@ static inline bool\n is_gimple_addressable (tree t)\n {\n   return (is_gimple_id (t) || handled_component_p (t)\n+\t  || TREE_CODE (t) == TARGET_MEM_REF\n \t  || TREE_CODE (t) == MEM_REF);\n }\n "}, {"sha": "86a196442498cd0872e7bfc62b6f5d534fc9a6fd", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 44, "deletions": 14, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65dd1346027bb5dd54d5bfea0c35a3d52f8af416/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65dd1346027bb5dd54d5bfea0c35a3d52f8af416/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=65dd1346027bb5dd54d5bfea0c35a3d52f8af416", "patch": "@@ -2412,27 +2412,62 @@ expand_LOOP_DIST_ALIAS (internal_fn, gcall *)\n   gcc_unreachable ();\n }\n \n+/* Return a memory reference of type TYPE for argument INDEX of STMT.\n+   Use argument INDEX + 1 to derive the second (TBAA) operand.  */\n+\n+static tree\n+expand_call_mem_ref (tree type, gcall *stmt, int index)\n+{\n+  tree addr = gimple_call_arg (stmt, index);\n+  tree alias_ptr_type = TREE_TYPE (gimple_call_arg (stmt, index + 1));\n+  unsigned int align = tree_to_shwi (gimple_call_arg (stmt, index + 1));\n+  if (TYPE_ALIGN (type) != align)\n+    type = build_aligned_type (type, align);\n+\n+  tree tmp = addr;\n+  if (TREE_CODE (tmp) == SSA_NAME)\n+    {\n+      gimple *def = SSA_NAME_DEF_STMT (tmp);\n+      if (gimple_assign_single_p (def))\n+\ttmp = gimple_assign_rhs1 (def);\n+    }\n+\n+  if (TREE_CODE (tmp) == ADDR_EXPR)\n+    {\n+      tree mem = TREE_OPERAND (tmp, 0);\n+      if (TREE_CODE (mem) == TARGET_MEM_REF\n+\t  && types_compatible_p (TREE_TYPE (mem), type))\n+\t{\n+\t  tree offset = TMR_OFFSET (mem);\n+\t  if (alias_ptr_type != TREE_TYPE (offset) || !integer_zerop (offset))\n+\t    {\n+\t      mem = copy_node (mem);\n+\t      TMR_OFFSET (mem) = wide_int_to_tree (alias_ptr_type,\n+\t\t\t\t\t\t   wi::to_poly_wide (offset));\n+\t    }\n+\t  return mem;\n+\t}\n+    }\n+\n+  return fold_build2 (MEM_REF, type, addr, build_int_cst (alias_ptr_type, 0));\n+}\n+\n /* Expand MASK_LOAD{,_LANES} call STMT using optab OPTAB.  */\n \n static void\n expand_mask_load_optab_fn (internal_fn, gcall *stmt, convert_optab optab)\n {\n   struct expand_operand ops[3];\n-  tree type, lhs, rhs, maskt, ptr;\n+  tree type, lhs, rhs, maskt;\n   rtx mem, target, mask;\n-  unsigned align;\n   insn_code icode;\n \n   maskt = gimple_call_arg (stmt, 2);\n   lhs = gimple_call_lhs (stmt);\n   if (lhs == NULL_TREE)\n     return;\n   type = TREE_TYPE (lhs);\n-  ptr = build_int_cst (TREE_TYPE (gimple_call_arg (stmt, 1)), 0);\n-  align = tree_to_shwi (gimple_call_arg (stmt, 1));\n-  if (TYPE_ALIGN (type) != align)\n-    type = build_aligned_type (type, align);\n-  rhs = fold_build2 (MEM_REF, type, gimple_call_arg (stmt, 0), ptr);\n+  rhs = expand_call_mem_ref (type, stmt, 0);\n \n   if (optab == vec_mask_load_lanes_optab)\n     icode = get_multi_vector_move (type, optab);\n@@ -2458,19 +2493,14 @@ static void\n expand_mask_store_optab_fn (internal_fn, gcall *stmt, convert_optab optab)\n {\n   struct expand_operand ops[3];\n-  tree type, lhs, rhs, maskt, ptr;\n+  tree type, lhs, rhs, maskt;\n   rtx mem, reg, mask;\n-  unsigned align;\n   insn_code icode;\n \n   maskt = gimple_call_arg (stmt, 2);\n   rhs = gimple_call_arg (stmt, 3);\n   type = TREE_TYPE (rhs);\n-  ptr = build_int_cst (TREE_TYPE (gimple_call_arg (stmt, 1)), 0);\n-  align = tree_to_shwi (gimple_call_arg (stmt, 1));\n-  if (TYPE_ALIGN (type) != align)\n-    type = build_aligned_type (type, align);\n-  lhs = fold_build2 (MEM_REF, type, gimple_call_arg (stmt, 0), ptr);\n+  lhs = expand_call_mem_ref (type, stmt, 0);\n \n   if (optab == vec_mask_store_lanes_optab)\n     icode = get_multi_vector_move (type, optab);"}]}