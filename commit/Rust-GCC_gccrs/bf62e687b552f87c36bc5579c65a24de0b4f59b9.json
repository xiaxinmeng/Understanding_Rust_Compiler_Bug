{"sha": "bf62e687b552f87c36bc5579c65a24de0b4f59b9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmY2MmU2ODdiNTUyZjg3YzM2YmM1NTc5YzY1YTI0ZGUwYjRmNTliOQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-08-30T11:15:46Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-08-30T11:15:46Z"}, "message": "[43/77] Use scalar_int_mode in simplify_comparison\n\nThe main loop of simplify_comparison starts with:\n\n      if (GET_MODE_CLASS (mode) != MODE_INT\n          && ! (mode == VOIDmode\n                && (GET_CODE (op0) == COMPARE || COMPARISON_P (op0))))\n        break;\n\nSo VOIDmode is only acceptable when comparing a COMPARE,\nEQ, NE, etc. operand against a constant.  After this, the loop\ncalls simplify_compare_const to:\n\n  (a) bring the constant op1 closer to 0 where possible and\n  (b) use nonzero_bits and num_sign_bit_copies to get a simpler\n      constant.\n\n(a) works for both integer and VOID modes, (b) is specific\nto integer modes.\n\nThe loop then has a big switch statement that handles further\nsimplifications.  This switch statement checks for COMPARISON_P\ncodes but not for COMPARE.\n\nThis patch uses scalar_int_mode to make the split between\n(a) and (b) more explicit.  It also takes the COMPARISON_P\nhandling out of the switch statement and does it first,\nso that the rest of the loop can treat the mode as a\nscalar_int_mode.\n\n2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* combine.c (simplify_compare_const): Check that the mode is a\n\tscalar_int_mode (rather than VOIDmode) before testing its\n\tprecision.\n\t(simplify_comparison): Move COMPARISON_P handling out of the\n\tloop and restrict the latter part of the loop to scalar_int_modes.\n\tCheck is_a <scalar_int_mode> before calling HWI_COMPUTABLE_MODE_P\n\tand when considering SUBREG_REGs.  Use is_int_mode instead of\n\tchecking GET_MODE_CLASS against MODE_INT.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r251495", "tree": {"sha": "2e431339af054633d0375b384554024913d45efc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2e431339af054633d0375b384554024913d45efc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bf62e687b552f87c36bc5579c65a24de0b4f59b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf62e687b552f87c36bc5579c65a24de0b4f59b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf62e687b552f87c36bc5579c65a24de0b4f59b9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf62e687b552f87c36bc5579c65a24de0b4f59b9/comments", "author": null, "committer": null, "parents": [{"sha": "e3731c52cf1b60d90f27f81ff0d1e2ad164fed07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3731c52cf1b60d90f27f81ff0d1e2ad164fed07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3731c52cf1b60d90f27f81ff0d1e2ad164fed07"}], "stats": {"total": 192, "additions": 110, "deletions": 82}, "files": [{"sha": "5449fa1849df1b1b467c3603f815094d1f41cff3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf62e687b552f87c36bc5579c65a24de0b4f59b9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf62e687b552f87c36bc5579c65a24de0b4f59b9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bf62e687b552f87c36bc5579c65a24de0b4f59b9", "patch": "@@ -1,3 +1,16 @@\n+2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* combine.c (simplify_compare_const): Check that the mode is a\n+\tscalar_int_mode (rather than VOIDmode) before testing its\n+\tprecision.\n+\t(simplify_comparison): Move COMPARISON_P handling out of the\n+\tloop and restrict the latter part of the loop to scalar_int_modes.\n+\tCheck is_a <scalar_int_mode> before calling HWI_COMPUTABLE_MODE_P\n+\tand when considering SUBREG_REGs.  Use is_int_mode instead of\n+\tchecking GET_MODE_CLASS against MODE_INT.\n+\n 2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "2fbfed4c416ed9eaa3b79dfd24ec968016ce116c", "filename": "gcc/combine.c", "status": "modified", "additions": 97, "deletions": 82, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf62e687b552f87c36bc5579c65a24de0b4f59b9/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf62e687b552f87c36bc5579c65a24de0b4f59b9/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=bf62e687b552f87c36bc5579c65a24de0b4f59b9", "patch": "@@ -11640,7 +11640,7 @@ static enum rtx_code\n simplify_compare_const (enum rtx_code code, machine_mode mode,\n \t\t\trtx op0, rtx *pop1)\n {\n-  unsigned int mode_width = GET_MODE_PRECISION (mode);\n+  scalar_int_mode int_mode;\n   HOST_WIDE_INT const_op = INTVAL (*pop1);\n \n   /* Get the constant we are comparing against and turn off all bits\n@@ -11655,10 +11655,11 @@ simplify_compare_const (enum rtx_code code, machine_mode mode,\n   if (const_op\n       && (code == EQ || code == NE || code == GE || code == GEU\n \t  || code == LT || code == LTU)\n-      && mode_width - 1 < HOST_BITS_PER_WIDE_INT\n-      && pow2p_hwi (const_op & GET_MODE_MASK (mode))\n-      && (nonzero_bits (op0, mode)\n-\t  == (unsigned HOST_WIDE_INT) (const_op & GET_MODE_MASK (mode))))\n+      && is_a <scalar_int_mode> (mode, &int_mode)\n+      && GET_MODE_PRECISION (int_mode) - 1 < HOST_BITS_PER_WIDE_INT\n+      && pow2p_hwi (const_op & GET_MODE_MASK (int_mode))\n+      && (nonzero_bits (op0, int_mode)\n+\t  == (unsigned HOST_WIDE_INT) (const_op & GET_MODE_MASK (int_mode))))\n     {\n       code = (code == EQ || code == GE || code == GEU ? NE : EQ);\n       const_op = 0;\n@@ -11669,7 +11670,8 @@ simplify_compare_const (enum rtx_code code, machine_mode mode,\n   if (const_op == -1\n       && (code == EQ || code == NE || code == GT || code == LE\n \t  || code == GEU || code == LTU)\n-      && num_sign_bit_copies (op0, mode) == mode_width)\n+      && is_a <scalar_int_mode> (mode, &int_mode)\n+      && num_sign_bit_copies (op0, int_mode) == GET_MODE_PRECISION (int_mode))\n     {\n       code = (code == EQ || code == LE || code == GEU ? NE : EQ);\n       const_op = 0;\n@@ -11703,9 +11705,10 @@ simplify_compare_const (enum rtx_code code, machine_mode mode,\n       /* If we are doing a <= 0 comparison on a value known to have\n \t a zero sign bit, we can replace this with == 0.  */\n       else if (const_op == 0\n-\t       && mode_width - 1 < HOST_BITS_PER_WIDE_INT\n-\t       && (nonzero_bits (op0, mode)\n-\t\t   & (HOST_WIDE_INT_1U << (mode_width - 1)))\n+\t       && is_a <scalar_int_mode> (mode, &int_mode)\n+\t       && GET_MODE_PRECISION (int_mode) - 1 < HOST_BITS_PER_WIDE_INT\n+\t       && (nonzero_bits (op0, int_mode)\n+\t\t   & (HOST_WIDE_INT_1U << (GET_MODE_PRECISION (int_mode) - 1)))\n \t       == 0)\n \tcode = EQ;\n       break;\n@@ -11733,9 +11736,10 @@ simplify_compare_const (enum rtx_code code, machine_mode mode,\n       /* If we are doing a > 0 comparison on a value known to have\n \t a zero sign bit, we can replace this with != 0.  */\n       else if (const_op == 0\n-\t       && mode_width - 1 < HOST_BITS_PER_WIDE_INT\n-\t       && (nonzero_bits (op0, mode)\n-\t\t   & (HOST_WIDE_INT_1U << (mode_width - 1)))\n+\t       && is_a <scalar_int_mode> (mode, &int_mode)\n+\t       && GET_MODE_PRECISION (int_mode) - 1 < HOST_BITS_PER_WIDE_INT\n+\t       && (nonzero_bits (op0, int_mode)\n+\t\t   & (HOST_WIDE_INT_1U << (GET_MODE_PRECISION (int_mode) - 1)))\n \t       == 0)\n \tcode = NE;\n       break;\n@@ -11749,9 +11753,10 @@ simplify_compare_const (enum rtx_code code, machine_mode mode,\n \t  /* ... fall through ...  */\n \t}\n       /* (unsigned) < 0x80000000 is equivalent to >= 0.  */\n-      else if (mode_width - 1 < HOST_BITS_PER_WIDE_INT\n-\t       && (unsigned HOST_WIDE_INT) const_op\n-\t       == HOST_WIDE_INT_1U << (mode_width - 1))\n+      else if (is_a <scalar_int_mode> (mode, &int_mode)\n+\t       && GET_MODE_PRECISION (int_mode) - 1 < HOST_BITS_PER_WIDE_INT\n+\t       && ((unsigned HOST_WIDE_INT) const_op\n+\t\t   == HOST_WIDE_INT_1U << (GET_MODE_PRECISION (int_mode) - 1)))\n \t{\n \t  const_op = 0;\n \t  code = GE;\n@@ -11765,9 +11770,11 @@ simplify_compare_const (enum rtx_code code, machine_mode mode,\n       if (const_op == 0)\n \tcode = EQ;\n       /* (unsigned) <= 0x7fffffff is equivalent to >= 0.  */\n-      else if (mode_width - 1 < HOST_BITS_PER_WIDE_INT\n-\t       && (unsigned HOST_WIDE_INT) const_op\n-\t       == (HOST_WIDE_INT_1U << (mode_width - 1)) - 1)\n+      else if (is_a <scalar_int_mode> (mode, &int_mode)\n+\t       && GET_MODE_PRECISION (int_mode) - 1 < HOST_BITS_PER_WIDE_INT\n+\t       && ((unsigned HOST_WIDE_INT) const_op\n+\t\t   == ((HOST_WIDE_INT_1U\n+\t\t\t<< (GET_MODE_PRECISION (int_mode) - 1)) - 1)))\n \t{\n \t  const_op = 0;\n \t  code = GE;\n@@ -11784,9 +11791,10 @@ simplify_compare_const (enum rtx_code code, machine_mode mode,\n \t}\n \n       /* (unsigned) >= 0x80000000 is equivalent to < 0.  */\n-      else if (mode_width - 1 < HOST_BITS_PER_WIDE_INT\n-\t       && (unsigned HOST_WIDE_INT) const_op\n-\t       == HOST_WIDE_INT_1U << (mode_width - 1))\n+      else if (is_a <scalar_int_mode> (mode, &int_mode)\n+\t       && GET_MODE_PRECISION (int_mode) - 1 < HOST_BITS_PER_WIDE_INT\n+\t       && ((unsigned HOST_WIDE_INT) const_op\n+\t\t   == HOST_WIDE_INT_1U << (GET_MODE_PRECISION (int_mode) - 1)))\n \t{\n \t  const_op = 0;\n \t  code = LT;\n@@ -11800,9 +11808,11 @@ simplify_compare_const (enum rtx_code code, machine_mode mode,\n       if (const_op == 0)\n \tcode = NE;\n       /* (unsigned) > 0x7fffffff is equivalent to < 0.  */\n-      else if (mode_width - 1 < HOST_BITS_PER_WIDE_INT\n-\t       && (unsigned HOST_WIDE_INT) const_op\n-\t       == (HOST_WIDE_INT_1U << (mode_width - 1)) - 1)\n+      else if (is_a <scalar_int_mode> (mode, &int_mode)\n+\t       && GET_MODE_PRECISION (int_mode) - 1 < HOST_BITS_PER_WIDE_INT\n+\t       && ((unsigned HOST_WIDE_INT) const_op\n+\t\t   == (HOST_WIDE_INT_1U\n+\t\t       << (GET_MODE_PRECISION (int_mode) - 1)) - 1))\n \t{\n \t  const_op = 0;\n \t  code = LT;\n@@ -11987,9 +11997,8 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \n   while (CONST_INT_P (op1))\n     {\n-      machine_mode mode = GET_MODE (op0);\n-      unsigned int mode_width = GET_MODE_PRECISION (mode);\n-      unsigned HOST_WIDE_INT mask = GET_MODE_MASK (mode);\n+      machine_mode raw_mode = GET_MODE (op0);\n+      scalar_int_mode int_mode;\n       int equality_comparison_p;\n       int sign_bit_comparison_p;\n       int unsigned_comparison_p;\n@@ -12000,14 +12009,14 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t can handle VOIDmode if OP0 is a COMPARE or a comparison\n \t operation.  */\n \n-      if (GET_MODE_CLASS (mode) != MODE_INT\n-\t  && ! (mode == VOIDmode\n+      if (GET_MODE_CLASS (raw_mode) != MODE_INT\n+\t  && ! (raw_mode == VOIDmode\n \t\t&& (GET_CODE (op0) == COMPARE || COMPARISON_P (op0))))\n \tbreak;\n \n       /* Try to simplify the compare to constant, possibly changing the\n \t comparison op, and/or changing op1 to zero.  */\n-      code = simplify_compare_const (code, mode, op0, &op1);\n+      code = simplify_compare_const (code, raw_mode, op0, &op1);\n       const_op = INTVAL (op1);\n \n       /* Compute some predicates to simplify code below.  */\n@@ -12019,16 +12028,62 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \n       /* If this is a sign bit comparison and we can do arithmetic in\n \t MODE, say that we will only be needing the sign bit of OP0.  */\n-      if (sign_bit_comparison_p && HWI_COMPUTABLE_MODE_P (mode))\n-\top0 = force_to_mode (op0, mode,\n+      if (sign_bit_comparison_p\n+\t  && is_a <scalar_int_mode> (raw_mode, &int_mode)\n+\t  && HWI_COMPUTABLE_MODE_P (int_mode))\n+\top0 = force_to_mode (op0, int_mode,\n \t\t\t     HOST_WIDE_INT_1U\n-\t\t\t     << (GET_MODE_PRECISION (mode) - 1),\n+\t\t\t     << (GET_MODE_PRECISION (int_mode) - 1),\n \t\t\t     0);\n \n+      if (COMPARISON_P (op0))\n+\t{\n+\t  /* We can't do anything if OP0 is a condition code value, rather\n+\t     than an actual data value.  */\n+\t  if (const_op != 0\n+\t      || CC0_P (XEXP (op0, 0))\n+\t      || GET_MODE_CLASS (GET_MODE (XEXP (op0, 0))) == MODE_CC)\n+\t    break;\n+\n+\t  /* Get the two operands being compared.  */\n+\t  if (GET_CODE (XEXP (op0, 0)) == COMPARE)\n+\t    tem = XEXP (XEXP (op0, 0), 0), tem1 = XEXP (XEXP (op0, 0), 1);\n+\t  else\n+\t    tem = XEXP (op0, 0), tem1 = XEXP (op0, 1);\n+\n+\t  /* Check for the cases where we simply want the result of the\n+\t     earlier test or the opposite of that result.  */\n+\t  if (code == NE || code == EQ\n+\t      || (val_signbit_known_set_p (raw_mode, STORE_FLAG_VALUE)\n+\t\t  && (code == LT || code == GE)))\n+\t    {\n+\t      enum rtx_code new_code;\n+\t      if (code == LT || code == NE)\n+\t\tnew_code = GET_CODE (op0);\n+\t      else\n+\t\tnew_code = reversed_comparison_code (op0, NULL);\n+\n+\t      if (new_code != UNKNOWN)\n+\t\t{\n+\t\t  code = new_code;\n+\t\t  op0 = tem;\n+\t\t  op1 = tem1;\n+\t\t  continue;\n+\t\t}\n+\t    }\n+\t  break;\n+\t}\n+\n+      if (raw_mode == VOIDmode)\n+\tbreak;\n+      scalar_int_mode mode = as_a <scalar_int_mode> (raw_mode);\n+\n       /* Now try cases based on the opcode of OP0.  If none of the cases\n \t does a \"continue\", we exit this loop immediately after the\n \t switch.  */\n \n+      unsigned int mode_width = GET_MODE_PRECISION (mode);\n+      unsigned HOST_WIDE_INT mask = GET_MODE_MASK (mode);\n       switch (GET_CODE (op0))\n \t{\n \tcase ZERO_EXTRACT:\n@@ -12173,8 +12228,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t     insn of the given mode, since we'd have to revert it\n \t     later on, and then we wouldn't know whether to sign- or\n \t     zero-extend.  */\n-\t  mode = GET_MODE (XEXP (op0, 0));\n-\t  if (GET_MODE_CLASS (mode) == MODE_INT\n+\t  if (is_int_mode (GET_MODE (XEXP (op0, 0)), &mode)\n \t      && ! unsigned_comparison_p\n \t      && HWI_COMPUTABLE_MODE_P (mode)\n \t      && trunc_int_for_mode (const_op, mode) == const_op\n@@ -12208,11 +12262,12 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \n \t  if (mode_width <= HOST_BITS_PER_WIDE_INT\n \t      && subreg_lowpart_p (op0)\n-\t      && GET_MODE_PRECISION (GET_MODE (SUBREG_REG (op0))) > mode_width\n+\t      && is_a <scalar_int_mode> (GET_MODE (SUBREG_REG (op0)),\n+\t\t\t\t\t &inner_mode)\n+\t      && GET_MODE_PRECISION (inner_mode) > mode_width\n \t      && GET_CODE (SUBREG_REG (op0)) == PLUS\n \t      && CONST_INT_P (XEXP (SUBREG_REG (op0), 1)))\n \t    {\n-\t      machine_mode inner_mode = GET_MODE (SUBREG_REG (op0));\n \t      rtx a = XEXP (SUBREG_REG (op0), 0);\n \t      HOST_WIDE_INT c1 = -INTVAL (XEXP (SUBREG_REG (op0), 1));\n \n@@ -12248,19 +12303,19 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t  if (paradoxical_subreg_p (op0))\n \t    ;\n \t  else if (subreg_lowpart_p (op0)\n-\t\t   && GET_MODE_CLASS (GET_MODE (op0)) == MODE_INT\n+\t\t   && GET_MODE_CLASS (mode) == MODE_INT\n \t\t   && is_int_mode (GET_MODE (SUBREG_REG (op0)), &inner_mode)\n \t\t   && (code == NE || code == EQ)\n \t\t   && GET_MODE_PRECISION (inner_mode) <= HOST_BITS_PER_WIDE_INT\n \t\t   && !paradoxical_subreg_p (op0)\n \t\t   && (nonzero_bits (SUBREG_REG (op0), inner_mode)\n-\t\t       & ~GET_MODE_MASK (GET_MODE (op0))) == 0)\n+\t\t       & ~GET_MODE_MASK (mode)) == 0)\n \t    {\n \t      /* Remove outer subregs that don't do anything.  */\n \t      tem = gen_lowpart (inner_mode, op1);\n \n \t      if ((nonzero_bits (tem, inner_mode)\n-\t\t   & ~GET_MODE_MASK (GET_MODE (op0))) == 0)\n+\t\t   & ~GET_MODE_MASK (mode)) == 0)\n \t\t{\n \t\t  op0 = SUBREG_REG (op0);\n \t\t  op1 = tem;\n@@ -12274,8 +12329,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t  /* FALLTHROUGH */\n \n \tcase ZERO_EXTEND:\n-\t  mode = GET_MODE (XEXP (op0, 0));\n-\t  if (GET_MODE_CLASS (mode) == MODE_INT\n+\t  if (is_int_mode (GET_MODE (XEXP (op0, 0)), &mode)\n \t      && (unsigned_comparison_p || equality_comparison_p)\n \t      && HWI_COMPUTABLE_MODE_P (mode)\n \t      && (unsigned HOST_WIDE_INT) const_op <= GET_MODE_MASK (mode)\n@@ -12364,45 +12418,6 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t    }\n \t  break;\n \n-\tcase EQ:  case NE:\n-\tcase UNEQ:  case LTGT:\n-\tcase LT:  case LTU:  case UNLT:  case LE:  case LEU:  case UNLE:\n-\tcase GT:  case GTU:  case UNGT:  case GE:  case GEU:  case UNGE:\n-\tcase UNORDERED: case ORDERED:\n-\t  /* We can't do anything if OP0 is a condition code value, rather\n-\t     than an actual data value.  */\n-\t  if (const_op != 0\n-\t      || CC0_P (XEXP (op0, 0))\n-\t      || GET_MODE_CLASS (GET_MODE (XEXP (op0, 0))) == MODE_CC)\n-\t    break;\n-\n-\t  /* Get the two operands being compared.  */\n-\t  if (GET_CODE (XEXP (op0, 0)) == COMPARE)\n-\t    tem = XEXP (XEXP (op0, 0), 0), tem1 = XEXP (XEXP (op0, 0), 1);\n-\t  else\n-\t    tem = XEXP (op0, 0), tem1 = XEXP (op0, 1);\n-\n-\t  /* Check for the cases where we simply want the result of the\n-\t     earlier test or the opposite of that result.  */\n-\t  if (code == NE || code == EQ\n-\t      || (val_signbit_known_set_p (GET_MODE (op0), STORE_FLAG_VALUE)\n-\t\t  && (code == LT || code == GE)))\n-\t    {\n-\t      enum rtx_code new_code;\n-\t      if (code == LT || code == NE)\n-\t\tnew_code = GET_CODE (op0);\n-\t      else\n-\t\tnew_code = reversed_comparison_code (op0, NULL);\n-\n-\t      if (new_code != UNKNOWN)\n-\t\t{\n-\t\t  code = new_code;\n-\t\t  op0 = tem;\n-\t\t  op1 = tem1;\n-\t\t  continue;\n-\t\t}\n-\t    }\n-\t  break;\n \n \tcase IOR:\n \t  /* The sign bit of (ior (plus X (const_int -1)) X) is nonzero\n@@ -12674,7 +12689,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t    {\n \t      rtx inner = XEXP (XEXP (XEXP (op0, 0), 0), 0);\n \t      rtx add_const = XEXP (XEXP (op0, 0), 1);\n-\t      rtx new_const = simplify_gen_binary (ASHIFTRT, GET_MODE (op0),\n+\t      rtx new_const = simplify_gen_binary (ASHIFTRT, mode,\n \t\t\t\t\t\t   add_const, XEXP (op0, 1));\n \n \t      op0 = simplify_gen_binary (PLUS, tmode,"}]}