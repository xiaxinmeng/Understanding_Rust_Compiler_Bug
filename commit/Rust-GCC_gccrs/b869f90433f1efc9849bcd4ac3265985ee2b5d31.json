{"sha": "b869f90433f1efc9849bcd4ac3265985ee2b5d31", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjg2OWY5MDQzM2YxZWZjOTg0OWJjZDRhYzMyNjU5ODVlZTJiNWQzMQ==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "joern.rennecke@superh.com", "date": "2003-08-06T19:33:13Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2003-08-06T19:33:13Z"}, "message": "Fix SHcompact exception handling:\n\n2003-08-06  J\"orn Rennecke <joern.rennecke@superh.com>\n\n\tFix SHcompact exception handling:\n\t* sh.c (sh_get_pr_initial_val): If PR is or miight be clobbered\n\tby the prologue, return a MEM with return_address_pointer_rtx\n\tas address.\n\t* sh.h (HARD_REGNO_MODE_OK): PR is OK for SImode.\n\t(RETURN_ADDR_OFFSET): Don't define.\n\t(SH_DBX_REGISTER_NUMBER): Use SHmedia numbers for SHmedia\n\tregisters that are visible in compact mode.  Show that SHmedia\n\tregisters still exist in compact mode, even if there are not\n\treadily accessible.\n\t(ASM_PREFERRED_EH_DATA_FORMAT): Supply DW_EH_PE_indirect\n\tif GLOBAL.  Use DW_EH_PE_textrel (nominally) for CODE,\n\tand DW_EH_PE_pcrel for pic data.\n\t(ASM_MAYBE_OUTPUT_ENCODED_ADDR_RTX): If DW_EH_PE_textrel,\n\tset SYMBOL_FLAG_FUNCTION in symbol, and actually use\n\tDW_EH_PE_pcrel / DW_EH_PE_absptr encoding.\n\t(ALLOCATE_INITIAL_VALUE): Put PR on stack if prologue clobbers it.\n\t* sh.md (movsi_media-1): New splitter.\n\nFrom-SVN: r70204", "tree": {"sha": "d029cd33239bc1d98c961ba9500987ee1ed0d9e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d029cd33239bc1d98c961ba9500987ee1ed0d9e1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b869f90433f1efc9849bcd4ac3265985ee2b5d31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b869f90433f1efc9849bcd4ac3265985ee2b5d31", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b869f90433f1efc9849bcd4ac3265985ee2b5d31", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b869f90433f1efc9849bcd4ac3265985ee2b5d31/comments", "author": null, "committer": null, "parents": [{"sha": "f2feed2c727298bbafa6cc6884f79aafe89326ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2feed2c727298bbafa6cc6884f79aafe89326ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2feed2c727298bbafa6cc6884f79aafe89326ea"}], "stats": {"total": 98, "additions": 86, "deletions": 12}, "files": [{"sha": "2041409a42dc1ab443179c683541a847a3e73ed0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b869f90433f1efc9849bcd4ac3265985ee2b5d31/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b869f90433f1efc9849bcd4ac3265985ee2b5d31/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b869f90433f1efc9849bcd4ac3265985ee2b5d31", "patch": "@@ -1,3 +1,24 @@\n+2003-08-06  J\"orn Rennecke <joern.rennecke@superh.com>\n+\n+\tFix SHcompact exception handling:\n+\t* sh.c (sh_get_pr_initial_val): If PR is or miight be clobbered\n+\tby the prologue, return a MEM with return_address_pointer_rtx\n+\tas address.\n+\t* sh.h (HARD_REGNO_MODE_OK): PR is OK for SImode.\n+\t(RETURN_ADDR_OFFSET): Don't define.\n+\t(SH_DBX_REGISTER_NUMBER): Use SHmedia numbers for SHmedia\n+\tregisters that are visible in compact mode.  Show that SHmedia\n+\tregisters still exist in compact mode, even if there are not\n+\treadily accessible.\n+\t(ASM_PREFERRED_EH_DATA_FORMAT): Supply DW_EH_PE_indirect\n+\tif GLOBAL.  Use DW_EH_PE_textrel (nominally) for CODE,\n+\tand DW_EH_PE_pcrel for pic data.\n+\t(ASM_MAYBE_OUTPUT_ENCODED_ADDR_RTX): If DW_EH_PE_textrel,\n+\tset SYMBOL_FLAG_FUNCTION in symbol, and actually use\n+\tDW_EH_PE_pcrel / DW_EH_PE_absptr encoding.\n+\t(ALLOCATE_INITIAL_VALUE): Put PR on stack if prologue clobbers it.\n+\t* sh.md (movsi_media-1): New splitter.\n+\n 2003-08-06  Graeme Peterson <gp@qnx.com>\n \n \t* config/i386/nto.h: New."}, {"sha": "8128d4731f818494051216256310e43891fa0aa9", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b869f90433f1efc9849bcd4ac3265985ee2b5d31/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b869f90433f1efc9849bcd4ac3265985ee2b5d31/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=b869f90433f1efc9849bcd4ac3265985ee2b5d31", "patch": "@@ -8835,6 +8835,15 @@ scavenge_reg (HARD_REG_SET *s)\n rtx\n sh_get_pr_initial_val (void)\n {\n+  /* ??? Unfortunately, get_hard_reg_initial_val doesn't always work for the\n+     PR register on SHcompact, because it might be clobbered by the prologue.\n+     We don't know if that's the case before rtl generation is finished.  */\n+  if (TARGET_SHCOMPACT\n+      && (rtx_equal_function_value_matters\n+\t  || (current_function_args_info.call_cookie\n+\t       & ~ CALL_COOKIE_RET_TRAMP (1))\n+\t  || current_function_has_nonlocal_label))\n+    return gen_rtx_MEM (SImode, return_address_pointer_rtx);\n   return\n     get_hard_reg_initial_val (Pmode, TARGET_SHMEDIA ? PR_MEDIA_REG : PR_REG);\n }"}, {"sha": "cc94be2f74047ccc66944e738f39cc95e04ece5b", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 45, "deletions": 12, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b869f90433f1efc9849bcd4ac3265985ee2b5d31/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b869f90433f1efc9849bcd4ac3265985ee2b5d31/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=b869f90433f1efc9849bcd4ac3265985ee2b5d31", "patch": "@@ -1018,7 +1018,7 @@ extern char sh_additional_register_names[ADDREGNAMES_SIZE] \\\n    ? (MODE) == DFmode \\\n    : TARGET_REGISTER_P (REGNO) \\\n    ? ((MODE) == DImode || (MODE) == SImode) \\\n-   : (REGNO) == PR_REG ? 0\t\t\t\\\n+   : (REGNO) == PR_REG ? (MODE) == SImode \\\n    : (REGNO) == FPSCR_REG ? (MODE) == PSImode \\\n    : 1)\n \n@@ -2335,11 +2335,6 @@ while (0)\n    the stack.  */\n #define INCOMING_RETURN_ADDR_RTX \\\n   gen_rtx_REG (Pmode, TARGET_SHMEDIA ? PR_MEDIA_REG : PR_REG)\n-\n-/* libstdc++-v3/libsupc++/eh_personality.cc:__gxx_personality_v0\n-   can get confused by SHmedia return addresses when it does:\n-   ip = _Unwind_GetIP (context) - 1;  */\n-#define RETURN_ADDR_OFFSET (TARGET_SH5 ? -1 : 0)\n \f\n /* Generate necessary RTL for __builtin_saveregs().  */\n #define EXPAND_BUILTIN_SAVEREGS() sh_builtin_saveregs ()\n@@ -3101,18 +3096,30 @@ while (0)\n    register exists, so we should return -1 for invalid register numbers.  */\n #define DBX_REGISTER_NUMBER(REGNO) SH_DBX_REGISTER_NUMBER (REGNO)\n \n+/* SHcompact PR_REG used to use the encoding 241, and SHcompact FP registers\n+   used to use the encodings 245..260, but that doesn't make sense:\n+   PR_REG and PR_MEDIA_REG are actually the same register, and likewise\n+   the FP registers stay the same when switching between compact and media\n+   mode.  Hence, we also need to use the same dwarf frame coloumns.\n+   Likewise, we need to support unwind information for SHmedia registers\n+   even in compact code.  */\n #define SH_DBX_REGISTER_NUMBER(REGNO) \\\n-  (GENERAL_REGISTER_P (REGNO) \\\n+  (IN_RANGE ((REGNO), \\\n+\t     (unsigned HOST_WIDE_INT) FIRST_GENERAL_REG, \\\n+\t     FIRST_GENERAL_REG + (TARGET_SH5 ? 63U :15U)) \\\n    ? ((unsigned) (REGNO) - FIRST_GENERAL_REG) \\\n-   : FP_REGISTER_P (REGNO) \\\n+  : ((int) (REGNO) >= FIRST_FP_REG \\\n+     && ((int) (REGNO) \\\n+\t <= (FIRST_FP_REG + \\\n+\t     ((TARGET_SH5 && TARGET_FPU_ANY) ? 63 : TARGET_SH2E ? 15 : -1)))) \\\n    ? ((unsigned) (REGNO) - FIRST_FP_REG \\\n-      + (TARGET_SH5 ? (TARGET_SHCOMPACT ? 245 : 77) : 25)) \\\n+      + (TARGET_SH5 ? 77 : 25)) \\\n    : XD_REGISTER_P (REGNO) \\\n    ? ((unsigned) (REGNO) - FIRST_XD_REG + (TARGET_SH5 ? 289 : 87)) \\\n    : TARGET_REGISTER_P (REGNO) \\\n    ? ((unsigned) (REGNO) - FIRST_TARGET_REG + 68) \\\n    : (REGNO) == PR_REG \\\n-   ? (TARGET_SH5 ? 241 : 17) \\\n+   ? (TARGET_SH5 ? 18 : 17) \\\n    : (REGNO) == PR_MEDIA_REG \\\n    ? (TARGET_SH5 ? 18 : (unsigned) -1) \\\n    : (REGNO) == T_REG \\\n@@ -3472,6 +3479,27 @@ extern int rtx_equal_function_value_matters;\n #define EH_RETURN_STACKADJ_REGNO STATIC_CHAIN_REGNUM\n #define EH_RETURN_STACKADJ_RTX\tgen_rtx_REG (Pmode, EH_RETURN_STACKADJ_REGNO)\n \n+/* We have to distinguish between code and data, so that we apply\n+   datalabel where and only where appropriate.  Use textrel for code.  */\n+#define ASM_PREFERRED_EH_DATA_FORMAT(CODE, GLOBAL) \\\n+ ((flag_pic && (GLOBAL) ? DW_EH_PE_indirect : 0) \\\n+  | ((CODE) ? DW_EH_PE_textrel : flag_pic ? DW_EH_PE_pcrel : DW_EH_PE_absptr))\n+\n+/* Handle special EH pointer encodings.  Absolute, pc-relative, and\n+   indirect are handled automatically.  */\n+#define ASM_MAYBE_OUTPUT_ENCODED_ADDR_RTX(FILE, ENCODING, SIZE, ADDR, DONE) \\\n+  do { \\\n+    if (((ENCODING) & 0x70) == DW_EH_PE_textrel) \\\n+      { \\\n+\tencoding &= ~DW_EH_PE_textrel; \\\n+\tencoding |= flag_pic ? DW_EH_PE_pcrel : DW_EH_PE_absptr; \\\n+\tif (GET_CODE (ADDR) != SYMBOL_REF) \\\n+\t  abort (); \\\n+\tSYMBOL_REF_FLAGS (ADDR) |= SYMBOL_FLAG_FUNCTION; \\\n+\tif (0) goto DONE; \\\n+      } \\\n+  } while (0)\n+\n #if (defined CRT_BEGIN || defined CRT_END) && ! __SHMEDIA__\n /* SH constant pool breaks the devices in crtstuff.c to control section\n    in where code resides.  We have to write it as asm code.  */\n@@ -3487,8 +3515,13 @@ extern int rtx_equal_function_value_matters;\n #endif /* (defined CRT_BEGIN || defined CRT_END) && ! __SHMEDIA__ */\n \n #define ALLOCATE_INITIAL_VALUE(hard_reg) \\\n-  (REGNO (hard_reg) == (TARGET_SH5 ? PR_MEDIA_REG : PR_REG) \\\n-   ? (current_function_is_leaf && ! sh_pr_n_sets () \\\n+  (REGNO (hard_reg) == (TARGET_SHMEDIA ? PR_MEDIA_REG : PR_REG) \\\n+   ? (current_function_is_leaf \\\n+      && ! sh_pr_n_sets () \\\n+      && ! (TARGET_SHCOMPACT \\\n+\t    && ((current_function_args_info.call_cookie \\\n+\t\t & ~ CALL_COOKIE_RET_TRAMP (1)) \\\n+\t\t|| current_function_has_nonlocal_label)) \\\n       ? (hard_reg) \\\n       : gen_rtx_MEM (Pmode, TARGET_SH5 \\\n \t\t\t    ? (plus_constant (arg_pointer_rtx, \\"}, {"sha": "d4dd5d1287d6357212e5c6b024349a5b819ef806", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b869f90433f1efc9849bcd4ac3265985ee2b5d31/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b869f90433f1efc9849bcd4ac3265985ee2b5d31/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=b869f90433f1efc9849bcd4ac3265985ee2b5d31", "patch": "@@ -3471,6 +3471,17 @@\n \tfake\t%1,%0\"\n   [(set_attr \"type\" \"pcload,move,load,move,prget,move,store,pcload\")])\n \n+(define_split\n+  [(set (match_operand:SI 0 \"general_movdst_operand\" \"\")\n+\t(mem:SI (reg:SI RAP_REG)))]\n+  \"TARGET_SHCOMPACT\n+   && ! rtx_equal_function_value_matters\n+   && ! ((current_function_args_info.call_cookie\n+\t  & ~ CALL_COOKIE_RET_TRAMP (1))\n+\t || current_function_has_nonlocal_label)\"\n+  [(set (match_dup 0) (match_dup 1))]\n+  \"operands[1] = sh_get_pr_initial_val ();\")\n+\n (define_insn \"*movsi_media\"\n   [(set (match_operand:SI 0 \"general_movdst_operand\"\n \t        \"=r,r,r,r,m,f,m,f,r,f,*b,r,b\")"}]}