{"sha": "143eac1265ef53a189c92b11c4b1c77eab1156c9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTQzZWFjMTI2NWVmNTNhMTg5YzkyYjExYzRiMWM3N2VhYjExNTZjOQ==", "commit": {"author": {"name": "Matthew Heaney", "email": "heaney@adacore.com", "date": "2010-10-26T10:31:39Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-26T10:31:39Z"}, "message": "Makefile.rtl, [...]: Added bounded list container.\n\n2010-10-26  Matthew Heaney  <heaney@adacore.com>\n\n\t* Makefile.rtl, impunit.adb: Added bounded list container.\n\t* a-cbdlli.ads, a-cbdlli.adb: New file.\n\nFrom-SVN: r165938", "tree": {"sha": "56b2feb77372d648afb028a64370bff2eb946cc4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/56b2feb77372d648afb028a64370bff2eb946cc4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/143eac1265ef53a189c92b11c4b1c77eab1156c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/143eac1265ef53a189c92b11c4b1c77eab1156c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/143eac1265ef53a189c92b11c4b1c77eab1156c9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/143eac1265ef53a189c92b11c4b1c77eab1156c9/comments", "author": null, "committer": null, "parents": [{"sha": "98fff892cc285ce4fc076153ef8a601df70459ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98fff892cc285ce4fc076153ef8a601df70459ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98fff892cc285ce4fc076153ef8a601df70459ff"}], "stats": {"total": 2282, "additions": 2282, "deletions": 0}, "files": [{"sha": "117b1145835faeaa44ef3bbca7bbc41b758b06a9", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/143eac1265ef53a189c92b11c4b1c77eab1156c9/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/143eac1265ef53a189c92b11c4b1c77eab1156c9/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=143eac1265ef53a189c92b11c4b1c77eab1156c9", "patch": "@@ -1,3 +1,8 @@\n+2010-10-26  Matthew Heaney  <heaney@adacore.com>\n+\n+\t* Makefile.rtl, impunit.adb: Added bounded list container.\n+\t* a-cbdlli.ads, a-cbdlli.adb: New file.\n+\n 2010-10-25  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/utils2.c: Include flags.h and remove prototypes."}, {"sha": "d57d67913bc00492aae405db1058ed79774875c3", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/143eac1265ef53a189c92b11c4b1c77eab1156c9/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/143eac1265ef53a189c92b11c4b1c77eab1156c9/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=143eac1265ef53a189c92b11c4b1c77eab1156c9", "patch": "@@ -87,6 +87,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   a-calfor$(objext) \\\n   a-catizo$(objext) \\\n   a-cborse$(objext) \\\n+  a-cbdlli$(objext) \\\n   a-cborma$(objext) \\\n   a-cdlili$(objext) \\\n   a-cgaaso$(objext) \\"}, {"sha": "5ee296b49da3df2cd32dcc70d08a34800bc457e7", "filename": "gcc/ada/a-cbdlli.adb", "status": "added", "additions": 2005, "deletions": 0, "changes": 2005, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/143eac1265ef53a189c92b11c4b1c77eab1156c9/gcc%2Fada%2Fa-cbdlli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/143eac1265ef53a189c92b11c4b1c77eab1156c9/gcc%2Fada%2Fa-cbdlli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cbdlli.adb?ref=143eac1265ef53a189c92b11c4b1c77eab1156c9", "patch": "@@ -0,0 +1,2005 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--               ADA.CONTAINERS.BOUNDED_DOUBLY_LINKED_LISTS                 --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 2004-2010, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+with System;  use type System.Address;\n+\n+package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure Allocate\n+     (Container : in out List;\n+      New_Item  : Element_Type;\n+      New_Node  : out Count_Type);\n+\n+   procedure Allocate\n+     (Container : in out List;\n+      New_Node  : out Count_Type);\n+\n+   procedure Allocate\n+     (Container : in out List;\n+      Stream    : not null access Root_Stream_Type'Class;\n+      New_Node  : out Count_Type);\n+\n+   procedure Free\n+     (Container : in out List;\n+      X         : Count_Type);\n+\n+   procedure Insert_Internal\n+     (Container : in out List;\n+      Before    : Count_Type;\n+      New_Node  : Count_Type);\n+\n+   function Vet (Position : Cursor) return Boolean;\n+\n+   ---------\n+   -- \"=\" --\n+   ---------\n+\n+   function \"=\" (Left, Right : List) return Boolean is\n+      LN : Node_Array renames Left.Nodes;\n+      RN : Node_Array renames Right.Nodes;\n+\n+      LI, RI : Count_Type;\n+\n+   begin\n+      if Left'Address = Right'Address then\n+         return True;\n+      end if;\n+\n+      if Left.Length /= Right.Length then\n+         return False;\n+      end if;\n+\n+      LI := Left.First;\n+      RI := Right.First;\n+      for J in 1 .. Left.Length loop\n+         if LN (LI).Element /= RN (RI).Element then\n+            return False;\n+         end if;\n+\n+         LI := LN (LI).Next;\n+         RI := RN (RI).Next;\n+      end loop;\n+\n+      return True;\n+   end \"=\";\n+\n+   --------------\n+   -- Allocate --\n+   --------------\n+\n+   procedure Allocate\n+     (Container : in out List;\n+      New_Item  : Element_Type;\n+      New_Node  : out Count_Type)\n+   is\n+      N : Node_Array renames Container.Nodes;\n+\n+   begin\n+      if Container.Free >= 0 then\n+         New_Node := Container.Free;\n+\n+         --  We always perform the assignment first, before we\n+         --  change container state, in order to defend against\n+         --  exceptions duration assignment.\n+\n+         N (New_Node).Element := New_Item;\n+         Container.Free := N (New_Node).Next;\n+\n+      else\n+         --  A negative free store value means that the links of the nodes\n+         --  in the free store have not been initialized. In this case, the\n+         --  nodes are physically contiguous in the array, starting at the\n+         --  index that is the absolute value of the Container.Free, and\n+         --  continuing until the end of the array (Nodes'Last).\n+\n+         New_Node := abs Container.Free;\n+\n+         --  As above, we perform this assignment first, before modifying\n+         --  any container state.\n+\n+         N (New_Node).Element := New_Item;\n+         Container.Free := Container.Free - 1;\n+      end if;\n+   end Allocate;\n+\n+   procedure Allocate\n+     (Container : in out List;\n+      Stream    : not null access Root_Stream_Type'Class;\n+      New_Node  : out Count_Type)\n+   is\n+      N : Node_Array renames Container.Nodes;\n+\n+   begin\n+      if Container.Free >= 0 then\n+         New_Node := Container.Free;\n+\n+         --  We always perform the assignment first, before we\n+         --  change container state, in order to defend against\n+         --  exceptions duration assignment.\n+\n+         Element_Type'Read (Stream, N (New_Node).Element);\n+         Container.Free := N (New_Node).Next;\n+\n+      else\n+         --  A negative free store value means that the links of the nodes\n+         --  in the free store have not been initialized. In this case, the\n+         --  nodes are physically contiguous in the array, starting at the\n+         --  index that is the absolute value of the Container.Free, and\n+         --  continuing until the end of the array (Nodes'Last).\n+\n+         New_Node := abs Container.Free;\n+\n+         --  As above, we perform this assignment first, before modifying\n+         --  any container state.\n+\n+         Element_Type'Read (Stream, N (New_Node).Element);\n+         Container.Free := Container.Free - 1;\n+      end if;\n+   end Allocate;\n+\n+   procedure Allocate\n+     (Container : in out List;\n+      New_Node  : out Count_Type)\n+   is\n+      N : Node_Array renames Container.Nodes;\n+\n+   begin\n+      if Container.Free >= 0 then\n+         New_Node := Container.Free;\n+         Container.Free := N (New_Node).Next;\n+\n+      else\n+         --  As explained above, a negative free store value means that the\n+         --  links for the nodes in the free store have not been initialized.\n+\n+         New_Node := abs Container.Free;\n+         Container.Free := Container.Free - 1;\n+      end if;\n+   end Allocate;\n+\n+   ------------\n+   -- Append --\n+   ------------\n+\n+   procedure Append\n+     (Container : in out List;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type := 1)\n+   is\n+   begin\n+      Insert (Container, No_Element, New_Item, Count);\n+   end Append;\n+\n+   ------------\n+   -- Assign --\n+   ------------\n+\n+   procedure Assign (Target : in out List; Source : List) is\n+      SN : Node_Array renames Source.Nodes;\n+      J  : Count_Type;\n+\n+   begin\n+      if Target'Address = Source'Address then\n+         return;\n+      end if;\n+\n+      if Target.Capacity < Source.Length then\n+         raise Capacity_Error  -- ???\n+           with \"Target capacity is less than Source length\";\n+      end if;\n+\n+      Target.Clear;\n+\n+      J := Source.First;\n+      while J /= 0 loop\n+         Target.Append (SN (J).Element);\n+         J := SN (J).Next;\n+      end loop;\n+   end Assign;\n+\n+   -----------\n+   -- Clear --\n+   -----------\n+\n+   procedure Clear (Container : in out List) is\n+      N : Node_Array renames Container.Nodes;\n+      X : Count_Type;\n+\n+   begin\n+      if Container.Length = 0 then\n+         pragma Assert (Container.First = 0);\n+         pragma Assert (Container.Last = 0);\n+         pragma Assert (Container.Busy = 0);\n+         pragma Assert (Container.Lock = 0);\n+         return;\n+      end if;\n+\n+      pragma Assert (Container.First >= 1);\n+      pragma Assert (Container.Last >= 1);\n+      pragma Assert (N (Container.First).Prev = 0);\n+      pragma Assert (N (Container.Last).Next = 0);\n+\n+      if Container.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (list is busy)\";\n+      end if;\n+\n+      while Container.Length > 1 loop\n+         X := Container.First;\n+         pragma Assert (N (N (X).Next).Prev = Container.First);\n+\n+         Container.First := N (X).Next;\n+         N (Container.First).Prev := 0;\n+\n+         Container.Length := Container.Length - 1;\n+\n+         Free (Container, X);\n+      end loop;\n+\n+      X := Container.First;\n+      pragma Assert (X = Container.Last);\n+\n+      Container.First := 0;\n+      Container.Last := 0;\n+      Container.Length := 0;\n+\n+      Free (Container, X);\n+   end Clear;\n+\n+   --------------\n+   -- Contains --\n+   --------------\n+\n+   function Contains\n+     (Container : List;\n+      Item      : Element_Type) return Boolean\n+   is\n+   begin\n+      return Find (Container, Item) /= No_Element;\n+   end Contains;\n+\n+   ----------\n+   -- Copy --\n+   ----------\n+\n+   function Copy (Source : List; Capacity : Count_Type := 0) return List is\n+      C : Count_Type;\n+\n+   begin\n+      if Capacity = 0 then\n+         C := Source.Length;\n+\n+      elsif Capacity >= Source.Length then\n+         C := Capacity;\n+\n+      else\n+         raise Capacity_Error with \"Capacity value too small\";\n+      end if;\n+\n+      return Target : List (Capacity => C) do\n+         Assign (Target => Target, Source => Source);\n+      end return;\n+   end Copy;\n+\n+   ------------\n+   -- Delete --\n+   ------------\n+\n+   procedure Delete\n+     (Container : in out List;\n+      Position  : in out Cursor;\n+      Count     : Count_Type := 1)\n+   is\n+      N : Node_Array renames Container.Nodes;\n+      X : Count_Type;\n+\n+   begin\n+      if Position.Node = 0 then\n+         raise Constraint_Error with\n+           \"Position cursor has no element\";\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with\n+           \"Position cursor designates wrong container\";\n+      end if;\n+\n+      pragma Assert (Vet (Position), \"bad cursor in Delete\");\n+      pragma Assert (Container.First >= 1);\n+      pragma Assert (Container.Last >= 1);\n+      pragma Assert (N (Container.First).Prev = 0);\n+      pragma Assert (N (Container.Last).Next = 0);\n+\n+      if Position.Node = Container.First then\n+         Delete_First (Container, Count);\n+         Position := No_Element;\n+         return;\n+      end if;\n+\n+      if Count = 0 then\n+         Position := No_Element;\n+         return;\n+      end if;\n+\n+      if Container.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (list is busy)\";\n+      end if;\n+\n+      for Index in 1 .. Count loop\n+         pragma Assert (Container.Length >= 2);\n+\n+         X := Position.Node;\n+         Container.Length := Container.Length - 1;\n+\n+         if X = Container.Last then\n+            Position := No_Element;\n+\n+            Container.Last := N (X).Prev;\n+            N (Container.Last).Next := 0;\n+\n+            Free (Container, X);\n+            return;\n+         end if;\n+\n+         Position.Node := N (X).Next;\n+\n+         N (N (X).Next).Prev := N (X).Prev;\n+         N (N (X).Prev).Next := N (X).Next;\n+\n+         Free (Container, X);\n+      end loop;\n+\n+      Position := No_Element;\n+   end Delete;\n+\n+   ------------------\n+   -- Delete_First --\n+   ------------------\n+\n+   procedure Delete_First\n+     (Container : in out List;\n+      Count     : Count_Type := 1)\n+   is\n+      N : Node_Array renames Container.Nodes;\n+      X : Count_Type;\n+\n+   begin\n+      if Count >= Container.Length then\n+         Clear (Container);\n+         return;\n+      end if;\n+\n+      if Count = 0 then\n+         return;\n+      end if;\n+\n+      if Container.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (list is busy)\";\n+      end if;\n+\n+      for I in 1 .. Count loop\n+         X := Container.First;\n+         pragma Assert (N (N (X).Next).Prev = Container.First);\n+\n+         Container.First := N (X).Next;\n+         N (Container.First).Prev := 0;\n+\n+         Container.Length := Container.Length - 1;\n+\n+         Free (Container, X);\n+      end loop;\n+   end Delete_First;\n+\n+   -----------------\n+   -- Delete_Last --\n+   -----------------\n+\n+   procedure Delete_Last\n+     (Container : in out List;\n+      Count     : Count_Type := 1)\n+   is\n+      N : Node_Array renames Container.Nodes;\n+      X : Count_Type;\n+\n+   begin\n+      if Count >= Container.Length then\n+         Clear (Container);\n+         return;\n+      end if;\n+\n+      if Count = 0 then\n+         return;\n+      end if;\n+\n+      if Container.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (list is busy)\";\n+      end if;\n+\n+      for I in 1 .. Count loop\n+         X := Container.Last;\n+         pragma Assert (N (N (X).Prev).Next = Container.Last);\n+\n+         Container.Last := N (X).Prev;\n+         N (Container.Last).Next := 0;\n+\n+         Container.Length := Container.Length - 1;\n+\n+         Free (Container, X);\n+      end loop;\n+   end Delete_Last;\n+\n+   -------------\n+   -- Element --\n+   -------------\n+\n+   function Element (Position : Cursor) return Element_Type is\n+   begin\n+      if Position.Node = 0 then\n+         raise Constraint_Error with\n+           \"Position cursor has no element\";\n+      end if;\n+\n+      pragma Assert (Vet (Position), \"bad cursor in Element\");\n+\n+      return Position.Container.Nodes (Position.Node).Element;\n+   end Element;\n+\n+   ----------\n+   -- Find --\n+   ----------\n+\n+   function Find\n+     (Container : List;\n+      Item      : Element_Type;\n+      Position  : Cursor := No_Element) return Cursor\n+   is\n+      Nodes : Node_Array renames Container.Nodes;\n+      Node  : Count_Type := Position.Node;\n+\n+   begin\n+      if Node = 0 then\n+         Node := Container.First;\n+\n+      else\n+         if Position.Container /= Container'Unrestricted_Access then\n+            raise Program_Error with\n+              \"Position cursor designates wrong container\";\n+         end if;\n+\n+         pragma Assert (Vet (Position), \"bad cursor in Find\");\n+      end if;\n+\n+      while Node /= 0 loop\n+         if Nodes (Node).Element = Item then\n+            return Cursor'(Container'Unrestricted_Access, Node);\n+         end if;\n+\n+         Node := Nodes (Node).Next;\n+      end loop;\n+\n+      return No_Element;\n+   end Find;\n+\n+   -----------\n+   -- First --\n+   -----------\n+\n+   function First (Container : List) return Cursor is\n+   begin\n+      if Container.First = 0 then\n+         return No_Element;\n+      end if;\n+\n+      return Cursor'(Container'Unrestricted_Access, Container.First);\n+   end First;\n+\n+   -------------------\n+   -- First_Element --\n+   -------------------\n+\n+   function First_Element (Container : List) return Element_Type is\n+   begin\n+      if Container.First = 0 then\n+         raise Constraint_Error with \"list is empty\";\n+      end if;\n+\n+      return Container.Nodes (Container.First).Element;\n+   end First_Element;\n+\n+   ----------\n+   -- Free --\n+   ----------\n+\n+   procedure Free\n+     (Container : in out List;\n+      X         : Count_Type)\n+   is\n+      pragma Assert (X > 0);\n+      pragma Assert (X <= Container.Capacity);\n+\n+      N : Node_Array renames Container.Nodes;\n+      pragma Assert (N (X).Prev >= 0);  -- node is active\n+\n+   begin\n+      --  The list container actually contains two lists: one for the \"active\"\n+      --  nodes that contain elements that have been inserted onto the list,\n+      --  and another for the \"inactive\" nodes for the free store.\n+      --\n+      --  We desire that merely declaring an object should have only minimal\n+      --  cost; specially, we want to avoid having to initialize the free\n+      --  store (to fill in the links), especially if the capacity is large.\n+      --\n+      --  The head of the free list is indicated by Container.Free. If its\n+      --  value is non-negative, then the free store has been initialized\n+      --  in the \"normal\" way: Container.Free points to the head of the list\n+      --  of free (inactive) nodes, and the value 0 means the free list is\n+      --  empty. Each node on the free list has been initialized to point\n+      --  to the next free node (via its Next component), and the value 0\n+      --  means that this is the last free node.\n+      --\n+      --  If Container.Free is negative, then the links on the free store\n+      --  have not been initialized. In this case the link values are\n+      --  implied: the free store comprises the components of the node array\n+      --  started with the absolute value of Container.Free, and continuing\n+      --  until the end of the array (Nodes'Last).\n+      --\n+      --  If the list container is manipulated on one end only (for example\n+      --  if the container were being used as a stack), then there is no\n+      --  need to initialize the free store, since the inactive nodes are\n+      --  physically contiguous (in fact, they lie immediately beyond the\n+      --  logical end being manipulated). The only time we need to actually\n+      --  initialize the nodes in the free store is if the node that becomes\n+      --  inactive is not at the end of the list. The free store would then\n+      --  be discontigous and so its nodes would need to be linked in the\n+      --  traditional way.\n+      --\n+      --  ???\n+      --  It might be possible to perform an optimization here. Suppose that\n+      --  the free store can be represented as having two parts: one\n+      --  comprising the non-contiguous inactive nodes linked together\n+      --  in the normal way, and the other comprising the contiguous\n+      --  inactive nodes (that are not linked together, at the end of the\n+      --  nodes array). This would allow us to never have to initialize\n+      --  the free store, except in a lazy way as nodes become inactive.\n+\n+      --  When an element is deleted from the list container, its node\n+      --  becomes inactive, and so we set its Prev component to a negative\n+      --  value, to indicate that it is now inactive. This provides a useful\n+      --  way to detect a dangling cursor reference.\n+\n+      N (X).Prev := -1;  -- Node is deallocated (not on active list)\n+\n+      if Container.Free >= 0 then\n+         --  The free store has previously been initialized. All we need to\n+         --  do here is link the newly-free'd node onto the free list.\n+\n+         N (X).Next := Container.Free;\n+         Container.Free := X;\n+\n+      elsif X + 1 = abs Container.Free then\n+         --  The free store has not been initialized, and the node becoming\n+         --  inactive immediately precedes the start of the free store. All\n+         --  we need to do is move the start of the free store back by one.\n+\n+         N (X).Next := 0;  -- Not strictly necessary, but marginally safer\n+         Container.Free := Container.Free + 1;\n+\n+      else\n+         --  The free store has not been initialized, and the node becoming\n+         --  inactive does not immediately precede the free store. Here we\n+         --  first initialize the free store (meaning the links are given\n+         --  values in the traditional way), and then link the newly-free'd\n+         --  node onto the head of the free store.\n+\n+         --  ???\n+         --  See the comments above for an optimization opportunity. If\n+         --  the next link for a node on the free store is negative, then\n+         --  this means the remaining nodes on the free store are\n+         --  physically contiguous, starting as the absolute value of\n+         --  that index value.\n+\n+         Container.Free := abs Container.Free;\n+\n+         if Container.Free > Container.Capacity then\n+            Container.Free := 0;\n+\n+         else\n+            for I in Container.Free .. Container.Capacity - 1 loop\n+               N (I).Next := I + 1;\n+            end loop;\n+\n+            N (Container.Capacity).Next := 0;\n+         end if;\n+\n+         N (X).Next := Container.Free;\n+         Container.Free := X;\n+      end if;\n+   end Free;\n+\n+   ---------------------\n+   -- Generic_Sorting --\n+   ---------------------\n+\n+   package body Generic_Sorting is\n+\n+      ---------------\n+      -- Is_Sorted --\n+      ---------------\n+\n+      function Is_Sorted (Container : List) return Boolean is\n+         Nodes : Node_Array renames Container.Nodes;\n+         Node  : Count_Type := Container.First;\n+\n+      begin\n+         for I in 2 .. Container.Length loop\n+            if Nodes (Nodes (Node).Next).Element < Nodes (Node).Element then\n+               return False;\n+            end if;\n+\n+            Node := Nodes (Node).Next;\n+         end loop;\n+\n+         return True;\n+      end Is_Sorted;\n+\n+      -----------\n+      -- Merge --\n+      -----------\n+\n+      procedure Merge\n+        (Target : in out List;\n+         Source : in out List)\n+      is\n+         LN     : Node_Array renames Target.Nodes;\n+         RN     : Node_Array renames Source.Nodes;\n+         LI, RI : Cursor;\n+\n+      begin\n+         if Target'Address = Source'Address then\n+            return;\n+         end if;\n+\n+         if Target.Busy > 0 then\n+            raise Program_Error with\n+              \"attempt to tamper with cursors of Target (list is busy)\";\n+         end if;\n+\n+         if Source.Busy > 0 then\n+            raise Program_Error with\n+              \"attempt to tamper with cursors of Source (list is busy)\";\n+         end if;\n+\n+         LI := First (Target);\n+         RI := First (Source);\n+         while RI.Node /= 0 loop\n+            pragma Assert (RN (RI.Node).Next = 0\n+                             or else not (RN (RN (RI.Node).Next).Element <\n+                                          RN (RI.Node).Element));\n+\n+            if LI.Node = 0 then\n+               Splice (Target, No_Element, Source);\n+               return;\n+            end if;\n+\n+            pragma Assert (LN (LI.Node).Next = 0\n+                             or else not (LN (LN (LI.Node).Next).Element <\n+                                          LN (LI.Node).Element));\n+\n+            if RN (RI.Node).Element < LN (LI.Node).Element then\n+               declare\n+                  RJ : Cursor := RI;\n+                  pragma Warnings (Off, RJ);\n+               begin\n+                  RI.Node := RN (RI.Node).Next;\n+                  Splice (Target, LI, Source, RJ);\n+               end;\n+\n+            else\n+               LI.Node := LN (LI.Node).Next;\n+            end if;\n+         end loop;\n+      end Merge;\n+\n+      ----------\n+      -- Sort --\n+      ----------\n+\n+      procedure Sort (Container : in out List) is\n+         N : Node_Array renames Container.Nodes;\n+\n+         procedure Partition (Pivot, Back : Count_Type);\n+\n+         procedure Sort (Front, Back : Count_Type);\n+\n+         ---------------\n+         -- Partition --\n+         ---------------\n+\n+         procedure Partition (Pivot, Back : Count_Type) is\n+            Node : Count_Type := N (Pivot).Next;\n+\n+         begin\n+            while Node /= Back loop\n+               if N (Node).Element < N (Pivot).Element then\n+                  declare\n+                     Prev : constant Count_Type := N (Node).Prev;\n+                     Next : constant Count_Type := N (Node).Next;\n+\n+                  begin\n+                     N (Prev).Next := Next;\n+\n+                     if Next = 0 then\n+                        Container.Last := Prev;\n+                     else\n+                        N (Next).Prev := Prev;\n+                     end if;\n+\n+                     N (Node).Next := Pivot;\n+                     N (Node).Prev := N (Pivot).Prev;\n+\n+                     N (Pivot).Prev := Node;\n+\n+                     if N (Node).Prev = 0 then\n+                        Container.First := Node;\n+                     else\n+                        N (N (Node).Prev).Next := Node;\n+                     end if;\n+\n+                     Node := Next;\n+                  end;\n+\n+               else\n+                  Node := N (Node).Next;\n+               end if;\n+            end loop;\n+         end Partition;\n+\n+         ----------\n+         -- Sort --\n+         ----------\n+\n+         procedure Sort (Front, Back : Count_Type) is\n+            Pivot : constant Count_Type :=\n+                      (if Front = 0 then Container.First else N (Front).Next);\n+         begin\n+            if Pivot /= Back then\n+               Partition (Pivot, Back);\n+               Sort (Front, Pivot);\n+               Sort (Pivot, Back);\n+            end if;\n+         end Sort;\n+\n+      --  Start of processing for Sort\n+\n+      begin\n+         if Container.Length <= 1 then\n+            return;\n+         end if;\n+\n+         pragma Assert (N (Container.First).Prev = 0);\n+         pragma Assert (N (Container.Last).Next = 0);\n+\n+         if Container.Busy > 0 then\n+            raise Program_Error with\n+              \"attempt to tamper with cursors (list is busy)\";\n+         end if;\n+\n+         Sort (Front => 0, Back => 0);\n+\n+         pragma Assert (N (Container.First).Prev = 0);\n+         pragma Assert (N (Container.Last).Next = 0);\n+      end Sort;\n+\n+   end Generic_Sorting;\n+\n+   -----------------\n+   -- Has_Element --\n+   -----------------\n+\n+   function Has_Element (Position : Cursor) return Boolean is\n+   begin\n+      pragma Assert (Vet (Position), \"bad cursor in Has_Element\");\n+      return Position.Node /= 0;\n+   end Has_Element;\n+\n+   ------------\n+   -- Insert --\n+   ------------\n+\n+   procedure Insert\n+     (Container : in out List;\n+      Before    : Cursor;\n+      New_Item  : Element_Type;\n+      Position  : out Cursor;\n+      Count     : Count_Type := 1)\n+   is\n+      New_Node : Count_Type;\n+\n+   begin\n+      if Before.Container /= null then\n+         if Before.Container /= Container'Unrestricted_Access then\n+            raise Program_Error with\n+              \"Before cursor designates wrong list\";\n+         end if;\n+\n+         pragma Assert (Vet (Before), \"bad cursor in Insert\");\n+      end if;\n+\n+      if Count = 0 then\n+         Position := Before;\n+         return;\n+      end if;\n+\n+      if Container.Length > Container.Capacity - Count then\n+         raise Constraint_Error with \"new length exceeds capacity\";\n+      end if;\n+\n+      if Container.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (list is busy)\";\n+      end if;\n+\n+      Allocate (Container, New_Item, New_Node);\n+      Insert_Internal (Container, Before.Node, New_Node => New_Node);\n+      Position := Cursor'(Container'Unchecked_Access, Node => New_Node);\n+\n+      for Index in Count_Type'(2) .. Count loop\n+         Allocate (Container, New_Item, New_Node => New_Node);\n+         Insert_Internal (Container, Before.Node, New_Node => New_Node);\n+      end loop;\n+   end Insert;\n+\n+   procedure Insert\n+     (Container : in out List;\n+      Before    : Cursor;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type := 1)\n+   is\n+      Position : Cursor;\n+      pragma Unreferenced (Position);\n+   begin\n+      Insert (Container, Before, New_Item, Position, Count);\n+   end Insert;\n+\n+   procedure Insert\n+     (Container : in out List;\n+      Before    : Cursor;\n+      Position  : out Cursor;\n+      Count     : Count_Type := 1)\n+   is\n+      New_Node : Count_Type;\n+\n+   begin\n+      if Before.Container /= null then\n+         if Before.Container /= Container'Unrestricted_Access then\n+            raise Program_Error with\n+              \"Before cursor designates wrong list\";\n+         end if;\n+\n+         pragma Assert (Vet (Before), \"bad cursor in Insert\");\n+      end if;\n+\n+      if Count = 0 then\n+         Position := Before;\n+         return;\n+      end if;\n+\n+      if Container.Length > Container.Capacity - Count then\n+         raise Constraint_Error with \"new length exceeds capacity\";\n+      end if;\n+\n+      if Container.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (list is busy)\";\n+      end if;\n+\n+      Allocate (Container, New_Node => New_Node);\n+      Insert_Internal (Container, Before.Node, New_Node);\n+      Position := Cursor'(Container'Unchecked_Access, New_Node);\n+\n+      for Index in Count_Type'(2) .. Count loop\n+         Allocate (Container, New_Node => New_Node);\n+         Insert_Internal (Container, Before.Node, New_Node);\n+      end loop;\n+   end Insert;\n+\n+   ---------------------\n+   -- Insert_Internal --\n+   ---------------------\n+\n+   procedure Insert_Internal\n+     (Container : in out List;\n+      Before    : Count_Type;\n+      New_Node  : Count_Type)\n+   is\n+      N : Node_Array renames Container.Nodes;\n+\n+   begin\n+      if Container.Length = 0 then\n+         pragma Assert (Before = 0);\n+         pragma Assert (Container.First = 0);\n+         pragma Assert (Container.Last = 0);\n+\n+         Container.First := New_Node;\n+         N (Container.First).Prev := 0;\n+\n+         Container.Last := New_Node;\n+         N (Container.Last).Next := 0;\n+\n+      elsif Before = 0 then  -- means append\n+         pragma Assert (N (Container.Last).Next = 0);\n+\n+         N (Container.Last).Next := New_Node;\n+         N (New_Node).Prev := Container.Last;\n+\n+         Container.Last := New_Node;\n+         N (Container.Last).Next := 0;\n+\n+      elsif Before = Container.First then  -- means prepend\n+         pragma Assert (N (Container.First).Prev = 0);\n+\n+         N (Container.First).Prev := New_Node;\n+         N (New_Node).Next := Container.First;\n+\n+         Container.First := New_Node;\n+         N (Container.First).Prev := 0;\n+\n+      else\n+         pragma Assert (N (Container.First).Prev = 0);\n+         pragma Assert (N (Container.Last).Next = 0);\n+\n+         N (New_Node).Next := Before;\n+         N (New_Node).Prev := N (Before).Prev;\n+\n+         N (N (Before).Prev).Next := New_Node;\n+         N (Before).Prev := New_Node;\n+      end if;\n+\n+      Container.Length := Container.Length + 1;\n+   end Insert_Internal;\n+\n+   --------------\n+   -- Is_Empty --\n+   --------------\n+\n+   function Is_Empty (Container : List) return Boolean is\n+   begin\n+      return Container.Length = 0;\n+   end Is_Empty;\n+\n+   -------------\n+   -- Iterate --\n+   -------------\n+\n+   procedure Iterate\n+     (Container : List;\n+      Process   : not null access procedure (Position : Cursor))\n+   is\n+      C : List renames Container'Unrestricted_Access.all;\n+      B : Natural renames C.Busy;\n+\n+      Node : Count_Type := Container.First;\n+\n+   begin\n+      B := B + 1;\n+\n+      begin\n+         while Node /= 0 loop\n+            Process (Cursor'(Container'Unrestricted_Access, Node));\n+            Node := Container.Nodes (Node).Next;\n+         end loop;\n+      exception\n+         when others =>\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      B := B - 1;\n+   end Iterate;\n+\n+   ----------\n+   -- Last --\n+   ----------\n+\n+   function Last (Container : List) return Cursor is\n+   begin\n+      if Container.Last = 0 then\n+         return No_Element;\n+      end if;\n+\n+      return Cursor'(Container'Unrestricted_Access, Container.Last);\n+   end Last;\n+\n+   ------------------\n+   -- Last_Element --\n+   ------------------\n+\n+   function Last_Element (Container : List) return Element_Type is\n+   begin\n+      if Container.Last = 0 then\n+         raise Constraint_Error with \"list is empty\";\n+      end if;\n+\n+      return Container.Nodes (Container.Last).Element;\n+   end Last_Element;\n+\n+   ------------\n+   -- Length --\n+   ------------\n+\n+   function Length (Container : List) return Count_Type is\n+   begin\n+      return Container.Length;\n+   end Length;\n+\n+   ----------\n+   -- Move --\n+   ----------\n+\n+   procedure Move\n+     (Target : in out List;\n+      Source : in out List)\n+   is\n+      N : Node_Array renames Source.Nodes;\n+      X : Count_Type;\n+\n+   begin\n+      if Target'Address = Source'Address then\n+         return;\n+      end if;\n+\n+      if Target.Capacity < Source.Length then\n+         raise Capacity_Error with \"Source length exceeds Target capacity\";\n+      end if;\n+\n+      if Source.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors of Source (list is busy)\";\n+      end if;\n+\n+      Clear (Target);\n+\n+      while Source.Length > 0 loop\n+         X := Source.First;\n+         Append (Target, N (X).Element);\n+\n+         Source.First := N (X).Next;\n+         N (Source.First).Prev := 0;\n+\n+         Source.Length := Source.Length - 1;\n+         Free (Source, X);\n+      end loop;\n+   end Move;\n+\n+   ----------\n+   -- Next --\n+   ----------\n+\n+   procedure Next (Position : in out Cursor) is\n+   begin\n+      Position := Next (Position);\n+   end Next;\n+\n+   function Next (Position : Cursor) return Cursor is\n+   begin\n+      if Position.Node = 0 then\n+         return No_Element;\n+      end if;\n+\n+      pragma Assert (Vet (Position), \"bad cursor in Next\");\n+\n+      declare\n+         Nodes : Node_Array renames Position.Container.Nodes;\n+         Node  : constant Count_Type := Nodes (Position.Node).Next;\n+      begin\n+         if Node = 0 then\n+            return No_Element;\n+         end if;\n+\n+         return Cursor'(Position.Container, Node);\n+      end;\n+   end Next;\n+\n+   -------------\n+   -- Prepend --\n+   -------------\n+\n+   procedure Prepend\n+     (Container : in out List;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type := 1)\n+   is\n+   begin\n+      Insert (Container, First (Container), New_Item, Count);\n+   end Prepend;\n+\n+   --------------\n+   -- Previous --\n+   --------------\n+\n+   procedure Previous (Position : in out Cursor) is\n+   begin\n+      Position := Previous (Position);\n+   end Previous;\n+\n+   function Previous (Position : Cursor) return Cursor is\n+   begin\n+      if Position.Node = 0 then\n+         return No_Element;\n+      end if;\n+\n+      pragma Assert (Vet (Position), \"bad cursor in Previous\");\n+\n+      declare\n+         Nodes : Node_Array renames Position.Container.Nodes;\n+         Node  : constant Count_Type := Nodes (Position.Node).Prev;\n+      begin\n+         if Node = 0 then\n+            return No_Element;\n+         end if;\n+\n+         return Cursor'(Position.Container, Node);\n+      end;\n+   end Previous;\n+\n+   -------------------\n+   -- Query_Element --\n+   -------------------\n+\n+   procedure Query_Element\n+     (Position : Cursor;\n+      Process  : not null access procedure (Element : Element_Type))\n+   is\n+   begin\n+      if Position.Node = 0 then\n+         raise Constraint_Error with\n+           \"Position cursor has no element\";\n+      end if;\n+\n+      pragma Assert (Vet (Position), \"bad cursor in Query_Element\");\n+\n+      declare\n+         C : List renames Position.Container.all'Unrestricted_Access.all;\n+         B : Natural renames C.Busy;\n+         L : Natural renames C.Lock;\n+\n+      begin\n+         B := B + 1;\n+         L := L + 1;\n+\n+         declare\n+            N : Node_Type renames C.Nodes (Position.Node);\n+         begin\n+            Process (N.Element);\n+         exception\n+            when others =>\n+               L := L - 1;\n+               B := B - 1;\n+               raise;\n+         end;\n+\n+         L := L - 1;\n+         B := B - 1;\n+      end;\n+   end Query_Element;\n+\n+   ----------\n+   -- Read --\n+   ----------\n+\n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out List)\n+   is\n+      N : Count_Type'Base;\n+      X : Count_Type;\n+\n+   begin\n+      Clear (Item);\n+      Count_Type'Base'Read (Stream, N);\n+\n+      if N < 0 then\n+         raise Program_Error with \"bad list length (corrupt stream)\";\n+      end if;\n+\n+      if N = 0 then\n+         return;\n+      end if;\n+\n+      if N > Item.Capacity then\n+         raise Constraint_Error with \"length exceeds capacity\";\n+      end if;\n+\n+      for Idx in 1 .. N loop\n+         Allocate (Item, Stream, New_Node => X);\n+         Insert_Internal (Item, Before => 0, New_Node => X);\n+      end loop;\n+   end Read;\n+\n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Cursor)\n+   is\n+   begin\n+      raise Program_Error with \"attempt to stream list cursor\";\n+   end Read;\n+\n+   ---------------------\n+   -- Replace_Element --\n+   ---------------------\n+\n+   procedure Replace_Element\n+     (Container : in out List;\n+      Position  : Cursor;\n+      New_Item  : Element_Type)\n+   is\n+   begin\n+      if Position.Container = null then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      if Position.Container /= Container'Unchecked_Access then\n+         raise Program_Error with\n+           \"Position cursor designates wrong container\";\n+      end if;\n+\n+      if Container.Lock > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with elements (list is locked)\";\n+      end if;\n+\n+      pragma Assert (Vet (Position), \"bad cursor in Replace_Element\");\n+\n+      Container.Nodes (Position.Node).Element := New_Item;\n+   end Replace_Element;\n+\n+   ----------------------\n+   -- Reverse_Elements --\n+   ----------------------\n+\n+   procedure Reverse_Elements (Container : in out List) is\n+      N : Node_Array renames Container.Nodes;\n+      I : Count_Type := Container.First;\n+      J : Count_Type := Container.Last;\n+\n+      procedure Swap (L, R : Count_Type);\n+\n+      ----------\n+      -- Swap --\n+      ----------\n+\n+      procedure Swap (L, R : Count_Type) is\n+         LN : constant Count_Type := N (L).Next;\n+         LP : constant Count_Type := N (L).Prev;\n+\n+         RN : constant Count_Type := N (R).Next;\n+         RP : constant Count_Type := N (R).Prev;\n+\n+      begin\n+         if LP /= 0 then\n+            N (LP).Next := R;\n+         end if;\n+\n+         if RN /= 0 then\n+            N (RN).Prev := L;\n+         end if;\n+\n+         N (L).Next := RN;\n+         N (R).Prev := LP;\n+\n+         if LN = R then\n+            pragma Assert (RP = L);\n+\n+            N (L).Prev := R;\n+            N (R).Next := L;\n+\n+         else\n+            N (L).Prev := RP;\n+            N (RP).Next := L;\n+\n+            N (R).Next := LN;\n+            N (LN).Prev := R;\n+         end if;\n+      end Swap;\n+\n+   --  Start of processing for Reverse_Elements\n+\n+   begin\n+      if Container.Length <= 1 then\n+         return;\n+      end if;\n+\n+      pragma Assert (N (Container.First).Prev = 0);\n+      pragma Assert (N (Container.Last).Next = 0);\n+\n+      if Container.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (list is busy)\";\n+      end if;\n+\n+      Container.First := J;\n+      Container.Last := I;\n+      loop\n+         Swap (L => I, R => J);\n+\n+         J := N (J).Next;\n+         exit when I = J;\n+\n+         I := N (I).Prev;\n+         exit when I = J;\n+\n+         Swap (L => J, R => I);\n+\n+         I := N (I).Next;\n+         exit when I = J;\n+\n+         J := N (J).Prev;\n+         exit when I = J;\n+      end loop;\n+\n+      pragma Assert (N (Container.First).Prev = 0);\n+      pragma Assert (N (Container.Last).Next = 0);\n+   end Reverse_Elements;\n+\n+   ------------------\n+   -- Reverse_Find --\n+   ------------------\n+\n+   function Reverse_Find\n+     (Container : List;\n+      Item      : Element_Type;\n+      Position  : Cursor := No_Element) return Cursor\n+   is\n+      Node : Count_Type := Position.Node;\n+\n+   begin\n+      if Node = 0 then\n+         Node := Container.Last;\n+\n+      else\n+         if Position.Container /= Container'Unrestricted_Access then\n+            raise Program_Error with\n+              \"Position cursor designates wrong container\";\n+         end if;\n+\n+         pragma Assert (Vet (Position), \"bad cursor in Reverse_Find\");\n+      end if;\n+\n+      while Node /= 0 loop\n+         if Container.Nodes (Node).Element = Item then\n+            return Cursor'(Container'Unrestricted_Access, Node);\n+         end if;\n+\n+         Node := Container.Nodes (Node).Prev;\n+      end loop;\n+\n+      return No_Element;\n+   end Reverse_Find;\n+\n+   ---------------------\n+   -- Reverse_Iterate --\n+   ---------------------\n+\n+   procedure Reverse_Iterate\n+     (Container : List;\n+      Process   : not null access procedure (Position : Cursor))\n+   is\n+      C : List renames Container'Unrestricted_Access.all;\n+      B : Natural renames C.Busy;\n+\n+      Node : Count_Type := Container.Last;\n+\n+   begin\n+      B := B + 1;\n+\n+      begin\n+         while Node /= 0 loop\n+            Process (Cursor'(Container'Unrestricted_Access, Node));\n+            Node := Container.Nodes (Node).Prev;\n+         end loop;\n+\n+      exception\n+         when others =>\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      B := B - 1;\n+   end Reverse_Iterate;\n+\n+   ------------\n+   -- Splice --\n+   ------------\n+\n+   procedure Splice\n+     (Target : in out List;\n+      Before : Cursor;\n+      Source : in out List)\n+   is\n+   begin\n+      if Before.Container /= null then\n+         if Before.Container /= Target'Unrestricted_Access then\n+            raise Program_Error with\n+              \"Before cursor designates wrong container\";\n+         end if;\n+\n+         pragma Assert (Vet (Before), \"bad cursor in Splice\");\n+      end if;\n+\n+      if Target'Address = Source'Address\n+        or else Source.Length = 0\n+      then\n+         return;\n+      end if;\n+\n+      pragma Assert (Source.Nodes (Source.First).Prev = 0);\n+      pragma Assert (Source.Nodes (Source.Last).Next = 0);\n+\n+      if Target.Length > Count_Type'Last - Source.Length then\n+         raise Constraint_Error with \"new length exceeds maximum\";\n+      end if;\n+\n+      if Target.Length + Source.Length > Target.Capacity then\n+         raise Capacity_Error with \"new length exceeds target capacity\";\n+      end if;\n+\n+      if Target.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors of Target (list is busy)\";\n+      end if;\n+\n+      if Source.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors of Source (list is busy)\";\n+      end if;\n+\n+      loop\n+         Insert (Target, Before, Source.Nodes (Source.Last).Element);\n+         Delete_Last (Source);\n+         exit when Is_Empty (Source);\n+      end loop;\n+   end Splice;\n+\n+   procedure Splice\n+     (Container : in out List;\n+      Before    : Cursor;\n+      Position  : Cursor)\n+   is\n+      N : Node_Array renames Container.Nodes;\n+\n+   begin\n+      if Before.Container /= null then\n+         if Before.Container /= Container'Unchecked_Access then\n+            raise Program_Error with\n+              \"Before cursor designates wrong container\";\n+         end if;\n+\n+         pragma Assert (Vet (Before), \"bad Before cursor in Splice\");\n+      end if;\n+\n+      if Position.Node = 0 then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with\n+           \"Position cursor designates wrong container\";\n+      end if;\n+\n+      pragma Assert (Vet (Position), \"bad Position cursor in Splice\");\n+\n+      if Position.Node = Before.Node\n+        or else N (Position.Node).Next = Before.Node\n+      then\n+         return;\n+      end if;\n+\n+      pragma Assert (Container.Length >= 2);\n+\n+      if Container.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (list is busy)\";\n+      end if;\n+\n+      if Before.Node = 0 then\n+         pragma Assert (Position.Node /= Container.Last);\n+\n+         if Position.Node = Container.First then\n+            Container.First := N (Position.Node).Next;\n+            N (Container.First).Prev := 0;\n+         else\n+            N (N (Position.Node).Prev).Next := N (Position.Node).Next;\n+            N (N (Position.Node).Next).Prev := N (Position.Node).Prev;\n+         end if;\n+\n+         N (Container.Last).Next := Position.Node;\n+         N (Position.Node).Prev := Container.Last;\n+\n+         Container.Last := Position.Node;\n+         N (Container.Last).Next := 0;\n+\n+         return;\n+      end if;\n+\n+      if Before.Node = Container.First then\n+         pragma Assert (Position.Node /= Container.First);\n+\n+         if Position.Node = Container.Last then\n+            Container.Last := N (Position.Node).Prev;\n+            N (Container.Last).Next := 0;\n+         else\n+            N (N (Position.Node).Prev).Next := N (Position.Node).Next;\n+            N (N (Position.Node).Next).Prev := N (Position.Node).Prev;\n+         end if;\n+\n+         N (Container.First).Prev := Position.Node;\n+         N (Position.Node).Next := Container.First;\n+\n+         Container.First := Position.Node;\n+         N (Container.First).Prev := 0;\n+\n+         return;\n+      end if;\n+\n+      if Position.Node = Container.First then\n+         Container.First := N (Position.Node).Next;\n+         N (Container.First).Prev := 0;\n+\n+      elsif Position.Node = Container.Last then\n+         Container.Last := N (Position.Node).Prev;\n+         N (Container.Last).Next := 0;\n+\n+      else\n+         N (N (Position.Node).Prev).Next := N (Position.Node).Next;\n+         N (N (Position.Node).Next).Prev := N (Position.Node).Prev;\n+      end if;\n+\n+      N (N (Before.Node).Prev).Next := Position.Node;\n+      N (Position.Node).Prev := N (Before.Node).Prev;\n+\n+      N (Before.Node).Prev := Position.Node;\n+      N (Position.Node).Next := Before.Node;\n+\n+      pragma Assert (N (Container.First).Prev = 0);\n+      pragma Assert (N (Container.Last).Next = 0);\n+   end Splice;\n+\n+   procedure Splice\n+     (Target   : in out List;\n+      Before   : Cursor;\n+      Source   : in out List;\n+      Position : in out Cursor)\n+   is\n+      Target_Position : Cursor;\n+\n+   begin\n+      if Target'Address = Source'Address then\n+         Splice (Target, Before, Position);\n+         return;\n+      end if;\n+\n+      if Before.Container /= null then\n+         if Before.Container /= Target'Unrestricted_Access then\n+            raise Program_Error with\n+              \"Before cursor designates wrong container\";\n+         end if;\n+\n+         pragma Assert (Vet (Before), \"bad Before cursor in Splice\");\n+      end if;\n+\n+      if Position.Node = 0 then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      if Position.Container /= Source'Unrestricted_Access then\n+         raise Program_Error with\n+           \"Position cursor designates wrong container\";\n+      end if;\n+\n+      pragma Assert (Vet (Position), \"bad Position cursor in Splice\");\n+\n+      if Target.Length >= Target.Capacity then\n+         raise Capacity_Error with \"Target is full\";\n+      end if;\n+\n+      if Target.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors of Target (list is busy)\";\n+      end if;\n+\n+      if Source.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors of Source (list is busy)\";\n+      end if;\n+\n+      Insert\n+        (Container => Target,\n+         Before    => Before,\n+         New_Item  => Source.Nodes (Position.Node).Element,\n+         Position  => Target_Position);\n+\n+      Delete (Source, Position);\n+      Position := Target_Position;\n+   end Splice;\n+\n+   ----------\n+   -- Swap --\n+   ----------\n+\n+   procedure Swap\n+     (Container : in out List;\n+      I, J      : Cursor)\n+   is\n+   begin\n+      if I.Node = 0 then\n+         raise Constraint_Error with \"I cursor has no element\";\n+      end if;\n+\n+      if J.Node = 0 then\n+         raise Constraint_Error with \"J cursor has no element\";\n+      end if;\n+\n+      if I.Container /= Container'Unchecked_Access then\n+         raise Program_Error with \"I cursor designates wrong container\";\n+      end if;\n+\n+      if J.Container /= Container'Unchecked_Access then\n+         raise Program_Error with \"J cursor designates wrong container\";\n+      end if;\n+\n+      if I.Node = J.Node then\n+         return;\n+      end if;\n+\n+      if Container.Lock > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with elements (list is locked)\";\n+      end if;\n+\n+      pragma Assert (Vet (I), \"bad I cursor in Swap\");\n+      pragma Assert (Vet (J), \"bad J cursor in Swap\");\n+\n+      declare\n+         EI : Element_Type renames Container.Nodes (I.Node).Element;\n+         EJ : Element_Type renames Container.Nodes (J.Node).Element;\n+\n+         EI_Copy : constant Element_Type := EI;\n+\n+      begin\n+         EI := EJ;\n+         EJ := EI_Copy;\n+      end;\n+   end Swap;\n+\n+   ----------------\n+   -- Swap_Links --\n+   ----------------\n+\n+   procedure Swap_Links\n+     (Container : in out List;\n+      I, J      : Cursor)\n+   is\n+   begin\n+      if I.Node = 0 then\n+         raise Constraint_Error with \"I cursor has no element\";\n+      end if;\n+\n+      if J.Node = 0 then\n+         raise Constraint_Error with \"J cursor has no element\";\n+      end if;\n+\n+      if I.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with \"I cursor designates wrong container\";\n+      end if;\n+\n+      if J.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with \"J cursor designates wrong container\";\n+      end if;\n+\n+      if I.Node = J.Node then\n+         return;\n+      end if;\n+\n+      if Container.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (list is busy)\";\n+      end if;\n+\n+      pragma Assert (Vet (I), \"bad I cursor in Swap_Links\");\n+      pragma Assert (Vet (J), \"bad J cursor in Swap_Links\");\n+\n+      declare\n+         I_Next : constant Cursor := Next (I);\n+\n+      begin\n+         if I_Next = J then\n+            Splice (Container, Before => I, Position => J);\n+\n+         else\n+            declare\n+               J_Next : constant Cursor := Next (J);\n+\n+            begin\n+               if J_Next = I then\n+                  Splice (Container, Before => J, Position => I);\n+\n+               else\n+                  pragma Assert (Container.Length >= 3);\n+\n+                  Splice (Container, Before => I_Next, Position => J);\n+                  Splice (Container, Before => J_Next, Position => I);\n+               end if;\n+            end;\n+         end if;\n+      end;\n+   end Swap_Links;\n+\n+   --------------------\n+   -- Update_Element --\n+   --------------------\n+\n+   procedure Update_Element\n+     (Container : in out List;\n+      Position  : Cursor;\n+      Process   : not null access procedure (Element : in out Element_Type))\n+   is\n+   begin\n+      if Position.Node = 0 then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      if Position.Container /= Container'Unchecked_Access then\n+         raise Program_Error with\n+           \"Position cursor designates wrong container\";\n+      end if;\n+\n+      pragma Assert (Vet (Position), \"bad cursor in Update_Element\");\n+\n+      declare\n+         B : Natural renames Container.Busy;\n+         L : Natural renames Container.Lock;\n+\n+      begin\n+         B := B + 1;\n+         L := L + 1;\n+\n+         declare\n+            N : Node_Type renames Container.Nodes (Position.Node);\n+         begin\n+            Process (N.Element);\n+         exception\n+            when others =>\n+               L := L - 1;\n+               B := B - 1;\n+               raise;\n+         end;\n+\n+         L := L - 1;\n+         B := B - 1;\n+      end;\n+   end Update_Element;\n+\n+   ---------\n+   -- Vet --\n+   ---------\n+\n+   function Vet (Position : Cursor) return Boolean is\n+   begin\n+      if Position.Node = 0 then\n+         return Position.Container = null;\n+      end if;\n+\n+      if Position.Container = null then\n+         return False;\n+      end if;\n+\n+      declare\n+         L : List renames Position.Container.all;\n+         N : Node_Array renames L.Nodes;\n+      begin\n+         if L.Length = 0 then\n+            return False;\n+         end if;\n+\n+         if L.First = 0\n+           or L.First > L.Capacity\n+         then\n+            return False;\n+         end if;\n+\n+         if L.Last = 0\n+           or L.Last > L.Capacity\n+         then\n+            return False;\n+         end if;\n+\n+         if N (L.First).Prev /= 0 then\n+            return False;\n+         end if;\n+\n+         if N (L.Last).Next /= 0 then\n+            return False;\n+         end if;\n+\n+         if Position.Node > L.Capacity then\n+            return False;\n+         end if;\n+\n+         if N (Position.Node).Prev < 0 then  -- see Free\n+            return False;\n+         end if;\n+\n+         if N (Position.Node).Prev > L.Capacity then\n+            return False;\n+         end if;\n+\n+         if N (Position.Node).Next = Position.Node then\n+            return False;\n+         end if;\n+\n+         if N (Position.Node).Prev = Position.Node then\n+            return False;\n+         end if;\n+\n+         if N (Position.Node).Prev = 0\n+           and then Position.Node /= L.First\n+         then\n+            return False;\n+         end if;\n+\n+         --  If we get here, we know that this disjunction is true:\n+         --  N (Position.Node).Prev /= 0 or else Position.Node = L.First\n+\n+         if N (Position.Node).Next = 0\n+           and then Position.Node /= L.Last\n+         then\n+            return False;\n+         end if;\n+\n+         --  If we get here, we know that this disjunction is true:\n+         --  N (Position.Node).Next /= 0 or else Position.Node = L.Last\n+\n+         if L.Length = 1 then\n+            return L.First = L.Last;\n+         end if;\n+\n+         if L.First = L.Last then\n+            return False;\n+         end if;\n+\n+         if N (L.First).Next = 0 then\n+            return False;\n+         end if;\n+\n+         if N (L.Last).Prev = 0 then\n+            return False;\n+         end if;\n+\n+         if N (N (L.First).Next).Prev /= L.First then\n+            return False;\n+         end if;\n+\n+         if N (N (L.Last).Prev).Next /= L.Last then\n+            return False;\n+         end if;\n+\n+         if L.Length = 2 then\n+            if N (L.First).Next /= L.Last then\n+               return False;\n+            end if;\n+\n+            if N (L.Last).Prev /= L.First then\n+               return False;\n+            end if;\n+\n+            return True;\n+         end if;\n+\n+         if N (L.First).Next = L.Last then\n+            return False;\n+         end if;\n+\n+         if N (L.Last).Prev = L.First then\n+            return False;\n+         end if;\n+\n+         if Position.Node = L.First then  -- eliminates ealier disjunct\n+            return True;\n+         end if;\n+\n+         --  If we get here, we know, per disjunctive syllogism (modus\n+         --  tollendo ponens), that this predicate is true:\n+         --  N (Position.Node).Prev /= 0\n+\n+         if Position.Node = L.Last then  -- eliminates earlier disjunct\n+            return True;\n+         end if;\n+\n+         --  If we get here, we know, per disjunctive syllogism (modus\n+         --  tollendo ponens), that this predicate is true:\n+         --  N (Position.Node).Next /= 0\n+\n+         if N (N (Position.Node).Next).Prev /= Position.Node then\n+            return False;\n+         end if;\n+\n+         if N (N (Position.Node).Prev).Next /= Position.Node then\n+            return False;\n+         end if;\n+\n+         if L.Length = 3 then\n+            if N (L.First).Next /= Position.Node then\n+               return False;\n+            end if;\n+\n+            if N (L.Last).Prev /= Position.Node then\n+               return False;\n+            end if;\n+         end if;\n+\n+         return True;\n+      end;\n+   end Vet;\n+\n+   -----------\n+   -- Write --\n+   -----------\n+\n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : List)\n+   is\n+      Node : Count_Type;\n+\n+   begin\n+      Count_Type'Base'Write (Stream, Item.Length);\n+\n+      Node := Item.First;\n+      while Node /= 0 loop\n+         Element_Type'Write (Stream, Item.Nodes (Node).Element);\n+         Node := Item.Nodes (Node).Next;\n+      end loop;\n+   end Write;\n+\n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Cursor)\n+   is\n+   begin\n+      raise Program_Error with \"attempt to stream list cursor\";\n+   end Write;\n+\n+end Ada.Containers.Bounded_Doubly_Linked_Lists;"}, {"sha": "2e5d96cd58d47ecd0e897a5441260cc5ace2d76f", "filename": "gcc/ada/a-cbdlli.ads", "status": "added", "additions": 270, "deletions": 0, "changes": 270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/143eac1265ef53a189c92b11c4b1c77eab1156c9/gcc%2Fada%2Fa-cbdlli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/143eac1265ef53a189c92b11c4b1c77eab1156c9/gcc%2Fada%2Fa-cbdlli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cbdlli.ads?ref=143eac1265ef53a189c92b11c4b1c77eab1156c9", "patch": "@@ -0,0 +1,270 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--               ADA.CONTAINERS.BOUNDED_DOUBLY_LINKED_LISTS                 --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 2004-2010, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+private with Ada.Streams;\n+\n+generic\n+   type Element_Type is private;\n+\n+   with function \"=\" (Left, Right : Element_Type)\n+      return Boolean is <>;\n+\n+package Ada.Containers.Bounded_Doubly_Linked_Lists is\n+   pragma Pure;\n+   pragma Remote_Types;\n+\n+   type List (Capacity : Count_Type) is tagged private;\n+   pragma Preelaborable_Initialization (List);\n+\n+   type Cursor is private;\n+   pragma Preelaborable_Initialization (Cursor);\n+\n+   Empty_List : constant List;\n+\n+   No_Element : constant Cursor;\n+\n+   function \"=\" (Left, Right : List) return Boolean;\n+\n+   function Length (Container : List) return Count_Type;\n+\n+   function Is_Empty (Container : List) return Boolean;\n+\n+   procedure Clear (Container : in out List);\n+\n+   function Element (Position : Cursor) return Element_Type;\n+\n+   procedure Replace_Element\n+     (Container : in out List;\n+      Position  : Cursor;\n+      New_Item  : Element_Type);\n+\n+   procedure Query_Element\n+     (Position : Cursor;\n+      Process  : not null access procedure (Element : Element_Type));\n+\n+   procedure Update_Element\n+     (Container : in out List;\n+      Position  : Cursor;\n+      Process   : not null access procedure (Element : in out Element_Type));\n+\n+   procedure Assign (Target : in out List; Source : List);\n+\n+   function Copy (Source : List; Capacity : Count_Type := 0) return List;\n+\n+   procedure Move\n+     (Target : in out List;\n+      Source : in out List);\n+\n+   procedure Insert\n+     (Container : in out List;\n+      Before    : Cursor;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type := 1);\n+\n+   procedure Insert\n+     (Container : in out List;\n+      Before    : Cursor;\n+      New_Item  : Element_Type;\n+      Position  : out Cursor;\n+      Count     : Count_Type := 1);\n+\n+   procedure Insert\n+     (Container : in out List;\n+      Before    : Cursor;\n+      Position  : out Cursor;\n+      Count     : Count_Type := 1);\n+\n+   procedure Prepend\n+     (Container : in out List;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type := 1);\n+\n+   procedure Append\n+     (Container : in out List;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type := 1);\n+\n+   procedure Delete\n+     (Container : in out List;\n+      Position  : in out Cursor;\n+      Count     : Count_Type := 1);\n+\n+   procedure Delete_First\n+     (Container : in out List;\n+      Count     : Count_Type := 1);\n+\n+   procedure Delete_Last\n+     (Container : in out List;\n+      Count     : Count_Type := 1);\n+\n+   procedure Reverse_Elements (Container : in out List);\n+\n+   procedure Swap\n+     (Container : in out List;\n+      I, J      : Cursor);\n+\n+   procedure Swap_Links\n+     (Container : in out List;\n+      I, J      : Cursor);\n+\n+   procedure Splice\n+     (Target : in out List;\n+      Before : Cursor;\n+      Source : in out List);\n+\n+   procedure Splice\n+     (Target   : in out List;\n+      Before   : Cursor;\n+      Source   : in out List;\n+      Position : in out Cursor);\n+\n+   procedure Splice\n+     (Container : in out List;\n+      Before    : Cursor;\n+      Position  : Cursor);\n+\n+   function First (Container : List) return Cursor;\n+\n+   function First_Element (Container : List) return Element_Type;\n+\n+   function Last (Container : List) return Cursor;\n+\n+   function Last_Element (Container : List) return Element_Type;\n+\n+   function Next (Position : Cursor) return Cursor;\n+\n+   procedure Next (Position : in out Cursor);\n+\n+   function Previous (Position : Cursor) return Cursor;\n+\n+   procedure Previous (Position : in out Cursor);\n+\n+   function Find\n+     (Container : List;\n+      Item      : Element_Type;\n+      Position  : Cursor := No_Element) return Cursor;\n+\n+   function Reverse_Find\n+     (Container : List;\n+      Item      : Element_Type;\n+      Position  : Cursor := No_Element) return Cursor;\n+\n+   function Contains\n+     (Container : List;\n+      Item      : Element_Type) return Boolean;\n+\n+   function Has_Element (Position : Cursor) return Boolean;\n+\n+   procedure Iterate\n+     (Container : List;\n+      Process   : not null access procedure (Position : Cursor));\n+\n+   procedure Reverse_Iterate\n+     (Container : List;\n+      Process   : not null access procedure (Position : Cursor));\n+\n+   generic\n+      with function \"<\" (Left, Right : Element_Type) return Boolean is <>;\n+   package Generic_Sorting is\n+\n+      function Is_Sorted (Container : List) return Boolean;\n+\n+      procedure Sort (Container : in out List);\n+\n+      procedure Merge (Target, Source : in out List);\n+\n+   end Generic_Sorting;\n+\n+private\n+\n+   pragma Inline (Next);\n+   pragma Inline (Previous);\n+\n+   type Node_Type is record\n+      Prev    : Count_Type'Base;\n+      Next    : Count_Type;\n+      Element : Element_Type;\n+   end record;\n+\n+   type Node_Array is array (Count_Type range <>) of Node_Type;\n+\n+   type List (Capacity : Count_Type) is tagged record\n+      Nodes  : Node_Array (1 .. Capacity) := (others => <>);\n+      Free   : Count_Type'Base := -1;\n+      First  : Count_Type := 0;\n+      Last   : Count_Type := 0;\n+      Length : Count_Type := 0;\n+      Busy   : Natural := 0;\n+      Lock   : Natural := 0;\n+   end record;\n+\n+   use Ada.Streams;\n+\n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out List);\n+\n+   for List'Read use Read;\n+\n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : List);\n+\n+   for List'Write use Write;\n+\n+   type List_Access is access all List;\n+   for List_Access'Storage_Size use 0;\n+\n+   type Cursor is\n+      record\n+         Container : List_Access;\n+         Node      : Count_Type := 0;\n+      end record;\n+\n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Cursor);\n+\n+   for Cursor'Read use Read;\n+\n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Cursor);\n+\n+   for Cursor'Write use Write;\n+\n+   Empty_List : constant List := (Capacity => 0, others => <>);\n+\n+   No_Element : constant Cursor := Cursor'(null, 0);\n+\n+end Ada.Containers.Bounded_Doubly_Linked_Lists;"}, {"sha": "267b48d88d5172c3a9fc386c18677b8bea3fa625", "filename": "gcc/ada/impunit.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/143eac1265ef53a189c92b11c4b1c77eab1156c9/gcc%2Fada%2Fimpunit.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/143eac1265ef53a189c92b11c4b1c77eab1156c9/gcc%2Fada%2Fimpunit.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fimpunit.adb?ref=143eac1265ef53a189c92b11c4b1c77eab1156c9", "patch": "@@ -508,6 +508,7 @@ package body Impunit is\n      \"s-multip\",    -- System.Multiprocessors\n      \"s-mudido\",    -- System.Multiprocessors.Dispatching_Domains\n      \"a-cobove\",    -- Ada.Containers.Bounded_Vectors\n+     \"a-cbdlli\",    -- Ada.Containers.Bounded_Doubly_Linked_Lists\n      \"a-cborse\",    -- Ada.Containers.Bounded_Ordered_Sets\n      \"a-cborma\");   -- Ada.Containers.Bounded_Ordered_Maps\n "}]}