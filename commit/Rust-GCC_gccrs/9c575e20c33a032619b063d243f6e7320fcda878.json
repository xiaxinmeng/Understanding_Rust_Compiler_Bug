{"sha": "9c575e20c33a032619b063d243f6e7320fcda878", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWM1NzVlMjBjMzNhMDMyNjE5YjA2M2QyNDNmNmU3MzIwZmNkYTg3OA==", "commit": {"author": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2011-04-16T15:43:31Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2011-04-16T15:43:31Z"}, "message": "predicates.md: Reorganize and simplify predicates.\n\n\t* config/pa/predicates.md: Reorganize and simplify predicates.\n\tEliminate duplicate code checks.\n\t(arith_operand): Rename to arith14_operand\n\t(reg_or_ior_operand): Rename to reg_or_cint_ior_operand.\n\t* config/pa/pa.md: Use renamed operands.\n\t* config/pa/pa-protos.h (symbolic_operand): Delete declaration.\n\t(tls_symbolic_operand, function_label_operand, lhs_lshift_cint_operand,\n\tarith11_operand, adddi3_operand, indexed_memory_operand,\n\tsymbolic_memory_operand, int11_operand, reg_or_cint_move_operand,\n\tarith5_operand, uint5_operand, pic_label_operand, plus_xor_ior_operator,\n\tborx_reg_operand, shadd_operand, arith_operand, read_only_operand,\n\tmove_dest_operand, move_src_operand, prefetch_cc_operand,\n\tprefetch_nocc_operand, and_operand, ior_operand, arith32_operand,\n\tuint32_operand, reg_before_reload_operand, reg_or_0_operand,\n\treg_or_0_or_nonsymb_mem_operand, pre_cint_operand, post_cint_operand,\n\tdiv_operand, int5_operand, movb_comparison_operator,\n\tireg_or_int5_operand, call_operand_address, ior_operand, fp_reg_operand,\n\tarith_double_operand, ireg_operand, lhs_lshift_operand,\n\tpc_or_label_operand, non_hard_reg_operand, eq_neq_comparison_operator,\n\tinteger_store_memory_operand): Likewise.\n\t* config/pa/pa.c (adddi3_operand): Move to predicates.md.\n\t(integer_store_memory_operand, read_only_operand,\n\tfunction_label_operand, borx_reg_operand,\n\tnon_hard_reg_operand): Likewise.\n\t(eq_neq_comparison_operator): Delete unused operator.\n\t(legitimize_pic_address): Use VOIDmode for mode argument in calls to\n\tfunction_label_operand.\n\t(emit_move_sequence): Likewise.\n\nFrom-SVN: r172588", "tree": {"sha": "bf143605c7897773a7ac961bc3196b22138a61f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf143605c7897773a7ac961bc3196b22138a61f7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9c575e20c33a032619b063d243f6e7320fcda878", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c575e20c33a032619b063d243f6e7320fcda878", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c575e20c33a032619b063d243f6e7320fcda878", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c575e20c33a032619b063d243f6e7320fcda878/comments", "author": null, "committer": null, "parents": [{"sha": "8dfb9f1682f383bff54945902aa8a32b0536aff7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8dfb9f1682f383bff54945902aa8a32b0536aff7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8dfb9f1682f383bff54945902aa8a32b0536aff7"}], "stats": {"total": 914, "additions": 386, "deletions": 528}, "files": [{"sha": "ab56250f147e9234d4ced1b76dd9ebea1c69ab74", "filename": "gcc/config/pa/pa-protos.h", "status": "modified", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c575e20c33a032619b063d243f6e7320fcda878/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c575e20c33a032619b063d243f6e7320fcda878/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-protos.h?ref=9c575e20c33a032619b063d243f6e7320fcda878", "patch": "@@ -21,14 +21,10 @@ along with GCC; see the file COPYING3.  If not see\n \n #ifdef RTX_CODE\n /* Prototype function used in various macros.  */\n-extern int symbolic_operand (rtx, enum machine_mode);\n-extern int tls_symbolic_operand (rtx);\n extern rtx pa_eh_return_handler_rtx (void);\n \n /* Used in insn-*.c.  */\n extern int following_call (rtx);\n-extern int function_label_operand (rtx, enum machine_mode);\n-extern int lhs_lshift_cint_operand (rtx, enum machine_mode);\n \n /* Define functions in pa.c and used in insn-output.c.  */\n \n@@ -58,44 +54,11 @@ extern void output_global_address (FILE *, rtx, int);\n extern void print_operand (FILE *, rtx, int);\n extern rtx legitimize_pic_address (rtx, enum machine_mode, rtx);\n extern void hppa_encode_label (rtx);\n-extern int arith11_operand (rtx, enum machine_mode);\n-extern int adddi3_operand (rtx, enum machine_mode);\n-extern int indexed_memory_operand (rtx, enum machine_mode);\n extern int symbolic_expression_p (rtx);\n-extern int symbolic_memory_operand (rtx, enum machine_mode);\n extern bool pa_tls_referenced_p (rtx);\n extern int pa_adjust_insn_length (rtx, int);\n-extern int int11_operand (rtx, enum machine_mode);\n-extern int reg_or_cint_move_operand (rtx, enum machine_mode);\n-extern int arith5_operand (rtx, enum machine_mode);\n-extern int uint5_operand (rtx, enum machine_mode);\n-extern int pic_label_operand (rtx, enum machine_mode);\n-extern int plus_xor_ior_operator (rtx, enum machine_mode);\n-extern int borx_reg_operand (rtx, enum machine_mode);\n-extern int shadd_operand (rtx, enum machine_mode);\n-extern int arith_operand (rtx, enum machine_mode);\n-extern int read_only_operand (rtx, enum machine_mode);\n-extern int move_dest_operand (rtx, enum machine_mode);\n-extern int move_src_operand (rtx, enum machine_mode);\n-extern int prefetch_cc_operand (rtx, enum machine_mode);\n-extern int prefetch_nocc_operand (rtx, enum machine_mode);\n-extern int and_operand (rtx, enum machine_mode);\n-extern int ior_operand (rtx, enum machine_mode);\n-extern int arith32_operand (rtx, enum machine_mode);\n-extern int uint32_operand (rtx, enum machine_mode);\n-extern int reg_before_reload_operand (rtx, enum machine_mode);\n-extern int reg_or_0_operand (rtx, enum machine_mode);\n-extern int reg_or_0_or_nonsymb_mem_operand (rtx, enum machine_mode);\n-extern int pre_cint_operand (rtx, enum machine_mode);\n-extern int post_cint_operand (rtx, enum machine_mode);\n-extern int div_operand (rtx, enum machine_mode);\n-extern int int5_operand (rtx, enum machine_mode);\n-extern int movb_comparison_operator (rtx, enum machine_mode);\n-extern int ireg_or_int5_operand (rtx, enum machine_mode);\n extern int fmpyaddoperands (rtx *);\n extern int fmpysuboperands (rtx *);\n-extern int call_operand_address (rtx, enum machine_mode);\n-extern int ior_operand (rtx, enum machine_mode);\n extern void emit_bcond_fp (rtx[]);\n extern int emit_move_sequence (rtx *, enum machine_mode, rtx);\n extern int emit_hpdiv_const (rtx *, int);\n@@ -111,24 +74,16 @@ extern int attr_length_save_restore_dltp (rtx);\n \n extern struct rtx_def *return_addr_rtx (int, rtx);\n \n-extern int fp_reg_operand (rtx, enum machine_mode);\n-extern int arith_double_operand (rtx, enum machine_mode);\n-extern int ireg_operand (rtx, enum machine_mode);\n-extern int lhs_lshift_operand (rtx, enum machine_mode);\n-extern int pc_or_label_operand (rtx, enum machine_mode);\n #ifdef ARGS_SIZE_RTX\n /* expr.h defines ARGS_SIZE_RTX and `enum direction' */\n #ifdef TREE_CODE\n extern enum direction function_arg_padding (enum machine_mode, const_tree);\n #endif\n #endif /* ARGS_SIZE_RTX */\n-extern int non_hard_reg_operand (rtx, enum machine_mode);\n-extern int eq_neq_comparison_operator (rtx, enum machine_mode);\n extern int insn_refs_are_delayed (rtx);\n extern rtx get_deferred_plabel (rtx);\n #endif /* RTX_CODE */\n \n-extern int integer_store_memory_operand (rtx, enum machine_mode);\n extern int ldil_cint_p (HOST_WIDE_INT);\n extern int zdepi_cint_p (unsigned HOST_WIDE_INT);\n "}, {"sha": "e05cf192344404353859ca05043deba1665366dd", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 6, "deletions": 106, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c575e20c33a032619b063d243f6e7320fcda878/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c575e20c33a032619b063d243f6e7320fcda878/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=9c575e20c33a032619b063d243f6e7320fcda878", "patch": "@@ -739,35 +739,6 @@ cint_ok_for_move (HOST_WIDE_INT ival)\n \t  || zdepi_cint_p (ival));\n }\n \f\n-/* Return truth value of whether OP can be used as an operand in a\n-   adddi3 insn.  */\n-int\n-adddi3_operand (rtx op, enum machine_mode mode)\n-{\n-  return (register_operand (op, mode)\n-\t  || (GET_CODE (op) == CONST_INT\n-\t      && (TARGET_64BIT ? INT_14_BITS (op) : INT_11_BITS (op))));\n-}\n-\n-/* True iff the operand OP can be used as the destination operand of\n-   an integer store.  This also implies the operand could be used as\n-   the source operand of an integer load.  Symbolic, lo_sum and indexed\n-   memory operands are not allowed.  We accept reloading pseudos and\n-   other memory operands.  */\n-int\n-integer_store_memory_operand (rtx op, enum machine_mode mode)\n-{\n-  return ((reload_in_progress\n-\t   && REG_P (op)\n-\t   && REGNO (op) >= FIRST_PSEUDO_REGISTER\n-\t   && reg_renumber [REGNO (op)] < 0)\n-\t  || (GET_CODE (op) == MEM\n-\t      && (reload_in_progress || memory_address_p (mode, XEXP (op, 0)))\n-\t      && !symbolic_memory_operand (op, VOIDmode)\n-\t      && !IS_LO_SUM_DLT_ADDR_P (XEXP (op, 0))\n-\t      && !IS_INDEX_ADDR_P (XEXP (op, 0))));\n-}\n-\n /* True iff ldil can be used to load this CONST_INT.  The least\n    significant 11 bits of the value must be zero and the value must\n    not change sign when extended from 32 to 64 bits.  */\n@@ -875,7 +846,7 @@ legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)\n       tmp_reg = ((reload_in_progress || reload_completed)\n \t\t ? reg : gen_reg_rtx (Pmode));\n \n-      if (function_label_operand (orig, mode))\n+      if (function_label_operand (orig, VOIDmode))\n \t{\n \t  /* Force function label into memory in word mode.  */\n \t  orig = XEXP (force_const_mem (word_mode, orig), 0);\n@@ -1937,7 +1908,7 @@ emit_move_sequence (rtx *operands, enum machine_mode mode, rtx scratch_reg)\n      not consider them legitimate constants.  Loop optimizations can\n      call the emit_move_xxx with one as a source.  */\n   if ((GET_CODE (operand1) != HIGH && immediate_operand (operand1, mode))\n-      || function_label_operand (operand1, mode)\n+      || function_label_operand (operand1, VOIDmode)\n       || (GET_CODE (operand1) == HIGH\n \t  && symbolic_operand (XEXP (operand1, 0), mode)))\n     {\n@@ -1957,8 +1928,9 @@ emit_move_sequence (rtx *operands, enum machine_mode mode, rtx scratch_reg)\n \t     the memory location, then add in the constant part.  */\n \t  if ((GET_CODE (operand1) == CONST\n \t       && GET_CODE (XEXP (operand1, 0)) == PLUS\n-\t       && function_label_operand (XEXP (XEXP (operand1, 0), 0), Pmode))\n-\t      || function_label_operand (operand1, mode))\n+\t       && function_label_operand (XEXP (XEXP (operand1, 0), 0),\n+\t\t\t\t\t  VOIDmode))\n+\t      || function_label_operand (operand1, VOIDmode))\n \t    {\n \t      rtx temp, const_part;\n \n@@ -2303,28 +2275,6 @@ reloc_needed (tree exp)\n   return reloc;\n }\n \n-/* Does operand (which is a symbolic_operand) live in text space?\n-   If so, SYMBOL_REF_FLAG, which is set by pa_encode_section_info,\n-   will be true.  */\n-\n-int\n-read_only_operand (rtx operand, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  if (GET_CODE (operand) == CONST)\n-    operand = XEXP (XEXP (operand, 0), 0);\n-  if (flag_pic)\n-    {\n-      if (GET_CODE (operand) == SYMBOL_REF)\n-\treturn SYMBOL_REF_FLAG (operand) && !CONSTANT_POOL_ADDRESS_P (operand);\n-    }\n-  else\n-    {\n-      if (GET_CODE (operand) == SYMBOL_REF)\n-\treturn SYMBOL_REF_FLAG (operand) || CONSTANT_POOL_ADDRESS_P (operand);\n-    }\n-  return 1;\n-}\n-\n \f\n /* Return the best assembler insn template\n    for moving operands[1] into operands[0] as a fullword.  */\n@@ -8190,12 +8140,6 @@ pa_strip_name_encoding (const char *str)\n   return str;\n }\n \n-int\n-function_label_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return GET_CODE (op) == SYMBOL_REF && FUNCTION_NAME_P (XSTR (op, 0));\n-}\n-\n /* Returns 1 if OP is a function label involved in a simple addition\n    with a constant.  Used to keep certain patterns from matching\n    during instruction combination.  */\n@@ -8207,7 +8151,7 @@ is_function_label_plus_const (rtx op)\n     op = XEXP (op, 0);\n \n   return (GET_CODE (op) == PLUS\n-\t  && function_label_operand (XEXP (op, 0), Pmode)\n+\t  && function_label_operand (XEXP (op, 0), VOIDmode)\n \t  && GET_CODE (XEXP (op, 1)) == CONST_INT);\n }\n \n@@ -8769,43 +8713,6 @@ shadd_constant_p (int val)\n     return 0;\n }\n \n-/* Return 1 if OP is valid as a base or index register in a\n-   REG+REG address.  */\n-\n-int\n-borx_reg_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_CODE (op) != REG)\n-    return 0;\n-\n-  /* We must reject virtual registers as the only expressions that\n-     can be instantiated are REG and REG+CONST.  */\n-  if (op == virtual_incoming_args_rtx\n-      || op == virtual_stack_vars_rtx\n-      || op == virtual_stack_dynamic_rtx\n-      || op == virtual_outgoing_args_rtx\n-      || op == virtual_cfa_rtx)\n-    return 0;\n-\n-  /* While it's always safe to index off the frame pointer, it's not\n-     profitable to do so when the frame pointer is being eliminated.  */\n-  if (!reload_completed\n-      && flag_omit_frame_pointer\n-      && !cfun->calls_alloca\n-      && op == frame_pointer_rtx)\n-    return 0;\n-\n-  return register_operand (op, mode);\n-}\n-\n-/* Return 1 if this operand is anything other than a hard register.  */\n-\n-int\n-non_hard_reg_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return ! (GET_CODE (op) == REG && REGNO (op) < FIRST_PSEUDO_REGISTER);\n-}\n-\n /* Return TRUE if INSN branches forward.  */\n \n static bool\n@@ -8830,13 +8737,6 @@ forward_branch_p (rtx insn)\n   return false;\n }\n \n-/* Return 1 if OP is an equality comparison, else return 0.  */\n-int\n-eq_neq_comparison_operator (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return (GET_CODE (op) == EQ || GET_CODE (op) == NE);\n-}\n-\n /* Return 1 if INSN is in the delay slot of a call instruction.  */\n int\n jump_in_call_delay (rtx insn)"}, {"sha": "7b22a013ce7f740cadf4aa6bb0de2aaebfcd1181", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c575e20c33a032619b063d243f6e7320fcda878/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c575e20c33a032619b063d243f6e7320fcda878/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=9c575e20c33a032619b063d243f6e7320fcda878", "patch": "@@ -106,11 +106,11 @@\n \t\t       (const_int 8) (const_int 4))\n \n \t (eq_attr \"type\" \"binary,shift,nullshift\")\n-\t (if_then_else (match_operand 2 \"arith_operand\" \"\")\n+\t (if_then_else (match_operand 2 \"arith14_operand\" \"\")\n \t\t       (const_int 4) (const_int 12))\n \n \t (eq_attr \"type\" \"move,unary,shift,nullshift\")\n-\t (if_then_else (match_operand 1 \"arith_operand\" \"\")\n+\t (if_then_else (match_operand 1 \"arith14_operand\" \"\")\n \t\t       (const_int 4) (const_int 8))]\n \n \t(const_int 4)))\n@@ -3063,7 +3063,7 @@\n \t      (clobber (match_dup 6))\n \t      (clobber (match_dup 7))\n \t      (clobber (match_dup 8))\n-\t      (use (match_operand:SI 2 \"arith_operand\" \"\"))\n+\t      (use (match_operand:SI 2 \"arith14_operand\" \"\"))\n \t      (use (match_operand:SI 3 \"const_int_operand\" \"\"))])]\n   \"!TARGET_64BIT && optimize > 0\"\n   \"\n@@ -3143,7 +3143,7 @@\n    (clobber (match_operand:SI 6 \"register_operand\" \"=&r,&r\"))\t;item tmp2\n    (clobber (match_operand:SI 7 \"register_operand\" \"=&r,&r\"))\t;item tmp3\n    (clobber (match_operand:SI 8 \"register_operand\" \"=&r,&r\"))\t;item tmp4\n-   (use (match_operand:SI 4 \"arith_operand\" \"J,2\"))\t ;byte count\n+   (use (match_operand:SI 4 \"arith14_operand\" \"J,2\"))\t ;byte count\n    (use (match_operand:SI 5 \"const_int_operand\" \"n,n\"))] ;alignment\n   \"!TARGET_64BIT\"\n   \"#\"\n@@ -3157,7 +3157,7 @@\n \t      (clobber (match_operand:SI 6 \"register_operand\" \"\"))\n \t      (clobber (match_operand:SI 7 \"register_operand\" \"\"))\n \t      (clobber (match_operand:SI 8 \"register_operand\" \"\"))\n-\t      (use (match_operand:SI 4 \"arith_operand\" \"\"))\n+\t      (use (match_operand:SI 4 \"arith14_operand\" \"\"))\n \t      (use (match_operand:SI 5 \"const_int_operand\" \"\"))])]\n   \"!TARGET_64BIT && reload_completed && !flag_peephole2\n    && GET_CODE (operands[0]) == MEM\n@@ -3191,7 +3191,7 @@\n \t      (clobber (match_operand:SI 6 \"register_operand\" \"\"))\n \t      (clobber (match_operand:SI 7 \"register_operand\" \"\"))\n \t      (clobber (match_operand:SI 8 \"register_operand\" \"\"))\n-\t      (use (match_operand:SI 4 \"arith_operand\" \"\"))\n+\t      (use (match_operand:SI 4 \"arith14_operand\" \"\"))\n \t      (use (match_operand:SI 5 \"const_int_operand\" \"\"))])]\n   \"!TARGET_64BIT\n    && GET_CODE (operands[0]) == MEM\n@@ -3236,7 +3236,7 @@\n    (clobber (match_operand:SI 6 \"register_operand\" \"=&r,&r\"))\t;item tmp2\n    (clobber (match_dup 0))\n    (clobber (match_dup 1))\n-   (use (match_operand:SI 4 \"arith_operand\" \"J,2\"))\t ;byte count\n+   (use (match_operand:SI 4 \"arith14_operand\" \"J,2\"))\t ;byte count\n    (use (match_operand:SI 5 \"const_int_operand\" \"n,n\"))  ;alignment\n    (const_int 0)]\n   \"!TARGET_64BIT && reload_completed\"\n@@ -3251,7 +3251,7 @@\n \t      (clobber (match_dup 6))\n \t      (clobber (match_dup 7))\n \t      (clobber (match_dup 8))\n-\t      (use (match_operand:DI 2 \"arith_operand\" \"\"))\n+\t      (use (match_operand:DI 2 \"arith14_operand\" \"\"))\n \t      (use (match_operand:DI 3 \"const_int_operand\" \"\"))])]\n   \"TARGET_64BIT && optimize > 0\"\n   \"\n@@ -3331,7 +3331,7 @@\n    (clobber (match_operand:DI 6 \"register_operand\" \"=&r,&r\"))\t;item tmp2\n    (clobber (match_operand:DI 7 \"register_operand\" \"=&r,&r\"))\t;item tmp3\n    (clobber (match_operand:DI 8 \"register_operand\" \"=&r,&r\"))\t;item tmp4\n-   (use (match_operand:DI 4 \"arith_operand\" \"J,2\"))\t ;byte count\n+   (use (match_operand:DI 4 \"arith14_operand\" \"J,2\"))\t ;byte count\n    (use (match_operand:DI 5 \"const_int_operand\" \"n,n\"))] ;alignment\n   \"TARGET_64BIT\"\n   \"#\"\n@@ -3345,7 +3345,7 @@\n \t      (clobber (match_operand:DI 6 \"register_operand\" \"\"))\n \t      (clobber (match_operand:DI 7 \"register_operand\" \"\"))\n \t      (clobber (match_operand:DI 8 \"register_operand\" \"\"))\n-\t      (use (match_operand:DI 4 \"arith_operand\" \"\"))\n+\t      (use (match_operand:DI 4 \"arith14_operand\" \"\"))\n \t      (use (match_operand:DI 5 \"const_int_operand\" \"\"))])]\n   \"TARGET_64BIT && reload_completed && !flag_peephole2\n    && GET_CODE (operands[0]) == MEM\n@@ -3379,7 +3379,7 @@\n \t      (clobber (match_operand:DI 6 \"register_operand\" \"\"))\n \t      (clobber (match_operand:DI 7 \"register_operand\" \"\"))\n \t      (clobber (match_operand:DI 8 \"register_operand\" \"\"))\n-\t      (use (match_operand:DI 4 \"arith_operand\" \"\"))\n+\t      (use (match_operand:DI 4 \"arith14_operand\" \"\"))\n \t      (use (match_operand:DI 5 \"const_int_operand\" \"\"))])]\n   \"TARGET_64BIT\n    && GET_CODE (operands[0]) == MEM\n@@ -3424,7 +3424,7 @@\n    (clobber (match_operand:DI 6 \"register_operand\" \"=&r,&r\"))\t;item tmp2\n    (clobber (match_dup 0))\n    (clobber (match_dup 1))\n-   (use (match_operand:DI 4 \"arith_operand\" \"J,2\"))\t ;byte count\n+   (use (match_operand:DI 4 \"arith14_operand\" \"J,2\"))\t ;byte count\n    (use (match_operand:DI 5 \"const_int_operand\" \"n,n\"))  ;alignment\n    (const_int 0)]\n   \"TARGET_64BIT && reload_completed\"\n@@ -3436,7 +3436,7 @@\n \t\t   (match_operand 2 \"const_int_operand\" \"\"))\n \t      (clobber (match_dup 4))\n \t      (clobber (match_dup 5))\n-\t      (use (match_operand:SI 1 \"arith_operand\" \"\"))\n+\t      (use (match_operand:SI 1 \"arith14_operand\" \"\"))\n \t      (use (match_operand:SI 3 \"const_int_operand\" \"\"))])]\n   \"!TARGET_64BIT && optimize > 0\"\n   \"\n@@ -3476,7 +3476,7 @@\n \t(const_int 0))\n    (clobber (match_operand:SI 1 \"register_operand\" \"=&r,&r\"))\t;loop cnt/tmp\n    (clobber (match_operand:SI 4 \"register_operand\" \"=&r,&r\"))\t;tmp1\n-   (use (match_operand:SI 2 \"arith_operand\" \"J,1\"))\t ;byte count\n+   (use (match_operand:SI 2 \"arith14_operand\" \"J,1\"))\t ;byte count\n    (use (match_operand:SI 3 \"const_int_operand\" \"n,n\"))] ;alignment\n   \"!TARGET_64BIT\"\n   \"#\"\n@@ -3487,7 +3487,7 @@\n \t\t   (const_int 0))\n \t      (clobber (match_operand:SI 1 \"register_operand\" \"\"))\n \t      (clobber (match_operand:SI 4 \"register_operand\" \"\"))\n-\t      (use (match_operand:SI 2 \"arith_operand\" \"\"))\n+\t      (use (match_operand:SI 2 \"arith14_operand\" \"\"))\n \t      (use (match_operand:SI 3 \"const_int_operand\" \"\"))])]\n   \"!TARGET_64BIT && reload_completed && !flag_peephole2\n    && GET_CODE (operands[0]) == MEM\n@@ -3510,7 +3510,7 @@\n \t\t   (const_int 0))\n \t      (clobber (match_operand:SI 1 \"register_operand\" \"\"))\n \t      (clobber (match_operand:SI 4 \"register_operand\" \"\"))\n-\t      (use (match_operand:SI 2 \"arith_operand\" \"\"))\n+\t      (use (match_operand:SI 2 \"arith14_operand\" \"\"))\n \t      (use (match_operand:SI 3 \"const_int_operand\" \"\"))])]\n   \"!TARGET_64BIT\n    && GET_CODE (operands[0]) == MEM\n@@ -3538,7 +3538,7 @@\n \t(const_int 0))\n    (clobber (match_operand:SI 1 \"register_operand\" \"=&r,&r\"))\t;loop cnt/tmp\n    (clobber (match_dup 0))\n-   (use (match_operand:SI 2 \"arith_operand\" \"J,1\"))\t ;byte count\n+   (use (match_operand:SI 2 \"arith14_operand\" \"J,1\"))\t ;byte count\n    (use (match_operand:SI 3 \"const_int_operand\" \"n,n\"))  ;alignment\n    (const_int 0)]\n   \"!TARGET_64BIT && reload_completed\"\n@@ -3550,7 +3550,7 @@\n \t\t   (match_operand 2 \"const_int_operand\" \"\"))\n \t      (clobber (match_dup 4))\n \t      (clobber (match_dup 5))\n-\t      (use (match_operand:DI 1 \"arith_operand\" \"\"))\n+\t      (use (match_operand:DI 1 \"arith14_operand\" \"\"))\n \t      (use (match_operand:DI 3 \"const_int_operand\" \"\"))])]\n   \"TARGET_64BIT && optimize > 0\"\n   \"\n@@ -3590,7 +3590,7 @@\n \t(const_int 0))\n    (clobber (match_operand:DI 1 \"register_operand\" \"=&r,&r\"))\t;loop cnt/tmp\n    (clobber (match_operand:DI 4 \"register_operand\" \"=&r,&r\"))\t;item tmp1\n-   (use (match_operand:DI 2 \"arith_operand\" \"J,1\"))\t ;byte count\n+   (use (match_operand:DI 2 \"arith14_operand\" \"J,1\"))\t ;byte count\n    (use (match_operand:DI 3 \"const_int_operand\" \"n,n\"))] ;alignment\n   \"TARGET_64BIT\"\n   \"#\"\n@@ -3601,7 +3601,7 @@\n \t\t   (const_int 0))\n \t      (clobber (match_operand:DI 1 \"register_operand\" \"\"))\n \t      (clobber (match_operand:DI 4 \"register_operand\" \"\"))\n-\t      (use (match_operand:DI 2 \"arith_operand\" \"\"))\n+\t      (use (match_operand:DI 2 \"arith14_operand\" \"\"))\n \t      (use (match_operand:DI 3 \"const_int_operand\" \"\"))])]\n   \"TARGET_64BIT && reload_completed && !flag_peephole2\n    && GET_CODE (operands[0]) == MEM\n@@ -3624,7 +3624,7 @@\n \t\t   (const_int 0))\n \t      (clobber (match_operand:DI 1 \"register_operand\" \"\"))\n \t      (clobber (match_operand:DI 4 \"register_operand\" \"\"))\n-\t      (use (match_operand:DI 2 \"arith_operand\" \"\"))\n+\t      (use (match_operand:DI 2 \"arith14_operand\" \"\"))\n \t      (use (match_operand:DI 3 \"const_int_operand\" \"\"))])]\n   \"TARGET_64BIT\n    && GET_CODE (operands[0]) == MEM\n@@ -3652,7 +3652,7 @@\n \t(const_int 0))\n    (clobber (match_operand:DI 1 \"register_operand\" \"=&r,&r\"))\t;loop cnt/tmp\n    (clobber (match_dup 0))\n-   (use (match_operand:DI 2 \"arith_operand\" \"J,1\"))\t ;byte count\n+   (use (match_operand:DI 2 \"arith14_operand\" \"J,1\"))\t ;byte count\n    (use (match_operand:DI 3 \"const_int_operand\" \"n,n\"))  ;alignment\n    (const_int 0)]\n   \"TARGET_64BIT && reload_completed\"\n@@ -4941,7 +4941,7 @@\n (define_insn \"\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n \t(plus:DI (match_operand:DI 1 \"register_operand\" \"%r,r\")\n-\t\t (match_operand:DI 2 \"arith_operand\" \"r,J\")))]\n+\t\t (match_operand:DI 2 \"arith14_operand\" \"r,J\")))]\n   \"TARGET_64BIT\"\n   \"@\n    add,l %1,%2,%0\n@@ -5089,7 +5089,7 @@\n (define_insn \"addsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n \t(plus:SI (match_operand:SI 1 \"register_operand\" \"%r,r\")\n-\t\t (match_operand:SI 2 \"arith_operand\" \"r,J\")))]\n+\t\t (match_operand:SI 2 \"arith14_operand\" \"r,J\")))]\n   \"\"\n   \"@\n    {addl|add,l} %1,%2,%0\n@@ -5686,7 +5686,7 @@\n (define_expand \"iordi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t(ior:DI (match_operand:DI 1 \"register_operand\" \"\")\n-\t\t(match_operand:DI 2 \"reg_or_ior_operand\" \"\")))]\n+\t\t(match_operand:DI 2 \"reg_or_cint_ior_operand\" \"\")))]\n   \"\"\n   \"\n {\n@@ -5707,7 +5707,7 @@\n (define_insn \"\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n \t(ior:DI (match_operand:DI 1 \"register_operand\" \"0,0\")\n-\t\t(match_operand:DI 2 \"ior_operand\" \"M,i\")))]\n+\t\t(match_operand:DI 2 \"cint_ior_operand\" \"M,i\")))]\n   \"TARGET_64BIT\"\n   \"* return output_64bit_ior (operands); \"\n   [(set_attr \"type\" \"binary,shift\")\n@@ -5726,14 +5726,14 @@\n (define_expand \"iorsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(ior:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t(match_operand:SI 2 \"reg_or_ior_operand\" \"\")))]\n+\t\t(match_operand:SI 2 \"reg_or_cint_ior_operand\" \"\")))]\n   \"\"\n   \"\")\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n \t(ior:SI (match_operand:SI 1 \"register_operand\" \"0,0\")\n-\t\t(match_operand:SI 2 \"ior_operand\" \"M,i\")))]\n+\t\t(match_operand:SI 2 \"cint_ior_operand\" \"M,i\")))]\n   \"\"\n   \"* return output_ior (operands); \"\n   [(set_attr \"type\" \"binary,shift\")"}, {"sha": "d6f45d513de48b51e428681b2e0cffe06ee5ac0a", "filename": "gcc/config/pa/predicates.md", "status": "modified", "additions": 352, "deletions": 349, "changes": 701, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c575e20c33a032619b063d243f6e7320fcda878/gcc%2Fconfig%2Fpa%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c575e20c33a032619b063d243f6e7320fcda878/gcc%2Fconfig%2Fpa%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpredicates.md?ref=9c575e20c33a032619b063d243f6e7320fcda878", "patch": "@@ -1,5 +1,5 @@\n ;; Predicate definitions for HP PA-RISC.\n-;; Copyright (C) 2005, 2007, 2010 Free Software Foundation, Inc.\n+;; Copyright (C) 2005, 2007, 2010, 2011 Free Software Foundation, Inc.\n ;;\n ;; This file is part of GCC.\n ;;\n@@ -17,13 +17,144 @@\n ;; along with GCC; see the file COPYING3.  If not see\n ;; <http://www.gnu.org/licenses/>.\n \n-;; Return nonzero only if OP is a register of mode MODE, or\n-;; CONST0_RTX.\n+;; Return truth value of whether OP is an integer which fits the range\n+;; constraining 5-bit signed immediate operands in three-address insns.\n \n-(define_predicate \"reg_or_0_operand\"\n-  (match_code \"subreg,reg,const_int,const_double\")\n+(define_predicate \"int5_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"INT_5_BITS (op)\")))\n+\n+;; Return truth value of whether OP is an integer which fits the range\n+;; constraining 5-bit unsigned immediate operands in three-address insns.\n+\n+(define_predicate \"uint5_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"INT_U5_BITS (op)\")))\n+\n+;; Return truth value of whether OP is an integer which fits the range\n+;; constraining 11-bit signed immediate operands in three-address insns.\n+\n+(define_predicate \"int11_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"INT_11_BITS (op)\")))\n+\n+;; Return truth value of whether OP is an integer which fits the range\n+;; constraining 14-bit signed immediate operands in three-address insns.\n+\n+(define_predicate \"int14_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"INT_14_BITS (op)\")))\n+\n+;; True iff OP is a const_int or const_double that will fit in 32 bits.\n+\n+(define_predicate \"uint32_operand\"\n+  (if_then_else (match_test \"HOST_BITS_PER_WIDE_INT > 32\")\n+    (and (match_code \"const_int\")\n+         (match_test \"INTVAL (op) >= 0\n+\t\t      && INTVAL (op) < (HOST_WIDE_INT) 1 << 32\"))\n+    (and (match_code \"const_int,const_double\")\n+         (match_test \"CONST_INT_P (op) || CONST_DOUBLE_HIGH (op) == 0\"))))\n+\n+;; True iff depi can be used to compute (reg | OP).\n+\n+(define_predicate \"cint_ior_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ior_mask_p (INTVAL (op))\")))\n+\n+;; True iff OP is CONST_INT that can be moved in one instruction\n+;; into a general register.\n+\n+(define_predicate \"cint_move_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"cint_ok_for_move (INTVAL (op))\")))\n+\n+;; True iff OP is a CONST0_RTX for MODE.\n+\n+(define_predicate \"const_0_operand\"\n+  (and (match_code \"const_int,const_double\")\n+       (match_test \"op == CONST0_RTX (mode)\")))\n+\n+;; A constant integer suitable for use in a PRE_MODIFY memory reference.\n+\n+(define_predicate \"pre_cint_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"INTVAL (op) >= -0x2000 && INTVAL (op) < 0x10\")))\n+\n+;; A constant integer suitable for use in a POST_MODIFY memory reference.\n+\n+(define_predicate \"post_cint_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"INTVAL (op) < 0x2000 && INTVAL (op) >= -0x10\")))\n+\n+;; True iff depi or extru can be used to compute (reg & OP).\n+\n+(define_predicate \"and_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (and (match_code \"const_int\")\n+\t    (match_test \"and_mask_p (INTVAL (op))\"))))\n+\n+;; Return truth value of whether OP can be used as an operand in a\n+;; three operand arithmetic insn that accepts registers of mode MODE\n+;; or 5-bit signed integers.\n+\n+(define_predicate \"arith5_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (match_operand 0 \"int5_operand\")))\n+\n+;; Return truth value of whether OP can be used as an operand in a\n+;; three operand arithmetic insn that accepts registers of mode MODE\n+;; or 11-bit signed integers.\n+\n+(define_predicate \"arith11_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (match_operand 0 \"int11_operand\")))\n+\n+;; Return truth value of whether OP can be used as an operand in a\n+;; three operand arithmetic insn that accepts registers of mode MODE\n+;; or 14-bit signed integers.\n+\n+(define_predicate \"arith14_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (match_operand 0 \"int14_operand\")))\n+\n+;; Return truth value of whether OP can be used as an operand in a\n+;; three operand arithmetic insn that accepts registers of mode MODE\n+;; or 32-bit signed integers.\n+\n+(define_predicate \"arith32_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (match_code \"const_int\")))\n+\n+;; True iff OP can be used as an operand in an adddi3 insn.\n+\n+(define_predicate \"adddi3_operand\"\n+  (if_then_else (match_test \"TARGET_64BIT\")\n+    (match_operand 0 \"arith14_operand\")\n+    (match_operand 0 \"arith11_operand\")))\n+\n+;; True iff OP is valid as a base or index register in a REG+REG address.\n+\n+(define_predicate \"borx_reg_operand\"\n+  (match_code \"reg\")\n {\n-  return (op == CONST0_RTX (mode) || register_operand (op, mode));\n+  /* We must reject virtual registers as the only expressions that\n+     can be instantiated are REG and REG+CONST.  */\n+  if (op == virtual_incoming_args_rtx\n+      || op == virtual_stack_vars_rtx\n+      || op == virtual_stack_dynamic_rtx\n+      || op == virtual_outgoing_args_rtx\n+      || op == virtual_cfa_rtx)\n+    return false;\n+\n+  /* While it's always safe to index off the frame pointer, it's not\n+     profitable to do so when the frame pointer is being eliminated.  */\n+  if (!reload_completed\n+      && flag_omit_frame_pointer\n+      && !cfun->calls_alloca\n+      && op == frame_pointer_rtx)\n+    return false;\n+\n+  return register_operand (op, mode);\n })\n \n ;; Return nonzero if OP is suitable for use in a call to a named\n@@ -39,143 +170,100 @@\n \t  && CONSTANT_P (op) && ! TARGET_PORTABLE_RUNTIME);\n })\n \n-;; Return 1 iff OP is an indexed memory operand.\n+;; True iff OP can be used as the divisor in a div millicode call.\n+\n+(define_predicate \"div_operand\"\n+  (match_code \"reg,const_int\")\n+{\n+  return (mode == SImode\n+\t  && ((REG_P (op) && REGNO (op) == 25)\n+\t      || (CONST_INT_P (op)\n+\t\t  && INTVAL (op) > 0 && INTVAL (op) < 16\n+\t\t  && magic_milli[INTVAL (op)])));\n+})\n+\n+;; True iff OP is a reloading floating point register\n+\n+(define_predicate \"fp_reg_operand\"\n+  (and (match_code \"reg\")\n+       (match_test \"reg_renumber && FP_REG_P (op)\")))\n+\n+;; True iff OP is a function label operand.\n+\n+(define_special_predicate \"function_label_operand\"\n+  (and (match_code \"symbol_ref\")\n+       (match_test \"FUNCTION_NAME_P (XSTR (op, 0))\")))\n+\n+;; True iff OP is an indexed memory operand.\n \n (define_predicate \"indexed_memory_operand\"\n   (match_code \"subreg,mem\")\n {\n   if (GET_MODE (op) != mode)\n-    return 0;\n+    return false;\n \n   /* Before reload, a (SUBREG (MEM...)) forces reloading into a register.  */\n   if (reload_completed && GET_CODE (op) == SUBREG)\n     op = SUBREG_REG (op);\n \n-  if (GET_CODE (op) != MEM || symbolic_memory_operand (op, mode))\n-    return 0;\n+  if (! MEM_P (op))\n+    return false;\n \n   op = XEXP (op, 0);\n-\n-  return (memory_address_p (mode, op) && IS_INDEX_ADDR_P (op));\n-})\n-\n-;; Return 1 iff OP is a symbolic operand.\n-;; Note: an inline copy of this code is present in pa_secondary_reload.\n-\n-(define_predicate \"symbolic_operand\"\n-  (match_code \"symbol_ref,label_ref,const\")\n-{\n-  switch (GET_CODE (op))\n-    {\n-    case SYMBOL_REF:\n-      return !SYMBOL_REF_TLS_MODEL (op);\n-    case LABEL_REF:\n-      return 1;\n-    case CONST:\n-      op = XEXP (op, 0);\n-      return (GET_CODE (op) == PLUS\n-\t      && ((GET_CODE (XEXP (op, 0)) == SYMBOL_REF\n-\t\t   && !SYMBOL_REF_TLS_MODEL (XEXP (op, 0)))\n-\t\t  || GET_CODE (XEXP (op, 0)) == LABEL_REF)\n-\t      && GET_CODE (XEXP (op, 1)) == CONST_INT);\n-    default:\n-      return 0;\n-    }\n+  return IS_INDEX_ADDR_P (op) && memory_address_p (mode, op);\n })\n \n-;; Return truth value of statement that OP is a symbolic memory\n-;; operand of mode MODE.\n+;; True iff the operand OP can be used as the destination operand of\n+;; an integer store.  This also implies the operand could be used as\n+;; the source operand of an integer load.  Symbolic, lo_sum and indexed\n+;; memory operands are not allowed.  We accept reloading pseudos and\n+;; other memory operands.\n \n-(define_predicate \"symbolic_memory_operand\"\n-  (match_code \"subreg,mem\")\n+(define_predicate \"integer_store_memory_operand\"\n+  (match_code \"reg,mem\")\n {\n-  if (GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n-  if (GET_CODE (op) != MEM)\n-    return 0;\n-  op = XEXP (op, 0);\n-  return ((GET_CODE (op) == SYMBOL_REF && !SYMBOL_REF_TLS_MODEL (op))\n-  \t || GET_CODE (op) == CONST || GET_CODE (op) == HIGH \n-\t || GET_CODE (op) == LABEL_REF);\n+  return ((reload_in_progress\n+           && REG_P (op)\n+           && REGNO (op) >= FIRST_PSEUDO_REGISTER\n+           && reg_renumber [REGNO (op)] < 0)\n+          || (MEM_P (op)\n+              && (reload_in_progress || memory_address_p (mode, XEXP (op, 0)))\n+              && !symbolic_memory_operand (op, VOIDmode)\n+              && !IS_LO_SUM_DLT_ADDR_P (XEXP (op, 0))\n+              && !IS_INDEX_ADDR_P (XEXP (op, 0))));\n })\n \n-;; Return true if OP is a symbolic operand for the TLS Global Dynamic model.\n-(define_predicate \"tgd_symbolic_operand\"\n-  (and (match_code \"symbol_ref\")\n-       (match_test \"SYMBOL_REF_TLS_MODEL (op) == TLS_MODEL_GLOBAL_DYNAMIC\")))\n+;; Return true iff OP is an integer register.\n \n-;; Return true if OP is a symbolic operand for the TLS Local Dynamic model.\n-(define_predicate \"tld_symbolic_operand\"\n-  (and (match_code \"symbol_ref\")\n-       (match_test \"SYMBOL_REF_TLS_MODEL (op) == TLS_MODEL_LOCAL_DYNAMIC\")))\n-\n-;; Return true if OP is a symbolic operand for the TLS Initial Exec model.\n-(define_predicate \"tie_symbolic_operand\"\n-  (and (match_code \"symbol_ref\")\n-       (match_test \"SYMBOL_REF_TLS_MODEL (op) == TLS_MODEL_INITIAL_EXEC\")))\n+(define_predicate \"ireg_operand\"\n+  (and (match_code \"reg\")\n+       (match_test \"REGNO (op) > 0 && REGNO (op) < 32\")))\n \n-;; Return true if OP is a symbolic operand for the TLS Local Exec model.\n-(define_predicate \"tle_symbolic_operand\"\n-  (and (match_code \"symbol_ref\")\n-       (match_test \"SYMBOL_REF_TLS_MODEL (op) == TLS_MODEL_LOCAL_EXEC\")))\n+;; Return truth value of whether OP is an integer which fits the range\n+;; constraining immediate operands in three-address insns, or is an\n+;; integer register.\n \n+(define_predicate \"ireg_or_int5_operand\"\n+  (ior (match_operand 0 \"ireg_operand\")\n+       (match_operand 0 \"int5_operand\")))\n \n-;; Return 1 if the operand is a register operand or a non-symbolic\n-;; memory operand after reload.  This predicate is used for branch\n-;; patterns that internally handle register reloading.  We need to\n-;; accept non-symbolic memory operands after reload to ensure that the\n-;; pattern is still valid if reload didn't find a hard register for\n-;; the operand.\n+;; True iff OP is a CONST_INT of the forms 0...0xxxx or\n+;; 0...01...1xxxx. Such values can be the left hand side x in (x <<\n+;; r), using the zvdepi instruction.\n \n-(define_predicate \"reg_before_reload_operand\"\n-  (match_code \"reg,mem\")\n+(define_predicate \"lhs_lshift_cint_operand\"\n+  (match_code \"const_int\")\n {\n-  /* Don't accept a SUBREG since it will need a reload.  */\n-  if (GET_CODE (op) == SUBREG)\n-    return 0;\n-\n-  if (register_operand (op, mode))\n-    return 1;\n-\n-  if (reload_completed\n-      && memory_operand (op, mode)\n-      && !symbolic_memory_operand (op, mode))\n-    return 1;\n-\n-  return 0;\n+  unsigned HOST_WIDE_INT x;\n+  x = INTVAL (op) >> 4;\n+  return (x & (x + 1)) == 0;\n })\n \n-;; Return 1 if the operand is either a register, zero, or a memory\n-;; operand that is not symbolic.\n+;; True iff OP can be used in a zvdep instruction.\n \n-(define_predicate \"reg_or_0_or_nonsymb_mem_operand\"\n-  (match_code \"subreg,reg,mem,const_int,const_double\")\n-{\n-  if (register_operand (op, mode))\n-    return 1;\n-\n-  if (op == CONST0_RTX (mode))\n-    return 1;\n-\n-  if (GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n-\n-  if (GET_CODE (op) != MEM)\n-    return 0;\n-\n-  /* Until problems with management of the REG_POINTER flag are resolved,\n-     we need to delay creating move insns with unscaled indexed addresses\n-     until CSE is not expected.  */\n-  if (!TARGET_NO_SPACE_REGS\n-      && !cse_not_expected\n-      && GET_CODE (XEXP (op, 0)) == PLUS\n-      && REG_P (XEXP (XEXP (op, 0), 0))\n-      && REG_P (XEXP (XEXP (op, 0), 1)))\n-    return 0;\n-\n-  return (!symbolic_memory_operand (op, mode)\n-\t  && memory_address_p (mode, XEXP (op, 0)));\n-})\n+(define_predicate \"lhs_lshift_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (match_operand 0 \"lhs_lshift_cint_operand\")))\n \n ;; Accept anything that can be used as a destination operand for a\n ;; move instruction.  We don't accept indexed memory operands since\n@@ -185,16 +273,16 @@\n   (match_code \"subreg,reg,mem\")\n {\n   if (register_operand (op, mode))\n-    return 1;\n+    return true;\n \n   if (GET_MODE (op) != mode)\n-    return 0;\n+    return false;\n \n   if (GET_CODE (op) == SUBREG)\n     op = SUBREG_REG (op);\n \n   if (GET_CODE (op) != MEM || symbolic_memory_operand (op, mode))\n-    return 0;\n+    return false;\n \n   op = XEXP (op, 0);\n \n@@ -210,22 +298,22 @@\n   (match_code \"subreg,reg,const_int,const_double,mem\")\n {\n   if (register_operand (op, mode))\n-    return 1;\n+    return true;\n \n   if (op == CONST0_RTX (mode))\n-    return 1;\n+    return true;\n \n-  if (GET_CODE (op) == CONST_INT)\n+  if (CONST_INT_P (op))\n     return cint_ok_for_move (INTVAL (op));\n \n   if (GET_MODE (op) != mode)\n-    return 0;\n+    return false;\n \n   if (GET_CODE (op) == SUBREG)\n     op = SUBREG_REG (op);\n \n-  if (GET_CODE (op) != MEM)\n-    return 0;\n+  if (! MEM_P (op))\n+    return false;\n \n   /* Until problems with management of the REG_POINTER flag are resolved,\n      we need to delay creating move insns with unscaled indexed addresses\n@@ -235,295 +323,210 @@\n       && GET_CODE (XEXP (op, 0)) == PLUS\n       && REG_P (XEXP (XEXP (op, 0), 0))\n       && REG_P (XEXP (XEXP (op, 0), 1)))\n-    return 0;\n+    return false;\n \n   return memory_address_p (mode, XEXP (op, 0));\n })\n \n-;; Accept REG and any CONST_INT that can be moved in one instruction\n-;; into a general register.\n+;; True iff OP is not a symbolic memory operand. \n \n-(define_predicate \"reg_or_cint_move_operand\"\n-  (match_code \"subreg,reg,const_int\")\n+(define_predicate \"nonsymb_mem_operand\"\n+  (match_code \"subreg,mem\")\n {\n-  if (register_operand (op, mode))\n-    return 1;\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+\n+  if (! MEM_P (op))\n+    return false;\n+\n+  /* Until problems with management of the REG_POINTER flag are resolved,\n+     we need to delay creating move insns with unscaled indexed addresses\n+     until CSE is not expected.  */\n+  if (!TARGET_NO_SPACE_REGS\n+      && !cse_not_expected\n+      && GET_CODE (XEXP (op, 0)) == PLUS\n+      && REG_P (XEXP (XEXP (op, 0), 0))\n+      && REG_P (XEXP (XEXP (op, 0), 1)))\n+    return false;\n \n-  return (GET_CODE (op) == CONST_INT && cint_ok_for_move (INTVAL (op)));\n+  return (!symbolic_memory_operand (op, mode)\n+\t  && memory_address_p (mode, XEXP (op, 0)));\n })\n \n-;; TODO: Add a comment here.\n+;; True iff OP is anything other than a hard register.\n+\n+(define_predicate \"non_hard_reg_operand\"\n+  (match_test \"! (REG_P (op) && REGNO (op) < FIRST_PSEUDO_REGISTER)\"))\n+\n+;; True iff OP is a reference to a label whose address can be loaded\n+;; while generating PIC code.\n \n (define_predicate \"pic_label_operand\"\n   (match_code \"label_ref,const\")\n {\n   if (!flag_pic)\n-    return 0;\n+    return false;\n \n   switch (GET_CODE (op))\n     {\n     case LABEL_REF:\n-      return 1;\n+      return true;\n     case CONST:\n       op = XEXP (op, 0);\n       return (GET_CODE (XEXP (op, 0)) == LABEL_REF\n-\t      && GET_CODE (XEXP (op, 1)) == CONST_INT);\n+\t      && CONST_INT_P (XEXP (op, 1)));\n     default:\n-      return 0;\n+      gcc_unreachable ();\n     }\n+  return false;\n })\n \n-;; TODO: Add a comment here.\n-\n-(define_predicate \"fp_reg_operand\"\n-  (match_code \"reg\")\n-{\n-  return reg_renumber && FP_REG_P (op);\n-})\n-\n-;; Return truth value of whether OP can be used as an operand in a\n-;; three operand arithmetic insn that accepts registers of mode MODE\n-;; or 14-bit signed integers.\n-\n-(define_predicate \"arith_operand\"\n-  (match_code \"subreg,reg,const_int\")\n-{\n-  return (register_operand (op, mode)\n-\t  || (GET_CODE (op) == CONST_INT && INT_14_BITS (op)));\n-})\n-\n-;; Return truth value of whether OP can be used as an operand in a\n-;; three operand arithmetic insn that accepts registers of mode MODE\n-;; or 11-bit signed integers.\n-\n-(define_predicate \"arith11_operand\"\n-  (match_code \"subreg,reg,const_int\")\n-{\n-  return (register_operand (op, mode)\n-\t  || (GET_CODE (op) == CONST_INT && INT_11_BITS (op)));\n-})\n-\n-;; A constant integer suitable for use in a PRE_MODIFY memory\n-;; reference.\n-\n-(define_predicate \"pre_cint_operand\"\n-  (match_code \"const_int\")\n-{\n-  return (GET_CODE (op) == CONST_INT\n-\t  && INTVAL (op) >= -0x2000 && INTVAL (op) < 0x10);\n-})\n-\n-;; A constant integer suitable for use in a POST_MODIFY memory\n-;; reference.\n-\n-(define_predicate \"post_cint_operand\"\n-  (match_code \"const_int\")\n-{\n-  return (GET_CODE (op) == CONST_INT\n-\t  && INTVAL (op) < 0x2000 && INTVAL (op) >= -0x10);\n-})\n-\n-;; TODO: Add a comment here.\n-\n-(define_predicate \"arith_double_operand\"\n-  (match_code \"subreg,reg,const_double\")\n-{\n-  return (register_operand (op, mode)\n-\t  || (GET_CODE (op) == CONST_DOUBLE\n-\t      && GET_MODE (op) == mode\n-\t      && VAL_14_BITS_P (CONST_DOUBLE_LOW (op))\n-\t      && ((CONST_DOUBLE_HIGH (op) >= 0)\n-\t\t  == ((CONST_DOUBLE_LOW (op) & 0x1000) == 0))));\n-})\n-\n-;; Return truth value of whether OP is an integer which fits the range\n-;; constraining immediate operands in three-address insns, or is an\n-;; integer register.\n+;; True iff the operand OP lives in text space.  OP is a symbolic operand.\n+;; If so, SYMBOL_REF_FLAG, which is set by pa_encode_section_info, is true.\n \n-(define_predicate \"ireg_or_int5_operand\"\n-  (match_code \"const_int,reg\")\n+(define_special_predicate \"read_only_operand\"\n+  (match_test \"true\")\n {\n-  return ((GET_CODE (op) == CONST_INT && INT_5_BITS (op))\n-\t  || (GET_CODE (op) == REG && REGNO (op) > 0 && REGNO (op) < 32));\n-})\n-\n-;; Return truth value of whether OP is an integer which fits the range\n-;; constraining immediate operands in three-address insns.\n-\n-(define_predicate \"int5_operand\"\n-  (match_code \"const_int\")\n-{\n-  return (GET_CODE (op) == CONST_INT && INT_5_BITS (op));\n+  if (GET_CODE (op) == CONST)\n+    op = XEXP (XEXP (op, 0), 0);\n+  if (GET_CODE (op) == SYMBOL_REF)\n+    {\n+      if (flag_pic)\n+        return SYMBOL_REF_FLAG (op) && !CONSTANT_POOL_ADDRESS_P (op);\n+      else\n+        return SYMBOL_REF_FLAG (op) || CONSTANT_POOL_ADDRESS_P (op);\n+    }\n+  return true;\n })\n \n-;; Return truth value of whether OP is an integer which fits the range\n-;; constraining immediate operands in three-address insns.\n+;; True iff the operand is a register operand, or a non-symbolic\n+;; memory operand after reload.  A SUBREG is not accepted since it\n+;; will need a reload.\n+;;\n+;; This predicate is used for branch patterns that internally handle\n+;; register reloading.  We need to accept non-symbolic memory operands\n+;; after reload to ensure that the pattern is still valid if reload\n+;; didn't find a hard register for the operand.\n \n-(define_predicate \"uint5_operand\"\n-  (match_code \"const_int\")\n+(define_predicate \"reg_before_reload_operand\"\n+  (match_code \"reg,mem\")\n {\n-  return (GET_CODE (op) == CONST_INT && INT_U5_BITS (op));\n-})\n+  if (register_operand (op, mode))\n+    return true;\n \n-;; Return truth value of whether OP is an integer which fits the range\n-;; constraining immediate operands in three-address insns.\n+  if (reload_completed\n+      && memory_operand (op, mode)\n+      && !symbolic_memory_operand (op, mode))\n+    return true;\n \n-(define_predicate \"int11_operand\"\n-  (match_code \"const_int\")\n-{\n-  return (GET_CODE (op) == CONST_INT && INT_11_BITS (op));\n+  return false;\n })\n \n-;; Return truth value of whether OP is an integer which fits the range\n-;; constraining immediate operands in three-address insns.\n+;; True iff OP is a register or const_0 operand for MODE.\n \n-(define_predicate \"uint32_operand\"\n-  (match_code \"const_int,const_double\")\n-{\n-#if HOST_BITS_PER_WIDE_INT > 32\n-  /* All allowed constants will fit a CONST_INT.  */\n-  return (GET_CODE (op) == CONST_INT\n-\t  && (INTVAL (op) >= 0 && INTVAL (op) < (HOST_WIDE_INT) 1 << 32));\n-#else\n-  return (GET_CODE (op) == CONST_INT\n-\t  || (GET_CODE (op) == CONST_DOUBLE\n-\t      && CONST_DOUBLE_HIGH (op) == 0));\n-#endif\n-})\n+(define_predicate \"reg_or_0_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (match_operand 0 \"const_0_operand\")))\n \n-;; Return truth value of whether OP is an integer which fits the range\n-;; constraining immediate operands in three-address insns.\n+;; True iff OP is either a register, zero, or a non-symbolic memory operand.\n \n-(define_predicate \"arith5_operand\"\n-  (match_code \"subreg,reg,const_int\")\n-{\n-  return register_operand (op, mode) || int5_operand (op, mode);\n-})\n+(define_predicate \"reg_or_0_or_nonsymb_mem_operand\"\n+  (ior (match_operand 0 \"reg_or_0_operand\")\n+       (match_operand 0 \"nonsymb_mem_operand\")))\n \n-;; True iff depi or extru can be used to compute (reg & OP).\n+;; Accept REG and any CONST_INT that can be moved in one instruction\n+;; into a general register.\n \n-(define_predicate \"and_operand\"\n-  (match_code \"subreg,reg,const_int\")\n-{\n-  return (register_operand (op, mode)\n-\t  || (GET_CODE (op) == CONST_INT && and_mask_p (INTVAL (op))));\n-})\n+(define_predicate \"reg_or_cint_move_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (match_operand 0 \"cint_move_operand\")))\n \n ;; True iff OP can be used to compute (reg | OP).\n \n-(define_predicate \"reg_or_ior_operand\"\n-  (match_code \"subreg,reg,const_int\")\n-{\n-  return (register_operand (op, mode)\n-\t  || (GET_CODE (op) == CONST_INT && ior_mask_p (INTVAL (op))));\n-})\n-\n-;; True iff depi can be used to compute (reg | OP).\n-\n-(define_predicate \"ior_operand\"\n-  (match_code \"const_int\")\n-{\n-  return (GET_CODE (op) == CONST_INT && ior_mask_p (INTVAL (op)));\n-})\n+(define_predicate \"reg_or_cint_ior_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (match_operand 0 \"cint_ior_operand\")))\n \n-;; True iff OP is a CONST_INT of the forms 0...0xxxx or\n-;; 0...01...1xxxx. Such values can be the left hand side x in (x <<\n-;; r), using the zvdepi instruction.\n-\n-(define_predicate \"lhs_lshift_cint_operand\"\n-  (match_code \"const_int\")\n-{\n-  unsigned HOST_WIDE_INT x;\n-  if (GET_CODE (op) != CONST_INT)\n-    return 0;\n-  x = INTVAL (op) >> 4;\n-  return (x & (x + 1)) == 0;\n-})\n-\n-;; TODO: Add a comment here.\n+;; Return 1 if OP is a CONST_INT with the value 2, 4, or 8.  These are\n+;; the valid constants for shadd instructions.\n \n-(define_predicate \"lhs_lshift_operand\"\n-  (match_code \"subreg,reg,const_int\")\n-{\n-  return register_operand (op, mode) || lhs_lshift_cint_operand (op, mode);\n-})\n+(define_predicate \"shadd_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"shadd_constant_p (INTVAL (op))\")))\n \n-;; TODO: Add a comment here.\n+;; Return truth value of statement that OP is a symbolic memory operand.\n \n-(define_predicate \"arith32_operand\"\n-  (match_code \"subreg,reg,const_int\")\n+(define_predicate \"symbolic_memory_operand\"\n+  (match_code \"subreg,mem\")\n {\n-  return register_operand (op, mode) || GET_CODE (op) == CONST_INT;\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+  if (!MEM_P (op))\n+    return false;\n+  return symbolic_expression_p (XEXP (op, 0));\n })\n \n-;; TODO: Add a comment here.\n+;; True iff OP is a symbolic operand.\n+;; Note: an inline copy of this code is present in pa_secondary_reload.\n \n-(define_predicate \"pc_or_label_operand\"\n-  (match_code \"pc,label_ref\")\n+(define_predicate \"symbolic_operand\"\n+  (match_code \"symbol_ref,label_ref,const\")\n {\n-  return (GET_CODE (op) == PC || GET_CODE (op) == LABEL_REF);\n+  switch (GET_CODE (op))\n+    {\n+    case SYMBOL_REF:\n+      return !SYMBOL_REF_TLS_MODEL (op);\n+    case LABEL_REF:\n+      return true;\n+    case CONST:\n+      op = XEXP (op, 0);\n+      return (GET_CODE (op) == PLUS\n+\t      && ((GET_CODE (XEXP (op, 0)) == SYMBOL_REF\n+\t\t   && !SYMBOL_REF_TLS_MODEL (XEXP (op, 0)))\n+\t\t  || GET_CODE (XEXP (op, 0)) == LABEL_REF)\n+\t      && GET_CODE (XEXP (op, 1)) == CONST_INT);\n+    default:\n+      gcc_unreachable ();\n+    }\n+  return true;\n })\n \n-;; TODO: Add a comment here.\n+;; Return true if OP is a symbolic operand for the TLS Global Dynamic model.\n \n-(define_predicate \"plus_xor_ior_operator\"\n-  (match_code \"plus,xor,ior\")\n-{\n-  return (GET_CODE (op) == PLUS || GET_CODE (op) == XOR\n-\t  || GET_CODE (op) == IOR);\n-})\n+(define_predicate \"tgd_symbolic_operand\"\n+  (and (match_code \"symbol_ref\")\n+       (match_test \"SYMBOL_REF_TLS_MODEL (op) == TLS_MODEL_GLOBAL_DYNAMIC\")))\n \n-;; Return 1 if OP is a CONST_INT with the value 2, 4, or 8.  These are\n-;; the valid constant for shadd instructions.\n+;; Return true if OP is a symbolic operand for the TLS Local Dynamic model.\n \n-(define_predicate \"shadd_operand\"\n-  (match_code \"const_int\")\n-{\n-  return (GET_CODE (op) == CONST_INT && shadd_constant_p (INTVAL (op)));\n-})\n+(define_predicate \"tld_symbolic_operand\"\n+  (and (match_code \"symbol_ref\")\n+       (match_test \"SYMBOL_REF_TLS_MODEL (op) == TLS_MODEL_LOCAL_DYNAMIC\")))\n \n-;; TODO: Add a comment here.\n+;; Return true if OP is a symbolic operand for the TLS Initial Exec model.\n \n-(define_predicate \"div_operand\"\n-  (match_code \"reg,const_int\")\n-{\n-  return (mode == SImode\n-\t  && ((GET_CODE (op) == REG && REGNO (op) == 25)\n-\t      || (GET_CODE (op) == CONST_INT && INTVAL (op) > 0\n-\t\t  && INTVAL (op) < 16 && magic_milli[INTVAL (op)])));\n-})\n+(define_predicate \"tie_symbolic_operand\"\n+  (and (match_code \"symbol_ref\")\n+       (match_test \"SYMBOL_REF_TLS_MODEL (op) == TLS_MODEL_INITIAL_EXEC\")))\n \n-;; Return nonzero if OP is an integer register, else return zero.\n+;; Return true if OP is a symbolic operand for the TLS Local Exec model.\n \n-(define_predicate \"ireg_operand\"\n-  (match_code \"reg\")\n-{\n-  return (GET_CODE (op) == REG && REGNO (op) > 0 && REGNO (op) < 32);\n-})\n+(define_predicate \"tle_symbolic_operand\"\n+  (and (match_code \"symbol_ref\")\n+       (match_test \"SYMBOL_REF_TLS_MODEL (op) == TLS_MODEL_LOCAL_EXEC\")))\n \n-;; Return 1 if this is a comparison operator.  This allows the use of\n+;; True iff this is a comparison operator.  This allows the use of\n ;; MATCH_OPERATOR to recognize all the branch insns.\n \n (define_predicate \"cmpib_comparison_operator\"\n-  (match_code \"eq,ne,lt,le,leu,gt,gtu,ge\")\n-{\n-  return ((mode == VOIDmode || GET_MODE (op) == mode)\n-          && (GET_CODE (op) == EQ\n-\t      || GET_CODE (op) == NE\n-\t      || GET_CODE (op) == GT\n-\t      || GET_CODE (op) == GTU\n-\t      || GET_CODE (op) == GE\n-\t      || GET_CODE (op) == LT\n-\t      || GET_CODE (op) == LE\n-\t      || GET_CODE (op) == LEU));\n-})\n+  (match_code \"eq,ne,lt,le,leu,gt,gtu,ge\"))\n \n-;; Return 1 if OP is an operator suitable for use in a movb\n-;; instruction.\n+;; True iff OP is an operator suitable for use in a movb instruction.\n \n (define_predicate \"movb_comparison_operator\"\n-  (match_code \"eq,ne,lt,ge\")\n-{\n-  return (GET_CODE (op) == EQ || GET_CODE (op) == NE\n-\t  || GET_CODE (op) == LT || GET_CODE (op) == GE);\n-})\n+  (match_code \"eq,ne,lt,ge\"))\n+\n+;; True iff OP is a PLUS, XOR or IOR operator.\n+\n+(define_predicate \"plus_xor_ior_operator\"\n+  (match_code \"plus,xor,ior\"))"}]}