{"sha": "231db5f4ec6703b6b9a931fa37c0eab18d4d49d8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjMxZGI1ZjRlYzY3MDNiNmI5YTkzMWZhMzdjMGVhYjE4ZDRkNDlkOA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-11-27T04:25:32Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-11-27T04:25:32Z"}, "message": "elfos.h (ASM_OUTPUT_SECTION_NAME): Use a hash table, not a list, to keep track of the sections.\n\n\t* config/elfos.h (ASM_OUTPUT_SECTION_NAME): Use a hash table, not\n\ta list, to keep track of the sections.\n\t* tm.texi (ASM_OUTPUT_SECTION_NAME): Document the fact that the\n\tparameter provided will always be a canonical string.\n\nFrom-SVN: r37776", "tree": {"sha": "dc69a39eb4eeb180a5f560c64bc91ce58d7cb806", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dc69a39eb4eeb180a5f560c64bc91ce58d7cb806"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/231db5f4ec6703b6b9a931fa37c0eab18d4d49d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/231db5f4ec6703b6b9a931fa37c0eab18d4d49d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/231db5f4ec6703b6b9a931fa37c0eab18d4d49d8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/231db5f4ec6703b6b9a931fa37c0eab18d4d49d8/comments", "author": null, "committer": null, "parents": [{"sha": "a4c9b97e262791f8bfc0e12ad1d564c90d8b966a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4c9b97e262791f8bfc0e12ad1d564c90d8b966a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4c9b97e262791f8bfc0e12ad1d564c90d8b966a"}], "stats": {"total": 57, "additions": 38, "deletions": 19}, "files": [{"sha": "b6e8264f7cfb2dcf42992928a4cdc5d041f71b26", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/231db5f4ec6703b6b9a931fa37c0eab18d4d49d8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/231db5f4ec6703b6b9a931fa37c0eab18d4d49d8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=231db5f4ec6703b6b9a931fa37c0eab18d4d49d8", "patch": "@@ -1,3 +1,10 @@\n+2000-11-26  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* config/elfos.h (ASM_OUTPUT_SECTION_NAME): Use a hash table, not\n+\ta list, to keep track of the sections.\n+\t* tm.texi (ASM_OUTPUT_SECTION_NAME): Document the fact that the\n+\tparameter provided will always be a canonical string.\n+\n 2000-11-26  Neil Booth  <neilb@earthling.net>\n \n         * cppmacro.c (cpp_scan_buffer_nooutput): Only scan the"}, {"sha": "9925ff5cf330a50a57865194f89bfce31609b671", "filename": "gcc/config/elfos.h", "status": "modified", "additions": 26, "deletions": 17, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/231db5f4ec6703b6b9a931fa37c0eab18d4d49d8/gcc%2Fconfig%2Felfos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/231db5f4ec6703b6b9a931fa37c0eab18d4d49d8/gcc%2Fconfig%2Felfos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Felfos.h?ref=231db5f4ec6703b6b9a931fa37c0eab18d4d49d8", "patch": "@@ -421,42 +421,51 @@ dtors_section ()\t\t\t\t\t\t\\\n #define ASM_OUTPUT_SECTION_NAME(FILE, DECL, NAME, RELOC)\t\t\\\n   do\t\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-      static struct section_info\t\t\t\t\t\\\n+      static htab_t htab;                                               \\\n+                                                                        \\\n+      struct section_info                                               \\\n       {\t\t\t\t\t\t\t\t\t\\\n-\tstruct section_info *next;\t\t\t\t        \\\n-\tchar *name;\t\t\t\t\t\t        \\\n \tenum sect_enum {SECT_RW, SECT_RO, SECT_EXEC} type;\t\t\\\n-      } *sections;\t\t\t\t\t\t\t\\\n+      };                                                                \\\n+                                                                        \\\n       struct section_info *s;\t\t\t\t\t\t\\\n       const char *mode;\t\t\t\t\t\t\t\\\n-      enum sect_enum type;\t\t\t\t\t\t\\\n-      \t\t\t\t\t\t\t\t\t\\\n-      for (s = sections; s; s = s->next)\t\t\t\t\\\n-\tif (!strcmp (NAME, s->name))\t\t\t\t\t\\\n-\t  break;\t\t\t\t\t\t\t\\\n-      \t\t\t\t\t\t\t\t\t\\\n+      enum sect_enum type;                                              \\\n+      PTR* slot;                                                        \\\n+                                                                        \\\n+      /* The names we put in the hashtable will always be the unique    \\\n+\t versions gived to us by the stringtable, so we can just use    \\\n+\t their addresses as the keys.  */                               \\\n+      if (!htab)                                                        \\\n+\thtab = htab_create (31,                                         \\\n+\t\t\t    htab_hash_pointer,                          \\\n+\t\t\t    htab_eq_pointer,                            \\\n+\t\t\t    NULL);                                      \\\n+                                                                        \\\n       if (DECL && TREE_CODE (DECL) == FUNCTION_DECL)\t\t\t\\\n \ttype = SECT_EXEC, mode = \"ax\";\t\t\t\t\t\\\n       else if (DECL && DECL_READONLY_SECTION (DECL, RELOC))\t\t\\\n \ttype = SECT_RO, mode = \"a\";\t\t\t\t\t\\\n       else\t\t\t\t\t\t\t\t\\\n \ttype = SECT_RW, mode = \"aw\";\t\t\t\t\t\\\n       \t\t\t\t\t\t\t\t\t\\\n-      if (s == 0)\t\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n+                                                                        \\\n+      /* See if we already have an entry for this section.  */          \\\n+      slot = htab_find_slot (htab, NAME, INSERT);                       \\\n+      if (!*slot)                                                       \\\n+\t{                                                               \\\n \t  s = (struct section_info *) xmalloc (sizeof (* s));\t\t\\\n-\t  s->name = xmalloc ((strlen (NAME) + 1) * sizeof (* NAME));\t\\\n-\t  strcpy (s->name, NAME);\t\t\t\t\t\\\n \t  s->type = type;\t\t\t\t\t\t\\\n-\t  s->next = sections;\t\t\t\t\t\t\\\n-\t  sections = s;\t\t\t\t\t\t\t\\\n+\t  *slot = s;\t\t\t\t\t\t\t\\\n \t  fprintf (FILE, \"\\t.section\\t%s,\\\"%s\\\",@progbits\\n\",\t\t\\\n \t\t   NAME, mode);\t\t\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\t\\\n       else\t\t\t\t\t\t\t\t\\\n \t{\t\t\t\t\t\t\t\t\\\n+\t  s = (struct section_info *) *slot;                            \\\n \t  if (DECL && s->type != type)\t\t\t\t\t\\\n-\t    error_with_decl (DECL, \"%s causes a section type conflict\");\\\n+\t    error_with_decl (DECL,                                      \\\n+\t\t\t     \"%s causes a section type conflict\");      \\\n \t  \t\t\t\t\t\t\t\t\\\n \t  fprintf (FILE, \"\\t.section\\t%s\\n\", NAME);\t\t\t\\\n \t}\t\t\t\t\t\t\t\t\\"}, {"sha": "03249881daf9dd722211bc5d6e8f14ed62e82865", "filename": "gcc/tm.texi", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/231db5f4ec6703b6b9a931fa37c0eab18d4d49d8/gcc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/231db5f4ec6703b6b9a931fa37c0eab18d4d49d8/gcc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftm.texi?ref=231db5f4ec6703b6b9a931fa37c0eab18d4d49d8", "patch": "@@ -5439,8 +5439,11 @@ A C statement to output something to the assembler file to switch to section\n @var{name} for object @var{decl} which is either a @code{FUNCTION_DECL}, a\n @code{VAR_DECL} or @code{NULL_TREE}.  @var{reloc}\n indicates whether the initial value of @var{exp} requires link-time\n-relocations.  Some target formats do not support\n-arbitrary sections.  Do not define this macro in such cases.\n+relocations.  The string given by @var{name} will always be the\n+canonical version stored in the global stringpool.\n+\n+Some target formats do not support arbitrary sections.  Do not define\n+this macro in such cases.\n \n At present this macro is only used to support section attributes.\n When this macro is undefined, section attributes are disabled."}]}