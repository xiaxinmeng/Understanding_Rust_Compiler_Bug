{"sha": "57f6a200e324c605ed19fef107e528d0b902770a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTdmNmEyMDBlMzI0YzYwNWVkMTlmZWYxMDdlNTI4ZDBiOTAyNzcwYQ==", "commit": {"author": {"name": "Sandra Loosemore", "email": "sandra@codesourcery.com", "date": "2017-10-24T02:39:11Z"}, "committer": {"name": "Sandra Loosemore", "email": "sandra@gcc.gnu.org", "date": "2017-10-24T02:39:11Z"}, "message": "cdx-branch.c: Fix broken test.\n\n2017-10-23  Sandra Loosemore  <sandra@codesourcery.com>\n\n\tgcc/testsuite/\n\t* gcc.target/nios2/cdx-branch.c:  Fix broken test.\n\t* gcc.target/nios2/lo-addr-bypass.c: New.\n\t* gcc.target/nios2/lo-addr-char.c: New.\n\t* gcc.target/nios2/lo-addr-int.c: New.\n\t* gcc.target/nios2/lo-addr-pic.c: New.\n\t* gcc.target/nios2/lo-addr-short.c: New.\n\t* gcc.target/nios2/lo-addr-tls.c: New.\n\t* gcc.target/nios2/lo-addr-uchar.c: New.\n\t* gcc.target/nios2/lo-addr-ushort.c: New.\n\t* gcc.target/nios2/lo-addr-volatile.c: New.\n\nFrom-SVN: r254035", "tree": {"sha": "c937e4fb6c15367498a383cb7f2e080d1149dce5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c937e4fb6c15367498a383cb7f2e080d1149dce5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/57f6a200e324c605ed19fef107e528d0b902770a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57f6a200e324c605ed19fef107e528d0b902770a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57f6a200e324c605ed19fef107e528d0b902770a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57f6a200e324c605ed19fef107e528d0b902770a/comments", "author": {"login": "SandraLoosemore", "id": 104087111, "node_id": "U_kgDOBjQ-Rw", "avatar_url": "https://avatars.githubusercontent.com/u/104087111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SandraLoosemore", "html_url": "https://github.com/SandraLoosemore", "followers_url": "https://api.github.com/users/SandraLoosemore/followers", "following_url": "https://api.github.com/users/SandraLoosemore/following{/other_user}", "gists_url": "https://api.github.com/users/SandraLoosemore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SandraLoosemore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SandraLoosemore/subscriptions", "organizations_url": "https://api.github.com/users/SandraLoosemore/orgs", "repos_url": "https://api.github.com/users/SandraLoosemore/repos", "events_url": "https://api.github.com/users/SandraLoosemore/events{/privacy}", "received_events_url": "https://api.github.com/users/SandraLoosemore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "efd5897cdf05c21156ce97fcf98f5c86163a445b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efd5897cdf05c21156ce97fcf98f5c86163a445b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/efd5897cdf05c21156ce97fcf98f5c86163a445b"}], "stats": {"total": 432, "additions": 430, "deletions": 2}, "files": [{"sha": "f188d8181e56217684e182ac1b23cccc9cdeab70", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57f6a200e324c605ed19fef107e528d0b902770a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57f6a200e324c605ed19fef107e528d0b902770a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=57f6a200e324c605ed19fef107e528d0b902770a", "patch": "@@ -1,3 +1,16 @@\n+2017-10-23  Sandra Loosemore  <sandra@codesourcery.com>\n+\n+\t* gcc.target/nios2/cdx-branch.c:  Fix broken test.\n+\t* gcc.target/nios2/lo-addr-bypass.c: New.\n+\t* gcc.target/nios2/lo-addr-char.c: New.\n+\t* gcc.target/nios2/lo-addr-int.c: New.\n+\t* gcc.target/nios2/lo-addr-pic.c: New.\n+\t* gcc.target/nios2/lo-addr-short.c: New.\n+\t* gcc.target/nios2/lo-addr-tls.c: New.\n+\t* gcc.target/nios2/lo-addr-uchar.c: New.\n+\t* gcc.target/nios2/lo-addr-ushort.c: New.\n+\t* gcc.target/nios2/lo-addr-volatile.c: New.\n+\n 2017-10-23  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/80449"}, {"sha": "3a9c459cec3e76665671e12d8e74d21bf0db2c9a", "filename": "gcc/testsuite/gcc.target/nios2/cdx-branch.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57f6a200e324c605ed19fef107e528d0b902770a/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Fcdx-branch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57f6a200e324c605ed19fef107e528d0b902770a/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Fcdx-branch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Fcdx-branch.c?ref=57f6a200e324c605ed19fef107e528d0b902770a", "patch": "@@ -23,15 +23,15 @@ extern int i (int);\n extern int j (int);\n extern int k (int);\n \n-int h (int a)\n+int h (int a, int b)\n {\n   int x;\n \n   /* As well as the conditional branch for the \"if\", there has to be\n      an unconditional branch from one branch of the \"if\" to\n      the return statement.  We compile this testcase with -Os to\n      avoid insertion of a duplicate epilogue in place of the branch.  */\n-  if (a == 1)\n+  if (a == b)\n     x = i (37);\n   else\n     x = j (42);"}, {"sha": "24e6cfd4cc08d642365a3014e13a619828b6fdf6", "filename": "gcc/testsuite/gcc.target/nios2/lo-addr-bypass.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57f6a200e324c605ed19fef107e528d0b902770a/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Flo-addr-bypass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57f6a200e324c605ed19fef107e528d0b902770a/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Flo-addr-bypass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Flo-addr-bypass.c?ref=57f6a200e324c605ed19fef107e528d0b902770a", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -march=r2 -mbypass-cache\" } */\n+/* { dg-final { scan-assembler-times \"addi\\tr., r., %lo\" 12 } } */\n+/* { dg-final { scan-assembler-not \"ldw\\t\" } } */\n+/* { dg-final { scan-assembler-not \"stw\\t\" } } */\n+/* { dg-final { scan-assembler-not \"ldwio\\tr., %lo\" } } */\n+/* { dg-final { scan-assembler-not \"stwio\\tr., %lo\" } } */\n+\n+/* Check that we do not generate %lo addresses with R2 ldstio instructions.\n+   %lo requires a 16-bit relocation and on R2 these instructions only have a\n+   12-bit register offset.  */\n+#define TYPE int\n+\n+struct ss\n+{\n+  TYPE x1,x2;\n+};\n+\n+extern TYPE S1;\n+extern TYPE S2[];\n+\n+extern struct ss S3;\n+extern struct ss S4[];\n+\n+TYPE *addr1 (void) { return &S1; }\n+TYPE get1 (void) { return S1; }\n+void set1 (TYPE value) { S1 = value; }\n+\n+TYPE *addr2 (int i) { return &(S2[i]); }\n+TYPE get2 (int i) { return S2[i]; }\n+void set2 (int i, TYPE value) { S2[i] = value; }\n+\n+TYPE *addr3 (void) { return &(S3.x2); }\n+TYPE get3 (void) { return S3.x2; }\n+void set3 (TYPE value) { S3.x2 = value; }\n+\n+TYPE *addr4 (int i) { return &(S4[i].x2); }\n+TYPE get4 (int i) { return S4[i].x2; }\n+void set4 (int i, TYPE value) { S4[i].x2 = value; }\n+"}, {"sha": "dd992458323de7b7e0bb0d2cf0ffcb9fa1f3c7e5", "filename": "gcc/testsuite/gcc.target/nios2/lo-addr-char.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57f6a200e324c605ed19fef107e528d0b902770a/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Flo-addr-char.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57f6a200e324c605ed19fef107e528d0b902770a/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Flo-addr-char.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Flo-addr-char.c?ref=57f6a200e324c605ed19fef107e528d0b902770a", "patch": "@@ -0,0 +1,60 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-final { scan-assembler-times \"addi\\tr., r., %lo\" 4 } } */\n+/* { dg-final { scan-assembler-times \"ldbu\\tr., %lo\" 4 } } */\n+/* { dg-final { scan-assembler-times \"ldb\\tr., %lo\" 16 } } */\n+/* { dg-final { scan-assembler-times \"stb\\tr., %lo\" 4 } } */\n+\n+/* Check that various address forms involving a symbolic constant\n+   with a possible constant offset and/or index register are optimized\n+   to generate a %lo relocation in the load/store instructions instead\n+   of a plain register indirect addressing mode.  */\n+/* Note: get* uses ldhu but ext* uses ldh since TYPE is signed.  */\n+\n+#define TYPE signed char\n+\n+struct ss\n+{\n+  TYPE x1,x2;\n+};\n+\n+extern TYPE S1;\n+extern TYPE S2[];\n+\n+extern struct ss S3;\n+extern struct ss S4[];\n+\n+TYPE *addr1 (void) { return &S1; }\n+TYPE get1 (void) { return S1; }\n+void set1 (TYPE value) { S1 = value; }\n+\n+TYPE *addr2 (int i) { return &(S2[i]); }\n+TYPE get2 (int i) { return S2[i]; }\n+void set2 (int i, TYPE value) { S2[i] = value; }\n+\n+TYPE *addr3 (void) { return &(S3.x2); }\n+TYPE get3 (void) { return S3.x2; }\n+void set3 (TYPE value) { S3.x2 = value; }\n+\n+TYPE *addr4 (int i) { return &(S4[i].x2); }\n+TYPE get4 (int i) { return S4[i].x2; }\n+void set4 (int i, TYPE value) { S4[i].x2 = value; }\n+\n+int extw1 (void) { return (int)(S1); }\n+int extw2 (int i) { return (int)(S2[i]); }\n+int extw3 (void) { return (int)(S3.x2); }\n+int extw4 (int i) { return (int)(S4[i].x2); }\n+unsigned int extwu1 (void) { return (unsigned int)(S1); }\n+unsigned int extwu2 (int i) { return (unsigned int)(S2[i]); }\n+unsigned int extwu3 (void) { return (unsigned int)(S3.x2); }\n+unsigned int extwu4 (int i) { return (unsigned int)(S4[i].x2); }\n+\n+short exth1 (void) { return (short)(S1); }\n+short exth2 (int i) { return (short)(S2[i]); }\n+short exth3 (void) { return (short)(S3.x2); }\n+short exth4 (int i) { return (short)(S4[i].x2); }\n+unsigned short exthu1 (void) { return (unsigned short)(S1); }\n+unsigned short exthu2 (int i) { return (unsigned short)(S2[i]); }\n+unsigned short exthu3 (void) { return (unsigned short)(S3.x2); }\n+unsigned short exthu4 (int i) { return (unsigned short)(S4[i].x2); }\n+"}, {"sha": "9a6f779d3837de1e0b83aa15b7cae028db233471", "filename": "gcc/testsuite/gcc.target/nios2/lo-addr-int.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57f6a200e324c605ed19fef107e528d0b902770a/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Flo-addr-int.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57f6a200e324c605ed19fef107e528d0b902770a/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Flo-addr-int.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Flo-addr-int.c?ref=57f6a200e324c605ed19fef107e528d0b902770a", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-final { scan-assembler-times \"addi\\tr., r., %lo\" 4 } } */\n+/* { dg-final { scan-assembler-times \"ldw\\tr., %lo\" 4 } } */\n+/* { dg-final { scan-assembler-times \"stw\\tr., %lo\" 4 } } */\n+\n+/* Check that various address forms involving a symbolic constant\n+   with a possible constant offset and/or index register are optimized\n+   to generate a %lo relocation in the load/store instructions instead\n+   of a plain register indirect addressing mode.  */\n+\n+#define TYPE int\n+\n+struct ss\n+{\n+  TYPE x1,x2;\n+};\n+\n+extern TYPE S1;\n+extern TYPE S2[];\n+\n+extern struct ss S3;\n+extern struct ss S4[];\n+\n+TYPE *addr1 (void) { return &S1; }\n+TYPE get1 (void) { return S1; }\n+void set1 (TYPE value) { S1 = value; }\n+\n+TYPE *addr2 (int i) { return &(S2[i]); }\n+TYPE get2 (int i) { return S2[i]; }\n+void set2 (int i, TYPE value) { S2[i] = value; }\n+\n+TYPE *addr3 (void) { return &(S3.x2); }\n+TYPE get3 (void) { return S3.x2; }\n+void set3 (TYPE value) { S3.x2 = value; }\n+\n+TYPE *addr4 (int i) { return &(S4[i].x2); }\n+TYPE get4 (int i) { return S4[i].x2; }\n+void set4 (int i, TYPE value) { S4[i].x2 = value; }\n+"}, {"sha": "bcd623785bdcf885a1832874ef45a37cb86bbca3", "filename": "gcc/testsuite/gcc.target/nios2/lo-addr-pic.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57f6a200e324c605ed19fef107e528d0b902770a/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Flo-addr-pic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57f6a200e324c605ed19fef107e528d0b902770a/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Flo-addr-pic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Flo-addr-pic.c?ref=57f6a200e324c605ed19fef107e528d0b902770a", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile { target nios2-*-linux-gnu } } */\n+/* { dg-options \"-O2 -fpic\" } */\n+/* { dg-final { scan-assembler-not \"ldw\\tr., %lo\" } } */\n+/* { dg-final { scan-assembler-not \"stw\\tr., %lo\" } } */\n+\n+/* Check that address transformations for symbolic constants do NOT\n+   apply to code compiled with -fPIC, which requires references to\n+   go through the GOT pointer (r22) instead.  */\n+\n+#define TYPE int\n+\n+struct ss\n+{\n+  TYPE x1,x2;\n+};\n+\n+extern TYPE S1;\n+extern TYPE S2[];\n+\n+extern struct ss S3;\n+extern struct ss S4[];\n+\n+TYPE *addr1 (void) { return &S1; }\n+TYPE get1 (void) { return S1; }\n+void set1 (TYPE value) { S1 = value; }\n+\n+TYPE *addr2 (int i) { return &(S2[i]); }\n+TYPE get2 (int i) { return S2[i]; }\n+void set2 (int i, TYPE value) { S2[i] = value; }\n+\n+TYPE *addr3 (void) { return &(S3.x2); }\n+TYPE get3 (void) { return S3.x2; }\n+void set3 (TYPE value) { S3.x2 = value; }\n+\n+TYPE *addr4 (int i) { return &(S4[i].x2); }\n+TYPE get4 (int i) { return S4[i].x2; }\n+void set4 (int i, TYPE value) { S4[i].x2 = value; }\n+"}, {"sha": "792ec227291b3a3edd80295bfe8fb10abb28fdeb", "filename": "gcc/testsuite/gcc.target/nios2/lo-addr-short.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57f6a200e324c605ed19fef107e528d0b902770a/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Flo-addr-short.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57f6a200e324c605ed19fef107e528d0b902770a/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Flo-addr-short.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Flo-addr-short.c?ref=57f6a200e324c605ed19fef107e528d0b902770a", "patch": "@@ -0,0 +1,51 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-final { scan-assembler-times \"addi\\tr., r., %lo\" 4 } } */\n+/* { dg-final { scan-assembler-times \"ldhu\\tr., %lo\" 4 } } */\n+/* { dg-final { scan-assembler-times \"ldh\\tr., %lo\" 8 } } */\n+/* { dg-final { scan-assembler-times \"sth\\tr., %lo\" 4 } } */\n+\n+/* Check that various address forms involving a symbolic constant\n+   with a possible constant offset and/or index register are optimized\n+   to generate a %lo relocation in the load/store instructions instead\n+   of a plain register indirect addressing mode.  */\n+/* Note: get* uses ldhu but ext* uses ldh since TYPE is signed.  */\n+\n+#define TYPE short\n+\n+struct ss\n+{\n+  TYPE x1,x2;\n+};\n+\n+extern TYPE S1;\n+extern TYPE S2[];\n+\n+extern struct ss S3;\n+extern struct ss S4[];\n+\n+TYPE *addr1 (void) { return &S1; }\n+TYPE get1 (void) { return S1; }\n+void set1 (TYPE value) { S1 = value; }\n+\n+TYPE *addr2 (int i) { return &(S2[i]); }\n+TYPE get2 (int i) { return S2[i]; }\n+void set2 (int i, TYPE value) { S2[i] = value; }\n+\n+TYPE *addr3 (void) { return &(S3.x2); }\n+TYPE get3 (void) { return S3.x2; }\n+void set3 (TYPE value) { S3.x2 = value; }\n+\n+TYPE *addr4 (int i) { return &(S4[i].x2); }\n+TYPE get4 (int i) { return S4[i].x2; }\n+void set4 (int i, TYPE value) { S4[i].x2 = value; }\n+\n+int extw1 (void) { return (int)(S1); }\n+int extw2 (int i) { return (int)(S2[i]); }\n+int extw3 (void) { return (int)(S3.x2); }\n+int extw4 (int i) { return (int)(S4[i].x2); }\n+unsigned int extwu1 (void) { return (unsigned int)(S1); }\n+unsigned int extwu2 (int i) { return (unsigned int)(S2[i]); }\n+unsigned int extwu3 (void) { return (unsigned int)(S3.x2); }\n+unsigned int extwu4 (int i) { return (unsigned int)(S4[i].x2); }\n+"}, {"sha": "d56fbc2ed8177bd11a4753d680190b7a24250cbd", "filename": "gcc/testsuite/gcc.target/nios2/lo-addr-tls.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57f6a200e324c605ed19fef107e528d0b902770a/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Flo-addr-tls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57f6a200e324c605ed19fef107e528d0b902770a/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Flo-addr-tls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Flo-addr-tls.c?ref=57f6a200e324c605ed19fef107e528d0b902770a", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-require-effective-target tls } */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-final { scan-assembler-not \"ldw\\tr., %lo\" } } */\n+/* { dg-final { scan-assembler-not \"stw\\tr., %lo\" } } */\n+\n+/* Check that address transformations for symbolic constants do NOT\n+   apply to TLS variables.  */\n+\n+#define TYPE int\n+\n+struct ss\n+{\n+  TYPE x1,x2;\n+};\n+\n+extern __thread TYPE S1;\n+extern __thread TYPE S2[];\n+\n+extern __thread struct ss S3;\n+extern __thread struct ss S4[];\n+\n+TYPE *addr1 (void) { return &S1; }\n+TYPE get1 (void) { return S1; }\n+void set1 (TYPE value) { S1 = value; }\n+\n+TYPE *addr2 (int i) { return &(S2[i]); }\n+TYPE get2 (int i) { return S2[i]; }\n+void set2 (int i, TYPE value) { S2[i] = value; }\n+\n+TYPE *addr3 (void) { return &(S3.x2); }\n+TYPE get3 (void) { return S3.x2; }\n+void set3 (TYPE value) { S3.x2 = value; }\n+\n+TYPE *addr4 (int i) { return &(S4[i].x2); }\n+TYPE get4 (int i) { return S4[i].x2; }\n+void set4 (int i, TYPE value) { S4[i].x2 = value; }\n+"}, {"sha": "e9733afde4a78d13ba610081a1d7154a62a2f9fa", "filename": "gcc/testsuite/gcc.target/nios2/lo-addr-uchar.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57f6a200e324c605ed19fef107e528d0b902770a/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Flo-addr-uchar.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57f6a200e324c605ed19fef107e528d0b902770a/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Flo-addr-uchar.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Flo-addr-uchar.c?ref=57f6a200e324c605ed19fef107e528d0b902770a", "patch": "@@ -0,0 +1,58 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-final { scan-assembler-times \"addi\\tr., r., %lo\" 4 } } */\n+/* { dg-final { scan-assembler-times \"ldbu\\tr., %lo\" 20 } } */\n+/* { dg-final { scan-assembler-times \"stb\\tr., %lo\" 4 } } */\n+\n+/* Check that various address forms involving a symbolic constant\n+   with a possible constant offset and/or index register are optimized\n+   to generate a %lo relocation in the load/store instructions instead\n+   of a plain register indirect addressing mode.  */\n+\n+#define TYPE unsigned char\n+\n+struct ss\n+{\n+  TYPE x1,x2;\n+};\n+\n+extern TYPE S1;\n+extern TYPE S2[];\n+\n+extern struct ss S3;\n+extern struct ss S4[];\n+\n+TYPE *addr1 (void) { return &S1; }\n+TYPE get1 (void) { return S1; }\n+void set1 (TYPE value) { S1 = value; }\n+\n+TYPE *addr2 (int i) { return &(S2[i]); }\n+TYPE get2 (int i) { return S2[i]; }\n+void set2 (int i, TYPE value) { S2[i] = value; }\n+\n+TYPE *addr3 (void) { return &(S3.x2); }\n+TYPE get3 (void) { return S3.x2; }\n+void set3 (TYPE value) { S3.x2 = value; }\n+\n+TYPE *addr4 (int i) { return &(S4[i].x2); }\n+TYPE get4 (int i) { return S4[i].x2; }\n+void set4 (int i, TYPE value) { S4[i].x2 = value; }\n+\n+int extw1 (void) { return (int)(S1); }\n+int extw2 (int i) { return (int)(S2[i]); }\n+int extw3 (void) { return (int)(S3.x2); }\n+int extw4 (int i) { return (int)(S4[i].x2); }\n+unsigned int extwu1 (void) { return (unsigned int)(S1); }\n+unsigned int extwu2 (int i) { return (unsigned int)(S2[i]); }\n+unsigned int extwu3 (void) { return (unsigned int)(S3.x2); }\n+unsigned int extwu4 (int i) { return (unsigned int)(S4[i].x2); }\n+\n+short exth1 (void) { return (short)(S1); }\n+short exth2 (int i) { return (short)(S2[i]); }\n+short exth3 (void) { return (short)(S3.x2); }\n+short exth4 (int i) { return (short)(S4[i].x2); }\n+unsigned short exthu1 (void) { return (unsigned short)(S1); }\n+unsigned short exthu2 (int i) { return (unsigned short)(S2[i]); }\n+unsigned short exthu3 (void) { return (unsigned short)(S3.x2); }\n+unsigned short exthu4 (int i) { return (unsigned short)(S4[i].x2); }\n+"}, {"sha": "4a19c13bf2cbf47797afbba6bfdade6bcbc7ecb4", "filename": "gcc/testsuite/gcc.target/nios2/lo-addr-ushort.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57f6a200e324c605ed19fef107e528d0b902770a/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Flo-addr-ushort.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57f6a200e324c605ed19fef107e528d0b902770a/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Flo-addr-ushort.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Flo-addr-ushort.c?ref=57f6a200e324c605ed19fef107e528d0b902770a", "patch": "@@ -0,0 +1,49 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-final { scan-assembler-times \"addi\\tr., r., %lo\" 4 } } */\n+/* { dg-final { scan-assembler-times \"ldhu\\tr., %lo\" 12 } } */\n+/* { dg-final { scan-assembler-times \"sth\\tr., %lo\" 4 } } */\n+\n+/* Check that various address forms involving a symbolic constant\n+   with a possible constant offset and/or index register are optimized\n+   to generate a %lo relocation in the load/store instructions instead\n+   of a plain register indirect addressing mode.  */\n+\n+#define TYPE unsigned short\n+\n+struct ss\n+{\n+  TYPE x1,x2;\n+};\n+\n+extern TYPE S1;\n+extern TYPE S2[];\n+\n+extern struct ss S3;\n+extern struct ss S4[];\n+\n+TYPE *addr1 (void) { return &S1; }\n+TYPE get1 (void) { return S1; }\n+void set1 (TYPE value) { S1 = value; }\n+\n+TYPE *addr2 (int i) { return &(S2[i]); }\n+TYPE get2 (int i) { return S2[i]; }\n+void set2 (int i, TYPE value) { S2[i] = value; }\n+\n+TYPE *addr3 (void) { return &(S3.x2); }\n+TYPE get3 (void) { return S3.x2; }\n+void set3 (TYPE value) { S3.x2 = value; }\n+\n+TYPE *addr4 (int i) { return &(S4[i].x2); }\n+TYPE get4 (int i) { return S4[i].x2; }\n+void set4 (int i, TYPE value) { S4[i].x2 = value; }\n+\n+int extw1 (void) { return (int)(S1); }\n+int extw2 (int i) { return (int)(S2[i]); }\n+int extw3 (void) { return (int)(S3.x2); }\n+int extw4 (int i) { return (int)(S4[i].x2); }\n+unsigned int extwu1 (void) { return (unsigned int)(S1); }\n+unsigned int extwu2 (int i) { return (unsigned int)(S2[i]); }\n+unsigned int extwu3 (void) { return (unsigned int)(S3.x2); }\n+unsigned int extwu4 (int i) { return (unsigned int)(S4[i].x2); }\n+"}, {"sha": "40a8be429bfc2bf7045681d834a6b47a82a04a55", "filename": "gcc/testsuite/gcc.target/nios2/lo-addr-volatile.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57f6a200e324c605ed19fef107e528d0b902770a/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Flo-addr-volatile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57f6a200e324c605ed19fef107e528d0b902770a/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Flo-addr-volatile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Flo-addr-volatile.c?ref=57f6a200e324c605ed19fef107e528d0b902770a", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -march=r2 -mno-cache-volatile\" } */\n+/* { dg-final { scan-assembler-times \"addi\\tr., r., %lo\" 12 } } */\n+/* { dg-final { scan-assembler-not \"ldw\\t\" } } */\n+/* { dg-final { scan-assembler-not \"stw\\t\" } } */\n+/* { dg-final { scan-assembler-not \"ldwio\\tr., %lo\" } } */\n+/* { dg-final { scan-assembler-not \"stwio\\tr., %lo\" } } */\n+\n+/* Check that we do not generate %lo addresses with R2 ldstio instructions.\n+   %lo requires a 16-bit relocation and on R2 these instructions only have a\n+   12-bit register offset.  */\n+\n+#define TYPE int\n+\n+struct ss\n+{\n+  TYPE x1,x2;\n+};\n+\n+extern volatile TYPE S1;\n+extern volatile TYPE S2[];\n+\n+extern volatile struct ss S3;\n+extern volatile struct ss S4[];\n+\n+volatile TYPE *addr1 (void) { return &S1; }\n+TYPE get1 (void) { return S1; }\n+void set1 (TYPE value) { S1 = value; }\n+\n+volatile TYPE *addr2 (int i) { return &(S2[i]); }\n+TYPE get2 (int i) { return S2[i]; }\n+void set2 (int i, TYPE value) { S2[i] = value; }\n+\n+volatile TYPE *addr3 (void) { return &(S3.x2); }\n+TYPE get3 (void) { return S3.x2; }\n+void set3 (TYPE value) { S3.x2 = value; }\n+\n+volatile TYPE *addr4 (int i) { return &(S4[i].x2); }\n+TYPE get4 (int i) { return S4[i].x2; }\n+void set4 (int i, TYPE value) { S4[i].x2 = value; }\n+"}]}