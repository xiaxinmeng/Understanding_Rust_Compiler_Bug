{"sha": "5c56efde0ffb3d25d744211d20984020f2a75e33", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWM1NmVmZGUwZmZiM2QyNWQ3NDQyMTFkMjA5ODQwMjBmMmE3NWUzMw==", "commit": {"author": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1994-05-07T00:31:51Z"}, "committer": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1994-05-07T00:31:51Z"}, "message": "(TARGET_FRW): Add note saying this option is deprecated.\n\n(TARGET_FLAT): Renamed from TARGET_FRW_COMPAT.\n(TARGET_SWITCHES): Delete references to -mfrw, -mfrw-compat.  Add -mflat.\n(CONDITIONAL_REGISTER_USAGE): If -mflat, fix %i7, rename \"%fp\"\nto \"%i7\", and make %g7 a global_reg.\n(FRAME_POINTER_REQUIRED): Handle -mflat.\n(INITIAL_FRAME_POINTER_OFFSET): Likewise.\n(ARG_POINTER_REGNUM): Explicitly say it's the frame pointer.\n(LEAF_REGISTERS): Make %g7 not a leaf register.\n(leaf_reg_backmap): Delete.\n(LEAF_REG_BACKMAP): Likewise.\n(FUNCTION_PROLOGUE): Handle -mflat.\n(FUNCTION_EPILOGUE): Likewise.\n(DELAY_SLOTS_FOR_EPILOGUE): Likewise.\n(ELIGIBLE_FOR_EPILOGUE_DELAY): Likewise.\n\nFrom-SVN: r7259", "tree": {"sha": "41d6fe9d3799792f2e8c2da7eea8a4523130c82a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/41d6fe9d3799792f2e8c2da7eea8a4523130c82a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5c56efde0ffb3d25d744211d20984020f2a75e33", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c56efde0ffb3d25d744211d20984020f2a75e33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c56efde0ffb3d25d744211d20984020f2a75e33", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c56efde0ffb3d25d744211d20984020f2a75e33/comments", "author": null, "committer": null, "parents": [{"sha": "c6aa9ce1220d7ee06053af57cd923d080701d20b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6aa9ce1220d7ee06053af57cd923d080701d20b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6aa9ce1220d7ee06053af57cd923d080701d20b"}], "stats": {"total": 50, "additions": 31, "deletions": 19}, "files": [{"sha": "e0ce855213dc7bdd8dd989920f317c3d5b887751", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 31, "deletions": 19, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c56efde0ffb3d25d744211d20984020f2a75e33/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c56efde0ffb3d25d744211d20984020f2a75e33/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=5c56efde0ffb3d25d744211d20984020f2a75e33", "patch": "@@ -118,16 +118,17 @@ extern int target_flags;\n    efficient manner.  This code is not compatible with normal sparc code.  */\n /* This is not a user selectable option yet, because it requires changes\n    that are not yet switchable via command line arguments.  */\n+/* ??? This flag is deprecated and may disappear at some point.  */\n #define TARGET_FRW (target_flags & 256)\n \n /* Nonzero means that we should generate code using a flat register window\n    model, i.e. no save/restore instructions are generated, but which is\n    compatible with normal sparc code.   This is the same as above, except\n-   that the frame pointer is %l6 instead of %fp.  This code is not as efficient\n-   as TARGET_FRW, because it has one less allocatable register.  */\n-/* This is not a user selectable option yet, because it requires changes\n-   that are not yet switchable via command line arguments.  */\n-#define TARGET_FRW_COMPAT (target_flags & 512)\n+   that the frame pointer is %i7 instead of %fp.  */\n+/* ??? This use to be named TARGET_FRW_COMPAT.  At some point TARGET_FRW will\n+   go away, but until that time only use this one when necessary.\n+   -mflat sets both.  */\n+#define TARGET_FLAT (target_flags & 512)\n \n /* Nonzero means use the registers that the Sparc ABI reserves for\n    application software.  This is the default.  */\n@@ -162,13 +163,11 @@ extern int target_flags;\n     {\"no-v8\", -64},\t\t\\\n     {\"sparclite\", 128},\t\t\\\n     {\"no-sparclite\", -128},\t\\\n-/*  {\"frw\", 256}, */\t\t\\\n-/*  {\"no-frw\", -256}, */\t\\\n-/*  {\"frw-compat\", 256+512}, */\t\\\n-/*  {\"no-frw-compat\", -(256+512)}, */ \\\n     {\"f930\", 128},\t\t\\\n     {\"f930\", -1},\t\t\\\n     {\"f934\", 128},\t\t\\\n+    {\"flat\", 256+512},\t\t\\\n+    {\"no-flat\", -(256+512)},\t\\\n     {\"app-regs\", 1024},\t\t\\\n     {\"no-app-regs\", -1024},\t\\\n     {\"hard-quad-float\", 2048},        \\\n@@ -381,6 +380,15 @@ do\t\t\t\t\t\t\t\t\\\n \tfixed_regs[3] = 1;\t\t\t\t\t\\\n \tfixed_regs[4] = 1;\t\t\t\t\t\\\n       }\t\t\t\t\t\t\t\t\\\n+    if (TARGET_FLAT)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\t/* Let the compiler believe the frame pointer is still\t\\\n+\t   %fp, but output it as %i7.  */\t\t\t\\\n+\tfixed_regs[31] = 1;\t\t\t\t\t\\\n+\treg_names[FRAME_POINTER_REGNUM] = \"%i7\";\t\t\\\n+\t/* ??? This is a hack to disable leaf functions.  */\t\\\n+\tglobal_regs[7] = 1;\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n   }\t\t\t\t\t\t\t\t\\\n while (0)\n \n@@ -447,7 +455,8 @@ extern int hard_regno_mode_ok[FIRST_PSEUDO_REGISTER];\n extern int leaf_function;\n \n #define FRAME_POINTER_REQUIRED \\\n-  (! (leaf_function_p () && only_leaf_regs_used ()))\n+  (TARGET_FRW ? (current_function_calls_alloca || current_function_varargs) \\\n+   : ! (leaf_function_p () && only_leaf_regs_used ()))\n \n /* C statement to store the difference between the frame pointer\n    and the stack pointer values immediately after the function prologue.\n@@ -456,11 +465,11 @@ extern int leaf_function;\n    it's not, there's no point in trying to eliminate the\n    frame pointer.  If it is a leaf function, we guessed right!  */\n #define INITIAL_FRAME_POINTER_OFFSET(VAR) \\\n-  ((VAR) = (TARGET_FRW ? sparc_frw_compute_frame_size (get_frame_size ()) \\\n+  ((VAR) = (TARGET_FRW ? sparc_flat_compute_frame_size (get_frame_size ()) \\\n \t    : compute_frame_size (get_frame_size (), 1)))\n \n /* Base register for access to arguments of the function.  */\n-#define ARG_POINTER_REGNUM 30\n+#define ARG_POINTER_REGNUM FRAME_POINTER_REGNUM\n \n /* Register in which static-chain is passed to a function.  This must\n    not be a register used by the prologue.  */\n@@ -577,8 +586,13 @@ enum reg_class { NO_REGS, GENERAL_REGS, FP_REGS, ALL_REGS, LIM_REG_CLASSES };\n \n #define ORDER_REGS_FOR_LOCAL_ALLOC order_regs_for_local_alloc ()\n \n+/* ??? %g7 is not a leaf register to effectively #undef LEAF_REGISTERS when\n+   -mflat is used.  Function only_leaf_regs_used will return 0 if a global\n+   register is used and is not permitted in a leaf function.  We make %g7\n+   a global reg if -mflat and voila.  Since %g7 is a system register and is\n+   fixed it won't be used by gcc anyway.  */\n #define LEAF_REGISTERS \\\n-{ 1, 1, 1, 1, 1, 1, 1, 1,\t\\\n+{ 1, 1, 1, 1, 1, 1, 1, 0,\t\\\n   0, 0, 0, 0, 0, 0, 1, 0,\t\\\n   0, 0, 0, 0, 0, 0, 0, 0,\t\\\n   1, 1, 1, 1, 1, 1, 0, 1,\t\\\n@@ -589,8 +603,6 @@ enum reg_class { NO_REGS, GENERAL_REGS, FP_REGS, ALL_REGS, LIM_REG_CLASSES };\n \n extern char leaf_reg_remap[];\n #define LEAF_REG_REMAP(REGNO) (leaf_reg_remap[REGNO])\n-extern char leaf_reg_backmap[];\n-#define LEAF_REG_BACKMAP(REGNO) (leaf_reg_backmap[REGNO])\n \n /* The class value for index registers, and the one for base regs.  */\n #define INDEX_REG_CLASS GENERAL_REGS\n@@ -939,7 +951,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n    to do this is made in regclass.c.  */\n \n #define FUNCTION_PROLOGUE(FILE, SIZE)\t\t\t\t\\\n-  (TARGET_FRW ? sparc_frw_output_function_prologue (FILE, SIZE, leaf_function)\\\n+  (TARGET_FRW ? sparc_flat_output_function_prologue (FILE, SIZE) \\\n    : output_function_prologue (FILE, SIZE, leaf_function))\n \n /* Output assembler code to FILE to increment profiler label # LABELNO\n@@ -1002,13 +1014,13 @@ extern int current_function_outgoing_args_size;\n extern union tree_node *current_function_decl;\n \n #define FUNCTION_EPILOGUE(FILE, SIZE)\t\t\t\t\\\n-  (TARGET_FRW ? sparc_frw_output_function_epilogue (FILE, SIZE, leaf_function)\\\n+  (TARGET_FRW ? sparc_flat_output_function_epilogue (FILE, SIZE) \\\n    : output_function_epilogue (FILE, SIZE, leaf_function))\n \n #define DELAY_SLOTS_FOR_EPILOGUE\t\\\n-  (TARGET_FRW ? sparc_frw_epilogue_delay_slots () : 1)\n+  (TARGET_FRW ? sparc_flat_epilogue_delay_slots () : 1)\n #define ELIGIBLE_FOR_EPILOGUE_DELAY(trial, slots_filled)\t\\\n-  (TARGET_FRW ? sparc_frw_eligible_for_epilogue_delay (trial, slots_filled) \\\n+  (TARGET_FRW ? sparc_flat_eligible_for_epilogue_delay (trial, slots_filled) \\\n    : eligible_for_epilogue_delay (trial, slots_filled))\n \f\n /* Output assembler code for a block containing the constant parts"}]}