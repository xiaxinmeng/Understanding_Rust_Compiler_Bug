{"sha": "b5493fb2fa5972e79056247600874f4480c6f8ad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjU0OTNmYjJmYTU5NzJlNzkwNTYyNDc2MDA4NzRmNDQ4MGM2ZjhhZA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2012-09-19T10:01:56Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2012-09-19T10:01:56Z"}, "message": "symtab.c (insert_to_assembler_name_hash): Do not insert register vars.\n\n\n\t* symtab.c (insert_to_assembler_name_hash): Do not insert\n\tregister vars.\n\t(unlink_from_assembler_name_hash): NULL out pointers of unlinked\n\tvar.\n\t(symtab_prevail_in_asm_name_hash): New.\n\t(symtab_initialize_asm_name_hash): Break out from ...\n\t(symtab_node_for_asm): ... here.\n\t(dump_symtab_base): Dump LTO file data.\n\t(verify_symtab_base): Register vars are not in symtab.\n\t* cgraph.h (symtab_initialize_asm_name_hash,\n\tsymtab_prevail_in_asm_name_hash): New functions.\n\t(symtab_real_symbol_p): New inline.\n\t* lto-symtab.c: Do not include gt-lto-symtab.h.\n\t(lto_symtab_entry_def): Remove.\n\t(lto_symtab_entry_t): Remove.\n\t(lto_symtab_identifiers): Remove.\n\t(lto_symtab_free): Remove.\n\t(lto_symtab_entry_hash): Remove.\n\t(lto_symtab_entry_eq): Remove.\n\t(lto_symtab_entry_marked_p): Remove.\n\t(lto_symtab_maybe_init_hash_table): Remove.\n\t(resolution_guessed_p, set_resolution_guessed): New functions.\n\t(lto_symtab_register_decl): Only set resolution info.\n\t(lto_symtab_get, lto_symtab_get_resolution): Remove.\n\t(lto_symtab_merge): Reorg to work across symtab; do nothing if decls\n\tare same.\n\t(lto_symtab_resolve_replaceable_p): Reorg to work on symtab.\n\t(lto_symtab_resolve_can_prevail_p): Likewise; only real symbols can\n\tprevail.\n\t(lto_symtab_resolve_symbols): Reorg to work on symtab.\n\t(lto_symtab_merge_decls_2): Likewise.\n\t(lto_symtab_merge_decls_1): Likewise; add debug dumps.\n\t(lto_symtab_merge_decls): Likewise; do not merge at ltrans stage.\n\t(lto_symtab_merge_cgraph_nodes_1): Reorg to work on symtab.\n\t(lto_symtab_merge_cgraph_nodes): Likewise; do not merge at ltrans stage.\n\t(lto_symtab_prevailing_decl): Rewrite to lookup into symtab.\n\t* lto-streaer.h (lto_symtab_free): Remove.\n\t* lto-cgraph.c (add_references): Cleanup.\n\t* varpool.c (varpool_assemble_decl): Skip hard regs.\n\n\t* lto.c (lto_materialize_function): Update confused comment.\n\t(read_cgraph_and_symbols): Do not free symtab.\n\nFrom-SVN: r191466", "tree": {"sha": "adf76d7fd51871b5c848e4b405009efc05ca3097", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/adf76d7fd51871b5c848e4b405009efc05ca3097"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b5493fb2fa5972e79056247600874f4480c6f8ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5493fb2fa5972e79056247600874f4480c6f8ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5493fb2fa5972e79056247600874f4480c6f8ad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5493fb2fa5972e79056247600874f4480c6f8ad/comments", "author": null, "committer": null, "parents": [{"sha": "9745abfd1ccb85110ce39ec3563a7c2a48c69ff4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9745abfd1ccb85110ce39ec3563a7c2a48c69ff4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9745abfd1ccb85110ce39ec3563a7c2a48c69ff4"}], "stats": {"total": 637, "additions": 314, "deletions": 323}, "files": [{"sha": "d00f3e2944970f94401cf1606398a16025206cb1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5493fb2fa5972e79056247600874f4480c6f8ad/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5493fb2fa5972e79056247600874f4480c6f8ad/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b5493fb2fa5972e79056247600874f4480c6f8ad", "patch": "@@ -1,3 +1,45 @@\n+2012-09-19  Jan Hubicka  <jh@suse.cz>\n+\n+\t* symtab.c (insert_to_assembler_name_hash): Do not insert\n+\tregister vars.\n+\t(unlink_from_assembler_name_hash): NULL out pointers of unlinked\n+\tvar.\n+\t(symtab_prevail_in_asm_name_hash): New.\n+\t(symtab_initialize_asm_name_hash): Break out from ...\n+\t(symtab_node_for_asm): ... here.\n+\t(dump_symtab_base): Dump LTO file data.\n+\t(verify_symtab_base): Register vars are not in symtab.\n+\t* cgraph.h (symtab_initialize_asm_name_hash,\n+\tsymtab_prevail_in_asm_name_hash): New functions.\n+\t(symtab_real_symbol_p): New inline.\n+\t* lto-symtab.c: Do not include gt-lto-symtab.h.\n+\t(lto_symtab_entry_def): Remove.\n+\t(lto_symtab_entry_t): Remove.\n+\t(lto_symtab_identifiers): Remove.\n+\t(lto_symtab_free): Remove.\n+\t(lto_symtab_entry_hash): Remove.\n+\t(lto_symtab_entry_eq): Remove.\n+\t(lto_symtab_entry_marked_p): Remove.\n+\t(lto_symtab_maybe_init_hash_table): Remove.\n+\t(resolution_guessed_p, set_resolution_guessed): New functions.\n+\t(lto_symtab_register_decl): Only set resolution info.\n+\t(lto_symtab_get, lto_symtab_get_resolution): Remove.\n+\t(lto_symtab_merge): Reorg to work across symtab; do nothing if decls\n+\tare same.\n+\t(lto_symtab_resolve_replaceable_p): Reorg to work on symtab.\n+\t(lto_symtab_resolve_can_prevail_p): Likewise; only real symbols can\n+\tprevail.\n+\t(lto_symtab_resolve_symbols): Reorg to work on symtab.\n+\t(lto_symtab_merge_decls_2): Likewise.\n+\t(lto_symtab_merge_decls_1): Likewise; add debug dumps.\n+\t(lto_symtab_merge_decls): Likewise; do not merge at ltrans stage.\n+\t(lto_symtab_merge_cgraph_nodes_1): Reorg to work on symtab.\n+\t(lto_symtab_merge_cgraph_nodes): Likewise; do not merge at ltrans stage.\n+\t(lto_symtab_prevailing_decl): Rewrite to lookup into symtab.\n+\t* lto-streaer.h (lto_symtab_free): Remove.\n+\t* lto-cgraph.c (add_references): Cleanup.\n+\t* varpool.c (varpool_assemble_decl): Skip hard regs.\n+\n 2012-09-19  Richard Guenther  <rguenther@suse.de>\n \n \tPR other/53316"}, {"sha": "b8001a62bc78e0c2aca9c0b53ebef713ad7cb0cb", "filename": "gcc/cgraph.h", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5493fb2fa5972e79056247600874f4480c6f8ad/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5493fb2fa5972e79056247600874f4480c6f8ad/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=b5493fb2fa5972e79056247600874f4480c6f8ad", "patch": "@@ -704,6 +704,8 @@ bool varpool_for_node_and_aliases (struct varpool_node *,\n \t\t                   bool (*) (struct varpool_node *, void *),\n \t\t\t           void *, bool);\n void varpool_add_new_variable (tree);\n+void symtab_initialize_asm_name_hash (void);\n+void symtab_prevail_in_asm_name_hash (symtab_node node);\n \n /* Return true when NODE is function.  */\n static inline bool\n@@ -1309,4 +1311,27 @@ cgraph_mark_force_output_node (struct cgraph_node *node)\n   gcc_checking_assert (!node->global.inlined_to);\n }\n \n+/* Return true when the symbol is real symbol, i.e. it is not inline clone\n+   or extern function kept around just for inlining.  */\n+\n+static inline bool\n+symtab_real_symbol_p (symtab_node node)\n+{\n+  struct cgraph_node *cnode;\n+  struct ipa_ref *ref;\n+\n+  if (!symtab_function_p (node))\n+    return true;\n+  cnode = cgraph (node);\n+  if (cnode->global.inlined_to)\n+    return false;\n+  if (cnode->abstract_and_needed)\n+    return false;\n+  /* We keep virtual clones in symtab.  */\n+  if (!cnode->analyzed\n+      || DECL_EXTERNAL (cnode->symbol.decl))\n+    return (cnode->callers\n+\t    || ipa_ref_list_referring_iterate (&cnode->symbol.ref_list, 0, ref));\n+  return true;\n+}\n #endif  /* GCC_CGRAPH_H  */"}, {"sha": "b86933430904178afea0bc00b2bc0e619eced562", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5493fb2fa5972e79056247600874f4480c6f8ad/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5493fb2fa5972e79056247600874f4480c6f8ad/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=b5493fb2fa5972e79056247600874f4480c6f8ad", "patch": "@@ -668,10 +668,7 @@ add_references (lto_symtab_encoder_t encoder,\n     if (symtab_function_p (ref->referred))\n       add_node_to (encoder, ipa_ref_node (ref), false);\n     else\n-      {\n-\tstruct varpool_node *vnode = ipa_ref_varpool_node (ref);\n-        lto_symtab_encoder_encode (encoder, (symtab_node)vnode);\n-      }\n+      lto_symtab_encoder_encode (encoder, ref->referred);\n }\n \n /* Find all symbols we want to stream into given partition and insert them"}, {"sha": "059959e737ff32999571b61db0b88baa11d7e1a6", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5493fb2fa5972e79056247600874f4480c6f8ad/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5493fb2fa5972e79056247600874f4480c6f8ad/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=b5493fb2fa5972e79056247600874f4480c6f8ad", "patch": "@@ -866,7 +866,6 @@ extern void lto_symtab_merge_decls (void);\n extern void lto_symtab_merge_cgraph_nodes (void);\n extern tree lto_symtab_prevailing_decl (tree decl);\n extern enum ld_plugin_symbol_resolution lto_symtab_get_resolution (tree decl);\n-extern void lto_symtab_free (void);\n extern GTY(()) VEC(tree,gc) *lto_global_var_decls;\n \n "}, {"sha": "58b77a353a7ba31c1b9521b481c2f2a1aca19ee4", "filename": "gcc/lto-symtab.c", "status": "modified", "additions": 202, "deletions": 308, "changes": 510, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5493fb2fa5972e79056247600874f4480c6f8ad/gcc%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5493fb2fa5972e79056247600874f4480c6f8ad/gcc%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-symtab.c?ref=b5493fb2fa5972e79056247600874f4480c6f8ad", "patch": "@@ -32,98 +32,19 @@ along with GCC; see the file COPYING3.  If not see\n /* Vector to keep track of external variables we've seen so far.  */\n VEC(tree,gc) *lto_global_var_decls;\n \n-/* Symbol table entry.  */\n-\n-struct GTY(()) lto_symtab_entry_def\n-{\n-  /* The symbol table entry key, an IDENTIFIER.  */\n-  tree id;\n-  /* The symbol table entry, a DECL.  */\n-  tree decl;\n-  /* The cgraph node if decl is a function decl.  Filled in during the\n-     merging process.  */\n-  struct cgraph_node *node;\n-  /* The varpool node if decl is a variable decl.  Filled in during the\n-     merging process.  */\n-  struct varpool_node *vnode;\n-  /* LTO file-data and symbol resolution for this decl.  */\n-  struct lto_file_decl_data * GTY((skip (\"\"))) file_data;\n-  enum ld_plugin_symbol_resolution resolution;\n-  /* True when resolution was guessed and not read from the file.  */\n-  bool guessed;\n-  /* Pointer to the next entry with the same key.  Before decl merging\n-     this links all symbols from the different TUs.  After decl merging\n-     this links merged but incompatible decls, thus all prevailing ones\n-     remaining.  */\n-  struct lto_symtab_entry_def *next;\n-};\n-typedef struct lto_symtab_entry_def *lto_symtab_entry_t;\n-\n-/* A poor man's symbol table. This hashes identifier to prevailing DECL\n-   if there is one. */\n-\n-static GTY ((if_marked (\"lto_symtab_entry_marked_p\"),\n-\t     param_is (struct lto_symtab_entry_def)))\n-  htab_t lto_symtab_identifiers;\n-\n-/* Free symtab hashtable.  */\n-\n-void\n-lto_symtab_free (void)\n-{\n-  htab_delete (lto_symtab_identifiers);\n-  lto_symtab_identifiers = NULL;\n-}\n-\n-/* Return the hash value of an lto_symtab_entry_t object pointed to by P.  */\n-\n-static hashval_t\n-lto_symtab_entry_hash (const void *p)\n-{\n-  const struct lto_symtab_entry_def *base =\n-    (const struct lto_symtab_entry_def *) p;\n-  return IDENTIFIER_HASH_VALUE (base->id);\n-}\n-\n-/* Return non-zero if P1 and P2 points to lto_symtab_entry_def structs\n-   corresponding to the same symbol.  */\n-\n-static int\n-lto_symtab_entry_eq (const void *p1, const void *p2)\n+/* Return true if the resolution was guessed and not obtained from\n+   the file.  */\n+static inline bool\n+resolution_guessed_p (symtab_node node)\n {\n-  const struct lto_symtab_entry_def *base1 =\n-     (const struct lto_symtab_entry_def *) p1;\n-  const struct lto_symtab_entry_def *base2 =\n-     (const struct lto_symtab_entry_def *) p2;\n-  return (base1->id == base2->id);\n+  return node->symbol.aux != NULL;\n }\n \n-/* Returns non-zero if P points to an lto_symtab_entry_def struct that needs\n-   to be marked for GC.  */\n-\n-static int\n-lto_symtab_entry_marked_p (const void *p)\n+/* Set guessed flag for NODE.  */\n+static inline void\n+set_resolution_guessed (symtab_node node, bool value)\n {\n-  const struct lto_symtab_entry_def *base =\n-     (const struct lto_symtab_entry_def *) p;\n-\n-  /* Keep this only if the common IDENTIFIER_NODE of the symtab chain\n-     is marked which it will be if at least one of the DECLs in the\n-     chain is marked.  */\n-  return ggc_marked_p (base->id);\n-}\n-\n-/* Lazily initialize resolution hash tables.  */\n-\n-static void\n-lto_symtab_maybe_init_hash_table (void)\n-{\n-  if (lto_symtab_identifiers)\n-    return;\n-\n-  lto_symtab_identifiers =\n-    htab_create_ggc (1021, lto_symtab_entry_hash,\n-\t\t     lto_symtab_entry_eq, NULL);\n+  node->symbol.aux = (void *)(size_t)value;\n }\n \n /* Registers DECL with the LTO symbol table as having resolution RESOLUTION\n@@ -134,8 +55,7 @@ lto_symtab_register_decl (tree decl,\n \t\t\t  ld_plugin_symbol_resolution_t resolution,\n \t\t\t  struct lto_file_decl_data *file_data)\n {\n-  lto_symtab_entry_t new_entry;\n-  void **slot;\n+  symtab_node node;\n \n   /* Check that declarations reaching this function do not have\n      properties inconsistent with having external linkage.  If any of\n@@ -153,54 +73,15 @@ lto_symtab_register_decl (tree decl,\n   if (TREE_CODE (decl) == FUNCTION_DECL)\n     gcc_assert (!DECL_ABSTRACT (decl));\n \n-  new_entry = ggc_alloc_cleared_lto_symtab_entry_def ();\n-  new_entry->id = (*targetm.asm_out.mangle_assembler_name)\n-\t\t  (IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl)));\n-  new_entry->decl = decl;\n-  new_entry->resolution = resolution;\n-  new_entry->file_data = file_data;\n-\n-  lto_symtab_maybe_init_hash_table ();\n-  slot = htab_find_slot (lto_symtab_identifiers, new_entry, INSERT);\n-  new_entry->next = (lto_symtab_entry_t) *slot;\n-  *slot = new_entry;\n-}\n-\n-/* Get the lto_symtab_entry_def struct associated with ID\n-   if there is one.  */\n-\n-static lto_symtab_entry_t\n-lto_symtab_get (tree id)\n-{\n-  struct lto_symtab_entry_def temp;\n-  void **slot;\n-\n-  lto_symtab_maybe_init_hash_table ();\n-  temp.id = id;\n-  slot = htab_find_slot (lto_symtab_identifiers, &temp, NO_INSERT);\n-  return slot ? (lto_symtab_entry_t) *slot : NULL;\n-}\n-\n-/* Get the linker resolution for DECL.  */\n-\n-enum ld_plugin_symbol_resolution\n-lto_symtab_get_resolution (tree decl)\n-{\n-  lto_symtab_entry_t e;\n-\n-  gcc_assert (DECL_ASSEMBLER_NAME_SET_P (decl));\n-\n-  e = lto_symtab_get ((*targetm.asm_out.mangle_assembler_name)\n-\t\t      (IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl))));\n-  while (e && e->decl != decl)\n-    e = e->next;\n-  if (!e)\n-    return LDPR_UNKNOWN;\n-\n-  return e->resolution;\n+  node = symtab_get_node (decl);\n+  if (node)\n+    {\n+      node->symbol.resolution = resolution;\n+      gcc_assert (node->symbol.lto_file_data == file_data);\n+      gcc_assert (!resolution_guessed_p (node));\n+    }\n }\n \n-\n /* Replace the cgraph node NODE with PREVAILING_NODE in the cgraph, merging\n    all edges and removing the old node.  */\n \n@@ -277,12 +158,15 @@ lto_varpool_replace_node (struct varpool_node *vnode,\n    should be emitted.  */\n \n static bool\n-lto_symtab_merge (lto_symtab_entry_t prevailing, lto_symtab_entry_t entry)\n+lto_symtab_merge (symtab_node prevailing, symtab_node entry)\n {\n-  tree prevailing_decl = prevailing->decl;\n-  tree decl = entry->decl;\n+  tree prevailing_decl = prevailing->symbol.decl;\n+  tree decl = entry->symbol.decl;\n   tree prevailing_type, type;\n \n+  if (prevailing_decl == decl)\n+    return true;\n+\n   /* Merge decl state in both directions, we may still end up using\n      the new decl.  */\n   TREE_ADDRESSABLE (prevailing_decl) |= TREE_ADDRESSABLE (decl);\n@@ -377,42 +261,41 @@ lto_symtab_merge (lto_symtab_entry_t prevailing, lto_symtab_entry_t entry)\n    entry.  */\n \n static bool\n-lto_symtab_resolve_replaceable_p (lto_symtab_entry_t e)\n+lto_symtab_resolve_replaceable_p (symtab_node e)\n {\n-  if (DECL_EXTERNAL (e->decl)\n-      || DECL_COMDAT (e->decl)\n-      || DECL_ONE_ONLY (e->decl)\n-      || DECL_WEAK (e->decl))\n+  if (DECL_EXTERNAL (e->symbol.decl)\n+      || DECL_COMDAT (e->symbol.decl)\n+      || DECL_ONE_ONLY (e->symbol.decl)\n+      || DECL_WEAK (e->symbol.decl))\n     return true;\n \n-  if (TREE_CODE (e->decl) == VAR_DECL)\n-    return (DECL_COMMON (e->decl)\n-\t    || (!flag_no_common && !DECL_INITIAL (e->decl)));\n+  if (TREE_CODE (e->symbol.decl) == VAR_DECL)\n+    return (DECL_COMMON (e->symbol.decl)\n+\t    || (!flag_no_common && !DECL_INITIAL (e->symbol.decl)));\n \n   return false;\n }\n \n /* Return true if the symtab entry E can be the prevailing one.  */\n \n static bool\n-lto_symtab_resolve_can_prevail_p (lto_symtab_entry_t e)\n+lto_symtab_resolve_can_prevail_p (symtab_node e)\n {\n+  if (!symtab_real_symbol_p (e))\n+    return false;\n+\n   /* The C++ frontend ends up neither setting TREE_STATIC nor\n      DECL_EXTERNAL on virtual methods but only TREE_PUBLIC.\n      So do not reject !TREE_STATIC here but only DECL_EXTERNAL.  */\n-  if (DECL_EXTERNAL (e->decl))\n+  if (DECL_EXTERNAL (e->symbol.decl))\n     return false;\n \n   /* For functions we need a non-discarded body.  */\n-  if (TREE_CODE (e->decl) == FUNCTION_DECL)\n-    return (e->node && e->node->analyzed);\n+  if (TREE_CODE (e->symbol.decl) == FUNCTION_DECL)\n+    return (cgraph (e)->analyzed);\n \n-  else if (TREE_CODE (e->decl) == VAR_DECL)\n-    {\n-      if (!e->vnode)\n-\treturn false;\n-      return e->vnode->finalized;\n-    }\n+  else if (TREE_CODE (e->symbol.decl) == VAR_DECL)\n+    return varpool (e)->finalized;\n \n   gcc_unreachable ();\n }\n@@ -421,50 +304,45 @@ lto_symtab_resolve_can_prevail_p (lto_symtab_entry_t e)\n    their resolutions.  */\n \n static void\n-lto_symtab_resolve_symbols (void **slot)\n+lto_symtab_resolve_symbols (symtab_node first)\n {\n-  lto_symtab_entry_t e;\n-  lto_symtab_entry_t prevailing = NULL;\n+  symtab_node e;\n+  symtab_node prevailing = NULL;\n \n   /* Always set e->node so that edges are updated to reflect decl merging. */\n-  for (e = (lto_symtab_entry_t) *slot; e; e = e->next)\n-    {\n-      if (TREE_CODE (e->decl) == FUNCTION_DECL)\n-\te->node = cgraph_get_node (e->decl);\n-      else if (TREE_CODE (e->decl) == VAR_DECL)\n-\te->vnode = varpool_get_node (e->decl);\n-      if (e->resolution == LDPR_PREVAILING_DEF_IRONLY\n-\t  || e->resolution == LDPR_PREVAILING_DEF_IRONLY_EXP\n-\t  || e->resolution == LDPR_PREVAILING_DEF)\n-\tprevailing = e;\n-    }\n+  for (e = first; e; e = e->symbol.next_sharing_asm_name)\n+    if (symtab_real_symbol_p (e)\n+\t&& (e->symbol.resolution == LDPR_PREVAILING_DEF_IRONLY\n+\t    || e->symbol.resolution == LDPR_PREVAILING_DEF_IRONLY_EXP\n+\t    || e->symbol.resolution == LDPR_PREVAILING_DEF))\n+      prevailing = e;\n \n   /* If the chain is already resolved there is nothing else to do.  */\n   if (prevailing)\n     return;\n \n   /* Find the single non-replaceable prevailing symbol and\n      diagnose ODR violations.  */\n-  for (e = (lto_symtab_entry_t) *slot; e; e = e->next)\n+  for (e = first; e; e = e->symbol.next_sharing_asm_name)\n     {\n       if (!lto_symtab_resolve_can_prevail_p (e))\n \t{\n-\t  e->resolution = LDPR_RESOLVED_IR;\n-          e->guessed = true;\n+\t  e->symbol.resolution = LDPR_RESOLVED_IR;\n+          set_resolution_guessed (e, true);\n \t  continue;\n \t}\n \n       /* Set a default resolution - the final prevailing one will get\n          adjusted later.  */\n-      e->resolution = LDPR_PREEMPTED_IR;\n-      e->guessed = true;\n+      e->symbol.resolution = LDPR_PREEMPTED_IR;\n+      set_resolution_guessed (e, true);\n       if (!lto_symtab_resolve_replaceable_p (e))\n \t{\n \t  if (prevailing)\n \t    {\n-\t      error_at (DECL_SOURCE_LOCATION (e->decl),\n-\t\t\t\"%qD has already been defined\", e->decl);\n-\t      inform (DECL_SOURCE_LOCATION (prevailing->decl),\n+\t      error_at (DECL_SOURCE_LOCATION (e->symbol.decl),\n+\t\t\t\"%qD has already been defined\", e->symbol.decl);\n+\t      inform (DECL_SOURCE_LOCATION (prevailing->symbol.decl),\n \t\t      \"previously defined here\");\n \t    }\n \t  prevailing = e;\n@@ -474,22 +352,23 @@ lto_symtab_resolve_symbols (void **slot)\n     goto found;\n \n   /* Do a second round choosing one from the replaceable prevailing decls.  */\n-  for (e = (lto_symtab_entry_t) *slot; e; e = e->next)\n+  for (e = first; e; e = e->symbol.next_sharing_asm_name)\n     {\n-      if (e->resolution != LDPR_PREEMPTED_IR)\n+      if (e->symbol.resolution != LDPR_PREEMPTED_IR\n+\t  || !symtab_real_symbol_p (e))\n \tcontinue;\n \n       /* Choose the first function that can prevail as prevailing.  */\n-      if (TREE_CODE (e->decl) == FUNCTION_DECL)\n+      if (TREE_CODE (e->symbol.decl) == FUNCTION_DECL)\n \t{\n \t  prevailing = e;\n \t  break;\n \t}\n \n       /* From variables that can prevail choose the largest one.  */\n       if (!prevailing\n-\t  || tree_int_cst_lt (DECL_SIZE (prevailing->decl),\n-\t\t\t      DECL_SIZE (e->decl))\n+\t  || tree_int_cst_lt (DECL_SIZE (prevailing->symbol.decl),\n+\t\t\t      DECL_SIZE (e->symbol.decl))\n \t  /* When variables are equivalent try to chose one that has useful\n \t     DECL_INITIAL.  This makes sense for keyed vtables that are\n \t     DECL_EXTERNAL but initialized.  In units that do not need them\n@@ -499,11 +378,11 @@ lto_symtab_resolve_symbols (void **slot)\n \t     We know that the vtable is keyed outside the LTO unit - otherwise\n \t     the keyed instance would prevail.  We still can preserve useful\n \t     info in the initializer.  */\n-\t  || (DECL_SIZE (prevailing->decl) == DECL_SIZE (e->decl)\n-\t      && (DECL_INITIAL (e->decl)\n-\t\t  && DECL_INITIAL (e->decl) != error_mark_node)\n-\t      && (!DECL_INITIAL (prevailing->decl)\n-\t\t  || DECL_INITIAL (prevailing->decl) == error_mark_node)))\n+\t  || (DECL_SIZE (prevailing->symbol.decl) == DECL_SIZE (e->symbol.decl)\n+\t      && (DECL_INITIAL (e->symbol.decl)\n+\t\t  && DECL_INITIAL (e->symbol.decl) != error_mark_node)\n+\t      && (!DECL_INITIAL (prevailing->symbol.decl)\n+\t\t  || DECL_INITIAL (prevailing->symbol.decl) == error_mark_node)))\n \tprevailing = e;\n     }\n \n@@ -524,153 +403,155 @@ lto_symtab_resolve_symbols (void **slot)\n     variables IRONLY, which are indeed PREVAILING_DEF in\n     resolution file.  These variables still need manual\n     externally_visible attribute.  */\n-    prevailing->resolution = LDPR_PREVAILING_DEF_IRONLY;\n-    prevailing->guessed = true;\n+    prevailing->symbol.resolution = LDPR_PREVAILING_DEF_IRONLY;\n+    set_resolution_guessed (prevailing, true);\n }\n \n /* Merge all decls in the symbol table chain to the prevailing decl and\n    issue diagnostics about type mismatches.  If DIAGNOSED_P is true\n    do not issue further diagnostics.*/\n \n static void\n-lto_symtab_merge_decls_2 (void **slot, bool diagnosed_p)\n+lto_symtab_merge_decls_2 (symtab_node first, bool diagnosed_p)\n {\n-  lto_symtab_entry_t prevailing, e;\n+  symtab_node prevailing, e;\n   VEC(tree, heap) *mismatches = NULL;\n   unsigned i;\n   tree decl;\n \n   /* Nothing to do for a single entry.  */\n-  prevailing = (lto_symtab_entry_t) *slot;\n-  if (!prevailing->next)\n+  prevailing = first;\n+  if (!prevailing->symbol.next_sharing_asm_name)\n     return;\n \n   /* Try to merge each entry with the prevailing one.  */\n-  for (e = prevailing->next; e; e = e->next)\n+  for (e = prevailing->symbol.next_sharing_asm_name;\n+       e; e = e->symbol.next_sharing_asm_name)\n     {\n       if (!lto_symtab_merge (prevailing, e)\n \t  && !diagnosed_p)\n-\tVEC_safe_push (tree, heap, mismatches, e->decl);\n+\tVEC_safe_push (tree, heap, mismatches, e->symbol.decl);\n     }\n   if (VEC_empty (tree, mismatches))\n     return;\n \n   /* Diagnose all mismatched re-declarations.  */\n   FOR_EACH_VEC_ELT (tree, mismatches, i, decl)\n     {\n-      if (!types_compatible_p (TREE_TYPE (prevailing->decl), TREE_TYPE (decl)))\n+      if (!types_compatible_p (TREE_TYPE (prevailing->symbol.decl),\n+\t\t\t       TREE_TYPE (decl)))\n \tdiagnosed_p |= warning_at (DECL_SOURCE_LOCATION (decl), 0,\n \t\t\t\t   \"type of %qD does not match original \"\n \t\t\t\t   \"declaration\", decl);\n \n-      else if ((DECL_USER_ALIGN (prevailing->decl) && DECL_USER_ALIGN (decl))\n-\t       && DECL_ALIGN (prevailing->decl) < DECL_ALIGN (decl))\n+      else if ((DECL_USER_ALIGN (prevailing->symbol.decl)\n+\t        && DECL_USER_ALIGN (decl))\n+\t       && DECL_ALIGN (prevailing->symbol.decl) < DECL_ALIGN (decl))\n \t{\n \t  diagnosed_p |= warning_at (DECL_SOURCE_LOCATION (decl), 0,\n \t\t\t\t     \"alignment of %qD is bigger than \"\n \t\t\t\t     \"original declaration\", decl);\n \t}\n     }\n   if (diagnosed_p)\n-    inform (DECL_SOURCE_LOCATION (prevailing->decl),\n+    inform (DECL_SOURCE_LOCATION (prevailing->symbol.decl),\n \t    \"previously declared here\");\n \n   VEC_free (tree, heap, mismatches);\n }\n \n /* Helper to process the decl chain for the symbol table entry *SLOT.  */\n \n-static int\n-lto_symtab_merge_decls_1 (void **slot, void *data ATTRIBUTE_UNUSED)\n+static void\n+lto_symtab_merge_decls_1 (symtab_node first)\n {\n-  lto_symtab_entry_t e, prevailing;\n+  symtab_node e, prevailing;\n   bool diagnosed_p = false;\n \n+  if (cgraph_dump_file)\n+    {\n+      fprintf (cgraph_dump_file, \"Merging nodes for %s. Candidates:\\n\",\n+\t       symtab_node_asm_name (first));\n+      for (e = first; e; e = e->symbol.next_sharing_asm_name)\n+\tdump_symtab_node (cgraph_dump_file, e);\n+    }\n+\n   /* Compute the symbol resolutions.  This is a no-op when using the\n-     linker plugin.  */\n-  lto_symtab_resolve_symbols (slot);\n+     linker plugin and resolution was decided by the linker.  */\n+  lto_symtab_resolve_symbols (first);\n \n   /* Find the prevailing decl.  */\n-  for (prevailing = (lto_symtab_entry_t) *slot;\n+  for (prevailing = first;\n        prevailing\n-       && prevailing->resolution != LDPR_PREVAILING_DEF_IRONLY\n-       && prevailing->resolution != LDPR_PREVAILING_DEF_IRONLY_EXP\n-       && prevailing->resolution != LDPR_PREVAILING_DEF;\n-       prevailing = prevailing->next)\n+       && (!symtab_real_symbol_p (prevailing)\n+\t   || (prevailing->symbol.resolution != LDPR_PREVAILING_DEF_IRONLY\n+\t       && prevailing->symbol.resolution != LDPR_PREVAILING_DEF_IRONLY_EXP\n+\t       && prevailing->symbol.resolution != LDPR_PREVAILING_DEF));\n+       prevailing = prevailing->symbol.next_sharing_asm_name)\n     ;\n \n   /* Assert it's the only one.  */\n   if (prevailing)\n-    for (e = prevailing->next; e; e = e->next)\n-      {\n-\tif (e->resolution == LDPR_PREVAILING_DEF_IRONLY\n-\t    || e->resolution == LDPR_PREVAILING_DEF_IRONLY_EXP\n-\t    || e->resolution == LDPR_PREVAILING_DEF)\n-\t  fatal_error (\"multiple prevailing defs for %qE\",\n-\t\t       DECL_NAME (prevailing->decl));\n-      }\n+    for (e = prevailing->symbol.next_sharing_asm_name; e; e = e->symbol.next_sharing_asm_name)\n+      if (symtab_real_symbol_p (e)\n+\t  && (e->symbol.resolution == LDPR_PREVAILING_DEF_IRONLY\n+\t      || e->symbol.resolution == LDPR_PREVAILING_DEF_IRONLY_EXP\n+\t      || e->symbol.resolution == LDPR_PREVAILING_DEF))\n+\tfatal_error (\"multiple prevailing defs for %qE\",\n+\t\t     DECL_NAME (prevailing->symbol.decl));\n \n   /* If there's not a prevailing symbol yet it's an external reference.\n      Happens a lot during ltrans.  Choose the first symbol with a\n      cgraph or a varpool node.  */\n   if (!prevailing)\n     {\n-      prevailing = (lto_symtab_entry_t) *slot;\n-      /* For functions choose one with a cgraph node.  */\n-      if (TREE_CODE (prevailing->decl) == FUNCTION_DECL)\n-\twhile (!prevailing->node\n-\t       && prevailing->next)\n-\t  prevailing = prevailing->next;\n+      prevailing = first;\n       /* For variables chose with a priority variant with vnode\n \t attached (i.e. from unit where external declaration of\n \t variable is actually used).\n \t When there are multiple variants, chose one with size.\n \t This is needed for C++ typeinfos, for example in\n \t lto/20081204-1 there are typeifos in both units, just\n \t one of them do have size.  */\n-      if (TREE_CODE (prevailing->decl) == VAR_DECL)\n+      if (TREE_CODE (prevailing->symbol.decl) == VAR_DECL)\n \t{\n-\t  for (e = prevailing->next; e; e = e->next)\n-\t    if ((!prevailing->vnode && e->vnode)\n-\t\t|| ((prevailing->vnode != NULL) == (e->vnode != NULL)\n-\t\t    && !COMPLETE_TYPE_P (TREE_TYPE (prevailing->decl))\n-\t\t    && COMPLETE_TYPE_P (TREE_TYPE (e->decl))))\n+\t  for (e = prevailing->symbol.next_sharing_asm_name;\n+\t       e; e = e->symbol.next_sharing_asm_name)\n+\t    if (!COMPLETE_TYPE_P (TREE_TYPE (prevailing->symbol.decl))\n+\t\t&& COMPLETE_TYPE_P (TREE_TYPE (e->symbol.decl)))\n \t      prevailing = e;\n \t}\n     }\n \n-  /* Move it first in the list.  */\n-  if ((lto_symtab_entry_t) *slot != prevailing)\n-    {\n-      for (e = (lto_symtab_entry_t) *slot; e->next != prevailing; e = e->next)\n-\t;\n-      e->next = prevailing->next;\n-      prevailing->next = (lto_symtab_entry_t) *slot;\n-      *slot = (void *) prevailing;\n-    }\n+  symtab_prevail_in_asm_name_hash (prevailing);\n \n   /* Record the prevailing variable.  */\n-  if (TREE_CODE (prevailing->decl) == VAR_DECL)\n-    VEC_safe_push (tree, gc, lto_global_var_decls, prevailing->decl);\n+  if (TREE_CODE (prevailing->symbol.decl) == VAR_DECL)\n+    VEC_safe_push (tree, gc, lto_global_var_decls,\n+\t\t   prevailing->symbol.decl);\n \n   /* Diagnose mismatched objects.  */\n-  for (e = prevailing->next; e; e = e->next)\n+  for (e = prevailing->symbol.next_sharing_asm_name;\n+       e; e = e->symbol.next_sharing_asm_name)\n     {\n-      if (TREE_CODE (prevailing->decl) == TREE_CODE (e->decl))\n+      if (TREE_CODE (prevailing->symbol.decl)\n+\t  == TREE_CODE (e->symbol.decl))\n \tcontinue;\n \n-      switch (TREE_CODE (prevailing->decl))\n+      switch (TREE_CODE (prevailing->symbol.decl))\n \t{\n \tcase VAR_DECL:\n-\t  gcc_assert (TREE_CODE (e->decl) == FUNCTION_DECL);\n-\t  error_at (DECL_SOURCE_LOCATION (e->decl),\n-\t\t    \"variable %qD redeclared as function\", prevailing->decl);\n+\t  gcc_assert (TREE_CODE (e->symbol.decl) == FUNCTION_DECL);\n+\t  error_at (DECL_SOURCE_LOCATION (e->symbol.decl),\n+\t\t    \"variable %qD redeclared as function\",\n+\t\t    prevailing->symbol.decl);\n \t  break;\n \n \tcase FUNCTION_DECL:\n-\t  gcc_assert (TREE_CODE (e->decl) == VAR_DECL);\n-\t  error_at (DECL_SOURCE_LOCATION (e->decl),\n-\t\t    \"function %qD redeclared as variable\", prevailing->decl);\n+\t  gcc_assert (TREE_CODE (e->symbol.decl) == VAR_DECL);\n+\t  error_at (DECL_SOURCE_LOCATION (e->symbol.decl),\n+\t\t    \"function %qD redeclared as variable\",\n+\t\t    prevailing->symbol.decl);\n \t  break;\n \n \tdefault:\n@@ -680,12 +561,19 @@ lto_symtab_merge_decls_1 (void **slot, void *data ATTRIBUTE_UNUSED)\n       diagnosed_p = true;\n     }\n   if (diagnosed_p)\n-      inform (DECL_SOURCE_LOCATION (prevailing->decl),\n+      inform (DECL_SOURCE_LOCATION (prevailing->symbol.decl),\n \t      \"previously declared here\");\n \n   /* Merge the chain to the single prevailing decl and diagnose\n      mismatches.  */\n-  lto_symtab_merge_decls_2 (slot, diagnosed_p);\n+  lto_symtab_merge_decls_2 (first, diagnosed_p);\n+\n+  if (cgraph_dump_file)\n+    {\n+      fprintf (cgraph_dump_file, \"After resolution:\\n\");\n+      for (e = first; e; e = e->symbol.next_sharing_asm_name)\n+\tdump_symtab_node (cgraph_dump_file, e);\n+    }\n \n   /* Store resolution decision into the callgraph.  \n      In LTRANS don't overwrite information we stored into callgraph at\n@@ -698,62 +586,56 @@ lto_symtab_merge_decls_1 (void **slot, void *data ATTRIBUTE_UNUSED)\n      PREVAILING_DEF, PREVAILING_DEF_IRONLY, PREVAILING_DEF_IRONLY_EXP.\n      First one would disable some whole program optimizations, while\n      ther second would imply to many whole program assumptions.  */\n-  if (prevailing->node && !flag_ltrans && !prevailing->guessed)\n-    prevailing->node->symbol.resolution = prevailing->resolution;\n-  else if (prevailing->vnode && !flag_ltrans && !prevailing->guessed)\n-    prevailing->vnode->symbol.resolution = prevailing->resolution;\n-  return 1;\n+  if (resolution_guessed_p (prevailing))\n+    prevailing->symbol.resolution = LDPR_UNKNOWN;\n+  return;\n }\n \n /* Resolve and merge all symbol table chains to a prevailing decl.  */\n \n void\n lto_symtab_merge_decls (void)\n {\n-  lto_symtab_maybe_init_hash_table ();\n-  htab_traverse (lto_symtab_identifiers, lto_symtab_merge_decls_1, NULL);\n+  symtab_node node;\n+\n+  /* In ltrans mode we read merged cgraph, we do not really need to care\n+     about resolving symbols again, we only need to replace duplicated declarations\n+     read from the callgraph and from function sections.  */\n+  if (flag_ltrans)\n+    return;\n+\n+  /* Populate assembler name hash.   */\n+  symtab_initialize_asm_name_hash ();\n+\n+  FOR_EACH_SYMBOL (node)\n+    if (TREE_PUBLIC (node->symbol.decl)\n+\t&& node->symbol.next_sharing_asm_name\n+\t&& !node->symbol.previous_sharing_asm_name)\n+    lto_symtab_merge_decls_1 (node);\n }\n \n /* Helper to process the decl chain for the symbol table entry *SLOT.  */\n \n-static int\n-lto_symtab_merge_cgraph_nodes_1 (void **slot, void *data ATTRIBUTE_UNUSED)\n+static void\n+lto_symtab_merge_cgraph_nodes_1 (symtab_node prevailing)\n {\n-  lto_symtab_entry_t e, prevailing = (lto_symtab_entry_t) *slot;\n-\n-  if (!prevailing->next)\n-    return 1;\n+  symtab_node e, next;\n \n   /* Replace the cgraph node of each entry with the prevailing one.  */\n-  for (e = prevailing->next; e; e = e->next)\n+  for (e = prevailing->symbol.next_sharing_asm_name; e;\n+       e = next)\n     {\n-      if (e->node != NULL)\n-\t{\n-\t  /* In case we prevail funcion by an alias, we can run into case\n-\t     that the alias has no cgraph node attached, since it was\n-\t     previously unused.  Create the node.  */\n-\t  if (!prevailing->node)\n-\t    {\n-\t      prevailing->node = cgraph_create_node (prevailing->decl);\n-\t      prevailing->node->alias = true;\n-\t    }\n-\t  lto_cgraph_replace_node (e->node, prevailing->node);\n-\t}\n-      if (e->vnode != NULL)\n-\t{\n-\t  if (!prevailing->vnode)\n-\t    {\n-\t      prevailing->vnode = varpool_node (prevailing->decl);\n-\t      prevailing->vnode->alias = true;\n-\t    }\n-\t  lto_varpool_replace_node (e->vnode, prevailing->vnode);\n-\t}\n-    }\n+      next = e->symbol.next_sharing_asm_name;\n \n-  /* Drop all but the prevailing decl from the symtab.  */\n-  prevailing->next = NULL;\n+      if (!symtab_real_symbol_p (e))\n+\tcontinue;\n+      if (symtab_function_p (e))\n+\tlto_cgraph_replace_node (cgraph (e), cgraph (prevailing));\n+      if (symtab_variable_p (e))\n+\tlto_varpool_replace_node (varpool (e), varpool (prevailing));\n+    }\n \n-  return 1;\n+  return;\n }\n \n /* Merge cgraph nodes according to the symbol merging done by\n@@ -762,26 +644,41 @@ lto_symtab_merge_cgraph_nodes_1 (void **slot, void *data ATTRIBUTE_UNUSED)\n void\n lto_symtab_merge_cgraph_nodes (void)\n {\n-  struct cgraph_node *node;\n+  struct cgraph_node *cnode;\n   struct varpool_node *vnode;\n-  lto_symtab_maybe_init_hash_table ();\n-  htab_traverse (lto_symtab_identifiers, lto_symtab_merge_cgraph_nodes_1, NULL);\n+  symtab_node node;\n+\n+  /* Populate assembler name hash.   */\n+  symtab_initialize_asm_name_hash ();\n \n-  FOR_EACH_FUNCTION (node)\n-    if ((node->thunk.thunk_p || node->alias)\n-\t&& node->thunk.alias)\n-      node->thunk.alias = lto_symtab_prevailing_decl (node->thunk.alias);\n+  if (!flag_ltrans)\n+    FOR_EACH_SYMBOL (node)\n+      if (TREE_PUBLIC (node->symbol.decl)\n+\t  && node->symbol.next_sharing_asm_name\n+\t  && !node->symbol.previous_sharing_asm_name)\n+        lto_symtab_merge_cgraph_nodes_1 (node);\n+\n+  FOR_EACH_FUNCTION (cnode)\n+    {\n+      if ((cnode->thunk.thunk_p || cnode->alias)\n+\t  && cnode->thunk.alias)\n+        cnode->thunk.alias = lto_symtab_prevailing_decl (cnode->thunk.alias);\n+      cnode->symbol.aux = NULL;\n+    }\n   FOR_EACH_VARIABLE (vnode)\n-    if (vnode->alias_of)\n-      vnode->alias_of = lto_symtab_prevailing_decl (vnode->alias_of);\n+    {\n+      if (vnode->alias_of)\n+        vnode->alias_of = lto_symtab_prevailing_decl (vnode->alias_of);\n+      vnode->symbol.aux = NULL;\n+    }\n }\n \n /* Given the decl DECL, return the prevailing decl with the same name. */\n \n tree\n lto_symtab_prevailing_decl (tree decl)\n {\n-  lto_symtab_entry_t ret;\n+  symtab_node ret;\n \n   /* Builtins and local symbols are their own prevailing decl.  */\n   if (!TREE_PUBLIC (decl) || is_builtin_fn (decl))\n@@ -795,12 +692,9 @@ lto_symtab_prevailing_decl (tree decl)\n   gcc_assert (DECL_ASSEMBLER_NAME_SET_P (decl));\n \n   /* Walk through the list of candidates and return the one we merged to.  */\n-  ret = lto_symtab_get ((*targetm.asm_out.mangle_assembler_name)\n-\t\t\t(IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl))));\n+  ret = symtab_node_for_asm (DECL_ASSEMBLER_NAME (decl));\n   if (!ret)\n-    return NULL_TREE;\n+    return decl;\n \n-  return ret->decl;\n+  return ret->symbol.decl;\n }\n-\n-#include \"gt-lto-symtab.h\""}, {"sha": "c6abe4b221f4042aa2d939bcbdb8694c142bdc2a", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5493fb2fa5972e79056247600874f4480c6f8ad/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5493fb2fa5972e79056247600874f4480c6f8ad/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=b5493fb2fa5972e79056247600874f4480c6f8ad", "patch": "@@ -1,3 +1,8 @@\n+2012-09-19  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto.c (lto_materialize_function): Update confused comment.\n+\t(read_cgraph_and_symbols): Do not free symtab.\n+\n 2012-09-12  Jan Hubicka  <jh@suse.cz>\n \n \t* lto.c (do_whole_program_analysis): Care timevars, statistics and"}, {"sha": "930e990b78048c2412f82a08e34e1a20b1a9adec", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5493fb2fa5972e79056247600874f4480c6f8ad/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5493fb2fa5972e79056247600874f4480c6f8ad/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=b5493fb2fa5972e79056247600874f4480c6f8ad", "patch": "@@ -198,7 +198,7 @@ lto_materialize_function (struct cgraph_node *node)\n      and also functions that are needed to produce virtual clones.  */\n   if (cgraph_function_with_gimple_body_p (node) || has_analyzed_clone_p (node))\n     {\n-      /* Clones and thunks don't need to be read.  */\n+      /* Clones don't need to be read.  */\n       if (node->clone_of)\n \treturn;\n \n@@ -3006,7 +3006,6 @@ read_cgraph_and_symbols (unsigned nfiles, const char **fnames)\n       VEC_safe_push (ipa_opt_pass, heap,\n \t\t     node->ipa_transforms_to_apply,\n \t\t     (ipa_opt_pass)&pass_ipa_inline);\n-  lto_symtab_free ();\n \n   timevar_pop (TV_IPA_LTO_CGRAPH_MERGE);\n \n@@ -3035,7 +3034,6 @@ materialize_cgraph (void)\n     fprintf (stderr,\n \t     flag_wpa ? \"Materializing decls:\" : \"Reading function bodies:\");\n \n-\n   /* Now that we have input the cgraph, we need to clear all of the aux\n      nodes and read the functions if we are not running in WPA mode.  */\n   timevar_push (TV_IPA_LTO_GIMPLE_IN);"}, {"sha": "c21edcbb79dc8cae717a73e4cdad333fd04882cd", "filename": "gcc/symtab.c", "status": "modified", "additions": 34, "deletions": 7, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5493fb2fa5972e79056247600874f4480c6f8ad/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5493fb2fa5972e79056247600874f4480c6f8ad/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=b5493fb2fa5972e79056247600874f4480c6f8ad", "patch": "@@ -104,6 +104,8 @@ eq_assembler_name (const void *p1, const void *p2)\n static void\n insert_to_assembler_name_hash (symtab_node node)\n {\n+  if (symtab_variable_p (node) && DECL_HARD_REGISTER (node->symbol.decl))\n+    return;\n   gcc_checking_assert (!node->symbol.previous_sharing_asm_name\n \t\t       && !node->symbol.next_sharing_asm_name);\n   if (assembler_name_hash)\n@@ -151,9 +153,20 @@ unlink_from_assembler_name_hash (symtab_node node)\n \t  else\n \t    *slot = node->symbol.next_sharing_asm_name;\n \t}\n+      node->symbol.next_sharing_asm_name = NULL;\n+      node->symbol.previous_sharing_asm_name = NULL;\n     }\n }\n \n+/* Arrange node to be first in its entry of assembler_name_hash.  */\n+\n+void\n+symtab_prevail_in_asm_name_hash (symtab_node node)\n+{\n+  unlink_from_assembler_name_hash (node);\n+  insert_to_assembler_name_hash (node);\n+}\n+\n \n /* Add node into symbol table.  This function is not used directly, but via\n    cgraph/varpool node creation routines.  */\n@@ -287,15 +300,12 @@ symtab_remove_node (symtab_node node)\n     varpool_remove_node (varpool (node));\n }\n \n-/* Return the cgraph node that has ASMNAME for its DECL_ASSEMBLER_NAME.\n-   Return NULL if there's no such node.  */\n+/* Initalize asm name hash unless.  */\n \n-symtab_node\n-symtab_node_for_asm (const_tree asmname)\n+void\n+symtab_initialize_asm_name_hash (void)\n {\n   symtab_node node;\n-  void **slot;\n-\n   if (!assembler_name_hash)\n     {\n       assembler_name_hash =\n@@ -304,7 +314,18 @@ symtab_node_for_asm (const_tree asmname)\n       FOR_EACH_SYMBOL (node)\n \tinsert_to_assembler_name_hash (node);\n     }\n+}\n \n+/* Return the cgraph node that has ASMNAME for its DECL_ASSEMBLER_NAME.\n+   Return NULL if there's no such node.  */\n+\n+symtab_node\n+symtab_node_for_asm (const_tree asmname)\n+{\n+  symtab_node node;\n+  void **slot;\n+\n+  symtab_initialize_asm_name_hash ();\n   slot = htab_find_slot_with_hash (assembler_name_hash, asmname,\n \t\t\t\t   decl_assembler_name_hash (asmname),\n \t\t\t\t   NO_INSERT);\n@@ -507,6 +528,9 @@ dump_symtab_base (FILE *f, symtab_node node)\n   ipa_dump_references (f, &node->symbol.ref_list);\n   fprintf (f, \"  Referring: \");\n   ipa_dump_referring (f, &node->symbol.ref_list);\n+  if (node->symbol.lto_file_data)\n+    fprintf (f, \"  Read from file: %s\\n\",\n+\t     node->symbol.lto_file_data->file_name);\n }\n \n /* Dump symtab node.  */\n@@ -597,7 +621,8 @@ verify_symtab_base (symtab_node node)\n \t    break;\n \t  hashed_node = hashed_node->symbol.next_sharing_asm_name;\n \t}\n-      if (!hashed_node)\n+      if (!hashed_node\n+          && !(symtab_variable_p (node) || DECL_HARD_REGISTER (node->symbol.decl)))\n \t{\n           error (\"node not found in symtab assembler name hash\");\n           error_found = true;\n@@ -733,6 +758,8 @@ symtab_make_decl_local (tree decl)\n   DECL_COMDAT_GROUP (decl) = 0;\n   DECL_WEAK (decl) = 0;\n   DECL_EXTERNAL (decl) = 0;\n+  DECL_VISIBILITY_SPECIFIED (decl) = 0;\n+  DECL_VISIBILITY (decl) = VISIBILITY_DEFAULT;\n   TREE_PUBLIC (decl) = 0;\n   DECL_VISIBILITY_SPECIFIED (decl) = 0;\n   DECL_VISIBILITY (decl) = VISIBILITY_DEFAULT;"}, {"sha": "314c66ee308f31f1fd2fa4ba208e1303cb7cb338", "filename": "gcc/varpool.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5493fb2fa5972e79056247600874f4480c6f8ad/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5493fb2fa5972e79056247600874f4480c6f8ad/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=b5493fb2fa5972e79056247600874f4480c6f8ad", "patch": "@@ -301,6 +301,10 @@ varpool_assemble_decl (struct varpool_node *node)\n       && !targetm.have_tls)\n     return false;\n \n+  /* Hard register vars do not need to be output.  */\n+  if (DECL_HARD_REGISTER (decl))\n+    return false;\n+\n   gcc_checking_assert (!TREE_ASM_WRITTEN (decl)\n \t\t       && TREE_CODE (decl) == VAR_DECL\n \t\t       && !DECL_HAS_VALUE_EXPR_P (decl));"}]}