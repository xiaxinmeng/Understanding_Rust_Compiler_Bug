{"sha": "f0dbdfbb4d55628785aed06c8e9d1ab81b26e458", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjBkYmRmYmI0ZDU1NjI4Nzg1YWVkMDZjOGU5ZDFhYjgxYjI2ZTQ1OA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2006-12-01T22:46:45Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2006-12-01T22:46:45Z"}, "message": "fold-const.c (fold_binary): Use the precision of the type instead of the size of its mode to compute the...\n\n\t* fold-const.c (fold_binary) <LT_EXPR>: Use the precision of the\n\ttype instead of the size of its mode to compute the highest and\n\tlowest possible values.  Still check the size of the mode before\n\tflipping the signedness of the comparison.\n\nFrom-SVN: r119422", "tree": {"sha": "eed9131e8b7c9700cd4de51e2d384449f3da69b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eed9131e8b7c9700cd4de51e2d384449f3da69b4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f0dbdfbb4d55628785aed06c8e9d1ab81b26e458", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0dbdfbb4d55628785aed06c8e9d1ab81b26e458", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0dbdfbb4d55628785aed06c8e9d1ab81b26e458", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0dbdfbb4d55628785aed06c8e9d1ab81b26e458/comments", "author": null, "committer": null, "parents": [{"sha": "09aad82b44b0e51d3561f4e7b411f21b881f46c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09aad82b44b0e51d3561f4e7b411f21b881f46c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09aad82b44b0e51d3561f4e7b411f21b881f46c3"}], "stats": {"total": 40, "additions": 26, "deletions": 14}, "files": [{"sha": "f322b66e2e1edf07a8342ba71becf1ca1c548045", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0dbdfbb4d55628785aed06c8e9d1ab81b26e458/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0dbdfbb4d55628785aed06c8e9d1ab81b26e458/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f0dbdfbb4d55628785aed06c8e9d1ab81b26e458", "patch": "@@ -1,3 +1,10 @@\n+2006-12-01  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* fold-const.c (fold_binary) <LT_EXPR>: Use the precision of the\n+\ttype instead of the size of its mode to compute the highest and\n+\tlowest possible values.  Still check the size of the mode before\n+\tflipping the signedness of the comparison.\n+\n 2006-12-01  Trevor Smigiel  <trevor_smigiel@playstation.sony.com>\n \n \t* config/spu/predicates.md (spu_mov_operand): Add."}, {"sha": "fce41c2bdb1287aa0b1a2ab234064bcf4afa8e71", "filename": "gcc/fold-const.c", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0dbdfbb4d55628785aed06c8e9d1ab81b26e458/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0dbdfbb4d55628785aed06c8e9d1ab81b26e458/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=f0dbdfbb4d55628785aed06c8e9d1ab81b26e458", "patch": "@@ -7758,24 +7758,24 @@ fold_minmax (enum tree_code code, tree type, tree op0, tree op1)\n   else\n     gcc_unreachable ();\n \n-  /* MIN (MAX (a, b), b) == b. \ufffd*/\n+  /* MIN (MAX (a, b), b) == b.  */\n   if (TREE_CODE (op0) == compl_code\n       && operand_equal_p (TREE_OPERAND (op0, 1), op1, 0))\n     return omit_one_operand (type, op1, TREE_OPERAND (op0, 0));\n \n-  /* MIN (MAX (b, a), b) == b. \ufffd*/\n+  /* MIN (MAX (b, a), b) == b.  */\n   if (TREE_CODE (op0) == compl_code\n       && operand_equal_p (TREE_OPERAND (op0, 0), op1, 0)\n       && reorder_operands_p (TREE_OPERAND (op0, 1), op1))\n     return omit_one_operand (type, op1, TREE_OPERAND (op0, 1));\n \n-  /* MIN (a, MAX (a, b)) == a. \ufffd*/\n+  /* MIN (a, MAX (a, b)) == a.  */\n   if (TREE_CODE (op1) == compl_code\n       && operand_equal_p (op0, TREE_OPERAND (op1, 0), 0)\n       && reorder_operands_p (op0, TREE_OPERAND (op1, 1)))\n     return omit_one_operand (type, op0, TREE_OPERAND (op1, 1));\n \n-  /* MIN (a, MAX (b, a)) == a. \ufffd*/\n+  /* MIN (a, MAX (b, a)) == a.  */\n   if (TREE_CODE (op1) == compl_code\n       && operand_equal_p (op0, TREE_OPERAND (op1, 1), 0)\n       && reorder_operands_p (op0, TREE_OPERAND (op1, 0)))\n@@ -10994,15 +10994,15 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t}\n \n       /* Comparisons with the highest or lowest possible integer of\n-\t the specified size will have known values.  */\n+\t the specified precision will have known values.  */\n       {\n-\tint width = GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (arg1)));\n+\ttree arg1_type = TREE_TYPE (arg1);\n+\tunsigned int width = TYPE_PRECISION (arg1_type);\n \n \tif (TREE_CODE (arg1) == INTEGER_CST\n \t    && ! TREE_CONSTANT_OVERFLOW (arg1)\n \t    && width <= 2 * HOST_BITS_PER_WIDE_INT\n-\t    && (INTEGRAL_TYPE_P (TREE_TYPE (arg1))\n-\t\t|| POINTER_TYPE_P (TREE_TYPE (arg1))))\n+\t    && (INTEGRAL_TYPE_P (arg1_type) || POINTER_TYPE_P (arg1_type)))\n \t  {\n \t    HOST_WIDE_INT signed_max_hi;\n \t    unsigned HOST_WIDE_INT signed_max_lo;\n@@ -11015,7 +11015,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t\tsigned_max_hi = 0;\n \t\tmax_hi = 0;\n \n-\t\tif (TYPE_UNSIGNED (TREE_TYPE (arg1)))\n+\t\tif (TYPE_UNSIGNED (arg1_type))\n \t\t  {\n \t\t    max_lo = ((unsigned HOST_WIDE_INT) 2 << (width - 1)) - 1;\n \t\t    min_lo = 0;\n@@ -11037,7 +11037,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t\tmax_lo = -1;\n \t\tmin_lo = 0;\n \n-\t\tif (TYPE_UNSIGNED (TREE_TYPE (arg1)))\n+\t\tif (TYPE_UNSIGNED (arg1_type))\n \t\t  {\n \t\t    max_hi = ((unsigned HOST_WIDE_INT) 2 << (width - 1)) - 1;\n \t\t    min_hi = 0;\n@@ -11124,9 +11124,14 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \n \t    else if (TREE_INT_CST_HIGH (arg1) == signed_max_hi\n \t\t     && TREE_INT_CST_LOW (arg1) == signed_max_lo\n-\t\t     && TYPE_UNSIGNED (TREE_TYPE (arg1))\n+\t\t     && TYPE_UNSIGNED (arg1_type)\n+\t\t     /* We will flip the signedness of the comparison operator\n+\t\t\tassociated with the mode of arg1, so the sign bit is\n+\t\t\tspecified by this mode.  Check that arg1 is the signed\n+\t\t\tmax associated with this sign bit.  */\n+\t\t     && width == GET_MODE_BITSIZE (TYPE_MODE (arg1_type))\n \t\t     /* signed_type does not work on pointer types.  */\n-\t\t     && INTEGRAL_TYPE_P (TREE_TYPE (arg1)))\n+\t\t     && INTEGRAL_TYPE_P (arg1_type))\n \t      {\n \t\t/* The following case also applies to X < signed_max+1\n \t\t   and X >= signed_max+1 because previous transformations.  */\n@@ -11136,8 +11141,8 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t\t    st0 = lang_hooks.types.signed_type (TREE_TYPE (arg0));\n \t\t    st1 = lang_hooks.types.signed_type (TREE_TYPE (arg1));\n \t\t    return fold_build2 (code == LE_EXPR ? GE_EXPR: LT_EXPR,\n-\t\t\t       \t\ttype, fold_convert (st0, arg0),\n-\t\t\t       \t\tbuild_int_cst (st1, 0));\n+\t\t\t\t\ttype, fold_convert (st0, arg0),\n+\t\t\t\t\tbuild_int_cst (st1, 0));\n \t\t  }\n \t      }\n \t  }"}]}