{"sha": "2ba7e31e7e1c77b639c88aff631900ab7db5958b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmJhN2UzMWU3ZTFjNzdiNjM5Yzg4YWZmNjMxOTAwYWI3ZGI1OTU4Yg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-04T13:41:55Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-04T13:41:55Z"}, "message": "[multiple changes]\n\n2011-08-04  Yannick Moy  <moy@adacore.com>\n\n\t* sem_prag.adb, sem.ads: Code cleanup.\n\n2011-08-04  Tristan Gingold  <gingold@adacore.com>\n\n\t* s-tassta.adb (Task_Wrapper): Rewrite the dynamic stack usage part.\n\t* s-stausa.adb, s-stausa.ads: Major rewrite. Now provides accurate\n\tresults if possible.\n\t* s-stusta.adb (Print): Adjust after changes in s-stausa.\n\t* gnat_ugn.texi: Update dynamic stack usage section.\n\n2011-08-04  Steve Baird  <baird@adacore.com>\n\n\t* bindgen.adb (Gen_CodePeer_Wrapper): new procedure.\n\tGenerate (if CodePeer_Mode is set) a \"wrapper\" subprogram which\n\tcontains only a call to the user-defined main subprogram.\n\t(Gen_Main_Ada) - If CodePeer_Mode is set, then\n\tcall the \"wrapper\" subprogram instead of directly\n\tcalling the user-defined main subprogram.\n\n2011-08-04  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch5.adb (Expand_N_Case_Statement): Check the statements of all\n\talternatives of a case statement for controlled objects. Rename local\n\tvariable A to Dead_Alt.\n\t(Expand_N_If_Statement): Check the then and else statements of an if\n\tstatement for controlled objects. Check the then statements of all\n\telsif parts of an if statement for controlled objects.\n\t(Expand_N_Loop_Statement): Check the statements of a loop for controlled\n\tobjects.\n\t* exp_ch7.adb (Process_Transient_Objects): Rewrite the condition which\n\tdetects a loop associated with the expansion of an array object.\n\tAugment the processing of the loop statements to account for a possible\n\twrap done by Process_Statements_For_Controlled_Objects.\n\t* exp_ch9.adb (Expand_N_Asynchronous_Select): Check the triggering\n\tstatements and abortable part of an asynchronous select for controlled\n\tobjects.\n\t(Expand_N_Conditional_Entry_Call): Check the else statements of a\n\tconditional entry call for controlled objects.\n\t(Expand_N_Selective_Accept): Check the alternatives of a selective\n\taccept for controlled objects.\n\t(Expand_N_Timed_Entry_Call): Check the entry call and delay\n\talternatives of a timed entry call for controlled objects.\n\t* exp_ch11.adb (Expand_Exception_Handlers): Check the statements of an\n\texception handler for controlled objects.\n\t* exp_util.adb (Requires_Cleanup_Actions (List_Id, Boolean, Boolean)):\n\tAdd formal parameter Nested_Constructs along with its associated\n\tcomment.\n\t(Requires_Cleanup_Actions (Node_Id)): Update all calls to\n\tRequires_Cleanup_Actions.\n\t(Process_Statements_For_Controlled_Objects): New routine.\n\t* exp_util.ads (Process_Statements_For_Controlled_Objects): New\n\troutine. Inspect a node which contains a non-handled sequence of\n\tstatements for controlled objects. If such an object is found, the\n\tstatements are wrapped in a block.\n\nFrom-SVN: r177386", "tree": {"sha": "fd677c39de60bb95b906b1170abe8bdfde73da29", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fd677c39de60bb95b906b1170abe8bdfde73da29"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2ba7e31e7e1c77b639c88aff631900ab7db5958b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ba7e31e7e1c77b639c88aff631900ab7db5958b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ba7e31e7e1c77b639c88aff631900ab7db5958b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ba7e31e7e1c77b639c88aff631900ab7db5958b/comments", "author": null, "committer": null, "parents": [{"sha": "1bf773bb9fb7ab8169e9c185a903f3c618b6bf75", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1bf773bb9fb7ab8169e9c185a903f3c618b6bf75", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1bf773bb9fb7ab8169e9c185a903f3c618b6bf75"}], "stats": {"total": 907, "additions": 523, "deletions": 384}, "files": [{"sha": "ec696b94f1be86467a400c76716cd9cccdccd500", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ba7e31e7e1c77b639c88aff631900ab7db5958b/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ba7e31e7e1c77b639c88aff631900ab7db5958b/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=2ba7e31e7e1c77b639c88aff631900ab7db5958b", "patch": "@@ -1,3 +1,60 @@\n+2011-08-04  Yannick Moy  <moy@adacore.com>\n+\n+\t* sem_prag.adb, sem.ads: Code cleanup.\n+\n+2011-08-04  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* s-tassta.adb (Task_Wrapper): Rewrite the dynamic stack usage part.\n+\t* s-stausa.adb, s-stausa.ads: Major rewrite. Now provides accurate\n+\tresults if possible.\n+\t* s-stusta.adb (Print): Adjust after changes in s-stausa.\n+\t* gnat_ugn.texi: Update dynamic stack usage section.\n+\n+2011-08-04  Steve Baird  <baird@adacore.com>\n+\n+\t* bindgen.adb (Gen_CodePeer_Wrapper): new procedure.\n+\tGenerate (if CodePeer_Mode is set) a \"wrapper\" subprogram which\n+\tcontains only a call to the user-defined main subprogram.\n+\t(Gen_Main_Ada) - If CodePeer_Mode is set, then\n+\tcall the \"wrapper\" subprogram instead of directly\n+\tcalling the user-defined main subprogram.\n+\n+2011-08-04  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch5.adb (Expand_N_Case_Statement): Check the statements of all\n+\talternatives of a case statement for controlled objects. Rename local\n+\tvariable A to Dead_Alt.\n+\t(Expand_N_If_Statement): Check the then and else statements of an if\n+\tstatement for controlled objects. Check the then statements of all\n+\telsif parts of an if statement for controlled objects.\n+\t(Expand_N_Loop_Statement): Check the statements of a loop for controlled\n+\tobjects.\n+\t* exp_ch7.adb (Process_Transient_Objects): Rewrite the condition which\n+\tdetects a loop associated with the expansion of an array object.\n+\tAugment the processing of the loop statements to account for a possible\n+\twrap done by Process_Statements_For_Controlled_Objects.\n+\t* exp_ch9.adb (Expand_N_Asynchronous_Select): Check the triggering\n+\tstatements and abortable part of an asynchronous select for controlled\n+\tobjects.\n+\t(Expand_N_Conditional_Entry_Call): Check the else statements of a\n+\tconditional entry call for controlled objects.\n+\t(Expand_N_Selective_Accept): Check the alternatives of a selective\n+\taccept for controlled objects.\n+\t(Expand_N_Timed_Entry_Call): Check the entry call and delay\n+\talternatives of a timed entry call for controlled objects.\n+\t* exp_ch11.adb (Expand_Exception_Handlers): Check the statements of an\n+\texception handler for controlled objects.\n+\t* exp_util.adb (Requires_Cleanup_Actions (List_Id, Boolean, Boolean)):\n+\tAdd formal parameter Nested_Constructs along with its associated\n+\tcomment.\n+\t(Requires_Cleanup_Actions (Node_Id)): Update all calls to\n+\tRequires_Cleanup_Actions.\n+\t(Process_Statements_For_Controlled_Objects): New routine.\n+\t* exp_util.ads (Process_Statements_For_Controlled_Objects): New\n+\troutine. Inspect a node which contains a non-handled sequence of\n+\tstatements for controlled objects. If such an object is found, the\n+\tstatements are wrapped in a block.\n+\n 2011-08-04  Bob Duff  <duff@adacore.com>\n \n \t* sem_type.adb (Covers): If T2 is a subtype of a class-wide type, we"}, {"sha": "f2714cdd895883357206bcf80fc3dfb993e9933c", "filename": "gcc/ada/bindgen.adb", "status": "modified", "additions": 50, "deletions": 17, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ba7e31e7e1c77b639c88aff631900ab7db5958b/gcc%2Fada%2Fbindgen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ba7e31e7e1c77b639c88aff631900ab7db5958b/gcc%2Fada%2Fbindgen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindgen.adb?ref=2ba7e31e7e1c77b639c88aff631900ab7db5958b", "patch": "@@ -1,4 +1,4 @@\n-------------------------------------------------------------------------------\n+-----------------------------------------------------------------------------\n --                                                                          --\n --                         GNAT COMPILER COMPONENTS                         --\n --                                                                          --\n@@ -74,6 +74,10 @@ package body Bindgen is\n    Lib_Final_Built : Boolean := False;\n    --  Flag indicating whether the finalize_library rountine has been built\n \n+   CodePeer_Wrapper_Name : constant String := \"call_main_subprogram\";\n+   --  For CodePeer, introduce a wrapper subprogram which calls the\n+   --  user-defined main subprogram.\n+\n    ----------------------------------\n    -- Interface_State Pragma Table --\n    ----------------------------------\n@@ -275,6 +279,9 @@ package body Bindgen is\n    procedure Gen_Finalize_Library_Defs_C;\n    --  Generate a sequence of defininitions for package finalizers (C case)\n \n+   procedure Gen_CodePeer_Wrapper;\n+   --  For CodePeer, generate wrapper which calls user-defined main subprogram\n+\n    procedure Gen_Main_Ada;\n    --  Generate procedure main (Ada code case)\n \n@@ -2126,6 +2133,36 @@ package body Bindgen is\n       WBI (\"\");\n    end Gen_Finalize_Library_Defs_C;\n \n+   --------------------------\n+   -- Gen_CodePeer_Wrapper --\n+   --------------------------\n+\n+   procedure Gen_CodePeer_Wrapper is\n+   begin\n+      Get_Name_String (Units.Table (First_Unit_Entry).Uname);\n+\n+      declare\n+         --  Bypass Ada_Main_Program; its Import pragma confuses CodePeer\n+\n+         Callee_Name : String renames Name_Buffer (1 .. Name_Len - 2);\n+         --  Strip trailing \"%b\"\n+      begin\n+         if ALIs.Table (ALIs.First).Main_Program = Proc then\n+            WBI (\"   procedure \" & CodePeer_Wrapper_Name & \" is \");\n+            WBI (\"   begin\");\n+            WBI (\"      \" & Callee_Name & \";\");\n+         else\n+            WBI\n+              (\"   function \" & CodePeer_Wrapper_Name & \" return Integer is\");\n+            WBI (\"   begin\");\n+            WBI (\"      return \" & Callee_Name & \";\");\n+         end if;\n+      end;\n+\n+      WBI (\"   end \" & CodePeer_Wrapper_Name & \";\");\n+      WBI (\"\");\n+   end Gen_CodePeer_Wrapper;\n+\n    ------------------\n    -- Gen_Main_Ada --\n    ------------------\n@@ -2318,22 +2355,11 @@ package body Bindgen is\n       if not No_Main_Subprogram then\n \n          if CodePeer_Mode then\n-\n-            --  Bypass Ada_Main_Program, its Import pragma confuses CodePeer\n-\n-            Get_Name_String (Units.Table (First_Unit_Entry).Uname);\n-\n-            declare\n-               Callee_Name : String renames Name_Buffer (1 .. Name_Len - 2);\n-               --  Strip trailing \"%b\"\n-\n-            begin\n-               if ALIs.Table (ALIs.First).Main_Program = Proc then\n-                  WBI (\"      \" & Callee_Name & \";\");\n-               else\n-                  WBI (\"      Result := \" & Callee_Name & \";\");\n-               end if;\n-            end;\n+            if ALIs.Table (ALIs.First).Main_Program = Proc then\n+               WBI (\"      \" & CodePeer_Wrapper_Name & \";\");\n+            else\n+               WBI (\"      Result := \" & CodePeer_Wrapper_Name & \";\");\n+            end if;\n \n          elsif ALIs.Table (ALIs.First).Main_Program = Proc then\n             WBI (\"      Ada_Main_Program;\");\n@@ -3232,6 +3258,13 @@ package body Bindgen is\n       Gen_Adainit_Ada;\n \n       if Bind_Main_Program and then VM_Target = No_VM then\n+         --  For CodePeer, declare a wrapper for the\n+         --  user-defined main program.\n+\n+         if CodePeer_Mode then\n+            Gen_CodePeer_Wrapper;\n+         end if;\n+\n          Gen_Main_Ada;\n       end if;\n "}, {"sha": "fc55d1567cbb8a84b34e4e7aae37bfd316e95577", "filename": "gcc/ada/exp_ch11.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ba7e31e7e1c77b639c88aff631900ab7db5958b/gcc%2Fada%2Fexp_ch11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ba7e31e7e1c77b639c88aff631900ab7db5958b/gcc%2Fada%2Fexp_ch11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch11.adb?ref=2ba7e31e7e1c77b639c88aff631900ab7db5958b", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -968,6 +968,8 @@ package body Exp_Ch11 is\n \n       Handler := First_Non_Pragma (Handlrs);\n       Handler_Loop : while Present (Handler) loop\n+         Process_Statements_For_Controlled_Objects (Handler);\n+\n          Next_Handler := Next_Non_Pragma (Handler);\n \n          --  Remove source handler if gnat debug flag .x is set"}, {"sha": "3c08b512d3b6bc0281f372657f0419dfa95eeb4e", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 32, "deletions": 12, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ba7e31e7e1c77b639c88aff631900ab7db5958b/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ba7e31e7e1c77b639c88aff631900ab7db5958b/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=2ba7e31e7e1c77b639c88aff631900ab7db5958b", "patch": "@@ -2279,6 +2279,8 @@ package body Exp_Ch5 is\n       if Compile_Time_Known_Value (Expr) then\n          Alt := Find_Static_Alternative (N);\n \n+         Process_Statements_For_Controlled_Objects (Alt);\n+\n          --  Move statements from this alternative after the case statement.\n          --  They are already analyzed, so will be skipped by the analyzer.\n \n@@ -2290,21 +2292,21 @@ package body Exp_Ch5 is\n          Kill_Dead_Code (Expression (N));\n \n          declare\n-            A : Node_Id;\n+            Dead_Alt : Node_Id;\n \n          begin\n             --  Loop through case alternatives, skipping pragmas, and skipping\n             --  the one alternative that we select (and therefore retain).\n \n-            A := First (Alternatives (N));\n-            while Present (A) loop\n-               if A /= Alt\n-                 and then Nkind (A) = N_Case_Statement_Alternative\n+            Dead_Alt := First (Alternatives (N));\n+            while Present (Dead_Alt) loop\n+               if Dead_Alt /= Alt\n+                 and then Nkind (Dead_Alt) = N_Case_Statement_Alternative\n                then\n-                  Kill_Dead_Code (Statements (A), Warn_On_Deleted_Code);\n+                  Kill_Dead_Code (Statements (Dead_Alt), Warn_On_Deleted_Code);\n                end if;\n \n-               Next (A);\n+               Next (Dead_Alt);\n             end loop;\n          end;\n \n@@ -2351,12 +2353,16 @@ package body Exp_Ch5 is\n          Len := List_Length (Alternatives (N));\n \n          if Len = 1 then\n-            --  We still need to evaluate the expression if it has any\n-            --  side effects.\n+\n+            --  We still need to evaluate the expression if it has any side\n+            --  effects.\n \n             Remove_Side_Effects (Expression (N));\n \n-            Insert_List_After (N, Statements (First (Alternatives (N))));\n+            Alt := First (Alternatives (N));\n+\n+            Process_Statements_For_Controlled_Objects (Alt);\n+            Insert_List_After (N, Statements (Alt));\n \n             --  That leaves the case statement as a shell. The alternative that\n             --  will be executed is reset to a null list. So now we can kill\n@@ -2365,7 +2371,6 @@ package body Exp_Ch5 is\n             Kill_Dead_Code (Expression (N));\n             Rewrite (N, Make_Null_Statement (Loc));\n             return;\n-         end if;\n \n          --  An optimization. If there are only two alternatives, and only\n          --  a single choice, then rewrite the whole case statement as an\n@@ -2374,7 +2379,7 @@ package body Exp_Ch5 is\n          --  simple form, but also with generated code (discriminant check\n          --  functions in particular)\n \n-         if Len = 2 then\n+         elsif Len = 2 then\n             Chlist := Discrete_Choices (First (Alternatives (N)));\n \n             if List_Length (Chlist) = 1 then\n@@ -2451,6 +2456,15 @@ package body Exp_Ch5 is\n               (Others_Node, Discrete_Choices (Last_Alt));\n             Set_Discrete_Choices (Last_Alt, New_List (Others_Node));\n          end if;\n+\n+         Alt := First (Alternatives (N));\n+         while Present (Alt)\n+           and then Nkind (Alt) = N_Case_Statement_Alternative\n+         loop\n+            Process_Statements_For_Controlled_Objects (Alt);\n+\n+            Next (Alt);\n+         end loop;\n       end;\n    end Expand_N_Case_Statement;\n \n@@ -2525,6 +2539,8 @@ package body Exp_Ch5 is\n       --  these warnings for expander generated code.\n \n    begin\n+      Process_Statements_For_Controlled_Objects (N);\n+\n       Adjust_Condition (Condition (N));\n \n       --  The following loop deals with constant conditions for the IF. We\n@@ -2610,6 +2626,8 @@ package body Exp_Ch5 is\n       if Present (Elsif_Parts (N)) then\n          E := First (Elsif_Parts (N));\n          while Present (E) loop\n+            Process_Statements_For_Controlled_Objects (E);\n+\n             Adjust_Condition (Condition (E));\n \n             --  If there are condition actions, then rewrite the if statement\n@@ -3065,6 +3083,8 @@ package body Exp_Ch5 is\n          return;\n       end if;\n \n+      Process_Statements_For_Controlled_Objects (N);\n+\n       --  Deal with condition for C/Fortran Boolean\n \n       if Present (Isc) then"}, {"sha": "452b9e5b2e4154a77332c3824cafca7fad661358", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 32, "deletions": 5, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ba7e31e7e1c77b639c88aff631900ab7db5958b/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ba7e31e7e1c77b639c88aff631900ab7db5958b/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=2ba7e31e7e1c77b639c88aff631900ab7db5958b", "patch": "@@ -4366,11 +4366,38 @@ package body Exp_Ch7 is\n             --  sometimes generate a loop and create transient objects inside\n             --  the loop.\n \n-            elsif Nkind (Stmt) = N_Loop_Statement then\n-               Process_Transient_Objects\n-                 (First_Object => First (Statements (Stmt)),\n-                  Last_Object  => Last (Statements (Stmt)),\n-                  Related_Node => Related_Node);\n+            elsif Nkind (Related_Node) = N_Object_Declaration\n+              and then Is_Array_Type (Base_Type\n+                         (Etype (Defining_Identifier (Related_Node))))\n+              and then Nkind (Stmt) = N_Loop_Statement\n+            then\n+               declare\n+                  Block_HSS : Node_Id := First (Statements (Stmt));\n+\n+               begin\n+                  --  The loop statements may have been wrapped in a block by\n+                  --  Process_Statements_For_Controlled_Objects, inspect the\n+                  --  handled sequence of statements.\n+\n+                  if Nkind (Block_HSS) = N_Block_Statement\n+                    and then No (Next (Block_HSS))\n+                  then\n+                     Block_HSS := Handled_Statement_Sequence (Block_HSS);\n+\n+                     Process_Transient_Objects\n+                       (First_Object => First (Statements (Block_HSS)),\n+                        Last_Object  => Last (Statements (Block_HSS)),\n+                        Related_Node => Related_Node);\n+\n+                  --  Inspect the statements of the loop\n+\n+                  else\n+                     Process_Transient_Objects\n+                       (First_Object => First (Statements (Stmt)),\n+                        Last_Object  => Last (Statements (Stmt)),\n+                        Related_Node => Related_Node);\n+                  end if;\n+               end;\n \n             --  Terminate the scan after the last object has been processed\n "}, {"sha": "a55a7f5169855acfb16143a60cbaf1f112a67178", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ba7e31e7e1c77b639c88aff631900ab7db5958b/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ba7e31e7e1c77b639c88aff631900ab7db5958b/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=2ba7e31e7e1c77b639c88aff631900ab7db5958b", "patch": "@@ -5872,6 +5872,9 @@ package body Exp_Ch9 is\n       T   : Entity_Id;  --  Additional status flag\n \n    begin\n+      Process_Statements_For_Controlled_Objects (Trig);\n+      Process_Statements_For_Controlled_Objects (Abrt);\n+\n       Blk_Ent := Make_Temporary (Loc, 'A');\n       Ecall   := Triggering_Statement (Trig);\n \n@@ -6824,6 +6827,8 @@ package body Exp_Ch9 is\n       S : Entity_Id;  --  Primitive operation slot\n \n    begin\n+      Process_Statements_For_Controlled_Objects (N);\n+\n       if Ada_Version >= Ada_2005\n         and then Nkind (Blk) = N_Procedure_Call_Statement\n       then\n@@ -9660,6 +9665,8 @@ package body Exp_Ch9 is\n    --  Start of processing for Expand_N_Selective_Accept\n \n    begin\n+      Process_Statements_For_Controlled_Objects (N);\n+\n       --  First insert some declarations before the select. The first is:\n \n       --    Ann : Address\n@@ -9679,6 +9686,7 @@ package body Exp_Ch9 is\n \n       Alt := First (Alts);\n       while Present (Alt) loop\n+         Process_Statements_For_Controlled_Objects (Alt);\n \n          if Nkind (Alt) = N_Accept_Alternative then\n             Add_Accept (Alt);\n@@ -11035,6 +11043,9 @@ package body Exp_Ch9 is\n          return;\n       end if;\n \n+      Process_Statements_For_Controlled_Objects (Entry_Call_Alternative (N));\n+      Process_Statements_For_Controlled_Objects (Delay_Alternative (N));\n+\n       --  The arguments in the call may require dynamic allocation, and the\n       --  call statement may have been transformed into a block. The block\n       --  may contain additional declarations for internal entities, and the"}, {"sha": "c8d41cb0e7c5dc4bce35e3d24a0bc9ccf9158c9a", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 123, "deletions": 13, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ba7e31e7e1c77b639c88aff631900ab7db5958b/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ba7e31e7e1c77b639c88aff631900ab7db5958b/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=2ba7e31e7e1c77b639c88aff631900ab7db5958b", "patch": "@@ -148,15 +148,17 @@ package body Exp_Util is\n    --  Create an implicit subtype of CW_Typ attached to node N\n \n    function Requires_Cleanup_Actions\n-     (L           : List_Id;\n-      For_Package : Boolean) return Boolean;\n+     (L                 : List_Id;\n+      For_Package       : Boolean;\n+      Nested_Constructs : Boolean) return Boolean;\n    --  Given a list L, determine whether it contains one of the following:\n    --\n    --    1) controlled objects\n    --    2) library-level tagged types\n    --\n    --  Flag For_Package should be set when the list comes from a package spec\n-   --  or body.\n+   --  or body. Flag Nested_Constructs should be set when any nested packages\n+   --  declared in L must be processed.\n \n    ----------------------\n    -- Adjust_Condition --\n@@ -5446,6 +5448,107 @@ package body Exp_Util is\n       end case;\n    end Possible_Bit_Aligned_Component;\n \n+   -----------------------------------------------\n+   -- Process_Statements_For_Controlled_Objects --\n+   -----------------------------------------------\n+\n+   procedure Process_Statements_For_Controlled_Objects (N : Node_Id) is\n+      Loc : constant Source_Ptr := Sloc (N);\n+\n+      function Are_Wrapped (L : List_Id) return Boolean;\n+      --  Determine whether list L contains only one statement which is a block\n+\n+      function Wrap_Statements_In_Block (L : List_Id) return Node_Id;\n+      --  Given a list of statements L, wrap it in a block statement and return\n+      --  the generated node.\n+\n+      -----------------\n+      -- Are_Wrapped --\n+      -----------------\n+\n+      function Are_Wrapped (L : List_Id) return Boolean is\n+         Stmt : constant Node_Id := First (L);\n+\n+      begin\n+         return\n+           Present (Stmt)\n+             and then No (Next (Stmt))\n+             and then Nkind (Stmt) = N_Block_Statement;\n+      end Are_Wrapped;\n+\n+      ------------------------------\n+      -- Wrap_Statements_In_Block --\n+      ------------------------------\n+\n+      function Wrap_Statements_In_Block (L : List_Id) return Node_Id is\n+      begin\n+         return\n+           Make_Block_Statement (Loc,\n+             Declarations => No_List,\n+             Handled_Statement_Sequence =>\n+               Make_Handled_Sequence_Of_Statements (Loc,\n+                 Statements => L));\n+      end Wrap_Statements_In_Block;\n+\n+   --  Start of processing for Process_Statements_For_Controlled_Objects\n+\n+   begin\n+      case Nkind (N) is\n+         when N_Elsif_Part                 |\n+              N_If_Statement               |\n+              N_Conditional_Entry_Call     |\n+              N_Selective_Accept           =>\n+\n+            --  Check the \"then statements\" for elsif parts and if statements\n+\n+            if Nkind_In (N, N_Elsif_Part,\n+                            N_If_Statement)\n+              and then not Is_Empty_List (Then_Statements (N))\n+              and then not Are_Wrapped (Then_Statements (N))\n+              and then Requires_Cleanup_Actions\n+                         (Then_Statements (N), False, False)\n+            then\n+               Set_Then_Statements (N, New_List (\n+                 Wrap_Statements_In_Block (Then_Statements (N))));\n+            end if;\n+\n+            --  Check the \"else statements\" for conditional entry calls, if\n+            --  statements and selective accepts.\n+\n+            if Nkind_In (N, N_Conditional_Entry_Call,\n+                            N_If_Statement,\n+                            N_Selective_Accept)\n+              and then not Is_Empty_List (Else_Statements (N))\n+              and then not Are_Wrapped (Else_Statements (N))\n+              and then Requires_Cleanup_Actions\n+                         (Else_Statements (N), False, False)\n+            then\n+               Set_Else_Statements (N, New_List (\n+                 Wrap_Statements_In_Block (Else_Statements (N))));\n+            end if;\n+\n+         when N_Abortable_Part             |\n+              N_Accept_Alternative         |\n+              N_Case_Statement_Alternative |\n+              N_Delay_Alternative          |\n+              N_Entry_Call_Alternative     |\n+              N_Exception_Handler          |\n+              N_Loop_Statement             |\n+              N_Triggering_Alternative     =>\n+\n+            if not Is_Empty_List (Statements (N))\n+              and then not Are_Wrapped (Statements (N))\n+              and then Requires_Cleanup_Actions (Statements (N), False, False)\n+            then\n+               Set_Statements (N, New_List (\n+                 Wrap_Statements_In_Block (Statements (N))));\n+            end if;\n+\n+         when others                       =>\n+            null;\n+      end case;\n+   end Process_Statements_For_Controlled_Objects;\n+\n    -------------------------\n    -- Remove_Side_Effects --\n    -------------------------\n@@ -6148,18 +6251,20 @@ package body Exp_Util is\n               N_Subprogram_Body       |\n               N_Task_Body             =>\n             return\n-              Requires_Cleanup_Actions (Declarations (N), For_Pkg)\n+              Requires_Cleanup_Actions (Declarations (N), For_Pkg, True)\n                 or else\n               (Present (Handled_Statement_Sequence (N))\n                 and then\n-              Requires_Cleanup_Actions\n-                (Statements (Handled_Statement_Sequence (N)), For_Pkg));\n+              Requires_Cleanup_Actions (Statements\n+                (Handled_Statement_Sequence (N)), For_Pkg, True));\n \n          when N_Package_Specification =>\n             return\n-              Requires_Cleanup_Actions (Visible_Declarations (N), For_Pkg)\n-                or else\n-              Requires_Cleanup_Actions (Private_Declarations (N), For_Pkg);\n+              Requires_Cleanup_Actions\n+                (Visible_Declarations (N), For_Pkg, True)\n+                  or else\n+              Requires_Cleanup_Actions\n+                (Private_Declarations (N), For_Pkg, True);\n \n          when others                  =>\n             return False;\n@@ -6171,8 +6276,9 @@ package body Exp_Util is\n    ------------------------------\n \n    function Requires_Cleanup_Actions\n-     (L           : List_Id;\n-      For_Package : Boolean) return Boolean\n+     (L                 : List_Id;\n+      For_Package       : Boolean;\n+      Nested_Constructs : Boolean) return Boolean\n    is\n       Decl    : Node_Id;\n       Expr    : Node_Id;\n@@ -6345,7 +6451,9 @@ package body Exp_Util is\n \n          --  Nested package declarations\n \n-         elsif Nkind (Decl) = N_Package_Declaration then\n+         elsif Nested_Constructs\n+           and then Nkind (Decl) = N_Package_Declaration\n+         then\n             Pack_Id := Defining_Unit_Name (Specification (Decl));\n \n             if Nkind (Pack_Id) = N_Defining_Program_Unit_Name then\n@@ -6360,7 +6468,9 @@ package body Exp_Util is\n \n          --  Nested package bodies\n \n-         elsif Nkind (Decl) = N_Package_Body then\n+         elsif Nested_Constructs\n+           and then Nkind (Decl) = N_Package_Body\n+         then\n             Pack_Id := Corresponding_Spec (Decl);\n \n             if Ekind (Pack_Id) /= E_Generic_Package"}, {"sha": "c7b5b8f8e6ccef62257983411b3d970bc4238df6", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ba7e31e7e1c77b639c88aff631900ab7db5958b/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ba7e31e7e1c77b639c88aff631900ab7db5958b/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=2ba7e31e7e1c77b639c88aff631900ab7db5958b", "patch": "@@ -706,6 +706,11 @@ package Exp_Util is\n    --  causes trouble for the back end (see Component_May_Be_Bit_Aligned for\n    --  further details).\n \n+   procedure Process_Statements_For_Controlled_Objects (N : Node_Id);\n+   --  N is a node which contains a non-handled statement list. Inspect the\n+   --  statements looking for declarations of controlled objects. If at least\n+   --  one such object is found, wrap the statement list in a block.\n+\n    procedure Remove_Side_Effects\n      (Exp          : Node_Id;\n       Name_Req     : Boolean := False;"}, {"sha": "ee2c381314e3da90760422accab4209b45076a0f", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ba7e31e7e1c77b639c88aff631900ab7db5958b/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ba7e31e7e1c77b639c88aff631900ab7db5958b/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=2ba7e31e7e1c77b639c88aff631900ab7db5958b", "patch": "@@ -17259,7 +17259,7 @@ output this info at program termination. Results are displayed in four\n columns:\n \n @noindent\n-Index | Task Name | Stack Size | Stack Usage [Value +/- Variation]\n+Index | Task Name | Stack Size | Stack Usage\n \n @noindent\n where:\n@@ -17277,8 +17277,7 @@ is the maximum size for the stack.\n @item Stack Usage\n is the measure done by the stack analyzer. In order to prevent overflow, the stack\n is not entirely analyzed, and it's not possible to know exactly how\n-much has actually been used. The report thus contains the theoretical stack usage\n-(Value) and the possible variation (Variation) around this value.\n+much has actually been used.\n \n @end table\n "}, {"sha": "76cac90454f423d7bc40f54899cd519dd98592fe", "filename": "gcc/ada/s-stausa.adb", "status": "modified", "additions": 112, "deletions": 235, "changes": 347, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ba7e31e7e1c77b639c88aff631900ab7db5958b/gcc%2Fada%2Fs-stausa.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ba7e31e7e1c77b639c88aff631900ab7db5958b/gcc%2Fada%2Fs-stausa.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-stausa.adb?ref=2ba7e31e7e1c77b639c88aff631900ab7db5958b", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---         Copyright (C) 2004-2010, Free Software Foundation, Inc.          --\n+--         Copyright (C) 2004-2011, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -93,76 +93,6 @@ package body System.Stack_Usage is\n    --  | entry frame | ... | leaf frame |                            |####|\n    --  +------------------------------------------------------------------+\n \n-   function Top_Slot_Index_In (Stack : Stack_Slots) return Integer;\n-   --  Index of the stack Top slot in the Slots array, denoting the latest\n-   --  possible slot available to call chain leaves.\n-\n-   function Bottom_Slot_Index_In (Stack : Stack_Slots) return Integer;\n-   --  Index of the stack Bottom slot in the Slots array, denoting the first\n-   --  possible slot available to call chain entry points.\n-\n-   function Push_Index_Step_For (Stack : Stack_Slots) return Integer;\n-   --  By how much do we need to update a Slots index to Push a single slot on\n-   --  the stack.\n-\n-   function Pop_Index_Step_For (Stack : Stack_Slots) return Integer;\n-   --  By how much do we need to update a Slots index to Pop a single slot off\n-   --  the stack.\n-\n-   pragma Inline_Always (Top_Slot_Index_In);\n-   pragma Inline_Always (Bottom_Slot_Index_In);\n-   pragma Inline_Always (Push_Index_Step_For);\n-   pragma Inline_Always (Pop_Index_Step_For);\n-\n-   -----------------------\n-   -- Top_Slot_Index_In --\n-   -----------------------\n-\n-   function Top_Slot_Index_In (Stack : Stack_Slots) return Integer is\n-   begin\n-      if System.Parameters.Stack_Grows_Down then\n-         return Stack'First;\n-      else\n-         return Stack'Last;\n-      end if;\n-   end Top_Slot_Index_In;\n-\n-   ----------------------------\n-   --  Bottom_Slot_Index_In  --\n-   ----------------------------\n-\n-   function Bottom_Slot_Index_In (Stack : Stack_Slots) return Integer is\n-   begin\n-      if System.Parameters.Stack_Grows_Down then\n-         return Stack'Last;\n-      else\n-         return Stack'First;\n-      end if;\n-   end Bottom_Slot_Index_In;\n-\n-   -------------------------\n-   -- Push_Index_Step_For --\n-   -------------------------\n-\n-   function Push_Index_Step_For (Stack : Stack_Slots) return Integer is\n-      pragma Unreferenced (Stack);\n-   begin\n-      if System.Parameters.Stack_Grows_Down then\n-         return -1;\n-      else\n-         return +1;\n-      end if;\n-   end Push_Index_Step_For;\n-\n-   ------------------------\n-   -- Pop_Index_Step_For --\n-   ------------------------\n-\n-   function Pop_Index_Step_For (Stack : Stack_Slots) return Integer is\n-   begin\n-      return -Push_Index_Step_For (Stack);\n-   end Pop_Index_Step_For;\n-\n    -------------------\n    -- Unit Services --\n    -------------------\n@@ -175,9 +105,6 @@ package body System.Stack_Usage is\n    Stack_Size_Str  : constant String  := \"Stack Size\";\n    Actual_Size_Str : constant String  := \"Stack usage\";\n \n-   function Get_Usage_Range (Result : Task_Result) return String;\n-   --  Return string representing the range of possible result of stack usage\n-\n    procedure Output_Result\n      (Result_Id          : Natural;\n       Result             : Task_Result;\n@@ -194,7 +121,6 @@ package body System.Stack_Usage is\n    ----------------\n \n    procedure Initialize (Buffer_Size : Natural) is\n-      Bottom_Of_Stack  : aliased Integer;\n       Stack_Size_Chars : System.Address;\n \n    begin\n@@ -204,9 +130,8 @@ package body System.Stack_Usage is\n       Result_Array.all :=\n         (others =>\n            (Task_Name => (others => ASCII.NUL),\n-            Variation => 0,\n             Value     => 0,\n-            Max_Size  => 0));\n+            Stack_Size  => 0));\n \n       --  Set the Is_Enabled flag to true, so that the task wrapper knows that\n       --  it has to handle dynamic stack analysis\n@@ -231,9 +156,8 @@ package body System.Stack_Usage is\n               (Environment_Task_Analyzer,\n                \"ENVIRONMENT TASK\",\n                My_Stack_Size,\n-               My_Stack_Size,\n-               System.Storage_Elements.To_Integer (Bottom_Of_Stack'Address),\n-               0);\n+               0,\n+               My_Stack_Size);\n \n             Fill_Stack (Environment_Task_Analyzer);\n \n@@ -257,99 +181,78 @@ package body System.Stack_Usage is\n       --  big, the more an \"instrumentation threshold at writing\" error is\n       --  likely to happen.\n \n-      Stack_Used_When_Filling : Integer;\n-      Current_Stack_Level     : aliased Integer;\n+      Current_Stack_Level : aliased Integer;\n \n-      Guard : constant Integer := 256;\n+      Guard : constant := 256;\n       --  Guard space between the Current_Stack_Level'Address and the last\n       --  allocated byte on the stack.\n-\n    begin\n-      --  Easiest and most accurate method: the top of the stack is known.\n-\n-      if Analyzer.Top_Pattern_Mark /= 0 then\n-         Analyzer.Pattern_Size :=\n-           Stack_Size (Analyzer.Top_Pattern_Mark,\n-                       To_Stack_Address (Current_Stack_Level'Address))\n-           - Guard;\n-\n-         if System.Parameters.Stack_Grows_Down then\n-            Analyzer.Stack_Overlay_Address :=\n-              To_Address (Analyzer.Top_Pattern_Mark);\n-         else\n-            Analyzer.Stack_Overlay_Address :=\n-              To_Address (Analyzer.Top_Pattern_Mark\n-                            - Stack_Address (Analyzer.Pattern_Size));\n+      if Parameters.Stack_Grows_Down then\n+         if Analyzer.Stack_Base - Stack_Address (Analyzer.Pattern_Size)\n+           > To_Stack_Address (Current_Stack_Level'Address) - Guard\n+         then\n+            --  No room for a pattern\n+            Analyzer.Pattern_Size := 0;\n+            return;\n          end if;\n \n-         declare\n-            Pattern : aliased Stack_Slots\n-                        (1 .. Analyzer.Pattern_Size / Bytes_Per_Pattern);\n-            for Pattern'Address use Analyzer.Stack_Overlay_Address;\n-\n-         begin\n-            if System.Parameters.Stack_Grows_Down then\n-               for J in reverse Pattern'Range loop\n-                  Pattern (J) := Analyzer.Pattern;\n-               end loop;\n+         Analyzer.Pattern_Limit := Analyzer.Stack_Base\n+           - Stack_Address (Analyzer.Pattern_Size);\n \n-               Analyzer.Bottom_Pattern_Mark :=\n-                 To_Stack_Address (Pattern (Pattern'Last)'Address);\n-\n-            else\n-               for J in Pattern'Range loop\n-                  Pattern (J) := Analyzer.Pattern;\n-               end loop;\n-\n-               Analyzer.Bottom_Pattern_Mark :=\n-                 To_Stack_Address (Pattern (Pattern'First)'Address);\n-            end if;\n-         end;\n+         if Analyzer.Stack_Base >\n+           To_Stack_Address (Current_Stack_Level'Address) - Guard\n+         then\n+            --  Reduce pattern size to prevent local frame overwrite\n+            Analyzer.Pattern_Size :=\n+              Integer (To_Stack_Address (Current_Stack_Level'Address) - Guard\n+                         - Analyzer.Pattern_Limit);\n+         end if;\n \n+         Analyzer.Pattern_Overlay_Address :=\n+           To_Address (Analyzer.Pattern_Limit);\n       else\n-         --  Readjust the pattern size. When we arrive in this function, there\n-         --  is already a given amount of stack used, that we won't analyze.\n+         if Analyzer.Stack_Base + Stack_Address (Analyzer.Pattern_Size)\n+           < To_Stack_Address (Current_Stack_Level'Address) + Guard\n+         then\n+            --  No room for a pattern\n+            Analyzer.Pattern_Size := 0;\n+            return;\n+         end if;\n \n-         Stack_Used_When_Filling :=\n-           Stack_Size (Analyzer.Bottom_Of_Stack,\n-                       To_Stack_Address (Current_Stack_Level'Address));\n+         Analyzer.Pattern_Limit := Analyzer.Stack_Base\n+           + Stack_Address (Analyzer.Pattern_Size);\n \n-         if Stack_Used_When_Filling > Analyzer.Pattern_Size then\n+         if Analyzer.Stack_Base <\n+           To_Stack_Address (Current_Stack_Level'Address) + Guard\n+         then\n+            --  Reduce pattern size to prevent local frame overwrite\n+            Analyzer.Pattern_Size := Integer\n+              (Analyzer.Pattern_Limit\n+                 - (To_Stack_Address (Current_Stack_Level'Address) + Guard));\n+         end if;\n \n-            --  In this case, the known size of the stack is too small, we've\n-            --  already taken more than expected, so there's no possible\n-            --  computation\n+         Analyzer.Pattern_Overlay_Address :=\n+           To_Address (Analyzer.Pattern_Limit\n+                         - Stack_Address (Analyzer.Pattern_Size));\n+      end if;\n \n-            Analyzer.Pattern_Size := 0;\n+      --  Declare and fill the pattern buffer\n+      declare\n+         Pattern : aliased Stack_Slots\n+           (1 .. Analyzer.Pattern_Size / Bytes_Per_Pattern);\n+         for Pattern'Address use Analyzer.Pattern_Overlay_Address;\n+\n+      begin\n+         if System.Parameters.Stack_Grows_Down then\n+            for J in reverse Pattern'Range loop\n+               Pattern (J) := Analyzer.Pattern;\n+            end loop;\n          else\n-            Analyzer.Pattern_Size :=\n-              Analyzer.Pattern_Size - Stack_Used_When_Filling;\n+            for J in Pattern'Range loop\n+               Pattern (J) := Analyzer.Pattern;\n+            end loop;\n          end if;\n-\n-         declare\n-            Stack : aliased Stack_Slots\n-              (1 .. Analyzer.Pattern_Size / Bytes_Per_Pattern);\n-\n-         begin\n-            Stack := (others => Analyzer.Pattern);\n-\n-            Analyzer.Stack_Overlay_Address := Stack'Address;\n-\n-            if Analyzer.Pattern_Size /= 0 then\n-               Analyzer.Bottom_Pattern_Mark :=\n-                 To_Stack_Address\n-                   (Stack (Bottom_Slot_Index_In (Stack))'Address);\n-               Analyzer.Top_Pattern_Mark :=\n-                 To_Stack_Address\n-                   (Stack (Top_Slot_Index_In (Stack))'Address);\n-            else\n-               Analyzer.Bottom_Pattern_Mark :=\n-                 To_Stack_Address (Stack'Address);\n-               Analyzer.Top_Pattern_Mark :=\n-                 To_Stack_Address (Stack'Address);\n-            end if;\n-         end;\n-      end if;\n+      end;\n    end Fill_Stack;\n \n    -------------------------\n@@ -359,22 +262,20 @@ package body System.Stack_Usage is\n    procedure Initialize_Analyzer\n      (Analyzer         : in out Stack_Analyzer;\n       Task_Name        : String;\n-      My_Stack_Size    : Natural;\n-      Max_Pattern_Size : Natural;\n-      Bottom           : Stack_Address;\n-      Top              : Stack_Address;\n-      Pattern          : Unsigned_32 := 16#DEAD_BEEF#)\n+      Stack_Size       : Natural;\n+      Stack_Base       : Stack_Address;\n+      Pattern_Size     : Natural;\n+      Pattern          : Interfaces.Unsigned_32 := 16#DEAD_BEEF#)\n    is\n    begin\n       --  Initialize the analyzer fields\n \n-      Analyzer.Bottom_Of_Stack  := Bottom;\n-      Analyzer.Stack_Size       := My_Stack_Size;\n-      Analyzer.Pattern_Size     := Max_Pattern_Size;\n-      Analyzer.Pattern          := Pattern;\n-      Analyzer.Result_Id        := Next_Id;\n-      Analyzer.Task_Name        := (others => ' ');\n-      Analyzer.Top_Pattern_Mark := Top;\n+      Analyzer.Stack_Base    := Stack_Base;\n+      Analyzer.Stack_Size    := Stack_Size;\n+      Analyzer.Pattern_Size  := Pattern_Size;\n+      Analyzer.Pattern       := Pattern;\n+      Analyzer.Result_Id     := Next_Id;\n+      Analyzer.Task_Name     := (others => ' ');\n \n       --  Compute the task name, and truncate if bigger than Task_Name_Length\n \n@@ -399,9 +300,9 @@ package body System.Stack_Usage is\n    is\n    begin\n       if SP_Low > SP_High then\n-         return Natural (SP_Low - SP_High + 4);\n+         return Natural (SP_Low - SP_High);\n       else\n-         return Natural (SP_High - SP_Low + 4);\n+         return Natural (SP_High - SP_Low);\n       end if;\n    end Stack_Size;\n \n@@ -417,10 +318,17 @@ package body System.Stack_Usage is\n       --  likely to happen.\n \n       Stack : Stack_Slots (1 .. Analyzer.Pattern_Size / Bytes_Per_Pattern);\n-      for Stack'Address use Analyzer.Stack_Overlay_Address;\n+      for Stack'Address use Analyzer.Pattern_Overlay_Address;\n \n    begin\n-      Analyzer.Topmost_Touched_Mark := Analyzer.Bottom_Pattern_Mark;\n+      --  Value if the pattern was not modified\n+      if Parameters.Stack_Grows_Down then\n+         Analyzer.Topmost_Touched_Mark :=\n+           Analyzer.Pattern_Limit + Stack_Address (Analyzer.Pattern_Size);\n+      else\n+         Analyzer.Topmost_Touched_Mark :=\n+           Analyzer.Pattern_Limit - Stack_Address (Analyzer.Pattern_Size);\n+      end if;\n \n       if Analyzer.Pattern_Size = 0 then\n          return;\n@@ -430,39 +338,26 @@ package body System.Stack_Usage is\n       --  the bottom of it. The first index not equals to the patterns marks\n       --  the beginning of the used stack.\n \n-      declare\n-         Top_Index    : constant Integer := Top_Slot_Index_In (Stack);\n-         Bottom_Index : constant Integer := Bottom_Slot_Index_In (Stack);\n-         Step         : constant Integer := Pop_Index_Step_For (Stack);\n-         J            : Integer;\n-\n-      begin\n-         J := Top_Index;\n-         loop\n+      if System.Parameters.Stack_Grows_Down then\n+         for J in Stack'Range loop\n             if Stack (J) /= Analyzer.Pattern then\n                Analyzer.Topmost_Touched_Mark\n                  := To_Stack_Address (Stack (J)'Address);\n                exit;\n             end if;\n-\n-            exit when J = Bottom_Index;\n-            J := J + Step;\n          end loop;\n-      end;\n-   end Compute_Result;\n \n-   ---------------------\n-   -- Get_Usage_Range --\n-   ---------------------\n+      else\n+         for J in reverse Stack'Range loop\n+            if Stack (J) /= Analyzer.Pattern then\n+               Analyzer.Topmost_Touched_Mark\n+                 := To_Stack_Address (Stack (J)'Address);\n+               exit;\n+            end if;\n+         end loop;\n \n-   function Get_Usage_Range (Result : Task_Result) return String is\n-      Variation_Used_Str : constant String :=\n-                             Natural'Image (Result.Variation);\n-      Value_Used_Str     : constant String :=\n-                             Natural'Image (Result.Value);\n-   begin\n-      return Value_Used_Str & \" +/- \" & Variation_Used_Str;\n-   end Get_Usage_Range;\n+      end if;\n+   end Compute_Result;\n \n    ---------------------\n    --  Output_Result --\n@@ -474,16 +369,16 @@ package body System.Stack_Usage is\n       Max_Stack_Size_Len : Natural;\n       Max_Actual_Use_Len : Natural)\n    is\n-      Result_Id_Str     : constant String := Natural'Image (Result_Id);\n-      My_Stack_Size_Str : constant String := Natural'Image (Result.Max_Size);\n-      Actual_Use_Str    : constant String := Get_Usage_Range (Result);\n+      Result_Id_Str  : constant String := Natural'Image (Result_Id);\n+      Stack_Size_Str : constant String := Natural'Image (Result.Stack_Size);\n+      Actual_Use_Str : constant String := Natural'Image (Result.Value);\n \n       Result_Id_Blanks  : constant\n         String (1 .. Index_Str'Length - Result_Id_Str'Length)    :=\n           (others => ' ');\n \n       Stack_Size_Blanks : constant\n-        String (1 .. Max_Stack_Size_Len - My_Stack_Size_Str'Length) :=\n+        String (1 .. Max_Stack_Size_Len - Stack_Size_Str'Length) :=\n           (others => ' ');\n \n       Actual_Use_Blanks : constant\n@@ -496,7 +391,7 @@ package body System.Stack_Usage is\n       Put (\" | \");\n       Put (Result.Task_Name);\n       Put (\" | \");\n-      Put (Stack_Size_Blanks & My_Stack_Size_Str);\n+      Put (Stack_Size_Blanks & Stack_Size_Str);\n       Put (\" | \");\n       Put (Actual_Use_Blanks & Actual_Use_Str);\n       New_Line;\n@@ -508,7 +403,7 @@ package body System.Stack_Usage is\n \n    procedure Output_Results is\n       Max_Stack_Size                         : Natural := 0;\n-      Max_Actual_Use_Result_Id               : Natural := Result_Array'First;\n+      Max_Stack_Usage                        : Natural := 0;\n       Max_Stack_Size_Len, Max_Actual_Use_Len : Natural := 0;\n \n       Task_Name_Blanks : constant\n@@ -531,21 +426,18 @@ package body System.Stack_Usage is\n          for J in Result_Array'Range loop\n             exit when J >= Next_Id;\n \n-            if Result_Array (J).Value >\n-               Result_Array (Max_Actual_Use_Result_Id).Value\n-            then\n-               Max_Actual_Use_Result_Id := J;\n+            if Result_Array (J).Value > Max_Stack_Usage then\n+               Max_Stack_Usage := Result_Array (J).Value;\n             end if;\n \n-            if Result_Array (J).Max_Size > Max_Stack_Size then\n-               Max_Stack_Size := Result_Array (J).Max_Size;\n+            if Result_Array (J).Stack_Size > Max_Stack_Size then\n+               Max_Stack_Size := Result_Array (J).Stack_Size;\n             end if;\n          end loop;\n \n          Max_Stack_Size_Len := Natural'Image (Max_Stack_Size)'Length;\n \n-         Max_Actual_Use_Len :=\n-           Get_Usage_Range (Result_Array (Max_Actual_Use_Result_Id))'Length;\n+         Max_Actual_Use_Len := Natural'Image (Max_Stack_Usage)'Length;\n \n          --  Display the output header. Blanks will be added in front of the\n          --  labels if needed.\n@@ -599,37 +491,22 @@ package body System.Stack_Usage is\n    -------------------\n \n    procedure Report_Result (Analyzer : Stack_Analyzer) is\n-      Result  : Task_Result :=\n-                  (Task_Name      => Analyzer.Task_Name,\n-                   Max_Size       => Analyzer.Stack_Size,\n-                   Variation    => 0,\n-                   Value    => 0);\n-\n-      Overflow_Guard : constant Integer :=\n-        Analyzer.Stack_Size\n-          - Stack_Size (Analyzer.Top_Pattern_Mark, Analyzer.Bottom_Of_Stack);\n-      Max, Min : Positive;\n-\n+      Result  : Task_Result := (Task_Name  => Analyzer.Task_Name,\n+                                Stack_Size => Analyzer.Stack_Size,\n+                                Value      => 0);\n    begin\n       if Analyzer.Pattern_Size = 0 then\n-\n          --  If we have that result, it means that we didn't do any computation\n          --  at all. In other words, we used at least everything (and possibly\n          --  more).\n \n-         Min := Analyzer.Stack_Size - Overflow_Guard;\n-         Max := Analyzer.Stack_Size;\n+         Result.Value := Analyzer.Stack_Size;\n \n       else\n-         Min :=\n-           Stack_Size\n-             (Analyzer.Topmost_Touched_Mark, Analyzer.Bottom_Of_Stack);\n-         Max := Min + Overflow_Guard;\n+         Result.Value := Stack_Size (Analyzer.Topmost_Touched_Mark,\n+                                     Analyzer.Stack_Base);\n       end if;\n \n-      Result.Value := (Max + Min) / 2;\n-      Result.Variation := (Max - Min) / 2;\n-\n       if Analyzer.Result_Id in Result_Array'Range then\n \n          --  If the result can be stored, then store it in Result_Array\n@@ -641,7 +518,7 @@ package body System.Stack_Usage is\n \n          declare\n             Result_Str_Len : constant Natural :=\n-                               Get_Usage_Range (Result)'Length;\n+                               Natural'Image (Result.Value)'Length;\n             Size_Str_Len   : constant Natural :=\n                                Natural'Image (Analyzer.Stack_Size)'Length;\n "}, {"sha": "c0449e8fbc88a4ae1055fe8183e8c3243d1d9d37", "filename": "gcc/ada/s-stausa.ads", "status": "modified", "additions": 35, "deletions": 43, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ba7e31e7e1c77b639c88aff631900ab7db5958b/gcc%2Fada%2Fs-stausa.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ba7e31e7e1c77b639c88aff631900ab7db5958b/gcc%2Fada%2Fs-stausa.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-stausa.ads?ref=2ba7e31e7e1c77b639c88aff631900ab7db5958b", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---         Copyright (C) 2004-2010, Free Software Foundation, Inc.          --\n+--         Copyright (C) 2004-2011, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -57,11 +57,8 @@ package System.Stack_Usage is\n       --  Amount of stack used. The value is calculated on the basis of the\n       --  mechanism used by GNAT to allocate it, and it is NOT a precise value.\n \n-      Variation : Natural;\n-      --  Possible variation in the amount of used stack. The real stack usage\n-      --  may vary in the range Value +/- Variation\n-\n-      Max_Size : Natural;\n+      Stack_Size : Natural;\n+      --  Size of the stack\n    end record;\n \n    type Result_Array_Type is array (Positive range <>) of Task_Result;\n@@ -91,8 +88,9 @@ package System.Stack_Usage is\n    --  begin\n    --     Initialize_Analyzer (A,\n    --                          \"Task t\",\n+   --                          A_Storage_Size,\n+   --                          0,\n    --                          A_Storage_Size - A_Guard,\n-   --                          A_Guard\n    --                          To_Stack_Address (Bottom_Of_Stack'Address));\n    --     Fill_Stack (A);\n    --     Some_User_Code;\n@@ -115,7 +113,9 @@ package System.Stack_Usage is\n    --       before the call to the instrumentation procedure.\n \n    --     Strategy: The user of this package should measure the bottom of stack\n-   --       before the call to Fill_Stack and pass it in parameter.\n+   --       before the call to Fill_Stack and pass it in parameter. The impact\n+   --       is very minor unless the stack used is very small, but in this case\n+   --       you aren't very interested by the figure.\n \n    --  Instrumentation threshold at writing:\n \n@@ -212,32 +212,29 @@ package System.Stack_Usage is\n    --  the memory will look like that:\n    --\n    --                                                             Stack growing\n-   --  ----------------------------------------------------------------------->\n-   --  |<---------------------->|<----------------------------------->|\n-   --  |  Stack frame           | Memory filled with Analyzer.Pattern |\n-   --  |  of Fill_Stack         |                                     |\n-   --  |  (deallocated at       |                                     |\n-   --  |  the end of the call)  |                                     |\n-   --  ^                        |                                     ^\n-   --  Analyzer.Bottom_Of_Stack |                  Analyzer.Top_Pattern_Mark\n-   --                           ^\n-   --                    Analyzer.Bottom_Pattern_Mark\n+   --  ---------------------------------------------------------------------->\n+   --  |<--------------------->|<----------------------------------->|\n+   --  |  Stack frames to      | Memory filled with Analyzer.Pattern |\n+   --  |  Fill_Stack           |                                     |\n+   --  ^                       |                                     ^\n+   --  Analyzer.Stack_Base     |                      Analyzer.Pattern_Limit\n+   --                          ^\n+   --                    Analyzer.Pattern_Limit +/- Analyzer.Pattern_Size\n    --\n \n    procedure Initialize_Analyzer\n      (Analyzer         : in out Stack_Analyzer;\n       Task_Name        : String;\n-      My_Stack_Size    : Natural;\n-      Max_Pattern_Size : Natural;\n-      Bottom           : Stack_Address;\n-      Top              : Stack_Address;\n+      Stack_Size       : Natural;\n+      Stack_Base       : Stack_Address;\n+      Pattern_Size     : Natural;\n       Pattern          : Interfaces.Unsigned_32 := 16#DEAD_BEEF#);\n    --  Should be called before any use of a Stack_Analyzer, to initialize it.\n    --  Max_Pattern_Size is the size of the pattern zone, might be smaller than\n-   --  the full stack size in order to take into account e.g. the secondary\n-   --  stack and a guard against overflow. The actual size taken will be\n-   --  readjusted with data already used at the time the stack is actually\n-   --  filled.\n+   --  the full stack size Stack_Size in order to take into account e.g. the\n+   --  secondary stack and a guard against overflow. The actual size taken\n+   --  will be readjusted with data already used at the time the stack is\n+   --  actually filled.\n \n    Is_Enabled : Boolean := False;\n    --  When this flag is true, then stack analysis is enabled\n@@ -253,16 +250,14 @@ package System.Stack_Usage is\n    --                                                             Stack growing\n    --  ----------------------------------------------------------------------->\n    --  |<---------------------->|<-------------->|<--------->|<--------->|\n-   --  |  Stack frame           | Array of       | used      |  Memory   |\n-   --  |  of Compute_Result     | Analyzer.Probe | during    |   filled  |\n-   --  |  (deallocated at       | elements       |  the      |    with   |\n-   --  |  the end of the call)  |                | execution |  pattern  |\n-   --  |                        ^                |           |           |\n-   --  |                   Bottom_Pattern_Mark   |           |           |\n+   --  |  Stack frames          | Array of       | used      |  Memory   |\n+   --  |  to Compute_Result     | Analyzer.Probe | during    |   filled  |\n+   --  |                        | elements       |  the      |    with   |\n+   --  |                        |                | execution |  pattern  |\n    --  |                                                     |           |\n    --  |<---------------------------------------------------->           |\n    --                  Stack used                                        ^\n-   --                                                     Top_Pattern_Mark\n+   --                                                           Pattern_Limit\n \n    procedure Report_Result (Analyzer : Stack_Analyzer);\n    --  Store the results of the computation in memory, at the address\n@@ -288,6 +283,10 @@ private\n       Task_Name : String (1 .. Task_Name_Length);\n       --  Name of the task\n \n+      Stack_Base : Stack_Address;\n+      --  Address of the base of the stack, as given by the caller of\n+      --  Initialize_Analyzer.\n+\n       Stack_Size : Natural;\n       --  Entire size of the analyzed stack\n \n@@ -297,23 +296,16 @@ private\n       Pattern : Pattern_Type;\n       --  Pattern used to recognize untouched memory\n \n-      Bottom_Pattern_Mark : Stack_Address;\n-      --  Bound of the pattern area on the stack closest to the bottom\n-\n-      Top_Pattern_Mark : Stack_Address;\n-      --  Topmost bound of the pattern area on the stack\n+      Pattern_Limit : Stack_Address;\n+      --  Bound of the pattern area farthest to the base\n \n       Topmost_Touched_Mark : Stack_Address;\n       --  Topmost address of the pattern area whose value it is pointing\n       --  at has been modified during execution. If the systematic error are\n       --  compensated, it is the topmost value of the stack pointer during\n       --  the execution.\n \n-      Bottom_Of_Stack : Stack_Address;\n-      --  Address of the bottom of the stack, as given by the caller of\n-      --  Initialize_Analyzer.\n-\n-      Stack_Overlay_Address : System.Address;\n+      Pattern_Overlay_Address : System.Address;\n       --  Address of the stack abstraction object we overlay over a\n       --  task's real stack, typically a pattern-initialized array.\n "}, {"sha": "8961759ce103184ac7245d32287b827346169019", "filename": "gcc/ada/s-stusta.adb", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ba7e31e7e1c77b639c88aff631900ab7db5958b/gcc%2Fada%2Fs-stusta.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ba7e31e7e1c77b639c88aff631900ab7db5958b/gcc%2Fada%2Fs-stusta.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-stusta.adb?ref=2ba7e31e7e1c77b639c88aff631900ab7db5958b", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---           Copyright (C) 2009-2010, Free Software Foundation, Inc.        --\n+--           Copyright (C) 2009-2011, Free Software Foundation, Inc.        --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -250,9 +250,8 @@ package body System.Stack_Usage.Tasking is\n                     Obj.Task_Name (Obj.Task_Name'First .. Pos);\n       begin\n          Put_Line\n-           (\"| \" & T_Name & \" | \" & Natural'Image (Obj.Max_Size) &\n-            Natural'Image (Obj.Value) & \" +/- \" &\n-            Natural'Image (Obj.Variation));\n+           (\"| \" & T_Name & \" | \" & Natural'Image (Obj.Stack_Size) &\n+            Natural'Image (Obj.Value));\n       end;\n    end Print;\n "}, {"sha": "9a5b67d52840823c0690c8c09f455347b4945b66", "filename": "gcc/ada/s-tassta.adb", "status": "modified", "additions": 58, "deletions": 40, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ba7e31e7e1c77b639c88aff631900ab7db5958b/gcc%2Fada%2Fs-tassta.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ba7e31e7e1c77b639c88aff631900ab7db5958b/gcc%2Fada%2Fs-tassta.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tassta.adb?ref=2ba7e31e7e1c77b639c88aff631900ab7db5958b", "patch": "@@ -1027,32 +1027,11 @@ package body System.Tasking.Stages is\n \n       Secondary_Stack : aliased SSE.Storage_Array (1 .. Secondary_Stack_Size);\n \n-      pragma Warnings (Off);\n-      --  Why are warnings being turned off here???\n-\n       Secondary_Stack_Address : System.Address := Secondary_Stack'Address;\n       --  Address of secondary stack. In the fixed secondary stack case, this\n       --  value is not modified, causing a warning, hence the bracketing with\n       --  Warnings (Off/On). But why is so much *more* bracketed???\n \n-      Small_Overflow_Guard : constant := 12 * 1024;\n-      --  Note: this used to be 4K, but was changed to 12K, since smaller\n-      --  values resulted in segmentation faults from dynamic stack analysis.\n-\n-      Big_Overflow_Guard   : constant := 16 * 1024;\n-      Small_Stack_Limit    : constant := 64 * 1024;\n-      --  ??? These three values are experimental, and seems to work on most\n-      --  platforms. They still need to be analyzed further. They also need\n-      --  documentation, what are they???\n-\n-      Size : Natural :=\n-               Natural (Self_ID.Common.Compiler_Data.Pri_Stack_Info.Size);\n-\n-      Overflow_Guard : Natural;\n-      --  Size of the overflow guard, used by dynamic stack usage analysis\n-\n-      pragma Warnings (On);\n-\n       SEH_Table : aliased SSE.Storage_Array (1 .. 8);\n       --  Structured Exception Registration table (2 words)\n \n@@ -1116,7 +1095,6 @@ package body System.Tasking.Stages is\n          Self_ID.Common.Compiler_Data.Sec_Stack_Addr :=\n            Secondary_Stack'Address;\n          SST.SS_Init (Secondary_Stack_Address, Integer (Secondary_Stack'Last));\n-         Size := Size - Natural (Secondary_Stack_Size);\n       end if;\n \n       if Use_Alternate_Stack then\n@@ -1136,24 +1114,64 @@ package body System.Tasking.Stages is\n       --  Initialize dynamic stack usage\n \n       if System.Stack_Usage.Is_Enabled then\n-         Overflow_Guard :=\n-           (if Size < Small_Stack_Limit\n-              then Small_Overflow_Guard\n-              else Big_Overflow_Guard);\n-\n-         STPO.Lock_RTS;\n-         Initialize_Analyzer\n-           (Self_ID.Common.Analyzer,\n-            Self_ID.Common.Task_Image\n-              (1 .. Self_ID.Common.Task_Image_Len),\n-            Natural\n-              (Self_ID.Common.Compiler_Data.Pri_Stack_Info.Size),\n-            Size - Overflow_Guard,\n-            SSE.To_Integer (Bottom_Of_Stack'Address),\n-            SSE.To_Integer\n-              (Self_ID.Common.Compiler_Data.Pri_Stack_Info.Limit));\n-         STPO.Unlock_RTS;\n-         Fill_Stack (Self_ID.Common.Analyzer);\n+         declare\n+            Guard_Page_Size      : constant := 12 * 1024;\n+            --  Part of the stack used as a guard page. This is an OS dependent\n+            --  value, so we need to use the maximum. This value is only used\n+            --  when the stack address is known, that is currently Windows.\n+\n+            Small_Overflow_Guard : constant := 12 * 1024;\n+            --  Note: this used to be 4K, but was changed to 12K, since\n+            --  smaller values resulted in segmentation faults from dynamic\n+            --  stack analysis.\n+\n+            Big_Overflow_Guard   : constant := 16 * 1024;\n+            Small_Stack_Limit    : constant := 64 * 1024;\n+            --  ??? These three values are experimental, and seems to work on\n+            --  most platforms. They still need to be analyzed further. They\n+            --  also need documentation, what are they???\n+\n+            Pattern_Size : Natural :=\n+              Natural (Self_ID.Common.Compiler_Data.Pri_Stack_Info.Size);\n+            --  Size of the pattern\n+\n+            Stack_Base : Address;\n+            --  Address of the base of the stack\n+         begin\n+            Stack_Base := Self_ID.Common.Compiler_Data.Pri_Stack_Info.Base;\n+            if Stack_Base = Null_Address then\n+               --  On many platforms, we don't know the real stack base\n+               --  address. Estimate it using an address in the frame.\n+               Stack_Base := Bottom_Of_Stack'Address;\n+\n+               --  Also reduce the size of the stack to take into account the\n+               --  secondary stack array declared in this frame. This is for\n+               --  sure very conservative.\n+               if not Parameters.Sec_Stack_Dynamic then\n+                  Pattern_Size :=\n+                    Pattern_Size - Natural (Secondary_Stack_Size);\n+               end if;\n+\n+               --  Adjustments for inner frames\n+               Pattern_Size := Pattern_Size -\n+                 (if Pattern_Size < Small_Stack_Limit\n+                    then Small_Overflow_Guard\n+                    else Big_Overflow_Guard);\n+            else\n+               --  Reduce by the size of the final guard page\n+               Pattern_Size := Pattern_Size - Guard_Page_Size;\n+            end if;\n+\n+            STPO.Lock_RTS;\n+            Initialize_Analyzer\n+              (Self_ID.Common.Analyzer,\n+               Self_ID.Common.Task_Image (1 .. Self_ID.Common.Task_Image_Len),\n+               Natural (Self_ID.Common.Compiler_Data.Pri_Stack_Info.Size),\n+               SSE.To_Integer (Stack_Base),\n+               Pattern_Size);\n+            STPO.Unlock_RTS;\n+            Fill_Stack (Self_ID.Common.Analyzer);\n+         end;\n       end if;\n \n       --  We setup the SEH (Structured Exception Handling) handler if supported"}, {"sha": "9528841e1c80252e574eb79770faaa15f8f5d699", "filename": "gcc/ada/sem.ads", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ba7e31e7e1c77b639c88aff631900ab7db5958b/gcc%2Fada%2Fsem.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ba7e31e7e1c77b639c88aff631900ab7db5958b/gcc%2Fada%2Fsem.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem.ads?ref=2ba7e31e7e1c77b639c88aff631900ab7db5958b", "patch": "@@ -240,14 +240,6 @@ package Sem is\n    --  then Full_Analysis above must be False. You should really regard this as\n    --  a read only flag.\n \n-   In_Pre_Post_Expression : Boolean := False;\n-   --  Switch to indicate that we are in a precondition or postcondition. The\n-   --  analysis is not expected to process a precondition or a postcondition as\n-   --  a sub-analysis for another precondition or postcondition, so this switch\n-   --  needs not be saved for recursive calls. When this switch is True then\n-   --  In_Spec_Expression above must be True also. You should really regard\n-   --  this as a read only flag.\n-\n    In_Deleted_Code : Boolean := False;\n    --  If the condition in an if-statement is statically known, the branch\n    --  that is not taken is analyzed with expansion disabled, and the tree"}, {"sha": "d04a7efc41387e62aec80e90093ea97a54eab215", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ba7e31e7e1c77b639c88aff631900ab7db5958b/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ba7e31e7e1c77b639c88aff631900ab7db5958b/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=2ba7e31e7e1c77b639c88aff631900ab7db5958b", "patch": "@@ -258,11 +258,8 @@ package body Sem_Prag is\n       --  Preanalyze the boolean expression, we treat this as a spec expression\n       --  (i.e. similar to a default expression).\n \n-      pragma Assert (In_Pre_Post_Expression = False);\n-      In_Pre_Post_Expression := True;\n       Preanalyze_Spec_Expression\n         (Get_Pragma_Arg (Arg1), Standard_Boolean);\n-      In_Pre_Post_Expression := False;\n \n       --  Remove the subprogram from the scope stack now that the pre-analysis\n       --  of the precondition/postcondition is done."}]}