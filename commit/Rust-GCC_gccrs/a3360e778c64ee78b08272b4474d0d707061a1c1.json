{"sha": "a3360e778c64ee78b08272b4474d0d707061a1c1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTMzNjBlNzc4YzY0ZWU3OGIwODI3MmI0NDc0ZDBkNzA3MDYxYTFjMQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2010-05-19T21:02:27Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2010-05-19T21:02:27Z"}, "message": "call.c (reference_binding): Use cp_build_qualified_type_real and cp_type_quals consistently.\n\n\t* call.c (reference_binding): Use cp_build_qualified_type_real\n\tand cp_type_quals consistently.\n\t(add_function_candidate): Likewise.\n\t(build_conditional_expr): Likewise.\n\t(convert_like_real): Likewise.\n\t(type_passed_as): Likewise.\n\t* class.c (add_method): Likewise.\n\t(same_signature_p): Likewise.\n\t(layout_class_type): Likewise.\n\t* decl.c (cxx_init_decl_processing): Likewise.\n\t(cp_fname_init): Likewise.\n\t(grokdeclarator): Likewise.\n\t* decl2.c (cp_reconstruct_complex_type): Likewise.\n\t* init.c (build_new_1): Likewise.\n\t* method.c (do_build_copy_constructor): Likewise.\n\t(implicitly_declare_fn): Likewise.\n\t* pt.c (tsubst_aggr_type): Likewise.\n\t(tsubst): Likewise.\n\t* rtti.c (init_rtti_processing): Likewise.\n\t(build_headof): Likewise.\n\t(build_dynamic_cast_1): Likewise.\n\t(tinfo_base_init): Likewise.\n\t(emit_support_tinfos): Likewise.\n\t* semantics.c (capture_decltype): Likewise.\n\t* tree.c (cv_unqualified): Likewise.\n\t* typeck.c (composite_pointer_type): Likewise.\n\t(string_conv_p): Likewise.\n\n\t* mangle.c (write_CV_qualifiers_for_type): Tweak.\n\n\t* call.c (initialize_reference): Use CP_TYPE_CONST_P.\n\t* decl.c (start_decl): Likewise.\n\t* semantics.c (finish_compound_literal): Likewise.\n\t* typeck.c (check_return_expr): Use CP_TYPE_VOLATILE_P.\n\t(cp_type_readonly): Remove.\n\t* cp-tree.h: Remove declaration.\n\nFrom-SVN: r159599", "tree": {"sha": "d2b59673b254491d2a8bacc1360f3025eb0c68ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d2b59673b254491d2a8bacc1360f3025eb0c68ad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a3360e778c64ee78b08272b4474d0d707061a1c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3360e778c64ee78b08272b4474d0d707061a1c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3360e778c64ee78b08272b4474d0d707061a1c1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3360e778c64ee78b08272b4474d0d707061a1c1/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a0685b7311e693f8b0ed709ae0727af294a6a72b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0685b7311e693f8b0ed709ae0727af294a6a72b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0685b7311e693f8b0ed709ae0727af294a6a72b"}], "stats": {"total": 144, "additions": 86, "deletions": 58}, "files": [{"sha": "68d461e72bb0782c53b108e9ae2a77b625c4078b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3360e778c64ee78b08272b4474d0d707061a1c1/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3360e778c64ee78b08272b4474d0d707061a1c1/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a3360e778c64ee78b08272b4474d0d707061a1c1", "patch": "@@ -1,5 +1,42 @@\n 2010-05-19  Jason Merrill  <jason@redhat.com>\n \n+\t* call.c (reference_binding): Use cp_build_qualified_type_real\n+\tand cp_type_quals consistently.\n+\t(add_function_candidate): Likewise.\n+\t(build_conditional_expr): Likewise.\n+\t(convert_like_real): Likewise.\n+\t(type_passed_as): Likewise.\n+\t* class.c (add_method): Likewise.\n+\t(same_signature_p): Likewise.\n+\t(layout_class_type): Likewise.\n+\t* decl.c (cxx_init_decl_processing): Likewise.\n+\t(cp_fname_init): Likewise.\n+\t(grokdeclarator): Likewise.\n+\t* decl2.c (cp_reconstruct_complex_type): Likewise.\n+\t* init.c (build_new_1): Likewise.\n+\t* method.c (do_build_copy_constructor): Likewise.\n+\t(implicitly_declare_fn): Likewise.\n+\t* pt.c (tsubst_aggr_type): Likewise.\n+\t(tsubst): Likewise.\n+\t* rtti.c (init_rtti_processing): Likewise.\n+\t(build_headof): Likewise.\n+\t(build_dynamic_cast_1): Likewise.\n+\t(tinfo_base_init): Likewise.\n+\t(emit_support_tinfos): Likewise.\n+\t* semantics.c (capture_decltype): Likewise.\n+\t* tree.c (cv_unqualified): Likewise.\n+\t* typeck.c (composite_pointer_type): Likewise.\n+\t(string_conv_p): Likewise.\n+\n+\t* mangle.c (write_CV_qualifiers_for_type): Tweak.\n+\n+\t* call.c (initialize_reference): Use CP_TYPE_CONST_P.\n+\t* decl.c (start_decl): Likewise.\n+\t* semantics.c (finish_compound_literal): Likewise.\n+\t* typeck.c (check_return_expr): Use CP_TYPE_VOLATILE_P.\n+\t(cp_type_readonly): Remove.\n+\t* cp-tree.h: Remove declaration.\n+\n \t* typeck.c (merge_types): Preserve memfn quals.\n \n \t* decl.c (grokdeclarator): Don't check quals on fn type."}, {"sha": "3cb30a5d8ee83f683348ddcb6bed70311103320c", "filename": "gcc/cp/call.c", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3360e778c64ee78b08272b4474d0d707061a1c1/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3360e778c64ee78b08272b4474d0d707061a1c1/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=a3360e778c64ee78b08272b4474d0d707061a1c1", "patch": "@@ -1246,7 +1246,7 @@ reference_binding (tree rto, tree rfrom, tree expr, bool c_cast_p, int flags)\n      type, so that we can later do a const_cast to the desired type.  */\n   if (related_p && c_cast_p\n       && !at_least_as_qualified_p (to, tfrom))\n-    to = build_qualified_type (to, cp_type_quals (tfrom));\n+    to = cp_build_qualified_type (to, cp_type_quals (tfrom));\n   compatible_p = reference_compatible_p (to, tfrom);\n \n   /* Directly bind reference when target expression's type is compatible with\n@@ -1617,9 +1617,8 @@ add_function_candidate (struct z_candidate **candidates,\n \t     parameter, we can just change the parm type.  */\n \t  if (ctype && is_this)\n \t    {\n-\t      parmtype\n-\t\t= build_qualified_type (ctype,\n-\t\t\t\t\tTYPE_QUALS (TREE_TYPE (parmtype)));\n+\t      parmtype = cp_build_qualified_type\n+\t\t(ctype, cp_type_quals (TREE_TYPE (parmtype)));\n \t      parmtype = build_pointer_type (parmtype);\n \t    }\n \n@@ -3777,11 +3776,11 @@ build_conditional_expr (tree arg1, tree arg2, tree arg3,\n \t the type of the other.  */\n       if ((conv2 || conv3)\n \t  && CLASS_TYPE_P (arg2_type)\n-\t  && TYPE_QUALS (arg2_type) != TYPE_QUALS (arg3_type))\n+\t  && cp_type_quals (arg2_type) != cp_type_quals (arg3_type))\n \targ2_type = arg3_type =\n \t  cp_build_qualified_type (arg2_type,\n-\t\t\t\t   TYPE_QUALS (arg2_type)\n-\t\t\t\t   | TYPE_QUALS (arg3_type));\n+\t\t\t\t   cp_type_quals (arg2_type)\n+\t\t\t\t   | cp_type_quals (arg3_type));\n     }\n \n   /* [expr.cond]\n@@ -4997,7 +4996,7 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \t  }\n \t/* Build up the array.  */\n \telttype = cp_build_qualified_type\n-\t  (elttype, TYPE_QUALS (elttype) | TYPE_QUAL_CONST);\n+\t  (elttype, cp_type_quals (elttype) | TYPE_QUAL_CONST);\n \tarray = build_array_of_n_type (elttype, len);\n \tarray = finish_compound_literal (array, new_ctor);\n \n@@ -5378,7 +5377,7 @@ type_passed_as (tree type)\n     {\n       type = build_reference_type (type);\n       /* There are no other pointers to this temporary.  */\n-      type = build_qualified_type (type, TYPE_QUAL_RESTRICT);\n+      type = cp_build_qualified_type (type, TYPE_QUAL_RESTRICT);\n     }\n   else if (targetm.calls.promote_prototypes (type)\n \t   && INTEGRAL_TYPE_P (type)\n@@ -7735,7 +7734,7 @@ initialize_reference (tree type, tree expr, tree decl, tree *cleanup,\n     {\n       if (complain & tf_error)\n \t{\n-\t  if (!(TYPE_QUALS (TREE_TYPE (type)) & TYPE_QUAL_CONST)\n+\t  if (!CP_TYPE_CONST_P (TREE_TYPE (type))\n \t      && !TYPE_REF_IS_RVALUE (type)\n \t      && !real_lvalue_p (expr))\n \t    error (\"invalid initialization of non-const reference of \""}, {"sha": "748e1b33b60f1b001af5763bb2caf17c38527c19", "filename": "gcc/cp/class.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3360e778c64ee78b08272b4474d0d707061a1c1/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3360e778c64ee78b08272b4474d0d707061a1c1/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=a3360e778c64ee78b08272b4474d0d707061a1c1", "patch": "@@ -1048,8 +1048,8 @@ add_method (tree type, tree method, tree using_decl)\n \t  && ! DECL_STATIC_FUNCTION_P (method)\n \t  && TREE_TYPE (TREE_VALUE (parms1)) != error_mark_node\n \t  && TREE_TYPE (TREE_VALUE (parms2)) != error_mark_node\n-\t  && (TYPE_QUALS (TREE_TYPE (TREE_VALUE (parms1)))\n-\t      != TYPE_QUALS (TREE_TYPE (TREE_VALUE (parms2)))))\n+\t  && (cp_type_quals (TREE_TYPE (TREE_VALUE (parms1)))\n+\t      != cp_type_quals (TREE_TYPE (TREE_VALUE (parms2)))))\n \tcontinue;\n \n       /* For templates, the return type and template parameters\n@@ -1868,8 +1868,8 @@ same_signature_p (const_tree fndecl, const_tree base_fndecl)\n       tree types, base_types;\n       types = TYPE_ARG_TYPES (TREE_TYPE (fndecl));\n       base_types = TYPE_ARG_TYPES (TREE_TYPE (base_fndecl));\n-      if ((TYPE_QUALS (TREE_TYPE (TREE_VALUE (base_types)))\n-\t   == TYPE_QUALS (TREE_TYPE (TREE_VALUE (types))))\n+      if ((cp_type_quals (TREE_TYPE (TREE_VALUE (base_types)))\n+\t   == cp_type_quals (TREE_TYPE (TREE_VALUE (types))))\n \t  && compparms (TREE_CHAIN (base_types), TREE_CHAIN (types)))\n \treturn 1;\n     }\n@@ -5102,7 +5102,7 @@ layout_class_type (tree t, tree *virtuals_p)\n \t\t\t\t\t\t TYPE_UNSIGNED (ftype));\n \t      TREE_TYPE (field)\n \t\t= cp_build_qualified_type (TREE_TYPE (field),\n-\t\t\t\t\t   TYPE_QUALS (ftype));\n+\t\t\t\t\t   cp_type_quals (ftype));\n \t    }\n \t}\n "}, {"sha": "3e1b3105a1bbe21f083b077def6225224195b595", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3360e778c64ee78b08272b4474d0d707061a1c1/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3360e778c64ee78b08272b4474d0d707061a1c1/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=a3360e778c64ee78b08272b4474d0d707061a1c1", "patch": "@@ -5415,7 +5415,6 @@ extern tree build_ptrmemfunc\t\t\t(tree, tree, int, bool);\n extern int cp_type_quals\t\t\t(const_tree);\n extern int type_memfn_quals\t\t\t(const_tree);\n extern tree apply_memfn_quals\t\t\t(tree, cp_cv_quals);\n-extern bool cp_type_readonly\t\t\t(const_tree);\n extern bool cp_has_mutable_p\t\t\t(const_tree);\n extern bool at_least_as_qualified_p\t\t(const_tree, const_tree);\n extern void cp_apply_type_quals_to_decl\t\t(int, tree);"}, {"sha": "43a6bc3d4a0b2f25234a23f3aa28d038e93322c4", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3360e778c64ee78b08272b4474d0d707061a1c1/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3360e778c64ee78b08272b4474d0d707061a1c1/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=a3360e778c64ee78b08272b4474d0d707061a1c1", "patch": "@@ -3482,7 +3482,7 @@ cxx_init_decl_processing (void)\n   vtbl_type_node\n     = build_cplus_array_type (vtable_entry_type, NULL_TREE);\n   layout_type (vtbl_type_node);\n-  vtbl_type_node = build_qualified_type (vtbl_type_node, TYPE_QUAL_CONST);\n+  vtbl_type_node = cp_build_qualified_type (vtbl_type_node, TYPE_QUAL_CONST);\n   record_builtin_type (RID_MAX, NULL, vtbl_type_node);\n   vtbl_ptr_type_node = build_pointer_type (vtable_entry_type);\n   layout_type (vtbl_ptr_type_node);\n@@ -3580,7 +3580,7 @@ cp_fname_init (const char* name, tree *type_p)\n       init = build_string (length + 1, name);\n     }\n \n-  type = build_qualified_type (char_type_node, TYPE_QUAL_CONST);\n+  type = cp_build_qualified_type (char_type_node, TYPE_QUAL_CONST);\n   type = build_cplus_array_type (type, domain);\n \n   *type_p = type;\n@@ -4320,7 +4320,7 @@ start_decl (const cp_declarator *declarator,\n       /* This is a const variable with implicit 'static'.  Set\n \t DECL_THIS_STATIC so we can tell it from variables that are\n \t !TREE_PUBLIC because of the anonymous namespace.  */\n-      gcc_assert (cp_type_readonly (TREE_TYPE (decl)));\n+      gcc_assert (CP_TYPE_CONST_P (TREE_TYPE (decl)));\n       DECL_THIS_STATIC (decl) = 1;\n     }\n \n@@ -8078,8 +8078,8 @@ grokdeclarator (const cp_declarator *declarator,\n   if (long_p && !longlong && TYPE_MAIN_VARIANT (type) == double_type_node)\n     {\n       long_p = false;\n-      type = build_qualified_type (long_double_type_node,\n-\t\t\t\t   cp_type_quals (type));\n+      type = cp_build_qualified_type (long_double_type_node,\n+\t\t\t\t      cp_type_quals (type));\n     }\n \n   /* Check all other uses of type modifiers.  */"}, {"sha": "25c1175485361dc60b7d304035e8f4dbb8141dc8", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3360e778c64ee78b08272b4474d0d707061a1c1/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3360e778c64ee78b08272b4474d0d707061a1c1/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=a3360e778c64ee78b08272b4474d0d707061a1c1", "patch": "@@ -1272,7 +1272,7 @@ cp_reconstruct_complex_type (tree type, tree bottom)\n \n   if (TYPE_ATTRIBUTES (type))\n     outer = cp_build_type_attribute_variant (outer, TYPE_ATTRIBUTES (type));\n-  return cp_build_qualified_type (outer, TYPE_QUALS (type));\n+  return cp_build_qualified_type (outer, cp_type_quals (type));\n }\n \n /* Like decl_attributes, but handle C++ complexity.  */"}, {"sha": "1fb5eb0d0699153d882d0c9c5da3edf59b814992", "filename": "gcc/cp/init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3360e778c64ee78b08272b4474d0d707061a1c1/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3360e778c64ee78b08272b4474d0d707061a1c1/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=a3360e778c64ee78b08272b4474d0d707061a1c1", "patch": "@@ -2200,7 +2200,7 @@ build_new_1 (VEC(tree,gc) **placement, tree type, tree nelts,\n   /* But we want to operate on a non-const version to start with,\n      since we'll be modifying the elements.  */\n   non_const_pointer_type = build_pointer_type\n-    (cp_build_qualified_type (type, TYPE_QUALS (type) & ~TYPE_QUAL_CONST));\n+    (cp_build_qualified_type (type, cp_type_quals (type) & ~TYPE_QUAL_CONST));\n \n   data_addr = fold_convert (non_const_pointer_type, data_addr);\n   /* Any further uses of alloc_node will want this type, too.  */"}, {"sha": "707df8b899d728360a6e1298fff957bf15cc4a30", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3360e778c64ee78b08272b4474d0d707061a1c1/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3360e778c64ee78b08272b4474d0d707061a1c1/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=a3360e778c64ee78b08272b4474d0d707061a1c1", "patch": "@@ -1975,18 +1975,19 @@ write_CV_qualifiers_for_type (const tree type)\n      Note that we do not use cp_type_quals below; given \"const\n      int[3]\", the \"const\" is emitted with the \"int\", not with the\n      array.  */\n+  cp_cv_quals quals = TYPE_QUALS (type);\n \n-  if (TYPE_QUALS (type) & TYPE_QUAL_RESTRICT)\n+  if (quals & TYPE_QUAL_RESTRICT)\n     {\n       write_char ('r');\n       ++num_qualifiers;\n     }\n-  if (TYPE_QUALS (type) & TYPE_QUAL_VOLATILE)\n+  if (quals & TYPE_QUAL_VOLATILE)\n     {\n       write_char ('V');\n       ++num_qualifiers;\n     }\n-  if (TYPE_QUALS (type) & TYPE_QUAL_CONST)\n+  if (quals & TYPE_QUAL_CONST)\n     {\n       write_char ('K');\n       ++num_qualifiers;"}, {"sha": "43b84dd77e5700428c0867e59b0fe36a67f3cf23", "filename": "gcc/cp/method.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3360e778c64ee78b08272b4474d0d707061a1c1/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3360e778c64ee78b08272b4474d0d707061a1c1/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=a3360e778c64ee78b08272b4474d0d707061a1c1", "patch": "@@ -494,7 +494,7 @@ do_build_copy_constructor (tree fndecl)\n \n \t      if (DECL_MUTABLE_P (field))\n \t\tquals &= ~TYPE_QUAL_CONST;\n-\t      quals |= TYPE_QUALS (expr_type);\n+\t      quals |= cp_type_quals (expr_type);\n \t      expr_type = cp_build_qualified_type (expr_type, quals);\n \t    }\n \n@@ -934,7 +934,7 @@ implicitly_declare_fn (special_function_kind kind, tree type, bool const_p)\n       if (const_p)\n \t{\n \t  data.quals = TYPE_QUAL_CONST;\n-\t  rhs_parm_type = build_qualified_type (type, TYPE_QUAL_CONST);\n+\t  rhs_parm_type = cp_build_qualified_type (type, TYPE_QUAL_CONST);\n \t}\n       else\n \trhs_parm_type = type;"}, {"sha": "85bf1fd071e0eea2b7fdbfe757430a2b5895a5e3", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3360e778c64ee78b08272b4474d0d707061a1c1/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3360e778c64ee78b08272b4474d0d707061a1c1/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=a3360e778c64ee78b08272b4474d0d707061a1c1", "patch": "@@ -8760,7 +8760,7 @@ tsubst_aggr_type (tree t,\n \t    {\n \t      r = lookup_template_class (t, argvec, in_decl, context,\n \t\t\t\t\t entering_scope, complain);\n-\t      r = cp_build_qualified_type_real (r, TYPE_QUALS (t), complain);\n+\t      r = cp_build_qualified_type_real (r, cp_type_quals (t), complain);\n \t    }\n \n \t  cp_unevaluated_operand = saved_unevaluated_operand;\n@@ -10141,7 +10141,7 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t\t\t\t\t    /*entering_scope=*/0,\n \t\t\t\t\t   complain);\n \t\treturn cp_build_qualified_type_real\n-\t\t  (r, TYPE_QUALS (t), complain);\n+\t\t  (r, cp_type_quals (t), complain);\n \t      }\n \t    else\n \t      /* TEMPLATE_TEMPLATE_PARM or TEMPLATE_PARM_INDEX.  */\n@@ -10331,7 +10331,7 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t       TYPE_REF_IS_RVALUE (t) && TYPE_REF_IS_RVALUE (type));\n \telse\n \t  r = cp_build_reference_type (type, TYPE_REF_IS_RVALUE (t));\n-\tr = cp_build_qualified_type_real (r, TYPE_QUALS (t), complain);\n+\tr = cp_build_qualified_type_real (r, cp_type_quals (t), complain);\n \n \tif (r != error_mark_node)\n \t  /* Will this ever be needed for TYPE_..._TO values?  */\n@@ -10380,7 +10380,7 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t  }\n \telse\n \t  return cp_build_qualified_type_real (build_ptrmem_type (r, type),\n-\t\t\t\t\t       TYPE_QUALS (t),\n+\t\t\t\t\t       cp_type_quals (t),\n \t\t\t\t\t       complain);\n       }\n     case FUNCTION_TYPE:"}, {"sha": "9d300d7f6eeda82325a225646d339577c8cbab60", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3360e778c64ee78b08272b4474d0d707061a1c1/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3360e778c64ee78b08272b4474d0d707061a1c1/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=a3360e778c64ee78b08272b4474d0d707061a1c1", "patch": "@@ -155,7 +155,7 @@ init_rtti_processing (void)\n \t\t\t     /*tag_scope=*/ts_current, false);\n   pop_namespace ();\n   const_type_info_type_node\n-    = build_qualified_type (type_info_type, TYPE_QUAL_CONST);\n+    = cp_build_qualified_type (type_info_type, TYPE_QUAL_CONST);\n   type_info_ptr_type = build_pointer_type (const_type_info_type_node);\n \n   unemitted_tinfo_decls = VEC_alloc (tree, gc, 124);\n@@ -192,8 +192,8 @@ build_headof (tree exp)\n                                                   tf_warning_or_error), \n                            index);\n \n-  type = build_qualified_type (ptr_type_node,\n-\t\t\t       cp_type_quals (TREE_TYPE (exp)));\n+  type = cp_build_qualified_type (ptr_type_node,\n+\t\t\t\t  cp_type_quals (TREE_TYPE (exp)));\n   return build2 (POINTER_PLUS_EXPR, type, exp,\n \t\t convert_to_integer (sizetype, offset));\n }\n@@ -726,7 +726,7 @@ build_dynamic_cast_1 (tree type, tree expr, tsubst_flags_t complain)\n \t\t\t\t    /*tag_scope=*/ts_current, false);\n \n \t      tinfo_ptr = build_pointer_type\n-\t\t(build_qualified_type\n+\t\t(cp_build_qualified_type\n \t\t (tinfo_ptr, TYPE_QUAL_CONST));\n \t      name = \"__dynamic_cast\";\n \t      tmp = tree_cons\n@@ -871,7 +871,7 @@ tinfo_base_init (tinfo_s *ti, tree target)\n \n     /* Generate the NTBS array variable.  */\n     tree name_type = build_cplus_array_type\n-\t\t     (build_qualified_type (char_type_node, TYPE_QUAL_CONST),\n+\t\t     (cp_build_qualified_type (char_type_node, TYPE_QUAL_CONST),\n \t\t     NULL_TREE);\n \n     /* Determine the name of the variable -- and remember with which\n@@ -1495,8 +1495,8 @@ emit_support_tinfos (void)\n \n       types[0] = bltn;\n       types[1] = build_pointer_type (bltn);\n-      types[2] = build_pointer_type (build_qualified_type (bltn,\n-\t\t\t\t\t\t\t   TYPE_QUAL_CONST));\n+      types[2] = build_pointer_type (cp_build_qualified_type (bltn,\n+\t\t\t\t\t\t\t      TYPE_QUAL_CONST));\n \n       for (i = 0; i < 3; ++i)\n \t{"}, {"sha": "173ef9616707dc3e0bcb71bd9fe2dcc8a4e89ba3", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3360e778c64ee78b08272b4474d0d707061a1c1/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3360e778c64ee78b08272b4474d0d707061a1c1/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=a3360e778c64ee78b08272b4474d0d707061a1c1", "patch": "@@ -2212,7 +2212,7 @@ finish_compound_literal (tree type, tree compound_literal)\n   if (TREE_CODE (type) == ARRAY_TYPE)\n     cp_complete_array_type (&type, compound_literal, false);\n   compound_literal = digest_init (type, compound_literal);\n-  if ((!at_function_scope_p () || cp_type_readonly (type))\n+  if ((!at_function_scope_p () || CP_TYPE_CONST_P (type))\n       && initializer_constant_valid_p (compound_literal, type))\n     {\n       tree decl = create_temporary_var (type);\n@@ -5629,7 +5629,7 @@ capture_decltype (tree decl)\n   if (TREE_CODE (type) != REFERENCE_TYPE)\n     {\n       if (!LAMBDA_EXPR_MUTABLE_P (lam))\n-\ttype = cp_build_qualified_type (type, (TYPE_QUALS (type)\n+\ttype = cp_build_qualified_type (type, (cp_type_quals (type)\n \t\t\t\t\t       |TYPE_QUAL_CONST));\n       type = build_reference_type (type);\n     }"}, {"sha": "d3bba4c1e5196e49afa8d74e7b0c93876090e2db", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3360e778c64ee78b08272b4474d0d707061a1c1/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3360e778c64ee78b08272b4474d0d707061a1c1/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=a3360e778c64ee78b08272b4474d0d707061a1c1", "patch": "@@ -940,7 +940,7 @@ cv_unqualified (tree type)\n   if (type == error_mark_node)\n     return type;\n \n-  quals = TYPE_QUALS (type);\n+  quals = cp_type_quals (type);\n   quals &= ~(TYPE_QUAL_CONST|TYPE_QUAL_VOLATILE);\n   return cp_build_qualified_type (type, quals);\n }"}, {"sha": "54ccbfe49f1a96f6a0d97651cc8a36dedf58ad3b", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3360e778c64ee78b08272b4474d0d707061a1c1/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3360e778c64ee78b08272b4474d0d707061a1c1/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=a3360e778c64ee78b08272b4474d0d707061a1c1", "patch": "@@ -633,10 +633,10 @@ composite_pointer_type (tree t1, tree t2, tree arg1, tree arg2,\n \n       if (DERIVED_FROM_P (class1, class2))\n \tt2 = (build_pointer_type\n-\t      (cp_build_qualified_type (class1, TYPE_QUALS (class2))));\n+\t      (cp_build_qualified_type (class1, cp_type_quals (class2))));\n       else if (DERIVED_FROM_P (class2, class1))\n \tt1 = (build_pointer_type\n-\t      (cp_build_qualified_type (class2, TYPE_QUALS (class1))));\n+\t      (cp_build_qualified_type (class2, cp_type_quals (class1))));\n       else\n         {\n           if (complain & tf_error)\n@@ -1250,7 +1250,10 @@ structural_comptypes (tree t1, tree t2, int strict)\n   /* Qualifiers must match.  For array types, we will check when we\n      recur on the array element types.  */\n   if (TREE_CODE (t1) != ARRAY_TYPE\n-      && TYPE_QUALS (t1) != TYPE_QUALS (t2))\n+      && cp_type_quals (t1) != cp_type_quals (t2))\n+    return false;\n+  if (TREE_CODE (t1) == FUNCTION_TYPE\n+      && type_memfn_quals (t1) != type_memfn_quals (t2))\n     return false;\n   if (TYPE_FOR_JAVA (t1) != TYPE_FOR_JAVA (t2))\n     return false;\n@@ -2032,7 +2035,7 @@ string_conv_p (const_tree totype, const_tree exp, int warn)\n   else\n     {\n       /* Is this a string constant which has decayed to 'const char *'?  */\n-      t = build_pointer_type (build_qualified_type (t, TYPE_QUAL_CONST));\n+      t = build_pointer_type (cp_build_qualified_type (t, TYPE_QUAL_CONST));\n       if (!same_type_p (TREE_TYPE (exp), t))\n \treturn 0;\n       STRIP_NOPS (exp);\n@@ -7642,7 +7645,7 @@ check_return_expr (tree retval, bool *no_warning)\n       if ((cxx_dialect != cxx98) \n           && named_return_value_okay_p\n           /* The variable must not have the `volatile' qualifier.  */\n-\t  && !(cp_type_quals (TREE_TYPE (retval)) & TYPE_QUAL_VOLATILE)\n+\t  && !CP_TYPE_VOLATILE_P (TREE_TYPE (retval))\n \t  /* The return type must be a class type.  */\n \t  && CLASS_TYPE_P (TREE_TYPE (TREE_TYPE (current_function_decl))))\n \tflags = flags | LOOKUP_PREFER_RVALUE;\n@@ -7902,17 +7905,6 @@ apply_memfn_quals (tree type, cp_cv_quals memfn_quals)\n   return build_qualified_type (type, memfn_quals);\n }\n \n-/* Returns nonzero if the TYPE is const from a C++ perspective: look inside\n-   arrays.  */\n-\n-bool\n-cp_type_readonly (const_tree type)\n-{\n-  /* This CONST_CAST is okay because strip_array_types returns its\n-     argument unmodified and we assign it to a const_tree.  */\n-  return (cp_type_quals (type) & TYPE_QUAL_CONST) != 0;\n-}\n-\n /* Returns nonzero if TYPE is const or volatile.  */\n \n bool"}]}