{"sha": "4f1d8bd5096cc234313b23f64cdac53a94ff75a2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGYxZDhiZDUwOTZjYzIzNDMxM2IyM2Y2NGNkYWM1M2E5NGZmNzVhMg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-12-10T19:33:35Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-12-10T19:33:35Z"}, "message": "c++: modules & using-decls\n\nThis extends using-decls to modules.  In modules you can export a\nusing decl, but the exported decl must have external linkage already.\nOne thing you can do is export something from the GMF.\n\nThe novel thing is that now 'export using foo::bar;' *in namespace\nbar* can mean something significant (rather than be an obscure nop).\n\n\tgcc/cp/\n\t* name-lookup.c (do_nonmember_using_decl): Add INSERT_P parm.\n\tDeal with exporting using decls.\n\t(finish_nonmember_using_decl): Examine BINDING_VECTOR.", "tree": {"sha": "3610b7e2e5f001305053c2cf63306ddf8077fc59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3610b7e2e5f001305053c2cf63306ddf8077fc59"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4f1d8bd5096cc234313b23f64cdac53a94ff75a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f1d8bd5096cc234313b23f64cdac53a94ff75a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f1d8bd5096cc234313b23f64cdac53a94ff75a2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f1d8bd5096cc234313b23f64cdac53a94ff75a2/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0979d8f22a97eb231ebf544c512353372bdb25d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0979d8f22a97eb231ebf544c512353372bdb25d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0979d8f22a97eb231ebf544c512353372bdb25d"}], "stats": {"total": 176, "additions": 149, "deletions": 27}, "files": [{"sha": "7dd4efa0a853f58301aebced10693464128f2e2a", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 149, "deletions": 27, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f1d8bd5096cc234313b23f64cdac53a94ff75a2/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f1d8bd5096cc234313b23f64cdac53a94ff75a2/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=4f1d8bd5096cc234313b23f64cdac53a94ff75a2", "patch": "@@ -4567,7 +4567,7 @@ pushdecl_outermost_localscope (tree x)\n \n static bool\n do_nonmember_using_decl (name_lookup &lookup, bool fn_scope_p,\n-\t\t\t tree *value_p, tree *type_p)\n+\t\t\t bool insert_p, tree *value_p, tree *type_p)\n {\n   tree value = *value_p;\n   tree type = *type_p;\n@@ -4587,20 +4587,44 @@ do_nonmember_using_decl (name_lookup &lookup, bool fn_scope_p,\n       lookup.value = NULL_TREE;\n     }\n \n+  /* Only process exporting if we're going to be inserting.  */\n+  bool revealing_p = insert_p && !fn_scope_p && module_has_cmi_p ();\n+\n+  /* First do the value binding.  */\n   if (!lookup.value)\n-    /* Nothing.  */;\n+    /* Nothing (only implicit typedef found).  */\n+    gcc_checking_assert (lookup.type);\n   else if (OVL_P (lookup.value) && (!value || OVL_P (value)))\n     {\n       for (lkp_iterator usings (lookup.value); usings; ++usings)\n \t{\n \t  tree new_fn = *usings;\n+\t  bool exporting = revealing_p && module_exporting_p ();\n+\t  if (exporting)\n+\t    {\n+\t      /* If the using decl is exported, the things it refers\n+\t\t to must also be exported (or not in module purview).  */\n+\t      if (!DECL_MODULE_EXPORT_P (new_fn)\n+\t\t  && (DECL_LANG_SPECIFIC (new_fn)\n+\t\t      && DECL_MODULE_PURVIEW_P (new_fn)))\n+\t\t{\n+\t\t  error (\"%q#D does not have external linkage\", new_fn);\n+\t\t  inform (DECL_SOURCE_LOCATION (new_fn),\n+\t\t\t  \"%q#D declared here\", new_fn);\n+\t\t  exporting = false;\n+\t\t}\n+\t    }\n \n \t  /* [namespace.udecl]\n \n \t     If a function declaration in namespace scope or block\n \t     scope has the same name and the same parameter types as a\n \t     function introduced by a using declaration the program is\n \t     ill-formed.  */\n+\t  /* This seems overreaching, asking core -- why do we care\n+\t     about decls in the namespace that we cannot name (because\n+\t     they are not transitively imported.  We just check the\n+\t     decls that are in this TU.  */\n \t  bool found = false;\n \t  for (ovl_iterator old (value); !found && old; ++old)\n \t    {\n@@ -4609,8 +4633,25 @@ do_nonmember_using_decl (name_lookup &lookup, bool fn_scope_p,\n \t      if (new_fn == old_fn)\n \t\t{\n \t\t  /* The function already exists in the current\n-\t\t     namespace.  */\n+\t\t     namespace.  We will still want to insert it if\n+\t\t     it is revealing a not-revealed thing.  */\n \t\t  found = true;\n+\t\t  if (!revealing_p)\n+\t\t    ;\n+\t\t  else if (old.using_p ())\n+\t\t    {\n+\t\t      if (exporting)\n+\t\t\t/* Update in place.  'tis ok.  */\n+\t\t\tOVL_EXPORT_P (old.get_using ()) = true;\n+\t\t      ;\n+\t\t    }\n+\t\t  else if (DECL_MODULE_EXPORT_P (new_fn))\n+\t\t    ;\n+\t\t  else\n+\t\t    {\n+\t\t      value = old.remove_node (value);\n+\t\t      found = false;\n+\t\t    }\n \t\t  break;\n \t\t}\n \t      else if (old.using_p ())\n@@ -4634,11 +4675,11 @@ do_nonmember_using_decl (name_lookup &lookup, bool fn_scope_p,\n \t\t}\n \t    }\n \n-\t  if (!found)\n+\t  if (!found && insert_p)\n \t    /* Unlike the decl-pushing case we don't drop anticipated\n \t       builtins here.  They don't cause a problem, and we'd\n \t       like to match them with a future declaration.  */\n-\t    value = ovl_insert (new_fn, value, true);\n+\t    value = ovl_insert (new_fn, value, 1 + exporting);\n \t}\n     }\n   else if (value\n@@ -4649,28 +4690,34 @@ do_nonmember_using_decl (name_lookup &lookup, bool fn_scope_p,\n       diagnose_name_conflict (lookup.value, value);\n       failed = true;\n     }\n-  else\n+  else if (insert_p)\n+    // FIXME:what if we're newly exporting lookup.value\n     value = lookup.value;\n-\n+  \n+  /* Now the type binding.  */\n   if (lookup.type && lookup.type != type)\n     {\n+      // FIXME: What if we're exporting lookup.type?\n       if (type && !decls_match (lookup.type, type))\n \t{\n \t  diagnose_name_conflict (lookup.type, type);\n \t  failed = true;\n \t}\n-      else\n+      else if (insert_p)\n \ttype = lookup.type;\n     }\n \n-  /* If value is empty, shift any class or enumeration name back.  */\n-  if (!value)\n+  if (insert_p)\n     {\n-      value = type;\n-      type = NULL_TREE;\n+      /* If value is empty, shift any class or enumeration name back.  */\n+      if (!value)\n+\t{\n+\t  value = type;\n+\t  type = NULL_TREE;\n+\t}\n+      *value_p = value;\n+      *type_p = type;\n     }\n-  *value_p = value;\n-  *type_p = type;\n \n   return failed;\n }\n@@ -5506,8 +5553,10 @@ do_class_using_decl (tree scope, tree name)\n }\n \n \f\n-/* Return the binding for NAME in NS.  If NS is NULL, look in\n-   global_namespace.  */\n+/* Return the binding for NAME in NS in the current TU.  If NS is\n+   NULL, look in global_namespace.  We will not find declarations\n+   from imports.  Users of this who, having found nothing, push a new\n+   decl must be prepared for that pushing to match an existing decl.  */\n \n tree\n get_namespace_binding (tree ns, tree name)\n@@ -5908,21 +5957,94 @@ finish_nonmember_using_decl (tree scope, tree name)\n   if (current_binding_level->kind == sk_namespace)\n     {\n       tree *slot = find_namespace_slot (current_namespace, name, true);\n+      tree *mslot = get_fixed_binding_slot (slot, name,\n+\t\t\t\t\t    BINDING_SLOT_CURRENT, true);\n+      bool failed = false;\n \n-      tree value = MAYBE_STAT_DECL (*slot);\n-      tree type = MAYBE_STAT_TYPE (*slot);\n+      if (mslot != slot)\n+\t{\n+\t  /* A module vector.  I presume the binding list is going to\n+\t     be sparser than the import bitmap.  Hence iterate over\n+\t     the former checking for bits set in the bitmap.  */\n+\t  bitmap imports = get_import_bitmap ();\n+\t  binding_cluster *cluster = BINDING_VECTOR_CLUSTER_BASE (*slot);\n \n-      do_nonmember_using_decl (lookup, false, &value, &type);\n+\t  /* Scan the imported bindings.  */\n+\t  unsigned ix = BINDING_VECTOR_NUM_CLUSTERS (*slot);\n+\t  if (BINDING_VECTOR_SLOTS_PER_CLUSTER == BINDING_SLOTS_FIXED)\n+\t    {\n+\t      ix--;\n+\t      cluster++;\n+\t    }\n \n-      if (STAT_HACK_P (*slot))\n+\t  /* Do this in forward order, so we load modules in an order\n+\t     the user expects.  */\n+\t  for (; ix--; cluster++)\n+\t    for (unsigned jx = 0; jx != BINDING_VECTOR_SLOTS_PER_CLUSTER; jx++)\n+\t      {\n+\t\t/* Are we importing this module?  */\n+\t\tif (unsigned base = cluster->indices[jx].base)\n+\t\t  if (unsigned span = cluster->indices[jx].span)\n+\t\t    do\n+\t\t      if (bitmap_bit_p (imports, base))\n+\t\t\tgoto found;\n+\t\t    while (++base, --span);\n+\t\tcontinue;\n+\n+\t      found:;\n+\t\t/* Is it loaded?  */\n+\t\tif (cluster->slots[jx].is_lazy ())\n+\t\t  {\n+\t\t    gcc_assert (cluster->indices[jx].span == 1);\n+\t\t    lazy_load_binding (cluster->indices[jx].base,\n+\t\t\t\t       scope, name, &cluster->slots[jx]);\n+\t\t  }\n+\n+\t\ttree value = cluster->slots[jx];\n+\t\tif (!value)\n+\t\t  /* Load errors could mean there's nothing here.  */\n+\t\t  continue;\n+\n+\t\t/* Extract what we can see from here.  If there's no\n+\t\t   stat_hack, then everything was exported.  */\n+\t\ttree type = NULL_TREE;\n+\n+\t\t/* If no stat hack, everything is visible.  */\n+\t\tif (STAT_HACK_P (value))\n+\t\t  {\n+\t\t    if (STAT_TYPE_VISIBLE_P (value))\n+\t\t      type = STAT_TYPE (value);\n+\t\t    value = STAT_VISIBLE (value);\n+\t\t  }\n+\n+\t\tif (do_nonmember_using_decl (lookup, false, false,\n+\t\t\t\t\t     &value, &type))\n+\t\t  {\n+\t\t    failed = true;\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t}\n+\n+      if (!failed)\n \t{\n-\t  STAT_DECL (*slot) = value;\n-\t  STAT_TYPE (*slot) = type;\n+\t  /* Now do the current slot.  */\n+\t  tree value = MAYBE_STAT_DECL (*mslot);\n+\t  tree type = MAYBE_STAT_TYPE (*mslot);\n+\n+\t  do_nonmember_using_decl (lookup, false, true, &value, &type);\n+\n+\t  // FIXME: Partition mergeableness?\n+\t  if (STAT_HACK_P (*mslot))\n+\t    {\n+\t      STAT_DECL (*mslot) = value;\n+\t      STAT_TYPE (*mslot) = type;\n+\t    }\n+\t  else if (type)\n+\t    *mslot = stat_hack (value, type);\n+\t  else\n+\t    *mslot = value;\n \t}\n-      else if (type)\n-\t*slot = stat_hack (value, type);\n-      else\n-\t*slot = value;\n     }\n   else\n     {\n@@ -5940,7 +6062,7 @@ finish_nonmember_using_decl (tree scope, tree name)\n       /* DR 36 questions why using-decls at function scope may not be\n \t duplicates.  Disallow it, as C++11 claimed and PR 20420\n \t implemented.  */\n-      do_nonmember_using_decl (lookup, true, &value, &type);\n+      do_nonmember_using_decl (lookup, true, true, &value, &type);\n \n       if (!value)\n \t;"}]}