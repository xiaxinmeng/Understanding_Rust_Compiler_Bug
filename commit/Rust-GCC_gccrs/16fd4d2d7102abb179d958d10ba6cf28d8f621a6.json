{"sha": "16fd4d2d7102abb179d958d10ba6cf28d8f621a6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTZmZDRkMmQ3MTAyYWJiMTc5ZDk1OGQxMGJhNmNmMjhkOGY2MjFhNg==", "commit": {"author": {"name": "Manuel L\u00f3pez-Ib\u00e1\u00f1ez", "email": "manu@gcc.gnu.org", "date": "2007-01-07T23:39:55Z"}, "committer": {"name": "Manuel L\u00f3pez-Ib\u00e1\u00f1ez", "email": "manu@gcc.gnu.org", "date": "2007-01-07T23:39:55Z"}, "message": "re PR c++/28986 (Failure to diagnose overflow in constant expression)\n\n2007-01-07  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n\n\tPR c++/28986\ncp/\n\t* typeck.c (build_binary_op): Call overflow_warning if\n\tTREE_OVERFLOW_P is true for the result and not for any of the\n\toperands.\n\ntestsuite/\n\t* g++.dg/conversion/nullptr1.C: Added overflow warning.\n\t* g++.dg/warn/overflow-warn-1.C: New.\n\t* g++.dg/warn/overflow-warn-3.C: New.\n\t* g++.dg/warn/overflow-warn-4.C: New.\n\t* g++.dg/warn/overflow-warn-5.C: New.\n\t* g++.dg/warn/overflow-warn-6.C: New.\n\t* g++.dg/warn/Woverflow-1.C: New.\n\t* g++.dg/warn/Woverflow-2.C: New.\n\t* g++.dg/warn/Woverflow-3.C: New.\n\t* g++.dg/warn/multiple-overflow-warn-2.C: New.\n\nFrom-SVN: r120558", "tree": {"sha": "07b723f57f7162726fedfa539303bb8ba68f2b28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/07b723f57f7162726fedfa539303bb8ba68f2b28"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/16fd4d2d7102abb179d958d10ba6cf28d8f621a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16fd4d2d7102abb179d958d10ba6cf28d8f621a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16fd4d2d7102abb179d958d10ba6cf28d8f621a6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16fd4d2d7102abb179d958d10ba6cf28d8f621a6/comments", "author": null, "committer": null, "parents": [{"sha": "636dff67dd28fc952990b83580ffd96f6508a338", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/636dff67dd28fc952990b83580ffd96f6508a338", "html_url": "https://github.com/Rust-GCC/gccrs/commit/636dff67dd28fc952990b83580ffd96f6508a338"}], "stats": {"total": 1348, "additions": 1347, "deletions": 1}, "files": [{"sha": "0e7898a7de573feed456a407da187fa1748133e5", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16fd4d2d7102abb179d958d10ba6cf28d8f621a6/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16fd4d2d7102abb179d958d10ba6cf28d8f621a6/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=16fd4d2d7102abb179d958d10ba6cf28d8f621a6", "patch": "@@ -1,3 +1,10 @@\n+2007-01-07  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n+\n+\tPR c++/28986\n+\t* typeck.c (build_binary_op): Call overflow_warning if\n+\tTREE_OVERFLOW_P is true for the result and not for any of the\n+\toperands.\n+\t\n 2007-01-06  Lee Millward  <lee.millward@codesourcery.com>\n \n        PR c++/19439"}, {"sha": "2a6c8f8880264347500e8280a81e54b2abdfd2f4", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16fd4d2d7102abb179d958d10ba6cf28d8f621a6/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16fd4d2d7102abb179d958d10ba6cf28d8f621a6/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=16fd4d2d7102abb179d958d10ba6cf28d8f621a6", "patch": "@@ -3870,6 +3870,12 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n   result = fold_if_not_in_template (result);\n   if (final_type != 0)\n     result = cp_convert (final_type, result);\n+\n+  if (TREE_OVERFLOW_P (result) \n+      && !TREE_OVERFLOW_P (op0) \n+      && !TREE_OVERFLOW_P (op1))\n+    overflow_warning (result);\n+\n   return result;\n }\n \f"}, {"sha": "a42328a59070c70586c2f0352334ec108e33610d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16fd4d2d7102abb179d958d10ba6cf28d8f621a6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16fd4d2d7102abb179d958d10ba6cf28d8f621a6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=16fd4d2d7102abb179d958d10ba6cf28d8f621a6", "patch": "@@ -1,3 +1,17 @@\n+2007-01-07  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n+\n+\tPR c++/28986\n+\t* g++.dg/conversion/nullptr1.C: Added overflow warning.\n+\t* g++.dg/warn/overflow-warn-1.C: New.\n+\t* g++.dg/warn/overflow-warn-3.C: New.\n+\t* g++.dg/warn/overflow-warn-4.C: New.\n+\t* g++.dg/warn/overflow-warn-5.C: New.\n+\t* g++.dg/warn/overflow-warn-6.C: New.\n+\t* g++.dg/warn/Woverflow-1.C: New.\n+\t* g++.dg/warn/Woverflow-2.C: New.\n+\t* g++.dg/warn/Woverflow-3.C: New.\n+\t* g++.dg/warn/multiple-overflow-warn-2.C: New.\n+\t\n 2007-01-07  Bernhard Fischer  <aldot@gcc.gnu.org>\n \n \tPR fortran/27698"}, {"sha": "5e9767a00ee38090a3870b1ac66ca6b0e8a87f77", "filename": "gcc/testsuite/g++.dg/conversion/nullptr1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16fd4d2d7102abb179d958d10ba6cf28d8f621a6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fnullptr1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16fd4d2d7102abb179d958d10ba6cf28d8f621a6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fnullptr1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fnullptr1.C?ref=16fd4d2d7102abb179d958d10ba6cf28d8f621a6", "patch": "@@ -6,5 +6,5 @@\n void *p = 0;\n \n void *q = 0 * (INT_MAX + 1);  // { dg-error \"invalid conversion\" }\n-\n+// { dg-warning \"integer overflow in expression\" \"\" { target *-*-* } 8 }\n "}, {"sha": "66750472e7493f855fbbe4080958957ee302b4eb", "filename": "gcc/testsuite/g++.dg/warn/Woverflow-1.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16fd4d2d7102abb179d958d10ba6cf28d8f621a6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWoverflow-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16fd4d2d7102abb179d958d10ba6cf28d8f621a6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWoverflow-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWoverflow-1.C?ref=16fd4d2d7102abb179d958d10ba6cf28d8f621a6", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <limits.h>\n+\n+int foo = INT_MAX + 1;  /* { dg-warning \"integer overflow\" } */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <limits.h>\n+\n+int foo = INT_MAX + 1;  /* { dg-warning \"integer overflow\" } */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <limits.h>\n+\n+int foo = INT_MAX + 1;  /* { dg-warning \"integer overflow\" } */\n+"}, {"sha": "392a5ee3e5ae5c2f8216c0838d068b0a34339338", "filename": "gcc/testsuite/g++.dg/warn/Woverflow-2.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16fd4d2d7102abb179d958d10ba6cf28d8f621a6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWoverflow-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16fd4d2d7102abb179d958d10ba6cf28d8f621a6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWoverflow-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWoverflow-2.C?ref=16fd4d2d7102abb179d958d10ba6cf28d8f621a6", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Woverflow\" } */\n+\n+#include <limits.h>\n+\n+int foo = INT_MAX + 1;  /* { dg-warning \"integer overflow\" } */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Woverflow\" } */\n+\n+#include <limits.h>\n+\n+int foo = INT_MAX + 1;  /* { dg-warning \"integer overflow\" } */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Woverflow\" } */\n+\n+#include <limits.h>\n+\n+int foo = INT_MAX + 1;  /* { dg-warning \"integer overflow\" } */\n+"}, {"sha": "d3b8afad41683e9b11a56b40c4ec4415a52dab77", "filename": "gcc/testsuite/g++.dg/warn/Woverflow-3.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16fd4d2d7102abb179d958d10ba6cf28d8f621a6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWoverflow-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16fd4d2d7102abb179d958d10ba6cf28d8f621a6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWoverflow-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWoverflow-3.C?ref=16fd4d2d7102abb179d958d10ba6cf28d8f621a6", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Wno-overflow\" } */\n+\n+#include <limits.h>\n+\n+int foo = INT_MAX + 1;\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Wno-overflow\" } */\n+\n+#include <limits.h>\n+\n+int foo = INT_MAX + 1;\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Wno-overflow\" } */\n+\n+#include <limits.h>\n+\n+int foo = INT_MAX + 1;\n+"}, {"sha": "aa7f40bc7933713f2a282636e7a24f36781a6e01", "filename": "gcc/testsuite/g++.dg/warn/multiple-overflow-warn-2.C", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16fd4d2d7102abb179d958d10ba6cf28d8f621a6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fmultiple-overflow-warn-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16fd4d2d7102abb179d958d10ba6cf28d8f621a6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fmultiple-overflow-warn-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fmultiple-overflow-warn-2.C?ref=16fd4d2d7102abb179d958d10ba6cf28d8f621a6", "patch": "@@ -0,0 +1,36 @@\n+/* PR c/19978 : Test for duplicated warnings (binary operators).  */\n+/* { dg-do compile } */\n+/* { dg-options \"-Woverflow\" } */\n+\n+#include <limits.h>\n+\n+int \n+g1 (void)\n+{\n+  return INT_MAX + 1 - INT_MAX; /* { dg-bogus \"integer overflow in expression.*integer overflow in expression\" } */\n+  /* { dg-warning \"integer overflow in expression\" \"\" { target *-*-* } 10 } */\n+}\n+/* PR c/19978 : Test for duplicated warnings (binary operators).  */\n+/* { dg-do compile } */\n+/* { dg-options \"-Woverflow\" } */\n+\n+#include <limits.h>\n+\n+int \n+g1 (void)\n+{\n+  return INT_MAX + 1 - INT_MAX; /* { dg-bogus \"integer overflow in expression.*integer overflow in expression\" } */\n+  /* { dg-warning \"integer overflow in expression\" \"\" { target *-*-* } 10 } */\n+}\n+/* PR c/19978 : Test for duplicated warnings (binary operators).  */\n+/* { dg-do compile } */\n+/* { dg-options \"-Woverflow\" } */\n+\n+#include <limits.h>\n+\n+int \n+g1 (void)\n+{\n+  return INT_MAX + 1 - INT_MAX; /* { dg-bogus \"integer overflow in expression.*integer overflow in expression\" } */\n+  /* { dg-warning \"integer overflow in expression\" \"\" { target *-*-* } 10 } */\n+}"}, {"sha": "d87774f136ad29e117b80b45a653623299666834", "filename": "gcc/testsuite/g++.dg/warn/overflow-warn-1.C", "status": "added", "additions": 369, "deletions": 0, "changes": 369, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16fd4d2d7102abb179d958d10ba6cf28d8f621a6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Foverflow-warn-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16fd4d2d7102abb179d958d10ba6cf28d8f621a6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Foverflow-warn-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Foverflow-warn-1.C?ref=16fd4d2d7102abb179d958d10ba6cf28d8f621a6", "patch": "@@ -0,0 +1,369 @@\n+/* Test for diagnostics for constant overflow.  */\n+/* Origin: Joseph Myers <joseph@codesourcery.com> */\n+/* { dg-do compile } */\n+/* { dg-options \"\" } */\n+\n+#include <limits.h>\n+\n+enum e {\n+  E0 = INT_MAX,\n+  /* Unsigned overflow wraps around.  */\n+  E1 = UINT_MAX + 1,\n+  /* Overflow in an unevaluated part of an expression is OK (example\n+     in the standard).  */\n+  E2 = 2 || 1 / 0, /* { dg-bogus \"warning: division by zero\" \"\" { xfail *-*-* } 14 } */\n+  E3 = 1 / 0, /* { dg-warning \"warning: division by zero\" } */\n+  /* { dg-error \"error: enumerator value for 'E3' is not an integer constant\" \"enum error\" { target *-*-* } 15 } */\n+  /* But as in DR#031, the 1/0 in an evaluated subexpression means the\n+     whole expression violates the constraints.  */\n+  E4 = 0 * (1 / 0), /* { dg-warning \"warning: division by zero\" } */\n+  /* { dg-error \"error: enumerator value for 'E4' is not an integer constant\" \"enum error\" { xfail *-*-* } 19 } */\n+  E5 = INT_MAX + 1, /* { dg-warning \"warning: integer overflow in expression\" } */\n+  /* Again, overflow in evaluated subexpression.  */\n+  E6 = 0 * (INT_MAX + 1), /* { dg-warning \"warning: integer overflow in expression\" } */\n+  /* A cast does not constitute overflow in conversion.  */\n+  E7 = (char) INT_MAX\n+};\n+\n+struct s {\n+  int a;\n+  int : 0 * (1 / 0); /* { dg-warning \"warning: division by zero\" } */\n+  int : 0 * (INT_MAX + 1); /* { dg-warning \"warning: integer overflow in expression\" } */\n+};\n+\n+void\n+f (void)\n+{\n+  /* This expression is not required to be a constant expression, so\n+     it should just involve undefined behavior at runtime.  */\n+  int c = INT_MAX + 1; /* { dg-warning \"warning: integer overflow in expression\" } */\n+}\n+\n+/* This expression is neither required to be constant.  */\n+static int sc = INT_MAX + 1; /* { dg-warning \"warning: integer overflow in expression\" } */\n+\n+\n+// Test for overflow in null pointer constant.  \n+void *n = 0;\n+/* The first two of these involve overflow, so are not null pointer\n+   constants.  The third has the overflow in an unevaluated\n+   subexpression, so is a null pointer constant.  */\n+void *p = 0 * (INT_MAX + 1); /* { dg-warning \"warning: integer overflow in expression\" } */\n+/* { dg-error \"invalid conversion from 'int' to 'void\" \"null\" { target *-*-* } 51 } */\n+void *q = 0 * (1 / 0); /* { dg-warning \"warning: division by zero\" } */\n+/* { dg-error \"invalid conversion from 'int' to 'void*'\" \"null\" { xfail *-*-* } 53 } */\n+void *r = (1 ? 0 : INT_MAX+1); /* { dg-bogus \"integer overflow in expression\" \"\" { xfail *-*-* } 55 } */\n+\n+void\n+g (int i)\n+{\n+  switch (i)\n+    {\n+    case 0 * (1/0): /* { dg-warning \"warning: division by zero\" } */\n+      ;\n+    case 1 + 0 * (INT_MAX + 1): /* { dg-warning \"warning: integer overflow in expression\" } */\n+      ;\n+    }\n+}\n+\n+int\n+h (void)\n+{\n+  return INT_MAX + 1; /* { dg-warning \"warning: integer overflow in expression\" } */\n+}\n+\n+int\n+h1 (void)\n+{\n+  return INT_MAX + 1 - INT_MAX; /* { dg-warning \"warning: integer overflow in expression\" } */\n+}\n+\n+void fuc (unsigned char);\n+void fsc (signed char);\n+\n+void\n+h2 (void)\n+{\n+  fsc (SCHAR_MAX + 1);\n+  fsc (SCHAR_MIN - 1); /* { dg-warning \"warning: overflow in implicit constant conversion\" } */\n+  fsc (UCHAR_MAX);\n+  fsc (UCHAR_MAX + 1); /* { dg-warning \"warning: overflow in implicit constant conversion\" } */\n+  fuc (-1);\n+  fuc (UCHAR_MAX + 1); /* { dg-warning \"warning: large integer implicitly truncated to unsigned type\" } */\n+  fuc (SCHAR_MIN);\n+  fuc (SCHAR_MIN - 1); /* { dg-warning \"warning: large integer implicitly truncated to unsigned type\" } */\n+  fuc (-UCHAR_MAX); /* { dg-warning \"warning: large integer implicitly truncated to unsigned type\" } */\n+}\n+\n+void fui (unsigned int);\n+void fsi (signed int);\n+\n+int si;\n+unsigned ui;\n+\n+void\n+h2i (int x)\n+{\n+  /* For some reason, we only give certain warnings for implicit\n+     conversions among values of the same precision with -Wconversion,\n+     while we don't give others at all.  */\n+  fsi ((unsigned)INT_MAX + 1);\n+  si = (unsigned)INT_MAX + 1;\n+  si = x ? (unsigned)INT_MAX + 1 : 1;\n+  fsi ((unsigned)INT_MAX + 2);\n+  si = (unsigned)INT_MAX + 2;\n+  si = x ? (unsigned)INT_MAX + 2 : 1;\n+  fsi (UINT_MAX);\n+  si = UINT_MAX;\n+  fui (-1);\n+  ui = -1;\n+  ui = x ? -1 : 1U;\n+  fui (INT_MIN);\n+  ui = INT_MIN;\n+  ui = x ? INT_MIN : 1U;\n+}\n+/* Test for diagnostics for constant overflow.  */\n+/* Origin: Joseph Myers <joseph@codesourcery.com> */\n+/* { dg-do compile } */\n+/* { dg-options \"\" } */\n+\n+#include <limits.h>\n+\n+enum e {\n+  E0 = INT_MAX,\n+  /* Unsigned overflow wraps around.  */\n+  E1 = UINT_MAX + 1,\n+  /* Overflow in an unevaluated part of an expression is OK (example\n+     in the standard).  */\n+  E2 = 2 || 1 / 0, /* { dg-bogus \"warning: division by zero\" \"\" { xfail *-*-* } 14 } */\n+  E3 = 1 / 0, /* { dg-warning \"warning: division by zero\" } */\n+  /* { dg-error \"error: enumerator value for 'E3' is not an integer constant\" \"enum error\" { target *-*-* } 15 } */\n+  /* But as in DR#031, the 1/0 in an evaluated subexpression means the\n+     whole expression violates the constraints.  */\n+  E4 = 0 * (1 / 0), /* { dg-warning \"warning: division by zero\" } */\n+  /* { dg-error \"error: enumerator value for 'E4' is not an integer constant\" \"enum error\" { xfail *-*-* } 19 } */\n+  E5 = INT_MAX + 1, /* { dg-warning \"warning: integer overflow in expression\" } */\n+  /* Again, overflow in evaluated subexpression.  */\n+  E6 = 0 * (INT_MAX + 1), /* { dg-warning \"warning: integer overflow in expression\" } */\n+  /* A cast does not constitute overflow in conversion.  */\n+  E7 = (char) INT_MAX\n+};\n+\n+struct s {\n+  int a;\n+  int : 0 * (1 / 0); /* { dg-warning \"warning: division by zero\" } */\n+  int : 0 * (INT_MAX + 1); /* { dg-warning \"warning: integer overflow in expression\" } */\n+};\n+\n+void\n+f (void)\n+{\n+  /* This expression is not required to be a constant expression, so\n+     it should just involve undefined behavior at runtime.  */\n+  int c = INT_MAX + 1; /* { dg-warning \"warning: integer overflow in expression\" } */\n+}\n+\n+/* But this expression does need to be constant.  */\n+static int sc = INT_MAX + 1; /* { dg-warning \"warning: integer overflow in expression\" } */\n+\n+/* The first two of these involve overflow, so are not null pointer\n+   constants.  The third has the overflow in an unevaluated\n+   subexpression, so is a null pointer constant.  */\n+void *p = 0 * (INT_MAX + 1); /* { dg-warning \"warning: integer overflow in expression\" } */\n+/* { dg-error \"invalid conversion from 'int' to 'void\" \"null\" { target *-*-* } 48 } */\n+void *q = 0 * (1 / 0); /* { dg-warning \"warning: division by zero\" } */\n+/* { dg-error \"invalid conversion from 'int' to 'void*'\" \"null\" { xfail *-*-* } 50 } */\n+void *r = (1 ? 0 : INT_MAX+1); /* { dg-bogus \"integer overflow in expression\" \"\" { xfail *-*-* } 52 } */\n+\n+void\n+g (int i)\n+{\n+  switch (i)\n+    {\n+    case 0 * (1/0): /* { dg-warning \"warning: division by zero\" } */\n+      ;\n+    case 1 + 0 * (INT_MAX + 1): /* { dg-warning \"warning: integer overflow in expression\" } */\n+      ;\n+    }\n+}\n+\n+int\n+h (void)\n+{\n+  return INT_MAX + 1; /* { dg-warning \"warning: integer overflow in expression\" } */\n+}\n+\n+int\n+h1 (void)\n+{\n+  return INT_MAX + 1 - INT_MAX; /* { dg-warning \"warning: integer overflow in expression\" } */\n+}\n+\n+void fuc (unsigned char);\n+void fsc (signed char);\n+\n+void\n+h2 (void)\n+{\n+  fsc (SCHAR_MAX + 1);\n+  fsc (SCHAR_MIN - 1); /* { dg-warning \"warning: overflow in implicit constant conversion\" } */\n+  fsc (UCHAR_MAX);\n+  fsc (UCHAR_MAX + 1); /* { dg-warning \"warning: overflow in implicit constant conversion\" } */\n+  fuc (-1);\n+  fuc (UCHAR_MAX + 1); /* { dg-warning \"warning: large integer implicitly truncated to unsigned type\" } */\n+  fuc (SCHAR_MIN);\n+  fuc (SCHAR_MIN - 1); /* { dg-warning \"warning: large integer implicitly truncated to unsigned type\" } */\n+  fuc (-UCHAR_MAX); /* { dg-warning \"warning: large integer implicitly truncated to unsigned type\" } */\n+}\n+\n+void fui (unsigned int);\n+void fsi (signed int);\n+\n+int si;\n+unsigned ui;\n+\n+void\n+h2i (int x)\n+{\n+  /* For some reason, we only give certain warnings for implicit\n+     conversions among values of the same precision with -Wconversion,\n+     while we don't give others at all.  */\n+  fsi ((unsigned)INT_MAX + 1);\n+  si = (unsigned)INT_MAX + 1;\n+  si = x ? (unsigned)INT_MAX + 1 : 1;\n+  fsi ((unsigned)INT_MAX + 2);\n+  si = (unsigned)INT_MAX + 2;\n+  si = x ? (unsigned)INT_MAX + 2 : 1;\n+  fsi (UINT_MAX);\n+  si = UINT_MAX;\n+  fui (-1);\n+  ui = -1;\n+  ui = x ? -1 : 1U;\n+  fui (INT_MIN);\n+  ui = INT_MIN;\n+  ui = x ? INT_MIN : 1U;\n+}\n+/* Test for diagnostics for constant overflow.  */\n+/* Origin: Joseph Myers <joseph@codesourcery.com> */\n+/* { dg-do compile } */\n+/* { dg-options \"\" } */\n+\n+#include <limits.h>\n+\n+enum e {\n+  E0 = INT_MAX,\n+  /* Unsigned overflow wraps around.  */\n+  E1 = UINT_MAX + 1,\n+  /* Overflow in an unevaluated part of an expression is OK (example\n+     in the standard).  */\n+  E2 = 2 || 1 / 0, /* { dg-bogus \"warning: division by zero\" \"\" { xfail *-*-* } 14 } */\n+  E3 = 1 / 0, /* { dg-warning \"warning: division by zero\" } */\n+  /* { dg-error \"error: enumerator value for 'E3' is not an integer constant\" \"enum error\" { target *-*-* } 15 } */\n+  /* But as in DR#031, the 1/0 in an evaluated subexpression means the\n+     whole expression violates the constraints.  */\n+  E4 = 0 * (1 / 0), /* { dg-warning \"warning: division by zero\" } */\n+  /* { dg-error \"error: enumerator value for 'E4' is not an integer constant\" \"enum error\" { xfail *-*-* } 19 } */\n+  E5 = INT_MAX + 1, /* { dg-warning \"warning: integer overflow in expression\" } */\n+  /* Again, overflow in evaluated subexpression.  */\n+  E6 = 0 * (INT_MAX + 1), /* { dg-warning \"warning: integer overflow in expression\" } */\n+  /* A cast does not constitute overflow in conversion.  */\n+  E7 = (char) INT_MAX\n+};\n+\n+struct s {\n+  int a;\n+  int : 0 * (1 / 0); /* { dg-warning \"warning: division by zero\" } */\n+  int : 0 * (INT_MAX + 1); /* { dg-warning \"warning: integer overflow in expression\" } */\n+};\n+\n+void\n+f (void)\n+{\n+  /* This expression is not required to be a constant expression, so\n+     it should just involve undefined behavior at runtime.  */\n+  int c = INT_MAX + 1; /* { dg-warning \"warning: integer overflow in expression\" } */\n+}\n+\n+/* This expression is neither required to be constant.  */\n+static int sc = INT_MAX + 1; /* { dg-warning \"warning: integer overflow in expression\" } */\n+\n+\n+// Test for overflow in null pointer constant.  \n+void *n = 0;\n+/* The first two of these involve overflow, so are not null pointer\n+   constants.  The third has the overflow in an unevaluated\n+   subexpression, so is a null pointer constant.  */\n+void *p = 0 * (INT_MAX + 1); /* { dg-warning \"warning: integer overflow in expression\" } */\n+/* { dg-error \"invalid conversion from 'int' to 'void\" \"null\" { target *-*-* } 51 } */\n+void *q = 0 * (1 / 0); /* { dg-warning \"warning: division by zero\" } */\n+/* { dg-error \"invalid conversion from 'int' to 'void*'\" \"null\" { xfail *-*-* } 53 } */\n+void *r = (1 ? 0 : INT_MAX+1); /* { dg-bogus \"integer overflow in expression\" \"\" { xfail *-*-* } 55 } */\n+\n+void\n+g (int i)\n+{\n+  switch (i)\n+    {\n+    case 0 * (1/0): /* { dg-warning \"warning: division by zero\" } */\n+      ;\n+    case 1 + 0 * (INT_MAX + 1): /* { dg-warning \"warning: integer overflow in expression\" } */\n+      ;\n+    }\n+}\n+\n+int\n+h (void)\n+{\n+  return INT_MAX + 1; /* { dg-warning \"warning: integer overflow in expression\" } */\n+}\n+\n+int\n+h1 (void)\n+{\n+  return INT_MAX + 1 - INT_MAX; /* { dg-warning \"warning: integer overflow in expression\" } */\n+}\n+\n+void fuc (unsigned char);\n+void fsc (signed char);\n+\n+void\n+h2 (void)\n+{\n+  fsc (SCHAR_MAX + 1);\n+  fsc (SCHAR_MIN - 1); /* { dg-warning \"warning: overflow in implicit constant conversion\" } */\n+  fsc (UCHAR_MAX);\n+  fsc (UCHAR_MAX + 1); /* { dg-warning \"warning: overflow in implicit constant conversion\" } */\n+  fuc (-1);\n+  fuc (UCHAR_MAX + 1); /* { dg-warning \"warning: large integer implicitly truncated to unsigned type\" } */\n+  fuc (SCHAR_MIN);\n+  fuc (SCHAR_MIN - 1); /* { dg-warning \"warning: large integer implicitly truncated to unsigned type\" } */\n+  fuc (-UCHAR_MAX); /* { dg-warning \"warning: large integer implicitly truncated to unsigned type\" } */\n+}\n+\n+void fui (unsigned int);\n+void fsi (signed int);\n+\n+int si;\n+unsigned ui;\n+\n+void\n+h2i (int x)\n+{\n+  /* For some reason, we only give certain warnings for implicit\n+     conversions among values of the same precision with -Wconversion,\n+     while we don't give others at all.  */\n+  fsi ((unsigned)INT_MAX + 1);\n+  si = (unsigned)INT_MAX + 1;\n+  si = x ? (unsigned)INT_MAX + 1 : 1;\n+  fsi ((unsigned)INT_MAX + 2);\n+  si = (unsigned)INT_MAX + 2;\n+  si = x ? (unsigned)INT_MAX + 2 : 1;\n+  fsi (UINT_MAX);\n+  si = UINT_MAX;\n+  fui (-1);\n+  ui = -1;\n+  ui = x ? -1 : 1U;\n+  fui (INT_MIN);\n+  ui = INT_MIN;\n+  ui = x ? INT_MIN : 1U;\n+}"}, {"sha": "a8651c9f645862e5b851c080eabe04d2831ec444", "filename": "gcc/testsuite/g++.dg/warn/overflow-warn-3.C", "status": "added", "additions": 388, "deletions": 0, "changes": 388, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16fd4d2d7102abb179d958d10ba6cf28d8f621a6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Foverflow-warn-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16fd4d2d7102abb179d958d10ba6cf28d8f621a6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Foverflow-warn-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Foverflow-warn-3.C?ref=16fd4d2d7102abb179d958d10ba6cf28d8f621a6", "patch": "@@ -0,0 +1,388 @@\n+/* Test for diagnostics for constant overflow.  Test with -pedantic.  */\n+/* Origin: Joseph Myers <joseph@codesourcery.com> */\n+/* { dg-do compile } */\n+/* { dg-options \"-fpermissive -pedantic\" } */\n+\n+#include <limits.h>\n+\n+enum e {\n+  E0 = INT_MAX,\n+  /* Unsigned overflow wraps around.  */\n+  E1 = UINT_MAX + 1,\n+  /* Overflow in an unevaluated part of an expression is OK (example\n+     in the standard).  */\n+  E2 = 2 || 1 / 0, /* { dg-bogus \"warning: division by zero\" \"\" { xfail *-*-* } 14 } */\n+  E3 = 1 / 0, /* { dg-warning \"warning: division by zero\" } */\n+  /* { dg-error \"error: enumerator value for 'E3' is not an integer constant\" \"enum error\" { target *-*-* } 15 } */\n+  /* But as in DR#031, the 1/0 in an evaluated subexpression means the\n+     whole expression violates the constraints.  */\n+  E4 = 0 * (1 / 0), /* { dg-warning \"warning: division by zero\" } */\n+  /* { dg-error \"error: enumerator value for 'E4' is not an integer constant\" \"enum error\" { xfail *-*-* } 19 } */\n+  E5 = INT_MAX + 1, /* { dg-warning \"warning: integer overflow in expression\" } */\n+  /* { dg-warning \"warning: overflow in constant expression\" \"constant\" { target *-*-* } 21 } */\n+  /* Again, overflow in evaluated subexpression.  */\n+  E6 = 0 * (INT_MAX + 1), /* { dg-warning \"warning: integer overflow in expression\" } */\n+  /* { dg-warning \"warning: overflow in constant expression\" \"constant\" { target *-*-* } 24 } */\n+  /* A cast does not constitute overflow in conversion.  */\n+  E7 = (char) INT_MAX\n+};\n+\n+struct s {\n+  int a;\n+  int : 0 * (1 / 0); /* { dg-warning \"warning: division by zero\" } */\n+  int : 0 * (INT_MAX + 1); /* { dg-warning \"warning: integer overflow in expression\" } */\n+  /* { dg-warning \"warning: overflow in constant expression\" \"constant\" { target *-*-* } 33 } */\n+};\n+\n+void\n+f (void)\n+{\n+  /* This expression is not required to be a constant expression, so\n+     it should just involve undefined behavior at runtime.  */\n+  int c = INT_MAX + 1; /* { dg-warning \"warning: integer overflow in expression\" } */\n+\n+}\n+\n+/* This expression is neither required to be constant.  */\n+static int sc = INT_MAX + 1; /* { dg-warning \"warning: integer overflow in expression\" } */\n+\n+\n+// Test for overflow in null pointer constant.  \n+void *n = 0;\n+/* The first two of these involve overflow, so are not null pointer\n+   constants.  The third has the overflow in an unevaluated\n+   subexpression, so is a null pointer constant.  */\n+void *p = 0 * (INT_MAX + 1); /* { dg-warning \"warning: integer overflow in expression\" } */\n+/* { dg-error \"invalid conversion from 'int' to 'void\" \"null\" { target *-*-* } 55 } */\n+\n+void *q = 0 * (1 / 0); /* { dg-warning \"warning: division by zero\" } */\n+/* { dg-error \"invalid conversion from 'int' to 'void*'\" \"null\" { xfail *-*-* } 58 } */\n+void *r = (1 ? 0 : INT_MAX+1); /* { dg-bogus \"integer overflow in expression\" \"\" { xfail *-*-* } 60 } */\n+\n+void\n+g (int i)\n+{\n+  switch (i)\n+    {\n+    case 0 * (1/0): /* { dg-warning \"warning: division by zero\" } */\n+      ;\n+    case 1 + 0 * (INT_MAX + 1): /* { dg-warning \"warning: integer overflow in expression\" } */\n+      /* { dg-warning \"warning: overflow in constant expression\" \"constant\" { target *-*-* } 69 } */\n+      ;\n+    }\n+}\n+\n+int\n+h (void)\n+{\n+  return INT_MAX + 1; /* { dg-warning \"warning: integer overflow in expression\" } */\n+}\n+\n+int\n+h1 (void)\n+{\n+  return INT_MAX + 1 - INT_MAX; /* { dg-warning \"warning: integer overflow in expression\" } */\n+}\n+\n+void fuc (unsigned char);\n+void fsc (signed char);\n+\n+void\n+h2 (void)\n+{\n+  fsc (SCHAR_MAX + 1); /* { dg-warning \"warning: overflow in implicit constant conversion\" } */\n+  fsc (SCHAR_MIN - 1); /* { dg-warning \"warning: overflow in implicit constant conversion\" } */\n+  fsc (UCHAR_MAX); /* { dg-warning \"warning: overflow in implicit constant conversion\" } */\n+  fsc (UCHAR_MAX + 1); /* { dg-warning \"warning: overflow in implicit constant conversion\" } */\n+  fuc (-1);\n+  fuc (UCHAR_MAX + 1); /* { dg-warning \"warning: large integer implicitly truncated to unsigned type\" } */\n+  fuc (SCHAR_MIN);\n+  fuc (SCHAR_MIN - 1); /* { dg-warning \"warning: large integer implicitly truncated to unsigned type\" } */\n+  fuc (-UCHAR_MAX); /* { dg-warning \"warning: large integer implicitly truncated to unsigned type\" } */\n+}\n+\n+void fui (unsigned int);\n+void fsi (signed int);\n+\n+int si;\n+unsigned ui;\n+\n+void\n+h2i (int x)\n+{\n+  /* For some reason, we only give certain warnings for implicit\n+     conversions among values of the same precision with -Wconversion,\n+     while we don't give others at all.  */\n+  fsi ((unsigned)INT_MAX + 1);\n+  si = (unsigned)INT_MAX + 1;\n+  si = x ? (unsigned)INT_MAX + 1 : 1;\n+  fsi ((unsigned)INT_MAX + 2);\n+  si = (unsigned)INT_MAX + 2;\n+  si = x ? (unsigned)INT_MAX + 2 : 1;\n+  fsi (UINT_MAX);\n+  si = UINT_MAX;\n+  fui (-1);\n+  ui = -1;\n+  ui = x ? -1 : 1U;\n+  fui (INT_MIN);\n+  ui = INT_MIN;\n+  ui = x ? INT_MIN : 1U;\n+}\n+/* Test for diagnostics for constant overflow.  Test with -pedantic.  */\n+/* Origin: Joseph Myers <joseph@codesourcery.com> */\n+/* { dg-do compile } */\n+/* { dg-options \"-fpermissive -pedantic\" } */\n+\n+#include <limits.h>\n+\n+enum e {\n+  E0 = INT_MAX,\n+  /* Unsigned overflow wraps around.  */\n+  E1 = UINT_MAX + 1,\n+  /* Overflow in an unevaluated part of an expression is OK (example\n+     in the standard).  */\n+  E2 = 2 || 1 / 0, /* { dg-bogus \"warning: division by zero\" \"\" { xfail *-*-* } 14 } */\n+  E3 = 1 / 0, /* { dg-warning \"warning: division by zero\" } */\n+  /* { dg-error \"error: enumerator value for 'E3' is not an integer constant\" \"enum error\" { target *-*-* } 15 } */\n+  /* But as in DR#031, the 1/0 in an evaluated subexpression means the\n+     whole expression violates the constraints.  */\n+  E4 = 0 * (1 / 0), /* { dg-warning \"warning: division by zero\" } */\n+  /* { dg-error \"error: enumerator value for 'E4' is not an integer constant\" \"enum error\" { xfail *-*-* } 19 } */\n+  E5 = INT_MAX + 1, /* { dg-warning \"warning: integer overflow in expression\" } */\n+  /* { dg-warning \"warning: overflow in constant expression\" \"constant\" { target *-*-* } 21 } */\n+  /* Again, overflow in evaluated subexpression.  */\n+  E6 = 0 * (INT_MAX + 1), /* { dg-warning \"warning: integer overflow in expression\" } */\n+  /* { dg-warning \"warning: overflow in constant expression\" \"constant\" { target *-*-* } 24 } */\n+  /* A cast does not constitute overflow in conversion.  */\n+  E7 = (char) INT_MAX\n+};\n+\n+struct s {\n+  int a;\n+  int : 0 * (1 / 0); /* { dg-warning \"warning: division by zero\" } */\n+  int : 0 * (INT_MAX + 1); /* { dg-warning \"warning: integer overflow in expression\" } */\n+  /* { dg-warning \"warning: overflow in constant expression\" \"constant\" { target *-*-* } 33 } */\n+};\n+\n+void\n+f (void)\n+{\n+  /* This expression is not required to be a constant expression, so\n+     it should just involve undefined behavior at runtime.  */\n+  int c = INT_MAX + 1; /* { dg-warning \"warning: integer overflow in expression\" } */\n+\n+}\n+\n+/* But this expression does need to be constant (in C++ ???).  */\n+static int sc = INT_MAX + 1; /* { dg-warning \"warning: integer overflow in expression\" } */\n+/* { dg-warning \"warning: overflow in constant expression\" \"constant\" { xfail *-*-* } 47 } */\n+\n+/* The first two of these involve overflow, so are not null pointer\n+   constants.  The third has the overflow in an unevaluated\n+   subexpression, so is a null pointer constant.  */\n+void *p = 0 * (INT_MAX + 1); /* { dg-warning \"warning: integer overflow in expression\" } */\n+/* { dg-error \"invalid conversion from 'int' to 'void\" \"null\" { target *-*-* } 53 } */\n+\n+void *q = 0 * (1 / 0); /* { dg-warning \"warning: division by zero\" } */\n+/* { dg-error \"invalid conversion from 'int' to 'void*'\" \"null\" { xfail *-*-* } 56 } */\n+void *r = (1 ? 0 : INT_MAX+1); /* { dg-bogus \"integer overflow in expression\" \"\" { xfail *-*-* } 58 } */\n+\n+void\n+g (int i)\n+{\n+  switch (i)\n+    {\n+    case 0 * (1/0): /* { dg-warning \"warning: division by zero\" } */\n+      ;\n+    case 1 + 0 * (INT_MAX + 1): /* { dg-warning \"warning: integer overflow in expression\" } */\n+      /* { dg-warning \"warning: overflow in constant expression\" \"constant\" { target *-*-* } 67 } */\n+      ;\n+    }\n+}\n+\n+int\n+h (void)\n+{\n+  return INT_MAX + 1; /* { dg-warning \"warning: integer overflow in expression\" } */\n+}\n+\n+int\n+h1 (void)\n+{\n+  return INT_MAX + 1 - INT_MAX; /* { dg-warning \"warning: integer overflow in expression\" } */\n+}\n+\n+void fuc (unsigned char);\n+void fsc (signed char);\n+\n+void\n+h2 (void)\n+{\n+  fsc (SCHAR_MAX + 1); /* { dg-warning \"warning: overflow in implicit constant conversion\" } */\n+  fsc (SCHAR_MIN - 1); /* { dg-warning \"warning: overflow in implicit constant conversion\" } */\n+  fsc (UCHAR_MAX); /* { dg-warning \"warning: overflow in implicit constant conversion\" } */\n+  fsc (UCHAR_MAX + 1); /* { dg-warning \"warning: overflow in implicit constant conversion\" } */\n+  fuc (-1);\n+  fuc (UCHAR_MAX + 1); /* { dg-warning \"warning: large integer implicitly truncated to unsigned type\" } */\n+  fuc (SCHAR_MIN);\n+  fuc (SCHAR_MIN - 1); /* { dg-warning \"warning: large integer implicitly truncated to unsigned type\" } */\n+  fuc (-UCHAR_MAX); /* { dg-warning \"warning: large integer implicitly truncated to unsigned type\" } */\n+}\n+\n+void fui (unsigned int);\n+void fsi (signed int);\n+\n+int si;\n+unsigned ui;\n+\n+void\n+h2i (int x)\n+{\n+  /* For some reason, we only give certain warnings for implicit\n+     conversions among values of the same precision with -Wconversion,\n+     while we don't give others at all.  */\n+  fsi ((unsigned)INT_MAX + 1);\n+  si = (unsigned)INT_MAX + 1;\n+  si = x ? (unsigned)INT_MAX + 1 : 1;\n+  fsi ((unsigned)INT_MAX + 2);\n+  si = (unsigned)INT_MAX + 2;\n+  si = x ? (unsigned)INT_MAX + 2 : 1;\n+  fsi (UINT_MAX);\n+  si = UINT_MAX;\n+  fui (-1);\n+  ui = -1;\n+  ui = x ? -1 : 1U;\n+  fui (INT_MIN);\n+  ui = INT_MIN;\n+  ui = x ? INT_MIN : 1U;\n+}\n+/* Test for diagnostics for constant overflow.  Test with -pedantic.  */\n+/* Origin: Joseph Myers <joseph@codesourcery.com> */\n+/* { dg-do compile } */\n+/* { dg-options \"-fpermissive -pedantic\" } */\n+\n+#include <limits.h>\n+\n+enum e {\n+  E0 = INT_MAX,\n+  /* Unsigned overflow wraps around.  */\n+  E1 = UINT_MAX + 1,\n+  /* Overflow in an unevaluated part of an expression is OK (example\n+     in the standard).  */\n+  E2 = 2 || 1 / 0, /* { dg-bogus \"warning: division by zero\" \"\" { xfail *-*-* } 14 } */\n+  E3 = 1 / 0, /* { dg-warning \"warning: division by zero\" } */\n+  /* { dg-error \"error: enumerator value for 'E3' is not an integer constant\" \"enum error\" { target *-*-* } 15 } */\n+  /* But as in DR#031, the 1/0 in an evaluated subexpression means the\n+     whole expression violates the constraints.  */\n+  E4 = 0 * (1 / 0), /* { dg-warning \"warning: division by zero\" } */\n+  /* { dg-error \"error: enumerator value for 'E4' is not an integer constant\" \"enum error\" { xfail *-*-* } 19 } */\n+  E5 = INT_MAX + 1, /* { dg-warning \"warning: integer overflow in expression\" } */\n+  /* { dg-warning \"warning: overflow in constant expression\" \"constant\" { target *-*-* } 21 } */\n+  /* Again, overflow in evaluated subexpression.  */\n+  E6 = 0 * (INT_MAX + 1), /* { dg-warning \"warning: integer overflow in expression\" } */\n+  /* { dg-warning \"warning: overflow in constant expression\" \"constant\" { target *-*-* } 24 } */\n+  /* A cast does not constitute overflow in conversion.  */\n+  E7 = (char) INT_MAX\n+};\n+\n+struct s {\n+  int a;\n+  int : 0 * (1 / 0); /* { dg-warning \"warning: division by zero\" } */\n+  int : 0 * (INT_MAX + 1); /* { dg-warning \"warning: integer overflow in expression\" } */\n+  /* { dg-warning \"warning: overflow in constant expression\" \"constant\" { target *-*-* } 33 } */\n+};\n+\n+void\n+f (void)\n+{\n+  /* This expression is not required to be a constant expression, so\n+     it should just involve undefined behavior at runtime.  */\n+  int c = INT_MAX + 1; /* { dg-warning \"warning: integer overflow in expression\" } */\n+\n+}\n+\n+/* This expression is neither required to be constant.  */\n+static int sc = INT_MAX + 1; /* { dg-warning \"warning: integer overflow in expression\" } */\n+\n+\n+// Test for overflow in null pointer constant.  \n+void *n = 0;\n+/* The first two of these involve overflow, so are not null pointer\n+   constants.  The third has the overflow in an unevaluated\n+   subexpression, so is a null pointer constant.  */\n+void *p = 0 * (INT_MAX + 1); /* { dg-warning \"warning: integer overflow in expression\" } */\n+/* { dg-error \"invalid conversion from 'int' to 'void\" \"null\" { target *-*-* } 55 } */\n+\n+void *q = 0 * (1 / 0); /* { dg-warning \"warning: division by zero\" } */\n+/* { dg-error \"invalid conversion from 'int' to 'void*'\" \"null\" { xfail *-*-* } 58 } */\n+void *r = (1 ? 0 : INT_MAX+1); /* { dg-bogus \"integer overflow in expression\" \"\" { xfail *-*-* } 60 } */\n+\n+void\n+g (int i)\n+{\n+  switch (i)\n+    {\n+    case 0 * (1/0): /* { dg-warning \"warning: division by zero\" } */\n+      ;\n+    case 1 + 0 * (INT_MAX + 1): /* { dg-warning \"warning: integer overflow in expression\" } */\n+      /* { dg-warning \"warning: overflow in constant expression\" \"constant\" { target *-*-* } 69 } */\n+      ;\n+    }\n+}\n+\n+int\n+h (void)\n+{\n+  return INT_MAX + 1; /* { dg-warning \"warning: integer overflow in expression\" } */\n+}\n+\n+int\n+h1 (void)\n+{\n+  return INT_MAX + 1 - INT_MAX; /* { dg-warning \"warning: integer overflow in expression\" } */\n+}\n+\n+void fuc (unsigned char);\n+void fsc (signed char);\n+\n+void\n+h2 (void)\n+{\n+  fsc (SCHAR_MAX + 1); /* { dg-warning \"warning: overflow in implicit constant conversion\" } */\n+  fsc (SCHAR_MIN - 1); /* { dg-warning \"warning: overflow in implicit constant conversion\" } */\n+  fsc (UCHAR_MAX); /* { dg-warning \"warning: overflow in implicit constant conversion\" } */\n+  fsc (UCHAR_MAX + 1); /* { dg-warning \"warning: overflow in implicit constant conversion\" } */\n+  fuc (-1);\n+  fuc (UCHAR_MAX + 1); /* { dg-warning \"warning: large integer implicitly truncated to unsigned type\" } */\n+  fuc (SCHAR_MIN);\n+  fuc (SCHAR_MIN - 1); /* { dg-warning \"warning: large integer implicitly truncated to unsigned type\" } */\n+  fuc (-UCHAR_MAX); /* { dg-warning \"warning: large integer implicitly truncated to unsigned type\" } */\n+}\n+\n+void fui (unsigned int);\n+void fsi (signed int);\n+\n+int si;\n+unsigned ui;\n+\n+void\n+h2i (int x)\n+{\n+  /* For some reason, we only give certain warnings for implicit\n+     conversions among values of the same precision with -Wconversion,\n+     while we don't give others at all.  */\n+  fsi ((unsigned)INT_MAX + 1);\n+  si = (unsigned)INT_MAX + 1;\n+  si = x ? (unsigned)INT_MAX + 1 : 1;\n+  fsi ((unsigned)INT_MAX + 2);\n+  si = (unsigned)INT_MAX + 2;\n+  si = x ? (unsigned)INT_MAX + 2 : 1;\n+  fsi (UINT_MAX);\n+  si = UINT_MAX;\n+  fui (-1);\n+  ui = -1;\n+  ui = x ? -1 : 1U;\n+  fui (INT_MIN);\n+  ui = INT_MIN;\n+  ui = x ? INT_MIN : 1U;\n+}"}, {"sha": "4d4ecf0bf027448785b4ef2fd328f52d15e04e73", "filename": "gcc/testsuite/g++.dg/warn/overflow-warn-4.C", "status": "added", "additions": 388, "deletions": 0, "changes": 388, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16fd4d2d7102abb179d958d10ba6cf28d8f621a6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Foverflow-warn-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16fd4d2d7102abb179d958d10ba6cf28d8f621a6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Foverflow-warn-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Foverflow-warn-4.C?ref=16fd4d2d7102abb179d958d10ba6cf28d8f621a6", "patch": "@@ -0,0 +1,388 @@\n+/* Test for diagnostics for constant overflow.  Test with -pedantic-errors.  */\n+/* Origin: Joseph Myers <joseph@codesourcery.com> */\n+/* { dg-do compile } */\n+/* { dg-options \"-pedantic-errors\" } */\n+\n+#include <limits.h>\n+\n+enum e {\n+  E0 = INT_MAX,\n+  /* Unsigned overflow wraps around.  */\n+  E1 = UINT_MAX + 1,\n+  /* Overflow in an unevaluated part of an expression is OK (example\n+     in the standard).  */\n+  E2 = 2 || 1 / 0, /* { dg-bogus \"warning: division by zero\" \"\" { xfail *-*-* } 14 } */\n+  E3 = 1 / 0, /* { dg-warning \"warning: division by zero\" } */\n+  /* { dg-error \"error: enumerator value for 'E3' is not an integer constant\" \"enum error\" { target *-*-* } 15 } */\n+  /* But as in DR#031, the 1/0 in an evaluated subexpression means the\n+     whole expression violates the constraints.  */\n+  E4 = 0 * (1 / 0), /* { dg-warning \"warning: division by zero\" } */\n+  /* { dg-error \"error: enumerator value for 'E4' is not an integer constant\" \"enum error\" { xfail *-*-* } 19 } */\n+  E5 = INT_MAX + 1, /* { dg-warning \"warning: integer overflow in expression\" } */\n+  /* { dg-error \"error: overflow in constant expression\" \"constant\" { target *-*-* } 21 } */\n+  /* Again, overflow in evaluated subexpression.  */\n+  E6 = 0 * (INT_MAX + 1), /* { dg-warning \"warning: integer overflow in expression\" } */\n+  /* { dg-error \"error: overflow in constant expression\" \"constant\" { target *-*-* } 24 } */\n+  /* A cast does not constitute overflow in conversion.  */\n+  E7 = (char) INT_MAX\n+};\n+\n+struct s {\n+  int a;\n+  int : 0 * (1 / 0); /* { dg-warning \"warning: division by zero\" } */\n+  int : 0 * (INT_MAX + 1); /* { dg-warning \"warning: integer overflow in expression\" } */\n+  /* { dg-error \"error: overflow in constant expression\" \"constant\" { target *-*-* } 33 } */\n+};\n+\n+void\n+f (void)\n+{\n+  /* This expression is not required to be a constant expression, so\n+     it should just involve undefined behavior at runtime.  */\n+  int c = INT_MAX + 1; /* { dg-warning \"warning: integer overflow in expression\" } */\n+\n+}\n+\n+/* This expression is neither required to be constant.  */\n+static int sc = INT_MAX + 1; /* { dg-warning \"warning: integer overflow in expression\" } */\n+\n+\n+// Test for overflow in null pointer constant.  \n+void *n = 0;\n+/* The first two of these involve overflow, so are not null pointer\n+   constants.  The third has the overflow in an unevaluated\n+   subexpression, so is a null pointer constant.  */\n+void *p = 0 * (INT_MAX + 1); /* { dg-warning \"warning: integer overflow in expression\" } */\n+/* { dg-error \"invalid conversion from 'int' to 'void\" \"null\" { target *-*-* } 55 } */\n+\n+void *q = 0 * (1 / 0); /* { dg-warning \"warning: division by zero\" } */\n+/* { dg-error \"invalid conversion from 'int' to 'void*'\" \"null\" { xfail *-*-* } 58 } */\n+void *r = (1 ? 0 : INT_MAX+1); /* { dg-bogus \"integer overflow in expression\" \"\" { xfail *-*-* } 60 } */\n+\n+void\n+g (int i)\n+{\n+  switch (i)\n+    {\n+    case 0 * (1/0): /* { dg-warning \"warning: division by zero\" } */\n+      ;\n+    case 1 + 0 * (INT_MAX + 1): /* { dg-warning \"warning: integer overflow in expression\" } */\n+      /* { dg-error \"error: overflow in constant expression\" \"constant\" { target *-*-* } 69 } */\n+      ;\n+    }\n+}\n+\n+int\n+h (void)\n+{\n+  return INT_MAX + 1; /* { dg-warning \"warning: integer overflow in expression\" } */\n+}\n+\n+int\n+h1 (void)\n+{\n+  return INT_MAX + 1 - INT_MAX; /* { dg-warning \"warning: integer overflow in expression\" } */\n+}\n+\n+void fuc (unsigned char);\n+void fsc (signed char);\n+\n+void\n+h2 (void)\n+{\n+  fsc (SCHAR_MAX + 1); /* { dg-warning \"warning: overflow in implicit constant conversion\" } */\n+  fsc (SCHAR_MIN - 1); /* { dg-warning \"warning: overflow in implicit constant conversion\" } */\n+  fsc (UCHAR_MAX); /* { dg-warning \"warning: overflow in implicit constant conversion\" } */\n+  fsc (UCHAR_MAX + 1); /* { dg-warning \"warning: overflow in implicit constant conversion\" } */\n+  fuc (-1);\n+  fuc (UCHAR_MAX + 1); /* { dg-warning \"warning: large integer implicitly truncated to unsigned type\" } */\n+  fuc (SCHAR_MIN);\n+  fuc (SCHAR_MIN - 1); /* { dg-warning \"warning: large integer implicitly truncated to unsigned type\" } */\n+  fuc (-UCHAR_MAX); /* { dg-warning \"warning: large integer implicitly truncated to unsigned type\" } */\n+}\n+\n+void fui (unsigned int);\n+void fsi (signed int);\n+\n+int si;\n+unsigned ui;\n+\n+void\n+h2i (int x)\n+{\n+  /* For some reason, we only give certain warnings for implicit\n+     conversions among values of the same precision with -Wconversion,\n+     while we don't give others at all.  */\n+  fsi ((unsigned)INT_MAX + 1);\n+  si = (unsigned)INT_MAX + 1;\n+  si = x ? (unsigned)INT_MAX + 1 : 1;\n+  fsi ((unsigned)INT_MAX + 2);\n+  si = (unsigned)INT_MAX + 2;\n+  si = x ? (unsigned)INT_MAX + 2 : 1;\n+  fsi (UINT_MAX);\n+  si = UINT_MAX;\n+  fui (-1);\n+  ui = -1;\n+  ui = x ? -1 : 1U;\n+  fui (INT_MIN);\n+  ui = INT_MIN;\n+  ui = x ? INT_MIN : 1U;\n+}\n+/* Test for diagnostics for constant overflow.  Test with -pedantic-errors.  */\n+/* Origin: Joseph Myers <joseph@codesourcery.com> */\n+/* { dg-do compile } */\n+/* { dg-options \"-pedantic-errors\" } */\n+\n+#include <limits.h>\n+\n+enum e {\n+  E0 = INT_MAX,\n+  /* Unsigned overflow wraps around.  */\n+  E1 = UINT_MAX + 1,\n+  /* Overflow in an unevaluated part of an expression is OK (example\n+     in the standard).  */\n+  E2 = 2 || 1 / 0, /* { dg-bogus \"warning: division by zero\" \"\" { xfail *-*-* } 14 } */\n+  E3 = 1 / 0, /* { dg-warning \"warning: division by zero\" } */\n+  /* { dg-error \"error: enumerator value for 'E3' is not an integer constant\" \"enum error\" { target *-*-* } 15 } */\n+  /* But as in DR#031, the 1/0 in an evaluated subexpression means the\n+     whole expression violates the constraints.  */\n+  E4 = 0 * (1 / 0), /* { dg-warning \"warning: division by zero\" } */\n+  /* { dg-error \"error: enumerator value for 'E4' is not an integer constant\" \"enum error\" { xfail *-*-* } 19 } */\n+  E5 = INT_MAX + 1, /* { dg-warning \"warning: integer overflow in expression\" } */\n+  /* { dg-error \"error: overflow in constant expression\" \"constant\" { target *-*-* } 21 } */\n+  /* Again, overflow in evaluated subexpression.  */\n+  E6 = 0 * (INT_MAX + 1), /* { dg-warning \"warning: integer overflow in expression\" } */\n+  /* { dg-error \"error: overflow in constant expression\" \"constant\" { target *-*-* } 24 } */\n+  /* A cast does not constitute overflow in conversion.  */\n+  E7 = (char) INT_MAX\n+};\n+\n+struct s {\n+  int a;\n+  int : 0 * (1 / 0); /* { dg-warning \"warning: division by zero\" } */\n+  int : 0 * (INT_MAX + 1); /* { dg-warning \"warning: integer overflow in expression\" } */\n+  /* { dg-error \"error: overflow in constant expression\" \"constant\" { target *-*-* } 33 } */\n+};\n+\n+void\n+f (void)\n+{\n+  /* This expression is not required to be a constant expression, so\n+     it should just involve undefined behavior at runtime.  */\n+  int c = INT_MAX + 1; /* { dg-warning \"warning: integer overflow in expression\" } */\n+\n+}\n+\n+/* But this expression does need to be constant (in C++ ???).  */\n+static int sc = INT_MAX + 1; /* { dg-warning \"warning: integer overflow in expression\" } */\n+/* { dg-error \"error: overflow in constant expression\" \"constant\" { xfail *-*-* } 47 } */\n+\n+/* The first two of these involve overflow, so are not null pointer\n+   constants.  The third has the overflow in an unevaluated\n+   subexpression, so is a null pointer constant.  */\n+void *p = 0 * (INT_MAX + 1); /* { dg-warning \"warning: integer overflow in expression\" } */\n+/* { dg-error \"invalid conversion from 'int' to 'void\" \"null\" { target *-*-* } 53 } */\n+\n+void *q = 0 * (1 / 0); /* { dg-warning \"warning: division by zero\" } */\n+/* { dg-error \"invalid conversion from 'int' to 'void*'\" \"null\" { xfail *-*-* } 56 } */\n+void *r = (1 ? 0 : INT_MAX+1); /* { dg-bogus \"integer overflow in expression\" \"\" { xfail *-*-* } 58 } */\n+\n+void\n+g (int i)\n+{\n+  switch (i)\n+    {\n+    case 0 * (1/0): /* { dg-warning \"warning: division by zero\" } */\n+      ;\n+    case 1 + 0 * (INT_MAX + 1): /* { dg-warning \"warning: integer overflow in expression\" } */\n+      /* { dg-error \"error: overflow in constant expression\" \"constant\" { target *-*-* } 67 } */\n+      ;\n+    }\n+}\n+\n+int\n+h (void)\n+{\n+  return INT_MAX + 1; /* { dg-warning \"warning: integer overflow in expression\" } */\n+}\n+\n+int\n+h1 (void)\n+{\n+  return INT_MAX + 1 - INT_MAX; /* { dg-warning \"warning: integer overflow in expression\" } */\n+}\n+\n+void fuc (unsigned char);\n+void fsc (signed char);\n+\n+void\n+h2 (void)\n+{\n+  fsc (SCHAR_MAX + 1); /* { dg-warning \"warning: overflow in implicit constant conversion\" } */\n+  fsc (SCHAR_MIN - 1); /* { dg-warning \"warning: overflow in implicit constant conversion\" } */\n+  fsc (UCHAR_MAX); /* { dg-warning \"warning: overflow in implicit constant conversion\" } */\n+  fsc (UCHAR_MAX + 1); /* { dg-warning \"warning: overflow in implicit constant conversion\" } */\n+  fuc (-1);\n+  fuc (UCHAR_MAX + 1); /* { dg-warning \"warning: large integer implicitly truncated to unsigned type\" } */\n+  fuc (SCHAR_MIN);\n+  fuc (SCHAR_MIN - 1); /* { dg-warning \"warning: large integer implicitly truncated to unsigned type\" } */\n+  fuc (-UCHAR_MAX); /* { dg-warning \"warning: large integer implicitly truncated to unsigned type\" } */\n+}\n+\n+void fui (unsigned int);\n+void fsi (signed int);\n+\n+int si;\n+unsigned ui;\n+\n+void\n+h2i (int x)\n+{\n+  /* For some reason, we only give certain warnings for implicit\n+     conversions among values of the same precision with -Wconversion,\n+     while we don't give others at all.  */\n+  fsi ((unsigned)INT_MAX + 1);\n+  si = (unsigned)INT_MAX + 1;\n+  si = x ? (unsigned)INT_MAX + 1 : 1;\n+  fsi ((unsigned)INT_MAX + 2);\n+  si = (unsigned)INT_MAX + 2;\n+  si = x ? (unsigned)INT_MAX + 2 : 1;\n+  fsi (UINT_MAX);\n+  si = UINT_MAX;\n+  fui (-1);\n+  ui = -1;\n+  ui = x ? -1 : 1U;\n+  fui (INT_MIN);\n+  ui = INT_MIN;\n+  ui = x ? INT_MIN : 1U;\n+}\n+/* Test for diagnostics for constant overflow.  Test with -pedantic-errors.  */\n+/* Origin: Joseph Myers <joseph@codesourcery.com> */\n+/* { dg-do compile } */\n+/* { dg-options \"-pedantic-errors\" } */\n+\n+#include <limits.h>\n+\n+enum e {\n+  E0 = INT_MAX,\n+  /* Unsigned overflow wraps around.  */\n+  E1 = UINT_MAX + 1,\n+  /* Overflow in an unevaluated part of an expression is OK (example\n+     in the standard).  */\n+  E2 = 2 || 1 / 0, /* { dg-bogus \"warning: division by zero\" \"\" { xfail *-*-* } 14 } */\n+  E3 = 1 / 0, /* { dg-warning \"warning: division by zero\" } */\n+  /* { dg-error \"error: enumerator value for 'E3' is not an integer constant\" \"enum error\" { target *-*-* } 15 } */\n+  /* But as in DR#031, the 1/0 in an evaluated subexpression means the\n+     whole expression violates the constraints.  */\n+  E4 = 0 * (1 / 0), /* { dg-warning \"warning: division by zero\" } */\n+  /* { dg-error \"error: enumerator value for 'E4' is not an integer constant\" \"enum error\" { xfail *-*-* } 19 } */\n+  E5 = INT_MAX + 1, /* { dg-warning \"warning: integer overflow in expression\" } */\n+  /* { dg-error \"error: overflow in constant expression\" \"constant\" { target *-*-* } 21 } */\n+  /* Again, overflow in evaluated subexpression.  */\n+  E6 = 0 * (INT_MAX + 1), /* { dg-warning \"warning: integer overflow in expression\" } */\n+  /* { dg-error \"error: overflow in constant expression\" \"constant\" { target *-*-* } 24 } */\n+  /* A cast does not constitute overflow in conversion.  */\n+  E7 = (char) INT_MAX\n+};\n+\n+struct s {\n+  int a;\n+  int : 0 * (1 / 0); /* { dg-warning \"warning: division by zero\" } */\n+  int : 0 * (INT_MAX + 1); /* { dg-warning \"warning: integer overflow in expression\" } */\n+  /* { dg-error \"error: overflow in constant expression\" \"constant\" { target *-*-* } 33 } */\n+};\n+\n+void\n+f (void)\n+{\n+  /* This expression is not required to be a constant expression, so\n+     it should just involve undefined behavior at runtime.  */\n+  int c = INT_MAX + 1; /* { dg-warning \"warning: integer overflow in expression\" } */\n+\n+}\n+\n+/* This expression is neither required to be constant.  */\n+static int sc = INT_MAX + 1; /* { dg-warning \"warning: integer overflow in expression\" } */\n+\n+\n+// Test for overflow in null pointer constant.  \n+void *n = 0;\n+/* The first two of these involve overflow, so are not null pointer\n+   constants.  The third has the overflow in an unevaluated\n+   subexpression, so is a null pointer constant.  */\n+void *p = 0 * (INT_MAX + 1); /* { dg-warning \"warning: integer overflow in expression\" } */\n+/* { dg-error \"invalid conversion from 'int' to 'void\" \"null\" { target *-*-* } 55 } */\n+\n+void *q = 0 * (1 / 0); /* { dg-warning \"warning: division by zero\" } */\n+/* { dg-error \"invalid conversion from 'int' to 'void*'\" \"null\" { xfail *-*-* } 58 } */\n+void *r = (1 ? 0 : INT_MAX+1); /* { dg-bogus \"integer overflow in expression\" \"\" { xfail *-*-* } 60 } */\n+\n+void\n+g (int i)\n+{\n+  switch (i)\n+    {\n+    case 0 * (1/0): /* { dg-warning \"warning: division by zero\" } */\n+      ;\n+    case 1 + 0 * (INT_MAX + 1): /* { dg-warning \"warning: integer overflow in expression\" } */\n+      /* { dg-error \"error: overflow in constant expression\" \"constant\" { target *-*-* } 69 } */\n+      ;\n+    }\n+}\n+\n+int\n+h (void)\n+{\n+  return INT_MAX + 1; /* { dg-warning \"warning: integer overflow in expression\" } */\n+}\n+\n+int\n+h1 (void)\n+{\n+  return INT_MAX + 1 - INT_MAX; /* { dg-warning \"warning: integer overflow in expression\" } */\n+}\n+\n+void fuc (unsigned char);\n+void fsc (signed char);\n+\n+void\n+h2 (void)\n+{\n+  fsc (SCHAR_MAX + 1); /* { dg-warning \"warning: overflow in implicit constant conversion\" } */\n+  fsc (SCHAR_MIN - 1); /* { dg-warning \"warning: overflow in implicit constant conversion\" } */\n+  fsc (UCHAR_MAX); /* { dg-warning \"warning: overflow in implicit constant conversion\" } */\n+  fsc (UCHAR_MAX + 1); /* { dg-warning \"warning: overflow in implicit constant conversion\" } */\n+  fuc (-1);\n+  fuc (UCHAR_MAX + 1); /* { dg-warning \"warning: large integer implicitly truncated to unsigned type\" } */\n+  fuc (SCHAR_MIN);\n+  fuc (SCHAR_MIN - 1); /* { dg-warning \"warning: large integer implicitly truncated to unsigned type\" } */\n+  fuc (-UCHAR_MAX); /* { dg-warning \"warning: large integer implicitly truncated to unsigned type\" } */\n+}\n+\n+void fui (unsigned int);\n+void fsi (signed int);\n+\n+int si;\n+unsigned ui;\n+\n+void\n+h2i (int x)\n+{\n+  /* For some reason, we only give certain warnings for implicit\n+     conversions among values of the same precision with -Wconversion,\n+     while we don't give others at all.  */\n+  fsi ((unsigned)INT_MAX + 1);\n+  si = (unsigned)INT_MAX + 1;\n+  si = x ? (unsigned)INT_MAX + 1 : 1;\n+  fsi ((unsigned)INT_MAX + 2);\n+  si = (unsigned)INT_MAX + 2;\n+  si = x ? (unsigned)INT_MAX + 2 : 1;\n+  fsi (UINT_MAX);\n+  si = UINT_MAX;\n+  fui (-1);\n+  ui = -1;\n+  ui = x ? -1 : 1U;\n+  fui (INT_MIN);\n+  ui = INT_MIN;\n+  ui = x ? INT_MIN : 1U;\n+}"}, {"sha": "5fd0ac4f93cf5f9f78d03b0154f9e8307159df39", "filename": "gcc/testsuite/g++.dg/warn/overflow-warn-5.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16fd4d2d7102abb179d958d10ba6cf28d8f621a6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Foverflow-warn-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16fd4d2d7102abb179d958d10ba6cf28d8f621a6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Foverflow-warn-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Foverflow-warn-5.C?ref=16fd4d2d7102abb179d958d10ba6cf28d8f621a6", "patch": "@@ -0,0 +1,21 @@\n+/* PR c/27273 */\n+/* { dg-do compile } */\n+/* { dg-options \"-Woverflow\" } */\n+\n+unsigned char rx_async(unsigned char p) {\n+    return p & 512; /* { dg-warning \"overflow in implicit constant conversion\" } */\n+}\n+/* PR c/27273 */\n+/* { dg-do compile } */\n+/* { dg-options \"-Woverflow\" } */\n+\n+unsigned char rx_async(unsigned char p) {\n+    return p & 512; /* { dg-warning \"overflow in implicit constant conversion\" } */\n+}\n+/* PR c/27273 */\n+/* { dg-do compile } */\n+/* { dg-options \"-Woverflow\" } */\n+\n+unsigned char rx_async(unsigned char p) {\n+    return p & 512; /* { dg-warning \"overflow in implicit constant conversion\" } */\n+}"}, {"sha": "af549abb54f76e6849f4303b66aa059e499ef60c", "filename": "gcc/testsuite/g++.dg/warn/overflow-warn-6.C", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16fd4d2d7102abb179d958d10ba6cf28d8f621a6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Foverflow-warn-6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16fd4d2d7102abb179d958d10ba6cf28d8f621a6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Foverflow-warn-6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Foverflow-warn-6.C?ref=16fd4d2d7102abb179d958d10ba6cf28d8f621a6", "patch": "@@ -0,0 +1,54 @@\n+/* Test non-constant operands in overflowed expressions.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-Woverflow\" } */\n+\n+#include <limits.h>\n+\n+int \n+h1 (int x)\n+{\n+  return x * (0 * (INT_MAX + 1)); /* { dg-warning \"warning: integer overflow in expression\" } */\n+}\n+\n+int \n+h2 (int x)\n+{\n+  return ((INT_MAX + 1) * 0) * x; /* { dg-warning \"warning: integer overflow in expression\" } */\n+}\n+\n+/* Test non-constant operands in overflowed expressions.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-Woverflow\" } */\n+\n+#include <limits.h>\n+\n+int \n+h1 (int x)\n+{\n+  return x * (0 * (INT_MAX + 1)); /* { dg-warning \"warning: integer overflow in expression\" } */\n+}\n+\n+int \n+h2 (int x)\n+{\n+  return ((INT_MAX + 1) * 0) * x; /* { dg-warning \"warning: integer overflow in expression\" } */\n+}\n+\n+/* Test non-constant operands in overflowed expressions.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-Woverflow\" } */\n+\n+#include <limits.h>\n+\n+int \n+h1 (int x)\n+{\n+  return x * (0 * (INT_MAX + 1)); /* { dg-warning \"warning: integer overflow in expression\" } */\n+}\n+\n+int \n+h2 (int x)\n+{\n+  return ((INT_MAX + 1) * 0) * x; /* { dg-warning \"warning: integer overflow in expression\" } */\n+}\n+"}]}