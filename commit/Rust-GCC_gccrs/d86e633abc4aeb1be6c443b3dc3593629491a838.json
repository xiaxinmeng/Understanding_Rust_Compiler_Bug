{"sha": "d86e633abc4aeb1be6c443b3dc3593629491a838", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDg2ZTYzM2FiYzRhZWIxYmU2YzQ0M2IzZGMzNTkzNjI5NDkxYTgzOA==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2013-07-31T20:04:07Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2013-07-31T20:04:07Z"}, "message": "predicates.md (fusion_gpr_addis): New predicates to support power8 load fusion.\n\n[gcc]\n2013-07-31  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* config/rs6000/predicates.md (fusion_gpr_addis): New predicates\n\tto support power8 load fusion.\n\t(fusion_gpr_mem_load): Likewise.\n\n\t* config/rs6000/rs6000-modes.def (PTImode): Update a comment.\n\n\t* config/rs6000/rs6000-protos.h (fusion_gpr_load_p): New\n\tdeclarations for power8 load fusion.\n\t(emit_fusion_gpr_load): Likewise.\n\n\t* config/rs6000/rs6000.c (rs6000_option_override_internal): If\n\ttuning for power8, turn on fusion mode by default.  Turn on sign\n\textending fusion mode if normal fusion mode is on, and we are at\n\t-O2 or -O3.\n\t(fusion_gpr_load_p): New function, return true if we can fuse an\n\taddis instruction with a dependent load to a GPR.\n\t(emit_fusion_gpr_load): Emit the instructions for power8 load\n\tfusion to GPRs.\n\n\t* config/rs6000/vsx.md (VSX_M2): New iterator for fusion\n\tpeepholes.\n\t(VSX load fusion peepholes): New peepholes to fuse together an\n\taddi instruction with a VSX load instruction.\n\n\t* config/rs6000/rs6000.md (GPR load fusion peepholes): New\n\tpeepholes to fuse an addis instruction with a load to a GPR base\n\tregister.  If we are supporting sign extending fusions, convert\n\tsign extending loads to zero extending loads and add an explicit\n\tsign extension.\n\n[gcc/testsuite]\n2013-07-31  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* gcc.target/powerpc/fusion.c: New file, test power8 fusion\n\tsupport.\n\nFrom-SVN: r201385", "tree": {"sha": "8fca80180a443821ea64db1f6fcab18e36937b55", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8fca80180a443821ea64db1f6fcab18e36937b55"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d86e633abc4aeb1be6c443b3dc3593629491a838", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d86e633abc4aeb1be6c443b3dc3593629491a838", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d86e633abc4aeb1be6c443b3dc3593629491a838", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d86e633abc4aeb1be6c443b3dc3593629491a838/comments", "author": null, "committer": null, "parents": [{"sha": "b26e3fc277ea869668b129563f9276caace5e5d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b26e3fc277ea869668b129563f9276caace5e5d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b26e3fc277ea869668b129563f9276caace5e5d9"}], "stats": {"total": 572, "additions": 571, "deletions": 1}, "files": [{"sha": "f2d25f06ef3a7d570669ce4c0899bf0806e3a99e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d86e633abc4aeb1be6c443b3dc3593629491a838/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d86e633abc4aeb1be6c443b3dc3593629491a838/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d86e633abc4aeb1be6c443b3dc3593629491a838", "patch": "@@ -1,3 +1,35 @@\n+2013-07-31  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* config/rs6000/predicates.md (fusion_gpr_addis): New predicates\n+\tto support power8 load fusion.\n+\t(fusion_gpr_mem_load): Likewise.\n+\n+\t* config/rs6000/rs6000-modes.def (PTImode): Update a comment.\n+\n+\t* config/rs6000/rs6000-protos.h (fusion_gpr_load_p): New\n+\tdeclarations for power8 load fusion.\n+\t(emit_fusion_gpr_load): Likewise.\n+\n+\t* config/rs6000/rs6000.c (rs6000_option_override_internal): If\n+\ttuning for power8, turn on fusion mode by default.  Turn on sign\n+\textending fusion mode if normal fusion mode is on, and we are at\n+\t-O2 or -O3.\n+\t(fusion_gpr_load_p): New function, return true if we can fuse an\n+\taddis instruction with a dependent load to a GPR.\n+\t(emit_fusion_gpr_load): Emit the instructions for power8 load\n+\tfusion to GPRs.\n+\n+\t* config/rs6000/vsx.md (VSX_M2): New iterator for fusion\n+\tpeepholes.\n+\t(VSX load fusion peepholes): New peepholes to fuse together an\n+\taddi instruction with a VSX load instruction.\n+\n+\t* config/rs6000/rs6000.md (GPR load fusion peepholes): New\n+\tpeepholes to fuse an addis instruction with a load to a GPR base\n+\tregister.  If we are supporting sign extending fusions, convert\n+\tsign extending loads to zero extending loads and add an explicit\n+\tsign extension.\n+\n 2013-07-31  Sofiane Naci  <sofiane.naci@arm.com>\n \n \t* config.gcc (arm*-*-*): Add aarch-common.o to extra_objs.  Add"}, {"sha": "09013c3d553b8b943d187d0f76f7f7a77afbdf57", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d86e633abc4aeb1be6c443b3dc3593629491a838/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d86e633abc4aeb1be6c443b3dc3593629491a838/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=d86e633abc4aeb1be6c443b3dc3593629491a838", "patch": "@@ -1702,3 +1702,91 @@\n \n   return GET_CODE (op) == UNSPEC && XINT (op, 1) == UNSPEC_TOCREL;\n })\n+\n+;; Match the first insn (addis) in fusing the combination of addis and loads to\n+;; GPR registers on power8.\n+(define_predicate \"fusion_gpr_addis\"\n+  (match_code \"const_int,high,plus\")\n+{\n+  HOST_WIDE_INT value;\n+  rtx int_const;\n+\n+  if (GET_CODE (op) == HIGH)\n+    return 1;\n+\n+  if (CONST_INT_P (op))\n+    int_const = op;\n+\n+  else if (GET_CODE (op) == PLUS\n+\t   && base_reg_operand (XEXP (op, 0), Pmode)\n+\t   && CONST_INT_P (XEXP (op, 1)))\n+    int_const = XEXP (op, 1);\n+\n+  else\n+    return 0;\n+\n+  /* Power8 currently will only do the fusion if the top 11 bits of the addis\n+     value are all 1's or 0's.  */\n+  value = INTVAL (int_const);\n+  if ((value & (HOST_WIDE_INT)0xffff) != 0)\n+    return 0;\n+\n+  if ((value & (HOST_WIDE_INT)0xffff0000) == 0)\n+    return 0;\n+\n+  return (IN_RANGE (value >> 16, -32, 31));\n+})\n+\n+;; Match the second insn (lbz, lhz, lwz, ld) in fusing the combination of addis\n+;; and loads to GPR registers on power8.\n+(define_predicate \"fusion_gpr_mem_load\"\n+  (match_code \"mem\")\n+{\n+  rtx addr;\n+\n+  if (!MEM_P (op))\n+    return 0;\n+\n+  switch (mode)\n+    {\n+    case QImode:\n+    case HImode:\n+    case SImode:\n+      break;\n+\n+    case DImode:\n+      if (!TARGET_POWERPC64)\n+\treturn 0;\n+      break;\n+\n+    default:\n+      return 0;\n+    }\n+\n+  addr = XEXP (op, 0);\n+  if (GET_CODE (addr) == PLUS)\n+    {\n+      rtx base = XEXP (addr, 0);\n+      rtx offset = XEXP (addr, 1);\n+\n+      return (base_reg_operand (base, GET_MODE (base))\n+\t      && satisfies_constraint_I (offset));\n+    }\n+\n+  else if (GET_CODE (addr) == LO_SUM)\n+    {\n+      rtx base = XEXP (addr, 0);\n+      rtx offset = XEXP (addr, 1);\n+\n+      if (!base_reg_operand (base, GET_MODE (base)))\n+\treturn 0;\n+\n+      else if (TARGET_XCOFF || (TARGET_ELF && TARGET_POWERPC64))\n+\treturn small_toc_ref (offset, GET_MODE (offset));\n+\n+      else if (TARGET_ELF && !TARGET_POWERPC64)\n+\treturn CONSTANT_P (offset);\n+    }\n+\n+  return 0;\n+})"}, {"sha": "5124e1665d4f572b62fc4829c24c39ecacb64a22", "filename": "gcc/config/rs6000/rs6000-modes.def", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d86e633abc4aeb1be6c443b3dc3593629491a838/gcc%2Fconfig%2Frs6000%2Frs6000-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d86e633abc4aeb1be6c443b3dc3593629491a838/gcc%2Fconfig%2Frs6000%2Frs6000-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-modes.def?ref=d86e633abc4aeb1be6c443b3dc3593629491a838", "patch": "@@ -42,5 +42,7 @@ VECTOR_MODES (FLOAT, 8);      /*             V4HF V2SF */\n VECTOR_MODES (FLOAT, 16);     /*       V8HF  V4SF V2DF */\n VECTOR_MODES (FLOAT, 32);     /*       V16HF V8SF V4DF */\n \n-/* Replacement for TImode that only is allowed in GPRs.  */\n+/* Replacement for TImode that only is allowed in GPRs.  We also use PTImode\n+   for quad memory atomic operations to force getting an even/odd register\n+   combination.  */\n PARTIAL_INT_MODE (TI);"}, {"sha": "410042bdcc138918bb45c3ebc951c25ef6068697", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d86e633abc4aeb1be6c443b3dc3593629491a838/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d86e633abc4aeb1be6c443b3dc3593629491a838/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=d86e633abc4aeb1be6c443b3dc3593629491a838", "patch": "@@ -73,6 +73,8 @@ extern int mems_ok_for_quad_peep (rtx, rtx);\n extern bool gpr_or_gpr_p (rtx, rtx);\n extern bool direct_move_p (rtx, rtx);\n extern bool quad_load_store_p (rtx, rtx);\n+extern bool fusion_gpr_load_p (rtx, rtx, rtx, rtx, rtx);\n+extern const char *emit_fusion_gpr_load (rtx, rtx, rtx, rtx);\n extern enum reg_class (*rs6000_preferred_reload_class_ptr) (rtx,\n \t\t\t\t\t\t\t    enum reg_class);\n extern enum reg_class (*rs6000_secondary_reload_class_ptr) (enum reg_class,"}, {"sha": "10a036c1249af3b78b20bbd1a0991a4c8201551d", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 279, "deletions": 0, "changes": 279, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d86e633abc4aeb1be6c443b3dc3593629491a838/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d86e633abc4aeb1be6c443b3dc3593629491a838/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=d86e633abc4aeb1be6c443b3dc3593629491a838", "patch": "@@ -3074,6 +3074,21 @@ rs6000_option_override_internal (bool global_init_p)\n       rs6000_isa_flags &= ~OPTION_MASK_QUAD_MEMORY;\n     }\n \n+  /* Enable power8 fusion if we are tuning for power8, even if we aren't\n+     generating power8 instructions.  */\n+  if (!(rs6000_isa_flags_explicit & OPTION_MASK_P8_FUSION))\n+    rs6000_isa_flags |= (processor_target_table[tune_index].target_enable\n+\t\t\t & OPTION_MASK_P8_FUSION);\n+\n+  /* Power8 does not fuse sign extended loads with the addis.  If we are\n+     optimizing at high levels for speed, convert a sign extended load into a\n+     zero extending load, and an explicit sign extension.  */\n+  if (TARGET_P8_FUSION\n+      && !(rs6000_isa_flags_explicit & OPTION_MASK_P8_FUSION_SIGN)\n+      && optimize_function_for_speed_p (cfun)\n+      && optimize >= 3)\n+    rs6000_isa_flags |= OPTION_MASK_P8_FUSION_SIGN;\n+\n   if (TARGET_DEBUG_REG || TARGET_DEBUG_TARGET)\n     rs6000_print_isa_options (stderr, 0, \"after defaults\", rs6000_isa_flags);\n \n@@ -30418,6 +30433,270 @@ rs6000_split_logical (rtx operands[3],\n   return;\n }\n \n+\f\n+/* Return true if the peephole2 can combine a load involving a combination of\n+   an addis instruction and a load with an offset that can be fused together on\n+   a power8.  */\n+\n+bool\n+fusion_gpr_load_p (rtx addis_reg,\t/* reg. to hold high value.  */\n+\t\t   rtx addis_value,\t/* high value loaded.  */\n+\t\t   rtx target,\t\t/* reg. that is loaded.  */\n+\t\t   rtx mem,\t\t/* memory to load.  */\n+\t\t   rtx insn)\t\t/* insn for looking up reg notes or\n+\t\t\t\t\t   NULL_RTX if this is a peephole2.  */\n+{\n+  rtx addr;\n+  rtx base_reg;\n+\n+  /* Validate arguments.  */\n+  if (!base_reg_operand (addis_reg, GET_MODE (addis_reg)))\n+    return false;\n+\n+  if (!base_reg_operand (target, GET_MODE (target)))\n+    return false;\n+\n+  if (!fusion_gpr_addis (addis_value, GET_MODE (addis_value)))\n+    return false;\n+\n+  if (!fusion_gpr_mem_load (mem, GET_MODE (mem)))\n+    return false;\n+\n+  /* Validate that the register used to load the high value is either the\n+     register being loaded, or we can safely replace its use in a peephole.\n+\n+     If this is a peephole2, we assume that there are 2 instructions in the\n+     peephole (addis and load), so we want to check if the target register was\n+     not used and the register to hold the addis result is dead after the\n+     peephole.  */\n+  if (REGNO (addis_reg) != REGNO (target))\n+    {\n+      if (reg_mentioned_p (target, mem))\n+\treturn false;\n+\n+      if (insn)\n+\t{\n+\t  if (!find_reg_note (insn, REG_DEAD, addis_reg))\n+\t    return false;\n+\t}\n+      else\n+\t{\n+\t  if (!peep2_reg_dead_p (2, addis_reg))\n+\t    return false;\n+\t}\n+    }\n+\n+  /* Validate that the value being loaded in the addis is used in the load.  */\n+  addr = XEXP (mem, 0);\t\t\t/* either PLUS or LO_SUM.  */\n+  if (GET_CODE (addr) != PLUS && GET_CODE (addr) != LO_SUM)\n+    return false;\n+\n+  base_reg = XEXP (addr, 0);\n+  return REGNO (addis_reg) == REGNO (base_reg);\n+}\n+\n+/* Return a string to fuse an addis instruction with a gpr load to the same\n+   register that we loaded up the addis instruction.  The code is complicated,\n+   so we call output_asm_insn directly, and just return \"\".  */\n+\n+const char *\n+emit_fusion_gpr_load (rtx addis_reg, rtx addis_value, rtx target, rtx mem)\n+{\n+  rtx fuse_ops[10];\n+  rtx addr;\n+  rtx load_offset;\n+  const char *addis_str = NULL;\n+  const char *load_str = NULL;\n+  const char *mode_name = NULL;\n+  char insn_template[80];\n+  enum machine_mode mode = GET_MODE (mem);\n+  const char *comment_str = ASM_COMMENT_START;\n+\n+  if (*comment_str == ' ')\n+    comment_str++;\n+\n+  if (!MEM_P (mem))\n+    gcc_unreachable ();\n+\n+  addr = XEXP (mem, 0);\n+  if (GET_CODE (addr) != PLUS && GET_CODE (addr) != LO_SUM)\n+    gcc_unreachable ();\n+\n+  load_offset = XEXP (addr, 1);\n+\n+  /* Now emit the load instruction to the same register.  */\n+  switch (mode)\n+    {\n+    case QImode:\n+      mode_name = \"char\";\n+      load_str = \"lbz\";\n+      break;\n+\n+    case HImode:\n+      mode_name = \"short\";\n+      load_str = \"lhz\";\n+      break;\n+\n+    case SImode:\n+      mode_name = \"int\";\n+      load_str = \"lwz\";\n+      break;\n+\n+    case DImode:\n+      if (TARGET_POWERPC64)\n+\t{\n+\t  mode_name = \"long\";\n+\t  load_str = \"ld\";\n+\t}\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  if (!load_str)\n+    gcc_unreachable ();\n+\n+  /* Emit the addis instruction.  */\n+  fuse_ops[0] = target;\n+  fuse_ops[1] = addis_reg;\n+  if (satisfies_constraint_L (addis_value))\n+    {\n+      fuse_ops[2] = addis_value;\n+      addis_str = \"lis %0,%v2\";\n+    }\n+\n+  else if (GET_CODE (addis_value) == PLUS)\n+    {\n+      rtx op0 = XEXP (addis_value, 0);\n+      rtx op1 = XEXP (addis_value, 1);\n+\n+      if (REG_P (op0) && CONST_INT_P (op1)\n+\t  && satisfies_constraint_L (op1))\n+\t{\n+\t  fuse_ops[2] = op0;\n+\t  fuse_ops[3] = op1;\n+\t  addis_str = \"addis %0,%2,%v3\";\n+\t}\n+    }\n+\n+  else if (GET_CODE (addis_value) == HIGH)\n+    {\n+      rtx value = XEXP (addis_value, 0);\n+      if (GET_CODE (value) == UNSPEC && XINT (value, 1) == UNSPEC_TOCREL)\n+\t{\n+\t  fuse_ops[2] = XVECEXP (value, 0, 0);\t\t/* symbol ref.  */\n+\t  fuse_ops[3] = XVECEXP (value, 0, 1);\t\t/* TOC register.  */\n+\t  if (TARGET_ELF)\n+\t    addis_str = \"addis %0,%3,%2@toc@ha\";\n+\n+\t  else if (TARGET_XCOFF)\n+\t    addis_str = \"addis %0,%2@u(%3)\";\n+\n+\t  else\n+\t    gcc_unreachable ();\n+\t}\n+\n+      else if (GET_CODE (value) == PLUS)\n+\t{\n+\t  rtx op0 = XEXP (value, 0);\n+\t  rtx op1 = XEXP (value, 1);\n+\n+\t  if (GET_CODE (op0) == UNSPEC\n+\t      && XINT (op0, 1) == UNSPEC_TOCREL\n+\t      && CONST_INT_P (op1))\n+\t    {\n+\t      fuse_ops[2] = XVECEXP (op0, 0, 0);\t/* symbol ref.  */\n+\t      fuse_ops[3] = XVECEXP (op0, 0, 1);\t/* TOC register.  */\n+\t      fuse_ops[4] = op1;\n+\t      if (TARGET_ELF)\n+\t\taddis_str = \"addis %0,%3,%2+%4@toc@ha\";\n+\n+\t      else if (TARGET_XCOFF)\n+\t\taddis_str = \"addis %0,%2+%4@u(%3)\";\n+\n+\t      else\n+\t\tgcc_unreachable ();\n+\t    }\n+\t}\n+\n+      else if (satisfies_constraint_L (value))\n+\t{\n+\t  fuse_ops[2] = value;\n+\t  addis_str = \"lis %0,%v2\";\n+\t}\n+\n+      else if (TARGET_ELF && !TARGET_POWERPC64 && CONSTANT_P (value))\n+\t{\n+\t  fuse_ops[2] = value;\n+\t  addis_str = \"lis %0,%2@ha\";\n+\t}\n+    }\n+\n+  if (!addis_str)\n+    fatal_insn (\"Could not generate addis value for fusion\", addis_value);\n+\n+  sprintf (insn_template, \"%s\\t\\t%s gpr load fusion, type %s, addis reg %%1\",\n+\t   addis_str, comment_str, mode_name);\n+  output_asm_insn (insn_template, fuse_ops);\n+\n+  if (CONST_INT_P (load_offset) && satisfies_constraint_I (load_offset))\n+    {\n+      sprintf (insn_template, \"%s %%0,%%1(%%0)\", load_str);\n+      fuse_ops[1] = load_offset;\n+      output_asm_insn (insn_template, fuse_ops);\n+    }\n+\n+  else if (GET_CODE (load_offset) == UNSPEC\n+\t   && XINT (load_offset, 1) == UNSPEC_TOCREL)\n+    {\n+      if (TARGET_ELF)\n+\tsprintf (insn_template, \"%s %%0,%%1@toc@l(%%0)\", load_str);\n+\n+      else if (TARGET_XCOFF)\n+\tsprintf (insn_template, \"%s %%0,%%1@l(%%0)\", load_str);\n+\n+      else\n+\tgcc_unreachable ();\n+\n+      fuse_ops[1] = XVECEXP (load_offset, 0, 0);\n+      output_asm_insn (insn_template, fuse_ops);\n+    }\n+\n+  else if (GET_CODE (load_offset) == PLUS\n+\t   && GET_CODE (XEXP (load_offset, 0)) == UNSPEC\n+\t   && XINT (XEXP (load_offset, 0), 1) == UNSPEC_TOCREL\n+\t   && CONST_INT_P (XEXP (load_offset, 1)))\n+    {\n+      rtx tocrel_unspec = XEXP (load_offset, 0);\n+      if (TARGET_ELF)\n+\tsprintf (insn_template, \"%s %%0,%%1+%%2@toc@l(%%0)\", load_str);\n+\n+      else if (TARGET_XCOFF)\n+\tsprintf (insn_template, \"%s %%0,%%1+%%2@l(%%0)\", load_str);\n+\n+      else\n+\tgcc_unreachable ();\n+\n+      fuse_ops[1] = XVECEXP (tocrel_unspec, 0, 0);\n+      fuse_ops[2] = XEXP (load_offset, 1);\n+      output_asm_insn (insn_template, fuse_ops);\n+    }\n+\n+  else if (TARGET_ELF && !TARGET_POWERPC64 && CONSTANT_P (load_offset))\n+    {\n+      sprintf (insn_template, \"%s %%0,%%1@l(%%0)\", load_str);\n+\n+      fuse_ops[1] = load_offset;\n+      output_asm_insn (insn_template, fuse_ops);\n+    }\n+\n+  else\n+    fatal_insn (\"Unable to generate load offset for fusion\", load_offset);\n+\n+  return \"\";\n+}\n+\n \f\n struct gcc_target targetm = TARGET_INITIALIZER;\n "}, {"sha": "98c43df3d81d8fd762d32a8f055290693e331f0f", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d86e633abc4aeb1be6c443b3dc3593629491a838/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d86e633abc4aeb1be6c443b3dc3593629491a838/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=d86e633abc4aeb1be6c443b3dc3593629491a838", "patch": "@@ -15770,6 +15770,113 @@\n     return \"mftb %0\";\n })\n \n+\f\n+;; Power8 fusion support for fusing an addis instruction with a D-form load of\n+;; a GPR.  The addis instruction must be adjacent to the load, and use the same\n+;; register that is being loaded.  The fused ops must be physically adjacent.\n+\n+;; GPR fusion for single word integer types\n+\n+(define_peephole\n+  [(set (match_operand:P 0 \"base_reg_operand\" \"\")\n+\t(match_operand:P 1 \"fusion_gpr_addis\" \"\"))\n+   (set (match_operand:INT1 2 \"base_reg_operand\" \"\")\n+\t(match_operand:INT1 3 \"fusion_gpr_mem_load\" \"\"))]\n+  \"TARGET_P8_FUSION\n+   && fusion_gpr_load_p (operands[0], operands[1], operands[2], operands[3],\n+\t\t\t insn)\"\n+{\n+  return emit_fusion_gpr_load (operands[0], operands[1], operands[2],\n+\t\t\t       operands[3]);\n+}\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"8\")])\n+\n+(define_peephole\n+  [(set (match_operand:DI 0 \"base_reg_operand\" \"\")\n+\t(match_operand:DI 1 \"fusion_gpr_addis\" \"\"))\n+   (set (match_operand:DI 2 \"base_reg_operand\" \"\")\n+\t(zero_extend:DI (match_operand:QHSI 3 \"fusion_gpr_mem_load\" \"\")))]\n+  \"TARGET_P8_FUSION && TARGET_POWERPC64\n+   && fusion_gpr_load_p (operands[0], operands[1], operands[2], operands[3],\n+\t\t\t insn)\"\n+{\n+  return emit_fusion_gpr_load (operands[0], operands[1], operands[2],\n+\t\t\t       operands[3]);\n+}\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"8\")])\n+\n+;; Power8 does not fuse a sign extending load, so convert the sign extending\n+;; load into a zero extending load, and do an explicit sign extension.  Don't\n+;; do this if we are trying to optimize for space.  Do this as a peephole2 to\n+;; allow final rtl optimizations and scheduling to move the sign extend.\n+(define_peephole2\n+  [(set (match_operand:DI 0 \"base_reg_operand\" \"\")\n+\t(match_operand:DI 1 \"fusion_gpr_addis\" \"\"))\n+   (set (match_operand:DI 2 \"base_reg_operand\" \"\")\n+\t(sign_extend:DI (match_operand:HSI 3 \"fusion_gpr_mem_load\" \"\")))]\n+  \"TARGET_P8_FUSION && TARGET_P8_FUSION_SIGN && TARGET_POWERPC64\n+   && fusion_gpr_load_p (operands[0], operands[1], operands[2], operands[3],\n+\t\t\t NULL_RTX)\"\n+  [(set (match_dup 0) (match_dup 1))\n+   (set (match_dup 4) (match_dup 3))\n+   (set (match_dup 2) (sign_extend:DI (match_dup 4)))]\n+{\n+  unsigned int offset\n+    = (BYTES_BIG_ENDIAN ? 8 - GET_MODE_SIZE (<MODE>mode) : 0);\n+\n+  operands[4] = simplify_subreg (<MODE>mode, operands[2], DImode,\n+\t\t\t\t offset);\n+})\n+\n+(define_peephole\n+  [(set (match_operand:P 0 \"base_reg_operand\" \"\")\n+\t(match_operand:P 1 \"fusion_gpr_addis\" \"\"))\n+   (set (match_operand:SI 2 \"base_reg_operand\" \"\")\n+\t(zero_extend:SI (match_operand:QHI 3 \"fusion_gpr_mem_load\" \"\")))]\n+  \"TARGET_P8_FUSION\n+   && fusion_gpr_load_p (operands[0], operands[1], operands[2], operands[3],\n+\t\t\t insn)\"\n+{\n+  return emit_fusion_gpr_load (operands[0], operands[1], operands[2],\n+\t\t\t       operands[3]);\n+}\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"8\")])\n+\n+(define_peephole2\n+  [(set (match_operand:P 0 \"base_reg_operand\" \"\")\n+\t(match_operand:P 1 \"fusion_gpr_addis\" \"\"))\n+   (set (match_operand:SI 2 \"base_reg_operand\" \"\")\n+\t(sign_extend:SI (match_operand:HI 3 \"fusion_gpr_mem_load\" \"\")))]\n+  \"TARGET_P8_FUSION && TARGET_P8_FUSION_SIGN\n+   && fusion_gpr_load_p (operands[0], operands[1], operands[2], operands[3],\n+\t\t\t NULL_RTX)\"\n+  [(set (match_dup 0) (match_dup 1))\n+   (set (match_dup 4) (match_dup 3))\n+   (set (match_dup 2) (sign_extend:SI (match_dup 4)))]\n+{\n+  unsigned int offset = (BYTES_BIG_ENDIAN ? 2 : 0);\n+\n+  operands[4] = simplify_subreg (HImode, operands[2], SImode, offset);\n+})\n+\n+(define_peephole\n+  [(set (match_operand:P 0 \"base_reg_operand\" \"\")\n+\t(match_operand:P 1 \"fusion_gpr_addis\" \"\"))\n+   (set (match_operand:HI 2 \"base_reg_operand\" \"\")\n+\t(zero_extend:HI (match_operand:QI 3 \"fusion_gpr_mem_load\" \"\")))]\n+  \"TARGET_P8_FUSION\n+   && fusion_gpr_load_p (operands[0], operands[1], operands[2], operands[3],\n+\t\t\t insn)\"\n+{\n+  return emit_fusion_gpr_load (operands[0], operands[1], operands[2],\n+\t\t\t       operands[3]);\n+}\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"8\")])\n+\n \f\n \n (include \"sync.md\")"}, {"sha": "11d6b8bb4d09c41377572d8cec86f3751971d579", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d86e633abc4aeb1be6c443b3dc3593629491a838/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d86e633abc4aeb1be6c443b3dc3593629491a838/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=d86e633abc4aeb1be6c443b3dc3593629491a838", "patch": "@@ -40,6 +40,14 @@\n ;; it to use gprs as well as vsx registers.\n (define_mode_iterator VSX_M [V16QI V8HI V4SI V2DI V4SF V2DF])\n \n+(define_mode_iterator VSX_M2 [V16QI\n+\t\t\t      V8HI\n+\t\t\t      V4SI\n+\t\t\t      V2DI\n+\t\t\t      V4SF\n+\t\t\t      V2DF\n+\t\t\t      (TI\t\"TARGET_VSX_TIMODE\")])\n+\n ;; Map into the appropriate load/store name based on the type\n (define_mode_attr VSm  [(V16QI \"vw4\")\n \t\t\t(V8HI  \"vw4\")\n@@ -1446,3 +1454,27 @@\n }\"\n   [(set_attr \"length\" \"20\")\n    (set_attr \"type\" \"veccomplex\")])\n+\n+\f\n+;; Power8 Vector fusion.  The fused ops must be physically adjacent.\n+(define_peephole\n+  [(set (match_operand:P 0 \"base_reg_operand\" \"\")\n+\t(match_operand:P 1 \"short_cint_operand\" \"\"))\n+   (set (match_operand:VSX_M2 2 \"vsx_register_operand\" \"\")\n+\t(mem:VSX_M2 (plus:P (match_dup 0)\n+\t\t\t    (match_operand:P 3 \"int_reg_operand\" \"\"))))]\n+  \"TARGET_P8_FUSION\"\n+  \"li %0,%1\\t\\t\\t# vector load fusion\\;lx<VSX_M2:VSm>x %x2,%0,%3\"  \n+  [(set_attr \"length\" \"8\")\n+   (set_attr \"type\" \"vecload\")])\n+\n+(define_peephole\n+  [(set (match_operand:P 0 \"base_reg_operand\" \"\")\n+\t(match_operand:P 1 \"short_cint_operand\" \"\"))\n+   (set (match_operand:VSX_M2 2 \"vsx_register_operand\" \"\")\n+\t(mem:VSX_M2 (plus:P (match_operand:P 3 \"int_reg_operand\" \"\")\n+\t\t\t    (match_dup 0))))]\n+  \"TARGET_P8_FUSION\"\n+  \"li %0,%1\\t\\t\\t# vector load fusion\\;lx<VSX_M2:VSm>x %x2,%0,%3\"  \n+  [(set_attr \"length\" \"8\")\n+   (set_attr \"type\" \"vecload\")])"}, {"sha": "846c9664fbde69c6f2d2cd31b20a35daea32e3a9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d86e633abc4aeb1be6c443b3dc3593629491a838/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d86e633abc4aeb1be6c443b3dc3593629491a838/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d86e633abc4aeb1be6c443b3dc3593629491a838", "patch": "@@ -1,3 +1,8 @@\n+2013-07-31  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* gcc.target/powerpc/fusion.c: New file, test power8 fusion\n+\tsupport.\n+\n 2013-07-31  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* gcc.target/mips/mips.exp (mips-dg-options): Test for mabicalls"}, {"sha": "3bea1c9f5a8fd33a6ff7d3462f86e407335fc814", "filename": "gcc/testsuite/gcc.target/powerpc/fusion.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d86e633abc4aeb1be6c443b3dc3593629491a838/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffusion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d86e633abc4aeb1be6c443b3dc3593629491a838/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffusion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffusion.c?ref=d86e633abc4aeb1be6c443b3dc3593629491a838", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-options \"-mcpu=power7 -mtune=power8 -O3\" } */\n+\n+#define LARGE 0x12345\n+\n+int fusion_uchar (unsigned char *p){ return p[LARGE]; }\n+int fusion_schar (signed char *p){ return p[LARGE]; }\n+int fusion_ushort (unsigned short *p){ return p[LARGE]; }\n+int fusion_short (short *p){ return p[LARGE]; }\n+int fusion_int (int *p){ return p[LARGE]; }\n+unsigned fusion_uns (unsigned *p){ return p[LARGE]; }\n+\n+vector double fusion_vector (vector double *p) { return p[2]; }\n+\n+/* { dg-final { scan-assembler-times \"gpr load fusion\"    6 } } */\n+/* { dg-final { scan-assembler-times \"vector load fusion\" 1 } } */\n+/* { dg-final { scan-assembler-times \"lbz\"                2 } } */\n+/* { dg-final { scan-assembler-times \"extsb\"              1 } } */\n+/* { dg-final { scan-assembler-times \"lhz\"                2 } } */\n+/* { dg-final { scan-assembler-times \"extsh\"              1 } } */\n+/* { dg-final { scan-assembler-times \"lwz\"                2 } } */"}]}