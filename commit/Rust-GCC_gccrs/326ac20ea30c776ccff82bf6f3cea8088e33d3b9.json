{"sha": "326ac20ea30c776ccff82bf6f3cea8088e33d3b9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzI2YWMyMGVhMzBjNzc2Y2NmZjgyYmY2ZjNjZWE4MDg4ZTMzZDNiOQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-09T14:31:55Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-09T14:31:55Z"}, "message": "[AArch64] Use vec_perm_indices helper routines\n\nThis patch makes the AArch64 vec_perm_const code use the new\nvec_perm_indices routines, instead of checking each element individually.\nThis means that they extend naturally to variable-length vectors.\n\nAlso, aarch64_evpc_dup was the only function that generated rtl when\ntesting_p is true, and that looked accidental.  The patch adds the\nmissing check and then replaces the gen_rtx_REG/start_sequence/\nend_sequence stuff with an assert that no rtl is generated.\n\n2018-01-09  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* config/aarch64/aarch64.c (aarch64_evpc_trn): Use d.perm.series_p\n\tinstead of checking each element individually.\n\t(aarch64_evpc_uzp): Likewise.\n\t(aarch64_evpc_zip): Likewise.\n\t(aarch64_evpc_ext): Likewise.\n\t(aarch64_evpc_rev): Likewise.\n\t(aarch64_evpc_dup): Test the encoding for a single duplicated element,\n\tinstead of checking each element individually.  Return true without\n\tgenerating rtl if\n\t(aarch64_vectorize_vec_perm_const): Use all_from_input_p to test\n\twhether all selected elements come from the same input, instead of\n\tchecking each element individually.  Remove calls to gen_rtx_REG,\n\tstart_sequence and end_sequence and instead assert that no rtl is\n\tgenerated.\n\nFrom-SVN: r256385", "tree": {"sha": "98be6ba5839fc0b41fccb054283e55db367400ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/98be6ba5839fc0b41fccb054283e55db367400ac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/326ac20ea30c776ccff82bf6f3cea8088e33d3b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/326ac20ea30c776ccff82bf6f3cea8088e33d3b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/326ac20ea30c776ccff82bf6f3cea8088e33d3b9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/326ac20ea30c776ccff82bf6f3cea8088e33d3b9/comments", "author": null, "committer": null, "parents": [{"sha": "509bb9b647516bbf6af77778d2ffe7e756be26df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/509bb9b647516bbf6af77778d2ffe7e756be26df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/509bb9b647516bbf6af77778d2ffe7e756be26df"}], "stats": {"total": 188, "additions": 66, "deletions": 122}, "files": [{"sha": "5c7b04604b41544cdadd5061ac268110ad7243dc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/326ac20ea30c776ccff82bf6f3cea8088e33d3b9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/326ac20ea30c776ccff82bf6f3cea8088e33d3b9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=326ac20ea30c776ccff82bf6f3cea8088e33d3b9", "patch": "@@ -1,3 +1,20 @@\n+2018-01-09  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* config/aarch64/aarch64.c (aarch64_evpc_trn): Use d.perm.series_p\n+\tinstead of checking each element individually.\n+\t(aarch64_evpc_uzp): Likewise.\n+\t(aarch64_evpc_zip): Likewise.\n+\t(aarch64_evpc_ext): Likewise.\n+\t(aarch64_evpc_rev): Likewise.\n+\t(aarch64_evpc_dup): Test the encoding for a single duplicated element,\n+\tinstead of checking each element individually.  Return true without\n+\tgenerating rtl if\n+\t(aarch64_vectorize_vec_perm_const): Use all_from_input_p to test\n+\twhether all selected elements come from the same input, instead of\n+\tchecking each element individually.  Remove calls to gen_rtx_REG,\n+\tstart_sequence and end_sequence and instead assert that no rtl is\n+\tgenerated.\n+\n 2018-01-09  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* config/aarch64/aarch64.c (aarch64_legitimate_constant_p): Fix"}, {"sha": "0aea458c4a26f2a680e6eecd63ba50caa177fc86", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 49, "deletions": 122, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/326ac20ea30c776ccff82bf6f3cea8088e33d3b9/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/326ac20ea30c776ccff82bf6f3cea8088e33d3b9/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=326ac20ea30c776ccff82bf6f3cea8088e33d3b9", "patch": "@@ -13317,7 +13317,7 @@ aarch64_expand_vec_perm (rtx target, rtx op0, rtx op1, rtx sel,\n static bool\n aarch64_evpc_trn (struct expand_vec_perm_d *d)\n {\n-  unsigned int i, odd, mask, nelt = d->perm.length ();\n+  unsigned int odd, nelt = d->perm.length ();\n   rtx out, in0, in1, x;\n   machine_mode vmode = d->vmode;\n \n@@ -13326,21 +13326,11 @@ aarch64_evpc_trn (struct expand_vec_perm_d *d)\n \n   /* Note that these are little-endian tests.\n      We correct for big-endian later.  */\n-  if (d->perm[0] == 0)\n-    odd = 0;\n-  else if (d->perm[0] == 1)\n-    odd = 1;\n-  else\n+  odd = d->perm[0];\n+  if ((odd != 0 && odd != 1)\n+      || !d->perm.series_p (0, 2, odd, 2)\n+      || !d->perm.series_p (1, 2, nelt + odd, 2))\n     return false;\n-  mask = (d->one_vector_p ? nelt - 1 : 2 * nelt - 1);\n-\n-  for (i = 0; i < nelt; i += 2)\n-    {\n-      if (d->perm[i] != i + odd)\n-\treturn false;\n-      if (d->perm[i + 1] != ((i + nelt + odd) & mask))\n-\treturn false;\n-    }\n \n   /* Success!  */\n   if (d->testing_p)\n@@ -13364,7 +13354,7 @@ aarch64_evpc_trn (struct expand_vec_perm_d *d)\n static bool\n aarch64_evpc_uzp (struct expand_vec_perm_d *d)\n {\n-  unsigned int i, odd, mask, nelt = d->perm.length ();\n+  unsigned int odd;\n   rtx out, in0, in1, x;\n   machine_mode vmode = d->vmode;\n \n@@ -13373,20 +13363,10 @@ aarch64_evpc_uzp (struct expand_vec_perm_d *d)\n \n   /* Note that these are little-endian tests.\n      We correct for big-endian later.  */\n-  if (d->perm[0] == 0)\n-    odd = 0;\n-  else if (d->perm[0] == 1)\n-    odd = 1;\n-  else\n+  odd = d->perm[0];\n+  if ((odd != 0 && odd != 1)\n+      || !d->perm.series_p (0, 1, odd, 2))\n     return false;\n-  mask = (d->one_vector_p ? nelt - 1 : 2 * nelt - 1);\n-\n-  for (i = 0; i < nelt; i++)\n-    {\n-      unsigned elt = (i * 2 + odd) & mask;\n-      if (d->perm[i] != elt)\n-\treturn false;\n-    }\n \n   /* Success!  */\n   if (d->testing_p)\n@@ -13410,7 +13390,7 @@ aarch64_evpc_uzp (struct expand_vec_perm_d *d)\n static bool\n aarch64_evpc_zip (struct expand_vec_perm_d *d)\n {\n-  unsigned int i, high, mask, nelt = d->perm.length ();\n+  unsigned int high, nelt = d->perm.length ();\n   rtx out, in0, in1, x;\n   machine_mode vmode = d->vmode;\n \n@@ -13419,25 +13399,11 @@ aarch64_evpc_zip (struct expand_vec_perm_d *d)\n \n   /* Note that these are little-endian tests.\n      We correct for big-endian later.  */\n-  high = nelt / 2;\n-  if (d->perm[0] == high)\n-    /* Do Nothing.  */\n-    ;\n-  else if (d->perm[0] == 0)\n-    high = 0;\n-  else\n+  high = d->perm[0];\n+  if ((high != 0 && high * 2 != nelt)\n+      || !d->perm.series_p (0, 2, high, 1)\n+      || !d->perm.series_p (1, 2, high + nelt, 1))\n     return false;\n-  mask = (d->one_vector_p ? nelt - 1 : 2 * nelt - 1);\n-\n-  for (i = 0; i < nelt / 2; i++)\n-    {\n-      unsigned elt = (i + high) & mask;\n-      if (d->perm[i * 2] != elt)\n-\treturn false;\n-      elt = (elt + nelt) & mask;\n-      if (d->perm[i * 2 + 1] != elt)\n-\treturn false;\n-    }\n \n   /* Success!  */\n   if (d->testing_p)\n@@ -13462,23 +13428,14 @@ aarch64_evpc_zip (struct expand_vec_perm_d *d)\n static bool\n aarch64_evpc_ext (struct expand_vec_perm_d *d)\n {\n-  unsigned int i, nelt = d->perm.length ();\n+  unsigned int nelt = d->perm.length ();\n   rtx offset;\n \n   unsigned int location = d->perm[0]; /* Always < nelt.  */\n \n   /* Check if the extracted indices are increasing by one.  */\n-  for (i = 1; i < nelt; i++)\n-    {\n-      unsigned int required = location + i;\n-      if (d->one_vector_p)\n-        {\n-          /* We'll pass the same vector in twice, so allow indices to wrap.  */\n-\t  required &= (nelt - 1);\n-\t}\n-      if (d->perm[i] != required)\n-        return false;\n-    }\n+  if (!d->perm.series_p (0, 1, location, 1))\n+    return false;\n \n   /* Success! */\n   if (d->testing_p)\n@@ -13510,7 +13467,7 @@ aarch64_evpc_ext (struct expand_vec_perm_d *d)\n static bool\n aarch64_evpc_rev (struct expand_vec_perm_d *d)\n {\n-  unsigned int i, j, diff, size, unspec, nelt = d->perm.length ();\n+  unsigned int i, diff, size, unspec;\n \n   if (!d->one_vector_p)\n     return false;\n@@ -13526,18 +13483,10 @@ aarch64_evpc_rev (struct expand_vec_perm_d *d)\n   else\n     return false;\n \n-  for (i = 0; i < nelt ; i += diff + 1)\n-    for (j = 0; j <= diff; j += 1)\n-      {\n-\t/* This is guaranteed to be true as the value of diff\n-\t   is 7, 3, 1 and we should have enough elements in the\n-\t   queue to generate this.  Getting a vector mask with a\n-\t   value of diff other than these values implies that\n-\t   something is wrong by the time we get here.  */\n-\tgcc_assert (i + j < nelt);\n-\tif (d->perm[i + j] != i + diff - j)\n-\t  return false;\n-      }\n+  unsigned int step = diff + 1;\n+  for (i = 0; i < step; ++i)\n+    if (!d->perm.series_p (i, step, diff - i, step))\n+      return false;\n \n   /* Success! */\n   if (d->testing_p)\n@@ -13554,15 +13503,17 @@ aarch64_evpc_dup (struct expand_vec_perm_d *d)\n   rtx out = d->target;\n   rtx in0;\n   machine_mode vmode = d->vmode;\n-  unsigned int i, elt, nelt = d->perm.length ();\n+  unsigned int elt;\n   rtx lane;\n \n+  if (d->perm.encoding ().encoded_nelts () != 1)\n+    return false;\n+\n+  /* Success! */\n+  if (d->testing_p)\n+    return true;\n+\n   elt = d->perm[0];\n-  for (i = 1; i < nelt; i++)\n-    {\n-      if (elt != d->perm[i])\n-\treturn false;\n-    }\n \n   /* The generic preparation in aarch64_expand_vec_perm_const_1\n      swaps the operand order and the permute indices if it finds\n@@ -13650,61 +13601,37 @@ aarch64_vectorize_vec_perm_const (machine_mode vmode, rtx target, rtx op0,\n \t\t\t\t  rtx op1, const vec_perm_indices &sel)\n {\n   struct expand_vec_perm_d d;\n-  unsigned int i, which;\n-\n-  d.vmode = vmode;\n-  d.target = target;\n-  d.op0 = op0;\n-  d.op1 = op1;\n-  d.testing_p = !target;\n \n-  /* Calculate whether all elements are in one vector.  */\n-  unsigned int nelt = sel.length ();\n-  for (i = which = 0; i < nelt; ++i)\n+  /* Check whether the mask can be applied to a single vector.  */\n+  if (op0 && rtx_equal_p (op0, op1))\n+    d.one_vector_p = true;\n+  else if (sel.all_from_input_p (0))\n     {\n-      unsigned int ei = sel[i] & (2 * nelt - 1);\n-      which |= (ei < nelt ? 1 : 2);\n+      d.one_vector_p = true;\n+      op1 = op0;\n     }\n-\n-  switch (which)\n+  else if (sel.all_from_input_p (1))\n     {\n-    default:\n-      gcc_unreachable ();\n-\n-    case 3:\n-      d.one_vector_p = false;\n-      if (d.testing_p || !rtx_equal_p (op0, op1))\n-\tbreak;\n-\n-      /* The elements of PERM do not suggest that only the first operand\n-\t is used, but both operands are identical.  Allow easier matching\n-\t of the permutation by folding the permutation into the single\n-\t input vector.  */\n-      /* Fall Through.  */\n-    case 2:\n-      d.op0 = op1;\n-      d.one_vector_p = true;\n-      break;\n-\n-    case 1:\n-      d.op1 = op0;\n       d.one_vector_p = true;\n-      break;\n+      op0 = op1;\n     }\n+  else\n+    d.one_vector_p = false;\n \n-  d.perm.new_vector (sel.encoding (), d.one_vector_p ? 1 : 2, nelt);\n+  d.perm.new_vector (sel.encoding (), d.one_vector_p ? 1 : 2,\n+\t\t     sel.nelts_per_input ());\n+  d.vmode = vmode;\n+  d.target = target;\n+  d.op0 = op0;\n+  d.op1 = op1;\n+  d.testing_p = !target;\n \n   if (!d.testing_p)\n     return aarch64_expand_vec_perm_const_1 (&d);\n \n-  d.target = gen_raw_REG (d.vmode, LAST_VIRTUAL_REGISTER + 1);\n-  d.op1 = d.op0 = gen_raw_REG (d.vmode, LAST_VIRTUAL_REGISTER + 2);\n-  if (!d.one_vector_p)\n-    d.op1 = gen_raw_REG (d.vmode, LAST_VIRTUAL_REGISTER + 3);\n-\n-  start_sequence ();\n+  rtx_insn *last = get_last_insn ();\n   bool ret = aarch64_expand_vec_perm_const_1 (&d);\n-  end_sequence ();\n+  gcc_assert (last == get_last_insn ());\n \n   return ret;\n }"}]}