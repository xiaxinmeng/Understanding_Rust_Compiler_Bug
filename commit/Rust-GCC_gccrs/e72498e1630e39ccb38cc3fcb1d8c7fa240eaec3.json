{"sha": "e72498e1630e39ccb38cc3fcb1d8c7fa240eaec3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTcyNDk4ZTE2MzBlMzljY2IzOGNjM2ZjYjFkOGM3ZmEyNDBlYWVjMw==", "commit": {"author": {"name": "Jan Brittenson", "email": "bson@gnu.org", "date": "1993-09-21T21:22:27Z"}, "committer": {"name": "Jan Brittenson", "email": "bson@gnu.org", "date": "1993-09-21T21:22:27Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r5377", "tree": {"sha": "ca60114d6c444248b449e0d9d98ec45f872bd777", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ca60114d6c444248b449e0d9d98ec45f872bd777"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e72498e1630e39ccb38cc3fcb1d8c7fa240eaec3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e72498e1630e39ccb38cc3fcb1d8c7fa240eaec3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e72498e1630e39ccb38cc3fcb1d8c7fa240eaec3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e72498e1630e39ccb38cc3fcb1d8c7fa240eaec3/comments", "author": null, "committer": null, "parents": [{"sha": "683e6ccd1d25dc749a576119eb82346e352e09a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/683e6ccd1d25dc749a576119eb82346e352e09a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/683e6ccd1d25dc749a576119eb82346e352e09a4"}], "stats": {"total": 180, "additions": 180, "deletions": 0}, "files": [{"sha": "c0bf3357bf224d4b5adf15c7400e5696a70bde4d", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e72498e1630e39ccb38cc3fcb1d8c7fa240eaec3/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e72498e1630e39ccb38cc3fcb1d8c7fa240eaec3/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=e72498e1630e39ccb38cc3fcb1d8c7fa240eaec3", "patch": "@@ -2299,3 +2299,35 @@ strict_low_part_peephole_ok (mode, first_insn, target)\n \n   return 0;\n }\n+\f\n+/* Emit the machine-code interface trampoline at the beginning of a byte\n+   coded function.  The argument is a label name of the interpreter\n+   bytecode callinfo structure; the return value is a label name for\n+   the beginning of the actual bytecode.  */\n+char *\n+bc_emit_trampoline (callinfo)\n+  char *callinfo;\n+{\n+  short insn;\n+  int zero = 0;\n+  char mylab[256];\n+  static int n;\n+\n+  sprintf (mylab, \"*LB%d\", n++);\n+\n+  /* Push a reference to the callinfo structure.  */\n+  insn = 0x4879;\t\t/* pea xxx.L */\n+  seg_data (trampoline, (char *) &insn, sizeof insn);\n+  seg_refsym (trampoline, callinfo, 0);\n+\n+  /* Call __interp, pop arguments, and return.  */\n+  insn = 0x4EB9;\t\t/* jsr xxx.L  */\n+  seg_data (trampoline, (char *) &insn, sizeof insn);\n+  seg_refsym (trampoline, \"__callint\", 0);\n+  insn = 0x588F;\t\t/* addql #4, sp */\n+  seg_data (trampoline, (char *) &insn, sizeof insn);\n+  insn = 0x4E75;\t\t/* rts */\n+  seg_data (trampoline, (char *) &insn, sizeof insn);\n+  seg_defsym (bytecode, mylab);\n+  return sym_lookup (mylab)->name;\n+}"}, {"sha": "4d2adef604a0cc79709ef893b4d5eaf7e261cc4a", "filename": "gcc/config/m68k/m68k.h", "status": "modified", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e72498e1630e39ccb38cc3fcb1d8c7fa240eaec3/gcc%2Fconfig%2Fm68k%2Fm68k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e72498e1630e39ccb38cc3fcb1d8c7fa240eaec3/gcc%2Fconfig%2Fm68k%2Fm68k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.h?ref=e72498e1630e39ccb38cc3fcb1d8c7fa240eaec3", "patch": "@@ -1809,6 +1809,154 @@ do { long l;\t\t\t\t\t\t\\\n #define PRINT_OPERAND_ADDRESS(FILE, ADDR) print_operand_address (FILE, ADDR)\n \n \n+/* Definitions for generating bytecode */\n+\n+/* Just so it's known this target is supported by the bytecode generator.\n+   If this define isn't found anywhere in the target config files, then\n+   dummy stubs are supplied by bytecode.h, and any attempt to use\n+   -fbytecode will result in an error message. */\n+\n+#define TARGET_SUPPORTS_BYTECODE\n+\n+/* Minimal segment alignment within sections is 8 units. */\n+#define MACHINE_SEG_ALIGN 3\n+\n+/* Integer alignment is two units. */\n+#define INT_ALIGN 2\n+\n+/* Pointer alignment is eight units. */\n+#define PTR_ALIGN 3\n+\n+/* Global symbols begin with `_' */\n+#define NAMES_HAVE_UNDERSCORES\n+\n+/* BC_xxx below are similar to their ASM_xxx counterparts above. */\n+#define BC_GLOBALIZE_LABEL(FP, NAME) bc_globalize_label(NAME)\n+\n+#define BC_OUTPUT_COMMON(FP, NAME, SIZE, ROUNDED) \\\n+  do { bc_emit_common(NAME, ROUNDED); bc_globalize_label(NAME); } while (0)\n+\n+#define BC_OUTPUT_LOCAL(FP, NAME, SIZE, ROUNDED) \\\n+  bc_emit_common(NAME, ROUNDED)\n+\n+#define BC_OUTPUT_ALIGN(FP, ALIGN) bc_align(ALIGN)\n+\n+#define BC_OUTPUT_LABEL(FP, NAME) bc_emit_labeldef(NAME)\n+\n+#define BC_OUTPUT_SKIP(FP, SIZE) bc_emit_skip(SIZE)\n+\n+#define BC_OUTPUT_LABELREF(FP, NAME)\t\t\t\t\t      \\\n+  do {\t\t\t\t\t\t\t\t\t      \\\n+    char *foo = (char *) xmalloc(strlen(NAME) + 2);\t\t\t      \\\n+    strcpy(foo, \"_\");\t\t\t\t\t\t\t      \\\n+    strcat(foo, NAME);\t\t\t\t\t\t\t      \\\n+    bc_emit_labelref (foo);\t\t\t\t\t\t      \\\n+    free (foo);\t\t\t\t\t\t\t\t      \\\n+  } while (0)\n+\n+#define BC_OUTPUT_FLOAT(FP, VAL)\t\t\t\t\t      \\\n+  do {\t\t\t\t\t\t\t\t\t      \\\n+    float F = VAL;\t\t\t\t\t\t\t      \\\n+    bc_emit ((char *) &F, sizeof F);\t\t\t\t\t      \\\n+  } while (0)\n+\n+#define BC_OUTPUT_DOUBLE(FP, VAL)\t\t\t\t\t      \\\n+  do {\t\t\t\t\t\t\t\t\t      \\\n+    double D = VAL;\t\t\t\t\t\t\t      \\\n+    bc_emit ((char *) &D, sizeof D);\t\t\t\t\t      \\\n+  } while (0)\n+\n+#define BC_OUTPUT_BYTE(FP, VAL)\t\t\t\t\t      \\\n+  do {\t\t\t\t\t\t\t\t\t      \\\n+    char C = VAL;\t\t\t\t\t\t\t      \\\n+    bc_emit (&C, 1);\t\t\t\t\t\t\t      \\\n+  } while (0)\n+\n+\n+#define BC_OUTPUT_FILE ASM_OUTPUT_FILE\n+#define BC_OUTPUT_ASCII ASM_OUTPUT_ASCII\n+#define BC_OUTPUT_IDENT ASM_OUTPUT_IDENT\n+\n+/* Same as XSTR, but for bytecode */\n+#define BCXSTR(RTX)  ((RTX)->bc_label)\n+\n+\n+/* Flush bytecode buffer onto file */\n+#define BC_WRITE_FILE(FP) \\\n+{ \\\n+  fprintf (FP, \".text\\n\"); \\\n+  bc_seg_write (bc_text_seg, FP); \\\n+  fprintf(FP, \"\\n.data\\n\"); \\\n+  bc_seg_write (bc_data_seg, FP); \\\n+  bc_sym_write (FP);  /* do .globl, .bss, etc. */ \\\n+}\n+\n+/* Write one symbol */\n+#define BC_WRITE_SEGSYM(SEGSYM, FP) \\\n+{ \\\n+  prsym (FP, (SEGSYM)->sym->name); \\\n+  fprintf (FP, \":\\n\"); \\\n+}\n+\n+\n+/* Write one reloc entry */\n+#define BC_WRITE_RELOC_ENTRY(SEGRELOC, FP, OFFSET) \\\n+{ \\\n+  fprintf (FP, \"\\t.long \"); \\\n+  prsym (FP, (SEGRELOC)->sym->name); \\\n+  fprintf (FP, \" + %d\\n\", OFFSET); \\\n+}\n+\n+/* Start new line of bytecodes */\n+#define BC_START_BYTECODE_LINE(FP) \\\n+{ \\\n+  fprintf (FP, \"\\t.byte\"); \\\n+}\n+\n+/* Write one bytecode */\n+#define BC_WRITE_BYTECODE(SEP, VAL, FP) \\\n+{ \\\n+  fprintf (FP, \"%c0x%02X\", (SEP), (VAL) & 0xff); \\\n+}\n+\n+/* Write one bytecode RTL entry */\n+#define BC_WRITE_RTL(R, FP) \\\n+{ \\\n+  fprintf (FP, \"%s+%d/0x%08X\\n\", (R)->label, (R)->offset, (R)->bc_label); \\\n+}\n+\n+\n+/* Emit function entry trampoline */\n+#define BC_EMIT_TRAMPOLINE(TRAMPSEG, CALLINFO) \\\n+{ \\\n+  short insn; \\\n+ \\\n+  /* Push a reference to the callinfo structure.  */ \\\n+  insn = 0x4879;\t\t/* pea xxx.L */ \\\n+  seg_data (TRAMPSEG, (char *) &insn, sizeof insn); \\\n+  seg_refsym (TRAMPSEG, CALLINFO, 0); \\\n+ \\\n+  /* Call __interp, pop arguments, and return.  */ \\\n+  insn = 0x4eb9;\t\t/* jsr xxx.L  */ \\\n+  seg_data (TRAMPSEG, (char *) &insn, sizeof insn); \\\n+  seg_refsym (TRAMPSEG, \"__callint\", 0); \\\n+  insn = 0x588f;\t\t/* addql #4, sp */ \\\n+  seg_data (TRAMPSEG, (char *) &insn, sizeof insn); \\\n+  insn = 0x4e75;\t\t/* rts */ \\\n+  seg_data (TRAMPSEG, (char *) &insn, sizeof insn); \\\n+}\n+\n+\n+\n+#if 0\n+#define VALIDATE_STACK()  if (stack_depth < 0) abort ();\n+#else\n+#if 0\n+#define VALIDATE_STACK() \\\n+  fprintf (stderr, \" %%%d%%\", stack_depth);\n+#endif\n+#endif\n+\n /* Define functions defined in aux-output.c and used in templates.  */\n \n extern char *output_move_double ();"}]}