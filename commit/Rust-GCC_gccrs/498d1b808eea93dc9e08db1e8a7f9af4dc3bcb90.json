{"sha": "498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDk4ZDFiODA4ZWVhOTNkYzllMDhkYjFlOGE3ZjlhZjRkYzNiY2I5MA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-09-09T09:44:34Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-09-09T09:44:34Z"}, "message": "[multiple changes]\n\n2010-09-09  Robert Dewar  <dewar@adacore.com>\n\n\t* a-calfor.adb, sem_ch3.adb: Minor reformatting.\n\n2010-09-09  Robert Dewar  <dewar@adacore.com>\n\n\t* bindgen.adb (Gen_Restrictions_Ada): Avoid explicit enumeration ranges\n\t(Gen_Restrictions_C): Avoid explicit enumeration ranges\n\t(Set_String_Replace): New procedure\n\t* casing.ads (Known_Casing): New subtype declaration\n\t* prj-attr.ads (All_Case_Insensitive_Associative_Array): New subtype\n\tdeclaration\n\t* prj-dect.adb (Parse_Attribute_Declaration): Avoid enumeration range\n\t* prj-nmsc.adb (Check_Naming): Avoid unnecessary enumeration range\n\t* prj-strt.adb (Attribute_Reference): Avoid enumeration range test\n\t* prj.adb (Known_Casing): Moved to Casing spec (avoid enum range)\n\t* sem_ch13.adb (Adjust_Record_For_Reverse_Bit_Order): Avoid enumeration\n\tranges\n\t* sem_res.adb (Resolve_Range): Check for enumeration subrange style rule\n\t* sem_type.adb (Is_Array_Class_Record_Type): New.\n\t* style.ads (Check_Enumeration_Subrange): New procedure\n\t* styleg.adb (Check_Enumeration_Subrange): New procedure\n\t* styleg.ads (Check_Enumeration_Subrange): New procedure\n\t* stylesw.adb Add handling for Style_Check_Enumeration_Subranges\n\t* stylesw.ads (Style_Check_Enumeration_Subranges): New flag\n\t* usage.adb: Add line for -gnatyE\n\t* vms_data.ads: Add entries for [NO]ENUMERATION_RANGES\n\tAdd missing entry for NOBOOLEAN_OPERATORS\n\t* gnat_ugn.texi: Add documentation for -gnatyE\n\n2010-09-09  Robert Dewar  <dewar@adacore.com>\n\n\t* namet.adb (Initialize): Is now a dummy procedure\n\t(Reinitialize): New procedure\n\tCall Reinitialize from package initialization\n\t* namet.ads (Initialize): Is now a dummy procedure\n\t(Reinitialize): New procedure\n\t* clean.adb, gnat1drv.adb, gnatbind.adb, gnatcmd.adb, gnatlink.adb,\n\tgnatls.adb, gprep.adb, make.adb, prj-makr.adb: Remove obsolete call to\n\tNamet.Initialize.\n\n2010-09-09  Bob Duff  <duff@adacore.com>\n\n\t* sem_elab.adb, s-os_lib.ads: Minor comment fixes.\n\n2010-09-09  Robert Dewar  <dewar@adacore.com>\n\n\t* s-bitops.adb (Raise_Error): Add exception message\n\nFrom-SVN: r164058", "tree": {"sha": "076b2e23e245fd1f10b39412c01d91d898d23801", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/076b2e23e245fd1f10b39412c01d91d898d23801"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/comments", "author": null, "committer": null, "parents": [{"sha": "821b8ef47bc9cd196526e61b9426be24ffdd6eca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/821b8ef47bc9cd196526e61b9426be24ffdd6eca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/821b8ef47bc9cd196526e61b9426be24ffdd6eca"}], "stats": {"total": 1142, "additions": 662, "deletions": 480}, "files": [{"sha": "fd0ab2a9b271e77569788dc390361e4176609ad2", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90", "patch": "@@ -1,3 +1,52 @@\n+2010-09-09  Robert Dewar  <dewar@adacore.com>\n+\n+\t* a-calfor.adb, sem_ch3.adb: Minor reformatting.\n+\n+2010-09-09  Robert Dewar  <dewar@adacore.com>\n+\n+\t* bindgen.adb (Gen_Restrictions_Ada): Avoid explicit enumeration ranges\n+\t(Gen_Restrictions_C): Avoid explicit enumeration ranges\n+\t(Set_String_Replace): New procedure\n+\t* casing.ads (Known_Casing): New subtype declaration\n+\t* prj-attr.ads (All_Case_Insensitive_Associative_Array): New subtype\n+\tdeclaration\n+\t* prj-dect.adb (Parse_Attribute_Declaration): Avoid enumeration range\n+\t* prj-nmsc.adb (Check_Naming): Avoid unnecessary enumeration range\n+\t* prj-strt.adb (Attribute_Reference): Avoid enumeration range test\n+\t* prj.adb (Known_Casing): Moved to Casing spec (avoid enum range)\n+\t* sem_ch13.adb (Adjust_Record_For_Reverse_Bit_Order): Avoid enumeration\n+\tranges\n+\t* sem_res.adb (Resolve_Range): Check for enumeration subrange style rule\n+\t* sem_type.adb (Is_Array_Class_Record_Type): New.\n+\t* style.ads (Check_Enumeration_Subrange): New procedure\n+\t* styleg.adb (Check_Enumeration_Subrange): New procedure\n+\t* styleg.ads (Check_Enumeration_Subrange): New procedure\n+\t* stylesw.adb Add handling for Style_Check_Enumeration_Subranges\n+\t* stylesw.ads (Style_Check_Enumeration_Subranges): New flag\n+\t* usage.adb: Add line for -gnatyE\n+\t* vms_data.ads: Add entries for [NO]ENUMERATION_RANGES\n+\tAdd missing entry for NOBOOLEAN_OPERATORS\n+\t* gnat_ugn.texi: Add documentation for -gnatyE\n+\n+2010-09-09  Robert Dewar  <dewar@adacore.com>\n+\n+\t* namet.adb (Initialize): Is now a dummy procedure\n+\t(Reinitialize): New procedure\n+\tCall Reinitialize from package initialization\n+\t* namet.ads (Initialize): Is now a dummy procedure\n+\t(Reinitialize): New procedure\n+\t* clean.adb, gnat1drv.adb, gnatbind.adb, gnatcmd.adb, gnatlink.adb,\n+\tgnatls.adb, gprep.adb, make.adb, prj-makr.adb: Remove obsolete call to\n+\tNamet.Initialize.\n+\n+2010-09-09  Bob Duff  <duff@adacore.com>\n+\n+\t* sem_elab.adb, s-os_lib.ads: Minor comment fixes.\n+\n+2010-09-09  Robert Dewar  <dewar@adacore.com>\n+\n+\t* s-bitops.adb (Raise_Error): Add exception message\n+\n 2010-09-09  Robert Dewar  <dewar@adacore.com>\n \n \t* par-ch5.adb (Test_Statement_Required): Deal with Ada 2012 allowing no"}, {"sha": "39c3c0a2f799bb864bba38c23dba8b75d3ecd903", "filename": "gcc/ada/a-calfor.adb", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fa-calfor.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fa-calfor.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-calfor.adb?ref=498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2006-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2006-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -42,15 +42,15 @@ package body Ada.Calendar.Formatting is\n    --  independent, thus only one source file is needed for multiple targets.\n \n    procedure Check_Char (S : String; C : Character; Index : Integer);\n-   --  Subsidiary to the two versions of Value. Determine whether the\n-   --  input string S has character C at position Index. Raise\n-   --  Constraint_Error if there is a mismatch.\n+   --  Subsidiary to the two versions of Value. Determine whether the input\n+   --  string S has character C at position Index. Raise Constraint_Error if\n+   --  there is a mismatch.\n \n    procedure Check_Digit (S : String; Index : Integer);\n-   --  Subsidiary to the two versions of Value. Determine whether the\n-   --  character of string S at position Index is a digit. This catches\n-   --  invalid input such as 1983-*1-j3 u5:n7:k9 which should be\n-   --  1983-01-03 05:07:09. Raise Constraint_Error if there is a mismatch.\n+   --  Subsidiary to the two versions of Value. Determine whether the character\n+   --  of string S at position Index is a digit. This catches invalid input\n+   --  such as 1983-*1-j3 u5:n7:k9 which should be 1983-01-03 05:07:09. Raise\n+   --  Constraint_Error if there is a mismatch.\n \n    ----------------\n    -- Check_Char --\n@@ -781,8 +781,8 @@ package body Ada.Calendar.Formatting is\n          raise Constraint_Error;\n       end if;\n \n-      --  After the correct length has been determined, it is safe to\n-      --  copy the Date in order to avoid Date'First + N indexing.\n+      --  After the correct length has been determined, it is safe to copy the\n+      --  Date in order to avoid Date'First + N indexing.\n \n       D (1 .. Date'Length) := Date;\n \n@@ -865,8 +865,8 @@ package body Ada.Calendar.Formatting is\n          raise Constraint_Error;\n       end if;\n \n-      --  After the correct length has been determined, it is safe to\n-      --  copy the Elapsed_Time in order to avoid Date'First + N indexing.\n+      --  After the correct length has been determined, it is safe to copy the\n+      --  Elapsed_Time in order to avoid Date'First + N indexing.\n \n       D (1 .. Elapsed_Time'Length) := Elapsed_Time;\n "}, {"sha": "28a0453fb6c7dbc9ae9fb82ec5da0564a0cd36a8", "filename": "gcc/ada/bindgen.adb", "status": "modified", "additions": 36, "deletions": 61, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fbindgen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fbindgen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindgen.adb?ref=498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90", "patch": "@@ -349,6 +349,11 @@ package body Bindgen is\n    --  Sets characters of given string in Statement_Buffer, starting at the\n    --  Last + 1 position, and updating last past the string value.\n \n+   procedure Set_String_Replace (S : String);\n+   --  Replaces the last S'Length characters in the Statement_Buffer with\n+   --  the characters of S. The caller must ensure that these characters do\n+   --  in fact exist in the Statement_Buffer.\n+\n    procedure Set_Unit_Name;\n    --  Given a unit name in the Name_Buffer, copies it to Statement_Buffer,\n    --  starting at the Last + 1 position, and updating last past the value.\n@@ -2801,9 +2806,7 @@ package body Bindgen is\n \n       Count := 0;\n \n-      for J in Cumulative_Restrictions.Set'First ..\n-        Restriction_Id'Pred (Cumulative_Restrictions.Set'Last)\n-      loop\n+      for J in Cumulative_Restrictions.Set'Range loop\n          Set_Boolean (Cumulative_Restrictions.Set (J));\n          Set_String (\", \");\n          Count := Count + 1;\n@@ -2815,30 +2818,22 @@ package body Bindgen is\n          end if;\n       end loop;\n \n-      Set_Boolean\n-        (Cumulative_Restrictions.Set (Cumulative_Restrictions.Set'Last));\n-      Set_String (\"),\");\n+      Set_String_Replace (\"),\");\n       Write_Statement_Buffer;\n       Set_String (\"         Value => (\");\n \n-      for J in Cumulative_Restrictions.Value'First ..\n-        Restriction_Id'Pred (Cumulative_Restrictions.Value'Last)\n-      loop\n+      for J in Cumulative_Restrictions.Value'Range loop\n          Set_Int (Int (Cumulative_Restrictions.Value (J)));\n          Set_String (\", \");\n       end loop;\n \n-      Set_Int (Int (Cumulative_Restrictions.Value\n-        (Cumulative_Restrictions.Value'Last)));\n-      Set_String (\"),\");\n+      Set_String_Replace (\"),\");\n       Write_Statement_Buffer;\n       WBI (\"         Violated =>\");\n       Set_String (\"          (\");\n       Count := 0;\n \n-      for J in Cumulative_Restrictions.Violated'First ..\n-        Restriction_Id'Pred (Cumulative_Restrictions.Violated'Last)\n-      loop\n+      for J in Cumulative_Restrictions.Violated'Range loop\n          Set_Boolean (Cumulative_Restrictions.Violated (J));\n          Set_String (\", \");\n          Count := Count + 1;\n@@ -2850,36 +2845,26 @@ package body Bindgen is\n          end if;\n       end loop;\n \n-      Set_Boolean (Cumulative_Restrictions.Violated\n-        (Cumulative_Restrictions.Violated'Last));\n-      Set_String (\"),\");\n+      Set_String_Replace (\"),\");\n       Write_Statement_Buffer;\n       Set_String (\"         Count => (\");\n \n-      for J in Cumulative_Restrictions.Count'First ..\n-        Restriction_Id'Pred (Cumulative_Restrictions.Count'Last)\n-      loop\n+      for J in Cumulative_Restrictions.Count'Range loop\n          Set_Int (Int (Cumulative_Restrictions.Count (J)));\n          Set_String (\", \");\n       end loop;\n \n-      Set_Int (Int (Cumulative_Restrictions.Count\n-        (Cumulative_Restrictions.Count'Last)));\n-      Set_String (\"),\");\n+      Set_String_Replace (\"),\");\n       Write_Statement_Buffer;\n       Set_String (\"         Unknown => (\");\n \n-      for J in Cumulative_Restrictions.Unknown'First ..\n-        Restriction_Id'Pred (Cumulative_Restrictions.Unknown'Last)\n-      loop\n+      for J in Cumulative_Restrictions.Unknown'Range loop\n          Set_Boolean (Cumulative_Restrictions.Unknown (J));\n          Set_String (\", \");\n       end loop;\n \n-      Set_Boolean\n-        (Cumulative_Restrictions.Unknown\n-          (Cumulative_Restrictions.Unknown'Last));\n-      Set_String (\"));\");\n+      Set_String_Replace (\"))\");\n+      Set_String (\";\");\n       Write_Statement_Buffer;\n    end Gen_Restrictions_Ada;\n \n@@ -2926,68 +2911,49 @@ package body Bindgen is\n       WBI (\"   restrictions r = {\");\n       Set_String (\"     {\");\n \n-      for J in Cumulative_Restrictions.Set'First ..\n-        Restriction_Id'Pred (Cumulative_Restrictions.Set'Last)\n-      loop\n+      for J in Cumulative_Restrictions.Set'Range loop\n          Set_Int (Boolean'Pos (Cumulative_Restrictions.Set (J)));\n          Set_String (\", \");\n       end loop;\n \n-      Set_Int (Boolean'Pos\n-        (Cumulative_Restrictions.Set (Cumulative_Restrictions.Set'Last)));\n-      Set_String (\"},\");\n+      Set_String_Replace (\"},\");\n       Write_Statement_Buffer;\n       Set_String (\"     {\");\n \n-      for J in Cumulative_Restrictions.Value'First ..\n-        Restriction_Id'Pred (Cumulative_Restrictions.Value'Last)\n-      loop\n+      for J in Cumulative_Restrictions.Value'Range loop\n          Set_Int (Int (Cumulative_Restrictions.Value (J)));\n          Set_String (\", \");\n       end loop;\n \n-      Set_Int (Int (Cumulative_Restrictions.Value\n-        (Cumulative_Restrictions.Value'Last)));\n-      Set_String (\"},\");\n+      Set_String_Replace (\"},\");\n       Write_Statement_Buffer;\n       Set_String (\"     {\");\n \n-      for J in Cumulative_Restrictions.Violated'First ..\n-        Restriction_Id'Pred (Cumulative_Restrictions.Violated'Last)\n-      loop\n+      for J in Cumulative_Restrictions.Violated'Range loop\n          Set_Int (Boolean'Pos (Cumulative_Restrictions.Violated (J)));\n          Set_String (\", \");\n       end loop;\n \n-      Set_Int (Boolean'Pos (Cumulative_Restrictions.Violated\n-        (Cumulative_Restrictions.Violated'Last)));\n-      Set_String (\"},\");\n+      Set_String_Replace (\"},\");\n       Write_Statement_Buffer;\n       Set_String (\"     {\");\n \n-      for J in Cumulative_Restrictions.Count'First ..\n-        Restriction_Id'Pred (Cumulative_Restrictions.Count'Last)\n-      loop\n+      for J in Cumulative_Restrictions.Count'Range loop\n          Set_Int (Int (Cumulative_Restrictions.Count (J)));\n          Set_String (\", \");\n       end loop;\n \n-      Set_Int (Int (Cumulative_Restrictions.Count\n-        (Cumulative_Restrictions.Count'Last)));\n-      Set_String (\"},\");\n+      Set_String_Replace (\"},\");\n       Write_Statement_Buffer;\n       Set_String (\"     {\");\n \n-      for J in Cumulative_Restrictions.Unknown'First ..\n-        Restriction_Id'Pred (Cumulative_Restrictions.Unknown'Last)\n-      loop\n+      for J in Cumulative_Restrictions.Unknown'Range loop\n          Set_Int (Boolean'Pos (Cumulative_Restrictions.Unknown (J)));\n          Set_String (\", \");\n       end loop;\n \n-      Set_Int (Boolean'Pos (Cumulative_Restrictions.Unknown\n-          (Cumulative_Restrictions.Unknown'Last)));\n-      Set_String (\"}};\");\n+      Set_String_Replace (\"}}\");\n+      Set_String (\";\");\n       Write_Statement_Buffer;\n       WBI (\"   system__restrictions__run_time_restrictions = r;\");\n    end Gen_Restrictions_C;\n@@ -3475,6 +3441,15 @@ package body Bindgen is\n       Last := Last + S'Length;\n    end Set_String;\n \n+   ------------------------\n+   -- Set_String_Replace --\n+   ------------------------\n+\n+   procedure Set_String_Replace (S : String) is\n+   begin\n+      Statement_Buffer (Last - S'Length + 1 .. Last) := S;\n+   end Set_String_Replace;\n+\n    -------------------\n    -- Set_Unit_Name --\n    -------------------"}, {"sha": "8d169fbd3f14f143e9bb3e72278f11d86a4940e8", "filename": "gcc/ada/casing.ads", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fcasing.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fcasing.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcasing.ads?ref=498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---         Copyright (C) 1992-2009  Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -61,6 +61,9 @@ package Casing is\n       --  (e.g. X, Y_3, M4, A_B, or if it is inconsistent ABC_def).\n    );\n \n+   subtype Known_Casing is Casing_Type range All_Upper_Case .. Mixed_Case;\n+   --  Exclude Unknown casing\n+\n    ------------------------------\n    -- Case Control Subprograms --\n    ------------------------------"}, {"sha": "f3a1e2fb7a7e8d9bd518cf47cd6e78862766810e", "filename": "gcc/ada/clean.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fclean.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fclean.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fclean.adb?ref=498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90", "patch": "@@ -1556,7 +1556,6 @@ package body Clean is\n          --  Initialize some packages\n \n          Csets.Initialize;\n-         Namet.Initialize;\n          Snames.Initialize;\n \n          Project_Node_Tree := new Project_Node_Tree_Data;"}, {"sha": "5def2eb5cf0ea1a3b38c5e1776a8569ca25e833e", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90", "patch": "@@ -610,7 +610,6 @@ begin\n       Uintp.Initialize;\n       Urealp.Initialize;\n       Errout.Initialize;\n-      Namet.Initialize;\n       SCOs.Initialize;\n       Snames.Initialize;\n       Stringt.Initialize;"}, {"sha": "0a197df3e5765805e7435c0b4cdb9e7d7c7623a8", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90", "patch": "@@ -6255,6 +6255,14 @@ allowed).\n Optional labels on @code{end} statements ending subprograms and on\n @code{exit} statements exiting named loops, are required to be present.\n \n+@item ^E^ENUMERATION_RANGES^\n+@emph{Check enumeration ranges.}\n+Explicit subranges of enumeration types (e.g. in loops or membership tests)\n+are not allowed unless the subrange occurs in the same package as the type\n+declaration, or its body or subunits. Standard types (such as Boolean and\n+Character) are excluded, allowing for example the range 'A'..'Z'. In addition\n+an explicit reference to X'First..X'Last (equivalent to X'Range) is allowed.\n+\n @item ^f^VTABS^\n @emph{No form feeds or vertical tabs.}\n Neither form feeds nor vertical tab characters are permitted"}, {"sha": "d3882589fdeaa8e838588e58f6e65495355c8be8", "filename": "gcc/ada/gnatbind.adb", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fgnatbind.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fgnatbind.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatbind.adb?ref=498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90", "patch": "@@ -583,13 +583,11 @@ begin\n    Osint.Add_Default_Search_Dirs;\n \n    --  Carry out package initializations. These are initializations which\n-   --  might logically be performed at elaboration time, but Namet at least\n-   --  can't be done that way (because it is used in the Compiler), and we\n-   --  decide to be consistent. Like elaboration, the order in which these\n-   --  calls are made is in some cases important.\n+   --  might logically be performed at elaboration time, and we decide to be\n+   --  consistent. Like elaboration, the order in which these calls are made\n+   --  is in some cases important.\n \n    Csets.Initialize;\n-   Namet.Initialize;\n    Snames.Initialize;\n \n    --  Acquire target parameters"}, {"sha": "24ee7a10beda078100099aa9f1f0454133b06936", "filename": "gcc/ada/gnatcmd.adb", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fgnatcmd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fgnatcmd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatcmd.adb?ref=498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90", "patch": "@@ -1320,9 +1320,7 @@ procedure GNATCmd is\n begin\n    --  Initializations\n \n-   Namet.Initialize;\n    Csets.Initialize;\n-\n    Snames.Initialize;\n \n    Project_Node_Tree := new Project_Node_Tree_Data;"}, {"sha": "ad57a9d9eefc0c9a1126811bcc1efa71a7466d5d", "filename": "gcc/ada/gnatlink.adb", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fgnatlink.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fgnatlink.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatlink.adb?ref=498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1996-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1996-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1537,7 +1537,6 @@ begin\n \n    --  Initialize packages to be used\n \n-   Namet.Initialize;\n    Csets.Initialize;\n    Snames.Initialize;\n \n@@ -1561,7 +1560,6 @@ begin\n    --  the binder generated file\n \n    if Compile_Bind_File and then Standard_Gcc then\n-\n       Initialize_ALI;\n       Name_Len := Ali_File_Name'Length;\n       Name_Buffer (1 .. Name_Len) := Ali_File_Name.all;"}, {"sha": "98088d011ab8142e7bd7cd090137ab78c64ccd43", "filename": "gcc/ada/gnatls.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fgnatls.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fgnatls.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatls.adb?ref=498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1524,7 +1524,6 @@ procedure Gnatls is\n begin\n    --  Initialize standard packages\n \n-   Namet.Initialize;\n    Csets.Initialize;\n    Snames.Initialize;\n "}, {"sha": "eb6cdde8220515cfee1c62f3c270dba6595cd1b1", "filename": "gcc/ada/gprep.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fgprep.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fgprep.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgprep.adb?ref=498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2002-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2002-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -172,7 +172,6 @@ package body GPrep is\n       --  Do some initializations (order is important here!)\n \n       Csets.Initialize;\n-      Namet.Initialize;\n       Snames.Initialize;\n       Stringt.Initialize;\n       Prep.Initialize;"}, {"sha": "f0c03320c2807b8a3d4a89361a80446e0c5897d5", "filename": "gcc/ada/make.adb", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fmake.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fmake.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmake.adb?ref=498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90", "patch": "@@ -6725,7 +6725,7 @@ package body Make is\n \n       Check_Object_Consistency := True;\n \n-      --  Package initializations. The order of calls is important here\n+      --  Package initializations (the order of calls is important here)\n \n       Output.Set_Standard_Error;\n \n@@ -6734,8 +6734,6 @@ package body Make is\n       Linker_Switches.Init;\n \n       Csets.Initialize;\n-      Namet.Initialize;\n-\n       Snames.Initialize;\n \n       Prj.Initialize (Project_Tree);"}, {"sha": "d13918cd60a77af8197a5ea20356c5ea179b9a86", "filename": "gcc/ada/namet.adb", "status": "modified", "additions": 37, "deletions": 24, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fnamet.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fnamet.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnamet.adb?ref=498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -864,29 +864,7 @@ package body Namet is\n \n    procedure Initialize is\n    begin\n-      Name_Chars.Init;\n-      Name_Entries.Init;\n-\n-      --  Initialize entries for one character names\n-\n-      for C in Character loop\n-         Name_Entries.Append\n-           ((Name_Chars_Index      => Name_Chars.Last,\n-             Name_Len              => 1,\n-             Byte_Info             => 0,\n-             Int_Info              => 0,\n-             Name_Has_No_Encodings => True,\n-             Hash_Link             => No_Name));\n-\n-         Name_Chars.Append (C);\n-         Name_Chars.Append (ASCII.NUL);\n-      end loop;\n-\n-      --  Clear hash table\n-\n-      for J in Hash_Index_Type loop\n-         Hash_Table (J) := No_Name;\n-      end loop;\n+      null;\n    end Initialize;\n \n    ----------------------\n@@ -1133,6 +1111,37 @@ package body Namet is\n       end if;\n    end Name_Find;\n \n+   ------------------\n+   -- Reinitialize --\n+   ------------------\n+\n+   procedure Reinitialize is\n+   begin\n+      Name_Chars.Init;\n+      Name_Entries.Init;\n+\n+      --  Initialize entries for one character names\n+\n+      for C in Character loop\n+         Name_Entries.Append\n+           ((Name_Chars_Index      => Name_Chars.Last,\n+             Name_Len              => 1,\n+             Byte_Info             => 0,\n+             Int_Info              => 0,\n+             Name_Has_No_Encodings => True,\n+             Hash_Link             => No_Name));\n+\n+         Name_Chars.Append (C);\n+         Name_Chars.Append (ASCII.NUL);\n+      end loop;\n+\n+      --  Clear hash table\n+\n+      for J in Hash_Index_Type loop\n+         Hash_Table (J) := No_Name;\n+      end loop;\n+   end Reinitialize;\n+\n    ----------------------\n    -- Reset_Name_Table --\n    ----------------------\n@@ -1399,4 +1408,8 @@ package body Namet is\n       end if;\n    end Write_Name_Decoded;\n \n+--  Package initialization, initialize tables\n+\n+begin\n+   Reinitialize;\n end Namet;"}, {"sha": "729fec1a5fa32de81ee952fc295200675bd7ca4f", "filename": "gcc/ada/namet.ads", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fnamet.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fnamet.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnamet.ads?ref=498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -239,14 +239,20 @@ package Namet is\n    --  is, it starts with an upper case O).\n \n    procedure Initialize;\n-   --  Initializes the names table, including initializing the first 26\n-   --  entries in the table (for the 1-character lower case names a-z) Note\n-   --  that Initialize must not be called if Tree_Read is used.\n+   --  This is a dummy procedure. It is retained for easy compatibility with\n+   --  clients who used to call Initialize when this call was required. Now\n+   --  initialization is performed automatically during package elaboration.\n+   --  Note that this change fixes problems which existed prior to the change\n+   --  of Initialize being called more than once. See also Reinitialize which\n+   --  allows reinitialiation of the tables.\n \n    procedure Lock;\n    --  Lock name tables before calling back end. We reserve some extra space\n    --  before locking to avoid unnecessary inefficiencies when we unlock.\n \n+   procedure Reinitialize;\n+   --  Clears the name tables and removes all existing entries from the table.\n+\n    procedure Unlock;\n    --  Unlocks the name table to allow use of the extra space reserved by the\n    --  call to Lock. See gnat1drv for details of the need for this."}, {"sha": "a16e6f3d181f5d8beb6da59d8b59519c3874d857", "filename": "gcc/ada/prj-attr.ads", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fprj-attr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fprj-attr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-attr.ads?ref=498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2001-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2001-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -44,8 +44,8 @@ package Prj.Attr is\n    --  packages and their attribute. This procedure should be called by\n    --  Prj.Initialize.\n \n-   type Attribute_Kind is\n-     (Unknown,\n+   type Attribute_Kind is (\n+      Unknown,\n       --  The attribute does not exist\n \n       Single,\n@@ -61,9 +61,10 @@ package Prj.Attr is\n       Case_Insensitive_Associative_Array,\n       --  Associative array attribute with a case insensitive index\n \n-      Optional_Index_Case_Insensitive_Associative_Array);\n+      Optional_Index_Case_Insensitive_Associative_Array\n       --  Associative array attribute with a case insensitive index and an\n       --  optional source index.\n+   );\n    --  Characteristics of an attribute. Optional_Index indicates that there\n    --  may be an optional index in the index of the associative array, as in\n    --     for Switches (\"files.ada\" at 2) use ...\n@@ -73,6 +74,11 @@ package Prj.Attr is\n    --  Subset of Attribute_Kinds that may be used for the attributes that is\n    --  used when defining a new package.\n \n+   subtype All_Case_Insensitive_Associative_Array is Attribute_Kind range\n+     Case_Insensitive_Associative_Array ..\n+     Optional_Index_Case_Insensitive_Associative_Array;\n+   --  Subtype including both cases of Case_Insensitive_Associative_Array\n+\n    Max_Attribute_Name_Length : constant := 64;\n    --  The maximum length of attribute names\n "}, {"sha": "9cb86bdb88095649d62d29fcc40bb167e3813d7d", "filename": "gcc/ada/prj-dect.adb", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fprj-dect.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fprj-dect.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-dect.adb?ref=498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2001-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2001-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -247,8 +247,7 @@ package body Prj.Dect is\n             end if;\n \n             if Attribute_Kind_Of (Current_Attribute) in\n-                 Case_Insensitive_Associative_Array ..\n-                 Optional_Index_Case_Insensitive_Associative_Array\n+                 All_Case_Insensitive_Associative_Array\n             then\n                Set_Case_Insensitive (Attribute, In_Tree, To => True);\n             end if;"}, {"sha": "0368237d5fe4f25752ae4351bfe9ffe048e0ce83", "filename": "gcc/ada/prj-makr.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fprj-makr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fprj-makr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-makr.adb?ref=498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2001-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2001-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -792,7 +792,6 @@ package body Prj.Makr is\n       --  Do some needed initializations\n \n       Csets.Initialize;\n-      Namet.Initialize;\n       Snames.Initialize;\n       Prj.Initialize (No_Project_Tree);\n       Prj.Tree.Initialize (Tree);"}, {"sha": "63b24b3d6fd60c4cccde49d1e54a25a8ad8fb809", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90", "patch": "@@ -3310,7 +3310,7 @@ package body Prj.Nmsc is\n \n          --  Get the naming exceptions for all languages\n \n-         for Kind in Spec .. Impl loop\n+         for Kind in Spec_Or_Body loop\n             Lang_Id := Project.Languages;\n             while Lang_Id /= No_Language_Index loop\n                case Lang_Id.Config.Kind is"}, {"sha": "3120e172227bf531b89bfa31d42785931aa7018e", "filename": "gcc/ada/prj-strt.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fprj-strt.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fprj-strt.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-strt.adb?ref=498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90", "patch": "@@ -216,8 +216,7 @@ package body Prj.Strt is\n             Set_Case_Insensitive\n               (Reference, In_Tree,\n                To => Attribute_Kind_Of (Current_Attribute) in\n-                      Case_Insensitive_Associative_Array ..\n-                        Optional_Index_Case_Insensitive_Associative_Array);\n+                      All_Case_Insensitive_Associative_Array);\n \n             --  Scan past the attribute name\n "}, {"sha": "17d544f6f3535ad244e6e111d6dd50e68f6c7ef5", "filename": "gcc/ada/prj.adb", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fprj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fprj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.adb?ref=498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90", "patch": "@@ -48,8 +48,6 @@ package body Prj is\n \n    The_Empty_String : Name_Id := No_Name;\n \n-   subtype Known_Casing is Casing_Type range All_Upper_Case .. Mixed_Case;\n-\n    type Cst_String_Access is access constant String;\n \n    All_Lower_Case_Image : aliased constant String := \"lowercase\";"}, {"sha": "dbf30ddd54e4a569cf48a726633d564db44e4542", "filename": "gcc/ada/s-bitops.adb", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fs-bitops.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fs-bitops.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-bitops.adb?ref=498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---         Copyright (C) 1996-2009, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1996-2010, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -34,6 +34,7 @@ pragma Compiler_Unit;\n with System;                 use System;\n with System.Unsigned_Types;  use System.Unsigned_Types;\n \n+with Ada.Exceptions;         use Ada.Exceptions;\n with Ada.Unchecked_Conversion;\n \n package body System.Bit_Ops is\n@@ -72,6 +73,7 @@ package body System.Bit_Ops is\n    -----------------------\n \n    procedure Raise_Error;\n+   pragma No_Return (Raise_Error);\n    --  Raise Constraint_Error, complaining about unequal lengths\n \n    -------------\n@@ -211,7 +213,8 @@ package body System.Bit_Ops is\n \n    procedure Raise_Error is\n    begin\n-      raise Constraint_Error;\n+      Raise_Exception\n+        (Constraint_Error'Identity, \"operand lengths are unequal\");\n    end Raise_Error;\n \n end System.Bit_Ops;"}, {"sha": "3b29ca9301289bb8c5768f387c4f8cfddc9ef93e", "filename": "gcc/ada/s-os_lib.ads", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fs-os_lib.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fs-os_lib.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-os_lib.ads?ref=498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1995-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1995-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -203,8 +203,9 @@ package System.OS_Lib is\n      (Name  : String;\n       Fmode : Mode) return File_Descriptor;\n    --  Creates new file with given name for writing, returning file descriptor\n-   --  for subsequent use in Write calls. File descriptor returned is\n-   --  Invalid_FD if file cannot be successfully created.\n+   --  for subsequent use in Write calls. If the file already exists, it is\n+   --  overwritten. File descriptor returned is Invalid_FD if file cannot be\n+   --  successfully created.\n \n    function Create_Output_Text_File (Name : String) return File_Descriptor;\n    --  Creates new text file with given name suitable to redirect standard"}, {"sha": "5f067ccc261601defee269042cc938f5a9618665", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 322, "deletions": 327, "changes": 649, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90", "patch": "@@ -184,415 +184,410 @@ package body Sem_Ch13 is\n    begin\n       --  Processing depends on version of Ada\n \n-      case Ada_Version is\n+      --  For Ada 95, we just renumber bits within a storage unit. We do the\n+      --  same for Ada 83 mode, since we recognize pragma Bit_Order in Ada 83,\n+      --  and are free to add this extension.\n \n-         --  For Ada 95, we just renumber bits within a storage unit. We do\n-         --  the same for Ada 83 mode, since we recognize pragma Bit_Order\n-         --  in Ada 83, and are free to add this extension.\n+      if Ada_Version < Ada_2005 then\n+         Comp := First_Component_Or_Discriminant (R);\n+         while Present (Comp) loop\n+            CC := Component_Clause (Comp);\n \n-         when Ada_83 | Ada_95 =>\n-            Comp := First_Component_Or_Discriminant (R);\n-            while Present (Comp) loop\n-               CC := Component_Clause (Comp);\n+            --  If component clause is present, then deal with the non-default\n+            --  bit order case for Ada 95 mode.\n \n-               --  If component clause is present, then deal with the non-\n-               --  default bit order case for Ada 95 mode.\n+            --  We only do this processing for the base type, and in fact that\n+            --  is important, since otherwise if there are record subtypes, we\n+            --  could reverse the bits once for each subtype, which is wrong.\n \n-               --  We only do this processing for the base type, and in\n-               --  fact that's important, since otherwise if there are\n-               --  record subtypes, we could reverse the bits once for\n-               --  each subtype, which would be incorrect.\n+            if Present (CC)\n+              and then Ekind (R) = E_Record_Type\n+            then\n+               declare\n+                  CFB : constant Uint    := Component_Bit_Offset (Comp);\n+                  CSZ : constant Uint    := Esize (Comp);\n+                  CLC : constant Node_Id := Component_Clause (Comp);\n+                  Pos : constant Node_Id := Position (CLC);\n+                  FB  : constant Node_Id := First_Bit (CLC);\n \n-               if Present (CC)\n-                 and then Ekind (R) = E_Record_Type\n-               then\n-                  declare\n-                     CFB : constant Uint    := Component_Bit_Offset (Comp);\n-                     CSZ : constant Uint    := Esize (Comp);\n-                     CLC : constant Node_Id := Component_Clause (Comp);\n-                     Pos : constant Node_Id := Position (CLC);\n-                     FB  : constant Node_Id := First_Bit (CLC);\n+                  Storage_Unit_Offset : constant Uint :=\n+                                          CFB / System_Storage_Unit;\n \n-                     Storage_Unit_Offset : constant Uint :=\n-                                             CFB / System_Storage_Unit;\n+                  Start_Bit : constant Uint :=\n+                                CFB mod System_Storage_Unit;\n \n-                     Start_Bit : constant Uint :=\n-                                   CFB mod System_Storage_Unit;\n+               begin\n+                  --  Cases where field goes over storage unit boundary\n \n-                  begin\n-                     --  Cases where field goes over storage unit boundary\n+                  if Start_Bit + CSZ > System_Storage_Unit then\n \n-                     if Start_Bit + CSZ > System_Storage_Unit then\n+                     --  Allow multi-byte field but generate warning\n \n-                        --  Allow multi-byte field but generate warning\n+                     if Start_Bit mod System_Storage_Unit = 0\n+                       and then CSZ mod System_Storage_Unit = 0\n+                     then\n+                        Error_Msg_N\n+                          (\"multi-byte field specified with non-standard\"\n+                           & \" Bit_Order?\", CLC);\n \n-                        if Start_Bit mod System_Storage_Unit = 0\n-                          and then CSZ mod System_Storage_Unit = 0\n-                        then\n+                        if Bytes_Big_Endian then\n                            Error_Msg_N\n-                             (\"multi-byte field specified with non-standard\"\n-                              & \" Bit_Order?\", CLC);\n-\n-                           if Bytes_Big_Endian then\n-                              Error_Msg_N\n-                                (\"bytes are not reversed \"\n-                                 & \"(component is big-endian)?\", CLC);\n-                           else\n-                              Error_Msg_N\n-                                (\"bytes are not reversed \"\n-                                 & \"(component is little-endian)?\", CLC);\n-                           end if;\n-\n-                           --  Do not allow non-contiguous field\n-\n+                             (\"bytes are not reversed \"\n+                              & \"(component is big-endian)?\", CLC);\n                         else\n                            Error_Msg_N\n-                             (\"attempt to specify non-contiguous field \"\n-                              & \"not permitted\", CLC);\n-                           Error_Msg_N\n-                             (\"\\caused by non-standard Bit_Order \"\n-                              & \"specified\", CLC);\n-                           Error_Msg_N\n-                             (\"\\consider possibility of using \"\n-                              & \"Ada 2005 mode here\", CLC);\n+                             (\"bytes are not reversed \"\n+                              & \"(component is little-endian)?\", CLC);\n                         end if;\n \n-                        --  Case where field fits in one storage unit\n+                        --  Do not allow non-contiguous field\n \n                      else\n-                        --  Give warning if suspicious component clause\n+                        Error_Msg_N\n+                          (\"attempt to specify non-contiguous field \"\n+                           & \"not permitted\", CLC);\n+                        Error_Msg_N\n+                          (\"\\caused by non-standard Bit_Order \"\n+                           & \"specified\", CLC);\n+                        Error_Msg_N\n+                          (\"\\consider possibility of using \"\n+                           & \"Ada 2005 mode here\", CLC);\n+                     end if;\n \n-                        if Intval (FB) >= System_Storage_Unit\n-                          and then Warn_On_Reverse_Bit_Order\n-                        then\n-                           Error_Msg_N\n-                             (\"?Bit_Order clause does not affect \" &\n-                              \"byte ordering\", Pos);\n-                           Error_Msg_Uint_1 :=\n-                             Intval (Pos) + Intval (FB) /\n-                             System_Storage_Unit;\n-                           Error_Msg_N\n-                             (\"?position normalized to ^ before bit \" &\n-                              \"order interpreted\", Pos);\n-                        end if;\n+                  --  Case where field fits in one storage unit\n+\n+                  else\n+                     --  Give warning if suspicious component clause\n+\n+                     if Intval (FB) >= System_Storage_Unit\n+                       and then Warn_On_Reverse_Bit_Order\n+                     then\n+                        Error_Msg_N\n+                          (\"?Bit_Order clause does not affect \" &\n+                           \"byte ordering\", Pos);\n+                        Error_Msg_Uint_1 :=\n+                          Intval (Pos) + Intval (FB) /\n+                          System_Storage_Unit;\n+                        Error_Msg_N\n+                          (\"?position normalized to ^ before bit \" &\n+                           \"order interpreted\", Pos);\n+                     end if;\n \n-                        --  Here is where we fix up the Component_Bit_Offset\n-                        --  value to account for the reverse bit order.\n-                        --  Some examples of what needs to be done are:\n+                     --  Here is where we fix up the Component_Bit_Offset value\n+                     --  to account for the reverse bit order. Some examples of\n+                     --  what needs to be done are:\n \n-                        --    First_Bit .. Last_Bit     Component_Bit_Offset\n-                        --      old          new          old       new\n+                     --    First_Bit .. Last_Bit     Component_Bit_Offset\n+                     --      old          new          old       new\n \n-                        --     0 .. 0       7 .. 7         0         7\n-                        --     0 .. 1       6 .. 7         0         6\n-                        --     0 .. 2       5 .. 7         0         5\n-                        --     0 .. 7       0 .. 7         0         4\n+                     --     0 .. 0       7 .. 7         0         7\n+                     --     0 .. 1       6 .. 7         0         6\n+                     --     0 .. 2       5 .. 7         0         5\n+                     --     0 .. 7       0 .. 7         0         4\n \n-                        --     1 .. 1       6 .. 6         1         6\n-                        --     1 .. 4       3 .. 6         1         3\n-                        --     4 .. 7       0 .. 3         4         0\n+                     --     1 .. 1       6 .. 6         1         6\n+                     --     1 .. 4       3 .. 6         1         3\n+                     --     4 .. 7       0 .. 3         4         0\n \n-                        --  The general rule is that the first bit is\n-                        --  is obtained by subtracting the old ending bit\n-                        --  from storage_unit - 1.\n+                     --  The rule is that the first bit is is obtained by\n+                     --  subtracting the old ending bit from storage_unit - 1.\n \n-                        Set_Component_Bit_Offset\n-                          (Comp,\n-                           (Storage_Unit_Offset * System_Storage_Unit) +\n-                             (System_Storage_Unit - 1) -\n-                             (Start_Bit + CSZ - 1));\n+                     Set_Component_Bit_Offset\n+                       (Comp,\n+                        (Storage_Unit_Offset * System_Storage_Unit) +\n+                          (System_Storage_Unit - 1) -\n+                          (Start_Bit + CSZ - 1));\n \n-                        Set_Normalized_First_Bit\n-                          (Comp,\n-                           Component_Bit_Offset (Comp) mod\n-                             System_Storage_Unit);\n-                     end if;\n-                  end;\n-               end if;\n+                     Set_Normalized_First_Bit\n+                       (Comp,\n+                        Component_Bit_Offset (Comp) mod\n+                          System_Storage_Unit);\n+                  end if;\n+               end;\n+            end if;\n \n-               Next_Component_Or_Discriminant (Comp);\n-            end loop;\n+            Next_Component_Or_Discriminant (Comp);\n+         end loop;\n \n-         --  For Ada 2005, we do machine scalar processing, as fully described\n-         --  In AI-133. This involves gathering all components which start at\n-         --  the same byte offset and processing them together\n+      --  For Ada 2005, we do machine scalar processing, as fully described In\n+      --  AI-133. This involves gathering all components which start at the\n+      --  same byte offset and processing them together. Same approach is still\n+      --  valid in later versions including Ada 2012.\n \n-         when Ada_05 .. Ada_Version_Type'Last =>\n-            declare\n-               Max_Machine_Scalar_Size : constant Uint :=\n-                                           UI_From_Int\n-                                             (Standard_Long_Long_Integer_Size);\n+      else\n+         declare\n+            Max_Machine_Scalar_Size : constant Uint :=\n+                                        UI_From_Int\n+                                          (Standard_Long_Long_Integer_Size);\n             --  We use this as the maximum machine scalar size\n \n-               Num_CC : Natural;\n-               SSU    : constant Uint := UI_From_Int (System_Storage_Unit);\n+            Num_CC : Natural;\n+            SSU    : constant Uint := UI_From_Int (System_Storage_Unit);\n \n-            begin\n-               --  This first loop through components does two things. First it\n-               --  deals with the case of components with component clauses\n-               --  whose length is greater than the maximum machine scalar size\n-               --  (either accepting them or rejecting as needed). Second, it\n-               --  counts the number of components with component clauses whose\n-               --  length does not exceed this maximum for later processing.\n+         begin\n+            --  This first loop through components does two things. First it\n+            --  deals with the case of components with component clauses whose\n+            --  length is greater than the maximum machine scalar size (either\n+            --  accepting them or rejecting as needed). Second, it counts the\n+            --  number of components with component clauses whose length does\n+            --  not exceed this maximum for later processing.\n+\n+            Num_CC := 0;\n+            Comp   := First_Component_Or_Discriminant (R);\n+            while Present (Comp) loop\n+               CC := Component_Clause (Comp);\n \n-               Num_CC := 0;\n-               Comp   := First_Component_Or_Discriminant (R);\n-               while Present (Comp) loop\n-                  CC := Component_Clause (Comp);\n+               if Present (CC) then\n+                  declare\n+                     Fbit : constant Uint :=\n+                              Static_Integer (First_Bit (CC));\n \n-                  if Present (CC) then\n-                     declare\n-                        Fbit : constant Uint :=\n-                                 Static_Integer (First_Bit (CC));\n+                  begin\n+                     --  Case of component with size > max machine scalar\n \n-                     begin\n-                        --  Case of component with size > max machine scalar\n+                     if Esize (Comp) > Max_Machine_Scalar_Size then\n \n-                        if Esize (Comp) > Max_Machine_Scalar_Size then\n+                        --  Must begin on byte boundary\n \n-                           --  Must begin on byte boundary\n+                        if Fbit mod SSU /= 0 then\n+                           Error_Msg_N\n+                             (\"illegal first bit value for \"\n+                              & \"reverse bit order\",\n+                              First_Bit (CC));\n+                           Error_Msg_Uint_1 := SSU;\n+                           Error_Msg_Uint_2 := Max_Machine_Scalar_Size;\n \n-                           if Fbit mod SSU /= 0 then\n-                              Error_Msg_N\n-                                (\"illegal first bit value for \"\n-                                 & \"reverse bit order\",\n-                                 First_Bit (CC));\n-                              Error_Msg_Uint_1 := SSU;\n-                              Error_Msg_Uint_2 := Max_Machine_Scalar_Size;\n+                           Error_Msg_N\n+                             (\"\\must be a multiple of ^ \"\n+                              & \"if size greater than ^\",\n+                              First_Bit (CC));\n \n-                              Error_Msg_N\n-                                (\"\\must be a multiple of ^ \"\n-                                 & \"if size greater than ^\",\n-                                 First_Bit (CC));\n+                           --  Must end on byte boundary\n \n-                              --  Must end on byte boundary\n+                        elsif Esize (Comp) mod SSU /= 0 then\n+                           Error_Msg_N\n+                             (\"illegal last bit value for \"\n+                              & \"reverse bit order\",\n+                              Last_Bit (CC));\n+                           Error_Msg_Uint_1 := SSU;\n+                           Error_Msg_Uint_2 := Max_Machine_Scalar_Size;\n \n-                           elsif Esize (Comp) mod SSU /= 0 then\n-                              Error_Msg_N\n-                                (\"illegal last bit value for \"\n-                                 & \"reverse bit order\",\n-                                 Last_Bit (CC));\n-                              Error_Msg_Uint_1 := SSU;\n-                              Error_Msg_Uint_2 := Max_Machine_Scalar_Size;\n+                           Error_Msg_N\n+                             (\"\\must be a multiple of ^ if size \"\n+                              & \"greater than ^\",\n+                              Last_Bit (CC));\n \n-                              Error_Msg_N\n-                                (\"\\must be a multiple of ^ if size \"\n-                                 & \"greater than ^\",\n-                                 Last_Bit (CC));\n+                           --  OK, give warning if enabled\n \n-                              --  OK, give warning if enabled\n+                        elsif Warn_On_Reverse_Bit_Order then\n+                           Error_Msg_N\n+                             (\"multi-byte field specified with \"\n+                              & \"  non-standard Bit_Order?\", CC);\n \n-                           elsif Warn_On_Reverse_Bit_Order then\n+                           if Bytes_Big_Endian then\n+                              Error_Msg_N\n+                                (\"\\bytes are not reversed \"\n+                                 & \"(component is big-endian)?\", CC);\n+                           else\n                               Error_Msg_N\n-                                (\"multi-byte field specified with \"\n-                                 & \"  non-standard Bit_Order?\", CC);\n-\n-                              if Bytes_Big_Endian then\n-                                 Error_Msg_N\n-                                   (\"\\bytes are not reversed \"\n-                                    & \"(component is big-endian)?\", CC);\n-                              else\n-                                 Error_Msg_N\n-                                   (\"\\bytes are not reversed \"\n-                                    & \"(component is little-endian)?\", CC);\n-                              end if;\n+                                (\"\\bytes are not reversed \"\n+                                 & \"(component is little-endian)?\", CC);\n                            end if;\n+                        end if;\n \n-                           --  Case where size is not greater than max machine\n-                           --  scalar. For now, we just count these.\n+                        --  Case where size is not greater than max machine\n+                        --  scalar. For now, we just count these.\n \n-                        else\n-                           Num_CC := Num_CC + 1;\n-                        end if;\n-                     end;\n-                  end if;\n+                     else\n+                        Num_CC := Num_CC + 1;\n+                     end if;\n+                  end;\n+               end if;\n \n-                  Next_Component_Or_Discriminant (Comp);\n-               end loop;\n+               Next_Component_Or_Discriminant (Comp);\n+            end loop;\n \n-               --  We need to sort the component clauses on the basis of the\n-               --  Position values in the clause, so we can group clauses with\n-               --  the same Position. together to determine the relevant\n-               --  machine scalar size.\n+            --  We need to sort the component clauses on the basis of the\n+            --  Position values in the clause, so we can group clauses with\n+            --  the same Position. together to determine the relevant machine\n+            --  scalar size.\n \n-               Sort_CC : declare\n-                  Comps : array (0 .. Num_CC) of Entity_Id;\n-                  --  Array to collect component and discriminant entities. The\n-                  --  data starts at index 1, the 0'th entry is for the sort\n-                  --  routine.\n+            Sort_CC : declare\n+               Comps : array (0 .. Num_CC) of Entity_Id;\n+               --  Array to collect component and discriminant entities. The\n+               --  data starts at index 1, the 0'th entry is for the sort\n+               --  routine.\n \n-                  function CP_Lt (Op1, Op2 : Natural) return Boolean;\n-                  --  Compare routine for Sort\n+               function CP_Lt (Op1, Op2 : Natural) return Boolean;\n+               --  Compare routine for Sort\n \n-                  procedure CP_Move (From : Natural; To : Natural);\n-                  --  Move routine for Sort\n+               procedure CP_Move (From : Natural; To : Natural);\n+               --  Move routine for Sort\n \n-                  package Sorting is new GNAT.Heap_Sort_G (CP_Move, CP_Lt);\n+               package Sorting is new GNAT.Heap_Sort_G (CP_Move, CP_Lt);\n \n-                  Start : Natural;\n-                  Stop  : Natural;\n-                  --  Start and stop positions in component list of set of\n-                  --  components with the same starting position (that\n-                  --  constitute components in a single machine scalar).\n+               Start : Natural;\n+               Stop  : Natural;\n+               --  Start and stop positions in the component list of the set of\n+               --  components with the same starting position (that constitute\n+               --  components in a single machine scalar).\n \n-                  MaxL  : Uint;\n-                  --  Maximum last bit value of any component in this set\n+               MaxL  : Uint;\n+               --  Maximum last bit value of any component in this set\n \n-                  MSS   : Uint;\n-                  --  Corresponding machine scalar size\n+               MSS   : Uint;\n+               --  Corresponding machine scalar size\n \n-                  -----------\n-                  -- CP_Lt --\n-                  -----------\n+               -----------\n+               -- CP_Lt --\n+               -----------\n \n-                  function CP_Lt (Op1, Op2 : Natural) return Boolean is\n-                  begin\n-                     return Position (Component_Clause (Comps (Op1))) <\n-                            Position (Component_Clause (Comps (Op2)));\n-                  end CP_Lt;\n+               function CP_Lt (Op1, Op2 : Natural) return Boolean is\n+               begin\n+                  return Position (Component_Clause (Comps (Op1))) <\n+                    Position (Component_Clause (Comps (Op2)));\n+               end CP_Lt;\n \n-                  -------------\n-                  -- CP_Move --\n-                  -------------\n+               -------------\n+               -- CP_Move --\n+               -------------\n \n-                  procedure CP_Move (From : Natural; To : Natural) is\n-                  begin\n-                     Comps (To) := Comps (From);\n-                  end CP_Move;\n+               procedure CP_Move (From : Natural; To : Natural) is\n+               begin\n+                  Comps (To) := Comps (From);\n+               end CP_Move;\n \n                --  Start of processing for Sort_CC\n \n-               begin\n-                  --  Collect the component clauses\n+            begin\n+               --  Collect the component clauses\n \n-                  Num_CC := 0;\n-                  Comp   := First_Component_Or_Discriminant (R);\n-                  while Present (Comp) loop\n-                     if Present (Component_Clause (Comp))\n-                       and then Esize (Comp) <= Max_Machine_Scalar_Size\n-                     then\n-                        Num_CC := Num_CC + 1;\n-                        Comps (Num_CC) := Comp;\n-                     end if;\n+               Num_CC := 0;\n+               Comp   := First_Component_Or_Discriminant (R);\n+               while Present (Comp) loop\n+                  if Present (Component_Clause (Comp))\n+                    and then Esize (Comp) <= Max_Machine_Scalar_Size\n+                  then\n+                     Num_CC := Num_CC + 1;\n+                     Comps (Num_CC) := Comp;\n+                  end if;\n \n-                     Next_Component_Or_Discriminant (Comp);\n-                  end loop;\n+                  Next_Component_Or_Discriminant (Comp);\n+               end loop;\n \n-                  --  Sort by ascending position number\n+               --  Sort by ascending position number\n \n-                  Sorting.Sort (Num_CC);\n+               Sorting.Sort (Num_CC);\n \n-                  --  We now have all the components whose size does not exceed\n-                  --  the max machine scalar value, sorted by starting\n-                  --  position. In this loop we gather groups of clauses\n-                  --  starting at the same position, to process them in\n-                  --  accordance with Ada 2005 AI-133.\n+               --  We now have all the components whose size does not exceed\n+               --  the max machine scalar value, sorted by starting position.\n+               --  In this loop we gather groups of clauses starting at the\n+               --  same position, to process them in accordance with AI-133.\n \n-                  Stop := 0;\n+               Stop := 0;\n+               while Stop < Num_CC loop\n+                  Start := Stop + 1;\n+                  Stop  := Start;\n+                  MaxL  :=\n+                    Static_Integer\n+                      (Last_Bit (Component_Clause (Comps (Start))));\n                   while Stop < Num_CC loop\n-                     Start := Stop + 1;\n-                     Stop  := Start;\n-                     MaxL  :=\n-                       Static_Integer\n-                         (Last_Bit (Component_Clause (Comps (Start))));\n-                     while Stop < Num_CC loop\n-                        if Static_Integer\n-                             (Position (Component_Clause (Comps (Stop + 1)))) =\n-                           Static_Integer\n-                             (Position (Component_Clause (Comps (Stop))))\n-                        then\n-                           Stop := Stop + 1;\n-                           MaxL :=\n-                             UI_Max\n-                               (MaxL,\n-                                Static_Integer\n-                                  (Last_Bit\n-                                     (Component_Clause (Comps (Stop)))));\n-                        else\n-                           exit;\n-                        end if;\n-                     end loop;\n+                     if Static_Integer\n+                          (Position (Component_Clause (Comps (Stop + 1)))) =\n+                        Static_Integer\n+                          (Position (Component_Clause (Comps (Stop))))\n+                     then\n+                        Stop := Stop + 1;\n+                        MaxL :=\n+                          UI_Max\n+                            (MaxL,\n+                             Static_Integer\n+                               (Last_Bit\n+                                  (Component_Clause (Comps (Stop)))));\n+                     else\n+                        exit;\n+                     end if;\n+                  end loop;\n \n-                     --  Now we have a group of component clauses from Start to\n-                     --  Stop whose positions are identical, and MaxL is the\n-                     --  maximum last bit value of any of these components.\n-\n-                     --  We need to determine the corresponding machine scalar\n-                     --  size. This loop assumes that machine scalar sizes are\n-                     --  even, and that each possible machine scalar has twice\n-                     --  as many bits as the next smaller one.\n-\n-                     MSS := Max_Machine_Scalar_Size;\n-                     while MSS mod 2 = 0\n-                       and then (MSS / 2) >= SSU\n-                       and then (MSS / 2) > MaxL\n-                     loop\n-                        MSS := MSS / 2;\n-                     end loop;\n+                  --  Now we have a group of component clauses from Start to\n+                  --  Stop whose positions are identical, and MaxL is the\n+                  --  maximum last bit value of any of these components.\n \n-                     --  Here is where we fix up the Component_Bit_Offset value\n-                     --  to account for the reverse bit order. Some examples of\n-                     --  what needs to be done for the case of a machine scalar\n-                     --  size of 8 are:\n+                  --  We need to determine the corresponding machine scalar\n+                  --  size. This loop assumes that machine scalar sizes are\n+                  --  even, and that each possible machine scalar has twice\n+                  --  as many bits as the next smaller one.\n \n-                     --    First_Bit .. Last_Bit     Component_Bit_Offset\n-                     --      old          new          old       new\n+                  MSS := Max_Machine_Scalar_Size;\n+                  while MSS mod 2 = 0\n+                    and then (MSS / 2) >= SSU\n+                    and then (MSS / 2) > MaxL\n+                  loop\n+                     MSS := MSS / 2;\n+                  end loop;\n \n-                     --     0 .. 0       7 .. 7         0         7\n-                     --     0 .. 1       6 .. 7         0         6\n-                     --     0 .. 2       5 .. 7         0         5\n-                     --     0 .. 7       0 .. 7         0         4\n+                  --  Here is where we fix up the Component_Bit_Offset value\n+                  --  to account for the reverse bit order. Some examples of\n+                  --  what needs to be done for the case of a machine scalar\n+                  --  size of 8 are:\n \n-                     --     1 .. 1       6 .. 6         1         6\n-                     --     1 .. 4       3 .. 6         1         3\n-                     --     4 .. 7       0 .. 3         4         0\n+                  --    First_Bit .. Last_Bit     Component_Bit_Offset\n+                  --      old          new          old       new\n \n-                     --  The general rule is that the first bit is obtained by\n-                     --  subtracting the old ending bit from machine scalar\n-                     --  size - 1.\n+                  --     0 .. 0       7 .. 7         0         7\n+                  --     0 .. 1       6 .. 7         0         6\n+                  --     0 .. 2       5 .. 7         0         5\n+                  --     0 .. 7       0 .. 7         0         4\n \n-                     for C in Start .. Stop loop\n-                        declare\n-                           Comp : constant Entity_Id := Comps (C);\n-                           CC   : constant Node_Id   :=\n-                                    Component_Clause (Comp);\n-                           LB   : constant Uint :=\n-                                    Static_Integer (Last_Bit (CC));\n-                           NFB  : constant Uint := MSS - Uint_1 - LB;\n-                           NLB  : constant Uint := NFB + Esize (Comp) - 1;\n-                           Pos  : constant Uint :=\n-                                    Static_Integer (Position (CC));\n+                  --     1 .. 1       6 .. 6         1         6\n+                  --     1 .. 4       3 .. 6         1         3\n+                  --     4 .. 7       0 .. 3         4         0\n \n-                        begin\n-                           if Warn_On_Reverse_Bit_Order then\n-                              Error_Msg_Uint_1 := MSS;\n-                              Error_Msg_N\n-                                (\"info: reverse bit order in machine \" &\n-                                 \"scalar of length^?\", First_Bit (CC));\n-                              Error_Msg_Uint_1 := NFB;\n-                              Error_Msg_Uint_2 := NLB;\n-\n-                              if Bytes_Big_Endian then\n-                                 Error_Msg_NE\n-                                   (\"?\\info: big-endian range for \"\n-                                    & \"component & is ^ .. ^\",\n-                                    First_Bit (CC), Comp);\n-                              else\n-                                 Error_Msg_NE\n-                                   (\"?\\info: little-endian range \"\n-                                    & \"for component & is ^ .. ^\",\n-                                    First_Bit (CC), Comp);\n-                              end if;\n+                  --  The rule is that the first bit is obtained by subtracting\n+                  --  the old ending bit from machine scalar size - 1.\n+\n+                  for C in Start .. Stop loop\n+                     declare\n+                        Comp : constant Entity_Id := Comps (C);\n+                        CC   : constant Node_Id   :=\n+                                 Component_Clause (Comp);\n+                        LB   : constant Uint :=\n+                                 Static_Integer (Last_Bit (CC));\n+                        NFB  : constant Uint := MSS - Uint_1 - LB;\n+                        NLB  : constant Uint := NFB + Esize (Comp) - 1;\n+                        Pos  : constant Uint :=\n+                                 Static_Integer (Position (CC));\n+\n+                     begin\n+                        if Warn_On_Reverse_Bit_Order then\n+                           Error_Msg_Uint_1 := MSS;\n+                           Error_Msg_N\n+                             (\"info: reverse bit order in machine \" &\n+                              \"scalar of length^?\", First_Bit (CC));\n+                           Error_Msg_Uint_1 := NFB;\n+                           Error_Msg_Uint_2 := NLB;\n+\n+                           if Bytes_Big_Endian then\n+                              Error_Msg_NE\n+                                (\"?\\info: big-endian range for \"\n+                                 & \"component & is ^ .. ^\",\n+                                 First_Bit (CC), Comp);\n+                           else\n+                              Error_Msg_NE\n+                                (\"?\\info: little-endian range \"\n+                                 & \"for component & is ^ .. ^\",\n+                                 First_Bit (CC), Comp);\n                            end if;\n+                        end if;\n \n-                           Set_Component_Bit_Offset (Comp, Pos * SSU + NFB);\n-                           Set_Normalized_First_Bit (Comp, NFB mod SSU);\n-                        end;\n-                     end loop;\n+                        Set_Component_Bit_Offset (Comp, Pos * SSU + NFB);\n+                        Set_Normalized_First_Bit (Comp, NFB mod SSU);\n+                     end;\n                   end loop;\n-               end Sort_CC;\n-            end;\n-      end case;\n+               end loop;\n+            end Sort_CC;\n+         end;\n+      end if;\n    end Adjust_Record_For_Reverse_Bit_Order;\n \n    --------------------------------------"}, {"sha": "6015eaec6961584f4e965edbbcedfb6b0344fc7b", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90", "patch": "@@ -5553,8 +5553,7 @@ package body Sem_Ch3 is\n       end if;\n \n       --  If we did not have a range constraint, then set the range from the\n-      --  parent type. Otherwise, the call to Process_Subtype has set the\n-      --  bounds.\n+      --  parent type. Otherwise, the Process_Subtype call has set the bounds.\n \n       if No_Constraint\n         or else not Has_Range_Constraint (Indic)\n@@ -17275,7 +17274,7 @@ package body Sem_Ch3 is\n                         N_Subtype_Declaration);\n \n          --  Create an Itype that is a duplicate of Entity (S) but with the\n-         --  null-exclusion attribute\n+         --  null-exclusion attribute.\n \n          if May_Have_Null_Exclusion\n            and then Is_Access_Type (Entity (S))"}, {"sha": "1c55b3016f796b1d76c1522cf58e1c86b5d84857", "filename": "gcc/ada/sem_elab.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fsem_elab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fsem_elab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.adb?ref=498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90", "patch": "@@ -1676,7 +1676,7 @@ package body Sem_Elab is\n \n          --  Here is where we give the warning\n \n-                  --  All OK if warnings suppressed on the entity\n+         --  All OK if warnings suppressed on the entity\n \n          if not Has_Warnings_Off (Ent) then\n             Error_Msg_Sloc := Sloc (Ent);"}, {"sha": "e07754e86c2d3105312161686d99be58b6d75dfe", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90", "patch": "@@ -7611,6 +7611,10 @@ package body Sem_Res is\n       Resolve (L, Typ);\n       Resolve (H, Typ);\n \n+      if Style_Check then\n+         Check_Enumeration_Subrange (N);\n+      end if;\n+\n       Check_Unset_Reference (L);\n       Check_Unset_Reference (H);\n "}, {"sha": "8f771578718ca365a7ba5d034244ed869938d242", "filename": "gcc/ada/sem_type.adb", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fsem_type.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fsem_type.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_type.adb?ref=498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90", "patch": "@@ -184,6 +184,18 @@ package body Sem_Type is\n    --  Interp_Has_Abstract_Op. Determine whether an overloaded node has an\n    --  abstract interpretation which yields type Typ.\n \n+   function Is_Array_Class_Record_Type (E : Entity_Id) return Boolean;\n+   --  This function tests if entity E is in Array_Kind, or Class_Wide_Kind,\n+   --  or is E_Record_Type or E_Record_Subtype, and returns True for these\n+   --  cases, and False for all others. Note that other record entity kinds\n+   --  such as E_Record_Type_With_Private return False.\n+   --\n+   --  This is a bit of an odd category, maybe it is wrong or a better name\n+   --  could be found for the class of entities being tested. The history\n+   --  is that this used to be done with an explicit range test for the range\n+   --  E_Array_Type .. E_Record_Subtype, which was itself suspicious and is\n+   --  now prohibited by the -gnatyE style check ???\n+\n    procedure New_Interps (N : Node_Id);\n    --  Initialize collection of interpretations for the given node, which is\n    --  either an overloaded entity, or an operation whose arguments have\n@@ -900,7 +912,7 @@ package body Sem_Type is\n       --  An aggregate is compatible with an array or record type\n \n       elsif T2 = Any_Composite\n-        and then Ekind (T1) in E_Array_Type .. E_Record_Subtype\n+        and then Is_Array_Class_Record_Type (T1)\n       then\n          return True;\n \n@@ -2615,6 +2627,18 @@ package body Sem_Type is\n       end if;\n    end Is_Ancestor;\n \n+   --------------------------------\n+   -- Is_Array_Class_Record_Type --\n+   --------------------------------\n+\n+   function Is_Array_Class_Record_Type (E : Entity_Id) return Boolean is\n+   begin\n+      return Is_Array_Type (E)\n+        or else Is_Class_Wide_Type (E)\n+        or else Ekind (E) = E_Record_Type\n+        or else Ekind (E) = E_Record_Subtype;\n+   end Is_Array_Class_Record_Type;\n+\n    ---------------------------\n    -- Is_Invisible_Operator --\n    ---------------------------\n@@ -3033,12 +3057,12 @@ package body Sem_Type is\n          return T1;\n \n       elsif T2 = Any_Composite\n-        and then Ekind (T1) in E_Array_Type .. E_Record_Subtype\n+        and then Is_Array_Class_Record_Type (T1)\n       then\n          return T1;\n \n       elsif T1 = Any_Composite\n-        and then Ekind (T2) in E_Array_Type .. E_Record_Subtype\n+        and then Is_Array_Class_Record_Type (T2)\n       then\n          return T2;\n "}, {"sha": "dcade7ba86f05e3ebaa8012d0b290622e37dcf2c", "filename": "gcc/ada/style.ads", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fstyle.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fstyle.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fstyle.ads?ref=498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -103,6 +103,9 @@ package Style is\n    --  Called after scanning out a binary operator other than a plus, minus\n    --  or exponentiation operator. Intended for checking spacing rules.\n \n+   procedure Check_Enumeration_Subrange (N : Node_Id)\n+     renames Style_Inst.Check_Enumeration_Subrange;\n+\n    procedure Check_Exponentiation_Operator\n      renames Style_Inst.Check_Exponentiation_Operator;\n    --  Called after scanning out an exponentiation operator. Intended for"}, {"sha": "c19a0969c51dca3ab6e35dc8efa0389f87183c5b", "filename": "gcc/ada/styleg.adb", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fstyleg.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fstyleg.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fstyleg.adb?ref=498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90", "patch": "@@ -32,10 +32,13 @@ with Casing;   use Casing;\n with Csets;    use Csets;\n with Einfo;    use Einfo;\n with Err_Vars; use Err_Vars;\n+with Lib;      use Lib;\n+with Namet;    use Namet;\n with Opt;      use Opt;\n with Scans;    use Scans;\n with Sinfo;    use Sinfo;\n with Sinput;   use Sinput;\n+with Snames;   use Snames;\n with Stylesw;  use Stylesw;\n \n package body Styleg is\n@@ -550,6 +553,82 @@ package body Styleg is\n       end if;\n    end Check_Dot_Dot;\n \n+   --------------------------------\n+   -- Check_Enumeration_Subrange --\n+   --------------------------------\n+\n+   procedure Check_Enumeration_Subrange (N : Node_Id) is\n+      function First_Last_Ref return Boolean;\n+      --  Returns True if N is of the form X'First .. X'Last where X is the\n+      --  same entity for both attributes. N is already known to be N_Range.\n+\n+      --------------------\n+      -- First_Last_Ref --\n+      --------------------\n+\n+      function First_Last_Ref return Boolean is\n+         L : constant Node_Id := Low_Bound  (N);\n+         H : constant Node_Id := High_Bound (N);\n+\n+      begin\n+         if Nkind (L) = N_Attribute_Reference\n+           and then Nkind (H) = N_Attribute_Reference\n+           and then Attribute_Name (L) = Name_First\n+           and then Attribute_Name (H) = Name_Last\n+         then\n+            declare\n+               PL : constant Node_Id := Prefix (L);\n+               PH : constant Node_Id := Prefix (H);\n+            begin\n+               if Is_Entity_Name (PL)\n+                 and then Is_Entity_Name (PH)\n+                 and then Entity (PL) = Entity (PH)\n+               then\n+                  return True;\n+               end if;\n+            end;\n+         end if;\n+\n+         return False;\n+      end First_Last_Ref;\n+\n+   --  Start of processing for Check_Enumeration_Subrange\n+\n+   begin\n+      if Style_Check_Enumeration_Subranges then\n+\n+         if Nkind (N) = N_Range\n+\n+           --  Only consider ranges that are explicit in the source\n+\n+           and then Comes_From_Source (N)\n+\n+           --  Only consider enumeration types\n+\n+           and then Is_Enumeration_Type (Etype (N))\n+\n+           --  Exclude standard types. Most importantly we want to exclude the\n+           --  standard character types, since we want to allow ranges like\n+           --  '0' .. '9'. But also exclude Boolean since False .. True is OK.\n+\n+           and then Sloc (Root_Type (Etype (N))) /= Standard_Location\n+\n+           --  Exclude X'First .. X'Last if X is the same entity for both\n+\n+           and then not First_Last_Ref\n+\n+           --  Allow the range if in same unit as type declaration (or the\n+           --  corresponding body or any of its subunits).\n+\n+           and then not In_Same_Extended_Unit (N, Etype (N))\n+         then\n+            Error_Msg\n+              (\"(style) explicit enumeration subrange not allowed\",\n+               Sloc (N));\n+         end if;\n+      end if;\n+   end Check_Enumeration_Subrange;\n+\n    ---------------\n    -- Check_EOF --\n    ---------------"}, {"sha": "ea78f6ed473ae977410cdd9df92882c029794052", "filename": "gcc/ada/styleg.ads", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fstyleg.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fstyleg.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fstyleg.ads?ref=498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -92,6 +92,10 @@ package Styleg is\n    procedure Check_Dot_Dot;\n    --  Called after scanning out dot dot to check spacing\n \n+   procedure Check_Enumeration_Subrange (N : Node_Id);\n+   --  Called to check a node that may be an N_Range node for an enumeration\n+   --  subtype occurring other than in the defining unit of the type.\n+\n    procedure Check_EOF;\n    --  Called after scanning out EOF mark\n "}, {"sha": "7d3c5cef613e330fad788eaa7682937b90507e7c", "filename": "gcc/ada/stylesw.adb", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fstylesw.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fstylesw.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fstylesw.adb?ref=498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -59,6 +59,12 @@ package body Stylesw is\n                      \"u\" &  -- check no unnecessary blank lines\n                      \"x\";   -- check extra parentheses around conditionals\n \n+   --  Note: we intend GNAT_Style to also include the following, but we do\n+   --  not yet have the whole tool suite clean with respect to this.\n+\n+   --                \"B\" &  -- check boolean operators\n+   --                \"E\" &  -- check enumeration ranges\n+\n    -------------------------------\n    -- Reset_Style_Check_Options --\n    -------------------------------\n@@ -73,6 +79,7 @@ package body Stylesw is\n       Style_Check_Boolean_And_Or        := False;\n       Style_Check_Comments              := False;\n       Style_Check_DOS_Line_Terminator   := False;\n+      Style_Check_Enumeration_Subranges := False;\n       Style_Check_End_Labels            := False;\n       Style_Check_Form_Feeds            := False;\n       Style_Check_Horizontal_Tabs       := False;\n@@ -158,6 +165,7 @@ package body Stylesw is\n       Add ('c', Style_Check_Comments);\n       Add ('d', Style_Check_DOS_Line_Terminator);\n       Add ('e', Style_Check_End_Labels);\n+      Add ('E', Style_Check_Enumeration_Subranges);\n       Add ('f', Style_Check_Form_Feeds);\n       Add ('h', Style_Check_Horizontal_Tabs);\n       Add ('i', Style_Check_If_Then_Layout);\n@@ -324,6 +332,9 @@ package body Stylesw is\n             when 'e' =>\n                Style_Check_End_Labels            := True;\n \n+            when 'E' =>\n+               Style_Check_Enumeration_Subranges := True;\n+\n             when 'f' =>\n                Style_Check_Form_Feeds            := True;\n \n@@ -488,6 +499,9 @@ package body Stylesw is\n             when 'e' =>\n                Style_Check_End_Labels            := False;\n \n+            when 'E' =>\n+               Style_Check_Enumeration_Subranges := False;\n+\n             when 'f' =>\n                Style_Check_Form_Feeds            := False;\n "}, {"sha": "7d5a461ded9b7ac57f560855931378168015d2f9", "filename": "gcc/ada/stylesw.ads", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fstylesw.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fstylesw.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fstylesw.ads?ref=498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -113,6 +113,12 @@ package Stylesw is\n    --  This can be set True by using the -gnatye switch. If it is True, then\n    --  optional END labels must always be present.\n \n+   Style_Check_Enumeration_Subranges : Boolean := False;\n+   --  This can be set True by using the -gnatyE switch. If it is True, then\n+   --  explicit subranges (using .. notation) on enumeration subtypes are not\n+   --  permitted in other than the same source unit in which the enumeration\n+   --  subtype is declared.\n+\n    Style_Check_Form_Feeds : Boolean := False;\n    --  This can be set True by using the -gnatyf switch. If it is True, then\n    --  form feeds and vertical tabs are not allowed in the source text."}, {"sha": "1bd22b5045c020de834079aa0e8d22f794eed80e", "filename": "gcc/ada/usage.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fusage.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fusage.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fusage.adb?ref=498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90", "patch": "@@ -533,6 +533,7 @@ begin\n    Write_Line (\"        c    check comment format\");\n    Write_Line (\"        d    check no DOS line terminators\");\n    Write_Line (\"        e    check end/exit labels present\");\n+   Write_Line (\"        E    check no explicit enumeration subranges\");\n    Write_Line (\"        f    check no form feeds/vertical tabs in source\");\n    Write_Line (\"        g    check standard GNAT style rules\");\n    Write_Line (\"        h    check no horizontal tabs in source\");"}, {"sha": "5fbf775988b4318b04977f30687aac57eae7c6da", "filename": "gcc/ada/vms_data.ads", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fvms_data.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90/gcc%2Fada%2Fvms_data.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fvms_data.ads?ref=498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90", "patch": "@@ -2259,10 +2259,12 @@ package VMS_Data is\n                                                \"-gnaty-A \"                 &\n                                             \"BLANKS \"                      &\n                                                \"-gnatyb \"                  &\n-                                            \"BOOLEAN_OPERATORS \"           &\n-                                               \"-gnatyB \"                  &\n                                             \"NOBLANKS \"                    &\n                                                \"-gnaty-b \"                 &\n+                                            \"BOOLEAN_OPERATORS \"           &\n+                                               \"-gnatyB \"                  &\n+                                            \"NOBOOLEAN_OPERATORS \"         &\n+                                               \"-gnaty-B \"                 &\n                                             \"COMMENTS \"                    &\n                                                \"-gnatyc \"                  &\n                                             \"NOCOMMENTS \"                  &\n@@ -2275,6 +2277,10 @@ package VMS_Data is\n                                                \"-gnatye \"                  &\n                                             \"NOEND \"                       &\n                                                \"-gnaty-e \"                 &\n+                                            \"ENUMERATION_RANGES \"          &\n+                                               \"-gnatyE \"                  &\n+                                            \"NOENUMERATION_RANGES \"        &\n+                                               \"-gnaty-E \"                 &\n                                             \"VTABS \"                       &\n                                                \"-gnatyf \"                  &\n                                             \"NOVTABS \"                     &"}]}