{"sha": "fc94a55b9221b13ebe9ac1c01a096d18c5d92594", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmM5NGE1NWI5MjIxYjEzZWJlOWFjMWMwMWEwOTZkMThjNWQ5MjU5NA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-05-17T12:28:54Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-05-17T12:28:54Z"}, "message": "Initial revision\n\nFrom-SVN: r11985", "tree": {"sha": "3fe8f6c2cde777ce58d62f3fd96a198b014b03b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3fe8f6c2cde777ce58d62f3fd96a198b014b03b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fc94a55b9221b13ebe9ac1c01a096d18c5d92594", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc94a55b9221b13ebe9ac1c01a096d18c5d92594", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc94a55b9221b13ebe9ac1c01a096d18c5d92594", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc94a55b9221b13ebe9ac1c01a096d18c5d92594/comments", "author": null, "committer": null, "parents": [{"sha": "b8abf72abbb7370d88a16fb7e2600f386fb41985", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8abf72abbb7370d88a16fb7e2600f386fb41985", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8abf72abbb7370d88a16fb7e2600f386fb41985"}], "stats": {"total": 1021, "additions": 1021, "deletions": 0}, "files": [{"sha": "22743d2cb56b847888191e86bfe8a38bf51c82b3", "filename": "gcc/objc/thr-mach.c", "status": "added", "additions": 359, "deletions": 0, "changes": 359, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc94a55b9221b13ebe9ac1c01a096d18c5d92594/gcc%2Fobjc%2Fthr-mach.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc94a55b9221b13ebe9ac1c01a096d18c5d92594/gcc%2Fobjc%2Fthr-mach.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fthr-mach.c?ref=fc94a55b9221b13ebe9ac1c01a096d18c5d92594", "patch": "@@ -0,0 +1,359 @@\n+/* GNU Objective C Runtime Thread Implementation\n+   Copyright (C) 1996 Free Software Foundation, Inc.\n+\n+Author: Galen C. Hunt (gchunt@cs.rochester.edu)\n+Modified for Mach threads by: Bill Bumgarner <bbum@friday.com>\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify it under the\n+terms of the GNU General Public License as published by the Free Software\n+Foundation; either version 2, or (at your option) any later version.\n+\n+GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n+details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with files compiled with\n+   GCC to produce an executable, this does not cause the resulting executable\n+   to be covered by the GNU General Public License. This exception does not\n+   however invalidate any other reasons why the executable file might be\n+   covered by the GNU General Public License.  */\n+\n+#include <mach/mach.h>\n+#include <mach/cthreads.h>\n+\n+/********\n+ *  This structure represents a single mutual exclusion lock.  Lock semantics\n+ *  are detailed with the subsequent functions.  We use whatever lock is\n+ *  provided by the system.  We augment it with depth and current owner id\n+ *  fields to implement and re-entrant lock.\n+ */\n+struct _objc_mutex \n+{\n+    volatile _objc_thread_t     owner;          /* Id of thread that owns.  */\n+    volatile int                depth;          /* # of acquires.           */\n+    struct mutex                lock;           /* cthread mutex            */\n+};\n+\n+\n+/********\n+ * obtain the maximum thread priority that can set for t.  Under the\n+ * mach threading model, it is possible for the developer to adjust the\n+ * maximum priority downward only-- cannot be raised without superuser\n+ * priviledges.  Once lowered, it cannot be raised.\n+ */\n+static int __mach_get_max_thread_priority(cthread_t t, int *base) {\n+    thread_t   \t\t      threadP;\n+    kern_return_t             error;\n+    struct thread_sched_info  info;\n+    unsigned int              info_count=THREAD_SCHED_INFO_COUNT;\n+    \n+    if (t == NULL)\n+\treturn -1;\n+\n+    threadP  = cthread_thread(t); \t/* get thread underlying */\n+\n+    error=thread_info(threadP, THREAD_SCHED_INFO, \n+\t\t      (thread_info_t)&info, &info_count);\n+\n+    if (error != KERN_SUCCESS)\n+\treturn -1;\n+\n+    if (base != NULL)\n+\t*base = info.base_priority;\n+\n+    return info.max_priority;\n+}\n+\t\n+/********\n+ *  Initialize the threads subsystem.  Returns 0 if successful, or -1 if no\n+ *  thread support is available.\n+ */\n+int\n+__objc_init_thread_system(void)\n+{\n+    DEBUG_PRINTF(\"__objc_init_thread_system\\n\");\n+    return 0;                                    /* Succeeded.       */\n+}\n+\n+\n+int\n+__objc_fini_thread_system(void)\n+{\n+  return 0;\n+}\n+\n+/********\n+ *  Create a new thread of execution and return its id.  Return NULL if fails.\n+ *  The new thread starts in \"func\" with the given argument.\n+ */\n+_objc_thread_t\n+objc_thread_create(void (*func)(void *arg), void *arg)\n+{\n+    _objc_thread_t      thread_id = NULL;       /* Detached thread id.      */\n+    cthread_t           new_thread_handle;      /* cthread handle.          */\n+\n+    objc_mutex_lock(__objc_runtime_mutex);\n+    \n+    /* create thread */\n+    new_thread_handle = cthread_fork((cthread_fn_t)func, arg);\n+\n+    if(new_thread_handle) {\n+        thread_id = *(_objc_thread_t *)&new_thread_handle; /* this is not terribly portable */\n+        cthread_detach(new_thread_handle);      /* fully detach thread */\n+        __objc_runtime_threads_alive++;         /* increment thread count */\n+    }\n+    \n+    objc_mutex_unlock(__objc_runtime_mutex);\n+    return thread_id;\n+}\n+\n+/********\n+ *  Set the current thread's priority.\n+ */\n+int\n+objc_thread_set_priority(int priority)\n+{\n+    _objc_thread_t \t*t\t     = objc_thread_id();\n+    cthread_t      \tcT\t     = (cthread_t) t; /* see objc_thread_id() */\n+    int \t\tmaxPriority  = __mach_get_max_thread_priority(cT, NULL);\n+    int         \tsys_priority = 0;\n+\n+    if (maxPriority == -1)\n+\treturn -1;\n+\n+    switch (priority) {\n+    case OBJC_THREAD_INTERACTIVE_PRIORITY:\n+        sys_priority = maxPriority;\n+        break;\n+    case OBJC_THREAD_BACKGROUND_PRIORITY:\n+        sys_priority = (maxPriority * 2) / 3;\n+        break;\n+    case OBJC_THREAD_LOW_PRIORITY:\n+        sys_priority = maxPriority / 3;\n+        break;\n+    default:\n+\treturn -1;\n+    }\n+\n+    if (sys_priority == 0)\n+\treturn -1;\n+    \n+    if (cthread_priority(cT, sys_priority, 0) == KERN_SUCCESS)\n+        return 0;                               /* Changed priority. End.   */\n+    \n+    return -1;                                  /* Failed.                  */\n+}\n+\n+/********\n+ *  Return the current thread's priority [well, whatever it is closest to].\n+ */\n+int\n+objc_thread_get_priority(void)\n+{\n+    _objc_thread_t *t\t        = objc_thread_id();\n+    cthread_t      cT\t        = (cthread_t) t; /* see objc_thread_id() */\n+    int \t   basePriority;\n+    int \t   maxPriority;\n+    int            sys_priority = 0;\n+\n+    int interactiveT, backgroundT, lowT; /* threasholds */\n+\n+    maxPriority = __mach_get_max_thread_priority(cT, &basePriority);\n+\n+    if(maxPriority == -1)\n+\treturn -1;\n+\n+    if (basePriority > ( (maxPriority * 2) / 3))\n+\treturn OBJC_THREAD_INTERACTIVE_PRIORITY; /* interactive priority\n+\t\t\t\t\t\t */\n+    if (basePriority > ( maxPriority / 3))\n+\treturn OBJC_THREAD_BACKGROUND_PRIORITY; /* background priority\n+\t\t\t\t\t\t */\n+    return OBJC_THREAD_LOW_PRIORITY; /* everything else is low */\n+}\n+\n+/********\n+ *  Yield our process time to another thread.  Any BUSY waiting that is done\n+ *  by a thread should use this function to make sure that other threads can\n+ *  make progress even on a lazy uniprocessor system.\n+ */\n+void\n+objc_thread_yield(void)\n+{\n+    cthread_yield();                            /* Yield to equal thread.   */\n+}\n+\n+/********\n+ *  Terminate the current tread.  Doesn't return anything.  Doesn't return.\n+ *  Actually, if it failed returns -1.\n+ */\n+int\n+objc_thread_exit(void)\n+{\n+  objc_mutex_lock(__objc_runtime_mutex);\n+  __objc_runtime_threads_alive--;\n+  objc_mutex_unlock(__objc_runtime_mutex);\n+      \n+  cthread_exit(&__objc_thread_exit_status);     /* Terminate thread.        */\n+  return -1;\n+}\n+\n+/********\n+ *  Returns an integer value which uniquely describes a thread.  Must not be\n+ *  NULL which is reserved as a marker for \"no thread\".\n+ */\n+_objc_thread_t\n+objc_thread_id(void)\n+{\n+  cthread_t self = cthread_self();\n+  return (_objc_thread_t)self;\n+}\n+\n+/********\n+ *  Sets the thread's local storage pointer.  Returns 0 if successful or -1\n+ *  if failed.\n+ */\n+\n+int\n+objc_thread_set_data(void *value)\n+{\n+  cthread_set_data(cthread_self(), (any_t) value);\n+  return 0;\n+}\n+\n+/********\n+ *  Returns the thread's local storage pointer.  Returns NULL on failure.\n+ */\n+void *\n+objc_thread_get_data(void)\n+{\n+  return (void *) cthread_data(cthread_self());\n+}\n+\n+/********\n+ *  Allocate a mutex.  Return the mutex pointer if successful or NULL if the\n+ *  allocation failed for any reason.\n+ */\n+_objc_mutex_t\n+objc_mutex_allocate(void)\n+{\n+    _objc_mutex_t mutex;\n+    int         err = 0;\n+    \n+    if (!(mutex = (_objc_mutex_t)__objc_xmalloc(sizeof(struct _objc_mutex))))\n+        return NULL;                            /* Abort if malloc failed.  */\n+\n+    err = mutex_init(&(mutex->lock));\n+    \n+    if (err != 0) {                             /* System init failed?      */\n+        free(mutex);                            /* Yes, free local memory.  */\n+        return NULL;                            /* Abort.                   */\n+    }\n+    mutex->owner = (_objc_thread_t) -1;         /* No owner.                */\n+    mutex->depth = 0;                           /* No locks.                */\n+    return mutex;                               /* Return mutex handle.     */\n+}\n+\n+/********\n+ *  Deallocate a mutex.  Note that this includes an implicit mutex_lock to\n+ *  insure that no one else is using the lock.  It is legal to deallocate\n+ *  a lock if we have a lock on it, but illegal to deallocate a lock held\n+ *  by anyone else.\n+ *  Returns the number of locks on the thread.  (1 for deallocate).\n+ */\n+int\n+objc_mutex_deallocate(_objc_mutex_t mutex)\n+{\n+    int         depth;                          /* # of locks on mutex.     */\n+\n+    if (!mutex)                                 /* Is argument bad?         */\n+        return -1;                              /* Yes, abort.              */\n+    depth = objc_mutex_lock(mutex);             /* Must have lock.          */\n+    \n+    mutex_unlock(&(mutex->lock));               /* Must unlock system mutex.*/\n+    mutex_clear(&(mutex->lock));                /* Free system mutex.       */\n+    \n+    free(mutex);                                /* Free memory.             */\n+    return depth;                               /* Return last depth.       */\n+}\n+\n+/********\n+ *  Grab a lock on a mutex.  If this thread already has a lock on this mutex\n+ *  then we increment the lock count.  If another thread has a lock on the \n+ *  mutex we block and wait for the thread to release the lock.\n+ *  Returns the lock count on the mutex held by this thread.\n+ */\n+int\n+objc_mutex_lock(_objc_mutex_t mutex)\n+{\n+    _objc_thread_t thread_id;                  /* Cache our thread id.     */\n+\n+    if (!mutex)                                 /* Is argument bad?         */\n+        return -1;                              /* Yes, abort.              */\n+    thread_id = objc_thread_id();               /* Get this thread's id.    */\n+    if (mutex->owner == thread_id)              /* Already own lock?        */\n+        return ++mutex->depth;                  /* Yes, increment depth.    */\n+\n+    mutex_lock(&(mutex->lock));                 /* Lock cthread mutex.      */\n+    \n+    mutex->owner = thread_id;                   /* Mark thread as owner.    */\n+    return mutex->depth = 1;                    /* Increment depth to end.  */\n+}\n+\n+/********\n+ *  Try to grab a lock on a mutex.  If this thread already has a lock on\n+ *  this mutex then we increment the lock count and return it.  If another\n+ *  thread has a lock on the mutex returns -1.\n+ */\n+int\n+objc_mutex_trylock(_objc_mutex_t mutex)\n+{\n+    _objc_thread_t         thread_id;           /* Cache our thread id.     */\n+\n+    if (!mutex)                                 /* Is argument bad?         */\n+        return -1;                              /* Yes, abort.              */\n+    thread_id = objc_thread_id();               /* Get this thread's id.    */\n+    if (mutex->owner == thread_id)              /* Already own lock?        */\n+        return ++mutex->depth;                  /* Yes, increment depth.    */\n+    \n+    if (mutex_try_lock(&(mutex->lock)) == 0)    /* Lock cthread mutex.      */\n+        return -1;                              /* Failed, abort.           */\n+    \n+    mutex->owner = thread_id;                   /* Mark thread as owner.    */\n+    return mutex->depth = 1;                    /* Increment depth to end.  */\n+}\n+\n+/********\n+ *  Decrements the lock count on this mutex by one.  If the lock count reaches\n+ *  zero, release the lock on the mutex.  Returns the lock count on the mutex.\n+ *  It is an error to attempt to unlock a mutex which this thread doesn't hold\n+ *  in which case return -1 and the mutex is unaffected.\n+ *  Will also return -1 if the mutex free fails.\n+ */\n+int\n+objc_mutex_unlock(_objc_mutex_t mutex)\n+{\n+    _objc_thread_t    thread_id;                /* Cache our thread id.     */\n+    \n+    if (!mutex)                                 /* Is argument bad?         */\n+        return -1;                              /* Yes, abort.              */\n+    thread_id = objc_thread_id();               /* Get this thread's id.    */\n+    if (mutex->owner != thread_id)              /* Does some else own lock? */\n+        return -1;                              /* Yes, abort.              */\n+    if (mutex->depth > 1)                       /* Released last lock?      */\n+        return --mutex->depth;                  /* No, Decrement depth, end.*/\n+    mutex->depth = 0;                           /* Yes, reset depth to 0.   */\n+    mutex->owner = (_objc_thread_t) -1;         /* Set owner to \"no thread\".*/\n+    \n+    mutex_unlock(&(mutex->lock));               /* unlock cthread mutex.    */\n+    \n+    return 0;                                   /* No, return success.      */\n+}"}, {"sha": "0db006b8bc7dcfb2f4bc6796fb13f3df3914bc1c", "filename": "gcc/objc/thr-os2.c", "status": "added", "additions": 341, "deletions": 0, "changes": 341, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc94a55b9221b13ebe9ac1c01a096d18c5d92594/gcc%2Fobjc%2Fthr-os2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc94a55b9221b13ebe9ac1c01a096d18c5d92594/gcc%2Fobjc%2Fthr-os2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fthr-os2.c?ref=fc94a55b9221b13ebe9ac1c01a096d18c5d92594", "patch": "@@ -0,0 +1,341 @@\n+/* GNU Objective C Runtime Thread Interface - OS/2 emx Implementation\n+   Copyright (C) 1996 Free Software Foundation, Inc.\n+\n+Author: Thomas Baier (baier@ci.tuwien.ac.at)\n+\n+This file is included into thread.c\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify it under the\n+terms of the GNU General Public License as published by the Free Software\n+Foundation; either version 2, or (at your option) any later version.\n+\n+GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n+details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with files compiled with\n+   GCC to produce an executable, this does not cause the resulting executable\n+   to be covered by the GNU General Public License. This exception does not\n+   however invalidate any other reasons why the executable file might be\n+   covered by the GNU General Public License.  */\n+\n+#define INCL_DOSSEMAPHORES\n+#define INCL_DOSPROCESS\n+\n+/*\n+ * conflicts with objc.h:       SEL, BOOL, id\n+ * solution:  prefixing those with _OS2_ before including <os2.h>\n+ */\n+#define SEL _OS2_SEL\n+#define BOOL _OS2_BOOL\n+#define id _OS2_id\n+#include <os2.h>\n+#undef id\n+#undef SEL\n+#undef BOOL\n+\n+#include <stdlib.h>\n+\n+/********\n+ *  This structure represents a single mutual exclusion lock.  Lock semantics\n+ *  are detailed with the subsequent functions.  We use whatever lock is\n+ *  provided by the system.  We augment it with depth and current owner id\n+ *  fields to implement and re-entrant lock.\n+ */\n+struct _objc_mutex \n+{\n+  volatile _objc_thread_t owner;          /* Id of thread that owns.  */\n+  volatile int            depth;          /* # of acquires.           */\n+  HMTX                    handle;         /* OS/2 mutex HANDLE.      */\n+};\n+\n+/*****************************************************************************\n+ *  Static variables.\n+ */\n+/* none needed for OS/2 */\n+\n+/********\n+ *  Initialize the threads subsystem.  Returns 0 if successful, or -1 if no\n+ *  thread support is available.\n+ */\n+int\n+__objc_init_thread_system(void)\n+{\n+  DEBUG_PRINTF(\"__objc_init_thread_system (os2-emx)\\n\");\n+\n+  /* no initialization of thread subsystem */\n+  return 0;                               \t/* Yes, return success.     */\n+}\n+\n+int\n+__objc_fini_thread_system(void)\n+{\n+  /* no termination code for thread subsystem */\n+  return 0;\n+}\n+\n+/********\n+ *  Create a new thread of execution and return its id.  Return NULL if fails.\n+ *  The new thread starts in \"func\" with the given argument.\n+ */\n+_objc_thread_t\n+objc_thread_create(void (*func)(void *arg), void *arg)\n+{\n+  int thread_id = 0;  /* id of the newly created thread */\n+\n+  objc_mutex_lock(__objc_runtime_mutex);\n+\n+  /* create a thread calling \"func\", args \"arg\", stack size 32768 bytes */\n+  if ((thread_id = _beginthread (func,NULL,32768,arg)) < 0)\n+    thread_id = 0;\n+  else\n+    __objc_runtime_threads_alive++;\n+  \n+  objc_mutex_unlock(__objc_runtime_mutex);\n+  \n+  return (_objc_thread_t)thread_id;\n+}\n+\n+/********\n+ *  Set the current thread's priority.\n+ */\n+int\n+objc_thread_set_priority(int priority)\n+{\n+  ULONG sys_class = 0;\n+  ULONG sys_priority = 0;\n+\n+  /* OBJC_THREAD_INTERACTIVE_PRIORITY -> PRTYC_FOREGROUNDSERVER\n+   * OBJC_THREAD_BACKGROUND_PRIORITY  -> PRTYC_REGULSR\n+   * OBJC_THREAD_LOW_PRIORITY         -> PRTYC_IDLETIME */\n+  \n+  switch (priority) {\n+  case OBJC_THREAD_INTERACTIVE_PRIORITY:\n+    sys_class = PRTYC_REGULAR;\n+    sys_priority = 10;\n+    break;\n+  default:\n+  case OBJC_THREAD_BACKGROUND_PRIORITY:\n+    sys_class = PRTYC_IDLETIME;\n+    sys_priority = 25;\n+    break;\n+  case OBJC_THREAD_LOW_PRIORITY:\n+    sys_class = PRTYC_IDLETIME;\n+    sys_priority = 0;\n+    break;\n+  }\n+  if (!DosSetPriority (PRTYS_THREAD,sys_class,sys_priority,*_threadid))\n+    return 0;                                  \t/* Changed priority. End.   */\n+    \n+  return -1;                                  \t/* Failed.                  */\n+}\n+\n+/********\n+ *  Return the current thread's priority.\n+ */\n+int\n+objc_thread_get_priority(void)\n+{\n+  PTIB ptib;\n+  PPIB ppib;\n+\n+  DosGetInfoBlocks (&ptib,&ppib); /* get information about current thread */\n+\n+  switch (ptib->tib_ptib2->tib2_ulpri) {\n+  case PRTYC_IDLETIME:\n+  case PRTYC_REGULAR:\n+  case PRTYC_TIMECRITICAL:\n+  case PRTYC_FOREGROUNDSERVER:\n+  default:\n+    return OBJC_THREAD_INTERACTIVE_PRIORITY;\n+  }\n+  return -1;                                  \t/* Couldn't get priority.   */\n+}\n+\n+/********\n+ *  Yield our process time to another thread.  Any BUSY waiting that is done\n+ *  by a thread should use this function to make sure that other threads can\n+ *  make progress even on a lazy uniprocessor system.\n+ */\n+void\n+objc_thread_yield(void)\n+{\n+  DosSleep (0);\t                            \t/* Yield to equal thread.   */\n+}\n+\n+/********\n+ *  Terminate the current tread.  Doesn't return anything.  Doesn't return.\n+ *  Actually, if it failed returns -1.\n+ */\n+int\n+objc_thread_exit(void)\n+{\n+  objc_mutex_lock(__objc_runtime_mutex);\n+  __objc_runtime_threads_alive--;\n+  objc_mutex_unlock(__objc_runtime_mutex);\n+\n+  _endthread (); /* terminate the thread, NEVER use DosExit () */\n+\n+  return -1;\n+}\n+\n+/********\n+ *  Returns an integer value which uniquely describes a thread.  Must not be\n+ *  -1 which is reserved as a marker for \"no thread\".\n+ */\n+_objc_thread_t\n+objc_thread_id(void)\n+{\n+  return (_objc_thread_t) *_threadid;  /* Return thread id.        */\n+}\n+\n+/********\n+ *  Sets the thread's local storage pointer.  Returns 0 if successful or -1\n+ *  if failed.\n+ */\n+int\n+objc_thread_set_data(void *value)\n+{\n+  *_threadstore () = value;\n+\n+  return 0;\n+}\n+\n+/********\n+ *  Returns the thread's local storage pointer.  Returns NULL on failure.\n+ */\n+void *\n+objc_thread_get_data(void)\n+{\n+  return *_threadstore ();\n+}\n+\n+/********\n+ *  Allocate a mutex.  Return the mutex pointer if successful or NULL if\n+ *  the allocation fails for any reason.\n+ */\n+_objc_mutex_t\n+objc_mutex_allocate(void)\n+{\n+    _objc_mutex_t mutex;\n+    int         err = 0;\n+\n+    if (!(mutex = (_objc_mutex_t)__objc_xmalloc(sizeof(struct _objc_mutex))))\n+        return NULL;                            /* Abort if malloc failed.  */\n+\n+    if (DosCreateMutexSem (NULL,&(mutex->handle),0L,0) > 0) {\n+      free (mutex);\n+      return NULL;\n+    }\n+\n+    mutex->owner = NULL;                        /* No owner.                */\n+    mutex->depth = 0;                           /* No locks.                */\n+    return mutex;                               /* Return mutex handle.     */\n+}\n+\n+/********\n+ *  Deallocate a mutex.  Note that this includes an implicit mutex_lock to\n+ *  insure that no one else is using the lock.  It is legal to deallocate\n+ *  a lock if we have a lock on it, but illegal to deallotcate a lock held\n+ *  by anyone else.\n+ *  Returns the number of locks on the thread.  (1 for deallocate).\n+ */\n+int\n+objc_mutex_deallocate(_objc_mutex_t mutex)\n+{\n+    int         depth;                          /* # of locks on mutex.     */\n+\n+    if (!mutex)                                 /* Is argument bad?         */\n+        return -1;                              /* Yes, abort.              */\n+    depth = objc_mutex_lock(mutex);             /* Must have lock.          */\n+\n+    DosCloseMutexSem (mutex->handle);\n+    \n+    free(mutex);                                /* Free memory.             */\n+    return depth;                               /* Return last depth.       */\n+}\n+\n+/********\n+ *  Grab a lock on a mutex.  If this thread already has a lock on this mutex\n+ *  then we increment the lock count.  If another thread has a lock on the \n+ *  mutex we block and wait for the thread to release the lock.\n+ *  Returns the lock count on the mutex held by this thread.\n+ */\n+int\n+objc_mutex_lock(_objc_mutex_t mutex)\n+{\n+    _objc_thread_t      thread_id;              /* Cache our thread id.     */\n+\n+    if (!mutex)                                 /* Is argument bad?         */\n+        return -1;                              /* Yes, abort.              */\n+\n+    thread_id = objc_thread_id();               /* Get this thread's id.    */\n+    if (mutex->owner == thread_id)              /* Already own lock?        */\n+        return ++mutex->depth;                  /* Yes, increment depth.    */\n+\n+    if (DosRequestMutexSem (mutex->handle,-1L) != 0)\n+      return -1;\n+\n+    mutex->owner = thread_id;                   /* Mark thread as owner.    */\n+\n+    return ++mutex->depth;                      /* Increment depth to end.  */\n+}\n+\n+/********\n+ *  Try to grab a lock on a mutex.  If this thread already has a lock on\n+ *  this mutex then we increment the lock count and return it.  If another\n+ *  thread has a lock on the mutex returns -1.\n+ */\n+int\n+objc_mutex_trylock(_objc_mutex_t mutex)\n+{\n+    _objc_thread_t      thread_id;              /* Cache our thread id.     */\n+\n+    if (!mutex)                                 /* Is argument bad?         */\n+        return -1;                              /* Yes, abort.              */\n+    thread_id = objc_thread_id();               /* Get this thread's id.    */\n+    if (mutex->owner == thread_id)              /* Already own lock?        */\n+        return ++mutex->depth;                  /* Yes, increment depth.    */\n+\n+    if (DosRequestMutexSem (mutex->handle,0L) != 0)\n+      return -1;\n+\n+    mutex->owner = thread_id;                   /* Mark thread as owner.    */\n+    return ++mutex->depth;                      /* Increment depth to end.  */\n+}\n+\n+/********\n+ *  Decrements the lock count on this mutex by one.  If the lock count reaches\n+ *  zero, release the lock on the mutex.  Returns the lock count on the mutex.\n+ *  It is an error to attempt to unlock a mutex which this thread doesn't hold\n+ *  in which case return -1 and the mutex is unaffected.\n+ *  Will also return -1 if the mutex free fails.\n+ */\n+int\n+objc_mutex_unlock(_objc_mutex_t mutex)\n+{\n+    _objc_thread_t      thread_id;              /* Cache our thread id.     */\n+    \n+    if (!mutex)                                 /* Is argument bad?         */\n+        return -1;                              /* Yes, abort.              */\n+    thread_id = objc_thread_id();               /* Get this thread's id.    */\n+    if (mutex->owner != thread_id)              /* Does some else own lock? */\n+        return -1;                              /* Yes, abort.              */\n+    if (mutex->depth > 1)                       /* Released last lock?      */\n+        return --mutex->depth;                  /* No, Decrement depth, end.*/\n+    mutex->depth = 0;                           /* Yes, reset depth to 0.   */\n+    mutex->owner = NULL;                        /* Set owner to \"no thread\".*/\n+    \n+    if (DosReleaseMutexSem(mutex->handle) != 0)\n+        return -1;                              /* Failed, abort.           */\n+    \n+    return 0;                                   /* No, return success.      */\n+}"}, {"sha": "fd9be1bfc12a628a90173f58eba69c13c93c93e6", "filename": "gcc/objc/thr-posix.c", "status": "added", "additions": 321, "deletions": 0, "changes": 321, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc94a55b9221b13ebe9ac1c01a096d18c5d92594/gcc%2Fobjc%2Fthr-posix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc94a55b9221b13ebe9ac1c01a096d18c5d92594/gcc%2Fobjc%2Fthr-posix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fthr-posix.c?ref=fc94a55b9221b13ebe9ac1c01a096d18c5d92594", "patch": "@@ -0,0 +1,321 @@\n+/* GNU Objective C Runtime Thread Interface for POSIX compliant threads\n+   Copyright (C) 1996 Free Software Foundation, Inc.\n+\n+Author: Galen C. Hunt (gchunt@cs.rochester.edu)\n+Modified for Linux & Pthreads: Kai-Uwe Sattler (kus@iti.cs.uni-magdeburg.de)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify it under the\n+terms of the GNU General Public License as published by the Free Software\n+Foundation; either version 2, or (at your option) any later version.\n+\n+GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n+details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with files compiled with\n+   GCC to produce an executable, this does not cause the resulting executable\n+   to be covered by the GNU General Public License. This exception does not\n+   however invalidate any other reasons why the executable file might be\n+   covered by the GNU General Public License.  */\n+\n+#include <pthread.h>\n+\n+/********\n+ *  This structure represents a single mutual exclusion lock.  Lock semantics\n+ *  are detailed with the subsequent functions.  We use whatever lock is\n+ *  provided by the system.  We augment it with depth and current owner id\n+ *  fields to implement and re-entrant lock.\n+ */\n+struct _objc_mutex \n+{\n+    volatile _objc_thread_t     owner;          /* Id of thread that owns.  */\n+    volatile int                depth;          /* # of acquires.           */\n+    pthread_mutex_t             lock;           /* pthread mutex.           */\n+};\n+\n+/*****************************************************************************\n+ *  Static variables.\n+ */\n+static pthread_key_t    __objc_thread_data_key; /* Data key for thread data.*/\n+\n+\n+/********\n+ *  Initialize the threads subsystem.  Returns 0 if successful, or -1 if no\n+ *  thread support is available.\n+ */\n+int\n+__objc_init_thread_system(void)\n+{\n+    if (pthread_key_create(&__objc_thread_data_key, NULL) == 0)\n+        return 0;                               /* Yes, return success.     */\n+    \n+    return -1;                                  /* Failed.                  */\n+}\n+\n+int\n+__objc_fini_thread_system(void)\n+{\n+  return 0;\n+}\n+\n+/********\n+ *  Create a new thread of execution and return its id.  Return NULL if fails.\n+ *  The new thread starts in \"func\" with the given argument.\n+ */\n+_objc_thread_t\n+objc_thread_create(void (*func)(void *arg), void *arg)\n+{\n+    _objc_thread_t      thread_id = NULL;       /* Detached thread id.      */\n+    pthread_t           new_thread_handle;      /* DCE thread handle.       */\n+\n+    objc_mutex_lock(__objc_runtime_mutex);\n+\n+    if (pthread_create(&new_thread_handle, NULL,\n+                       (void *)func, arg) == 0) {\n+        thread_id = (_objc_thread_t) new_thread_handle;\n+        pthread_detach(new_thread_handle);     /* Fully detach thread.     */\n+\t__objc_runtime_threads_alive++;\n+    }\n+    \n+    objc_mutex_unlock(__objc_runtime_mutex);\n+    return thread_id;\n+}\n+\n+/********\n+ *  Set the current thread's priority.\n+ */\n+int\n+objc_thread_set_priority(int priority)\n+{\n+#if 0 /* no get/set priority in Linux pthreads */\n+\n+    int         sys_priority = 0;\n+\n+    switch (priority) {\n+    case OBJC_THREAD_INTERACTIVE_PRIORITY:\n+        sys_priority = (PRI_FG_MIN_NP + PRI_FG_MAX_NP) / 2;\n+        break;\n+    default:\n+    case OBJC_THREAD_BACKGROUND_PRIORITY:\n+        sys_priority = (PRI_BG_MIN_NP + PRI_BG_MAX_NP) / 2;\n+        break;\n+    case OBJC_THREAD_LOW_PRIORITY:\n+        sys_priority = (PRI_BG_MIN_NP + PRI_BG_MAX_NP) / 2;\n+        break;\n+    }\n+    \n+    if (pthread_setprio(pthread_self(), sys_priority) >= 0)\n+        return 0;                               /* Changed priority. End.   */\n+    \n+#endif\n+    return -1;                                  /* Failed.                  */\n+}\n+\n+/********\n+ *  Return the current thread's priority.\n+ */\n+int\n+objc_thread_get_priority(void)\n+{\n+#if 0 /* no get/set priority in Linux pthreads */\n+    int         sys_priority;                   /* DCE thread priority.     */\n+    \n+    if ((sys_priority = pthread_getprio(pthread_self())) >= 0) {\n+        if (sys_priority >= PRI_FG_MIN_NP && sys_priority <= PRI_FG_MAX_NP)\n+            return OBJC_THREAD_INTERACTIVE_PRIORITY;\n+        if (sys_priority >= PRI_BG_MIN_NP && sys_priority <= PRI_BG_MAX_NP)\n+            return OBJC_THREAD_BACKGROUND_PRIORITY;\n+        return OBJC_THREAD_LOW_PRIORITY;\n+    }\n+#endif\n+    return -1;                                  /* Couldn't get priority.   */\n+}\n+\n+/********\n+ *  Yield our process time to another thread.  Any BUSY waiting that is done\n+ *  by a thread should use this function to make sure that other threads can\n+ *  make progress even on a lazy uniprocessor system.\n+ */\n+void\n+objc_thread_yield(void)\n+{\n+    pthread_yield();                            /* Yield to equal thread.   */\n+}\n+\n+/********\n+ *  Terminate the current tread.  Doesn't return anything.  Doesn't return.\n+ *  Actually, if it failed returns -1.\n+ */\n+int\n+objc_thread_exit(void)\n+{\n+  objc_mutex_lock(__objc_runtime_mutex);\n+  __objc_runtime_threads_alive--;\n+  objc_mutex_unlock(__objc_runtime_mutex);\n+      \n+  pthread_exit(&__objc_thread_exit_status);     /* Terminate thread.        */\n+  return -1;\n+}\n+\n+/********\n+ *  Returns an integer value which uniquely describes a thread.  Must not be\n+ *  -1 which is reserved as a marker for \"no thread\".\n+ */\n+_objc_thread_t\n+objc_thread_id(void)\n+{\n+  pthread_t self = pthread_self();\n+\n+  return (_objc_thread_t) self;               /* Return thread handle.    */\n+}\n+\n+/********\n+ *  Sets the thread's local storage pointer.  Returns 0 if successful or -1\n+ *  if failed.\n+ */\n+int\n+objc_thread_set_data(void *value)\n+{\n+    if (pthread_setspecific(__objc_thread_data_key, (void *)value) == 0)\n+        return 0;                           \t/* Return thread data.      */\n+    return -1;\n+}\n+\n+/********\n+ *  Returns the thread's local storage pointer.  Returns NULL on failure.\n+ */\n+void *\n+objc_thread_get_data(void)\n+{\n+    return pthread_getspecific(__objc_thread_data_key);\n+}\n+\n+/********\n+ *  Allocate a mutex.  Return the mutex pointer if successful or NULL if\n+ *  the allocation fails for any reason.\n+ */\n+_objc_mutex_t\n+objc_mutex_allocate(void)\n+{\n+    _objc_mutex_t mutex;\n+    int         err = 0;\n+    \n+    if (!(mutex = (_objc_mutex_t)__objc_xmalloc(sizeof(struct _objc_mutex))))\n+        return NULL;                            /* Abort if malloc failed.  */\n+\n+    err = pthread_mutex_init(&mutex->lock, NULL);\n+    \n+    if (err != 0) {                             /* System init failed?      */\n+        free(mutex);                            /* Yes, free local memory.  */\n+        return NULL;                            /* Abort.                   */\n+    }\n+    mutex->owner = NULL;                        /* No owner.                */\n+    mutex->depth = 0;                           /* No locks.                */\n+    return mutex;                               /* Return mutex handle.     */\n+}\n+\n+/********\n+ *  Deallocate a mutex.  Note that this includes an implicit mutex_lock to\n+ *  insure that no one else is using the lock.  It is legal to deallocate\n+ *  a lock if we have a lock on it, but illegal to deallotcate a lock held\n+ *  by anyone else.\n+ *  Returns the number of locks on the thread.  (1 for deallocate).\n+ */\n+int\n+objc_mutex_deallocate(_objc_mutex_t mutex)\n+{\n+    int         depth;                          /* # of locks on mutex.     */\n+\n+    if (!mutex)                                 /* Is argument bad?         */\n+        return -1;                              /* Yes, abort.              */\n+    depth = objc_mutex_lock(mutex);             /* Must have lock.          */\n+    \n+    pthread_mutex_unlock(&mutex->lock);         /* Must unlock system mutex.*/\n+    pthread_mutex_destroy(&mutex->lock);        /* Free system mutex.       */\n+    \n+    free(mutex);                                /* Free memory.             */\n+    return depth;                               /* Return last depth.       */\n+}\n+\n+/********\n+ *  Grab a lock on a mutex.  If this thread already has a lock on this mutex\n+ *  then we increment the lock count.  If another thread has a lock on the \n+ *  mutex we block and wait for the thread to release the lock.\n+ *  Returns the lock count on the mutex held by this thread.\n+ */\n+int\n+objc_mutex_lock(_objc_mutex_t mutex)\n+{\n+    _objc_thread_t     thread_id;                /* Cache our thread id. */\n+\n+    if (!mutex)                                 /* Is argument bad?         */\n+        return -1;                              /* Yes, abort.              */\n+    thread_id = objc_thread_id();               /* Get this thread's id.    */\n+    if (mutex->owner == thread_id)              /* Already own lock?        */\n+        return ++mutex->depth;                  /* Yes, increment depth.    */\n+\n+    if (pthread_mutex_lock(&mutex->lock) != 0)  /* Lock DCE system mutex.   */\n+        return -1;                              /* Failed, abort.           */\n+    \n+    mutex->owner = thread_id;                   /* Mark thread as owner.    */\n+    return mutex->depth = 1;                    /* Increment depth to end.  */\n+}\n+\n+/********\n+ *  Try to grab a lock on a mutex.  If this thread already has a lock on\n+ *  this mutex then we increment the lock count and return it.  If another\n+ *  thread has a lock on the mutex returns -1.\n+ */\n+int\n+objc_mutex_trylock(_objc_mutex_t mutex)\n+{\n+    _objc_thread_t    thread_id;                 /* Cache our thread id. */\n+\n+    if (!mutex)                                 /* Is argument bad?         */\n+        return -1;                              /* Yes, abort.              */\n+    thread_id = objc_thread_id();               /* Get this thread's id.    */\n+    if (mutex->owner == thread_id)              /* Already own lock?        */\n+        return ++mutex->depth;                  /* Yes, increment depth.    */\n+    \n+    if (pthread_mutex_trylock(&mutex->lock) != 1) /* Lock DCE system mutex. */\n+        return -1;                              /* Failed, abort.           */\n+    \n+    mutex->owner = thread_id;                   /* Mark thread as owner.    */\n+    return mutex->depth = 1;                    /* Increment depth to end.  */\n+}\n+\n+/********\n+ *  Decrements the lock count on this mutex by one.  If the lock count reaches\n+ *  zero, release the lock on the mutex.  Returns the lock count on the mutex.\n+ *  It is an error to attempt to unlock a mutex which this thread doesn't hold\n+ *  in which case return -1 and the mutex is unaffected.\n+ *  Will also return -1 if the mutex free fails.\n+ */\n+int\n+objc_mutex_unlock(_objc_mutex_t mutex)\n+{\n+    _objc_thread_t   thread_id;                 /* Cache our thread id.     */\n+    \n+    if (!mutex)                                 /* Is argument bad?         */\n+        return -1;                              /* Yes, abort.              */\n+    thread_id = objc_thread_id();               /* Get this thread's id.    */\n+    if (mutex->owner != thread_id)              /* Does some else own lock? */\n+        return -1;                              /* Yes, abort.              */\n+    if (mutex->depth > 1)                       /* Released last lock?      */\n+        return --mutex->depth;                  /* No, Decrement depth, end.*/\n+    mutex->depth = 0;                           /* Yes, reset depth to 0.   */\n+    mutex->owner = NULL;                        /* Set owner to \"no thread\".*/\n+    \n+    if (pthread_mutex_unlock(&mutex->lock) != 0)  /* Unlock system mutex.   */\n+        return -1;                              /* Failed, abort.           */\n+    \n+    return 0;                                   /* No, return success.      */\n+}"}]}