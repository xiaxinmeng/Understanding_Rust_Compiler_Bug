{"sha": "84b6a4d217b2762af5b223afc35c56d4c91e9d00", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODRiNmE0ZDIxN2IyNzYyYWY1YjIyM2FmYzM1YzU2ZDRjOTFlOWQwMA==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2005-02-22T18:14:37Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2005-02-22T18:14:37Z"}, "message": "re PR java/20056 ('verification failed: incompatible type on stack' with --indirect-dispatch)\n\n\tPR java/20056:\n\t* verify-impl.c (EITHER): New define.\n\t(types_compatible): Handle it.\n\t(check_field_constant): Use it.\n\nFrom-SVN: r95404", "tree": {"sha": "50a948b2042b828a734df573abcc30e89cb95cfc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/50a948b2042b828a734df573abcc30e89cb95cfc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/84b6a4d217b2762af5b223afc35c56d4c91e9d00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84b6a4d217b2762af5b223afc35c56d4c91e9d00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84b6a4d217b2762af5b223afc35c56d4c91e9d00", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84b6a4d217b2762af5b223afc35c56d4c91e9d00/comments", "author": null, "committer": null, "parents": [{"sha": "de646917966153fb997aff63928c9f3bfcb613f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de646917966153fb997aff63928c9f3bfcb613f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de646917966153fb997aff63928c9f3bfcb613f3"}], "stats": {"total": 62, "additions": 45, "deletions": 17}, "files": [{"sha": "54dc009a4b7626297a435c57afc6732173a2c8ea", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b6a4d217b2762af5b223afc35c56d4c91e9d00/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b6a4d217b2762af5b223afc35c56d4c91e9d00/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=84b6a4d217b2762af5b223afc35c56d4c91e9d00", "patch": "@@ -1,3 +1,10 @@\n+2005-02-22  Tom Tromey  <tromey@redhat.com>\n+\n+\tPR java/20056:\n+\t* verify-impl.c (EITHER): New define.\n+\t(types_compatible): Handle it.\n+\t(check_field_constant): Use it.\n+\n 2005-02-18  Tom Tromey  <tromey@redhat.com>\n \n \tPR java/20056:"}, {"sha": "ae585c8d7dbc4382a8c7a7c705f71927839eb657", "filename": "gcc/java/verify-impl.c", "status": "modified", "additions": 38, "deletions": 17, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b6a4d217b2762af5b223afc35c56d4c91e9d00/gcc%2Fjava%2Fverify-impl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b6a4d217b2762af5b223afc35c56d4c91e9d00/gcc%2Fjava%2Fverify-impl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fverify-impl.c?ref=84b6a4d217b2762af5b223afc35c56d4c91e9d00", "patch": "@@ -539,16 +539,19 @@ struct type\n   \n      First, when constructing a new object, it is the PC of the\n      `new' instruction which created the object.  We use the special\n-     value UNINIT to mean that this is uninitialized, and the\n-     special value SELF for the case where the current method is\n-     itself the <init> method.\n-\n+     value UNINIT to mean that this is uninitialized.  The special\n+     value SELF is used for the case where the current method is\n+     itself the <init> method.  the special value EITHER is used\n+     when we may optionally allow either an uninitialized or\n+     initialized reference to match.\n+  \n      Second, when the key is return_address_type, this holds the PC\n      of the instruction following the `jsr'.  */\n   int pc;\n \n-  #define UNINIT -2\n-  #define SELF -1\n+#define UNINIT -2\n+#define SELF -1\n+#define EITHER -3\n };\n \n #if 0\n@@ -721,19 +724,33 @@ types_compatible (type *t, type *k)\n   if (k->klass == NULL)\n     verify_fail (\"programmer error in type::compatible\");\n \n-  /* An initialized type and an uninitialized type are not\n-     compatible.  */\n-  if (type_initialized (t) != type_initialized (k))\n-    return false;\n-\n-  /* Two uninitialized objects are compatible if either:\n-     * The PCs are identical, or\n-     * One PC is UNINIT.  */\n-  if (type_initialized (t))\n+  /* Handle the special 'EITHER' case, which is only used in a\n+     special case of 'putfield'.  Note that we only need to handle\n+     this on the LHS of a check.  */\n+  if (! type_initialized (t) && t->pc == EITHER)\n     {\n-      if (t->pc != k->pc && t->pc != UNINIT && k->pc != UNINIT)\n+      /* If the RHS is uninitialized, it must be an uninitialized\n+\t 'this'.  */\n+      if (! type_initialized (k) && k->pc != SELF)\n \treturn false;\n     }\n+  else if (type_initialized (t) != type_initialized (k))\n+    {\n+      /* An initialized type and an uninitialized type are not\n+\t otherwise compatible.  */\n+      return false;\n+    }\n+  else\n+    {\n+      /* Two uninitialized objects are compatible if either:\n+       * The PCs are identical, or\n+       * One PC is UNINIT.  */\n+      if (type_initialized (t))\n+\t{\n+\t  if (t->pc != k->pc && t->pc != UNINIT && k->pc != UNINIT)\n+\t    return false;\n+\t}\n+    }\n \n   return ref_compatible (t->klass, k->klass);\n }\n@@ -2162,7 +2179,11 @@ check_field_constant (int index, type *class_type, bool putfield)\n       && vfr->current_state->this_type.pc == SELF\n       && types_equal (&vfr->current_state->this_type, &ct)\n       && vfy_class_has_field (vfr->current_class, name, field_type))\n-    type_set_uninitialized (class_type, SELF);\n+    /* Note that we don't actually know whether we're going to match\n+       against 'this' or some other object of the same type.  So,\n+       here we set things up so that it doesn't matter.  This relies\n+       on knowing what our caller is up to.  */\n+    type_set_uninitialized (class_type, EITHER);\n \n   return t;\n }"}]}