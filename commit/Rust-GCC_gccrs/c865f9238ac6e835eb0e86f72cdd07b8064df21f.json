{"sha": "c865f9238ac6e835eb0e86f72cdd07b8064df21f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzg2NWY5MjM4YWM2ZTgzNWViMGU4NmY3MmNkZDA3YjgwNjRkZjIxZg==", "commit": {"author": {"name": "Ed Smith-Rowland", "email": "3dw4rd@verizon.net", "date": "2013-06-29T03:41:58Z"}, "committer": {"name": "Edward Smith-Rowland", "email": "emsr@gcc.gnu.org", "date": "2013-06-29T03:41:58Z"}, "message": "lex.c (lex_raw_string(), [...]): Constrain suffixes treated as concatenated literal and macro to just the...\n\nlibcpp:\n\n2013-06-28  Ed Smith-Rowland  <3dw4rd@verizon.net>\n\n\t* lex.c (lex_raw_string(), lex_string()): Constrain suffixes treated\n\tas concatenated literal and macro to just the patterns found in\n\tinttypes.h; (is_macro()): New.\n\n\ngcc/cp:\n\n2013-06-28  Ed Smith-Rowland  <3dw4rd@verizon.net>\n\n\t* cp-tree.h (UDLIT_OP_ANSI_PREFIX): Remove space.\n\t* parser.c (cp_parser_operator()): Parse user-defined string\n\tliteral as literal operator.\n\n\ngcc/testsuite:\n\n2013-06-28  Ed Smith-Rowland  <3dw4rd@verizon.net>\n\n\t* g++.dg/cpp0x/udlit-nospace-neg.C: Adjust.\n\t* g++.dg/cpp1y/udlit-enc-prefix-neg.C: New.\n\t* g++.dg/cpp1y/udlit-userdef-string.C: New.\n\t* g++.dg/cpp1y/complex_literals.h: New.\n\nFrom-SVN: r200563", "tree": {"sha": "30b4ba2a69beb74bae477e5c0f92613b0eee4ae5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/30b4ba2a69beb74bae477e5c0f92613b0eee4ae5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c865f9238ac6e835eb0e86f72cdd07b8064df21f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c865f9238ac6e835eb0e86f72cdd07b8064df21f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c865f9238ac6e835eb0e86f72cdd07b8064df21f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c865f9238ac6e835eb0e86f72cdd07b8064df21f/comments", "author": {"login": "emsr", "id": 1936479, "node_id": "MDQ6VXNlcjE5MzY0Nzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1936479?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emsr", "html_url": "https://github.com/emsr", "followers_url": "https://api.github.com/users/emsr/followers", "following_url": "https://api.github.com/users/emsr/following{/other_user}", "gists_url": "https://api.github.com/users/emsr/gists{/gist_id}", "starred_url": "https://api.github.com/users/emsr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emsr/subscriptions", "organizations_url": "https://api.github.com/users/emsr/orgs", "repos_url": "https://api.github.com/users/emsr/repos", "events_url": "https://api.github.com/users/emsr/events{/privacy}", "received_events_url": "https://api.github.com/users/emsr/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "efc58ac54877a0d0fcc82a269e8791343465a6dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efc58ac54877a0d0fcc82a269e8791343465a6dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/efc58ac54877a0d0fcc82a269e8791343465a6dc"}], "stats": {"total": 172, "additions": 147, "deletions": 25}, "files": [{"sha": "2de63c0b8d87ef8cd9dbf0774541d33f3b5969a5", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c865f9238ac6e835eb0e86f72cdd07b8064df21f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c865f9238ac6e835eb0e86f72cdd07b8064df21f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=c865f9238ac6e835eb0e86f72cdd07b8064df21f", "patch": "@@ -1,3 +1,9 @@\n+2013-06-28  Ed Smith-Rowland  <3dw4rd@verizon.net>\n+\n+\t* cp-tree.h (UDLIT_OP_ANSI_PREFIX): Remove space.\n+\t* parser.c (cp_parser_operator()): Parse user-defined string\n+\tliteral as literal operator.\n+\n 2013-06-28  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/57645"}, {"sha": "3e8043a4162692600d4a3a0375232321859c897c", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c865f9238ac6e835eb0e86f72cdd07b8064df21f/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c865f9238ac6e835eb0e86f72cdd07b8064df21f/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=c865f9238ac6e835eb0e86f72cdd07b8064df21f", "patch": "@@ -4404,7 +4404,7 @@ extern GTY(()) vec<tree, va_gc> *local_classes;\n #define LAMBDANAME_PREFIX \"__lambda\"\n #define LAMBDANAME_FORMAT LAMBDANAME_PREFIX \"%d\"\n \n-#define UDLIT_OP_ANSI_PREFIX \"operator\\\"\\\" \"\n+#define UDLIT_OP_ANSI_PREFIX \"operator\\\"\\\"\"\n #define UDLIT_OP_ANSI_FORMAT UDLIT_OP_ANSI_PREFIX \"%s\"\n #define UDLIT_OP_MANGLED_PREFIX \"li\"\n #define UDLIT_OP_MANGLED_FORMAT UDLIT_OP_MANGLED_PREFIX \"%s\""}, {"sha": "6e8293b024e108a64d34b23d9894e92e0efcd79b", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 49, "deletions": 3, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c865f9238ac6e835eb0e86f72cdd07b8064df21f/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c865f9238ac6e835eb0e86f72cdd07b8064df21f/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=c865f9238ac6e835eb0e86f72cdd07b8064df21f", "patch": "@@ -12244,6 +12244,8 @@ cp_parser_operator (cp_parser* parser)\n {\n   tree id = NULL_TREE;\n   cp_token *token;\n+  bool bad_encoding_prefix = false;\n+  int string_len = 2;\n \n   /* Peek at the next token.  */\n   token = cp_lexer_peek_token (parser->lexer);\n@@ -12443,10 +12445,20 @@ cp_parser_operator (cp_parser* parser)\n       cp_parser_require (parser, CPP_CLOSE_SQUARE, RT_CLOSE_SQUARE);\n       return ansi_opname (ARRAY_REF);\n \n+    case CPP_WSTRING:\n+      string_len = 3;\n+    case CPP_STRING16:\n+    case CPP_STRING32:\n+      string_len = 5;\n+    case CPP_UTF8STRING:\n+      string_len = 4;\n+      bad_encoding_prefix = true;\n     case CPP_STRING:\n       if (cxx_dialect == cxx98)\n \tmaybe_warn_cpp0x (CPP0X_USER_DEFINED_LITERALS);\n-      if (TREE_STRING_LENGTH (token->u.value) > 2)\n+      if (bad_encoding_prefix)\n+\terror (\"invalid encoding prefix in literal operator\");\n+      if (TREE_STRING_LENGTH (token->u.value) > string_len)\n \t{\n \t  error (\"expected empty string after %<operator%> keyword\");\n \t  return error_mark_node;\n@@ -12464,15 +12476,49 @@ cp_parser_operator (cp_parser* parser)\n \t      return cp_literal_operator_id (name);\n \t    }\n \t}\n+      else if (token->type == CPP_KEYWORD)\n+\t{\n+\t  error (\"unexpected keyword;\"\n+\t\t \" remove space between quotes and suffix identifier\");\n+\t  return error_mark_node;\n+\t}\n       else\n \t{\n \t  error (\"expected suffix identifier\");\n \t  return error_mark_node;\n \t}\n \n+    case CPP_WSTRING_USERDEF:\n+      string_len = 3;\n+    case CPP_STRING16_USERDEF:\n+    case CPP_STRING32_USERDEF:\n+      string_len = 5;\n+    case CPP_UTF8STRING_USERDEF:\n+      string_len = 4;\n+      bad_encoding_prefix = true;\n     case CPP_STRING_USERDEF:\n-      error (\"missing space between %<\\\"\\\"%> and suffix identifier\");\n-      return error_mark_node;\n+      if (cxx_dialect == cxx98)\n+\tmaybe_warn_cpp0x (CPP0X_USER_DEFINED_LITERALS);\n+      if (bad_encoding_prefix)\n+\terror (\"invalid encoding prefix in literal operator\");\n+      {\n+\ttree string_tree = USERDEF_LITERAL_VALUE (token->u.value);\n+\tif (TREE_STRING_LENGTH (string_tree) > string_len)\n+\t  {\n+\t    error (\"expected empty string after %<operator%> keyword\");\n+\t    return error_mark_node;\n+\t  }\n+\tid = USERDEF_LITERAL_SUFFIX_ID (token->u.value);\n+\t/* Consume the user-defined string literal.  */\n+\tcp_lexer_consume_token (parser->lexer);\n+\tif (id != error_mark_node)\n+\t  {\n+\t    const char *name = IDENTIFIER_POINTER (id);\n+\t    return cp_literal_operator_id (name);\n+\t  }\n+\telse\n+\t  return error_mark_node;\n+      }\n \n     default:\n       /* Anything else is an error.  */"}, {"sha": "5c09364a80a38b912746bee377b45697ad4d48c5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c865f9238ac6e835eb0e86f72cdd07b8064df21f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c865f9238ac6e835eb0e86f72cdd07b8064df21f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c865f9238ac6e835eb0e86f72cdd07b8064df21f", "patch": "@@ -1,3 +1,10 @@\n+2013-06-28  Ed Smith-Rowland  <3dw4rd@verizon.net>\n+\n+\t* g++.dg/cpp0x/udlit-nospace-neg.C: Adjust.\n+\t* g++.dg/cpp1y/udlit-enc-prefix-neg.C: New.\n+\t* g++.dg/cpp1y/udlit-userdef-string.C: New.\n+\t* g++.dg/cpp1y/complex_literals.h: New.\n+\n 2013-06-28  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/57645"}, {"sha": "f06bd8bdf02b5d045cf89ec721da9a0cb1f39fcf", "filename": "gcc/testsuite/g++.dg/cpp0x/udlit-nospace-neg.C", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c865f9238ac6e835eb0e86f72cdd07b8064df21f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-nospace-neg.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c865f9238ac6e835eb0e86f72cdd07b8064df21f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-nospace-neg.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-nospace-neg.C?ref=c865f9238ac6e835eb0e86f72cdd07b8064df21f", "patch": "@@ -1,3 +1,5 @@\n // { dg-options \"-std=c++0x\" }\n \n-float operator \"\"_abc(const char*); // { dg-error \"missing space between|and suffix identifier\" }\n+float operator \"\"_abc(const char*);\n+\n+int operator\"\"_def(long double);"}, {"sha": "ea328e39ecf459a9ce83ee365a5b1f6cc650e645", "filename": "gcc/testsuite/g++.dg/cpp1y/complex_literals.h", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c865f9238ac6e835eb0e86f72cdd07b8064df21f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fcomplex_literals.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c865f9238ac6e835eb0e86f72cdd07b8064df21f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fcomplex_literals.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fcomplex_literals.h?ref=c865f9238ac6e835eb0e86f72cdd07b8064df21f", "patch": "@@ -0,0 +1,12 @@\n+\n+#include <complex>\n+\n+#pragma GCC system_header\n+\n+std::complex<float>\n+operator\"\"if(long double ximag)\n+{ return std::complex<float>(0.0F, static_cast<float>(ximag)); }\n+\n+std::complex<float>\n+operator\"\"if(unsigned long long nimag)\n+{ return std::complex<float>(0.0F, static_cast<float>(nimag)); }"}, {"sha": "149fd0d162aef5b9a53cbf720b4197a6f966a690", "filename": "gcc/testsuite/g++.dg/cpp1y/udlit-enc-prefix-neg.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c865f9238ac6e835eb0e86f72cdd07b8064df21f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fudlit-enc-prefix-neg.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c865f9238ac6e835eb0e86f72cdd07b8064df21f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fudlit-enc-prefix-neg.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fudlit-enc-prefix-neg.C?ref=c865f9238ac6e835eb0e86f72cdd07b8064df21f", "patch": "@@ -0,0 +1,17 @@\n+// { dg-options -std=c++1y }\n+\n+int\n+operator L\"\"_Ls(unsigned long long) // { dg-error \"invalid encoding prefix in literal operator\" }\n+{ return 0; }\n+\n+int\n+operator u\"\"_s16(unsigned long long) // { dg-error \"invalid encoding prefix in literal operator\" }\n+{ return 0; }\n+\n+int\n+operator U\"\"_s32(unsigned long long) // { dg-error \"invalid encoding prefix in literal operator\" }\n+{ return 0; }\n+\n+int\n+operator u8\"\"_u8s(unsigned long long) // { dg-error \"invalid encoding prefix in literal operator\" }\n+{ return 0; }"}, {"sha": "e58a66bb63f2f0e1cffcd9efebb2f6162cebbacb", "filename": "gcc/testsuite/g++.dg/cpp1y/udlit-userdef-string.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c865f9238ac6e835eb0e86f72cdd07b8064df21f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fudlit-userdef-string.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c865f9238ac6e835eb0e86f72cdd07b8064df21f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fudlit-userdef-string.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fudlit-userdef-string.C?ref=c865f9238ac6e835eb0e86f72cdd07b8064df21f", "patch": "@@ -0,0 +1,7 @@\n+// { dg-options -std=c++1y }\n+\n+#include \"complex_literals.h\"\n+\n+auto cx = 1.1if;\n+\n+auto cn = 123if;"}, {"sha": "0cf9100cf62f5f6a0f282bdae2b660a45d1c1e41", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c865f9238ac6e835eb0e86f72cdd07b8064df21f/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c865f9238ac6e835eb0e86f72cdd07b8064df21f/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=c865f9238ac6e835eb0e86f72cdd07b8064df21f", "patch": "@@ -1,3 +1,9 @@\n+2013-06-28  Ed Smith-Rowland  <3dw4rd@verizon.net>\n+\n+\t* lex.c (lex_raw_string(), lex_string()): Constrain suffixes treated\n+\tas concatenated literal and macro to just the patterns found in\n+\tinttypes.h; (is_macro()): New.\n+\n 2013-06-24  Dehao Chen  <dehao@google.com>\n \n \t* files.c (_cpp_stack_include): Fix the highest_location when header"}, {"sha": "022d31016e221ed3114b711d8a0edff77bbdb49c", "filename": "libcpp/lex.c", "status": "modified", "additions": 39, "deletions": 20, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c865f9238ac6e835eb0e86f72cdd07b8064df21f/libcpp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c865f9238ac6e835eb0e86f72cdd07b8064df21f/libcpp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Flex.c?ref=c865f9238ac6e835eb0e86f72cdd07b8064df21f", "patch": "@@ -1334,6 +1334,33 @@ bufring_append (cpp_reader *pfile, const uchar *base, size_t len,\n   *last_buff_p = last_buff;\n }\n \n+\n+/* Returns true if a macro has been defined.\n+   This might not work if compile with -save-temps,\n+   or preprocess separately from compilation.  */\n+\n+static bool\n+is_macro(cpp_reader *pfile, const uchar *base)\n+{\n+  const uchar *cur = base;\n+  if (! ISIDST (*cur))\n+    return false;\n+  unsigned int hash = HT_HASHSTEP (0, *cur);\n+  ++cur;\n+  while (ISIDNUM (*cur))\n+    {\n+      hash = HT_HASHSTEP (hash, *cur);\n+      ++cur;\n+    }\n+  hash = HT_HASHFINISH (hash, cur - base);\n+\n+  cpp_hashnode *result = CPP_HASHNODE (ht_lookup_with_hash (pfile->hash_table,\n+\t\t\t\t\tbase, cur - base, hash, HT_NO_INSERT));\n+\n+  return !result ? false : (result->type == NT_MACRO);\n+}\n+\n+\n /* Lexes a raw string.  The stored string contains the spelling, including\n    double quotes, delimiter string, '(' and ')', any leading\n    'L', 'u', 'U' or 'u8' and 'R' modifier.  It returns the type of the\n@@ -1556,22 +1583,18 @@ lex_raw_string (cpp_reader *pfile, cpp_token *token, const uchar *base,\n \n   if (CPP_OPTION (pfile, user_literals))\n     {\n-      /* According to C++11 [lex.ext]p10, a ud-suffix not starting with an\n-\t underscore is ill-formed.  Since this breaks programs using macros\n-\t from inttypes.h, we generate a warning and treat the ud-suffix as a\n-\t separate preprocessing token.  This approach is under discussion by\n-\t the standards committee, and has been adopted as a conforming\n-\t extension by other front ends such as clang.\n-         A special exception is made for the suffix 's' which will be\n-\t standardized as a user-defined literal suffix for strings.  */\n-      if (ISALPHA (*cur) && *cur != 's')\n+      /* If a string format macro, say from inttypes.h, is placed touching\n+\t a string literal it could be parsed as a C++11 user-defined string\n+\t literal thus breaking the program.\n+\t Try to identify macros with is_macro. A warning is issued. */\n+      if (is_macro (pfile, cur))\n \t{\n \t  /* Raise a warning, but do not consume subsequent tokens.  */\n \t  if (CPP_OPTION (pfile, warn_literal_suffix))\n \t    cpp_warning_with_line (pfile, CPP_W_LITERAL_SUFFIX,\n \t\t\t\t   token->src_loc, 0,\n \t\t\t\t   \"invalid suffix on literal; C++11 requires \"\n-\t\t\t\t   \"a space between literal and identifier\");\n+\t\t\t\t   \"a space between literal and string macro\");\n \t}\n       /* Grab user defined literal suffix.  */\n       else if (ISIDST (*cur))\n@@ -1689,22 +1712,18 @@ lex_string (cpp_reader *pfile, cpp_token *token, const uchar *base)\n \n   if (CPP_OPTION (pfile, user_literals))\n     {\n-      /* According to C++11 [lex.ext]p10, a ud-suffix not starting with an\n-\t underscore is ill-formed.  Since this breaks programs using macros\n-\t from inttypes.h, we generate a warning and treat the ud-suffix as a\n-\t separate preprocessing token.  This approach is under discussion by\n-\t the standards committee, and has been adopted as a conforming\n-\t extension by other front ends such as clang.\n-         A special exception is made for the suffix 's' which will be\n-\t standardized as a user-defined literal suffix for strings.  */\n-      if (ISALPHA (*cur) && *cur != 's')\n+      /* If a string format macro, say from inttypes.h, is placed touching\n+\t a string literal it could be parsed as a C++11 user-defined string\n+\t literal thus breaking the program.\n+\t Try to identify macros with is_macro. A warning is issued. */\n+      if (is_macro (pfile, cur))\n \t{\n \t  /* Raise a warning, but do not consume subsequent tokens.  */\n \t  if (CPP_OPTION (pfile, warn_literal_suffix))\n \t    cpp_warning_with_line (pfile, CPP_W_LITERAL_SUFFIX,\n \t\t\t\t   token->src_loc, 0,\n \t\t\t\t   \"invalid suffix on literal; C++11 requires \"\n-\t\t\t\t   \"a space between literal and identifier\");\n+\t\t\t\t   \"a space between literal and string macro\");\n \t}\n       /* Grab user defined literal suffix.  */\n       else if (ISIDST (*cur))"}]}