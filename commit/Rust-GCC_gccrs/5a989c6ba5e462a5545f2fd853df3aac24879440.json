{"sha": "5a989c6ba5e462a5545f2fd853df3aac24879440", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWE5ODljNmJhNWU0NjJhNTU0NWYyZmQ4NTNkZjNhYWMyNDg3OTQ0MA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-07-22T13:09:40Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-07-22T13:09:40Z"}, "message": "[multiple changes]\n\n2009-07-22  Ed Schonberg  <schonberg@adacore.com>\n\n\t* freeze.adb (Freeze_Entity): If Implicit_Packing is enabled, and the\n\tcomponent size is an exact number of bytes, an array type can have a\n\tsize clause that forces packing even though the array type itself is\n\tnot bit-packed.\n\n2009-07-22  Thomas Quinot  <quinot@adacore.com>\n\n\t* sem_ch3.adb (Analyze_Object_Declaration): For a constant declaration,\n\tif there is a previous entity with the same name in the scope, ignore\n\tit if it is the renaming declaration for a generic package introduced\n\tin instances.\n\n2009-07-22  Nicolas Roche  <roche@adacore.com>\n\n\t* seh_init.c: use RtlAddFunctionTable to register our SEH exception\n\thandler on x86_64 windows.\n\n2009-07-22  Arnaud Charlet  <charlet@adacore.com>\n\n\t* sem_prag.adb (Analyze_Pragma): Initialize/Normalize_Scalars create\n\tfalse positives in CodePeer, so ignore this pragma in this mode.\n\nFrom-SVN: r149931", "tree": {"sha": "5e9ab029114cde8cbdc8632002f642d414b88336", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5e9ab029114cde8cbdc8632002f642d414b88336"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5a989c6ba5e462a5545f2fd853df3aac24879440", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a989c6ba5e462a5545f2fd853df3aac24879440", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a989c6ba5e462a5545f2fd853df3aac24879440", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a989c6ba5e462a5545f2fd853df3aac24879440/comments", "author": null, "committer": null, "parents": [{"sha": "1a66936f87bd6fce4765c9cb157734d2f1850282", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a66936f87bd6fce4765c9cb157734d2f1850282", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a66936f87bd6fce4765c9cb157734d2f1850282"}], "stats": {"total": 167, "additions": 157, "deletions": 10}, "files": [{"sha": "5bce84d5eac9fbe2333410070a02d81d4f8c31a3", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a989c6ba5e462a5545f2fd853df3aac24879440/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a989c6ba5e462a5545f2fd853df3aac24879440/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=5a989c6ba5e462a5545f2fd853df3aac24879440", "patch": "@@ -1,3 +1,27 @@\n+2009-07-22  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* freeze.adb (Freeze_Entity): If Implicit_Packing is enabled, and the\n+\tcomponent size is an exact number of bytes, an array type can have a\n+\tsize clause that forces packing even though the array type itself is\n+\tnot bit-packed.\n+\n+2009-07-22  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* sem_ch3.adb (Analyze_Object_Declaration): For a constant declaration,\n+\tif there is a previous entity with the same name in the scope, ignore\n+\tit if it is the renaming declaration for a generic package introduced\n+\tin instances.\n+\n+2009-07-22  Nicolas Roche  <roche@adacore.com>\n+\n+\t* seh_init.c: use RtlAddFunctionTable to register our SEH exception\n+\thandler on x86_64 windows.\n+\n+2009-07-22  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* sem_prag.adb (Analyze_Pragma): Initialize/Normalize_Scalars create\n+\tfalse positives in CodePeer, so ignore this pragma in this mode.\n+\n 2009-07-22  Thomas Quinot  <quinot@adacore.com>\n \n \t* sem_util.adb, sem_ch10.adb: Minor reformatting"}, {"sha": "036e92752b74fd414ed9b27c534039603974f486", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a989c6ba5e462a5545f2fd853df3aac24879440/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a989c6ba5e462a5545f2fd853df3aac24879440/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=5a989c6ba5e462a5545f2fd853df3aac24879440", "patch": "@@ -3030,7 +3030,10 @@ package body Freeze is\n                         --  was a pragma Pack (resulting in the component size\n                         --  being the same as the RM_Size). Furthermore, the\n                         --  component type size must be an odd size (not a\n-                        --  multiple of storage unit)\n+                        --  multiple of storage unit). If the component RM size\n+                        --  is an exact number of storage units that is a power\n+                        --  of two, the array is not packed and has a standard\n+                        --  representation.\n \n                         begin\n                            if RM_Size (E) = Len * Rsiz\n@@ -3054,6 +3057,19 @@ package body Freeze is\n                                    (\"\\use explicit pragma Pack \"\n                                     & \"or use pragma Implicit_Packing\", SZ);\n                               end if;\n+\n+                           elsif RM_Size (E) = Len * Rsiz\n+                             and then Implicit_Packing\n+                             and then\n+                               (Rsiz / System_Storage_Unit = 1\n+                                 or else Rsiz / System_Storage_Unit = 2\n+                                 or else Rsiz / System_Storage_Unit = 4)\n+                           then\n+\n+                              --  Not a packed array, but indicate the desired\n+                              --  component size, for the back-end.\n+\n+                              Set_Component_Size (Btyp, Rsiz);\n                            end if;\n                         end;\n                      end if;"}, {"sha": "9edd88265aae75c4ee348e8518430f21aa7d9904", "filename": "gcc/ada/seh_init.c", "status": "modified", "additions": 86, "deletions": 2, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a989c6ba5e462a5545f2fd853df3aac24879440/gcc%2Fada%2Fseh_init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a989c6ba5e462a5545f2fd853df3aac24879440/gcc%2Fada%2Fseh_init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fseh_init.c?ref=5a989c6ba5e462a5545f2fd853df3aac24879440", "patch": "@@ -59,7 +59,7 @@ extern struct Exception_Data _abort_signal;\n extern void Raise_From_Signal_Handler (struct Exception_Data *, const char *);\n \n \n-#if defined (_WIN32) && !defined (_WIN64)\n+#if defined (_WIN32)\n \n #include <windows.h>\n #include <excpt.h>\n@@ -179,17 +179,100 @@ __gnat_SEH_error_handler (struct _EXCEPTION_RECORD* ExceptionRecord,\n       msg = \"unhandled signal\";\n     }\n \n+#if ! defined (_WIN64)\n   /* This call is important as it avoids locking the second time we catch a\n      signal. Note that this routine is documented as internal to Windows and\n      should not be used.  */\n \n   _global_unwind2 (EstablisherFrame);\n   /* Call equivalent to RtlUnwind (EstablisherFrame, NULL, NULL, 0); */\n+#endif\n \n   Raise_From_Signal_Handler (exception, msg);\n   return 0; /* This is never reached, avoid compiler warning  */\n }\n \n+#if defined (_WIN64)\n+/*  On x86_64 windows exception mechanism is no more based on a chained list\n+    of handlers addresses on the stack. Instead unwinding information is used\n+    to retrieve the exception handler (similar to ZCX GCC mechanism). So in\n+    order to register an exception handler we need to put in the final\n+    executable some unwinding information. This information might be present\n+    statically in the image file inside the .pdata section or registered\n+    through RtlAddFunctionTable API. Currently the GCC toolchain does not\n+    generate the .pdata information for each function. As we don't need to\n+    handle SEH exceptions except for signal handling we are registering a\n+    \"fake\" unwinding data that associate a SEH exception handler to the\n+    complete .text section. As we never return from the handler, the system\n+    does not try to do the final unwinding using the pdata information. The\n+    unwinding is handled by the runtime using either the GNAT SJLJ mechanism\n+    or the ZCX GCC mechanism.\n+\n+    The current implementation is using the RtlAddFunctionTable. Here is for\n+    information purposes the equivalent using a static .pdata section:\n+\n+         .section .rdata,\"dr\"\n+         .align 4\n+      Lunwind_info:\n+         .byte 9,0,0,0\n+         .rva ___gnat_SEH_error_handler\n+         .section .pdata,\"dr\"\n+         .align 4\n+         .long 0\n+         .rva etext\n+         .rva Lunwind_info\n+\n+    Solutions based on SetUnhandledExceptionFilter have been discarded as this\n+    function is mostly disabled on last Windows versions.\n+    Using AddVectoredExceptionHandler should also be discarded as it overrides\n+    all SEH exception handlers that might be present in the program itself and\n+    the loaded DLL (for example it results in unexpected behaviors in the\n+    Win32 subsystem.  */\n+\n+typedef struct _UNWIND_INFO {\n+  BYTE VersionAndFlags;\n+  BYTE PrologSize;\n+  BYTE CountOfUnwindCodes;\n+  BYTE FrameRegisterAndOffset;\n+  ULONG AddressOfExceptionHandler;\n+} UNWIND_INFO,*PUNWIND_INFO;\n+\n+static RUNTIME_FUNCTION Table[1];\n+static UNWIND_INFO unwind_info[1];\n+\n+#define UNW_VERSION 0x01\n+#define UNW_FLAG_EHANDLER 0x08\n+\n+void __gnat_install_SEH_handler (void *eh ATTRIBUTE_UNUSED)\n+{\n+  /* Get the end of the text section.  */\n+  extern char etext[] asm(\"etext\");\n+  /* Get the base of the module.  */\n+  extern char _ImageBase[];\n+\n+  /* Current version is always 1 and we are registering an\n+     exception handler.  */\n+  unwind_info[0].VersionAndFlags = UNW_FLAG_EHANDLER | UNW_VERSION;\n+\n+  /* We don't use the unwinding info so fill the structure with 0 values.  */\n+  unwind_info[0].PrologSize = 0;\n+  unwind_info[0].CountOfUnwindCodes = 0;\n+  unwind_info[0].FrameRegisterAndOffset = 0;\n+\n+  /* Add the exception handler.  */\n+  unwind_info[0].AddressOfExceptionHandler =\n+    (DWORD)((char *)__gnat_SEH_error_handler - _ImageBase);\n+\n+  /* Set its scope to the entire program.  */\n+  Table[0].BeginAddress = 0;\n+  Table[0].EndAddress = (DWORD)(etext - _ImageBase);\n+  Table[0].UnwindData = (DWORD)((char *)unwind_info - _ImageBase);\n+\n+  /* Register the unwind information.  */\n+  RtlAddFunctionTable (Table, 1, (DWORD64)_ImageBase);\n+}\n+\n+#else /* defined (_WIN64) */\n /*  Install the Win32 SEH exception handler. Note that the caller must have\n     allocated 8 bytes on the stack and pass the pointer to this stack\n     space. This is needed as the SEH exception handler must be on the stack of\n@@ -220,8 +303,9 @@ __gnat_install_SEH_handler (void *ER)\n \n   asm volatile (\"mov %0,%%fs:(0)\": : \"r\" (ER));\n }\n+#endif\n \n-#else /* defined (_WIN32) && !defined (_WIN64) */\n+#else /* defined (_WIN32) */\n /* For all non Windows targets we provide a dummy SEH install handler.  */\n void __gnat_install_SEH_handler (void *eh ATTRIBUTE_UNUSED)\n {"}, {"sha": "9fe88de141f3dcda94072d94645e0ff18f89fdd9", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a989c6ba5e462a5545f2fd853df3aac24879440/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a989c6ba5e462a5545f2fd853df3aac24879440/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=5a989c6ba5e462a5545f2fd853df3aac24879440", "patch": "@@ -2330,11 +2330,11 @@ package body Sem_Ch3 is\n       if Constant_Present (N) then\n          Prev_Entity := Current_Entity_In_Scope (Id);\n \n-         --  If the homograph is an implicit subprogram, it is overridden by\n-         --  the current declaration.\n-\n          if Present (Prev_Entity)\n            and then\n+               --  If the homograph is an implicit subprogram, it is overridden\n+               --  by the current declaration.\n+\n              ((Is_Overloadable (Prev_Entity)\n                  and then Is_Inherited_Operation (Prev_Entity))\n \n@@ -2346,7 +2346,19 @@ package body Sem_Ch3 is\n                or else\n                 (Is_Discriminal (Id)\n                    and then Ekind (Discriminal_Link (Id)) =\n-                              E_Entry_Index_Parameter))\n+                              E_Entry_Index_Parameter)\n+\n+               --  The current object is the renaming for a generic declared\n+               --  within the instance.\n+\n+               or else\n+                (Ekind (Prev_Entity) = E_Package\n+                   and then\n+                 Nkind (Parent (Prev_Entity)) = N_Package_Renaming_Declaration\n+                   and then\n+                 not Comes_From_Source (Prev_Entity)\n+                   and then\n+                 Is_Generic_Instance (Renamed_Entity (Prev_Entity))))\n          then\n             Prev_Entity := Empty;\n          end if;"}, {"sha": "c76e5bc8a3baa4de90de53509cd39d419dfac46f", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a989c6ba5e462a5545f2fd853df3aac24879440/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a989c6ba5e462a5545f2fd853df3aac24879440/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=5a989c6ba5e462a5545f2fd853df3aac24879440", "patch": "@@ -7949,7 +7949,12 @@ package body Sem_Prag is\n             Check_Valid_Configuration_Pragma;\n             Check_Restriction (No_Initialize_Scalars, N);\n \n-            if not Restriction_Active (No_Initialize_Scalars) then\n+            --  Initialize_Scalars creates false positives in CodePeer,\n+            --  so ignore this pragma in this mode.\n+\n+            if not Restriction_Active (No_Initialize_Scalars)\n+              and then not CodePeer_Mode\n+            then\n                Init_Or_Norm_Scalars := True;\n                Initialize_Scalars := True;\n             end if;\n@@ -9154,8 +9159,14 @@ package body Sem_Prag is\n             Check_Ada_83_Warning;\n             Check_Arg_Count (0);\n             Check_Valid_Configuration_Pragma;\n-            Normalize_Scalars := True;\n-            Init_Or_Norm_Scalars := True;\n+\n+            --  Normalize_Scalars creates false positives in CodePeer,\n+            --  so ignore this pragma in this mode.\n+\n+            if not CodePeer_Mode then\n+               Normalize_Scalars := True;\n+               Init_Or_Norm_Scalars := True;\n+            end if;\n \n          -----------------\n          -- Obsolescent --"}]}