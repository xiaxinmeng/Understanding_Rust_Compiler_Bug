{"sha": "7ffc7de55b058e78cbc46803b89b712849ea35b3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2ZmYzdkZTU1YjA1OGU3OGNiYzQ2ODAzYjg5YjcxMjg0OWVhMzViMw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2019-06-27T21:29:19Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2019-06-27T21:29:19Z"}, "message": "PR c++/55442 - memory-hog with highly recursive constexpr.\n\nThis testcase in the PR is extremely recursive, and therefore uses a huge\namount of memory on caching the results of individual calls.  We no longer\nneed to track all calls to catch infinite recursion, as we have other limits\non maximum depth and operations count.  So let's only cache a few calls at\nthe top level: 8 seems to be a reasonable compromise.\n\ngcc/c-family/\n\t* c.opt (fconstexpr-loop-limit): New.\ngcc/cp/\n\t* constexpr.c (push_cx_call_context): Return depth.\n\t(cxx_eval_call_expression): Don't cache past constexpr_cache_depth.\n\nFrom-SVN: r272765", "tree": {"sha": "45cdc9befe6ccde50d84263ddfe64923c8a031a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/45cdc9befe6ccde50d84263ddfe64923c8a031a9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7ffc7de55b058e78cbc46803b89b712849ea35b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ffc7de55b058e78cbc46803b89b712849ea35b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ffc7de55b058e78cbc46803b89b712849ea35b3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ffc7de55b058e78cbc46803b89b712849ea35b3/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "95bb6e7a56d17f5f8886815f85dff71d12964245", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95bb6e7a56d17f5f8886815f85dff71d12964245", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95bb6e7a56d17f5f8886815f85dff71d12964245"}], "stats": {"total": 60, "additions": 47, "deletions": 13}, "files": [{"sha": "22d7c6ecf7cfeda7a5f4e8329a72c737a4974aef", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ffc7de55b058e78cbc46803b89b712849ea35b3/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ffc7de55b058e78cbc46803b89b712849ea35b3/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=7ffc7de55b058e78cbc46803b89b712849ea35b3", "patch": "@@ -1,3 +1,8 @@\n+2019-06-26  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/55442 - memory-hog with highly recursive constexpr.\n+\t* c.opt (fconstexpr-loop-limit): New.\n+\n 2019-06-25  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR sanitizer/90954"}, {"sha": "080066fa6087787190eee482ca6d607baa319920", "filename": "gcc/c-family/c.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ffc7de55b058e78cbc46803b89b712849ea35b3/gcc%2Fc-family%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ffc7de55b058e78cbc46803b89b712849ea35b3/gcc%2Fc-family%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc.opt?ref=7ffc7de55b058e78cbc46803b89b712849ea35b3", "patch": "@@ -1424,6 +1424,10 @@ fconstexpr-depth=\n C++ ObjC++ Joined RejectNegative UInteger Var(max_constexpr_depth) Init(512)\n -fconstexpr-depth=<number>\tSpecify maximum constexpr recursion depth.\n \n+fconstexpr-cache-depth=\n+C++ ObjC++ Joined RejectNegative UInteger Var(constexpr_cache_depth) Init(8)\n+-fconstexpr-cache-depth=<number>\tSpecify maximum constexpr recursion cache depth.\n+\n fconstexpr-loop-limit=\n C++ ObjC++ Joined RejectNegative UInteger Var(constexpr_loop_limit) Init(262144)\n -fconstexpr-loop-limit=<number>\tSpecify maximum constexpr loop iteration count."}, {"sha": "db7ddf5075703b4b490bc55ff96b37ce45e8dbb0", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ffc7de55b058e78cbc46803b89b712849ea35b3/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ffc7de55b058e78cbc46803b89b712849ea35b3/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=7ffc7de55b058e78cbc46803b89b712849ea35b3", "patch": "@@ -1,3 +1,9 @@\n+2019-06-27  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/55442 - memory-hog with highly recursive constexpr.\n+\t* constexpr.c (push_cx_call_context): Return depth.\n+\t(cxx_eval_call_expression): Don't cache past constexpr_cache_depth.\n+\n 2019-06-27  Jan Hubicka  <jh@suse.cz>\n \n \t* class.c (layout_class_type): Set TYPE_CXX_ODR_P for as-base"}, {"sha": "d11e7af3eb11124002fde6d053bf21a3bcb21184", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ffc7de55b058e78cbc46803b89b712849ea35b3/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ffc7de55b058e78cbc46803b89b712849ea35b3/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=7ffc7de55b058e78cbc46803b89b712849ea35b3", "patch": "@@ -1447,16 +1447,17 @@ static vec<tree> call_stack;\n static int call_stack_tick;\n static int last_cx_error_tick;\n \n-static bool\n+static int\n push_cx_call_context (tree call)\n {\n   ++call_stack_tick;\n   if (!EXPR_HAS_LOCATION (call))\n     SET_EXPR_LOCATION (call, input_location);\n   call_stack.safe_push (call);\n-  if (call_stack.length () > (unsigned) max_constexpr_depth)\n+  int len = call_stack.length ();\n+  if (len > max_constexpr_depth)\n     return false;\n-  return true;\n+  return len;\n }\n \n static void\n@@ -1587,7 +1588,7 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n   tree fun = get_function_named_in_call (t);\n   constexpr_call new_call\n     = { NULL, NULL, NULL, 0, ctx->manifestly_const_eval };\n-  bool depth_ok;\n+  int depth_ok;\n \n   if (fun == NULL_TREE)\n     return cxx_eval_internal_function (ctx, t, lval,\n@@ -1791,14 +1792,20 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n       entry = *slot;\n       if (entry == NULL)\n \t{\n-\t  /* We need to keep a pointer to the entry, not just the slot, as the\n-\t     slot can move in the call to cxx_eval_builtin_function_call.  */\n-\t  *slot = entry = ggc_alloc<constexpr_call> ();\n-\t  *entry = new_call;\n-\t  fb.preserve ();\n+\t  /* Only cache up to constexpr_cache_depth to limit memory use.  */\n+\t  if (depth_ok < constexpr_cache_depth)\n+\t    {\n+\t      /* We need to keep a pointer to the entry, not just the slot, as\n+\t\t the slot can move during evaluation of the body.  */\n+\t      *slot = entry = ggc_alloc<constexpr_call> ();\n+\t      *entry = new_call;\n+\t      fb.preserve ();\n+\t    }\n \t}\n-      /* Calls that are in progress have their result set to NULL,\n-\t so that we can detect circular dependencies.  */\n+      /* Calls that are in progress have their result set to NULL, so that we\n+\t can detect circular dependencies.  Now that we only cache up to\n+\t constexpr_cache_depth this won't catch circular dependencies that\n+\t start deeper, but they'll hit the recursion or ops limit.  */\n       else if (entry->result == NULL)\n \t{\n \t  if (!ctx->quiet)"}, {"sha": "6382a840281ff3cbc7e45016b2e4f7a38b265068", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ffc7de55b058e78cbc46803b89b712849ea35b3/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ffc7de55b058e78cbc46803b89b712849ea35b3/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=7ffc7de55b058e78cbc46803b89b712849ea35b3", "patch": "@@ -209,8 +209,9 @@ in the following sections.\n @xref{C++ Dialect Options,,Options Controlling C++ Dialect}.\n @gccoptlist{-fabi-version=@var{n}  -fno-access-control @gol\n -faligned-new=@var{n}  -fargs-in-order=@var{n}  -fchar8_t  -fcheck-new @gol\n--fconstexpr-depth=@var{n}  -fconstexpr-loop-limit=@var{n} @gol\n--fconstexpr-ops-limit=@var{n} -fno-elide-constructors @gol\n+-fconstexpr-depth=@var{n}  -fconstexpr-cache-depth=@var{n} @gol\n+-fconstexpr-loop-limit=@var{n}  -fconstexpr-ops-limit=@var{n} @gol\n+-fno-elide-constructors @gol\n -fno-enforce-eh-specs @gol\n -fno-gnu-keywords @gol\n -fno-implicit-templates @gol\n@@ -2527,6 +2528,17 @@ to @var{n}.  A limit is needed to detect endless recursion during\n constant expression evaluation.  The minimum specified by the standard\n is 512.\n \n+@item -fconstexpr-cache-depth=@var{n}\n+@opindex fconstexpr-cache-depth\n+Set the maximum level of nested evaluation depth for C++11 constexpr\n+functions that will be cached to @var{n}.  This is a heuristic that\n+trades off compilation speed (when the cache avoids repeated\n+calculations) against memory consumption (when the cache grows very\n+large from highly recursive evaluations).  The default is 8.  Very few\n+users are likely to want to adjust it, but if your code does heavy\n+constexpr calculations you might want to experiment to find which\n+value works best for you.\n+\n @item -fconstexpr-loop-limit=@var{n}\n @opindex fconstexpr-loop-limit\n Set the maximum number of iterations for a loop in C++14 constexpr functions"}]}