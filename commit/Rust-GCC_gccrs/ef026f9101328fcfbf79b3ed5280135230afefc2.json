{"sha": "ef026f9101328fcfbf79b3ed5280135230afefc2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWYwMjZmOTEwMTMyOGZjZmJmNzliM2VkNTI4MDEzNTIzMGFmZWZjMg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-09-23T06:11:30Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-09-23T06:11:30Z"}, "message": "(init_reg_last_arrays): New function.\n\n(combine_instructions): Use it.\n(force_to_mode): Narrow mask to fit mode (except VOIDmode).\n(record_value_for_reg): When zeroing reg_last_set_value, also\nzero reg_last_set_{mode,nonzero_bits,sign_bit_copies}.\n(record_dead_and_set_regs): Likewise.\n\nFrom-SVN: r5430", "tree": {"sha": "c0bdf84e967cb652316c1401252cf15a8710c448", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c0bdf84e967cb652316c1401252cf15a8710c448"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ef026f9101328fcfbf79b3ed5280135230afefc2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef026f9101328fcfbf79b3ed5280135230afefc2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef026f9101328fcfbf79b3ed5280135230afefc2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef026f9101328fcfbf79b3ed5280135230afefc2/comments", "author": null, "committer": null, "parents": [{"sha": "9f5cad058274f4fdb14939db3470c89a94c21a24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f5cad058274f4fdb14939db3470c89a94c21a24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f5cad058274f4fdb14939db3470c89a94c21a24"}], "stats": {"total": 98, "additions": 61, "deletions": 37}, "files": [{"sha": "8251b2e5f087bbd205a0b770b0bd5e1de396e0fb", "filename": "gcc/combine.c", "status": "modified", "additions": 61, "deletions": 37, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef026f9101328fcfbf79b3ed5280135230afefc2/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef026f9101328fcfbf79b3ed5280135230afefc2/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=ef026f9101328fcfbf79b3ed5280135230afefc2", "patch": "@@ -368,6 +368,7 @@ static struct undobuf undobuf;\n \n static int n_occurrences;\n \n+static void init_reg_last_arrays\tPROTO(());\n static void setup_incoming_promotions   PROTO(());\n static void set_nonzero_bits_and_sign_copies  PROTO((rtx, rtx));\n static int can_combine_p\tPROTO((rtx, rtx, rtx, rtx, rtx *, rtx *));\n@@ -438,6 +439,13 @@ combine_instructions (f, nregs)\n \n   combine_max_regno = nregs;\n \n+  reg_nonzero_bits\n+    = (unsigned HOST_WIDE_INT *) alloca (nregs * sizeof (HOST_WIDE_INT));\n+  reg_sign_bit_copies = (char *) alloca (nregs * sizeof (char));\n+\n+  bzero (reg_nonzero_bits, nregs * sizeof (HOST_WIDE_INT));\n+  bzero (reg_sign_bit_copies, nregs * sizeof (char));\n+\n   reg_last_death = (rtx *) alloca (nregs * sizeof (rtx));\n   reg_last_set = (rtx *) alloca (nregs * sizeof (rtx));\n   reg_last_set_value = (rtx *) alloca (nregs * sizeof (rtx));\n@@ -451,21 +459,7 @@ combine_instructions (f, nregs)\n   reg_last_set_sign_bit_copies\n     = (char *) alloca (nregs * sizeof (char));\n \n-  reg_nonzero_bits\n-    = (unsigned HOST_WIDE_INT *) alloca (nregs * sizeof (HOST_WIDE_INT));\n-  reg_sign_bit_copies = (char *) alloca (nregs * sizeof (char));\n-\n-  bzero (reg_last_death, nregs * sizeof (rtx));\n-  bzero (reg_last_set, nregs * sizeof (rtx));\n-  bzero (reg_last_set_value, nregs * sizeof (rtx));\n-  bzero (reg_last_set_table_tick, nregs * sizeof (int));\n-  bzero (reg_last_set_label, nregs * sizeof (int));\n-  bzero (reg_last_set_invalid, nregs * sizeof (char));\n-  bzero (reg_last_set_mode, nregs * sizeof (enum machine_mode));\n-  bzero (reg_last_set_nonzero_bits, nregs * sizeof (HOST_WIDE_INT));\n-  bzero (reg_last_set_sign_bit_copies, nregs * sizeof (char));\n-  bzero (reg_nonzero_bits, nregs * sizeof (HOST_WIDE_INT));\n-  bzero (reg_sign_bit_copies, nregs * sizeof (char));\n+  init_reg_last_arrays ();\n \n   init_recog_no_volatile ();\n \n@@ -523,13 +517,7 @@ combine_instructions (f, nregs)\n   label_tick = 1;\n   last_call_cuid = 0;\n   mem_last_set = 0;\n-  bzero (reg_last_death, nregs * sizeof (rtx));\n-  bzero (reg_last_set, nregs * sizeof (rtx));\n-  bzero (reg_last_set_value, nregs * sizeof (rtx));\n-  bzero (reg_last_set_table_tick, nregs * sizeof (int));\n-  bzero (reg_last_set_label, nregs * sizeof (int));\n-  bzero (reg_last_set_invalid, nregs * sizeof (char));\n-\n+  init_reg_last_arrays ();\n   setup_incoming_promotions ();\n \n   for (insn = f; insn; insn = next ? next : NEXT_INSN (insn))\n@@ -640,6 +628,24 @@ combine_instructions (f, nregs)\n \n   nonzero_sign_valid = 0;\n }\n+\n+/* Wipe the reg_last_xxx arrays in preparation for another pass.  */\n+\n+static void\n+init_reg_last_arrays ()\n+{\n+  int nregs = combine_max_regno;\n+\n+  bzero (reg_last_death, nregs * sizeof (rtx));\n+  bzero (reg_last_set, nregs * sizeof (rtx));\n+  bzero (reg_last_set_value, nregs * sizeof (rtx));\n+  bzero (reg_last_set_table_tick, nregs * sizeof (int));\n+  bzero (reg_last_set_label, nregs * sizeof (int));\n+  bzero (reg_last_set_invalid, nregs * sizeof (char));\n+  bzero (reg_last_set_mode, nregs * sizeof (enum machine_mode));\n+  bzero (reg_last_set_nonzero_bits, nregs * sizeof (HOST_WIDE_INT));\n+  bzero (reg_last_set_sign_bit_copies, nregs * sizeof (char));\n+}\n \f\n /* Set up any promoted values for incoming argument registers.  */\n \n@@ -5554,25 +5560,34 @@ force_to_mode (x, mode, mask, reg)\n      rtx reg;\n {\n   enum rtx_code code = GET_CODE (x);\n-  unsigned HOST_WIDE_INT nonzero = nonzero_bits (x, mode);\n+  enum machine_mode op_mode;\n+  unsigned HOST_WIDE_INT fuller_mask, nonzero;\n   rtx op0, op1, temp;\n \n   /* We want to perform the operation is its present mode unless we know\n      that the operation is valid in MODE, in which case we do the operation\n      in MODE.  */\n-  enum machine_mode op_mode\n-    = ((code_to_optab[(int) code] != 0\n-\t&& (code_to_optab[(int) code]->handlers[(int) mode].insn_code\n-\t    != CODE_FOR_nothing))\n-       ? mode : GET_MODE (x));\n+  op_mode = ((code_to_optab[(int) code] != 0\n+\t      && (code_to_optab[(int) code]->handlers[(int) mode].insn_code\n+\t\t  != CODE_FOR_nothing))\n+\t     ? mode : GET_MODE (x));\n+\n+  /* Truncate MASK to fit OP_MODE.  */\n+  if (op_mode)\n+    mask &= GET_MODE_MASK (op_mode);\n \n   /* When we have an arithmetic operation, or a shift whose count we\n      do not know, we need to assume that all bit the up to the highest-order\n      bit in MASK will be needed.  This is how we form such a mask.  */\n-  unsigned HOST_WIDE_INT fuller_mask\n-    = (GET_MODE_BITSIZE (op_mode) >= HOST_BITS_PER_WIDE_INT\n-       ? GET_MODE_MASK (op_mode)\n-       : ((HOST_WIDE_INT) 1 << (floor_log2 (mask) + 1)) - 1);\n+  if (op_mode)\n+    fuller_mask = (GET_MODE_BITSIZE (op_mode) >= HOST_BITS_PER_WIDE_INT\n+\t\t   ? GET_MODE_MASK (op_mode)\n+\t\t   : ((HOST_WIDE_INT) 1 << (floor_log2 (mask) + 1)) - 1);\n+  else\n+    fuller_mask = ~ (HOST_WIDE_INT) 0;\n+\n+  /* Determine what bits of X are guaranteed to be (non)zero.  */\n+  nonzero = nonzero_bits (x, mode);\n \n   /* If none of the bits in X are needed, return a zero.  */\n   if ((nonzero & mask) == 0)\n@@ -9188,13 +9203,17 @@ record_value_for_reg (reg, insn, value)\n     }\n \n   /* For each register modified, show we don't know its value, that\n-     its value has been updated, and that we don't know the location of\n-     the death of the register.  */\n+     we don't know about its bitwise content, that its value has been\n+     updated, and that we don't know the location of the death of the\n+     register.  */\n   for (i = regno; i < endregno; i ++)\n     {\n       if (insn)\n \treg_last_set[i] = insn;\n       reg_last_set_value[i] = 0;\n+      reg_last_set_mode[i] = 0;\n+      reg_last_set_nonzero_bits[i] = 0;\n+      reg_last_set_sign_bit_copies[i] = 0;\n       reg_last_death[i] = 0;\n     }\n \n@@ -9281,9 +9300,11 @@ record_dead_and_set_regs_1 (dest, setter)\n    for the things done by INSN.  This is the last thing done in processing\n    INSN in the combiner loop.\n \n-   We update reg_last_set, reg_last_set_value, reg_last_death, and also the\n-   similar information mem_last_set (which insn most recently modified memory)\n-   and last_call_cuid (which insn was the most recent subroutine call).  */\n+   We update reg_last_set, reg_last_set_value, reg_last_set_mode,\n+   reg_last_set_nonzero_bits, reg_last_set_sign_bit_copies, reg_last_death,\n+   and also the similar information mem_last_set (which insn most recently\n+   modified memory) and last_call_cuid (which insn was the most recent\n+   subroutine call).  */\n \n static void\n record_dead_and_set_regs (insn)\n@@ -9316,6 +9337,9 @@ record_dead_and_set_regs (insn)\n \tif (call_used_regs[i])\n \t  {\n \t    reg_last_set_value[i] = 0;\n+\t    reg_last_set_mode[i] = 0;\n+\t    reg_last_set_nonzero_bits[i] = 0;\n+\t    reg_last_set_sign_bit_copies[i] = 0;\n \t    reg_last_death[i] = 0;\n \t  }\n "}]}