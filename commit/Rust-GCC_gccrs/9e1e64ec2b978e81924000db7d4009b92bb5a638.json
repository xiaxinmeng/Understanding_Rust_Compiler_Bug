{"sha": "9e1e64ec2b978e81924000db7d4009b92bb5a638", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWUxZTY0ZWMyYjk3OGU4MTkyNDAwMGRiN2Q0MDA5YjkyYmI1YTYzOA==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2008-03-21T18:56:51Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2008-03-21T18:56:51Z"}, "message": "cp-tree.h (IS_AGGR_TYPE): Rename to MAYBE_CLASS_TYPE_P.\n\n2008-03-21  Paolo Carlini  <pcarlini@suse.de>\n\n\t* cp-tree.h (IS_AGGR_TYPE): Rename to MAYBE_CLASS_TYPE_P.\n\t(SET_IS_AGGR_TYPE): Rename to SET_CLASS_TYPE_P.\n\t(IS_AGGR_TYPE_CODE): Rename to RECORD_OR_UNION_CODE_P.\n\t(PROMOTES_TO_AGGR_TYPE): Remove.\n\t(CLASS_TYPE_P, TYPE_NON_AGGREGATE_CLASS): Adjust.\n\t* typeck.c (unary_complex_lvalue, build_modify_expr,\n\tconvert_for_initialization): Adjust.\n\t* init.c (is_aggr_type): Remove.\n\t(is_class_type): Add.\n\t(build_offset_ref, build_new_1, build_vec_delete_1, build_vec_init,\n\tbuild_delete): Adjust.\n\t* lex.c (make_aggr_type): Remove.\n\t(make_class_type): Add.\n\t(cxx_make_type): Adjust.\n\t* class.c (finish_struct_1, fixed_type_or_null, is_empty_class):\n\tAdjust.\n\t* decl.c (build_typename_type, make_typename_type,\n\tmake_unbound_class_template, cxx_init_decl_processing,\n\tcheck_tag_decl, groktypename, start_decl_1, layout_var_decl,\n\tcheck_initializer, cp_finish_decl, build_ptrmemfunc_type, grokparms,\n\tgrok_op_properties, xref_tag, check_function_type): Adjust.\n\t* call.c (check_dtor_name, standard_conversion, implicit_conversion,\n\tadd_builtin_candidate, add_builtin_candidates,\n\tbuild_user_type_conversion_1, convert_like_real, build_cxx_call,\n\tis_subseq, compare_ics): Adjust.\n\t* method.c (use_thunk): Adjust.\n\t* rtti.c (build_dynamic_cast_1, create_pseudo_type_info,\n\tcreate_tinfo_types): Adjust.\n\t* cvt.c (cp_convert_to_pointer, convert_to_pointer_force,\n\tbuild_up_reference, convert_to_reference, convert_from_reference,\n\tocp_convert, build_expr_type_conversion): Adjust.\n\t* tree.c (bind_template_template_parm, error_type): Adjust.\n\t* dump.c (cp_dump_tree): Adjust.\n\t* search.c (lookup_member): Adjust.\n\t* friend.c (make_friend_class, do_friend): Adjust.\n\t* typeck2.c (store_init_value, process_init_constructor_array,\n\tprocess_init_constructor_record, build_x_arrow, build_m_component_ref,\n\tbuild_functional_cast): Adjust.\n\t* pt.c (finish_member_template_decl, process_template_parm,\n\tlookup_template_class, tsubst_function_type, tsubst,\n\ttsubst_copy_and_build, get_template_base, bt_instantiate_type_proc):\n\tAdjust.\n\t* semantics.c (begin_class_definition, finish_base_specifier,\n\tfinish_typeof, cxx_omp_predetermined_sharing, finish_decltype_type):\n\tAdjust.\n\t* name-lookup.c (constructor_name_p, push_overloaded_decl,\n\tdo_class_using_decl, lookup_qualified_name,\n\tmaybe_process_template_type_declaration): Adjust.\n\t* decl2.c (grok_array_decl, check_member_template,\n\tconstrain_class_visibility): Adjust.\n\t* parser.c (cp_parser_class_name): Adjust.\n\nFrom-SVN: r133434", "tree": {"sha": "28e5155485b87e7675ad708f94b5a26a8e4ea948", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/28e5155485b87e7675ad708f94b5a26a8e4ea948"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e1e64ec2b978e81924000db7d4009b92bb5a638", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e1e64ec2b978e81924000db7d4009b92bb5a638", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e1e64ec2b978e81924000db7d4009b92bb5a638", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e1e64ec2b978e81924000db7d4009b92bb5a638/comments", "author": null, "committer": null, "parents": [{"sha": "fc34570cc14662c34807b275ea7dd5c8ac310e9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc34570cc14662c34807b275ea7dd5c8ac310e9f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc34570cc14662c34807b275ea7dd5c8ac310e9f"}], "stats": {"total": 378, "additions": 215, "deletions": 163}, "files": [{"sha": "eaaddc8bf43a50b06a5e970d51e2cdcc0e5b4ca2", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e1e64ec2b978e81924000db7d4009b92bb5a638/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e1e64ec2b978e81924000db7d4009b92bb5a638/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9e1e64ec2b978e81924000db7d4009b92bb5a638", "patch": "@@ -1,3 +1,57 @@\n+2008-03-21  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* cp-tree.h (IS_AGGR_TYPE): Rename to MAYBE_CLASS_TYPE_P.\n+\t(SET_IS_AGGR_TYPE): Rename to SET_CLASS_TYPE_P.\n+\t(IS_AGGR_TYPE_CODE): Rename to RECORD_OR_UNION_CODE_P.\n+\t(PROMOTES_TO_AGGR_TYPE): Remove.\n+\t(CLASS_TYPE_P, TYPE_NON_AGGREGATE_CLASS): Adjust.\n+\t* typeck.c (unary_complex_lvalue, build_modify_expr,\n+\tconvert_for_initialization): Adjust.\n+\t* init.c (is_aggr_type): Remove.\n+\t(is_class_type): Add.\n+\t(build_offset_ref, build_new_1, build_vec_delete_1, build_vec_init,\n+\tbuild_delete): Adjust.\n+\t* lex.c (make_aggr_type): Remove.\n+\t(make_class_type): Add.\n+\t(cxx_make_type): Adjust.\n+\t* class.c (finish_struct_1, fixed_type_or_null, is_empty_class):\n+\tAdjust.\n+\t* decl.c (build_typename_type, make_typename_type,\n+\tmake_unbound_class_template, cxx_init_decl_processing,\n+\tcheck_tag_decl, groktypename, start_decl_1, layout_var_decl,\n+\tcheck_initializer, cp_finish_decl, build_ptrmemfunc_type, grokparms,\n+\tgrok_op_properties, xref_tag, check_function_type): Adjust.\n+\t* call.c (check_dtor_name, standard_conversion, implicit_conversion,\n+\tadd_builtin_candidate, add_builtin_candidates,\n+\tbuild_user_type_conversion_1, convert_like_real, build_cxx_call,\n+\tis_subseq, compare_ics): Adjust.\n+\t* method.c (use_thunk): Adjust.\n+\t* rtti.c (build_dynamic_cast_1, create_pseudo_type_info,\n+\tcreate_tinfo_types): Adjust.\n+\t* cvt.c (cp_convert_to_pointer, convert_to_pointer_force,\n+\tbuild_up_reference, convert_to_reference, convert_from_reference,\n+\tocp_convert, build_expr_type_conversion): Adjust.\n+\t* tree.c (bind_template_template_parm, error_type): Adjust.\n+\t* dump.c (cp_dump_tree): Adjust.\n+\t* search.c (lookup_member): Adjust.\n+\t* friend.c (make_friend_class, do_friend): Adjust.\n+\t* typeck2.c (store_init_value, process_init_constructor_array,\n+\tprocess_init_constructor_record, build_x_arrow, build_m_component_ref,\n+\tbuild_functional_cast): Adjust.\n+\t* pt.c (finish_member_template_decl, process_template_parm,\n+\tlookup_template_class, tsubst_function_type, tsubst,\n+\ttsubst_copy_and_build, get_template_base, bt_instantiate_type_proc):\n+\tAdjust.\n+\t* semantics.c (begin_class_definition, finish_base_specifier,\n+\tfinish_typeof, cxx_omp_predetermined_sharing, finish_decltype_type):\n+\tAdjust.\n+\t* name-lookup.c (constructor_name_p, push_overloaded_decl,\n+\tdo_class_using_decl, lookup_qualified_name,\n+\tmaybe_process_template_type_declaration): Adjust.\n+\t* decl2.c (grok_array_decl, check_member_template,\n+\tconstrain_class_visibility): Adjust.\n+\t* parser.c (cp_parser_class_name): Adjust.\n+\n 2008-03-18  Paolo Bonzini  <bonzini@gnu.org>\n \n         * cp-lang.c (LANG_HOOKS_REDUCE_BIT_FIELD_OPERATIONS): Delete."}, {"sha": "41e6933f68633f3fd2f529e1b1f6589991050a0d", "filename": "gcc/cp/call.c", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e1e64ec2b978e81924000db7d4009b92bb5a638/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e1e64ec2b978e81924000db7d4009b92bb5a638/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=9e1e64ec2b978e81924000db7d4009b92bb5a638", "patch": "@@ -214,7 +214,8 @@ check_dtor_name (tree basetype, tree name)\n     /* OK */;\n   else if (TREE_CODE (name) == IDENTIFIER_NODE)\n     {\n-      if ((IS_AGGR_TYPE (basetype) && name == constructor_name (basetype))\n+      if ((MAYBE_CLASS_TYPE_P (basetype)\n+\t   && name == constructor_name (basetype))\n \t  || (TREE_CODE (basetype) == ENUMERAL_TYPE\n \t      && name == TYPE_IDENTIFIER (basetype)))\n \treturn true;\n@@ -732,8 +733,8 @@ standard_conversion (tree to, tree from, tree expr, bool c_cast_p,\n \t  else if (!same_type_p (fbase, tbase))\n \t    return NULL;\n \t}\n-      else if (IS_AGGR_TYPE (TREE_TYPE (from))\n-\t       && IS_AGGR_TYPE (TREE_TYPE (to))\n+      else if (MAYBE_CLASS_TYPE_P (TREE_TYPE (from))\n+\t       && MAYBE_CLASS_TYPE_P (TREE_TYPE (to))\n \t       /* [conv.ptr]\n \n \t\t  An rvalue of type \"pointer to cv D,\" where D is a\n@@ -849,7 +850,7 @@ standard_conversion (tree to, tree from, tree expr, bool c_cast_p,\n   else if (fcode == VECTOR_TYPE && tcode == VECTOR_TYPE\n \t   && vector_types_convertible_p (from, to, false))\n     return build_conv (ck_std, to, conv);\n-  else if (IS_AGGR_TYPE (to) && IS_AGGR_TYPE (from)\n+  else if (MAYBE_CLASS_TYPE_P (to) && MAYBE_CLASS_TYPE_P (from)\n \t   && is_properly_derived_from (from, to))\n     {\n       if (conv->kind == ck_rvalue)\n@@ -1296,8 +1297,8 @@ implicit_conversion (tree to, tree from, tree expr, bool c_cast_p,\n     return conv;\n \n   if (expr != NULL_TREE\n-      && (IS_AGGR_TYPE (from)\n-\t  || IS_AGGR_TYPE (to))\n+      && (MAYBE_CLASS_TYPE_P (from)\n+\t  || MAYBE_CLASS_TYPE_P (to))\n       && (flags & LOOKUP_NO_CONVERSION) == 0)\n     {\n       struct z_candidate *cand;\n@@ -1753,7 +1754,7 @@ add_builtin_candidate (struct z_candidate **candidates, enum tree_code code,\n \t  tree c1 = TREE_TYPE (type1);\n \t  tree c2 = TYPE_PTRMEM_CLASS_TYPE (type2);\n \n-\t  if (IS_AGGR_TYPE (c1) && DERIVED_FROM_P (c2, c1)\n+\t  if (MAYBE_CLASS_TYPE_P (c1) && DERIVED_FROM_P (c2, c1)\n \t      && (TYPE_PTRMEMFUNC_P (type2)\n \t\t  || is_complete (TYPE_PTRMEM_POINTED_TO_TYPE (type2))))\n \t    break;\n@@ -2024,7 +2025,7 @@ add_builtin_candidate (struct z_candidate **candidates, enum tree_code code,\n \t  || (TYPE_PTR_P (type1) && TYPE_PTR_P (type2))\n \t  || (TYPE_PTRMEM_P (type1) && TYPE_PTRMEM_P (type2))\n \t  || TYPE_PTRMEMFUNC_P (type1)\n-\t  || IS_AGGR_TYPE (type1)\n+\t  || MAYBE_CLASS_TYPE_P (type1)\n \t  || TREE_CODE (type1) == ENUMERAL_TYPE))\n     {\n       build_builtin_candidate\n@@ -2141,7 +2142,7 @@ add_builtin_candidates (struct z_candidate **candidates, enum tree_code code,\n     {\n       if (! args[i])\n \t;\n-      else if (IS_AGGR_TYPE (argtypes[i]))\n+      else if (MAYBE_CLASS_TYPE_P (argtypes[i]))\n \t{\n \t  tree convs;\n \n@@ -2568,13 +2569,13 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags)\n   /* We represent conversion within a hierarchy using RVALUE_CONV and\n      BASE_CONV, as specified by [over.best.ics]; these become plain\n      constructor calls, as specified in [dcl.init].  */\n-  gcc_assert (!IS_AGGR_TYPE (fromtype) || !IS_AGGR_TYPE (totype)\n+  gcc_assert (!MAYBE_CLASS_TYPE_P (fromtype) || !MAYBE_CLASS_TYPE_P (totype)\n \t      || !DERIVED_FROM_P (totype, fromtype));\n \n-  if (IS_AGGR_TYPE (totype))\n+  if (MAYBE_CLASS_TYPE_P (totype))\n     ctors = lookup_fnfields (totype, complete_ctor_identifier, 0);\n \n-  if (IS_AGGR_TYPE (fromtype))\n+  if (MAYBE_CLASS_TYPE_P (fromtype))\n     {\n       tree to_nonref = non_reference (totype);\n       if (same_type_ignoring_top_level_qualifiers_p (to_nonref, fromtype) ||\n@@ -4381,7 +4382,7 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \t   conversion, but is not considered during overload resolution.\n \n \t   If the target is a class, that means call a ctor.  */\n-\tif (IS_AGGR_TYPE (totype)\n+\tif (MAYBE_CLASS_TYPE_P (totype)\n \t    && (inner >= 0 || !lvalue_p (expr)))\n \t  {\n \t    expr = (build_temp\n@@ -4443,7 +4444,7 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n     {\n     case ck_rvalue:\n       expr = convert_bitfield_to_declared_type (expr);\n-      if (! IS_AGGR_TYPE (totype))\n+      if (! MAYBE_CLASS_TYPE_P (totype))\n \treturn expr;\n       /* Else fall through.  */\n     case ck_base:\n@@ -5193,7 +5194,7 @@ build_cxx_call (tree fn, int nargs, tree *argarray)\n   if (fn == error_mark_node)\n     return error_mark_node;\n \n-  if (IS_AGGR_TYPE (TREE_TYPE (fn)))\n+  if (MAYBE_CLASS_TYPE_P (TREE_TYPE (fn)))\n     fn = build_cplus_new (TREE_TYPE (fn), fn);\n   return convert_from_reference (fn);\n }\n@@ -5742,8 +5743,7 @@ is_subseq (conversion *ics1, conversion *ics2)\n bool\n is_properly_derived_from (tree derived, tree base)\n {\n-  if (!IS_AGGR_TYPE_CODE (TREE_CODE (derived))\n-      || !IS_AGGR_TYPE_CODE (TREE_CODE (base)))\n+  if (!CLASS_TYPE_P (derived) || !CLASS_TYPE_P (base))\n     return false;\n \n   /* We only allow proper derivation here.  The DERIVED_FROM_P macro\n@@ -6021,8 +6021,8 @@ compare_ics (conversion *ics1, conversion *ics2)\n     }\n \n   if (deref_from_type1 != NULL_TREE\n-      && IS_AGGR_TYPE_CODE (TREE_CODE (deref_from_type1))\n-      && IS_AGGR_TYPE_CODE (TREE_CODE (deref_from_type2)))\n+      && RECORD_OR_UNION_CODE_P (TREE_CODE (deref_from_type1))\n+      && RECORD_OR_UNION_CODE_P (TREE_CODE (deref_from_type2)))\n     {\n       /* This was one of the pointer or pointer-like conversions.\n \n@@ -6059,8 +6059,8 @@ compare_ics (conversion *ics1, conversion *ics2)\n \t\treturn -1;\n \t    }\n \t}\n-      else if (IS_AGGR_TYPE_CODE (TREE_CODE (deref_to_type1))\n-\t       && IS_AGGR_TYPE_CODE (TREE_CODE (deref_to_type2)))\n+      else if (RECORD_OR_UNION_CODE_P (TREE_CODE (deref_to_type1))\n+\t       && RECORD_OR_UNION_CODE_P (TREE_CODE (deref_to_type2)))\n \t{\n \t  /* [over.ics.rank]\n "}, {"sha": "154c3b3fc37cadcd8d88c9e9a7274e2e887ca98a", "filename": "gcc/cp/class.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e1e64ec2b978e81924000db7d4009b92bb5a638/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e1e64ec2b978e81924000db7d4009b92bb5a638/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=9e1e64ec2b978e81924000db7d4009b92bb5a638", "patch": "@@ -1,6 +1,6 @@\n /* Functions related to building classes and their related objects.\n    Copyright (C) 1987, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008\n    Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com)\n \n@@ -4926,7 +4926,7 @@ layout_class_type (tree t, tree *virtuals_p)\n   remove_zero_width_bit_fields (t);\n \n   /* Create the version of T used for virtual bases.  We do not use\n-     make_aggr_type for this version; this is an artificial type.  For\n+     make_class_type for this version; this is an artificial type.  For\n      a POD type, we just reuse T.  */\n   if (CLASSTYPE_NON_POD_P (t) || CLASSTYPE_EMPTY_P (t))\n     {\n@@ -5086,7 +5086,7 @@ finish_struct_1 (tree t)\n \n   if (COMPLETE_TYPE_P (t))\n     {\n-      gcc_assert (IS_AGGR_TYPE (t));\n+      gcc_assert (MAYBE_CLASS_TYPE_P (t));\n       error (\"redefinition of %q#T\", t);\n       popclass ();\n       return;\n@@ -5432,7 +5432,7 @@ fixed_type_or_null (tree instance, int *nonnull, int *cdtorp)\n     case VAR_DECL:\n     case FIELD_DECL:\n       if (TREE_CODE (TREE_TYPE (instance)) == ARRAY_TYPE\n-\t  && IS_AGGR_TYPE (TREE_TYPE (TREE_TYPE (instance))))\n+\t  && MAYBE_CLASS_TYPE_P (TREE_TYPE (TREE_TYPE (instance))))\n \t{\n \t  if (nonnull)\n \t    *nonnull = 1;\n@@ -5442,7 +5442,7 @@ fixed_type_or_null (tree instance, int *nonnull, int *cdtorp)\n     case TARGET_EXPR:\n     case PARM_DECL:\n     case RESULT_DECL:\n-      if (IS_AGGR_TYPE (TREE_TYPE (instance)))\n+      if (MAYBE_CLASS_TYPE_P (TREE_TYPE (instance)))\n \t{\n \t  if (nonnull)\n \t    *nonnull = 1;\n@@ -6343,7 +6343,7 @@ is_empty_class (tree type)\n   if (type == error_mark_node)\n     return 0;\n \n-  if (! IS_AGGR_TYPE (type))\n+  if (! MAYBE_CLASS_TYPE_P (type))\n     return 0;\n \n   /* In G++ 3.2, whether or not a class was empty was determined by"}, {"sha": "9afeed71fbe728cedc0e0cf3f330ac0ca737815b", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 12, "deletions": 19, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e1e64ec2b978e81924000db7d4009b92bb5a638/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e1e64ec2b978e81924000db7d4009b92bb5a638/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=9e1e64ec2b978e81924000db7d4009b92bb5a638", "patch": "@@ -1,6 +1,6 @@\n /* Definitions for C++ parsing and type checking.\n    Copyright (C) 1987, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,\n-   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n+   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008\n    Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com)\n \n@@ -95,7 +95,7 @@ struct diagnostic_info;\n    2: Unused\n    3: TYPE_FOR_JAVA.\n    4: TYPE_HAS_NONTRIVIAL_DESTRUCTOR\n-   5: IS_AGGR_TYPE.\n+   5: CLASS_TYPE_P.\n    6: TYPE_DEPENDENT_P_VALID\n \n    Usage of DECL_LANG_FLAG_?:\n@@ -958,34 +958,32 @@ enum languages { lang_c, lang_cplusplus, lang_java };\n \n /* Nonzero if T is a class (or struct or union) type.  Also nonzero\n    for template type parameters, typename types, and instantiated\n-   template template parameters.  Despite its name,\n-   this macro has nothing to do with the definition of aggregate given\n-   in the standard.  Think of this macro as MAYBE_CLASS_TYPE_P.  Keep\n-   these checks in ascending code order.  */\n-#define IS_AGGR_TYPE(T)\t\t\t\t\t\\\n+   template template parameters.  Keep these checks in ascending code\n+   order.  */\n+#define MAYBE_CLASS_TYPE_P(T)\t\t\t\t\t\\\n   (TREE_CODE (T) == TEMPLATE_TYPE_PARM\t\t\t\\\n    || TREE_CODE (T) == TYPENAME_TYPE\t\t\t\\\n    || TREE_CODE (T) == TYPEOF_TYPE\t\t\t\\\n    || TREE_CODE (T) == BOUND_TEMPLATE_TEMPLATE_PARM\t\\\n    || TREE_CODE (T) == DECLTYPE_TYPE\t\t\t\\\n    || TYPE_LANG_FLAG_5 (T))\n \n-/* Set IS_AGGR_TYPE for T to VAL.  T must be a class, struct, or\n+/* Set CLASS_TYPE_P for T to VAL.  T must be a class, struct, or\n    union type.  */\n-#define SET_IS_AGGR_TYPE(T, VAL) \\\n+#define SET_CLASS_TYPE_P(T, VAL) \\\n   (TYPE_LANG_FLAG_5 (T) = (VAL))\n \n /* Nonzero if T is a class type.  Zero for template type parameters,\n    typename types, and so forth.  */\n #define CLASS_TYPE_P(T) \\\n-  (IS_AGGR_TYPE_CODE (TREE_CODE (T)) && TYPE_LANG_FLAG_5 (T))\n+  (RECORD_OR_UNION_CODE_P (TREE_CODE (T)) && TYPE_LANG_FLAG_5 (T))\n \n /* Nonzero if T is a class type but not an union.  */\n #define NON_UNION_CLASS_TYPE_P(T) \\\n   (CLASS_TYPE_P (T) && TREE_CODE (T) != UNION_TYPE)\n \n /* Keep these checks in ascending code order.  */\n-#define IS_AGGR_TYPE_CODE(T)\t\\\n+#define RECORD_OR_UNION_CODE_P(T)\t\\\n   ((T) == RECORD_TYPE || (T) == UNION_TYPE)\n #define TAGGED_TYPE_P(T) \\\n   (CLASS_TYPE_P (T) || TREE_CODE (T) == ENUMERAL_TYPE)\n@@ -1034,11 +1032,6 @@ enum languages { lang_c, lang_cplusplus, lang_java };\n #define FUNCTION_FIRST_USER_PARM(NODE) \\\n   skip_artificial_parms_for ((NODE), DECL_ARGUMENTS (NODE))\n \n-#define PROMOTES_TO_AGGR_TYPE(NODE, CODE)\t\\\n-  (((CODE) == TREE_CODE (NODE)\t\t\t\\\n-    && IS_AGGR_TYPE (TREE_TYPE (NODE)))\t\t\\\n-   || IS_AGGR_TYPE (NODE))\n-\n /* Nonzero iff TYPE is derived from PARENT. Ignores accessibility and\n    ambiguity issues.  */\n #define DERIVED_FROM_P(PARENT, TYPE) \\\n@@ -2746,7 +2739,7 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n #define CLASSTYPE_NON_AGGREGATE(NODE) \\\n   (LANG_TYPE_CLASS_CHECK (NODE)->non_aggregate)\n #define TYPE_NON_AGGREGATE_CLASS(NODE) \\\n-  (IS_AGGR_TYPE (NODE) && CLASSTYPE_NON_AGGREGATE (NODE))\n+  (MAYBE_CLASS_TYPE_P (NODE) && CLASSTYPE_NON_AGGREGATE (NODE))\n \n /* Nonzero if there is a user-defined X::op=(x&) for this class.  */\n #define TYPE_HAS_COMPLEX_ASSIGN_REF(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->has_complex_assign_ref)\n@@ -4344,7 +4337,7 @@ extern tree do_friend\t\t\t\t(tree, tree, tree, tree, enum overload_flags, bool);\n extern tree expand_member_init\t\t\t(tree);\n extern void emit_mem_initializers\t\t(tree);\n extern tree build_aggr_init\t\t\t(tree, tree, int);\n-extern int is_aggr_type\t\t\t\t(tree, int);\n+extern int is_class_type\t\t\t(tree, int);\n extern tree get_type_value\t\t\t(tree);\n extern tree build_zero_init\t\t\t(tree, tree, bool);\n extern tree build_value_init\t\t\t(tree);\n@@ -4374,7 +4367,7 @@ extern void retrofit_lang_decl\t\t\t(tree);\n extern tree copy_decl\t\t\t\t(tree);\n extern tree copy_type\t\t\t\t(tree);\n extern tree cxx_make_type\t\t\t(enum tree_code);\n-extern tree make_aggr_type\t\t\t(enum tree_code);\n+extern tree make_class_type\t\t\t(enum tree_code);\n extern void yyerror\t\t\t\t(const char *);\n extern void yyhook\t\t\t\t(int);\n extern bool cxx_init\t\t\t\t(void);"}, {"sha": "64a871650e1594aa3a3ae90241f9eb64116e310d", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e1e64ec2b978e81924000db7d4009b92bb5a638/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e1e64ec2b978e81924000db7d4009b92bb5a638/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=9e1e64ec2b978e81924000db7d4009b92bb5a638", "patch": "@@ -1,6 +1,6 @@\n /* Language-level data type conversion for GNU C++.\n    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008\n    Free Software Foundation, Inc.\n    Hacked by Michael Tiemann (tiemann@cygnus.com)\n \n@@ -82,7 +82,7 @@ cp_convert_to_pointer (tree type, tree expr)\n   if (intype == error_mark_node)\n     return error_mark_node;\n \n-  if (IS_AGGR_TYPE (intype))\n+  if (MAYBE_CLASS_TYPE_P (intype))\n     {\n       intype = complete_type (intype);\n       if (!COMPLETE_TYPE_P (intype))\n@@ -127,8 +127,8 @@ cp_convert_to_pointer (tree type, tree expr)\n       if (TYPE_MAIN_VARIANT (type) != intype\n \t  && TREE_CODE (type) == POINTER_TYPE\n \t  && TREE_CODE (TREE_TYPE (type)) == RECORD_TYPE\n-\t  && IS_AGGR_TYPE (TREE_TYPE (type))\n-\t  && IS_AGGR_TYPE (TREE_TYPE (intype))\n+\t  && MAYBE_CLASS_TYPE_P (TREE_TYPE (type))\n+\t  && MAYBE_CLASS_TYPE_P (TREE_TYPE (intype))\n \t  && TREE_CODE (TREE_TYPE (intype)) == RECORD_TYPE)\n \t{\n \t  enum tree_code code = PLUS_EXPR;\n@@ -256,8 +256,8 @@ convert_to_pointer_force (tree type, tree expr)\n \n       if (TYPE_MAIN_VARIANT (type) != intype\n \t  && TREE_CODE (TREE_TYPE (type)) == RECORD_TYPE\n-\t  && IS_AGGR_TYPE (TREE_TYPE (type))\n-\t  && IS_AGGR_TYPE (TREE_TYPE (intype))\n+\t  && MAYBE_CLASS_TYPE_P (TREE_TYPE (type))\n+\t  && MAYBE_CLASS_TYPE_P (TREE_TYPE (intype))\n \t  && TREE_CODE (TREE_TYPE (intype)) == RECORD_TYPE)\n \t{\n \t  enum tree_code code = PLUS_EXPR;\n@@ -332,8 +332,8 @@ build_up_reference (tree type, tree arg, int flags, tree decl)\n \n   if ((flags & LOOKUP_PROTECT)\n       && TYPE_MAIN_VARIANT (argtype) != TYPE_MAIN_VARIANT (target_type)\n-      && IS_AGGR_TYPE (argtype)\n-      && IS_AGGR_TYPE (target_type))\n+      && MAYBE_CLASS_TYPE_P (argtype)\n+      && MAYBE_CLASS_TYPE_P (target_type))\n     {\n       /* We go through lookup_base for the access control.  */\n       tree binfo = lookup_base (argtype, target_type, ba_check, NULL);\n@@ -418,7 +418,7 @@ convert_to_reference (tree reftype, tree expr, int convtype,\n \n   can_convert_intype_to_type = can_convert (type, intype);\n   if (!can_convert_intype_to_type\n-      && (convtype & CONV_IMPLICIT) && IS_AGGR_TYPE (intype)\n+      && (convtype & CONV_IMPLICIT) && MAYBE_CLASS_TYPE_P (intype)\n       && ! (flags & LOOKUP_NO_CONVERSION))\n     {\n       /* Look for a user-defined conversion to lvalue that we can use.  */\n@@ -530,7 +530,7 @@ convert_from_reference (tree val)\n tree\n force_rvalue (tree expr)\n {\n-  if (IS_AGGR_TYPE (TREE_TYPE (expr)) && TREE_CODE (expr) != TARGET_EXPR)\n+  if (MAYBE_CLASS_TYPE_P (TREE_TYPE (expr)) && TREE_CODE (expr) != TARGET_EXPR)\n     expr = ocp_convert (TREE_TYPE (expr), expr,\n \t\t\tCONV_IMPLICIT|CONV_FORCE_TEMP, LOOKUP_NORMAL);\n   else\n@@ -596,7 +596,7 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n \n   e = integral_constant_value (e);\n \n-  if (IS_AGGR_TYPE (type) && (convtype & CONV_FORCE_TEMP))\n+  if (MAYBE_CLASS_TYPE_P (type) && (convtype & CONV_FORCE_TEMP))\n     /* We need a new temporary; don't take this shortcut.  */;\n   else if (same_type_ignoring_top_level_qualifiers_p (type, TREE_TYPE (e)))\n     {\n@@ -651,7 +651,7 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n \t  if (!flag_permissive)\n \t    return error_mark_node;\n \t}\n-      if (IS_AGGR_TYPE (intype))\n+      if (MAYBE_CLASS_TYPE_P (intype))\n \t{\n \t  tree rval;\n \t  rval = build_type_conversion (type, e);\n@@ -671,7 +671,7 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n   if (code == VECTOR_TYPE)\n     {\n       tree in_vtype = TREE_TYPE (e);\n-      if (IS_AGGR_TYPE (in_vtype))\n+      if (MAYBE_CLASS_TYPE_P (in_vtype))\n \t{\n \t  tree ret_val;\n \t  ret_val = build_type_conversion (type, e);\n@@ -685,7 +685,7 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n     }\n   if (code == REAL_TYPE || code == COMPLEX_TYPE)\n     {\n-      if (IS_AGGR_TYPE (TREE_TYPE (e)))\n+      if (MAYBE_CLASS_TYPE_P (TREE_TYPE (e)))\n \t{\n \t  tree rval;\n \t  rval = build_type_conversion (type, e);\n@@ -705,7 +705,7 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n   /* New C++ semantics:  since assignment is now based on\n      memberwise copying,  if the rhs type is derived from the\n      lhs type, then we may still do a conversion.  */\n-  if (IS_AGGR_TYPE_CODE (code))\n+  if (RECORD_OR_UNION_CODE_P (code))\n     {\n       tree dtype = TREE_TYPE (e);\n       tree ctor = NULL_TREE;\n@@ -725,7 +725,7 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n \treturn error_mark_node;\n \n       if ((flags & LOOKUP_ONLYCONVERTING)\n-\t  && ! (IS_AGGR_TYPE (dtype) && DERIVED_FROM_P (type, dtype)))\n+\t  && ! (MAYBE_CLASS_TYPE_P (dtype) && DERIVED_FROM_P (type, dtype)))\n \t/* For copy-initialization, first we create a temp of the proper type\n \t   with a user-defined conversion sequence, then we direct-initialize\n \t   the target with the temp (see [dcl.init]).  */\n@@ -1065,7 +1065,7 @@ build_expr_type_conversion (int desires, tree expr, bool complain)\n   if (basetype == error_mark_node)\n     return error_mark_node;\n \n-  if (! IS_AGGR_TYPE (basetype))\n+  if (! MAYBE_CLASS_TYPE_P (basetype))\n     switch (TREE_CODE (basetype))\n       {\n       case INTEGER_TYPE:"}, {"sha": "8353b9b64c3f44fb87118655d1a7e9f208f3ef4d", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e1e64ec2b978e81924000db7d4009b92bb5a638/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e1e64ec2b978e81924000db7d4009b92bb5a638/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=9e1e64ec2b978e81924000db7d4009b92bb5a638", "patch": "@@ -2891,7 +2891,7 @@ build_typename_type (tree context, tree name, tree fullname,\n   else\n     {\n       /* Build the TYPENAME_TYPE.  */\n-      t = make_aggr_type (TYPENAME_TYPE);\n+      t = cxx_make_type (TYPENAME_TYPE);\n       TYPE_CONTEXT (t) = ti.scope;\n       TYPENAME_TYPE_FULLNAME (t) = ti.template_id;\n       TYPENAME_IS_ENUM_P (t) = ti.enum_p;\n@@ -2979,7 +2979,7 @@ make_typename_type (tree context, tree name, enum tag_types tag_type,\n   if (dependent_type_p (context))\n     return build_typename_type (context, name, fullname, tag_type);\n \n-  if (!IS_AGGR_TYPE (context))\n+  if (!MAYBE_CLASS_TYPE_P (context))\n     {\n       if (complain & tf_error)\n \terror (\"%q#T is not a class\", context);\n@@ -3056,7 +3056,7 @@ make_unbound_class_template (tree context, tree name, tree parm_list,\n     {\n       tree tmpl = NULL_TREE;\n \n-      if (IS_AGGR_TYPE (context))\n+      if (MAYBE_CLASS_TYPE_P (context))\n \ttmpl = lookup_field (context, name, 0, false);\n \n       if (!tmpl || !DECL_CLASS_TEMPLATE_P (tmpl))\n@@ -3084,7 +3084,7 @@ make_unbound_class_template (tree context, tree name, tree parm_list,\n     }\n \n   /* Build the UNBOUND_CLASS_TEMPLATE.  */\n-  t = make_aggr_type (UNBOUND_CLASS_TEMPLATE);\n+  t = cxx_make_type (UNBOUND_CLASS_TEMPLATE);\n   TYPE_CONTEXT (t) = FROB_CONTEXT (context);\n   TREE_TYPE (t) = NULL_TREE;\n   SET_TYPE_STRUCTURAL_EQUALITY (t);\n@@ -3382,7 +3382,7 @@ cxx_init_decl_processing (void)\n \n     push_namespace (std_identifier);\n     bad_alloc_id = get_identifier (\"bad_alloc\");\n-    bad_alloc_type_node = make_aggr_type (RECORD_TYPE);\n+    bad_alloc_type_node = make_class_type (RECORD_TYPE);\n     TYPE_CONTEXT (bad_alloc_type_node) = current_namespace;\n     bad_alloc_decl\n       = create_implicit_typedef (bad_alloc_id, bad_alloc_type_node);\n@@ -3773,15 +3773,15 @@ check_tag_decl (cp_decl_specifier_seq *declspecs)\n   if (declspecs->type\n       && TYPE_P (declspecs->type)\n       && ((TREE_CODE (declspecs->type) != TYPENAME_TYPE\n-\t   && IS_AGGR_TYPE (declspecs->type))\n+\t   && MAYBE_CLASS_TYPE_P (declspecs->type))\n \t  || TREE_CODE (declspecs->type) == ENUMERAL_TYPE))\n     declared_type = declspecs->type;\n   else if (declspecs->type == error_mark_node)\n     error_p = true;\n   if (declared_type == NULL_TREE && ! saw_friend && !error_p)\n     pedwarn (\"declaration does not declare anything\");\n   /* Check for an anonymous union.  */\n-  else if (declared_type && IS_AGGR_TYPE_CODE (TREE_CODE (declared_type))\n+  else if (declared_type && RECORD_OR_UNION_CODE_P (TREE_CODE (declared_type))\n \t   && TYPE_ANONYMOUS_P (declared_type))\n     {\n       /* 7/3 In a simple-declaration, the optional init-declarator-list\n@@ -3910,7 +3910,7 @@ groktypename (cp_decl_specifier_seq *type_specifiers,\n       if (CLASS_TYPE_P (type))\n \twarning (OPT_Wattributes, \"ignoring attributes applied to class type %qT \"\n \t\t \"outside of definition\", type);\n-      else if (IS_AGGR_TYPE (type))\n+      else if (MAYBE_CLASS_TYPE_P (type))\n \t/* A template type parameter or other dependent type.  */\n \twarning (OPT_Wattributes, \"ignoring attributes applied to dependent \"\n \t\t \"type %qT without an associated declaration\", type);\n@@ -4174,7 +4174,7 @@ start_decl_1 (tree decl, bool initialized)\n \n   type = TREE_TYPE (decl);\n   complete_p = COMPLETE_TYPE_P (type);\n-  aggregate_definition_p = IS_AGGR_TYPE (type) && !DECL_EXTERNAL (decl);\n+  aggregate_definition_p = MAYBE_CLASS_TYPE_P (type) && !DECL_EXTERNAL (decl);\n \n   /* If an explicit initializer is present, or if this is a definition\n      of an aggregate, then we need a complete type at this point.\n@@ -4427,7 +4427,7 @@ layout_var_decl (tree decl)\n   /* Keep this code around in case we later want to control debug info\n      based on whether a type is \"used\".  (jason 1999-11-11) */\n \n-  else if (!DECL_EXTERNAL (decl) && IS_AGGR_TYPE (ttype))\n+  else if (!DECL_EXTERNAL (decl) && MAYBE_CLASS_TYPE_P (ttype))\n     /* Let debugger know it should output info for this type.  */\n     note_debug_info_needed (ttype);\n \n@@ -5054,7 +5054,7 @@ check_initializer (tree decl, tree init, int flags, tree *cleanup)\n     ;\n   else if (TYPE_P (type) && TYPE_NEEDS_CONSTRUCTING (type))\n     goto initialize_aggr;\n-  else if (IS_AGGR_TYPE (type))\n+  else if (MAYBE_CLASS_TYPE_P (type))\n     {\n       tree core_type = strip_array_types (type);\n \n@@ -5450,7 +5450,7 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n   if (TREE_CODE (decl) == TYPE_DECL)\n     {\n       if (type != error_mark_node\n-\t  && IS_AGGR_TYPE (type) && DECL_NAME (decl))\n+\t  && MAYBE_CLASS_TYPE_P (type) && DECL_NAME (decl))\n \t{\n \t  if (TREE_TYPE (DECL_NAME (decl)) && TREE_TYPE (decl) != type)\n \t    warning (0, \"shadowing previous type declaration of %q#D\", decl);\n@@ -5504,7 +5504,7 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n \t     is *not* defined.  */\n \t  && (!DECL_EXTERNAL (decl) || init))\n \t{\n-\t  if (TYPE_FOR_JAVA (type) && IS_AGGR_TYPE (type))\n+\t  if (TYPE_FOR_JAVA (type) && MAYBE_CLASS_TYPE_P (type))\n \t    {\n \t      tree jclass\n \t\t= IDENTIFIER_GLOBAL_VALUE (get_identifier (\"jclass\"));\n@@ -5589,7 +5589,7 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n \tlayout_type (type);\n     }\n   else if (TREE_CODE (decl) == FIELD_DECL\n-\t   && TYPE_FOR_JAVA (type) && IS_AGGR_TYPE (type))\n+\t   && TYPE_FOR_JAVA (type) && MAYBE_CLASS_TYPE_P (type))\n     error (\"non-static data member %qD has Java class type\", decl);\n \n   /* Add this declaration to the statement-tree.  This needs to happen\n@@ -6854,13 +6854,13 @@ build_ptrmemfunc_type (tree type)\n     unqualified_variant\n       = build_ptrmemfunc_type (TYPE_MAIN_VARIANT (type));\n \n-  t = make_aggr_type (RECORD_TYPE);\n+  t = make_class_type (RECORD_TYPE);\n   xref_basetypes (t, NULL_TREE);\n \n   /* Let the front end know this is a pointer to member function...  */\n   TYPE_PTRMEMFUNC_FLAG (t) = 1;\n-  /* ... and not really an aggregate.  */\n-  SET_IS_AGGR_TYPE (t, 0);\n+  /* ... and not really a class type.  */\n+  SET_CLASS_TYPE_P (t, 0);\n \n   field = build_decl (FIELD_DECL, pfn_identifier, type);\n   fields = field;\n@@ -9383,7 +9383,7 @@ grokparms (cp_parameter_declarator *first_parm, tree *parms)\n \n       if (type != error_mark_node\n \t  && TYPE_FOR_JAVA (type)\n-\t  && IS_AGGR_TYPE (type))\n+\t  && MAYBE_CLASS_TYPE_P (type))\n \t{\n \t  error (\"parameter %qD has Java class type\", decl);\n \t  type = error_mark_node;\n@@ -9831,10 +9831,11 @@ grok_op_properties (tree decl, bool complain)\n \t\t  if (arg == error_mark_node)\n \t\t    return false;\n \n-\t\t  /* IS_AGGR_TYPE, rather than CLASS_TYPE_P, is used\n+\t\t  /* MAYBE_CLASS_TYPE_P, rather than CLASS_TYPE_P, is used\n \t\t     because these checks are performed even on\n \t\t     template functions.  */\n-\t\t  if (IS_AGGR_TYPE (arg) || TREE_CODE (arg) == ENUMERAL_TYPE)\n+\t\t  if (MAYBE_CLASS_TYPE_P (arg)\n+\t\t      || TREE_CODE (arg) == ENUMERAL_TYPE)\n \t\t    break;\n \t\t}\n \n@@ -9875,7 +9876,7 @@ grok_op_properties (tree decl, bool complain)\n \t      if (t == class_type)\n \t\twhat = \"the same type\";\n \t      /* Don't force t to be complete here.  */\n-\t      else if (IS_AGGR_TYPE (t)\n+\t      else if (MAYBE_CLASS_TYPE_P (t)\n \t\t       && COMPLETE_TYPE_P (t)\n \t\t       && DERIVED_FROM_P (t, class_type))\n \t\twhat = \"a base class\";\n@@ -10349,14 +10350,14 @@ xref_tag (enum tag_types tag_code, tree name,\n \t}\n       else\n \t{\n-\t  t = make_aggr_type (code);\n+\t  t = make_class_type (code);\n \t  TYPE_CONTEXT (t) = context;\n \t  t = pushtag (name, t, scope);\n \t}\n     }\n   else\n     {\n-      if (template_header_p && IS_AGGR_TYPE (t))\n+      if (template_header_p && MAYBE_CLASS_TYPE_P (t))\n         {\n \t  if (!redeclare_class_template (t, current_template_parms))\n             POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n@@ -10983,7 +10984,7 @@ check_function_type (tree decl, tree current_function_parms)\n   if (dependent_type_p (return_type))\n     return;\n   if (!COMPLETE_OR_VOID_TYPE_P (return_type)\n-      || (TYPE_FOR_JAVA (return_type) && IS_AGGR_TYPE (return_type)))\n+      || (TYPE_FOR_JAVA (return_type) && MAYBE_CLASS_TYPE_P (return_type)))\n     {\n       tree args = TYPE_ARG_TYPES (fntype);\n "}, {"sha": "367d9eba26b31131dda78e37e96fc7ea90d6f7f0", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e1e64ec2b978e81924000db7d4009b92bb5a638/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e1e64ec2b978e81924000db7d4009b92bb5a638/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=9e1e64ec2b978e81924000db7d4009b92bb5a638", "patch": "@@ -308,7 +308,7 @@ grok_array_decl (tree array_expr, tree index_exp)\n   type = non_reference (type);\n \n   /* If they have an `operator[]', use that.  */\n-  if (IS_AGGR_TYPE (type) || IS_AGGR_TYPE (TREE_TYPE (index_exp)))\n+  if (MAYBE_CLASS_TYPE_P (type) || MAYBE_CLASS_TYPE_P (TREE_TYPE (index_exp)))\n     expr = build_new_op (ARRAY_REF, LOOKUP_NORMAL,\n \t\t\t array_expr, index_exp, NULL_TREE,\n \t\t\t /*overloaded_p=*/NULL);\n@@ -443,7 +443,7 @@ check_member_template (tree tmpl)\n \n   if (TREE_CODE (decl) == FUNCTION_DECL\n       || (TREE_CODE (decl) == TYPE_DECL\n-\t  && IS_AGGR_TYPE (TREE_TYPE (decl))))\n+\t  && MAYBE_CLASS_TYPE_P (TREE_TYPE (decl))))\n     {\n       /* The parser rejects template declarations in local classes.  */\n       gcc_assert (!current_function_decl);\n@@ -2029,7 +2029,7 @@ constrain_class_visibility (tree type)\n %qT has a field %qD whose type uses the anonymous namespace\",\n \t\t       type, t);\n \t  }\n-\telse if (IS_AGGR_TYPE (ftype)\n+\telse if (MAYBE_CLASS_TYPE_P (ftype)\n \t\t && vis < VISIBILITY_HIDDEN\n \t\t && subvis >= VISIBILITY_HIDDEN)\n \t  warning (OPT_Wattributes, \"\\"}, {"sha": "5ca10fca2a1167e10ae88d99a8262be3632cdc4a", "filename": "gcc/cp/dump.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e1e64ec2b978e81924000db7d4009b92bb5a638/gcc%2Fcp%2Fdump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e1e64ec2b978e81924000db7d4009b92bb5a638/gcc%2Fcp%2Fdump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdump.c?ref=9e1e64ec2b978e81924000db7d4009b92bb5a638", "patch": "@@ -1,5 +1,5 @@\n /* Tree-dumping functionality for intermediate representation.\n-   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007\n+   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008\n    Free Software Foundation, Inc.\n    Written by Mark Mitchell <mark@codesourcery.com>\n \n@@ -257,7 +257,7 @@ cp_dump_tree (void* dump_info, tree t)\n \t  return true;\n \t}\n \n-      if (! IS_AGGR_TYPE (t))\n+      if (! MAYBE_CLASS_TYPE_P (t))\n \tbreak;\n \n       dump_child (\"vfld\", TYPE_VFIELD (t));"}, {"sha": "a4c5e39a4853775beca1fa10cad98184fe4febd3", "filename": "gcc/cp/friend.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e1e64ec2b978e81924000db7d4009b92bb5a638/gcc%2Fcp%2Ffriend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e1e64ec2b978e81924000db7d4009b92bb5a638/gcc%2Fcp%2Ffriend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ffriend.c?ref=9e1e64ec2b978e81924000db7d4009b92bb5a638", "patch": "@@ -1,6 +1,6 @@\n /* Help friends in C++.\n    Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,\n-   2007  Free Software Foundation, Inc.\n+   2007, 2008  Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -227,7 +227,7 @@ make_friend_class (tree type, tree friend_type, bool complain)\n   int class_template_depth = template_class_depth (type);\n   int friend_depth = processing_template_decl - class_template_depth;\n \n-  if (! IS_AGGR_TYPE (friend_type))\n+  if (! MAYBE_CLASS_TYPE_P (friend_type))\n     {\n       error (\"invalid type %qT declared %<friend%>\", friend_type);\n       return;\n@@ -408,7 +408,7 @@ do_friend (tree ctype, tree declarator, tree decl,\n \t   bool funcdef_flag)\n {\n   gcc_assert (TREE_CODE (decl) == FUNCTION_DECL);\n-  gcc_assert (!ctype || IS_AGGR_TYPE (ctype));\n+  gcc_assert (!ctype || MAYBE_CLASS_TYPE_P (ctype));\n \n   /* Every decl that gets here is a friend of something.  */\n   DECL_FRIEND_P (decl) = 1;"}, {"sha": "e0700eacb4f056411e945ba0f6c5f7aed4999507", "filename": "gcc/cp/init.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e1e64ec2b978e81924000db7d4009b92bb5a638/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e1e64ec2b978e81924000db7d4009b92bb5a638/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=9e1e64ec2b978e81924000db7d4009b92bb5a638", "patch": "@@ -1420,19 +1420,19 @@ expand_aggr_init_1 (tree binfo, tree true_exp, tree exp, tree init, int flags)\n   expand_default_init (binfo, true_exp, exp, init, flags);\n }\n \n-/* Report an error if TYPE is not a user-defined, aggregate type.  If\n+/* Report an error if TYPE is not a user-defined, class type.  If\n    OR_ELSE is nonzero, give an error message.  */\n \n int\n-is_aggr_type (tree type, int or_else)\n+is_class_type (tree type, int or_else)\n {\n   if (type == error_mark_node)\n     return 0;\n \n-  if (! IS_AGGR_TYPE (type))\n+  if (! CLASS_TYPE_P (type))\n     {\n       if (or_else)\n-\terror (\"%qT is not an aggregate type\", type);\n+\terror (\"%qT is not a class type\", type);\n       return 0;\n     }\n   return 1;\n@@ -1476,7 +1476,7 @@ build_offset_ref (tree type, tree member, bool address_p)\n \t\t\t\t /*template_p=*/false);\n \n   gcc_assert (TYPE_P (type));\n-  if (! is_aggr_type (type, 1))\n+  if (! is_class_type (type, 1))\n     return error_mark_node;\n \n   gcc_assert (DECL_P (member) || BASELINK_P (member));\n@@ -1921,7 +1921,7 @@ build_new_1 (tree placement, tree type, tree nelts, tree init,\n \t\t    (alloc_fn,\n \t\t     build_tree_list (NULL_TREE, class_addr)));\n     }\n-  else if (TYPE_FOR_JAVA (elt_type) && IS_AGGR_TYPE (elt_type))\n+  else if (TYPE_FOR_JAVA (elt_type) && MAYBE_CLASS_TYPE_P (elt_type))\n     {\n       error (\"Java class %q#T object allocated using placement new\", elt_type);\n       return error_mark_node;\n@@ -2456,7 +2456,7 @@ build_vec_delete_1 (tree base, tree maxindex, tree type,\n   /* We should only have 1-D arrays here.  */\n   gcc_assert (TREE_CODE (type) != ARRAY_TYPE);\n \n-  if (! IS_AGGR_TYPE (type) || TYPE_HAS_TRIVIAL_DESTRUCTOR (type))\n+  if (! MAYBE_CLASS_TYPE_P (type) || TYPE_HAS_TRIVIAL_DESTRUCTOR (type))\n     goto no_destructor;\n \n   /* The below is short by the cookie size.  */\n@@ -2736,7 +2736,7 @@ build_vec_init (tree base, tree maxindex, tree init,\n \t  num_initialized_elts++;\n \n \t  current_stmt_tree ()->stmts_are_full_exprs_p = 1;\n-\t  if (IS_AGGR_TYPE (type) || TREE_CODE (type) == ARRAY_TYPE)\n+\t  if (MAYBE_CLASS_TYPE_P (type) || TREE_CODE (type) == ARRAY_TYPE)\n \t    finish_expr_stmt (build_aggr_init (baseref, elt, 0));\n \t  else\n \t    finish_expr_stmt (build_modify_expr (baseref, NOP_EXPR,\n@@ -2967,7 +2967,7 @@ build_delete (tree type, tree addr, special_function_kind auto_delete,\n \t      complete_p = false;\n \t    }\n \t}\n-      if (VOID_TYPE_P (type) || !complete_p || !IS_AGGR_TYPE (type))\n+      if (VOID_TYPE_P (type) || !complete_p || !MAYBE_CLASS_TYPE_P (type))\n \t/* Call the builtin operator delete.  */\n \treturn build_builtin_delete_call (addr);\n       if (TREE_SIDE_EFFECTS (addr))\n@@ -3000,7 +3000,7 @@ build_delete (tree type, tree addr, special_function_kind auto_delete,\n       addr = convert_force (build_pointer_type (type), addr, 0);\n     }\n \n-  gcc_assert (IS_AGGR_TYPE (type));\n+  gcc_assert (MAYBE_CLASS_TYPE_P (type));\n \n   if (TYPE_HAS_TRIVIAL_DESTRUCTOR (type))\n     {"}, {"sha": "adf793b1d4269fbef3bd5bb34046f2c0f18fb65a", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e1e64ec2b978e81924000db7d4009b92bb5a638/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e1e64ec2b978e81924000db7d4009b92bb5a638/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=9e1e64ec2b978e81924000db7d4009b92bb5a638", "patch": "@@ -801,7 +801,7 @@ cxx_make_type (enum tree_code code)\n   tree t = make_node (code);\n \n   /* Create lang_type structure.  */\n-  if (IS_AGGR_TYPE_CODE (code)\n+  if (RECORD_OR_UNION_CODE_P (code)\n       || code == BOUND_TEMPLATE_TEMPLATE_PARM)\n     {\n       struct lang_type *pi = GGC_CNEW (struct lang_type);\n@@ -816,7 +816,7 @@ cxx_make_type (enum tree_code code)\n     }\n \n   /* Set up some flags that give proper default behavior.  */\n-  if (IS_AGGR_TYPE_CODE (code))\n+  if (RECORD_OR_UNION_CODE_P (code))\n     {\n       struct c_fileinfo *finfo = get_fileinfo (input_filename);\n       SET_CLASSTYPE_INTERFACE_UNKNOWN_X (t, finfo->interface_unknown);\n@@ -827,13 +827,10 @@ cxx_make_type (enum tree_code code)\n }\n \n tree\n-make_aggr_type (enum tree_code code)\n+make_class_type (enum tree_code code)\n {\n   tree t = cxx_make_type (code);\n-\n-  if (IS_AGGR_TYPE_CODE (code))\n-    SET_IS_AGGR_TYPE (t, 1);\n-\n+  SET_CLASS_TYPE_P (t, 1);\n   return t;\n }\n "}, {"sha": "c8061bbc6b82ff07f54fa85e6470e041f97d3191", "filename": "gcc/cp/method.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e1e64ec2b978e81924000db7d4009b92bb5a638/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e1e64ec2b978e81924000db7d4009b92bb5a638/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=9e1e64ec2b978e81924000db7d4009b92bb5a638", "patch": "@@ -1,7 +1,7 @@\n /* Handle the hair of processing (but not expanding) inline functions.\n    Also manage function and variable name overloading.\n    Copyright (C) 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008\n    Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com)\n \n@@ -507,7 +507,7 @@ use_thunk (tree thunk_fndecl, bool emit_p)\n \t\tt = build3 (COND_EXPR, TREE_TYPE (t), cond, t,\n \t\t\t    cp_convert (TREE_TYPE (t), integer_zero_node));\n \t    }\n-\t  if (IS_AGGR_TYPE (TREE_TYPE (t)))\n+\t  if (MAYBE_CLASS_TYPE_P (TREE_TYPE (t)))\n \t    t = build_cplus_new (TREE_TYPE (t), t);\n \t  finish_return_stmt (t);\n \t}"}, {"sha": "75bc6bd47b28bc7256af6f8cc816fd55ce91ca96", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e1e64ec2b978e81924000db7d4009b92bb5a638/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e1e64ec2b978e81924000db7d4009b92bb5a638/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=9e1e64ec2b978e81924000db7d4009b92bb5a638", "patch": "@@ -1737,7 +1737,7 @@ constructor_name_p (tree name, tree type)\n {\n   tree ctor_name;\n \n-  gcc_assert (IS_AGGR_TYPE (type));\n+  gcc_assert (MAYBE_CLASS_TYPE_P (type));\n \n   if (!name)\n     return false;\n@@ -1916,7 +1916,7 @@ push_overloaded_decl (tree decl, int flags, bool is_friend)\n       if (TREE_CODE (old) == TYPE_DECL && DECL_ARTIFICIAL (old))\n \t{\n \t  tree t = TREE_TYPE (old);\n-\t  if (IS_AGGR_TYPE (t) && warn_shadow\n+\t  if (MAYBE_CLASS_TYPE_P (t) && warn_shadow\n \t      && (! DECL_IN_SYSTEM_HEADER (decl)\n \t\t  || ! DECL_IN_SYSTEM_HEADER (old)))\n \t    warning (OPT_Wshadow, \"%q#D hides constructor for %q#T\", decl, t);\n@@ -2826,7 +2826,7 @@ do_class_using_decl (tree scope, tree name)\n       error (\"%<%T::%D%> names destructor\", scope, name);\n       return NULL_TREE;\n     }\n-  if (IS_AGGR_TYPE (scope) && constructor_name_p (name, scope))\n+  if (MAYBE_CLASS_TYPE_P (scope) && constructor_name_p (name, scope))\n     {\n       error (\"%<%T::%D%> names constructor\", scope, name);\n       return NULL_TREE;\n@@ -3765,7 +3765,7 @@ lookup_qualified_name (tree scope, tree name, bool is_type_p, bool complain)\n       if (qualified_lookup_using_namespace (name, scope, &binding, flags))\n \tt = binding.value;\n     }\n-  else if (is_aggr_type (scope, complain))\n+  else if (is_class_type (scope, complain))\n     t = lookup_member (scope, name, 2, is_type_p);\n \n   if (!t)\n@@ -4826,7 +4826,8 @@ maybe_process_template_type_declaration (tree type, int is_friend,\n     ;\n   else\n     {\n-      gcc_assert (IS_AGGR_TYPE (type) || TREE_CODE (type) == ENUMERAL_TYPE);\n+      gcc_assert (MAYBE_CLASS_TYPE_P (type)\n+\t\t  || TREE_CODE (type) == ENUMERAL_TYPE);\n \n       if (processing_template_decl)\n \t{"}, {"sha": "8156822f62688ebe1d072a9b27f7e48449f0bbfb", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e1e64ec2b978e81924000db7d4009b92bb5a638/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e1e64ec2b978e81924000db7d4009b92bb5a638/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=9e1e64ec2b978e81924000db7d4009b92bb5a638", "patch": "@@ -14224,7 +14224,7 @@ cp_parser_class_name (cp_parser *parser,\n     }\n   else if (TREE_CODE (decl) != TYPE_DECL\n \t   || TREE_TYPE (decl) == error_mark_node\n-\t   || !IS_AGGR_TYPE (TREE_TYPE (decl)))\n+\t   || !MAYBE_CLASS_TYPE_P (TREE_TYPE (decl)))\n     decl = error_mark_node;\n \n   if (decl == error_mark_node)"}, {"sha": "628a445a58eff2923fa0002159b4004b197b3b7a", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e1e64ec2b978e81924000db7d4009b92bb5a638/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e1e64ec2b978e81924000db7d4009b92bb5a638/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=9e1e64ec2b978e81924000db7d4009b92bb5a638", "patch": "@@ -238,7 +238,7 @@ finish_member_template_decl (tree decl)\n       type = TREE_TYPE (decl);\n       if (type == error_mark_node)\n \treturn error_mark_node;\n-      if (IS_AGGR_TYPE (type)\n+      if (MAYBE_CLASS_TYPE_P (type)\n \t  && CLASSTYPE_TEMPLATE_INFO (type)\n \t  && !CLASSTYPE_TEMPLATE_SPECIALIZATION (type))\n \t{\n@@ -3041,7 +3041,7 @@ process_template_parm (tree list, tree parm, bool is_non_type,\n \n       if (parm && TREE_CODE (parm) == TEMPLATE_DECL)\n \t{\n-\t  t = make_aggr_type (TEMPLATE_TEMPLATE_PARM);\n+\t  t = cxx_make_type (TEMPLATE_TEMPLATE_PARM);\n \t  /* This is for distinguishing between real templates and template\n \t     template parameters */\n \t  TREE_TYPE (parm) = t;\n@@ -3050,7 +3050,7 @@ process_template_parm (tree list, tree parm, bool is_non_type,\n \t}\n       else\n \t{\n-\t  t = make_aggr_type (TEMPLATE_TYPE_PARM);\n+\t  t = cxx_make_type (TEMPLATE_TYPE_PARM);\n \t  /* parm is either IDENTIFIER_NODE or NULL_TREE.  */\n \t  decl = build_decl (TYPE_DECL, parm, t);\n \t}\n@@ -5473,7 +5473,7 @@ lookup_template_class (tree d1,\n       if (template)\n \tcontext = DECL_CONTEXT (template);\n     }\n-  else if (TREE_CODE (d1) == TYPE_DECL && IS_AGGR_TYPE (TREE_TYPE (d1)))\n+  else if (TREE_CODE (d1) == TYPE_DECL && MAYBE_CLASS_TYPE_P (TREE_TYPE (d1)))\n     {\n       tree type = TREE_TYPE (d1);\n \n@@ -5489,7 +5489,7 @@ lookup_template_class (tree d1,\n \t}\n     }\n   else if (TREE_CODE (d1) == ENUMERAL_TYPE\n-\t   || (TYPE_P (d1) && IS_AGGR_TYPE (d1)))\n+\t   || (TYPE_P (d1) && MAYBE_CLASS_TYPE_P (d1)))\n     {\n       template = TYPE_TI_TEMPLATE (d1);\n       d1 = DECL_NAME (template);\n@@ -5762,7 +5762,7 @@ lookup_template_class (tree d1,\n \t}\n       else\n \t{\n-\t  t = make_aggr_type (TREE_CODE (template_type));\n+\t  t = make_class_type (TREE_CODE (template_type));\n \t  CLASSTYPE_DECLARED_CLASS (t)\n \t    = CLASSTYPE_DECLARED_CLASS (template_type);\n \t  SET_CLASSTYPE_IMPLICIT_INSTANTIATION (t);\n@@ -8673,7 +8673,7 @@ tsubst_function_type (tree t,\n   else\n     {\n       tree r = TREE_TYPE (TREE_VALUE (arg_types));\n-      if (! IS_AGGR_TYPE (r))\n+      if (! MAYBE_CLASS_TYPE_P (r))\n \t{\n \t  /* [temp.deduct]\n \n@@ -9202,7 +9202,7 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n     case OFFSET_TYPE:\n       {\n \tr = tsubst (TYPE_OFFSET_BASETYPE (t), args, complain, in_decl);\n-\tif (r == error_mark_node || !IS_AGGR_TYPE (r))\n+\tif (r == error_mark_node || !MAYBE_CLASS_TYPE_P (r))\n \t  {\n \t    /* [temp.deduct]\n \n@@ -9345,7 +9345,7 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \tif (ctx == error_mark_node || f == error_mark_node)\n \t  return error_mark_node;\n \n-\tif (!IS_AGGR_TYPE (ctx))\n+\tif (!MAYBE_CLASS_TYPE_P (ctx))\n \t  {\n \t    if (complain & tf_error)\n \t      error (\"%qT is not a class, struct, or union type\", ctx);\n@@ -11211,7 +11211,7 @@ tsubst_copy_and_build (tree t,\n \t/* We do not want to process the index of aggregate\n \t   initializers as they are identifier nodes which will be\n \t   looked up by digest_init.  */\n-\tprocess_index_p = !(type && IS_AGGR_TYPE (type));\n+\tprocess_index_p = !(type && MAYBE_CLASS_TYPE_P (type));\n \n \tn = VEC_copy (constructor_elt, gc, CONSTRUCTOR_ELTS (t));\n         newlen = VEC_length (constructor_elt, n);\n@@ -12325,7 +12325,7 @@ get_template_base (tree tparms, tree targs, tree parm, tree arg)\n   tree rval = NULL_TREE;\n   tree binfo;\n \n-  gcc_assert (IS_AGGR_TYPE_CODE (TREE_CODE (arg)));\n+  gcc_assert (RECORD_OR_UNION_CODE_P (TREE_CODE (arg)));\n \n   binfo = TYPE_BINFO (complete_type (arg));\n   if (!binfo)\n@@ -14317,7 +14317,7 @@ bt_instantiate_type_proc (binding_entry entry, void *data)\n {\n   tree storage = *(tree *) data;\n \n-  if (IS_AGGR_TYPE (entry->type)\n+  if (MAYBE_CLASS_TYPE_P (entry->type)\n       && !uses_template_parms (CLASSTYPE_TI_ARGS (entry->type)))\n     do_type_instantiation (TYPE_MAIN_DECL (entry->type), storage, 0);\n }"}, {"sha": "8bd51c80a207148089e65517b3fe4261273de2a3", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e1e64ec2b978e81924000db7d4009b92bb5a638/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e1e64ec2b978e81924000db7d4009b92bb5a638/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=9e1e64ec2b978e81924000db7d4009b92bb5a638", "patch": "@@ -503,7 +503,7 @@ build_dynamic_cast_1 (tree type, tree expr)\n \tbreak;\n       /* Fall through.  */\n     case REFERENCE_TYPE:\n-      if (! IS_AGGR_TYPE (TREE_TYPE (type)))\n+      if (! MAYBE_CLASS_TYPE_P (TREE_TYPE (type)))\n \t{\n \t  errstr = \"target is not pointer or reference to class\";\n \t  goto fail;\n@@ -530,7 +530,7 @@ build_dynamic_cast_1 (tree type, tree expr)\n \t  errstr = \"source is not a pointer\";\n \t  goto fail;\n \t}\n-      if (! IS_AGGR_TYPE (TREE_TYPE (exprtype)))\n+      if (! MAYBE_CLASS_TYPE_P (TREE_TYPE (exprtype)))\n \t{\n \t  errstr = \"source is not a pointer to class\";\n \t  goto fail;\n@@ -548,7 +548,7 @@ build_dynamic_cast_1 (tree type, tree expr)\n       /* T is a reference type, v shall be an lvalue of a complete class\n \t type, and the result is an lvalue of the type referred to by T.  */\n \n-      if (! IS_AGGR_TYPE (TREE_TYPE (exprtype)))\n+      if (! MAYBE_CLASS_TYPE_P (TREE_TYPE (exprtype)))\n \t{\n \t  errstr = \"source is not of class type\";\n \t  goto fail;\n@@ -1167,7 +1167,7 @@ create_pseudo_type_info (int tk, const char *real_name, ...)\n     }\n \n   /* Create the pseudo type.  */\n-  pseudo_type = make_aggr_type (RECORD_TYPE);\n+  pseudo_type = make_class_type (RECORD_TYPE);\n   finish_builtin_struct (pseudo_type, pseudo_name, fields, NULL_TREE);\n   CLASSTYPE_AS_BASE (pseudo_type) = pseudo_type;\n \n@@ -1326,7 +1326,7 @@ create_tinfo_types (void)\n     fields = field;\n \n     ti = VEC_index (tinfo_s, tinfo_descs, TK_TYPE_INFO_TYPE);\n-    ti->type = make_aggr_type (RECORD_TYPE);\n+    ti->type = make_class_type (RECORD_TYPE);\n     ti->vtable = NULL_TREE;\n     ti->name = NULL_TREE;\n     finish_builtin_struct (ti->type, \"__type_info_pseudo\",\n@@ -1364,7 +1364,7 @@ create_tinfo_types (void)\n \n     ti = VEC_index (tinfo_s, tinfo_descs, TK_BASE_TYPE);\n \n-    ti->type = make_aggr_type (RECORD_TYPE);\n+    ti->type = make_class_type (RECORD_TYPE);\n     ti->vtable = NULL_TREE;\n     ti->name = NULL_TREE;\n     finish_builtin_struct (ti->type, \"__base_class_type_info_pseudo\","}, {"sha": "cee29240e9e5fa135af33a8f4d2d6b366e933f17", "filename": "gcc/cp/search.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e1e64ec2b978e81924000db7d4009b92bb5a638/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e1e64ec2b978e81924000db7d4009b92bb5a638/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=9e1e64ec2b978e81924000db7d4009b92bb5a638", "patch": "@@ -1,7 +1,8 @@\n /* Breadth-first and depth-first routines for\n    searching multiple-inheritance lattice for GNU C++.\n    Copyright (C) 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2002, 2003, 2004, 2005, 2007 Free Software Foundation, Inc.\n+   1999, 2000, 2002, 2003, 2004, 2005, 2007, 2008\n+   Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com)\n \n This file is part of GCC.\n@@ -1212,7 +1213,7 @@ lookup_member (tree xbasetype, tree name, int protect, bool want_type)\n     }\n   else\n     {\n-      if (!IS_AGGR_TYPE_CODE (TREE_CODE (xbasetype)))\n+      if (!RECORD_OR_UNION_CODE_P (TREE_CODE (xbasetype)))\n \treturn NULL_TREE;\n       type = xbasetype;\n       xbasetype = NULL_TREE;"}, {"sha": "74d9ae55af268f0aab276b3d566b2982baf512d7", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e1e64ec2b978e81924000db7d4009b92bb5a638/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e1e64ec2b978e81924000db7d4009b92bb5a638/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=9e1e64ec2b978e81924000db7d4009b92bb5a638", "patch": "@@ -2254,9 +2254,9 @@ begin_class_definition (tree t, tree attributes)\n       t = error_mark_node;\n     }\n \n-  if (t == error_mark_node || ! IS_AGGR_TYPE (t))\n+  if (t == error_mark_node || ! MAYBE_CLASS_TYPE_P (t))\n     {\n-      t = make_aggr_type (RECORD_TYPE);\n+      t = make_class_type (RECORD_TYPE);\n       pushtag (make_anon_name (), t, /*tag_scope=*/ts_current);\n     }\n \n@@ -2265,7 +2265,7 @@ begin_class_definition (tree t, tree attributes)\n \n   if (TYPE_BEING_DEFINED (t))\n     {\n-      t = make_aggr_type (TREE_CODE (t));\n+      t = make_class_type (TREE_CODE (t));\n       pushtag (TYPE_IDENTIFIER (t), t, /*tag_scope=*/ts_current);\n     }\n   maybe_process_partial_specialization (t);\n@@ -2469,8 +2469,11 @@ finish_base_specifier (tree base, tree access, bool virtual_p)\n       error (\"invalid base-class specification\");\n       result = NULL_TREE;\n     }\n-  else if (! is_aggr_type (base, 1))\n-    result = NULL_TREE;\n+  else if (! MAYBE_CLASS_TYPE_P (base))\n+    {\n+      error (\"%qT is not a class type\", base);\n+      result = NULL_TREE;\n+    }\n   else\n     {\n       if (cp_type_quals (base) != 0)\n@@ -2988,7 +2991,7 @@ finish_typeof (tree expr)\n \n   if (type_dependent_expression_p (expr))\n     {\n-      type = make_aggr_type (TYPEOF_TYPE);\n+      type = cxx_make_type (TYPEOF_TYPE);\n       TYPEOF_TYPE_EXPR (type) = expr;\n       SET_TYPE_STRUCTURAL_EQUALITY (type);\n \n@@ -4030,7 +4033,7 @@ cxx_omp_predetermined_sharing (tree decl)\n   if (TREE_STATIC (decl))\n     {\n       tree ctx = CP_DECL_CONTEXT (decl);\n-      if (TYPE_P (ctx) && IS_AGGR_TYPE (ctx))\n+      if (TYPE_P (ctx) && MAYBE_CLASS_TYPE_P (ctx))\n \treturn OMP_CLAUSE_DEFAULT_SHARED;\n     }\n \n@@ -4123,7 +4126,7 @@ finish_decltype_type (tree expr, bool id_expression_or_member_access_p)\n \n   if (type_dependent_expression_p (expr))\n     {\n-      type = make_aggr_type (DECLTYPE_TYPE);\n+      type = cxx_make_type (DECLTYPE_TYPE);\n       DECLTYPE_TYPE_EXPR (type) = expr;\n       DECLTYPE_TYPE_ID_EXPR_OR_MEMBER_ACCESS_P (type)\n         = id_expression_or_member_access_p;"}, {"sha": "927b3de0dea4abcb3f66aee55cb397cd047b28eb", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e1e64ec2b978e81924000db7d4009b92bb5a638/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e1e64ec2b978e81924000db7d4009b92bb5a638/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=9e1e64ec2b978e81924000db7d4009b92bb5a638", "patch": "@@ -1238,7 +1238,7 @@ bind_template_template_parm (tree t, tree newargs)\n   tree decl = TYPE_NAME (t);\n   tree t2;\n \n-  t2 = make_aggr_type (BOUND_TEMPLATE_TEMPLATE_PARM);\n+  t2 = cxx_make_type (BOUND_TEMPLATE_TEMPLATE_PARM);\n   decl = build_decl (TYPE_DECL, DECL_NAME (decl), NULL_TREE);\n \n   /* These nodes have to be created to reflect new TYPE_DECL and template\n@@ -1958,7 +1958,7 @@ error_type (tree arg)\n     ;\n   else if (real_lvalue_p (arg))\n     type = build_reference_type (lvalue_type (arg));\n-  else if (IS_AGGR_TYPE (type))\n+  else if (MAYBE_CLASS_TYPE_P (type))\n     type = lvalue_type (arg);\n \n   return type;"}, {"sha": "036f93efecb4c5b47098b7a72842a6da0b910bea", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e1e64ec2b978e81924000db7d4009b92bb5a638/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e1e64ec2b978e81924000db7d4009b92bb5a638/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=9e1e64ec2b978e81924000db7d4009b92bb5a638", "patch": "@@ -1,6 +1,6 @@\n /* Build expressions with type checking for C++ compiler.\n    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008\n    Free Software Foundation, Inc.\n    Hacked by Michael Tiemann (tiemann@cygnus.com)\n \n@@ -4630,7 +4630,7 @@ unary_complex_lvalue (enum tree_code code, tree arg)\n     if (TREE_CODE (targ) == SAVE_EXPR)\n       targ = TREE_OPERAND (targ, 0);\n \n-    if (TREE_CODE (targ) == CALL_EXPR && IS_AGGR_TYPE (TREE_TYPE (targ)))\n+    if (TREE_CODE (targ) == CALL_EXPR && MAYBE_CLASS_TYPE_P (TREE_TYPE (targ)))\n       {\n \tif (TREE_CODE (arg) == SAVE_EXPR)\n \t  targ = arg;\n@@ -5751,7 +5751,7 @@ build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n \t  TREE_SIDE_EFFECTS (result) = 1;\n \t  return result;\n \t}\n-      else if (! IS_AGGR_TYPE (lhstype))\n+      else if (! MAYBE_CLASS_TYPE_P (lhstype))\n \t/* Do the default thing.  */;\n       else\n \t{\n@@ -5772,7 +5772,7 @@ build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n       if (modifycode == NOP_EXPR)\n \t{\n \t  /* `operator=' is not an inheritable operator.  */\n-\t  if (! IS_AGGR_TYPE (lhstype))\n+\t  if (! MAYBE_CLASS_TYPE_P (lhstype))\n \t    /* Do the default thing.  */;\n \t  else\n \t    {\n@@ -5790,8 +5790,10 @@ build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n \t  /* A binary op has been requested.  Combine the old LHS\n \t     value with the RHS producing the value we should actually\n \t     store into the LHS.  */\n+\t  gcc_assert (!((TREE_CODE (lhstype) == REFERENCE_TYPE\n+\t\t\t && MAYBE_CLASS_TYPE_P (TREE_TYPE (lhstype)))\n+\t\t\t|| MAYBE_CLASS_TYPE_P (lhstype)));\n \n-\t  gcc_assert (!PROMOTES_TO_AGGR_TYPE (lhstype, REFERENCE_TYPE));\n \t  lhs = stabilize_reference (lhs);\n \t  newrhs = cp_build_binary_op (modifycode, lhs, rhs);\n \t  if (newrhs == error_mark_node)\n@@ -6512,7 +6514,7 @@ convert_for_initialization (tree exp, tree type, tree rhs, int flags,\n \n   type = complete_type (type);\n \n-  if (IS_AGGR_TYPE (type))\n+  if (MAYBE_CLASS_TYPE_P (type))\n     return ocp_convert (type, rhs, CONV_IMPLICIT|CONV_FORCE_TEMP, flags);\n \n   return convert_for_assignment (type, rhs, errtype, fndecl, parmnum);"}, {"sha": "c48a7852609ee57899e48854f6c8712b9d97e9a8", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e1e64ec2b978e81924000db7d4009b92bb5a638/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e1e64ec2b978e81924000db7d4009b92bb5a638/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=9e1e64ec2b978e81924000db7d4009b92bb5a638", "patch": "@@ -1,7 +1,7 @@\n /* Report error messages, build initializers, and perform\n    some front-end optimizations for C++ compiler.\n    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2004, 2005, 2006, 2007\n+   1999, 2000, 2001, 2002, 2004, 2005, 2006, 2007, 2008\n    Free Software Foundation, Inc.\n    Hacked by Michael Tiemann (tiemann@cygnus.com)\n \n@@ -583,7 +583,7 @@ store_init_value (tree decl, tree init)\n   if (TREE_CODE (type) == ERROR_MARK)\n     return NULL_TREE;\n \n-  if (IS_AGGR_TYPE (type))\n+  if (MAYBE_CLASS_TYPE_P (type))\n     {\n       gcc_assert (TYPE_HAS_TRIVIAL_INIT_REF (type)\n \t\t  || TREE_CODE (init) == CONSTRUCTOR);\n@@ -848,7 +848,7 @@ process_init_constructor_array (tree type, tree init)\n \t      we can't rely on the back end to do it for us, so build up\n \t      TARGET_EXPRs.  If the type in question is a class, just build\n \t      one up; if it's an array, recurse.  */\n-\t    if (IS_AGGR_TYPE (TREE_TYPE (type)))\n+\t    if (MAYBE_CLASS_TYPE_P (TREE_TYPE (type)))\n \t\tnext = build_functional_cast (TREE_TYPE (type), NULL_TREE);\n \t    else\n \t\tnext = build_constructor (NULL_TREE, NULL);\n@@ -935,7 +935,7 @@ process_init_constructor_record (tree type, tree init)\n \t     default-initialization, we can't rely on the back end to do it\n \t     for us, so build up TARGET_EXPRs.  If the type in question is\n \t     a class, just build one up; if it's an array, recurse.  */\n-\t  if (IS_AGGR_TYPE (TREE_TYPE (field)))\n+\t  if (MAYBE_CLASS_TYPE_P (TREE_TYPE (field)))\n \t    next = build_functional_cast (TREE_TYPE (field), NULL_TREE);\n \t  else\n \t    next = build_constructor (NULL_TREE, NULL);\n@@ -1161,7 +1161,7 @@ build_x_arrow (tree expr)\n       expr = build_non_dependent_expr (expr);\n     }\n \n-  if (IS_AGGR_TYPE (type))\n+  if (MAYBE_CLASS_TYPE_P (type))\n     {\n       while ((expr = build_new_op (COMPONENT_REF, LOOKUP_NORMAL, expr,\n \t\t\t\t   NULL_TREE, NULL_TREE,\n@@ -1240,7 +1240,7 @@ build_m_component_ref (tree datum, tree component)\n     }\n \n   objtype = TYPE_MAIN_VARIANT (TREE_TYPE (datum));\n-  if (! IS_AGGR_TYPE (objtype))\n+  if (! MAYBE_CLASS_TYPE_P (objtype))\n     {\n       error (\"cannot apply member pointer %qE to %qE, which is of \"\n \t     \"non-class type %qT\",\n@@ -1330,7 +1330,7 @@ build_functional_cast (tree exp, tree parms)\n       return t;\n     }\n \n-  if (! IS_AGGR_TYPE (type))\n+  if (! MAYBE_CLASS_TYPE_P (type))\n     {\n       if (parms == NULL_TREE)\n \treturn cp_convert (type, integer_zero_node);"}]}