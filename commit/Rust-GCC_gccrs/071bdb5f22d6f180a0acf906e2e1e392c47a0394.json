{"sha": "071bdb5f22d6f180a0acf906e2e1e392c47a0394", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDcxYmRiNWYyMmQ2ZjE4MGEwYWNmOTA2ZTJlMWUzOTJjNDdhMDM5NA==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2010-08-02T16:53:51Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2010-08-02T16:53:51Z"}, "message": "re PR fortran/36854 ([meta-bug] fortran front-end optimization)\n\n2010-08-02  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/36854\n\t* dependency.h:  Add prototype for gfc_are_identical_variables.\n\t* frontend-passes.c:  Include depencency.h.\n\t(optimimize_equality):  Use gfc_are_identical_variables.\n\t* dependency.c (identical_array_ref): New function.\n\t(gfc_are_identical_variables):  New function.\n\t(gfc_deb_compare_expr):  Use gfc_are_identical_variables.\n\t* dependency.c (gfc_check_section_vs_section).  Rename gfc_\n\tprefix from statc function.\n\t(check_section_vs_section): Change arguments to gfc_array_ref,\n\tadjust function body accordingly.\n\n2010-08-02  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/36854\n\t* gfortran.dg/character_comparison_2.f90:  New test.\n\t* gfortran.dg/character_comparison_3.f90:  New test.\n\t* gfortran.dg/dependency_28.f90:  New test.\n\nFrom-SVN: r162824", "tree": {"sha": "479f0423955a284d5abd1abccc5b3bab38efbc1e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/479f0423955a284d5abd1abccc5b3bab38efbc1e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/071bdb5f22d6f180a0acf906e2e1e392c47a0394", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/071bdb5f22d6f180a0acf906e2e1e392c47a0394", "html_url": "https://github.com/Rust-GCC/gccrs/commit/071bdb5f22d6f180a0acf906e2e1e392c47a0394", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/071bdb5f22d6f180a0acf906e2e1e392c47a0394/comments", "author": null, "committer": null, "parents": [{"sha": "20769d5eb6854f1dec44744721ec17c52609254d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20769d5eb6854f1dec44744721ec17c52609254d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20769d5eb6854f1dec44744721ec17c52609254d"}], "stats": {"total": 280, "additions": 249, "deletions": 31}, "files": [{"sha": "db64bff0596ebe9b85eeba574bee214565b0a50f", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/071bdb5f22d6f180a0acf906e2e1e392c47a0394/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/071bdb5f22d6f180a0acf906e2e1e392c47a0394/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=071bdb5f22d6f180a0acf906e2e1e392c47a0394", "patch": "@@ -1,3 +1,17 @@\n+2010-08-02  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/36854\n+\t* dependency.h:  Add prototype for gfc_are_identical_variables.\n+\t* frontend-passes.c:  Include depencency.h.\n+\t(optimimize_equality):  Use gfc_are_identical_variables.\n+\t* dependency.c (identical_array_ref): New function.\n+\t(gfc_are_identical_variables):  New function.\n+\t(gfc_deb_compare_expr):  Use gfc_are_identical_variables.\n+\t* dependency.c (gfc_check_section_vs_section).  Rename gfc_\n+\tprefix from statc function.\n+\t(check_section_vs_section): Change arguments to gfc_array_ref,\n+\tadjust function body accordingly.\n+\n 2010-08-02  Mikael Morin  <mikael@gcc.gnu.org>\n \t    Janus Weil  <janus@gcc.gnu.org>\n "}, {"sha": "b20b627b3f7bb6b11eddf0f9d1fdcec5853b78d4", "filename": "gcc/fortran/dependency.c", "status": "modified", "additions": 123, "deletions": 26, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/071bdb5f22d6f180a0acf906e2e1e392c47a0394/gcc%2Ffortran%2Fdependency.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/071bdb5f22d6f180a0acf906e2e1e392c47a0394/gcc%2Ffortran%2Fdependency.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdependency.c?ref=071bdb5f22d6f180a0acf906e2e1e392c47a0394", "patch": "@@ -49,6 +49,10 @@ gfc_dependency;\n /* Macros */\n #define IS_ARRAY_EXPLICIT(as) ((as->type == AS_EXPLICIT ? 1 : 0))\n \n+/* Forward declarations */\n+\n+static gfc_dependency check_section_vs_section (gfc_array_ref *,\n+\t\t\t\t\t\tgfc_array_ref *, int);\n \n /* Returns 1 if the expr is an integer constant value 1, 0 if it is not or\n    def if the value could not be determined.  */\n@@ -67,6 +71,105 @@ gfc_expr_is_one (gfc_expr *expr, int def)\n   return mpz_cmp_si (expr->value.integer, 1) == 0;\n }\n \n+/* Check if two array references are known to be identical.  Calls\n+   gfc_dep_compare_expr if necessary for comparing array indices.  */\n+\n+static bool\n+identical_array_ref (gfc_array_ref *a1, gfc_array_ref *a2)\n+{\n+  int i;\n+\n+  if (a1->type == AR_FULL && a2->type == AR_FULL)\n+    return true;\n+\n+  if (a1->type == AR_SECTION && a2->type == AR_SECTION)\n+    {\n+      gcc_assert (a1->dimen == a2->dimen);\n+\n+      for ( i = 0; i < a1->dimen; i++)\n+\t{\n+\t  /* TODO: Currently, we punt on an integer array as an index.  */\n+\t  if (a1->dimen_type[i] != DIMEN_RANGE\n+\t      || a2->dimen_type[i] != DIMEN_RANGE)\n+\t    return false;\n+\n+\t  if (check_section_vs_section (a1, a2, i) != GFC_DEP_EQUAL)\n+\t    return false;\n+\t}\n+      return true;\n+    }\n+\n+  if (a1->type == AR_ELEMENT && a2->type == AR_ELEMENT)\n+    {\n+      gcc_assert (a1->dimen == a2->dimen);\n+      for (i = 0; i < a1->dimen; i++)\n+\t{\n+\t  if (gfc_dep_compare_expr (a1->start[i], a2->start[i]) != 0)\n+\t    return false;\n+\t}\n+      return true;\n+    }\n+  return false;\n+}\n+\n+\n+\n+/* Return true for identical variables, checking for references if\n+   necessary.  Calls identical_array_ref for checking array sections.  */\n+\n+bool\n+gfc_are_identical_variables (gfc_expr *e1, gfc_expr *e2)\n+{\n+  gfc_ref *r1, *r2;\n+\n+  if (e1->symtree->n.sym != e2->symtree->n.sym)\n+    return false;\n+\n+  r1 = e1->ref;\n+  r2 = e2->ref;\n+\n+  while (r1 != NULL || r2 != NULL)\n+    {\n+\n+      /* Assume the variables are not equal if one has a reference and the\n+\t other doesn't.\n+\t TODO: Handle full references like comparing a(:) to a.\n+      */\n+\n+      if (r1 == NULL || r2 == NULL)\n+\treturn false;\n+\n+      if (r1->type != r2->type)\n+\treturn false;\n+\n+      switch (r1->type)\n+\t{\n+\n+\tcase REF_ARRAY:\n+\t  if (!identical_array_ref (&r1->u.ar,  &r2->u.ar))\n+\t    return false;\n+\n+\t  break;\n+\n+\tcase REF_COMPONENT:\n+\t  if (r1->u.c.component != r2->u.c.component)\n+\t    return false;\n+\t  break;\n+\n+\tcase REF_SUBSTRING:\n+\t  if (gfc_dep_compare_expr (r1->u.ss.start, r2->u.ss.start) != 0\n+\t      || gfc_dep_compare_expr (r1->u.ss.end, r2->u.ss.end) != 0)\n+\t    return false;\n+\t  break;\n+\n+\tdefault:\n+\t  gfc_internal_error (\"gfc_are_identical_variables: Bad type\");\n+\t}\n+      r1 = r1->next;\n+      r2 = r2->next;\n+    }\n+  return true;\n+}\n \n /* Compare two values.  Returns 0 if e1 == e2, -1 if e1 < e2, +1 if e1 > e2,\n    and -2 if the relationship could not be determined.  */\n@@ -191,11 +294,10 @@ gfc_dep_compare_expr (gfc_expr *e1, gfc_expr *e2)\n       return 1;\n \n     case EXPR_VARIABLE:\n-      if (e1->ref || e2->ref)\n-\treturn -2;\n-      if (e1->symtree->n.sym == e2->symtree->n.sym)\n+      if (gfc_are_identical_variables (e1, e2))\n \treturn 0;\n-      return -2;\n+      else\n+\treturn -2;\n \n     case EXPR_OP:\n       /* Intrinsic operators are the same if their operands are the same.  */\n@@ -882,52 +984,47 @@ gfc_check_dependency (gfc_expr *expr1, gfc_expr *expr2, bool identical)\n /* Determines overlapping for two array sections.  */\n \n static gfc_dependency\n-gfc_check_section_vs_section (gfc_ref *lref, gfc_ref *rref, int n)\n+check_section_vs_section (gfc_array_ref *l_ar, gfc_array_ref *r_ar, int n)\n {\n-  gfc_array_ref l_ar;\n   gfc_expr *l_start;\n   gfc_expr *l_end;\n   gfc_expr *l_stride;\n   gfc_expr *l_lower;\n   gfc_expr *l_upper;\n   int l_dir;\n \n-  gfc_array_ref r_ar;\n   gfc_expr *r_start;\n   gfc_expr *r_end;\n   gfc_expr *r_stride;\n   gfc_expr *r_lower;\n   gfc_expr *r_upper;\n   int r_dir;\n \n-  l_ar = lref->u.ar;\n-  r_ar = rref->u.ar;\n-  \n   /* If they are the same range, return without more ado.  */\n-  if (gfc_is_same_range (&l_ar, &r_ar, n, 0))\n+  if (gfc_is_same_range (l_ar, r_ar, n, 0))\n     return GFC_DEP_EQUAL;\n \n-  l_start = l_ar.start[n];\n-  l_end = l_ar.end[n];\n-  l_stride = l_ar.stride[n];\n+  l_start = l_ar->start[n];\n+  l_end = l_ar->end[n];\n+  l_stride = l_ar->stride[n];\n \n-  r_start = r_ar.start[n];\n-  r_end = r_ar.end[n];\n-  r_stride = r_ar.stride[n];\n+  r_start = r_ar->start[n];\n+  r_end = r_ar->end[n];\n+  r_stride = r_ar->stride[n];\n \n   /* If l_start is NULL take it from array specifier.  */\n-  if (NULL == l_start && IS_ARRAY_EXPLICIT (l_ar.as))\n-    l_start = l_ar.as->lower[n];\n+  if (NULL == l_start && IS_ARRAY_EXPLICIT (l_ar->as))\n+    l_start = l_ar->as->lower[n];\n   /* If l_end is NULL take it from array specifier.  */\n-  if (NULL == l_end && IS_ARRAY_EXPLICIT (l_ar.as))\n-    l_end = l_ar.as->upper[n];\n+  if (NULL == l_end && IS_ARRAY_EXPLICIT (l_ar->as))\n+    l_end = l_ar->as->upper[n];\n \n   /* If r_start is NULL take it from array specifier.  */\n-  if (NULL == r_start && IS_ARRAY_EXPLICIT (r_ar.as))\n-    r_start = r_ar.as->lower[n];\n+  if (NULL == r_start && IS_ARRAY_EXPLICIT (r_ar->as))\n+    r_start = r_ar->as->lower[n];\n   /* If r_end is NULL take it from array specifier.  */\n-  if (NULL == r_end && IS_ARRAY_EXPLICIT (r_ar.as))\n-    r_end = r_ar.as->upper[n];\n+  if (NULL == r_end && IS_ARRAY_EXPLICIT (r_ar->as))\n+    r_end = r_ar->as->upper[n];\n \n   /* Determine whether the l_stride is positive or negative.  */\n   if (!l_stride)\n@@ -1574,7 +1671,7 @@ gfc_dep_resolver (gfc_ref *lref, gfc_ref *rref, gfc_reverse *reverse)\n \n \t      if (lref->u.ar.dimen_type[n] == DIMEN_RANGE\n \t\t  && rref->u.ar.dimen_type[n] == DIMEN_RANGE)\n-\t\tthis_dep = gfc_check_section_vs_section (lref, rref, n);\n+\t\tthis_dep = check_section_vs_section (&lref->u.ar, &rref->u.ar, n);\n \t      else if (lref->u.ar.dimen_type[n] == DIMEN_ELEMENT\n \t\t       && rref->u.ar.dimen_type[n] == DIMEN_RANGE)\n \t\tthis_dep = gfc_check_element_vs_section (lref, rref, n);"}, {"sha": "c2f7229390ca28f8bc0e48a0d55a7aca1831483f", "filename": "gcc/fortran/dependency.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/071bdb5f22d6f180a0acf906e2e1e392c47a0394/gcc%2Ffortran%2Fdependency.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/071bdb5f22d6f180a0acf906e2e1e392c47a0394/gcc%2Ffortran%2Fdependency.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdependency.h?ref=071bdb5f22d6f180a0acf906e2e1e392c47a0394", "patch": "@@ -43,3 +43,5 @@ int gfc_expr_is_one (gfc_expr *, int);\n int gfc_dep_resolver(gfc_ref *, gfc_ref *, gfc_reverse *);\n int gfc_are_equivalenced_arrays (gfc_expr *, gfc_expr *);\n \n+bool gfc_are_identical_variables (gfc_expr *, gfc_expr *);\n+"}, {"sha": "ce3ee9a27208230676b19f211311acfa726e43e7", "filename": "gcc/fortran/frontend-passes.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/071bdb5f22d6f180a0acf906e2e1e392c47a0394/gcc%2Ffortran%2Ffrontend-passes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/071bdb5f22d6f180a0acf906e2e1e392c47a0394/gcc%2Ffortran%2Ffrontend-passes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ffrontend-passes.c?ref=071bdb5f22d6f180a0acf906e2e1e392c47a0394", "patch": "@@ -23,6 +23,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gfortran.h\"\n #include \"arith.h\"\n #include \"flags.h\"\n+#include \"dependency.h\"\n \n /* Forward declarations.  */\n \n@@ -398,14 +399,13 @@ optimize_equality (gfc_expr *e, bool equal)\n       return true;\n     }\n \n-  /* Check for direct comparison between identical variables.\n-     TODO: Handle cases with identical refs.  */\n+  /* Check for direct comparison between identical variables.  Don't compare\n+     REAL or COMPLEX because of NaN checks.  */\n   if (op1->expr_type == EXPR_VARIABLE\n       && op2->expr_type == EXPR_VARIABLE\n-      && op1->symtree == op2->symtree\n-      && op1->ref == NULL && op2->ref == NULL\n       && op1->ts.type != BT_REAL && op2->ts.type != BT_REAL\n-      && op1->ts.type != BT_COMPLEX && op2->ts.type !=BT_COMPLEX)\n+      && op1->ts.type != BT_COMPLEX && op2->ts.type !=BT_COMPLEX\n+      && gfc_are_identical_variables (op1, op2))\n     {\n       /* Replace the expression by a constant expression.  The typespec\n \t and where remains the way it is.  */"}, {"sha": "1687f03d369f6d02bfc26320bd63c980512d38a1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/071bdb5f22d6f180a0acf906e2e1e392c47a0394/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/071bdb5f22d6f180a0acf906e2e1e392c47a0394/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=071bdb5f22d6f180a0acf906e2e1e392c47a0394", "patch": "@@ -1,3 +1,17 @@\n+2010-08-02  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/36854\n+\t* dependency.h:  Add prototype for gfc_are_identical_variables.\n+\t* frontend-passes.c:  Include depencency.h.\n+\t(optimimize_equality):  Use gfc_are_identical_variables.\n+\t* dependency.c (identical_array_ref): New function.\n+\t(gfc_are_identical_variables):  New function.\n+\t(gfc_deb_compare_expr):  Use gfc_are_identical_variables.\n+\t* dependency.c (gfc_check_section_vs_section).  Rename gfc_\n+\tprefix from statc function.\n+\t(check_section_vs_section): Change arguments to gfc_array_ref,\n+\tadjust function body accordingly.\n+\n 2010-08-02  Bernd Schmidt  <bernds@codesourcery.com>\n \n \tPR target/40457"}, {"sha": "d2736f874a61dc5e4b219516e2b115b38eeee178", "filename": "gcc/testsuite/gfortran.dg/character_comparison_2.f90", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/071bdb5f22d6f180a0acf906e2e1e392c47a0394/gcc%2Ftestsuite%2Fgfortran.dg%2Fcharacter_comparison_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/071bdb5f22d6f180a0acf906e2e1e392c47a0394/gcc%2Ftestsuite%2Fgfortran.dg%2Fcharacter_comparison_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcharacter_comparison_2.f90?ref=071bdb5f22d6f180a0acf906e2e1e392c47a0394", "patch": "@@ -0,0 +1,40 @@\n+! { dg-do run }\n+! { dg-options \"-O -fdump-tree-original\" }\n+program main\n+  implicit none\n+  character(len=4) :: c\n+  integer :: n\n+  integer :: i\n+  integer :: k1, k2\n+  common /foo/ i\n+\n+  n = 0\n+  i = 0\n+  k1 = 1\n+  k2 = 3\n+  c = 'abcd'\n+  n = n + 1 ; if (c(1:2) == c(1:2)) call yes\n+  n = n + 1 ; if (c(k1:k2) >= c(k1:k2)) call yes\n+  n = n + 1 ; if (c(:2) <= c(1:2)) call yes\n+  n = n + 1 ; if (c(k2:) .eq. c(k2:4)) call yes\n+  n = n + 1 ; if (c(:) .ge. c) call yes\n+  n = n + 1 ; if (c .le. c) call yes\n+  if (c(1:2) /= c(1:2)) call abort\n+  if (c(k1:k2) > c(k1:k2)) call abort\n+  if (c(:2) < c(1:2)) call abort\n+  if (c(:) .ne. c) call abort\n+  if (c(:2) .gt. c(1:2)) call abort\n+  if (c(1:2) .lt. c(:2)) call abort\n+  if (n /= i) call abort\n+end program main\n+\n+subroutine yes\n+  implicit none\n+  common /foo/ i\n+  integer :: i\n+  i = i + 1\n+end subroutine yes\n+\n+! { dg-final { scan-tree-dump-times \"gfortran_compare_string\" 0 \"original\" } }\n+! { dg-final { cleanup-tree-dump \"original\" } }\n+"}, {"sha": "dbcdbefb20aa1448f9b2ec2c6acc05609bb307bc", "filename": "gcc/testsuite/gfortran.dg/character_comparison_3.f90", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/071bdb5f22d6f180a0acf906e2e1e392c47a0394/gcc%2Ftestsuite%2Fgfortran.dg%2Fcharacter_comparison_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/071bdb5f22d6f180a0acf906e2e1e392c47a0394/gcc%2Ftestsuite%2Fgfortran.dg%2Fcharacter_comparison_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcharacter_comparison_3.f90?ref=071bdb5f22d6f180a0acf906e2e1e392c47a0394", "patch": "@@ -0,0 +1,30 @@\n+! { dg-do run }\n+! { dg-options \"-fdump-tree-original\" }\n+program main\n+  implicit none\n+  character(len=4) :: c\n+  integer :: i\n+  integer :: k1, k2, k3, k4, k11, k22, k33, k44\n+\n+  k1 = 1\n+  k2 = 2\n+  k3 = 3\n+  k4 = 4\n+  k11 = 1\n+  k22 = 2\n+  k33 = 3\n+  k44 = 4\n+  c = 'abcd'\n+  if (c(2:) /= c(k2:k4)) call abort\n+  if (c(k2:k4) /= c(k22:)) call abort\n+  if (c(2:3) == c(1:2)) call abort\n+  if (c(1:2) == c(2:3)) call abort\n+  if (c(k1:) == c(k2:)) call abort\n+  if (c(:3) == c(:k4)) call abort\n+  if (c(:k4) == c(:3)) call abort\n+  if (c(:k3) == c(:k44)) call abort\n+end program main\n+\n+! { dg-final { scan-tree-dump-times \"gfortran_compare_string\" 8 \"original\" } }\n+! { dg-final { cleanup-tree-dump \"original\" } }\n+"}, {"sha": "5d70abe395ec5daa948a24cab916add86cb433be", "filename": "gcc/testsuite/gfortran.dg/dependency_28.f90", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/071bdb5f22d6f180a0acf906e2e1e392c47a0394/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_28.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/071bdb5f22d6f180a0acf906e2e1e392c47a0394/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_28.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_28.f90?ref=071bdb5f22d6f180a0acf906e2e1e392c47a0394", "patch": "@@ -0,0 +1,21 @@\n+! { dg-do compile }\n+! { dg-options \"-Warray-temporaries\" }\n+module foobar\n+  type baz\n+     integer :: i\n+     integer :: j\n+     integer :: k\n+     integer :: m\n+  end type baz\n+contains\n+  subroutine foo(a,b,c,i)\n+    real, dimension(10) :: a,b\n+    type(baz) :: c\n+    integer, dimension(10) :: i\n+    a(i(1):i(2)) = a(i(1):i(2)) + b(i(1):i(2))\n+    a(i(1):i(2)) = a(i(3):i(5)) ! { dg-warning \"Creating array temporary\" }\n+    a(c%i:c%j) = a(c%i:c%j) + b(c%k:c%m)\n+    a(c%k:c%m) = a(c%i:c%j) + b(c%k:c%m) ! { dg-warning \"Creating array temporary\" }\n+  end subroutine foo\n+end module foobar\n+! { dg-final { cleanup-modules \"foobar\" } }"}]}