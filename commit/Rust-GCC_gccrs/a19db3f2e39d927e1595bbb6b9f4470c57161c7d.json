{"sha": "a19db3f2e39d927e1595bbb6b9f4470c57161c7d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTE5ZGIzZjJlMzlkOTI3ZTE1OTViYmI2YjlmNDQ3MGM1NzE2MWM3ZA==", "commit": {"author": {"name": "Torvald Riegel", "email": "triegel@redhat.com", "date": "2012-02-20T13:06:07Z"}, "committer": {"name": "Torvald Riegel", "email": "torvald@gcc.gnu.org", "date": "2012-02-20T13:06:07Z"}, "message": "libitm: Fix race condition in dispatch choice at transaction begin.\n\n\tlibitm/\n\t* beginend.cc (GTM::gtm_thread::begin_transaction): Move serial lock\n\tacquisition to ...\n\t* retry.cc (GTM::gtm_thread::decide_begin_dispatch): ... here.\n\t(default_dispatch): Make atomic.\n\t(GTM::gtm_thread::set_default_dispatch): Access atomically.\n\t(GTM::gtm_thread::decide_retry_strategy): Access atomically and\n\tuse decide_begin_dispatch() if default_dispatch might have changed.\n\t(GTM::gtm_thread::number_of_threads_changed): Initialize\n\tdefault_dispatch here.\n\nFrom-SVN: r184392", "tree": {"sha": "ab52139ec839cdce4a63ce4b77072d1d850159b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ab52139ec839cdce4a63ce4b77072d1d850159b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a19db3f2e39d927e1595bbb6b9f4470c57161c7d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a19db3f2e39d927e1595bbb6b9f4470c57161c7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a19db3f2e39d927e1595bbb6b9f4470c57161c7d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a19db3f2e39d927e1595bbb6b9f4470c57161c7d/comments", "author": {"login": "triegelrh", "id": 62400967, "node_id": "MDQ6VXNlcjYyNDAwOTY3", "avatar_url": "https://avatars.githubusercontent.com/u/62400967?v=4", "gravatar_id": "", "url": "https://api.github.com/users/triegelrh", "html_url": "https://github.com/triegelrh", "followers_url": "https://api.github.com/users/triegelrh/followers", "following_url": "https://api.github.com/users/triegelrh/following{/other_user}", "gists_url": "https://api.github.com/users/triegelrh/gists{/gist_id}", "starred_url": "https://api.github.com/users/triegelrh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/triegelrh/subscriptions", "organizations_url": "https://api.github.com/users/triegelrh/orgs", "repos_url": "https://api.github.com/users/triegelrh/repos", "events_url": "https://api.github.com/users/triegelrh/events{/privacy}", "received_events_url": "https://api.github.com/users/triegelrh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5a226e0af1d34600e38f02e3e84485db3f96b56c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a226e0af1d34600e38f02e3e84485db3f96b56c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a226e0af1d34600e38f02e3e84485db3f96b56c"}], "stats": {"total": 136, "additions": 96, "deletions": 40}, "files": [{"sha": "e0d94a1d1130a7079f183fad90093eac8051f6d1", "filename": "libitm/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a19db3f2e39d927e1595bbb6b9f4470c57161c7d/libitm%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a19db3f2e39d927e1595bbb6b9f4470c57161c7d/libitm%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2FChangeLog?ref=a19db3f2e39d927e1595bbb6b9f4470c57161c7d", "patch": "@@ -1,3 +1,15 @@\n+2012-02-20  Torvald Riegel  <triegel@redhat.com>\n+\n+\t* beginend.cc (GTM::gtm_thread::begin_transaction): Move serial lock\n+\tacquisition to ...\n+\t* retry.cc (GTM::gtm_thread::decide_begin_dispatch): ... here.\n+\t(default_dispatch): Make atomic.\n+\t(GTM::gtm_thread::set_default_dispatch): Access atomically.\n+\t(GTM::gtm_thread::decide_retry_strategy): Access atomically and\n+\tuse decide_begin_dispatch() if default_dispatch might have changed.\n+\t(GTM::gtm_thread::number_of_threads_changed): Initialize\n+\tdefault_dispatch here.\n+\n 2012-02-15  Iain Sandoe  <iains@gcc.gnu.org>\n \t    Patrick Marlier  <patrick.marlier@gmail.com>\n "}, {"sha": "e6a84de13e239706df7d1d3e2f5a169c7c6fcd1c", "filename": "libitm/beginend.cc", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a19db3f2e39d927e1595bbb6b9f4470c57161c7d/libitm%2Fbeginend.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a19db3f2e39d927e1595bbb6b9f4470c57161c7d/libitm%2Fbeginend.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fbeginend.cc?ref=a19db3f2e39d927e1595bbb6b9f4470c57161c7d", "patch": "@@ -233,16 +233,6 @@ GTM::gtm_thread::begin_transaction (uint32_t prop, const gtm_jmpbuf *jb)\n     {\n       // Outermost transaction\n       disp = tx->decide_begin_dispatch (prop);\n-      if (disp == dispatch_serialirr() || disp == dispatch_serial())\n-\t{\n-\t  tx->state = STATE_SERIAL;\n-\t  if (disp == dispatch_serialirr())\n-\t    tx->state |= STATE_IRREVOCABLE;\n-\t  serial_lock.write_lock ();\n-\t}\n-      else\n-\tserial_lock.read_lock (tx);\n-\n       set_abi_disp (disp);\n     }\n "}, {"sha": "2c1483eae5a0cd4554787fcf3a05d7ff0a8a924e", "filename": "libitm/retry.cc", "status": "modified", "additions": 84, "deletions": 30, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a19db3f2e39d927e1595bbb6b9f4470c57161c7d/libitm%2Fretry.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a19db3f2e39d927e1595bbb6b9f4470c57161c7d/libitm%2Fretry.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fretry.cc?ref=a19db3f2e39d927e1595bbb6b9f4470c57161c7d", "patch": "@@ -27,8 +27,16 @@\n #include <ctype.h>\n #include \"libitm_i.h\"\n \n-// The default TM method used when starting a new transaction.\n-static GTM::abi_dispatch* default_dispatch = 0;\n+// The default TM method used when starting a new transaction.  Initialized\n+// in number_of_threads_changed() below.\n+// Access to this variable is always synchronized with help of the serial\n+// lock, except one read access that happens in decide_begin_dispatch() before\n+// a transaction has become active (by acquiring the serial lock in read or\n+// write mode).  The default_dispatch is only changed and initialized in\n+// serial mode.  Transactions stay active when they restart (see beginend.cc),\n+// thus decide_retry_strategy() can expect default_dispatch to be unmodified.\n+// See decide_begin_dispatch() for further comments.\n+static std::atomic<GTM::abi_dispatch*> default_dispatch;\n // The default TM method as requested by the user, if any.\n static GTM::abi_dispatch* default_dispatch_user = 0;\n \n@@ -57,20 +65,24 @@ GTM::gtm_thread::decide_retry_strategy (gtm_restart_reason r)\n \t  // given that re-inits should be very infrequent.\n \t  serial_lock.read_unlock(this);\n \t  serial_lock.write_lock();\n-\t  if (disp->get_method_group() == default_dispatch->get_method_group())\n+\t  if (disp->get_method_group()\n+\t      == default_dispatch.load(memory_order_relaxed)\n+\t      ->get_method_group())\n \t    // Still the same method group.\n \t    disp->get_method_group()->reinit();\n \t  serial_lock.write_unlock();\n-\t  serial_lock.read_lock(this);\n-\t  if (disp->get_method_group() != default_dispatch->get_method_group())\n-\t    {\n-\t      disp = default_dispatch;\n-\t      set_abi_disp(disp);\n-\t    }\n+\t  // Also, we're making the transaction inactive, so when we become\n+\t  // active again, some other thread might have changed the default\n+\t  // dispatch, so we run the same code as for the first execution\n+\t  // attempt.\n+\t  disp = decide_begin_dispatch(prop);\n+\t  set_abi_disp(disp);\n \t}\n       else\n \t// We are a serial transaction already, which makes things simple.\n \tdisp->get_method_group()->reinit();\n+\n+      return;\n     }\n \n   bool retry_irr = (r == RESTART_SERIAL_IRR);\n@@ -124,48 +136,89 @@ GTM::gtm_thread::decide_retry_strategy (gtm_restart_reason r)\n \n \n // Decides which TM method should be used on the first attempt to run this\n-// transaction.\n+// transaction.  Acquires the serial lock and sets transaction state\n+// according to the chosen TM method.\n GTM::abi_dispatch*\n GTM::gtm_thread::decide_begin_dispatch (uint32_t prop)\n {\n+  abi_dispatch* dd;\n   // TODO Pay more attention to prop flags (eg, *omitted) when selecting\n   // dispatch.\n+  // ??? We go irrevocable eagerly here, which is not always good for\n+  // performance.  Don't do this?\n   if ((prop & pr_doesGoIrrevocable) || !(prop & pr_instrumentedCode))\n-    return dispatch_serialirr();\n-\n-  // If we might need closed nesting and the default dispatch has an\n-  // alternative that supports closed nesting, use it.\n-  // ??? We could choose another TM method that we know supports closed\n-  // nesting but isn't the default (e.g., dispatch_serial()). However, we\n-  // assume that aborts that need closed nesting are infrequent, so don't\n-  // choose a non-default method until we have to actually restart the\n-  // transaction.\n-  if (!(prop & pr_hasNoAbort) && !default_dispatch->closed_nesting()\n-      && default_dispatch->closed_nesting_alternative())\n-    return default_dispatch->closed_nesting_alternative();\n-\n-  // No special case, just use the default dispatch.\n-  return default_dispatch;\n+    dd = dispatch_serialirr();\n+\n+  else\n+    {\n+      // Load the default dispatch.  We're not an active transaction and so it\n+      // can change concurrently but will still be some valid dispatch.\n+      // Relaxed memory order is okay because we expect each dispatch to be\n+      // constructed properly already (at least that its closed_nesting() and\n+      // closed_nesting_alternatives() will return sensible values).  It is\n+      // harmless if we incorrectly chose the serial or serialirr methods, and\n+      // for all other methods we will acquire the serial lock in read mode\n+      // and load the default dispatch again.\n+      abi_dispatch* dd_orig = default_dispatch.load(memory_order_relaxed);\n+      dd = dd_orig;\n+\n+      // If we might need closed nesting and the default dispatch has an\n+      // alternative that supports closed nesting, use it.\n+      // ??? We could choose another TM method that we know supports closed\n+      // nesting but isn't the default (e.g., dispatch_serial()). However, we\n+      // assume that aborts that need closed nesting are infrequent, so don't\n+      // choose a non-default method until we have to actually restart the\n+      // transaction.\n+      if (!(prop & pr_hasNoAbort) && !dd->closed_nesting()\n+\t  && dd->closed_nesting_alternative())\n+\tdd = dd->closed_nesting_alternative();\n+\n+      if (dd != dispatch_serial() && dd != dispatch_serialirr())\n+\t{\n+\t  // The current dispatch is supposedly a non-serial one.  Become an\n+\t  // active transaction and verify this.  Relaxed memory order is fine\n+\t  // because the serial lock itself will have established\n+\t  // happens-before for any change to the selected dispatch.\n+\t  serial_lock.read_lock (this);\n+\t  if (default_dispatch.load(memory_order_relaxed) == dd_orig)\n+\t    return dd;\n+\n+\t  // If we raced with a concurrent modification of default_dispatch,\n+\t  // just fall back to serialirr.  The dispatch choice might not be\n+\t  // up-to-date anymore, but this is harmless.\n+\t  serial_lock.read_unlock (this);\n+\t  dd = dispatch_serialirr();\n+\t}\n+    }\n+\n+  // We are some kind of serial transaction.\n+  serial_lock.write_lock();\n+  if (dd == dispatch_serialirr())\n+    state = STATE_SERIAL | STATE_IRREVOCABLE;\n+  else\n+    state = STATE_SERIAL;\n+  return dd;\n }\n \n \n void\n GTM::gtm_thread::set_default_dispatch(GTM::abi_dispatch* disp)\n {\n-  if (default_dispatch == disp)\n+  abi_dispatch* dd = default_dispatch.load(memory_order_relaxed);\n+  if (dd == disp)\n     return;\n-  if (default_dispatch)\n+  if (dd)\n     {\n       // If we are switching method groups, initialize and shut down properly.\n-      if (default_dispatch->get_method_group() != disp->get_method_group())\n+      if (dd->get_method_group() != disp->get_method_group())\n \t{\n-\t  default_dispatch->get_method_group()->fini();\n+\t  dd->get_method_group()->fini();\n \t  disp->get_method_group()->init();\n \t}\n     }\n   else\n     disp->get_method_group()->init();\n-  default_dispatch = disp;\n+  default_dispatch.store(disp, memory_order_relaxed);\n }\n \n \n@@ -233,6 +286,7 @@ GTM::gtm_thread::number_of_threads_changed(unsigned previous, unsigned now)\n \t{\n \t  initialized = true;\n \t  // Check for user preferences here.\n+\t  default_dispatch = 0;\n \t  default_dispatch_user = parse_default_method();\n \t}\n     }"}]}