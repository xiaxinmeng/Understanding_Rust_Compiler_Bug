{"sha": "ff2ad0f77f613012b18f08ac9414de159d4971bb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmYyYWQwZjc3ZjYxMzAxMmIxOGYwOGFjOTQxNGRlMTU5ZDQ5NzFiYg==", "commit": {"author": {"name": "Diego Novillo", "email": "dnovillo@redhat.com", "date": "2004-06-29T01:53:04Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2004-06-29T01:53:04Z"}, "message": "common.opt (ftree-fre): New flag.\n\n\n\t* common.opt (ftree-fre): New flag.\n\t* flags.h (flag_tree_fre): Declare.\n\t* opts.c (decode_options): Set.\n\t* timevar.def (TV_TREE_FRE): Define.\n\t* tree-flow-inline.h (may_propagate_copy): Re-arrange for\n\treadability.  Handle destinations that are not SSA_NAMEs.\n\t* tree-flow.h (struct ptr_info_def): Move from tree.h\n\t(cprop_into_stmt, cprop_into_successor_phis): Remove.\n\t(vn_compute, vn_lookup_or_add, vn_add, vn_lookup): Add\n\tvuse_optype parameter.\n\t* tree-pass.h (pass_fre): Declare.\n\t* tree-ssa-copy.c (cprop_operand): Move to tree-ssa-dom.c\n\t(cprop_into_stmt): Likewise.\n\t(cprop_into_successor_phis): Likewise.\n\t* tree-ssa-dom.c (eliminate_redundant_computations): Fix\n\targument ordering in call to may_propagate_copy.\n\t* tree-ssa-pre.c (is_undefined_value): Assume hard registers\n\tto be always defined.\n\t(add_to_sets): New local function.\n\t(create_value_expr_from): New local function.\n\t(compute_avail): Call them.\n\t(eliminate): Don't ignore statements with virtual operands.\n\t(init_pre): New local function.\n\t(fini_pre): New local function.\n\t(execute_pre): Call them.\n\tAdd argument DO_FRE.  Don't do insertion if DO_FRE is true.\n\t(do_pre): New function.\n\t(do_fre): New function.\n\t(gate_fre): New function.\n\t(pass_fre): Declare.\n\t* tree-ssa.c (init_tree_ssa): Don't call vn_init.\n\t(delete_tree_ssa): Don't call vn_delete.\n\t* tree-vn.c (val_expr_pair_d): Add documentation.\n\t(vn_compute): Add VUSES argument to incorporate in computing\n\thash values.  Update all callers.\n\t(expressions_equal_p): Call operand_equal_p with\n\tOEP_PURE_SAME.\n\t(vn_add): Add VUSES argument.  Update all callers.\n\t(vn_lookup): Likewise.\n\t(vn_lookup_or_add): Likewise.\n\t* doc/invoke.texi: Document -ftree-fre and -fdump-tree-fre.\n\nFrom-SVN: r83837", "tree": {"sha": "96e0012a9258a47b5f0378d9e76710e8c9689b4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/96e0012a9258a47b5f0378d9e76710e8c9689b4b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ff2ad0f77f613012b18f08ac9414de159d4971bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff2ad0f77f613012b18f08ac9414de159d4971bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff2ad0f77f613012b18f08ac9414de159d4971bb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff2ad0f77f613012b18f08ac9414de159d4971bb/comments", "author": null, "committer": null, "parents": [{"sha": "7b63e340d215e2c1abf5a6d195b224658020e233", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b63e340d215e2c1abf5a6d195b224658020e233", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b63e340d215e2c1abf5a6d195b224658020e233"}], "stats": {"total": 1244, "additions": 706, "deletions": 538}, "files": [{"sha": "64cca62c739e1f632f6f13576bdeb03b41522992", "filename": "gcc/ChangeLog", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2ad0f77f613012b18f08ac9414de159d4971bb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2ad0f77f613012b18f08ac9414de159d4971bb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ff2ad0f77f613012b18f08ac9414de159d4971bb", "patch": "@@ -1,3 +1,47 @@\n+2004-06-28  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* common.opt (ftree-fre): New flag.\n+\t* flags.h (flag_tree_fre): Declare.\n+\t* opts.c (decode_options): Set.\n+\t* timevar.def (TV_TREE_FRE): Define.\n+\t* tree-flow-inline.h (may_propagate_copy): Re-arrange for\n+\treadability.  Handle destinations that are not SSA_NAMEs.\n+\t* tree-flow.h (struct ptr_info_def): Move from tree.h\n+\t(cprop_into_stmt, cprop_into_successor_phis): Remove.\n+\t(vn_compute, vn_lookup_or_add, vn_add, vn_lookup): Add\n+\tvuse_optype parameter.\n+\t* tree-pass.h (pass_fre): Declare.\n+\t* tree-ssa-copy.c (cprop_operand): Move to tree-ssa-dom.c\n+\t(cprop_into_stmt): Likewise.\n+\t(cprop_into_successor_phis): Likewise.\n+\t* tree-ssa-dom.c (eliminate_redundant_computations): Fix\n+\targument ordering in call to may_propagate_copy.\n+\t* tree-ssa-pre.c (is_undefined_value): Assume hard registers\n+\tto be always defined.\n+\t(add_to_sets): New local function.\n+\t(create_value_expr_from): New local function.\n+\t(compute_avail): Call them.\n+\t(eliminate): Don't ignore statements with virtual operands.\n+\t(init_pre): New local function.\n+\t(fini_pre): New local function.\n+\t(execute_pre): Call them.\n+\tAdd argument DO_FRE.  Don't do insertion if DO_FRE is true.\n+\t(do_pre): New function.\n+\t(do_fre): New function.\n+\t(gate_fre): New function.\n+\t(pass_fre): Declare.\n+\t* tree-ssa.c (init_tree_ssa): Don't call vn_init.\n+\t(delete_tree_ssa): Don't call vn_delete.\n+\t* tree-vn.c (val_expr_pair_d): Add documentation.\n+\t(vn_compute): Add VUSES argument to incorporate in computing\n+\thash values.  Update all callers.\n+\t(expressions_equal_p): Call operand_equal_p with\n+\tOEP_PURE_SAME.\n+\t(vn_add): Add VUSES argument.  Update all callers.\n+\t(vn_lookup): Likewise.\n+\t(vn_lookup_or_add): Likewise.\n+\t* doc/invoke.texi: Document -ftree-fre and -fdump-tree-fre.\n+\n 2004-06-28  Steven Bosscher  <stevenb@suse.de>\n \n \t* config/m32r/m32r.c (m32r_sched_odd_word_p, m32r_adjust_cost,"}, {"sha": "3cf0ec92ec37176bdba6410225e04eddb1106511", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2ad0f77f613012b18f08ac9414de159d4971bb/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2ad0f77f613012b18f08ac9414de159d4971bb/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=ff2ad0f77f613012b18f08ac9414de159d4971bb", "patch": "@@ -773,6 +773,10 @@ ftree-dse\n Common Report Var(flag_tree_dse)\n Enable dead store elimination\n \n+ftree-fre\n+Common Report Var(flag_tree_fre)\n+Enable Full Redundancy Elimination (FRE) on trees\n+\n ftree-points-to=\n Common Joined RejectNegative\n "}, {"sha": "510eda967ba6d737ce4b38fc263172810b7ba8b9", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2ad0f77f613012b18f08ac9414de159d4971bb/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2ad0f77f613012b18f08ac9414de159d4971bb/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=ff2ad0f77f613012b18f08ac9414de159d4971bb", "patch": "@@ -262,6 +262,7 @@ in the following sections.\n -fdump-tree-copyrename@r{[}-@var{n}@r{]} @gol\n -fdump-tree-nrv @gol\n -fdump-tree-sra@r{[}-@var{n}@r{]} @gol\n+-fdump-tree-fre@r{[}-@var{n}@r{]} @gol\n -feliminate-dwarf2-dups -feliminate-unused-debug-types @gol\n -feliminate-unused-debug-symbols -fmem-report -fprofile-arcs -ftree-based-profiling @gol\n -frandom-seed=@var{string} -fsched-verbose=@var{n} @gol\n@@ -313,7 +314,7 @@ in the following sections.\n -funswitch-loops  -fold-unroll-loops  -fold-unroll-all-loops @gol\n -ftree-pre  -ftree-ccp  -ftree-dce  @gol\n -ftree-dominator-opts -ftree-dse -ftree-copyrename @gol\n--ftree-ch -ftree-sra -ftree-ter -ftree-lrs @gol\n+-ftree-ch -ftree-sra -ftree-ter -ftree-lrs -ftree-fre @gol\n --param @var{name}=@var{value}\n -O  -O0  -O1  -O2  -O3  -Os}\n \n@@ -3553,6 +3554,11 @@ Dump each function after CCP.  The file name is made by appending\n Dump trees after partial redundancy elimination.  The file name is made\n by appending @file{.pre} to the source file name.\n \n+@item fre\n+@opindex fdump-tree-fre\n+Dump trees after full redundancy elimination.  The file name is made\n+by appending @file{.fre} to the source file name.\n+\n @item dce\n @opindex fdump-tree-dce\n Dump each function after dead code elimination.  The file name is made by\n@@ -4369,6 +4375,13 @@ Enabled at levels @option{-O2}, @option{-O3}, @option{-Os}.\n Perform Partial Redundancy Elimination (PRE) on trees.  This flag is\n enabled by default at -O and higher.\n \n+@item -ftree-fre\n+Perform Full Redundancy Elimination (FRE) on trees.  The difference\n+between FRE and PRE is that FRE only considers expressions\n+that are computed on all paths leading to the redundant computation.\n+This analysis faster than PRE, though it exposes fewer redundancies.\n+This flag is enabled by default at -O and higher.\n+\n @item -ftree-ccp\n Perform sparse conditional constant propagation (CCP) on trees.  This flag\n is enabled by default at -O and higher."}, {"sha": "bc8019edf348952a10c661f5b2ab16f0c9838947", "filename": "gcc/flags.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2ad0f77f613012b18f08ac9414de159d4971bb/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2ad0f77f613012b18f08ac9414de159d4971bb/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=ff2ad0f77f613012b18f08ac9414de159d4971bb", "patch": "@@ -700,6 +700,9 @@ enum pta_type\n   };\n extern enum pta_type flag_tree_points_to;\n \n+/* Enable FRE (Full Redundancy Elimination) on trees.  */\n+extern int flag_tree_fre;\n+\n /* Nonzero means put zero initialized data in the bss section.  */\n extern int flag_zero_initialized_in_bss;\n "}, {"sha": "5a4873c80ce3c54f0a013cf367f4d8d3d148d2b8", "filename": "gcc/opts.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2ad0f77f613012b18f08ac9414de159d4971bb/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2ad0f77f613012b18f08ac9414de159d4971bb/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=ff2ad0f77f613012b18f08ac9414de159d4971bb", "patch": "@@ -495,6 +495,7 @@ decode_options (unsigned int argc, const char **argv)\n       flag_tree_live_range_split = 1;\n       flag_tree_sra = 1;\n       flag_tree_copyrename = 1;\n+      flag_tree_fre = 1;\n \n       if (!optimize_size)\n \t{"}, {"sha": "9cf957860a30682ac4d2a717dc2b7be16b239fda", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2ad0f77f613012b18f08ac9414de159d4971bb/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2ad0f77f613012b18f08ac9414de159d4971bb/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=ff2ad0f77f613012b18f08ac9414de159d4971bb", "patch": "@@ -75,6 +75,7 @@ DEFTIMEVAR (TV_TREE_SRA              , \"tree SRA\")\n DEFTIMEVAR (TV_TREE_CCP\t\t     , \"tree CCP\")\n DEFTIMEVAR (TV_TREE_SPLIT_EDGES      , \"tree split crit edges\")\n DEFTIMEVAR (TV_TREE_PRE\t\t     , \"tree PRE\")\n+DEFTIMEVAR (TV_TREE_FRE\t\t     , \"tree FRE\")\n DEFTIMEVAR (TV_TREE_PHIOPT\t     , \"tree linearize phis\")\n DEFTIMEVAR (TV_TREE_FORWPROP\t     , \"tree forward propagate\")\n DEFTIMEVAR (TV_TREE_DCE\t\t     , \"tree conservative DCE\")"}, {"sha": "48d8b34bfaaf00e7027082c1192abc2666ff5823", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2ad0f77f613012b18f08ac9414de159d4971bb/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2ad0f77f613012b18f08ac9414de159d4971bb/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=ff2ad0f77f613012b18f08ac9414de159d4971bb", "patch": "@@ -541,10 +541,20 @@ may_propagate_copy (tree dest, tree orig)\n       return false;\n     }\n \n-  return (!SSA_NAME_OCCURS_IN_ABNORMAL_PHI (dest)\n-\t  && (TREE_CODE (orig) != SSA_NAME\n-\t      || !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (orig))\n-\t  && !DECL_HARD_REGISTER (SSA_NAME_VAR (dest)));\n+  /* If ORIG flows in from an abnormal edge, it cannot be propagated.  */\n+  if (TREE_CODE (orig) == SSA_NAME\n+      && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (orig))\n+    return false;\n+\n+  /* If DEST is an SSA_NAME that flows from an abnormal edge or if it\n+     represents a hard register, then it cannot be replaced.  */\n+  if (TREE_CODE (dest) == SSA_NAME\n+      && (SSA_NAME_OCCURS_IN_ABNORMAL_PHI (dest)\n+\t  || DECL_HARD_REGISTER (SSA_NAME_VAR (dest))))\n+    return false;\n+\n+  /* Anything else is OK.  */\n+  return true;\n }\n \n /* Set the default definition for VAR to DEF.  */"}, {"sha": "0f97a5b9cf1a533efd4a71f4ca6ed33ae035c2ff", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 38, "deletions": 7, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2ad0f77f613012b18f08ac9414de159d4971bb/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2ad0f77f613012b18f08ac9414de159d4971bb/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=ff2ad0f77f613012b18f08ac9414de159d4971bb", "patch": "@@ -37,6 +37,39 @@ struct basic_block_def;\n typedef struct basic_block_def *basic_block;\n #endif\n \n+/*---------------------------------------------------------------------------\n+\t\t      Attributes for SSA_NAMEs.\n+  \n+  NOTE: These structures are stored in struct tree_ssa_name\n+  but are only used by the tree optimizers, so it makes better sense\n+  to declare them here to avoid recompiling unrelated files when\n+  making changes.\n+---------------------------------------------------------------------------*/\n+\n+/* Aliasing information for SSA_NAMEs representing pointer variables.  */\n+struct ptr_info_def GTY(())\n+{\n+  /* Nonzero if points-to analysis couldn't determine where this pointer\n+     is pointing to.  */\n+  unsigned int pt_anything : 1;\n+\n+  /* Nonzero if this pointer is the result of a call to malloc.  */\n+  unsigned int pt_malloc : 1;\n+\n+  /* Nonzero if the value of this pointer escapes the current function.  */\n+  unsigned int value_escapes_p : 1;\n+\n+  /* Set of variables that this pointer may point to.  */\n+  bitmap pt_vars;\n+\n+  /* If this pointer has been dereferenced, and points-to information is\n+     more precise than type-based aliasing, indirect references to this\n+     pointer will be represented by this memory tag, instead of the type\n+     tag computed by TBAA.  */\n+  tree name_mem_tag;\n+};\n+\n+\n /*---------------------------------------------------------------------------\n \t\t   Tree annotations stored in tree_common.ann\n ---------------------------------------------------------------------------*/\n@@ -554,8 +587,6 @@ extern void debug_dominator_optimization_stats (void);\n extern void propagate_value (use_operand_p, tree);\n extern void propagate_tree_value (tree *, tree);\n extern void replace_exp (use_operand_p, tree);\n-extern bool cprop_into_stmt (tree, varray_type);\n-extern void cprop_into_successor_phis (basic_block, varray_type, bitmap);\n \n /* In tree-flow-inline.h  */\n static inline int phi_arg_from_edge (tree, edge);\n@@ -578,12 +609,12 @@ void print_value_expressions (FILE *, tree);\n \n \n /* In tree-vn.c  */\n-bool expressions_equal_p (tree e1, tree e2);\n+bool expressions_equal_p (tree, tree);\n tree get_value_handle (tree);\n-hashval_t vn_compute (tree, hashval_t);\n-tree vn_lookup_or_add (tree);\n-void vn_add (tree, tree);\n-tree vn_lookup (tree);\n+hashval_t vn_compute (tree, hashval_t, vuse_optype);\n+tree vn_lookup_or_add (tree, vuse_optype);\n+void vn_add (tree, tree, vuse_optype);\n+tree vn_lookup (tree, vuse_optype);\n void vn_init (void);\n void vn_delete (void);\n "}, {"sha": "18c2197dbbc65491bc1bb94fb42b0a323015417f", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2ad0f77f613012b18f08ac9414de159d4971bb/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2ad0f77f613012b18f08ac9414de159d4971bb/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=ff2ad0f77f613012b18f08ac9414de159d4971bb", "patch": "@@ -131,6 +131,7 @@ extern struct tree_opt_pass pass_remove_useless_vars;\n extern struct tree_opt_pass pass_rename_ssa_copies;\n extern struct tree_opt_pass pass_expand;\n extern struct tree_opt_pass pass_rest_of_compilation;\n+extern struct tree_opt_pass pass_fre;\n \n \n #endif /* GCC_TREE_PASS_H */"}, {"sha": "12aaff81d94c55a3c5a02f28317e43b39304233a", "filename": "gcc/tree-ssa-copy.c", "status": "modified", "additions": 3, "deletions": 233, "changes": 236, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2ad0f77f613012b18f08ac9414de159d4971bb/gcc%2Ftree-ssa-copy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2ad0f77f613012b18f08ac9414de159d4971bb/gcc%2Ftree-ssa-copy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copy.c?ref=ff2ad0f77f613012b18f08ac9414de159d4971bb", "patch": "@@ -111,6 +111,7 @@ replace_exp_1 (use_operand_p op_p, tree val, bool for_propagation)\n     SET_USE (op_p, lhd_unsave_expr_now (val));\n }\n \n+\n /* Propagate the value VAL (assumed to be a constant or another SSA_NAME)\n    into the operand pointed by OP_P.\n \n@@ -123,6 +124,7 @@ propagate_value (use_operand_p op_p, tree val)\n   replace_exp_1 (op_p, val, true);\n }\n \n+\n /* Propagate the value VAL (assumed to be a constant or another SSA_NAME)\n    into the tree pointed by OP_P.\n \n@@ -144,6 +146,7 @@ propagate_tree_value (tree *op_p, tree val)\n     *op_p = lhd_unsave_expr_now (val);\n }\n \n+\n /* Replace *OP_P with value VAL (assumed to be a constant or another SSA_NAME).\n \n    Use this version when not const/copy propagating values.  For example,\n@@ -155,236 +158,3 @@ replace_exp (use_operand_p op_p, tree val)\n {\n   replace_exp_1 (op_p, val, false);\n }\n-\n-/* Replace *OP_P in STMT with any known equivalent value for *OP_P from\n-   CONST_AND_COPIES.  */\n-\n-static bool\n-cprop_operand (stmt_ann_t ann, use_operand_p op_p, varray_type const_and_copies)\n-{\n-  bool may_have_exposed_new_symbols = false;\n-  tree val;\n-  tree op = USE_FROM_PTR (op_p);\n-\n-  /* If the operand has a known constant value or it is known to be a\n-     copy of some other variable, use the value or copy stored in\n-     CONST_AND_COPIES.  */\n-  val = VARRAY_TREE (const_and_copies, SSA_NAME_VERSION (op));\n-  if (val)\n-    {\n-      tree op_type, val_type;\n-\n-      /* Do not change the base variable in the virtual operand\n-\t tables.  That would make it impossible to reconstruct\n-\t the renamed virtual operand if we later modify this\n-\t statement.  Also only allow the new value to be an SSA_NAME\n-\t for propagation into virtual operands.  */\n-      if (!is_gimple_reg (op)\n-\t  && (get_virtual_var (val) != get_virtual_var (op)\n-\t      || TREE_CODE (val) != SSA_NAME))\n-\treturn false;\n-\n-      /* Get the toplevel type of each operand.  */\n-      op_type = TREE_TYPE (op);\n-      val_type = TREE_TYPE (val);\n-\n-      /* While both types are pointers, get the type of the object\n-\t pointed to.  */\n-      while (POINTER_TYPE_P (op_type) && POINTER_TYPE_P (val_type))\n-\t{\n-\t  op_type = TREE_TYPE (op_type);\n-\t  val_type = TREE_TYPE (val_type);\n-\t}\n-\n-      /* Make sure underlying types match before propagating a\n-\t constant by converting the constant to the proper type.  Note\n-\t that convert may return a non-gimple expression, in which case\n-\t we ignore this propagation opportunity.  */\n-     if (!lang_hooks.types_compatible_p (op_type, val_type)\n-           && TREE_CODE (val) != SSA_NAME)\n-\t{\n-\t  val = fold_convert (TREE_TYPE (op), val);\n-\t  if (!is_gimple_min_invariant (val)\n-\t      && TREE_CODE (val) != SSA_NAME)\n-\t    return false;\n-\t}\n-\n-      /* Certain operands are not allowed to be copy propagated due\n-\t to their interaction with exception handling and some GCC\n-\t extensions.  */\n-      if (TREE_CODE (val) == SSA_NAME\n-\t  && !may_propagate_copy (op, val))\n-\treturn false;\n-\n-      /* Dump details.  */\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t{\n-\t  fprintf (dump_file, \"  Replaced '\");\n-\t  print_generic_expr (dump_file, op, dump_flags);\n-\t  fprintf (dump_file, \"' with %s '\",\n-\t\t   (TREE_CODE (val) != SSA_NAME ? \"constant\" : \"variable\"));\n-\t  print_generic_expr (dump_file, val, dump_flags);\n-\t  fprintf (dump_file, \"'\\n\");\n-\t}\n-\n-      /* If VAL is an ADDR_EXPR or a constant of pointer type, note\n-\t that we may have exposed a new symbol for SSA renaming.  */\n-      if (TREE_CODE (val) == ADDR_EXPR\n-\t  || (POINTER_TYPE_P (TREE_TYPE (op))\n-\t      && is_gimple_min_invariant (val)))\n-\tmay_have_exposed_new_symbols = true;\n-\n-      propagate_value (op_p, val);\n-\n-      /* And note that we modified this statement.  This is now\n-\t safe, even if we changed virtual operands since we will\n-\t rescan the statement and rewrite its operands again.  */\n-      ann->modified = 1;\n-    }\n-  return may_have_exposed_new_symbols;\n-}\n-\n-/* CONST_AND_COPIES is a table which maps an SSA_NAME to the current\n-   known value for that SSA_NAME (or NULL if no value is known).  \n-\n-   Propagate values from CONST_AND_COPIES into the uses, vuses and\n-   v_may_def_ops of STMT.  */\n-\n-bool\n-cprop_into_stmt (tree stmt, varray_type const_and_copies)\n-{\n-  bool may_have_exposed_new_symbols = false;\n-  stmt_ann_t ann = stmt_ann (stmt);\n-  size_t i, num_uses, num_vuses, num_v_may_defs;\n-  vuse_optype vuses;\n-  v_may_def_optype v_may_defs;\n-  use_optype uses;\n-\n-  uses = USE_OPS (ann);\n-  num_uses = NUM_USES (uses);\n-  for (i = 0; i < num_uses; i++)\n-    {\n-      use_operand_p op_p = USE_OP_PTR (uses, i);\n-      if (TREE_CODE (USE_FROM_PTR (op_p)) == SSA_NAME)\n-\tmay_have_exposed_new_symbols\n-\t  |= cprop_operand (ann, op_p, const_and_copies);\n-    }\n-\n-  vuses = VUSE_OPS (ann);\n-  num_vuses = NUM_VUSES (vuses);\n-  for (i = 0; i < num_vuses; i++)\n-    {\n-      use_operand_p op_p = VUSE_OP_PTR (vuses, i);\n-      if (TREE_CODE (USE_FROM_PTR (op_p)) == SSA_NAME)\n-\tmay_have_exposed_new_symbols\n-\t  |= cprop_operand (ann, op_p, const_and_copies);\n-    }\n-\n-  v_may_defs = V_MAY_DEF_OPS (ann);\n-  num_v_may_defs = NUM_V_MAY_DEFS (v_may_defs);\n-  for (i = 0; i < num_v_may_defs; i++)\n-    {\n-      use_operand_p op_p = V_MAY_DEF_OP_PTR (v_may_defs, i);\n-      if (TREE_CODE (USE_FROM_PTR (op_p)) == SSA_NAME)\n-\tmay_have_exposed_new_symbols\n-\t  |= cprop_operand (ann, op_p, const_and_copies);\n-    }\n-  return may_have_exposed_new_symbols;\n-}\n-\n-/* CONST_AND_COPIES is a table which maps an SSA_NAME to the current\n-   known value for that SSA_NAME (or NULL if no value is known).  \n-\n-   NONZERO_VARS is the set SSA_NAMES known to have a nonzero value,\n-   even if we don't know their precise value.\n-\n-   Propagate values from CONST_AND_COPIES and NONZERO_VARS into the PHI\n-   nodes of the successors of BB.  */\n-\n-void\n-cprop_into_successor_phis (basic_block bb,\n-\t\t\t   varray_type const_and_copies,\n-\t\t\t   bitmap nonzero_vars)\n-{\n-  edge e;\n-\n-  /* This can get rather expensive if the implementation is naive in\n-     how it finds the phi alternative associated with a particular edge.  */\n-  for (e = bb->succ; e; e = e->succ_next)\n-    {\n-      tree phi;\n-      int phi_num_args;\n-      int hint;\n-\n-      /* If this is an abnormal edge, then we do not want to copy propagate\n-\t into the PHI alternative associated with this edge.  */\n-      if (e->flags & EDGE_ABNORMAL)\n-\tcontinue;\n-\n-      phi = phi_nodes (e->dest);\n-      if (! phi)\n-\tcontinue;\n-\n-      /* There is no guarantee that for any two PHI nodes in a block that\n-\t the phi alternative associated with a particular edge will be\n-\t at the same index in the phi alternative array.\n-\n-\t However, it is very likely they will be the same.  So we keep\n-\t track of the index of the alternative where we found the edge in\n-\t the previous phi node and check that index first in the next\n-\t phi node.  If that hint fails, then we actually search all\n-\t the entries.  */\n-      phi_num_args = PHI_NUM_ARGS (phi);\n-      hint = phi_num_args;\n-      for ( ; phi; phi = PHI_CHAIN (phi))\n-\t{\n-\t  int i;\n-\t  tree new;\n-\t  use_operand_p orig_p;\n-\t  tree orig;\n-\n-\t  /* If the hint is valid (!= phi_num_args), see if it points\n-\t     us to the desired phi alternative.  */\n-\t  if (hint != phi_num_args && PHI_ARG_EDGE (phi, hint) == e)\n-\t    ;\n-\t  else\n-\t    {\n-\t      /* The hint was either invalid or did not point to the\n-\t\t correct phi alternative.  Search all the alternatives\n-\t\t for the correct one.  Update the hint.  */\n-\t      for (i = 0; i < phi_num_args; i++)\n-\t\tif (PHI_ARG_EDGE (phi, i) == e)\n-\t\t  break;\n-\t      hint = i;\n-\t    }\n-\n-#ifdef ENABLE_CHECKING\n-\t  /* If we did not find the proper alternative, then something is\n-\t     horribly wrong.  */\n-\t  if (hint == phi_num_args)\n-\t    abort ();\n-#endif\n-\n-\t  /* The alternative may be associated with a constant, so verify\n-\t     it is an SSA_NAME before doing anything with it.  */\n-\t  orig_p = PHI_ARG_DEF_PTR (phi, hint);\n-\t  orig = USE_FROM_PTR (orig_p);\n-\t  if (TREE_CODE (orig) != SSA_NAME)\n-\t    continue;\n-\n-\t  /* If the alternative is known to have a nonzero value, record\n-\t     that fact in the PHI node itself for future use.  */\n-\t  if (bitmap_bit_p (nonzero_vars, SSA_NAME_VERSION (orig)))\n-\t    PHI_ARG_NONZERO (phi, hint) = true;\n-\n-\t  /* If we have *ORIG_P in our constant/copy table, then replace\n-\t     ORIG_P with its value in our constant/copy table.  */\n-\t  new = VARRAY_TREE (const_and_copies, SSA_NAME_VERSION (orig));\n-\t  if (new\n-\t      && (TREE_CODE (new) == SSA_NAME\n-\t\t  || is_gimple_min_invariant (new))\n-\t      && may_propagate_copy (orig, new))\n-\t    propagate_value (orig_p, new);\n-\t}\n-    }\n-}"}, {"sha": "287807477366bea6da3198c267fb0f865236dd13", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 240, "deletions": 7, "changes": 247, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2ad0f77f613012b18f08ac9414de159d4971bb/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2ad0f77f613012b18f08ac9414de159d4971bb/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=ff2ad0f77f613012b18f08ac9414de159d4971bb", "patch": "@@ -529,14 +529,9 @@ redirect_edges_and_update_ssa_graph (varray_type redirection_edges)\n \n /* Jump threading, redundancy elimination and const/copy propagation. \n \n-   Optimize function FNDECL based on a walk through the dominator tree.\n-\n    This pass may expose new symbols that need to be renamed into SSA.  For\n    every new symbol exposed, its corresponding bit will be set in\n-   VARS_TO_RENAME.\n-\n-   PHASE indicates which dump file from the DUMP_FILES array to use when\n-   dumping debugging information.  */\n+   VARS_TO_RENAME.  */\n \n static void\n tree_ssa_dominator_optimize (void)\n@@ -2453,6 +2448,107 @@ simplify_switch_and_lookup_avail_expr (tree stmt,\n   return 0;\n }\n \n+\n+/* CONST_AND_COPIES is a table which maps an SSA_NAME to the current\n+   known value for that SSA_NAME (or NULL if no value is known).  \n+\n+   NONZERO_VARS is the set SSA_NAMES known to have a nonzero value,\n+   even if we don't know their precise value.\n+\n+   Propagate values from CONST_AND_COPIES and NONZERO_VARS into the PHI\n+   nodes of the successors of BB.  */\n+\n+static void\n+cprop_into_successor_phis (basic_block bb,\n+\t\t\t   varray_type const_and_copies,\n+\t\t\t   bitmap nonzero_vars)\n+{\n+  edge e;\n+\n+  /* This can get rather expensive if the implementation is naive in\n+     how it finds the phi alternative associated with a particular edge.  */\n+  for (e = bb->succ; e; e = e->succ_next)\n+    {\n+      tree phi;\n+      int phi_num_args;\n+      int hint;\n+\n+      /* If this is an abnormal edge, then we do not want to copy propagate\n+\t into the PHI alternative associated with this edge.  */\n+      if (e->flags & EDGE_ABNORMAL)\n+\tcontinue;\n+\n+      phi = phi_nodes (e->dest);\n+      if (! phi)\n+\tcontinue;\n+\n+      /* There is no guarantee that for any two PHI nodes in a block that\n+\t the phi alternative associated with a particular edge will be\n+\t at the same index in the phi alternative array.\n+\n+\t However, it is very likely they will be the same.  So we keep\n+\t track of the index of the alternative where we found the edge in\n+\t the previous phi node and check that index first in the next\n+\t phi node.  If that hint fails, then we actually search all\n+\t the entries.  */\n+      phi_num_args = PHI_NUM_ARGS (phi);\n+      hint = phi_num_args;\n+      for ( ; phi; phi = PHI_CHAIN (phi))\n+\t{\n+\t  int i;\n+\t  tree new;\n+\t  use_operand_p orig_p;\n+\t  tree orig;\n+\n+\t  /* If the hint is valid (!= phi_num_args), see if it points\n+\t     us to the desired phi alternative.  */\n+\t  if (hint != phi_num_args && PHI_ARG_EDGE (phi, hint) == e)\n+\t    ;\n+\t  else\n+\t    {\n+\t      /* The hint was either invalid or did not point to the\n+\t\t correct phi alternative.  Search all the alternatives\n+\t\t for the correct one.  Update the hint.  */\n+\t      for (i = 0; i < phi_num_args; i++)\n+\t\tif (PHI_ARG_EDGE (phi, i) == e)\n+\t\t  break;\n+\t      hint = i;\n+\t    }\n+\n+#ifdef ENABLE_CHECKING\n+\t  /* If we did not find the proper alternative, then something is\n+\t     horribly wrong.  */\n+\t  if (hint == phi_num_args)\n+\t    abort ();\n+#endif\n+\n+\t  /* The alternative may be associated with a constant, so verify\n+\t     it is an SSA_NAME before doing anything with it.  */\n+\t  orig_p = PHI_ARG_DEF_PTR (phi, hint);\n+\t  orig = USE_FROM_PTR (orig_p);\n+\t  if (TREE_CODE (orig) != SSA_NAME)\n+\t    continue;\n+\n+\t  /* If the alternative is known to have a nonzero value, record\n+\t     that fact in the PHI node itself for future use.  */\n+\t  if (bitmap_bit_p (nonzero_vars, SSA_NAME_VERSION (orig)))\n+\t    PHI_ARG_NONZERO (phi, hint) = true;\n+\n+\t  /* If we have *ORIG_P in our constant/copy table, then replace\n+\t     ORIG_P with its value in our constant/copy table.  */\n+\t  new = VARRAY_TREE (const_and_copies, SSA_NAME_VERSION (orig));\n+\t  if (new\n+\t      && (TREE_CODE (new) == SSA_NAME\n+\t\t  || is_gimple_min_invariant (new))\n+\t      && may_propagate_copy (orig, new))\n+\t    {\n+\t      propagate_value (orig_p, new);\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n /* Propagate known constants/copies into PHI nodes of BB's successor\n    blocks.  */\n \n@@ -2538,7 +2634,7 @@ eliminate_redundant_computations (struct dom_walk_data *walk_data,\n      CACHED_LHS into *EXPR_P.  */\n   if (cached_lhs\n       && (TREE_CODE (cached_lhs) != SSA_NAME\n-\t  || may_propagate_copy (cached_lhs, *expr_p)))\n+\t  || may_propagate_copy (*expr_p, cached_lhs)))\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n@@ -2736,6 +2832,143 @@ record_equivalences_from_stmt (tree stmt,\n     }\n }\n \n+/* Replace *OP_P in STMT with any known equivalent value for *OP_P from\n+   CONST_AND_COPIES.  */\n+\n+static bool\n+cprop_operand (stmt_ann_t ann, use_operand_p op_p, varray_type const_and_copies)\n+{\n+  bool may_have_exposed_new_symbols = false;\n+  tree val;\n+  tree op = USE_FROM_PTR (op_p);\n+\n+  /* If the operand has a known constant value or it is known to be a\n+     copy of some other variable, use the value or copy stored in\n+     CONST_AND_COPIES.  */\n+  val = VARRAY_TREE (const_and_copies, SSA_NAME_VERSION (op));\n+  if (val)\n+    {\n+      tree op_type, val_type;\n+\n+      /* Do not change the base variable in the virtual operand\n+\t tables.  That would make it impossible to reconstruct\n+\t the renamed virtual operand if we later modify this\n+\t statement.  Also only allow the new value to be an SSA_NAME\n+\t for propagation into virtual operands.  */\n+      if (!is_gimple_reg (op)\n+\t  && (get_virtual_var (val) != get_virtual_var (op)\n+\t      || TREE_CODE (val) != SSA_NAME))\n+\treturn false;\n+\n+      /* Get the toplevel type of each operand.  */\n+      op_type = TREE_TYPE (op);\n+      val_type = TREE_TYPE (val);\n+\n+      /* While both types are pointers, get the type of the object\n+\t pointed to.  */\n+      while (POINTER_TYPE_P (op_type) && POINTER_TYPE_P (val_type))\n+\t{\n+\t  op_type = TREE_TYPE (op_type);\n+\t  val_type = TREE_TYPE (val_type);\n+\t}\n+\n+      /* Make sure underlying types match before propagating a\n+\t constant by converting the constant to the proper type.  Note\n+\t that convert may return a non-gimple expression, in which case\n+\t we ignore this propagation opportunity.  */\n+     if (!lang_hooks.types_compatible_p (op_type, val_type)\n+           && TREE_CODE (val) != SSA_NAME)\n+\t{\n+\t  val = fold_convert (TREE_TYPE (op), val);\n+\t  if (!is_gimple_min_invariant (val)\n+\t      && TREE_CODE (val) != SSA_NAME)\n+\t    return false;\n+\t}\n+\n+      /* Certain operands are not allowed to be copy propagated due\n+\t to their interaction with exception handling and some GCC\n+\t extensions.  */\n+      if (TREE_CODE (val) == SSA_NAME\n+\t  && !may_propagate_copy (op, val))\n+\treturn false;\n+\n+      /* Dump details.  */\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"  Replaced '\");\n+\t  print_generic_expr (dump_file, op, dump_flags);\n+\t  fprintf (dump_file, \"' with %s '\",\n+\t\t   (TREE_CODE (val) != SSA_NAME ? \"constant\" : \"variable\"));\n+\t  print_generic_expr (dump_file, val, dump_flags);\n+\t  fprintf (dump_file, \"'\\n\");\n+\t}\n+\n+      /* If VAL is an ADDR_EXPR or a constant of pointer type, note\n+\t that we may have exposed a new symbol for SSA renaming.  */\n+      if (TREE_CODE (val) == ADDR_EXPR\n+\t  || (POINTER_TYPE_P (TREE_TYPE (op))\n+\t      && is_gimple_min_invariant (val)))\n+\tmay_have_exposed_new_symbols = true;\n+\n+      propagate_value (op_p, val);\n+\n+      /* And note that we modified this statement.  This is now\n+\t safe, even if we changed virtual operands since we will\n+\t rescan the statement and rewrite its operands again.  */\n+      ann->modified = 1;\n+    }\n+  return may_have_exposed_new_symbols;\n+}\n+\n+/* CONST_AND_COPIES is a table which maps an SSA_NAME to the current\n+   known value for that SSA_NAME (or NULL if no value is known).  \n+\n+   Propagate values from CONST_AND_COPIES into the uses, vuses and\n+   v_may_def_ops of STMT.  */\n+\n+static bool\n+cprop_into_stmt (tree stmt, varray_type const_and_copies)\n+{\n+  bool may_have_exposed_new_symbols = false;\n+  stmt_ann_t ann = stmt_ann (stmt);\n+  size_t i, num_uses, num_vuses, num_v_may_defs;\n+  vuse_optype vuses;\n+  v_may_def_optype v_may_defs;\n+  use_optype uses;\n+\n+  uses = USE_OPS (ann);\n+  num_uses = NUM_USES (uses);\n+  for (i = 0; i < num_uses; i++)\n+    {\n+      use_operand_p op_p = USE_OP_PTR (uses, i);\n+      if (TREE_CODE (USE_FROM_PTR (op_p)) == SSA_NAME)\n+\tmay_have_exposed_new_symbols\n+\t  |= cprop_operand (ann, op_p, const_and_copies);\n+    }\n+\n+  vuses = VUSE_OPS (ann);\n+  num_vuses = NUM_VUSES (vuses);\n+  for (i = 0; i < num_vuses; i++)\n+    {\n+      use_operand_p op_p = VUSE_OP_PTR (vuses, i);\n+      if (TREE_CODE (USE_FROM_PTR (op_p)) == SSA_NAME)\n+\tmay_have_exposed_new_symbols\n+\t  |= cprop_operand (ann, op_p, const_and_copies);\n+    }\n+\n+  v_may_defs = V_MAY_DEF_OPS (ann);\n+  num_v_may_defs = NUM_V_MAY_DEFS (v_may_defs);\n+  for (i = 0; i < num_v_may_defs; i++)\n+    {\n+      use_operand_p op_p = V_MAY_DEF_OP_PTR (v_may_defs, i);\n+      if (TREE_CODE (USE_FROM_PTR (op_p)) == SSA_NAME)\n+\tmay_have_exposed_new_symbols\n+\t  |= cprop_operand (ann, op_p, const_and_copies);\n+    }\n+  return may_have_exposed_new_symbols;\n+}\n+\n+\n /* Optimize the statement pointed by iterator SI.\n    \n    We try to perform some simplistic global redundancy elimination and"}, {"sha": "e9d888a684b6aa08a5485fda86036050f58825a8", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 265, "deletions": 226, "changes": 491, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2ad0f77f613012b18f08ac9414de159d4971bb/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2ad0f77f613012b18f08ac9414de159d4971bb/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=ff2ad0f77f613012b18f08ac9414de159d4971bb", "patch": "@@ -358,7 +358,7 @@ phi_trans_lookup (tree e, basic_block pred)\n   struct expr_pred_trans_d ept;\n   ept.e = e;\n   ept.pred = pred;\n-  ept.hashcode = vn_compute (e, (unsigned long) pred);\n+  ept.hashcode = vn_compute (e, (unsigned long) pred, NULL);\n   slot = htab_find_slot_with_hash (phi_translate_table, &ept, ept.hashcode,\n \t\t\t\t   NO_INSERT);\n   if (!slot)\n@@ -379,14 +379,15 @@ phi_trans_add (tree e, tree v, basic_block pred)\n   new_pair->e = e;\n   new_pair->pred = pred;\n   new_pair->v = v;\n-  new_pair->hashcode = vn_compute (e, (unsigned long) pred);\n+  new_pair->hashcode = vn_compute (e, (unsigned long) pred, NULL);\n   slot = htab_find_slot_with_hash (phi_translate_table, new_pair,\n \t\t\t\t   new_pair->hashcode, INSERT);\n   if (*slot)\n     free (*slot);\n   *slot = (void *) new_pair;\n }\n \n+\n /* Add expression E to the expression set of value V.  */\n \n void\n@@ -748,7 +749,7 @@ debug_value_set (value_set_t set, const char *setname, int blockindex)\n    part of the translated expression.  */\n \n static tree\n-phi_translate (tree expr, value_set_t set,  basic_block pred,\n+phi_translate (tree expr, value_set_t set, basic_block pred,\n \t       basic_block phiblock)\n {\n   tree phitrans = NULL;\n@@ -788,7 +789,7 @@ phi_translate (tree expr, value_set_t set,  basic_block pred,\n \t    create_tree_ann (newexpr);\n \t    TREE_OPERAND (newexpr, 0) = newop1 == oldop1 ? oldop1 : get_value_handle (newop1);\n \t    TREE_OPERAND (newexpr, 1) = newop2 == oldop2 ? oldop2 : get_value_handle (newop2);\n-\t    vn_lookup_or_add (newexpr);\n+\t    vn_lookup_or_add (newexpr, NULL);\n \t    expr = newexpr;\n \t    phi_trans_add (oldexpr, newexpr, pred);\t    \n \t  }\n@@ -815,7 +816,7 @@ phi_translate (tree expr, value_set_t set,  basic_block pred,\n \t    memcpy (newexpr, expr, tree_size (expr));\n \t    create_tree_ann (newexpr);\t \n \t    TREE_OPERAND (newexpr, 0) = get_value_handle (newop1);\n-\t    vn_lookup_or_add (newexpr);\n+\t    vn_lookup_or_add (newexpr, NULL);\n \t    expr = newexpr;\n \t    phi_trans_add (oldexpr, newexpr, pred);\n \t  }\n@@ -840,7 +841,7 @@ phi_translate (tree expr, value_set_t set,  basic_block pred,\n \t      tree val;\n \t      if (is_undefined_value (PHI_ARG_DEF (phi, i)))\n \t\treturn NULL;\n-\t      val = vn_lookup_or_add (PHI_ARG_DEF (phi, i));\n+\t      val = vn_lookup_or_add (PHI_ARG_DEF (phi, i), NULL);\n \t      return PHI_ARG_DEF (phi, i);\n \t    }\n       }\n@@ -867,7 +868,7 @@ phi_translate_set (value_set_t dest, value_set_t set, basic_block pred,\n     } \n }\n \n-/* Find the leader for a value (IE the name representing that\n+/* Find the leader for a value (i.e., the name representing that\n    value) in a given set, and return it.  Return NULL if no leader is\n    found.  */\n \n@@ -878,9 +879,11 @@ find_leader (value_set_t set, tree val)\n \n   if (val == NULL)\n     return NULL;\n+\n   /* True constants represent themselves.  */\n   if (TREE_CODE_CLASS (TREE_CODE (val)) == 'c')\n     return val;\n+\n   /* Invariants are still represented by values, since they may be\n      more than a single _CST node.  */  \n   if (TREE_CONSTANT (val))\n@@ -899,6 +902,7 @@ find_leader (value_set_t set, tree val)\n \t    return node->expr;\n \t}\n     }\n+\n   return NULL;\n }\n \n@@ -1241,7 +1245,7 @@ create_expression_by_pieces (basic_block block, tree expr, tree stmts)\n       \n     }\n   v = get_value_handle (expr);\n-  vn_add (name, v);\n+  vn_add (name, v, NULL);\n   insert_into_set (NEW_SETS (block), name);\n   value_insert_into_set (AVAIL_OUT (block), name);\n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -1406,7 +1410,7 @@ insert_aux (basic_block block)\n \t\t\t  temp = create_tmp_var (type, \"prephitmp\");\n \t\t\t  add_referenced_tmp_var (temp);\n \t\t\t  temp = create_phi_node (temp, block);\n-\t\t\t  vn_add (PHI_RESULT (temp), val);\n+\t\t\t  vn_add (PHI_RESULT (temp), val, NULL);\n \n #if 0\n \t\t\t  if (!set_contains_value (AVAIL_OUT (block), val))\n@@ -1476,41 +1480,95 @@ insert (void)\n }\n \n \n-/* Return true if EXPR has no defining statement in this procedure,\n-   *AND* isn't a live-on-entry parameter.  */\n+/* Return true if VAR is an SSA variable with no defining statement in\n+   this procedure, *AND* isn't a live-on-entry parameter.  */\n \n static bool\n is_undefined_value (tree expr)\n-{  \n-#ifdef ENABLE_CHECKING\n-  /* We should never be handed DECL's  */\n-  if (DECL_P (expr))\n+{\n+  return (TREE_CODE (expr) == SSA_NAME\n+          && IS_EMPTY_STMT (SSA_NAME_DEF_STMT (expr))\n+\t  /* PARM_DECLs and hard registers are always defined.  */\n+\t  && TREE_CODE (SSA_NAME_VAR (expr)) != PARM_DECL\n+\t  && !DECL_HARD_REGISTER (SSA_NAME_VAR (expr)));\n+}\n+\n+\n+/* Given an SSA variable VAR and an expression EXPR, compute the value\n+   number for EXPR and create a value handle (VAL) for it.  If VAR and\n+   EXPR are not the same, associate VAL with VAR.  Finally, add VAR to\n+   S1 and its value handle to S2.\n+\n+   VUSES represent the virtual use operands associated with EXPR (if\n+   any). They are used when computing the hash value for EXPR.  */\n+\n+static inline void\n+add_to_sets (tree var, tree expr, vuse_optype vuses, value_set_t s1,\n+\t     value_set_t s2)\n+{\n+  tree val = vn_lookup_or_add (expr, vuses);\n+\n+  /* VAR and EXPR may be the same when processing statements for which\n+     we are not computing value numbers (e.g., non-assignments, or\n+     statements that make aliased stores).  In those cases, we are\n+     only interested in making VAR available as its own value.  */\n+  if (var != expr)\n+    vn_add (var, val, vuses);\n+\n+  insert_into_set (s1, var);\n+  value_insert_into_set (s2, var);\n+}\n+\n+\n+/* Given a unary or binary expression EXPR, create and return a new\n+   expresion with the same structure as EXPR but with its operands\n+   replaced with the value handles of each of the operands of EXPR.\n+   Insert EXPR's operands into the EXP_GEN set for BLOCK.\n+\n+   VUSES represent the virtual use operands associated with EXPR (if\n+   any). They are used when computing the hash value for EXPR.  */\n+\n+static inline tree\n+create_value_expr_from (tree expr, basic_block block, vuse_optype vuses)\n+{\n+  int i;\n+  enum tree_code code = TREE_CODE (expr);\n+  tree vexpr;\n+\n+#if defined ENABLE_CHECKING\n+  if (TREE_CODE_CLASS (code) != '1'\n+      && TREE_CODE_CLASS (code) != '2')\n     abort ();\n #endif\n \n-  if (TREE_CODE (expr) == SSA_NAME)\n+  if (TREE_CODE_CLASS (code) == '1')\n+    vexpr = pool_alloc (unary_node_pool);\n+  else\n+    vexpr = pool_alloc (binary_node_pool);\n+\n+  memcpy (vexpr, expr, tree_size (expr));\n+\n+  for (i = 0; i < TREE_CODE_LENGTH (code); i++)\n     {\n-      /* XXX: Is this the correct test?  */\n-      if (TREE_CODE (SSA_NAME_VAR (expr)) == PARM_DECL)\n-\treturn false;\n-      if (IS_EMPTY_STMT (SSA_NAME_DEF_STMT (expr)))\n-\treturn true;\n+      tree op = TREE_OPERAND (expr, i);\n+      tree val = vn_lookup_or_add (op, vuses);\n+      if (!is_undefined_value (op))\n+\tvalue_insert_into_set (EXP_GEN (block), op);\n+      TREE_OPERAND (vexpr, i) = val;\n     }\n \n-  return false;\n+  return vexpr;\n }\n \n+\n /* Compute the AVAIL set for BLOCK.\n    This function performs value numbering of the statements in BLOCK. \n    The AVAIL sets are built from information we glean while doing this\n-   value numbering, since the AVAIL sets contain only entry per\n+   value numbering, since the AVAIL sets contain only one entry per\n    value.\n-\n    \n    AVAIL_IN[BLOCK] = AVAIL_OUT[dom(BLOCK)].\n-   AVAIL_OUT[BLOCK] = AVAIL_IN[BLOCK] U PHI_GEN[BLOCK] U\n-   TMP_GEN[BLOCK].\n-*/\n+   AVAIL_OUT[BLOCK] = AVAIL_IN[BLOCK] U PHI_GEN[BLOCK] U TMP_GEN[BLOCK].  */\n \n static void\n compute_avail (basic_block block)\n@@ -1530,7 +1588,7 @@ compute_avail (basic_block block)\n \t    {\n \t      tree val;\n \t      tree def = default_def (param);\n-\t      val = vn_lookup_or_add (def);\n+\t      val = vn_lookup_or_add (def, NULL);\n \t      insert_into_set (TMP_GEN (block), def);\n \t      value_insert_into_set (AVAIL_OUT (block), def);\n \t    }\n@@ -1542,169 +1600,91 @@ compute_avail (basic_block block)\n       tree stmt, phi;\n       basic_block dom;\n \n+      /* Initially, the set of available values in BLOCK is that of\n+\t its immediate dominator.  */\n       dom = get_immediate_dominator (CDI_DOMINATORS, block);\n       if (dom)\n \tset_copy (AVAIL_OUT (block), AVAIL_OUT (dom));\n \n+      /* Generate values for PHI nodes.  */\n       for (phi = phi_nodes (block); phi; phi = PHI_CHAIN (phi))\n-\t{\n-\t  /* Ignore virtual PHIs until we can do PRE on expressions\n-\t     with virtual operands.  */\n-\t  if (!is_gimple_reg (SSA_NAME_VAR (PHI_RESULT (phi))))\n-\t    continue;\n-\n-\t  vn_lookup_or_add (PHI_RESULT (phi));\n-\t  value_insert_into_set (AVAIL_OUT (block), PHI_RESULT (phi));\n-\t  insert_into_set (PHI_GEN (block), PHI_RESULT (phi));\n-\t}\n+\tadd_to_sets (PHI_RESULT (phi), PHI_RESULT (phi), NULL,\n+\t\t     PHI_GEN (block), AVAIL_OUT (block));\n \n+      /* Now compute value numbers and populate value sets with all\n+\t the expressions computed in BLOCK.  */\n       for (bsi = bsi_start (block); !bsi_end_p (bsi); bsi_next (&bsi))\n \t{\n-\t  tree op0, op1;\n+\t  stmt_ann_t ann;\n+\t  size_t j;\n+\n \t  stmt = bsi_stmt (bsi);\n+\t  ann = stmt_ann (stmt);\n \t  get_stmt_operands (stmt);\n-\t  \n-\t  if (NUM_VUSES (STMT_VUSE_OPS (stmt))\n-\t      || NUM_V_MUST_DEFS (STMT_V_MUST_DEF_OPS (stmt))\n-\t      || NUM_V_MAY_DEFS (STMT_V_MAY_DEF_OPS (stmt))\n-\t      || stmt_ann (stmt)->has_volatile_ops)\n+\n+\t  /* We are only interested in assignments of the form\n+\t     X_i = EXPR, where EXPR represents an \"interesting\"\n+\t     computation, it has no volatile operands and X_i\n+\t     doesn't flow through an abnormal edge.  */\n+\t  if (TREE_CODE (stmt) == MODIFY_EXPR\n+\t      && !ann->has_volatile_ops\n+\t      && TREE_CODE (TREE_OPERAND (stmt, 0)) == SSA_NAME\n+\t      && !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (TREE_OPERAND (stmt, 0)))\n \t    {\n-\t      size_t j;\n-\t      for (j = 0; j < NUM_DEFS (STMT_DEF_OPS (stmt)); j++)\n+\t      tree lhs = TREE_OPERAND (stmt, 0);\n+\t      tree rhs = TREE_OPERAND (stmt, 1);\n+\t      vuse_optype vuses = STMT_VUSE_OPS (stmt);\n+\n+\t      STRIP_USELESS_TYPE_CONVERSION (rhs);\n+\n+\t      if (TREE_CODE_CLASS (TREE_CODE (rhs)) == '1'\n+\t\t  || TREE_CODE_CLASS (TREE_CODE (rhs)) == '2')\n \t\t{\n-\t\t  tree def = DEF_OP (STMT_DEF_OPS (stmt), j);\n-\t\t  vn_lookup_or_add (def);\n-\t\t  insert_into_set (TMP_GEN (block), def);\n-\t\t  value_insert_into_set (AVAIL_OUT (block), def);\n+\t\t  /* For binary and unary expressions, create a duplicate\n+\t\t     expression with the operands replaced with the value\n+\t\t     handles of the original RHS.  */\n+\t\t  tree newt = create_value_expr_from (rhs, block, vuses);\n+\t\t  add_to_sets (lhs, newt, vuses, TMP_GEN (block),\n+\t\t\t       AVAIL_OUT (block));\n+\t\t  value_insert_into_set (EXP_GEN (block), newt);\n+\t\t  continue;\n \t\t}\n-\t      for (j = 0; j < NUM_USES (STMT_USE_OPS (stmt)); j++)\n+\t      else if (TREE_CODE (rhs) == SSA_NAME\n+\t\t       || is_gimple_min_invariant (rhs))\n \t\t{\n-\t\t  tree use = USE_OP (STMT_USE_OPS (stmt), j);\n-\t\t  if (TREE_CODE (use) == SSA_NAME)\n-\t\t    {\n-\t\t      vn_lookup_or_add (use);\n-\t\t      insert_into_set (TMP_GEN (block), use);\n-\t\t      value_insert_into_set (AVAIL_OUT (block), use);\n-\t\t    }\n+\t\t  /* Compute a value number for the RHS of the statement\n+\t\t    and add its value to the AVAIL_OUT set for the block.\n+\t\t    Add the LHS to TMP_GEN.  */\n+\t\t  add_to_sets (lhs, rhs, vuses, TMP_GEN (block), \n+\t\t\t       AVAIL_OUT (block));\n+\n+\t\t  if (TREE_CODE (rhs) == SSA_NAME\n+\t\t      && !is_undefined_value (rhs))\n+\t\t    value_insert_into_set (EXP_GEN (block), rhs);\n+\t\t  continue;\n \t\t}\n-\t      continue;\n \t    }\n \n-\t  if (TREE_CODE (stmt) == MODIFY_EXPR)\n+\t  /* For any other statement that we don't recognize, simply\n+\t     make the names generated by the statement available in\n+\t     AVAIL_OUT and TMP_GEN.  */\n+\t  for (j = 0; j < NUM_DEFS (STMT_DEF_OPS (stmt)); j++)\n \t    {\n-\t      op0 = TREE_OPERAND (stmt, 0);\n-\t      if (TREE_CODE (op0) != SSA_NAME)\n-\t\tcontinue;\n-\t      if (SSA_NAME_OCCURS_IN_ABNORMAL_PHI (op0))\n-\t\tcontinue;\n-\t      op1 = TREE_OPERAND (stmt, 1);\n-\t      STRIP_USELESS_TYPE_CONVERSION (op1);\n-\t      if (is_gimple_min_invariant (op1))\n-\t\t{\n-\t\t  vn_add (op0, vn_lookup_or_add (op1));\n-\t\t  insert_into_set (TMP_GEN (block), op0);\n-\t\t  value_insert_into_set (AVAIL_OUT (block), op0);\n-\t\t}\n-\t      else if (TREE_CODE_CLASS (TREE_CODE (op1)) == '2')\n-\t\t{\n-\t\t  tree bop1, bop2;\n-\t\t  tree val, val1, val2;\n-\t\t  tree newt;\n-\t\t  bop1 = TREE_OPERAND (op1, 0);\n-\t\t  bop2 = TREE_OPERAND (op1, 1);\n-\t\t  val1 = vn_lookup_or_add (bop1);\n-\t\t  val2 = vn_lookup_or_add (bop2);\n- \n-\t\t  newt = pool_alloc (binary_node_pool);\n-\t\t  memcpy (newt, op1, tree_size (op1));\n-\t\t  TREE_OPERAND (newt, 0) = val1;\n-\t\t  TREE_OPERAND (newt, 1) = val2;\n-\t\t  val = vn_lookup_or_add (newt);\n-\t\t  vn_add (op0, val);\n-\t\t  if (!is_undefined_value (bop1))\n-\t\t    value_insert_into_set (EXP_GEN (block), bop1);\n-\t\t  if (!is_undefined_value (bop2))\n-\t\t    value_insert_into_set (EXP_GEN (block), bop2);\n-\t\t  value_insert_into_set (EXP_GEN (block), newt);\n-\t\t  insert_into_set (TMP_GEN (block), op0);\n-\t\t  value_insert_into_set (AVAIL_OUT (block), op0);  \n-\t\t}\n-\t      else if (TREE_CODE_CLASS (TREE_CODE (op1)) == '1'\n-\t\t       && !is_gimple_cast (op1))\n-\t\t{\n-\t\t  tree uop;\n-\t\t  tree val, val1;\n-\t\t  tree newt;\n-\t\t  uop = TREE_OPERAND (op1, 0);\n-\t\t  val1 = vn_lookup_or_add (uop);\n-\t\t  newt = pool_alloc (unary_node_pool);\n-\t\t  memcpy (newt, op1, tree_size (op1));\n-\t\t  TREE_OPERAND (newt, 0) = val1;\n-\t\t  val = vn_lookup_or_add (newt);\n-\t\t  vn_add (op0, val);\n-\t\t  if (!is_undefined_value (uop))\n-\t\t    value_insert_into_set (EXP_GEN (block), uop);\n-\t\t  value_insert_into_set (EXP_GEN (block), newt);\n-\t\t  insert_into_set (TMP_GEN (block), op0);\n-\t\t  value_insert_into_set (AVAIL_OUT (block), op0);\n-\t\t}\n-\t      else if (TREE_CODE (op1) == SSA_NAME)\n-\t\t{\n-\t\t  tree val = vn_lookup_or_add (op1);\n-\t\t  vn_add (op0, val);\n-\t\t  if (!is_undefined_value (op1))\n-\t\t    value_insert_into_set (EXP_GEN (block), op1);\n-\t\t  insert_into_set (TMP_GEN (block), op0);\n-\t\t  value_insert_into_set (AVAIL_OUT (block), op0);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  size_t j;\n-\t\t  for (j = 0; j < NUM_DEFS (STMT_DEF_OPS (stmt)); j++)\n-\t\t    {\n-\t\t      tree def = DEF_OP (STMT_DEF_OPS (stmt), j);\n-\t\t      vn_lookup_or_add (def);\n-\t\t      insert_into_set (TMP_GEN (block), def);\n-\t\t      value_insert_into_set (AVAIL_OUT (block), def);\n-\t\t      if (def != op0)\n-\t\t\tabort ();\n-\t\t    }\n-\t\t  for (j = 0; j < NUM_USES (STMT_USE_OPS (stmt)); j++)\n-\t\t    {\n-\t\t      tree use = USE_OP (STMT_USE_OPS (stmt), j);\n-\t\t      if (TREE_CODE (use) == SSA_NAME)\n-\t\t\t{\n-\t\t\t  vn_lookup_or_add (use);\n-\t\t\t  insert_into_set (TMP_GEN (block), use);\n-\t\t\t  value_insert_into_set (AVAIL_OUT (block), use);\n-\t\t\t}\n-\t\t    }\n-\t\t}\n+\t      tree def = DEF_OP (STMT_DEF_OPS (stmt), j);\n+\t      add_to_sets (def, def, NULL, TMP_GEN (block),\n+\t\t\t    AVAIL_OUT (block));\n \t    }\n-\t  else\n+\n+\t  for (j = 0; j < NUM_USES (STMT_USE_OPS (stmt)); j++)\n \t    {\n-\t      size_t j;\n-\t      for (j = 0; j < NUM_DEFS (STMT_DEF_OPS (stmt)); j++)\n-\t\t{\n-\t\t  tree def = DEF_OP (STMT_DEF_OPS (stmt), j);\n-\t\t  vn_lookup_or_add (def);\n-\t\t  insert_into_set (TMP_GEN (block), def);\n-\t\t  value_insert_into_set (AVAIL_OUT (block), def);\n-\t\t}\n-\t      for (j = 0; j < NUM_USES (STMT_USE_OPS (stmt)); j++)\n-\t\t{\n-\t\t  tree use = USE_OP (STMT_USE_OPS (stmt), j);\n-\t\t  if (TREE_CODE (use) == SSA_NAME)\n-\t\t    {\n-\t\t      vn_lookup_or_add (use);\n-\t\t      insert_into_set (TMP_GEN (block), use);\n-\t\t      value_insert_into_set (AVAIL_OUT (block), use);\n-\t\t    }\n-\t\t}\n+\t      tree use = USE_OP (STMT_USE_OPS (stmt), j);\n+\t      add_to_sets (use, use, NULL, TMP_GEN (block),\n+\t\t\t    AVAIL_OUT (block));\n \t    }\n \t}\n     }\n \n+  /* Compute available sets for the dominator children of BLOCK.  */\n   for (son = first_dom_son (CDI_DOMINATORS, block);\n        son;\n        son = next_dom_son (CDI_DOMINATORS, son))\n@@ -1727,77 +1707,70 @@ eliminate (void)\n         {\n           tree stmt = bsi_stmt (i);\n \n-          if (NUM_VUSES (STMT_VUSE_OPS (stmt))\n-              || NUM_V_MUST_DEFS (STMT_V_MUST_DEF_OPS (stmt))\n-\t      || NUM_V_MAY_DEFS (STMT_V_MAY_DEF_OPS (stmt))\n-\t      || stmt_ann (stmt)->has_volatile_ops)\n-            continue;\n-\n-          /* Lookup the RHS of the expression, see if we have an\n-\t     available computation for it. If so, replace the RHS with\n+\t  /* Lookup the RHS of the expression, see if we have an\n+\t     available computation for it.  If so, replace the RHS with\n \t     the available computation.  */\n-\t  if (TREE_CODE (stmt) == MODIFY_EXPR)\n-            {\n-              tree t = TREE_OPERAND (stmt, 0);\n-              tree expr = TREE_OPERAND (stmt, 1);\n-              tree sprime;\n-\t      /* There is no point in eliminating NOP_EXPR, it isn't\n-\t\t supposed to generate any code.  */\n-\t      if (TREE_CODE (expr) == NOP_EXPR\n-\t\t  || (TREE_CODE_CLASS (TREE_CODE (expr)) != '2' \n-\t\t   && TREE_CODE_CLASS (TREE_CODE (expr)) != '1'))\n-\t\tcontinue;\n-\n-\t      sprime = find_leader (AVAIL_OUT (b), vn_lookup (t));\n-              if (sprime \n-\t\t  && sprime != t \n-\t\t  && may_propagate_copy (sprime, TREE_OPERAND (stmt, 1)))\n-                {\n+\t  if (TREE_CODE (stmt) == MODIFY_EXPR\n+\t      && TREE_CODE (TREE_OPERAND (stmt, 0)) == SSA_NAME\n+\t      && TREE_CODE (TREE_OPERAND (stmt ,1)) != SSA_NAME\n+\t      && !is_gimple_min_invariant (TREE_OPERAND (stmt, 1))\n+\t      && !stmt_ann (stmt)->has_volatile_ops)\n+\t    {\n+\t      tree lhs = TREE_OPERAND (stmt, 0);\n+\t      tree *rhs_p = &TREE_OPERAND (stmt, 1);\n+\t      tree sprime;\n+\t      vuse_optype vuses = STMT_VUSE_OPS (stmt);\n+\n+\t      sprime = find_leader (AVAIL_OUT (b), vn_lookup (lhs, vuses));\n+\t      if (sprime \n+\t\t  && sprime != lhs\n+\t\t  && (TREE_CODE (*rhs_p) != SSA_NAME\n+\t\t      || may_propagate_copy (*rhs_p, sprime)))\n+\t\t{\n+\t\t  if (sprime == *rhs_p)\n+\t\t    abort ();\n+\n \t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t\t    {\n \t\t      fprintf (dump_file, \"Replaced \");\n-\t\t      print_generic_expr (dump_file, expr, 0);\n+\t\t      print_generic_expr (dump_file, *rhs_p, 0);\n \t\t      fprintf (dump_file, \" with \");\n \t\t      print_generic_expr (dump_file, sprime, 0);\n \t\t      fprintf (dump_file, \" in \");\n \t\t      print_generic_stmt (dump_file, stmt, 0);\n \t\t    }\n \t\t  pre_stats.eliminations++;\n-                  propagate_tree_value (&TREE_OPERAND (stmt, 1), sprime);\n-                  modify_stmt (stmt);\n-                }\n-            }\n+\t\t  propagate_tree_value (rhs_p, sprime);\n+\t\t  modify_stmt (stmt);\n+\t\t}\n+\t    }\n         }\n     }\n }\n \n \n-/* Main entry point to the SSA-PRE pass.\n-\n-   PHASE indicates which dump file from the DUMP_FILES array to use when\n-   dumping debugging information.  */\n+/* Initialize data structures used by PRE.  */\n \n static void\n-execute_pre (void)\n+init_pre (void)\n {\n   size_t tsize;\n   basic_block bb;\n+\n+  vn_init ();\n   memset (&pre_stats, 0, sizeof (pre_stats));\n   FOR_ALL_BB (bb)\n-    {\n-      bb->aux = xcalloc (1, sizeof (struct bb_value_sets));\n-    }\n+    bb->aux = xcalloc (1, sizeof (struct bb_value_sets));\n+\n   phi_translate_table = htab_create (511, expr_pred_trans_hash,\n-\t\t\t\t     expr_pred_trans_eq,\n-\t\t\t\t     free);\n+\t\t\t\t     expr_pred_trans_eq, free);\n   value_set_pool = create_alloc_pool (\"Value sets\",\n \t\t\t\t      sizeof (struct value_set), 30);\n   value_set_node_pool = create_alloc_pool (\"Value set nodes\",\n-\t\t\t\t       sizeof (struct value_set_node), 30);\n+\t\t\t\t           sizeof (struct value_set_node), 30);\n   calculate_dominance_info (CDI_POST_DOMINATORS);\n   calculate_dominance_info (CDI_DOMINATORS);\n-  tsize = tree_size (build (PLUS_EXPR, void_type_node, NULL_TREE,\n-\t\t\t    NULL_TREE));\n+  tsize = tree_size (build (PLUS_EXPR, void_type_node, NULL_TREE, NULL_TREE));\n   binary_node_pool = create_alloc_pool (\"Binary tree nodes\", tsize, 30);\n   tsize = tree_size (build1 (NEGATE_EXPR, void_type_node, NULL_TREE));\n   unary_node_pool = create_alloc_pool (\"Unary tree nodes\", tsize, 30);\n@@ -1809,11 +1782,48 @@ execute_pre (void)\n       TMP_GEN (bb) = set_new (false);\n       AVAIL_OUT (bb) = set_new (true);\n     }\n+}\n+\n+\n+/* Deallocate data structures used by PRE.  */\n \n+static void\n+fini_pre (void)\n+{\n+  basic_block bb;\n+\n+  free_alloc_pool (value_set_pool);\n+  free_alloc_pool (value_set_node_pool);\n+  free_alloc_pool (binary_node_pool);\n+  free_alloc_pool (unary_node_pool);\n+  htab_delete (phi_translate_table);\n+  \n+  FOR_ALL_BB (bb)\n+    {\n+      free (bb->aux);\n+      bb->aux = NULL;\n+    }\n+  free_dominance_info (CDI_POST_DOMINATORS);\n+  vn_delete ();\n+}\n+\n+\n+/* Main entry point to the SSA-PRE pass.  DO_FRE is true if the caller\n+   only wants to do full redundancy elimination.  */\n+\n+static void\n+execute_pre (bool do_fre)\n+{\n+  init_pre ();\n+\n+  /* Collect and value number expressions computed in each basic\n+     block.  */\n   compute_avail (ENTRY_BLOCK_PTR);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n+      basic_block bb;\n+\n       FOR_ALL_BB (bb)\n \t{\n \t  print_value_set (dump_file, EXP_GEN (bb), \"exp_gen\", bb->index);\n@@ -1827,13 +1837,13 @@ execute_pre (void)\n      fixed, don't run it when he have an incredibly large number of\n      bb's.  If we aren't going to run insert, there is no point in\n      computing ANTIC, either, even though it's plenty fast.  */\n- \n-  if (n_basic_blocks < 4000)\n+  if (!do_fre && n_basic_blocks < 4000)\n     {\n       compute_antic ();\n-      \n       insert ();\n     }\n+\n+  /* Remove all the redundant expressions.  */\n   eliminate ();\n   \n   if (dump_file && (dump_flags & TDF_STATS))\n@@ -1843,18 +1853,16 @@ execute_pre (void)\n       fprintf (dump_file, \"Eliminated:%d\\n\", pre_stats.eliminations);\n     }\n \n-  free_alloc_pool (value_set_pool);\n-  free_alloc_pool (value_set_node_pool);\n-  free_alloc_pool (binary_node_pool);\n-  free_alloc_pool (unary_node_pool);\n-  htab_delete (phi_translate_table);\n-  \n-  FOR_ALL_BB (bb)\n-    {\n-      free (bb->aux);\n-      bb->aux = NULL;\n-    }\n-  free_dominance_info (CDI_POST_DOMINATORS);\n+  fini_pre ();\n+}\n+\n+\n+/* Gate and execute functions for PRE.  */\n+\n+static void\n+do_pre (void)\n+{\n+  execute_pre (false);\n }\n \n static bool\n@@ -1867,7 +1875,7 @@ struct tree_opt_pass pass_pre =\n {\n   \"pre\",\t\t\t\t/* name */\n   gate_pre,\t\t\t\t/* gate */\n-  execute_pre,\t\t\t\t/* execute */\n+  do_pre,\t\t\t\t/* execute */\n   NULL,\t\t\t\t\t/* sub */\n   NULL,\t\t\t\t\t/* next */\n   0,\t\t\t\t\t/* static_pass_number */\n@@ -1878,3 +1886,34 @@ struct tree_opt_pass pass_pre =\n   0,\t\t\t\t\t/* todo_flags_start */\n   TODO_dump_func | TODO_ggc_collect | TODO_verify_ssa /* todo_flags_finish */\n };\n+\n+\n+/* Gate and execute functions for FRE.  */\n+\n+static void\n+do_fre (void)\n+{\n+  execute_pre (true);\n+}\n+\n+static bool\n+gate_fre (void)\n+{\n+  return flag_tree_fre != 0;\n+}\n+\n+struct tree_opt_pass pass_fre =\n+{\n+  \"fre\",\t\t\t\t/* name */\n+  gate_fre,\t\t\t\t/* gate */\n+  do_fre,\t\t\t\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  TV_TREE_FRE,\t\t\t\t/* tv_id */\n+  PROP_no_crit_edges | PROP_cfg | PROP_ssa,/* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  TODO_dump_func | TODO_ggc_collect | TODO_verify_ssa /* todo_flags_finish */\n+};"}, {"sha": "a931d9f7fef6c769919e568aff7f4adb37dedfba", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2ad0f77f613012b18f08ac9414de159d4971bb/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2ad0f77f613012b18f08ac9414de159d4971bb/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=ff2ad0f77f613012b18f08ac9414de159d4971bb", "patch": "@@ -497,7 +497,6 @@ init_tree_ssa (void)\n   init_ssa_operands ();\n   init_ssanames ();\n   init_phinodes ();\n-  vn_init ();\n   global_var = NULL_TREE;\n   aliases_computed_p = false;\n }\n@@ -528,7 +527,6 @@ delete_tree_ssa (void)\n   fini_ssanames ();\n   fini_phinodes ();\n   fini_ssa_operands ();\n-  vn_delete ();\n \n   global_var = NULL_TREE;\n   BITMAP_XFREE (call_clobbered_vars);"}, {"sha": "d83f75c3a6111d309484299b7898847b6afa5c92", "filename": "gcc/tree-vn.c", "status": "modified", "additions": 76, "deletions": 33, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2ad0f77f613012b18f08ac9414de159d4971bb/gcc%2Ftree-vn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2ad0f77f613012b18f08ac9414de159d4971bb/gcc%2Ftree-vn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vn.c?ref=ff2ad0f77f613012b18f08ac9414de159d4971bb", "patch": "@@ -42,7 +42,16 @@ static htab_t value_table;\n    pairs, and the expression is the key.  */\n typedef struct val_expr_pair_d\n {\n-  tree v, e;\n+  /* Value handle.  */\n+  tree v;\n+\n+  /* Associated expression.  */\n+  tree e;\n+\n+  /* Virtual uses in E.  */\n+  vuse_optype vuses;\n+\n+  /* E's hash value.  */\n   hashval_t hashcode;\n } *val_expr_pair_t;\n \n@@ -63,13 +72,37 @@ make_value_handle (tree type)\n }\n \n \n-/* Given an expression or statement P, compute a hash value number using the\n-   code of the expression and its real operands.  */\n+/* Given an expression EXPR, compute a hash value number using the\n+   code of the expression, its real operands and virtual operands (if\n+   any).\n+   \n+   VAL can be used to iterate by passing previous value numbers (it is\n+   used by iterative_hash_expr).\n+\n+   VUSES is the set of virtual use operands associated with EXPR.  It\n+   may be NULL if EXPR has no virtual operands.  */\n \n hashval_t\n-vn_compute (tree expr, hashval_t val)\n+vn_compute (tree expr, hashval_t val, vuse_optype vuses)\n {\n+  size_t i;\n+\n+#if defined ENABLE_CHECKING\n+  /* EXPR must not be a statement.  We are only interested in value\n+     numbering expressions on the RHS of assignments.  */\n+  if (expr == NULL_TREE\n+      || (expr->common.ann\n+\t  && expr->common.ann->common.type == STMT_ANN))\n+    abort ();\n+#endif\n+\n   val = iterative_hash_expr (expr, val);\n+\n+  /* If the expression has virtual uses, incorporate them into the\n+     hash value computed for EXPR.  */\n+  for (i = 0; i < NUM_VUSES (vuses); i++)\n+    val = iterative_hash_expr (VUSE_OP (vuses, i), val);\n+\n   return val;\n }\n \n@@ -90,7 +123,7 @@ expressions_equal_p (tree e1, tree e2)\n \n   if (TREE_CODE (e1) == TREE_CODE (e2) \n       && (te1 == te2 || lang_hooks.types_compatible_p (te1, te2))\n-      && operand_equal_p (e1, e2, 0))\n+      && operand_equal_p (e1, e2, OEP_PURE_SAME))\n     return true;\n \n   return false;\n@@ -143,41 +176,49 @@ set_value_handle (tree e, tree v)\n }\n \n \n-/* Insert E into VALUE_TABLE with value V, and add expression E to the\n-   value set for value V.  */\n+/* Insert EXPR into VALUE_TABLE with value VAL, and add expression\n+   EXPR to the value set for value VAL.  VUSES represent the virtual\n+   use operands associated with EXPR (if any).  They are used when\n+   computing the hash value for EXPR.  */\n \n void\n-vn_add (tree e, tree v)\n+vn_add (tree expr, tree val, vuse_optype vuses)\n {\n   void **slot;\n-  val_expr_pair_t new_pair = xmalloc (sizeof (struct val_expr_pair_d));\n-  new_pair->e = e;\n-  new_pair->v = v;\n-  new_pair->hashcode = vn_compute (e, 0);\n+  val_expr_pair_t new_pair;\n+  \n+  new_pair = xmalloc (sizeof (struct val_expr_pair_d));\n+  new_pair->e = expr;\n+  new_pair->v = val;\n+  new_pair->vuses = vuses;\n+  new_pair->hashcode = vn_compute (expr, 0, vuses);\n   slot = htab_find_slot_with_hash (value_table, new_pair, new_pair->hashcode,\n \t\t\t\t   INSERT);\n   if (*slot)\n     free (*slot);\n   *slot = (void *) new_pair;\n-  set_value_handle (e, v);\n \n-  add_to_value (v, e);\n+  set_value_handle (expr, val);\n+  add_to_value (val, expr);\n }\n \n \n-/* Search in VALUE_TABLE for an existing instance of expression E, and\n-   return its value, or NULL if none has been set.  */\n+/* Search in VALUE_TABLE for an existing instance of expression EXPR,\n+   and return its value, or NULL if none has been set.  VUSES\n+   represent the virtual use operands associated with EXPR (if any).\n+   They are used when computing the hash value for EXPR.  */\n \n tree\n-vn_lookup (tree e)\n+vn_lookup (tree expr, vuse_optype vuses)\n {\n   void **slot;\n-  struct val_expr_pair_d vep = {NULL, NULL, 0};\n+  struct val_expr_pair_d vep = {NULL, NULL, NULL, 0};\n \n-  if (TREE_CODE_CLASS (TREE_CODE (e)) == 'c')\n-    return e;\n-  vep.e = e;\n-  vep.hashcode = vn_compute (e, 0); \n+  if (TREE_CODE_CLASS (TREE_CODE (expr)) == 'c')\n+    return expr;\n+  vep.e = expr;\n+  vep.vuses = vuses;\n+  vep.hashcode = vn_compute (expr, 0, vuses); \n   slot = htab_find_slot_with_hash (value_table, &vep, vep.hashcode, NO_INSERT);\n   if (!slot)\n     return NULL_TREE;\n@@ -186,33 +227,35 @@ vn_lookup (tree e)\n }\n \n \n-/* Like vn_lookup, but creates a new value for expression E if E doesn't\n-   already have a value.  Return the existing/created value for E.  */\n+/* Like vn_lookup, but creates a new value for expression EXPR, if\n+   EXPR doesn't already have a value.  Return the existing/created\n+   value for EXPR.  VUSES represent the virtual use operands\n+   associated with EXPR (if any).  They are used when computing the\n+   hash value for EXPR.  */\n \n tree\n-vn_lookup_or_add (tree e)\n+vn_lookup_or_add (tree expr, vuse_optype vuses)\n {\n-  tree x = vn_lookup (e);\n-  if (x == NULL_TREE)\n+  tree v = vn_lookup (expr, vuses);\n+  if (v == NULL_TREE)\n     {\n-      tree v = make_value_handle (TREE_TYPE (e));\n+      v = make_value_handle (TREE_TYPE (expr));\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{     \n \t  fprintf (dump_file, \"Created value \");\n \t  print_generic_expr (dump_file, v, dump_flags);\n \t  fprintf (dump_file, \" for \");\n-\t  print_generic_expr (dump_file, e, dump_flags);\n+\t  print_generic_expr (dump_file, expr, dump_flags);\n \t  fprintf (dump_file, \"\\n\");\n \t}\n \n-      vn_add (e, v);\n-      x = v;\n+      vn_add (expr, v, vuses);\n     }\n \n-  set_value_handle (e, x);\n+  set_value_handle (expr, v);\n \n-  return x;\n+  return v;\n }\n \n "}, {"sha": "fdabc24a64e4d7f463f7055ca927d8a7766443af", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 25, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2ad0f77f613012b18f08ac9414de159d4971bb/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2ad0f77f613012b18f08ac9414de159d4971bb/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=ff2ad0f77f613012b18f08ac9414de159d4971bb", "patch": "@@ -1215,33 +1215,10 @@ struct tree_exp GTY(())\n #define SSA_NAME_VALUE(N) \\\n    SSA_NAME_CHECK (N)->ssa_name.value_handle\n \n-#ifndef GCC_BITMAP_H\n-struct bitmap_head_def;\n+#ifndef _TREE_FLOW_H\n+struct ptr_info_def;\n #endif\n \n-/* Aliasing information for SSA_NAMEs representing pointer variables.  */\n-struct ptr_info_def GTY(())\n-{\n-  /* Nonzero if points-to analysis couldn't determine where this pointer\n-     is pointing to.  */\n-  unsigned int pt_anything : 1;\n-\n-  /* Nonzero if this pointer is the result of a call to malloc.  */\n-  unsigned int pt_malloc : 1;\n-\n-  /* Nonzero if the value of this pointer escapes the current function.  */\n-  unsigned int value_escapes_p : 1;\n-\n-  /* Set of variables that this pointer may point to.  */\n-  struct bitmap_head_def *pt_vars;\n-\n-  /* If this pointer has been dereferenced, and points-to information is\n-     more precise than type-based aliasing, indirect references to this\n-     pointer will be represented by this memory tag, instead of the type\n-     tag computed by TBAA.  */\n-  tree name_mem_tag;\n-};\n-\n struct tree_ssa_name GTY(())\n {\n   struct tree_common common;"}]}