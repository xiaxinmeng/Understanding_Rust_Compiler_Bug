{"sha": "de514d407ef8af0b0ba377d8934348702cf87d05", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGU1MTRkNDA3ZWY4YWYwYjBiYTM3N2Q4OTM0MzQ4NzAyY2Y4N2QwNQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2016-10-21T12:50:56Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2016-10-21T12:50:56Z"}, "message": "re PR fortran/69566 ([OOP] Failure of SELECT TYPE with unlimited polymorphic function result)\n\n2016-10-21  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/69566\n\t* resolve.c (fixup_array_ref): New function.\n\t(resolve_select_type): Gather up the rank and array reference,\n\tif any, from the selector. Fix up the 'associate name' and the\n\t'associate entities' as necessary.\n\t* trans-expr.c (gfc_conv_class_to_class): If the symbol backend\n\tdecl is a FUNCTION_DECL, use the 'fake_result_decl' instead.\n\n2016-10-21  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/69566\n\t* gfortran.dg/select_type_37.f03: New test.\n\nFrom-SVN: r241403", "tree": {"sha": "8c272f3218f0e29691939ff45b3f7f5bd4e1a7af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8c272f3218f0e29691939ff45b3f7f5bd4e1a7af"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/de514d407ef8af0b0ba377d8934348702cf87d05", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de514d407ef8af0b0ba377d8934348702cf87d05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de514d407ef8af0b0ba377d8934348702cf87d05", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de514d407ef8af0b0ba377d8934348702cf87d05/comments", "author": null, "committer": null, "parents": [{"sha": "dfe08bc4ef2810b98e0ce8ffca4155ad304e0429", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfe08bc4ef2810b98e0ce8ffca4155ad304e0429", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfe08bc4ef2810b98e0ce8ffca4155ad304e0429"}], "stats": {"total": 182, "additions": 181, "deletions": 1}, "files": [{"sha": "b9b742e22bcfc0149f0a8e7a2bef5edebeac2875", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de514d407ef8af0b0ba377d8934348702cf87d05/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de514d407ef8af0b0ba377d8934348702cf87d05/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=de514d407ef8af0b0ba377d8934348702cf87d05", "patch": "@@ -1,3 +1,13 @@\n+2016-10-21  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/69566\n+\t* resolve.c (fixup_array_ref): New function.\n+\t(resolve_select_type): Gather up the rank and array reference,\n+\tif any, from the selector. Fix up the 'associate name' and the\n+\t'associate entities' as necessary.\n+\t* trans-expr.c (gfc_conv_class_to_class): If the symbol backend\n+\tdecl is a FUNCTION_DECL, use the 'fake_result_decl' instead.\n+\n 2016-10-20  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \t* array.c (gfc_match_array_constructor): Remove set, but unused"}, {"sha": "c4426f8132052923cd629643d3cd0b46830a4467", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 78, "deletions": 1, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de514d407ef8af0b0ba377d8934348702cf87d05/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de514d407ef8af0b0ba377d8934348702cf87d05/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=de514d407ef8af0b0ba377d8934348702cf87d05", "patch": "@@ -8327,6 +8327,48 @@ resolve_assoc_var (gfc_symbol* sym, bool resolve_target)\n }\n \n \n+/* Ensure that SELECT TYPE expressions have the correct rank and a full\n+   array reference, where necessary.  The symbols are artificial and so\n+   the dimension attribute and arrayspec can also be set.  In addition,\n+   sometimes the expr1 arrives as BT_DERIVED, when the symbol is BT_CLASS.\n+   This is corrected here as well.*/\n+\n+static void\n+fixup_array_ref (gfc_expr **expr1, gfc_expr *expr2,\n+\t\t int rank, gfc_ref *ref)\n+{\n+  gfc_ref *nref = (*expr1)->ref;\n+  gfc_symbol *sym1 = (*expr1)->symtree->n.sym;\n+  gfc_symbol *sym2 = expr2 ? expr2->symtree->n.sym : NULL;\n+  (*expr1)->rank = rank;\n+  if (sym1->ts.type == BT_CLASS)\n+    {\n+      if ((*expr1)->ts.type != BT_CLASS)\n+\t(*expr1)->ts = sym1->ts;\n+\n+      CLASS_DATA (sym1)->attr.dimension = 1;\n+      if (CLASS_DATA (sym1)->as == NULL && sym2)\n+\tCLASS_DATA (sym1)->as\n+\t\t= gfc_copy_array_spec (CLASS_DATA (sym2)->as);\n+    }\n+  else\n+    {\n+      sym1->attr.dimension = 1;\n+      if (sym1->as == NULL && sym2)\n+\tsym1->as = gfc_copy_array_spec (sym2->as);\n+    }\n+\n+  for (; nref; nref = nref->next)\n+    if (nref->next == NULL)\n+      break;\n+\n+  if (ref && nref && nref->type != REF_ARRAY)\n+    nref->next = gfc_copy_ref (ref);\n+  else if (ref && !nref)\n+    (*expr1)->ref = gfc_copy_ref (ref);\n+}\n+\n+\n /* Resolve a SELECT TYPE statement.  */\n \n static void\n@@ -8341,6 +8383,8 @@ resolve_select_type (gfc_code *code, gfc_namespace *old_ns)\n   gfc_namespace *ns;\n   int error = 0;\n   int charlen = 0;\n+  int rank = 0;\n+  gfc_ref* ref = NULL;\n \n   ns = code->ext.block.ns;\n   gfc_resolve (ns);\n@@ -8468,6 +8512,31 @@ resolve_select_type (gfc_code *code, gfc_namespace *old_ns)\n   else\n     code->ext.block.assoc = NULL;\n \n+  /* Ensure that the selector rank and arrayspec are available to\n+     correct expressions in which they might be missing.  */\n+  if (code->expr2 && code->expr2->rank)\n+    {\n+      rank = code->expr2->rank;\n+      for (ref = code->expr2->ref; ref; ref = ref->next)\n+\tif (ref->next == NULL)\n+\t  break;\n+      if (ref && ref->type == REF_ARRAY)\n+\tref = gfc_copy_ref (ref);\n+\n+      /* Fixup expr1 if necessary.  */\n+      if (rank)\n+\tfixup_array_ref (&code->expr1, code->expr2, rank, ref);\n+    }\n+  else if (code->expr1->rank)\n+    {\n+      rank = code->expr1->rank;\n+      for (ref = code->expr1->ref; ref; ref = ref->next)\n+\tif (ref->next == NULL)\n+\t  break;\n+      if (ref && ref->type == REF_ARRAY)\n+\tref = gfc_copy_ref (ref);\n+    }\n+\n   /* Add EXEC_SELECT to switch on type.  */\n   new_st = gfc_get_code (code->op);\n   new_st->expr1 = code->expr1;\n@@ -8533,7 +8602,12 @@ resolve_select_type (gfc_code *code, gfc_namespace *old_ns)\n       st->n.sym->assoc->target = gfc_get_variable_expr (code->expr1->symtree);\n       st->n.sym->assoc->target->where = code->expr1->where;\n       if (c->ts.type != BT_CLASS && c->ts.type != BT_UNKNOWN)\n-\tgfc_add_data_component (st->n.sym->assoc->target);\n+\t{\n+\t  gfc_add_data_component (st->n.sym->assoc->target);\n+\t  /* Fixup the target expression if necessary.  */\n+\t  if (rank)\n+\t    fixup_array_ref (&st->n.sym->assoc->target, NULL, rank, ref);\n+\t}\n \n       new_st = gfc_get_code (EXEC_BLOCK);\n       new_st->ext.block.ns = gfc_build_block_ns (ns);\n@@ -8672,6 +8746,9 @@ resolve_select_type (gfc_code *code, gfc_namespace *old_ns)\n   gfc_resolve_blocks (code->block, gfc_current_ns);\n   gfc_current_ns = old_ns;\n \n+  if (ref)\n+    free (ref);\n+\n   resolve_select (code, true);\n }\n "}, {"sha": "2f8ea22e643fe51101bd128a25f497522715fc10", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de514d407ef8af0b0ba377d8934348702cf87d05/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de514d407ef8af0b0ba377d8934348702cf87d05/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=de514d407ef8af0b0ba377d8934348702cf87d05", "patch": "@@ -1033,8 +1033,13 @@ gfc_conv_class_to_class (gfc_se *parmse, gfc_expr *e, gfc_typespec class_ts,\n \t&& e->symtree && e->symtree->n.sym->ts.type == BT_CLASS)\n     {\n       tmp = e->symtree->n.sym->backend_decl;\n+\n+      if (TREE_CODE (tmp) == FUNCTION_DECL)\n+\ttmp = gfc_get_fake_result_decl (e->symtree->n.sym, 0);\n+\n       if (DECL_LANG_SPECIFIC (tmp) && GFC_DECL_SAVED_DESCRIPTOR (tmp))\n \ttmp = GFC_DECL_SAVED_DESCRIPTOR (tmp);\n+\n       slen = integer_zero_node;\n     }\n   else"}, {"sha": "83414ed3833e6e5782183cdfbec2eac86900d9c2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de514d407ef8af0b0ba377d8934348702cf87d05/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de514d407ef8af0b0ba377d8934348702cf87d05/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=de514d407ef8af0b0ba377d8934348702cf87d05", "patch": "@@ -1,3 +1,8 @@\n+2016-10-21  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/69566\n+\t* gfortran.dg/select_type_37.f03: New test.\n+\n 2016-10-21  Senthil Kumar Selvaraj  <senthil_kumar.selvaraj@atmel.com>\n \n \tPR target/71627"}, {"sha": "c9fd23cea3eb1bef940274042e7b45ba43dd0c5e", "filename": "gcc/testsuite/gfortran.dg/select_type_37.f03", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de514d407ef8af0b0ba377d8934348702cf87d05/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_type_37.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de514d407ef8af0b0ba377d8934348702cf87d05/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_type_37.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_type_37.f03?ref=de514d407ef8af0b0ba377d8934348702cf87d05", "patch": "@@ -0,0 +1,83 @@\n+! { dg-do run }\n+!\n+! Checks the fix for PR69556 in which using implicit function results\n+! in SELECT TYPE caused all sorts of problems, especially in the form\n+! in 'return_pointer1' with \"associate_name => selector\". The original\n+! PR is encapsulated in 'return_pointer'. Explicit results, such as in\n+! 'return_pointer2' always worked.\n+!\n+! Contributed by James Greenhalgh  <jgreenhalgh@gcc.gnu.org>\n+!\n+program pr69556\n+  class(*), pointer :: ptr(:)\n+  character(40) :: buffer1, buffer2\n+  real :: cst1(2) = [1.0, 2.0]\n+  real :: cst2(2) = [3.0, 4.0]\n+  real :: cst3(2) = [5.0, 6.0]\n+\n+  write (buffer1, *) cst1\n+  if (.not.associated(return_pointer1(cst1))) call abort\n+  if (trim (buffer1) .ne. trim (buffer2)) call abort\n+  select type (ptr)\n+    type is (real)\n+      if (any (ptr .ne. cst2)) call abort\n+  end select\n+  deallocate (ptr)\n+\n+  write (buffer1, *) cst2\n+  if (.not.associated(return_pointer(cst2))) call abort\n+  if (trim (buffer1) .ne. trim (buffer2)) call abort\n+  select type (ptr)\n+    type is (real)\n+      if (any (ptr .ne. cst3)) call abort\n+  end select\n+  deallocate (ptr)\n+\n+  write (buffer1, *) cst1\n+  if (.not.associated(return_pointer2(cst1))) call abort\n+  if (trim (buffer1) .ne. trim (buffer2)) call abort\n+  select type (ptr)\n+    type is (real)\n+      if (any (ptr .ne. cst2)) call abort\n+  end select\n+  deallocate (ptr)\n+\n+contains\n+\n+  function return_pointer2(arg) result (res) ! Explicit result always worked.\n+    class(*), pointer :: res(:)\n+    real, intent(inout) :: arg(:)\n+    allocate (res, source = arg)\n+    ptr => res                               ! Check association and cleanup\n+    select type (z => res)\n+      type is (real(4))\n+        write (buffer2, *) z                 ! Check associate expression is OK.\n+        z = cst2                             ! Check associate is OK for lvalue.\n+    end select\n+  end function\n+\n+  function return_pointer1(arg)\n+    class(*), pointer :: return_pointer1(:)\n+    real, intent(inout) :: arg(:)\n+    allocate (return_pointer1, source = arg)\n+    ptr => return_pointer1\n+    select type (z => return_pointer1) ! This caused a segfault in compilation.\n+      type is (real(4))\n+        write (buffer2, *) z\n+        z = cst2\n+    end select\n+  end function\n+\n+  function return_pointer(arg) ! The form in the PR.\n+    class(*), pointer :: return_pointer(:)\n+    real, intent(inout) :: arg(:)\n+    allocate (return_pointer, source = cst2)\n+    ptr => return_pointer\n+    select type (return_pointer)\n+      type is (real(4)) ! Associate-name \u2018__tmp_REAL_4\u2019 at (1) is used as array\n+        write (buffer2, *) return_pointer\n+        return_pointer = cst3\n+    end select\n+  end function\n+end program\n+"}]}