{"sha": "3619ab8bd4ed2ceaeb202ccaa59341c863679725", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzYxOWFiOGJkNGVkMmNlYWViMjAyY2NhYTU5MzQxYzg2MzY3OTcyNQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-05-11T20:55:41Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-05-11T20:55:41Z"}, "message": "runtime: fix isSystemGoroutine for gccgo\n    \n    The gc toolchain decides whether a goroutine is a system goroutine by\n    comparing startpc to a list of saved special PCs.  In gccgo that\n    approach does not work as startpc is often a thunk that invokes the\n    real function with arguments, so the thunk address never matches the\n    saved special PCs.\n    \n    This patch fixes gccgo's understanding of system goroutines.  Since\n    there are only a limited number of them, we simply change each one to\n    mark itself as special.\n    \n    This fixes stack dumps and functions like runtime.NumGoroutine to\n    behave more like gc.  It also fixes the goprint test in the gc\n    testsuite.\n    \n    Reviewed-on: https://go-review.googlesource.com/43156\n\nFrom-SVN: r247931", "tree": {"sha": "1836ce9be27e6473305ed505646f84c09ff1a621", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1836ce9be27e6473305ed505646f84c09ff1a621"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3619ab8bd4ed2ceaeb202ccaa59341c863679725", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3619ab8bd4ed2ceaeb202ccaa59341c863679725", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3619ab8bd4ed2ceaeb202ccaa59341c863679725", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3619ab8bd4ed2ceaeb202ccaa59341c863679725/comments", "author": null, "committer": null, "parents": [{"sha": "628c06d6bc47c3a1487ecd41eb12d13a968d4480", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/628c06d6bc47c3a1487ecd41eb12d13a968d4480", "html_url": "https://github.com/Rust-GCC/gccrs/commit/628c06d6bc47c3a1487ecd41eb12d13a968d4480"}], "stats": {"total": 87, "additions": 39, "deletions": 48}, "files": [{"sha": "a0e661bd61bc5eda9c1ebfee1912d8088c204a09", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3619ab8bd4ed2ceaeb202ccaa59341c863679725/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3619ab8bd4ed2ceaeb202ccaa59341c863679725/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=3619ab8bd4ed2ceaeb202ccaa59341c863679725", "patch": "@@ -1,4 +1,4 @@\n-822ab419bf7d1c705cdce1c12133e7a11f56be2e\n+619848ccd463ac385e9912df008e7e8e6301a284\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "615a2b295222fa86bed4bc7a870b98ab555b4de0", "filename": "libgo/go/runtime/mfinal.go", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3619ab8bd4ed2ceaeb202ccaa59341c863679725/libgo%2Fgo%2Fruntime%2Fmfinal.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3619ab8bd4ed2ceaeb202ccaa59341c863679725/libgo%2Fgo%2Fruntime%2Fmfinal.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmfinal.go?ref=3619ab8bd4ed2ceaeb202ccaa59341c863679725", "patch": "@@ -100,8 +100,7 @@ func wakefing() *g {\n }\n \n var (\n-\tfingCreate  uint32\n-\tfingRunning bool\n+\tfingCreate uint32\n )\n \n func createfing() {\n@@ -113,17 +112,19 @@ func createfing() {\n \n // This is the goroutine that runs all of the finalizers\n func runfinq() {\n+\tsetSystemGoroutine()\n+\n \tvar (\n \t\tef   eface\n \t\tifac iface\n \t)\n \n+\tgp := getg()\n \tfor {\n \t\tlock(&finlock)\n \t\tfb := finq\n \t\tfinq = nil\n \t\tif fb == nil {\n-\t\t\tgp := getg()\n \t\t\tfing = gp\n \t\t\tfingwait = true\n \t\t\tgoparkunlock(&finlock, \"finalizer wait\", traceEvGoBlock, 1)\n@@ -160,9 +161,17 @@ func runfinq() {\n \t\t\t\tdefault:\n \t\t\t\t\tthrow(\"bad kind in runfinq\")\n \t\t\t\t}\n-\t\t\t\tfingRunning = true\n+\t\t\t\t// This is not a system goroutine while\n+\t\t\t\t// running the actual finalizer.\n+\t\t\t\t// This matters because we want this\n+\t\t\t\t// goroutine to appear in a stack dump\n+\t\t\t\t// if the finalizer crashes.\n+\t\t\t\t// The gc toolchain handles this using\n+\t\t\t\t// a global variable fingRunning,\n+\t\t\t\t// but we don't need that.\n+\t\t\t\tgp.isSystemGoroutine = false\n \t\t\t\treflectcall(f.ft, f.fn, false, false, &param, nil)\n-\t\t\t\tfingRunning = false\n+\t\t\t\tgp.isSystemGoroutine = true\n \n \t\t\t\t// Drop finalizer queue heap references\n \t\t\t\t// before hiding them from markroot."}, {"sha": "f828e7c28f328b4d343c001372955adbf4ac9e0b", "filename": "libgo/go/runtime/mgc.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3619ab8bd4ed2ceaeb202ccaa59341c863679725/libgo%2Fgo%2Fruntime%2Fmgc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3619ab8bd4ed2ceaeb202ccaa59341c863679725/libgo%2Fgo%2Fruntime%2Fmgc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmgc.go?ref=3619ab8bd4ed2ceaeb202ccaa59341c863679725", "patch": "@@ -1423,6 +1423,8 @@ func gcBgMarkPrepare() {\n }\n \n func gcBgMarkWorker(_p_ *p) {\n+\tsetSystemGoroutine()\n+\n \tgp := getg()\n \n \ttype parkInfo struct {"}, {"sha": "2b698bf74a506dfcf404e4873a788ccb4b75b87a", "filename": "libgo/go/runtime/mgcsweep.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3619ab8bd4ed2ceaeb202ccaa59341c863679725/libgo%2Fgo%2Fruntime%2Fmgcsweep.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3619ab8bd4ed2ceaeb202ccaa59341c863679725/libgo%2Fgo%2Fruntime%2Fmgcsweep.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmgcsweep.go?ref=3619ab8bd4ed2ceaeb202ccaa59341c863679725", "patch": "@@ -48,6 +48,8 @@ func finishsweep_m() {\n }\n \n func bgsweep(c chan int) {\n+\tsetSystemGoroutine()\n+\n \tsweep.g = getg()\n \n \tlock(&sweep.lock)"}, {"sha": "64735e2a653259f1f641939507989bb6c6b3e896", "filename": "libgo/go/runtime/proc.go", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3619ab8bd4ed2ceaeb202ccaa59341c863679725/libgo%2Fgo%2Fruntime%2Fproc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3619ab8bd4ed2ceaeb202ccaa59341c863679725/libgo%2Fgo%2Fruntime%2Fproc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fproc.go?ref=3619ab8bd4ed2ceaeb202ccaa59341c863679725", "patch": "@@ -237,6 +237,8 @@ func init() {\n }\n \n func forcegchelper() {\n+\tsetSystemGoroutine()\n+\n \tforcegc.g = getg()\n \tfor {\n \t\tlock(&forcegc.lock)\n@@ -450,7 +452,6 @@ func schedinit() {\n \n \tsched.maxmcount = 10000\n \n-\ttracebackinit()\n \tmallocinit()\n \tmcommoninit(_g_.m)\n \talginit() // maps must not be used before this call\n@@ -2688,9 +2689,6 @@ func newproc(fn uintptr, arg unsafe.Pointer) *g {\n \tnewg.param = arg\n \tnewg.gopc = getcallerpc(unsafe.Pointer(&fn))\n \tnewg.startpc = fn\n-\tif isSystemGoroutine(newg) {\n-\t\tatomic.Xadd(&sched.ngsys, +1)\n-\t}\n \t// The stack is dirty from the argument frame, so queue it for\n \t// scanning. Do this before setting it to runnable so we still\n \t// own the G. If we're recycling a G, it may already be on the\n@@ -2729,6 +2727,18 @@ func newproc(fn uintptr, arg unsafe.Pointer) *g {\n \treturn newg\n }\n \n+// setSystemGoroutine marks this goroutine as a \"system goroutine\".\n+// In the gc toolchain this is done by comparing startpc to a list of\n+// saved special PCs. In gccgo that approach does not work as startpc\n+// is often a thunk that invokes the real function with arguments,\n+// so the thunk address never matches the saved special PCs. Instead,\n+// since there are only a limited number of \"system goroutines\",\n+// we force each one to mark itself as special.\n+func setSystemGoroutine() {\n+\tgetg().isSystemGoroutine = true\n+\tatomic.Xadd(&sched.ngsys, +1)\n+}\n+\n // Put on gfree list.\n // If local list is too long, transfer a batch to the global list.\n func gfput(_p_ *p, gp *g) {"}, {"sha": "8deb6202bae4fa2168fa8e952c3f841202a39dab", "filename": "libgo/go/runtime/runtime2.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3619ab8bd4ed2ceaeb202ccaa59341c863679725/libgo%2Fgo%2Fruntime%2Fruntime2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3619ab8bd4ed2ceaeb202ccaa59341c863679725/libgo%2Fgo%2Fruntime%2Fruntime2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fruntime2.go?ref=3619ab8bd4ed2ceaeb202ccaa59341c863679725", "patch": "@@ -415,6 +415,8 @@ type g struct {\n \n \tscanningself bool // whether goroutine is scanning its own stack\n \n+\tisSystemGoroutine bool // whether goroutine is a \"system\" goroutine\n+\n \ttraceback *tracebackg // stack traceback buffer\n \n \tcontext      g_ucontext_t // saved context for setcontext"}, {"sha": "e85fc7a54fa2af5cbad857c665ba77cbe1748914", "filename": "libgo/go/runtime/time.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3619ab8bd4ed2ceaeb202ccaa59341c863679725/libgo%2Fgo%2Fruntime%2Ftime.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3619ab8bd4ed2ceaeb202ccaa59341c863679725/libgo%2Fgo%2Fruntime%2Ftime.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Ftime.go?ref=3619ab8bd4ed2ceaeb202ccaa59341c863679725", "patch": "@@ -152,6 +152,8 @@ func deltimer(t *timer) bool {\n // It sleeps until the next event in the timers heap.\n // If addtimer inserts a new earlier event, it wakes timerproc early.\n func timerproc() {\n+\tsetSystemGoroutine()\n+\n \ttimers.gp = getg()\n \tfor {\n \t\tlock(&timers.lock)"}, {"sha": "fb51043e13da992c79a8c4764ab14aabb95d7c6d", "filename": "libgo/go/runtime/traceback_gccgo.go", "status": "modified", "additions": 2, "deletions": 38, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3619ab8bd4ed2ceaeb202ccaa59341c863679725/libgo%2Fgo%2Fruntime%2Ftraceback_gccgo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3619ab8bd4ed2ceaeb202ccaa59341c863679725/libgo%2Fgo%2Fruntime%2Ftraceback_gccgo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Ftraceback_gccgo.go?ref=3619ab8bd4ed2ceaeb202ccaa59341c863679725", "patch": "@@ -9,7 +9,7 @@ package runtime\n \n import (\n \t\"runtime/internal/sys\"\n-\t\"unsafe\"\n+\t_ \"unsafe\" // for go:linkname\n )\n \n // For gccgo, use go:linkname to rename compiler-called functions to\n@@ -20,34 +20,6 @@ import (\n //go:linkname goroutineheader runtime.goroutineheader\n //go:linkname printcreatedby runtime.printcreatedby\n \n-var (\n-\t// initialized in tracebackinit\n-\trunfinqPC        uintptr\n-\tbgsweepPC        uintptr\n-\tforcegchelperPC  uintptr\n-\ttimerprocPC      uintptr\n-\tgcBgMarkWorkerPC uintptr\n-)\n-\n-func tracebackinit() {\n-\t// Go variable initialization happens late during runtime startup.\n-\t// Instead of initializing the variables above in the declarations,\n-\t// schedinit calls this function so that the variables are\n-\t// initialized and available earlier in the startup sequence.\n-\t// This doesn't use funcPC to avoid memory allocation.\n-\t// FIXME: We should be able to use funcPC when escape analysis is on.\n-\tf1 := runfinq\n-\trunfinqPC = **(**uintptr)(unsafe.Pointer(&f1))\n-\tf2 := bgsweep\n-\tbgsweepPC = **(**uintptr)(unsafe.Pointer(&f2))\n-\tf3 := forcegchelper\n-\tforcegchelperPC = **(**uintptr)(unsafe.Pointer(&f3))\n-\tf4 := timerproc\n-\ttimerprocPC = **(**uintptr)(unsafe.Pointer(&f4))\n-\tf5 := gcBgMarkWorker\n-\tgcBgMarkWorkerPC = **(**uintptr)(unsafe.Pointer(&f5))\n-}\n-\n func printcreatedby(gp *g) {\n \t// Show what created goroutine, except main goroutine (goid 1).\n \tpc := gp.gopc\n@@ -196,15 +168,7 @@ func goroutineheader(gp *g) {\n // isSystemGoroutine reports whether the goroutine g must be omitted in\n // stack dumps and deadlock detector.\n func isSystemGoroutine(gp *g) bool {\n-\t// FIXME: This doesn't work reliably for gccgo because in many\n-\t// cases the startpc field will be set to a thunk rather than\n-\t// to one of these addresses.\n-\tpc := gp.startpc\n-\treturn pc == runfinqPC && !fingRunning ||\n-\t\tpc == bgsweepPC ||\n-\t\tpc == forcegchelperPC ||\n-\t\tpc == timerprocPC ||\n-\t\tpc == gcBgMarkWorkerPC\n+\treturn gp.isSystemGoroutine\n }\n \n func tracebackothers(me *g) {"}]}