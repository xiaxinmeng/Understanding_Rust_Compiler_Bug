{"sha": "311eb8168ea83b8b7ce76735fee8c594cda5a0e0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzExZWI4MTY4ZWE4M2I4YjdjZTc2NzM1ZmVlOGM1OTRjZGE1YTBlMA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2018-05-16T13:02:27Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2018-05-16T13:02:27Z"}, "message": "params.def (PARAM_DSE_MAX_ALIAS_QUERIES_PER_STORE): New param.\n\n2018-05-16  Richard Biener  <rguenther@suse.de>\n\n\t* params.def (PARAM_DSE_MAX_ALIAS_QUERIES_PER_STORE): New param.\n\t* doc/invoke.texi (dse-max-alias-queries-per-store): Document.\n\t* tree-ssa-dse.c: Include tree-ssa-loop.h.\n\t(check_name): New callback.\n\t(dse_classify_store): Track cycles via a visited bitmap of PHI\n\tdefs and simplify handling of in-loop and across loop dead stores\n\tand properly fail for loop-variant refs.  Handle byte-tracking with\n\tmultiple defs.  Use PARAM_DSE_MAX_ALIAS_QUERIES_PER_STORE for\n\tlimiting the walk.\n\n\t* gcc.dg/tree-ssa/ssa-dse-32.c: New testcase.\n\t* gcc.dg/tree-ssa/ssa-dse-33.c: Likewise.\n\t* gcc.dg/uninit-pr81897-2.c: Use -fno-tree-dse.\n\nFrom-SVN: r260288", "tree": {"sha": "458fa57074883441e57ab838c7d5537943e23ee7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/458fa57074883441e57ab838c7d5537943e23ee7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/311eb8168ea83b8b7ce76735fee8c594cda5a0e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/311eb8168ea83b8b7ce76735fee8c594cda5a0e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/311eb8168ea83b8b7ce76735fee8c594cda5a0e0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/311eb8168ea83b8b7ce76735fee8c594cda5a0e0/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1f3cb66326d724cca10ac6097ab32c53191c53ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f3cb66326d724cca10ac6097ab32c53191c53ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f3cb66326d724cca10ac6097ab32c53191c53ff"}], "stats": {"total": 169, "additions": 118, "deletions": 51}, "files": [{"sha": "5d4298b02ee376aea16d07dde0cb997147861bfa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/311eb8168ea83b8b7ce76735fee8c594cda5a0e0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/311eb8168ea83b8b7ce76735fee8c594cda5a0e0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=311eb8168ea83b8b7ce76735fee8c594cda5a0e0", "patch": "@@ -1,3 +1,15 @@\n+2018-05-16  Richard Biener  <rguenther@suse.de>\n+\n+\t* params.def (PARAM_DSE_MAX_ALIAS_QUERIES_PER_STORE): New param.\n+\t* doc/invoke.texi (dse-max-alias-queries-per-store): Document.\n+\t* tree-ssa-dse.c: Include tree-ssa-loop.h.\n+\t(check_name): New callback.\n+\t(dse_classify_store): Track cycles via a visited bitmap of PHI\n+\tdefs and simplify handling of in-loop and across loop dead stores\n+\tand properly fail for loop-variant refs.  Handle byte-tracking with\n+\tmultiple defs.  Use PARAM_DSE_MAX_ALIAS_QUERIES_PER_STORE for\n+\tlimiting the walk.\n+\n 2018-05-16  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* tree-vectorizer.h (vect_get_vector_types_for_stmt): Declare."}, {"sha": "b78a2d67b0dfef91a4b5c2d5ebafa264701c5228", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/311eb8168ea83b8b7ce76735fee8c594cda5a0e0/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/311eb8168ea83b8b7ce76735fee8c594cda5a0e0/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=311eb8168ea83b8b7ce76735fee8c594cda5a0e0", "patch": "@@ -10439,6 +10439,11 @@ Average number of iterations of a loop.\n Maximum size (in bytes) of objects tracked bytewise by dead store elimination.\n Larger values may result in larger compilation times.\n \n+@item dse-max-alias-queries-per-store\n+Maximum number of queries into the alias oracle per store.\n+Larger values result in larger compilation times and may result in more\n+removed dead stores.\n+\n @item scev-max-expr-size\n Bound on size of expressions used in the scalar evolutions analyzer.\n Large expressions slow the analyzer."}, {"sha": "5c4e2c9507267e9f607d820d933a95eba19116bb", "filename": "gcc/params.def", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/311eb8168ea83b8b7ce76735fee8c594cda5a0e0/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/311eb8168ea83b8b7ce76735fee8c594cda5a0e0/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=311eb8168ea83b8b7ce76735fee8c594cda5a0e0", "patch": "@@ -547,6 +547,11 @@ DEFPARAM(PARAM_DSE_MAX_OBJECT_SIZE,\n \t \"Maximum size (in bytes) of objects tracked bytewise by dead store elimination.\",\n \t 256, 0, 0)\n \n+DEFPARAM(PARAM_DSE_MAX_ALIAS_QUERIES_PER_STORE,\n+\t \"dse-max-alias-queries-per-store\",\n+\t \"Maximum number of queries into the alias oracle per store.\",\n+\t 256, 0, 0)\n+\n DEFPARAM(PARAM_SCEV_MAX_EXPR_SIZE,\n  \t \"scev-max-expr-size\",\n \t \"Bound on size of expressions used in the scalar evolutions analyzer.\","}, {"sha": "b1785436a175ac84d75c733aaf662cb6fa4c6d8e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/311eb8168ea83b8b7ce76735fee8c594cda5a0e0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/311eb8168ea83b8b7ce76735fee8c594cda5a0e0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=311eb8168ea83b8b7ce76735fee8c594cda5a0e0", "patch": "@@ -1,3 +1,9 @@\n+2018-05-16  Richard Biener  <rguenther@suse.de>\n+\n+\t* gcc.dg/tree-ssa/ssa-dse-32.c: New testcase.\n+\t* gcc.dg/tree-ssa/ssa-dse-33.c: Likewise.\n+\t* gcc.dg/uninit-pr81897-2.c: Use -fno-tree-dse.\n+\n 2018-05-16  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* gcc.target/aarch64/sve/vcond_10.c: New test."}, {"sha": "eea0d8d5cf0d35c62a687748a8b6164f278a4b29", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dse-32.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/311eb8168ea83b8b7ce76735fee8c594cda5a0e0/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dse-32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/311eb8168ea83b8b7ce76735fee8c594cda5a0e0/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dse-32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dse-32.c?ref=311eb8168ea83b8b7ce76735fee8c594cda5a0e0", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-dse1-details\" } */\n+\n+void f(int n)\n+{\n+  char *p = __builtin_malloc (1);\n+  int i;\n+  do\n+    *p = 0;\n+  while (++i < n);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Deleted dead store\" 1 \"dse1\" } } */"}, {"sha": "5bcc016ed1ef253985a6eac9387133f8ab250263", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dse-33.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/311eb8168ea83b8b7ce76735fee8c594cda5a0e0/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dse-33.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/311eb8168ea83b8b7ce76735fee8c594cda5a0e0/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dse-33.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dse-33.c?ref=311eb8168ea83b8b7ce76735fee8c594cda5a0e0", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-dse1-details\" } */\n+\n+void f(char *p, int n)\n+{\n+  for (int i = 0; i < n; ++i)\n+    *p = 0;  /* Removed by DSE.  */\n+  *p = 1;\n+}\n+\n+void g(char *p, int n)\n+{\n+  int i = 0;\n+  do\n+    *p = 0;  /* Not yet removed by DSE.  */\n+  while (++i < n);\n+  *p = 1;\n+}\n+\n+\n+/* { dg-final { scan-tree-dump-times \"Deleted dead store\" 2 \"dse1\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"Deleted dead store\" 1 \"dse1\" } } */"}, {"sha": "644de655225d9d72acd6d58aff379eb4f1a5373e", "filename": "gcc/testsuite/gcc.dg/uninit-pr81897-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/311eb8168ea83b8b7ce76735fee8c594cda5a0e0/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pr81897-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/311eb8168ea83b8b7ce76735fee8c594cda5a0e0/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pr81897-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pr81897-2.c?ref=311eb8168ea83b8b7ce76735fee8c594cda5a0e0", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile }  */\n-/* { dg-options \"-O1 -fno-tree-ccp -Wmaybe-uninitialized\" } */\n+/* { dg-options \"-O1 -fno-tree-ccp -fno-tree-dse -Wmaybe-uninitialized\" } */\n \n int oo;\n "}, {"sha": "32a25b9eb1ef3b54517276d9c1a2c8efdb37d8ac", "filename": "gcc/tree-ssa-dse.c", "status": "modified", "additions": 54, "deletions": 50, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/311eb8168ea83b8b7ce76735fee8c594cda5a0e0/gcc%2Ftree-ssa-dse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/311eb8168ea83b8b7ce76735fee8c594cda5a0e0/gcc%2Ftree-ssa-dse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dse.c?ref=311eb8168ea83b8b7ce76735fee8c594cda5a0e0", "patch": "@@ -35,6 +35,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-cfgcleanup.h\"\n #include \"params.h\"\n #include \"alias.h\"\n+#include \"tree-ssa-loop.h\"\n \n /* This file implements dead store elimination.\n \n@@ -515,6 +516,21 @@ live_bytes_read (ao_ref use_ref, ao_ref *ref, sbitmap live)\n   return true;\n }\n \n+/* Callback for dse_classify_store calling for_each_index.  Verify that\n+   indices are invariant in the loop with backedge PHI in basic-block DATA.  */\n+\n+static bool\n+check_name (tree, tree *idx, void *data)\n+{\n+  basic_block phi_bb = (basic_block) data;\n+  if (TREE_CODE (*idx) == SSA_NAME\n+      && !SSA_NAME_IS_DEFAULT_DEF (*idx)\n+      && dominated_by_p (CDI_DOMINATORS, gimple_bb (SSA_NAME_DEF_STMT (*idx)),\n+\t\t\t phi_bb))\n+    return false;\n+  return true;\n+}\n+\n /* A helper of dse_optimize_stmt.\n    Given a GIMPLE_ASSIGN in STMT that writes to REF, classify it\n    according to downstream uses and defs.  Sets *BY_CLOBBER_P to true\n@@ -527,7 +543,8 @@ dse_classify_store (ao_ref *ref, gimple *stmt,\n \t\t    bool *by_clobber_p = NULL)\n {\n   gimple *temp;\n-  unsigned cnt = 0;\n+  int cnt = 0;\n+  auto_bitmap visited;\n \n   if (by_clobber_p)\n     *by_clobber_p = true;\n@@ -539,58 +556,50 @@ dse_classify_store (ao_ref *ref, gimple *stmt,\n   temp = stmt;\n   do\n     {\n-      gimple *use_stmt, *defvar_def;\n+      gimple *use_stmt;\n       imm_use_iterator ui;\n       bool fail = false;\n       tree defvar;\n \n-      /* Limit stmt walking to be linear in the number of possibly\n-         dead stores.  */\n-      if (++cnt > 256)\n-\treturn DSE_STORE_LIVE;\n-\n       if (gimple_code (temp) == GIMPLE_PHI)\n-\tdefvar = PHI_RESULT (temp);\n+\t{\n+\t  /* If we visit this PHI by following a backedge then we have to\n+\t     make sure ref->ref only refers to SSA names that are invariant\n+\t     with respect to the loop represented by this PHI node.  */\n+\t  if (dominated_by_p (CDI_DOMINATORS, gimple_bb (stmt),\n+\t\t\t      gimple_bb (temp))\n+\t      && !for_each_index (ref->ref ? &ref->ref : &ref->base,\n+\t\t\t\t  check_name, gimple_bb (temp)))\n+\t    return DSE_STORE_LIVE;\n+\t  defvar = PHI_RESULT (temp);\n+\t  bitmap_set_bit (visited, SSA_NAME_VERSION (defvar));\n+\t}\n       else\n \tdefvar = gimple_vdef (temp);\n-      defvar_def = temp;\n       auto_vec<gimple *, 10> defs;\n       FOR_EACH_IMM_USE_STMT (use_stmt, ui, defvar)\n \t{\n-\t  cnt++;\n-\n-\t  /* If we ever reach our DSE candidate stmt again fail.  We\n-\t     cannot handle dead stores in loops.  */\n-\t  if (use_stmt == stmt)\n+\t  /* Limit stmt walking.  */\n+\t  if (++cnt > PARAM_VALUE (PARAM_DSE_MAX_ALIAS_QUERIES_PER_STORE))\n \t    {\n \t      fail = true;\n \t      BREAK_FROM_IMM_USE_STMT (ui);\n \t    }\n+\n+\t  /* We have visited ourselves already so ignore STMT for the\n+\t     purpose of chaining.  */\n+\t  if (use_stmt == stmt)\n+\t    ;\n \t  /* In simple cases we can look through PHI nodes, but we\n \t     have to be careful with loops and with memory references\n \t     containing operands that are also operands of PHI nodes.\n \t     See gcc.c-torture/execute/20051110-*.c.  */\n \t  else if (gimple_code (use_stmt) == GIMPLE_PHI)\n \t    {\n-\t      /* Make sure we are not in a loop latch block.  */\n-\t      if (gimple_bb (stmt) == gimple_bb (use_stmt)\n-\t\t  || dominated_by_p (CDI_DOMINATORS,\n-\t\t\t\t     gimple_bb (stmt), gimple_bb (use_stmt))\n-\t\t  /* We can look through PHIs to regions post-dominating\n-\t\t     the DSE candidate stmt.  */\n-\t\t  || !dominated_by_p (CDI_POST_DOMINATORS,\n-\t\t\t\t      gimple_bb (stmt), gimple_bb (use_stmt)))\n-\t\t{\n-\t\t  fail = true;\n-\t\t  BREAK_FROM_IMM_USE_STMT (ui);\n-\t\t}\n-\t      /* Do not consider the PHI as use if it dominates the\n-\t         stmt defining the virtual operand we are processing,\n-\t\t we have processed it already in this case.  */\n-\t      if (gimple_bb (defvar_def) != gimple_bb (use_stmt)\n-\t\t  && !dominated_by_p (CDI_DOMINATORS,\n-\t\t\t\t      gimple_bb (defvar_def),\n-\t\t\t\t      gimple_bb (use_stmt)))\n+\t      /* If we already visited this PHI ignore it for further\n+\t\t processing.  */\n+\t      if (!bitmap_bit_p (visited,\n+\t\t\t\t SSA_NAME_VERSION (PHI_RESULT (use_stmt))))\n \t\tdefs.safe_push (use_stmt);\n \t    }\n \t  /* If the statement is a use the store is not dead.  */\n@@ -600,25 +609,20 @@ dse_classify_store (ao_ref *ref, gimple *stmt,\n \t\t structure for USE_STMT and in doing so we find that the\n \t\t references hit non-live bytes and thus can be ignored.  */\n \t      if (byte_tracking_enabled\n-\t\t  && (!gimple_vdef (use_stmt) || defs.is_empty ()))\n+\t\t  && is_gimple_assign (use_stmt))\n \t\t{\n-\t\t  if (is_gimple_assign (use_stmt))\n+\t\t  ao_ref use_ref;\n+\t\t  ao_ref_init (&use_ref, gimple_assign_rhs1 (use_stmt));\n+\t\t  if (valid_ao_ref_for_dse (&use_ref)\n+\t\t      && use_ref.base == ref->base\n+\t\t      && known_eq (use_ref.size, use_ref.max_size)\n+\t\t      && !live_bytes_read (use_ref, ref, live_bytes))\n \t\t    {\n-\t\t      /* Other cases were noted as non-aliasing by\n-\t\t\t the call to ref_maybe_used_by_stmt_p.  */\n-\t\t      ao_ref use_ref;\n-\t\t      ao_ref_init (&use_ref, gimple_assign_rhs1 (use_stmt));\n-\t\t      if (valid_ao_ref_for_dse (&use_ref)\n-\t\t\t  && use_ref.base == ref->base\n-\t\t\t  && known_eq (use_ref.size, use_ref.max_size)\n-\t\t\t  && !live_bytes_read (use_ref, ref, live_bytes))\n-\t\t\t{\n-\t\t\t  /* If this statement has a VDEF, then it is the\n-\t\t\t     first store we have seen, so walk through it.  */\n-\t\t\t  if (gimple_vdef (use_stmt))\n-\t\t\t    defs.safe_push (use_stmt);\n-\t\t\t  continue;\n-\t\t\t}\n+\t\t      /* If this is a store, remember it as we possibly\n+\t\t\t need to walk the defs uses.  */\n+\t\t      if (gimple_vdef (use_stmt))\n+\t\t\tdefs.safe_push (use_stmt);\n+\t\t      continue;\n \t\t    }\n \t\t}\n "}]}