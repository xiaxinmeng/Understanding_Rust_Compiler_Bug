{"sha": "738e281059b7bd0f19aec2f0a08d00598c9a7469", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzM4ZTI4MTA1OWI3YmQwZjE5YWVjMmYwYTA4ZDAwNTk4YzlhNzQ2OQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-05-01T05:50:40Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-05-01T05:50:40Z"}, "message": "expr.c (cplus_expand_expr): Preserve temporaries when expanding STMT_EXPRs.\n\n\t* expr.c (cplus_expand_expr): Preserve temporaries when expanding\n\tSTMT_EXPRs.\n\t* optimize.c (struct inline_data): Add target_exprs field.\n\t(declare_return_variable): When a function returns an aggregate,\n\tuse the variable declared in the TARGET_EXPR as the remapped\n\tDECL_RESULT.\n\t(expand_call_inline): Update the pending target_exprs stack.\n\t(optimize_function): Initialize the stack.\n\nFrom-SVN: r33561", "tree": {"sha": "e41de7e1f2eea4b105de1a4b38766e800772579c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e41de7e1f2eea4b105de1a4b38766e800772579c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/738e281059b7bd0f19aec2f0a08d00598c9a7469", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/738e281059b7bd0f19aec2f0a08d00598c9a7469", "html_url": "https://github.com/Rust-GCC/gccrs/commit/738e281059b7bd0f19aec2f0a08d00598c9a7469", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/738e281059b7bd0f19aec2f0a08d00598c9a7469/comments", "author": null, "committer": null, "parents": [{"sha": "e3fdc58a352cfb510340ae819be8f27b30af1206", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3fdc58a352cfb510340ae819be8f27b30af1206", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3fdc58a352cfb510340ae819be8f27b30af1206"}], "stats": {"total": 110, "additions": 104, "deletions": 6}, "files": [{"sha": "ff7b02db562da8fd4aa892923127ead846cef63a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/738e281059b7bd0f19aec2f0a08d00598c9a7469/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/738e281059b7bd0f19aec2f0a08d00598c9a7469/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=738e281059b7bd0f19aec2f0a08d00598c9a7469", "patch": "@@ -1,5 +1,14 @@\n 2000-04-30  Mark Mitchell  <mark@codesourcery.com>\n \n+\t* expr.c (cplus_expand_expr): Preserve temporaries when expanding\n+\tSTMT_EXPRs.\n+\t* optimize.c (struct inline_data): Add target_exprs field.\n+\t(declare_return_variable): When a function returns an aggregate,\n+\tuse the variable declared in the TARGET_EXPR as the remapped\n+\tDECL_RESULT.\n+\t(expand_call_inline): Update the pending target_exprs stack.\n+\t(optimize_function): Initialize the stack.\n+\t\n \t* decl2.c (finish_file): Fix typo in comment.\n \n \t* method.c (emit_thunk): Don't try to return a `void' value."}, {"sha": "c47d3909a7216f2118796bebace27746050294d9", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/738e281059b7bd0f19aec2f0a08d00598c9a7469/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/738e281059b7bd0f19aec2f0a08d00598c9a7469/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=738e281059b7bd0f19aec2f0a08d00598c9a7469", "patch": "@@ -143,10 +143,21 @@ cplus_expand_expr (exp, target, tmode, modifier)\n \n     case STMT_EXPR:\n       {\n-\ttree rtl_expr = expand_start_stmt_expr ();\n+\ttree rtl_expr;\n+\trtx result;\n+\n+\t/* Since expand_expr_stmt calls free_temp_slots after every\n+\t   expression statement, we must call push_temp_slots here.\n+\t   Otherwise, any temporaries in use now would be considered\n+\t   out-of-scope after the first EXPR_STMT from within the\n+\t   STMT_EXPR.  */\n+\tpush_temp_slots ();\n+\trtl_expr = expand_start_stmt_expr ();\n \texpand_stmt (STMT_EXPR_STMT (exp));\n \texpand_end_stmt_expr (rtl_expr);\n-\treturn expand_expr (rtl_expr, target, tmode, modifier);\n+\tresult = expand_expr (rtl_expr, target, tmode, modifier);\n+\tpop_temp_slots ();\n+\treturn result;\n       }\n       break;\n "}, {"sha": "a83b6849ef3cb89d730816432e3c343621d2a51d", "filename": "gcc/cp/optimize.c", "status": "modified", "additions": 44, "deletions": 4, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/738e281059b7bd0f19aec2f0a08d00598c9a7469/gcc%2Fcp%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/738e281059b7bd0f19aec2f0a08d00598c9a7469/gcc%2Fcp%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foptimize.c?ref=738e281059b7bd0f19aec2f0a08d00598c9a7469", "patch": "@@ -60,6 +60,8 @@ typedef struct inline_data\n   /* Nonzero if we are currently within the cleanup for a\n      TARGET_EXPR.  */\n   int in_target_cleanup_p;\n+  /* A stack of the TARGET_EXPRs that we are currently processing.  */\n+  varray_type target_exprs;\n } inline_data;\n \n /* Prototypes.  */\n@@ -462,6 +464,7 @@ declare_return_variable (id, use_stmt)\n   tree fn = VARRAY_TOP_TREE (id->fns);\n   tree result = DECL_RESULT (fn);\n   tree var;\n+  int aggregate_return_p;\n \n   /* We don't need to do anything for functions that don't return\n      anything.  */\n@@ -472,8 +475,29 @@ declare_return_variable (id, use_stmt)\n       return NULL_TREE;\n     }\n \n-  /* Make an appropriate copy.  */\n-  var = copy_decl_for_inlining (result, fn, VARRAY_TREE (id->fns, 0));\n+  /* Figure out whether or not FN returns an aggregate.  */\n+  aggregate_return_p = IS_AGGR_TYPE (TREE_TYPE (result));\n+\n+  /* If FN returns an aggregate then the caller will always create the\n+     temporary (using a TARGET_EXPR) and the call will be the\n+     initializing expression for the TARGET_EXPR.  If we were just to\n+     create a new VAR_DECL here, then the result of this function\n+     would be copied (bitwise) into the variable initialized by the\n+     TARGET_EXPR.  That's incorrect, so we must transform any\n+     references to the RESULT into references to the target.  */\n+  if (aggregate_return_p)\n+    {\n+      my_friendly_assert (id->target_exprs->elements_used != 0,\n+\t\t\t  20000430);\n+      var = TREE_OPERAND (VARRAY_TOP_TREE (id->target_exprs), 0);\n+      my_friendly_assert (same_type_p (TREE_TYPE (var), \n+\t\t\t\t       TREE_TYPE (result)),\n+\t\t\t  20000430);\n+    }\n+  /* Otherwise, make an appropriate copy.  */\n+  else\n+    var = copy_decl_for_inlining (result, fn, VARRAY_TREE (id->fns, 0));\n+\n   /* Register the VAR_DECL as the equivalent for the RESULT_DECL; that\n      way, when the RESULT_DECL is encountered, it will be\n      automatically replaced by the VAR_DECL.  */\n@@ -484,8 +508,14 @@ declare_return_variable (id, use_stmt)\n   /* Build the USE_STMT.  */\n   *use_stmt = build_min_nt (EXPR_STMT, var);\n \n-  /* Build the declaration statement.  */\n-  return build_min_nt (DECL_STMT, var);\n+  /* Build the declaration statement if FN does not return an\n+     aggregate.  */\n+  if (!aggregate_return_p)\n+    return build_min_nt (DECL_STMT, var);\n+  /* If FN does return an aggregate, there's no need to declare the\n+     return variable; we're using a variable in our caller's frame.  */\n+  else\n+    return NULL_TREE;\n }\n \n /* Returns non-zero if FN is a function that can be inlined.  */\n@@ -586,6 +616,9 @@ expand_call_inline (tp, walk_subtrees, data)\n       /* We're walking our own subtrees.  */\n       *walk_subtrees = 0;\n \n+      /* Push *TP on the stack of pending TARGET_EXPRs.  */\n+      VARRAY_PUSH_TREE (id->target_exprs, *tp);\n+\n       /* Actually walk over them.  This loop is the body of\n \t walk_trees, omitting the case where the TARGET_EXPR\n \t itself is handled.  */\n@@ -598,6 +631,9 @@ expand_call_inline (tp, walk_subtrees, data)\n \t    --id->in_target_cleanup_p;\n \t}\n \n+      /* We're done with this TARGET_EXPR now.  */\n+      VARRAY_POP (id->target_exprs);\n+\n       return NULL_TREE;\n     }\n \n@@ -780,12 +816,16 @@ optimize_function (fn)\n \t    prev_fn = s->function_decl;\n \t  }\n \n+      /* Create the stack of TARGET_EXPRs.  */\n+      VARRAY_TREE_INIT (id.target_exprs, 32, \"target_exprs\");\n+\n       /* Replace all calls to inline functions with the bodies of those\n \t functions.  */\n       expand_calls_inline (&DECL_SAVED_TREE (fn), &id);\n \n       /* Clean up.  */\n       VARRAY_FREE (id.fns);\n+      VARRAY_FREE (id.target_exprs);\n     }\n }\n "}, {"sha": "2b166e2231294f828007aff4a9e25c00a6e2d73b", "filename": "gcc/testsuite/g++.old-deja/g++.other/dtor8.C", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/738e281059b7bd0f19aec2f0a08d00598c9a7469/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdtor8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/738e281059b7bd0f19aec2f0a08d00598c9a7469/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdtor8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdtor8.C?ref=738e281059b7bd0f19aec2f0a08d00598c9a7469", "patch": "@@ -0,0 +1,38 @@\n+// Special g++ Options: -O1\n+// Origin: Mark Mitchell <mark@codesourcery.com>\n+\n+int result;\n+\n+struct S\n+{\n+  S ();\n+  S (const S&);\n+  ~S ();\n+  \n+  int i;\n+  double d[18];\n+};\n+\n+S* s;\n+\n+S::S ()\n+{\n+  s = this;\n+}\n+\n+S::~S ()\n+{\n+  if (s != this)\n+    result = 1;\n+}\n+\n+inline S f ()\n+{\n+  return S ();\n+}\n+\n+int main ()\n+{\n+  f ();\n+  return result;\n+}"}]}