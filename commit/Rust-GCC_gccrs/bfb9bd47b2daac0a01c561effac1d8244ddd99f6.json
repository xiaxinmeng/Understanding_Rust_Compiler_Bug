{"sha": "bfb9bd47b2daac0a01c561effac1d8244ddd99f6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmZiOWJkNDdiMmRhYWMwYTAxYzU2MWVmZmFjMWQ4MjQ0ZGRkOTlmNg==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2018-07-25T02:11:31Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2018-07-25T02:11:31Z"}, "message": "PR tree-optimization/86622 - incorrect strlen of array of array plus variable offset\n\nPR tree-optimization/86622 - incorrect strlen of array of array plus variable offset\nPR tree-optimization/86532 - Wrong code due to a wrong strlen folding starting with r262522\n\ngcc/ChangeLog:\n\n\tPR tree-optimization/86622\n\tPR tree-optimization/86532\n\t* builtins.h (string_length): Declare.\n\t* builtins.c (c_strlen): Correct handling of non-constant offsets.\t\n\t(check_access): Be prepared for non-constant length ranges.\n\t(string_length): Make extern.\n\t* expr.c (string_constant): Only handle the minor non-constant\n\tarray index.  Use string_constant to compute the length of\n\ta generic string constant.\n\ngcc/testsuite/ChangeLog:\n\n\tPR tree-optimization/86622\n\tPR tree-optimization/86532\n\t* gcc.c-torture/execute/strlen-2.c: New test.\n\t* gcc.c-torture/execute/strlen-3.c: New test.\n\t* gcc.c-torture/execute/strlen-4.c: New test.\n\nFrom-SVN: r262958", "tree": {"sha": "bf72d7afae065152f74b4f862adffad1c954d61e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf72d7afae065152f74b4f862adffad1c954d61e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bfb9bd47b2daac0a01c561effac1d8244ddd99f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfb9bd47b2daac0a01c561effac1d8244ddd99f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bfb9bd47b2daac0a01c561effac1d8244ddd99f6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfb9bd47b2daac0a01c561effac1d8244ddd99f6/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ae752f020fd86b2d34a1556124dc4e5f01a8dcce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae752f020fd86b2d34a1556124dc4e5f01a8dcce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae752f020fd86b2d34a1556124dc4e5f01a8dcce"}], "stats": {"total": 715, "additions": 668, "deletions": 47}, "files": [{"sha": "ee4b21254ddc3b84a3bfe825642aeaaca2c31169", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfb9bd47b2daac0a01c561effac1d8244ddd99f6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfb9bd47b2daac0a01c561effac1d8244ddd99f6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bfb9bd47b2daac0a01c561effac1d8244ddd99f6", "patch": "@@ -1,3 +1,15 @@\n+2018-07-24  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/86622\n+\tPR tree-optimization/86532\n+\t* builtins.h (string_length): Declare.\n+\t* builtins.c (c_strlen): Correct handling of non-constant offsets.\t\n+\t(check_access): Be prepared for non-constant length ranges.\n+\t(string_length): Make extern.\n+\t* expr.c (string_constant): Only handle the minor non-constant\n+\tarray index.  Use string_constant to compute the length of\n+\ta generic string constant.\n+\n 2018-07-24  Richard Sandiford  <richard.sandiford@arm.com>\n \n \tPR tree-optimization/86618"}, {"sha": "aa3e0d80cd19a9cb2cfc6b707259ec3349b79f7a", "filename": "gcc/builtins.c", "status": "modified", "additions": 36, "deletions": 22, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfb9bd47b2daac0a01c561effac1d8244ddd99f6/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfb9bd47b2daac0a01c561effac1d8244ddd99f6/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=bfb9bd47b2daac0a01c561effac1d8244ddd99f6", "patch": "@@ -517,11 +517,11 @@ get_pointer_alignment (tree exp)\n   return align;\n }\n \n-/* Return the number of non-zero elements in the sequence\n+/* Return the number of leading non-zero elements in the sequence\n    [ PTR, PTR + MAXELTS ) where each element's size is ELTSIZE bytes.\n    ELTSIZE must be a power of 2 less than 8.  Used by c_strlen.  */\n \n-static unsigned\n+unsigned\n string_length (const void *ptr, unsigned eltsize, unsigned maxelts)\n {\n   gcc_checking_assert (eltsize == 1 || eltsize == 2 || eltsize == 4);\n@@ -605,25 +605,34 @@ c_strlen (tree src, int only_value)\n \n   /* Set MAXELTS to sizeof (SRC) / sizeof (*SRC) - 1, the maximum possible\n      length of SRC.  Prefer TYPE_SIZE() to TREE_STRING_LENGTH() if possible\n-     in case the latter is less than the size of the array.  */\n-  HOST_WIDE_INT maxelts = TREE_STRING_LENGTH (src);\n+     in case the latter is less than the size of the array, such as when\n+     SRC refers to a short string literal used to initialize a large array.\n+     In that case, the elements of the array after the terminating NUL are\n+     all NUL.  */\n+  HOST_WIDE_INT strelts = TREE_STRING_LENGTH (src);\n+  strelts = strelts / eltsize - 1;\n+\n+  HOST_WIDE_INT maxelts = strelts;\n   tree type = TREE_TYPE (src);\n   if (tree size = TYPE_SIZE_UNIT (type))\n     if (tree_fits_shwi_p (size))\n-      maxelts = tree_to_uhwi (size);\n-\n-  maxelts = maxelts / eltsize - 1;\n+      {\n+\tmaxelts = tree_to_uhwi (size);\n+\tmaxelts = maxelts / eltsize - 1;\n+      }\n \n   /* PTR can point to the byte representation of any string type, including\n      char* and wchar_t*.  */\n   const char *ptr = TREE_STRING_POINTER (src);\n \n   if (byteoff && TREE_CODE (byteoff) != INTEGER_CST)\n     {\n-      /* If the string has an internal zero byte (e.g., \"foo\\0bar\"), we can't\n-\t compute the offset to the following null if we don't know where to\n+      /* If the string has an internal NUL character followed by any\n+\t non-NUL characters (e.g., \"foo\\0bar\"), we can't compute\n+\t the offset to the following NUL if we don't know where to\n \t start searching for it.  */\n-      if (string_length (ptr, eltsize, maxelts) < maxelts)\n+      unsigned len = string_length (ptr, eltsize, strelts);\n+      if (len < strelts)\n \t{\n \t  /* Return when an embedded null character is found.  */\n \t  return NULL_TREE;\n@@ -633,12 +642,17 @@ c_strlen (tree src, int only_value)\n \treturn ssize_int (0);\n \n       /* We don't know the starting offset, but we do know that the string\n-\t has no internal zero bytes.  We can assume that the offset falls\n-\t within the bounds of the string; otherwise, the programmer deserves\n-\t what he gets.  Subtract the offset from the length of the string,\n-\t and return that.  This would perhaps not be valid if we were dealing\n-\t with named arrays in addition to literal string constants.  */\n-      return size_diffop_loc (loc, size_int (maxelts * eltsize), byteoff);\n+\t has no internal zero bytes.  If the offset falls within the bounds\n+\t of the string subtract the offset from the length of the string,\n+\t and return that.  Otherwise the length is zero.  Take care to\n+\t use SAVE_EXPR in case the OFFSET has side-effects.  */\n+      tree offsave = TREE_SIDE_EFFECTS (byteoff) ? save_expr (byteoff) : byteoff;\n+      offsave = fold_convert (ssizetype, offsave);\n+      tree condexp = fold_build2_loc (loc, LE_EXPR, boolean_type_node, offsave,\n+\t\t\t\t      build_int_cst (ssizetype, len * eltsize));\n+      tree lenexp = size_diffop_loc (loc, ssize_int (strelts * eltsize), offsave);\n+      return fold_build3_loc (loc, COND_EXPR, ssizetype, condexp, lenexp,\n+\t\t\t      build_zero_cst (ssizetype));\n     }\n \n   /* Offset from the beginning of the string in elements.  */\n@@ -3192,15 +3206,13 @@ check_access (tree exp, tree, tree, tree dstwrite,\n   if (dstwrite)\n     get_size_range (dstwrite, range);\n \n-  /* This can happen at -O0.  */\n-  if (range[0] && TREE_CODE (range[0]) != INTEGER_CST)\n-    return false;\n-\n   tree func = get_callee_fndecl (exp);\n \n   /* First check the number of bytes to be written against the maximum\n      object size.  */\n-  if (range[0] && tree_int_cst_lt (maxobjsize, range[0]))\n+  if (range[0]\n+      && TREE_CODE (range[0]) == INTEGER_CST\n+      && tree_int_cst_lt (maxobjsize, range[0]))\n     {\n       if (TREE_NO_WARNING (exp))\n \treturn false;\n@@ -3235,9 +3247,11 @@ check_access (tree exp, tree, tree, tree dstwrite,\n   if (range[0] || !exactwrite || integer_all_onesp (dstwrite))\n     {\n       if (range[0]\n+\t  && TREE_CODE (range[0]) == INTEGER_CST\n \t  && ((tree_fits_uhwi_p (dstsize)\n \t       && tree_int_cst_lt (dstsize, range[0]))\n-\t      || (tree_fits_uhwi_p (dstwrite)\n+\t      || (dstwrite\n+\t\t  && tree_fits_uhwi_p (dstwrite)\n \t\t  && tree_int_cst_lt (dstwrite, range[0]))))\n \t{\n \t  if (TREE_NO_WARNING (exp))"}, {"sha": "2e0a2f95379d5df4df62cea307bfa137287a30eb", "filename": "gcc/builtins.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfb9bd47b2daac0a01c561effac1d8244ddd99f6/gcc%2Fbuiltins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfb9bd47b2daac0a01c561effac1d8244ddd99f6/gcc%2Fbuiltins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.h?ref=bfb9bd47b2daac0a01c561effac1d8244ddd99f6", "patch": "@@ -57,6 +57,7 @@ extern unsigned int get_object_alignment (tree);\n extern bool get_pointer_alignment_1 (tree, unsigned int *,\n \t\t\t\t     unsigned HOST_WIDE_INT *);\n extern unsigned int get_pointer_alignment (tree);\n+extern unsigned string_length (const void*, unsigned, unsigned);\n extern tree c_strlen (tree, int);\n extern void expand_builtin_setjmp_setup (rtx, rtx);\n extern void expand_builtin_setjmp_receiver (rtx);"}, {"sha": "de6709defd601b8dfb9d49f45b4e19fcd97504f2", "filename": "gcc/expr.c", "status": "modified", "additions": 37, "deletions": 25, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfb9bd47b2daac0a01c561effac1d8244ddd99f6/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfb9bd47b2daac0a01c561effac1d8244ddd99f6/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=bfb9bd47b2daac0a01c561effac1d8244ddd99f6", "patch": "@@ -11294,12 +11294,15 @@ string_constant (tree arg, tree *ptr_offset)\n \t  tree idx = TREE_OPERAND (arg, 1);\n \t  if (TREE_CODE (idx) != INTEGER_CST)\n \t    {\n-\t      /* Extract the variable index to prevent\n-\t\t get_addr_base_and_unit_offset() from failing due to\n-\t\t it.  Use it later to compute the non-constant offset\n+\t      /* From a pointer (but not array) argument extract the variable\n+\t\t index to prevent get_addr_base_and_unit_offset() from failing\n+\t\t due to it.  Use it later to compute the non-constant offset\n \t\t into the string and return it to the caller.  */\n \t      varidx = idx;\n \t      ref = TREE_OPERAND (arg, 0);\n+\n+\t      if (TREE_CODE (TREE_TYPE (arg)) == ARRAY_TYPE)\n+\t\treturn NULL_TREE;\n \t    }\n \t}\n       array = get_addr_base_and_unit_offset (ref, &base_off);\n@@ -11327,6 +11330,12 @@ string_constant (tree arg, tree *ptr_offset)\n       tree offset;\n       if (tree str = string_constant (arg0, &offset))\n \t{\n+\t  /* Avoid pointers to arrays (see bug 86622).  */\n+\t  if (POINTER_TYPE_P (TREE_TYPE (arg))\n+\t      && TREE_CODE (TREE_TYPE (TREE_TYPE (arg))) == ARRAY_TYPE\n+\t      && TREE_CODE (TREE_OPERAND (arg0, 0)) == ARRAY_REF)\n+\t    return NULL_TREE;\n+\n \t  tree type = TREE_TYPE (arg1);\n \t  *ptr_offset = fold_build2 (PLUS_EXPR, type, offset, arg1);\n \t  return str;\n@@ -11343,16 +11352,17 @@ string_constant (tree arg, tree *ptr_offset)\n     {\n       if (TREE_CODE (TREE_TYPE (array)) != ARRAY_TYPE)\n \treturn NULL_TREE;\n-      if (tree eltsize = TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (array))))\n-\t{\n-\t  /* Add the scaled variable index to the constant offset.  */\n-\t  tree eltoff = fold_build2 (MULT_EXPR, TREE_TYPE (offset),\n-\t\t\t\t     fold_convert (sizetype, varidx),\n-\t\t\t\t     eltsize);\n-\t  offset = fold_build2 (PLUS_EXPR, TREE_TYPE (offset), offset, eltoff);\n-\t}\n-      else\n-\treturn NULL_TREE;\n+\n+      gcc_assert (TREE_CODE (arg) == ARRAY_REF);\n+      tree chartype = TREE_TYPE (TREE_TYPE (TREE_OPERAND (arg, 0)));\n+      if (TREE_CODE (chartype) != INTEGER_TYPE)\n+\treturn NULL;\n+\n+      tree charsize = array_ref_element_size (arg);\n+      /* Set the non-constant offset to the non-constant index scaled\n+\t by the size of the character type.  */\n+      offset = fold_build2 (MULT_EXPR, TREE_TYPE (offset),\n+\t\t\t    fold_convert (sizetype, varidx), charsize);\n     }\n \n   if (TREE_CODE (array) == STRING_CST)\n@@ -11371,11 +11381,6 @@ string_constant (tree arg, tree *ptr_offset)\n     return NULL_TREE;\n   if (TREE_CODE (init) == CONSTRUCTOR)\n     {\n-      if (TREE_CODE (arg) != ARRAY_REF\n-\t  && TREE_CODE (arg) == COMPONENT_REF\n-\t  && TREE_CODE (arg) == MEM_REF)\n-\treturn NULL_TREE;\n-\n       /* Convert the 64-bit constant offset to a wider type to avoid\n \t overflow.  */\n       offset_int wioff;\n@@ -11391,11 +11396,15 @@ string_constant (tree arg, tree *ptr_offset)\n       init = fold_ctor_reference (NULL_TREE, init, base_off, 0, array,\n \t\t\t\t  &fieldoff);\n       HOST_WIDE_INT cstoff;\n-      if (init && base_off.is_constant (&cstoff))\n-\t{\n-\t  cstoff = (cstoff - fieldoff) / BITS_PER_UNIT;\n-\t  offset = build_int_cst (sizetype, cstoff);\n-\t}\n+      if (!base_off.is_constant (&cstoff))\n+\treturn NULL_TREE;\n+\n+      cstoff = (cstoff - fieldoff) / BITS_PER_UNIT;\n+      tree off = build_int_cst (sizetype, cstoff);\n+      if (varidx)\n+\toffset = fold_build2 (PLUS_EXPR, TREE_TYPE (offset), offset, off);\n+      else\n+\toffset = off;\n     }\n \n   if (!init || TREE_CODE (init) != STRING_CST)\n@@ -11413,8 +11422,11 @@ string_constant (tree arg, tree *ptr_offset)\n      const char a[4] = \"abc\\000\\000\";\n      The excess elements contribute to TREE_STRING_LENGTH()\n      but not to strlen().  */\n-  unsigned HOST_WIDE_INT length\n-    = strnlen (TREE_STRING_POINTER (init), TREE_STRING_LENGTH (init));\n+  unsigned HOST_WIDE_INT charsize\n+    = tree_to_uhwi (TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (init))));\n+  unsigned HOST_WIDE_INT length = TREE_STRING_LENGTH (init);\n+  length = string_length (TREE_STRING_POINTER (init), charsize,\n+\t\t\t  length / charsize);\n   if (compare_tree_int (array_size, length + 1) < 0)\n     return NULL_TREE;\n "}, {"sha": "af40567347d3dd52e7c62c5484634fb3d6955995", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfb9bd47b2daac0a01c561effac1d8244ddd99f6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfb9bd47b2daac0a01c561effac1d8244ddd99f6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bfb9bd47b2daac0a01c561effac1d8244ddd99f6", "patch": "@@ -1,3 +1,11 @@\n+2018-07-24  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/86622\n+\tPR tree-optimization/86532\n+\t* gcc.c-torture/execute/strlen-2.c: New test.\n+\t* gcc.c-torture/execute/strlen-3.c: New test.\n+\t* gcc.c-torture/execute/strlen-4.c: New test.\n+\n 2018-07-24  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR tree-optimization/86636"}, {"sha": "4519f6a4680ccb8fa351daa98e7d7a7690613771", "filename": "gcc/testsuite/gcc.c-torture/execute/strlen-2.c", "status": "added", "additions": 210, "deletions": 0, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfb9bd47b2daac0a01c561effac1d8244ddd99f6/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstrlen-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfb9bd47b2daac0a01c561effac1d8244ddd99f6/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstrlen-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstrlen-2.c?ref=bfb9bd47b2daac0a01c561effac1d8244ddd99f6", "patch": "@@ -0,0 +1,210 @@\n+/* PR tree-optimization/86532 - Wrong code due to a wrong strlen folding  */\n+\n+extern __SIZE_TYPE__ strlen (const char*);\n+\n+static const char a[2][3] = { \"1\", \"12\" };\n+static const char b[2][2][5] = { { \"1\", \"12\" }, { \"123\", \"1234\" } };\n+\n+volatile int v0 = 0;\n+volatile int v1 = 1;\n+volatile int v2 = 2;\n+\n+#define A(expr)\t\t\t\t\t\t\t\t\\\n+  ((expr) ? (void)0 : (__builtin_printf (\"assertion on line %i: %s\\n\",\t\\\n+\t\t\t\t\t __LINE__, #expr),\t\t\\\n+\t\t       __builtin_abort ()))\n+\n+void test_array_ref_2_3 (void)\n+{\n+  A (strlen (a[v0]) == 1);\n+  A (strlen (&a[v0][v0]) == 1);\n+  A (strlen (&a[0][v0]) == 1);\n+  A (strlen (&a[v0][0]) == 1);\n+\n+  A (strlen (a[v1]) == 2);\n+  A (strlen (&a[v1][0]) == 2);\n+  A (strlen (&a[1][v0]) == 2);\n+  A (strlen (&a[v1][v0]) == 2);\n+\n+  A (strlen (&a[v1][1]) == 1);\n+  A (strlen (&a[v1][1]) == 1);\n+\n+  A (strlen (&a[v1][2]) == 0);\n+  A (strlen (&a[v1][v2]) == 0);\n+\n+  int i0 = 0;\n+  int i1 = i0 + 1;\n+  int i2 = i1 + 1;\n+\n+  A (strlen (a[v0]) == 1);\n+  A (strlen (&a[v0][v0]) == 1);\n+  A (strlen (&a[i0][v0]) == 1);\n+  A (strlen (&a[v0][i0]) == 1);\n+\n+  A (strlen (a[v1]) == 2);\n+  A (strlen (&a[v1][i0]) == 2);\n+  A (strlen (&a[i1][v0]) == 2);\n+  A (strlen (&a[v1][v0]) == 2);\n+\n+  A (strlen (&a[v1][i1]) == 1);\n+  A (strlen (&a[v1][i1]) == 1);\n+\n+  A (strlen (&a[v1][i2]) == 0);\n+  A (strlen (&a[v1][v2]) == 0);\n+}\n+\n+void test_array_off_2_3 (void)\n+{\n+  A (strlen (a[0] + 0) == 1);\n+  A (strlen (a[0] + v0) == 1);\n+  A (strlen (a[v0] + 0) == 1);\n+  A (strlen (a[v0] + v0) == 1);\n+\n+  A (strlen (a[v1] + 0) == 2);\n+  A (strlen (a[1] + v0) == 2);\n+  A (strlen (a[v1] + 0) == 2);\n+  A (strlen (a[v1] + v0) == 2);\n+\n+  A (strlen (a[v1] + 1) == 1);\n+  A (strlen (a[v1] + v1) == 1);\n+\n+  A (strlen (a[v1] + 2) == 0);\n+  A (strlen (a[v1] + v2) == 0);\n+\n+  int i0 = 0;\n+  int i1 = i0 + 1;\n+  int i2 = i1 + 1;\n+\n+  A (strlen (a[i0] + i0) == 1);\n+  A (strlen (a[i0] + v0) == 1);\n+  A (strlen (a[v0] + i0) == 1);\n+  A (strlen (a[v0] + v0) == 1);\n+\n+  A (strlen (a[v1] + i0) == 2);\n+  A (strlen (a[i1] + v0) == 2);\n+  A (strlen (a[v1] + i0) == 2);\n+  A (strlen (a[v1] + v0) == 2);\n+\n+  A (strlen (a[v1] + i1) == 1);\n+  A (strlen (a[v1] + v1) == 1);\n+\n+  A (strlen (a[v1] + i2) == 0);\n+  A (strlen (a[v1] + v2) == 0);\n+}\n+\n+void test_array_ref_2_2_5 (void)\n+{\n+  A (strlen (b[0][v0]) == 1);\n+  A (strlen (b[v0][0]) == 1);\n+\n+  A (strlen (&b[0][0][v0]) == 1);\n+  A (strlen (&b[0][v0][0]) == 1);\n+  A (strlen (&b[v0][0][0]) == 1);\n+\n+  A (strlen (&b[0][v0][v0]) == 1);\n+  A (strlen (&b[v0][0][v0]) == 1);\n+  A (strlen (&b[v0][v0][0]) == 1);\n+\n+  A (strlen (b[0][v1]) == 2);\n+  A (strlen (b[v1][0]) == 3);\n+\n+  A (strlen (&b[0][0][v1]) == 0);\n+  A (strlen (&b[0][v1][0]) == 2);\n+  A (strlen (&b[v0][0][0]) == 1);\n+\n+  A (strlen (&b[0][v0][v0]) == 1);\n+  A (strlen (&b[v0][0][v0]) == 1);\n+  A (strlen (&b[v0][v0][0]) == 1);\n+\n+  A (strlen (&b[0][v1][v1]) == 1);\n+  A (strlen (&b[v1][0][v1]) == 2);\n+  A (strlen (&b[v1][v1][0]) == 4);\n+  A (strlen (&b[v1][v1][1]) == 3);\n+  A (strlen (&b[v1][v1][2]) == 2);\n+\n+  int i0 = 0;\n+  int i1 = i0 + 1;\n+  int i2 = i1 + 1;\n+\n+  A (strlen (b[i0][v0]) == 1);\n+  A (strlen (b[v0][i0]) == 1);\n+\n+  A (strlen (&b[i0][i0][v0]) == 1);\n+  A (strlen (&b[i0][v0][i0]) == 1);\n+  A (strlen (&b[v0][i0][i0]) == 1);\n+\n+  A (strlen (&b[i0][v0][v0]) == 1);\n+  A (strlen (&b[v0][i0][v0]) == 1);\n+  A (strlen (&b[v0][v0][i0]) == 1);\n+\n+  A (strlen (b[i0][v1]) == 2);\n+  A (strlen (b[v1][i0]) == 3);\n+\n+  A (strlen (&b[i0][i0][v1]) == 0);\n+  A (strlen (&b[i0][v1][i0]) == 2);\n+  A (strlen (&b[v0][i0][i0]) == 1);\n+\n+  A (strlen (&b[i0][v0][v0]) == 1);\n+  A (strlen (&b[v0][i0][v0]) == 1);\n+  A (strlen (&b[v0][v0][i0]) == 1);\n+\n+  A (strlen (&b[i0][v1][v1]) == 1);\n+  A (strlen (&b[v1][i0][v1]) == 2);\n+  A (strlen (&b[v1][v1][i0]) == 4);\n+  A (strlen (&b[v1][v1][i1]) == 3);\n+  A (strlen (&b[v1][v1][i2]) == 2);\n+}\n+\n+void test_array_off_2_2_5 (void)\n+{\n+  A (strlen (b[0][0] + v0) == 1);\n+  A (strlen (b[0][v0] + v0) == 1);\n+  A (strlen (b[v0][0] + v0) == 1);\n+  A (strlen (b[v0][v0] + v0) == 1);\n+\n+  A (strlen (b[0][0] + v1) == 0);\n+  A (strlen (b[0][v1] + 0) == 2);\n+  A (strlen (b[v0][0] + 0) == 1);\n+\n+  A (strlen (b[0][v0] + v0) == 1);\n+  A (strlen (b[v0][0] + v0) == 1);\n+  A (strlen (b[v0][v0] + 0) == 1);\n+\n+  A (strlen (b[0][v1] + v1) == 1);\n+  A (strlen (b[v1][0] + v1) == 2);\n+  A (strlen (b[v1][v1] + 0) == 4);\n+  A (strlen (b[v1][v1] + 1) == 3);\n+  A (strlen (b[v1][v1] + 2) == 2);\n+\n+  int i0 = 0;\n+  int i1 = i0 + 1;\n+  int i2 = i1 + 1;\n+\n+  A (strlen (b[i0][i0] + v0) == 1);\n+  A (strlen (b[i0][v0] + v0) == 1);\n+  A (strlen (b[v0][i0] + v0) == 1);\n+  A (strlen (b[v0][v0] + v0) == 1);\n+\n+  A (strlen (b[i0][i0] + v1) == 0);\n+  A (strlen (b[i0][v1] + i0) == 2);\n+  A (strlen (b[v0][i0] + i0) == 1);\n+\n+  A (strlen (b[i0][v0] + v0) == 1);\n+  A (strlen (b[v0][i0] + v0) == 1);\n+  A (strlen (b[v0][v0] + i0) == 1);\n+\n+  A (strlen (b[i0][v1] + v1) == 1);\n+  A (strlen (b[v1][i0] + v1) == 2);\n+  A (strlen (b[v1][v1] + i0) == 4);\n+  A (strlen (b[v1][v1] + i1) == 3);\n+  A (strlen (b[v1][v1] + i2) == 2);\n+}\n+\n+int main ()\n+{\n+  test_array_ref_2_3 ();\n+  test_array_off_2_3 ();\n+\n+  test_array_ref_2_2_5 ();\n+  test_array_off_2_2_5 ();\n+}"}, {"sha": "182afdd1fa6f6b1024ffc47059ea14873711281d", "filename": "gcc/testsuite/gcc.c-torture/execute/strlen-3.c", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfb9bd47b2daac0a01c561effac1d8244ddd99f6/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstrlen-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfb9bd47b2daac0a01c561effac1d8244ddd99f6/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstrlen-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstrlen-3.c?ref=bfb9bd47b2daac0a01c561effac1d8244ddd99f6", "patch": "@@ -0,0 +1,132 @@\n+/* PR tree-optimization/86532 - Wrong code due to a wrong strlen folding\n+   starting with r262522\n+   Exercise strlen() with a multi-dimensional array of strings with\n+   embedded nuls.  */\n+\n+extern __SIZE_TYPE__ strlen (const char*);\n+\n+static const char a[2][3][9] = {\n+  { \"1\", \"1\\0002\" },\n+  { \"12\\0003\", \"123\\0004\" }\n+};\n+\n+volatile int v0 = 0;\n+volatile int v1 = 1;\n+volatile int v2 = 2;\n+volatile int v3 = 3;\n+volatile int v4 = 4;\n+volatile int v5 = 5;\n+volatile int v6 = 6;\n+volatile int v7 = 7;\n+\n+#define A(expr)\t\t\t\t\t\t\t\t\\\n+  ((expr) ? (void)0 : (__builtin_printf (\"assertion on line %i: %s\\n\",\t\\\n+\t\t\t\t\t __LINE__, #expr),\t\t\\\n+\t\t       __builtin_abort ()))\n+\n+void test_array_ref (void)\n+{\n+  int i0 = 0;\n+  int i1 = i0 + 1;\n+  int i2 = i1 + 1;\n+  int i3 = i2 + 1;\n+  int i4 = i3 + 1;\n+  int i5 = i4 + 1;\n+  int i6 = i5 + 1;\n+  int i7 = i6 + 1;\n+\n+  A (strlen (a[0][0]) == 1);\n+  A (strlen (a[0][1]) == 1);\n+\n+  A (strlen (a[1][0]) == 2);\n+  A (strlen (a[1][1]) == 3);\n+\n+  A (strlen (&a[0][0][0]) == 1);\n+  A (strlen (&a[0][1][0]) == 1);\n+\n+  A (strlen (&a[1][0][0]) == 2);\n+  A (strlen (&a[1][1][0]) == 3);\n+\n+  A (strlen (&a[0][0][0] + 1) == 0);\n+  A (strlen (&a[0][1][0] + 1) == 0);\n+  A (strlen (&a[0][1][0] + 2) == 1);\n+  A (strlen (&a[0][1][0] + 3) == 0);\n+  A (strlen (&a[0][1][0] + 7) == 0);\n+\n+  A (strlen (&a[1][0][0] + 1) == 1);\n+  A (strlen (&a[1][1][0] + 1) == 2);\n+  A (strlen (&a[1][1][0] + 2) == 1);\n+  A (strlen (&a[1][1][0] + 7) == 0);\n+\n+\n+  A (strlen (a[i0][i0]) == 1);\n+  A (strlen (a[i0][i1]) == 1);\n+\n+  A (strlen (a[i1][i0]) == 2);\n+  A (strlen (a[i1][i1]) == 3);\n+\n+  A (strlen (&a[i0][i0][i0]) == 1);\n+  A (strlen (&a[i0][i1][i0]) == 1);\n+  A (strlen (&a[i0][i1][i1]) == 0);\n+  A (strlen (&a[i0][i1][i2]) == 1);\n+  A (strlen (&a[i0][i1][i3]) == 0);\n+  A (strlen (&a[i0][i1][i3]) == 0);\n+\n+  A (strlen (&a[i1][i0][i0]) == 2);\n+  A (strlen (&a[i1][i1][i0]) == 3);\n+  A (strlen (&a[i1][i1][i1]) == 2);\n+  A (strlen (&a[i1][i1][i2]) == 1);\n+  A (strlen (&a[i1][i1][i3]) == 0);\n+  A (strlen (&a[i1][i1][i4]) == 1);\n+  A (strlen (&a[i1][i1][i5]) == 0);\n+  A (strlen (&a[i1][i1][i6]) == 0);\n+  A (strlen (&a[i1][i1][i7]) == 0);\n+\n+  A (strlen (&a[i0][i0][i0] + i1) == 0);\n+  A (strlen (&a[i0][i1][i0] + i1) == 0);\n+  A (strlen (&a[i0][i1][i0] + i7) == 0);\n+\n+  A (strlen (&a[i1][i0][i0] + i1) == 1);\n+  A (strlen (&a[i1][i1][i0] + i1) == 2);\n+  A (strlen (&a[i1][i1][i0] + i2) == 1);\n+  A (strlen (&a[i1][i1][i0] + i3) == 0);\n+  A (strlen (&a[i1][i1][i0] + i4) == 1);\n+  A (strlen (&a[i1][i1][i0] + i5) == 0);\n+  A (strlen (&a[i1][i1][i0] + i6) == 0);\n+  A (strlen (&a[i1][i1][i0] + i7) == 0);\n+\n+\n+  A (strlen (a[i0][i0]) == 1);\n+  A (strlen (a[i0][i1]) == 1);\n+\n+  A (strlen (a[i1][i0]) == 2);\n+  A (strlen (a[i1][i1]) == 3);\n+\n+  A (strlen (&a[i0][i0][i0]) == 1);\n+  A (strlen (&a[i0][i1][i0]) == 1);\n+\n+  A (strlen (&a[i1][i0][i0]) == 2);\n+  A (strlen (&a[i1][i1][i0]) == 3);\n+\n+  A (strlen (&a[i0][i0][i0] + v1) == 0);\n+  A (strlen (&a[i0][i0][i0] + v2) == 0);\n+  A (strlen (&a[i0][i0][i0] + v7) == 0);\n+\n+  A (strlen (&a[i0][i1][i0] + v1) == 0);\n+  A (strlen (&a[i0][i1][i0] + v2) == 1);\n+  A (strlen (&a[i0][i1][i0] + v3) == 0);\n+\n+  A (strlen (&a[i1][i0][i0] + v1) == 1);\n+  A (strlen (&a[i1][i1][i0] + v1) == 2);\n+  A (strlen (&a[i1][i1][i0] + v2) == 1);\n+  A (strlen (&a[i1][i1][i0] + v3) == 0);\n+  A (strlen (&a[i1][i1][i0] + v4) == 1);\n+  A (strlen (&a[i1][i1][i0] + v5) == 0);\n+  A (strlen (&a[i1][i1][i0] + v6) == 0);\n+  A (strlen (&a[i1][i1][i0] + v7) == 0);\n+}\n+\n+int main (void)\n+{\n+  test_array_ref ();\n+}"}, {"sha": "c3b2c7712f6a147b968c072e2245830b84f6d3d0", "filename": "gcc/testsuite/gcc.c-torture/execute/strlen-4.c", "status": "added", "additions": 232, "deletions": 0, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfb9bd47b2daac0a01c561effac1d8244ddd99f6/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstrlen-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfb9bd47b2daac0a01c561effac1d8244ddd99f6/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstrlen-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstrlen-4.c?ref=bfb9bd47b2daac0a01c561effac1d8244ddd99f6", "patch": "@@ -0,0 +1,232 @@\n+/* PR tree-optimization/86622 - incorrect strlen of array of array plus\n+   variable offset\n+   Exercise strlen() with a multi-dimensional array of strings with\n+   offsets.  */\n+\n+extern int printf (const char*, ...);\n+extern __SIZE_TYPE__ strlen (const char*);\n+\n+typedef char A28[28];\n+typedef A28 A3_28[3];\n+typedef A3_28 A2_3_28[2];\n+\n+static const A2_3_28 a = {\n+  /* [0][0]    [0][1]         [0][2] */\n+  { \"1\\00012\", \"123\\0001234\", \"12345\\000123456\" },\n+  /* [1][0]    [1][1]         [1][2] */\n+  { \"1234567\\00012345678\", \"123456789\\0001234567890\", \"12345678901\\000123456789012\" }\n+};\n+\n+volatile int v0 = 0;\n+volatile int v1 = 1;\n+volatile int v2 = 2;\n+volatile int v3 = 3;\n+volatile int v4 = 4;\n+volatile int v5 = 5;\n+volatile int v6 = 6;\n+volatile int v7 = 7;\n+\n+#define A(expr, N)\t\t\t\t\t\t\t\\\n+  ((strlen (expr) == N)\t\t\t\t\t\t\t\\\n+   ? (void)0 : (printf (\"line %i: strlen (%s = \\\"%s\\\") != %i\\n\",\t\\\n+\t\t\t__LINE__, #expr, expr, N),\t\t\t\\\n+\t\t__builtin_abort ()))\n+\n+/* Verify that strlen() involving pointer to array arguments computes\n+   the correct result.  */\n+\n+void test_array_ptr (void)\n+{\n+  /* Compute the length of the string at the refeenced array.  */\n+  A (*(&a[0][0] + 0), 1);\n+  A (*(&a[0][0] + 1), 3);\n+  A (*(&a[0][0] + 2), 5);\n+\n+  A (*(&a[0][1] - 1), 1);\n+  A (*(&a[0][1] + 0), 3);\n+  A (*(&a[0][1] + 1), 5);\n+\n+  A (*(&a[0][2] - 2), 1);\n+  A (*(&a[0][2] - 1), 3);\n+  A (*(&a[0][2] + 0), 5);\n+\n+  A (*(&a[1][0] + 0), 7);\n+  A (*(&a[1][0] + 1), 9);\n+  A (*(&a[1][0] + 2), 11);\n+\n+  A (*(&a[1][1] - 1), 7);\n+  A (*(&a[1][1] + 0), 9);\n+  A (*(&a[1][1] + 1), 11);\n+\n+  A (*(&a[1][2] - 2), 7);\n+  A (*(&a[1][2] - 1), 9);\n+  A (*(&a[1][2] - 0), 11);\n+\n+  /* Compute the length of the string past the first nul.  */\n+  A (*(&a[0][0] + 0) + 2, 2);\n+  A (*(&a[0][0] + 1) + 4, 4);\n+  A (*(&a[0][0] + 2) + 6, 6);\n+\n+  /* Compute the length of the string past the second nul.  */\n+  A (*(&a[0][0] + 0) + 5, 0);\n+  A (*(&a[0][0] + 1) + 10, 0);\n+  A (*(&a[0][0] + 2) + 14, 0);\n+\n+  int i0 = 0;\n+  int i1 = i0 + 1;\n+  int i2 = i1 + 1;\n+  int i3 = i2 + 1;\n+  int i4 = i3 + 1;\n+  int i5 = i4 + 1;\n+\n+  A (*(&a[0][0] + i0), 1);\n+  A (*(&a[0][0] + i1), 3);\n+  A (*(&a[0][0] + i2), 5);\n+\n+  A (*(&a[0][1] - i1), 1);\n+  A (*(&a[0][1] + i0), 3);\n+  A (*(&a[0][1] + i1), 5);\n+\n+  A (*(&a[0][2] - i2), 1);\n+  A (*(&a[0][2] - i1), 3);\n+  A (*(&a[0][2] + i0), 5);\n+\n+  A (*(&a[1][0] + i0), 7);\n+  A (*(&a[1][0] + i1), 9);\n+  A (*(&a[1][0] + i2), 11);\n+\n+  A (*(&a[1][1] - i1), 7);\n+  A (*(&a[1][1] + i0), 9);\n+  A (*(&a[1][1] + i1), 11);\n+\n+  A (*(&a[1][2] - i2), 7);\n+  A (*(&a[1][2] - i1), 9);\n+  A (*(&a[1][2] - i0), 11);\n+\n+\n+  A (*(&a[i0][i0] + i0), 1);\n+  A (*(&a[i0][i0] + i1), 3);\n+  A (*(&a[i0][i0] + i2), 5);\n+\n+  A (*(&a[i0][i1] - i1), 1);\n+  A (*(&a[i0][i1] + i0), 3);\n+  A (*(&a[i0][i1] + i1), 5);\n+\n+  A (*(&a[i0][i2] - i2), 1);\n+  A (*(&a[i0][i2] - i1), 3);\n+  A (*(&a[i0][i2] + i0), 5);\n+\n+  A (*(&a[i1][i0] + i0), 7);\n+  A (*(&a[i1][i0] + i1), 9);\n+  A (*(&a[i1][i0] + i2), 11);\n+\n+  A (*(&a[i1][i1] - i1), 7);\n+  A (*(&a[i1][i1] + i0), 9);\n+  A (*(&a[i1][i1] + i1), 11);\n+\n+  A (*(&a[i1][i2] - i2), 7);\n+  A (*(&a[i1][i2] - i1), 9);\n+  A (*(&a[i1][i2] - i0), 11);\n+\n+\n+  A (*(&a[i0][i0] + v0), 1);\n+  A (*(&a[i0][i0] + v1), 3);\n+  A (*(&a[i0][i0] + v2), 5);\n+\n+  A (*(&a[i0][i1] - v1), 1);\n+  A (*(&a[i0][i1] + v0), 3);\n+  A (*(&a[i0][i1] + v1), 5);\n+\n+  A (*(&a[i0][i2] - v2), 1);\n+  A (*(&a[i0][i2] - v1), 3);\n+  A (*(&a[i0][i2] + v0), 5);\n+\n+  A (*(&a[i1][i0] + v0), 7);\n+  A (*(&a[i1][i0] + v1), 9);\n+  A (*(&a[i1][i0] + v2), 11);\n+\n+  A (*(&a[i1][i1] - v1), 7);\n+  A (*(&a[i1][i1] + v0), 9);\n+  A (*(&a[i1][i1] + v1), 11);\n+\n+  A (*(&a[i1][i2] - v2), 7);\n+  A (*(&a[i1][i2] - v1), 9);\n+  A (*(&a[i1][i2] - v0), 11);\n+\n+\n+  A (*(&a[i0][i0] + v0) + i1, 0);\n+  A (*(&a[i0][i0] + v1) + i2, 1);\n+  A (*(&a[i0][i0] + v2) + i3, 2);\n+\n+  A (*(&a[i0][i1] - v1) + v1, 0);\n+  A (*(&a[i0][i1] + v0) + v3, 0);\n+  A (*(&a[i0][i1] + v1) + v5, 0);\n+\n+  A (*(&a[i0][v1] - i1) + i1, 0);\n+  A (*(&a[i0][v1] + i0) + i3, 0);\n+  A (*(&a[i0][v1] + i1) + i5, 0);\n+}\n+\n+static const A3_28* const pa0 = &a[0];\n+static const A3_28* const pa1 = &a[1];\n+\n+static const A3_28* const paa[] = { &a[0], &a[1] };\n+\n+/* Verify that strlen() involving pointers and arrays of pointers\n+   to array arguments computes the correct result.  */\n+\n+void test_ptr_array (void)\n+{\n+  int i0 = 0;\n+  int i1 = i0 + 1;\n+  int i2 = i1 + 1;\n+  int i3 = i2 + 1;\n+\n+  A (*((*pa0) + i0), 1);\n+  A (*((*pa0) + i1), 3);\n+  A (*((*pa0) + i2), 5);\n+\n+  A (*(pa0[0] + i0), 1);\n+  A (*(pa0[0] + i1), 3);\n+  A (*(pa0[0] + i2), 5);\n+\n+  A ((*pa0)[i0] + i1, 0);\n+  A ((*pa0)[i1] + i2, 1);\n+  A ((*pa0)[i2] + i3, 2);\n+\n+\n+  A (*((*pa1) + i0), 7);\n+  A (*((*pa1) + i1), 9);\n+  A (*((*pa1) + i2), 11);\n+\n+  A (*(pa1[0] + i0), 7);\n+  A (*(pa1[0] + i1), 9);\n+  A (*(pa1[0] + i2), 11);\n+\n+  A ((*pa1)[i0] + i1, 6);\n+  A ((*pa1)[i1] + i2, 7);\n+  A ((*pa1)[i2] + i3, 8);\n+\n+  A (*(*(paa[0]) + i0), 1);\n+  A (*(*(paa[0]) + i1), 3);\n+  A (*(*(paa[0]) + i2), 5);\n+\n+  A (*(*(paa[1]) + i0), 7);\n+  A (*(*(paa[1]) + i1), 9);\n+  A (*(*(paa[1]) + i2), 11);\n+\n+  A (*(*(paa[1]) - i1), 5);\n+  A (*(*(paa[1]) - i2), 3);\n+  A (*(*(paa[1]) - i3), 1);\n+\n+  A (*(*(paa[0]) + i0) + i1, 0);\n+  A (*(*(paa[0]) + i1) + i2, 1);\n+  A (*(*(paa[0]) + i2) + i3, 2);\n+}\n+\n+int main (void)\n+{\n+  test_array_ptr ();\n+\n+  test_ptr_array ();\n+}"}]}