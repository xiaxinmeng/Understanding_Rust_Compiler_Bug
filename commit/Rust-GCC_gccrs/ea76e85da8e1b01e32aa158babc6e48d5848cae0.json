{"sha": "ea76e85da8e1b01e32aa158babc6e48d5848cae0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWE3NmU4NWRhOGUxYjAxZTMyYWExNThiYWJjNmU0OGQ1ODQ4Y2FlMA==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1991-12-01T04:57:16Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1991-12-01T04:57:16Z"}, "message": "Initial revision\n\nFrom-SVN: r86", "tree": {"sha": "fef1f2e84f42b27cf6f7fd0d8ea4791860d01b74", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fef1f2e84f42b27cf6f7fd0d8ea4791860d01b74"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ea76e85da8e1b01e32aa158babc6e48d5848cae0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea76e85da8e1b01e32aa158babc6e48d5848cae0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea76e85da8e1b01e32aa158babc6e48d5848cae0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea76e85da8e1b01e32aa158babc6e48d5848cae0/comments", "author": null, "committer": null, "parents": [{"sha": "868df7f7f9a31877be4e4acbc1095072f1e6d362", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/868df7f7f9a31877be4e4acbc1095072f1e6d362", "html_url": "https://github.com/Rust-GCC/gccrs/commit/868df7f7f9a31877be4e4acbc1095072f1e6d362"}], "stats": {"total": 448, "additions": 448, "deletions": 0}, "files": [{"sha": "69fab57aa103864daaa491f32c7e7474cd95e8f4", "filename": "gcc/config/i386/isccoff.h", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea76e85da8e1b01e32aa158babc6e48d5848cae0/gcc%2Fconfig%2Fi386%2Fisccoff.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea76e85da8e1b01e32aa158babc6e48d5848cae0/gcc%2Fconfig%2Fi386%2Fisccoff.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fisccoff.h?ref=ea76e85da8e1b01e32aa158babc6e48d5848cae0", "patch": "@@ -0,0 +1,36 @@\n+/* Definitions for Intel 386 running Interactive Unix System V.\n+   Specifically, this is for recent versions that support POSIX;\n+   for version 2.0.2, use configuration option i386-sysv instead.  */\n+\n+/* Mostly it's like AT&T Unix System V. */\n+\n+#include \"i386v.h\"\n+\n+/* Use crt0.o or crt1.o as a startup file and crtn.o as a closing file.  */\n+#undef STARTFILE_SPEC\n+#define STARTFILE_SPEC \\\n+  \"%{!shlib:%{posix:%{pg:mcrtp1.o%s}%{!pg:%{p:mcrtp1.o%s}%{!p:crtp0.o%s}}}\\\n+   %{!posix:%{pg:mcrt0.o%s}%{!pg:%{p:mcrt0.o%s}%{!p:crt0.o%s}}\\\n+   %{p:-L/lib/libp} %{pg:-L/lib/libp}}}\\\n+   %{shlib:%{posix:crtp1.o%s}%{!posix:crt1.o%s}} \"\n+\n+#define ENDFILE_SPEC \"crtn.o%s\"\n+\n+/* Library spec */\n+#undef LIB_SPEC\n+#define LIB_SPEC \"%{posix:-lcposix} %{shlib:-lc_s} -lc\"\n+\n+/* caller has to pop the extra argument passed to functions that return\n+   structures. */\n+\n+#undef RETURN_POPS_ARGS\n+#define RETURN_POPS_ARGS(FUNTYPE,SIZE)   \\\n+  (TREE_CODE (FUNTYPE) == IDENTIFIER_NODE ? 0\t\t\t\\\n+   : (TARGET_RTD\t\t\t\t\t\t\\\n+      && (TYPE_ARG_TYPES (FUNTYPE) == 0\t\t\t\t\\\n+\t  || (TREE_VALUE (tree_last (TYPE_ARG_TYPES (FUNTYPE)))\t\\\n+\t      == void_type_node))) ? (SIZE)\t\t\t\\\n+   : 0)\n+/* On other 386 systems, the last line looks like this:\n+   : (aggregate_value_p (FUNTYPE)) ? GET_MODE_SIZE (Pmode) : 0)  */\n+"}, {"sha": "4365a8ddab427592b696337a5d21b3de6c6b16ec", "filename": "gcc/config/m68k/apollo68.h", "status": "added", "additions": 180, "deletions": 0, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea76e85da8e1b01e32aa158babc6e48d5848cae0/gcc%2Fconfig%2Fm68k%2Fapollo68.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea76e85da8e1b01e32aa158babc6e48d5848cae0/gcc%2Fconfig%2Fm68k%2Fapollo68.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fapollo68.h?ref=ea76e85da8e1b01e32aa158babc6e48d5848cae0", "patch": "@@ -0,0 +1,180 @@\n+/* Definitions of target machine for GNU compiler.  Apollo 680X0 version.\n+   Copyright (C) 1989 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include \"m68k.h\"\n+\n+/* This symbol may be tested in other files for special Apollo handling */\n+\n+#define TM_APOLLO\n+\n+/* See m68k.h.  7 means 68020 with 68881.  */\n+\n+#ifndef TARGET_DEFAULT\n+#define TARGET_DEFAULT 7\n+#endif\n+\n+/* Target switches for the Apollo is the same as in m68k.h, except\n+   there is no Sun FPA. */\n+\n+#undef TARGET_SWITCHES\n+#define TARGET_SWITCHES  \\\n+  { { \"68020\", 5},\t\t\t\t\\\n+    { \"c68020\", 5},\t\t\t\t\\\n+    { \"68881\", 2},\t\t\t\t\\\n+    { \"bitfield\", 4},\t\t\t\t\\\n+    { \"68000\", -5},\t\t\t\t\\\n+    { \"c68000\", -5},\t\t\t\t\\\n+    { \"soft-float\", -0102},\t\t\t\\\n+    { \"nobitfield\", -4},\t\t\t\\\n+    { \"rtd\", 8},\t\t\t\t\\\n+    { \"nortd\", -8},\t\t\t\t\\\n+    { \"short\", 040},\t\t\t\t\\\n+    { \"noshort\", -040},\t\t\t\t\\\n+    { \"\", TARGET_DEFAULT}}\n+\n+/* Define __HAVE_68881__ in preprocessor,\n+   according to the -m flags.\n+   This will control the use of inline 68881 insns in certain macros.\n+   Also inform the program which CPU this is for.  */\n+\n+#if TARGET_DEFAULT & 02\n+\n+/* -m68881 is the default */\n+#define CPP_SPEC \\\n+\"%{!msoft-float:%{mfpa:-D__HAVE_FPA__ }%{!mfpa:-D__HAVE_68881__ }}\\\n+%{!ansi:%{m68000:-Dmc68010 }%{mc68000:-Dmc68010 }%{!mc68000:%{!m68000:-Dmc68020 }}\\\n+%{!ansi:-D_APOLLO_SOURCE}}\"\n+\n+#else\n+\n+/* -msoft-float is the default */\n+#define CPP_SPEC \\\n+\"%{m68881:-D__HAVE_68881__ }%{mfpa:-D__HAVE_FPA__ }\\\n+%{!ansi:%{m68000:-Dmc68010 }%{mc68000:-Dmc68010 }%{!mc68000:%{!m68000:-Dmc68020 }}\\\n+%{!ansi:-D_APOLLO_SOURCE}}\"\n+\n+#endif\n+\n+/* Names to predefine in the preprocessor for this target machine.  */\n+/* These are the ones defined by Apollo, plus mc68000 for uniformity with\n+   GCC on other 68000 systems.  */\n+\n+#define CPP_PREDEFINES \"-Dapollo -Daegis -Dunix\"\n+\n+/* cpp has to support a #sccs directive for the /usr/include files */\n+\n+#define SCCS_DIRECTIVE\n+\n+/* Allow #ident but output nothing for it.  */\n+\n+#define IDENT_DIRECTIVE\n+#define ASM_OUTPUT_IDENT(FILE, NAME)\n+\n+/* Allow dollarsigns in identifiers */\n+\n+#define DOLLARS_IN_IDENTIFIERS 2\n+\n+/* -m68000 requires special flags to the assembler.\n+   The -C flag is passed to a modified GNU assembler to cause COFF\n+   modules to be produced.  Remove it if you're not using this.\n+   (See vasta@apollo.com.)  */\n+\n+#define ASM_SPEC \\\n+ \"-C %{m68000:-mc68010}%{mc68000:-mc68010}%{!mc68000:%{!m68000:-mc68020}}\"\n+\n+/* STARTFILE_SPEC\n+   Note that includes knowledge of the default specs for gcc, ie. no\n+   args translates to the same effect as -m68881 */\n+\n+#if TARGET_DEFAULT & 2\n+/* -m68881 is the default */\n+#define STARTFILE_SPEC\t\t\t\t\t\\\n+  \"%{pg:gcrt0.o%s}%{!pg:%{p:mcrt0.o%s}%{!p:crt0.o%s}}\"\n+#else\n+/* -msoft-float is the default */\n+#define STARTFILE_SPEC\t\t\t\t\t\\\n+  \"%{pg:gcrt0.o%s}%{!pg:%{p:mcrt0.o%s}%{!p:crt0.o%s}}\"\n+#endif\n+\n+/* Specify library to handle `-a' basic block profiling.  */\n+\n+#define LIB_SPEC \"%{!p:%{!pg:-lc}}%{p:-lc_p}%{pg:-lc_p} \\\n+%{a:/usr/lib/bb_link.o} \"\n+\n+/* Debugging is not supported yet */\n+\n+#undef DBX_DEBUGGING_INFO\n+#undef SDB_DEBUGGING_INFO\n+\n+/* Every structure or union's size must be a multiple of 2 bytes.  */\n+\n+#define STRUCTURE_SIZE_BOUNDARY 16\n+\n+/* Functions which return large structures get the address\n+   to place the wanted value at offset 8 from the frame.  */\n+\n+#undef  PCC_STATIC_STRUCT_RETURN\n+#undef  STRUCT_VALUE_REGNUM\n+\n+/* Caller treats address of return area like a parm.  */\n+#define STRUCT_VALUE 0\n+\n+#define STRUCT_VALUE_INCOMING \\\n+  gen_rtx (MEM, Pmode,\t\t\t\t\t\\\n+\t   gen_rtx (PLUS, SImode, frame_pointer_rtx,\t\\\n+\t\t    gen_rtx (CONST_INT, VOIDmode, 8)))\n+\n+/* Boundary (in *bits*) on which stack pointer should be aligned.  */\n+#undef STACK_BOUNDARY\n+#define STACK_BOUNDARY 32\n+\n+/* Specify how to pad function arguments.\n+   Arguments are not padded at all; the stack is kept aligned on long\n+   boundaries. */\n+\n+#define FUNCTION_ARG_PADDING(mode, size) none\n+\n+/* Short integral argument prototype promotion is not done */\n+\n+#undef  PROMOTE_PROTOTYPES\n+\n+/* The definition of this macro imposes a limit on the size of\n+   an aggregate object which can be treated as if it were a scalar\n+   object. */\n+\n+#define MAX_FIXED_MODE_SIZE    BITS_PER_WORD\n+\n+/* The definition of this macro implies that there are cases where\n+   a scalar value cannot be returned in registers.\n+   For Apollo, anything larger than one integer register is returned\n+   using the structure-value mechanism, i.e. objects of DFmode are\n+   returned that way. */\n+\n+#define RETURN_IN_MEMORY(type) \\\n+  (GET_MODE_SIZE (TYPE_MODE (type)) > UNITS_PER_WORD)\n+\n+/* This is how to output a reference to a user-level label named NAME.\n+   In order to link to Apollo libraries, no underscore is prepended to names.\n+   `assemble_name' uses this.  */\n+\n+#undef  ASM_OUTPUT_LABELREF\n+#define ASM_OUTPUT_LABELREF(FILE,NAME)\t\\\n+  fprintf (FILE, \"%s\", NAME)\n+\n+"}, {"sha": "3392634d23dd9a8d1763ee044bd13f5fad6d405b", "filename": "gcc/config/m68k/hp2bsd.h", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea76e85da8e1b01e32aa158babc6e48d5848cae0/gcc%2Fconfig%2Fm68k%2Fhp2bsd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea76e85da8e1b01e32aa158babc6e48d5848cae0/gcc%2Fconfig%2Fm68k%2Fhp2bsd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fhp2bsd.h?ref=ea76e85da8e1b01e32aa158babc6e48d5848cae0", "patch": "@@ -0,0 +1,69 @@\n+/* Definitions of target machine for GNU compiler.  HP 9000/200 68000 version.\n+   Copyright (C) 1987 - 1991 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include \"m68k.h\"\n+\n+/* See m68k.h.  0 means 68000 with no 68881.  */\n+\n+#define TARGET_DEFAULT -0102\n+\n+/* Define __HAVE_68881 in preprocessor only if -m68881 is specified.\n+   This will control the use of inline 68881 insns in certain macros.\n+   Also inform the program which CPU this is for.  */\n+\n+#define CPP_SPEC \"%{m68881:-D__HAVE_68881__} \\\n+%{!ansi:%{m68020:-Dmc68020}%{mc68020:-Dmc68020}%{!mc68020:%{!m68020:-Dmc68010}}}\"\n+\n+/* -m68020 requires special flags to the assembler.  */\n+\n+#define ASM_SPEC \\\n+ \"%{m68020:-mc68020}%{mc68020:-mc68020}%{!mc68020:%{!m68020:-mc68010}}\"\n+\n+/* Names to predefine in the preprocessor for this target machine.  */\n+\n+#define CPP_PREDEFINES \"-Dmc68000 -Dmc68010 -Dhp200 -Dunix\"\n+\n+/* Link with libg.a when debugging, for dbx's sake.  */\n+\n+#define LIB_SPEC \"%{g:-lg} %{!p:%{!pg:-lc}}%{p:-lc_p}%{pg:-lc_p} \"\n+\n+/* Alignment of field after `int : 0' in a structure.  */\n+\n+#undef EMPTY_FIELD_BOUNDARY\n+#define EMPTY_FIELD_BOUNDARY 16\n+\n+/* Every structure or union's size must be a multiple of 2 bytes.  */\n+\n+#define STRUCTURE_SIZE_BOUNDARY 16\n+\n+/* This is BSD, so it wants DBX format.  */\n+\n+#define DBX_DEBUGGING_INFO\n+\n+/* Define subroutines to call to handle multiply, divide, and remainder.\n+   These routines are built into the c-library on the hp200.\n+   XXX What other routines from the c-library could we use?\n+   The `*' prevents an underscore from being prepended by the compiler.  */\n+\n+#define DIVSI3_LIBCALL \"*ldiv\"\n+#define UDIVSI3_LIBCALL \"*uldiv\"\n+#define MODSI3_LIBCALL \"*lrem\"\n+#define UMODSI3_LIBCALL \"*ulrem\"\n+#define MULSI3_LIBCALL \"*lmul\"\n+#define UMULSI3_LIBCALL \"*ulmul\""}, {"sha": "f0fe09cb807823604ec1dad3ba9de0f6843cccbf", "filename": "gcc/config/ns32k/genix.h", "status": "added", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea76e85da8e1b01e32aa158babc6e48d5848cae0/gcc%2Fconfig%2Fns32k%2Fgenix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea76e85da8e1b01e32aa158babc6e48d5848cae0/gcc%2Fconfig%2Fns32k%2Fgenix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fgenix.h?ref=ea76e85da8e1b01e32aa158babc6e48d5848cae0", "patch": "@@ -0,0 +1,163 @@\n+/* Definitions of target machine for GNU compiler.  Genix ns32000 version.\n+   Copyright (C) 1987, 1988 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include \"encore.h\"\n+\n+/* We don't want the one Encore needs.  */\n+#undef ASM_SPEC\n+\n+/* The following defines override ones in ns32k.h and prevent any attempts\n+   to explicitly or implicitly make references to the SB register in the GCC\n+   generated code.  It is necessary to avoid such references under Genix V.3.1\n+   because this OS doesn't even save/restore the SB on context switches!  */\n+\n+#define IS_OK_REG_FOR_BASE_P(X)\t\t\t\t\t\t\\\n+  ( (GET_CODE (X) == REG) && REG_OK_FOR_BASE_P (X) )\n+\n+#undef INDIRECTABLE_1_ADDRESS_P\n+#define INDIRECTABLE_1_ADDRESS_P(X)\t\t\t\t\t\\\n+  (CONSTANT_ADDRESS_NO_LABEL_P (X)\t\t\t\t\t\\\n+   || IS_OK_REG_FOR_BASE_P (X)\t\t\t\t\t\t\\\n+   || (GET_CODE (X) == PLUS\t\t\t\t\t\t\\\n+       && IS_OK_REG_FOR_BASE_P (XEXP (X, 0))\t\t\t\t\\\n+       && CONSTANT_ADDRESS_P (XEXP (X, 1))  )  )\n+\n+/* Note that for double indirects, only FP, SP, and SB are allowed\n+   as the inner-most base register.  But we are avoiding use of SB.  */\n+\n+#undef MEM_REG\n+#define MEM_REG(X)\t\t\t\t\t\t\t\\\n+  ( (GET_CODE (X) == REG)\t\t\t\t\t\t\\\n+  && ( (REGNO (X) == FRAME_POINTER_REGNUM)\t\t\t\t\\\n+    || (REGNO (X) == STACK_POINTER_REGNUM) ) )\n+\n+#undef INDIRECTABLE_2_ADDRESS_P\n+#define INDIRECTABLE_2_ADDRESS_P(X)\t\t\t\t\t\\\n+  (GET_CODE (X) == MEM\t\t\t\t\t\t\t\\\n+   && (((xfoo0 = XEXP (X, 0), MEM_REG (xfoo0))\t\t\t\t\\\n+       || (GET_CODE (xfoo0) == PLUS\t\t\t\t\t\\\n+\t   && MEM_REG (XEXP (xfoo0, 0))\t\t\t\t\t\\\n+\t   && CONSTANT_ADDRESS_NO_LABEL_P (XEXP (xfoo0, 1))))\t\t\\\n+       || CONSTANT_ADDRESS_NO_LABEL_P (xfoo0)))\n+\n+/* Go to ADDR if X is a valid address not using indexing.\n+   (This much is the easy part.)  */\n+#undef GO_IF_NONINDEXED_ADDRESS\n+#define GO_IF_NONINDEXED_ADDRESS(X, ADDR)\t\t\t\t\\\n+{ register rtx xfoob = (X);\t\t\t\t\t\t\\\n+  if (GET_CODE (xfoob) == REG) goto ADDR;\t\t\t\t\\\n+  if (INDIRECTABLE_1_ADDRESS_P(X)) goto ADDR;\t\t\t\t\\\n+  if (CONSTANT_P(X)) goto ADDR;\t\t\t\t\t\t\\\n+  if (INDIRECTABLE_2_ADDRESS_P (X)) goto ADDR;\t\t\t\t\\\n+  if (GET_CODE (X) == PLUS)\t\t\t\t\t\t\\\n+    if (CONSTANT_ADDRESS_NO_LABEL_P (XEXP (X, 1)))\t\t\t\\\n+      if (INDIRECTABLE_2_ADDRESS_P (XEXP (X, 0)))\t\t\t\\\n+\tgoto ADDR;\t\t\t\t\t\t\t\\\n+}\n+\n+/* A bug in the GNX 3.X assembler causes references to external symbols to\n+   be mishandled if the symbol is also used as the name of a function-local\n+   variable or as the name of a struct or union field.  The problem only\n+   appears when you are also using the -g option so that SDB debugging\n+   directives are also being produced by GCC.  In such cases, the assembler\n+   gets the external entity confused with the local entity and addressing\n+   havoc ensues.  The solution is to get GCC to produce .global directives\n+   for all external entities which are actually referenced within the current\n+   source file.  The following macro does this.  */\n+\n+#define ASM_OUTPUT_EXTERNAL(FILE, DECL, NAME)\t\t\t\t\\\n+    ASM_GLOBALIZE_LABEL(FILE,NAME);\n+\n+/* Genix wants 0l instead of 0f.  */\n+\n+#undef ASM_OUTPUT_DOUBLE\n+#define ASM_OUTPUT_DOUBLE(FILE,VALUE)\t\t\t\t\\\n+ fprintf (FILE, \"\\t.long 0l%.20e\\n\", (VALUE))\n+\n+/*  A bug in the GNX 3.X linker prevents symbol-table entries with a storage-\n+    class field of C_EFCN (-1) from being accepted. */\n+\n+#ifdef PUT_SDB_EPILOGUE_END\n+#undef PUT_SDB_EPILOGUE_END\n+#endif\n+#define PUT_SDB_EPILOGUE_END(NAME)\n+\n+#undef TARGET_VERSION\n+#define TARGET_VERSION fprintf (stderr, \" (32000, National syntax)\");\n+\n+/* Same as the encore definition except\n+   * Different syntax for double constants.\n+   * Don't output `?' before external regs.\n+   * Output `(sb)' in certain indirect refs.  */\n+\n+#undef PRINT_OPERAND\n+#define PRINT_OPERAND(FILE, X, CODE)\t\t\t\t\t\\\n+{ if (CODE == '$') putc ('$', FILE);\t\t\t\t\t\\\n+  else if (CODE == '?');\t\t\t\t\t\t\\\n+  else if (GET_CODE (X) == REG)\t\t\t\t\t\t\\\n+    fprintf (FILE, \"%s\", reg_names[REGNO (X)]);\t\t\t\t\\\n+  else if (GET_CODE (X) == MEM)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      rtx xfoo;\t\t\t\t\t\t\t\t\\\n+      xfoo = XEXP (X, 0);\t\t\t\t\t\t\\\n+      switch (GET_CODE (xfoo))\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\tcase MEM:\t\t\t\t\t\t\t\\\n+\t  if (GET_CODE (XEXP (xfoo, 0)) == REG)\t\t\t\t\\\n+\t    if (REGNO (XEXP (xfoo, 0)) == STACK_POINTER_REGNUM)\t\t\\\n+\t      fprintf (FILE, \"0(0(sp))\");\t\t\t\t\\\n+\t    else fprintf (FILE, \"0(0(%s))\",\t\t\t\t\\\n+\t\t\t  reg_names[REGNO (XEXP (xfoo, 0))]);\t\t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      extern int paren_base_reg_printed;\t\t\t\\\n+\t      fprintf (FILE, \"0(\");\t\t\t\t\t\\\n+\t      paren_base_reg_printed = 0;\t\t\t\t\\\n+\t      output_address (xfoo);\t\t\t\t\t\\\n+\t      if (!paren_base_reg_printed)\t\t\t\t\\\n+\t\tfprintf (FILE, \"(sb)\");\t\t\t\t\t\\\n+\t      putc (')', FILE);\t\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\t\\\n+\tcase REG:\t\t\t\t\t\t\t\\\n+\t  fprintf (FILE, \"0(%s)\", reg_names[REGNO (xfoo)]);\t\t\\\n+\t  break;\t\t\t\t\t\t\t\\\n+\tcase PRE_DEC:\t\t\t\t\t\t\t\\\n+\tcase POST_INC:\t\t\t\t\t\t\t\\\n+\t  fprintf (FILE, \"tos\");\t\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\t\\\n+\tcase CONST_INT:\t\t\t\t\t\t\t\\\n+\t  fprintf (FILE, \"@%d\", INTVAL (xfoo));\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\t\\\n+\tdefault:\t\t\t\t\t\t\t\\\n+\t  output_address (xfoo);\t\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else if (GET_CODE (X) == CONST_DOUBLE && GET_MODE (X) != DImode)\t\\\n+    if (GET_MODE (X) == DFmode)\t\t\t\t\t\t\\\n+      { union { double d; int i[2]; } u;\t\t\t\t\\\n+        u.i[0] = CONST_DOUBLE_LOW (X); u.i[1] = CONST_DOUBLE_HIGH (X);\t\\\n+\tfprintf (FILE, \"$0l%.20e\", u.d); }\t\t\t\t\\\n+    else { union { double d; int i[2]; } u;\t\t\t\t\\\n+\t   u.i[0] = CONST_DOUBLE_LOW (X); u.i[1] = CONST_DOUBLE_HIGH (X); \\\n+\t   fprintf (FILE, \"$0f%.20e\", u.d); }\t\t\t\t\\\n+  else if (GET_CODE (X) == CONST)\t\t\t\t\t\\\n+    output_addr_const (FILE, X);\t\t\t\t\t\\\n+  else { putc ('$', FILE); output_addr_const (FILE, X); }}"}]}