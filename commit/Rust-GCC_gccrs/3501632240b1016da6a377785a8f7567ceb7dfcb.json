{"sha": "3501632240b1016da6a377785a8f7567ceb7dfcb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzUwMTYzMjI0MGIxMDE2ZGE2YTM3Nzc4NWE4Zjc1NjdjZWI3ZGZjYg==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1992-04-19T01:55:55Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1992-04-19T01:55:55Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r788", "tree": {"sha": "bfe9b0b6b898000347629b5c4c01cd9434979a72", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bfe9b0b6b898000347629b5c4c01cd9434979a72"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3501632240b1016da6a377785a8f7567ceb7dfcb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3501632240b1016da6a377785a8f7567ceb7dfcb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3501632240b1016da6a377785a8f7567ceb7dfcb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3501632240b1016da6a377785a8f7567ceb7dfcb/comments", "author": null, "committer": null, "parents": [{"sha": "56a2f049100e12cc7a96480a6879c229778515ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56a2f049100e12cc7a96480a6879c229778515ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56a2f049100e12cc7a96480a6879c229778515ef"}], "stats": {"total": 185, "additions": 185, "deletions": 0}, "files": [{"sha": "aa7c291f5f504c8be5c48814c33fc52fc24c155e", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3501632240b1016da6a377785a8f7567ceb7dfcb/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3501632240b1016da6a377785a8f7567ceb7dfcb/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=3501632240b1016da6a377785a8f7567ceb7dfcb", "patch": "@@ -2250,6 +2250,107 @@ output_arc_profiler (arcno, insert_after)\n   emit_insn_after (gen_rtx (SET, VOIDmode, mem_ref, profiler_reg),\n \t\t   insert_after);\n }\n+\n+/* Return 1 if REGNO (reg1) is even and REGNO (reg1) == REGNO (reg2) - 1.\n+   This makes them candidates for using ldd and std insns. \n+\n+   Note reg1 and reg2 *must* be hard registers.  To be sure we will\n+   abort if we are passed pseudo registers.  */\n+\n+int\n+registers_ok_for_ldd (reg1, reg2)\n+     rtx reg1, reg2;\n+{\n+\n+  /* We might have been passed a SUBREG.  */\n+  if (GET_CODE (reg1) != REG || GET_CODE (reg2) != REG) \n+    return 0;\n+\n+  /* Should never happen.  */\n+  if (REGNO (reg1) > FIRST_PSEUDO_REGISTER \n+      || REGNO (reg2) > FIRST_PSEUDO_REGISTER)\n+    abort ();\n+\n+  if (REGNO (reg1) % 2 != 0)\n+    return 0;\n+\n+  return (REGNO (reg1) == REGNO (reg2) - 1);\n+  \n+}\n+\n+/* Return 1 if addr1 and addr2 are suitable for use in an ldd or \n+   std insn.\n+\n+   This can only happen when addr1 and addr2 are consecutive memory\n+   locations (addr1 + 4 == addr2).  addr1 must also be aligned on a \n+   64 bit boundary (addr1 % 8 == 0).  \n+\n+   We know %sp and %fp are kept aligned on a 64 bit boundary.  Other\n+   registers are assumed to *never* be properly aligned and are \n+   rejected.\n+\n+   Knowing %sp and %fp are kept aligned on a 64 bit boundary, we \n+   need only check that the offset for addr1 % 8 == 0.  */\n+\n+int\n+memory_ok_for_ldd (addr1, addr2)\n+      rtx addr1, addr2;\n+{\n+  int reg1, offset1;\n+\n+  /* Extract a register number and offset (if used) from the first addr.  */\n+  if (GET_CODE (addr1) == PLUS)\n+    {\n+      /* If not a REG, return zero.  */\n+      if (GET_CODE (XEXP (addr1, 0)) != REG)\n+\treturn 0;\n+      else\n+\t{\n+          reg1 = REGNO (XEXP (addr1, 0));\n+\t  /* The offset must be constant!  */\n+\t  if (GET_CODE (XEXP (addr1, 1)) != CONST_INT)\n+            return 0;\n+          offset1 = INTVAL (XEXP (addr1, 1));\n+\t}\n+    }\n+  else if (GET_CODE (addr1) != REG)\n+    return 0;\n+  else\n+    {\n+      reg1 = REGNO (addr1);\n+      /* This was a simple (mem (reg)) expression.  Offset is 0.  */\n+      offset1 = 0;\n+    }\n+\n+  /* Make sure the second address is a (mem (plus (reg) (const_int).  */\n+  if (GET_CODE (addr2) != PLUS)\n+    return 0;\n+\n+  if (GET_CODE (XEXP (addr2, 0)) != REG\n+      || GET_CODE (XEXP (addr2, 1)) != CONST_INT)\n+    return 0;\n+\n+  /* Only %fp and %sp are allowed.  Additionally both addresses must\n+     use the same register.  */\n+  if (reg1 != FRAME_POINTER_REGNUM && reg1 != STACK_POINTER_REGNUM)\n+    return 0;\n+\n+  if (reg1 != REGNO (XEXP (addr2, 0)))\n+    return 0;\n+\n+  /* The first offset must be evenly divisable by 8 to ensure the \n+     address is 64 bit aligned.  */\n+  if (offset1 % 8 != 0)\n+    return 0;\n+\n+  /* The offset for the second addr must be 4 more than the first addr.  */\n+  if (INTVAL (XEXP (addr2, 1)) != offset1 + 4)\n+    return 0;\n+\n+  /* All the tests passed.  addr1 and addr2 are valid for ldd and std\n+     instructions.  */\n+  return 1;\n+}\n \f\n /* Print operand X (an rtx) in assembler syntax to file FILE.\n    CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified."}, {"sha": "31faa3c7104ed56bca2918a85336288fb11f17f9", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3501632240b1016da6a377785a8f7567ceb7dfcb/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3501632240b1016da6a377785a8f7567ceb7dfcb/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=3501632240b1016da6a377785a8f7567ceb7dfcb", "patch": "@@ -2584,6 +2584,90 @@\n \f\n ;; Peepholes go at the end.\n \n+;; Optimize consecutive loads or stores into ldd and std when possible.\n+;; The conditions in which we do this are very restricted and are \n+;; explained in the code for {registers,memory}_ok_for_ldd functions.\n+\n+(define_peephole\n+  [(set (match_operand:SI 0 \"register_operand\" \"r\")\n+        (match_operand:SI 1 \"memory_operand\" \"\"))\n+   (set (match_operand:SI 2 \"register_operand\" \"r\")\n+        (match_operand:SI 3 \"memory_operand\" \"\"))]\n+  \"registers_ok_for_ldd (operands[0], operands[2]) \n+   && ! MEM_VOLATILE_P (operands[1]) && ! MEM_VOLATILE_P (operands[3])\n+   && memory_ok_for_ldd (XEXP (operands[1], 0), XEXP (operands[3], 0))\" \n+  \"ldd %1,%0\")\n+\n+(define_peephole\n+  [(set (match_operand:SI 0 \"memory_operand\" \"\")\n+        (match_operand:SI 1 \"register_operand\" \"r\"))\n+   (set (match_operand:SI 2 \"memory_operand\" \"\")\n+        (match_operand:SI 3 \"register_operand\" \"r\"))]\n+  \"registers_ok_for_ldd (operands[1], operands[3]) \n+   && ! MEM_VOLATILE_P (operands[0]) && ! MEM_VOLATILE_P (operands[2])\n+   && memory_ok_for_ldd (XEXP (operands[0], 0), XEXP (operands[2], 0))\"\n+  \"std %1,%0\")\n+ \n+(define_peephole\n+  [(set (match_operand:SF 0 \"register_operand\" \"fr\")\n+        (match_operand:SF 1 \"memory_operand\" \"\"))\n+   (set (match_operand:SF 2 \"register_operand\" \"fr\")\n+        (match_operand:SF 3 \"memory_operand\" \"\"))]\n+  \"registers_ok_for_ldd (operands[0], operands[2]) \n+   && ! MEM_VOLATILE_P (operands[1]) && ! MEM_VOLATILE_P (operands[3])\n+   && memory_ok_for_ldd (XEXP (operands[1], 0), XEXP (operands[3], 0))\"\n+  \"ldd %1,%0\")\n+\n+(define_peephole\n+  [(set (match_operand:SF 0 \"memory_operand\" \"\")\n+        (match_operand:SF 1 \"register_operand\" \"fr\"))\n+   (set (match_operand:SF 2 \"memory_operand\" \"\")\n+        (match_operand:SF 3 \"register_operand\" \"fr\"))]\n+  \"registers_ok_for_ldd (operands[1], operands[3]) \n+   && ! MEM_VOLATILE_P (operands[0]) && ! MEM_VOLATILE_P (operands[2])\n+   && memory_ok_for_ldd (XEXP (operands[0], 0), XEXP (operands[2], 0))\"\n+  \"std %1,%0\")\n+\n+(define_peephole\n+  [(set (match_operand:SI 0 \"register_operand\" \"r\")\n+        (match_operand:SI 1 \"memory_operand\" \"\"))\n+   (set (match_operand:SI 2 \"register_operand\" \"r\")\n+        (match_operand:SI 3 \"memory_operand\" \"\"))]\n+  \"registers_ok_for_ldd (operands[2], operands[0]) \n+   && ! MEM_VOLATILE_P (operands[3]) && ! MEM_VOLATILE_P (operands[1])\n+   && memory_ok_for_ldd (XEXP (operands[3], 0), XEXP (operands[1], 0))\"\n+  \"ldd %3,%2\")\n+\n+(define_peephole\n+  [(set (match_operand:SI 0 \"memory_operand\" \"\")\n+        (match_operand:SI 1 \"register_operand\" \"r\"))\n+   (set (match_operand:SI 2 \"memory_operand\" \"\")\n+        (match_operand:SI 3 \"register_operand\" \"r\"))]\n+  \"registers_ok_for_ldd (operands[3], operands[1]) \n+   && ! MEM_VOLATILE_P (operands[2]) && ! MEM_VOLATILE_P (operands[0])\n+   && memory_ok_for_ldd (XEXP (operands[2], 0), XEXP (operands[0], 0))\" \n+  \"std %3,%2\")\n+ \n+(define_peephole\n+  [(set (match_operand:SF 0 \"register_operand\" \"fr\")\n+        (match_operand:SF 1 \"memory_operand\" \"\"))\n+   (set (match_operand:SF 2 \"register_operand\" \"fr\")\n+        (match_operand:SF 3 \"memory_operand\" \"\"))]\n+  \"registers_ok_for_ldd (operands[2], operands[0]) \n+   && ! MEM_VOLATILE_P (operands[3]) && ! MEM_VOLATILE_P (operands[1])\n+   && memory_ok_for_ldd (XEXP (operands[3], 0), XEXP (operands[1], 0))\"\n+  \"ldd %3,%2\")\n+\n+(define_peephole\n+  [(set (match_operand:SF 0 \"memory_operand\" \"\")\n+        (match_operand:SF 1 \"register_operand\" \"fr\"))\n+   (set (match_operand:SF 2 \"memory_operand\" \"\")\n+        (match_operand:SF 3 \"register_operand\" \"fr\"))]\n+  \"registers_ok_for_ldd (operands[3], operands[1]) \n+   && ! MEM_VOLATILE_P (operands[2]) && ! MEM_VOLATILE_P (operands[0])\n+   && memory_ok_for_ldd (XEXP (operands[2], 0), XEXP (operands[0], 0))\"\n+  \"std %3,%2\")\n+ \n ;; Optimize the case of following a reg-reg move with a test\n ;; of reg just moved.\n "}]}