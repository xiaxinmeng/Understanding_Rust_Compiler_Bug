{"sha": "0754a104bed7c8a937f0623ad15ca03387131210", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDc1NGExMDRiZWQ3YzhhOTM3ZjA2MjNhZDE1Y2EwMzM4NzEzMTIxMA==", "commit": {"author": {"name": "Christophe Lyon", "email": "christophe.lyon@linaro.org", "date": "2021-04-16T19:58:25Z"}, "committer": {"name": "Christophe Lyon", "email": "christophe.lyon@linaro.org", "date": "2021-04-16T19:58:25Z"}, "message": "testsuite/arm: Fix scan-assembler-times in pr96770.c with movt/movw\n\nThe previous change to this testcase missed the fact that the data may\nbe accessed via an anchor, depending on the optimization level,\nleading to false failures.\n\nThis patch restricts matching to upper16:lower16 followed by\nnon-spaces, followed by +4 (in f4) or +320 (in f5).\n\nUsing '.*' instead of '[^ \\]' would match accross the whole assembly\nfile, which is not what we want, hence the limitation with spaces.\n\n2021-04-16  Christophe Lyon  <christophe.lyon@linaro.org>\n\n\tgcc/testsuite/\n\tPR target/96770\n\t* gcc.target/arm/pure-code/pr96770.c: Fix scan-assembler-times\n\twith movt/movw.", "tree": {"sha": "f08d70a666120d331cec226ac915e9113a4b5b06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f08d70a666120d331cec226ac915e9113a4b5b06"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0754a104bed7c8a937f0623ad15ca03387131210", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0754a104bed7c8a937f0623ad15ca03387131210", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0754a104bed7c8a937f0623ad15ca03387131210", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0754a104bed7c8a937f0623ad15ca03387131210/comments", "author": null, "committer": null, "parents": [{"sha": "49813aad3292f7f2bef69206274da78a9a7116ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49813aad3292f7f2bef69206274da78a9a7116ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49813aad3292f7f2bef69206274da78a9a7116ed"}], "stats": {"total": 12, "additions": 7, "deletions": 5}, "files": [{"sha": "3c69614b76f4b77d4fc59599fb8dcf1f15da9b29", "filename": "gcc/testsuite/gcc.target/arm/pure-code/pr96770.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0754a104bed7c8a937f0623ad15ca03387131210/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpure-code%2Fpr96770.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0754a104bed7c8a937f0623ad15ca03387131210/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpure-code%2Fpr96770.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpure-code%2Fpr96770.c?ref=0754a104bed7c8a937f0623ad15ca03387131210", "patch": "@@ -4,18 +4,20 @@\n int arr[1000];\n int *f4 (void) { return &arr[1]; }\n \n-/* For cortex-m0 (thumb-1/v6m), we generate 4 movs with upper/lower:#arr+4.  */\n+/* For cortex-m0 (thumb-1/v6m), we generate 2 pairs of movs/adds with upper/lower:#arr+4.  */\n /* { dg-final { scan-assembler-times \"arr\\\\+4\" 4 { target { { ! arm_thumb1_movt_ok } && { ! arm_thumb2_ok } } } } } */\n \n /* For cortex-m with movt/movw (thumb-1/v8m.base or thumb-2), we\n-   generate a movt/movw pair with upper/lower:#arr+4.  */\n-/* { dg-final { scan-assembler-times \"arr\\\\+4\" 2 { target { arm_thumb1_movt_ok || arm_thumb2_ok } } } } */\n+   generate a movt/movw pair with upper/lower:#arr+4 possibly via an anchor.  */\n+/* { dg-final { scan-assembler-times \"upper16:\\[^ \\]+.\\\\+4\" 1 { target { arm_thumb1_movt_ok || arm_thumb2_ok } } } } */\n+/* { dg-final { scan-assembler-times \"lower16:\\[^ \\]+\\\\+4\" 1 { target { arm_thumb1_movt_ok || arm_thumb2_ok } } } } */\n \n int *f5 (void) { return &arr[80]; }\n \n /* For cortex-m0 (thumb-1/v6m), we generate 1 ldr from rodata pointer to arr+320.  */\n /* { dg-final { scan-assembler-times \"arr\\\\+320\" 1 { target { { ! arm_thumb1_movt_ok } && { ! arm_thumb2_ok } } } } } */\n \n /* For cortex-m with movt/movw (thumb-1/v8m.base or thumb-2), we\n-   generate a movt/movw pair with upper/lower:arr+320.  */\n-/* { dg-final { scan-assembler-times \"arr\\\\+320\" 2 { target { arm_thumb1_movt_ok || arm_thumb2_ok } } } } */\n+   generate a movt/movw pair with upper/lower:arr+320 possibly via an anchor.  */\n+/* { dg-final { scan-assembler-times \"upper16:\\[^ \\]+\\\\+320\" 1 { target { arm_thumb1_movt_ok || arm_thumb2_ok } } } } */\n+/* { dg-final { scan-assembler-times \"lower16:\\[^ \\]+\\\\+320\" 1 { target { arm_thumb1_movt_ok || arm_thumb2_ok } } } } */"}]}