{"sha": "d7cd794fdf7abd1d9e93482a8074220a1e133c8b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDdjZDc5NGZkZjdhYmQxZDllOTM0ODJhODA3NDIyMGExZTEzM2M4Yg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-03-11T11:49:32Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-03-11T11:49:32Z"}, "message": "(make_extraction): Use proper mode for INNER in all cases.\n\n(simplify_comparison, case ZERO_EXTRACT): For bits big endian and no extzv,\nuse BITS_PER_WORD.\n\nFrom-SVN: r11510", "tree": {"sha": "5817b710fa1df498d731a3b5bd42aa1b9dfdac73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5817b710fa1df498d731a3b5bd42aa1b9dfdac73"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d7cd794fdf7abd1d9e93482a8074220a1e133c8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7cd794fdf7abd1d9e93482a8074220a1e133c8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7cd794fdf7abd1d9e93482a8074220a1e133c8b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7cd794fdf7abd1d9e93482a8074220a1e133c8b/comments", "author": null, "committer": null, "parents": [{"sha": "2ae508e5e3d7756fb7bf74015337f82869f16a77", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ae508e5e3d7756fb7bf74015337f82869f16a77", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ae508e5e3d7756fb7bf74015337f82869f16a77"}], "stats": {"total": 67, "additions": 31, "deletions": 36}, "files": [{"sha": "70231199812156fd41b66714d4e2a0ae38ed2411", "filename": "gcc/combine.c", "status": "modified", "additions": 31, "deletions": 36, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7cd794fdf7abd1d9e93482a8074220a1e133c8b/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7cd794fdf7abd1d9e93482a8074220a1e133c8b/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=d7cd794fdf7abd1d9e93482a8074220a1e133c8b", "patch": "@@ -5068,7 +5068,8 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n      ignore the POS lowest bits, etc.  */\n   enum machine_mode is_mode = GET_MODE (inner);\n   enum machine_mode inner_mode;\n-  enum machine_mode wanted_mem_mode = byte_mode;\n+  enum machine_mode wanted_inner_mode = byte_mode;\n+  enum machine_mode wanted_inner_reg_mode = word_mode;\n   enum machine_mode pos_mode = word_mode;\n   enum machine_mode extraction_mode = word_mode;\n   enum machine_mode tmode = mode_for_size (len, MODE_INT, 1);\n@@ -5208,12 +5209,12 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n \t  || (pos_rtx != 0 && len != 1)))\n     return 0;\n \n-  /* Get the mode to use should INNER be a MEM, the mode for the position,\n+  /* Get the mode to use should INNER not be a MEM, the mode for the position,\n      and the mode for the result.  */\n #ifdef HAVE_insv\n   if (in_dest)\n     {\n-      wanted_mem_mode = insn_operand_mode[(int) CODE_FOR_insv][0];\n+      wanted_inner_reg_mode = insn_operand_mode[(int) CODE_FOR_insv][0];\n       pos_mode = insn_operand_mode[(int) CODE_FOR_insv][2];\n       extraction_mode = insn_operand_mode[(int) CODE_FOR_insv][3];\n     }\n@@ -5222,7 +5223,7 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n #ifdef HAVE_extzv\n   if (! in_dest && unsignedp)\n     {\n-      wanted_mem_mode = insn_operand_mode[(int) CODE_FOR_extzv][1];\n+      wanted_inner_reg_mode = insn_operand_mode[(int) CODE_FOR_extzv][1];\n       pos_mode = insn_operand_mode[(int) CODE_FOR_extzv][3];\n       extraction_mode = insn_operand_mode[(int) CODE_FOR_extzv][0];\n     }\n@@ -5231,7 +5232,7 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n #ifdef HAVE_extv\n   if (! in_dest && ! unsignedp)\n     {\n-      wanted_mem_mode = insn_operand_mode[(int) CODE_FOR_extv][1];\n+      wanted_inner_reg_mode = insn_operand_mode[(int) CODE_FOR_extv][1];\n       pos_mode = insn_operand_mode[(int) CODE_FOR_extv][3];\n       extraction_mode = insn_operand_mode[(int) CODE_FOR_extv][0];\n     }\n@@ -5247,13 +5248,15 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n       && GET_MODE_SIZE (pos_mode) < GET_MODE_SIZE (GET_MODE (pos_rtx)))\n     pos_mode = GET_MODE (pos_rtx);\n \n-  /* If this is not from memory or we have to change the mode of memory and\n-     cannot, the desired mode is EXTRACTION_MODE.  */\n-  if (GET_CODE (inner) != MEM\n-      || (inner_mode != wanted_mem_mode\n-\t  && (mode_dependent_address_p (XEXP (inner, 0))\n-\t      || MEM_VOLATILE_P (inner))))\n-    wanted_mem_mode = extraction_mode;\n+  /* If this is not from memory, the desired mode is wanted_inner_reg_mode;\n+     if we have to change the mode of memory and cannot, the desired mode is\n+     EXTRACTION_MODE.  */\n+  if (GET_CODE (inner) != MEM)\n+    wanted_inner_mode = wanted_inner_reg_mode;\n+  else if (inner_mode != wanted_inner_mode\n+\t   && (mode_dependent_address_p (XEXP (inner, 0))\n+\t       || MEM_VOLATILE_P (inner)))\n+    wanted_inner_mode = extraction_mode;\n \n   orig_pos = pos;\n \n@@ -5262,25 +5265,22 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n       /* If position is constant, compute new position.  Otherwise,\n \t build subtraction.  */\n       if (pos_rtx == 0)\n-\tpos = (MAX (GET_MODE_BITSIZE (is_mode),\n-\t\t    GET_MODE_BITSIZE (wanted_mem_mode))\n-\t       - len - pos);\n+\tpos = GET_MODE_BITSIZE (wanted_inner_mode) - len - pos;\n       else\n \tpos_rtx\n \t  = gen_rtx_combine (MINUS, GET_MODE (pos_rtx),\n-\t\t\t     GEN_INT (MAX (GET_MODE_BITSIZE (is_mode),\n-\t\t\t\t\t   GET_MODE_BITSIZE (wanted_mem_mode))\n+\t\t\t     GEN_INT (GET_MODE_BITSIZE (wanted_inner_mode)\n \t\t\t\t      - len),\n \t\t\t     pos_rtx);\n     }\n \n   /* If INNER has a wider mode, make it smaller.  If this is a constant\n      extract, try to adjust the byte to point to the byte containing\n      the value.  */\n-  if (wanted_mem_mode != VOIDmode\n-      && GET_MODE_SIZE (wanted_mem_mode) < GET_MODE_SIZE (is_mode)\n+  if (wanted_inner_mode != VOIDmode\n+      && GET_MODE_SIZE (wanted_inner_mode) < GET_MODE_SIZE (is_mode)\n       && ((GET_CODE (inner) == MEM\n-\t   && (inner_mode == wanted_mem_mode\n+\t   && (inner_mode == wanted_inner_mode\n \t       || (! mode_dependent_address_p (XEXP (inner, 0))\n \t\t   && ! MEM_VOLATILE_P (inner))))))\n     {\n@@ -5301,18 +5301,18 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n       if (pos_rtx == 0)\n \t{\n \t  offset += pos / BITS_PER_UNIT;\n-\t  pos %= GET_MODE_BITSIZE (wanted_mem_mode);\n+\t  pos %= GET_MODE_BITSIZE (wanted_inner_mode);\n \t}\n \n       if (BYTES_BIG_ENDIAN != BITS_BIG_ENDIAN\n \t  && ! spans_byte\n-\t  && is_mode != wanted_mem_mode)\n+\t  && is_mode != wanted_inner_mode)\n \toffset = (GET_MODE_SIZE (is_mode)\n-\t\t  - GET_MODE_SIZE (wanted_mem_mode) - offset);\n+\t\t  - GET_MODE_SIZE (wanted_inner_mode) - offset);\n \n-      if (offset != 0 || inner_mode != wanted_mem_mode)\n+      if (offset != 0 || inner_mode != wanted_inner_mode)\n \t{\n-\t  rtx newmem = gen_rtx (MEM, wanted_mem_mode,\n+\t  rtx newmem = gen_rtx (MEM, wanted_inner_mode,\n \t\t\t\tplus_constant (XEXP (inner, 0), offset));\n \t  RTX_UNCHANGING_P (newmem) = RTX_UNCHANGING_P (inner);\n \t  MEM_VOLATILE_P (newmem) = MEM_VOLATILE_P (inner);\n@@ -5323,7 +5323,7 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n \n   /* If INNER is not memory, we can always get it into the proper mode. */\n   else if (GET_CODE (inner) != MEM)\n-    inner = force_to_mode (inner, extraction_mode,\n+    inner = force_to_mode (inner, wanted_inner_mode,\n \t\t\t   pos_rtx || len + orig_pos >= HOST_BITS_PER_WIDE_INT\n \t\t\t   ? GET_MODE_MASK (extraction_mode)\n \t\t\t   : (((HOST_WIDE_INT) 1 << len) - 1) << orig_pos,\n@@ -9156,24 +9156,19 @@ simplify_comparison (code, pop0, pop1)\n \t  /* If we are extracting a single bit from a variable position in\n \t     a constant that has only a single bit set and are comparing it\n \t     with zero, we can convert this into an equality comparison \n-\t     between the position and the location of the single bit.  We can't\n-\t     do this if bit endian and we don't have an extzv since we then\n-\t     can't know what mode to use for the endianness adjustment.  */\n+\t     between the position and the location of the single bit.  */\n \n \t  if (GET_CODE (XEXP (op0, 0)) == CONST_INT\n \t      && XEXP (op0, 1) == const1_rtx\n \t      && equality_comparison_p && const_op == 0\n-\t      && (i = exact_log2 (INTVAL (XEXP (op0, 0)))) >= 0\n-\t      && (! BITS_BIG_ENDIAN\n-#ifdef HAVE_extzv\n-\t\t  || HAVE_extzv\n-#endif\n-\t\t  ))\n+\t      && (i = exact_log2 (INTVAL (XEXP (op0, 0)))) >= 0)\n \t    {\n-#ifdef HAVE_extzv\n \t      if (BITS_BIG_ENDIAN)\n+#ifdef HAVE_extzv\n \t\ti = (GET_MODE_BITSIZE\n \t\t     (insn_operand_mode[(int) CODE_FOR_extzv][1]) - 1 - i);\n+#else\n+\t        i = BITS_PER_WORD - 1 - i;\n #endif\n \n \t      op0 = XEXP (op0, 2);"}]}