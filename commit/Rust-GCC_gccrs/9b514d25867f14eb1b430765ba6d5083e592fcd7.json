{"sha": "9b514d25867f14eb1b430765ba6d5083e592fcd7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWI1MTRkMjU4NjdmMTRlYjFiNDMwNzY1YmE2ZDUwODNlNTkyZmNkNw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2003-05-10T19:02:21Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2003-05-10T19:02:21Z"}, "message": "defaults.h (GCOV_TYPE_SIZE): Remove.\n\n\t* defaults.h (GCOV_TYPE_SIZE): Remove.\n\t* gcov-io.h (gcov_type): Set to specific mode int on target.\n\t(gcov_unsigned_t, gcov_position_t): New.\n\t(GCOV_TYPE_NODE): New.\n\t(GCOV_TAG_SUMMARY_LENGTH): Adjust.\n\t(GCOV_COUNTERS_SUMMABLE): New.\n\t(gcov_ctr_summary, gcov_sumary, gcov_fn_info, gcov_merge_fn,\n\tgcov_ctr_info, gcov_info): Adjust types.\n\t(gcov_var): Adjust types.\n\t(gcov_write_unsigned, gcov_write_tag,\n\tgcov_write_length, gcov_write_tag_length, gcov_write_summary,\n\tgcov_read_unsigned, gcov_read_summary): Adjust gcov types.\n\t(gcov_position, gcov_sync, gcov_seek): Adjust gcov types.\n\t* gcov-io.c (gcov_write_unsigned, gcov_write_tag,\n\tgcov_write_length, gcov_write_tag_length, gcov_write_summary,\n\tgcov_read_unsigned, gcov_read_summary): Adjust gcov types.\n\t* libgcov.c (gcov_crc32, gcov_version_mismatch, gcov_exit,\n\t__gcov_init, __gcov_merge_add): Adjust gcov types.\n\t* coverage.c (ctr_merge_functions): Constify.\n\t(ctr_names): New.\n\t(read_counts_file): Adjust gcov types. Only summarize & merge\n\tsummable counters.\n\t(coverage_counter_ref): Use GCOV_TYPE_NODE.\n\t(build_fn_info_type, build_fn_info_value, build_ctr_info_type,\n\tbuild_ctr_info_value, build_gcov_info): Adjust types.\n\t* profile.c (branch_prob): Adjust gcov types.\n\t* gcov_dump (dump_file): Adjust gcov types.\n\nFrom-SVN: r66668", "tree": {"sha": "854e36366a2cd453b70412c2e728a48810418a26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/854e36366a2cd453b70412c2e728a48810418a26"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9b514d25867f14eb1b430765ba6d5083e592fcd7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b514d25867f14eb1b430765ba6d5083e592fcd7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b514d25867f14eb1b430765ba6d5083e592fcd7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b514d25867f14eb1b430765ba6d5083e592fcd7/comments", "author": null, "committer": null, "parents": [{"sha": "bac45eb9ffa0dde3bce2170a29ac04644de86365", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bac45eb9ffa0dde3bce2170a29ac04644de86365", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bac45eb9ffa0dde3bce2170a29ac04644de86365"}], "stats": {"total": 306, "additions": 177, "deletions": 129}, "files": [{"sha": "f8e7ccd600b16a669a18b272b88d2b8bdfe6d3a3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b514d25867f14eb1b430765ba6d5083e592fcd7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b514d25867f14eb1b430765ba6d5083e592fcd7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9b514d25867f14eb1b430765ba6d5083e592fcd7", "patch": "@@ -1,3 +1,33 @@\n+2003-05-10  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* defaults.h (GCOV_TYPE_SIZE): Remove.\n+\t* gcov-io.h (gcov_type): Set to specific mode int on target.\n+\t(gcov_unsigned_t, gcov_position_t): New.\n+\t(GCOV_TYPE_NODE): New.\n+\t(GCOV_TAG_SUMMARY_LENGTH): Adjust.\n+\t(GCOV_COUNTERS_SUMMABLE): New.\n+\t(gcov_ctr_summary, gcov_sumary, gcov_fn_info, gcov_merge_fn,\n+\tgcov_ctr_info, gcov_info): Adjust types.\n+\t(gcov_var): Adjust types.\n+\t(gcov_write_unsigned, gcov_write_tag,\n+\tgcov_write_length, gcov_write_tag_length, gcov_write_summary,\n+\tgcov_read_unsigned, gcov_read_summary): Adjust gcov types.\n+\t(gcov_position, gcov_sync, gcov_seek): Adjust gcov types.\n+\t* gcov-io.c (gcov_write_unsigned, gcov_write_tag,\n+\tgcov_write_length, gcov_write_tag_length, gcov_write_summary,\n+\tgcov_read_unsigned, gcov_read_summary): Adjust gcov types.\n+\t* libgcov.c (gcov_crc32, gcov_version_mismatch, gcov_exit,\n+\t__gcov_init, __gcov_merge_add): Adjust gcov types.\n+\t* coverage.c (ctr_merge_functions): Constify.\n+\t(ctr_names): New.\n+\t(read_counts_file): Adjust gcov types. Only summarize & merge\n+\tsummable counters.\n+\t(coverage_counter_ref): Use GCOV_TYPE_NODE.\n+\t(build_fn_info_type, build_fn_info_value, build_ctr_info_type,\n+\tbuild_ctr_info_value, build_gcov_info): Adjust types.\n+\t* profile.c (branch_prob): Adjust gcov types.\n+\t* gcov_dump (dump_file): Adjust gcov types.\n+\n 2003-05-10  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* arm.md (DOM_CC_X_AND_Y, DOM_CC_NX_OR_Y, DOM_CC_X_OR_Y): New "}, {"sha": "685a633da4f0acba2c36a84e7ded881667586f84", "filename": "gcc/coverage.c", "status": "modified", "additions": 39, "deletions": 33, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b514d25867f14eb1b430765ba6d5083e592fcd7/gcc%2Fcoverage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b514d25867f14eb1b430765ba6d5083e592fcd7/gcc%2Fcoverage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.c?ref=9b514d25867f14eb1b430765ba6d5083e592fcd7", "patch": "@@ -99,7 +99,8 @@ static htab_t counts_hash = NULL;\n static GTY(()) rtx ctr_labels[GCOV_COUNTERS];\n \n /* The names of merge functions for counters.  */\n-static const char *ctr_merge_functions[GCOV_COUNTERS] = GCOV_MERGE_FUNCTIONS;\n+static const char *const ctr_merge_functions[GCOV_COUNTERS] = GCOV_MERGE_FUNCTIONS;\n+static const char *const ctr_names[GCOV_COUNTERS] = GCOV_COUNTER_NAMES;\n \n /* Forward declarations.  */\n static hashval_t htab_counts_entry_hash PARAMS ((const void *));\n@@ -151,8 +152,9 @@ htab_counts_entry_del (of)\n static void\n read_counts_file ()\n {\n-  unsigned fn_ident = 0;\n-  unsigned version, ix, checksum = -1;\n+  gcov_unsigned_t fn_ident = 0;\n+  gcov_unsigned_t version, checksum = -1;\n+  unsigned ix;\n   counts_entry_t *summaried = NULL;\n   unsigned seen_summary = 0;\n   \n@@ -168,7 +170,7 @@ read_counts_file ()\n   else if ((version = gcov_read_unsigned ()) != GCOV_VERSION)\n     {\n       char v[4], e[4];\n-      unsigned required = GCOV_VERSION;\n+      gcov_unsigned_t required = GCOV_VERSION;\n       \n       for (ix = 4; ix--; required >>= 8, version >>= 8)\n \t{\n@@ -186,8 +188,8 @@ read_counts_file ()\n \t\t\t     htab_counts_entry_del);\n   while (!gcov_is_eof ())\n     {\n-      unsigned tag, length;\n-      unsigned long offset;\n+      gcov_unsigned_t tag, length;\n+      gcov_position_t offset;\n       int error;\n       \n       tag = gcov_read_unsigned ();\n@@ -259,17 +261,25 @@ read_counts_file ()\n \t      htab_delete (counts_hash);\n \t      break;\n \t    }\n-\t  \n-\t  /* This should always be true for a just allocated entry,\n-\t     and always false for an existing one. Check this way, in\n-\t     case the gcov file is corrupt.  */\n-\t  if (!entry->chain || summaried != entry)\n+\t  else if (elt.ctr >= GCOV_COUNTERS_SUMMABLE)\n+\t    {\n+\t      warning (\"cannot merge separate %s counters for function %u\",\n+\t\t       ctr_names[elt.ctr], fn_ident);\n+\t      goto skip_merge;\n+\t    }\n+\n+\t  if (elt.ctr < GCOV_COUNTERS_SUMMABLE\n+\t      /* This should always be true for a just allocated entry,\n+\t     \t and always false for an existing one. Check this way, in\n+\t     \t case the gcov file is corrupt.  */\n+\t      && (!entry->chain || summaried != entry))\n \t    {\n \t      entry->chain = summaried;\n \t      summaried = entry;\n \t    }\n \t  for (ix = 0; ix != n_counts; ix++)\n \t    entry->counts[ix] += gcov_read_counter ();\n+\tskip_merge:;\n \t}\n       gcov_sync (offset, length);\n       if ((error = gcov_is_error ()))\n@@ -332,7 +342,8 @@ get_coverage_counts (unsigned counter, unsigned expected,\n rtx\n coverage_counter_ref (unsigned counter, unsigned no)\n {\n-  enum machine_mode mode = mode_for_size (GCOV_TYPE_SIZE, MODE_INT, 0);\n+  unsigned gcov_size = tree_low_cst (TYPE_SIZE (GCOV_TYPE_NODE), 1);\n+  enum machine_mode mode = mode_for_size (gcov_size, MODE_INT, 0);\n   rtx ref;\n \n   if (!ctr_labels[counter])\n@@ -350,8 +361,7 @@ coverage_counter_ref (unsigned counter, unsigned no)\n     }\n \n   no += prg_n_ctrs[counter];\n-  ref = plus_constant (ctr_labels[counter],\n-\t\t       GCOV_TYPE_SIZE / BITS_PER_UNIT * no);\n+  ref = plus_constant (ctr_labels[counter], gcov_size / BITS_PER_UNIT * no);\n   ref = gen_rtx_MEM (mode, ref);\n   set_mem_alias_set (ref, new_alias_set ());\n \n@@ -489,10 +499,10 @@ build_fn_info_type (counters)\n   tree array_type;\n   \n   /* ident */\n-  fields = build_decl (FIELD_DECL, NULL_TREE, unsigned_type_node);\n+  fields = build_decl (FIELD_DECL, NULL_TREE, unsigned_intSI_type_node);\n \n   /* checksum */\n-  field = build_decl (FIELD_DECL, NULL_TREE, unsigned_type_node);\n+  field = build_decl (FIELD_DECL, NULL_TREE, unsigned_intSI_type_node);\n   TREE_CHAIN (field) = fields;\n   fields = field;\n \n@@ -525,14 +535,14 @@ build_fn_info_value (function, type)\n   \n   /* ident */\n   value = tree_cons (fields,\n-\t\t     convert (unsigned_type_node,\n+\t\t     convert (unsigned_intSI_type_node,\n \t\t\t      build_int_2 (function->ident, 0)),\n \t\t     value);\n   fields = TREE_CHAIN (fields);\n   \n   /* checksum */\n   value = tree_cons (fields,\n-\t\t     convert (unsigned_type_node,\n+\t\t     convert (unsigned_intSI_type_node,\n \t\t\t      build_int_2 (function->checksum, 0)),\n \t\t     value);\n   fields = TREE_CHAIN (fields);\n@@ -562,26 +572,24 @@ build_ctr_info_type ()\n {\n   tree type = (*lang_hooks.types.make_type) (RECORD_TYPE);\n   tree field, fields = NULL_TREE;\n+  tree gcov_ptr_type = build_pointer_type (GCOV_TYPE_NODE);\n   tree gcov_merge_fn_type;\n-  \n+\n   /* counters */\n-  field = build_decl (FIELD_DECL, NULL_TREE, unsigned_type_node);\n+  field = build_decl (FIELD_DECL, NULL_TREE, unsigned_intSI_type_node);\n   TREE_CHAIN (field) = fields;\n   fields = field;\n \n   /* values */\n-  field = build_decl (FIELD_DECL, NULL_TREE,\n-\t\t      build_pointer_type (make_signed_type (GCOV_TYPE_SIZE)));\n+  field = build_decl (FIELD_DECL, NULL_TREE, gcov_ptr_type);\n   TREE_CHAIN (field) = fields;\n   fields = field;\n \n   /* merge */\n   gcov_merge_fn_type =\n-\tbuild_function_type_list (\n-\t\tvoid_type_node,\n-\t\tbuild_pointer_type (make_signed_type (GCOV_TYPE_SIZE)),\n-\t\tunsigned_type_node,\n-\t\tNULL_TREE);\n+    build_function_type_list (void_type_node,\n+\t\t\t      gcov_ptr_type, unsigned_type_node,\n+\t\t\t      NULL_TREE);\n   field = build_decl (FIELD_DECL, NULL_TREE,\n \t\t      build_pointer_type (gcov_merge_fn_type));\n   TREE_CHAIN (field) = fields;\n@@ -607,7 +615,7 @@ build_ctr_info_value (counter, type)\n \n   /* counters */\n   value = tree_cons (fields,\n-\t\t     convert (unsigned_type_node,\n+\t\t     convert (unsigned_intSI_type_node,\n \t\t\t      build_int_2 (prg_n_ctrs[counter], 0)),\n \t\t     value);\n   fields = TREE_CHAIN (fields);\n@@ -641,9 +649,7 @@ build_ctr_info_value (counter, type)\n   DECL_ARTIFICIAL (fn) = 1;\n   TREE_NOTHROW (fn) = 1;\n   value = tree_cons (fields,\n-\t\t     build1 (ADDR_EXPR,\n-\t\t\t     TREE_TYPE (fields),\n-\t\t\t     fn),\n+\t\t     build1 (ADDR_EXPR, TREE_TYPE (fields), fn),\n \t\t     value);\n \n   value = build_constructor (type, nreverse (value));\n@@ -680,10 +686,10 @@ build_gcov_info ()\n   const_type = build_qualified_type (type, TYPE_QUAL_CONST);\n   \n   /* Version ident */\n-  field = build_decl (FIELD_DECL, NULL_TREE, long_unsigned_type_node);\n+  field = build_decl (FIELD_DECL, NULL_TREE, unsigned_intSI_type_node);\n   TREE_CHAIN (field) = fields;\n   fields = field;\n-  value = tree_cons (field, convert (long_unsigned_type_node,\n+  value = tree_cons (field, convert (unsigned_intSI_type_node,\n \t\t\t\t     build_int_2 (GCOV_VERSION, 0)),\n \t\t     value);\n   "}, {"sha": "24ee0bcf5e78e12822a604d83ba6efac938a16b4", "filename": "gcc/defaults.h", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b514d25867f14eb1b430765ba6d5083e592fcd7/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b514d25867f14eb1b430765ba6d5083e592fcd7/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=9b514d25867f14eb1b430765ba6d5083e592fcd7", "patch": "@@ -404,15 +404,6 @@ do { fputs (integer_asm_op (POINTER_SIZE / UNITS_PER_WORD, TRUE), FILE); \\\n #define PIC_OFFSET_TABLE_REGNUM INVALID_REGNUM\n #endif\n \n-/* Type used by GCOV counters.  Use 64bit data type if target supports\n-   it.  */\n-#if LONG_TYPE_SIZE >= 64\n-#define GCOV_TYPE_SIZE LONG_TYPE_SIZE\n-#else\n-#define GCOV_TYPE_SIZE LONG_LONG_TYPE_SIZE\n-#endif\n-\n-\n /* By default, the preprocessor should be invoked the same way in C++\n    as in C.  */\n #ifndef CPLUSPLUS_CPP_SPEC"}, {"sha": "d70e4dddc8bf5a9d0129d686effb7c989dc2673a", "filename": "gcc/gcov-dump.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b514d25867f14eb1b430765ba6d5083e592fcd7/gcc%2Fgcov-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b514d25867f14eb1b430765ba6d5083e592fcd7/gcc%2Fgcov-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-dump.c?ref=9b514d25867f14eb1b430765ba6d5083e592fcd7", "patch": "@@ -241,7 +241,8 @@ dump_file (filename)\n       if ((error = gcov_is_error ()))\n \t{\n \t  printf (error < 0 ? \"%s:counter overflow at %lu\\n\" :\n-\t\t  \"%s:read error at %lu\\n\", filename, gcov_position ());\n+\t\t  \"%s:read error at %lu\\n\", filename,\n+\t\t  (long unsigned) gcov_position ());\n \t  break;\n \t}\n     }"}, {"sha": "d61cff392cd6cc329fb15f356800757a27460dd4", "filename": "gcc/gcov-io.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b514d25867f14eb1b430765ba6d5083e592fcd7/gcc%2Fgcov-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b514d25867f14eb1b430765ba6d5083e592fcd7/gcc%2Fgcov-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.c?ref=9b514d25867f14eb1b430765ba6d5083e592fcd7", "patch": "@@ -181,7 +181,7 @@ gcov_write_bytes (unsigned bytes)\n    appropriately.  */\n \n GCOV_LINKAGE void\n-gcov_write_unsigned (unsigned value)\n+gcov_write_unsigned (gcov_unsigned_t value)\n {\n   unsigned char *buffer = gcov_write_bytes (4);\n   unsigned ix;\n@@ -261,10 +261,10 @@ gcov_write_string (const char *string)\n /* Write a tag TAG and reserve space for the record length. Return a\n    value to be used for gcov_write_length.  */\n \n-GCOV_LINKAGE unsigned long\n-gcov_write_tag (unsigned tag)\n+GCOV_LINKAGE gcov_position_t\n+gcov_write_tag (gcov_unsigned_t tag)\n {\n-  unsigned long result = gcov_var.position;\n+  gcov_position_t result = gcov_var.position;\n   unsigned char *buffer = gcov_write_bytes (8);\n   unsigned ix;\n \n@@ -285,11 +285,11 @@ gcov_write_tag (unsigned tag)\n    overflow.  */\n \n GCOV_LINKAGE void\n-gcov_write_length (unsigned long position)\n+gcov_write_length (gcov_position_t position)\n {\n   if (position)\n     {\n-      unsigned length = gcov_var.position - position - 8;\n+      gcov_unsigned_t length = gcov_var.position - position - 8;\n       unsigned char *buffer = &gcov_var.buffer[position + 4];\n       unsigned ix;\n       \n@@ -300,12 +300,13 @@ gcov_write_length (unsigned long position)\n \t}\n     }\n }\n-#endif\n+\n+#else /* IN_LIBGCOV */\n \n /* Write a tag TAG and length LENGTH.  */\n \n GCOV_LINKAGE void\n-gcov_write_tag_length (unsigned tag, unsigned length)\n+gcov_write_tag_length (gcov_unsigned_t tag, gcov_unsigned_t length)\n {\n   unsigned char *buffer = gcov_write_bytes (8);\n   unsigned ix;\n@@ -325,19 +326,18 @@ gcov_write_tag_length (unsigned tag, unsigned length)\n   return;\n }\n \n-#if IN_LIBGCOV\n /* Write a summary structure to the gcov file.  Return non-zero on\n    overflow.  */\n \n GCOV_LINKAGE void\n-gcov_write_summary (unsigned tag, const struct gcov_summary *summary)\n+gcov_write_summary (gcov_unsigned_t tag, const struct gcov_summary *summary)\n {\n   unsigned ix;\n   const struct gcov_ctr_summary *csum;\n \n   gcov_write_tag_length (tag, GCOV_TAG_SUMMARY_LENGTH);\n   gcov_write_unsigned (summary->checksum);\n-  for (csum = summary->ctrs, ix = GCOV_COUNTERS; ix--; csum++)\n+  for (csum = summary->ctrs, ix = GCOV_COUNTERS_SUMMABLE; ix--; csum++)\n     {\n       gcov_write_unsigned (csum->num);\n       gcov_write_unsigned (csum->runs);\n@@ -372,10 +372,10 @@ gcov_read_bytes (unsigned bytes)\n /* Read unsigned value from a coverage file. Sets error flag on file\n    error, overflow flag on overflow */\n \n-GCOV_LINKAGE unsigned\n+GCOV_LINKAGE gcov_unsigned_t\n gcov_read_unsigned ()\n {\n-  unsigned value = 0;\n+  gcov_unsigned_t value = 0;\n   unsigned ix;\n   const unsigned char *buffer = gcov_read_bytes (4);\n \n@@ -442,7 +442,7 @@ gcov_read_summary (struct gcov_summary *summary)\n   struct gcov_ctr_summary *csum;\n   \n   summary->checksum = gcov_read_unsigned ();\n-  for (csum = summary->ctrs, ix = GCOV_COUNTERS; ix--; csum++)\n+  for (csum = summary->ctrs, ix = GCOV_COUNTERS_SUMMABLE; ix--; csum++)\n     {\n       csum->num = gcov_read_unsigned ();\n       csum->runs = gcov_read_unsigned ();"}, {"sha": "f7396532fffbfebb2020f62d4df66ad4bd7669b6", "filename": "gcc/gcov-io.h", "status": "modified", "additions": 62, "deletions": 41, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b514d25867f14eb1b430765ba6d5083e592fcd7/gcc%2Fgcov-io.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b514d25867f14eb1b430765ba6d5083e592fcd7/gcc%2Fgcov-io.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.h?ref=9b514d25867f14eb1b430765ba6d5083e592fcd7", "patch": "@@ -158,29 +158,48 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #define GCC_GCOV_IO_H\n \n #if IN_LIBGCOV\n-#if LONG_TYPE_SIZE == GCOV_TYPE_SIZE\n-typedef long gcov_type;\n+/* About the target */\n+\n+typedef unsigned gcov_unsigned_t __attribute__ ((mode (SI)));\n+typedef unsigned gcov_position_t __attribute__ ((mode (SI)));\n+#if LONG_LONG_TYPE_SIZE > 32\n+typedef signed gcov_type __attribute__ ((mode (DI)));\n #else\n-typedef long long gcov_type;\n+typedef signed gcov_type __attribute__ ((mode (SI)));\n #endif\n+\n #if defined (TARGET_HAS_F_SETLKW)\n #define GCOV_LOCKED 1\n #else\n #define GCOV_LOCKED 0\n #endif\n+\n #else /* !IN_LIBGCOV */\n-#if defined (HOST_HAS_F_SETLKW)\n-#define GCOV_LOCKED 1\n-#else\n-#define GCOV_LOCKED 0\n-#endif\n+/* About the host */\n+\n+typedef unsigned gcov_unsigned_t;\n+typedef unsigned gcov_position_t;\n+/* gcov_type is typedef'd elsewhere for the compiler */\n #if IN_GCOV\n #define GCOV_LINKAGE static\n typedef HOST_WIDEST_INT gcov_type;\n #if IN_GCOV > 0\n #include <sys/types.h>\n #endif\n+#else /*!IN_GCOV */\n+#if LONG_LONG_TYPE_SIZE > 32\n+#define GCOV_TYPE_NODE intDI_type_node\n+#else\n+#define GCOV_TYPE_NODE intSI_type_node\n+#endif\n #endif\n+\n+#if defined (HOST_HAS_F_SETLKW)\n+#define GCOV_LOCKED 1\n+#else\n+#define GCOV_LOCKED 0\n+#endif\n+\n #endif /* !IN_LIBGCOV */\n \n /* In gcov we want function linkage to be static, so we do not\n@@ -247,10 +266,12 @@ typedef HOST_WIDEST_INT gcov_type;\n #define GCOV_TAG_COUNTER_LENGTH(NUM) ((NUM) * 8)\n #define GCOV_TAG_OBJECT_SUMMARY  ((unsigned)0xa1000000)\n #define GCOV_TAG_PROGRAM_SUMMARY ((unsigned)0xa3000000)\n-#define GCOV_TAG_SUMMARY_LENGTH  (1 * 4 + GCOV_COUNTERS * (2 * 4 + 3 * 8))\n+#define GCOV_TAG_SUMMARY_LENGTH  (1 * 4 + GCOV_COUNTERS_SUMMABLE * (2 * 4 + 3 * 8))\n \n /* Counters that are collected.  */\n #define GCOV_COUNTER_ARCS \t0  /* Arc transitions.  */\n+#define GCOV_COUNTERS_SUMMABLE\t1  /* Counters which can be\n+\t\t\t\t      summaried. */\n #define GCOV_COUNTERS\t\t1\n \n /* A list of human readable names of the counters */\n@@ -296,18 +317,18 @@ typedef HOST_WIDEST_INT gcov_type;\n /* Cumulative counter data.   */\n struct gcov_ctr_summary\n {\n-  unsigned num;\t\t/* number of counters.  */\n-  unsigned runs;\t/* number of program runs */\n-  gcov_type sum_all;\t/* sum of all counters accumulated. */\n-  gcov_type run_max;\t/* maximum value on a single run.  */\n-  gcov_type sum_max;    /* sum of individual run max values. */\n+  gcov_unsigned_t num;\t\t/* number of counters.  */\n+  gcov_unsigned_t runs;\t\t/* number of program runs */\n+  gcov_type sum_all;\t\t/* sum of all counters accumulated. */\n+  gcov_type run_max;\t\t/* maximum value on a single run.  */\n+  gcov_type sum_max;    \t/* sum of individual run max values. */\n };\n \n /* Object & program summary record.  */\n struct gcov_summary\n {\n-  unsigned checksum;\t  /* checksum of program */\n-  struct gcov_ctr_summary ctrs[GCOV_COUNTERS];\n+  gcov_unsigned_t checksum;\t/* checksum of program */\n+  struct gcov_ctr_summary ctrs[GCOV_COUNTERS_SUMMABLE];\n };\n \n /* Structures embedded in coveraged program.  The structures generated\n@@ -320,34 +341,34 @@ struct gcov_summary\n    explicitly calculate the correct array stride.  */\n struct gcov_fn_info\n {\n-  unsigned ident;               /* unique ident of function */\n-  unsigned checksum;\t\t/* function checksum */\n+  gcov_unsigned_t ident;\t/* unique ident of function */\n+  gcov_unsigned_t checksum;\t/* function checksum */\n   unsigned n_ctrs[0];\t\t/* instrumented counters */\n };\n \n /* Type of function used to merge counters.  */\n-typedef void (*gcov_merge_fn) (gcov_type *, unsigned);\n+typedef void (*gcov_merge_fn) (gcov_type *, gcov_unsigned_t);\n \n /* Information about counters.  */\n struct gcov_ctr_info\n {\n-  unsigned num;\t\t/* number of counters.  */\n-  gcov_type *values;\t/* their values.  */\n-  gcov_merge_fn merge;  /* The function used to merge them.  */\n+  gcov_unsigned_t num;\t\t/* number of counters.  */\n+  gcov_type *values;\t\t/* their values.  */\n+  gcov_merge_fn merge;  \t/* The function used to merge them.  */\n };\n \n /* Information about a single object file.  */\n struct gcov_info\n {\n-  unsigned long version;        /* expected version number */\n+  gcov_unsigned_t version;\t/* expected version number */\n   struct gcov_info *next;\t/* link to next, used by libgcc */\n \n   const char *filename;\t\t/* output file name */\n \n-  unsigned n_functions;             /* number of functions */\n+  unsigned n_functions;\t\t/* number of functions */\n   const struct gcov_fn_info *functions; /* table of functions */\n \n-  unsigned ctr_mask;              /* mask of counters instrumented.  */\n+  unsigned ctr_mask;\t\t/* mask of counters instrumented.  */\n   struct gcov_ctr_info counts[0]; /* count data. The number of bits\n \t\t\t\t     set in the ctr_mask field\n \t\t\t\t     determines how big this array\n@@ -372,8 +393,8 @@ extern void __gcov_merge_add (gcov_type *, unsigned);\n GCOV_LINKAGE struct gcov_var\n {\n   FILE *file;\n-  size_t position;\n-  size_t length;\n+  gcov_position_t position;\n+  gcov_position_t length;\n   size_t alloc;\n   unsigned modified;\n   int error;\n@@ -385,31 +406,31 @@ GCOV_LINKAGE int gcov_open (const char */*name*/, int /*truncate*/);\n GCOV_LINKAGE int gcov_close (void);\n #if !IN_GCOV\n GCOV_LINKAGE unsigned char *gcov_write_bytes (unsigned);\n-GCOV_LINKAGE void gcov_write_unsigned (unsigned);\n+GCOV_LINKAGE void gcov_write_unsigned (gcov_unsigned_t);\n #if IN_LIBGCOV\n GCOV_LINKAGE void gcov_write_counter (gcov_type);\n #else\n GCOV_LINKAGE void gcov_write_string (const char *);\n #endif\n #if !IN_LIBGCOV\n-GCOV_LINKAGE unsigned long gcov_write_tag (unsigned);\n-GCOV_LINKAGE void gcov_write_length (unsigned long /*position*/);\n-#endif\n-GCOV_LINKAGE void gcov_write_tag_length (unsigned, unsigned);\n-#if IN_LIBGCOV\n-GCOV_LINKAGE void gcov_write_summary (unsigned, const struct gcov_summary *);\n+GCOV_LINKAGE gcov_position_t gcov_write_tag (gcov_unsigned_t);\n+GCOV_LINKAGE void gcov_write_length (gcov_position_t /*position*/);\n+#else\n+GCOV_LINKAGE void gcov_write_tag_length (gcov_unsigned_t, gcov_unsigned_t);\n+GCOV_LINKAGE void gcov_write_summary (gcov_unsigned_t /*tag*/,\n+\t\t\t\t      const struct gcov_summary *);\n #endif\n #endif /* !IN_GCOV */\n GCOV_LINKAGE const unsigned char *gcov_read_bytes (unsigned);\n-GCOV_LINKAGE unsigned gcov_read_unsigned (void);\n+GCOV_LINKAGE gcov_unsigned_t gcov_read_unsigned (void);\n GCOV_LINKAGE gcov_type gcov_read_counter (void);\n #if !IN_LIBGCOV\n GCOV_LINKAGE const char *gcov_read_string (void);\n #endif\n GCOV_LINKAGE void gcov_read_summary (struct gcov_summary *);\n-static unsigned long gcov_position (void);\n-static void gcov_sync (unsigned long /*base*/, unsigned /*length */);\n-static void gcov_seek (unsigned long /*position*/);\n+static gcov_position_t gcov_position (void);\n+static void gcov_sync (gcov_position_t /*base*/, gcov_unsigned_t /*length */);\n+static void gcov_seek (gcov_position_t /*position*/);\n static void gcov_rewrite (void);\n static int gcov_is_eof (void);\n static int gcov_is_error (void);\n@@ -419,7 +440,7 @@ GCOV_LINKAGE time_t gcov_time (void);\n \n /* Save the current position in the gcov file.  */\n \n-static inline unsigned long\n+static inline gcov_position_t\n gcov_position (void)\n {\n   return gcov_var.position;\n@@ -429,7 +450,7 @@ gcov_position (void)\n    gcov_save_position, LENGTH should be a record length, or zero.  */\n \n static inline void\n-gcov_sync (unsigned long base, unsigned length)\n+gcov_sync (gcov_position_t base, gcov_unsigned_t length)\n {\n   if (gcov_var.buffer)\n     {\n@@ -446,7 +467,7 @@ gcov_sync (unsigned long base, unsigned length)\n /* Move to the end of the gcov file.  */\n \n static inline void\n-gcov_seek (unsigned long base)\n+gcov_seek (gcov_position_t base)\n {\n   gcov_var.position = base < gcov_var.length ? base : gcov_var.length;\n }"}, {"sha": "221eae474983f4f635878aca1044d987dc909cb3", "filename": "gcc/libgcov.c", "status": "modified", "additions": 17, "deletions": 20, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b514d25867f14eb1b430765ba6d5083e592fcd7/gcc%2Flibgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b514d25867f14eb1b430765ba6d5083e592fcd7/gcc%2Flibgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcov.c?ref=9b514d25867f14eb1b430765ba6d5083e592fcd7", "patch": "@@ -79,12 +79,12 @@ static struct gcov_info *gcov_list;\n \n /* A program checksum allows us to distinguish program data for an\n    object file included in multiple programs.  */\n-static unsigned gcov_crc32;\n+static gcov_unsigned_t gcov_crc32;\n \n static void\n-gcov_version_mismatch (struct gcov_info *ptr, unsigned version)\n+gcov_version_mismatch (struct gcov_info *ptr, gcov_unsigned_t version)\n {\n-  unsigned expected = GCOV_VERSION;\n+  gcov_unsigned_t expected = GCOV_VERSION;\n   unsigned ix;\n   char e[4], v[4];\n \n@@ -123,11 +123,11 @@ gcov_exit (void)\n       unsigned t_ix;\n       \n       for (t_ix = 0, ci_ptr = gi_ptr->counts, cs_ptr = this_program.ctrs;\n-\t   t_ix != GCOV_COUNTERS; t_ix++, cs_ptr++)\n+\t   t_ix != GCOV_COUNTERS_SUMMABLE; t_ix++, cs_ptr++)\n \tif ((1 << t_ix) & gi_ptr->ctr_mask)\n \t  {\n \t    const gcov_type *c_ptr;\n-\t    unsigned c_num;\n+\t    gcov_unsigned_t c_num;\n \n \t    cs_ptr->num += ci_ptr->num;\n \t    for (c_num = ci_ptr->num, c_ptr = ci_ptr->values; c_num--; c_ptr++)\n@@ -140,7 +140,7 @@ gcov_exit (void)\n \t  }\n     }\n \n-  /* Now write the data  */\n+  /* Now merge each file  */\n   for (gi_ptr = gcov_list; gi_ptr; gi_ptr = gi_ptr->next)\n     {\n       struct gcov_summary this_object;\n@@ -154,18 +154,18 @@ gcov_exit (void)\n       struct gcov_ctr_summary *cs_obj, *cs_tobj, *cs_prg, *cs_tprg, *cs_all;\n       int error;\n       int merging;\n-      unsigned tag, length;\n-      unsigned long summary_pos = ~0UL;\n+      gcov_unsigned_t tag, length;\n+      gcov_position_t summary_pos = ~(gcov_position_t)0;\n \n       /* Totals for this object file.  */\n       memset (&this_object, 0, sizeof (this_object));\n       for (t_ix = c_ix = 0,\n \t     ci_ptr = gi_ptr->counts, cs_ptr = this_object.ctrs;\n-\t   t_ix != GCOV_COUNTERS; t_ix++, cs_ptr++)\n+\t   t_ix != GCOV_COUNTERS_SUMMABLE; t_ix++, cs_ptr++)\n \tif ((1 << t_ix) & gi_ptr->ctr_mask)\n \t  {\n \t    const gcov_type *c_ptr;\n-\t    unsigned c_num;\n+\t    gcov_unsigned_t c_num;\n \n \t    cs_ptr->num += ci_ptr->num;\n \t    values[c_ix] = ci_ptr->values;\n@@ -258,7 +258,7 @@ gcov_exit (void)\n \t  /* Check program & object summary */\n \t  while (!gcov_is_eof ())\n \t    {\n-\t      unsigned long base = gcov_position ();\n+\t      gcov_position_t base = gcov_position ();\n \t      int is_program;\n \t      \n \t      tag = gcov_read_unsigned ();\n@@ -295,7 +295,7 @@ gcov_exit (void)\n \t     cs_obj = object.ctrs, cs_tobj = this_object.ctrs,\n \t     cs_prg = program.ctrs, cs_tprg = this_program.ctrs,\n \t     cs_all = all.ctrs;\n-\t   t_ix != GCOV_COUNTERS;\n+\t   t_ix != GCOV_COUNTERS_SUMMABLE;\n \t   t_ix++, cs_obj++, cs_tobj++, cs_prg++, cs_tprg++, cs_all++)\n \t{\n \t  if ((1 << t_ix) & gi_ptr->ctr_mask)\n@@ -340,8 +340,7 @@ gcov_exit (void)\n       program.checksum = gcov_crc32;\n       \n       /* Write out the data.  */\n-      gcov_write_unsigned (GCOV_DATA_MAGIC);\n-      gcov_write_unsigned (GCOV_VERSION);\n+      gcov_write_tag_length (GCOV_DATA_MAGIC, GCOV_VERSION);\n       \n       /* Write execution counts for each function.  */\n       for (f_ix = gi_ptr->n_functions, fi_ptr = gi_ptr->functions; f_ix--;\n@@ -396,16 +395,16 @@ __gcov_init (struct gcov_info *info)\n   else\n     {\n       const char *ptr = info->filename;\n-      unsigned crc32 = gcov_crc32;\n+      gcov_unsigned_t crc32 = gcov_crc32;\n   \n       do\n \t{\n \t  unsigned ix;\n-\t  unsigned value = *ptr << 24;\n+\t  gcov_unsigned_t value = *ptr << 24;\n \n \t  for (ix = 8; ix--; value <<= 1)\n \t    {\n-\t      unsigned feedback;\n+\t      gcov_unsigned_t feedback;\n \n \t      feedback = (value ^ crc32) & 0x80000000 ? 0x04c11db7 : 0;\n \t      crc32 <<= 1;\n@@ -456,9 +455,7 @@ __gcov_flush (void)\n    an array COUNTERS of N_COUNTERS old counters and it reads the same number\n    of counters from the gcov file.  */\n void\n-__gcov_merge_add (counters, n_counters)\n-     gcov_type *counters;\n-     unsigned n_counters;\n+__gcov_merge_add (gcov_type *counters, unsigned n_counters)\n {\n   for (; n_counters; counters++, n_counters--)\n     *counters += gcov_read_counter ();"}, {"sha": "f5ee9f318254f3e1bfcd66a5d8fb43113e9bcf84", "filename": "gcc/profile.c", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b514d25867f14eb1b430765ba6d5083e592fcd7/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b514d25867f14eb1b430765ba6d5083e592fcd7/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=9b514d25867f14eb1b430765ba6d5083e592fcd7", "patch": "@@ -670,22 +670,25 @@ branch_prob ()\n   if (rtl_dump_file)\n     fprintf (rtl_dump_file, \"%d ignored edges\\n\", ignored_edges);\n \n-  /* Write the .bbg data from which gcov can reconstruct the basic block\n-     graph.  First output the number of basic blocks, and then for every\n-     edge output the source and target basic block numbers.\n-     NOTE: The format of this file must be compatible with gcov.  */\n+  /* Write the data from which gcov can reconstruct the basic block\n+     graph.  */\n \n+  /* Basic block flags */\n   if (coverage_begin_output ())\n     {\n-      long offset;\n+      gcov_position_t offset;\n       \n-      /* Basic block flags */\n       offset = gcov_write_tag (GCOV_TAG_BLOCKS);\n       for (i = 0; i != (unsigned) (n_basic_blocks + 2); i++)\n \tgcov_write_unsigned (0);\n       gcov_write_length (offset);\n-      \n-      /* Arcs */\n+    }\n+\n+  /* Arcs */\n+  if (coverage_begin_output ())\n+    {\n+      gcov_position_t offset;\n+\n       FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR, next_bb)\n \t{\n \t  edge e;\n@@ -716,12 +719,11 @@ branch_prob ()\n \t}\n     }\n   \n-  /* Output line number information about each basic block for GCOV\n-     utility.  */\n+  /* Line numbers. */\n   if (coverage_begin_output ())\n     {\n       char const *prev_file_name = NULL;\n-      long offset;\n+      gcov_position_t offset;\n       \n       FOR_EACH_BB (bb)\n \t{"}]}