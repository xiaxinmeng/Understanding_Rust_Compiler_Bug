{"sha": "9927ecbb42d5be48fa933adc26f8601fab5007ca", "node_id": "C_kwDOANBUbNoAKDk5MjdlY2JiNDJkNWJlNDhmYTkzM2FkYzI2Zjg2MDFmYWI1MDA3Y2E", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-10-28T14:05:14Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-10-28T14:05:14Z"}, "message": "c++: quadratic constexpr behavior for left-assoc logical exprs [PR102780]\n\nIn the testcase below the two left fold expressions each expand into a\nconstant logical expression with 1024 terms, for which potential_const_expr\ntakes more than a minute to return true.  This happens because p_c_e_1\nperforms trial evaluation of the first operand of a &&/|| in order to\ndetermine whether to consider the potentiality of the second operand.\nAnd because the expanded expression is left-associated, this trial\nevaluation causes p_c_e_1 to be quadratic in the number of terms of the\nexpression.\n\nThis patch fixes this quadratic behavior by making p_c_e_1 preemptively\ncompute potentiality of the second operand of a &&/||, and perform trial\nevaluation of the first operand only if the second operand isn't\npotentially constant.  We must be careful to avoid emitting bogus\ndiagnostics during the preemptive computation; to that end, we perform\nthis shortcut only when tf_error is cleared, and when tf_error is set we\nnow first check potentiality of the whole expression quietly and replay\nthe check noisily for diagnostics.\n\nApart from fixing the quadraticness for left-associated logical exprs,\nthis change also reduces compile time for the libstdc++ testcase\n20_util/variant/87619.cc by about 15% even though our <variant> uses\nright folds instead of left folds.  Likewise for the testcase in the PR,\nfor which compile time is reduced by 30%.  The reason for these speedups\nis that p_c_e_1 no longer performs expensive trial evaluation of each term\nof large constant logical expressions when determining their potentiality.\n\n\tPR c++/102780\n\ngcc/cp/ChangeLog:\n\n\t* constexpr.c (potential_constant_expression_1) <case TRUTH_*_EXPR>:\n\tWhen tf_error isn't set, preemptively check potentiality of the\n\tsecond operand before performing trial evaluation of the first\n\toperand.\n\t(potential_constant_expression_1): When tf_error is set, first check\n\tpotentiality quietly and return true if successful, otherwise\n\tproceed noisily to give errors.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp1z/fold13.C: New test.", "tree": {"sha": "d7a429153129f283749b464cdb50c7fed3296fcd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d7a429153129f283749b464cdb50c7fed3296fcd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9927ecbb42d5be48fa933adc26f8601fab5007ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9927ecbb42d5be48fa933adc26f8601fab5007ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9927ecbb42d5be48fa933adc26f8601fab5007ca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9927ecbb42d5be48fa933adc26f8601fab5007ca/comments", "author": null, "committer": null, "parents": [{"sha": "60861d87946c84a1eb90e21d6acb55a7289450e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60861d87946c84a1eb90e21d6acb55a7289450e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60861d87946c84a1eb90e21d6acb55a7289450e0"}], "stats": {"total": 55, "additions": 50, "deletions": 5}, "files": [{"sha": "40fe165c2b7c8758bf3c4a15a645b99b7c8a5953", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9927ecbb42d5be48fa933adc26f8601fab5007ca/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9927ecbb42d5be48fa933adc26f8601fab5007ca/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=9927ecbb42d5be48fa933adc26f8601fab5007ca", "patch": "@@ -8892,13 +8892,18 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n       tmp = boolean_false_node;\n     truth:\n       {\n-\ttree op = TREE_OPERAND (t, 0);\n-\tif (!RECUR (op, rval))\n+\ttree op0 = TREE_OPERAND (t, 0);\n+\ttree op1 = TREE_OPERAND (t, 1);\n+\tif (!RECUR (op0, rval))\n \t  return false;\n+\tif (!(flags & tf_error) && RECUR (op1, rval))\n+\t  /* When quiet, try to avoid expensive trial evaluation by first\n+\t     checking potentiality of the second operand.  */\n+\t  return true;\n \tif (!processing_template_decl)\n-\t  op = cxx_eval_outermost_constant_expr (op, true);\n-\tif (tree_int_cst_equal (op, tmp))\n-\t  return RECUR (TREE_OPERAND (t, 1), rval);\n+\t  op0 = cxx_eval_outermost_constant_expr (op0, true);\n+\tif (tree_int_cst_equal (op0, tmp))\n+\t  return (flags & tf_error) ? RECUR (op1, rval) : false;\n \telse\n \t  return true;\n       }\n@@ -9107,6 +9112,17 @@ bool\n potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n \t\t\t\t tsubst_flags_t flags)\n {\n+  if (flags & tf_error)\n+    {\n+      /* Check potentiality quietly first, as that could be performed more\n+\t efficiently in some cases (currently only for TRUTH_*_EXPR).  If\n+\t that fails, replay the check noisily to give errors.  */\n+      flags &= ~tf_error;\n+      if (potential_constant_expression_1 (t, want_rval, strict, now, flags))\n+\treturn true;\n+      flags |= tf_error;\n+    }\n+\n   tree target = NULL_TREE;\n   return potential_constant_expression_1 (t, want_rval, strict, now,\n \t\t\t\t\t  flags, &target);"}, {"sha": "9d7554f8999c5d1cb1486e7ea9561d38b70833d4", "filename": "gcc/testsuite/g++.dg/cpp1z/fold13.C", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9927ecbb42d5be48fa933adc26f8601fab5007ca/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Ffold13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9927ecbb42d5be48fa933adc26f8601fab5007ca/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Ffold13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Ffold13.C?ref=9927ecbb42d5be48fa933adc26f8601fab5007ca", "patch": "@@ -0,0 +1,29 @@\n+// { dg-do compile { target c++17 } }\n+// Verify constexpr evaluation of a large left fold logical expression\n+// isn't quadratic in the size of the expanded expression.\n+\n+template<int> struct S { static constexpr bool value = true; };\n+\n+template<class T, T...> struct integer_sequence { };\n+\n+template<class T, T N>\n+using make_integer_sequence\n+#if __has_builtin(__make_integer_seq)\n+  = __make_integer_seq<integer_sequence, T, N>;\n+#else\n+  = integer_sequence<T, __integer_pack(N)...>;\n+#endif\n+\n+template<int... Is>\n+constexpr bool f_impl(integer_sequence<int, Is...>) {\n+  return (... && S<Is>::value);\n+}\n+\n+static_assert(f_impl(make_integer_sequence<int, 1024>()));\n+\n+template<int... Is>\n+constexpr bool g_impl(integer_sequence<int, Is...>) {\n+  return (... || !S<Is>::value);\n+}\n+\n+static_assert(!g_impl(make_integer_sequence<int, 1024>()));"}]}