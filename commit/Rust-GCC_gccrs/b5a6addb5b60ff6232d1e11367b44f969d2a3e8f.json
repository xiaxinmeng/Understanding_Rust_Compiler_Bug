{"sha": "b5a6addb5b60ff6232d1e11367b44f969d2a3e8f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjVhNmFkZGI1YjYwZmY2MjMyZDFlMTEzNjdiNDRmOTY5ZDJhM2U4Zg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2019-08-27T12:46:07Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2019-08-27T12:46:07Z"}, "message": "2019-08-27  Richard Biener  <rguenther@suse.de>\n\n\t* config/i386/i386-features.h\n\t(general_scalar_chain::~general_scalar_chain): Add.\n\t(general_scalar_chain::insns_conv): New bitmap.\n\t(general_scalar_chain::n_sse_to_integer): New.\n\t(general_scalar_chain::n_integer_to_sse): Likewise.\n\t(general_scalar_chain::make_vector_copies): Adjust signature.\n\t* config/i386/i386-features.c\n\t(general_scalar_chain::general_scalar_chain): Outline,\n\tinitialize new members.\n\t(general_scalar_chain::~general_scalar_chain): New.\n\t(general_scalar_chain::mark_dual_mode_def): Record insns\n\twe need to insert conversions at and count them.\n\t(general_scalar_chain::compute_convert_gain): Account\n\tfor conversion instructions at chain boundary.\n\t(general_scalar_chain::make_vector_copies): Generate a single\n\tcopy for a def by a specific insn.\n\t(general_scalar_chain::convert_registers): First populate\n\tdefs_map, then make copies at out-of chain insns.\n\nFrom-SVN: r274953", "tree": {"sha": "f674a206cb862c84935c8239e024ce69a8cc3c95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f674a206cb862c84935c8239e024ce69a8cc3c95"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b5a6addb5b60ff6232d1e11367b44f969d2a3e8f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5a6addb5b60ff6232d1e11367b44f969d2a3e8f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5a6addb5b60ff6232d1e11367b44f969d2a3e8f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5a6addb5b60ff6232d1e11367b44f969d2a3e8f/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6a07489267e55084c3d5e88b4e9591be25bf2bf6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a07489267e55084c3d5e88b4e9591be25bf2bf6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a07489267e55084c3d5e88b4e9591be25bf2bf6"}], "stats": {"total": 202, "additions": 119, "deletions": 83}, "files": [{"sha": "65f9db966d067bca2d1783e9d85ea6c362a7d8e8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5a6addb5b60ff6232d1e11367b44f969d2a3e8f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5a6addb5b60ff6232d1e11367b44f969d2a3e8f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b5a6addb5b60ff6232d1e11367b44f969d2a3e8f", "patch": "@@ -1,3 +1,24 @@\n+2019-08-27  Richard Biener  <rguenther@suse.de>\n+\n+\t* config/i386/i386-features.h\n+\t(general_scalar_chain::~general_scalar_chain): Add.\n+\t(general_scalar_chain::insns_conv): New bitmap.\n+\t(general_scalar_chain::n_sse_to_integer): New.\n+\t(general_scalar_chain::n_integer_to_sse): Likewise.\n+\t(general_scalar_chain::make_vector_copies): Adjust signature.\n+\t* config/i386/i386-features.c\n+\t(general_scalar_chain::general_scalar_chain): Outline,\n+\tinitialize new members.\n+\t(general_scalar_chain::~general_scalar_chain): New.\n+\t(general_scalar_chain::mark_dual_mode_def): Record insns\n+\twe need to insert conversions at and count them.\n+\t(general_scalar_chain::compute_convert_gain): Account\n+\tfor conversion instructions at chain boundary.\n+\t(general_scalar_chain::make_vector_copies): Generate a single\n+\tcopy for a def by a specific insn.\n+\t(general_scalar_chain::convert_registers): First populate\n+\tdefs_map, then make copies at out-of chain insns.\n+\n 2019-08-27  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* config/arm/arm.md (stack_protect_set_insn): Add security-related"}, {"sha": "9505b4a133009a982e589b7ae4ea65649c7ec8dc", "filename": "gcc/config/i386/i386-features.c", "status": "modified", "additions": 92, "deletions": 80, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5a6addb5b60ff6232d1e11367b44f969d2a3e8f/gcc%2Fconfig%2Fi386%2Fi386-features.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5a6addb5b60ff6232d1e11367b44f969d2a3e8f/gcc%2Fconfig%2Fi386%2Fi386-features.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-features.c?ref=b5a6addb5b60ff6232d1e11367b44f969d2a3e8f", "patch": "@@ -320,6 +320,20 @@ scalar_chain::add_to_queue (unsigned insn_uid)\n   bitmap_set_bit (queue, insn_uid);\n }\n \n+general_scalar_chain::general_scalar_chain (enum machine_mode smode_,\n+\t\t\t\t\t    enum machine_mode vmode_)\n+     : scalar_chain (smode_, vmode_)\n+{\n+  insns_conv = BITMAP_ALLOC (NULL);\n+  n_sse_to_integer = 0;\n+  n_integer_to_sse = 0;\n+}\n+\n+general_scalar_chain::~general_scalar_chain ()\n+{\n+  BITMAP_FREE (insns_conv);\n+}\n+\n /* For DImode conversion, mark register defined by DEF as requiring\n    conversion.  */\n \n@@ -328,15 +342,27 @@ general_scalar_chain::mark_dual_mode_def (df_ref def)\n {\n   gcc_assert (DF_REF_REG_DEF_P (def));\n \n-  if (bitmap_bit_p (defs_conv, DF_REF_REGNO (def)))\n-    return;\n-\n+  /* Record the def/insn pair so we can later efficiently iterate over\n+     the defs to convert on insns not in the chain.  */\n+  bool reg_new = bitmap_set_bit (defs_conv, DF_REF_REGNO (def));\n+  if (!bitmap_bit_p (insns, DF_REF_INSN_UID (def)))\n+    {\n+      if (!bitmap_set_bit (insns_conv, DF_REF_INSN_UID (def))\n+\t  && !reg_new)\n+\treturn;\n+      n_integer_to_sse++;\n+    }\n+  else\n+    {\n+      if (!reg_new)\n+\treturn;\n+      n_sse_to_integer++;\n+    }\n+ \n   if (dump_file)\n     fprintf (dump_file,\n \t     \"  Mark r%d def in insn %d as requiring both modes in chain #%d\\n\",\n \t     DF_REF_REGNO (def), DF_REF_INSN_UID (def), chain_id);\n-\n-  bitmap_set_bit (defs_conv, DF_REF_REGNO (def));\n }\n \n /* For TImode conversion, it is unused.  */\n@@ -523,7 +549,7 @@ general_scalar_chain::compute_convert_gain ()\n \t       || GET_CODE (src) == ASHIFTRT\n \t       || GET_CODE (src) == LSHIFTRT)\n \t{\n-    \t  if (CONST_INT_P (XEXP (src, 0)))\n+\t  if (CONST_INT_P (XEXP (src, 0)))\n \t    igain -= vector_const_cost (XEXP (src, 0));\n \t  igain += m * ix86_cost->shift_const - ix86_cost->sse_op;\n \t  if (INTVAL (XEXP (src, 1)) >= 32)\n@@ -588,9 +614,12 @@ general_scalar_chain::compute_convert_gain ()\n   if (dump_file)\n     fprintf (dump_file, \"  Instruction conversion gain: %d\\n\", gain);\n \n-  /* ???  What about integer to SSE?  */\n-  EXECUTE_IF_SET_IN_BITMAP (defs_conv, 0, insn_uid, bi)\n-    cost += DF_REG_DEF_COUNT (insn_uid) * ix86_cost->sse_to_integer;\n+  /* Cost the integer to sse and sse to integer moves.  */\n+  cost += n_sse_to_integer * ix86_cost->sse_to_integer;\n+  /* ???  integer_to_sse but we only have that in the RA cost table.\n+     Assume sse_to_integer/integer_to_sse are the same which they\n+     are at the moment.  */\n+  cost += n_integer_to_sse * ix86_cost->sse_to_integer;\n \n   if (dump_file)\n     fprintf (dump_file, \"  Registers conversion cost: %d\\n\", cost);\n@@ -649,85 +678,64 @@ gen_gpr_to_xmm_move_src (enum machine_mode vmode, rtx gpr)\n    and replace its uses in a chain.  */\n \n void\n-general_scalar_chain::make_vector_copies (unsigned regno)\n+general_scalar_chain::make_vector_copies (rtx_insn *insn, rtx reg)\n {\n-  rtx reg = regno_reg_rtx[regno];\n-  rtx vreg = gen_reg_rtx (smode);\n-  df_ref ref;\n-\n-  defs_map.put (reg, vreg);\n+  rtx vreg = *defs_map.get (reg);\n \n-  /* For each insn defining REGNO, see if it is defined by an insn\n-     not part of the chain but with uses in insns part of the chain\n-     and insert a copy in that case.  */\n-  for (ref = DF_REG_DEF_CHAIN (regno); ref; ref = DF_REF_NEXT_REG (ref))\n+  start_sequence ();\n+  if (!TARGET_INTER_UNIT_MOVES_TO_VEC)\n     {\n-      if (bitmap_bit_p (insns, DF_REF_INSN_UID (ref)))\n-\tcontinue;\n-      df_link *use;\n-      for (use = DF_REF_CHAIN (ref); use; use = use->next)\n-\tif (!DF_REF_REG_MEM_P (use->ref)\n-\t    && bitmap_bit_p (insns, DF_REF_INSN_UID (use->ref)))\n-\t  break;\n-      if (!use)\n-\tcontinue;\n-\n-      start_sequence ();\n-      if (!TARGET_INTER_UNIT_MOVES_TO_VEC)\n+      rtx tmp = assign_386_stack_local (smode, SLOT_STV_TEMP);\n+      if (smode == DImode && !TARGET_64BIT)\n \t{\n-\t  rtx tmp = assign_386_stack_local (smode, SLOT_STV_TEMP);\n-\t  if (smode == DImode && !TARGET_64BIT)\n-\t    {\n-\t      emit_move_insn (adjust_address (tmp, SImode, 0),\n-\t\t\t      gen_rtx_SUBREG (SImode, reg, 0));\n-\t      emit_move_insn (adjust_address (tmp, SImode, 4),\n-\t\t\t      gen_rtx_SUBREG (SImode, reg, 4));\n-\t    }\n-\t  else\n-\t    emit_move_insn (copy_rtx (tmp), reg);\n-\t  emit_insn (gen_rtx_SET (gen_rtx_SUBREG (vmode, vreg, 0),\n-\t\t\t\t  gen_gpr_to_xmm_move_src (vmode, tmp)));\n+\t  emit_move_insn (adjust_address (tmp, SImode, 0),\n+\t\t\t  gen_rtx_SUBREG (SImode, reg, 0));\n+\t  emit_move_insn (adjust_address (tmp, SImode, 4),\n+\t\t\t  gen_rtx_SUBREG (SImode, reg, 4));\n \t}\n-      else if (!TARGET_64BIT && smode == DImode)\n+      else\n+\temit_move_insn (copy_rtx (tmp), reg);\n+      emit_insn (gen_rtx_SET (gen_rtx_SUBREG (vmode, vreg, 0),\n+\t\t\t      gen_gpr_to_xmm_move_src (vmode, tmp)));\n+    }\n+  else if (!TARGET_64BIT && smode == DImode)\n+    {\n+      if (TARGET_SSE4_1)\n \t{\n-\t  if (TARGET_SSE4_1)\n-\t    {\n-\t      emit_insn (gen_sse2_loadld (gen_rtx_SUBREG (V4SImode, vreg, 0),\n-\t\t\t\t\t  CONST0_RTX (V4SImode),\n-\t\t\t\t\t  gen_rtx_SUBREG (SImode, reg, 0)));\n-\t      emit_insn (gen_sse4_1_pinsrd (gen_rtx_SUBREG (V4SImode, vreg, 0),\n-\t\t\t\t\t    gen_rtx_SUBREG (V4SImode, vreg, 0),\n-\t\t\t\t\t    gen_rtx_SUBREG (SImode, reg, 4),\n-\t\t\t\t\t    GEN_INT (2)));\n-\t    }\n-\t  else\n-\t    {\n-\t      rtx tmp = gen_reg_rtx (DImode);\n-\t      emit_insn (gen_sse2_loadld (gen_rtx_SUBREG (V4SImode, vreg, 0),\n-\t\t\t\t\t  CONST0_RTX (V4SImode),\n-\t\t\t\t\t  gen_rtx_SUBREG (SImode, reg, 0)));\n-\t      emit_insn (gen_sse2_loadld (gen_rtx_SUBREG (V4SImode, tmp, 0),\n-\t\t\t\t\t  CONST0_RTX (V4SImode),\n-\t\t\t\t\t  gen_rtx_SUBREG (SImode, reg, 4)));\n-\t      emit_insn (gen_vec_interleave_lowv4si\n-\t\t\t (gen_rtx_SUBREG (V4SImode, vreg, 0),\n-\t\t\t  gen_rtx_SUBREG (V4SImode, vreg, 0),\n-\t\t\t  gen_rtx_SUBREG (V4SImode, tmp, 0)));\n-\t    }\n+\t  emit_insn (gen_sse2_loadld (gen_rtx_SUBREG (V4SImode, vreg, 0),\n+\t\t\t\t      CONST0_RTX (V4SImode),\n+\t\t\t\t      gen_rtx_SUBREG (SImode, reg, 0)));\n+\t  emit_insn (gen_sse4_1_pinsrd (gen_rtx_SUBREG (V4SImode, vreg, 0),\n+\t\t\t\t\tgen_rtx_SUBREG (V4SImode, vreg, 0),\n+\t\t\t\t\tgen_rtx_SUBREG (SImode, reg, 4),\n+\t\t\t\t\tGEN_INT (2)));\n \t}\n       else\n-\temit_insn (gen_rtx_SET (gen_rtx_SUBREG (vmode, vreg, 0),\n-\t\t\t\tgen_gpr_to_xmm_move_src (vmode, reg)));\n-      rtx_insn *seq = get_insns ();\n-      end_sequence ();\n-      rtx_insn *insn = DF_REF_INSN (ref);\n-      emit_conversion_insns (seq, insn);\n-\n-      if (dump_file)\n-\tfprintf (dump_file,\n-\t\t \"  Copied r%d to a vector register r%d for insn %d\\n\",\n-\t\t regno, REGNO (vreg), INSN_UID (insn));\n+\t{\n+\t  rtx tmp = gen_reg_rtx (DImode);\n+\t  emit_insn (gen_sse2_loadld (gen_rtx_SUBREG (V4SImode, vreg, 0),\n+\t\t\t\t      CONST0_RTX (V4SImode),\n+\t\t\t\t      gen_rtx_SUBREG (SImode, reg, 0)));\n+\t  emit_insn (gen_sse2_loadld (gen_rtx_SUBREG (V4SImode, tmp, 0),\n+\t\t\t\t      CONST0_RTX (V4SImode),\n+\t\t\t\t      gen_rtx_SUBREG (SImode, reg, 4)));\n+\t  emit_insn (gen_vec_interleave_lowv4si\n+\t\t     (gen_rtx_SUBREG (V4SImode, vreg, 0),\n+\t\t      gen_rtx_SUBREG (V4SImode, vreg, 0),\n+\t\t      gen_rtx_SUBREG (V4SImode, tmp, 0)));\n+\t}\n     }\n+  else\n+    emit_insn (gen_rtx_SET (gen_rtx_SUBREG (vmode, vreg, 0),\n+\t\t\t    gen_gpr_to_xmm_move_src (vmode, reg)));\n+  rtx_insn *seq = get_insns ();\n+  end_sequence ();\n+  emit_conversion_insns (seq, insn);\n+\n+  if (dump_file)\n+    fprintf (dump_file,\n+\t     \"  Copied r%d to a vector register r%d for insn %d\\n\",\n+\t     REGNO (reg), REGNO (vreg), INSN_UID (insn));\n }\n \n /* Copy the definition SRC of INSN inside the chain to DST for\n@@ -1158,7 +1166,11 @@ general_scalar_chain::convert_registers ()\n   bitmap_iterator bi;\n   unsigned id;\n   EXECUTE_IF_SET_IN_BITMAP (defs_conv, 0, id, bi)\n-    make_vector_copies (id);\n+    defs_map.put (regno_reg_rtx[id], gen_reg_rtx (smode));\n+  EXECUTE_IF_SET_IN_BITMAP (insns_conv, 0, id, bi)\n+    for (df_ref ref = DF_INSN_UID_DEFS (id); ref; ref = DF_REF_NEXT_LOC (ref))\n+      if (bitmap_bit_p (defs_conv, DF_REF_REGNO (ref)))\n+\tmake_vector_copies (DF_REF_INSN (ref), DF_REF_REAL_REG (ref));\n }\n \n /* Convert whole chain creating required register"}, {"sha": "09fe3402de3a92889e892808876d7de005350b0d", "filename": "gcc/config/i386/i386-features.h", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5a6addb5b60ff6232d1e11367b44f969d2a3e8f/gcc%2Fconfig%2Fi386%2Fi386-features.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5a6addb5b60ff6232d1e11367b44f969d2a3e8f/gcc%2Fconfig%2Fi386%2Fi386-features.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-features.h?ref=b5a6addb5b60ff6232d1e11367b44f969d2a3e8f", "patch": "@@ -167,16 +167,19 @@ class scalar_chain\n class general_scalar_chain : public scalar_chain\n {\n  public:\n-  general_scalar_chain (enum machine_mode smode_, enum machine_mode vmode_)\n-    : scalar_chain (smode_, vmode_) {}\n+  general_scalar_chain (enum machine_mode smode_, enum machine_mode vmode_);\n+  ~general_scalar_chain ();\n   int compute_convert_gain ();\n  private:\n   hash_map<rtx, rtx> defs_map;\n+  bitmap insns_conv;\n+  unsigned n_sse_to_integer;\n+  unsigned n_integer_to_sse;\n   void mark_dual_mode_def (df_ref def);\n   void convert_insn (rtx_insn *insn);\n   void convert_op (rtx *op, rtx_insn *insn);\n   void convert_reg (rtx_insn *insn, rtx dst, rtx src);\n-  void make_vector_copies (unsigned regno);\n+  void make_vector_copies (rtx_insn *, rtx);\n   void convert_registers ();\n   int vector_const_cost (rtx exp);\n };"}]}