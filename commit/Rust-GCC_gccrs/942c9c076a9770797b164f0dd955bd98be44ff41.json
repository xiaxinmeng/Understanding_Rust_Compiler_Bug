{"sha": "942c9c076a9770797b164f0dd955bd98be44ff41", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTQyYzljMDc2YTk3NzA3OTdiMTY0ZjBkZDk1NWJkOThiZTQ0ZmY0MQ==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@gmail.com", "date": "2010-11-01T03:24:20Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2010-11-01T03:24:20Z"}, "message": "re PR target/46030 (registers trashed with -Os)\n\n\tPR target/46030\n\t* config/rs6000/rs6000.c (struct rs6000_stack): Add reload_completed\n\tand savres_strategy.\n\t(stack_info): New file scope var.\n\t(rs6000_init_machine_status): Init stack_info.\n\t(SAVRES_INLINE_FPRS, SAVRES_INLINE_GPRS,\n\tSAVRES_NOINLINE_GPRS_SAVES_LR, SAVRES_NOINLINE_FPRS_SAVES_LR,\n\tSAVRES_NOINLINE_FPRS_DOESNT_RESTORE_LR): Replace with..\n\t(SAVE_INLINE_FPRS, SAVE_INLINE_GPRS, REST_INLINE_FPRS, REST_INLINE_GPRS,\n\tSAVE_NOINLINE_GPRS_SAVES_LR, SAVE_NOINLINE_FPRS_SAVES_LR\n\tREST_NOINLINE_FPRS_DOESNT_RESTORE_LR): ..this.  Update all refs.\n\t(rs6000_savres_strategy): Rewrite.\n\t(rs6000_stack_info): Use \"stack_info\" in place of local \"info\".\n\tReturn cached stack info when reload_completed unless ENABLE_CHECKING\n\tin which case confirm newly calculated stack info matches old info.\n\tDelay calculation of lr_save_p, set it for out of line gp save/restore\n\tas well as fp.  Call rs6000_savres_strategy from here..\n\t(rs6000_emit_prologue, rs6000_emit_epilogue): ..rather than here.\n\t(rs6000_output_function_prologue): Use info->savres_strategy to\n\tdetermine whether fp save/restore externs need to be emitted.\n\nFrom-SVN: r166125", "tree": {"sha": "2789cb8ef742aef3eb7d081e5cd801573be82187", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2789cb8ef742aef3eb7d081e5cd801573be82187"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/942c9c076a9770797b164f0dd955bd98be44ff41", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/942c9c076a9770797b164f0dd955bd98be44ff41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/942c9c076a9770797b164f0dd955bd98be44ff41", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/942c9c076a9770797b164f0dd955bd98be44ff41/comments", "author": {"login": "amodra", "id": 6006325, "node_id": "MDQ6VXNlcjYwMDYzMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amodra", "html_url": "https://github.com/amodra", "followers_url": "https://api.github.com/users/amodra/followers", "following_url": "https://api.github.com/users/amodra/following{/other_user}", "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}", "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amodra/subscriptions", "organizations_url": "https://api.github.com/users/amodra/orgs", "repos_url": "https://api.github.com/users/amodra/repos", "events_url": "https://api.github.com/users/amodra/events{/privacy}", "received_events_url": "https://api.github.com/users/amodra/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0930cc0ece835ab77a30d8b5894a8910f55d4054", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0930cc0ece835ab77a30d8b5894a8910f55d4054", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0930cc0ece835ab77a30d8b5894a8910f55d4054"}], "stats": {"total": 344, "additions": 199, "deletions": 145}, "files": [{"sha": "6fd8147b29cd5a7739af911b97cb095ecf267ca9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/942c9c076a9770797b164f0dd955bd98be44ff41/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/942c9c076a9770797b164f0dd955bd98be44ff41/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=942c9c076a9770797b164f0dd955bd98be44ff41", "patch": "@@ -1,3 +1,26 @@\n+2010-11-01  Alan Modra  <amodra@gmail.com>\n+\n+\tPR target/46030\n+\t* config/rs6000/rs6000.c (struct rs6000_stack): Add reload_completed\n+\tand savres_strategy.\n+\t(stack_info): New file scope var.\n+\t(rs6000_init_machine_status): Init stack_info.\n+\t(SAVRES_INLINE_FPRS, SAVRES_INLINE_GPRS,\n+\tSAVRES_NOINLINE_GPRS_SAVES_LR, SAVRES_NOINLINE_FPRS_SAVES_LR,\n+\tSAVRES_NOINLINE_FPRS_DOESNT_RESTORE_LR): Replace with..\n+\t(SAVE_INLINE_FPRS, SAVE_INLINE_GPRS, REST_INLINE_FPRS, REST_INLINE_GPRS,\n+\tSAVE_NOINLINE_GPRS_SAVES_LR, SAVE_NOINLINE_FPRS_SAVES_LR\n+\tREST_NOINLINE_FPRS_DOESNT_RESTORE_LR): ..this.  Update all refs.\n+\t(rs6000_savres_strategy): Rewrite.\n+\t(rs6000_stack_info): Use \"stack_info\" in place of local \"info\".\n+\tReturn cached stack info when reload_completed unless ENABLE_CHECKING\n+\tin which case confirm newly calculated stack info matches old info.\n+\tDelay calculation of lr_save_p, set it for out of line gp save/restore\n+\tas well as fp.  Call rs6000_savres_strategy from here..\n+\t(rs6000_emit_prologue, rs6000_emit_epilogue): ..rather than here.\n+\t(rs6000_output_function_prologue): Use info->savres_strategy to\n+\tdetermine whether fp save/restore externs need to be emitted.\n+\n 2010-10-31  Jason Merrill  <jason@redhat.com>\n \n \t* tree.h (EXPR_LOC_OR_HERE): New macro."}, {"sha": "6f7636bb2984cc2b705abaf55e88924eff217583", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 176, "deletions": 145, "changes": 321, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/942c9c076a9770797b164f0dd955bd98be44ff41/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/942c9c076a9770797b164f0dd955bd98be44ff41/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=942c9c076a9770797b164f0dd955bd98be44ff41", "patch": "@@ -73,6 +73,7 @@\n \n /* Structure used to define the rs6000 stack */\n typedef struct rs6000_stack {\n+  int reload_completed;\t\t/* stack info won't change from here on */\n   int first_gp_reg_save;\t/* first callee saved GP register used */\n   int first_fp_reg_save;\t/* first callee saved FP register used */\n   int first_altivec_reg_save;\t/* first callee saved AltiVec register used */\n@@ -109,6 +110,7 @@ typedef struct rs6000_stack {\n   int spe_padding_size;\n   HOST_WIDE_INT total_size;\t/* total bytes allocated for stack */\n   int spe_64bit_regs_used;\n+  int savres_strategy;\n } rs6000_stack_t;\n \n /* A C structure for machine-specific, per-function data.\n@@ -994,7 +996,6 @@ static rtx rs6000_make_savres_rtx (rs6000_stack_t *, rtx, int,\n static bool rs6000_reg_live_or_pic_offset_p (int);\n static tree rs6000_builtin_vectorized_libmass (tree, tree, tree);\n static tree rs6000_builtin_vectorized_function (tree, tree, tree);\n-static int rs6000_savres_strategy (rs6000_stack_t *, bool, int, int);\n static void rs6000_restore_saved_cr (rtx, int);\n static bool rs6000_output_addr_const_extra (FILE *, rtx);\n static void rs6000_output_function_prologue (FILE *, HOST_WIDE_INT);\n@@ -15161,13 +15162,16 @@ rs6000_got_register (rtx value ATTRIBUTE_UNUSED)\n   return pic_offset_table_rtx;\n }\n \f\n+static rs6000_stack_t stack_info;\n+\n /* Function to init struct machine_function.\n    This will be called, via a pointer variable,\n    from push_function_context.  */\n \n static struct machine_function *\n rs6000_init_machine_status (void)\n {\n+  stack_info.reload_completed = 0;\n   return ggc_alloc_cleared_machine_function ();\n }\n \f\n@@ -18050,6 +18054,107 @@ is_altivec_return_reg (rtx reg, void *xyes)\n }\n \n \f\n+/* Determine the strategy for savings/restoring registers.  */\n+\n+enum {\n+  SAVRES_MULTIPLE = 0x1,\n+  SAVE_INLINE_FPRS = 0x2,\n+  SAVE_INLINE_GPRS = 0x4,\n+  REST_INLINE_FPRS = 0x8,\n+  REST_INLINE_GPRS = 0x10,\n+  SAVE_NOINLINE_GPRS_SAVES_LR = 0x20,\n+  SAVE_NOINLINE_FPRS_SAVES_LR = 0x40,\n+  REST_NOINLINE_FPRS_DOESNT_RESTORE_LR = 0x80\n+};\n+\n+static int\n+rs6000_savres_strategy (rs6000_stack_t *info,\n+\t\t\tbool using_static_chain_p)\n+{\n+  int strategy = 0;\n+\n+  if (TARGET_MULTIPLE\n+      && !TARGET_POWERPC64\n+      && !(TARGET_SPE_ABI && info->spe_64bit_regs_used)\n+      && info->first_gp_reg_save < 31\n+      && no_global_regs_above (info->first_gp_reg_save, /*gpr=*/true))\n+    strategy |= SAVRES_MULTIPLE;\n+\n+  if (crtl->calls_eh_return\n+      || cfun->machine->ra_need_lr\n+      || info->total_size > 32767)\n+    strategy |= (SAVE_INLINE_FPRS | REST_INLINE_FPRS\n+\t\t | SAVE_INLINE_GPRS | REST_INLINE_GPRS);\n+\n+  if (info->first_fp_reg_save == 64\n+      || FP_SAVE_INLINE (info->first_fp_reg_save)\n+      /* The out-of-line FP routines use double-precision stores;\n+\t we can't use those routines if we don't have such stores.  */\n+      || (TARGET_HARD_FLOAT && !TARGET_DOUBLE_FLOAT)\n+      || !no_global_regs_above (info->first_fp_reg_save, /*gpr=*/false))\n+    strategy |= SAVE_INLINE_FPRS | REST_INLINE_FPRS;\n+\n+  if (info->first_gp_reg_save == 32\n+      || GP_SAVE_INLINE (info->first_gp_reg_save)\n+      || !((strategy & SAVRES_MULTIPLE)\n+\t   || no_global_regs_above (info->first_gp_reg_save, /*gpr=*/true)))\n+    strategy |= SAVE_INLINE_GPRS | REST_INLINE_GPRS;\n+\n+  /* Don't bother to try to save things out-of-line if r11 is occupied\n+     by the static chain.  It would require too much fiddling and the\n+     static chain is rarely used anyway.  */\n+  if (using_static_chain_p)\n+    strategy |= SAVE_INLINE_FPRS | SAVE_INLINE_GPRS;\n+\n+  /* If we are going to use store multiple, then don't even bother\n+     with the out-of-line routines, since the store-multiple\n+     instruction will always be smaller.  */\n+  if ((strategy & SAVRES_MULTIPLE))\n+    strategy |= SAVE_INLINE_GPRS;\n+\n+  /* The situation is more complicated with load multiple.  We'd\n+     prefer to use the out-of-line routines for restores, since the\n+     \"exit\" out-of-line routines can handle the restore of LR and the\n+     frame teardown.  However if doesn't make sense to use the\n+     out-of-line routine if that is the only reason we'd need to save\n+     LR, and we can't use the \"exit\" out-of-line gpr restore if we\n+     have saved some fprs; In those cases it is advantageous to use\n+     load multiple when available.  */\n+  if ((strategy & SAVRES_MULTIPLE)\n+      && (!info->lr_save_p\n+\t  || info->first_fp_reg_save != 64))\n+    strategy |= REST_INLINE_GPRS;\n+\n+  /* We can only use load multiple or the out-of-line routines to\n+     restore if we've used store multiple or out-of-line routines\n+     in the prologue, i.e. if we've saved all the registers from\n+     first_gp_reg_save.  Otherwise, we risk loading garbage.  */\n+  if ((strategy & (SAVE_INLINE_GPRS | SAVRES_MULTIPLE)) == SAVE_INLINE_GPRS)\n+    strategy |= REST_INLINE_GPRS;\n+\n+  /* Saving CR interferes with the exit routines used on the SPE, so\n+     just punt here.  */\n+  if (TARGET_SPE_ABI\n+      && info->spe_64bit_regs_used\n+      && info->cr_save_p)\n+    strategy |= REST_INLINE_GPRS;\n+\n+#ifdef POWERPC_LINUX\n+  if (TARGET_64BIT)\n+    {\n+      if (!(strategy & SAVE_INLINE_FPRS))\n+\tstrategy |= SAVE_NOINLINE_FPRS_SAVES_LR;\n+      else if (!(strategy & SAVE_INLINE_GPRS)\n+\t       && info->first_fp_reg_save == 64)\n+\tstrategy |= SAVE_NOINLINE_GPRS_SAVES_LR;\n+    }\n+#else\n+  if (TARGET_AIX && !(strategy & REST_INLINE_FPRS))\n+    strategy |= REST_NOINLINE_FPRS_DOESNT_RESTORE_LR;\n+#endif\n+  return strategy;\n+}\n+\n /* Calculate the stack information for the current function.  This is\n    complicated by having two separate calling sequences, the AIX calling\n    sequence and the V.4 calling sequence.\n@@ -18150,15 +18255,26 @@ is_altivec_return_reg (rtx reg, void *xyes)\n static rs6000_stack_t *\n rs6000_stack_info (void)\n {\n-  static rs6000_stack_t info;\n-  rs6000_stack_t *info_ptr = &info;\n+#ifdef ENABLE_CHECKING\n+  static rs6000_stack_t info_save;\n+#endif\n+  rs6000_stack_t *info_ptr = &stack_info;\n   int reg_size = TARGET_32BIT ? 4 : 8;\n   int ehrd_size;\n   int save_align;\n   int first_gp;\n   HOST_WIDE_INT non_fixed_size;\n+  bool using_static_chain_p;\n+\n+#ifdef ENABLE_CHECKING\n+  memcpy (&info_save, &stack_info, sizeof stack_info);\n+#else\n+  if (reload_completed && info_ptr->reload_completed)\n+    return info_ptr;\n+#endif\n \n-  memset (&info, 0, sizeof (info));\n+  memset (&stack_info, 0, sizeof (stack_info));\n+  info_ptr->reload_completed = reload_completed;\n \n   if (TARGET_SPE)\n     {\n@@ -18215,23 +18331,6 @@ rs6000_stack_info (void)\n   info_ptr->calls_p = (! current_function_is_leaf\n \t\t       || cfun->machine->ra_needs_full_frame);\n \n-  /* Determine if we need to save the link register.  */\n-  if ((DEFAULT_ABI == ABI_AIX\n-       && crtl->profile\n-       && !TARGET_PROFILE_KERNEL)\n-#ifdef TARGET_RELOCATABLE\n-      || (TARGET_RELOCATABLE && (get_pool_size () != 0))\n-#endif\n-      || (info_ptr->first_fp_reg_save != 64\n-\t  && !FP_SAVE_INLINE (info_ptr->first_fp_reg_save))\n-      || (DEFAULT_ABI == ABI_V4 && cfun->calls_alloca)\n-      || info_ptr->calls_p\n-      || rs6000_ra_ever_killed ())\n-    {\n-      info_ptr->lr_save_p = 1;\n-      df_set_regs_ever_live (LR_REGNO, true);\n-    }\n-\n   /* Determine if we need to save the condition code registers.  */\n   if (df_regs_ever_live_p (CR2_REGNO)\n       || df_regs_ever_live_p (CR3_REGNO)\n@@ -18400,6 +18499,33 @@ rs6000_stack_info (void)\n   info_ptr->total_size = RS6000_ALIGN (non_fixed_size + info_ptr->fixed_size,\n \t\t\t\t       ABI_STACK_BOUNDARY / BITS_PER_UNIT);\n \n+  /* Determine if we need to save the link register.  */\n+  if (info_ptr->calls_p\n+      || (DEFAULT_ABI == ABI_AIX\n+\t  && crtl->profile\n+\t  && !TARGET_PROFILE_KERNEL)\n+      || (DEFAULT_ABI == ABI_V4 && cfun->calls_alloca)\n+#ifdef TARGET_RELOCATABLE\n+      || (TARGET_RELOCATABLE && (get_pool_size () != 0))\n+#endif\n+      || rs6000_ra_ever_killed ())\n+    info_ptr->lr_save_p = 1;\n+\n+  using_static_chain_p = (cfun->static_chain_decl != NULL_TREE\n+\t\t\t  && df_regs_ever_live_p (STATIC_CHAIN_REGNUM)\n+\t\t\t  && call_used_regs[STATIC_CHAIN_REGNUM]);\n+  info_ptr->savres_strategy = rs6000_savres_strategy (info_ptr,\n+\t\t\t\t\t\t      using_static_chain_p);\n+\n+  if (!(info_ptr->savres_strategy & SAVE_INLINE_GPRS)\n+      || !(info_ptr->savres_strategy & SAVE_INLINE_FPRS)\n+      || !(info_ptr->savres_strategy & REST_INLINE_GPRS)\n+      || !(info_ptr->savres_strategy & REST_INLINE_FPRS))\n+    info_ptr->lr_save_p = 1;\n+\n+  if (info_ptr->lr_save_p)\n+    df_set_regs_ever_live (LR_REGNO, true);\n+\n   /* Determine if we need to allocate any stack frame:\n \n      For AIX we need to push the stack if a frame pointer is needed\n@@ -18451,6 +18577,10 @@ rs6000_stack_info (void)\n   if (! info_ptr->cr_save_p)\n     info_ptr->cr_save_offset = 0;\n \n+#ifdef ENABLE_CHECKING\n+  gcc_assert (!(reload_completed && info_save.reload_completed)\n+\t      || memcmp (&info_save, &stack_info, sizeof stack_info) == 0);\n+#endif\n   return info_ptr;\n }\n \n@@ -19714,106 +19844,6 @@ rs6000_reg_live_or_pic_offset_p (int reg)\n                   || (DEFAULT_ABI == ABI_DARWIN && flag_pic))));\n }\n \n-enum {\n-  SAVRES_MULTIPLE = 0x1,\n-  SAVRES_INLINE_FPRS = 0x2,\n-  SAVRES_INLINE_GPRS = 0x4,\n-  SAVRES_NOINLINE_GPRS_SAVES_LR = 0x8,\n-  SAVRES_NOINLINE_FPRS_SAVES_LR = 0x10,\n-  SAVRES_NOINLINE_FPRS_DOESNT_RESTORE_LR = 0x20\n-};\n-\n-/* Determine the strategy for savings/restoring registers.  */\n-\n-static int\n-rs6000_savres_strategy (rs6000_stack_t *info, bool savep,\n-\t\t\tint using_static_chain_p, int sibcall)\n-{\n-  bool using_multiple_p;\n-  bool common;\n-  bool savres_fprs_inline;\n-  bool savres_gprs_inline;\n-  bool noclobber_global_gprs\n-    = no_global_regs_above (info->first_gp_reg_save, /*gpr=*/true);\n-  int strategy;\n-\n-  using_multiple_p = (TARGET_MULTIPLE && ! TARGET_POWERPC64\n-\t\t      && (!TARGET_SPE_ABI\n-\t\t\t  || info->spe_64bit_regs_used == 0)\n-\t\t      && info->first_gp_reg_save < 31\n-\t\t      && noclobber_global_gprs);\n-  /* Don't bother to try to save things out-of-line if r11 is occupied\n-     by the static chain.  It would require too much fiddling and the\n-     static chain is rarely used anyway.  */\n-  common = (using_static_chain_p\n-\t    || sibcall\n-\t    || crtl->calls_eh_return\n-\t    || !info->lr_save_p\n-\t    || cfun->machine->ra_need_lr\n-\t    || info->total_size > 32767);\n-  savres_fprs_inline = (common\n-\t\t\t|| info->first_fp_reg_save == 64\n-\t\t\t|| !no_global_regs_above (info->first_fp_reg_save,\n-\t\t\t\t\t\t  /*gpr=*/false)\n-\t\t\t/* The out-of-line FP routines use\n-\t\t\t   double-precision stores; we can't use those\n-\t\t\t   routines if we don't have such stores.  */\n-\t\t\t|| (TARGET_HARD_FLOAT && !TARGET_DOUBLE_FLOAT)\n-\t\t\t|| FP_SAVE_INLINE (info->first_fp_reg_save));\n-  savres_gprs_inline = (common\n-\t\t\t/* Saving CR interferes with the exit routines\n-\t\t\t   used on the SPE, so just punt here.  */\n-\t\t\t|| (!savep\n-\t\t\t    && TARGET_SPE_ABI\n-\t\t\t    && info->spe_64bit_regs_used != 0\n-\t\t\t    && info->cr_save_p != 0)\n-\t\t\t|| info->first_gp_reg_save == 32\n-\t\t\t|| !noclobber_global_gprs\n-\t\t\t|| GP_SAVE_INLINE (info->first_gp_reg_save));\n-\n-  if (savep)\n-    /* If we are going to use store multiple, then don't even bother\n-     with the out-of-line routines, since the store-multiple instruction\n-     will always be smaller.  */\n-    savres_gprs_inline = savres_gprs_inline || using_multiple_p;\n-  else\n-    {\n-      /* The situation is more complicated with load multiple.  We'd\n-         prefer to use the out-of-line routines for restores, since the\n-         \"exit\" out-of-line routines can handle the restore of LR and\n-         the frame teardown.  But we can only use the out-of-line\n-         routines if we know that we've used store multiple or\n-         out-of-line routines in the prologue, i.e. if we've saved all\n-         the registers from first_gp_reg_save.  Otherwise, we risk\n-         loading garbage from the stack.  Furthermore, we can only use\n-         the \"exit\" out-of-line gpr restore if we haven't saved any\n-         fprs.  */\n-      bool saved_all = !savres_gprs_inline || using_multiple_p;\n-\n-      if (saved_all && info->first_fp_reg_save != 64)\n-\t/* We can't use the exit routine; use load multiple if it's\n-\t   available.  */\n-\tsavres_gprs_inline = savres_gprs_inline || using_multiple_p;\n-    }\n-\n-  strategy = (using_multiple_p\n-\t      | (savres_fprs_inline << 1)\n-\t      | (savres_gprs_inline << 2));\n-#ifdef POWERPC_LINUX\n-  if (TARGET_64BIT)\n-    {\n-      if (!savres_fprs_inline)\n-\tstrategy |= SAVRES_NOINLINE_FPRS_SAVES_LR;\n-      else if (!savres_gprs_inline && info->first_fp_reg_save == 64)\n-\tstrategy |= SAVRES_NOINLINE_GPRS_SAVES_LR;\n-    }\n-#else\n-  if (TARGET_AIX && !savres_fprs_inline)\n-    strategy |= SAVRES_NOINLINE_FPRS_DOESNT_RESTORE_LR;\n-#endif\n-  return strategy;\n-}\n-\n /* Emit function prologue as insns.  */\n \n void\n@@ -19862,12 +19892,10 @@ rs6000_emit_prologue (void)\n       reg_size = 8;\n     }\n \n-  strategy = rs6000_savres_strategy (info, /*savep=*/true,\n-\t\t\t\t     /*static_chain_p=*/using_static_chain_p,\n-\t\t\t\t     /*sibcall=*/0);\n+  strategy = info->savres_strategy;\n   using_store_multiple = strategy & SAVRES_MULTIPLE;\n-  saving_FPRs_inline = strategy & SAVRES_INLINE_FPRS;\n-  saving_GPRs_inline = strategy & SAVRES_INLINE_GPRS;\n+  saving_FPRs_inline = strategy & SAVE_INLINE_FPRS;\n+  saving_GPRs_inline = strategy & SAVE_INLINE_GPRS;\n \n   /* For V.4, update stack before we do any saving and set back pointer.  */\n   if (! WORLD_SAVE_P (info)\n@@ -20037,8 +20065,8 @@ rs6000_emit_prologue (void)\n \t\t\t     gen_rtx_REG (Pmode, LR_REGNO));\n       RTX_FRAME_RELATED_P (insn) = 1;\n \n-      if (!(strategy & (SAVRES_NOINLINE_GPRS_SAVES_LR\n-\t\t\t| SAVRES_NOINLINE_FPRS_SAVES_LR)))\n+      if (!(strategy & (SAVE_NOINLINE_GPRS_SAVES_LR\n+\t\t\t| SAVE_NOINLINE_FPRS_SAVES_LR)))\n \t{\n \t  addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n \t\t\t       GEN_INT (info->lr_save_offset + sp_offset));\n@@ -20098,7 +20126,7 @@ rs6000_emit_prologue (void)\n \t\t\t\t    DFmode,\n \t\t\t\t    /*savep=*/true, /*gpr=*/false,\n \t\t\t\t    /*lr=*/(strategy\n-\t\t\t\t\t    & SAVRES_NOINLINE_FPRS_SAVES_LR)\n+\t\t\t\t\t    & SAVE_NOINLINE_FPRS_SAVES_LR)\n \t\t\t\t\t   != 0);\n       insn = emit_insn (par);\n       rs6000_frame_related (insn, frame_ptr_rtx, info->total_size,\n@@ -20225,7 +20253,7 @@ rs6000_emit_prologue (void)\n \t\t\t\t    reg_mode,\n \t\t\t\t    /*savep=*/true, /*gpr=*/true,\n \t\t\t\t    /*lr=*/(strategy\n-\t\t\t\t\t    & SAVRES_NOINLINE_GPRS_SAVES_LR)\n+\t\t\t\t\t    & SAVE_NOINLINE_GPRS_SAVES_LR)\n \t\t\t\t\t   != 0);\n       insn = emit_insn (par);\n       rs6000_frame_related (insn, frame_ptr_rtx, info->total_size,\n@@ -20533,19 +20561,23 @@ rs6000_output_function_prologue (FILE *file,\n \n   /* Write .extern for any function we will call to save and restore\n      fp values.  */\n-  if (info->first_fp_reg_save < 64\n-      && !FP_SAVE_INLINE (info->first_fp_reg_save))\n+  if (info->first_fp_reg_save < 64)\n     {\n       char *name;\n       int regno = info->first_fp_reg_save - 32;\n \n-      name = rs6000_savres_routine_name (info, regno, /*savep=*/true,\n-\t\t\t\t\t /*gpr=*/false, /*lr=*/false);\n-      fprintf (file, \"\\t.extern %s\\n\", name);\n-\n-      name = rs6000_savres_routine_name (info, regno, /*savep=*/false,\n-\t\t\t\t\t /*gpr=*/false, /*lr=*/true);\n-      fprintf (file, \"\\t.extern %s\\n\", name);\n+      if ((info->savres_strategy & SAVE_INLINE_FPRS) == 0)\n+\t{\n+\t  name = rs6000_savres_routine_name (info, regno, /*savep=*/true,\n+\t\t\t\t\t     /*gpr=*/false, /*lr=*/false);\n+\t  fprintf (file, \"\\t.extern %s\\n\", name);\n+\t}\n+      if ((info->savres_strategy & REST_INLINE_FPRS) == 0)\n+\t{\n+\t  name = rs6000_savres_routine_name (info, regno, /*savep=*/false,\n+\t\t\t\t\t     /*gpr=*/false, /*lr=*/true);\n+\t  fprintf (file, \"\\t.extern %s\\n\", name);\n+\t}\n     }\n \n   /* Write .extern for AIX common mode routines, if needed.  */\n@@ -20691,11 +20723,10 @@ rs6000_emit_epilogue (int sibcall)\n       reg_size = 8;\n     }\n \n-  strategy = rs6000_savres_strategy (info, /*savep=*/false,\n-\t\t\t\t     /*static_chain_p=*/0, sibcall);\n+  strategy = info->savres_strategy;\n   using_load_multiple = strategy & SAVRES_MULTIPLE;\n-  restoring_FPRs_inline = strategy & SAVRES_INLINE_FPRS;\n-  restoring_GPRs_inline = strategy & SAVRES_INLINE_GPRS;\n+  restoring_FPRs_inline = sibcall || (strategy & REST_INLINE_FPRS);\n+  restoring_GPRs_inline = sibcall || (strategy & REST_INLINE_GPRS);\n   using_mtcr_multiple = (rs6000_cpu == PROCESSOR_PPC601\n \t\t\t || rs6000_cpu == PROCESSOR_PPC603\n \t\t\t || rs6000_cpu == PROCESSOR_PPC750\n@@ -20713,7 +20744,7 @@ rs6000_emit_epilogue (int sibcall)\n \t\t\t\t     && !frame_pointer_needed));\n   restore_lr = (info->lr_save_p\n \t\t&& (restoring_FPRs_inline\n-\t\t    || (strategy & SAVRES_NOINLINE_FPRS_DOESNT_RESTORE_LR))\n+\t\t    || (strategy & REST_NOINLINE_FPRS_DOESNT_RESTORE_LR))\n \t\t&& (restoring_GPRs_inline\n \t\t    || info->first_fp_reg_save < 64));\n \n@@ -21352,7 +21383,7 @@ rs6000_emit_epilogue (int sibcall)\n   if (!sibcall)\n     {\n       rtvec p;\n-      bool lr = (strategy & SAVRES_NOINLINE_FPRS_DOESNT_RESTORE_LR) == 0;\n+      bool lr = (strategy & REST_NOINLINE_FPRS_DOESNT_RESTORE_LR) == 0;\n       if (! restoring_FPRs_inline)\n \tp = rtvec_alloc (4 + 64 - info->first_fp_reg_save);\n       else"}]}