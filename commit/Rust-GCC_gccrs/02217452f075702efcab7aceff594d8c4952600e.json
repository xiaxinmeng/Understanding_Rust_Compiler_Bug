{"sha": "02217452f075702efcab7aceff594d8c4952600e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDIyMTc0NTJmMDc1NzAyZWZjYWI3YWNlZmY1OTRkOGM0OTUyNjAwZQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-01-03T10:58:47Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-01-03T10:58:47Z"}, "message": "[multiple changes]\n\n2013-01-03  Thomas Quinot  <quinot@adacore.com>\n\n\t* exp_ch11.adb: Minor reformatting.\n\n2013-01-03  Thomas Quinot  <quinot@adacore.com>\n\n\t* exp_util.adb, einfo.adb, einfo.ads, freeze.adb, exp_aggr.adb,\n\tsem_ch13.adb (Einfo.Initialization_Statements,\n\tEinfo.Set_Initialization_Statements): New entity attribute\n\tfor objects.\n\t(Exp_Util.Find_Init_Call): Handle case of an object initialized\n\tby an aggregate converted to a block of assignment statements.\n\t(Freeze.Check_Address_Clause): Do not clear Has_Delayed_Freeze\n\teven for objects that require a constant address, because the\n\taddress expression might involve entities that have yet to be\n\telaborated at the point of the object declaration.\n\t(Exp_Aggr.Convert_Aggregate_In_Obj_Decl): For a type that does\n\tnot require a transient scope, capture the assignment statements\n\tin a block so that they can be moved down after elaboration of\n\tan address clause if needed.\n\t(Sem_Ch13.Check_Constant_Address_Clause.Check_Expr_Constants,\n\tcase N_Unchecked_Conversion): Do not replace operand subtype with\n\tits base type as this violates a GIGI invariant if the operand\n\tis an identifier (in which case the etype of the identifier\n\tis expected to be equal to that of the denoted entity).\n\n2013-01-03  Javier Miranda  <miranda@adacore.com>\n\n\t* sem_util.ads, sem_util.adb (Denotes_Same_Object): Extend the\n\tfunctionality of this routine to cover cases described in the Ada 2012\n\treference manual.\n\n2013-01-03  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_elab.adb (Set_Elaboration_Constraint): Handle properly\n\ta 'Access attribute reference when the subprogram is called\n\tInitialize.\n\n2013-01-03  Arnaud Charlet  <charlet@adacore.com>\n\n\t* s-tpobop.adb (PO_Do_Or_Queue): Refine assertion, since a\n\tselect statement may be called from a controlled (e.g. Initialize)\n\toperation and have abort always deferred.\n\nFrom-SVN: r194847", "tree": {"sha": "748874df3dc0a3314fe920a2323c47f25ce1db05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/748874df3dc0a3314fe920a2323c47f25ce1db05"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/02217452f075702efcab7aceff594d8c4952600e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02217452f075702efcab7aceff594d8c4952600e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02217452f075702efcab7aceff594d8c4952600e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02217452f075702efcab7aceff594d8c4952600e/comments", "author": null, "committer": null, "parents": [{"sha": "8398e82eccc1a725ed34a9c81be37a7c2bec9bda", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8398e82eccc1a725ed34a9c81be37a7c2bec9bda", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8398e82eccc1a725ed34a9c81be37a7c2bec9bda"}], "stats": {"total": 341, "additions": 265, "deletions": 76}, "files": [{"sha": "a7440cf20c894d03ef40f19e300b26370380c4fd", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02217452f075702efcab7aceff594d8c4952600e/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02217452f075702efcab7aceff594d8c4952600e/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=02217452f075702efcab7aceff594d8c4952600e", "patch": "@@ -1,3 +1,47 @@\n+2013-01-03  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* exp_ch11.adb: Minor reformatting.\n+\n+2013-01-03  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* exp_util.adb, einfo.adb, einfo.ads, freeze.adb, exp_aggr.adb,\n+\tsem_ch13.adb (Einfo.Initialization_Statements,\n+\tEinfo.Set_Initialization_Statements): New entity attribute\n+\tfor objects.\n+\t(Exp_Util.Find_Init_Call): Handle case of an object initialized\n+\tby an aggregate converted to a block of assignment statements.\n+\t(Freeze.Check_Address_Clause): Do not clear Has_Delayed_Freeze\n+\teven for objects that require a constant address, because the\n+\taddress expression might involve entities that have yet to be\n+\telaborated at the point of the object declaration.\n+\t(Exp_Aggr.Convert_Aggregate_In_Obj_Decl): For a type that does\n+\tnot require a transient scope, capture the assignment statements\n+\tin a block so that they can be moved down after elaboration of\n+\tan address clause if needed.\n+\t(Sem_Ch13.Check_Constant_Address_Clause.Check_Expr_Constants,\n+\tcase N_Unchecked_Conversion): Do not replace operand subtype with\n+\tits base type as this violates a GIGI invariant if the operand\n+\tis an identifier (in which case the etype of the identifier\n+\tis expected to be equal to that of the denoted entity).\n+\n+2013-01-03  Javier Miranda  <miranda@adacore.com>\n+\n+\t* sem_util.ads, sem_util.adb (Denotes_Same_Object): Extend the\n+\tfunctionality of this routine to cover cases described in the Ada 2012\n+\treference manual.\n+\n+2013-01-03  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_elab.adb (Set_Elaboration_Constraint): Handle properly\n+\ta 'Access attribute reference when the subprogram is called\n+\tInitialize.\n+\n+2013-01-03  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* s-tpobop.adb (PO_Do_Or_Queue): Refine assertion, since a\n+\tselect statement may be called from a controlled (e.g. Initialize)\n+\toperation and have abort always deferred.\n+\n 2013-01-03  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_ch8.adb, einfo.ads, einfo.adb: Minor code reorganization."}, {"sha": "3eb514404f5b9aa2d4e2a5306a676c3457b8bdf5", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02217452f075702efcab7aceff594d8c4952600e/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02217452f075702efcab7aceff594d8c4952600e/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=02217452f075702efcab7aceff594d8c4952600e", "patch": "@@ -237,6 +237,7 @@ package body Einfo is\n    --    Wrapped_Entity                  Node27\n \n    --    Extra_Formals                   Node28\n+   --    Initialization_Statements       Node28\n    --    Underlying_Record_View          Node28\n \n    --    Subprograms_For_Type            Node29\n@@ -1655,6 +1656,12 @@ package body Einfo is\n       return Flag8 (Id);\n    end In_Use;\n \n+   function Initialization_Statements (Id : E) return N is\n+   begin\n+      pragma Assert (Ekind_In (Id, E_Constant, E_Variable));\n+      return Node28 (Id);\n+   end Initialization_Statements;\n+\n    function Inner_Instances (Id : E) return L is\n    begin\n       return Elist23 (Id);\n@@ -4187,6 +4194,12 @@ package body Einfo is\n       Set_Flag8 (Id, V);\n    end Set_In_Use;\n \n+   procedure Set_Initialization_Statements (Id : E; V : N) is\n+   begin\n+      pragma Assert (Ekind_In (Id, E_Constant, E_Variable));\n+      Set_Node28 (Id, V);\n+   end Set_Initialization_Statements;\n+\n    procedure Set_Inner_Instances (Id : E; V : L) is\n    begin\n       Set_Elist23 (Id, V);\n@@ -8702,6 +8715,9 @@ package body Einfo is\n               E_Subprogram_Type                            =>\n             Write_Str (\"Extra_Formals\");\n \n+         when E_Constant | E_Variable =>\n+            Write_Str (\"Initialization_Statements\");\n+\n          when E_Record_Type =>\n             Write_Str (\"Underlying_Record_View\");\n "}, {"sha": "55acb34dedeeecbc104c854cebdaf9d91586eb88", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02217452f075702efcab7aceff594d8c4952600e/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02217452f075702efcab7aceff594d8c4952600e/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=02217452f075702efcab7aceff594d8c4952600e", "patch": "@@ -1932,6 +1932,12 @@ package Einfo is\n --       the end of the package declaration. For objects it indicates that the\n --       declaration of the object occurs in the private part of a package.\n \n+--    Initialization_Statements (Node28)\n+--       Defined in constants and variables. For a composite object initialized\n+--       initialized with an aggregate that has been converted to a sequence\n+--       of assignments, points to a block statement containing the\n+--       assignments.\n+\n --    Inner_Instances (Elist23)\n --       Defined in generic units. Contains element list of units that are\n --       instantiated within the given generic. Used to diagnose circular\n@@ -5104,6 +5110,7 @@ package Einfo is\n    --    Prival_Link                         (Node20)   (privals only)\n    --    Interface_Name                      (Node21)   (constants only)\n    --    Related_Type                        (Node27)   (constants only)\n+   --    Initialization_Statements           (Node28)\n    --    Has_Alignment_Clause                (Flag46)\n    --    Has_Atomic_Components               (Flag86)\n    --    Has_Biased_Representation           (Flag139)\n@@ -5773,6 +5780,7 @@ package Einfo is\n    --    Debug_Renaming_Link                 (Node25)\n    --    Last_Assignment                     (Node26)\n    --    Related_Type                        (Node27)\n+   --    Initialization_Statements           (Node28)\n    --    Has_Alignment_Clause                (Flag46)\n    --    Has_Atomic_Components               (Flag86)\n    --    Has_Biased_Representation           (Flag139)\n@@ -6217,6 +6225,7 @@ package Einfo is\n    function In_Package_Body                     (Id : E) return B;\n    function In_Private_Part                     (Id : E) return B;\n    function In_Use                              (Id : E) return B;\n+   function Initialization_Statements           (Id : E) return N;\n    function Inner_Instances                     (Id : E) return L;\n    function Interface_Alias                     (Id : E) return E;\n    function Interface_Name                      (Id : E) return N;\n@@ -6809,6 +6818,7 @@ package Einfo is\n    procedure Set_In_Package_Body                 (Id : E; V : B := True);\n    procedure Set_In_Private_Part                 (Id : E; V : B := True);\n    procedure Set_In_Use                          (Id : E; V : B := True);\n+   procedure Set_Initialization_Statements       (Id : E; V : N);\n    procedure Set_Inner_Instances                 (Id : E; V : L);\n    procedure Set_Interface_Alias                 (Id : E; V : E);\n    procedure Set_Interface_Name                  (Id : E; V : N);"}, {"sha": "0f8f187cd3428e5cff20955a6f95346eff0ea4ae", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02217452f075702efcab7aceff594d8c4952600e/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02217452f075702efcab7aceff594d8c4952600e/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=02217452f075702efcab7aceff594d8c4952600e", "patch": "@@ -3012,6 +3012,8 @@ package body Exp_Aggr is\n       Loc  : constant Source_Ptr := Sloc (Aggr);\n       Typ  : constant Entity_Id  := Etype (Aggr);\n       Occ  : constant Node_Id    := New_Occurrence_Of (Obj, Loc);\n+      Blk  : Node_Id             := Empty;\n+      Ins  : Node_Id;\n \n       function Discriminants_Ok return Boolean;\n       --  If the object type is constrained, the discriminants in the\n@@ -3116,9 +3118,27 @@ package body Exp_Aggr is\n            (Aggr,\n             Sec_Stack =>\n               Is_Controlled (Typ) or else Has_Controlled_Component (Typ));\n+         Ins := N;\n+\n+         --  Need to Set_Initialization_Statements??? (see below)\n+\n+      else\n+         --  Capture initialization statements within an identified block\n+         --  statement, as we might need to move them to the freeze actions\n+         --  of Obj later on if a representation clause (such as an address\n+         --  clause) makes it necessary to delay freezing.\n+\n+         Ins := Make_Null_Statement (Loc);\n+         Blk := Make_Block_Statement (Loc,\n+                  Declarations               => New_List,\n+                  Handled_Statement_Sequence =>\n+                    Make_Handled_Sequence_Of_Statements (Loc,\n+                      Statements => New_List (Ins)));\n+         Insert_Action_After (N, Blk);\n+         Set_Initialization_Statements (Obj, Blk);\n       end if;\n \n-      Insert_Actions_After (N, Late_Expansion (Aggr, Typ, Occ));\n+      Insert_Actions_After (Ins, Late_Expansion (Aggr, Typ, Occ));\n       Set_No_Initialization (N);\n       Initialize_Discriminants (N, Typ);\n    end Convert_Aggr_In_Object_Decl;"}, {"sha": "64a53e36cda6493d21fb02595dc6957ea980f978", "filename": "gcc/ada/exp_ch11.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02217452f075702efcab7aceff594d8c4952600e/gcc%2Fada%2Fexp_ch11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02217452f075702efcab7aceff594d8c4952600e/gcc%2Fada%2Fexp_ch11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch11.adb?ref=02217452f075702efcab7aceff594d8c4952600e", "patch": "@@ -1832,7 +1832,7 @@ package body Exp_Ch11 is\n \n       Rewrite (N,\n         Make_Attribute_Reference (Loc,\n-          Prefix => Identifier (N),\n+          Prefix         => Identifier (N),\n           Attribute_Name => Name_Code_Address));\n \n       Analyze_And_Resolve (N, RTE (RE_Code_Loc));"}, {"sha": "2ee01133c8d5c9dd2bdf8416ae53adfe922b7a82", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02217452f075702efcab7aceff594d8c4952600e/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02217452f075702efcab7aceff594d8c4952600e/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=02217452f075702efcab7aceff594d8c4952600e", "patch": "@@ -2206,13 +2206,20 @@ package body Exp_Util is\n    --  Start of processing for Find_Init_Call\n \n    begin\n-      if not Has_Non_Null_Base_Init_Proc (Typ) then\n+      if Present (Initialization_Statements (Var)) then\n+         return Initialization_Statements (Var);\n+\n+      elsif not Has_Non_Null_Base_Init_Proc (Typ) then\n \n          --  No init proc for the type, so obviously no call to be found\n \n          return Empty;\n       end if;\n \n+      --  We might be able to handle other cases below by just properly setting\n+      --  Initialization_Statements at the point where the init proc call is\n+      --  generated???\n+\n       Init_Proc := Base_Init_Proc (Typ);\n \n       --  First scan the list containing the declaration of Var"}, {"sha": "291a9f3bedf04586548771ceb2a92d13471fb899", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02217452f075702efcab7aceff594d8c4952600e/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02217452f075702efcab7aceff594d8c4952600e/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=02217452f075702efcab7aceff594d8c4952600e", "patch": "@@ -562,12 +562,9 @@ package body Freeze is\n             Check_Constant_Address_Clause (Expr, E);\n \n             --  Has_Delayed_Freeze was set on E when the address clause was\n-            --  analyzed. Reset the flag now unless freeze actions were\n-            --  attached to it in the mean time.\n-\n-            if No (Freeze_Node (E)) then\n-               Set_Has_Delayed_Freeze (E, False);\n-            end if;\n+            --  analyzed, and must remain set because we want the address\n+            --  clause to be elaborated only after any entity it references\n+            --  has been elaborated.\n          end if;\n \n          --  If Rep_Clauses are to be ignored, remove address clause from"}, {"sha": "aaf18208e59e11bf2e8ff2dde267d7d38aa8ec6f", "filename": "gcc/ada/s-tpobop.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02217452f075702efcab7aceff594d8c4952600e/gcc%2Fada%2Fs-tpobop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02217452f075702efcab7aceff594d8c4952600e/gcc%2Fada%2Fs-tpobop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tpobop.adb?ref=02217452f075702efcab7aceff594d8c4952600e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1998-2011, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1998-2012, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -379,7 +379,7 @@ package body System.Tasking.Protected_Objects.Operations is\n          end if;\n \n          STPO.Write_Lock (Entry_Call.Self);\n-         pragma Assert (Entry_Call.State >= Was_Abortable);\n+         pragma Assert (Entry_Call.State /= Not_Yet_Abortable);\n          Initialization.Wakeup_Entry_Caller (Self_ID, Entry_Call, Cancelled);\n          STPO.Unlock (Entry_Call.Self);\n "}, {"sha": "548656f9574fa0ecb37d6aa9a264e35eb5362f34", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 5, "deletions": 21, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02217452f075702efcab7aceff594d8c4952600e/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02217452f075702efcab7aceff594d8c4952600e/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=02217452f075702efcab7aceff594d8c4952600e", "patch": "@@ -2880,7 +2880,9 @@ package body Sem_Ch13 is\n                   --  Legality checks on the address clause for initialized\n                   --  objects is deferred until the freeze point, because\n                   --  a subsequent pragma might indicate that the object\n-                  --  is imported and thus not initialized.\n+                  --  is imported and thus not initialized. Also, the address\n+                  --  clause might involve entities that have yet to be\n+                  --  elaborated.\n \n                   Set_Has_Delayed_Freeze (U_Ent);\n \n@@ -7216,28 +7218,10 @@ package body Sem_Ch13 is\n \n             when N_Type_Conversion           |\n                  N_Qualified_Expression      |\n-                 N_Allocator                 =>\n+                 N_Allocator                 |\n+                 N_Unchecked_Type_Conversion =>\n                Check_Expr_Constants (Expression (Nod));\n \n-            when N_Unchecked_Type_Conversion =>\n-               Check_Expr_Constants (Expression (Nod));\n-\n-               --  If this is a rewritten unchecked conversion, subtypes in\n-               --  this node are those created within the instance. To avoid\n-               --  order of elaboration issues, replace them with their base\n-               --  types. Note that address clauses can cause order of\n-               --  elaboration problems because they are elaborated by the\n-               --  back-end at the point of definition, and may mention\n-               --  entities declared in between (as long as everything is\n-               --  static). It is user-friendly to allow unchecked conversions\n-               --  in this context.\n-\n-               if Nkind (Original_Node (Nod)) = N_Function_Call then\n-                  Set_Etype (Expression (Nod),\n-                    Base_Type (Etype (Expression (Nod))));\n-                  Set_Etype (Nod, Base_Type (Etype (Nod)));\n-               end if;\n-\n             when N_Function_Call =>\n                if not Is_Pure (Entity (Name (Nod))) then\n                   Error_Msg_NE"}, {"sha": "1c897c8147f234b58928be726bf28fed8ae793b1", "filename": "gcc/ada/sem_elab.adb", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02217452f075702efcab7aceff594d8c4952600e/gcc%2Fada%2Fsem_elab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02217452f075702efcab7aceff594d8c4952600e/gcc%2Fada%2Fsem_elab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.adb?ref=02217452f075702efcab7aceff594d8c4952600e", "patch": "@@ -2541,8 +2541,14 @@ package body Sem_Elab is\n      Scop : Entity_Id)\n    is\n       Elab_Unit  : Entity_Id;\n+\n+      --  Check whether this is a call to an Initialize subprogram for a\n+      --  controlled type. Note that Call can also be a 'access attribute\n+      --  reference, which now generates an elaboration check.\n+\n       Init_Call  : constant Boolean :=\n-                     Chars (Subp) = Name_Initialize\n+                     Nkind (Call) = N_Procedure_Call_Statement\n+                       and then Chars (Subp) = Name_Initialize\n                        and then Comes_From_Source (Subp)\n                        and then Present (Parameter_Associations (Call))\n                        and then Is_Controlled (Etype (First_Actual (Call)));"}, {"sha": "907efe4c1e6d23a2304e4a261fa70fd5ef83c7a0", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 145, "deletions": 43, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02217452f075702efcab7aceff594d8c4952600e/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02217452f075702efcab7aceff594d8c4952600e/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=02217452f075702efcab7aceff594d8c4952600e", "patch": "@@ -2814,87 +2814,188 @@ package body Sem_Util is\n       Obj1 : Node_Id := A1;\n       Obj2 : Node_Id := A2;\n \n-      procedure Check_Renaming (Obj : in out Node_Id);\n-      --  If an object is a renaming, examine renamed object. If it is a\n-      --  dereference of a variable, or an indexed expression with non-constant\n-      --  indexes, no overlap check can be reported.\n+      function Has_Prefix (N : Node_Id) return Boolean;\n+      --  Return True if N has attribute Prefix\n \n-      --------------------\n-      -- Check_Renaming --\n-      --------------------\n+      function Is_Renaming (N : Node_Id) return Boolean;\n+      --  Return true if N names a renaming entity\n+\n+      function Is_Valid_Renaming (N : Node_Id) return Boolean;\n+      --  For renamings, return False if the prefix of any dereference within\n+      --  the renamed object_name is a variable, or any expression within the\n+      --  renamed object_name contains references to variables or calls on\n+      --  nonstatic functions; otherwise return True (RM 6.4.1(6.10/3))\n \n-      procedure Check_Renaming (Obj : in out Node_Id) is\n+      ----------------\n+      -- Has_Prefix --\n+      ----------------\n+\n+      function Has_Prefix (N : Node_Id) return Boolean is\n       begin\n-         if Is_Entity_Name (Obj)\n-           and then Present (Renamed_Entity (Entity (Obj)))\n-         then\n-            Obj := Renamed_Entity (Entity (Obj));\n-            if Nkind (Obj) = N_Explicit_Dereference\n-              and then Is_Variable (Prefix (Obj))\n+         return\n+           Nkind_In (N,\n+             N_Attribute_Reference,\n+             N_Expanded_Name,\n+             N_Explicit_Dereference,\n+             N_Indexed_Component,\n+             N_Reference,\n+             N_Selected_Component,\n+             N_Slice);\n+      end Has_Prefix;\n+\n+      -----------------\n+      -- Is_Renaming --\n+      -----------------\n+\n+      function Is_Renaming (N : Node_Id) return Boolean is\n+      begin\n+         return Is_Entity_Name (N)\n+           and then Present (Renamed_Entity (Entity (N)));\n+      end Is_Renaming;\n+\n+      -----------------------\n+      -- Is_Valid_Renaming --\n+      -----------------------\n+\n+      function Is_Valid_Renaming (N : Node_Id) return Boolean is\n+\n+         function Check_Renaming (N : Node_Id) return Boolean;\n+         --  Recursive function used to traverse all the prefixes of N\n+\n+         function Check_Renaming (N : Node_Id) return Boolean is\n+         begin\n+            if Is_Renaming (N)\n+              and then not Check_Renaming (Renamed_Entity (Entity (N)))\n             then\n-               Obj := Empty;\n+               return False;\n+            end if;\n \n-            elsif Nkind (Obj) = N_Indexed_Component then\n+            if Nkind (N) = N_Indexed_Component then\n                declare\n                   Indx : Node_Id;\n \n                begin\n-                  Indx := First (Expressions (Obj));\n+                  Indx := First (Expressions (N));\n                   while Present (Indx) loop\n                      if not Is_OK_Static_Expression (Indx) then\n-                        Obj := Empty;\n-                        exit;\n+                        return False;\n                      end if;\n \n                      Next_Index (Indx);\n                   end loop;\n                end;\n             end if;\n-         end if;\n-      end Check_Renaming;\n+\n+            if Has_Prefix (N) then\n+               declare\n+                  P : constant Node_Id := Prefix (N);\n+\n+               begin\n+                  if Nkind (N) = N_Explicit_Dereference\n+                    and then Is_Variable (P)\n+                  then\n+                     return False;\n+\n+                  elsif Is_Entity_Name (P)\n+                    and then Ekind (Entity (P)) = E_Function\n+                  then\n+                     return False;\n+\n+                  elsif Nkind (P) = N_Function_Call then\n+                     return False;\n+                  end if;\n+\n+                  --  Recursion to continue traversing the prefix of the\n+                  --  renaming expression\n+\n+                  return Check_Renaming (P);\n+               end;\n+            end if;\n+\n+            return True;\n+         end Check_Renaming;\n+\n+      --  Start of processing for Is_Valid_Renaming\n+\n+      begin\n+         return Check_Renaming (N);\n+      end Is_Valid_Renaming;\n \n    --  Start of processing for Denotes_Same_Object\n \n    begin\n-      Check_Renaming (Obj1);\n-      Check_Renaming (Obj2);\n+      --  Both names statically denote the same stand-alone object or parameter\n+      --  (RM 6.4.1(6.5/3))\n \n-      if No (Obj1)\n-        or else No (Obj2)\n+      if Is_Entity_Name (Obj1)\n+        and then Is_Entity_Name (Obj2)\n+        and then Entity (Obj1) = Entity (Obj2)\n       then\n-         return False;\n+         return True;\n       end if;\n \n-      --  If we have entity names, then must be same entity\n+      --  For renamings, the prefix of any dereference within the renamed\n+      --  object_name is not a variable, and any expression within the\n+      --  renamed object_name contains no references to variables nor\n+      --  calls on nonstatic functions (RM 6.4.1(6.10/3)).\n \n-      if Is_Entity_Name (Obj1) then\n-         if Is_Entity_Name (Obj2) then\n-            return Entity (Obj1) = Entity (Obj2);\n+      if Is_Renaming (Obj1) then\n+         if Is_Valid_Renaming (Obj1) then\n+            Obj1 := Renamed_Entity (Entity (Obj1));\n          else\n             return False;\n          end if;\n+      end if;\n \n-      --  No match if not same node kind\n+      if Is_Renaming (Obj2) then\n+         if Is_Valid_Renaming (Obj2) then\n+            Obj2 := Renamed_Entity (Entity (Obj2));\n+         else\n+            return False;\n+         end if;\n+      end if;\n+\n+      --  No match if not same node kind (such cases are handled by\n+      --  Denotes_Same_Prefix)\n \n-      elsif Nkind (Obj1) /= Nkind (Obj2) then\n+      if Nkind (Obj1) /= Nkind (Obj2) then\n          return False;\n \n-      --  For selected components, must have same prefix and selector\n+      --  After handling valid renamings, one of the two names statically\n+      --  denoted a renaming declaration whose renamed object_name is known\n+      --  to denote the same object as the other (RM 6.4.1(6.10/3))\n+\n+      elsif Is_Entity_Name (Obj1) then\n+         if Is_Entity_Name (Obj2) then\n+            return Entity (Obj1) = Entity (Obj2);\n+         else\n+            return False;\n+         end if;\n+\n+      --  Both names are selected_components, their prefixes are known to\n+      --  denote the same object, and their selector_names denote the same\n+      --  component (RM 6.4.1(6.6/3)\n \n       elsif Nkind (Obj1) = N_Selected_Component then\n          return Denotes_Same_Object (Prefix (Obj1), Prefix (Obj2))\n            and then\n          Entity (Selector_Name (Obj1)) = Entity (Selector_Name (Obj2));\n \n-      --  For explicit dereferences, prefixes must be same\n+      --  Both names are dereferences and the dereferenced names are known to\n+      --  denote the same object (RM 6.4.1(6.7/3))\n \n       elsif Nkind (Obj1) = N_Explicit_Dereference then\n          return Denotes_Same_Object (Prefix (Obj1), Prefix (Obj2));\n \n-      --  For indexed components, prefixes and all subscripts must be the same\n+      --  Both names are indexed_components, their prefixes are known to denote\n+      --  the same object, and each of the pairs of corresponding index values\n+      --  are either both static expressions with the same static value or both\n+      --  names that are known to denote the same object (RM 6.4.1(6.8/3))\n \n       elsif Nkind (Obj1) = N_Indexed_Component then\n-         if Denotes_Same_Object (Prefix (Obj1), Prefix (Obj2)) then\n+         if not Denotes_Same_Object (Prefix (Obj1), Prefix (Obj2)) then\n+            return False;\n+         else\n             declare\n                Indx1 : Node_Id;\n                Indx2 : Node_Id;\n@@ -2924,11 +3025,11 @@ package body Sem_Util is\n \n                return True;\n             end;\n-         else\n-            return False;\n          end if;\n \n-      --  For slices, prefixes must match and bounds must match\n+      --  Both names are slices, their prefixes are known to denote the same\n+      --  object, and the two slices have statically matching index constraints\n+      --  (RM 6.4.1(6.9/3))\n \n       elsif Nkind (Obj1) = N_Slice\n         and then Denotes_Same_Object (Prefix (Obj1), Prefix (Obj2))\n@@ -2947,10 +3048,11 @@ package body Sem_Util is\n               and then Denotes_Same_Object (Hi1, Hi2);\n          end;\n \n-         --  Literals will appear as indexes. Isn't this where we should check\n-         --  Known_At_Compile_Time at least if we are generating warnings ???\n+      --  In the recursion, literals appear as indexes.\n \n-      elsif Nkind (Obj1) = N_Integer_Literal then\n+      elsif Nkind (Obj1) = N_Integer_Literal\n+        and then Nkind (Obj2) = N_Integer_Literal\n+      then\n          return Intval (Obj1) = Intval (Obj2);\n \n       else\n@@ -3014,7 +3116,7 @@ package body Sem_Util is\n             end loop;\n \n             --  If both have the same depth and they do not denote the same\n-            --  object, they are disjoint and not warning is needed.\n+            --  object, they are disjoint and no warning is needed.\n \n             if Depth1 = Depth2 then\n                return False;"}, {"sha": "7c8d80357fd2e2d7441fbf1c7e1ce27e7e74a545", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02217452f075702efcab7aceff594d8c4952600e/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02217452f075702efcab7aceff594d8c4952600e/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=02217452f075702efcab7aceff594d8c4952600e", "patch": "@@ -360,6 +360,9 @@ package Sem_Util is\n    --  and constraint checks on entry families constrained by discriminants.\n \n    function Denotes_Same_Object (A1, A2 : Node_Id) return Boolean;\n+   --  Detect suspicious overlapping between actuals in a call, when both are\n+   --  writable (RM 2012 6.4.1(6.4/3))\n+\n    function Denotes_Same_Prefix (A1, A2 : Node_Id) return Boolean;\n    --  Functions to detect suspicious overlapping between actuals in a call,\n    --  when one of them is writable. The predicates are those proposed in"}]}