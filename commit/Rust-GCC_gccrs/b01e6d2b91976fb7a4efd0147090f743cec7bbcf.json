{"sha": "b01e6d2b91976fb7a4efd0147090f743cec7bbcf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjAxZTZkMmI5MTk3NmZiN2E0ZWZkMDE0NzA5MGY3NDNjZWM3YmJjZg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2006-09-06T01:15:09Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2006-09-06T01:15:09Z"}, "message": "re PR c++/26102 (\"using Base::member\" nonsense)\n\n        PR c++/26102\n        * name-lookup.c (do_class_using_decl): Try to find the base even\n        if bases_dependent_p.\n        * pt.c (type_dependent_expression_p): A USING_DECL is dependent.\n\n        PR c++/19809\n        * pt.c (tsubst_friend_function): Set DECL_INITIAL before pushdecl.\n\nFrom-SVN: r116709", "tree": {"sha": "fc0bf5d8a95f07ff8fe2c9161eeb3812c9ecbd7b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fc0bf5d8a95f07ff8fe2c9161eeb3812c9ecbd7b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b01e6d2b91976fb7a4efd0147090f743cec7bbcf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b01e6d2b91976fb7a4efd0147090f743cec7bbcf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b01e6d2b91976fb7a4efd0147090f743cec7bbcf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b01e6d2b91976fb7a4efd0147090f743cec7bbcf/comments", "author": null, "committer": null, "parents": [{"sha": "6dd0d2f48454187c94e2b14cc7eaf99ced15a94d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6dd0d2f48454187c94e2b14cc7eaf99ced15a94d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6dd0d2f48454187c94e2b14cc7eaf99ced15a94d"}], "stats": {"total": 52, "additions": 45, "deletions": 7}, "files": [{"sha": "3016bb0ad560b4015a24381d0a019865eea72279", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b01e6d2b91976fb7a4efd0147090f743cec7bbcf/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b01e6d2b91976fb7a4efd0147090f743cec7bbcf/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=b01e6d2b91976fb7a4efd0147090f743cec7bbcf", "patch": "@@ -2824,18 +2824,19 @@ do_class_using_decl (tree scope, tree name)\n      class type.  However, if all of the base classes are\n      non-dependent, then we can avoid delaying the check until\n      instantiation.  */\n-  if (!scope_dependent_p && !bases_dependent_p)\n+  if (!scope_dependent_p)\n     {\n       base_kind b_kind;\n-      tree binfo;\n       binfo = lookup_base (current_class_type, scope, ba_any, &b_kind);\n       if (b_kind < bk_proper_base)\n \t{\n-\t  error_not_base_type (scope, current_class_type);\n-\t  return NULL_TREE;\n+\t  if (!bases_dependent_p)\n+\t    {\n+\t      error_not_base_type (scope, current_class_type);\n+\t      return NULL_TREE;\n+\t    }\n \t}\n-\n-      if (!name_dependent_p)\n+      else if (!name_dependent_p)\n \t{\n \t  decl = lookup_member (binfo, name, 0, false);\n \t  if (!decl)"}, {"sha": "d278b00448ee07d8d97bcefeaef89bf947f10945", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b01e6d2b91976fb7a4efd0147090f743cec7bbcf/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b01e6d2b91976fb7a4efd0147090f743cec7bbcf/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=b01e6d2b91976fb7a4efd0147090f743cec7bbcf", "patch": "@@ -5333,6 +5333,10 @@ tsubst_friend_function (tree decl, tree args)\n       else\n \tnew_friend_result_template_info = NULL_TREE;\n \n+      /* Make the init_value nonzero so pushdecl knows this is a defn.  */\n+      if (new_friend_is_defn)\n+\tDECL_INITIAL (new_friend) = error_mark_node;\n+\n       /* Inside pushdecl_namespace_level, we will push into the\n \t current namespace. However, the friend function should go\n \t into the namespace of the template.  */\n@@ -12862,7 +12866,8 @@ type_dependent_expression_p (tree expression)\n     return false;\n \n   /* An unresolved name is always dependent.  */\n-  if (TREE_CODE (expression) == IDENTIFIER_NODE)\n+  if (TREE_CODE (expression) == IDENTIFIER_NODE\n+      || TREE_CODE (expression) == USING_DECL)\n     return true;\n \n   /* Some expression forms are never type-dependent.  */"}, {"sha": "612173950a7eaccf2736c01b2ec841df2f33ac83", "filename": "gcc/testsuite/g++.dg/template/friend47.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b01e6d2b91976fb7a4efd0147090f743cec7bbcf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ffriend47.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b01e6d2b91976fb7a4efd0147090f743cec7bbcf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ffriend47.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ffriend47.C?ref=b01e6d2b91976fb7a4efd0147090f743cec7bbcf", "patch": "@@ -0,0 +1,11 @@\n+// PR c++/19809\n+\n+template<int i>\n+struct n{\n+  friend void foo(){ }\t\t// { dg-error \"defin\" }\n+};\n+\n+int main(){\n+  n<1> n1;\n+  n<2> n2;\n+}"}, {"sha": "d104948773257424eabe18586db1f7a1773fba65", "filename": "gcc/testsuite/g++.dg/template/using14.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b01e6d2b91976fb7a4efd0147090f743cec7bbcf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fusing14.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b01e6d2b91976fb7a4efd0147090f743cec7bbcf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fusing14.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fusing14.C?ref=b01e6d2b91976fb7a4efd0147090f743cec7bbcf", "patch": "@@ -0,0 +1,21 @@\n+// PR c++/26102\n+\n+template <class T> struct B1 { int i(); };\n+\n+struct B2 { int i(); };\n+\n+template <class T> struct C : public B1<T>, public B2\n+{\n+  using B2::i;\n+  void f()\n+  {\n+    i();\t\t\t// should be accepted\n+    i.i();\t\t\t// { dg-error \"\" }\n+  }\n+};\n+\n+int main()\n+{\n+  C<int> c;\n+  c.f();\t\t\t// { dg-error \"instantiated\" }\n+}"}]}