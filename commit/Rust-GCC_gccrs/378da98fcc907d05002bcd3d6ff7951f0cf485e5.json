{"sha": "378da98fcc907d05002bcd3d6ff7951f0cf485e5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzc4ZGE5OGZjYzkwN2QwNTAwMmJjZDNkNmZmNzk1MWYwY2Y0ODVlNQ==", "commit": {"author": {"name": "Julian Brown", "email": "julian@codesourcery.com", "date": "2019-12-20T01:20:16Z"}, "committer": {"name": "Julian Brown", "email": "jules@gcc.gnu.org", "date": "2019-12-20T01:20:16Z"}, "message": "OpenACC reference count overhaul\n\n\tlibgomp/\n\t* libgomp.h (struct splay_tree_key_s): Substitute dynamic_refcount\n\tfield for virtual_refcount.\n\t(enum gomp_map_vars_kind): Add GOMP_MAP_VARS_OPENACC_ENTER_DATA.\n\t(gomp_free_memmap): Remove prototype.\n\t* oacc-init.c (acc_shutdown_1): Iteratively call gomp_remove_var\n\tinstead of calling gomp_free_memmap.\n\t* oacc-mem.c (acc_map_data): Use virtual_refcount instead of\n\tdynamic_refcount.\n\t(acc_unmap_data): Open code instead of forcing target_mem_desc's\n\tto_free field to NULL then calling gomp_unmap_vars.  Handle\n\tREFCOUNT_INFINITY on target blocks.\n\t(goacc_enter_data): Rename to...\n\t(goacc_enter_datum): ...this.  Remove MAPNUM parameter and special\n\thandling for mapping groups.  Use virtual_refcount instead of\n\tdynamic_refcount.  Use GOMP_MAP_VARS_OPENACC_ENTER_DATA for\n\tmap_map_vars_async call.  Re-do lookup for target pointer return value.\n\t(acc_create, acc_create_async, acc_copyin, acc_copyin_async): Call\n\trenamed goacc_enter_datum function.\n\t(goacc_exit_data): Rename to...\n\t(goacc_exit_datum): ...this.  Update for virtual_refcount semantics.\n\t(acc_delete, acc_delete_async, acc_delete_finalize,\n\tacc_delete_finalize_async, acc_copyout, acc_copyout_async,\n\tacc_copyout_finalize, acc_copyout_finalize_async): Call renamed\n\tgoacc_exit_datum function.\n\t(gomp_acc_remove_pointer, find_pointer): Remove functions.\n\t(find_group_last, goacc_enter_data_internal, goacc_exit_data_internal):\n\tNew functions.\n\t(GOACC_enter_exit_data): Use goacc_enter_data_internal and\n\tgoacc_exit_data_internal helper functions.\n\t* target.c (gomp_map_vars_internal): Handle\n\tGOMP_MAP_VARS_OPENACC_ENTER_DATA.  Update for virtual_refcount\n\tsemantics.\n\t(gomp_unmap_vars_internal): Update for virtual_refcount semantics.\n\t(gomp_load_image_to_device, omp_target_associate_ptr): Zero-initialise\n\tvirtual_refcount field instead of dynamic_refcount.\n\t(gomp_free_memmap): Remove function.\n\t* testsuite/libgomp.oacc-c-c++-common/unmap-infinity-1.c: New test.\n\t* testsuite/libgomp.c-c++-common/unmap-infinity-2.c: New test.\n\t* testsuite/libgomp.oacc-c-c++-common/pr92843-1.c: Add XFAIL.\n\nFrom-SVN: r279621", "tree": {"sha": "34594f4141deedb06cce4ba795d40708665a9ac4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/34594f4141deedb06cce4ba795d40708665a9ac4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/378da98fcc907d05002bcd3d6ff7951f0cf485e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/378da98fcc907d05002bcd3d6ff7951f0cf485e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/378da98fcc907d05002bcd3d6ff7951f0cf485e5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/378da98fcc907d05002bcd3d6ff7951f0cf485e5/comments", "author": {"login": "jtb20", "id": 6094880, "node_id": "MDQ6VXNlcjYwOTQ4ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/6094880?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jtb20", "html_url": "https://github.com/jtb20", "followers_url": "https://api.github.com/users/jtb20/followers", "following_url": "https://api.github.com/users/jtb20/following{/other_user}", "gists_url": "https://api.github.com/users/jtb20/gists{/gist_id}", "starred_url": "https://api.github.com/users/jtb20/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jtb20/subscriptions", "organizations_url": "https://api.github.com/users/jtb20/orgs", "repos_url": "https://api.github.com/users/jtb20/repos", "events_url": "https://api.github.com/users/jtb20/events{/privacy}", "received_events_url": "https://api.github.com/users/jtb20/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2a656a93597d9ba2444cf5f4b2954734c97fe06d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a656a93597d9ba2444cf5f4b2954734c97fe06d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a656a93597d9ba2444cf5f4b2954734c97fe06d"}], "stats": {"total": 599, "additions": 301, "deletions": 298}, "files": [{"sha": "c08d7b0c457cd19dba528939fbfd3aaf648a37e9", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/378da98fcc907d05002bcd3d6ff7951f0cf485e5/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/378da98fcc907d05002bcd3d6ff7951f0cf485e5/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=378da98fcc907d05002bcd3d6ff7951f0cf485e5", "patch": "@@ -1,3 +1,45 @@\n+2019-12-19  Julian Brown  <julian@codesourcery.com>\n+\n+\t* libgomp.h (struct splay_tree_key_s): Substitute dynamic_refcount\n+\tfield for virtual_refcount.\n+\t(enum gomp_map_vars_kind): Add GOMP_MAP_VARS_OPENACC_ENTER_DATA.\n+\t(gomp_free_memmap): Remove prototype.\n+\t* oacc-init.c (acc_shutdown_1): Iteratively call gomp_remove_var\n+\tinstead of calling gomp_free_memmap.\n+\t* oacc-mem.c (acc_map_data): Use virtual_refcount instead of\n+\tdynamic_refcount.\n+\t(acc_unmap_data): Open code instead of forcing target_mem_desc's\n+\tto_free field to NULL then calling gomp_unmap_vars.  Handle\n+\tREFCOUNT_INFINITY on target blocks.\n+\t(goacc_enter_data): Rename to...\n+\t(goacc_enter_datum): ...this.  Remove MAPNUM parameter and special\n+\thandling for mapping groups.  Use virtual_refcount instead of\n+\tdynamic_refcount.  Use GOMP_MAP_VARS_OPENACC_ENTER_DATA for\n+\tmap_map_vars_async call.  Re-do lookup for target pointer return value.\n+\t(acc_create, acc_create_async, acc_copyin, acc_copyin_async): Call\n+\trenamed goacc_enter_datum function.\n+\t(goacc_exit_data): Rename to...\n+\t(goacc_exit_datum): ...this.  Update for virtual_refcount semantics.\n+\t(acc_delete, acc_delete_async, acc_delete_finalize,\n+\tacc_delete_finalize_async, acc_copyout, acc_copyout_async,\n+\tacc_copyout_finalize, acc_copyout_finalize_async): Call renamed\n+\tgoacc_exit_datum function.\n+\t(gomp_acc_remove_pointer, find_pointer): Remove functions.\n+\t(find_group_last, goacc_enter_data_internal, goacc_exit_data_internal):\n+\tNew functions.\n+\t(GOACC_enter_exit_data): Use goacc_enter_data_internal and\n+\tgoacc_exit_data_internal helper functions.\n+\t* target.c (gomp_map_vars_internal): Handle\n+\tGOMP_MAP_VARS_OPENACC_ENTER_DATA.  Update for virtual_refcount\n+\tsemantics.\n+\t(gomp_unmap_vars_internal): Update for virtual_refcount semantics.\n+\t(gomp_load_image_to_device, omp_target_associate_ptr): Zero-initialise\n+\tvirtual_refcount field instead of dynamic_refcount.\n+\t(gomp_free_memmap): Remove function.\n+\t* testsuite/libgomp.oacc-c-c++-common/unmap-infinity-1.c: New test.\n+\t* testsuite/libgomp.c-c++-common/unmap-infinity-2.c: New test.\n+\t* testsuite/libgomp.oacc-c-c++-common/pr92843-1.c: Add XFAIL.\n+\n 2019-12-19  Julian Brown  <julian@codesourcery.com>\n \t    Thomas Schwinge  <thomas@codesourcery.com>\n "}, {"sha": "b9301bd70f81d0c72092210534d8f1a52bc3d185", "filename": "libgomp/libgomp.h", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/378da98fcc907d05002bcd3d6ff7951f0cf485e5/libgomp%2Flibgomp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/378da98fcc907d05002bcd3d6ff7951f0cf485e5/libgomp%2Flibgomp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.h?ref=378da98fcc907d05002bcd3d6ff7951f0cf485e5", "patch": "@@ -1007,8 +1007,11 @@ struct splay_tree_key_s {\n   uintptr_t tgt_offset;\n   /* Reference count.  */\n   uintptr_t refcount;\n-  /* Dynamic reference count.  */\n-  uintptr_t dynamic_refcount;\n+  /* Reference counts beyond those that represent genuine references in the\n+     linked splay tree key/target memory structures, e.g. for multiple OpenACC\n+     \"present increment\" operations (via \"acc enter data\") referring to the same\n+     host-memory block.  */\n+  uintptr_t virtual_refcount;\n   struct splay_tree_aux *aux;\n };\n \n@@ -1139,6 +1142,7 @@ struct gomp_device_descr\n enum gomp_map_vars_kind\n {\n   GOMP_MAP_VARS_OPENACC,\n+  GOMP_MAP_VARS_OPENACC_ENTER_DATA,\n   GOMP_MAP_VARS_TARGET,\n   GOMP_MAP_VARS_DATA,\n   GOMP_MAP_VARS_ENTER_DATA\n@@ -1168,7 +1172,6 @@ extern void gomp_unmap_vars_async (struct target_mem_desc *, bool,\n \t\t\t\t   struct goacc_asyncqueue *);\n extern void gomp_init_device (struct gomp_device_descr *);\n extern bool gomp_fini_device (struct gomp_device_descr *);\n-extern void gomp_free_memmap (struct splay_tree_s *);\n extern void gomp_unload_device (struct gomp_device_descr *);\n extern bool gomp_remove_var (struct gomp_device_descr *, splay_tree_key);\n extern void gomp_remove_var_async (struct gomp_device_descr *, splay_tree_key,"}, {"sha": "dd88b58a379cc85a892dfab59774a9c0a4527fa6", "filename": "libgomp/oacc-init.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/378da98fcc907d05002bcd3d6ff7951f0cf485e5/libgomp%2Foacc-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/378da98fcc907d05002bcd3d6ff7951f0cf485e5/libgomp%2Foacc-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-init.c?ref=378da98fcc907d05002bcd3d6ff7951f0cf485e5", "patch": "@@ -370,7 +370,15 @@ acc_shutdown_1 (acc_device_t d)\n       if (walk->dev)\n \t{\n \t  gomp_mutex_lock (&walk->dev->lock);\n-\t  gomp_free_memmap (&walk->dev->mem_map);\n+\n+\t  while (walk->dev->mem_map.root)\n+\t    {\n+\t      splay_tree_key k = &walk->dev->mem_map.root->key;\n+\t      if (k->aux)\n+\t\tk->aux->link_key = NULL;\n+\t      gomp_remove_var (walk->dev, k);\n+\t    }\n+\n \t  gomp_mutex_unlock (&walk->dev->lock);\n \n \t  walk->dev = NULL;"}, {"sha": "64168d64017ba68b9b4e48107ffa600178f34abf", "filename": "libgomp/oacc-mem.c", "status": "modified", "additions": 178, "deletions": 270, "changes": 448, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/378da98fcc907d05002bcd3d6ff7951f0cf485e5/libgomp%2Foacc-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/378da98fcc907d05002bcd3d6ff7951f0cf485e5/libgomp%2Foacc-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-mem.c?ref=378da98fcc907d05002bcd3d6ff7951f0cf485e5", "patch": "@@ -407,7 +407,7 @@ acc_map_data (void *h, void *d, size_t s)\n       assert (tgt);\n       splay_tree_key n = tgt->list[0].key;\n       assert (n->refcount == 1);\n-      assert (n->dynamic_refcount == 0);\n+      assert (n->virtual_refcount == 0);\n       /* Special reference counting behavior.  */\n       n->refcount = REFCOUNT_INFINITY;\n \n@@ -435,20 +435,17 @@ acc_unmap_data (void *h)\n   acc_api_info api_info;\n   bool profiling_p = GOACC_PROFILING_SETUP_P (thr, &prof_info, &api_info);\n \n-  size_t host_size;\n-\n   gomp_mutex_lock (&acc_dev->lock);\n \n   splay_tree_key n = lookup_host (acc_dev, h, 1);\n-  struct target_mem_desc *t;\n \n   if (!n)\n     {\n       gomp_mutex_unlock (&acc_dev->lock);\n       gomp_fatal (\"%p is not a mapped block\", (void *)h);\n     }\n \n-  host_size = n->host_end - n->host_start;\n+  size_t host_size = n->host_end - n->host_start;\n \n   if (n->host_start != (uintptr_t) h)\n     {\n@@ -457,7 +454,7 @@ acc_unmap_data (void *h)\n \t\t  (void *) n->host_start, (int) host_size, (void *) h);\n     }\n   /* TODO This currently doesn't catch 'REFCOUNT_INFINITY' usage different from\n-     'acc_map_data'.  Maybe 'dynamic_refcount' can be used for disambiguating\n+     'acc_map_data'.  Maybe 'virtual_refcount' can be used for disambiguating\n      the different 'REFCOUNT_INFINITY' cases, or simply separate\n      'REFCOUNT_INFINITY' values per different usage ('REFCOUNT_ACC_MAP_DATA'\n      etc.)?  */\n@@ -469,19 +466,22 @@ acc_unmap_data (void *h)\n \t\t  (void *) h, (int) host_size);\n     }\n \n-  t = n->tgt;\n+  splay_tree_remove (&acc_dev->mem_map, n);\n+\n+  struct target_mem_desc *tgt = n->tgt;\n \n-  if (t->refcount == 1)\n+  if (tgt->refcount == REFCOUNT_INFINITY)\n     {\n-      /* This is the last reference, so pull the descriptor off the\n-         chain.  This prevents 'gomp_unmap_tgt' via 'gomp_remove_var' from\n-         freeing the device memory. */\n-      t->tgt_end = 0;\n-      t->to_free = 0;\n+      gomp_mutex_unlock (&acc_dev->lock);\n+      gomp_fatal (\"cannot unmap target block\");\n+    }\n+  else if (tgt->refcount > 1)\n+    tgt->refcount--;\n+  else\n+    {\n+      free (tgt->array);\n+      free (tgt);\n     }\n-\n-  bool is_tgt_unmapped = gomp_remove_var (acc_dev, n);\n-  assert (is_tgt_unmapped);\n \n   gomp_mutex_unlock (&acc_dev->lock);\n \n@@ -493,42 +493,24 @@ acc_unmap_data (void *h)\n }\n \n \n-/* Enter dynamic mappings.\n-\n-   The handling for MAPNUM bigger than one is special handling for\n-   'GOMP_MAP_POINTER', 'GOMP_MAP_TO_PSET'.  For these, only the first mapping\n-   is considered in reference counting; the following ones implicitly follow\n-   suit.\n-\n-   If there's just one mapping, return the device pointer.  */\n+/* Enter dynamic mapping for a single datum.  Return the device pointer.  */\n \n static void *\n-goacc_enter_data (size_t mapnum, void **hostaddrs, size_t *sizes, void *kinds,\n-\t\t  int async)\n+goacc_enter_datum (void **hostaddrs, size_t *sizes, void *kinds, int async)\n {\n   void *d;\n   splay_tree_key n;\n \n-  assert (mapnum > 0);\n-  if (mapnum == 1\n-      && (!hostaddrs[0] || !sizes[0]))\n+  if (!hostaddrs[0] || !sizes[0])\n     gomp_fatal (\"[%p,+%d] is a bad range\", hostaddrs[0], (int) sizes[0]);\n-  else if (mapnum > 1\n-\t   && !hostaddrs[0])\n-    return /* n/a */ (void *) -1;\n \n   goacc_lazy_initialize ();\n \n   struct goacc_thread *thr = goacc_thread ();\n   struct gomp_device_descr *acc_dev = thr->dev;\n \n   if (acc_dev->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)\n-    {\n-      if (mapnum == 1)\n-\treturn hostaddrs[0];\n-      else\n-\treturn /* n/a */ (void *) -1;\n-    }\n+    return hostaddrs[0];\n \n   acc_prof_info prof_info;\n   acc_api_info api_info;\n@@ -542,7 +524,7 @@ goacc_enter_data (size_t mapnum, void **hostaddrs, size_t *sizes, void *kinds,\n   gomp_mutex_lock (&acc_dev->lock);\n \n   n = lookup_host (acc_dev, hostaddrs[0], sizes[0]);\n-  if (n && mapnum == 1)\n+  if (n)\n     {\n       void *h = hostaddrs[0];\n       size_t s = sizes[0];\n@@ -558,53 +540,31 @@ goacc_enter_data (size_t mapnum, void **hostaddrs, size_t *sizes, void *kinds,\n \n       assert (n->refcount != REFCOUNT_LINK);\n       if (n->refcount != REFCOUNT_INFINITY)\n-\tn->refcount++;\n-      n->dynamic_refcount++;\n-\n-      gomp_mutex_unlock (&acc_dev->lock);\n-    }\n-  else if (n && mapnum > 1)\n-    {\n-      d = /* n/a */ (void *) -1;\n-\n-      assert (n->refcount != REFCOUNT_INFINITY\n-\t      && n->refcount != REFCOUNT_LINK);\n-\n-      bool processed = false;\n-\n-      struct target_mem_desc *tgt = n->tgt;\n-      for (size_t i = 0; i < tgt->list_count; i++)\n-\tif (tgt->list[i].key == n)\n-\t  {\n-\t    for (size_t j = 0; j < mapnum; j++)\n-\t      if (i + j < tgt->list_count && tgt->list[i + j].key)\n-\t\t{\n-\t\t  tgt->list[i + j].key->refcount++;\n-\t\t  tgt->list[i + j].key->dynamic_refcount++;\n-\t\t}\n-\t    processed = true;\n-\t  }\n+\t{\n+\t  n->refcount++;\n+\t  n->virtual_refcount++;\n+\t}\n \n       gomp_mutex_unlock (&acc_dev->lock);\n-      if (!processed)\n-\tgomp_fatal (\"dynamic refcount incrementing failed for pointer/pset\");\n     }\n   else\n     {\n+      const size_t mapnum = 1;\n+\n       gomp_mutex_unlock (&acc_dev->lock);\n \n       goacc_aq aq = get_goacc_asyncqueue (async);\n \n-      struct target_mem_desc *tgt\n-\t= gomp_map_vars_async (acc_dev, aq, mapnum, hostaddrs, NULL, sizes,\n-\t\t\t       kinds, true, GOMP_MAP_VARS_ENTER_DATA);\n-      assert (tgt);\n-      n = tgt->list[0].key;\n-      assert (n->refcount == 1);\n-      assert (n->dynamic_refcount == 0);\n-      n->dynamic_refcount++;\n+      gomp_map_vars_async (acc_dev, aq, mapnum, hostaddrs, NULL, sizes, kinds,\n+\t\t\t   true, GOMP_MAP_VARS_OPENACC_ENTER_DATA);\n \n-      d = tgt->to_free;\n+      gomp_mutex_lock (&acc_dev->lock);\n+      n = lookup_host (acc_dev, hostaddrs[0], sizes[0]);\n+      assert (n != NULL);\n+      assert (n->tgt_offset == 0);\n+      assert ((uintptr_t) hostaddrs[0] == n->host_start);\n+      d = (void *) n->tgt->tgt_start;\n+      gomp_mutex_unlock (&acc_dev->lock);\n     }\n \n   if (profiling_p)\n@@ -620,14 +580,14 @@ void *\n acc_create (void *h, size_t s)\n {\n   unsigned short kinds[1] = { GOMP_MAP_ALLOC };\n-  return goacc_enter_data (1, &h, &s, &kinds, acc_async_sync);\n+  return goacc_enter_datum (&h, &s, &kinds, acc_async_sync);\n }\n \n void\n acc_create_async (void *h, size_t s, int async)\n {\n   unsigned short kinds[1] = { GOMP_MAP_ALLOC };\n-  goacc_enter_data (1, &h, &s, &kinds, async);\n+  goacc_enter_datum (&h, &s, &kinds, async);\n }\n \n /* acc_present_or_create used to be what acc_create is now.  */\n@@ -653,14 +613,14 @@ void *\n acc_copyin (void *h, size_t s)\n {\n   unsigned short kinds[1] = { GOMP_MAP_TO };\n-  return goacc_enter_data (1, &h, &s, &kinds, acc_async_sync);\n+  return goacc_enter_datum (&h, &s, &kinds, acc_async_sync);\n }\n \n void\n acc_copyin_async (void *h, size_t s, int async)\n {\n   unsigned short kinds[1] = { GOMP_MAP_TO };\n-  goacc_enter_data (1, &h, &s, &kinds, async);\n+  goacc_enter_datum (&h, &s, &kinds, async);\n }\n \n /* acc_present_or_copyin used to be what acc_copyin is now.  */\n@@ -683,10 +643,10 @@ acc_pcopyin (void *h, size_t s)\n #endif\n \n \n-/* Exit a dynamic mapping.  */\n+/* Exit a dynamic mapping for a single variable.  */\n \n static void\n-goacc_exit_data (void *h, size_t s, unsigned short kind, int async)\n+goacc_exit_datum (void *h, size_t s, unsigned short kind, int async)\n {\n   /* No need to call lazy open, as the data must already have been\n      mapped.  */\n@@ -723,28 +683,23 @@ goacc_exit_data (void *h, size_t s, unsigned short kind, int async)\n \t\t  (void *) h, (int) s, (void *) n->host_start, (int) host_size);\n     }\n \n-  assert (n->refcount != REFCOUNT_LINK);\n-  if (n->refcount != REFCOUNT_INFINITY\n-      && n->refcount < n->dynamic_refcount)\n-    {\n-      gomp_mutex_unlock (&acc_dev->lock);\n-      gomp_fatal (\"Dynamic reference counting assert fail\\n\");\n-    }\n-\n   bool finalize = (kind == GOMP_MAP_DELETE\n \t\t   || kind == GOMP_MAP_FORCE_FROM);\n   if (finalize)\n     {\n       if (n->refcount != REFCOUNT_INFINITY)\n-\tn->refcount -= n->dynamic_refcount;\n-      n->dynamic_refcount = 0;\n+\tn->refcount -= n->virtual_refcount;\n+      n->virtual_refcount = 0;\n     }\n-  else if (n->dynamic_refcount)\n+\n+  if (n->virtual_refcount > 0)\n     {\n       if (n->refcount != REFCOUNT_INFINITY)\n \tn->refcount--;\n-      n->dynamic_refcount--;\n+      n->virtual_refcount--;\n     }\n+  else if (n->refcount > 0 && n->refcount != REFCOUNT_INFINITY)\n+    n->refcount--;\n \n   if (n->refcount == 0)\n     {\n@@ -785,49 +740,49 @@ goacc_exit_data (void *h, size_t s, unsigned short kind, int async)\n void\n acc_delete (void *h , size_t s)\n {\n-  goacc_exit_data (h, s, GOMP_MAP_RELEASE, acc_async_sync);\n+  goacc_exit_datum (h, s, GOMP_MAP_RELEASE, acc_async_sync);\n }\n \n void\n acc_delete_async (void *h , size_t s, int async)\n {\n-  goacc_exit_data (h, s, GOMP_MAP_RELEASE, async);\n+  goacc_exit_datum (h, s, GOMP_MAP_RELEASE, async);\n }\n \n void\n acc_delete_finalize (void *h , size_t s)\n {\n-  goacc_exit_data (h, s, GOMP_MAP_DELETE, acc_async_sync);\n+  goacc_exit_datum (h, s, GOMP_MAP_DELETE, acc_async_sync);\n }\n \n void\n acc_delete_finalize_async (void *h , size_t s, int async)\n {\n-  goacc_exit_data (h, s, GOMP_MAP_DELETE, async);\n+  goacc_exit_datum (h, s, GOMP_MAP_DELETE, async);\n }\n \n void\n acc_copyout (void *h, size_t s)\n {\n-  goacc_exit_data (h, s, GOMP_MAP_FROM, acc_async_sync);\n+  goacc_exit_datum (h, s, GOMP_MAP_FROM, acc_async_sync);\n }\n \n void\n acc_copyout_async (void *h, size_t s, int async)\n {\n-  goacc_exit_data (h, s, GOMP_MAP_FROM, async);\n+  goacc_exit_datum (h, s, GOMP_MAP_FROM, async);\n }\n \n void\n acc_copyout_finalize (void *h, size_t s)\n {\n-  goacc_exit_data (h, s, GOMP_MAP_FORCE_FROM, acc_async_sync);\n+  goacc_exit_datum (h, s, GOMP_MAP_FORCE_FROM, acc_async_sync);\n }\n \n void\n acc_copyout_finalize_async (void *h, size_t s, int async)\n {\n-  goacc_exit_data (h, s, GOMP_MAP_FORCE_FROM, async);\n+  goacc_exit_datum (h, s, GOMP_MAP_FORCE_FROM, async);\n }\n \n static void\n@@ -912,123 +867,145 @@ acc_update_self_async (void *h, size_t s, int async)\n   update_dev_host (0, h, s, async);\n }\n \n+/* Some types of (pointer) variables use several consecutive mappings, which\n+   must be treated as a group for enter/exit data directives.  This function\n+   returns the last mapping in such a group (inclusive), or POS for singleton\n+   mappings.  */\n \n-/* OpenACC 'enter data', 'exit data': 'GOACC_enter_exit_data' and its helper\n-   functions.  */\n+static int\n+find_group_last (int pos, size_t mapnum, unsigned short *kinds)\n+{\n+  unsigned char kind0 = kinds[pos] & 0xff;\n+  int first_pos = pos, last_pos = pos;\n \n-/* Special handling for 'GOMP_MAP_POINTER', 'GOMP_MAP_TO_PSET'.\n+  if (kind0 == GOMP_MAP_TO_PSET)\n+    {\n+      while (pos + 1 < mapnum && (kinds[pos + 1] & 0xff) == GOMP_MAP_POINTER)\n+\tlast_pos = ++pos;\n+      /* We expect at least one GOMP_MAP_POINTER after a GOMP_MAP_TO_PSET.  */\n+      assert (last_pos > first_pos);\n+    }\n+  else\n+    {\n+      /* GOMP_MAP_ALWAYS_POINTER can only appear directly after some other\n+\t mapping.  */\n+      if (pos + 1 < mapnum\n+\t  && (kinds[pos + 1] & 0xff) == GOMP_MAP_ALWAYS_POINTER)\n+\treturn pos + 1;\n+\n+      /* We can have one or several GOMP_MAP_POINTER mappings after a to/from\n+\t (etc.) mapping.  */\n+      while (pos + 1 < mapnum && (kinds[pos + 1] & 0xff) == GOMP_MAP_POINTER)\n+\tlast_pos = ++pos;\n+    }\n \n-   Only the first mapping is considered in reference counting; the following\n-   ones implicitly follow suit.  Similarly, 'copyout' is done only for the\n-   first mapping.  */\n+  return last_pos;\n+}\n+\n+/* Map variables for OpenACC \"enter data\".  We can't just call\n+   gomp_map_vars_async once, because individual mapped variables might have\n+   \"exit data\" called for them at different times.  */\n \n static void\n-goacc_remove_pointer (void *h, size_t s, unsigned short kind, int async)\n+goacc_enter_data_internal (struct gomp_device_descr *acc_dev, size_t mapnum,\n+\t\t\t   void **hostaddrs, size_t *sizes,\n+\t\t\t   unsigned short *kinds, goacc_aq aq)\n {\n-  kind &= 0xff;\n-\n-  struct goacc_thread *thr = goacc_thread ();\n-  struct gomp_device_descr *acc_dev = thr->dev;\n-  splay_tree_key n;\n-  struct target_mem_desc *t;\n-\n-  if (!acc_is_present (h, s))\n-    return;\n-\n-  gomp_mutex_lock (&acc_dev->lock);\n+  for (size_t i = 0; i < mapnum; i++)\n+    {\n+      int group_last = find_group_last (i, mapnum, kinds);\n \n-  n = lookup_host (acc_dev, h, 1);\n+      gomp_map_vars_async (acc_dev, aq,\n+\t\t\t   (group_last - i) + 1,\n+\t\t\t   &hostaddrs[i], NULL,\n+\t\t\t   &sizes[i], &kinds[i], true,\n+\t\t\t   GOMP_MAP_VARS_OPENACC_ENTER_DATA);\n \n-  if (!n)\n-    {\n-      gomp_mutex_unlock (&acc_dev->lock);\n-      gomp_fatal (\"%p is not a mapped block\", (void *)h);\n+      i = group_last;\n     }\n+}\n \n-  gomp_debug (0, \"  %s: restore mappings\\n\", __FUNCTION__);\n-\n-  t = n->tgt;\n+/* Unmap variables for OpenACC \"exit data\".  */\n \n-  assert (n->refcount != REFCOUNT_INFINITY\n-\t  && n->refcount != REFCOUNT_LINK);\n-  if (n->refcount < n->dynamic_refcount)\n-    {\n-      gomp_mutex_unlock (&acc_dev->lock);\n-      gomp_fatal (\"Dynamic reference counting assert fail\\n\");\n-    }\n+static void\n+goacc_exit_data_internal (struct gomp_device_descr *acc_dev, size_t mapnum,\n+\t\t\t  void **hostaddrs, size_t *sizes,\n+\t\t\t  unsigned short *kinds, goacc_aq aq)\n+{\n+  gomp_mutex_lock (&acc_dev->lock);\n \n-  bool finalize = (kind == GOMP_MAP_DELETE\n-\t\t   || kind == GOMP_MAP_FORCE_FROM);\n-  if (finalize)\n-    {\n-      n->refcount -= n->dynamic_refcount;\n-      n->dynamic_refcount = 0;\n-    }\n-  else if (n->dynamic_refcount)\n+  for (size_t i = 0; i < mapnum; ++i)\n     {\n-      n->refcount--;\n-      n->dynamic_refcount--;\n-    }\n+      unsigned char kind = kinds[i] & 0xff;\n+      bool copyfrom = false;\n+      bool finalize = false;\n \n-  if (n->refcount == 0)\n-    {\n-      goacc_aq aq = get_goacc_asyncqueue (async);\n+      if (kind == GOMP_MAP_FORCE_FROM\n+\t  || kind == GOMP_MAP_DELETE)\n+\tfinalize = true;\n \n-      bool copyout = (kind == GOMP_MAP_FROM\n-\t\t      || kind == GOMP_MAP_FORCE_FROM);\n-      if (copyout)\n+      switch (kind)\n \t{\n-\t  void *d = (void *) (t->tgt_start + n->tgt_offset\n-\t\t\t      + (uintptr_t) h - n->host_start);\n-\t  gomp_copy_dev2host (acc_dev, aq, h, d, s);\n-\t}\n+\tcase GOMP_MAP_FROM:\n+\tcase GOMP_MAP_FORCE_FROM:\n+\tcase GOMP_MAP_ALWAYS_FROM:\n+\t  copyfrom = true;\n+\t  /* Fallthrough.  */\n+\n+\tcase GOMP_MAP_TO_PSET:\n+\tcase GOMP_MAP_POINTER:\n+\tcase GOMP_MAP_DELETE:\n+\tcase GOMP_MAP_RELEASE:\n+\t  {\n+\t    struct splay_tree_key_s cur_node;\n+\t    size_t size;\n+\t    if (kind == GOMP_MAP_POINTER)\n+\t      size = sizeof (void *);\n+\t    else\n+\t      size = sizes[i];\n+\t    cur_node.host_start = (uintptr_t) hostaddrs[i];\n+\t    cur_node.host_end = cur_node.host_start + size;\n+\t    splay_tree_key n\n+\t      = splay_tree_lookup (&acc_dev->mem_map, &cur_node);\n+\n+\t    if (n == NULL)\n+\t      continue;\n+\n+\t    if (finalize)\n+\t      {\n+\t\tif (n->refcount != REFCOUNT_INFINITY)\n+\t\t  n->refcount -= n->virtual_refcount;\n+\t\tn->virtual_refcount = 0;\n+\t      }\n \n-      if (aq)\n-\t{\n-\t  /* TODO The way the following code is currently implemented, we need\n-\t     the 'is_tgt_unmapped' return value from 'gomp_remove_var', so\n-\t     can't use 'gomp_remove_var_async' here -- see the 'gomp_unref_tgt'\n-\t     comment in\n-\t     <http://mid.mail-archive.com/878snl36eu.fsf@euler.schwinge.homeip.net>;\n-\t     PR92881 -- so have to synchronize here.  */\n-\t  if (!acc_dev->openacc.async.synchronize_func (aq))\n-\t    {\n-\t      gomp_mutex_unlock (&acc_dev->lock);\n-\t      gomp_fatal (\"synchronize failed\");\n-\t    }\n-\t}\n-      bool is_tgt_unmapped = false;\n-      for (size_t i = 0; i < t->list_count; i++)\n-\t{\n-\t  is_tgt_unmapped = gomp_remove_var (acc_dev, t->list[i].key);\n-\t  if (is_tgt_unmapped)\n-\t    break;\n+\t    if (n->virtual_refcount > 0)\n+\t      {\n+\t\tif (n->refcount != REFCOUNT_INFINITY)\n+\t\t  n->refcount--;\n+\t\tn->virtual_refcount--;\n+\t      }\n+\t    else if (n->refcount > 0 && n->refcount != REFCOUNT_INFINITY)\n+\t      n->refcount--;\n+\n+\t    if (copyfrom\n+\t\t&& (kind != GOMP_MAP_FROM || n->refcount == 0))\n+\t      gomp_copy_dev2host (acc_dev, aq, (void *) cur_node.host_start,\n+\t\t\t\t  (void *) (n->tgt->tgt_start + n->tgt_offset\n+\t\t\t\t\t    + cur_node.host_start\n+\t\t\t\t\t    - n->host_start),\n+\t\t\t\t  cur_node.host_end - cur_node.host_start);\n+\n+\t    if (n->refcount == 0)\n+\t      gomp_remove_var_async (acc_dev, n, aq);\n+\t  }\n+\t  break;\n+\tdefault:\n+\t  gomp_fatal (\">>>> goacc_exit_data_internal UNHANDLED kind 0x%.2x\",\n+\t\t\t  kind);\n \t}\n-      assert (is_tgt_unmapped);\n     }\n \n   gomp_mutex_unlock (&acc_dev->lock);\n-\n-  gomp_debug (0, \"  %s: mappings restored\\n\", __FUNCTION__);\n-}\n-\n-/* Return the number of mappings associated with 'GOMP_MAP_TO_PSET' or\n-   'GOMP_MAP_POINTER'.  */\n-\n-static int\n-find_pointer (int pos, size_t mapnum, unsigned short *kinds)\n-{\n-  if (pos + 1 >= mapnum)\n-    return 0;\n-\n-  unsigned char kind = kinds[pos+1] & 0xff;\n-\n-  if (kind == GOMP_MAP_TO_PSET)\n-    return 3;\n-  else if (kind == GOMP_MAP_POINTER)\n-    return 2;\n-\n-  return 0;\n }\n \n void\n@@ -1147,81 +1124,12 @@ GOACC_enter_exit_data (int flags_m, size_t mapnum, void **hostaddrs,\n       va_end (ap);\n     }\n \n-  /* In c, non-pointers and arrays are represented by a single data clause.\n-     Dynamically allocated arrays and subarrays are represented by a data\n-     clause followed by an internal GOMP_MAP_POINTER.\n-\n-     In fortran, scalars and not allocated arrays are represented by a\n-     single data clause. Allocated arrays and subarrays have three mappings:\n-     1) the original data clause, 2) a PSET 3) a pointer to the array data.\n-  */\n+  goacc_aq aq = get_goacc_asyncqueue (async);\n \n   if (data_enter)\n-    {\n-      for (i = 0; i < mapnum; i++)\n-\t{\n-\t  /* Scan for pointers and PSETs.  */\n-\t  int pointer = find_pointer (i, mapnum, kinds);\n-\n-\t  if (!pointer)\n-\t    {\n-\t      unsigned char kind = kinds[i] & 0xff;\n-\t      switch (kind)\n-\t\t{\n-\t\tcase GOMP_MAP_ALLOC:\n-\t\tcase GOMP_MAP_FORCE_ALLOC:\n-\t\tcase GOMP_MAP_TO:\n-\t\tcase GOMP_MAP_FORCE_TO:\n-\t\t  break;\n-\t\tdefault:\n-\t\t  gomp_fatal (\">>>> GOACC_enter_exit_data UNHANDLED kind 0x%.2x\",\n-\t\t\t      kind);\n-\t\t  break;\n-\t\t}\n-\n-\t      /* We actually have one mapping.  */\n-\t      pointer = 1;\n-\t    }\n-\n-\t  goacc_enter_data (pointer, &hostaddrs[i], &sizes[i], &kinds[i],\n-\t\t\t    async);\n-\t  /* If applicable, increment 'i' further; OpenACC requires fortran\n-\t     arrays to be contiguous, so each PSET is associated with\n-\t     one of MAP_FORCE_ALLOC/MAP_FORCE_PRESET/MAP_FORCE_TO, and\n-\t     one MAP_POINTER.  */\n-\t  i += pointer - 1;\n-\t}\n-    }\n+    goacc_enter_data_internal (acc_dev, mapnum, hostaddrs, sizes, kinds, aq);\n   else\n-    for (i = 0; i < mapnum; ++i)\n-      {\n-\tint pointer = find_pointer (i, mapnum, kinds);\n-\n-\tif (!pointer)\n-\t  {\n-\t    unsigned char kind = kinds[i] & 0xff;\n-\t    switch (kind)\n-\t      {\n-\t      case GOMP_MAP_RELEASE:\n-\t      case GOMP_MAP_DELETE:\n-\t      case GOMP_MAP_FROM:\n-\t      case GOMP_MAP_FORCE_FROM:\n-\t\tbreak;\n-\t      default:\n-\t\tgomp_fatal (\">>>> GOACC_enter_exit_data UNHANDLED kind 0x%.2x\",\n-\t\t\t    kind);\n-\t\tbreak;\n-\t      }\n-\n-\t    goacc_exit_data (hostaddrs[i], sizes[i], kinds[i], async);\n-\t  }\n-\telse\n-\t  {\n-\t    goacc_remove_pointer (hostaddrs[i], sizes[i], kinds[i], async);\n-\t    /* See the above comment.  */\n-\t    i += pointer - 1;\n-\t  }\n-      }\n+    goacc_exit_data_internal (acc_dev, mapnum, hostaddrs, sizes, kinds, aq);\n \n  out_prof:\n   if (profiling_p)"}, {"sha": "f2a60614e598ed1b2593c4b0893a2d804d25dc26", "filename": "libgomp/target.c", "status": "modified", "additions": 29, "deletions": 24, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/378da98fcc907d05002bcd3d6ff7951f0cf485e5/libgomp%2Ftarget.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/378da98fcc907d05002bcd3d6ff7951f0cf485e5/libgomp%2Ftarget.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftarget.c?ref=378da98fcc907d05002bcd3d6ff7951f0cf485e5", "patch": "@@ -537,8 +537,10 @@ gomp_map_vars_internal (struct gomp_device_descr *devicep,\n   struct target_mem_desc *tgt\n     = gomp_malloc (sizeof (*tgt) + sizeof (tgt->list[0]) * mapnum);\n   tgt->list_count = mapnum;\n-  tgt->refcount = pragma_kind == GOMP_MAP_VARS_ENTER_DATA ? 0 : 1;\n+  tgt->refcount = (pragma_kind == GOMP_MAP_VARS_ENTER_DATA\n+\t\t   || pragma_kind == GOMP_MAP_VARS_OPENACC_ENTER_DATA) ? 0 : 1;\n   tgt->device_descr = devicep;\n+  tgt->prev = NULL;\n   struct gomp_coalesce_buf cbuf, *cbufp = NULL;\n \n   if (mapnum == 0)\n@@ -963,7 +965,7 @@ gomp_map_vars_internal (struct gomp_device_descr *devicep,\n \t\ttgt->list[i].offset = 0;\n \t\ttgt->list[i].length = k->host_end - k->host_start;\n \t\tk->refcount = 1;\n-\t\tk->dynamic_refcount = 0;\n+\t\tk->virtual_refcount = 0;\n \t\ttgt->refcount++;\n \t\tarray->left = NULL;\n \t\tarray->right = NULL;\n@@ -1101,8 +1103,20 @@ gomp_map_vars_internal (struct gomp_device_descr *devicep,\n   /* If the variable from \"omp target enter data\" map-list was already mapped,\n      tgt is not needed.  Otherwise tgt will be freed by gomp_unmap_vars or\n      gomp_exit_data.  */\n-  if (pragma_kind == GOMP_MAP_VARS_ENTER_DATA && tgt->refcount == 0)\n-    {\n+  if ((pragma_kind == GOMP_MAP_VARS_ENTER_DATA\n+       || pragma_kind == GOMP_MAP_VARS_OPENACC_ENTER_DATA)\n+      && tgt->refcount == 0)\n+    {\n+      /* If we're about to discard a target_mem_desc with no \"structural\"\n+\t references (tgt->refcount == 0), any splay keys linked in the tgt's\n+\t list must have their virtual refcount incremented to represent that\n+\t \"lost\" reference in order to implement the semantics of the OpenACC\n+\t \"present increment\" operation properly.  */\n+      if (pragma_kind == GOMP_MAP_VARS_OPENACC_ENTER_DATA)\n+\tfor (i = 0; i < tgt->list_count; i++)\n+\t  if (tgt->list[i].key)\n+\t    tgt->list[i].key->virtual_refcount++;\n+\n       free (tgt);\n       tgt = NULL;\n     }\n@@ -1240,7 +1254,14 @@ gomp_unmap_vars_internal (struct target_mem_desc *tgt, bool do_copyfrom,\n \tcontinue;\n \n       bool do_unmap = false;\n-      if (k->refcount > 1 && k->refcount != REFCOUNT_INFINITY)\n+      if (k->tgt == tgt\n+\t  && k->virtual_refcount > 0\n+\t  && k->refcount != REFCOUNT_INFINITY)\n+\t{\n+\t  k->virtual_refcount--;\n+\t  k->refcount--;\n+\t}\n+      else if (k->refcount > 1 && k->refcount != REFCOUNT_INFINITY)\n \tk->refcount--;\n       else if (k->refcount == 1)\n \t{\n@@ -1405,7 +1426,7 @@ gomp_load_image_to_device (struct gomp_device_descr *devicep, unsigned version,\n       k->tgt = tgt;\n       k->tgt_offset = target_table[i].start;\n       k->refcount = REFCOUNT_INFINITY;\n-      k->dynamic_refcount = 0;\n+      k->virtual_refcount = 0;\n       k->aux = NULL;\n       array->left = NULL;\n       array->right = NULL;\n@@ -1438,7 +1459,7 @@ gomp_load_image_to_device (struct gomp_device_descr *devicep, unsigned version,\n       k->tgt = tgt;\n       k->tgt_offset = target_var->start;\n       k->refcount = target_size & link_bit ? REFCOUNT_LINK : REFCOUNT_INFINITY;\n-      k->dynamic_refcount = 0;\n+      k->virtual_refcount = 0;\n       k->aux = NULL;\n       array->left = NULL;\n       array->right = NULL;\n@@ -1673,22 +1694,6 @@ gomp_unload_device (struct gomp_device_descr *devicep)\n     }\n }\n \n-/* Free address mapping tables.  MM must be locked on entry, and remains locked\n-   on return.  */\n-\n-attribute_hidden void\n-gomp_free_memmap (struct splay_tree_s *mem_map)\n-{\n-  while (mem_map->root)\n-    {\n-      struct target_mem_desc *tgt = mem_map->root->key.tgt;\n-\n-      splay_tree_remove (mem_map, &mem_map->root->key);\n-      free (tgt->array);\n-      free (tgt);\n-    }\n-}\n-\n /* Host fallback for GOMP_target{,_ext} routines.  */\n \n static void\n@@ -2700,7 +2705,7 @@ omp_target_associate_ptr (const void *host_ptr, const void *device_ptr,\n       k->tgt = tgt;\n       k->tgt_offset = (uintptr_t) device_ptr + device_offset;\n       k->refcount = REFCOUNT_INFINITY;\n-      k->dynamic_refcount = 0;\n+      k->virtual_refcount = 0;\n       k->aux = NULL;\n       array->left = NULL;\n       array->right = NULL;"}, {"sha": "3931c5aba25ae71d7e0c7a027c8af39ad5734a1a", "filename": "libgomp/testsuite/libgomp.c-c++-common/unmap-infinity-2.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/378da98fcc907d05002bcd3d6ff7951f0cf485e5/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Funmap-infinity-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/378da98fcc907d05002bcd3d6ff7951f0cf485e5/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Funmap-infinity-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Funmap-infinity-2.c?ref=378da98fcc907d05002bcd3d6ff7951f0cf485e5", "patch": "@@ -0,0 +1,19 @@\n+int foo[16];\n+#pragma omp declare target (foo)\n+\n+__attribute__((used)) void bar (void)\n+{\n+  #pragma omp target parallel for\n+  for (int i = 0; i < 16; i++)\n+    foo[i] = i;\n+}\n+\n+int\n+main (int argc, char *argv[])\n+{\n+  int *foo_copy = foo;\n+  /* Try to trigger the unmapping of a REFCOUNT_INFINITY target block.  This\n+     does nothing at the time of writing.  */\n+  #pragma omp target exit data map(delete: foo_copy[0:16])\n+  return 0;\n+}"}, {"sha": "f16c46a37bfb0ac3801ae0b7054b3fafcf2037d0", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/pr92843-1.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/378da98fcc907d05002bcd3d6ff7951f0cf485e5/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fpr92843-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/378da98fcc907d05002bcd3d6ff7951f0cf485e5/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fpr92843-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fpr92843-1.c?ref=378da98fcc907d05002bcd3d6ff7951f0cf485e5", "patch": "@@ -1,6 +1,7 @@\n /* Verify that 'acc_copyout' etc. is a no-op if there's still a structured\n    reference count.  */\n \n+/* { dg-xfail-run-if \"TODO PR92843\" { *-*-* } } */\n /* { dg-skip-if \"\" { *-*-* } { \"*\" } { \"-DACC_MEM_SHARED=0\" } } */\n \n #include <assert.h>"}, {"sha": "872f0c1de5c1e866d77e32f06684415292d00cb2", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/unmap-infinity-1.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/378da98fcc907d05002bcd3d6ff7951f0cf485e5/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Funmap-infinity-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/378da98fcc907d05002bcd3d6ff7951f0cf485e5/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Funmap-infinity-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Funmap-infinity-1.c?ref=378da98fcc907d05002bcd3d6ff7951f0cf485e5", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-skip-if \"\" { *-*-* } { \"*\" } { \"-DACC_MEM_SHARED=0\" } } */\n+\n+#include <openacc.h>\n+\n+int foo[16];\n+#pragma acc declare device_resident(foo)\n+\n+int\n+main (int argc, char *argv[])\n+{\n+  acc_init (acc_device_default);\n+  acc_unmap_data ((void *) foo);\n+/* { dg-output \"libgomp: cannot unmap target block\" } */\n+  return 0;\n+}\n+\n+/* { dg-shouldfail \"\" } */"}]}