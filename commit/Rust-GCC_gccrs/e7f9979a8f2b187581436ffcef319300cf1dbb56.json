{"sha": "e7f9979a8f2b187581436ffcef319300cf1dbb56", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTdmOTk3OWE4ZjJiMTg3NTgxNDM2ZmZjZWYzMTkzMDBjZjFkYmI1Ng==", "commit": {"author": {"name": "Naohiko Shimizu", "email": "nshimizu@keyaki.cc.u-tokai.ac.jp", "date": "2002-10-07T08:21:21Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-10-07T08:21:21Z"}, "message": "t-pdp11: Add MULTILIB support for msoft-float.\n\n        * t-pdp11: Add MULTILIB support for msoft-float.\n        * pdp11.h (LEGITIMATE_CONSTANT_P): Fix soft-float case.\n\n        * t-pdp11: Add LIB2FUNCS_EXTRA.\n        * pdp11.c (pdp11_output_function_prologue): Restrict offset to 16bit,\n        add preceding 0 to the octal constant, rename 'fp' to 'r5', rename\n        'fldd' to 'ldd', rename 'fstd' to 'std'.\n        (pdp11_output_function_epilogue): Likewise.\n        (output_move_quad): Make the comment gas compatible.\n        (output_ascii): Add preceding 0 to the octal constant.\n        (print_operand_address): Add pre_modify, post_modify.\n        (output_addr_const_pdp11): Add preceding 0 to the octal constant.\n        * pdp11.h (GO_IF_LEGITIMATE_ADDRESS) : Add 'movb' pre_modify case\n        with the indication of Paul Koning.\n        (PRINT_OPERAND): Fix floating constant.\n        * pdp11.md (movdi): Restrict matching pattern.\n        (movqi): Generalize the matching pattern.\n        (movdf): Restrict matching pattern.\n        (zero_extendqihi2): Change constant representation.\n        (floatsidf2): Fix wrong operands.\n        (addqi3): Fix wrong instruction name.\n        (subqi3): Fix wrong instruction name.\n        (andsi3, andhi3, andqi3): Simplify and fix to use 'bic'.\n        (xorsi3): Fix wrong insn.\n        (one_cmplqi2): Add two operand pattern.\n        (lsrsi3): New.\n        (negsi2): New.\n        (call): Add register indirect case.\n        (mod): Fix wrong subreg.\n\nFrom-SVN: r57886", "tree": {"sha": "50fea605915c06125c5fa78a5ba8976b01609226", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/50fea605915c06125c5fa78a5ba8976b01609226"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e7f9979a8f2b187581436ffcef319300cf1dbb56", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7f9979a8f2b187581436ffcef319300cf1dbb56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7f9979a8f2b187581436ffcef319300cf1dbb56", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7f9979a8f2b187581436ffcef319300cf1dbb56/comments", "author": null, "committer": null, "parents": [{"sha": "0b6dfe3b83b357c38b36448252085cd6bb555d37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b6dfe3b83b357c38b36448252085cd6bb555d37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b6dfe3b83b357c38b36448252085cd6bb555d37"}], "stats": {"total": 284, "additions": 185, "deletions": 99}, "files": [{"sha": "66708d98abf4a819db73ab1df40a002132802f98", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f9979a8f2b187581436ffcef319300cf1dbb56/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f9979a8f2b187581436ffcef319300cf1dbb56/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e7f9979a8f2b187581436ffcef319300cf1dbb56", "patch": "@@ -1,3 +1,35 @@\n+2002-10-05  Naohiko Shimizu <nshimizu@keyaki.cc.u-tokai.ac.jp>\n+\n+\t* t-pdp11: Add MULTILIB support for msoft-float.\n+\t* pdp11.h (LEGITIMATE_CONSTANT_P): Fix soft-float case.\n+\n+\t* t-pdp11: Add LIB2FUNCS_EXTRA.\n+\t* pdp11.c (pdp11_output_function_prologue): Restrict offset to 16bit, \n+\tadd preceding 0 to the octal constant, rename 'fp' to 'r5', rename\n+\t'fldd' to 'ldd', rename 'fstd' to 'std'.\n+\t(pdp11_output_function_epilogue): Likewise.\n+\t(output_move_quad): Make the comment gas compatible.\n+\t(output_ascii): Add preceding 0 to the octal constant.\n+\t(print_operand_address): Add pre_modify, post_modify.\n+\t(output_addr_const_pdp11): Add preceding 0 to the octal constant.\n+\t* pdp11.h (GO_IF_LEGITIMATE_ADDRESS) : Add 'movb' pre_modify case\n+\twith the indication of Paul Koning. \n+\t(PRINT_OPERAND): Fix floating constant.\n+\t* pdp11.md (movdi): Restrict matching pattern.\n+\t(movqi): Generalize the matching pattern.\n+\t(movdf): Restrict matching pattern.\n+\t(zero_extendqihi2): Change constant representation.\n+\t(floatsidf2): Fix wrong operands.\n+\t(addqi3): Fix wrong instruction name.\n+\t(subqi3): Fix wrong instruction name.\n+\t(andsi3, andhi3, andqi3): Simplify and fix to use 'bic'.\n+\t(xorsi3): Fix wrong insn.\n+\t(one_cmplqi2): Add two operand pattern.\n+\t(lsrsi3): New.\n+\t(negsi2): New.\n+\t(call): Add register indirect case.\n+\t(mod): Fix wrong subreg.\n+\n 2002-09-25  Eric Botcazou  <ebotcazou@libertysurf.fr>\n             Volker Reichelt <reichelt@igpm.rwth-aachen.de>\n "}, {"sha": "038b89878e1dff0bad55cdca592ee9d5465f54bb", "filename": "gcc/config/pdp11/pdp11.c", "status": "modified", "additions": 24, "deletions": 21, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f9979a8f2b187581436ffcef319300cf1dbb56/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f9979a8f2b187581436ffcef319300cf1dbb56/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.c?ref=e7f9979a8f2b187581436ffcef319300cf1dbb56", "patch": "@@ -137,7 +137,7 @@ pdp11_output_function_prologue (stream, size)\n     {\n       fprintf (stream, \"\\t/*abuse empty parameter slot for locals!*/\\n\");\n       if (size > 2)\n-\tfprintf(stream, \"\\tsub $%d, sp\\n\", size - 2);\n+\tfprintf(stream, \"\\tsub $0%o, sp\\n\", size - 2);\n \n     }\n }\n@@ -168,8 +168,8 @@ pdp11_output_function_prologue (stream, size)\n     \n     if (frame_pointer_needed) \t\t\t\t\t\n     {\t\t\t\t\t\t\t\t\n-\tfprintf(stream, \"\\tmov fp, -(sp)\\n\");\t\t\t\n-\tfprintf(stream, \"\\tmov sp, fp\\n\");\t\t\t\t\n+\tfprintf(stream, \"\\tmov r5, -(sp)\\n\");\t\t\t\n+\tfprintf(stream, \"\\tmov sp, r5\\n\");\t\t\t\t\n     }\t\t\t\t\t\t\t\t\n     else \t\t\t\t\t\t\t\t\n     {\t\t\t\t\t\t\t\t\n@@ -178,7 +178,7 @@ pdp11_output_function_prologue (stream, size)\n \n     /* make frame */\n     if (fsize)\t\t\t\t\t\t\t\n-\tfprintf (stream, \"\\tsub $%o, sp\\n\", fsize);\t\t\t\n+\tfprintf (stream, \"\\tsub $0%o, sp\\n\", fsize);\t\t\t\n \n     /* save CPU registers  */\n     for (regno = 0; regno < 8; regno++)\t\t\t\t\n@@ -198,7 +198,7 @@ pdp11_output_function_prologue (stream, size)\n \t    && regs_ever_live[regno] \n \t    && ! call_used_regs[regno])\n \t{\n-\t    fprintf (stream, \"\\tfstd %s, -(sp)\\n\", reg_names[regno]);\n+\t    fprintf (stream, \"\\tstd %s, -(sp)\\n\", reg_names[regno]);\n \t    via_ac = regno;\n \t}\n \t\n@@ -211,8 +211,8 @@ pdp11_output_function_prologue (stream, size)\n \t    if (via_ac == -1)\n \t\tabort();\n \t    \n-\t    fprintf (stream, \"\\tfldd %s, %s\\n\", reg_names[regno], reg_names[via_ac]);\n-\t    fprintf (stream, \"\\tfstd %s, -(sp)\\n\", reg_names[via_ac]);\n+\t    fprintf (stream, \"\\tldd %s, %s\\n\", reg_names[regno], reg_names[via_ac]);\n+\t    fprintf (stream, \"\\tstd %s, -(sp)\\n\", reg_names[via_ac]);\n \t}\n     }\n \n@@ -277,9 +277,10 @@ pdp11_output_function_epilogue (stream, size)\n \t/* remember # of pushed bytes for CPU regs */\n \tk = 2*j;\n \t\n+\t/* change fp -> r5 due to the compile error on libgcc2.c */\n \tfor (i =7 ; i >= 0 ; i--)\t\t\t\t\t\n \t    if (regs_ever_live[i] && ! call_used_regs[i])\t\t\n-\t\tfprintf(stream, \"\\tmov %o(fp), %s\\n\",-fsize-2*j--, reg_names[i]);\n+\t\tfprintf(stream, \"\\tmov 0%o(r5), %s\\n\",(-fsize-2*j--)&0xffff, reg_names[i]);\n \n \t/* get ACs */\t\t\t\t\t\t\n \tvia_ac = FIRST_PSEUDO_REGISTER -1;\n@@ -297,7 +298,7 @@ pdp11_output_function_epilogue (stream, size)\n \t\t&& regs_ever_live[i]\n \t\t&& ! call_used_regs[i])\n \t    {\n-\t\tfprintf(stream, \"\\tfldd %o(fp), %s\\n\", -fsize-k, reg_names[i]);\n+\t\tfprintf(stream, \"\\tldd 0%o(r5), %s\\n\", (-fsize-k)&0xffff, reg_names[i]);\n \t\tk -= 8;\n \t    }\n \t    \n@@ -308,14 +309,14 @@ pdp11_output_function_epilogue (stream, size)\n \t\tif (! LOAD_FPU_REG_P(via_ac))\n \t\t    abort();\n \t\t    \n-\t\tfprintf(stream, \"\\tfldd %o(fp), %s\\n\", -fsize-k, reg_names[via_ac]);\n-\t\tfprintf(stream, \"\\tfstd %s, %s\\n\", reg_names[via_ac], reg_names[i]);\n+\t\tfprintf(stream, \"\\tldd 0%o(r5), %s\\n\", (-fsize-k)&0xffff, reg_names[via_ac]);\n+\t\tfprintf(stream, \"\\tstd %s, %s\\n\", reg_names[via_ac], reg_names[i]);\n \t\tk -= 8;\n \t    }\n \t}\n \t\n-\tfprintf(stream, \"\\tmov fp, sp\\n\");\t\t\t\t\n-\tfprintf (stream, \"\\tmov (sp)+, fp\\n\");     \t\t\t\n+\tfprintf(stream, \"\\tmov r5, sp\\n\");\t\t\t\t\n+\tfprintf (stream, \"\\tmov (sp)+, r5\\n\");     \t\t\t\n     }\t\t\t\t\t\t\t\t\n     else\t\t\t\t\t\t\t\t\n     {\t\t   \n@@ -331,7 +332,7 @@ pdp11_output_function_epilogue (stream, size)\n \t    if (LOAD_FPU_REG_P(i)\n \t\t&& regs_ever_live[i]\n \t\t&& ! call_used_regs[i])\n-\t      fprintf(stream, \"\\tfldd (sp)+, %s\\n\", reg_names[i]);\n+\t      fprintf(stream, \"\\tldd (sp)+, %s\\n\", reg_names[i]);\n \t    \n \t    if (NO_LOAD_FPU_REG_P(i)\n \t\t&& regs_ever_live[i]\n@@ -340,8 +341,8 @@ pdp11_output_function_epilogue (stream, size)\n \t\tif (! LOAD_FPU_REG_P(via_ac))\n \t\t    abort();\n \t\t    \n-\t\tfprintf(stream, \"\\tfldd (sp)+, %s\\n\", reg_names[via_ac]);\n-\t\tfprintf(stream, \"\\tfstd %s, %s\\n\", reg_names[via_ac], reg_names[i]);\n+\t\tfprintf(stream, \"\\tldd (sp)+, %s\\n\", reg_names[via_ac]);\n+\t\tfprintf(stream, \"\\tstd %s, %s\\n\", reg_names[via_ac], reg_names[i]);\n \t    }\n \t}\n \n@@ -350,7 +351,7 @@ pdp11_output_function_epilogue (stream, size)\n \t\tfprintf(stream, \"\\tmov (sp)+, %s\\n\", reg_names[i]);\t\n \t\t\t\t\t\t\t\t\n \tif (fsize)\t\t\t\t\t\t\n-\t    fprintf((stream), \"\\tadd $%o, sp\\n\", fsize);      \t\t\n+\t    fprintf((stream), \"\\tadd $0%o, sp\\n\", (fsize)&0xffff);      \t\t\n     }\t\t\t\n \t\t\t\t\t\n     fprintf (stream, \"\\trts pc\\n\");\t\t\t\t\t\n@@ -562,7 +563,7 @@ output_move_quad (operands)\n   rtx latehalf[2];\n   rtx addreg0 = 0, addreg1 = 0;\n \n-  output_asm_insn(\";; movdi/df: %1 -> %0\", operands);\n+  output_asm_insn(\";/* movdi/df: %1 -> %0 */\", operands);\n   \n   if (REG_P (operands[0]))\n     optype0 = REGOP;\n@@ -817,7 +818,7 @@ output_ascii (file, p, size)\n       register int c = p[i];\n       if (c < 0)\n \tc += 256;\n-      fprintf (file, \"%o\", c);\n+      fprintf (file, \"0%o\", c);\n       if (i < size - 1)\n \tputc (',', file);\n     }\n@@ -851,10 +852,12 @@ print_operand_address (file, addr)\n       fprintf (file, \"(%s)\", reg_names[REGNO (addr)]);\n       break;\n \n+    case PRE_MODIFY:\n     case PRE_DEC:\n       fprintf (file, \"-(%s)\", reg_names[REGNO (XEXP (addr, 0))]);\n       break;\n \n+    case POST_MODIFY:\n     case POST_INC:\n       fprintf (file, \"(%s)+\", reg_names[REGNO (XEXP (addr, 0))]);\n       break;\n@@ -1546,7 +1549,7 @@ output_addr_const_pdp11 (file, x)\n     case CONST_INT:\n       /* Should we check for constants which are too big?  Maybe cutting\n \t them off to 16 bits is OK?  */\n-      fprintf (file, \"%ho\", (unsigned short) INTVAL (x));\n+      fprintf (file, \"0%ho\", (unsigned short) INTVAL (x));\n       break;\n \n     case CONST:\n@@ -1562,7 +1565,7 @@ output_addr_const_pdp11 (file, x)\n \t  if (CONST_DOUBLE_HIGH (x))\n \t    abort (); /* Should we just silently drop the high part?  */\n \t  else\n-\t    fprintf (file, \"%ho\", (unsigned short) CONST_DOUBLE_LOW (x));\n+\t    fprintf (file, \"0%ho\", (unsigned short) CONST_DOUBLE_LOW (x));\n \t}\n       else\n \t/* We can't handle floating point constants;"}, {"sha": "96ebf521776a7f1f99f1e27703ad6d42cd60ea2e", "filename": "gcc/config/pdp11/pdp11.h", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f9979a8f2b187581436ffcef319300cf1dbb56/gcc%2Fconfig%2Fpdp11%2Fpdp11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f9979a8f2b187581436ffcef319300cf1dbb56/gcc%2Fconfig%2Fpdp11%2Fpdp11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.h?ref=e7f9979a8f2b187581436ffcef319300cf1dbb56", "patch": "@@ -20,6 +20,7 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n+#define CONSTANT_POOL_BEFORE_FUNCTION\t0\n \n /* check whether load_fpu_reg or not */\n #define LOAD_FPU_REG_P(x) ((x)>=8 && (x)<=11)\n@@ -702,7 +703,7 @@ extern int may_call_alloca;\n /* Nonzero if the constant value X is a legitimate general operand.\n    It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n \n-#define LEGITIMATE_CONSTANT_P(X) (1)\n+#define LEGITIMATE_CONSTANT_P(X) (TARGET_FPU? 1: !(GET_CODE(X) == CONST_DOUBLE))\n \n /* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n    and check its validity for a certain class.\n@@ -773,6 +774,29 @@ extern int may_call_alloca;\n \t&& GET_CODE (XEXP (operand, 0)) == REG\t\t\t\t\\\n \t&& REG_OK_FOR_BASE_P (XEXP (operand, 0)))\t\t\t\\\n       goto ADDR;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    /* accept -(SP) -- which uses PRE_MODIFY for byte mode */\t\t\\\n+    if (GET_CODE (operand) == PRE_MODIFY\t\t\t\t\\\n+\t&& GET_CODE (XEXP (operand, 0)) == REG\t\t\t\t\\\n+\t&& REGNO (XEXP (operand, 0)) == 6        \t        \t\\\n+\t&& GET_CODE ((xfoob = XEXP (operand, 1))) == PLUS\t\t\\\n+\t&& GET_CODE (XEXP (xfoob, 0)) == REG\t\t\t\t\\\n+\t&& REGNO (XEXP (xfoob, 0)) == 6\t        \t        \t\\\n+\t&& CONSTANT_P (XEXP (xfoob, 1))                                 \\\n+\t&& INTVAL (XEXP (xfoob,1)) == -2)      \t               \t\t\\\n+      goto ADDR;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    /* accept (SP)+ -- which uses POST_MODIFY for byte mode */\t\t\\\n+    if (GET_CODE (operand) == POST_MODIFY\t\t\t\t\\\n+\t&& GET_CODE (XEXP (operand, 0)) == REG\t\t\t\t\\\n+\t&& REGNO (XEXP (operand, 0)) == 6        \t        \t\\\n+\t&& GET_CODE ((xfoob = XEXP (operand, 1))) == PLUS\t\t\\\n+\t&& GET_CODE (XEXP (xfoob, 0)) == REG\t\t\t\t\\\n+\t&& REGNO (XEXP (xfoob, 0)) == 6\t        \t        \t\\\n+\t&& CONSTANT_P (XEXP (xfoob, 1))                                 \\\n+\t&& INTVAL (XEXP (xfoob,1)) == 2)      \t               \t\t\\\n+      goto ADDR;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n     \t\t\t\t\t\t\t\t\t\\\n     /* handle another level of indirection ! */\t\t\t\t\\\n     if (GET_CODE(operand) != MEM)\t\t\t\t\t\\\n@@ -1129,7 +1153,7 @@ fprintf (FILE, \"$help$: . = .+8 ; space for tmp moves!\\n\")\t\\\n       char buf[30];\t\t\t\t\t\t\t\\\n       REAL_VALUE_FROM_CONST_DOUBLE (r, X);\t\t\t\t\\\n       REAL_VALUE_TO_DECIMAL (r, buf, -1);\t\t\t\t\\\n-      fprintf (FILE, \"#%s\", buf); }\t\t\t\t\t\\\n+      fprintf (FILE, \"$0F%s\", buf); }\t\t\t\t\t\\\n   else { putc ('$', FILE); output_addr_const_pdp11 (FILE, X); }}\n \f\n /* Print a memory address as an operand to reference that memory location.  */"}, {"sha": "2b8747fd0578d20b32dbe0576722308202bbcbf8", "filename": "gcc/config/pdp11/pdp11.md", "status": "modified", "additions": 89, "deletions": 76, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f9979a8f2b187581436ffcef319300cf1dbb56/gcc%2Fconfig%2Fpdp11%2Fpdp11.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f9979a8f2b187581436ffcef319300cf1dbb56/gcc%2Fconfig%2Fpdp11%2Fpdp11.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.md?ref=e7f9979a8f2b187581436ffcef319300cf1dbb56", "patch": "@@ -621,12 +621,12 @@\n ;; Move instructions\n \n (define_insn \"movdi\"\n-  [(set (match_operand:DI 0 \"general_operand\" \"=g\")\n-\t(match_operand:DI 1 \"general_operand\" \"g\"))]\n+  [(set (match_operand:DI 0 \"general_operand\" \"=g,rm,m\")\n+\t(match_operand:DI 1 \"general_operand\" \"m,r,a\"))]\n   \"\"\n   \"* return output_move_quad (operands);\"\n ;; what's the mose expensive code - say twice movsi = 16\n-  [(set_attr \"length\" \"16\")])\n+  [(set_attr \"length\" \"16,16,16\")])\n \n (define_insn \"movsi\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=r,r,r,rm,m\")\n@@ -651,8 +651,8 @@\n   [(set_attr \"length\" \"1,2,2,3\")])\n \n (define_insn \"movqi\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=rR,rR,Q,Q\")\n-\t(match_operand:QI 1 \"general_operand\" \"rRN,Qi,rRN,Qi\"))]\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=g\")\n+\t(match_operand:QI 1 \"general_operand\" \"g\"))]\n   \"\"\n   \"*\n {\n@@ -661,17 +661,22 @@\n \n   return \\\"movb %1, %0\\\";\n }\"\n-  [(set_attr \"length\" \"1,2,2,3\")])\n+  [(set_attr \"length\" \"1\")])\n \n ;; do we have to supply all these moves? e.g. to \n ;; NO_LOAD_FPU_REGs ? \n (define_insn \"movdf\"\n-  [(set (match_operand:DF 0 \"general_operand\" \"=f,R,f,Q,f,m\")\n-        (match_operand:DF 1 \"general_operand\" \"fR,f,Q,f,F,m\"))]\n+  [(set (match_operand:DF 0 \"general_operand\" \"=a,fR,a,Q,m\")\n+        (match_operand:DF 1 \"general_operand\" \"fFR,a,Q,a,m\"))]\n   \"\"\n-  \"* return output_move_quad (operands);\"\n+  \"* if (which_alternative ==0)\n+       return \\\"ldd %1, %0\\\";\n+     else if (which_alternative == 1)\n+       return \\\"std %1, %0\\\";\n+     else \n+       return output_move_quad (operands); \"\n ;; just a guess..\n-  [(set_attr \"length\" \"1,1,2,2,5,16\")])\n+  [(set_attr \"length\" \"1,1,5,5,16\")])\n \n (define_insn \"movsf\"\n   [(set (match_operand:SF 0 \"general_operand\" \"=g,r,g\")\n@@ -760,7 +765,7 @@\n   [(set (match_operand:HI 0 \"general_operand\" \"=r\")\n \t(zero_extend:HI (match_operand:QI 1 \"general_operand\" \"0\")))]\n   \"\"\n-  \"bic $(256*255), %0\"\n+  \"bic $0177400, %0\"\n   [(set_attr \"length\" \"2\")])\n \t\t\t \n (define_expand \"zero_extendhisi2\"\n@@ -919,7 +924,7 @@\n        rtx latehalf[2];\n \n        latehalf[0] = NULL; \n-       latehalf[1] = gen_rtx_REG (HImode, REGNO (operands[0]) + 1);\n+       latehalf[1] = gen_rtx_REG (HImode, REGNO (operands[1]) + 1);\n        output_asm_insn(\\\"mov %1, -(sp)\\\", latehalf);\n        output_asm_insn(\\\"mov %1, -(sp)\\\", operands);\n        \n@@ -1067,7 +1072,7 @@\n \treturn \\\"decb %0\\\";\n     }\n \n-  return \\\"addb %2, %0\\\";\n+  return \\\"add %2, %0\\\";\n }\"\n   [(set_attr \"length\" \"1,2,2,3\")])\n \n@@ -1143,53 +1148,14 @@\n   if (GET_CODE (operands[2]) == CONST_INT)\n     abort();\n \n-  return \\\"subb %2, %0\\\";\n+  return \\\"sub %2, %0\\\";\n }\"\n   [(set_attr \"length\" \"1,2,2,3\")])\n \n ;;;;- and instructions\n ;; Bit-and on the pdp (like on the VAX) is done with a clear-bits insn.\n-(define_expand \"andsi3\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n-\t(and:SI (match_operand:SI 1 \"general_operand\" \"0\")\n-\t\t(not:SI (match_operand:SI 2 \"general_operand\" \"g\"))))]\n-  \"\"\n-  \"\n-{\n-  if (GET_CODE (operands[2]) == CONST_INT)\n-    operands[2] = GEN_INT (~INTVAL (operands[2]));\n-  else\n-    operands[2] = expand_unop (SImode, one_cmpl_optab, operands[2], 0, 1);\n-}\")\n \n-(define_expand \"andhi3\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=g\")\n-\t(and:HI (match_operand:HI 1 \"general_operand\" \"0\")\n-\t\t(not:HI (match_operand:HI 2 \"general_operand\" \"g\"))))]\n-  \"\"\n-  \"\n-{\n-  if (GET_CODE (operands[2]) == CONST_INT)\n-    operands[2] = GEN_INT (~INTVAL (operands[2]));\n-  else\n-    operands[2] = expand_unop (HImode, one_cmpl_optab, operands[2], 0, 1);\n-}\")\n-\n-(define_expand \"andqi3\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=g\")\n-\t(and:QI (match_operand:QI 1 \"general_operand\" \"0\")\n-\t\t(not:QI (match_operand:QI 2 \"general_operand\" \"g\"))))]\n-  \"\"\n-  \"\n-{\n-  rtx op = operands[2];\n-  if (GET_CODE (op) == CONST_INT)\n-    operands[2] = GEN_INT (((1 << 8) - 1) & ~INTVAL (op));\n-  else\n-    operands[2] = expand_unop (QImode, one_cmpl_optab, op, 0, 1);\n-}\")\n-\n-(define_insn \"andcbsi3\"\n+(define_insn \"andsi3\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=r,r,o,o,r,r,r,o,o,o\")\n         (and:SI (match_operand:SI 1 \"general_operand\" \"%0,0,0,0,0,0,0,0,0,0\")\n                 (not:SI (match_operand:SI 2 \"general_operand\" \"r,o,r,o,I,J,K,I,J,K\"))))]\n@@ -1237,15 +1203,15 @@\n }\"\n   [(set_attr \"length\" \"2,4,4,6,2,2,4,3,3,6\")])\n \n-(define_insn \"andcbhi3\"\n+(define_insn \"andhi3\"\n   [(set (match_operand:HI 0 \"general_operand\" \"=rR,rR,Q,Q\")\n \t(and:HI (match_operand:HI 1 \"general_operand\" \"0,0,0,0\")\n \t\t(not:HI (match_operand:HI 2 \"general_operand\" \"rR,Qi,rR,Qi\"))))]\n   \"\"\n   \"bic %2, %0\"\n   [(set_attr \"length\" \"1,2,2,3\")])\n \n-(define_insn \"andcbqi3\"\n+(define_insn \"andqi3\"\n   [(set (match_operand:QI 0 \"general_operand\" \"=rR,rR,Q,Q\")\n \t(and:QI (match_operand:QI 1 \"general_operand\" \"0,0,0,0\")\n \t\t(not:QI (match_operand:QI 2 \"general_operand\" \"rR,Qi,rR,Qi\"))))]\n@@ -1319,9 +1285,9 @@\n \n ;;- xor instructions\n (define_insn \"xorsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r,r\")\n-        (xor:SI (match_operand:SI 1 \"register_operand\" \"%0,0,0,0\")\n-                  (match_operand:SI 2 \"arith_operand\" \"r,I,J,K\")))]\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (xor:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n+                (match_operand:SI 2 \"arith_operand\" \"r\")))]\n   \"TARGET_40_PLUS\"\n   \"*\n { /* Here we trust that operands don't overlap */\n@@ -1342,18 +1308,8 @@\n       return \\\"\\\";\n     }\n \n-  lateoperands[2] = GEN_INT ((INTVAL (operands[2]) >> 16) & 0xffff);\n-  operands[2] = GEN_INT (INTVAL(operands[2]) & 0xffff);\n-  \n-  if (INTVAL (operands[2]))\n-    output_asm_insn (\\\"xor %2, %0\\\", operands);\n-\n-  if (INTVAL (lateoperands[2]))\n-    output_asm_insn (\\\"xor %2, %0\\\", lateoperands);\n-\n-  return \\\"\\\";\n }\"\n-  [(set_attr \"length\" \"2,1,1,2\")])\n+  [(set_attr \"length\" \"2\")])\n \n (define_insn \"xorhi3\"\n   [(set (match_operand:HI 0 \"general_operand\" \"=rR,Q\")\n@@ -1373,10 +1329,12 @@\n   [(set_attr \"length\" \"1,2\")])\n \n (define_insn \"one_cmplqi2\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=rR,Q\")\n-        (not:QI (match_operand:QI 1 \"general_operand\" \"0,0\")))]\n+  [(set (match_operand:QI 0 \"general_operand\" \"=rR,rR\")\n+        (not:QI (match_operand:QI 1 \"general_operand\" \"0,g\")))]\n   \"\"\n-  \"comb %0\"\n+  \"@\n+  comb %0\n+  movb %1, %0\\; comb %0\"\n   [(set_attr \"length\" \"1,2\")])\n \n ;;- arithmetic shift instructions\n@@ -1423,6 +1381,38 @@\n   \"asr %0\"\n   [(set_attr \"length\" \"1,2\")])\n \n+;; lsr\n+(define_insn \"\" \n+  [(set (match_operand:HI 0 \"general_operand\" \"=rR,Q\")\n+\t(lshiftrt:HI (match_operand:HI 1 \"general_operand\" \"0,0\")\n+\t\t   (const_int 1)))]\n+  \"\"\n+  \"clc\\;ror %0\"\n+  [(set_attr \"length\" \"1,2\")])\n+\n+(define_insn \"lshrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"general_operand\" \"0\")\n+                   (const_int 1)))]\n+  \"\"\n+{ /* Here we trust that operands don't overlap */\n+\n+  rtx lateoperands[2];\n+\n+  lateoperands[0] = operands[0];\n+  operands[0] = gen_rtx_REG (HImode, REGNO (operands[0]) + 1);\n+\n+  lateoperands[1] = operands[1];\n+  operands[1] = gen_rtx_REG (HImode, REGNO (operands[1]) + 1);\n+\n+  output_asm_insn (\\\"clc\\\", operands);\n+  output_asm_insn (\\\"ror %0\\\", lateoperands);\n+  output_asm_insn (\\\"ror %0\\\", operands);\n+\n+  return \\\"\\\";\n+}\n+  [(set_attr \"length\" \"5\")])\n+\n ;; shift is by arbitrary count is expensive, \n ;; shift by one cheap - so let's do that, if\n ;; space doesn't matter\n@@ -1620,6 +1610,29 @@\n   \"{negd|negf} %0\"\n   [(set_attr \"length\" \"1,2\")])\n \n+(define_insn \"negsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(neg:SI (match_operand:SI 1 \"general_operand\" \"0\")))]\n+  \"\"\n+{ /* Here we trust that operands don't overlap */\n+\n+  rtx lateoperands[2];\n+\n+  lateoperands[0] = operands[0];\n+  operands[0] = gen_rtx_REG (HImode, REGNO (operands[0]) + 1);\n+\n+  lateoperands[1] = operands[1];\n+  operands[1] = gen_rtx_REG (HImode, REGNO (operands[1]) + 1);\n+\n+  output_asm_insn (\\\"com %0\\\", operands);\n+  output_asm_insn (\\\"com %0\\\", lateoperands);\n+  output_asm_insn (\\\"inc %0\\\", operands);\n+  output_asm_insn (\\\"adc %0\\\", lateoperands);\n+\n+  return \\\"\\\";\n+}\n+  [(set_attr \"length\" \"5\")])\n+\n (define_insn \"neghi2\"\n   [(set (match_operand:HI 0 \"general_operand\" \"=rR,Q\")\n \t(neg:HI (match_operand:HI 1 \"general_operand\" \"0,0\")))]\n@@ -1670,7 +1683,7 @@\n ;;- jump to subroutine\n \n (define_insn \"call\"\n-  [(call (match_operand:HI 0 \"general_operand\" \"R,Q\")\n+  [(call (match_operand:HI 0 \"general_operand\" \"rR,Q\")\n \t (match_operand:HI 1 \"general_operand\" \"g,g\"))\n ;;   (use (reg:HI 0)) what was that ???\n   ]\n@@ -1682,7 +1695,7 @@\n ;;- jump to subroutine\n (define_insn \"call_value\"\n   [(set (match_operand 0 \"\" \"\")\n-\t(call (match_operand:HI 1 \"general_operand\" \"R,Q\")\n+\t(call (match_operand:HI 1 \"general_operand\" \"rR,Q\")\n \t      (match_operand:HI 2 \"general_operand\" \"g,g\")))\n ;;   (use (reg:HI 0)) - what was that ????\n   ]\n@@ -1788,7 +1801,7 @@\n   \"\")\n \n (define_insn \"\"\n-  [(set (subreg:HI (match_operand:SI 0 \"general_operand\" \"=r\") 4)\n+  [(set (subreg:HI (match_operand:SI 0 \"general_operand\" \"=r\") 2)\n \t(mod:HI (match_operand:SI 1 \"general_operand\" \"0\")\n \t\t(match_operand:HI 2 \"general_operand\" \"g\")))]\n   \"TARGET_45\""}, {"sha": "0231a7b38d6cb66c749a006b7c583b8bf7812304", "filename": "gcc/config/pdp11/t-pdp11", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f9979a8f2b187581436ffcef319300cf1dbb56/gcc%2Fconfig%2Fpdp11%2Ft-pdp11", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f9979a8f2b187581436ffcef319300cf1dbb56/gcc%2Fconfig%2Fpdp11%2Ft-pdp11", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Ft-pdp11?ref=e7f9979a8f2b187581436ffcef319300cf1dbb56", "patch": "@@ -1 +1,15 @@\n TARGET_LIBGCC2_CFLAGS = -O2 -mfloat32\n+LIB2FUNCS_EXTRA = $(srcdir)/config/udivmod.c $(srcdir)/config/udivmodsi4.c\n+# floating point emulation libraries\n+\n+FPBIT = fp-bit.c\n+DPBIT = dp-bit.c\n+\n+fp-bit.c: $(srcdir)/config/fp-bit.c\n+\techo '#define FLOAT'                            > fp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c                   >> fp-bit.c\n+\n+dp-bit.c: $(srcdir)/config/fp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c > dp-bit.c\n+\n+MULTILIB_OPTIONS = msoft-float"}]}