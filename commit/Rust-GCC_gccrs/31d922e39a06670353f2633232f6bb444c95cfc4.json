{"sha": "31d922e39a06670353f2633232f6bb444c95cfc4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzFkOTIyZTM5YTA2NjcwMzUzZjI2MzMyMzJmNmJiNDQ0Yzk1Y2ZjNA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-01-31T15:56:44Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-01-31T15:56:44Z"}, "message": "[multiple changes]\n\n2014-01-31  Yannick Moy  <moy@adacore.com>\n\n\t* erroutc.adb (Validate_Specific_Warnings): Remove special case for\n\tGNATprove_Mode.\n\n2014-01-31  Robert Dewar  <dewar@adacore.com>\n\n\t* prj-attr.ads (First_Attribute_Of): Returns Empty_Attribute\n\tfor Unknown_Package.\n\t* sem_ch6.adb, sem_attr.adb: Minor comment addition.\n\n2014-01-31  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_util.adb (Build_Allocate_Deallocate_Proc): Rewrite\n\tthe logic that generates a runtime check to determine the\n\tcontrolled status of the object about to be allocated or\n\tdeallocated. Class-wide types now always use a runtime check\n\teven if they appear as generic actuals.\n\t(Find_Object): Detect\n\ta special case that involves interface class-wide types because\n\tthe object appears as a complex expression.\n\nFrom-SVN: r207356", "tree": {"sha": "3def43a0629d80c2f7ff9023f31cbf6d9f27ad75", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3def43a0629d80c2f7ff9023f31cbf6d9f27ad75"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/31d922e39a06670353f2633232f6bb444c95cfc4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31d922e39a06670353f2633232f6bb444c95cfc4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31d922e39a06670353f2633232f6bb444c95cfc4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31d922e39a06670353f2633232f6bb444c95cfc4/comments", "author": null, "committer": null, "parents": [{"sha": "5b6f12c7bf5e8699aee3f4c04e68c59906668e50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b6f12c7bf5e8699aee3f4c04e68c59906668e50", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b6f12c7bf5e8699aee3f4c04e68c59906668e50"}], "stats": {"total": 231, "additions": 136, "deletions": 95}, "files": [{"sha": "27d0c3fff13ec5b4be8d83934a175d235aa2dd30", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31d922e39a06670353f2633232f6bb444c95cfc4/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31d922e39a06670353f2633232f6bb444c95cfc4/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=31d922e39a06670353f2633232f6bb444c95cfc4", "patch": "@@ -1,3 +1,25 @@\n+2014-01-31  Yannick Moy  <moy@adacore.com>\n+\n+\t* erroutc.adb (Validate_Specific_Warnings): Remove special case for\n+\tGNATprove_Mode.\n+\n+2014-01-31  Robert Dewar  <dewar@adacore.com>\n+\n+\t* prj-attr.ads (First_Attribute_Of): Returns Empty_Attribute\n+\tfor Unknown_Package.\n+\t* sem_ch6.adb, sem_attr.adb: Minor comment addition.\n+\n+2014-01-31  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_util.adb (Build_Allocate_Deallocate_Proc): Rewrite\n+\tthe logic that generates a runtime check to determine the\n+\tcontrolled status of the object about to be allocated or\n+\tdeallocated. Class-wide types now always use a runtime check\n+\teven if they appear as generic actuals.\n+\t(Find_Object): Detect\n+\ta special case that involves interface class-wide types because\n+\tthe object appears as a complex expression.\n+\n 2014-01-31  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_ch6.adb (Process_Formals): In Ada2012 mode, place"}, {"sha": "541cd432f539e9b304eab9ee7182b488a63d9ba4", "filename": "gcc/ada/erroutc.adb", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31d922e39a06670353f2633232f6bb444c95cfc4/gcc%2Fada%2Ferroutc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31d922e39a06670353f2633232f6bb444c95cfc4/gcc%2Fada%2Ferroutc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferroutc.adb?ref=31d922e39a06670353f2633232f6bb444c95cfc4", "patch": "@@ -1322,13 +1322,6 @@ package body Erroutc is\n \n                elsif not SWE.Used\n \n-                 --  Do not issue this warning in GNATprove_Mode, as not\n-                 --  all warnings may be generated in this mode, and pragma\n-                 --  Warnings(Off) may correspond to warnings generated by the\n-                 --  formal verification backend instead of frontend warnings.\n-\n-                 and then not GNATprove_Mode\n-\n                  --  Do not issue this warning for -Wxxx messages since the\n                  --  back-end doesn't report the information.\n "}, {"sha": "c79c06739fa3807977f059d3587dac06a6cb0f54", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 104, "deletions": 81, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31d922e39a06670353f2633232f6bb444c95cfc4/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31d922e39a06670353f2633232f6bb444c95cfc4/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=31d922e39a06670353f2633232f6bb444c95cfc4", "patch": "@@ -511,13 +511,32 @@ package body Exp_Util is\n \n          Expr := E;\n          loop\n-            if Nkind_In (Expr, N_Qualified_Expression,\n-                               N_Unchecked_Type_Conversion)\n-            then\n+            if Nkind (Expr) = N_Explicit_Dereference then\n+               Expr := Prefix (Expr);\n+\n+            elsif Nkind (Expr) = N_Qualified_Expression then\n                Expr := Expression (Expr);\n \n-            elsif Nkind (Expr) = N_Explicit_Dereference then\n-               Expr := Prefix (Expr);\n+            elsif Nkind (Expr) = N_Unchecked_Type_Conversion then\n+\n+               --  When interface class-wide types are involved in allocation,\n+               --  the expander introduces several levels of address arithmetic\n+               --  to perform dispatch table displacement. In this scenario the\n+               --  object appears as:\n+               --\n+               --    Tag_Ptr (Base_Address (<object>'Address))\n+               --\n+               --  Detect this case and utilize the whole expression as the\n+               --  \"object\" since it now points to the proper dispatch table.\n+\n+               if Is_RTE (Etype (Expr), RE_Tag_Ptr) then\n+                  exit;\n+\n+               --  Continue to strip the object\n+\n+               else\n+                  Expr := Expression (Expr);\n+               end if;\n \n             else\n                exit;\n@@ -790,101 +809,105 @@ package body Exp_Util is\n \n          --  h) Is_Controlled\n \n-         --  Generate a run-time check to determine whether a class-wide object\n-         --  is truly controlled.\n-\n          if Needs_Finalization (Desig_Typ) then\n-            if Is_Class_Wide_Type (Desig_Typ)\n-              or else Is_Generic_Actual_Type (Desig_Typ)\n-            then\n-               declare\n-                  Flag_Id   : constant Entity_Id := Make_Temporary (Loc, 'F');\n-                  Flag_Expr : Node_Id;\n-                  Param     : Node_Id;\n-                  Temp      : Node_Id;\n+            declare\n+               Flag_Id   : constant Entity_Id := Make_Temporary (Loc, 'F');\n+               Flag_Expr : Node_Id;\n+               Param     : Node_Id;\n+               Temp      : Node_Id;\n \n-               begin\n-                  if Is_Allocate then\n-                     Temp := Find_Object (Expression (Expr));\n-                  else\n-                     Temp := Expr;\n-                  end if;\n+            begin\n+               if Is_Allocate then\n+                  Temp := Find_Object (Expression (Expr));\n+               else\n+                  Temp := Expr;\n+               end if;\n \n-                  --  Processing for generic actuals\n+               --  Processing for allocations where the expression is a subtype\n+               --  indication.\n \n-                  if Is_Generic_Actual_Type (Desig_Typ) then\n-                     Flag_Expr :=\n-                       New_Reference_To (Boolean_Literals\n-                         (Needs_Finalization (Base_Type (Desig_Typ))), Loc);\n+               if Is_Allocate\n+                 and then Is_Entity_Name (Temp)\n+                 and then Is_Type (Entity (Temp))\n+               then\n+                  Flag_Expr :=\n+                    New_Reference_To (Boolean_Literals\n+                      (Needs_Finalization (Entity (Temp))), Loc);\n \n-                  --  Processing for subtype indications\n+               --  The allocation / deallocation of a class-wide object relies\n+               --  on a runtime check to determine whether the object is truly\n+               --  controlled or not. Depending on this check, the finalization\n+               --  machinery will request or reclaim extra storage reserved for\n+               --  a list header.\n \n-                  elsif Nkind (Temp) in N_Has_Entity\n-                    and then Is_Type (Entity (Temp))\n-                  then\n-                     Flag_Expr :=\n-                       New_Reference_To (Boolean_Literals\n-                         (Needs_Finalization (Entity (Temp))), Loc);\n+               elsif Is_Class_Wide_Type (Desig_Typ) then\n \n-                  --  Generate a runtime check to test the controlled state of\n-                  --  an object for the purposes of allocation / deallocation.\n+                  --  Detect a special case where interface class-wide types\n+                  --  are involved as the object appears as:\n+                  --\n+                  --    Tag_Ptr (Base_Address (<object>'Address))\n+                  --\n+                  --  The expression already yields the proper tag, generate:\n+                  --\n+                  --    Temp.all\n \n-                  else\n-                     --  The following case arises when allocating through an\n-                     --  interface class-wide type, generate:\n-                     --\n-                     --    Temp.all\n+                  if Is_RTE (Etype (Temp), RE_Tag_Ptr) then\n+                     Param :=\n+                       Make_Explicit_Dereference (Loc,\n+                         Prefix => Relocate_Node (Temp));\n \n-                     if Is_RTE (Etype (Temp), RE_Tag_Ptr) then\n-                        Param :=\n-                          Make_Explicit_Dereference (Loc,\n-                            Prefix =>\n-                              Relocate_Node (Temp));\n+                  --  In the default case, obtain the tag of the object about\n+                  --  to be allocated / deallocated. Generate:\n+                  --\n+                  --    Temp'Tag\n \n-                     --  Generate:\n-                     --    Temp'Tag\n+                  else\n+                     Param :=\n+                       Make_Attribute_Reference (Loc,\n+                         Prefix         => Relocate_Node (Temp),\n+                         Attribute_Name => Name_Tag);\n+                  end if;\n \n-                     else\n-                        Param :=\n-                          Make_Attribute_Reference (Loc,\n-                            Prefix =>\n-                              Relocate_Node (Temp),\n-                            Attribute_Name => Name_Tag);\n-                     end if;\n+                  --  Generate:\n+                  --    Needs_Finalization (<Param>)\n \n-                     --  Generate:\n-                     --    Needs_Finalization (<Param>)\n+                  Flag_Expr :=\n+                    Make_Function_Call (Loc,\n+                      Name                   =>\n+                        New_Reference_To (RTE (RE_Needs_Finalization), Loc),\n+                      Parameter_Associations => New_List (Param));\n \n-                     Flag_Expr :=\n-                       Make_Function_Call (Loc,\n-                         Name =>\n-                           New_Reference_To (RTE (RE_Needs_Finalization), Loc),\n-                         Parameter_Associations => New_List (Param));\n-                  end if;\n+               --  Processing for generic actuals\n \n-                  --  Create the temporary which represents the finalization\n-                  --  state of the expression. Generate:\n-                  --\n-                  --    F : constant Boolean := <Flag_Expr>;\n+               elsif Is_Generic_Actual_Type (Desig_Typ) then\n+                  Flag_Expr :=\n+                    New_Reference_To (Boolean_Literals\n+                      (Needs_Finalization (Base_Type (Desig_Typ))), Loc);\n \n-                  Insert_Action (N,\n-                    Make_Object_Declaration (Loc,\n-                      Defining_Identifier => Flag_Id,\n-                      Constant_Present => True,\n-                      Object_Definition =>\n-                        New_Reference_To (Standard_Boolean, Loc),\n-                      Expression => Flag_Expr));\n+               --  The object does not require any specialized checks, it is\n+               --  known to be controlled.\n \n-                  --  The flag acts as the last actual\n+               else\n+                  Flag_Expr := New_Reference_To (Standard_True, Loc);\n+               end if;\n \n-                  Append_To (Actuals, New_Reference_To (Flag_Id, Loc));\n-               end;\n+               --  Create the temporary which represents the finalization state\n+               --  of the expression. Generate:\n+               --\n+               --    F : constant Boolean := <Flag_Expr>;\n \n-            --  The object is statically known to be controlled\n+               Insert_Action (N,\n+                 Make_Object_Declaration (Loc,\n+                   Defining_Identifier => Flag_Id,\n+                   Constant_Present    => True,\n+                   Object_Definition   =>\n+                     New_Reference_To (Standard_Boolean, Loc),\n+                    Expression          => Flag_Expr));\n \n-            else\n-               Append_To (Actuals, New_Reference_To (Standard_True, Loc));\n-            end if;\n+               Append_To (Actuals, New_Reference_To (Flag_Id, Loc));\n+            end;\n+\n+         --  The object is not controlled\n \n          else\n             Append_To (Actuals, New_Reference_To (Standard_False, Loc));"}, {"sha": "dc60cd69135e41f092d106eb795995d5ec66c1e5", "filename": "gcc/ada/prj-attr.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31d922e39a06670353f2633232f6bb444c95cfc4/gcc%2Fada%2Fprj-attr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31d922e39a06670353f2633232f6bb444c95cfc4/gcc%2Fada%2Fprj-attr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-attr.ads?ref=31d922e39a06670353f2633232f6bb444c95cfc4", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2001-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2001-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -246,7 +246,7 @@ package Prj.Attr is\n    function First_Attribute_Of\n      (Pkg : Package_Node_Id) return Attribute_Node_Id;\n    --  Returns the first attribute in the list of attributes of package Pkg.\n-   --  Returns Empty_Attribute if Pkg is Empty_Package.\n+   --  Returns Empty_Attribute if Pkg is Empty_Package or Unknown_Package.\n \n private\n    ----------------"}, {"sha": "24faf86c833013ec6464be021181c198745cceed", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31d922e39a06670353f2633232f6bb444c95cfc4/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31d922e39a06670353f2633232f6bb444c95cfc4/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=31d922e39a06670353f2633232f6bb444c95cfc4", "patch": "@@ -6149,6 +6149,11 @@ package body Sem_Attr is\n                   end;\n \n                elsif Is_Record_Type (P_Type) then\n+\n+                  --  Make sure we have an identifier. Old SPARK allowed\n+                  --  a component selection e.g. A.B in the corresponding\n+                  --  context, but we do not yet permit this for 'Update.\n+\n                   if Nkind (Comp) /= N_Identifier then\n                      Error_Msg_N (\"name should be identifier or OTHERS\", Comp);\n                   else"}, {"sha": "5b91519630f9a924cd02e4653f34c22fbb037498", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31d922e39a06670353f2633232f6bb444c95cfc4/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31d922e39a06670353f2633232f6bb444c95cfc4/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=31d922e39a06670353f2633232f6bb444c95cfc4", "patch": "@@ -1908,18 +1908,16 @@ package body Sem_Ch6 is\n                      null;\n \n                   elsif Nkind (Parent (N)) = N_Subprogram_Body\n-                    or else\n-                      Nkind_In (Parent (Parent (N)),\n-                        N_Accept_Statement,\n-                        N_Entry_Body)\n+                    or else Nkind_In (Parent (Parent (N)), N_Accept_Statement,\n+                                                           N_Entry_Body)\n                   then\n                      Error_Msg_NE\n                        (\"invalid use of untagged incomplete type&\",\n                           Designator, Typ);\n                   end if;\n \n                   --  The type must be completed in the current package. This\n-                  --  is checked at the end of the package declaraton, when\n+                  --  is checked at the end of the package declaration when\n                   --  Taft-amendment types are identified. If the return type\n                   --  is class-wide, there is no required check, the type can\n                   --  be a bona fide TAT."}]}