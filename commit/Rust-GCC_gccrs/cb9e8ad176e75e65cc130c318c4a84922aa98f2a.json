{"sha": "cb9e8ad176e75e65cc130c318c4a84922aa98f2a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2I5ZThhZDE3NmU3NWU2NWNjMTMwYzMxOGM0YTg0OTIyYWE5OGYyYQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-05-10T22:33:30Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-05-10T22:33:30Z"}, "message": "(mark_set_1, mark_used_regs): Clean up usages of ALL_NEEDED; change to\nSOME_NOT_NEEDED and set properly.\n\nFrom-SVN: r11967", "tree": {"sha": "330078c70b65206931b0f8676ecb7d5dc6c02c3f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/330078c70b65206931b0f8676ecb7d5dc6c02c3f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cb9e8ad176e75e65cc130c318c4a84922aa98f2a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb9e8ad176e75e65cc130c318c4a84922aa98f2a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb9e8ad176e75e65cc130c318c4a84922aa98f2a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb9e8ad176e75e65cc130c318c4a84922aa98f2a/comments", "author": null, "committer": null, "parents": [{"sha": "d1b0168185c85ebe41859ae9d2bdf9251103f144", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1b0168185c85ebe41859ae9d2bdf9251103f144", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1b0168185c85ebe41859ae9d2bdf9251103f144"}], "stats": {"total": 42, "additions": 21, "deletions": 21}, "files": [{"sha": "4b30a2dfff18839b575acac97dad8faa38cf32b6", "filename": "gcc/flow.c", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb9e8ad176e75e65cc130c318c4a84922aa98f2a/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb9e8ad176e75e65cc130c318c4a84922aa98f2a/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=cb9e8ad176e75e65cc130c318c4a84922aa98f2a", "patch": "@@ -2006,8 +2006,8 @@ mark_set_1 (needed, dead, x, insn, significant)\n       register int offset = regno / REGSET_ELT_BITS;\n       register REGSET_ELT_TYPE bit\n \t= (REGSET_ELT_TYPE) 1 << (regno % REGSET_ELT_BITS);\n-      REGSET_ELT_TYPE all_needed = (needed[offset] & bit);\n       REGSET_ELT_TYPE some_needed = (needed[offset] & bit);\n+      REGSET_ELT_TYPE some_not_needed = (~ needed[offset]) & bit;\n \n       /* Mark it as a significant register for this basic block.  */\n       if (significant)\n@@ -2030,17 +2030,17 @@ mark_set_1 (needed, dead, x, insn, significant)\n \t  n = HARD_REGNO_NREGS (regno, GET_MODE (reg));\n \t  while (--n > 0)\n \t    {\n+\t      REGSET_ELT_TYPE n_bit\n+\t\t= (REGSET_ELT_TYPE) 1 << ((regno + n) % REGSET_ELT_BITS);\n+\n \t      if (significant)\n-\t\tsignificant[(regno + n) / REGSET_ELT_BITS]\n-\t\t  |= (REGSET_ELT_TYPE) 1 << ((regno + n) % REGSET_ELT_BITS);\n-\t      dead[(regno + n) / REGSET_ELT_BITS]\n-\t\t|= (REGSET_ELT_TYPE) 1 << ((regno + n) % REGSET_ELT_BITS);\n+\t\tsignificant[(regno + n) / REGSET_ELT_BITS] |= n_bit;\n+\n+\t      dead[(regno + n) / REGSET_ELT_BITS] |= n_bit;\n \t      some_needed\n-\t\t|= (needed[(regno + n) / REGSET_ELT_BITS]\n-\t\t    & (REGSET_ELT_TYPE) 1 << ((regno + n) % REGSET_ELT_BITS));\n-\t      all_needed\n-\t\t&= (needed[(regno + n) / REGSET_ELT_BITS]\n-\t\t    & (REGSET_ELT_TYPE) 1 << ((regno + n) % REGSET_ELT_BITS));\n+\t\t|= (needed[(regno + n) / REGSET_ELT_BITS] & n_bit);\n+\t      some_not_needed\n+\t\t|= ((~ needed[(regno + n) / REGSET_ELT_BITS]) & n_bit);\n \t    }\n \t}\n       /* Additional data to record if this is the final pass.  */\n@@ -2092,7 +2092,7 @@ mark_set_1 (needed, dead, x, insn, significant)\n \t      reg_live_length[regno]++;\n \t    }\n \n-\t  if (all_needed)\n+\t  if (! some_not_needed)\n \t    {\n \t      /* Make a logical link from the next following insn\n \t\t that uses this register, back to this insn.\n@@ -2435,10 +2435,11 @@ mark_used_regs (needed, live, x, final, insn)\n \tregister int offset = regno / REGSET_ELT_BITS;\n \tregister REGSET_ELT_TYPE bit\n \t  = (REGSET_ELT_TYPE) 1 << (regno % REGSET_ELT_BITS);\n-\tREGSET_ELT_TYPE all_needed = needed[offset] & bit;\n \tREGSET_ELT_TYPE some_needed = needed[offset] & bit;\n+\tREGSET_ELT_TYPE some_not_needed = (~ needed[offset]) & bit;\n \n \tlive[offset] |= bit;\n+\n \t/* A hard reg in a wide mode may really be multiple registers.\n \t   If so, mark all of them just like the first.  */\n \tif (regno < FIRST_PSEUDO_REGISTER)\n@@ -2479,14 +2480,13 @@ mark_used_regs (needed, live, x, final, insn)\n \t    n = HARD_REGNO_NREGS (regno, GET_MODE (x));\n \t    while (--n > 0)\n \t      {\n-\t\tlive[(regno + n) / REGSET_ELT_BITS]\n-\t\t  |= (REGSET_ELT_TYPE) 1 << ((regno + n) % REGSET_ELT_BITS);\n-\t\tsome_needed\n-\t\t  |= (needed[(regno + n) / REGSET_ELT_BITS]\n-\t\t      & (REGSET_ELT_TYPE) 1 << ((regno + n) % REGSET_ELT_BITS));\n-\t\tall_needed\n-\t\t  &= (needed[(regno + n) / REGSET_ELT_BITS]\n-\t\t      & (REGSET_ELT_TYPE) 1 << ((regno + n) % REGSET_ELT_BITS));\n+\t\tREGSET_ELT_TYPE n_bit\n+\t\t  = (REGSET_ELT_TYPE) 1 << ((regno + n) % REGSET_ELT_BITS);\n+\n+\t\tlive[(regno + n) / REGSET_ELT_BITS] |= n_bit;\n+\t\tsome_needed |= (needed[(regno + n) / REGSET_ELT_BITS] & n_bit);\n+\t\tsome_not_needed\n+\t\t  |= ((~ needed[(regno + n) / REGSET_ELT_BITS]) & n_bit);\n \t      }\n \t  }\n \tif (final)\n@@ -2530,7 +2530,7 @@ mark_used_regs (needed, live, x, final, insn)\n \t       we do not make a REG_DEAD note; likewise if we already\n \t       made such a note.  */\n \n-\t    if (! all_needed\n+\t    if (some_not_needed\n \t\t&& ! dead_or_set_p (insn, x)\n #if 0\n \t\t&& (regno >= FIRST_PSEUDO_REGISTER || ! fixed_regs[regno])"}]}