{"sha": "1fe2d5fb0998455d5faec36e62a8919ad16c939f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWZlMmQ1ZmIwOTk4NDU1ZDVmYWVjMzZlNjJhODkxOWFkMTZjOTM5Zg==", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@redhat.com", "date": "2003-09-17T20:03:02Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@gcc.gnu.org", "date": "2003-09-17T20:03:02Z"}, "message": "GdkGraphics2D.java, [...]: New files.\n\n2003-09-17  Graydon Hoare  <graydon@redhat.com>\n\n\t* gnu/java/awt/peer/gtk/GdkGraphics2D.java,\n\tgnu/java/awt/peer/gtk/GdkPixbufDecoder.java,\n\tjni/gtk-peer/gnu_java_awt_peer_gtk_GdkGraphics2D.c,\n\tjni/gtk-peer/gnu_java_awt_peer_gtk_GdkPixbufDecoder.c:\n\tNew files.\n\nFrom-SVN: r71475", "tree": {"sha": "f6def737e08704bfb28fabae57e50f10d4bd3e3f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f6def737e08704bfb28fabae57e50f10d4bd3e3f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1fe2d5fb0998455d5faec36e62a8919ad16c939f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fe2d5fb0998455d5faec36e62a8919ad16c939f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1fe2d5fb0998455d5faec36e62a8919ad16c939f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fe2d5fb0998455d5faec36e62a8919ad16c939f/comments", "author": null, "committer": null, "parents": [{"sha": "eeae7b417a7a1e90d7da1f512048d697f5b3a4f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eeae7b417a7a1e90d7da1f512048d697f5b3a4f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eeae7b417a7a1e90d7da1f512048d697f5b3a4f6"}], "stats": {"total": 2676, "additions": 2676, "deletions": 0}, "files": [{"sha": "9b98128111b77a4a691a6c13b914c02338c88cd4", "filename": "libjava/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fe2d5fb0998455d5faec36e62a8919ad16c939f/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fe2d5fb0998455d5faec36e62a8919ad16c939f/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=1fe2d5fb0998455d5faec36e62a8919ad16c939f", "patch": "@@ -1,3 +1,11 @@\n+2003-09-17  Graydon Hoare  <graydon@redhat.com>\n+\n+\t* gnu/java/awt/peer/gtk/GdkGraphics2D.java,\n+\tgnu/java/awt/peer/gtk/GdkPixbufDecoder.java,\n+\tjni/gtk-peer/gnu_java_awt_peer_gtk_GdkGraphics2D.c,\n+\tjni/gtk-peer/gnu_java_awt_peer_gtk_GdkPixbufDecoder.c: \n+\tNew files.\n+\n 2003-09-16  Graydon Hoare  <graydon@redhat.com>\n \n \t* java/awt/BufferedImage.java (setData): Support non-component"}, {"sha": "11c0371bd08a7606dd4faa3654104d15b255178f", "filename": "libjava/gnu/java/awt/peer/gtk/GdkGraphics2D.java", "status": "added", "additions": 1146, "deletions": 0, "changes": 1146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fe2d5fb0998455d5faec36e62a8919ad16c939f/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkGraphics2D.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fe2d5fb0998455d5faec36e62a8919ad16c939f/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkGraphics2D.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkGraphics2D.java?ref=1fe2d5fb0998455d5faec36e62a8919ad16c939f", "patch": "@@ -0,0 +1,1146 @@\n+/* GdkGraphics2D.java\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.awt.peer.gtk;\n+\n+import java.awt.*;\n+import java.awt.geom.*;\n+import java.awt.font.*;\n+import java.awt.color.*;\n+import java.awt.image.*;\n+import java.awt.image.renderable.*;\n+\n+import java.text.AttributedCharacterIterator;\n+import java.util.Map;\n+import java.lang.Integer;\n+import gnu.classpath.Configuration;\n+\n+public class GdkGraphics2D extends Graphics2D\n+{\n+\n+  //////////////////////////////////////\n+  ////// State Management Methods //////\n+  //////////////////////////////////////\n+\n+  static \n+  {\n+    if (Configuration.INIT_LOAD_LIBRARY)\n+      {\n+        System.loadLibrary(\"gtkpeer\");\n+      }\n+    initStaticState ();\n+  }\n+  native static void initStaticState ();\n+  private final int native_state = GtkGenericPeer.getUniqueInteger();  \n+\n+  private Paint paint;\n+  private Stroke stroke;\n+  private Color fg;\n+  private Color bg;\n+  private Shape clip;\n+  private AffineTransform transform;\n+  private GtkComponentPeer component;\n+  private GdkFont font;  \n+\n+  native private int[] initState (GtkComponentPeer component);\n+  native private void initState (int width, int height);\n+  native private void copyState (GdkGraphics2D g);\n+  native public void dispose ();\n+\n+  public void finalize ()\n+  {\n+    dispose();\n+  }\n+\n+  public Graphics create ()\n+  {\n+    return new GdkGraphics2D (this);\n+  }\n+\n+  public Graphics create (int x, int y, int width, int height)\n+  {\n+    return new GdkGraphics2D (width, height);\n+  }\n+\n+  GdkGraphics2D (GdkGraphics2D g)\n+  {\n+    paint = g.paint;\n+    stroke = g.stroke;\n+\n+    if (g.fg.getAlpha() != -1)\n+      fg = new Color (g.fg.getRed (), g.fg.getGreen (), \n+                      g.fg.getBlue (), g.fg.getAlpha ());\n+    else \n+      fg = new Color (g.fg.getRGB ());\n+\n+    if (g.bg.getAlpha() != -1)\n+      bg = new Color(g.bg.getRed (), g.bg.getGreen (), \n+                     g.bg.getBlue (), g.bg.getAlpha ());\n+    else\n+      bg = new Color (g.bg.getRGB ());\n+\n+    if (g.clip == null)\n+      clip = null;\n+    else\n+      clip = new Rectangle (g.getClipBounds ());\n+\n+    if (g.transform == null)\n+      transform = null;\n+    else\n+      transform = new AffineTransform (g.transform);\n+\n+    component = g.component;\n+    copyState (g);\n+\n+    setColor (fg);\n+    setClip (clip);\n+    setTransform (transform);\n+  }\n+\n+  GdkGraphics2D (int width, int height)\n+  {\n+    initState (width, height);\n+    bg = Color.black;\n+    fg = Color.black;\n+    transform = new AffineTransform ();\n+  }\n+\n+  GdkGraphics2D (GtkComponentPeer component)\n+  {\n+    this.component = component;\n+    int rgb[] = initState (component);\n+    fg = new Color (rgb[0], rgb[1], rgb[2]);\n+    bg = new Color (rgb[3], rgb[4], rgb[5]);\n+    transform = new AffineTransform ();\n+  }\n+\n+\n+  ////////////////////////////////////\n+  ////// Native Drawing Methods //////\n+  ////////////////////////////////////\n+\n+  // GDK drawing methods\n+  private native void gdkDrawDrawable (GdkGraphics2D other, int x, int y);\n+\n+  // drawing utility methods\n+  private native void drawPixels (int pixels[], int w, int h, int stride);\n+  private native void setTexturePixels (int pixels[], int w, int h, int stride);\n+  private native void setGradient (double x1, double y1,\n+                                   double x2, double y2,\n+                                   int r1, int g1, int b1, int a1,\n+                                   int r2, int g2, int b2, int a2,\n+                                   boolean cyclic);\n+\n+  // simple passthroughs to cairo\n+  private native void cairoSave ();\n+  private native void cairoRestore ();\n+  private native void cairoSetMatrix (double m00, double m10, \n+                                      double m01, double m11,\n+                                      double m02, double m12);\n+  private native void cairoSetOperator (int cairoOperator);\n+  private native void cairoSetRGBColor (double red, double green, double blue);\n+  private native void cairoSetAlpha (double alpha);\n+  private native void cairoSetFillRule (int cairoFillRule);\n+  private native void cairoSetLineWidth (double width);\n+  private native void cairoSetLineCap (int cairoLineCap);\n+  private native void cairoSetLineJoin (int cairoLineJoin);\n+  private native void cairoSetDash (double dashes[], int ndash, double offset);\n+  private native void cairoSetMiterLimit (double limit);\n+  private native void cairoTranslate (double tx, double ty);\n+  private native void cairoScale (double sx, double sy);\n+  private native void cairoRotate (double angle);\n+  private native void cairoNewPath ();\n+  private native void cairoMoveTo (double x, double y);\n+  private native void cairoLineTo (double x, double y);\n+  private native void cairoCurveTo (double x1, double y1,\n+                                 double x2, double y2,\n+                                 double x3, double y3);  \n+  private native void cairoRelMoveTo (double dx, double dy);\n+  private native void cairoRelLineTo (double dx, double dy);\n+  private native void cairoRelCurveTo (double dx1, double dy1,\n+                                    double dx2, double dy2,\n+                                    double dx3, double dy3);\n+  private native void cairoRectangle (double x, double y, \n+                                   double width, double height);\n+  private native void cairoClosePath ();\n+  private native void cairoStroke ();\n+  private native void cairoFill ();\n+  private native void cairoClip ();\n+\n+\n+  /////////////////////////////////////////////\n+  ////// General Drawing Support Methods //////\n+  /////////////////////////////////////////////\n+\n+  double x;\n+  double y;\n+  private void setPos (double nx, double ny)\n+  {\n+    x = nx;\n+    y = ny;\n+  }\n+\n+  private void walkPath(PathIterator p)\n+  {\n+    double coords[] = new double[6];\n+\n+    cairoSetFillRule (p.getWindingRule ());\n+    for ( ; ! p.isDone (); p.next())\n+      {\n+        int seg = p.currentSegment (coords);\n+        switch(seg)\n+          {\n+\n+          case PathIterator.SEG_MOVETO:\n+            setPos(coords[0], coords[1]);\n+            cairoMoveTo (coords[0], coords[1]);\n+            break;\n+\n+          case PathIterator.SEG_LINETO:\n+            setPos(coords[0], coords[1]);\n+            cairoLineTo (coords[0], coords[1]);\n+            break;\n+\n+          case PathIterator.SEG_QUADTO:\n+\n+            // splitting a quadratic bezier into a cubic:\n+            // see: http://pfaedit.sourceforge.net/bezier.html\n+\n+            double x1 = x + (2.0/3.0) * (coords[0] - x);\n+            double y1 = y + (2.0/3.0) * (coords[1] - y);\n+            \n+            double x2 = x1 + (1.0/3.0) * (coords[2] - x);\n+            double y2 = y1 + (1.0/3.0) * (coords[3] - y);\n+\n+            setPos(coords[2], coords[3]);\n+            cairoCurveTo (x1, y1,\n+                          x2, y2,\n+                          coords[2], coords[3]);\n+            break;\n+\n+          case PathIterator.SEG_CUBICTO:\n+            setPos(coords[4], coords[5]);\n+            cairoCurveTo (coords[0], coords[1],\n+                          coords[2], coords[3],\n+                          coords[4], coords[5]);\n+            break;\n+\n+          case PathIterator.SEG_CLOSE:\n+            cairoClosePath ();\n+            break;\n+          }\n+      }    \n+  }\n+\n+\n+  //////////////////////////////////////////////////\n+  ////// Implementation of Graphics2D Methods //////\n+  //////////////////////////////////////////////////\n+\n+  public void draw (Shape s)\n+  {\n+\n+    if (stroke != null &&\n+        !(stroke instanceof BasicStroke))\n+      {\n+        fill (stroke.createStrokedShape (s));\n+        return;\n+      }\n+\n+    cairoSave ();\n+    cairoNewPath ();\n+    if (s instanceof Rectangle2D)\n+      {\n+        Rectangle2D r = (Rectangle2D)s;\n+        cairoRectangle (r.getX (), r.getY (), r.getWidth (), r.getHeight ());\n+      }\n+    else      \n+      walkPath (s.getPathIterator (null));\n+    cairoStroke ();\n+    cairoRestore ();\n+  }\n+\n+  public void fill(Shape s)\n+  {\n+    cairoSave();\n+    cairoNewPath ();\n+    if (s instanceof Rectangle2D)\n+      {\n+        Rectangle2D r = (Rectangle2D)s;\n+        cairoRectangle (r.getX (), r.getY (), r.getWidth (), r.getHeight ());\n+      }\n+    else      \n+      walkPath (s.getPathIterator (null));\n+    cairoFill ();\n+    cairoRestore ();\n+  }\n+\n+  public void clip (Shape s)\n+  {\n+    clip = s;\n+    cairoNewPath ();\n+    if (s instanceof Rectangle2D)\n+      {\n+        Rectangle2D r = (Rectangle2D)s;\n+        cairoRectangle (r.getX (), r.getY (), \n+                        r.getWidth (), r.getHeight ());\n+      }\n+    else      \n+      walkPath (s.getPathIterator (null));\n+    cairoClosePath ();\n+    cairoClip ();\n+  }\n+\n+  public Paint getPaint ()\n+  {\n+    return paint;\n+  }\n+\n+  public AffineTransform getTransform ()\n+  {\n+    return transform;\n+  }\n+\n+  public void setPaint (Paint p)\n+  {\n+    paint = p;\n+    if (paint instanceof Color)\n+      {\n+        setColor ((Color) paint);\n+      }\n+    else if (paint instanceof TexturePaint)\n+      {\n+        TexturePaint tp = (TexturePaint) paint;\n+        BufferedImage img = tp.getImage ();\n+        int pixels[] = img.getRGB(0, 0, img.getWidth (), \n+                                  img.getHeight (), null, \n+                                  0, img.getWidth ());\n+        setTexturePixels (pixels, img.getWidth (), \n+                          img.getHeight (), img.getWidth ());\n+      }\n+    else if (paint instanceof GradientPaint)\n+      {\n+        GradientPaint gp = (GradientPaint) paint;\n+        Point2D p1 = gp.getPoint1 ();\n+        Point2D p2 = gp.getPoint2 ();\n+        Color c1 = gp.getColor1 ();\n+        Color c2 = gp.getColor2 ();        \n+        setGradient (p1.getX (), p1.getY (),\n+                     p2.getX (), p2.getY (),\n+                     c1.getRed (), c1.getGreen (), \n+                     c1.getBlue (), c1.getAlpha (),\n+                     c2.getRed (), c2.getGreen (), \n+                     c2.getBlue (), c2.getAlpha (),\n+                     gp.isCyclic ());\n+      }\n+    else\n+      throw new java.lang.UnsupportedOperationException ();\n+  }\n+\n+  public void setTransform (AffineTransform tx)\n+  {\n+    transform = tx;\n+    if (transform != null)\n+      {\n+        double m[] = new double[6];\n+        transform.getMatrix (m);\n+        cairoSetMatrix (m[0], m[1], m[2], m[3], m[4], m[5]);\n+      }\n+  }\n+\n+  public void transform (AffineTransform tx)\n+  {\n+    if (transform == null)\n+      transform = new AffineTransform (tx);\n+    else\n+      transform.concatenate (tx);\n+    setTransform (transform);\n+  }\n+\n+  public void rotate(double theta)\n+  {\n+    if (transform != null)\n+      transform.rotate (theta);\n+    cairoRotate (theta);\n+  }\n+\n+  public void rotate(double theta, double x, double y)\n+  {\n+    if (transform != null)\n+      transform.rotate (theta, x, y);\n+    cairoTranslate (x, y);\n+    cairoRotate (theta);\n+    cairoTranslate (-x, -y);\n+  }\n+\n+  public void scale(double sx, double sy)\n+  {\n+    if (transform != null)\n+      transform.scale (sx, sy);\n+    cairoScale (sx, sy);\n+  }\n+\n+  public void translate (double tx, double ty)\n+  {\n+    if (transform != null)\n+      transform.translate (tx, ty);\n+    cairoTranslate (tx, ty);\n+  }\n+\n+  public void translate (int x, int y)\n+  {\n+    translate ((double) x, (double) y);\n+  }\n+\n+  public Stroke getStroke()\n+  {\n+    return stroke;\n+  }\n+\n+  public void setStroke (Stroke st)\n+  {\n+    stroke = st;\n+    if (stroke instanceof BasicStroke)\n+      {\n+        BasicStroke bs = (BasicStroke) stroke;\n+        cairoSetLineCap (bs.getEndCap());\n+        cairoSetLineWidth (bs.getLineWidth());\n+        cairoSetLineJoin (bs.getLineJoin());\n+        cairoSetMiterLimit (bs.getMiterLimit());\n+        float dashes[] = bs.getDashArray();\n+        if (dashes != null)\n+          {\n+            double double_dashes[] = new double[dashes.length];\n+            for (int i = 0; i < dashes.length; i++)\n+              double_dashes[i] = dashes[i];\n+            cairoSetDash (double_dashes, double_dashes.length, \n+                          (double) bs.getDashPhase ());        \n+          }\n+      }\n+  }\n+\n+\n+  ////////////////////////////////////////////////\n+  ////// Implementation of Graphics Methods //////\n+  ////////////////////////////////////////////////\n+\n+  public void setPaintMode () \n+  { \n+    setComposite (java.awt.AlphaComposite.Xor); \n+  }\n+\n+  public void setXORMode (Color c) \n+  { \n+    setComposite (new BitwiseXorComposite (c)); \n+  }\n+\n+  public void setColor (Color c)\n+  {\n+    fg = c;\n+    cairoSetRGBColor (fg.getRed() / 255.0, \n+                      fg.getGreen() / 255.0, \n+                      fg.getBlue() / 255.0);\n+    cairoSetAlpha ((fg.getAlpha() & 255) / 255.0);\n+  }\n+\n+  public Color getColor ()\n+  {\n+    return fg;\n+  }\n+\n+  public void clipRect (int x, int y, int width, int height)\n+  {\n+    // this is *slightly* different than all the other clip functions: it\n+    // intersects the clip area with the new clip rectangle. obviously.  of\n+    // course, since Shape doesn't *have* any way of intersecting with a\n+    // rectangle, we will promote the current clipping region to its\n+    // bounding rectangle and then intersect with that.\n+    if (clip == null)\n+      {\n+        cairoNewPath ();\n+        cairoRectangle (x, y, width, height);\n+        cairoClosePath ();\n+        cairoClip ();\n+        clip = new Rectangle (x, y, width, height);\n+      }\n+    else\n+      {\n+        clip (clip.getBounds ().intersection \n+              (new Rectangle (x, y, width, height)));\n+      }\n+  }\n+\n+  public Shape getClip ()\n+  {\n+    return clip;\n+  }\n+\n+  public Rectangle getClipBounds ()\n+  {\n+    if (clip == null)\n+      return null;\n+    else\n+      return clip.getBounds ();\n+  }\n+\n+  public void setClip (int x, int y, int width, int height)\n+  {\n+    cairoNewPath ();\n+    cairoRectangle (x, y, width, height);\n+    cairoClosePath ();\n+    cairoClip ();\n+    clip = new Rectangle (x, y, width, height);\n+  }\n+\n+  public void setClip (Shape s)\n+  {\n+    clip (s);\n+  }\n+\n+  public void draw3DRect(int x, int y, int width, \n+                         int height, boolean raised)\n+  {\n+    Color std = fg;\n+    Color light = std.brighter();\n+    Color dark = std.darker();\n+\n+    if (!raised)\n+      {\n+        Color t = light;\n+        light = dark;\n+        dark = t;\n+      }\n+    \n+    double x1 = (double) x;\n+    double x2 = (double) x + width;\n+\n+    double y1 = (double) y;\n+    double y2 = (double) y + height;\n+\n+    cairoSave ();\n+    \n+    cairoNewPath ();\n+    setColor (light);\n+    cairoMoveTo (x1, y1);\n+    cairoLineTo (x2, y1);\n+    cairoLineTo (x2, y2);\n+    cairoStroke ();\n+    \n+    cairoNewPath ();\n+    setColor (dark);\n+    cairoMoveTo (x1, y1);\n+    cairoLineTo (x1, y2);\n+    cairoLineTo (x2, y2);\n+    cairoStroke ();\n+    \n+    cairoRestore ();    \n+    setColor (std);\n+\n+  }\n+\n+  public void fill3DRect(int x, int y, int width, \n+                         int height, boolean raised)\n+  {\n+    double step = 1.0;\n+    if (stroke != null && stroke instanceof BasicStroke)\n+      {\n+        BasicStroke bs = (BasicStroke) stroke;\n+        step = bs.getLineWidth();\n+      }\n+\n+    Color bright = fg.brighter ();\n+    Color dark = fg.darker ();\n+      \n+    draw3DRect (x, y, width, height, raised);\n+    \n+    cairoSave ();\n+    cairoTranslate (step/2.0, step/2.0);\n+    cairoNewPath ();\n+    cairoRectangle ((double) x, (double) y, \n+                    ((double) width) - step, \n+                    ((double) height) - step );\n+    cairoClosePath ();\n+    cairoFill ();\n+    cairoRestore ();\n+  }\n+\n+\n+  public void drawRect (int x, int y, int width, int height)\n+  {\n+    draw(new Rectangle (x, y, width, height));\n+  }\n+\n+  public void fillRect (int x, int y, int width, int height)\n+  {\n+    fill(new Rectangle (x, y, width, height));\n+  }\n+\n+  public void clearRect (int x, int y, int width, int height)\n+  {\n+    cairoSave ();\n+    cairoSetRGBColor (bg.getRed() / 255.0, \n+                      bg.getGreen() / 255.0, \n+                      bg.getBlue() / 255.0);\n+    cairoSetAlpha (1.0);\n+    cairoNewPath ();\n+    cairoRectangle (x, y, width, height);\n+    cairoClosePath ();\n+    cairoFill ();\n+    cairoRestore ();\n+  }\n+\n+  public void setBackground(Color c)\n+  {\n+    bg = c;\n+  }\n+\n+\n+  public Color getBackground()\n+  {\n+    return bg;\n+  }\n+\n+\n+  private void doPolygon(int[] xPoints, int[] yPoints, int nPoints, \n+                         boolean close, boolean fill)\n+  {    \n+    if (nPoints < 1)\n+      return;\n+    GeneralPath gp = new GeneralPath ();\n+    gp.moveTo ((float)xPoints[0], (float)yPoints[0]);\n+    for (int i = 1; i < nPoints; i++)\n+      gp.lineTo ((float)xPoints[i], (float)yPoints[i]);\n+    \n+    if (close)\n+      gp.closePath ();\n+\n+    Shape sh = gp;\n+    if (fill == false &&\n+        stroke != null &&\n+        !(stroke instanceof BasicStroke))\n+      {\n+        sh = stroke.createStrokedShape (gp);\n+        fill = true;\n+      }\n+    \n+    if (fill) \n+      fill (sh);\n+    else \n+      draw (sh);\n+  }\n+\n+  public void drawLine (int x1, int y1, int x2, int y2)\n+  {\n+    int xp[] = new int[2];\n+    int yp[] = new int[2];\n+\n+    xp[0] = x1;\n+    xp[1] = x2;\n+    yp[0] = y1;\n+    yp[1] = y2;\n+    \n+    doPolygon (xp, yp, 2, false, false);\n+  }\n+\n+  public void fillPolygon(int[] xPoints, int[] yPoints, int nPoints)\n+  {\n+    doPolygon (xPoints, yPoints, nPoints, true, true);\n+  }\n+  \n+  public void drawPolygon(int[] xPoints, int[] yPoints, int nPoints)\n+  {    \n+    doPolygon (xPoints, yPoints, nPoints, true, false);\n+  }\n+\n+  public void drawPolyline(int[] xPoints, int[] yPoints, int nPoints)\n+  {\n+    doPolygon (xPoints, yPoints, nPoints, false, false);\n+  }\n+\n+  private boolean drawRaster (ColorModel cm, Raster r)\n+  {\n+    if (r == null)\n+      return false;\n+\n+    SampleModel sm = r.getSampleModel ();\n+    DataBuffer db = r.getDataBuffer ();\n+\n+    if (db == null || sm == null)\n+      return false;\n+\n+    if (cm == null)\n+      cm = ColorModel.getRGBdefault ();\n+\n+    int pixels[] = null;\n+\n+    if (sm.getDataType () == DataBuffer.TYPE_INT &&\n+        db instanceof DataBufferInt &&\n+        db.getNumBanks () == 1)\n+      {\n+        // single bank, ARGB-ints buffer in sRGB space\n+        DataBufferInt dbi = (DataBufferInt)db;\n+        pixels = dbi.getData ();\n+      }\n+    else\n+      pixels = r.getPixels (0, 0, r.getWidth (), r.getHeight (), pixels);\n+    \n+    ColorSpace cs = cm.getColorSpace ();\n+    if (cs != null && \n+        cs.getType () != ColorSpace.CS_sRGB)\n+      {\n+        int pixels2[] = new int[pixels.length];        \n+        for (int i = 0; i < pixels2.length; i++)\n+          pixels2[i] = cm.getRGB (pixels[i]);        \n+        pixels = pixels2;\n+      }\n+    \n+    cairoSave ();\n+    cairoTranslate (x, y);\n+    drawPixels (pixels, r.getWidth (), r.getHeight (), r.getWidth ());\n+    cairoRestore ();    \n+    return true;\n+  }\n+\n+  public boolean drawImage (Image img, int x, int y, \n+                            ImageObserver observer)\n+  {\n+    if (img instanceof GtkOffScreenImage &&\n+        img.getGraphics () instanceof GdkGraphics2D &&            \n+        (transform == null || transform.isIdentity ())) \n+      {\n+        // we are being asked to flush a double buffer from Gdk\n+        GdkGraphics2D g2 = (GdkGraphics2D) img.getGraphics ();\n+        gdkDrawDrawable (g2, x, y);\n+        return true;\n+      }\n+    else\n+      {\n+        if (img instanceof BufferedImage)\n+          {\n+            // draw an image which has actually been loaded into memory fully\n+            BufferedImage b = (BufferedImage) img;\n+            return drawRaster (b.getColorModel (), b.getData ());\n+          }        \n+        else\n+          {\n+            // begin progressive loading in a separate thread\n+            new PainterThread (this, img);\n+            return false;\n+          }\n+      }\n+  }\n+\n+\n+  ////////////////////////////////////////\n+  ////// Supporting Private Classes //////\n+  ////////////////////////////////////////\n+  \n+  private class PainterThread implements Runnable, ImageConsumer\n+  {\n+\n+    // this is a helper which is spun off when someone tries to do\n+    // Graphics2D.drawImage on an image we cannot determine to be either\n+    // one of our own offscreen images or a BufferedImage; that is, when\n+    // someone wants to draw an image which is possibly still loading over\n+    // a network or something. you run it in a separate thread and it\n+    // writes through to the underlying Graphics2D as pixels becomg\n+    // available.\n+\n+    GdkGraphics2D gr;\n+    Image image;\n+    ColorModel defaultModel;\n+\n+    public PainterThread (GdkGraphics2D g, Image im)\n+    {\n+      image = im;\n+      this.gr = (GdkGraphics2D) g.create ();\n+      new Thread (this).start ();\n+    }\n+    \n+    public void imageComplete (int status)\n+    {\n+    }\n+    \n+    public void setColorModel (ColorModel model) \n+    {\n+      defaultModel = model;\n+    }\n+    \n+    public void setDimensions (int width, int height)\n+    {\n+    }\n+    \n+    public void setHints (int hintflags)\n+    {\n+    }\n+    \n+    public void setPixels (int x, int y, int w, int h, ColorModel model, \n+                           byte[] pixels, int off, int scansize)\n+    {\n+    }\n+    \n+    public void setPixels (int x, int y, int w, int h, ColorModel model, \n+                           int[] pixels, int off, int scansize)\n+      {\n+        gr.cairoSave ();\n+        gr.cairoTranslate (x, y);\n+\n+        if (model == null)\n+          model = defaultModel;\n+\n+        int pixels2[];\n+        if (model != null)\n+          {\n+            pixels2 = new int[pixels.length];\n+            for (int yy = 0; yy < h; yy++)\n+              for (int xx = 0; xx < w; xx++)\n+                {\n+                  int i = yy * scansize + xx;\n+                  pixels2[i] = model.getRGB (pixels[i]);\n+                }\n+          }\n+        else\n+          pixels2 = pixels;\n+\n+        gr.drawPixels (pixels2, w, h, scansize);\n+        gr.cairoRestore ();\n+      }\n+\n+    public void setProperties (java.util.Hashtable props)\n+    {\n+    }\n+    \n+    public void run ()\n+    {\n+      image.getSource ().startProduction (this);\n+      gr.dispose ();\n+    }\n+  }\n+\n+\n+  private class BitwiseXorComposite implements Composite\n+  {\n+    // this is a special class which does a bitwise XOR composite, for\n+    // backwards compatibility sake. it does *not* implement the\n+    // porter-duff XOR operator.  the porter-duff XOR is unrelated to\n+    // bitwise XOR; it just happens to have a similar name but it\n+    // represents a desire to composite the exclusive or of overlapping\n+    // subpixel regions. bitwise XOR is for drawing \"highlights\" such as\n+    // cursors (in a cheap oldskool bitblit fashion) by inverting colors\n+    // temporarily and then inverting them back.\n+\n+    Color xorColor;\n+    \n+    class BitwiseXorCompositeContext implements CompositeContext\n+    {\n+      ColorModel srcColorModel;\n+      ColorModel dstColorModel;\n+      \n+      public BitwiseXorCompositeContext (ColorModel s,\n+                                         ColorModel d)\n+      {\n+        srcColorModel = s;\n+        dstColorModel = d;\n+      }\n+\n+      public void dispose () \n+      {\n+      }\n+\n+      public void compose (Raster src,\n+                           Raster dstIn,\n+                           WritableRaster dstOut)\n+      {\n+        Rectangle srcRect = src.getBounds ();\n+        Rectangle dstInRect = dstIn.getBounds ();\n+        Rectangle dstOutRect = dstOut.getBounds ();\n+        \n+        int xp = xorColor.getRGB ();\n+        int x = 0, y = 0;\n+        int w = Math.min (Math.min (srcRect.width, dstOutRect.width), dstInRect.width);\n+        int h = Math.min (Math.min (srcRect.height, dstOutRect.height), dstInRect.height);\n+        Object srcPix = null, dstPix = null;\n+\n+        for (y = 0; y < h; y++)\n+          for (x = 0; x < w; x++)\n+            {\n+              srcPix = src.getDataElements (x + srcRect.x, y + srcRect.y, srcPix);\n+              dstPix = dstIn.getDataElements (x + dstInRect.x, y + dstInRect.y, dstPix);\n+              int sp = srcColorModel.getRGB (srcPix);\n+              int dp = dstColorModel.getRGB (dstPix);\n+              int rp = sp ^ xp ^ dp;\n+              dstOut.setDataElements (x + dstOutRect.x, y + dstOutRect.y, \n+                                      dstColorModel.getDataElements (rp, null));\n+            }\n+      }\n+    }\n+    \n+    public BitwiseXorComposite (Color c)\n+    {\n+      xorColor = c;\n+    }\n+    \n+    public CompositeContext createContext (ColorModel srcColorModel, \n+                                           ColorModel dstColorModel, \n+                                           RenderingHints hints) \n+    {\n+      return new BitwiseXorCompositeContext (srcColorModel, dstColorModel);\n+    }\n+  }  \n+\n+\n+  ///////////////////////////////////////////////\n+  ////// Unimplemented Stubs and Overloads //////\n+  ///////////////////////////////////////////////\n+\n+  public boolean drawImage(Image image, \n+                           AffineTransform xform,\n+                           ImageObserver obs)\n+  {\n+    throw new java.lang.UnsupportedOperationException ();\n+  }\n+  \n+  public void drawImage(BufferedImage image,\n+                        BufferedImageOp op,\n+                        int x,\n+                        int y)\n+  {\n+    throw new java.lang.UnsupportedOperationException ();\n+  }\n+  \n+  public void drawRenderedImage(RenderedImage image,\n+                                AffineTransform xform)\n+  {\n+    throw new java.lang.UnsupportedOperationException ();\n+  }\n+  \n+  public void drawRenderableImage(RenderableImage image,\n+                                  AffineTransform xform)\n+  {\n+    throw new java.lang.UnsupportedOperationException ();\n+  }\n+\n+  public void drawString(String text, float x, float y)\n+  {\n+    throw new java.lang.UnsupportedOperationException ();\n+  }\n+  \n+  public void drawString(AttributedCharacterIterator iterator,\n+                         float x, float y)\n+  {\n+    throw new java.lang.UnsupportedOperationException ();\n+  }\n+    \n+  public boolean hit(Rectangle rect, Shape text,\n+                     boolean onStroke)\n+  {\n+    throw new java.lang.UnsupportedOperationException ();\n+  }\n+\n+  public GraphicsConfiguration getDeviceConfiguration()\n+  {\n+    throw new java.lang.UnsupportedOperationException ();\n+  }\n+\n+  public void setComposite(Composite comp)\n+  {\n+    throw new java.lang.UnsupportedOperationException ();\n+  }\n+\n+  public void setRenderingHint(RenderingHints.Key hintKey,\n+                               Object hintValue)\n+  {\n+    throw new java.lang.UnsupportedOperationException ();\n+  }\n+\n+  public Object getRenderingHint(RenderingHints.Key hintKey)\n+  {\n+    throw new java.lang.UnsupportedOperationException ();\n+  }\n+  \n+  public void setRenderingHints(Map hints)\n+  {\n+    throw new java.lang.UnsupportedOperationException ();\n+  }\n+\n+  public void addRenderingHints(Map hints)\n+  {\n+    throw new java.lang.UnsupportedOperationException ();\n+  }\n+\n+  public RenderingHints getRenderingHints()\n+  {\n+    throw new java.lang.UnsupportedOperationException ();\n+  }\n+\n+  public void shear(double shearX, double shearY)\n+  {\n+    throw new java.lang.UnsupportedOperationException ();\n+  }\n+\n+  public Composite getComposite()\n+  {\n+    throw new java.lang.UnsupportedOperationException ();\n+  }\n+\n+  public FontRenderContext getFontRenderContext ()\n+  {\n+    throw new java.lang.UnsupportedOperationException ();\n+  }\n+\n+  public void drawGlyphVector (GlyphVector g, float x, float y)\n+  {\n+    throw new java.lang.UnsupportedOperationException ();\n+  }\n+\n+  public void copyArea (int x, int y, int width, int height, int dx, int dy)\n+  {\n+    throw new java.lang.UnsupportedOperationException ();\n+  }\n+\n+  public void drawArc (int x, int y, int width, int height,\n+                       int startAngle, int arcAngle)\n+  {\n+    throw new java.lang.UnsupportedOperationException ();\n+  }\n+\n+  public boolean drawImage (Image img, int x, int y, Color bgcolor, \n+                            ImageObserver observer)\n+  {\n+    throw new java.lang.UnsupportedOperationException ();\n+  }\n+\n+  public boolean drawImage (Image img, int x, int y, int width, int height, \n+                            Color bgcolor, ImageObserver observer)\n+  {\n+    throw new java.lang.UnsupportedOperationException ();\n+  }\n+\n+  public boolean drawImage (Image img, int x, int y, int width, int height, \n+                            ImageObserver observer)\n+  {\n+    throw new java.lang.UnsupportedOperationException ();\n+  }\n+\n+  public boolean drawImage (Image img, int dx1, int dy1, int dx2, int dy2, \n+                            int sx1, int sy1, int sx2, int sy2, \n+                            Color bgcolor, ImageObserver observer)\n+  {\n+    throw new java.lang.UnsupportedOperationException ();\n+  }\n+\n+  public boolean drawImage (Image img, int dx1, int dy1, int dx2, int dy2, \n+                            int sx1, int sy1, int sx2, int sy2, \n+                            ImageObserver observer) \n+  {\n+    throw new java.lang.UnsupportedOperationException ();\n+  }\n+\n+  public void drawOval(int x, int y, int width, int height)\n+  {\n+    throw new java.lang.UnsupportedOperationException ();\n+  }\n+\n+  public void drawRoundRect(int x, int y, int width, int height, \n+                            int arcWidth, int arcHeight)\n+  {\n+    throw new java.lang.UnsupportedOperationException ();\n+  }\n+\n+  public void drawString (String str, int x, int y)\n+  {\n+    throw new java.lang.UnsupportedOperationException ();\n+  }\n+\n+  public void drawString (AttributedCharacterIterator ci, int x, int y)\n+  {\n+    throw new java.lang.UnsupportedOperationException ();\n+  }\n+\n+  public void fillArc (int x, int y, int width, int height, \n+                       int startAngle, int arcAngle)\n+  {\n+    cairoNewPath ();\n+    walkPath (new Arc2D.Double((double)x, (double)y, \n+                               (double)width, (double)height,\n+                               (double)startAngle, (double)arcAngle,\n+                               Arc2D.PIE).getPathIterator (null));\n+    cairoClosePath ();\n+    cairoFill ();\n+  }\n+\n+  public void fillOval(int x, int y, int width, int height)\n+  {\n+    throw new java.lang.UnsupportedOperationException ();\n+  }\n+\n+  public void fillRoundRect (int x, int y, int width, int height, \n+                             int arcWidth, int arcHeight)\n+  {\n+    throw new java.lang.UnsupportedOperationException ();\n+  }\n+\n+  public Font getFont ()\n+  {\n+    throw new java.lang.UnsupportedOperationException ();\n+  }\n+\n+  public FontMetrics getFontMetrics ()\n+  {\n+    throw new java.lang.UnsupportedOperationException ();\n+  }\n+\n+  public FontMetrics getFontMetrics (Font f)\n+  {\n+    throw new java.lang.UnsupportedOperationException ();\n+  }\n+\n+  public void setFont (Font f)\n+  {\n+    if (f instanceof GdkFont)\n+      font = (GdkFont) f;\n+    else\n+      font = new GdkFont (f.getAttributes ());\n+  }\n+\n+  public String toString()\n+  {\n+    throw new java.lang.UnsupportedOperationException ();\n+  }\n+\n+}"}, {"sha": "55f3338006e9096b9b4816f00b954711006b3967", "filename": "libjava/gnu/java/awt/peer/gtk/GdkPixbufDecoder.java", "status": "added", "additions": 217, "deletions": 0, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fe2d5fb0998455d5faec36e62a8919ad16c939f/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkPixbufDecoder.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fe2d5fb0998455d5faec36e62a8919ad16c939f/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkPixbufDecoder.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkPixbufDecoder.java?ref=1fe2d5fb0998455d5faec36e62a8919ad16c939f", "patch": "@@ -0,0 +1,217 @@\n+/* GdkPixbufDecoder.java -- Image data decoding object\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+   \n+   This file is part of GNU Classpath.\n+   \n+   GNU Classpath is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+   \n+   GNU Classpath is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+   \n+   You should have received a copy of the GNU General Public License\n+   along with GNU Classpath; see the file COPYING.  If not, write to the\n+   Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+   02111-1307 USA.\n+   \n+   Linking this library statically or dynamically with other modules is\n+   making a combined work based on this library.  Thus, the terms and\n+   conditions of the GNU General Public License cover the whole\n+   combination.\n+   \n+   As a special exception, the copyright holders of this library give you\n+   permission to link this library with independent modules to produce an\n+   executable, regardless of the license terms of these independent\n+   modules, and to copy and distribute the resulting executable under\n+   terms of your choice, provided that you also meet, for each linked\n+   independent module, the terms and conditions of the license of that\n+   module.  An independent module is a module which is not derived from\n+   or based on this library.  If you modify this library, you may extend\n+   this exception to your version of the library, but you are not\n+   obligated to do so.  If you do not wish to do so, delete this\n+   exception statement from your version. */\n+\n+\n+package gnu.java.awt.peer.gtk;\n+\n+import java.awt.image.*;\n+import java.io.FileDescriptor;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.net.URL;\n+import java.util.Vector;\n+import java.util.Hashtable;\n+import gnu.classpath.Configuration;\n+\n+public class GdkPixbufDecoder extends gnu.java.awt.image.ImageDecoder\n+{\n+  static \n+  {\n+    if (Configuration.INIT_LOAD_LIBRARY)\n+      {\n+        System.loadLibrary(\"gtkpeer\");\n+      }\n+    initStaticState ();\n+  }\n+  native static void initStaticState ();\n+  private final int native_state = GtkGenericPeer.getUniqueInteger ();\n+\n+  // the current set of ImageConsumers for this decoder\n+  Vector curr;\n+\n+  // interface to GdkPixbuf\n+  native void initState ();\n+  native void pumpBytes (byte bytes[], int len);\n+  native void finish ();\n+  \n+  // gdk-pixbuf provids data in RGBA format\n+  static final ColorModel cm = new DirectColorModel (32, 0xff000000, \n+                                                     0x00ff0000, \n+                                                     0x0000ff00, \n+                                                     0x000000ff);\n+  public GdkPixbufDecoder (String filename)\n+  {\n+    super (filename);\n+    initState ();\n+  }\n+  \n+  public GdkPixbufDecoder (URL url)\n+  {\n+    super (url);\n+    initState ();\n+  }\n+\n+  // called back by native side\n+  void areaPrepared (int width, int height)\n+  {\n+\n+    if (curr == null)\n+      return;\n+\n+    for (int i = 0; i < curr.size (); i++)\n+      {\n+        ImageConsumer ic = (ImageConsumer) curr.elementAt (i);\n+        ic.setDimensions (width, height);\n+        ic.setColorModel (cm);\n+        ic.setHints (ImageConsumer.RANDOMPIXELORDER);\n+      }\n+  }\n+  \n+  // called back by native side\n+  void areaUpdated (int x, int y, int width, int height, \n+                    int pixels[], int scansize)\n+  {\n+    if (curr == null)\n+      return;\n+    \n+    for (int i = 0; i < curr.size (); i++)\n+      {\n+        ImageConsumer ic = (ImageConsumer) curr.elementAt (i);\n+        ic.setPixels (x, y, width, height, cm, pixels, 0, scansize);\n+      }\n+  }\n+  \n+  // called from an async image loader of one sort or another, this method\n+  // repeatedly reads bytes from the input stream and passes them through a\n+  // GdkPixbufLoader using the native method pumpBytes. pumpBytes in turn\n+  // decodes the image data and calls back areaPrepared and areaUpdated on\n+  // this object, feeding back decoded pixel blocks, which we pass to each\n+  // of the ImageConsumers in the provided Vector.\n+\n+  void produce (Vector v, FileInputStream is) throws IOException\n+  {\n+    curr = v;\n+\n+    byte bytes[] = new byte[4096];\n+    int len = 0;\n+    while ((len = is.read (bytes)) != -1)\n+      pumpBytes (bytes, len);\n+    \n+    for (int i = 0; i < curr.size (); i++)\n+      {\n+        ImageConsumer ic = (ImageConsumer) curr.elementAt (i);\n+        ic.imageComplete (ImageConsumer.STATICIMAGEDONE);\n+      }\n+\n+    curr = null;\n+  }\n+\n+  // remaining helper class and static method is a convenience for the Gtk\n+  // peers, for loading a BufferedImage in off a disk file. one would think\n+  // this ought to be fairly straightforward, but it does not appear\n+  // anywhere else I can find.\n+\n+  private class BufferedImageBuilder implements ImageConsumer\n+  {\n+    BufferedImage bufferedImage;\n+    ColorModel defaultModel;\n+\n+    public BufferedImage getBufferedImage()\n+    {\n+      return bufferedImage;\n+    }\n+\n+    public void setDimensions(int width, int height)\n+    {\n+      bufferedImage = new BufferedImage (width, height, BufferedImage.TYPE_INT_ARGB);\n+    }\n+    \n+    public void setProperties(Hashtable props) {}\n+\n+    public void setColorModel(ColorModel model) \n+    {\n+      defaultModel = model;\n+    }\n+\n+    public void setHints(int flags) {}\n+\n+    public void setPixels(int x, int y, int w, int h, \n+                          ColorModel model, byte[] pixels, \n+                          int offset, int scansize)\n+    {\n+    }      \n+\n+    public void setPixels(int x, int y, int w, int h, \n+                          ColorModel model, int[] pixels, \n+                          int offset, int scansize)\n+    {\n+      if (bufferedImage != null)\n+        {\n+\n+          if (model == null)\n+            model = defaultModel;\n+\n+          int pixels2[];\n+          if (model != null)\n+            {\n+              pixels2 = new int[pixels.length];\n+              for (int yy = 0; yy < h; yy++)\n+                for (int xx = 0; xx < w; xx++)\n+                  {\n+                    int i = yy * scansize + xx;\n+                    pixels2[i] = model.getRGB (pixels[i]);\n+                  }\n+            }\n+          else\n+            pixels2 = pixels;\n+\n+          bufferedImage.setRGB (x, y, w, h, pixels2, offset, scansize);\n+        }\n+    }\n+\n+    public void imageComplete(int status) {}\n+  }\n+\n+  public static BufferedImage createBufferedImage (String filename)\n+  {\n+    BufferedImageBuilder bb = new BufferedImageBuilder ();\n+    GdkPixbufDecoder dec = new GdkPixbufDecoder (filename);\n+    dec.startProduction (bb);\n+    return bb.getBufferedImage ();\n+  }\n+\n+}"}, {"sha": "04eb2e5a52495ea9c82989e884ff273d5deb5dc0", "filename": "libjava/jni/gtk-peer/gnu_java_awt_peer_gtk_GdkGraphics2D.c", "status": "added", "additions": 1069, "deletions": 0, "changes": 1069, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fe2d5fb0998455d5faec36e62a8919ad16c939f/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkGraphics2D.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fe2d5fb0998455d5faec36e62a8919ad16c939f/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkGraphics2D.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkGraphics2D.c?ref=1fe2d5fb0998455d5faec36e62a8919ad16c939f", "patch": "@@ -0,0 +1,1069 @@\n+/* gnu_java_awt_peer_gtk_GdkGraphics2d.c\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+   This file is part of GNU Classpath.\n+   \n+   GNU Classpath is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+   \n+   GNU Classpath is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+   \n+   You should have received a copy of the GNU General Public License\n+   along with GNU Classpath; see the file COPYING.  If not, write to the\n+   Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+   02111-1307 USA.\n+   \n+   Linking this library statically or dynamically with other modules is\n+   making a combined work based on this library.  Thus, the terms and\n+   conditions of the GNU General Public License cover the whole\n+   combination.\n+   \n+   As a special exception, the copyright holders of this library give you\n+   permission to link this library with independent modules to produce an\n+   executable, regardless of the license terms of these independent\n+   modules, and to copy and distribute the resulting executable under\n+   terms of your choice, provided that you also meet, for each linked\n+   independent module, the terms and conditions of the license of that\n+   module.  An independent module is a module which is not derived from\n+   or based on this library.  If you modify this library, you may extend\n+   this exception to your version of the library, but you are not\n+   obligated to do so.  If you do not wish to do so, delete this\n+   exception statement from your version. */\n+\n+#include \"gtkpeer.h\"\n+#include \"gnu_java_awt_peer_gtk_GdkGraphics2D.h\"\n+#include <gdk/gdktypes.h>\n+#include <gdk/gdkprivate.h>\n+#include <gdk/gdkx.h>\n+\n+#include <gdk-pixbuf/gdk-pixbuf.h>\n+#include <gdk-pixbuf/gdk-pixdata.h>\n+\n+#include <cairo.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+struct state_table *native_graphics2d_state_table;\n+\n+#define NSA_G2D_INIT(env, clazz) \\\n+  native_graphics2d_state_table = init_state_table (env, clazz)\n+\n+#define NSA_GET_G2D_PTR(env, obj) \\\n+  get_state (env, obj, native_graphics2d_state_table)\n+\n+#define NSA_SET_G2D_PTR(env, obj, ptr) \\\n+  set_state (env, obj, native_graphics2d_state_table, (void *)ptr)\n+\n+#define NSA_DEL_G2D_PTR(env, obj) \\\n+  remove_state_slot (env, obj, native_graphics2d_state_table)\n+\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics2D_initStaticState \n+  (JNIEnv *env, jclass clazz)\n+{\n+    NSA_G2D_INIT (env, clazz);\n+}\n+\n+/* these public final constants are part of the java2d public API, so we\n+   write them explicitly here to save fetching them from the constant pool\n+   all the time. */\n+\n+#ifndef min\n+#define min(x,y) ((x) < (y) ? (x) : (y))\n+#endif\n+\n+enum java_awt_alpha_composite_rule\n+  {\n+    java_awt_alpha_composite_CLEAR = 1,\n+    java_awt_alpha_composite_SRC = 2,\n+    java_awt_alpha_composite_SRC_OVER = 3,\n+    java_awt_alpha_composite_DST_OVER = 4,\n+    java_awt_alpha_composite_SRC_IN = 5,\n+    java_awt_alpha_composite_DST_IN = 6,\n+    java_awt_alpha_composite_SRC_OUT = 7,\n+    java_awt_alpha_composite_DST_OUT = 8,\n+    java_awt_alpha_composite_DST = 9,\n+    java_awt_alpha_composite_SRC_ATOP = 10,\n+    java_awt_alpha_composite_DST_ATOP = 11,\n+    java_awt_alpha_composite_XOR = 12\n+  };\n+\n+enum java_awt_basic_stroke_join_rule\n+  {\n+    java_awt_basic_stroke_JOIN_MITER = 0,\n+    java_awt_basic_stroke_JOIN_ROUND = 1,\n+    java_awt_basic_stroke_JOIN_BEVEL = 2\n+  };\n+\n+enum java_awt_basic_stroke_cap_rule\n+  {\n+    java_awt_basic_stroke_CAP_BUTT = 0,\n+    java_awt_basic_stroke_CAP_ROUND = 1,\n+    java_awt_basic_stroke_CAP_SQUARE = 2\n+  };\n+\n+enum java_awt_geom_path_iterator_winding_rule\n+  {\n+    java_awt_geom_path_iterator_WIND_EVEN_ODD = 0,\n+    java_awt_geom_path_iterator_WIND_NON_ZERO = 1\n+  };\n+\n+\n+static void \n+grab_current_drawable (GtkWidget *widget, GdkDrawable **draw, GdkWindow **win)\n+{  \n+  g_assert (widget != NULL);\n+  g_assert (draw != NULL);\n+  g_assert (win != NULL);\n+\n+  if (GTK_IS_WINDOW (widget))\n+    {\n+      *win = find_gtk_layout (widget)->bin_window;\n+    }\n+  else if (GTK_IS_LAYOUT (widget))\n+    {\n+      *win = GTK_LAYOUT (widget)->bin_window;\n+    }\n+  else\n+    {\n+      *win = widget->window;\n+    }\n+\n+  *draw = *win;\n+  gdk_window_get_internal_paint_info (*win, draw, 0, 0);\n+  g_object_ref (*draw);\n+}\n+\n+\n+static int\n+x_server_has_render_extension (void)\n+{\n+  int ev = 0, err = 0; \n+  return (int) XRenderQueryExtension (GDK_DISPLAY (), &ev, &err);\n+}\n+\n+\n+static void\n+init_graphics2d_as_pixbuf (struct graphics2d *gr)\n+{\n+  gint width, height;\n+  gint bits_per_sample = 8;\n+  gint total_channels = 4;\n+  gboolean has_alpha = TRUE;\n+  \n+  g_assert (gr != NULL);\n+  g_assert (gr->drawable != NULL);\n+\n+  if (gr->debug) printf (\"initializing graphics2d as pixbuf\\n\");\n+  gdk_drawable_get_size (gr->drawable, &width, &height);\n+  gr->drawbuf = gdk_pixbuf_new (GDK_COLORSPACE_RGB, \n+\t\t\t\thas_alpha, bits_per_sample,\n+\t\t\t\twidth, height);\n+  g_assert (gr->drawbuf != NULL);\n+  g_assert (gdk_pixbuf_get_bits_per_sample (gr->drawbuf) == bits_per_sample);\n+  g_assert (gdk_pixbuf_get_n_channels (gr->drawbuf) == total_channels);\n+  \n+  gr->surface = cairo_surface_create_for_image (gdk_pixbuf_get_pixels (gr->drawbuf), \n+\t\t\t\t\t\tCAIRO_FORMAT_ARGB32, \n+\t\t\t\t\t\tgdk_pixbuf_get_width (gr->drawbuf), \n+\t\t\t\t\t\tgdk_pixbuf_get_height (gr->drawbuf), \n+\t\t\t\t\t\tgdk_pixbuf_get_rowstride (gr->drawbuf));      \n+  g_assert (gr->surface != NULL);\n+  g_assert (gr->cr != NULL);\n+  cairo_set_target_surface (gr->cr, gr->surface);\n+}\n+\n+static void\n+init_graphics2d_as_renderable (struct graphics2d *gr)\n+{\n+  Drawable draw;\n+  Display * dpy;\n+  Visual * vis;\n+  \n+  g_assert (gr != NULL);\n+  g_assert (gr->drawable != NULL);\n+\n+  gr->drawbuf = NULL;\n+  \n+  if (gr->debug) printf (\"initializing graphics2d as renderable\\n\");\n+  draw = gdk_x11_drawable_get_xid (gr->drawable);\n+  \n+  dpy = gdk_x11_drawable_get_xdisplay (gr->drawable);\n+  g_assert (dpy != NULL);\n+  \n+  vis = gdk_x11_visual_get_xvisual (gdk_drawable_get_visual (gr->drawable));\n+  g_assert (vis != NULL);\n+  \n+  gr->surface = cairo_surface_create_for_drawable (dpy, draw, vis, \n+\t\t\t\t\t\t   CAIRO_FORMAT_ARGB32,\n+\t\t\t\t\t\t   DefaultColormap (dpy, DefaultScreen (dpy)));\n+  g_assert (gr->surface != NULL);\n+  g_assert (gr->cr != NULL);\n+  cairo_set_target_surface (gr->cr, gr->surface);\n+}\n+\n+static void\n+begin_drawing_operation (struct graphics2d * gr)\n+{  \n+  gdk_threads_enter ();\n+  if (gr->drawbuf)\n+    {\n+\n+      gint drawable_width, drawable_height;\n+      gint pixbuf_width, pixbuf_height;\n+      gint width, height;\n+      \n+      gdk_drawable_get_size (gr->drawable, &drawable_width, &drawable_height);\n+      pixbuf_width = gdk_pixbuf_get_width (gr->drawbuf);\n+      pixbuf_height = gdk_pixbuf_get_height (gr->drawbuf);\n+      width = min (drawable_width, pixbuf_width);\n+      height = min (drawable_height, pixbuf_height);\n+\n+      gdk_pixbuf_get_from_drawable (gr->drawbuf, /* destination pixbuf */\n+\t\t\t\t    gr->drawable, \n+\t\t\t\t    NULL, /* colormap */\n+\t\t\t\t    0, 0, 0, 0,\n+\t\t\t\t    width, height); \n+      \n+      if (gr->debug) printf (\"copied (%d, %d) pixels from GDK drawable to pixbuf\\n\",\n+\t\t\t     width, height);      \n+    }\n+}\n+\n+static void\n+end_drawing_operation (struct graphics2d * gr)\n+{\n+  if (gr->drawbuf)\n+    { \n+      gint drawable_width, drawable_height;\n+      gint pixbuf_width, pixbuf_height;\n+      gint width, height;\n+      \n+      gdk_drawable_get_size (gr->drawable, &drawable_width, &drawable_height);\n+      pixbuf_width = gdk_pixbuf_get_width (gr->drawbuf);\n+      pixbuf_height = gdk_pixbuf_get_height (gr->drawbuf);\n+      width = min (drawable_width, pixbuf_width);\n+      height = min (drawable_height, pixbuf_height);\n+\n+      gdk_draw_pixbuf (gr->drawable, NULL, gr->drawbuf,\n+\t\t       0, 0, 0, 0, \n+\t\t       width, height, \n+\t\t       GDK_RGB_DITHER_NORMAL, 0, 0);\n+\n+      if (gr->debug) printf (\"copied (%d, %d) pixels from pixbuf to GDK drawable\\n\",\n+\t\t\t     width, height);\n+    }\n+  gdk_threads_leave ();\n+}\n+\n+\n+static void \n+update_pattern_transform (struct graphics2d *gr)\n+{\n+  double a, b, c, d, tx, ty;\n+  cairo_matrix_t *mat = NULL;\n+\n+  g_assert (gr != NULL);\n+  if (gr->pattern == NULL)\n+    return;\n+\n+  return;\n+  /* temporarily disabled: ambiguous behavior */\n+  /*   cairo_get_matrix (gr->cr, &a, &b, &c, &d, &tx, &ty); */\n+  mat = cairo_matrix_create ();\n+  g_assert (mat != NULL);\n+  cairo_matrix_set_affine (mat, a, b, c, d, tx, ty);\n+  cairo_surface_set_matrix (gr->pattern, mat);\n+  cairo_matrix_destroy (mat);\n+}\n+\n+static void\n+check_for_debug (struct graphics2d *gr)\n+{\n+  gr->debug = (gboolean)(getenv(\"DEBUGJ2D\") != NULL);\n+}\n+\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics2D_copyState\n+  (JNIEnv *env, jobject obj, jobject old)\n+{\n+  struct graphics2d *g = NULL, *g_old = NULL;\n+\n+  g = (struct graphics2d *) malloc (sizeof (struct graphics2d));\n+  g_assert (g != NULL);\n+  memset (g, 0, sizeof(struct graphics2d));\n+\n+  g_old = (struct graphics2d *) NSA_GET_G2D_PTR (env, old);\n+  g_assert (g_old != NULL);\n+\n+  g->drawable = g_old->drawable;\n+  g->debug = g_old->debug; \n+\n+  gdk_threads_enter ();\n+  g_object_ref (g->drawable);\n+  \n+  g->cr = cairo_create();\n+  g_assert (g->cr != NULL);\n+\n+  if (x_server_has_render_extension ())\n+    init_graphics2d_as_renderable (g);\n+  else\n+    init_graphics2d_as_pixbuf (g);\n+\n+  cairo_surface_set_filter (g->surface, CAIRO_FILTER_BILINEAR);\n+\n+  gdk_threads_leave ();\n+\n+  NSA_SET_G2D_PTR (env, obj, g);\n+}\n+\n+\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics2D_initState__II\n+  (JNIEnv *env, jobject obj, jint width, jint height)\n+{\n+  struct graphics2d *gr;\n+\n+  gdk_threads_enter ();\n+  \n+  gr = (struct graphics2d *) malloc (sizeof (struct graphics2d));\n+  g_assert (gr != NULL);\n+  memset (gr, 0, sizeof(struct graphics2d));\n+\n+  check_for_debug (gr);  \n+\n+  if (gr->debug) printf (\"constructing offscreen drawable of size (%d,%d)\\n\",\n+\t\t\t width, height);\n+  \n+  gr->drawable = (GdkDrawable *) gdk_pixmap_new (NULL, width, height, \n+\t\t\t\t\t\t gdk_rgb_get_visual ()->depth);\n+  g_assert (gr->drawable != NULL);\n+\n+  gr->cr = cairo_create();\n+  g_assert (gr->cr != NULL);\n+\n+  if (x_server_has_render_extension ())\n+    init_graphics2d_as_renderable (gr);\n+  else\n+    init_graphics2d_as_pixbuf (gr);\n+\n+  gdk_threads_leave ();\n+  if (gr->debug) printf (\"constructed offscreen drawable of size (%d,%d)\\n\",\n+\t\t\t width, height);\n+  NSA_SET_G2D_PTR (env, obj, gr);\n+}\n+\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics2D_gdkDrawDrawable\n+  (JNIEnv *env, jobject self, jobject other, jint x, jint y)\n+{\n+  struct graphics2d *src = NULL, *dst = NULL;\n+  gint s_height, s_width, d_height, d_width, height, width;\n+  GdkGC *gc;\n+\n+  src = (struct graphics2d *)NSA_GET_G2D_PTR (env, other);\n+  dst = (struct graphics2d *)NSA_GET_G2D_PTR (env, self);\n+  g_assert (src != NULL);\n+  g_assert (dst != NULL);  \n+\n+  if (src->debug) printf (\"copying from offscreen drawable\\n\");\n+\n+  gdk_threads_enter ();\n+  gdk_drawable_get_size (src->drawable, &s_width, &s_height);\n+  gdk_drawable_get_size (dst->drawable, &d_width, &d_height);\n+  width = min (s_width, d_width);\n+  height = min (s_width, d_height);\n+\n+  gc = gdk_gc_new (dst->drawable);\n+  g_assert (gc != NULL);\n+\n+  gdk_draw_drawable(dst->drawable, gc, src->drawable,\n+\t\t    0, 0, x, y, width, height);\n+\n+  g_object_unref (gc);\n+\n+  if (src->debug) printf (\"copied %d x %d pixels from offscreen drawable\\n\", width, height);\n+  gdk_threads_leave ();  \n+}\n+\n+static jintArray\n+current_colors_of_widget (GtkWidget *widget, JNIEnv *env)\n+{\n+  GdkColor color;\n+  jintArray array;\n+  jint *rgb;\n+\n+  g_assert (widget != NULL);\n+  g_assert (env != NULL);\n+\n+  color = widget->style->fg[GTK_STATE_NORMAL];\n+  array = (*env)->NewIntArray (env, 6);\n+\n+  rgb = (*env)->GetIntArrayElements (env, array, NULL);\n+  rgb[0] = color.red >> 8;\n+  rgb[1] = color.green >> 8;\n+  rgb[2] = color.blue >> 8;\n+\n+  color = widget->style->bg[GTK_STATE_NORMAL];\n+  rgb[3] = color.red >> 8;\n+  rgb[4] = color.green >> 8;\n+  rgb[5] = color.blue >> 8;\n+\n+  (*env)->ReleaseIntArrayElements (env, array, rgb, 0);\n+  \n+  return array;\n+}\n+\n+JNIEXPORT jintArray JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics2D_initState__Lgnu_java_awt_peer_gtk_GtkComponentPeer_2\n+  (JNIEnv *env, jobject obj, jobject peer)\n+{\n+  struct graphics2d *gr = NULL;\n+  GtkWidget *widget = NULL;\n+  void *ptr = NULL;\n+  jintArray color;\n+\n+  ptr = NSA_GET_PTR (env, peer);\n+  g_assert (ptr != NULL);\n+  gdk_threads_enter ();\n+\n+  gr = (struct graphics2d *) malloc (sizeof (struct graphics2d));\n+  g_assert (gr != NULL);\n+  memset (gr, 0, sizeof(struct graphics2d));\n+\n+  check_for_debug (gr);\n+\n+  gr->cr = cairo_create();\n+  g_assert (gr->cr != NULL);\n+\n+  widget = GTK_WIDGET (ptr);\n+  g_assert (widget != NULL);\n+\n+  grab_current_drawable (widget, &(gr->drawable), &(gr->win));\n+  g_assert (gr->drawable != NULL);\n+\n+  if (x_server_has_render_extension ())\n+    init_graphics2d_as_renderable (gr);\n+  else\n+    init_graphics2d_as_pixbuf (gr);\n+\n+  color = current_colors_of_widget (widget, env);\n+\n+  gdk_threads_leave ();\n+  NSA_SET_G2D_PTR (env, obj, gr);\n+  return color;\n+}\n+\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics2D_dispose\n+  (JNIEnv *env, jobject obj)\n+{\n+  struct graphics2d *gr = NULL;\n+\n+  gr = (struct graphics2d *) NSA_DEL_G2D_PTR (env, obj);\n+  if (gr == NULL) \n+    return; /* dispose has been called more than once */\n+  \n+  gdk_threads_enter ();\n+\n+  if (gr->surface)\n+    cairo_surface_destroy (gr->surface);\n+\n+  cairo_destroy (gr->cr);\n+\n+  if (gr->drawbuf)\n+    g_object_unref (gr->drawbuf); \n+\n+  g_object_unref (gr->drawable);\n+  free (gr);\n+\n+  if (gr->pattern)\n+    cairo_surface_destroy (gr->pattern);\n+\n+  if (gr->pattern_pixels)\n+    free (gr->pattern_pixels);\n+\n+  if (gr->debug) printf (\"disposed of graphics2d\\n\");\n+\n+  gdk_threads_leave ();\n+}\n+\n+\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics2D_setGradient \n+  (JNIEnv *env, jobject obj, \n+   jdouble x1, jdouble y1, \n+   jdouble x2, jdouble y2,\n+   jint r1, jint g1, jint b1, jint a1,\n+   jint r2, jint g2, jint b2, jint a2,\n+   jboolean cyclic)\n+{\n+  struct graphics2d *gr = NULL;\n+  cairo_surface_t *surf = NULL;\n+  cairo_matrix_t *mat = NULL;\n+  gr = (struct graphics2d *) NSA_GET_G2D_PTR (env, obj);\n+  g_assert (gr != NULL);\n+\n+  if (gr->debug) printf (\"setGradient (%f,%f) -> (%f,%f); (%d,%d,%d,%d) -> (%d,%d,%d,%d)\\n\",\n+\t\t\t x1, y1, \n+\t\t\t x2, y2, \n+\t\t\t r1, g1, b1, a1, \n+\t\t\t r2, g2, b2, a2);\n+  \n+  cairo_save (gr->cr);\n+  \n+  if (cyclic)\n+    surf = cairo_surface_create_similar (gr->surface, CAIRO_FORMAT_ARGB32, 3, 2);\n+  else\n+    surf = cairo_surface_create_similar (gr->surface, CAIRO_FORMAT_ARGB32, 2, 2);      \n+  g_assert (surf != NULL);\n+\n+  cairo_set_target_surface (gr->cr, surf);\n+  \n+  cairo_identity_matrix (gr->cr);\n+\n+  cairo_set_rgb_color (gr->cr, r1 / 255.0, g1 / 255.0, b1 / 255.0);\n+  cairo_set_alpha (gr->cr, a1 / 255.0);\n+  cairo_rectangle (gr->cr, 0, 0, 1, 2);\n+  cairo_fill (gr->cr);\n+    \n+  cairo_set_rgb_color (gr->cr, r2 / 255.0, g2 / 255.0, b2 / 255.0);\n+  cairo_set_alpha (gr->cr, a2 / 255.0);\n+  cairo_rectangle (gr->cr, 1, 0, 1, 2);\n+  cairo_fill (gr->cr);\n+\n+  if (cyclic)\n+    {\n+      cairo_set_rgb_color (gr->cr, r1 / 255.0, g1 / 255.0, b1 / 255.0);\n+      cairo_set_alpha (gr->cr, a1 / 255.0);\n+      cairo_rectangle (gr->cr, 2, 0, 1, 2);\n+      cairo_fill (gr->cr);\n+    }\n+\n+  mat = cairo_matrix_create ();\n+  g_assert (mat != NULL);\n+\n+  /* \n+     consider the vector [x2 - x1, y2 - y1] = [p,q]\n+\n+     this is a line in space starting at an 'origin' x1, y1.\n+\n+     it can also be thought of as a \"transformed\" unit vector in either the\n+     x or y directions. we have just *drawn* our gradient as a unit vector\n+     (well, a 2-3x unit vector) in the x dimension. so what we want to know\n+     is which transformation turns our existing unit vector into [p,q].\n+\n+     which means solving for M in \n+ \n+     [p,q] = M[1,0]\n+\n+     [p,q] = |a b| [1,0]\n+             |c d|      \n+\n+     [p,q] = [a,c], with b = d = 0.\n+\n+     what does this mean? it means that our gradient is 1-dimensional; as\n+     you move through the x axis of our 2 or 3 pixel gradient from logical\n+     x positions 0 to 1, the transformation of your x coordinate under the\n+     matrix M causes you to accumulate both x and y values in fill\n+     space. the y value of a gradient coordinate is ignored, since the\n+     gradient is one dimensional. which is correct.\n+\n+     unfortunately we want the opposite transformation, it seems, because of\n+     the way cairo is going to use this transformation. I'm a bit confused by\n+     that, but it seems to work right, so we take reciprocals of values and\n+     negate offsets. oh well.\n+     \n+   */\n+\n+  double a = (x2 - x1 == 0.) ? 0. : ((cyclic ? 3.0 : 2.0) / (x2 - x1));\n+  double c = (y2 - y1 == 0.) ? 0. : (1. / (y2 - y1));\n+  double dx = (x1 == 0.) ? 0. : 1. / x1;\n+  double dy = (y1 == 0.) ? 0. : 1. / y1;\n+\n+  cairo_matrix_set_affine (mat,\n+\t\t\t   a, 0.,\n+\t\t\t   c, 0.,\n+\t\t\t   dx, dy);\n+\n+  cairo_surface_set_matrix (surf, mat);\n+  cairo_matrix_destroy (mat);\n+  cairo_surface_set_filter (surf, CAIRO_FILTER_BILINEAR);\n+\n+  /* FIXME: repeating gradients (not to mention hold gradients) don't seem to work. */\n+  /*   cairo_surface_set_repeat (surf, cyclic ? 1 : 0); */\n+\n+  if (gr->pattern)\n+    cairo_surface_destroy (gr->pattern);\n+\n+  if (gr->pattern_pixels)\n+    {\n+      free (gr->pattern_pixels);\n+      gr->pattern_pixels = NULL;\n+    }\n+\n+  gr->pattern = surf;  \n+\n+  cairo_restore (gr->cr);    \n+  cairo_set_pattern (gr->cr, gr->pattern);\n+\n+}\n+\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics2D_setTexturePixels \n+  (JNIEnv *env, jobject obj, jintArray jarr, jint w, jint h, jint stride)\n+{\n+  struct graphics2d *gr = NULL;\n+  jint *jpixels = NULL;\n+\n+  gr = (struct graphics2d *) NSA_GET_G2D_PTR (env, obj);\n+  g_assert (gr != NULL);\n+\n+  if (gr->debug) printf (\"setTexturePixels (%d pixels, %dx%d, stride: %d)\\n\",\n+\t\t\t (*env)->GetArrayLength (env, jarr), w, h, stride);\n+\n+  if (gr->pattern)\n+    cairo_surface_destroy (gr->pattern);\n+\n+  if (gr->pattern_pixels)\n+    free (gr->pattern_pixels);\n+\n+  gr->pattern = NULL;\n+  gr->pattern_pixels = NULL;\n+\n+  gr->pattern_pixels = (char *) malloc (h * stride * 4);\n+  g_assert (gr->pattern_pixels != NULL);\n+\n+  jpixels = (*env)->GetIntArrayElements (env, jarr, NULL);\n+  g_assert (jpixels != NULL);\n+  memcpy (gr->pattern_pixels, jpixels, h * stride * 4);\n+  (*env)->ReleaseIntArrayElements (env, jarr, jpixels, 0);\n+\n+  gr->pattern = cairo_surface_create_for_image (gr->pattern_pixels, \n+\t\t\t\t\t\tCAIRO_FORMAT_ARGB32, \n+\t\t\t\t\t\tw, h, stride * 4);\n+  g_assert (gr->pattern != NULL);\n+  cairo_surface_set_repeat (gr->pattern, 1);\n+  cairo_set_pattern (gr->cr, gr->pattern);\n+\n+}\n+\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics2D_drawPixels \n+  (JNIEnv *env, jobject obj, jintArray jarr, jint w, jint h, jint stride)\n+{\n+  struct graphics2d *gr = NULL;\n+  jint *jpixels = NULL;\n+\n+  gr = (struct graphics2d *) NSA_GET_G2D_PTR (env, obj);\n+  g_assert (gr != NULL);\n+\n+  if (gr->debug) printf (\"drawPixels (%d pixels, %dx%d, stride: %d)\\n\",\n+\t\t\t (*env)->GetArrayLength (env, jarr), w, h, stride);\n+\n+  jpixels = (*env)->GetIntArrayElements (env, jarr, NULL);\n+  g_assert (jpixels != NULL);\n+\n+  begin_drawing_operation (gr);\n+\n+ {\n+   cairo_surface_t *surf = cairo_surface_create_for_image ((char *)jpixels, \n+\t\t\t\t\t\t\t   CAIRO_FORMAT_ARGB32, \n+\t\t\t\t\t\t\t   w, h, stride * 4);   \n+   cairo_surface_set_filter (surf, CAIRO_FILTER_BILINEAR);\n+   cairo_show_surface (gr->cr, surf, w, h);\n+   cairo_surface_destroy (surf);\n+ }\n+\n+  end_drawing_operation (gr);\n+\n+  (*env)->ReleaseIntArrayElements (env, jarr, jpixels, 0);\n+\n+}\n+\n+/* passthrough methods to cairo */\n+\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics2D_cairoSave \n+   (JNIEnv *env, jobject obj)\n+{\n+  struct graphics2d *gr = NULL;\n+  gr = (struct graphics2d *) NSA_GET_G2D_PTR (env, obj);\n+  g_assert (gr != NULL);\n+  if (gr->debug) printf (\"cairo_save\\n\");\n+  cairo_save (gr->cr);\n+}\n+\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics2D_cairoRestore \n+   (JNIEnv *env, jobject obj)\n+{\n+  struct graphics2d *gr = NULL;\n+  gr = (struct graphics2d *) NSA_GET_G2D_PTR (env, obj);\n+  g_assert (gr != NULL);\n+  if (gr->debug) printf (\"cairo_restore\\n\");\n+  cairo_restore (gr->cr);\n+  update_pattern_transform (gr);\n+}\n+\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics2D_cairoSetMatrix \n+   (JNIEnv *env, jobject obj,\n+    jdouble m00, jdouble m10,\n+    jdouble m01, jdouble m11,\n+    jdouble m02, jdouble m12)\n+{\n+  struct graphics2d *gr = NULL;\n+  gr = (struct graphics2d *) NSA_GET_G2D_PTR (env, obj);\n+  g_assert (gr != NULL);\n+  if (gr->debug) printf (\"cairo_set_matrix\\n\");\n+\n+  {\n+    cairo_matrix_t * mat = cairo_matrix_create ();\n+    cairo_matrix_set_affine (mat,\n+\t\t\t     m00, m10,\n+\t\t\t     m01, m11,\n+\t\t\t     m02, m12);\n+    cairo_set_matrix (gr->cr, mat);\n+    cairo_matrix_destroy (mat);\n+  }\n+  update_pattern_transform (gr);\n+}\n+\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics2D_cairoSetOperator \n+   (JNIEnv *env, jobject obj, jint op)\n+{\n+  struct graphics2d *gr = NULL;\n+  gr = (struct graphics2d *) NSA_GET_G2D_PTR (env, obj);\n+  g_assert (gr != NULL);\n+  if (gr->debug) printf (\"cairo_set_operator %d\\n\", op);\n+  switch ((enum java_awt_alpha_composite_rule) op)\n+    {\n+    case java_awt_alpha_composite_CLEAR: \n+      cairo_set_operator (gr->cr, CAIRO_OPERATOR_CLEAR);\n+      break;\n+      \n+    case java_awt_alpha_composite_SRC: \n+      cairo_set_operator (gr->cr, CAIRO_OPERATOR_SRC);\n+      break;\n+      \n+    case java_awt_alpha_composite_SRC_OVER: \n+      cairo_set_operator (gr->cr, CAIRO_OPERATOR_OVER);\n+      break;\n+\n+    case java_awt_alpha_composite_DST_OVER: \n+      cairo_set_operator (gr->cr, CAIRO_OPERATOR_OVER_REVERSE);\n+      break;\n+\n+    case java_awt_alpha_composite_SRC_IN: \n+      cairo_set_operator (gr->cr, CAIRO_OPERATOR_IN);\n+      break;\n+\n+    case java_awt_alpha_composite_DST_IN: \n+      cairo_set_operator (gr->cr, CAIRO_OPERATOR_IN_REVERSE);\n+      break;\n+\n+    case java_awt_alpha_composite_SRC_OUT: \n+      cairo_set_operator (gr->cr, CAIRO_OPERATOR_OUT);\n+      break;\n+\n+    case java_awt_alpha_composite_DST_OUT: \n+      cairo_set_operator (gr->cr, CAIRO_OPERATOR_OUT_REVERSE);\n+      break;\n+\n+    case java_awt_alpha_composite_DST: \n+      cairo_set_operator (gr->cr, CAIRO_OPERATOR_DST);\n+      break;\n+\n+    case java_awt_alpha_composite_SRC_ATOP: \n+      cairo_set_operator (gr->cr, CAIRO_OPERATOR_ATOP);\n+      break;\n+\n+    case java_awt_alpha_composite_DST_ATOP: \n+      cairo_set_operator (gr->cr, CAIRO_OPERATOR_ATOP_REVERSE);\n+      break;\n+\n+    case java_awt_alpha_composite_XOR: \n+      cairo_set_operator (gr->cr, CAIRO_OPERATOR_XOR);\n+      break;\n+    }\n+}\n+\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics2D_cairoSetRGBColor \n+   (JNIEnv *env, jobject obj, jdouble r, jdouble g, jdouble b)\n+{\n+  struct graphics2d *gr = NULL;\n+  gr = (struct graphics2d *) NSA_GET_G2D_PTR (env, obj);\n+  g_assert (gr != NULL);\n+\n+  /* this is a very weird fact: GDK Pixbufs and RENDER drawables consider\n+     colors in opposite pixel order. I have no idea why.  thus when you\n+     draw to a PixBuf, you must exchange the R and B components of your\n+     color. */\n+\n+  if (gr->debug) printf (\"cairo_set_rgb_color (%f, %f, %f)\\n\", r, g, b);\n+\n+  if (gr->drawbuf)\n+    cairo_set_rgb_color (gr->cr, b, g, r);\n+  else\n+    cairo_set_rgb_color (gr->cr, r, g, b);\n+}\n+\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics2D_cairoSetAlpha \n+   (JNIEnv *env, jobject obj, jdouble a)\n+{\n+  struct graphics2d *gr = NULL;\n+  gr = (struct graphics2d *) NSA_GET_G2D_PTR (env, obj);\n+  g_assert (gr != NULL);\n+  if (gr->debug) printf (\"cairo_set_alpha %f\\n\", a);\n+  cairo_set_alpha (gr->cr, a);\n+}\n+\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics2D_cairoSetFillRule \n+   (JNIEnv *env, jobject obj, jint rule)\n+{\n+  struct graphics2d *gr = NULL;\n+  gr = (struct graphics2d *) NSA_GET_G2D_PTR (env, obj);\n+  if (gr->debug) printf (\"cairo_set_fill_rule %d\\n\", rule);\n+  g_assert (gr != NULL);\n+  switch ((enum java_awt_geom_path_iterator_winding_rule) rule)\n+    {\n+    case java_awt_geom_path_iterator_WIND_NON_ZERO:\n+      cairo_set_fill_rule (gr->cr, CAIRO_FILL_RULE_WINDING);\n+      break;\n+    case java_awt_geom_path_iterator_WIND_EVEN_ODD:\n+      cairo_set_fill_rule (gr->cr, CAIRO_FILL_RULE_EVEN_ODD);\n+      break;\n+    }  \n+}\n+\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics2D_cairoSetLineWidth \n+   (JNIEnv *env, jobject obj, jdouble width)\n+{\n+  struct graphics2d *gr = NULL;\n+  gr = (struct graphics2d *) NSA_GET_G2D_PTR (env, obj);\n+  g_assert (gr != NULL);\n+  if (gr->debug) printf (\"cairo_set_line_width %f\\n\", width);\n+  cairo_set_line_width (gr->cr, width);\n+}\n+\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics2D_cairoSetLineCap \n+   (JNIEnv *env, jobject obj, jint cap)\n+{\n+  struct graphics2d *gr = NULL;\n+  gr = (struct graphics2d *) NSA_GET_G2D_PTR (env, obj);\n+  g_assert (gr != NULL);\n+  if (gr->debug) printf (\"cairo_set_line_cap %d\\n\", cap);\n+  switch ((enum java_awt_basic_stroke_cap_rule) cap)\n+    {\n+    case java_awt_basic_stroke_CAP_BUTT: \n+      cairo_set_line_cap (gr->cr, CAIRO_LINE_CAP_BUTT);\n+      break;\n+\n+    case java_awt_basic_stroke_CAP_ROUND: \n+      cairo_set_line_cap (gr->cr, CAIRO_LINE_CAP_ROUND);\n+      break;\n+\n+    case java_awt_basic_stroke_CAP_SQUARE: \n+      cairo_set_line_cap (gr->cr, CAIRO_LINE_CAP_SQUARE);\n+      break;\n+    }\n+}\n+\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics2D_cairoSetLineJoin \n+   (JNIEnv *env, jobject obj, jint join)\n+{\n+  struct graphics2d *gr = NULL;\n+  gr = (struct graphics2d *) NSA_GET_G2D_PTR (env, obj);\n+  g_assert (gr != NULL);\n+  if (gr->debug) printf (\"cairo_set_line_join %d\\n\", join);\n+  switch ((enum java_awt_basic_stroke_join_rule) join)\n+    {\n+    case java_awt_basic_stroke_JOIN_MITER:\n+      cairo_set_line_join (gr->cr, CAIRO_LINE_JOIN_MITER);\n+      break;\n+\n+    case java_awt_basic_stroke_JOIN_ROUND:\n+      cairo_set_line_join (gr->cr, CAIRO_LINE_JOIN_ROUND);\n+      break;\n+\n+    case java_awt_basic_stroke_JOIN_BEVEL:\n+      cairo_set_line_join (gr->cr, CAIRO_LINE_JOIN_BEVEL);\n+      break;\n+    }\n+}\n+\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics2D_cairoSetDash \n+   (JNIEnv *env, jobject obj, jdoubleArray dashes, jint ndash, jdouble offset)\n+{\n+  struct graphics2d *gr = NULL;\n+  jdouble *dasharr = NULL;\n+  gr = (struct graphics2d *) NSA_GET_G2D_PTR (env, obj);\n+  g_assert (gr != NULL);\n+  if (gr->debug) printf (\"cairo_set_dash\\n\");\n+  dasharr = (*env)->GetDoubleArrayElements (env, dashes, NULL);  \n+  g_assert (dasharr != NULL);\n+  cairo_set_dash (gr->cr, dasharr, ndash, offset);\n+  (*env)->ReleaseDoubleArrayElements (env, dashes, dasharr, 0);\n+}\n+\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics2D_cairoSetMiterLimit \n+   (JNIEnv *env, jobject obj, jdouble miter)\n+{\n+  struct graphics2d *gr = NULL;\n+  gr = (struct graphics2d *) NSA_GET_G2D_PTR (env, obj);\n+  g_assert (gr != NULL);\n+  if (gr->debug) printf (\"cairo_set_miter_limit %f\\n\", miter);\n+  cairo_set_miter_limit (gr->cr, miter);\n+}\n+\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics2D_cairoTranslate \n+   (JNIEnv *env, jobject obj, jdouble dx, jdouble dy)\n+{\n+  struct graphics2d *gr = NULL;\n+  gr = (struct graphics2d *) NSA_GET_G2D_PTR (env, obj);\n+  g_assert (gr != NULL);\n+  if (gr->debug) printf (\"cairo_translate (%f, %f)\\n\", dx, dy);\n+  cairo_translate (gr->cr, dx, dy);\n+  update_pattern_transform (gr);\n+}\n+\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics2D_cairoScale \n+   (JNIEnv *env, jobject obj, jdouble sx, jdouble sy)\n+{\n+  struct graphics2d *gr = NULL;\n+  gr = (struct graphics2d *) NSA_GET_G2D_PTR (env, obj);\n+  g_assert (gr != NULL);\n+  if (gr->debug) printf (\"cairo_scale (%f, %f)\\n\", sx, sy);\n+  cairo_scale (gr->cr, sx, sy);\n+  update_pattern_transform (gr);\n+}\n+\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics2D_cairoRotate \n+   (JNIEnv *env, jobject obj, jdouble angle)\n+{\n+  struct graphics2d *gr = NULL;\n+  gr = (struct graphics2d *) NSA_GET_G2D_PTR (env, obj);\n+  g_assert (gr != NULL);\n+  if (gr->debug) printf (\"cairo_rotate %f\\n\", angle);\n+  cairo_rotate (gr->cr, angle);\n+  update_pattern_transform (gr);\n+}\n+\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics2D_cairoNewPath \n+   (JNIEnv *env, jobject obj)\n+{\n+  struct graphics2d *gr = NULL;\n+  gr = (struct graphics2d *) NSA_GET_G2D_PTR (env, obj);\n+  g_assert (gr != NULL);\n+  if (gr->debug) printf (\"cairo_new_path\\n\");\n+  cairo_new_path (gr->cr);\n+}\n+\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics2D_cairoMoveTo \n+   (JNIEnv *env, jobject obj, jdouble x, jdouble y)\n+{\n+  struct graphics2d *gr = NULL;\n+  gr = (struct graphics2d *) NSA_GET_G2D_PTR (env, obj);\n+  g_assert (gr != NULL);\n+  if (gr->debug) printf (\"cairo_move_to (%f, %f)\\n\", x, y);\n+  cairo_move_to (gr->cr, x, y);\n+}\n+\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics2D_cairoLineTo \n+   (JNIEnv *env, jobject obj, jdouble x, jdouble y)\n+{\n+  struct graphics2d *gr = NULL;\n+  gr = (struct graphics2d *) NSA_GET_G2D_PTR (env, obj);\n+  g_assert (gr != NULL);\n+  if (gr->debug) printf (\"cairo_line_to (%f, %f)\\n\", x, y);\n+  cairo_line_to (gr->cr, x, y);\n+}\n+\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics2D_cairoCurveTo \n+   (JNIEnv *env, jobject obj, jdouble x1, jdouble y1, jdouble x2, jdouble y2, jdouble x3, jdouble y3)\n+{\n+  struct graphics2d *gr = NULL;\n+  gr = (struct graphics2d *) NSA_GET_G2D_PTR (env, obj);\n+  g_assert (gr != NULL);\n+  if (gr->debug) printf (\"cairo_curve_to (%f, %f), (%f, %f), (%f, %f)\\n\", x1, y1, x2, y2, x3, y3);\n+  cairo_curve_to (gr->cr, x1, y1, x2, y2, x3, y3);\n+}\n+\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics2D_cairoRelMoveTo \n+   (JNIEnv *env, jobject obj, jdouble dx, jdouble dy)\n+{\n+  struct graphics2d *gr = NULL;\n+  gr = (struct graphics2d *) NSA_GET_G2D_PTR (env, obj);\n+  g_assert (gr != NULL);\n+  if (gr->debug) printf (\"cairo_rel_move_to (%f, %f)\\n\", dx, dy);\n+  cairo_rel_move_to (gr->cr, dx, dy);\n+}\n+\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics2D_cairoRelLineTo \n+   (JNIEnv *env, jobject obj, jdouble dx, jdouble dy)\n+{\n+  struct graphics2d *gr = NULL;\n+  gr = (struct graphics2d *) NSA_GET_G2D_PTR (env, obj);\n+  g_assert (gr != NULL);\n+  if (gr->debug) printf (\"cairo_rel_line_to (%f, %f)\\n\", dx, dy);\n+  cairo_rel_line_to (gr->cr, dx, dy);\n+}\n+\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics2D_cairoRelCurveTo \n+   (JNIEnv *env, jobject obj, jdouble dx1, jdouble dy1, jdouble dx2, jdouble dy2, jdouble dx3, jdouble dy3)\n+{\n+  struct graphics2d *gr = NULL;\n+  gr = (struct graphics2d *) NSA_GET_G2D_PTR (env, obj);\n+  g_assert (gr != NULL);\n+  if (gr->debug) printf (\"cairo_rel_curve_to (%f, %f), (%f, %f), (%f, %f)\\n\", dx1, dy1, dx2, dy2, dx3, dy3);\n+  cairo_rel_curve_to (gr->cr, dx1, dy1, dx2, dy2, dx3, dy3);\n+}\n+\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics2D_cairoRectangle \n+   (JNIEnv *env, jobject obj, jdouble x, jdouble y, jdouble width, jdouble height)\n+{\n+  struct graphics2d *gr = NULL;\n+  gr = (struct graphics2d *) NSA_GET_G2D_PTR (env, obj);\n+  g_assert (gr != NULL);\n+  if (gr->debug) printf (\"cairo_rectangle (%f, %f) (%f, %f)\\n\", x, y, width, height);\n+  cairo_rectangle (gr->cr, x, y, width, height);\n+}\n+\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics2D_cairoClosePath \n+   (JNIEnv *env, jobject obj)\n+{\n+  struct graphics2d *gr = NULL;\n+  gr = (struct graphics2d *) NSA_GET_G2D_PTR (env, obj);\n+  g_assert (gr != NULL);\n+  if (gr->debug) printf (\"cairo_close_path\\n\");\n+  cairo_close_path (gr->cr);\n+}\n+\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics2D_cairoStroke \n+   (JNIEnv *env, jobject obj)\n+{\n+  struct graphics2d *gr = NULL;\n+  gr = (struct graphics2d *) NSA_GET_G2D_PTR (env, obj);\n+  g_assert (gr != NULL);\n+  if (gr->debug) printf (\"cairo_stroke\\n\");\n+  begin_drawing_operation (gr);\n+  cairo_stroke (gr->cr);\n+  end_drawing_operation (gr);\n+}\n+\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics2D_cairoFill \n+   (JNIEnv *env, jobject obj)\n+{\n+  struct graphics2d *gr = NULL;\n+  gr = (struct graphics2d *) NSA_GET_G2D_PTR (env, obj);\n+  g_assert (gr != NULL);\n+  if (gr->debug) printf (\"cairo_fill\\n\");\n+  begin_drawing_operation (gr);\n+  cairo_fill (gr->cr);\n+  end_drawing_operation (gr);\n+}\n+\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics2D_cairoClip \n+   (JNIEnv *env, jobject obj)\n+{\n+  struct graphics2d *gr = NULL;\n+  gr = (struct graphics2d *) NSA_GET_G2D_PTR (env, obj);\n+  g_assert (gr != NULL);\n+  if (gr->debug) printf (\"cairo_clip\\n\");\n+  cairo_clip (gr->cr);\n+}\n+"}, {"sha": "0d755721649644d282124e9307c1bde3fedd9343", "filename": "libjava/jni/gtk-peer/gnu_java_awt_peer_gtk_GdkPixbufDecoder.c", "status": "added", "additions": 236, "deletions": 0, "changes": 236, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fe2d5fb0998455d5faec36e62a8919ad16c939f/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkPixbufDecoder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fe2d5fb0998455d5faec36e62a8919ad16c939f/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkPixbufDecoder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkPixbufDecoder.c?ref=1fe2d5fb0998455d5faec36e62a8919ad16c939f", "patch": "@@ -0,0 +1,236 @@\n+/* gdkpixbufdecoder.c\n+   Copyright (C) 1999, 2003 Free Software Foundation, Inc.\n+\n+   This file is part of GNU Classpath.\n+   \n+   GNU Classpath is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+   \n+   GNU Classpath is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+   \n+   You should have received a copy of the GNU General Public License\n+   along with GNU Classpath; see the file COPYING.  If not, write to the\n+   Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+   02111-1307 USA.\n+   \n+   Linking this library statically or dynamically with other modules is\n+   making a combined work based on this library.  Thus, the terms and\n+   conditions of the GNU General Public License cover the whole\n+   combination.\n+   \n+   As a special exception, the copyright holders of this library give you\n+   permission to link this library with independent modules to produce an\n+   executable, regardless of the license terms of these independent\n+   modules, and to copy and distribute the resulting executable under\n+   terms of your choice, provided that you also meet, for each linked\n+   independent module, the terms and conditions of the license of that\n+   module.  An independent module is a module which is not derived from\n+   or based on this library.  If you modify this library, you may extend\n+   this exception to your version of the library, but you are not\n+   obligated to do so.  If you do not wish to do so, delete this\n+   exception statement from your version. */\n+\n+\n+#include <gtk/gtk.h>\n+#include <gdk-pixbuf/gdk-pixbuf.h>\n+#include <gdk-pixbuf/gdk-pixbuf-loader.h>\n+\n+#include \"gtkpeer.h\"\n+#include \"gnu_java_awt_peer_gtk_GdkPixbufDecoder.h\"\n+\n+struct state_table *native_pixbufdecoder_state_table;\n+\n+#define NSA_PB_INIT(env, clazz) \\\n+  native_pixbufdecoder_state_table = init_state_table (env, clazz)\n+\n+#define NSA_GET_PB_PTR(env, obj) \\\n+  get_state (env, obj, native_pixbufdecoder_state_table)\n+\n+#define NSA_SET_PB_PTR(env, obj, ptr) \\\n+  set_state (env, obj, native_pixbufdecoder_state_table, (void *)ptr)\n+\n+#define NSA_DEL_PB_PTR(env, obj) \\\n+  remove_state_slot (env, obj, native_pixbufdecoder_state_table)\n+\n+\n+jmethodID areaPreparedID;\n+jmethodID areaUpdatedID;\n+\n+static void\n+area_prepared (GdkPixbufLoader *loader, \n+\t       jobject *decoder)\n+{\n+  jint width, height;\n+\n+  GdkPixbuf *pixbuf = gdk_pixbuf_loader_get_pixbuf (loader);\n+  if (pixbuf == NULL)\n+    return;\n+\n+  width = gdk_pixbuf_get_width (pixbuf); \n+  height = gdk_pixbuf_get_height (pixbuf), \n+\n+  gdk_threads_leave ();\n+\n+  g_assert (decoder != NULL);\n+\n+  (*gdk_env)->CallVoidMethod (gdk_env,\n+\t\t\t      *decoder,\n+\t\t\t      areaPreparedID,\n+\t\t\t      width, height);\n+\n+  gdk_threads_enter ();\n+}\n+\n+static void\n+area_updated (GdkPixbufLoader *loader, \n+\t      gint x, gint y, \n+\t      gint width, gint height,\n+\t      jobject *decoder)\n+{\n+  jint stride_bytes, stride_pixels, n_channels, n_pixels;\n+  int i, px;\n+  jintArray jpixels;  \n+  jint *java_pixels;\n+  guchar *gdk_pixels;\n+\n+  GdkPixbuf *pixbuf_no_alpha = NULL;\n+  GdkPixbuf *pixbuf = NULL;\n+  \n+  pixbuf_no_alpha = gdk_pixbuf_loader_get_pixbuf (loader);\n+  if (pixbuf_no_alpha == NULL)\n+    return;\n+\n+  pixbuf = gdk_pixbuf_add_alpha(pixbuf_no_alpha, FALSE, 0, 0, 0);\n+  g_assert (gdk_pixbuf_get_has_alpha (pixbuf));\n+  \n+  stride_bytes = gdk_pixbuf_get_rowstride (pixbuf);\n+  n_channels = gdk_pixbuf_get_n_channels (pixbuf);\n+  stride_pixels =  stride_bytes / n_channels;\n+  n_pixels = height * stride_pixels;\n+  gdk_pixels = gdk_pixbuf_get_pixels (pixbuf);\n+\n+  jpixels = (*gdk_env)->NewIntArray (gdk_env, n_pixels);\n+  java_pixels = (*gdk_env)->GetIntArrayElements (gdk_env, jpixels, NULL);\n+\n+  memcpy (java_pixels, \n+\t  gdk_pixels + (y * stride_bytes), \n+\t  (height * stride_bytes));\n+\n+  for (i = 0; i < n_pixels; ++i)\n+    {\n+      px = java_pixels[i];\n+\n+      /* move alpha around (GdkPixbufLoader results are AGBR not GBRA, in\n+\t the lsb sense) */\n+      /* px = ((px >> 24) & 0xff) | ((px << 8) & 0xffffff00); */\n+\n+      /* it appears to require a full byte swap, now, not just a shift to\n+\t the A channel. why did this change? don't know. */\n+      px = ((px >>  8) & 0x00ff00ff) | ((px <<  8) & 0xff00ff00); \n+      px = ((px >> 16) & 0x0000ffff) | ((px << 16) & 0xffff0000); \n+\n+      java_pixels[i] = px;\n+    }\n+\n+  g_object_unref (pixbuf);\n+\n+  gdk_threads_leave ();\n+\n+  (*gdk_env)->ReleaseIntArrayElements (gdk_env, jpixels, java_pixels, 0);\n+  (*gdk_env)->CallVoidMethod (gdk_env, \n+\t\t\t      *decoder, \n+\t\t\t      areaUpdatedID,\n+\t\t\t      (jint) x, (jint) y,\n+\t\t\t      (jint) width, (jint) height,\n+\t\t\t      jpixels,\n+\t\t\t      stride_pixels);\n+  gdk_threads_enter ();\n+}\n+\n+static void\n+closed (GdkPixbufLoader *loader, jobject *decoder)\n+{\n+  gdk_threads_leave ();\n+  (*gdk_env)->DeleteGlobalRef (gdk_env, *decoder); \n+  free (decoder);\n+  gdk_threads_enter ();\n+}\n+\n+\n+\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkPixbufDecoder_initState\n+  (JNIEnv *env, jobject obj)\n+{\n+  GdkPixbufLoader *loader = NULL;\n+  jobject *decoder = NULL;\n+\n+  decoder = (jobject *) malloc (sizeof (jobject));\n+  g_assert (decoder != NULL);\n+  *decoder = (*env)->NewGlobalRef (env, obj);\n+\n+  gdk_threads_enter ();\n+  loader = gdk_pixbuf_loader_new ();\n+  g_assert (loader != NULL);  \n+  g_signal_connect (loader, \"area-prepared\", G_CALLBACK (area_prepared), decoder);  \n+  g_signal_connect (loader, \"area-updated\", G_CALLBACK (area_updated), decoder);\n+  g_signal_connect (loader, \"closed\", G_CALLBACK (closed), decoder);\n+  gdk_threads_leave ();\n+\n+  NSA_SET_PB_PTR (env, obj, loader);\n+}\n+\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkPixbufDecoder_initStaticState \n+  (JNIEnv *env, jclass clazz)\n+{\n+  areaPreparedID = (*env)->GetMethodID (env, clazz, \n+\t\t\t\t        \"areaPrepared\", \n+\t\t\t\t\t\"(II)V\");\n+\n+  areaUpdatedID = (*env)->GetMethodID (env, clazz,\n+\t\t\t\t       \"areaUpdated\",\n+\t\t\t\t       \"(IIII[II)V\");\n+  NSA_PB_INIT (env, clazz);\n+}\n+\n+\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkPixbufDecoder_finish\n+  (JNIEnv *env, jobject obj)\n+{\n+  GdkPixbufLoader *loader = NULL;\n+\n+  loader = (GdkPixbufLoader *)NSA_DEL_PB_PTR (env, obj);\n+  if (loader == NULL)\n+    return;\n+\n+  gdk_threads_enter ();\n+  gdk_pixbuf_loader_close (loader, NULL);\n+  g_object_unref (loader);\n+  gdk_threads_leave (); \n+}\n+\n+\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkPixbufDecoder_pumpBytes\n+  (JNIEnv *env, jobject obj, jbyteArray jarr, jint len)\n+{\n+  GdkPixbufLoader *loader = NULL;\n+  jbyte *bytes = NULL;\n+\n+  if (len < 1)\n+    return;\n+\n+  bytes = (*gdk_env)->GetByteArrayElements (gdk_env, jarr, NULL);\n+  g_assert (bytes != NULL);\n+  loader = (GdkPixbufLoader *)NSA_GET_PB_PTR (env, obj);\n+  g_assert (loader != NULL);\n+\n+  gdk_threads_enter ();\n+  gdk_pixbuf_loader_write (loader, bytes, len, NULL);\n+  gdk_threads_leave ();\n+\n+  (*gdk_env)->ReleaseByteArrayElements (gdk_env, jarr, bytes, 0);\n+}"}]}