{"sha": "8ffa3150d30b90a11aba7d7bba3c6462b6461101", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGZmYTMxNTBkMzBiOTBhMTFhYmE3ZDdiYmEzYzY0NjJiNjQ2MTEwMQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-05-06T07:46:48Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-05-06T07:46:48Z"}, "message": "Record equivalences for spill registers\n\nIf we decide to allocate a call-clobbered register R to a value that\nis live across a call, LRA will create a new spill register TMPR,\ninsert:\n\n   TMPR <- R\n\nbefore the call and\n\n   R <- TMPR\n\nafter it.  But if we then failed to allocate a register to TMPR, we would\nalways spill it to the stack, even if R was known to be equivalent to\na constant or to some existing memory location.  And on AArch64, we'd\nalways fail to allocate such a register for 128-bit Advanced SIMD modes,\nsince no registers of those modes are call-preserved.\n\nThis patch avoids the problem by copying the equivalence information\nfrom the original pseudo to the spill register.  It means that the\ncode for the testcase is as good with -O2 as it is with -O,\nwhereas previously the -O code was better.\n\n[Based on the code ARM contributed in branches/ARM/sve-branch@247248]\n\n2017-05-06  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* lra-constraints.c (lra_copy_reg_equiv): New function.\n\t(split_reg): Use it to copy equivalence information from the\n\toriginal register to the spill register.\n\ngcc/testsuite/\n\t* gcc.target/aarch64/spill_1.c: New test.\n\nFrom-SVN: r247720", "tree": {"sha": "7d48a218f64b22e0df6870cad3e5169bfba7fe89", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7d48a218f64b22e0df6870cad3e5169bfba7fe89"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8ffa3150d30b90a11aba7d7bba3c6462b6461101", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ffa3150d30b90a11aba7d7bba3c6462b6461101", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ffa3150d30b90a11aba7d7bba3c6462b6461101", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ffa3150d30b90a11aba7d7bba3c6462b6461101/comments", "author": null, "committer": null, "parents": [{"sha": "2a3f79973f7ff22ab936b3919c31df5c704e1715", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a3f79973f7ff22ab936b3919c31df5c704e1715", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a3f79973f7ff22ab936b3919c31df5c704e1715"}], "stats": {"total": 70, "additions": 64, "deletions": 6}, "files": [{"sha": "b0c253b09aea0c496a51b4220ff2a91016858a62", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ffa3150d30b90a11aba7d7bba3c6462b6461101/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ffa3150d30b90a11aba7d7bba3c6462b6461101/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8ffa3150d30b90a11aba7d7bba3c6462b6461101", "patch": "@@ -1,3 +1,9 @@\n+2017-05-06  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* lra-constraints.c (lra_copy_reg_equiv): New function.\n+\t(split_reg): Use it to copy equivalence information from the\n+\toriginal register to the spill register.\n+\n 2017-05-06  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \tPR rtl-optimization/75964"}, {"sha": "b0ae0fe3d9a815e7eca5935c2fa4e786ef51123c", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 36, "deletions": 6, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ffa3150d30b90a11aba7d7bba3c6462b6461101/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ffa3150d30b90a11aba7d7bba3c6462b6461101/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=8ffa3150d30b90a11aba7d7bba3c6462b6461101", "patch": "@@ -5394,6 +5394,29 @@ choose_split_class (enum reg_class allocno_class,\n #endif\n }\n \n+/* Copy any equivalence information from ORIGINAL_REGNO to NEW_REGNO.\n+   It only makes sense to call this function if NEW_REGNO is always\n+   equal to ORIGINAL_REGNO.  */\n+\n+static void\n+lra_copy_reg_equiv (unsigned int new_regno, unsigned int original_regno)\n+{\n+  if (!ira_reg_equiv[original_regno].defined_p)\n+    return;\n+\n+  ira_expand_reg_equiv ();\n+  ira_reg_equiv[new_regno].defined_p = true;\n+  if (ira_reg_equiv[original_regno].memory)\n+    ira_reg_equiv[new_regno].memory\n+      = copy_rtx (ira_reg_equiv[original_regno].memory);\n+  if (ira_reg_equiv[original_regno].constant)\n+    ira_reg_equiv[new_regno].constant\n+      = copy_rtx (ira_reg_equiv[original_regno].constant);\n+  if (ira_reg_equiv[original_regno].invariant)\n+    ira_reg_equiv[new_regno].invariant\n+      = copy_rtx (ira_reg_equiv[original_regno].invariant);\n+}\n+\n /* Do split transformations for insn INSN, which defines or uses\n    ORIGINAL_REGNO.  NEXT_USAGE_INSNS specifies which instruction in\n    the EBB next uses ORIGINAL_REGNO; it has the same form as the\n@@ -5515,6 +5538,7 @@ split_reg (bool before_p, int original_regno, rtx_insn *insn,\n       new_reg = lra_create_new_reg (mode, original_reg, rclass, \"split\");\n       reg_renumber[REGNO (new_reg)] = hard_regno;\n     }\n+  int new_regno = REGNO (new_reg);\n   save = emit_spill_move (true, new_reg, original_reg);\n   if (NEXT_INSN (save) != NULL_RTX && !call_save_p)\n     {\n@@ -5523,7 +5547,7 @@ split_reg (bool before_p, int original_regno, rtx_insn *insn,\n \t  fprintf\n \t    (lra_dump_file,\n \t     \"\t  Rejecting split %d->%d resulting in > 2 save insns:\\n\",\n-\t     original_regno, REGNO (new_reg));\n+\t     original_regno, new_regno);\n \t  dump_rtl_slim (lra_dump_file, save, NULL, -1, 0);\n \t  fprintf (lra_dump_file,\n \t\t   \"\t))))))))))))))))))))))))))))))))))))))))))))))))\\n\");\n@@ -5538,18 +5562,24 @@ split_reg (bool before_p, int original_regno, rtx_insn *insn,\n \t  fprintf (lra_dump_file,\n \t\t   \"\tRejecting split %d->%d \"\n \t\t   \"resulting in > 2 restore insns:\\n\",\n-\t\t   original_regno, REGNO (new_reg));\n+\t\t   original_regno, new_regno);\n \t  dump_rtl_slim (lra_dump_file, restore, NULL, -1, 0);\n \t  fprintf (lra_dump_file,\n \t\t   \"\t))))))))))))))))))))))))))))))))))))))))))))))))\\n\");\n \t}\n       return false;\n     }\n+  /* Transfer equivalence information to the spill register, so that\n+     if we fail to allocate the spill register, we have the option of\n+     rematerializing the original value instead of spilling to the stack.  */\n+  if (!HARD_REGISTER_NUM_P (original_regno)\n+      && mode == PSEUDO_REGNO_MODE (original_regno))\n+    lra_copy_reg_equiv (new_regno, original_regno);\n   after_p = usage_insns[original_regno].after_p;\n-  lra_reg_info[REGNO (new_reg)].restore_rtx = regno_reg_rtx[original_regno];\n-  bitmap_set_bit (&check_only_regs, REGNO (new_reg));\n+  lra_reg_info[new_regno].restore_rtx = regno_reg_rtx[original_regno];\n+  bitmap_set_bit (&check_only_regs, new_regno);\n   bitmap_set_bit (&check_only_regs, original_regno);\n-  bitmap_set_bit (&lra_split_regs, REGNO (new_reg));\n+  bitmap_set_bit (&lra_split_regs, new_regno);\n   for (;;)\n     {\n       if (GET_CODE (next_usage_insns) != INSN_LIST)\n@@ -5565,7 +5595,7 @@ split_reg (bool before_p, int original_regno, rtx_insn *insn,\n       if (lra_dump_file != NULL)\n \t{\n \t  fprintf (lra_dump_file, \"    Split reuse change %d->%d:\\n\",\n-\t\t   original_regno, REGNO (new_reg));\n+\t\t   original_regno, new_regno);\n \t  dump_insn_slim (lra_dump_file, as_a <rtx_insn *> (usage_insn));\n \t}\n     }"}, {"sha": "fca5b87e7983c09dc6bc3e4f297dccbad9f6d5c1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ffa3150d30b90a11aba7d7bba3c6462b6461101/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ffa3150d30b90a11aba7d7bba3c6462b6461101/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8ffa3150d30b90a11aba7d7bba3c6462b6461101", "patch": "@@ -1,3 +1,7 @@\n+2017-05-06  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* gcc.target/aarch64/spill_1.c: New test.\n+\n 2017-05-06  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \tPR rtl-optimization/75964"}, {"sha": "847425895d456e4433b0d15556d60a66a8f8f70c", "filename": "gcc/testsuite/gcc.target/aarch64/spill_1.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ffa3150d30b90a11aba7d7bba3c6462b6461101/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fspill_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ffa3150d30b90a11aba7d7bba3c6462b6461101/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fspill_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fspill_1.c?ref=8ffa3150d30b90a11aba7d7bba3c6462b6461101", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+typedef int v4si __attribute__ ((vector_size (16)));\n+\n+void bar (void);\n+void\n+foo (void)\n+{\n+  v4si x = { 1, 1, 1, 1 };\n+  asm (\"# %0\" :: \"w\" (x));\n+  bar ();\n+  asm (\"# %0\" :: \"w\" (x));\n+}\n+\n+/* { dg-final { scan-assembler-times {\\tmovi\\tv[0-9]+\\.4s,} 2 } } */\n+/* { dg-final { scan-assembler-not {\\tldr\\t} } } */\n+/* { dg-final { scan-assembler-not {\\tstr\\t} } } */"}]}