{"sha": "d7a6176efe2cec2584a9d784c6e228df952862f9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDdhNjE3NmVmZTJjZWMyNTg0YTlkNzg0YzZlMjI4ZGY5NTI4NjJmOQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2005-05-16T22:52:26Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2005-05-16T22:52:26Z"}, "message": "generate-random.c (config.h): Do not include.\n\n\t* gcc.dg/compat/generate-random.c (config.h): Do not include.\n\t(limits.h): Include unconditionally.\n\t(stdlib.h): Likewise.\n\t* gcc.dg/compat/generate-random_r.c (config.h): Do not include.\n\t(limits.h): Include unconditionally.\n\t(stdlib.h): Likewise.\n\t* gcc.dg/compat/struct-layout-1.exp: Do not link with libiberty.\n\t* gcc.dg/compat/struct-layout-1_generate.c (config.h): Do not include.\n\t(limits.h): Include unconditionally.\n\t(stdlib.h): Likewise.\n\t(hashtab.h): Do not include.\n\t(getopt.h): Likewise.\n\t(stddef.h): Include.\n\t(hashval_t): Define.\n\t(struct entry): Add \"next\" field.\n\t(HASH_SIZE): New macro.\n\t(hash_table): New variable.\n\t(switchfiles): Do not use xmalloc.\n\t(mix): New macro.\n\t(iterative_hash): New function.\n\t(hasht): Remove.\n\t(e_exists): New function.\n\t(e_insert): Likewise.\n\t(output): Use, instead of libiberty hashtable functions.\n\t(main): Do not use getopt.  Do not call htab_create.\n\nFrom-SVN: r99799", "tree": {"sha": "d468c91e66290efdf572a3573a071029e6a50131", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d468c91e66290efdf572a3573a071029e6a50131"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d7a6176efe2cec2584a9d784c6e228df952862f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7a6176efe2cec2584a9d784c6e228df952862f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7a6176efe2cec2584a9d784c6e228df952862f9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7a6176efe2cec2584a9d784c6e228df952862f9/comments", "author": null, "committer": null, "parents": [{"sha": "1ad435a5d548be5b04ae22d68afa3d2584c4703b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ad435a5d548be5b04ae22d68afa3d2584c4703b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ad435a5d548be5b04ae22d68afa3d2584c4703b"}], "stats": {"total": 292, "additions": 240, "deletions": 52}, "files": [{"sha": "b94841e9e9a7707ad7abc7eddccbc05e4baa089f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7a6176efe2cec2584a9d784c6e228df952862f9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7a6176efe2cec2584a9d784c6e228df952862f9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d7a6176efe2cec2584a9d784c6e228df952862f9", "patch": "@@ -1,3 +1,31 @@\n+2005-05-16  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* gcc.dg/compat/generate-random.c (config.h): Do not include.\n+\t(limits.h): Include unconditionally.\n+\t(stdlib.h): Likewise.\n+\t* gcc.dg/compat/generate-random_r.c (config.h): Do not include.\n+\t(limits.h): Include unconditionally.\n+\t(stdlib.h): Likewise.\n+\t* gcc.dg/compat/struct-layout-1.exp: Do not link with libiberty.\n+\t* gcc.dg/compat/struct-layout-1_generate.c (config.h): Do not include.\n+\t(limits.h): Include unconditionally.\n+\t(stdlib.h): Likewise. \n+\t(hashtab.h): Do not include.\n+\t(getopt.h): Likewise.\n+\t(stddef.h): Include.\n+\t(hashval_t): Define.\n+\t(struct entry): Add \"next\" field.\n+\t(HASH_SIZE): New macro.\n+\t(hash_table): New variable.\n+\t(switchfiles): Do not use xmalloc.\n+\t(mix): New macro.\n+\t(iterative_hash): New function.\n+\t(hasht): Remove.\n+\t(e_exists): New function.\n+\t(e_insert): Likewise.\n+\t(output): Use, instead of libiberty hashtable functions.\n+\t(main): Do not use getopt.  Do not call htab_create.\n+\t\n 2005-05-16  David Billinghurst <David.Billinghurst@riotinto.com>\n \n \tPR libstdc++/21526"}, {"sha": "175924012f251767b1a8e08751beaa219b4ff0e7", "filename": "gcc/testsuite/gcc.dg/compat/generate-random.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7a6176efe2cec2584a9d784c6e228df952862f9/gcc%2Ftestsuite%2Fgcc.dg%2Fcompat%2Fgenerate-random.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7a6176efe2cec2584a9d784c6e228df952862f9/gcc%2Ftestsuite%2Fgcc.dg%2Fcompat%2Fgenerate-random.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcompat%2Fgenerate-random.c?ref=d7a6176efe2cec2584a9d784c6e228df952862f9", "patch": "@@ -51,14 +51,9 @@\n    OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.*/\n \n-#include \"config.h\"\n-#ifdef HAVE_LIMITS_H\n #include <limits.h>\n-#endif\n #include \"libiberty.h\"\n-#ifdef HAVE_STDLIB_H\n #include <stdlib.h>\n-#endif\n #include \"generate-random.h\"\n \n "}, {"sha": "83d3c9f15e670e1dff45220534adc1797942bc6d", "filename": "gcc/testsuite/gcc.dg/compat/generate-random_r.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7a6176efe2cec2584a9d784c6e228df952862f9/gcc%2Ftestsuite%2Fgcc.dg%2Fcompat%2Fgenerate-random_r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7a6176efe2cec2584a9d784c6e228df952862f9/gcc%2Ftestsuite%2Fgcc.dg%2Fcompat%2Fgenerate-random_r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcompat%2Fgenerate-random_r.c?ref=d7a6176efe2cec2584a9d784c6e228df952862f9", "patch": "@@ -52,14 +52,9 @@\n  * Rewritten to be reentrant by Ulrich Drepper, 1995\n  */\n \n-#include \"config.h\"\n-#ifdef HAVE_LIMITS_H\n #include <limits.h>\n-#endif\n #include \"libiberty.h\"\n-#ifdef HAVE_STDLIB_H\n #include <stdlib.h>\n-#endif\n #include \"generate-random.h\"\n \n "}, {"sha": "5b3d300381295ae474879dac30025642c02da061", "filename": "gcc/testsuite/gcc.dg/compat/struct-layout-1.exp", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7a6176efe2cec2584a9d784c6e228df952862f9/gcc%2Ftestsuite%2Fgcc.dg%2Fcompat%2Fstruct-layout-1.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7a6176efe2cec2584a9d784c6e228df952862f9/gcc%2Ftestsuite%2Fgcc.dg%2Fcompat%2Fstruct-layout-1.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcompat%2Fstruct-layout-1.exp?ref=d7a6176efe2cec2584a9d784c6e228df952862f9", "patch": "@@ -102,10 +102,7 @@ set generator \"$tmpdir/gcc.dg-struct-layout-1_generate\"\n set generator_src \"$srcdir/$subdir/struct-layout-1_generate.c\"\n set generator_src \"$generator_src $srcdir/$subdir/generate-random.c\"\n set generator_src \"$generator_src $srcdir/$subdir/generate-random_r.c\"\n-set generator_inc \"-I$srcdir/$subdir -I$srcdir/../../include\"\n-set generator_inc \"$generator_inc -I$rootme/../libiberty\"\n-set generator_lib \"-L$rootme/../libiberty -liberty\"\n-set generator_cmd \"-o $generator $generator_src $generator_inc $generator_lib\"\n+set generator_cmd \"-o $generator $generator_src\"\n \n set status [remote_exec host \"$HOSTCC $HOSTCFLAGS $generator_cmd\"]\n set status [lindex $status 0]"}, {"sha": "6c627f0de588e36fe8e2959910dd6a14c0cdf288", "filename": "gcc/testsuite/gcc.dg/compat/struct-layout-1_generate.c", "status": "modified", "additions": 211, "deletions": 38, "changes": 249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7a6176efe2cec2584a9d784c6e228df952862f9/gcc%2Ftestsuite%2Fgcc.dg%2Fcompat%2Fstruct-layout-1_generate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7a6176efe2cec2584a9d784c6e228df952862f9/gcc%2Ftestsuite%2Fgcc.dg%2Fcompat%2Fstruct-layout-1_generate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcompat%2Fstruct-layout-1_generate.c?ref=d7a6176efe2cec2584a9d784c6e228df952862f9", "patch": "@@ -19,23 +19,15 @@ along with GCC; see the file COPYING.  If not, write to the Free\n Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n 02111-1307, USA.  */\n \n-/* Compile with gcc -I$(srcdir)/../include -{I,L}$(objdir)/../libiberty/ \\\n-   -o struct-layout-1_generate{,.c} generate_random{,_r}.c -liberty */\n+/* Compile with gcc -o struct-layout-1_generate{,.c} generate_random{,_r}.c */\n \n-#include \"config.h\"\n-#ifdef HAVE_LIMITS_H\n+/* N.B. -- This program cannot use libiberty as that will not work\n+   when testing an installed compiler.  */\n #include <limits.h>\n-#endif\n-#include \"libiberty.h\"\n #include <stdio.h>\n-#ifdef HAVE_STDLIB_H\n #include <stdlib.h>\n-#endif\n-#ifdef HAVE_STRING_H\n #include <string.h>\n-#endif\n-#include \"hashtab.h\"\n-#include \"getopt.h\"\n+#include <stddef.h>\n /* We use our own pseudo-random number generator, so that it gives the same\n    values on all hosts.  */\n #include \"generate-random.h\"\n@@ -44,6 +36,8 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n # error Need 64-bit long long\n #endif\n \n+typedef unsigned int hashval_t;\n+\n enum TYPE\n {\n   TYPE_INT,\n@@ -654,8 +648,14 @@ struct entry\n   unsigned char arr_len;\n   struct types *type;\n   const char *attrib;\n+  /* Used to chain together entries in the hash table.  */\n+  struct entry *next;\n };\n \n+/* A prime number giving the number of slots in the hash table.  */ \n+#define HASH_SIZE 32749 \n+static struct entry *hash_table[HASH_SIZE];\n+\n static int idx, limidx, output_one;\n static const char *destdir;\n static const char *srcdir;\n@@ -677,7 +677,9 @@ switchfiles (int fields)\n   if (destbuf == NULL)\n     {\n       size_t len = strlen (destdir);\n-      destbuf = xmalloc (len + 20);\n+      destbuf = malloc (len + 20);\n+      if (!destbuf)\n+\tabort ();\n       memcpy (destbuf, destdir, len);\n       if (!len || destbuf[len - 1] != '/')\n \tdestbuf[len++] = '/';\n@@ -1131,6 +1133,145 @@ subvalues (struct entry *e, char *p, char *letter)\n     }\n }\n \n+/* DERIVED FROM:\n+--------------------------------------------------------------------\n+lookup2.c, by Bob Jenkins, December 1996, Public Domain.\n+hash(), hash2(), hash3, and mix() are externally useful functions.\n+Routines to test the hash are included if SELF_TEST is defined.\n+You can use this free for any purpose.  It has no warranty.\n+--------------------------------------------------------------------\n+*/\n+\n+/*\n+--------------------------------------------------------------------\n+mix -- mix 3 32-bit values reversibly.\n+For every delta with one or two bit set, and the deltas of all three\n+  high bits or all three low bits, whether the original value of a,b,c\n+  is almost all zero or is uniformly distributed,\n+* If mix() is run forward or backward, at least 32 bits in a,b,c\n+  have at least 1/4 probability of changing.\n+* If mix() is run forward, every bit of c will change between 1/3 and\n+  2/3 of the time.  (Well, 22/100 and 78/100 for some 2-bit deltas.)\n+mix() was built out of 36 single-cycle latency instructions in a \n+  structure that could supported 2x parallelism, like so:\n+      a -= b; \n+      a -= c; x = (c>>13);\n+      b -= c; a ^= x;\n+      b -= a; x = (a<<8);\n+      c -= a; b ^= x;\n+      c -= b; x = (b>>13);\n+      ...\n+  Unfortunately, superscalar Pentiums and Sparcs can't take advantage \n+  of that parallelism.  They've also turned some of those single-cycle\n+  latency instructions into multi-cycle latency instructions.  Still,\n+  this is the fastest good hash I could find.  There were about 2^^68\n+  to choose from.  I only looked at a billion or so.\n+--------------------------------------------------------------------\n+*/\n+/* same, but slower, works on systems that might have 8 byte hashval_t's */\n+#define mix(a,b,c) \\\n+{ \\\n+  a -= b; a -= c; a ^= (c>>13); \\\n+  b -= c; b -= a; b ^= (a<< 8); \\\n+  c -= a; c -= b; c ^= ((b&0xffffffff)>>13); \\\n+  a -= b; a -= c; a ^= ((c&0xffffffff)>>12); \\\n+  b -= c; b -= a; b = (b ^ (a<<16)) & 0xffffffff; \\\n+  c -= a; c -= b; c = (c ^ (b>> 5)) & 0xffffffff; \\\n+  a -= b; a -= c; a = (a ^ (c>> 3)) & 0xffffffff; \\\n+  b -= c; b -= a; b = (b ^ (a<<10)) & 0xffffffff; \\\n+  c -= a; c -= b; c = (c ^ (b>>15)) & 0xffffffff; \\\n+}\n+\n+/*\n+--------------------------------------------------------------------\n+hash() -- hash a variable-length key into a 32-bit value\n+  k     : the key (the unaligned variable-length array of bytes)\n+  len   : the length of the key, counting by bytes\n+  level : can be any 4-byte value\n+Returns a 32-bit value.  Every bit of the key affects every bit of\n+the return value.  Every 1-bit and 2-bit delta achieves avalanche.\n+About 36+6len instructions.\n+\n+The best hash table sizes are powers of 2.  There is no need to do\n+mod a prime (mod is sooo slow!).  If you need less than 32 bits,\n+use a bitmask.  For example, if you need only 10 bits, do\n+  h = (h & hashmask(10));\n+In which case, the hash table should have hashsize(10) elements.\n+\n+If you are hashing n strings (ub1 **)k, do it like this:\n+  for (i=0, h=0; i<n; ++i) h = hash( k[i], len[i], h);\n+\n+By Bob Jenkins, 1996.  bob_jenkins@burtleburtle.net.  You may use this\n+code any way you wish, private, educational, or commercial.  It's free.\n+\n+See http://burtleburtle.net/bob/hash/evahash.html\n+Use for hash table lookup, or anything where one collision in 2^32 is\n+acceptable.  Do NOT use for cryptographic purposes.\n+--------------------------------------------------------------------\n+*/\n+\n+static hashval_t\n+iterative_hash (const void *k_in /* the key */,\n+                register size_t  length /* the length of the key */,\n+                register hashval_t initval /* the previous hash, or\n+                                              an arbitrary value */)\n+{\n+  register const unsigned char *k = (const unsigned char *)k_in;\n+  register hashval_t a,b,c,len;\n+\n+  /* Set up the internal state */\n+  len = length;\n+  a = b = 0x9e3779b9;  /* the golden ratio; an arbitrary value */\n+  c = initval;           /* the previous hash value */\n+\n+  /*---------------------------------------- handle most of the key */\n+#ifndef WORDS_BIGENDIAN\n+  /* On a little-endian machine, if the data is 4-byte aligned we can hash\n+     by word for better speed.  This gives nondeterministic results on\n+     big-endian machines.  */\n+  if (sizeof (hashval_t) == 4 && (((size_t)k)&3) == 0)\n+    while (len >= 12)    /* aligned */\n+      {\n+\ta += *(hashval_t *)(k+0);\n+\tb += *(hashval_t *)(k+4);\n+\tc += *(hashval_t *)(k+8);\n+\tmix(a,b,c);\n+\tk += 12; len -= 12;\n+      }\n+  else /* unaligned */\n+#endif\n+    while (len >= 12)\n+      {\n+\ta += (k[0] +((hashval_t)k[1]<<8) +((hashval_t)k[2]<<16) +((hashval_t)k[3]<<24));\n+\tb += (k[4] +((hashval_t)k[5]<<8) +((hashval_t)k[6]<<16) +((hashval_t)k[7]<<24));\n+\tc += (k[8] +((hashval_t)k[9]<<8) +((hashval_t)k[10]<<16)+((hashval_t)k[11]<<24));\n+\tmix(a,b,c);\n+\tk += 12; len -= 12;\n+      }\n+\n+  /*------------------------------------- handle the last 11 bytes */\n+  c += length;\n+  switch(len)              /* all the case statements fall through */\n+    {\n+    case 11: c+=((hashval_t)k[10]<<24);\n+    case 10: c+=((hashval_t)k[9]<<16);\n+    case 9 : c+=((hashval_t)k[8]<<8);\n+      /* the first byte of c is reserved for the length */\n+    case 8 : b+=((hashval_t)k[7]<<24);\n+    case 7 : b+=((hashval_t)k[6]<<16);\n+    case 6 : b+=((hashval_t)k[5]<<8);\n+    case 5 : b+=k[4];\n+    case 4 : a+=((hashval_t)k[3]<<24);\n+    case 3 : a+=((hashval_t)k[2]<<16);\n+    case 2 : a+=((hashval_t)k[1]<<8);\n+    case 1 : a+=k[0];\n+      /* case 0: nothing left to add */\n+    }\n+  mix(a,b,c);\n+  /*-------------------------------------------- report the result */\n+  return c;\n+}\n+\n hashval_t\n e_hash (const void *a)\n {\n@@ -1176,25 +1317,46 @@ e_eq (const void *a, const void *b)\n   return 1;\n }\n \n-htab_t hasht;\n+static int \n+e_exists (const struct entry *e) \n+{\n+  struct entry *h;\n+  hashval_t hval;\n+\n+  hval = e_hash (e);\n+  for (h = hash_table[hval % HASH_SIZE]; h; h = h->next)\n+    if (e_eq (e, h))\n+      return 1;\n+  return 0;\n+}\n+\n+static void\n+e_insert (struct entry *e)\n+{\n+  hashval_t hval;\n+\n+  hval = e_hash (e);\n+  e->next = hash_table[hval % HASH_SIZE];\n+  hash_table[hval % HASH_SIZE] = e;\n+}\n \n void\n output (struct entry *e)\n {\n   int i;\n   char c;\n-  void **p;\n+  struct entry *n;\n   const char *skip_cint = \"\";\n \n   if (e[0].etype != ETYPE_STRUCT && e[0].etype != ETYPE_UNION)\n     abort ();\n \n-  p = htab_find_slot (hasht, e, INSERT);\n-  if (*p != NULL)\n+  if (e_exists (e))\n     return;\n \n-  *p = malloc ((e[0].len + 1) * sizeof (struct entry));\n-  memcpy (*p, e, (e[0].len + 1) * sizeof (struct entry));\n+  n = (struct entry *) malloc ((e[0].len + 1) * sizeof (struct entry));\n+  memcpy (n, e, (e[0].len + 1) * sizeof (struct entry));\n+  e_insert (n);\n \n   if (idx == limidx)\n     switchfiles (e[0].len);\n@@ -1645,29 +1807,41 @@ int\n main (int argc, char **argv)\n {\n   int i, j, count, c, n = 3000;\n+  char *optarg;\n \n   if (sizeof (int) != 4 || sizeof (long long) != 8)\n     return 1;\n-\n-  while ((c = getopt (argc, argv, \"d:i:n:s:\")) != -1)\n-    switch (c)\n-      {\n-      case 'n':\n-\tn = atoi (optarg);\n-\tbreak;\n-      case 'd':\n-\tdestdir = optarg;\n-\tbreak;\n-      case 's':\n-\tsrcdir = optarg;\n-\tbreak;\n-      case 'i':\n-\toutput_one = 1;\n-\tlimidx = atoi (optarg);\n-\tbreak;\n-      default:\n+  \n+  i = 1;\n+  while (i < argc) \n+    {\n+      c = '\\0';\n+      if (argv[i][0] == '-' && argv[i][2] == '\\0')\n+\tc = argv[i][1];\n+      optarg = argv[i + 1];\n+      if (!optarg)\n \tgoto usage;\n+      switch (c)\n+\t{\n+\tcase 'n':\n+\t  n = atoi (optarg);\n+\t  break;\n+\tcase 'd':\n+\t  destdir = optarg;\n+\t  break;\n+\tcase 's':\n+\t  srcdir = optarg;\n+\t  break;\n+\tcase 'i':\n+\t  output_one = 1;\n+\t  limidx = atoi (optarg);\n+\t  break;\n+\tdefault:\n+\t  fprintf (stderr, \"unrecognized option %s\\n\", argv[i]);\n+\t  goto usage;\n       }\n+      i += 2;\n+    }\n \n   if (output_one)\n     {\n@@ -1692,7 +1866,6 @@ Either -s srcdir -d destdir or -i idx must be used\\n\", argv[0]);\n   if (srcdir == NULL && !output_one)\n     goto usage;\n \n-  hasht = htab_create (40000, e_hash, e_eq, NULL);\n   for (i = 0; i < NTYPES2; ++i)\n     if (base_types[i].bitfld)\n       bitfld_types[n_bitfld_types++] = base_types[i];"}]}