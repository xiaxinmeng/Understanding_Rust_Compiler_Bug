{"sha": "2f7007a777bbb3d2fbd29f66b98d71ba6849eab6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmY3MDA3YTc3N2JiYjNkMmZiZDI5ZjY2Yjk4ZDcxYmE2ODQ5ZWFiNg==", "commit": {"author": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2020-09-12T06:47:58Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2020-11-28T21:13:21Z"}, "message": "Attempt to fix the ExprWithoutBlock in ExprStmtWithoutBlock issue\nFirst step toward consolidation of similar parsing functions (ComparisonExpr in this case)\nDebug output for apparent parsing failure\nAttempt to fix problem with non-digit character after 0 being mistaken as\nnon-decimal int literal\nAttempt to fix incorrect tokenisation of a dot then a decimal\nTry new implementation of token splitting rather than token replacing", "tree": {"sha": "24600d3b090ae5b606f3b69688fa2fb32a351351", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/24600d3b090ae5b606f3b69688fa2fb32a351351"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f7007a777bbb3d2fbd29f66b98d71ba6849eab6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f7007a777bbb3d2fbd29f66b98d71ba6849eab6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f7007a777bbb3d2fbd29f66b98d71ba6849eab6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f7007a777bbb3d2fbd29f66b98d71ba6849eab6/comments", "author": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e0db6e13f05fb197621eca65d275094f2502473f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0db6e13f05fb197621eca65d275094f2502473f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0db6e13f05fb197621eca65d275094f2502473f"}], "stats": {"total": 317, "additions": 191, "deletions": 126}, "files": [{"sha": "ce7a37a24f2ffc3efc447dacab858966103d0f26", "filename": "gcc/rust/ast/rust-stmt.h", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f7007a777bbb3d2fbd29f66b98d71ba6849eab6/gcc%2Frust%2Fast%2Frust-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f7007a777bbb3d2fbd29f66b98d71ba6849eab6/gcc%2Frust%2Fast%2Frust-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-stmt.h?ref=2f7007a777bbb3d2fbd29f66b98d71ba6849eab6", "patch": "@@ -120,31 +120,36 @@ class ExprStmt : public Stmt\n class ExprStmtWithoutBlock : public ExprStmt\n {\n public:\n-  // ExprWithoutBlock* expr;\n+  // TODO: ensure that this works\n+  std::unique_ptr<ExprWithoutBlock> expr;\n   /* HACK: cannot ensure type safety of ExprWithoutBlock due to Pratt parsing,\n    * so have to store more general type of Expr. FIXME: fix this issue somehow\n    * or redesign AST. */\n-  // std::unique_ptr<ExprWithoutBlock> expr;\n-  std::unique_ptr<Expr> expr;\n+  // std::unique_ptr<Expr> expr;\n \n   std::string as_string () const override;\n \n-  // ExprStmtWithoutBlock(std::unique_ptr<ExprWithoutBlock> expr) :\n-  // expr(std::move(expr)) {}\n-  ExprStmtWithoutBlock (std::unique_ptr<Expr> expr, Location locus)\n+  ExprStmtWithoutBlock (std::unique_ptr<ExprWithoutBlock> expr, Location locus)\n     : ExprStmt (locus), expr (std::move (expr))\n   {}\n+  /*ExprStmtWithoutBlock (std::unique_ptr<Expr> expr, Location locus)\n+    : ExprStmt (locus), expr (std::move (expr))\n+  {}*/\n \n   // Copy constructor with clone\n   ExprStmtWithoutBlock (ExprStmtWithoutBlock const &other)\n-    : ExprStmt (other), expr (other.expr->clone_expr /*_without_block*/ ())\n+    : ExprStmt (other), expr (other.expr->clone_expr_without_block ())\n   {}\n+  /*ExprStmtWithoutBlock (ExprStmtWithoutBlock const &other)\n+    : ExprStmt (other), expr (other.expr->clone_expr ())\n+  {}*/\n \n   // Overloaded assignment operator to clone\n   ExprStmtWithoutBlock &operator= (ExprStmtWithoutBlock const &other)\n   {\n     ExprStmt::operator= (other);\n-    expr = other.expr->clone_expr /*_without_block*/ ();\n+    expr = other.expr->clone_expr_without_block ();\n+    //expr = other.expr->clone_expr ();\n \n     return *this;\n   }"}, {"sha": "019e9220641c5a7151b4c518bbdfb2faa20d0831", "filename": "gcc/rust/lex/rust-lex.cc", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f7007a777bbb3d2fbd29f66b98d71ba6849eab6/gcc%2Frust%2Flex%2Frust-lex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f7007a777bbb3d2fbd29f66b98d71ba6849eab6/gcc%2Frust%2Flex%2Frust-lex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flex%2Frust-lex.cc?ref=2f7007a777bbb3d2fbd29f66b98d71ba6849eab6", "patch": "@@ -95,6 +95,12 @@ is_whitespace (char character)\n   return ISSPACE (character);\n }\n \n+bool\n+is_non_decimal_int_literal_separator (char character)\n+{\n+  return character == 'x' || character == 'o' || character == 'b';\n+}\n+\n // this compiles fine, so any intellisense saying otherwise is fake news\n Lexer::Lexer (const char *filename, RAIIFile file_input, Linemap *linemap)\n   : input (std::move (file_input)), current_line (1), current_column (1),\n@@ -674,10 +680,11 @@ Lexer::build_token ()\n \t\t  return Token::make (DOT_DOT, loc);\n \t\t}\n \t    }\n-\t  else if (!ISDIGIT (peek_input ()))\n+\t  else /*if (!ISDIGIT (peek_input ()))*/\n \t    {\n \t      // single dot .\n-\t      // Only if followed by a non-number - otherwise is float\n+\t      // Only if followed by a non-number - otherwise is float \n+        // nope, float cannot start with '.'. \n \t      current_column++;\n \t      return Token::make (DOT, loc);\n \t    }\n@@ -721,9 +728,9 @@ Lexer::build_token ()\n \treturn parse_identifier_or_keyword (loc);\n \n       // int and float literals\n-      if (ISDIGIT (current_char) || current_char == '.')\n+      if (ISDIGIT (current_char))\n \t{ //  _ not allowed as first char\n-\t  if (current_char == '0' && !ISDIGIT (peek_input ()))\n+\t  if (current_char == '0' && is_non_decimal_int_literal_separator (peek_input ()))\n \t    {\n \t      // handle binary, octal, hex literals\n \t      TokenPtr non_dec_int_lit_ptr\n@@ -752,6 +759,14 @@ Lexer::build_token ()\n \t    return char_or_lifetime_ptr;\n \t}\n \n+      // DEBUG: check for specific character problems:\n+      if (current_char == '0')\n+        fprintf(stderr, \"'0' uncaught before unexpected character\\n\");\n+      else if (current_char == ']')\n+        fprintf(stderr, \"']' uncaught before unexpected character\\n\");\n+      else if (current_char == 0x5d)\n+        fprintf(stderr, \"whatever 0x5d is (not '0' or ']') uncaught before unexpected character\\n\");\n+\n       // didn't match anything so error\n       rust_error_at (loc, \"unexpected character '%x'\", current_char);\n       current_column++;"}, {"sha": "6a9b45a5a3284e356bf14c22e5b798325ae03863", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 115, "deletions": 74, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f7007a777bbb3d2fbd29f66b98d71ba6849eab6/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f7007a777bbb3d2fbd29f66b98d71ba6849eab6/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=2f7007a777bbb3d2fbd29f66b98d71ba6849eab6", "patch": "@@ -191,48 +191,50 @@ Parser<ManagedTokenSource>::skip_generics_right_angle ()\n       lexer.skip_token ();\n       return true;\n       case RIGHT_SHIFT: {\n+#if 0\n \t/* shit. preferred HACK would be to replace this token in stream with\n \t * '>', but may not be possible at this point. */\n \t// FIXME: ensure locations aren't messed up\n \tTokenPtr right_angle = Token::make (RIGHT_ANGLE, tok->get_locus () + 1);\n \tlexer.replace_current_token (right_angle);\n+#endif\n \n \t// new implementation that should be better\n-#if 0\n   lexer.split_current_token (RIGHT_ANGLE, RIGHT_ANGLE);\n   lexer.skip_token ();\n-#endif\n \treturn true;\n       }\n       case GREATER_OR_EQUAL: {\n+#if 0\n \t// another HACK - replace with equal (as assignment intended, probably)\n \t/* FIXME: is this even required? how many people wouldn't leave a space?\n \t * - apparently rustc has this feature */\n \t// FIXME: ensure locations aren't messed up\n \tTokenPtr equal = Token::make (EQUAL, tok->get_locus () + 1);\n \tlexer.replace_current_token (equal);\n \treturn true;\n+#endif\n \n \t// new implementation that should be better\n-#if 0\n   lexer.split_current_token (RIGHT_ANGLE, EQUAL);\n   lexer.skip_token ();\n-#endif\n+  return true;\n       }\n       case RIGHT_SHIFT_EQ: {\n+#if 0\n \t// another HACK - replace with greater or equal\n \t// FIXME: again, is this really required? rustc has the feature, though\n \t// FIXME: ensure locations aren't messed up\n \tTokenPtr greater_equal\n \t  = Token::make (GREATER_OR_EQUAL, tok->get_locus () + 1);\n \tlexer.replace_current_token (greater_equal);\n \treturn true;\n+#endif\n \n \t// new implementation that should be better\n-#if 0\n   lexer.split_current_token (RIGHT_ANGLE, GREATER_OR_EQUAL);\n   lexer.skip_token ();\n-#endif\n+  return true;\n       }\n     default:\n       rust_error_at (tok->get_locus (),\n@@ -255,8 +257,8 @@ Parser<ManagedTokenSource>::left_binding_power (const_TokenPtr token)\n   switch (token->get_id ())\n     {\n       /* TODO: issue here - distinguish between method calls and field access\n-\t   * somehow? Also would have to distinguish between paths and function\n-\t   * calls (:: operator), maybe more stuff. */\n+       * somehow? Also would have to distinguish between paths and function\n+       * calls (:: operator), maybe more stuff. */\n       /* Current plan for tackling LBP - don't do it based on token, use\n        * lookahead. Or alternatively, only use Pratt parsing for OperatorExpr\n        * and handle other expressions without it. rustc only considers\n@@ -6461,16 +6463,7 @@ Parser<ManagedTokenSource>::parse_expr_stmt_without_block (\n   /* TODO: maybe move more logic for expr without block in here for better error\n    * handling */\n \n-  // try to parse expr without block\n-  /*AST::ExprWithoutBlock* expr = nullptr;\n-  expr = parse_expr_without_block(std::move(outer_attrs));*/\n-  // HACK: parse expression instead of expression without block, due to Pratt\n-  // parsing issues\n-  /*std::unique_ptr<AST::Expr> expr = nullptr;\n-  Location locus = lexer.peek_token ()->get_locus ();\n-  expr = parse_expr (std::move (outer_attrs));*/\n-\n-  // attempt to parse via parse_expr_without_block\n+  // attempt to parse via parse_expr_without_block - seems to work\n   std::unique_ptr<AST::ExprWithoutBlock> expr = nullptr;\n   Location locus = lexer.peek_token ()->get_locus ();\n   expr = parse_expr_without_block (std::move (outer_attrs));\n@@ -10800,9 +10793,9 @@ Parser<ManagedTokenSource>::parse_path_based_stmt_or_expr (\n   switch (t2->get_id ())\n     {\n       case EXCLAM: {\n-\t// macro invocation or macro invocation semi - depends on whether there\n-\t// is a final ';' convert path in expr to simple path (as that is used\n-\t// in macros)\n+\t/* macro invocation or macro invocation semi - depends on whether there\n+\t * is a final ';' */\n+\t// convert path in expr to simple path (as that is used in macros)\n \tAST::SimplePath macro_path = path.as_simple_path ();\n \tif (macro_path.is_empty ())\n \t  {\n@@ -10854,8 +10847,7 @@ Parser<ManagedTokenSource>::parse_path_based_stmt_or_expr (\n \t\trust_error_at (\n \t\t  t3->get_locus (),\n \t\t  \"failed to parse token tree for macro invocation (or semi) - \"\n-\t\t  \"found \"\n-\t\t  \"'%s'\",\n+\t\t  \"found '%s'\",\n \t\t  t3->get_token_description ());\n \t\treturn ExprOrStmt::create_error ();\n \t      }\n@@ -10967,8 +10959,8 @@ Parser<ManagedTokenSource>::parse_path_based_stmt_or_expr (\n \treturn ExprOrStmt (std::move (expr));\n       }\n       case LEFT_PAREN: {\n-\t// assume struct expr tuple (as struct-enum disambiguation requires name\n-\t// lookup) again, make statement if final ';'\n+\t/* assume struct expr tuple (as struct-enum disambiguation requires name\n+\t * lookup) again, make statement if final ';' */\n \tstd::unique_ptr<AST::CallExpr> struct_expr\n \t  = parse_struct_expr_tuple_partial (std::move (path),\n \t\t\t\t\t     std::move (outer_attrs));\n@@ -11022,9 +11014,6 @@ template <typename ManagedTokenSource>\n std::unique_ptr<AST::StructExprField>\n Parser<ManagedTokenSource>::parse_struct_expr_field ()\n {\n-  // DEBUG:\n-  fprintf (stderr, \"beginning struct/enum expr field parsing \\n\");\n-\n   const_TokenPtr t = lexer.peek_token ();\n   switch (t->get_id ())\n     {\n@@ -11045,11 +11034,6 @@ Parser<ManagedTokenSource>::parse_struct_expr_field ()\n \t      return nullptr;\n \t    }\n \n-\t  // DEBUG:\n-\t  fprintf (\n-\t    stderr,\n-\t    \"struct/enum expr field parsing field identifier value done \\n\");\n-\n \t  return std::unique_ptr<AST::StructExprFieldIdentifierValue> (\n \t    new AST::StructExprFieldIdentifierValue (std::move (ident),\n \t\t\t\t\t\t     std::move (expr)));\n@@ -11060,10 +11044,6 @@ Parser<ManagedTokenSource>::parse_struct_expr_field ()\n \t  Identifier ident = t->get_str ();\n \t  lexer.skip_token ();\n \n-\t  // DEBUG:\n-\t  fprintf (stderr,\n-\t\t   \"struct/enum expr field parsing field identifier done \\n\");\n-\n \t  return std::unique_ptr<AST::StructExprFieldIdentifier> (\n \t    new AST::StructExprFieldIdentifier (std::move (ident)));\n \t}\n@@ -11088,30 +11068,18 @@ Parser<ManagedTokenSource>::parse_struct_expr_field ()\n \t    return nullptr;\n \t  }\n \n-\t// DEBUG:\n-\tfprintf (stderr,\n-\t\t \"struct/enum expr field parsing field index value done \\n\");\n-\n \treturn std::unique_ptr<AST::StructExprFieldIndexValue> (\n \t  new AST::StructExprFieldIndexValue (index, std::move (expr)));\n       }\n     case DOT_DOT:\n-      // this is a struct base and can't be parsed here, so just return nothing\n-      // without erroring\n-\n-      // DEBUG:\n-      fprintf (stderr, \"struct/enum expr field parsing failed - '..' \\n\");\n+      /* this is a struct base and can't be parsed here, so just return nothing\n+       * without erroring */\n \n       return nullptr;\n     default:\n-      // DEBUG:\n-      fprintf (stderr,\n-\t       \"struct/enum expr field parsing failed - unrecognised char \\n\");\n-\n       rust_error_at (t->get_locus (),\n \t\t     \"unrecognised token '%s' as first token of struct expr \"\n-\t\t     \"field - expected identifier \"\n-\t\t     \"or int literal\",\n+\t\t     \"field - expected identifier or int literal\",\n \t\t     t->get_token_description ());\n       return nullptr;\n     }\n@@ -11194,9 +11162,8 @@ Parser<ManagedTokenSource>::parse_macro_invocation_maybe_semi (\n       /* with curly bracketed macros, assume it is a macro invocation unless\n        * a semicolon is explicitly put at the end. this is not necessarily\n        * true (i.e. context-dependence) and so may have to be fixed up via\n-       * HACKs in semantic\n-       * analysis (by checking whether it is the last elem in the vector).\n-       */\n+       * HACKs in semantic analysis (by checking whether it is the last elem in\n+       * the vector). */\n \n       if (lexer.peek_token ()->get_id () == SEMICOLON)\n \t{\n@@ -11399,8 +11366,7 @@ Parser<ManagedTokenSource>::parse_expr (int right_binding_power,\n \n   // parse null denotation (unary part of expression)\n   std::unique_ptr<AST::Expr> expr\n-    = null_denotation (current_token, std::move (outer_attrs),\n-\t\t\t   restrictions);\n+    = null_denotation (current_token, std::move (outer_attrs), restrictions);\n \n   if (expr == nullptr)\n     {\n@@ -11720,7 +11686,8 @@ Parser<ManagedTokenSource>::null_denotation (\n \n \t// HACK: as struct expressions should always be value expressions,\n \t// cannot be referenced\n-\tParseRestrictions entered_from_unary = { .can_be_struct_expr = false, .entered_from_unary = true };\n+\tParseRestrictions entered_from_unary\n+\t  = {.can_be_struct_expr = false, .entered_from_unary = true};\n \t/*entered_from_unary.entered_from_unary = true;\n \tentered_from_unary.can_be_struct_expr = false;*/\n \n@@ -11786,8 +11753,8 @@ Parser<ManagedTokenSource>::null_denotation (\n \tfprintf (stderr, \"beginning null denotation \"\n \t\t\t \"self/self-alias/dollar/crate/super handling\\n\");\n \n-\t// best option: parse as path, then extract identifier, macro,\n-\t// struct/enum, or just path info from it\n+\t/* best option: parse as path, then extract identifier, macro,\n+\t * struct/enum, or just path info from it */\n \tAST::PathInExpression path = parse_path_in_expression_pratt (tok);\n \n \t// DEBUG\n@@ -11956,33 +11923,55 @@ Parser<ManagedTokenSource>::left_denotation (\n \t\t\t\t     std::move (outer_attrs), restrictions);\n     case EQUAL_EQUAL:\n       // equal to expression - binary infix (no associativity)\n-      return parse_binary_equal_expr (tok, std::move (left),\n-\t\t\t\t      std::move (outer_attrs), restrictions);\n+      /*return parse_binary_equal_expr (tok, std::move (left),\n+\t\t\t\t      std::move (outer_attrs), restrictions);*/\n+      return parse_comparison_expr (tok, std::move (left),\n+\t\t\t\t    std::move (outer_attrs),\n+\t\t\t\t    AST::ComparisonExpr::ExprType::EQUAL,\n+\t\t\t\t    restrictions);\n     case NOT_EQUAL:\n       // not equal to expression - binary infix (no associativity)\n-      return parse_binary_not_equal_expr (tok, std::move (left),\n+      /*return parse_binary_not_equal_expr (tok, std::move (left),\n \t\t\t\t\t  std::move (outer_attrs),\n-\t\t\t\t\t  restrictions);\n+\t\t\t\t\t  restrictions);*/\n+      return parse_comparison_expr (tok, std::move (left),\n+\t\t\t\t    std::move (outer_attrs),\n+\t\t\t\t    AST::ComparisonExpr::ExprType::NOT_EQUAL,\n+\t\t\t\t    restrictions);\n     case RIGHT_ANGLE:\n       // greater than expression - binary infix (no associativity)\n-      return parse_binary_greater_than_expr (tok, std::move (left),\n+      /*return parse_binary_greater_than_expr (tok, std::move (left),\n \t\t\t\t\t     std::move (outer_attrs),\n-\t\t\t\t\t     restrictions);\n+\t\t\t\t\t     restrictions);*/\n+      return parse_comparison_expr (tok, std::move (left),\n+\t\t\t\t    std::move (outer_attrs),\n+\t\t\t\t    AST::ComparisonExpr::ExprType::GREATER_THAN,\n+\t\t\t\t    restrictions);\n     case LEFT_ANGLE:\n       // less than expression - binary infix (no associativity)\n-      return parse_binary_less_than_expr (tok, std::move (left),\n+      /*return parse_binary_less_than_expr (tok, std::move (left),\n \t\t\t\t\t  std::move (outer_attrs),\n-\t\t\t\t\t  restrictions);\n+\t\t\t\t\t  restrictions);*/\n+      return parse_comparison_expr (tok, std::move (left),\n+\t\t\t\t    std::move (outer_attrs),\n+\t\t\t\t    AST::ComparisonExpr::ExprType::LESS_THAN,\n+\t\t\t\t    restrictions);\n     case GREATER_OR_EQUAL:\n       // greater than or equal to expression - binary infix (no associativity)\n-      return parse_binary_greater_equal_expr (tok, std::move (left),\n+      /*return parse_binary_greater_equal_expr (tok, std::move (left),\n \t\t\t\t\t      std::move (outer_attrs),\n-\t\t\t\t\t      restrictions);\n+\t\t\t\t\t      restrictions);*/\n+      return parse_comparison_expr (\n+\ttok, std::move (left), std::move (outer_attrs),\n+\tAST::ComparisonExpr::ExprType::GREATER_OR_EQUAL, restrictions);\n     case LESS_OR_EQUAL:\n       // less than or equal to expression - binary infix (no associativity)\n-      return parse_binary_less_equal_expr (tok, std::move (left),\n+      /*return parse_binary_less_equal_expr (tok, std::move (left),\n \t\t\t\t\t   std::move (outer_attrs),\n-\t\t\t\t\t   restrictions);\n+\t\t\t\t\t   restrictions);*/\n+      return parse_comparison_expr (\n+\ttok, std::move (left), std::move (outer_attrs),\n+\tAST::ComparisonExpr::ExprType::LESS_OR_EQUAL, restrictions);\n     case OR:\n       // lazy logical or expression - binary infix\n       return parse_lazy_or_expr (tok, std::move (left), std::move (outer_attrs),\n@@ -12093,8 +12082,8 @@ Parser<ManagedTokenSource>::left_denotation (\n \t\t && lexer.peek_token (1)->get_id () != LEFT_PAREN\n \t\t && lexer.peek_token (1)->get_id () != SCOPE_RESOLUTION)\n \t  {\n-\t    // field expression (or should be) - FIXME: scope resolution right\n-\t    // after identifier should always be method, I'm pretty sure\n+\t    /* field expression (or should be) - FIXME: scope resolution right\n+\t     * after identifier should always be method, I'm pretty sure */\n \t    return parse_field_access_expr (tok, std::move (left),\n \t\t\t\t\t    std::move (outer_attrs),\n \t\t\t\t\t    restrictions);\n@@ -12362,6 +12351,58 @@ Parser<ManagedTokenSource>::parse_right_shift_expr (\n \t\t\t\t      locus));\n }\n \n+/* Returns the left binding power for the given ComparisonExpr type.\n+ * TODO make constexpr? Would that even do anything useful? */\n+inline binding_powers\n+get_lbp_for_comparison_expr (AST::ComparisonExpr::ExprType expr_type)\n+{\n+  switch (expr_type)\n+    {\n+    case AST::ComparisonExpr::EQUAL:\n+      return LBP_EQUAL;\n+    case AST::ComparisonExpr::NOT_EQUAL:\n+      return LBP_NOT_EQUAL;\n+    case AST::ComparisonExpr::GREATER_THAN:\n+      return LBP_GREATER_THAN;\n+    case AST::ComparisonExpr::LESS_THAN:\n+      return LBP_SMALLER_THAN;\n+    case AST::ComparisonExpr::GREATER_OR_EQUAL:\n+      return LBP_GREATER_EQUAL;\n+    case AST::ComparisonExpr::LESS_OR_EQUAL:\n+      return LBP_SMALLER_EQUAL;\n+    default:\n+      // WTF? should not happen, this is an error\n+      rust_error_at (\n+\tLocation (),\n+\t\"could not get LBP for ComparisonExpr - unknown ExprType!\");\n+      return LBP_EQUAL;\n+    }\n+}\n+\n+/* Parses a ComparisonExpr of given type and LBP. TODO find a way to only\n+ * specify one and have the other looked up - e.g. specify ExprType and binding\n+ * power is looked up? */\n+template <typename ManagedTokenSource>\n+std::unique_ptr<AST::ComparisonExpr>\n+Parser<ManagedTokenSource>::parse_comparison_expr (\n+  const_TokenPtr, std::unique_ptr<AST::Expr> left, std::vector<AST::Attribute>,\n+  AST::ComparisonExpr::ExprType expr_type, ParseRestrictions restrictions)\n+{\n+  // parse RHS (as tok has already been consumed in parse_expression)\n+  std::unique_ptr<AST::Expr> right\n+    = parse_expr (get_lbp_for_comparison_expr (expr_type),\n+\t\t  std::vector<AST::Attribute> (), restrictions);\n+  if (right == nullptr)\n+    return nullptr;\n+\n+  // TODO: check types. actually, do so during semantic analysis\n+  Location locus = left->get_locus_slow ();\n+\n+  return std::unique_ptr<AST::ComparisonExpr> (\n+    new AST::ComparisonExpr (std::move (left), std::move (right), expr_type,\n+\t\t\t     locus));\n+}\n+\n // Parses a binary equal to expression (with Pratt parsing).\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::ComparisonExpr>"}, {"sha": "cec0904c58e9349b578a5c8ff19f2da07f241462", "filename": "gcc/rust/parse/rust-parse.h", "status": "modified", "additions": 44, "deletions": 40, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f7007a777bbb3d2fbd29f66b98d71ba6849eab6/gcc%2Frust%2Fparse%2Frust-parse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f7007a777bbb3d2fbd29f66b98d71ba6849eab6/gcc%2Frust%2Fparse%2Frust-parse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse.h?ref=2f7007a777bbb3d2fbd29f66b98d71ba6849eab6", "patch": "@@ -28,7 +28,8 @@ struct ExprOrStmt\n   // Returns whether this object is in an error state.\n   bool is_error () const\n   {\n-    return (expr == nullptr && stmt == nullptr) || (expr != nullptr && stmt != nullptr);\n+    return (expr == nullptr && stmt == nullptr)\n+\t   || (expr != nullptr && stmt != nullptr);\n   }\n \n   // Returns an error state object.\n@@ -69,8 +70,7 @@ struct ParseRestrictions\n \n // Parser implementation for gccrs.\n // TODO: if updated to C++20, ManagedTokenSource would be useful as a concept\n-template <typename ManagedTokenSource> \n-class Parser\n+template <typename ManagedTokenSource> class Parser\n {\n private:\n   void skip_after_semicolon ();\n@@ -126,7 +126,7 @@ class Parser\n   std::unique_ptr<AST::MacroMatchRepetition> parse_macro_match_repetition ();\n \n   // Top-level item-related\n-  std::vector< std::unique_ptr<AST::Item> > parse_items ();\n+  std::vector<std::unique_ptr<AST::Item> > parse_items ();\n   std::unique_ptr<AST::Item> parse_item (bool called_from_statement);\n   std::unique_ptr<AST::VisItem>\n   parse_vis_item (std::vector<AST::Attribute> outer_attrs);\n@@ -141,21 +141,18 @@ class Parser\n   parse_extern_crate (AST::Visibility vis,\n \t\t      std::vector<AST::Attribute> outer_attrs);\n   std::unique_ptr<AST::UseDeclaration>\n-  parse_use_decl (AST::Visibility vis,\n-\t\t  std::vector<AST::Attribute> outer_attrs);\n+  parse_use_decl (AST::Visibility vis, std::vector<AST::Attribute> outer_attrs);\n   std::unique_ptr<AST::UseTree> parse_use_tree ();\n   std::unique_ptr<AST::Function>\n-  parse_function (AST::Visibility vis,\n-\t\t  std::vector<AST::Attribute> outer_attrs);\n+  parse_function (AST::Visibility vis, std::vector<AST::Attribute> outer_attrs);\n   AST::FunctionQualifiers parse_function_qualifiers ();\n-  std::vector< std::unique_ptr<AST::GenericParam> >\n+  std::vector<std::unique_ptr<AST::GenericParam> >\n   parse_generic_params_in_angles ();\n-  std::vector< std::unique_ptr<AST::GenericParam> > parse_generic_params ();\n-  std::vector< std::unique_ptr<AST::LifetimeParam> >\n-  parse_lifetime_params ();\n+  std::vector<std::unique_ptr<AST::GenericParam> > parse_generic_params ();\n+  std::vector<std::unique_ptr<AST::LifetimeParam> > parse_lifetime_params ();\n   std::vector<AST::LifetimeParam> parse_lifetime_params_objs ();\n   AST::LifetimeParam parse_lifetime_param ();\n-  std::vector< std::unique_ptr<AST::TypeParam> > parse_type_params ();\n+  std::vector<std::unique_ptr<AST::TypeParam> > parse_type_params ();\n   std::unique_ptr<AST::TypeParam> parse_type_param ();\n   std::vector<AST::FunctionParam> parse_function_params ();\n   AST::FunctionParam parse_function_param ();\n@@ -167,8 +164,7 @@ class Parser\n   std::unique_ptr<AST::TypeBoundWhereClauseItem>\n   parse_type_bound_where_clause_item ();\n   std::vector<AST::LifetimeParam> parse_for_lifetimes ();\n-  std::vector< std::unique_ptr<AST::TypeParamBound> >\n-  parse_type_param_bounds ();\n+  std::vector<std::unique_ptr<AST::TypeParamBound> > parse_type_param_bounds ();\n   std::unique_ptr<AST::TypeParamBound> parse_type_param_bound ();\n   std::unique_ptr<AST::TraitBound> parse_trait_bound ();\n   std::vector<AST::Lifetime> parse_lifetime_bounds ();\n@@ -184,7 +180,7 @@ class Parser\n   AST::TupleField parse_tuple_field ();\n   std::unique_ptr<AST::Enum>\n   parse_enum (AST::Visibility vis, std::vector<AST::Attribute> outer_attrs);\n-  std::vector< std::unique_ptr<AST::EnumItem> > parse_enum_items ();\n+  std::vector<std::unique_ptr<AST::EnumItem> > parse_enum_items ();\n   std::unique_ptr<AST::EnumItem> parse_enum_item ();\n   std::unique_ptr<AST::Union>\n   parse_union (AST::Visibility vis, std::vector<AST::Attribute> outer_attrs);\n@@ -209,8 +205,9 @@ class Parser\n   parse_inherent_impl_function_or_method (\n     AST::Visibility vis, std::vector<AST::Attribute> outer_attrs);\n   std::unique_ptr<AST::TraitImplItem> parse_trait_impl_item ();\n-  std::unique_ptr<AST::TraitImplItem> parse_trait_impl_function_or_method (\n-    AST::Visibility vis, std::vector<AST::Attribute> outer_attrs);\n+  std::unique_ptr<AST::TraitImplItem>\n+  parse_trait_impl_function_or_method (AST::Visibility vis,\n+\t\t\t\t       std::vector<AST::Attribute> outer_attrs);\n   std::unique_ptr<AST::ExternBlock>\n   parse_extern_block (AST::Visibility vis,\n \t\t      std::vector<AST::Attribute> outer_attrs);\n@@ -219,20 +216,20 @@ class Parser\n   AST::Method parse_method ();\n \n   // Expression-related (Pratt parsed)\n-  std::unique_ptr<AST::Expr>\n-  parse_expr (std::vector<AST::Attribute> outer_attrs\n-\t      = std::vector<AST::Attribute> (),\n-\t      ParseRestrictions restrictions = ParseRestrictions ());\n-  std::unique_ptr<AST::Expr>\n-  parse_expr (int right_binding_power,\n-\t      std::vector<AST::Attribute> outer_attrs\n-\t      = std::vector<AST::Attribute> (),\n-\t      ParseRestrictions restrictions = ParseRestrictions ());\n+  std::unique_ptr<AST::Expr> parse_expr (std::vector<AST::Attribute> outer_attrs\n+\t\t\t\t\t = std::vector<AST::Attribute> (),\n+\t\t\t\t\t ParseRestrictions restrictions\n+\t\t\t\t\t = ParseRestrictions ());\n+  std::unique_ptr<AST::Expr> parse_expr (int right_binding_power,\n+\t\t\t\t\t std::vector<AST::Attribute> outer_attrs\n+\t\t\t\t\t = std::vector<AST::Attribute> (),\n+\t\t\t\t\t ParseRestrictions restrictions\n+\t\t\t\t\t = ParseRestrictions ());\n   std::unique_ptr<AST::Expr>\n   null_denotation (const_TokenPtr t,\n-\t\t       std::vector<AST::Attribute> outer_attrs\n-\t\t       = std::vector<AST::Attribute> (),\n-\t\t       ParseRestrictions restrictions = ParseRestrictions ());\n+\t\t   std::vector<AST::Attribute> outer_attrs\n+\t\t   = std::vector<AST::Attribute> (),\n+\t\t   ParseRestrictions restrictions = ParseRestrictions ());\n   std::unique_ptr<AST::Expr>\n   left_denotation (const_TokenPtr t, std::unique_ptr<AST::Expr> left,\n \t\t   std::vector<AST::Attribute> outer_attrs\n@@ -243,10 +240,11 @@ class Parser\n \t\t\t  std::vector<AST::Attribute> outer_attrs,\n \t\t\t  ParseRestrictions restrictions\n \t\t\t  = ParseRestrictions ());\n-  std::unique_ptr<AST::ArithmeticOrLogicalExpr> parse_binary_minus_expr (\n-    const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n-    std::vector<AST::Attribute> outer_attrs,\n-    ParseRestrictions restrictions = ParseRestrictions ());\n+  std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n+  parse_binary_minus_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+\t\t\t   std::vector<AST::Attribute> outer_attrs,\n+\t\t\t   ParseRestrictions restrictions\n+\t\t\t   = ParseRestrictions ());\n   std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n   parse_binary_mult_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n \t\t\t  std::vector<AST::Attribute> outer_attrs,\n@@ -283,10 +281,16 @@ class Parser\n \t\t\t  std::vector<AST::Attribute> outer_attrs,\n \t\t\t  ParseRestrictions restrictions\n \t\t\t  = ParseRestrictions ());\n-  std::unique_ptr<AST::ComparisonExpr> parse_binary_equal_expr (\n-    const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n-    std::vector<AST::Attribute> outer_attrs,\n-    ParseRestrictions restrictions = ParseRestrictions ());\n+  std::unique_ptr<AST::ComparisonExpr>\n+  parse_comparison_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+\t\t\t std::vector<AST::Attribute> outer_attrs,\n+\t\t\t AST::ComparisonExpr::ExprType expr_type,\n+\t\t\t ParseRestrictions restrictions = ParseRestrictions ());\n+  std::unique_ptr<AST::ComparisonExpr>\n+  parse_binary_equal_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+\t\t\t   std::vector<AST::Attribute> outer_attrs,\n+\t\t\t   ParseRestrictions restrictions\n+\t\t\t   = ParseRestrictions ());\n   std::unique_ptr<AST::ComparisonExpr> parse_binary_not_equal_expr (\n     const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n     std::vector<AST::Attribute> outer_attrs,\n@@ -457,7 +461,7 @@ class Parser\n \t\t    = std::vector<AST::Attribute> (),\n \t\t    bool pratt_parse = false);\n   AST::MatchArm parse_match_arm ();\n-  std::vector< std::unique_ptr<AST::Pattern> >\n+  std::vector<std::unique_ptr<AST::Pattern> >\n   parse_match_arm_patterns (TokenId end_token_id);\n   std::unique_ptr<AST::BaseLoopExpr>\n   parse_labelled_loop_expr (std::vector<AST::Attribute> outer_attrs\n@@ -551,7 +555,7 @@ class Parser\n \n public:\n   // Construct parser with specified \"managed\" token source.\n-  Parser (ManagedTokenSource tokenSource) : lexer (std::move(tokenSource)) {}\n+  Parser (ManagedTokenSource tokenSource) : lexer (std::move (tokenSource)) {}\n \n   // Main entry point for parser.\n   AST::Crate parse_crate ();"}]}