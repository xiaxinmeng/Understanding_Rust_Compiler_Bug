{"sha": "cf7ec0ab009db4a5cda12d0756427bd6d292e377", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2Y3ZWMwYWIwMDlkYjRhNWNkYTEyZDA3NTY0MjdiZDZkMjkyZTM3Nw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-06-08T12:24:30Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-06-08T12:24:30Z"}, "message": "sibcall.c (skip_unreturned_value): New function.\n\n\t* sibcall.c (skip_unreturned_value): New function.\n\t(call_ends_block_p): Use it.\n\nFrom-SVN: r43010", "tree": {"sha": "b697dc90e12964767994ab80553cb5edacea3c88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b697dc90e12964767994ab80553cb5edacea3c88"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cf7ec0ab009db4a5cda12d0756427bd6d292e377", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf7ec0ab009db4a5cda12d0756427bd6d292e377", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf7ec0ab009db4a5cda12d0756427bd6d292e377", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf7ec0ab009db4a5cda12d0756427bd6d292e377/comments", "author": null, "committer": null, "parents": [{"sha": "d58d4c12b026c142675eaac6e56b39a6ee19a267", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d58d4c12b026c142675eaac6e56b39a6ee19a267", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d58d4c12b026c142675eaac6e56b39a6ee19a267"}], "stats": {"total": 38, "additions": 38, "deletions": 0}, "files": [{"sha": "05be51cfbfbf404b8863af2190270bc64dd77663", "filename": "gcc/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf7ec0ab009db4a5cda12d0756427bd6d292e377/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf7ec0ab009db4a5cda12d0756427bd6d292e377/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cf7ec0ab009db4a5cda12d0756427bd6d292e377", "patch": "@@ -1,5 +1,8 @@\n Fri Jun  8 14:16:33 CEST 2001  Jan Hubicka  <jh@suse.cz>\n \n+\t* sibcall.c (skip_unreturned_value): New function.\n+\t(call_ends_block_p): Use it.\n+\n \t* recog.c (split_insn): Break out from ...\n \t(split_all_insns): ... here; do not use basic block information\n \twhen it is broken."}, {"sha": "5c437b1053922efca70a834fdade8aaacaa1404b", "filename": "gcc/sibcall.c", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf7ec0ab009db4a5cda12d0756427bd6d292e377/gcc%2Fsibcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf7ec0ab009db4a5cda12d0756427bd6d292e377/gcc%2Fsibcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsibcall.c?ref=cf7ec0ab009db4a5cda12d0756427bd6d292e377", "patch": "@@ -43,6 +43,7 @@ static int uses_addressof\t\tPARAMS ((rtx));\n static int sequence_uses_addressof\tPARAMS ((rtx));\n static void purge_reg_equiv_notes\tPARAMS ((void));\n static void purge_mem_unchanging_flag\tPARAMS ((rtx));\n+static rtx skip_unreturned_value \tPARAMS ((rtx));\n \n /* Examine a CALL_PLACEHOLDER pattern and determine where the call's\n    return value is located.  P_HARD_RETURN receives the hard register\n@@ -220,6 +221,35 @@ skip_use_of_return_value (orig_insn, code)\n   return orig_insn;\n }\n \n+/* In case function does not return value,  we get clobber of pseudo followed\n+   by set to hard return value.  */\n+static rtx\n+skip_unreturned_value (orig_insn)\n+     rtx orig_insn;\n+{\n+  rtx insn = next_nonnote_insn (orig_insn);\n+\n+  /* Skip possible clobber of pseudo return register.  */\n+  if (insn\n+      && GET_CODE (insn) == INSN\n+      && GET_CODE (PATTERN (insn)) == CLOBBER\n+      && REG_P (XEXP (PATTERN (insn), 0))\n+      && (REGNO (XEXP (PATTERN (insn), 0)) >= FIRST_PSEUDO_REGISTER))\n+    {\n+      rtx set_insn = next_nonnote_insn (insn);\n+      rtx set;\n+      if (!set_insn)\n+\treturn insn;\n+      set = single_set (set_insn);\n+      if (!set\n+\t  || SET_SRC (set) != XEXP (PATTERN (insn), 0)\n+\t  || SET_DEST (set) != current_function_return_rtx)\n+\treturn insn;\n+      return set_insn;\n+    }\n+  return orig_insn;\n+}\n+\n /* If the first real insn after ORIG_INSN adjusts the stack pointer\n    by a constant, return the insn with the stack pointer adjustment.\n    Otherwise return ORIG_INSN.  */\n@@ -317,6 +347,11 @@ call_ends_block_p (insn, end)\n   if (insn == end)\n     return 1;\n \n+  /* Skip over a CLOBBER of the return value as a hard reg.  */\n+  insn = skip_unreturned_value (insn);\n+  if (insn == end)\n+    return 1;\n+\n   /* Skip over a USE of the return value (as a hard reg).  */\n   insn = skip_use_of_return_value (insn, USE);\n   if (insn == end)"}]}