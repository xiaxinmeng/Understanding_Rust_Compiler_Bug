{"sha": "f5045c967e137546faaf24cac2d9f103533775cc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjUwNDVjOTY3ZTEzNzU0NmZhYWYyNGNhYzJkOWYxMDM1MzM3NzVjYw==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2009-07-30T18:36:30Z"}, "committer": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "2009-07-30T18:36:30Z"}, "message": "Add source_location support to PHI arguments.\n\n\n2009-07-29  Andrew MacLeod  <amacleod@redhat.com>\n\n\tPR debug 26475\n\t* tree-into-ssa.c (insert_phi_nodes_for, rewrite_add_phi_arguments): Set\n\tlocation for phi arguments.\n\t(rewrite_update_phi_arguments): Find locations for reaching defs.\n\t* tree-ssa-threadupdate.c (create_edge_and_update_destination_phis):\n\tAdd location to add_phi_arg calls.\n\t* tree-loop-districbution.c (update_phis_for_loop_copy): Add locations.\n\t* tree-ssa-loop-manip.c (create_iv, add_exit_phis_edge,\n\tsplit_loop_exit_edge, tree_transform_and_unroll_loop): Add locations.\n\t* tree-tailcall.c (add_successor_phi_arg, eliminate_tail_call,\n\tcreate_tailcall_accumulator, tree_optimize_tail_calls_1): Add locations.\n\t* tree.h (struct phi_arg_d): Add location_t to PHI arguments.\n\t* tree-phinodes.c (make_phi_node): Initialize location.\n\t(resize_phi_node): Initialize location to UNKNOWN_LOCATION.\n\t(add_phi_arg): Add location parameter.\n\t(remove_phi_arg_num): Move location when moving phi argument.\n\t* omp-low.c (expand_parallel_call, expand_omp_for_static_chunk): Set \n\tlocation.\n\t* tree-vect-loop-manip.c (slpeel_update_phis_for_duplicate_loop,\n\tslpeel_update_phi_nodes_for_guard1,\n\tslpeel_update_phi_nodes_for_guard2,\n\tslpeel_tree_duplicate_loop_to_edge_cfg, set_prologue_iterations,\n\tvect_loop_versioning): Set locations.\n\t* tree-parloops.c (create_phi_for_local_result,\n\ttransform_to_exit_first_loop, create_parallel_loop): Add locations.\n\t* gimple-pretty-print.c (dump_gimple_phi): Dump lineno's if present.\n\t* tree-vect-loop.c (get_initial_def_for_induction,\n\tvect_create_epilog_for_reduction, vect_finalize_reduction): Add\n\tlocations.\n\t* tree-flow-inline.h (gimple_phi_arg_location): New.  Return locus.\n\t(gimple_phi_arg_location_from_edge): New.  Return locus from an edge.\n\t(gimple_phi_arg_set_location): New.  Set locus.\n\t(gimple_phi_arg_has_location): New.  Check for locus.\n\t(redirect_edge_var_map_location): New.  Return locus from var_map.\n\t* tree-vect-data-refs.c (vect_setup_realignment): Set location.\n\t* tree-ssa-phiopt.c (conditional_replacement): Set locus when\n\tcombining PHI arguments.\n\t(cond_store_replacement): Set location.\n\t* cfgexpand.c (gimple_assign_rhs_to_tree): Transfer locus if possible.\n\t* grpahite.c (add_loop_exit_phis, add_guard_exit_phis,\n\tscop_add_exit_phis_edge): Add locations.\n\t* tree-cfgcleanup.c (remove_forwarder_block,\n\tremove_forwarder_block_with_phi): Add locations.\n\t* tree-ssa-pre.c (insert_into_preds_of_block): Add locations.\n\t* tree-predcom.c (initialize_root_vars, initialize_root_vars_lm): Add\n\tlocations.\n\t* tree-ssa-dce.c (forward_edge_to_pdom): Add locations.\n\t* tree-ssa.c (redirect_edge_var_map_add, ssa_redirect_edge,\n\tflush_pending_stmts): Add source location.\n\t* lambda-code.c (perfect_nestify): Maintain location stack with argument\n\tstack to preserve locations.\n\t* tree-vect-stmts.c (vectorizable_load): Add location.\n\t* tree-inline.c (copy_phis_for_bb): Copy locus.\n\t(setup_one_parameter): Add call locus to inlined parameter stmts.\n\t(initialize_inlined_parameters): Pass in call location as parameter\n\tassignment locus.\n\t(tree_function_versioning): Pass location to setup_one_parameter.\n\t* tree-ssa-phiprop.c (phiprop_insert_phi): Set locations.\n\t* tree-outof-ssa.c (struct _elim_graph): Add source_location vecs for\n\tcopy and edge lists.\n\t(insert_partition_copy_on_edge, insert_value_copy_on_edge,\n\tinsert_rtx_to_part_on_edge, insert_part_to_rtx_on_edge): Provide a \n\tlocus parameter and override the stmt default if provided.\n\t(new_elim_graph, clear_elim_graph, delete_elim_graph,\n\telim_graph_add_edge, elim_graph_remove_succ_edge,\n\tFOR_EACH_ELIM_GRAPH_SUCC, FOR_EACH_ELIM_GRAPH_PRED, eliminate_build,\n\telim_forward, elim_unvisited_predecessor, elim_backward, elim_create,\n\teliminate_phi):  Add locus info in elimination graph for each edge and\n\tvalue copy.\n\t(insert_backedge_copies): Copy locus if present.\n\t* tree-flow.h (struct _edge_var_map): Add locus field.\n\t* tree-switch_conversions.c (fix_phi_nodes): Add locations.\n\t* tree-cfg.c (reinstall_phi_args, gimple_make_forwarder_block,\n\tadd_phi_args_after_copy_edge, gimple_lv_adjust_loop_header_phi): Add \n\tlocations.\n\t* ipa-struct-reorg.c (make_edge_and_fix_phis_of_dest): Add locations.\n\nFrom-SVN: r150267", "tree": {"sha": "c3c37452d20254e178bef3a30aeb83c4cc6ef27e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c3c37452d20254e178bef3a30aeb83c4cc6ef27e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f5045c967e137546faaf24cac2d9f103533775cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5045c967e137546faaf24cac2d9f103533775cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5045c967e137546faaf24cac2d9f103533775cc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5045c967e137546faaf24cac2d9f103533775cc/comments", "author": null, "committer": null, "parents": [{"sha": "8a04f5d8b763695d99b27c0c8b704b59f1cfa31a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a04f5d8b763695d99b27c0c8b704b59f1cfa31a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a04f5d8b763695d99b27c0c8b704b59f1cfa31a"}], "stats": {"total": 533, "additions": 424, "deletions": 109}, "files": [{"sha": "47845784fbcd8c81b3ca20473c6f2c81e86dcde5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5045c967e137546faaf24cac2d9f103533775cc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5045c967e137546faaf24cac2d9f103533775cc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f5045c967e137546faaf24cac2d9f103533775cc", "patch": "@@ -1,3 +1,82 @@\n+2009-07-30  Andrew MacLeod  <amacleod@redhat.com>\n+\n+\tPR debug/26475\n+\t* tree-into-ssa.c (insert_phi_nodes_for, rewrite_add_phi_arguments): Set\n+\tlocation for phi arguments.\n+\t(rewrite_update_phi_arguments): Find locations for reaching defs.\n+\t* tree-ssa-threadupdate.c (create_edge_and_update_destination_phis):\n+\tAdd location to add_phi_arg calls.\n+\t* tree-loop-districbution.c (update_phis_for_loop_copy): Add locations.\n+\t* tree-ssa-loop-manip.c (create_iv, add_exit_phis_edge,\n+\tsplit_loop_exit_edge, tree_transform_and_unroll_loop): Add locations.\n+\t* tree-tailcall.c (add_successor_phi_arg, eliminate_tail_call,\n+\tcreate_tailcall_accumulator, tree_optimize_tail_calls_1): Add locations.\n+\t* tree.h (struct phi_arg_d): Add location_t to PHI arguments.\n+\t* tree-phinodes.c (make_phi_node): Initialize location.\n+\t(resize_phi_node): Initialize location to UNKNOWN_LOCATION.\n+\t(add_phi_arg): Add location parameter.\n+\t(remove_phi_arg_num): Move location when moving phi argument.\n+\t* omp-low.c (expand_parallel_call, expand_omp_for_static_chunk): Set \n+\tlocation.\n+\t* tree-vect-loop-manip.c (slpeel_update_phis_for_duplicate_loop,\n+\tslpeel_update_phi_nodes_for_guard1,\n+\tslpeel_update_phi_nodes_for_guard2,\n+\tslpeel_tree_duplicate_loop_to_edge_cfg, set_prologue_iterations,\n+\tvect_loop_versioning): Set locations.\n+\t* tree-parloops.c (create_phi_for_local_result,\n+\ttransform_to_exit_first_loop, create_parallel_loop): Add locations.\n+\t* gimple-pretty-print.c (dump_gimple_phi): Dump lineno's if present.\n+\t* tree-vect-loop.c (get_initial_def_for_induction,\n+\tvect_create_epilog_for_reduction, vect_finalize_reduction): Add\n+\tlocations.\n+\t* tree-flow-inline.h (gimple_phi_arg_location): New.  Return locus.\n+\t(gimple_phi_arg_location_from_edge): New.  Return locus from an edge.\n+\t(gimple_phi_arg_set_location): New.  Set locus.\n+\t(gimple_phi_arg_has_location): New.  Check for locus.\n+\t(redirect_edge_var_map_location): New.  Return locus from var_map.\n+\t* tree-vect-data-refs.c (vect_setup_realignment): Set location.\n+\t* tree-ssa-phiopt.c (conditional_replacement): Set locus when\n+\tcombining PHI arguments.\n+\t(cond_store_replacement): Set location.\n+\t* cfgexpand.c (gimple_assign_rhs_to_tree): Transfer locus if possible.\n+\t* grpahite.c (add_loop_exit_phis, add_guard_exit_phis,\n+\tscop_add_exit_phis_edge): Add locations.\n+\t* tree-cfgcleanup.c (remove_forwarder_block,\n+\tremove_forwarder_block_with_phi): Add locations.\n+\t* tree-ssa-pre.c (insert_into_preds_of_block): Add locations.\n+\t* tree-predcom.c (initialize_root_vars, initialize_root_vars_lm): Add\n+\tlocations.\n+\t* tree-ssa-dce.c (forward_edge_to_pdom): Add locations.\n+\t* tree-ssa.c (redirect_edge_var_map_add, ssa_redirect_edge,\n+\tflush_pending_stmts): Add source location.\n+\t* lambda-code.c (perfect_nestify): Maintain location stack with argument\n+\tstack to preserve locations.\n+\t* tree-vect-stmts.c (vectorizable_load): Add location.\n+\t* tree-inline.c (copy_phis_for_bb): Copy locus.\n+\t(setup_one_parameter): Add call locus to inlined parameter stmts.\n+\t(initialize_inlined_parameters): Pass in call location as parameter\n+\tassignment locus.\n+\t(tree_function_versioning): Pass location to setup_one_parameter.\n+\t* tree-ssa-phiprop.c (phiprop_insert_phi): Set locations.\n+\t* tree-outof-ssa.c (struct _elim_graph): Add source_location vecs for\n+\tcopy and edge lists.\n+\t(insert_partition_copy_on_edge, insert_value_copy_on_edge,\n+\tinsert_rtx_to_part_on_edge, insert_part_to_rtx_on_edge): Provide a \n+\tlocus parameter and override the stmt default if provided.\n+\t(new_elim_graph, clear_elim_graph, delete_elim_graph,\n+\telim_graph_add_edge, elim_graph_remove_succ_edge,\n+\tFOR_EACH_ELIM_GRAPH_SUCC, FOR_EACH_ELIM_GRAPH_PRED, eliminate_build,\n+\telim_forward, elim_unvisited_predecessor, elim_backward, elim_create,\n+\teliminate_phi):  Add locus info in elimination graph for each edge and\n+\tvalue copy.\n+\t(insert_backedge_copies): Copy locus if present.\n+\t* tree-flow.h (struct _edge_var_map): Add locus field.\n+\t* tree-switch_conversions.c (fix_phi_nodes): Add locations.\n+\t* tree-cfg.c (reinstall_phi_args, gimple_make_forwarder_block,\n+\tadd_phi_args_after_copy_edge, gimple_lv_adjust_loop_header_phi): Add \n+\tlocations.\n+\t* ipa-struct-reorg.c (make_edge_and_fix_phis_of_dest): Add locations.\n+\t\n 2009-07-30  Martin Jambor  <mjambor@suse.cz>\n \n \tPR tree-optimization/40570"}, {"sha": "c172c96a5801f6a087041e4c3985c0ade2d949b9", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5045c967e137546faaf24cac2d9f103533775cc/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5045c967e137546faaf24cac2d9f103533775cc/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=f5045c967e137546faaf24cac2d9f103533775cc", "patch": "@@ -74,6 +74,9 @@ gimple_assign_rhs_to_tree (gimple stmt)\n   else\n     gcc_unreachable ();\n \n+  if (gimple_has_location (stmt) && CAN_HAVE_LOCATION_P (t))\n+    SET_EXPR_LOCATION (t, gimple_location (stmt));\n+\n   return t;\n }\n "}, {"sha": "70ab4e1b8006af4f9c179e5869a3e6ad35f6a39e", "filename": "gcc/gimple-pretty-print.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5045c967e137546faaf24cac2d9f103533775cc/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5045c967e137546faaf24cac2d9f103533775cc/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=f5045c967e137546faaf24cac2d9f103533775cc", "patch": "@@ -1150,6 +1150,22 @@ dump_gimple_phi (pretty_printer *buffer, gimple phi, int spc, int flags)\n     }\n   for (i = 0; i < gimple_phi_num_args (phi); i++)\n     {\n+      if ((flags & TDF_LINENO) && gimple_phi_arg_has_location (phi, i))\n+        {\n+\t  expanded_location xloc;\n+\n+\t  xloc = expand_location (gimple_phi_arg_location (phi, i));\n+\t  pp_character (buffer, '[');\n+\t  if (xloc.file)\n+\t    {\n+\t      pp_string (buffer, xloc.file);\n+\t      pp_string (buffer, \" : \");\n+\t    }\n+\t  pp_decimal_int (buffer, xloc.line);\n+\t  pp_string (buffer, \":\");\n+\t  pp_decimal_int (buffer, xloc.column);\n+\t  pp_string (buffer, \"] \");\n+\t}\n       dump_generic_node (buffer, gimple_phi_arg_def (phi, i), spc, flags,\n \t\t\t false);\n       pp_character (buffer, '(');"}, {"sha": "f3bdc4b101ff05c20cfb1c11ea66f71500b95def", "filename": "gcc/graphite.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5045c967e137546faaf24cac2d9f103533775cc/gcc%2Fgraphite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5045c967e137546faaf24cac2d9f103533775cc/gcc%2Fgraphite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite.c?ref=f5045c967e137546faaf24cac2d9f103533775cc", "patch": "@@ -4555,7 +4555,7 @@ add_loop_exit_phis (void **slot, void *s)\n   tree res = create_new_def_for (gimple_phi_result (phi), phi,\n \t\t\t\t gimple_phi_result_ptr (phi));\n \n-  add_phi_arg (phi, new_name, single_pred_edge (bb));\n+  add_phi_arg (phi, new_name, single_pred_edge (bb), UNKNOWN_LOCATION);\n \n   entry->new_name = res;\n   *slot = entry;\n@@ -4617,8 +4617,8 @@ add_guard_exit_phis (void **slot, void *s)\n   tree res = create_new_def_for (gimple_phi_result (phi), phi,\n \t\t\t\t gimple_phi_result_ptr (phi));\n \n-  add_phi_arg (phi, name1, true_edge);\n-  add_phi_arg (phi, name2, false_edge);\n+  add_phi_arg (phi, name1, true_edge, UNKNOWN_LOCATION);\n+  add_phi_arg (phi, name2, false_edge, UNKNOWN_LOCATION);\n \n   entry->new_name = res;\n   *slot = entry;\n@@ -5141,8 +5141,8 @@ scop_add_exit_phis_edge (basic_block exit, tree use, edge false_e, edge true_e)\n \n   create_new_def_for (gimple_phi_result (phi), phi,\n \t\t      gimple_phi_result_ptr (phi));\n-  add_phi_arg (phi, use, false_e);\n-  add_phi_arg (phi, use, true_e);\n+  add_phi_arg (phi, use, false_e, UNKNOWN_LOCATION);\n+  add_phi_arg (phi, use, true_e, UNKNOWN_LOCATION);\n }\n \n /* Add phi nodes for VAR that is used in LIVEIN.  Phi nodes are"}, {"sha": "bc84eee372b483fce4e0bd3670d78517c525f051", "filename": "gcc/ipa-struct-reorg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5045c967e137546faaf24cac2d9f103533775cc/gcc%2Fipa-struct-reorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5045c967e137546faaf24cac2d9f103533775cc/gcc%2Fipa-struct-reorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-struct-reorg.c?ref=f5045c967e137546faaf24cac2d9f103533775cc", "patch": "@@ -658,7 +658,7 @@ make_edge_and_fix_phis_of_dest (basic_block bb, edge e)\n     {\n       gimple phi = gsi_stmt (si);\n       arg = PHI_ARG_DEF_FROM_EDGE (phi, e);\n-      add_phi_arg (phi, arg, new_e); \n+      add_phi_arg (phi, arg, new_e, gimple_phi_arg_location_from_edge (phi, e));\n     }\n \n   return new_e;"}, {"sha": "e7a49951a67c51a5dfd0670cb89bf73c0cf37a92", "filename": "gcc/lambda-code.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5045c967e137546faaf24cac2d9f103533775cc/gcc%2Flambda-code.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5045c967e137546faaf24cac2d9f103533775cc/gcc%2Flambda-code.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-code.c?ref=f5045c967e137546faaf24cac2d9f103533775cc", "patch": "@@ -2343,6 +2343,10 @@ can_convert_to_perfect_nest (struct loop *loop)\n   return false;\n }\n \n+\n+DEF_VEC_I(source_location);\n+DEF_VEC_ALLOC_I(source_location,heap);\n+\n /* Transform the loop nest into a perfect nest, if possible.\n    LOOP is the loop nest to transform into a perfect nest\n    LBOUNDS are the lower bounds for the loops to transform\n@@ -2400,6 +2404,7 @@ perfect_nestify (struct loop *loop,\n   gimple stmt;\n   tree oldivvar, ivvar, ivvarinced;\n   VEC(tree,heap) *phis = NULL;\n+  VEC(source_location,heap) *locations = NULL;\n   htab_t replacements = NULL;\n \n   /* Create the new loop.  */\n@@ -2412,8 +2417,11 @@ perfect_nestify (struct loop *loop,\n     {\n       phi = gsi_stmt (bsi);\n       VEC_reserve (tree, heap, phis, 2);\n+      VEC_reserve (source_location, heap, locations, 1);\n       VEC_quick_push (tree, phis, PHI_RESULT (phi));\n       VEC_quick_push (tree, phis, PHI_ARG_DEF (phi, 0));\n+      VEC_quick_push (source_location, locations, \n+\t\t      gimple_phi_arg_location (phi, 0));\n     }\n   e = redirect_edge_and_branch (single_succ_edge (preheaderbb), headerbb);\n \n@@ -2426,10 +2434,12 @@ perfect_nestify (struct loop *loop,\n     {\n       tree def;\n       tree phiname;\n+      source_location locus;\n       def = VEC_pop (tree, phis);\n       phiname = VEC_pop (tree, phis);      \n+      locus = VEC_pop (source_location, locations);\n       phi = create_phi_node (phiname, preheaderbb);\n-      add_phi_arg (phi, def, single_pred_edge (preheaderbb));\n+      add_phi_arg (phi, def, single_pred_edge (preheaderbb), locus);\n     }\n   flush_pending_stmts (e);\n   VEC_free (tree, heap, phis);"}, {"sha": "3a4a1f40c55b131debe03826c8882c87005f168a", "filename": "gcc/omp-low.c", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5045c967e137546faaf24cac2d9f103533775cc/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5045c967e137546faaf24cac2d9f103533775cc/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=f5045c967e137546faaf24cac2d9f103533775cc", "patch": "@@ -3013,8 +3013,8 @@ expand_parallel_call (struct omp_region *region, basic_block bb,\n \t    {\n \t      gimple phi = create_phi_node (tmp_join, bb);\n \t      SSA_NAME_DEF_STMT (tmp_join) = phi;\n-\t      add_phi_arg (phi, tmp_then, e_then);\n-\t      add_phi_arg (phi, tmp_else, e_else);\n+\t      add_phi_arg (phi, tmp_then, e_then, UNKNOWN_LOCATION);\n+\t      add_phi_arg (phi, tmp_else, e_else, UNKNOWN_LOCATION);\n \t    }\n \n \t  val = tmp_join;\n@@ -4508,6 +4508,7 @@ expand_omp_for_static_chunk (struct omp_region *region, struct omp_for_data *fd)\n \t   gsi_next (&psi), ++i)\n \t{\n \t  gimple nphi;\n+\t  source_location locus;\n \n \t  phi = gsi_stmt (psi);\n \t  t = gimple_phi_result (phi);\n@@ -4516,12 +4517,15 @@ expand_omp_for_static_chunk (struct omp_region *region, struct omp_for_data *fd)\n \t  SSA_NAME_DEF_STMT (t) = nphi;\n \n \t  t = PHI_ARG_DEF_FROM_EDGE (phi, se);\n+\t  locus = gimple_phi_arg_location_from_edge (phi, se);\n+\n \t  /* A special case -- fd->loop.v is not yet computed in\n \t     iter_part_bb, we need to use v_extra instead.  */\n \t  if (t == fd->loop.v)\n \t    t = v_extra;\n-\t  add_phi_arg (nphi, t, ene);\n-\t  add_phi_arg (nphi, redirect_edge_var_map_def (vm), re);\n+\t  add_phi_arg (nphi, t, ene, locus);\n+\t  locus = redirect_edge_var_map_location (vm);\n+\t  add_phi_arg (nphi, redirect_edge_var_map_def (vm), re, locus);\n \t}\n       gcc_assert (!gsi_end_p (psi) && i == VEC_length (edge_var_map, head));\n       redirect_edge_var_map_clear (re);\n@@ -4536,8 +4540,10 @@ expand_omp_for_static_chunk (struct omp_region *region, struct omp_for_data *fd)\n       /* Make phi node for trip.  */\n       phi = create_phi_node (trip_main, iter_part_bb);\n       SSA_NAME_DEF_STMT (trip_main) = phi;\n-      add_phi_arg (phi, trip_back, single_succ_edge (trip_update_bb));\n-      add_phi_arg (phi, trip_init, single_succ_edge (entry_bb));\n+      add_phi_arg (phi, trip_back, single_succ_edge (trip_update_bb),\n+\t\t   UNKNOWN_LOCATION);\n+      add_phi_arg (phi, trip_init, single_succ_edge (entry_bb),\n+\t\t   UNKNOWN_LOCATION);\n     }\n \n   set_immediate_dominator (CDI_DOMINATORS, trip_update_bb, cont_bb);"}, {"sha": "a6097edf3fe2f9d7f43d2af3f5dbfc6ace9f92a1", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5045c967e137546faaf24cac2d9f103533775cc/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5045c967e137546faaf24cac2d9f103533775cc/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=f5045c967e137546faaf24cac2d9f103533775cc", "patch": "@@ -2886,7 +2886,7 @@ reinstall_phi_args (edge new_edge, edge old_edge)\n  \n       gcc_assert (result == gimple_phi_result (phi));\n   \n-      add_phi_arg (phi, arg, new_edge);\n+      add_phi_arg (phi, arg, new_edge, redirect_edge_var_map_location (vm));\n     }\n   \n   redirect_edge_var_map_clear (old_edge);\n@@ -4840,7 +4840,8 @@ gimple_make_forwarder_block (edge fallthru)\n       new_phi = create_phi_node (var, bb);\n       SSA_NAME_DEF_STMT (var) = new_phi;\n       gimple_phi_set_result (phi, make_ssa_name (SSA_NAME_VAR (var), phi));\n-      add_phi_arg (new_phi, gimple_phi_result (phi), fallthru);\n+      add_phi_arg (new_phi, gimple_phi_result (phi), fallthru, \n+\t\t   UNKNOWN_LOCATION);\n     }\n \n   /* Add the arguments we have stored on edges.  */\n@@ -5239,7 +5240,8 @@ add_phi_args_after_copy_edge (edge e_copy)\n       phi = gsi_stmt (psi);\n       phi_copy = gsi_stmt (psi_copy);\n       def = PHI_ARG_DEF_FROM_EDGE (phi, e);\n-      add_phi_arg (phi_copy, def, e_copy);\n+      add_phi_arg (phi_copy, def, e_copy, \n+\t\t   gimple_phi_arg_location_from_edge (phi, e));\n     }\n }\n \n@@ -7058,7 +7060,7 @@ gimple_lv_adjust_loop_header_phi (basic_block first, basic_block second,\n       phi1 = gsi_stmt (psi1);\n       phi2 = gsi_stmt (psi2);\n       def = PHI_ARG_DEF (phi2, e2->dest_idx);\n-      add_phi_arg (phi1, def, e);\n+      add_phi_arg (phi1, def, e, gimple_phi_arg_location_from_edge (phi2, e2));\n     }\n }\n "}, {"sha": "34cfc80bbee756e5bc15d0537b3e5685a02491fe", "filename": "gcc/tree-cfgcleanup.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5045c967e137546faaf24cac2d9f103533775cc/gcc%2Ftree-cfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5045c967e137546faaf24cac2d9f103533775cc/gcc%2Ftree-cfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfgcleanup.c?ref=f5045c967e137546faaf24cac2d9f103533775cc", "patch": "@@ -401,7 +401,8 @@ remove_forwarder_block (basic_block bb)\n \t       gsi_next (&gsi))\n \t    {\n \t      gimple phi = gsi_stmt (gsi);\n-\t      add_phi_arg (phi, gimple_phi_arg_def (phi, succ->dest_idx), s);\n+\t      source_location l = gimple_phi_arg_location_from_edge (phi, succ);\n+\t      add_phi_arg (phi, gimple_phi_arg_def (phi, succ->dest_idx), s, l);\n \t    }\n \t}\n     }\n@@ -744,6 +745,7 @@ remove_forwarder_block_with_phi (basic_block bb)\n \t{\n \t  gimple phi = gsi_stmt (gsi);\n \t  tree def = gimple_phi_arg_def (phi, succ->dest_idx);\n+\t  source_location locus = gimple_phi_arg_location_from_edge (phi, succ);\n \n \t  if (TREE_CODE (def) == SSA_NAME)\n \t    {\n@@ -763,12 +765,13 @@ remove_forwarder_block_with_phi (basic_block bb)\n \t\t  if (def == old_arg)\n \t\t    {\n \t\t      def = new_arg;\n+\t\t      locus = redirect_edge_var_map_location (vm);\n \t\t      break;\n \t\t    }\n \t\t}\n \t    }\n \n-\t  add_phi_arg (phi, def, s);\n+\t  add_phi_arg (phi, def, s, locus);\n \t}\n \n       redirect_edge_var_map_clear (e);"}, {"sha": "f56ecea7db7bd24d75fa0f050644035378856b23", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5045c967e137546faaf24cac2d9f103533775cc/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5045c967e137546faaf24cac2d9f103533775cc/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=f5045c967e137546faaf24cac2d9f103533775cc", "patch": "@@ -455,6 +455,39 @@ gimple_phi_arg_edge (gimple gs, size_t i)\n   return EDGE_PRED (gimple_bb (gs), i);\n }\n \n+/* Return the source location of gimple argument I of phi node GS.  */\n+\n+static inline source_location\n+gimple_phi_arg_location (gimple gs, size_t i)\n+{\n+  return gimple_phi_arg (gs, i)->locus;\n+}\n+\n+/* Return the source location of the argument on edge E of phi node GS.  */\n+\n+static inline source_location\n+gimple_phi_arg_location_from_edge (gimple gs, edge e)\n+{\n+  return gimple_phi_arg (gs, e->dest_idx)->locus;\n+}\n+\n+/* Set the source location of gimple argument I of phi node GS to LOC.  */\n+\n+static inline void\n+gimple_phi_arg_set_location (gimple gs, size_t i, source_location loc)\n+{\n+  gimple_phi_arg (gs, i)->locus = loc;\n+}\n+\n+/* Return TRUE if argument I of phi node GS has a location record.  */\n+\n+static inline bool\n+gimple_phi_arg_has_location (gimple gs, size_t i)\n+{\n+  return gimple_phi_arg_location (gs, i) != UNKNOWN_LOCATION;\n+}\n+\n+\n /* Return the PHI nodes for basic block BB, or NULL if there are no\n    PHI nodes.  */\n static inline gimple_seq\n@@ -1196,6 +1229,14 @@ redirect_edge_var_map_result (edge_var_map *v)\n   return v->result;\n }\n \n+/* Given an edge_var_map V, return the PHI arg location.  */\n+\n+static inline source_location\n+redirect_edge_var_map_location (edge_var_map *v)\n+{\n+  return v->locus;\n+}\n+\n \n /* Return an SSA_NAME node for variable VAR defined in statement STMT\n    in function cfun.  */"}, {"sha": "69dc446b8b8a0c8c0f15546be311d7b8315e3e59", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5045c967e137546faaf24cac2d9f103533775cc/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5045c967e137546faaf24cac2d9f103533775cc/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=f5045c967e137546faaf24cac2d9f103533775cc", "patch": "@@ -579,7 +579,7 @@ extern void reserve_phi_args_for_new_edge (basic_block);\n extern void add_phi_node_to_bb (gimple phi, basic_block bb);\n extern gimple make_phi_node (tree var, int len);\n extern gimple create_phi_node (tree, basic_block);\n-extern void add_phi_arg (gimple, tree, edge);\n+extern void add_phi_arg (gimple, tree, edge, source_location);\n extern void remove_phi_args (edge);\n extern void remove_phi_node (gimple_stmt_iterator *, bool);\n extern void remove_phi_nodes (basic_block);\n@@ -604,6 +604,7 @@ extern bool gimple_stmt_may_fallthru (gimple);\n struct GTY(()) _edge_var_map {\n   tree result;\t\t\t/* PHI result.  */\n   tree def;\t\t\t/* PHI arg definition.  */\n+  source_location locus;        /* PHI arg location.  */\n };\n typedef struct _edge_var_map edge_var_map;\n \n@@ -614,7 +615,7 @@ DEF_VEC_ALLOC_O(edge_var_map, heap);\n typedef VEC(edge_var_map, heap) *edge_var_map_vector;\n \n extern void init_tree_ssa (struct function *);\n-extern void redirect_edge_var_map_add (edge, tree, tree);\n+extern void redirect_edge_var_map_add (edge, tree, tree, source_location);\n extern void redirect_edge_var_map_clear (edge);\n extern void redirect_edge_var_map_dup (edge, edge);\n extern edge_var_map_vector redirect_edge_var_map_vector (edge);"}, {"sha": "f79ba75808816aaf09cb1f7c2cc855d0aa686920", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5045c967e137546faaf24cac2d9f103533775cc/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5045c967e137546faaf24cac2d9f103533775cc/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=f5045c967e137546faaf24cac2d9f103533775cc", "patch": "@@ -1828,7 +1828,8 @@ copy_phis_for_bb (basic_block bb, copy_body_data *id)\n \t\t  new_arg = force_gimple_operand (new_arg, &stmts, true, NULL);\n \t\t  gsi_insert_seq_on_edge_immediate (new_edge, stmts);\n \t\t}\n-\t      add_phi_arg (new_phi, new_arg, new_edge);\n+\t      add_phi_arg (new_phi, new_arg, new_edge, \n+\t\t\t   gimple_phi_arg_location_from_edge (phi, old_edge));\n \t    }\n \t}\n     }"}, {"sha": "bdec08063e49ae9fb203f119734e194e65fe648f", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 32, "deletions": 6, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5045c967e137546faaf24cac2d9f103533775cc/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5045c967e137546faaf24cac2d9f103533775cc/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=f5045c967e137546faaf24cac2d9f103533775cc", "patch": "@@ -1114,7 +1114,7 @@ insert_phi_nodes_for (tree var, bitmap phi_insertion_points, bool update_p)\n \t     renamer will use the symbol on the LHS to get its\n \t     reaching definition.  */\n \t  FOR_EACH_EDGE (e, ei, bb->preds)\n-\t    add_phi_arg (phi, var, e);\n+\t    add_phi_arg (phi, var, e, UNKNOWN_LOCATION);\n \t}\n       else\n \t{\n@@ -1320,9 +1320,12 @@ rewrite_add_phi_arguments (basic_block bb)\n \t   gsi_next (&gsi))\n \t{\n \t  tree currdef;\n+\t  gimple stmt;\n+\n \t  phi = gsi_stmt (gsi);\n \t  currdef = get_reaching_def (SSA_NAME_VAR (gimple_phi_result (phi)));\n-\t  add_phi_arg (phi, currdef, e);\n+\t  stmt = SSA_NAME_DEF_STMT (currdef);\n+\t  add_phi_arg (phi, currdef, e, gimple_location (stmt));\n \t}\n     }\n }\n@@ -1857,7 +1860,7 @@ rewrite_update_phi_arguments (basic_block bb)\n       phis = VEC_index (gimple_vec, phis_to_rewrite, e->dest->index);\n       for (i = 0; VEC_iterate (gimple, phis, i, phi); i++)\n \t{\n-\t  tree arg, lhs_sym;\n+\t  tree arg, lhs_sym, reaching_def = NULL;\n \t  use_operand_p arg_p;\n \n   \t  gcc_assert (rewrite_uses_p (phi));\n@@ -1875,18 +1878,41 @@ rewrite_update_phi_arguments (basic_block bb)\n \t      /* When updating a PHI node for a recently introduced\n \t\t symbol we may find NULL arguments.  That's why we\n \t\t take the symbol from the LHS of the PHI node.  */\n-\t      SET_USE (arg_p, get_reaching_def (lhs_sym));\n+\t      reaching_def = get_reaching_def (lhs_sym);\n+\n \t    }\n \t  else\n \t    {\n \t      tree sym = DECL_P (arg) ? arg : SSA_NAME_VAR (arg);\n \n \t      if (symbol_marked_for_renaming (sym))\n-\t\tSET_USE (arg_p, get_reaching_def (sym));\n+\t\treaching_def = get_reaching_def (sym);\n \t      else if (is_old_name (arg))\n-\t\tSET_USE (arg_p, get_reaching_def (arg));\n+\t\treaching_def = get_reaching_def (arg);\n+\t    }\n+\n+          /* Update the argument if there is a reaching def.  */\n+\t  if (reaching_def)\n+\t    {\n+\t      gimple stmt;\n+\t      source_location locus;\n+\t      int arg_i = PHI_ARG_INDEX_FROM_USE (arg_p);\n+\n+\t      SET_USE (arg_p, reaching_def);\n+\t      stmt = SSA_NAME_DEF_STMT (reaching_def);\n+\n+\t      /* Single element PHI nodes  behave like copies, so get the \n+\t\t location from the phi argument.  */\n+\t      if (gimple_code (stmt) == GIMPLE_PHI && \n+\t\t  gimple_phi_num_args (stmt) == 1)\n+\t\tlocus = gimple_phi_arg_location (stmt, 0);\n+\t      else\n+\t\tlocus = gimple_location (stmt);\n+\n+\t      gimple_phi_arg_set_location (phi, arg_i, locus);\n \t    }\n \n+\n \t  if (e->flags & EDGE_ABNORMAL)\n \t    SSA_NAME_OCCURS_IN_ABNORMAL_PHI (USE_FROM_PTR (arg_p)) = 1;\n \t}"}, {"sha": "b9b6ea3cd43bbd6291f87f2d58e1a6db01da2b84", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5045c967e137546faaf24cac2d9f103533775cc/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5045c967e137546faaf24cac2d9f103533775cc/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=f5045c967e137546faaf24cac2d9f103533775cc", "patch": "@@ -97,17 +97,20 @@ update_phis_for_loop_copy (struct loop *orig_loop, struct loop *new_loop)\n        gsi_next (&si_new), gsi_next (&si_orig))\n     {\n       tree def;\n+      source_location locus;\n       gimple phi_new = gsi_stmt (si_new);\n       gimple phi_orig = gsi_stmt (si_orig);\n \n       /* Add the first phi argument for the phi in NEW_LOOP (the one\n \t associated with the entry of NEW_LOOP)  */\n       def = PHI_ARG_DEF_FROM_EDGE (phi_orig, orig_entry_e);\n-      add_phi_arg (phi_new, def, new_loop_entry_e);\n+      locus = gimple_phi_arg_location_from_edge (phi_orig, orig_entry_e);\n+      add_phi_arg (phi_new, def, new_loop_entry_e, locus);\n \n       /* Add the second phi argument for the phi in NEW_LOOP (the one\n \t associated with the latch of NEW_LOOP)  */\n       def = PHI_ARG_DEF_FROM_EDGE (phi_orig, orig_loop_latch);\n+      locus = gimple_phi_arg_location_from_edge (phi_orig, orig_loop_latch);\n \n       if (TREE_CODE (def) == SSA_NAME)\n \t{\n@@ -122,7 +125,7 @@ update_phis_for_loop_copy (struct loop *orig_loop, struct loop *new_loop)\n \t/* Could be an integer.  */\n \tnew_ssa_name = def;\n \n-      add_phi_arg (phi_new, new_ssa_name, loop_latch_edge (new_loop));\n+      add_phi_arg (phi_new, new_ssa_name, loop_latch_edge (new_loop), locus);\n     }\n }\n "}, {"sha": "696c7259eedd752f3ee6d30dc147f4928ba7cb73", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 74, "deletions": 19, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5045c967e137546faaf24cac2d9f103533775cc/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5045c967e137546faaf24cac2d9f103533775cc/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=f5045c967e137546faaf24cac2d9f103533775cc", "patch": "@@ -36,6 +36,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ssaexpand.h\"\n \n \n+DEF_VEC_I(source_location);\n+DEF_VEC_ALLOC_I(source_location,heap);\n+\n /* Used to hold all the components required to do SSA PHI elimination.\n    The node and pred/succ list is a simple linear list of nodes and\n    edges represented as pairs of nodes.\n@@ -67,6 +70,9 @@ typedef struct _elim_graph {\n   /*  The predecessor and successor edge list.  */\n   VEC(int,heap) *edge_list;\n \n+  /* Source locus on each edge */\n+  VEC(source_location,heap) *edge_locus;\n+\n   /* Visited vector.  */\n   sbitmap visited;\n \n@@ -82,6 +88,9 @@ typedef struct _elim_graph {\n   /* List of constant copies to emit.  These are pushed on in pairs.  */\n   VEC(int,heap) *const_dests;\n   VEC(tree,heap) *const_copies;\n+\n+  /* Source locations for any constant copies.  */\n+  VEC(source_location,heap) *copy_locus;\n } *elim_graph;\n \n \n@@ -150,7 +159,7 @@ emit_partition_copy (rtx dest, rtx src, int unsignedsrcp)\n /* Insert a copy instruction from partition SRC to DEST onto edge E.  */\n \n static void\n-insert_partition_copy_on_edge (edge e, int dest, int src)\n+insert_partition_copy_on_edge (edge e, int dest, int src, source_location locus)\n {\n   rtx seq;\n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -167,6 +176,9 @@ insert_partition_copy_on_edge (edge e, int dest, int src)\n   gcc_assert (SA.partition_to_pseudo[src]);\n \n   set_location_for_edge (e);\n+  /* If a locus is provided, override the default.  */\n+  if (locus)\n+    set_curr_insn_source_location (locus);\n \n   seq = emit_partition_copy (SA.partition_to_pseudo[dest],\n \t\t\t     SA.partition_to_pseudo[src],\n@@ -180,7 +192,7 @@ insert_partition_copy_on_edge (edge e, int dest, int src)\n    onto edge E.  */\n \n static void\n-insert_value_copy_on_edge (edge e, int dest, tree src)\n+insert_value_copy_on_edge (edge e, int dest, tree src, source_location locus)\n {\n   rtx seq, x;\n   enum machine_mode mode;\n@@ -197,6 +209,9 @@ insert_value_copy_on_edge (edge e, int dest, tree src)\n   gcc_assert (SA.partition_to_pseudo[dest]);\n \n   set_location_for_edge (e);\n+  /* If a locus is provided, override the default.  */\n+  if (locus)\n+    set_curr_insn_source_location (locus);\n \n   start_sequence ();\n   mode = GET_MODE (SA.partition_to_pseudo[dest]);\n@@ -219,7 +234,8 @@ insert_value_copy_on_edge (edge e, int dest, tree src)\n    onto edge E.  */\n \n static void\n-insert_rtx_to_part_on_edge (edge e, int dest, rtx src, int unsignedsrcp)\n+insert_rtx_to_part_on_edge (edge e, int dest, rtx src, int unsignedsrcp,\n+\t\t\t    source_location locus)\n {\n   rtx seq;\n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -233,7 +249,11 @@ insert_rtx_to_part_on_edge (edge e, int dest, rtx src, int unsignedsrcp)\n     }\n \n   gcc_assert (SA.partition_to_pseudo[dest]);\n+\n   set_location_for_edge (e);\n+  /* If a locus is provided, override the default.  */\n+  if (locus)\n+    set_curr_insn_source_location (locus);\n \n   seq = emit_partition_copy (SA.partition_to_pseudo[dest],\n \t\t\t     src,\n@@ -246,7 +266,7 @@ insert_rtx_to_part_on_edge (edge e, int dest, rtx src, int unsignedsrcp)\n    onto edge E.  */\n \n static void\n-insert_part_to_rtx_on_edge (edge e, rtx dest, int src)\n+insert_part_to_rtx_on_edge (edge e, rtx dest, int src, source_location locus)\n {\n   rtx seq;\n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -260,7 +280,11 @@ insert_part_to_rtx_on_edge (edge e, rtx dest, int src)\n     }\n \n   gcc_assert (SA.partition_to_pseudo[src]);\n+\n   set_location_for_edge (e);\n+  /* If a locus is provided, override the default.  */\n+  if (locus)\n+    set_curr_insn_source_location (locus);\n \n   seq = emit_partition_copy (dest,\n \t\t\t     SA.partition_to_pseudo[src],\n@@ -282,7 +306,9 @@ new_elim_graph (int size)\n   g->nodes = VEC_alloc (int, heap, 30);\n   g->const_dests = VEC_alloc (int, heap, 20);\n   g->const_copies = VEC_alloc (tree, heap, 20);\n+  g->copy_locus = VEC_alloc (source_location, heap, 10);\n   g->edge_list = VEC_alloc (int, heap, 20);\n+  g->edge_locus = VEC_alloc (source_location, heap, 10);\n   g->stack = VEC_alloc (int, heap, 30);\n   \n   g->visited = sbitmap_alloc (size);\n@@ -298,6 +324,7 @@ clear_elim_graph (elim_graph g)\n {\n   VEC_truncate (int, g->nodes, 0);\n   VEC_truncate (int, g->edge_list, 0);\n+  VEC_truncate (source_location, g->edge_locus, 0);\n }\n \n \n@@ -312,6 +339,9 @@ delete_elim_graph (elim_graph g)\n   VEC_free (tree, heap, g->const_copies);\n   VEC_free (int, heap, g->const_dests);\n   VEC_free (int, heap, g->nodes);\n+  VEC_free (source_location, heap, g->copy_locus);\n+  VEC_free (source_location, heap, g->edge_locus);\n+\n   free (g);\n }\n \n@@ -343,18 +373,19 @@ elim_graph_add_node (elim_graph g, int node)\n /* Add the edge PRED->SUCC to graph G.  */\n \n static inline void\n-elim_graph_add_edge (elim_graph g, int pred, int succ)\n+elim_graph_add_edge (elim_graph g, int pred, int succ, source_location locus)\n {\n   VEC_safe_push (int, heap, g->edge_list, pred);\n   VEC_safe_push (int, heap, g->edge_list, succ);\n+  VEC_safe_push (source_location, heap, g->edge_locus, locus);\n }\n \n \n /* Remove an edge from graph G for which NODE is the predecessor, and\n    return the successor node.  -1 is returned if there is no such edge.  */\n \n static inline int\n-elim_graph_remove_succ_edge (elim_graph g, int node)\n+elim_graph_remove_succ_edge (elim_graph g, int node, source_location *locus)\n {\n   int y;\n   unsigned x;\n@@ -364,8 +395,11 @@ elim_graph_remove_succ_edge (elim_graph g, int node)\n         VEC_replace (int, g->edge_list, x, -1);\n \ty = VEC_index (int, g->edge_list, x + 1);\n \tVEC_replace (int, g->edge_list, x + 1, -1);\n+\t*locus = VEC_index (source_location, g->edge_locus, x / 2);\n+\tVEC_replace (source_location, g->edge_locus, x / 2, UNKNOWN_LOCATION);\n \treturn y;\n       }\n+  *locus = UNKNOWN_LOCATION;\n   return -1;\n }\n \n@@ -374,7 +408,7 @@ elim_graph_remove_succ_edge (elim_graph g, int node)\n    edge list.  VAR will hold the partition number found.  CODE is the\n    code fragment executed for every node found.  */\n \n-#define FOR_EACH_ELIM_GRAPH_SUCC(GRAPH, NODE, VAR, CODE)\t\t\\\n+#define FOR_EACH_ELIM_GRAPH_SUCC(GRAPH, NODE, VAR, LOCUS, CODE)\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n   unsigned x_;\t\t\t\t\t\t\t\t\\\n   int y_;\t\t\t\t\t\t\t\t\\\n@@ -384,6 +418,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n       if (y_ != (NODE))\t\t\t\t\t\t\t\\\n         continue;\t\t\t\t\t\t\t\\\n       (VAR) = VEC_index (int, (GRAPH)->edge_list, x_ + 1);\t\t\\\n+      (LOCUS) = VEC_index (source_location, (GRAPH)->edge_locus, x_ / 2); \\\n       CODE;\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n } while (0)\n@@ -393,7 +428,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n    GRAPH.  VAR will hold the partition number found.  CODE is the\n    code fragment executed for every node found.  */\n \n-#define FOR_EACH_ELIM_GRAPH_PRED(GRAPH, NODE, VAR, CODE)\t\t\\\n+#define FOR_EACH_ELIM_GRAPH_PRED(GRAPH, NODE, VAR, LOCUS, CODE)\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n   unsigned x_;\t\t\t\t\t\t\t\t\\\n   int y_;\t\t\t\t\t\t\t\t\\\n@@ -403,6 +438,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n       if (y_ != (NODE))\t\t\t\t\t\t\t\\\n         continue;\t\t\t\t\t\t\t\\\n       (VAR) = VEC_index (int, (GRAPH)->edge_list, x_);\t\t\t\\\n+      (LOCUS) = VEC_index (source_location, (GRAPH)->edge_locus, x_ / 2); \\\n       CODE;\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n } while (0)\n@@ -432,13 +468,15 @@ eliminate_build (elim_graph g)\n   for (gsi = gsi_start_phis (g->e->dest); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n       gimple phi = gsi_stmt (gsi);\n+      source_location locus;\n \n       p0 = var_to_partition (g->map, gimple_phi_result (phi));\n       /* Ignore results which are not in partitions.  */\n       if (p0 == NO_PARTITION)\n \tcontinue;\n \n       Ti = PHI_ARG_DEF (phi, g->e->dest_idx);\n+      locus = gimple_phi_arg_location_from_edge (phi, g->e);\n \n       /* If this argument is a constant, or a SSA_NAME which is being\n \t left in SSA form, just queue a copy to be emitted on this\n@@ -451,6 +489,7 @@ eliminate_build (elim_graph g)\n \t     on this edge.  */\n \t  VEC_safe_push (int, heap, g->const_dests, p0);\n \t  VEC_safe_push (tree, heap, g->const_copies, Ti);\n+\t  VEC_safe_push (source_location, heap, g->copy_locus, locus);\n \t}\n       else\n         {\n@@ -459,7 +498,7 @@ eliminate_build (elim_graph g)\n \t    {\n \t      eliminate_name (g, p0);\n \t      eliminate_name (g, pi);\n-\t      elim_graph_add_edge (g, p0, pi);\n+\t      elim_graph_add_edge (g, p0, pi, locus);\n \t    }\n \t}\n     }\n@@ -472,8 +511,10 @@ static void\n elim_forward (elim_graph g, int T)\n {\n   int S;\n+  source_location locus;\n+\n   SET_BIT (g->visited, T);\n-  FOR_EACH_ELIM_GRAPH_SUCC (g, T, S,\n+  FOR_EACH_ELIM_GRAPH_SUCC (g, T, S, locus,\n     {\n       if (!TEST_BIT (g->visited, S))\n         elim_forward (g, S);\n@@ -488,7 +529,9 @@ static int\n elim_unvisited_predecessor (elim_graph g, int T)\n {\n   int P;\n-  FOR_EACH_ELIM_GRAPH_PRED (g, T, P, \n+  source_location locus;\n+\n+  FOR_EACH_ELIM_GRAPH_PRED (g, T, P, locus,\n     {\n       if (!TEST_BIT (g->visited, P))\n         return 1;\n@@ -502,13 +545,15 @@ static void\n elim_backward (elim_graph g, int T)\n {\n   int P;\n+  source_location locus;\n+\n   SET_BIT (g->visited, T);\n-  FOR_EACH_ELIM_GRAPH_PRED (g, T, P, \n+  FOR_EACH_ELIM_GRAPH_PRED (g, T, P, locus,\n     {\n       if (!TEST_BIT (g->visited, P))\n         {\n \t  elim_backward (g, P);\n-\t  insert_partition_copy_on_edge (g->e, P, T);\n+\t  insert_partition_copy_on_edge (g->e, P, T, locus);\n \t}\n     });\n }\n@@ -537,30 +582,31 @@ static void\n elim_create (elim_graph g, int T)\n {\n   int P, S;\n+  source_location locus;\n \n   if (elim_unvisited_predecessor (g, T))\n     {\n       tree var = partition_to_var (g->map, T);\n       rtx U = get_temp_reg (var);\n       int unsignedsrcp = TYPE_UNSIGNED (TREE_TYPE (var));\n \n-      insert_part_to_rtx_on_edge (g->e, U, T);\n-      FOR_EACH_ELIM_GRAPH_PRED (g, T, P, \n+      insert_part_to_rtx_on_edge (g->e, U, T, UNKNOWN_LOCATION);\n+      FOR_EACH_ELIM_GRAPH_PRED (g, T, P, locus,\n \t{\n \t  if (!TEST_BIT (g->visited, P))\n \t    {\n \t      elim_backward (g, P);\n-\t      insert_rtx_to_part_on_edge (g->e, P, U, unsignedsrcp);\n+\t      insert_rtx_to_part_on_edge (g->e, P, U, unsignedsrcp, locus);\n \t    }\n \t});\n     }\n   else\n     {\n-      S = elim_graph_remove_succ_edge (g, T);\n+      S = elim_graph_remove_succ_edge (g, T, &locus);\n       if (S != -1)\n \t{\n \t  SET_BIT (g->visited, T);\n-\t  insert_partition_copy_on_edge (g->e, T, S);\n+\t  insert_partition_copy_on_edge (g->e, T, S, locus);\n \t}\n     }\n }\n@@ -574,6 +620,7 @@ eliminate_phi (edge e, elim_graph g)\n   int x;\n \n   gcc_assert (VEC_length (tree, g->const_copies) == 0);\n+  gcc_assert (VEC_length (source_location, g->copy_locus) == 0);\n \n   /* Abnormal edges already have everything coalesced.  */\n   if (e->flags & EDGE_ABNORMAL)\n@@ -610,9 +657,12 @@ eliminate_phi (edge e, elim_graph g)\n     {\n       int dest;\n       tree src;\n+      source_location locus;\n+\n       src = VEC_pop (tree, g->const_copies);\n       dest = VEC_pop (int, g->const_dests);\n-      insert_value_copy_on_edge (e, dest, src);\n+      locus = VEC_pop (source_location, g->copy_locus);\n+      insert_value_copy_on_edge (e, dest, src, locus);\n     }\n }\n \n@@ -991,6 +1041,11 @@ insert_backedge_copies (void)\n \t\t  name = make_ssa_name (result_var, stmt);\n \t\t  gimple_assign_set_lhs (stmt, name);\n \n+\t\t  /* copy location if present.  */\n+\t\t  if (gimple_phi_arg_has_location (phi, i))\n+\t\t    gimple_set_location (stmt, \n+\t\t\t\t\t gimple_phi_arg_location (phi, i));\n+\n \t\t  /* Insert the new statement into the block and update\n \t\t     the PHI node.  */\n \t\t  if (last && stmt_ends_bb_p (last))"}, {"sha": "9acf0ff75f0db8f798e042837d5e53e075d6e388", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5045c967e137546faaf24cac2d9f103533775cc/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5045c967e137546faaf24cac2d9f103533775cc/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=f5045c967e137546faaf24cac2d9f103533775cc", "patch": "@@ -747,6 +747,7 @@ create_phi_for_local_result (void **slot, void *data)\n   gimple new_phi;\n   basic_block store_bb;\n   tree local_res;\n+  source_location locus;\n \n   /* STORE_BB is the block where the phi \n      should be stored.  It is the destination of the loop exit.  \n@@ -765,11 +766,12 @@ create_phi_for_local_result (void **slot, void *data)\n   local_res\n     = make_ssa_name (SSA_NAME_VAR (gimple_assign_lhs (reduc->reduc_stmt)),\n \t\t     NULL);\n+  locus = gimple_location (reduc->reduc_stmt);\n   new_phi = create_phi_node (local_res, store_bb);\n   SSA_NAME_DEF_STMT (local_res) = new_phi;\n-  add_phi_arg (new_phi, reduc->init, e);\n+  add_phi_arg (new_phi, reduc->init, e, locus);\n   add_phi_arg (new_phi, gimple_assign_lhs (reduc->reduc_stmt),\n-\t       FALLTHRU_EDGE (loop->latch));\n+\t       FALLTHRU_EDGE (loop->latch), locus);\n   reduc->new_phi = new_phi;\n \n   return 1;\n@@ -1219,7 +1221,7 @@ transform_to_exit_first_loop (struct loop *loop, htab_t reduction_list, tree nit\n \n       nphi = create_phi_node (res, orig_header);\n       SSA_NAME_DEF_STMT (res) = nphi;\n-      add_phi_arg (nphi, t, hpred);\n+      add_phi_arg (nphi, t, hpred, UNKNOWN_LOCATION);\n \n       if (res == control)\n \t{\n@@ -1370,14 +1372,20 @@ create_parallel_loop (struct loop *loop, tree loop_fn, tree data,\n   end = make_edge (loop->latch, ex_bb, EDGE_FALLTHRU);\n   for (gsi = gsi_start_phis (ex_bb); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n+      source_location locus;\n+      tree def;\n       phi = gsi_stmt (gsi);\n       res = PHI_RESULT (phi);\n       stmt = SSA_NAME_DEF_STMT (PHI_ARG_DEF_FROM_EDGE (phi, exit));\n-      add_phi_arg (phi,\n-\t\t   PHI_ARG_DEF_FROM_EDGE (stmt, loop_preheader_edge (loop)),\n-\t\t   guard);\n-      add_phi_arg (phi, PHI_ARG_DEF_FROM_EDGE (stmt, loop_latch_edge (loop)),\n-\t\t   end);\n+\n+      def = PHI_ARG_DEF_FROM_EDGE (stmt, loop_preheader_edge (loop));\n+      locus = gimple_phi_arg_location_from_edge (stmt, \n+\t\t\t\t\t\t loop_preheader_edge (loop));\n+      add_phi_arg (phi, def, guard, locus);\n+\n+      def = PHI_ARG_DEF_FROM_EDGE (stmt, loop_latch_edge (loop));\n+      locus = gimple_phi_arg_location_from_edge (stmt, loop_latch_edge (loop));\n+      add_phi_arg (phi, def, end, locus);\n     }\n   e = redirect_edge_and_branch (exit, nexit->dest);\n   PENDING_STMT (e) = NULL;"}, {"sha": "a48ae01fe8d433d128d7113c7762af72ba9b4556", "filename": "gcc/tree-phinodes.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5045c967e137546faaf24cac2d9f103533775cc/gcc%2Ftree-phinodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5045c967e137546faaf24cac2d9f103533775cc/gcc%2Ftree-phinodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-phinodes.c?ref=f5045c967e137546faaf24cac2d9f103533775cc", "patch": "@@ -231,6 +231,8 @@ make_phi_node (tree var, int len)\n   for (i = 0; i < capacity; i++)\n     {\n       use_operand_p  imm;\n+\n+      gimple_phi_arg_set_location (phi, i, UNKNOWN_LOCATION);\n       imm = gimple_phi_arg_imm_use_ptr (phi, i);\n       imm->use = gimple_phi_arg_def_ptr (phi, i);\n       imm->prev = NULL;\n@@ -299,6 +301,8 @@ resize_phi_node (gimple *phi, size_t len)\n   for (i = gimple_phi_num_args (new_phi); i < len; i++)\n     {\n       use_operand_p imm;\n+\n+      gimple_phi_arg_set_location (new_phi, i, UNKNOWN_LOCATION);\n       imm = gimple_phi_arg_imm_use_ptr (new_phi, i);\n       imm->use = gimple_phi_arg_def_ptr (new_phi, i);\n       imm->prev = NULL;\n@@ -384,7 +388,7 @@ create_phi_node (tree var, basic_block bb)\n    PHI points to the reallocated phi node when we return.  */\n \n void\n-add_phi_arg (gimple phi, tree def, edge e)\n+add_phi_arg (gimple phi, tree def, edge e, source_location locus)\n {\n   basic_block bb = e->dest;\n \n@@ -407,6 +411,7 @@ add_phi_arg (gimple phi, tree def, edge e)\n     }\n \n   SET_PHI_ARG_DEF (phi, e->dest_idx, def);\n+  gimple_phi_arg_set_location (phi, e->dest_idx, locus);\n }\n \n \n@@ -435,6 +440,9 @@ remove_phi_arg_num (gimple phi, int i)\n       /* Set use on new node, and link into last element's place.  */\n       *(new_p->use) = *(old_p->use);\n       relink_imm_use (new_p, old_p);\n+      /* Move the location as well.  */\n+      gimple_phi_arg_set_location (phi, i, \n+\t\t\t\t   gimple_phi_arg_location (phi, num_elem - 1));\n     }\n \n   /* Shrink the vector and return.  Note that we do not have to clear"}, {"sha": "0ce35f5de86a5918945173f07686142e6c623a3f", "filename": "gcc/tree-predcom.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5045c967e137546faaf24cac2d9f103533775cc/gcc%2Ftree-predcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5045c967e137546faaf24cac2d9f103533775cc/gcc%2Ftree-predcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-predcom.c?ref=f5045c967e137546faaf24cac2d9f103533775cc", "patch": "@@ -1512,8 +1512,8 @@ initialize_root_vars (struct loop *loop, chain_p chain, bitmap tmp_vars)\n \n       phi = create_phi_node (var, loop->header);\n       SSA_NAME_DEF_STMT (var) = phi;\n-      add_phi_arg (phi, init, entry);\n-      add_phi_arg (phi, next, latch);\n+      add_phi_arg (phi, init, entry, UNKNOWN_LOCATION);\n+      add_phi_arg (phi, next, latch, UNKNOWN_LOCATION);\n     }\n }\n \n@@ -1576,8 +1576,8 @@ initialize_root_vars_lm (struct loop *loop, dref root, bool written,\n       next = VEC_index (tree, *vars, 1);\n       phi = create_phi_node (var, loop->header);\n       SSA_NAME_DEF_STMT (var) = phi;\n-      add_phi_arg (phi, init, entry);\n-      add_phi_arg (phi, next, latch);\n+      add_phi_arg (phi, init, entry, UNKNOWN_LOCATION);\n+      add_phi_arg (phi, next, latch, UNKNOWN_LOCATION);\n     }\n   else\n     {"}, {"sha": "2eec3147886e6d65db5b26c4266d3b4a669e1a6a", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5045c967e137546faaf24cac2d9f103533775cc/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5045c967e137546faaf24cac2d9f103533775cc/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=f5045c967e137546faaf24cac2d9f103533775cc", "patch": "@@ -951,6 +951,7 @@ forward_edge_to_pdom (edge e, basic_block post_dom_bb)\n \t{\n \t  gimple phi = gsi_stmt (gsi);\n \t  tree op;\n+\t  source_location locus;\n \n \t  /* Dead PHI do not imply control dependency.  */\n           if (!gimple_plf (phi, STMT_NECESSARY)\n@@ -975,10 +976,16 @@ forward_edge_to_pdom (edge e, basic_block post_dom_bb)\n \t      continue;\n \t    }\n \t  if (!e2)\n-\t    op = gimple_phi_arg_def (phi, e->dest_idx == 0 ? 1 : 0);\n+\t    {\n+\t      op = gimple_phi_arg_def (phi, e->dest_idx == 0 ? 1 : 0);\n+\t      locus = gimple_phi_arg_location (phi, e->dest_idx == 0 ? 1 : 0);\n+\t    }\n \t  else\n-\t    op = gimple_phi_arg_def (phi, e2->dest_idx);\n-\t  add_phi_arg (phi, op, e);\n+\t    {\n+\t      op = gimple_phi_arg_def (phi, e2->dest_idx);\n+\t      locus = gimple_phi_arg_location (phi, e2->dest_idx);\n+\t    }\n+\t  add_phi_arg (phi, op, e, locus);\n \t  gcc_assert (e2 || degenerate_phi_p (phi));\n \t  gsi_next (&gsi);\n \t}"}, {"sha": "e43c0bc404a5479cfeb9209449fe94acff3ef75d", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5045c967e137546faaf24cac2d9f103533775cc/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5045c967e137546faaf24cac2d9f103533775cc/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=f5045c967e137546faaf24cac2d9f103533775cc", "patch": "@@ -125,8 +125,8 @@ create_iv (tree base, tree step, tree var, struct loop *loop,\n \n   stmt = create_phi_node (vb, loop->header);\n   SSA_NAME_DEF_STMT (vb) = stmt;\n-  add_phi_arg (stmt, initial, loop_preheader_edge (loop));\n-  add_phi_arg (stmt, va, loop_latch_edge (loop));\n+  add_phi_arg (stmt, initial, loop_preheader_edge (loop), UNKNOWN_LOCATION);\n+  add_phi_arg (stmt, va, loop_latch_edge (loop), UNKNOWN_LOCATION);\n }\n \n /* Add exit phis for the USE on EXIT.  */\n@@ -156,7 +156,7 @@ add_exit_phis_edge (basic_block exit, tree use)\n   create_new_def_for (gimple_phi_result (phi), phi,\n \t\t      gimple_phi_result_ptr (phi));\n   FOR_EACH_EDGE (e, ei, exit->preds)\n-    add_phi_arg (phi, use, e);\n+    add_phi_arg (phi, use, e, UNKNOWN_LOCATION);\n }\n \n /* Add exit phis for VAR that is used in LIVEIN.\n@@ -476,11 +476,13 @@ split_loop_exit_edge (edge exit)\n   tree new_name, name;\n   use_operand_p op_p;\n   gimple_stmt_iterator psi;\n+  source_location locus;\n \n   for (psi = gsi_start_phis (dest); !gsi_end_p (psi); gsi_next (&psi))\n     {\n       phi = gsi_stmt (psi);\n       op_p = PHI_ARG_DEF_PTR_FROM_EDGE (phi, single_succ_edge (bb));\n+      locus = gimple_phi_arg_location_from_edge (phi, single_succ_edge (bb));\n \n       name = USE_FROM_PTR (op_p);\n \n@@ -494,7 +496,7 @@ split_loop_exit_edge (edge exit)\n       new_name = duplicate_ssa_name (name, NULL);\n       new_phi = create_phi_node (new_name, bb);\n       SSA_NAME_DEF_STMT (new_name) = new_phi;\n-      add_phi_arg (new_phi, name, exit);\n+      add_phi_arg (new_phi, name, exit, locus);\n       SET_USE (op_p, new_name);\n     }\n \n@@ -1014,8 +1016,8 @@ tree_transform_and_unroll_loop (struct loop *loop, unsigned factor,\n       phi_rest = create_phi_node (new_init, rest);\n       SSA_NAME_DEF_STMT (new_init) = phi_rest;\n \n-      add_phi_arg (phi_rest, init, precond_edge);\n-      add_phi_arg (phi_rest, next, new_exit);\n+      add_phi_arg (phi_rest, init, precond_edge, UNKNOWN_LOCATION);\n+      add_phi_arg (phi_rest, next, new_exit, UNKNOWN_LOCATION);\n       SET_USE (op, new_init);\n     }\n "}, {"sha": "97847f4c8882fe9bd3fddc27db0a6892783a2618", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5045c967e137546faaf24cac2d9f103533775cc/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5045c967e137546faaf24cac2d9f103533775cc/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=f5045c967e137546faaf24cac2d9f103533775cc", "patch": "@@ -513,6 +513,8 @@ conditional_replacement (basic_block cond_bb, basic_block middle_bb,\n \n   if (!useless_type_conversion_p (TREE_TYPE (result), TREE_TYPE (new_var)))\n     {\n+      source_location locus_0, locus_1;\n+\n       new_var2 = create_tmp_var (TREE_TYPE (result), NULL);\n       add_referenced_var (new_var2);\n       new_stmt = gimple_build_assign_with_ops (CONVERT_EXPR, new_var2,\n@@ -521,6 +523,13 @@ conditional_replacement (basic_block cond_bb, basic_block middle_bb,\n       gimple_assign_set_lhs (new_stmt, new_var2);\n       gsi_insert_before (&gsi, new_stmt, GSI_SAME_STMT);\n       new_var = new_var2;\n+\n+      /* Set the locus to the first argument, unless is doesn't have one.  */\n+      locus_0 = gimple_phi_arg_location (phi, 0);\n+      locus_1 = gimple_phi_arg_location (phi, 1);\n+      if (locus_0 == UNKNOWN_LOCATION)\n+        locus_0 = locus_1;\n+      gimple_set_location (new_stmt, locus_0);\n     }\n \n   replace_phi_edge_with_variable (cond_bb, e1, phi, new_var);\n@@ -1177,13 +1186,15 @@ cond_store_replacement (basic_block middle_bb, basic_block join_bb,\n   tree lhs, rhs, name;\n   gimple newphi, new_stmt;\n   gimple_stmt_iterator gsi;\n+  source_location locus;\n   enum tree_code code;\n \n   /* Check if middle_bb contains of only one store.  */\n   if (!assign\n       || gimple_code (assign) != GIMPLE_ASSIGN)\n     return false;\n \n+  locus = gimple_location (assign);\n   lhs = gimple_assign_lhs (assign);\n   rhs = gimple_assign_rhs1 (assign);\n   if (!INDIRECT_REF_P (lhs))\n@@ -1224,15 +1235,16 @@ cond_store_replacement (basic_block middle_bb, basic_block join_bb,\n   new_stmt = gimple_build_assign (condstoretemp, lhs);\n   name = make_ssa_name (condstoretemp, new_stmt);\n   gimple_assign_set_lhs (new_stmt, name);\n+  gimple_set_location (new_stmt, locus);\n   mark_symbols_for_renaming (new_stmt);\n   gsi_insert_on_edge (e1, new_stmt);\n \n   /* 4) Create a PHI node at the join block, with one argument\n         holding the old RHS, and the other holding the temporary\n         where we stored the old memory contents.  */\n   newphi = create_phi_node (condstoretemp, join_bb);\n-  add_phi_arg (newphi, rhs, e0);\n-  add_phi_arg (newphi, name, e1);\n+  add_phi_arg (newphi, rhs, e0, locus);\n+  add_phi_arg (newphi, name, e1, locus);\n \n   lhs = unshare_expr (lhs);\n   new_stmt = gimple_build_assign (lhs, PHI_RESULT (newphi));"}, {"sha": "bac2303899f1e7847de2994f1a407a93087d0a14", "filename": "gcc/tree-ssa-phiprop.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5045c967e137546faaf24cac2d9f103533775cc/gcc%2Ftree-ssa-phiprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5045c967e137546faaf24cac2d9f103533775cc/gcc%2Ftree-ssa-phiprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiprop.c?ref=f5045c967e137546faaf24cac2d9f103533775cc", "patch": "@@ -159,14 +159,17 @@ phiprop_insert_phi (basic_block bb, gimple phi, gimple use_stmt,\n     {\n       tree old_arg, new_var;\n       gimple tmp;\n+      source_location locus;\n \n       old_arg = PHI_ARG_DEF_FROM_EDGE (phi, e);\n+      locus = gimple_phi_arg_location_from_edge (phi, e);\n       while (TREE_CODE (old_arg) == SSA_NAME\n \t     && (SSA_NAME_VERSION (old_arg) >= n\n \t         || phivn[SSA_NAME_VERSION (old_arg)].value == NULL_TREE))\n \t{\n \t  gimple def_stmt = SSA_NAME_DEF_STMT (old_arg);\n \t  old_arg = gimple_assign_rhs1 (def_stmt);\n+\t  locus = gimple_location (def_stmt);\n \t}\n \n       if (TREE_CODE (old_arg) == SSA_NAME)\n@@ -196,6 +199,7 @@ phiprop_insert_phi (basic_block bb, gimple phi, gimple use_stmt,\n \t  add_referenced_var (new_var);\n \t  new_var = make_ssa_name (new_var, tmp);\n \t  gimple_assign_set_lhs (tmp, new_var);\n+\t  gimple_set_location (tmp, locus);\n \n \t  gsi_insert_on_edge (e, tmp);\n \t  update_stmt (tmp);\n@@ -209,7 +213,7 @@ phiprop_insert_phi (basic_block bb, gimple phi, gimple use_stmt,\n \t    }\n \t}\n \n-      add_phi_arg (new_phi, new_var, e);\n+      add_phi_arg (new_phi, new_var, e, locus);\n     }\n \n   update_stmt (new_phi);"}, {"sha": "237c250a5f0069aec225ce9a3b1c21834c098dad", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5045c967e137546faaf24cac2d9f103533775cc/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5045c967e137546faaf24cac2d9f103533775cc/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=f5045c967e137546faaf24cac2d9f103533775cc", "patch": "@@ -3328,9 +3328,10 @@ insert_into_preds_of_block (basic_block block, unsigned int exprnum,\n       gcc_assert (get_expr_type (ae) == type\n \t\t  || useless_type_conversion_p (type, get_expr_type (ae)));\n       if (ae->kind == CONSTANT)\n-\tadd_phi_arg (phi, PRE_EXPR_CONSTANT (ae), pred);\n+\tadd_phi_arg (phi, PRE_EXPR_CONSTANT (ae), pred, UNKNOWN_LOCATION);\n       else\n-\tadd_phi_arg (phi, PRE_EXPR_NAME (avail[pred->src->index]), pred);\n+\tadd_phi_arg (phi, PRE_EXPR_NAME (avail[pred->src->index]), pred,\n+\t\t     UNKNOWN_LOCATION);\n     }\n \n   newphi = get_or_alloc_expr_for_name (gimple_phi_result (phi));"}, {"sha": "71a34957bdf0387e19a42a1ab00cc11eeadc7ba8", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5045c967e137546faaf24cac2d9f103533775cc/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5045c967e137546faaf24cac2d9f103533775cc/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=f5045c967e137546faaf24cac2d9f103533775cc", "patch": "@@ -325,9 +325,11 @@ create_edge_and_update_destination_phis (struct redirection_data *rd)\n   for (gsi = gsi_start_phis (e->dest); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n       gimple phi = gsi_stmt (gsi);\n-\n+      source_location locus;\n       int indx = rd->outgoing_edge->dest_idx;\n-      add_phi_arg (phi, gimple_phi_arg_def (phi, indx), e);\n+\n+      locus = gimple_phi_arg_location (phi, indx);\n+      add_phi_arg (phi, gimple_phi_arg_def (phi, indx), e, locus);\n     }\n }\n "}, {"sha": "e8033cd46caf5827259dc2cc7f2e214869e9acbe", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5045c967e137546faaf24cac2d9f103533775cc/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5045c967e137546faaf24cac2d9f103533775cc/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=f5045c967e137546faaf24cac2d9f103533775cc", "patch": "@@ -53,7 +53,7 @@ static struct pointer_map_t *edge_var_maps;\n /* Add a mapping with PHI RESULT and PHI DEF associated with edge E.  */\n \n void\n-redirect_edge_var_map_add (edge e, tree result, tree def)\n+redirect_edge_var_map_add (edge e, tree result, tree def, source_location locus)\n {\n   void **slot;\n   edge_var_map_vector old_head, head;\n@@ -71,6 +71,7 @@ redirect_edge_var_map_add (edge e, tree result, tree def)\n     }\n   new_node.def = def;\n   new_node.result = result;\n+  new_node.locus = locus;\n \n   VEC_safe_push (edge_var_map, heap, head, &new_node);\n   if (old_head != head)\n@@ -193,14 +194,16 @@ ssa_redirect_edge (edge e, basic_block dest)\n   for (gsi = gsi_start_phis (e->dest); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n       tree def;\n+      source_location locus ;\n \n       phi = gsi_stmt (gsi);\n       def = gimple_phi_arg_def (phi, e->dest_idx);\n+      locus = gimple_phi_arg_location (phi, e->dest_idx);\n \n       if (def == NULL_TREE)\n \tcontinue;\n \n-      redirect_edge_var_map_add (e, gimple_phi_result (phi), def);\n+      redirect_edge_var_map_add (e, gimple_phi_result (phi), def, locus);\n     }\n \n   e = redirect_edge_succ_nodup (e, dest);\n@@ -233,7 +236,7 @@ flush_pending_stmts (edge e)\n \n       phi = gsi_stmt (gsi);\n       def = redirect_edge_var_map_def (vm);\n-      add_phi_arg (phi, def, e);\n+      add_phi_arg (phi, def, e, redirect_edge_var_map_location (vm));\n     }\n \n   redirect_edge_var_map_clear (e);"}, {"sha": "1309e822fe2b426f327842bbade2c377e5617757", "filename": "gcc/tree-switch-conversion.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5045c967e137546faaf24cac2d9f103533775cc/gcc%2Ftree-switch-conversion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5045c967e137546faaf24cac2d9f103533775cc/gcc%2Ftree-switch-conversion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-switch-conversion.c?ref=f5045c967e137546faaf24cac2d9f103533775cc", "patch": "@@ -638,8 +638,8 @@ fix_phi_nodes (edge e1f, edge e2f, basic_block bbf)\n        !gsi_end_p (gsi); gsi_next (&gsi), i++)\n     {\n       gimple phi = gsi_stmt (gsi);\n-      add_phi_arg (phi, info.target_inbound_names[i], e1f);\n-      add_phi_arg (phi, info.target_outbound_names[i], e2f);\n+      add_phi_arg (phi, info.target_inbound_names[i], e1f, UNKNOWN_LOCATION);\n+      add_phi_arg (phi, info.target_outbound_names[i], e2f, UNKNOWN_LOCATION);\n     }\n \n }"}, {"sha": "efd6bc2c029702b770f1bb0c1c18155c8fa17cf8", "filename": "gcc/tree-tailcall.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5045c967e137546faaf24cac2d9f103533775cc/gcc%2Ftree-tailcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5045c967e137546faaf24cac2d9f103533775cc/gcc%2Ftree-tailcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-tailcall.c?ref=f5045c967e137546faaf24cac2d9f103533775cc", "patch": "@@ -548,7 +548,7 @@ add_successor_phi_arg (edge e, tree var, tree phi_arg)\n       break;\n \n   gcc_assert (!gsi_end_p (gsi));\n-  add_phi_arg (gsi_stmt (gsi), phi_arg, e);\n+  add_phi_arg (gsi_stmt (gsi), phi_arg, e, UNKNOWN_LOCATION);\n }\n \n /* Creates a GIMPLE statement which computes the operation specified by\n@@ -773,7 +773,7 @@ eliminate_tail_call (struct tailcall *t)\n       phi = gsi_stmt (gsi);\n       gcc_assert (param == SSA_NAME_VAR (PHI_RESULT (phi)));\n \n-      add_phi_arg (phi, arg, e);\n+      add_phi_arg (phi, arg, e, gimple_location (stmt));\n       gsi_next (&gsi);\n     }\n \n@@ -870,7 +870,8 @@ create_tailcall_accumulator (const char *label, basic_block bb, tree init)\n   add_referenced_var (tmp);\n   phi = create_phi_node (tmp, bb);\n   /* RET_TYPE can be a float when -ffast-maths is enabled.  */\n-  add_phi_arg (phi, fold_convert (ret_type, init), single_pred_edge (bb));\n+  add_phi_arg (phi, fold_convert (ret_type, init), single_pred_edge (bb),\n+\t       UNKNOWN_LOCATION);\n   return PHI_RESULT (phi);\n }\n  \n@@ -933,7 +934,8 @@ tree_optimize_tail_calls_1 (bool opt_tailcalls)\n \t\tset_default_def (param, new_name);\n \t\tphi = create_phi_node (name, first);\n \t\tSSA_NAME_DEF_STMT (name) = phi;\n-\t\tadd_phi_arg (phi, new_name, single_pred_edge (first));\n+\t\tadd_phi_arg (phi, new_name, single_pred_edge (first), \n+\t\t\t     EXPR_LOCATION (param));\n \t      }\n \t  phis_constructed = true;\n \t}"}, {"sha": "facde06969e4db701ab9b0f7e036ffe13589d97b", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5045c967e137546faaf24cac2d9f103533775cc/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5045c967e137546faaf24cac2d9f103533775cc/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=f5045c967e137546faaf24cac2d9f103533775cc", "patch": "@@ -3049,7 +3049,7 @@ vect_setup_realignment (gimple stmt, gimple_stmt_iterator *gsi,\n   msq = make_ssa_name (vec_dest, NULL);\n   phi_stmt = create_phi_node (msq, containing_loop->header);\n   SSA_NAME_DEF_STMT (msq) = phi_stmt;\n-  add_phi_arg (phi_stmt, msq_init, pe);\n+  add_phi_arg (phi_stmt, msq_init, pe, UNKNOWN_LOCATION);\n \n   return msq;\n }"}, {"sha": "c0b15cd98a548662fb3432e8195a022c4be2501c", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 30, "deletions": 14, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5045c967e137546faaf24cac2d9f103533775cc/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5045c967e137546faaf24cac2d9f103533775cc/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=f5045c967e137546faaf24cac2d9f103533775cc", "patch": "@@ -169,15 +169,18 @@ slpeel_update_phis_for_duplicate_loop (struct loop *orig_loop,\n        !gsi_end_p (gsi_new) && !gsi_end_p (gsi_orig);\n        gsi_next (&gsi_new), gsi_next (&gsi_orig))\n     {\n+      source_location locus;\n       phi_new = gsi_stmt (gsi_new);\n       phi_orig = gsi_stmt (gsi_orig);\n \n       /* step 1.  */\n       def = PHI_ARG_DEF_FROM_EDGE (phi_orig, entry_arg_e);\n-      add_phi_arg (phi_new, def, new_loop_entry_e);\n+      locus = gimple_phi_arg_location_from_edge (phi_orig, entry_arg_e);\n+      add_phi_arg (phi_new, def, new_loop_entry_e, locus);\n \n       /* step 2.  */\n       def = PHI_ARG_DEF_FROM_EDGE (phi_orig, orig_loop_latch);\n+      locus = gimple_phi_arg_location_from_edge (phi_orig, orig_loop_latch);\n       if (TREE_CODE (def) != SSA_NAME)\n         continue;\n \n@@ -190,7 +193,7 @@ slpeel_update_phis_for_duplicate_loop (struct loop *orig_loop,\n \t}\n \n       /* An ordinary ssa name defined in the loop.  */\n-      add_phi_arg (phi_new, new_ssa_name, loop_latch_edge (new_loop));\n+      add_phi_arg (phi_new, new_ssa_name, loop_latch_edge (new_loop), locus);\n \n       /* step 3 (case 1).  */\n       if (!after)\n@@ -383,6 +386,7 @@ slpeel_update_phi_nodes_for_guard1 (edge guard_edge, struct loop *loop,\n        !gsi_end_p (gsi_orig) && !gsi_end_p (gsi_update);\n        gsi_next (&gsi_orig), gsi_next (&gsi_update))\n     {\n+      source_location loop_locus, guard_locus;;\n       orig_phi = gsi_stmt (gsi_orig);\n       update_phi = gsi_stmt (gsi_update);\n \n@@ -395,10 +399,16 @@ slpeel_update_phi_nodes_for_guard1 (edge guard_edge, struct loop *loop,\n       /* 1.2. NEW_MERGE_BB has two incoming edges: GUARD_EDGE and the exit-edge\n             of LOOP. Set the two phi args in NEW_PHI for these edges:  */\n       loop_arg = PHI_ARG_DEF_FROM_EDGE (orig_phi, EDGE_SUCC (loop->latch, 0));\n+      loop_locus = gimple_phi_arg_location_from_edge (orig_phi, \n+\t\t\t\t\t\t      EDGE_SUCC (loop->latch, \n+\t\t\t\t\t\t\t\t 0));\n       guard_arg = PHI_ARG_DEF_FROM_EDGE (orig_phi, loop_preheader_edge (loop));\n+      guard_locus \n+\t= gimple_phi_arg_location_from_edge (orig_phi, \n+\t\t\t\t\t     loop_preheader_edge (loop));\n \n-      add_phi_arg (new_phi, loop_arg, new_exit_e);\n-      add_phi_arg (new_phi, guard_arg, guard_edge);\n+      add_phi_arg (new_phi, loop_arg, new_exit_e, loop_locus);\n+      add_phi_arg (new_phi, guard_arg, guard_edge, guard_locus);\n \n       /* 1.3. Update phi in successor block.  */\n       gcc_assert (PHI_ARG_DEF_FROM_EDGE (update_phi, e) == loop_arg\n@@ -417,7 +427,7 @@ slpeel_update_phi_nodes_for_guard1 (edge guard_edge, struct loop *loop,\n                                  *new_exit_bb);\n \n       /* 2.2. NEW_EXIT_BB has one incoming edge: the exit-edge of the loop.  */\n-      add_phi_arg (new_phi, loop_arg, single_exit (loop));\n+      add_phi_arg (new_phi, loop_arg, single_exit (loop), loop_locus);\n \n       /* 2.3. Update phi in successor of NEW_EXIT_BB:  */\n       gcc_assert (PHI_ARG_DEF_FROM_EDGE (update_phi2, new_exit_e) == loop_arg);\n@@ -545,8 +555,8 @@ slpeel_update_phi_nodes_for_guard2 (edge guard_edge, struct loop *loop,\n       if (new_name2)\n         guard_arg = new_name2;\n   \n-      add_phi_arg (new_phi, loop_arg, new_exit_e);\n-      add_phi_arg (new_phi, guard_arg, guard_edge);\n+      add_phi_arg (new_phi, loop_arg, new_exit_e, UNKNOWN_LOCATION);\n+      add_phi_arg (new_phi, guard_arg, guard_edge, UNKNOWN_LOCATION);\n \n       /* 1.3. Update phi in successor block.  */\n       gcc_assert (PHI_ARG_DEF_FROM_EDGE (update_phi, e) == orig_def);\n@@ -561,7 +571,7 @@ slpeel_update_phi_nodes_for_guard2 (edge guard_edge, struct loop *loop,\n                                  *new_exit_bb);\n \n       /* 2.2. NEW_EXIT_BB has one incoming edge: the exit-edge of the loop.  */\n-      add_phi_arg (new_phi, loop_arg, single_exit (loop));\n+      add_phi_arg (new_phi, loop_arg, single_exit (loop), UNKNOWN_LOCATION);\n \n       /* 2.3. Update phi in successor of NEW_EXIT_BB:  */\n       gcc_assert (PHI_ARG_DEF_FROM_EDGE (update_phi2, new_exit_e) == loop_arg);\n@@ -596,7 +606,8 @@ slpeel_update_phi_nodes_for_guard2 (edge guard_edge, struct loop *loop,\n \n       /* 3.3. GUARD_BB has one incoming edge:  */\n       gcc_assert (EDGE_COUNT (guard_edge->src->preds) == 1);\n-      add_phi_arg (new_phi, arg, EDGE_PRED (guard_edge->src, 0));\n+      add_phi_arg (new_phi, arg, EDGE_PRED (guard_edge->src, 0), \n+\t\t   UNKNOWN_LOCATION);\n \n       /* 3.4. Update phi in successor of GUARD_BB:  */\n       gcc_assert (PHI_ARG_DEF_FROM_EDGE (update_phi2, guard_edge)\n@@ -720,13 +731,15 @@ slpeel_tree_duplicate_loop_to_edge_cfg (struct loop *loop, edge e)\n       if (phi_arg)\n \t{\n \t  edge new_loop_exit_edge;\n+\t  source_location locus;\n \n+\t  locus = gimple_phi_arg_location_from_edge (phi, single_exit (loop));\n \t  if (EDGE_SUCC (new_loop->header, 0)->dest == new_loop->latch)\n \t    new_loop_exit_edge = EDGE_SUCC (new_loop->header, 1);\n \t  else\n \t    new_loop_exit_edge = EDGE_SUCC (new_loop->header, 0);\n   \n-\t  add_phi_arg (phi, phi_arg, new_loop_exit_edge);\t\n+\t  add_phi_arg (phi, phi_arg, new_loop_exit_edge, locus);\t\n \t}\n     }    \n    \n@@ -764,7 +777,8 @@ slpeel_tree_duplicate_loop_to_edge_cfg (struct loop *loop, edge e)\n \t  phi = gsi_stmt (gsi);\n \t  phi_arg = PHI_ARG_DEF_FROM_EDGE (phi, entry_e);\n \t  if (phi_arg)\n-\t    add_phi_arg (phi, phi_arg, new_exit_e);\t\n+\t    add_phi_arg (phi, phi_arg, new_exit_e,\n+\t\t\t gimple_phi_arg_location_from_edge (phi, entry_e));\t\n \t}    \n \n       redirect_edge_and_branch_force (entry_e, new_loop->header);\n@@ -954,8 +968,9 @@ set_prologue_iterations (basic_block bb_before_first_loop,\n     gsi_insert_seq_after (&gsi, stmts, GSI_NEW_STMT);\n \n   newphi = create_phi_node (var, bb_before_first_loop);\n-  add_phi_arg (newphi, prologue_after_cost_adjust_name, e_fallthru);\n-  add_phi_arg (newphi, first_niters, e_false);\n+  add_phi_arg (newphi, prologue_after_cost_adjust_name, e_fallthru, \n+\t       UNKNOWN_LOCATION);\n+  add_phi_arg (newphi, first_niters, e_false, UNKNOWN_LOCATION);\n \n   first_niters = PHI_RESULT (newphi);\n }\n@@ -2383,7 +2398,8 @@ vect_loop_versioning (loop_vec_info loop_vinfo, bool do_versioning,\n       new_phi = create_phi_node (SSA_NAME_VAR (PHI_RESULT (orig_phi)),\n \t\t\t\t  new_exit_bb);\n       arg = PHI_ARG_DEF_FROM_EDGE (orig_phi, e);\n-      add_phi_arg (new_phi, arg, new_exit_e);\n+      add_phi_arg (new_phi, arg, new_exit_e, \n+\t\t   gimple_phi_arg_location_from_edge (orig_phi, e));\n       SET_PHI_ARG_DEF (orig_phi, e->dest_idx, PHI_RESULT (new_phi));\n     } \n "}, {"sha": "113dc0ff0e6bc20ef67bb8e7d7389e013b523fcd", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5045c967e137546faaf24cac2d9f103533775cc/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5045c967e137546faaf24cac2d9f103533775cc/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=f5045c967e137546faaf24cac2d9f103533775cc", "patch": "@@ -2524,8 +2524,9 @@ get_initial_def_for_induction (gimple iv_phi)\n                                                    NULL));\n \n   /* Set the arguments of the phi node:  */\n-  add_phi_arg (induction_phi, vec_init, pe);\n-  add_phi_arg (induction_phi, vec_def, loop_latch_edge (iv_loop));\n+  add_phi_arg (induction_phi, vec_init, pe, UNKNOWN_LOCATION);\n+  add_phi_arg (induction_phi, vec_def, loop_latch_edge (iv_loop), \n+\t       UNKNOWN_LOCATION);\n \n \n   /* In case that vectorization factor (VF) is bigger than the number\n@@ -2934,12 +2935,13 @@ vect_create_epilog_for_reduction (tree vect_def, gimple stmt,\n   for (j = 0; j < ncopies; j++)\n     {\n       /* 1.1 set the loop-entry arg of the reduction-phi:  */\n-      add_phi_arg (phi, vec_initial_def, loop_preheader_edge (loop));\n+      add_phi_arg (phi, vec_initial_def, loop_preheader_edge (loop), \n+\t\t   UNKNOWN_LOCATION);\n \n       /* 1.2 set the loop-latch arg for the reduction-phi:  */\n       if (j > 0)\n         def = vect_get_vec_def_for_stmt_copy (dt, def);\n-      add_phi_arg (phi, def, loop_latch_edge (loop));\n+      add_phi_arg (phi, def, loop_latch_edge (loop), UNKNOWN_LOCATION);\n \n       if (vect_print_dump_info (REPORT_DETAILS))\n \t{\n@@ -3350,9 +3352,9 @@ vect_create_epilog_for_reduction (tree vect_def, gimple stmt,\n                \n               /* Update phi node arguments with vs0 and vs2.  */\n               add_phi_arg (vect_phi, vect_phi_init, \n-                           loop_preheader_edge (outer_loop));\n+                           loop_preheader_edge (outer_loop), UNKNOWN_LOCATION);\n               add_phi_arg (vect_phi, PHI_RESULT (epilog_stmt), \n-                           loop_latch_edge (outer_loop));\n+                           loop_latch_edge (outer_loop), UNKNOWN_LOCATION);\n               if (vect_print_dump_info (REPORT_DETAILS))\n                 {\n                   fprintf (vect_dump, \"created double reduction phi node: \");"}, {"sha": "aacf768a4cf7f6035cdaf3437a69b05356275ef5", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5045c967e137546faaf24cac2d9f103533775cc/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5045c967e137546faaf24cac2d9f103533775cc/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=f5045c967e137546faaf24cac2d9f103533775cc", "patch": "@@ -3639,7 +3639,8 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t\t{\n \t\t  gcc_assert (phi);\n \t\t  if (i == vec_num - 1 && j == ncopies - 1)\n-\t\t    add_phi_arg (phi, lsq, loop_latch_edge (containing_loop));\n+\t\t    add_phi_arg (phi, lsq, loop_latch_edge (containing_loop),\n+\t\t\t\t UNKNOWN_LOCATION);\n \t\t  msq = lsq;\n \t\t}\n \t    }"}, {"sha": "a1370fa5e55726367db6d78f4106e79cb6a755d4", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5045c967e137546faaf24cac2d9f103533775cc/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5045c967e137546faaf24cac2d9f103533775cc/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=f5045c967e137546faaf24cac2d9f103533775cc", "patch": "@@ -1888,6 +1888,7 @@ struct GTY(()) phi_arg_d {\n      pointer arithmetic with it.  See phi_arg_index_from_use.  */\n   struct ssa_use_operand_d imm_use;\n   tree def;\n+  location_t locus;\n };\n \n \f"}]}