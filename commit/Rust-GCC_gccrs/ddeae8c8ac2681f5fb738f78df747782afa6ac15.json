{"sha": "ddeae8c8ac2681f5fb738f78df747782afa6ac15", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGRlYWU4YzhhYzI2ODFmNWZiNzM4Zjc4ZGY3NDc3ODJhZmE2YWMxNQ==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2019-04-01T17:04:10Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2019-04-01T17:04:10Z"}, "message": "PR c/89685 - ICE on attribute copy with a compound expression\n\ngcc/c-family/ChangeLog:\n\n\tPR c/89685\n\t* c-attribs.c (handle_copy_attribute): Handle references and\n\tnon-constant expressions.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c/89685\n\t* gcc.dg/attr-copy-8.c: New test.\n\t* g++.dg/ext/attr-copy-2.C: New test.\n\nFrom-SVN: r270062", "tree": {"sha": "793b61eaa47bfc7ada1b66ad9c0e0e349f14c1ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/793b61eaa47bfc7ada1b66ad9c0e0e349f14c1ac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ddeae8c8ac2681f5fb738f78df747782afa6ac15", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddeae8c8ac2681f5fb738f78df747782afa6ac15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ddeae8c8ac2681f5fb738f78df747782afa6ac15", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddeae8c8ac2681f5fb738f78df747782afa6ac15/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8bad0ced9fad845ef61bb3e27c38d004e0ab6d0f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8bad0ced9fad845ef61bb3e27c38d004e0ab6d0f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8bad0ced9fad845ef61bb3e27c38d004e0ab6d0f"}], "stats": {"total": 262, "additions": 256, "deletions": 6}, "files": [{"sha": "cf73a1cad1cf31b966e4d17a3ea73d21b72be16a", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddeae8c8ac2681f5fb738f78df747782afa6ac15/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddeae8c8ac2681f5fb738f78df747782afa6ac15/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=ddeae8c8ac2681f5fb738f78df747782afa6ac15", "patch": "@@ -1,3 +1,9 @@\n+2019-04-01  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c/89685\n+\t* c-attribs.c (handle_copy_attribute): Handle references and\n+\tnon-constant expressions.\n+\n 2019-03-22  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/87481"}, {"sha": "d055a0897acd0be2b7cf5f91c2e24509344f369c", "filename": "gcc/c-family/c-attribs.c", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddeae8c8ac2681f5fb738f78df747782afa6ac15/gcc%2Fc-family%2Fc-attribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddeae8c8ac2681f5fb738f78df747782afa6ac15/gcc%2Fc-family%2Fc-attribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-attribs.c?ref=ddeae8c8ac2681f5fb738f78df747782afa6ac15", "patch": "@@ -2413,15 +2413,31 @@ handle_copy_attribute (tree *node, tree name, tree args,\n     }\n \n   /* Consider address-of expressions in the attribute argument\n-     as requests to copy from the referenced entity.  For constant\n-     expressions, consider those to be requests to copy from their\n-     type, such as in:\n+     as requests to copy from the referenced entity.  */\n+  if (TREE_CODE (ref) == ADDR_EXPR)\n+    ref = TREE_OPERAND (ref, 0);\n+\n+  do\n+    {\n+      /* Drill down into references to find the referenced decl.  */\n+      tree_code refcode = TREE_CODE (ref);\n+      if (refcode == ARRAY_REF\n+\t  || refcode == INDIRECT_REF)\n+\tref = TREE_OPERAND (ref, 0);\n+      else if (refcode == COMPONENT_REF)\n+\tref = TREE_OPERAND (ref, 1);\n+      else\n+\tbreak;\n+    } while (!DECL_P (ref));\n+\n+  /* For object pointer expressions, consider those to be requests\n+     to copy from their type, such as in:\n        struct __attribute__ (copy ((struct T *)0)) U { ... };\n      which copies type attributes from struct T to the declaration\n      of struct U.  */\n-  if (TREE_CODE (ref) == ADDR_EXPR)\n-    ref = TREE_OPERAND (ref, 0);\n-  else if (CONSTANT_CLASS_P (ref))\n+  if ((CONSTANT_CLASS_P (ref) || EXPR_P (ref))\n+      && POINTER_TYPE_P (TREE_TYPE (ref))\n+      && !FUNCTION_POINTER_TYPE_P (TREE_TYPE (ref)))\n     ref = TREE_TYPE (ref);\n \n   if (DECL_P (decl))"}, {"sha": "1c516a95185edc3d7a786c6aba91d886e1b31f69", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddeae8c8ac2681f5fb738f78df747782afa6ac15/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddeae8c8ac2681f5fb738f78df747782afa6ac15/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ddeae8c8ac2681f5fb738f78df747782afa6ac15", "patch": "@@ -1,3 +1,9 @@\n+2019-04-01  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c/89685\n+\t* gcc.dg/attr-copy-8.c: New test.\n+\t* g++.dg/ext/attr-copy-2.C: New test.\n+\n 2019-04-01  Andrey Belevantsev  <abel@ispras.ru>\n \n \tPR rtl-optimization/86928"}, {"sha": "7776959d9f6baf5da52c13c6de49dd269bdfd476", "filename": "gcc/testsuite/g++.dg/ext/attr-copy-2.C", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddeae8c8ac2681f5fb738f78df747782afa6ac15/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-copy-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddeae8c8ac2681f5fb738f78df747782afa6ac15/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-copy-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-copy-2.C?ref=ddeae8c8ac2681f5fb738f78df747782afa6ac15", "patch": "@@ -0,0 +1,124 @@\n+/* PR c/89685 - ICE on attribute copy with a compound expression\n+   { dg-do compile }\n+   { dg-options \"-Wall -Wno-unused-value -Wno-int-to-pointer-cast\" } */\n+\n+#if __cplusplus <= 199711L\n+#  define static_assert(expr) typedef char Assert [1 - !(expr) * 2]\n+#endif\n+\n+#define ATTR(...) __attribute__ ((__VA_ARGS__))\n+\n+typedef struct ATTR (packed) A { ATTR (packed) unsigned bf: 1; } A;\n+\n+typedef struct B\n+{\n+  struct A a;\n+  struct A *pa;\n+  struct A &ra;\n+} B;\n+\n+extern struct A a;\n+extern struct A *pa;\n+extern struct A &ra;\n+extern B b;\n+extern B ab[1];\n+extern B *pb;\n+extern B &rb;\n+\n+typedef struct C\n+{\n+  ATTR (copy ((struct A *)0)) short m_pa_0;\n+  ATTR (copy ((struct A *)(1, 0))) int m_pa_1_0;\n+  ATTR (copy ((struct A *)(0, 1))) long m_pa_0_1;\n+\n+  ATTR (copy (*(struct A *)0)) short m_xpa_0;\n+  ATTR (copy (*(struct A *)(1, 0))) int m_xpa_1_0;\n+  ATTR (copy (*(struct A *)(0, 1))) long m_xpa_0_1;\n+\n+  ATTR (copy (((struct A *)0)[0])) short m_arpa_0;\n+  ATTR (copy (((struct A *)(1, 0))[0])) int m_arpa_1_0;\n+  ATTR (copy (((struct A *)(0, 1))[0])) long m_arpa_0_1;\n+\n+  ATTR (copy (a)) short m_a;\n+  ATTR (copy (b.a)) int m_b_a;\n+  ATTR (copy (b.pa)) long m_b_pa;\n+  ATTR (copy (b.ra)) long m_b_ra;\n+\n+  ATTR (copy (&a)) short m_ara;\n+  ATTR (copy (&b.a)) int m_arb_a;\n+  ATTR (copy (*b.pa)) long m_xb_pa;\n+  ATTR (copy (b.pa[0])) long m_arb_pa;\n+\n+  ATTR (copy (*pa)) short m_xpa;\n+  ATTR (copy (pa[0])) short m_arpa;\n+\n+  ATTR (copy (ra)) short m_ra;\n+\n+  ATTR (copy (ab[0].a)) int m_arab_a;\n+  ATTR (copy (ab[1].pa)) long m_arab_pa;\n+  ATTR (copy (*ab[2].pa)) int m_xarab_pa;\n+  ATTR (copy (ab[3].pa->bf)) unsigned int m_arab_pa_bf: 1;\n+  ATTR (copy (ab[4].ra.bf)) unsigned int m_arab_ra_bf: 1;\n+\n+  ATTR (copy (pb->a)) int m_pb_a;\n+  ATTR (copy (pb->pa)) long m_pb_pa;\n+  ATTR (copy (*pb->pa)) int m_xpb_pa;\n+  ATTR (copy (pb->pa->bf)) unsigned int m_pb_pa_bf: 1;\n+  ATTR (copy (pb->ra.bf)) unsigned int m_pb_ra_bf: 1;\n+\n+  ATTR (copy (rb.a)) int m_rb_a;\n+  ATTR (copy (rb.pa)) long m_rb_pa;\n+  ATTR (copy (*rb.pa)) int m_xrb_pa;\n+  ATTR (copy (rb.pa->bf)) unsigned int m_rb_pa_bf: 1;\n+\n+  ATTR (aligned (4), copy ((struct A *)(0))) short m_a4_pa_0;\n+} C;\n+\n+\n+static_assert (__builtin_has_attribute (((C*)0)->m_pa_0, packed));\n+static_assert (__builtin_has_attribute (((C*)0)->m_pa_1_0, packed));\n+static_assert (__builtin_has_attribute (((C*)0)->m_pa_0_1, packed));\n+\n+static_assert (__builtin_has_attribute (((C*)0)->m_xpa_0, packed));\n+static_assert (__builtin_has_attribute (((C*)0)->m_xpa_1_0, packed));\n+static_assert (__builtin_has_attribute (((C*)0)->m_xpa_0_1, packed));\n+\n+static_assert (__builtin_has_attribute (((C*)0)->m_ra, packed));\n+\n+static_assert (__builtin_has_attribute (((C*)0)->m_arpa_0, packed));\n+static_assert (__builtin_has_attribute (((C*)0)->m_arpa_1_0, packed));\n+static_assert (__builtin_has_attribute (((C*)0)->m_arpa_0_1, packed));\n+\n+static_assert (__builtin_has_attribute (((C*)0)->m_a, packed));\n+static_assert (__builtin_has_attribute (((C*)0)->m_b_a, packed));\n+static_assert (__builtin_has_attribute (((C*)0)->m_b_pa, packed));\n+static_assert (__builtin_has_attribute (((C*)0)->m_b_ra, packed));\n+\n+static_assert (__builtin_has_attribute (((C*)0)->m_ara, packed));\n+static_assert (__builtin_has_attribute (((C*)0)->m_arb_a, packed));\n+static_assert (__builtin_has_attribute (((C*)0)->m_xb_pa, packed));\n+static_assert (__builtin_has_attribute (((C*)0)->m_arb_pa, packed));\n+\n+static_assert (__builtin_has_attribute (((C*)0)->m_xpa, packed));\n+static_assert (__builtin_has_attribute (((C*)0)->m_arpa, packed));\n+\n+static_assert (__builtin_has_attribute (((C*)0)->m_arab_a, packed));\n+static_assert (__builtin_has_attribute (((C*)0)->m_arab_pa, packed));\n+static_assert (__builtin_has_attribute (((C*)0)->m_xarab_pa, packed));\n+static_assert (__builtin_has_attribute (((C*)0)->m_arab_pa_bf, packed));\n+static_assert (__builtin_has_attribute (((C*)0)->m_arab_ra_bf, packed));\n+\n+static_assert (__builtin_has_attribute (((C*)0)->m_pb_a, packed));\n+static_assert (__builtin_has_attribute (((C*)0)->m_pb_pa, packed));\n+static_assert (__builtin_has_attribute (((C*)0)->m_pb_pa, packed));\n+static_assert (__builtin_has_attribute (((C*)0)->m_pb_pa_bf, packed));\n+static_assert (__builtin_has_attribute (((C*)0)->m_pb_ra_bf, packed));\n+\n+static_assert (__builtin_has_attribute (((C*)0)->m_rb_a, packed));\n+static_assert (__builtin_has_attribute (((C*)0)->m_rb_pa, packed));\n+static_assert (__builtin_has_attribute (((C*)0)->m_xrb_pa, packed));\n+static_assert (__builtin_has_attribute (((C*)0)->m_rb_pa_bf, packed));\n+\n+static_assert (__builtin_has_attribute (((C*)0)->m_a4_pa_0, packed));\n+static_assert (__builtin_has_attribute (((C*)0)->m_a4_pa_0, aligned));\n+static_assert (__alignof__ (((C*)0)->m_a4_pa_0) == 4);"}, {"sha": "c75d9e5c98c976889ec9f433a7bedf2cbe64e059", "filename": "gcc/testsuite/gcc.dg/attr-copy-8.c", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddeae8c8ac2681f5fb738f78df747782afa6ac15/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-copy-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddeae8c8ac2681f5fb738f78df747782afa6ac15/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-copy-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-copy-8.c?ref=ddeae8c8ac2681f5fb738f78df747782afa6ac15", "patch": "@@ -0,0 +1,98 @@\n+/* PR c/89685 - ICE on attribute copy with a compound expression\n+   { dg-do compile }\n+   { dg-options \"-Wall -Wno-unused-value -Wno-int-to-pointer-cast\" } */\n+\n+#define ATTR(...) __attribute__ ((__VA_ARGS__))\n+\n+typedef struct ATTR (packed) A { ATTR (packed) unsigned bf: 1; } A;\n+\n+typedef struct B\n+{\n+  struct A a;\n+  struct A *pa;\n+} B;\n+\n+extern struct A a;\n+extern struct A *pa;\n+extern B b;\n+extern B ab[1];\n+extern B *pb;\n+\n+typedef struct C\n+{\n+  ATTR (copy ((struct A *)0)) short m_pa_0;\n+  ATTR (copy ((struct A *)(1, 0))) int m_pa_1_0;\n+  ATTR (copy ((struct A *)(0, 1))) long m_pa_0_1;\n+\n+  ATTR (copy (*(struct A *)0)) short m_xpa_0;\n+  ATTR (copy (*(struct A *)(1, 0))) int m_xpa_1_0;\n+  ATTR (copy (*(struct A *)(0, 1))) long m_xpa_0_1;\n+\n+  ATTR (copy (((struct A *)0)[0])) short m_arpa_0;\n+  ATTR (copy (((struct A *)(1, 0))[0])) int m_arpa_1_0;\n+  ATTR (copy (((struct A *)(0, 1))[0])) long m_arpa_0_1;\n+\n+  /* Also exercise COMPONENT_REF, ARRAY_REF, and INDIRECT_REF.  */\n+  ATTR (copy (a)) short m_ra;\n+  ATTR (copy (b.a)) int m_rb_a;\n+  ATTR (copy (b.pa)) long m_rb_pa;\n+\n+  ATTR (copy (&a)) short m_ara;\n+  ATTR (copy (&b.a)) int m_arb_a;\n+  ATTR (copy (*b.pa)) long m_xb_pa;\n+  ATTR (copy (b.pa[0])) long m_arb_pa;\n+\n+  ATTR (copy (*pa)) short m_xpa;\n+  ATTR (copy (pa[0])) short m_arpa;\n+\n+  ATTR (copy (ab[0].a)) int m_arab_a;\n+  ATTR (copy (ab[1].pa)) long m_arab_pa;\n+  ATTR (copy (*ab[2].pa)) int m_xarab_pa;\n+  ATTR (copy (ab[3].pa->bf)) unsigned int m_arab_pa_bf: 1;\n+\n+  ATTR (copy (pb->a)) int m_pb_a;\n+  ATTR (copy (pb->pa)) long m_pb_pa;\n+  ATTR (copy (*pb->pa)) int m_xpb_pa;\n+  ATTR (copy (pb->pa->bf)) unsigned int m_pb_pa_bf: 1;\n+\n+  ATTR (aligned (4), copy ((struct A *)(0))) short m_a4_pa_0;\n+} C;\n+\n+\n+_Static_assert (__builtin_has_attribute (((C*)0)->m_pa_0, packed));\n+_Static_assert (__builtin_has_attribute (((C*)0)->m_pa_1_0, packed));\n+_Static_assert (__builtin_has_attribute (((C*)0)->m_pa_0_1, packed));\n+\n+_Static_assert (__builtin_has_attribute (((C*)0)->m_xpa_0, packed));\n+_Static_assert (__builtin_has_attribute (((C*)0)->m_xpa_1_0, packed));\n+_Static_assert (__builtin_has_attribute (((C*)0)->m_xpa_0_1, packed));\n+\n+_Static_assert (__builtin_has_attribute (((C*)0)->m_arpa_0, packed));\n+_Static_assert (__builtin_has_attribute (((C*)0)->m_arpa_1_0, packed));\n+_Static_assert (__builtin_has_attribute (((C*)0)->m_arpa_0_1, packed));\n+\n+_Static_assert (__builtin_has_attribute (((C*)0)->m_ra, packed));\n+_Static_assert (__builtin_has_attribute (((C*)0)->m_rb_a, packed));\n+_Static_assert (__builtin_has_attribute (((C*)0)->m_rb_pa, packed));\n+\n+_Static_assert (__builtin_has_attribute (((C*)0)->m_ara, packed));\n+_Static_assert (__builtin_has_attribute (((C*)0)->m_arb_a, packed));\n+_Static_assert (__builtin_has_attribute (((C*)0)->m_xb_pa, packed));\n+_Static_assert (__builtin_has_attribute (((C*)0)->m_arb_pa, packed));\n+\n+_Static_assert (__builtin_has_attribute (((C*)0)->m_xpa, packed));\n+_Static_assert (__builtin_has_attribute (((C*)0)->m_arpa, packed));\n+\n+_Static_assert (__builtin_has_attribute (((C*)0)->m_arab_a, packed));\n+_Static_assert (__builtin_has_attribute (((C*)0)->m_arab_pa, packed));\n+_Static_assert (__builtin_has_attribute (((C*)0)->m_xarab_pa, packed));\n+_Static_assert (__builtin_has_attribute (((C*)0)->m_arab_pa_bf, packed));\n+\n+_Static_assert (__builtin_has_attribute (((C*)0)->m_pb_a, packed));\n+_Static_assert (__builtin_has_attribute (((C*)0)->m_pb_pa, packed));\n+_Static_assert (__builtin_has_attribute (((C*)0)->m_xpb_pa, packed));\n+_Static_assert (__builtin_has_attribute (((C*)0)->m_pb_pa_bf, packed));\n+\n+_Static_assert (__builtin_has_attribute (((C*)0)->m_a4_pa_0, packed));\n+_Static_assert (__builtin_has_attribute (((C*)0)->m_a4_pa_0, aligned));\n+_Static_assert (__alignof__ (((C*)0)->m_a4_pa_0) == 4);"}]}