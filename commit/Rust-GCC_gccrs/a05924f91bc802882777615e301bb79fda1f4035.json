{"sha": "a05924f91bc802882777615e301bb79fda1f4035", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTA1OTI0ZjkxYmM4MDI4ODI3Nzc2MTVlMzAxYmI3OWZkYTFmNDAzNQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@freesoft.cz", "date": "1999-10-27T01:25:13Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-10-27T01:25:13Z"}, "message": "Reorg reg-stack to use the standard CFG.\n\nCo-Authored-By: Richard Henderson <rth@cygnus.com>\n\nFrom-SVN: r30201", "tree": {"sha": "7fc24b0621130fa71399fe7a18886374f8f8f7ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7fc24b0621130fa71399fe7a18886374f8f8f7ad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a05924f91bc802882777615e301bb79fda1f4035", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a05924f91bc802882777615e301bb79fda1f4035", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a05924f91bc802882777615e301bb79fda1f4035", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a05924f91bc802882777615e301bb79fda1f4035/comments", "author": null, "committer": null, "parents": [{"sha": "b517dcd29efdce45944072b01e562887bbca276f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b517dcd29efdce45944072b01e562887bbca276f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b517dcd29efdce45944072b01e562887bbca276f"}], "stats": {"total": 2253, "additions": 952, "deletions": 1301}, "files": [{"sha": "6614d8ba543b3c3c0afb2186e59ef9caadde21f1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a05924f91bc802882777615e301bb79fda1f4035/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a05924f91bc802882777615e301bb79fda1f4035/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a05924f91bc802882777615e301bb79fda1f4035", "patch": "@@ -1,3 +1,56 @@\n+Tue Oct 26 18:23:38 1999  Jan Hubicka  <hubicka@freesoft.cz>\n+\t\t\t  Richard Henderson  <rth@cygnus.com>\n+\n+\t* emit-rtl.c (emit_block_insn_before): New.\n+\t(emit_block_insn_after): New.\n+\t* basic-block.h: Declare them.\n+\n+\t* bitmap.h: Protect from multiple inclusion.\n+\n+\t* recog.c (scratch_operand): Handle VOIDmode correctly.\n+\n+\t* rtl.h (JUMP_CROSS_JUMP_DEATH_MATTERS): New.\n+\n+\t* builtins.c (expand_builtin_apply_args_1): Remove STACK_REGS hack.\n+\t* function.c (assign_parms): Likewise.\n+\t* global.c (global_conflicts): Clarify STACK_REGS commentary.\n+\n+\t* reg-stack.c (max_uid): Remove.\n+\t(blocks, block_begin, block_end, block_drops_in): Remove.\n+\t(block_stack_in, block_out_reg_set, block_number): Remove.\n+\t(struct block_info_def, BLOCK_INFO): New.\n+\t(enum emit_where): New.\n+\t(current_block): New.\n+\t(BLOCK_NUM): Remove.\n+\t(mark_regs_pat, record_label_references): Remove.\n+\t(record_reg_life_pat, record_reg_life, find_blocks): Remove.\n+\t(nan): New.\n+\t(goto_block_pat, print_blocks, dump_stack_info): Remove.\n+\t(reg_to_stack): Simplified test for existance of fp code.  Use\n+\tflow.c code.  Call shorten_branches after cross-jump opt.\n+\t(check_asm_stack_operands): Renamed from record_asm_reg_life.\n+\tReturn false if the asm doesn't use stack regs.  Don't do life\n+\tanalysis on the asm.\n+\t(emit_pop_insn): Replace function pointer arg `when' with\n+\tenum `where'.  Update all callers.\n+\t(change_stack): Likewise.  Update basic block end.\n+\t(emit_swap_insn): Use current_block->head to limit reverse search\n+\tfor start of block.  Use emit_block_insn_after.\n+\t(subst_stack_regs_pat): Handle USE and CLOBBER patterns.\n+\t(subst_asm_stack_regs): Use check_asm_stack_operands.  Use direct\n+\tstructure assignment instead of bcopy.\n+\t(print_stack): New.\n+\t(convert_regs_entry, convert_regs_exit): New.\n+\t(convert_regs_1, convert_regs_2): Split out from convert_regs.\n+\tWork on basic blocks and the CFG.\n+\t(convert_regs): Use them.\n+\n+\t* i386.c (output_fix_trunc): Remove code for DImode input operand\n+\tnot at top-of-stack.\n+\t* i386.c (fix_truncdfdi2, fix_truncsfdi2): Use scratch with\n+\tappropriate mode.\n+\t(fix_truncdi_1): Allow any mode scratch.\n+\n Tue Oct 26 13:30:35 1999  Richard Henderson  <rth@cygnus.com>\n \n \t* alpha.h (TARGET_MEM_FUNCTIONS): Define here."}, {"sha": "4de631ad9bee9ffc8278004368fe3e2f39445089", "filename": "gcc/basic-block.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a05924f91bc802882777615e301bb79fda1f4035/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a05924f91bc802882777615e301bb79fda1f4035/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=a05924f91bc802882777615e301bb79fda1f4035", "patch": "@@ -333,3 +333,7 @@ extern struct edge_list *pre_edge_rev_lcm PROTO ((FILE *, int, sbitmap *,\n \t\t\t\t\t\t  sbitmap **));\n extern int compute_available\t\tPROTO ((sbitmap *, sbitmap *,\n \t\t\t\t\t\tsbitmap *, sbitmap *));\n+\n+/* In emit-rtl.c.  */\n+extern rtx emit_block_insn_after\tPROTO((rtx, rtx, basic_block));\n+extern rtx emit_block_insn_before\tPROTO((rtx, rtx, basic_block));"}, {"sha": "4f27bdcf9294d97859b7e0e9778023b873c773ac", "filename": "gcc/bitmap.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a05924f91bc802882777615e301bb79fda1f4035/gcc%2Fbitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a05924f91bc802882777615e301bb79fda1f4035/gcc%2Fbitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.h?ref=a05924f91bc802882777615e301bb79fda1f4035", "patch": "@@ -18,6 +18,9 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n+#ifndef _BITMAP_H\n+#define _BITMAP_H 1\n+\n /* Number of words to use for each element in the linked list.  */\n \n #ifndef BITMAP_ELEMENT_WORDS\n@@ -319,3 +322,5 @@ do {\t\t\t\t\t\t\t\t\t\\\n       word_num_ = 0;\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n } while (0)\n+\n+#endif /* _BITMAP_H */"}, {"sha": "ffc84fd9ccd120c17511bbd520e634ce538ed99f", "filename": "gcc/builtins.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a05924f91bc802882777615e301bb79fda1f4035/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a05924f91bc802882777615e301bb79fda1f4035/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=a05924f91bc802882777615e301bb79fda1f4035", "patch": "@@ -762,13 +762,6 @@ expand_builtin_apply_args_1 ()\n \n \ttem = gen_rtx_REG (mode, INCOMING_REGNO (regno));\n \n-#ifdef STACK_REGS\n-        /* For reg-stack.c's stack register household.\n-\t   Compare with a similar piece of code in function.c.  */\n-\n-        emit_insn (gen_rtx_USE (mode, tem));\n-#endif\n-\n \temit_move_insn (change_address (registers, mode,\n \t\t\t\t\tplus_constant (XEXP (registers, 0),\n \t\t\t\t\t\t       size)),"}, {"sha": "b2e2dff50ffe058b3ef44c549903075230cc7fb2", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 2, "deletions": 19, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a05924f91bc802882777615e301bb79fda1f4035/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a05924f91bc802882777615e301bb79fda1f4035/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=a05924f91bc802882777615e301bb79fda1f4035", "patch": "@@ -3163,25 +3163,8 @@ output_fix_trunc (insn, operands)\n   /* Jump through a hoop or two for DImode, since the hardware has no\n      non-popping instruction.  We used to do this a different way, but\n      that was somewhat fragile and broke with post-reload splitters.  */\n-  if (dimode_p)\n-    {\n-      if (! STACK_TOP_P (operands[1]))\n-\t{\n-\t  rtx tmp;\n-\n-\t  output_asm_insn (\"fst\\t%y1\", operands);\n-\n-\t  /* The scratch we allocated sure better have died.  */\n-\t  if (! stack_top_dies)\n-\t    abort ();\n-\n-\t  tmp = operands[1];\n-\t  operands[1] = operands[5];\n-\t  operands[5] = tmp;\n-\t}\n-      else if (! stack_top_dies)\n-\toutput_asm_insn (\"fld\\t%y1\", operands);\n-    }\n+  if (dimode_p && !stack_top_dies)\n+    output_asm_insn (\"fld\\t%y1\", operands);\n \n   if (! STACK_TOP_P (operands[1]))\n     abort ();"}, {"sha": "4641b06b05e15ebce747f5b7a22b4cb9ccd05acb", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a05924f91bc802882777615e301bb79fda1f4035/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a05924f91bc802882777615e301bb79fda1f4035/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=a05924f91bc802882777615e301bb79fda1f4035", "patch": "@@ -2724,7 +2724,7 @@\n \t      (clobber (match_dup 2))\n \t      (clobber (match_dup 3))\n \t      (clobber (match_scratch:SI 4 \"\"))\n-\t      (clobber (match_scratch:XF 5 \"\"))])]\n+\t      (clobber (match_scratch:DF 5 \"\"))])]\n   \"TARGET_80387\"\n   \"operands[2] = assign_386_stack_local (SImode, 0);\n    operands[3] = assign_386_stack_local (DImode, 1);\")\n@@ -2735,7 +2735,7 @@\n \t      (clobber (match_dup 2))\n \t      (clobber (match_dup 3))\n \t      (clobber (match_scratch:SI 4 \"\"))\n-\t      (clobber (match_scratch:XF 5 \"\"))])]\n+\t      (clobber (match_scratch:SF 5 \"\"))])]\n   \"TARGET_80387\"\n   \"operands[2] = assign_386_stack_local (SImode, 0);\n    operands[3] = assign_386_stack_local (DImode, 1);\")\n@@ -2745,8 +2745,8 @@\n \t(fix:DI (match_operand 1 \"register_operand\" \"f,f\")))\n    (clobber (match_operand:SI 2 \"memory_operand\" \"=o,o\"))\n    (clobber (match_operand:DI 3 \"memory_operand\" \"=m,m\"))\n-   (clobber (match_scratch:SI 4 \"=&r,=&r\"))\n-   (clobber (match_scratch:XF 5 \"=f,f\"))]\n+   (clobber (match_scratch:SI 4 \"=&r,&r\"))\n+   (clobber (match_scratch 5 \"=&f,&f\"))]\n   \"TARGET_80387 && FLOAT_MODE_P (GET_MODE (operands[1]))\"\n   \"* return output_fix_trunc (insn, operands);\"\n   [(set_attr \"type\" \"multi\")])\n@@ -2757,7 +2757,7 @@\n    (clobber (match_operand:SI 2 \"memory_operand\" \"\"))\n    (clobber (match_operand:DI 3 \"memory_operand\" \"\"))\n    (clobber (match_scratch:SI 4 \"\"))\n-   (clobber (match_scratch:XF 5 \"\"))]\n+   (clobber (match_scratch 5 \"\"))]\n   \"reload_completed && !reg_overlap_mentioned_p (operands[4], operands[3])\"\n   [(parallel [(set (match_dup 3) (fix:DI (match_dup 1)))\n \t      (clobber (match_dup 2))"}, {"sha": "4e45985df0138df1ad5e3ec32c617ffe489b180c", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a05924f91bc802882777615e301bb79fda1f4035/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a05924f91bc802882777615e301bb79fda1f4035/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=a05924f91bc802882777615e301bb79fda1f4035", "patch": "@@ -50,6 +50,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"real.h\"\n #include \"obstack.h\"\n #include \"bitmap.h\"\n+#include \"basic-block.h\"\n #include \"ggc.h\"\n \n /* Commonly used modes.  */\n@@ -2600,6 +2601,20 @@ emit_insn_before (pattern, before)\n   return insn;\n }\n \n+/* Similar to emit_insn_before, but update basic block boundaries as well.  */\n+\n+rtx\n+emit_block_insn_before (pattern, before, block)\n+     rtx pattern, before;\n+     basic_block block;\n+{\n+  rtx prev = PREV_INSN (before);\n+  rtx r = emit_insn_before (pattern, before);\n+  if (block && block->head == before)\n+    block->head = NEXT_INSN (prev);\n+  return r;\n+}\n+\n /* Make an instruction with body PATTERN and code JUMP_INSN\n    and output it before the instruction BEFORE.  */\n \n@@ -2742,6 +2757,19 @@ emit_insn_after_with_line_notes (pattern, after, from)\n \t\t\t  insn);\n }\n \n+/* Similar to emit_insn_after, but update basic block boundaries as well.  */\n+\n+rtx\n+emit_block_insn_after (pattern, after, block)\n+     rtx pattern, after;\n+     basic_block block;\n+{\n+  rtx r = emit_insn_after (pattern, after);\n+  if (block && block->end == after)\n+    block->end = r;\n+  return r;\n+}\n+\n /* Make an insn of code JUMP_INSN with body PATTERN\n    and output it after the insn AFTER.  */\n "}, {"sha": "890f62bdbae8b56ef74de6cba9042529e5e66eca", "filename": "gcc/function.c", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a05924f91bc802882777615e301bb79fda1f4035/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a05924f91bc802882777615e301bb79fda1f4035/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=a05924f91bc802882777615e301bb79fda1f4035", "patch": "@@ -4323,17 +4323,6 @@ assign_parms (fndecl)\n \t}\n #endif /* 0 */\n \n-#ifdef STACK_REGS\n-      /* We need this \"use\" info, because the gcc-register->stack-register\n-\t converter in reg-stack.c needs to know which registers are active\n-\t at the start of the function call.  The actual parameter loading\n-\t instructions are not always available then anymore, since they might\n-\t have been optimised away.  */\n-\n-      if (GET_CODE (entry_parm) == REG && !(hide_last_arg && last_named))\n-\t  emit_insn (gen_rtx_USE (GET_MODE (entry_parm), entry_parm));\n-#endif\n-\n       /* ENTRY_PARM is an RTX for the parameter as it arrives,\n \t in the mode in which it arrives.\n \t STACK_PARM is an RTX for a stack slot where the parameter can live"}, {"sha": "44564e8dd2e3c47daddcf507a958f6fee45beefb", "filename": "gcc/global.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a05924f91bc802882777615e301bb79fda1f4035/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a05924f91bc802882777615e301bb79fda1f4035/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=a05924f91bc802882777615e301bb79fda1f4035", "patch": "@@ -673,16 +673,12 @@ global_conflicts ()\n #ifdef STACK_REGS\n \t{\n \t  /* Pseudos can't go in stack regs at the start of a basic block\n-\t     that can be reached through a computed goto, since reg-stack\n-\t     can't handle computed gotos.  */\n-\t  /* ??? Seems more likely that reg-stack can't handle any abnormal\n-\t     edges, critical or not, computed goto or otherwise.  */\n+\t     that is reached by an abnormal edge.  */\n \n \t  edge e;\n \t  for (e = BASIC_BLOCK (b)->pred; e ; e = e->pred_next)\n \t    if (e->flags & EDGE_ABNORMAL)\n \t      break;\n-\n \t  if (e != NULL)\n \t    for (ax = FIRST_STACK_REG; ax <= LAST_STACK_REG; ax++)\n \t      record_one_conflict (ax);"}, {"sha": "b7d8e71ef3e7e75fa7add98114b5f06bba010951", "filename": "gcc/recog.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a05924f91bc802882777615e301bb79fda1f4035/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a05924f91bc802882777615e301bb79fda1f4035/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=a05924f91bc802882777615e301bb79fda1f4035", "patch": "@@ -1045,10 +1045,12 @@ scratch_operand (op, mode)\n      register rtx op;\n      enum machine_mode mode;\n {\n-  return (GET_MODE (op) == mode\n-\t  && (GET_CODE (op) == SCRATCH\n-\t      || (GET_CODE (op) == REG\n-\t\t  && REGNO (op) < FIRST_PSEUDO_REGISTER)));\n+  if (GET_MODE (op) != mode && mode != VOIDmode)\n+    return 0;\n+\n+  return (GET_CODE (op) == SCRATCH\n+\t  || (GET_CODE (op) == REG\n+\t      && REGNO (op) < FIRST_PSEUDO_REGISTER));\n }\n \n /* Return 1 if OP is a valid immediate operand for mode MODE."}, {"sha": "50e55c1147d74e6a1ead67dae54355430fb02cc6", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 844, "deletions": 1247, "changes": 2091, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a05924f91bc802882777615e301bb79fda1f4035/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a05924f91bc802882777615e301bb79fda1f4035/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=a05924f91bc802882777615e301bb79fda1f4035", "patch": "@@ -1,22 +1,22 @@\n /* Register to Stack convert for GNU compiler.\n    Copyright (C) 1992, 93-98, 1999 Free Software Foundation, Inc.\n \n-This file is part of GNU CC.\n+   This file is part of GNU CC.\n \n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n+   GNU CC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n \n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n+   GNU CC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n \n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n+   You should have received a copy of the GNU General Public License\n+   along with GNU CC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n \n /* This pass converts stack-like registers from the \"flat register\n    file\" model that gcc uses, to a stack convention that the 387 uses.\n@@ -148,7 +148,7 @@ Boston, MA 02111-1307, USA.  */\n \n \tasm (\"fyl2xp1\" : \"=t\" (result) : \"0\" (x), \"u\" (y) : \"st(1)\");\n \n-   */\n+*/\n \f\n #include \"config.h\"\n #include \"system.h\"\n@@ -163,6 +163,8 @@ Boston, MA 02111-1307, USA.  */\n #include \"insn-flags.h\"\n #include \"toplev.h\"\n #include \"recog.h\"\n+#include \"output.h\"\n+#include \"basic-block.h\"\n #include \"varray.h\"\n \n #ifdef STACK_REGS\n@@ -185,35 +187,24 @@ typedef struct stack_def\n   char reg[REG_STACK_SIZE];\t/* register - stack mapping */\n } *stack;\n \n-/* highest instruction uid */\n-static int max_uid = 0;\n+/* This is used to carry information about basic blocks.  It is \n+   attached to the AUX field of the standard CFG block.  */\n \n-/* Number of basic blocks in the current function.  */\n-static int blocks;\n-\n-/* Element N is first insn in basic block N.\n-   This info lasts until we finish compiling the function.  */\n-static rtx *block_begin;\n-\n-/* Element N is last insn in basic block N.\n-   This info lasts until we finish compiling the function.  */\n-static rtx *block_end;\n-\n-/* Element N is nonzero if control can drop into basic block N */\n-static char *block_drops_in;\n-\n-/* Element N says all about the stack at entry block N */\n-static stack block_stack_in;\n+typedef struct block_info_def\n+{\n+  struct stack_def stack_in;\t/* Input stack configuration.  */\n+  HARD_REG_SET out_reg_set;\t/* Stack regs live on output.  */\n+  int done;\t\t\t/* True if block already converted.  */\n+} *block_info;\n \n-/* Element N says all about the stack life at the end of block N */\n-static HARD_REG_SET *block_out_reg_set;\n+#define BLOCK_INFO(B)\t((block_info) (B)->aux)\n \n-/* This is where the BLOCK_NUM values are really stored.  This is set\n-   up by find_blocks and used there and in life_analysis.  It can be used\n-   later, but only to look up an insn that is the head or tail of some\n-   block.  life_analysis and the stack register conversion process can\n-   add insns within a block.  */\n-static int *block_number;\n+/* Passed to change_stack to indicate where to emit insns.  */\n+enum emit_where\n+{\n+  EMIT_AFTER,\n+  EMIT_BEFORE\n+};\n \n /* We use this array to cache info about insns, because otherwise we\n    spend too much time in stack_regs_mentioned_p. \n@@ -223,42 +214,35 @@ static int *block_number;\n    stack registers.  */\n static varray_type stack_regs_mentioned_data;\n \n+/* The block we're currently working on.  */\n+static basic_block current_block;\n+\n /* This is the register file for all register after conversion */\n static rtx\n   FP_mode_reg[LAST_STACK_REG+1-FIRST_STACK_REG][(int) MAX_MACHINE_MODE];\n \n #define FP_MODE_REG(regno,mode)\t\\\n   (FP_mode_reg[(regno)-FIRST_STACK_REG][(int)(mode)])\n \n-/* Get the basic block number of an insn.  See note at block_number\n-   definition are validity of this information.  */\n-\n-#define BLOCK_NUM(INSN)\t\t\t\t\t\\\n-  ((INSN_UID (INSN) > max_uid)\t\t\t\t\\\n-   ? (abort() , -1) : block_number[INSN_UID (INSN)])\n+/* Used to initialize uninitialized registers.  */\n+static rtx nan;\n \n /* Forward declarations */\n \n static int stack_regs_mentioned_p\tPROTO((rtx pat));\n-static void mark_regs_pat\t\tPROTO((rtx, HARD_REG_SET *));\n static void straighten_stack\t\tPROTO((rtx, stack));\n static void pop_stack\t\t\tPROTO((stack, int));\n-static void record_label_references\tPROTO((rtx, rtx));\n static rtx *get_true_reg\t\tPROTO((rtx *));\n \n-static void record_asm_reg_life\t\tPROTO((rtx, stack));\n-static void record_reg_life_pat\t\tPROTO((rtx, HARD_REG_SET *,\n-\t\t\t\t\t       HARD_REG_SET *, int));\n+static int check_asm_stack_operands\tPROTO((rtx));\n static int get_asm_operand_n_inputs\tPROTO((rtx));\n-static void record_reg_life\t\tPROTO((rtx, int, stack));\n-static void find_blocks\t\t\tPROTO((rtx));\n static rtx stack_result\t\t\tPROTO((tree));\n-static void stack_reg_life_analysis\tPROTO((rtx, HARD_REG_SET *));\n static void replace_reg\t\t\tPROTO((rtx *, int));\n static void remove_regno_note\t\tPROTO((rtx, enum reg_note, int));\n static int get_hard_regnum\t\tPROTO((stack, rtx));\n static void delete_insn_for_stacker\tPROTO((rtx));\n-static rtx emit_pop_insn\t\tPROTO((rtx, stack, rtx, rtx (*) ()));\n+static rtx emit_pop_insn\t\tPROTO((rtx, stack, rtx,\n+\t\t\t\t\t       enum emit_where));\n static void emit_swap_insn\t\tPROTO((rtx, stack, rtx));\n static void move_for_stack_reg\t\tPROTO((rtx, stack, rtx));\n static int swap_rtx_condition_1\t\tPROTO((rtx));\n@@ -267,12 +251,14 @@ static void compare_for_stack_reg\tPROTO((rtx, stack, rtx));\n static void subst_stack_regs_pat\tPROTO((rtx, stack, rtx));\n static void subst_asm_stack_regs\tPROTO((rtx, stack));\n static void subst_stack_regs\t\tPROTO((rtx, stack));\n-static void change_stack\t\tPROTO((rtx, stack, stack, rtx (*) ()));\n-\n-static void goto_block_pat\t\tPROTO((rtx, stack, rtx));\n-static void convert_regs\t\tPROTO((void));\n-static void print_blocks\t\tPROTO((FILE *, rtx, rtx));\n-static void dump_stack_info\t\tPROTO((FILE *));\n+static void change_stack\t\tPROTO((rtx, stack, stack,\n+\t\t\t\t\t       enum emit_where));\n+static int convert_regs_entry\t\tPROTO((void));\n+static void convert_regs_exit\t\tPROTO((void));\n+static int convert_regs_1\t\tPROTO((FILE *, basic_block));\n+static int convert_regs_2\t\tPROTO((FILE *, basic_block));\n+static int convert_regs\t\t\tPROTO((FILE *));\n+static void print_stack \t\tPROTO((FILE *, stack));\n \f\n /* Return non-zero if any stack register is mentioned somewhere within PAT.  */\n \n@@ -364,31 +350,6 @@ next_flags_user (insn)\n     }\n }\n \f\n-/* Mark all registers needed for this pattern.  */\n-\n-static void\n-mark_regs_pat (pat, set)\n-     rtx pat;\n-     HARD_REG_SET *set;\n-{\n-  enum machine_mode mode;\n-  register int regno;\n-  register int count;\n-\n-  if (GET_CODE (pat) == SUBREG)\n-    {\n-      mode = GET_MODE (pat);\n-      regno = SUBREG_WORD (pat);\n-      regno += REGNO (SUBREG_REG (pat));\n-    }\n-  else\n-    regno = REGNO (pat), mode = GET_MODE (pat);\n-\n-  for (count = HARD_REGNO_NREGS (regno, mode);\n-       count; count--, regno++)\n-    SET_HARD_REG_BIT (*set, regno);\n-}\n-\f\n /* Reorganise the stack into ascending numbers,\n    after this insn.  */\n \n@@ -412,7 +373,7 @@ straighten_stack (insn, regstack)\n   for (top = temp_stack.top = regstack->top; top >= 0; top--)\n     temp_stack.reg[top] = FIRST_STACK_REG + temp_stack.top - top;\n   \n-  change_stack (insn, regstack, &temp_stack, emit_insn_after);\n+  change_stack (insn, regstack, &temp_stack, EMIT_AFTER);\n }\n \n /* Pop a register from the stack */\n@@ -445,151 +406,92 @@ pop_stack (regstack, regno)\n    register file.  FIRST is the first insn in the function, FILE is the\n    dump file, if used.\n \n-   First compute the beginning and end of each basic block.  Do a\n-   register life analysis on the stack registers, recording the result\n-   for the head and tail of each basic block.  The convert each insn one\n-   by one.  Run a last jump_optimize() pass, if optimizing, to eliminate\n-   any cross-jumping created when the converter inserts pop insns.*/\n+   Construct a CFG and run life analysis.  (When optimizing, the data\n+   was corruped by jump2's cross-jumping.)  Then convert each insn one\n+   by one.  Run a last jump_optimize pass, if optimizing, to eliminate\n+   code duplication created when the converter inserts pop insns on\n+   the edges.  */\n \n void\n reg_to_stack (first, file)\n      rtx first;\n      FILE *file;\n {\n-  register rtx insn;\n-  register int i;\n-  int stack_reg_seen = 0;\n-  enum machine_mode mode;\n-  HARD_REG_SET stackentry;\n-\n-  ix86_flags_rtx = gen_rtx_REG (CCmode, FLAGS_REG);\n-\n-  max_uid = get_max_uid ();\n-  VARRAY_CHAR_INIT (stack_regs_mentioned_data, max_uid + 1,\n-\t\t    \"stack_regs_mentioned cache\");\n-\n-  CLEAR_HARD_REG_SET (stackentry);\n-\n-  {\n-    static int initialised;\n-    if (!initialised)\n-      {\n-#if 0\n-\tinitialised = 1;\t/* This array can not have been previously\n-\t\t\t\t   initialised, because the rtx's are\n-\t\t\t\t   thrown away between compilations of\n-\t\t\t\t   functions.  */\n-#endif\n-        for (i = FIRST_STACK_REG; i <= LAST_STACK_REG; i++)\n-\t  {\n-\t    for (mode = GET_CLASS_NARROWEST_MODE (MODE_FLOAT); mode != VOIDmode;\n-\t\t mode = GET_MODE_WIDER_MODE (mode))\n-              FP_MODE_REG (i, mode) = gen_rtx_REG (mode, i);\n-\t    for (mode = GET_CLASS_NARROWEST_MODE (MODE_COMPLEX_FLOAT); mode != VOIDmode;\n-\t\t mode = GET_MODE_WIDER_MODE (mode))\n-              FP_MODE_REG (i, mode) = gen_rtx_REG (mode, i);\n-\t  }\n-      }\n-  }\n-\n-  /* Count the basic blocks.  Also find maximum insn uid.  */\n-  {\n-    register RTX_CODE prev_code = BARRIER;\n-    register RTX_CODE code;\n-    register int before_function_beg = 1;\n-\n-    max_uid = 0;\n-    blocks = 0;\n-    for (insn = first; insn; insn = NEXT_INSN (insn))\n-      {\n-\t/* Note that this loop must select the same block boundaries\n-\t   as code in find_blocks.  Also note that this code is not the\n-\t   same as that used in flow.c.  */\n-\n-\tif (INSN_UID (insn) > max_uid)\n-\t  max_uid = INSN_UID (insn);\n-\n-\tcode = GET_CODE (insn);\n-\n-\tif (code == CODE_LABEL\n-\t    || (prev_code != INSN\n-\t\t&& prev_code != CALL_INSN\n-\t\t&& prev_code != CODE_LABEL\n-\t\t&& GET_RTX_CLASS (code) == 'i'))\n-\t  blocks++;\n-\n-\tif (code == NOTE && NOTE_LINE_NUMBER (insn) == NOTE_INSN_FUNCTION_BEG)\n-\t  before_function_beg = 0;\n-\n-\t/* Remember whether or not this insn mentions an FP regs.\n-\t   Check JUMP_INSNs too, in case someone creates a funny PARALLEL.  */\n-\n-\tif (GET_RTX_CLASS (code) == 'i'\n-\t    && stack_regs_mentioned_p (PATTERN (insn)))\n-\t  {\n-\t    stack_reg_seen = 1;\n- \t    VARRAY_CHAR (stack_regs_mentioned_data, INSN_UID (insn)) = 1;\n-\n-\t    /* Note any register passing parameters.  */\n+  int i;\n+  int max_uid;\n+  sbitmap blocks;\n+  block_info bi;\n+\n+  /* See if there is something to do.  Flow analysis is quite\n+     expensive so we might save some compilation time.  */\n+  for (i = FIRST_STACK_REG; i <= LAST_STACK_REG; i++)\n+    if (regs_ever_live[i])\n+      break;\n+  if (i > LAST_STACK_REG)\n+    return;\n \n-\t    if (before_function_beg && code == INSN\n-\t        && GET_CODE (PATTERN (insn)) == USE)\n-              record_reg_life_pat (PATTERN (insn), (HARD_REG_SET *) 0,\n-\t\t\t\t   &stackentry, 1);\n-\t  }\n-\telse\n-\t  VARRAY_CHAR (stack_regs_mentioned_data, INSN_UID (insn)) = 2;\n+  /* Ok, floating point instructions exist.  Rebuild the CFG and run \n+     life analysis.  */\n+  find_basic_blocks (first, max_reg_num (), file, 0);\n \n-\tif (code == CODE_LABEL)\n-\t  LABEL_REFS (insn) = insn; /* delete old chain */\n+  blocks = sbitmap_alloc (n_basic_blocks);\n+  sbitmap_ones (blocks);\n+  count_or_remove_death_notes (blocks, 1);\n+  sbitmap_free (blocks);\n \n-\tif (code != NOTE)\n-\t  prev_code = code;\n-      }\n-  }\n+  life_analysis (first, max_reg_num (), file, 0);\n \n-  /* If no stack register reference exists in this insn, there isn't\n-     anything to convert.  */\n+  /* Set up block info for each basic block.  */\n+  bi = (block_info) alloca ((n_basic_blocks + 1) * sizeof (*bi));\n+  memset (bi, 0, (n_basic_blocks + 1) * sizeof (*bi));\n+  for (i = n_basic_blocks - 1; i >= 0; --i)\n+    BASIC_BLOCK (i)->aux = bi + i;\n+  EXIT_BLOCK_PTR->aux = bi + n_basic_blocks;\n \n-  if (! stack_reg_seen)\n+  /* Create the replacement registers up front.  */\n+  for (i = FIRST_STACK_REG; i <= LAST_STACK_REG; i++)\n     {\n-      VARRAY_FREE (stack_regs_mentioned_data);\n-      return;\n+      enum machine_mode mode;\n+      for (mode = GET_CLASS_NARROWEST_MODE (MODE_FLOAT);\n+\t   mode != VOIDmode;\n+\t   mode = GET_MODE_WIDER_MODE (mode))\n+\tFP_MODE_REG (i, mode) = gen_rtx_REG (mode, i);\n+      for (mode = GET_CLASS_NARROWEST_MODE (MODE_COMPLEX_FLOAT);\n+\t   mode != VOIDmode;\n+\t   mode = GET_MODE_WIDER_MODE (mode))\n+\tFP_MODE_REG (i, mode) = gen_rtx_REG (mode, i);\n     }\n \n-  /* If there are stack registers, there must be at least one block.  */\n-\n-  if (! blocks)\n-    abort ();\n-\n-  /* Allocate some tables that last till end of compiling this function\n-     and some needed only in find_blocks and life_analysis.  */\n-\n-  block_begin = (rtx *) alloca (blocks * sizeof (rtx));\n-  block_end = (rtx *) alloca (blocks * sizeof (rtx));\n-  block_drops_in = (char *) alloca (blocks);\n-\n-  block_stack_in = (stack) alloca (blocks * sizeof (struct stack_def));\n-  block_out_reg_set = (HARD_REG_SET *) alloca (blocks * sizeof (HARD_REG_SET));\n-  bzero ((char *) block_stack_in, blocks * sizeof (struct stack_def));\n-  bzero ((char *) block_out_reg_set, blocks * sizeof (HARD_REG_SET));\n+  ix86_flags_rtx = gen_rtx_REG (CCmode, FLAGS_REG);\n \n-  block_number = (int *) alloca ((max_uid + 1) * sizeof (int));\n+  /* A QNaN for initializing uninitialized variables.  \n \n-  find_blocks (first);\n-  stack_reg_life_analysis (first, &stackentry);\n+     ??? We can't load from constant memory in PIC mode, because\n+     we're insertting these instructions before the prologue and\n+     the PIC register hasn't been set up.  In that case, fall back\n+     on zero, which we can get from `ldz'.  */\n \n-  /* Dump the life analysis debug information before jump\n-     optimization, as that will destroy the LABEL_REFS we keep the\n-     information in.  */\n+  if (flag_pic)\n+    nan = CONST0_RTX (SFmode);\n+  else\n+    {\n+      nan = gen_lowpart (SFmode, GEN_INT (0x7fc00000));\n+      nan = force_const_mem (SFmode, nan);\n+    }\n \n-  if (file)\n-    dump_stack_info (file);\n+  /* Allocate a cache for stack_regs_mentioned.  */\n+  max_uid = get_max_uid ();\n+  VARRAY_CHAR_INIT (stack_regs_mentioned_data, max_uid + 1,\n+\t\t    \"stack_regs_mentioned cache\");\n \n-  convert_regs ();\n+  if (convert_regs (file) && optimize)\n+    {\n+      jump_optimize (first, JUMP_CROSS_JUMP_DEATH_MATTERS,\n+\t\t     !JUMP_NOOP_MOVES, !JUMP_AFTER_REGSCAN);\n \n-  if (optimize)\n-    jump_optimize (first, 2, 0, 0);\n+      /* This has the effect of resetting label alignments around loops.  */\n+      shorten_branches (get_insns ());\n+    }\n \n   VARRAY_FREE (stack_regs_mentioned_data);\n }\n@@ -679,25 +581,21 @@ get_true_reg (pat)\n       }\n }\n \f\n-/* Record the life info of each stack reg in INSN, updating REGSTACK.\n-   N_INPUTS is the number of inputs; N_OUTPUTS the outputs.\n-\n-   There are many rules that an asm statement for stack-like regs must\n+/* There are many rules that an asm statement for stack-like regs must\n    follow.  Those rules are explained at the top of this file: the rule\n    numbers below refer to that explanation.  */\n \n-static void\n-record_asm_reg_life (insn, regstack)\n+static int\n+check_asm_stack_operands (insn)\n      rtx insn;\n-     stack regstack;\n {\n   int i;\n   int n_clobbers;\n   int malformed_asm = 0;\n   rtx body = PATTERN (insn);\n \n-  int reg_used_as_output[FIRST_PSEUDO_REGISTER];\n-  int implicitly_dies[FIRST_PSEUDO_REGISTER];\n+  char reg_used_as_output[FIRST_PSEUDO_REGISTER];\n+  char implicitly_dies[FIRST_PSEUDO_REGISTER];\n   int alt;\n \n   rtx *clobber_reg;\n@@ -719,8 +617,7 @@ record_asm_reg_life (insn, regstack)\n       malformed_asm = 1;\n       /* Avoid further trouble with this insn.  */\n       PATTERN (insn) = gen_rtx_USE (VOIDmode, const0_rtx);\n-      PUT_MODE (insn, VOIDmode);\n-      return;\n+      return 0;\n     }\n \n   /* Strip SUBREGs here to make the following code simpler.  */\n@@ -761,7 +658,7 @@ record_asm_reg_life (insn, regstack)\n      Also enforce rule #5: Output operands must start at the top of\n      the reg-stack: output operands may not \"skip\" a reg.  */\n \n-  bzero ((char *) reg_used_as_output, sizeof (reg_used_as_output));\n+  memset (reg_used_as_output, 0, sizeof (reg_used_as_output));\n   for (i = 0; i < n_outputs; i++)\n     if (STACK_REG_P (recog_data.operand[i]))\n       {\n@@ -795,7 +692,7 @@ record_asm_reg_life (insn, regstack)\n      to the top of the reg-stack than any input that is not implicitly\n      popped.  */\n \n-  bzero ((char *) implicitly_dies, sizeof (implicitly_dies));\n+  memset (implicitly_dies, 0, sizeof (implicitly_dies));\n   for (i = n_outputs; i < n_outputs + n_inputs; i++)\n     if (STACK_REG_P (recog_data.operand[i]))\n       {\n@@ -831,7 +728,7 @@ record_asm_reg_life (insn, regstack)\n   /* Enfore rule #3: If any input operand uses the \"f\" constraint, all\n      output constraints must use the \"&\" earlyclobber.\n \n-     ???  Detect this more deterministically by having constraint_asm_operands\n+     ??? Detect this more deterministically by having constrain_asm_operands\n      record any earlyclobber.  */\n \n   for (i = n_outputs; i < n_outputs + n_inputs; i++)\n@@ -852,110 +749,10 @@ record_asm_reg_life (insn, regstack)\n     {\n       /* Avoid further trouble with this insn.  */\n       PATTERN (insn) = gen_rtx_USE (VOIDmode, const0_rtx);\n-      VARRAY_CHAR (stack_regs_mentioned_data, INSN_UID (insn)) = 2;\n-      return;\n-    }\n-\n-  /* Process all outputs */\n-  for (i = 0; i < n_outputs; i++)\n-    {\n-      rtx op = recog_data.operand[i];\n-\n-      if (! STACK_REG_P (op))\n-\t{\n-\t  if (stack_regs_mentioned_p (op))\n-\t    abort ();\n-\t  else\n-\t    continue;\n-\t}\n-\n-      /* Each destination is dead before this insn.  If the\n-\t destination is not used after this insn, record this with\n-\t REG_UNUSED.  */\n-\n-      if (! TEST_HARD_REG_BIT (regstack->reg_set, REGNO (op)))\n-\tREG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_UNUSED, op,\n-\t\t\t\t\t      REG_NOTES (insn));\n-\n-      CLEAR_HARD_REG_BIT (regstack->reg_set, REGNO (op));\n-    }\n-\n-  /* Process all inputs */\n-  for (i = n_outputs; i < n_outputs + n_inputs; i++)\n-    {\n-      rtx op = recog_data.operand[i];\n-      if (! STACK_REG_P (op))\n-\t{\n-\t  if (stack_regs_mentioned_p (op))\n-\t    abort ();\n-\t  else\n-\t    continue;\n-\t}\n-\n-      /* If an input is dead after the insn, record a death note.\n-\t But don't record a death note if there is already a death note,\n-\t or if the input is also an output.  */\n-\n-      if (! TEST_HARD_REG_BIT (regstack->reg_set, REGNO (op))\n-\t  && recog_op_alt[i][alt].matches == -1\n-\t  && find_regno_note (insn, REG_DEAD, REGNO (op)) == NULL_RTX)\n-\tREG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_DEAD, op, REG_NOTES (insn));\n-\n-      SET_HARD_REG_BIT (regstack->reg_set, REGNO (op));\n-    }\n-}\n-\n-/* Scan PAT, which is part of INSN, and record registers appearing in\n-   a SET_DEST in DEST, and other registers in SRC.\n-\n-   This function does not know about SET_DESTs that are both input and\n-   output (such as ZERO_EXTRACT) - this cannot happen on a 387.  */\n-\n-static void\n-record_reg_life_pat (pat, src, dest, douse)\n-     rtx pat;\n-     HARD_REG_SET *src, *dest;\n-     int douse;\n-{\n-  register const char *fmt;\n-  register int i;\n-\n-  if (STACK_REG_P (pat)\n-      || (GET_CODE (pat) == SUBREG && STACK_REG_P (SUBREG_REG (pat))))\n-    {\n-      if (src)\n-\tmark_regs_pat (pat, src);\n-\n-      if (dest)\n-\tmark_regs_pat (pat, dest);\n-\n-      return;\n-    }\n-\n-  if (GET_CODE (pat) == SET)\n-    {\n-      record_reg_life_pat (XEXP (pat, 0), NULL_PTR, dest, 0);\n-      record_reg_life_pat (XEXP (pat, 1), src, NULL_PTR, 0);\n-      return;\n+      return 0;\n     }\n \n-  /* We don't need to consider either of these cases.  */\n-  if ((GET_CODE (pat) == USE && !douse) || GET_CODE (pat) == CLOBBER)\n-    return;\n-\n-  fmt = GET_RTX_FORMAT (GET_CODE (pat));\n-  for (i = GET_RTX_LENGTH (GET_CODE (pat)) - 1; i >= 0; i--)\n-    {\n-      if (fmt[i] == 'E')\n-\t{\n-\t  register int j;\n-\n-\t  for (j = XVECLEN (pat, i) - 1; j >= 0; j--)\n-\t    record_reg_life_pat (XVECEXP (pat, i, j), src, dest, 0);\n-\t}\n-      else if (fmt[i] == 'e')\n-\trecord_reg_life_pat (XEXP (pat, i), src, dest, 0);\n-    }\n+  return 1;\n }\n \f\n /* Calculate the number of inputs and outputs in BODY, an\n@@ -983,207 +780,6 @@ get_asm_operand_n_inputs (body)\n \n   abort ();\n }\n-\f\n-/* Scan INSN, which is in BLOCK, and record the life & death of stack\n-   registers in REGSTACK.  This function is called to process insns from\n-   the last insn in a block to the first.  The actual scanning is done in\n-   record_reg_life_pat.\n-\n-   If a register is live after a CALL_INSN, but is not a value return\n-   register for that CALL_INSN, then code is emitted to initialize that\n-   register.  The block_end[] data is kept accurate.\n-\n-   Existing death and unset notes for stack registers are deleted\n-   before processing the insn.  */\n-\n-static void\n-record_reg_life (insn, block, regstack)\n-     rtx insn;\n-     int block;\n-     stack regstack;\n-{\n-  rtx note, *note_link;\n-  int n_operands;\n-\n-  if ((GET_CODE (insn) != INSN && GET_CODE (insn) != CALL_INSN)\n-      || INSN_DELETED_P (insn))\n-    return;\n-\n-  /* Strip death notes for stack regs from this insn */\n-\n-  note_link = &REG_NOTES(insn);\n-  for (note = *note_link; note; note = XEXP (note, 1))\n-    if (STACK_REG_P (XEXP (note, 0))\n-\t&& (REG_NOTE_KIND (note) == REG_DEAD\n-\t    || REG_NOTE_KIND (note) == REG_UNUSED))\n-      *note_link = XEXP (note, 1);\n-    else\n-      note_link = &XEXP (note, 1);\n-\n-  /* Process all patterns in the insn.  */\n-\n-  n_operands = asm_noperands (PATTERN (insn));\n-  if (n_operands >= 0)\n-    {\n-      record_asm_reg_life (insn, regstack);\n-      return;\n-    }\n-\n-  {\n-    HARD_REG_SET src, dest;\n-    int regno;\n-\n-    CLEAR_HARD_REG_SET (src);\n-    CLEAR_HARD_REG_SET (dest);\n-\n-    if (GET_CODE (insn) == CALL_INSN)\n-      for (note = CALL_INSN_FUNCTION_USAGE (insn);\n-\t   note;\n-\t   note = XEXP (note, 1))\n-\tif (GET_CODE (XEXP (note, 0)) == USE)\n-\t  record_reg_life_pat (SET_DEST (XEXP (note, 0)), &src, NULL_PTR, 0);\n-\n-    record_reg_life_pat (PATTERN (insn), &src, &dest, 0);\n-    for (regno = FIRST_STACK_REG; regno <= LAST_STACK_REG; regno++)\n-      if (! TEST_HARD_REG_BIT (regstack->reg_set, regno))\n-\t{\n-\t  if (TEST_HARD_REG_BIT (src, regno)\n-\t      && ! TEST_HARD_REG_BIT (dest, regno))\n-\t    REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_DEAD,\n-\t\t\t\t\t\t  FP_MODE_REG (regno, DFmode),\n-\t\t\t\t\t\t  REG_NOTES (insn));\n-\t  else if (TEST_HARD_REG_BIT (dest, regno))\n-\t    REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_UNUSED,\n-\t\t\t\t\t\t  FP_MODE_REG (regno, DFmode),\n-\t\t\t\t\t\t  REG_NOTES (insn));\n-\t}\n-\n-    if (GET_CODE (insn) == CALL_INSN)\n-      {\n-\tint reg;\n-\n-\t/* There might be a reg that is live after a function call.\n-\t   Initialize it to zero so that the program does not crash.  See\n-\t   comment towards the end of stack_reg_life_analysis().  */\n-\n-\tfor (reg = FIRST_STACK_REG; reg <= LAST_STACK_REG; reg++)\n-\t  if (! TEST_HARD_REG_BIT (dest, reg)\n-\t      && TEST_HARD_REG_BIT (regstack->reg_set, reg))\n-\t    {\n-\t      rtx init, pat;\n-\n-\t      /* The insn will use virtual register numbers, and so\n-\t\t convert_regs is expected to process these.  But BLOCK_NUM\n-\t\t cannot be used on these insns, because they do not appear in\n-\t\t block_number[].  */\n-\n-\t      pat = gen_rtx_SET (VOIDmode, FP_MODE_REG (reg, DFmode),\n-\t\t\t\t CONST0_RTX (DFmode));\n-\t      init = emit_insn_after (pat, insn);\n-\n-\t      CLEAR_HARD_REG_BIT (regstack->reg_set, reg);\n-\n-\t      /* If the CALL_INSN was the end of a block, move the\n-\t\t block_end to point to the new insn.  */\n-\n-\t      if (block_end[block] == insn)\n-\t\tblock_end[block] = init;\n-\t    }\n-\n-\t/* Some regs do not survive a CALL */\n-\tAND_COMPL_HARD_REG_SET (regstack->reg_set, call_used_reg_set);\n-      }\n-\n-    AND_COMPL_HARD_REG_SET (regstack->reg_set, dest);\n-    IOR_HARD_REG_SET (regstack->reg_set, src);\n-  }\n-}\n-\f\n-/* Find all basic blocks of the function, which starts with FIRST.\n-   For each JUMP_INSN, build the chain of LABEL_REFS on each CODE_LABEL.  */\n-\n-static void\n-find_blocks (first)\n-     rtx first;\n-{\n-  register rtx insn;\n-  register int block;\n-  register RTX_CODE prev_code = BARRIER;\n-  register RTX_CODE code;\n-  rtx label_value_list = 0;\n-\n-  /* Record where all the blocks start and end.\n-     Record which basic blocks control can drop in to.  */\n-\n-  block = -1;\n-  for (insn = first; insn; insn = NEXT_INSN (insn))\n-    {\n-      /* Note that this loop must select the same block boundaries\n-\t as code in reg_to_stack, but that these are not the same\n-\t as those selected in flow.c.  */\n-\n-      code = GET_CODE (insn);\n-\n-      if (code == CODE_LABEL\n-\t  || (prev_code != INSN\n-\t      && prev_code != CALL_INSN\n-\t      && prev_code != CODE_LABEL\n-\t      && GET_RTX_CLASS (code) == 'i'))\n-\t{\n-\t  block_begin[++block] = insn;\n-\t  block_end[block] = insn;\n-\t  block_drops_in[block] = prev_code != BARRIER;\n-\t}\n-      else if (GET_RTX_CLASS (code) == 'i')\n-\tblock_end[block] = insn;\n-\n-      if (GET_RTX_CLASS (code) == 'i')\n-\t{\n-\t  rtx note;\n-\n-\t  /* Make a list of all labels referred to other than by jumps.  */\n-\t  for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n-\t    if (REG_NOTE_KIND (note) == REG_LABEL)\n-\t      label_value_list = gen_rtx_EXPR_LIST (VOIDmode, XEXP (note, 0),\n-\t\t\t\t\t\t    label_value_list);\n-\t}\n-\n-      block_number[INSN_UID (insn)] = block;\n-\n-      if (code != NOTE)\n-\tprev_code = code;\n-    }\n-\n-  if (block + 1 != blocks)\n-    abort ();\n-\n-  /* generate all label references to the corresponding jump insn */\n-  for (block = 0; block < blocks; block++)\n-    {\n-      insn = block_end[block];\n-\n-      if (GET_CODE (insn) == JUMP_INSN)\n-\t{\n-\t  rtx pat = PATTERN (insn);\n-\t  rtx x;\n-\n-\t  if (computed_jump_p (insn))\n-\t    {\n-\t      for (x = label_value_list; x; x = XEXP (x, 1))\n-\t\trecord_label_references (insn,\n-\t\t\t\t\t gen_rtx_LABEL_REF (VOIDmode,\n-\t\t\t\t\t\t\t    XEXP (x, 0)));\n-\n-\t      for (x = forced_labels; x; x = XEXP (x, 1))\n-\t\trecord_label_references (insn,\n-\t\t\t\t\t gen_rtx_LABEL_REF (VOIDmode,\n-\t\t\t\t\t\t\t    XEXP (x, 0)));\n-\t    }\n-\n-\t  record_label_references (insn, pat);\n-\t}\n-    }\n-}\n \n /* If current function returns its result in an fp stack register,\n    return the REG.  Otherwise, return 0.  */\n@@ -1217,177 +813,7 @@ stack_result (decl)\n   return result != 0 && STACK_REG_P (result) ? result : 0;\n }\n \f\n-/* Determine the which registers are live at the start of each basic\n-   block of the function whose first insn is FIRST.\n-\n-   First, if the function returns a real_type, mark the function\n-   return type as live at each return point, as the RTL may not give any\n-   hint that the register is live.\n-\n-   Then, start with the last block and work back to the first block.\n-   Similarly, work backwards within each block, insn by insn, recording\n-   which regs are dead and which are used (and therefore live) in the\n-   hard reg set of block_stack_in[].\n-\n-   After processing each basic block, if there is a label at the start\n-   of the block, propagate the live registers to all jumps to this block.\n-\n-   As a special case, if there are regs live in this block, that are\n-   not live in a block containing a jump to this label, and the block\n-   containing the jump has already been processed, we must propagate this\n-   block's entry register life back to the block containing the jump, and\n-   restart life analysis from there.\n-\n-   In the worst case, this function may traverse the insns\n-   REG_STACK_SIZE times.  This is necessary, since a jump towards the end\n-   of the insns may not know that a reg is live at a target that is early\n-   in the insns.  So we back up and start over with the new reg live.\n-\n-   If there are registers that are live at the start of the function,\n-   insns are emitted to initialize these registers.  Something similar is\n-   done after CALL_INSNs in record_reg_life.  */\n-\n-static void\n-stack_reg_life_analysis (first, stackentry)\n-     rtx first;\n-     HARD_REG_SET *stackentry;\n-{\n-  int reg, block;\n-  struct stack_def regstack;\n-\n-  {\n-    rtx retvalue;\n-\n-    if ((retvalue = stack_result (current_function_decl)))\n-      {\n-        /* Find all RETURN insns and mark them.  */\n-\n-        for (block = blocks - 1; --block >= 0;)\n-\t  if (GET_CODE (block_end[block]) == JUMP_INSN\n-\t      && returnjump_p (block_end[block]))\n-\t    mark_regs_pat (retvalue, block_out_reg_set+block);\n-\n-        /* Mark off the end of last block if we \"fall off\" the end of the\n-\t   function into the epilogue.  */\n-\n-        if (GET_CODE (block_end[blocks-1]) != JUMP_INSN\n-\t    || GET_CODE (PATTERN (block_end[blocks-1])) == RETURN)\n-\t  mark_regs_pat (retvalue, block_out_reg_set+blocks-1);\n-      }\n-  }\n-\n-  /* now scan all blocks backward for stack register use */\n-\n-  block = blocks - 1;\n-  while (block >= 0)\n-    {\n-      register rtx insn, prev;\n-\n-      /* current register status at last instruction */\n-\n-      COPY_HARD_REG_SET (regstack.reg_set, block_out_reg_set[block]);\n-\n-      prev = block_end[block];\n-      do\n-\t{\n-\t  insn = prev;\n-\t  prev = PREV_INSN (insn);\n-\n-\t  /* If the insn is a CALL_INSN, we need to ensure that\n-\t     everything dies.  But otherwise don't process unless there\n-\t     are some stack regs present.  */\n-\n-\t  if (stack_regs_mentioned (insn) || GET_CODE (insn) == CALL_INSN)\n-\t    record_reg_life (insn, block, &regstack);\n \n-\t} while (insn != block_begin[block]);\n-\n-      /* Set the state at the start of the block.  Mark that no\n-\t register mapping information known yet.  */\n-\n-      COPY_HARD_REG_SET (block_stack_in[block].reg_set, regstack.reg_set);\n-      block_stack_in[block].top = -2;\n-\n-      /* If there is a label, propagate our register life to all jumps\n-\t to this label.  */\n-\n-      if (GET_CODE (insn) == CODE_LABEL)\n-\t{\n-\t  register rtx label;\n-\t  int must_restart = 0;\n-\n-\t  for (label = LABEL_REFS (insn); label != insn;\n-\t       label = LABEL_NEXTREF (label))\n-\t    {\n-\t      int jump_block = BLOCK_NUM (CONTAINING_INSN (label));\n-\n-\t      if (jump_block < block)\n-\t\tIOR_HARD_REG_SET (block_out_reg_set[jump_block],\n-\t\t\t\t  block_stack_in[block].reg_set);\n-\t      else\n-\t\t{\n-\t\t  /* The block containing the jump has already been\n-\t\t     processed.  If there are registers that were not known\n-\t\t     to be live then, but are live now, we must back up\n-\t\t     and restart life analysis from that point with the new\n-\t\t     life information.  */\n-\n-\t\t  GO_IF_HARD_REG_SUBSET (block_stack_in[block].reg_set,\n-\t\t\t\t\t block_out_reg_set[jump_block],\n-\t\t\t\t\t win);\n-\n-\t\t  IOR_HARD_REG_SET (block_out_reg_set[jump_block],\n-\t\t\t\t    block_stack_in[block].reg_set);\n-\n-\t\t  block = jump_block;\n-\t\t  must_restart = 1;\n-\t\t  break;\n-\n-\t\twin:\n-\t\t  ;\n-\t\t}\n-\t    }\n-\t  if (must_restart)\n-\t    continue;\n-\t}\n-\n-      if (block_drops_in[block])\n-\tIOR_HARD_REG_SET (block_out_reg_set[block-1],\n-\t\t\t  block_stack_in[block].reg_set);\n-\n-      block -= 1;\n-    }\n-\n-  /* If any reg is live at the start of the first block of a\n-     function, then we must guarantee that the reg holds some value by\n-     generating our own \"load\" of that register.  Otherwise a 387 would\n-     fault trying to access an empty register.  */\n-\n-  /* Load zero into each live register.  The fact that a register\n-     appears live at the function start necessarily implies an error\n-     in the user program: it means that (unless the offending code is *never*\n-     executed) this program is using uninitialised floating point\n-     variables.  In order to keep broken code like this happy, we initialise\n-     those variables with zero.\n-\n-     Note that we are inserting virtual register references here:\n-     these insns must be processed by convert_regs later.  Also, these\n-     insns will not be in block_number, so BLOCK_NUM() will fail for them.  */\n-\n-  for (reg = LAST_STACK_REG; reg >= FIRST_STACK_REG; reg--)\n-    if (TEST_HARD_REG_BIT (block_stack_in[0].reg_set, reg)\n-        && ! TEST_HARD_REG_BIT (*stackentry, reg))\n-      {\n-\trtx init_rtx;\n-\n-\tinit_rtx = gen_rtx_SET (VOIDmode, FP_MODE_REG(reg, DFmode),\n-\t\t\t\tCONST0_RTX (DFmode));\n-\tblock_begin[0] = emit_insn_after (init_rtx, first);\n-\n-\tCLEAR_HARD_REG_BIT (block_stack_in[0].reg_set, reg);\n-      }\n-}\n-\f\n /*\n  * This section deals with stack register substitution, and forms the second\n  * pass over the RTL.\n@@ -1482,11 +908,11 @@ delete_insn_for_stacker (insn)\n    cases the movdf pattern to pop.  */\n \n static rtx\n-emit_pop_insn (insn, regstack, reg, when)\n+emit_pop_insn (insn, regstack, reg, where)\n      rtx insn;\n      stack regstack;\n      rtx reg;\n-     rtx (*when)();\n+     enum emit_where where;\n {\n   rtx pop_insn, pop_rtx;\n   int hard_regno;\n@@ -1499,7 +925,10 @@ emit_pop_insn (insn, regstack, reg, when)\n   pop_rtx = gen_rtx_SET (VOIDmode, FP_MODE_REG (hard_regno, DFmode),\n \t\t\t FP_MODE_REG (FIRST_STACK_REG, DFmode));\n \n-  pop_insn = (*when) (pop_rtx, insn);\n+  if (where == EMIT_AFTER)\n+    pop_insn = emit_block_insn_after (pop_rtx, insn, current_block);\n+  else\n+    pop_insn = emit_block_insn_before (pop_rtx, insn, current_block);\n \n   REG_NOTES (pop_insn)\n     = gen_rtx_EXPR_LIST (REG_DEAD, FP_MODE_REG (FIRST_STACK_REG, DFmode),\n@@ -1513,11 +942,10 @@ emit_pop_insn (insn, regstack, reg, when)\n   return pop_insn;\n }\n \f\n-/* Emit an insn before or after INSN to swap virtual register REG with the\n-   top of stack.  WHEN should be `emit_insn_before' or `emit_insn_before'\n-   REGSTACK is the stack state before the swap, and is updated to reflect\n-   the swap.  A swap insn is represented as a PARALLEL of two patterns:\n-   each pattern moves one reg to the other.\n+/* Emit an insn before or after INSN to swap virtual register REG with\n+   the top of stack.  REGSTACK is the stack state before the swap, and\n+   is updated to reflect the swap.  A swap insn is represented as a\n+   PARALLEL of two patterns: each pattern moves one reg to the other.\n \n    If REG is already at the top of the stack, no insn is emitted.  */\n \n@@ -1528,7 +956,7 @@ emit_swap_insn (insn, regstack, reg)\n      rtx reg;\n {\n   int hard_regno;\n-  rtx swap_rtx, swap_insn;\n+  rtx swap_rtx;\n   int tmp, other_reg;\t\t/* swap regno temps */\n   rtx i1;\t\t\t/* the stack-reg insn prior to INSN */\n   rtx i1set = NULL_RTX;\t\t/* the SET rtx within I1 */\n@@ -1546,18 +974,31 @@ emit_swap_insn (insn, regstack, reg)\n   regstack->reg[other_reg] = regstack->reg[regstack->top];\n   regstack->reg[regstack->top] = tmp;\n \n-  /* Find the previous insn involving stack regs, but don't go past\n-     any labels, calls or jumps.  */\n-  i1 = prev_nonnote_insn (insn);\n-  while (i1 && GET_CODE (i1) == INSN && !stack_regs_mentioned (i1))\n-    i1 = prev_nonnote_insn (i1);\n-\n-  if (i1)\n-    i1set = single_set (i1);\n-\n-  if (i1set)\n+  /* Find the previous insn involving stack regs, but don't pass a\n+     block boundary.  */\n+  i1 = NULL;\n+  if (current_block && insn != current_block->head)\n     {\n-      rtx i1src = *get_true_reg (&SET_SRC (i1set));\n+      rtx tmp = PREV_INSN (insn);\n+      while (tmp != current_block->head)\n+\t{\n+\t  if (GET_CODE (tmp) == CODE_LABEL\n+\t      || (GET_CODE (tmp) == NOTE\n+\t\t  && NOTE_LINE_NUMBER (tmp) == NOTE_INSN_BASIC_BLOCK)\n+\t      || (GET_CODE (tmp) == INSN\n+\t\t  && stack_regs_mentioned (tmp)))\n+\t    {\n+\t      i1 = tmp;\n+\t      break;\n+\t    }\n+\t  tmp = PREV_INSN (tmp);\n+\t}\n+    }\n+\n+  if (i1 != NULL_RTX\n+      && (i1set = single_set (i1)) != NULL_RTX)\n+    {\n+      rtx i1src = *get_true_reg (&SET_SRC (i1set));\n       rtx i1dest = *get_true_reg (&SET_DEST (i1set));\n \n       /* If the previous register stack push was from the reg we are to\n@@ -1579,7 +1020,16 @@ emit_swap_insn (insn, regstack, reg)\n \n   swap_rtx = gen_swapxf (FP_MODE_REG (hard_regno, XFmode),\n \t\t\t FP_MODE_REG (FIRST_STACK_REG, XFmode));\n-  swap_insn = emit_insn_after (swap_rtx, i1);\n+\n+  if (i1)\n+    emit_block_insn_after (swap_rtx, i1, current_block);\n+  else if (current_block)\n+    {\n+      i1 = emit_insn_before (swap_rtx, current_block->head);\n+      current_block->head = i1;\n+    }\n+  else\n+    emit_insn_before (swap_rtx, insn);\n }\n \f\n /* Handle a move to or from a stack register in PAT, which is in INSN.\n@@ -1625,7 +1075,7 @@ move_for_stack_reg (insn, regstack, pat)\n \n \t  if (find_regno_note (insn, REG_UNUSED, REGNO (dest)))\n \t    {\n-\t      emit_pop_insn (insn, regstack, src, emit_insn_after);\n+\t      emit_pop_insn (insn, regstack, src, EMIT_AFTER);\n \n \t      delete_insn_for_stacker (insn);\n \t      return;\n@@ -1651,7 +1101,7 @@ move_for_stack_reg (insn, regstack, pat)\n       if (REGNO (src) == REGNO (dest))\n \t{\n \t  if (find_regno_note (insn, REG_UNUSED, REGNO (dest)))\n-\t    emit_pop_insn (insn, regstack, dest, emit_insn_after);\n+\t    emit_pop_insn (insn, regstack, dest, EMIT_AFTER);\n \n \t  delete_insn_for_stacker (insn);\n \t  return;\n@@ -1917,7 +1367,7 @@ compare_for_stack_reg (insn, regstack, pat_src)\n \t  remove_regno_note (insn, REG_DEAD, REGNO (XEXP (src2_note, 0)));\n \n \t  emit_pop_insn (insn, regstack, XEXP (src2_note, 0),\n-\t\t\t emit_insn_after);\n+\t\t\t EMIT_AFTER);\n \t}\n     }\n }\n@@ -1932,318 +1382,370 @@ subst_stack_regs_pat (insn, regstack, pat)\n      rtx pat;\n {\n   rtx *dest, *src;\n-  rtx *src1 = (rtx *) NULL_PTR, *src2;\n-  rtx src1_note, src2_note;\n-  rtx pat_src;\n \n-  if (GET_CODE (pat) != SET)\n-    return;\n+  switch (GET_CODE (pat))\n+    {\n+    case USE:\n+      /* Deaths in USE insns can happen in non optimizing compilation.\n+\t Handle them by popping the dying register.  */\n+      src = get_true_reg (&XEXP (pat, 0));\n+      if (STACK_REG_P (*src) \n+          && find_regno_note (insn, REG_DEAD, REGNO (*src)))\n+        {\n+\t   emit_pop_insn (insn, regstack, *src, EMIT_AFTER);\n+\t   return;\n+        }\n+      /* ??? Uninitialized USE should not happen.  */\n+      else if (get_hard_regnum (regstack, *src) == -1)\n+\tabort();\n+      break;\n \n-  dest = get_true_reg (&SET_DEST (pat));\n-  src  = get_true_reg (&SET_SRC (pat));\n-  pat_src = SET_SRC (pat);\n+    case CLOBBER:\n+      {\n+\trtx note;\n \n-  /* See if this is a `movM' pattern, and handle elsewhere if so.  */\n+\t/* The fix_truncdi_1 pattern wants to be able to allocate it's\n+\t   own scratch register.  It does this by clobbering an fp reg\n+\t   so that it is assured of an empty reg-stack register.\n+\t   If the register is live, kill it now.  Remove the DEAD/UNUSED\n+\t   note so we don't try to kill it later too.  */\n \n-  if (*dest != cc0_rtx\n-      && (STACK_REG_P (*src)\n-\t  || (STACK_REG_P (*dest)\n-\t      && (GET_CODE (*src) == REG || GET_CODE (*src) == MEM\n-\t\t  || GET_CODE (*src) == CONST_DOUBLE))))\n-    move_for_stack_reg (insn, regstack, pat);\n-  else\n-    switch (GET_CODE (pat_src))\n-      {\n-      case COMPARE:\n-\tcompare_for_stack_reg (insn, regstack, pat_src);\n-\tbreak;\n+\tdest = get_true_reg (&XEXP (pat, 0));\n+\tif (STACK_REG_P (*dest))\n+\t  {\n+\t    note = find_reg_note (insn, REG_DEAD, *dest);\n+\t    if (note)\n+\t      emit_pop_insn (insn, regstack, *dest, EMIT_BEFORE);\n+\t    else\n+\t      {\n+\t\tnote = find_reg_note (insn, REG_UNUSED, *dest);\n+\t\tif (!note)\n+\t\t  abort ();\n+\t      }\n \n-      case CALL:\n-\t{\n-\t  int count;\n-\t  for (count = HARD_REGNO_NREGS (REGNO (*dest), GET_MODE (*dest));\n-\t       --count >= 0;)\n-\t    {\n-\t      regstack->reg[++regstack->top] = REGNO (*dest) + count;\n-\t      SET_HARD_REG_BIT (regstack->reg_set, REGNO (*dest) + count);\n-\t    }\n-\t}\n-\treplace_reg (dest, FIRST_STACK_REG);\n+\t    remove_note (insn, note);\n+\t    replace_reg (dest, LAST_STACK_REG);\n+\t  }\n \tbreak;\n+      }\n \n-      case REG:\n-\t/* This is a `tstM2' case.  */\n-\tif (*dest != cc0_rtx)\n-\t  abort ();\n+    case SET:\n+      {\n+\trtx *src1 = (rtx *) NULL_PTR, *src2;\n+\trtx src1_note, src2_note;\n+\trtx pat_src;\n+\n+\tdest = get_true_reg (&SET_DEST (pat));\n+\tsrc  = get_true_reg (&SET_SRC (pat));\n+\tpat_src = SET_SRC (pat);\n+\n+\t/* See if this is a `movM' pattern, and handle elsewhere if so.  */\n+\tif (STACK_REG_P (*src)\n+\t    || (STACK_REG_P (*dest)\n+\t\t&& (GET_CODE (*src) == REG || GET_CODE (*src) == MEM\n+\t\t    || GET_CODE (*src) == CONST_DOUBLE)))\n+\t  {\n+\t    move_for_stack_reg (insn, regstack, pat);\n+\t    break;\n+\t  }\n \n-\tsrc1 = src;\n+\tswitch (GET_CODE (pat_src))\n+\t  {\n+\t  case COMPARE:\n+\t    compare_for_stack_reg (insn, regstack, pat_src);\n+\t    break;\n \n-\t/* Fall through.  */\n+\t  case CALL:\n+\t    {\n+\t      int count;\n+\t      for (count = HARD_REGNO_NREGS (REGNO (*dest), GET_MODE (*dest));\n+\t\t   --count >= 0;)\n+\t\t{\n+\t\t  regstack->reg[++regstack->top] = REGNO (*dest) + count;\n+\t\t  SET_HARD_REG_BIT (regstack->reg_set, REGNO (*dest) + count);\n+\t\t}\n+\t    }\n+\t    replace_reg (dest, FIRST_STACK_REG);\n+\t    break;\n \n-      case FLOAT_TRUNCATE:\n-      case SQRT:\n-      case ABS:\n-      case NEG:\n-\t/* These insns only operate on the top of the stack. DEST might\n-\t   be cc0_rtx if we're processing a tstM pattern. Also, it's\n-\t   possible that the tstM case results in a REG_DEAD note on the\n-\t   source.  */\n+\t  case REG:\n+\t    /* This is a `tstM2' case.  */\n+\t    if (*dest != cc0_rtx)\n+\t      abort ();\n+\t    src1 = src;\n \n-\tif (src1 == 0)\n-\t  src1 = get_true_reg (&XEXP (pat_src, 0));\n+\t    /* Fall through.  */\n \n-\temit_swap_insn (insn, regstack, *src1);\n+\t  case FLOAT_TRUNCATE:\n+\t  case SQRT:\n+\t  case ABS:\n+\t  case NEG:\n+\t    /* These insns only operate on the top of the stack. DEST might\n+\t       be cc0_rtx if we're processing a tstM pattern. Also, it's\n+\t       possible that the tstM case results in a REG_DEAD note on the\n+\t       source.  */\n \n-\tsrc1_note = find_regno_note (insn, REG_DEAD, REGNO (*src1));\n+\t    if (src1 == 0)\n+\t      src1 = get_true_reg (&XEXP (pat_src, 0));\n \n-\tif (STACK_REG_P (*dest))\n-\t  replace_reg (dest, FIRST_STACK_REG);\n+\t    emit_swap_insn (insn, regstack, *src1);\n \n-\tif (src1_note)\n-\t  {\n-\t    replace_reg (&XEXP (src1_note, 0), FIRST_STACK_REG);\n-\t    regstack->top--;\n-\t    CLEAR_HARD_REG_BIT (regstack->reg_set, REGNO (*src1));\n-\t  }\n+\t    src1_note = find_regno_note (insn, REG_DEAD, REGNO (*src1));\n \n-\treplace_reg (src1, FIRST_STACK_REG);\n+\t    if (STACK_REG_P (*dest))\n+\t      replace_reg (dest, FIRST_STACK_REG);\n \n-\tbreak;\n+\t    if (src1_note)\n+\t      {\n+\t\treplace_reg (&XEXP (src1_note, 0), FIRST_STACK_REG);\n+\t\tregstack->top--;\n+\t\tCLEAR_HARD_REG_BIT (regstack->reg_set, REGNO (*src1));\n+\t      }\n \n-      case MINUS:\n-      case DIV:\n-\t/* On i386, reversed forms of subM3 and divM3 exist for\n-\t   MODE_FLOAT, so the same code that works for addM3 and mulM3\n-\t   can be used.  */\n-      case MULT:\n-      case PLUS:\n-\t/* These insns can accept the top of stack as a destination\n-\t   from a stack reg or mem, or can use the top of stack as a\n-\t   source and some other stack register (possibly top of stack)\n-\t   as a destination.  */\n-\n-\tsrc1 = get_true_reg (&XEXP (pat_src, 0));\n-\tsrc2 = get_true_reg (&XEXP (pat_src, 1));\n-\n-\t/* We will fix any death note later.  */\n-\n-\tif (STACK_REG_P (*src1))\n-\t  src1_note = find_regno_note (insn, REG_DEAD, REGNO (*src1));\n-\telse\n-\t  src1_note = NULL_RTX;\n-\tif (STACK_REG_P (*src2))\n-\t  src2_note = find_regno_note (insn, REG_DEAD, REGNO (*src2));\n-\telse\n-\t  src2_note = NULL_RTX;\n-\n-\t/* If either operand is not a stack register, then the dest\n-\t   must be top of stack.  */\n-\n-\tif (! STACK_REG_P (*src1) || ! STACK_REG_P (*src2))\n-\t  emit_swap_insn (insn, regstack, *dest);\n-\telse\n-\t  {\n-\t    /* Both operands are REG.  If neither operand is already\n-\t       at the top of stack, choose to make the one that is the dest\n-\t       the new top of stack.  */\n+\t    replace_reg (src1, FIRST_STACK_REG);\n+\t    break;\n \n-\t    int src1_hard_regnum, src2_hard_regnum;\n+\t  case MINUS:\n+\t  case DIV:\n+\t    /* On i386, reversed forms of subM3 and divM3 exist for\n+\t       MODE_FLOAT, so the same code that works for addM3 and mulM3\n+\t       can be used.  */\n+\t  case MULT:\n+\t  case PLUS:\n+\t    /* These insns can accept the top of stack as a destination\n+\t       from a stack reg or mem, or can use the top of stack as a\n+\t       source and some other stack register (possibly top of stack)\n+\t       as a destination.  */\n+\n+\t    src1 = get_true_reg (&XEXP (pat_src, 0));\n+\t    src2 = get_true_reg (&XEXP (pat_src, 1));\n+\n+\t    /* We will fix any death note later.  */\n+\n+\t    if (STACK_REG_P (*src1))\n+\t      src1_note = find_regno_note (insn, REG_DEAD, REGNO (*src1));\n+\t    else\n+\t      src1_note = NULL_RTX;\n+\t    if (STACK_REG_P (*src2))\n+\t      src2_note = find_regno_note (insn, REG_DEAD, REGNO (*src2));\n+\t    else\n+\t      src2_note = NULL_RTX;\n \n-\t    src1_hard_regnum = get_hard_regnum (regstack, *src1);\n-\t    src2_hard_regnum = get_hard_regnum (regstack, *src2);\n-\t    if (src1_hard_regnum == -1 || src2_hard_regnum == -1)\n-\t      abort ();\n+\t    /* If either operand is not a stack register, then the dest\n+\t       must be top of stack.  */\n \n-\t    if (src1_hard_regnum != FIRST_STACK_REG\n-\t\t&& src2_hard_regnum != FIRST_STACK_REG)\n+\t    if (! STACK_REG_P (*src1) || ! STACK_REG_P (*src2))\n \t      emit_swap_insn (insn, regstack, *dest);\n-\t  }\n+\t    else\n+\t      {\n+\t\t/* Both operands are REG.  If neither operand is already\n+\t\t   at the top of stack, choose to make the one that is the dest\n+\t\t   the new top of stack.  */\n \n-\tif (STACK_REG_P (*src1))\n-\t  replace_reg (src1, get_hard_regnum (regstack, *src1));\n-\tif (STACK_REG_P (*src2))\n-\t  replace_reg (src2, get_hard_regnum (regstack, *src2));\n+\t\tint src1_hard_regnum, src2_hard_regnum;\n \n-\tif (src1_note)\n-\t  {\n-\t    /* If the register that dies is at the top of stack, then\n-\t       the destination is somewhere else - merely substitute it.\n-\t       But if the reg that dies is not at top of stack, then\n-\t       move the top of stack to the dead reg, as though we had\n-\t       done the insn and then a store-with-pop.  */\n+\t\tsrc1_hard_regnum = get_hard_regnum (regstack, *src1);\n+\t\tsrc2_hard_regnum = get_hard_regnum (regstack, *src2);\n+\t\tif (src1_hard_regnum == -1 || src2_hard_regnum == -1)\n+\t\t  abort ();\n \n-\t    if (REGNO (XEXP (src1_note, 0)) == regstack->reg[regstack->top])\n-\t      {\n-\t\tSET_HARD_REG_BIT (regstack->reg_set, REGNO (*dest));\n-\t\treplace_reg (dest, get_hard_regnum (regstack, *dest));\n+\t\tif (src1_hard_regnum != FIRST_STACK_REG\n+\t\t    && src2_hard_regnum != FIRST_STACK_REG)\n+\t\t  emit_swap_insn (insn, regstack, *dest);\n \t      }\n-\t    else\n+\n+\t    if (STACK_REG_P (*src1))\n+\t      replace_reg (src1, get_hard_regnum (regstack, *src1));\n+\t    if (STACK_REG_P (*src2))\n+\t      replace_reg (src2, get_hard_regnum (regstack, *src2));\n+\n+\t    if (src1_note)\n \t      {\n-\t\tint regno = get_hard_regnum (regstack, XEXP (src1_note, 0));\n+\t\trtx src1_reg = XEXP (src1_note, 0);\n \n-\t\tSET_HARD_REG_BIT (regstack->reg_set, REGNO (*dest));\n-\t\treplace_reg (dest, regno);\n+\t\t/* If the register that dies is at the top of stack, then\n+\t\t   the destination is somewhere else - merely substitute it.\n+\t\t   But if the reg that dies is not at top of stack, then\n+\t\t   move the top of stack to the dead reg, as though we had\n+\t\t   done the insn and then a store-with-pop.  */\n \n-\t\tregstack->reg[regstack->top - (regno - FIRST_STACK_REG)]\n-\t\t  = regstack->reg[regstack->top];\n-\t      }\n+\t\tif (REGNO (src1_reg) == regstack->reg[regstack->top])\n+\t\t  {\n+\t\t    SET_HARD_REG_BIT (regstack->reg_set, REGNO (*dest));\n+\t\t    replace_reg (dest, get_hard_regnum (regstack, *dest));\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    int regno = get_hard_regnum (regstack, src1_reg);\n \n-\t    CLEAR_HARD_REG_BIT (regstack->reg_set,\n-\t\t\t\tREGNO (XEXP (src1_note, 0)));\n-\t    replace_reg (&XEXP (src1_note, 0), FIRST_STACK_REG);\n-\t    regstack->top--;\n-\t  }\n-\telse if (src2_note)\n-\t  {\n-\t    if (REGNO (XEXP (src2_note, 0)) == regstack->reg[regstack->top])\n+\t\t    SET_HARD_REG_BIT (regstack->reg_set, REGNO (*dest));\n+\t\t    replace_reg (dest, regno);\n+\n+\t\t    regstack->reg[regstack->top - (regno - FIRST_STACK_REG)]\n+\t\t      = regstack->reg[regstack->top];\n+\t\t  }\n+\n+\t\tCLEAR_HARD_REG_BIT (regstack->reg_set,\n+\t\t\t\t    REGNO (XEXP (src1_note, 0)));\n+\t\treplace_reg (&XEXP (src1_note, 0), FIRST_STACK_REG);\n+\t\tregstack->top--;\n+\t      }\n+\t    else if (src2_note)\n \t      {\n-\t\tSET_HARD_REG_BIT (regstack->reg_set, REGNO (*dest));\n-\t\treplace_reg (dest, get_hard_regnum (regstack, *dest));\n+\t\trtx src2_reg = XEXP (src2_note, 0);\n+\t\tif (REGNO (src2_reg) == regstack->reg[regstack->top])\n+\t\t  {\n+\t\t    SET_HARD_REG_BIT (regstack->reg_set, REGNO (*dest));\n+\t\t    replace_reg (dest, get_hard_regnum (regstack, *dest));\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    int regno = get_hard_regnum (regstack, src2_reg);\n+\n+\t\t    SET_HARD_REG_BIT (regstack->reg_set, REGNO (*dest));\n+\t\t    replace_reg (dest, regno);\n+\n+\t\t    regstack->reg[regstack->top - (regno - FIRST_STACK_REG)]\n+\t\t      = regstack->reg[regstack->top];\n+\t\t  }\n+\n+\t\tCLEAR_HARD_REG_BIT (regstack->reg_set,\n+\t\t\t\t    REGNO (XEXP (src2_note, 0)));\n+\t\treplace_reg (&XEXP (src2_note, 0), FIRST_STACK_REG);\n+\t\tregstack->top--;\n \t      }\n \t    else\n \t      {\n-\t\tint regno = get_hard_regnum (regstack, XEXP (src2_note, 0));\n-\n \t\tSET_HARD_REG_BIT (regstack->reg_set, REGNO (*dest));\n-\t\treplace_reg (dest, regno);\n-\n-\t\tregstack->reg[regstack->top - (regno - FIRST_STACK_REG)]\n-\t\t  = regstack->reg[regstack->top];\n+\t\treplace_reg (dest, get_hard_regnum (regstack, *dest));\n \t      }\n+\t    break;\n \n-\t    CLEAR_HARD_REG_BIT (regstack->reg_set,\n-\t\t\t\tREGNO (XEXP (src2_note, 0)));\n-\t    replace_reg (&XEXP (src2_note, 0), FIRST_STACK_REG);\n-\t    regstack->top--;\n-\t  }\n-\telse\n-\t  {\n-\t    SET_HARD_REG_BIT (regstack->reg_set, REGNO (*dest));\n-\t    replace_reg (dest, get_hard_regnum (regstack, *dest));\n-\t  }\n-\n-\tbreak;\n-\n-      case UNSPEC:\n-\tswitch (XINT (pat_src, 1))\n-\t  {\n-\t  case 1: /* sin */\n-\t  case 2: /* cos */\n-\t    /* These insns only operate on the top of the stack.  */\n+\t  case UNSPEC:\n+\t    switch (XINT (pat_src, 1))\n+\t      {\n+\t      case 1: /* sin */\n+\t      case 2: /* cos */\n+\t\t/* These insns only operate on the top of the stack.  */\n \n-\t    src1 = get_true_reg (&XVECEXP (pat_src, 0, 0));\n+\t\tsrc1 = get_true_reg (&XVECEXP (pat_src, 0, 0));\n \n-\t    emit_swap_insn (insn, regstack, *src1);\n+\t\temit_swap_insn (insn, regstack, *src1);\n \n-\t    src1_note = find_regno_note (insn, REG_DEAD, REGNO (*src1));\n+\t\tsrc1_note = find_regno_note (insn, REG_DEAD, REGNO (*src1));\n \n-\t    if (STACK_REG_P (*dest))\n-\t      replace_reg (dest, FIRST_STACK_REG);\n+\t\tif (STACK_REG_P (*dest))\n+\t\t  replace_reg (dest, FIRST_STACK_REG);\n \n-\t    if (src1_note)\n-\t      {\n-\t\treplace_reg (&XEXP (src1_note, 0), FIRST_STACK_REG);\n-\t\tregstack->top--;\n-\t\tCLEAR_HARD_REG_BIT (regstack->reg_set, REGNO (*src1));\n-\t      }\n+\t\tif (src1_note)\n+\t\t  {\n+\t\t    replace_reg (&XEXP (src1_note, 0), FIRST_STACK_REG);\n+\t\t    regstack->top--;\n+\t\t    CLEAR_HARD_REG_BIT (regstack->reg_set, REGNO (*src1));\n+\t\t  }\n \n-\t    replace_reg (src1, FIRST_STACK_REG);\n+\t\treplace_reg (src1, FIRST_STACK_REG);\n+\t\tbreak;\n \n-\t    break;\n+\t      case 10:\n+\t\t/* (unspec [(unspec [(compare ..)] 9)] 10)\n+\t\t   Unspec 9 is fnstsw; unspec 10 is sahf.  The combination\n+\t\t   matches the PPRO fcomi instruction.  */\n \n-\t  case 10:\n-\t    /* (unspec [(unspec [(compare ..)] 9)] 10)\n-\t       Unspec 9 is fnstsw; unspec 10 is sahf.  The combination\n-\t       matches the PPRO fcomi instruction.  */\n+\t\tpat_src = XVECEXP (pat_src, 0, 0);\n+\t\tif (GET_CODE (pat_src) != UNSPEC\n+\t\t    || XINT (pat_src, 1) != 9)\n+\t\t  abort ();\n+\t\t/* FALLTHRU */\n \n-\t    pat_src = XVECEXP (pat_src, 0, 0);\n-\t    if (GET_CODE (pat_src) != UNSPEC\n-\t\t|| XINT (pat_src, 1) != 9)\n-\t      abort ();\n-\t    /* FALLTHRU */\n+\t      case 9:\n+\t\t/* (unspec [(compare ..)] 9) */\n+\t\t/* Combined fcomp+fnstsw generated for doing well with\n+\t\t   CSE.  When optimizing this would have been broken\n+\t\t   up before now.  */\n \n-\t  case 9:\n-\t    /* (unspec [(compare ..)] 9)\n-\t       Combined fcomp+fnstsw generated for doing well with CSE.\n-\t       When optimizing this would have been broken up before now.  */\n+\t\tpat_src = XVECEXP (pat_src, 0, 0);\n+\t\tif (GET_CODE (pat_src) != COMPARE)\n+\t\t  abort ();\n \n-\t    pat_src = XVECEXP (pat_src, 0, 0);\n-\t    if (GET_CODE (pat_src) != COMPARE)\n-\t      abort ();\n+\t\tcompare_for_stack_reg (insn, regstack, pat_src);\n+\t\tbreak;\n \n-\t    compare_for_stack_reg (insn, regstack, pat_src);\n+\t      default:\n+\t\tabort ();\n+\t      }\n \t    break;\n \n-\t  default:\n-\t    abort ();\n-\t  }\n-\tbreak;\n+\t  case IF_THEN_ELSE:\n+\t    /* This insn requires the top of stack to be the destination. */\n \n-      case IF_THEN_ELSE:\n-\t/* This insn requires the top of stack to be the destination. */\n+\t    /* If the comparison operator is an FP comparison operator,\n+\t       it is handled correctly by compare_for_stack_reg () who\n+\t       will move the destination to the top of stack. But if the\n+\t       comparison operator is not an FP comparison operator, we\n+\t       have to handle it here. */\n+\t    if (get_hard_regnum (regstack, *dest) >= FIRST_STACK_REG\n+\t\t&& REGNO (*dest) != regstack->reg[regstack->top])\n+\t      emit_swap_insn (insn, regstack, *dest);\t\n \n-\t/* If the comparison operator is an FP comparison operator,\n-\t   it is handled correctly by compare_for_stack_reg () who\n-\t   will move the destination to the top of stack. But if the\n-\t   comparison operator is not an FP comparison operator, we\n-\t   have to handle it here. */\n-\tif (get_hard_regnum (regstack, *dest) >= FIRST_STACK_REG\n-\t    && REGNO (*dest) != regstack->reg[regstack->top])\n-\t  emit_swap_insn (insn, regstack, *dest);\t\n+\t    src1 = get_true_reg (&XEXP (pat_src, 1));\n+\t    src2 = get_true_reg (&XEXP (pat_src, 2));\n \n-\tsrc1 = get_true_reg (&XEXP (pat_src, 1));\n-\tsrc2 = get_true_reg (&XEXP (pat_src, 2));\n-\n-\tsrc1_note = find_regno_note (insn, REG_DEAD, REGNO (*src1));\n-\tsrc2_note = find_regno_note (insn, REG_DEAD, REGNO (*src2));\n+\t    src1_note = find_regno_note (insn, REG_DEAD, REGNO (*src1));\n+\t    src2_note = find_regno_note (insn, REG_DEAD, REGNO (*src2));\n \n-\t{\n-\t  rtx src_note [3];\n-\t  int i;\n+\t    {\n+\t      rtx src_note [3];\n+\t      int i;\n \n-\t  src_note[0] = 0;\n-\t  src_note[1] = src1_note;\n-\t  src_note[2] = src2_note;\n+\t      src_note[0] = 0;\n+\t      src_note[1] = src1_note;\n+\t      src_note[2] = src2_note;\n \n-\t  if (STACK_REG_P (*src1))\n-\t    replace_reg (src1, get_hard_regnum (regstack, *src1));\n-\t  if (STACK_REG_P (*src2))\n-\t    replace_reg (src2, get_hard_regnum (regstack, *src2));\n+\t      if (STACK_REG_P (*src1))\n+\t\treplace_reg (src1, get_hard_regnum (regstack, *src1));\n+\t      if (STACK_REG_P (*src2))\n+\t\treplace_reg (src2, get_hard_regnum (regstack, *src2));\n \n-\t  for (i = 1; i <= 2; i++)\n-\t    if (src_note [i])\n-\t      {\n-\t\t/* If the register that dies is not at the top of stack, then\n-\t\t   move the top of stack to the dead reg */\n-\t\tif (REGNO (XEXP (src_note[i], 0))\n-\t\t    != regstack->reg[regstack->top])\n+\t      for (i = 1; i <= 2; i++)\n+\t\tif (src_note [i])\n \t\t  {\n-\t\t    remove_regno_note (insn, REG_DEAD,\n-\t\t\t\t       REGNO (XEXP (src_note [i], 0)));\n-\t\t    emit_pop_insn (insn, regstack, XEXP (src_note[i], 0),\n-\t\t\t\t   emit_insn_after);\n+\t\t    int regno = REGNO (XEXP (src_note[i], 0));\n+\n+\t\t    /* If the register that dies is not at the top of\n+\t\t       stack, then move the top of stack to the dead reg */\n+\t\t    if (regno != regstack->reg[regstack->top])\n+\t\t      {\n+\t\t\tremove_regno_note (insn, REG_DEAD, regno);\n+\t\t\temit_pop_insn (insn, regstack, XEXP (src_note[i], 0),\n+\t\t\t\t       EMIT_AFTER);\n+\t\t      }\n+\t\t    else\n+\t\t      {\n+\t\t\tCLEAR_HARD_REG_BIT (regstack->reg_set, regno);\n+\t\t\treplace_reg (&XEXP (src_note[i], 0), FIRST_STACK_REG);\n+\t\t\tregstack->top--;\n+\t\t      }\n \t\t  }\n-\t\telse\n-\t\t  {\n-\t\t    CLEAR_HARD_REG_BIT (regstack->reg_set,\n-\t\t\t\t\tREGNO (XEXP (src_note[i], 0)));\n-\t\t    replace_reg (&XEXP (src_note[i], 0), FIRST_STACK_REG);\n-\t\t    regstack->top--;\n-\t\t  }\n-\t      }\n-\t}\n+\t    }\n \n-\t/* Make dest the top of stack.  Add dest to regstack if not present. */\n-\tif (get_hard_regnum (regstack, *dest) < FIRST_STACK_REG)\n-\t  regstack->reg[++regstack->top] = REGNO (*dest);\t\n-\tSET_HARD_REG_BIT (regstack->reg_set, REGNO (*dest));\n-\treplace_reg (dest, FIRST_STACK_REG);\n+\t    /* Make dest the top of stack.  Add dest to regstack if\n+\t       not present. */\n+\t    if (get_hard_regnum (regstack, *dest) < FIRST_STACK_REG)\n+\t      regstack->reg[++regstack->top] = REGNO (*dest);\t\n+\t    SET_HARD_REG_BIT (regstack->reg_set, REGNO (*dest));\n+\t    replace_reg (dest, FIRST_STACK_REG);\n+\t    break;\n \n+\t  default:\n+\t    abort ();\n+\t  }\n \tbreak;\n-\n-      default:\n-\tabort ();\n       }\n+\n+    default:\n+      break;\n+    }\n }\n \f\n /* Substitute hard regnums for any stack regs in INSN, which has\n@@ -2278,10 +1780,12 @@ subst_asm_stack_regs (insn, regstack)\n   int i;\n   int n_inputs, n_outputs;\n \n+  if (! check_asm_stack_operands (insn))\n+    return;\n+\n   /* Find out what the constraints required.  If no constraint\n      alternative matches, that is a compiler bug: we should have caught\n-     such an insn during the life analysis pass (and reload should have\n-     caught it regardless).  */\n+     such an insn in check_asm_stack_operands.  */\n   extract_insn (insn);\n   constrain_operands (1);\n   alt = which_alternative;\n@@ -2366,7 +1870,7 @@ subst_asm_stack_regs (insn, regstack)\n \t  }\n     }\n \n-  bcopy ((char *) regstack, (char *) &temp_stack, sizeof (temp_stack));\n+  temp_stack = *regstack;\n \n   /* Put the input regs into the desired place in TEMP_STACK.  */\n \n@@ -2406,10 +1910,10 @@ subst_asm_stack_regs (insn, regstack)\n \t  }\n       }\n \n-  /* emit insns before INSN to make sure the reg-stack is in the right\n+  /* Emit insns before INSN to make sure the reg-stack is in the right\n      order.  */\n \n-  change_stack (insn, regstack, &temp_stack, emit_insn_before);\n+  change_stack (insn, regstack, &temp_stack, EMIT_BEFORE);\n \n   /* Make the needed input register substitutions.  Do death notes and\n      clobbers too, because these are for inputs, not outputs.  */\n@@ -2515,7 +2019,7 @@ subst_asm_stack_regs (insn, regstack)\n \t      && note_kind[j] == REG_UNUSED)\n \t    {\n \t      insn = emit_pop_insn (insn, regstack, recog_data.operand[i],\n-\t\t\t\t    emit_insn_after);\n+\t\t\t\t    EMIT_AFTER);\n \t      break;\n \t    }\n       }\n@@ -2532,7 +2036,7 @@ subst_asm_stack_regs (insn, regstack)\n \t\t\t\t    REGNO (recog_data.operand[i])))\n \t    {\n \t      insn = emit_pop_insn (insn, regstack, recog_data.operand[i],\n-\t\t\t\t    emit_insn_after);\n+\t\t\t\t    EMIT_AFTER);\n \t      break;\n \t    }\n       }\n@@ -2619,7 +2123,7 @@ subst_stack_regs (insn, regstack)\n     if (REG_NOTE_KIND (note) == REG_UNUSED && STACK_REG_P (XEXP (note, 0)))\n       {\n \t*note_link = XEXP (note, 1);\n-\tinsn = emit_pop_insn (insn, regstack, XEXP (note, 0), emit_insn_after);\n+\tinsn = emit_pop_insn (insn, regstack, XEXP (note, 0), EMIT_AFTER);\n       }\n     else\n       note_link = &XEXP (note, 1);\n@@ -2629,44 +2133,48 @@ subst_stack_regs (insn, regstack)\n    block.  Some registers might have to be popped, but there can never be\n    a register live in the new block that is not now live.\n \n-   Insert any needed insns before or after INSN.  WHEN is emit_insn_before\n-   or emit_insn_after. OLD is the original stack layout, and NEW is\n-   the desired form.  OLD is updated to reflect the code emitted, ie, it\n-   will be the same as NEW upon return.\n+   Insert any needed insns before or after INSN, as indicated by\n+   WHERE.  OLD is the original stack layout, and NEW is the desired\n+   form.  OLD is updated to reflect the code emitted, ie, it will be\n+   the same as NEW upon return.\n \n    This function will not preserve block_end[].  But that information\n    is no longer needed once this has executed.  */\n \n static void\n-change_stack (insn, old, new, when)\n+change_stack (insn, old, new, where)\n      rtx insn;\n      stack old;\n      stack new;\n-     rtx (*when)();\n+     enum emit_where where;\n {\n   int reg;\n+  int update_end = 0;\n \n-  /* We will be inserting new insns \"backwards\", by calling emit_insn_before.\n-     If we are to insert after INSN, find the next insn, and insert before\n-     it.  */\n+  /* We will be inserting new insns \"backwards\".  If we are to insert\n+     after INSN, find the next insn, and insert before it.  */\n \n-  if (when == emit_insn_after)\n-    insn = NEXT_INSN (insn);\n+  if (where == EMIT_AFTER)\n+    {\n+      if (current_block && current_block->end == insn)\n+\tupdate_end = 1;\n+      insn = NEXT_INSN (insn);\n+    }\n \n   /* Pop any registers that are not needed in the new block.  */\n \n   for (reg = old->top; reg >= 0; reg--)\n     if (! TEST_HARD_REG_BIT (new->reg_set, old->reg[reg]))\n       emit_pop_insn (insn, old, FP_MODE_REG (old->reg[reg], DFmode),\n-\t\t     emit_insn_before);\n+\t\t     EMIT_BEFORE);\n \n   if (new->top == -2)\n     {\n       /* If the new block has never been processed, then it can inherit\n \t the old stack order.  */\n \n       new->top = old->top;\n-      bcopy (old->reg, new->reg, sizeof (new->reg));\n+      memcpy (new->reg, old->reg, sizeof (new->reg));\n     }\n   else\n     {\n@@ -2677,11 +2185,8 @@ change_stack (insn, old, new, when)\n \t not their depth or liveliness.  */\n \n       GO_IF_HARD_REG_EQUAL (old->reg_set, new->reg_set, win);\n-\n       abort ();\n-\n     win:\n-\n       if (old->top != new->top)\n \tabort ();\n \n@@ -2732,338 +2237,430 @@ change_stack (insn, old, new, when)\n \tif (old->reg[reg] != new->reg[reg])\n \t  abort ();\n     }\n+\n+  if (update_end)\n+    current_block->end = PREV_INSN (insn);\n }\n \f\n-/* Check PAT, which points to RTL in INSN, for a LABEL_REF.  If it is\n-   found, ensure that a jump from INSN to the code_label to which the\n-   label_ref points ends up with the same stack as that at the\n-   code_label.  Do this by inserting insns just before the code_label to\n-   pop and rotate the stack until it is in the correct order.  REGSTACK\n-   is the order of the register stack in INSN.\n-\n-   Any code that is emitted here must not be later processed as part\n-   of any block, as it will already contain hard register numbers.  */\n+/* Print stack configuration.  */\n \n static void\n-goto_block_pat (insn, regstack, pat)\n-     rtx insn;\n-     stack regstack;\n-     rtx pat;\n+print_stack (file, s)\n+     FILE *file;\n+     stack s;\n {\n-  rtx label;\n-  rtx new_jump, new_label, new_barrier;\n-  rtx *ref;\n-  stack label_stack;\n-  struct stack_def temp_stack;\n-  int reg;\n+  if (! file)\n+    return;\n \n-  switch (GET_CODE (pat))\n+  if (s->top == -2)\n+    fprintf (file, \"uninitialized\\n\");\n+  else if (s->top == -1)\n+    fprintf (file, \"empty\\n\");\n+  else\n     {\n-    case RETURN:\n-      straighten_stack (PREV_INSN (insn), regstack);\n-      return;\n-    default:\n-      {\n-\tint i, j;\n-\tconst char *fmt = GET_RTX_FORMAT (GET_CODE (pat));\n-\n-\tfor (i = GET_RTX_LENGTH (GET_CODE (pat)) - 1; i >= 0; i--)\n-\t  {\n-\t    if (fmt[i] == 'e')\n-\t      goto_block_pat (insn, regstack, XEXP (pat, i));\n-\t    if (fmt[i] == 'E')\n-\t      for (j = 0; j < XVECLEN (pat, i); j++)\n-\t\tgoto_block_pat (insn, regstack, XVECEXP (pat, i, j));\n-\t  }\n-\treturn;\n-      }\n-    case LABEL_REF:;\n+      int i;\n+      fputs (\"[ \", file);\n+      for (i = 0; i <= s->top; ++i)\n+\tfprintf (file, \"%d \", s->reg[i]);\n+      fputs (\"]\\n\", file);\n     }\n+}\n+\f\n+/* This function was doing life analysis.  We now let the regular live\n+   code do it's job, so we only need to check some extra invariants \n+   that reg-stack expects.  Primary among these being that all registers\n+   are initialized before use.\n \n-  label = XEXP (pat, 0);\n-  if (GET_CODE (label) != CODE_LABEL)\n-    abort ();\n-\n-  /* First, see if in fact anything needs to be done to the stack at all.  */\n-  if (INSN_UID (label) <= 0)\n-    return;\n+   The function returns true when code was emitted to CFG edges and\n+   commit_edge_insertions needs to be called.  */\n \n-  label_stack = &block_stack_in[BLOCK_NUM (label)];\n+static int\n+convert_regs_entry ()\n+{\n+  int inserted = 0, i;\n+  edge e;\n \n-  if (label_stack->top == -2)\n+  for (i = n_basic_blocks - 1; i >= 0; --i)\n     {\n-      /* If the target block hasn't had a stack order selected, then\n-\t we need merely ensure that no pops are needed.  */\n-\n-      for (reg = regstack->top; reg >= 0; reg--)\n-\tif (! TEST_HARD_REG_BIT (label_stack->reg_set, regstack->reg[reg]))\n-\t  break;\n-\n-      if (reg == -1)\n+      basic_block block = BASIC_BLOCK (i);\n+      block_info bi = BLOCK_INFO (block);\n+      int reg;\n+      \n+      /* Set current register status at last instruction `uninitialized'.  */\n+      bi->stack_in.top = -2;\n+  \n+      /* Copy live_at_end and live_at_start into temporaries.  */\n+      for (reg = FIRST_STACK_REG; reg <= LAST_STACK_REG; reg++)\n \t{\n-\t  /* change_stack will not emit any code in this case.  */\n-\n-\t  change_stack (label, regstack, label_stack, emit_insn_after);\n-\t  return;\n+\t  if (REGNO_REG_SET_P (block->global_live_at_end, reg))\n+\t    SET_HARD_REG_BIT (bi->out_reg_set, reg);\n+\t  if (REGNO_REG_SET_P (block->global_live_at_start, reg))\n+\t    SET_HARD_REG_BIT (bi->stack_in.reg_set, reg);\n \t}\n     }\n-  else if (label_stack->top == regstack->top)\n-    {\n-      for (reg = label_stack->top; reg >= 0; reg--)\n-\tif (label_stack->reg[reg] != regstack->reg[reg])\n-\t  break;\n-\n-      if (reg == -1)\n-\treturn;\n-    }\n \n-  /* At least one insn will need to be inserted before label.  Insert\n-     a jump around the code we are about to emit.  Emit a label for the new\n-     code, and point the original insn at this new label. We can't use\n-     redirect_jump here, because we're using fld[4] of the code labels as\n-     LABEL_REF chains, no NUSES counters.  */\n+  /* Load something into each stack register live at function entry. \n+     Such live registers can be caused by uninitialized variables or\n+     functions not returning values on all paths.  In order to keep \n+     the push/pop code happy, and to not scrog the register stack, we\n+     must put something in these registers.  Use a QNaN.  \n \n-  new_jump = emit_jump_insn_before (gen_jump (label), label);\n-  record_label_references (new_jump, PATTERN (new_jump));\n-  JUMP_LABEL (new_jump) = label;\n+     Note that we are insertting converted code here.  This code is\n+     never seen by the convert_regs pass.  */\n \n-  new_barrier = emit_barrier_after (new_jump);\n+  for (e = ENTRY_BLOCK_PTR->succ; e ; e = e->succ_next)\n+    {\n+      basic_block block = e->dest;\n+      block_info bi = BLOCK_INFO (block);\n+      int reg, top = -1;\n \n-  new_label = gen_label_rtx ();\n-  emit_label_after (new_label, new_barrier);\n-  LABEL_REFS (new_label) = new_label;\n+      for (reg = LAST_STACK_REG; reg >= FIRST_STACK_REG; --reg)\n+\tif (TEST_HARD_REG_BIT (bi->stack_in.reg_set, reg))\n+\t  {\n+\t    rtx init;\n \n-  /* The old label_ref will no longer point to the code_label if now uses,\n-     so strip the label_ref from the code_label's chain of references.  */\n+\t    bi->stack_in.reg[++top] = reg;\n \n-  for (ref = &LABEL_REFS (label); *ref != label; ref = &LABEL_NEXTREF (*ref))\n-    if (*ref == pat)\n-      break;\n+\t    init = gen_rtx_SET (VOIDmode,\n+\t\t\t\tFP_MODE_REG (FIRST_STACK_REG, SFmode),\n+\t\t\t\tnan);\n+\t    insert_insn_on_edge (init, e);\n+\t    inserted = 1;\n+\t  }\n \n-  if (*ref == label)\n-    abort ();\n+      bi->stack_in.top = top;\n+    }\n \n-  *ref = LABEL_NEXTREF (*ref);\n+  return inserted;\n+}\n \n-  XEXP (pat, 0) = new_label;\n-  record_label_references (insn, PATTERN (insn));\n+/* Construct the desired stack for function exit.  This will either\n+   be `empty', or the function return value at top-of-stack.  */\n \n-  if (JUMP_LABEL (insn) == label)\n-    JUMP_LABEL (insn) = new_label;\n+static void\n+convert_regs_exit ()\n+{\n+  int value_reg_low, value_reg_high;\n+  stack output_stack;\n+  rtx retvalue;\n \n-  /* Now emit the needed code.  */\n+  retvalue = stack_result (current_function_decl);\n+  value_reg_low = value_reg_high = -1;\n+  if (retvalue)\n+    {\n+      value_reg_low = REGNO (retvalue);\n+      value_reg_high = value_reg_low\n+\t+ HARD_REGNO_NREGS (value_reg_low, GET_MODE (retvalue)) - 1;\n+    }\n \n-  temp_stack = *regstack;\n+  output_stack = &BLOCK_INFO (EXIT_BLOCK_PTR)->stack_in;\n+  if (value_reg_low == -1)\n+    output_stack->top = -1;\n+  else\n+    {\n+      int reg;\n \n-  change_stack (new_label, &temp_stack, label_stack, emit_insn_after);\n+      output_stack->top = value_reg_high - value_reg_low;\n+      for (reg = value_reg_low; reg <= value_reg_high; ++reg)\n+\t{\n+\t  output_stack->reg[reg - value_reg_low] = reg;\n+\t  SET_HARD_REG_BIT (output_stack->reg_set, reg);\n+\t}\n+    }\n }\n-\f\n-/* Traverse all basic blocks in a function, converting the register\n-   references in each insn from the \"flat\" register file that gcc uses, to\n-   the stack-like registers the 387 uses.  */\n \n-static void\n-convert_regs ()\n+/* Convert stack register references in one block.  */\n+\n+static int\n+convert_regs_1 (file, block)\n+     FILE *file;\n+     basic_block block;\n {\n-  register int block, reg;\n-  register rtx insn, next;\n-  struct stack_def regstack;\n+  struct stack_def regstack, tmpstack;\n+  block_info bi = BLOCK_INFO (block);\n+  int inserted, reg;\n+  rtx insn, next;\n+  edge e;\n \n-  for (block = 0; block < blocks; block++)\n+  current_block = block;\n+  \n+  if (file)\n     {\n-      if (block_stack_in[block].top == -2)\n-\t{\n-\t  /* This block has not been previously encountered.  Choose a\n-\t     default mapping for any stack regs live on entry */\n+      fprintf (file, \"\\nBasic block %d\\nInput stack: \", block->index);\n+      print_stack (file, &bi->stack_in);\n+    }\n \n-\t  block_stack_in[block].top = -1;\n+  /* Process all insns in this block.  Keep track of NEXT so that we\n+     don't process insns emitted while substituting in INSN.  */\n+  next = block->head;\n+  regstack = bi->stack_in;\n+  do\n+    {\n+      insn = next;\n+      next = NEXT_INSN (insn);\n \n-\t  for (reg = LAST_STACK_REG; reg >= FIRST_STACK_REG; reg--)\n-\t    if (TEST_HARD_REG_BIT (block_stack_in[block].reg_set, reg))\n-\t      block_stack_in[block].reg[++block_stack_in[block].top] = reg;\n+      /* Ensure we have not missed a block boundary.  */\n+      if (next == NULL)\n+\tabort ();\n+      if (insn == block->end)\n+\tnext = NULL;\n+\n+      /* Don't bother processing unless there is a stack reg\n+\t mentioned or if it's a CALL_INSN.  */\n+      if (stack_regs_mentioned (insn)\n+\t  || GET_CODE (insn) == CALL_INSN)\n+\t{\n+\t  if (file)\n+\t    {\n+\t      fprintf (file, \"  insn %d input stack: \",\n+\t\t       INSN_UID (insn));\n+\t      print_stack (file, &regstack);\n+\t    }\n+\t  subst_stack_regs (insn, &regstack);\n \t}\n+    }\n+  while (next);\n \n-      /* Process all insns in this block.  Keep track of `next' here,\n-\t so that we don't process any insns emitted while making\n-\t substitutions in INSN.  */\n+  if (file)\n+    {\n+      fprintf (file, \"Expected live registers [\");\n+      for (reg = FIRST_STACK_REG; reg <= LAST_STACK_REG; ++reg)\n+\tif (TEST_HARD_REG_BIT (bi->out_reg_set, reg))\n+\t  fprintf (file, \" %d\", reg);\n+      fprintf (file, \" ]\\nOutput stack: \");\n+      print_stack (file, &regstack);\n+    }\n \n-      next = block_begin[block];\n-      regstack = block_stack_in[block];\n-      do\n+  insn = block->end;\n+  if (GET_CODE (insn) == JUMP_INSN)\n+    insn = PREV_INSN (insn);\n+\n+  /* If the function is declared to return a value, but it returns one\n+     in only some cases, some registers might come live here.  Emit\n+     necessary moves for them.  */\n+\n+  for (reg = FIRST_STACK_REG; reg <= LAST_STACK_REG; ++reg)\n+    {\n+      if (TEST_HARD_REG_BIT (bi->out_reg_set, reg)\n+\t  && ! TEST_HARD_REG_BIT (regstack.reg_set, reg))\n \t{\n-\t  insn = next;\n-\t  next = NEXT_INSN (insn);\n+\t  rtx set;\n \n-\t  /* Don't bother processing unless there is a stack reg\n-\t     mentioned or if it's a CALL_INSN (register passing of\n-\t     floating point values).  */\n+\t  if (file)\n+\t    {\n+\t      fprintf (file, \"Emitting insn initializing reg %d\\n\",\n+\t\t       reg);\n+\t    }\n \n-\t  if (stack_regs_mentioned (insn) || GET_CODE (insn) == CALL_INSN)\n-\t    subst_stack_regs (insn, &regstack);\n+\t  set = gen_rtx_SET (VOIDmode, FP_MODE_REG (reg, SFmode),\n+\t\t\t     nan);\n+\t  insn = emit_block_insn_after (set, insn, block);\n+\t  subst_stack_regs (insn, &regstack);\n+\t}\n+    }\n \n-\t} while (insn != block_end[block]);\n-      \n-      /* For all further actions, INSN needs to be the last insn in\n-         this basic block.  If subst_stack_regs inserted additional\n-         instructions after INSN, it is no longer the last one at\n-         this point.  */\n-      next = PREV_INSN (next);\n-\n-      /* If subst_stack_regs inserted something after a JUMP_INSN, that\n-         is almost certainly a bug.  */\n-      if (GET_CODE (insn) == JUMP_INSN && insn != next)\n-\tabort ();\n-      insn = next;\n+  /* Something failed if the stack lives don't match.  */\n+  GO_IF_HARD_REG_EQUAL (regstack.reg_set, bi->out_reg_set, win);\n+  abort ();\n+ win:\n \n-      /* Something failed if the stack life doesn't match.  */\n+  /* Adjust the stack of this block on exit to match the stack of the\n+     target block, or copy stack info into the stack of the successor\n+     of the successor hasn't been processed yet.  */\n+  inserted = 0;\n+  for (e = block->succ; e ; e = e->succ_next)\n+    {\n+      basic_block target = e->dest;\n+      stack target_stack = &BLOCK_INFO (target)->stack_in;\n \n-      GO_IF_HARD_REG_EQUAL (regstack.reg_set, block_out_reg_set[block], win);\n+      if (file)\n+\tfprintf (file, \"Edge to block %d: \", target->index);\n \n-      abort ();\n+      if (target_stack->top == -2)\n+\t{\n+\t  /* The target block hasn't had a stack order selected.\n+\t     We need merely ensure that no pops are needed.  */\n+\t  for (reg = regstack.top; reg >= 0; --reg)\n+\t    if (! TEST_HARD_REG_BIT (target_stack->reg_set,\n+\t\t\t\t     regstack.reg[reg]))\n+\t      break;\n \n-    win:\n+\t  if (reg == -1)\n+\t    {\n+\t      if (file)\n+\t\tfprintf (file, \"new block; copying stack position\\n\");\n \n-      /* Adjust the stack of this block on exit to match the stack of\n-\t the target block, or copy stack information into stack of\n-\t jump target if the target block's stack order hasn't been set\n-\t yet.  */\n+\t      /* change_stack kills values in regstack.  */\n+\t      tmpstack = regstack;\n \n-      if (GET_CODE (insn) == JUMP_INSN)\n-\tgoto_block_pat (insn, &regstack, PATTERN (insn));\n+\t      change_stack (block->end, &tmpstack,\n+\t\t\t    target_stack, EMIT_AFTER);\n+\t      continue;\n+\t    }\n \n-      /* Likewise handle the case where we fall into the next block.  */\n+\t  if (file)\n+\t    fprintf (file, \"new block; pops needed\\n\");\n+\t}\n+      else\n+\t{\n+\t  if (target_stack->top == regstack.top)\n+\t    {\n+\t      for (reg = target_stack->top; reg >= 0; --reg)\n+\t\tif (target_stack->reg[reg] != regstack.reg[reg])\n+\t\t  break;\n \n-      if ((block < blocks - 1) && block_drops_in[block+1])\n-\tchange_stack (insn, &regstack, &block_stack_in[block+1],\n-\t\t      emit_insn_after);\n-    }\n+\t      if (reg == -1)\n+\t\t{\n+\t\t  if (file)\n+\t\t    fprintf (file, \"no changes needed\\n\");\n+\t\t  continue;\n+\t\t}\n+\t    }\n \n-  /* If the last basic block is the end of a loop, and that loop has\n-     regs live at its start, then the last basic block will have regs live\n-     at its end that need to be popped before the function returns.  */\n+\t  if (file)\n+\t    {\n+\t      fprintf (file, \"correcting stack to \");\n+\t      print_stack (file, target_stack);\n+\t    }\n+\t}\n \n-  {\n-    int value_reg_low, value_reg_high;\n-    value_reg_low = value_reg_high = -1;\n-    {\n-      rtx retvalue;\n-      if ((retvalue = stack_result (current_function_decl)))\n+      /* It is better to output directly to the end of the block\n+\t instead of to the edge, because emit_swap can do minimal\n+\t insn scheduling.  We can do this when there is only one\n+\t edge out, and it is not abnormal.  */\n+      if (block->succ->succ_next == NULL\n+\t  && ! (e->flags & EDGE_ABNORMAL))\n \t{\n-\t  value_reg_low = REGNO (retvalue);\n-\t  value_reg_high = value_reg_low +\n-\t    HARD_REGNO_NREGS (value_reg_low, GET_MODE (retvalue)) - 1;\n+\t  /* change_stack kills values in regstack.  */\n+\t  tmpstack = regstack;\n+\n+\t  change_stack (block->end, &tmpstack, target_stack,\n+\t\t\t(GET_CODE (block->end) == JUMP_INSN\n+\t\t\t ? EMIT_BEFORE : EMIT_AFTER));\n \t}\n+      else\n+\t{\n+\t  rtx seq, after;\n+\n+\t  /* We don't support abnormal edges.  Global takes\n+\t     care to avoid any live register across them, so\n+\t     we should never have to.  */\n+\t  if (e->flags & EDGE_ABNORMAL)\n+\t    abort ();\n+\n+\t  current_block = NULL;\n+\t  start_sequence ();\n+\t\t  \n+\t  /* ??? change_stack needs some point to emit insns after. \n+\t     Also needed to keep gen_sequence from returning a \n+\t     pattern as opposed to a sequence, which would lose\n+\t     REG_DEAD notes.  */\n+\t  after = emit_note (NULL, NOTE_INSN_DELETED);\n+\n+\t  tmpstack = regstack;\n+\t  change_stack (after, &tmpstack, target_stack, EMIT_BEFORE);\n \n+\t  seq = gen_sequence ();\n+\t  end_sequence ();\n+\n+\t  insert_insn_on_edge (seq, e);\n+\t  inserted = 1;\n+\t  current_block = block;\n+\t}\n     }\n-    for (reg = regstack.top; reg >= 0; reg--)\n-      if (regstack.reg[reg] < value_reg_low\n-\t  || regstack.reg[reg] > value_reg_high)\n-\tinsn = emit_pop_insn (insn, &regstack,\n-\t\t\t      FP_MODE_REG (regstack.reg[reg], DFmode),\n-\t\t\t      emit_insn_after);\n-  }\n-  straighten_stack (insn, &regstack);\n+\n+  return inserted;\n }\n-\f\n-/* Check expression PAT, which is in INSN, for label references.  if\n-   one is found, print the block number of destination to FILE.  */\n \n-static void\n-print_blocks (file, insn, pat)\n+/* Convert registers in all blocks reachable from BLOCK.  */\n+\n+static int\n+convert_regs_2 (file, block)\n      FILE *file;\n-     rtx insn, pat;\n+     basic_block block;\n {\n-  register RTX_CODE code = GET_CODE (pat);\n-  register int i;\n-  register const char *fmt;\n+  basic_block *stack, *sp;\n+  int inserted;\n \n-  if (code == LABEL_REF)\n-    {\n-      register rtx label = XEXP (pat, 0);\n+  stack = (basic_block *) alloca (sizeof (*stack) * n_basic_blocks);\n+  sp = stack;\n \n-      if (GET_CODE (label) != CODE_LABEL)\n-\tabort ();\n+  *sp++ = block;\n+  BLOCK_INFO (block)->done = 1;\n \n-      fprintf (file, \" %d\", BLOCK_NUM (label));\n+  inserted = 0;\n+  do\n+    {\n+      edge e;\n \n-      return;\n-    }\n+      block = *--sp;\n+      inserted |= convert_regs_1 (file, block);\n \n-  fmt = GET_RTX_FORMAT (code);\n-  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n-    {\n-      if (fmt[i] == 'e')\n-\tprint_blocks (file, insn, XEXP (pat, i));\n-      if (fmt[i] == 'E')\n-\t{\n-\t  register int j;\n-\t  for (j = 0; j < XVECLEN (pat, i); j++)\n-\t    print_blocks (file, insn, XVECEXP (pat, i, j));\n-\t}\n+      for (e = block->succ; e ; e = e->succ_next)\n+\tif (! BLOCK_INFO (e->dest)->done)\n+\t  {\n+\t    *sp++ = e->dest;\n+\t    BLOCK_INFO (e->dest)->done = 1;\n+\t  }\n     }\n+  while (sp != stack);\n+\n+  return inserted;\n }\n-\f\n-/* Write information about stack registers and stack blocks into FILE.\n-   This is part of making a debugging dump.  */\n \n-static void\n-dump_stack_info (file)\n+/* Traverse all basic blocks in a function, converting the register\n+   references in each insn from the \"flat\" register file that gcc uses,\n+   to the stack-like registers the 387 uses.  */\n+\n+static int\n+convert_regs (file)\n      FILE *file;\n {\n-  register int block;\n+  int inserted, i;\n+  edge e;\n \n-  fprintf (file, \"\\n%d stack blocks.\\n\", blocks);\n-  for (block = 0; block < blocks; block++)\n-    {\n-      register rtx head, jump, end;\n-      register int regno;\n+  /* Initialize uninitialized registers on function entry.  */\n+  inserted = convert_regs_entry ();\n \n-      fprintf (file, \"\\nStack block %d: first insn %d, last %d.\\n\",\n-\t       block, INSN_UID (block_begin[block]),\n-\t       INSN_UID (block_end[block]));\n+  /* Construct the desired stack for function exit.  */\n+  convert_regs_exit ();\n+  BLOCK_INFO (EXIT_BLOCK_PTR)->done = 1;\n \n-      head = block_begin[block];\n+  /* ??? Future: process inner loops first, and give them arbitrary\n+     initial stacks which emit_swap_insn can modify.  This ought to\n+     prevent double fxch that aften appears at the head of a loop.  */\n \n-      fprintf (file, \"Reached from blocks: \");\n-      if (GET_CODE (head) == CODE_LABEL)\n-\tfor (jump = LABEL_REFS (head);\n-\t     jump != head;\n-\t     jump = LABEL_NEXTREF (jump))\n-\t  {\n-\t    register int from_block = BLOCK_NUM (CONTAINING_INSN (jump));\n-\t    fprintf (file, \" %d\", from_block);\n-\t  }\n-      if (block_drops_in[block])\n-\tfprintf (file, \" previous\");\n+  /* Process all blocks reachable from all entry points.  */\n+  for (e = ENTRY_BLOCK_PTR->succ; e ; e = e->succ_next)\n+    inserted |= convert_regs_2 (file, e->dest);\n+  \n+  /* ??? Process all unreachable blocks.  Though there's no excuse \n+     for keeping these even when not optimizing.  */\n+  for (i = 0; i < n_basic_blocks; ++i)\n+    {\n+      basic_block b = BASIC_BLOCK (i);\n+      block_info bi = BLOCK_INFO (b);\n \n-      fprintf (file, \"\\nlive stack registers on block entry: \");\n-      for (regno = FIRST_STACK_REG; regno <= LAST_STACK_REG; regno++)\n+      if (! bi->done)\n \t{\n-\t  if (TEST_HARD_REG_BIT (block_stack_in[block].reg_set, regno))\n-\t    fprintf (file, \"%d \", regno);\n-\t}\n+\t  int reg;\n \n-      fprintf (file, \"\\nlive stack registers on block exit: \");\n-      for (regno = FIRST_STACK_REG; regno <= LAST_STACK_REG; regno++)\n-\t{\n-\t  if (TEST_HARD_REG_BIT (block_out_reg_set[block], regno))\n-\t    fprintf (file, \"%d \", regno);\n-\t}\n+\t  /* Create an arbitrary input stack.  */\n+\t  bi->stack_in.top = -1;\n+\t  for (reg = LAST_STACK_REG; reg >= FIRST_STACK_REG; --reg)\n+\t    if (TEST_HARD_REG_BIT (bi->stack_in.reg_set, reg))\n+\t      bi->stack_in.reg[++bi->stack_in.top] = reg;\n \n-      end = block_end[block];\n+\t  inserted |= convert_regs_2 (file, b);\n+\t}\n+    }\n \n-      fprintf (file, \"\\nJumps to blocks: \");\n-      if (GET_CODE (end) == JUMP_INSN)\n-\tprint_blocks (file, end, PATTERN (end));\n+  if (inserted)\n+    commit_edge_insertions ();\n \n-      if (block + 1 < blocks && block_drops_in[block+1])\n-\tfprintf (file, \" next\");\n-      else if (block + 1 == blocks\n-\t       || (GET_CODE (end) == JUMP_INSN\n-\t\t   && GET_CODE (PATTERN (end)) == RETURN))\n-\tfprintf (file, \" return\");\n+  if (file)\n+    fputc ('\\n', file);\n \n-      fprintf (file, \"\\n\");\n-    }\n+  return inserted;\n }\n #endif /* STACK_REGS */"}, {"sha": "ccc89eb9424d76705b1fd70c99e4cf48b81b39e0", "filename": "gcc/rtl.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a05924f91bc802882777615e301bb79fda1f4035/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a05924f91bc802882777615e301bb79fda1f4035/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=a05924f91bc802882777615e301bb79fda1f4035", "patch": "@@ -1410,9 +1410,10 @@ extern int condjump_in_parallel_p\tPROTO ((rtx));\n extern void never_reached_warning\tPROTO ((rtx));\n \n /* Flags for jump_optimize() */\n-#define JUMP_CROSS_JUMP\t\t1\n-#define JUMP_NOOP_MOVES\t\t1\n-#define JUMP_AFTER_REGSCAN\t1\n+#define JUMP_CROSS_JUMP\t\t\t1\n+#define JUMP_CROSS_JUMP_DEATH_MATTERS\t2\n+#define JUMP_NOOP_MOVES\t\t\t1\n+#define JUMP_AFTER_REGSCAN\t\t1\n \n /* In emit-rtl.c. */\n extern int max_reg_num\t\t\t\tPROTO ((void));"}]}