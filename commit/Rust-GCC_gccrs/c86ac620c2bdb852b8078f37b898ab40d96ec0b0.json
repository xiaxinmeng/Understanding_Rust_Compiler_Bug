{"sha": "c86ac620c2bdb852b8078f37b898ab40d96ec0b0", "node_id": "C_kwDOANBUbNoAKGM4NmFjNjIwYzJiZGI4NTJiODA3OGYzN2I4OThhYjQwZDk2ZWMwYjA", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-08-05T13:29:19Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-08-05T13:37:41Z"}, "message": "Array index access does not need to unsize to a slice for access\n\nWhen we define the core code for SliceIndex access its possible for an\narray to be fully coerced into a slice DST and follow the normal slice\nindex access which removes support for GCC -Warray-index checks and\ngenerates unnessecary code for array access.\n\nFixes #1436", "tree": {"sha": "d0ad3824e02135310865254787603c99b27224f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d0ad3824e02135310865254787603c99b27224f7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c86ac620c2bdb852b8078f37b898ab40d96ec0b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c86ac620c2bdb852b8078f37b898ab40d96ec0b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c86ac620c2bdb852b8078f37b898ab40d96ec0b0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c86ac620c2bdb852b8078f37b898ab40d96ec0b0/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8725e324aad3eac0df074e5f0a494b5e3f332a31", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8725e324aad3eac0df074e5f0a494b5e3f332a31", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8725e324aad3eac0df074e5f0a494b5e3f332a31"}], "stats": {"total": 237, "additions": 209, "deletions": 28}, "files": [{"sha": "ff1165d093f2143302782bc004a5e2a6fd208f68", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.cc", "status": "modified", "additions": 36, "deletions": 27, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c86ac620c2bdb852b8078f37b898ab40d96ec0b0/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c86ac620c2bdb852b8078f37b898ab40d96ec0b0/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc?ref=c86ac620c2bdb852b8078f37b898ab40d96ec0b0", "patch": "@@ -250,6 +250,35 @@ TypeCheckExpr::visit (HIR::ArrayIndexExpr &expr)\n   if (index_expr_ty->get_kind () == TyTy::TypeKind::ERROR)\n     return;\n \n+  // first attempt to use direct array index logic\n+  auto direct_array_expr_ty = array_expr_ty;\n+  if (direct_array_expr_ty->get_kind () == TyTy::TypeKind::REF)\n+    {\n+      // lets try and deref it since rust allows this\n+      auto ref = static_cast<TyTy::ReferenceType *> (direct_array_expr_ty);\n+      auto base = ref->get_base ();\n+      if (base->get_kind () == TyTy::TypeKind::ARRAY)\n+\tdirect_array_expr_ty = base;\n+    }\n+\n+  TyTy::BaseType *size_ty;\n+  bool ok = context->lookup_builtin (\"usize\", &size_ty);\n+  rust_assert (ok);\n+\n+  bool maybe_simple_array_access = index_expr_ty->can_eq (size_ty, false);\n+  if (maybe_simple_array_access\n+      && direct_array_expr_ty->get_kind () == TyTy::TypeKind::ARRAY)\n+    {\n+      auto resolved_index_expr = size_ty->unify (index_expr_ty);\n+      if (resolved_index_expr->get_kind () == TyTy::TypeKind::ERROR)\n+\treturn;\n+\n+      TyTy::ArrayType *array_type\n+\t= static_cast<TyTy::ArrayType *> (direct_array_expr_ty);\n+      infered = array_type->get_element_type ()->clone ();\n+      return;\n+    }\n+\n   // is this a case of core::ops::index?\n   auto lang_item_type = Analysis::RustLangItem::ItemType::INDEX;\n   bool operator_overloaded\n@@ -266,33 +295,13 @@ TypeCheckExpr::visit (HIR::ArrayIndexExpr &expr)\n       return;\n     }\n \n-  if (array_expr_ty->get_kind () == TyTy::TypeKind::REF)\n-    {\n-      // lets try and deref it since rust allows this\n-      auto ref = static_cast<TyTy::ReferenceType *> (array_expr_ty);\n-      auto base = ref->get_base ();\n-      if (base->get_kind () == TyTy::TypeKind::ARRAY)\n-\tarray_expr_ty = base;\n-    }\n-\n-  if (array_expr_ty->get_kind () != TyTy::TypeKind::ARRAY)\n-    {\n-      rust_error_at (expr.get_index_expr ()->get_locus (),\n-\t\t     \"expected an ArrayType got [%s]\",\n-\t\t     array_expr_ty->as_string ().c_str ());\n-      return;\n-    }\n-\n-  TyTy::BaseType *size_ty;\n-  bool ok = context->lookup_builtin (\"usize\", &size_ty);\n-  rust_assert (ok);\n-\n-  auto resolved_index_expr = size_ty->unify (index_expr_ty);\n-  if (resolved_index_expr->get_kind () == TyTy::TypeKind::ERROR)\n-    return;\n-\n-  TyTy::ArrayType *array_type = static_cast<TyTy::ArrayType *> (array_expr_ty);\n-  infered = array_type->get_element_type ()->clone ();\n+  // error[E0277]: the type `[{integer}]` cannot be indexed by `u32`\n+  RichLocation r (expr.get_locus ());\n+  r.add_range (expr.get_array_expr ()->get_locus ());\n+  r.add_range (expr.get_index_expr ()->get_locus ());\n+  rust_error_at (r, \"the type %<%s%> cannot be indexed by %<%s%>\",\n+\t\t array_expr_ty->get_name ().c_str (),\n+\t\t index_expr_ty->get_name ().c_str ());\n }\n \n void"}, {"sha": "b1c8fe864736a8ead0c87c3276a92392ca35cda0", "filename": "gcc/testsuite/rust/compile/usize1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c86ac620c2bdb852b8078f37b898ab40d96ec0b0/gcc%2Ftestsuite%2Frust%2Fcompile%2Fusize1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c86ac620c2bdb852b8078f37b898ab40d96ec0b0/gcc%2Ftestsuite%2Frust%2Fcompile%2Fusize1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fusize1.rs?ref=c86ac620c2bdb852b8078f37b898ab40d96ec0b0", "patch": "@@ -1,6 +1,6 @@\n fn main() {\n     let a = [1, 2, 3];\n     let b: u32 = 1;\n-    let c = a[b]; // { dg-error \"expected .usize. got .u32.\" }\n+    let c = a[b]; // { dg-error \"the type ...integer..CAPACITY.. cannot be indexed by .u32.\" }\n                   // { dg-error {failed to type resolve expression} \"\" { target *-*-* } .-1 }\n }"}, {"sha": "32da34e105af96405130f139b2a2d59bece80ca9", "filename": "gcc/testsuite/rust/execute/torture/issue-1436.rs", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c86ac620c2bdb852b8078f37b898ab40d96ec0b0/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fissue-1436.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c86ac620c2bdb852b8078f37b898ab40d96ec0b0/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fissue-1436.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fissue-1436.rs?ref=c86ac620c2bdb852b8078f37b898ab40d96ec0b0", "patch": "@@ -0,0 +1,172 @@\n+// { dg-options \"-w\" }\n+// { dg-output \"\" }\n+mod intrinsics {\n+    extern \"rust-intrinsic\" {\n+        pub fn offset<T>(ptr: *const T, count: isize) -> *const T;\n+    }\n+}\n+\n+mod mem {\n+    extern \"rust-intrinsic\" {\n+        fn size_of<T>() -> usize;\n+    }\n+}\n+\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+struct FatPtr<T> {\n+    data: *const T,\n+    len: usize,\n+}\n+\n+pub union Repr<T> {\n+    rust: *const [T],\n+    rust_mut: *mut [T],\n+    raw: FatPtr<T>,\n+}\n+\n+pub enum Option<T> {\n+    None,\n+    Some(T),\n+}\n+\n+#[lang = \"Range\"]\n+pub struct Range<Idx> {\n+    pub start: Idx,\n+    pub end: Idx,\n+}\n+\n+#[lang = \"const_slice_ptr\"]\n+impl<T> *const [T] {\n+    pub const fn len(self) -> usize {\n+        let a = unsafe { Repr { rust: self }.raw };\n+        a.len\n+    }\n+\n+    pub const fn as_ptr(self) -> *const T {\n+        self as *const T\n+    }\n+}\n+\n+#[lang = \"const_ptr\"]\n+impl<T> *const T {\n+    pub const unsafe fn offset(self, count: isize) -> *const T {\n+        unsafe { intrinsics::offset(self, count) }\n+    }\n+\n+    pub const unsafe fn add(self, count: usize) -> Self {\n+        unsafe { self.offset(count as isize) }\n+    }\n+\n+    pub const fn as_ptr(self) -> *const T {\n+        self as *const T\n+    }\n+}\n+\n+const fn slice_from_raw_parts<T>(data: *const T, len: usize) -> *const [T] {\n+    unsafe {\n+        Repr {\n+            raw: FatPtr { data, len },\n+        }\n+        .rust\n+    }\n+}\n+\n+#[lang = \"index\"]\n+trait Index<Idx> {\n+    type Output;\n+\n+    fn index(&self, index: Idx) -> &Self::Output;\n+}\n+\n+impl<T> [T] {\n+    pub const fn is_empty(&self) -> bool {\n+        self.len() == 0\n+    }\n+\n+    pub const fn len(&self) -> usize {\n+        unsafe { Repr { rust: self }.raw.len }\n+    }\n+}\n+\n+pub unsafe trait SliceIndex<T> {\n+    type Output;\n+\n+    fn get(self, slice: &T) -> Option<&Self::Output>;\n+\n+    unsafe fn get_unchecked(self, slice: *const T) -> *const Self::Output;\n+\n+    fn index(self, slice: &T) -> &Self::Output;\n+}\n+\n+unsafe impl<T> SliceIndex<[T]> for usize {\n+    type Output = T;\n+\n+    fn get(self, slice: &[T]) -> Option<&T> {\n+        unsafe { Option::Some(&*self.get_unchecked(slice)) }\n+    }\n+\n+    unsafe fn get_unchecked(self, slice: *const [T]) -> *const T {\n+        // SAFETY: the caller guarantees that `slice` is not dangling, so it\n+        // cannot be longer than `isize::MAX`. They also guarantee that\n+        // `self` is in bounds of `slice` so `self` cannot overflow an `isize`,\n+        // so the call to `add` is safe.\n+        unsafe { slice.as_ptr().add(self) }\n+    }\n+\n+    fn index(self, slice: &[T]) -> &T {\n+        unsafe { &*self.get_unchecked(slice) }\n+    }\n+}\n+\n+unsafe impl<T> SliceIndex<[T]> for Range<usize> {\n+    type Output = [T];\n+\n+    fn get(self, slice: &[T]) -> Option<&[T]> {\n+        if self.start > self.end || self.end > slice.len() {\n+            Option::None\n+        } else {\n+            unsafe { Option::Some(&*self.get_unchecked(slice)) }\n+        }\n+    }\n+\n+    unsafe fn get_unchecked(self, slice: *const [T]) -> *const [T] {\n+        unsafe {\n+            let a: *const T = slice.as_ptr();\n+            let b: *const T = a.add(self.start);\n+            slice_from_raw_parts(b, self.end - self.start)\n+        }\n+    }\n+\n+    fn index(self, slice: &[T]) -> &[T] {\n+        unsafe { &*self.get_unchecked(slice) }\n+    }\n+}\n+\n+impl<T, I> Index<I> for [T]\n+where\n+    I: SliceIndex<[T]>,\n+{\n+    type Output = I::Output;\n+\n+    fn index(&self, index: I) -> &I::Output {\n+        unsafe {\n+            let a = \"slice-index\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c);\n+        }\n+\n+        index.index(self)\n+    }\n+}\n+\n+fn main() -> i32 {\n+    let a = [1, 2, 3, 4, 5];\n+    let b = a[1];\n+\n+    b - 2\n+}"}]}