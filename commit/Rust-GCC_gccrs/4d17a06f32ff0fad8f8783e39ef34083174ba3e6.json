{"sha": "4d17a06f32ff0fad8f8783e39ef34083174ba3e6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGQxN2EwNmYzMmZmMGZhZDhmODc4M2UzOWVmMzQwODMxNzRiYTNlNg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1998-07-28T11:45:32Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-07-28T11:45:32Z"}, "message": "cplus-dem.c (type_kind_t): New type.\n\n\t* cplus-dem.c (type_kind_t): New type.\n\t(demangle_template_value_parm): Add type_kind_t parameter.  Rely\n\ton this paramter, rather than demangling the type again.\n\t(demangle_integral_value): Pass tk_integral.\n\t(demangle_template_: Pass the value returned from do_type.\n\t(do_type): Return a type_kind_t.  Pass tk_integral to\n\tdemangle_template_value_parm for array bounds.\n\t(demangle_fund_type): Likewise.\n\nFrom-SVN: r21434", "tree": {"sha": "2f3525341b9c4c9094170272c608c8617cb76ec8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2f3525341b9c4c9094170272c608c8617cb76ec8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d17a06f32ff0fad8f8783e39ef34083174ba3e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d17a06f32ff0fad8f8783e39ef34083174ba3e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d17a06f32ff0fad8f8783e39ef34083174ba3e6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d17a06f32ff0fad8f8783e39ef34083174ba3e6/comments", "author": null, "committer": null, "parents": [{"sha": "36a117a5b33194265633e62df5968d2385baf8be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36a117a5b33194265633e62df5968d2385baf8be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36a117a5b33194265633e62df5968d2385baf8be"}], "stats": {"total": 351, "additions": 145, "deletions": 206}, "files": [{"sha": "425a9406bd7990ed2e48b085531fdfe95463d7a6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d17a06f32ff0fad8f8783e39ef34083174ba3e6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d17a06f32ff0fad8f8783e39ef34083174ba3e6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4d17a06f32ff0fad8f8783e39ef34083174ba3e6", "patch": "@@ -1,3 +1,14 @@\n+Tue Jul 28 11:33:09 1998  Mark Mitchell  <mark@markmitchell.com>\n+\n+\t* cplus-dem.c (type_kind_t): New type.\n+\t(demangle_template_value_parm): Add type_kind_t parameter.  Rely\n+\ton this paramter, rather than demangling the type again.\n+\t(demangle_integral_value): Pass tk_integral.\n+\t(demangle_template_: Pass the value returned from do_type.\n+\t(do_type): Return a type_kind_t.  Pass tk_integral to\n+\tdemangle_template_value_parm for array bounds.\n+\t(demangle_fund_type): Likewise.\n+\t\n Mon Jul 27 00:54:41 1998  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* tree.c (simple_cst_equal, case CONSTRUCTOR): OK if the elts are"}, {"sha": "d10e9c5b91116e5f6147d76d26ba71f13b93c8fb", "filename": "gcc/cplus-dem.c", "status": "modified", "additions": 57, "deletions": 97, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d17a06f32ff0fad8f8783e39ef34083174ba3e6/gcc%2Fcplus-dem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d17a06f32ff0fad8f8783e39ef34083174ba3e6/gcc%2Fcplus-dem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcplus-dem.c?ref=4d17a06f32ff0fad8f8783e39ef34083174ba3e6", "patch": "@@ -220,7 +220,19 @@ static const struct optable\n   {\"sz\",          \"sizeof \",    DMGL_ANSI}      /* pseudo-ansi */\n };\n \n-\n+/* These values are used to indicate the various type varieties.\n+   They are all non-zero so that they can be used as `success'\n+   values.  */\n+typedef enum type_kind_t \n+{ \n+  tk_none,\n+  tk_pointer,\n+  tk_integral, \n+  tk_bool,\n+  tk_char, \n+  tk_real\n+} type_kind_t;\n+\t\t\t     \n #define STRING_EMPTY(str)\t((str) -> b == (str) -> p)\n #define PREPEND_BLANK(str)\t{if (!STRING_EMPTY(str)) \\\n     string_prepend(str, \" \");}\n@@ -369,8 +381,8 @@ static void\n string_prepends PARAMS ((string *, string *));\n \n static int \n-demangle_template_value_parm PARAMS ((struct work_stuff*, \n-\t\t\t\t      const char**, string*)); \n+demangle_template_value_parm PARAMS ((struct work_stuff*, const char**, \n+\t\t\t\t      string*, type_kind_t));\n \n /*  Translate count to integer, consuming tokens in the process.\n     Conversion terminates on the first non-digit character.\n@@ -1179,7 +1191,8 @@ demangle_integral_value (work, mangled, s)\n \t  else\n \t    need_operator = 1;\n \n-\t  success = demangle_template_value_parm (work, mangled, s);\n+\t  success = demangle_template_value_parm (work, mangled, s,\n+\t\t\t\t\t\t  tk_integral);\n \t}\n \n       if (**mangled != 'W')\n@@ -1213,76 +1226,14 @@ demangle_integral_value (work, mangled, s)\n }\n \n static int \n-demangle_template_value_parm (work, mangled, s)\n+demangle_template_value_parm (work, mangled, s, tk)\n      struct work_stuff *work;\n      const char **mangled;\n      string* s;\n+     type_kind_t tk;\n {\n-  const char *old_p = *mangled;\n-  int is_pointer = 0;\n-  int is_real = 0;\n-  int is_integral = 0;\n-  int is_char = 0;\n-  int is_bool = 0;\n-  int done = 0;\n   int success = 1;\n \n-  while (*old_p && !done)\n-    {\t\n-      switch (*old_p)\n-\t{\n-\tcase 'P':\n-\tcase 'p':\n-\tcase 'R':\n-\t  done = is_pointer = 1;\n-\t  break;\n-\tcase 'C':\t/* const */\n-\tcase 'S':\t/* explicitly signed [char] */\n-\tcase 'U':\t/* unsigned */\n-\tcase 'V':\t/* volatile */\n-\tcase 'F':\t/* function */\n-\tcase 'M':\t/* member function */\n-\tcase 'O':\t/* ??? */\n-\tcase 'J':\t/* complex */\n-\t  old_p++;\n-\t  continue;\n-\tcase 'E':       /* expression */\n-\tcase 'Q':\t/* qualified name */\n-\tcase 'K':       /* qualified name */\n-\t  done = is_integral = 1;\n-\t  break;\n-\tcase 'B':\t/* remembered type */\n-\tcase 'T':\t/* remembered type */\n-\t  abort ();\n-\t  break;\n-\tcase 'v':\t/* void */\n-\t  abort ();\n-\t  break;\n-\tcase 'x':\t/* long long */\n-\tcase 'l':\t/* long */\n-\tcase 'i':\t/* int */\n-\tcase 's':\t/* short */\n-\tcase 'w':\t/* wchar_t */\n-\t  done = is_integral = 1;\n-\t  break;\n-\tcase 'b':\t/* bool */\n-\t  done = is_bool = 1;\n-\t  break;\n-\tcase 'c':\t/* char */\n-\t  done = is_char = 1;\n-\t  break;\n-\tcase 'r':\t/* long double */\n-\tcase 'd':\t/* double */\n-\tcase 'f':\t/* float */\n-\t  done = is_real = 1;\n-\t  break;\n-\tdefault:\n-\t  /* it's probably user defined type, let's assume\n-\t     it's integral, it seems hard to figure out\n-\t     what it really is */\n-\t  done = is_integral = 1;\n-\t}\n-    }\n   if (**mangled == 'Y')\n     {\n       /* The next argument is a template parameter. */\n@@ -1303,9 +1254,9 @@ demangle_template_value_parm (work, mangled, s)\n \t  string_append (s, buf);\n \t}\n     }\n-  else if (is_integral)\n+  else if (tk == tk_integral)\n     success = demangle_integral_value (work, mangled, s);\n-  else if (is_char)\n+  else if (tk == tk_char)\n     {\n       char tmp[2];\n       int val;\n@@ -1323,7 +1274,7 @@ demangle_template_value_parm (work, mangled, s)\n       string_appendn (s, &tmp[0], 1);\n       string_appendn (s, \"'\", 1);\n     }\n-  else if (is_bool)\n+  else if (tk == tk_bool)\n     {\n       int val = consume_count (mangled);\n       if (val == 0)\n@@ -1333,7 +1284,7 @@ demangle_template_value_parm (work, mangled, s)\n       else\n \tsuccess = 0;\n     }\n-  else if (is_real)\n+  else if (tk == tk_real)\n     {\n       if (**mangled == 'm')\n \t{\n@@ -1366,7 +1317,7 @@ demangle_template_value_parm (work, mangled, s)\n \t    }\n \t}\n     }\n-  else if (is_pointer)\n+  else if (tk == tk_pointer)\n     {\n       int symbol_len = consume_count (mangled);\n       if (symbol_len == 0)\n@@ -1542,25 +1493,15 @@ demangle_template (work, mangled, tname, trawname, is_type, remember)\n \t{\n \t  string  param;\n \t  string* s;\n+\t  const char* start_of_value_parm = *mangled;\n \n \t  /* otherwise, value parameter */\n \n \t  /* temp is initialized in do_type */\n \t  success = do_type (work, mangled, &temp);\n-\t  /*\n-\t    if (success)\n-\t    {\n-\t    string_appends (s, &temp);\n-\t    }\n-\t    */\n \t  string_delete(&temp);\n \t  if (!success)\n-\t    {\n-\t      break;\n-\t    }\n-\t  /*\n-\t    string_append (s, \"=\");\n-\t    */\n+\t    break;\n \n \t  if (!is_type)\n \t    {\n@@ -1570,7 +1511,8 @@ demangle_template (work, mangled, tname, trawname, is_type, remember)\n \t  else\n \t    s = tname;\n \n-\t  success = demangle_template_value_parm (work, mangled, s);\n+\t  success = demangle_template_value_parm (work, mangled, s,\n+\t\t\t\t\t\t  (type_kind_t) success);\n \n \t  if (!success)\n \t    {\n@@ -2490,7 +2432,8 @@ get_count (type, count)\n   return (1);\n }\n \n-/* result will be initialised here; it will be freed on failure */\n+/* RESULT will be initialised here; it will be freed on failure.  The\n+   value returned is really a type_kind_t.  */\n \n static int\n do_type (work, mangled, result)\n@@ -2506,6 +2449,7 @@ do_type (work, mangled, result)\n   int constp;\n   int volatilep;\n   string btype;\n+  type_kind_t tk = tk_none;\n \n   string_init (&btype);\n   string_init (&decl);\n@@ -2524,12 +2468,16 @@ do_type (work, mangled, result)\n \tcase 'p':\n \t  (*mangled)++;\n \t  string_prepend (&decl, \"*\");\n+\t  if (tk == tk_none)\n+\t    tk = tk_pointer;\n \t  break;\n \n \t  /* A reference type */\n \tcase 'R':\n \t  (*mangled)++;\n \t  string_prepend (&decl, \"&\");\n+\t  if (tk == tk_none)\n+\t    tk = tk_pointer;\n \t  break;\n \n \t  /* An array */\n@@ -2538,7 +2486,8 @@ do_type (work, mangled, result)\n \t    ++(*mangled);\n \t    string_prepend (&decl, \"(\");\n \t    string_append (&decl, \")[\");\n-\t    success = demangle_template_value_parm (work, mangled, &decl);\n+\t    success = demangle_template_value_parm (work, mangled, &decl,\n+\t\t\t\t\t\t    tk_integral);\n \t    if (**mangled == '_')\n \t      ++(*mangled);\n \t    string_append (&decl, \"]\");\n@@ -2711,9 +2660,7 @@ do_type (work, mangled, result)\n       if (!get_count (mangled, &n) || n >= work -> numb)\n           success = 0;\n       else\n-        {\n-          string_append (result, work->btypevec[n]);\n-        }\n+\tstring_append (result, work->btypevec[n]);\n       break;\n \n     case 'X':\n@@ -2748,6 +2695,8 @@ do_type (work, mangled, result)\n \n     default:\n       success = demangle_fund_type (work, mangled, result);\n+      if (tk == tk_none)\n+\ttk = (type_kind_t) success;\n       break;\n     }\n \n@@ -2760,11 +2709,14 @@ do_type (work, mangled, result)\n \t}\n     }\n   else\n-    {\n-      string_delete (result);\n-    }\n+    string_delete (result);\n   string_delete (&decl);\n-  return (success);\n+\n+  if (success)\n+    /* Assume an integral type, if we're not sure.  */\n+    return (int) ((tk == tk_none) ? tk_integral : tk);\n+  else\n+    return 0;\n }\n \n /* Given a pointer to a type string that represents a fundamental type\n@@ -2778,7 +2730,7 @@ do_type (work, mangled, result)\n \t\"Sl\"\t=>\t\"signed long\"\n \t\"CUs\"\t=>\t\"const unsigned short\"\n \n-   */\n+   The value returned is really a type_kind_t.  */\n \n static int\n demangle_fund_type (work, mangled, result)\n@@ -2789,6 +2741,8 @@ demangle_fund_type (work, mangled, result)\n   int done = 0;\n   int success = 1;\n   string btype;\n+  type_kind_t tk = tk_integral;\n+\n   string_init (&btype);\n \n   /* First pick off any type qualifiers.  There can be more than one.  */\n@@ -2870,31 +2824,37 @@ demangle_fund_type (work, mangled, result)\n       (*mangled)++;\n       APPEND_BLANK (result);\n       string_append (result, \"bool\");\n+      tk = tk_bool;\n       break;\n     case 'c':\n       (*mangled)++;\n       APPEND_BLANK (result);\n       string_append (result, \"char\");\n+      tk = tk_char;\n       break;\n     case 'w':\n       (*mangled)++;\n       APPEND_BLANK (result);\n       string_append (result, \"wchar_t\");\n+      tk = tk_char;\n       break;\n     case 'r':\n       (*mangled)++;\n       APPEND_BLANK (result);\n       string_append (result, \"long double\");\n+      tk = tk_real;\n       break;\n     case 'd':\n       (*mangled)++;\n       APPEND_BLANK (result);\n       string_append (result, \"double\");\n+      tk = tk_real;\n       break;\n     case 'f':\n       (*mangled)++;\n       APPEND_BLANK (result);\n       string_append (result, \"float\");\n+      tk = tk_real;\n       break;\n     case 'G':\n       (*mangled)++;\n@@ -2940,7 +2900,7 @@ demangle_fund_type (work, mangled, result)\n       break;\n     }\n \n-  return (success);\n+  return success ? ((int) tk) : 0;\n }\n \n /* Demangle the next argument, given by MANGLED into RESULT, which"}, {"sha": "77397f9316508eccff0529121b8c34b8d696466f", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d17a06f32ff0fad8f8783e39ef34083174ba3e6/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d17a06f32ff0fad8f8783e39ef34083174ba3e6/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=4d17a06f32ff0fad8f8783e39ef34083174ba3e6", "patch": "@@ -1,3 +1,20 @@\n+Tue Jul 28 11:33:09 1998  Mark Mitchell  <mark@markmitchell.com>\n+\n+\t* cplus-dem.c (type_kind_t): New type.\n+\t(demangle_template_value_parm): Add type_kind_t parameter.  Rely\n+\ton this paramter, rather than demangling the type again.\n+\t(demangle_integral_value): Pass tk_integral.\n+\t(demangle_template_: Pass the value returned from do_type.\n+\t(do_type): Return a type_kind_t.  Pass tk_integral to\n+\tdemangle_template_value_parm for array bounds.\n+\t(demangle_fund_type): Likewise.\n+\n+\tAlso incorporate from GCC version:\n+\n+\tTue Jul 21 13:28:19 1998  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* cplus-dem.c (do_type): Use demangle_template_value_parm for arrays.\n+\n Sun Jul 19 08:23:17 1998  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* cplus-dem.c (demangle_nested_args): Make function definition"}, {"sha": "d10e9c5b91116e5f6147d76d26ba71f13b93c8fb", "filename": "libiberty/cplus-dem.c", "status": "modified", "additions": 60, "deletions": 109, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d17a06f32ff0fad8f8783e39ef34083174ba3e6/libiberty%2Fcplus-dem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d17a06f32ff0fad8f8783e39ef34083174ba3e6/libiberty%2Fcplus-dem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcplus-dem.c?ref=4d17a06f32ff0fad8f8783e39ef34083174ba3e6", "patch": "@@ -220,7 +220,19 @@ static const struct optable\n   {\"sz\",          \"sizeof \",    DMGL_ANSI}      /* pseudo-ansi */\n };\n \n-\n+/* These values are used to indicate the various type varieties.\n+   They are all non-zero so that they can be used as `success'\n+   values.  */\n+typedef enum type_kind_t \n+{ \n+  tk_none,\n+  tk_pointer,\n+  tk_integral, \n+  tk_bool,\n+  tk_char, \n+  tk_real\n+} type_kind_t;\n+\t\t\t     \n #define STRING_EMPTY(str)\t((str) -> b == (str) -> p)\n #define PREPEND_BLANK(str)\t{if (!STRING_EMPTY(str)) \\\n     string_prepend(str, \" \");}\n@@ -369,8 +381,8 @@ static void\n string_prepends PARAMS ((string *, string *));\n \n static int \n-demangle_template_value_parm PARAMS ((struct work_stuff*, \n-\t\t\t\t      const char**, string*)); \n+demangle_template_value_parm PARAMS ((struct work_stuff*, const char**, \n+\t\t\t\t      string*, type_kind_t));\n \n /*  Translate count to integer, consuming tokens in the process.\n     Conversion terminates on the first non-digit character.\n@@ -1179,7 +1191,8 @@ demangle_integral_value (work, mangled, s)\n \t  else\n \t    need_operator = 1;\n \n-\t  success = demangle_template_value_parm (work, mangled, s);\n+\t  success = demangle_template_value_parm (work, mangled, s,\n+\t\t\t\t\t\t  tk_integral);\n \t}\n \n       if (**mangled != 'W')\n@@ -1213,76 +1226,14 @@ demangle_integral_value (work, mangled, s)\n }\n \n static int \n-demangle_template_value_parm (work, mangled, s)\n+demangle_template_value_parm (work, mangled, s, tk)\n      struct work_stuff *work;\n      const char **mangled;\n      string* s;\n+     type_kind_t tk;\n {\n-  const char *old_p = *mangled;\n-  int is_pointer = 0;\n-  int is_real = 0;\n-  int is_integral = 0;\n-  int is_char = 0;\n-  int is_bool = 0;\n-  int done = 0;\n   int success = 1;\n \n-  while (*old_p && !done)\n-    {\t\n-      switch (*old_p)\n-\t{\n-\tcase 'P':\n-\tcase 'p':\n-\tcase 'R':\n-\t  done = is_pointer = 1;\n-\t  break;\n-\tcase 'C':\t/* const */\n-\tcase 'S':\t/* explicitly signed [char] */\n-\tcase 'U':\t/* unsigned */\n-\tcase 'V':\t/* volatile */\n-\tcase 'F':\t/* function */\n-\tcase 'M':\t/* member function */\n-\tcase 'O':\t/* ??? */\n-\tcase 'J':\t/* complex */\n-\t  old_p++;\n-\t  continue;\n-\tcase 'E':       /* expression */\n-\tcase 'Q':\t/* qualified name */\n-\tcase 'K':       /* qualified name */\n-\t  done = is_integral = 1;\n-\t  break;\n-\tcase 'B':\t/* remembered type */\n-\tcase 'T':\t/* remembered type */\n-\t  abort ();\n-\t  break;\n-\tcase 'v':\t/* void */\n-\t  abort ();\n-\t  break;\n-\tcase 'x':\t/* long long */\n-\tcase 'l':\t/* long */\n-\tcase 'i':\t/* int */\n-\tcase 's':\t/* short */\n-\tcase 'w':\t/* wchar_t */\n-\t  done = is_integral = 1;\n-\t  break;\n-\tcase 'b':\t/* bool */\n-\t  done = is_bool = 1;\n-\t  break;\n-\tcase 'c':\t/* char */\n-\t  done = is_char = 1;\n-\t  break;\n-\tcase 'r':\t/* long double */\n-\tcase 'd':\t/* double */\n-\tcase 'f':\t/* float */\n-\t  done = is_real = 1;\n-\t  break;\n-\tdefault:\n-\t  /* it's probably user defined type, let's assume\n-\t     it's integral, it seems hard to figure out\n-\t     what it really is */\n-\t  done = is_integral = 1;\n-\t}\n-    }\n   if (**mangled == 'Y')\n     {\n       /* The next argument is a template parameter. */\n@@ -1303,9 +1254,9 @@ demangle_template_value_parm (work, mangled, s)\n \t  string_append (s, buf);\n \t}\n     }\n-  else if (is_integral)\n+  else if (tk == tk_integral)\n     success = demangle_integral_value (work, mangled, s);\n-  else if (is_char)\n+  else if (tk == tk_char)\n     {\n       char tmp[2];\n       int val;\n@@ -1323,7 +1274,7 @@ demangle_template_value_parm (work, mangled, s)\n       string_appendn (s, &tmp[0], 1);\n       string_appendn (s, \"'\", 1);\n     }\n-  else if (is_bool)\n+  else if (tk == tk_bool)\n     {\n       int val = consume_count (mangled);\n       if (val == 0)\n@@ -1333,7 +1284,7 @@ demangle_template_value_parm (work, mangled, s)\n       else\n \tsuccess = 0;\n     }\n-  else if (is_real)\n+  else if (tk == tk_real)\n     {\n       if (**mangled == 'm')\n \t{\n@@ -1366,7 +1317,7 @@ demangle_template_value_parm (work, mangled, s)\n \t    }\n \t}\n     }\n-  else if (is_pointer)\n+  else if (tk == tk_pointer)\n     {\n       int symbol_len = consume_count (mangled);\n       if (symbol_len == 0)\n@@ -1542,25 +1493,15 @@ demangle_template (work, mangled, tname, trawname, is_type, remember)\n \t{\n \t  string  param;\n \t  string* s;\n+\t  const char* start_of_value_parm = *mangled;\n \n \t  /* otherwise, value parameter */\n \n \t  /* temp is initialized in do_type */\n \t  success = do_type (work, mangled, &temp);\n-\t  /*\n-\t    if (success)\n-\t    {\n-\t    string_appends (s, &temp);\n-\t    }\n-\t    */\n \t  string_delete(&temp);\n \t  if (!success)\n-\t    {\n-\t      break;\n-\t    }\n-\t  /*\n-\t    string_append (s, \"=\");\n-\t    */\n+\t    break;\n \n \t  if (!is_type)\n \t    {\n@@ -1570,7 +1511,8 @@ demangle_template (work, mangled, tname, trawname, is_type, remember)\n \t  else\n \t    s = tname;\n \n-\t  success = demangle_template_value_parm (work, mangled, s);\n+\t  success = demangle_template_value_parm (work, mangled, s,\n+\t\t\t\t\t\t  (type_kind_t) success);\n \n \t  if (!success)\n \t    {\n@@ -2490,7 +2432,8 @@ get_count (type, count)\n   return (1);\n }\n \n-/* result will be initialised here; it will be freed on failure */\n+/* RESULT will be initialised here; it will be freed on failure.  The\n+   value returned is really a type_kind_t.  */\n \n static int\n do_type (work, mangled, result)\n@@ -2506,6 +2449,7 @@ do_type (work, mangled, result)\n   int constp;\n   int volatilep;\n   string btype;\n+  type_kind_t tk = tk_none;\n \n   string_init (&btype);\n   string_init (&decl);\n@@ -2524,33 +2468,29 @@ do_type (work, mangled, result)\n \tcase 'p':\n \t  (*mangled)++;\n \t  string_prepend (&decl, \"*\");\n+\t  if (tk == tk_none)\n+\t    tk = tk_pointer;\n \t  break;\n \n \t  /* A reference type */\n \tcase 'R':\n \t  (*mangled)++;\n \t  string_prepend (&decl, \"&\");\n+\t  if (tk == tk_none)\n+\t    tk = tk_pointer;\n \t  break;\n \n \t  /* An array */\n \tcase 'A':\n \t  {\n-\t    const char *p = ++(*mangled);\n-\n+\t    ++(*mangled);\n \t    string_prepend (&decl, \"(\");\n \t    string_append (&decl, \")[\");\n-\t    /* Copy anything up until the next underscore (the size of the\n-\t       array).  */\n-\t    while (**mangled && **mangled != '_')\n-\t      ++(*mangled);\n+\t    success = demangle_template_value_parm (work, mangled, &decl,\n+\t\t\t\t\t\t    tk_integral);\n \t    if (**mangled == '_')\n-\t      {\n-\t\tstring_appendn (&decl, p, *mangled - p);\n-\t\tstring_append (&decl, \"]\");             \n-\t\t*mangled += 1;\n-\t      }\n-\t    else\n-\t      success = 0;\n+\t      ++(*mangled);\n+\t    string_append (&decl, \"]\");\n \t    break;\n \t  }\n \n@@ -2720,9 +2660,7 @@ do_type (work, mangled, result)\n       if (!get_count (mangled, &n) || n >= work -> numb)\n           success = 0;\n       else\n-        {\n-          string_append (result, work->btypevec[n]);\n-        }\n+\tstring_append (result, work->btypevec[n]);\n       break;\n \n     case 'X':\n@@ -2757,6 +2695,8 @@ do_type (work, mangled, result)\n \n     default:\n       success = demangle_fund_type (work, mangled, result);\n+      if (tk == tk_none)\n+\ttk = (type_kind_t) success;\n       break;\n     }\n \n@@ -2769,11 +2709,14 @@ do_type (work, mangled, result)\n \t}\n     }\n   else\n-    {\n-      string_delete (result);\n-    }\n+    string_delete (result);\n   string_delete (&decl);\n-  return (success);\n+\n+  if (success)\n+    /* Assume an integral type, if we're not sure.  */\n+    return (int) ((tk == tk_none) ? tk_integral : tk);\n+  else\n+    return 0;\n }\n \n /* Given a pointer to a type string that represents a fundamental type\n@@ -2787,7 +2730,7 @@ do_type (work, mangled, result)\n \t\"Sl\"\t=>\t\"signed long\"\n \t\"CUs\"\t=>\t\"const unsigned short\"\n \n-   */\n+   The value returned is really a type_kind_t.  */\n \n static int\n demangle_fund_type (work, mangled, result)\n@@ -2798,6 +2741,8 @@ demangle_fund_type (work, mangled, result)\n   int done = 0;\n   int success = 1;\n   string btype;\n+  type_kind_t tk = tk_integral;\n+\n   string_init (&btype);\n \n   /* First pick off any type qualifiers.  There can be more than one.  */\n@@ -2879,31 +2824,37 @@ demangle_fund_type (work, mangled, result)\n       (*mangled)++;\n       APPEND_BLANK (result);\n       string_append (result, \"bool\");\n+      tk = tk_bool;\n       break;\n     case 'c':\n       (*mangled)++;\n       APPEND_BLANK (result);\n       string_append (result, \"char\");\n+      tk = tk_char;\n       break;\n     case 'w':\n       (*mangled)++;\n       APPEND_BLANK (result);\n       string_append (result, \"wchar_t\");\n+      tk = tk_char;\n       break;\n     case 'r':\n       (*mangled)++;\n       APPEND_BLANK (result);\n       string_append (result, \"long double\");\n+      tk = tk_real;\n       break;\n     case 'd':\n       (*mangled)++;\n       APPEND_BLANK (result);\n       string_append (result, \"double\");\n+      tk = tk_real;\n       break;\n     case 'f':\n       (*mangled)++;\n       APPEND_BLANK (result);\n       string_append (result, \"float\");\n+      tk = tk_real;\n       break;\n     case 'G':\n       (*mangled)++;\n@@ -2949,7 +2900,7 @@ demangle_fund_type (work, mangled, result)\n       break;\n     }\n \n-  return (success);\n+  return success ? ((int) tk) : 0;\n }\n \n /* Demangle the next argument, given by MANGLED into RESULT, which"}]}