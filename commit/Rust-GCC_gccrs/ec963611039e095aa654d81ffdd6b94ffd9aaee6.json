{"sha": "ec963611039e095aa654d81ffdd6b94ffd9aaee6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWM5NjM2MTEwMzllMDk1YWE2NTRkODFmZmRkNmI5NGZmZDlhYWVlNg==", "commit": {"author": {"name": "John David Anglin", "email": "dave.anglin@nrc-cnrc.gc.ca", "date": "2005-11-30T13:51:32Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2005-11-30T13:51:32Z"}, "message": "predicates.md (symbolic_operand): Add comment.\n\n\t* pa/predicates.md (symbolic_operand): Add comment.\n\t* pa/pa.md (reload_insi_r1, reload_indi_r1): New reload expanders.\n\t* pa/pa-protos.h (pa_secondary_reload_class): Delete.\n\t* pa/pa.c (TARGET_SECONDARY_RELOAD): Define.\n\t(pa_secondary_reload_class): Delete.\n\t(pa_secondary_reload): New function derived from SECONDARY_RELOAD_CLASS\n\tand pa_secondary_reload_class.  Reorder some checks.  Update inline\n\tcopy of symbolic operand.\n\t* pa/pa.h (SECONDARY_RELOAD_CLASS): Delete.\n\n\nCo-Authored-By: Bernd Schmidt <bernd.schmidt@analog.com>\n\nFrom-SVN: r107719", "tree": {"sha": "d5d1e284918b1142f448f7024c16298be8cfe218", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d5d1e284918b1142f448f7024c16298be8cfe218"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec963611039e095aa654d81ffdd6b94ffd9aaee6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec963611039e095aa654d81ffdd6b94ffd9aaee6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec963611039e095aa654d81ffdd6b94ffd9aaee6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec963611039e095aa654d81ffdd6b94ffd9aaee6/comments", "author": null, "committer": null, "parents": [{"sha": "b6a8dc3ad64ea3ec42c21e6c7299bcba263c323d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6a8dc3ad64ea3ec42c21e6c7299bcba263c323d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6a8dc3ad64ea3ec42c21e6c7299bcba263c323d"}], "stats": {"total": 204, "additions": 129, "deletions": 75}, "files": [{"sha": "813e2098d4e215ca633ae19161ea1460fe49bcc3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec963611039e095aa654d81ffdd6b94ffd9aaee6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec963611039e095aa654d81ffdd6b94ffd9aaee6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ec963611039e095aa654d81ffdd6b94ffd9aaee6", "patch": "@@ -1,3 +1,16 @@\n+2005-11-30  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n+\t    Bernd Schmidt  <bernd.schmidt@analog.com>\n+\n+\t* pa/predicates.md (symbolic_operand): Add comment.\n+\t* pa/pa.md (reload_insi_r1, reload_indi_r1): New reload expanders.\n+\t* pa/pa-protos.h (pa_secondary_reload_class): Delete.\n+\t* pa/pa.c (TARGET_SECONDARY_RELOAD): Define.\n+\t(pa_secondary_reload_class): Delete.\n+\t(pa_secondary_reload): New function derived from SECONDARY_RELOAD_CLASS\n+\tand pa_secondary_reload_class.  Reorder some checks.  Update inline\n+\tcopy of symbolic operand.\n+\t* pa/pa.h (SECONDARY_RELOAD_CLASS): Delete.\n+\n 2005-11-30  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* loop-doloop.c (add_test): Only add jump notes if we did emit a"}, {"sha": "0963844c36e0f00c6d1f3ad59f435cc982a4db14", "filename": "gcc/config/pa/pa-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec963611039e095aa654d81ffdd6b94ffd9aaee6/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec963611039e095aa654d81ffdd6b94ffd9aaee6/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-protos.h?ref=ec963611039e095aa654d81ffdd6b94ffd9aaee6", "patch": "@@ -106,8 +106,6 @@ extern int emit_move_sequence (rtx *, enum machine_mode, rtx);\n extern int emit_hpdiv_const (rtx *, int);\n extern int is_function_label_plus_const (rtx);\n extern int jump_in_call_delay (rtx);\n-extern enum reg_class pa_secondary_reload_class (enum reg_class,\n-\t\t\t\t\t\t enum machine_mode, rtx);\n extern int hppa_fpstore_bypass_p (rtx, rtx);\n extern int attr_length_millicode_call (rtx);\n extern int attr_length_call (rtx, int);"}, {"sha": "4dcd828098f1df0ab6140f0f141eae759380de65", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 67, "deletions": 54, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec963611039e095aa654d81ffdd6b94ffd9aaee6/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec963611039e095aa654d81ffdd6b94ffd9aaee6/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=ec963611039e095aa654d81ffdd6b94ffd9aaee6", "patch": "@@ -150,6 +150,9 @@ static bool pa_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode,\n static int pa_arg_partial_bytes (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t tree, bool);\n static struct machine_function * pa_init_machine_status (void);\n+static enum reg_class pa_secondary_reload (bool, rtx, enum reg_class,\n+\t\t\t\t\t   enum machine_mode,\n+\t\t\t\t\t   secondary_reload_info *);\n \n \n /* Save the operands last given to a compare for use when we\n@@ -299,6 +302,9 @@ static size_t n_deferred_plabels = 0;\n #undef TARGET_CANNOT_FORCE_CONST_MEM\n #define TARGET_CANNOT_FORCE_CONST_MEM pa_tls_referenced_p\n \n+#undef TARGET_SECONDARY_RELOAD\n+#define TARGET_SECONDARY_RELOAD pa_secondary_reload\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Parse the -mfixed-range= option string.  */\n@@ -5565,100 +5571,107 @@ output_arg_descriptor (rtx call_insn)\n   fputc ('\\n', asm_out_file);\n }\n \f\n-/* Return the class of any secondary reload register that is needed to\n-   move IN into a register in class CLASS using mode MODE.\n+static enum reg_class\n+pa_secondary_reload (bool in_p, rtx x, enum reg_class class,\n+\t\t     enum machine_mode mode, secondary_reload_info *sri)\n+{\n+  int is_symbolic;\n+  int regno = -1;\n \n-   Profiling has showed this routine and its descendants account for\n-   a significant amount of compile time (~7%).  So it has been\n-   optimized to reduce redundant computations and eliminate useless\n-   function calls.\n+  /* Handle the easy stuff first.  */\n+  if (class == R1_REGS)\n+    return NO_REGS;\n \n-   It might be worthwhile to try and make this a leaf function too.  */\n+  if (REG_P (x))\n+    {\n+      regno = REGNO (x);\n+      if (class == BASE_REG_CLASS && regno < FIRST_PSEUDO_REGISTER)\n+\treturn NO_REGS;\n+    }\n \n-enum reg_class\n-pa_secondary_reload_class (enum reg_class class, enum machine_mode mode, rtx in)\n-{\n-  int regno, is_symbolic;\n+  /* If we have something like (mem (mem (...)), we can safely assume the\n+     inner MEM will end up in a general register after reloading, so there's\n+     no need for a secondary reload.  */\n+  if (GET_CODE (x) == MEM && GET_CODE (XEXP (x, 0)) == MEM)\n+    return NO_REGS;\n \n   /* Trying to load a constant into a FP register during PIC code\n-     generation will require %r1 as a scratch register.  */\n+     generation requires %r1 as a scratch register.  */\n   if (flag_pic\n       && GET_MODE_CLASS (mode) == MODE_INT\n       && FP_REG_CLASS_P (class)\n-      && (GET_CODE (in) == CONST_INT || GET_CODE (in) == CONST_DOUBLE))\n-    return R1_REGS;\n-\n-  /* Profiling showed the PA port spends about 1.3% of its compilation\n-     time in true_regnum from calls inside pa_secondary_reload_class.  */\n-\n-  if (GET_CODE (in) == REG)\n+      && (GET_CODE (x) == CONST_INT || GET_CODE (x) == CONST_DOUBLE))\n     {\n-      regno = REGNO (in);\n-      if (regno >= FIRST_PSEUDO_REGISTER)\n-\tregno = true_regnum (in);\n+      gcc_assert (mode == SImode || mode == DImode);\n+      sri->icode = (mode == SImode ? CODE_FOR_reload_insi_r1\n+\t\t    : CODE_FOR_reload_indi_r1);\n+      return NO_REGS;\n     }\n-  else if (GET_CODE (in) == SUBREG)\n-    regno = true_regnum (in);\n-  else\n-    regno = -1;\n \n-  /* If we have something like (mem (mem (...)), we can safely assume the\n-     inner MEM will end up in a general register after reloading, so there's\n-     no need for a secondary reload.  */\n-  if (GET_CODE (in) == MEM\n-      && GET_CODE (XEXP (in, 0)) == MEM)\n-    return NO_REGS;\n+  /* Profiling showed the PA port spends about 1.3% of its compilation\n+     time in true_regnum from calls inside pa_secondary_reload_class.  */\n+  if (regno >= FIRST_PSEUDO_REGISTER || GET_CODE (x) == SUBREG)\n+    regno = true_regnum (x);\n \n   /* Handle out of range displacement for integer mode loads/stores of\n      FP registers.  */\n   if (((regno >= FIRST_PSEUDO_REGISTER || regno == -1)\n        && GET_MODE_CLASS (mode) == MODE_INT\n        && FP_REG_CLASS_P (class))\n       || (class == SHIFT_REGS && (regno <= 0 || regno >= 32)))\n-    return GENERAL_REGS;\n+    {\n+      sri->icode = in_p ? reload_in_optab[mode] : reload_out_optab[mode];\n+      return NO_REGS;\n+    }\n \n   /* A SAR<->FP register copy requires a secondary register (GPR) as\n      well as secondary memory.  */\n   if (regno >= 0 && regno < FIRST_PSEUDO_REGISTER\n       && ((REGNO_REG_CLASS (regno) == SHIFT_REGS && FP_REG_CLASS_P (class))\n-\t  || (class == SHIFT_REGS && FP_REG_CLASS_P (REGNO_REG_CLASS (regno)))))\n-    return GENERAL_REGS;\n+\t  || (class == SHIFT_REGS\n+\t      && FP_REG_CLASS_P (REGNO_REG_CLASS (regno)))))\n+    {\n+      sri->icode = in_p ? reload_in_optab[mode] : reload_out_optab[mode];\n+      return NO_REGS;\n+    }\n \n-  if (GET_CODE (in) == HIGH)\n-    in = XEXP (in, 0);\n+  /* Secondary reloads of symbolic operands require %r1 as a scratch\n+     register when we're generating PIC code and the operand isn't\n+     readonly.  */\n+  if (GET_CODE (x) == HIGH)\n+    x = XEXP (x, 0);\n \n   /* Profiling has showed GCC spends about 2.6% of its compilation\n      time in symbolic_operand from calls inside pa_secondary_reload_class.\n-\n-     We use an inline copy and only compute its return value once to avoid\n-     useless work.  */\n-  switch (GET_CODE (in))\n+     So, we use an inline copy to avoid useless work.  */\n+  switch (GET_CODE (x))\n     {\n-      rtx tmp;\n+      rtx op;\n \n       case SYMBOL_REF:\n+        is_symbolic = !SYMBOL_REF_TLS_MODEL (x);\n+        break;\n       case LABEL_REF:\n         is_symbolic = 1;\n         break;\n       case CONST:\n-\ttmp = XEXP (in, 0);\n-\tis_symbolic = ((GET_CODE (XEXP (tmp, 0)) == SYMBOL_REF\n-\t\t\t|| GET_CODE (XEXP (tmp, 0)) == LABEL_REF)\n-\t\t       && GET_CODE (XEXP (tmp, 1)) == CONST_INT);\n+\top = XEXP (x, 0);\n+\tis_symbolic = (((GET_CODE (XEXP (op, 0)) == SYMBOL_REF\n+\t\t\t && !SYMBOL_REF_TLS_MODEL (XEXP (op, 0)))\n+\t\t\t|| GET_CODE (XEXP (op, 0)) == LABEL_REF)\n+\t\t       && GET_CODE (XEXP (op, 1)) == CONST_INT);\n         break;\n-\n       default:\n         is_symbolic = 0;\n         break;\n     }\n \n-  if (!flag_pic\n-      && is_symbolic\n-      && read_only_operand (in, VOIDmode))\n-    return NO_REGS;\n-\n-  if (class != R1_REGS && is_symbolic)\n-    return R1_REGS;\n+  if (is_symbolic && (flag_pic || !read_only_operand (x, VOIDmode)))\n+    {\n+      gcc_assert (mode == SImode || mode == DImode);\n+      sri->icode = (mode == SImode ? CODE_FOR_reload_insi_r1\n+\t\t    : CODE_FOR_reload_indi_r1);\n+    }\n \n   return NO_REGS;\n }"}, {"sha": "6fc265edbe0c17a1170d895be6cc8d8f9ddc0774", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec963611039e095aa654d81ffdd6b94ffd9aaee6/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec963611039e095aa654d81ffdd6b94ffd9aaee6/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=ec963611039e095aa654d81ffdd6b94ffd9aaee6", "patch": "@@ -527,16 +527,6 @@ extern struct rtx_def *hppa_pic_save_rtx (void);\n    in some cases it is preferable to use a more restrictive class.  */\n #define PREFERRED_RELOAD_CLASS(X,CLASS) (CLASS)\n \n-/* Return the register class of a scratch register needed to copy\n-   IN into a register in CLASS in MODE, or a register in CLASS in MODE\n-   to IN.  If it can be done directly NO_REGS is returned. \n-\n-  Avoid doing any work for the common case calls.  */\n-#define SECONDARY_RELOAD_CLASS(CLASS,MODE,IN) \\\n-  ((CLASS == BASE_REG_CLASS && GET_CODE (IN) == REG\t\t\\\n-    && REGNO (IN) < FIRST_PSEUDO_REGISTER)\t\t\t\\\n-   ? NO_REGS : pa_secondary_reload_class (CLASS, MODE, IN))\n-\n #define MAYBE_FP_REG_CLASS_P(CLASS) \\\n   reg_classes_intersect_p ((CLASS), FP_REGS)\n "}, {"sha": "8e28e8fb613ff260192b8d5ff79a4d4ca49ff840", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 47, "deletions": 8, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec963611039e095aa654d81ffdd6b94ffd9aaee6/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec963611039e095aa654d81ffdd6b94ffd9aaee6/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=ec963611039e095aa654d81ffdd6b94ffd9aaee6", "patch": "@@ -2255,9 +2255,24 @@\n     DONE;\n }\")\n \n-;; Reloading an SImode or DImode value requires a scratch register if\n-;; going in to or out of float point registers.\n+;; Handle SImode input reloads requiring %r1 as a scratch register.\n+(define_expand \"reload_insi_r1\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=Z\")\n+\t(match_operand:SI 1 \"non_hard_reg_operand\" \"\"))\n+   (clobber (match_operand:SI 2 \"register_operand\" \"=&a\"))]\n+  \"\"\n+  \"\n+{\n+  if (emit_move_sequence (operands, SImode, operands[2]))\n+    DONE;\n \n+  /* We don't want the clobber emitted, so handle this ourselves.  */\n+  emit_insn (gen_rtx_SET (VOIDmode, operands[0], operands[1]));\n+  DONE;\n+}\")\n+\n+;; Handle SImode input reloads requiring a general register as a\n+;; scratch register.\n (define_expand \"reload_insi\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=Z\")\n \t(match_operand:SI 1 \"non_hard_reg_operand\" \"\"))\n@@ -2273,6 +2288,8 @@\n   DONE;\n }\")\n \n+;; Handle SImode output reloads requiring a general register as a\n+;; scratch register.\n (define_expand \"reload_outsi\"\n   [(set (match_operand:SI 0 \"non_hard_reg_operand\" \"\")\n \t(match_operand:SI 1  \"register_operand\" \"Z\"))\n@@ -3787,9 +3804,8 @@\n     DONE;\n }\")\n \n-;; Reloading an SImode or DImode value requires a scratch register if\n-;; going in to or out of float point registers.\n-\n+;; Handle DFmode input reloads requiring a general register as a\n+;; scratch register.\n (define_expand \"reload_indf\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=Z\")\n \t(match_operand:DF 1 \"non_hard_reg_operand\" \"\"))\n@@ -3805,6 +3821,8 @@\n   DONE;\n }\")\n \n+;; Handle DFmode output reloads requiring a general register as a\n+;; scratch register.\n (define_expand \"reload_outdf\" \n  [(set (match_operand:DF 0 \"non_hard_reg_operand\" \"\")\n \t(match_operand:DF 1  \"register_operand\" \"Z\"))\n@@ -4044,6 +4062,24 @@\n     DONE;\n }\")\n \n+;; Handle DImode input reloads requiring %r1 as a scratch register.\n+(define_expand \"reload_indi_r1\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=Z\")\n+\t(match_operand:DI 1 \"non_hard_reg_operand\" \"\"))\n+   (clobber (match_operand:SI 2 \"register_operand\" \"=&a\"))]\n+  \"\"\n+  \"\n+{\n+  if (emit_move_sequence (operands, DImode, operands[2]))\n+    DONE;\n+\n+  /* We don't want the clobber emitted, so handle this ourselves.  */\n+  emit_insn (gen_rtx_SET (VOIDmode, operands[0], operands[1]));\n+  DONE;\n+}\")\n+\n+;; Handle DImode input reloads requiring a general register as a\n+;; scratch register.\n (define_expand \"reload_indi\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=Z\")\n \t(match_operand:DI 1 \"non_hard_reg_operand\" \"\"))\n@@ -4059,6 +4095,8 @@\n   DONE;\n }\")\n \n+;; Handle DImode output reloads requiring a general register as a\n+;; scratch register.\n (define_expand \"reload_outdi\"\n   [(set (match_operand:DI 0 \"non_hard_reg_operand\" \"\")\n \t(match_operand:DI 1 \"register_operand\" \"Z\"))\n@@ -4306,9 +4344,8 @@\n     DONE;\n }\")\n \n-;; Reloading an SImode or DImode value requires a scratch register if\n-;; going in to or out of float point registers.\n-\n+;; Handle SFmode input reloads requiring a general register as a\n+;; scratch register.\n (define_expand \"reload_insf\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=Z\")\n \t(match_operand:SF 1 \"non_hard_reg_operand\" \"\"))\n@@ -4324,6 +4361,8 @@\n   DONE;\n }\")\n \n+;; Handle SFmode output reloads requiring a general register as a\n+;; scratch register.\n (define_expand \"reload_outsf\"\n   [(set (match_operand:SF 0 \"non_hard_reg_operand\" \"\")\n \t(match_operand:SF 1  \"register_operand\" \"Z\"))"}, {"sha": "685a4941991f7c594e528460f191ff3e3d07001a", "filename": "gcc/config/pa/predicates.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec963611039e095aa654d81ffdd6b94ffd9aaee6/gcc%2Fconfig%2Fpa%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec963611039e095aa654d81ffdd6b94ffd9aaee6/gcc%2Fconfig%2Fpa%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpredicates.md?ref=ec963611039e095aa654d81ffdd6b94ffd9aaee6", "patch": "@@ -60,7 +60,8 @@\n   return (memory_address_p (mode, op) && IS_INDEX_ADDR_P (op));\n })\n \n-;; TODO: Add a comment.\n+;; Return 1 iff OP is a symbolic operand.\n+;; Note: an inline copy of this code is present in pa_secondary_reload.\n \n (define_predicate \"symbolic_operand\"\n   (match_code \"symbol_ref,label_ref,const\")"}]}