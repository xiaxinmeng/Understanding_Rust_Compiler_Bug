{"sha": "dc91d8927961dc5785d3622d3502d422e42f85c9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGM5MWQ4OTI3OTYxZGM1Nzg1ZDM2MjJkMzUwMmQ0MjJlNDJmODVjOQ==", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2010-08-03T09:25:22Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2010-08-03T09:25:22Z"}, "message": "i386.h (ix86_compare_op0, [...]): Remove.\n\n\t* config/i386/i386.h (ix86_compare_op0, ix86_compare_op1): Remove.\n\t* config/i386/i386.c (ix86_compare_op0, ix86_compare_op1): Remove.\n\t(ix86_expand_branch): Add op0 and op1 arguments.  Do not access\n\tix86_compare_op0 and ix86_compare_op1, use op0 and op1 instead.\n\tUpdate calls to ix86_expand_compare and ix86_expand_branch.\n\t(ix86_expand_setcc): Add op0 and op1 arguments.  Update calls to\n\tix86_expand_compare.\n\t(ix86_expand_compare): Add op0 and op1 arguments.  Do not access\n\tix86_compare_op0 and ix86_compare_op1, use op0 and op1 instead.\n\tMake static.\n\t(ix86_expand_carry_flag_compare): Do not set ix86_compare_op0\n\tand ix86_compare_op1.  Update calls to ix86_expand_compare.\n\t(ix86_expand_int_movcc): Ditto.\n\t(ix86_expand_fp_movcc): Ditto.  Update calls to ix86_expand_setcc.\n\t* config/i386/i386-protos.h (ix86_expand_branch): Update prototype.\n\t(ix86_expand_setcc): Ditto.\n\t(ix86_expand_compare): Remove prototype.\n\t* config/i386/i386.md (cbranch<SDWIM:mode>4): Do not set\n\tix86_compare_op0 and ix86_compare_op1.  Update calls\n\tto ix86_expand_branch to directly pass operands[1] and operands[2].\n\t(cbranchxf4): Ditto.\n\t(cbranch<MODEF:mode>4): Ditto.\n\t(cbranchcc4): Ditto.\n\t(cstore<SWIM:mode>4): Do not set ix86_compare_op0 and ix86_compare_op1.\n\tUpdate calls to ix86_expand_setcc to directly pass operands[2] and\n\toperands[3].\n\t(cstorexf4): Ditto.\n\t(cstore<MODEF:mode>4): Ditto.\n\t(cstorecc4): Ditto.\n\nFrom-SVN: r162837", "tree": {"sha": "314a8b0d25b26db953808773f472b015caf345ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/314a8b0d25b26db953808773f472b015caf345ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc91d8927961dc5785d3622d3502d422e42f85c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc91d8927961dc5785d3622d3502d422e42f85c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc91d8927961dc5785d3622d3502d422e42f85c9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc91d8927961dc5785d3622d3502d422e42f85c9/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d518b5e9c796df0c31694a57c9faa1012161ff73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d518b5e9c796df0c31694a57c9faa1012161ff73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d518b5e9c796df0c31694a57c9faa1012161ff73"}], "stats": {"total": 243, "additions": 113, "deletions": 130}, "files": [{"sha": "b100fd62fd3c74bfb539b4560854c6aea1884451", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc91d8927961dc5785d3622d3502d422e42f85c9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc91d8927961dc5785d3622d3502d422e42f85c9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dc91d8927961dc5785d3622d3502d422e42f85c9", "patch": "@@ -1,3 +1,35 @@\n+2010-08-03  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386.h (ix86_compare_op0, ix86_compare_op1): Remove.\n+\t* config/i386/i386.c (ix86_compare_op0, ix86_compare_op1): Remove.\n+\t(ix86_expand_branch): Add op0 and op1 arguments.  Do not access\n+\tix86_compare_op0 and ix86_compare_op1, use op0 and op1 instead.\n+\tUpdate calls to ix86_expand_compare and ix86_expand_branch.\n+\t(ix86_expand_setcc): Add op0 and op1 arguments.  Update calls to\n+\tix86_expand_compare.\n+\t(ix86_expand_compare): Add op0 and op1 arguments.  Do not access\n+\tix86_compare_op0 and ix86_compare_op1, use op0 and op1 instead.\n+\tMake static.\n+\t(ix86_expand_carry_flag_compare): Do not set ix86_compare_op0\n+\tand ix86_compare_op1.  Update calls to ix86_expand_compare.\n+\t(ix86_expand_int_movcc): Ditto.\n+\t(ix86_expand_fp_movcc): Ditto.  Update calls to ix86_expand_setcc.\n+\t* config/i386/i386-protos.h (ix86_expand_branch): Update prototype.\n+\t(ix86_expand_setcc): Ditto.\n+\t(ix86_expand_compare): Remove prototype.\n+\t* config/i386/i386.md (cbranch<SDWIM:mode>4): Do not set\n+\tix86_compare_op0 and ix86_compare_op1.  Update calls\n+\tto ix86_expand_branch to directly pass operands[1] and operands[2].\n+\t(cbranchxf4): Ditto.\n+\t(cbranch<MODEF:mode>4): Ditto.\n+\t(cbranchcc4): Ditto.\n+\t(cstore<SWIM:mode>4): Do not set ix86_compare_op0 and ix86_compare_op1.\n+\tUpdate calls to ix86_expand_setcc to directly pass operands[2] and\n+\toperands[3].\n+\t(cstorexf4): Ditto.\n+\t(cstore<MODEF:mode>4): Ditto.\n+\t(cstorecc4): Ditto.\n+\n 2010-08-02  Bernd Schmidt  <bernds@codesourcery.com>\n \n \tPR target/45063"}, {"sha": "e41d8101851114e90e802d82212e7fe2cb9223b7", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc91d8927961dc5785d3622d3502d422e42f85c9/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc91d8927961dc5785d3622d3502d422e42f85c9/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=dc91d8927961dc5785d3622d3502d422e42f85c9", "patch": "@@ -109,10 +109,9 @@ extern void ix86_split_copysign_const (rtx []);\n extern void ix86_split_copysign_var (rtx []);\n extern int ix86_unary_operator_ok (enum rtx_code, enum machine_mode, rtx[]);\n extern int ix86_match_ccmode (rtx, enum machine_mode);\n-extern rtx ix86_expand_compare (enum rtx_code);\n extern int ix86_use_fcomi_compare (enum rtx_code);\n-extern void ix86_expand_branch (enum rtx_code, rtx);\n-extern void ix86_expand_setcc (enum rtx_code, rtx);\n+extern void ix86_expand_branch (enum rtx_code, rtx, rtx, rtx);\n+extern void ix86_expand_setcc (rtx, enum rtx_code, rtx, rtx);\n extern int ix86_expand_int_movcc (rtx[]);\n extern int ix86_expand_fp_movcc (rtx[]);\n extern bool ix86_expand_fp_vcond (rtx[]);"}, {"sha": "6d676b22ad228a58b653a5f8587f0425f7393c0e", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 63, "deletions": 100, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc91d8927961dc5785d3622d3502d422e42f85c9/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc91d8927961dc5785d3622d3502d422e42f85c9/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=dc91d8927961dc5785d3622d3502d422e42f85c9", "patch": "@@ -1792,12 +1792,6 @@ int const svr4_dbx_register_map[FIRST_PSEUDO_REGISTER] =\n   -1, -1, -1, -1, -1, -1, -1, -1,\t/* extended SSE registers */\n };\n \n-/* Test and compare insns in i386.md store the information needed to\n-   generate branch and scc insns here.  */\n-\n-rtx ix86_compare_op0 = NULL_RTX;\n-rtx ix86_compare_op1 = NULL_RTX;\n-\n /* Define parameter passing and return registers.  */\n \n static int const x86_64_int_parameter_registers[6] =\n@@ -15916,15 +15910,13 @@ ix86_expand_fp_compare (enum rtx_code code, rtx op0, rtx op1, rtx scratch)\n \t\t\t const0_rtx);\n }\n \n-rtx\n-ix86_expand_compare (enum rtx_code code)\n+static rtx\n+ix86_expand_compare (enum rtx_code code, rtx op0, rtx op1)\n {\n-  rtx op0, op1, ret;\n-  op0 = ix86_compare_op0;\n-  op1 = ix86_compare_op1;\n+  rtx ret;\n \n-  if (GET_MODE_CLASS (GET_MODE (ix86_compare_op0)) == MODE_CC)\n-    ret = gen_rtx_fmt_ee (code, VOIDmode, ix86_compare_op0, ix86_compare_op1);\n+  if (GET_MODE_CLASS (GET_MODE (op0)) == MODE_CC)\n+    ret = gen_rtx_fmt_ee (code, VOIDmode, op0, op1);\n \n   else if (SCALAR_FLOAT_MODE_P (GET_MODE (op0)))\n     {\n@@ -15938,11 +15930,11 @@ ix86_expand_compare (enum rtx_code code)\n }\n \n void\n-ix86_expand_branch (enum rtx_code code, rtx label)\n+ix86_expand_branch (enum rtx_code code, rtx op0, rtx op1, rtx label)\n {\n   rtx tmp;\n \n-  switch (GET_MODE (ix86_compare_op0))\n+  switch (GET_MODE (op0))\n     {\n     case SFmode:\n     case DFmode:\n@@ -15951,7 +15943,7 @@ ix86_expand_branch (enum rtx_code code, rtx label)\n     case HImode:\n     case SImode:\n       simple:\n-      tmp = ix86_expand_compare (code);\n+      tmp = ix86_expand_compare (code, op0, op1);\n       tmp = gen_rtx_IF_THEN_ELSE (VOIDmode, tmp,\n \t\t\t\t  gen_rtx_LABEL_REF (VOIDmode, label),\n \t\t\t\t  pc_rtx);\n@@ -15968,23 +15960,21 @@ ix86_expand_branch (enum rtx_code code, rtx label)\n \tenum rtx_code code1, code2, code3;\n \tenum machine_mode submode;\n \n-\tif (CONSTANT_P (ix86_compare_op0) && ! CONSTANT_P (ix86_compare_op1))\n+\tif (CONSTANT_P (op0) && !CONSTANT_P (op1))\n \t  {\n-\t    tmp = ix86_compare_op0;\n-\t    ix86_compare_op0 = ix86_compare_op1;\n-\t    ix86_compare_op1 = tmp;\n+\t    tmp = op0, op0 = op1, op1 = tmp;\n \t    code = swap_condition (code);\n \t  }\n-\tif (GET_MODE (ix86_compare_op0) == DImode)\n+\tif (GET_MODE (op0) == DImode)\n \t  {\n-\t    split_di (&ix86_compare_op0, 1, lo+0, hi+0);\n-\t    split_di (&ix86_compare_op1, 1, lo+1, hi+1);\n+\t    split_di (&op0, 1, lo+0, hi+0);\n+\t    split_di (&op1, 1, lo+1, hi+1);\n \t    submode = SImode;\n \t  }\n \telse\n \t  {\n-\t    split_ti (&ix86_compare_op0, 1, lo+0, hi+0);\n-\t    split_ti (&ix86_compare_op1, 1, lo+1, hi+1);\n+\t    split_ti (&op0, 1, lo+0, hi+0);\n+\t    split_ti (&op1, 1, lo+1, hi+1);\n \t    submode = DImode;\n \t  }\n \n@@ -16011,9 +16001,7 @@ ix86_expand_branch (enum rtx_code code, rtx label)\n \t    tmp = expand_binop (submode, ior_optab, xor1, xor0,\n \t\t\t\tNULL_RTX, 0, OPTAB_WIDEN);\n \n-\t    ix86_compare_op0 = tmp;\n-\t    ix86_compare_op1 = const0_rtx;\n-\t    ix86_expand_branch (code, label);\n+\t    ix86_expand_branch (code, tmp, const0_rtx, label);\n \t    return;\n \t  }\n \n@@ -16028,18 +16016,14 @@ ix86_expand_branch (enum rtx_code code, rtx label)\n \t    case LT: case LTU: case GE: case GEU:\n \t      if (lo[1] == const0_rtx)\n \t\t{\n-\t\t  ix86_compare_op0 = hi[0];\n-\t\t  ix86_compare_op1 = hi[1];\n-\t\t  ix86_expand_branch (code, label);\n+\t\t  ix86_expand_branch (code, hi[0], hi[1], label);\n \t\t  return;\n \t\t}\n \t      break;\n \t    case LE: case LEU: case GT: case GTU:\n \t      if (lo[1] == constm1_rtx)\n \t\t{\n-\t\t  ix86_compare_op0 = hi[0];\n-\t\t  ix86_compare_op1 = hi[1];\n-\t\t  ix86_expand_branch (code, label);\n+\t\t  ix86_expand_branch (code, hi[0], hi[1], label);\n \t\t  return;\n \t\t}\n \t      break;\n@@ -16080,28 +16064,20 @@ ix86_expand_branch (enum rtx_code code, rtx label)\n \t *  false:\n \t */\n \n-\tix86_compare_op0 = hi[0];\n-\tix86_compare_op1 = hi[1];\n-\n \tif (code1 != UNKNOWN)\n-\t  ix86_expand_branch (code1, label);\n+\t  ix86_expand_branch (code1, hi[0], hi[1], label);\n \tif (code2 != UNKNOWN)\n-\t  ix86_expand_branch (code2, label2);\n+\t  ix86_expand_branch (code2, hi[0], hi[1], label2);\n \n-\tix86_compare_op0 = lo[0];\n-\tix86_compare_op1 = lo[1];\n-\tix86_expand_branch (code3, label);\n+\tix86_expand_branch (code3, lo[0], lo[1], label);\n \n \tif (code2 != UNKNOWN)\n \t  emit_label (label2);\n \treturn;\n       }\n \n     default:\n-      /* If we have already emitted a compare insn, go straight to simple.\n-         ix86_expand_compare won't emit anything if ix86_compare_emitted\n-         is non NULL.  */\n-      gcc_assert (GET_MODE_CLASS (GET_MODE (ix86_compare_op0)) == MODE_CC);\n+      gcc_assert (GET_MODE_CLASS (GET_MODE (op0)) == MODE_CC);\n       goto simple;\n     }\n }\n@@ -16138,13 +16114,13 @@ ix86_split_fp_branch (enum rtx_code code, rtx op1, rtx op2,\n }\n \n void\n-ix86_expand_setcc (enum rtx_code code, rtx dest)\n+ix86_expand_setcc (rtx dest, enum rtx_code code, rtx op0, rtx op1)\n {\n   rtx ret;\n \n   gcc_assert (GET_MODE (dest) == QImode);\n \n-  ret = ix86_expand_compare (code);\n+  ret = ix86_expand_compare (code, op0, op1);\n   PUT_MODE (ret, QImode);\n   emit_insn (gen_rtx_SET (VOIDmode, dest, ret));\n }\n@@ -16272,9 +16248,7 @@ ix86_expand_carry_flag_compare (enum rtx_code code, rtx op0, rtx op1, rtx *pop)\n \treturn false;\n       op0 = force_reg (mode, op0);\n     }\n-  ix86_compare_op0 = op0;\n-  ix86_compare_op1 = op1;\n-  *pop = ix86_expand_compare (code);\n+  *pop = ix86_expand_compare (code, op0, op1);\n   gcc_assert (GET_CODE (*pop) == LTU || GET_CODE (*pop) == GEU);\n   return true;\n }\n@@ -16286,18 +16260,18 @@ ix86_expand_int_movcc (rtx operands[])\n   rtx compare_seq, compare_op;\n   enum machine_mode mode = GET_MODE (operands[0]);\n   bool sign_bit_compare_p = false;\n+  rtx op0 = XEXP (operands[1], 0);\n+  rtx op1 = XEXP (operands[1], 1);\n \n   start_sequence ();\n-  ix86_compare_op0 = XEXP (operands[1], 0);\n-  ix86_compare_op1 = XEXP (operands[1], 1);\n-  compare_op = ix86_expand_compare (code);\n+  compare_op = ix86_expand_compare (code, op0, op1);\n   compare_seq = get_insns ();\n   end_sequence ();\n \n   compare_code = GET_CODE (compare_op);\n \n-  if ((ix86_compare_op1 == const0_rtx && (code == GE || code == LT))\n-      || (ix86_compare_op1 == constm1_rtx && (code == GT || code == LE)))\n+  if ((op1 == const0_rtx && (code == GE || code == LT))\n+      || (op1 == constm1_rtx && (code == GT || code == LE)))\n     sign_bit_compare_p = true;\n \n   /* Don't attempt mode expansion here -- if we had to expand 5 or 6\n@@ -16317,8 +16291,7 @@ ix86_expand_int_movcc (rtx operands[])\n       /*  Sign bit compares are better done using shifts than we do by using\n \t  sbb.  */\n       if (sign_bit_compare_p\n-\t  || ix86_expand_carry_flag_compare (code, ix86_compare_op0,\n-\t\t\t\t\t     ix86_compare_op1, &compare_op))\n+\t  || ix86_expand_carry_flag_compare (code, op0, op1, &compare_op))\n \t{\n \t  /* Detect overlap between destination and compare sources.  */\n \t  rtx tmp = out;\n@@ -16361,8 +16334,8 @@ ix86_expand_int_movcc (rtx operands[])\n \t\t}\n \t      diff = ct - cf;\n \n-\t      if (reg_overlap_mentioned_p (out, ix86_compare_op0)\n-\t\t  || reg_overlap_mentioned_p (out, ix86_compare_op1))\n+\t      if (reg_overlap_mentioned_p (out, op0)\n+\t\t  || reg_overlap_mentioned_p (out, op1))\n \t\ttmp = gen_reg_rtx (mode);\n \n \t      if (mode == DImode)\n@@ -16382,8 +16355,7 @@ ix86_expand_int_movcc (rtx operands[])\n \t\t  cf = tmp;\n \t\t  diff = ct - cf;\n \t\t}\n-\t      tmp = emit_store_flag (tmp, code, ix86_compare_op0,\n-\t\t\t\t     ix86_compare_op1, VOIDmode, 0, -1);\n+\t      tmp = emit_store_flag (tmp, code, op0, op1, VOIDmode, 0, -1);\n \t    }\n \n \t  if (diff == 1)\n@@ -16466,7 +16438,7 @@ ix86_expand_int_movcc (rtx operands[])\n \n       if (diff < 0)\n \t{\n-\t  enum machine_mode cmp_mode = GET_MODE (ix86_compare_op0);\n+\t  enum machine_mode cmp_mode = GET_MODE (op0);\n \n \t  HOST_WIDE_INT tmp;\n \t  tmp = ct, ct = cf, cf = tmp;\n@@ -16491,13 +16463,13 @@ ix86_expand_int_movcc (rtx operands[])\n \t}\n \n       compare_code = UNKNOWN;\n-      if (GET_MODE_CLASS (GET_MODE (ix86_compare_op0)) == MODE_INT\n-\t  && CONST_INT_P (ix86_compare_op1))\n+      if (GET_MODE_CLASS (GET_MODE (op0)) == MODE_INT\n+\t  && CONST_INT_P (op1))\n \t{\n-\t  if (ix86_compare_op1 == const0_rtx\n+\t  if (op1 == const0_rtx\n \t      && (code == LT || code == GE))\n \t    compare_code = code;\n-\t  else if (ix86_compare_op1 == constm1_rtx)\n+\t  else if (op1 == constm1_rtx)\n \t    {\n \t      if (code == LE)\n \t\tcompare_code = LT;\n@@ -16508,7 +16480,7 @@ ix86_expand_int_movcc (rtx operands[])\n \n       /* Optimize dest = (op0 < 0) ? -1 : cf.  */\n       if (compare_code != UNKNOWN\n-\t  && GET_MODE (ix86_compare_op0) == GET_MODE (out)\n+\t  && GET_MODE (op0) == GET_MODE (out)\n \t  && (cf == -1 || ct == -1))\n \t{\n \t  /* If lea code below could be used, only optimize\n@@ -16531,8 +16503,7 @@ ix86_expand_int_movcc (rtx operands[])\n \t\t  code = reverse_condition (code);\n \t\t}\n \n-\t      out = emit_store_flag (out, code, ix86_compare_op0,\n-\t\t\t\t     ix86_compare_op1, VOIDmode, 0, -1);\n+\t      out = emit_store_flag (out, code, op0, op1, VOIDmode, 0, -1);\n \n \t      out = expand_simple_binop (mode, IOR,\n \t\t\t\t\t out, GEN_INT (cf),\n@@ -16565,8 +16536,7 @@ ix86_expand_int_movcc (rtx operands[])\n \t  rtx tmp;\n \t  int nops;\n \n-\t  out = emit_store_flag (out, code, ix86_compare_op0,\n-\t\t\t\t ix86_compare_op1, VOIDmode, 0, 1);\n+\t  out = emit_store_flag (out, code, op0, op1, VOIDmode, 0, 1);\n \n \t  nops = 0;\n \t  /* On x86_64 the lea instruction operates on Pmode, so we need\n@@ -16625,7 +16595,7 @@ ix86_expand_int_movcc (rtx operands[])\n \t{\n \t  if (cf == 0)\n \t    {\n-\t      enum machine_mode cmp_mode = GET_MODE (ix86_compare_op0);\n+\t      enum machine_mode cmp_mode = GET_MODE (op0);\n \n \t      cf = ct;\n \t      ct = 0;\n@@ -16674,15 +16644,14 @@ ix86_expand_int_movcc (rtx operands[])\n \t\t  ct = tmp;\n \t\t}\n \n-\t      out = emit_store_flag (out, code, ix86_compare_op0,\n-\t\t\t\t     ix86_compare_op1, VOIDmode, 0, -1);\n+\t      out = emit_store_flag (out, code, op0, op1, VOIDmode, 0, -1);\n \t    }\n \t  else\n \t    {\n-\t      out = emit_store_flag (out, code, ix86_compare_op0,\n-\t\t\t\t     ix86_compare_op1, VOIDmode, 0, 1);\n+\t      out = emit_store_flag (out, code, op0, op1, VOIDmode, 0, 1);\n \n-\t      out = expand_simple_binop (mode, PLUS, copy_rtx (out), constm1_rtx,\n+\t      out = expand_simple_binop (mode, PLUS, copy_rtx (out),\n+\t\t\t\t\t constm1_rtx,\n \t\t\t\t\t copy_rtx (out), 1, OPTAB_DIRECT);\n \t    }\n \n@@ -16987,51 +16956,46 @@ ix86_expand_fp_movcc (rtx operands[])\n   enum machine_mode mode = GET_MODE (operands[0]);\n   enum rtx_code code = GET_CODE (operands[1]);\n   rtx tmp, compare_op;\n+  rtx op0 = XEXP (operands[1], 0);\n+  rtx op1 = XEXP (operands[1], 1);\n \n-  ix86_compare_op0 = XEXP (operands[1], 0);\n-  ix86_compare_op1 = XEXP (operands[1], 1);\n   if (TARGET_SSE_MATH && SSE_FLOAT_MODE_P (mode))\n     {\n       enum machine_mode cmode;\n \n       /* Since we've no cmove for sse registers, don't force bad register\n \t allocation just to gain access to it.  Deny movcc when the\n \t comparison mode doesn't match the move mode.  */\n-      cmode = GET_MODE (ix86_compare_op0);\n+      cmode = GET_MODE (op0);\n       if (cmode == VOIDmode)\n-\tcmode = GET_MODE (ix86_compare_op1);\n+\tcmode = GET_MODE (op1);\n       if (cmode != mode)\n \treturn 0;\n \n-      code = ix86_prepare_sse_fp_compare_args (operands[0], code,\n-\t\t\t\t\t       &ix86_compare_op0,\n-\t\t\t\t\t       &ix86_compare_op1);\n+      code = ix86_prepare_sse_fp_compare_args (operands[0], code, &op0, &op1);\n       if (code == UNKNOWN)\n \treturn 0;\n \n-      if (ix86_expand_sse_fp_minmax (operands[0], code, ix86_compare_op0,\n-\t\t\t\t     ix86_compare_op1, operands[2],\n-\t\t\t\t     operands[3]))\n+      if (ix86_expand_sse_fp_minmax (operands[0], code, op0, op1,\n+\t\t\t\t     operands[2], operands[3]))\n \treturn 1;\n \n-      tmp = ix86_expand_sse_cmp (operands[0], code, ix86_compare_op0,\n-\t\t\t\t ix86_compare_op1, operands[2], operands[3]);\n+      tmp = ix86_expand_sse_cmp (operands[0], code, op0, op1,\n+\t\t\t\t operands[2], operands[3]);\n       ix86_expand_sse_movcc (operands[0], tmp, operands[2], operands[3]);\n       return 1;\n     }\n \n   /* The floating point conditional move instructions don't directly\n      support conditions resulting from a signed integer comparison.  */\n \n-  compare_op = ix86_expand_compare (code);\n+  compare_op = ix86_expand_compare (code, op0, op1);\n   if (!fcmov_comparison_operator (compare_op, VOIDmode))\n     {\n       tmp = gen_reg_rtx (QImode);\n-      ix86_expand_setcc (code, tmp);\n-      code = NE;\n-      ix86_compare_op0 = tmp;\n-      ix86_compare_op1 = const0_rtx;\n-      compare_op = ix86_expand_compare (code);\n+      ix86_expand_setcc (tmp, code, op0, op1);\n+\n+      compare_op = ix86_expand_compare (NE, tmp, const0_rtx);\n     }\n \n   emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n@@ -17303,14 +17267,13 @@ ix86_expand_int_addcc (rtx operands[])\n   rtx val = const0_rtx;\n   bool fpcmp = false;\n   enum machine_mode mode;\n+  rtx op0 = XEXP (operands[1], 0);\n+  rtx op1 = XEXP (operands[1], 1);\n \n-  ix86_compare_op0 = XEXP (operands[1], 0);\n-  ix86_compare_op1 = XEXP (operands[1], 1);\n   if (operands[3] != const1_rtx\n       && operands[3] != constm1_rtx)\n     return 0;\n-  if (!ix86_expand_carry_flag_compare (code, ix86_compare_op0,\n-\t\t\t\t       ix86_compare_op1, &compare_op))\n+  if (!ix86_expand_carry_flag_compare (code, op0, op1, &compare_op))\n      return 0;\n   code = GET_CODE (compare_op);\n "}, {"sha": "3c3aeab970f01c2370ff8db06ff405f0d7c7243b", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc91d8927961dc5785d3622d3502d422e42f85c9/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc91d8927961dc5785d3622d3502d422e42f85c9/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=dc91d8927961dc5785d3622d3502d422e42f85c9", "patch": "@@ -2198,9 +2198,6 @@ extern int ix86_branch_cost, ix86_section_threshold;\n /* Smallest class containing REGNO.  */\n extern enum reg_class const regclass_map[FIRST_PSEUDO_REGISTER];\n \n-extern rtx ix86_compare_op0;\t/* operand 0 for comparisons */\n-extern rtx ix86_compare_op1;\t/* operand 1 for comparisons */\n-\n enum ix86_fpcmp_strategy {\n   IX86_FPCMP_SAHF,\n   IX86_FPCMP_COMI,"}, {"sha": "d7fd78dc61e368b4c737f21770fda3831bdedf1d", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 16, "deletions": 24, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc91d8927961dc5785d3622d3502d422e42f85c9/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc91d8927961dc5785d3622d3502d422e42f85c9/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=dc91d8927961dc5785d3622d3502d422e42f85c9", "patch": "@@ -942,9 +942,8 @@\n {\n   if (MEM_P (operands[1]) && MEM_P (operands[2]))\n     operands[1] = force_reg (<MODE>mode, operands[1]);\n-  ix86_compare_op0 = operands[1];\n-  ix86_compare_op1 = operands[2];\n-  ix86_expand_branch (GET_CODE (operands[0]), operands[3]);\n+  ix86_expand_branch (GET_CODE (operands[0]),\n+\t\t      operands[1], operands[2], operands[3]);\n   DONE;\n })\n \n@@ -959,9 +958,8 @@\n {\n   if (MEM_P (operands[2]) && MEM_P (operands[3]))\n     operands[2] = force_reg (<MODE>mode, operands[2]);\n-  ix86_compare_op0 = operands[2];\n-  ix86_compare_op1 = operands[3];\n-  ix86_expand_setcc (GET_CODE (operands[1]), operands[0]);\n+  ix86_expand_setcc (operands[0], GET_CODE (operands[1]),\n+\t\t     operands[2], operands[3]);\n   DONE;\n })\n \n@@ -1124,9 +1122,8 @@\n               (pc)))]\n   \"TARGET_80387\"\n {\n-  ix86_compare_op0 = operands[1];\n-  ix86_compare_op1 = operands[2];\n-  ix86_expand_branch (GET_CODE (operands[0]), operands[3]);\n+  ix86_expand_branch (GET_CODE (operands[0]),\n+\t\t      operands[1], operands[2], operands[3]);\n   DONE;\n })\n \n@@ -1140,9 +1137,8 @@\n                 (const_int 0)]))]\n   \"TARGET_80387\"\n {\n-  ix86_compare_op0 = operands[2];\n-  ix86_compare_op1 = operands[3];\n-  ix86_expand_setcc (GET_CODE (operands[1]), operands[0]);\n+  ix86_expand_setcc (operands[0], GET_CODE (operands[1]),\n+\t\t     operands[2], operands[3]);\n   DONE;\n })\n \n@@ -1158,9 +1154,8 @@\n               (pc)))]\n   \"TARGET_80387 || (SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH)\"\n {\n-  ix86_compare_op0 = operands[1];\n-  ix86_compare_op1 = operands[2];\n-  ix86_expand_branch (GET_CODE (operands[0]), operands[3]);\n+  ix86_expand_branch (GET_CODE (operands[0]),\n+\t\t      operands[1], operands[2], operands[3]);\n   DONE;\n })\n \n@@ -1174,9 +1169,8 @@\n                 (const_int 0)]))]\n   \"TARGET_80387 || (SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH)\"\n {\n-  ix86_compare_op0 = operands[2];\n-  ix86_compare_op1 = operands[3];\n-  ix86_expand_setcc (GET_CODE (operands[1]), operands[0]);\n+  ix86_expand_setcc (operands[0], GET_CODE (operands[1]),\n+\t\t     operands[2], operands[3]);\n   DONE;\n })\n \n@@ -1189,9 +1183,8 @@\n               (pc)))]\n   \"\"\n {\n-  ix86_compare_op0 = operands[1];\n-  ix86_compare_op1 = operands[2];\n-  ix86_expand_branch (GET_CODE (operands[0]), operands[3]);\n+  ix86_expand_branch (GET_CODE (operands[0]),\n+\t\t      operands[1], operands[2], operands[3]);\n   DONE;\n })\n \n@@ -1202,9 +1195,8 @@\n                 (match_operand 3 \"const0_operand\" \"\")]))]\n   \"\"\n {\n-  ix86_compare_op0 = operands[2];\n-  ix86_compare_op1 = operands[3];\n-  ix86_expand_setcc (GET_CODE (operands[1]), operands[0]);\n+  ix86_expand_setcc (operands[0], GET_CODE (operands[1]),\n+\t\t     operands[2], operands[3]);\n   DONE;\n })\n "}]}