{"sha": "ca4aac003dd77456362b1adfca46345e3840bc72", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2E0YWFjMDAzZGQ3NzQ1NjM2MmIxYWRmY2E0NjM0NWUzODQwYmM3Mg==", "commit": {"author": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1994-04-20T03:36:49Z"}, "committer": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1994-04-20T03:36:49Z"}, "message": "(choose_hard_reg_mode): Define here.\n\n(reg_raw_mode): Define.\n(init_reg_sets_1): Initialize reg_raw_mode.\n\nFrom-SVN: r7087", "tree": {"sha": "67e750186b349d8b84b2bb4467f2df7c000c2ca9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/67e750186b349d8b84b2bb4467f2df7c000c2ca9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca4aac003dd77456362b1adfca46345e3840bc72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca4aac003dd77456362b1adfca46345e3840bc72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca4aac003dd77456362b1adfca46345e3840bc72", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca4aac003dd77456362b1adfca46345e3840bc72/comments", "author": null, "committer": null, "parents": [{"sha": "d0c6176a4d095eb8959c89b31c9d91e46ca31af4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0c6176a4d095eb8959c89b31c9d91e46ca31af4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0c6176a4d095eb8959c89b31c9d91e46ca31af4"}], "stats": {"total": 58, "additions": 58, "deletions": 0}, "files": [{"sha": "69ed76140e351ad600e766c387960d2ed6d5e754", "filename": "gcc/regclass.c", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca4aac003dd77456362b1adfca46345e3840bc72/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca4aac003dd77456362b1adfca46345e3840bc72/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=ca4aac003dd77456362b1adfca46345e3840bc72", "patch": "@@ -152,6 +152,13 @@ enum reg_class reg_class_superunion[N_REG_CLASSES][N_REG_CLASSES];\n \n char *reg_names[] = REGISTER_NAMES;\n \n+/* For each hard register, the widest mode object that it can contain.\n+   This will be a MODE_INT mode if the register can hold integers.  Otherwise\n+   it will be a MODE_FLOAT or a MODE_CC mode, whichever is valid for the\n+   register.  */\n+\n+enum machine_mode reg_raw_mode[FIRST_PSEUDO_REGISTER];\n+\n /* Indexed by n, gives number of times (REG n) is set or clobbered.\n    This information remains valid for the rest of the compilation\n    of the current function; it is used to control register allocation.\n@@ -391,6 +398,57 @@ init_reg_sets_1 ()\n       if (call_fixed_regs[i])\n \tSET_HARD_REG_BIT (call_fixed_reg_set, i);\n     }\n+\n+  /* Compute the table of register modes.\n+     These values are used to record death information for individual registers\n+     (as opposed to a multi-register mode).\n+     This can't be done until HARD_REGNO_NREGS and HARD_REGNO_MODE_OK are\n+     usable which is after OVERRIDE_OPTIONS on some targets.  */\n+\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    reg_raw_mode[i] = choose_hard_reg_mode (i, 1);\n+}\n+\n+/* Return a machine mode that is legitimate for hard reg REGNO and large\n+   enough to save nregs.  If we can't find one, return VOIDmode.  */\n+\n+enum machine_mode\n+choose_hard_reg_mode (regno, nregs)\n+     int regno;\n+     int nregs;\n+{\n+  enum machine_mode found_mode = VOIDmode, mode;\n+\n+  /* We first look for the largest integer mode that can be validly\n+     held in REGNO.  If none, we look for the largest floating-point mode.\n+     If we still didn't find a valid mode, try CCmode.  */\n+\n+  for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n+       mode != VOIDmode;\n+       mode = GET_MODE_WIDER_MODE (mode))\n+    if (HARD_REGNO_NREGS (regno, mode) == nregs\n+\t&& HARD_REGNO_MODE_OK (regno, mode))\n+      found_mode = mode;\n+\n+  if (found_mode != VOIDmode)\n+    return found_mode;\n+\n+  for (mode = GET_CLASS_NARROWEST_MODE (MODE_FLOAT);\n+       mode != VOIDmode;\n+       mode = GET_MODE_WIDER_MODE (mode))\n+    if (HARD_REGNO_NREGS (regno, mode) == nregs\n+\t&& HARD_REGNO_MODE_OK (regno, mode))\n+      found_mode = mode;\n+\n+  if (found_mode != VOIDmode)\n+    return found_mode;\n+\n+  if (HARD_REGNO_NREGS (regno, CCmode) == nregs\n+      && HARD_REGNO_MODE_OK (regno, CCmode))\n+    return CCmode;\n+\n+  /* We can't find a mode valid for this register.  */\n+  return VOIDmode;\n }\n \n /* Specify the usage characteristics of the register named NAME."}]}