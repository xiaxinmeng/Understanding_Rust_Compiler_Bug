{"sha": "5d7ee2fa66f5bfd49b1759482a258c825babc6e3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWQ3ZWUyZmE2NmY1YmZkNDliMTc1OTQ4MmEyNThjODI1YmFiYzZlMw==", "commit": {"author": {"name": "Neil Booth", "email": "neilb@earthling.net", "date": "2000-05-10T09:39:18Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2000-05-10T09:39:18Z"}, "message": "cpplex.c (spell_token): New function.\n\n\t* cpplex.c (spell_token): New function.\n\t(spell_string, spell_comment, spell_name): fold into\n\tspell_token.\n\t(I, S): Add macros.\n\t(E, H): Remove macros.\n\t(save_comment): Save comment opening characters too.\n\t(_cpp_lex_file): Update to use spell_token.  Tidy up comment\n\thandling.\n\t* cpplib.h (I, S): Add macros.\n\t(E, H): Remove macros.\n\t(TTYPE_TABLE): Update entries for new speller.\n\t(SYNTAX_ASSERT): Remove.\n\nFrom-SVN: r33817", "tree": {"sha": "fe104bfe51165428d5f4c2be4fdff8d49abb8311", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fe104bfe51165428d5f4c2be4fdff8d49abb8311"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5d7ee2fa66f5bfd49b1759482a258c825babc6e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d7ee2fa66f5bfd49b1759482a258c825babc6e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d7ee2fa66f5bfd49b1759482a258c825babc6e3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d7ee2fa66f5bfd49b1759482a258c825babc6e3/comments", "author": null, "committer": null, "parents": [{"sha": "fb4527c3547bcce7b7465adf5164ad1d7aee7745", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb4527c3547bcce7b7465adf5164ad1d7aee7745", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb4527c3547bcce7b7465adf5164ad1d7aee7745"}], "stats": {"total": 255, "additions": 113, "deletions": 142}, "files": [{"sha": "67b2bfc1deae0c19a14d270f2722afee3cbe989a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d7ee2fa66f5bfd49b1759482a258c825babc6e3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d7ee2fa66f5bfd49b1759482a258c825babc6e3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5d7ee2fa66f5bfd49b1759482a258c825babc6e3", "patch": "@@ -1,3 +1,18 @@\n+Wed 10 May 09:36:47 2000  Neil Booth  <NeilB@earthling.net>\n+\n+\t* cpplex.c (spell_token): New function.\n+\t(spell_string, spell_comment, spell_name): fold into\n+\tspell_token.\t\n+\t(I, S): Add macros.\n+\t(E, H): Remove macros.\n+\t(save_comment): Save comment opening characters too.\n+\t(_cpp_lex_file): Update to use spell_token.  Tidy up comment\n+\thandling.\n+\t* cpplib.h (I, S): Add macros.\n+\t(E, H): Remove macros.\n+\t(TTYPE_TABLE): Update entries for new speller.\n+\t(SYNTAX_ASSERT): Remove.\n+\n Wed 10 May 09:08:30 2000  Neil Booth  <NeilB@earthling.net>\n \n         * cpplex.c (_cpp_lex_line): Maintain PREV_WHITESPACE flag"}, {"sha": "625b55eb78cf7af8332d70d6ff519e05aa802cda", "filename": "gcc/cpplex.c", "status": "modified", "additions": 76, "deletions": 119, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d7ee2fa66f5bfd49b1759482a258c825babc6e3/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d7ee2fa66f5bfd49b1759482a258c825babc6e3/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=5d7ee2fa66f5bfd49b1759482a258c825babc6e3", "patch": "@@ -84,12 +84,6 @@ void _cpp_lex_line PARAMS ((cpp_reader *, cpp_toklist *));\n \n static void _cpp_output_list PARAMS ((cpp_reader *, cpp_toklist *));\n \n-unsigned int spell_string PARAMS ((unsigned char *, cpp_toklist *,\n-\t\t\t\t   cpp_token *token));\n-unsigned int spell_comment PARAMS ((unsigned char *, cpp_toklist *,\n-\t\t\t\t    cpp_token *token));\n-unsigned int spell_name PARAMS ((unsigned char *, cpp_toklist *,\n-\t\t\t\t cpp_token *token));\n static unsigned char * spell_token PARAMS ((cpp_reader *, cpp_token *,\n \t\t\t\t\t    cpp_toklist *, unsigned char *,\n \t\t\t\t\t    int));\n@@ -120,13 +114,17 @@ typedef unsigned int (* speller) PARAMS ((unsigned char *, cpp_toklist *,\n #define IMMED_TOKEN() (!(cur_token->flags & PREV_WHITESPACE))\n #define PREV_TOKEN_TYPE (cur_token[-1].type)\n \n-#define SPELL_TEXT     0\n-#define SPELL_HANDLER  1\n-#define SPELL_CHAR     2\n-#define SPELL_NONE     3\n-\n-#define T(e, s) {SPELL_TEXT, s},\n-#define H(e, s) {SPELL_HANDLER, (PTR) s},\n+/* Order here matters.  Those beyond SPELL_NONE store their spelling\n+   in the token list, and it's length in the token->val.name.len.  */\n+#define SPELL_OPERATOR 0\n+#define SPELL_CHAR     1\n+#define SPELL_NONE     2\n+#define SPELL_IDENT    3\n+#define SPELL_STRING   4\n+\n+#define T(e, s) {SPELL_OPERATOR, s},\n+#define I(e, s) {SPELL_IDENT, s},\n+#define S(e, s) {SPELL_STRING, s},\n #define C(e, s) {SPELL_CHAR, s},\n #define N(e, s) {SPELL_NONE, s},\n \n@@ -137,7 +135,8 @@ static const struct token_spelling\n } token_spellings [N_TTYPES + 1] = {TTYPE_TABLE {0, 0} };\n \n #undef T\n-#undef H\n+#undef I\n+#undef S\n #undef C\n #undef N\n \n@@ -147,10 +146,10 @@ static const struct token_spelling\n #define BACKUP_DIGRAPH(ttype) do { \\\n   BACKUP_TOKEN(ttype); cur_token->flags |= DIGRAPH;} while (0)\n \n-/* If there is this many bytes in a buffer, you have enough room to\n-   spell the token, including preceding whitespace.  */\n-#define TOKEN_LEN(token) (5 + (token_spellings[token->type].type == \\\n-\t\t\t       SPELL_HANDLER ? token->val.name.len: 0))\n+/* An upper bound on the number of bytes needed to spell a token,\n+   including preceding whitespace.  */\n+#define TOKEN_LEN(token) (5 + (token_spellings[token->type].type > \\\n+\t\t               SPELL_NONE ? token->val.name.len: 0))\n \n #endif\n \n@@ -2760,9 +2759,11 @@ parse_string2 (pfile, list, name, terminator)\n \t\t\t : \"null character preserved\"));\n }\n \n-/* The character C helps us distinguish comment types: '*' = C style,\n-   '-' = Chill-style and '/' = C++ style.  For code simplicity, the\n-   stored comment includes any C-style comment terminator.  */\n+/* The character TYPE helps us distinguish comment types: '*' = C\n+   style, '-' = Chill-style and '/' = C++ style.  For code simplicity,\n+   the stored comment includes the comment start and any terminator.  */\n+\n+#define COMMENT_START_LEN 2\n static void\n save_comment (list, from, len, tok_no, type)\n      cpp_toklist *list;\n@@ -2772,6 +2773,9 @@ save_comment (list, from, len, tok_no, type)\n      unsigned int type;\n {\n   cpp_token *comment;\n+  unsigned char *buffer;\n+  \n+  len += COMMENT_START_LEN;\n \n   if (list->comments_used == list->comments_cap)\n     expand_comment_space (list);\n@@ -2780,12 +2784,24 @@ save_comment (list, from, len, tok_no, type)\n     expand_name_space (list, len);\n \n   comment = &list->comments[list->comments_used++];\n-  comment->type = type;\n+  comment->type = CPP_COMMENT;\n   comment->aux = tok_no;\n   comment->val.name.len = len;\n   comment->val.name.offset = list->name_used;\n \n-  memcpy (list->namebuf + list->name_used, from, len);\n+  buffer = list->namebuf + list->name_used;\n+  if (type == '*')\n+    {\n+      *buffer++ = '/';\n+      *buffer++ = '*';\n+    }\n+  else\n+    {\n+      *buffer++ = type;\n+      *buffer++ = type;\n+    }\n+\n+  memcpy (buffer, from, len - COMMENT_START_LEN);\n   list->name_used += len;\n }\n \n@@ -2956,8 +2972,7 @@ _cpp_lex_line (pfile, list)\n \t\t\t\t\t     \"multi-line comment\");\n \t\t      if (!CPP_OPTION (pfile, discard_comments))\n \t\t\tsave_comment (list, cur, buffer->cur - cur,\n-\t\t\t\t      cur_token - 1 - list->tokens, c == '/'\n-\t\t\t\t      ? CPP_CPP_COMMENT: CPP_CHILL_COMMENT);\n+\t\t\t\t      cur_token - 1 - list->tokens, c);\n \t\t      cur = buffer->cur;\n \n \t\t      /* Back-up to first '-' or '/'.  */\n@@ -2988,7 +3003,7 @@ _cpp_lex_line (pfile, list)\n \t\t\t\t \"comment end '*/' split across lines\");\n \t\t  if (!CPP_OPTION (pfile, discard_comments))\n \t\t    save_comment (list, cur, buffer->cur - cur,\n-\t\t\t\t cur_token - 1 - list->tokens, CPP_C_COMMENT);\n+\t\t\t\t cur_token - 1 - list->tokens, c);\n \t\t  cur = buffer->cur;\n \n \t\t  cur_token -= 2;\n@@ -3278,79 +3293,6 @@ _cpp_lex_line (pfile, list)\n \t\t\t \"invalid preprocessing directive\");\n }\n \n-/* Token spelling functions.  Used for output of a preprocessed file,\n-   stringizing and token pasting.  They all assume sufficient buffer\n-   is allocated, and return exactly how much they used.  */\n-\n-/* Needs buffer of 3 + len.  */\n-unsigned int\n-spell_string (buffer, list, token)\n-     unsigned char *buffer;\n-     cpp_toklist *list;\n-     cpp_token *token;\n-{\n-  unsigned char c, *orig_buff = buffer;\n-  size_t len;\n-\n-  if (token->type == CPP_WSTRING || token->type == CPP_WCHAR)\n-    *buffer++ = 'L';\n-  c = token->type == CPP_STRING || token->type == CPP_WSTRING ? '\"': '\\'';\n-  *buffer++ = c;\n-\n-  len = token->val.name.len;\n-  memcpy (buffer, list->namebuf + token->val.name.offset, len);\n-  buffer += len;\n-  *buffer++ = c;\n-  return buffer - orig_buff;\n-}\n-\n-/* Needs buffer of len + 2.  */\n-unsigned int\n-spell_comment (buffer, list, token)\n-     unsigned char *buffer;\n-     cpp_toklist *list;\n-     cpp_token *token;\n-{\n-  size_t len;\n-\n-  if (token->type == CPP_C_COMMENT)\n-    {\n-      *buffer++ = '/';\n-      *buffer++ = '*';\n-    }\n-  else if (token->type == CPP_CPP_COMMENT)\n-    {\n-      *buffer++ = '/';\n-      *buffer++ = '/';\n-    }\n-  else \n-    {\n-      *buffer++ = '-';\n-      *buffer++ = '-';\n-    }\n-\n-  len = token->val.name.len;\n-  memcpy (buffer, list->namebuf + token->val.name.offset, len);\n-\n-  return len + 2;\n-}\n-\n-/* Needs buffer of len.  */\n-unsigned int\n-spell_name (buffer, list, token)\n-     unsigned char *buffer;\n-     cpp_toklist *list;\n-     cpp_token *token;\n-{\n-  size_t len;\n-\n-  len = token->val.name.len;\n-  memcpy (buffer, list->namebuf + token->val.name.offset, len);\n-  buffer += len;\n-\n-  return len;\n-}\n-\n /* Write the spelling of a token TOKEN to BUFFER.  The buffer must\n    already contain the enough space to hold the token's spelling.  If\n    WHITESPACE is true, and the token was preceded by whitespace,\n@@ -3373,7 +3315,7 @@ spell_token (pfile, token, list, buffer, whitespace)\n \n   switch (token_spellings[token->type].type)\n     {\n-    case SPELL_TEXT:\n+    case SPELL_OPERATOR:\n       {\n \tconst unsigned char *spelling;\n \tunsigned char c;\n@@ -3388,12 +3330,26 @@ spell_token (pfile, token, list, buffer, whitespace)\n       }\n       break;\n \n-    case SPELL_HANDLER:\n+    case SPELL_IDENT:\n+      memcpy (buffer, list->namebuf + token->val.name.offset,\n+\t      token->val.name.len);\n+      buffer += token->val.name.len;\n+      break;\n+\n+    case SPELL_STRING:\n       {\n-\tspeller s;\n+\tunsigned char c;\n \n-\ts = (speller) token_spellings[token->type].speller;\n-\tbuffer += s (buffer, list, token);\n+\tif (token->type == CPP_WSTRING || token->type == CPP_WCHAR)\n+\t  *buffer++ = 'L';\n+\tc = '\\'';\n+\tif (token->type == CPP_STRING || token->type == CPP_WSTRING)\n+\t  c = '\"';\n+\t*buffer++ = c;\n+\tmemcpy (buffer, list->namebuf + token->val.name.offset,\n+\t\ttoken->val.name.len);\n+\tbuffer += token->val.name.len;\n+\t*buffer++ = c;\n       }\n       break;\n \n@@ -3448,29 +3404,30 @@ _cpp_output_list (pfile, list)\n      cpp_reader *pfile;\n      cpp_toklist *list;\n {\n-  unsigned int comment_no = 0;\n-  cpp_token *token, *comment_token = 0;\n+  cpp_token *token, *comment, *comment_before = 0;\n \n   if (list->comments_used > 0)\n-    comment_token = list->tokens + list->comments[0].aux;\n+    {\n+      comment = &list->comments[0];\n+      comment_before = &list->tokens[comment->aux];\n+    }\n \n   token = &list->tokens[0];\n   do\n     {\n       /* Output comments if -C.  */\n-      if (token == comment_token)\n+      while (token == comment_before)\n \t{\n-\t  cpp_token *comment = &list->comments[comment_no];\n-\t  do\n-\t    {\n-\t      CPP_RESERVE (pfile, TOKEN_LEN (comment));\n-\t      pfile->limit += spell_comment (pfile->limit, list, comment);\n-\t      comment_no++, comment++;\n-\t      if (comment_no == list->comments_used)\n-\t\tbreak;\n-\t      comment_token = comment->aux + list->tokens;\n-\t    }\n-\t  while (comment_token == token);\n+\t  /* Make space for the comment, and copy it out.  */\n+\t  CPP_RESERVE (pfile, TOKEN_LEN (comment));\n+\t  pfile->limit = spell_token (pfile, comment, list, pfile->limit, 0);\n+\n+\t  /* Stop if no comments left, or no more comments appear\n+             before the current token.  */\n+\t  comment++;\n+\t  if (comment == list->comments + list->comments_used)\n+\t    break;\n+\t  comment_before = &list->tokens[comment->aux];\n \t}\n \n       CPP_RESERVE (pfile, TOKEN_LEN (token));"}, {"sha": "4103a2b6f2bad0e0f9236c876403de28d51311a7", "filename": "gcc/cpplib.h", "status": "modified", "additions": 22, "deletions": 23, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d7ee2fa66f5bfd49b1759482a258c825babc6e3/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d7ee2fa66f5bfd49b1759482a258c825babc6e3/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=5d7ee2fa66f5bfd49b1759482a258c825babc6e3", "patch": "@@ -109,33 +109,31 @@ typedef struct cpp_name cpp_name;\n   T(CPP_MAX,\t\t\">?\")\t\t\t\\\n   C(CPP_OTHER,\t\t0)\t/* stray punctuation */ \\\n \\\n-  H(CPP_NAME,\t\tspell_name)\t/* word */\t\\\n-  N(CPP_INT,\t\t0)\t\t/* 23 */\t\\\n-  N(CPP_FLOAT,\t\t0)\t\t/* 3.14159 */\t\\\n-  H(CPP_NUMBER,\t\tspell_name)\t/* 34_be+ta  */\t\\\n-  H(CPP_CHAR,\t\tspell_string)\t/* 'char' */\t\\\n-  H(CPP_WCHAR,\t\tspell_string)\t/* L'char' */\t\\\n-  H(CPP_STRING,\t\tspell_string)\t/* \"string\" */\t\\\n-  H(CPP_WSTRING,\tspell_string)\t/* L\"string\" */\t\\\n+  I(CPP_NAME,\t\t0)\t/* word */\t\\\n+  N(CPP_INT,\t\t0)\t/* 23 */\t\\\n+  N(CPP_FLOAT,\t\t0)\t/* 3.14159 */\t\\\n+  I(CPP_NUMBER,\t\t0)\t/* 34_be+ta  */\t\\\n+  S(CPP_CHAR,\t\t0)\t/* 'char' */\t\\\n+  S(CPP_WCHAR,\t\t0)\t/* L'char' */\t\\\n+  S(CPP_STRING,\t\t0)\t/* \"string\" */\t\\\n+  S(CPP_WSTRING,\t0)\t/* L\"string\" */\t\\\n \\\n-  H(CPP_C_COMMENT,\tspell_comment)\t/* Only if output comments.  */ \\\n-  H(CPP_CPP_COMMENT,\tspell_comment)\t/* Only if output comments.  */ \\\n-  H(CPP_CHILL_COMMENT,\tspell_comment)\t/* Only if output comments.  */ \\\n-  N(CPP_MACRO_ARG,      0)              /* Macro argument.  */          \\\n-  N(CPP_SUBLIST,        0)\t        /* Sublist.  */                 \\\n-  T(CPP_VSPACE,\t\t\"\\n\")\t\t/* End of line.  */\t\t\\\n-  N(CPP_EOF,\t\t0)\t\t/* End of file.  */\t\t\\\n-  N(CPP_HEADER_NAME,\t0)\t\t/* <stdio.h> in #include */\t\\\n-  N(CPP_ASSERTION,\t0)\t\t/* (...) in #assert */\t\t\\\n+  I(CPP_COMMENT,\t0)\t/* Only if output comments.  */ \\\n+  N(CPP_MACRO_ARG,      0)\t/* Macro argument.  */          \\\n+  N(CPP_SUBLIST,        0)\t/* Sublist.  */                 \\\n+  T(CPP_VSPACE,\t\t\"\\n\")\t/* End of line.  */\t\t\\\n+  N(CPP_EOF,\t\t0)\t/* End of file.  */\t\t\\\n+  N(CPP_HEADER_NAME,\t0)\t/* <stdio.h> in #include */\t\\\n+  N(CPP_ASSERTION,\t0)\t/* (...) in #assert */\t\t\\\n \\\n   /* Obsolete - will be removed when no code uses them still.  */\t\\\n-  H(CPP_COMMENT,\t0)\t\t/* Only if output comments.  */ \\\n-  N(CPP_HSPACE,\t\t0)\t\t/* Horizontal white space.  */\t\\\n-  N(CPP_DIRECTIVE,\t0)\t\t/* #define and the like */\t\\\n-  N(CPP_MACRO,\t\t0)\t\t/* Like a NAME, but expanded.  */\n+  N(CPP_HSPACE,\t\t0)\t/* Horizontal white space.  */\t\\\n+  N(CPP_DIRECTIVE,\t0)\t/* #define and the like */\t\\\n+  N(CPP_MACRO,\t\t0)\t/* Like a NAME, but expanded.  */\n \n #define T(e, s) e,\n-#define H(e, s) e,\n+#define I(e, s) e,\n+#define S(e, s) e,\n #define C(e, s) e,\n #define N(e, s) e,\n enum cpp_ttype\n@@ -144,7 +142,8 @@ enum cpp_ttype\n   N_TTYPES\n };\n #undef T\n-#undef H\n+#undef I\n+#undef S\n #undef C\n #undef N\n "}]}