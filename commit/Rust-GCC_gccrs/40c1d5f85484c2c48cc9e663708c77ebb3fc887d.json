{"sha": "40c1d5f85484c2c48cc9e663708c77ebb3fc887d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDBjMWQ1Zjg1NDg0YzJjNDhjYzllNjYzNzA4Yzc3ZWJiM2ZjODg3ZA==", "commit": {"author": {"name": "Adrian Straetling", "email": "straetling@de.ibm.com", "date": "2005-07-12T09:20:21Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2005-07-12T09:20:21Z"}, "message": "builtins.c: (expand_builtin_memcmp, expand_builtin_strncmp): s/cmpstrsi/cmpstrnsi\n\n2005-07-12  Adrian Straetling  <straetling@de.ibm.com>\n\n\t* builtins.c: (expand_builtin_memcmp, expand_builtin_strncmp):\n\ts/cmpstrsi/cmpstrnsi\n\t(expand_builtin_strcmp): Rewrite to support both 'cmpstrsi' and\n\t'cmpstrnsi'.\n\t* optabs.c: (prepare_cmp_insn): Add availability of 'cmpstrn'.\n\t(init_optabs): Initialize cmpstrn_optab.\n\t* optabs.h: (enum insn_code cmpstrn_optab): Declare.\n\t* genopinit.c: (optabs[]): Add 'cmpstrn' to initialisation.\n\t* expr.c: (enum insn_code cmpstrn_optab): Declare.\n\t* config/i386/i386.md: s/cmpstr/cmpstrn\n\t* config/c4x/c4x.md: s/cmpstr/cmpstrn\n\t* doc/md.texi: Update documentation.\n\nFrom-SVN: r101916", "tree": {"sha": "958e94659cf1699b8af01c3da5cdf919e2da079f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/958e94659cf1699b8af01c3da5cdf919e2da079f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/40c1d5f85484c2c48cc9e663708c77ebb3fc887d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40c1d5f85484c2c48cc9e663708c77ebb3fc887d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40c1d5f85484c2c48cc9e663708c77ebb3fc887d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40c1d5f85484c2c48cc9e663708c77ebb3fc887d/comments", "author": null, "committer": null, "parents": [{"sha": "72f9377893a401cb13337523c1950d047d3c4acf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72f9377893a401cb13337523c1950d047d3c4acf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72f9377893a401cb13337523c1950d047d3c4acf"}], "stats": {"total": 315, "additions": 193, "deletions": 122}, "files": [{"sha": "0ab6fdebde26fbae7af1b7de9a6461f79a6951c6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40c1d5f85484c2c48cc9e663708c77ebb3fc887d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40c1d5f85484c2c48cc9e663708c77ebb3fc887d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=40c1d5f85484c2c48cc9e663708c77ebb3fc887d", "patch": "@@ -1,3 +1,18 @@\n+2005-07-12  Adrian Straetling  <straetling@de.ibm.com>\n+\n+\t* builtins.c: (expand_builtin_memcmp, expand_builtin_strncmp):\n+\ts/cmpstrsi/cmpstrnsi\n+\t(expand_builtin_strcmp): Rewrite to support both 'cmpstrsi' and\n+\t'cmpstrnsi'.\n+\t* optabs.c: (prepare_cmp_insn): Add availability of 'cmpstrn'.\n+\t(init_optabs): Initialize cmpstrn_optab.\n+\t* optabs.h: (enum insn_code cmpstrn_optab): Declare.\n+\t* genopinit.c: (optabs[]): Add 'cmpstrn' to initialisation.\n+\t* expr.c: (enum insn_code cmpstrn_optab): Declare.\n+\t* config/i386/i386.md: s/cmpstr/cmpstrn\n+\t* config/c4x/c4x.md: s/cmpstr/cmpstrn\n+\t* doc/md.texi: Update documentation.\n+\n 2005-07-11  Richard Henderson  <rth@redhat.com>\n \n \t* config/alpha/alpha.c (alpha_gimplify_va_arg_1): Use"}, {"sha": "b032fc4378489cc3b7d858abbccc0b3ce5fdc547", "filename": "gcc/builtins.c", "status": "modified", "additions": 133, "deletions": 102, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40c1d5f85484c2c48cc9e663708c77ebb3fc887d/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40c1d5f85484c2c48cc9e663708c77ebb3fc887d/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=40c1d5f85484c2c48cc9e663708c77ebb3fc887d", "patch": "@@ -3449,7 +3449,7 @@ expand_builtin_memcmp (tree exp ATTRIBUTE_UNUSED, tree arglist, rtx target,\n \treturn expand_expr (result, target, mode, EXPAND_NORMAL);\n     }\n \n-#if defined HAVE_cmpmemsi || defined HAVE_cmpstrsi\n+#if defined HAVE_cmpmemsi || defined HAVE_cmpstrnsi\n   {\n     tree arg1 = TREE_VALUE (arglist);\n     tree arg2 = TREE_VALUE (TREE_CHAIN (arglist));\n@@ -3469,9 +3469,9 @@ expand_builtin_memcmp (tree exp ATTRIBUTE_UNUSED, tree arglist, rtx target,\n       insn_mode = insn_data[(int) CODE_FOR_cmpmemsi].operand[0].mode;\n     else\n #endif\n-#ifdef HAVE_cmpstrsi\n-    if (HAVE_cmpstrsi)\n-      insn_mode = insn_data[(int) CODE_FOR_cmpstrsi].operand[0].mode;\n+#ifdef HAVE_cmpstrnsi\n+    if (HAVE_cmpstrnsi)\n+      insn_mode = insn_data[(int) CODE_FOR_cmpstrnsi].operand[0].mode;\n     else\n #endif\n       return 0;\n@@ -3504,10 +3504,10 @@ expand_builtin_memcmp (tree exp ATTRIBUTE_UNUSED, tree arglist, rtx target,\n \t\t\t   GEN_INT (MIN (arg1_align, arg2_align)));\n     else\n #endif\n-#ifdef HAVE_cmpstrsi\n-    if (HAVE_cmpstrsi)\n-      insn = gen_cmpstrsi (result, arg1_rtx, arg2_rtx, arg3_rtx,\n-\t\t\t   GEN_INT (MIN (arg1_align, arg2_align)));\n+#ifdef HAVE_cmpstrnsi\n+    if (HAVE_cmpstrnsi)\n+      insn = gen_cmpstrnsi (result, arg1_rtx, arg2_rtx, arg3_rtx,\n+\t\t\t    GEN_INT (MIN (arg1_align, arg2_align)));\n     else\n #endif\n       gcc_unreachable ();\n@@ -3558,103 +3558,134 @@ expand_builtin_strcmp (tree exp, rtx target, enum machine_mode mode)\n \treturn expand_expr (result, target, mode, EXPAND_NORMAL);\n     }\n \n-#ifdef HAVE_cmpstrsi\n-  if (HAVE_cmpstrsi)\n-  {\n-    tree arg1 = TREE_VALUE (arglist);\n-    tree arg2 = TREE_VALUE (TREE_CHAIN (arglist));\n-    tree len, len1, len2;\n-    rtx arg1_rtx, arg2_rtx, arg3_rtx;\n-    rtx result, insn;\n-    tree fndecl, fn;\n-\n-    int arg1_align\n-      = get_pointer_alignment (arg1, BIGGEST_ALIGNMENT) / BITS_PER_UNIT;\n-    int arg2_align\n-      = get_pointer_alignment (arg2, BIGGEST_ALIGNMENT) / BITS_PER_UNIT;\n-    enum machine_mode insn_mode\n-      = insn_data[(int) CODE_FOR_cmpstrsi].operand[0].mode;\n+#if defined HAVE_cmpstrsi || defined HAVE_cmpstrnsi\n+  if (cmpstr_optab[SImode] != CODE_FOR_nothing\n+      || cmpstrn_optab[SImode] != CODE_FOR_nothing)\n+    {\n+      rtx arg1_rtx, arg2_rtx;\n+      rtx result, insn = NULL_RTX;\n+      tree fndecl, fn;\n+      \n+      tree arg1 = TREE_VALUE (arglist);\n+      tree arg2 = TREE_VALUE (TREE_CHAIN (arglist));\n+      int arg1_align\n+\t= get_pointer_alignment (arg1, BIGGEST_ALIGNMENT) / BITS_PER_UNIT;\n+      int arg2_align\n+\t= get_pointer_alignment (arg2, BIGGEST_ALIGNMENT) / BITS_PER_UNIT;\n+\n+      /* If we don't have POINTER_TYPE, call the function.  */\n+      if (arg1_align == 0 || arg2_align == 0)\n+\treturn 0;\n \n-    len1 = c_strlen (arg1, 1);\n-    len2 = c_strlen (arg2, 1);\n+      /* Stabilize the arguments in case gen_cmpstr(n)si fail.  */\n+      arg1 = builtin_save_expr (arg1);\n+      arg2 = builtin_save_expr (arg2);\n \n-    if (len1)\n-      len1 = size_binop (PLUS_EXPR, ssize_int (1), len1);\n-    if (len2)\n-      len2 = size_binop (PLUS_EXPR, ssize_int (1), len2);\n+      arg1_rtx = get_memory_rtx (arg1);\n+      arg2_rtx = get_memory_rtx (arg2);\n \n-    /* If we don't have a constant length for the first, use the length\n-       of the second, if we know it.  We don't require a constant for\n-       this case; some cost analysis could be done if both are available\n-       but neither is constant.  For now, assume they're equally cheap,\n-       unless one has side effects.  If both strings have constant lengths,\n-       use the smaller.  */\n-\n-    if (!len1)\n-      len = len2;\n-    else if (!len2)\n-      len = len1;\n-    else if (TREE_SIDE_EFFECTS (len1))\n-      len = len2;\n-    else if (TREE_SIDE_EFFECTS (len2))\n-      len = len1;\n-    else if (TREE_CODE (len1) != INTEGER_CST)\n-      len = len2;\n-    else if (TREE_CODE (len2) != INTEGER_CST)\n-      len = len1;\n-    else if (tree_int_cst_lt (len1, len2))\n-      len = len1;\n-    else\n-      len = len2;\n+#ifdef HAVE_cmpstrsi\n+      /* Try to call cmpstrsi.  */\n+      if (HAVE_cmpstrsi)\n+\t{\n+\t  enum machine_mode insn_mode \n+\t    = insn_data[(int) CODE_FOR_cmpstrsi].operand[0].mode;\n+\n+\t  /* Make a place to write the result of the instruction.  */\n+\t  result = target;\n+\t  if (! (result != 0\n+\t\t && REG_P (result) && GET_MODE (result) == insn_mode\n+\t\t && REGNO (result) >= FIRST_PSEUDO_REGISTER))\n+\t    result = gen_reg_rtx (insn_mode);\n+\n+\t  insn = gen_cmpstrsi (result, arg1_rtx, arg2_rtx,\n+\t\t\t       GEN_INT (MIN (arg1_align, arg2_align)));\n+\t}\n+#endif\n+#if HAVE_cmpstrnsi \n+      /* Try to determine at least one length and call cmpstrnsi.  */\n+      if (!insn && HAVE_cmpstrnsi) \n+\t{\n+\t  tree len;\n+\t  rtx arg3_rtx;\n+\n+\t  enum machine_mode insn_mode \n+\t    = insn_data[(int) CODE_FOR_cmpstrnsi].operand[0].mode;\n+\t  tree len1 = c_strlen (arg1, 1);\n+\t  tree len2 = c_strlen (arg2, 1);\n+\n+\t  if (len1)\n+\t    len1 = size_binop (PLUS_EXPR, ssize_int (1), len1);\n+\t  if (len2)\n+\t    len2 = size_binop (PLUS_EXPR, ssize_int (1), len2);\n+\n+\t  /* If we don't have a constant length for the first, use the length\n+\t     of the second, if we know it.  We don't require a constant for\n+\t     this case; some cost analysis could be done if both are available\n+\t     but neither is constant.  For now, assume they're equally cheap,\n+\t     unless one has side effects.  If both strings have constant lengths,\n+\t     use the smaller.  */\n+\n+\t  if (!len1)\n+\t    len = len2;\n+\t  else if (!len2)\n+\t    len = len1;\n+\t  else if (TREE_SIDE_EFFECTS (len1))\n+\t    len = len2;\n+\t  else if (TREE_SIDE_EFFECTS (len2))\n+\t    len = len1;\n+\t  else if (TREE_CODE (len1) != INTEGER_CST)\n+\t    len = len2;\n+\t  else if (TREE_CODE (len2) != INTEGER_CST)\n+\t    len = len1;\n+\t  else if (tree_int_cst_lt (len1, len2))\n+\t    len = len1;\n+\t  else\n+\t    len = len2;\n \n-    /* If both arguments have side effects, we cannot optimize.  */\n-    if (!len || TREE_SIDE_EFFECTS (len))\n-      return 0;\n+\t  /* If both arguments have side effects, we cannot optimize.  */\n+\t  if (!len || TREE_SIDE_EFFECTS (len))\n+\t    return 0;\n \n-    /* If we don't have POINTER_TYPE, call the function.  */\n-    if (arg1_align == 0 || arg2_align == 0)\n-      return 0;\n+\t  /* Stabilize the arguments in case gen_cmpstrnsi fails.  */\n+\t  arg3_rtx = expand_expr (len, NULL_RTX, VOIDmode, 0);\n \n-    /* Make a place to write the result of the instruction.  */\n-    result = target;\n-    if (! (result != 0\n-\t   && REG_P (result) && GET_MODE (result) == insn_mode\n-\t   && REGNO (result) >= FIRST_PSEUDO_REGISTER))\n-      result = gen_reg_rtx (insn_mode);\n+\t  /* Make a place to write the result of the instruction.  */\n+\t  result = target;\n+\t  if (! (result != 0\n+\t\t && REG_P (result) && GET_MODE (result) == insn_mode\n+\t\t && REGNO (result) >= FIRST_PSEUDO_REGISTER))\n+\t    result = gen_reg_rtx (insn_mode);\n \n-    /* Stabilize the arguments in case gen_cmpstrsi fails.  */\n-    arg1 = builtin_save_expr (arg1);\n-    arg2 = builtin_save_expr (arg2);\n+\t  insn = gen_cmpstrnsi (result, arg1_rtx, arg2_rtx, arg3_rtx,\n+\t\t\t\tGEN_INT (MIN (arg1_align, arg2_align)));\n+\t}\n+#endif\n \n-    arg1_rtx = get_memory_rtx (arg1);\n-    arg2_rtx = get_memory_rtx (arg2);\n-    arg3_rtx = expand_expr (len, NULL_RTX, VOIDmode, 0);\n-    insn = gen_cmpstrsi (result, arg1_rtx, arg2_rtx, arg3_rtx,\n-\t\t\t GEN_INT (MIN (arg1_align, arg2_align)));\n-    if (insn)\n-      {\n-\temit_insn (insn);\n+      if (insn)\n+\t{\n+\t  emit_insn (insn);\n \n-\t/* Return the value in the proper mode for this function.  */\n-\tmode = TYPE_MODE (TREE_TYPE (exp));\n-\tif (GET_MODE (result) == mode)\n-\t  return result;\n-\tif (target == 0)\n-\t  return convert_to_mode (mode, result, 0);\n-\tconvert_move (target, result, 0);\n-\treturn target;\n-      }\n+\t  /* Return the value in the proper mode for this function.  */\n+\t  mode = TYPE_MODE (TREE_TYPE (exp));\n+\t  if (GET_MODE (result) == mode)\n+\t    return result;\n+\t  if (target == 0)\n+\t    return convert_to_mode (mode, result, 0);\n+\t  convert_move (target, result, 0);\n+\t  return target;\n+\t}\n \n-    /* Expand the library call ourselves using a stabilized argument\n-       list to avoid re-evaluating the function's arguments twice.  */\n-    arglist = build_tree_list (NULL_TREE, arg2);\n-    arglist = tree_cons (NULL_TREE, arg1, arglist);\n-    fndecl = get_callee_fndecl (exp);\n-    fn = build_function_call_expr (fndecl, arglist);\n-    if (TREE_CODE (fn) == CALL_EXPR)\n-      CALL_EXPR_TAILCALL (fn) = CALL_EXPR_TAILCALL (exp);\n-    return expand_call (fn, target, target == const0_rtx);\n-  }\n+      /* Expand the library call ourselves using a stabilized argument\n+\t list to avoid re-evaluating the function's arguments twice.  */\n+      arglist = build_tree_list (NULL_TREE, arg2);\n+      arglist = tree_cons (NULL_TREE, arg1, arglist);\n+      fndecl = get_callee_fndecl (exp);\n+      fn = build_function_call_expr (fndecl, arglist);\n+      if (TREE_CODE (fn) == CALL_EXPR)\n+\tCALL_EXPR_TAILCALL (fn) = CALL_EXPR_TAILCALL (exp);\n+      return expand_call (fn, target, target == const0_rtx);\n+    }\n #endif\n   return 0;\n }\n@@ -3679,10 +3710,10 @@ expand_builtin_strncmp (tree exp, rtx target, enum machine_mode mode)\n     }\n \n   /* If c_strlen can determine an expression for one of the string\n-     lengths, and it doesn't have side effects, then emit cmpstrsi\n+     lengths, and it doesn't have side effects, then emit cmpstrnsi\n      using length MIN(strlen(string)+1, arg3).  */\n-#ifdef HAVE_cmpstrsi\n-  if (HAVE_cmpstrsi)\n+#ifdef HAVE_cmpstrnsi\n+  if (HAVE_cmpstrnsi)\n   {\n     tree arg1 = TREE_VALUE (arglist);\n     tree arg2 = TREE_VALUE (TREE_CHAIN (arglist));\n@@ -3697,7 +3728,7 @@ expand_builtin_strncmp (tree exp, rtx target, enum machine_mode mode)\n     int arg2_align\n       = get_pointer_alignment (arg2, BIGGEST_ALIGNMENT) / BITS_PER_UNIT;\n     enum machine_mode insn_mode\n-      = insn_data[(int) CODE_FOR_cmpstrsi].operand[0].mode;\n+      = insn_data[(int) CODE_FOR_cmpstrnsi].operand[0].mode;\n \n     len1 = c_strlen (arg1, 1);\n     len2 = c_strlen (arg2, 1);\n@@ -3750,16 +3781,16 @@ expand_builtin_strncmp (tree exp, rtx target, enum machine_mode mode)\n \t   && REGNO (result) >= FIRST_PSEUDO_REGISTER))\n       result = gen_reg_rtx (insn_mode);\n \n-    /* Stabilize the arguments in case gen_cmpstrsi fails.  */\n+    /* Stabilize the arguments in case gen_cmpstrnsi fails.  */\n     arg1 = builtin_save_expr (arg1);\n     arg2 = builtin_save_expr (arg2);\n     len = builtin_save_expr (len);\n \n     arg1_rtx = get_memory_rtx (arg1);\n     arg2_rtx = get_memory_rtx (arg2);\n     arg3_rtx = expand_expr (len, NULL_RTX, VOIDmode, 0);\n-    insn = gen_cmpstrsi (result, arg1_rtx, arg2_rtx, arg3_rtx,\n-\t\t\t GEN_INT (MIN (arg1_align, arg2_align)));\n+    insn = gen_cmpstrnsi (result, arg1_rtx, arg2_rtx, arg3_rtx,\n+\t\t\t  GEN_INT (MIN (arg1_align, arg2_align)));\n     if (insn)\n       {\n \temit_insn (insn);"}, {"sha": "5054383e5204a57505c81393517b9246d21771df", "filename": "gcc/config/c4x/c4x.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40c1d5f85484c2c48cc9e663708c77ebb3fc887d/gcc%2Fconfig%2Fc4x%2Fc4x.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40c1d5f85484c2c48cc9e663708c77ebb3fc887d/gcc%2Fconfig%2Fc4x%2Fc4x.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.md?ref=40c1d5f85484c2c48cc9e663708c77ebb3fc887d", "patch": "@@ -5714,7 +5714,7 @@\n  }\")\n \n \n-(define_insn \"*cmpstrqi\"\n+(define_insn \"*cmpstrnqi\"\n   [(set (match_operand:QI 0 \"ext_reg_operand\" \"=d\")\n         (compare:QI (mem:BLK (match_operand:QI 1 \"addr_reg_operand\" \"+a\"))\n                     (mem:BLK (match_operand:QI 2 \"addr_reg_operand\" \"+a\"))))\n@@ -5731,7 +5731,7 @@\n     return \\\"\\\";\n  }\")\n \n-(define_expand \"cmpstrqi\"\n+(define_expand \"cmpstrnqi\"\n   [(parallel [(set (match_operand:QI 0 \"reg_operand\" \"\")\n                    (compare:QI (match_operand:BLK 1 \"general_operand\" \"\")\n                                (match_operand:BLK 2 \"general_operand\" \"\")))"}, {"sha": "d3a085b9f97da4e72faf00d39a4f719d164af908", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40c1d5f85484c2c48cc9e663708c77ebb3fc887d/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40c1d5f85484c2c48cc9e663708c77ebb3fc887d/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=40c1d5f85484c2c48cc9e663708c77ebb3fc887d", "patch": "@@ -17446,7 +17446,7 @@\n    (set_attr \"memory\" \"store\")\n    (set_attr \"mode\" \"QI\")])\n \n-(define_expand \"cmpstrsi\"\n+(define_expand \"cmpstrnsi\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(compare:SI (match_operand:BLK 1 \"general_operand\" \"\")\n \t\t    (match_operand:BLK 2 \"general_operand\" \"\")))\n@@ -17487,17 +17487,17 @@\n \t  emit_move_insn (operands[0], const0_rtx);\n \t  DONE;\n \t}\n-      emit_insn (gen_cmpstrqi_nz_1 (addr1, addr2, countreg, align,\n-\t\t\t\t    operands[1], operands[2]));\n+      emit_insn (gen_cmpstrnqi_nz_1 (addr1, addr2, countreg, align,\n+\t\t\t\t     operands[1], operands[2]));\n     }\n   else\n     {\n       if (TARGET_64BIT)\n \temit_insn (gen_cmpdi_1_rex64 (countreg, countreg));\n       else\n \temit_insn (gen_cmpsi_1 (countreg, countreg));\n-      emit_insn (gen_cmpstrqi_1 (addr1, addr2, countreg, align,\n-\t\t\t\t operands[1], operands[2]));\n+      emit_insn (gen_cmpstrnqi_1 (addr1, addr2, countreg, align,\n+\t\t\t\t  operands[1], operands[2]));\n     }\n \n   outlow = gen_lowpart (QImode, out);\n@@ -17528,7 +17528,7 @@\n ;; memcmp recognizers.  The `cmpsb' opcode does nothing if the count is\n ;; zero.  Emit extra code to make sure that a zero-length compare is EQ.\n \n-(define_expand \"cmpstrqi_nz_1\"\n+(define_expand \"cmpstrnqi_nz_1\"\n   [(parallel [(set (reg:CC FLAGS_REG)\n \t\t   (compare:CC (match_operand 4 \"memory_operand\" \"\")\n \t\t\t       (match_operand 5 \"memory_operand\" \"\")))\n@@ -17541,7 +17541,7 @@\n   \"\"\n   \"\")\n \n-(define_insn \"*cmpstrqi_nz_1\"\n+(define_insn \"*cmpstrnqi_nz_1\"\n   [(set (reg:CC FLAGS_REG)\n \t(compare:CC (mem:BLK (match_operand:SI 4 \"register_operand\" \"0\"))\n \t\t    (mem:BLK (match_operand:SI 5 \"register_operand\" \"1\"))))\n@@ -17557,7 +17557,7 @@\n    (set_attr \"mode\" \"QI\")\n    (set_attr \"prefix_rep\" \"1\")])\n \n-(define_insn \"*cmpstrqi_nz_rex_1\"\n+(define_insn \"*cmpstrnqi_nz_rex_1\"\n   [(set (reg:CC FLAGS_REG)\n \t(compare:CC (mem:BLK (match_operand:DI 4 \"register_operand\" \"0\"))\n \t\t    (mem:BLK (match_operand:DI 5 \"register_operand\" \"1\"))))\n@@ -17575,7 +17575,7 @@\n \n ;; The same, but the count is not known to not be zero.\n \n-(define_expand \"cmpstrqi_1\"\n+(define_expand \"cmpstrnqi_1\"\n   [(parallel [(set (reg:CC FLAGS_REG)\n \t\t(if_then_else:CC (ne (match_operand 2 \"register_operand\" \"\")\n \t\t\t\t     (const_int 0))\n@@ -17591,7 +17591,7 @@\n   \"\"\n   \"\")\n \n-(define_insn \"*cmpstrqi_1\"\n+(define_insn \"*cmpstrnqi_1\"\n   [(set (reg:CC FLAGS_REG)\n \t(if_then_else:CC (ne (match_operand:SI 6 \"register_operand\" \"2\")\n \t\t\t     (const_int 0))\n@@ -17610,7 +17610,7 @@\n    (set_attr \"mode\" \"QI\")\n    (set_attr \"prefix_rep\" \"1\")])\n \n-(define_insn \"*cmpstrqi_rex_1\"\n+(define_insn \"*cmpstrnqi_rex_1\"\n   [(set (reg:CC FLAGS_REG)\n \t(if_then_else:CC (ne (match_operand:DI 6 \"register_operand\" \"2\")\n \t\t\t     (const_int 0))\n@@ -17693,9 +17693,9 @@\n    (set_attr \"mode\" \"QI\")\n    (set_attr \"prefix_rep\" \"1\")])\n \n-;; Peephole optimizations to clean up after cmpstr*.  This should be\n+;; Peephole optimizations to clean up after cmpstrn*.  This should be\n ;; handled in combine, but it is not currently up to the task.\n-;; When used for their truth value, the cmpstr* expanders generate\n+;; When used for their truth value, the cmpstrn* expanders generate\n ;; code like this:\n ;;\n ;;   repz cmpsb\n@@ -17706,7 +17706,7 @@\n ;;\n ;; The intermediate three instructions are unnecessary.\n \n-;; This one handles cmpstr*_nz_1...\n+;; This one handles cmpstrn*_nz_1...\n (define_peephole2\n   [(parallel[\n      (set (reg:CC FLAGS_REG)\n@@ -17738,7 +17738,7 @@\n      (clobber (match_dup 2))])]\n   \"\")\n \n-;; ...and this one handles cmpstr*_1.\n+;; ...and this one handles cmpstrn*_1.\n (define_peephole2\n   [(parallel[\n      (set (reg:CC FLAGS_REG)"}, {"sha": "5af0d55e10b398c93619e1b407f41d0b8abb2845", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40c1d5f85484c2c48cc9e663708c77ebb3fc887d/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40c1d5f85484c2c48cc9e663708c77ebb3fc887d/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=40c1d5f85484c2c48cc9e663708c77ebb3fc887d", "patch": "@@ -3269,8 +3269,8 @@ operand.\n \n The use for multiple @code{setmem@var{m}} is as for @code{movmem@var{m}}.\n \n-@cindex @code{cmpstr@var{m}} instruction pattern\n-@item @samp{cmpstr@var{m}}\n+@cindex @code{cmpstrn@var{m}} instruction pattern\n+@item @samp{cmpstrn@var{m}}\n String compare instruction, with five operands.  Operand 0 is the output;\n it has mode @var{m}.  The remaining four operands are like the operands\n of @samp{movmem@var{m}}.  The two memory blocks specified are compared\n@@ -3281,6 +3281,25 @@ that may access an invalid page or segment and cause a fault.  The\n effect of the instruction is to store a value in operand 0 whose sign\n indicates the result of the comparison.\n \n+@cindex @code{cmpstr@var{m}} instruction pattern\n+@item @samp{cmpstr@var{m}}\n+String compare instruction, without known maximum length.  Operand 0 is the\n+output; it has mode @var{m}.  The second and third operand are the blocks of\n+memory to be compared; both are @code{mem:BLK} with an address in mode\n+@code{Pmode}.\n+\n+The fourth operand is the known shared alignment of the source and\n+destination, in the form of a @code{const_int} rtx.  Thus, if the\n+compiler knows that both source and destination are word-aligned,\n+it may provide the value 4 for this operand.\n+\n+The two memory blocks specified are compared byte by byte in lexicographic\n+order starting at the beginning of each string.  The instruction is not allowed\n+to prefetch more than one byte at a time since either string may end in the\n+first byte and reading past that may access an invalid page or segment and\n+cause a fault.  The effect of the instruction is to store a value in operand 0\n+whose sign indicates the result of the comparison.\n+\n @cindex @code{cmpmem@var{m}} instruction pattern\n @item @samp{cmpmem@var{m}}\n Block compare instruction, with five operands like the operands"}, {"sha": "01f890fa6a51eb9100cb99b593bfe26cd95e482f", "filename": "gcc/expr.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40c1d5f85484c2c48cc9e663708c77ebb3fc887d/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40c1d5f85484c2c48cc9e663708c77ebb3fc887d/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=40c1d5f85484c2c48cc9e663708c77ebb3fc887d", "patch": "@@ -202,9 +202,10 @@ enum insn_code movmem_optab[NUM_MACHINE_MODES];\n /* This array records the insn_code of insns to perform block sets.  */\n enum insn_code setmem_optab[NUM_MACHINE_MODES];\n \n-/* These arrays record the insn_code of two different kinds of insns\n+/* These arrays record the insn_code of three different kinds of insns\n    to perform block compares.  */\n enum insn_code cmpstr_optab[NUM_MACHINE_MODES];\n+enum insn_code cmpstrn_optab[NUM_MACHINE_MODES];\n enum insn_code cmpmem_optab[NUM_MACHINE_MODES];\n \n /* Synchronization primitives.  */"}, {"sha": "8bf574743e96a172b50e0109b14a7e85e2ff872a", "filename": "gcc/genopinit.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40c1d5f85484c2c48cc9e663708c77ebb3fc887d/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40c1d5f85484c2c48cc9e663708c77ebb3fc887d/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=40c1d5f85484c2c48cc9e663708c77ebb3fc887d", "patch": "@@ -169,6 +169,7 @@ static const char * const optabs[] =\n   \"reload_out_optab[$A] = CODE_FOR_$(reload_out$a$)\",\n   \"movmem_optab[$A] = CODE_FOR_$(movmem$a$)\",\n   \"cmpstr_optab[$A] = CODE_FOR_$(cmpstr$a$)\",\n+  \"cmpstrn_optab[$A] = CODE_FOR_$(cmpstrn$a$)\",\n   \"cmpmem_optab[$A] = CODE_FOR_$(cmpmem$a$)\",\n   \"setmem_optab[$A] = CODE_FOR_$(setmem$a$)\",\n   \"sync_add_optab[$A] = CODE_FOR_$(sync_add$I$a$)\","}, {"sha": "2f981abf19bf7837a9f1999b5ea03bf796d83d44", "filename": "gcc/optabs.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40c1d5f85484c2c48cc9e663708c77ebb3fc887d/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40c1d5f85484c2c48cc9e663708c77ebb3fc887d/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=40c1d5f85484c2c48cc9e663708c77ebb3fc887d", "patch": "@@ -3425,6 +3425,8 @@ prepare_cmp_insn (rtx *px, rtx *py, enum rtx_code *pcomparison, rtx size,\n \t  cmp_code = cmpmem_optab[cmp_mode];\n \t  if (cmp_code == CODE_FOR_nothing)\n \t    cmp_code = cmpstr_optab[cmp_mode];\n+\t  if (cmp_code == CODE_FOR_nothing)\n+\t    cmp_code = cmpstrn_optab[cmp_mode];\n \t  if (cmp_code == CODE_FOR_nothing)\n \t    continue;\n \n@@ -5090,6 +5092,7 @@ init_optabs (void)\n     {\n       movmem_optab[i] = CODE_FOR_nothing;\n       cmpstr_optab[i] = CODE_FOR_nothing;\n+      cmpstrn_optab[i] = CODE_FOR_nothing;\n       cmpmem_optab[i] = CODE_FOR_nothing;\n       setmem_optab[i] = CODE_FOR_nothing;\n "}, {"sha": "71f198abf58a5b211a7ca67a6490653f539e22db", "filename": "gcc/optabs.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40c1d5f85484c2c48cc9e663708c77ebb3fc887d/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40c1d5f85484c2c48cc9e663708c77ebb3fc887d/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=40c1d5f85484c2c48cc9e663708c77ebb3fc887d", "patch": "@@ -450,6 +450,7 @@ extern enum insn_code setmem_optab[NUM_MACHINE_MODES];\n /* These arrays record the insn_code of two different kinds of insns\n    to perform block compares.  */\n extern enum insn_code cmpstr_optab[NUM_MACHINE_MODES];\n+extern enum insn_code cmpstrn_optab[NUM_MACHINE_MODES];\n extern enum insn_code cmpmem_optab[NUM_MACHINE_MODES];\n \n /* Synchronization primitives.  This first set is atomic operation for"}]}