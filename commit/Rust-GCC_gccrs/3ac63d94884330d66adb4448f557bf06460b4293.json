{"sha": "3ac63d94884330d66adb4448f557bf06460b4293", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2FjNjNkOTQ4ODQzMzBkNjZhZGI0NDQ4ZjU1N2JmMDY0NjBiNDI5Mw==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@cygnus.com", "date": "2000-03-14T18:08:35Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2000-03-14T18:08:35Z"}, "message": "Fix spec string parsing bugs\n\nFrom-SVN: r32535", "tree": {"sha": "f5aa3882a6b4e6949b62f409484862b9f208fd92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f5aa3882a6b4e6949b62f409484862b9f208fd92"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ac63d94884330d66adb4448f557bf06460b4293", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ac63d94884330d66adb4448f557bf06460b4293", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ac63d94884330d66adb4448f557bf06460b4293", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ac63d94884330d66adb4448f557bf06460b4293/comments", "author": null, "committer": null, "parents": [{"sha": "c487e4846704a9f954636159e05437711c4c2bf4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c487e4846704a9f954636159e05437711c4c2bf4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c487e4846704a9f954636159e05437711c4c2bf4"}], "stats": {"total": 87, "additions": 53, "deletions": 34}, "files": [{"sha": "376206f8788aced587f213a439a6525c6a0d7e72", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ac63d94884330d66adb4448f557bf06460b4293/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ac63d94884330d66adb4448f557bf06460b4293/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3ac63d94884330d66adb4448f557bf06460b4293", "patch": "@@ -1,3 +1,10 @@\n+2000-03-14  Nick Clifton  <nickc@cygnus.com>\n+\n+\t* gcc.c (do_spec_1): Catch the case where %* is used in a\n+\tsubstitution pattern, but it has not been initialised.\n+\tIssue a meaningful error message if an unrecognised operator\n+\tis encountered in a spec string.\n+\n 2000-03-14  Richard Earnshaw <rearnsha@arm.com>\n \n \t* function.c (prepare_function_start): Correctly initialize"}, {"sha": "14499cff0b1d2c1123c4ba01d689f668307354e6", "filename": "gcc/gcc.c", "status": "modified", "additions": 46, "deletions": 34, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ac63d94884330d66adb4448f557bf06460b4293/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ac63d94884330d66adb4448f557bf06460b4293/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=3ac63d94884330d66adb4448f557bf06460b4293", "patch": "@@ -522,7 +522,8 @@ static char *multilib_exclusions;\n \n static const  char *const multilib_defaults_raw[] = MULTILIB_DEFAULTS;\n \n-struct user_specs {\n+struct user_specs\n+{\n   struct user_specs *next;\n   const char *filename;\n };\n@@ -1123,8 +1124,9 @@ struct spec_list\n #define INIT_STATIC_SPEC(NAME,PTR) \\\n { NAME, NULL_PTR, PTR, (struct spec_list *)0, sizeof (NAME)-1, 0 }\n \n-/* List of statically defined specs */\n-static struct spec_list static_specs[] = {\n+/* List of statically defined specs.  */\n+static struct spec_list static_specs[] =\n+{\n   INIT_STATIC_SPEC (\"asm\",\t\t\t&asm_spec),\n   INIT_STATIC_SPEC (\"asm_final\",\t\t&asm_final_spec),\n   INIT_STATIC_SPEC (\"cpp\",\t\t\t&cpp_spec),\n@@ -1150,7 +1152,7 @@ static struct spec_list static_specs[] = {\n \n #ifdef EXTRA_SPECS\t\t/* additional specs needed */\n /* Structure to keep track of just the first two args of a spec_list.\n-   That is all that the EXTRA_SPECS macro gives us. */\n+   That is all that the EXTRA_SPECS macro gives us.  */\n struct spec_list_1\n {\n   char *name;\n@@ -1176,7 +1178,7 @@ init_spec ()\n   int i;\n \n   if (specs)\n-    return;\t\t\t/* already initialized */\n+    return;\t\t\t/* Already initialized.  */\n \n   if (verbose_flag)\n     notice (\"Using builtin specs.\\n\");\n@@ -1223,7 +1225,7 @@ set_spec (name, spec)\n   int name_len = strlen (name);\n   int i;\n \n-  /* If this is the first call, initialize the statically allocated specs */\n+  /* If this is the first call, initialize the statically allocated specs.  */\n   if (!specs)\n     {\n       struct spec_list *next = (struct spec_list *)0;\n@@ -1237,14 +1239,14 @@ set_spec (name, spec)\n       specs = sl;\n     }\n \n-  /* See if the spec already exists */\n+  /* See if the spec already exists.  */\n   for (sl = specs; sl; sl = sl->next)\n     if (name_len == sl->name_len && !strcmp (sl->name, name))\n       break;\n \n   if (!sl)\n     {\n-      /* Not found - make it */\n+      /* Not found - make it.  */\n       sl = (struct spec_list *) xmalloc (sizeof (struct spec_list));\n       sl->name = xstrdup (name);\n       sl->name_len = name_len;\n@@ -1265,7 +1267,7 @@ set_spec (name, spec)\n     notice (\"Setting spec %s to '%s'\\n\\n\", name, *(sl->ptr_spec));\n #endif\n \n-  /* Free the old spec */\n+  /* Free the old spec.  */\n   if (old_spec && sl->alloc_p)\n     free (old_spec);\n \n@@ -2153,7 +2155,7 @@ make_relative_prefix (progname, bin_prefix, prefix)\n \n   prefix_dirs = split_directories (prefix, &prefix_num);\n \n-  /* Find how many directories are in common between bin_prefix & prefix */\n+  /* Find how many directories are in common between bin_prefix & prefix.  */\n   n = (prefix_num < bin_num) ? prefix_num : bin_num;\n   for (common = 0; common < n; common++)\n     {\n@@ -2454,7 +2456,7 @@ execute ()\n   struct command\n     {\n       const char *prog;\t\t/* program name.  */\n-      char **argv;\t/* vector of args.  */\n+      char **argv;\t\t/* vector of args.  */\n       int pid;\t\t\t/* pid of process for this command.  */\n     };\n \n@@ -3844,7 +3846,7 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t\t     and use them to search for dynamic linking.  */\n \t\t  /* Relative directories always come from -B,\n \t\t     and it is better not to use them for searching\n-\t\t     at run time.  In particular, stage1 loses  */\n+\t\t     at run time.  In particular, stage1 loses.  */\n \t\t  if (!IS_DIR_SEPARATOR (pl->prefix[0]))\n \t\t    continue;\n #endif\n@@ -4266,7 +4268,8 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t      char *y;\n \n \t      /* Copy all of CPP_PREDEFINES into BUF,\n-\t\t but force them all into the reserved name space if they\t\t\t aren't already there.  The reserved name space is all\n+\t\t but force them all into the reserved name space if they\n+\t\t aren't already there.  The reserved name space is all\n \t\t identifiers beginning with two underscores or with one\n \t\t underscore and a capital letter.  We do the forcing by\n \t\t adding up to two underscores to the beginning and end\n@@ -4359,7 +4362,7 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t\t  else if (*y == ' ' || *y == '\\t')\n \t\t    /* Copy whitespace to the result.  */\n \t\t    *x++ = *y++;\n-\t\t  /* Don't copy -A options  */\n+\t\t  /* Don't copy -A options.  */\n \t\t  else\n \t\t    y++;\n \t\t}\n@@ -4408,8 +4411,16 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t    break;\n \n \t  case '*':\n-\t    do_spec_1 (soft_matched_part, 1, NULL_PTR);\n-\t    do_spec_1 (\" \", 0, NULL_PTR);\n+\t    if (soft_matched_part)\n+\t      {\n+\t\tdo_spec_1 (soft_matched_part, 1, NULL_PTR);\n+\t\tdo_spec_1 (\" \", 0, NULL_PTR);\n+\t      }\n+\t    else\n+\t      /* Catch the case where a spec string contains something like\n+\t\t '%{foo:%*}'.  ie there is no * in the pattern on the left\n+\t\t hand side of the :.  */\n+\t      error (\"Spec failure: '%%*' has not been initialised by pattern match\");\n \t    break;\n \n \t    /* Process a string found as the value of a spec given by name.\n@@ -4430,7 +4441,7 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t      while (*p && *p != ')' && *p != ']')\n \t\tp++;\n \n-\t      /* See if it's in the list */\n+\t      /* See if it's in the list.  */\n \t      for (len = p - name, sl = specs; sl; sl = sl->next)\n \t\tif (sl->name_len == len && !strncmp (sl->name, name, len))\n \t\t  {\n@@ -4458,7 +4469,7 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t\t      int flag = 0;\n \n \t\t      /* Copy all of NAME into BUF, but put __ after\n-\t\t\t every -D and at the end of each arg,  */\n+\t\t\t every -D and at the end of each arg.  */\n \t\t      while (1)\n \t\t\t{\n \t\t\t  if (! strncmp (y, \"-D\", 2))\n@@ -4560,7 +4571,8 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t    break;\n \n \t  default:\n-\t    abort ();\n+\t    error (\"Spec failure: Unrecognised spec option '%c'\", c);\n+\t    break;\n \t  }\n \tbreak;\n \n@@ -5203,7 +5215,7 @@ main (argc, argv)\n     init_spec ();\n \n   /* We need to check standard_exec_prefix/just_machine_suffix/specs\n-     for any override of as, ld and libraries. */\n+     for any override of as, ld and libraries.  */\n   specs_file = (char *) alloca (strlen (standard_exec_prefix)\n \t\t\t\t+ strlen (just_machine_suffix)\n \t\t\t\t+ sizeof (\"specs\"));\n@@ -5556,7 +5568,7 @@ lookup_compiler (name, length, language)\n {\n   struct compiler *cp;\n \n-  /* If this was specified by the user to be a linker input, indicate that. */\n+  /* If this was specified by the user to be a linker input, indicate that.  */\n   if (language != 0 && language[0] == '*')\n     return 0;\n \n@@ -5756,7 +5768,7 @@ validate_all_switches ()\n \t}\n     }\n \n-  /* look through the linked list of specs read from the specs file */\n+  /* Look through the linked list of specs read from the specs file.  */\n   for (spec = specs; spec ; spec = spec->next)\n     {\n       p = *(spec->ptr_spec);\n@@ -5827,7 +5839,8 @@ used_arg (p, len)\n      const char *p;\n      int len;\n {\n-  struct mswitchstr {\n+  struct mswitchstr\n+  {\n     char *str;\n     char *replace;\n     int len;\n@@ -5845,7 +5858,7 @@ used_arg (p, len)\n       int cnt = 0;\n \n       /* Break multilib_matches into the component strings of string and replacement\n-         string */\n+         string.  */\n       for (q = multilib_matches; *q != '\\0'; q++)\n \tif (*q == ';')\n \t  cnt++;\n@@ -5953,7 +5966,7 @@ static void\n set_multilib_dir ()\n {\n   char *p;\n-  int this_path_len;\n+  unsigned int this_path_len;\n   char *this_path, *this_arg;\n   int not_arg;\n   int ok;\n@@ -6006,9 +6019,7 @@ set_multilib_dir ()\n         }\n \n       if (ok)\n-        {\n-\t  return;\n-        }\n+\treturn;\n \n       ++p;\n     }\n@@ -6114,7 +6125,7 @@ print_multilib_info ()\n   char *p = multilib_select;\n   char *last_path = 0, *this_path;\n   int skip;\n-  int last_path_len = 0;\n+  unsigned int last_path_len = 0;\n \n   while (*p != '\\0')\n     {\n@@ -6194,16 +6205,15 @@ print_multilib_info ()\n \t\t\t    ++q;\n \t\t\t}\n \n-\t\t      if (! strncmp(arg, this_arg, (len < q - arg) ? q - arg : len) ||\n-\t\t\t  default_arg(this_arg, e - this_arg))\n+\t\t      if (! strncmp (arg, this_arg, (len < q - arg) ? q - arg : len) ||\n+\t\t\t  default_arg (this_arg, e - this_arg))\n \t\t        {\n \t\t\t  mp = 1;\n \t\t\t  break;\n \t\t\t}\n \n \t\t      if (*q == ' ')\n \t\t\t++q;\n-\t\t      \n \t    \t    }\n \n \t\t  if (! mp)\n@@ -6212,6 +6222,7 @@ print_multilib_info ()\n \t          if (*e == ' ')\n \t            ++e;\n \t        }\n+\t      \n \t      if (m)\n \t        {\n \t\t  skip = 1;\n@@ -6226,7 +6237,7 @@ print_multilib_info ()\n       if (! skip)\n         {\n           /* If this is a duplicate, skip it.  */\n-          skip = (last_path != 0 && p - this_path == last_path_len\n+          skip = (last_path != 0 && (unsigned int)(p - this_path) == last_path_len\n                   && ! strncmp (last_path, this_path, last_path_len));\n \n           last_path = this_path;\n@@ -6315,7 +6326,7 @@ print_multilib_info ()\n \n       if (! skip)\n \t{\n-\t  /* If there are extra options, print them now */\n+\t  /* If there are extra options, print them now.  */\n \t  if (multilib_extra && *multilib_extra)\n \t    {\n \t      int print_at = TRUE;\n@@ -6334,6 +6345,7 @@ print_multilib_info ()\n \t\t    }\n \t\t}\n \t    }\n+\t  \n \t  putchar ('\\n');\n \t}\n "}]}