{"sha": "8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGYxN2I1YzVjYmYxNWQwZjNhNTQ4ZTk0OTI4Y2FmZjlmZmNmZDdiOA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-09-17T07:38:23Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-09-17T07:38:23Z"}, "message": "splay-tree.c (splay_tree_predecessor): Fix typo in comment.\n\n\t* splay-tree.c (splay_tree_predecessor): Fix typo in comment.\n\n\tConvert the C front-end to use function-at-a-time mode.\n\t* c-common.h: Include splay-tree.h.\n\t(C_DECLARED_LABEL_FLAG): New macro.\n\t(struct language_function): Add x_scope_stmt_stack and\n\tx_function_name_declared_p.\n\t(RECHAIN_STMTS): Move definition.\n\t(lang_statment_code_p): Likewise.\n\t(lang_expand_stmt): Likewise.\n\t(lang_expand_decl_stmt): New variable.\n\t(lang_expand_function_end): Likewise.\n\t(current_scope_stmt_stack): New function.\n\t(add_decl_stmt): Likewise.\n\t(add_scope_stmt): Likewise.\n\t(mark_stmt_tree): Likewise.\n\t(struct c_lang_decl): New structure.\n\t(DECL_SAVED_TREE): Define.\n\t(c_mark_lang_decl): New function.\n\t(c_expand_start_cond): Change prototype.\n\t(c_finish_then): New function.\n\t(c_finish_else): Likewise.\n\t(current_function_name_declared): Remove.\n\t(set_current_function_name_declared): Likewise.\n\t(mark_c_language_function): Declare.\n\t(case_compare): Likewise.\n\t(c_add_case_label): Likewise.\n\t(c_expand_expr): Likewise.\n\t(c_safe_from_p): Likewise.\n\t* c-common.c (lang_expand_function_end): New variable.\n\t(struct if_elt): Add if_stmt.\n\t(c_expand_start_cond): Add the if-statement to the statement-tree,\n\trather than generating RTL.\n\t(c_finish_then): New function.\n\t(c_expand_start_else): Don't generate RTL.\n\t(c_finish_else): New function.\n\t(c_expand_expr_stmt): Don't generate RTL.\n\t(statement_code_p): Add SCOPE_STMT.\n\t(case_compare): New function.\n\t(c_add_case_label): Likewise.\n\t(mark_stmt_tree): Likewise.\n\t(c_mark_lang_decl): Likewise.\n\t(mark_c_language_function): Likewise.\n\t(c_expand_expr): Likewise.\n\t(c_safe_from_p): Likewise.\n\t* c-decl.c (c_stmt_tree): New variable\n\t(c_scope_stmt_stack): Likewise.\n\t(c_function_name_declared_p): Likewise.\n\t(lang_expand_expr_stmt): Remove.\n\t(poplevel): Don't call output_inline_function for nested\n\tfunctions.\n\t(pushdecl): Don't set DECL_CONTEXT for a local declaration of an\n\t`extern' function.\n\t(redeclaration_error_message): Change means of computing whether\n\tor not a function is nested.\n\t(lookup_label): Don't call label_rtx.\n\t(init_decl_processing): Add more GC roots.\n\t(start_decl): Add DECL_STMTs to the statement-tree, rather than\n\tcalling rest_of_decl_compilation.\n\t(finish_decl): Don't call expand_decl.\n\t(store_parm_decls): Begin the statement-tree, but don't generate\n\tRTL.\n\t(finish_function): Tie off the statement-tree.  Call c_expand_body\n\tif appropriate.\n\t(c_expand_body): New function.\n\t(push_c_function_context): Save more information.\n\t(pop_c_function_contxt): Likewise.\n\t(copy_lang_decl): Now that we use DECL_LANG_SPECIFIC, copy it.\n\t(lang_mark_tree): Mark it.\n\t(current_stmt_tree): Adjust.\n\t(current_scope_stmt_stack): New function.\n\t(do_case): Remove.\n\t(set_current_name_declared): Likewise.\n\t(c_begin_compound_stmt): Define.\n\t(c_expand_decl_stmt): Likewise.\n\t* c-lang.c: Include rtl.h and expr.h.\n\t(lang_init): Set more language-specific hooks.\n\t* c-lex.c: Include expr.h.\n\t* c-parse.in: Changes throughout to add statements to the\n\tstatement-tree, rather than generating RTL after every statement.\n\t* c-semantics.c (lang_expand_decl_stmt): Define.\n\t(add_decl_stmt): New function.\n\t(add_scope_stmt): Likewise.\n\t(finish_stmt_tree): Tweak.\n\t(genrtl_expr_stmt): Likewise.\n\t(genrtl_decl_stmt): Handle local labels, and call\n\tlang_expand_decl_stmt if required.\n\t(genrtl_for_stmt): Fix line-number handling.\n\t(genrtl_case_label): Handle cleanups.\n\t(genrtl_asm_stmt): Don't call combine_strings.\n\t(genrtl_compound_stmt): Simplify.\n\t(expand_stmt): Handle SCOPE_STMTs.\n\t* c-tree.h (struct lang_decl): New structure.\n\t(C_DECLARED_LABEL_FLAG): Remove.\n\t(c_begin_compound_stmt): Declare.\n\t(c_expand_decl_stmt): Likewise.\n\t(c_expand_start_case): Rename to c_start_case.\n\t(c_finish_case): New function.\n\t* c-typeck.c (start_init): Tweak setting of\n\tconstructor_incremental.\n\t(c_expand_asm_operands): Tweak error-handling.  Add to the\n\tstatement-tree.\n\t(c_expand_return): Add to the statement-tree.\n\t(c_expand_start_case): Rename to ...\n\t(c_start_case): ... this.\n\t(struct c_switch): New type.\n\t(switch_stack): New variable.\n\t(do_case): Simplify.\n\t(c_finish_case): New function.\n\t* dependence.c: Include expr.h.\n\t(enum dependence_type): Change spelling of enumerals.\n\t(check_node_dependence): Adjust.\n\t* expr.h (lang_safe_from_p): Declare.\n\t(safe_from_p): Likewise.\n\t* expr.c (lang_safe_from_p): New variable.\n\t(safe_from_p): Give it external linkage.  Use lang_safe_from_p.\n\t* stmt.c (expand_expr_stmt): Avoid clobberring of last_expr_type.\n\t* toplev.c (rest_of_decl_compilation): Robustify.\n\t* tree.c (contains_placeholder_p): Likewise.\n\t* Makefile.in: Update dependencies.\n\t* objc/objc-act.h: Adjust calculation of value for dummy_tree_code.\n\t* objc/objc-act.c: Include rtl.h, expr.h, and c-common.h.\n\t(objc_expand_function_end): New function.\n\t(finish_method_def): Use it.\n\t(init_objc): Initialize more language-specific hooks.\n\t* objc/Make-lang.in: Update dependencies.\n\n\t* cp-tree.h (struct cp_language_function): Remove\n\tx_scope_stmt_stack and name_declared.\n\t(current_scope_stmt_stack): Remove.\n\t(function_name_declared_p): New macro.\n\t(struct lang_decl_flags): Use c_lang_decl as a base class.\n\t(context): Remove.\n\t(struct lang_decl): Replace saved_tree with context.\n\t(DECL_FRIEND_CONTEXT): Adjust accordingly.\n\t(SET_DECL_FRIEND_CONTEXT): Likewise.\n\t(DECL_VIRTUAL_CONTEXT): Likewise.\n\t(DECL_SAVED_TREE): Remove.\n\t(C_DECLARED_LABEL_FLAG): Likewise.\n\t(cplus_expand_expr_stmt): Don't declare.\n\t(add_decl_stmt): Likewise.\n\t(add_scope_stmt): Likewise.\n\t* decl.c (mark_stmt_tree): Remove.\n\t(case_compare): Likewise.\n\t(finish_case_label): Use c_add_case_label.\n\t(init_decl_processing): Set more language-specific hooks.\n\t(build_enumerator): Fix typo in comment.\n\t(cplus_expand_expr_stmt): Remove.\n\t(mark_lang_function): Use mark_c_language_function.\n\t(lang_mark_tree): Use c_mark_lang_decl.\n\t* decl2.c: Change order of inclusion.\n\t* except.c: Likewise.\n\t* expr.c (cplus_expand_expr): Remove handling of STMT_EXPR.  Fall\n\tback on c_expand_expr.\n\t* friend.c: Include expr.h.\n\t* init.c: Change order of inclusion.\n\t* Makefile.in: Update dependencies.\n\t* lex.h (free_lang_decl_chain): Remove.\n\t* optimize.c (maybe_clone_body): Use function_name_declared_p.\n\t* pt.c (build_template_decl): Don't copy DECL_VIRTUAL_CONTEXT if\n\tit doesn't exist.\n\t(instantiate_decl): Use function_name_declared_p.\n\t* semantics.c (lang_expand_expr_stmt): Remove.\n\t(set_current_function_name_declared): Likewise.\n\t(current_function_name_declared): Likewise.\n\t(begin_compound_stmt): Use function_name_declared_p.\n\t(add_decl_stmt): Remove.\n\t(setup_vtbl_ptr): Use function_name_declared_p.\n\t(add_scope_stmt): Remove.\n\t(current_scope_stmt_stack): New function.\n\t(cp_expand_stmt): Don't handle SCOPE_STMTs.\n\t(expand_body): Use function_name_declared_p.\n\t* tree.c (cp_statement_code_p): Don't include SCOPE_STMT.\n\t* typeck.c: Change order of includes.\n\t(convert_sequence): Remove.\n\nFrom-SVN: r36464", "tree": {"sha": "45edb9dcda813de0e477165a8b093d17332bda80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/45edb9dcda813de0e477165a8b093d17332bda80"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/comments", "author": null, "committer": null, "parents": [{"sha": "4797e955c6b44df4bef1d8d1c2ae9074480c6cf4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4797e955c6b44df4bef1d8d1c2ae9074480c6cf4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4797e955c6b44df4bef1d8d1c2ae9074480c6cf4"}], "stats": {"total": 2014, "additions": 1245, "deletions": 769}, "files": [{"sha": "d3a8a6bb80c940834c338536979931078dfacb60", "filename": "gcc/ChangeLog", "status": "modified", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8", "patch": "@@ -1,3 +1,130 @@\n+2000-09-16  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tConvert the C front-end to use function-at-a-time mode.\n+\t* c-common.h: Include splay-tree.h.\n+\t(C_DECLARED_LABEL_FLAG): New macro.\n+\t(struct language_function): Add x_scope_stmt_stack and\n+\tx_function_name_declared_p.\n+\t(RECHAIN_STMTS): Move definition.\n+\t(lang_statment_code_p): Likewise.\n+\t(lang_expand_stmt): Likewise.\n+\t(lang_expand_decl_stmt): New variable.\n+\t(lang_expand_function_end): Likewise.\n+\t(current_scope_stmt_stack): New function.\n+\t(add_decl_stmt): Likewise.\n+\t(add_scope_stmt): Likewise.\n+\t(mark_stmt_tree): Likewise.\n+\t(struct c_lang_decl): New structure.\n+\t(DECL_SAVED_TREE): Define.\n+\t(c_mark_lang_decl): New function.\n+\t(c_expand_start_cond): Change prototype.\n+\t(c_finish_then): New function.\n+\t(c_finish_else): Likewise.\n+\t(current_function_name_declared): Remove.\n+\t(set_current_function_name_declared): Likewise.\n+\t(mark_c_language_function): Declare.\n+\t(case_compare): Likewise.\n+\t(c_add_case_label): Likewise.\n+\t(c_expand_expr): Likewise.\n+\t(c_safe_from_p): Likewise.\n+\t* c-common.c (lang_expand_function_end): New variable.\n+\t(struct if_elt): Add if_stmt.\n+\t(c_expand_start_cond): Add the if-statement to the statement-tree,\n+\trather than generating RTL.\n+\t(c_finish_then): New function.\n+\t(c_expand_start_else): Don't generate RTL.\n+\t(c_finish_else): New function.\n+\t(c_expand_expr_stmt): Don't generate RTL.\n+\t(statement_code_p): Add SCOPE_STMT.\n+\t(case_compare): New function.\n+\t(c_add_case_label): Likewise.\n+\t(mark_stmt_tree): Likewise.\n+\t(c_mark_lang_decl): Likewise.\n+\t(mark_c_language_function): Likewise.\n+\t(c_expand_expr): Likewise.\n+\t(c_safe_from_p): Likewise.\n+\t* c-decl.c (c_stmt_tree): New variable\n+\t(c_scope_stmt_stack): Likewise.\n+\t(c_function_name_declared_p): Likewise.\n+\t(lang_expand_expr_stmt): Remove.\n+\t(poplevel): Don't call output_inline_function for nested\n+\tfunctions.\n+\t(pushdecl): Don't set DECL_CONTEXT for a local declaration of an\n+\t`extern' function.\n+\t(redeclaration_error_message): Change means of computing whether\n+\tor not a function is nested.\n+\t(lookup_label): Don't call label_rtx.\n+\t(init_decl_processing): Add more GC roots.\n+\t(start_decl): Add DECL_STMTs to the statement-tree, rather than\n+\tcalling rest_of_decl_compilation.\n+\t(finish_decl): Don't call expand_decl.\n+\t(store_parm_decls): Begin the statement-tree, but don't generate\n+\tRTL.\n+\t(finish_function): Tie off the statement-tree.  Call c_expand_body\n+\tif appropriate.\n+\t(c_expand_body): New function.\n+\t(push_c_function_context): Save more information.\n+\t(pop_c_function_contxt): Likewise.\n+\t(copy_lang_decl): Now that we use DECL_LANG_SPECIFIC, copy it.\n+\t(lang_mark_tree): Mark it.\n+\t(current_stmt_tree): Adjust.\n+\t(current_scope_stmt_stack): New function.\n+\t(do_case): Remove.\n+\t(set_current_name_declared): Likewise.\n+\t(c_begin_compound_stmt): Define.\n+\t(c_expand_decl_stmt): Likewise.\n+\t* c-lang.c: Include rtl.h and expr.h.\n+\t(lang_init): Set more language-specific hooks.\n+\t* c-lex.c: Include expr.h.\n+\t* c-parse.in: Changes throughout to add statements to the\n+\tstatement-tree, rather than generating RTL after every statement.\n+\t* c-semantics.c (lang_expand_decl_stmt): Define.\n+\t(add_decl_stmt): New function.\n+\t(add_scope_stmt): Likewise.\n+\t(finish_stmt_tree): Tweak.\n+\t(genrtl_expr_stmt): Likewise.\n+\t(genrtl_decl_stmt): Handle local labels, and call\n+\tlang_expand_decl_stmt if required.\n+\t(genrtl_for_stmt): Fix line-number handling.\n+\t(genrtl_case_label): Handle cleanups.\n+\t(genrtl_asm_stmt): Don't call combine_strings.\n+\t(genrtl_compound_stmt): Simplify.\n+\t(expand_stmt): Handle SCOPE_STMTs.\n+\t* c-tree.h (struct lang_decl): New structure.\n+\t(C_DECLARED_LABEL_FLAG): Remove.\n+\t(c_begin_compound_stmt): Declare.\n+\t(c_expand_decl_stmt): Likewise.\n+\t(c_expand_start_case): Rename to c_start_case.\n+\t(c_finish_case): New function.\n+\t* c-typeck.c (start_init): Tweak setting of\n+\tconstructor_incremental.\n+\t(c_expand_asm_operands): Tweak error-handling.  Add to the\n+\tstatement-tree.\n+\t(c_expand_return): Add to the statement-tree.\n+\t(c_expand_start_case): Rename to ...\n+\t(c_start_case): ... this.\n+\t(struct c_switch): New type.\n+\t(switch_stack): New variable.\n+\t(do_case): Simplify.\n+\t(c_finish_case): New function.\n+\t* dependence.c: Include expr.h.\n+\t(enum dependence_type): Change spelling of enumerals.\n+\t(check_node_dependence): Adjust.\n+\t* expr.h (lang_safe_from_p): Declare.\n+\t(safe_from_p): Likewise.\n+\t* expr.c (lang_safe_from_p): New variable.\n+\t(safe_from_p): Give it external linkage.  Use lang_safe_from_p.\n+\t* stmt.c (expand_expr_stmt): Avoid clobberring of last_expr_type.\n+\t* toplev.c (rest_of_decl_compilation): Robustify.\n+\t* tree.c (contains_placeholder_p): Likewise.\n+\t* Makefile.in: Update dependencies.\n+\t* objc/objc-act.h: Adjust calculation of value for dummy_tree_code.\n+\t* objc/objc-act.c: Include rtl.h, expr.h, and c-common.h.\n+\t(objc_expand_function_end): New function.\n+\t(finish_method_def): Use it.\n+\t(init_objc): Initialize more language-specific hooks.\n+\t* objc/Make-lang.in: Update dependencies.\n+\t\n 2000-09-16  Geoffrey Keating  <geoffk@cygnus.com>\n \n \t* configure.in: Define macros that affect features before"}, {"sha": "2734aebda04a7bec34cb7d759d3d5c5f18e388b0", "filename": "gcc/Makefile.in", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8", "patch": "@@ -782,6 +782,9 @@ GCC_H = gcc.h version.h\n GGC_H = ggc.h varray.h\n TIMEVAR_H = timevar.h timevar.def\n INSN_ATTR_H = insn-attr.h $(srcdir)/insn-addr.h $(srcdir)/varray.h\n+C_COMMON_H = c-common.h $(SPLAY_TREE_H)\n+C_TREE_H = c-tree.h $(C_COMMON_H)\n+\n #\f\n # Language makefile fragments.\n \n@@ -1077,10 +1080,10 @@ s-crt0:\t$(CRT0_S) $(MCRT0_S) $(GCC_PASSES) $(CONFIG_H)\n \n # C language specific files.\n \n-c-errors.o: c-errors.c $(CONFIG_H) system.h $(TREE_H) c-tree.h flags.h \\\n+c-errors.o: c-errors.c $(CONFIG_H) system.h $(TREE_H) $(C_TREE_H) flags.h \\\n     diagnostic.h\n c-parse.o : $(srcdir)/c-parse.c $(CONFIG_H) $(TREE_H) c-lex.h $(GGC_H) intl.h \\\n-    c-tree.h c-common.h input.h flags.h system.h toplev.h output.h cpplib.h\n+    $(C_TREE_H) input.h flags.h system.h toplev.h output.h cpplib.h\n \t$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) -c $(srcdir)/c-parse.c\n \n $(srcdir)/c-parse.c: $(srcdir)/c-parse.y\n@@ -1092,18 +1095,19 @@ $(srcdir)/c-parse.y: c-parse.in\n \t  $(srcdir)/c-parse.in >>tmp-c-parse.y\n \t$(SHELL) $(srcdir)/move-if-change tmp-c-parse.y $(srcdir)/c-parse.y\n \n-c-decl.o : c-decl.c $(CONFIG_H) system.h $(TREE_H) $(RTL_H) c-tree.h \\\n-    c-common.h $(GGC_H) c-lex.h flags.h function.h output.h $(EXPR_H) \\\n+c-decl.o : c-decl.c $(CONFIG_H) system.h $(TREE_H) $(RTL_H) $(C_TREE_H) \\\n+    $(GGC_H) c-lex.h flags.h function.h output.h $(EXPR_H) \\\n     toplev.h defaults.h intl.h\n-c-typeck.o : c-typeck.c $(CONFIG_H) system.h $(TREE_H) c-tree.h c-common.h \\\n+c-typeck.o : c-typeck.c $(CONFIG_H) system.h $(TREE_H) $(C_TREE_H) \\\n     flags.h intl.h output.h $(EXPR_H) $(RTL_H) toplev.h\n-c-lang.o : c-lang.c $(CONFIG_H) system.h $(TREE_H) c-tree.h c-common.h \\\n-    $(GGC_H)  c-lex.h toplev.h diagnostic.h output.h function.h\n-c-lex.o : c-lex.c $(CONFIG_H) system.h $(TREE_H) $(RTL_H) c-lex.h c-tree.h \\\n-    c-common.h c-pragma.h input.h intl.h flags.h toplev.h output.h \\\n-    mbchar.h $(GGC_H) cpplib.h $(SPLAY_TREE_H)\n-c-aux-info.o : c-aux-info.c  $(CONFIG_H) system.h $(TREE_H) c-tree.h \\\n-    c-common.h flags.h toplev.h\n+c-lang.o : c-lang.c $(CONFIG_H) system.h $(TREE_H) $(C_TREE_H) \\\n+    $(GGC_H)  c-lex.h toplev.h diagnostic.h output.h function.h \\\n+    $(RTL_H) $(EXPR_H)\n+c-lex.o : c-lex.c $(CONFIG_H) system.h $(TREE_H) $(RTL_H) c-lex.h $(C_TREE_H) \\\n+    c-pragma.h input.h intl.h flags.h toplev.h output.h \\\n+    mbchar.h $(GGC_H) cpplib.h $(EXPR_H)\n+c-aux-info.o : c-aux-info.c  $(CONFIG_H) system.h $(TREE_H) $(C_TREE_H) \\\n+    flags.h toplev.h\n c-convert.o : c-convert.c $(CONFIG_H) system.h $(TREE_H) flags.h toplev.h\n c-pragma.o: c-pragma.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) function.h \\\n     defaults.h c-pragma.h toplev.h $(GGC_H)\n@@ -1157,11 +1161,11 @@ s-under: $(GCC_PASSES)\n # A file used by all variants of C.\n \n c-common.o : c-common.c $(CONFIG_H) system.h $(TREE_H) \\\n-\tc-common.h flags.h toplev.h output.h c-pragma.h $(RTL_H) $(GGC_H) \\\n+\t$(C_COMMON_H) flags.h toplev.h output.h c-pragma.h $(RTL_H) $(GGC_H) \\\n \t$(EXPR_H)\n \n-c-semantics.o : c-semantics.c $(CONFIG_H) system.h $(TREE_H) c-tree.h c-lex.h \\\n-\tc-common.h flags.h toplev.h output.h c-pragma.h $(RTL_H) $(GGC_H) \\\n+c-semantics.o : c-semantics.c $(CONFIG_H) system.h $(TREE_H) $(C_TREE_H) \\\n+\tc-lex.h flags.h toplev.h output.h c-pragma.h $(RTL_H) $(GGC_H) \\\n \t$(EXPR_H)\n \n # Language-independent files.\n@@ -1406,8 +1410,8 @@ regrename.o : regrename.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h \\\n ifcvt.o : ifcvt.c $(CONFIG_H) system.h $(RTL_H) $(REGS_H) \\\n    flags.h insn-config.h function.h $(RECOG_H) $(BASIC_BLOCK_H) $(EXPR_H) \\\n    output.h\n-dependence.o : dependence.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) c-common.h \\\n-   flags.h varray.h\n+dependence.o : dependence.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) \\\n+   $(C_COMMON_H) flags.h varray.h $(EXPR_H)\n \n $(out_object_file): $(out_file) $(CONFIG_H) $(TREE_H) $(GGC_H) \\\n    $(RTL_H) $(REGS_H) hard-reg-set.h real.h insn-config.h conditions.h \\"}, {"sha": "54335dd7c6bfb04c2c9b1a0a73d3346d1c89196c", "filename": "gcc/c-common.c", "status": "modified", "additions": 317, "deletions": 10, "changes": 327, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8", "patch": "@@ -22,14 +22,14 @@ Boston, MA 02111-1307, USA.  */\n #include \"config.h\"\n #include \"system.h\"\n #include \"tree.h\"\n-#include \"c-common.h\"\n #include \"flags.h\"\n #include \"toplev.h\"\n #include \"output.h\"\n #include \"c-pragma.h\"\n #include \"rtl.h\"\n #include \"ggc.h\"\n #include \"expr.h\"\n+#include \"c-common.h\"\n #include \"tm_p.h\"\n #include \"intl.h\"\n \n@@ -149,6 +149,10 @@ tree (*make_fname_decl)                PARAMS ((tree, const char *, int));\n    returns 1 for language-specific statement codes.  */\n int (*lang_statement_code_p)           PARAMS ((enum tree_code));\n \n+/* If non-NULL, the address of a language-specific function that takes\n+   any action required right before expand_function_end is called.  */\n+void (*lang_expand_function_end)       PARAMS ((void));\n+\n /* Nonzero means the expression being parsed will never be evaluated.\n    This is a count, since unevaluated expressions can nest.  */\n int skip_evaluation;\n@@ -181,6 +185,7 @@ typedef struct\n   int line;\n   const char *file;\n   int needs_warning;\n+  tree if_stmt;\n } if_elt;\n static void tfaff\t\t\tPARAMS ((void));\n \n@@ -192,15 +197,16 @@ static int if_stack_space = 0;\n /* Stack pointer.  */\n static int if_stack_pointer = 0;\n \n-/* Generate RTL for the start of an if-then, and record the start of it\n+/* Record the start of an if-then, and record the start of it\n    for ambiguous else detection.  */\n \n void\n-c_expand_start_cond (cond, exitflag, compstmt_count)\n+c_expand_start_cond (cond, compstmt_count)\n      tree cond;\n-     int exitflag;\n      int compstmt_count;\n {\n+  tree if_stmt;\n+\n   /* Make sure there is enough space on the stack.  */\n   if (if_stack_space == 0)\n     {\n@@ -213,17 +219,29 @@ c_expand_start_cond (cond, exitflag, compstmt_count)\n       if_stack = (if_elt *)xrealloc (if_stack, if_stack_space * sizeof (if_elt));\n     }\n \n+  if_stmt = build_stmt (IF_STMT, NULL_TREE, NULL_TREE, NULL_TREE);\n+  IF_COND (if_stmt) = cond;\n+  add_stmt (if_stmt);\n+\n   /* Record this if statement.  */\n   if_stack[if_stack_pointer].compstmt_count = compstmt_count;\n   if_stack[if_stack_pointer].file = input_filename;\n   if_stack[if_stack_pointer].line = lineno;\n   if_stack[if_stack_pointer].needs_warning = 0;\n+  if_stack[if_stack_pointer].if_stmt = if_stmt;\n   if_stack_pointer++;\n+}\n \n-  expand_start_cond (cond, exitflag);\n+/* Called after the then-clause for an if-statement is processed.  */\n+\n+void\n+c_finish_then ()\n+{\n+  tree if_stmt = if_stack[if_stack_pointer - 1].if_stmt;\n+  RECHAIN_STMTS (if_stmt, THEN_CLAUSE (if_stmt));\n }\n \n-/* Generate RTL for the end of an if-then.  Optionally warn if a nested\n+/* Record the end of an if-then.  Optionally warn if a nested\n    if statement had an ambiguous else clause.  */\n \n void\n@@ -234,10 +252,10 @@ c_expand_end_cond ()\n     warning_with_file_and_line (if_stack[if_stack_pointer].file,\n \t\t\t\tif_stack[if_stack_pointer].line,\n \t\t\t\t\"suggest explicit braces to avoid ambiguous `else'\");\n-  expand_end_cond ();\n+  last_expr_type = NULL_TREE;\n }\n \n-/* Generate RTL between the then-clause and the else-clause\n+/* Called between the then-clause and the else-clause\n    of an if-then-else.  */\n \n void\n@@ -256,8 +274,15 @@ c_expand_start_else ()\n      case.  Also don't warn for any if statements nested in this else.  */\n   if_stack[if_stack_pointer - 1].needs_warning = 0;\n   if_stack[if_stack_pointer - 1].compstmt_count--;\n+}\n+\n+/* Called after the else-clause for an if-statement is processed.  */\n \n-  expand_start_else ();\n+void\n+c_finish_else ()\n+{\n+  tree if_stmt = if_stack[if_stack_pointer - 1].if_stmt;\n+  RECHAIN_STMTS (if_stmt, ELSE_CLAUSE (if_stmt));\n }\n \n /* Make bindings for __FUNCTION__, __PRETTY_FUNCTION__, and __func__.  */\n@@ -2770,7 +2795,8 @@ c_expand_expr_stmt (expr)\n       && TREE_CODE (TREE_TYPE (expr)) != ARRAY_TYPE)\n     error (\"expression statement has incomplete type\");\n \n-  expand_expr_stmt (expr);\n+  last_expr_type = TREE_TYPE (expr); \n+  add_stmt (build_stmt (EXPR_STMT, expr));\n }\n \f\n /* Validate the expression after `case' and apply default promotions.  */\n@@ -4540,6 +4566,7 @@ statement_code_p (code)\n     case RETURN_STMT:\n     case BREAK_STMT:\n     case CONTINUE_STMT:\n+    case SCOPE_STMT:\n     case SWITCH_STMT:\n     case GOTO_STMT:\n     case LABEL_STMT:\n@@ -4627,6 +4654,286 @@ walk_stmt_tree (tp, func, data)\n #undef WALK_SUBTREE\n }\n \n+/* Used to compare case labels.  K1 and K2 are actually tree nodes\n+   representing case labels, or NULL_TREE for a `default' label.\n+   Returns -1 if K1 is ordered before K2, -1 if K1 is ordered after\n+   K2, and 0 if K1 and K2 are equal.  */\n+\n+int\n+case_compare (k1, k2)\n+     splay_tree_key k1;\n+     splay_tree_key k2;\n+{\n+  /* Consider a NULL key (such as arises with a `default' label) to be\n+     smaller than anything else.  */\n+  if (!k1)\n+    return k2 ? -1 : 0;\n+  else if (!k2)\n+    return k1 ? 1 : 0;\n+\n+  return tree_int_cst_compare ((tree) k1, (tree) k2);\n+}\n+\n+/* Process a case label for the range LOW_VALUE ... HIGH_VALUE.  If\n+   LOW_VALUE and HIGH_VALUE are both NULL_TREE then this case label is\n+   actually a `default' label.  If only HIGH_VALUE is NULL_TREE, then\n+   case label was declared using the usual C/C++ syntax, rather than\n+   the GNU case range extension.  CASES is a tree containing all the\n+   case ranges processed so far; COND is the condition for the\n+   switch-statement itself.  Returns the CASE_LABEL created, or\n+   ERROR_MARK_NODE if no CASE_LABEL is created.  */\n+\n+tree\n+c_add_case_label (cases, cond, low_value, high_value)\n+     splay_tree cases;\n+     tree cond;\n+     tree low_value;\n+     tree high_value;\n+{\n+  tree type;\n+  tree label;\n+  tree case_label;\n+  splay_tree_node node;\n+\n+  /* Create the LABEL_DECL itself.  */\n+  label = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n+  DECL_CONTEXT (label) = current_function_decl;\n+\n+  /* If there was an error processing the switch condition, bail now\n+     before we get more confused.  */\n+  if (!cond || cond == error_mark_node)\n+    {\n+      /* Add a label anyhow so that the back-end doesn't think that\n+\t the beginning of the switch is unreachable.  */\n+      if (!cases->root)\n+\tadd_stmt (build_case_label (NULL_TREE, NULL_TREE, label));\n+      return error_mark_node;\n+    }\n+\n+  if ((low_value && TREE_TYPE (low_value) \n+       && POINTER_TYPE_P (TREE_TYPE (low_value))) \n+      || (high_value && TREE_TYPE (high_value)\n+\t  && POINTER_TYPE_P (TREE_TYPE (high_value))))\n+    error (\"pointers are not permitted as case values\");\n+\n+  /* Case ranges are a GNU extension.  */\n+  if (high_value && pedantic)\n+    {\n+      if (c_language == clk_cplusplus)\n+\tpedwarn (\"ISO C++ forbids range expressions in switch statements\");\n+      else\n+\tpedwarn (\"ISO C forbids range expressions in switch statements\");\n+    }\n+\n+  type = TREE_TYPE (cond);\n+  if (low_value)\n+    {\n+      low_value = check_case_value (low_value);\n+      low_value = convert_and_check (type, low_value);\n+    }\n+  if (high_value)\n+    {\n+      high_value = check_case_value (high_value);\n+      high_value = convert_and_check (type, high_value);\n+    }\n+\n+  /* If an error has occurred, bail out now.  */\n+  if (low_value == error_mark_node || high_value == error_mark_node)\n+    {\n+      if (!cases->root)\n+\tadd_stmt (build_case_label (NULL_TREE, NULL_TREE, label));\n+      return error_mark_node;\n+    }\n+\n+  /* If the LOW_VALUE and HIGH_VALUE are the same, then this isn't\n+     really a case range, even though it was written that way.  Remove\n+     the HIGH_VALUE to simplify later processing.  */\n+  if (tree_int_cst_equal (low_value, high_value))\n+    high_value = NULL_TREE;\n+  if (low_value && high_value \n+      && !tree_int_cst_lt (low_value, high_value)) \n+    warning (\"empty range specified\");\n+\n+  /* Look up the LOW_VALUE in the table of case labels we already\n+     have.  */\n+  node = splay_tree_lookup (cases, (splay_tree_key) low_value);\n+  /* If there was not an exact match, check for overlapping ranges.\n+     There's no need to do this if there's no LOW_VALUE or HIGH_VALUE;\n+     that's a `default' label and the only overlap is an exact match.  */\n+  if (!node && (low_value || high_value))\n+    {\n+      splay_tree_node low_bound;\n+      splay_tree_node high_bound;\n+\n+      /* Even though there wasn't an exact match, there might be an\n+\t overlap between this case range and another case range.\n+\t Since we've (inductively) not allowed any overlapping case\n+\t ranges, we simply need to find the greatest low case label\n+\t that is smaller that LOW_VALUE, and the smallest low case\n+\t label that is greater than LOW_VALUE.  If there is an overlap\n+\t it will occur in one of these two ranges.  */\n+      low_bound = splay_tree_predecessor (cases,\n+\t\t\t\t\t  (splay_tree_key) low_value);\n+      high_bound = splay_tree_successor (cases,\n+\t\t\t\t\t (splay_tree_key) low_value);\n+\n+      /* Check to see if the LOW_BOUND overlaps.  It is smaller than\n+\t the LOW_VALUE, so there is no need to check unless the\n+\t LOW_BOUND is in fact itself a case range.  */\n+      if (low_bound\n+\t  && CASE_HIGH ((tree) low_bound->value)\n+\t  && tree_int_cst_compare (CASE_HIGH ((tree) low_bound->value),\n+\t\t\t\t    low_value) >= 0)\n+\tnode = low_bound;\n+      /* Check to see if the HIGH_BOUND overlaps.  The low end of that\n+\t range is bigger than the low end of the current range, so we\n+\t are only interested if the current range is a real range, and\n+\t not an ordinary case label.  */\n+      else if (high_bound \n+\t       && high_value\n+\t       && (tree_int_cst_compare ((tree) high_bound->key,\n+\t\t\t\t\t high_value)\n+\t\t   <= 0))\n+\tnode = high_bound;\n+    }\n+  /* If there was an overlap, issue an error.  */\n+  if (node)\n+    {\n+      tree duplicate = CASE_LABEL_DECL ((tree) node->value);\n+\n+      if (high_value)\n+\t{\n+\t  error (\"duplicate (or overlapping) case value\");\n+\t  error_with_decl (duplicate, \n+\t\t\t   \"this is the first entry overlapping that value\");\n+\t}\n+      else if (low_value)\n+\t{\n+\t  error (\"duplicate case value\") ;\n+\t  error_with_decl (duplicate, \"previously used here\");\n+\t}\n+      else\n+\t{\n+\t  error (\"multiple default labels in one switch\");\n+\t  error_with_decl (duplicate, \"this is the first default label\");\n+\t}\n+      if (!cases->root)\n+\tadd_stmt (build_case_label (NULL_TREE, NULL_TREE, label));\n+    }\n+\n+  /* Add a CASE_LABEL to the statement-tree.  */\n+  case_label = add_stmt (build_case_label (low_value, high_value, label));\n+  /* Register this case label in the splay tree.  */\n+  splay_tree_insert (cases, \n+\t\t     (splay_tree_key) low_value,\n+\t\t     (splay_tree_value) case_label);\n+\n+  return case_label;\n+}\n+\n+/* Mark P (a stmt_tree) for GC.  The use of a `void *' for the\n+   parameter allows this function to be used as a GC-marking\n+   function.  */\n+\n+void\n+mark_stmt_tree (p)\n+     void *p;\n+{\n+  stmt_tree st = (stmt_tree) p;\n+\n+  ggc_mark_tree (st->x_last_stmt);\n+  ggc_mark_tree (st->x_last_expr_type);\n+}\n+\n+/* Mark LD for GC.  */\n+\n+void\n+c_mark_lang_decl (c)\n+     struct c_lang_decl *c;\n+{\n+  ggc_mark_tree (c->saved_tree);\n+}\n+\n+/* Mark F for GC.  */\n+\n+void\n+mark_c_language_function (f)\n+     struct language_function *f;\n+{\n+  if (!f)\n+    return;\n+\n+  mark_stmt_tree (&f->x_stmt_tree);\n+  ggc_mark_tree (f->x_scope_stmt_stack);\n+}\n+\n+/* Hook used by expand_expr to expand language-specific tree codes.  */\n+\n+rtx\n+c_expand_expr (exp, target, tmode, modifier)\n+     tree exp;\n+     rtx target;\n+     enum machine_mode tmode;\n+     enum expand_modifier modifier;\n+{\n+  switch (TREE_CODE (exp))\n+    {\n+    case STMT_EXPR:\n+      {\n+\ttree rtl_expr;\n+\trtx result;\n+\n+\t/* Since expand_expr_stmt calls free_temp_slots after every\n+\t   expression statement, we must call push_temp_slots here.\n+\t   Otherwise, any temporaries in use now would be considered\n+\t   out-of-scope after the first EXPR_STMT from within the\n+\t   STMT_EXPR.  */\n+\tpush_temp_slots ();\n+\trtl_expr = expand_start_stmt_expr ();\n+\texpand_stmt (STMT_EXPR_STMT (exp));\n+\texpand_end_stmt_expr (rtl_expr);\n+\tresult = expand_expr (rtl_expr, target, tmode, modifier);\n+\tpop_temp_slots ();\n+\treturn result;\n+      }\n+      break;\n+      \n+    default:\n+      abort ();\n+    }\n+\n+  abort ();\n+  return NULL;\n+}\n+\n+/* Hook used by safe_from_p to handle language-specific tree codes.  */\n+\n+int\n+c_safe_from_p (target, exp)\n+     rtx target;\n+     tree exp;\n+{\n+  /* We can see statements here when processing the body of a\n+     statement-expression.  For a declaration statement declaring a\n+     variable, look at the variable's initializer.  */\n+  if (TREE_CODE (exp) == DECL_STMT) \n+    {\n+      tree decl = DECL_STMT_DECL (exp);\n+\n+      if (TREE_CODE (decl) == VAR_DECL\n+\t  && DECL_INITIAL (decl)\n+\t  && !safe_from_p (target, DECL_INITIAL (decl), /*top_p=*/0))\n+\treturn 0;\n+    }\n+\n+  /* For any statement, we must follow the statement-chain.  */\n+  if (statement_code_p (TREE_CODE (exp)) && TREE_CHAIN (exp))\n+    return safe_from_p (target, TREE_CHAIN (exp), /*top_p=*/0);\n+\n+  /* Assume everything else is safe.  */\n+  return 1;\n+}\n+\n /* Tree code classes. */\n \n #define DEFTREECODE(SYM, NAME, TYPE, LENGTH) TYPE,"}, {"sha": "2477a0f33aeef40bc0cf7be70efafb8788530e7b", "filename": "gcc/c-common.h", "status": "modified", "additions": 73, "deletions": 17, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8", "patch": "@@ -22,6 +22,8 @@ Boston, MA 02111-1307, USA.  */\n #ifndef GCC_C_COMMON_H\n #define GCC_C_COMMON_H\n \n+#include \"splay-tree.h\"\n+\n /* Usage of TREE_LANG_FLAG_?:\n    0: COMPOUND_STMT_NO_SCOPE (in COMPOUND_STMT).\n       TREE_NEGATED_INT (in INTEGER_CST).\n@@ -194,6 +196,10 @@ enum c_tree_index\n \n extern tree c_global_trees[CTI_MAX];\n \n+/* Mark which labels are explicitly declared.\n+   These may be shadowed, and may be referenced from nested functions.  */\n+#define C_DECLARED_LABEL_FLAG(label) TREE_LANG_FLAG_1 (label)\n+\n typedef enum c_language_kind\n {\n   clk_c,           /* A dialect of C: K&R C, ANSI/ISO C89, C2000,\n@@ -237,6 +243,11 @@ struct language_function {\n   /* While we are parsing the function, this contains information\n      about the statement-tree that we are building.  */\n   struct stmt_tree_s x_stmt_tree;\n+  /* The stack of SCOPE_STMTs for the current function.  */\n+  tree x_scope_stmt_stack;\n+  /* Nonzero if __FUNCTION__ and its ilk have been declared in this\n+     function.  */\n+  int x_function_name_declared_p;\n };\n \n /* When building a statement-tree, this is the last statement added to\n@@ -248,37 +259,65 @@ struct language_function {\n \n #define last_expr_type (current_stmt_tree ()->x_last_expr_type)\n \n+/* LAST_TREE contains the last statement parsed.  These are chained\n+   together through the TREE_CHAIN field, but often need to be\n+   re-organized since the parse is performed bottom-up.  This macro\n+   makes LAST_TREE the indicated SUBSTMT of STMT.  */\n+\n+#define RECHAIN_STMTS(stmt, substmt)\t\t\\\n+  do {\t\t\t\t\t\t\\\n+    substmt = TREE_CHAIN (stmt);\t\t\\\n+    TREE_CHAIN (stmt) = NULL_TREE;\t\t\\\n+    last_tree = stmt;\t\t\t\t\\\n+  } while (0)\n+\n+/* Language-specific hooks.  */\n+\n+extern int (*lang_statement_code_p)             PARAMS ((enum tree_code));\n+extern void (*lang_expand_stmt)                 PARAMS ((tree));\n+extern void (*lang_expand_decl_stmt)            PARAMS ((tree));\n+extern void (*lang_expand_function_end)         PARAMS ((void));\n+\n /* The type of a function that walks over tree structure.  */\n \n typedef tree (*walk_tree_fn)                    PARAMS ((tree *, \n \t\t\t\t\t\t\t int *, \n \t\t\t\t\t\t\t void *));\n \n extern stmt_tree current_stmt_tree              PARAMS ((void));\n+extern tree *current_scope_stmt_stack           PARAMS ((void));\n extern void begin_stmt_tree                     PARAMS ((tree *));\n extern tree add_stmt\t\t\t\tPARAMS ((tree));\n+extern void add_decl_stmt                       PARAMS ((tree));\n+extern tree add_scope_stmt                      PARAMS ((int, int));\n extern void finish_stmt_tree                    PARAMS ((tree *));\n \n extern int statement_code_p                     PARAMS ((enum tree_code));\n-extern int (*lang_statement_code_p)             PARAMS ((enum tree_code));\n extern tree walk_stmt_tree\t\t\tPARAMS ((tree *,\n \t\t\t\t\t\t\t walk_tree_fn,\n \t\t\t\t\t\t\t void *));\n extern void prep_stmt                           PARAMS ((tree));\n-extern void (*lang_expand_stmt)                 PARAMS ((tree));\n extern void expand_stmt                         PARAMS ((tree));\n+extern void mark_stmt_tree                      PARAMS ((void *));\n \n-/* LAST_TREE contains the last statement parsed.  These are chained\n-   together through the TREE_CHAIN field, but often need to be\n-   re-organized since the parse is performed bottom-up.  This macro\n-   makes LAST_TREE the indicated SUBSTMT of STMT.  */\n+/* Extra information associated with a DECL.  Other C dialects extend\n+   this structure in various ways.  The C front-end only uses this\n+   structure for FUNCTION_DECLs; all other DECLs have a NULL\n+   DECL_LANG_SPECIFIC field.  */\n \n-#define RECHAIN_STMTS(stmt, substmt)\t\t\\\n-  do {\t\t\t\t\t\t\\\n-    substmt = TREE_CHAIN (stmt);\t\t\\\n-    TREE_CHAIN (stmt) = NULL_TREE;\t\t\\\n-    last_tree = stmt;\t\t\t\t\\\n-  } while (0)\n+struct c_lang_decl {\n+  /* In a FUNCTION_DECL, this is DECL_SAVED_TREE.  */\n+  tree saved_tree;\n+};\n+\n+/* In a FUNCTION_DECL, the saved representation of the body of the\n+   entire function.  Usually a COMPOUND_STMT, but in C++ this may also\n+   be a RETURN_INIT, CTOR_INITIALIZER, or TRY_BLOCK.  */\n+#define DECL_SAVED_TREE(NODE)\t\t\t\t\t\t    \\\n+  (((struct c_lang_decl *) DECL_LANG_SPECIFIC (FUNCTION_DECL_CHECK (NODE))) \\\n+   ->saved_tree)\n+\n+extern void c_mark_lang_decl                    PARAMS ((struct c_lang_decl *));\n \n /* The variant of the C language being processed.  Each C language\n    front-end defines this variable.  */\n@@ -363,8 +402,10 @@ extern void c_apply_type_quals_to_decl\t\tPARAMS ((int, tree));\n    NOP_EXPR is used as a special case (see truthvalue_conversion).  */\n extern void binary_op_error\t\t\tPARAMS ((enum tree_code));\n extern void c_expand_expr_stmt\t\t\tPARAMS ((tree));\n-extern void c_expand_start_cond\t\t\tPARAMS ((tree, int, int));\n+extern void c_expand_start_cond\t\t\tPARAMS ((tree, int));\n+extern void c_finish_then                       PARAMS ((void));\n extern void c_expand_start_else\t\t\tPARAMS ((void));\n+extern void c_finish_else                   PARAMS ((void));\n extern void c_expand_end_cond\t\t\tPARAMS ((void));\n /* Validate the expression after `case' and apply default promotions.  */\n extern tree check_case_value\t\t\tPARAMS ((tree));\n@@ -589,8 +630,6 @@ extern void genrtl_asm_stmt                     PARAMS ((tree, tree,\n \t\t\t\t\t\t\t tree));\n extern void genrtl_decl_cleanup                 PARAMS ((tree, tree));\n extern int stmts_are_full_exprs_p               PARAMS ((void));\n-typedef void (*expand_expr_stmt_fn)             PARAMS ((tree));\n-extern expand_expr_stmt_fn lang_expand_expr_stmt;\n extern int anon_aggr_type_p                     PARAMS ((tree));\n \n /* For a VAR_DECL that is an anonymous union, these are the various\n@@ -611,8 +650,6 @@ extern tree build_return_stmt                   PARAMS ((tree));\n #define COMPOUND_STMT_NO_SCOPE(NODE)\tTREE_LANG_FLAG_0 (NODE)\n \n extern void c_expand_asm_operands\t\tPARAMS ((tree, tree, tree, tree, int, const char *, int));\n-extern int current_function_name_declared       PARAMS ((void));\n-extern void set_current_function_name_declared  PARAMS ((int));\n \n /* These functions must be defined by each front-end which implements\n    a variant of the C language.  They are used in c-common.c.  */\n@@ -637,6 +674,25 @@ extern tree decl_constant_value\t\tPARAMS ((tree));\n    after entering or leaving a header file.  */\n extern void extract_interface_info\t\tPARAMS ((void));\n \n+extern void mark_c_language_function            PARAMS ((struct language_function *));\n+\n+extern int case_compare                         PARAMS ((splay_tree_key, \n+\t\t\t\t\t\t\t splay_tree_key));\n+\n+extern tree c_add_case_label                    PARAMS ((splay_tree,\n+\t\t\t\t\t\t\t tree, tree,\n+\t\t\t\t\t\t\t tree));\n+\n+#ifdef RTX_CODE\n+\n+extern struct rtx_def *c_expand_expr            PARAMS ((tree, rtx,\n+\t\t\t\t\t\t\t enum machine_mode,\n+\t\t\t\t\t\t\t enum expand_modifier));\n+\n+extern int c_safe_from_p                        PARAMS ((rtx, tree));\n+\n+#endif\n+\n /* Information recorded about each file examined during compilation.  */\n \n struct c_fileinfo"}, {"sha": "b8421a7c4bc1db30d2ab9a65db12375b020fe9c6", "filename": "gcc/c-decl.c", "status": "modified", "additions": 200, "deletions": 131, "changes": 331, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8", "patch": "@@ -125,6 +125,19 @@ static tree current_function_parm_tags;\n static const char *current_function_prototype_file;\n static int current_function_prototype_line;\n \n+/* The current statement tree.  */\n+\n+static struct stmt_tree_s c_stmt_tree;\n+\n+/* The current scope statement stack.  */\n+\n+static tree c_scope_stmt_stack;\n+\n+/* Nonzero if __FUNCTION__ and its ilk have been declared in this\n+   function.  */\n+\n+static int c_function_name_declared_p;\n+\n /* A list (chain of TREE_LIST nodes) of all LABEL_DECLs in the function\n    that have names.  Here so we can clear out their names' definitions\n    at the end of the function.  */\n@@ -296,6 +309,7 @@ static tree grokdeclarator\t\tPARAMS ((tree, tree, enum decl_context,\n static tree grokparms\t\t\tPARAMS ((tree, int));\n static void layout_array_type\t\tPARAMS ((tree));\n static tree c_make_fname_decl           PARAMS ((tree, const char *, int));\n+static void c_expand_body               PARAMS ((tree, int));\n \f\n /* C-specific option variables.  */\n \n@@ -471,10 +485,6 @@ int warn_float_equal = 0;\n \n int warn_multichar = 1;\n \n-/* Wrapper since C and C++ expand_expr_stmt are different.  */\n-\n-expand_expr_stmt_fn lang_expand_expr_stmt = c_expand_expr_stmt;\n-\n /* The variant of the C language being processed.  */\n \n c_language_kind c_language = clk_c;\n@@ -1088,12 +1098,6 @@ poplevel (keep, reverse, functionbody)\n \tif (DECL_ABSTRACT_ORIGIN (decl) != 0\n \t    && DECL_ABSTRACT_ORIGIN (decl) != decl)\n \t  TREE_ADDRESSABLE (DECL_ABSTRACT_ORIGIN (decl)) = 1;\n-\telse if (DECL_SAVED_INSNS (decl) != 0)\n-\t  {\n-\t    push_function_context ();\n-\t    output_inline_function (decl);\n-\t    pop_function_context ();\n-\t  }\n       }\n \n   /* If there were any declarations or structure tags in that level,\n@@ -1235,6 +1239,7 @@ poplevel (keep, reverse, functionbody)\n \n   if (block)\n     TREE_USED (block) = 1;\n+\n   return block;\n }\n \n@@ -2063,8 +2068,8 @@ pushdecl (x)\n   /* A local extern declaration for a function doesn't constitute nesting.\n      A local auto declaration does, since it's a forward decl\n      for a nested function coming later.  */\n-  if (TREE_CODE (x) == FUNCTION_DECL && DECL_INITIAL (x) == 0\n-      && DECL_EXTERNAL (x))\n+  if ((TREE_CODE (x) == FUNCTION_DECL || TREE_CODE (x) == VAR_DECL)\n+      && DECL_INITIAL (x) == 0 && DECL_EXTERNAL (x))\n     DECL_CONTEXT (x) = 0;\n \n   if (warn_nested_externs && DECL_EXTERNAL (x) && b != global_binding_level\n@@ -2618,7 +2623,7 @@ redeclaration_error_message (newdecl, olddecl)\n \treturn 1;\n       return 0;\n     }\n-  else if (current_binding_level == global_binding_level)\n+  else if (DECL_CONTEXT (newdecl) == NULL_TREE)\n     {\n       /* Objects declared at top level:  */\n       /* If at least one is a reference, it's ok.  */\n@@ -2678,9 +2683,6 @@ lookup_label (id)\n \n   decl = build_decl (LABEL_DECL, id, void_type_node);\n \n-  /* Make sure every label has an rtx.  */\n-  label_rtx (decl);\n-\n   /* A label not explicitly declared must be local to where it's ref'd.  */\n   DECL_CONTEXT (decl) = current_function_decl;\n \n@@ -3217,6 +3219,8 @@ init_decl_processing ()\n   /* Record our roots.  */\n \n   ggc_add_tree_root (c_global_trees, CTI_MAX);\n+  ggc_add_root (&c_stmt_tree, 1, sizeof c_stmt_tree, mark_stmt_tree);\n+  ggc_add_tree_root (&c_scope_stmt_stack, 1);\n   ggc_add_tree_root (&named_labels, 1);\n   ggc_add_tree_root (&shadowed_labels, 1);\n   ggc_add_root (&current_binding_level, 1, sizeof current_binding_level,\n@@ -3553,7 +3557,8 @@ start_decl (declarator, declspecs, initialized, attributes, prefix_attributes)\n       /* But not if this is a duplicate decl\n \t and we preserved the rtl from the previous one\n \t (which may or may not happen).  */\n-      && DECL_RTL (tem) == 0)\n+      && DECL_RTL (tem) == 0\n+      && !DECL_CONTEXT (tem))\n     {\n       if (COMPLETE_TYPE_P (TREE_TYPE (tem)))\n \texpand_decl (tem);\n@@ -3703,9 +3708,17 @@ finish_decl (decl, init, asmspec_tree)\n     {\n       /* This is a no-op in c-lang.c or something real in objc-actions.c.  */\n       maybe_objc_check_decl (decl);\n-      rest_of_decl_compilation (decl, asmspec,\n-\t\t\t\t(DECL_CONTEXT (decl) == 0\n-\t\t\t\t || TREE_ASM_WRITTEN (decl)), 0);\n+\n+      if (!DECL_CONTEXT (decl))\n+\trest_of_decl_compilation (decl, asmspec,\n+\t\t\t\t  (DECL_CONTEXT (decl) == 0\n+\t\t\t\t   || TREE_ASM_WRITTEN (decl)), 0);\n+      else\n+\t{\n+\t  if (asmspec)\n+\t    DECL_ASSEMBLER_NAME (decl) = get_identifier (asmspec);\n+\t  add_decl_stmt (decl);\n+\t}\n \n       if (DECL_CONTEXT (decl) != 0)\n \t{\n@@ -3719,11 +3732,7 @@ finish_decl (decl, init, asmspec_tree)\n \t      /* If it's still incomplete now, no init will save it.  */\n \t      if (DECL_SIZE (decl) == 0)\n \t\tDECL_INITIAL (decl) = 0;\n-\t      expand_decl (decl);\n \t    }\n-\t  /* Compute and store the initial value.  */\n-\t  if (TREE_CODE (decl) != FUNCTION_DECL)\n-\t    expand_decl_init (decl);\n \t}\n     }\n \n@@ -5784,6 +5793,7 @@ build_enumerator (name, value)\n \n   return tree_cons (decl, value, NULL_TREE);\n }\n+\n \f\n /* Create the FUNCTION_DECL for a function definition.\n    DECLSPECS, DECLARATOR, PREFIX_ATTRIBUTES and ATTRIBUTES are the parts of\n@@ -6432,25 +6442,20 @@ store_parm_decls ()\n \n   init_function_start (fndecl, input_filename, lineno);\n \n-  /* If this is a varargs function, inform function.c.  */\n-\n-  if (c_function_varargs)\n-    mark_varargs ();\n+  /* Begin the statement tree for this function.  */\n+  DECL_LANG_SPECIFIC (current_function_decl) \n+    =((struct lang_decl *) ggc_alloc (sizeof (struct lang_decl)));\n+  begin_stmt_tree (&DECL_SAVED_TREE (current_function_decl));\n \n-  /* Declare __FUNCTION__ and __PRETTY_FUNCTION__ for this function.  */\n-\n-  declare_function_name ();\n+  /* This function is being processed in whole-function mode.  */\n+  cfun->x_whole_function_mode_p = 1;\n \n-  /* Set up parameters and prepare for return, for the function.  */\n-\n-  expand_function_start (fndecl, 0);\n-\n-  /* If this function is `main', emit a call to `__main'\n-     to run global initializers, etc.  */\n-  if (DECL_NAME (fndecl)\n-      && MAIN_NAME_P (DECL_NAME (fndecl))\n-      && DECL_CONTEXT (fndecl) == NULL_TREE)\n-    expand_main_function ();\n+  /* Even though we're inside a function body, we still don't want to\n+     call expand_expr to calculate the size of a variable-sized array.\n+     We haven't necessarily assigned RTL to all variables yet, so it's\n+     not safe to try to expand expressions involving them.  */\n+  immediate_size_expand = 0;\n+  cfun->x_dont_save_pending_sizes_p = 1;\n }\n \f\n /* SPECPARMS is an identifier list--a chain of TREE_LIST nodes\n@@ -6650,6 +6655,82 @@ finish_function (nested)\n \t}\n     }\n \n+  /* Tie off the statement tree for this function.  */\n+  finish_stmt_tree (&DECL_SAVED_TREE (fndecl));\n+  /* Clear out memory we no longer need.  */\n+  free_after_parsing (cfun);\n+  /* Since we never call rest_of_compilation, we never clear\n+     CFUN.  Do so explicitly.  */\n+  free_after_compilation (cfun);\n+  cfun = NULL;\n+\n+  if (! nested)\n+    {\n+      /* Generate RTL for the body of this function.  */\n+      c_expand_body (fndecl, nested);\n+      /* Let the error reporting routines know that we're outside a\n+\t function.  For a nested function, this value is used in\n+\t pop_c_function_context and then reset via pop_function_context.  */\n+      current_function_decl = NULL;\n+    }\n+}\n+\n+/* Generate the RTL for the body of FNDECL.  If NESTED_P is non-zero,\n+   then we are already in the process of generating RTL for another\n+   function.  */\n+\n+static void\n+c_expand_body (fndecl, nested_p)\n+     tree fndecl;\n+     int nested_p;\n+{\n+  /* Squirrel away our current state.  */\n+  if (nested_p)\n+    push_function_context ();\n+\n+  /* Initialize the RTL code for the function.  */\n+  current_function_decl = fndecl;\n+  init_function_start (fndecl, input_filename, lineno);\n+\n+  /* This function is being processed in whole-function mode.  */\n+  cfun->x_whole_function_mode_p = 1;\n+\n+  /* Even though we're inside a function body, we still don't want to\n+     call expand_expr to calculate the size of a variable-sized array.\n+     We haven't necessarily assigned RTL to all variables yet, so it's\n+     not safe to try to expand expressions involving them.  */\n+  immediate_size_expand = 0;\n+  cfun->x_dont_save_pending_sizes_p = 1;\n+\n+  /* Set up parameters and prepare for return, for the function.  */\n+  expand_function_start (fndecl, 0);\n+\n+  /* If this function is `main', emit a call to `__main'\n+     to run global initializers, etc.  */\n+  if (DECL_NAME (fndecl)\n+      && MAIN_NAME_P (DECL_NAME (fndecl))\n+      && DECL_CONTEXT (fndecl) == NULL_TREE)\n+    expand_main_function ();\n+\n+  /* If this is a varargs function, inform function.c.  */\n+  if (c_function_varargs)\n+    mark_varargs ();\n+\n+  /* Generate the RTL for this function.  */\n+  expand_stmt (DECL_SAVED_TREE (fndecl));\n+  /* Allow the body of the function to be garbage collected.  */\n+  DECL_SAVED_TREE (fndecl) = NULL_TREE;\n+\n+  /* We hard-wired immediate_size_expand to zero in start_function.\n+     expand_function_end will decrement this variable.  So, we set the\n+     variable to one here, so that after the decrement it will remain\n+     zero.  */\n+  immediate_size_expand = 1;\n+\n+  /* Allow language dialects to perform special processing.  */\n+  if (lang_expand_function_end)\n+    (*lang_expand_function_end) ();\n+\n   /* Generate rtl for function exit.  */\n   expand_function_end (input_filename, lineno, 0);\n \n@@ -6658,14 +6739,14 @@ finish_function (nested)\n \n   /* If this is a nested function, protect the local variables in the stack\n      above us from being collected while we're compiling this function.  */\n-  if (nested)\n+  if (nested_p)\n     ggc_push_context ();\n \n   /* Run the optimizers and output the assembler code for this function.  */\n   rest_of_compilation (fndecl);\n \n   /* Undo the GC context switch.  */\n-  if (nested)\n+  if (nested_p)\n     ggc_pop_context ();\n \n   current_function_returns_null |= can_reach_end;\n@@ -6715,7 +6796,7 @@ finish_function (nested)\n \t}\n     }\n \n-  if (DECL_SAVED_INSNS (fndecl) == 0 && ! nested)\n+  if (DECL_SAVED_INSNS (fndecl) == 0 && ! nested_p)\n     {\n       /* Stop pointing to the local nodes about to be freed.\n \t But DECL_INITIAL must remain nonzero so we know this\n@@ -6748,13 +6829,20 @@ finish_function (nested)\n \tassemble_destructor (IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (fndecl)));\n     }\n \n-  if (! nested)\n+  if (nested_p)\n     {\n-      /* Let the error reporting routines know that we're outside a\n-\t function.  For a nested function, this value is used in\n-\t pop_c_function_context and then reset via pop_function_context.  */\n-      current_function_decl = NULL;\n+      /* Return to the enclosing function.  */\n+      pop_function_context ();\n+      /* If the nested function was inline, write it out if that is\n+\t necessary.  */\n+      if (!TREE_ASM_WRITTEN (fndecl) && TREE_ADDRESSABLE (fndecl))\n+\t{\n+\t  push_function_context ();\n+\t  output_inline_function (fndecl);\n+\t  pop_function_context ();\n+\t}\n     }\n+      \n }\n \f\n /* Save and restore the variables in this file and elsewhere\n@@ -6785,6 +6873,9 @@ push_c_function_context (f)\n        xmalloc (sizeof (struct c_language_function)));\n   f->language = (struct language_function *) p;\n \n+  p->base.x_stmt_tree = c_stmt_tree;\n+  p->base.x_scope_stmt_stack = c_scope_stmt_stack;\n+  p->base.x_function_name_declared_p = c_function_name_declared_p;\n   p->named_labels = named_labels;\n   p->shadowed_labels = shadowed_labels;\n   p->returns_value = current_function_returns_value;\n@@ -6810,7 +6901,8 @@ pop_c_function_context (f)\n       IDENTIFIER_LABEL_VALUE (DECL_NAME (TREE_VALUE (link)))\n \t= TREE_VALUE (link);\n \n-  if (DECL_SAVED_INSNS (current_function_decl) == 0)\n+  if (DECL_SAVED_INSNS (current_function_decl) == 0\n+      && DECL_SAVED_TREE (current_function_decl) == NULL_TREE)\n     {\n       /* Stop pointing to the local nodes about to be freed.  */\n       /* But DECL_INITIAL must remain nonzero so we know this\n@@ -6819,6 +6911,9 @@ pop_c_function_context (f)\n       DECL_ARGUMENTS (current_function_decl) = 0;\n     }\n \n+  c_stmt_tree = p->base.x_stmt_tree;\n+  c_scope_stmt_stack = p->base.x_scope_stmt_stack;\n+  c_function_name_declared_p = p->base.x_function_name_declared_p;\n   named_labels = p->named_labels;\n   shadowed_labels = p->shadowed_labels;\n   current_function_returns_value = p->returns_value;\n@@ -6843,18 +6938,27 @@ mark_c_function_context (f)\n   if (p == 0)\n     return;\n \n+  mark_c_language_function (&p->base);\n   ggc_mark_tree (p->shadowed_labels);\n   ggc_mark_tree (p->named_labels);\n   mark_binding_level (&p->binding_level);\n }\n \n-/* integrate_decl_tree calls this function, but since we don't use the\n-   DECL_LANG_SPECIFIC field, this is a no-op.  */\n+/* Copy the DECL_LANG_SEPECIFIC data associated with NODE.  */\n \n void\n-copy_lang_decl (node)\n-     tree node ATTRIBUTE_UNUSED;\n+copy_lang_decl (decl)\n+     tree decl;\n {\n+  struct lang_decl *ld;\n+\n+  if (!DECL_LANG_SPECIFIC (decl))\n+    return;\n+\n+  ld = (struct lang_decl *) ggc_alloc (sizeof (struct lang_decl));\n+  bcopy ((char *)DECL_LANG_SPECIFIC (decl), (char *)ld, \n+\t sizeof (struct lang_decl));\n+  DECL_LANG_SPECIFIC (decl) = ld;\n }\n \n /* Mark ARG for GC.  */\n@@ -6886,6 +6990,11 @@ lang_mark_tree (t)\n     }\n   else if (TYPE_P (t) && TYPE_LANG_SPECIFIC (t))\n     ggc_mark (TYPE_LANG_SPECIFIC (t));\n+  else if (DECL_P (t) && DECL_LANG_SPECIFIC (t))\n+    {\n+      ggc_mark (DECL_LANG_SPECIFIC (t));\n+      c_mark_lang_decl (&DECL_LANG_SPECIFIC (t)->base);\n+    }\n }\n \n /* The functions below are required for functionality of doing\n@@ -6910,7 +7019,15 @@ stmts_are_full_exprs_p ()\n stmt_tree\n current_stmt_tree ()\n {\n-  return cfun ? &cfun->language->x_stmt_tree : NULL;\n+  return &c_stmt_tree;\n+}\n+\n+/* Returns the stack of SCOPE_STMTs for the current function.  */\n+\n+tree *\n+current_scope_stmt_stack ()\n+{\n+  return &c_scope_stmt_stack;\n }\n \n /* Nonzero if TYPE is an anonymous union or struct type.  Always 0 in\n@@ -6923,94 +7040,46 @@ anon_aggr_type_p (node)\n   return 0;\n }\n \n-/* One if we have already declared __FUNCTION__ (and related\n-   variables) in the current function.  Two if we are in the process\n-   of doing so.  */\n+/* Dummy function in place of callback used by C++.  */\n \n-int\n-current_function_name_declared ()\n+void\n+extract_interface_info ()\n {\n-  abort ();\n-  return 0;\n }\n \n-/* Code to generate the RTL for a case label in C.  */\n+/* Return a new COMPOUND_STMT, after adding it to the current\n+   statement tree.  */\n \n-void\n-do_case (low_value, high_value)\n-     tree low_value;\n-     tree high_value;\n+tree\n+c_begin_compound_stmt ()\n {\n-  tree value1 = NULL_TREE, value2 = NULL_TREE, label;\n-\n-  if (low_value != NULL_TREE)\n-    value1 = check_case_value (low_value);\n-  if (high_value != NULL_TREE)\n-    value2 = check_case_value (high_value);\n-\n-  label = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n+  tree stmt;\n \n-  if (pedantic && (high_value != NULL_TREE))\n-    pedwarn (\"ISO C forbids case ranges\");\n-\n-  if (value1 != error_mark_node && value2 != error_mark_node)\n+  /* Create the COMPOUND_STMT.  */\n+  stmt = add_stmt (build_stmt (COMPOUND_STMT, NULL_TREE));\n+  /* If we haven't already declared __FUNCTION__ and its ilk then this\n+     is the opening curly brace of the function.  Declare them now.  */\n+  if (!c_function_name_declared_p) \n     {\n-      tree duplicate;\n-      int success;\n-\n-      if (high_value == NULL_TREE && value1 != NULL_TREE &&\n-\t  pedantic && ! INTEGRAL_TYPE_P (TREE_TYPE (value1)))\n-\tpedwarn (\"label must have integral type in ISO C\");\n-\n-      if (low_value == NULL_TREE)\n-\tsuccess = pushcase (NULL_TREE, 0, label, &duplicate);\n-      else if (high_value == NULL_TREE)\n-\tsuccess = pushcase (value1, convert_and_check, label, &duplicate);\n-      else\n-\tsuccess = pushcase_range (value1, value2, convert_and_check,\n-\t\t\t\t  label, &duplicate);\n-\n-      if (success == 1)\n-\t{\n-\t  if (low_value == NULL_TREE)\n-\t    error (\"default label not within a switch statement\");\n-\t  else\n-\t    error (\"case label not within a switch statement\");\n-\t}\n-      else if (success == 2)\n-\t{\n-\t  if (low_value == NULL_TREE)\n-\t    {\n-\t      error (\"multiple default labels in one switch\");\n-\t      error_with_decl (duplicate, \"this is the first default label\");\n-\t    }\n-\t  else\n-\t    error (\"duplicate case value\");\n-\t  if (high_value != NULL_TREE)\n-\t    error_with_decl (duplicate,\n-\t\t\t     \"this is the first entry for that value\");\n-\t}\n-      else if (low_value != NULL_TREE)\n-\t{\n-\t  if (success == 3)\n-\t    warning (\"case value out of range\");\n-\t  else if (success == 5)\n-\t    error (\"case label within scope of cleanup or variable array\");\n-\t}\n+      c_function_name_declared_p = 1;\n+      declare_function_name ();\n     }\n+  \n+  return stmt;\n }\n \n-/* Accessor to set the 'current_function_name_declared' flag.  */\n+/* Expand T (a DECL_STMT) if it declares an entity not handled by the\n+   common code.  */\n \n void\n-set_current_function_name_declared (i)\n-     int i ATTRIBUTE_UNUSED;\n-{\n-  abort ();\n-}\n-\n-/* Dummy function in place of callback used by C++.  */\n-void\n-extract_interface_info ()\n+c_expand_decl_stmt (t)\n+     tree t;\n {\n+  tree decl = DECL_STMT_DECL (t);\n+  \n+  /* Expand nested functions.  */\n+  if (TREE_CODE (decl) == FUNCTION_DECL\n+      && DECL_CONTEXT (decl) == current_function_decl\n+      && DECL_SAVED_TREE (decl))\n+    c_expand_body (decl, /*nested_p=*/1);\n }"}, {"sha": "21b8f0f273b6b501e45943fbe1c29874a7af02fb", "filename": "gcc/c-lang.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Fc-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Fc-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lang.c?ref=8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8", "patch": "@@ -25,13 +25,15 @@ Boston, MA 02111-1307, USA.  */\n #include \"tree.h\"\n #include \"function.h\"\n #include \"input.h\"\n-#include \"c-tree.h\"\n-#include \"c-lex.h\"\n #include \"toplev.h\"\n #include \"diagnostic.h\"\n #include \"output.h\"\n #include \"flags.h\"\n #include \"ggc.h\"\n+#include \"rtl.h\"\n+#include \"expr.h\"\n+#include \"c-tree.h\"\n+#include \"c-lex.h\"\n \n static int c_tree_printer PARAMS ((output_buffer *));\n \n@@ -88,8 +90,10 @@ lang_init ()\n   save_lang_status = &push_c_function_context;\n   restore_lang_status = &pop_c_function_context;\n   mark_lang_status = &mark_c_function_context;\n-\n-  lang_printer = c_tree_printer;\n+  lang_expand_expr = &c_expand_expr;\n+  lang_safe_from_p = &c_safe_from_p;\n+  lang_printer = &c_tree_printer;\n+  lang_expand_decl_stmt = &c_expand_decl_stmt;\n \n   c_parse_init ();\n }"}, {"sha": "f853fd067e9be84b7f3b24edf9679e394a2c40f0", "filename": "gcc/c-lex.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8", "patch": "@@ -23,6 +23,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"system.h\"\n \n #include \"rtl.h\"\n+#include \"expr.h\"\n #include \"tree.h\"\n #include \"input.h\"\n #include \"output.h\""}, {"sha": "c590f31ae32f63eeab1bef43af4199e95a7c794a", "filename": "gcc/c-parse.in", "status": "modified", "additions": 97, "deletions": 138, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8", "patch": "@@ -173,7 +173,8 @@ end ifc\n %type <ttype> maybe_attribute attributes attribute attribute_list attrib\n %type <ttype> any_word extension\n \n-%type <ttype> compstmt compstmt_nostart compstmt_primary_start\n+%type <ttype> compstmt compstmt_start compstmt_nostart compstmt_primary_start\n+%type <ttype> do_stmt_start poplevel\n \n %type <ttype> declarator\n %type <ttype> notype_declarator after_type_declarator\n@@ -661,33 +662,26 @@ primary:\n \t| '(' error ')'\n \t\t{ $$ = error_mark_node; }\n \t| compstmt_primary_start compstmt_nostart ')'\n-\t\t{ tree rtl_exp;\n-\t\t  if (pedantic)\n-\t\t    pedwarn (\"ISO C forbids braced-groups within expressions\");\n+                 { tree saved_last_tree;\n+\n+\t\t   if (pedantic)\n+\t\t     pedwarn (\"ISO C forbids braced-groups within expressions\");\n \t\t  pop_label_level ();\n-\t\t  rtl_exp = expand_end_stmt_expr ($1);\n-\t\t  /* The statements have side effects, so the group does.  */\n-\t\t  TREE_SIDE_EFFECTS (rtl_exp) = 1;\n \n-\t\t  if (TREE_CODE ($2) == BLOCK)\n-\t\t    {\n-\t\t      /* Make a BIND_EXPR for the BLOCK already made.  */\n-\t\t      $$ = build (BIND_EXPR, TREE_TYPE (rtl_exp),\n-\t\t\t\t  NULL_TREE, rtl_exp, $2);\n-\t\t      /* Remove the block from the tree at this point.\n-\t\t\t It gets put back at the proper place\n-\t\t\t when the BIND_EXPR is expanded.  */\n-\t\t      delete_block ($2);\n-\t\t    }\n-\t\t  else\n-\t\t    $$ = $2;\n+\t\t  saved_last_tree = COMPOUND_BODY ($1);\n+\t\t  RECHAIN_STMTS ($1, COMPOUND_BODY ($1));\n+\t\t  last_tree = saved_last_tree;\n+\t\t  TREE_CHAIN (last_tree) = NULL_TREE;\n+\t\t  if (!last_expr_type)\n+\t\t    last_expr_type = void_type_node;\n+\t\t  $$ = build1 (STMT_EXPR, last_expr_type, $1);\n+\t\t  TREE_SIDE_EFFECTS ($$) = 1;\n \t\t}\n \t| compstmt_primary_start error ')'\n \t\t{\n-\t\t  /* Make sure we call expand_end_stmt_expr.  Otherwise\n-\t\t     we are likely to lose sequences and crash later.  */\n \t\t  pop_label_level ();\n-\t\t  expand_end_stmt_expr ($1);\n+\t\t  last_tree = COMPOUND_BODY ($1);\n+\t\t  TREE_CHAIN (last_tree) = NULL_TREE;\n \t\t  $$ = error_mark_node;\n \t\t}\n \t| primary '(' exprlist ')'   %prec '.'\n@@ -1196,8 +1190,10 @@ nested_function:\n    There followed a repeated execution of that same rule,\n    which called YYERROR1 again, and so on.  */\n \t  compstmt\n-\t\t{ finish_function (1);\n-\t\t  pop_function_context (); }\n+\t\t{ tree decl = current_function_decl;\n+\t\t  finish_function (1);\n+\t\t  pop_function_context (); \n+\t\t  add_decl_stmt (decl); }\n \t;\n \n notype_nested_function:\n@@ -1222,8 +1218,10 @@ notype_nested_function:\n    There followed a repeated execution of that same rule,\n    which called YYERROR1 again, and so on.  */\n \t  compstmt\n-\t\t{ finish_function (1);\n-\t\t  pop_function_context (); }\n+\t\t{ tree decl = current_function_decl;\n+\t\t  finish_function (1);\n+\t\t  pop_function_context (); \n+\t\t  add_decl_stmt (decl); }\n \t;\n \n /* Any kind of declarator (thus, all declarators allowed\n@@ -1604,17 +1602,19 @@ errstmt:  error ';'\n \t;\n \n pushlevel:  /* empty */\n-\t\t{ emit_line_note (input_filename, lineno);\n-\t\t  pushlevel (0);\n+\t\t{ pushlevel (0);\n \t\t  clear_last_expr ();\n-\t\t  expand_start_bindings (0);\n+\t\t  add_scope_stmt (/*begin_p=*/1, /*partial_p=*/0);\n ifobjc\n \t\t  if (objc_method_context)\n \t\t    add_objc_decls ();\n end ifobjc\n \t\t}\n \t;\n \n+poplevel:  /* empty */\n+                { $$ = add_scope_stmt (/*begin_p=*/0, /*partial_p=*/0); }\n+\n /* Read zero or more forward-declarations for labels\n    that nested functions can jump to.  */\n maybe_label_decls:\n@@ -1636,7 +1636,7 @@ label_decl:\n \t\t    {\n \t\t      tree label = shadow_label (TREE_VALUE (link));\n \t\t      C_DECLARED_LABEL_FLAG (label) = 1;\n-\t\t      declare_nonlocal_label (label);\n+\t\t      add_decl_stmt (label);\n \t\t    }\n \t\t}\n \t;\n@@ -1649,22 +1649,26 @@ compstmt_or_error:\n \t| error compstmt\n \t;\n \n-compstmt_start: '{' { compstmt_count++; }\n+compstmt_start: '{' { compstmt_count++;\n+                      $$ = c_begin_compound_stmt (); } \n \n compstmt_nostart: '}'\n \t\t{ $$ = convert (void_type_node, integer_zero_node); }\n-\t| pushlevel maybe_label_decls decls xstmts '}'\n-\t\t{ emit_line_note (input_filename, lineno);\n-\t\t  expand_end_bindings (getdecls (), 1, 0);\n-\t\t  $$ = poplevel (1, 1, 0); }\n-\t| pushlevel maybe_label_decls error '}'\n-\t\t{ emit_line_note (input_filename, lineno);\n-\t\t  expand_end_bindings (getdecls (), kept_level_p (), 0);\n-\t\t  $$ = poplevel (kept_level_p (), 0, 0); }\n-\t| pushlevel maybe_label_decls stmts '}'\n-\t\t{ emit_line_note (input_filename, lineno);\n-\t\t  expand_end_bindings (getdecls (), kept_level_p (), 0);\n-\t\t  $$ = poplevel (kept_level_p (), 0, 0); }\n+\t| pushlevel maybe_label_decls decls xstmts '}' poplevel\n+\t\t{ $$ = poplevel (1, 1, 0); \n+\t\t  SCOPE_STMT_BLOCK (TREE_PURPOSE ($6)) \n+\t\t    = SCOPE_STMT_BLOCK (TREE_VALUE ($6))\n+\t\t    = $$; }\n+\t| pushlevel maybe_label_decls error '}' poplevel\n+\t\t{ $$ = poplevel (kept_level_p (), 0, 0); \n+\t\t  SCOPE_STMT_BLOCK (TREE_PURPOSE ($5)) \n+\t\t    = SCOPE_STMT_BLOCK (TREE_VALUE ($5))\n+\t\t    = $$; }\n+\t| pushlevel maybe_label_decls stmts '}' poplevel\n+\t\t{ $$ = poplevel (kept_level_p (), 0, 0); \n+\t\t  SCOPE_STMT_BLOCK (TREE_PURPOSE ($5)) \n+\t\t    = SCOPE_STMT_BLOCK (TREE_VALUE ($5))\n+\t\t    = $$; }\n \t;\n \n compstmt_primary_start:\n@@ -1680,17 +1684,19 @@ compstmt_primary_start:\n \t\t     that are contained in it.  */\n \t\t  keep_next_level ();\n \t\t  push_label_level ();\n-\t\t  $$ = expand_start_stmt_expr ();\n \t\t  compstmt_count++;\n+\t\t  $$ = add_stmt (build_stmt (COMPOUND_STMT, last_tree));\n \t\t}\n \n compstmt: compstmt_start compstmt_nostart\n-\t\t{ $$ = $2; }\n+\t\t{ RECHAIN_STMTS ($1, COMPOUND_BODY ($1)); \n+                  $$ = $2; }\n \t;\n \n /* Value is number of statements counted as of the closeparen.  */\n simple_if:\n \t  if_prefix lineno_labeled_stmt\n+                { c_finish_then (); }\n /* Make sure c_expand_end_cond is run once\n    for each call to c_expand_start_cond.\n    Otherwise a crash is likely.  */\n@@ -1699,8 +1705,7 @@ simple_if:\n \n if_prefix:\n \t  IF '(' expr ')'\n-\t\t{ emit_line_note ($<filename>-1, $<lineno>0);\n-\t\t  c_expand_start_cond (truthvalue_conversion ($3), 0, \n+\t\t{ c_expand_start_cond (truthvalue_conversion ($3), \n \t\t\t\t       compstmt_count);\n \t\t  $<itype>$ = stmt_count;\n \t\t  if_stmt_file = $<filename>-1;\n@@ -1714,12 +1719,17 @@ do_stmt_start:\n \t  DO\n \t\t{ stmt_count++;\n \t\t  compstmt_count++;\n-\t\t  emit_line_note ($<filename>-1, $<lineno>0);\n-\t\t  /* See comment in `while' alternative, above.  */\n-\t\t  emit_nop ();\n-\t\t  expand_start_loop_continue_elsewhere (1); }\n+\t\t  $<ttype>$ \n+\t\t    = add_stmt (build_stmt (DO_STMT, NULL_TREE,\n+\t\t\t\t\t    NULL_TREE));\n+\t\t  /* In the event that a parse error prevents\n+\t\t     parsing the complete do-statement, set the\n+\t\t     condition now.  Otherwise, we can get crashes at\n+\t\t     RTL-generation time.  */\n+\t\t  DO_COND ($<ttype>$) = error_mark_node; }\n \t  lineno_labeled_stmt WHILE\n-\t\t{ expand_loop_continue_here (); }\n+\t\t{ $$ = $<ttype>2;\n+\t\t  RECHAIN_STMTS ($$, DO_BODY ($$)); }\n \t;\n \n /* The forced readahead in here is because we might be at the end of a\n@@ -1765,25 +1775,13 @@ stmt:\n \t\t{ stmt_count++; }\n \t| expr ';'\n \t\t{ stmt_count++;\n-\t\t  emit_line_note ($<filename>-1, $<lineno>0);\n-/* It appears that this should not be done--that a non-lvalue array\n-   shouldn't get an error if the value isn't used.\n-   Section 3.2.2.1 says that an array lvalue gets converted to a pointer\n-   if it appears as a top-level expression,\n-   but says nothing about non-lvalue arrays.  */\n-#if 0\n-\t\t  /* Call default_conversion to get an error\n-\t\t     on referring to a register array if pedantic.  */\n-\t\t  if (TREE_CODE (TREE_TYPE ($1)) == ARRAY_TYPE\n-\t\t      || TREE_CODE (TREE_TYPE ($1)) == FUNCTION_TYPE)\n-\t\t    $1 = default_conversion ($1);\n-#endif\n-\t\t  expand_expr_stmt ($1); }\n+\t\t  c_expand_expr_stmt ($1); }\n \t| simple_if ELSE\n \t\t{ c_expand_start_else ();\n \t\t  $<itype>1 = stmt_count; }\n \t  lineno_labeled_stmt\n-\t\t{ c_expand_end_cond ();\n+                { c_finish_else ();\n+\t\t  c_expand_end_cond ();\n \t\t  if (extra_warnings && stmt_count == $<itype>1)\n \t\t    warning (\"empty body in an else-statement\"); }\n \t| simple_if %prec IF\n@@ -1801,83 +1799,43 @@ stmt:\n \t| simple_if ELSE error\n \t\t{ c_expand_end_cond (); }\n \t| WHILE\n-\t\t{ stmt_count++;\n-\t\t  emit_line_note ($<filename>-1, $<lineno>0);\n-\t\t  /* The emit_nop used to come before emit_line_note,\n-\t\t     but that made the nop seem like part of the preceding line.\n-\t\t     And that was confusing when the preceding line was\n-\t\t     inside of an if statement and was not really executed.\n-\t\t     I think it ought to work to put the nop after the line number.\n-\t\t     We will see.  --rms, July 15, 1991.  */\n-\t\t  emit_nop (); }\n+                { stmt_count++; }\n \t  '(' expr ')'\n-\t\t{ /* Don't start the loop till we have succeeded\n-\t\t     in parsing the end test.  This is to make sure\n-\t\t     that we end every loop we start.  */\n-\t\t  expand_start_loop (1);\n-\t\t  emit_line_note (input_filename, lineno);\n-\t\t  expand_exit_loop_if_false (NULL_PTR,\n-\t\t\t\t\t     truthvalue_conversion ($4)); }\n+                { $4 = truthvalue_conversion ($4);\n+\t\t  $<ttype>$ \n+\t\t    = add_stmt (build_stmt (WHILE_STMT, $4, NULL_TREE)); }\n \t  lineno_labeled_stmt\n-\t\t{ expand_end_loop (); }\n+\t\t{ RECHAIN_STMTS ($<ttype>6, WHILE_BODY ($<ttype>6)); }\n \t| do_stmt_start\n \t  '(' expr ')' ';'\n-\t\t{ emit_line_note (input_filename, lineno);\n-\t\t  expand_exit_loop_if_false (NULL_PTR,\n-\t\t\t\t\t     truthvalue_conversion ($3));\n-\t\t  expand_end_loop (); }\n-/* This rule is needed to make sure we end every loop we start.  */\n+                { DO_COND ($1) = truthvalue_conversion ($3); }\n \t| do_stmt_start error\n-\t\t{ expand_end_loop (); }\n+ \t\t{ }\n \t| FOR\n \t  '(' xexpr ';'\n \t\t{ stmt_count++;\n-\t\t  emit_line_note ($<filename>-1, $<lineno>0);\n-\t\t  /* See comment in `while' alternative, above.  */\n-\t\t  emit_nop ();\n-\t\t  if ($3) c_expand_expr_stmt ($3);\n-\t\t  /* Next step is to call expand_start_loop_continue_elsewhere,\n-\t\t     but wait till after we parse the entire for (...).\n-\t\t     Otherwise, invalid input might cause us to call that\n-\t\t     fn without calling expand_end_loop.  */\n+\t\t  $3 = build_stmt (EXPR_STMT, $3); \n+\t\t  $<ttype>$ = build_stmt (FOR_STMT, $3, NULL_TREE,\n+\t\t\t\t\t  NULL_TREE, NULL_TREE);\n+\t\t  add_stmt ($<ttype>$);\n \t\t}\n \t  xexpr ';'\n-\t\t/* Can't emit now; wait till after expand_start_loop...  */\n-\t\t{ $<lineno>7 = lineno;\n-\t\t  $<filename>$ = input_filename; }\n+                { FOR_COND ($<ttype>5) = $6; }\n \t  xexpr ')'\n-\t\t{ \n-\t\t  /* Start the loop.  Doing this after parsing\n-\t\t     all the expressions ensures we will end the loop.  */\n-\t\t  expand_start_loop_continue_elsewhere (1);\n-\t\t  /* Emit the end-test, with a line number.  */\n-\t\t  emit_line_note ($<filename>8, $<lineno>7);\n-\t\t  if ($6)\n-\t\t    expand_exit_loop_if_false (NULL_PTR,\n-\t\t\t\t\t       truthvalue_conversion ($6));\n-\t\t  $<lineno>7 = lineno;\n-\t\t  $<filename>8 = input_filename; }\n+\t\t{ FOR_EXPR ($<ttype>5) = $9; }\n \t  lineno_labeled_stmt\n-\t\t{ /* Emit the increment expression, with a line number.  */\n-\t\t  emit_line_note ($<filename>8, $<lineno>7);\n-\t\t  expand_loop_continue_here ();\n-\t\t  if ($9)\n-\t\t    c_expand_expr_stmt ($9);\n-\t\t  expand_end_loop (); }\n+                { RECHAIN_STMTS ($<ttype>5, FOR_BODY ($<ttype>5)); }\n \t| SWITCH '(' expr ')'\n \t\t{ stmt_count++;\n-\t\t  emit_line_note ($<filename>-1, $<lineno>0);\n-\t\t  c_expand_start_case ($3); }\n+\t\t  $<ttype>$ = c_start_case ($3); }\n \t  lineno_labeled_stmt\n-\t\t{ expand_end_case ($3); }\n+                { c_finish_case (); }\n \t| BREAK ';'\n-\t        { build_break_stmt ();\n-\t\t  stmt_count++;\n-\t\t  genrtl_break_stmt (); }\n+\t        { stmt_count++;\n+\t\t  add_stmt (build_break_stmt ()); }\n \t| CONTINUE ';'\n-                { build_continue_stmt ();\n-                  stmt_count++;\n-\t\t  genrtl_continue_stmt (); }\n+                { stmt_count++;\n+\t\t  add_stmt (build_continue_stmt ()); }\n \t| RETURN ';'\n                 { stmt_count++;\n \t\t  c_expand_return (NULL_TREE); }\n@@ -1886,53 +1844,55 @@ stmt:\n \t\t  c_expand_return ($2); }\n \t| ASM_KEYWORD maybe_type_qual '(' expr ')' ';'\n \t\t{ stmt_count++;\n-\t\t  emit_line_note ($<filename>-1, $<lineno>0);\n \t\t  STRIP_NOPS ($4);\n \t\t  if ((TREE_CODE ($4) == ADDR_EXPR\n \t\t       && TREE_CODE (TREE_OPERAND ($4, 0)) == STRING_CST)\n \t\t      || TREE_CODE ($4) == STRING_CST)\n-\t\t    expand_asm ($4);\n+\t\t    {\n+\t\t      if (TREE_CODE ($4) == ADDR_EXPR)\n+\t\t\t$4 = TREE_OPERAND ($4, 0);\n+\t\t      if (TREE_CHAIN ($4))\n+\t\t\t$4 = combine_strings ($4);\n+\t\t      add_stmt (build_stmt (ASM_STMT, NULL_TREE, $4,\n+\t\t\t\t\t    NULL_TREE, NULL_TREE, NULL_TREE));\n+\t\t    }\n \t\t  else\n \t\t    error (\"argument of `asm' is not a constant string\"); }\n \t/* This is the case with just output operands.  */\n \t| ASM_KEYWORD maybe_type_qual '(' expr ':' asm_operands ')' ';'\n \t\t{ stmt_count++;\n-\t\t  emit_line_note ($<filename>-1, $<lineno>0);\n \t\t  c_expand_asm_operands ($4, $6, NULL_TREE, NULL_TREE,\n \t\t\t\t\t $2 == ridpointers[(int)RID_VOLATILE],\n \t\t\t\t\t input_filename, lineno); }\n \t/* This is the case with input operands as well.  */\n \t| ASM_KEYWORD maybe_type_qual '(' expr ':' asm_operands ':' asm_operands ')' ';'\n \t\t{ stmt_count++;\n-\t\t  emit_line_note ($<filename>-1, $<lineno>0);\n \t\t  c_expand_asm_operands ($4, $6, $8, NULL_TREE,\n \t\t\t\t\t $2 == ridpointers[(int)RID_VOLATILE],\n \t\t\t\t\t input_filename, lineno); }\n \t/* This is the case with clobbered registers as well.  */\n \t| ASM_KEYWORD maybe_type_qual '(' expr ':' asm_operands ':'\n   \t  asm_operands ':' asm_clobbers ')' ';'\n \t\t{ stmt_count++;\n-\t\t  emit_line_note ($<filename>-1, $<lineno>0);\n \t\t  c_expand_asm_operands ($4, $6, $8, $10,\n \t\t\t\t\t $2 == ridpointers[(int)RID_VOLATILE],\n \t\t\t\t\t input_filename, lineno); }\n \t| GOTO identifier ';'\n \t\t{ tree decl;\n \t\t  stmt_count++;\n-\t\t  emit_line_note ($<filename>-1, $<lineno>0);\n \t\t  decl = lookup_label ($2);\n \t\t  if (decl != 0)\n \t\t    {\n \t\t      TREE_USED (decl) = 1;\n-\t\t      expand_goto (decl);\n+\t\t      add_stmt (build_stmt (GOTO_STMT, decl));\n \t\t    }\n \t\t}\n \t| GOTO '*' expr ';'\n \t\t{ if (pedantic)\n \t\t    pedwarn (\"ISO C forbids `goto *expr;'\");\n \t\t  stmt_count++;\n-\t\t  emit_line_note ($<filename>-1, $<lineno>0);\n-\t\t  expand_computed_goto (convert (ptr_type_node, $3)); }\n+\t\t  $3 = convert (ptr_type_node, $3);\n+\t\t  add_stmt (build_stmt (GOTO_STMT, $3)); }\n \t| ';'\n \t;\n \n@@ -1952,11 +1912,10 @@ label:\t  CASE expr_no_commas ':'\n \t| identifier save_filename save_lineno ':' maybe_attribute\n \t\t{ tree label = define_label ($2, $3, $1);\n \t\t  stmt_count++;\n-\t\t  emit_nop ();\n \t\t  if (label)\n \t\t    {\n-\t\t      expand_label (label);\n \t\t      decl_attributes (label, $5, NULL_TREE);\n+\t\t      add_stmt (build_stmt (LABEL_STMT, label));\n \t\t    }\n \t\t}\n \t;"}, {"sha": "b349bd383e91c146057ec054bbceb4d2f05ae88a", "filename": "gcc/c-semantics.c", "status": "modified", "additions": 110, "deletions": 20, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Fc-semantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Fc-semantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-semantics.c?ref=8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8", "patch": "@@ -40,6 +40,13 @@ Boston, MA 02111-1307, USA.  */\n    expanding statements.  */\n void (*lang_expand_stmt) PARAMS ((tree));\n \n+/* If non-NULL, the address of a language-specific function for\n+   expanding a DECL_STMT.  After the language-independent cases are\n+   handled, this function will be called.  If this function is not\n+   defined, it is assumed that declarations other than those for\n+   variables and labels do not require any RTL generation.  */\n+void (*lang_expand_decl_stmt) PARAMS ((tree));\n+\n static tree prune_unused_decls PARAMS ((tree *, int *, void *));\n \n /* Create an empty statement tree rooted at T.  */\n@@ -71,6 +78,63 @@ add_stmt (t)\n   return t;\n }\n \n+/* Create a declaration statement for the declaration given by the\n+   DECL.  */\n+\n+void\n+add_decl_stmt (decl)\n+     tree decl;\n+{\n+  tree decl_stmt;\n+\n+  /* We need the type to last until instantiation time.  */\n+  decl_stmt = build_stmt (DECL_STMT, decl);\n+  add_stmt (decl_stmt); \n+}\n+\n+/* Add a scope-statement to the statement-tree.  BEGIN_P indicates\n+   whether this statements opens or closes a scope.  PARTIAL_P is true\n+   for a partial scope, i.e, the scope that begins after a label when\n+   an object that needs a cleanup is created.  If BEGIN_P is nonzero,\n+   returns a new TREE_LIST representing the top of the SCOPE_STMT\n+   stack.  The TREE_PURPOSE is the new SCOPE_STMT.  If BEGIN_P is\n+   zero, returns a TREE_LIST whose TREE_VALUE is the new SCOPE_STMT,\n+   and whose TREE_PURPOSE is the matching SCOPE_STMT iwth\n+   SCOPE_BEGIN_P set.  */\n+\n+tree\n+add_scope_stmt (begin_p, partial_p)\n+     int begin_p;\n+     int partial_p;\n+{\n+  tree ss;\n+  tree top;\n+\n+  /* Build the statement.  */\n+  ss = build_stmt (SCOPE_STMT, NULL_TREE);\n+  SCOPE_BEGIN_P (ss) = begin_p;\n+  SCOPE_PARTIAL_P (ss) = partial_p;\n+\n+  /* Keep the scope stack up to date.  */\n+  if (begin_p)\n+    {\n+      *current_scope_stmt_stack () \n+\t= tree_cons (ss, NULL_TREE, *current_scope_stmt_stack ());\n+      top = *current_scope_stmt_stack ();\n+    }\n+  else\n+    {\n+      top = *current_scope_stmt_stack ();\n+      TREE_VALUE (top) = ss;\n+      *current_scope_stmt_stack () = TREE_CHAIN (top);\n+    }\n+\n+  /* Add the new statement to the statement-tree.  */\n+  add_stmt (ss);\n+\n+  return top;\n+}\n+\n /* Remove declarations of internal variables that are not used from a\n    stmt tree.  To qualify, the variable must have a name and must have\n    a zero DECL_SOURCE_LINE.  We tried to remove all variables for\n@@ -145,7 +209,7 @@ finish_stmt_tree (t)\n   /* Remove unused decls from the stmt tree.  */\n   walk_stmt_tree (t, prune_unused_decls, NULL);\n \n-  if (cfun)\n+  if (cfun && stmt)\n     {\n       /* The line-number recorded in the outermost statement in a function\n \t is the line number of the end of the function.  */\n@@ -305,7 +369,8 @@ genrtl_expr_stmt (expr)\n       if (stmts_are_full_exprs_p ())\n \texpand_start_target_temps ();\n       \n-      lang_expand_expr_stmt (expr);\n+      if (expr != error_mark_node)\n+\texpand_expr_stmt (expr);\n       \n       if (stmts_are_full_exprs_p ())\n \texpand_end_target_temps ();\n@@ -348,6 +413,11 @@ genrtl_decl_stmt (t)\n       else\n \tmake_rtl_for_local_static (decl);\n     }\n+  else if (TREE_CODE (decl) == LABEL_DECL \n+\t   && C_DECLARED_LABEL_FLAG (decl))\n+    declare_nonlocal_label (decl);\n+  else if (lang_expand_decl_stmt)\n+    (*lang_expand_decl_stmt) (t);\n }\n \n /* Generate the RTL for T, which is an IF_STMT. */\n@@ -448,30 +518,43 @@ void\n genrtl_for_stmt (t)\n      tree t;\n {\n-  tree tmp;\n   tree cond;\n+  const char *saved_filename;\n+  int saved_lineno;\n+\n   if (NEW_FOR_SCOPE_P (t))\n     genrtl_do_pushlevel ();\n \n   expand_stmt (FOR_INIT_STMT (t));\n \n+  /* Expand the initialization.  */\n   emit_nop ();\n   emit_line_note (input_filename, lineno);\n   expand_start_loop_continue_elsewhere (1); \n   genrtl_do_pushlevel ();\n   cond = expand_cond (FOR_COND (t));\n+\n+  /* Save the filename and line number so that we expand the FOR_EXPR\n+     we can reset them back to the saved values.  */\n+  saved_filename = input_filename;\n+  saved_lineno = lineno;\n+\n+  /* Expand the condition.  */\n   emit_line_note (input_filename, lineno);\n   if (cond)\n     expand_exit_loop_if_false (0, cond);\n-  genrtl_do_pushlevel ();\n-  tmp = FOR_EXPR (t);\n \n+  /* Expand the body.  */\n+  genrtl_do_pushlevel ();\n   expand_stmt (FOR_BODY (t));\n \n+  /* Expand the increment expression.  */\n+  input_filename = saved_filename;\n+  lineno = saved_lineno;\n   emit_line_note (input_filename, lineno);\n   expand_loop_continue_here ();\n-  if (tmp) \n-    genrtl_expr_stmt (tmp);\n+  if (FOR_EXPR (t))\n+    genrtl_expr_stmt (FOR_EXPR (t));\n   expand_end_loop ();\n }\n \n@@ -575,6 +658,22 @@ genrtl_case_label (case_label)\n      tree case_label;\n {\n   tree duplicate;\n+  tree cleanup;\n+\n+  cleanup = last_cleanup_this_contour ();\n+  if (cleanup)\n+    {\n+      static int explained = 0;\n+      warning_with_decl (TREE_PURPOSE (cleanup), \n+\t\t\t \"destructor needed for `%#D'\");\n+      warning (\"where case label appears here\");\n+      if (!explained)\n+\t{\n+\t  warning (\"(enclose actions of previous case statements requiring destructors in their own scope.)\");\n+\t  explained = 1;\n+\t}\n+    }\n+\n   add_case_node (CASE_LOW (case_label), CASE_HIGH (case_label), \n \t\t CASE_LABEL_DECL (case_label), &duplicate);\n }\n@@ -585,16 +684,6 @@ void\n genrtl_compound_stmt (t)\n     tree t;\n {\n-  /* If this is the outermost block of the function, declare the\n-     variables __FUNCTION__, __PRETTY_FUNCTION__, and so forth.  */\n-  if (cfun\n-      && !current_function_name_declared () \n-      && !COMPOUND_STMT_NO_SCOPE (t))\n-    {\n-      set_current_function_name_declared (1);\n-      declare_function_name ();\n-    } \n-\n   expand_stmt (COMPOUND_BODY (t));\n }\n \n@@ -609,9 +698,6 @@ genrtl_asm_stmt (cv_qualifier, string, output_operands,\n      tree input_operands;\n      tree clobbers;\n {\n-  if (TREE_CHAIN (string))\n-    string = combine_strings (string);\n-\n   if (cv_qualifier != NULL_TREE\n       && cv_qualifier != ridpointers[(int) RID_VOLATILE])\n     {\n@@ -733,6 +819,10 @@ expand_stmt (t)\n \t\t\t   ASM_OUTPUTS (t), ASM_INPUTS (t), ASM_CLOBBERS (t));\n \t  break;\n \n+\tcase SCOPE_STMT:\n+\t  genrtl_scope_stmt (t);\n+\t  break;\n+\n \tdefault:\n \t  if (lang_expand_stmt)\n \t    (*lang_expand_stmt) (t);"}, {"sha": "5531731010e2ae318c8d0fcaf872c710fd4b1c7c", "filename": "gcc/c-tree.h", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8", "patch": "@@ -42,6 +42,14 @@ struct lang_identifier\n   enum rid rid_code;\n };\n \n+/* Wrapping c_lang_decl in another struct is an unfortunate\n+   necessity.  */\n+\n+struct lang_decl\n+{\n+  struct c_lang_decl base;\n+};\n+\n /* Macros for access to language-specific slots in an identifier.  */\n /* Each of these slots contains a DECL node or null.  */\n \n@@ -103,10 +111,6 @@ struct lang_type\n   tree elts[1];\n };\n \n-/* Mark which labels are explicitly declared.\n-   These may be shadowed, and may be referenced from nested functions.  */\n-#define C_DECLARED_LABEL_FLAG(label) TREE_LANG_FLAG_1 (label)\n-\n /* Record whether a type or decl was written with nonconstant size.\n    Note that TYPE_SIZE may have simplified to a constant.  */\n #define C_TYPE_VARIABLE_SIZE(type) TYPE_LANG_FLAG_1 (type)\n@@ -230,6 +234,8 @@ extern tree start_decl                          PARAMS ((tree, tree, int,\n extern tree start_struct                        PARAMS ((enum tree_code, tree));\n extern void store_parm_decls                    PARAMS ((void));\n extern tree xref_tag                            PARAMS ((enum tree_code, tree));\n+extern tree c_begin_compound_stmt               PARAMS ((void));\n+extern void c_expand_decl_stmt                  PARAMS ((tree));\n \n /* in c-typeck.c */\n extern tree require_complete_type\t\tPARAMS ((tree));\n@@ -268,7 +274,8 @@ extern void set_init_label\t\t\tPARAMS ((tree));\n extern void process_init_element\t\tPARAMS ((tree));\n extern void pedwarn_c99\t\t\t\tPARAMS ((const char *, ...))\n \t\t\t\t\t\t\tATTRIBUTE_PRINTF_1;\n-extern tree c_expand_start_case                 PARAMS ((tree));\n+extern tree c_start_case                        PARAMS ((tree));\n+extern void c_finish_case                       PARAMS ((void));\n \n /* Set to 0 at beginning of a function definition, set to 1 if\n    a return statement that specifies a return value is seen.  */"}, {"sha": "f4b42b991a50793ed1bd4cde343abe373708a835", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 107, "deletions": 35, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8", "patch": "@@ -4999,7 +4999,8 @@ start_init (decl, asmspec_tree, top_level)\n \t       || TREE_CODE (TREE_TYPE (decl)) == UNION_TYPE\n \t       || TREE_CODE (TREE_TYPE (decl)) == QUAL_UNION_TYPE));\n       locus = IDENTIFIER_POINTER (DECL_NAME (decl));\n-      constructor_incremental |= TREE_STATIC (decl);\n+      constructor_incremental \n+\t|= (TREE_STATIC (decl) && !DECL_CONTEXT (decl));\n     }\n   else\n     {\n@@ -6541,7 +6542,7 @@ c_expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n \n   if (TREE_CODE (string) == ADDR_EXPR)\n     string = TREE_OPERAND (string, 0);\n-  if (TREE_CODE (string) != STRING_CST)\n+  if (last_tree && TREE_CODE (string) != STRING_CST)\n     {\n       error (\"asm template is not a string constant\");\n       return;\n@@ -6567,7 +6568,8 @@ c_expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n \t     || TREE_CODE (output) == FIX_CEIL_EXPR)\n \toutput = TREE_OPERAND (output, 0);\n \n-      lvalue_or_else (o[i], \"invalid lvalue in asm statement\");\n+      if (last_tree)\n+\tlvalue_or_else (o[i], \"invalid lvalue in asm statement\");\n     }\n \n   /* Perform default conversions on array and function inputs.  */\n@@ -6578,6 +6580,14 @@ c_expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n \t|| TREE_CODE (TREE_TYPE (TREE_VALUE (tail))) == FUNCTION_TYPE)\n       TREE_VALUE (tail) = default_conversion (TREE_VALUE (tail));\n \n+  if (last_tree)\n+    {\n+      add_stmt (build_stmt (ASM_STMT, \n+\t\t\t    vol ? ridpointers[(int) RID_VOLATILE] : NULL_TREE,\n+\t\t\t    string, outputs, inputs, clobbers));\n+      return;\n+    }\n+\n   /* Generate the ASM_OPERANDS insn;\n      store into the TREE_VALUEs of OUTPUTS some trees for\n      where the values were actually stored.  */\n@@ -6703,53 +6713,115 @@ c_expand_return (retval)\n       current_function_returns_value = 1;\n     }\n \n-  genrtl_return_stmt (build_return_stmt (retval));\n+ add_stmt (build_return_stmt (retval));\n }\n \f\n-/* Start a C switch statement, testing expression EXP.\n-   Return EXP if it is valid, an error node otherwise.  */\n+struct c_switch {\n+  /* The SWITCH_STMT being built.  */\n+  tree switch_stmt;\n+  /* A splay-tree mapping the low element of a case range to the high\n+     element, or NULL_TREE if there is no high element.  Used to\n+     determine whether or not a new case label duplicates an old case\n+     label.  We need a tree, rather than simply a hash table, because\n+     of the GNU case range extension.  */\n+  splay_tree cases;\n+  /* The next node on the stack.  */\n+  struct c_switch *next;\n+};\n+\n+/* A stack of the currently active switch statements.  The innermost\n+   switch statement is on the top of the stack.  There is no need to\n+   mark the stack for garbage collection because it is only active\n+   during the processing of the body of a function, and we never\n+   collect at that point.  */\n+\n+static struct c_switch *switch_stack;\n+\n+/* Start a C switch statement, testing expression EXP.  Return the new\n+   SWITCH_STMT.  */\n \n tree\n-c_expand_start_case (exp)\n+c_start_case (exp)\n      tree exp;\n {\n   register enum tree_code code;\n   tree type;\n+  struct c_switch *cs;\n \n-  if (TREE_CODE (exp) == ERROR_MARK)\n-    return exp;\n+  if (exp != error_mark_node)\n+    {\n+      code = TREE_CODE (TREE_TYPE (exp));\n+      type = TREE_TYPE (exp);\n \n-  code = TREE_CODE (TREE_TYPE (exp));\n-  type = TREE_TYPE (exp);\n+      if (code != INTEGER_TYPE \n+\t  && code != ENUMERAL_TYPE \n+\t  && code != ERROR_MARK)\n+\t{\n+\t  error (\"switch quantity not an integer\");\n+\t  exp = integer_zero_node;\n+\t}\n+      else\n+\t{\n+\t  tree index;\n+\t  type = TYPE_MAIN_VARIANT (TREE_TYPE (exp));\n \n-  if (code != INTEGER_TYPE && code != ENUMERAL_TYPE && code != ERROR_MARK)\n-    {\n-      error (\"switch quantity not an integer\");\n-      exp = error_mark_node;\n+\t  if (warn_traditional && !in_system_header\n+\t      && (type == long_integer_type_node\n+\t\t  || type == long_unsigned_type_node))\n+\t    warning (\"`long' switch expression not converted to `int' in ISO C\");\n+\n+\t  exp = default_conversion (exp);\n+\t  type = TREE_TYPE (exp);\n+\t  index = get_unwidened (exp, NULL_TREE);\n+\t  /* We can't strip a conversion from a signed type to an\n+\t     unsigned, because if we did, int_fits_type_p would do the\n+\t     wrong thing when checking case values for being in range,\n+\t     and it's too hard to do the right thing.  */\n+\t  if (TREE_UNSIGNED (TREE_TYPE (exp))\n+\t      == TREE_UNSIGNED (TREE_TYPE (index)))\n+\t    exp = index;\n+\t}\n     }\n+\n+  /* Add this new SWITCH_STMT to the stack.  */\n+  cs = (struct c_switch *) xmalloc (sizeof (cs));\n+  cs->switch_stmt = build_stmt (SWITCH_STMT, exp, NULL_TREE, NULL_TREE);\n+  cs->cases = splay_tree_new (case_compare, NULL, NULL);\n+  cs->next = switch_stack;\n+  switch_stack = cs;\n+\n+  return add_stmt (switch_stack->switch_stmt);\n+}\n+\n+/* Process a case label.  */\n+\n+void\n+do_case (low_value, high_value)\n+     tree low_value;\n+     tree high_value;\n+{\n+  if (switch_stack)\n+    c_add_case_label (switch_stack->cases, \n+\t\t      SWITCH_COND (switch_stack->switch_stmt), \n+\t\t      low_value, \n+\t\t      high_value);\n+  else if (low_value)\n+    error (\"case label not within a switch statement\");\n   else\n-    {\n-      tree index;\n-      type = TYPE_MAIN_VARIANT (TREE_TYPE (exp));\n+    error (\"`default' label not within a switch statement\");\n+}\n \n-      if (warn_traditional && !in_system_header\n-\t  && (type == long_integer_type_node\n-\t      || type == long_unsigned_type_node))\n-\twarning (\"`long' switch expression not converted to `int' in ISO C\");\n+/* Finish the switch statement.  */\n \n-      exp = default_conversion (exp);\n-      type = TREE_TYPE (exp);\n-      index = get_unwidened (exp, NULL_TREE);\n-      /* We can't strip a conversion from a signed type to an unsigned,\n-\t because if we did, int_fits_type_p would do the wrong thing\n-\t when checking case values for being in range,\n-\t and it's too hard to do the right thing.  */\n-      if (TREE_UNSIGNED (TREE_TYPE (exp))\n-\t  == TREE_UNSIGNED (TREE_TYPE (index)))\n-\texp = index;\n-    }\n+void\n+c_finish_case ()\n+{\n+  struct c_switch *cs = switch_stack;\n \n-  expand_start_case (1, exp, type, \"switch statement\");\n+  RECHAIN_STMTS (cs->switch_stmt, SWITCH_BODY (cs->switch_stmt)); \n \n-  return exp;\n+  /* Pop the stack.  */\n+  switch_stack = switch_stack->next;\n+  splay_tree_delete (cs->cases);\n+  free (cs);\n }"}, {"sha": "66e39759b8ee2cf0503b8b908a3a17786c5760e3", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8", "patch": "@@ -1,3 +1,54 @@\n+2000-09-16  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (struct cp_language_function): Remove\n+\tx_scope_stmt_stack and name_declared.\n+\t(current_scope_stmt_stack): Remove.\n+\t(function_name_declared_p): New macro.\n+\t(struct lang_decl_flags): Use c_lang_decl as a base class.\n+\t(context): Remove.\n+\t(struct lang_decl): Replace saved_tree with context.\n+\t(DECL_FRIEND_CONTEXT): Adjust accordingly.\n+\t(SET_DECL_FRIEND_CONTEXT): Likewise.\n+\t(DECL_VIRTUAL_CONTEXT): Likewise.\n+\t(DECL_SAVED_TREE): Remove.\n+\t(C_DECLARED_LABEL_FLAG): Likewise.\n+\t(cplus_expand_expr_stmt): Don't declare.\n+\t(add_decl_stmt): Likewise.\n+\t(add_scope_stmt): Likewise.\n+\t* decl.c (mark_stmt_tree): Remove.\n+\t(case_compare): Likewise.\n+\t(finish_case_label): Use c_add_case_label.\n+\t(init_decl_processing): Set more language-specific hooks.\n+\t(build_enumerator): Fix typo in comment.\n+\t(cplus_expand_expr_stmt): Remove.\n+\t(mark_lang_function): Use mark_c_language_function.\n+\t(lang_mark_tree): Use c_mark_lang_decl.\n+\t* decl2.c: Change order of inclusion.\n+\t* except.c: Likewise.\n+\t* expr.c (cplus_expand_expr): Remove handling of STMT_EXPR.  Fall\n+\tback on c_expand_expr.\n+\t* friend.c: Include expr.h.\n+\t* init.c: Change order of inclusion.\n+\t* Makefile.in: Update dependencies.\n+\t* lex.h (free_lang_decl_chain): Remove.\n+\t* optimize.c (maybe_clone_body): Use function_name_declared_p.\n+\t* pt.c (build_template_decl): Don't copy DECL_VIRTUAL_CONTEXT if\n+\tit doesn't exist.\n+\t(instantiate_decl): Use function_name_declared_p.\n+\t* semantics.c (lang_expand_expr_stmt): Remove.\n+\t(set_current_function_name_declared): Likewise.\n+\t(current_function_name_declared): Likewise.\n+\t(begin_compound_stmt): Use function_name_declared_p.\n+\t(add_decl_stmt): Remove.\n+\t(setup_vtbl_ptr): Use function_name_declared_p.\n+\t(add_scope_stmt): Remove.\n+\t(current_scope_stmt_stack): New function.\n+\t(cp_expand_stmt): Don't handle SCOPE_STMTs.\n+\t(expand_body): Use function_name_declared_p.\n+\t* tree.c (cp_statement_code_p): Don't include SCOPE_STMT.\n+\t* typeck.c: Change order of includes.\n+\t(convert_sequence): Remove.\n+\t\n 2000-09-14  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* lex.c (reswords): Add _Complex."}, {"sha": "b81c4f025e301575aab990707b0185e2587dbb04", "filename": "gcc/cp/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Fcp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Fcp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMakefile.in?ref=8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8", "patch": "@@ -265,7 +265,7 @@ class.o : class.c $(CXX_TREE_H) $(srcdir)/../flags.h \\\n call.o : call.c $(CXX_TREE_H) $(srcdir)/../flags.h \\\n   $(srcdir)/../toplev.h $(RTL_H) $(EXPR_H) $(GGC_H)\n friend.o : friend.c $(CXX_TREE_H) $(srcdir)/../flags.h $(RTL_H) \\\n-  $(srcdir)/../toplev.h\n+  $(srcdir)/../toplev.h $(EXPR_H)\n init.o : init.c $(CXX_TREE_H) $(srcdir)/../flags.h $(RTL_H) \\\n   $(EXPR_H) $(srcdir)/../toplev.h $(GGC_H) \\\n   $(srcdir)/../except.h"}, {"sha": "b7bc919791ba4e9a1995be3f8bc4171c41463224", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 14, "deletions": 26, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8", "patch": "@@ -878,7 +878,6 @@ struct cp_language_function\n   tree x_current_class_ptr;\n   tree x_current_class_ref;\n   tree x_eh_spec_try_block;\n-  tree x_scope_stmt_stack;\n   tree x_in_charge_parm;\n \n   tree *x_vcalls_possible_p;\n@@ -889,7 +888,6 @@ struct cp_language_function\n   int returns_null;\n   int in_function_try_handler;\n   int x_expanding_p;\n-  int name_declared;\n   int vtbls_set_up_p;\n \n   struct named_label_use_list *x_named_label_uses;\n@@ -928,10 +926,6 @@ struct cp_language_function\n \n #define current_eh_spec_try_block cp_function_chain->x_eh_spec_try_block\n \n-/* The stack of SCOPE_STMTs for the current function.  */\n-\n-#define current_scope_stmt_stack cp_function_chain->x_scope_stmt_stack\n-\n /* The `__in_chrg' parameter for the current function.  Only used for\n    destructors.  */\n \n@@ -978,6 +972,12 @@ struct cp_language_function\n \n #define in_function_try_handler cp_function_chain->in_function_try_handler\n \n+/* Nonzero if __FUNCTION__ and its ilk have been declared in this\n+   function.  */\n+\n+#define function_name_declared_p \\\n+  (cp_function_chain->base.x_function_name_declared_p)\n+\n extern tree current_function_return_value;\n extern tree global_namespace;\n \n@@ -1811,6 +1811,8 @@ struct lang_type\n \n struct lang_decl_flags\n {\n+  struct c_lang_decl base;\n+\n   ENUM_BITFIELD(languages) language : 8;\n \n   unsigned operator_attr : 1;\n@@ -1839,8 +1841,6 @@ struct lang_decl_flags\n   unsigned generate_with_vtable_p : 1;\n   unsigned dummy : 1;\n \n-  tree context;\n-\n   union {\n     /* In a FUNCTION_DECL, VAR_DECL, TYPE_DECL, or TEMPLATE_DECL, this\n        is DECL_TEMPLATE_INFO.  */\n@@ -1872,8 +1872,9 @@ struct lang_decl\n \n   tree befriending_classes;\n \n-  /* In a FUNCTION_DECL, this is DECL_SAVED_TREE.  */\n-  tree saved_tree;\n+  /* For a virtual FUNCTION_DECL, this is DECL_VIRTUAL_CONTEXT.  For a\n+     non-virtual FUNCTION_DECL, this is DECL_FRIEND_CONTEXT.  */\n+  tree context;\n \n   /* In a FUNCTION_DECL, this is DECL_CLONED_FUNCTION.  */\n   tree cloned_function;\n@@ -2168,12 +2169,12 @@ struct lang_decl\n    the DECL_FRIEND_CONTEXT for `f' will be `S'.  */\n #define DECL_FRIEND_CONTEXT(NODE)\t\t\t\t\\\n   ((DECL_FRIEND_P (NODE) && !DECL_FUNCTION_MEMBER_P (NODE))\t\\\n-   ? DECL_LANG_SPECIFIC (NODE)->decl_flags.context              \\\n+   ? DECL_LANG_SPECIFIC (NODE)->context                         \\\n    : NULL_TREE)\n \n /* Set the DECL_FRIEND_CONTEXT for NODE to CONTEXT.  */\n #define SET_DECL_FRIEND_CONTEXT(NODE, CONTEXT) \\\n-  (DECL_LANG_SPECIFIC (NODE)->decl_flags.context = (CONTEXT))\n+  (DECL_LANG_SPECIFIC (NODE)->context = (CONTEXT))\n \n /* NULL_TREE in DECL_CONTEXT represents the global namespace. */\n #define CP_DECL_CONTEXT(NODE) \\\n@@ -2183,7 +2184,7 @@ struct lang_decl\n /* For a virtual function, the base where we find its vtable entry.\n    For a non-virtual function, the base where it is defined.  */\n #define DECL_VIRTUAL_CONTEXT(NODE) \\\n-  (DECL_LANG_SPECIFIC (NODE)->decl_flags.context)\n+  (DECL_LANG_SPECIFIC (NODE)->context)\n \n /* 1 iff NODE has namespace scope, including the global namespace.  */\n #define DECL_NAMESPACE_SCOPE_P(NODE)\t\t\t\t\\\n@@ -2409,12 +2410,6 @@ struct lang_decl\n    the class definition is complete.  */\n #define TEMPLATE_PARMS_FOR_INLINE(NODE) TREE_LANG_FLAG_1 (NODE)\n \n-/* In a FUNCTION_DECL, the saved representation of the body of the\n-   entire function.  Usually a COMPOUND_STMT, but this may also be a\n-   RETURN_INIT, CTOR_INITIALIZER, or TRY_BLOCK.  */\n-#define DECL_SAVED_TREE(NODE) \\\n-  (DECL_LANG_SPECIFIC (FUNCTION_DECL_CHECK (NODE))->saved_tree)\n-\n /* In a FUNCTION_DECL, the saved language-specific per-function data.  */\n #define DECL_SAVED_FUNCTION_DATA(NODE) \\\n   (DECL_LANG_SPECIFIC (FUNCTION_DECL_CHECK (NODE))->u.saved_language_function)\n@@ -2532,10 +2527,6 @@ extern int flag_new_for_scope;\n #define ARITHMETIC_TYPE_P(TYPE) \\\n   (CP_INTEGRAL_TYPE_P (TYPE) || TREE_CODE (TYPE) == REAL_TYPE)\n \n-/* Mark which labels are explicitly declared.\n-   These may be shadowed, and may be referenced from nested functions.  */\n-#define C_DECLARED_LABEL_FLAG(label) TREE_LANG_FLAG_1 (label)\n-\n /* Nonzero for _TYPE means that the _TYPE defines\n    at least one constructor.  */\n #define TYPE_HAS_CONSTRUCTOR(NODE) (TYPE_LANG_FLAG_1(NODE))\n@@ -3904,7 +3895,6 @@ extern tree start_method\t\t\tPARAMS ((tree, tree, tree));\n extern tree finish_method\t\t\tPARAMS ((tree));\n extern void hack_incomplete_structures\t\tPARAMS ((tree));\n extern tree maybe_build_cleanup\t\t\tPARAMS ((tree));\n-extern void cplus_expand_expr_stmt\t\tPARAMS ((tree));\n extern void finish_stmt\t\t\t\tPARAMS ((void));\n extern void replace_defarg\t\t\tPARAMS ((tree, tree));\n extern void print_other_binding_stack\t\tPARAMS ((struct binding_level *));\n@@ -4356,12 +4346,10 @@ extern tree finish_base_specifier               PARAMS ((tree, tree));\n extern void finish_member_declaration           PARAMS ((tree));\n extern void check_multiple_declarators          PARAMS ((void));\n extern tree finish_typeof\t\t\tPARAMS ((tree));\n-extern void add_decl_stmt                       PARAMS ((tree));\n extern void finish_decl_cleanup                 PARAMS ((tree, tree));\n extern void finish_named_return_value           PARAMS ((tree, tree));\n extern void expand_body                         PARAMS ((tree));\n extern void prep_stmt                           PARAMS ((tree));\n-extern tree add_scope_stmt                      PARAMS ((int, int));\n extern void do_pushlevel                        PARAMS ((void));\n extern tree do_poplevel                         PARAMS ((void));\n extern void finish_mem_initializers             PARAMS ((tree));"}, {"sha": "3b2a0573b53609218ac99d5b5d55da617c9662bb", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 11, "deletions": 194, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8", "patch": "@@ -159,7 +159,6 @@ static void mark_named_label_lists PARAMS ((void *, void *));\n static void mark_cp_function_context PARAMS ((struct function *));\n static void mark_saved_scope PARAMS ((void *));\n static void mark_lang_function PARAMS ((struct cp_language_function *));\n-static void mark_stmt_tree PARAMS ((stmt_tree));\n static void save_function_data PARAMS ((tree));\n static void check_function_type PARAMS ((tree, tree));\n static void destroy_local_var PARAMS ((tree));\n@@ -176,7 +175,6 @@ static tree check_special_function_return_type\n   PARAMS ((special_function_kind, tree, tree, tree));\n static tree push_cp_library_fn PARAMS ((enum tree_code, tree));\n static tree build_cp_library_fn PARAMS ((tree, enum tree_code, tree));\n-static int case_compare PARAMS ((splay_tree_key, splay_tree_key));\n static void store_parm_decls PARAMS ((tree));\n \n #if defined (DEBUG_CP_BINDING_LEVELS)\n@@ -2411,16 +2409,6 @@ pop_nested_namespace (ns)\n    scope isn't enough, because more binding levels may be pushed.  */\n struct saved_scope *scope_chain;\n \n-/* Mark ST for GC.  */\n-\n-static void\n-mark_stmt_tree (st)\n-     stmt_tree st;\n-{\n-  ggc_mark_tree (st->x_last_stmt);\n-  ggc_mark_tree (st->x_last_expr_type);\n-}\n-\n /* Mark ARG (which is really a struct saved_scope **) for GC.  */\n \n static void\n@@ -5156,21 +5144,6 @@ struct cp_switch\n    \n static struct cp_switch *switch_stack;\n \n-static int\n-case_compare (k1, k2)\n-     splay_tree_key k1;\n-     splay_tree_key k2;\n-{\n-  /* Consider a NULL key (such as arises with a `default' label) to be\n-     smaller than anything else.  */\n-  if (!k1)\n-    return k2 ? -1 : 0;\n-  else if (!k2)\n-    return k1 ? 1 : 0;\n-\n-  return tree_int_cst_compare ((tree) k1, (tree) k2);\n-}\n-\n /* Called right after a switch-statement condition is parsed.\n    SWITCH_STMT is the switch statement being parsed.  */\n \n@@ -5206,12 +5179,7 @@ finish_case_label (low_value, high_value)\n      tree low_value;\n      tree high_value;\n {\n-  tree label;\n-  tree cleanup;\n-  tree type;\n   tree cond;\n-  tree case_label;\n-  splay_tree_node node;\n \n   if (! switch_stack)\n     {\n@@ -5225,13 +5193,13 @@ finish_case_label (low_value, high_value)\n       return;\n     }\n \n-  label = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n-  DECL_CONTEXT (label) = current_function_decl;\n-\n   if (processing_template_decl)\n     {\n+      tree label;\n+\n       /* For templates, just add the case label; we'll do semantic\n \t analysis at instantiation-time.  */\n+      label = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n       add_stmt (build_case_label (low_value, high_value, label));\n       return;\n     }\n@@ -5240,141 +5208,15 @@ finish_case_label (low_value, high_value)\n   cond = SWITCH_COND (switch_stack->switch_stmt);\n   if (cond && TREE_CODE (cond) == TREE_LIST)\n     cond = TREE_VALUE (cond);\n-  /* If there was an error processing the switch condition, bail now\n-     before we get more confused.  */\n-  if (!cond || cond == error_mark_node)\n-    return;\n-  type = TREE_TYPE (cond);\n-\n-  if ((low_value && TREE_TYPE (low_value) \n-       && POINTER_TYPE_P (TREE_TYPE (low_value))) \n-      || (high_value && TREE_TYPE (high_value)\n-\t  && POINTER_TYPE_P (TREE_TYPE (high_value))))\n-    error (\"pointers are not permitted as case values\");\n \n-  /* Case ranges are a GNU extension.  */\n-  if (high_value && pedantic)\n-    pedwarn (\"ISO C++ forbids range expressions in switch statement\");\n-\n-  if (low_value)\n-    {\n-      low_value = check_case_value (low_value);\n-      low_value = convert_and_check (type, low_value);\n-    }\n-  if (high_value)\n-    {\n-      high_value = check_case_value (high_value);\n-      high_value = convert_and_check (type, high_value);\n-    }\n-\n-  /* If an error has occurred, bail out now.  */\n-  if (low_value == error_mark_node || high_value == error_mark_node)\n-    return;\n-\n-  /* If the LOW_VALUE and HIGH_VALUE are the same, then this isn't\n-     really a case range, even though it was written that way.  Remove\n-     the HIGH_VALUE to simplify later processing.  */\n-  if (tree_int_cst_equal (low_value, high_value))\n-    high_value = NULL_TREE;\n-  if (low_value && high_value \n-      && !tree_int_cst_lt (low_value, high_value)) \n-    warning (\"empty range specified\");\n-\n-  /* Look up the LOW_VALUE in the table of case labels we already\n-     have.  */\n-  node = splay_tree_lookup (switch_stack->cases, (splay_tree_key) low_value);\n-  /* If there was not an exact match, check for overlapping ranges.\n-     There's no need to do this if there's no LOW_VALUE or HIGH_VALUE;\n-     that's a `default' label and the only overlap is an exact match.  */\n-  if (!node && (low_value || high_value))\n-    {\n-      splay_tree_node low_bound;\n-      splay_tree_node high_bound;\n-\n-      /* Even though there wasn't an exact match, there might be an\n-\t overlap between this case range and another case range.\n-\t Since we've (inductively) not allowed any overlapping case\n-\t ranges, we simply need to find the greatest low case label\n-\t that is smaller that LOW_VALUE, and the smallest low case\n-\t label that is greater than LOW_VALUE.  If there is an overlap\n-\t it will occur in one of these two ranges.  */\n-      low_bound = splay_tree_predecessor (switch_stack->cases,\n-\t\t\t\t\t  (splay_tree_key) low_value);\n-      high_bound = splay_tree_successor (switch_stack->cases,\n-\t\t\t\t\t (splay_tree_key) low_value);\n-\n-      /* Check to see if the LOW_BOUND overlaps.  It is smaller than\n-\t the LOW_VALUE, so there is no need to check unless the\n-\t LOW_BOUND is in fact itself a case range.  */\n-      if (low_bound\n-\t  && CASE_HIGH ((tree) low_bound->value)\n-\t  && tree_int_cst_compare (CASE_HIGH ((tree) low_bound->value),\n-\t\t\t\t    low_value) >= 0)\n-\tnode = low_bound;\n-      /* Check to see if the HIGH_BOUND overlaps.  The low end of that\n-\t range is bigger than the low end of the current range, so we\n-\t are only interested if the current range is a real range, and\n-\t not an ordinary case label.  */\n-      else if (high_bound \n-\t       && high_value\n-\t       && (tree_int_cst_compare ((tree) high_bound->key,\n-\t\t\t\t\t high_value)\n-\t\t   <= 0))\n-\tnode = high_bound;\n-    }\n-  /* If there was an overlap, issue an error.  */\n-  if (node)\n-    {\n-      tree duplicate = CASE_LABEL_DECL ((tree) node->value);\n-\n-      if (high_value)\n-\t{\n-\t  error (\"duplicate (or overlapping) case value\");\n-\t  cp_error_at (\"this is the first entry overlapping that value\",\n-\t\t       duplicate);\n-\t}\n-      else if (low_value)\n-\t{\n-\t  cp_error (\"duplicate case value `%E'\", low_value) ;\n-\t  cp_error_at (\"previously used here\", duplicate);\n-\t}\n-      else\n-\t{\n-\t  error (\"multiple default labels in one switch\");\n-\t  cp_error_at (\"this is the first default label\", duplicate);\n-\t}\n-      return;\n-    }\n-\n-  cleanup = last_cleanup_this_contour ();\n-  if (cleanup)\n-    {\n-      static int explained = 0;\n-      cp_warning_at (\"destructor needed for `%#D'\", TREE_PURPOSE (cleanup));\n-      warning (\"where case label appears here\");\n-      if (!explained)\n-\t{\n-\t  warning (\"(enclose actions of previous case statements requiring destructors in their own scope.)\");\n-\t  explained = 1;\n-\t}\n-    }\n+  c_add_case_label (switch_stack->cases, cond, low_value, high_value);\n \n   check_switch_goto (switch_stack->level);\n \n   /* After labels, make any new cleanups go into their\n      own new (temporary) binding contour.  */\n   current_binding_level->more_cleanups_ok = 0;\n   current_function_return_value = NULL_TREE;\n-\n-  /* Add a representation for the case label to the statement\n-     tree.  */\n-  case_label = build_case_label (low_value, high_value, label);\n-  add_stmt (case_label);\n-\n-  /* Register this case label in the splay tree.  */\n-  splay_tree_insert (switch_stack->cases, \n-\t\t     (splay_tree_key) low_value,\n-\t\t     (splay_tree_value) case_label);\n }\n \f\n /* Return the list of declarations of the current level.\n@@ -6462,11 +6304,11 @@ init_decl_processing ()\n   /* Create all the identifiers we need.  */\n   initialize_predefined_identifiers ();\n \n-  /* Let the back-end now how to save and restore language-specific\n-     per-function globals.  */\n+  /* Fill in back-end hooks.  */\n   init_lang_status = &push_cp_function_context;\n   free_lang_status = &pop_cp_function_context;\n   mark_lang_status = &mark_cp_function_context;\n+  lang_safe_from_p = &c_safe_from_p;\n \n   cp_parse_init ();\n   init_decl2 ();\n@@ -13557,7 +13399,7 @@ build_enumerator (name, value, enumtype)\n \n   if (context && context == current_class_type)\n     /* This enum declaration is local to the class.  We need the full\n-      lang_decl so that we can record DECL_CLASS_CONTEXT, for example.  */\n+       lang_decl so that we can record DECL_CLASS_CONTEXT, for example.  */\n     decl = build_lang_decl (CONST_DECL, name, type);\n   else\n     /* It's a global enum, or it's local to a function.  (Note local to\n@@ -14696,31 +14538,6 @@ maybe_build_cleanup (decl)\n   return 0;\n }\n \f\n-/* Expand a C++ expression at the statement level.\n-   This is needed to ferret out nodes which have UNKNOWN_TYPE.\n-   The C++ type checker should get all of these out when\n-   expressions are combined with other, type-providing, expressions,\n-   leaving only orphan expressions, such as:\n-\n-   &class::bar;\t\t/ / takes its address, but does nothing with it.  */\n-\n-void\n-cplus_expand_expr_stmt (exp)\n-     tree exp;\n-{\n-#if 0\n-  /* We should do this eventually, but right now this causes regex.o from\n-     libg++ to miscompile, and tString to core dump.  */\n-  exp = build1 (CLEANUP_POINT_EXPR, TREE_TYPE (exp), exp);\n-#endif\n-\n-  /* If we don't do this, we end up down inside expand_expr\n-     trying to do TYPE_MODE on the ERROR_MARK, and really\n-     go outside the bounds of the type.  */\n-  if (exp != error_mark_node)\n-    expand_expr_stmt (exp);\n-}\n-\n /* When a stmt has been parsed, this function is called.  */\n \n void\n@@ -14801,17 +14618,17 @@ mark_lang_function (p)\n   if (!p)\n     return;\n \n+  mark_c_language_function (&p->base);\n+\n   ggc_mark_tree (p->x_ctor_label);\n   ggc_mark_tree (p->x_dtor_label);\n   ggc_mark_tree (p->x_current_class_ptr);\n   ggc_mark_tree (p->x_current_class_ref);\n   ggc_mark_tree (p->x_eh_spec_try_block);\n-  ggc_mark_tree (p->x_scope_stmt_stack);\n \n   ggc_mark_rtx (p->x_result_rtx);\n \n   mark_named_label_lists (&p->x_named_labels, &p->x_named_label_uses);\n-  mark_stmt_tree (&p->base.x_stmt_tree);\n   mark_binding_level (&p->bindings);\n }\n \n@@ -14872,21 +14689,21 @@ lang_mark_tree (t)\n       if (ld)\n \t{\n \t  ggc_mark (ld);\n+\t  c_mark_lang_decl (&ld->decl_flags.base);\n \t  if (!DECL_GLOBAL_CTOR_P (t) \n \t      && !DECL_GLOBAL_DTOR_P (t)\n \t      && !DECL_THUNK_P (t))\n \t    ggc_mark_tree (ld->decl_flags.u2.access);\n \t  else if (DECL_THUNK_P (t))\n \t    ggc_mark_tree (ld->decl_flags.u2.vcall_offset);\n-\t  ggc_mark_tree (ld->decl_flags.context);\n \t  if (TREE_CODE (t) != NAMESPACE_DECL)\n \t    ggc_mark_tree (ld->decl_flags.u.template_info);\n \t  else\n \t    mark_binding_level (&NAMESPACE_LEVEL (t));\n \t  if (CAN_HAVE_FULL_LANG_DECL_P (t))\n \t    {\n \t      ggc_mark_tree (ld->befriending_classes);\n-\t      ggc_mark_tree (ld->saved_tree);\n+\t      ggc_mark_tree (ld->context);\n \t      ggc_mark_tree (ld->cloned_function);\n \t      if (!DECL_OVERLOADED_OPERATOR_P (t))\n \t\tggc_mark_tree (ld->u2.vtt_parm);"}, {"sha": "b579f5976f8fe880141f5a98c11a4beb6f69bf22", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8", "patch": "@@ -32,13 +32,13 @@ Boston, MA 02111-1307, USA.  */\n #include \"system.h\"\n #include \"tree.h\"\n #include \"rtl.h\"\n+#include \"expr.h\"\n #include \"flags.h\"\n #include \"cp-tree.h\"\n #include \"decl.h\"\n #include \"lex.h\"\n #include \"output.h\"\n #include \"except.h\"\n-#include \"expr.h\"\n #include \"defaults.h\"\n #include \"toplev.h\"\n #include \"dwarf2out.h\""}, {"sha": "ee2cf44675cf7f0b3c65284067dbf3e7a86c9042", "filename": "gcc/cp/except.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8", "patch": "@@ -27,10 +27,10 @@ Boston, MA 02111-1307, USA.  */\n #include \"system.h\"\n #include \"tree.h\"\n #include \"rtl.h\"\n+#include \"expr.h\"\n #include \"cp-tree.h\"\n #include \"flags.h\"\n #include \"obstack.h\"\n-#include \"expr.h\"\n #include \"output.h\"\n #include \"except.h\"\n #include \"defaults.h\""}, {"sha": "c49a2f93583cf835e02ab3e6a7154849c1c79d74", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 1, "deletions": 21, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8", "patch": "@@ -133,28 +133,8 @@ cplus_expand_expr (exp, target, tmode, modifier)\n       /* We don't need to generate any code for an empty class.  */\n       return const0_rtx;\n \n-    case STMT_EXPR:\n-      {\n-\ttree rtl_expr;\n-\trtx result;\n-\n-\t/* Since expand_expr_stmt calls free_temp_slots after every\n-\t   expression statement, we must call push_temp_slots here.\n-\t   Otherwise, any temporaries in use now would be considered\n-\t   out-of-scope after the first EXPR_STMT from within the\n-\t   STMT_EXPR.  */\n-\tpush_temp_slots ();\n-\trtl_expr = expand_start_stmt_expr ();\n-\texpand_stmt (STMT_EXPR_STMT (exp));\n-\texpand_end_stmt_expr (rtl_expr);\n-\tresult = expand_expr (rtl_expr, target, tmode, modifier);\n-\tpop_temp_slots ();\n-\treturn result;\n-      }\n-      break;\n-\n     default:\n-      break;\n+      return c_expand_expr (exp, target, tmode, modifier);\n     }\n   my_friendly_abort (40);\n   /* NOTREACHED */"}, {"sha": "1cc990522558023388d11606f4ae1404c4a63852", "filename": "gcc/cp/friend.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Fcp%2Ffriend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Fcp%2Ffriend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ffriend.c?ref=8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8", "patch": "@@ -22,6 +22,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"system.h\"\n #include \"tree.h\"\n #include \"rtl.h\"\n+#include \"expr.h\"\n #include \"cp-tree.h\"\n #include \"flags.h\"\n #include \"output.h\""}, {"sha": "89619ee4e503496c0ca46f611af1173d856207a9", "filename": "gcc/cp/init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8", "patch": "@@ -26,11 +26,11 @@ Boston, MA 02111-1307, USA.  */\n #include \"system.h\"\n #include \"tree.h\"\n #include \"rtl.h\"\n+#include \"expr.h\"\n #include \"cp-tree.h\"\n #include \"flags.h\"\n #include \"output.h\"\n #include \"except.h\"\n-#include \"expr.h\"\n #include \"toplev.h\"\n #include \"ggc.h\"\n "}, {"sha": "272a917f97e5e2cf9c7cb7e369e97e29f0d87fc9", "filename": "gcc/cp/lex.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Fcp%2Flex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Fcp%2Flex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.h?ref=8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8", "patch": "@@ -88,6 +88,4 @@ extern int pending_lang_change;\n \n extern int yylex PARAMS ((void));\n \n-extern struct lang_decl *free_lang_decl_chain;\n-\n #endif /* _CP_LEX_H */"}, {"sha": "be53216ac7cac14222346758fba10ca545917319", "filename": "gcc/cp/optimize.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Fcp%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Fcp%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foptimize.c?ref=8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8", "patch": "@@ -1004,7 +1004,7 @@ maybe_clone_body (fn)\n       VARRAY_FREE (id.fns);\n \n       /* Now, expand this function into RTL, if appropriate.  */\n-      cp_function_chain->name_declared = 1;\n+      function_name_declared_p = 1;\n       expand_body (finish_function (0));\n       pop_from_top_level ();\n     }"}, {"sha": "e3357a0bce0cc1598509dfdf7ab35ed68ac341e6", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8", "patch": "@@ -1985,7 +1985,8 @@ build_template_decl (decl, parms)\n   DECL_CONTEXT (tmpl) = DECL_CONTEXT (decl);\n   if (DECL_LANG_SPECIFIC (decl))\n     {\n-      DECL_VIRTUAL_CONTEXT (tmpl) = DECL_VIRTUAL_CONTEXT (decl);\n+      if (CAN_HAVE_FULL_LANG_DECL_P (decl))\n+\tDECL_VIRTUAL_CONTEXT (tmpl) = DECL_VIRTUAL_CONTEXT (decl);\n       DECL_STATIC_FUNCTION_P (tmpl) = DECL_STATIC_FUNCTION_P (decl);\n       DECL_CONSTRUCTOR_P (tmpl) = DECL_CONSTRUCTOR_P (decl);\n       DECL_NONCONVERTING_P (tmpl) = DECL_NONCONVERTING_P (decl);\n@@ -9689,7 +9690,7 @@ instantiate_decl (d, defer_ok)\n \n       /* We already set up __FUNCTION__, etc., so we don't want to do\n \t it again now.  */\n-      cp_function_chain->name_declared = 1;\n+      function_name_declared_p = 1;\n \n       /* Substitute into the body of the function.  */\n       tsubst_expr (DECL_SAVED_TREE (code_pattern), args,"}, {"sha": "2f4432f5a18a6c14211747b1af1078dd9bd3c1d8", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 10, "deletions": 87, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8", "patch": "@@ -77,19 +77,6 @@ static void genrtl_finish_function PARAMS ((tree));\n       substmt = cond;\t\t\t\t\t\\\n   } while (0)\n \n-/* Wrapper since C and C++ expand_expr_stmt are different. */\n-\n-expand_expr_stmt_fn lang_expand_expr_stmt = cplus_expand_expr_stmt;\n-\n-/* Wrapper function instead of #define for use with c-common code. */\n-\n-void\n-set_current_function_name_declared (i)\n-     int i;\n-{\n-  cp_function_chain->name_declared = i;\n-}\n-\n /* Returns non-zero if the current statement is a full expression,\n    i.e. temporaries created during that statement should be destroyed\n    at the end of the statement.  */\n@@ -112,16 +99,6 @@ current_stmt_tree ()\n \t  : &scope_chain->x_stmt_tree);\n }\n \n-/* One if we have already declared __FUNCTION__ (and related\n-   variables) in the current function.  Two if we are in the process\n-   of doing so.  */\n-\n-int\n-current_function_name_declared ()\n-{\n-  return cp_function_chain->name_declared;\n-}\n-\n /* Nonzero if TYPE is an anonymous union or struct type.  We have to use a\n    flag for this because \"A union for which objects or pointers are\n    declared is not an anonymous union\" [class.union].  */\n@@ -863,10 +840,10 @@ begin_compound_stmt (has_no_scope)\n   /* If this is the outermost block of the function, declare the\n      variables __FUNCTION__, __PRETTY_FUNCTION__, and so forth.  */\n   if (cfun\n-      && !(current_function_name_declared () )\n+      && !function_name_declared_p\n       && !has_no_scope)\n     {\n-      cp_function_chain->name_declared = 1;\n+      function_name_declared_p = 1;\n       declare_function_name ();\n     }\n \n@@ -962,20 +939,6 @@ finish_label_decl (name)\n   add_decl_stmt (decl);\n }\n \n-/* Create a declaration statement for the declaration given by the\n-   DECL.  */\n-\n-void\n-add_decl_stmt (decl)\n-     tree decl;\n-{\n-  tree decl_stmt;\n-\n-  /* We need the type to last until instantiation time.  */\n-  decl_stmt = build_stmt (DECL_STMT, decl);\n-  add_stmt (decl_stmt); \n-}\n-\n /* Generate the RTL for a SUBOBJECT. */\n \n static void \n@@ -1216,10 +1179,10 @@ setup_vtbl_ptr (member_init_list, base_init_list)\n \n       /* Don't declare __PRETTY_FUNCTION__ and friends here when we\n \t open the block for the if-body.  */\n-      saved_cfnd = current_function_name_declared ();\n-      cp_function_chain->name_declared = 1;\n+      saved_cfnd = function_name_declared_p;\n+      function_name_declared_p = 1;\n       compound_stmt = begin_compound_stmt (/*has_no_scope=*/0);\n-      cp_function_chain->name_declared = saved_cfnd;\n+      function_name_declared_p = saved_cfnd;\n \n       /* Make all virtual function table pointers in non-virtual base\n \t classes point to CURRENT_CLASS_TYPE's virtual function\n@@ -1240,48 +1203,12 @@ setup_vtbl_ptr (member_init_list, base_init_list)\n   vtbls_set_up_p = 1;\n }\n \n+/* Returns the stack of SCOPE_STMTs for the current function.  */\n \n-/* Add a scope-statement to the statement-tree.  BEGIN_P indicates\n-   whether this statements opens or closes a scope.  PARTIAL_P is true\n-   for a partial scope, i.e, the scope that begins after a label when\n-   an object that needs a cleanup is created.  If BEGIN_P is nonzero,\n-   returns a new TREE_LIST representing the top of the SCOPE_STMT\n-   stack.  The TREE_PURPOSE is the new SCOPE_STMT.  If BEGIN_P is\n-   zero, returns a TREE_LIST whose TREE_VALUE is the new SCOPE_STMT,\n-   and whose TREE_PURPOSE is the matching SCOPE_STMT iwth\n-   SCOPE_BEGIN_P set.  */\n-\n-tree\n-add_scope_stmt (begin_p, partial_p)\n-     int begin_p;\n-     int partial_p;\n+tree *\n+current_scope_stmt_stack ()\n {\n-  tree ss;\n-  tree top;\n-\n-  /* Build the statement.  */\n-  ss = build_stmt (SCOPE_STMT, NULL_TREE);\n-  SCOPE_BEGIN_P (ss) = begin_p;\n-  SCOPE_PARTIAL_P (ss) = partial_p;\n-\n-  /* Keep the scope stack up to date.  */\n-  if (begin_p)\n-    {\n-      current_scope_stmt_stack \n-\t= tree_cons (ss, NULL_TREE, current_scope_stmt_stack);\n-      top = current_scope_stmt_stack;\n-    }\n-  else\n-    {\n-      top = current_scope_stmt_stack;\n-      TREE_VALUE (top) = ss;\n-      current_scope_stmt_stack = TREE_CHAIN (top);\n-    }\n-\n-  /* Add the new statement to the statement-tree.  */\n-  add_stmt (ss);\n-\n-  return top;\n+  return &cfun->language->x_scope_stmt_stack;\n }\n \n /* Finish a parenthesized expression EXPR.  */\n@@ -2236,10 +2163,6 @@ cp_expand_stmt (t)\n       genrtl_subobject (SUBOBJECT_CLEANUP (t));\n       break;\n \n-    case SCOPE_STMT:\n-      genrtl_scope_stmt (t);\n-      break;\n-\n     case RETURN_INIT:\n       genrtl_named_return_value ();\n       break;\n@@ -2483,7 +2406,7 @@ expand_body (fn)\n   /* We don't need to redeclare __FUNCTION__, __PRETTY_FUNCTION__, or\n      any of the other magic variables we set up when starting a\n      function body.  */\n-  cp_function_chain->name_declared = 1;\n+  function_name_declared_p = 1;\n \n   /* Expand the body.  */\n   expand_stmt (DECL_SAVED_TREE (fn));"}, {"sha": "9b5e2be87f2f593f35fe44141a392931b8fef4cb", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8", "patch": "@@ -1081,7 +1081,6 @@ cp_statement_code_p (code)\n     case CLEANUP_STMT:\n     case START_CATCH_STMT:\n     case CTOR_STMT:\n-    case SCOPE_STMT:\n     case CTOR_INITIALIZER:\n     case RETURN_INIT:\n     case TRY_BLOCK:"}, {"sha": "3a16526b43436fabe84aff609291aa5876c7a31c", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 1, "deletions": 33, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8", "patch": "@@ -34,11 +34,11 @@ Boston, MA 02111-1307, USA.  */\n #include \"system.h\"\n #include \"tree.h\"\n #include \"rtl.h\"\n+#include \"expr.h\"\n #include \"cp-tree.h\"\n #include \"tm_p.h\"\n #include \"flags.h\"\n #include \"output.h\"\n-#include \"expr.h\"\n #include \"toplev.h\"\n #include \"defaults.h\"\n \n@@ -54,9 +54,6 @@ static int comp_except_types PARAMS ((tree, tree, int));\n static int comp_array_types PARAMS ((int (*) (tree, tree, int), tree,\n \t\t\t\t   tree, int));\n static tree common_base_type PARAMS ((tree, tree));\n-#if 0\n-static tree convert_sequence PARAMS ((tree, tree));\n-#endif\n static tree lookup_anon_field PARAMS ((tree, tree));\n static tree pointer_diff PARAMS ((tree, tree, tree));\n static tree build_component_addr PARAMS ((tree, tree));\n@@ -4745,35 +4742,6 @@ build_unary_op (code, xarg, noconvert)\n   return error_mark_node;\n }\n \n-#if 0\n-/* If CONVERSIONS is a conversion expression or a nested sequence of such,\n-   convert ARG with the same conversions in the same order\n-   and return the result.  */\n-\n-static tree\n-convert_sequence (conversions, arg)\n-     tree conversions;\n-     tree arg;\n-{\n-  switch (TREE_CODE (conversions))\n-    {\n-    case NOP_EXPR:\n-    case CONVERT_EXPR:\n-    case FLOAT_EXPR:\n-    case FIX_TRUNC_EXPR:\n-    case FIX_FLOOR_EXPR:\n-    case FIX_ROUND_EXPR:\n-    case FIX_CEIL_EXPR:\n-      return cp_convert (TREE_TYPE (conversions),\n-\t\t\t convert_sequence (TREE_OPERAND (conversions, 0),\n-\t\t\t\t\t   arg));\n-\n-    default:\n-      return arg;\n-    }\n-}\n-#endif\n-\n /* Apply unary lvalue-demanding operator CODE to the expression ARG\n    for certain kinds of expressions which are not really lvalues\n    but which we can accept as lvalues."}, {"sha": "3bfe34a627b264ffb5bb162a741b03472a07d619", "filename": "gcc/dependence.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Fdependence.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Fdependence.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdependence.c?ref=8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8", "patch": "@@ -27,6 +27,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"system.h\"\n \n #include \"rtl.h\"\n+#include \"expr.h\"\n #include \"tree.h\"\n #include \"c-common.h\"\n #include \"flags.h\"\n@@ -58,7 +59,7 @@ Boston, MA 02111-1307, USA.  */\n    dependence to the dep_chain\n */\n \n-enum dependence_type {flow, anti, output, none};\n+enum dependence_type {dt_flow, dt_anti, dt_output, dt_none};\n #if 0\n static const char * dependence_string [] = {\"flow\", \"anti\", \"output\", \"none\"};\n #endif\n@@ -756,23 +757,23 @@ check_node_dependence (du)\n \t  dep_ptr->next = 0;\n \t  \n \t  if (def_ptr < use_ptr && use_ptr->type == use) \n-\t    dep_ptr->dependence = flow;\n+\t    dep_ptr->dependence = dt_flow;\n \t  else if (def_ptr > use_ptr && use_ptr->type == use)\n-\t    dep_ptr->dependence = anti;\n-\t  else dep_ptr->dependence = output;\n+\t    dep_ptr->dependence = dt_anti;\n+\t  else dep_ptr->dependence = dt_output;\n \n \t  for (j = 1 ; j <= i - 1 ; j++)\n \t    {\n \t      if (direction[j][0] == gt)\n \t\t{\n-\t\t  dep_ptr->dependence = anti;\n+\t\t  dep_ptr->dependence = dt_anti;\n \t\t  direction[j][0] = lt;\n \t\t  distance[j][0] = -distance[j][0];\n \t\t  break;\n \t\t}\n \t      else if (direction[j][0] == lt)\n \t\t{\n-\t\t  dep_ptr->dependence = flow;\n+\t\t  dep_ptr->dependence = dt_flow;\n \t\t  break;\n \t\t}\n \t    }\n@@ -796,7 +797,7 @@ check_node_dependence (du)\n \t      dep_root_ptr = VARRAY_TOP (dep_chain, generic);\n \t      dep_root_ptr->source = 0;\n \t      dep_root_ptr->destination = def_ptr->expression;\n-\t      dep_root_ptr->dependence = none;\n+\t      dep_root_ptr->dependence = dt_none;\n \t      dep_root_ptr->next = dep_ptr;\n \t      def_ptr->dep = dep_ptr;\n \t    }"}, {"sha": "bf2697a743c85c9839cee6c2d64500c43140d4bd", "filename": "gcc/expr.c", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8", "patch": "@@ -85,6 +85,15 @@ Boston, MA 02111-1307, USA.  */\n #define CASE_VECTOR_PC_RELATIVE 0\n #endif\n \n+/* Hook called by safe_from_p for language-specific tree codes.  It is\n+   up to the language front-end to install a hook if it has any such\n+   codes that safe_from_p needs to know about.  Since same_from_p will\n+   recursively explore the TREE_OPERANDs of an expression, this hook\n+   should not reexamine those pieces.  This routine may recursively\n+   call safe_from_p; it should always pass `0' as the TOP_P\n+   parameter.  */\n+int (*lang_safe_from_p) PARAMS ((rtx, tree));\n+\n /* If this is nonzero, we do not bother generating VOLATILE\n    around volatile memory references, and we are willing to\n    output indirect addresses.  If cse is to follow, we reject\n@@ -168,7 +177,6 @@ static enum memory_use_mode\n   get_memory_usage_from_modifier PARAMS ((enum expand_modifier));\n static tree save_noncopied_parts PARAMS ((tree, tree));\n static tree init_noncopied_parts PARAMS ((tree, tree));\n-static int safe_from_p\t\tPARAMS ((rtx, tree, int));\n static int fixed_type_p\t\tPARAMS ((tree));\n static rtx var_rtx\t\tPARAMS ((tree));\n static int readonly_fields_p\tPARAMS ((tree));\n@@ -5396,7 +5404,7 @@ init_noncopied_parts (lhs, list)\n    It is always safe for this routine to return zero since it merely\n    searches for optimization opportunities.  */\n \n-static int\n+int\n safe_from_p (x, exp, top_p)\n      rtx x;\n      tree exp;\n@@ -5595,11 +5603,18 @@ safe_from_p (x, exp, top_p)\n       if (exp_rtl)\n \tbreak;\n \n-      nops = TREE_CODE_LENGTH (TREE_CODE (exp));\n+      nops = first_rtl_op (TREE_CODE (exp));\n       for (i = 0; i < nops; i++)\n \tif (TREE_OPERAND (exp, i) != 0\n \t    && ! safe_from_p (x, TREE_OPERAND (exp, i), 0))\n \t  return 0;\n+\n+      /* If this is a language-specific tree code, it may require\n+\t special handling.  */\n+      if (TREE_CODE (exp) >= LAST_AND_UNUSED_TREE_CODE\n+\t  && lang_safe_from_p\n+\t  && !(*lang_safe_from_p) (x, exp))\n+\treturn 0;\n     }\n \n   /* If we have an rtl, find any enclosed object.  Then see if we conflict"}, {"sha": "596b68ab82f8c10bc6369e6763d3e5476ff48848", "filename": "gcc/expr.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8", "patch": "@@ -1257,6 +1257,17 @@ extern rtx (*lang_expand_expr) PARAMS ((union tree_node *, rtx,\n    such codes that output_constant needs to know about.  Returns a\n    language-independent constant equivalent to its input.  */\n extern tree (*lang_expand_constant) PARAMS ((tree));\n+\n+extern int safe_from_p PARAMS ((rtx, tree, int));\n+\n+/* Hook called by safe_from_p for language-specific tree codes.  It is\n+   up to the language front-end to install a hook if it has any such\n+   codes that safe_from_p needs to know about.  Since same_from_p will\n+   recursively explore the TREE_OPERANDs of an expression, this hook\n+   should not reexamine those pieces.  This routine may recursively\n+   call safe_from_p; it should always pass `0' as the TOP_P\n+   parameter.  */\n+extern int (*lang_safe_from_p) PARAMS ((rtx, tree));\n #endif\n \n extern void init_all_optabs\t\t\tPARAMS ((void));"}, {"sha": "920683815e4ed79d22c16249f125345f68c7761e", "filename": "gcc/objc/Make-lang.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Fobjc%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Fobjc%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FMake-lang.in?ref=8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8", "patch": "@@ -1,5 +1,5 @@\n # Top level makefile fragment for GNU Objective-C\n-#   Copyright (C) 1997, 1998 Free Software Foundation, Inc.\n+#   Copyright (C) 1997, 1998, 2000 Free Software Foundation, Inc.\n \n #This file is part of GNU CC.\n \n@@ -85,7 +85,7 @@ $(srcdir)/objc/objc-parse.y: $(srcdir)/c-parse.in\n \t$(SHELL) $(srcdir)/move-if-change tmp-objc-prs.y $(srcdir)/objc/objc-parse.y\n \n objc-act.o : $(srcdir)/objc/objc-act.c \\\n-   $(CONFIG_H) $(TREE_H) $(RTL_H) system.h \\\n+   $(CONFIG_H) $(TREE_H) $(RTL_H) system.h $(EXPR_H) \\\n    $(srcdir)/c-tree.h $(srcdir)/c-common.h $(srcdir)/c-lex.h \\\n    $(srcdir)/toplev.h $(srcdir)/flags.h $(srcdir)/objc/objc-act.h \\\n    $(srcdir)/input.h $(srcdir)/function.h $(srcdir)/output.h"}, {"sha": "5bb4fcd369444c4ca22d976edda0943aaabe2748", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8", "patch": "@@ -42,8 +42,11 @@ Boston, MA 02111-1307, USA.  */\n #include \"config.h\"\n #include \"system.h\"\n #include \"tree.h\"\n+#include \"rtl.h\"\n+#include \"expr.h\"\n #include \"c-tree.h\"\n #include \"c-lex.h\"\n+#include \"c-common.h\"\n #include \"flags.h\"\n #include \"objc-act.h\"\n #include \"input.h\"\n@@ -198,6 +201,7 @@ static void encode_aggregate_within\t\tPARAMS ((tree, int, int,\n \t\t\t\t\t               int, int));\n static const char *objc_demangle\t\tPARAMS ((const char *));\n static const char *objc_printable_name\t\tPARAMS ((tree, int));\n+static void objc_expand_function_end            PARAMS ((void));\n \n /* Misc. bookkeeping */\n \n@@ -7410,12 +7414,18 @@ encode_method_def (func_decl)\n   return result;\n }\n \n-void\n-finish_method_def ()\n+static void\n+objc_expand_function_end ()\n {\n   METHOD_ENCODING (method_context) = encode_method_def (current_function_decl);\n+}\n \n+void\n+finish_method_def ()\n+{\n+  lang_expand_function_end = objc_expand_function_end;\n   finish_function (0);\n+  lang_expand_function_end = NULL;\n \n   /* Required to implement _msgSuper. This must be done AFTER finish_function,\n      since the optimizer may find \"may be used before set\" errors.  */\n@@ -8172,7 +8182,7 @@ init_objc ()\n {\n   /* Add the special tree codes of Objective C to the tables.  */\n \n-#define LAST_CODE LAST_AND_UNUSED_TREE_CODE\n+#define LAST_CODE LAST_C_TREE_CODE\n \n   gcc_obstack_init (&util_obstack);\n   util_firstobj = (char *) obstack_finish (&util_obstack);\n@@ -8193,6 +8203,8 @@ init_objc ()\n \n   /* Change the default error function */\n   decl_printable_name = objc_printable_name;\n+  lang_expand_expr = c_expand_expr;\n+  lang_expand_decl_stmt = c_expand_decl_stmt;\n }\n \f\n static void"}, {"sha": "f13acc8f1927b60fe39b056d851f2a8f1c1e761c", "filename": "gcc/objc/objc-act.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Fobjc%2Fobjc-act.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Fobjc%2Fobjc-act.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.h?ref=8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8", "patch": "@@ -110,7 +110,7 @@ enum objc_tree_code {\n #ifdef OBJCPLUS\n   dummy_tree_code = LAST_CPLUS_TREE_CODE,\n #else\n-  dummy_tree_code = LAST_AND_UNUSED_TREE_CODE,\n+  dummy_tree_code = LAST_C_TREE_CODE,\n #endif\n #include \"objc-tree.def\"\n   LAST_OBJC_TREE_CODE"}, {"sha": "25382ccd40fd00293c352ec70477ee2d8ae5c8e0", "filename": "gcc/stmt.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8", "patch": "@@ -1923,11 +1923,14 @@ expand_expr_stmt (exp)\n   if (expr_stmts_for_value && TREE_CODE (TREE_TYPE (exp)) == FUNCTION_TYPE)\n     exp = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (exp)), exp);\n \n-  last_expr_type = TREE_TYPE (exp);\n+  /* The call to `expand_expr' could cause last_expr_type and\n+     last_expr_value to get reset.  Therefore, we set last_expr_value\n+     and last_expr_type *after* calling expand_expr.  */\n   last_expr_value = expand_expr (exp,\n \t\t\t\t (expr_stmts_for_value\n \t\t\t\t  ? NULL_RTX : const0_rtx),\n \t\t\t\t VOIDmode, 0);\n+  last_expr_type = TREE_TYPE (exp);\n \n   /* If all we do is reference a volatile value in memory,\n      copy it to a register to be sure it is actually touched.  */"}, {"sha": "f0748e714f696ae516284a539a6f3f83739233d4", "filename": "gcc/testsuite/gcc.dg/noncompile/920923-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Ftestsuite%2Fgcc.dg%2Fnoncompile%2F920923-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Ftestsuite%2Fgcc.dg%2Fnoncompile%2F920923-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fnoncompile%2F920923-1.c?ref=8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8", "patch": "@@ -75,7 +75,7 @@ caddr_t v_addr;\t\t\t/* { dg-error \"parse error\" } */\n \t  p_addr = fill_item_entry(va_op, v_addr);\n \t  goto page_type;\n      case((caddr_t)1):\t\t/* { dg-error \"parse error\" } */\n-     default:\t\t\t/* { dg-error \"default label\" } */\n+     default:\t\t\t\n \t  ((void)(((0))?0:(__eprintf(\"Failed assertion`%s'at line%d of`%s'.\\n\",\n \t\t\t\t     \"FALSE\", 327, \"b.c\"), 0)));\n      }"}, {"sha": "333cde6a00e2a0db8bb4b0acb9c123fa0ea7fa5f", "filename": "gcc/toplev.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8", "patch": "@@ -2566,7 +2566,11 @@ rest_of_decl_compilation (decl, asmspec, top_level, at_end)\n \t  make_decl_rtl (decl, asmspec, top_level);\n \t}\n       else\n-\terror (\"invalid register name `%s' for register variable\", asmspec);\n+\t{\n+\t  error (\"invalid register name `%s' for register variable\", asmspec);\n+\t  DECL_REGISTER (decl) = 0;\n+\t  make_decl_rtl (decl, NULL, top_level);\n+\t}\n     }\n #if defined (DBX_DEBUGGING_INFO) || defined (XCOFF_DEBUGGING_INFO)\n   else if ((write_symbols == DBX_DEBUG || write_symbols == XCOFF_DEBUG)"}, {"sha": "3f8d7c67c3f76156ab6286dc2a585bb84dc73590", "filename": "gcc/tree.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8", "patch": "@@ -2794,11 +2794,15 @@ int\n contains_placeholder_p (exp)\n      tree exp;\n {\n-  register enum tree_code code = TREE_CODE (exp);\n+  register enum tree_code code;\n   int result;\n \n+  if (!exp)\n+    return 0;\n+\n   /* If we have a WITH_RECORD_EXPR, it \"cancels\" any PLACEHOLDER_EXPR\n      in it since it is supplying a value for it.  */\n+  code = TREE_CODE (exp);\n   if (code == WITH_RECORD_EXPR)\n     return 0;\n   else if (code == PLACEHOLDER_EXPR)"}, {"sha": "853b2425bf59b944b299a93cf3168257b3cacb7e", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8", "patch": "@@ -1,3 +1,7 @@\n+2000-09-16  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* splay-tree.c (splay_tree_predecessor): Fix typo in comment.\n+\n 2000-09-14  Michael Sokolov  <msokolov@ivan.Harhan.ORG>\n \n \t* splay-tree.c: #include <stdio.h>."}, {"sha": "eb888148c80a78d30c948855758070dbfbd3666b", "filename": "libiberty/splay-tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/libiberty%2Fsplay-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8/libiberty%2Fsplay-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fsplay-tree.c?ref=8f17b5c5cbf15d0f3a548e94928caff9ffcfd7b8", "patch": "@@ -392,7 +392,7 @@ splay_tree_predecessor (sp, key)\n   if (comparison < 0)\n     return sp->root;\n \n-  /* Otherwise, find the rightmost element of the left subtree.  */\n+  /* Otherwise, find the leftmost element of the right subtree.  */\n   node = sp->root->left;\n   if (node)\n     while (node->right)"}]}