{"sha": "d536f4236b545134c84bd3d0f517934f0c36da97", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDUzNmY0MjM2YjU0NTEzNGM4NGJkM2QwZjUxNzkzNGYwYzM2ZGE5Nw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-02-10T14:42:13Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-02-10T14:42:13Z"}, "message": "(flush_pending_lists): Add new arg, ONLY_WRITE.\n\n(sched_analyze_{1,2,insn}): Add new arg to flush_pending_lists.\n(sched_analyze): Always flush pending write list for call, even const.\n\nFrom-SVN: r11200", "tree": {"sha": "03188978a89f82072c770b5b2ef723bc54e8e7fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/03188978a89f82072c770b5b2ef723bc54e8e7fb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d536f4236b545134c84bd3d0f517934f0c36da97", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d536f4236b545134c84bd3d0f517934f0c36da97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d536f4236b545134c84bd3d0f517934f0c36da97", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d536f4236b545134c84bd3d0f517934f0c36da97/comments", "author": null, "committer": null, "parents": [{"sha": "6c0449a57a9f88654b0b17b59f4a4aa1c6b339f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c0449a57a9f88654b0b17b59f4a4aa1c6b339f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c0449a57a9f88654b0b17b59f4a4aa1c6b339f5"}], "stats": {"total": 30, "additions": 14, "deletions": 16}, "files": [{"sha": "f279512d6eb2ef1c9bfb0c8925323d02273a4363", "filename": "gcc/sched.c", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d536f4236b545134c84bd3d0f517934f0c36da97/gcc%2Fsched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d536f4236b545134c84bd3d0f517934f0c36da97/gcc%2Fsched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched.c?ref=d536f4236b545134c84bd3d0f517934f0c36da97", "patch": "@@ -313,7 +313,7 @@ static int insn_cost\t\t\tPROTO((rtx, rtx, rtx));\n static int priority\t\t\tPROTO((rtx));\n static void free_pending_lists\t\tPROTO((void));\n static void add_insn_mem_dependence\tPROTO((rtx *, rtx *, rtx, rtx));\n-static void flush_pending_lists\t\tPROTO((rtx));\n+static void flush_pending_lists\t\tPROTO((rtx, int));\n static void sched_analyze_1\t\tPROTO((rtx, rtx));\n static void sched_analyze_2\t\tPROTO((rtx, rtx));\n static void sched_analyze_insn\t\tPROTO((rtx, rtx, rtx));\n@@ -1628,15 +1628,17 @@ add_insn_mem_dependence (insn_list, mem_list, insn, mem)\n }\n \f\n /* Make a dependency between every memory reference on the pending lists\n-   and INSN, thus flushing the pending lists.  */\n+   and INSN, thus flushing the pending lists.  If ONLY_WRITE, don't flush\n+   the read list.  */\n \n static void\n-flush_pending_lists (insn)\n+flush_pending_lists (insn, only_write)\n      rtx insn;\n+     int only_write;\n {\n   rtx link;\n \n-  while (pending_read_insns)\n+  while (pending_read_insns && ! only_write)\n     {\n       add_dependence (insn, XEXP (pending_read_insns, 0), REG_DEP_ANTI);\n \n@@ -1765,7 +1767,7 @@ sched_analyze_1 (x, insn)\n \t     seems like a reasonable number.  When compiling GCC with itself,\n \t     this flush occurs 8 times for sparc, and 10 times for m88k using\n \t     the number 32.  */\n-\t  flush_pending_lists (insn);\n+\t  flush_pending_lists (insn, 0);\n \t}\n       else\n \t{\n@@ -1984,7 +1986,7 @@ sched_analyze_2 (x, insn)\n \t      }\n \t    reg_pending_sets_all = 1;\n \n-\t    flush_pending_lists (insn);\n+\t    flush_pending_lists (insn, 0);\n \t  }\n \n \t/* For all ASM_OPERANDS, we must traverse the vector of input operands.\n@@ -2088,7 +2090,7 @@ sched_analyze_insn (x, insn, loop_notes)\n \t}\n       reg_pending_sets_all = 1;\n \n-      flush_pending_lists (insn);\n+      flush_pending_lists (insn, 0);\n \n       link = loop_notes;\n       while (XEXP (link, 1))\n@@ -2263,15 +2265,11 @@ sched_analyze (head, tail)\n \t  sched_analyze_insn (PATTERN (insn), insn, loop_notes);\n \t  loop_notes = 0;\n \n-\t  /* We don't need to flush memory for a function call which does\n-\t     not involve memory.  */\n-\t  if (! CONST_CALL_P (insn))\n-\t    {\n-\t      /* In the absence of interprocedural alias analysis,\n-\t\t we must flush all pending reads and writes, and\n-\t\t start new dependencies starting from here.  */\n-\t      flush_pending_lists (insn);\n-\t    }\n+\t  /* In the absence of interprocedural alias analysis, we must flush\n+\t     all pending reads and writes, and start new dependencies starting\n+\t     from here.  But only flush writes for constant calls (which may\n+\t     be passed a pointer to something we haven't written yet).  */\n+\t  flush_pending_lists (insn, CONST_CALL_P (insn));\n \n \t  /* Depend this function call (actually, the user of this\n \t     function call) on all hard register clobberage.  */"}]}