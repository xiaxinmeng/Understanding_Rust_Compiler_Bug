{"sha": "bb7ec730fe407f84e27c6e0e0cdcf71c0fe50c3a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmI3ZWM3MzBmZTQwN2Y4NGUyN2M2ZTBlMGNkY2Y3MWMwZmU1MGMzYQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2015-04-23T19:40:16Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2015-04-23T19:40:16Z"}, "message": "Revert:PR c++/50800\n\nRevert:PR c++/50800\n       * tree.c (strip_typedefs): Add remove_attributes parm.\n       (strip_typedefs_expr): Likewise.\n       (apply_identity_attributes): New subroutine of strip_typedefs.\n       * pt.c (canonicalize_type_argument): Let strip_typedefs handle attrs.\n       (convert_nontype_argument, unify): Likewise.\n       * cp-tree.h: Adjust.\n\nFrom-SVN: r222384", "tree": {"sha": "6dc602d1b04184377dd1acba5a3f7a5aa887860c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6dc602d1b04184377dd1acba5a3f7a5aa887860c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bb7ec730fe407f84e27c6e0e0cdcf71c0fe50c3a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb7ec730fe407f84e27c6e0e0cdcf71c0fe50c3a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb7ec730fe407f84e27c6e0e0cdcf71c0fe50c3a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb7ec730fe407f84e27c6e0e0cdcf71c0fe50c3a/comments", "author": null, "committer": null, "parents": [{"sha": "98ff5bf95936e741cdcbda61c279e12f05714993", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98ff5bf95936e741cdcbda61c279e12f05714993", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98ff5bf95936e741cdcbda61c279e12f05714993"}], "stats": {"total": 189, "additions": 53, "deletions": 136}, "files": [{"sha": "a463f66c18e02a27ec4c4804094dfda0c3444463", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb7ec730fe407f84e27c6e0e0cdcf71c0fe50c3a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb7ec730fe407f84e27c6e0e0cdcf71c0fe50c3a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=bb7ec730fe407f84e27c6e0e0cdcf71c0fe50c3a", "patch": "@@ -1,13 +1,5 @@\n 2015-04-23  Jason Merrill  <jason@redhat.com>\n \n-\tPR c++/50800\n-\t* tree.c (strip_typedefs): Add remove_attributes parm.\n-\t(strip_typedefs_expr): Likewise.\n-\t(apply_identity_attributes): New subroutine of strip_typedefs.\n-\t* pt.c (canonicalize_type_argument): Let strip_typedefs handle attrs.\n-\t(convert_nontype_argument, unify): Likewise.\n-\t* cp-tree.h: Adjust.\n-\n \tPR c++/65646\n \t* pt.c (check_explicit_specialization): Don't\n \tSET_DECL_TEMPLATE_SPECIALIZATION for a variable with no template"}, {"sha": "2a904a5f4f4d66e7647edfaacb3539b0987018c2", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb7ec730fe407f84e27c6e0e0cdcf71c0fe50c3a/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb7ec730fe407f84e27c6e0e0cdcf71c0fe50c3a/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=bb7ec730fe407f84e27c6e0e0cdcf71c0fe50c3a", "patch": "@@ -6066,8 +6066,8 @@ extern bool class_tmpl_impl_spec_p\t\t(const_tree);\n extern int zero_init_p\t\t\t\t(const_tree);\n extern bool check_abi_tag_redeclaration\t\t(const_tree, const_tree, const_tree);\n extern bool check_abi_tag_args\t\t\t(tree, tree);\n-extern tree strip_typedefs\t\t\t(tree, bool * = NULL);\n-extern tree strip_typedefs_expr\t\t\t(tree, bool * = NULL);\n+extern tree strip_typedefs\t\t\t(tree);\n+extern tree strip_typedefs_expr\t\t\t(tree);\n extern tree copy_binfo\t\t\t\t(tree, tree, tree,\n \t\t\t\t\t\t tree *, int);\n extern int member_p\t\t\t\t(const_tree);"}, {"sha": "f9a5c3b70c5bf0840039c6de781f5db995736548", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb7ec730fe407f84e27c6e0e0cdcf71c0fe50c3a/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb7ec730fe407f84e27c6e0e0cdcf71c0fe50c3a/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=bb7ec730fe407f84e27c6e0e0cdcf71c0fe50c3a", "patch": "@@ -6493,14 +6493,20 @@ template_template_parm_bindings_ok_p (tree tparms, tree targs)\n static tree\n canonicalize_type_argument (tree arg, tsubst_flags_t complain)\n {\n+  tree mv;\n   if (!arg || arg == error_mark_node || arg == TYPE_CANONICAL (arg))\n     return arg;\n-  bool removed_attributes = false;\n-  tree canon = strip_typedefs (arg, &removed_attributes);\n-  if (removed_attributes\n-      && (complain & tf_warning))\n-    warning (0, \"ignoring attributes on template argument %qT\", arg);\n-  return canon;\n+  mv = TYPE_MAIN_VARIANT (arg);\n+  arg = strip_typedefs (arg);\n+  if (TYPE_ALIGN (arg) != TYPE_ALIGN (mv)\n+      || TYPE_ATTRIBUTES (arg) != TYPE_ATTRIBUTES (mv))\n+    {\n+      if (complain & tf_warning)\n+\twarning (0, \"ignoring attributes on template argument %qT\", arg);\n+      arg = build_aligned_type (arg, TYPE_ALIGN (mv));\n+      arg = cp_build_type_attribute_variant (arg, TYPE_ATTRIBUTES (mv));\n+    }\n+  return arg;\n }\n \n /* Convert the indicated template ARG as necessary to match the\n@@ -6737,10 +6743,7 @@ convert_template_argument (tree parm,\n \t   argument specification is valid.  */\n \tval = convert_nontype_argument (t, orig_arg, complain);\n       else\n-\t{\n-\t  bool removed_attr = false;\n-\t  val = strip_typedefs_expr (orig_arg, &removed_attr);\n-\t}\n+\tval = strip_typedefs_expr (orig_arg);\n \n       if (val == NULL_TREE)\n \tval = error_mark_node;\n@@ -18199,10 +18202,7 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict,\n \t  && !TEMPLATE_PARM_PARAMETER_PACK (parm))\n \treturn unify_parameter_pack_mismatch (explain_p, parm, arg);\n \n-      {\n-\tbool removed_attr = false;\n-\targ = strip_typedefs_expr (arg, &removed_attr);\n-      }\n+      arg = strip_typedefs_expr (arg);\n       TREE_VEC_ELT (INNERMOST_TEMPLATE_ARGS (targs), idx) = arg;\n       return unify_success (explain_p);\n "}, {"sha": "9a4779f4a3c40321b8bf6c2b59a42cc103e6813a", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 32, "deletions": 99, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb7ec730fe407f84e27c6e0e0cdcf71c0fe50c3a/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb7ec730fe407f84e27c6e0e0cdcf71c0fe50c3a/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=bb7ec730fe407f84e27c6e0e0cdcf71c0fe50c3a", "patch": "@@ -55,7 +55,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-expr.h\"\n #include \"gimplify.h\"\n #include \"wide-int.h\"\n-#include \"attribs.h\"\n \n static tree bot_manip (tree *, int *, void *);\n static tree bot_replace (tree *, int *, void *);\n@@ -1176,52 +1175,6 @@ cv_unqualified (tree type)\n   return cp_build_qualified_type (type, quals);\n }\n \n-/* Subroutine of strip_typedefs.  We want to apply to RESULT the attributes\n-   from ATTRIBS that affect type identity, and no others.  If any are not\n-   applied, set *remove_attributes to true.  */\n-\n-static tree\n-apply_identity_attributes (tree result, tree attribs, bool *remove_attributes)\n-{\n-  tree first_ident = NULL_TREE;\n-  tree new_attribs = NULL_TREE;\n-  tree *p = &new_attribs;\n-\n-  for (tree a = TYPE_ATTRIBUTES (result); a; a = TREE_CHAIN (a))\n-    {\n-      const attribute_spec *as\n-\t= lookup_attribute_spec (get_attribute_name (a));\n-      if (as && as->affects_type_identity)\n-\t{\n-\t  if (!first_ident)\n-\t    first_ident = a;\n-\t  else if (first_ident == error_mark_node)\n-\t    {\n-\t      *p = tree_cons (TREE_PURPOSE (a), TREE_VALUE (a), NULL_TREE);\n-\t      p = &TREE_CHAIN (*p);\n-\t    }\n-\t}\n-      else if (first_ident)\n-\t{\n-\t  for (tree a2 = first_ident; a2; a2 = TREE_CHAIN (a2))\n-\t    {\n-\t      *p = tree_cons (TREE_PURPOSE (a2), TREE_VALUE (a2), NULL_TREE);\n-\t      p = &TREE_CHAIN (*p);\n-\t    }\n-\t  first_ident = error_mark_node;\n-\t}\n-    }\n-  if (first_ident != error_mark_node)\n-    new_attribs = first_ident;\n-\n-  if (first_ident == attribs)\n-    /* All attributes affected type identity.  */;\n-  else\n-    *remove_attributes = true;\n-\n-  return cp_build_type_attribute_variant (result, new_attribs);\n-}\n-\n /* Builds a qualified variant of T that is not a typedef variant.\n    E.g. consider the following declarations:\n      typedef const int ConstInt;\n@@ -1240,14 +1193,10 @@ apply_identity_attributes (tree result, tree attribs, bool *remove_attributes)\n     * If T is a type that needs structural equality\n       its TYPE_CANONICAL (T) will be NULL.\n     * TYPE_CANONICAL (T) desn't carry type attributes\n-      and loses template parameter names.\n-\n-   If REMOVE_ATTRIBUTES is non-null, also strip attributes that don't\n-   affect type identity, and set the referent to true if any were\n-   stripped.  */\n+      and loses template parameter names.   */\n \n tree\n-strip_typedefs (tree t, bool *remove_attributes)\n+strip_typedefs (tree t)\n {\n   tree result = NULL, type = NULL, t0 = NULL;\n \n@@ -1261,7 +1210,7 @@ strip_typedefs (tree t, bool *remove_attributes)\n       for (; t; t = TREE_CHAIN (t))\n \t{\n \t  gcc_assert (!TREE_PURPOSE (t));\n-\t  tree elt = strip_typedefs (TREE_VALUE (t), remove_attributes);\n+\t  tree elt = strip_typedefs (TREE_VALUE (t));\n \t  if (elt != TREE_VALUE (t))\n \t    changed = true;\n \t  vec_safe_push (vec, elt);\n@@ -1286,28 +1235,28 @@ strip_typedefs (tree t, bool *remove_attributes)\n   switch (TREE_CODE (t))\n     {\n     case POINTER_TYPE:\n-      type = strip_typedefs (TREE_TYPE (t), remove_attributes);\n+      type = strip_typedefs (TREE_TYPE (t));\n       result = build_pointer_type (type);\n       break;\n     case REFERENCE_TYPE:\n-      type = strip_typedefs (TREE_TYPE (t), remove_attributes);\n+      type = strip_typedefs (TREE_TYPE (t));\n       result = cp_build_reference_type (type, TYPE_REF_IS_RVALUE (t));\n       break;\n     case OFFSET_TYPE:\n-      t0 = strip_typedefs (TYPE_OFFSET_BASETYPE (t), remove_attributes);\n-      type = strip_typedefs (TREE_TYPE (t), remove_attributes);\n+      t0 = strip_typedefs (TYPE_OFFSET_BASETYPE (t));\n+      type = strip_typedefs (TREE_TYPE (t));\n       result = build_offset_type (t0, type);\n       break;\n     case RECORD_TYPE:\n       if (TYPE_PTRMEMFUNC_P (t))\n \t{\n-\t  t0 = strip_typedefs (TYPE_PTRMEMFUNC_FN_TYPE (t), remove_attributes);\n+\t  t0 = strip_typedefs (TYPE_PTRMEMFUNC_FN_TYPE (t));\n \t  result = build_ptrmemfunc_type (t0);\n \t}\n       break;\n     case ARRAY_TYPE:\n-      type = strip_typedefs (TREE_TYPE (t), remove_attributes);\n-      t0  = strip_typedefs (TYPE_DOMAIN (t), remove_attributes);\n+      type = strip_typedefs (TREE_TYPE (t));\n+      t0  = strip_typedefs (TYPE_DOMAIN (t));;\n       result = build_cplus_array_type (type, t0);\n       break;\n     case FUNCTION_TYPE:\n@@ -1320,8 +1269,7 @@ strip_typedefs (tree t, bool *remove_attributes)\n \t  {\n \t    if (arg_node == void_list_node)\n \t      break;\n-\t    arg_type = strip_typedefs (TREE_VALUE (arg_node),\n-\t\t\t\t       remove_attributes);\n+\t    arg_type = strip_typedefs (TREE_VALUE (arg_node));\n \t    gcc_assert (arg_type);\n \n \t    arg_types =\n@@ -1336,7 +1284,7 @@ strip_typedefs (tree t, bool *remove_attributes)\n \tif (arg_node)\n \t  arg_types = chainon (arg_types, void_list_node);\n \n-\ttype = strip_typedefs (TREE_TYPE (t), remove_attributes);\n+\ttype = strip_typedefs (TREE_TYPE (t));\n \tif (TREE_CODE (t) == METHOD_TYPE)\n \t  {\n \t    tree class_type = TREE_TYPE (TREE_VALUE (arg_types));\n@@ -1377,9 +1325,9 @@ strip_typedefs (tree t, bool *remove_attributes)\n \t\ttree arg = TREE_VEC_ELT (args, i);\n \t\ttree strip_arg;\n \t\tif (TYPE_P (arg))\n-\t\t  strip_arg = strip_typedefs (arg, remove_attributes);\n+\t\t  strip_arg = strip_typedefs (arg);\n \t\telse\n-\t\t  strip_arg = strip_typedefs_expr (arg, remove_attributes);\n+\t\t  strip_arg = strip_typedefs_expr (arg);\n \t\tTREE_VEC_ELT (new_args, i) = strip_arg;\n \t\tif (strip_arg != arg)\n \t\t  changed = true;\n@@ -1395,14 +1343,12 @@ strip_typedefs (tree t, bool *remove_attributes)\n \t    else\n \t      ggc_free (new_args);\n \t  }\n-\tresult = make_typename_type (strip_typedefs (TYPE_CONTEXT (t),\n-\t\t\t\t\t\t     remove_attributes),\n+\tresult = make_typename_type (strip_typedefs (TYPE_CONTEXT (t)),\n \t\t\t\t     fullname, typename_type, tf_none);\n       }\n       break;\n     case DECLTYPE_TYPE:\n-      result = strip_typedefs_expr (DECLTYPE_TYPE_EXPR (t),\n-\t\t\t\t    remove_attributes);\n+      result = strip_typedefs_expr (DECLTYPE_TYPE_EXPR (t));\n       if (result == DECLTYPE_TYPE_EXPR (t))\n \treturn t;\n       else\n@@ -1421,25 +1367,14 @@ strip_typedefs (tree t, bool *remove_attributes)\n       || TYPE_ALIGN (t) != TYPE_ALIGN (result))\n     {\n       gcc_assert (TYPE_USER_ALIGN (t));\n-      if (remove_attributes)\n-\t*remove_attributes = true;\n+      if (TYPE_ALIGN (t) == TYPE_ALIGN (result))\n+\tresult = build_variant_type_copy (result);\n       else\n-\t{\n-\t  if (TYPE_ALIGN (t) == TYPE_ALIGN (result))\n-\t    result = build_variant_type_copy (result);\n-\t  else\n-\t    result = build_aligned_type (result, TYPE_ALIGN (t));\n-\t  TYPE_USER_ALIGN (result) = true;\n-\t}\n+\tresult = build_aligned_type (result, TYPE_ALIGN (t));\n+      TYPE_USER_ALIGN (result) = true;\n     }\n   if (TYPE_ATTRIBUTES (t))\n-    {\n-      if (remove_attributes)\n-\tresult = apply_identity_attributes (result, TYPE_ATTRIBUTES (t),\n-\t\t\t\t\t    remove_attributes);\n-      else\n-\tresult = cp_build_type_attribute_variant (result, TYPE_ATTRIBUTES (t));\n-    }\n+    result = cp_build_type_attribute_variant (result, TYPE_ATTRIBUTES (t));\n   return cp_build_qualified_type (result, cp_type_quals (t));\n }\n \n@@ -1454,7 +1389,7 @@ strip_typedefs (tree t, bool *remove_attributes)\n    sizeof(TT) is replaced by sizeof(T).  */\n \n tree\n-strip_typedefs_expr (tree t, bool *remove_attributes)\n+strip_typedefs_expr (tree t)\n {\n   unsigned i,n;\n   tree r, type, *ops;\n@@ -1469,7 +1404,7 @@ strip_typedefs_expr (tree t, bool *remove_attributes)\n   /* Some expressions have type operands, so let's handle types here rather\n      than check TYPE_P in multiple places below.  */\n   if (TYPE_P (t))\n-    return strip_typedefs (t, remove_attributes);\n+    return strip_typedefs (t);\n \n   code = TREE_CODE (t);\n   switch (code)\n@@ -1483,8 +1418,8 @@ strip_typedefs_expr (tree t, bool *remove_attributes)\n \n     case TRAIT_EXPR:\n       {\n-\ttree type1 = strip_typedefs (TRAIT_EXPR_TYPE1 (t), remove_attributes);\n-\ttree type2 = strip_typedefs (TRAIT_EXPR_TYPE2 (t), remove_attributes);\n+\ttree type1 = strip_typedefs (TRAIT_EXPR_TYPE1 (t));\n+\ttree type2 = strip_typedefs (TRAIT_EXPR_TYPE2 (t));\n \tif (type1 == TRAIT_EXPR_TYPE1 (t)\n \t    && type2 == TRAIT_EXPR_TYPE2 (t))\n \t  return t;\n@@ -1501,7 +1436,7 @@ strip_typedefs_expr (tree t, bool *remove_attributes)\n \ttree it;\n \tfor (it = t; it; it = TREE_CHAIN (it))\n \t  {\n-\t    tree val = strip_typedefs_expr (TREE_VALUE (t), remove_attributes);\n+\t    tree val = strip_typedefs_expr (TREE_VALUE (t));\n \t    vec_safe_push (vec, val);\n \t    if (val != TREE_VALUE (t))\n \t      changed = true;\n@@ -1527,8 +1462,7 @@ strip_typedefs_expr (tree t, bool *remove_attributes)\n \tvec_safe_reserve (vec, n);\n \tfor (i = 0; i < n; ++i)\n \t  {\n-\t    tree op = strip_typedefs_expr (TREE_VEC_ELT (t, i),\n-\t\t\t\t\t   remove_attributes);\n+\t    tree op = strip_typedefs_expr (TREE_VEC_ELT (t, i));\n \t    vec->quick_push (op);\n \t    if (op != TREE_VEC_ELT (t, i))\n \t      changed = true;\n@@ -1553,18 +1487,17 @@ strip_typedefs_expr (tree t, bool *remove_attributes)\n \tvec<constructor_elt, va_gc> *vec\n \t  = vec_safe_copy (CONSTRUCTOR_ELTS (t));\n \tn = CONSTRUCTOR_NELTS (t);\n-\ttype = strip_typedefs (TREE_TYPE (t), remove_attributes);\n+\ttype = strip_typedefs (TREE_TYPE (t));\n \tfor (i = 0; i < n; ++i)\n \t  {\n \t    constructor_elt *e = &(*vec)[i];\n-\t    tree op = strip_typedefs_expr (e->value, remove_attributes);\n+\t    tree op = strip_typedefs_expr (e->value);\n \t    if (op != e->value)\n \t      {\n \t\tchanged = true;\n \t\te->value = op;\n \t      }\n-\t    gcc_checking_assert\n-\t      (e->index == strip_typedefs_expr (e->index, remove_attributes));\n+\t    gcc_checking_assert (e->index == strip_typedefs_expr (e->index));\n \t  }\n \n \tif (!changed && type == TREE_TYPE (t))\n@@ -1605,12 +1538,12 @@ strip_typedefs_expr (tree t, bool *remove_attributes)\n     case REINTERPRET_CAST_EXPR:\n     case CAST_EXPR:\n     case NEW_EXPR:\n-      type = strip_typedefs (type, remove_attributes);\n+      type = strip_typedefs (type);\n       /* fallthrough */\n \n     default:\n       for (i = 0; i < n; ++i)\n-\tops[i] = strip_typedefs_expr (TREE_OPERAND (t, i), remove_attributes);\n+\tops[i] = strip_typedefs_expr (TREE_OPERAND (t, i));\n       break;\n     }\n "}, {"sha": "2b8300bff6f2a254644013c24a047c63db853f36", "filename": "gcc/testsuite/g++.dg/abi/mangle40.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb7ec730fe407f84e27c6e0e0cdcf71c0fe50c3a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle40.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb7ec730fe407f84e27c6e0e0cdcf71c0fe50c3a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle40.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle40.C?ref=bb7ec730fe407f84e27c6e0e0cdcf71c0fe50c3a", "patch": "@@ -24,5 +24,5 @@ void f (T t) { }\t\t// { dg-warning \"mangled name\" }\n \n int main()\n {\n-  f (A<__v4sf>::t);\n+  f (A<__m128>::t);\n }"}, {"sha": "4833db852d3338acb560bbe5872e5a51da259579", "filename": "gcc/testsuite/g++.dg/ext/alias-canon2.C", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb7ec730fe407f84e27c6e0e0cdcf71c0fe50c3a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Falias-canon2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb7ec730fe407f84e27c6e0e0cdcf71c0fe50c3a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Falias-canon2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Falias-canon2.C?ref=bb7ec730fe407f84e27c6e0e0cdcf71c0fe50c3a", "patch": "@@ -31,3 +31,6 @@ out_long (ui64 longVal)\n         }\n     }\n }\n+\n+void f(ui32 *) { }\n+void f(ui32a *) { }"}, {"sha": "a7706e996d020704f4a96d62907c1b2f1fea8543", "filename": "gcc/testsuite/g++.dg/ext/alias-mangle.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb7ec730fe407f84e27c6e0e0cdcf71c0fe50c3a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Falias-mangle.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb7ec730fe407f84e27c6e0e0cdcf71c0fe50c3a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Falias-mangle.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Falias-mangle.C?ref=bb7ec730fe407f84e27c6e0e0cdcf71c0fe50c3a", "patch": "@@ -8,4 +8,4 @@ template<typename> struct A\n   A();\n };\n \n-A<X> a;\t       // { dg-warning \"ignoring attributes on template argument\" }\n+A<X> a;"}, {"sha": "9ff9918fb8039609e203e33043b9119bd98ad4ee", "filename": "gcc/testsuite/g++.dg/ext/attrib50.C", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98ff5bf95936e741cdcbda61c279e12f05714993/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattrib50.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98ff5bf95936e741cdcbda61c279e12f05714993/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattrib50.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattrib50.C?ref=98ff5bf95936e741cdcbda61c279e12f05714993", "patch": "@@ -1,11 +0,0 @@\n-// PR c++/50800\n-\n-template <typename T> struct B;\n-template <typename T> struct B<T &> {\n-  typedef T type;\n-};\n-struct A {\n-  typedef int TA __attribute__((__may_alias__));\n-};\n-void d() { B<int &> b; }\n-int main() { B<A::TA &> b; }\t// { dg-warning \"attributes\" }"}]}