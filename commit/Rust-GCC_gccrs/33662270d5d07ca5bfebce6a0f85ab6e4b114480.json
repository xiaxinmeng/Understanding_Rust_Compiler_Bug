{"sha": "33662270d5d07ca5bfebce6a0f85ab6e4b114480", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzM2NjIyNzBkNWQwN2NhNWJmZWJjZTZhMGY4NWFiNmU0YjExNDQ4MA==", "commit": {"author": {"name": "Rafael Avila de Espindola", "email": "espindola@google.com", "date": "2009-10-16T15:25:13Z"}, "committer": {"name": "Rafael Espindola", "email": "espindola@gcc.gnu.org", "date": "2009-10-16T15:25:13Z"}, "message": "lto-plugin.c (message): New variable.\n\n2009-10-16  Rafael Avila de Espindola  <espindola@google.com>\n\n\t* lto-plugin.c (message): New variable.\n\t(check): New function.\n\t(parse_table_entry, translate, write_resolution,add_output_files,\n\texec_lto_wrapper,claim_file_handler, onload): Use check instead of\n\tassert.\n\t(cleanup_handler): Use check instead of assert. Remove the arguments\n\tfile if it exists.\n\nFrom-SVN: r152906", "tree": {"sha": "447e910213fb168c38d8507a0130d335cdab03a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/447e910213fb168c38d8507a0130d335cdab03a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/33662270d5d07ca5bfebce6a0f85ab6e4b114480", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33662270d5d07ca5bfebce6a0f85ab6e4b114480", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33662270d5d07ca5bfebce6a0f85ab6e4b114480", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33662270d5d07ca5bfebce6a0f85ab6e4b114480/comments", "author": null, "committer": null, "parents": [{"sha": "2ced58ea6f4e381fa5f5eea061a1438cbff63f25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ced58ea6f4e381fa5f5eea061a1438cbff63f25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ced58ea6f4e381fa5f5eea061a1438cbff63f25"}], "stats": {"total": 117, "additions": 84, "deletions": 33}, "files": [{"sha": "01d7f4c87da262b3e9f28ab7cfc445d4885d993e", "filename": "lto-plugin/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33662270d5d07ca5bfebce6a0f85ab6e4b114480/lto-plugin%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33662270d5d07ca5bfebce6a0f85ab6e4b114480/lto-plugin%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/lto-plugin%2FChangeLog?ref=33662270d5d07ca5bfebce6a0f85ab6e4b114480", "patch": "@@ -1,3 +1,13 @@\n+2009-10-16  Rafael Avila de Espindola  <espindola@google.com>\n+\n+\t* lto-plugin.c (message): New variable.\n+\t(check): New function.\n+\t(parse_table_entry, translate, write_resolution,add_output_files,\n+\texec_lto_wrapper,claim_file_handler, onload): Use check instead of\n+\tassert.\n+\t(cleanup_handler): Use check instead of assert. Remove the arguments\n+\tfile if it exists.\n+\n 2009-10-15  Rafael Avila de Espindola  <espindola@google.com>\n \n \t* lto-plugin.c (resolution_file): New."}, {"sha": "0cf1ab4ec6902e62c9ff5f79d9d24683921f8b13", "filename": "lto-plugin/lto-plugin.c", "status": "modified", "additions": 74, "deletions": 33, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33662270d5d07ca5bfebce6a0f85ab6e4b114480/lto-plugin%2Flto-plugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33662270d5d07ca5bfebce6a0f85ab6e4b114480/lto-plugin%2Flto-plugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/lto-plugin%2Flto-plugin.c?ref=33662270d5d07ca5bfebce6a0f85ab6e4b114480", "patch": "@@ -82,6 +82,7 @@ static ld_plugin_get_symbols get_symbols;\n static ld_plugin_register_cleanup register_cleanup;\n static ld_plugin_add_input_file add_input_file;\n static ld_plugin_add_input_library add_input_library;\n+static ld_plugin_message message;\n \n static struct plugin_file_info *claimed_files = NULL;\n static unsigned int num_claimed_files = 0;\n@@ -99,6 +100,23 @@ static bool debug;\n static bool nop;\n static char *resolution_file = NULL;\n \n+static void\n+check (bool gate, enum ld_plugin_level level, const char *text)\n+{\n+  if (gate)\n+    return;\n+\n+  if (message)\n+    message (level, text);\n+  else\n+    {\n+      /* If there is no nicer way to inform the user, fallback to stderr. */\n+      fprintf (stderr, \"%s\\n\", text);\n+      if (level == LDPL_FATAL)\n+\tabort ();\n+    }\n+}\n+\n /* Parse an entry of the IL symbol table. The data to be parsed is pointed\n    by P and the result is written in ENTRY. The slot number is stored in SLOT.\n    Returns the address of the next entry. */\n@@ -142,12 +160,12 @@ parse_table_entry (char *p, struct ld_plugin_symbol *entry, uint32_t *slot)\n     entry->comdat_key = strdup (entry->comdat_key);\n \n   t = *p;\n-  assert (t <= 4);\n+  check (t <= 4, LDPL_FATAL, \"invalid symbol kind found\");\n   entry->def = translate_kind[t];\n   p++;\n \n   t = *p;\n-  assert (t <= 3);\n+  check (t <= 3, LDPL_FATAL, \"invalid symbol visibility found\");\n   entry->visibility = translate_visibility[t];\n   p++;\n \n@@ -218,9 +236,9 @@ translate (Elf_Data *symtab, struct plugin_symtab *out)\n     {\n       n++;\n       syms = realloc (syms, n * sizeof (struct ld_plugin_symbol));\n-      assert (syms);\n+      check (syms, LDPL_FATAL, \"could not allocate memory\");\n       slots = realloc (slots, n * sizeof (uint32_t));\n-      assert (slots);\n+      check (slots, LDPL_FATAL, \"could not allocate memory\");\n       data = parse_table_entry (data, &syms[n - 1], &slots[n - 1]);\n     }\n \n@@ -297,7 +315,7 @@ write_resolution (void)\n     return;\n \n   f = fopen (resolution_file, \"w\");\n-  assert (f);\n+  check (f, LDPL_FATAL, \"could not open file\");\n \n   fprintf (f, \"%d\\n\", num_claimed_files);\n \n@@ -329,7 +347,7 @@ write_resolution (void)\n static void\n add_output_files (FILE *f)\n {\n-  char fname[1000]; /* FIXME: Is this big enough? */\n+  char fname[1000]; /* FIXME: Remove this restriction. */\n \n   for (;;)\n     {\n@@ -339,7 +357,7 @@ add_output_files (FILE *f)\n \tbreak;\n \n       len = strlen (s);\n-      assert (s[len - 1] == '\\n');\n+      check (s[len - 1] == '\\n', LDPL_FATAL, \"file name too long\");\n       s[len - 1] = '\\0';\n \n       num_output_files++;\n@@ -367,16 +385,16 @@ exec_lto_wrapper (char *argv[])\n \n   /* Write argv to a file to avoid a command line that is too long. */\n   t = asprintf (&at_args, \"@%s/arguments\", temp_obj_dir_name);\n-  assert (t >= 0);\n+  check (t >= 0, LDPL_FATAL, \"asprintf failed\");\n \n   args_name = at_args + 1;\n   args = fopen (args_name, \"w\");\n-  assert (args);\n+  check (args, LDPL_FATAL, \"could not open arguments file\");\n \n   t = writeargv (&argv[1], args);\n-  assert (t == 0);\n+  check (t == 0, LDPL_FATAL, \"could not write arguments\");\n   t = fclose (args);\n-  assert (t == 0);\n+  check (t == 0, LDPL_FATAL, \"could not close arguments file\");\n \n   new_argv[0] = argv[0];\n   new_argv[1] = at_args;\n@@ -392,25 +410,26 @@ exec_lto_wrapper (char *argv[])\n \n \n   pex = pex_init (PEX_USE_PIPES, \"lto-wrapper\", NULL);\n-  assert (pex != NULL);\n+  check (pex != NULL, LDPL_FATAL, \"could not pex_init lto-wrapper\");\n \n   errmsg = pex_run (pex, 0, new_argv[0], new_argv, NULL, NULL, &t);\n-  assert (errmsg == NULL);\n-  assert (t == 0);\n+  check (errmsg == NULL, LDPL_FATAL, \"could not run lto-wrapper\");\n+  check (t == 0, LDPL_FATAL, \"could not run lto-wrapper\");\n \n   wrapper_output = pex_read_output (pex, 0);\n-  assert (wrapper_output);\n+  check (wrapper_output, LDPL_FATAL, \"could not read lto-wrapper output\");\n \n   add_output_files (wrapper_output);\n \n   t = pex_get_status (pex, 1, &status);\n-  assert (t == 1);\n-  assert (WIFEXITED (status) && WEXITSTATUS (status) == 0);\n+  check (t == 1, LDPL_FATAL, \"could not get lto-wrapper exit status\");\n+  check (WIFEXITED (status) && WEXITSTATUS (status) == 0, LDPL_FATAL,\n+         \"lto-wrapper failed\");\n \n   pex_free (pex);\n \n   t = unlink (args_name);\n-  assert (t == 0);\n+  check (t == 0, LDPL_FATAL, \"could not unlink arguments file\");\n   free (at_args);\n }\n \n@@ -493,20 +512,36 @@ all_symbols_read_handler (void)\n static enum ld_plugin_status\n cleanup_handler (void)\n {\n+  /* Note: we cannot use LDPL_FATAL in here as that would produce\n+     an infinite loop. */\n   int t;\n   unsigned i;\n+  char *arguments;\n+  struct stat buf;\n \n   for (i = 0; i < num_claimed_files; i++)\n     {\n       struct plugin_file_info *info = &claimed_files[i];\n       if (info->temp)\n \t{\n \t  t = unlink (info->name);\n-\t  assert (t == 0);\n+\t  check (t == 0, LDPL_ERROR, \"could not unlink temporary file\");\n \t}\n     }\n+\n+  /* If we are being called from an error handler, it is possible\n+     that the arguments file is still exists. */\n+  t = asprintf (&arguments, \"%s/arguments\", temp_obj_dir_name);\n+  check (t >= 0, LDPL_ERROR, \"asprintf failed\");\n+  if (stat(arguments, &buf) == 0)\n+    {\n+      t = unlink (arguments);\n+      check (t == 0, LDPL_ERROR, \"could not unlink arguments file\");\n+    }\n+  free (arguments);\n+\n   t = rmdir (temp_obj_dir_name);\n-  assert (t == 0);\n+  check (t == 0, LDPL_ERROR, \"could not remove temporary directory\");\n \n   free_2 ();\n   return LDPS_OK;\n@@ -535,21 +570,21 @@ claim_file_handler (const struct ld_plugin_input_file *file, int *claimed)\n       char *objname;\n       int t = asprintf (&objname, \"%s/obj%d.o\",\n \t\t\ttemp_obj_dir_name, objnum);\n-      assert (t >= 0);\n+      check (t >= 0, LDPL_FATAL, \"asprintf failed\");\n       objnum++;\n \n       fd = open (objname, O_RDWR | O_CREAT, 0666);\n-      assert (fd > 0);\n+      check (fd > 0, LDPL_FATAL, \"could not open/create temporary file\");\n       offset = lseek (file->fd, file->offset, SEEK_SET);\n-      assert (offset == file->offset);\n+      check (offset == file->offset, LDPL_FATAL, \"could not seek\");\n       while (size > 0)\n \t{\n \t  ssize_t r, written;\n \t  char buf[1000];\n \t  off_t s = sizeof (buf) < size ? sizeof (buf) : size;\n \t  r = read (file->fd, buf, s);\n \t  written = write (fd, buf, r);\n-\t  assert (written = r);\n+\t  check (written == r, LDPL_FATAL, \"could not write to temporary file\");\n \t  size -= r;\n \t}\n       lto_file.name = objname;\n@@ -579,7 +614,7 @@ claim_file_handler (const struct ld_plugin_input_file *file, int *claimed)\n \n   status = add_symbols (file->handle, lto_file.symtab.nsyms,\n \t\t\tlto_file.symtab.syms);\n-  assert (status == LDPS_OK);\n+  check (status == LDPS_OK, LDPL_FATAL, \"could not add symbols\");\n \n   *claimed = 1;\n   num_claimed_files++;\n@@ -594,7 +629,7 @@ claim_file_handler (const struct ld_plugin_input_file *file, int *claimed)\n   if (file->offset != 0)\n     {\n       int t = unlink (lto_file.name);\n-      assert (t == 0);\n+      check (t == 0, LDPL_FATAL, \"could not unlink file\");\n     }\n   free (lto_file.name);\n \n@@ -646,13 +681,16 @@ onload (struct ld_plugin_tv *tv)\n   char *t;\n \n   unsigned version = elf_version (EV_CURRENT);\n-  assert (version != EV_NONE);\n+  check (version != EV_NONE, LDPL_FATAL, \"invalid ELF version\");\n \n   p = tv;\n   while (p->tv_tag)\n     {\n       switch (p->tv_tag)\n \t{\n+        case LDPT_MESSAGE:\n+          message = p->tv_u.tv_message;\n+          break;\n \tcase LDPT_REGISTER_CLAIM_FILE_HOOK:\n \t  register_claim_file = p->tv_u.tv_register_claim_file;\n \t  break;\n@@ -683,22 +721,25 @@ onload (struct ld_plugin_tv *tv)\n       p++;\n     }\n \n-  assert (register_claim_file);\n-  assert (add_symbols);\n+  check (register_claim_file, LDPL_FATAL, \"register_claim_file not found\");\n+  check (add_symbols, LDPL_FATAL, \"add_symbols not found\");\n   status = register_claim_file (claim_file_handler);\n-  assert (status == LDPS_OK);\n+  check (status == LDPS_OK, LDPL_FATAL,\n+\t \"could not register the claim_file callback\");\n \n   if (register_cleanup)\n     {\n       status = register_cleanup (cleanup_handler);\n-      assert (status == LDPS_OK);\n+      check (status == LDPS_OK, LDPL_FATAL,\n+\t     \"could not register the cleanup callback\");\n     }\n \n   if (register_all_symbols_read)\n     {\n-      assert (get_symbols);\n+      check (get_symbols, LDPL_FATAL, \"get_symbols not found\");\n       status = register_all_symbols_read (all_symbols_read_handler);\n-      assert (status == LDPS_OK);\n+      check (status == LDPS_OK, LDPL_FATAL,\n+\t     \"could not register the all_symbols_read callback\");\n     }\n \n   temp_obj_dir_name = strdup (\"tmp_objectsXXXXXX\");"}]}