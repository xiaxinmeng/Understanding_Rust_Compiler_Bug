{"sha": "0c0efb33464ff07de3228fbc0cd658926e607e89", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGMwZWZiMzM0NjRmZjA3ZGUzMjI4ZmJjMGNkNjU4OTI2ZTYwN2U4OQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2009-04-09T08:26:01Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2009-04-09T08:26:01Z"}, "message": "except.c (find_prev_try): Break out from ....\n\n\t* except.c (find_prev_try): Break out from ....\n\t(duplicate_eh_regions): ... here; properly update prev_try pointers\n\twhen duplication part of tree.\n\t(dump_eh_tree): Improve dumping.\n\t(verify_eh_region): New.\n\t(verify_eh_tree): Use it.\n\nFrom-SVN: r145805", "tree": {"sha": "37e894253b44498fbcd4b28907481604b1dc042d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/37e894253b44498fbcd4b28907481604b1dc042d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0c0efb33464ff07de3228fbc0cd658926e607e89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c0efb33464ff07de3228fbc0cd658926e607e89", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c0efb33464ff07de3228fbc0cd658926e607e89", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c0efb33464ff07de3228fbc0cd658926e607e89/comments", "author": null, "committer": null, "parents": [{"sha": "3c25856afeb80abfd75bdefaf77277f477cba7f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c25856afeb80abfd75bdefaf77277f477cba7f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c25856afeb80abfd75bdefaf77277f477cba7f3"}], "stats": {"total": 166, "additions": 149, "deletions": 17}, "files": [{"sha": "7433c61f6d90f9465b1a248c5cc37f0c787eeea9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c0efb33464ff07de3228fbc0cd658926e607e89/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c0efb33464ff07de3228fbc0cd658926e607e89/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0c0efb33464ff07de3228fbc0cd658926e607e89", "patch": "@@ -1,3 +1,12 @@\n+2009-04-09  Jan Hubicka  <jh@suse.cz>\n+\n+\t* except.c (find_prev_try): Break out from ....\n+\t(duplicate_eh_regions): ... here; properly update prev_try pointers\n+\twhen duplication part of tree.\n+\t(dump_eh_tree): Improve dumping.\n+\t(verify_eh_region): New.\n+\t(verify_eh_tree): Use it.\n+\n 2009-04-06  Richard Guenther  <rguenther@suse.de>\n \n \t* c-gimplify.c (c_gimplify_expr): Fix the invalid GENERIC"}, {"sha": "a0a81bcecf890af6c97e653dfc4d4c756d3b6858", "filename": "gcc/except.c", "status": "modified", "additions": 140, "deletions": 17, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c0efb33464ff07de3228fbc0cd658926e607e89/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c0efb33464ff07de3228fbc0cd658926e607e89/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=0c0efb33464ff07de3228fbc0cd658926e607e89", "patch": "@@ -1033,6 +1033,23 @@ duplicate_eh_regions_1 (eh_region old, eh_region outer, int eh_offset)\n   return ret;\n }\n \n+/* Return prev_try pointers catch subregions of R should\n+   point to.  */\n+\n+static struct eh_region *\n+find_prev_try (struct eh_region * r)\n+{\n+  for (; r && r->type != ERT_TRY; r = r->outer)\n+    if (r->type == ERT_MUST_NOT_THROW\n+\t|| (r->type == ERT_ALLOWED_EXCEPTIONS\n+\t    && !r->u.allowed.type_list))\n+      {\n+\tr = NULL;\n+\tbreak;\n+      }\n+  return r;\n+}\n+\n /* Duplicate the EH regions of IFUN, rooted at COPY_REGION, into current\n    function and root the tree below OUTER_REGION.  Remap labels using MAP\n    callback.  The special case of COPY_REGION of 0 means all regions.  */\n@@ -1041,7 +1058,7 @@ int\n duplicate_eh_regions (struct function *ifun, duplicate_eh_regions_map map,\n \t\t      void *data, int copy_region, int outer_region)\n {\n-  eh_region cur, prev_try, outer, *splice;\n+  eh_region cur, prev_try, old_prev_try, outer, *splice;\n   int i, min_region, max_region, eh_offset, cfun_last_region_number;\n   int num_regions;\n \n@@ -1061,10 +1078,15 @@ duplicate_eh_regions (struct function *ifun, duplicate_eh_regions_map map,\n       max_region = 0;\n \n       cur = VEC_index (eh_region, ifun->eh->region_array, copy_region);\n+      old_prev_try = find_prev_try (cur);\n       duplicate_eh_regions_0 (cur, &min_region, &max_region);\n     }\n   else\n-    min_region = 1, max_region = ifun->eh->last_region_number;\n+    {\n+      min_region = 1;\n+      max_region = ifun->eh->last_region_number;\n+      old_prev_try = NULL;\n+    }\n   num_regions = max_region - min_region + 1;\n   cfun_last_region_number = cfun->eh->last_region_number;\n   eh_offset = cfun_last_region_number + 1 - min_region;\n@@ -1134,16 +1156,7 @@ duplicate_eh_regions (struct function *ifun, duplicate_eh_regions_map map,\n      the prev_try short-cuts for ERT_CLEANUP regions.  */\n   prev_try = NULL;\n   if (outer_region > 0)\n-    for (prev_try =\n-\t VEC_index (eh_region, cfun->eh->region_array, outer_region);\n-\t prev_try && prev_try->type != ERT_TRY; prev_try = prev_try->outer)\n-      if (prev_try->type == ERT_MUST_NOT_THROW\n-\t  || (prev_try->type == ERT_ALLOWED_EXCEPTIONS\n-\t      && !prev_try->u.allowed.type_list))\n-\t{\n-\t  prev_try = NULL;\n-\t  break;\n-\t}\n+    prev_try = find_prev_try (VEC_index (eh_region, cfun->eh->region_array, outer_region));\n \n   /* Remap all of the internal catch and cleanup linkages.  Since we \n      duplicate entire subtrees, all of the referenced regions will have\n@@ -1192,7 +1205,7 @@ duplicate_eh_regions (struct function *ifun, duplicate_eh_regions_map map,\n \t  break;\n \n \tcase ERT_CLEANUP:\n-\t  if (cur->u.cleanup.prev_try)\n+\t  if (cur->u.cleanup.prev_try != old_prev_try)\n \t    REMAP (cur->u.cleanup.prev_try);\n \t  else\n \t    cur->u.cleanup.prev_try = prev_try;\n@@ -3968,6 +3981,28 @@ dump_eh_tree (FILE * out, struct function *fun)\n \t  fprintf (out, \" tree_label:\");\n \t  print_generic_expr (out, i->tree_label, 0);\n \t}\n+      if (i->label)\n+\tfprintf (out, \" label:%i\", INSN_UID (i->label));\n+      if (i->landing_pad)\n+\t{\n+          fprintf (out, \" landing_pad:%i\", INSN_UID (i->landing_pad));\n+\t  if (GET_CODE (i->landing_pad) == NOTE)\n+\t    fprintf (out, \" (deleted)\");\n+        }\n+      if (i->post_landing_pad)\n+\t{\n+          fprintf (out, \" post_landing_pad:%i\", INSN_UID (i->post_landing_pad));\n+\t  if (GET_CODE (i->post_landing_pad) == NOTE)\n+\t    fprintf (out, \" (deleted)\");\n+\t}\n+      if (i->resume)\n+\t{\n+          fprintf (out, \" resume:%i\", INSN_UID (i->resume));\n+\t  if (GET_CODE (i->resume) == NOTE)\n+\t    fprintf (out, \" (deleted)\");\n+\t}\n+      if (i->may_contain_throw)\n+        fprintf (out, \" may_contain_throw\");\n       switch (i->type)\n \t{\n \tcase ERT_CLEANUP:\n@@ -3992,15 +4027,17 @@ dump_eh_tree (FILE * out, struct function *fun)\n \t  if (i->u.eh_catch.next_catch)\n \t    fprintf (out, \" next %i\",\n \t\t     i->u.eh_catch.next_catch->region_number);\n+\t  fprintf (out, \" type:\");\n+\t  print_generic_expr (out, i->u.eh_catch.type_list, 0);\n \t  break;\n \n \tcase ERT_ALLOWED_EXCEPTIONS:\n-\t  fprintf (out, \"filter :%i types:\", i->u.allowed.filter);\n+\t  fprintf (out, \" filter :%i types:\", i->u.allowed.filter);\n \t  print_generic_expr (out, i->u.allowed.type_list, 0);\n \t  break;\n \n \tcase ERT_THROW:\n-\t  fprintf (out, \"type:\");\n+\t  fprintf (out, \" type:\");\n \t  print_generic_expr (out, i->u.eh_throw.type, 0);\n \t  break;\n \n@@ -4039,8 +4076,90 @@ dump_eh_tree (FILE * out, struct function *fun)\n     }\n }\n \n-/* Verify some basic invariants on EH datastructures.  Could be extended to\n-   catch more.  */\n+/* Verify EH region invariants.  */\n+\n+static bool\n+verify_eh_region (struct eh_region *region, struct eh_region *prev_try)\n+{\n+  bool found = false;\n+  if (!region)\n+    return false;\n+  switch (region->type)\n+    {\n+    case ERT_CLEANUP:\n+      if (region->u.cleanup.prev_try != prev_try)\n+\t{\n+\t  error (\"Wrong prev_try pointer in EH region %i\",\n+\t\t region->region_number);\n+\t  found = true;\n+\t}\n+      break;\n+    case ERT_TRY:\n+      {\n+\tstruct eh_region *c, *prev = NULL;\n+\tif (region->u.eh_try.eh_catch->u.eh_catch.prev_catch)\n+\t  {\n+\t    error (\"Try region %i has wrong rh_catch pointer to %i\",\n+\t\t   region->region_number,\n+\t\t   region->u.eh_try.eh_catch->region_number);\n+\t    found = true;\n+\t  }\n+\tfor (c = region->u.eh_try.eh_catch; c; c = c->u.eh_catch.next_catch)\n+\t  {\n+\t    if (c->outer != region->outer)\n+\t      {\n+\t\terror\n+\t\t  (\"Catch region %i has different outer region than try region %i\",\n+\t\t   c->region_number, region->region_number);\n+\t\tfound = true;\n+\t      }\n+\t    if (c->u.eh_catch.prev_catch != prev)\n+\t      {\n+\t\terror (\"Catch region %i has corrupted catchlist\",\n+\t\t       c->region_number);\n+\t\tfound = true;\n+\t      }\n+\t    prev = c;\n+\t  }\n+\tif (prev != region->u.eh_try.last_catch)\n+\t  {\n+\t    error\n+\t      (\"Try region %i has wrong last_catch pointer to %i instead of %i\",\n+\t       region->region_number,\n+\t       region->u.eh_try.last_catch->region_number,\n+\t       prev->region_number);\n+\t    found = true;\n+\t  }\n+      }\n+      break;\n+    case ERT_CATCH:\n+      if (!region->u.eh_catch.prev_catch\n+          && (!region->next_peer || region->next_peer->type != ERT_TRY))\n+\t{\n+\t  error (\"Catch region %i should be followed by try\", region->region_number);\n+\t  found = true;\n+\t}\n+      break;\n+    case ERT_ALLOWED_EXCEPTIONS:\n+    case ERT_MUST_NOT_THROW:\n+    case ERT_THROW:\n+      break;\n+    case ERT_UNKNOWN:\n+      gcc_unreachable ();\n+    }\n+  if (region->type == ERT_TRY)\n+    prev_try = region;\n+  else if (region->type == ERT_MUST_NOT_THROW\n+\t   || (region->type == ERT_ALLOWED_EXCEPTIONS\n+\t       && !region->u.allowed.type_list))\n+    prev_try = NULL;\n+  for (region = region->inner; region; region = region->next_peer)\n+    found |= verify_eh_region (region, prev_try);\n+  return found;\n+}\n+\n+/* Verify invariants on EH datastructures.  */\n+\n void\n verify_eh_tree (struct function *fun)\n {\n@@ -4117,6 +4236,10 @@ verify_eh_tree (struct function *fun)\n \t\t      error (\"array does not match the region tree\");\n \t\t      err = true;\n \t\t    }\n+\t\t  if (!err)\n+\t\t    for (i = fun->eh->region_tree; i; i = i->next_peer)\n+\t\t      err |= verify_eh_region (i, NULL);\n+\t\t  \n \t\t  if (err)\n \t\t    {\n \t\t      dump_eh_tree (stderr, fun);"}]}