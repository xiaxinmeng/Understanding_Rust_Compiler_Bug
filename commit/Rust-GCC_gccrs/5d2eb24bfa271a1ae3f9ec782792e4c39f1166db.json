{"sha": "5d2eb24bfa271a1ae3f9ec782792e4c39f1166db", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWQyZWIyNGJmYTI3MWExYWUzZjllYzc4Mjc5MmU0YzM5ZjExNjZkYg==", "commit": {"author": {"name": "Ira Rosen", "email": "irar@il.ibm.com", "date": "2012-01-03T13:24:04Z"}, "committer": {"name": "Ira Rosen", "email": "irar@gcc.gnu.org", "date": "2012-01-03T13:24:04Z"}, "message": "re PR tree-optimization/51269 (Vectorization profitability threshold is not actually used)\n\n\n        PR tree-optimization/51269\n        * tree-vect-loop-manip.c (set_prologue_iterations): Make\n        first_niters a pointer.\n        (slpeel_tree_peel_loop_to_edge): Likewise.\n        (vect_do_peeling_for_loop_bound): Update call to\n        slpeel_tree_peel_loop_to_edge.\n        (vect_gen_niters_for_prolog_loop): Don't compute\n        wide_prolog_niters here.  Remove it from the parameters list.\n        (vect_do_peeling_for_alignment): Update calls and compute\n        wide_prolog_niters.\n\nFrom-SVN: r182844", "tree": {"sha": "551bda0fafa2e3b8047b99e28f3576dbabaf189a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/551bda0fafa2e3b8047b99e28f3576dbabaf189a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5d2eb24bfa271a1ae3f9ec782792e4c39f1166db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d2eb24bfa271a1ae3f9ec782792e4c39f1166db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d2eb24bfa271a1ae3f9ec782792e4c39f1166db", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d2eb24bfa271a1ae3f9ec782792e4c39f1166db/comments", "author": {"login": "irar2", "id": 16818592, "node_id": "MDQ6VXNlcjE2ODE4NTky", "avatar_url": "https://avatars.githubusercontent.com/u/16818592?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irar2", "html_url": "https://github.com/irar2", "followers_url": "https://api.github.com/users/irar2/followers", "following_url": "https://api.github.com/users/irar2/following{/other_user}", "gists_url": "https://api.github.com/users/irar2/gists{/gist_id}", "starred_url": "https://api.github.com/users/irar2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irar2/subscriptions", "organizations_url": "https://api.github.com/users/irar2/orgs", "repos_url": "https://api.github.com/users/irar2/repos", "events_url": "https://api.github.com/users/irar2/events{/privacy}", "received_events_url": "https://api.github.com/users/irar2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c3e85659f16f012074dc41ac48f520ad2334e589", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3e85659f16f012074dc41ac48f520ad2334e589", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3e85659f16f012074dc41ac48f520ad2334e589"}], "stats": {"total": 79, "additions": 48, "deletions": 31}, "files": [{"sha": "c6a5fb77dea58814c8d82cd6f4102aeb518aa3f9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d2eb24bfa271a1ae3f9ec782792e4c39f1166db/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d2eb24bfa271a1ae3f9ec782792e4c39f1166db/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5d2eb24bfa271a1ae3f9ec782792e4c39f1166db", "patch": "@@ -1,3 +1,16 @@\n+2012-01-03  Ira Rosen  <irar@il.ibm.com>\n+\n+\tPR tree-optimization/51269\n+\t* tree-vect-loop-manip.c (set_prologue_iterations): Make\n+\tfirst_niters a pointer.\n+\t(slpeel_tree_peel_loop_to_edge): Likewise.\n+\t(vect_do_peeling_for_loop_bound): Update call to\n+\tslpeel_tree_peel_loop_to_edge.\n+\t(vect_gen_niters_for_prolog_loop): Don't compute wide_prolog_niters\n+\there.  Remove it from the parameters list.\n+\t(vect_do_peeling_for_alignment): Update calls and compute\n+\twide_prolog_niters.\n+\n 2012-01-03  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/51070"}, {"sha": "7ac3f674ac952983199a3bd9fbd4ee81cac2425d", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 35, "deletions": 31, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d2eb24bfa271a1ae3f9ec782792e4c39f1166db/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d2eb24bfa271a1ae3f9ec782792e4c39f1166db/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=5d2eb24bfa271a1ae3f9ec782792e4c39f1166db", "patch": "@@ -1,5 +1,5 @@\n /* Vectorizer Specific Loop Manipulations\n-   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n+   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2012\n    Free Software Foundation, Inc.\n    Contributed by Dorit Naishlos <dorit@il.ibm.com>\n    and Ira Rosen <irar@il.ibm.com>\n@@ -1037,7 +1037,7 @@ slpeel_verify_cfg_after_peeling (struct loop *first_loop,\n \n static void\n set_prologue_iterations (basic_block bb_before_first_loop,\n-\t\t\t tree first_niters,\n+\t\t\t tree *first_niters,\n \t\t\t struct loop *loop,\n \t\t\t unsigned int th)\n {\n@@ -1100,9 +1100,9 @@ set_prologue_iterations (basic_block bb_before_first_loop,\n   newphi = create_phi_node (var, bb_before_first_loop);\n   add_phi_arg (newphi, prologue_after_cost_adjust_name, e_fallthru,\n \t       UNKNOWN_LOCATION);\n-  add_phi_arg (newphi, first_niters, e_false, UNKNOWN_LOCATION);\n+  add_phi_arg (newphi, *first_niters, e_false, UNKNOWN_LOCATION);\n \n-  first_niters = PHI_RESULT (newphi);\n+  *first_niters = PHI_RESULT (newphi);\n }\n \n /* Function slpeel_tree_peel_loop_to_edge.\n@@ -1158,7 +1158,7 @@ set_prologue_iterations (basic_block bb_before_first_loop,\n \n static struct loop*\n slpeel_tree_peel_loop_to_edge (struct loop *loop,\n-\t\t\t       edge e, tree first_niters,\n+\t\t\t       edge e, tree *first_niters,\n \t\t\t       tree niters, bool update_first_loop_count,\n \t\t\t       unsigned int th, bool check_profitability,\n \t\t\t       tree cond_expr, gimple_seq cond_expr_stmt_list)\n@@ -1328,8 +1328,8 @@ slpeel_tree_peel_loop_to_edge (struct loop *loop,\n   if (!update_first_loop_count)\n     {\n       pre_condition =\n-\tfold_build2 (LE_EXPR, boolean_type_node, first_niters,\n-\t\t     build_int_cst (TREE_TYPE (first_niters), 0));\n+\tfold_build2 (LE_EXPR, boolean_type_node, *first_niters,\n+\t\t     build_int_cst (TREE_TYPE (*first_niters), 0));\n       if (check_profitability)\n \t{\n \t  tree scalar_loop_iters\n@@ -1360,8 +1360,8 @@ slpeel_tree_peel_loop_to_edge (struct loop *loop,\n \t\t\t\t loop, th);\n \n       pre_condition =\n-\tfold_build2 (LE_EXPR, boolean_type_node, first_niters,\n-\t\t     build_int_cst (TREE_TYPE (first_niters), 0));\n+\tfold_build2 (LE_EXPR, boolean_type_node, *first_niters,\n+\t\t     build_int_cst (TREE_TYPE (*first_niters), 0));\n     }\n \n   skip_e = slpeel_add_loop_guard (bb_before_first_loop, pre_condition,\n@@ -1402,7 +1402,7 @@ slpeel_tree_peel_loop_to_edge (struct loop *loop,\n   bb_after_second_loop = split_edge (single_exit (second_loop));\n \n   pre_condition =\n-\tfold_build2 (EQ_EXPR, boolean_type_node, first_niters, niters);\n+\tfold_build2 (EQ_EXPR, boolean_type_node, *first_niters, niters);\n   skip_e = slpeel_add_loop_guard (bb_between_loops, pre_condition, NULL,\n                                   bb_after_second_loop, bb_before_first_loop);\n   slpeel_update_phi_nodes_for_guard2 (skip_e, second_loop,\n@@ -1411,7 +1411,7 @@ slpeel_tree_peel_loop_to_edge (struct loop *loop,\n   /* 4. Make first-loop iterate FIRST_NITERS times, if requested.\n    */\n   if (update_first_loop_count)\n-    slpeel_make_loop_iterate_ntimes (first_loop, first_niters);\n+    slpeel_make_loop_iterate_ntimes (first_loop, *first_niters);\n \n   BITMAP_FREE (definitions);\n   delete_update_ssa ();\n@@ -1925,7 +1925,7 @@ vect_do_peeling_for_loop_bound (loop_vec_info loop_vinfo, tree *ratio,\n     }\n \n   new_loop = slpeel_tree_peel_loop_to_edge (loop, single_exit (loop),\n-                                            ratio_mult_vf_name, ni_name, false,\n+                                            &ratio_mult_vf_name, ni_name, false,\n                                             th, check_profitability,\n \t\t\t\t\t    cond_expr, cond_expr_stmt_list);\n   gcc_assert (new_loop);\n@@ -1988,8 +1988,7 @@ vect_do_peeling_for_loop_bound (loop_vec_info loop_vinfo, tree *ratio,\n    use TYPE_VECTOR_SUBPARTS.  */\n \n static tree\n-vect_gen_niters_for_prolog_loop (loop_vec_info loop_vinfo, tree loop_niters,\n-\t\t\t\t tree *wide_prolog_niters)\n+vect_gen_niters_for_prolog_loop (loop_vec_info loop_vinfo, tree loop_niters)\n {\n   struct data_reference *dr = LOOP_VINFO_UNALIGNED_DR (loop_vinfo);\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n@@ -2073,19 +2072,6 @@ vect_gen_niters_for_prolog_loop (loop_vec_info loop_vinfo, tree loop_niters,\n   add_referenced_var (var);\n   stmts = NULL;\n   iters_name = force_gimple_operand (iters, &stmts, false, var);\n-  if (types_compatible_p (sizetype, niters_type))\n-    *wide_prolog_niters = iters_name;\n-  else\n-    {\n-      gimple_seq seq = NULL;\n-      tree wide_iters = fold_convert (sizetype, iters);\n-      var = create_tmp_var (sizetype, \"prolog_loop_niters\");\n-      add_referenced_var (var);\n-      *wide_prolog_niters = force_gimple_operand (wide_iters, &seq, false,\n-\t\t\t\t\t\t  var);\n-      if (seq)\n-\tgimple_seq_add_seq (&stmts, seq);\n-    }\n \n   /* Insert stmt on loop preheader edge.  */\n   if (stmts)\n@@ -2167,9 +2153,8 @@ vect_do_peeling_for_alignment (loop_vec_info loop_vinfo)\n   initialize_original_copy_tables ();\n \n   ni_name = vect_build_loop_niters (loop_vinfo, NULL);\n-  niters_of_prolog_loop = vect_gen_niters_for_prolog_loop (loop_vinfo, ni_name,\n-\t\t\t\t\t\t\t   &wide_prolog_niters);\n-\n+  niters_of_prolog_loop = vect_gen_niters_for_prolog_loop (loop_vinfo,\n+\t\t\t\t\t\t\t   ni_name);\n \n   /* Get profitability threshold for vectorized loop.  */\n   min_profitable_iters = LOOP_VINFO_COST_MODEL_MIN_ITERS (loop_vinfo);\n@@ -2179,7 +2164,7 @@ vect_do_peeling_for_alignment (loop_vec_info loop_vinfo)\n   /* Peel the prolog loop and iterate it niters_of_prolog_loop.  */\n   new_loop =\n     slpeel_tree_peel_loop_to_edge (loop, loop_preheader_edge (loop),\n-\t\t\t\t   niters_of_prolog_loop, ni_name, true,\n+\t\t\t\t   &niters_of_prolog_loop, ni_name, true,\n \t\t\t\t   th, true, NULL_TREE, NULL);\n \n   gcc_assert (new_loop);\n@@ -2192,6 +2177,25 @@ vect_do_peeling_for_alignment (loop_vec_info loop_vinfo)\n   LOOP_VINFO_NITERS (loop_vinfo) = fold_build2 (MINUS_EXPR,\n \t\tTREE_TYPE (n_iters), n_iters, niters_of_prolog_loop);\n \n+  if (types_compatible_p (sizetype, TREE_TYPE (niters_of_prolog_loop)))\n+    wide_prolog_niters = niters_of_prolog_loop;\n+  else\n+    {\n+      gimple_seq seq = NULL;\n+      edge pe = loop_preheader_edge (loop);\n+      tree wide_iters = fold_convert (sizetype, niters_of_prolog_loop);\n+      tree var = create_tmp_var (sizetype, \"prolog_loop_adjusted_niters\");\n+      add_referenced_var (var);\n+      wide_prolog_niters = force_gimple_operand (wide_iters, &seq, false,\n+                                                 var);\n+      if (seq)\n+\t{\n+\t  /* Insert stmt on loop preheader edge.  */\n+          basic_block new_bb = gsi_insert_seq_on_edge_immediate (pe, seq);\n+          gcc_assert (!new_bb);\n+        }\n+    }\n+\n   /* Update the init conditions of the access functions of all data refs.  */\n   vect_update_inits_of_drs (loop_vinfo, wide_prolog_niters);\n "}]}