{"sha": "2b2b6798119883d6cc535db15cc19baaae32bb49", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmIyYjY3OTgxMTk4ODNkNmNjNTM1ZGIxNWNjMTliYWFhZTMyYmI0OQ==", "commit": {"author": {"name": "Thomas Quinot", "email": "quinot@adacore.com", "date": "2008-03-26T07:41:04Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-03-26T07:41:04Z"}, "message": "sem_cat.adb (Validate_RACW_Primitives): Do not rely on Comes_From_Source to exclude primitives from being checked.\n\n2008-03-26  Thomas Quinot  <quinot@adacore.com>\n\n\t* sem_cat.adb (Validate_RACW_Primitives): Do not rely on\n\tComes_From_Source to exclude primitives from being checked. We want to\n\texclude predefined primitives only, so use the appropriate specific\n\tpredicate. Also, flag a formal parameter of an anonymous\n\taccess-to-subprogram type as illegal for a primitive operation of a\n\tremote access to class-wide type.\n\nFrom-SVN: r133572", "tree": {"sha": "b801c3ca3d42c4198be9bc589eb7146dccbbb102", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b801c3ca3d42c4198be9bc589eb7146dccbbb102"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2b2b6798119883d6cc535db15cc19baaae32bb49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b2b6798119883d6cc535db15cc19baaae32bb49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b2b6798119883d6cc535db15cc19baaae32bb49", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b2b6798119883d6cc535db15cc19baaae32bb49/comments", "author": null, "committer": null, "parents": [{"sha": "e96db982d28a0ff3ab6e80226c272a072eba9cb7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e96db982d28a0ff3ab6e80226c272a072eba9cb7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e96db982d28a0ff3ab6e80226c272a072eba9cb7"}], "stats": {"total": 84, "additions": 60, "deletions": 24}, "files": [{"sha": "b9dbfb18f949c13d46629232eac72d3efc2c7173", "filename": "gcc/ada/sem_cat.adb", "status": "modified", "additions": 60, "deletions": 24, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b2b6798119883d6cc535db15cc19baaae32bb49/gcc%2Fada%2Fsem_cat.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b2b6798119883d6cc535db15cc19baaae32bb49/gcc%2Fada%2Fsem_cat.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_cat.adb?ref=2b2b6798119883d6cc535db15cc19baaae32bb49", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -28,6 +28,7 @@ with Debug;    use Debug;\n with Einfo;    use Einfo;\n with Elists;   use Elists;\n with Errout;   use Errout;\n+with Exp_Util; use Exp_Util;\n with Fname;    use Fname;\n with Lib;      use Lib;\n with Namet;    use Namet;\n@@ -214,11 +215,26 @@ package body Sem_Cat is\n          --  Here we have an error\n \n          else\n-            if Is_Subunit then\n+            --  Don't give error if main unit is not an internal unit, and the\n+            --  unit generating the message is an internal unit. This is the\n+            --  situation in which such messages would be ignored in any case,\n+            --  so it is convenient not to generate them (since it causes\n+            --  annoying inteference with debugging)\n+\n+            if Is_Internal_File_Name (Unit_File_Name (Current_Sem_Unit))\n+              and then not Is_Internal_File_Name (Unit_File_Name (Main_Unit))\n+            then\n+               return;\n+\n+            --  Subunit case\n+\n+            elsif Is_Subunit then\n                Error_Msg_NE\n                  (\"<subunit cannot depend on& \" &\n                   \"(parent has wrong categorization)\", N, Depended_Entity);\n \n+            --  Normal unit, not subunit\n+\n             else\n                Error_Msg_NE\n                  (\"<cannot depend on& \" &\n@@ -660,8 +676,7 @@ package body Sem_Cat is\n             --  previous analysis.\n \n             if Nkind (PN) = N_Pragma then\n-\n-               case Get_Pragma_Id (Chars (PN)) is\n+               case Get_Pragma_Id (PN) is\n                   when Pragma_All_Calls_Remote   |\n                     Pragma_Preelaborate          |\n                     Pragma_Pure                  |\n@@ -1297,12 +1312,36 @@ package body Sem_Cat is\n       Primitive_Subprograms  : Elist_Id;\n       Subprogram_Elmt        : Elmt_Id;\n       Subprogram             : Entity_Id;\n-      Profile                : List_Id;\n       Param_Spec             : Node_Id;\n       Param                  : Entity_Id;\n       Param_Type             : Entity_Id;\n       Rtyp                   : Node_Id;\n \n+      procedure Illegal_RACW (Msg : String; N : Node_Id);\n+      --  Diagnose that T is illegal because of the given reason, associated\n+      --  with the location of node N.\n+\n+      Illegal_RACW_Message_Issued : Boolean := False;\n+      --  Set True once Illegal_RACW has been called\n+\n+      ------------------\n+      -- Illegal_RACW --\n+      ------------------\n+\n+      procedure Illegal_RACW (Msg : String; N : Node_Id) is\n+      begin\n+         if not Illegal_RACW_Message_Issued then\n+            Error_Msg_N\n+              (\"illegal remote access to class-wide type&\", T);\n+            Illegal_RACW_Message_Issued := True;\n+         end if;\n+\n+         Error_Msg_Sloc := Sloc (N);\n+         Error_Msg_N (\"\\\\\" & Msg & \" in primitive#\", T);\n+      end Illegal_RACW;\n+\n+   --  Start of processing for Validate_RACW_Primitives\n+\n    begin\n       Desig_Type := Etype (Designated_Type (T));\n \n@@ -1312,7 +1351,9 @@ package body Sem_Cat is\n       while Subprogram_Elmt /= No_Elmt loop\n          Subprogram := Node (Subprogram_Elmt);\n \n-         if not Comes_From_Source (Subprogram) then\n+         if Is_Predefined_Dispatching_Operation (Subprogram)\n+           or else Is_Hidden (Subprogram)\n+         then\n             goto Next_Subprogram;\n          end if;\n \n@@ -1325,15 +1366,14 @@ package body Sem_Cat is\n                null;\n \n             elsif Ekind (Rtyp) = E_Anonymous_Access_Type then\n-               Error_Msg_N\n-                 (\"anonymous access result in remote object primitive\", Rtyp);\n+               Illegal_RACW (\"anonymous access result\", Rtyp);\n \n             elsif Is_Limited_Type (Rtyp) then\n                if No (TSS (Rtyp, TSS_Stream_Read))\n                     or else\n                   No (TSS (Rtyp, TSS_Stream_Write))\n                then\n-                  Error_Msg_N\n+                  Illegal_RACW\n                     (\"limited return type must have Read and Write attributes\",\n                      Parent (Subprogram));\n                   Explain_Limited_Type (Rtyp, Parent (Subprogram));\n@@ -1342,16 +1382,12 @@ package body Sem_Cat is\n             end if;\n          end if;\n \n-         Profile := Parameter_Specifications (Parent (Subprogram));\n-\n-         --  Profile must exist, otherwise not primitive operation\n-\n-         Param_Spec := First (Profile);\n-         while Present (Param_Spec) loop\n+         Param := First_Formal (Subprogram);\n+         while Present (Param) loop\n \n             --  Now find out if this parameter is a controlling parameter\n \n-            Param      := Defining_Identifier (Param_Spec);\n+            Param_Spec := Parent (Param);\n             Param_Type := Etype (Param);\n \n             if Is_Controlling_Formal (Param) then\n@@ -1361,13 +1397,13 @@ package body Sem_Cat is\n \n                null;\n \n-            elsif Ekind (Param_Type) = E_Anonymous_Access_Type then\n-\n+            elsif Ekind (Param_Type) = E_Anonymous_Access_Type\n+              or else Ekind (Param_Type) = E_Anonymous_Access_Subprogram_Type\n+            then\n                --  From RM E.2.2(14), no access parameter other than\n                --  controlling ones may be used.\n \n-               Error_Msg_N\n-                 (\"non-controlling access parameter\", Param_Spec);\n+               Illegal_RACW (\"non-controlling access parameter\", Param_Spec);\n \n             elsif Is_Limited_Type (Param_Type) then\n \n@@ -1378,7 +1414,7 @@ package body Sem_Cat is\n                     or else\n                   No (TSS (Param_Type, TSS_Stream_Write))\n                then\n-                  Error_Msg_N\n+                  Illegal_RACW\n                     (\"limited formal must have Read and Write attributes\",\n                      Param_Spec);\n                   Explain_Limited_Type (Param_Type, Param_Spec);\n@@ -1387,7 +1423,7 @@ package body Sem_Cat is\n \n             --  Check next parameter in this subprogram\n \n-            Next (Param_Spec);\n+            Next_Formal (Param);\n          end loop;\n \n          <<Next_Subprogram>>\n@@ -1654,7 +1690,7 @@ package body Sem_Cat is\n          Error_Msg_N\n            (\"error in designated type of remote access to class-wide type\", T);\n          Error_Msg_N\n-           (\"\\must be tagged limited private or private extension of type\", T);\n+           (\"\\must be tagged limited private or private extension\", T);\n          return;\n       end if;\n \n@@ -1788,7 +1824,7 @@ package body Sem_Cat is\n             return;\n          end if;\n \n-         Error_Msg_N (\"incorrect remote type dereference\", N);\n+         Error_Msg_N (\"incorrect dereference of remote type\", N);\n       end if;\n    end Validate_Remote_Access_To_Class_Wide_Type;\n "}]}