{"sha": "bd11e37d6102fa1e90174e627a5f15e7975adc14", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmQxMWUzN2Q2MTAyZmExZTkwMTc0ZTYyN2E1ZjE1ZTc5NzVhZGMxNA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2008-08-29T18:52:22Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2008-08-29T18:52:22Z"}, "message": "dwarf2out.c (gen_const_die): New function.\n\n\t* dwarf2out.c (gen_const_die): New function.\n\t(size_of_die, value_format, output_die): Output larger\n\tdw_val_class_vec using DW_FORM_block2 or DW_FORM_block4.\n\t(native_encode_initializer): New function.\n\t(tree_add_const_value_attribute): Call it.\n\t(gen_decl_die, dwarf2out_decl): Handle CONST_DECLs if is_fortran ().\n\n\t* trans-decl.c (check_constant_initializer,\n\tgfc_emit_parameter_debug_info): New functions.\n\t(gfc_generate_module_vars, gfc_generate_function_code): Emit\n\tPARAMETERs and unreferenced variables with initializers into\n\tdebug info.\n\nFrom-SVN: r139781", "tree": {"sha": "e6a9d0c9f2245a2786df25f77a5899242d5389ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e6a9d0c9f2245a2786df25f77a5899242d5389ec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bd11e37d6102fa1e90174e627a5f15e7975adc14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd11e37d6102fa1e90174e627a5f15e7975adc14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd11e37d6102fa1e90174e627a5f15e7975adc14", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd11e37d6102fa1e90174e627a5f15e7975adc14/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9268ba9ad692f010dc8447c165404ac201d0a6d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9268ba9ad692f010dc8447c165404ac201d0a6d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9268ba9ad692f010dc8447c165404ac201d0a6d4"}], "stats": {"total": 367, "additions": 361, "deletions": 6}, "files": [{"sha": "09d5e1e2ee6bb107dbcec63f3617f4f447074b16", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd11e37d6102fa1e90174e627a5f15e7975adc14/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd11e37d6102fa1e90174e627a5f15e7975adc14/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bd11e37d6102fa1e90174e627a5f15e7975adc14", "patch": "@@ -1,5 +1,12 @@\n 2008-08-29  Jakub Jelinek  <jakub@redhat.com>\n \n+\t* dwarf2out.c (gen_const_die): New function.\n+\t(size_of_die, value_format, output_die): Output larger\n+\tdw_val_class_vec using DW_FORM_block2 or DW_FORM_block4.\n+\t(native_encode_initializer): New function.\n+\t(tree_add_const_value_attribute): Call it.\n+\t(gen_decl_die, dwarf2out_decl): Handle CONST_DECLs if is_fortran ().\n+\n \t* dwarf2out.c (gen_formal_parameter_die, gen_variable_die): For\n \tDECL_BY_REFERENCE decls don't pass TREE_READONLY and\n \tTREE_THIS_VOLATILE to add_type_attribute."}, {"sha": "deddf7e05ab8569febfe8da4f953545ee99f2867", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 217, "deletions": 6, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd11e37d6102fa1e90174e627a5f15e7975adc14/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd11e37d6102fa1e90174e627a5f15e7975adc14/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=bd11e37d6102fa1e90174e627a5f15e7975adc14", "patch": "@@ -5093,6 +5093,7 @@ static void gen_unspecified_parameters_die (tree, dw_die_ref);\n static void gen_formal_types_die (tree, dw_die_ref);\n static void gen_subprogram_die (tree, dw_die_ref);\n static void gen_variable_die (tree, dw_die_ref);\n+static void gen_const_die (tree, dw_die_ref);\n static void gen_label_die (tree, dw_die_ref);\n static void gen_lexical_block_die (tree, dw_die_ref, int);\n static void gen_inlined_subroutine_die (tree, dw_die_ref, int);\n@@ -7564,8 +7565,10 @@ size_of_die (dw_die_ref die)\n \t  size += 1 + 2*HOST_BITS_PER_LONG/HOST_BITS_PER_CHAR; /* block */\n \t  break;\n \tcase dw_val_class_vec:\n-\t  size += 1 + (a->dw_attr_val.v.val_vec.length\n-\t\t       * a->dw_attr_val.v.val_vec.elt_size); /* block */\n+\t  size += constant_size (a->dw_attr_val.v.val_vec.length\n+\t\t\t\t * a->dw_attr_val.v.val_vec.elt_size)\n+\t\t  + a->dw_attr_val.v.val_vec.length\n+\t\t    * a->dw_attr_val.v.val_vec.elt_size; /* block */\n \t  break;\n \tcase dw_val_class_flag:\n \t  size += 1;\n@@ -7764,7 +7767,18 @@ value_format (dw_attr_ref a)\n     case dw_val_class_long_long:\n       return DW_FORM_block1;\n     case dw_val_class_vec:\n-      return DW_FORM_block1;\n+      switch (constant_size (a->dw_attr_val.v.val_vec.length\n+\t\t\t     * a->dw_attr_val.v.val_vec.elt_size))\n+\t{\n+\tcase 1:\n+\t  return DW_FORM_block1;\n+\tcase 2:\n+\t  return DW_FORM_block2;\n+\tcase 4:\n+\t  return DW_FORM_block4;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n     case dw_val_class_flag:\n       return DW_FORM_flag;\n     case dw_val_class_die_ref:\n@@ -8056,7 +8070,8 @@ output_die (dw_die_ref die)\n \t    unsigned int i;\n \t    unsigned char *p;\n \n-\t    dw2_asm_output_data (1, len * elt_size, \"%s\", name);\n+\t    dw2_asm_output_data (constant_size (len * elt_size),\n+\t\t\t\t len * elt_size, \"%s\", name);\n \t    if (elt_size > sizeof (HOST_WIDE_INT))\n \t      {\n \t\telt_size /= 2;\n@@ -11762,6 +11777,150 @@ add_location_or_const_value_attribute (dw_die_ref die, tree decl,\n   tree_add_const_value_attribute (die, decl);\n }\n \n+/* Helper function for tree_add_const_value_attribute.  Natively encode\n+   initializer INIT into an array.  Return true if successful.  */\n+\n+static bool\n+native_encode_initializer (tree init, unsigned char *array, int size)\n+{\n+  tree type;\n+\n+  if (init == NULL_TREE)\n+    return false;\n+\n+  STRIP_NOPS (init);\n+  switch (TREE_CODE (init))\n+    {\n+    case STRING_CST:\n+      type = TREE_TYPE (init);\n+      if (TREE_CODE (type) == ARRAY_TYPE)\n+\t{\n+\t  tree enttype = TREE_TYPE (type);\n+\t  enum machine_mode mode = TYPE_MODE (enttype);\n+\n+\t  if (GET_MODE_CLASS (mode) != MODE_INT || GET_MODE_SIZE (mode) != 1)\n+\t    return false;\n+\t  if (int_size_in_bytes (type) != size)\n+\t    return false;\n+\t  if (size > TREE_STRING_LENGTH (init))\n+\t    {\n+\t      memcpy (array, TREE_STRING_POINTER (init),\n+\t\t      TREE_STRING_LENGTH (init));\n+\t      memset (array + TREE_STRING_LENGTH (init),\n+\t\t      '\\0', size - TREE_STRING_LENGTH (init));\n+\t    }\n+\t  else\n+\t    memcpy (array, TREE_STRING_POINTER (init), size);\n+\t  return true;\n+\t}\n+      return false;\n+    case CONSTRUCTOR:\n+      type = TREE_TYPE (init);\n+      if (int_size_in_bytes (type) != size)\n+\treturn false;\n+      if (TREE_CODE (type) == ARRAY_TYPE)\n+\t{\n+\t  HOST_WIDE_INT min_index;\n+\t  unsigned HOST_WIDE_INT cnt;\n+\t  int curpos = 0, fieldsize;\n+\t  constructor_elt *ce;\n+\n+\t  if (TYPE_DOMAIN (type) == NULL_TREE\n+\t      || !host_integerp (TYPE_MIN_VALUE (TYPE_DOMAIN (type)), 0))\n+\t    return false;\n+\n+\t  fieldsize = int_size_in_bytes (TREE_TYPE (type));\n+\t  if (fieldsize <= 0)\n+\t    return false;\n+\n+\t  min_index = tree_low_cst (TYPE_MIN_VALUE (TYPE_DOMAIN (type)), 0);\n+\t  memset (array, '\\0', size);\n+\t  for (cnt = 0;\n+\t       VEC_iterate (constructor_elt, CONSTRUCTOR_ELTS (init), cnt, ce);\n+\t       cnt++)\n+\t    {\n+\t      tree val = ce->value;\n+\t      tree index = ce->index;\n+\t      int pos = curpos;\n+\t      if (index && TREE_CODE (index) == RANGE_EXPR)\n+\t\tpos = (tree_low_cst (TREE_OPERAND (index, 0), 0) - min_index)\n+\t\t      * fieldsize;\n+\t      else if (index)\n+\t\tpos = tree_low_cst (index, 0) * fieldsize;\n+\n+\t      if (val)\n+\t\t{\n+\t\t  STRIP_NOPS (val);\n+\t\t  if (!native_encode_initializer (val, array + pos, fieldsize))\n+\t\t    return false;\n+\t\t}\n+\t      curpos = pos + fieldsize;\n+\t      if (index && TREE_CODE (index) == RANGE_EXPR)\n+\t\t{\n+\t\t  int count = tree_low_cst (TREE_OPERAND (index, 1), 0)\n+\t\t\t      - tree_low_cst (TREE_OPERAND (index, 0), 0);\n+\t\t  while (count > 0)\n+\t\t    {\n+\t\t      if (val)\n+\t\t\tmemcpy (array + curpos, array + pos, fieldsize);\n+\t\t      curpos += fieldsize;\n+\t\t    }\n+\t\t}\n+\t      gcc_assert (curpos <= size);\n+\t    }\n+\t  return true;\n+\t}\n+      else if (TREE_CODE (type) == RECORD_TYPE\n+\t       || TREE_CODE (type) == UNION_TYPE)\n+\t{\n+\t  tree field = NULL_TREE;\n+\t  unsigned HOST_WIDE_INT cnt;\n+\t  constructor_elt *ce;\n+\n+\t  if (int_size_in_bytes (type) != size)\n+\t    return false;\n+\n+\t  if (TREE_CODE (type) == RECORD_TYPE)\n+\t    field = TYPE_FIELDS (type);\n+\n+\t  for (cnt = 0;\n+\t       VEC_iterate (constructor_elt, CONSTRUCTOR_ELTS (init), cnt, ce);\n+\t       cnt++, field = field ? TREE_CHAIN (field) : 0)\n+\t    {\n+\t      tree val = ce->value;\n+\t      int pos, fieldsize;\n+\n+\t      if (ce->index != 0)\n+\t\tfield = ce->index;\n+\n+\t      if (val)\n+\t\tSTRIP_NOPS (val);\n+\n+\t      if (field == NULL_TREE || DECL_BIT_FIELD (field))\n+\t\treturn false;\n+\n+\t      if (TREE_CODE (TREE_TYPE (field)) == ARRAY_TYPE\n+\t\t  && TYPE_DOMAIN (TREE_TYPE (field))\n+\t\t  && ! TYPE_MAX_VALUE (TYPE_DOMAIN (TREE_TYPE (field))))\n+\t\treturn false;\n+\t      else if (DECL_SIZE_UNIT (field) == NULL_TREE\n+\t\t       || !host_integerp (DECL_SIZE_UNIT (field), 0))\n+\t\treturn false;\n+\t      fieldsize = tree_low_cst (DECL_SIZE_UNIT (field), 0);\n+\t      pos = int_byte_position (field);\n+\t      gcc_assert (pos + fieldsize <= size);\n+\t      if (val\n+\t\t  && !native_encode_initializer (val, array + pos, fieldsize))\n+\t\treturn false;\n+\t    }\n+\t  return true;\n+\t}\n+      return false;\n+    default:\n+      return native_encode_expr (init, array, size) == size;\n+    }\n+}\n+\n /* If we don't have a copy of this variable in memory for some reason (such\n    as a C++ member constant that doesn't have an out-of-line definition),\n    we should tell the debugger about the constant value.  */\n@@ -11781,6 +11940,19 @@ tree_add_const_value_attribute (dw_die_ref var_die, tree decl)\n   rtl = rtl_for_decl_init (init, type);\n   if (rtl)\n     add_const_value_attribute (var_die, rtl);\n+  /* If the host and target are sane, try harder.  */\n+  else if (CHAR_BIT == 8 && BITS_PER_UNIT == 8\n+\t   && initializer_constant_valid_p (init, type))\n+    {\n+      HOST_WIDE_INT size = int_size_in_bytes (TREE_TYPE (init));\n+      if (size > 0 && (int) size == size)\n+\t{\n+\t  unsigned char *array = GGC_CNEWVEC (unsigned char, size);\n+\n+\t  if (native_encode_initializer (init, array, size))\n+\t    add_AT_vec (var_die, DW_AT_const_value, size, 1, array);\n+\t}\n+    }\n }\n \n /* Convert the CFI instructions for the current function into a\n@@ -13743,6 +13915,24 @@ gen_variable_die (tree decl, dw_die_ref context_die)\n     tree_add_const_value_attribute (var_die, decl);\n }\n \n+/* Generate a DIE to represent a named constant.  */\n+\n+static void\n+gen_const_die (tree decl, dw_die_ref context_die)\n+{\n+  dw_die_ref const_die;\n+  tree type = TREE_TYPE (decl);\n+\n+  const_die = new_die (DW_TAG_constant, context_die, decl);\n+  add_name_and_src_coords_attributes (const_die, decl);\n+  add_type_attribute (const_die, type, 1, 0, context_die);\n+  if (TREE_PUBLIC (decl))\n+    add_AT_flag (const_die, DW_AT_external, 1);\n+  if (DECL_ARTIFICIAL (decl))\n+    add_AT_flag (const_die, DW_AT_artificial, 1);\n+  tree_add_const_value_attribute (const_die, decl);\n+}\n+\n /* Generate a DIE to represent a label identifier.  */\n \n static void\n@@ -14883,8 +15073,20 @@ gen_decl_die (tree decl, dw_die_ref context_die)\n       break;\n \n     case CONST_DECL:\n-      /* The individual enumerators of an enum type get output when we output\n-\t the Dwarf representation of the relevant enum type itself.  */\n+      if (!is_fortran ())\n+\t{\n+\t  /* The individual enumerators of an enum type get output when we output\n+\t     the Dwarf representation of the relevant enum type itself.  */\n+\t  break;\n+\t}\n+\n+      /* Emit its type.  */\n+      gen_type_die (TREE_TYPE (decl), context_die);\n+\n+      /* And its containing namespace.  */\n+      context_die = declare_in_namespace (decl, context_die);\n+\n+      gen_const_die (decl, context_die);\n       break;\n \n     case FUNCTION_DECL:\n@@ -15229,6 +15431,15 @@ dwarf2out_decl (tree decl)\n \treturn;\n       break;\n \n+    case CONST_DECL:\n+      if (debug_info_level <= DINFO_LEVEL_TERSE)\n+\treturn;\n+      if (!is_fortran ())\n+\treturn;\n+      if (TREE_STATIC (decl) && decl_function_context (decl))\n+\tcontext_die = lookup_decl_die (DECL_CONTEXT (decl));\n+      break;\n+\n     case NAMESPACE_DECL:\n       if (debug_info_level <= DINFO_LEVEL_TERSE)\n \treturn;"}, {"sha": "b509e576516f6d8c785ce433bf7b2c8d936da065", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd11e37d6102fa1e90174e627a5f15e7975adc14/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd11e37d6102fa1e90174e627a5f15e7975adc14/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=bd11e37d6102fa1e90174e627a5f15e7975adc14", "patch": "@@ -1,5 +1,11 @@\n 2008-08-29  Jakub Jelinek  <jakub@redhat.com>\n \n+\t* trans-decl.c (check_constant_initializer,\n+\tgfc_emit_parameter_debug_info): New functions.\n+\t(gfc_generate_module_vars, gfc_generate_function_code): Emit\n+\tPARAMETERs and unreferenced variables with initializers into\n+\tdebug info.\n+\n \t* gfortran.h (gfc_use_list): Add where field.\n \t* module.c (use_locus): New static variable.\n \t(gfc_match_use): Set it."}, {"sha": "c6128a6f48a62952ad83ea2e7781aa09256dbaea", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd11e37d6102fa1e90174e627a5f15e7975adc14/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd11e37d6102fa1e90174e627a5f15e7975adc14/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=bd11e37d6102fa1e90174e627a5f15e7975adc14", "patch": "@@ -3232,6 +3232,135 @@ gfc_trans_use_stmts (gfc_namespace * ns)\n }\n \n \n+/* Return true if expr is a constant initializer that gfc_conv_initializer\n+   will handle.  */\n+\n+static bool\n+check_constant_initializer (gfc_expr *expr, gfc_typespec *ts, bool array,\n+\t\t\t    bool pointer)\n+{\n+  gfc_constructor *c;\n+  gfc_component *cm;\n+\n+  if (pointer)\n+    return true;\n+  else if (array)\n+    {\n+      if (expr->expr_type == EXPR_CONSTANT || expr->expr_type == EXPR_NULL)\n+\treturn true;\n+      else if (expr->expr_type == EXPR_STRUCTURE)\n+\treturn check_constant_initializer (expr, ts, false, false);\n+      else if (expr->expr_type != EXPR_ARRAY)\n+\treturn false;\n+      for (c = expr->value.constructor; c; c = c->next)\n+\t{\n+\t  if (c->iterator)\n+\t    return false;\n+\t  if (c->expr->expr_type == EXPR_STRUCTURE)\n+\t    {\n+\t      if (!check_constant_initializer (c->expr, ts, false, false))\n+\t\treturn false;\n+\t    }\n+\t  else if (c->expr->expr_type != EXPR_CONSTANT)\n+\t    return false;\n+\t}\n+      return true;\n+    }\n+  else switch (ts->type)\n+    {\n+    case BT_DERIVED:\n+      if (expr->expr_type != EXPR_STRUCTURE)\n+\treturn false;\n+      cm = expr->ts.derived->components;\n+      for (c = expr->value.constructor; c; c = c->next, cm = cm->next)\n+\t{\n+\t  if (!c->expr || cm->attr.allocatable)\n+\t    continue;\n+\t  if (!check_constant_initializer (c->expr, &cm->ts,\n+\t\t\t\t\t   cm->attr.dimension,\n+\t\t\t\t\t   cm->attr.pointer))\n+\t    return false;\n+\t}\n+      return true;\n+    default:\n+      return expr->expr_type == EXPR_CONSTANT;\n+    }\n+}\n+\n+/* Emit debug info for parameters and unreferenced variables with\n+   initializers.  */\n+\n+static void\n+gfc_emit_parameter_debug_info (gfc_symbol *sym)\n+{\n+  tree decl;\n+\n+  if (sym->attr.flavor != FL_PARAMETER\n+      && (sym->attr.flavor != FL_VARIABLE || sym->attr.referenced))\n+    return;\n+\n+  if (sym->backend_decl != NULL\n+      || sym->value == NULL\n+      || sym->attr.use_assoc\n+      || sym->attr.dummy\n+      || sym->attr.result\n+      || sym->attr.function\n+      || sym->attr.intrinsic\n+      || sym->attr.pointer\n+      || sym->attr.allocatable\n+      || sym->attr.cray_pointee\n+      || sym->attr.threadprivate\n+      || sym->attr.is_bind_c\n+      || sym->attr.subref_array_pointer\n+      || sym->attr.assign)\n+    return;\n+\n+  if (sym->ts.type == BT_CHARACTER)\n+    {\n+      gfc_conv_const_charlen (sym->ts.cl);\n+      if (sym->ts.cl->backend_decl == NULL\n+\t  || TREE_CODE (sym->ts.cl->backend_decl) != INTEGER_CST)\n+\treturn;\n+    }\n+  else if (sym->ts.type == BT_DERIVED && sym->ts.derived->attr.alloc_comp)\n+    return;\n+\n+  if (sym->as)\n+    {\n+      int n;\n+\n+      if (sym->as->type != AS_EXPLICIT)\n+\treturn;\n+      for (n = 0; n < sym->as->rank; n++)\n+\tif (sym->as->lower[n]->expr_type != EXPR_CONSTANT\n+\t    || sym->as->upper[n] == NULL\n+\t    || sym->as->upper[n]->expr_type != EXPR_CONSTANT)\n+\t  return;\n+    }\n+\n+  if (!check_constant_initializer (sym->value, &sym->ts,\n+\t\t\t\t   sym->attr.dimension, false))\n+    return;\n+\n+  /* Create the decl for the variable or constant.  */\n+  decl = build_decl (sym->attr.flavor == FL_PARAMETER ? CONST_DECL : VAR_DECL,\n+\t\t     gfc_sym_identifier (sym), gfc_sym_type (sym));\n+  if (sym->attr.flavor == FL_PARAMETER)\n+    TREE_READONLY (decl) = 1;\n+  gfc_set_decl_location (decl, &sym->declared_at);\n+  if (sym->attr.dimension)\n+    GFC_DECL_PACKED_ARRAY (decl) = 1;\n+  DECL_CONTEXT (decl) = sym->ns->proc_name->backend_decl;\n+  TREE_STATIC (decl) = 1;\n+  TREE_USED (decl) = 1;\n+  if (DECL_CONTEXT (decl) && TREE_CODE (DECL_CONTEXT (decl)) == NAMESPACE_DECL)\n+    TREE_PUBLIC (decl) = 1;\n+  DECL_INITIAL (decl)\n+    = gfc_conv_initializer (sym->value, &sym->ts, TREE_TYPE (decl),\n+\t\t\t    sym->attr.dimension, 0);\n+  debug_hooks->global_decl (decl);\n+}\n+\n /* Generate all the required code for module variables.  */\n \n void\n@@ -3252,6 +3381,7 @@ gfc_generate_module_vars (gfc_namespace * ns)\n   cur_module = NULL;\n \n   gfc_trans_use_stmts (ns);\n+  gfc_traverse_ns (ns, gfc_emit_parameter_debug_info);\n }\n \n \n@@ -3787,6 +3917,7 @@ gfc_generate_function_code (gfc_namespace * ns)\n     }\n \n   gfc_trans_use_stmts (ns);\n+  gfc_traverse_ns (ns, gfc_emit_parameter_debug_info);\n }\n \n void"}]}