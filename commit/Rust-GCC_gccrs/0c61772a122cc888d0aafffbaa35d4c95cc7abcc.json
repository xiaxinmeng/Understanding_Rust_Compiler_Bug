{"sha": "0c61772a122cc888d0aafffbaa35d4c95cc7abcc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGM2MTc3MmExMjJjYzg4OGQwYWFmZmZiYWEzNWQ0Yzk1Y2M3YWJjYw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-04-20T10:40:48Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-04-20T10:40:48Z"}, "message": "[multiple changes]\n\n2016-04-20  Vincent Celier  <celier@adacore.com>\n\n\t* gnatcmd.adb: Do not invoke gprls when the invocation of \"gnat\n\tls\" includes the switch -V.\n\t* clean.adb: \"<target>-gnatclean -P\" now calls \"gprclean\n\t--target=<target>\"\n\t* make.adb: \"<target>-gnatmake -P\" now calls \"gprbuild\n\t--target=<target>\"\n\n2016-04-20  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_ch12.adb (Qualify_Type): Do not perform\n\tpartial qualification when the immediate scope is a generic unit.\n\nFrom-SVN: r235260", "tree": {"sha": "d453a67df3e66d1b84843f68fa59727adf489147", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d453a67df3e66d1b84843f68fa59727adf489147"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0c61772a122cc888d0aafffbaa35d4c95cc7abcc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c61772a122cc888d0aafffbaa35d4c95cc7abcc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c61772a122cc888d0aafffbaa35d4c95cc7abcc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c61772a122cc888d0aafffbaa35d4c95cc7abcc/comments", "author": null, "committer": null, "parents": [{"sha": "61d1b085b96c6f9aa6cc952e7161c4f0e41794c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61d1b085b96c6f9aa6cc952e7161c4f0e41794c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61d1b085b96c6f9aa6cc952e7161c4f0e41794c8"}], "stats": {"total": 731, "additions": 686, "deletions": 45}, "files": [{"sha": "dca79d9cdddb56673c832f224897576974e72753", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c61772a122cc888d0aafffbaa35d4c95cc7abcc/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c61772a122cc888d0aafffbaa35d4c95cc7abcc/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=0c61772a122cc888d0aafffbaa35d4c95cc7abcc", "patch": "@@ -1,3 +1,17 @@\n+2016-04-20  Vincent Celier  <celier@adacore.com>\n+\n+\t* gnatcmd.adb: Do not invoke gprls when the invocation of \"gnat\n+\tls\" includes the switch -V.\n+\t* clean.adb: \"<target>-gnatclean -P\" now calls \"gprclean\n+\t--target=<target>\"\n+\t* make.adb: \"<target>-gnatmake -P\" now calls \"gprbuild\n+\t--target=<target>\"\n+\n+2016-04-20  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_ch12.adb (Qualify_Type): Do not perform\n+\tpartial qualification when the immediate scope is a generic unit.\n+\n 2016-04-20  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* exp_unst.adb: Minor reformatting."}, {"sha": "615cc48c594a0d4f1ff44c6885b7d81436725597", "filename": "gcc/ada/clean.adb", "status": "modified", "additions": 37, "deletions": 20, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c61772a122cc888d0aafffbaa35d4c95cc7abcc/gcc%2Fada%2Fclean.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c61772a122cc888d0aafffbaa35d4c95cc7abcc/gcc%2Fada%2Fclean.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fclean.adb?ref=0c61772a122cc888d0aafffbaa35d4c95cc7abcc", "patch": "@@ -1619,8 +1619,8 @@ package body Clean is\n \n    procedure Parse_Cmd_Line is\n       Last         : constant Natural := Argument_Count;\n-      Source_Index : Int := 0;\n       Index        : Positive;\n+      Source_Index : Int := 0;\n \n       procedure Check_Version_And_Help is new Check_Version_And_Help_G (Usage);\n \n@@ -1629,16 +1629,29 @@ package body Clean is\n \n       Check_Version_And_Help (\"GNATCLEAN\", \"2003\");\n \n-      --  First, for native gnatclean, check for switch -P and, if found and\n-      --  gprclean is available, silently invoke gprclean.\n+      --  First, check for switch -P and, if found and gprclean is available,\n+      --  silently invoke gprclean, with switch --target if not on a native\n+      --  platform.\n \n-      Find_Program_Name;\n+      declare\n+         Arg_Len       : Positive      := Argument_Count;\n+         Call_Gprclean : Boolean       := False;\n+         Gprclean      : String_Access := null;\n+         Pos           : Natural       := 0;\n+         Success       : Boolean;\n+         Target        : String_Access := null;\n \n-      if Name_Buffer (1 .. Name_Len) = \"gnatclean\" then\n-         declare\n-            Call_Gprclean : Boolean := False;\n+      begin\n+         Find_Program_Name;\n+\n+         if Name_Len >= 9\n+           and then Name_Buffer (Name_Len - 8 .. Name_Len) = \"gnatclean\"\n+         then\n+            if Name_Len > 9 then\n+               Target  := new String'(Name_Buffer (1 .. Name_Len - 10));\n+               Arg_Len := Arg_Len + 1;\n+            end if;\n \n-         begin\n             for J in 1 .. Argument_Count loop\n                declare\n                   Arg : constant String := Argument (J);\n@@ -1653,16 +1666,20 @@ package body Clean is\n             end loop;\n \n             if Call_Gprclean then\n-               declare\n-                  Gprclean : String_Access :=\n-                               Locate_Exec_On_Path (Exec_Name => \"gprclean\");\n-                  Args     : Argument_List (1 .. Argument_Count);\n-                  Success  : Boolean;\n+               Gprclean := Locate_Exec_On_Path (Exec_Name => \"gprclean\");\n+\n+               if Gprclean /= null then\n+                  declare\n+                     Args : Argument_List (1 .. Arg_Len);\n+                  begin\n+                     if Target /= null then\n+                        Args (1) := new String'(\"--target=\" & Target.all);\n+                        Pos := 1;\n+                     end if;\n \n-               begin\n-                  if Gprclean /= null then\n                      for J in 1 .. Argument_Count loop\n-                        Args (J) := new String'(Argument (J));\n+                        Pos := Pos + 1;\n+                        Args (Pos) := new String'(Argument (J));\n                      end loop;\n \n                      Spawn (Gprclean.all, Args, Success);\n@@ -1672,11 +1689,11 @@ package body Clean is\n                      if Success then\n                         Exit_Program (E_Success);\n                      end if;\n-                  end if;\n-               end;\n+                  end;\n+               end if;\n             end if;\n-         end;\n-      end if;\n+         end if;\n+      end;\n \n       Index := 1;\n       while Index <= Last loop"}, {"sha": "2432f89f8f43022b83bcd5e3b2d7072d2a8f74ab", "filename": "gcc/ada/gnatcmd.adb", "status": "modified", "additions": 598, "deletions": 5, "changes": 603, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c61772a122cc888d0aafffbaa35d4c95cc7abcc/gcc%2Fada%2Fgnatcmd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c61772a122cc888d0aafffbaa35d4c95cc7abcc/gcc%2Fada%2Fgnatcmd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatcmd.adb?ref=0c61772a122cc888d0aafffbaa35d4c95cc7abcc", "patch": "@@ -23,19 +23,35 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Csets;\n with Gnatvsn;\n+with Makeutl;  use Makeutl;\n with Namet;    use Namet;\n with Opt;      use Opt;\n with Osint;    use Osint;\n+with Output;   use Output;\n+with Prj;      use Prj;\n+with Prj.Env;\n+with Prj.Ext;  use Prj.Ext;\n+with Prj.Pars;\n+with Prj.Tree; use Prj.Tree;\n+with Prj.Util; use Prj.Util;\n+with Sdefault;\n+with Sinput.P;\n+with Snames;   use Snames;\n+with Stringt;\n with Switch;   use Switch;\n with Table;\n with Targparm; use Targparm;\n+with Tempdir;\n+with Types;    use Types;\n \n with Ada.Characters.Handling; use Ada.Characters.Handling;\n with Ada.Command_Line;        use Ada.Command_Line;\n with Ada.Text_IO;             use Ada.Text_IO;\n \n-with GNAT.OS_Lib; use GNAT.OS_Lib;\n+with GNAT.Directory_Operations; use GNAT.Directory_Operations;\n+with GNAT.OS_Lib;               use GNAT.OS_Lib;\n \n procedure GNATCmd is\n    Gprbuild : constant String := \"gprbuild\";\n@@ -82,6 +98,25 @@ procedure GNATCmd is\n       Pp    => Pretty);\n    --  Mapping of alternate commands to commands\n \n+   Call_GPR_Tool : Boolean := False;\n+   --  True when a GPR tool should be called, if available\n+\n+   Project_Node_Tree : Project_Node_Tree_Ref;\n+   Project_File      : String_Access;\n+   Project           : Prj.Project_Id;\n+   Current_Verbosity : Prj.Verbosity := Prj.Default;\n+   Tool_Package_Name : Name_Id       := No_Name;\n+\n+   Project_Tree : constant Project_Tree_Ref :=\n+                    new Project_Tree_Data (Is_Root_Tree => True);\n+   --  The project tree\n+\n+   All_Projects : Boolean := False;\n+\n+   Temp_File_Name : Path_Name_Type := No_Path;\n+   --  The name of the temporary text file to put a list of source/object\n+   --  files to pass to a tool.\n+\n    package First_Switches is new Table.Table\n      (Table_Component_Type => String_Access,\n       Table_Index_Type     => Integer,\n@@ -222,16 +257,177 @@ procedure GNATCmd is\n          Unixsws  => null)\n      );\n \n+   subtype SA is String_Access;\n+\n+   Naming_String      : constant SA := new String'(\"naming\");\n+   Gnatls_String      : constant SA := new String'(\"gnatls\");\n+\n+   Packages_To_Check_By_Gnatls    : constant String_List_Access :=\n+     new String_List'((Naming_String, Gnatls_String));\n+\n+   Packages_To_Check : String_List_Access := Prj.All_Packages;\n+\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n \n+   procedure Check_Files;\n+   --  For GNAT LIST -V, check if a project file is specified, without any file\n+   --  arguments and without a switch -files=. If it is the case, invoke the\n+   --  GNAT tool with the proper list of files, derived from the sources of\n+   --  the project.\n+\n    procedure Output_Version;\n    --  Output the version of this program\n \n    procedure Usage;\n    --  Display usage\n \n+   -----------------\n+   -- Check_Files --\n+   -----------------\n+\n+   procedure Check_Files is\n+      Add_Sources : Boolean := True;\n+      Unit        : Prj.Unit_Index;\n+      Subunit     : Boolean := False;\n+      FD          : File_Descriptor := Invalid_FD;\n+      Status      : Integer;\n+      Success     : Boolean;\n+\n+      procedure Add_To_Response_File\n+        (File_Name  : String;\n+         Check_File : Boolean := True);\n+      --  Include the file name passed as parameter in the response file for\n+      --  the tool being called. If the response file can not be written then\n+      --  the file name is passed in the parameter list of the tool. If the\n+      --  Check_File parameter is True then the procedure verifies the\n+      --  existence of the file before adding it to the response file.\n+\n+      --------------------------\n+      -- Add_To_Response_File --\n+      --------------------------\n+\n+      procedure Add_To_Response_File\n+        (File_Name  : String;\n+         Check_File : Boolean := True)\n+      is\n+      begin\n+         Name_Len := 0;\n+\n+         Add_Str_To_Name_Buffer (File_Name);\n+\n+         if not Check_File or else\n+           Is_Regular_File (Name_Buffer (1 .. Name_Len))\n+         then\n+            if FD /= Invalid_FD then\n+               Name_Len := Name_Len + 1;\n+               Name_Buffer (Name_Len) := ASCII.LF;\n+\n+               Status := Write (FD, Name_Buffer (1)'Address, Name_Len);\n+\n+               if Status /= Name_Len then\n+                  Osint.Fail (\"disk full\");\n+               end if;\n+            else\n+               Last_Switches.Increment_Last;\n+               Last_Switches.Table (Last_Switches.Last) :=\n+                 new String'(File_Name);\n+            end if;\n+         end if;\n+      end Add_To_Response_File;\n+\n+   --  Start of processing for Check_Files\n+\n+   begin\n+      --  Check if there is at least one argument that is not a switch\n+\n+      for Index in 1 .. Last_Switches.Last loop\n+         if Last_Switches.Table (Index) (1) /= '-'\n+           or else (Last_Switches.Table (Index).all'Length > 7\n+                     and then Last_Switches.Table (Index) (1 .. 7) = \"-files=\")\n+         then\n+            Add_Sources := False;\n+            exit;\n+         end if;\n+      end loop;\n+\n+      --  If all arguments are switches and there is no switch -files=, add the\n+      --  path names of all the sources of the main project.\n+\n+      if Add_Sources then\n+         Tempdir.Create_Temp_File (FD, Temp_File_Name);\n+         Last_Switches.Increment_Last;\n+         Last_Switches.Table (Last_Switches.Last) :=\n+           new String'(\"-files=\" & Get_Name_String (Temp_File_Name));\n+\n+         Unit := Units_Htable.Get_First (Project_Tree.Units_HT);\n+         while Unit /= No_Unit_Index loop\n+\n+            --  We only need to put the library units, body or spec, but not\n+            --  the subunits.\n+\n+            if Unit.File_Names (Impl) /= null\n+              and then not Unit.File_Names (Impl).Locally_Removed\n+            then\n+               --  There is a body, check if it is for this project\n+\n+               if All_Projects\n+                 or else Unit.File_Names (Impl).Project = Project\n+               then\n+                  Subunit := False;\n+\n+                  if Unit.File_Names (Spec) = null\n+                    or else Unit.File_Names (Spec).Locally_Removed\n+                  then\n+                     --  We have a body with no spec: we need to check if\n+                     --  this is a subunit, because gnatls will complain\n+                     --  about subunits.\n+\n+                     declare\n+                        Src_Ind : constant Source_File_Index :=\n+                                    Sinput.P.Load_Project_File\n+                                      (Get_Name_String\n+                                         (Unit.File_Names (Impl).Path.Name));\n+                     begin\n+                        Subunit := Sinput.P.Source_File_Is_Subunit (Src_Ind);\n+                     end;\n+                  end if;\n+\n+                  if not Subunit then\n+                     Add_To_Response_File\n+                       (Get_Name_String (Unit.File_Names (Impl).Display_File),\n+                        Check_File => False);\n+                  end if;\n+               end if;\n+\n+            elsif Unit.File_Names (Spec) /= null\n+              and then not Unit.File_Names (Spec).Locally_Removed\n+            then\n+               --  We have a spec with no body. Check if it is for this project\n+\n+               if All_Projects\n+                 or else Unit.File_Names (Spec).Project = Project\n+               then\n+                  Add_To_Response_File\n+                    (Get_Name_String (Unit.File_Names (Spec).Display_File),\n+                     Check_File => False);\n+               end if;\n+            end if;\n+\n+            Unit := Units_Htable.Get_Next (Project_Tree.Units_HT);\n+         end loop;\n+\n+         if FD /= Invalid_FD then\n+            Close (FD, Success);\n+\n+            if not Success then\n+               Osint.Fail (\"disk full\");\n+            end if;\n+         end if;\n+      end if;\n+   end Check_Files;\n+\n    --------------------\n    -- Output_Version --\n    --------------------\n@@ -293,8 +489,23 @@ procedure GNATCmd is\n --  Start of processing for GNATCmd\n \n begin\n+   --  All output from GNATCmd is debugging or error output: send to stderr\n+\n+   Set_Standard_Error;\n+\n    --  Initializations\n \n+   Csets.Initialize;\n+   Snames.Initialize;\n+   Stringt.Initialize;\n+\n+   Prj.Tree.Initialize (Root_Environment, Gnatmake_Flags);\n+\n+   Project_Node_Tree := new Project_Node_Tree_Data;\n+   Prj.Tree.Initialize (Project_Node_Tree);\n+\n+   Prj.Initialize (Project_Tree);\n+\n    Last_Switches.Init;\n    Last_Switches.Set_Last (0);\n \n@@ -485,21 +696,27 @@ begin\n            or else The_Command = List\n          then\n             declare\n-               Project_File_Used : Boolean := False;\n                Switch            : String_Access;\n+               Dash_V_Switch     : constant String := \"-V\";\n \n             begin\n                for J in 1 .. Last_Switches.Last loop\n                   Switch := Last_Switches.Table (J);\n+\n+                  if The_Command = List and then Switch.all = Dash_V_Switch\n+                  then\n+                     Call_GPR_Tool := False;\n+                     exit;\n+                  end if;\n+\n                   if Switch'Length >= 2\n                     and then Switch (Switch'First .. Switch'First + 1) = \"-P\"\n                   then\n-                     Project_File_Used := True;\n-                     exit;\n+                     Call_GPR_Tool := True;\n                   end if;\n                end loop;\n \n-               if Project_File_Used then\n+               if Call_GPR_Tool then\n                   case The_Command is\n                      when Make | Compile | Bind | Link =>\n                         if Locate_Exec_On_Path (Gprbuild) /= null  then\n@@ -602,6 +819,382 @@ begin\n          end;\n       end if;\n \n+      if The_Command = List and then not Call_GPR_Tool then\n+         Tool_Package_Name := Name_Gnatls;\n+         Packages_To_Check := Packages_To_Check_By_Gnatls;\n+\n+         --  Check that the switches are consistent. Detect project file\n+         --  related switches.\n+\n+         Inspect_Switches : declare\n+            Arg_Num : Positive := 1;\n+            Argv    : String_Access;\n+\n+            procedure Remove_Switch (Num : Positive);\n+            --  Remove a project related switch from table Last_Switches\n+\n+            -------------------\n+            -- Remove_Switch --\n+            -------------------\n+\n+            procedure Remove_Switch (Num : Positive) is\n+            begin\n+               Last_Switches.Table (Num .. Last_Switches.Last - 1) :=\n+                 Last_Switches.Table (Num + 1 .. Last_Switches.Last);\n+               Last_Switches.Decrement_Last;\n+            end Remove_Switch;\n+\n+         --  Start of processing for Inspect_Switches\n+\n+         begin\n+            while Arg_Num <= Last_Switches.Last loop\n+               Argv := Last_Switches.Table (Arg_Num);\n+\n+               if Argv (Argv'First) = '-' then\n+                  if Argv'Length = 1 then\n+                     Fail (\"switch character cannot be followed by a blank\");\n+                  end if;\n+\n+                  --  --subdirs=... Specify Subdirs\n+\n+                  if Argv'Length > Makeutl.Subdirs_Option'Length\n+                    and then\n+                      Argv\n+                       (Argv'First ..\n+                        Argv'First + Makeutl.Subdirs_Option'Length - 1) =\n+                                                        Makeutl.Subdirs_Option\n+                  then\n+                     Subdirs :=\n+                       new String'\n+                         (Argv (Argv'First + Makeutl.Subdirs_Option'Length ..\n+                                Argv'Last));\n+\n+                     Remove_Switch (Arg_Num);\n+\n+                  --  -aPdir  Add dir to the project search path\n+\n+                  elsif Argv'Length > 3\n+                    and then Argv (Argv'First + 1 .. Argv'First + 2) = \"aP\"\n+                  then\n+                     Prj.Env.Add_Directories\n+                       (Root_Environment.Project_Path,\n+                        Argv (Argv'First + 3 .. Argv'Last));\n+\n+                     --  Pass -aPdir to gnatls, but not to other tools\n+\n+                     if The_Command = List then\n+                        Arg_Num := Arg_Num + 1;\n+                     else\n+                        Remove_Switch (Arg_Num);\n+                     end if;\n+\n+                  --  -eL  Follow links for files\n+\n+                  elsif Argv.all = \"-eL\" then\n+                     Follow_Links_For_Files := True;\n+                     Follow_Links_For_Dirs  := True;\n+\n+                     Remove_Switch (Arg_Num);\n+\n+                  --  -vPx  Specify verbosity while parsing project files\n+\n+                  elsif Argv'Length >= 3\n+                    and then  Argv (Argv'First + 1 .. Argv'First + 2) = \"vP\"\n+                  then\n+                     if Argv'Length = 4\n+                       and then Argv (Argv'Last) in '0' .. '2'\n+                     then\n+                        case Argv (Argv'Last) is\n+                           when '0' =>\n+                              Current_Verbosity := Prj.Default;\n+                           when '1' =>\n+                              Current_Verbosity := Prj.Medium;\n+                           when '2' =>\n+                              Current_Verbosity := Prj.High;\n+                           when others =>\n+\n+                              --  Cannot happen\n+\n+                              raise Program_Error;\n+                        end case;\n+                     else\n+                        Fail (\"invalid verbosity level: \"\n+                              & Argv (Argv'First + 3 .. Argv'Last));\n+                     end if;\n+\n+                     Remove_Switch (Arg_Num);\n+\n+                  --  -Pproject_file  Specify project file to be used\n+\n+                  elsif Argv (Argv'First + 1) = 'P' then\n+\n+                     --  Only one -P switch can be used\n+\n+                     if Project_File /= null then\n+                        Fail\n+                          (Argv.all\n+                           & \": second project file forbidden (first is \"\"\"\n+                           & Project_File.all & \"\"\")\");\n+\n+                     elsif Argv'Length = 2 then\n+\n+                        --  There is space between -P and the project file\n+                        --  name. -P cannot be the last option.\n+\n+                        if Arg_Num = Last_Switches.Last then\n+                           Fail (\"project file name missing after -P\");\n+\n+                        else\n+                           Remove_Switch (Arg_Num);\n+                           Argv := Last_Switches.Table (Arg_Num);\n+\n+                           --  After -P, there must be a project file name,\n+                           --  not another switch.\n+\n+                           if Argv (Argv'First) = '-' then\n+                              Fail (\"project file name missing after -P\");\n+\n+                           else\n+                              Project_File := new String'(Argv.all);\n+                           end if;\n+                        end if;\n+\n+                     else\n+                        --  No space between -P and project file name\n+\n+                        Project_File :=\n+                          new String'(Argv (Argv'First + 2 .. Argv'Last));\n+                     end if;\n+\n+                     Remove_Switch (Arg_Num);\n+\n+                  --  -Xexternal=value Specify an external reference to be\n+                  --                   used in project files\n+\n+                  elsif Argv'Length >= 5\n+                    and then Argv (Argv'First + 1) = 'X'\n+                  then\n+                     if not Check (Root_Environment.External,\n+                                    Argv (Argv'First + 2 .. Argv'Last))\n+                     then\n+                        Fail\n+                          (Argv.all & \" is not a valid external assignment.\");\n+                     end if;\n+\n+                     Remove_Switch (Arg_Num);\n+\n+                  elsif\n+                    The_Command = List\n+                    and then Argv'Length = 2\n+                    and then Argv (2) = 'U'\n+                  then\n+                     All_Projects := True;\n+                     Remove_Switch (Arg_Num);\n+\n+                  else\n+                     Arg_Num := Arg_Num + 1;\n+                  end if;\n+\n+               else\n+                  Arg_Num := Arg_Num + 1;\n+               end if;\n+            end loop;\n+         end Inspect_Switches;\n+      end if;\n+\n+      --  Add the default project search directories now, after the directories\n+      --  that have been specified by switches -aP<dir>.\n+\n+      Prj.Env.Initialize_Default_Project_Path\n+        (Root_Environment.Project_Path,\n+         Target_Name => Sdefault.Target_Name.all);\n+\n+      --  If there is a project file specified, parse it, get the switches\n+      --  for the tool and setup PATH environment variables.\n+\n+      if Project_File /= null then\n+         Prj.Pars.Set_Verbosity (To => Current_Verbosity);\n+\n+         Prj.Pars.Parse\n+           (Project           => Project,\n+            In_Tree           => Project_Tree,\n+            In_Node_Tree      => Project_Node_Tree,\n+            Project_File_Name => Project_File.all,\n+            Env               => Root_Environment,\n+            Packages_To_Check => Packages_To_Check);\n+\n+         --  Prj.Pars.Parse calls Set_Standard_Output, reset to stderr\n+\n+         Set_Standard_Error;\n+\n+         if Project = Prj.No_Project then\n+            Fail (\"\"\"\" & Project_File.all & \"\"\" processing failed\");\n+\n+         elsif Project.Qualifier = Aggregate then\n+            Fail (\"aggregate projects are not supported\");\n+\n+         elsif Aggregate_Libraries_In (Project_Tree) then\n+            Fail (\"aggregate library projects are not supported\");\n+         end if;\n+\n+         --  Check if a package with the name of the tool is in the project\n+         --  file and if there is one, get the switches, if any, and scan them.\n+\n+         declare\n+            Pkg : constant Prj.Package_Id :=\n+                    Prj.Util.Value_Of\n+                      (Name        => Tool_Package_Name,\n+                       In_Packages => Project.Decl.Packages,\n+                       Shared      => Project_Tree.Shared);\n+\n+            Element : Package_Element;\n+\n+            Switches_Array : Array_Element_Id;\n+\n+            The_Switches : Prj.Variable_Value;\n+            Current      : Prj.String_List_Id;\n+            The_String   : String_Element;\n+\n+            Main : String_Access := null;\n+\n+         begin\n+            if Pkg /= No_Package then\n+               Element := Project_Tree.Shared.Packages.Table (Pkg);\n+\n+               --  Package Gnatls has a single attribute Switches, that is not\n+               --  an associative array.\n+\n+               if The_Command = List then\n+                  The_Switches :=\n+                    Prj.Util.Value_Of\n+                    (Variable_Name => Snames.Name_Switches,\n+                     In_Variables  => Element.Decl.Attributes,\n+                     Shared        => Project_Tree.Shared);\n+\n+               --  Packages Binder (for gnatbind), Cross_Reference (for\n+               --  gnatxref), Linker (for gnatlink), Finder (for gnatfind),\n+               --  have an attributed Switches, an associative array, indexed\n+               --  by the name of the file.\n+\n+               --  They also have an attribute Default_Switches, indexed by the\n+               --  name of the programming language.\n+\n+               else\n+                  --  First check if there is a single main\n+\n+                  for J in 1 .. Last_Switches.Last loop\n+                     if Last_Switches.Table (J) (1) /= '-' then\n+                        if Main = null then\n+                           Main := Last_Switches.Table (J);\n+                        else\n+                           Main := null;\n+                           exit;\n+                        end if;\n+                     end if;\n+                  end loop;\n+\n+                  if Main /= null then\n+                     Switches_Array :=\n+                       Prj.Util.Value_Of\n+                         (Name      => Name_Switches,\n+                          In_Arrays => Element.Decl.Arrays,\n+                          Shared    => Project_Tree.Shared);\n+                     Name_Len := 0;\n+\n+                     --  If the single main has been specified as an absolute\n+                     --  path, use only the simple file name. If the absolute\n+                     --  path is incorrect, an error will be reported by the\n+                     --  underlying tool and it does not make a difference\n+                     --  what switches are used.\n+\n+                     if Is_Absolute_Path (Main.all) then\n+                        Add_Str_To_Name_Buffer (File_Name (Main.all));\n+                     else\n+                        Add_Str_To_Name_Buffer (Main.all);\n+                     end if;\n+\n+                     The_Switches := Prj.Util.Value_Of\n+                       (Index     => Name_Find,\n+                        Src_Index => 0,\n+                        In_Array  => Switches_Array,\n+                        Shared    => Project_Tree.Shared);\n+                  end if;\n+\n+                  if The_Switches.Kind = Prj.Undefined then\n+                     Switches_Array :=\n+                       Prj.Util.Value_Of\n+                         (Name      => Name_Default_Switches,\n+                          In_Arrays => Element.Decl.Arrays,\n+                          Shared    => Project_Tree.Shared);\n+                     The_Switches := Prj.Util.Value_Of\n+                       (Index     => Name_Ada,\n+                        Src_Index => 0,\n+                        In_Array  => Switches_Array,\n+                        Shared    => Project_Tree.Shared);\n+                  end if;\n+               end if;\n+\n+               --  If there are switches specified in the package of the\n+               --  project file corresponding to the tool, scan them.\n+\n+               case The_Switches.Kind is\n+                  when Prj.Undefined =>\n+                     null;\n+\n+                  when Prj.Single =>\n+                     declare\n+                        Switch : constant String :=\n+                                   Get_Name_String (The_Switches.Value);\n+                     begin\n+                        if Switch'Length > 0 then\n+                           First_Switches.Increment_Last;\n+                           First_Switches.Table (First_Switches.Last) :=\n+                             new String'(Switch);\n+                        end if;\n+                     end;\n+\n+                  when Prj.List =>\n+                     Current := The_Switches.Values;\n+                     while Current /= Prj.Nil_String loop\n+                        The_String := Project_Tree.Shared.String_Elements.\n+                                        Table (Current);\n+\n+                        declare\n+                           Switch : constant String :=\n+                                      Get_Name_String (The_String.Value);\n+                        begin\n+                           if Switch'Length > 0 then\n+                              First_Switches.Increment_Last;\n+                              First_Switches.Table (First_Switches.Last) :=\n+                                new String'(Switch);\n+                           end if;\n+                        end;\n+\n+                        Current := The_String.Next;\n+                     end loop;\n+               end case;\n+            end if;\n+         end;\n+\n+         if The_Command = Bind or else The_Command = Link then\n+            if Project.Object_Directory.Name = No_Path then\n+               Fail (\"project \" & Get_Name_String (Project.Display_Name)\n+                     & \" has no object directory\");\n+            end if;\n+\n+            Change_Dir (Get_Name_String (Project.Object_Directory.Name));\n+         end if;\n+\n+         --  Set up the env vars for project path files\n+\n+         Prj.Env.Set_Ada_Paths\n+           (Project, Project_Tree, Including_Libraries => True);\n+\n+         if The_Command = List then\n+            Check_Files;\n+         end if;\n+      end if;\n+\n       --  Gather all the arguments and invoke the executable\n \n       declare"}, {"sha": "a2c4c9e278f069f8b859b572544224e69be2e1a6", "filename": "gcc/ada/make.adb", "status": "modified", "additions": 36, "deletions": 19, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c61772a122cc888d0aafffbaa35d4c95cc7abcc/gcc%2Fada%2Fmake.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c61772a122cc888d0aafffbaa35d4c95cc7abcc/gcc%2Fada%2Fmake.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmake.adb?ref=0c61772a122cc888d0aafffbaa35d4c95cc7abcc", "patch": "@@ -6413,16 +6413,29 @@ package body Make is\n       --  Scan again the switch and arguments, now that we are sure that they\n       --  do not include --version or --help.\n \n-      --  First, for native gnatmake, check for switch -P and, if found and\n-      --  gprbuild is available, silently invoke gprbuild.\n+      --  First, check for switch -P and, if found and gprbuild is available,\n+      --  silently invoke gprbuild, with switch --target if not on a native\n+      --  platform.\n \n-      Find_Program_Name;\n+      declare\n+         Arg_Len       : Positive      := Argument_Count;\n+         Call_Gprbuild : Boolean       := False;\n+         Gprbuild      : String_Access := null;\n+         Pos           : Natural       := 0;\n+         Success       : Boolean;\n+         Target        : String_Access := null;\n \n-      if Name_Buffer (1 .. Name_Len) = \"gnatmake\" then\n-         declare\n-            Call_Gprbuild : Boolean := False;\n+      begin\n+         Find_Program_Name;\n+\n+         if Name_Len >= 8\n+           and then Name_Buffer (Name_Len - 7 .. Name_Len) = \"gnatmake\"\n+         then\n+            if Name_Len > 8 then\n+               Target  := new String'(Name_Buffer (1 .. Name_Len - 9));\n+               Arg_Len := Arg_Len + 1;\n+            end if;\n \n-         begin\n             for J in 1 .. Argument_Count loop\n                declare\n                   Arg : constant String := Argument (J);\n@@ -6437,16 +6450,20 @@ package body Make is\n             end loop;\n \n             if Call_Gprbuild then\n-               declare\n-                  Gprbuild : String_Access :=\n-                               Locate_Exec_On_Path (Exec_Name => \"gprbuild\");\n-                  Args     : Argument_List (1 .. Argument_Count);\n-                  Success  : Boolean;\n+               Gprbuild := Locate_Exec_On_Path (Exec_Name => \"gprbuild\");\n+\n+               if Gprbuild /= null then\n+                  declare\n+                     Args : Argument_List (1 .. Arg_Len);\n+                  begin\n+                     if Target /= null then\n+                        Args (1) := new String'(\"--target=\" & Target.all);\n+                        Pos := 1;\n+                     end if;\n \n-               begin\n-                  if Gprbuild /= null then\n                      for J in 1 .. Argument_Count loop\n-                        Args (J) := new String'(Argument (J));\n+                        Pos := Pos + 1;\n+                        Args (Pos) := new String'(Argument (J));\n                      end loop;\n \n                      Spawn (Gprbuild.all, Args, Success);\n@@ -6456,11 +6473,11 @@ package body Make is\n                      if Success then\n                         Exit_Program (E_Success);\n                      end if;\n-                  end if;\n-               end;\n+                  end;\n+               end if;\n             end if;\n-         end;\n-      end if;\n+         end if;\n+      end;\n \n       Scan_Args : for Next_Arg in 1 .. Argument_Count loop\n          Scan_Make_Arg (Env, Argument (Next_Arg), And_Save => True);"}, {"sha": "5f77f5719997e27850ed7f1e50aedcd2bc9943f4", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c61772a122cc888d0aafffbaa35d4c95cc7abcc/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c61772a122cc888d0aafffbaa35d4c95cc7abcc/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=0c61772a122cc888d0aafffbaa35d4c95cc7abcc", "patch": "@@ -14052,7 +14052,7 @@ package body Sem_Ch12 is\n          begin\n             Result := Make_Identifier (Loc, Chars (Typ));\n \n-            if Present (Scop) and then Scop /= Standard_Standard then\n+            if Present (Scop) and then not Is_Generic_Unit (Scop) then\n                Result :=\n                  Make_Selected_Component (Loc,\n                    Prefix        => Make_Identifier (Loc, Chars (Scop)),"}]}