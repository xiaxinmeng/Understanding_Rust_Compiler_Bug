{"sha": "00abf86c47606f8220d6508654ef52ef11d76e3d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDBhYmY4NmM0NzYwNmY4MjIwZDY1MDg2NTRlZjUyZWYxMWQ3NmUzZA==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2018-07-20T20:51:20Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2018-07-20T20:51:20Z"}, "message": "PR middle-end/82063 - issues with arguments enabled by -Wall\n\ngcc/ada/ChangeLog:\n\n\tPR middle-end/82063\n\t* gcc-interface/misc.c (gnat_handle_option): Change function argument\n\tto HOST_WIDE_INT.\n\ngcc/brig/ChangeLog:\n\n\tPR middle-end/82063\n\t* brig/brig-lang.c (brig_langhook_handle_option): Change function\n\targument to HOST_WIDE_INT.\n\ngcc/c-family/ChangeLog:\n\n\tPR middle-end/82063\n\t* c-common.h (c_common_handle_option): Change function argument\n\tto HOST_WIDE_INT.\n\t* c-opts.c (c_common_init_options): Same.\n\t(c_common_handle_option): Same.  Remove special handling of\n\tOPT_Walloca_larger_than_ and OPT_Wvla_larger_than_.\n\t* c.opt (-Walloc-size-larger-than, -Walloca-larger-than): Change\n\toptions to take a HOST_WIDE_INT argument and accept a byte-size\n\tsuffix.  Initialize.\n\t(-Wvla-larger-than): Same.\n\t(-Wno-alloc-size-larger-than, -Wno-alloca-larger-than): New.\n\t(-Wno-vla-larger-than): Same.\n\ngcc/fortran/ChangeLog:\n\n\tPR middle-end/82063\n\t* gfortran.h (gfc_handle_option): Change function argument\n\tto HOST_WIDE_INT.\n\t* options.c (gfc_handle_option): Same.\n\ngcc/go/ChangeLog:\n\n\tPR middle-end/82063\n\t* go-lang.c (go_langhook_handle_option): Change function argument\n\tto HOST_WIDE_INT.\n\ngcc/lto/ChangeLog:\n\n\tPR middle-end/82063\n\t* lto-lang.c (lto_handle_option): Change function argument\n\tto HOST_WIDE_INT.\n\ngcc/testsuite/ChangeLog:\n\n\tPR middle-end/82063\n\t* gcc/testsuite/c-c++-common/pr68657-1.c: Adjust.\n\t* gcc/testsuite/c-c++-common/pr68657-2.c: Same.\n\t* gcc/testsuite/c-c++-common/pr68657-3.c: Same.\n\t* gcc.dg/Walloc-size-larger-than-16.c: Same.\n\t* gcc.dg/Walloca-larger-than.c: New test.\n\t* gcc.dg/Walloca-larger-than-2.c: New test.\n\t* gcc.dg/Wframe-larger-than-2.c: New test.\n\t* gcc.dg/Wlarger-than3.c: New test.\n\t* gcc.dg/Wvla-larger-than-3.c: New test.\n\t* gcc.dg/pr42611.c: Adjust.\n\t* gnat.dg/frame_overflow.adb: Same.\n\ngcc/ChangeLog:\n\n\tPR middle-end/82063\n\t* builtins.c (expand_builtin_alloca): Adjust.\n\t* calls.c (alloc_max_size): Simplify.\n\t* cgraphunit.c (cgraph_node::expand): Adjust.\n\t* common.opt (larger_than_size, warn_frame_larger_than): Remove\n\tvariables.\n\t(frame_larger_than_size): Same.\n\t(-Wframe-larger-than, -Wlarger-than, -Wstack-usage): Change options\n\tto take a HOST_WIDE_INT argument and accept a byte-size suffix.\n\tInitialize.\n\t* doc/invoke.texi (GCC Command Options): Document option arguments.\n\tExplain byte-size arguments and suffixes.\n\t(-Wvla-larger-than, -Wno-alloc-size-larger-than): Update.\n\t(-Wno-alloca-larger-than, -Wno-vla-larger-than): Same.\n\t(-Wframe-larger-than, -Wlarger-than, -Wstack-usage): Same.\n\t* doc/options.texi (UInteger): Expand.\n\t(Host_Wide_Int, ByteSize): Document new properties.\n\t* final.c (final_start_function_1): Include sizes in an error message.\n\t* function.c (frame_offset_overflow): Same.\n\t* gimple-ssa-warn-alloca.c (pass_walloca::gate): Adjust.\n\t(alloca_call_type_by_arg): Change function argument to HOST_WIDE_INT.\n\tDiagnose unbounded alloca calls only for limits of less than\n\tPTRDIFF_MAX.\n\t(alloca_call_type): Adjust.  Diagnose possibly out-of-bounds alloca\n\tcalls and VLA size only for limits of less than\tPTRDIFF_MAX.  Same\n\tfor alloca(0).\n\t(pass_walloca::execute): Adjust.  Diagnose alloca calls in loops\n\tonly for limits of less than PTRDIFF_MAX.\n\t* langhooks-def.h (lhd_handle_option): Change function argument\n\tto HOST_WIDE_INT.\n\t* langhooks.c (lhd_handle_option): Same.\n\t* langhooks.h (handle_option): Same.\n\t* opt-functions.awk (switch_bit_fields): Handle Host_Wide_Int and\n\tByteSize flags.\n\t(var_type, var_type_struct): Same.\n\t(var_set): Handle ByteSize flag.\n\t* optc-gen.awk: Add comments to output to ease debugging.  Make\n\tuse of HOST_WIDE_INT where appropriate.\n\t* opts-gen-save.awk:  Use %lx to format unsigned long.\n\t* opth-gen.awk: Change function argument to HOST_WIDE_INT.\n\t* opts-common.c (integral_argument): Return HOST_WIDE_INT and add\n\targuments.  Parse bytes-size suffixes.\n\t(enum_arg_to_value): Change function argument to HOST_WIDE_INT.\n\t(enum_value_to_arg): Same.\n\t(decode_cmdline_option): Handle cl_host_wide_int.  Adjust.\n\t(handle_option): Adjust.\n\t(generate_option): Change function argument to HOST_WIDE_INT.\n\t(cmdline_handle_error): Adjust.\n\t(read_cmdline_option): Change function argument to HOST_WIDE_INT.\n\t(set_option): Change function argument to HOST_WIDE_INT.\n\t(option_enabled): Handle cl_host_wide_int.\n\t(get_option_state): Handle CLVC_SIZE.\n\t(control_warning_option): Same.\n\t* opts.c (common_handle_option): Change function argument to\n\tHOST_WIDE_INT.  Remove handling of OPT_Walloca_larger_than_ and\n\tOPT_Wvla_larger_than_.\n\t* opts.h (enum cl_var_type): Add an enumerator.\n\t* stor-layout.c (layout_decl): Print a more meaningful warning.\n\t* toplev.c (output_stack_usage): Adjust.\n\nFrom-SVN: r262910", "tree": {"sha": "9fa355c5a990f19e6fa77fffaa11f37da0124134", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9fa355c5a990f19e6fa77fffaa11f37da0124134"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/00abf86c47606f8220d6508654ef52ef11d76e3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00abf86c47606f8220d6508654ef52ef11d76e3d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00abf86c47606f8220d6508654ef52ef11d76e3d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00abf86c47606f8220d6508654ef52ef11d76e3d/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "20e8ceae67be4186c4f20b4fb96f7cfade9853a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20e8ceae67be4186c4f20b4fb96f7cfade9853a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20e8ceae67be4186c4f20b4fb96f7cfade9853a7"}], "stats": {"total": 1239, "additions": 862, "deletions": 377}, "files": [{"sha": "1b4f28523c1bbbc07c0fe1a3cac13fb40a772f2c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=00abf86c47606f8220d6508654ef52ef11d76e3d", "patch": "@@ -1,3 +1,65 @@\n+2018-07-20  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/82063\n+\t* builtins.c (expand_builtin_alloca): Adjust.\n+\t* calls.c (alloc_max_size): Simplify.\n+\t* cgraphunit.c (cgraph_node::expand): Adjust.\n+\t* common.opt (larger_than_size, warn_frame_larger_than): Remove\n+\tvariables.\n+\t(frame_larger_than_size): Same.\n+\t(-Wframe-larger-than, -Wlarger-than, -Wstack-usage): Change options\n+\tto take a HOST_WIDE_INT argument and accept a byte-size suffix.\n+\tInitialize.\n+\t* doc/invoke.texi (GCC Command Options): Document option arguments.\n+\tExplain byte-size arguments and suffixes.\n+\t(-Wvla-larger-than, -Wno-alloc-size-larger-than): Update.\n+\t(-Wno-alloca-larger-than, -Wno-vla-larger-than): Same.\n+\t(-Wframe-larger-than, -Wlarger-than, -Wstack-usage): Same.\n+\t* doc/options.texi (UInteger): Expand.\n+\t(Host_Wide_Int, ByteSize): Document new properties.\n+\t* final.c (final_start_function_1): Include sizes in an error message.\n+\t* function.c (frame_offset_overflow): Same.\n+\t* gimple-ssa-warn-alloca.c (pass_walloca::gate): Adjust.\n+\t(alloca_call_type_by_arg): Change function argument to HOST_WIDE_INT.\n+\tDiagnose unbounded alloca calls only for limits of less than\n+\tPTRDIFF_MAX.\n+\t(alloca_call_type): Adjust.  Diagnose possibly out-of-bounds alloca\n+\tcalls and VLA size only for limits of less than\tPTRDIFF_MAX.  Same\n+\tfor alloca(0).\n+\t(pass_walloca::execute): Adjust.  Diagnose alloca calls in loops\n+\tonly for limits of less than PTRDIFF_MAX.\n+\t* langhooks-def.h (lhd_handle_option): Change function argument\n+\tto HOST_WIDE_INT.\n+\t* langhooks.c (lhd_handle_option): Same.\n+\t* langhooks.h (handle_option): Same.\n+\t* opt-functions.awk (switch_bit_fields): Handle Host_Wide_Int and\n+\tByteSize flags.\n+\t(var_type, var_type_struct): Same.\n+\t(var_set): Handle ByteSize flag.\n+\t* optc-gen.awk: Add comments to output to ease debugging.  Make\n+\tuse of HOST_WIDE_INT where appropriate.\n+\t* opts-gen-save.awk:  Use %lx to format unsigned long.\n+\t* opth-gen.awk: Change function argument to HOST_WIDE_INT.\n+\t* opts-common.c (integral_argument): Return HOST_WIDE_INT and add\n+\targuments.  Parse bytes-size suffixes.\n+\t(enum_arg_to_value): Change function argument to HOST_WIDE_INT.\n+\t(enum_value_to_arg): Same.\n+\t(decode_cmdline_option): Handle cl_host_wide_int.  Adjust.\n+\t(handle_option): Adjust.\n+\t(generate_option): Change function argument to HOST_WIDE_INT.\n+\t(cmdline_handle_error): Adjust.\n+\t(read_cmdline_option): Change function argument to HOST_WIDE_INT.\n+\t(set_option): Change function argument to HOST_WIDE_INT.\n+\t(option_enabled): Handle cl_host_wide_int.\n+\t(get_option_state): Handle CLVC_SIZE.\n+\t(control_warning_option): Same.\n+\t* opts.c (common_handle_option): Change function argument to\n+\tHOST_WIDE_INT.  Remove handling of OPT_Walloca_larger_than_ and\n+\tOPT_Wvla_larger_than_.\n+\t* opts.h (enum cl_var_type): Add an enumerator.\n+\t* stor-layout.c (layout_decl): Print a more meaningful warning.\n+\t* toplev.c (output_stack_usage): Adjust.\n+\n 2018-07-20  Qing Zhao  <qing.zhao@oracle.com>\n \n \t* builtins.c (expand_builtin_memcmp): Delete the last parameter for"}, {"sha": "6f096266d009e2af14434b24a16c0ba780ee2578", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=00abf86c47606f8220d6508654ef52ef11d76e3d", "patch": "@@ -1,3 +1,9 @@\n+2018-07-20  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/82063\n+\t* gcc-interface/misc.c (gnat_handle_option): Change function argument\n+\tto HOST_WIDE_INT.\n+\n 2018-07-17  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/decl.c (choices_to_gnu): Rename parameters.  Deal with"}, {"sha": "9ee73b9ec1bb94d3ab30b596479a03e4660fbf1a", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=00abf86c47606f8220d6508654ef52ef11d76e3d", "patch": "@@ -138,8 +138,9 @@ gnat_option_lang_mask (void)\n    are marked as Ada-specific.  Return true on success or false on failure.  */\n \n static bool\n-gnat_handle_option (size_t scode, const char *arg, int value, int kind,\n-\t\t    location_t loc, const struct cl_option_handlers *handlers)\n+gnat_handle_option (size_t scode, const char *arg, HOST_WIDE_INT value,\n+\t\t    int kind, location_t loc,\n+\t\t    const struct cl_option_handlers *handlers)\n {\n   enum opt_code code = (enum opt_code) scode;\n "}, {"sha": "f8749b46e617c15d1658abb6ad526c38667337d0", "filename": "gcc/brig/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Fbrig%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Fbrig%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2FChangeLog?ref=00abf86c47606f8220d6508654ef52ef11d76e3d", "patch": "@@ -1,3 +1,9 @@\n+2018-07-20  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/82063\n+\t* brig/brig-lang.c (brig_langhook_handle_option): Change function\n+\targument to HOST_WIDE_INT.\n+\n 2018-07-04  Martin Jambor  <mjambor@suse.cz>\n \n \tPR hsa/86371"}, {"sha": "862ea69a0eac81a9f5c7e225954e9fa35e10189d", "filename": "gcc/brig/brig-lang.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Fbrig%2Fbrig-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Fbrig%2Fbrig-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrig-lang.c?ref=00abf86c47606f8220d6508654ef52ef11d76e3d", "patch": "@@ -145,7 +145,7 @@ brig_langhook_init_options_struct (struct gcc_options *opts)\n static bool\n brig_langhook_handle_option\n   (size_t scode, const char *arg ATTRIBUTE_UNUSED,\n-  int value ATTRIBUTE_UNUSED, int kind ATTRIBUTE_UNUSED,\n+  HOST_WIDE_INT value ATTRIBUTE_UNUSED, int kind ATTRIBUTE_UNUSED,\n   location_t loc ATTRIBUTE_UNUSED,\n   const struct cl_option_handlers *handlers ATTRIBUTE_UNUSED)\n {"}, {"sha": "539a6d17688720b81087c59cef244cc68736665c", "filename": "gcc/builtins.c", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=00abf86c47606f8220d6508654ef52ef11d76e3d", "patch": "@@ -5093,13 +5093,20 @@ expand_builtin_alloca (tree exp)\n   if (!valid_arglist)\n     return NULL_RTX;\n \n-  if ((alloca_for_var && !warn_vla_limit)\n-      || (!alloca_for_var && !warn_alloca_limit))\n-    {\n-      /* -Walloca-larger-than and -Wvla-larger-than settings override\n-\t the more general -Walloc-size-larger-than so unless either of\n-\t the former options is specified check the alloca arguments for\n-\t overflow.  */\n+  if ((alloca_for_var\n+       && warn_vla_limit >= HOST_WIDE_INT_MAX\n+       && warn_alloc_size_limit < warn_vla_limit)\n+      || (!alloca_for_var\n+\t  && warn_alloca_limit >= HOST_WIDE_INT_MAX\n+\t  && warn_alloc_size_limit < warn_alloca_limit\n+\t  ))\n+    {\n+      /* -Walloca-larger-than and -Wvla-larger-than settings of\n+\t less than HOST_WIDE_INT_MAX override the more general\n+\t -Walloc-size-larger-than so unless either of the former\n+\t options is smaller than the last one (wchich would imply\n+\t that the call was already checked), check the alloca\n+\t arguments for overflow.  */\n       tree args[] = { CALL_EXPR_ARG (exp, 0), NULL_TREE };\n       int idx[] = { 0, -1 };\n       maybe_warn_alloc_args_overflow (fndecl, exp, args, idx);"}, {"sha": "9ea551ac1a92c0b639bd3aa836ab870b79c7df78", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=00abf86c47606f8220d6508654ef52ef11d76e3d", "patch": "@@ -1,3 +1,18 @@\n+2018-07-20  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/82063\n+\t* c-common.h (c_common_handle_option): Change function argument\n+\tto HOST_WIDE_INT.\n+\t* c-opts.c (c_common_init_options): Same.\n+\t(c_common_handle_option): Same.  Remove special handling of\n+\tOPT_Walloca_larger_than_ and OPT_Wvla_larger_than_.\n+\t* c.opt (-Walloc-size-larger-than, -Walloca-larger-than): Change\n+\toptions to take a HOST_WIDE_INT argument and accept a byte-size\n+\tsuffix.  Initialize.\n+\t(-Wvla-larger-than): Same.\n+\t(-Wno-alloc-size-larger-than, -Wno-alloca-larger-than): New.\n+\t(-Wno-vla-larger-than): Same.\n+\n 2018-07-12  Jakub Jelinek  <jakub@redhat.com>\n \n \t* c-attribs.c (c_common_attribute_table): Add"}, {"sha": "fcec95b4f3be1883d33fe5c1b309886696f84d04", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=00abf86c47606f8220d6508654ef52ef11d76e3d", "patch": "@@ -808,7 +808,8 @@ extern void check_function_format (tree, int, tree *, vec<location_t> *);\n extern bool attribute_fallthrough_p (tree);\n extern tree handle_format_attribute (tree *, tree, tree, int, bool *);\n extern tree handle_format_arg_attribute (tree *, tree, tree, int, bool *);\n-extern bool c_common_handle_option (size_t, const char *, int, int, location_t,\n+extern bool c_common_handle_option (size_t, const char *, HOST_WIDE_INT, int,\n+\t\t\t\t    location_t,\n \t\t\t\t    const struct cl_option_handlers *);\n extern bool default_handle_c_option (size_t, const char *, int);\n extern tree c_common_type_for_mode (machine_mode, int);"}, {"sha": "cb69fb3513c7cb544c6252461fb384629b6607d6", "filename": "gcc/c-family/c-opts.c", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Fc-family%2Fc-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Fc-family%2Fc-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-opts.c?ref=00abf86c47606f8220d6508654ef52ef11d76e3d", "patch": "@@ -262,7 +262,7 @@ c_common_init_options (unsigned int decoded_options_count,\n    form of an -f or -W option was given.  Returns false if the switch was\n    invalid, true if valid.  Use HANDLERS in recursive handle_option calls.  */\n bool\n-c_common_handle_option (size_t scode, const char *arg, int value,\n+c_common_handle_option (size_t scode, const char *arg, HOST_WIDE_INT value,\n \t\t\tint kind, location_t loc,\n \t\t\tconst struct cl_option_handlers *handlers)\n {\n@@ -381,16 +381,6 @@ c_common_handle_option (size_t scode, const char *arg, int value,\n       cpp_opts->warn_num_sign_change = value;\n       break;\n \n-    case OPT_Walloca_larger_than_:\n-      if (!value)\n-\tinform (loc, \"-Walloca-larger-than=0 is meaningless\");\n-      break;\n-\n-    case OPT_Wvla_larger_than_:\n-      if (!value)\n-\tinform (loc, \"-Wvla-larger-than=0 is meaningless\");\n-      break;\n-\n     case OPT_Wunknown_pragmas:\n       /* Set to greater than 1, so that even unknown pragmas in\n \t system headers will be warned about.  */"}, {"sha": "bb4f6034c60834e20084c7f7ffac8cd36c7a044e", "filename": "gcc/c-family/c.opt", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Fc-family%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Fc-family%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc.opt?ref=00abf86c47606f8220d6508654ef52ef11d76e3d", "patch": "@@ -304,24 +304,28 @@ C ObjC C++ ObjC++ Var(warn_alloca) Warning\n Warn on any use of alloca.\n \n Walloc-size-larger-than=\n-C ObjC C++ LTO ObjC++ Var(warn_alloc_size_limit) Warning Joined LangEnabledBy(C ObjC C++ LTO ObjC++,Wall)\n+C ObjC C++ LTO ObjC++ Var(warn_alloc_size_limit) Joined Host_Wide_Int ByteSize Warning Init(HOST_WIDE_INT_MAX)\n -Walloc-size-larger-than=<bytes> Warn for calls to allocation functions that\n attempt to allocate objects larger than the specified number of bytes.\n \n Wno-alloc-size-larger-than\n-C ObjC C++ LTO ObjC++ Alias(Walloc-size-larger-than=, 18446744073709551615EiB,none) Warning\n+C ObjC C++ LTO ObjC++ Alias(Walloc-size-larger-than=,18446744073709551615EiB,none) Warning\n -Wno-alloc-size-larger-than Disable Walloc-size-larger-than= warning.  Equivalent to Walloc-size-larger-than=<SIZE_MAX> or larger.\n \n Walloc-zero\n C ObjC C++ ObjC++ Var(warn_alloc_zero) Warning\n -Walloc-zero Warn for calls to allocation functions that specify zero bytes.\n \n Walloca-larger-than=\n-C ObjC C++ LTO ObjC++ Var(warn_alloca_limit) Warning Joined RejectNegative UInteger\n+C ObjC C++ LTO ObjC++ Var(warn_alloca_limit) Warning Joined Host_Wide_Int ByteSize Init(HOST_WIDE_INT_MAX)\n -Walloca-larger-than=<number>\tWarn on unbounded uses of\n alloca, and on bounded uses of alloca whose bound can be larger than\n <number> bytes.\n \n+Wno-alloca-larger-than\n+C ObjC C++ LTO ObjC++ Alias(Walloca-larger-than=,18446744073709551615EiB,none) Warning\n+-Wno-alloca-larger-than Disable Walloca-larger-than= warning.  Equivalent to Walloca-larger-than=<SIZE_MAX> or larger.\n+\n Warray-bounds\n LangEnabledBy(C ObjC C++ LTO ObjC++,Wall)\n ; in common.opt\n@@ -1158,10 +1162,15 @@ C ObjC C++ ObjC++ Var(warn_vla) Init(-1) Warning\n Warn if a variable length array is used.\n \n Wvla-larger-than=\n-C ObjC C++ ObjC++ Var(warn_vla_limit) Warning Joined RejectNegative UInteger\n--Wvla-larger-than=<number>\tWarn on unbounded uses of variable-length arrays, and\n-on bounded uses of variable-length arrays whose bound can be\n+C ObjC C++ LTO ObjC++ Var(warn_vla_limit) Warning Joined Host_Wide_Int ByteSize Init(HOST_WIDE_INT_MAX)\n+-Wvla-larger-than=<number>\tWarn on unbounded uses of variable-length\n+arrays, and on bounded uses of variable-length arrays whose bound can be\n larger than <number> bytes.\n+<number> bytes.\n+\n+Wno-vla-larger-than\n+C ObjC C++ LTO ObjC++ Alias(Wvla-larger-than=,18446744073709551615EiB,none) Warning\n+-Wno-vla-larger-than Disable Wvla-larger-than= warning.  Equivalent to Wvla-larger-than=<SIZE_MAX> or larger.\n \n Wvolatile-register-var\n C ObjC C++ ObjC++ Var(warn_volatile_register_var) Warning LangEnabledBy(C ObjC C++ ObjC++,Wall)"}, {"sha": "384c0238748d1748d3f0b12438ae4d5009cf70ec", "filename": "gcc/calls.c", "status": "modified", "additions": 2, "deletions": 71, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=00abf86c47606f8220d6508654ef52ef11d76e3d", "patch": "@@ -1222,77 +1222,8 @@ alloc_max_size (void)\n   if (alloc_object_size_limit)\n     return alloc_object_size_limit;\n \n-  alloc_object_size_limit = max_object_size ();\n-\n-  if (!warn_alloc_size_limit)\n-    return alloc_object_size_limit;\n-\n-  const char *optname = \"-Walloc-size-larger-than=\";\n-\n-  char *end = NULL;\n-  errno = 0;\n-  unsigned HOST_WIDE_INT unit = 1;\n-  unsigned HOST_WIDE_INT limit\n-    = strtoull (warn_alloc_size_limit, &end, 10);\n-\n-  /* If the value is too large to be represented use the maximum\n-     representable value that strtoull sets limit to (setting\n-     errno to ERANGE).  */\n-\n-  if (end && *end)\n-    {\n-      /* Numeric option arguments are at most INT_MAX.  Make it\n-\t possible to specify a larger value by accepting common\n-\t suffixes.  */\n-      if (!strcmp (end, \"kB\"))\n-\tunit = 1000;\n-      else if (!strcasecmp (end, \"KiB\") || !strcmp (end, \"KB\"))\n-\tunit = 1024;\n-      else if (!strcmp (end, \"MB\"))\n-\tunit = HOST_WIDE_INT_UC (1000) * 1000;\n-      else if (!strcasecmp (end, \"MiB\"))\n-\tunit = HOST_WIDE_INT_UC (1024) * 1024;\n-      else if (!strcasecmp (end, \"GB\"))\n-\tunit = HOST_WIDE_INT_UC (1000) * 1000 * 1000;\n-      else if (!strcasecmp (end, \"GiB\"))\n-\tunit = HOST_WIDE_INT_UC (1024) * 1024 * 1024;\n-      else if (!strcasecmp (end, \"TB\"))\n-\tunit = HOST_WIDE_INT_UC (1000) * 1000 * 1000 * 1000;\n-      else if (!strcasecmp (end, \"TiB\"))\n-\tunit = HOST_WIDE_INT_UC (1024) * 1024 * 1024 * 1024;\n-      else if (!strcasecmp (end, \"PB\"))\n-\tunit = HOST_WIDE_INT_UC (1000) * 1000 * 1000 * 1000 * 1000;\n-      else if (!strcasecmp (end, \"PiB\"))\n-\tunit = HOST_WIDE_INT_UC (1024) * 1024 * 1024 * 1024 * 1024;\n-      else if (!strcasecmp (end, \"EB\"))\n-\tunit = HOST_WIDE_INT_UC (1000) * 1000 * 1000 * 1000 * 1000\n-\t  * 1000;\n-      else if (!strcasecmp (end, \"EiB\"))\n-\tunit = HOST_WIDE_INT_UC (1024) * 1024 * 1024 * 1024 * 1024\n-\t  * 1024;\n-      else\n-\t{\n-\t  /* This could mean an unknown suffix or a bad prefix, like\n-\t     \"+-1\".  */\n-\t  warning_at (UNKNOWN_LOCATION, 0,\n-\t\t      \"invalid argument %qs to %qs\",\n-\t\t      warn_alloc_size_limit, optname);\n-\n-\t  /* Ignore the limit extracted by strtoull.  */\n-\t  unit = 0;\n-\t}\n-    }\n-\n-  if (unit)\n-    {\n-      widest_int w = wi::mul (limit, unit);\n-      if (w < wi::to_widest (alloc_object_size_limit))\n-\talloc_object_size_limit\n-\t  = wide_int_to_tree (ptrdiff_type_node, w);\n-      else\n-\talloc_object_size_limit = build_all_ones_cst (size_type_node);\n-    }\n-\n+  alloc_object_size_limit\n+    = build_int_cst (size_type_node, warn_alloc_size_limit);\n \n   return alloc_object_size_limit;\n }"}, {"sha": "462e247328ea988bbfa51fa0b639cfab89fed229", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=00abf86c47606f8220d6508654ef52ef11d76e3d", "patch": "@@ -2126,24 +2126,26 @@ cgraph_node::expand (void)\n   /* If requested, warn about function definitions where the function will\n      return a value (usually of some struct or union type) which itself will\n      take up a lot of stack space.  */\n-  if (warn_larger_than && !DECL_EXTERNAL (decl) && TREE_TYPE (decl))\n+  if (!DECL_EXTERNAL (decl) && TREE_TYPE (decl))\n     {\n       tree ret_type = TREE_TYPE (TREE_TYPE (decl));\n \n       if (ret_type && TYPE_SIZE_UNIT (ret_type)\n \t  && TREE_CODE (TYPE_SIZE_UNIT (ret_type)) == INTEGER_CST\n \t  && compare_tree_int (TYPE_SIZE_UNIT (ret_type),\n-\t\t\t       larger_than_size) > 0)\n+\t\t\t       warn_larger_than_size) > 0)\n \t{\n \t  unsigned int size_as_int\n \t    = TREE_INT_CST_LOW (TYPE_SIZE_UNIT (ret_type));\n \n \t  if (compare_tree_int (TYPE_SIZE_UNIT (ret_type), size_as_int) == 0)\n-\t    warning (OPT_Wlarger_than_, \"size of return value of %q+D is %u bytes\",\n+\t    warning (OPT_Wlarger_than_,\n+\t\t     \"size of return value of %q+D is %u bytes\",\n                      decl, size_as_int);\n \t  else\n-\t    warning (OPT_Wlarger_than_, \"size of return value of %q+D is larger than %wd bytes\",\n-                     decl, larger_than_size);\n+\t    warning (OPT_Wlarger_than_,\n+\t\t     \"size of return value of %q+D is larger than %wu bytes\",\n+\t             decl, warn_larger_than_size);\n \t}\n     }\n "}, {"sha": "4bf8de903318efeb906c8b7a0be678918a42aafc", "filename": "gcc/common.opt", "status": "modified", "additions": 6, "deletions": 23, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=00abf86c47606f8220d6508654ef52ef11d76e3d", "patch": "@@ -74,23 +74,6 @@ int flag_generate_lto\n Variable\n int flag_generate_offload = 0\n \n-; True to warn about any objects definitions whose size is larger\n-; than N bytes.  Also want about function definitions whose returned\n-; values are larger than N bytes, where N is 'larger_than_size'.\n-Variable\n-bool warn_larger_than\n-\n-Variable\n-HOST_WIDE_INT larger_than_size\n-\n-; True to warn about any function whose frame size is larger\n-; than N bytes.\n-Variable\n-bool warn_frame_larger_than\n-\n-Variable\n-HOST_WIDE_INT frame_larger_than_size\n-\n ; Nonzero means we should be saving declaration info into a .X file.\n Variable\n int flag_gen_aux_info = 0\n@@ -613,8 +596,8 @@ Common Var(flag_fatal_errors)\n Exit on the first error occurred.\n \n Wframe-larger-than=\n-Common RejectNegative Joined UInteger Warning\n--Wframe-larger-than=<number>\tWarn if a function's stack frame requires more than <number> bytes.\n+Common RejectNegative Joined Host_Wide_Int ByteSize Warning Var(warn_frame_larger_than_size) Init(HOST_WIDE_INT_MAX)\n+-Wframe-larger-than=<byte-size>\tWarn if a function's stack frame requires in excess of <byte-size>.\n \n Wfree-nonheap-object\n Common Var(warn_free_nonheap_object) Init(1) Warning\n@@ -643,8 +626,8 @@ Wlarger-than-\n Common RejectNegative Joined Warning Undocumented Alias(Wlarger-than=)\n \n Wlarger-than=\n-Common RejectNegative Joined UInteger Warning\n--Wlarger-than=<number>\tWarn if an object is larger than <number> bytes.\n+Common RejectNegative Joined Host_Wide_Int ByteSize Warning Var(warn_larger_than_size) Init(HOST_WIDE_INT_MAX)\n+-Wlarger-than=<byte-size>\tWarn if an object's size exceeds <byte-size>.\n \n Wnonnull-compare\n Var(warn_nonnull_compare) Warning\n@@ -716,8 +699,8 @@ Common Var(warn_stack_protect) Warning\n Warn when not issuing stack smashing protection for some reason.\n \n Wstack-usage=\n-Common Joined RejectNegative UInteger Var(warn_stack_usage) Warning\n--Wstack-usage=<number>\tWarn if stack usage might be larger than specified amount.\n+Common Joined RejectNegative Host_Wide_Int ByteSize Var(warn_stack_usage) Warning Init(HOST_WIDE_INT_MAX)\n+-Wstack-usage=<byte-size>\tWarn if stack usage might exceed <byte-size>.\n \n Wstrict-aliasing\n Common Warning"}, {"sha": "1dcdfb51c470a3a5b45affe58189288626153219", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 118, "deletions": 45, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=00abf86c47606f8220d6508654ef52ef11d76e3d", "patch": "@@ -121,6 +121,21 @@ these have both positive and negative forms; the negative form of\n @option{-ffoo} is @option{-fno-foo}.  This manual documents\n only one of these two forms, whichever one is not the default.\n \n+Some options take one or more arguments typically separated either\n+by a space or by the equals sign (@samp{=}) from the option name.\n+Unless documented otherwise, an argument can be either numeric or\n+a string.  Numeric arguments must typically be small unsigned decimal\n+or hexadecimal integers.  Hexadecimal arguments must begin with\n+the @samp{0x} prefix.  Arguments to options that specify a size\n+threshold of some sort may be arbitrarily large decimal or hexadecimal\n+integers followed by a byte size suffix designating a multiple of bytes\n+such as @code{kB} and @code{KiB} for kilobyte and kibibyte, respectively,\n+@code{MB} and @code{MiB} for megabyte and mebibyte, @code{GB} and\n+@code{GiB} for gigabyte and gigibyte, and so on.  Such arguments are\n+designated by @var{byte-size} in the following text.  Refer to the NIST,\n+IEC, and other relevant national and international standards for the full\n+listing and explanation of the binary and decimal byte size prefixes.\n+\n @c man end\n \n @xref{Option Index}, for an index to GCC's options.\n@@ -261,8 +276,8 @@ Objective-C and Objective-C++ Dialects}.\n @gccoptlist{-fsyntax-only  -fmax-errors=@var{n}  -Wpedantic @gol\n -pedantic-errors @gol\n -w  -Wextra  -Wall  -Waddress  -Waggregate-return  @gol\n--Walloc-zero  -Walloc-size-larger-than=@var{n}\n--Walloca  -Walloca-larger-than=@var{n} @gol\n+-Walloc-zero  -Walloc-size-larger-than=@var{byte-size}\n+-Walloca  -Walloca-larger-than=@var{byte-size} @gol\n -Wno-aggressive-loop-optimizations  -Warray-bounds  -Warray-bounds=@var{n} @gol\n -Wno-attributes  -Wbool-compare  -Wbool-operation @gol\n -Wno-builtin-declaration-mismatch @gol\n@@ -285,14 +300,15 @@ Objective-C and Objective-C++ Dialects}.\n -Wformat-nonliteral -Wformat-overflow=@var{n} @gol\n -Wformat-security  -Wformat-signedness  -Wformat-truncation=@var{n} @gol\n -Wformat-y2k  -Wframe-address @gol\n--Wframe-larger-than=@var{len}  -Wno-free-nonheap-object  -Wjump-misses-init @gol\n+-Wframe-larger-than=@var{byte-size}  -Wno-free-nonheap-object @gol\n+-Wjump-misses-init @gol\n -Wif-not-aligned @gol\n -Wignored-qualifiers  -Wignored-attributes  -Wincompatible-pointer-types @gol\n -Wimplicit  -Wimplicit-fallthrough  -Wimplicit-fallthrough=@var{n} @gol\n -Wimplicit-function-declaration  -Wimplicit-int @gol\n -Winit-self  -Winline  -Wno-int-conversion  -Wint-in-bool-context @gol\n -Wno-int-to-pointer-cast  -Winvalid-memory-model  -Wno-invalid-offsetof @gol\n--Winvalid-pch  -Wlarger-than=@var{len} @gol\n+-Winvalid-pch  -Wlarger-than=@var{byte-size} @gol\n -Wlogical-op  -Wlogical-not-parentheses  -Wlong-long @gol\n -Wmain  -Wmaybe-uninitialized  -Wmemset-elt-size  -Wmemset-transposed-args @gol\n -Wmisleading-indentation  -Wmissing-attributes -Wmissing-braces @gol\n@@ -313,7 +329,7 @@ Objective-C and Objective-C++ Dialects}.\n -Wsign-compare  -Wsign-conversion  -Wfloat-conversion @gol\n -Wno-scalar-storage-order  -Wsizeof-pointer-div @gol\n -Wsizeof-pointer-memaccess  -Wsizeof-array-argument @gol\n--Wstack-protector  -Wstack-usage=@var{len}  -Wstrict-aliasing @gol\n+-Wstack-protector  -Wstack-usage=@var{byte-size}  -Wstrict-aliasing @gol\n -Wstrict-aliasing=n  -Wstrict-overflow  -Wstrict-overflow=@var{n} @gol\n -Wstringop-overflow=@var{n} -Wstringop-truncation @gol\n -Wsuggest-attribute=@r{[}pure@r{|}const@r{|}noreturn@r{|}format@r{|}malloc@r{]} @gol\n@@ -331,7 +347,8 @@ Objective-C and Objective-C++ Dialects}.\n -Wunused-const-variable  -Wunused-const-variable=@var{n} @gol\n -Wunused-but-set-parameter  -Wunused-but-set-variable @gol\n -Wuseless-cast  -Wvariadic-macros  -Wvector-operation-performance @gol\n--Wvla  -Wvla-larger-than=@var{n}  -Wvolatile-register-var  -Wwrite-strings @gol\n+-Wvla  -Wvla-larger-than=@var{byte-size}  -Wvolatile-register-var @gol\n+-Wwrite-strings @gol\n -Wzero-as-null-pointer-constant  -Whsa}\n \n @item C and Objective-C-only Warning Options\n@@ -5523,33 +5540,39 @@ when called with a zero size differs among implementations (and in the case\n of @code{realloc} has been deprecated) relying on it may result in subtle\n portability bugs and should be avoided.\n \n-@item -Walloc-size-larger-than=@var{n}\n-@opindex Walloc-size-larger-than=@var{n}\n+@item -Walloc-size-larger-than=@var{byte-size}\n+@opindex Walloc-size-larger-than=\n @opindex Wno-alloc-size-larger-than\n Warn about calls to functions decorated with attribute @code{alloc_size}\n that attempt to allocate objects larger than the specified number of bytes,\n or where the result of the size computation in an integer type with infinite\n-precision would exceed @code{SIZE_MAX / 2}.  The option argument @var{n} is\n-treated as an integer with infinite precision and may end in one of\n-the standard suffixes designating a multiple of bytes such as @code{kB} and\n-@code{KiB} for kilobyte and kibibyte, respectively, @code{MB} and @code{MiB}\n-for megabyte and mebibyte, and so on.\n-@option{-Walloc-size-larger-than=}@var{PTRDIFF_MAX} is enabled by default.\n+precision would exceed the value of @samp{PTRDIFF_MAX} on the target.\n+@option{-Walloc-size-larger-than=}@samp{PTRDIFF_MAX} is enabled by default.\n Warnings controlled by the option can be disabled either by specifying\n-@var{n} of @var{SIZE_MAX} or more or by @option{-Wno-alloc-size-larger-than}.\n+@var{byte-size} of @samp{SIZE_MAX} or more or by\n+@option{-Wno-alloc-size-larger-than}.\n @xref{Function Attributes}.\n \n+@item -Wno-alloc-size-larger-than\n+@opindex Wno-alloc-size-larger-than\n+Disable @option{-Walloc-size-larger-than=} warnings.  The option is\n+equivalent to @option{-Walloc-size-larger-than=}@samp{SIZE_MAX} or\n+larger.\n+\n @item -Walloca\n @opindex Wno-alloca\n @opindex Walloca\n This option warns on all uses of @code{alloca} in the source.\n \n-@item -Walloca-larger-than=@var{n}\n-This option warns on calls to @code{alloca} that are not bounded by a\n-controlling predicate limiting its argument of integer type to at most\n-@var{n} bytes, or calls to @code{alloca} where the bound is unknown.\n-Arguments of non-integer types are considered unbounded even if they\n-appear to be constrained to the expected range.\n+@item -Walloca-larger-than=@var{byte-size}\n+@opindex -Walloca-larger-than=\n+@opindex -Wno-alloca-larger-than\n+This option warns on calls to @code{alloca} with an integer argument whose\n+value is either zero, or that is not bounded by a controlling predicate\n+that limits its value to at most @var{byte-size}.  It also warns for calls\n+to @code{alloca} where the bound value is unknown.  Arguments of non-integer\n+types are considered unbounded even if they appear to be constrained to\n+the expected range.\n \n For example, a bounded case of @code{alloca} could be:\n \n@@ -5603,10 +5626,16 @@ expected argument to be implicitly cast into the @code{alloca} call.\n \n This option also warns when @code{alloca} is used in a loop.\n \n-This warning is not enabled by @option{-Wall}, and is only active when\n-@option{-ftree-vrp} is active (default for @option{-O2} and above).\n+@option{-Walloca-larger-than=}@samp{PTRDIFF_MAX} is enabled by default\n+but is usually only effective  when @option{-ftree-vrp} is active (default\n+for @option{-O2} and above).\n \n-See also @option{-Wvla-larger-than=@var{n}}.\n+See also @option{-Wvla-larger-than=}@samp{byte-size}.\n+\n+@item -Wno-alloca-larger-than\n+@opindex Wno-alloca-larger-than\n+Disable @option{-Walloca-larger-than=} warnings.  The option is\n+equivalent to @option{-Walloca-larger-than=}@samp{SIZE_MAX} or larger.\n \n @item -Warray-bounds\n @itemx -Warray-bounds=@var{n}\n@@ -5954,33 +5983,51 @@ possibly reduce the number of warnings triggered by intentional shadowing.\n \n This warning is enabled by @option{-Wshadow=local}.\n \n-@item -Wlarger-than=@var{len}\n-@opindex Wlarger-than=@var{len}\n-@opindex Wlarger-than-@var{len}\n-Warn whenever an object of larger than @var{len} bytes is defined.\n-\n-@item -Wframe-larger-than=@var{len}\n-@opindex Wframe-larger-than=@var{len}\n-@opindex Wframe-larger-than\n-Warn if the size of a function frame is larger than @var{len} bytes.\n+@item -Wlarger-than=@var{byte-size}\n+@opindex Wlarger-than=\n+@opindex Wlarger-than-@var{byte-size}\n+Warn whenever an object is defined whose size exceeds @var{byte-size}.\n+@option{-Wlarger-than=}@samp{PTRDIFF_MAX} is enabled by default.\n+Warnings controlled by the option can be disabled either by specifying\n+@var{byte-size} of @samp{SIZE_MAX} or more or by\n+@option{-Wno-larger-than}.\n+\n+@item -Wno-larger-than\n+@opindex Wno-larger-than\n+Disable @option{-Wlarger-than=} warnings.  The option is equivalent\n+to @option{-Wlarger-than=}@samp{SIZE_MAX} or larger.\n+\n+@item -Wframe-larger-than=@var{byte-size}\n+@opindex Wframe-larger-than=\n+@opindex Wno-frame-larger-than\n+Warn if the size of a function frame exceeds @var{byte-size}.\n The computation done to determine the stack frame size is approximate\n and not conservative.\n-The actual requirements may be somewhat greater than @var{len}\n+The actual requirements may be somewhat greater than @var{byte-size}\n even if you do not get a warning.  In addition, any space allocated\n via @code{alloca}, variable-length arrays, or related constructs\n is not included by the compiler when determining\n whether or not to issue a warning.\n+@option{-Wframe-larger-than=}@samp{PTRDIFF_MAX} is enabled by default.\n+Warnings controlled by the option can be disabled either by specifying\n+@var{byte-size} of @samp{SIZE_MAX} or more or by\n+@option{-Wno-frame-larger-than}.\n+\n+@item -Wno-frame-larger-than\n+@opindex Wno-frame-larger-than\n+Disable @option{-Wframe-larger-than=} warnings.  The option is equivalent\n+to @option{-Wframe-larger-than=}@samp{SIZE_MAX} or larger.\n \n @item -Wno-free-nonheap-object\n @opindex Wno-free-nonheap-object\n @opindex Wfree-nonheap-object\n Do not warn when attempting to free an object that was not allocated\n on the heap.\n \n-@item -Wstack-usage=@var{len}\n+@item -Wstack-usage=@var{byte-size}\n @opindex Wstack-usage\n @opindex Wno-stack-usage\n-Warn if the stack usage of a function might be larger than @var{len} bytes.\n+Warn if the stack usage of a function might exceed @var{byte-size}.\n The computation done to determine the stack usage is conservative.\n Any space allocated via @code{alloca}, variable-length arrays, or related\n constructs is included by the compiler when determining whether or not to\n@@ -6009,6 +6056,24 @@ If the stack usage is (partly) dynamic and not bounded, it's:\n @end smallexample\n @end itemize\n \n+@option{-Wstack-usage=}@samp{PTRDIFF_MAX} is enabled by default.\n+Warnings controlled by the option can be disabled either by specifying\n+@var{byte-size} of @samp{SIZE_MAX} or more or by\n+@option{-Wno-stack-usage}.\n+\n+@item -Wno-stack-usage\n+@opindex Wno-stack-usage\n+Disable @option{-Wstack-usage=} warnings.  The option is equivalent\n+to @option{-Wstack-usage=}@samp{SIZE_MAX} or larger.\n+\n+@item -Wunsafe-loop-optimizations\n+@opindex Wunsafe-loop-optimizations\n+@opindex Wno-unsafe-loop-optimizations\n+Warn if the loop cannot be optimized because the compiler cannot\n+assume anything on the bounds of the loop indices.  With\n+@option{-funsafe-loop-optimizations} warn if the compiler makes\n+such assumptions.\n+\n @item -Wno-pedantic-ms-format @r{(MinGW targets only)}\n @opindex Wno-pedantic-ms-format\n @opindex Wpedantic-ms-format\n@@ -7011,21 +7076,29 @@ Warn if a variable-length array is used in the code.\n @option{-Wno-vla} prevents the @option{-Wpedantic} warning of\n the variable-length array.\n \n-@item -Wvla-larger-than=@var{n}\n-If this option is used, the compiler will warn on uses of\n-variable-length arrays where the size is either unbounded, or bounded\n-by an argument that can be larger than @var{n} bytes.  This is similar\n-to how @option{-Walloca-larger-than=@var{n}} works, but with\n-variable-length arrays.\n+@item -Wvla-larger-than=@var{byte-size}\n+@opindex -Wvla-larger-than=\n+@opindex -Wno-vla-larger-than\n+If this option is used, the compiler will warn for declarations of\n+variable-length arrays whose size is either unbounded, or bounded\n+by an argument that allows the array size to exceed @var{byte-size}\n+bytes.  This is similar to how @option{-Walloca-larger-than=}@var{byte-size}\n+works, but with variable-length arrays.\n \n Note that GCC may optimize small variable-length arrays of a known\n value into plain arrays, so this warning may not get triggered for\n such arrays.\n \n-This warning is not enabled by @option{-Wall}, and is only active when\n-@option{-ftree-vrp} is active (default for @option{-O2} and above).\n+@option{-Wvla-larger-than=}@samp{PTRDIFF_MAX} is enabled by default but\n+is typically only effective when @option{-ftree-vrp} is active (default\n+for @option{-O2} and above).\n+\n+See also @option{-Walloca-larger-than=@var{byte-size}}.\n \n-See also @option{-Walloca-larger-than=@var{n}}.\n+@item -Wno-vla-larger-than\n+@opindex Wno-vla-larger-than\n+Disable @option{-Wvla-larger-than=} warnings.  The option is equivalent\n+to @option{-Wvla-larger-than=}@samp{SIZE_MAX} or larger.\n \n @item -Wvolatile-register-var\n @opindex Wvolatile-register-var"}, {"sha": "f887d16f88f8e22d280d0ab20a6fde05eb86e3d8", "filename": "gcc/doc/options.texi", "status": "modified", "additions": 34, "deletions": 9, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Fdoc%2Foptions.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Fdoc%2Foptions.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Foptions.texi?ref=00abf86c47606f8220d6508654ef52ef11d76e3d", "patch": "@@ -257,17 +257,42 @@ For an option marked @code{Separate}, indicate that it takes @var{n}\n arguments.  The default is 1.\n \n @item UInteger\n-The option's argument is a non-negative integer.  The option parser\n-will check and convert the argument before passing it to the relevant\n-option handler.  @code{UInteger} should also be used on options like\n-@code{-falign-loops} where both @code{-falign-loops} and\n-@code{-falign-loops}=@var{n} are supported to make sure the saved\n-options are given a full integer.\n+The option's argument is a non-negative integer consisting of either\n+decimal or hexadecimal digits interpreted as @code{int}.  Hexadecimal\n+integers may optionally start with the @code{0x} or @code{0X} prefix.\n+The option parser validates and converts the argument before passing\n+it to the relevant option handler.  @code{UInteger} should also be used\n+with options like @code{-falign-loops} where both @code{-falign-loops}\n+and @code{-falign-loops}=@var{n} are supported to make sure the saved\n+options are given a full integer.  Positive values of the argument in\n+excess of @code{INT_MAX} wrap around zero.\n+\n+@item Host_Wide_Int\n+The option's argument is a non-negative integer consisting of either\n+decimal or hexadecimal digits interpreted as the widest integer type\n+on the host.  As with an @code{UInteger} argument, hexadecimal integers\n+may optionally start with the @code{0x} or @code{0X} prefix.  The option\n+parser validates and converts the argument before passing it to\n+the relevant option handler.  @code{Host_Wide_Int} should be used with\n+options that need to accept very large values.  Positive values of\n+the argument in excess of @code{HOST_WIDE_INT_M1U} are assigned\n+@code{HOST_WIDE_INT_M1U}.\n \n @item IntegerRange(@var{n}, @var{m})\n-The options's arguments are integer numbers.  The option's parser\n-will check that value of an option is inclusively within the\n-range [@var{n}, @var{m}].\n+The options's arguments are integers of type @code{int}.  The option's\n+parser validates that the value of an option integer argument is within\n+the closed range [@var{n}, @var{m}].\n+\n+@item ByteSize\n+A property applicable only to @code{UInteger} or @code{Host_Wide_Int}\n+arguments.  The option's integer argument is interpreted as if in infinite\n+precision using saturation arithmetic in the corresponding type.  The argument\n+may be followed by a @samp{byte-size} suffix designating a multiple of bytes\n+such as @code{kB} and @code{KiB} for kilobyte and kibibyte, respectively,\n+@code{MB} and @code{MiB} for megabyte and mebibyte, @code{GB} and @code{GiB}\n+for gigabyte and gigibyte, and so on.  @code{ByteSize} should be used for\n+with options that take a very large argument representing a size in bytes,\n+such as @option{-Wlarger-than=}.\n \n @item ToLower\n The option's argument should be converted to lowercase as part of"}, {"sha": "6fa4acdaa2e950cfb26a50c8475378f3ab16e4ff", "filename": "gcc/final.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=00abf86c47606f8220d6508654ef52ef11d76e3d", "patch": "@@ -1778,14 +1778,14 @@ final_start_function_1 (rtx_insn **firstp, FILE *file, int *seen,\n       TREE_ASM_WRITTEN (DECL_INITIAL (current_function_decl)) = 1;\n     }\n \n-  HOST_WIDE_INT min_frame_size = constant_lower_bound (get_frame_size ());\n-  if (warn_frame_larger_than\n-      && min_frame_size > frame_larger_than_size)\n+  unsigned HOST_WIDE_INT min_frame_size\n+    = constant_lower_bound (get_frame_size ());\n+  if (min_frame_size > (unsigned HOST_WIDE_INT) warn_frame_larger_than_size)\n     {\n       /* Issue a warning */\n       warning (OPT_Wframe_larger_than_,\n-\t       \"the frame size of %wd bytes is larger than %wd bytes\",\n-\t       min_frame_size, frame_larger_than_size);\n+\t       \"the frame size of %wu bytes is larger than %wu bytes\",\n+\t       min_frame_size, warn_frame_larger_than_size);\n     }\n \n   /* First output the function prologue: code to set up the stack frame.  */"}, {"sha": "27d57eb2fb1fb9e0bd76a457b7635855756a74f2", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=00abf86c47606f8220d6508654ef52ef11d76e3d", "patch": "@@ -1,3 +1,10 @@\n+2018-07-20  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/82063\n+\t* gfortran.h (gfc_handle_option): Change function argument\n+\tto HOST_WIDE_INT.\n+\t* options.c (gfc_handle_option): Same.\n+\n 2018-07-20  Andrew Benson  <abenson@carnegiescience.edu>\n \n \t* gfortran.h (gfc_symbol): Add pointer to next derived type."}, {"sha": "04b0024a992defe8f55f81c6e446d2a4dfd0d8ac", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=00abf86c47606f8220d6508654ef52ef11d76e3d", "patch": "@@ -2830,7 +2830,7 @@ unsigned int gfc_option_lang_mask (void);\n void gfc_init_options_struct (struct gcc_options *);\n void gfc_init_options (unsigned int,\n \t\t       struct cl_decoded_option *);\n-bool gfc_handle_option (size_t, const char *, int, int, location_t,\n+bool gfc_handle_option (size_t, const char *, HOST_WIDE_INT, int, location_t,\n \t\t\tconst struct cl_option_handlers *);\n bool gfc_post_options (const char **);\n char *gfc_get_option_string (void);"}, {"sha": "af937511347a169ee065f474bdb4170c25a56839", "filename": "gcc/fortran/options.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Ffortran%2Foptions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Ffortran%2Foptions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Foptions.c?ref=00abf86c47606f8220d6508654ef52ef11d76e3d", "patch": "@@ -585,7 +585,7 @@ gfc_handle_runtime_check_option (const char *arg)\n    recognized and handled.  */\n \n bool\n-gfc_handle_option (size_t scode, const char *arg, int value,\n+gfc_handle_option (size_t scode, const char *arg, HOST_WIDE_INT value,\n \t\t   int kind ATTRIBUTE_UNUSED, location_t loc ATTRIBUTE_UNUSED,\n \t\t   const struct cl_option_handlers *handlers ATTRIBUTE_UNUSED)\n {"}, {"sha": "dee303cdbdd430a610640a3d1743c42b6d4ea902", "filename": "gcc/function.c", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=00abf86c47606f8220d6508654ef52ef11d76e3d", "patch": "@@ -242,8 +242,15 @@ frame_offset_overflow (poly_int64 offset, tree func)\n \n   if (!coeffs_in_range_p (size, 0U, limit))\n     {\n-      error_at (DECL_SOURCE_LOCATION (func),\n-\t\t\"total size of local objects too large\");\n+      unsigned HOST_WIDE_INT hwisize;\n+      if (size.is_constant (&hwisize))\n+\terror_at (DECL_SOURCE_LOCATION (func),\n+\t\t  \"total size of local objects %wu exceeds maximum %wu\",\n+\t\t  hwisize, limit);\n+      else\n+\terror_at (DECL_SOURCE_LOCATION (func),\n+\t\t  \"total size of local objects exceeds maximum %wu\",\n+\t\t  limit);\n       return true;\n     }\n "}, {"sha": "cc66c466217bb5ca1eb6cbd8589731d1de3e707b", "filename": "gcc/gimple-ssa-warn-alloca.c", "status": "modified", "additions": 69, "deletions": 26, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Fgimple-ssa-warn-alloca.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Fgimple-ssa-warn-alloca.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-warn-alloca.c?ref=00abf86c47606f8220d6508654ef52ef11d76e3d", "patch": "@@ -33,6 +33,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-ssa.h\"\n #include \"params.h\"\n #include \"tree-cfg.h\"\n+#include \"builtins.h\"\n #include \"calls.h\"\n #include \"cfgloop.h\"\n #include \"intl.h\"\n@@ -78,8 +79,10 @@ pass_walloca::gate (function *fun ATTRIBUTE_UNUSED)\n   if (first_time_p)\n     return warn_alloca != 0;\n \n-  return ((unsigned HOST_WIDE_INT) warn_alloca_limit > 0\n-\t  || (unsigned HOST_WIDE_INT) warn_vla_limit > 0);\n+  // Warning is disabled when its size limit is greater than PTRDIFF_MAX\n+  // for the target maximum, which makes the limit negative since when\n+  // represented in signed HOST_WIDE_INT.\n+  return warn_alloca_limit >= 0 || warn_vla_limit >= 0;\n }\n \n // Possible problematic uses of alloca.\n@@ -150,21 +153,33 @@ struct alloca_type_and_limit {\n // in bytes we allow for arg.\n \n static struct alloca_type_and_limit\n-alloca_call_type_by_arg (tree arg, tree arg_casted, edge e, unsigned max_size)\n+alloca_call_type_by_arg (tree arg, tree arg_casted, edge e,\n+\t\t\t unsigned HOST_WIDE_INT max_size)\n {\n   basic_block bb = e->src;\n   gimple_stmt_iterator gsi = gsi_last_bb (bb);\n   gimple *last = gsi_stmt (gsi);\n+\n+  const offset_int maxobjsize = tree_to_shwi (max_object_size ());\n+\n+  /* When MAX_SIZE is greater than or equal to PTRDIFF_MAX treat\n+     allocations that aren't visibly constrained as OK, otherwise\n+     report them as (potentially) unbounded.  */\n+  alloca_type unbounded_result = (max_size < maxobjsize.to_uhwi ()\n+\t\t\t\t  ? ALLOCA_UNBOUNDED : ALLOCA_OK);\n+\n   if (!last || gimple_code (last) != GIMPLE_COND)\n-    return alloca_type_and_limit (ALLOCA_UNBOUNDED);\n+    {\n+      return alloca_type_and_limit (unbounded_result);\n+    }\n \n   enum tree_code cond_code = gimple_cond_code (last);\n   if (e->flags & EDGE_TRUE_VALUE)\n     ;\n   else if (e->flags & EDGE_FALSE_VALUE)\n     cond_code = invert_tree_comparison (cond_code, false);\n   else\n-    return alloca_type_and_limit (ALLOCA_UNBOUNDED);\n+      return alloca_type_and_limit (unbounded_result);\n \n   // Check for:\n   //   if (ARG .COND. N)\n@@ -229,10 +244,10 @@ alloca_call_type_by_arg (tree arg, tree arg_casted, edge e, unsigned max_size)\n       //\n       // If this ever triggers, we should probably figure out why and\n       // handle it, though it is likely to be just an ALLOCA_UNBOUNDED.\n-      return alloca_type_and_limit (ALLOCA_UNBOUNDED);\n+      return alloca_type_and_limit (unbounded_result);\n     }\n \n-  return alloca_type_and_limit (ALLOCA_UNBOUNDED);\n+  return alloca_type_and_limit (unbounded_result);\n }\n \n // Return TRUE if SSA's definition is a cast from a signed type.\n@@ -281,16 +296,16 @@ alloca_call_type (gimple *stmt, bool is_vla, tree *invalid_casted_type)\n   edge_iterator ei;\n   edge e;\n \n-  gcc_assert (!is_vla || (unsigned HOST_WIDE_INT) warn_vla_limit > 0);\n-  gcc_assert (is_vla || (unsigned HOST_WIDE_INT) warn_alloca_limit > 0);\n+  gcc_assert (!is_vla || warn_vla_limit >= 0);\n+  gcc_assert (is_vla || warn_alloca_limit >= 0);\n \n   // Adjust warn_alloca_max_size for VLAs, by taking the underlying\n   // type into account.\n   unsigned HOST_WIDE_INT max_size;\n   if (is_vla)\n-    max_size = (unsigned HOST_WIDE_INT) warn_vla_limit;\n+    max_size = warn_vla_limit;\n   else\n-    max_size = (unsigned HOST_WIDE_INT) warn_alloca_limit;\n+    max_size = warn_alloca_limit;\n \n   // Check for the obviously bounded case.\n   if (TREE_CODE (len) == INTEGER_CST)\n@@ -299,7 +314,13 @@ alloca_call_type (gimple *stmt, bool is_vla, tree *invalid_casted_type)\n \treturn alloca_type_and_limit (ALLOCA_BOUND_DEFINITELY_LARGE,\n \t\t\t\t      wi::to_wide (len));\n       if (integer_zerop (len))\n-\treturn alloca_type_and_limit (ALLOCA_ARG_IS_ZERO);\n+\t{\n+\t  const offset_int maxobjsize\n+\t    = wi::to_offset (max_object_size ());\n+\t  alloca_type result = (max_size < maxobjsize\n+\t\t\t\t? ALLOCA_ARG_IS_ZERO : ALLOCA_OK);\n+\t  return alloca_type_and_limit (result);\n+\t}\n \n       return alloca_type_and_limit (ALLOCA_OK);\n     }\n@@ -357,8 +378,15 @@ alloca_call_type (gimple *stmt, bool is_vla, tree *invalid_casted_type)\n \t\t}\n \t      else if (range_type == VR_ANTI_RANGE)\n \t\treturn alloca_type_and_limit (ALLOCA_UNBOUNDED);\n-\t      else if (range_type != VR_VARYING)\n-\t\treturn alloca_type_and_limit (ALLOCA_BOUND_MAYBE_LARGE, max);\n+\n+\t      if (range_type != VR_VARYING)\n+\t\t{\n+\t\t  const offset_int maxobjsize\n+\t\t    = wi::to_offset (max_object_size ());\n+\t\t  alloca_type result = (max_size < maxobjsize\n+\t\t\t\t\t? ALLOCA_BOUND_MAYBE_LARGE : ALLOCA_OK);\n+\t\t  return alloca_type_and_limit (result, max);\n+\t\t}\n \t    }\n \t}\n       else if (range_type == VR_ANTI_RANGE)\n@@ -414,8 +442,13 @@ alloca_call_type (gimple *stmt, bool is_vla, tree *invalid_casted_type)\n       if (compare_tree_int (arg, max_size) <= 0)\n \tret = alloca_type_and_limit (ALLOCA_OK);\n       else\n-\tret = alloca_type_and_limit (ALLOCA_BOUND_MAYBE_LARGE,\n-\t\t\t\t     wi::to_wide (arg));\n+\t{\n+\t  const offset_int maxobjsize\n+\t    = wi::to_offset (max_object_size ());\n+\t  alloca_type result = (max_size < maxobjsize\n+\t\t\t\t? ALLOCA_BOUND_MAYBE_LARGE : ALLOCA_OK);\n+\t  ret = alloca_type_and_limit (result, wi::to_wide (arg));\n+\t}\n     }\n \n   return ret;\n@@ -452,16 +485,18 @@ pass_walloca::execute (function *fun)\n \t  // Strict mode whining for VLAs is handled by the front-end,\n \t  // so we can safely ignore this case.  Also, ignore VLAs if\n \t  // the user doesn't care about them.\n-\t  if (is_vla\n-\t      && (warn_vla > 0 || !warn_vla_limit))\n-\t    continue;\n-\n-\t  if (!is_vla && (warn_alloca || !warn_alloca_limit))\n+\t  if (is_vla)\n \t    {\n-\t      if (warn_alloca)\n-\t\twarning_at (loc, OPT_Walloca, G_(\"use of %<alloca%>\"));\n+\t      if (warn_vla > 0 || warn_vla_limit < 0)\n+\t\tcontinue;\n+\t    }\n+\t  else if (warn_alloca)\n+\t    {\n+\t      warning_at (loc, OPT_Walloca, G_(\"use of %<alloca%>\"));\n \t      continue;\n \t    }\n+\t  else if (warn_alloca_limit < 0)\n+\t    continue;\n \n \t  tree invalid_casted_type = NULL;\n \t  struct alloca_type_and_limit t\n@@ -471,7 +506,15 @@ pass_walloca::execute (function *fun)\n \t  // loop, except for a VLA, since VLAs are guaranteed to be cleaned\n \t  // up when they go out of scope, including in a loop.\n \t  if (t.type == ALLOCA_OK && !is_vla && in_loop_p (stmt))\n-\t    t = alloca_type_and_limit (ALLOCA_IN_LOOP);\n+\t    {\n+\t      /* As in other instances, only diagnose this when the limit\n+\t\t is less than the maximum valid object size.  */\n+\t      const offset_int maxobjsize\n+\t\t= wi::to_offset (max_object_size ());\n+\t      if ((unsigned HOST_WIDE_INT) warn_alloca_limit\n+\t\t  < maxobjsize.to_uhwi ())\n+\t\tt = alloca_type_and_limit (ALLOCA_IN_LOOP);\n+\t    }\n \n \t  enum opt_code wcode\n \t    = is_vla ? OPT_Wvla_larger_than_ : OPT_Walloca_larger_than_;\n@@ -488,7 +531,7 @@ pass_walloca::execute (function *fun)\n \t\t  && t.limit != 0)\n \t\t{\n \t\t  print_decu (t.limit, buff);\n-\t\t  inform (loc, G_(\"limit is %u bytes, but argument \"\n+\t\t  inform (loc, G_(\"limit is %wu bytes, but argument \"\n \t\t\t\t  \"may be as large as %s\"),\n \t\t\t  is_vla ? warn_vla_limit : warn_alloca_limit, buff);\n \t\t}\n@@ -501,7 +544,7 @@ pass_walloca::execute (function *fun)\n \t\t  && t.limit != 0)\n \t\t{\n \t\t  print_decu (t.limit, buff);\n-\t\t  inform (loc, G_(\"limit is %u bytes, but argument is %s\"),\n+\t\t  inform (loc, G_(\"limit is %wu bytes, but argument is %s\"),\n \t\t\t  is_vla ? warn_vla_limit : warn_alloca_limit, buff);\n \t\t}\n \t      break;"}, {"sha": "a392ed89bad0b753f8073dea1e2347bde608f9a2", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=00abf86c47606f8220d6508654ef52ef11d76e3d", "patch": "@@ -1,3 +1,9 @@\n+2018-07-20  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/82063\n+\t* go-lang.c (go_langhook_handle_option): Change function argument\n+\tto HOST_WIDE_INT.\n+\n 2018-06-28  Ian Lance Taylor  <iant@golang.org>\n \n \tPR go/86343"}, {"sha": "e76e1fc4f98ef69b97684212e2afc733e46effa1", "filename": "gcc/go/go-lang.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Fgo%2Fgo-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Fgo%2Fgo-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-lang.c?ref=00abf86c47606f8220d6508654ef52ef11d76e3d", "patch": "@@ -194,7 +194,7 @@ static bool\n go_langhook_handle_option (\n     size_t scode,\n     const char *arg,\n-    int value,\n+    HOST_WIDE_INT value,\n     int kind ATTRIBUTE_UNUSED,\n     location_t loc ATTRIBUTE_UNUSED,\n     const struct cl_option_handlers *handlers ATTRIBUTE_UNUSED)"}, {"sha": "27b8273b95ddb1a172a73df33d3daf32cc7f23c5", "filename": "gcc/langhooks-def.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Flanghooks-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Flanghooks-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks-def.h?ref=00abf86c47606f8220d6508654ef52ef11d76e3d", "patch": "@@ -70,8 +70,8 @@ extern void lhd_initialize_diagnostics (diagnostic_context *);\n extern void lhd_init_options (unsigned int,\n \t\t\t      struct cl_decoded_option *);\n extern bool lhd_complain_wrong_lang_p (const struct cl_option *);\n-extern bool lhd_handle_option (size_t, const char *, int, int, location_t,\n-\t\t\t       const struct cl_option_handlers *);\n+extern bool lhd_handle_option (size_t, const char *, HOST_WIDE_INT, int,\n+\t\t\t       location_t, const struct cl_option_handlers *);\n \n \n /* Declarations for tree gimplification hooks.  */"}, {"sha": "c7b5cf9f6c566be1b0fa05ae8ee2872f590585fd", "filename": "gcc/langhooks.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Flanghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Flanghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.c?ref=00abf86c47606f8220d6508654ef52ef11d76e3d", "patch": "@@ -353,7 +353,8 @@ lhd_complain_wrong_lang_p (const struct cl_option *option ATTRIBUTE_UNUSED)\n bool\n lhd_handle_option (size_t code ATTRIBUTE_UNUSED,\n \t\t   const char *arg ATTRIBUTE_UNUSED,\n-\t\t   int value ATTRIBUTE_UNUSED, int kind ATTRIBUTE_UNUSED,\n+\t\t   HOST_WIDE_INT value ATTRIBUTE_UNUSED,\n+\t\t   int kind ATTRIBUTE_UNUSED,\n \t\t   location_t loc ATTRIBUTE_UNUSED,\n \t\t   const struct cl_option_handlers *handlers ATTRIBUTE_UNUSED)\n {"}, {"sha": "8ad2ec763e1075592a8e153407073e108d8487df", "filename": "gcc/langhooks.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=00abf86c47606f8220d6508654ef52ef11d76e3d", "patch": "@@ -348,8 +348,8 @@ struct lang_hooks\n      location of the option.\n \n      Return true if the switch is valid, false if invalid.  */\n-  bool (*handle_option) (size_t code, const char *arg, int value, int kind,\n-\t\t\t location_t loc,\n+  bool (*handle_option) (size_t code, const char *arg, HOST_WIDE_INT value,\n+\t\t\t int kind, location_t loc,\n \t\t\t const struct cl_option_handlers *handlers);\n \n   /* Called when all command line options have been parsed to allow"}, {"sha": "eb239972d9e72cc7a5e4901b5d22640a3ddad8b7", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=00abf86c47606f8220d6508654ef52ef11d76e3d", "patch": "@@ -1,3 +1,9 @@\n+2018-07-20  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/82063\n+\t* lto-lang.c (lto_handle_option): Change function argument\n+\tto HOST_WIDE_INT.\n+\n 2018-07-20  Richard Biener  <rguenther@suse.de>\n \n \tPR debug/86585"}, {"sha": "de6ec1c077a9b267f4bd589c0ecaf964a442af57", "filename": "gcc/lto/lto-lang.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Flto%2Flto-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Flto%2Flto-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-lang.c?ref=00abf86c47606f8220d6508654ef52ef11d76e3d", "patch": "@@ -827,7 +827,8 @@ lto_init_options_struct (struct gcc_options *opts)\n const char *resolution_file_name;\n static bool\n lto_handle_option (size_t scode, const char *arg,\n-\t\t   int value ATTRIBUTE_UNUSED, int kind ATTRIBUTE_UNUSED,\n+\t\t   HOST_WIDE_INT value ATTRIBUTE_UNUSED,\n+\t\t   int kind ATTRIBUTE_UNUSED,\n \t\t   location_t loc ATTRIBUTE_UNUSED,\n \t\t   const struct cl_option_handlers *handlers ATTRIBUTE_UNUSED)\n {"}, {"sha": "6611bf340b555b8429c85c6d850f639135a6fcd5", "filename": "gcc/opt-functions.awk", "status": "modified", "additions": 35, "deletions": 6, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Fopt-functions.awk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Fopt-functions.awk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopt-functions.awk?ref=00abf86c47606f8220d6508654ef52ef11d76e3d", "patch": "@@ -113,9 +113,14 @@ function switch_flags (flags)\n # Return bit-field initializers for option flags FLAGS.\n function switch_bit_fields (flags)\n {\n+\tuinteger_flag = \"\"\n \tvn = var_name(flags);\n \tif (host_wide_int[vn] == \"yes\")\n \t\thwi = \"Host_Wide_Int\"\n+\telse if (flag_set_p(\"Host_Wide_Int\", flags)) {\n+\t\thwi = \"Host_Wide_Int\"\n+\t\tuinteger_flag = flag_init(\"UInteger\", flags)\n+\t}\n \telse\n \t\thwi = \"\"\n \tresult = \"\"\n@@ -126,18 +131,33 @@ function switch_bit_fields (flags)\n \t\tsep_args--\n \tresult = result sep_args \", \"\n \n+\tif (uinteger_flag == \"\")\n+\t\tuinteger_flag = flag_init(\"UInteger\", flags)\n+\n+\thwi_flag = flag_init(\"Host_Wide_Int\", hwi)\n+\tbyte_size_flag = flag_init(\"ByteSize\", flags)\n+\n+\tif (substr(byte_size_flag, 1, 1) != \"0\"\t\\\n+\t    && substr(uinteger_flag, 1, 1) == \"0\" \\\n+\t    && substr(hwi_flag, 1, 1) == \"0\")\n+\t  print \"#error only UInteger amd Host_Wide_Int options can specify a ByteSize suffix\"\n+\n+\t# The following flags need to be in the same order as\n+\t# the corresponding members of struct cl_option defined\n+\t# in gcc/opts.h.\n \tresult = result \\\n \t  flag_init(\"SeparateAlias\", flags) \\\n \t  flag_init(\"NegativeAlias\", flags) \\\n \t  flag_init(\"NoDriverArg\", flags) \\\n \t  flag_init(\"RejectDriver\", flags) \\\n \t  flag_init(\"RejectNegative\", flags) \\\n \t  flag_init(\"JoinedOrMissing\", flags) \\\n-\t  flag_init(\"UInteger\", flags) \\\n-\t  flag_init(\"Host_Wide_Int\", hwi) \\\n+\t  uinteger_flag \\\n+\t  hwi_flag \\\n \t  flag_init(\"ToLower\", flags) \\\n \t  flag_init(\"Report\", flags) \\\n-\t  flag_init(\"Deprecated\", flags)\n+\t  flag_init(\"Deprecated\", flags) \\\n+\t  byte_size_flag\n \n \tsub(\", $\", \"\", result)\n \treturn result\n@@ -200,6 +220,8 @@ function var_type(flags)\n \t}\n \telse if (!flag_set_p(\"Joined.*\", flags) && !flag_set_p(\"Separate\", flags))\n \t\treturn \"int \"\n+\telse if (flag_set_p(\"Host_Wide_Int\", flags))\n+\t\treturn \"HOST_WIDE_INT \"\n \telse if (flag_set_p(\"UInteger\", flags))\n \t\treturn \"int \"\n \telse\n@@ -211,8 +233,13 @@ function var_type(flags)\n # type instead of int to save space.\n function var_type_struct(flags)\n {\n-\tif (flag_set_p(\"UInteger\", flags))\n-\t\treturn \"int \"\n+\tif (flag_set_p(\"UInteger\", flags)) {\n+\t\tif (host_wide_int[var_name(flags)] == \"yes\")\n+\t\t\treturn \"HOST_WIDE_INT \";\n+\t\tif (flag_set_p(\"ByteSize\", flags))\n+\t\t\treturn \"HOST_WIDE_INT \"\n+\t  return \"int \"\n+\t}\n \telse if (flag_set_p(\"Enum.*\", flags)) {\n \t\ten = opt_args(\"Enum\", flags);\n \t\treturn enum_type[en] \" \"\n@@ -222,7 +249,7 @@ function var_type_struct(flags)\n \t\t\tif (host_wide_int[var_name(flags)] == \"yes\")\n \t\t\t\treturn \"HOST_WIDE_INT \"\n \t\t\telse\n-\t\t\t\treturn \"int \"\n+\t\t\t\treturn \"/* - */ int \"\n \t\t}\n \t\telse\n \t\t\treturn \"signed char \"\n@@ -262,6 +289,8 @@ function var_set(flags)\n \t}\n \tif (var_type(flags) == \"const char *\")\n \t\treturn \"0, CLVC_STRING, 0\"\n+\tif (flag_set_p(\"ByteSize\", flags))\n+\t\treturn \"0, CLVC_SIZE, 0\"\n \treturn \"0, CLVC_BOOLEAN, 0\"\n }\n "}, {"sha": "7eaca62c545faf17adb76c0d71dc1b6d4bff34da", "filename": "gcc/optc-gen.awk", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Foptc-gen.awk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Foptc-gen.awk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptc-gen.awk?ref=00abf86c47606f8220d6508654ef52ef11d76e3d", "patch": "@@ -274,6 +274,7 @@ for (i = 0; i < n_opts; i++) {\n \tj++;\n }\n \n+optindex = 0\n for (i = 0; i < n_opts; i++) {\n \t# With identical flags, pick only the last one.  The\n \t# earlier loop ensured that it has all flags merged,\n@@ -303,20 +304,20 @@ for (i = 0; i < n_opts; i++) {\n \t\tcomma = \"\"\n \n \tif (help[i] == \"\")\n-\t\thlp = \"0\"\n+\t\thlp = \"NULL\"\n \telse\n \t\thlp = quote help[i] quote;\n \n \tmissing_arg_error = opt_args(\"MissingArgError\", flags[i])\n \tif (missing_arg_error == \"\")\n-\t\tmissing_arg_error = \"0\"\n+\t\tmissing_arg_error = \"NULL\"\n \telse\n \t\tmissing_arg_error = quote missing_arg_error quote\n \n \n \twarn_message = opt_args(\"Warn\", flags[i])\n \tif (warn_message == \"\")\n-\t\twarn_message = \"0\"\n+\t\twarn_message = \"NULL\"\n \telse\n \t\twarn_message = quote warn_message quote\n \n@@ -378,10 +379,11 @@ for (i = 0; i < n_opts; i++) {\n \t}\n \t# Split the printf after %u to work around an ia64-hp-hpux11.23\n \t# awk bug.\n-\tprintf(\"  { %c-%s%c,\\n    %s,\\n    %s,\\n    %s,\\n    %s, %s, %u,\",\n+\tprintf(\" /* [%i] = */ {\\n\", optindex)\n+\tprintf(\"    %c-%s%c,\\n    %s,\\n    %s,\\n    %s,\\n    %s, %s, %u,\",\n \t       quote, opts[i], quote, hlp, missing_arg_error, warn_message,\n \t       alias_data, back_chain[i], len)\n-\tprintf(\" %d,\\n\", idx)\n+\tprintf(\" /* .neg_idx = */ %d,\\n\", idx)\n \tcondition = opt_args(\"Condition\", flags[i])\n \tcl_flags = switch_flags(flags[i])\n \tcl_bit_fields = switch_bit_fields(flags[i])\n@@ -402,7 +404,10 @@ for (i = 0; i < n_opts; i++) {\n \tprintf(\"    %s, %s, %s }%s\\n\", var_ref(opts[i], flags[i]),\n \t       var_set(flags[i]), integer_range_info(opt_args(\"IntegerRange\", flags[i]),\n \t\t    opt_args(\"Init\", flags[i]), opts[i]), comma)\n-}\n+\n+\t# Bump up the informational option index.\n+\t++optindex\n+ }\n \n print \"};\"\n \n@@ -417,7 +422,7 @@ print \"                           const struct cl_option_handlers *handlers, \"\n print \"                           diagnostic_context *dc)                    \"\n print \"{                                                                     \"\n print \"  size_t scode = decoded->opt_index;                                  \"\n-print \"  int value = decoded->value;                                         \"\n+print \"  HOST_WIDE_INT value = decoded->value;                               \"\n print \"  enum opt_code code = (enum opt_code) scode;                         \"\n print \"                                                                      \"\n print \"  gcc_assert (decoded->canonical_option_num_elements <= 2);           \"\n@@ -467,7 +472,7 @@ for (i = 0; i < n_langs; i++) {\n     print \"bool                                                                  \"\n     print lang_name \"_handle_option_auto (struct gcc_options *opts\" mark_unused \",              \"\n     print \"                           struct gcc_options *opts_set\" mark_unused \",              \"\n-    print \"                           size_t scode\" mark_unused \", const char *arg\" mark_unused \", int value\" mark_unused \",  \"\n+    print \"                           size_t scode\" mark_unused \", const char *arg\" mark_unused \", HOST_WIDE_INT value\" mark_unused \",  \"\n     print \"                           unsigned int lang_mask\" mark_unused \", int kind\" mark_unused \",          \"\n     print \"                           location_t loc\" mark_unused \",                            \"\n     print \"                           const struct cl_option_handlers *handlers\" mark_unused \", \""}, {"sha": "4d602230d89354eeefafcc96bc8b00ba61e1e49b", "filename": "gcc/optc-save-gen.awk", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Foptc-save-gen.awk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Foptc-save-gen.awk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptc-save-gen.awk?ref=00abf86c47606f8220d6508654ef52ef11d76e3d", "patch": "@@ -478,13 +478,14 @@ print \"{\";\n print \"  fputs (\\\"\\\\n\\\", file);\";\n for (i = 0; i < n_target_other; i++) {\n \tprint \"  if (ptr->x_\" var_target_other[i] \")\";\n-\tif (host_wide_int[var_target_other[i]] == \"yes\")\n+\thwi = host_wide_int[var_target_other[i]]\n+\tif (hwi == \"yes\")\n \t\tprint \"    fprintf (file, \\\"%*s%s (%#\\\" HOST_WIDE_INT_PRINT \\\"x)\\\\n\\\",\";\n \telse\n-\t\tprint \"    fprintf (file, \\\"%*s%s (%#x)\\\\n\\\",\";\n+\t\tprint \"    fprintf (file, \\\"%*s%s (%#lx)\\\\n\\\",\";\n \tprint \"             indent, \\\"\\\",\";\n \tprint \"             \\\"\" var_target_other[i] \"\\\",\";\n-\tif (host_wide_int[var_target_other[i]] == \"yes\")\n+\tif (hwi == \"yes\")\n \t\tprint \"             ptr->x_\" var_target_other[i] \");\";\n \telse\n \t\tprint \"             (unsigned long)ptr->x_\" var_target_other[i] \");\";\n@@ -544,13 +545,14 @@ print \"{\";\n print \"  fputs (\\\"\\\\n\\\", file);\";\n for (i = 0; i < n_target_other; i++) {\n \tprint \"  if (ptr1->x_\" var_target_other[i] \" != ptr2->x_\" var_target_other[i] \")\";\n-\tif (host_wide_int[var_target_other[i]] == \"yes\")\n+\thwi = host_wide_int[var_target_other[i]]\n+\tif (hwi == \"yes\")\n \t\tprint \"    fprintf (file, \\\"%*s%s (%#\\\" HOST_WIDE_INT_PRINT \\\"x/%#\\\" HOST_WIDE_INT_PRINT \\\"x)\\\\n\\\",\";\n \telse\n-\t\tprint \"    fprintf (file, \\\"%*s%s (%#x/%#x)\\\\n\\\",\";\n+\t\tprint \"    fprintf (file, \\\"%*s%s (%#lx/%#lx)\\\\n\\\",\";\n \tprint \"             indent, \\\"\\\",\";\n \tprint \"             \\\"\" var_target_other[i] \"\\\",\";\n-\tif (host_wide_int[var_target_other[i]] == \"yes\") {\n+\tif (hwi == \"yes\") {\n \t\tprint \"             ptr1->x_\" var_target_other[i] \",\";\n \t\tprint \"             ptr2->x_\" var_target_other[i] \");\";\n \t}"}, {"sha": "36f22b88502bd1b760d6ddb32b7588ac26434942", "filename": "gcc/opth-gen.awk", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Fopth-gen.awk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Fopth-gen.awk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopth-gen.awk?ref=00abf86c47606f8220d6508654ef52ef11d76e3d", "patch": "@@ -323,14 +323,15 @@ print \"                           const struct cl_option_handlers *handlers, \"\n print \"                           diagnostic_context *dc);                   \"\n for (i = 0; i < n_langs; i++) {\n     lang_name = lang_sanitized_name(langs[i]);\n-    print \"bool                                                                  \"\n-    print lang_name \"_handle_option_auto (struct gcc_options *opts,              \"\n-    print \"                           struct gcc_options *opts_set,              \"\n-    print \"                           size_t scode, const char *arg, int value,  \"\n-    print \"                           unsigned int lang_mask, int kind,          \"\n-    print \"                           location_t loc,                            \"\n-    print \"                           const struct cl_option_handlers *handlers, \"\n-    print \"                           diagnostic_context *dc);                   \"\n+    print \"bool\"\n+    print lang_name \"_handle_option_auto (struct gcc_options *opts,\"\n+    print \"                           struct gcc_options *opts_set,\"\n+    print \"                           size_t scode, const char *arg,\"\n+    print \"                           HOST_WIDE_INT value,\"\n+    print \"                           unsigned int lang_mask, int kind,\"\n+    print \"                           location_t loc,\"\n+    print \"                           const struct cl_option_handlers *handlers,\"\n+    print \"                           diagnostic_context *dc);\"\n }\n print \"void cpp_handle_option_auto (const struct gcc_options * opts, size_t scode,\"\n print \"                             struct cpp_options * cpp_opts);\""}, {"sha": "11356442e7bfc67c744ed00dc0b28cf70690c721", "filename": "gcc/opts-common.c", "status": "modified", "additions": 182, "deletions": 53, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Fopts-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Fopts-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts-common.c?ref=00abf86c47606f8220d6508654ef52ef11d76e3d", "patch": "@@ -169,32 +169,95 @@ find_opt (const char *input, unsigned int lang_mask)\n   return match_wrong_lang;\n }\n \n-/* If ARG is a non-negative decimal or hexadecimal integer, return its\n-   value, otherwise return -1.  */\n+/* If ARG is a non-negative decimal or hexadecimal integer representable\n+   in HOST_WIDE_INT return its value, otherwise return -1.  If ERR is not\n+   null set *ERR to zero on success or to EINVAL or to the value of errno\n+   otherwise.  */\n \n-int\n-integral_argument (const char *arg)\n+HOST_WIDE_INT\n+integral_argument (const char *arg, int *err, bool byte_size_suffix)\n {\n-  const char *p = arg;\n+  if (!err)\n+    err = &errno;\n+\n+  if (!ISDIGIT (*arg))\n+    {\n+      *err = EINVAL;\n+      return -1;\n+    }\n+\n+  *err = 0;\n+  errno = 0;\n \n-  while (*p && ISDIGIT (*p))\n-    p++;\n+  char *end = NULL;\n+  unsigned HOST_WIDE_INT unit = 1;\n+  unsigned HOST_WIDE_INT value = strtoull (arg, &end, 10);\n \n-  if (*p == '\\0')\n-    return atoi (arg);\n+  /* If the value is too large to be represented use the maximum\n+     representable value that strtoull sets VALUE to (setting\n+     errno to ERANGE).  */\n \n-  /* It wasn't a decimal number - try hexadecimal.  */\n-  if (arg[0] == '0' && (arg[1] == 'x' || arg[1] == 'X'))\n+  if (end && *end)\n     {\n-      p = arg + 2;\n-      while (*p && ISXDIGIT (*p))\n-\tp++;\n+      if (!byte_size_suffix)\n+\t{\n+\t  errno = 0;\n+\t  value = strtoull (arg, &end, 0);\n+\t  if (*end)\n+\t    {\n+\t      /* errno is most likely EINVAL here.  */\n+\t      *err = errno;\n+\t      return -1;\n+\t    }\n+\n+\t  return value;\n+\t}\n+\n+      /* Numeric option arguments are at most INT_MAX.  Make it\n+\t possible to specify a larger value by accepting common\n+\t suffixes.  */\n+      if (!strcmp (end, \"kB\"))\n+\tunit = 1000;\n+      else if (!strcasecmp (end, \"KiB\") || !strcmp (end, \"KB\"))\n+\tunit = 1024;\n+      else if (!strcmp (end, \"MB\"))\n+\tunit = HOST_WIDE_INT_UC (1000) * 1000;\n+      else if (!strcasecmp (end, \"MiB\"))\n+\tunit = HOST_WIDE_INT_UC (1024) * 1024;\n+      else if (!strcasecmp (end, \"GB\"))\n+\tunit = HOST_WIDE_INT_UC (1000) * 1000 * 1000;\n+      else if (!strcasecmp (end, \"GiB\"))\n+\tunit = HOST_WIDE_INT_UC (1024) * 1024 * 1024;\n+      else if (!strcasecmp (end, \"TB\"))\n+\tunit = HOST_WIDE_INT_UC (1000) * 1000 * 1000 * 1000;\n+      else if (!strcasecmp (end, \"TiB\"))\n+\tunit = HOST_WIDE_INT_UC (1024) * 1024 * 1024 * 1024;\n+      else if (!strcasecmp (end, \"PB\"))\n+\tunit = HOST_WIDE_INT_UC (1000) * 1000 * 1000 * 1000 * 1000;\n+      else if (!strcasecmp (end, \"PiB\"))\n+\tunit = HOST_WIDE_INT_UC (1024) * 1024 * 1024 * 1024 * 1024;\n+      else if (!strcasecmp (end, \"EB\"))\n+\tunit = HOST_WIDE_INT_UC (1000) * 1000 * 1000 * 1000 * 1000\n+\t  * 1000;\n+      else if (!strcasecmp (end, \"EiB\"))\n+\tunit = HOST_WIDE_INT_UC (1024) * 1024 * 1024 * 1024 * 1024\n+\t  * 1024;\n+      else\n+\t{\n+\t  /* This could mean an unknown suffix or a bad prefix, like\n+\t     \"+-1\".  */\n+\t  *err = EINVAL;\n+\t  return -1;\n+\t}\n+    }\n \n-      if (p != arg + 2 && *p == '\\0')\n-\treturn strtol (arg, NULL, 16);\n+  if (unit)\n+    {\n+      unsigned HOST_WIDE_INT prod = value * unit;\n+      value = prod < value ? HOST_WIDE_INT_M1U : prod;\n     }\n \n-  return -1;\n+  return value;\n }\n \n /* Return whether OPTION is OK for the language given by\n@@ -230,7 +293,8 @@ enum_arg_ok_for_language (const struct cl_enum_arg *enum_arg,\n \n static bool\n enum_arg_to_value (const struct cl_enum_arg *enum_args,\n-\t\t   const char *arg, int *value, unsigned int lang_mask)\n+\t\t   const char *arg, HOST_WIDE_INT *value,\n+\t\t   unsigned int lang_mask)\n {\n   unsigned int i;\n \n@@ -250,15 +314,22 @@ enum_arg_to_value (const struct cl_enum_arg *enum_args,\n    and returning false without modifying *VALUE if not found.  */\n \n bool\n-opt_enum_arg_to_value (size_t opt_index, const char *arg, int *value,\n-\t\t       unsigned int lang_mask)\n+opt_enum_arg_to_value (size_t opt_index, const char *arg,\n+\t\t       int *value, unsigned int lang_mask)\n {\n   const struct cl_option *option = &cl_options[opt_index];\n \n   gcc_assert (option->var_type == CLVC_ENUM);\n \n-  return enum_arg_to_value (cl_enums[option->var_enum].values, arg,\n-\t\t\t    value, lang_mask);\n+  HOST_WIDE_INT wideval;\n+  if (enum_arg_to_value (cl_enums[option->var_enum].values, arg,\n+\t\t\t &wideval, lang_mask))\n+    {\n+      *value = wideval;\n+      return true;\n+    }\n+\n+  return false;\n }\n \n /* Look of VALUE in ENUM_ARGS for language LANG_MASK and store the\n@@ -299,7 +370,8 @@ enum_value_to_arg (const struct cl_enum_arg *enum_args,\n    described by OPT_INDEX, ARG and VALUE.  */\n \n static void\n-generate_canonical_option (size_t opt_index, const char *arg, int value,\n+generate_canonical_option (size_t opt_index, const char *arg,\n+\t\t\t   HOST_WIDE_INT value,\n \t\t\t   struct cl_decoded_option *decoded)\n {\n   const struct cl_option *option = &cl_options[opt_index];\n@@ -449,7 +521,7 @@ decode_cmdline_option (const char **argv, unsigned int lang_mask,\n {\n   size_t opt_index;\n   const char *arg = 0;\n-  int value = 1;\n+  HOST_WIDE_INT value = 1;\n   unsigned int result = 1, i, extra_args, separate_args = 0;\n   int adjust_len = 0;\n   size_t total_len;\n@@ -520,6 +592,11 @@ decode_cmdline_option (const char **argv, unsigned int lang_mask,\n       goto done;\n     }\n \n+  /* Clear the initial value for size options (it will be overwritten\n+     later based on the Init(value) specification in the opt file.  */\n+  if (option->var_type == CLVC_SIZE)\n+    value = 0;\n+\n   result = extra_args + 1;\n   warn_message = option->warn_message;\n \n@@ -684,11 +761,12 @@ decode_cmdline_option (const char **argv, unsigned int lang_mask,\n       arg = arg_lower;\n     }\n \n-  /* If the switch takes an integer, convert it.  */\n-  if (arg && option->cl_uinteger)\n+  /* If the switch takes an integer argument, convert it.  */\n+  if (arg && (option->cl_uinteger || option->cl_host_wide_int))\n     {\n-      value = integral_argument (arg);\n-      if (value == -1)\n+      int error = 0;\n+      value = *arg ? integral_argument (arg, &error, option->cl_byte_size) : 0;\n+      if (error)\n \terrors |= CL_ERR_UINT_ARG;\n \n       /* Reject value out of a range.  */\n@@ -1008,7 +1086,7 @@ handle_option (struct gcc_options *opts,\n {\n   size_t opt_index = decoded->opt_index;\n   const char *arg = decoded->arg;\n-  int value = decoded->value;\n+  HOST_WIDE_INT value = decoded->value;\n   const struct cl_option *option = &cl_options[opt_index];\n   void *flag_var = option_flag_var (opt_index, opts);\n   size_t i;\n@@ -1038,7 +1116,7 @@ handle_option (struct gcc_options *opts,\n bool\n handle_generated_option (struct gcc_options *opts,\n \t\t\t struct gcc_options *opts_set,\n-\t\t\t size_t opt_index, const char *arg, int value,\n+\t\t\t size_t opt_index, const char *arg, HOST_WIDE_INT value,\n \t\t\t unsigned int lang_mask, int kind, location_t loc,\n \t\t\t const struct cl_option_handlers *handlers,\n \t\t\t bool generated_p, diagnostic_context *dc)\n@@ -1055,7 +1133,7 @@ handle_generated_option (struct gcc_options *opts,\n    compiler generates options internally.  */\n \n void\n-generate_option (size_t opt_index, const char *arg, int value,\n+generate_option (size_t opt_index, const char *arg, HOST_WIDE_INT value,\n \t\t unsigned int lang_mask, struct cl_decoded_option *decoded)\n {\n   const struct cl_option *option = &cl_options[opt_index];\n@@ -1167,8 +1245,13 @@ cmdline_handle_error (location_t loc, const struct cl_option *option,\n \n   if (errors & CL_ERR_UINT_ARG)\n     {\n-      error_at (loc, \"argument to %qs should be a non-negative integer\",\n-\t\toption->opt_text);\n+      if (option->cl_byte_size)\n+\terror_at (loc, \"argument to %qs should be a non-negative integer \"\n+\t\t  \"optionally followed by a size unit\",\n+\t\t  option->opt_text);\n+      else\n+\terror_at (loc, \"argument to %qs should be a non-negative integer\",\n+\t\t  option->opt_text);\n       return true;\n     }\n \n@@ -1274,7 +1357,7 @@ read_cmdline_option (struct gcc_options *opts,\n \n void\n set_option (struct gcc_options *opts, struct gcc_options *opts_set,\n-\t    int opt_index, int value, const char *arg, int kind,\n+\t    int opt_index, HOST_WIDE_INT value, const char *arg, int kind,\n \t    location_t loc, diagnostic_context *dc)\n {\n   const struct cl_option *option = &cl_options[opt_index];\n@@ -1293,22 +1376,54 @@ set_option (struct gcc_options *opts, struct gcc_options *opts_set,\n   switch (option->var_type)\n     {\n     case CLVC_BOOLEAN:\n-\t*(int *) flag_var = value;\n-\tif (set_flag_var)\n-\t  *(int *) set_flag_var = 1;\n+\tif (option->cl_host_wide_int)\n+\t  {\n+\t    *(HOST_WIDE_INT *) flag_var = value;\n+\t    if (set_flag_var)\n+\t      *(HOST_WIDE_INT *) set_flag_var = 1;\n+\t  }\n+\telse\n+\t  {\n+\t    *(int *) flag_var = value;\n+\t    if (set_flag_var)\n+\t      *(int *) set_flag_var = 1;\n+\t  }\n+\n+\tbreak;\n+\n+    case CLVC_SIZE:\n+\tif (option->cl_host_wide_int)\n+\t  {\n+\t    *(HOST_WIDE_INT *) flag_var = value;\n+\t    if (set_flag_var)\n+\t      *(HOST_WIDE_INT *) set_flag_var = value;\n+\t  }\n+\telse\n+\t  {\n+\t    *(int *) flag_var = value;\n+\t    if (set_flag_var)\n+\t      *(int *) set_flag_var = value;\n+\t  }\n+\n \tbreak;\n \n     case CLVC_EQUAL:\n-\tif (option->cl_host_wide_int) \n-\t  *(HOST_WIDE_INT *) flag_var = (value\n-\t\t\t\t\t ? option->var_value\n-\t\t\t\t\t : !option->var_value);\n+\tif (option->cl_host_wide_int)\n+\t  {\n+\t    *(HOST_WIDE_INT *) flag_var = (value\n+\t\t\t\t\t   ? option->var_value\n+\t\t\t\t\t   : !option->var_value);\n+\t    if (set_flag_var)\n+\t      *(HOST_WIDE_INT *) set_flag_var = 1;\n+\t  }\n \telse\n-\t  *(int *) flag_var = (value\n-\t\t\t       ? option->var_value\n-\t\t\t       : !option->var_value);\n-\tif (set_flag_var)\n-\t  *(int *) set_flag_var = 1;\n+\t  {\n+\t    *(int *) flag_var = (value\n+\t\t\t\t ? option->var_value\n+\t\t\t\t : !option->var_value);\n+\t    if (set_flag_var)\n+\t      *(int *) set_flag_var = 1;\n+\t  }\n \tbreak;\n \n     case CLVC_BIT_CLEAR:\n@@ -1395,7 +1510,10 @@ option_enabled (int opt_idx, void *opts)\n     switch (option->var_type)\n       {\n       case CLVC_BOOLEAN:\n-\treturn *(int *) flag_var != 0;\n+\tif (option->cl_host_wide_int)\n+\t  return *(HOST_WIDE_INT *) flag_var != 0;\n+\telse\n+\t  return *(int *) flag_var != 0;\n \n       case CLVC_EQUAL:\n \tif (option->cl_host_wide_int) \n@@ -1415,6 +1533,12 @@ option_enabled (int opt_idx, void *opts)\n \telse \n \t  return (*(int *) flag_var & option->var_value) != 0;\n \n+      case CLVC_SIZE:\n+\tif (option->cl_host_wide_int)\n+\t  return *(HOST_WIDE_INT *) flag_var != -1;\n+\telse\n+\t  return *(int *) flag_var != -1;\n+\n       case CLVC_STRING:\n       case CLVC_ENUM:\n       case CLVC_DEFER:\n@@ -1439,6 +1563,7 @@ get_option_state (struct gcc_options *opts, int option,\n     {\n     case CLVC_BOOLEAN:\n     case CLVC_EQUAL:\n+    case CLVC_SIZE:\n       state->data = flag_var;\n       state->size = (cl_options[option].cl_host_wide_int\n \t\t     ? sizeof (HOST_WIDE_INT)\n@@ -1503,9 +1628,11 @@ control_warning_option (unsigned int opt_index, int kind, const char *arg,\n       const struct cl_option *option = &cl_options[opt_index];\n \n       /* -Werror=foo implies -Wfoo.  */\n-      if (option->var_type == CLVC_BOOLEAN || option->var_type == CLVC_ENUM)\n+      if (option->var_type == CLVC_BOOLEAN\n+\t  || option->var_type == CLVC_ENUM\n+\t  || option->var_type == CLVC_SIZE)\n \t{\n-\t  int value = 1;\n+\t  HOST_WIDE_INT value = 1;\n \n \t  if (arg && *arg == '\\0' && !option->cl_missing_ok)\n \t    arg = NULL;\n@@ -1517,11 +1644,13 @@ control_warning_option (unsigned int opt_index, int kind, const char *arg,\n \t      return;\n \t    }\n \n-\t  /* If the switch takes an integer, convert it.  */\n-\t  if (arg && option->cl_uinteger)\n+\t  /* If the switch takes an integer argument, convert it.  */\n+\t  if (arg && (option->cl_uinteger || option->cl_host_wide_int))\n \t    {\n-\t      value = integral_argument (arg);\n-\t      if (value == -1)\n+\t      int error = 0;\n+\t      value = *arg ? integral_argument (arg, &error,\n+\t\t\t\t\t\toption->cl_byte_size) : 0;\n+\t      if (error)\n \t\t{\n \t\t  cmdline_handle_error (loc, option, option->opt_text, arg,\n \t\t\t\t\tCL_ERR_UINT_ARG, lang_mask);"}, {"sha": "17d91988ada7a451159ced30abb0c1bd9f41a9b5", "filename": "gcc/opts.c", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=00abf86c47606f8220d6508654ef52ef11d76e3d", "patch": "@@ -1844,7 +1844,7 @@ common_handle_option (struct gcc_options *opts,\n {\n   size_t scode = decoded->opt_index;\n   const char *arg = decoded->arg;\n-  int value = decoded->value;\n+  HOST_WIDE_INT value = decoded->value;\n   enum opt_code code = (enum opt_code) scode;\n \n   gcc_assert (decoded->canonical_option_num_elements <= 2);\n@@ -2107,22 +2107,11 @@ common_handle_option (struct gcc_options *opts,\n \t\t\t       opts, opts_set, loc, dc);\n       break;\n \n-    case OPT_Wlarger_than_:\n-      opts->x_larger_than_size = value;\n-      opts->x_warn_larger_than = value != -1;\n-      break;\n-\n     case OPT_Wfatal_errors:\n       dc->fatal_errors = value;\n       break;\n \n-    case OPT_Wframe_larger_than_:\n-      opts->x_frame_larger_than_size = value;\n-      opts->x_warn_frame_larger_than = value != -1;\n-      break;\n-\n     case OPT_Wstack_usage_:\n-      opts->x_warn_stack_usage = value;\n       opts->x_flag_stack_usage_info = value != -1;\n       break;\n \n@@ -2282,7 +2271,7 @@ common_handle_option (struct gcc_options *opts,\n     case OPT_fpack_struct_:\n       if (value <= 0 || (value & (value - 1)) || value > 16)\n \terror_at (loc,\n-\t\t  \"structure alignment must be a small power of two, not %d\",\n+\t\t  \"structure alignment must be a small power of two, not %wu\",\n \t\t  value);\n       else\n \topts->x_initial_max_fld_align = value;\n@@ -2465,7 +2454,7 @@ common_handle_option (struct gcc_options *opts,\n       /* FALLTHRU */\n     case OPT_gdwarf_:\n       if (value < 2 || value > 5)\n-\terror_at (loc, \"dwarf version %d is not supported\", value);\n+\terror_at (loc, \"dwarf version %wu is not supported\", value);\n       else\n \topts->x_dwarf_version = value;\n       set_debug_level (DWARF2_DEBUG, false, \"\", opts, opts_set, loc);"}, {"sha": "0091fe0e9b22648641f318c0ad177c48e887f614", "filename": "gcc/opts.h", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Fopts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Fopts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.h?ref=00abf86c47606f8220d6508654ef52ef11d76e3d", "patch": "@@ -36,6 +36,9 @@ enum cl_var_type {\n   /* The switch is enabled when VAR_VALUE is set in FLAG_VAR.  */\n   CLVC_BIT_SET,\n \n+  /* The switch is enabled when FLAG_VAR is less than HOST_WIDE_INT_M1U.  */\n+  CLVC_SIZE,\n+\n   /* The switch takes a string argument and FLAG_VAR points to that\n      argument.  */\n   CLVC_STRING,\n@@ -70,7 +73,10 @@ struct cl_option\n   unsigned short back_chain;\n   /* Option length, not including initial '-'.  */\n   unsigned char opt_len;\n-  /* Next option in a sequence marked with Negative, or -1 if none.  */\n+  /* Next option in a sequence marked with Negative, or -1 if none.\n+     For a single option with both a negative and a positve form\n+     (such as -Wall and -Wno-all), NEG_IDX is equal to the option's\n+     own index (i.e., cl_options[IDX].neg_idx == IDX holds).  */\n   int neg_index;\n   /* CL_* flags for this option.  */\n   unsigned int flags;\n@@ -102,6 +108,8 @@ struct cl_option\n   BOOL_BITFIELD cl_report : 1;\n   /* Deprecated option  */\n   BOOL_BITFIELD cl_deprecated: 1;\n+  /* Argument is an unsigned integer with an optional byte suffix.  */\n+  BOOL_BITFIELD cl_byte_size: 1;\n   /* Offset of field for this option in struct gcc_options, or\n      (unsigned short) -1 if none.  */\n   unsigned short flag_var_offset;\n@@ -247,7 +255,7 @@ struct cl_decoded_option\n   /* For a boolean option, 1 for the true case and 0 for the \"no-\"\n      case.  For an unsigned integer option, the value of the\n      argument.  1 in all other cases.  */\n-  int value;\n+  HOST_WIDE_INT value;\n \n   /* Any flags describing errors detected in this option.  */\n   int errors;\n@@ -327,7 +335,7 @@ extern char *opts_concat (const char *first, ...);\n extern struct obstack opts_obstack;\n \n size_t find_opt (const char *input, unsigned int lang_mask);\n-extern int integral_argument (const char *arg);\n+extern HOST_WIDE_INT integral_argument (const char *arg, int * = NULL, bool = false);\n extern bool enum_value_to_arg (const struct cl_enum_arg *enum_args,\n \t\t\t       const char **argp, int value,\n \t\t\t       unsigned int lang_mask);\n@@ -359,16 +367,17 @@ extern bool get_option_state (struct gcc_options *, int,\n \t\t\t      struct cl_option_state *);\n extern void set_option (struct gcc_options *opts,\n \t\t\tstruct gcc_options *opts_set,\n-\t\t\tint opt_index, int value, const char *arg, int kind,\n-\t\t\tlocation_t loc, diagnostic_context *dc);\n+\t\t\tint opt_index, HOST_WIDE_INT value, const char *arg,\n+\t\t\tint kind, location_t loc, diagnostic_context *dc);\n extern void *option_flag_var (int opt_index, struct gcc_options *opts);\n bool handle_generated_option (struct gcc_options *opts,\n \t\t\t      struct gcc_options *opts_set,\n-\t\t\t      size_t opt_index, const char *arg, int value,\n+\t\t\t      size_t opt_index, const char *arg,\n+\t\t\t      HOST_WIDE_INT value,\n \t\t\t      unsigned int lang_mask, int kind, location_t loc,\n \t\t\t      const struct cl_option_handlers *handlers,\n \t\t\t      bool generated_p, diagnostic_context *dc);\n-void generate_option (size_t opt_index, const char *arg, int value,\n+void generate_option (size_t opt_index, const char *arg, HOST_WIDE_INT value,\n \t\t      unsigned int lang_mask,\n \t\t      struct cl_decoded_option *decoded);\n void generate_option_input_file (const char *file,\n@@ -425,7 +434,8 @@ extern void set_struct_debug_option (struct gcc_options *opts,\n \t\t\t\t     location_t loc,\n \t\t\t\t     const char *value);\n extern bool opt_enum_arg_to_value (size_t opt_index, const char *arg,\n-\t\t\t\t   int *value, unsigned int lang_mask);\n+\t\t\t\t   int *value,\n+\t\t\t\t   unsigned int lang_mask);\n \n extern const struct sanitizer_opts_s\n {"}, {"sha": "cb377ca5b82823eeb3c087a3f926cced2e431fba", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=00abf86c47606f8220d6508654ef52ef11d76e3d", "patch": "@@ -756,22 +756,19 @@ layout_decl (tree decl, unsigned int known_align)\n     DECL_SIZE_UNIT (decl) = variable_size (DECL_SIZE_UNIT (decl));\n \n   /* If requested, warn about definitions of large data objects.  */\n-  if (warn_larger_than\n-      && (code == VAR_DECL || code == PARM_DECL)\n+  if ((code == VAR_DECL || code == PARM_DECL)\n       && ! DECL_EXTERNAL (decl))\n     {\n       tree size = DECL_SIZE_UNIT (decl);\n \n       if (size != 0 && TREE_CODE (size) == INTEGER_CST\n-\t  && compare_tree_int (size, larger_than_size) > 0)\n+\t  && compare_tree_int (size, warn_larger_than_size) > 0)\n \t{\n-\t  int size_as_int = TREE_INT_CST_LOW (size);\n+\t  unsigned HOST_WIDE_INT uhwisize = tree_to_uhwi (size);\n \n-\t  if (compare_tree_int (size, size_as_int) == 0)\n-\t    warning (OPT_Wlarger_than_, \"size of %q+D is %d bytes\", decl, size_as_int);\n-\t  else\n-\t    warning (OPT_Wlarger_than_, \"size of %q+D is larger than %wd bytes\",\n-                     decl, larger_than_size);\n+\t  warning (OPT_Wlarger_than_, \"size of %q+D %wu bytes exceeds \"\n+\t\t   \"maximum object size %wu\",\n+\t\t   decl, uhwisize, warn_larger_than_size);\n \t}\n     }\n "}, {"sha": "dc2ce278f7fa42911bfeb34e6de7da30c60c64ed", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=00abf86c47606f8220d6508654ef52ef11d76e3d", "patch": "@@ -1,3 +1,18 @@\n+2018-07-20  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/82063\n+\t* gcc/testsuite/c-c++-common/pr68657-1.c: Adjust.\n+\t* gcc/testsuite/c-c++-common/pr68657-2.c: Same.\n+\t* gcc/testsuite/c-c++-common/pr68657-3.c: Same.\n+\t* gcc.dg/Walloc-size-larger-than-16.c: Same.\n+\t* gcc.dg/Walloca-larger-than.c: New test.\n+\t* gcc.dg/Walloca-larger-than-2.c: New test.\n+\t* gcc.dg/Wframe-larger-than-2.c: New test.\n+\t* gcc.dg/Wlarger-than3.c: New test.\n+\t* gcc.dg/Wvla-larger-than-3.c: New test.\n+\t* gcc.dg/pr42611.c: Adjust.\n+\t* gnat.dg/frame_overflow.adb: Same.\n+\n 2018-07-20  Martin Sebor  <msebor@redhat.com>\n \n \tPR tree-optimization/86613"}, {"sha": "ef11ad1204b13b98669e43a225d5161a270fb0a3", "filename": "gcc/testsuite/c-c++-common/pr68657-2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpr68657-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpr68657-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpr68657-2.c?ref=00abf86c47606f8220d6508654ef52ef11d76e3d", "patch": "@@ -3,7 +3,7 @@\n /* { dg-options \"-Werror=larger-than=65536\" } */\n /* { dg-require-effective-target ptr32plus } */\n \n-int a[131072];\t/* { dg-error \"size of 'a' is \\[1-9]\\[0-9]* bytes\" } */\n-int b[1024];\t/* { dg-bogus \"size of 'b' is \\[1-9]\\[0-9]* bytes\" } */\n+int a[131072];\t/* { dg-error \"size of .a. 524288 bytes exceeds maximum object size 65536\" } */\n+int b[1024];\t/* { dg-bogus \"size\" } */\n \n /* { dg-prune-output \"treated as errors\" } */"}, {"sha": "8ee6f26462f4db5a1872898dd1dbc20ba7dcb819", "filename": "gcc/testsuite/c-c++-common/pr68657-3.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpr68657-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpr68657-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpr68657-3.c?ref=00abf86c47606f8220d6508654ef52ef11d76e3d", "patch": "@@ -3,12 +3,12 @@\n /* { dg-require-effective-target ptr32plus } */\n \n #pragma GCC diagnostic error \"-Wlarger-than=65536\"\n-int a[131072];\t/* { dg-error \"size of 'a' is \\[1-9]\\[0-9]* bytes\" } */\n-int b[1024];\t/* { dg-bogus \"size of 'b' is \\[1-9]\\[0-9]* bytes\" } */\n+int a[131072];\t/* { dg-error \"size of 'a' \\[1-9\\]\\[0-9\\]* bytes exceeds maximum object size 65536\" } */\n+int b[1024];\t/* { dg-bogus \"size\" } */\n #pragma GCC diagnostic ignored \"-Wlarger-than=65536\"\n-int c[131072];\t/* { dg-bogus \"size of 'c' is \\[1-9]\\[0-9]* bytes\" } */\n-int d[1024];\t/* { dg-bogus \"size of 'd' is \\[1-9]\\[0-9]* bytes\" } */\n+int c[131072];\t/* { dg-bogus \"size\" } */\n+int d[1024];\t/* { dg-bogus \"size\" } */\n #pragma GCC diagnostic warning \"-Wlarger-than=65536\"\n-int e[131072];\t/* { dg-warning \"size of 'e' is \\[1-9]\\[0-9]* bytes\" } */\n-int f[1024];\t/* { dg-bogus \"size of 'f' is \\[1-9]\\[0-9]* bytes\" } */\n+int e[131072];\t/* { dg-warning \"size of 'e' \\[1-9\\]\\[0-9\\]* bytes exceeds maximum object size 65536\" } */\n+int f[1024];\t/* { dg-bogus \"size\" } */\n /* { dg-prune-output \"treated as errors\" } */"}, {"sha": "d035cbb9c51703759062cbd28dc2e6f3a5f2cd26", "filename": "gcc/testsuite/gcc.dg/Walloc-size-larger-than-16.c", "status": "modified", "additions": 5, "deletions": 28, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Ftestsuite%2Fgcc.dg%2FWalloc-size-larger-than-16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Ftestsuite%2Fgcc.dg%2FWalloc-size-larger-than-16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWalloc-size-larger-than-16.c?ref=00abf86c47606f8220d6508654ef52ef11d76e3d", "patch": "@@ -1,32 +1,9 @@\n /* PR middle-end/82063 - issues with arguments enabled by -Wall\n+   Verify that an invalid argument to -Walloc-size-larger-than is diagnosed.\n    { dg-do compile }\n-   { dg-options \"-O -Walloc-size-larger-than=1zb -ftrack-macro-expansion=0\" } */\n+   { dg-options \"-Walloc-size-larger-than=1zb -Walloca-larger-than=2kbytes -Wvla-larger-than=3MIBZ\" } */\n \n-typedef __SIZE_TYPE__ size_t;\n \n-void sink (void*);\n-\n-#define T(x) sink (x)\n-\n-/* Verify that an invalid -Walloc-size-larger-than argument is diagnosed\n-   and rejected without changing the default setting of PTRDIFF_MAX.  */\n-\n-void f (void)\n-{\n-  size_t n = 0;\n-  T (__builtin_malloc (n));\n-\n-  n = __PTRDIFF_MAX__;\n-  T (__builtin_malloc (n));\n-\n-  n += 1;\n-  T (__builtin_malloc (n));   /* { dg-warning \"exceeds maximum object size\" } */\n-\n-  n = __SIZE_MAX__ - 1;\n-  T (__builtin_malloc (n));   /* { dg-warning \"exceeds maximum object size\" } */\n-\n-  n = __SIZE_MAX__;\n-  T (__builtin_malloc (n));   /* { dg-warning \"exceeds maximum object size\" } */\n-}\n-\n-/* { dg-warning \"invalid argument .1zb. to .-Walloc-size-larger-than=.\" \"\" { target *-*-* } 0 } */\n+/* { dg-error \"argument to '-Walloc-size-larger-than=' should be a non-negative integer optionally followed by a size unit\" \"\" { target *-*-* } 0 }\n+   { dg-error \"argument to '-Walloca-larger-than=' should be a non-negative integer optionally followed by a size unit\" \"\" { target *-*-* } 0 }\n+   { dg-error \"argument to '-Wvla-larger-than=' should be a non-negative integer optionally followed by a size unit\" \"\" { target *-*-* } 0 } */"}, {"sha": "fe003bd088271314ea67fad43005d0e884e48a0a", "filename": "gcc/testsuite/gcc.dg/Walloca-larger-than-2.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-larger-than-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-larger-than-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-larger-than-2.c?ref=00abf86c47606f8220d6508654ef52ef11d76e3d", "patch": "@@ -0,0 +1,24 @@\n+/* PR middle-end/82063 - issues with arguments enabled by -Wall\n+   Verify that alloca() calls in loops are not diagnosed by default.\n+   { dg-do compile }\n+   { dg-options \"-O2 -ftrack-macro-expansion=0\" } */\n+\n+extern void* alloca (__SIZE_TYPE__);\n+\n+void sink (void*);\n+\n+#define T(x) sink (x)\n+\n+void test_alloca (unsigned n)\n+{\n+  /* Verify that alloca(0) is not diagnosed in a loop either.  */\n+  for (unsigned i = 0; i < n; ++i)\n+    T (alloca (0));\n+\n+  /* Verify no warnings for the loops below.  */\n+  for (unsigned i = 0; i < n; ++i)\n+    T (alloca (1));\n+\n+  for (unsigned i = 1; i < n; ++i)\n+    T (alloca (n));\n+}"}, {"sha": "284601d22ff8d6d3175dde76ee89d4df8248374e", "filename": "gcc/testsuite/gcc.dg/Walloca-larger-than.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-larger-than.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-larger-than.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-larger-than.c?ref=00abf86c47606f8220d6508654ef52ef11d76e3d", "patch": "@@ -0,0 +1,26 @@\n+/* PR middle-end/82063 - issues with arguments enabled by -Wall\n+   { dg-do compile }\n+   { dg-options \"-O2 -Walloca-larger-than=0 -Wvla-larger-than=0 -ftrack-macro-expansion=0\" } */\n+\n+extern void* alloca (__SIZE_TYPE__);\n+\n+void sink (void*);\n+\n+#define T(x) sink (x)\n+\n+void test_alloca (void)\n+{\n+  /* Verify that alloca(0) is diagnosed even if the limit is zero.  */\n+  T (alloca (0));   /* { dg-warning \"argument to .alloca. is zero\" } */\n+  T (alloca (1));   /* { dg-warning \"argument to .alloca. is too large\" } */\n+}\n+\n+void test_vla (unsigned n)\n+{\n+  /* VLAs smaller than 32 bytes are optimized into ordinary arrays.  */\n+  if (n < 1 || 99 < n)\n+    n = 1;\n+\n+  char a[n];        /* { dg-warning \"argument to variable-length array \" } */\n+  T (a);\n+}"}, {"sha": "1a5402f812035ff69b7c75f4e8a9603f88a8a3fe", "filename": "gcc/testsuite/gcc.dg/Wframe-larger-than-2.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Ftestsuite%2Fgcc.dg%2FWframe-larger-than-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Ftestsuite%2Fgcc.dg%2FWframe-larger-than-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWframe-larger-than-2.c?ref=00abf86c47606f8220d6508654ef52ef11d76e3d", "patch": "@@ -0,0 +1,19 @@\n+/* Exercise -Wframe-larger-than= with a byte-size suffix.\n+   { dg-do compile }\n+   { dg-options \"-O -Wframe-larger-than=1KB\" } */\n+\n+extern void f (void*, ...);\n+\n+void frame_size_912 (void)\n+{\n+  char a[512];\n+  char b[400];\n+  f (a, b);\n+}\n+\n+void frame_size_1025 (void)\n+{\n+  char a[512];\n+  char b[513];\n+  f (a, b);\n+} /* { dg-warning \"frame size of \\[0-9\\]+ bytes is larger than 1024 bytes\" } */"}, {"sha": "b9eaa563770bf564f1175c16e273ab09b1a68dc9", "filename": "gcc/testsuite/gcc.dg/Wlarger-than3.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Ftestsuite%2Fgcc.dg%2FWlarger-than3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Ftestsuite%2Fgcc.dg%2FWlarger-than3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWlarger-than3.c?ref=00abf86c47606f8220d6508654ef52ef11d76e3d", "patch": "@@ -0,0 +1,12 @@\n+/* Exercise -Wlarger-than= with a byte-size suffix.\n+   { dg-do compile }\n+   { dg-options \"-Wlarger-than=1MiB\" } */\n+\n+#define MB (1000 * 1000)    /* MegaByte */\n+#define MiB (1024 * 1024)   /* MebiByte */\n+\n+char megabyte[MB];\n+char membibyte[MiB];\n+\n+char megabyte_plus_1[MB + 1];\n+char membibyte_plus_1[MiB + 1];   /* { dg-warning \"size of .membibyte_plus_1. 1048577 bytes exceeds maximum object size 1048576\" } */"}, {"sha": "70011f1d3829eb9d549112e827e760efa5a3b844", "filename": "gcc/testsuite/gcc.dg/Wvla-larger-than-3.c", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Ftestsuite%2Fgcc.dg%2FWvla-larger-than-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Ftestsuite%2Fgcc.dg%2FWvla-larger-than-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWvla-larger-than-3.c?ref=00abf86c47606f8220d6508654ef52ef11d76e3d", "patch": "@@ -0,0 +1,68 @@\n+/* Verify that VLA definitions with an unknown upper bound don't trigger\n+   -Wvla-larger-than= warnings by default.\n+   { dg-do compile }\n+   { dg-require-effective-target alloca }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+void f (void *, ...);\n+\n+void nowarn_vla_int (int n)\n+{\n+  char a[n];\n+\n+  if (n < 1234)\n+    n = 1234;\n+\n+  char b[n];\n+  f (a, b);\n+}\n+\n+void nowarn_vla_uint (unsigned n)\n+{\n+  char a[n];\n+  f (a);\n+\n+  if (n < 2345)\n+    n = 2345;\n+\n+  char b[n];\n+  f (a, b);\n+}\n+\n+void nowarn_vla_long (long n)\n+{\n+  char a[n];\n+\n+  if (n < 1234)\n+    n = 1234;\n+\n+  char b[n];\n+  f (a, b);\n+}\n+\n+void nowarn_vla_ulong (unsigned long n)\n+{\n+  char a[n];\n+  f (a);\n+\n+  if (n < 2345)\n+    n = 2345;\n+\n+  char b[n];\n+  f (a, b);\n+}\n+\n+/* Verify that a VLA whose size is definitely in excess of PTRDIFF_MAX\n+   is diagnosed by default.  */\n+\n+void warn_vla (__PTRDIFF_TYPE__ n)\n+{\n+  int a[n];\n+  f (a);\n+\n+  if (n <= __PTRDIFF_MAX__)\n+    n = __PTRDIFF_MAX__;\n+\n+  int b[n];   /* { dg-warning \"argument to variable-length array is too large\" } */\n+  f (a, b);\n+}"}, {"sha": "0426ce2d5bc1d45a4b77531d4636c335e2991199", "filename": "gcc/testsuite/gcc.dg/pr42611.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Ftestsuite%2Fgcc.dg%2Fpr42611.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Ftestsuite%2Fgcc.dg%2Fpr42611.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr42611.c?ref=00abf86c47606f8220d6508654ef52ef11d76e3d", "patch": "@@ -14,6 +14,6 @@ struct S { int a; char b[L]; };\t/* { dg-error \"type .struct S. is too large\" } *\n void\n foo (void)\n {\n-  struct S s;\n+  struct S s;   /* { dg-warning \"size of .s. \\[0-9\\]+ bytes exceeds maximum object size \\[0-9\\]+\" } */\n   asm volatile (\"\" : : \"r\" (&s));\n }"}, {"sha": "0351fdfa869e896b57623a47e93bb545fee4934b", "filename": "gcc/testsuite/gnat.dg/frame_overflow.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Ftestsuite%2Fgnat.dg%2Fframe_overflow.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Ftestsuite%2Fgnat.dg%2Fframe_overflow.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fframe_overflow.adb?ref=00abf86c47606f8220d6508654ef52ef11d76e3d", "patch": "@@ -2,7 +2,7 @@\n \n package body Frame_Overflow is\n \n-   function -- { dg-error \"too large\" }\n+   function -- { dg-error \"exceeds\" }\n      Set_In (Bitmap : Bitmap_T; Bitpos : Bitpos_Range_T)  return Bitmap_T\n    is\n       Result: Bitmap_T := Bitmap;\n@@ -11,7 +11,7 @@ package body Frame_Overflow is\n       return Result;\n    end;\n \n-   function -- { dg-error \"too large\" }\n+   function -- { dg-error \"exceeds\" }\n      Negate (Bitmap : Bitmap_T) return Bitmap_T\n    is\n       Result: Bitmap_T;"}, {"sha": "f23e8aeb17b288d804f726aa5a25e4b32a334381", "filename": "gcc/toplev.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00abf86c47606f8220d6508654ef52ef11d76e3d/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=00abf86c47606f8220d6508654ef52ef11d76e3d", "patch": "@@ -1024,7 +1024,7 @@ output_stack_usage (void)\n \t       stack_usage_kind_str[stack_usage_kind]);\n     }\n \n-  if (warn_stack_usage >= 0)\n+  if (warn_stack_usage >= 0 && warn_stack_usage < HOST_WIDE_INT_MAX)\n     {\n       const location_t loc = DECL_SOURCE_LOCATION (current_function_decl);\n \n@@ -1034,10 +1034,10 @@ output_stack_usage (void)\n \t{\n \t  if (stack_usage_kind == DYNAMIC_BOUNDED)\n \t    warning_at (loc,\n-\t\t\tOPT_Wstack_usage_, \"stack usage might be %wd bytes\",\n+\t\t\tOPT_Wstack_usage_, \"stack usage might be %wu bytes\",\n \t\t\tstack_usage);\n \t  else\n-\t    warning_at (loc, OPT_Wstack_usage_, \"stack usage is %wd bytes\",\n+\t    warning_at (loc, OPT_Wstack_usage_, \"stack usage is %wu bytes\",\n \t\t\tstack_usage);\n \t}\n     }"}]}