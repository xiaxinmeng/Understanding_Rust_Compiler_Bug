{"sha": "84cdf51de42f823b4ed0d65ef20ab0142607917b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODRjZGY1MWRlNDJmODIzYjRlZDBkNjVlZjIwYWIwMTQyNjA3OTE3Yg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-09-13T21:32:24Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-09-13T21:32:24Z"}, "message": "compiler, runtime: open code select\n    \n    This is the gofrontend version of https://golang.org/cl/37933,\n    https://golang.org/cl/37934, and https://golang.org/cl/37935.\n    Open code the initialization of select cases.\n    \n    This is a step toward updating libgo to the 1.11 release.\n    \n    Reviewed-on: https://go-review.googlesource.com/135000\n\nFrom-SVN: r264290", "tree": {"sha": "b7d94851b891d2529f5f7eb23386a86f07563097", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b7d94851b891d2529f5f7eb23386a86f07563097"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/84cdf51de42f823b4ed0d65ef20ab0142607917b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84cdf51de42f823b4ed0d65ef20ab0142607917b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84cdf51de42f823b4ed0d65ef20ab0142607917b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84cdf51de42f823b4ed0d65ef20ab0142607917b/comments", "author": null, "committer": null, "parents": [{"sha": "283b9cafbd73b92b106e3f23b07f59af6761c78b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/283b9cafbd73b92b106e3f23b07f59af6761c78b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/283b9cafbd73b92b106e3f23b07f59af6761c78b"}], "stats": {"total": 643, "additions": 278, "deletions": 365}, "files": [{"sha": "6650b03ec67a8da762f8cb7b100ef8c2f33ddde3", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84cdf51de42f823b4ed0d65ef20ab0142607917b/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84cdf51de42f823b4ed0d65ef20ab0142607917b/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=84cdf51de42f823b4ed0d65ef20ab0142607917b", "patch": "@@ -1,4 +1,4 @@\n-f68c03e509b26e7f483f2800eb70a5fbf3f74d0b\n+f2cd046a4e0d681c3d21ee547b437d3eab8af268\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "9c31525eb9584a13039c2cac7b0a3b3d3b1b2b38", "filename": "gcc/go/gofrontend/escape.cc", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84cdf51de42f823b4ed0d65ef20ab0142607917b/gcc%2Fgo%2Fgofrontend%2Fescape.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84cdf51de42f823b4ed0d65ef20ab0142607917b/gcc%2Fgo%2Fgofrontend%2Fescape.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fescape.cc?ref=84cdf51de42f823b4ed0d65ef20ab0142607917b", "patch": "@@ -1361,7 +1361,13 @@ Escape_analysis_assign::statement(Block*, size_t*, Statement* s)\n       {\n         Expression* init = s->temporary_statement()->init();\n         if (init != NULL)\n-          this->assign(Node::make_node(s), Node::make_node(init));\n+\t  {\n+\t    Node* n = Node::make_node(init);\n+\t    if (s->temporary_statement()->value_escapes())\n+\t      this->assign(this->context_->sink(), n);\n+\t    else\n+\t      this->assign(Node::make_node(s), n);\n+\t  }\n       }\n       break;\n \n@@ -1616,15 +1622,6 @@ Escape_analysis_assign::expression(Expression** pexpr)\n                 }\n                 break;\n \n-              case Runtime::SELECTSEND:\n-                {\n-                  // Send to a channel, lose track. The last argument is\n-                  // the address of the value to send.\n-                  Node* arg_node = Node::make_node(call->args()->back());\n-                  this->assign_deref(this->context_->sink(), arg_node);\n-                }\n-                break;\n-\n               case Runtime::IFACEE2T2:\n               case Runtime::IFACEI2T2:\n                 {\n@@ -2228,8 +2225,12 @@ Escape_analysis_assign::assign(Node* dst, Node* src)\n         case Expression::EXPRESSION_TEMPORARY_REFERENCE:\n           {\n             // Temporary is tracked through the underlying Temporary_statement.\n-            Statement* t = dst->expr()->temporary_reference_expression()->statement();\n-            dst = Node::make_node(t);\n+            Temporary_statement* t =\n+\t      dst->expr()->temporary_reference_expression()->statement();\n+\t    if (t->value_escapes())\n+\t      dst = this->context_->sink();\n+\t    else\n+\t      dst = Node::make_node(t);\n           }\n           break;\n "}, {"sha": "1486cd85f27f6dbdfa6f83cf6fc0646d6337debf", "filename": "gcc/go/gofrontend/runtime.def", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84cdf51de42f823b4ed0d65ef20ab0142607917b/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84cdf51de42f823b4ed0d65ef20ab0142607917b/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fruntime.def?ref=84cdf51de42f823b4ed0d65ef20ab0142607917b", "patch": "@@ -152,22 +152,10 @@ DEF_GO_RUNTIME(CHANRECV1, \"runtime.chanrecv1\", P2(CHAN, POINTER), R0())\n DEF_GO_RUNTIME(CHANRECV2, \"runtime.chanrecv2\", P2(CHAN, POINTER), R1(BOOL))\n \n \n-// Start building a select statement.\n-DEF_GO_RUNTIME(NEWSELECT, \"runtime.newselect\", P3(POINTER, INT64, INT32), R0())\n-\n-// Add a default clause to a select statement.\n-DEF_GO_RUNTIME(SELECTDEFAULT, \"runtime.selectdefault\", P1(POINTER), R0())\n-\n-// Add a send clause to a select statement.\n-DEF_GO_RUNTIME(SELECTSEND, \"runtime.selectsend\", P3(POINTER, CHAN, POINTER),\n-\t       R0())\n-\n-// Add a receive clause to a select statement.\n-DEF_GO_RUNTIME(SELECTRECV, \"runtime.selectrecv\",\n-\t       P4(POINTER, CHAN, POINTER, BOOLPTR), R0())\n-\n-// Run a select, returning the index of the selected clause.\n-DEF_GO_RUNTIME(SELECTGO, \"runtime.selectgo\", P1(POINTER), R1(INT))\n+// Run a select, returning the index of the selected clause and\n+// whether that channel received a value.\n+DEF_GO_RUNTIME(SELECTGO, \"runtime.selectgo\", P3(POINTER, POINTER, INT),\n+\t       R2(INT, BOOL))\n \n \n // Panic."}, {"sha": "1df676f53c2c3886723d8dec9c7321259ba2f473", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 147, "deletions": 85, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84cdf51de42f823b4ed0d65ef20ab0142607917b/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84cdf51de42f823b4ed0d65ef20ab0142607917b/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=84cdf51de42f823b4ed0d65ef20ab0142607917b", "patch": "@@ -4548,17 +4548,19 @@ Select_clauses::Select_clause::traverse(Traverse* traverse)\n \n void\n Select_clauses::Select_clause::lower(Gogo* gogo, Named_object* function,\n-\t\t\t\t     Block* b, Temporary_statement* sel)\n+\t\t\t\t     Block* b, Temporary_statement* scases,\n+\t\t\t\t     size_t index, Temporary_statement* recvok)\n {\n   Location loc = this->location_;\n \n-  Expression* selref = Expression::make_temporary_reference(sel, loc);\n-  selref = Expression::make_unary(OPERATOR_AND, selref, loc);\n+  Expression* scase = Expression::make_temporary_reference(scases, loc);\n+  Expression* index_expr = Expression::make_integer_ul(index, NULL, loc);\n+  scase = Expression::make_array_index(scase, index_expr, NULL, NULL, loc);\n \n   if (this->is_default_)\n     {\n       go_assert(this->channel_ == NULL && this->val_ == NULL);\n-      this->lower_default(b, selref);\n+      this->lower_default(b, scase);\n       this->is_lowered_ = true;\n       return;\n     }\n@@ -4572,9 +4574,9 @@ Select_clauses::Select_clause::lower(Gogo* gogo, Named_object* function,\n \t\t\t\t\t\t\t     loc);\n \n   if (this->is_send_)\n-    this->lower_send(b, selref, chanref);\n+    this->lower_send(b, scase, chanref);\n   else\n-    this->lower_recv(gogo, function, b, selref, chanref);\n+    this->lower_recv(gogo, function, b, scase, chanref, recvok);\n \n   // Now all references should be handled through the statements, not\n   // through here.\n@@ -4585,18 +4587,16 @@ Select_clauses::Select_clause::lower(Gogo* gogo, Named_object* function,\n // Lower a default clause in a select statement.\n \n void\n-Select_clauses::Select_clause::lower_default(Block* b, Expression* selref)\n+Select_clauses::Select_clause::lower_default(Block* b, Expression* scase)\n {\n   Location loc = this->location_;\n-  Expression* call = Runtime::make_call(Runtime::SELECTDEFAULT, loc, 1,\n-\t\t\t\t\tselref);\n-  b->add_statement(Statement::make_statement(call, true));\n+  this->set_case(b, scase, Expression::make_nil(loc), NULL, caseDefault);\n }\n \n // Lower a send clause in a select statement.\n \n void\n-Select_clauses::Select_clause::lower_send(Block* b, Expression* selref,\n+Select_clauses::Select_clause::lower_send(Block* b, Expression* scase,\n \t\t\t\t\t  Expression* chanref)\n {\n   Location loc = this->location_;\n@@ -4611,22 +4611,29 @@ Select_clauses::Select_clause::lower_send(Block* b, Expression* selref,\n   // evaluate the send values in the required order.\n   Temporary_statement* val = Statement::make_temporary(valtype, this->val_,\n \t\t\t\t\t\t       loc);\n+  // The value here escapes, because it might be sent on a channel.\n+  // We record that via the Temporary_statement, so that the escape\n+  // analysis pass can pick it up.  The gc compiler lowers select\n+  // statements after escape analysis, so it doesn't have to worry\n+  // about this.\n+  val->set_value_escapes();\n   b->add_statement(val);\n \n   Expression* valref = Expression::make_temporary_reference(val, loc);\n   Expression* valaddr = Expression::make_unary(OPERATOR_AND, valref, loc);\n+  Type* unsafe_pointer_type = Type::make_pointer_type(Type::make_void_type());\n+  valaddr = Expression::make_cast(unsafe_pointer_type, valaddr, loc);\n \n-  Expression* call = Runtime::make_call(Runtime::SELECTSEND, loc, 3, selref,\n-\t\t\t\t\tchanref, valaddr);\n-  b->add_statement(Statement::make_statement(call, true));\n+  this->set_case(b, scase, chanref, valaddr, caseSend);\n }\n \n // Lower a receive clause in a select statement.\n \n void\n Select_clauses::Select_clause::lower_recv(Gogo* gogo, Named_object* function,\n-\t\t\t\t\t  Block* b, Expression* selref,\n-\t\t\t\t\t  Expression* chanref)\n+\t\t\t\t\t  Block* b, Expression* scase,\n+\t\t\t\t\t  Expression* chanref,\n+\t\t\t\t\t  Temporary_statement* recvok)\n {\n   Location loc = this->location_;\n \n@@ -4640,26 +4647,10 @@ Select_clauses::Select_clause::lower_recv(Gogo* gogo, Named_object* function,\n \n   Expression* valref = Expression::make_temporary_reference(val, loc);\n   Expression* valaddr = Expression::make_unary(OPERATOR_AND, valref, loc);\n+  Type* unsafe_pointer_type = Type::make_pointer_type(Type::make_void_type());\n+  valaddr = Expression::make_cast(unsafe_pointer_type, valaddr, loc);\n \n-  Temporary_statement* closed_temp = NULL;\n-\n-  Expression* caddr;\n-  if (this->closed_ == NULL && this->closedvar_ == NULL)\n-    caddr = Expression::make_nil(loc);\n-  else\n-    {\n-      closed_temp = Statement::make_temporary(Type::lookup_bool_type(), NULL,\n-\t\t\t\t\t      loc);\n-      b->add_statement(closed_temp);\n-      Expression* cref = Expression::make_temporary_reference(closed_temp,\n-\t\t\t\t\t\t\t      loc);\n-      caddr = Expression::make_unary(OPERATOR_AND, cref, loc);\n-    }\n-\n-  Expression* call = Runtime::make_call(Runtime::SELECTRECV, loc, 4, selref,\n-\t\t\t\t\tchanref, valaddr, caddr);\n-\n-  b->add_statement(Statement::make_statement(call, true));\n+  this->set_case(b, scase, chanref, valaddr, caseRecv);\n \n   // If the block of statements is executed, arrange for the received\n   // value to move from VAL to the place where the statements expect\n@@ -4684,16 +4675,14 @@ Select_clauses::Select_clause::lower_recv(Gogo* gogo, Named_object* function,\n   if (this->closedvar_ != NULL)\n     {\n       go_assert(this->closed_ == NULL);\n-      Expression* cref = Expression::make_temporary_reference(closed_temp,\n-\t\t\t\t\t\t\t      loc);\n+      Expression* cref = Expression::make_temporary_reference(recvok, loc);\n       this->closedvar_->var_value()->set_init(cref);\n     }\n   else if (this->closed_ != NULL && !this->closed_->is_sink_expression())\n     {\n       if (init == NULL)\n \tinit = new Block(b, loc);\n-      Expression* cref = Expression::make_temporary_reference(closed_temp,\n-\t\t\t\t\t\t\t      loc);\n+      Expression* cref = Expression::make_temporary_reference(recvok, loc);\n       init->add_statement(Statement::make_assignment(this->closed_, cref,\n \t\t\t\t\t\t     loc));\n     }\n@@ -4709,6 +4698,45 @@ Select_clauses::Select_clause::lower_recv(Gogo* gogo, Named_object* function,\n     }\n }\n \n+// Set the fields of an scase struct, an element in the array that we\n+// pass to the runtime function selectgo.\n+\n+void\n+Select_clauses::Select_clause::set_case(Block* b,\n+\t\t\t\t\tExpression* scase,\n+\t\t\t\t\tExpression* chanref,\n+\t\t\t\t\tExpression* elem,\n+\t\t\t\t\tint kind)\n+{\n+  Location loc = this->location_;\n+  Struct_type* scase_type = scase->type()->struct_type();\n+\n+  int field_index = 0;\n+  go_assert(scase_type->field(field_index)->is_field_name(\"c\"));\n+  Expression* ref = Expression::make_field_reference(scase, field_index, loc);\n+  Type* unsafe_pointer_type = Type::make_pointer_type(Type::make_void_type());\n+  chanref = Expression::make_unsafe_cast(unsafe_pointer_type, chanref, loc);\n+  Statement* s = Statement::make_assignment(ref, chanref, loc);\n+  b->add_statement(s);\n+\n+  if (elem != NULL)\n+    {\n+      field_index = 1;\n+      go_assert(scase_type->field(field_index)->is_field_name(\"elem\"));\n+      ref = Expression::make_field_reference(scase->copy(), field_index, loc);\n+      s = Statement::make_assignment(ref, elem, loc);\n+      b->add_statement(s);\n+    }\n+\n+  field_index = 2;\n+  go_assert(scase_type->field(field_index)->is_field_name(\"kind\"));\n+  Type* uint16_type = Type::lookup_integer_type(\"uint16\");\n+  Expression* k = Expression::make_integer_ul(kind, uint16_type, loc);\n+  ref = Expression::make_field_reference(scase->copy(), field_index, loc);\n+  s = Statement::make_assignment(ref, k, loc);\n+  b->add_statement(s);\n+}\n+\n // Determine types.\n \n void\n@@ -4828,12 +4856,13 @@ Select_clauses::traverse(Traverse* traverse)\n \n void\n Select_clauses::lower(Gogo* gogo, Named_object* function, Block* b,\n-\t\t      Temporary_statement* sel)\n+\t\t      Temporary_statement* scases, Temporary_statement* recvok)\n {\n+  size_t i = 0;\n   for (Clauses::iterator p = this->clauses_.begin();\n        p != this->clauses_.end();\n-       ++p)\n-    p->lower(gogo, function, b, sel);\n+       ++p, ++i)\n+    p->lower(gogo, function, b, scases, i, recvok);\n }\n \n // Determine types.\n@@ -4872,13 +4901,13 @@ Select_clauses::may_fall_through() const\n   return false;\n }\n \n-// Convert to the backend representation.  We have already accumulated\n-// all the select information.  Now we call selectgo, which will\n-// return the index of the clause to execute.\n+// Convert to the backend representation.  Assemble the clauses and\n+// build a switch statement on the index value returned by the call to\n+// selectgo.\n \n Bstatement*\n Select_clauses::get_backend(Translate_context* context,\n-\t\t\t    Temporary_statement* sel,\n+\t\t\t    Temporary_statement* index,\n \t\t\t    Unnamed_label *break_label,\n \t\t\t    Location location)\n {\n@@ -4909,21 +4938,14 @@ Select_clauses::get_backend(Translate_context* context,\n         clauses[i] = context->backend()->compound_statement(s, g);\n     }\n \n-  Expression* selref = Expression::make_temporary_reference(sel, location);\n-  selref = Expression::make_unary(OPERATOR_AND, selref, location);\n-  Expression* call = Runtime::make_call(Runtime::SELECTGO, location, 1,\n-\t\t\t\t\tselref);\n-  context->gogo()->lower_expression(context->function(), NULL, &call);\n-  Bexpression* bcall = call->get_backend(context);\n-\n-  if (count == 0)\n-    {\n-      Bfunction* bfunction = context->function()->func_value()->get_decl();\n-      return context->backend()->expression_statement(bfunction, bcall);\n-    }\n+  Expression* ref = Expression::make_temporary_reference(index, location);\n+  Bexpression* bindex = ref->get_backend(context);\n \n   Bfunction* bfunction = context->function()->func_value()->get_decl();\n \n+  if (count == 0)\n+    return context->backend()->expression_statement(bfunction, bindex);\n+\n   Expression* crash = Runtime::make_call(Runtime::UNREACHABLE, location, 0);\n   Bexpression* bcrash = crash->get_backend(context);\n   clauses[count] = context->backend()->expression_statement(bfunction, bcrash);\n@@ -4932,7 +4954,7 @@ Select_clauses::get_backend(Translate_context* context,\n   statements.reserve(2);\n \n   Bstatement* switch_stmt = context->backend()->switch_statement(bfunction,\n-\t\t\t\t\t\t\t\t bcall,\n+\t\t\t\t\t\t\t\t bindex,\n \t\t\t\t\t\t\t\t cases,\n \t\t\t\t\t\t\t\t clauses,\n \t\t\t\t\t\t\t\t location);\n@@ -4943,6 +4965,7 @@ Select_clauses::get_backend(Translate_context* context,\n \n   return context->backend()->statement_list(statements);\n }\n+\n // Dump the AST representation for select clauses.\n \n void\n@@ -4967,10 +4990,10 @@ Select_statement::break_label()\n   return this->break_label_;\n }\n \n-// Lower a select statement.  This will still return a select\n-// statement, but it will be modified to implement the order of\n-// evaluation rules, and to include the send and receive statements as\n-// explicit statements in the clauses.\n+// Lower a select statement.  This will return a block containing this\n+// select statement.  The block will implement the order of evaluation\n+// rules, include the send and receive statements as explicit\n+// statements in the clauses, and call the runtime selectgo function.\n \n Statement*\n Select_statement::do_lower(Gogo* gogo, Named_object* function,\n@@ -4983,30 +5006,69 @@ Select_statement::do_lower(Gogo* gogo, Named_object* function,\n \n   Block* b = new Block(enclosing, loc);\n \n-  go_assert(this->sel_ == NULL);\n-\n   int ncases = this->clauses_->size();\n-  Type* selstruct_type = Channel_type::select_type(ncases);\n-  this->sel_ = Statement::make_temporary(selstruct_type, NULL, loc);\n-  b->add_statement(this->sel_);\n+  Type* scase_type = Channel_type::select_case_type();\n+  Expression* ncases_expr =\n+    Expression::make_integer_ul(ncases, NULL,\n+\t\t\t\tLinemap::predeclared_location());\n+  Array_type* scases_type = Type::make_array_type(scase_type, ncases_expr);\n+  scases_type->set_is_array_incomparable();\n+\n+  Temporary_statement* scases = Statement::make_temporary(scases_type, NULL,\n+\t\t\t\t\t\t\t  loc);\n+  b->add_statement(scases);\n \n-  int64_t selstruct_size;\n-  if (!selstruct_type->backend_type_size(gogo, &selstruct_size))\n-    {\n-      go_assert(saw_errors());\n-      return Statement::make_error_statement(loc);\n-    }\n+  Expression* ncases2_expr =\n+    Expression::make_integer_ul(ncases * 2, NULL,\n+\t\t\t\tLinemap::predeclared_location());\n+  Type* uint16_type = Type::lookup_integer_type(\"uint16\");\n+  Array_type* order_type = Type::make_array_type(uint16_type, ncases2_expr);\n+  order_type->set_is_array_incomparable();\n+\n+  Temporary_statement* order = Statement::make_temporary(order_type, NULL,\n+\t\t\t\t\t\t\t loc);\n+  b->add_statement(order);\n \n-  Expression* ref = Expression::make_temporary_reference(this->sel_, loc);\n-  ref = Expression::make_unary(OPERATOR_AND, ref, loc);\n-  Expression* selstruct_size_expr =\n-    Expression::make_integer_int64(selstruct_size, NULL, loc);\n-  Expression* size_expr = Expression::make_integer_ul(ncases, NULL, loc);\n-  Expression* call = Runtime::make_call(Runtime::NEWSELECT, loc, 3,\n-\t\t\t\t\tref, selstruct_size_expr, size_expr);\n-  b->add_statement(Statement::make_statement(call, true));\n+  Type* int_type = Type::lookup_integer_type(\"int\");\n+  this->index_ = Statement::make_temporary(int_type, NULL, loc);\n+  b->add_statement(this->index_);\n+\n+  Type* bool_type = Type::lookup_bool_type();\n+  Temporary_statement* recvok = Statement::make_temporary(bool_type, NULL,\n+\t\t\t\t\t\t\t  loc);\n+  b->add_statement(recvok);\n+\n+  // Initialize the scases array.\n+  this->clauses_->lower(gogo, function, b, scases, recvok);\n+\n+  // Build the call to selectgo.  Later, in do_get_backend, we will\n+  // build a switch on the result that branches to the various cases.\n+\n+  Expression* scases_ref = Expression::make_temporary_reference(scases, loc);\n+  scases_ref = Expression::make_unary(OPERATOR_AND, scases_ref, loc);\n+  Type* unsafe_pointer_type = Type::make_pointer_type(Type::make_void_type());\n+  scases_ref = Expression::make_cast(unsafe_pointer_type, scases_ref, loc);\n+\n+  Expression* order_ref = Expression::make_temporary_reference(order, loc);\n+  order_ref = Expression::make_unary(OPERATOR_AND, order_ref, loc);\n+  order_ref = Expression::make_cast(unsafe_pointer_type, order_ref, loc);\n+\n+  Expression* count_expr = Expression::make_integer_ul(ncases, int_type, loc);\n+\n+  Call_expression* call = Runtime::make_call(Runtime::SELECTGO, loc, 3,\n+\t\t\t\t\t     scases_ref, order_ref,\n+\t\t\t\t\t     count_expr);\n+\n+  Expression* result = Expression::make_call_result(call, 0);\n+  Expression* ref = Expression::make_temporary_reference(this->index_, loc);\n+  Statement* s = Statement::make_assignment(ref, result, loc);\n+  b->add_statement(s);\n+\n+  result = Expression::make_call_result(call, 1);\n+  ref = Expression::make_temporary_reference(recvok, loc);\n+  s = Statement::make_assignment(ref, result, loc);\n+  b->add_statement(s);\n \n-  this->clauses_->lower(gogo, function, b, this->sel_);\n   this->is_lowered_ = true;\n   b->add_statement(this);\n \n@@ -5031,8 +5093,8 @@ Select_statement::do_may_fall_through() const\n Bstatement*\n Select_statement::do_get_backend(Translate_context* context)\n {\n-  return this->clauses_->get_backend(context, this->sel_, this->break_label(),\n-\t\t\t\t     this->location());\n+  return this->clauses_->get_backend(context, this->index_,\n+\t\t\t\t     this->break_label(), this->location());\n }\n \n // Dump the AST representation for a select statement."}, {"sha": "81b26b3e5a9dedfaab1fa0824f919fd9c0db0322", "filename": "gcc/go/gofrontend/statements.h", "status": "modified", "additions": 39, "deletions": 11, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84cdf51de42f823b4ed0d65ef20ab0142607917b/gcc%2Fgo%2Fgofrontend%2Fstatements.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84cdf51de42f823b4ed0d65ef20ab0142607917b/gcc%2Fgo%2Fgofrontend%2Fstatements.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.h?ref=84cdf51de42f823b4ed0d65ef20ab0142607917b", "patch": "@@ -622,7 +622,8 @@ class Temporary_statement : public Statement\n  public:\n   Temporary_statement(Type* type, Expression* init, Location location)\n     : Statement(STATEMENT_TEMPORARY, location),\n-      type_(type), init_(init), bvariable_(NULL), is_address_taken_(false)\n+      type_(type), init_(init), bvariable_(NULL), is_address_taken_(false),\n+      value_escapes_(false)\n   { }\n \n   // Return the type of the temporary variable.\n@@ -640,6 +641,16 @@ class Temporary_statement : public Statement\n   set_is_address_taken()\n   { this->is_address_taken_ = true; }\n \n+  // Whether the value escapes.\n+  bool\n+  value_escapes() const\n+  { return this->value_escapes_; }\n+\n+  // Record that the value escapes.\n+  void\n+  set_value_escapes()\n+  { this->value_escapes_ = true; }\n+\n   // Return the temporary variable.  This should not be called until\n   // after the statement itself has been converted.\n   Bvariable*\n@@ -676,6 +687,9 @@ class Temporary_statement : public Statement\n   Bvariable* bvariable_;\n   // True if something takes the address of this temporary variable.\n   bool is_address_taken_;\n+  // True if the value assigned to this temporary variable escapes.\n+  // This is used for select statements.\n+  bool value_escapes_;\n };\n \n // A variable declaration.  This marks the point in the code where a\n@@ -851,7 +865,7 @@ class Send_statement : public Statement\n \n   Expression*\n   channel()\n-  { return this->channel_; }  \n+  { return this->channel_; }\n \n   Expression*\n   val()\n@@ -924,7 +938,8 @@ class Select_clauses\n \n   // Lower statements.\n   void\n-  lower(Gogo*, Named_object*, Block*, Temporary_statement*);\n+  lower(Gogo*, Named_object*, Block*, Temporary_statement*,\n+\tTemporary_statement*);\n \n   // Determine types.\n   void\n@@ -941,7 +956,7 @@ class Select_clauses\n \n   // Convert to the backend representation.\n   Bstatement*\n-  get_backend(Translate_context*, Temporary_statement* sel,\n+  get_backend(Translate_context*, Temporary_statement* index,\n \t      Unnamed_label* break_label, Location);\n \n   // Dump AST representation.\n@@ -974,7 +989,8 @@ class Select_clauses\n \n     // Lower statements.\n     void\n-    lower(Gogo*, Named_object*, Block*, Temporary_statement*);\n+    lower(Gogo*, Named_object*, Block*, Temporary_statement*, size_t,\n+\t  Temporary_statement*);\n \n     // Determine types.\n     void\n@@ -1027,14 +1043,26 @@ class Select_clauses\n     dump_clause(Ast_dump_context*) const;\n \n    private:\n+    // These values must match the values in libgo/go/runtime/select.go.\n+    enum\n+    {\n+      caseRecv = 1,\n+      caseSend = 2,\n+      caseDefault = 3,\n+    };\n+\n     void\n     lower_default(Block*, Expression*);\n \n     void\n     lower_send(Block*, Expression*, Expression*);\n \n     void\n-    lower_recv(Gogo*, Named_object*, Block*, Expression*, Expression*);\n+    lower_recv(Gogo*, Named_object*, Block*, Expression*, Expression*,\n+\t       Temporary_statement*);\n+\n+    void\n+    set_case(Block*, Expression*, Expression*, Expression*, int);\n \n     // The channel.\n     Expression* channel_;\n@@ -1072,7 +1100,7 @@ class Select_statement : public Statement\n  public:\n   Select_statement(Location location)\n     : Statement(STATEMENT_SELECT, location),\n-      clauses_(NULL), sel_(NULL), break_label_(NULL), is_lowered_(false)\n+      clauses_(NULL), index_(NULL), break_label_(NULL), is_lowered_(false)\n   { }\n \n   // Add the clauses.\n@@ -1115,8 +1143,8 @@ class Select_statement : public Statement\n  private:\n   // The select clauses.\n   Select_clauses* clauses_;\n-  // A temporary which holds the select structure we build up at runtime.\n-  Temporary_statement* sel_;\n+  // A temporary that holds the index value returned by selectgo.\n+  Temporary_statement* index_;\n   // The break label.\n   Unnamed_label* break_label_;\n   // Whether this statement has been lowered.\n@@ -1609,7 +1637,7 @@ class Case_clauses\n   // Dump the AST representation to a dump context.\n   void\n   dump_clauses(Ast_dump_context*) const;\n-  \n+\n  private:\n   // For a constant switch we need to keep a record of constants we\n   // have already seen.\n@@ -1683,7 +1711,7 @@ class Case_clauses\n     // Dump the AST representation to a dump context.\n     void\n     dump_clause(Ast_dump_context*) const;\n-  \n+\n    private:\n     // The list of case expressions.\n     Expression_list* cases_;"}, {"sha": "cc07bfc25bdce9fdca475258f42059189f0cd370", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 12, "deletions": 34, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84cdf51de42f823b4ed0d65ef20ab0142607917b/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84cdf51de42f823b4ed0d65ef20ab0142607917b/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=84cdf51de42f823b4ed0d65ef20ab0142607917b", "patch": "@@ -8557,51 +8557,29 @@ Channel_type::do_import(Import* imp)\n   return Type::make_channel_type(may_send, may_receive, element_type);\n }\n \n-// Return the type to manage a select statement with ncases case\n-// statements.  A value of this type is allocated on the stack.  This\n-// must match the type hselect in libgo/go/runtime/select.go.\n+// Return the type that the runtime package uses for one case of a\n+// select statement.  An array of values of this type is allocated on\n+// the stack.  This must match scase in libgo/go/runtime/select.go.\n \n Type*\n-Channel_type::select_type(int ncases)\n+Channel_type::select_case_type()\n {\n-  Type* unsafe_pointer_type = Type::make_pointer_type(Type::make_void_type());\n-  Type* uint16_type = Type::lookup_integer_type(\"uint16\");\n-\n   static Struct_type* scase_type;\n   if (scase_type == NULL)\n     {\n-      Type* uintptr_type = Type::lookup_integer_type(\"uintptr\");\n-      Type* uint64_type = Type::lookup_integer_type(\"uint64\");\n+      Type* unsafe_pointer_type =\n+\tType::make_pointer_type(Type::make_void_type());\n+      Type* uint16_type = Type::lookup_integer_type(\"uint16\");\n+      Type* int64_type = Type::lookup_integer_type(\"int64\");\n       scase_type =\n-\tType::make_builtin_struct_type(7,\n+\tType::make_builtin_struct_type(4,\n+\t\t\t\t       \"c\", unsafe_pointer_type,\n \t\t\t\t       \"elem\", unsafe_pointer_type,\n-\t\t\t\t       \"chan\", unsafe_pointer_type,\n-\t\t\t\t       \"pc\", uintptr_type,\n \t\t\t\t       \"kind\", uint16_type,\n-\t\t\t\t       \"index\", uint16_type,\n-\t\t\t\t       \"receivedp\", unsafe_pointer_type,\n-\t\t\t\t       \"releasetime\", uint64_type);\n+\t\t\t\t       \"releasetime\", int64_type);\n       scase_type->set_is_struct_incomparable();\n     }\n-\n-  Expression* ncases_expr =\n-    Expression::make_integer_ul(ncases, NULL, Linemap::predeclared_location());\n-  Array_type* scases = Type::make_array_type(scase_type, ncases_expr);\n-  scases->set_is_array_incomparable();\n-  Array_type* order = Type::make_array_type(uint16_type, ncases_expr);\n-  order->set_is_array_incomparable();\n-\n-  Struct_type* ret =\n-    Type::make_builtin_struct_type(7,\n-\t\t\t\t   \"tcase\", uint16_type,\n-\t\t\t\t   \"ncase\", uint16_type,\n-\t\t\t\t   \"pollorder\", unsafe_pointer_type,\n-\t\t\t\t   \"lockorder\", unsafe_pointer_type,\n-\t\t\t\t   \"scase\", scases,\n-\t\t\t\t   \"lockorderarr\", order,\n-\t\t\t\t   \"pollorderarr\", order);\n-  ret->set_is_struct_incomparable();\n-  return ret;\n+  return scase_type;\n }\n \n // Make a new channel type."}, {"sha": "e011236cba50b8bbb13317a93a351919c510b31d", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84cdf51de42f823b4ed0d65ef20ab0142607917b/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84cdf51de42f823b4ed0d65ef20ab0142607917b/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=84cdf51de42f823b4ed0d65ef20ab0142607917b", "patch": "@@ -2981,7 +2981,7 @@ class Channel_type : public Type\n   make_chan_type_descriptor_type();\n \n   static Type*\n-  select_type(int ncases);\n+  select_case_type();\n \n  protected:\n   int"}, {"sha": "9dab052e3bfefa2608dc8cb22b7b79c5cb45eed5", "filename": "libgo/go/runtime/select.go", "status": "modified", "additions": 61, "deletions": 205, "changes": 266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84cdf51de42f823b4ed0d65ef20ab0142607917b/libgo%2Fgo%2Fruntime%2Fselect.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84cdf51de42f823b4ed0d65ef20ab0142607917b/libgo%2Fgo%2Fruntime%2Fselect.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fselect.go?ref=84cdf51de42f823b4ed0d65ef20ab0142607917b", "patch": "@@ -7,146 +7,36 @@ package runtime\n // This file contains the implementation of Go select statements.\n \n import (\n-\t\"runtime/internal/sys\"\n \t\"unsafe\"\n )\n \n // For gccgo, use go:linkname to rename compiler-called functions to\n // themselves, so that the compiler will export them.\n //\n-//go:linkname newselect runtime.newselect\n-//go:linkname selectdefault runtime.selectdefault\n-//go:linkname selectsend runtime.selectsend\n-//go:linkname selectrecv runtime.selectrecv\n //go:linkname selectgo runtime.selectgo\n \n const debugSelect = false\n \n+// scase.kind values.\n+// Known to compiler.\n+// Changes here must also be made in src/cmd/compile/internal/gc/select.go's walkselect.\n const (\n-\t// scase.kind\n \tcaseNil = iota\n \tcaseRecv\n \tcaseSend\n \tcaseDefault\n )\n \n-// Select statement header.\n-// Known to compiler.\n-// Changes here must also be made in src/cmd/internal/gc/select.go's selecttype.\n-type hselect struct {\n-\ttcase     uint16   // total count of scase[]\n-\tncase     uint16   // currently filled scase[]\n-\tpollorder *uint16  // case poll order\n-\tlockorder *uint16  // channel lock order\n-\tscase     [1]scase // one per case (in order of appearance)\n-}\n-\n // Select case descriptor.\n // Known to compiler.\n-// Changes here must also be made in src/cmd/internal/gc/select.go's selecttype.\n+// Changes here must also be made in src/cmd/internal/gc/select.go's scasetype.\n type scase struct {\n-\telem        unsafe.Pointer // data element\n \tc           *hchan         // chan\n-\tpc          uintptr        // return pc (for race detector / msan)\n+\telem        unsafe.Pointer // data element\n \tkind        uint16\n-\treceivedp   *bool // pointer to received bool, if any\n \treleasetime int64\n }\n \n-var (\n-\tchansendpc = funcPC(chansend)\n-\tchanrecvpc = funcPC(chanrecv)\n-)\n-\n-func selectsize(size uintptr) uintptr {\n-\tselsize := unsafe.Sizeof(hselect{}) +\n-\t\t(size-1)*unsafe.Sizeof(hselect{}.scase[0]) +\n-\t\tsize*unsafe.Sizeof(*hselect{}.lockorder) +\n-\t\tsize*unsafe.Sizeof(*hselect{}.pollorder)\n-\treturn round(selsize, sys.Int64Align)\n-}\n-\n-func newselect(sel *hselect, selsize int64, size int32) {\n-\tif selsize != int64(selectsize(uintptr(size))) {\n-\t\tprint(\"runtime: bad select size \", selsize, \", want \", selectsize(uintptr(size)), \"\\n\")\n-\t\tthrow(\"bad select size\")\n-\t}\n-\tif size != int32(uint16(size)) {\n-\t\tthrow(\"select size too large\")\n-\t}\n-\tsel.tcase = uint16(size)\n-\tsel.ncase = 0\n-\tsel.lockorder = (*uint16)(add(unsafe.Pointer(&sel.scase), uintptr(size)*unsafe.Sizeof(hselect{}.scase[0])))\n-\tsel.pollorder = (*uint16)(add(unsafe.Pointer(sel.lockorder), uintptr(size)*unsafe.Sizeof(*hselect{}.lockorder)))\n-\n-\t// For gccgo the temporary variable will not have been zeroed.\n-\tmemclrNoHeapPointers(unsafe.Pointer(&sel.scase), uintptr(size)*unsafe.Sizeof(hselect{}.scase[0])+uintptr(size)*unsafe.Sizeof(*hselect{}.lockorder)+uintptr(size)*unsafe.Sizeof(*hselect{}.pollorder))\n-\n-\tif debugSelect {\n-\t\tprint(\"newselect s=\", sel, \" size=\", size, \"\\n\")\n-\t}\n-}\n-\n-func selectsend(sel *hselect, c *hchan, elem unsafe.Pointer) {\n-\tpc := getcallerpc()\n-\ti := sel.ncase\n-\tif i >= sel.tcase {\n-\t\tthrow(\"selectsend: too many cases\")\n-\t}\n-\tsel.ncase = i + 1\n-\tif c == nil {\n-\t\treturn\n-\t}\n-\tcas := (*scase)(add(unsafe.Pointer(&sel.scase), uintptr(i)*unsafe.Sizeof(sel.scase[0])))\n-\tcas.pc = pc\n-\tcas.c = c\n-\tcas.kind = caseSend\n-\tcas.elem = elem\n-\n-\tif debugSelect {\n-\t\tprint(\"selectsend s=\", sel, \" pc=\", hex(cas.pc), \" chan=\", cas.c, \"\\n\")\n-\t}\n-}\n-\n-func selectrecv(sel *hselect, c *hchan, elem unsafe.Pointer, received *bool) {\n-\tpc := getcallerpc()\n-\ti := sel.ncase\n-\tif i >= sel.tcase {\n-\t\tthrow(\"selectrecv: too many cases\")\n-\t}\n-\tsel.ncase = i + 1\n-\tif c == nil {\n-\t\treturn\n-\t}\n-\tcas := (*scase)(add(unsafe.Pointer(&sel.scase), uintptr(i)*unsafe.Sizeof(sel.scase[0])))\n-\tcas.pc = pc\n-\tcas.c = c\n-\tcas.kind = caseRecv\n-\tcas.elem = elem\n-\tcas.receivedp = received\n-\n-\tif debugSelect {\n-\t\tprint(\"selectrecv s=\", sel, \" pc=\", hex(cas.pc), \" chan=\", cas.c, \"\\n\")\n-\t}\n-}\n-\n-func selectdefault(sel *hselect) {\n-\tpc := getcallerpc()\n-\ti := sel.ncase\n-\tif i >= sel.tcase {\n-\t\tthrow(\"selectdefault: too many cases\")\n-\t}\n-\tsel.ncase = i + 1\n-\tcas := (*scase)(add(unsafe.Pointer(&sel.scase), uintptr(i)*unsafe.Sizeof(sel.scase[0])))\n-\tcas.pc = pc\n-\tcas.c = nil\n-\tcas.kind = caseDefault\n-\n-\tif debugSelect {\n-\t\tprint(\"selectdefault s=\", sel, \" pc=\", hex(cas.pc), \"\\n\")\n-\t}\n-}\n-\n func sellock(scases []scase, lockorder []uint16) {\n \tvar c *hchan\n \tfor _, o := range lockorder {\n@@ -209,26 +99,39 @@ func block() {\n \n // selectgo implements the select statement.\n //\n-// *sel is on the current goroutine's stack (regardless of any\n-// escaping in selectgo).\n+// cas0 points to an array of type [ncases]scase, and order0 points to\n+// an array of type [2*ncases]uint16. Both reside on the goroutine's\n+// stack (regardless of any escaping in selectgo).\n //\n // selectgo returns the index of the chosen scase, which matches the\n // ordinal position of its respective select{recv,send,default} call.\n-func selectgo(sel *hselect) int {\n+// Also, if the chosen scase was a receive operation, it returns whether\n+// a value was received.\n+func selectgo(cas0 *scase, order0 *uint16, ncases int) (int, bool) {\n \tif debugSelect {\n-\t\tprint(\"select: sel=\", sel, \"\\n\")\n-\t}\n-\tif sel.ncase != sel.tcase {\n-\t\tthrow(\"selectgo: case count mismatch\")\n+\t\tprint(\"select: cas0=\", cas0, \"\\n\")\n \t}\n \n-\tscaseslice := slice{unsafe.Pointer(&sel.scase), int(sel.ncase), int(sel.ncase)}\n-\tscases := *(*[]scase)(unsafe.Pointer(&scaseslice))\n+\tcas1 := (*[1 << 16]scase)(unsafe.Pointer(cas0))\n+\torder1 := (*[1 << 17]uint16)(unsafe.Pointer(order0))\n+\n+\tscases := cas1[:ncases:ncases]\n+\tpollorder := order1[:ncases:ncases]\n+\tlockorder := order1[ncases:][:ncases:ncases]\n+\n+\t// Replace send/receive cases involving nil channels with\n+\t// caseNil so logic below can assume non-nil channel.\n+\tfor i := range scases {\n+\t\tcas := &scases[i]\n+\t\tif cas.c == nil && cas.kind != caseDefault {\n+\t\t\t*cas = scase{}\n+\t\t}\n+\t}\n \n \tvar t0 int64\n \tif blockprofilerate > 0 {\n \t\tt0 = cputicks()\n-\t\tfor i := 0; i < int(sel.ncase); i++ {\n+\t\tfor i := 0; i < ncases; i++ {\n \t\t\tscases[i].releasetime = -1\n \t\t}\n \t}\n@@ -241,20 +144,21 @@ func selectgo(sel *hselect) int {\n \t// cases correctly, and they are rare enough not to bother\n \t// optimizing (and needing to test).\n \n+\t// needed for gccgo, which doesn't zero pollorder\n+\tif ncases > 0 {\n+\t\tpollorder[0] = 0\n+\t}\n+\n \t// generate permuted order\n-\tpollslice := slice{unsafe.Pointer(sel.pollorder), int(sel.ncase), int(sel.ncase)}\n-\tpollorder := *(*[]uint16)(unsafe.Pointer(&pollslice))\n-\tfor i := 1; i < int(sel.ncase); i++ {\n+\tfor i := 1; i < ncases; i++ {\n \t\tj := fastrandn(uint32(i + 1))\n \t\tpollorder[i] = pollorder[j]\n \t\tpollorder[j] = uint16(i)\n \t}\n \n \t// sort the cases by Hchan address to get the locking order.\n \t// simple heap sort, to guarantee n log n time and constant stack footprint.\n-\tlockslice := slice{unsafe.Pointer(sel.lockorder), int(sel.ncase), int(sel.ncase)}\n-\tlockorder := *(*[]uint16)(unsafe.Pointer(&lockslice))\n-\tfor i := 0; i < int(sel.ncase); i++ {\n+\tfor i := 0; i < ncases; i++ {\n \t\tj := i\n \t\t// Start with the pollorder to permute cases on the same channel.\n \t\tc := scases[pollorder[i]].c\n@@ -265,7 +169,7 @@ func selectgo(sel *hselect) int {\n \t\t}\n \t\tlockorder[j] = pollorder[i]\n \t}\n-\tfor i := int(sel.ncase) - 1; i >= 0; i-- {\n+\tfor i := ncases - 1; i >= 0; i-- {\n \t\to := lockorder[i]\n \t\tc := scases[o].c\n \t\tlockorder[i] = lockorder[0]\n@@ -287,14 +191,15 @@ func selectgo(sel *hselect) int {\n \t\t}\n \t\tlockorder[j] = o\n \t}\n-\t/*\n-\t\tfor i := 0; i+1 < int(sel.ncase); i++ {\n+\n+\tif debugSelect {\n+\t\tfor i := 0; i+1 < ncases; i++ {\n \t\t\tif scases[lockorder[i]].c.sortkey() > scases[lockorder[i+1]].c.sortkey() {\n \t\t\t\tprint(\"i=\", i, \" x=\", lockorder[i], \" y=\", lockorder[i+1], \"\\n\")\n \t\t\t\tthrow(\"select: broken sort\")\n \t\t\t}\n \t\t}\n-\t*/\n+\t}\n \n \t// lock all the channels involved in the select\n \tsellock(scases, lockorder)\n@@ -316,7 +221,8 @@ loop:\n \tvar dfl *scase\n \tvar casi int\n \tvar cas *scase\n-\tfor i := 0; i < int(sel.ncase); i++ {\n+\tvar recvOK bool\n+\tfor i := 0; i < ncases; i++ {\n \t\tcasi = int(pollorder[i])\n \t\tcas = &scases[casi]\n \t\tc = cas.c\n@@ -338,9 +244,6 @@ loop:\n \t\t\t}\n \n \t\tcase caseSend:\n-\t\t\tif raceenabled {\n-\t\t\t\tracereadpc(unsafe.Pointer(c), cas.pc, chansendpc)\n-\t\t\t}\n \t\t\tif c.closed != 0 {\n \t\t\t\tgoto sclose\n \t\t\t}\n@@ -469,46 +372,19 @@ loop:\n \tc = cas.c\n \n \tif debugSelect {\n-\t\tprint(\"wait-return: sel=\", sel, \" c=\", c, \" cas=\", cas, \" kind=\", cas.kind, \"\\n\")\n+\t\tprint(\"wait-return: cas0=\", cas0, \" c=\", c, \" cas=\", cas, \" kind=\", cas.kind, \"\\n\")\n \t}\n \n-\tif cas.kind == caseRecv && cas.receivedp != nil {\n-\t\t*cas.receivedp = true\n-\t}\n-\n-\tif raceenabled {\n-\t\tif cas.kind == caseRecv && cas.elem != nil {\n-\t\t\traceWriteObjectPC(c.elemtype, cas.elem, cas.pc, chanrecvpc)\n-\t\t} else if cas.kind == caseSend {\n-\t\t\traceReadObjectPC(c.elemtype, cas.elem, cas.pc, chansendpc)\n-\t\t}\n-\t}\n-\tif msanenabled {\n-\t\tif cas.kind == caseRecv && cas.elem != nil {\n-\t\t\tmsanwrite(cas.elem, c.elemtype.size)\n-\t\t} else if cas.kind == caseSend {\n-\t\t\tmsanread(cas.elem, c.elemtype.size)\n-\t\t}\n+\tif cas.kind == caseRecv {\n+\t\trecvOK = true\n \t}\n \n \tselunlock(scases, lockorder)\n \tgoto retc\n \n bufrecv:\n \t// can receive from buffer\n-\tif raceenabled {\n-\t\tif cas.elem != nil {\n-\t\t\traceWriteObjectPC(c.elemtype, cas.elem, cas.pc, chanrecvpc)\n-\t\t}\n-\t\traceacquire(chanbuf(c, c.recvx))\n-\t\tracerelease(chanbuf(c, c.recvx))\n-\t}\n-\tif msanenabled && cas.elem != nil {\n-\t\tmsanwrite(cas.elem, c.elemtype.size)\n-\t}\n-\tif cas.receivedp != nil {\n-\t\t*cas.receivedp = true\n-\t}\n+\trecvOK = true\n \tqp = chanbuf(c, c.recvx)\n \tif cas.elem != nil {\n \t\ttypedmemmove(c.elemtype, cas.elem, qp)\n@@ -524,14 +400,6 @@ bufrecv:\n \n bufsend:\n \t// can send to buffer\n-\tif raceenabled {\n-\t\traceacquire(chanbuf(c, c.sendx))\n-\t\tracerelease(chanbuf(c, c.sendx))\n-\t\traceReadObjectPC(c.elemtype, cas.elem, cas.pc, chansendpc)\n-\t}\n-\tif msanenabled {\n-\t\tmsanread(cas.elem, c.elemtype.size)\n-\t}\n \ttypedmemmove(c.elemtype, chanbuf(c, c.sendx), cas.elem)\n \tc.sendx++\n \tif c.sendx == c.dataqsiz {\n@@ -545,19 +413,15 @@ recv:\n \t// can receive from sleeping sender (sg)\n \trecv(c, sg, cas.elem, func() { selunlock(scases, lockorder) }, 2)\n \tif debugSelect {\n-\t\tprint(\"syncrecv: sel=\", sel, \" c=\", c, \"\\n\")\n-\t}\n-\tif cas.receivedp != nil {\n-\t\t*cas.receivedp = true\n+\t\tprint(\"syncrecv: cas0=\", cas0, \" c=\", c, \"\\n\")\n \t}\n+\trecvOK = true\n \tgoto retc\n \n rclose:\n \t// read at end of closed channel\n \tselunlock(scases, lockorder)\n-\tif cas.receivedp != nil {\n-\t\t*cas.receivedp = false\n-\t}\n+\trecvOK = false\n \tif cas.elem != nil {\n \t\ttypedmemclr(c.elemtype, cas.elem)\n \t}\n@@ -568,15 +432,9 @@ rclose:\n \n send:\n \t// can send to a sleeping receiver (sg)\n-\tif raceenabled {\n-\t\traceReadObjectPC(c.elemtype, cas.elem, cas.pc, chansendpc)\n-\t}\n-\tif msanenabled {\n-\t\tmsanread(cas.elem, c.elemtype.size)\n-\t}\n \tsend(c, sg, cas.elem, func() { selunlock(scases, lockorder) }, 2)\n \tif debugSelect {\n-\t\tprint(\"syncsend: sel=\", sel, \" c=\", c, \"\\n\")\n+\t\tprint(\"syncsend: cas0=\", cas0, \" c=\", c, \"\\n\")\n \t}\n \tgoto retc\n \n@@ -591,7 +449,7 @@ retc:\n \t\tcheckPreempt()\n \t}\n \n-\treturn casi\n+\treturn casi, recvOK\n \n sclose:\n \t// send on closed channel\n@@ -625,27 +483,25 @@ const (\n )\n \n //go:linkname reflect_rselect reflect.rselect\n-func reflect_rselect(cases []runtimeSelect) (chosen int, recvOK bool) {\n-\t// flagNoScan is safe here, because all objects are also referenced from cases.\n-\tsize := selectsize(uintptr(len(cases)))\n-\tsel := (*hselect)(mallocgc(size, nil, true))\n-\tnewselect(sel, int64(size), int32(len(cases)))\n-\tr := new(bool)\n+func reflect_rselect(cases []runtimeSelect) (int, bool) {\n+\tif len(cases) == 0 {\n+\t\tblock()\n+\t}\n+\tsel := make([]scase, len(cases))\n+\torder := make([]uint16, 2*len(cases))\n \tfor i := range cases {\n \t\trc := &cases[i]\n \t\tswitch rc.dir {\n \t\tcase selectDefault:\n-\t\t\tselectdefault(sel)\n+\t\t\tsel[i] = scase{kind: caseDefault}\n \t\tcase selectSend:\n-\t\t\tselectsend(sel, rc.ch, rc.val)\n+\t\t\tsel[i] = scase{kind: caseSend, c: rc.ch, elem: rc.val}\n \t\tcase selectRecv:\n-\t\t\tselectrecv(sel, rc.ch, rc.val, r)\n+\t\t\tsel[i] = scase{kind: caseRecv, c: rc.ch, elem: rc.val}\n \t\t}\n \t}\n \n-\tchosen = selectgo(sel)\n-\trecvOK = *r\n-\treturn\n+\treturn selectgo(&sel[0], &order[0], len(cases))\n }\n \n func (q *waitq) dequeueSudoG(sgp *sudog) {"}]}