{"sha": "8c2dfb32b76245329231a8b435aff957340b863d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGMyZGZiMzJiNzYyNDUzMjkyMzFhOGI0MzVhZmY5NTczNDBiODYzZA==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@cygnus.com", "date": "1998-12-14T11:25:19Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "1998-12-14T11:25:19Z"}, "message": "gjavah.c (decompile_method): Decompile `return null'.\n\n\t* gjavah.c (decompile_method): Decompile `return null'.\n\t(process_file): Generate `#pragma interface'.\n\t(method_declared): New global.\n\t(print_method_info): Set it.\n\t(HANDLE_CODE_ATTRIBUTE): Only print it method_declared set.\n\t(print_method_info): Handle abstract methods.\n\nFrom-SVN: r24309", "tree": {"sha": "a295404c16f11a6d0ee61912810574c8b388f99e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a295404c16f11a6d0ee61912810574c8b388f99e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8c2dfb32b76245329231a8b435aff957340b863d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c2dfb32b76245329231a8b435aff957340b863d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c2dfb32b76245329231a8b435aff957340b863d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c2dfb32b76245329231a8b435aff957340b863d/comments", "author": null, "committer": null, "parents": [{"sha": "9fe3461ee717754d600eadccaf6893f68b3e2c80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fe3461ee717754d600eadccaf6893f68b3e2c80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fe3461ee717754d600eadccaf6893f68b3e2c80"}], "stats": {"total": 32, "additions": 31, "deletions": 1}, "files": [{"sha": "f81222fb3dbde5178cc6113e1554428e6a46186e", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c2dfb32b76245329231a8b435aff957340b863d/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c2dfb32b76245329231a8b435aff957340b863d/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=8c2dfb32b76245329231a8b435aff957340b863d", "patch": "@@ -1,3 +1,12 @@\n+1998-12-14  Tom Tromey  <tromey@cygnus.com>\n+\n+\t* gjavah.c (decompile_method): Decompile `return null'.\n+\t(process_file): Generate `#pragma interface'.\n+\t(method_declared): New global.\n+\t(print_method_info): Set it.\n+\t(HANDLE_CODE_ATTRIBUTE): Only print it method_declared set.\n+\t(print_method_info): Handle abstract methods.\n+\n Sun Dec 13 17:31:40 1998  Per Bothner  <bothner@cygnus.com>\n \n \t* parse.y (patch_method_invocation):  If class_decl is null"}, {"sha": "8fa0d0eb738241b7267253bf773836020594b50d", "filename": "gcc/java/gjavah.c", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c2dfb32b76245329231a8b435aff957340b863d/gcc%2Fjava%2Fgjavah.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c2dfb32b76245329231a8b435aff957340b863d/gcc%2Fjava%2Fgjavah.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fgjavah.c?ref=8c2dfb32b76245329231a8b435aff957340b863d", "patch": "@@ -124,14 +124,15 @@ static int field_pass;\n \n #define HANDLE_CONSTANTVALUE(VALUEINDEX) current_field_value = (VALUEINDEX)\n \n+static int method_declared = 0;\n static int method_access = 0;\n #define HANDLE_METHOD(ACCESS_FLAGS, NAME, SIGNATURE, ATTRIBUTE_COUNT) \\\n   if (out) { decompiled = 0; \\\n       print_method_info (out, jcf, NAME, SIGNATURE, ACCESS_FLAGS); \\\n   }\n \n #define HANDLE_CODE_ATTRIBUTE(MAX_STACK, MAX_LOCALS, CODE_LENGTH) \\\n-  if (out) decompile_method (out, jcf, CODE_LENGTH);\n+  if (out && method_declared) decompile_method (out, jcf, CODE_LENGTH);\n \n static int decompiled = 0;\n #define HANDLE_END_METHOD() \\\n@@ -399,6 +400,7 @@ DEFUN(print_method_info, (stream, jcf, name_index, sig_index, flags),\n   int length, is_init = 0;\n   char *override = NULL;\n \n+  method_declared = 0;\n   method_access = flags;\n   if (JPOOL_TAG (jcf, name_index) != CONSTANT_Utf8)\n     fprintf (stream, \"<not a UTF8 constant>\");\n@@ -453,6 +455,11 @@ DEFUN(print_method_info, (stream, jcf, name_index, sig_index, flags),\n \tfputs (\"virtual \", out);\n     }\n   print_c_decl (out, jcf, name_index, sig_index, flags, is_init, override);\n+\n+  if ((flags & ACC_ABSTRACT))\n+    fputs (\" = 0\", out);\n+  else\n+    method_declared = 1;\n }\n \n /* Try to decompile a method body.  Right now we just try to handle a\n@@ -506,6 +513,15 @@ decompile_method (out, jcf, code_len)\n       fputs (\" { }\", out);\n       decompiled = 1;\n     }\n+  else if (code_len == 2\n+\t   && codes[0] == OPCODE_aconst_null\n+\t   && codes[1] == OPCODE_areturn)\n+    {\n+      /* Found `return null'.  We don't want to depend on NULL being\n+\t defined.  */\n+      fputs (\" { return 0; }\", out);\n+      decompiled = 1;\n+    }\n }\n \n /* Print one piece of a signature.  Returns pointer to next parseable\n@@ -833,6 +849,11 @@ DEFUN(process_file, (jcf, out),\n \n       print_mangled_classname (out, jcf, \"#define __\", jcf->this_class);\n       fprintf (out, \"__\\n\\n\");\n+\n+      /* We do this to ensure that inline methods won't be `outlined'\n+\t by g++.  This works as long as method and fields are not\n+\t added by the user.  */\n+      fprintf (out, \"#pragma interface\\n\\n\");\n     }\n \n   if (jcf->super_class && out)"}]}