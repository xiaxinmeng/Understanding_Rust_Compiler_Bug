{"sha": "12d9ce19034428072b3779eff017c5e129ee4c0e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTJkOWNlMTkwMzQ0MjgwNzJiMzc3OWVmZjAxN2M1ZTEyOWVlNGMwZQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2014-12-17T20:41:18Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2014-12-17T20:41:18Z"}, "message": "re PR c++/64333 (C++14 constexpr gives wrong results when a looping constexpr function is evaluated twice)\n\n\tPR c++/64333\n\t* constexpr.c (cxx_bind_parameters_in_call): non_constant_args parm.\n\t(cxx_eval_call_expression): Don't cache calls with non-constant args.\n\t(cxx_eval_constant_expression) [COMPOUND_EXPR]: Pass true for lval.\n\t(cxx_eval_unary_expression, cxx_eval_binary_expression)\n\t(cxx_eval_conditional_expression): Pass\tfalse for lval.\n\nFrom-SVN: r218832", "tree": {"sha": "dfc5f8c7bb2b4b522da4a02ec8e17658f3a656ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dfc5f8c7bb2b4b522da4a02ec8e17658f3a656ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/12d9ce19034428072b3779eff017c5e129ee4c0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12d9ce19034428072b3779eff017c5e129ee4c0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12d9ce19034428072b3779eff017c5e129ee4c0e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12d9ce19034428072b3779eff017c5e129ee4c0e/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "92a596e856e165a28c245fcc29e72baf8283cf9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92a596e856e165a28c245fcc29e72baf8283cf9c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92a596e856e165a28c245fcc29e72baf8283cf9c"}], "stats": {"total": 130, "additions": 89, "deletions": 41}, "files": [{"sha": "e7e2365353e07269572aa8ef18627728727215ce", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12d9ce19034428072b3779eff017c5e129ee4c0e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12d9ce19034428072b3779eff017c5e129ee4c0e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=12d9ce19034428072b3779eff017c5e129ee4c0e", "patch": "@@ -1,5 +1,12 @@\n 2014-12-17  Jason Merrill  <jason@redhat.com>\n \n+\tPR c++/64333\n+\t* constexpr.c (cxx_bind_parameters_in_call): non_constant_args parm.\n+\t(cxx_eval_call_expression): Don't cache calls with non-constant args.\n+\t(cxx_eval_constant_expression) [COMPOUND_EXPR]: Pass true for lval.\n+\t(cxx_eval_unary_expression, cxx_eval_binary_expression)\n+\t(cxx_eval_conditional_expression): Pass\tfalse for lval.\n+\n \t* constexpr.c: Change \"addr\" parm names to \"lval\".\n \n \t* constexpr.c: Tweak comments and formatting."}, {"sha": "afbcf51fec127f00009d6e31114e0ef29d6a6bf3", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 48, "deletions": 41, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12d9ce19034428072b3779eff017c5e129ee4c0e/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12d9ce19034428072b3779eff017c5e129ee4c0e/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=12d9ce19034428072b3779eff017c5e129ee4c0e", "patch": "@@ -1050,7 +1050,8 @@ adjust_temp_type (tree type, tree temp)\n static void\n cxx_bind_parameters_in_call (const constexpr_ctx *ctx, tree t,\n                              constexpr_call *new_call,\n-\t\t\t     bool *non_constant_p, bool *overflow_p)\n+\t\t\t     bool *non_constant_p, bool *overflow_p,\n+\t\t\t     bool *non_constant_args)\n {\n   const int nargs = call_expr_nargs (t);\n   tree fun = new_call->fundef->decl;\n@@ -1099,6 +1100,8 @@ cxx_bind_parameters_in_call (const constexpr_ctx *ctx, tree t,\n       /* Make sure the binding has the same type as the parm.  */\n       if (TREE_CODE (type) != REFERENCE_TYPE)\n \targ = adjust_temp_type (type, arg);\n+      if (!TREE_CONSTANT (arg))\n+\t*non_constant_args = true;\n       *p = build_tree_list (parms, arg);\n       p = &TREE_CHAIN (*p);\n     next:\n@@ -1155,10 +1158,7 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n {\n   location_t loc = EXPR_LOC_OR_LOC (t, input_location);\n   tree fun = get_function_named_in_call (t);\n-  tree result;\n   constexpr_call new_call = { NULL, NULL, NULL, 0 };\n-  constexpr_call **slot;\n-  constexpr_call *entry;\n   bool depth_ok;\n \n   if (fun == NULL_TREE)\n@@ -1264,36 +1264,45 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n       ctx = &new_ctx;\n     }\n \n+  bool non_constant_args = false;\n   cxx_bind_parameters_in_call (ctx, t, &new_call,\n-\t\t\t       non_constant_p, overflow_p);\n+\t\t\t       non_constant_p, overflow_p, &non_constant_args);\n   if (*non_constant_p)\n     return t;\n \n   depth_ok = push_cx_call_context (t);\n \n-  new_call.hash\n-    = iterative_hash_template_arg (new_call.bindings,\n-\t\t\t\t   constexpr_fundef_hasher::hash (new_call.fundef));\n+  tree result = NULL_TREE;\n \n-  /* If we have seen this call before, we are done.  */\n-  maybe_initialize_constexpr_call_table ();\n-  slot = constexpr_call_table->find_slot (&new_call, INSERT);\n-  entry = *slot;\n-  if (entry == NULL)\n+  constexpr_call *entry = NULL;\n+  if (!non_constant_args)\n     {\n-      /* We need to keep a pointer to the entry, not just the slot, as the\n-\t slot can move in the call to cxx_eval_builtin_function_call.  */\n-      *slot = entry = ggc_alloc<constexpr_call> ();\n-      *entry = new_call;\n-    }\n-  /* Calls which are in progress have their result set to NULL\n-     so that we can detect circular dependencies.  */\n-  else if (entry->result == NULL)\n-    {\n-      if (!ctx->quiet)\n-\terror (\"call has circular dependency\");\n-      *non_constant_p = true;\n-      entry->result = result = error_mark_node;\n+      new_call.hash = iterative_hash_template_arg\n+\t(new_call.bindings, constexpr_fundef_hasher::hash (new_call.fundef));\n+\n+      /* If we have seen this call before, we are done.  */\n+      maybe_initialize_constexpr_call_table ();\n+      constexpr_call **slot\n+\t= constexpr_call_table->find_slot (&new_call, INSERT);\n+      entry = *slot;\n+      if (entry == NULL)\n+\t{\n+\t  /* We need to keep a pointer to the entry, not just the slot, as the\n+\t     slot can move in the call to cxx_eval_builtin_function_call.  */\n+\t  *slot = entry = ggc_alloc<constexpr_call> ();\n+\t  *entry = new_call;\n+\t}\n+      /* Calls which are in progress have their result set to NULL\n+\t so that we can detect circular dependencies.  */\n+      else if (entry->result == NULL)\n+\t{\n+\t  if (!ctx->quiet)\n+\t    error (\"call has circular dependency\");\n+\t  *non_constant_p = true;\n+\t  entry->result = result = error_mark_node;\n+\t}\n+      else\n+\tresult = entry->result;\n     }\n \n   if (!depth_ok)\n@@ -1303,11 +1312,10 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n \t       \"-fconstexpr-depth= to increase the maximum)\",\n \t       max_constexpr_depth);\n       *non_constant_p = true;\n-      entry->result = result = error_mark_node;\n+      result = error_mark_node;\n     }\n   else\n     {\n-      result = entry->result;\n       if (!result || result == error_mark_node)\n \t{\n \t  if (!use_new_call)\n@@ -1395,7 +1403,7 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n       if (result == error_mark_node)\n \t*non_constant_p = true;\n       if (*non_constant_p)\n-\tentry->result = result = error_mark_node;\n+\tresult = error_mark_node;\n       else if (result)\n \t{\n \t  /* If this was a call to initialize an object, set the type of\n@@ -1409,10 +1417,11 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n \t      result = adjust_temp_type (TREE_TYPE (TREE_TYPE (ob_arg)),\n \t\t\t\t\t result);\n \t    }\n-\t  entry->result = result;\n \t}\n       else\n \tresult = void_node;\n+      if (entry)\n+\tentry->result = result;\n     }\n \n   pop_cx_call_context ();\n@@ -1558,13 +1567,13 @@ cxx_eval_check_shift_p (location_t loc, const constexpr_ctx *ctx,\n \n static tree\n cxx_eval_unary_expression (const constexpr_ctx *ctx, tree t,\n-\t\t\t   bool lval,\n+\t\t\t   bool /*lval*/,\n \t\t\t   bool *non_constant_p, bool *overflow_p)\n {\n   tree r;\n   tree orig_arg = TREE_OPERAND (t, 0);\n-  tree arg = cxx_eval_constant_expression (ctx, orig_arg,\n-\t\t\t\t\t   lval, non_constant_p, overflow_p);\n+  tree arg = cxx_eval_constant_expression (ctx, orig_arg, /*lval*/false,\n+\t\t\t\t\t   non_constant_p, overflow_p);\n   VERIFY_CONSTANT (arg);\n   location_t loc = EXPR_LOCATION (t);\n   enum tree_code code = TREE_CODE (t);\n@@ -1586,19 +1595,17 @@ cxx_eval_unary_expression (const constexpr_ctx *ctx, tree t,\n \n static tree\n cxx_eval_binary_expression (const constexpr_ctx *ctx, tree t,\n-\t\t\t    bool lval,\n+\t\t\t    bool /*lval*/,\n \t\t\t    bool *non_constant_p, bool *overflow_p)\n {\n   tree r;\n   tree orig_lhs = TREE_OPERAND (t, 0);\n   tree orig_rhs = TREE_OPERAND (t, 1);\n   tree lhs, rhs;\n-  lhs = cxx_eval_constant_expression (ctx, orig_lhs,\n-\t\t\t\t      lval,\n+  lhs = cxx_eval_constant_expression (ctx, orig_lhs, /*lval*/false,\n \t\t\t\t      non_constant_p, overflow_p);\n   VERIFY_CONSTANT (lhs);\n-  rhs = cxx_eval_constant_expression (ctx, orig_rhs,\n-\t\t\t\t      lval,\n+  rhs = cxx_eval_constant_expression (ctx, orig_rhs, /*lval*/false,\n \t\t\t\t      non_constant_p, overflow_p);\n   VERIFY_CONSTANT (rhs);\n \n@@ -1630,7 +1637,7 @@ cxx_eval_conditional_expression (const constexpr_ctx *ctx, tree t,\n \t\t\t\t tree *jump_target)\n {\n   tree val = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 0),\n-\t\t\t\t\t   lval,\n+\t\t\t\t\t   /*lval*/false,\n \t\t\t\t\t   non_constant_p, overflow_p);\n   VERIFY_CONSTANT (val);\n   /* Don't VERIFY_CONSTANT the other operands.  */\n@@ -3085,7 +3092,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \tr = *p;\n       else\n \t{\n-\t  r = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 0), addr,\n+\t  r = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 0), false,\n \t\t\t\t\t    non_constant_p, overflow_p);\n \t  ctx->values->put (t, r);\n \t}\n@@ -3174,7 +3181,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t  {\n \t    /* Check that the LHS is constant and then discard it.  */\n \t    cxx_eval_constant_expression (ctx, op0,\n-\t\t\t\t\t  false, non_constant_p, overflow_p,\n+\t\t\t\t\t  true, non_constant_p, overflow_p,\n \t\t\t\t\t  jump_target);\n \t    op1 = TREE_OPERAND (t, 1);\n \t    r = cxx_eval_constant_expression (ctx, op1,"}, {"sha": "bdef8a101a5c65efc210411333e790934ad5fb4c", "filename": "gcc/testsuite/g++.dg/cpp1y/constexpr-initlist1.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12d9ce19034428072b3779eff017c5e129ee4c0e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-initlist1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12d9ce19034428072b3779eff017c5e129ee4c0e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-initlist1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-initlist1.C?ref=12d9ce19034428072b3779eff017c5e129ee4c0e", "patch": "@@ -0,0 +1,22 @@\n+// PR c++/64333\n+// { dg-do compile { target c++14 } }\n+#include <initializer_list>\n+\n+constexpr int max(std::initializer_list<int> ints)\n+{\n+        int ret = *(ints.begin());\n+        for (int i = 0; i < ints.size(); ++i) {\n+                if (*(ints.begin()+i) > ret) {\n+                        ret = *(ints.begin()+i);\n+                }\n+        }\n+        return ret;\n+}\n+\n+int main()\n+{\n+        constexpr int z = max({7,6,5,4,3,2,1});\n+        constexpr int z2 = max({5,4,3,2,1});\n+        static_assert(z == 7, \"\");\n+        static_assert(z2 == 5, \"\");\n+}"}, {"sha": "2e53e4831d3d6d3a36483024c28f3cedbf95bdd8", "filename": "gcc/testsuite/g++.dg/cpp1y/constexpr-loop2.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12d9ce19034428072b3779eff017c5e129ee4c0e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-loop2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12d9ce19034428072b3779eff017c5e129ee4c0e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-loop2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-loop2.C?ref=12d9ce19034428072b3779eff017c5e129ee4c0e", "patch": "@@ -0,0 +1,12 @@\n+// { dg-do compile { target c++14 } }\n+\n+constexpr int f(int* p) { return *p; }\n+constexpr int g(int n)\n+{\n+  int sum = 0;\n+  for (int i = 1; i <= n; ++i)\n+    sum += f(&i);\n+  return sum;\n+}\n+\n+static_assert(g(3) == 3+2+1,\"\");"}]}