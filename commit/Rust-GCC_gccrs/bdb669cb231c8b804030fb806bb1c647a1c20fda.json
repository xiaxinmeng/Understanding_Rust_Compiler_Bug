{"sha": "bdb669cb231c8b804030fb806bb1c647a1c20fda", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmRiNjY5Y2IyMzFjOGI4MDQwMzBmYjgwNmJiMWM2NDdhMWMyMGZkYQ==", "commit": {"author": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1996-10-02T20:51:39Z"}, "committer": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1996-10-02T20:51:39Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r12890", "tree": {"sha": "13aceeb962f16f9f2b88dea09e322bf31c92a155", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/13aceeb962f16f9f2b88dea09e322bf31c92a155"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bdb669cb231c8b804030fb806bb1c647a1c20fda", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bdb669cb231c8b804030fb806bb1c647a1c20fda", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bdb669cb231c8b804030fb806bb1c647a1c20fda", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bdb669cb231c8b804030fb806bb1c647a1c20fda/comments", "author": null, "committer": null, "parents": [{"sha": "5621d7177ec0ae3b73fa0d85058bd5b6203bdba8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5621d7177ec0ae3b73fa0d85058bd5b6203bdba8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5621d7177ec0ae3b73fa0d85058bd5b6203bdba8"}], "stats": {"total": 355, "additions": 226, "deletions": 129}, "files": [{"sha": "70ee884198073d4094d9e16709924026646296f5", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 226, "deletions": 129, "changes": 355, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdb669cb231c8b804030fb806bb1c647a1c20fda/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdb669cb231c8b804030fb806bb1c647a1c20fda/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=bdb669cb231c8b804030fb806bb1c647a1c20fda", "patch": "@@ -723,7 +723,6 @@ static unsigned lookup_filename ();\n #define SFNAMES_ENTRY_LABEL_FMT\t\".L_F%u\"\n #endif\n \n-\n /* Definitions of defaults for various types of primitive assembly language\n    output operations.  These may be overridden from within the tm.h file,\n    but typically, that is unecessary.  */\n@@ -971,10 +970,10 @@ addr_const_to_string (str, x)\n \t{\n \t  addr_const_to_string (buf1, XEXP (x, 0));\n \t  strcat (str, buf1);\n-\t  if (INTVAL (XEXP (x, 0)) >= 0)\n+\t  if (INTVAL (XEXP (x, 1)) >= 0)\n \t    strcat (str, \"+\");\n \t  addr_const_to_string (buf1, XEXP (x, 1));\n-\t  strcat (str, buf2);\n+\t  strcat (str, buf1);\n \t}\n       break;\n \n@@ -1841,6 +1840,28 @@ block_ultimate_origin (block)\n       return ret_val;\n     }\n }\n+\n+/* Get the class to which DECL belongs, if any.  In g++, the DECL_CONTEXT\n+   of a virtual function may refer to a base class, so we check the 'this'\n+   parameter.  */\n+\n+tree\n+decl_class_context (decl)\n+     tree decl;\n+{\n+  tree context = NULL_TREE;\n+  if (TREE_CODE (decl) != FUNCTION_DECL\n+      || ! DECL_VIRTUAL_P (decl))\n+    context = DECL_CONTEXT (decl);\n+  else\n+    context = TYPE_MAIN_VARIANT\n+      (TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (TREE_TYPE (decl)))));\n+\n+  if (context && TREE_CODE_CLASS (TREE_CODE (context)) != 't')\n+    context = NULL_TREE;\n+\n+  return context;\n+}\n \f\n /**************** DIE internal representation constturction *******************/\n \n@@ -2134,6 +2155,45 @@ get_AT_low_pc (die)\n   return low_pc;\n }\n \n+/* Return the value of the flag attribute designated by ATTR_KIND, or -1\n+   if it is not present.  */\n+inline int\n+get_AT_flag (die, attr_kind)\n+     register dw_die_ref die;\n+     register enum dwarf_attribute attr_kind;\n+{\n+  register dw_attr_ref a;\n+  if (die != NULL)\n+    {\n+      for (a = die->die_attr; a != NULL; a = a->dw_attr_next)\n+\t{\n+\t  if (a->dw_attr == attr_kind\n+\t      && a->dw_attr_val.val_class == dw_val_class_flag)\n+\t    return a->dw_attr_val.v.val_flag;\n+\t}\n+    }\n+  return -1;\n+}\n+\n+/* Return the value of the unsigned attribute designated by ATTR_KIND, or 0\n+   if it is not present.  */\n+inline unsigned\n+get_AT_unsigned (die, attr_kind)\n+     register dw_die_ref die;\n+     register enum dwarf_attribute attr_kind;\n+{\n+  register dw_attr_ref a;\n+  if (die != NULL)\n+    {\n+      for (a = die->die_attr; a != NULL; a = a->dw_attr_next)\n+\t{\n+\t  if (a->dw_attr == attr_kind\n+\t      && a->dw_attr_val.val_class == dw_val_class_unsigned_const)\n+\t    return a->dw_attr_val.v.val_unsigned;\n+\t}\n+    }\n+  return 0;\n+}\n \n /* Return the \"high pc\" attribute value, typically associated with\n    a subprogram DIE.  Return null if the \"high pc\" attribute is\n@@ -2918,9 +2978,8 @@ size_of_line_info ()\n \t    }\n \t}\n     }\n-  /* Set address register instruction.  */\n-  size += 1 + size_of_uleb128 (1 + PTR_SIZE)\n-    + 1 + PTR_SIZE;\n+  /* Advance pc instruction.  */\n+  size += 1 + 2;\n   /* End of line number info. marker.  */\n   size += 1 + size_of_uleb128 (1) + 1;\n   return size;\n@@ -3893,13 +3952,13 @@ output_aranges ()\n \t       ASM_COMMENT_START);\n     }\n   fputc ('\\n', asm_out_file);\n-  ASM_OUTPUT_DWARF_ADDR (asm_out_file, TEXT_BEGIN_LABEL);\n+  ASM_OUTPUT_DWARF_ADDR (asm_out_file, TEXT_SECTION);\n   if (flag_verbose_asm)\n     {\n       fprintf (asm_out_file, \"\\t%s Address\", ASM_COMMENT_START);\n     }\n   fputc ('\\n', asm_out_file);\n-  ASM_OUTPUT_DWARF_DELTA4 (asm_out_file, TEXT_END_LABEL, TEXT_BEGIN_LABEL);\n+  ASM_OUTPUT_DWARF_DELTA4 (asm_out_file, TEXT_END_LABEL, TEXT_SECTION);\n   if (flag_verbose_asm)\n     {\n       fprintf (asm_out_file, \"%s Length\", ASM_COMMENT_START);\n@@ -4057,14 +4116,14 @@ output_line_info ()\n   fputc ('\\n', asm_out_file);\n   ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DW_LNE_set_address);\n   fputc ('\\n', asm_out_file);\n-  ASM_OUTPUT_DWARF_ADDR (asm_out_file, TEXT_BEGIN_LABEL);\n+  ASM_OUTPUT_DWARF_ADDR (asm_out_file, TEXT_SECTION);\n   fputc ('\\n', asm_out_file);\n \n   /* Generate the line number to PC correspondence table, encoded as\n      a series of state machine operations.  */\n   current_file = 1;\n   current_line = 1;\n-  strcpy (prev_line_label, TEXT_BEGIN_LABEL);\n+  strcpy (prev_line_label, TEXT_SECTION);\n   for (lt_index = 1; lt_index < line_info_table_in_use; ++lt_index)\n     {\n       ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DW_LNS_fixed_advance_pc);\n@@ -4131,18 +4190,16 @@ output_line_info ()\n       strcpy (prev_line_label, line_label);\n     }\n \n-  ASM_OUTPUT_DWARF_DATA1 (asm_out_file, 0);\n+  ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DW_LNS_fixed_advance_pc);\n   if (flag_verbose_asm)\n     {\n-      fprintf (asm_out_file, \"\\t%s DW_LNE_set_address\", ASM_COMMENT_START);\n+      fprintf (asm_out_file, \"\\t%s DW_LNS_fixed_advance_pc\",\n+\t       ASM_COMMENT_START);\n     }\n   fputc ('\\n', asm_out_file);\n-  output_uleb128 (1 + PTR_SIZE);\n-  fputc ('\\n', asm_out_file);\n-  ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DW_LNE_set_address);\n-  fputc ('\\n', asm_out_file);\n-  ASM_OUTPUT_DWARF_ADDR (asm_out_file, TEXT_END_LABEL);\n+  ASM_OUTPUT_DWARF_DELTA2 (asm_out_file, TEXT_END_LABEL, prev_line_label);\n   fputc ('\\n', asm_out_file);\n+\n   /* Output the marker for the end of the line number info.  */\n   ASM_OUTPUT_DWARF_DATA1 (asm_out_file, 0);\n   if (flag_verbose_asm)\n@@ -4453,16 +4510,24 @@ modified_type_die (type, is_const_type, is_volatile_type, context_die)\n \n   if (code != ERROR_MARK)\n     {\n+      type = build_type_variant (type, is_const_type, is_volatile_type);\n+\n+      mod_type_die = lookup_type_die (type);\n+      if (mod_type_die)\n+\treturn mod_type_die;\n+\n       if (is_const_type)\n \t{\n \t  mod_type_die = new_die (DW_TAG_const_type, context_die);\n-\t  sub_die = modified_type_die (type,\n-\t\t\t\t       0, is_volatile_type, context_die);\n+\t  sub_die = modified_type_die\n+\t    (build_type_variant (type, 0, is_volatile_type),\n+\t     0, is_volatile_type, context_die);\n \t}\n       else if (is_volatile_type)\n \t{\n \t  mod_type_die = new_die (DW_TAG_volatile_type, context_die);\n-\t  sub_die = modified_type_die (type, 0, 0, context_die);\n+\t  sub_die = modified_type_die\n+\t    (TYPE_MAIN_VARIANT (type), 0, 0, context_die);\n \t}\n       else if (code == POINTER_TYPE)\n \t{\n@@ -4519,6 +4584,7 @@ modified_type_die (type, is_const_type, is_volatile_type, context_die)\n     {\n       add_AT_die_ref (mod_type_die, DW_AT_type, sub_die);\n     }\n+  equate_type_number_to_die (type, mod_type_die);\n   return mod_type_die;\n }\n \n@@ -5495,21 +5561,6 @@ add_bit_size_attribute (die, decl)\n \t\t   (unsigned) TREE_INT_CST_LOW (DECL_SIZE (decl)));\n }\n \n-inline void\n-add_member_attribute (die, context)\n-     register dw_die_ref die;\n-     register tree context;\n-{\n-  register dw_die_ref type_die;\n-\n-  /* Generate this attribute only for members in C++.  */\n-  if (context != NULL && is_tagged_type (context))\n-    {\n-      type_die = lookup_type_die (context);\n-      add_AT_die_ref (die, DW_AT_member, type_die);\n-    }\n-}\n-\n /* If the compiled language is GNU C, then add a 'prototyped'\n    attribute, if arg types are given for the parameters of a function.  */\n inline void\n@@ -5545,24 +5596,16 @@ add_abstract_origin_attribute (die, origin)\n   add_AT_die_ref (die, DW_AT_abstract_origin, origin_die);\n }\n \n-/* If the compiled source program is  C++, define the pure_virtual\n-   attribute.  */\n+/* We do not currently support the pure_virtual attribute.  */\n+\n inline void\n add_pure_or_virtual_attribute (die, func_decl)\n      register dw_die_ref die;\n      register tree func_decl;\n {\n   if (DECL_VIRTUAL_P (func_decl))\n     {\n-      if ((strcmp (language_string, \"GNU C++\") == 0)\n-\t  && (DECL_VIRTUAL_P (func_decl)))\n-\t{\n-\t  add_AT_unsigned (die, DW_AT_virtuality, DW_VIRTUALITY_pure_virtual);\n-\t}\n-      else\n-\t{\n-\t  add_AT_unsigned (die, DW_AT_virtuality, DW_VIRTUALITY_virtual);\n-\t}\n+      add_AT_unsigned (die, DW_AT_virtuality, DW_VIRTUALITY_virtual);\n     }\n }\n \f\n@@ -5699,23 +5742,13 @@ type_tag (type)\n       /* Find the IDENTIFIER_NODE for the type name.  */\n       if (TREE_CODE (TYPE_NAME (type)) == IDENTIFIER_NODE)\n \tt = TYPE_NAME (type);\n-#if 0\n+\n       /* The g++ front end makes the TYPE_NAME of *each* tagged type point to \n          a TYPE_DECL node, regardless of whether or not a `typedef' was\n-         involved.  This is distinctly different from what the gcc front-end\n-         does.  It always makes the TYPE_NAME for each tagged type be either\n-         NULL (signifying an anonymous tagged type) or else a pointer to an\n-         IDENTIFIER_NODE.  Obviously, we would like to generate correct Dwarf \n-         for both C and C++, but given this inconsistency in the TREE\n-         representation of tagged types for C and C++ in the GNU front-ends,\n-         we cannot support both languages correctly unless we introduce some\n-         front-end specific code here, and rms objects to that, so we can\n-         only generate correct Dwarf for one of these two languages.  C is\n-         more important, so for now we'll do the right thing for C and let\n-         g++ go fish.  */\n+         involved.  */\n       else if (TREE_CODE (TYPE_NAME (type)) == TYPE_DECL)\n \tt = DECL_NAME (TYPE_NAME (type));\n-#endif\n+\n       /* Now get the name as a string, or invent one.  */\n       if (t != 0)\n \t{\n@@ -5770,10 +5803,13 @@ gen_array_type_die (type, context_die)\n      register dw_die_ref context_die;\n {\n   register dw_die_ref scope_die = scope_die_for_type (type, context_die);\n-  register dw_die_ref array_die = new_die (DW_TAG_array_type, scope_die);\n+  register dw_die_ref array_die = lookup_type_die (type);\n   register tree element_type;\n-  /* TODO: why a member_attribute under an array?\n-     member_attribute (array_die, TYPE_CONTEXT (type)); */\n+\n+  if (array_die)\n+    return;\n+\n+  array_die  = new_die (DW_TAG_array_type, scope_die);\n #if 0\n   /* We default the array ordering.  SDB will probably do\n      the right things even if DW_AT_ordering is not present.  It's not even\n@@ -5811,10 +5847,11 @@ gen_set_type_die (type, context_die)\n      register tree type;\n      register dw_die_ref context_die;\n {\n-  register dw_die_ref type_die;\n+  register dw_die_ref type_die = lookup_type_die (type);\n+  if (type_die)\n+    return;\n   type_die = new_die (DW_TAG_set_type, scope_die_for_type (type, context_die));\n   equate_type_number_to_die (type, type_die);\n-  add_member_attribute (type_die, TYPE_CONTEXT (type));\n   add_type_attribute (type_die, TREE_TYPE (type), 0, 0, context_die);\n }\n \n@@ -5832,7 +5869,6 @@ gen_entry_point_die (decl, context_die)\n   else\n     {\n       add_name_and_src_coords_attributes (decl_die, decl);\n-      add_member_attribute (decl_die, DECL_CONTEXT (decl));\n       add_type_attribute (decl_die, TREE_TYPE (TREE_TYPE (decl)),\n \t\t\t  0, 0, context_die);\n     }\n@@ -5904,7 +5940,6 @@ gen_enumeration_type_die (type, is_complete, context_die)\n \t\t\t  scope_die_for_type (type, context_die));\n       equate_type_number_to_die (type, type_die);\n       add_name_attribute (type_die, type_tag (type));\n-      add_member_attribute (type_die, TYPE_CONTEXT (type));\n     }\n   if (is_complete)\n     {\n@@ -5963,6 +5998,8 @@ gen_formal_parameter_die (node, context_die)\n \t\t\t      TREE_READONLY (node),\n \t\t\t      TREE_THIS_VOLATILE (node),\n \t\t\t      context_die);\n+\t  if (DECL_ARTIFICIAL (node))\n+\t    add_AT_flag (parm_die, DW_AT_artificial, 1);\n \t}\n       if (DECL_ABSTRACT (node))\n \t{\n@@ -6028,6 +6065,7 @@ gen_formal_types_die (function_or_method_type, context_die)\n   register tree formal_type = NULL;\n   register tree first_parm_type = TYPE_ARG_TYPES (function_or_method_type);\n \n+#if 0\n   /* In the case where we are generating a formal types list for a C++\n      non-static member function type, skip over the first thing on the\n      TYPE_ARG_TYPES list because it only represents the type of the hidden\n@@ -6038,6 +6076,7 @@ gen_formal_types_die (function_or_method_type, context_die)\n      DW_TAG_subroutine_type DIE.  */\n   if (TREE_CODE (function_or_method_type) == METHOD_TYPE)\n     first_parm_type = TREE_CHAIN (first_parm_type);\n+#endif\n \n   /* Make our first pass over the list of formal parameter types and output a \n      DW_TAG_formal_parameter DIE for each one.  */\n@@ -6086,11 +6125,29 @@ gen_subprogram_die (decl, context_die)\n   register tree fn_arg_types;\n   register tree outer_scope;\n   register tree label;\n+  dw_die_ref old_die = lookup_decl_die (decl);\n \n   if (origin != NULL)\n     {\n       add_abstract_origin_attribute (subr_die, origin);\n     }\n+  else if (old_die)\n+    {\n+      if (get_AT_flag (old_die, DW_AT_declaration) != 1)\n+\tabort ();\n+      add_AT_die_ref (subr_die, DW_AT_specification, old_die);\n+      if (DECL_NAME (decl))\n+\t{\n+\t  register unsigned file_index\n+\t    = lookup_filename (DECL_SOURCE_FILE (decl));\n+\t  if (get_AT_unsigned (old_die, DW_AT_decl_file) != file_index)\n+\t    add_AT_unsigned (subr_die, DW_AT_decl_file, file_index);\n+\t  if (get_AT_unsigned (old_die, DW_AT_decl_line)\n+\t      != DECL_SOURCE_LINE (decl))\n+\t    add_AT_unsigned\n+\t      (subr_die, DW_AT_decl_line, DECL_SOURCE_LINE (decl));\n+\t}\n+    }\n   else\n     {\n       if (TREE_PUBLIC (decl) || DECL_EXTERNAL (decl))\n@@ -6104,11 +6161,17 @@ gen_subprogram_die (decl, context_die)\n \t}\n       type = TREE_TYPE (decl);\n       add_prototyped_attribute (subr_die, type);\n-      add_member_attribute (subr_die, DECL_CONTEXT (decl));\n       add_type_attribute (subr_die, TREE_TYPE (type), 0, 0, context_die);\n       add_pure_or_virtual_attribute (subr_die, decl);\n+\n+      /* The first time we see a member function, it is in the context of\n+         the class to which it belongs.  We make sure of this by emitting\n+         the class first.  The next time is the definition, which is\n+         handled above.  The two may come from the same source text.  */\n+      if (! DECL_INITIAL (decl))\n+\tadd_AT_flag (subr_die, DW_AT_declaration, 1);\n     }\n-  if (DECL_ABSTRACT (decl))\n+  if (DECL_ABSTRACT (decl) || ! DECL_INITIAL (decl))\n     {\n       equate_decl_number_to_die (decl, subr_die);\n     }\n@@ -6254,30 +6317,54 @@ gen_variable_die (decl, context_die)\n {\n   register tree origin = decl_ultimate_origin (decl);\n   register dw_die_ref var_die = new_die (DW_TAG_variable, context_die);\n-  if (TREE_PUBLIC (decl) || DECL_EXTERNAL (decl))\n-    {\n-      add_AT_flag (var_die, DW_AT_external, 1);\n-    }\n+  dw_die_ref old_die = lookup_decl_die (decl);\n+  \n   if (origin != NULL)\n     {\n       add_abstract_origin_attribute (var_die, origin);\n     }\n+  else if (old_die)\n+    {\n+      if (get_AT_flag (old_die, DW_AT_declaration) != 1)\n+\tabort ();\n+      add_AT_die_ref (var_die, DW_AT_specification, old_die);\n+      if (DECL_NAME (decl))\n+\t{\n+\t  register unsigned file_index\n+\t    = lookup_filename (DECL_SOURCE_FILE (decl));\n+\t  if (get_AT_unsigned (old_die, DW_AT_decl_file) != file_index)\n+\t    add_AT_unsigned (var_die, DW_AT_decl_file, file_index);\n+\t  if (get_AT_unsigned (old_die, DW_AT_decl_line)\n+\t      != DECL_SOURCE_LINE (decl))\n+\t    add_AT_unsigned\n+\t      (var_die, DW_AT_decl_line, DECL_SOURCE_LINE (decl));\n+\t}\n+    }\n   else\n     {\n       add_name_and_src_coords_attributes (var_die, decl);\n-      add_member_attribute (var_die, DECL_CONTEXT (decl));\n       add_type_attribute (var_die, TREE_TYPE (decl),\n \t\t\t  TREE_READONLY (decl),\n \t\t\t  TREE_THIS_VOLATILE (decl), context_die);\n+      if (TREE_PUBLIC (decl) || DECL_EXTERNAL (decl))\n+\t{\n+\t  add_AT_flag (var_die, DW_AT_external, 1);\n+\t}\n     }\n   if (DECL_ABSTRACT (decl))\n     {\n       equate_decl_number_to_die (decl, var_die);\n     }\n   else if (!DECL_EXTERNAL (decl))\n     {\n+      equate_decl_number_to_die (decl, var_die);\n       add_location_or_const_value_attribute (var_die, decl);\n     }\n+  else if (decl_class_context (decl))\n+    {\n+      equate_decl_number_to_die (decl, var_die);\n+      add_AT_flag (var_die, DW_AT_declaration, 1);\n+    }\n }\n \n /* Generate a DIE to represent a label identifier.  */\n@@ -6369,7 +6456,6 @@ gen_field_die (decl, context_die)\n {\n   register dw_die_ref decl_die = new_die (DW_TAG_member, context_die);\n   add_name_and_src_coords_attributes (decl_die, decl);\n-  add_member_attribute (decl_die, DECL_CONTEXT (decl));\n   add_type_attribute (decl_die, member_declared_type (decl),\n \t\t      TREE_READONLY (decl), TREE_THIS_VOLATILE (decl),\n \t\t      context_die);\n@@ -6392,9 +6478,11 @@ gen_pointer_type_die (type, context_die)\n      register tree type;\n      register dw_die_ref context_die;\n {\n-  register dw_die_ref ptr_die = new_die (DW_TAG_pointer_type, context_die);\n+  register dw_die_ref ptr_die = lookup_type_die (type);\n+  if (ptr_die)\n+    return;\n+  ptr_die = new_die (DW_TAG_pointer_type, context_die);\n   equate_type_number_to_die (type, ptr_die);\n-  add_member_attribute (ptr_die, TYPE_CONTEXT (type));\n   add_type_attribute (ptr_die, TREE_TYPE (type), 0, 0, context_die);\n }\n \n@@ -6407,9 +6495,11 @@ gen_reference_type_die (type, context_die)\n      register tree type;\n      register dw_die_ref context_die;\n {\n-  register dw_die_ref ref_die = new_die (DW_TAG_reference_type, context_die);\n+  register dw_die_ref ref_die = lookup_type_die (type);\n+  if (ref_die)\n+    return;\n+  ref_die = new_die (DW_TAG_reference_type, context_die);\n   equate_type_number_to_die (type, ref_die);\n-  add_member_attribute (ref_die, TYPE_CONTEXT (type));\n   add_type_attribute (ref_die, TREE_TYPE (type), 0, 0, context_die);\n }\n \n@@ -6419,12 +6509,13 @@ gen_ptr_to_mbr_type_die (type, context_die)\n      register tree type;\n      register dw_die_ref context_die;\n {\n-  register dw_die_ref ptr_die = new_die (DW_TAG_ptr_to_member_type,\n-\t\t\t\t\t context_die);\n+  register dw_die_ref ptr_die = lookup_type_die (type);\n+  if (ptr_die)\n+    return;\n+  ptr_die = new_die (DW_TAG_ptr_to_member_type, context_die);\n   equate_type_number_to_die (type, ptr_die);\n-  add_member_attribute (ptr_die, TYPE_CONTEXT (type));\n   add_AT_die_ref (ptr_die, DW_AT_containing_type,\n-\t      lookup_type_die (TYPE_OFFSET_BASETYPE (type)));\n+\t\t  lookup_type_die (TYPE_OFFSET_BASETYPE (type)));\n   add_type_attribute (ptr_die, TREE_TYPE (type), 0, 0, context_die);\n }\n \n@@ -6434,20 +6525,15 @@ gen_compile_unit_die (main_input_filename)\n      register char *main_input_filename;\n {\n   char producer[250];\n-  char full_src_name[1024];\n   char *wd = getpwd ();\n \n   comp_unit_die = new_die (DW_TAG_compile_unit, NULL);\n \n-  /* MIPS/SGI requires the full pathname of the input file.  */\n-  if (main_input_filename[0] == '/')\n-    {\n-      add_name_attribute (comp_unit_die, main_input_filename);\n-    }\n-  else\n+  add_name_attribute (comp_unit_die, main_input_filename);\n+\n+  if (wd)\n     {\n-      sprintf (full_src_name, \"%s/%s\", wd, main_input_filename);\n-      add_name_attribute (comp_unit_die, full_src_name);\n+      add_AT_string (comp_unit_die, DW_AT_comp_dir, wd);\n     }\n \n   sprintf (producer, \"%s %s\", language_string, version_string);\n@@ -6461,7 +6547,7 @@ gen_compile_unit_die (main_input_filename)\n      information in the object file, we add a -g to the producer string.  */\n   if (write_symbols != NO_DEBUG)\n     {\n-       strcpy (producer, \" -g\");\n+       strcat (producer, \" -g\");\n     }\n \n #endif\n@@ -6483,12 +6569,8 @@ gen_compile_unit_die (main_input_filename)\n     {\n       add_AT_unsigned (comp_unit_die, DW_AT_language, DW_LANG_C89);\n     }\n-  add_AT_lbl_id (comp_unit_die, DW_AT_low_pc, TEXT_BEGIN_LABEL);\n+  add_AT_lbl_id (comp_unit_die, DW_AT_low_pc, TEXT_SECTION);\n   add_AT_lbl_id (comp_unit_die, DW_AT_high_pc, TEXT_END_LABEL);\n-  if (wd)\n-    {\n-      add_AT_string (comp_unit_die, DW_AT_comp_dir, wd);\n-    }\n   if (debug_info_level >= DINFO_LEVEL_NORMAL)\n     {\n       add_AT_section_offset (comp_unit_die, DW_AT_stmt_list, LINE_SECTION);\n@@ -6505,10 +6587,12 @@ gen_string_type_die (type, context_die)\n      register tree type;\n      register dw_die_ref context_die;\n {\n-  register dw_die_ref type_die;\n+  register dw_die_ref type_die = lookup_type_die (type);\n+  if (type_die)\n+    return;\n   type_die = new_die (DW_TAG_string_type,\n \t\t      scope_die_for_type (type, context_die));\n-  add_member_attribute (type_die, TYPE_CONTEXT (type));\n+  equate_type_number_to_die (type, type_die);\n \n   /* Fudge the string length attribute for now.  */\n \n@@ -6524,7 +6608,6 @@ gen_member_die (type, context_die)\n      register dw_die_ref context_die;\n {\n   register tree normal_member;\n-  register tree vec_base;\n   register tree first_func_member;\n   register tree func_member;\n   /* If this is not an incomplete type, output descriptions of each of its\n@@ -6549,25 +6632,11 @@ gen_member_die (type, context_die)\n     }\n \n   /* Now output info about the function members (if any).  */\n-  vec_base = TYPE_METHODS (type);\n-  if (vec_base)\n+  for (func_member = TYPE_METHODS (type);\n+       func_member;\n+       func_member = TREE_CHAIN (func_member))\n     {\n-      first_func_member = TREE_VEC_ELT (vec_base, 0);\n-      /* This isn't documented, but the first element of the vector of member \n-         functions can be NULL in cases where the class type in question\n-         didn't have either a constructor or a destructor declared for it.\n-         We have to make allowances for that here.  */\n-      if (first_func_member == NULL)\n-\t{\n-\t  first_func_member = TREE_VEC_ELT (vec_base, 1);\n-\t}\n-\n-      for (func_member = first_func_member;\n-\t   func_member;\n-\t   func_member = TREE_CHAIN (func_member))\n-\t{\n-\t  gen_decl_die (func_member, context_die);\n-\t}\n+      gen_decl_die (func_member, context_die);\n     }\n }\n \n@@ -6587,7 +6656,6 @@ gen_struct_or_union_type_die (type, is_complete, context_die)\n \t\t\t  scope_die_for_type (type, context_die));\n       equate_type_number_to_die (type, type_die);\n       add_name_attribute (type_die, type_tag (type));\n-      add_member_attribute (type_die, TYPE_CONTEXT (type));\n     }\n \n   /* If this type has been completed, then give it a byte_size attribute and\n@@ -6612,10 +6680,12 @@ gen_subroutine_type_die (type, context_die)\n      register dw_die_ref context_die;\n {\n   register tree return_type = TREE_TYPE (type);\n-  register dw_die_ref subr_die = new_die (DW_TAG_subroutine_type, context_die);\n+  register dw_die_ref subr_die = lookup_type_die (type);\n+  if (subr_die)\n+    return;\n+  subr_die = new_die (DW_TAG_subroutine_type, context_die);\n   equate_type_number_to_die (type, subr_die);\n   add_prototyped_attribute (subr_die, type);\n-  add_member_attribute (subr_die, TYPE_CONTEXT (type));\n   add_type_attribute (subr_die, return_type, 0, 0, context_die);\n   gen_formal_types_die (type, context_die);\n }\n@@ -6637,7 +6707,6 @@ gen_typedef_die (decl, context_die)\n   else\n     {\n       add_name_and_src_coords_attributes (type_die, decl);\n-      add_member_attribute (type_die, DECL_CONTEXT (decl));\n       add_type_attribute (type_die, TREE_TYPE (decl),\n \t\t\t  TREE_READONLY (decl),\n \t\t\t  TREE_THIS_VOLATILE (decl),\n@@ -7002,11 +7071,24 @@ gen_decl_die (decl, context_die)\n \n     case FUNCTION_DECL:\n       /* If we are in terse mode, don't output any DIEs to represent mere\n-         function declarations.  */\n-      if (DECL_INITIAL (decl) == NULL_TREE)\n+         function declarations, unless they are class members.  */\n+      if (DECL_INITIAL (decl) == NULL_TREE && DECL_CONTEXT (decl) == NULL_TREE)\n \t{\n \t  break;\n \t}\n+      /* Before we describe the FUNCTION_DECL itself, make sure that we have\n+         described its context.  */\n+      origin = decl_class_context (decl);\n+      if (origin && ! decl_ultimate_origin (decl))\n+\t{\n+\t  dw_die_ref old_die;\n+\t  gen_type_die (origin, context_die);\n+\t  /* We may have just generated the DIE we need; let's check.  */\n+\t  old_die = lookup_decl_die (decl);\n+\t  if (old_die && get_AT_flag (old_die, DW_AT_declaration) != 1)\n+\t    break;\n+\t}\n+\n       /* Before we describe the FUNCTION_DECL itself, make sure that we have\n          described its return type.  */\n       gen_type_die (TREE_TYPE (TREE_TYPE (decl)), context_die);\n@@ -7048,11 +7130,9 @@ gen_decl_die (decl, context_die)\n          TYPE_DECL node for each complete tagged type, each array type, and\n          each function type node created) the g++ front end generates a\n          _named_ TYPE_DECL node for each tagged type node created.\n-         Unfortunately, these g++ TYPE_DECL nodes cause us to output many\n-         superfluous and unnecessary DW_TAG_typedef DIEs here.  When g++ is\n-         fixed to stop generating these superfluous named TYPE_DECL nodes,\n-         the superfluous DW_TAG_typedef DIEs will likewise cease.  */\n-      if (DECL_NAME (decl))\n+\t These TYPE_DECLs have DECL_ARTIFICIAL set, so we know not to\n+\t generate a DW_TAG_typedef DIE for them.  */\n+      if (DECL_NAME (decl) && ! DECL_ARTIFICIAL (decl))\n \t{\n \t  /* Output a DIE to represent the typedef itself.  */\n \t  gen_typedef_die (decl, context_die);\n@@ -7074,6 +7154,19 @@ gen_decl_die (decl, context_die)\n \t  break;\n \t}\n \n+      /* Before we describe the VAR_DECL itself, make sure that we have\n+         described its context.  */\n+      origin = decl_class_context (decl);\n+      if (origin && ! decl_ultimate_origin (decl))\n+\t{\n+\t  dw_die_ref old_die;\n+\t  gen_type_die (origin, context_die);\n+\t  /* We may have just generated the DIE we need; let's check.  */\n+\t  old_die = lookup_decl_die (decl);\n+\t  if (old_die && get_AT_flag (old_die, DW_AT_declaration) != 1)\n+\t    break;\n+\t}\n+\n       /* Output any DIEs that are needed to specify the type of this data\n          object.  */\n       gen_type_die (TREE_TYPE (decl), context_die);\n@@ -7624,6 +7717,7 @@ dwarfout_init (asm_out_file, main_input_filename)\n   fde_table_allocated = FDE_TABLE_INCREMENT;\n   fde_table_in_use = 0;\n \n+#if 0\n   /* Output a starting label for the .text section.  */\n   fputc ('\\n', asm_out_file);\n   ASM_OUTPUT_SECTION (asm_out_file, TEXT_SECTION);\n@@ -7643,6 +7737,7 @@ dwarfout_init (asm_out_file, main_input_filename)\n   fputc ('\\n', asm_out_file);\n   ASM_OUTPUT_SECTION (asm_out_file, BSS_SECTION);\n   ASM_OUTPUT_LABEL (asm_out_file, BSS_BEGIN_LABEL);\n+#endif\n \n   /* Generate the initial DIE for the .debug section.  Note that the (string) \n      value given in the DW_AT_name attribute of the DW_TAG_compile_unit DIE\n@@ -7675,6 +7770,7 @@ dwarfout_finish ()\n   ASM_OUTPUT_SECTION (asm_out_file, TEXT_SECTION);\n   ASM_OUTPUT_LABEL (asm_out_file, TEXT_END_LABEL);\n \n+#if 0\n   /* Output a terminator label for the .data section.  */\n   fputc ('\\n', asm_out_file);\n   ASM_OUTPUT_SECTION (asm_out_file, DATA_SECTION);\n@@ -7689,6 +7785,7 @@ dwarfout_finish ()\n   fputc ('\\n', asm_out_file);\n   ASM_OUTPUT_SECTION (asm_out_file, BSS_SECTION);\n   ASM_OUTPUT_LABEL (asm_out_file, BSS_END_LABEL);\n+#endif\n \n   /* Output the abbreviation table.  */\n   fputc ('\\n', asm_out_file);"}]}