{"sha": "3649b9b791c54f35a8bfb5540711dc4112acce7d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzY0OWI5Yjc5MWM1NGYzNWE4YmZiNTU0MDcxMWRjNDExMmFjY2U3ZA==", "commit": {"author": {"name": "Sriraman Tallam", "email": "tmsriram@google.com", "date": "2012-11-06T02:35:17Z"}, "committer": {"name": "Sriraman Tallam", "email": "tmsriram@gcc.gnu.org", "date": "2012-11-06T02:35:17Z"}, "message": "Function Multiversioning\n========================\n\nSriraman Tallam, tmsriram@google.com\n\nOverview of the patch which adds support to specify function versions.  This is\nonly enabled for target i386.\n\nExample:\n\nint foo ();  /* Default version */\nint foo () __attribute__ ((target(\"avx,popcnt\")));/*Specialized for avx and popcnt */\nint foo () __attribute__ ((target(\"arch=core2,ssse3\")));/*Specialized for core2 and ssse3*/\n\nint main ()\n{\n int (*p)() = &foo;\n return foo () + (*p)();\n}\n\nint foo ()\n{\n return 0;\n}\n\nint __attribute__ ((target(\"avx,popcnt\")))\nfoo ()\n{\n return 0;\n}\n\nint __attribute__ ((target(\"arch=core2,ssse3\")))\nfoo ()\n{\n return 0;\n}\n\nThe above example has foo defined 3 times, but all 3 definitions of foo are\ndifferent versions of the same function. The call to foo in main, directly and\nvia a pointer, are calls to the multi-versioned function foo which is dispatched\nto the right foo at run-time.\n\nFront-end changes:\n\nThe front-end changes are calls at appropriate places to target hooks that\ndetermine the following:\n\n* Determine if two function decls with the same signature are versions.\n* Determine the assembler name of a function version.\n* Generate the dispatcher function for a set of function versions.\n* Compare versions to see if one has a higher priority over the other.\n\nAll the implementation happens in the target-specific config/i386/i386.c.\n\nWhat does the patch do?\n\n* Tracking decls that correspond to function versions of function\nname, say \"foo\":\n\nWhen the front-end sees more than one decl for \"foo\", it calls a target hook to\ndetermine if they are versions. To prevent duplicate definition errors with\nother versions of \"foo\", \"decls_match\" function in cp/decl.c is made to return\nfalse when 2 decls have are deemed versions by the target. This will make all\nfunction versions of \"foo\" to be added to the overload list of \"foo\".\n\n* Change the assembler names of the function versions.\n\nFor i386, the target changes the assembler names of the function versions by\n suffixing the sorted list of args to \"target\" to the function name of \"foo\".\nFor example, the assembler name of\n \"void foo () __attribute__ ((target (\"sse4\")))\" will\nbecome _Z3foov.sse4.  The target hook mangle_decl_assembler_name is used\nfor this.\n\n* Overload resolution:\n\n Function \"build_over_call\" in cp/call.c sees a call to function\n\"foo\", which is multi-versioned. The overload resolution happens in\nfunction \"joust\" in \"cp/call.c\". Here, the call to \"foo\" has all\npossible versions of \"foo\" as candidates. All the candidates of \"foo\" are\nstored in the cgraph side data structure. Each version of foo is chained in a \ndoubly-linked list with the default function as the first element.  This allows\nany pass to access all the semantically identical versions. A call to a\nmulti-versioned function will be replaced by a call to a dispatcher function,\ndetermined by a target hook, to execute the right function version at run-time.\n\nOptimization to directly call a version when possible:\nAlso, in joust, where overload resolution happens, a multiversioned function\nresolution is made to return the most specialized version.  This is the version\nthat will be checked for dispatching first and is determined by the target.\nNow, if the caller can inline this function version then a direct call is made\nto this function version rather than go through the dispatcher. When a direct\ncall cannot be made, a call to the dispatcher function is created.\n\n* Creating the dispatcher body.\n\nThe dispatcher body, called the resolver is made only when there is a call to a\nmultiversioned function dispatcher or the address of a function is taken. This\nis generated during cgraph_analyze_function. This is done by another target hook.\n\n* Dispatch ordering.\n\nThe order in which the function versions are checked during dispatch is based\non a priority value assigned for the ISA that is catered. More specialized \nversions are checked for dispatching first.  This is to mitigate the ambiguity\nthat can arise when more than one function version is valid for execution on\na particular platform.  This is not a perfect solution, and in future the user\nshould be allowed to assign a dispatching priority value to each version.\n\nFunction MV in the Intel compiler:\n\nThe intel compiler supports function multiversioning and the syntax is\nsimilar to the patch proposed here.  Here is an example of how to\ngenerate multiple function versions with the intel compiler.\n\n/* Create a stub function to specify the various versions of function that\n   will be created, using declspec attribute cpu_dispatch.  */\n__declspec (cpu_dispatch (core_i7_sse4_2, atom, generic))\nvoid foo () {};\n\n/* Bodies of each function version.  */\n\n/* Intel Corei7 processor + SSE4.2 version.  */\n__declspec (cpu_specific(core_i7_sse4_2))\nvoid foo ()\n{\n  printf (\"corei7 + sse4.2\");\n}\n\n/* Atom processor.  */\n__declspec (cpu_specific(atom))\nvoid foo ()\n{\n  printf (\"atom\");\n}\n\n/* The generic or the default version.  */\n__declspec (cpu_specific(generic))\nvoid foo ()\n{\n  printf (\"This is generic\");\n}\n\nA new function version is generated by defining a new function with the same\nsignature but with a different cpu_specific declspec attribute string.  The\nset of cpu_specific strings that are allowed is the following:\n\n\"core_2nd_gen_avx\"\n\"core_aes_pclmulqdq\"\n\"core_i7_sse4_2\"\n\"core_2_duo_sse4_1\"\n\"core_2_duo_ssse3\"\n\"atom\"\n\"pentium_4_sse3\"\n\"pentium_4\"\n\"pentium_m\"\n\"pentium_iii\"\n\"generic\"\n\nComparison with the GCC MV implementation in this patch:\n\n* Version creation syntax:\n\nThe implementation in this patch also has a similar syntax to specify function\nversions. The first stub function is not needed.  Here is the code to generate\nthe function versions with this patch:\n\n/* Intel Corei7 processor + SSE4.2 version.  */\n__attribute__ ((target (\"arch=corei7, sse4.2\")))\nvoid foo ()\n{\n  printf (\"corei7 + sse4.2\");\n}\n\n/* Atom processor.  */\n__attribute__ ((target (\"arch=atom\")))\nvoid foo ()\n{\n  printf (\"atom\");\n}\n\nvoid foo ()\n{\n}\n\nThe target attribute can have one of the following arch names:\n\n\"amd\"\n\"intel\"\n\"atom\"\n\"core2\"\n\"corei7\"\n\"nehalem\"\n\"westmere\"\n\"sandybridge\"\n\"amdfam10h\"\n\"barcelona\"\n\"shanghai\"\n\"istanbul\"\n\"amdfam15h\"\n\"bdver1\"\n\"bdver2\"\n\nand any number of the following ISA names:\n\n\"cmov\"\n\"mmx\"\n\"popcnt\"\n\"sse\"\n\"sse2\"\n\"sse3\"\n\"ssse3\"\n\"sse4.1\"\n\"sse4.2\"\n\"avx\"\n\"avx2\"\n\n\n\n\t* doc/tm.texi.in (TARGET_OPTION_FUNCTION_VERSIONS): New hook\n\tdescription.\n\t* (TARGET_COMPARE_VERSION_PRIORITY): New hook description.\n\t* (TARGET_GET_FUNCTION_VERSIONS_DISPATCHER): New hook description.\n\t* (TARGET_GENERATE_VERSION_DISPATCHER_BODY): New hook description.\n\t* doc/tm.texi: Regenerate.\n\t* target.def (compare_version_priority): New target hook.\n\t* (generate_version_dispatcher_body): New target hook.\n\t* (get_function_versions_dispatcher): New target hook.\n\t* (function_versions): New target hook.\n\t* cgraph.c (cgraph_fnver_htab): New htab.\n\t(cgraph_fn_ver_htab_hash): New function.\n\t(cgraph_fn_ver_htab_eq): New function.\n\t(version_info_node): New pointer.\n\t(insert_new_cgraph_node_version): New function.\n\t(get_cgraph_node_version): New function.\n\t(delete_function_version): New function.\n\t(record_function_versions): New function.\n\t* cgraph.h (cgraph_node): New bitfield dispatcher_function.\n\t(cgraph_function_version_info): New struct.\n\t(get_cgraph_node_version): New function.\n\t(insert_new_cgraph_node_version): New function.\n\t(record_function_versions): New function.\n\t(delete_function_version): New function.\n\t(init_lowered_empty_function): Expose function.\n\t* tree.h (DECL_FUNCTION_VERSIONED): New macro.\n\t(tree_function_decl): New bit-field versioned_function.\n\t* cgraphunit.c (cgraph_analyze_function): Generate body of multiversion\n\tfunction dispatcher.\n\t(cgraph_analyze_functions): Analyze dispatcher function.\n\t(init_lowered_empty_function): Make non-static. New parameter in_ssa.\n\t(assemble_thunk): Add parameter to call to init_lowered_empty_function.\n\t* config/i386/i386.c (add_condition_to_bb): New function.\n\t(get_builtin_code_for_version): New function.\n\t(ix86_compare_version_priority): New function.\n\t(feature_compare): New function.\n\t(dispatch_function_versions): New function.\n\t(ix86_function_versions): New function.\n\t(attr_strcmp): New function.\n\t(ix86_mangle_function_version_assembler_name): New function.\n\t(ix86_mangle_decl_assembler_name): New function.\n\t(make_name): New function.\n\t(make_dispatcher_decl): New function.\n\t(is_function_default_version): New function.\n\t(ix86_get_function_versions_dispatcher): New function.\n\t(make_attribute): New function.\n\t(make_resolver_func): New function.\n\t(ix86_generate_version_dispatcher_body): New function.\n\t(fold_builtin_cpu): Return integer for cpu builtins.\n\t(TARGET_MANGLE_DECL_ASSEMBLER_NAME): New macro.\n\t(TARGET_COMPARE_VERSION_PRIORITY): New macro.\n\t(TARGET_GENERATE_VERSION_DISPATCHER_BODY): New macro.\n\t(TARGET_GET_FUNCTION_VERSIONS_DISPATCHER): New macro.\n\t(TARGET_OPTION_FUNCTION_VERSIONS): New macro.\n\n\t* class.c (add_method): Change assembler names of function versions.\n\t(mark_versions_used): New static function.\n\t(resolve_address_of_overloaded_function): Create dispatcher decl and\n\treturn address of dispatcher instead.\n\t* decl.c (decls_match): Make decls unmatched for versioned\n\tfunctions.\n\t(duplicate_decls): Remove ambiguity for versioned functions.\n\tDelete versioned function data for merged decls. \n\t* decl2.c (check_classfn): Check attributes of versioned functions\n\tfor match.\n\t* call.c (get_function_version_dispatcher): New function.\n\t(mark_versions_used): New static function.\n\t(build_over_call): Make calls to multiversioned functions\n\tto call the dispatcher.\n\t(joust): For calls to multi-versioned functions, make the most\n\tspecialized function version win.\n\n\t* testsuite/g++.dg/mv1.C: New test.\n\t* testsuite/g++.dg/mv2.C: New test.\n\t* testsuite/g++.dg/mv3.C: New test.\n\t* testsuite/g++.dg/mv4.C: New test.\n\t* testsuite/g++.dg/mv5.C: New test.\n\t* testsuite/g++.dg/mv6.C: New test.\n\nFrom-SVN: r193204", "tree": {"sha": "9f75f10875e97a88f4cbb481f476857a29e3bbb2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9f75f10875e97a88f4cbb481f476857a29e3bbb2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3649b9b791c54f35a8bfb5540711dc4112acce7d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3649b9b791c54f35a8bfb5540711dc4112acce7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3649b9b791c54f35a8bfb5540711dc4112acce7d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3649b9b791c54f35a8bfb5540711dc4112acce7d/comments", "author": {"login": "tmsri", "id": 38991943, "node_id": "MDQ6VXNlcjM4OTkxOTQz", "avatar_url": "https://avatars.githubusercontent.com/u/38991943?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmsri", "html_url": "https://github.com/tmsri", "followers_url": "https://api.github.com/users/tmsri/followers", "following_url": "https://api.github.com/users/tmsri/following{/other_user}", "gists_url": "https://api.github.com/users/tmsri/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmsri/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmsri/subscriptions", "organizations_url": "https://api.github.com/users/tmsri/orgs", "repos_url": "https://api.github.com/users/tmsri/repos", "events_url": "https://api.github.com/users/tmsri/events{/privacy}", "received_events_url": "https://api.github.com/users/tmsri/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9dddaecf2f08a26514fbf8d2357bc1e37bbf3d39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9dddaecf2f08a26514fbf8d2357bc1e37bbf3d39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9dddaecf2f08a26514fbf8d2357bc1e37bbf3d39"}], "stats": {"total": 2030, "additions": 2011, "deletions": 19}, "files": [{"sha": "b2b7ea185aa45a0c295d9d905573d22d87861236", "filename": "gcc/ChangeLog", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3649b9b791c54f35a8bfb5540711dc4112acce7d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3649b9b791c54f35a8bfb5540711dc4112acce7d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3649b9b791c54f35a8bfb5540711dc4112acce7d", "patch": "@@ -1,3 +1,60 @@\n+2012-11-05  Sriraman Tallam  <tmsriram@google.com>\n+\n+\t* doc/tm.texi.in (TARGET_OPTION_FUNCTION_VERSIONS): New hook\n+\tdescription.\n+\t* (TARGET_COMPARE_VERSION_PRIORITY): New hook description.\n+\t* (TARGET_GET_FUNCTION_VERSIONS_DISPATCHER): New hook description.\n+\t* (TARGET_GENERATE_VERSION_DISPATCHER_BODY): New hook description.\n+\t* doc/tm.texi: Regenerate.\n+\t* target.def (compare_version_priority): New target hook.\n+\t* (generate_version_dispatcher_body): New target hook.\n+\t* (get_function_versions_dispatcher): New target hook.\n+\t* (function_versions): New target hook.\n+\t* cgraph.c (cgraph_fnver_htab): New htab.\n+\t(cgraph_fn_ver_htab_hash): New function.\n+\t(cgraph_fn_ver_htab_eq): New function.\n+\t(version_info_node): New pointer.\n+\t(insert_new_cgraph_node_version): New function.\n+\t(get_cgraph_node_version): New function.\n+\t(delete_function_version): New function.\n+\t(record_function_versions): New function.\n+\t* cgraph.h (cgraph_node): New bitfield dispatcher_function.\n+\t(cgraph_function_version_info): New struct.\n+\t(get_cgraph_node_version): New function.\n+\t(insert_new_cgraph_node_version): New function.\n+\t(record_function_versions): New function.\n+\t(delete_function_version): New function.\n+\t(init_lowered_empty_function): Expose function.\n+\t* tree.h (DECL_FUNCTION_VERSIONED): New macro.\n+\t(tree_function_decl): New bit-field versioned_function.\n+\t* cgraphunit.c (cgraph_analyze_function): Generate body of multiversion\n+\tfunction dispatcher.\n+\t(cgraph_analyze_functions): Analyze dispatcher function.\n+\t(init_lowered_empty_function): Make non-static. New parameter in_ssa.\n+\t(assemble_thunk): Add parameter to call to init_lowered_empty_function.\n+\t* config/i386/i386.c (add_condition_to_bb): New function.\n+\t(get_builtin_code_for_version): New function.\n+\t(ix86_compare_version_priority): New function.\n+\t(feature_compare): New function.\n+\t(dispatch_function_versions): New function.\n+\t(ix86_function_versions): New function.\n+\t(attr_strcmp): New function.\n+\t(ix86_mangle_function_version_assembler_name): New function.\n+\t(ix86_mangle_decl_assembler_name): New function.\n+\t(make_name): New function.\n+\t(make_dispatcher_decl): New function.\n+\t(is_function_default_version): New function.\n+\t(ix86_get_function_versions_dispatcher): New function.\n+\t(make_attribute): New function.\n+\t(make_resolver_func): New function.\n+\t(ix86_generate_version_dispatcher_body): New function.\n+\t(fold_builtin_cpu): Return integer for cpu builtins.\n+\t(TARGET_MANGLE_DECL_ASSEMBLER_NAME): New macro.\n+\t(TARGET_COMPARE_VERSION_PRIORITY): New macro.\n+\t(TARGET_GENERATE_VERSION_DISPATCHER_BODY): New macro.\n+\t(TARGET_GET_FUNCTION_VERSIONS_DISPATCHER): New macro.\n+\t(TARGET_OPTION_FUNCTION_VERSIONS): New macro.\n+\n 2012-11-05  Joern Rennecke  <joern.rennecke@embecosm.com>\n \n \t* recog.c (extract_insn): Enabled alternative defaults to 1."}, {"sha": "c9ff5c6de8d150b13718919f8c44b2215b4a208a", "filename": "gcc/cgraph.c", "status": "modified", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3649b9b791c54f35a8bfb5540711dc4112acce7d/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3649b9b791c54f35a8bfb5540711dc4112acce7d/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=3649b9b791c54f35a8bfb5540711dc4112acce7d", "patch": "@@ -132,6 +132,144 @@ static GTY(()) struct cgraph_edge *free_edges;\n /* Did procss_same_body_aliases run?  */\n bool same_body_aliases_done;\n \n+/* Map a cgraph_node to cgraph_function_version_info using this htab.\n+   The cgraph_function_version_info has a THIS_NODE field that is the\n+   corresponding cgraph_node..  */\n+\n+static htab_t GTY((param_is (struct cgraph_function_version_info *)))\n+  cgraph_fnver_htab = NULL;\n+\n+/* Hash function for cgraph_fnver_htab.  */\n+static hashval_t\n+cgraph_fnver_htab_hash (const void *ptr)\n+{\n+  int uid = ((const struct cgraph_function_version_info *)ptr)->this_node->uid;\n+  return (hashval_t)(uid);\n+}\n+\n+/* eq function for cgraph_fnver_htab.  */\n+static int\n+cgraph_fnver_htab_eq (const void *p1, const void *p2)\n+{\n+  const struct cgraph_function_version_info *n1\n+    = (const struct cgraph_function_version_info *)p1;\n+  const struct cgraph_function_version_info *n2\n+    = (const struct cgraph_function_version_info *)p2;\n+\n+  return n1->this_node->uid == n2->this_node->uid;\n+}\n+\n+/* Mark as GC root all allocated nodes.  */\n+static GTY(()) struct cgraph_function_version_info *\n+  version_info_node = NULL;\n+\n+/* Get the cgraph_function_version_info node corresponding to node.  */\n+struct cgraph_function_version_info *\n+get_cgraph_node_version (struct cgraph_node *node)\n+{\n+  struct cgraph_function_version_info *ret;\n+  struct cgraph_function_version_info key;\n+  key.this_node = node;\n+\n+  if (cgraph_fnver_htab == NULL)\n+    return NULL;\n+\n+  ret = (struct cgraph_function_version_info *)\n+    htab_find (cgraph_fnver_htab, &key);\n+\n+  return ret;\n+}\n+\n+/* Insert a new cgraph_function_version_info node into cgraph_fnver_htab\n+   corresponding to cgraph_node NODE.  */\n+struct cgraph_function_version_info *\n+insert_new_cgraph_node_version (struct cgraph_node *node)\n+{\n+  void **slot;\n+  \n+  version_info_node = NULL;\n+  version_info_node = ggc_alloc_cleared_cgraph_function_version_info ();\n+  version_info_node->this_node = node;\n+\n+  if (cgraph_fnver_htab == NULL)\n+    cgraph_fnver_htab = htab_create_ggc (2, cgraph_fnver_htab_hash,\n+\t\t\t\t         cgraph_fnver_htab_eq, NULL);\n+\n+  slot = htab_find_slot (cgraph_fnver_htab, version_info_node, INSERT);\n+  gcc_assert (slot != NULL);\n+  *slot = version_info_node;\n+  return version_info_node;\n+}\n+\n+/* Remove the cgraph_function_version_info and cgraph_node for DECL.  This\n+   DECL is a duplicate declaration.  */\n+void\n+delete_function_version (tree decl)\n+{\n+  struct cgraph_node *decl_node = cgraph_get_create_node (decl);\n+  struct cgraph_function_version_info *decl_v = NULL;\n+\n+  if (decl_node == NULL)\n+    return;\n+\n+  decl_v = get_cgraph_node_version (decl_node);\n+\n+  if (decl_v == NULL)\n+    return;\n+\n+  if (decl_v->prev != NULL)\n+   decl_v->prev->next = decl_v->next;\n+\n+  if (decl_v->next != NULL)\n+    decl_v->next->prev = decl_v->prev;\n+\n+  if (cgraph_fnver_htab != NULL)\n+    htab_remove_elt (cgraph_fnver_htab, decl_v);\n+\n+  cgraph_remove_node (decl_node);\n+}\n+\n+/* Record that DECL1 and DECL2 are semantically identical function\n+   versions.  */\n+void\n+record_function_versions (tree decl1, tree decl2)\n+{\n+  struct cgraph_node *decl1_node = cgraph_get_create_node (decl1);\n+  struct cgraph_node *decl2_node = cgraph_get_create_node (decl2);\n+  struct cgraph_function_version_info *decl1_v = NULL;\n+  struct cgraph_function_version_info *decl2_v = NULL;\n+  struct cgraph_function_version_info *before;\n+  struct cgraph_function_version_info *after;\n+\n+  gcc_assert (decl1_node != NULL && decl2_node != NULL);\n+  decl1_v = get_cgraph_node_version (decl1_node);\n+  decl2_v = get_cgraph_node_version (decl2_node);\n+\n+  if (decl1_v != NULL && decl2_v != NULL)\n+    return;\n+\n+  if (decl1_v == NULL)\n+    decl1_v = insert_new_cgraph_node_version (decl1_node);\n+\n+  if (decl2_v == NULL)\n+    decl2_v = insert_new_cgraph_node_version (decl2_node);\n+\n+  /* Chain decl2_v and decl1_v.  All semantically identical versions\n+     will be chained together.  */\n+\n+  before = decl1_v;\n+  after = decl2_v;\n+\n+  while (before->next != NULL)\n+    before = before->next;\n+\n+  while (after->prev != NULL)\n+    after= after->prev;\n+\n+  before->next = after;\n+  after->prev = before;\n+}\n+\n /* Macros to access the next item in the list of free cgraph nodes and\n    edges. */\n #define NEXT_FREE_NODE(NODE) cgraph ((NODE)->symbol.next)"}, {"sha": "25c1f33eb579e5f59b2983f21ea429143715a6e0", "filename": "gcc/cgraph.h", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3649b9b791c54f35a8bfb5540711dc4112acce7d/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3649b9b791c54f35a8bfb5540711dc4112acce7d/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=3649b9b791c54f35a8bfb5540711dc4112acce7d", "patch": "@@ -280,6 +280,8 @@ struct GTY(()) cgraph_node {\n   /* ?? We should be able to remove this.  We have enough bits in\n      cgraph to calculate it.  */\n   unsigned tm_clone : 1;\n+  /* True if this decl is a dispatcher for function versions.  */\n+  unsigned dispatcher_function : 1;\n };\n \n DEF_VEC_P(symtab_node);\n@@ -292,6 +294,47 @@ DEF_VEC_P(cgraph_node_ptr);\n DEF_VEC_ALLOC_P(cgraph_node_ptr,heap);\n DEF_VEC_ALLOC_P(cgraph_node_ptr,gc);\n \n+/* Function Multiversioning info.  */\n+struct GTY(()) cgraph_function_version_info {\n+  /* The cgraph_node for which the function version info is stored.  */\n+  struct cgraph_node *this_node;\n+  /* Chains all the semantically identical function versions.  The\n+     first function in this chain is the version_info node of the\n+     default function.  */\n+  struct cgraph_function_version_info *prev;\n+  /* If this version node corresponds to a dispatcher for function\n+     versions, this points to the version info node of the default\n+     function, the first node in the chain.  */\n+  struct cgraph_function_version_info *next;\n+  /* If this node corresponds to a function version, this points\n+     to the dispatcher function decl, which is the function that must\n+     be called to execute the right function version at run-time.\n+\n+     If this cgraph node is a dispatcher (if dispatcher_function is\n+     true, in the cgraph_node struct) for function versions, this\n+     points to resolver function, which holds the function body of the\n+     dispatcher. The dispatcher decl is an alias to the resolver\n+     function decl.  */\n+  tree dispatcher_resolver;\n+};\n+\n+/* Get the cgraph_function_version_info node corresponding to node.  */\n+struct cgraph_function_version_info *\n+  get_cgraph_node_version (struct cgraph_node *node);\n+\n+/* Insert a new cgraph_function_version_info node into cgraph_fnver_htab\n+   corresponding to cgraph_node NODE.  */\n+struct cgraph_function_version_info *\n+  insert_new_cgraph_node_version (struct cgraph_node *node);\n+\n+/* Record that DECL1 and DECL2 are semantically identical function\n+   versions.  */\n+void record_function_versions (tree decl1, tree decl2);\n+\n+/* Remove the cgraph_function_version_info and cgraph_node for DECL.  This\n+   DECL is a duplicate declaration.  */\n+void delete_function_version (tree decl);\n+\n /* A cgraph node set is a collection of cgraph nodes.  A cgraph node\n    can appear in multiple sets.  */\n struct cgraph_node_set_def\n@@ -638,6 +681,9 @@ void init_cgraph (void);\n bool cgraph_process_new_functions (void);\n void cgraph_process_same_body_aliases (void);\n void fixup_same_cpp_alias_visibility (symtab_node node, symtab_node target, tree alias);\n+/*  Initialize datastructures so DECL is a function in lowered gimple form.\n+    IN_SSA is true if the gimple is in SSA.  */\n+basic_block init_lowered_empty_function (tree decl, bool in_ssa);\n \n /* In cgraphclones.c  */\n "}, {"sha": "bf1326bbb886e902cd548ee7496d04a7742e1014", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 29, "deletions": 8, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3649b9b791c54f35a8bfb5540711dc4112acce7d/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3649b9b791c54f35a8bfb5540711dc4112acce7d/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=3649b9b791c54f35a8bfb5540711dc4112acce7d", "patch": "@@ -630,6 +630,21 @@ cgraph_analyze_function (struct cgraph_node *node)\n       cgraph_create_edge (node, cgraph_get_node (node->thunk.alias),\n \t\t\t  NULL, 0, CGRAPH_FREQ_BASE);\n     }\n+  else if (node->dispatcher_function)\n+    {\n+      /* Generate the dispatcher body of multi-versioned functions.  */\n+      struct cgraph_function_version_info *dispatcher_version_info\n+\t= get_cgraph_node_version (node);\n+      if (dispatcher_version_info != NULL\n+          && (dispatcher_version_info->dispatcher_resolver\n+\t      == NULL_TREE))\n+\t{\n+\t  tree resolver = NULL_TREE;\n+\t  gcc_assert (targetm.generate_version_dispatcher_body);\n+\t  resolver = targetm.generate_version_dispatcher_body (node);\n+\t  gcc_assert (resolver != NULL_TREE);\n+\t}\n+    }\n   else\n     {\n       push_cfun (DECL_STRUCT_FUNCTION (decl));\n@@ -938,7 +953,8 @@ cgraph_analyze_functions (void)\n \t      See gcc.c-torture/compile/20011119-1.c  */\n \t      if (!DECL_STRUCT_FUNCTION (decl)\n \t\t  && (!cnode->alias || !cnode->thunk.alias)\n-\t\t  && !cnode->thunk.thunk_p)\n+\t\t  && !cnode->thunk.thunk_p\n+\t\t  && !cnode->dispatcher_function)\n \t\t{\n \t\t  cgraph_reset_node (cnode);\n \t\t  cnode->local.redefined_extern_inline = true;\n@@ -1219,23 +1235,28 @@ mark_functions_to_output (void)\n }\n \n /* DECL is FUNCTION_DECL.  Initialize datastructures so DECL is a function\n-   in lowered gimple form.\n+   in lowered gimple form.  IN_SSA is true if the gimple is in SSA.\n    \n    Set current_function_decl and cfun to newly constructed empty function body.\n    return basic block in the function body.  */\n \n-static basic_block\n-init_lowered_empty_function (tree decl)\n+basic_block\n+init_lowered_empty_function (tree decl, bool in_ssa)\n {\n   basic_block bb;\n \n   current_function_decl = decl;\n   allocate_struct_function (decl, false);\n   gimple_register_cfg_hooks ();\n   init_empty_tree_cfg ();\n-  init_tree_ssa (cfun);\n-  init_ssa_operands (cfun);\n-  cfun->gimple_df->in_ssa_p = true;\n+\n+  if (in_ssa)\n+    {\n+      init_tree_ssa (cfun);\n+      init_ssa_operands (cfun);\n+      cfun->gimple_df->in_ssa_p = true;\n+    }\n+\n   DECL_INITIAL (decl) = make_node (BLOCK);\n \n   DECL_SAVED_TREE (decl) = error_mark_node;\n@@ -1442,7 +1463,7 @@ assemble_thunk (struct cgraph_node *node)\n       else\n \tresdecl = DECL_RESULT (thunk_fndecl);\n \n-      bb = then_bb = else_bb = return_bb = init_lowered_empty_function (thunk_fndecl);\n+      bb = then_bb = else_bb = return_bb = init_lowered_empty_function (thunk_fndecl, true);\n \n       bsi = gsi_start_bb (bb);\n "}, {"sha": "d92fb1677abd6c1a332a79aa9c8d09341ec7bc35", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 990, "deletions": 4, "changes": 994, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3649b9b791c54f35a8bfb5540711dc4112acce7d/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3649b9b791c54f35a8bfb5540711dc4112acce7d/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=3649b9b791c54f35a8bfb5540711dc4112acce7d", "patch": "@@ -62,6 +62,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"opts.h\"\n #include \"diagnostic.h\"\n #include \"dumpfile.h\"\n+#include \"tree-pass.h\"\n+#include \"tree-flow.h\"\n \n enum upper_128bits_state\n {\n@@ -28463,6 +28465,967 @@ ix86_init_mmx_sse_builtins (void)\n     }\n }\n \n+/* This adds a condition to the basic_block NEW_BB in function FUNCTION_DECL\n+   to return a pointer to VERSION_DECL if the outcome of the expression\n+   formed by PREDICATE_CHAIN is true.  This function will be called during\n+   version dispatch to decide which function version to execute.  It returns\n+   the basic block at the end, to which more conditions can be added.  */\n+\n+static basic_block\n+add_condition_to_bb (tree function_decl, tree version_decl,\n+\t\t     tree predicate_chain, basic_block new_bb)\n+{\n+  gimple return_stmt;\n+  tree convert_expr, result_var;\n+  gimple convert_stmt;\n+  gimple call_cond_stmt;\n+  gimple if_else_stmt;\n+\n+  basic_block bb1, bb2, bb3;\n+  edge e12, e23;\n+\n+  tree cond_var, and_expr_var = NULL_TREE;\n+  gimple_seq gseq;\n+\n+  tree predicate_decl, predicate_arg;\n+\n+  push_cfun (DECL_STRUCT_FUNCTION (function_decl));\n+\n+  gcc_assert (new_bb != NULL);\n+  gseq = bb_seq (new_bb);\n+\n+\n+  convert_expr = build1 (CONVERT_EXPR, ptr_type_node,\n+\t     \t\t build_fold_addr_expr (version_decl));\n+  result_var = create_tmp_var (ptr_type_node, NULL);\n+  convert_stmt = gimple_build_assign (result_var, convert_expr); \n+  return_stmt = gimple_build_return (result_var);\n+\n+  if (predicate_chain == NULL_TREE)\n+    {\n+      gimple_seq_add_stmt (&gseq, convert_stmt);\n+      gimple_seq_add_stmt (&gseq, return_stmt);\n+      set_bb_seq (new_bb, gseq);\n+      gimple_set_bb (convert_stmt, new_bb);\n+      gimple_set_bb (return_stmt, new_bb);\n+      pop_cfun ();\n+      return new_bb;\n+    }\n+\n+  while (predicate_chain != NULL)\n+    {\n+      cond_var = create_tmp_var (integer_type_node, NULL);\n+      predicate_decl = TREE_PURPOSE (predicate_chain);\n+      predicate_arg = TREE_VALUE (predicate_chain);\n+      call_cond_stmt = gimple_build_call (predicate_decl, 1, predicate_arg);\n+      gimple_call_set_lhs (call_cond_stmt, cond_var);\n+\n+      gimple_set_block (call_cond_stmt, DECL_INITIAL (function_decl));\n+      gimple_set_bb (call_cond_stmt, new_bb);\n+      gimple_seq_add_stmt (&gseq, call_cond_stmt);\n+\n+      predicate_chain = TREE_CHAIN (predicate_chain);\n+      \n+      if (and_expr_var == NULL)\n+        and_expr_var = cond_var;\n+      else\n+\t{\n+\t  gimple assign_stmt;\n+\t  /* Use MIN_EXPR to check if any integer is zero?.\n+\t     and_expr_var = min_expr <cond_var, and_expr_var>  */\n+\t  assign_stmt = gimple_build_assign (and_expr_var,\n+\t\t\t  build2 (MIN_EXPR, integer_type_node,\n+\t\t\t\t  cond_var, and_expr_var));\n+\n+\t  gimple_set_block (assign_stmt, DECL_INITIAL (function_decl));\n+\t  gimple_set_bb (assign_stmt, new_bb);\n+\t  gimple_seq_add_stmt (&gseq, assign_stmt);\n+\t}\n+    }\n+\n+  if_else_stmt = gimple_build_cond (GT_EXPR, and_expr_var,\n+\t  \t\t            integer_zero_node,\n+\t\t\t\t    NULL_TREE, NULL_TREE);\n+  gimple_set_block (if_else_stmt, DECL_INITIAL (function_decl));\n+  gimple_set_bb (if_else_stmt, new_bb);\n+  gimple_seq_add_stmt (&gseq, if_else_stmt);\n+\n+  gimple_seq_add_stmt (&gseq, convert_stmt);\n+  gimple_seq_add_stmt (&gseq, return_stmt);\n+  set_bb_seq (new_bb, gseq);\n+\n+  bb1 = new_bb;\n+  e12 = split_block (bb1, if_else_stmt);\n+  bb2 = e12->dest;\n+  e12->flags &= ~EDGE_FALLTHRU;\n+  e12->flags |= EDGE_TRUE_VALUE;\n+\n+  e23 = split_block (bb2, return_stmt);\n+\n+  gimple_set_bb (convert_stmt, bb2);\n+  gimple_set_bb (return_stmt, bb2);\n+\n+  bb3 = e23->dest;\n+  make_edge (bb1, bb3, EDGE_FALSE_VALUE); \n+\n+  remove_edge (e23);\n+  make_edge (bb2, EXIT_BLOCK_PTR, 0);\n+\n+  pop_cfun ();\n+\n+  return bb3;\n+}\n+\n+/* This parses the attribute arguments to target in DECL and determines\n+   the right builtin to use to match the platform specification.\n+   It returns the priority value for this version decl.  If PREDICATE_LIST\n+   is not NULL, it stores the list of cpu features that need to be checked\n+   before dispatching this function.  */\n+\n+static unsigned int\n+get_builtin_code_for_version (tree decl, tree *predicate_list)\n+{\n+  tree attrs;\n+  struct cl_target_option cur_target;\n+  tree target_node;\n+  struct cl_target_option *new_target;\n+  const char *arg_str = NULL;\n+  const char *attrs_str = NULL;\n+  char *tok_str = NULL;\n+  char *token;\n+\n+  /* Priority of i386 features, greater value is higher priority.   This is\n+     used to decide the order in which function dispatch must happen.  For\n+     instance, a version specialized for SSE4.2 should be checked for dispatch\n+     before a version for SSE3, as SSE4.2 implies SSE3.  */\n+  enum feature_priority\n+  {\n+    P_ZERO = 0,\n+    P_MMX,\n+    P_SSE,\n+    P_SSE2,\n+    P_SSE3,\n+    P_SSSE3,\n+    P_PROC_SSSE3,\n+    P_SSE4_a,\n+    P_PROC_SSE4_a,\n+    P_SSE4_1,\n+    P_SSE4_2,\n+    P_PROC_SSE4_2,\n+    P_POPCNT,\n+    P_AVX,\n+    P_AVX2,\n+    P_FMA,\n+    P_PROC_FMA\n+  };\n+\n+ enum feature_priority priority = P_ZERO;\n+\n+  /* These are the target attribute strings for which a dispatcher is\n+     available, from fold_builtin_cpu.  */\n+\n+  static struct _feature_list\n+    {\n+      const char *const name;\n+      const enum feature_priority priority;\n+    }\n+  const feature_list[] =\n+    {\n+      {\"mmx\", P_MMX},\n+      {\"sse\", P_SSE},\n+      {\"sse2\", P_SSE2},\n+      {\"sse3\", P_SSE3},\n+      {\"ssse3\", P_SSSE3},\n+      {\"sse4.1\", P_SSE4_1},\n+      {\"sse4.2\", P_SSE4_2},\n+      {\"popcnt\", P_POPCNT},\n+      {\"avx\", P_AVX},\n+      {\"avx2\", P_AVX2}\n+    };\n+\n+\n+  static unsigned int NUM_FEATURES\n+    = sizeof (feature_list) / sizeof (struct _feature_list);\n+\n+  unsigned int i;\n+\n+  tree predicate_chain = NULL_TREE;\n+  tree predicate_decl, predicate_arg;\n+\n+  attrs = lookup_attribute (\"target\", DECL_ATTRIBUTES (decl));\n+  gcc_assert (attrs != NULL);\n+\n+  attrs = TREE_VALUE (TREE_VALUE (attrs));\n+\n+  gcc_assert (TREE_CODE (attrs) == STRING_CST);\n+  attrs_str = TREE_STRING_POINTER (attrs);\n+\n+\n+  /* Handle arch= if specified.  For priority, set it to be 1 more than\n+     the best instruction set the processor can handle.  For instance, if\n+     there is a version for atom and a version for ssse3 (the highest ISA\n+     priority for atom), the atom version must be checked for dispatch\n+     before the ssse3 version. */\n+  if (strstr (attrs_str, \"arch=\") != NULL)\n+    {\n+      cl_target_option_save (&cur_target, &global_options);\n+      target_node = ix86_valid_target_attribute_tree (attrs);\n+    \n+      gcc_assert (target_node);\n+      new_target = TREE_TARGET_OPTION (target_node);\n+      gcc_assert (new_target);\n+      \n+      if (new_target->arch_specified && new_target->arch > 0)\n+\t{\n+\t  switch (new_target->arch)\n+\t    {\n+\t    case PROCESSOR_CORE2_32:\n+\t    case PROCESSOR_CORE2_64:\n+\t      arg_str = \"core2\";\n+\t      priority = P_PROC_SSSE3;\n+\t      break;\n+\t    case PROCESSOR_COREI7_32:\n+\t    case PROCESSOR_COREI7_64:\n+\t      arg_str = \"corei7\";\n+\t      priority = P_PROC_SSE4_2;\n+\t      break;\n+\t    case PROCESSOR_ATOM:\n+\t      arg_str = \"atom\";\n+\t      priority = P_PROC_SSSE3;\n+\t      break;\n+\t    case PROCESSOR_AMDFAM10:\n+\t      arg_str = \"amdfam10h\";\n+\t      priority = P_PROC_SSE4_a;\n+\t      break;\n+\t    case PROCESSOR_BDVER1:\n+\t      arg_str = \"bdver1\";\n+\t      priority = P_PROC_FMA;\n+\t      break;\n+\t    case PROCESSOR_BDVER2:\n+\t      arg_str = \"bdver2\";\n+\t      priority = P_PROC_FMA;\n+\t      break;\n+\t    }  \n+\t}    \n+    \n+      cl_target_option_restore (&global_options, &cur_target);\n+\t\n+      if (predicate_list && arg_str == NULL)\n+\t{\n+\t  error_at (DECL_SOURCE_LOCATION (decl),\n+\t    \t\"No dispatcher found for the versioning attributes\");\n+\t  return 0;\n+\t}\n+    \n+      if (predicate_list)\n+\t{\n+          predicate_decl = ix86_builtins [(int) IX86_BUILTIN_CPU_IS];\n+          /* For a C string literal the length includes the trailing NULL.  */\n+          predicate_arg = build_string_literal (strlen (arg_str) + 1, arg_str);\n+          predicate_chain = tree_cons (predicate_decl, predicate_arg,\n+\t\t\t\t       predicate_chain);\n+\t}\n+    }\n+\n+  /* Process feature name.  */\n+  tok_str =  (char *) xmalloc (strlen (attrs_str) + 1);\n+  strcpy (tok_str, attrs_str);\n+  token = strtok (tok_str, \",\");\n+  predicate_decl = ix86_builtins [(int) IX86_BUILTIN_CPU_SUPPORTS];\n+\n+  while (token != NULL)\n+    {\n+      /* Do not process \"arch=\"  */\n+      if (strncmp (token, \"arch=\", 5) == 0)\n+\t{\n+\t  token = strtok (NULL, \",\");\n+\t  continue;\n+\t}\n+      for (i = 0; i < NUM_FEATURES; ++i)\n+\t{\n+\t  if (strcmp (token, feature_list[i].name) == 0)\n+\t    {\n+\t      if (predicate_list)\n+\t\t{\n+\t\t  predicate_arg = build_string_literal (\n+\t\t\t\t  strlen (feature_list[i].name) + 1,\n+\t\t\t\t  feature_list[i].name);\n+\t\t  predicate_chain = tree_cons (predicate_decl, predicate_arg,\n+\t\t\t\t\t       predicate_chain);\n+\t\t}\n+\t      /* Find the maximum priority feature.  */\n+\t      if (feature_list[i].priority > priority)\n+\t\tpriority = feature_list[i].priority;\n+\n+\t      break;\n+\t    }\n+\t}\n+      if (predicate_list && i == NUM_FEATURES)\n+\t{\n+\t  error_at (DECL_SOURCE_LOCATION (decl),\n+\t\t    \"No dispatcher found for %s\", token);\n+\t  return 0;\n+\t}\n+      token = strtok (NULL, \",\");\n+    }\n+  free (tok_str);\n+\n+  if (predicate_list && predicate_chain == NULL_TREE)\n+    {\n+      error_at (DECL_SOURCE_LOCATION (decl),\n+\t        \"No dispatcher found for the versioning attributes : %s\",\n+\t        attrs_str);\n+      return 0;\n+    }\n+  else if (predicate_list)\n+    {\n+      predicate_chain = nreverse (predicate_chain);\n+      *predicate_list = predicate_chain;\n+    }\n+\n+  return priority; \n+}\n+\n+/* This compares the priority of target features in function DECL1\n+   and DECL2.  It returns positive value if DECL1 is higher priority,\n+   negative value if DECL2 is higher priority and 0 if they are the\n+   same.  */\n+\n+static int\n+ix86_compare_version_priority (tree decl1, tree decl2)\n+{\n+  unsigned int priority1 = 0;\n+  unsigned int priority2 = 0;\n+\n+  if (lookup_attribute (\"target\", DECL_ATTRIBUTES (decl1)) != NULL)\n+    priority1 = get_builtin_code_for_version (decl1, NULL);\n+\n+  if (lookup_attribute (\"target\", DECL_ATTRIBUTES (decl2)) != NULL)\n+    priority2 = get_builtin_code_for_version (decl2, NULL);\n+\n+  return (int)priority1 - (int)priority2;\n+}\n+\n+/* V1 and V2 point to function versions with different priorities\n+   based on the target ISA.  This function compares their priorities.  */\n+ \n+static int\n+feature_compare (const void *v1, const void *v2)\n+{\n+  typedef struct _function_version_info\n+    {\n+      tree version_decl;\n+      tree predicate_chain;\n+      unsigned int dispatch_priority;\n+    } function_version_info;\n+\n+  const function_version_info c1 = *(const function_version_info *)v1;\n+  const function_version_info c2 = *(const function_version_info *)v2;\n+  return (c2.dispatch_priority - c1.dispatch_priority);\n+}\n+\n+/* This function generates the dispatch function for\n+   multi-versioned functions.  DISPATCH_DECL is the function which will\n+   contain the dispatch logic.  FNDECLS are the function choices for\n+   dispatch, and is a tree chain.  EMPTY_BB is the basic block pointer\n+   in DISPATCH_DECL in which the dispatch code is generated.  */\n+\n+static int\n+dispatch_function_versions (tree dispatch_decl,\n+\t\t\t    void *fndecls_p,\n+\t\t\t    basic_block *empty_bb)\n+{\n+  tree default_decl;\n+  gimple ifunc_cpu_init_stmt;\n+  gimple_seq gseq;\n+  int ix;\n+  tree ele;\n+  VEC (tree, heap) *fndecls;\n+  unsigned int num_versions = 0;\n+  unsigned int actual_versions = 0;\n+  unsigned int i;\n+\n+  struct _function_version_info\n+    {\n+      tree version_decl;\n+      tree predicate_chain;\n+      unsigned int dispatch_priority;\n+    }*function_version_info;\n+\n+  gcc_assert (dispatch_decl != NULL\n+\t      && fndecls_p != NULL\n+\t      && empty_bb != NULL);\n+\n+  /*fndecls_p is actually a vector.  */\n+  fndecls = (VEC (tree, heap) *)fndecls_p;\n+\n+  /* At least one more version other than the default.  */\n+  num_versions = VEC_length (tree, fndecls);\n+  gcc_assert (num_versions >= 2);\n+\n+  function_version_info = (struct _function_version_info *)\n+    XNEWVEC (struct _function_version_info, (num_versions - 1));\n+\n+  /* The first version in the vector is the default decl.  */\n+  default_decl = VEC_index (tree, fndecls, 0);\n+\n+  push_cfun (DECL_STRUCT_FUNCTION (dispatch_decl));\n+\n+  gseq = bb_seq (*empty_bb);\n+  /* Function version dispatch is via IFUNC.  IFUNC resolvers fire before\n+     constructors, so explicity call __builtin_cpu_init here.  */\n+  ifunc_cpu_init_stmt = gimple_build_call_vec (\n+                     ix86_builtins [(int) IX86_BUILTIN_CPU_INIT], NULL);\n+  gimple_seq_add_stmt (&gseq, ifunc_cpu_init_stmt);\n+  gimple_set_bb (ifunc_cpu_init_stmt, *empty_bb);\n+  set_bb_seq (*empty_bb, gseq);\n+\n+  pop_cfun ();\n+\n+\n+  for (ix = 1; VEC_iterate (tree, fndecls, ix, ele); ++ix)\n+    {\n+      tree version_decl = ele;\n+      tree predicate_chain = NULL_TREE;\n+      unsigned int priority;\n+      /* Get attribute string, parse it and find the right predicate decl.\n+         The predicate function could be a lengthy combination of many\n+\t features, like arch-type and various isa-variants.  */\n+      priority = get_builtin_code_for_version (version_decl,\n+\t \t\t\t               &predicate_chain);\n+\n+      if (predicate_chain == NULL_TREE)\n+\tcontinue;\n+\n+      actual_versions++;\n+      function_version_info [ix - 1].version_decl = version_decl;\n+      function_version_info [ix - 1].predicate_chain = predicate_chain;\n+      function_version_info [ix - 1].dispatch_priority = priority;\n+    }\n+\n+  /* Sort the versions according to descending order of dispatch priority.  The\n+     priority is based on the ISA.  This is not a perfect solution.  There\n+     could still be ambiguity.  If more than one function version is suitable\n+     to execute,  which one should be dispatched?  In future, allow the user\n+     to specify a dispatch  priority next to the version.  */\n+  qsort (function_version_info, actual_versions,\n+         sizeof (struct _function_version_info), feature_compare);\n+\n+  for  (i = 0; i < actual_versions; ++i)\n+    *empty_bb = add_condition_to_bb (dispatch_decl,\n+\t\t\t\t     function_version_info[i].version_decl,\n+\t\t\t\t     function_version_info[i].predicate_chain,\n+\t\t\t\t     *empty_bb);\n+\n+  /* dispatch default version at the end.  */\n+  *empty_bb = add_condition_to_bb (dispatch_decl, default_decl,\n+\t\t\t\t   NULL, *empty_bb);\n+\n+  free (function_version_info);\n+  return 0;\n+}\n+\n+/* This function returns true if FN1 and FN2 are versions of the same function,\n+   that is, the targets of the function decls are different.  This assumes\n+   that FN1 and FN2 have the same signature.  */\n+\n+static bool\n+ix86_function_versions (tree fn1, tree fn2)\n+{\n+  tree attr1, attr2;\n+  struct cl_target_option *target1, *target2;\n+\n+  if (TREE_CODE (fn1) != FUNCTION_DECL\n+      || TREE_CODE (fn2) != FUNCTION_DECL)\n+    return false;\n+\n+  attr1 = DECL_FUNCTION_SPECIFIC_TARGET (fn1);\n+  attr2 = DECL_FUNCTION_SPECIFIC_TARGET (fn2);\n+\n+  /* Atleast one function decl should have target attribute specified.  */\n+  if (attr1 == NULL_TREE && attr2 == NULL_TREE)\n+    return false;\n+\n+  if (attr1 == NULL_TREE)\n+    attr1 = target_option_default_node;\n+  else if (attr2 == NULL_TREE)\n+    attr2 = target_option_default_node;\n+\n+  target1 = TREE_TARGET_OPTION (attr1);\n+  target2 = TREE_TARGET_OPTION (attr2);\n+\n+  /* target1 and target2 must be different in some way.  */\n+  if (target1->x_ix86_isa_flags == target2->x_ix86_isa_flags\n+      && target1->x_target_flags == target2->x_target_flags\n+      && target1->arch == target2->arch\n+      && target1->tune == target2->tune\n+      && target1->x_ix86_fpmath == target2->x_ix86_fpmath\n+      && target1->branch_cost == target2->branch_cost)\n+    return false;\n+\n+  return true;\n+}\n+\n+/* Comparator function to be used in qsort routine to sort attribute\n+   specification strings to \"target\".  */\n+\n+static int\n+attr_strcmp (const void *v1, const void *v2)\n+{\n+  const char *c1 = *(char *const*)v1;\n+  const char *c2 = *(char *const*)v2;\n+  return strcmp (c1, c2);\n+}\n+\n+/* STR is the argument to target attribute.  This function tokenizes\n+   the comma separated arguments, sorts them and returns a string which\n+   is a unique identifier for the comma separated arguments.   It also\n+   replaces non-identifier characters \"=,-\" with \"_\".  */\n+\n+static char *\n+sorted_attr_string (const char *str)\n+{\n+  char **args = NULL;\n+  char *attr_str, *ret_str;\n+  char *attr = NULL;\n+  unsigned int argnum = 1;\n+  unsigned int i;\n+\n+  for (i = 0; i < strlen (str); i++)\n+    if (str[i] == ',')\n+      argnum++;\n+\n+  attr_str = (char *)xmalloc (strlen (str) + 1);\n+  strcpy (attr_str, str);\n+\n+  /* Replace \"=,-\" with \"_\".  */\n+  for (i = 0; i < strlen (attr_str); i++)\n+    if (attr_str[i] == '=' || attr_str[i]== '-')\n+      attr_str[i] = '_';\n+\n+  if (argnum == 1)\n+    return attr_str;\n+\n+  args = XNEWVEC (char *, argnum);\n+\n+  i = 0;\n+  attr = strtok (attr_str, \",\");\n+  while (attr != NULL)\n+    {\n+      args[i] = attr;\n+      i++;\n+      attr = strtok (NULL, \",\");\n+    }\n+\n+  qsort (args, argnum, sizeof (char*), attr_strcmp);\n+\n+  ret_str = (char *)xmalloc (strlen (str) + 1);\n+  strcpy (ret_str, args[0]);\n+  for (i = 1; i < argnum; i++)\n+    {\n+      strcat (ret_str, \"_\");\n+      strcat (ret_str, args[i]);\n+    }\n+\n+  free (args);\n+  free (attr_str);\n+  return ret_str;\n+}\n+\n+/* This function changes the assembler name for functions that are\n+   versions.  If DECL is a function version and has a \"target\"\n+   attribute, it appends the attribute string to its assembler name.  */\n+\n+static tree\n+ix86_mangle_function_version_assembler_name (tree decl, tree id)\n+{\n+  tree version_attr;\n+  const char *orig_name, *version_string, *attr_str;\n+  char *assembler_name;\n+\n+  if (DECL_DECLARED_INLINE_P (decl)\n+      && lookup_attribute (\"gnu_inline\",\n+\t\t\t   DECL_ATTRIBUTES (decl)))\n+    error_at (DECL_SOURCE_LOCATION (decl),\n+\t      \"Function versions cannot be marked as gnu_inline,\"\n+\t      \" bodies have to be generated\");\n+\n+  if (DECL_VIRTUAL_P (decl)\n+      || DECL_VINDEX (decl))\n+    error_at (DECL_SOURCE_LOCATION (decl),\n+\t      \"Virtual function versioning not supported\\n\");\n+\n+  version_attr = lookup_attribute (\"target\", DECL_ATTRIBUTES (decl));\n+\n+  /* target attribute string is NULL for default functions.  */\n+  if (version_attr == NULL_TREE)\n+    return id;\n+\n+  orig_name = IDENTIFIER_POINTER (id);\n+  version_string\n+    = TREE_STRING_POINTER (TREE_VALUE (TREE_VALUE (version_attr)));\n+\n+  attr_str = sorted_attr_string (version_string);\n+  assembler_name = (char *) xmalloc (strlen (orig_name)\n+\t\t\t\t     + strlen (attr_str) + 2);\n+\n+  sprintf (assembler_name, \"%s.%s\", orig_name, attr_str);\n+\n+  /* Allow assembler name to be modified if already set.  */\n+  if (DECL_ASSEMBLER_NAME_SET_P (decl))\n+    SET_DECL_RTL (decl, NULL);\n+\n+  return get_identifier (assembler_name);\n+}\n+\n+static tree \n+ix86_mangle_decl_assembler_name (tree decl, tree id)\n+{\n+  /* For function version, add the target suffix to the assembler name.  */\n+  if (TREE_CODE (decl) == FUNCTION_DECL\n+      && DECL_FUNCTION_VERSIONED (decl))\n+    return ix86_mangle_function_version_assembler_name (decl, id);\n+\n+  return id;\n+}\n+\n+/* Return a new name by appending SUFFIX to the DECL name.  If make_unique\n+   is true, append the full path name of the source file.  */\n+\n+static char *\n+make_name (tree decl, const char *suffix, bool make_unique)\n+{\n+  char *global_var_name;\n+  int name_len;\n+  const char *name;\n+  const char *unique_name = NULL;\n+\n+  name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n+\n+  /* Get a unique name that can be used globally without any chances\n+     of collision at link time.  */\n+  if (make_unique)\n+    unique_name = IDENTIFIER_POINTER (get_file_function_name (\"\\0\"));\n+\n+  name_len = strlen (name) + strlen (suffix) + 2;\n+\n+  if (make_unique)\n+    name_len += strlen (unique_name) + 1;\n+  global_var_name = XNEWVEC (char, name_len);\n+\n+  /* Use '.' to concatenate names as it is demangler friendly.  */\n+  if (make_unique)\n+      snprintf (global_var_name, name_len, \"%s.%s.%s\", name,\n+\t\tunique_name, suffix);\n+  else\n+      snprintf (global_var_name, name_len, \"%s.%s\", name, suffix);\n+\n+  return global_var_name;\n+}\n+\n+/* Make a dispatcher declaration for the multi-versioned function DECL.\n+   Calls to DECL function will be replaced with calls to the dispatcher\n+   by the front-end.  Return the decl created.  */\n+\n+static tree\n+make_dispatcher_decl (const tree decl)\n+{\n+  tree func_decl;\n+  char *func_name, *resolver_name;\n+  tree fn_type, func_type;\n+  bool is_uniq = false;\n+\n+  if (TREE_PUBLIC (decl) == 0)\n+    is_uniq = true;\n+\n+  func_name = make_name (decl, \"ifunc\", is_uniq);\n+  resolver_name = make_name (decl, \"resolver\", is_uniq);\n+  gcc_assert (resolver_name);\n+\n+  fn_type = TREE_TYPE (decl);\n+  func_type = build_function_type (TREE_TYPE (fn_type),\n+\t\t\t\t   TYPE_ARG_TYPES (fn_type));\n+  \n+  func_decl = build_fn_decl (func_name, func_type);\n+  TREE_USED (func_decl) = 1;\n+  DECL_CONTEXT (func_decl) = NULL_TREE;\n+  DECL_INITIAL (func_decl) = error_mark_node;\n+  DECL_ARTIFICIAL (func_decl) = 1;\n+  /* Mark this func as external, the resolver will flip it again if\n+     it gets generated.  */\n+  DECL_EXTERNAL (func_decl) = 1;\n+  /* This will be of type IFUNCs have to be externally visible.  */\n+  TREE_PUBLIC (func_decl) = 1;\n+\n+  return func_decl;  \n+}\n+\n+/* Returns true if decl is multi-versioned and DECL is the default function,\n+   that is it is not tagged with target specific optimization.  */\n+\n+static bool\n+is_function_default_version (const tree decl)\n+{\n+  return (TREE_CODE (decl) == FUNCTION_DECL\n+\t  && DECL_FUNCTION_VERSIONED (decl)\n+\t  && DECL_FUNCTION_SPECIFIC_TARGET (decl) == NULL_TREE);\n+}\n+\n+/* Make a dispatcher declaration for the multi-versioned function DECL.\n+   Calls to DECL function will be replaced with calls to the dispatcher\n+   by the front-end.  Returns the decl of the dispatcher function.  */\n+\n+static tree\n+ix86_get_function_versions_dispatcher (void *decl)\n+{\n+  tree fn = (tree) decl;\n+  struct cgraph_node *node = NULL;\n+  struct cgraph_node *default_node = NULL;\n+  struct cgraph_function_version_info *node_v = NULL;\n+  struct cgraph_function_version_info *it_v = NULL;\n+  struct cgraph_function_version_info *first_v = NULL;\n+\n+  tree dispatch_decl = NULL;\n+  struct cgraph_node *dispatcher_node = NULL;\n+  struct cgraph_function_version_info *dispatcher_version_info = NULL;\n+\n+  struct cgraph_function_version_info *default_version_info = NULL;\n+ \n+  gcc_assert (fn != NULL && DECL_FUNCTION_VERSIONED (fn));\n+\n+  node = cgraph_get_node (fn);\n+  gcc_assert (node != NULL);\n+\n+  node_v = get_cgraph_node_version (node);\n+  gcc_assert (node_v != NULL);\n+ \n+  if (node_v->dispatcher_resolver != NULL)\n+    return node_v->dispatcher_resolver;\n+\n+  /* Find the default version and make it the first node.  */\n+  first_v = node_v;\n+  /* Go to the beginnig of the chain.  */\n+  while (first_v->prev != NULL)\n+    first_v = first_v->prev;\n+  default_version_info = first_v;\n+  while (default_version_info != NULL)\n+    {\n+      if (is_function_default_version\n+\t    (default_version_info->this_node->symbol.decl))\n+        break;\n+      default_version_info = default_version_info->next;\n+    }\n+\n+  /* If there is no default node, just return NULL.  */\n+  if (default_version_info == NULL)\n+    return NULL;\n+\n+  /* Make default info the first node.  */\n+  if (first_v != default_version_info)\n+    {\n+      default_version_info->prev->next = default_version_info->next;\n+      if (default_version_info->next)\n+        default_version_info->next->prev = default_version_info->prev;\n+      first_v->prev = default_version_info;\n+      default_version_info->next = first_v;\n+      default_version_info->prev = NULL;\n+    }\n+\n+  default_node = default_version_info->this_node;\n+\n+#if defined (ASM_OUTPUT_TYPE_DIRECTIVE) && HAVE_GNU_INDIRECT_FUNCTION\n+  /* Right now, the dispatching is done via ifunc.  */\n+  dispatch_decl = make_dispatcher_decl (default_node->symbol.decl); \n+#else\n+  error_at (DECL_SOURCE_LOCATION (default_node->symbol.decl),\n+\t    \"Multiversioning needs ifunc which is not supported \"\n+\t    \"in this configuration\");\n+#endif\n+\n+  dispatcher_node = cgraph_get_create_node (dispatch_decl);\n+  gcc_assert (dispatcher_node != NULL);\n+  dispatcher_node->dispatcher_function = 1;\n+  dispatcher_version_info\n+    = insert_new_cgraph_node_version (dispatcher_node);\n+  dispatcher_version_info->next = default_version_info;\n+  dispatcher_node->local.finalized = 1;\n+ \n+  /* Set the dispatcher for all the versions.  */ \n+  it_v = default_version_info;\n+  while (it_v->next != NULL)\n+    {\n+      it_v->dispatcher_resolver = dispatch_decl;\n+      it_v = it_v->next;\n+    }\n+\n+  return dispatch_decl;\n+}\n+\n+/* Makes a function attribute of the form NAME(ARG_NAME) and chains\n+   it to CHAIN.  */\n+\n+static tree\n+make_attribute (const char *name, const char *arg_name, tree chain)\n+{\n+  tree attr_name;\n+  tree attr_arg_name;\n+  tree attr_args;\n+  tree attr;\n+\n+  attr_name = get_identifier (name);\n+  attr_arg_name = build_string (strlen (arg_name), arg_name);\n+  attr_args = tree_cons (NULL_TREE, attr_arg_name, NULL_TREE);\n+  attr = tree_cons (attr_name, attr_args, chain);\n+  return attr;\n+}\n+\n+/* Make the resolver function decl to dispatch the versions of\n+   a multi-versioned function,  DEFAULT_DECL.  Create an\n+   empty basic block in the resolver and store the pointer in\n+   EMPTY_BB.  Return the decl of the resolver function.  */\n+\n+static tree\n+make_resolver_func (const tree default_decl,\n+\t\t    const tree dispatch_decl,\n+\t\t    basic_block *empty_bb)\n+{\n+  char *resolver_name;\n+  tree decl, type, decl_name, t;\n+  bool is_uniq = false;\n+\n+  /* IFUNC's have to be globally visible.  So, if the default_decl is\n+     not, then the name of the IFUNC should be made unique.  */\n+  if (TREE_PUBLIC (default_decl) == 0)\n+    is_uniq = true;\n+\n+  /* Append the filename to the resolver function if the versions are\n+     not externally visible.  This is because the resolver function has\n+     to be externally visible for the loader to find it.  So, appending\n+     the filename will prevent conflicts with a resolver function from\n+     another module which is based on the same version name.  */\n+  resolver_name = make_name (default_decl, \"resolver\", is_uniq);\n+\n+  /* The resolver function should return a (void *). */\n+  type = build_function_type_list (ptr_type_node, NULL_TREE);\n+\n+  decl = build_fn_decl (resolver_name, type);\n+  decl_name = get_identifier (resolver_name);\n+  SET_DECL_ASSEMBLER_NAME (decl, decl_name);\n+\n+  DECL_NAME (decl) = decl_name;\n+  TREE_USED (decl) = 1;\n+  DECL_ARTIFICIAL (decl) = 1;\n+  DECL_IGNORED_P (decl) = 0;\n+  /* IFUNC resolvers have to be externally visible.  */\n+  TREE_PUBLIC (decl) = 1;\n+  DECL_UNINLINABLE (decl) = 0;\n+\n+  /* Resolver is not external, body is generated.  */\n+  DECL_EXTERNAL (decl) = 0;\n+  DECL_EXTERNAL (dispatch_decl) = 0;\n+\n+  DECL_CONTEXT (decl) = NULL_TREE;\n+  DECL_INITIAL (decl) = make_node (BLOCK);\n+  DECL_STATIC_CONSTRUCTOR (decl) = 0;\n+\n+  if (DECL_COMDAT_GROUP (default_decl)\n+      || TREE_PUBLIC (default_decl))\n+    {\n+      /* In this case, each translation unit with a call to this\n+\t versioned function will put out a resolver.  Ensure it\n+\t is comdat to keep just one copy.  */\n+      DECL_COMDAT (decl) = 1;\n+      make_decl_one_only (decl, DECL_ASSEMBLER_NAME (decl));\n+    }\n+  /* Build result decl and add to function_decl. */\n+  t = build_decl (UNKNOWN_LOCATION, RESULT_DECL, NULL_TREE, ptr_type_node);\n+  DECL_ARTIFICIAL (t) = 1;\n+  DECL_IGNORED_P (t) = 1;\n+  DECL_RESULT (decl) = t;\n+\n+  gimplify_function_tree (decl);\n+  push_cfun (DECL_STRUCT_FUNCTION (decl));\n+  *empty_bb = init_lowered_empty_function (decl, false);\n+\n+  cgraph_add_new_function (decl, true);\n+  cgraph_call_function_insertion_hooks (cgraph_get_create_node (decl));\n+\n+  pop_cfun ();\n+\n+  gcc_assert (dispatch_decl != NULL);\n+  /* Mark dispatch_decl as \"ifunc\" with resolver as resolver_name.  */\n+  DECL_ATTRIBUTES (dispatch_decl) \n+    = make_attribute (\"ifunc\", resolver_name, DECL_ATTRIBUTES (dispatch_decl));\n+\n+  /* Create the alias for dispatch to resolver here.  */\n+  /*cgraph_create_function_alias (dispatch_decl, decl);*/\n+  cgraph_same_body_alias (NULL, dispatch_decl, decl);\n+  return decl;\n+}\n+\n+/* Generate the dispatching code body to dispatch multi-versioned function\n+   DECL.  The target hook is called to process the \"target\" attributes and\n+   provide the code to dispatch the right function at run-time.  NODE points\n+   to the dispatcher decl whose body will be created.  */\n+\n+static tree \n+ix86_generate_version_dispatcher_body (void *node_p)\n+{\n+  tree resolver_decl;\n+  basic_block empty_bb;\n+  VEC (tree, heap) *fn_ver_vec = NULL;\n+  tree default_ver_decl;\n+  struct cgraph_node *versn;\n+  struct cgraph_node *node;\n+\n+  struct cgraph_function_version_info *node_version_info = NULL;\n+  struct cgraph_function_version_info *versn_info = NULL;\n+\n+  node = (cgraph_node *)node_p;\n+\n+  node_version_info = get_cgraph_node_version (node);\n+  gcc_assert (node->dispatcher_function\n+\t      && node_version_info != NULL);\n+\n+  if (node_version_info->dispatcher_resolver)\n+    return node_version_info->dispatcher_resolver;\n+\n+  /* The first version in the chain corresponds to the default version.  */\n+  default_ver_decl = node_version_info->next->this_node->symbol.decl;\n+\n+  /* node is going to be an alias, so remove the finalized bit.  */\n+  node->local.finalized = false;\n+\n+  resolver_decl = make_resolver_func (default_ver_decl,\n+\t\t\t\t      node->symbol.decl, &empty_bb);\n+\n+  node_version_info->dispatcher_resolver = resolver_decl;\n+\n+  push_cfun (DECL_STRUCT_FUNCTION (resolver_decl));\n+\n+  fn_ver_vec = VEC_alloc (tree, heap, 2);\n+\n+  for (versn_info = node_version_info->next; versn_info;\n+       versn_info = versn_info->next)\n+    {\n+      versn = versn_info->this_node;\n+      /* Check for virtual functions here again, as by this time it should\n+\t have been determined if this function needs a vtable index or\n+\t not.  This happens for methods in derived classes that override\n+\t virtual methods in base classes but are not explicitly marked as\n+\t virtual.  */\n+      if (DECL_VINDEX (versn->symbol.decl))\n+        error_at (DECL_SOURCE_LOCATION (versn->symbol.decl),\n+\t\t  \"Virtual function multiversioning not supported\");\n+      VEC_safe_push (tree, heap, fn_ver_vec, versn->symbol.decl);\n+    }\n+\n+  dispatch_function_versions (resolver_decl, fn_ver_vec, &empty_bb);\n+\n+  rebuild_cgraph_edges (); \n+  pop_cfun ();\n+  return resolver_decl;\n+}\n /* This builds the processor_model struct type defined in\n    libgcc/config/i386/cpuinfo.c  */\n \n@@ -28651,6 +29614,8 @@ fold_builtin_cpu (tree fndecl, tree *args)\n     {\n       tree ref;\n       tree field;\n+      tree final;\n+\n       unsigned int field_val = 0;\n       unsigned int NUM_ARCH_NAMES\n \t= sizeof (arch_names_table) / sizeof (struct _arch_names_table);\n@@ -28690,14 +29655,17 @@ fold_builtin_cpu (tree fndecl, tree *args)\n \t\t     field, NULL_TREE);\n \n       /* Check the value.  */\n-      return build2 (EQ_EXPR, unsigned_type_node, ref,\n-\t\t     build_int_cstu (unsigned_type_node, field_val));\n+      final = build2 (EQ_EXPR, unsigned_type_node, ref,\n+\t\t      build_int_cstu (unsigned_type_node, field_val));\n+      return build1 (CONVERT_EXPR, integer_type_node, final);\n     }\n   else if (fn_code == IX86_BUILTIN_CPU_SUPPORTS)\n     {\n       tree ref;\n       tree array_elt;\n       tree field;\n+      tree final;\n+\n       unsigned int field_val = 0;\n       unsigned int NUM_ISA_NAMES\n \t= sizeof (isa_names_table) / sizeof (struct _isa_names_table);\n@@ -28729,8 +29697,9 @@ fold_builtin_cpu (tree fndecl, tree *args)\n \n       field_val = (1 << isa_names_table[i].feature);\n       /* Return __cpu_model.__cpu_features[0] & field_val  */\n-      return build2 (BIT_AND_EXPR, unsigned_type_node, array_elt,\n-\t\t     build_int_cstu (unsigned_type_node, field_val));\n+      final = build2 (BIT_AND_EXPR, unsigned_type_node, array_elt,\n+\t\t      build_int_cstu (unsigned_type_node, field_val));\n+      return build1 (CONVERT_EXPR, integer_type_node, final);\n     }\n   gcc_unreachable ();\n }\n@@ -41218,6 +42187,9 @@ ix86_memmodel_check (unsigned HOST_WIDE_INT val)\n #undef TARGET_PROFILE_BEFORE_PROLOGUE\n #define TARGET_PROFILE_BEFORE_PROLOGUE ix86_profile_before_prologue\n \n+#undef TARGET_MANGLE_DECL_ASSEMBLER_NAME\n+#define TARGET_MANGLE_DECL_ASSEMBLER_NAME ix86_mangle_decl_assembler_name\n+\n #undef TARGET_ASM_UNALIGNED_HI_OP\n #define TARGET_ASM_UNALIGNED_HI_OP TARGET_ASM_ALIGNED_HI_OP\n #undef TARGET_ASM_UNALIGNED_SI_OP\n@@ -41311,6 +42283,17 @@ ix86_memmodel_check (unsigned HOST_WIDE_INT val)\n #undef TARGET_FOLD_BUILTIN\n #define TARGET_FOLD_BUILTIN ix86_fold_builtin\n \n+#undef TARGET_COMPARE_VERSION_PRIORITY\n+#define TARGET_COMPARE_VERSION_PRIORITY ix86_compare_version_priority\n+\n+#undef TARGET_GENERATE_VERSION_DISPATCHER_BODY\n+#define TARGET_GENERATE_VERSION_DISPATCHER_BODY \\\n+  ix86_generate_version_dispatcher_body\n+\n+#undef TARGET_GET_FUNCTION_VERSIONS_DISPATCHER\n+#define TARGET_GET_FUNCTION_VERSIONS_DISPATCHER \\\n+  ix86_get_function_versions_dispatcher\n+\n #undef TARGET_ENUM_VA_LIST_P\n #define TARGET_ENUM_VA_LIST_P ix86_enum_va_list\n \n@@ -41451,6 +42434,9 @@ ix86_memmodel_check (unsigned HOST_WIDE_INT val)\n #undef TARGET_OPTION_PRINT\n #define TARGET_OPTION_PRINT ix86_function_specific_print\n \n+#undef TARGET_OPTION_FUNCTION_VERSIONS\n+#define TARGET_OPTION_FUNCTION_VERSIONS ix86_function_versions\n+\n #undef TARGET_CAN_INLINE_P\n #define TARGET_CAN_INLINE_P ix86_can_inline_p\n "}, {"sha": "5e73e1bc0c7872758e0986a251667da4d0f25d9f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3649b9b791c54f35a8bfb5540711dc4112acce7d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3649b9b791c54f35a8bfb5540711dc4112acce7d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=3649b9b791c54f35a8bfb5540711dc4112acce7d", "patch": "@@ -1,3 +1,22 @@\n+2012-11-05  Sriraman Tallam  <tmsriram@google.com>\n+\n+\t* class.c (add_method): Change assembler names of function versions.\n+\t(mark_versions_used): New static function.\n+\t(resolve_address_of_overloaded_function): Create dispatcher decl and\n+\treturn address of dispatcher instead.\n+\t* decl.c (decls_match): Make decls unmatched for versioned\n+\tfunctions.\n+\t(duplicate_decls): Remove ambiguity for versioned functions.\n+\tDelete versioned function data for merged decls. \n+\t* decl2.c (check_classfn): Check attributes of versioned functions\n+\tfor match.\n+\t* call.c (get_function_version_dispatcher): New function.\n+\t(mark_versions_used): New static function.\n+\t(build_over_call): Make calls to multiversioned functions\n+\tto call the dispatcher.\n+\t(joust): For calls to multi-versioned functions, make the most\n+\tspecialized function version win.\n+\n 2012-10-31  Lawrence Crowl  <crowl@google.com>\n \n \t* decl2.c (var_finalized_p): Rename varpool_node to"}, {"sha": "4373bce69313f276dce2775e6abbc7a00976b481", "filename": "gcc/cp/call.c", "status": "modified", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3649b9b791c54f35a8bfb5540711dc4112acce7d/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3649b9b791c54f35a8bfb5540711dc4112acce7d/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=3649b9b791c54f35a8bfb5540711dc4112acce7d", "patch": "@@ -40,6 +40,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"langhooks.h\"\n #include \"c-family/c-objc.h\"\n #include \"timevar.h\"\n+#include \"cgraph.h\"\n \n /* The various kinds of conversion.  */\n \n@@ -6514,6 +6515,63 @@ magic_varargs_p (tree fn)\n   return false;\n }\n \n+/* Returns the decl of the dispatcher function if FN is a function version.  */\n+\n+static tree\n+get_function_version_dispatcher (tree fn)\n+{\n+  tree dispatcher_decl = NULL;\n+\n+  gcc_assert (TREE_CODE (fn) == FUNCTION_DECL\n+\t      && DECL_FUNCTION_VERSIONED (fn));\n+\n+  gcc_assert (targetm.get_function_versions_dispatcher);\n+  dispatcher_decl = targetm.get_function_versions_dispatcher (fn);\n+\n+  if (dispatcher_decl == NULL)\n+    {\n+      error_at (input_location, \"Call to multiversioned function\"\n+                \" without a default is not allowed\");\n+      return NULL;\n+    }\n+\n+  retrofit_lang_decl (dispatcher_decl);\n+  gcc_assert (dispatcher_decl != NULL);\n+  return dispatcher_decl;\n+}\n+\n+/* fn is a function version dispatcher that is marked used. Mark all the \n+   semantically identical function versions it will dispatch as used.  */\n+\n+static void\n+mark_versions_used (tree fn)\n+{\n+  struct cgraph_node *node;\n+  struct cgraph_function_version_info *node_v;\n+  struct cgraph_function_version_info *it_v;\n+\n+  gcc_assert (TREE_CODE (fn) == FUNCTION_DECL);\n+\n+  node = cgraph_get_node (fn);\n+  if (node == NULL)\n+    return;\n+\n+  gcc_assert (node->dispatcher_function);\n+\n+  node_v = get_cgraph_node_version (node);\n+  if (node_v == NULL)\n+    return;\n+\n+  /* All semantically identical versions are chained.  Traverse and mark each\n+     one of them as used.  */\n+  it_v = node_v->next;\n+  while (it_v != NULL)\n+    {\n+      mark_used (it_v->this_node->symbol.decl);\n+      it_v = it_v->next;\n+    }\n+}\n+\n /* Subroutine of the various build_*_call functions.  Overload resolution\n    has chosen a winning candidate CAND; build up a CALL_EXPR accordingly.\n    ARGS is a TREE_LIST of the unconverted arguments to the call.  FLAGS is a\n@@ -6963,6 +7021,22 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n     return fold_convert (void_type_node, argarray[0]);\n   /* FIXME handle trivial default constructor, too.  */\n \n+  /* For calls to a multi-versioned function, overload resolution\n+     returns the function with the highest target priority, that is,\n+     the version that will checked for dispatching first.  If this\n+     version is inlinable, a direct call to this version can be made\n+     otherwise the call should go through the dispatcher.  */\n+\n+  if (DECL_FUNCTION_VERSIONED (fn)\n+      && !targetm.target_option.can_inline_p (current_function_decl, fn))\n+    {\n+      fn = get_function_version_dispatcher (fn);\n+      if (fn == NULL)\n+\treturn NULL;\n+      if (!already_used)\n+\tmark_versions_used (fn);\n+    }\n+\n   if (!already_used)\n     mark_used (fn);\n \n@@ -8481,6 +8555,38 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn,\n \t}\n     }\n \n+  /* For candidates of a multi-versioned function,  make the version with\n+     the highest priority win.  This version will be checked for dispatching\n+     first.  If this version can be inlined into the caller, the front-end\n+     will simply make a direct call to this function.  */\n+\n+  if (TREE_CODE (cand1->fn) == FUNCTION_DECL\n+      && DECL_FUNCTION_VERSIONED (cand1->fn)\n+      && TREE_CODE (cand2->fn) == FUNCTION_DECL\n+      && DECL_FUNCTION_VERSIONED (cand2->fn))\n+    {\n+      tree f1 = TREE_TYPE (cand1->fn);\n+      tree f2 = TREE_TYPE (cand2->fn);\n+      tree p1 = TYPE_ARG_TYPES (f1);\n+      tree p2 = TYPE_ARG_TYPES (f2);\n+     \n+      /* Check if cand1->fn and cand2->fn are versions of the same function.  It\n+         is possible that cand1->fn and cand2->fn are function versions but of\n+         different functions.  Check types to see if they are versions of the same\n+         function.  */\n+      if (compparms (p1, p2)\n+\t  && same_type_p (TREE_TYPE (f1), TREE_TYPE (f2)))\n+\t{\n+\t  /* Always make the version with the higher priority, more\n+\t     specialized, win.  */\n+\t  gcc_assert (targetm.compare_version_priority);\n+\t  if (targetm.compare_version_priority (cand1->fn, cand2->fn) >= 0)\n+\t    return 1;\n+\t  else\n+\t    return -1;\n+\t}\n+    }\n+\n   /* If the two function declarations represent the same function (this can\n      happen with declarations in multiple scopes and arg-dependent lookup),\n      arbitrarily choose one.  But first make sure the default args we're"}, {"sha": "a91e63a6301920ffc53232527f3d9c0aed0b7046", "filename": "gcc/cp/class.c", "status": "modified", "additions": 101, "deletions": 4, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3649b9b791c54f35a8bfb5540711dc4112acce7d/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3649b9b791c54f35a8bfb5540711dc4112acce7d/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=3649b9b791c54f35a8bfb5540711dc4112acce7d", "patch": "@@ -1087,6 +1087,35 @@ add_method (tree type, tree method, tree using_decl)\n \t      || same_type_p (TREE_TYPE (fn_type),\n \t\t\t      TREE_TYPE (method_type))))\n \t{\n+\t  /* For function versions, their parms and types match\n+\t     but they are not duplicates.  Record function versions\n+\t     as and when they are found.  extern \"C\" functions are\n+\t     not treated as versions.  */\n+\t  if (TREE_CODE (fn) == FUNCTION_DECL\n+\t      && TREE_CODE (method) == FUNCTION_DECL\n+\t      && !DECL_EXTERN_C_P (fn)\n+\t      && !DECL_EXTERN_C_P (method)\n+\t      && (DECL_FUNCTION_SPECIFIC_TARGET (fn)\n+\t\t  || DECL_FUNCTION_SPECIFIC_TARGET (method))\n+\t      && targetm.target_option.function_versions (fn, method))\n+ \t    {\n+\t      /* Mark functions as versions if necessary.  Modify the mangled\n+\t\t decl name if necessary.  */\n+\t      if (!DECL_FUNCTION_VERSIONED (fn))\n+\t\t{\n+\t\t  DECL_FUNCTION_VERSIONED (fn) = 1;\n+\t\t  if (DECL_ASSEMBLER_NAME_SET_P (fn))\n+\t\t    mangle_decl (fn);\n+\t\t}\n+\t      if (!DECL_FUNCTION_VERSIONED (method))\n+\t\t{\n+\t\t  DECL_FUNCTION_VERSIONED (method) = 1;\n+\t\t  if (DECL_ASSEMBLER_NAME_SET_P (method))\n+\t\t    mangle_decl (method);\n+\t\t}\n+\t      record_function_versions (fn, method);\n+\t      continue;\n+\t    }\n \t  if (DECL_INHERITED_CTOR_BASE (method))\n \t    {\n \t      if (DECL_INHERITED_CTOR_BASE (fn))\n@@ -6951,6 +6980,38 @@ pop_lang_context (void)\n {\n   current_lang_name = VEC_pop (tree, current_lang_base);\n }\n+\n+/* fn is a function version dispatcher that is marked used. Mark all the \n+   semantically identical function versions it will dispatch as used.  */\n+\n+static void\n+mark_versions_used (tree fn)\n+{\n+  struct cgraph_node *node;\n+  struct cgraph_function_version_info *node_v;\n+  struct cgraph_function_version_info *it_v;\n+\n+  gcc_assert (TREE_CODE (fn) == FUNCTION_DECL);\n+\n+  node = cgraph_get_node (fn);\n+  if (node == NULL)\n+    return;\n+\n+  gcc_assert (node->dispatcher_function);\n+\n+  node_v = get_cgraph_node_version (node);\n+  if (node_v == NULL)\n+    return;\n+\n+  /* All semantically identical versions are chained.  Traverse and mark each\n+     one of them as used.  */\n+  it_v = node_v->next;\n+  while (it_v != NULL)\n+    {\n+      mark_used (it_v->this_node->symbol.decl);\n+      it_v = it_v->next;\n+    }\n+}\n \f\n /* Type instantiation routines.  */\n \n@@ -7162,12 +7223,26 @@ resolve_address_of_overloaded_function (tree target_type,\n     {\n       /* There were too many matches.  First check if they're all\n \t the same function.  */\n-      tree match;\n+      tree match = NULL_TREE;\n \n       fn = TREE_PURPOSE (matches);\n-      for (match = TREE_CHAIN (matches); match; match = TREE_CHAIN (match))\n-\tif (!decls_match (fn, TREE_PURPOSE (match)))\n-\t  break;\n+\n+      /* For multi-versioned functions, more than one match is just fine.\n+\t Call decls_match to make sure they are different because they are\n+\t versioned.  */\n+      if (DECL_FUNCTION_VERSIONED (fn))\n+\t{\n+          for (match = TREE_CHAIN (matches); match; match = TREE_CHAIN (match))\n+  \t    if (!DECL_FUNCTION_VERSIONED (TREE_PURPOSE (match))\n+\t        || decls_match (fn, TREE_PURPOSE (match)))\n+\t      break;\n+\t}\n+      else\n+\t{\n+          for (match = TREE_CHAIN (matches); match; match = TREE_CHAIN (match))\n+  \t    if (!decls_match (fn, TREE_PURPOSE (match)))\n+\t      break;\n+\t}\n \n       if (match)\n \t{\n@@ -7208,6 +7283,28 @@ resolve_address_of_overloaded_function (tree target_type,\n \t}\n     }\n \n+  /* If a pointer to a function that is multi-versioned is requested, the\n+     pointer to the dispatcher function is returned instead.  This works\n+     well because indirectly calling the function will dispatch the right\n+     function version at run-time.  */\n+  if (DECL_FUNCTION_VERSIONED (fn))\n+    {\n+      tree dispatcher_decl = NULL;\n+      gcc_assert (targetm.get_function_versions_dispatcher);\n+      dispatcher_decl = targetm.get_function_versions_dispatcher (fn);\n+      if (!dispatcher_decl)\n+\t{\n+\t  error_at (input_location, \"Pointer to a multiversioned function\"\n+\t\t    \" without a default is not allowed\");\n+\t  return error_mark_node;\n+\t}\n+      retrofit_lang_decl (dispatcher_decl);\n+      fn = dispatcher_decl;\n+      /* Mark all the versions corresponding to the dispatcher as used.  */\n+      if (!(flags & tf_conv))\n+\tmark_versions_used (fn);\n+    }\n+\n   /* If we're doing overload resolution purely for the purpose of\n      determining conversion sequences, we should not consider the\n      function used.  If this conversion sequence is selected, the"}, {"sha": "f8f9d4f2391c13c34050c71c262ed7bcc0e7ed21", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 45, "deletions": 1, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3649b9b791c54f35a8bfb5540711dc4112acce7d/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3649b9b791c54f35a8bfb5540711dc4112acce7d/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=3649b9b791c54f35a8bfb5540711dc4112acce7d", "patch": "@@ -53,6 +53,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"pointer-set.h\"\n #include \"splay-tree.h\"\n #include \"plugin.h\"\n+#include \"cgraph.h\"\n \n /* Possible cases of bad specifiers type used by bad_specifiers. */\n enum bad_spec_place {\n@@ -981,6 +982,36 @@ decls_match (tree newdecl, tree olddecl)\n       if (t1 != t2)\n \treturn 0;\n \n+      /* The decls dont match if they correspond to two different versions\n+\t of the same function.   Disallow extern \"C\" functions to be\n+\t versions for now.  */\n+      if (compparms (p1, p2)\n+\t  && same_type_p (TREE_TYPE (f1), TREE_TYPE (f2))\n+\t  && !DECL_EXTERN_C_P (newdecl)\n+\t  && !DECL_EXTERN_C_P (olddecl)\n+\t  && targetm.target_option.function_versions (newdecl, olddecl))\n+\t{\n+\t  /* Mark functions as versions if necessary.  Modify the mangled decl\n+\t     name if necessary.  */\n+\t  if (DECL_FUNCTION_VERSIONED (newdecl)\n+\t      && DECL_FUNCTION_VERSIONED (olddecl))\n+\t    return 0;\n+\t  if (!DECL_FUNCTION_VERSIONED (newdecl))\n+\t    {\n+\t      DECL_FUNCTION_VERSIONED (newdecl) = 1;\n+\t      if (DECL_ASSEMBLER_NAME_SET_P (newdecl))\n+\t        mangle_decl (newdecl);\n+\t    }\n+\t  if (!DECL_FUNCTION_VERSIONED (olddecl))\n+\t    {\n+\t      DECL_FUNCTION_VERSIONED (olddecl) = 1;\n+\t      if (DECL_ASSEMBLER_NAME_SET_P (olddecl))\n+\t       mangle_decl (olddecl);\n+\t    }\n+\t  record_function_versions (olddecl, newdecl);\n+\t  return 0;\n+\t}\n+\n       if (CP_DECL_CONTEXT (newdecl) != CP_DECL_CONTEXT (olddecl)\n \t  && ! (DECL_EXTERN_C_P (newdecl)\n \t\t&& DECL_EXTERN_C_P (olddecl)))\n@@ -1499,7 +1530,11 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n \t      error (\"previous declaration %q+#D here\", olddecl);\n \t      return NULL_TREE;\n \t    }\n-\t  else if (compparms (TYPE_ARG_TYPES (TREE_TYPE (newdecl)),\n+\t  /* For function versions, params and types match, but they\n+\t     are not ambiguous.  */\n+\t  else if ((!DECL_FUNCTION_VERSIONED (newdecl)\n+\t\t    && !DECL_FUNCTION_VERSIONED (olddecl))\n+\t\t   && compparms (TYPE_ARG_TYPES (TREE_TYPE (newdecl)),\n \t\t\t      TYPE_ARG_TYPES (TREE_TYPE (olddecl))))\n \t    {\n \t      error (\"new declaration %q#D\", newdecl);\n@@ -2272,6 +2307,15 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n   else if (DECL_PRESERVE_P (newdecl))\n     DECL_PRESERVE_P (olddecl) = 1;\n \n+  /* If the olddecl is a version, so is the newdecl.  */\n+  if (TREE_CODE (newdecl) == FUNCTION_DECL\n+      && DECL_FUNCTION_VERSIONED (olddecl))\n+    {\n+      DECL_FUNCTION_VERSIONED (newdecl) = 1;\n+      /* newdecl will be purged and is no longer a version.  */\n+      delete_function_version (newdecl);\n+    }\n+\n   if (TREE_CODE (newdecl) == FUNCTION_DECL)\n     {\n       int function_size;"}, {"sha": "90ee16bde969619994a78ce58f841303331742a8", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3649b9b791c54f35a8bfb5540711dc4112acce7d/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3649b9b791c54f35a8bfb5540711dc4112acce7d/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=3649b9b791c54f35a8bfb5540711dc4112acce7d", "patch": "@@ -674,9 +674,13 @@ check_classfn (tree ctype, tree function, tree template_parms)\n \t  if (is_template != (TREE_CODE (fndecl) == TEMPLATE_DECL))\n \t    continue;\n \n+\t  /* While finding a match, same types and params are not enough\n+\t     if the function is versioned.  Also check version (\"target\")\n+\t     attributes.  */\n \t  if (same_type_p (TREE_TYPE (TREE_TYPE (function)),\n \t\t\t   TREE_TYPE (TREE_TYPE (fndecl)))\n \t      && compparms (p1, p2)\n+\t      && !targetm.target_option.function_versions (function, fndecl)\n \t      && (!is_template\n \t\t  || comp_template_parms (template_parms,\n \t\t\t\t\t  DECL_TEMPLATE_PARMS (fndecl)))"}, {"sha": "dbf6c20b8ddc71f7da8f199ac28587e230eec55d", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3649b9b791c54f35a8bfb5540711dc4112acce7d/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3649b9b791c54f35a8bfb5540711dc4112acce7d/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=3649b9b791c54f35a8bfb5540711dc4112acce7d", "patch": "@@ -9929,6 +9929,14 @@ changed via the optimize attribute or pragma, see\n @code{TARGET_OVERRIDE_OPTIONS_AFTER_CHANGE}\n @end deftypefn\n \n+@deftypefn {Target Hook} bool TARGET_OPTION_FUNCTION_VERSIONS (tree @var{decl1}, tree @var{decl2})\n+This target hook returns @code{true} if @var{DECL1} and @var{DECL2} are\n+versions of the same function.  @var{DECL1} and @var{DECL2} are function\n+versions if and only if they have the same function signature and\n+different target specific attributes, that is, they are compiled for\n+different target machines.\n+@end deftypefn\n+\n @deftypefn {Target Hook} bool TARGET_CAN_INLINE_P (tree @var{caller}, tree @var{callee})\n This target hook returns @code{false} if the @var{caller} function\n cannot inline @var{callee}, based on target specific information.  By\n@@ -10952,6 +10960,29 @@ The result is another tree containing a simplified expression for the\n call's result.  If @var{ignore} is true the value will be ignored.\n @end deftypefn\n \n+@deftypefn {Target Hook} int TARGET_COMPARE_VERSION_PRIORITY (tree @var{decl1}, tree @var{decl2})\n+This hook is used to compare the target attributes in two functions to\n+determine which function's features get higher priority.  This is used\n+during function multi-versioning to figure out the order in which two\n+versions must be dispatched.  A function version with a higher priority\n+is checked for dispatching earlier.  @var{decl1} and @var{decl2} are\n+ the two function decls that will be compared.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} tree TARGET_GET_FUNCTION_VERSIONS_DISPATCHER (void *@var{decl})\n+This hook is used to get the dispatcher function for a set of function\n+versions.  The dispatcher function is called to invoke the right function\n+version at run-time. @var{decl} is one version from a set of semantically\n+identical versions.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} tree TARGET_GENERATE_VERSION_DISPATCHER_BODY (void *@var{arg})\n+This hook is used to generate the dispatcher logic to invoke the right\n+function version at run-time for a given set of function versions.\n+@var{arg} points to the callgraph node of the dispatcher function whose\n+body must be generated.\n+@end deftypefn\n+\n @deftypefn {Target Hook} {const char *} TARGET_INVALID_WITHIN_DOLOOP (const_rtx @var{insn})\n \n Take an instruction in @var{insn} and return NULL if it is valid within a"}, {"sha": "575cc7322af9dcf58fedf1b34db295b595281835", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3649b9b791c54f35a8bfb5540711dc4112acce7d/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3649b9b791c54f35a8bfb5540711dc4112acce7d/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=3649b9b791c54f35a8bfb5540711dc4112acce7d", "patch": "@@ -9790,6 +9790,14 @@ changed via the optimize attribute or pragma, see\n @code{TARGET_OVERRIDE_OPTIONS_AFTER_CHANGE}\n @end deftypefn\n \n+@hook TARGET_OPTION_FUNCTION_VERSIONS\n+This target hook returns @code{true} if @var{DECL1} and @var{DECL2} are\n+versions of the same function.  @var{DECL1} and @var{DECL2} are function\n+versions if and only if they have the same function signature and\n+different target specific attributes, that is, they are compiled for\n+different target machines.\n+@end deftypefn\n+\n @hook TARGET_CAN_INLINE_P\n This target hook returns @code{false} if the @var{caller} function\n cannot inline @var{callee}, based on target specific information.  By\n@@ -10798,6 +10806,29 @@ The result is another tree containing a simplified expression for the\n call's result.  If @var{ignore} is true the value will be ignored.\n @end deftypefn\n \n+@hook TARGET_COMPARE_VERSION_PRIORITY\n+This hook is used to compare the target attributes in two functions to\n+determine which function's features get higher priority.  This is used\n+during function multi-versioning to figure out the order in which two\n+versions must be dispatched.  A function version with a higher priority\n+is checked for dispatching earlier.  @var{decl1} and @var{decl2} are\n+ the two function decls that will be compared.\n+@end deftypefn\n+\n+@hook TARGET_GET_FUNCTION_VERSIONS_DISPATCHER\n+This hook is used to get the dispatcher function for a set of function\n+versions.  The dispatcher function is called to invoke the right function\n+version at run-time. @var{decl} is one version from a set of semantically\n+identical versions.\n+@end deftypefn\n+\n+@hook TARGET_GENERATE_VERSION_DISPATCHER_BODY\n+This hook is used to generate the dispatcher logic to invoke the right\n+function version at run-time for a given set of function versions.\n+@var{arg} points to the callgraph node of the dispatcher function whose\n+body must be generated.\n+@end deftypefn\n+\n @hook TARGET_INVALID_WITHIN_DOLOOP\n \n Take an instruction in @var{insn} and return NULL if it is valid within a"}, {"sha": "2801aea5a17dc31c096f5ec7a83209bb26d308cf", "filename": "gcc/target.def", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3649b9b791c54f35a8bfb5540711dc4112acce7d/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3649b9b791c54f35a8bfb5540711dc4112acce7d/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=3649b9b791c54f35a8bfb5540711dc4112acce7d", "patch": "@@ -1298,6 +1298,37 @@ DEFHOOK\n  tree, (tree fndecl, int n_args, tree *argp, bool ignore),\n  hook_tree_tree_int_treep_bool_null)\n \n+/* Target hook is used to compare the target attributes in two functions to\n+   determine which function's features get higher priority.  This is used\n+   during function multi-versioning to figure out the order in which two\n+   versions must be dispatched.  A function version with a higher priority\n+   is checked for dispatching earlier.  DECL1 and DECL2 are\n+   the two function decls that will be compared. It returns positive value\n+   if DECL1 is higher priority,  negative value if DECL2 is higher priority\n+   and 0 if they are the same. */\n+DEFHOOK\n+(compare_version_priority,\n+ \"\",\n+ int, (tree decl1, tree decl2), NULL)\n+\n+/*  Target hook is used to generate the dispatcher logic to invoke the right\n+    function version at run-time for a given set of function versions.\n+    ARG points to the callgraph node of the dispatcher function whose body\n+    must be generated.  */\n+DEFHOOK\n+(generate_version_dispatcher_body,\n+ \"\",\n+ tree, (void *arg), NULL) \n+\n+/* Target hook is used to get the dispatcher function for a set of function\n+   versions.  The dispatcher function is called to invoke the right function\n+   version at run-time.  DECL is one version from a set of semantically\n+   identical versions.  */\n+DEFHOOK\n+(get_function_versions_dispatcher,\n+ \"\",\n+ tree, (void *decl), NULL)\n+\n /* Returns a code for a target-specific builtin that implements\n    reciprocal of the function, or NULL_TREE if not available.  */\n DEFHOOK\n@@ -2774,6 +2805,16 @@ DEFHOOK\n  void, (void),\n  hook_void_void)\n \n+/* This function returns true if DECL1 and DECL2 are versions of the same\n+   function.  DECL1 and DECL2 are function versions if and only if they\n+   have the same function signature and different target specific attributes,\n+   that is, they are compiled for different target machines.  */\n+DEFHOOK\n+(function_versions,\n+ \"\",\n+ bool, (tree decl1, tree decl2),\n+ hook_bool_tree_tree_false)\n+\n /* Function to determine if one function can inline another function.  */\n #undef HOOK_PREFIX\n #define HOOK_PREFIX \"TARGET_\""}, {"sha": "e44a637b1eecc020cd4f782625166c265ea90aa2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3649b9b791c54f35a8bfb5540711dc4112acce7d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3649b9b791c54f35a8bfb5540711dc4112acce7d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3649b9b791c54f35a8bfb5540711dc4112acce7d", "patch": "@@ -1,3 +1,12 @@\n+2012-11-05  Sriraman Tallam  <tmsriram@google.com>\n+\n+\t* testsuite/g++.dg/mv1.C: New test.\n+\t* testsuite/g++.dg/mv2.C: New test.\n+\t* testsuite/g++.dg/mv3.C: New test.\n+\t* testsuite/g++.dg/mv4.C: New test.\n+\t* testsuite/g++.dg/mv5.C: New test.\n+\t* testsuite/g++.dg/mv6.C: New test.\n+\n 2012-11-05  Hans-Peter Nilsson  <hp@axis.com>\n \n \tPR testsuite/55186"}, {"sha": "676e48577afd89eecd129962f902683c707c22fd", "filename": "gcc/testsuite/g++.dg/mv1.C", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3649b9b791c54f35a8bfb5540711dc4112acce7d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmv1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3649b9b791c54f35a8bfb5540711dc4112acce7d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmv1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmv1.C?ref=3649b9b791c54f35a8bfb5540711dc4112acce7d", "patch": "@@ -0,0 +1,130 @@\n+/* Test case to check if Multiversioning works.  */\n+/* { dg-do run { target i?86-*-* x86_64-*-* } } */\n+/* { dg-require-ifunc \"\" }  */\n+/* { dg-options \"-O2 -fPIC -mno-avx -mno-popcnt\" } */\n+\n+#include <assert.h>\n+\n+/* Default version.  */\n+int foo ();\n+/* The other versions of foo.  Mix up the ordering and \n+   check if the dispatching does it in the order of priority. */\n+/* Check combination of target attributes.  */\n+int foo () __attribute__ ((target(\"arch=corei7,popcnt\")));\n+/* The target operands in this declaration and the definition are re-ordered.\n+   This should still work.  */\n+int foo () __attribute__ ((target(\"ssse3,avx2\")));\n+\n+/* Check for all target attributes for which dispatchers are available.  */\n+/* Check arch= */\n+int foo () __attribute__((target(\"arch=core2\")));\n+int foo () __attribute__((target(\"arch=corei7\")));\n+int foo () __attribute__((target(\"arch=atom\")));\n+/* Check ISAs  */\n+int foo () __attribute__((target(\"avx\")));\n+int foo () __attribute__ ((target(\"arch=core2,sse4.2\")));\n+/* Check more arch=.  */\n+int foo () __attribute__((target(\"arch=amdfam10\")));\n+int foo () __attribute__((target(\"arch=bdver1\")));\n+int foo () __attribute__((target(\"arch=bdver2\")));\n+\n+int (*p)() = &foo;\n+int main ()\n+{\n+  int val = foo ();\n+  assert (val ==  (*p)());\n+\n+  /* Check in the exact same order in which the dispatching\n+     is expected to happen.  */\n+  if (__builtin_cpu_is (\"bdver1\"))\n+    assert (val == 1);\n+  else if (__builtin_cpu_is (\"bdver2\"))\n+    assert (val == 2);\n+  else if (__builtin_cpu_supports (\"avx2\")\n+\t   && __builtin_cpu_supports (\"ssse3\"))\n+    assert (val == 3);\n+  else if (__builtin_cpu_supports (\"avx\"))\n+    assert (val == 4);\n+  else if (__builtin_cpu_is (\"corei7\")\n+\t   && __builtin_cpu_supports (\"popcnt\"))\n+    assert (val == 5);\n+  else if (__builtin_cpu_is (\"corei7\"))\n+    assert (val == 6);\n+  else if (__builtin_cpu_is (\"amdfam10h\"))\n+    assert (val == 7);\n+  else if (__builtin_cpu_is (\"core2\")\n+\t   && __builtin_cpu_supports (\"sse4.2\"))\n+    assert (val == 8);\n+  else if (__builtin_cpu_is (\"core2\"))\n+    assert (val == 9);\n+  else if (__builtin_cpu_is (\"atom\"))\n+    assert (val == 10);\n+  else\n+    assert (val == 0);\n+  \n+  return 0;\n+}\n+\n+int foo ()\n+{\n+  return 0;\n+}\n+\n+int __attribute__ ((target(\"arch=corei7,popcnt\")))\n+foo ()\n+{\n+  return 5;\n+}\n+int __attribute__ ((target(\"avx2,ssse3\")))\n+foo ()\n+{\n+  return 3;\n+}\n+\n+int __attribute__ ((target(\"arch=core2\")))\n+foo ()\n+{\n+  return 9;\n+}\n+\n+int __attribute__ ((target(\"arch=corei7\")))\n+foo ()\n+{\n+  return 6;\n+}\n+\n+int __attribute__ ((target(\"arch=atom\")))\n+foo ()\n+{\n+  return 10;\n+}\n+\n+int __attribute__ ((target(\"avx\")))\n+foo ()\n+{\n+  return 4;\n+}\n+\n+int __attribute__ ((target(\"arch=core2,sse4.2\")))\n+foo ()\n+{\n+  return 8;\n+}\n+\n+int __attribute__ ((target(\"arch=amdfam10\")))\n+foo ()\n+{\n+  return 7;\n+}\n+\n+int __attribute__ ((target(\"arch=bdver1\")))\n+foo ()\n+{\n+  return 1;\n+}\n+\n+int __attribute__ ((target(\"arch=bdver2\")))\n+foo ()\n+{\n+  return 2;\n+}"}, {"sha": "f94877a674f00f1094efb4dc5cb3cc0a9e022683", "filename": "gcc/testsuite/g++.dg/mv2.C", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3649b9b791c54f35a8bfb5540711dc4112acce7d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmv2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3649b9b791c54f35a8bfb5540711dc4112acce7d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmv2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmv2.C?ref=3649b9b791c54f35a8bfb5540711dc4112acce7d", "patch": "@@ -0,0 +1,118 @@\n+/* Test case to check if Multiversioning chooses the correct\n+   dispatching order when versions are for various ISAs.  */\n+/* { dg-do run { target i?86-*-* x86_64-*-* } } */\n+/* { dg-require-ifunc \"\" }  */\n+/* { dg-options \"-O2 -mno-sse -mno-mmx -mno-popcnt -mno-avx\" } */\n+\n+#include <assert.h>\n+\n+/* Default version.  */\n+int foo ();\n+/* The dispatch checks should be in the exact reverse order of the\n+   declarations below.  */\n+int foo () __attribute__ ((target (\"mmx\")));\n+int foo () __attribute__ ((target (\"sse\")));\n+int foo () __attribute__ ((target (\"sse2\")));\n+int foo () __attribute__ ((target (\"sse3\")));\n+int foo () __attribute__ ((target (\"ssse3\")));\n+int foo () __attribute__ ((target (\"sse4.1\")));\n+int foo () __attribute__ ((target (\"sse4.2\")));\n+int foo () __attribute__ ((target (\"popcnt\")));\n+int foo () __attribute__ ((target (\"avx\")));\n+int foo () __attribute__ ((target (\"avx2\")));\n+\n+int main ()\n+{\n+  int val = foo ();\n+\n+  if (__builtin_cpu_supports (\"avx2\"))\n+    assert (val == 1);\n+  else if (__builtin_cpu_supports (\"avx\"))\n+    assert (val == 2);\n+  else if (__builtin_cpu_supports (\"popcnt\"))\n+    assert (val == 3);\n+  else if (__builtin_cpu_supports (\"sse4.2\"))\n+    assert (val == 4);\n+  else if (__builtin_cpu_supports (\"sse4.1\"))\n+    assert (val == 5);\n+  else if (__builtin_cpu_supports (\"ssse3\"))\n+    assert (val == 6);\n+  else if (__builtin_cpu_supports (\"sse3\"))\n+    assert (val == 7);\n+  else if (__builtin_cpu_supports (\"sse2\"))\n+    assert (val == 8);\n+  else if (__builtin_cpu_supports (\"sse\"))\n+    assert (val == 9);\n+  else if (__builtin_cpu_supports (\"mmx\"))\n+    assert (val == 10);\n+  else\n+    assert (val == 0);\n+\n+  return 0;\n+}\n+\n+int\n+foo ()\n+{\n+  return 0;\n+}\n+\n+int __attribute__ ((target(\"mmx\")))\n+foo ()\n+{\n+  return 10;\n+}\n+\n+int __attribute__ ((target(\"sse\")))\n+foo ()\n+{\n+  return 9;\n+}\n+\n+int __attribute__ ((target(\"sse2\")))\n+foo ()\n+{\n+  return 8;\n+}\n+\n+int __attribute__ ((target(\"sse3\")))\n+foo ()\n+{\n+  return 7;\n+}\n+\n+int __attribute__ ((target(\"ssse3\")))\n+foo ()\n+{\n+  return 6;\n+}\n+\n+int __attribute__ ((target(\"sse4.1\")))\n+foo ()\n+{\n+  return 5;\n+}\n+\n+int __attribute__ ((target(\"sse4.2\")))\n+foo ()\n+{\n+  return 4;\n+}\n+\n+int __attribute__ ((target(\"popcnt\")))\n+foo ()\n+{\n+  return 3;\n+}\n+\n+int __attribute__ ((target(\"avx\")))\n+foo ()\n+{\n+  return 2;\n+}\n+\n+int __attribute__ ((target(\"avx2\")))\n+foo ()\n+{\n+  return 1;\n+}"}, {"sha": "c7088f2b01394dd9b4037aedd57d507e33951158", "filename": "gcc/testsuite/g++.dg/mv3.C", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3649b9b791c54f35a8bfb5540711dc4112acce7d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmv3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3649b9b791c54f35a8bfb5540711dc4112acce7d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmv3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmv3.C?ref=3649b9b791c54f35a8bfb5540711dc4112acce7d", "patch": "@@ -0,0 +1,36 @@\n+/* Test case to check if a call to a multiversioned function\n+   is replaced with a direct call to the particular version when\n+   the most specialized version's target attributes match the\n+   caller.  \n+  \n+   In this program, foo is multiversioned but there is no default\n+   function.  This is an error if the call has to go through a\n+   dispatcher.  However, the call to foo in bar can be replaced\n+   with a direct call to the popcnt version of foo.  Hence, this\n+   test should pass.  */\n+\n+/* { dg-do run { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 -mno-sse -mno-popcnt\" } */\n+\n+\n+int __attribute__ ((target (\"sse\")))\n+foo ()\n+{\n+  return 1;\n+}\n+int __attribute__ ((target (\"popcnt\")))\n+foo ()\n+{\n+  return 0;\n+}\n+\n+int __attribute__ ((target (\"popcnt\")))\n+bar ()\n+{\n+  return foo ();\n+}\n+\n+int main ()\n+{\n+  return bar ();\n+}"}, {"sha": "1a7290643acd612039140dc0ac4efe3943101dd7", "filename": "gcc/testsuite/g++.dg/mv4.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3649b9b791c54f35a8bfb5540711dc4112acce7d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmv4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3649b9b791c54f35a8bfb5540711dc4112acce7d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmv4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmv4.C?ref=3649b9b791c54f35a8bfb5540711dc4112acce7d", "patch": "@@ -0,0 +1,23 @@\n+/* Test case to check if the compiler generates an error message\n+   when the default version of a multiversioned function is absent\n+   and its pointer is taken.  */\n+\n+/* { dg-do compile { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 -mno-sse -mno-popcnt\" } */\n+\n+int __attribute__ ((target (\"sse\")))\n+foo ()\n+{\n+  return 1;\n+}\n+int __attribute__ ((target (\"popcnt\")))\n+foo ()\n+{\n+  return 0;\n+}\n+\n+int main ()\n+{\n+  int (*p)() = &foo; /* { dg-error \"Pointer to a multiversioned function without a default is not allowed\" {} } */\n+  return (*p)();\n+}"}, {"sha": "33d72804bcfc636318bcfbbbf32e5bbf8f369bca", "filename": "gcc/testsuite/g++.dg/mv5.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3649b9b791c54f35a8bfb5540711dc4112acce7d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmv5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3649b9b791c54f35a8bfb5540711dc4112acce7d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmv5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmv5.C?ref=3649b9b791c54f35a8bfb5540711dc4112acce7d", "patch": "@@ -0,0 +1,24 @@\n+/* Test case to check if multiversioned functions are still generated if they are\n+   marked comdat with inline keyword.  */\n+\n+/* { dg-do run { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2  -mno-popcnt\" } */\n+\n+\n+/* Default version.  */\n+inline int\n+foo ()\n+{\n+  return 0;\n+}\n+\n+inline int __attribute__ ((target (\"popcnt\")))\n+foo ()\n+{\n+  return 0;\n+}\n+\n+int main ()\n+{\n+  return foo ();\n+}"}, {"sha": "7e5aa29d0bb0e39a4c4e1f9457b4f337cf9e70d3", "filename": "gcc/testsuite/g++.dg/mv6.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3649b9b791c54f35a8bfb5540711dc4112acce7d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmv6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3649b9b791c54f35a8bfb5540711dc4112acce7d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmv6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmv6.C?ref=3649b9b791c54f35a8bfb5540711dc4112acce7d", "patch": "@@ -0,0 +1,25 @@\n+/* Test to check if member version multiversioning works correctly.  */\n+\n+/* { dg-do run { target i?86-*-* x86_64-*-* } } */\n+\n+class Foo\n+{\n+ public:\n+  /* Default version of foo.  */\n+  int foo ()\n+  {\n+    return 0;\n+  }\n+  /* corei7 version of foo.  */\n+  __attribute__ ((target(\"arch=corei7\")))\n+  int foo ()\n+  {\n+    return 0;\n+  }\n+};\n+\n+int main ()\n+{\n+  Foo f;\n+  return f.foo ();\n+}"}, {"sha": "5fe1f1f46bdadf09c39ba6ad4b61a0eb21b73f85", "filename": "gcc/tree.h", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3649b9b791c54f35a8bfb5540711dc4112acce7d/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3649b9b791c54f35a8bfb5540711dc4112acce7d/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=3649b9b791c54f35a8bfb5540711dc4112acce7d", "patch": "@@ -3480,6 +3480,12 @@ extern VEC(tree, gc) **decl_debug_args_insert (tree);\n #define DECL_FUNCTION_SPECIFIC_OPTIMIZATION(NODE) \\\n    (FUNCTION_DECL_CHECK (NODE)->function_decl.function_specific_optimization)\n \n+/* In FUNCTION_DECL, this is set if this function has other versions generated\n+   using \"target\" attributes.  The default version is the one which does not\n+   have any \"target\" attribute set. */\n+#define DECL_FUNCTION_VERSIONED(NODE)\\\n+   (FUNCTION_DECL_CHECK (NODE)->function_decl.versioned_function)\n+\n /* FUNCTION_DECL inherits from DECL_NON_COMMON because of the use of the\n    arguments/result/saved_tree fields by front ends.   It was either inherit\n    FUNCTION_DECL from non_common, or inherit non_common from FUNCTION_DECL,\n@@ -3524,8 +3530,8 @@ struct GTY(()) tree_function_decl {\n   unsigned looping_const_or_pure_flag : 1;\n   unsigned has_debug_args_flag : 1;\n   unsigned tm_clone_flag : 1;\n-\n-  /* 1 bit left */\n+  unsigned versioned_function : 1;\n+  /* No bits left.  */\n };\n \n /* The source language of the translation-unit.  */"}]}