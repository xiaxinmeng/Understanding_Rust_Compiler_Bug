{"sha": "a04084545806300525bb07d0c827480f5282bb55", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTA0MDg0NTQ1ODA2MzAwNTI1YmIwN2QwYzgyNzQ4MGY1MjgyYmI1NQ==", "commit": {"author": {"name": "Kostya Serebryany", "email": "kcc@google.com", "date": "2012-12-05T13:19:55Z"}, "committer": {"name": "Kostya Serebryany", "email": "kcc@gcc.gnu.org", "date": "2012-12-05T13:19:55Z"}, "message": "[libsanitizer] merge from upstream r169371\n\nFrom-SVN: r194221", "tree": {"sha": "1a9c1fa8fc461362f209a6c9b1abdadaacf74938", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1a9c1fa8fc461362f209a6c9b1abdadaacf74938"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a04084545806300525bb07d0c827480f5282bb55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a04084545806300525bb07d0c827480f5282bb55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a04084545806300525bb07d0c827480f5282bb55", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a04084545806300525bb07d0c827480f5282bb55/comments", "author": {"login": "kcc", "id": 1789297, "node_id": "MDQ6VXNlcjE3ODkyOTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1789297?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kcc", "html_url": "https://github.com/kcc", "followers_url": "https://api.github.com/users/kcc/followers", "following_url": "https://api.github.com/users/kcc/following{/other_user}", "gists_url": "https://api.github.com/users/kcc/gists{/gist_id}", "starred_url": "https://api.github.com/users/kcc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kcc/subscriptions", "organizations_url": "https://api.github.com/users/kcc/orgs", "repos_url": "https://api.github.com/users/kcc/repos", "events_url": "https://api.github.com/users/kcc/events{/privacy}", "received_events_url": "https://api.github.com/users/kcc/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cc4d934fa0d16330f29953d7ad14ff71e15f0d1b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc4d934fa0d16330f29953d7ad14ff71e15f0d1b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc4d934fa0d16330f29953d7ad14ff71e15f0d1b"}], "stats": {"total": 1207, "additions": 863, "deletions": 344}, "files": [{"sha": "4b0adecc5e9373d60affff88b462902a18e32369", "filename": "libsanitizer/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FChangeLog?ref=a04084545806300525bb07d0c827480f5282bb55", "patch": "@@ -1,3 +1,7 @@\n+2012-12-05  Kostya Serebryany  <kcc@google.com>\n+\n+\t* All files: Merge from upstream r169371.\n+\n 2012-12-04  Kostya Serebryany  <kcc@google.com>\n             Jack Howarth <howarth@bromo.med.uc.edu>\n "}, {"sha": "1512aa0380278d3e11ce55847b3c65a648800579", "filename": "libsanitizer/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FMERGE?ref=a04084545806300525bb07d0c827480f5282bb55", "patch": "@@ -1,4 +1,4 @@\n-168699\n+169371\n \n The first line of this file holds the svn revision number of the\n last merge done from the master library sources."}, {"sha": "ebaf95c3834c7bc34618b626da83d53cc9be12b2", "filename": "libsanitizer/asan/asan_interceptors.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Fasan%2Fasan_interceptors.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Fasan%2Fasan_interceptors.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interceptors.cc?ref=a04084545806300525bb07d0c827480f5282bb55", "patch": "@@ -177,6 +177,8 @@ INTERCEPTOR(void, siglongjmp, void *env, int val) {\n \n #if ASAN_INTERCEPT___CXA_THROW\n INTERCEPTOR(void, __cxa_throw, void *a, void *b, void *c) {\n+  Printf(\"__asan's __cxa_throw %p; REAL(__cxa_throw) %p PLAIN %p\\n\",\n+         __interceptor___cxa_throw, REAL(__cxa_throw), __cxa_throw);\n   CHECK(REAL(__cxa_throw));\n   __asan_handle_no_return();\n   REAL(__cxa_throw)(a, b, c);"}, {"sha": "ac1ee7de700f3d010b44f498d0b4edbc57751057", "filename": "libsanitizer/asan/asan_internal.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Fasan%2Fasan_internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Fasan%2Fasan_internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_internal.h?ref=a04084545806300525bb07d0c827480f5282bb55", "patch": "@@ -159,6 +159,7 @@ const int kAsanStackPartialRedzoneMagic = 0xf4;\n const int kAsanStackAfterReturnMagic = 0xf5;\n const int kAsanInitializationOrderMagic = 0xf6;\n const int kAsanUserPoisonedMemoryMagic = 0xf7;\n+const int kAsanStackUseAfterScopeMagic = 0xf8;\n const int kAsanGlobalRedzoneMagic = 0xf9;\n const int kAsanInternalHeapMagic = 0xfe;\n "}, {"sha": "447999446c8927ea318e4328505d32ad2e2b014e", "filename": "libsanitizer/asan/asan_linux.cc", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Fasan%2Fasan_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Fasan%2Fasan_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_linux.cc?ref=a04084545806300525bb07d0c827480f5282bb55", "patch": "@@ -156,7 +156,9 @@ void GetStackTrace(StackTrace *stack, uptr max_s, uptr pc, uptr bp) {\n   stack->trace[0] = pc;\n   if ((max_s) > 1) {\n     stack->max_size = max_s;\n-#if defined(__arm__) || defined(__powerpc__) || defined(__powerpc64__)\n+#if defined(__arm__) || \\\n+    defined(__powerpc__) || defined(__powerpc64__) || \\\n+    defined(__sparc__)\n     _Unwind_Backtrace(Unwind_Trace, stack);\n     // Pop off the two ASAN functions from the backtrace.\n     stack->PopStackFrames(2);"}, {"sha": "449299a583669435ac3d4b9ec478a327ae78caa3", "filename": "libsanitizer/asan/asan_poisoning.cc", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Fasan%2Fasan_poisoning.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Fasan%2Fasan_poisoning.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_poisoning.cc?ref=a04084545806300525bb07d0c827480f5282bb55", "patch": "@@ -149,3 +149,40 @@ void __asan_unpoison_memory_region(void const volatile *addr, uptr size) {\n bool __asan_address_is_poisoned(void const volatile *addr) {\n   return __asan::AddressIsPoisoned((uptr)addr);\n }\n+\n+// This is a simplified version of __asan_(un)poison_memory_region, which\n+// assumes that left border of region to be poisoned is properly aligned.\n+static void PoisonAlignedStackMemory(uptr addr, uptr size, bool do_poison) {\n+  if (size == 0) return;\n+  uptr aligned_size = size & ~(SHADOW_GRANULARITY - 1);\n+  PoisonShadow(addr, aligned_size,\n+               do_poison ? kAsanStackUseAfterScopeMagic : 0);\n+  if (size == aligned_size)\n+    return;\n+  s8 end_offset = (s8)(size - aligned_size);\n+  s8* shadow_end = (s8*)MemToShadow(addr + aligned_size);\n+  s8 end_value = *shadow_end;\n+  if (do_poison) {\n+    // If possible, mark all the bytes mapping to last shadow byte as\n+    // unaddressable.\n+    if (end_value > 0 && end_value <= end_offset)\n+      *shadow_end = kAsanStackUseAfterScopeMagic;\n+  } else {\n+    // If necessary, mark few first bytes mapping to last shadow byte\n+    // as addressable\n+    if (end_value != 0)\n+      *shadow_end = Max(end_value, end_offset);\n+  }\n+}\n+\n+void __asan_poison_stack_memory(uptr addr, uptr size) {\n+  if (flags()->verbosity > 0)\n+    Report(\"poisoning: %p %zx\\n\", (void*)addr, size);\n+  PoisonAlignedStackMemory(addr, size, true);\n+}\n+\n+void __asan_unpoison_stack_memory(uptr addr, uptr size) {\n+  if (flags()->verbosity > 0)\n+    Report(\"unpoisoning: %p %zx\\n\", (void*)addr, size);\n+  PoisonAlignedStackMemory(addr, size, false);\n+}"}, {"sha": "9804ddd1850c74e08da46922e315887061f145f7", "filename": "libsanitizer/asan/asan_report.cc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Fasan%2Fasan_report.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Fasan%2Fasan_report.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_report.cc?ref=a04084545806300525bb07d0c827480f5282bb55", "patch": "@@ -455,6 +455,9 @@ void __asan_report_error(uptr pc, uptr bp, uptr sp,\n       case kAsanUserPoisonedMemoryMagic:\n         bug_descr = \"use-after-poison\";\n         break;\n+      case kAsanStackUseAfterScopeMagic:\n+        bug_descr = \"stack-use-after-scope\";\n+        break;\n       case kAsanGlobalRedzoneMagic:\n         bug_descr = \"global-buffer-overflow\";\n         break;"}, {"sha": "cf0025a70efc81c9a53631c76c99ffba66095817", "filename": "libsanitizer/asan/asan_rtl.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Fasan%2Fasan_rtl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Fasan%2Fasan_rtl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_rtl.cc?ref=a04084545806300525bb07d0c827480f5282bb55", "patch": "@@ -246,6 +246,8 @@ static NOINLINE void force_interface_symbols() {\n     case 34: __asan_malloc_hook(0, 0); break;\n     case 35: __asan_free_hook(0); break;\n     case 36: __asan_symbolize(0, 0, 0); break;\n+    case 37: __asan_poison_stack_memory(0, 0); break;\n+    case 38: __asan_unpoison_stack_memory(0, 0); break;\n   }\n }\n "}, {"sha": "3f6f06a511859abf50fa5d40f68d4dfd1aa45d6a", "filename": "libsanitizer/asan/dynamic/asan_interceptors_dynamic.cc", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Fasan%2Fdynamic%2Fasan_interceptors_dynamic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Fasan%2Fdynamic%2Fasan_interceptors_dynamic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fdynamic%2Fasan_interceptors_dynamic.cc?ref=a04084545806300525bb07d0c827480f5282bb55", "patch": "@@ -1,7 +1,5 @@\n //===-- asan_interceptors_dynamic.cc --------------------------------------===//\n //\n-//                     The LLVM Compiler Infrastructure\n-//\n // This file is distributed under the University of Illinois Open Source\n // License. See LICENSE.TXT for details.\n //"}, {"sha": "b94b303f3ac1d6a751b8c8bf9f9df313a8d2337b", "filename": "libsanitizer/include/sanitizer/asan_interface.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Finclude%2Fsanitizer%2Fasan_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Finclude%2Fsanitizer%2Fasan_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fasan_interface.h?ref=a04084545806300525bb07d0c827480f5282bb55", "patch": "@@ -64,6 +64,15 @@ extern \"C\" {\n   void __asan_stack_free(uptr ptr, uptr size, uptr real_stack)\n       SANITIZER_INTERFACE_ATTRIBUTE;\n \n+  // These two functions are used by instrumented code in the\n+  // use-after-scope mode. They mark memory for local variables as\n+  // unaddressable when they leave scope and addressable before the\n+  // function exits.\n+  void __asan_poison_stack_memory(uptr addr, uptr size)\n+      SANITIZER_INTERFACE_ATTRIBUTE;\n+  void __asan_unpoison_stack_memory(uptr addr, uptr size)\n+      SANITIZER_INTERFACE_ATTRIBUTE;\n+\n   // Marks memory region [addr, addr+size) as unaddressable.\n   // This memory must be previously allocated by the user program. Accessing\n   // addresses in this region from instrumented code is forbidden until"}, {"sha": "d09112705f5d44e6aa63edfd5f8d2251647979b1", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator.cc", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.cc?ref=a04084545806300525bb07d0c827480f5282bb55", "patch": "@@ -47,13 +47,6 @@ void InternalFree(void *addr) {\n   LIBC_FREE(addr);\n }\n \n-void *InternalAllocBlock(void *p) {\n-  CHECK_NE(p, (void*)0);\n-  u64 *pp = (u64*)((uptr)p & ~0x7);\n-  for (; pp[0] != kBlockMagic; pp--) {}\n-  return pp + 1;\n-}\n-\n // LowLevelAllocator\n static LowLevelAllocateCallback low_level_alloc_callback;\n "}, {"sha": "63107bdbdb021d069f6e0350fa35f4e4be455691", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator.h", "status": "renamed", "additions": 40, "deletions": 39, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.h?ref=a04084545806300525bb07d0c827480f5282bb55", "patch": "@@ -1,25 +1,18 @@\n-//===-- sanitizer_allocator64.h ---------------------------------*- C++ -*-===//\n+//===-- sanitizer_allocator.h -----------------------------------*- C++ -*-===//\n //\n // This file is distributed under the University of Illinois Open Source\n // License. See LICENSE.TXT for details.\n //\n //===----------------------------------------------------------------------===//\n-// Specialized allocator which works only in 64-bit address space.\n-// To be used by ThreadSanitizer, MemorySanitizer and possibly other tools.\n-// The main feature of this allocator is that the header is located far away\n-// from the user memory region, so that the tool does not use extra shadow\n-// for the header.\n //\n-// Status: not yet ready.\n+// Specialized memory allocator for ThreadSanitizer, MemorySanitizer, etc.\n+//\n //===----------------------------------------------------------------------===//\n+\n #ifndef SANITIZER_ALLOCATOR_H\n #define SANITIZER_ALLOCATOR_H\n \n #include \"sanitizer_internal_defs.h\"\n-#if SANITIZER_WORDSIZE != 64\n-# error \"sanitizer_allocator64.h can only be used on 64-bit platforms\"\n-#endif\n-\n #include \"sanitizer_common.h\"\n #include \"sanitizer_libc.h\"\n #include \"sanitizer_list.h\"\n@@ -28,46 +21,31 @@\n namespace __sanitizer {\n \n // Maps size class id to size and back.\n-class DefaultSizeClassMap {\n+template <uptr l0, uptr l1, uptr l2, uptr l3, uptr l4, uptr l5,\n+          uptr s0, uptr s1, uptr s2, uptr s3, uptr s4,\n+          uptr c0, uptr c1, uptr c2, uptr c3, uptr c4>\n+class SplineSizeClassMap {\n  private:\n   // Here we use a spline composed of 5 polynomials of oder 1.\n   // The first size class is l0, then the classes go with step s0\n   // untill they reach l1, after which they go with step s1 and so on.\n   // Steps should be powers of two for cheap division.\n   // The size of the last size class should be a power of two.\n   // There should be at most 256 size classes.\n-  static const uptr l0 = 1 << 4;\n-  static const uptr l1 = 1 << 9;\n-  static const uptr l2 = 1 << 12;\n-  static const uptr l3 = 1 << 15;\n-  static const uptr l4 = 1 << 18;\n-  static const uptr l5 = 1 << 21;\n-\n-  static const uptr s0 = 1 << 4;\n-  static const uptr s1 = 1 << 6;\n-  static const uptr s2 = 1 << 9;\n-  static const uptr s3 = 1 << 12;\n-  static const uptr s4 = 1 << 15;\n-\n   static const uptr u0 = 0  + (l1 - l0) / s0;\n   static const uptr u1 = u0 + (l2 - l1) / s1;\n   static const uptr u2 = u1 + (l3 - l2) / s2;\n   static const uptr u3 = u2 + (l4 - l3) / s3;\n   static const uptr u4 = u3 + (l5 - l4) / s4;\n \n-  // Max cached in local cache blocks.\n-  static const uptr c0 = 256;\n-  static const uptr c1 = 64;\n-  static const uptr c2 = 16;\n-  static const uptr c3 = 4;\n-  static const uptr c4 = 1;\n-\n  public:\n+  // The number of size classes should be a power of two for fast division.\n   static const uptr kNumClasses = u4 + 1;\n   static const uptr kMaxSize = l5;\n   static const uptr kMinSize = l0;\n \n   COMPILER_CHECK(kNumClasses <= 256);\n+  COMPILER_CHECK((kNumClasses & (kNumClasses - 1)) == 0);\n   COMPILER_CHECK((kMaxSize & (kMaxSize - 1)) == 0);\n \n   static uptr Size(uptr class_id) {\n@@ -97,13 +75,30 @@ class DefaultSizeClassMap {\n   }\n };\n \n+class DefaultSizeClassMap: public SplineSizeClassMap<\n+  /* l: */1 << 4, 1 << 9,  1 << 12, 1 << 15, 1 << 18, 1 << 21,\n+  /* s: */1 << 4, 1 << 6,  1 << 9,  1 << 12, 1 << 15,\n+  /* c: */256,    64,      16,      4,       1> {\n+ private:\n+  COMPILER_CHECK(kNumClasses == 256);\n+};\n+\n+class CompactSizeClassMap: public SplineSizeClassMap<\n+  /* l: */1 << 3, 1 << 4,  1 << 7, 1 << 8, 1 << 12, 1 << 15,\n+  /* s: */1 << 3, 1 << 4,  1 << 7, 1 << 8, 1 << 12,\n+  /* c: */256,    64,      16,      4,       1> {\n+ private:\n+  COMPILER_CHECK(kNumClasses <= 32);\n+};\n+\n struct AllocatorListNode {\n   AllocatorListNode *next;\n };\n \n typedef IntrusiveList<AllocatorListNode> AllocatorFreeList;\n \n-\n+// SizeClassAllocator64 -- allocator for 64-bit address space.\n+//\n // Space: a portion of address space of kSpaceSize bytes starting at\n // a fixed address (kSpaceBeg). Both constants are powers of two and\n // kSpaceBeg is kSpaceSize-aligned.\n@@ -217,14 +212,15 @@ class SizeClassAllocator64 {\n   static uptr AllocBeg()  { return kSpaceBeg; }\n   static uptr AllocSize() { return kSpaceSize + AdditionalSize(); }\n \n-  static const uptr kNumClasses = 256;  // Power of two <= 256\n   typedef SizeClassMap SizeClassMapT;\n+  static const uptr kNumClasses = SizeClassMap::kNumClasses;  // 2^k <= 256\n \n  private:\n+  static const uptr kRegionSize = kSpaceSize / kNumClasses;\n   COMPILER_CHECK(kSpaceBeg % kSpaceSize == 0);\n   COMPILER_CHECK(kNumClasses <= SizeClassMap::kNumClasses);\n-  static const uptr kRegionSize = kSpaceSize / kNumClasses;\n-  COMPILER_CHECK((kRegionSize >> 32) > 0);  // kRegionSize must be >= 2^32.\n+  // kRegionSize must be >= 2^32.\n+  COMPILER_CHECK((kRegionSize) >= (1ULL << (SANITIZER_WORDSIZE / 2)));\n   // Populate the free list with at most this number of bytes at once\n   // or with one element if its size is greater.\n   static const uptr kPopulateSize = 1 << 18;\n@@ -239,8 +235,9 @@ class SizeClassAllocator64 {\n   COMPILER_CHECK(sizeof(RegionInfo) == kCacheLineSize);\n \n   static uptr AdditionalSize() {\n-    uptr res = sizeof(RegionInfo) * kNumClasses;\n-    CHECK_EQ(res % GetPageSizeCached(), 0);\n+    uptr PageSize = GetPageSizeCached();\n+    uptr res = Max(sizeof(RegionInfo) * kNumClasses, PageSize);\n+    CHECK_EQ(res % PageSize, 0);\n     return res;\n   }\n \n@@ -305,8 +302,10 @@ class SizeClassAllocator64 {\n // Objects of this type should be used as local caches for SizeClassAllocator64.\n // Since the typical use of this class is to have one object per thread in TLS,\n // is has to be POD.\n-template<const uptr kNumClasses, class SizeClassAllocator>\n+template<class SizeClassAllocator>\n struct SizeClassAllocatorLocalCache {\n+  typedef SizeClassAllocator Allocator;\n+  static const uptr kNumClasses = SizeClassAllocator::kNumClasses;\n   // Don't need to call Init if the object is a global (i.e. zero-initialized).\n   void Init() {\n     internal_memset(this, 0, sizeof(*this));\n@@ -458,11 +457,13 @@ class LargeMmapAllocator {\n   };\n \n   Header *GetHeader(uptr p) {\n+    CHECK_EQ(p % page_size_, 0);\n     return reinterpret_cast<Header*>(p - page_size_);\n   }\n   Header *GetHeader(void *p) { return GetHeader(reinterpret_cast<uptr>(p)); }\n \n   void *GetUser(Header *h) {\n+    CHECK_EQ((uptr)h % page_size_, 0);\n     return reinterpret_cast<void*>(reinterpret_cast<uptr>(h) + page_size_);\n   }\n ", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_allocator64.h"}, {"sha": "5639134b031c94dd707d979c1d7e4d5ed4771206", "filename": "libsanitizer/sanitizer_common/sanitizer_common.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h?ref=a04084545806300525bb07d0c827480f5282bb55", "patch": "@@ -49,9 +49,6 @@ bool MemoryRangeIsAvailable(uptr range_start, uptr range_end);\n // Internal allocator\n void *InternalAlloc(uptr size);\n void InternalFree(void *p);\n-// Given the pointer p into a valid allocated block,\n-// returns a pointer to the beginning of the block.\n-void *InternalAllocBlock(void *p);\n \n // InternalScopedBuffer can be used instead of large stack arrays to\n // keep frame size low."}, {"sha": "75f2ee18a67452eb7f0d45ba49ae949df8d41cb7", "filename": "libsanitizer/sanitizer_common/sanitizer_linux.cc", "status": "modified", "additions": 48, "deletions": 8, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cc?ref=a04084545806300525bb07d0c827480f5282bb55", "patch": "@@ -14,6 +14,7 @@\n #include \"sanitizer_common.h\"\n #include \"sanitizer_internal_defs.h\"\n #include \"sanitizer_libc.h\"\n+#include \"sanitizer_mutex.h\"\n #include \"sanitizer_placement_new.h\"\n #include \"sanitizer_procmaps.h\"\n \n@@ -215,21 +216,60 @@ void ReExec() {\n }\n \n // ----------------- sanitizer_procmaps.h\n+// Linker initialized.\n+ProcSelfMapsBuff MemoryMappingLayout::cached_proc_self_maps_;\n+StaticSpinMutex MemoryMappingLayout::cache_lock_;  // Linker initialized.\n+\n MemoryMappingLayout::MemoryMappingLayout() {\n-  proc_self_maps_buff_len_ =\n-      ReadFileToBuffer(\"/proc/self/maps\", &proc_self_maps_buff_,\n-                       &proc_self_maps_buff_mmaped_size_, 1 << 26);\n-  CHECK_GT(proc_self_maps_buff_len_, 0);\n-  // internal_write(2, proc_self_maps_buff_, proc_self_maps_buff_len_);\n+  proc_self_maps_.len =\n+      ReadFileToBuffer(\"/proc/self/maps\", &proc_self_maps_.data,\n+                       &proc_self_maps_.mmaped_size, 1 << 26);\n+  if (proc_self_maps_.mmaped_size == 0) {\n+    LoadFromCache();\n+    CHECK_GT(proc_self_maps_.len, 0);\n+  }\n+  // internal_write(2, proc_self_maps_.data, proc_self_maps_.len);\n   Reset();\n+  // FIXME: in the future we may want to cache the mappings on demand only.\n+  CacheMemoryMappings();\n }\n \n MemoryMappingLayout::~MemoryMappingLayout() {\n-  UnmapOrDie(proc_self_maps_buff_, proc_self_maps_buff_mmaped_size_);\n+  // Only unmap the buffer if it is different from the cached one. Otherwise\n+  // it will be unmapped when the cache is refreshed.\n+  if (proc_self_maps_.data != cached_proc_self_maps_.data) {\n+    UnmapOrDie(proc_self_maps_.data, proc_self_maps_.mmaped_size);\n+  }\n }\n \n void MemoryMappingLayout::Reset() {\n-  current_ = proc_self_maps_buff_;\n+  current_ = proc_self_maps_.data;\n+}\n+\n+// static\n+void MemoryMappingLayout::CacheMemoryMappings() {\n+  SpinMutexLock l(&cache_lock_);\n+  // Don't invalidate the cache if the mappings are unavailable.\n+  ProcSelfMapsBuff old_proc_self_maps;\n+  old_proc_self_maps = cached_proc_self_maps_;\n+  cached_proc_self_maps_.len =\n+      ReadFileToBuffer(\"/proc/self/maps\", &cached_proc_self_maps_.data,\n+                       &cached_proc_self_maps_.mmaped_size, 1 << 26);\n+  if (cached_proc_self_maps_.mmaped_size == 0) {\n+    cached_proc_self_maps_ = old_proc_self_maps;\n+  } else {\n+    if (old_proc_self_maps.mmaped_size) {\n+      UnmapOrDie(old_proc_self_maps.data,\n+                 old_proc_self_maps.mmaped_size);\n+    }\n+  }\n+}\n+\n+void MemoryMappingLayout::LoadFromCache() {\n+  SpinMutexLock l(&cache_lock_);\n+  if (cached_proc_self_maps_.data) {\n+    proc_self_maps_ = cached_proc_self_maps_;\n+  }\n }\n \n // Parse a hex value in str and update str.\n@@ -263,7 +303,7 @@ static bool IsDecimal(char c) {\n \n bool MemoryMappingLayout::Next(uptr *start, uptr *end, uptr *offset,\n                                char filename[], uptr filename_size) {\n-  char *last = proc_self_maps_buff_ + proc_self_maps_buff_len_;\n+  char *last = proc_self_maps_.data + proc_self_maps_.len;\n   if (current_ >= last) return false;\n   uptr dummy;\n   if (!start) start = &dummy;"}, {"sha": "465d0a30121a0967de2312c22cc0f660f0136cfe", "filename": "libsanitizer/sanitizer_common/sanitizer_mac.cc", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cc?ref=a04084545806300525bb07d0c827480f5282bb55", "patch": "@@ -160,6 +160,15 @@ void MemoryMappingLayout::Reset() {\n   current_filetype_ = 0;\n }\n \n+// static\n+void MemoryMappingLayout::CacheMemoryMappings() {\n+  // No-op on Mac for now.\n+}\n+\n+void MemoryMappingLayout::LoadFromCache() {\n+  // No-op on Mac for now.\n+}\n+\n // Next and NextSegmentLoad were inspired by base/sysinfo.cc in\n // Google Perftools, http://code.google.com/p/google-perftools.\n "}, {"sha": "b9601eaa9436b81c8b631f49c3e847edb59a6878", "filename": "libsanitizer/sanitizer_common/sanitizer_posix.cc", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.cc?ref=a04084545806300525bb07d0c827480f5282bb55", "patch": "@@ -167,7 +167,10 @@ void SetStackSizeLimitInBytes(uptr limit) {\n   struct rlimit rlim;\n   rlim.rlim_cur = limit;\n   rlim.rlim_max = limit;\n-  CHECK_EQ(0, setrlimit(RLIMIT_STACK, &rlim));\n+  if (setrlimit(RLIMIT_STACK, &rlim)) {\n+    Report(\"setrlimit() failed %d\\n\", errno);\n+    Die();\n+  }\n   CHECK(!StackSizeIsUnlimited());\n }\n "}, {"sha": "400fd7a8bc4ab00d1f60515ec69be269044d94d7", "filename": "libsanitizer/sanitizer_common/sanitizer_procmaps.h", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps.h?ref=a04084545806300525bb07d0c827480f5282bb55", "patch": "@@ -13,6 +13,7 @@\n #define SANITIZER_PROCMAPS_H\n \n #include \"sanitizer_internal_defs.h\"\n+#include \"sanitizer_mutex.h\"\n \n namespace __sanitizer {\n \n@@ -27,6 +28,14 @@ class MemoryMappingLayout {\n };\n \n #else  // _WIN32\n+#if defined(__linux__)\n+struct ProcSelfMapsBuff {\n+  char *data;\n+  uptr mmaped_size;\n+  uptr len;\n+};\n+#endif  // defined(__linux__)\n+\n class MemoryMappingLayout {\n  public:\n   MemoryMappingLayout();\n@@ -37,9 +46,14 @@ class MemoryMappingLayout {\n   // address 'addr'. Returns true on success.\n   bool GetObjectNameAndOffset(uptr addr, uptr *offset,\n                               char filename[], uptr filename_size);\n+  // In some cases, e.g. when running under a sandbox on Linux, ASan is unable\n+  // to obtain the memory mappings. It should fall back to pre-cached data\n+  // instead of aborting.\n+  static void CacheMemoryMappings();\n   ~MemoryMappingLayout();\n \n  private:\n+  void LoadFromCache();\n   // Default implementation of GetObjectNameAndOffset.\n   // Quite slow, because it iterates through the whole process map for each\n   // lookup.\n@@ -71,10 +85,12 @@ class MemoryMappingLayout {\n   }\n \n # if defined __linux__\n-  char *proc_self_maps_buff_;\n-  uptr proc_self_maps_buff_mmaped_size_;\n-  uptr proc_self_maps_buff_len_;\n+  ProcSelfMapsBuff proc_self_maps_;\n   char *current_;\n+\n+  // Static mappings cache.\n+  static ProcSelfMapsBuff cached_proc_self_maps_;\n+  static StaticSpinMutex cache_lock_;  // protects cached_proc_self_maps_.\n # elif defined __APPLE__\n   template<u32 kLCSegment, typename SegmentCommand>\n   bool NextSegmentLoad(uptr *start, uptr *end, uptr *offset,"}, {"sha": "308c2d90731eb2e864616e01cab0be61b294af4f", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cc?ref=a04084545806300525bb07d0c827480f5282bb55", "patch": "@@ -34,6 +34,8 @@ static uptr patch_pc(uptr pc) {\n #if defined(__powerpc__) || defined(__powerpc64__)\n   // PCs are always 4 byte aligned.\n   return pc - 4;\n+#elif defined(__sparc__)\n+  return pc - 8;\n #else\n   return pc - 1;\n #endif"}, {"sha": "11393e4450389f216b54ad110d3a53aa98addfc9", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer.cc", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.cc?ref=a04084545806300525bb07d0c827480f5282bb55", "patch": "@@ -254,6 +254,17 @@ class Symbolizer {\n     // Otherwise, the data was filled by external symbolizer.\n     return actual_frames;\n   }\n+\n+  bool SymbolizeData(uptr addr, AddressInfo *frame) {\n+    LoadedModule *module = FindModuleForAddress(addr);\n+    if (module == 0)\n+      return false;\n+    const char *module_name = module->full_name();\n+    uptr module_offset = addr - module->base_address();\n+    frame->FillAddressAndModuleInfo(addr, module_name, module_offset);\n+    return true;\n+  }\n+\n   bool InitializeExternalSymbolizer(const char *path_to_symbolizer) {\n     int input_fd, output_fd;\n     if (!StartSymbolizerSubprocess(path_to_symbolizer, &input_fd, &output_fd))\n@@ -305,6 +316,10 @@ uptr SymbolizeCode(uptr address, AddressInfo *frames, uptr max_frames) {\n   return symbolizer.SymbolizeCode(address, frames, max_frames);\n }\n \n+bool SymbolizeData(uptr address, AddressInfo *frame) {\n+  return symbolizer.SymbolizeData(address, frame);\n+}\n+\n bool InitializeExternalSymbolizer(const char *path_to_symbolizer) {\n   return symbolizer.InitializeExternalSymbolizer(path_to_symbolizer);\n }"}, {"sha": "4d7ec17fe6a854e45fe72aa85c77a865f6d6624c", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.h?ref=a04084545806300525bb07d0c827480f5282bb55", "patch": "@@ -56,6 +56,7 @@ struct AddressInfo {\n // of descriptions actually filled.\n // This function should NOT be called from two threads simultaneously.\n uptr SymbolizeCode(uptr address, AddressInfo *frames, uptr max_frames);\n+bool SymbolizeData(uptr address, AddressInfo *frame);\n \n // Starts external symbolizer program in a subprocess. Sanitizer communicates\n // with external symbolizer via pipes."}, {"sha": "c14a6d196232a708967b2a5cb9a69e29e76308d9", "filename": "libsanitizer/tsan/tsan_defs.h", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Ftsan%2Ftsan_defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Ftsan%2Ftsan_defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_defs.h?ref=a04084545806300525bb07d0c827480f5282bb55", "patch": "@@ -23,8 +23,12 @@\n namespace __tsan {\n \n #ifdef TSAN_GO\n+const bool kGoMode = true;\n+const bool kCppMode = false;\n const char *const kTsanOptionsEnv = \"GORACE\";\n #else\n+const bool kGoMode = false;\n+const bool kCppMode = true;\n const char *const kTsanOptionsEnv = \"TSAN_OPTIONS\";\n #endif\n \n@@ -122,11 +126,17 @@ T max(T a, T b) {\n }\n \n template<typename T>\n-T RoundUp(T p, int align) {\n+T RoundUp(T p, u64 align) {\n   DCHECK_EQ(align & (align - 1), 0);\n   return (T)(((u64)p + align - 1) & ~(align - 1));\n }\n \n+template<typename T>\n+T RoundDown(T p, u64 align) {\n+  DCHECK_EQ(align & (align - 1), 0);\n+  return (T)((u64)p & ~(align - 1));\n+}\n+\n struct MD5Hash {\n   u64 hash[2];\n   bool operator==(const MD5Hash &other) const;"}, {"sha": "1b726e6c8de3145dd6e4935106cb95708af70bc6", "filename": "libsanitizer/tsan/tsan_flags.cc", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Ftsan%2Ftsan_flags.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Ftsan%2Ftsan_flags.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_flags.cc?ref=a04084545806300525bb07d0c827480f5282bb55", "patch": "@@ -38,6 +38,7 @@ void InitializeFlags(Flags *f, const char *env) {\n   f->enable_annotations = true;\n   f->suppress_equal_stacks = true;\n   f->suppress_equal_addresses = true;\n+  f->suppress_java = false;\n   f->report_bugs = true;\n   f->report_thread_leaks = true;\n   f->report_destroy_locked = true;\n@@ -46,14 +47,15 @@ void InitializeFlags(Flags *f, const char *env) {\n   f->strip_path_prefix = \"\";\n   f->suppressions = \"\";\n   f->exitcode = 66;\n-  f->log_fileno = kStderrFd;\n+  f->log_path = \"stderr\";\n   f->atexit_sleep_ms = 1000;\n   f->verbosity = 0;\n   f->profile_memory = \"\";\n   f->flush_memory_ms = 0;\n   f->stop_on_start = false;\n   f->running_on_valgrind = false;\n   f->external_symbolizer_path = \"\";\n+  f->history_size = kGoMode ? 1 : 2;  // There are a lot of goroutines in Go.\n \n   // Let a frontend override.\n   OverrideFlags(f);\n@@ -62,6 +64,7 @@ void InitializeFlags(Flags *f, const char *env) {\n   ParseFlag(env, &f->enable_annotations, \"enable_annotations\");\n   ParseFlag(env, &f->suppress_equal_stacks, \"suppress_equal_stacks\");\n   ParseFlag(env, &f->suppress_equal_addresses, \"suppress_equal_addresses\");\n+  ParseFlag(env, &f->suppress_java, \"suppress_java\");\n   ParseFlag(env, &f->report_bugs, \"report_bugs\");\n   ParseFlag(env, &f->report_thread_leaks, \"report_thread_leaks\");\n   ParseFlag(env, &f->report_destroy_locked, \"report_destroy_locked\");\n@@ -70,19 +73,26 @@ void InitializeFlags(Flags *f, const char *env) {\n   ParseFlag(env, &f->strip_path_prefix, \"strip_path_prefix\");\n   ParseFlag(env, &f->suppressions, \"suppressions\");\n   ParseFlag(env, &f->exitcode, \"exitcode\");\n-  ParseFlag(env, &f->log_fileno, \"log_fileno\");\n+  ParseFlag(env, &f->log_path, \"log_path\");\n   ParseFlag(env, &f->atexit_sleep_ms, \"atexit_sleep_ms\");\n   ParseFlag(env, &f->verbosity, \"verbosity\");\n   ParseFlag(env, &f->profile_memory, \"profile_memory\");\n   ParseFlag(env, &f->flush_memory_ms, \"flush_memory_ms\");\n   ParseFlag(env, &f->stop_on_start, \"stop_on_start\");\n   ParseFlag(env, &f->external_symbolizer_path, \"external_symbolizer_path\");\n+  ParseFlag(env, &f->history_size, \"history_size\");\n \n   if (!f->report_bugs) {\n     f->report_thread_leaks = false;\n     f->report_destroy_locked = false;\n     f->report_signal_unsafe = false;\n   }\n+\n+  if (f->history_size < 0 || f->history_size > 7) {\n+    Printf(\"ThreadSanitizer: incorrect value for history_size\"\n+           \" (must be [0..7])\\n\");\n+    Die();\n+  }\n }\n \n }  // namespace __tsan"}, {"sha": "6af96ec83becc55a46c9738d1a2a538315715302", "filename": "libsanitizer/tsan/tsan_flags.h", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Ftsan%2Ftsan_flags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Ftsan%2Ftsan_flags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_flags.h?ref=a04084545806300525bb07d0c827480f5282bb55", "patch": "@@ -29,6 +29,9 @@ struct Flags {\n   // Supress a race report if we've already output another race report\n   // on the same address.\n   bool suppress_equal_addresses;\n+  // Suppress weird race reports that can be seen if JVM is embed\n+  // into the process.\n+  bool suppress_java;\n   // Turns off bug reporting entirely (useful for benchmarking).\n   bool report_bugs;\n   // Report thread leaks at exit?\n@@ -47,8 +50,10 @@ struct Flags {\n   const char *suppressions;\n   // Override exit status if something was reported.\n   int exitcode;\n-  // Log fileno (1 - stdout, 2 - stderr).\n-  int log_fileno;\n+  // Write logs to \"log_path.pid\".\n+  // The special values are \"stdout\" and \"stderr\".\n+  // The default is \"stderr\".\n+  const char *log_path;\n   // Sleep in main thread before exiting for that many ms\n   // (useful to catch \"at exit\" races).\n   int atexit_sleep_ms;\n@@ -64,6 +69,12 @@ struct Flags {\n   bool running_on_valgrind;\n   // Path to external symbolizer.\n   const char *external_symbolizer_path;\n+  // Per-thread history size, controls how many previous memory accesses\n+  // are remembered per thread.  Possible values are [0..7].\n+  // history_size=0 amounts to 32K memory accesses.  Each next value doubles\n+  // the amount of memory accesses, up to history_size=7 that amounts to\n+  // 4M memory accesses.  The default value is 2 (128K memory accesses).\n+  int history_size;\n };\n \n Flags *flags();"}, {"sha": "0463fbd4f2847daae277fd4e3ed124df34d75ac8", "filename": "libsanitizer/tsan/tsan_interceptors.cc", "status": "modified", "additions": 82, "deletions": 2, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Ftsan%2Ftsan_interceptors.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Ftsan%2Ftsan_interceptors.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interceptors.cc?ref=a04084545806300525bb07d0c827480f5282bb55", "patch": "@@ -13,7 +13,7 @@\n #include \"sanitizer_common/sanitizer_libc.h\"\n #include \"sanitizer_common/sanitizer_placement_new.h\"\n #include \"sanitizer_common/sanitizer_stacktrace.h\"\n-#include \"tsan_interceptors.h\"\n+#include \"interception/interception.h\"\n #include \"tsan_interface.h\"\n #include \"tsan_platform.h\"\n #include \"tsan_rtl.h\"\n@@ -135,6 +135,15 @@ static SignalContext *SigCtx(ThreadState *thr) {\n \n static unsigned g_thread_finalize_key;\n \n+class ScopedInterceptor {\n+ public:\n+  ScopedInterceptor(ThreadState *thr, const char *fname, uptr pc);\n+  ~ScopedInterceptor();\n+ private:\n+  ThreadState *const thr_;\n+  const int in_rtl_;\n+};\n+\n ScopedInterceptor::ScopedInterceptor(ThreadState *thr, const char *fname,\n                                      uptr pc)\n     : thr_(thr)\n@@ -158,6 +167,30 @@ ScopedInterceptor::~ScopedInterceptor() {\n   CHECK_EQ(in_rtl_, thr_->in_rtl);\n }\n \n+#define SCOPED_INTERCEPTOR_RAW(func, ...) \\\n+    ThreadState *thr = cur_thread(); \\\n+    StatInc(thr, StatInterceptor); \\\n+    StatInc(thr, StatInt_##func); \\\n+    const uptr caller_pc = GET_CALLER_PC(); \\\n+    ScopedInterceptor si(thr, #func, caller_pc); \\\n+    /* Subtract one from pc as we need current instruction address */ \\\n+    const uptr pc = __sanitizer::StackTrace::GetCurrentPc() - 1; \\\n+    (void)pc; \\\n+/**/\n+\n+#define SCOPED_TSAN_INTERCEPTOR(func, ...) \\\n+    SCOPED_INTERCEPTOR_RAW(func, __VA_ARGS__); \\\n+    if (REAL(func) == 0) { \\\n+      Printf(\"FATAL: ThreadSanitizer: failed to intercept %s\\n\", #func); \\\n+      Die(); \\\n+    } \\\n+    if (thr->in_rtl > 1) \\\n+      return REAL(func)(__VA_ARGS__); \\\n+/**/\n+\n+#define TSAN_INTERCEPTOR(ret, func, ...) INTERCEPTOR(ret, func, __VA_ARGS__)\n+#define TSAN_INTERCEPT(func) INTERCEPT_FUNCTION(func)\n+\n #define BLOCK_REAL(name) (BlockingCall(thr), REAL(name))\n \n struct BlockingCall {\n@@ -259,7 +292,6 @@ static void finalize(void *arg) {\n TSAN_INTERCEPTOR(int, atexit, void (*f)()) {\n   SCOPED_TSAN_INTERCEPTOR(atexit, f);\n   return atexit_ctx->atexit(thr, pc, f);\n-  return 0;\n }\n \n TSAN_INTERCEPTOR(void, longjmp, void *env, int val) {\n@@ -308,6 +340,11 @@ TSAN_INTERCEPTOR(void*, malloc, uptr size) {\n   return p;\n }\n \n+TSAN_INTERCEPTOR(void*, __libc_memalign, uptr align, uptr sz) {\n+  SCOPED_TSAN_INTERCEPTOR(__libc_memalign, align, sz);\n+  return user_alloc(thr, pc, sz, align);\n+}\n+\n TSAN_INTERCEPTOR(void*, calloc, uptr size, uptr n) {\n   void *p = 0;\n   {\n@@ -1347,6 +1384,35 @@ TSAN_INTERCEPTOR(int, gettimeofday, void *tv, void *tz) {\n   return REAL(gettimeofday)(tv, tz);\n }\n \n+// Linux kernel has a bug that leads to kernel deadlock if a process\n+// maps TBs of memory and then calls mlock().\n+static void MlockIsUnsupported() {\n+  static atomic_uint8_t printed;\n+  if (atomic_exchange(&printed, 1, memory_order_relaxed))\n+    return;\n+  Printf(\"INFO: ThreadSanitizer ignores mlock/mlockall/munlock/munlockall\\n\");\n+}\n+\n+TSAN_INTERCEPTOR(int, mlock, const void *addr, uptr len) {\n+  MlockIsUnsupported();\n+  return 0;\n+}\n+\n+TSAN_INTERCEPTOR(int, munlock, const void *addr, uptr len) {\n+  MlockIsUnsupported();\n+  return 0;\n+}\n+\n+TSAN_INTERCEPTOR(int, mlockall, int flags) {\n+  MlockIsUnsupported();\n+  return 0;\n+}\n+\n+TSAN_INTERCEPTOR(int, munlockall, void) {\n+  MlockIsUnsupported();\n+  return 0;\n+}\n+\n namespace __tsan {\n \n void ProcessPendingSignals(ThreadState *thr) {\n@@ -1396,6 +1462,11 @@ void ProcessPendingSignals(ThreadState *thr) {\n   thr->in_signal_handler = false;\n }\n \n+static void unreachable() {\n+  Printf(\"FATAL: ThreadSanitizer: unreachable called\\n\");\n+  Die();\n+}\n+\n void InitializeInterceptors() {\n   CHECK_GT(cur_thread()->in_rtl, 0);\n \n@@ -1408,6 +1479,7 @@ void InitializeInterceptors() {\n   TSAN_INTERCEPT(siglongjmp);\n \n   TSAN_INTERCEPT(malloc);\n+  TSAN_INTERCEPT(__libc_memalign);\n   TSAN_INTERCEPT(calloc);\n   TSAN_INTERCEPT(realloc);\n   TSAN_INTERCEPT(free);\n@@ -1524,6 +1596,14 @@ void InitializeInterceptors() {\n   TSAN_INTERCEPT(nanosleep);\n   TSAN_INTERCEPT(gettimeofday);\n \n+  TSAN_INTERCEPT(mlock);\n+  TSAN_INTERCEPT(munlock);\n+  TSAN_INTERCEPT(mlockall);\n+  TSAN_INTERCEPT(munlockall);\n+\n+  // Need to setup it, because interceptors check that the function is resolved.\n+  // But atexit is emitted directly into the module, so can't be resolved.\n+  REAL(atexit) = (int(*)(void(*)()))unreachable;\n   atexit_ctx = new(internal_alloc(MBlockAtExit, sizeof(AtExitContext)))\n       AtExitContext();\n "}, {"sha": "2e8c553172c05205274e03b88f1c7632d12ae44e", "filename": "libsanitizer/tsan/tsan_interceptors.h", "status": "removed", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc4d934fa0d16330f29953d7ad14ff71e15f0d1b/libsanitizer%2Ftsan%2Ftsan_interceptors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc4d934fa0d16330f29953d7ad14ff71e15f0d1b/libsanitizer%2Ftsan%2Ftsan_interceptors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interceptors.h?ref=cc4d934fa0d16330f29953d7ad14ff71e15f0d1b", "patch": "@@ -1,52 +0,0 @@\n-//===-- tsan_interceptors.h -------------------------------------*- C++ -*-===//\n-//\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n-//\n-//===----------------------------------------------------------------------===//\n-//\n-// This file is a part of ThreadSanitizer (TSan), a race detector.\n-//\n-//===----------------------------------------------------------------------===//\n-\n-#ifndef TSAN_INTERCEPTORS_H\n-#define TSAN_INTERCEPTORS_H\n-\n-#include \"interception/interception.h\"\n-#include \"sanitizer_common/sanitizer_stacktrace.h\"\n-#include \"tsan_rtl.h\"\n-\n-namespace __tsan {\n-\n-class ScopedInterceptor {\n- public:\n-  ScopedInterceptor(ThreadState *thr, const char *fname, uptr pc);\n-  ~ScopedInterceptor();\n- private:\n-  ThreadState *const thr_;\n-  const int in_rtl_;\n-};\n-\n-#define SCOPED_INTERCEPTOR_RAW(func, ...) \\\n-    ThreadState *thr = cur_thread(); \\\n-    StatInc(thr, StatInterceptor); \\\n-    StatInc(thr, StatInt_##func); \\\n-    const uptr caller_pc = GET_CALLER_PC(); \\\n-    ScopedInterceptor si(thr, #func, caller_pc); \\\n-    /* Subtract one from pc as we need current instruction address */ \\\n-    const uptr pc = __sanitizer::StackTrace::GetCurrentPc() - 1; \\\n-    (void)pc; \\\n-/**/\n-\n-#define SCOPED_TSAN_INTERCEPTOR(func, ...) \\\n-    SCOPED_INTERCEPTOR_RAW(func, __VA_ARGS__); \\\n-    if (thr->in_rtl > 1) \\\n-      return REAL(func)(__VA_ARGS__); \\\n-/**/\n-\n-#define TSAN_INTERCEPTOR(ret, func, ...) INTERCEPTOR(ret, func, __VA_ARGS__)\n-#define TSAN_INTERCEPT(func) INTERCEPT_FUNCTION(func)\n-\n-}  // namespace __tsan\n-\n-#endif  // TSAN_INTERCEPTORS_H"}, {"sha": "8f265ca27b5f84d7c5a36380963cb6dcbc992e7f", "filename": "libsanitizer/tsan/tsan_interface.h", "status": "modified", "additions": 26, "deletions": 21, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Ftsan%2Ftsan_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Ftsan%2Ftsan_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface.h?ref=a04084545806300525bb07d0c827480f5282bb55", "patch": "@@ -14,6 +14,8 @@\n #ifndef TSAN_INTERFACE_H\n #define TSAN_INTERFACE_H\n \n+#include <sanitizer/common_interface_defs.h>\n+\n // This header should NOT include any other headers.\n // All functions in this header are extern \"C\" and start with __tsan_.\n \n@@ -23,27 +25,30 @@ extern \"C\" {\n \n // This function should be called at the very beginning of the process,\n // before any instrumented code is executed and before any call to malloc.\n-void __tsan_init();\n-\n-void __tsan_read1(void *addr);\n-void __tsan_read2(void *addr);\n-void __tsan_read4(void *addr);\n-void __tsan_read8(void *addr);\n-void __tsan_read16(void *addr);\n-\n-void __tsan_write1(void *addr);\n-void __tsan_write2(void *addr);\n-void __tsan_write4(void *addr);\n-void __tsan_write8(void *addr);\n-void __tsan_write16(void *addr);\n-\n-void __tsan_vptr_update(void **vptr_p, void *new_val);\n-\n-void __tsan_func_entry(void *call_pc);\n-void __tsan_func_exit();\n-\n-void __tsan_read_range(void *addr, unsigned long size);  // NOLINT\n-void __tsan_write_range(void *addr, unsigned long size);  // NOLINT\n+void __tsan_init() SANITIZER_INTERFACE_ATTRIBUTE;\n+\n+void __tsan_read1(void *addr) SANITIZER_INTERFACE_ATTRIBUTE;\n+void __tsan_read2(void *addr) SANITIZER_INTERFACE_ATTRIBUTE;\n+void __tsan_read4(void *addr) SANITIZER_INTERFACE_ATTRIBUTE;\n+void __tsan_read8(void *addr) SANITIZER_INTERFACE_ATTRIBUTE;\n+void __tsan_read16(void *addr) SANITIZER_INTERFACE_ATTRIBUTE;\n+\n+void __tsan_write1(void *addr) SANITIZER_INTERFACE_ATTRIBUTE;\n+void __tsan_write2(void *addr) SANITIZER_INTERFACE_ATTRIBUTE;\n+void __tsan_write4(void *addr) SANITIZER_INTERFACE_ATTRIBUTE;\n+void __tsan_write8(void *addr) SANITIZER_INTERFACE_ATTRIBUTE;\n+void __tsan_write16(void *addr) SANITIZER_INTERFACE_ATTRIBUTE;\n+\n+void __tsan_vptr_update(void **vptr_p, void *new_val)\n+    SANITIZER_INTERFACE_ATTRIBUTE;\n+\n+void __tsan_func_entry(void *call_pc) SANITIZER_INTERFACE_ATTRIBUTE;\n+void __tsan_func_exit() SANITIZER_INTERFACE_ATTRIBUTE;\n+\n+void __tsan_read_range(void *addr, unsigned long size)  // NOLINT\n+    SANITIZER_INTERFACE_ATTRIBUTE;\n+void __tsan_write_range(void *addr, unsigned long size)  // NOLINT\n+    SANITIZER_INTERFACE_ATTRIBUTE;\n \n #ifdef __cplusplus\n }  // extern \"C\""}, {"sha": "7e49fb8b059cc6f80735d678564c20354bcf0948", "filename": "libsanitizer/tsan/tsan_interface_ann.cc", "status": "modified", "additions": 60, "deletions": 40, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Ftsan%2Ftsan_interface_ann.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Ftsan%2Ftsan_interface_ann.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface_ann.cc?ref=a04084545806300525bb07d0c827480f5282bb55", "patch": "@@ -9,6 +9,7 @@\n //\n //===----------------------------------------------------------------------===//\n #include \"sanitizer_common/sanitizer_libc.h\"\n+#include \"sanitizer_common/sanitizer_internal_defs.h\"\n #include \"sanitizer_common/sanitizer_placement_new.h\"\n #include \"tsan_interface_ann.h\"\n #include \"tsan_mutex.h\"\n@@ -157,76 +158,80 @@ bool IsExpectedReport(uptr addr, uptr size) {\n using namespace __tsan;  // NOLINT\n \n extern \"C\" {\n-void AnnotateHappensBefore(char *f, int l, uptr addr) {\n+void INTERFACE_ATTRIBUTE AnnotateHappensBefore(char *f, int l, uptr addr) {\n   SCOPED_ANNOTATION(AnnotateHappensBefore);\n   Release(cur_thread(), CALLERPC, addr);\n }\n \n-void AnnotateHappensAfter(char *f, int l, uptr addr) {\n+void INTERFACE_ATTRIBUTE AnnotateHappensAfter(char *f, int l, uptr addr) {\n   SCOPED_ANNOTATION(AnnotateHappensAfter);\n   Acquire(cur_thread(), CALLERPC, addr);\n }\n \n-void AnnotateCondVarSignal(char *f, int l, uptr cv) {\n+void INTERFACE_ATTRIBUTE AnnotateCondVarSignal(char *f, int l, uptr cv) {\n   SCOPED_ANNOTATION(AnnotateCondVarSignal);\n }\n \n-void AnnotateCondVarSignalAll(char *f, int l, uptr cv) {\n+void INTERFACE_ATTRIBUTE AnnotateCondVarSignalAll(char *f, int l, uptr cv) {\n   SCOPED_ANNOTATION(AnnotateCondVarSignalAll);\n }\n \n-void AnnotateMutexIsNotPHB(char *f, int l, uptr mu) {\n+void INTERFACE_ATTRIBUTE AnnotateMutexIsNotPHB(char *f, int l, uptr mu) {\n   SCOPED_ANNOTATION(AnnotateMutexIsNotPHB);\n }\n \n-void AnnotateCondVarWait(char *f, int l, uptr cv, uptr lock) {\n+void INTERFACE_ATTRIBUTE AnnotateCondVarWait(char *f, int l, uptr cv,\n+                                             uptr lock) {\n   SCOPED_ANNOTATION(AnnotateCondVarWait);\n }\n \n-void AnnotateRWLockCreate(char *f, int l, uptr m) {\n+void INTERFACE_ATTRIBUTE AnnotateRWLockCreate(char *f, int l, uptr m) {\n   SCOPED_ANNOTATION(AnnotateRWLockCreate);\n   MutexCreate(thr, pc, m, true, true, false);\n }\n \n-void AnnotateRWLockCreateStatic(char *f, int l, uptr m) {\n+void INTERFACE_ATTRIBUTE AnnotateRWLockCreateStatic(char *f, int l, uptr m) {\n   SCOPED_ANNOTATION(AnnotateRWLockCreateStatic);\n   MutexCreate(thr, pc, m, true, true, true);\n }\n \n-void AnnotateRWLockDestroy(char *f, int l, uptr m) {\n+void INTERFACE_ATTRIBUTE AnnotateRWLockDestroy(char *f, int l, uptr m) {\n   SCOPED_ANNOTATION(AnnotateRWLockDestroy);\n   MutexDestroy(thr, pc, m);\n }\n \n-void AnnotateRWLockAcquired(char *f, int l, uptr m, uptr is_w) {\n+void INTERFACE_ATTRIBUTE AnnotateRWLockAcquired(char *f, int l, uptr m,\n+                                                uptr is_w) {\n   SCOPED_ANNOTATION(AnnotateRWLockAcquired);\n   if (is_w)\n     MutexLock(thr, pc, m);\n   else\n     MutexReadLock(thr, pc, m);\n }\n \n-void AnnotateRWLockReleased(char *f, int l, uptr m, uptr is_w) {\n+void INTERFACE_ATTRIBUTE AnnotateRWLockReleased(char *f, int l, uptr m,\n+                                                uptr is_w) {\n   SCOPED_ANNOTATION(AnnotateRWLockReleased);\n   if (is_w)\n     MutexUnlock(thr, pc, m);\n   else\n     MutexReadUnlock(thr, pc, m);\n }\n \n-void AnnotateTraceMemory(char *f, int l, uptr mem) {\n+void INTERFACE_ATTRIBUTE AnnotateTraceMemory(char *f, int l, uptr mem) {\n   SCOPED_ANNOTATION(AnnotateTraceMemory);\n }\n \n-void AnnotateFlushState(char *f, int l) {\n+void INTERFACE_ATTRIBUTE AnnotateFlushState(char *f, int l) {\n   SCOPED_ANNOTATION(AnnotateFlushState);\n }\n \n-void AnnotateNewMemory(char *f, int l, uptr mem, uptr size) {\n+void INTERFACE_ATTRIBUTE AnnotateNewMemory(char *f, int l, uptr mem,\n+                                           uptr size) {\n   SCOPED_ANNOTATION(AnnotateNewMemory);\n }\n \n-void AnnotateNoOp(char *f, int l, uptr mem) {\n+void INTERFACE_ATTRIBUTE AnnotateNoOp(char *f, int l, uptr mem) {\n   SCOPED_ANNOTATION(AnnotateNoOp);\n }\n \n@@ -238,7 +243,7 @@ static void ReportMissedExpectedRace(ExpectRace *race) {\n   Printf(\"==================\\n\");\n }\n \n-void AnnotateFlushExpectedRaces(char *f, int l) {\n+void INTERFACE_ATTRIBUTE AnnotateFlushExpectedRaces(char *f, int l) {\n   SCOPED_ANNOTATION(AnnotateFlushExpectedRaces);\n   Lock lock(&dyn_ann_ctx->mtx);\n   while (dyn_ann_ctx->expect.next != &dyn_ann_ctx->expect) {\n@@ -253,110 +258,125 @@ void AnnotateFlushExpectedRaces(char *f, int l) {\n   }\n }\n \n-void AnnotateEnableRaceDetection(char *f, int l, int enable) {\n+void INTERFACE_ATTRIBUTE AnnotateEnableRaceDetection(\n+    char *f, int l, int enable) {\n   SCOPED_ANNOTATION(AnnotateEnableRaceDetection);\n   // FIXME: Reconsider this functionality later. It may be irrelevant.\n }\n \n-void AnnotateMutexIsUsedAsCondVar(char *f, int l, uptr mu) {\n+void INTERFACE_ATTRIBUTE AnnotateMutexIsUsedAsCondVar(\n+    char *f, int l, uptr mu) {\n   SCOPED_ANNOTATION(AnnotateMutexIsUsedAsCondVar);\n }\n \n-void AnnotatePCQGet(char *f, int l, uptr pcq) {\n+void INTERFACE_ATTRIBUTE AnnotatePCQGet(\n+    char *f, int l, uptr pcq) {\n   SCOPED_ANNOTATION(AnnotatePCQGet);\n }\n \n-void AnnotatePCQPut(char *f, int l, uptr pcq) {\n+void INTERFACE_ATTRIBUTE AnnotatePCQPut(\n+    char *f, int l, uptr pcq) {\n   SCOPED_ANNOTATION(AnnotatePCQPut);\n }\n \n-void AnnotatePCQDestroy(char *f, int l, uptr pcq) {\n+void INTERFACE_ATTRIBUTE AnnotatePCQDestroy(\n+    char *f, int l, uptr pcq) {\n   SCOPED_ANNOTATION(AnnotatePCQDestroy);\n }\n \n-void AnnotatePCQCreate(char *f, int l, uptr pcq) {\n+void INTERFACE_ATTRIBUTE AnnotatePCQCreate(\n+    char *f, int l, uptr pcq) {\n   SCOPED_ANNOTATION(AnnotatePCQCreate);\n }\n \n-void AnnotateExpectRace(char *f, int l, uptr mem, char *desc) {\n+void INTERFACE_ATTRIBUTE AnnotateExpectRace(\n+    char *f, int l, uptr mem, char *desc) {\n   SCOPED_ANNOTATION(AnnotateExpectRace);\n   Lock lock(&dyn_ann_ctx->mtx);\n   AddExpectRace(&dyn_ann_ctx->expect,\n                 f, l, mem, 1, desc);\n   DPrintf(\"Add expected race: %s addr=%zx %s:%d\\n\", desc, mem, f, l);\n }\n \n-static void BenignRaceImpl(char *f, int l, uptr mem, uptr size, char *desc) {\n+static void BenignRaceImpl(\n+    char *f, int l, uptr mem, uptr size, char *desc) {\n   Lock lock(&dyn_ann_ctx->mtx);\n   AddExpectRace(&dyn_ann_ctx->benign,\n                 f, l, mem, size, desc);\n   DPrintf(\"Add benign race: %s addr=%zx %s:%d\\n\", desc, mem, f, l);\n }\n \n // FIXME: Turn it off later. WTF is benign race?1?? Go talk to Hans Boehm.\n-void AnnotateBenignRaceSized(char *f, int l, uptr mem, uptr size, char *desc) {\n+void INTERFACE_ATTRIBUTE AnnotateBenignRaceSized(\n+    char *f, int l, uptr mem, uptr size, char *desc) {\n   SCOPED_ANNOTATION(AnnotateBenignRaceSized);\n   BenignRaceImpl(f, l, mem, size, desc);\n }\n \n-void AnnotateBenignRace(char *f, int l, uptr mem, char *desc) {\n+void INTERFACE_ATTRIBUTE AnnotateBenignRace(\n+    char *f, int l, uptr mem, char *desc) {\n   SCOPED_ANNOTATION(AnnotateBenignRace);\n   BenignRaceImpl(f, l, mem, 1, desc);\n }\n \n-void AnnotateIgnoreReadsBegin(char *f, int l) {\n+void INTERFACE_ATTRIBUTE AnnotateIgnoreReadsBegin(char *f, int l) {\n   SCOPED_ANNOTATION(AnnotateIgnoreReadsBegin);\n   IgnoreCtl(cur_thread(), false, true);\n }\n \n-void AnnotateIgnoreReadsEnd(char *f, int l) {\n+void INTERFACE_ATTRIBUTE AnnotateIgnoreReadsEnd(char *f, int l) {\n   SCOPED_ANNOTATION(AnnotateIgnoreReadsEnd);\n   IgnoreCtl(cur_thread(), false, false);\n }\n \n-void AnnotateIgnoreWritesBegin(char *f, int l) {\n+void INTERFACE_ATTRIBUTE AnnotateIgnoreWritesBegin(char *f, int l) {\n   SCOPED_ANNOTATION(AnnotateIgnoreWritesBegin);\n   IgnoreCtl(cur_thread(), true, true);\n }\n \n-void AnnotateIgnoreWritesEnd(char *f, int l) {\n+void INTERFACE_ATTRIBUTE AnnotateIgnoreWritesEnd(char *f, int l) {\n   SCOPED_ANNOTATION(AnnotateIgnoreWritesEnd);\n-  IgnoreCtl(cur_thread(), true, false);\n+  IgnoreCtl(thr, true, false);\n }\n \n-void AnnotatePublishMemoryRange(char *f, int l, uptr addr, uptr size) {\n+void INTERFACE_ATTRIBUTE AnnotatePublishMemoryRange(\n+    char *f, int l, uptr addr, uptr size) {\n   SCOPED_ANNOTATION(AnnotatePublishMemoryRange);\n }\n \n-void AnnotateUnpublishMemoryRange(char *f, int l, uptr addr, uptr size) {\n+void INTERFACE_ATTRIBUTE AnnotateUnpublishMemoryRange(\n+    char *f, int l, uptr addr, uptr size) {\n   SCOPED_ANNOTATION(AnnotateUnpublishMemoryRange);\n }\n \n-void AnnotateThreadName(char *f, int l, char *name) {\n+void INTERFACE_ATTRIBUTE AnnotateThreadName(\n+    char *f, int l, char *name) {\n   SCOPED_ANNOTATION(AnnotateThreadName);\n+  ThreadSetName(thr, name);\n }\n \n-void WTFAnnotateHappensBefore(char *f, int l, uptr addr) {\n+void INTERFACE_ATTRIBUTE WTFAnnotateHappensBefore(char *f, int l, uptr addr) {\n   SCOPED_ANNOTATION(AnnotateHappensBefore);\n }\n \n-void WTFAnnotateHappensAfter(char *f, int l, uptr addr) {\n+void INTERFACE_ATTRIBUTE WTFAnnotateHappensAfter(char *f, int l, uptr addr) {\n   SCOPED_ANNOTATION(AnnotateHappensAfter);\n }\n \n-void WTFAnnotateBenignRaceSized(char *f, int l, uptr mem, uptr sz, char *desc) {\n+void INTERFACE_ATTRIBUTE WTFAnnotateBenignRaceSized(\n+    char *f, int l, uptr mem, uptr sz, char *desc) {\n   SCOPED_ANNOTATION(AnnotateBenignRaceSized);\n }\n \n-int RunningOnValgrind() {\n+int INTERFACE_ATTRIBUTE RunningOnValgrind() {\n   return flags()->running_on_valgrind;\n }\n \n-double __attribute__((weak)) ValgrindSlowdown(void) {\n+double __attribute__((weak)) INTERFACE_ATTRIBUTE ValgrindSlowdown(void) {\n   return 10.0;\n }\n \n-const char *ThreadSanitizerQuery(const char *query) {\n+const char INTERFACE_ATTRIBUTE* ThreadSanitizerQuery(const char *query) {\n   if (internal_strcmp(query, \"pure_happens_before\") == 0)\n     return \"1\";\n   else"}, {"sha": "b10264cdd6f5a4aa58b59adf0a6bc443433a1109", "filename": "libsanitizer/tsan/tsan_interface_ann.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Ftsan%2Ftsan_interface_ann.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Ftsan%2Ftsan_interface_ann.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface_ann.h?ref=a04084545806300525bb07d0c827480f5282bb55", "patch": "@@ -12,15 +12,17 @@\n #ifndef TSAN_INTERFACE_ANN_H\n #define TSAN_INTERFACE_ANN_H\n \n+#include <sanitizer/common_interface_defs.h>\n+\n // This header should NOT include any other headers.\n // All functions in this header are extern \"C\" and start with __tsan_.\n \n #ifdef __cplusplus\n extern \"C\" {\n #endif\n \n-void __tsan_acquire(void *addr);\n-void __tsan_release(void *addr);\n+void __tsan_acquire(void *addr) SANITIZER_INTERFACE_ATTRIBUTE;\n+void __tsan_release(void *addr) SANITIZER_INTERFACE_ATTRIBUTE;\n \n #ifdef __cplusplus\n }  // extern \"C\""}, {"sha": "25f171ed07a5ab56d9e93413de0b541f4769af4f", "filename": "libsanitizer/tsan/tsan_interface_atomic.cc", "status": "modified", "additions": 92, "deletions": 27, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Ftsan%2Ftsan_interface_atomic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Ftsan%2Ftsan_interface_atomic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface_atomic.cc?ref=a04084545806300525bb07d0c827480f5282bb55", "patch": "@@ -112,34 +112,101 @@ static morder ConvertOrder(morder mo) {\n   return mo;\n }\n \n-template<typename T> T func_xchg(T v, T op) {\n-  return op;\n+template<typename T> T func_xchg(volatile T *v, T op) {\n+  return __sync_lock_test_and_set(v, op);\n }\n \n-template<typename T> T func_add(T v, T op) {\n-  return v + op;\n+template<typename T> T func_add(volatile T *v, T op) {\n+  return __sync_fetch_and_add(v, op);\n }\n \n-template<typename T> T func_sub(T v, T op) {\n-  return v - op;\n+template<typename T> T func_sub(volatile T *v, T op) {\n+  return __sync_fetch_and_sub(v, op);\n }\n \n-template<typename T> T func_and(T v, T op) {\n-  return v & op;\n+template<typename T> T func_and(volatile T *v, T op) {\n+  return __sync_fetch_and_and(v, op);\n }\n \n-template<typename T> T func_or(T v, T op) {\n-  return v | op;\n+template<typename T> T func_or(volatile T *v, T op) {\n+  return __sync_fetch_and_or(v, op);\n }\n \n-template<typename T> T func_xor(T v, T op) {\n-  return v ^ op;\n+template<typename T> T func_xor(volatile T *v, T op) {\n+  return __sync_fetch_and_xor(v, op);\n }\n \n-template<typename T> T func_nand(T v, T op) {\n-  return ~v & op;\n+template<typename T> T func_nand(volatile T *v, T op) {\n+  // clang does not support __sync_fetch_and_nand.\n+  T cmp = *v;\n+  for (;;) {\n+    T newv = ~(cmp & op);\n+    T cur = __sync_val_compare_and_swap(v, cmp, newv);\n+    if (cmp == cur)\n+      return cmp;\n+    cmp = cur;\n+  }\n+}\n+\n+template<typename T> T func_cas(volatile T *v, T cmp, T xch) {\n+  return __sync_val_compare_and_swap(v, cmp, xch);\n+}\n+\n+// clang does not support 128-bit atomic ops.\n+// Atomic ops are executed under tsan internal mutex,\n+// here we assume that the atomic variables are not accessed\n+// from non-instrumented code.\n+#ifndef __GCC_HAVE_SYNC_COMPARE_AND_SWAP_16\n+a128 func_xchg(volatile a128 *v, a128 op) {\n+  a128 cmp = *v;\n+  *v = op;\n+  return cmp;\n+}\n+\n+a128 func_add(volatile a128 *v, a128 op) {\n+  a128 cmp = *v;\n+  *v = cmp + op;\n+  return cmp;\n+}\n+\n+a128 func_sub(volatile a128 *v, a128 op) {\n+  a128 cmp = *v;\n+  *v = cmp - op;\n+  return cmp;\n+}\n+\n+a128 func_and(volatile a128 *v, a128 op) {\n+  a128 cmp = *v;\n+  *v = cmp & op;\n+  return cmp;\n+}\n+\n+a128 func_or(volatile a128 *v, a128 op) {\n+  a128 cmp = *v;\n+  *v = cmp | op;\n+  return cmp;\n }\n \n+a128 func_xor(volatile a128 *v, a128 op) {\n+  a128 cmp = *v;\n+  *v = cmp ^ op;\n+  return cmp;\n+}\n+\n+a128 func_nand(volatile a128 *v, a128 op) {\n+  a128 cmp = *v;\n+  *v = ~(cmp & op);\n+  return cmp;\n+}\n+\n+a128 func_cas(volatile a128 *v, a128 cmp, a128 xch) {\n+  a128 cur = *v;\n+  if (cur == cmp)\n+    *v = xch;\n+  return cur;\n+}\n+#endif\n+\n #define SCOPED_ATOMIC(func, ...) \\\n     mo = ConvertOrder(mo); \\\n     mo = flags()->force_seq_cst_atomics ? (morder)mo_seq_cst : mo; \\\n@@ -164,6 +231,7 @@ static T AtomicLoad(ThreadState *thr, uptr pc, const volatile T *a,\n   thr->clock.acquire(&s->clock);\n   T v = *a;\n   s->mtx.ReadUnlock();\n+  __sync_synchronize();\n   return v;\n }\n \n@@ -179,14 +247,15 @@ static void AtomicStore(ThreadState *thr, uptr pc, volatile T *a, T v,\n     *a = v;\n     return;\n   }\n+  __sync_synchronize();\n   SyncVar *s = CTX()->synctab.GetAndLock(thr, pc, (uptr)a, true);\n   thr->clock.set(thr->tid, thr->fast_state.epoch());\n   thr->clock.ReleaseStore(&s->clock);\n   *a = v;\n   s->mtx.Unlock();\n }\n \n-template<typename T, T (*F)(T v, T op)>\n+template<typename T, T (*F)(volatile T *v, T op)>\n static T AtomicRMW(ThreadState *thr, uptr pc, volatile T *a, T v, morder mo) {\n   SyncVar *s = CTX()->synctab.GetAndLock(thr, pc, (uptr)a, true);\n   thr->clock.set(thr->tid, thr->fast_state.epoch());\n@@ -196,10 +265,9 @@ static T AtomicRMW(ThreadState *thr, uptr pc, volatile T *a, T v, morder mo) {\n     thr->clock.release(&s->clock);\n   else if (IsAcquireOrder(mo))\n     thr->clock.acquire(&s->clock);\n-  T c = *a;\n-  *a = F(c, v);\n+  v = F(a, v);\n   s->mtx.Unlock();\n-  return c;\n+  return v;\n }\n \n template<typename T>\n@@ -256,16 +324,13 @@ static bool AtomicCAS(ThreadState *thr, uptr pc,\n     thr->clock.release(&s->clock);\n   else if (IsAcquireOrder(mo))\n     thr->clock.acquire(&s->clock);\n-  T cur = *a;\n-  bool res = false;\n-  if (cur == *c) {\n-    *a = v;\n-    res = true;\n-  } else {\n-    *c = cur;\n-  }\n+  T cc = *c;\n+  T pr = func_cas(a, cc, v);\n   s->mtx.Unlock();\n-  return res;\n+  if (pr == cc)\n+    return true;\n+  *c = pr;\n+  return false;\n }\n \n template<typename T>"}, {"sha": "9db31da0638dd6441c958e86161f885fc6ad1462", "filename": "libsanitizer/tsan/tsan_interface_atomic.h", "status": "modified", "additions": 68, "deletions": 62, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Ftsan%2Ftsan_interface_atomic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Ftsan%2Ftsan_interface_atomic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface_atomic.h?ref=a04084545806300525bb07d0c827480f5282bb55", "patch": "@@ -11,6 +11,10 @@\n #ifndef TSAN_INTERFACE_ATOMIC_H\n #define TSAN_INTERFACE_ATOMIC_H\n \n+#ifndef INTERFACE_ATTRIBUTE\n+# define INTERFACE_ATTRIBUTE __attribute__((visibility(\"default\")))\n+#endif\n+\n #ifdef __cplusplus\n extern \"C\" {\n #endif\n@@ -41,157 +45,159 @@ typedef enum {\n } __tsan_memory_order;\n \n __tsan_atomic8 __tsan_atomic8_load(const volatile __tsan_atomic8 *a,\n-    __tsan_memory_order mo);\n+    __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n __tsan_atomic16 __tsan_atomic16_load(const volatile __tsan_atomic16 *a,\n-    __tsan_memory_order mo);\n+    __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n __tsan_atomic32 __tsan_atomic32_load(const volatile __tsan_atomic32 *a,\n-    __tsan_memory_order mo);\n+    __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n __tsan_atomic64 __tsan_atomic64_load(const volatile __tsan_atomic64 *a,\n-    __tsan_memory_order mo);\n+    __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n __tsan_atomic128 __tsan_atomic128_load(const volatile __tsan_atomic128 *a,\n-    __tsan_memory_order mo);\n+    __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n \n void __tsan_atomic8_store(volatile __tsan_atomic8 *a, __tsan_atomic8 v,\n-    __tsan_memory_order mo);\n+    __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n void __tsan_atomic16_store(volatile __tsan_atomic16 *a, __tsan_atomic16 v,\n-    __tsan_memory_order mo);\n+    __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n void __tsan_atomic32_store(volatile __tsan_atomic32 *a, __tsan_atomic32 v,\n-    __tsan_memory_order mo);\n+    __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n void __tsan_atomic64_store(volatile __tsan_atomic64 *a, __tsan_atomic64 v,\n-    __tsan_memory_order mo);\n+    __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n void __tsan_atomic128_store(volatile __tsan_atomic128 *a, __tsan_atomic128 v,\n-    __tsan_memory_order mo);\n+    __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n \n __tsan_atomic8 __tsan_atomic8_exchange(volatile __tsan_atomic8 *a,\n-    __tsan_atomic8 v, __tsan_memory_order mo);\n+    __tsan_atomic8 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n __tsan_atomic16 __tsan_atomic16_exchange(volatile __tsan_atomic16 *a,\n-    __tsan_atomic16 v, __tsan_memory_order mo);\n+    __tsan_atomic16 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n __tsan_atomic32 __tsan_atomic32_exchange(volatile __tsan_atomic32 *a,\n-    __tsan_atomic32 v, __tsan_memory_order mo);\n+    __tsan_atomic32 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n __tsan_atomic64 __tsan_atomic64_exchange(volatile __tsan_atomic64 *a,\n-    __tsan_atomic64 v, __tsan_memory_order mo);\n+    __tsan_atomic64 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n __tsan_atomic128 __tsan_atomic128_exchange(volatile __tsan_atomic128 *a,\n-    __tsan_atomic128 v, __tsan_memory_order mo);\n+    __tsan_atomic128 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n \n __tsan_atomic8 __tsan_atomic8_fetch_add(volatile __tsan_atomic8 *a,\n-    __tsan_atomic8 v, __tsan_memory_order mo);\n+    __tsan_atomic8 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n __tsan_atomic16 __tsan_atomic16_fetch_add(volatile __tsan_atomic16 *a,\n-    __tsan_atomic16 v, __tsan_memory_order mo);\n+    __tsan_atomic16 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n __tsan_atomic32 __tsan_atomic32_fetch_add(volatile __tsan_atomic32 *a,\n-    __tsan_atomic32 v, __tsan_memory_order mo);\n+    __tsan_atomic32 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n __tsan_atomic64 __tsan_atomic64_fetch_add(volatile __tsan_atomic64 *a,\n-    __tsan_atomic64 v, __tsan_memory_order mo);\n+    __tsan_atomic64 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n __tsan_atomic128 __tsan_atomic128_fetch_add(volatile __tsan_atomic128 *a,\n-    __tsan_atomic128 v, __tsan_memory_order mo);\n+    __tsan_atomic128 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n \n __tsan_atomic8 __tsan_atomic8_fetch_sub(volatile __tsan_atomic8 *a,\n-    __tsan_atomic8 v, __tsan_memory_order mo);\n+    __tsan_atomic8 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n __tsan_atomic16 __tsan_atomic16_fetch_sub(volatile __tsan_atomic16 *a,\n-    __tsan_atomic16 v, __tsan_memory_order mo);\n+    __tsan_atomic16 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n __tsan_atomic32 __tsan_atomic32_fetch_sub(volatile __tsan_atomic32 *a,\n-    __tsan_atomic32 v, __tsan_memory_order mo);\n+    __tsan_atomic32 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n __tsan_atomic64 __tsan_atomic64_fetch_sub(volatile __tsan_atomic64 *a,\n-    __tsan_atomic64 v, __tsan_memory_order mo);\n+    __tsan_atomic64 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n __tsan_atomic128 __tsan_atomic128_fetch_sub(volatile __tsan_atomic128 *a,\n-    __tsan_atomic128 v, __tsan_memory_order mo);\n+    __tsan_atomic128 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n \n __tsan_atomic8 __tsan_atomic8_fetch_and(volatile __tsan_atomic8 *a,\n-    __tsan_atomic8 v, __tsan_memory_order mo);\n+    __tsan_atomic8 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n __tsan_atomic16 __tsan_atomic16_fetch_and(volatile __tsan_atomic16 *a,\n-    __tsan_atomic16 v, __tsan_memory_order mo);\n+    __tsan_atomic16 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n __tsan_atomic32 __tsan_atomic32_fetch_and(volatile __tsan_atomic32 *a,\n-    __tsan_atomic32 v, __tsan_memory_order mo);\n+    __tsan_atomic32 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n __tsan_atomic64 __tsan_atomic64_fetch_and(volatile __tsan_atomic64 *a,\n-    __tsan_atomic64 v, __tsan_memory_order mo);\n+    __tsan_atomic64 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n __tsan_atomic128 __tsan_atomic128_fetch_and(volatile __tsan_atomic128 *a,\n-    __tsan_atomic128 v, __tsan_memory_order mo);\n+    __tsan_atomic128 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n \n __tsan_atomic8 __tsan_atomic8_fetch_or(volatile __tsan_atomic8 *a,\n-    __tsan_atomic8 v, __tsan_memory_order mo);\n+    __tsan_atomic8 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n __tsan_atomic16 __tsan_atomic16_fetch_or(volatile __tsan_atomic16 *a,\n-    __tsan_atomic16 v, __tsan_memory_order mo);\n+    __tsan_atomic16 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n __tsan_atomic32 __tsan_atomic32_fetch_or(volatile __tsan_atomic32 *a,\n-    __tsan_atomic32 v, __tsan_memory_order mo);\n+    __tsan_atomic32 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n __tsan_atomic64 __tsan_atomic64_fetch_or(volatile __tsan_atomic64 *a,\n-    __tsan_atomic64 v, __tsan_memory_order mo);\n+    __tsan_atomic64 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n __tsan_atomic128 __tsan_atomic128_fetch_or(volatile __tsan_atomic128 *a,\n-    __tsan_atomic128 v, __tsan_memory_order mo);\n+    __tsan_atomic128 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n \n __tsan_atomic8 __tsan_atomic8_fetch_xor(volatile __tsan_atomic8 *a,\n-    __tsan_atomic8 v, __tsan_memory_order mo);\n+    __tsan_atomic8 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n __tsan_atomic16 __tsan_atomic16_fetch_xor(volatile __tsan_atomic16 *a,\n-    __tsan_atomic16 v, __tsan_memory_order mo);\n+    __tsan_atomic16 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n __tsan_atomic32 __tsan_atomic32_fetch_xor(volatile __tsan_atomic32 *a,\n-    __tsan_atomic32 v, __tsan_memory_order mo);\n+    __tsan_atomic32 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n __tsan_atomic64 __tsan_atomic64_fetch_xor(volatile __tsan_atomic64 *a,\n-    __tsan_atomic64 v, __tsan_memory_order mo);\n+    __tsan_atomic64 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n __tsan_atomic128 __tsan_atomic128_fetch_xor(volatile __tsan_atomic128 *a,\n-    __tsan_atomic128 v, __tsan_memory_order mo);\n+    __tsan_atomic128 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n \n __tsan_atomic8 __tsan_atomic8_fetch_nand(volatile __tsan_atomic8 *a,\n-    __tsan_atomic8 v, __tsan_memory_order mo);\n+    __tsan_atomic8 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n __tsan_atomic16 __tsan_atomic16_fetch_nand(volatile __tsan_atomic16 *a,\n-    __tsan_atomic16 v, __tsan_memory_order mo);\n+    __tsan_atomic16 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n __tsan_atomic32 __tsan_atomic32_fetch_nand(volatile __tsan_atomic32 *a,\n-    __tsan_atomic32 v, __tsan_memory_order mo);\n+    __tsan_atomic32 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n __tsan_atomic64 __tsan_atomic64_fetch_nand(volatile __tsan_atomic64 *a,\n-    __tsan_atomic64 v, __tsan_memory_order mo);\n+    __tsan_atomic64 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n __tsan_atomic128 __tsan_atomic128_fetch_nand(volatile __tsan_atomic128 *a,\n-    __tsan_atomic128 v, __tsan_memory_order mo);\n+    __tsan_atomic128 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n \n int __tsan_atomic8_compare_exchange_weak(volatile __tsan_atomic8 *a,\n     __tsan_atomic8 *c, __tsan_atomic8 v, __tsan_memory_order mo,\n-    __tsan_memory_order fail_mo);\n+    __tsan_memory_order fail_mo) INTERFACE_ATTRIBUTE;\n int __tsan_atomic16_compare_exchange_weak(volatile __tsan_atomic16 *a,\n     __tsan_atomic16 *c, __tsan_atomic16 v, __tsan_memory_order mo,\n-    __tsan_memory_order fail_mo);\n+    __tsan_memory_order fail_mo) INTERFACE_ATTRIBUTE;\n int __tsan_atomic32_compare_exchange_weak(volatile __tsan_atomic32 *a,\n     __tsan_atomic32 *c, __tsan_atomic32 v, __tsan_memory_order mo,\n-    __tsan_memory_order fail_mo);\n+    __tsan_memory_order fail_mo) INTERFACE_ATTRIBUTE;\n int __tsan_atomic64_compare_exchange_weak(volatile __tsan_atomic64 *a,\n     __tsan_atomic64 *c, __tsan_atomic64 v, __tsan_memory_order mo,\n-    __tsan_memory_order fail_mo);\n+    __tsan_memory_order fail_mo) INTERFACE_ATTRIBUTE;\n int __tsan_atomic128_compare_exchange_weak(volatile __tsan_atomic128 *a,\n     __tsan_atomic128 *c, __tsan_atomic128 v, __tsan_memory_order mo,\n-    __tsan_memory_order fail_mo);\n+    __tsan_memory_order fail_mo) INTERFACE_ATTRIBUTE;\n \n int __tsan_atomic8_compare_exchange_strong(volatile __tsan_atomic8 *a,\n     __tsan_atomic8 *c, __tsan_atomic8 v, __tsan_memory_order mo,\n-    __tsan_memory_order fail_mo);\n+    __tsan_memory_order fail_mo) INTERFACE_ATTRIBUTE;\n int __tsan_atomic16_compare_exchange_strong(volatile __tsan_atomic16 *a,\n     __tsan_atomic16 *c, __tsan_atomic16 v, __tsan_memory_order mo,\n-    __tsan_memory_order fail_mo);\n+    __tsan_memory_order fail_mo) INTERFACE_ATTRIBUTE;\n int __tsan_atomic32_compare_exchange_strong(volatile __tsan_atomic32 *a,\n     __tsan_atomic32 *c, __tsan_atomic32 v, __tsan_memory_order mo,\n-    __tsan_memory_order fail_mo);\n+    __tsan_memory_order fail_mo) INTERFACE_ATTRIBUTE;\n int __tsan_atomic64_compare_exchange_strong(volatile __tsan_atomic64 *a,\n     __tsan_atomic64 *c, __tsan_atomic64 v, __tsan_memory_order mo,\n-    __tsan_memory_order fail_mo);\n+    __tsan_memory_order fail_mo) INTERFACE_ATTRIBUTE;\n int __tsan_atomic128_compare_exchange_strong(volatile __tsan_atomic128 *a,\n     __tsan_atomic128 *c, __tsan_atomic128 v, __tsan_memory_order mo,\n-    __tsan_memory_order fail_mo);\n+    __tsan_memory_order fail_mo) INTERFACE_ATTRIBUTE;\n \n __tsan_atomic8 __tsan_atomic8_compare_exchange_val(\n     volatile __tsan_atomic8 *a, __tsan_atomic8 c, __tsan_atomic8 v,\n-    __tsan_memory_order mo, __tsan_memory_order fail_mo);\n+    __tsan_memory_order mo, __tsan_memory_order fail_mo) INTERFACE_ATTRIBUTE;\n __tsan_atomic16 __tsan_atomic16_compare_exchange_val(\n     volatile __tsan_atomic16 *a, __tsan_atomic16 c, __tsan_atomic16 v,\n-    __tsan_memory_order mo, __tsan_memory_order fail_mo);\n+    __tsan_memory_order mo, __tsan_memory_order fail_mo) INTERFACE_ATTRIBUTE;\n __tsan_atomic32 __tsan_atomic32_compare_exchange_val(\n     volatile __tsan_atomic32 *a, __tsan_atomic32 c, __tsan_atomic32 v,\n-    __tsan_memory_order mo, __tsan_memory_order fail_mo);\n+    __tsan_memory_order mo, __tsan_memory_order fail_mo) INTERFACE_ATTRIBUTE;\n __tsan_atomic64 __tsan_atomic64_compare_exchange_val(\n     volatile __tsan_atomic64 *a, __tsan_atomic64 c, __tsan_atomic64 v,\n-    __tsan_memory_order mo, __tsan_memory_order fail_mo);\n+    __tsan_memory_order mo, __tsan_memory_order fail_mo) INTERFACE_ATTRIBUTE;\n __tsan_atomic128 __tsan_atomic128_compare_exchange_val(\n     volatile __tsan_atomic128 *a, __tsan_atomic128 c, __tsan_atomic128 v,\n-    __tsan_memory_order mo, __tsan_memory_order fail_mo);\n+    __tsan_memory_order mo, __tsan_memory_order fail_mo) INTERFACE_ATTRIBUTE;\n \n-void __tsan_atomic_thread_fence(__tsan_memory_order mo);\n-void __tsan_atomic_signal_fence(__tsan_memory_order mo);\n+void __tsan_atomic_thread_fence(__tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n+void __tsan_atomic_signal_fence(__tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n \n #ifdef __cplusplus\n }  // extern \"C\"\n #endif\n \n+#undef INTERFACE_ATTRIBUTE\n+\n #endif  // #ifndef TSAN_INTERFACE_ATOMIC_H"}, {"sha": "5c776f14e8a600c41d5bba6245563ad93bb7c6ff", "filename": "libsanitizer/tsan/tsan_platform.h", "status": "modified", "additions": 57, "deletions": 1, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Ftsan%2Ftsan_platform.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Ftsan%2Ftsan_platform.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform.h?ref=a04084545806300525bb07d0c827480f5282bb55", "patch": "@@ -10,10 +10,53 @@\n // Platform-specific code.\n //===----------------------------------------------------------------------===//\n \n+/*\n+C++ linux memory layout:\n+0000 0000 0000 - 03c0 0000 0000: protected\n+03c0 0000 0000 - 1000 0000 0000: shadow\n+1000 0000 0000 - 6000 0000 0000: protected\n+6000 0000 0000 - 6200 0000 0000: traces\n+6200 0000 0000 - 7d00 0000 0000: -\n+7d00 0000 0000 - 7e00 0000 0000: heap\n+7e00 0000 0000 - 7fff ffff ffff: modules and main thread stack\n+\n+C++ COMPAT linux memory layout:\n+0000 0000 0000 - 0400 0000 0000: protected\n+0400 0000 0000 - 1000 0000 0000: shadow\n+1000 0000 0000 - 2900 0000 0000: protected\n+2900 0000 0000 - 2c00 0000 0000: modules\n+2c00 0000 0000 - 6000 0000 0000: -\n+6000 0000 0000 - 6200 0000 0000: traces\n+6200 0000 0000 - 7d00 0000 0000: -\n+7d00 0000 0000 - 7e00 0000 0000: heap\n+7e00 0000 0000 - 7f00 0000 0000: -\n+7f00 0000 0000 - 7fff ffff ffff: main thread stack\n+\n+Go linux and darwin memory layout:\n+0000 0000 0000 - 0000 1000 0000: executable\n+0000 1000 0000 - 00f8 0000 0000: -\n+00f8 0000 0000 - 0118 0000 0000: heap\n+0118 0000 0000 - 1000 0000 0000: -\n+1000 0000 0000 - 1460 0000 0000: shadow\n+1460 0000 0000 - 6000 0000 0000: -\n+6000 0000 0000 - 6200 0000 0000: traces\n+6200 0000 0000 - 7fff ffff ffff: -\n+\n+Go windows memory layout:\n+0000 0000 0000 - 0000 1000 0000: executable\n+0000 1000 0000 - 00f8 0000 0000: -\n+00f8 0000 0000 - 0118 0000 0000: heap\n+0118 0000 0000 - 0100 0000 0000: -\n+0100 0000 0000 - 0560 0000 0000: shadow\n+0560 0000 0000 - 0760 0000 0000: traces\n+0760 0000 0000 - 07ff ffff ffff: -\n+*/\n+\n #ifndef TSAN_PLATFORM_H\n #define TSAN_PLATFORM_H\n \n-#include \"tsan_rtl.h\"\n+#include \"tsan_defs.h\"\n+#include \"tsan_trace.h\"\n \n #if defined(__LP64__) || defined(_WIN64)\n namespace __tsan {\n@@ -39,6 +82,13 @@ static const uptr kLinuxAppMemEnd = 0x7fffffffffffULL;\n \n static const uptr kLinuxAppMemMsk = 0x7c0000000000ULL;\n \n+#if defined(_WIN32)\n+const uptr kTraceMemBegin = 0x056000000000ULL;\n+#else\n+const uptr kTraceMemBegin = 0x600000000000ULL;\n+#endif\n+const uptr kTraceMemSize = 0x020000000000ULL;\n+\n // This has to be a macro to allow constant initialization of constants below.\n #ifndef TSAN_GO\n #define MemToShadow(addr) \\\n@@ -85,6 +135,12 @@ void FlushShadowMemory();\n \n const char *InitializePlatform();\n void FinalizePlatform();\n+void MapThreadTrace(uptr addr, uptr size);\n+uptr ALWAYS_INLINE INLINE GetThreadTrace(int tid) {\n+  uptr p = kTraceMemBegin + (uptr)tid * kTraceSize * sizeof(Event);\n+  DCHECK_LT(p, kTraceMemBegin + kTraceMemSize);\n+  return p;\n+}\n \n void internal_start_thread(void(*func)(void*), void *arg);\n "}, {"sha": "34221af16c9ef5776bcd35cd1db1b26e77269e9a", "filename": "libsanitizer/tsan/tsan_platform_linux.cc", "status": "modified", "additions": 41, "deletions": 9, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Ftsan%2Ftsan_platform_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Ftsan%2Ftsan_platform_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform_linux.cc?ref=a04084545806300525bb07d0c827480f5282bb55", "patch": "@@ -101,7 +101,7 @@ void InitializeShadowMemory() {\n   const uptr kClosedLowBeg  = 0x200000;\n   const uptr kClosedLowEnd  = kLinuxShadowBeg - 1;\n   const uptr kClosedMidBeg = kLinuxShadowEnd + 1;\n-  const uptr kClosedMidEnd = kLinuxAppMemBeg - 1;\n+  const uptr kClosedMidEnd = min(kLinuxAppMemBeg, kTraceMemBegin);\n   ProtectRange(kClosedLowBeg, kClosedLowEnd);\n   ProtectRange(kClosedMidBeg, kClosedMidEnd);\n   DPrintf(\"kClosedLow   %zx-%zx (%zuGB)\\n\",\n@@ -118,6 +118,16 @@ void InitializeShadowMemory() {\n }\n #endif\n \n+void MapThreadTrace(uptr addr, uptr size) {\n+  DPrintf(\"Mapping trace at %p-%p(0x%zx)\\n\", addr, addr + size, size);\n+  CHECK_GE(addr, kTraceMemBegin);\n+  CHECK_LE(addr + size, kTraceMemBegin + kTraceMemSize);\n+  if (addr != (uptr)MmapFixedNoReserve(addr, size)) {\n+    Printf(\"FATAL: ThreadSanitizer can not mmap thread trace\\n\");\n+    Die();\n+  }\n+}\n+\n static uptr g_data_start;\n static uptr g_data_end;\n \n@@ -190,28 +200,50 @@ static int InitTlsSize() {\n }\n #endif  // #ifndef TSAN_GO\n \n+static rlim_t getlim(int res) {\n+  rlimit rlim;\n+  CHECK_EQ(0, getrlimit(res, &rlim));\n+  return rlim.rlim_cur;\n+}\n+\n+static void setlim(int res, rlim_t lim) {\n+  // The following magic is to prevent clang from replacing it with memset.\n+  volatile rlimit rlim;\n+  rlim.rlim_cur = lim;\n+  rlim.rlim_max = lim;\n+  setrlimit(res, (rlimit*)&rlim);\n+}\n+\n const char *InitializePlatform() {\n   void *p = 0;\n   if (sizeof(p) == 8) {\n     // Disable core dumps, dumping of 16TB usually takes a bit long.\n-    // The following magic is to prevent clang from replacing it with memset.\n-    volatile rlimit lim;\n-    lim.rlim_cur = 0;\n-    lim.rlim_max = 0;\n-    setrlimit(RLIMIT_CORE, (rlimit*)&lim);\n+    setlim(RLIMIT_CORE, 0);\n   }\n+  bool reexec = false;\n   // TSan doesn't play well with unlimited stack size (as stack\n   // overlaps with shadow memory). If we detect unlimited stack size,\n   // we re-exec the program with limited stack size as a best effort.\n-  if (StackSizeIsUnlimited()) {\n-    const uptr kMaxStackSize = 32 * 1024 * 1024;  // 32 Mb\n+  if (getlim(RLIMIT_STACK) == (rlim_t)-1) {\n+    const uptr kMaxStackSize = 32 * 1024 * 1024;\n     Report(\"WARNING: Program is run with unlimited stack size, which \"\n            \"wouldn't work with ThreadSanitizer.\\n\");\n     Report(\"Re-execing with stack size limited to %zd bytes.\\n\", kMaxStackSize);\n     SetStackSizeLimitInBytes(kMaxStackSize);\n-    ReExec();\n+    reexec = true;\n   }\n \n+  if (getlim(RLIMIT_AS) != (rlim_t)-1) {\n+    Report(\"WARNING: Program is run with limited virtual address space, which \"\n+           \"wouldn't work with ThreadSanitizer.\\n\");\n+    Report(\"Re-execing with unlimited virtual address space.\\n\");\n+    setlim(RLIMIT_AS, -1);\n+    reexec = true;\n+  }\n+\n+  if (reexec)\n+    ReExec();\n+\n #ifndef TSAN_GO\n   CheckPIE();\n   g_tls_size = (uptr)InitTlsSize();"}, {"sha": "18870a76eb7e8b85b73cb63e16ec3f122e17aa41", "filename": "libsanitizer/tsan/tsan_report.cc", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Ftsan%2Ftsan_report.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Ftsan%2Ftsan_report.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_report.cc?ref=a04084545806300525bb07d0c827480f5282bb55", "patch": "@@ -24,6 +24,7 @@ ReportDesc::ReportDesc()\n }\n \n ReportDesc::~ReportDesc() {\n+  // FIXME(dvyukov): it must be leaking a lot of memory.\n }\n \n #ifndef TSAN_GO\n@@ -78,8 +79,9 @@ static void PrintMop(const ReportMop *mop, bool first) {\n \n static void PrintLocation(const ReportLocation *loc) {\n   if (loc->type == ReportLocationGlobal) {\n-    Printf(\"  Location is global '%s' of size %zu at %zx %s:%d\\n\",\n-               loc->name, loc->size, loc->addr, loc->file, loc->line);\n+    Printf(\"  Location is global '%s' of size %zu at %zx %s:%d (%s+%p)\\n\\n\",\n+               loc->name, loc->size, loc->addr, loc->file, loc->line,\n+               loc->module, loc->offset);\n   } else if (loc->type == ReportLocationHeap) {\n     Printf(\"  Location is heap block of size %zu at %p allocated\",\n         loc->size, loc->addr);\n@@ -89,7 +91,7 @@ static void PrintLocation(const ReportLocation *loc) {\n       Printf(\" by thread %d:\\n\", loc->tid);\n     PrintStack(loc->stack);\n   } else if (loc->type == ReportLocationStack) {\n-    Printf(\"  Location is stack of thread %d:\\n\", loc->tid);\n+    Printf(\"  Location is stack of thread %d:\\n\\n\", loc->tid);\n   }\n }\n \n@@ -149,6 +151,10 @@ void PrintReport(const ReportDesc *rep) {\n #else\n \n void PrintStack(const ReportStack *ent) {\n+  if (ent == 0) {\n+    Printf(\"  [failed to restore the stack]\\n\\n\");\n+    return;\n+  }\n   for (int i = 0; ent; ent = ent->next, i++) {\n     Printf(\"  %s()\\n      %s:%d +0x%zx\\n\",\n         ent->func, ent->file, ent->line, (void*)ent->offset);"}, {"sha": "6776f1e078c0c92a2c16ed499e4daffb7fdcda1a", "filename": "libsanitizer/tsan/tsan_report.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Ftsan%2Ftsan_report.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Ftsan%2Ftsan_report.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_report.h?ref=a04084545806300525bb07d0c827480f5282bb55", "patch": "@@ -56,6 +56,8 @@ struct ReportLocation {\n   ReportLocationType type;\n   uptr addr;\n   uptr size;\n+  char *module;\n+  uptr offset;\n   int tid;\n   char *name;\n   char *file;"}, {"sha": "2778ac3e49062c176ad2c2018c2b238dabf674e4", "filename": "libsanitizer/tsan/tsan_rtl.cc", "status": "modified", "additions": 29, "deletions": 7, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Ftsan%2Ftsan_rtl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Ftsan%2Ftsan_rtl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl.cc?ref=a04084545806300525bb07d0c827480f5282bb55", "patch": "@@ -82,7 +82,8 @@ ThreadContext::ThreadContext(int tid)\n   , epoch0()\n   , epoch1()\n   , dead_info()\n-  , dead_next() {\n+  , dead_next()\n+  , name() {\n }\n \n static void WriteMemoryProfile(char *buf, uptr buf_size, int num) {\n@@ -189,7 +190,12 @@ void Initialize(ThreadState *thr) {\n   ctx->dead_list_tail = 0;\n   InitializeFlags(&ctx->flags, env);\n   // Setup correct file descriptor for error reports.\n-  __sanitizer_set_report_fd(flags()->log_fileno);\n+  if (internal_strcmp(flags()->log_path, \"stdout\") == 0)\n+    __sanitizer_set_report_fd(kStdoutFd);\n+  else if (internal_strcmp(flags()->log_path, \"stderr\") == 0)\n+    __sanitizer_set_report_fd(kStderrFd);\n+  else\n+    __sanitizer_set_report_path(flags()->log_path);\n   InitializeSuppressions();\n #ifndef TSAN_GO\n   // Initialize external symbolizer before internal threads are started.\n@@ -279,13 +285,27 @@ void TraceSwitch(ThreadState *thr) {\n   thr->nomalloc++;\n   ScopedInRtl in_rtl;\n   Lock l(&thr->trace.mtx);\n-  unsigned trace = (thr->fast_state.epoch() / kTracePartSize) % kTraceParts;\n+  unsigned trace = (thr->fast_state.epoch() / kTracePartSize) % TraceParts();\n   TraceHeader *hdr = &thr->trace.headers[trace];\n   hdr->epoch0 = thr->fast_state.epoch();\n   hdr->stack0.ObtainCurrent(thr, 0);\n   thr->nomalloc--;\n }\n \n+uptr TraceTopPC(ThreadState *thr) {\n+  Event *events = (Event*)GetThreadTrace(thr->tid);\n+  uptr pc = events[thr->fast_state.GetTracePos()];\n+  return pc;\n+}\n+\n+uptr TraceSize() {\n+  return (uptr)(1ull << (kTracePartSizeBits + flags()->history_size + 1));\n+}\n+\n+uptr TraceParts() {\n+  return TraceSize() / kTracePartSize;\n+}\n+\n #ifndef TSAN_GO\n extern \"C\" void __tsan_trace_switch() {\n   TraceSwitch(cur_thread());\n@@ -342,7 +362,7 @@ static inline bool OldIsInSameSynchEpoch(Shadow old, ThreadState *thr) {\n }\n \n static inline bool HappensBefore(Shadow old, ThreadState *thr) {\n-  return thr->clock.get(old.tid()) >= old.epoch();\n+  return thr->clock.get(old.TidWithIgnore()) >= old.epoch();\n }\n \n ALWAYS_INLINE\n@@ -451,7 +471,7 @@ void MemoryAccess(ThreadState *thr, uptr pc, uptr addr,\n \n   // We must not store to the trace if we do not store to the shadow.\n   // That is, this call must be moved somewhere below.\n-  TraceAddEvent(thr, fast_state.epoch(), EventTypeMop, pc);\n+  TraceAddEvent(thr, fast_state, EventTypeMop, pc);\n \n   MemoryAccessImpl(thr, addr, kAccessSizeLog, kAccessIsWrite,\n       shadow_mem, cur);\n@@ -502,6 +522,7 @@ void MemoryResetRange(ThreadState *thr, uptr pc, uptr addr, uptr size) {\n void MemoryRangeFreed(ThreadState *thr, uptr pc, uptr addr, uptr size) {\n   MemoryAccessRange(thr, pc, addr, size, true);\n   Shadow s(thr->fast_state);\n+  s.ClearIgnoreBit();\n   s.MarkAsFreed();\n   s.SetWrite(true);\n   s.SetAddr0AndSizeLog(0, 3);\n@@ -510,6 +531,7 @@ void MemoryRangeFreed(ThreadState *thr, uptr pc, uptr addr, uptr size) {\n \n void MemoryRangeImitateWrite(ThreadState *thr, uptr pc, uptr addr, uptr size) {\n   Shadow s(thr->fast_state);\n+  s.ClearIgnoreBit();\n   s.SetWrite(true);\n   s.SetAddr0AndSizeLog(0, 3);\n   MemoryRangeSet(thr, pc, addr, size, s.raw());\n@@ -521,7 +543,7 @@ void FuncEntry(ThreadState *thr, uptr pc) {\n   StatInc(thr, StatFuncEnter);\n   DPrintf2(\"#%d: FuncEntry %p\\n\", (int)thr->fast_state.tid(), (void*)pc);\n   thr->fast_state.IncrementEpoch();\n-  TraceAddEvent(thr, thr->fast_state.epoch(), EventTypeFuncEnter, pc);\n+  TraceAddEvent(thr, thr->fast_state, EventTypeFuncEnter, pc);\n \n   // Shadow stack maintenance can be replaced with\n   // stack unwinding during trace switch (which presumably must be faster).\n@@ -551,7 +573,7 @@ void FuncExit(ThreadState *thr) {\n   StatInc(thr, StatFuncExit);\n   DPrintf2(\"#%d: FuncExit\\n\", (int)thr->fast_state.tid());\n   thr->fast_state.IncrementEpoch();\n-  TraceAddEvent(thr, thr->fast_state.epoch(), EventTypeFuncExit, 0);\n+  TraceAddEvent(thr, thr->fast_state, EventTypeFuncExit, 0);\n \n   DCHECK_GT(thr->shadow_stack_pos, &thr->shadow_stack[0]);\n #ifndef TSAN_GO"}, {"sha": "56fcad1412f900a65be32de7056144d95d107ca8", "filename": "libsanitizer/tsan/tsan_rtl.h", "status": "modified", "additions": 58, "deletions": 15, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Ftsan%2Ftsan_rtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Ftsan%2Ftsan_rtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl.h?ref=a04084545806300525bb07d0c827480f5282bb55", "patch": "@@ -25,14 +25,19 @@\n #define TSAN_RTL_H\n \n #include \"sanitizer_common/sanitizer_common.h\"\n-#include \"sanitizer_common/sanitizer_allocator64.h\"\n+#include \"sanitizer_common/sanitizer_allocator.h\"\n #include \"tsan_clock.h\"\n #include \"tsan_defs.h\"\n #include \"tsan_flags.h\"\n #include \"tsan_sync.h\"\n #include \"tsan_trace.h\"\n #include \"tsan_vector.h\"\n #include \"tsan_report.h\"\n+#include \"tsan_platform.h\"\n+\n+#if SANITIZER_WORDSIZE != 64\n+# error \"ThreadSanitizer is supported only on 64-bit platforms\"\n+#endif\n \n namespace __tsan {\n \n@@ -55,8 +60,7 @@ const uptr kAllocatorSize  =  0x10000000000ULL;  // 1T.\n \n typedef SizeClassAllocator64<kAllocatorSpace, kAllocatorSize, sizeof(MBlock),\n     DefaultSizeClassMap> PrimaryAllocator;\n-typedef SizeClassAllocatorLocalCache<PrimaryAllocator::kNumClasses,\n-    PrimaryAllocator> AllocatorCache;\n+typedef SizeClassAllocatorLocalCache<PrimaryAllocator> AllocatorCache;\n typedef LargeMmapAllocator SecondaryAllocator;\n typedef CombinedAllocator<PrimaryAllocator, AllocatorCache,\n     SecondaryAllocator> Allocator;\n@@ -67,18 +71,19 @@ void TsanCheckFailed(const char *file, int line, const char *cond,\n                      u64 v1, u64 v2);\n \n // FastState (from most significant bit):\n-//   unused          : 1\n+//   ignore          : 1\n //   tid             : kTidBits\n //   epoch           : kClkBits\n //   unused          : -\n-//   ignore_bit      : 1\n+//   history_size    : 3\n class FastState {\n  public:\n   FastState(u64 tid, u64 epoch) {\n     x_ = tid << kTidShift;\n     x_ |= epoch << kClkShift;\n-    DCHECK(tid == this->tid());\n-    DCHECK(epoch == this->epoch());\n+    DCHECK_EQ(tid, this->tid());\n+    DCHECK_EQ(epoch, this->epoch());\n+    DCHECK_EQ(GetIgnoreBit(), false);\n   }\n \n   explicit FastState(u64 x)\n@@ -90,6 +95,11 @@ class FastState {\n   }\n \n   u64 tid() const {\n+    u64 res = (x_ & ~kIgnoreBit) >> kTidShift;\n+    return res;\n+  }\n+\n+  u64 TidWithIgnore() const {\n     u64 res = x_ >> kTidShift;\n     return res;\n   }\n@@ -108,13 +118,34 @@ class FastState {\n \n   void SetIgnoreBit() { x_ |= kIgnoreBit; }\n   void ClearIgnoreBit() { x_ &= ~kIgnoreBit; }\n-  bool GetIgnoreBit() const { return x_ & kIgnoreBit; }\n+  bool GetIgnoreBit() const { return (s64)x_ < 0; }\n+\n+  void SetHistorySize(int hs) {\n+    CHECK_GE(hs, 0);\n+    CHECK_LE(hs, 7);\n+    x_ = (x_ & ~7) | hs;\n+  }\n+\n+  int GetHistorySize() const {\n+    return (int)(x_ & 7);\n+  }\n+\n+  void ClearHistorySize() {\n+    x_ &= ~7;\n+  }\n+\n+  u64 GetTracePos() const {\n+    const int hs = GetHistorySize();\n+    // When hs == 0, the trace consists of 2 parts.\n+    const u64 mask = (1ull << (kTracePartSizeBits + hs + 1)) - 1;\n+    return epoch() & mask;\n+  }\n \n  private:\n   friend class Shadow;\n   static const int kTidShift = 64 - kTidBits - 1;\n   static const int kClkShift = kTidShift - kClkBits;\n-  static const u64 kIgnoreBit = 1ull;\n+  static const u64 kIgnoreBit = 1ull << 63;\n   static const u64 kFreedBit = 1ull << 63;\n   u64 x_;\n };\n@@ -128,9 +159,14 @@ class FastState {\n //   addr0           : 3\n class Shadow : public FastState {\n  public:\n-  explicit Shadow(u64 x) : FastState(x) { }\n+  explicit Shadow(u64 x)\n+      : FastState(x) {\n+  }\n \n-  explicit Shadow(const FastState &s) : FastState(s.x_) { }\n+  explicit Shadow(const FastState &s)\n+      : FastState(s.x_) {\n+    ClearHistorySize();\n+  }\n \n   void SetAddr0AndSizeLog(u64 addr0, unsigned kAccessSizeLog) {\n     DCHECK_EQ(x_ & 31, 0);\n@@ -152,7 +188,7 @@ class Shadow : public FastState {\n \n   static inline bool TidsAreEqual(const Shadow s1, const Shadow s2) {\n     u64 shifted_xor = (s1.x_ ^ s2.x_) >> kTidShift;\n-    DCHECK_EQ(shifted_xor == 0, s1.tid() == s2.tid());\n+    DCHECK_EQ(shifted_xor == 0, s1.TidWithIgnore() == s2.TidWithIgnore());\n     return shifted_xor == 0;\n   }\n \n@@ -335,6 +371,7 @@ struct ThreadContext {\n   StackTrace creation_stack;\n   ThreadDeadInfo *dead_info;\n   ThreadContext *dead_next;  // In dead thread list.\n+  char *name;  // As annotated by user.\n \n   explicit ThreadContext(int tid);\n };\n@@ -491,6 +528,7 @@ int ThreadTid(ThreadState *thr, uptr pc, uptr uid);\n void ThreadJoin(ThreadState *thr, uptr pc, int tid);\n void ThreadDetach(ThreadState *thr, uptr pc, int tid);\n void ThreadFinalize(ThreadState *thr);\n+void ThreadSetName(ThreadState *thr, const char *name);\n int ThreadCount(ThreadState *thr);\n void ProcessPendingSignals(ThreadState *thr);\n \n@@ -531,19 +569,24 @@ void AfterSleep(ThreadState *thr, uptr pc);\n #endif\n \n void TraceSwitch(ThreadState *thr);\n+uptr TraceTopPC(ThreadState *thr);\n+uptr TraceSize();\n+uptr TraceParts();\n \n extern \"C\" void __tsan_trace_switch();\n-void ALWAYS_INLINE INLINE TraceAddEvent(ThreadState *thr, u64 epoch,\n+void ALWAYS_INLINE INLINE TraceAddEvent(ThreadState *thr, FastState fs,\n                                         EventType typ, uptr addr) {\n   StatInc(thr, StatEvents);\n-  if (UNLIKELY((epoch % kTracePartSize) == 0)) {\n+  u64 pos = fs.GetTracePos();\n+  if (UNLIKELY((pos % kTracePartSize) == 0)) {\n #ifndef TSAN_GO\n     HACKY_CALL(__tsan_trace_switch);\n #else\n     TraceSwitch(thr);\n #endif\n   }\n-  Event *evp = &thr->trace.events[epoch % kTraceSize];\n+  Event *trace = (Event*)GetThreadTrace(fs.tid());\n+  Event *evp = &trace[pos];\n   Event ev = (u64)addr | ((u64)typ << 61);\n   *evp = ev;\n }"}, {"sha": "e5b43be6a4972796a4ff81f1fcb3174f4e91ad34", "filename": "libsanitizer/tsan/tsan_rtl_mutex.cc", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Ftsan%2Ftsan_rtl_mutex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Ftsan%2Ftsan_rtl_mutex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_mutex.cc?ref=a04084545806300525bb07d0c827480f5282bb55", "patch": "@@ -73,7 +73,7 @@ void MutexLock(ThreadState *thr, uptr pc, uptr addr) {\n   if (IsAppMem(addr))\n     MemoryRead1Byte(thr, pc, addr);\n   thr->fast_state.IncrementEpoch();\n-  TraceAddEvent(thr, thr->fast_state.epoch(), EventTypeLock, addr);\n+  TraceAddEvent(thr, thr->fast_state, EventTypeLock, addr);\n   SyncVar *s = CTX()->synctab.GetAndLock(thr, pc, addr, true);\n   if (s->owner_tid == SyncVar::kInvalidTid) {\n     CHECK_EQ(s->recursion, 0);\n@@ -105,7 +105,7 @@ void MutexUnlock(ThreadState *thr, uptr pc, uptr addr) {\n   if (IsAppMem(addr))\n     MemoryRead1Byte(thr, pc, addr);\n   thr->fast_state.IncrementEpoch();\n-  TraceAddEvent(thr, thr->fast_state.epoch(), EventTypeUnlock, addr);\n+  TraceAddEvent(thr, thr->fast_state, EventTypeUnlock, addr);\n   SyncVar *s = CTX()->synctab.GetAndLock(thr, pc, addr, true);\n   if (s->recursion == 0) {\n     if (!s->is_broken) {\n@@ -142,7 +142,7 @@ void MutexReadLock(ThreadState *thr, uptr pc, uptr addr) {\n   if (IsAppMem(addr))\n     MemoryRead1Byte(thr, pc, addr);\n   thr->fast_state.IncrementEpoch();\n-  TraceAddEvent(thr, thr->fast_state.epoch(), EventTypeRLock, addr);\n+  TraceAddEvent(thr, thr->fast_state, EventTypeRLock, addr);\n   SyncVar *s = CTX()->synctab.GetAndLock(thr, pc, addr, false);\n   if (s->owner_tid != SyncVar::kInvalidTid) {\n     Printf(\"ThreadSanitizer WARNING: read lock of a write locked mutex\\n\");\n@@ -162,7 +162,7 @@ void MutexReadUnlock(ThreadState *thr, uptr pc, uptr addr) {\n   if (IsAppMem(addr))\n     MemoryRead1Byte(thr, pc, addr);\n   thr->fast_state.IncrementEpoch();\n-  TraceAddEvent(thr, thr->fast_state.epoch(), EventTypeRUnlock, addr);\n+  TraceAddEvent(thr, thr->fast_state, EventTypeRUnlock, addr);\n   SyncVar *s = CTX()->synctab.GetAndLock(thr, pc, addr, true);\n   if (s->owner_tid != SyncVar::kInvalidTid) {\n     Printf(\"ThreadSanitizer WARNING: read unlock of a write \"\n@@ -186,7 +186,7 @@ void MutexReadOrWriteUnlock(ThreadState *thr, uptr pc, uptr addr) {\n     // Seems to be read unlock.\n     StatInc(thr, StatMutexReadUnlock);\n     thr->fast_state.IncrementEpoch();\n-    TraceAddEvent(thr, thr->fast_state.epoch(), EventTypeRUnlock, addr);\n+    TraceAddEvent(thr, thr->fast_state, EventTypeRUnlock, addr);\n     thr->clock.set(thr->tid, thr->fast_state.epoch());\n     thr->fast_synch_epoch = thr->fast_state.epoch();\n     thr->clock.release(&s->read_clock);\n@@ -203,7 +203,7 @@ void MutexReadOrWriteUnlock(ThreadState *thr, uptr pc, uptr addr) {\n       // First, it's a bug to increment the epoch w/o writing to the trace.\n       // Then, the acquire/release logic can be factored out as well.\n       thr->fast_state.IncrementEpoch();\n-      TraceAddEvent(thr, thr->fast_state.epoch(), EventTypeUnlock, addr);\n+      TraceAddEvent(thr, thr->fast_state, EventTypeUnlock, addr);\n       thr->clock.set(thr->tid, thr->fast_state.epoch());\n       thr->fast_synch_epoch = thr->fast_state.epoch();\n       thr->clock.ReleaseStore(&s->clock);"}, {"sha": "6aae6cf6e8afcbf7c512defddcf1ca6bbad8f8cc", "filename": "libsanitizer/tsan/tsan_rtl_report.cc", "status": "modified", "additions": 48, "deletions": 10, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Ftsan%2Ftsan_rtl_report.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Ftsan%2Ftsan_rtl_report.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_report.cc?ref=a04084545806300525bb07d0c827480f5282bb55", "patch": "@@ -123,8 +123,7 @@ ScopedReport::ScopedReport(ReportType typ) {\n \n ScopedReport::~ScopedReport() {\n   ctx_->report_mtx.Unlock();\n-  rep_->~ReportDesc();\n-  internal_free(rep_);\n+  DestroyAndFree(rep_);\n }\n \n void ScopedReport::AddStack(const StackTrace *stack) {\n@@ -156,6 +155,7 @@ void ScopedReport::AddThread(const ThreadContext *tctx) {\n   rt->id = tctx->tid;\n   rt->pid = tctx->os_id;\n   rt->running = (tctx->status == ThreadStatusRunning);\n+  rt->name = tctx->name ? internal_strdup(tctx->name) : 0;\n   rt->stack = SymbolizeStack(tctx->creation_stack);\n }\n \n@@ -218,9 +218,11 @@ void ScopedReport::AddLocation(uptr addr, uptr size) {\n     loc->type = ReportLocationGlobal;\n     loc->addr = addr;\n     loc->size = size;\n+    loc->module = symb->module ? internal_strdup(symb->module) : 0;\n+    loc->offset = symb->offset;\n     loc->tid = 0;\n-    loc->name = symb->func;\n-    loc->file = symb->file;\n+    loc->name = symb->func ? internal_strdup(symb->func) : 0;\n+    loc->file = symb->file ? internal_strdup(symb->file) : 0;\n     loc->line = symb->line;\n     loc->stack = 0;\n     internal_free(symb);\n@@ -261,12 +263,12 @@ void RestoreStack(int tid, const u64 epoch, StackTrace *stk) {\n     return;\n   }\n   Lock l(&trace->mtx);\n-  const int partidx = (epoch / (kTraceSize / kTraceParts)) % kTraceParts;\n+  const int partidx = (epoch / kTracePartSize) % TraceParts();\n   TraceHeader* hdr = &trace->headers[partidx];\n   if (epoch < hdr->epoch0)\n     return;\n-  const u64 eend = epoch % kTraceSize;\n-  const u64 ebegin = eend / kTracePartSize * kTracePartSize;\n+  const u64 eend = epoch % TraceSize();\n+  const u64 ebegin = RoundDown(eend, kTracePartSize);\n   DPrintf(\"#%d: RestoreStack epoch=%zu ebegin=%zu eend=%zu partidx=%d\\n\",\n           tid, (uptr)epoch, (uptr)ebegin, (uptr)eend, partidx);\n   InternalScopedBuffer<uptr> stack(1024);  // FIXME: de-hardcode 1024\n@@ -275,8 +277,9 @@ void RestoreStack(int tid, const u64 epoch, StackTrace *stk) {\n     DPrintf2(\"  #%02lu: pc=%zx\\n\", i, stack[i]);\n   }\n   uptr pos = hdr->stack0.Size();\n+  Event *events = (Event*)GetThreadTrace(tid);\n   for (uptr i = ebegin; i <= eend; i++) {\n-    Event ev = trace->events[i];\n+    Event ev = events[i];\n     EventType typ = (EventType)(ev >> 61);\n     uptr pc = (uptr)(ev & 0xffffffffffffull);\n     DPrintf2(\"  %zu typ=%d pc=%zx\\n\", i, typ, pc);\n@@ -382,6 +385,39 @@ bool IsFiredSuppression(Context *ctx,\n   return false;\n }\n \n+// On programs that use Java we see weird reports like:\n+// WARNING: ThreadSanitizer: data race (pid=22512)\n+//   Read of size 8 at 0x7d2b00084318 by thread 100:\n+//     #0 memcpy tsan_interceptors.cc:406 (foo+0x00000d8dfae3)\n+//     #1 <null> <null>:0 (0x7f7ad9b40193)\n+//   Previous write of size 8 at 0x7d2b00084318 by thread 105:\n+//     #0 strncpy tsan_interceptors.cc:501 (foo+0x00000d8e0919)\n+//     #1 <null> <null>:0 (0x7f7ad9b42707)\n+static bool IsJavaNonsense(const ReportDesc *rep) {\n+  for (uptr i = 0; i < rep->mops.Size(); i++) {\n+    ReportMop *mop = rep->mops[i];\n+    ReportStack *frame = mop->stack;\n+    if (frame != 0 && frame->func != 0\n+        && (internal_strcmp(frame->func, \"memset\") == 0\n+        || internal_strcmp(frame->func, \"memcpy\") == 0\n+        || internal_strcmp(frame->func, \"strcmp\") == 0\n+        || internal_strcmp(frame->func, \"strncpy\") == 0\n+        || internal_strcmp(frame->func, \"pthread_mutex_lock\") == 0)) {\n+      frame = frame->next;\n+      if (frame == 0\n+          || (frame->func == 0 && frame->file == 0 && frame->line == 0\n+            && frame->module == 0)) {\n+        if (frame) {\n+          FiredSuppression supp = {rep->typ, frame->pc};\n+          CTX()->fired_suppressions.PushBack(supp);\n+        }\n+        return true;\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n void ReportRace(ThreadState *thr) {\n   if (!flags()->report_bugs)\n     return;\n@@ -414,8 +450,7 @@ void ReportRace(ThreadState *thr) {\n   ScopedReport rep(freed ? ReportTypeUseAfterFree : ReportTypeRace);\n   const uptr kMop = 2;\n   StackTrace traces[kMop];\n-  const uptr toppc = thr->trace.events[thr->fast_state.epoch() % kTraceSize]\n-      & ((1ull << 61) - 1);\n+  const uptr toppc = TraceTopPC(thr);\n   traces[0].ObtainCurrent(thr, toppc);\n   if (IsFiredSuppression(ctx, rep, traces[0]))\n     return;\n@@ -430,6 +465,9 @@ void ReportRace(ThreadState *thr) {\n     rep.AddMemoryAccess(addr, s, &traces[i]);\n   }\n \n+  if (flags()->suppress_java && IsJavaNonsense(rep.GetReport()))\n+    return;\n+\n   for (uptr i = 0; i < kMop; i++) {\n     FastState s(thr->racy_state[i]);\n     ThreadContext *tctx = ctx->threads[s.tid()];"}, {"sha": "462d12c7dee39a9dd85e648e36a8a5714ddee48c", "filename": "libsanitizer/tsan/tsan_rtl_thread.cc", "status": "modified", "additions": 32, "deletions": 8, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Ftsan%2Ftsan_rtl_thread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Ftsan%2Ftsan_rtl_thread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_thread.cc?ref=a04084545806300525bb07d0c827480f5282bb55", "patch": "@@ -96,6 +96,7 @@ int ThreadCreate(ThreadState *thr, uptr pc, uptr uid, bool detached) {\n   ThreadContext *tctx = 0;\n   if (ctx->dead_list_size > kThreadQuarantineSize\n       || ctx->thread_seq >= kMaxTid) {\n+    // Reusing old thread descriptor and tid.\n     if (ctx->dead_list_size == 0) {\n       Printf(\"ThreadSanitizer: %d thread limit exceeded. Dying.\\n\",\n                  kMaxTid);\n@@ -115,12 +116,18 @@ int ThreadCreate(ThreadState *thr, uptr pc, uptr uid, bool detached) {\n     tctx->sync.Reset();\n     tid = tctx->tid;\n     DestroyAndFree(tctx->dead_info);\n+    if (tctx->name) {\n+      internal_free(tctx->name);\n+      tctx->name = 0;\n+    }\n   } else {\n+    // Allocating new thread descriptor and tid.\n     StatInc(thr, StatThreadMaxTid);\n     tid = ctx->thread_seq++;\n     void *mem = internal_alloc(MBlockThreadContex, sizeof(ThreadContext));\n     tctx = new(mem) ThreadContext(tid);\n     ctx->threads[tid] = tctx;\n+    MapThreadTrace(GetThreadTrace(tid), TraceSize() * sizeof(Event));\n   }\n   CHECK_NE(tctx, 0);\n   CHECK_GE(tid, 0);\n@@ -141,12 +148,11 @@ int ThreadCreate(ThreadState *thr, uptr pc, uptr uid, bool detached) {\n   if (tid) {\n     thr->fast_state.IncrementEpoch();\n     // Can't increment epoch w/o writing to the trace as well.\n-    TraceAddEvent(thr, thr->fast_state.epoch(), EventTypeMop, 0);\n+    TraceAddEvent(thr, thr->fast_state, EventTypeMop, 0);\n     thr->clock.set(thr->tid, thr->fast_state.epoch());\n     thr->fast_synch_epoch = thr->fast_state.epoch();\n     thr->clock.release(&tctx->sync);\n     StatInc(thr, StatSyncRelease);\n-\n     tctx->creation_stack.ObtainCurrent(thr, pc);\n   }\n   return tid;\n@@ -185,7 +191,9 @@ void ThreadStart(ThreadState *thr, int tid, uptr os_id) {\n   CHECK_EQ(tctx->status, ThreadStatusCreated);\n   tctx->status = ThreadStatusRunning;\n   tctx->os_id = os_id;\n-  tctx->epoch0 = tctx->epoch1 + 1;\n+  // RoundUp so that one trace part does not contain events\n+  // from different threads.\n+  tctx->epoch0 = RoundUp(tctx->epoch1 + 1, kTracePartSize);\n   tctx->epoch1 = (u64)-1;\n   new(thr) ThreadState(CTX(), tid, tctx->unique_id,\n       tctx->epoch0, stk_addr, stk_size,\n@@ -202,6 +210,9 @@ void ThreadStart(ThreadState *thr, int tid, uptr os_id) {\n   thr->fast_synch_epoch = tctx->epoch0;\n   thr->clock.set(tid, tctx->epoch0);\n   thr->clock.acquire(&tctx->sync);\n+  thr->fast_state.SetHistorySize(flags()->history_size);\n+  const uptr trace = (tctx->epoch0 / kTracePartSize) % TraceParts();\n+  thr->trace.headers[trace].epoch0 = tctx->epoch0;\n   StatInc(thr, StatSyncAcquire);\n   DPrintf(\"#%d: ThreadStart epoch=%zu stk_addr=%zx stk_size=%zx \"\n           \"tls_addr=%zx tls_size=%zx\\n\",\n@@ -236,7 +247,7 @@ void ThreadFinish(ThreadState *thr) {\n   } else {\n     thr->fast_state.IncrementEpoch();\n     // Can't increment epoch w/o writing to the trace as well.\n-    TraceAddEvent(thr, thr->fast_state.epoch(), EventTypeMop, 0);\n+    TraceAddEvent(thr, thr->fast_state, EventTypeMop, 0);\n     thr->clock.set(thr->tid, thr->fast_state.epoch());\n     thr->fast_synch_epoch = thr->fast_state.epoch();\n     thr->clock.release(&tctx->sync);\n@@ -247,9 +258,8 @@ void ThreadFinish(ThreadState *thr) {\n   // Save from info about the thread.\n   tctx->dead_info = new(internal_alloc(MBlockDeadInfo, sizeof(ThreadDeadInfo)))\n       ThreadDeadInfo();\n-  internal_memcpy(&tctx->dead_info->trace.events[0],\n-      &thr->trace.events[0], sizeof(thr->trace.events));\n-  for (int i = 0; i < kTraceParts; i++) {\n+  for (uptr i = 0; i < TraceParts(); i++) {\n+    tctx->dead_info->trace.headers[i].epoch0 = thr->trace.headers[i].epoch0;\n     tctx->dead_info->trace.headers[i].stack0.CopyFrom(\n         thr->trace.headers[i].stack0);\n   }\n@@ -318,6 +328,20 @@ void ThreadDetach(ThreadState *thr, uptr pc, int tid) {\n   }\n }\n \n+void ThreadSetName(ThreadState *thr, const char *name) {\n+  Context *ctx = CTX();\n+  Lock l(&ctx->thread_mtx);\n+  ThreadContext *tctx = ctx->threads[thr->tid];\n+  CHECK_NE(tctx, 0);\n+  CHECK_EQ(tctx->status, ThreadStatusRunning);\n+  if (tctx->name) {\n+    internal_free(tctx->name);\n+    tctx->name = 0;\n+  }\n+  if (name)\n+    tctx->name = internal_strdup(name);\n+}\n+\n void MemoryAccessRange(ThreadState *thr, uptr pc, uptr addr,\n                        uptr size, bool is_write) {\n   if (size == 0)\n@@ -356,7 +380,7 @@ void MemoryAccessRange(ThreadState *thr, uptr pc, uptr addr,\n \n   fast_state.IncrementEpoch();\n   thr->fast_state = fast_state;\n-  TraceAddEvent(thr, fast_state.epoch(), EventTypeMop, pc);\n+  TraceAddEvent(thr, fast_state, EventTypeMop, pc);\n \n   bool unaligned = (addr % kShadowCell) != 0;\n "}, {"sha": "f8ecec1e2071da06e85ad423427fe57aac22a9d2", "filename": "libsanitizer/tsan/tsan_stat.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Ftsan%2Ftsan_stat.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Ftsan%2Ftsan_stat.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_stat.cc?ref=a04084545806300525bb07d0c827480f5282bb55", "patch": "@@ -98,6 +98,7 @@ void StatOutput(u64 *stat) {\n   name[StatInt_longjmp]                  = \"  longjmp                         \";\n   name[StatInt_siglongjmp]               = \"  siglongjmp                      \";\n   name[StatInt_malloc]                   = \"  malloc                          \";\n+  name[StatInt___libc_memalign]          = \"  __libc_memalign                 \";\n   name[StatInt_calloc]                   = \"  calloc                          \";\n   name[StatInt_realloc]                  = \"  realloc                         \";\n   name[StatInt_free]                     = \"  free                            \";"}, {"sha": "51e4c4a377e42e430670b83d5964b4c9ea6dfee0", "filename": "libsanitizer/tsan/tsan_stat.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Ftsan%2Ftsan_stat.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Ftsan%2Ftsan_stat.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_stat.h?ref=a04084545806300525bb07d0c827480f5282bb55", "patch": "@@ -95,6 +95,7 @@ enum StatType {\n   StatInt_longjmp,\n   StatInt_siglongjmp,\n   StatInt_malloc,\n+  StatInt___libc_memalign,\n   StatInt_calloc,\n   StatInt_realloc,\n   StatInt_free,"}, {"sha": "42ba9b509eb064c90642619dd4e1289a7a9bf4be", "filename": "libsanitizer/tsan/tsan_suppressions.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Ftsan%2Ftsan_suppressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Ftsan%2Ftsan_suppressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_suppressions.cc?ref=a04084545806300525bb07d0c827480f5282bb55", "patch": "@@ -25,7 +25,7 @@ static char *ReadFile(const char *filename) {\n   if (filename == 0 || filename[0] == 0)\n     return 0;\n   InternalScopedBuffer<char> tmp(4*1024);\n-  if (filename[0] == '/')\n+  if (filename[0] == '/' || GetPwd() == 0)\n     internal_snprintf(tmp.data(), tmp.size(), \"%s\", filename);\n   else\n     internal_snprintf(tmp.data(), tmp.size(), \"%s/%s\", GetPwd(), filename);"}, {"sha": "50a4eaa518b848e9dd5c79c7e387d4975b41cb38", "filename": "libsanitizer/tsan/tsan_symbolize.cc", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Ftsan%2Ftsan_symbolize.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Ftsan%2Ftsan_symbolize.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_symbolize.cc?ref=a04084545806300525bb07d0c827480f5282bb55", "patch": "@@ -50,7 +50,7 @@ static ReportStack *NewReportStackEntry(const AddressInfo &info) {\n }\n \n ReportStack *SymbolizeCode(uptr addr) {\n-  if (0 != internal_strcmp(flags()->external_symbolizer_path, \"\")) {\n+  if (flags()->external_symbolizer_path[0]) {\n     static const uptr kMaxAddrFrames = 16;\n     InternalScopedBuffer<AddressInfo> addr_frames(kMaxAddrFrames);\n     for (uptr i = 0; i < kMaxAddrFrames; i++)\n@@ -77,6 +77,12 @@ ReportStack *SymbolizeCode(uptr addr) {\n }\n \n ReportStack *SymbolizeData(uptr addr) {\n+  if (flags()->external_symbolizer_path[0]) {\n+    AddressInfo frame;\n+    if (!__sanitizer::SymbolizeData(addr, &frame))\n+      return 0;\n+    return NewReportStackEntry(frame);\n+  }\n   return SymbolizeDataAddr2Line(addr);\n }\n "}, {"sha": "154cc15c083f02a5cf848dd4a30f83a69502a558", "filename": "libsanitizer/tsan/tsan_trace.h", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Ftsan%2Ftsan_trace.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a04084545806300525bb07d0c827480f5282bb55/libsanitizer%2Ftsan%2Ftsan_trace.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_trace.h?ref=a04084545806300525bb07d0c827480f5282bb55", "patch": "@@ -17,12 +17,9 @@\n \n namespace __tsan {\n \n-#ifndef TSAN_HISTORY_SIZE  // in kibitraces\n-#define TSAN_HISTORY_SIZE 128\n-#endif\n-\n-const int kTracePartSize = 16 * 1024;\n-const int kTraceParts = TSAN_HISTORY_SIZE * 1024 / kTracePartSize;\n+const int kTracePartSizeBits = 14;\n+const int kTracePartSize = 1 << kTracePartSizeBits;\n+const int kTraceParts = 4 * 1024 * 1024 / kTracePartSize;\n const int kTraceSize = kTracePartSize * kTraceParts;\n \n // Must fit into 3 bits.\n@@ -59,7 +56,6 @@ struct TraceHeader {\n };\n \n struct Trace {\n-  Event events[kTraceSize];\n   TraceHeader headers[kTraceParts];\n   Mutex mtx;\n "}]}