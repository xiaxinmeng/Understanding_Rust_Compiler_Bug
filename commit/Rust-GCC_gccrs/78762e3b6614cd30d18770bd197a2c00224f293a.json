{"sha": "78762e3b6614cd30d18770bd197a2c00224f293a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzg3NjJlM2I2NjE0Y2QzMGQxODc3MGJkMTk3YTJjMDAyMjRmMjkzYQ==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2002-07-13T00:13:15Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2002-07-13T00:13:15Z"}, "message": "expr.c [...]: New macro defining the maximum number of move instructions to use when...\n\n\n\t* expr.c [CLEAR_RATIO]: New macro defining the maximum number\n\tof move instructions to use when clearing memory, c.f. MOVE_RATIO.\n\t[CLEAR_BY_PIECES]: New macro, using CLEAR_RATIO, to determine\n\twhether clear_by_pieces should be used to clear storage.\n\t(clear_storage): Use CLEAR_BY_PIECES instead of MOVE_BY_PIECES.\n\n\t* doc/tm.texi: Document these two new target macros.\n\nFrom-SVN: r55429", "tree": {"sha": "3f26eda82c3cb91e38e890329c44fe3521873af1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3f26eda82c3cb91e38e890329c44fe3521873af1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/78762e3b6614cd30d18770bd197a2c00224f293a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78762e3b6614cd30d18770bd197a2c00224f293a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78762e3b6614cd30d18770bd197a2c00224f293a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78762e3b6614cd30d18770bd197a2c00224f293a/comments", "author": null, "committer": null, "parents": [{"sha": "a5774acd5514d2a5370e040681177303ec5d4823", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5774acd5514d2a5370e040681177303ec5d4823", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5774acd5514d2a5370e040681177303ec5d4823"}], "stats": {"total": 47, "additions": 46, "deletions": 1}, "files": [{"sha": "8117485ac6fbd9dbe4b19b08fc9094f99e699876", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78762e3b6614cd30d18770bd197a2c00224f293a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78762e3b6614cd30d18770bd197a2c00224f293a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=78762e3b6614cd30d18770bd197a2c00224f293a", "patch": "@@ -1,3 +1,13 @@\n+2002-07-12  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* expr.c [CLEAR_RATIO]: New macro defining the maximum number\n+\tof move instructions to use when clearing memory, c.f. MOVE_RATIO.\n+\t[CLEAR_BY_PIECES]: New macro, using CLEAR_RATIO, to determine\n+\twhether clear_by_pieces should be used to clear storage.\n+\t(clear_storage): Use CLEAR_BY_PIECES instead of MOVE_BY_PIECES.\n+\n+\t* doc/tm.texi: Document these two new target macros.\n+\n 2002-07-12  Stephane Carrez  <stcarrez@nerim.fr>\n \n \t* config/m68hc11/m68hc11.md (\"zero_extendsidi2\"): Use D_REG only for"}, {"sha": "813482edc5296a16dfc5c28d7a057aa8f6f54a73", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78762e3b6614cd30d18770bd197a2c00224f293a/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78762e3b6614cd30d18770bd197a2c00224f293a/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=78762e3b6614cd30d18770bd197a2c00224f293a", "patch": "@@ -5325,6 +5325,22 @@ than @code{MOVE_RATIO}.\n A C expression used by @code{move_by_pieces} to determine the largest unit\n a load or store used to copy memory is.  Defaults to @code{MOVE_MAX}.\n \n+@findex CLEAR_RATIO\n+@item CLEAR_RATIO\n+The threshold of number of scalar move insns, @emph{below} which a sequence\n+of insns should be generated to clear memory instead of a string clear insn\n+or a library call.  Increasing the value will always make code faster, but\n+eventually incurs high cost in increased code size.\n+\n+If you don't define this, a reasonable default is used.\n+\n+@findex CLEAR_BY_PIECES_P\n+@item CLEAR_BY_PIECES_P (@var{size}, @var{alignment})\n+A C expression used to determine whether @code{clear_by_pieces} will be used\n+to clear a chunk of memory, or whether some other block clear mechanism\n+will be used.  Defaults to 1 if @code{move_by_pieces_ninsns} returns less\n+than @code{CLEAR_RATIO}.\n+\n @findex USE_LOAD_POST_INCREMENT\n @item USE_LOAD_POST_INCREMENT (@var{mode})\n A C expression used to determine whether a load postincrement is a good"}, {"sha": "870a4c527bf2ff9f15d1fe33a1b681c7c3aa6108", "filename": "gcc/expr.c", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78762e3b6614cd30d18770bd197a2c00224f293a/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78762e3b6614cd30d18770bd197a2c00224f293a/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=78762e3b6614cd30d18770bd197a2c00224f293a", "patch": "@@ -192,6 +192,25 @@ static bool float_extend_from_mem[NUM_MACHINE_MODES][NUM_MACHINE_MODES];\n   (move_by_pieces_ninsns (SIZE, ALIGN) < (unsigned int) MOVE_RATIO)\n #endif\n \n+/* If a clear memory operation would take CLEAR_RATIO or more simple\n+   move-instruction sequences, we will do a clrstr or libcall instead.  */\n+\n+#ifndef CLEAR_RATIO\n+#if defined (HAVE_clrstrqi) || defined (HAVE_clrstrhi) || defined (HAVE_clrstrsi) || defined (HAVE_clrstrdi) || defined (HAVE_clrstrti)\n+#define CLEAR_RATIO 2\n+#else\n+/* If we are optimizing for space, cut down the default clear ratio.  */\n+#define CLEAR_RATIO (optimize_size ? 3 : 15)\n+#endif\n+#endif\n+\n+/* This macro is used to determine whether clear_by_pieces should be\n+   called to clear storage.  */\n+#ifndef CLEAR_BY_PIECES_P\n+#define CLEAR_BY_PIECES_P(SIZE, ALIGN) \\\n+  (move_by_pieces_ninsns (SIZE, ALIGN) < (unsigned int) CLEAR_RATIO)\n+#endif\n+\n /* This array records the insn_code of insns to perform block moves.  */\n enum insn_code movstr_optab[NUM_MACHINE_MODES];\n \n@@ -2633,7 +2652,7 @@ clear_storage (object, size)\n       size = protect_from_queue (size, 0);\n \n       if (GET_CODE (size) == CONST_INT\n-\t  && MOVE_BY_PIECES_P (INTVAL (size), align))\n+\t  && CLEAR_BY_PIECES_P (INTVAL (size), align))\n \tclear_by_pieces (object, INTVAL (size), align);\n       else\n \t{"}]}