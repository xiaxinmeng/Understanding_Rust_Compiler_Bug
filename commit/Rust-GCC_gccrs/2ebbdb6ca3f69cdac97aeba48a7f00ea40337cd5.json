{"sha": "2ebbdb6ca3f69cdac97aeba48a7f00ea40337cd5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmViYmRiNmNhM2Y2OWNkYWM5N2FlYmE0OGE3ZjAwZWE0MDMzN2NkNQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2018-08-30T15:05:38Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2018-08-30T15:05:38Z"}, "message": "lto-streamer-out.c (DFS::DFS_write_tree_body): Do not follow TYPE_STUB_DECL.\n\n\n\t* lto-streamer-out.c (DFS::DFS_write_tree_body): Do not follow\n\tTYPE_STUB_DECL.\n\t(hash_tree): Do not visit TYPE_STUB_DECL.\n\t* tree-streamer-out.c (write_ts_type_common_tree_pointers): Do not\n\tstream TYPE_STUB_DECL.\n\t* tree-streamer-in.c (lto_input_ts_type_common_tree_pointers): Likewise.\n\t* ipa-utils.h (type_with_linkage_p): Do not rely on TYPE_STUB_DECL\n\tafter free_lang_data.\n\t(type_in_anonymous_namespace_p): Likewise.\n\nFrom-SVN: r263985", "tree": {"sha": "1e40ab202c9f3cae5ffbc665346f1312fa99cb81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1e40ab202c9f3cae5ffbc665346f1312fa99cb81"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2ebbdb6ca3f69cdac97aeba48a7f00ea40337cd5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ebbdb6ca3f69cdac97aeba48a7f00ea40337cd5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ebbdb6ca3f69cdac97aeba48a7f00ea40337cd5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ebbdb6ca3f69cdac97aeba48a7f00ea40337cd5/comments", "author": null, "committer": null, "parents": [{"sha": "21592ebe9d8d1d3486be575d6a64dfa10eba17b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21592ebe9d8d1d3486be575d6a64dfa10eba17b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21592ebe9d8d1d3486be575d6a64dfa10eba17b1"}], "stats": {"total": 76, "additions": 45, "deletions": 31}, "files": [{"sha": "fe6dacbc4dcca79f443b95c2a76ef80b9cff6084", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ebbdb6ca3f69cdac97aeba48a7f00ea40337cd5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ebbdb6ca3f69cdac97aeba48a7f00ea40337cd5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2ebbdb6ca3f69cdac97aeba48a7f00ea40337cd5", "patch": "@@ -1,3 +1,15 @@\n+2018-08-29  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto-streamer-out.c (DFS::DFS_write_tree_body): Do not follow\n+\tTYPE_STUB_DECL.\n+\t(hash_tree): Do not visit TYPE_STUB_DECL.\n+\t* tree-streamer-out.c (write_ts_type_common_tree_pointers): Do not\n+\tstream TYPE_STUB_DECL.\n+\t* tree-streamer-in.c (lto_input_ts_type_common_tree_pointers): Likewise.\n+\t* ipa-utils.h (type_with_linkage_p): Do not rely on TYPE_STUB_DECL\n+\tafter free_lang_data.\n+\t(type_in_anonymous_namespace_p): Likewise.\n+\n 2018-08-29  Jan Hubicka  <jh@suse.cz>\n \n \t* sreal.h (SREAL_PART_BITS): Change to 31; remove seemingly unnecessary"}, {"sha": "98f2a75cd814ceacf08141bd29dd4fd5636fc62d", "filename": "gcc/ipa-utils.h", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ebbdb6ca3f69cdac97aeba48a7f00ea40337cd5/gcc%2Fipa-utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ebbdb6ca3f69cdac97aeba48a7f00ea40337cd5/gcc%2Fipa-utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.h?ref=2ebbdb6ca3f69cdac97aeba48a7f00ea40337cd5", "patch": "@@ -179,22 +179,24 @@ polymorphic_type_binfo_p (const_tree binfo)\n inline bool\n type_with_linkage_p (const_tree t)\n {\n-  if (!TYPE_NAME (t) || TREE_CODE (TYPE_NAME (t)) != TYPE_DECL\n-      || !TYPE_STUB_DECL (t))\n+  if (!TYPE_NAME (t) || TREE_CODE (TYPE_NAME (t)) != TYPE_DECL)\n+    return false;\n+\n+  /* To support -fno-lto-odr-type-merigng recognize types with vtables\n+     to have linkage.  */\n+  if (RECORD_OR_UNION_TYPE_P (t)\n+      && TYPE_BINFO (t) && BINFO_VTABLE (TYPE_BINFO (t)))\n+    return true;\n+\n+  /* After free_lang_data was run and -flto-odr-type-merging we can recongize\n+     types with linkage by presence of mangled name.  */\n+  if (DECL_ASSEMBLER_NAME_SET_P (TYPE_NAME (t)))\n+    return true;\n+\n+  /* If free lang data was not run check if indeed the type looks like C++\n+     type with linkage.  */\n+  if (in_lto_p || !TYPE_STUB_DECL (t))\n     return false;\n-  /* In LTO do not get confused by non-C++ produced types or types built\n-     with -fno-lto-odr-type-merigng.  */\n-  if (in_lto_p)\n-    {\n-      /* To support -fno-lto-odr-type-merigng recognize types with vtables\n-         to have linkage.  */\n-      if (RECORD_OR_UNION_TYPE_P (t)\n-\t  && TYPE_BINFO (t) && BINFO_VTABLE (TYPE_BINFO (t)))\n-        return true;\n-      /* With -flto-odr-type-merging C++ FE specify mangled names\n-\t for all types with the linkage.  */\n-      return DECL_ASSEMBLER_NAME_SET_P (TYPE_NAME (t));\n-    }\n \n   if (!RECORD_OR_UNION_TYPE_P (t) && TREE_CODE (t) != ENUMERAL_TYPE)\n     return false;\n@@ -214,18 +216,16 @@ type_in_anonymous_namespace_p (const_tree t)\n {\n   gcc_checking_assert (type_with_linkage_p (t));\n \n-  if (!TREE_PUBLIC (TYPE_STUB_DECL (t)))\n-    {\n-      /* C++ FE uses magic <anon> as assembler names of anonymous types.\n- \t verify that this match with type_in_anonymous_namespace_p.  */\n-      gcc_checking_assert (!in_lto_p\n-\t\t\t   || !DECL_ASSEMBLER_NAME_SET_P (TYPE_NAME (t))\n-\t\t\t   || !strcmp (\"<anon>\",\n-\t\t\t\t       IDENTIFIER_POINTER\n-\t\t\t\t       (DECL_ASSEMBLER_NAME (TYPE_NAME (t)))));\n-      return true;\n-    }\n-  return false;\n+  /* free_lang_data clears TYPE_STUB_DECL but sets assembler name to\n+     \"<anon>\"  */\n+  if (DECL_ASSEMBLER_NAME_SET_P (TYPE_NAME (t)))\n+    return !strcmp (\"<anon>\",\n+\t\t    IDENTIFIER_POINTER\n+\t\t    (DECL_ASSEMBLER_NAME (TYPE_NAME (t))));\n+  else if (!TYPE_STUB_DECL (t))\n+    return false;\n+  else\n+    return !TREE_PUBLIC (TYPE_STUB_DECL (t));\n }\n \n /* Return true of T is type with One Definition Rule info attached. "}, {"sha": "21ac1a466596875b89fc12e6fd3498c7c3f95f64", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ebbdb6ca3f69cdac97aeba48a7f00ea40337cd5/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ebbdb6ca3f69cdac97aeba48a7f00ea40337cd5/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=2ebbdb6ca3f69cdac97aeba48a7f00ea40337cd5", "patch": "@@ -857,7 +857,9 @@ DFS::DFS_write_tree_body (struct output_block *ob,\n       DFS_follow_tree_edge (TYPE_CONTEXT (expr));\n       /* TYPE_CANONICAL is re-computed during type merging, so no need\n \t to follow it here.  */\n-      DFS_follow_tree_edge (TYPE_STUB_DECL (expr));\n+      /* Do not stream TYPE_STUB_DECL; it is not needed by LTO but currently\n+\t it can not be freed by free_lang_data without triggering ICEs in\n+\t langhooks.  */\n     }\n \n   if (CODE_CONTAINS_STRUCT (code, TS_TYPE_NON_COMMON))\n@@ -1269,7 +1271,6 @@ hash_tree (struct streamer_tree_cache_d *cache, hash_map<tree, hashval_t> *map,\n \t;\n       else\n \tvisit (TYPE_CONTEXT (t));\n-      visit (TYPE_STUB_DECL (t));\n     }\n \n   if (CODE_CONTAINS_STRUCT (code, TS_TYPE_NON_COMMON))"}, {"sha": "8d8f86957182cdff82333ddc5d6cb850492d0699", "filename": "gcc/tree-streamer-in.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ebbdb6ca3f69cdac97aeba48a7f00ea40337cd5/gcc%2Ftree-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ebbdb6ca3f69cdac97aeba48a7f00ea40337cd5/gcc%2Ftree-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer-in.c?ref=2ebbdb6ca3f69cdac97aeba48a7f00ea40337cd5", "patch": "@@ -819,7 +819,6 @@ lto_input_ts_type_common_tree_pointers (struct lto_input_block *ib,\n   TYPE_CONTEXT (expr) = stream_read_tree (ib, data_in);\n   /* TYPE_CANONICAL gets re-computed during type merging.  */\n   TYPE_CANONICAL (expr) = NULL_TREE;\n-  TYPE_STUB_DECL (expr) = stream_read_tree (ib, data_in);\n }\n \n /* Read all pointer fields in the TS_TYPE_NON_COMMON structure of EXPR"}, {"sha": "60ec1788bf3a6548b6e4aad1667c0220fe9cd7c6", "filename": "gcc/tree-streamer-out.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ebbdb6ca3f69cdac97aeba48a7f00ea40337cd5/gcc%2Ftree-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ebbdb6ca3f69cdac97aeba48a7f00ea40337cd5/gcc%2Ftree-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer-out.c?ref=2ebbdb6ca3f69cdac97aeba48a7f00ea40337cd5", "patch": "@@ -686,7 +686,9 @@ write_ts_type_common_tree_pointers (struct output_block *ob, tree expr,\n   stream_write_tree (ob, TYPE_CONTEXT (expr), ref_p);\n   /* TYPE_CANONICAL is re-computed during type merging, so no need\n      to stream it here.  */\n-  stream_write_tree (ob, TYPE_STUB_DECL (expr), ref_p);\n+  /* Do not stream TYPE_STUB_DECL; it is not needed by LTO but currently\n+     it can not be freed by free_lang_data without triggering ICEs in\n+     langhooks.  */\n }\n \n /* Write all pointer fields in the TS_TYPE_NON_COMMON structure of EXPR"}]}