{"sha": "75514d157e9e28616c6de4e8c2740d8c87b6857d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzU1MTRkMTU3ZTllMjg2MTZjNmRlNGU4YzI3NDBkOGM4N2I2ODU3ZA==", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2020-05-15T14:22:19Z"}, "committer": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2020-05-15T14:22:19Z"}, "message": "i386: Allow SI, DI and TImode pushes from XMM registers\n\nAlso change XMM register constraint from \"x\" to \"v\" in FP push insns.\n\ngcc/ChangeLog:\n\n2020-05-15  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n\n\t* config/i386/i386.md (SWI48DWI): New mode iterator.\n\t(*push<mode>2): Allow XMM registers.\n\t(*pushdi2_rex64): Ditto.\n\t(*pushsi2_rex64): Ditto.\n\t(*pushsi2): Ditto.\n\t(push XMM reg splitter): New splitter\n\n\t(*pushdf) Change \"x\" operand constraint to \"v\".\n\t(*pushsf_rex64): Ditto.\n\t(*pushsf): Ditto.", "tree": {"sha": "dffa5eba21b2aa7cffd7806657ff33b6fc3e8a81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dffa5eba21b2aa7cffd7806657ff33b6fc3e8a81"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/75514d157e9e28616c6de4e8c2740d8c87b6857d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75514d157e9e28616c6de4e8c2740d8c87b6857d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75514d157e9e28616c6de4e8c2740d8c87b6857d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75514d157e9e28616c6de4e8c2740d8c87b6857d/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "271e3da859f92e32e0f3a8779fb6ac0c2a7909c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/271e3da859f92e32e0f3a8779fb6ac0c2a7909c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/271e3da859f92e32e0f3a8779fb6ac0c2a7909c4"}], "stats": {"total": 88, "additions": 62, "deletions": 26}, "files": [{"sha": "d44ad8be80116a6bf2ad0ae1410b9dca3ccf5072", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75514d157e9e28616c6de4e8c2740d8c87b6857d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75514d157e9e28616c6de4e8c2740d8c87b6857d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=75514d157e9e28616c6de4e8c2740d8c87b6857d", "patch": "@@ -1,3 +1,16 @@\n+2020-05-15  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386.md (SWI48DWI): New mode iterator.\n+\t(*push<mode>2): Allow XMM registers.\n+\t(*pushdi2_rex64): Ditto.\n+\t(*pushsi2_rex64): Ditto.\n+\t(*pushsi2): Ditto.\n+\t(push XMM reg splitter): New splitter\n+\n+\t(*pushdf) Change \"x\" operand constraint to \"v\".\n+\t(*pushsf_rex64): Ditto.\n+\t(*pushsf): Ditto.\n+\n 2020-05-15  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/92260"}, {"sha": "1bf0c1a7f0181a323c152bf077a95303e8151335", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 49, "deletions": 26, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75514d157e9e28616c6de4e8c2740d8c87b6857d/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75514d157e9e28616c6de4e8c2740d8c87b6857d/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=75514d157e9e28616c6de4e8c2740d8c87b6857d", "patch": "@@ -1051,6 +1051,9 @@\n ;; SWI and DWI together.\n (define_mode_iterator SWIDWI [QI HI SI DI (TI \"TARGET_64BIT\")])\n \n+;; SWI48 and DWI together.\n+(define_mode_iterator SWI48DWI [SI DI (TI \"TARGET_64BIT\")])\n+\n ;; GET_MODE_SIZE for selected modes.  As GET_MODE_SIZE is not\n ;; compile time constant, it is faster to use <MODE_SIZE> than\n ;; GET_MODE_SIZE (<MODE>mode).  For XFmode which depends on\n@@ -1672,8 +1675,8 @@\n ;; Push/pop instructions.\n \n (define_insn \"*push<mode>2\"\n-  [(set (match_operand:DWI 0 \"push_operand\" \"=<\")\n-\t(match_operand:DWI 1 \"general_no_elim_operand\" \"riF*o\"))]\n+  [(set (match_operand:DWI 0 \"push_operand\" \"=<,<\")\n+\t(match_operand:DWI 1 \"general_no_elim_operand\" \"riF*o,*v\"))]\n   \"\"\n   \"#\"\n   [(set_attr \"type\" \"multi\")\n@@ -1687,13 +1690,14 @@\n   \"ix86_split_long_move (operands); DONE;\")\n \n (define_insn \"*pushdi2_rex64\"\n-  [(set (match_operand:DI 0 \"push_operand\" \"=<,!<\")\n-\t(match_operand:DI 1 \"general_no_elim_operand\" \"re*m,n\"))]\n+  [(set (match_operand:DI 0 \"push_operand\" \"=<,<,!<\")\n+\t(match_operand:DI 1 \"general_no_elim_operand\" \"re*m,*v,n\"))]\n   \"TARGET_64BIT\"\n   \"@\n    push{q}\\t%1\n+   #\n    #\"\n-  [(set_attr \"type\" \"push,multi\")\n+  [(set_attr \"type\" \"push,multi,multi\")\n    (set_attr \"mode\" \"DI\")])\n \n ;; Convert impossible pushes of immediate to existing instructions.\n@@ -1727,34 +1731,53 @@\n \t\t\t     plus_constant (Pmode, stack_pointer_rtx, 4));\n })\n \n+;; For TARGET_64BIT we always round up to 8 bytes.\n+(define_insn \"*pushsi2_rex64\"\n+  [(set (match_operand:SI 0 \"push_operand\" \"=X,X\")\n+\t(match_operand:SI 1 \"nonmemory_no_elim_operand\" \"ri,*v\"))]\n+  \"TARGET_64BIT\"\n+  \"@\n+   push{q}\\t%q1\n+   #\"\n+  [(set_attr \"type\" \"push,multi\")\n+   (set_attr \"mode\" \"DI\")])\n+\n (define_insn \"*pushsi2\"\n-  [(set (match_operand:SI 0 \"push_operand\" \"=<\")\n-\t(match_operand:SI 1 \"general_no_elim_operand\" \"ri*m\"))]\n+  [(set (match_operand:SI 0 \"push_operand\" \"=<,<\")\n+\t(match_operand:SI 1 \"general_no_elim_operand\" \"ri*m,*v\"))]\n   \"!TARGET_64BIT\"\n-  \"push{l}\\t%1\"\n-  [(set_attr \"type\" \"push\")\n+  \"@\n+   push{l}\\t%1\n+   #\"\n+  [(set_attr \"type\" \"push,multi\")\n    (set_attr \"mode\" \"SI\")])\n \n-;; emit_push_insn when it calls move_by_pieces requires an insn to\n-;; \"push a byte/word\".  But actually we use pushl, which has the effect\n-;; of rounding the amount pushed up to a word.\n+(define_split\n+  [(set (match_operand:SWI48DWI 0 \"push_operand\")\n+\t(match_operand:SWI48DWI 1 \"sse_reg_operand\"))]\n+  \"TARGET_SSE && reload_completed\"\n+  [(set (reg:P SP_REG) (plus:P (reg:P SP_REG) (match_dup 2)))\n+    (set (match_dup 0) (match_dup 1))]\n+{\n+  operands[2] = GEN_INT (-PUSH_ROUNDING (GET_MODE_SIZE (<SWI48DWI:MODE>mode)));\n+  /* Preserve memory attributes. */\n+  operands[0] = replace_equiv_address (operands[0], stack_pointer_rtx);\n+})\n \n-;; For TARGET_64BIT we always round up to 8 bytes.\n-(define_insn \"*push<mode>2_rex64\"\n-  [(set (match_operand:SWI124 0 \"push_operand\" \"=X\")\n-\t(match_operand:SWI124 1 \"nonmemory_no_elim_operand\" \"r<i>\"))]\n-  \"TARGET_64BIT\"\n-  \"push{q}\\t%q1\"\n-  [(set_attr \"type\" \"push\")\n-   (set_attr \"mode\" \"DI\")])\n+;; emit_push_insn when it calls move_by_pieces requires an insn to\n+;; \"push a byte/word\".  But actually we use push{l,q}, which has\n+;; the effect of rounding the amount pushed up to a word.\n \n (define_insn \"*push<mode>2\"\n   [(set (match_operand:SWI12 0 \"push_operand\" \"=X\")\n \t(match_operand:SWI12 1 \"nonmemory_no_elim_operand\" \"rn\"))]\n-  \"!TARGET_64BIT\"\n-  \"push{l}\\t%k1\"\n+  \"\"\n+  \"* return TARGET_64BIT ? \\\"push{q}\\t%q1\\\" : \\\"push{l}\\t%k1\\\";\"\n   [(set_attr \"type\" \"push\")\n-   (set_attr \"mode\" \"SI\")])\n+   (set (attr \"mode\")\n+\t(if_then_else (match_test \"TARGET_64BIT\")\n+\t  (const_string \"DI\")\n+\t  (const_string \"SI\")))])\n \n (define_insn \"*push<mode>2_prologue\"\n   [(set (match_operand:W 0 \"push_operand\" \"=<\")\n@@ -3031,7 +3054,7 @@\n \n (define_insn \"*pushdf\"\n   [(set (match_operand:DF 0 \"push_operand\" \"=<,<,<,<,<,<\")\n-\t(match_operand:DF 1 \"general_no_elim_operand\" \"f,r,*r,oF,rmC,x\"))]\n+\t(match_operand:DF 1 \"general_no_elim_operand\" \"f,r,*r,oF,rmC,v\"))]\n   \"\"\n {\n   /* This insn should be already split before reg-stack.  */\n@@ -3064,7 +3087,7 @@\n \n (define_insn \"*pushsf_rex64\"\n   [(set (match_operand:SF 0 \"push_operand\" \"=X,X,X\")\n-\t(match_operand:SF 1 \"nonmemory_no_elim_operand\" \"f,rF,x\"))]\n+\t(match_operand:SF 1 \"nonmemory_no_elim_operand\" \"f,rF,v\"))]\n   \"TARGET_64BIT\"\n {\n   /* Anything else should be already split before reg-stack.  */\n@@ -3078,7 +3101,7 @@\n \n (define_insn \"*pushsf\"\n   [(set (match_operand:SF 0 \"push_operand\" \"=<,<,<\")\n-\t(match_operand:SF 1 \"general_no_elim_operand\" \"f,rmF,x\"))]\n+\t(match_operand:SF 1 \"general_no_elim_operand\" \"f,rmF,v\"))]\n   \"!TARGET_64BIT\"\n {\n   /* Anything else should be already split before reg-stack.  */"}]}