{"sha": "8c6ab2db94dd89afd71a17768dac974ff91cbe8f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGM2YWIyZGI5NGRkODlhZmQ3MWExNzc2OGRhYzk3NGZmOTFjYmU4Zg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2003-07-31T09:06:26Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2003-07-31T09:06:26Z"}, "message": "pt.c (coerce_template_template_parms, [...]): Reformat.\n\n\t* pt.c (coerce_template_template_parms, lookup_template_class,\n\tcan_complete_type_without_circularity, instantiate_class_template,\n\ttsubst_decl, unify): Reformat.\n\nFrom-SVN: r69993", "tree": {"sha": "66bce0a99091c0be3f1c59e65bacae0d92759b92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/66bce0a99091c0be3f1c59e65bacae0d92759b92"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8c6ab2db94dd89afd71a17768dac974ff91cbe8f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c6ab2db94dd89afd71a17768dac974ff91cbe8f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c6ab2db94dd89afd71a17768dac974ff91cbe8f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c6ab2db94dd89afd71a17768dac974ff91cbe8f/comments", "author": null, "committer": null, "parents": [{"sha": "caf819ae17ec6db89dc59af158478016f7f2d6a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/caf819ae17ec6db89dc59af158478016f7f2d6a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/caf819ae17ec6db89dc59af158478016f7f2d6a6"}], "stats": {"total": 56, "additions": 28, "deletions": 28}, "files": [{"sha": "110579ea0c8f2d8757ad720f80bc13e4620b48d3", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c6ab2db94dd89afd71a17768dac974ff91cbe8f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c6ab2db94dd89afd71a17768dac974ff91cbe8f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=8c6ab2db94dd89afd71a17768dac974ff91cbe8f", "patch": "@@ -1,3 +1,9 @@\n+2003-07-31  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* pt.c (coerce_template_template_parms, lookup_template_class,\n+\tcan_complete_type_without_circularity, instantiate_class_template,\n+\ttsubst_decl, unify): Reformat.\n+\n Thu Jul 31 01:07:41 CEST 2003  Jan Hubicka  <jh@suse.cz>\n \n \t* decl2.c (maybe_make_one_only): Use mark_referenced."}, {"sha": "07df30de06000419252e23ffa3d2d6a5aa41c8af", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 22, "deletions": 28, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c6ab2db94dd89afd71a17768dac974ff91cbe8f/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c6ab2db94dd89afd71a17768dac974ff91cbe8f/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=8c6ab2db94dd89afd71a17768dac974ff91cbe8f", "patch": "@@ -3371,9 +3371,8 @@ coerce_template_template_parms (tree parm_parms,\n \t    tree parmparm = DECL_INNERMOST_TEMPLATE_PARMS (parm);\n \t    tree argparm = DECL_INNERMOST_TEMPLATE_PARMS (arg);\n \n-\t    if (!coerce_template_template_parms (parmparm, argparm, \n-\t\t\t\t\t         complain, in_decl,\n-\t\t\t\t\t\t outer_args))\n+\t    if (!coerce_template_template_parms\n+\t\t(parmparm, argparm, complain, in_decl, outer_args))\n \t      return 0;\n \t  }\n \t  break;\n@@ -3382,9 +3381,9 @@ coerce_template_template_parms (tree parm_parms,\n \t  /* The tsubst call is used to handle cases such as\n \t       template <class T, template <T> class TT> class D;  \n \t     i.e. the parameter list of TT depends on earlier parameters.  */\n-\t  if (!same_type_p (tsubst (TREE_TYPE (parm), outer_args, \n-\t\t\t\t    complain, in_decl),\n-\t\t\t    TREE_TYPE (arg)))\n+\t  if (!same_type_p\n+\t      (tsubst (TREE_TYPE (parm), outer_args, complain, in_decl),\n+\t       TREE_TYPE (arg)))\n \t    return 0;\n \t  break;\n \t  \n@@ -4135,9 +4134,9 @@ lookup_template_class (tree d1,\n \t       i > 0 && t != NULL_TREE;\n \t       --i, t = TREE_CHAIN (t))\n \t    {\n-\t      tree a = coerce_template_parms (TREE_VALUE (t),\n-\t\t\t\t\t      arglist, template,\n-\t                                      complain, /*require_all_args=*/1);\n+\t      tree a = coerce_template_parms (TREE_VALUE (t), arglist,\n+\t\t\t\t\t      template, complain,\n+\t\t\t\t\t      /*require_all_args=*/1);\n \n \t      /* Don't process further if one of the levels fails.  */\n \t      if (a == error_mark_node)\n@@ -5061,7 +5060,8 @@ can_complete_type_without_circularity (tree type)\n     return 1;\n   else if (TREE_CODE (type) == ARRAY_TYPE && TYPE_DOMAIN (type))\n     return can_complete_type_without_circularity (TREE_TYPE (type));\n-  else if (CLASS_TYPE_P (type) && TYPE_BEING_DEFINED (TYPE_MAIN_VARIANT (type)))\n+  else if (CLASS_TYPE_P (type)\n+\t   && TYPE_BEING_DEFINED (TYPE_MAIN_VARIANT (type)))\n     return 0;\n   else\n     return 1;\n@@ -5100,8 +5100,7 @@ instantiate_class_template (tree type)\n       for (t = DECL_TEMPLATE_SPECIALIZATIONS (template); t; \n \t   t = TREE_CHAIN (t))\n \t{\n-\t  if (get_class_bindings (TREE_VALUE (t), TREE_PURPOSE (t),\n-\t\t\t\t  args))\n+\t  if (get_class_bindings (TREE_VALUE (t), TREE_PURPOSE (t), args))\n \t    {\n \t      cp_error_at (\"%s %+#T\", str, TREE_TYPE (t));\n \t      str = \"               \";\n@@ -5255,7 +5254,8 @@ instantiate_class_template (tree type)\n   pushclass (type, true);\n \n   /* Now members are processed in the order of declaration.  */\n-  for (member = CLASSTYPE_DECL_LIST (pattern); member; member = TREE_CHAIN (member))\n+  for (member = CLASSTYPE_DECL_LIST (pattern);\n+       member; member = TREE_CHAIN (member))\n     {\n       tree t = TREE_VALUE (member);\n \n@@ -5329,9 +5329,8 @@ instantiate_class_template (tree type)\n \t\t      else\n \t\t\tinit = NULL_TREE;\n \n-\t\t      finish_static_data_member_decl (r, init,\n-\t\t\t\t\t\t      /*asmspec_tree=*/NULL_TREE, \n-\t\t\t\t\t\t      /*flags=*/0);\n+\t\t      finish_static_data_member_decl\n+\t\t\t(r, init, /*asmspec_tree=*/NULL_TREE, /*flags=*/0);\n \n \t\t      if (DECL_INITIALIZED_IN_CLASS_P (r))\n \t\t\tcheck_static_variable_definition (r, TREE_TYPE (r));\n@@ -5853,14 +5852,10 @@ tsubst_decl (tree t, tree args, tree type, tsubst_flags_t complain)\n \tif (PRIMARY_TEMPLATE_P (t))\n \t  DECL_PRIMARY_TEMPLATE (r) = r;\n \n-\t/* We don't partially instantiate partial specializations.  */\n-\tif (TREE_CODE (decl) == TYPE_DECL)\n-\t  break;\n-\n-\t/* Record this partial instantiation.  */\n-\tregister_specialization (r, t, \n-\t\t\t\t DECL_TI_ARGS (DECL_TEMPLATE_RESULT (r)));\n-\n+\tif (TREE_CODE (decl) != TYPE_DECL)\n+\t  /* Record this non-type partial instantiation.  */\n+\t  register_specialization (r, t, \n+\t\t\t\t   DECL_TI_ARGS (DECL_TEMPLATE_RESULT (r)));\n       }\n       break;\n \n@@ -5971,8 +5966,7 @@ tsubst_decl (tree t, tree args, tree type, tsubst_flags_t complain)\n \t    else\n \t      member = 1;\n \t    ctx = tsubst_aggr_type (DECL_CONTEXT (t), args, \n-\t\t\t\t    complain, t, \n-\t\t\t\t    /*entering_scope=*/1);\n+\t\t\t\t    complain, t, /*entering_scope=*/1);\n \t  }\n \telse\n \t  {\n@@ -9482,8 +9476,8 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n \t       template <class T, class Allocator = allocator> \n \t       class vector.  */\n \n-\t    if (coerce_template_parms (argtmplvec, parmvec, parmtmpl, 0, 1)\n-\t        == error_mark_node)\n+\t    if (coerce_template_parms (argtmplvec, parmvec, parmtmpl,\n+\t\t\t\t       tf_none, 1) == error_mark_node)\n \t      return 1;\n \t  \n \t    /* Deduce arguments T, i from TT<T> or TT<i>.  "}]}