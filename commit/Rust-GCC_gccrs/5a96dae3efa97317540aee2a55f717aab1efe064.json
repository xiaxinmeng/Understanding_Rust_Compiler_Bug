{"sha": "5a96dae3efa97317540aee2a55f717aab1efe064", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWE5NmRhZTNlZmE5NzMxNzU0MGFlZTJhNTVmNzE3YWFiMWVmZTA2NA==", "commit": {"author": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2016-05-10T08:03:49Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2016-05-10T08:03:49Z"}, "message": "DWARF: add abstract origin links on lexical blocks DIEs\n\nTrack from which abstract lexical block concrete ones come from in DWARF\nso that debuggers can inherit the former from the latter. This enables\ndebuggers to properly handle the following case:\n\n  * function Child2 is nested in a lexical block, itself nested in\n    function Child1;\n  * function Child1 is inlined into some call site;\n  * function Child2 is never inlined.\n\nHere, Child2 is described in DWARF only in the abstract instance of\nChild1. So when debuggers decode Child1's concrete instances, they need\nto fetch the definition for Child2 in the corresponding abstract\ninstance: the DW_AT_abstract_origin link on the lexical block that\nembeds Child1 enables them to do that.\n\nBootstrapped and regtested on x86_64-linux.\n\ngcc/ChangeLog:\n\n\t* dwarf2out.c (add_abstract_origin_attribute): Adjust\n\tdocumentation comment.  For BLOCK nodes, add a\n\tDW_AT_abstract_origin attribute that points to the DIE generated\n\tfor the origin BLOCK.\n\t(gen_lexical_block_die): Call add_abstract_origin_attribute for\n\tblocks from inlined functions.\n\ngcc/testsuite/Changelog:\n\n\t* gcc.dg/debug/dwarf2/nested_fun.c: New testcase.\n\nFrom-SVN: r236065", "tree": {"sha": "b97ded89e8b47e37053c7b658937ebd62f0da1b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b97ded89e8b47e37053c7b658937ebd62f0da1b7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5a96dae3efa97317540aee2a55f717aab1efe064", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a96dae3efa97317540aee2a55f717aab1efe064", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a96dae3efa97317540aee2a55f717aab1efe064", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a96dae3efa97317540aee2a55f717aab1efe064/comments", "author": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ad251dfd97b5d640a6db3a85bdad272e780f65e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad251dfd97b5d640a6db3a85bdad272e780f65e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad251dfd97b5d640a6db3a85bdad272e780f65e0"}], "stats": {"total": 91, "additions": 88, "deletions": 3}, "files": [{"sha": "fb9b6a7f4166b0de6e9b96f3de5157526c7c646f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a96dae3efa97317540aee2a55f717aab1efe064/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a96dae3efa97317540aee2a55f717aab1efe064/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5a96dae3efa97317540aee2a55f717aab1efe064", "patch": "@@ -1,3 +1,12 @@\n+2016-05-10  Pierre-Marie de Rodat  <derodat@adacore.com>\n+\n+\t* dwarf2out.c (add_abstract_origin_attribute): Adjust\n+\tdocumentation comment.  For BLOCK nodes, add a\n+\tDW_AT_abstract_origin attribute that points to the DIE generated\n+\tfor the origin BLOCK.\n+\t(gen_lexical_block_die): Call add_abstract_origin_attribute for\n+\tblocks from inlined functions.\n+\n 2016-05-10  Alan Modra  <amodra@gmail.com>\n \n \tPR target/70947"}, {"sha": "da95e19849dfb58ce195244660c8b247bbb92a66", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a96dae3efa97317540aee2a55f717aab1efe064/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a96dae3efa97317540aee2a55f717aab1efe064/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=5a96dae3efa97317540aee2a55f717aab1efe064", "patch": "@@ -18621,15 +18621,16 @@ add_prototyped_attribute (dw_die_ref die, tree func_type)\n }\n \n /* Add an 'abstract_origin' attribute below a given DIE.  The DIE is found\n-   by looking in either the type declaration or object declaration\n-   equate table.  */\n+   by looking in the type declaration, the object declaration equate table or\n+   the block mapping.  */\n \n static inline dw_die_ref\n add_abstract_origin_attribute (dw_die_ref die, tree origin)\n {\n   dw_die_ref origin_die = NULL;\n \n-  if (TREE_CODE (origin) != FUNCTION_DECL)\n+  if (TREE_CODE (origin) != FUNCTION_DECL\n+      && TREE_CODE (origin) != BLOCK)\n     {\n       /* We may have gotten separated from the block for the inlined\n \t function, if we're in an exception handler or some such; make\n@@ -18651,6 +18652,8 @@ add_abstract_origin_attribute (dw_die_ref die, tree origin)\n     origin_die = lookup_decl_die (origin);\n   else if (TYPE_P (origin))\n     origin_die = lookup_type_die (origin);\n+  else if (TREE_CODE (origin) == BLOCK)\n+    origin_die = BLOCK_DIE (origin);\n \n   /* XXX: Functions that are never lowered don't always have correct block\n      trees (in the case of java, they simply have no block tree, in some other\n@@ -21467,6 +21470,10 @@ gen_lexical_block_die (tree stmt, dw_die_ref context_die)\n \t  BLOCK_DIE (stmt) = stmt_die;\n \t  old_die = NULL;\n \t}\n+\n+      tree origin = block_ultimate_origin (stmt);\n+      if (origin != NULL_TREE && origin != stmt)\n+\tadd_abstract_origin_attribute (stmt_die, origin);\n     }\n \n   if (old_die)"}, {"sha": "f144648aae8e68a9cef871e396b82dfacbed4acb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a96dae3efa97317540aee2a55f717aab1efe064/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a96dae3efa97317540aee2a55f717aab1efe064/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5a96dae3efa97317540aee2a55f717aab1efe064", "patch": "@@ -1,3 +1,7 @@\n+2016-05-10  Pierre-Marie de Rodat  <derodat@adacore.com>\n+\n+\t* gcc.dg/debug/dwarf2/nested_fun.c: New testcase.\n+\n 2016-05-09  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* gcc.target/i386/fabsneg-1.c New test."}, {"sha": "c783ac0c11aa975ccd73d578ad9edeb022928499", "filename": "gcc/testsuite/gcc.dg/debug/dwarf2/nested_fun.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a96dae3efa97317540aee2a55f717aab1efe064/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Fnested_fun.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a96dae3efa97317540aee2a55f717aab1efe064/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Fnested_fun.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Fnested_fun.c?ref=5a96dae3efa97317540aee2a55f717aab1efe064", "patch": "@@ -0,0 +1,65 @@\n+/* As part of inlining, a BLOCK (described as DW_TAG_lexical_block DIE's) may\n+   be present both as an abstract instance and a concrete one in the DWARF\n+   output.  This testcase attempts to make sure that the concrete ones refer to\n+   the abstract ones thanks to the DW_AT_abstract_origin attribute.\n+\n+   Such a back-link enables debuggers to make entities present in the abstract\n+   instance only available in concrete ones.  */\n+\n+/* { dg-options \"-O2 -g -std=gnu99 -gdwarf -dA\" } */\n+/* { dg-final { scan-assembler-times \"\\\\(DIE \\\\(0x.*\\\\) DW_TAG_lexical_block\\\\)\\[^)\\]*DW_AT_abstract_origin\" 1 } } */\n+\n+extern void *create (const char *);\n+extern void destroy (void *);\n+extern void do_nothing (char);\n+\n+struct string\n+{\n+  const char *data;\n+  int lb;\n+  int ub;\n+};\n+\n+int\n+main (void)\n+{\n+  void *o1 = create (\"foo\");\n+\n+  void\n+  parent (void)\n+  {\n+    {\n+      void *o2 = create (\"bar\");\n+\n+      int\n+      child (struct string s)\n+      {\n+\tint i = s.lb;\n+\n+\tif (s.lb <= s.ub)\n+\t  while (1)\n+\t    {\n+\t      char c = s.data[i - s.lb];\n+\t      do_nothing (c);\n+\t      if (c == 'o')\n+\t\treturn 1;\n+\t      if (i == s.ub)\n+\t\tbreak;\n+\t      ++i;\n+\t    }\n+\treturn 0;\n+      }\n+\n+      int r;\n+\n+      r = child ((struct string) {\"baz\", 1, 3});\n+      r = child ((struct string) {\"qux\", 2, 4});\n+      r = child ((struct string) {\"foobar\", 1, 6});\n+    }\n+\n+    do_nothing (0);\n+  }\n+\n+  parent ();\n+  return 0;\n+}"}]}