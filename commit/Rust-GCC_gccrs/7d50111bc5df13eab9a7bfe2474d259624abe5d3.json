{"sha": "7d50111bc5df13eab9a7bfe2474d259624abe5d3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2Q1MDExMWJjNWRmMTNlYWI5YTdiZmUyNDc0ZDI1OTYyNGFiZTVkMw==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2015-06-01T12:29:12Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2015-06-01T12:29:12Z"}, "message": "Introduce new type-based pool allocator.\n\n\t* alloc-pool.c (struct alloc_pool_descriptor): Move definition\n\tto header file.\n\t* alloc-pool.h (pool_allocator::pool_allocator): New function.\n\t(pool_allocator::release): Likewise.\n\t(inline pool_allocator::release_if_empty): Likewise.\n\t(inline pool_allocator::~pool_allocator): Likewise.\n\t(pool_allocator::allocate): Likewise.\n\t(pool_allocator::remove): Likewise.\n\nFrom-SVN: r223942", "tree": {"sha": "5e5b7af70400998f92983d09f4c721873f8f42be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5e5b7af70400998f92983d09f4c721873f8f42be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7d50111bc5df13eab9a7bfe2474d259624abe5d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d50111bc5df13eab9a7bfe2474d259624abe5d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d50111bc5df13eab9a7bfe2474d259624abe5d3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d50111bc5df13eab9a7bfe2474d259624abe5d3/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "32d48af55ed76de590977ef9fc32f392523ff4d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32d48af55ed76de590977ef9fc32f392523ff4d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32d48af55ed76de590977ef9fc32f392523ff4d9"}], "stats": {"total": 424, "additions": 394, "deletions": 30}, "files": [{"sha": "1411d498861851125de0ea39f1ca07a256e89d68", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d50111bc5df13eab9a7bfe2474d259624abe5d3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d50111bc5df13eab9a7bfe2474d259624abe5d3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7d50111bc5df13eab9a7bfe2474d259624abe5d3", "patch": "@@ -1,3 +1,14 @@\n+2015-06-01  Martin Liska  <mliska@suse.cz>\n+\n+\t* alloc-pool.c (struct alloc_pool_descriptor): Move definition\n+\tto header file.\n+\t* alloc-pool.h (pool_allocator::pool_allocator): New function.\n+\t(pool_allocator::release): Likewise.\n+\t(inline pool_allocator::release_if_empty): Likewise.\n+\t(inline pool_allocator::~pool_allocator): Likewise.\n+\t(pool_allocator::allocate): Likewise.\n+\t(pool_allocator::remove): Likewise.\n+\n 2015-06-01  James Greenhalgh  <james.greenhalgh@arm.com>\n \n \t* sched-deps.c (sched_analyze_2): Replace fuseable with fusible"}, {"sha": "829556fe25aabd1b4b021870f8d2bf901d7128e9", "filename": "gcc/alloc-pool.c", "status": "modified", "additions": 5, "deletions": 28, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d50111bc5df13eab9a7bfe2474d259624abe5d3/gcc%2Falloc-pool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d50111bc5df13eab9a7bfe2474d259624abe5d3/gcc%2Falloc-pool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falloc-pool.c?ref=7d50111bc5df13eab9a7bfe2474d259624abe5d3", "patch": "@@ -25,6 +25,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"hash-table.h\"\n #include \"hash-map.h\"\n \n+ALLOC_POOL_ID_TYPE last_id;\n+\n #define align_eight(x) (((x+7) >> 3) << 3)\n \n /* The internal allocation object.  */\n@@ -58,36 +60,10 @@ typedef struct allocation_object_def\n #define USER_PTR_FROM_ALLOCATION_OBJECT_PTR(X)\t\t\t\t\\\n    ((void *) (((allocation_object *) (X))->u.data))\n \n-#ifdef ENABLE_CHECKING\n-/* Last used ID.  */\n-static ALLOC_POOL_ID_TYPE last_id;\n-#endif\n-\n-/* Store information about each particular alloc_pool.  Note that this\n-   will underestimate the amount the amount of storage used by a small amount:\n-   1) The overhead in a pool is not accounted for.\n-   2) The unallocated elements in a block are not accounted for.  Note\n-   that this can at worst case be one element smaller that the block\n-   size for that pool.  */\n-struct alloc_pool_descriptor\n-{\n-  /* Number of pools allocated.  */\n-  unsigned long created;\n-  /* Gross allocated storage.  */\n-  unsigned long allocated;\n-  /* Amount of currently active storage. */\n-  unsigned long current;\n-  /* Peak amount of storage used.  */\n-  unsigned long peak;\n-  /* Size of element in the pool.  */\n-  int elt_size;\n-};\n-\n /* Hashtable mapping alloc_pool names to descriptors.  */\n-static hash_map<const char *, alloc_pool_descriptor> *alloc_pool_hash;\n+hash_map<const char *, alloc_pool_descriptor> *alloc_pool_hash;\n \n-/* For given name, return descriptor, create new if needed.  */\n-static struct alloc_pool_descriptor *\n+struct alloc_pool_descriptor *\n allocate_pool_descriptor (const char *name)\n {\n   if (!alloc_pool_hash)\n@@ -98,6 +74,7 @@ allocate_pool_descriptor (const char *name)\n   return &alloc_pool_hash->get_or_insert (name);\n }\n \n+\n /* Create a pool of things of size SIZE, with NUM in each block we\n    allocate.  */\n "}, {"sha": "ec671dcd6f4eba1391f3175c76cc3ef11f71c387", "filename": "gcc/alloc-pool.h", "status": "modified", "additions": 378, "deletions": 2, "changes": 380, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d50111bc5df13eab9a7bfe2474d259624abe5d3/gcc%2Falloc-pool.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d50111bc5df13eab9a7bfe2474d259624abe5d3/gcc%2Falloc-pool.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falloc-pool.h?ref=7d50111bc5df13eab9a7bfe2474d259624abe5d3", "patch": "@@ -20,6 +20,8 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef ALLOC_POOL_H\n #define ALLOC_POOL_H\n \n+#include \"hash-map.h\"\n+\n typedef unsigned long ALLOC_POOL_ID_TYPE;\n \n typedef struct alloc_pool_list_def\n@@ -31,9 +33,7 @@ typedef struct alloc_pool_list_def\n typedef struct alloc_pool_def\n {\n   const char *name;\n-#ifdef ENABLE_CHECKING\n   ALLOC_POOL_ID_TYPE id;\n-#endif\n   size_t elts_per_block;\n \n   /* These are the elements that have been allocated at least once and freed.  */\n@@ -63,4 +63,380 @@ extern void free_alloc_pool_if_empty (alloc_pool *);\n extern void *pool_alloc (alloc_pool) ATTRIBUTE_MALLOC;\n extern void pool_free (alloc_pool, void *);\n extern void dump_alloc_pool_statistics (void);\n+\n+typedef unsigned long ALLOC_POOL_ID_TYPE;\n+\n+/* Type based memory pool allocator.  */\n+template <typename T>\n+class pool_allocator\n+{\n+public:\n+  /* Default constructor for pool allocator called NAME.  Each block\n+     has NUM elements.  The allocator support EXTRA_SIZE and can\n+     potentially IGNORE_TYPE_SIZE.  */\n+  pool_allocator (const char *name, size_t num, size_t extra_size = 0,\n+\t\t  bool ignore_type_size = false);\n+\n+  /* Default destuctor.  */\n+  ~pool_allocator ();\n+\n+  /* Release internal data structures.  */\n+  void release ();\n+\n+  /* Release internal data structures if the pool has not allocated\n+     an object.  */\n+  void release_if_empty ();\n+\n+  /* Allocate a new object.  */\n+  T *allocate () ATTRIBUTE_MALLOC;\n+\n+  /* Release OBJECT that must come from the pool.  */\n+  void remove (T *object);\n+\n+private:\n+  struct allocation_pool_list\n+  {\n+    allocation_pool_list *next;\n+  };\n+\n+  /* Initialize a pool allocator.  */\n+  void initialize ();\n+\n+  template <typename U>\n+  struct allocation_object\n+  {\n+    /* The ID of alloc pool which the object was allocated from.  */\n+    ALLOC_POOL_ID_TYPE id;\n+\n+    union\n+      {\n+\t/* The data of the object.  */\n+\tchar data[1];\n+\n+\t/* Because we want any type of data to be well aligned after the ID,\n+\t   the following elements are here.  They are never accessed so\n+\t   the allocated object may be even smaller than this structure.\n+\t   We do not care about alignment for floating-point types.  */\n+\tchar *align_p;\n+\tint64_t align_i;\n+      } u;\n+\n+    static inline allocation_object<U> *get_instance (void *data_ptr)\n+    {\n+      return (allocation_object<U> *)(((char *)(data_ptr))\n+\t\t\t\t      - offsetof (allocation_object<U>,\n+\t\t\t\t\t\t  u.data));\n+    }\n+\n+    static inline U *get_data (void *instance_ptr)\n+    {\n+      return (U*)(((allocation_object<U> *) instance_ptr)->u.data);\n+    }\n+  };\n+\n+  /* Align X to 8.  */\n+  size_t align_eight (size_t x)\n+  {\n+    return (((x+7) >> 3) << 3);\n+  }\n+\n+  const char *m_name;\n+  ALLOC_POOL_ID_TYPE m_id;\n+  size_t m_elts_per_block;\n+\n+  /* These are the elements that have been allocated at least once\n+     and freed.  */\n+  allocation_pool_list *m_returned_free_list;\n+\n+  /* These are the elements that have not yet been allocated out of\n+     the last block obtained from XNEWVEC.  */\n+  char* m_virgin_free_list;\n+\n+  /* The number of elements in the virgin_free_list that can be\n+     allocated before needing another block.  */\n+  size_t m_virgin_elts_remaining;\n+  /* The number of elements that are allocated.  */\n+  size_t m_elts_allocated;\n+  /* The number of elements that are released.  */\n+  size_t m_elts_free;\n+  /* The number of allocated blocks.  */\n+  size_t m_blocks_allocated;\n+  /* List of blocks that are used to allocate new objects.  */\n+  allocation_pool_list *m_block_list;\n+  /* The number of elements in a block.  */\n+  size_t m_block_size;\n+  /* Size of a pool elements in bytes.  */\n+  size_t m_elt_size;\n+  /* Flag if we shoul ignore size of a type.  */\n+  bool m_ignore_type_size;\n+  /* Extra size in bytes that should be allocated for each element.  */\n+  size_t m_extra_size;\n+  /* Flag if a pool allocator is initialized.  */\n+  bool m_initialized;\n+};\n+\n+/* Last used ID.  */\n+extern ALLOC_POOL_ID_TYPE last_id;\n+\n+/* Store information about each particular alloc_pool.  Note that this\n+   will underestimate the amount the amount of storage used by a small amount:\n+   1) The overhead in a pool is not accounted for.\n+   2) The unallocated elements in a block are not accounted for.  Note\n+   that this can at worst case be one element smaller that the block\n+   size for that pool.  */\n+struct alloc_pool_descriptor\n+{\n+  /* Number of pools allocated.  */\n+  unsigned long created;\n+  /* Gross allocated storage.  */\n+  unsigned long allocated;\n+  /* Amount of currently active storage.  */\n+  unsigned long current;\n+  /* Peak amount of storage used.  */\n+  unsigned long peak;\n+  /* Size of element in the pool.  */\n+  int elt_size;\n+};\n+\n+\n+/* Hashtable mapping alloc_pool names to descriptors.  */\n+extern hash_map<const char *, alloc_pool_descriptor> *alloc_pool_hash;\n+\n+/* For given name, return descriptor, create new if needed.  */\n+alloc_pool_descriptor *\n+allocate_pool_descriptor (const char *name);\n+\n+template <typename T>\n+inline\n+pool_allocator<T>::pool_allocator (const char *name, size_t num,\n+\t\t\t\t   size_t extra_size, bool ignore_type_size):\n+  m_name (name), m_elts_per_block (num), m_returned_free_list (NULL),\n+  m_virgin_free_list (NULL), m_virgin_elts_remaining (0), m_elts_allocated (0),\n+  m_elts_free (0), m_blocks_allocated (0), m_block_list (NULL),\n+  m_ignore_type_size (ignore_type_size), m_extra_size (extra_size),\n+  m_initialized (false) {}\n+\n+/* Initialize a pool allocator.  */\n+\n+template <typename T>\n+void\n+pool_allocator<T>::initialize ()\n+{\n+  gcc_checking_assert (!m_initialized);\n+  m_initialized = true;\n+\n+  size_t header_size;\n+  size_t size = (m_ignore_type_size ? 0 : sizeof (T)) + m_extra_size;\n+\n+  gcc_checking_assert (m_name);\n+\n+  /* Make size large enough to store the list header.  */\n+  if (size < sizeof (allocation_pool_list*))\n+    size = sizeof (allocation_pool_list*);\n+\n+  /* Now align the size to a multiple of 4.  */\n+  size = align_eight (size);\n+\n+  /* Add the aligned size of ID.  */\n+  size += offsetof (allocation_object<T>, u.data);\n+\n+  /* Um, we can't really allocate 0 elements per block.  */\n+  gcc_checking_assert (m_elts_per_block);\n+\n+  m_elt_size = size;\n+\n+  if (GATHER_STATISTICS)\n+    {\n+      alloc_pool_descriptor *desc = allocate_pool_descriptor (m_name);\n+      desc->elt_size = size;\n+      desc->created++;\n+    }\n+\n+  /* List header size should be a multiple of 8.  */\n+  header_size = align_eight (sizeof (allocation_pool_list));\n+\n+  m_block_size = (size * m_elts_per_block) + header_size;\n+\n+#ifdef ENABLE_CHECKING\n+  /* Increase the last used ID and use it for this pool.\n+     ID == 0 is used for free elements of pool so skip it.  */\n+  last_id++;\n+  if (last_id == 0)\n+    last_id++;\n+\n+  m_id = last_id;\n+#endif\n+\n+}\n+\n+/* Free all memory allocated for the given memory pool.  */\n+template <typename T>\n+inline void\n+pool_allocator<T>::release ()\n+{\n+  if (!m_initialized)\n+    return;\n+\n+  allocation_pool_list *block, *next_block;\n+\n+  /* Free each block allocated to the pool.  */\n+  for (block = m_block_list; block != NULL; block = next_block)\n+    {\n+      next_block = block->next;\n+      free (block);\n+    }\n+\n+  if (GATHER_STATISTICS && false)\n+    {\n+      alloc_pool_descriptor *desc = allocate_pool_descriptor (m_name);\n+      desc->current -= (m_elts_allocated - m_elts_free) * m_elt_size;\n+    }\n+\n+  m_returned_free_list = NULL;\n+  m_virgin_free_list = NULL;\n+  m_virgin_elts_remaining = 0;\n+  m_elts_allocated = 0;\n+  m_elts_free = 0;\n+  m_blocks_allocated = 0;\n+  m_block_list = NULL;\n+}\n+\n+template <typename T>\n+void\n+inline pool_allocator<T>::release_if_empty ()\n+{\n+  if (m_elts_free == m_elts_allocated)\n+    release ();\n+}\n+\n+template <typename T>\n+inline pool_allocator<T>::~pool_allocator ()\n+{\n+  release ();\n+}\n+\n+/* Allocates one element from the pool specified.  */\n+template <typename T>\n+inline T *\n+pool_allocator<T>::allocate ()\n+{\n+  if (!m_initialized)\n+    initialize ();\n+\n+  allocation_pool_list *header;\n+#ifdef ENABLE_VALGRIND_ANNOTATIONS\n+  int size;\n+#endif\n+\n+  if (GATHER_STATISTICS)\n+    {\n+      alloc_pool_descriptor *desc = allocate_pool_descriptor (m_name);\n+\n+      desc->allocated += m_elt_size;\n+      desc->current += m_elt_size;\n+      if (desc->peak < desc->current)\n+\tdesc->peak = desc->current;\n+    }\n+\n+#ifdef ENABLE_VALGRIND_ANNOTATIONS\n+  size = m_elt_size - offsetof (allocation_object<T>, u.data);\n+#endif\n+\n+  /* If there are no more free elements, make some more!.  */\n+  if (!m_returned_free_list)\n+    {\n+      char *block;\n+      if (!m_virgin_elts_remaining)\n+\t{\n+\t  allocation_pool_list *block_header;\n+\n+\t  /* Make the block.  */\n+\t  block = XNEWVEC (char, m_block_size);\n+\t  block_header = (allocation_pool_list*) block;\n+\t  block += align_eight (sizeof (allocation_pool_list));\n+\n+\t  /* Throw it on the block list.  */\n+\t  block_header->next = m_block_list;\n+\t  m_block_list = block_header;\n+\n+\t  /* Make the block available for allocation.  */\n+\t  m_virgin_free_list = block;\n+\t  m_virgin_elts_remaining = m_elts_per_block;\n+\n+\t  /* Also update the number of elements we have free/allocated, and\n+\t     increment the allocated block count.  */\n+\t  m_elts_allocated += m_elts_per_block;\n+\t  m_elts_free += m_elts_per_block;\n+\t  m_blocks_allocated += 1;\n+\t}\n+\n+      /* We now know that we can take the first elt off the virgin list and\n+\t put it on the returned list.  */\n+      block = m_virgin_free_list;\n+      header = (allocation_pool_list*) allocation_object<T>::get_data (block);\n+      header->next = NULL;\n+#ifdef ENABLE_CHECKING\n+      /* Mark the element to be free.  */\n+      ((allocation_object<T> *) block)->id = 0;\n+#endif\n+      VALGRIND_DISCARD (VALGRIND_MAKE_MEM_NOACCESS (header,size));\n+      m_returned_free_list = header;\n+      m_virgin_free_list += m_elt_size;\n+      m_virgin_elts_remaining--;\n+\n+    }\n+\n+  /* Pull the first free element from the free list, and return it.  */\n+  header = m_returned_free_list;\n+  VALGRIND_DISCARD (VALGRIND_MAKE_MEM_DEFINED (header, sizeof (*header)));\n+  m_returned_free_list = header->next;\n+  m_elts_free--;\n+\n+#ifdef ENABLE_CHECKING\n+  /* Set the ID for element.  */\n+  allocation_object<T>::get_instance (header)->id = m_id;\n+#endif\n+  VALGRIND_DISCARD (VALGRIND_MAKE_MEM_UNDEFINED (header, size));\n+\n+  /* Call default constructor.  */\n+  return (T *)(header);\n+}\n+\n+/* Puts PTR back on POOL's free list.  */\n+template <typename T>\n+void\n+pool_allocator<T>::remove (T *object)\n+{\n+  gcc_checking_assert (m_initialized);\n+\n+  allocation_pool_list *header;\n+  int size;\n+  size = m_elt_size - offsetof (allocation_object<T>, u.data);\n+\n+#ifdef ENABLE_CHECKING\n+  gcc_assert (object\n+\t      /* Check if we free more than we allocated, which is Bad (TM).  */\n+\t      && m_elts_free < m_elts_allocated\n+\t      /* Check whether the PTR was allocated from POOL.  */\n+\t      && m_id == allocation_object<T>::get_instance (object)->id);\n+\n+  memset (object, 0xaf, size);\n+\n+  /* Mark the element to be free.  */\n+  allocation_object<T>::get_instance (object)->id = 0;\n+#endif\n+\n+  header = (allocation_pool_list*) object;\n+  header->next = m_returned_free_list;\n+  m_returned_free_list = header;\n+  VALGRIND_DISCARD (VALGRIND_MAKE_MEM_NOACCESS (object, size));\n+  m_elts_free++;\n+\n+  if (GATHER_STATISTICS)\n+    {\n+      alloc_pool_descriptor *desc = allocate_pool_descriptor (m_name);\n+      desc->current -= m_elt_size;\n+    }\n+}\n+\n #endif"}]}