{"sha": "e0472d7e8cefd8f4eed658424b8283fcd8ca4b15", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTA0NzJkN2U4Y2VmZDhmNGVlZDY1ODQyNGI4MjgzZmNkOGNhNGIxNQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2017-03-09T15:42:02Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2017-03-09T15:42:02Z"}, "message": "Define std::byte for C++17 (P0298R3)\n\n\t* doc/xml/manual/status_cxx2017.xml: Document std::byte support.\n\t* include/c_global/cstddef (std::byte): Define for C++17.\n\t* testsuite/18_support/byte/global_neg.cc: New test.\n\t* testsuite/18_support/byte/ops.cc: New test.\n\t* testsuite/18_support/byte/requirements.cc: New test.\n\nFrom-SVN: r246005", "tree": {"sha": "bd1fef6b0530b3691d23d9b68d125ad7f1405b70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bd1fef6b0530b3691d23d9b68d125ad7f1405b70"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e0472d7e8cefd8f4eed658424b8283fcd8ca4b15", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0472d7e8cefd8f4eed658424b8283fcd8ca4b15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0472d7e8cefd8f4eed658424b8283fcd8ca4b15", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0472d7e8cefd8f4eed658424b8283fcd8ca4b15/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f1fd3e2721cf68b2fe8b9516f260aee89872f60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f1fd3e2721cf68b2fe8b9516f260aee89872f60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f1fd3e2721cf68b2fe8b9516f260aee89872f60"}], "stats": {"total": 437, "additions": 425, "deletions": 12}, "files": [{"sha": "dabac4ad1280b9e0031cc1c7e855c4471868f4a6", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0472d7e8cefd8f4eed658424b8283fcd8ca4b15/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0472d7e8cefd8f4eed658424b8283fcd8ca4b15/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=e0472d7e8cefd8f4eed658424b8283fcd8ca4b15", "patch": "@@ -1,3 +1,11 @@\n+2017-03-09  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\t* doc/xml/manual/status_cxx2017.xml: Document std::byte support.\n+\t* include/c_global/cstddef (std::byte): Define for C++17.\n+\t* testsuite/18_support/byte/global_neg.cc: New test.\n+\t* testsuite/18_support/byte/ops.cc: New test.\n+\t* testsuite/18_support/byte/requirements.cc: New test.\n+\n 2017-03-05  Jonathan Wakely  <jwakely@redhat.com>\n \n \t* doc/xml/manual/status_cxx2017.xml: Document P0156R2 status."}, {"sha": "e0e4e8e7c8005e4d645cdb7beeef3d12e921e3cd", "filename": "libstdc++-v3/doc/xml/manual/status_cxx2017.xml", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0472d7e8cefd8f4eed658424b8283fcd8ca4b15/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fstatus_cxx2017.xml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0472d7e8cefd8f4eed658424b8283fcd8ca4b15/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fstatus_cxx2017.xml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fstatus_cxx2017.xml?ref=e0472d7e8cefd8f4eed658424b8283fcd8ca4b15", "patch": "@@ -459,18 +459,6 @@ Feature-testing recommendations for C++</link>.\n       <entry><code> __cpp_lib_has_unique_object_representations >= 201606 </code></entry>\n     </row>\n \n-    <row>\n-      <?dbhtml bgcolor=\"#C8B0B0\" ?>\n-      <entry> Ordered by default </entry>\n-      <entry>\n-\t<link xmlns:xlink=\"http://www.w3.org/1999/xlink\" xlink:href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0181r1.html\">\n-\tP0181R1\n-\t</link>\n-      </entry>\n-      <entry align=\"center\"> No </entry>\n-      <entry><code> __cpp_lib_default_order >= 201606</code></entry>\n-    </row>\n-\n     <row>\n       <entry> Polishing <code>&lt;chrono&gt;</code> </entry>\n       <entry>\n@@ -729,6 +717,19 @@ Feature-testing recommendations for C++</link>.\n       <entry><code> __cpp_lib_scoped_lock >= 201703 </code></entry>\n     </row>\n \n+    <row>\n+      <?dbhtml bgcolor=\"#C8B0B0\" ?>\n+      <entry>  </entry> byte type definition\n+      <entry>\n+\t<link xmlns:xlink=\"http://www.w3.org/1999/xlink\" xlink:href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0298r3.pdf\">\n+\tP0298R3\n+\t</link>\n+      </entry>\n+      <entry align=\"center\"> 7 </entry>\n+      <entry><code> ??? </code></entry>\n+    </row>\n+\n+\n   </tbody>\n </tgroup>\n </table>"}, {"sha": "09754ee45da45cb90ea637aea72424e1104b46fc", "filename": "libstdc++-v3/include/c_global/cstddef", "status": "modified", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0472d7e8cefd8f4eed658424b8283fcd8ca4b15/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcstddef", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0472d7e8cefd8f4eed658424b8283fcd8ca4b15/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcstddef", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcstddef?ref=e0472d7e8cefd8f4eed658424b8283fcd8ca4b15", "patch": "@@ -57,4 +57,133 @@ namespace std\n }\n #endif\n \n+#if __cplusplus > 201402L\n+namespace std\n+{\n+  /// std::byte\n+  enum class byte : unsigned char {};\n+\n+  template<typename _IntegerType> struct __byte_operand;\n+  template<> struct __byte_operand<bool> { using __type = byte; };\n+  template<> struct __byte_operand<char> { using __type = byte; };\n+  template<> struct __byte_operand<signed char> { using __type = byte; };\n+  template<> struct __byte_operand<unsigned char> { using __type = byte; };\n+#ifdef _GLIBCXX_USE_WCHAR_T\n+  template<> struct __byte_operand<wchar_t> { using __type = byte; };\n+#endif\n+  template<> struct __byte_operand<char16_t> { using __type = byte; };\n+  template<> struct __byte_operand<char32_t> { using __type = byte; };\n+  template<> struct __byte_operand<short> { using __type = byte; };\n+  template<> struct __byte_operand<unsigned short> { using __type = byte; };\n+  template<> struct __byte_operand<int> { using __type = byte; };\n+  template<> struct __byte_operand<unsigned int> { using __type = byte; };\n+  template<> struct __byte_operand<long> { using __type = byte; };\n+  template<> struct __byte_operand<unsigned long> { using __type = byte; };\n+  template<> struct __byte_operand<long long> { using __type = byte; };\n+  template<> struct __byte_operand<unsigned long long> { using __type = byte; };\n+#if defined(__GLIBCXX_TYPE_INT_N_0)\n+  template<> struct __byte_operand<__GLIBCXX_TYPE_INT_N_0>\n+  { using __type = byte; };\n+  template<> struct __byte_operand<unsigned __GLIBCXX_TYPE_INT_N_0>\n+  { using __type = byte; };\n+#endif\n+#if defined(__GLIBCXX_TYPE_INT_N_1)\n+  template<> struct __byte_operand<__GLIBCXX_TYPE_INT_N_1>\n+  { using __type = byte; };\n+  template<> struct __byte_operand<unsigned __GLIBCXX_TYPE_INT_N_1>\n+  { using __type = byte; };\n+#endif\n+#if defined(__GLIBCXX_TYPE_INT_N_2)\n+  template<> struct __byte_operand<__GLIBCXX_TYPE_INT_N_2>\n+  { using __type = byte; };\n+  template<> struct __byte_operand<unsigned __GLIBCXX_TYPE_INT_N_2>\n+  { using __type = byte; };\n+#endif\n+  template<typename _IntegerType>\n+    struct __byte_operand<const _IntegerType>\n+    : __byte_operand<_IntegerType> { };\n+  template<typename _IntegerType>\n+    struct __byte_operand<volatile _IntegerType>\n+    : __byte_operand<_IntegerType> { };\n+  template<typename _IntegerType>\n+    struct __byte_operand<const volatile _IntegerType>\n+    : __byte_operand<_IntegerType> { };\n+\n+  template<typename _IntegerType>\n+    using __byte_op_t = typename __byte_operand<_IntegerType>::__type;\n+\n+  template<typename _IntegerType>\n+    constexpr __byte_op_t<_IntegerType>&\n+    operator<<=(byte& __b, _IntegerType __shift) noexcept\n+    { return __b = byte(static_cast<unsigned char>(__b) << __shift); }\n+\n+  template<typename _IntegerType>\n+    constexpr __byte_op_t<_IntegerType>\n+    operator<<(byte __b, _IntegerType __shift) noexcept\n+    { return byte(static_cast<unsigned char>(__b) << __shift); }\n+\n+  template<typename _IntegerType>\n+    constexpr __byte_op_t<_IntegerType>&\n+    operator>>=(byte& __b, _IntegerType __shift) noexcept\n+    { return __b = byte(static_cast<unsigned char>(__b) >> __shift); }\n+\n+  template<typename _IntegerType>\n+    constexpr __byte_op_t<_IntegerType>\n+    operator>>(byte __b, _IntegerType __shift) noexcept\n+    { return byte(static_cast<unsigned char>(__b) >> __shift); }\n+\n+  constexpr byte&\n+  operator|=(byte& __l, byte __r) noexcept\n+  {\n+    return __l =\n+      byte(static_cast<unsigned char>(__l) | static_cast<unsigned char>(__r));\n+  }\n+\n+  constexpr byte\n+  operator|(byte __l, byte __r) noexcept\n+  {\n+    return\n+      byte(static_cast<unsigned char>(__l) | static_cast<unsigned char>(__r));\n+  }\n+\n+  constexpr byte&\n+  operator&=(byte& __l, byte __r) noexcept\n+  {\n+   return __l =\n+     byte(static_cast<unsigned char>(__l) & static_cast<unsigned char>(__r));\n+  }\n+\n+  constexpr byte\n+  operator&(byte __l, byte __r) noexcept\n+  {\n+    return\n+      byte(static_cast<unsigned char>(__l) & static_cast<unsigned char>(__r));\n+  }\n+\n+  constexpr byte&\n+  operator^=(byte& __l, byte __r) noexcept\n+  {\n+    return __l =\n+      byte(static_cast<unsigned char>(__l) ^ static_cast<unsigned char>(__r));\n+  }\n+\n+  constexpr byte\n+  operator^(byte __l, byte __r) noexcept\n+  {\n+    return\n+      byte(static_cast<unsigned char>(__l) ^ static_cast<unsigned char>(__r));\n+  }\n+\n+  constexpr byte\n+  operator~(byte __b) noexcept\n+  { return byte(~static_cast<unsigned char>(__b)); }\n+\n+  template<typename _IntegerType>\n+    constexpr _IntegerType\n+    to_integer(__byte_op_t<_IntegerType> __b) noexcept\n+    { return _IntegerType(__b); }\n+\n+} // namespace std\n+#endif\n+\n #endif // _GLIBCXX_CSTDDEF"}, {"sha": "722f65860f704ef07b6b30bed6ea6a14ff2263b4", "filename": "libstdc++-v3/testsuite/18_support/byte/global_neg.cc", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0472d7e8cefd8f4eed658424b8283fcd8ca4b15/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fbyte%2Fglobal_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0472d7e8cefd8f4eed658424b8283fcd8ca4b15/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fbyte%2Fglobal_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fbyte%2Fglobal_neg.cc?ref=e0472d7e8cefd8f4eed658424b8283fcd8ca4b15", "patch": "@@ -0,0 +1,24 @@\n+// Copyright (C) 2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do compile { target c++1z } }\n+\n+#include <stddef.h>\n+\n+byte b;\t\t\t// { dg-error \"does not name a type\" }\n+using std::byte;\t// { dg-error \"has not been declared\" }"}, {"sha": "6573bd9b1e32f6f1ebd013f7f322cdf066dece03", "filename": "libstdc++-v3/testsuite/18_support/byte/ops.cc", "status": "added", "additions": 224, "deletions": 0, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0472d7e8cefd8f4eed658424b8283fcd8ca4b15/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fbyte%2Fops.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0472d7e8cefd8f4eed658424b8283fcd8ca4b15/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fbyte%2Fops.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fbyte%2Fops.cc?ref=e0472d7e8cefd8f4eed658424b8283fcd8ca4b15", "patch": "@@ -0,0 +1,224 @@\n+// Copyright (C) 2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do compile { target c++1z } }\n+\n+#include <cstddef>\n+\n+constexpr bool is_byte(std::byte) { return true; }\n+template<typename T> constexpr bool is_byte(T) { return false; }\n+\n+template<typename T>\n+constexpr bool test_lshift_assign(unsigned char c, T t)\n+{\n+  std::byte b{c};\n+  b <<= t;\n+  return b == std::byte(c << t);\n+}\n+\n+static_assert( test_lshift_assign(0, 1) );\n+static_assert( test_lshift_assign(0, 1u) );\n+static_assert( test_lshift_assign(0, 1ll) );\n+static_assert( test_lshift_assign(4, 1) );\n+static_assert( test_lshift_assign(9, 2u) );\n+static_assert( test_lshift_assign(16, 3ll) );\n+static_assert( test_lshift_assign(127, 1) );\n+static_assert( test_lshift_assign(255, 2u) );\n+static_assert( test_lshift_assign(63, 3ll) );\n+\n+template<typename T>\n+constexpr bool test_lshift(unsigned char c, T t)\n+{\n+  const std::byte b{c};\n+  const std::byte b2 = b << t;\n+  return b2 == std::byte(c << t);\n+}\n+\n+static_assert( test_lshift(0, 1) );\n+static_assert( test_lshift(0, 1u) );\n+static_assert( test_lshift(0, 1ll) );\n+static_assert( test_lshift(4, 1) );\n+static_assert( test_lshift(9, 2u) );\n+static_assert( test_lshift(16, 3ll) );\n+static_assert( test_lshift(127, 1) );\n+static_assert( test_lshift(255, 2u) );\n+static_assert( test_lshift(63, 3ll) );\n+\n+template<typename T>\n+constexpr bool test_rshift_assign(unsigned char c, T t)\n+{\n+  std::byte b{c};\n+  b >>= t;\n+  return b == std::byte(c >> t);\n+}\n+\n+static_assert( test_rshift_assign(0, 1) );\n+static_assert( test_rshift_assign(0, 1u) );\n+static_assert( test_rshift_assign(0, 1ll) );\n+static_assert( test_rshift_assign(4, 1) );\n+static_assert( test_rshift_assign(9, 2u) );\n+static_assert( test_rshift_assign(16, 3ll) );\n+static_assert( test_rshift_assign(127, 1) );\n+static_assert( test_rshift_assign(255, 2u) );\n+static_assert( test_rshift_assign(63, 3ll) );\n+\n+template<typename T>\n+constexpr bool test_rshift(unsigned char c, T t)\n+{\n+  const std::byte b{c};\n+  const std::byte b2 = b >> t;\n+  return b2 == std::byte(c >> t);\n+}\n+\n+static_assert( test_rshift(0, 1) );\n+static_assert( test_rshift(0, 1u) );\n+static_assert( test_rshift(0, 1ll) );\n+static_assert( test_rshift(4, 1) );\n+static_assert( test_rshift(9, 2u) );\n+static_assert( test_rshift(16, 3ll) );\n+static_assert( test_rshift(127, 1) );\n+static_assert( test_rshift(255, 2u) );\n+static_assert( test_rshift(63, 3ll) );\n+\n+constexpr bool test_or_assign(unsigned char l, unsigned char r)\n+{\n+  std::byte b{l};\n+  b |= std::byte{r};\n+  return b == std::byte(l | r);\n+}\n+\n+static_assert( test_or_assign(0, 1) );\n+static_assert( test_or_assign(4, 1) );\n+static_assert( test_or_assign(9, 2) );\n+static_assert( test_or_assign(16, 3) );\n+static_assert( test_or_assign(63, 3) );\n+static_assert( test_or_assign(127, 1) );\n+static_assert( test_or_assign(255, 2) );\n+\n+constexpr bool test_or(unsigned char l, unsigned char r)\n+{\n+  const std::byte b1{l};\n+  const std::byte b2{r};\n+  return (b1 | b2) == std::byte(l | r);\n+}\n+\n+static_assert( test_or(0, 1) );\n+static_assert( test_or(0, 1u) );\n+static_assert( test_or(0, 1ll) );\n+static_assert( test_or(4, 1) );\n+static_assert( test_or(9, 2u) );\n+static_assert( test_or(16, 3ll) );\n+static_assert( test_or(127, 1) );\n+static_assert( test_or(255, 2u) );\n+static_assert( test_or(63, 3ll) );\n+\n+constexpr bool test_and_assign(unsigned char l, unsigned char r)\n+{\n+  std::byte b{l};\n+  b &= std::byte{r};\n+  return b == std::byte(l & r);\n+}\n+\n+static_assert( test_and_assign(0, 1) );\n+static_assert( test_and_assign(0, 1u) );\n+static_assert( test_and_assign(0, 1ll) );\n+static_assert( test_and_assign(4, 1) );\n+static_assert( test_and_assign(9, 2u) );\n+static_assert( test_and_assign(16, 3ll) );\n+static_assert( test_and_assign(127, 1) );\n+static_assert( test_and_assign(255, 2u) );\n+static_assert( test_and_assign(63, 3ll) );\n+\n+constexpr bool test_and(unsigned char l, unsigned char r)\n+{\n+  const std::byte b1{l};\n+  const std::byte b2{r};\n+  return (b1 & b2) == std::byte(l & r);\n+}\n+\n+static_assert( test_and(0, 1) );\n+static_assert( test_and(0, 1u) );\n+static_assert( test_and(0, 1ll) );\n+static_assert( test_and(4, 1) );\n+static_assert( test_and(9, 2u) );\n+static_assert( test_and(16, 3ll) );\n+static_assert( test_and(127, 1) );\n+static_assert( test_and(255, 2u) );\n+static_assert( test_and(63, 3ll) );\n+\n+constexpr bool test_xor_assign(unsigned char l, unsigned char r)\n+{\n+  std::byte b{l};\n+  b ^= std::byte{r};\n+  return b == std::byte(l ^ r);\n+}\n+\n+static_assert( test_xor_assign(0, 1) );\n+static_assert( test_xor_assign(0, 1u) );\n+static_assert( test_xor_assign(0, 1ll) );\n+static_assert( test_xor_assign(4, 1) );\n+static_assert( test_xor_assign(9, 2u) );\n+static_assert( test_xor_assign(16, 3ll) );\n+static_assert( test_xor_assign(127, 1) );\n+static_assert( test_xor_assign(255, 2u) );\n+static_assert( test_xor_assign(63, 3ll) );\n+\n+constexpr bool test_xor(unsigned char l, unsigned char r)\n+{\n+  const std::byte b1{l};\n+  const std::byte b2{r};\n+  return (b1 ^ b2) == std::byte(l ^ r);\n+}\n+\n+static_assert( test_xor(0, 1) );\n+static_assert( test_xor(0, 1u) );\n+static_assert( test_xor(0, 1ll) );\n+static_assert( test_xor(4, 1) );\n+static_assert( test_xor(9, 2u) );\n+static_assert( test_xor(16, 3ll) );\n+static_assert( test_xor(127, 1) );\n+static_assert( test_xor(255, 2u) );\n+static_assert( test_xor(63, 3ll) );\n+\n+constexpr bool test_complement(unsigned char c)\n+{\n+  const std::byte b{c};\n+  return ~b == std::byte(~c);\n+}\n+\n+static_assert( test_complement(0) );\n+static_assert( test_complement(4) );\n+static_assert( test_complement(9) );\n+static_assert( test_complement(16) );\n+static_assert( test_complement(63) );\n+static_assert( test_complement(127) );\n+static_assert( test_complement(255) );\n+\n+template<typename T>\n+constexpr bool test_to_integer(unsigned char c)\n+{\n+  std::byte b{c};\n+  return std::to_integer<T>(b) == T(c);\n+}\n+\n+static_assert( test_to_integer<int>(0) );\n+static_assert( test_to_integer<int>(255) );\n+static_assert( test_to_integer<signed char>(255) );\n+static_assert( test_to_integer<unsigned>(0) );\n+static_assert( test_to_integer<unsigned>(255) );\n+"}, {"sha": "da5fc91a12a654ab2b53ce67a12e7b8c00dde6a0", "filename": "libstdc++-v3/testsuite/18_support/byte/requirements.cc", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0472d7e8cefd8f4eed658424b8283fcd8ca4b15/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fbyte%2Frequirements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0472d7e8cefd8f4eed658424b8283fcd8ca4b15/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fbyte%2Frequirements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fbyte%2Frequirements.cc?ref=e0472d7e8cefd8f4eed658424b8283fcd8ca4b15", "patch": "@@ -0,0 +1,27 @@\n+// Copyright (C) 2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do compile { target c++1z } }\n+\n+#include <cstddef>\n+\n+static_assert( sizeof(std::byte) == sizeof(unsigned char) );\n+static_assert( alignof(std::byte) == alignof(unsigned char) );\n+\n+// Use the built-in to avoid depending on <type_traits>\n+__underlying_type(std::byte)* p = (unsigned char*)nullptr;"}]}