{"sha": "837748497c4bbaef1dc957d555f97e7a4995e002", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODM3NzQ4NDk3YzRiYmFlZjFkYzk1N2Q1NTVmOTdlN2E0OTk1ZTAwMg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-01-23T21:43:06Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-01-23T21:43:06Z"}, "message": "i386.c (dbx_register_map, [...]): New.\n\n        * i386.c (dbx_register_map, svr4_dbx_register_map): New.\n        * i386.h (DBX_REGISTER_NUMBER): Use them.\n        * i386/beos-elf.h, i386/freebsd-elf.h, i386/i386elf.h: Likewise.\n        * i386/linux.h, i386/osfrose.h, i386/ptx4-i.h: Likewise.\n        * i386/rtemself.h, i386/sco5.h, i386/sysv4.h: Likewise.\n        * i386/sequent.h: Kill incorrect comment.\n\nFrom-SVN: r31575", "tree": {"sha": "7973189fdbe29f2b846a14cf46a30bf797e2e073", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7973189fdbe29f2b846a14cf46a30bf797e2e073"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/837748497c4bbaef1dc957d555f97e7a4995e002", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/837748497c4bbaef1dc957d555f97e7a4995e002", "html_url": "https://github.com/Rust-GCC/gccrs/commit/837748497c4bbaef1dc957d555f97e7a4995e002", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/837748497c4bbaef1dc957d555f97e7a4995e002/comments", "author": null, "committer": null, "parents": [{"sha": "d416576b49bf4913ad2bf187948b6bdc7e93f7a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d416576b49bf4913ad2bf187948b6bdc7e93f7a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d416576b49bf4913ad2bf187948b6bdc7e93f7a3"}], "stats": {"total": 660, "additions": 102, "deletions": 558}, "files": [{"sha": "fc63569ff2f4b888e9718bbbb966ef86f855cc30", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/837748497c4bbaef1dc957d555f97e7a4995e002/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/837748497c4bbaef1dc957d555f97e7a4995e002/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=837748497c4bbaef1dc957d555f97e7a4995e002", "patch": "@@ -1,3 +1,12 @@\n+2000-01-23  Richard Henderson  <rth@cygnus.com>\n+\n+\t* i386.c (dbx_register_map, svr4_dbx_register_map): New.\n+\t* i386.h (DBX_REGISTER_NUMBER): Use them.\n+\t* i386/beos-elf.h, i386/freebsd-elf.h, i386/i386elf.h: Likewise.\n+\t* i386/linux.h, i386/osfrose.h, i386/ptx4-i.h: Likewise.\n+\t* i386/rtemself.h, i386/sco5.h, i386/sysv4.h: Likewise.\n+\t* i386/sequent.h: Kill incorrect comment.\n+\n 2000-01-23  Mark Mitchell  <mark@codesourcery.com>\n \n \t* ggc-page.c (struct page_entry): Make `context_depth' an"}, {"sha": "34d94f5d8a899fa4d76b6d1c6ef2d48927ae6173", "filename": "gcc/config/i386/beos-elf.h", "status": "modified", "additions": 1, "deletions": 66, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/837748497c4bbaef1dc957d555f97e7a4995e002/gcc%2Fconfig%2Fi386%2Fbeos-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/837748497c4bbaef1dc957d555f97e7a4995e002/gcc%2Fconfig%2Fi386%2Fbeos-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fbeos-elf.h?ref=837748497c4bbaef1dc957d555f97e7a4995e002", "patch": "@@ -48,73 +48,8 @@ Boston, MA 02111-1307, USA.  */\n    necessary when compiling PIC code.  */\n #define JUMP_TABLES_IN_TEXT_SECTION (flag_pic)\n \n-/* Copy this from the svr4 specifications... */\n-/* Define the register numbers to be used in Dwarf debugging information.\n-   The SVR4 reference port C compiler uses the following register numbers\n-   in its Dwarf output code:\n-\t0 for %eax (gnu regno = 0)\n-\t1 for %ecx (gnu regno = 2)\n-\t2 for %edx (gnu regno = 1)\n-\t3 for %ebx (gnu regno = 3)\n-\t4 for %esp (gnu regno = 7)\n-\t5 for %ebp (gnu regno = 6)\n-\t6 for %esi (gnu regno = 4)\n-\t7 for %edi (gnu regno = 5)\n-   The following three DWARF register numbers are never generated by\n-   the SVR4 C compiler or by the GNU compilers, but SDB on x86/svr4\n-   believes these numbers have these meanings.\n-\t8  for %eip    (no gnu equivalent)\n-\t9  for %eflags (no gnu equivalent)\n-\t10 for %trapno (no gnu equivalent)\n-   It is not at all clear how we should number the FP stack registers\n-   for the x86 architecture.  If the version of SDB on x86/svr4 were\n-   a bit less brain dead with respect to floating-point then we would\n-   have a precedent to follow with respect to DWARF register numbers\n-   for x86 FP registers, but the SDB on x86/svr4 is so completely\n-   broken with respect to FP registers that it is hardly worth thinking\n-   of it as something to strive for compatibility with.\n-   The version of x86/svr4 SDB I have at the moment does (partially)\n-   seem to believe that DWARF register number 11 is associated with\n-   the x86 register %st(0), but that's about all.  Higher DWARF\n-   register numbers don't seem to be associated with anything in\n-   particular, and even for DWARF regno 11, SDB only seems to under-\n-   stand that it should say that a variable lives in %st(0) (when\n-   asked via an `=' command) if we said it was in DWARF regno 11,\n-   but SDB still prints garbage when asked for the value of the\n-   variable in question (via a `/' command).\n-   (Also note that the labels SDB prints for various FP stack regs\n-   when doing an `x' command are all wrong.)\n-   Note that these problems generally don't affect the native SVR4\n-   C compiler because it doesn't allow the use of -O with -g and\n-   because when it is *not* optimizing, it allocates a memory\n-   location for each floating-point variable, and the memory\n-   location is what gets described in the DWARF AT_location\n-   attribute for the variable in question.\n-   Regardless of the severe mental illness of the x86/svr4 SDB, we\n-   do something sensible here and we use the following DWARF\n-   register numbers.  Note that these are all stack-top-relative\n-   numbers.\n-\t11 for %st(0) (gnu regno = 8)\n-\t12 for %st(1) (gnu regno = 9)\n-\t13 for %st(2) (gnu regno = 10)\n-\t14 for %st(3) (gnu regno = 11)\n-\t15 for %st(4) (gnu regno = 12)\n-\t16 for %st(5) (gnu regno = 13)\n-\t17 for %st(6) (gnu regno = 14)\n-\t18 for %st(7) (gnu regno = 15)\n-*/\n #undef DBX_REGISTER_NUMBER\n-#define DBX_REGISTER_NUMBER(n) \\\n-((n) == 0 ? 0 \\\n- : (n) == 1 ? 2 \\\n- : (n) == 2 ? 1 \\\n- : (n) == 3 ? 3 \\\n- : (n) == 4 ? 6 \\\n- : (n) == 5 ? 7 \\\n- : (n) == 6 ? 5 \\\n- : (n) == 7 ? 4 \\\n- : ((n) >= FIRST_STACK_REG && (n) <= LAST_STACK_REG) ? (n)+3 \\\n- : (-1))\n+#define DBX_REGISTER_NUMBER(n)  svr4_dbx_register_map[n]\n \n /* Output assembler code to FILE to increment profiler label # LABELNO\n    for profiling a function entry.  */"}, {"sha": "360f844d0e0f2d6e31589e11c7ce37eea319b9df", "filename": "gcc/config/i386/freebsd-elf.h", "status": "modified", "additions": 1, "deletions": 66, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/837748497c4bbaef1dc957d555f97e7a4995e002/gcc%2Fconfig%2Fi386%2Ffreebsd-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/837748497c4bbaef1dc957d555f97e7a4995e002/gcc%2Fconfig%2Fi386%2Ffreebsd-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Ffreebsd-elf.h?ref=837748497c4bbaef1dc957d555f97e7a4995e002", "patch": "@@ -49,73 +49,8 @@ Boston, MA 02111-1307, USA.  */\n    necessary when compiling PIC code.  */\n #define JUMP_TABLES_IN_TEXT_SECTION (flag_pic)\n \n-/* Copy this from the svr4 specifications... */\n-/* Define the register numbers to be used in Dwarf debugging information.\n-   The SVR4 reference port C compiler uses the following register numbers\n-   in its Dwarf output code:\n-\t0 for %eax (gnu regno = 0)\n-\t1 for %ecx (gnu regno = 2)\n-\t2 for %edx (gnu regno = 1)\n-\t3 for %ebx (gnu regno = 3)\n-\t4 for %esp (gnu regno = 7)\n-\t5 for %ebp (gnu regno = 6)\n-\t6 for %esi (gnu regno = 4)\n-\t7 for %edi (gnu regno = 5)\n-   The following three DWARF register numbers are never generated by\n-   the SVR4 C compiler or by the GNU compilers, but SDB on x86/svr4\n-   believes these numbers have these meanings.\n-\t8  for %eip    (no gnu equivalent)\n-\t9  for %eflags (no gnu equivalent)\n-\t10 for %trapno (no gnu equivalent)\n-   It is not at all clear how we should number the FP stack registers\n-   for the x86 architecture.  If the version of SDB on x86/svr4 were\n-   a bit less brain dead with respect to floating-point then we would\n-   have a precedent to follow with respect to DWARF register numbers\n-   for x86 FP registers, but the SDB on x86/svr4 is so completely\n-   broken with respect to FP registers that it is hardly worth thinking\n-   of it as something to strive for compatibility with.\n-   The version of x86/svr4 SDB I have at the moment does (partially)\n-   seem to believe that DWARF register number 11 is associated with\n-   the x86 register %st(0), but that's about all.  Higher DWARF\n-   register numbers don't seem to be associated with anything in\n-   particular, and even for DWARF regno 11, SDB only seems to under-\n-   stand that it should say that a variable lives in %st(0) (when\n-   asked via an `=' command) if we said it was in DWARF regno 11,\n-   but SDB still prints garbage when asked for the value of the\n-   variable in question (via a `/' command).\n-   (Also note that the labels SDB prints for various FP stack regs\n-   when doing an `x' command are all wrong.)\n-   Note that these problems generally don't affect the native SVR4\n-   C compiler because it doesn't allow the use of -O with -g and\n-   because when it is *not* optimizing, it allocates a memory\n-   location for each floating-point variable, and the memory\n-   location is what gets described in the DWARF AT_location\n-   attribute for the variable in question.\n-   Regardless of the severe mental illness of the x86/svr4 SDB, we\n-   do something sensible here and we use the following DWARF\n-   register numbers.  Note that these are all stack-top-relative\n-   numbers.\n-\t11 for %st(0) (gnu regno = 8)\n-\t12 for %st(1) (gnu regno = 9)\n-\t13 for %st(2) (gnu regno = 10)\n-\t14 for %st(3) (gnu regno = 11)\n-\t15 for %st(4) (gnu regno = 12)\n-\t16 for %st(5) (gnu regno = 13)\n-\t17 for %st(6) (gnu regno = 14)\n-\t18 for %st(7) (gnu regno = 15)\n-*/\n #undef DBX_REGISTER_NUMBER\n-#define DBX_REGISTER_NUMBER(n) \\\n-((n) == 0 ? 0 \\\n- : (n) == 1 ? 2 \\\n- : (n) == 2 ? 1 \\\n- : (n) == 3 ? 3 \\\n- : (n) == 4 ? 6 \\\n- : (n) == 5 ? 7 \\\n- : (n) == 6 ? 5 \\\n- : (n) == 7 ? 4 \\\n- : ((n) >= FIRST_STACK_REG && (n) <= LAST_STACK_REG) ? (n)+3 \\\n- : (-1))\n+#define DBX_REGISTER_NUMBER(n)  svr4_dbx_register_map[n]\n \n /* Tell final.c that we don't need a label passed to mcount.  */\n "}, {"sha": "c002262f542e8542c8c8530b6a3b5ab6b1f2490b", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 75, "deletions": 3, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/837748497c4bbaef1dc957d555f97e7a4995e002/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/837748497c4bbaef1dc957d555f97e7a4995e002/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=837748497c4bbaef1dc957d555f97e7a4995e002", "patch": "@@ -233,11 +233,83 @@ enum reg_class const regclass_map[FIRST_PSEUDO_REGISTER] =\n   FP_TOP_REG, FP_SECOND_REG, FLOAT_REGS, FLOAT_REGS,\n   FLOAT_REGS, FLOAT_REGS, FLOAT_REGS, FLOAT_REGS,\n   /* arg pointer */\n-  INDEX_REGS,\n-  /* flags, fpsr */\n-  NO_REGS, NO_REGS\n+  NON_Q_REGS,\n+  /* flags, fpsr, dirflag */\n+  NO_REGS, NO_REGS, NO_REGS\n };\n \n+/* The \"default\" register map.  */\n+\n+int const dbx_register_map[FIRST_PSEUDO_REGISTER] = \n+{\n+  0, 2, 1, 3, 6, 7, 4, 5,\t\t/* general regs */\n+  12, 13, 14, 15, 16, 17, 18, 19,\t/* fp regs */\n+  -1, -1, -1, -1,\t\t\t/* arg, flags, fpsr, dir */\n+};\n+\n+/* Define the register numbers to be used in Dwarf debugging information.\n+   The SVR4 reference port C compiler uses the following register numbers\n+   in its Dwarf output code:\n+\t0 for %eax (gcc regno = 0)\n+\t1 for %ecx (gcc regno = 2)\n+\t2 for %edx (gcc regno = 1)\n+\t3 for %ebx (gcc regno = 3)\n+\t4 for %esp (gcc regno = 7)\n+\t5 for %ebp (gcc regno = 6)\n+\t6 for %esi (gcc regno = 4)\n+\t7 for %edi (gcc regno = 5)\n+   The following three DWARF register numbers are never generated by\n+   the SVR4 C compiler or by the GNU compilers, but SDB on x86/svr4\n+   believes these numbers have these meanings.\n+\t8  for %eip    (no gcc equivalent)\n+\t9  for %eflags (gcc regno = 17)\n+\t10 for %trapno (no gcc equivalent)\n+   It is not at all clear how we should number the FP stack registers\n+   for the x86 architecture.  If the version of SDB on x86/svr4 were\n+   a bit less brain dead with respect to floating-point then we would\n+   have a precedent to follow with respect to DWARF register numbers\n+   for x86 FP registers, but the SDB on x86/svr4 is so completely\n+   broken with respect to FP registers that it is hardly worth thinking\n+   of it as something to strive for compatibility with.\n+   The version of x86/svr4 SDB I have at the moment does (partially)\n+   seem to believe that DWARF register number 11 is associated with\n+   the x86 register %st(0), but that's about all.  Higher DWARF\n+   register numbers don't seem to be associated with anything in\n+   particular, and even for DWARF regno 11, SDB only seems to under-\n+   stand that it should say that a variable lives in %st(0) (when\n+   asked via an `=' command) if we said it was in DWARF regno 11,\n+   but SDB still prints garbage when asked for the value of the\n+   variable in question (via a `/' command).\n+   (Also note that the labels SDB prints for various FP stack regs\n+   when doing an `x' command are all wrong.)\n+   Note that these problems generally don't affect the native SVR4\n+   C compiler because it doesn't allow the use of -O with -g and\n+   because when it is *not* optimizing, it allocates a memory\n+   location for each floating-point variable, and the memory\n+   location is what gets described in the DWARF AT_location\n+   attribute for the variable in question.\n+   Regardless of the severe mental illness of the x86/svr4 SDB, we\n+   do something sensible here and we use the following DWARF\n+   register numbers.  Note that these are all stack-top-relative\n+   numbers.\n+\t11 for %st(0) (gcc regno = 8)\n+\t12 for %st(1) (gcc regno = 9)\n+\t13 for %st(2) (gcc regno = 10)\n+\t14 for %st(3) (gcc regno = 11)\n+\t15 for %st(4) (gcc regno = 12)\n+\t16 for %st(5) (gcc regno = 13)\n+\t17 for %st(6) (gcc regno = 14)\n+\t18 for %st(7) (gcc regno = 15)\n+*/\n+int const svr4_dbx_register_map[FIRST_PSEUDO_REGISTER] = \n+{\n+  0, 2, 1, 3, 6, 7, 5, 4,\t\t/* general regs */\n+  11, 12, 13, 14, 15, 16, 17, 18,\t/* fp regs */\n+  -1, 9, -1, -1,\t\t\t/* arg, flags, fpsr, dir */\n+};\n+\n+\n+\n /* Test and compare insns in i386.md store the information needed to\n    generate branch and scc insns here.  */\n "}, {"sha": "859b4604e09af392c67f0922e52683d21a3c9a56", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/837748497c4bbaef1dc957d555f97e7a4995e002/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/837748497c4bbaef1dc957d555f97e7a4995e002/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=837748497c4bbaef1dc957d555f97e7a4995e002", "patch": "@@ -2185,17 +2185,10 @@ number as al, and ax.\n \n /* How to renumber registers for dbx and gdb.  */\n \n-/* {0,2,1,3,6,7,4,5,12,13,14,15,16,17}  */\n-#define DBX_REGISTER_NUMBER(n) \\\n-((n) == 0 ? 0 : \\\n- (n) == 1 ? 2 : \\\n- (n) == 2 ? 1 : \\\n- (n) == 3 ? 3 : \\\n- (n) == 4 ? 6 : \\\n- (n) == 5 ? 7 : \\\n- (n) == 6 ? 4 : \\\n- (n) == 7 ? 5 : \\\n- (n) + 4)\n+#define DBX_REGISTER_NUMBER(n)  dbx_register_map[n]\n+\n+extern int const dbx_register_map[FIRST_PSEUDO_REGISTER];\n+extern int const svr4_dbx_register_map[FIRST_PSEUDO_REGISTER];\n \n /* Before the prologue, RA is at 0(%esp).  */\n #define INCOMING_RETURN_ADDR_RTX \\"}, {"sha": "2e75310c0c407c913f39711a8e7d2e54333562ad", "filename": "gcc/config/i386/i386elf.h", "status": "modified", "additions": 1, "deletions": 75, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/837748497c4bbaef1dc957d555f97e7a4995e002/gcc%2Fconfig%2Fi386%2Fi386elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/837748497c4bbaef1dc957d555f97e7a4995e002/gcc%2Fconfig%2Fi386%2Fi386elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386elf.h?ref=837748497c4bbaef1dc957d555f97e7a4995e002", "patch": "@@ -115,82 +115,8 @@ do { long value[3];\t\t\t\t\t\t\t\\\n \tfprintf (FILE, \"\\t.version\\t\\\"01.01\\\"\\n\");\t\t\t\\\n   } while (0)\n \n-/* Define the register numbers to be used in Dwarf debugging information.\n-   The SVR4 reference port C compiler uses the following register numbers\n-   in its Dwarf output code:\n-\n-\t0 for %eax (gnu regno = 0)\n-\t1 for %ecx (gnu regno = 2)\n-\t2 for %edx (gnu regno = 1)\n-\t3 for %ebx (gnu regno = 3)\n-\t4 for %esp (gnu regno = 7)\n-\t5 for %ebp (gnu regno = 6)\n-\t6 for %esi (gnu regno = 4)\n-\t7 for %edi (gnu regno = 5)\n-\n-   The following three DWARF register numbers are never generated by\n-   the SVR4 C compiler or by the GNU compilers, but SDB on x86/svr4\n-   believes these numbers have these meanings.\n-\n-\t8  for %eip    (no gnu equivalent)\n-\t9  for %eflags (no gnu equivalent)\n-\t10 for %trapno (no gnu equivalent)\n-\n-   It is not at all clear how we should number the FP stack registers\n-   for the x86 architecture.  If the version of SDB on x86/svr4 were\n-   a bit less brain dead with respect to floating-point then we would\n-   have a precedent to follow with respect to DWARF register numbers\n-   for x86 FP registers, but the SDB on x86/svr4 is so completely\n-   broken with respect to FP registers that it is hardly worth thinking\n-   of it as something to strive for compatibility with.\n-\n-   The verison of x86/svr4 SDB I have at the moment does (partially)\n-   seem to believe that DWARF register number 11 is associated with\n-   the x86 register %st(0), but that's about all.  Higher DWARF\n-   register numbers don't seem to be associated with anything in\n-   particular, and even for DWARF regno 11, SDB only seems to under-\n-   stand that it should say that a variable lives in %st(0) (when\n-   asked via an `=' command) if we said it was in DWARF regno 11,\n-   but SDB still prints garbage when asked for the value of the\n-   variable in question (via a `/' command).\n-\n-   (Also note that the labels SDB prints for various FP stack regs\n-   when doing an `x' command are all wrong.)\n-\n-   Note that these problems generally don't affect the native SVR4\n-   C compiler because it doesn't allow the use of -O with -g and\n-   because when it is *not* optimizing, it allocates a memory\n-   location for each floating-point variable, and the memory\n-   location is what gets described in the DWARF AT_location\n-   attribute for the variable in question.\n-\n-   Regardless of the severe mental illness of the x86/svr4 SDB, we\n-   do something sensible here and we use the following DWARF\n-   register numbers.  Note that these are all stack-top-relative\n-   numbers.\n-\n-\t11 for %st(0) (gnu regno = 8)\n-\t12 for %st(1) (gnu regno = 9)\n-\t13 for %st(2) (gnu regno = 10)\n-\t14 for %st(3) (gnu regno = 11)\n-\t15 for %st(4) (gnu regno = 12)\n-\t16 for %st(5) (gnu regno = 13)\n-\t17 for %st(6) (gnu regno = 14)\n-\t18 for %st(7) (gnu regno = 15)\n-*/\n-\n #undef DBX_REGISTER_NUMBER\n-#define DBX_REGISTER_NUMBER(n) \\\n-((n) == 0 ? 0 \\\n- : (n) == 1 ? 2 \\\n- : (n) == 2 ? 1 \\\n- : (n) == 3 ? 3 \\\n- : (n) == 4 ? 6 \\\n- : (n) == 5 ? 7 \\\n- : (n) == 6 ? 5 \\\n- : (n) == 7 ? 4 \\\n- : ((n) >= FIRST_STACK_REG && (n) <= LAST_STACK_REG) ? (n)+3 \\\n- : (-1))\n+#define DBX_REGISTER_NUMBER(n)  svr4_dbx_register_map[n]\n \n /* The routine used to output sequences of byte values.  We use a special\n    version of this for most svr4 targets because doing so makes the"}, {"sha": "9ba64c67ee7af93030984201801cedd6fcc480d8", "filename": "gcc/config/i386/linux.h", "status": "modified", "additions": 1, "deletions": 66, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/837748497c4bbaef1dc957d555f97e7a4995e002/gcc%2Fconfig%2Fi386%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/837748497c4bbaef1dc957d555f97e7a4995e002/gcc%2Fconfig%2Fi386%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Flinux.h?ref=837748497c4bbaef1dc957d555f97e7a4995e002", "patch": "@@ -51,73 +51,8 @@ Boston, MA 02111-1307, USA.  */\n    necessary when compiling PIC code.  */\n #define JUMP_TABLES_IN_TEXT_SECTION (flag_pic)\n \n-/* Copy this from the svr4 specifications... */\n-/* Define the register numbers to be used in Dwarf debugging information.\n-   The SVR4 reference port C compiler uses the following register numbers\n-   in its Dwarf output code:\n-\t0 for %eax (gnu regno = 0)\n-\t1 for %ecx (gnu regno = 2)\n-\t2 for %edx (gnu regno = 1)\n-\t3 for %ebx (gnu regno = 3)\n-\t4 for %esp (gnu regno = 7)\n-\t5 for %ebp (gnu regno = 6)\n-\t6 for %esi (gnu regno = 4)\n-\t7 for %edi (gnu regno = 5)\n-   The following three DWARF register numbers are never generated by\n-   the SVR4 C compiler or by the GNU compilers, but SDB on x86/svr4\n-   believes these numbers have these meanings.\n-\t8  for %eip    (no gnu equivalent)\n-\t9  for %eflags (no gnu equivalent)\n-\t10 for %trapno (no gnu equivalent)\n-   It is not at all clear how we should number the FP stack registers\n-   for the x86 architecture.  If the version of SDB on x86/svr4 were\n-   a bit less brain dead with respect to floating-point then we would\n-   have a precedent to follow with respect to DWARF register numbers\n-   for x86 FP registers, but the SDB on x86/svr4 is so completely\n-   broken with respect to FP registers that it is hardly worth thinking\n-   of it as something to strive for compatibility with.\n-   The version of x86/svr4 SDB I have at the moment does (partially)\n-   seem to believe that DWARF register number 11 is associated with\n-   the x86 register %st(0), but that's about all.  Higher DWARF\n-   register numbers don't seem to be associated with anything in\n-   particular, and even for DWARF regno 11, SDB only seems to under-\n-   stand that it should say that a variable lives in %st(0) (when\n-   asked via an `=' command) if we said it was in DWARF regno 11,\n-   but SDB still prints garbage when asked for the value of the\n-   variable in question (via a `/' command).\n-   (Also note that the labels SDB prints for various FP stack regs\n-   when doing an `x' command are all wrong.)\n-   Note that these problems generally don't affect the native SVR4\n-   C compiler because it doesn't allow the use of -O with -g and\n-   because when it is *not* optimizing, it allocates a memory\n-   location for each floating-point variable, and the memory\n-   location is what gets described in the DWARF AT_location\n-   attribute for the variable in question.\n-   Regardless of the severe mental illness of the x86/svr4 SDB, we\n-   do something sensible here and we use the following DWARF\n-   register numbers.  Note that these are all stack-top-relative\n-   numbers.\n-\t11 for %st(0) (gnu regno = 8)\n-\t12 for %st(1) (gnu regno = 9)\n-\t13 for %st(2) (gnu regno = 10)\n-\t14 for %st(3) (gnu regno = 11)\n-\t15 for %st(4) (gnu regno = 12)\n-\t16 for %st(5) (gnu regno = 13)\n-\t17 for %st(6) (gnu regno = 14)\n-\t18 for %st(7) (gnu regno = 15)\n-*/\n #undef DBX_REGISTER_NUMBER\n-#define DBX_REGISTER_NUMBER(n) \\\n-((n) == 0 ? 0 \\\n- : (n) == 1 ? 2 \\\n- : (n) == 2 ? 1 \\\n- : (n) == 3 ? 3 \\\n- : (n) == 4 ? 6 \\\n- : (n) == 5 ? 7 \\\n- : (n) == 6 ? 5 \\\n- : (n) == 7 ? 4 \\\n- : ((n) >= FIRST_STACK_REG && (n) <= LAST_STACK_REG) ? (n)+3 \\\n- : (-1))\n+#define DBX_REGISTER_NUMBER(n)  svr4_dbx_register_map[n]\n \n /* Output assembler code to FILE to increment profiler label # LABELNO\n    for profiling a function entry.  */"}, {"sha": "1a2eee53dfdc472870ea2a6dd353bb925916615e", "filename": "gcc/config/i386/osfrose.h", "status": "modified", "additions": 5, "deletions": 29, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/837748497c4bbaef1dc957d555f97e7a4995e002/gcc%2Fconfig%2Fi386%2Fosfrose.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/837748497c4bbaef1dc957d555f97e7a4995e002/gcc%2Fconfig%2Fi386%2Fosfrose.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fosfrose.h?ref=837748497c4bbaef1dc957d555f97e7a4995e002", "patch": "@@ -877,34 +877,10 @@ while (0)\n    we want to retain compatibility with older gcc versions.  */\n #define DEFAULT_PCC_STRUCT_RETURN 0\n \n-/* Map i386 registers to the numbers dwarf expects.  Of course this is different\n-   from what stabs expects.  */\n-\n-#define DWARF_DBX_REGISTER_NUMBER(n) \\\n-((n) == 0 ? 0 \\\n- : (n) == 1 ? 2 \\\n- : (n) == 2 ? 1 \\\n- : (n) == 3 ? 3 \\\n- : (n) == 4 ? 6 \\\n- : (n) == 5 ? 7 \\\n- : (n) == 6 ? 5 \\\n- : (n) == 7 ? 4 \\\n- : ((n) >= FIRST_STACK_REG && (n) <= LAST_STACK_REG) ? (n)+3 \\\n- : (-1))\n-\n-/* Now what stabs expects in the register.  */\n-#define STABS_DBX_REGISTER_NUMBER(n) \\\n-((n) == 0 ? 0 : \\\n- (n) == 1 ? 2 : \\\n- (n) == 2 ? 1 : \\\n- (n) == 3 ? 3 : \\\n- (n) == 4 ? 6 : \\\n- (n) == 5 ? 7 : \\\n- (n) == 6 ? 4 : \\\n- (n) == 7 ? 5 : \\\n- (n) + 4)\n+/* Map i386 registers to the numbers dwarf expects.  Of course this is\n+   different from what stabs expects.  */\n \n #undef\tDBX_REGISTER_NUMBER\n-#define DBX_REGISTER_NUMBER(n) ((write_symbols == DWARF_DEBUG)\t\t\\\n-\t\t\t\t? DWARF_DBX_REGISTER_NUMBER(n)\t\t\\\n-\t\t\t\t: STABS_DBX_REGISTER_NUMBER(n))\n+#define DBX_REGISTER_NUMBER(n)  ((write_symbols == DWARF_DEBUG)\t\\\n+\t\t\t\t ? svr4_dbx_register_map[n]\t\\\n+\t\t\t\t : dbx_register_map[n])"}, {"sha": "0303014efabada4dab2f05cc316498d2960b923b", "filename": "gcc/config/i386/ptx4-i.h", "status": "modified", "additions": 1, "deletions": 75, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/837748497c4bbaef1dc957d555f97e7a4995e002/gcc%2Fconfig%2Fi386%2Fptx4-i.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/837748497c4bbaef1dc957d555f97e7a4995e002/gcc%2Fconfig%2Fi386%2Fptx4-i.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fptx4-i.h?ref=837748497c4bbaef1dc957d555f97e7a4995e002", "patch": "@@ -107,82 +107,8 @@ do { long value[3];\t\t\t\t\t\t\t\\\n \tfprintf (FILE, \"\\t.version\\t\\\"01.01\\\"\\n\");\t\t\t\\\n   } while (0)\n \n-/* Define the register numbers to be used in Dwarf debugging information.\n-   The SVR4 reference port C compiler uses the following register numbers\n-   in its Dwarf output code:\n-\n-\t0 for %eax (gnu regno = 0)\n-\t1 for %ecx (gnu regno = 2)\n-\t2 for %edx (gnu regno = 1)\n-\t3 for %ebx (gnu regno = 3)\n-\t4 for %esp (gnu regno = 7)\n-\t5 for %ebp (gnu regno = 6)\n-\t6 for %esi (gnu regno = 4)\n-\t7 for %edi (gnu regno = 5)\n-\n-   The following three DWARF register numbers are never generated by\n-   the SVR4 C compiler or by the GNU compilers, but SDB on x86/svr4\n-   believes these numbers have these meanings.\n-\n-\t8  for %eip    (no gnu equivalent)\n-\t9  for %eflags (no gnu equivalent)\n-\t10 for %trapno (no gnu equivalent)\n-\n-   It is not at all clear how we should number the FP stack registers\n-   for the x86 architecture.  If the version of SDB on x86/svr4 were\n-   a bit less brain dead with respect to floating-point then we would\n-   have a precedent to follow with respect to DWARF register numbers\n-   for x86 FP registers, but the SDB on x86/svr4 is so completely\n-   broken with respect to FP registers that it is hardly worth thinking\n-   of it as something to strive for compatibility with.\n-\n-   The version of x86/svr4 SDB I have at the moment does (partially)\n-   seem to believe that DWARF register number 11 is associated with\n-   the x86 register %st(0), but that's about all.  Higher DWARF\n-   register numbers don't seem to be associated with anything in\n-   particular, and even for DWARF regno 11, SDB only seems to under-\n-   stand that it should say that a variable lives in %st(0) (when\n-   asked via an `=' command) if we said it was in DWARF regno 11,\n-   but SDB still prints garbage when asked for the value of the\n-   variable in question (via a `/' command).\n-\n-   (Also note that the labels SDB prints for various FP stack regs\n-   when doing an `x' command are all wrong.)\n-\n-   Note that these problems generally don't affect the native SVR4\n-   C compiler because it doesn't allow the use of -O with -g and\n-   because when it is *not* optimizing, it allocates a memory\n-   location for each floating-point variable, and the memory\n-   location is what gets described in the DWARF AT_location\n-   attribute for the variable in question.\n-\n-   Regardless of the severe mental illness of the x86/svr4 SDB, we\n-   do something sensible here and we use the following DWARF\n-   register numbers.  Note that these are all stack-top-relative\n-   numbers.\n-\n-\t11 for %st(0) (gnu regno = 8)\n-\t12 for %st(1) (gnu regno = 9)\n-\t13 for %st(2) (gnu regno = 10)\n-\t14 for %st(3) (gnu regno = 11)\n-\t15 for %st(4) (gnu regno = 12)\n-\t16 for %st(5) (gnu regno = 13)\n-\t17 for %st(6) (gnu regno = 14)\n-\t18 for %st(7) (gnu regno = 15)\n-*/\n-\n #undef DBX_REGISTER_NUMBER\n-#define DBX_REGISTER_NUMBER(n) \\\n-((n) == 0 ? 0 \\\n- : (n) == 1 ? 2 \\\n- : (n) == 2 ? 1 \\\n- : (n) == 3 ? 3 \\\n- : (n) == 4 ? 6 \\\n- : (n) == 5 ? 7 \\\n- : (n) == 6 ? 5 \\\n- : (n) == 7 ? 4 \\\n- : ((n) >= FIRST_STACK_REG && (n) <= LAST_STACK_REG) ? (n)+3 \\\n- : (-1))\n+#define DBX_REGISTER_NUMBER(n)  svr4_dbx_register_map[n]\n \n /* The routine used to output sequences of byte values.  We use a special\n    version of this for most svr4 targets because doing so makes the"}, {"sha": "c1c125f7b7fcb75f82a16c790af71a8b1393d976", "filename": "gcc/config/i386/rtemself.h", "status": "modified", "additions": 1, "deletions": 66, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/837748497c4bbaef1dc957d555f97e7a4995e002/gcc%2Fconfig%2Fi386%2Frtemself.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/837748497c4bbaef1dc957d555f97e7a4995e002/gcc%2Fconfig%2Fi386%2Frtemself.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Frtemself.h?ref=837748497c4bbaef1dc957d555f97e7a4995e002", "patch": "@@ -48,73 +48,8 @@ Boston, MA 02111-1307, USA.  */\n    necessary when compiling PIC code.  */\n #define JUMP_TABLES_IN_TEXT_SECTION (flag_pic)\n \n-/* Copy this from the svr4 specifications... */\n-/* Define the register numbers to be used in Dwarf debugging information.\n-   The SVR4 reference port C compiler uses the following register numbers\n-   in its Dwarf output code:\n-\t0 for %eax (gnu regno = 0)\n-\t1 for %ecx (gnu regno = 2)\n-\t2 for %edx (gnu regno = 1)\n-\t3 for %ebx (gnu regno = 3)\n-\t4 for %esp (gnu regno = 7)\n-\t5 for %ebp (gnu regno = 6)\n-\t6 for %esi (gnu regno = 4)\n-\t7 for %edi (gnu regno = 5)\n-   The following three DWARF register numbers are never generated by\n-   the SVR4 C compiler or by the GNU compilers, but SDB on x86/svr4\n-   believes these numbers have these meanings.\n-\t8  for %eip    (no gnu equivalent)\n-\t9  for %eflags (no gnu equivalent)\n-\t10 for %trapno (no gnu equivalent)\n-   It is not at all clear how we should number the FP stack registers\n-   for the x86 architecture.  If the version of SDB on x86/svr4 were\n-   a bit less brain dead with respect to floating-point then we would\n-   have a precedent to follow with respect to DWARF register numbers\n-   for x86 FP registers, but the SDB on x86/svr4 is so completely\n-   broken with respect to FP registers that it is hardly worth thinking\n-   of it as something to strive for compatibility with.\n-   The version of x86/svr4 SDB I have at the moment does (partially)\n-   seem to believe that DWARF register number 11 is associated with\n-   the x86 register %st(0), but that's about all.  Higher DWARF\n-   register numbers don't seem to be associated with anything in\n-   particular, and even for DWARF regno 11, SDB only seems to under-\n-   stand that it should say that a variable lives in %st(0) (when\n-   asked via an `=' command) if we said it was in DWARF regno 11,\n-   but SDB still prints garbage when asked for the value of the\n-   variable in question (via a `/' command).\n-   (Also note that the labels SDB prints for various FP stack regs\n-   when doing an `x' command are all wrong.)\n-   Note that these problems generally don't affect the native SVR4\n-   C compiler because it doesn't allow the use of -O with -g and\n-   because when it is *not* optimizing, it allocates a memory\n-   location for each floating-point variable, and the memory\n-   location is what gets described in the DWARF AT_location\n-   attribute for the variable in question.\n-   Regardless of the severe mental illness of the x86/svr4 SDB, we\n-   do something sensible here and we use the following DWARF\n-   register numbers.  Note that these are all stack-top-relative\n-   numbers.\n-\t11 for %st(0) (gnu regno = 8)\n-\t12 for %st(1) (gnu regno = 9)\n-\t13 for %st(2) (gnu regno = 10)\n-\t14 for %st(3) (gnu regno = 11)\n-\t15 for %st(4) (gnu regno = 12)\n-\t16 for %st(5) (gnu regno = 13)\n-\t17 for %st(6) (gnu regno = 14)\n-\t18 for %st(7) (gnu regno = 15)\n-*/\n #undef DBX_REGISTER_NUMBER\n-#define DBX_REGISTER_NUMBER(n) \\\n-((n) == 0 ? 0 \\\n- : (n) == 1 ? 2 \\\n- : (n) == 2 ? 1 \\\n- : (n) == 3 ? 3 \\\n- : (n) == 4 ? 6 \\\n- : (n) == 5 ? 7 \\\n- : (n) == 6 ? 5 \\\n- : (n) == 7 ? 4 \\\n- : ((n) >= FIRST_STACK_REG && (n) <= LAST_STACK_REG) ? (n)+3 \\\n- : (-1))\n+#define DBX_REGISTER_NUMBER(n)  svr4_dbx_register_map[n]\n \n /* Output assembler code to FILE to increment profiler label # LABELNO\n    for profiling a function entry.  */"}, {"sha": "7fd7e008c84d09c21bc3c270a9e1a046827b17c7", "filename": "gcc/config/i386/sco5.h", "status": "modified", "additions": 2, "deletions": 22, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/837748497c4bbaef1dc957d555f97e7a4995e002/gcc%2Fconfig%2Fi386%2Fsco5.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/837748497c4bbaef1dc957d555f97e7a4995e002/gcc%2Fconfig%2Fi386%2Fsco5.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsco5.h?ref=837748497c4bbaef1dc957d555f97e7a4995e002", "patch": "@@ -541,28 +541,8 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define DBX_FUNCTION_FIRST 1\n \n #undef DBX_REGISTER_NUMBER\n-#define DBX_REGISTER_NUMBER(n)\t\t\t\t\t\t\\\n-((TARGET_ELF) ?\t\t\t\t\t\t\t\t\\\n- ((n) == 0 ? 0 \t\t\t\t\t\t\t\t\\\n-  : (n) == 1 ? 2 \t\t\t\t\t\t\t\\\n-  : (n) == 2 ? 1 \t\t\t\t\t\t\t\\\n-  : (n) == 3 ? 3 \t\t\t\t\t\t\t\\\n-  : (n) == 4 ? 6 \t\t\t\t\t\t\t\\\n-  : (n) == 5 ? 7 \t\t\t\t\t\t\t\\\n-  : (n) == 6 ? 5 \t\t\t\t\t\t\t\\\n-  : (n) == 7 ? 4 \t\t\t\t\t\t\t\\\n-  : ((n) >= FIRST_STACK_REG && (n) <= LAST_STACK_REG) ? (n)+3 \t\t\\\n-  : (-1))\t\t\t\t\t\t\t\t\\\n- :\t\t\t\t\t\t\t\t\t\\\n- ((n) == 0 ? 0 : \t\t\t\t\t\t\t\\\n-  (n) == 1 ? 2 : \t\t\t\t\t\t\t\\\n-  (n) == 2 ? 1 : \t\t\t\t\t\t\t\\\n-  (n) == 3 ? 3 : \t\t\t\t\t\t\t\\\n-  (n) == 4 ? 6 : \t\t\t\t\t\t\t\\\n-  (n) == 5 ? 7 : \t\t\t\t\t\t\t\\\n-  (n) == 6 ? 4 : \t\t\t\t\t\t\t\\\n-  (n) == 7 ? 5 : \t\t\t\t\t\t\t\\\n-  (n) + 4))\n+#define DBX_REGISTER_NUMBER(n) \\\n+  ((TARGET_ELF) ? svr4_dbx_register_map[n] : dbx_register_map[n])\n \n #undef DWARF_DEBUGGING_INFO\n #undef SDB_DEBUGGING_INFO"}, {"sha": "daf62c4a374640e9f8f8570e9e8e400f0ddd863f", "filename": "gcc/config/i386/sequent.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/837748497c4bbaef1dc957d555f97e7a4995e002/gcc%2Fconfig%2Fi386%2Fsequent.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/837748497c4bbaef1dc957d555f97e7a4995e002/gcc%2Fconfig%2Fi386%2Fsequent.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsequent.h?ref=837748497c4bbaef1dc957d555f97e7a4995e002", "patch": "@@ -64,10 +64,6 @@ Boston, MA 02111-1307, USA.  */\n  * dbx order is ax, dx, cx, st(0), st(1), bx, si, di, st(2), st(3),\n  * \t\tst(4), st(5), st(6), st(7), sp, bp  */\n \n-/* ??? The right thing would be to change the ordering of the\n-   registers to correspond to the conventions of this system,\n-   and get rid of DBX_REGISTER_NUMBER.  */\n-\n #undef DBX_REGISTER_NUMBER\n #define DBX_REGISTER_NUMBER(n)\t\t\\\n ((n) < 3 ? (n) : (n) < 6 ? (n) + 2\t\\"}, {"sha": "0c16d2e205a1876e24c45468b8ae2438b763dda8", "filename": "gcc/config/i386/sysv4.h", "status": "modified", "additions": 1, "deletions": 75, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/837748497c4bbaef1dc957d555f97e7a4995e002/gcc%2Fconfig%2Fi386%2Fsysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/837748497c4bbaef1dc957d555f97e7a4995e002/gcc%2Fconfig%2Fi386%2Fsysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsysv4.h?ref=837748497c4bbaef1dc957d555f97e7a4995e002", "patch": "@@ -105,82 +105,8 @@ do { long value[3];\t\t\t\t\t\t\t\\\n \tfprintf (FILE, \"\\t.version\\t\\\"01.01\\\"\\n\");\t\t\t\\\n   } while (0)\n \n-/* Define the register numbers to be used in Dwarf debugging information.\n-   The SVR4 reference port C compiler uses the following register numbers\n-   in its Dwarf output code:\n-\n-\t0 for %eax (gnu regno = 0)\n-\t1 for %ecx (gnu regno = 2)\n-\t2 for %edx (gnu regno = 1)\n-\t3 for %ebx (gnu regno = 3)\n-\t4 for %esp (gnu regno = 7)\n-\t5 for %ebp (gnu regno = 6)\n-\t6 for %esi (gnu regno = 4)\n-\t7 for %edi (gnu regno = 5)\n-\n-   The following three DWARF register numbers are never generated by\n-   the SVR4 C compiler or by the GNU compilers, but SDB on x86/svr4\n-   believes these numbers have these meanings.\n-\n-\t8  for %eip    (no gnu equivalent)\n-\t9  for %eflags (no gnu equivalent)\n-\t10 for %trapno (no gnu equivalent)\n-\n-   It is not at all clear how we should number the FP stack registers\n-   for the x86 architecture.  If the version of SDB on x86/svr4 were\n-   a bit less brain dead with respect to floating-point then we would\n-   have a precedent to follow with respect to DWARF register numbers\n-   for x86 FP registers, but the SDB on x86/svr4 is so completely\n-   broken with respect to FP registers that it is hardly worth thinking\n-   of it as something to strive for compatibility with.\n-\n-   The version of x86/svr4 SDB I have at the moment does (partially)\n-   seem to believe that DWARF register number 11 is associated with\n-   the x86 register %st(0), but that's about all.  Higher DWARF\n-   register numbers don't seem to be associated with anything in\n-   particular, and even for DWARF regno 11, SDB only seems to under-\n-   stand that it should say that a variable lives in %st(0) (when\n-   asked via an `=' command) if we said it was in DWARF regno 11,\n-   but SDB still prints garbage when asked for the value of the\n-   variable in question (via a `/' command).\n-\n-   (Also note that the labels SDB prints for various FP stack regs\n-   when doing an `x' command are all wrong.)\n-\n-   Note that these problems generally don't affect the native SVR4\n-   C compiler because it doesn't allow the use of -O with -g and\n-   because when it is *not* optimizing, it allocates a memory\n-   location for each floating-point variable, and the memory\n-   location is what gets described in the DWARF AT_location\n-   attribute for the variable in question.\n-\n-   Regardless of the severe mental illness of the x86/svr4 SDB, we\n-   do something sensible here and we use the following DWARF\n-   register numbers.  Note that these are all stack-top-relative\n-   numbers.\n-\n-\t11 for %st(0) (gnu regno = 8)\n-\t12 for %st(1) (gnu regno = 9)\n-\t13 for %st(2) (gnu regno = 10)\n-\t14 for %st(3) (gnu regno = 11)\n-\t15 for %st(4) (gnu regno = 12)\n-\t16 for %st(5) (gnu regno = 13)\n-\t17 for %st(6) (gnu regno = 14)\n-\t18 for %st(7) (gnu regno = 15)\n-*/\n-\n #undef DBX_REGISTER_NUMBER\n-#define DBX_REGISTER_NUMBER(n) \\\n-((n) == 0 ? 0 \\\n- : (n) == 1 ? 2 \\\n- : (n) == 2 ? 1 \\\n- : (n) == 3 ? 3 \\\n- : (n) == 4 ? 6 \\\n- : (n) == 5 ? 7 \\\n- : (n) == 6 ? 5 \\\n- : (n) == 7 ? 4 \\\n- : ((n) >= FIRST_STACK_REG && (n) <= LAST_STACK_REG) ? (n)+3 \\\n- : (-1))\n+#define DBX_REGISTER_NUMBER(n)  svr4_dbx_register_map[n]\n \n /* The routine used to output sequences of byte values.  We use a special\n    version of this for most svr4 targets because doing so makes the"}]}