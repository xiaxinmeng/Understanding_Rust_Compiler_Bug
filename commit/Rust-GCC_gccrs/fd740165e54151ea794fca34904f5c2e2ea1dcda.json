{"sha": "fd740165e54151ea794fca34904f5c2e2ea1dcda", "node_id": "C_kwDOANBUbNoAKGZkNzQwMTY1ZTU0MTUxZWE3OTRmY2EzNDkwNGY1YzJlMmVhMWRjZGE", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-11-19T13:54:25Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-11-19T13:54:25Z"}, "message": "c++: nested lambda capturing a capture proxy [PR94376]\n\nHere when determining the type of the FIELD_DECL for the by-value capture\nof 'i' in the inner lambda, we incorrectly give it the type const int\ninstead of int since the effective initializer is the proxy for the outer\ncapture, and this proxy is const since the outer lambda is non-mutable.\n\nThis patch fixes this by making lambda_capture_field_type handle\nby-value capturing of capture proxies specially, namely we instead\nconsider the type of their FIELD_DECL which unlike the proxy has the\ntrue cv-quals of the captured entity.\n\n\tPR c++/94376\n\ngcc/cp/ChangeLog:\n\n\t* lambda.c (lambda_capture_field_type): Simplify by handling the\n\tis_this case first.  When capturing by-value a capture proxy,\n\tconsider the type of the corresponding field instead.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp0x/lambda/lambda-nested9.C: New test.", "tree": {"sha": "c0481c3654f63b5d76040b0ac7fe6214a18d8923", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c0481c3654f63b5d76040b0ac7fe6214a18d8923"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fd740165e54151ea794fca34904f5c2e2ea1dcda", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd740165e54151ea794fca34904f5c2e2ea1dcda", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd740165e54151ea794fca34904f5c2e2ea1dcda", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd740165e54151ea794fca34904f5c2e2ea1dcda/comments", "author": null, "committer": null, "parents": [{"sha": "f316727e5f6a4c58b63bdee9ad6be785f97f5ee7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f316727e5f6a4c58b63bdee9ad6be785f97f5ee7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f316727e5f6a4c58b63bdee9ad6be785f97f5ee7"}], "stats": {"total": 60, "additions": 56, "deletions": 4}, "files": [{"sha": "c39a2bca416dba21aac0a55b34db189a59e79d3b", "filename": "gcc/cp/lambda.c", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd740165e54151ea794fca34904f5c2e2ea1dcda/gcc%2Fcp%2Flambda.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd740165e54151ea794fca34904f5c2e2ea1dcda/gcc%2Fcp%2Flambda.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flambda.c?ref=fd740165e54151ea794fca34904f5c2e2ea1dcda", "patch": "@@ -195,7 +195,9 @@ lambda_capture_field_type (tree expr, bool explicit_init_p,\n   tree type;\n   bool is_this = is_this_parameter (tree_strip_nop_conversions (expr));\n \n-  if (!is_this && explicit_init_p)\n+  if (is_this)\n+    type = TREE_TYPE (expr);\n+  else if (explicit_init_p)\n     {\n       tree auto_node = make_auto ();\n       \n@@ -209,7 +211,7 @@ lambda_capture_field_type (tree expr, bool explicit_init_p,\n       else\n \ttype = do_auto_deduction (type, expr, auto_node);\n     }\n-  else if (!is_this && type_dependent_expression_p (expr))\n+  else if (type_dependent_expression_p (expr))\n     {\n       type = cxx_make_type (DECLTYPE_TYPE);\n       DECLTYPE_TYPE_EXPR (type) = expr;\n@@ -219,10 +221,19 @@ lambda_capture_field_type (tree expr, bool explicit_init_p,\n     }\n   else\n     {\n+      if (!by_reference_p && is_capture_proxy (expr))\n+\t{\n+\t  /* When capturing by-value another capture proxy from an enclosing\n+\t     lambda, consider the type of the corresponding field instead,\n+\t     as the proxy may be additionally const-qualifed if the enclosing\n+\t     lambda is non-mutable (PR94376).  */\n+\t  gcc_assert (TREE_CODE (DECL_VALUE_EXPR (expr)) == COMPONENT_REF);\n+\t  expr = TREE_OPERAND (DECL_VALUE_EXPR (expr), 1);\n+\t}\n+\n       type = non_reference (unlowered_expr_type (expr));\n \n-      if (!is_this\n-\t  && (by_reference_p || TREE_CODE (type) == FUNCTION_TYPE))\n+      if (by_reference_p || TREE_CODE (type) == FUNCTION_TYPE)\n \ttype = build_reference_type (type);\n     }\n "}, {"sha": "ff7da3b0ce146c167372e3c6000542feb552c14d", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-nested9.C", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd740165e54151ea794fca34904f5c2e2ea1dcda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-nested9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd740165e54151ea794fca34904f5c2e2ea1dcda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-nested9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-nested9.C?ref=fd740165e54151ea794fca34904f5c2e2ea1dcda", "patch": "@@ -0,0 +1,41 @@\n+// PR c++/94376\n+// { dg-do compile { target c++11 } }\n+\n+int main() {\n+  // We used to incorrectly reject the first two cases.\n+  int i = 0;\n+  [=] () {\n+    [=] () mutable {\n+      ++i;\n+    };\n+  };\n+\n+#if __cpp_init_captures\n+  [j=0] () {\n+    [=] () mutable {\n+      ++j;\n+    };\n+  };\n+#endif\n+\n+  [=] () {\n+    [&] () mutable {\n+      ++i; // { dg-error \"read-only\" }\n+    };\n+  };\n+\n+  const int j = 0;\n+  [=] () {\n+    [=] () mutable {\n+      ++j; // { dg-error \"read-only\" }\n+    };\n+  };\n+\n+#if __cpp_init_captures\n+  [j=0] () {\n+    [&] () mutable {\n+      ++j; // { dg-error \"read-only\" }\n+    };\n+  };\n+#endif\n+}"}]}