{"sha": "dcd2ca63ec5c467decb70db983fc19a8329f67dc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGNkMmNhNjNlYzVjNDY3ZGVjYjcwZGI5ODNmYzE5YTgzMjlmNjdkYw==", "commit": {"author": {"name": "Ilya Leoshkevich", "email": "iii@linux.ibm.com", "date": "2019-10-07T15:01:15Z"}, "committer": {"name": "Ilya Leoshkevich", "email": "iii@gcc.gnu.org", "date": "2019-10-07T15:01:15Z"}, "message": "Introduce can_vcond_compare_p function\n\nz13 supports only non-signaling vector comparisons.  This means we\ncannot vectorize LT, LE, GT, GE and LTGT when compiling for z13.\nHowever, we cannot express this restriction today: the code only checks\nwhether vcond$a$b optab exists, but this does not say anything about the\noperation.\n\nIntroduce a function that checks whether back-end supports vector\ncomparisons with individual rtx codes by matching vcond expander's third\nargument with a fake comparison with the corresponding rtx code.\n\ngcc/ChangeLog:\n\n2019-10-07  Ilya Leoshkevich  <iii@linux.ibm.com>\n\n\tPR target/77918\n\t* optabs-tree.c (vcond_icode_p): New function.\n\t(vcond_eq_icode_p): Likewise.\n\t(expand_vec_cond_expr_p): Use vcond_icode_p and\n\tvcond_eq_icode_p.\n\t* optabs.c (can_vcond_compare_p): New function.\n\t* optabs.h (can_vcond_compare_p): Likewise.\n\nFrom-SVN: r276660", "tree": {"sha": "57e8c3ef3613a9b118825f76b0390c14d6429549", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/57e8c3ef3613a9b118825f76b0390c14d6429549"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dcd2ca63ec5c467decb70db983fc19a8329f67dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dcd2ca63ec5c467decb70db983fc19a8329f67dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dcd2ca63ec5c467decb70db983fc19a8329f67dc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dcd2ca63ec5c467decb70db983fc19a8329f67dc/comments", "author": {"login": "iii-i", "id": 45998171, "node_id": "MDQ6VXNlcjQ1OTk4MTcx", "avatar_url": "https://avatars.githubusercontent.com/u/45998171?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iii-i", "html_url": "https://github.com/iii-i", "followers_url": "https://api.github.com/users/iii-i/followers", "following_url": "https://api.github.com/users/iii-i/following{/other_user}", "gists_url": "https://api.github.com/users/iii-i/gists{/gist_id}", "starred_url": "https://api.github.com/users/iii-i/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iii-i/subscriptions", "organizations_url": "https://api.github.com/users/iii-i/orgs", "repos_url": "https://api.github.com/users/iii-i/repos", "events_url": "https://api.github.com/users/iii-i/events{/privacy}", "received_events_url": "https://api.github.com/users/iii-i/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "70e2a30ac8f474feefbcc392cbc59cf91271b92b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70e2a30ac8f474feefbcc392cbc59cf91271b92b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70e2a30ac8f474feefbcc392cbc59cf91271b92b"}], "stats": {"total": 74, "additions": 68, "deletions": 6}, "files": [{"sha": "c9ca3bae0e488a288e9f5d39086e5e1381d5b467", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dcd2ca63ec5c467decb70db983fc19a8329f67dc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dcd2ca63ec5c467decb70db983fc19a8329f67dc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dcd2ca63ec5c467decb70db983fc19a8329f67dc", "patch": "@@ -1,3 +1,13 @@\n+2019-10-07  Ilya Leoshkevich  <iii@linux.ibm.com>\n+\n+\tPR target/77918\n+\t* optabs-tree.c (vcond_icode_p): New function.\n+\t(vcond_eq_icode_p): Likewise.\n+\t(expand_vec_cond_expr_p): Use vcond_icode_p and\n+\tvcond_eq_icode_p.\n+\t* optabs.c (can_vcond_compare_p): New function.\n+\t* optabs.h (can_vcond_compare_p): Likewise.\n+\n 2019-10-07  Ilya Leoshkevich  <iii@linux.ibm.com>\n \n \tPR target/77918"}, {"sha": "a5ecbf075b5d0cce6f1dfbcc51399fae87f5e1be", "filename": "gcc/optabs-tree.c", "status": "modified", "additions": 33, "deletions": 6, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dcd2ca63ec5c467decb70db983fc19a8329f67dc/gcc%2Foptabs-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dcd2ca63ec5c467decb70db983fc19a8329f67dc/gcc%2Foptabs-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-tree.c?ref=dcd2ca63ec5c467decb70db983fc19a8329f67dc", "patch": "@@ -23,7 +23,10 @@ along with GCC; see the file COPYING3.  If not see\n #include \"coretypes.h\"\n #include \"target.h\"\n #include \"insn-codes.h\"\n+#include \"rtl.h\"\n #include \"tree.h\"\n+#include \"memmodel.h\"\n+#include \"optabs.h\"\n #include \"optabs-tree.h\"\n #include \"stor-layout.h\"\n \n@@ -329,6 +332,31 @@ expand_vec_cmp_expr_p (tree value_type, tree mask_type, enum tree_code code)\n   return false;\n }\n \n+/* Return true iff vcond_optab/vcondu_optab can handle a vector\n+   comparison for code CODE, comparing operands of type CMP_OP_TYPE and\n+   producing a result of type VALUE_TYPE.  */\n+\n+static bool\n+vcond_icode_p (tree value_type, tree cmp_op_type, enum tree_code code)\n+{\n+  return can_vcond_compare_p (get_rtx_code (code, TYPE_UNSIGNED (cmp_op_type)),\n+\t\t\t      TYPE_MODE (value_type), TYPE_MODE (cmp_op_type));\n+}\n+\n+/* Return true iff vcondeq_optab can handle a vector comparison for code CODE,\n+   comparing operands of type CMP_OP_TYPE and producing a result of type\n+   VALUE_TYPE.  */\n+\n+static bool\n+vcond_eq_icode_p (tree value_type, tree cmp_op_type, enum tree_code code)\n+{\n+  if (code != EQ_EXPR && code != NE_EXPR)\n+    return false;\n+\n+  return get_vcond_eq_icode (TYPE_MODE (value_type), TYPE_MODE (cmp_op_type))\n+\t != CODE_FOR_nothing;\n+}\n+\n /* Return TRUE iff, appropriate vector insns are available\n    for vector cond expr with vector type VALUE_TYPE and a comparison\n    with operand vector types in CMP_OP_TYPE.  */\n@@ -347,14 +375,13 @@ expand_vec_cond_expr_p (tree value_type, tree cmp_op_type, enum tree_code code)\n       || maybe_ne (GET_MODE_NUNITS (value_mode), GET_MODE_NUNITS (cmp_op_mode)))\n     return false;\n \n-  if (get_vcond_icode (TYPE_MODE (value_type), TYPE_MODE (cmp_op_type),\n-\t\t       TYPE_UNSIGNED (cmp_op_type)) == CODE_FOR_nothing\n-      && ((code != EQ_EXPR && code != NE_EXPR)\n-\t  || get_vcond_eq_icode (TYPE_MODE (value_type),\n-\t\t\t\t TYPE_MODE (cmp_op_type)) == CODE_FOR_nothing))\n+  if (TREE_CODE_CLASS (code) != tcc_comparison)\n+    /* This may happen, for example, if code == SSA_NAME, in which case we\n+       cannot be certain whether a vector insn is available.  */\n     return false;\n \n-  return true;\n+  return vcond_icode_p (value_type, cmp_op_type, code)\n+\t || vcond_eq_icode_p (value_type, cmp_op_type, code);\n }\n \n /* Use the current target and options to initialize"}, {"sha": "d6701df158c593e3be86d15b076c646a8f8ff58d", "filename": "gcc/optabs.c", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dcd2ca63ec5c467decb70db983fc19a8329f67dc/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dcd2ca63ec5c467decb70db983fc19a8329f67dc/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=dcd2ca63ec5c467decb70db983fc19a8329f67dc", "patch": "@@ -3819,6 +3819,25 @@ can_compare_p (enum rtx_code code, machine_mode mode,\n   return 0;\n }\n \n+/* Return whether the backend can emit a vector comparison for code CODE,\n+   comparing operands of mode CMP_OP_MODE and producing a result with\n+   VALUE_MODE.  */\n+\n+bool\n+can_vcond_compare_p (enum rtx_code code, machine_mode value_mode,\n+\t\t     machine_mode cmp_op_mode)\n+{\n+  enum insn_code icode;\n+  bool unsigned_p = (code == LTU || code == LEU || code == GTU || code == GEU);\n+  rtx reg1 = alloca_raw_REG (cmp_op_mode, LAST_VIRTUAL_REGISTER + 1);\n+  rtx reg2 = alloca_raw_REG (cmp_op_mode, LAST_VIRTUAL_REGISTER + 2);\n+  rtx test = alloca_rtx_fmt_ee (code, value_mode, reg1, reg2);\n+\n+  return (icode = get_vcond_icode (value_mode, cmp_op_mode, unsigned_p))\n+\t != CODE_FOR_nothing\n+\t && insn_operand_matches (icode, 3, test);\n+}\n+\n /* This function is called when we are going to emit a compare instruction that\n    compares the values found in X and Y, using the rtl operator COMPARISON.\n "}, {"sha": "b1348ce85c916e6b9fcdbaf5c51a1644a4e28dc3", "filename": "gcc/optabs.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dcd2ca63ec5c467decb70db983fc19a8329f67dc/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dcd2ca63ec5c467decb70db983fc19a8329f67dc/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=dcd2ca63ec5c467decb70db983fc19a8329f67dc", "patch": "@@ -242,6 +242,12 @@ enum can_compare_purpose\n    (without splitting it into pieces).  */\n extern int can_compare_p (enum rtx_code, machine_mode,\n \t\t\t  enum can_compare_purpose);\n+\n+/* Return whether the backend can emit a vector comparison for code CODE,\n+   comparing operands of mode CMP_OP_MODE and producing a result with\n+   VALUE_MODE.  */\n+extern bool can_vcond_compare_p (enum rtx_code, machine_mode, machine_mode);\n+\n extern rtx prepare_operand (enum insn_code, rtx, int, machine_mode,\n \t\t\t    machine_mode, int);\n /* Emit a pair of rtl insns to compare two rtx's and to jump"}]}