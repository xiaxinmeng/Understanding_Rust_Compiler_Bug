{"sha": "009368dba64b7288dc9d9a92618de62d2e36dc3a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDA5MzY4ZGJhNjRiNzI4OGRjOWQ5YTkyNjE4ZGU2MmQyZTM2ZGMzYQ==", "commit": {"author": {"name": "Dhruv Matani", "email": "dhruvbird@HotPOP.com", "date": "2004-03-12T03:28:12Z"}, "committer": {"name": "Loren J. Rittle", "email": "ljrittle@gcc.gnu.org", "date": "2004-03-12T03:28:12Z"}, "message": "ballocator_doc.txt: New file.\n\n2004-03-11  Dhruv Matani  <dhruvbird@HotPOP.com>\n\n\t* docs/html/ext/ballocator_doc.txt: New file.\n\t* include/Makefile.am (ext_headers): Add\n\t${ext_srcdir}/bitmap_allocator.h .\n\t* include/Makefile.in: Regenerate (by hand, since I didn't have\n\tautomake de jure on hand).\n\t* include/ext/bitmap_allocator.h: New file.\n\t* testsuite/performance/20_util/allocator/list_sort_search.cc: New test.\n\t* testsuite/performance/20_util/allocator/map_mt_find.cc: Likewise.\n\t* testsuite/performance/20_util/allocator/producer_consumer.cc: Add\n\ttest for the bitmap_allocator<>.\n\t* testsuite/performance/20_util/allocator/insert.cc: Likewise.\n\t* testsuite/performance/20_util/allocator/insert_insert.cc: Likewise.\n\t* testsuite/performance/20_util/allocator/map_thread.cc: Likewise.\n\nFrom-SVN: r79366", "tree": {"sha": "ca58c4306f28de2d044b770e99596d8b8e76cb18", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ca58c4306f28de2d044b770e99596d8b8e76cb18"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/009368dba64b7288dc9d9a92618de62d2e36dc3a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/009368dba64b7288dc9d9a92618de62d2e36dc3a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/009368dba64b7288dc9d9a92618de62d2e36dc3a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/009368dba64b7288dc9d9a92618de62d2e36dc3a/comments", "author": null, "committer": null, "parents": [{"sha": "a8dad789a5d98744bdff783b7cc66085eb51ca87", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8dad789a5d98744bdff783b7cc66085eb51ca87", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8dad789a5d98744bdff783b7cc66085eb51ca87"}], "stats": {"total": 1626, "additions": 1593, "deletions": 33}, "files": [{"sha": "818842c97d3474677208c1ae155c0ec3f05405cf", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/009368dba64b7288dc9d9a92618de62d2e36dc3a/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/009368dba64b7288dc9d9a92618de62d2e36dc3a/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=009368dba64b7288dc9d9a92618de62d2e36dc3a", "patch": "@@ -1,3 +1,18 @@\n+2004-03-11  Dhruv Matani  <dhruvbird@HotPOP.com>\n+\n+\t* include/Makefile.am (ext_headers): Add\n+\t${ext_srcdir}/bitmap_allocator.h .\n+\t* include/Makefile.in: Regenerate.\n+\t* docs/html/ext/ballocator_doc.txt: New file.\n+\t* include/ext/bitmap_allocator.h: New file.\n+\t* testsuite/performance/20_util/allocator/list_sort_search.cc: New test.\n+\t* testsuite/performance/20_util/allocator/map_mt_find.cc: Likewise.\n+\t* testsuite/performance/20_util/allocator/producer_consumer.cc: Add\n+\ttest for the bitmap_allocator<>.\n+\t* testsuite/performance/20_util/allocator/insert.cc: Likewise.\n+\t* testsuite/performance/20_util/allocator/insert_insert.cc: Likewise.\n+\t* testsuite/performance/20_util/allocator/map_thread.cc: Likewise.\n+\n 2004-03-11  Paolo Carlini  <pcarlini@suse.de>\n \n \t* include/std/std_complex.h (pow(const complex&, const _Tp&),"}, {"sha": "2173b618f4f8836f35ed833c308a8b0a95a89879", "filename": "libstdc++-v3/docs/html/ext/ballocator_doc.txt", "status": "added", "additions": 374, "deletions": 0, "changes": 374, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/009368dba64b7288dc9d9a92618de62d2e36dc3a/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fext%2Fballocator_doc.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/009368dba64b7288dc9d9a92618de62d2e36dc3a/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fext%2Fballocator_doc.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fext%2Fballocator_doc.txt?ref=009368dba64b7288dc9d9a92618de62d2e36dc3a", "patch": "@@ -0,0 +1,374 @@\n+\t\t\tBITMAPPED ALLOCATOR\n+\t\t\t===================\n+\n+2004-03-11  Dhruv Matani  <dhruvbird@HotPOP.com>\n+\n+---------------------------------------------------------------------\n+\n+As this name suggests, this allocator uses a bit-map to keep track of\n+the used and unused memory locations for it's book-keeping purposes.\n+\n+This allocator will make use of 1 single bit to keep track of whether\n+it has been allocated or not. A bit 1 indicates free, while 0\n+indicates allocated. This has been done so that you can easily check a\n+collection of bits for a free block. This kind of Bitmapped strategy\n+works best for single object allocations, and with the STL type\n+parameterized allocators, we do not need to choose any size for the\n+block which will be represented by a single bit. This will be the size\n+of the parameter around which the allocator has been\n+parameterized. Thus, close to optimal performance will result. Hence,\n+this should be used for node based containers which call the allocate\n+function with an argument of 1.\n+\n+The bitmapped allocator's internal pool is exponentially\n+growing. Meaning that internally, the blocks acquired from the Free\n+List Store will double every time the bitmapped allocator runs out of\n+memory.\n+\n+--------------------------------------------------------------------\n+\n+The macro __GTHREADS decides whether to use Mutex Protection around\n+every allocation/deallocation.  The state of the macro is picked up\n+automatically from the gthr abstration layer.\n+\n+----------------------------------------------------------------------\n+\n+What is the Free List Store?\n+----------------------------\n+\n+The Free List Store (referred to as FLS for the remaining part of this\n+document) is the Global memory pool that is shared by all instances of\n+the bitmapped allocator instantiated for any type. This maintains a\n+sorted order of all free memory blocks given back to it by the\n+bitmapped allocator, and is also responsible for giving memory to the\n+bitmapped allocator when it asks for more.\n+\n+Internally, there is a Free List threshold which indicates the Maximum\n+number of free lists that the FLS can hold internally\n+(cache). Currently, this value is set at 64. So, if there are more\n+than 64 free lists coming in, then some of them will be given back to\n+the OS using operator delete so that at any given time the Free List's\n+size does not exceed 64 entries. This is done because a Binary Search\n+is used to locate an entry in a free list when a request for memory\n+comes along. Thus, the run-time complexity of the search would go up\n+given an increasing size, for 64 entries however, lg(64) == 6\n+comparisons are enough to locate the correct free list if it exists.\n+\n+Suppose the free list size has reached it's threshold, then the\n+largest block from among those in the list and the new block will be\n+selected and given back to the OS. This is done because it reduces\n+external fragmentation, and allows the OS to use the larger blocks\n+later in an orderly fashion, possibly merging them later. Also, on\n+some systems, large blocks are obtained via calls to mmap, so giving\n+them back to free system resources becomes most important.\n+\n+The function _S_should_i_give decides the policy that determines\n+whether the current block of memory should be given to the allocator\n+for the request that it has made. That's because we may not always\n+have exact fits for the memory size that the allocator requests. We do\n+this mainly to prevent external fragmentation at the cost of a little\n+internal fragmentation. Now, the value of this internal fragmentation\n+has to be decided by this function. I can see 3 possibilities right\n+now. Please add more as and when you find better strategies.\n+\n+1. Equal size check. Return true only when the 2 blocks are of equal\n+   size.\n+\n+2. Difference Threshold: Return true only when the _block_size is\n+   greater than or equal to the _required_size, and if the _BS is >\n+   _RS by a difference of less than some THRESHOLD value, then return\n+   true, else return false.  \n+\n+3. Percentage Threshold. Return true only when the _block_size is\n+   greater than or equal to the _required_size, and if the _BS is >\n+   _RS by a percentage of less than some THRESHOLD value, then return\n+   true, else return false.\n+\n+Currently, (3) is being used with a value of 36% Maximum wastage per\n+Super Block.\n+\n+--------------------------------------------------------------------\n+\n+1) What is a super block? Why is it needed?\n+\n+   A super block is the block of memory acquired from the FLS from\n+   which the bitmap allocator carves out memory for single objects and\n+   satisfies the user's requests. These super blocks come in sizes that\n+   are powers of 2 and multiples of 32 (_Bits_Per_Block). Yes both at\n+   the same time! That's because the next super block acquired will be\n+   2 times the previous one, and also all super blocks have to be\n+   multiples of the _Bits_Per_Block value.\n+\n+2) How does it interact with the free list store?\n+\n+   The super block is contained in the FLS, and the FLS is responsible\n+   for getting / returning Super Bocks to and from the OS using\n+   operator new as defined by the C++ standard.\n+\n+---------------------------------------------------------------------\n+\n+How does the allocate function Work?\n+------------------------------------\n+\n+The allocate function is specialized for single object allocation\n+ONLY. Thus, ONLY if n == 1, will the bitmap_allocator's specialized\n+algorithm be used. Otherwise, the request is satisfied directly by\n+calling operator new.\n+\n+Suppose n == 1, then the allocator does the following:\n+\n+1. Checks to see whether the a free block exists somewhere in a region\n+   of memory close to the last satisfied request. If so, then that\n+   block is marked as allocated in the bit map and given to the\n+   user. If not, then (2) is executed.\n+\n+2. Is there a free block anywhere after the current block right upto\n+   the end of the memory that we have? If so, that block is found, and\n+   the same procedure is applied as above, and returned to the\n+   user. If not, then (3) is executed.\n+\n+3. Is there any block in whatever region of memory that we own free?\n+   This is done by checking (a) The use count for each super block,\n+   and if that fails then (b) The individual bit-maps for each super\n+   block. Note: Here we are never touching any of the memory that the\n+   user will be given, and we are confining all memory accesses to a\n+   small region of memory! This helps reduce cache misses. If this\n+   succeeds then we apply the same procedure on that bit-map as (1),\n+   and return that block of memory to the user. However, if this\n+   process fails, then we resort to (4).\n+\n+4. This process involves Refilling the internal exponentially growing\n+   memory pool. The said effect is achieved by calling _S_refill_pool\n+   which does the following:\n+\t (a). Gets more memory from the Global Free List of the\n+\t      Required size.\n+\t (b). Adjusts the size for the next call to itself.\n+\t (c). Writes the appropriate headers in the bit-maps.\n+\t (d). Sets the use count for that super-block just allocated\n+\t      to 0 (zero).\n+\t (e). All of the above accounts to maintaining the basic\n+\t      invariant for the allocator. If the invariant is\n+\t      maintained, we are sure that all is well.\n+   Now, the same process is applied on the newly acquired free blocks,\n+   which are dispatched accordingly.\n+\n+Thus, you can clearly see that the allocate function is nothing but a\n+combination of the next-fit and first-fit algorithm optimized ONLY for\n+single object allocations.\n+\n+\n+-------------------------------------------------------------------------\n+\n+How does the deallocate function work?\n+--------------------------------------\n+\n+The deallocate function again is specialized for single objects ONLY.\n+For all n belonging to > 1, the operator delete is called without\n+further ado, and the deallocate function returns.\n+\n+However for n == 1, a series of steps are performed:\n+\n+1. We first need to locate that super-block which holds the memory\n+   location given to us by the user. For that purpose, we maintain a\n+   static variable _S_last_dealloc_index, which holds the index into\n+   the vector of block pairs which indicates the index of the last\n+   super-block from which memory was freed. We use this strategy in\n+   the hope that the user will deallocate memory in a region close to\n+   what he/she deallocated the last time around. If the check for\n+   belongs_to succeeds, then we determine the bit-map for the given\n+   pointer, and locate the index into that bit-map, and mark that bit\n+   as free by setting it.\n+\n+2. If the _S_last_dealloc_index does not point to the memory block\n+   that we're looking for, then we do a linear search on the block\n+   stored in the vector of Block Pairs. This vector in code is called\n+   _S_mem_blocks. When the corresponding super-block is found, we\n+   apply the same procedure as we did for (1) to mark the block as\n+   free in the bit-map.\n+\n+Now, whenever a block is freed, the use count of that particular super\n+block goes down by 1. When this use count hits 0, we remove that super\n+block from the list of all valid super blocks stored in the\n+vector. While doing this, we also make sure that the basic invariant\n+is maintained by making sure that _S_last_request and\n+_S_last_dealloc_index point to valid locations within the vector.\n+\n+--------------------------------------------------------------------\n+\n+\n+Data Layout for a Super Block:\n+==============================\n+\n+Each Super Block will be of some size that is a multiple of the number\n+of Bits Per Block. Typically, this value is chosen as Bits_Per_Byte X\n+sizeof(unsigned int). On an X86 system, this gives the figure \n+8 X 4 = 32. Thus, each Super Block will be of size 32 X Some_Value.\n+This Some_Value is sizeof(value_type). For now, let it be called 'K'.\n+Thus, finally, Super Block size is 32 X K bytes.\n+\n+This value of 32 has been chosen because each unsigned int has 32-bits\n+and Maximum use of these can be made with such a figure.\n+\n+Consider a block of size 32 ints.\n+In memory, it would look like this:\n+\n+---------------------------------------------------------------------\n+|   136   |    0    | 4294967295 |      Data-> Space for 32-ints    |\n+---------------------------------------------------------------------\n+\n+The first Columns represents the size of the Block in bytes as seen by\n+the Bitmap Allocator. Internally, a global free list is used to keep\n+track of the free blocks used and given back by the bitmap\n+allocator. It is this Free List Store that is responsible for writing\n+and managing this information. Actually the number of bytes allocated\n+in this case would be: 4 + 4 + 4 + 32*4 = 140 bytes, but the first 4\n+bytes are an addition by the Free List Store, so the Bitmap Allocator\n+sees only 136 bytes. These first 4 bytes about which the bitmapped\n+allocator is not aware hold the value 136.\n+\n+What do the remaining values represent?\n+---------------------------------------\n+\n+The 2nd 4 in the expression is the sizeof(unsigned int) because the\n+Bitmapped Allocator maintains a used count for each Super Block, which\n+is initially set to 0 (as indicated in the diagram). This is\n+incremented every time a block is removed from this super block\n+(allocated), and decremented whenever it is given back. So, when the\n+used count falls to 0, the whole super block will be given back to the\n+Free List Store.\n+\n+The value 4294967295 represents the integer corresponding to the\n+bit representation of all bits set: 11111111111111111111111111111111.\n+\n+The 3rd 4 is size of the bitmap itself, which is the size of 32-bits,\n+which is 4-bytes, or 1 X sizeof(unsigned int).\n+\n+\n+--------------------------------------------------------------------\n+\n+Another issue would be whether to keep the all bitmaps in a separate\n+area in memory, or to keep them near the actual blocks that will be\n+given out or allocated for the client. After some testing, I've\n+decided to keep these bitmaps close to the actual blocks. this will\n+help in 2 ways. \n+\n+1. Constant time access for the bitmap themselves, since no kind of\n+   look up will be needed to find the correct bitmap list or it's\n+   equivalent.\n+\n+2. And also this would preserve the cache as far as possible.\n+\n+So in effect, this kind of an allocator might prove beneficial from a\n+purely cache point of view. But this allocator has been made to try\n+and roll out the defects of the node_allocator, wherein the nodes get\n+skewed about in memory, if they are not returned in the exact reverse\n+order or in the same order in which they were allocated. Also, the\n+new_allocator's book keeping overhead is too much for small objects\n+and single object allocations, though it preserves the locality of\n+blocks very well when they are returned back to the allocator.\n+\n+-------------------------------------------------------------------\n+\n+Expected overhead per block would be 1 bit in memory. Also, once\n+the address of the free list has been found, the cost for\n+allocation/deallocation would be negligible, and is supposed to be\n+constant time. For these very reasons, it is very important to\n+minimize the linear time costs, which include finding a free list\n+with a free block while allocating, and finding the corresponding\n+free list for a block while deallocating. Therefore, I have decided\n+that the growth of the internal pool for this allocator will be\n+exponential as compared to linear for node_allocator. There, linear\n+time works well, because we are mainly concerned with speed of\n+allocation/deallocation and memory consumption, whereas here, the\n+allocation/deallocation part does have some linear/logarithmic\n+complexity components in it. Thus, to try and minimize them would\n+be a good thing to do at the cost of a little bit of memory.\n+\n+Another thing to be noted is the the pool size will double every time\n+the internal pool gets exhausted, and all the free blocks have been\n+given away. The initial size of the pool would be sizeof(unsigned\n+int)*8 which is the number of bits in an integer, which can fit\n+exactly in a CPU register. Hence, the term given is exponential growth\n+of the internal pool.\n+\n+---------------------------------------------------------------------\n+\n+After reading all this, you may still have a few questions about the\n+internal working of this allocator, like my friend had!\n+\n+Well here are the exact questions that he posed:\n+\n+1) The \"Data Layout\" section is cryptic. I have no idea of what you\n+   are trying to say. Layout of what? The free-list? Each bitmap? The\n+   Super Block?\n+\n+   The layout of a Super Block of a given size. In the example, a super\n+   block of size 32 X 1 is taken. The general formula for calculating\n+   the size of a super block is 32*sizeof(value_type)*2^n, where n\n+   ranges from 0 to 32 for 32-bit systems.\n+\n+2) And since I just mentioned the term `each bitmap', what in the\n+   world is meant by it? What does each bitmap manage? How does it\n+   relate to the super block? Is the Super Block a bitmap as well?\n+\n+   Good question! Each bitmap is part of a Super Block which is made up\n+   of 3 parts as I have mentioned earlier. Re-iterating, 1. The use\n+   count, 2. The bit-map for that Super Block. 3. The actual memory\n+   that will be eventually given to the user. Each bitmap is a multiple\n+   of 32 in size. If there are 32*(2^3) blocks of single objects to be\n+   given, there will be '32*(2^3)' bits present. Each 32 bits managing\n+   the allocated / free status for 32 blocks. Since each unsigned int\n+   contains 32-bits, one unsigned int can manage upto 32 blocks'\n+   status. Each bit-map is made up of a number of unsigned ints, whose\n+   exact number for a super-block of a given size I have just\n+   mentioned.\n+\n+3) How do the allocate and deallocate functions work in regard to\n+   bitmaps?\n+\n+   The allocate and deallocate functions manipulate the bitmaps and have\n+   nothing to do with the memory that is given to the user. As I have\n+   earlier mentioned, a 1 in the bitmap's bit field indicates free,\n+   while a 0 indicates allocated. This lets us check 32 bits at a time\n+   to check whether there is at lease one free block in those 32 blocks\n+   by testing for equality with (0). Now, the allocate function will\n+   given a memory block find the corresponding bit in the bitmap, and\n+   will reset it (ie. make it re-set (0)). And when the deallocate\n+   function is called, it will again set that bit after locating it to\n+   indicate that that particular block corresponding to this bit in the\n+   bit-map is not being used by anyone, and may be used to satisfy\n+   future requests.\n+\n+----------------------------------------------------------------------\n+\n+(Tech-Stuff, Please stay out if you are not interested in the\n+selection of certain constants. This has nothing to do with the\n+algorithm per-se, only with some vales that must be chosen correctly\n+to ensure that the allocator performs well in a real word scenario,\n+and maintains a good balance between the memory consumption and the\n+allocation/deallocation speed).\n+\n+The formula for calculating the maximum wastage as a percentage:\n+\n+(32 X k + 1) / (2 X (32 X k + 1 + 32 X c)) X 100.\n+\n+Where,\n+\tk => The constant overhead per node. eg. for list, it is 8\n+\tbytes, and for map it is 12 bytes.\n+\tc => The size of the base type on which the map/list is\n+\tinstantiated. Thus, suppose the the type1 is int and type2 is\n+\tdouble, they are related by the relation sizeof(double) ==\n+\t2*sizeof(int). Thus, all types must have this double size\n+\trelation for this formula to work properly.\n+\n+Plugging-in: For List: k = 8 and c = 4 (int and double), we get:\n+33.376%\n+\n+For map/multimap: k = 12, and c = 4 (int and double), we get:\n+37.524%\n+\n+Thus, knowing these values, and based on the sizeof(value_type), we\n+may create a function that returns the Max_Wastage_Percentage for us\n+to use.\n+\n+"}, {"sha": "df51997ef25f2da83144d76d85ba0a34771720b3", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/009368dba64b7288dc9d9a92618de62d2e36dc3a/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/009368dba64b7288dc9d9a92618de62d2e36dc3a/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=009368dba64b7288dc9d9a92618de62d2e36dc3a", "patch": "@@ -202,6 +202,7 @@ ext_srcdir = ${glibcxx_srcdir}/include/ext\n ext_builddir = ./ext\n ext_headers = \\\n \t${ext_srcdir}/algorithm \\\n+\t${ext_srcdir}/bitmap_allocator.h \\\n \t${ext_srcdir}/debug_allocator.h \\\n \t${ext_srcdir}/demangle.h \\\n \t${ext_srcdir}/enc_filebuf.h \\"}, {"sha": "69dfe302674d11d7cce37ff23376fb9d7f28ad15", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/009368dba64b7288dc9d9a92618de62d2e36dc3a/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/009368dba64b7288dc9d9a92618de62d2e36dc3a/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=009368dba64b7288dc9d9a92618de62d2e36dc3a", "patch": "@@ -411,6 +411,7 @@ ext_srcdir = ${glibcxx_srcdir}/include/ext\n ext_builddir = ./ext\n ext_headers = \\\n \t${ext_srcdir}/algorithm \\\n+\t${ext_srcdir}/bitmap_allocator.h \\\n \t${ext_srcdir}/debug_allocator.h \\\n \t${ext_srcdir}/demangle.h \\\n \t${ext_srcdir}/enc_filebuf.h \\"}, {"sha": "71b278b30dc4d638d25b344f055b98f027e9e254", "filename": "libstdc++-v3/include/ext/bitmap_allocator.h", "status": "added", "additions": 823, "deletions": 0, "changes": 823, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/009368dba64b7288dc9d9a92618de62d2e36dc3a/libstdc%2B%2B-v3%2Finclude%2Fext%2Fbitmap_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/009368dba64b7288dc9d9a92618de62d2e36dc3a/libstdc%2B%2B-v3%2Finclude%2Fext%2Fbitmap_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fbitmap_allocator.h?ref=009368dba64b7288dc9d9a92618de62d2e36dc3a", "patch": "@@ -0,0 +1,823 @@\n+// Bitmapped Allocator. -*- C++ -*-\n+\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+\n+\n+#if !defined _BITMAP_ALLOCATOR_H\n+#define _BITMAP_ALLOCATOR_H 1\n+\n+#include <cstddef>\n+//For std::size_t, and ptrdiff_t.\n+#include <utility>\n+//For std::pair.\n+#include <algorithm>\n+//std::find_if.\n+#include <vector>\n+//For the free list of exponentially growing memory blocks. At max,\n+//size of the vector should be  not more than the number of bits in an\n+//integer or an unsigned integer.\n+#include <functional>\n+//For greater_equal, and less_equal.\n+#include <new>\n+//For operator new.\n+#include <bits/gthr.h>\n+//For __gthread_mutex_t, __gthread_mutex_lock and __gthread_mutex_unlock.\n+#include <ext/new_allocator.h>\n+//For __gnu_cxx::new_allocator for std::vector.\n+\n+#include <cassert>\n+#define NDEBUG\n+\n+//#define CHECK_FOR_ERRORS\n+\n+namespace __gnu_cxx\n+{\n+\n+  class _Mutex {\n+    __gthread_mutex_t _M_mut;\n+    //Prevent Copying and assignment.\n+    _Mutex (_Mutex const&);\n+    _Mutex& operator= (_Mutex const&);\n+  public:\n+    _Mutex ()\n+    {\n+#if !defined __GTHREAD_MUTEX_INIT\n+      __GTHREAD_MUTEX_INIT_FUNCTION(&_M_mut);\n+#else\n+      __gthread_mutex_t __mtemp = __GTHREAD_MUTEX_INIT;\n+      _M_mut = __mtemp;\n+#endif\n+    }\n+    ~_Mutex ()\n+    {\n+      //Gthreads does not define a Mutex Destruction Function.\n+    }\n+    __gthread_mutex_t *_M_get() { return &_M_mut; }\n+  };\n+\n+\n+  class _Lock {\n+    _Mutex& _M_mt;\n+    //Prevent Copying and assignment.\n+    _Lock (_Lock const&);\n+    _Lock& operator= (_Lock const&);\n+  public:\n+    _Lock (_Mutex& __mref) : _M_mt(__mref)\n+    {\n+      __gthread_mutex_lock(_M_mt._M_get());\n+    }\n+    ~_Lock () { __gthread_mutex_unlock(_M_mt._M_get()); }\n+  };\n+\n+  namespace __aux_balloc {\n+\n+    static const unsigned int _Bits_Per_Byte = 8;\n+    static const unsigned int _Bits_Per_Block = sizeof(unsigned int) * _Bits_Per_Byte;\n+\n+    template <typename _Addr_Pair_t>\n+    inline size_t __balloc_num_blocks (_Addr_Pair_t __ap)\n+    {\n+      return (__ap.second - __ap.first) + 1;\n+    }\n+\n+    template <typename _Addr_Pair_t>\n+    inline size_t __balloc_num_bit_maps (_Addr_Pair_t __ap)\n+    {\n+      return __balloc_num_blocks(__ap) / _Bits_Per_Block;\n+    }\n+\n+    //T should be a pointer type.\n+    template <typename _Tp>\n+    class _Inclusive_between : public std::unary_function<typename std::pair<_Tp, _Tp>, bool> {\n+      typedef _Tp pointer;\n+      pointer _M_ptr_value;\n+      typedef typename std::pair<_Tp, _Tp> _Block_pair;\n+\n+    public:\n+      _Inclusive_between (pointer __ptr) : _M_ptr_value(__ptr) { }\n+      bool operator () (_Block_pair __bp) const throw ()\n+      {\n+\tif (std::less_equal<pointer> ()(_M_ptr_value, __bp.second) && \n+\t    std::greater_equal<pointer> ()(_M_ptr_value, __bp.first))\n+\t  return true;\n+\telse\n+\t  return false;\n+      }\n+    };\n+  \n+    //Used to pass a Functor to functions by reference.\n+    template <typename _Functor>\n+    class _Functor_Ref : \n+      public std::unary_function<typename _Functor::argument_type, typename _Functor::result_type> {\n+      _Functor& _M_fref;\n+    \n+    public:\n+      typedef typename _Functor::argument_type argument_type;\n+      typedef typename _Functor::result_type result_type;\n+\n+      _Functor_Ref (_Functor& __fref) : _M_fref(__fref) { }\n+      result_type operator() (argument_type __arg) { return _M_fref (__arg); }\n+    };\n+\n+\n+    //T should be a pointer type, and A is the Allocator for the vector.\n+    template <typename _Tp, typename _Alloc>\n+    class _Ffit_finder : public std::unary_function<typename std::pair<_Tp, _Tp>, bool> {\n+      typedef typename std::vector<std::pair<_Tp, _Tp>, _Alloc> _BPVector;\n+      typedef typename _BPVector::difference_type _Counter_type;\n+      typedef typename std::pair<_Tp, _Tp> _Block_pair;\n+\n+      unsigned int *_M_pbitmap;\n+      unsigned int _M_data_offset;\n+\n+    public:\n+      _Ffit_finder () : _M_pbitmap (0), _M_data_offset (0) { }\n+\n+      bool operator() (_Block_pair __bp) throw()\n+      {\n+\t//Set the _rover to the last unsigned integer, which is the\n+\t//bitmap to the first free block. Thus, the bitmaps are in exact\n+\t//reverse order of the actual memory layout. So, we count down\n+\t//the bimaps, which is the same as moving up the memory.\n+\n+\t//If the used count stored at the start of the Bit Map headers\n+\t//is equal to the number of Objects that the current Block can\n+\t//store, then there is definitely no space for another single\n+\t//object, so just return false.\n+\t_Counter_type __diff = __gnu_cxx::__aux_balloc::__balloc_num_bit_maps (__bp);\n+\n+\tassert (*(reinterpret_cast<unsigned int*>(__bp.first) - (__diff + 1)) <= \n+\t\t__gnu_cxx::__aux_balloc::__balloc_num_blocks (__bp));\n+\n+\tif (*(reinterpret_cast<unsigned int*>(__bp.first) - (__diff + 1)) == \n+\t    __gnu_cxx::__aux_balloc::__balloc_num_blocks (__bp))\n+\t  return false;\n+\n+\tunsigned int *__rover = reinterpret_cast<unsigned int*>(__bp.first) - 1;\n+\tfor (_Counter_type __i = 0; __i < __diff; ++__i)\n+\t  {\n+\t    _M_data_offset = __i;\n+\t    if (*__rover)\n+\t      {\n+\t\t_M_pbitmap = __rover;\n+\t\treturn true;\n+\t      }\n+\t    --__rover;\n+\t  }\n+\treturn false;\n+      }\n+    \n+      unsigned int *_M_get () { return _M_pbitmap; }\n+      unsigned int _M_offset () { return _M_data_offset * _Bits_Per_Block; }\n+    };\n+  \n+    //T should be a pointer type.\n+    template <typename _Tp, typename _Alloc>\n+    class _Bit_map_counter {\n+    \n+      typedef typename std::vector<std::pair<_Tp, _Tp>, _Alloc> _BPVector;\n+      typedef typename _BPVector::size_type _Index_type;\n+      typedef _Tp pointer;\n+    \n+      _BPVector& _M_vbp;\n+      unsigned int *_M_curr_bmap;\n+      unsigned int *_M_last_bmap_in_block;\n+      _Index_type _M_curr_index;\n+    \n+    public:\n+      //Use the 2nd parameter with care. Make sure that such an entry\n+      //exists in the vector before passing that particular index to\n+      //this ctor.\n+      _Bit_map_counter (_BPVector& Rvbp, int __index = -1) : _M_vbp(Rvbp)\n+      {\n+\tthis->_M_reset(__index);\n+      }\n+    \n+      void _M_reset (int __index = -1) throw()\n+      {\n+\tif (__index == -1)\n+\t  {\n+\t    _M_curr_bmap = 0;\n+\t    _M_curr_index = (_Index_type)-1;\n+\t    return;\n+\t  }\n+\n+\t_M_curr_index = __index;\n+\t_M_curr_bmap = reinterpret_cast<unsigned int*>(_M_vbp[_M_curr_index].first) - 1;\n+\n+\tassert (__index <= (int)_M_vbp.size() - 1);\n+\t\n+\t_M_last_bmap_in_block = _M_curr_bmap - \n+\t  ((_M_vbp[_M_curr_index].second - _M_vbp[_M_curr_index].first + 1) / _Bits_Per_Block - 1);\n+      }\n+    \n+      //Dangerous Function! Use with extreme care. Pass to this\n+      //functions ONLY those values that are known to be correct,\n+      //otherwise this will mess up big time.\n+      void _M_set_internal_bit_map (unsigned int *__new_internal_marker) throw()\n+      {\n+\t_M_curr_bmap = __new_internal_marker;\n+      }\n+    \n+      bool _M_finished () const throw()\n+      {\n+\treturn (_M_curr_bmap == 0);\n+      }\n+    \n+      _Bit_map_counter& operator++ () throw()\n+      {\n+\tif (_M_curr_bmap == _M_last_bmap_in_block)\n+\t  {\n+\t    if (++_M_curr_index == _M_vbp.size())\n+\t      {\n+\t\t_M_curr_bmap = 0;\n+\t      }\n+\t    else\n+\t      {\n+\t\tthis->_M_reset (_M_curr_index);\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    --_M_curr_bmap;\n+\t  }\n+\treturn *this;\n+      }\n+    \n+      unsigned int *_M_get ()\n+      {\n+\treturn _M_curr_bmap;\n+      }\n+    \n+      pointer base () { return _M_vbp[_M_curr_index].first; }\n+      unsigned int _M_offset ()\n+      {\n+\treturn _Bits_Per_Block * ((reinterpret_cast<unsigned int*>(this->base()) - _M_curr_bmap) - 1);\n+      }\n+    \n+      unsigned int _M_where () { return _M_curr_index; }\n+    };\n+  }\n+\n+    //Generic Version of the bsf instruction.\n+    typedef unsigned int _Bit_map_type;\n+    static inline unsigned int _Bit_scan_forward (_Bit_map_type __num)\n+    {\n+      unsigned int __ret_val = 0;\n+      while (__num % 2 == 0)\n+\t{\n+\t  ++__ret_val;\n+\t  __num >>= 1;\n+\t}\n+      return __ret_val;\n+    }\n+\n+  struct _OOM_handler {\n+    static std::new_handler _S_old_handler;\n+    static bool _S_handled_oom;\n+    typedef void (*_FL_clear_proc)(void);\n+    static _FL_clear_proc _S_oom_fcp;\n+    \n+    _OOM_handler (_FL_clear_proc __fcp)\n+    {\n+      _S_oom_fcp = __fcp;\n+      _S_old_handler = std::set_new_handler (_S_handle_oom_proc);\n+      _S_handled_oom = false;\n+    }\n+\n+    static void _S_handle_oom_proc()\n+    {\n+      _S_oom_fcp();\n+      std::set_new_handler (_S_old_handler);\n+      _S_handled_oom = true;\n+    }\n+\n+    ~_OOM_handler ()\n+    {\n+      if (!_S_handled_oom)\n+\tstd::set_new_handler (_S_old_handler);\n+    }\n+  };\n+  \n+  std::new_handler _OOM_handler::_S_old_handler;\n+  bool _OOM_handler::_S_handled_oom = false;\n+  _OOM_handler::_FL_clear_proc _OOM_handler::_S_oom_fcp = 0;\n+  \n+\n+  class _BA_free_list_store {\n+    struct _LT_pointer_compare {\n+      template <typename _Tp>\n+      bool operator() (_Tp* __pt, _Tp const& __crt) const throw()\n+      {\n+\treturn *__pt < __crt;\n+      }\n+    };\n+\n+#if defined __GTHREADS\n+    static _Mutex _S_bfl_mutex;\n+#endif\n+    static std::vector<unsigned int*> _S_free_list;\n+    typedef std::vector<unsigned int*>::iterator _FLIter;\n+\n+    static void _S_validate_free_list(unsigned int *__addr) throw()\n+    {\n+      const unsigned int Max_Size = 64;\n+      if (_S_free_list.size() >= Max_Size)\n+\t{\n+\t  //Ok, the threshold value has been reached.\n+\t  //We determine which block to remove from the list of free\n+\t  //blocks.\n+\t  if (*__addr >= *_S_free_list.back())\n+\t    {\n+\t      //Ok, the new block is greater than or equal to the last\n+\t      //block in the list of free blocks. We just free the new\n+\t      //block.\n+\t      operator delete((void*)__addr);\n+\t      return;\n+\t    }\n+\t  else\n+\t    {\n+\t      //Deallocate the last block in the list of free lists, and\n+\t      //insert the new one in it's correct position.\n+\t      operator delete((void*)_S_free_list.back());\n+\t      _S_free_list.pop_back();\n+\t    }\n+\t}\n+\t  \n+      //Just add the block to the list of free lists\n+      //unconditionally.\n+      _FLIter __temp = std::lower_bound(_S_free_list.begin(), _S_free_list.end(), \n+\t\t\t\t\t*__addr, _LT_pointer_compare ());\n+      //We may insert the new free list before _temp;\n+      _S_free_list.insert(__temp, __addr);\n+    }\n+\n+    static bool _S_should_i_give(unsigned int __block_size, unsigned int __required_size) throw()\n+    {\n+      const unsigned int Max_Wastage_Percentage = 36;\n+\n+      if (__block_size >= __required_size && \n+\t  (((__block_size - __required_size) * 100 / __block_size) < Max_Wastage_Percentage))\n+\treturn true;\n+      else\n+\treturn false;\n+    }\n+\n+  public:\n+    typedef _BA_free_list_store _BFL_type;\n+\n+    static inline void _S_insert_free_list(unsigned int *__addr) throw()\n+    {\n+#if defined __GTHREADS\n+      _Lock __bfl_lock(*&_S_bfl_mutex);\n+#endif\n+      //Call _S_validate_free_list to decide what should be done with this\n+      //particular free list.\n+      _S_validate_free_list(--__addr);\n+    }\n+    \n+    static unsigned int *_S_get_free_list(unsigned int __sz) throw (std::bad_alloc)\n+    {\n+#if defined __GTHREADS\n+      _Lock __bfl_lock(*&_S_bfl_mutex);\n+#endif\n+      _FLIter __temp = std::lower_bound(_S_free_list.begin(), _S_free_list.end(), \n+\t\t\t\t\t__sz, _LT_pointer_compare());\n+      if (__temp == _S_free_list.end() || !_S_should_i_give (**__temp, __sz))\n+\t{\n+\t  _OOM_handler __set_handler(_BFL_type::_S_clear);\n+\t  unsigned int *__ret_val = reinterpret_cast<unsigned int*>\n+\t    (operator new (__sz + sizeof(unsigned int)));\n+\t  *__ret_val = __sz;\n+\t  return ++__ret_val;\n+\t}\n+      else\n+\t{\n+\t  unsigned int* __ret_val = *__temp;\n+\t  _S_free_list.erase (__temp);\n+\t  return ++__ret_val;\n+\t}\n+    }\n+\n+    //This function just clears the internal Free List, and gives back\n+    //all the memory to the OS.\n+    static void _S_clear()\n+    {\n+#if defined __GTHREADS\n+      _Lock __bfl_lock(*&_S_bfl_mutex);\n+#endif\n+      _FLIter __iter = _S_free_list.begin();\n+      while (__iter != _S_free_list.end())\n+\t{\n+\t  operator delete((void*)*__iter);\n+\t  ++__iter;\n+\t}\n+      _S_free_list.clear();\n+    }\n+\n+  };\n+\n+#if defined __GTHREADS\n+  _Mutex _BA_free_list_store::_S_bfl_mutex;\n+#endif\n+  std::vector<unsigned int*> _BA_free_list_store::_S_free_list;\n+\n+  template <class _Tp> class bitmap_allocator;\n+  // specialize for void:\n+  template <> class bitmap_allocator<void> {\n+  public:\n+    typedef void*       pointer;\n+    typedef const void* const_pointer;\n+    //  reference-to-void members are impossible.\n+    typedef void  value_type;\n+    template <class U> struct rebind { typedef bitmap_allocator<U> other; };\n+  };\n+\n+  template <class _Tp> class bitmap_allocator : private _BA_free_list_store {\n+  public:\n+    typedef size_t    size_type;\n+    typedef ptrdiff_t difference_type;\n+    typedef _Tp*        pointer;\n+    typedef const _Tp*  const_pointer;\n+    typedef _Tp&        reference;\n+    typedef const _Tp&  const_reference;\n+    typedef _Tp         value_type;\n+    template <class U> struct rebind { typedef bitmap_allocator<U> other; };\n+\n+  private:\n+    static const unsigned int _Bits_Per_Byte = 8;\n+    static const unsigned int _Bits_Per_Block = sizeof(unsigned int) * _Bits_Per_Byte;\n+\n+    static inline void _S_bit_allocate(unsigned int *__pbmap, unsigned int __pos) throw()\n+    {\n+      unsigned int __mask = 1 << __pos;\n+      __mask = ~__mask;\n+      *__pbmap &= __mask;\n+    }\n+  \n+    static inline void _S_bit_free(unsigned int *__pbmap, unsigned int __Pos) throw()\n+    {\n+      unsigned int __mask = 1 << __Pos;\n+      *__pbmap |= __mask;\n+    }\n+\n+    static inline void *_S_memory_get(size_t __sz) throw (std::bad_alloc)\n+    {\n+      return operator new(__sz);\n+    }\n+\n+    static inline void _S_memory_put(void *__vptr) throw ()\n+    {\n+      operator delete(__vptr);\n+    }\n+\n+    typedef typename std::pair<pointer, pointer> _Block_pair;\n+    typedef typename __gnu_cxx::new_allocator<_Block_pair> _BPVec_allocator_type;\n+    typedef typename std::vector<_Block_pair, _BPVec_allocator_type> _BPVector;\n+\n+\n+#if defined CHECK_FOR_ERRORS\n+    //Complexity: O(lg(N)). Where, N is the number of block of size\n+    //sizeof(value_type).\n+    static void _S_check_for_free_blocks() throw()\n+    {\n+      typedef typename __gnu_cxx::__aux_balloc::_Ffit_finder<pointer, _BPVec_allocator_type> _FFF;\n+      _FFF __fff;\n+      typedef typename _BPVector::iterator _BPiter;\n+      _BPiter __bpi = std::find_if(_S_mem_blocks.begin(), _S_mem_blocks.end(), \n+\t\t\t\t   __gnu_cxx::__aux_balloc::_Functor_Ref<_FFF>(__fff));\n+      assert(__bpi == _S_mem_blocks.end());\n+    }\n+#endif\n+\n+\n+    //Complexity: O(1), but internally depends upon the complexity of\n+    //the function _BA_free_list_store::_S_get_free_list. The part\n+    //where the bitmap headers are written is of worst case complexity:\n+    //O(X),where X is the number of blocks of size sizeof(value_type)\n+    //within the newly acquired block. Having a tight bound.\n+    static void _S_refill_pool() throw (std::bad_alloc)\n+    {\n+#if defined CHECK_FOR_ERRORS\n+      _S_check_for_free_blocks();\n+#endif\n+\n+      const unsigned int __num_bit_maps = _S_block_size / _Bits_Per_Block;\n+      const unsigned int __size_to_allocate = sizeof(unsigned int) + \n+\t_S_block_size * sizeof(value_type) + __num_bit_maps*sizeof(unsigned int);\n+\n+      unsigned int *__temp = \n+\treinterpret_cast<unsigned int*>(_BA_free_list_store::_S_get_free_list(__size_to_allocate));\n+      *__temp = 0;\n+      ++__temp;\n+\n+      //The Header information goes at the Beginning of the Block.\n+      _Block_pair __bp = std::make_pair(reinterpret_cast<pointer>(__temp + __num_bit_maps), \n+\t\t\t\t       reinterpret_cast<pointer>(__temp + __num_bit_maps) \n+\t\t\t\t\t+ _S_block_size - 1);\n+\n+      //Fill the Vector with this information.\n+      _S_mem_blocks.push_back(__bp);\n+\n+      unsigned int __bit_mask = 0; //0 Indicates all Allocated.\n+      __bit_mask = ~__bit_mask; //1 Indicates all Free.\n+\n+      for (unsigned int __i = 0; __i < __num_bit_maps; ++__i)\n+\t__temp[__i] = __bit_mask;\n+\n+      //On some implementations, operator new might throw bad_alloc, or\n+      //malloc might fail if the size passed is too large, therefore, we\n+      //limit the size passed to malloc or operator new.\n+      _S_block_size *= 2;\n+    }\n+\n+    static _BPVector _S_mem_blocks;\n+    static unsigned int _S_block_size;\n+    static __gnu_cxx::__aux_balloc::_Bit_map_counter<pointer, _BPVec_allocator_type> _S_last_request;\n+    static typename _BPVector::size_type _S_last_dealloc_index;\n+#if defined __GTHREADS\n+    static _Mutex _S_mut;\n+#endif\n+\n+  public:\n+    bitmap_allocator() throw()\n+    { }\n+\n+    bitmap_allocator(const bitmap_allocator&) { }\n+\n+    template <typename _Tp1> bitmap_allocator(const bitmap_allocator<_Tp1>&) throw()\n+    { }\n+\n+    ~bitmap_allocator() throw()\n+    { }\n+\n+    //Complexity: Worst case complexity is O(N), but that is hardly ever\n+    //hit. if and when this particular case is encountered, the next few\n+    //cases are guaranteed to have a worst case complexity of O(1)!\n+    //That's why this function performs very well on the average. you\n+    //can consider this function to be having a complexity refrred to\n+    //commonly as: Amortized Constant time.\n+    static pointer _S_allocate_single_object()\n+    {\n+#if defined __GTHREADS\n+      _Lock _bit_lock(*&_S_mut);\n+#endif\n+      //The algorithm is something like this: The last_requst variable\n+      //points to the last accessed Bit Map. When such a condition\n+      //occurs, we try to find a free block in the current bitmap, or\n+      //succeeding bitmaps until the last bitmap is reached. If no free\n+      //block turns up, we resort to First Fit method. But, again, the\n+      //First Fit is used only upto the point where we started the\n+      //previous linear search.\n+\n+      while (_S_last_request._M_finished() == false && (*(_S_last_request._M_get()) == 0))\n+\t{\n+\t  _S_last_request.operator++();\n+\t}\n+\n+      if (_S_last_request._M_finished())\n+\t{\n+\t  //Fall Back to First Fit algorithm.\n+\t  typedef typename __gnu_cxx::__aux_balloc::_Ffit_finder<pointer, _BPVec_allocator_type> _FFF;\n+\t  _FFF __fff;\n+\t  typedef typename _BPVector::iterator _BPiter;\n+\t  _BPiter __bpi = std::find_if(_S_mem_blocks.begin(), _S_mem_blocks.end(), \n+\t\t\t\t      __gnu_cxx::__aux_balloc::_Functor_Ref<_FFF>(__fff));\n+\n+\t  if (__bpi != _S_mem_blocks.end())\n+\t    {\n+\t      //Search was successful. Ok, now mark the first bit from\n+\t      //the right as 0, meaning Allocated. This bit is obtained\n+\t      //by calling _M_get() on __fff.\n+\t      unsigned int __nz_bit = _Bit_scan_forward(*__fff._M_get());\n+\t      _S_bit_allocate(__fff._M_get(), __nz_bit);\n+\n+\t      _S_last_request._M_reset(__bpi - _S_mem_blocks.begin());\n+\n+\t      //Now, get the address of the bit we marked as allocated.\n+\t      pointer __ret_val = __bpi->first + __fff._M_offset() + __nz_bit;\n+\t      unsigned int *__puse_count = reinterpret_cast<unsigned int*>(__bpi->first) - \n+\t\t(__gnu_cxx::__aux_balloc::__balloc_num_bit_maps(*__bpi) + 1);\n+\t      ++(*__puse_count);\n+\t      return __ret_val;\n+\t    }\n+\t  else\n+\t    {\n+\t      //Search was unsuccessful. We Add more memory to the pool\n+\t      //by calling _S_refill_pool().\n+\t      _S_refill_pool();\n+\n+\t      //_M_Reset the _S_last_request structure to the first free\n+\t      //block's bit map.\n+\t      _S_last_request._M_reset(_S_mem_blocks.size() - 1);\n+\n+\t      //Now, mark that bit as allocated.\n+\t    }\n+\t}\n+      //_S_last_request holds a pointer to a valid bit map, that points\n+      //to a free block in memory.\n+      unsigned int __nz_bit = _Bit_scan_forward(*_S_last_request._M_get());\n+      _S_bit_allocate(_S_last_request._M_get(), __nz_bit);\n+\n+      pointer __ret_val = _S_last_request.base() + _S_last_request._M_offset() + __nz_bit;\n+\n+      unsigned int *__puse_count = reinterpret_cast<unsigned int*>\n+\t(_S_mem_blocks[_S_last_request._M_where()].first) - \n+\t(__gnu_cxx::__aux_balloc::__balloc_num_bit_maps(_S_mem_blocks[_S_last_request._M_where()]) + 1);\n+      ++(*__puse_count);\n+      return __ret_val;\n+    }\n+\n+    //Complexity: O(1), but internally the complexity depends upon the\n+    //complexity of the function(s) _S_allocate_single_object and\n+    //_S_memory_get.\n+    pointer allocate(size_type __n)\n+    {\n+      if (__n == 1)\n+\treturn _S_allocate_single_object();\n+      else\n+\treturn reinterpret_cast<pointer>(_S_memory_get(__n * sizeof(value_type)));\n+    }\n+\n+    //Complexity: Worst case complexity is O(N) where N is the number of\n+    //blocks of size sizeof(value_type) within the free lists that the\n+    //allocator holds. However, this worst case is hit only when the\n+    //user supplies a bogus argument to hint. If the hint argument is\n+    //sensible, then the complexity drops to O(lg(N)), and in extreme\n+    //cases, even drops to as low as O(1). So, if the user supplied\n+    //argument is good, then this function performs very well.\n+    pointer allocate(size_type __n, typename bitmap_allocator<void>::const_pointer)\n+    {\n+      return allocate(__n);\n+    }\n+\n+    void deallocate(pointer __p, size_type __n) throw()\n+    {\n+      if (__n == 1)\n+\t_S_deallocate_single_object(__p);\n+      else\n+\t_S_memory_put(__p);\n+    }\n+\n+    //Complexity: O(lg(N)), but the worst case is hit quite often! I\n+    //need to do something about this. I'll be able to work on it, only\n+    //when I have some solid figures from a few real apps.\n+    static void _S_deallocate_single_object(pointer __p) throw()\n+    {\n+#if defined __GTHREADS\n+      _Lock _bit_lock(*&_S_mut);\n+#endif\n+      typedef typename _BPVector::iterator iterator;\n+      typedef typename _BPVector::difference_type diff_type;\n+\n+      diff_type __diff;\n+      int __displacement;\n+\n+      assert(_S_last_dealloc_index >= 0);\n+\n+      if (__gnu_cxx::__aux_balloc::_Inclusive_between<pointer>(__p)(_S_mem_blocks[_S_last_dealloc_index]))\n+\t{\n+\t  assert(_S_last_dealloc_index <= _S_mem_blocks.size() - 1);\n+\n+\t  //Initial Assumption was correct!\n+\t  __diff = _S_last_dealloc_index;\n+\t  __displacement = __p - _S_mem_blocks[__diff].first;\n+\t}\n+      else\n+\t{\n+\t  iterator _iter = (std::find_if(_S_mem_blocks.begin(), _S_mem_blocks.end(), \n+\t\t\t\t\t  __gnu_cxx::__aux_balloc::_Inclusive_between<pointer>(__p)));\n+\t  assert(_iter != _S_mem_blocks.end());\n+\n+\t  __diff = _iter - _S_mem_blocks.begin();\n+\t  __displacement = __p - _S_mem_blocks[__diff].first;\n+\t  _S_last_dealloc_index = __diff;\n+\t}\n+\n+      //Get the position of the iterator that has been found.\n+      const unsigned int __rotate = __displacement % _Bits_Per_Block;\n+      unsigned int *__bit_mapC = reinterpret_cast<unsigned int*>(_S_mem_blocks[__diff].first) - 1;\n+      __bit_mapC -= (__displacement / _Bits_Per_Block);\n+      \n+      _S_bit_free(__bit_mapC, __rotate);\n+      unsigned int *__puse_count = reinterpret_cast<unsigned int*>\n+\t(_S_mem_blocks[__diff].first) - \n+\t(__gnu_cxx::__aux_balloc::__balloc_num_bit_maps(_S_mem_blocks[__diff]) + 1);\n+\n+      assert(*__puse_count != 0);\n+\n+      --(*__puse_count);\n+\n+      if (!*__puse_count)\n+\t{\n+\t  _S_block_size /= 2;\n+\t  \n+\t  //We may safely remove this block.\n+\t  _Block_pair __bp = _S_mem_blocks[__diff];\n+\t  _S_insert_free_list(__puse_count);\n+\t  _S_mem_blocks.erase(_S_mem_blocks.begin() + __diff);\n+\n+\t  //We reset the _S_last_request variable to reflect the erased\n+\t  //block. We do this to pretect future requests after the last\n+\t  //block has been removed from a particular memory Chunk,\n+\t  //which in turn has been returned to the free list, and\n+\t  //hence had been erased from the vector, so the size of the\n+\t  //vector gets reduced by 1.\n+\t  if ((diff_type)_S_last_request._M_where() >= __diff--)\n+\t    {\n+\t      _S_last_request._M_reset(__diff);\n+\t      //\t      assert(__diff >= 0);\n+\t    }\n+\n+\t  //If the Index into the vector of the region of memory that\n+\t  //might hold the next address that will be passed to\n+\t  //deallocated may have been invalidated due to the above\n+\t  //erase procedure being called on the vector, hence we try\n+\t  //to restore this invariant too.\n+\t  if (_S_last_dealloc_index >= _S_mem_blocks.size())\n+\t    {\n+\t      _S_last_dealloc_index =(__diff != -1 ? __diff : 0);\n+\t      assert(_S_last_dealloc_index >= 0);\n+\t    }\n+\t}\n+    }\n+\n+    pointer address(reference r) const { return &r; }\n+    const_pointer address(const_reference r) const { return &r; }\n+\n+    size_type max_size(void) const throw() { return (size_type()-1)/sizeof(value_type); }\n+\n+    void construct (pointer p, const_reference _data)\n+    {\n+      new (p) value_type (_data);\n+    }\n+\n+    void destroy (pointer p)\n+    {\n+      p->~value_type();\n+    }\n+\n+  };\n+\n+  template <typename _Tp>\n+  typename bitmap_allocator<_Tp>::_BPVector bitmap_allocator<_Tp>::_S_mem_blocks;\n+\n+  template <typename _Tp>\n+  unsigned int bitmap_allocator<_Tp>::_S_block_size = bitmap_allocator<_Tp>::_Bits_Per_Block;\n+\n+  template <typename _Tp>\n+  typename __gnu_cxx::bitmap_allocator<_Tp>::_BPVector::size_type \n+  bitmap_allocator<_Tp>::_S_last_dealloc_index = 0;\n+\n+  template <typename _Tp>\n+  __gnu_cxx::__aux_balloc::_Bit_map_counter \n+  <typename bitmap_allocator<_Tp>::pointer, typename bitmap_allocator<_Tp>::_BPVec_allocator_type> \n+  bitmap_allocator<_Tp>::_S_last_request(_S_mem_blocks);\n+\n+#if defined __GTHREADS\n+  template <typename _Tp>\n+  __gnu_cxx::_Mutex\n+  bitmap_allocator<_Tp>::_S_mut;\n+#endif\n+\n+  template <typename _Tp1, typename _Tp2>\n+  bool operator== (const bitmap_allocator<_Tp1>&, const bitmap_allocator<_Tp2>&) throw()\n+  {\n+    return true;\n+  }\n+  \n+  template <typename _Tp1, typename _Tp2>\n+  bool operator!= (const bitmap_allocator<_Tp1>&, const bitmap_allocator<_Tp2>&) throw()\n+  {\n+    return false;\n+  }\n+}\n+\n+\n+#endif //_BITMAP_ALLOCATOR_H"}, {"sha": "c9eb2935badef093cc21d8df0d77230a57e7deed", "filename": "libstdc++-v3/testsuite/performance/20_util/allocator/insert.cc", "status": "modified", "additions": 56, "deletions": 24, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/009368dba64b7288dc9d9a92618de62d2e36dc3a/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F20_util%2Fallocator%2Finsert.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/009368dba64b7288dc9d9a92618de62d2e36dc3a/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F20_util%2Fallocator%2Finsert.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F20_util%2Fallocator%2Finsert.cc?ref=009368dba64b7288dc9d9a92618de62d2e36dc3a", "patch": "@@ -43,6 +43,7 @@\n #include <ext/mt_allocator.h>\n #include <ext/new_allocator.h>\n #include <ext/malloc_allocator.h>\n+#include <ext/bitmap_allocator.h>\n #include <cxxabi.h>\n #include <testsuite_performance.h>\n \n@@ -146,6 +147,7 @@ int main(void)\n   typedef __gnu_cxx::malloc_allocator<test_type> m_alloc_type;\n   typedef __gnu_cxx::new_allocator<test_type> n_alloc_type;\n   typedef __gnu_cxx::__mt_alloc<test_type> so_alloc_type;\n+  typedef __gnu_cxx::bitmap_allocator<test_type> bit_alloc_type;\n \n #ifdef TEST_B0\n   test_container(vector<test_type, m_alloc_type>());\n@@ -156,47 +158,62 @@ int main(void)\n #ifdef TEST_B2\n   test_container(vector<test_type, so_alloc_type>());\n #endif\n-\n #ifdef TEST_B3\n-  test_container(list<test_type, m_alloc_type>());\n+  test_container(vector<test_type, bit_alloc_type>());\n #endif\n+\n #ifdef TEST_B4\n-  test_container(list<test_type, n_alloc_type>());\n+  test_container(list<test_type, m_alloc_type>());\n #endif\n #ifdef TEST_B5\n+  test_container(list<test_type, n_alloc_type>());\n+#endif\n+#ifdef TEST_B6\n   test_container(list<test_type, so_alloc_type>());\n #endif\n+#ifdef TEST_B7\n+  test_container(list<test_type, bit_alloc_type>());\n+#endif\n \n-#ifdef TEST_B6\n+#ifdef TEST_B8\n   test_container(deque<test_type, m_alloc_type>());\n #endif\n-#ifdef TEST_B7\n+#ifdef TEST_B9\n   test_container(deque<test_type, n_alloc_type>());\n #endif\n-#ifdef TEST_B8\n+#ifdef TEST_B10\n   test_container(deque<test_type, so_alloc_type>());\n #endif\n+#ifdef TEST_B11\n+  test_container(deque<test_type, bit_alloc_type>());\n+#endif\n \n   typedef less<test_type> compare_type;\n-#ifdef TEST_B9\n+#ifdef TEST_B12\n   test_container(map<test_type, test_type, compare_type, m_alloc_type>());\n #endif\n-#ifdef TEST_B10\n+#ifdef TEST_B13\n   test_container(map<test_type, test_type, compare_type, n_alloc_type>());\n #endif\n-#ifdef TEST_B11\n+#ifdef TEST_B14\n   test_container(map<test_type, test_type, compare_type, so_alloc_type>());\n #endif\n+#ifdef TEST_B15\n+  test_container(map<test_type, test_type, compare_type, bit_alloc_type>());\n+#endif\n \n-#ifdef TEST_B12\n+#ifdef TEST_B16\n   test_container(set<test_type, compare_type, m_alloc_type>());\n #endif\n-#ifdef TEST_B13\n+#ifdef TEST_B17\n   test_container(set<test_type, compare_type, n_alloc_type>());\n #endif\n-#ifdef TEST_B14\n+#ifdef TEST_B18\n   test_container(set<test_type, compare_type, so_alloc_type>());\n #endif\n+#ifdef TEST_B19\n+  test_container(set<test_type, compare_type, bit_alloc_type>());\n+#endif\n \n #ifdef TEST_T0\n   test_container(vector<test_type, m_alloc_type>(), true);\n@@ -207,47 +224,62 @@ int main(void)\n #ifdef TEST_T2\n   test_container(vector<test_type, so_alloc_type>(), true);\n #endif\n-\n #ifdef TEST_T3\n-  test_container(list<test_type, m_alloc_type>(), true);\n+  test_container(vector<test_type, bit_alloc_type>(), true);\n #endif\n+\n #ifdef TEST_T4\n-  test_container(list<test_type, n_alloc_type>(), true);\n+  test_container(list<test_type, m_alloc_type>(), true);\n #endif\n #ifdef TEST_T5\n+  test_container(list<test_type, n_alloc_type>(), true);\n+#endif\n+#ifdef TEST_T6\n   test_container(list<test_type, so_alloc_type>(), true);\n #endif\n+#ifdef TEST_T7\n+  test_container(list<test_type, bit_alloc_type>(), true);\n+#endif\n \n-#ifdef TEST_T6\n+#ifdef TEST_T8\n   test_container(deque<test_type, m_alloc_type>(), true);\n #endif\n-#ifdef TEST_T7\n+#ifdef TEST_T9\n   test_container(deque<test_type, n_alloc_type>(), true);\n #endif\n-#ifdef TEST_T8\n+#ifdef TEST_T10\n   test_container(deque<test_type, so_alloc_type>(), true);\n #endif\n+#ifdef TEST_T11\n+  test_container(deque<test_type, bit_alloc_type>(), true);\n+#endif\n \n   typedef less<test_type> compare_type;\n-#ifdef TEST_T9\n+#ifdef TEST_T12\n   test_container(map<test_type, test_type, compare_type, m_alloc_type>(), true);\n #endif\n-#ifdef TEST_T10\n+#ifdef TEST_T13\n   test_container(map<test_type, test_type, compare_type, n_alloc_type>(), true);\n #endif\n-#ifdef TEST_T11\n+#ifdef TEST_T14\n   test_container(map<test_type, test_type, compare_type, so_alloc_type>(), true);\n #endif\n+#ifdef TEST_T15\n+  test_container(map<test_type, test_type, compare_type, bit_alloc_type>(), true);\n+#endif\n \n-#ifdef TEST_T12\n+#ifdef TEST_T16\n   test_container(set<test_type, compare_type, m_alloc_type>(), true);\n #endif\n-#ifdef TEST_T13\n+#ifdef TEST_T17\n   test_container(set<test_type, compare_type, n_alloc_type>(), true);\n #endif\n-#ifdef TEST_T14\n+#ifdef TEST_T18\n   test_container(set<test_type, compare_type, so_alloc_type>(), true);\n #endif\n+#ifdef TEST_T19\n+  test_container(set<test_type, compare_type, bit_alloc_type>(), true);\n+#endif\n \n   return 0;\n }"}, {"sha": "8f30c0c339adbf0b99fb474f998627af22bb6a71", "filename": "libstdc++-v3/testsuite/performance/20_util/allocator/insert_insert.cc", "status": "modified", "additions": 29, "deletions": 9, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/009368dba64b7288dc9d9a92618de62d2e36dc3a/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F20_util%2Fallocator%2Finsert_insert.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/009368dba64b7288dc9d9a92618de62d2e36dc3a/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F20_util%2Fallocator%2Finsert_insert.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F20_util%2Fallocator%2Finsert_insert.cc?ref=009368dba64b7288dc9d9a92618de62d2e36dc3a", "patch": "@@ -43,6 +43,7 @@\n #include <ext/mt_allocator.h>\n #include <ext/new_allocator.h>\n #include <ext/malloc_allocator.h>\n+#include <ext/bitmap_allocator.h>\n #include <cxxabi.h>\n #include <testsuite_performance.h>\n \n@@ -117,6 +118,7 @@ int main(void)\n   typedef __gnu_cxx::malloc_allocator<test_type> m_alloc_type;\n   typedef __gnu_cxx::new_allocator<test_type> n_alloc_type;\n   typedef __gnu_cxx::__mt_alloc<test_type> so_alloc_type;\n+  typedef __gnu_cxx::bitmap_allocator<test_type> bit_alloc_type;\n \n #ifdef TEST_S0\n   test_container(vector<test_type, m_alloc_type>());\n@@ -127,37 +129,52 @@ int main(void)\n #ifdef TEST_S2\n   test_container(vector<test_type, so_alloc_type>());\n #endif\n-\n #ifdef TEST_S3\n-  test_container(list<test_type, m_alloc_type>());\n+  test_container(vector<test_type, bit_alloc_type>());\n #endif\n+\n+\n #ifdef TEST_S4\n-  test_container(list<test_type, n_alloc_type>());\n+  test_container(list<test_type, m_alloc_type>());\n #endif\n #ifdef TEST_S5\n+  test_container(list<test_type, n_alloc_type>());\n+#endif\n+#ifdef TEST_S6\n   test_container(list<test_type, so_alloc_type>());\n #endif\n+#ifdef TEST_S7\n+  test_container(list<test_type, bit_alloc_type>());\n+#endif\n \n-#ifdef TEST_S6\n+\n+#ifdef TEST_S8\n   test_container(deque<test_type, m_alloc_type>());\n #endif\n-#ifdef TEST_S7\n+#ifdef TEST_S9\n   test_container(deque<test_type, n_alloc_type>());\n #endif\n-#ifdef TEST_S8\n+#ifdef TEST_S10\n   test_container(deque<test_type, so_alloc_type>());\n #endif\n+#ifdef TEST_S11\n+  test_container(deque<test_type, bit_alloc_type>());\n+#endif\n \n   typedef less<test_type> compare_type;\n-#ifdef TEST_S9\n+#ifdef TEST_S12\n   test_container(map<test_type, test_type, compare_type, m_alloc_type>());\n #endif\n-#ifdef TEST_S10\n+#ifdef TEST_S13\n   test_container(map<test_type, test_type, compare_type, n_alloc_type>());\n #endif\n-#ifdef TEST_S11\n+#ifdef TEST_S14\n   test_container(map<test_type, test_type, compare_type, so_alloc_type>());\n #endif\n+#ifdef TEST_S15\n+  test_container(map<test_type, test_type, compare_type, bit_alloc_type>());\n+#endif\n+\n \n #ifdef TEST_S12\n   test_container(set<test_type, compare_type, m_alloc_type>());\n@@ -168,6 +185,9 @@ int main(void)\n #ifdef TEST_S14\n   test_container(set<test_type, compare_type, so_alloc_type>());\n #endif\n+#ifdef TEST_S14\n+  test_container(set<test_type, compare_type, bit_alloc_type>());\n+#endif\n \n   return 0;\n }"}, {"sha": "aceff0231eaeb3bf3f7332b29f48e62e1721f508", "filename": "libstdc++-v3/testsuite/performance/20_util/allocator/list_sort_search.cc", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/009368dba64b7288dc9d9a92618de62d2e36dc3a/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F20_util%2Fallocator%2Flist_sort_search.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/009368dba64b7288dc9d9a92618de62d2e36dc3a/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F20_util%2Fallocator%2Flist_sort_search.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F20_util%2Fallocator%2Flist_sort_search.cc?ref=009368dba64b7288dc9d9a92618de62d2e36dc3a", "patch": "@@ -0,0 +1,125 @@\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// 2004-03-11  Dhruv Matani  <dhruvbird@HotPOP.com>\n+\n+#include <typeinfo>\n+#include <sstream>\n+#include <ext/mt_allocator.h>\n+#include <ext/malloc_allocator.h>\n+#include <cxxabi.h>\n+#include <testsuite_performance.h>\n+#include <ext/bitmap_allocator.h>\n+\n+using namespace std;\n+using __gnu_cxx::malloc_allocator;\n+using __gnu_cxx::__mt_alloc;\n+using __gnu_cxx::bitmap_allocator;\n+\n+typedef int test_type;\n+\n+using namespace __gnu_cxx;\n+\n+#include <list>\n+#include <map>\n+#include <algorithm>\n+#include <cstdlib>\n+using namespace std;\n+\n+template <typename Alloc>\n+int Test_Allocator ()\n+{\n+  typedef list<int, Alloc> My_List;\n+  My_List il1;\n+\n+  int const Iter = 150000;\n+\n+  int ctr = 3;\n+  while (ctr--)\n+    {\n+      for (int i = 0; i < Iter; ++i)\n+\til1.push_back (rand()%500001);\n+\n+      //Search for random values that may or may not belong to the list.\n+      for (int i = 0; i < 50; ++i)\n+\tstd::find (il1.begin(), il1.end(), rand()%100001);\n+      \n+      il1.sort ();\n+      \n+      //Search for random values that may or may not belong to the list.\n+      for (int i = 0; i < 50; ++i)\n+\t{\n+\t  typename My_List::iterator _liter = std::find (il1.begin(), il1.end(), rand()%100001);\n+\t  if (_liter != il1.end())\n+\t    il1.erase (_liter);\n+\t}\n+      \n+      il1.clear ();\n+    }\n+  return Iter;\n+}\n+\n+template <typename Alloc>\n+void do_test ()\n+{\n+  using namespace __gnu_test;\n+  int status;\n+  Alloc obj;\n+\n+  time_counter time;\n+  resource_counter resource;\n+  clear_counters(time, resource);\n+  start_counters(time, resource);\n+  int test_iterations = Test_Allocator<Alloc>();\n+  stop_counters(time, resource);\n+ \n+  std::ostringstream comment;\n+  comment << \"iterations: \" << test_iterations <<endl;\n+  comment << \"type: \" << abi::__cxa_demangle(typeid(obj).name(),\n+\t\t\t\t\t     0, 0, &status);\n+  report_header(__FILE__, comment.str());\n+  report_performance(__FILE__, string(), time, resource);\n+}\n+\n+\n+int main ()\n+{\n+#ifdef TEST_S0\n+  do_test<new_allocator<int> >();\n+#endif\n+#ifdef TEST_S1\n+  do_test<malloc_allocator<int> >();\n+#endif\n+#ifdef TEST_S2\n+  do_test<bitmap_allocator<int> >();\n+#endif\n+#ifdef TEST_S3\n+  do_test<__mt_alloc<int> >();\n+#endif\n+}\n+\n+"}, {"sha": "c3fe0884075e1745ba66a8461ce99a14794fa089", "filename": "libstdc++-v3/testsuite/performance/20_util/allocator/map_mt_find.cc", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/009368dba64b7288dc9d9a92618de62d2e36dc3a/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F20_util%2Fallocator%2Fmap_mt_find.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/009368dba64b7288dc9d9a92618de62d2e36dc3a/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F20_util%2Fallocator%2Fmap_mt_find.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F20_util%2Fallocator%2Fmap_mt_find.cc?ref=009368dba64b7288dc9d9a92618de62d2e36dc3a", "patch": "@@ -0,0 +1,148 @@\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// 2004-03-11  Dhruv Matani  <dhruvbird@HotPOP.com>\n+\n+#include <new>\n+#include <map>\n+#include <cstdlib>\n+#include <string>\n+#include <pthread.h>\n+\n+#include <typeinfo>\n+#include <sstream>\n+#include <ext/mt_allocator.h>\n+#include <ext/malloc_allocator.h>\n+#include <cxxabi.h>\n+#include <testsuite_performance.h>\n+#include <ext/bitmap_allocator.h>\n+\n+using namespace std;\n+using __gnu_cxx::malloc_allocator;\n+using __gnu_cxx::__mt_alloc;\n+using __gnu_cxx::bitmap_allocator;\n+\n+typedef int test_type;\n+\n+using namespace __gnu_cxx;\n+using namespace std;\n+\n+bool less_int (int x1, int x2) { return x1<x2; }\n+\n+\n+#if defined USE_FUNCTION_COMPARE\n+#define COMPARE_T typeof(&less_int)\n+#define COMPARE_F &less_int\n+#else\n+#define COMPARE_T std::less<int>\n+#define COMPARE_F std::less<int>()\n+#endif\n+\n+template <typename Alloc>\n+void *find_proc (void *_vptr)\n+{\n+  map<int, string, COMPARE_T, Alloc> *_mptr = \n+    reinterpret_cast<map<int, string, COMPARE_T, Alloc>*>(_vptr);\n+\n+  for (int i = 0; i < 700000; ++i)\n+    {\n+      int Finder = rand() % 2000000;\n+      _mptr->find (Finder);\n+    }\n+  return _vptr;\n+}\n+\n+\n+template <typename Alloc>\n+int do_test ()\n+{\n+  COMPARE_T _comp = COMPARE_F;\n+  map<int, string, COMPARE_T, Alloc> imap (_comp);\n+  int x = 2;\n+  pthread_t thr[3];\n+  const int Iter = 1000000;\n+\n+  while (x--)\n+    {\n+      for (int i = 0; i < 300000; ++i)\n+\timap.insert (make_pair (rand()%1000000, \"_test_data\"));\n+\n+      for (int i = 0; i < 100000; ++i)\n+\timap.insert (make_pair (rand()%2000000, \"_test_data\"));\n+\n+      pthread_create (&thr[0], NULL, find_proc<Alloc>, (void*)&imap);\n+      pthread_create (&thr[1], NULL, find_proc<Alloc>, (void*)&imap);\n+      pthread_create (&thr[2], NULL, find_proc<Alloc>, (void*)&imap);\n+\n+      pthread_join (thr[0], 0);\n+      pthread_join (thr[1], 0);\n+      pthread_join (thr[2], 0);\n+\n+      imap.clear ();\n+    }\n+  return Iter;\n+}\n+\n+template <typename Alloc>\n+void exec_tests ()\n+{\n+  using namespace __gnu_test;\n+  int status;\n+  COMPARE_T _comp = COMPARE_F;\n+  map<int, string, COMPARE_T, Alloc> obj (_comp);\n+\n+  time_counter time;\n+  resource_counter resource;\n+  clear_counters(time, resource);\n+  start_counters(time, resource);\n+  int test_iterations = do_test<Alloc>();\n+  stop_counters(time, resource);\n+ \n+  std::ostringstream comment;\n+  comment << \"iterations: \" << test_iterations <<endl;\n+  comment << \"type: \" << abi::__cxa_demangle(typeid(obj).name(),\n+\t\t\t\t\t     0, 0, &status);\n+  report_header(__FILE__, comment.str());\n+  report_performance(__FILE__, string(), time, resource);\n+}\n+\n+\n+int main()\n+{\n+#ifdef TEST_T0\n+  exec_tests<new_allocator<int> >();\n+#endif\n+#ifdef TEST_T1\n+  exec_tests<malloc_allocator<int> >();\n+#endif\n+#ifdef TEST_T2\n+  exec_tests<bitmap_allocator<int> >();\n+#endif\n+#ifdef TEST_T3\n+  exec_tests<__mt_alloc<int> >();\n+#endif\n+}"}, {"sha": "b85e6e94c76934761775ceaa149adcb0b05ef6a8", "filename": "libstdc++-v3/testsuite/performance/20_util/allocator/map_thread.cc", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/009368dba64b7288dc9d9a92618de62d2e36dc3a/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F20_util%2Fallocator%2Fmap_thread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/009368dba64b7288dc9d9a92618de62d2e36dc3a/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F20_util%2Fallocator%2Fmap_thread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F20_util%2Fallocator%2Fmap_thread.cc?ref=009368dba64b7288dc9d9a92618de62d2e36dc3a", "patch": "@@ -40,13 +40,15 @@\n #include <ext/mt_allocator.h>\n #include <ext/new_allocator.h>\n #include <ext/malloc_allocator.h>\n+#include <ext/bitmap_allocator.h>\n #include <cxxabi.h>\n #include <testsuite_performance.h>\n \n using namespace std;\n using __gnu_cxx::__mt_alloc;\n using __gnu_cxx::new_allocator;\n using __gnu_cxx::malloc_allocator;\n+using __gnu_cxx::bitmap_allocator;\n \n // The number of iterations to be performed.\n int iterations = 10000;\n@@ -120,6 +122,10 @@ int main(void)\n   test_container(map<int, int, less<const int>,\n                      __mt_alloc< pair<const int, int> > >());\n #endif\n+#ifdef TEST_T5\n+  test_container(map<int, int, less<const int>, bitmap_allocator<int> >());\n+#endif\n+\n \n   return 0;\n }"}, {"sha": "4de30777eab6a335f77d5f4ea04455992060f1c0", "filename": "libstdc++-v3/testsuite/performance/20_util/allocator/producer_consumer.cc", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/009368dba64b7288dc9d9a92618de62d2e36dc3a/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F20_util%2Fallocator%2Fproducer_consumer.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/009368dba64b7288dc9d9a92618de62d2e36dc3a/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F20_util%2Fallocator%2Fproducer_consumer.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F20_util%2Fallocator%2Fproducer_consumer.cc?ref=009368dba64b7288dc9d9a92618de62d2e36dc3a", "patch": "@@ -41,6 +41,7 @@\n #include <ext/mt_allocator.h>\n #include <ext/new_allocator.h>\n #include <ext/malloc_allocator.h>\n+#include <ext/bitmap_allocator.h>\n #include <cxxabi.h>\n #include <testsuite_performance.h>\n \n@@ -49,13 +50,15 @@ using namespace std;\n using __gnu_cxx::__mt_alloc;\n using __gnu_cxx::new_allocator;\n using __gnu_cxx::malloc_allocator;\n+using __gnu_cxx::bitmap_allocator;\n using abi::__cxa_demangle;\n \n typedef int test_type;\n typedef less<test_type> compare_type;\n typedef malloc_allocator<test_type> malloc_alloc_type;\n typedef new_allocator<test_type> new_alloc_type;\n typedef __mt_alloc<test_type> so_alloc_type;\n+typedef bitmap_allocator<test_type> bit_alloc_type;\n \n // The number of iterations to be performed.\n int iterations = 10000;\n@@ -292,6 +295,10 @@ int main(void)\n #ifdef TEST_T3\n   test_container(vector<test_type, so_alloc_type>());\n #endif\n+#ifdef TEST_T4\n+  test_container(vector<test_type, bit_alloc_type>());\n+#endif\n+\n \n #ifdef TEST_T5\n   test_container(list<test_type, malloc_alloc_type>());\n@@ -302,6 +309,10 @@ int main(void)\n #ifdef TEST_T7\n   test_container(list<test_type, so_alloc_type>());\n #endif\n+#ifdef TEST_T8\n+  test_container(list<test_type, bit_alloc_type>());\n+#endif\n+\n \n #ifdef TEST_T9\n   test_container(map<test_type, test_type, compare_type, malloc_alloc_type>());\n@@ -312,6 +323,10 @@ int main(void)\n #ifdef TEST_T11\n   test_container(map<test_type, test_type, compare_type, so_alloc_type>());\n #endif\n+#ifdef TEST_T12\n+  test_container(map<test_type, test_type, compare_type, bit_alloc_type>());\n+#endif\n+\n \n   return 0;\n }"}]}