{"sha": "7499cd25dc142d0271d5eb4ab130ad9c63470e66", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzQ5OWNkMjVkYzE0MmQwMjcxZDVlYjRhYjEzMGFkOWM2MzQ3MGU2Ng==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2015-05-27T04:42:23Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2015-05-27T04:42:23Z"}, "message": "tree-ssa-threadupdate.c: Replace 8 space sequences with tabs.\n\n        * tree-ssa-threadupdate.c: Replace 8 space sequences with tabs.\n        No functional changes.\n\nFrom-SVN: r223734", "tree": {"sha": "ff6b16a2fe4f3dbff07b135fefa7fc8687f1141a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff6b16a2fe4f3dbff07b135fefa7fc8687f1141a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7499cd25dc142d0271d5eb4ab130ad9c63470e66", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7499cd25dc142d0271d5eb4ab130ad9c63470e66", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7499cd25dc142d0271d5eb4ab130ad9c63470e66", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7499cd25dc142d0271d5eb4ab130ad9c63470e66/comments", "author": null, "committer": null, "parents": [{"sha": "6acd8c92ef9e9ff26daff5082a16e196b482f340", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6acd8c92ef9e9ff26daff5082a16e196b482f340", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6acd8c92ef9e9ff26daff5082a16e196b482f340"}], "stats": {"total": 297, "additions": 151, "deletions": 146}, "files": [{"sha": "f02ba5cc1c3473945a54f2bf4f82af2f5aa185a5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7499cd25dc142d0271d5eb4ab130ad9c63470e66/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7499cd25dc142d0271d5eb4ab130ad9c63470e66/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7499cd25dc142d0271d5eb4ab130ad9c63470e66", "patch": "@@ -1,3 +1,8 @@\n+2015-05-26  Jeff Law  <law@redhat.com>\n+\n+\t* tree-ssa-threadupdate.c: Replace 8 space sequences with tabs.\n+\tNo functional changes.\n+\n 2015-05-26  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* ipa-polymorphic-call.c"}, {"sha": "ce1dcdb96a7f6a8f1b0dce0bdd855a08936b35b1", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 146, "deletions": 146, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7499cd25dc142d0271d5eb4ab130ad9c63470e66/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7499cd25dc142d0271d5eb4ab130ad9c63470e66/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=7499cd25dc142d0271d5eb4ab130ad9c63470e66", "patch": "@@ -605,25 +605,25 @@ any_remaining_duplicated_blocks (vec<jump_thread_edge *> *path,\n    For example, assume we have the following control flow and identified\n    jump threading paths:\n \n-                A     B     C\n-                 \\    |    /\n-               Ea \\   |Eb / Ec\n-                   \\  |  /\n-                    v v v\n-                      J       <-- Joiner\n-                     / \\\n-                Eoff/   \\Eon\n-                   /     \\\n-                  v       v\n-                Soff     Son  <--- Normal\n-                         /\\\n-                      Ed/  \\ Ee\n-                       /    \\\n-                      v     v\n-                      D      E\n-\n-            Jump threading paths: A -> J -> Son -> D (path 1)\n-                                  C -> J -> Son -> E (path 2)\n+\t\tA     B     C\n+\t\t \\    |    /\n+\t       Ea \\   |Eb / Ec\n+\t\t   \\  |  /\n+\t\t    v v v\n+\t\t      J       <-- Joiner\n+\t\t     / \\\n+\t\tEoff/   \\Eon\n+\t\t   /     \\\n+\t\t  v       v\n+\t\tSoff     Son  <--- Normal\n+\t\t\t /\\\n+\t\t      Ed/  \\ Ee\n+\t\t       /    \\\n+\t\t      v     v\n+\t\t      D      E\n+\n+\t    Jump threading paths: A -> J -> Son -> D (path 1)\n+\t\t\t\t  C -> J -> Son -> E (path 2)\n \n    Note that the control flow could be more complicated:\n    - Each jump threading path may have more than one incoming edge.  I.e. A and\n@@ -639,22 +639,22 @@ any_remaining_duplicated_blocks (vec<jump_thread_edge *> *path,\n    In the aboe example, after all jump threading is complete, we will\n    end up with the following control flow:\n \n-                A          B            C\n-                |          |            |\n-              Ea|          |Eb          |Ec\n-                |          |            |\n-                v          v            v\n-               Ja          J           Jc\n-               / \\        / \\Eon'     / \\\n-          Eona/   \\   ---/---\\--------   \\Eonc\n-             /     \\ /  /     \\           \\\n-            v       v  v       v          v\n-           Sona     Soff      Son        Sonc\n-             \\                 /\\         /\n-              \\___________    /  \\  _____/\n-                          \\  /    \\/\n-                           vv      v\n-                            D      E\n+\t\tA\t  B\t    C\n+\t\t|\t  |\t    |\n+\t      Ea|\t  |Eb\t  |Ec\n+\t\t|\t  |\t    |\n+\t\tv\t  v\t    v\n+\t       Ja\t  J\t   Jc\n+\t       / \\\t/ \\Eon'     / \\\n+\t  Eona/   \\   ---/---\\--------   \\Eonc\n+\t     /     \\ /  /     \\\t   \\\n+\t    v       v  v       v\t  v\n+\t   Sona     Soff      Son\tSonc\n+\t     \\\t\t /\\\t /\n+\t      \\___________    /  \\  _____/\n+\t\t\t  \\  /    \\/\n+\t\t\t   vv      v\n+\t\t\t    D      E\n \n    The main issue to notice here is that when we are processing path 1\n    (A->J->Son->D) we need to figure out the outgoing edge weights to\n@@ -684,10 +684,10 @@ any_remaining_duplicated_blocks (vec<jump_thread_edge *> *path,\n \n static bool\n compute_path_counts (struct redirection_data *rd,\n-                     ssa_local_info_t *local_info,\n-                     gcov_type *path_in_count_ptr,\n-                     gcov_type *path_out_count_ptr,\n-                     int *path_in_freq_ptr)\n+\t\t     ssa_local_info_t *local_info,\n+\t\t     gcov_type *path_in_count_ptr,\n+\t\t     gcov_type *path_out_count_ptr,\n+\t\t     int *path_in_freq_ptr)\n {\n   edge e = rd->incoming_edges->e;\n   vec<jump_thread_edge *> *path = THREAD_PATH (e);\n@@ -699,13 +699,13 @@ compute_path_counts (struct redirection_data *rd,\n \n   /* Start by accumulating incoming edge counts to the path's first bb\n      into a couple buckets:\n-        path_in_count: total count of incoming edges that flow into the\n-                  current path.\n-        nonpath_count: total count of incoming edges that are not\n-                  flowing along *any* path.  These are the counts\n-                  that will still flow along the original path after\n-                  all path duplication is done by potentially multiple\n-                  calls to this routine.\n+\tpath_in_count: total count of incoming edges that flow into the\n+\t\t  current path.\n+\tnonpath_count: total count of incoming edges that are not\n+\t\t  flowing along *any* path.  These are the counts\n+\t\t  that will still flow along the original path after\n+\t\t  all path duplication is done by potentially multiple\n+\t\t  calls to this routine.\n      (any other incoming edge counts are for a different jump threading\n      path that will be handled by a later call to this routine.)\n      To make this easier, start by recording all incoming edges that flow into\n@@ -727,23 +727,23 @@ compute_path_counts (struct redirection_data *rd,\n       vec<jump_thread_edge *> *ein_path = THREAD_PATH (ein);\n       /* Simply check the incoming edge src against the set captured above.  */\n       if (ein_path\n-          && bitmap_bit_p (in_edge_srcs, (*ein_path)[0]->e->src->index))\n-        {\n-          /* It is necessary but not sufficient that the last path edges\n-             are identical.  There may be different paths that share the\n-             same last path edge in the case where the last edge has a nocopy\n-             source block.  */\n-          gcc_assert (ein_path->last ()->e == elast);\n-          path_in_count += ein->count;\n-          path_in_freq += EDGE_FREQUENCY (ein);\n-        }\n+\t  && bitmap_bit_p (in_edge_srcs, (*ein_path)[0]->e->src->index))\n+\t{\n+\t  /* It is necessary but not sufficient that the last path edges\n+\t     are identical.  There may be different paths that share the\n+\t     same last path edge in the case where the last edge has a nocopy\n+\t     source block.  */\n+\t  gcc_assert (ein_path->last ()->e == elast);\n+\t  path_in_count += ein->count;\n+\t  path_in_freq += EDGE_FREQUENCY (ein);\n+\t}\n       else if (!ein_path)\n-        {\n-          /* Keep track of the incoming edges that are not on any jump-threading\n-             path.  These counts will still flow out of original path after all\n-             jump threading is complete.  */\n-            nonpath_count += ein->count;\n-        }\n+\t{\n+\t  /* Keep track of the incoming edges that are not on any jump-threading\n+\t     path.  These counts will still flow out of original path after all\n+\t     jump threading is complete.  */\n+\t    nonpath_count += ein->count;\n+\t}\n     }\n \n   /* This is needed due to insane incoming frequencies.  */\n@@ -786,31 +786,31 @@ compute_path_counts (struct redirection_data *rd,\n       edge epath = (*path)[i]->e;\n       gcov_type cur_count = epath->count;\n       if ((*path)[i]->type == EDGE_COPY_SRC_JOINER_BLOCK)\n-        {\n-          has_joiner = true;\n-          cur_count = apply_probability (cur_count, onpath_scale);\n-        }\n+\t{\n+\t  has_joiner = true;\n+\t  cur_count = apply_probability (cur_count, onpath_scale);\n+\t}\n       /* In the joiner case we need to update nonpath_count for any edges\n-         coming into the path that will contribute to the count flowing\n-         into the path successor.  */\n+\t coming into the path that will contribute to the count flowing\n+\t into the path successor.  */\n       if (has_joiner && epath != elast)\n       {\n-        /* Look for other incoming edges after joiner.  */\n-        FOR_EACH_EDGE (ein, ei, epath->dest->preds)\n-          {\n-            if (ein != epath\n-                /* Ignore in edges from blocks we have duplicated for a\n-                   threading path, which have duplicated edge counts until\n-                   they are redirected by an invocation of this routine.  */\n-                && !bitmap_bit_p (local_info->duplicate_blocks,\n-                                  ein->src->index))\n-              nonpath_count += ein->count;\n-          }\n+\t/* Look for other incoming edges after joiner.  */\n+\tFOR_EACH_EDGE (ein, ei, epath->dest->preds)\n+\t  {\n+\t    if (ein != epath\n+\t\t/* Ignore in edges from blocks we have duplicated for a\n+\t\t   threading path, which have duplicated edge counts until\n+\t\t   they are redirected by an invocation of this routine.  */\n+\t\t&& !bitmap_bit_p (local_info->duplicate_blocks,\n+\t\t\t\t  ein->src->index))\n+\t      nonpath_count += ein->count;\n+\t  }\n       }\n       if (cur_count < path_out_count)\n-        path_out_count = cur_count;\n+\tpath_out_count = cur_count;\n       if (epath->count < min_path_count)\n-        min_path_count = epath->count;\n+\tmin_path_count = epath->count;\n     }\n \n   /* We computed path_out_count above assuming that this path targeted\n@@ -850,7 +850,7 @@ compute_path_counts (struct redirection_data *rd,\n    and the duplicate edge EDUP will have a count of PATH_OUT_COUNT.  */\n static void\n update_profile (edge epath, edge edup, gcov_type path_in_count,\n-                gcov_type path_out_count, int path_in_freq)\n+\t\tgcov_type path_out_count, int path_in_freq)\n {\n \n   /* First update the duplicated block's count / frequency.  */\n@@ -899,22 +899,22 @@ recompute_probabilities (basic_block bb)\n   FOR_EACH_EDGE (esucc, ei, bb->succs)\n     {\n       if (!bb->count)\n-        continue;\n+\tcontinue;\n \n       /* Prevent overflow computation due to insane profiles.  */\n       if (esucc->count < bb->count)\n-        esucc->probability = GCOV_COMPUTE_SCALE (esucc->count,\n-                                                 bb->count);\n+\tesucc->probability = GCOV_COMPUTE_SCALE (esucc->count,\n+\t\t\t\t\t\t bb->count);\n       else\n-        /* Can happen with missing/guessed probabilities, since we\n-           may determine that more is flowing along duplicated\n-           path than joiner succ probabilities allowed.\n-           Counts and freqs will be insane after jump threading,\n-           at least make sure probability is sane or we will\n-           get a flow verification error.\n-           Not much we can do to make counts/freqs sane without\n-           redoing the profile estimation.  */\n-        esucc->probability = REG_BR_PROB_BASE;\n+\t/* Can happen with missing/guessed probabilities, since we\n+\t   may determine that more is flowing along duplicated\n+\t   path than joiner succ probabilities allowed.\n+\t   Counts and freqs will be insane after jump threading,\n+\t   at least make sure probability is sane or we will\n+\t   get a flow verification error.\n+\t   Not much we can do to make counts/freqs sane without\n+\t   redoing the profile estimation.  */\n+\tesucc->probability = REG_BR_PROB_BASE;\n     }\n }\n \n@@ -927,8 +927,8 @@ recompute_probabilities (basic_block bb)\n \n static void\n update_joiner_offpath_counts (edge epath, basic_block dup_bb,\n-                              gcov_type path_in_count,\n-                              gcov_type path_out_count)\n+\t\t\t      gcov_type path_in_count,\n+\t\t\t      gcov_type path_out_count)\n {\n   /* Compute the count that currently flows off path from the joiner.\n      In other words, the total count of joiner's out edges other than\n@@ -943,7 +943,7 @@ update_joiner_offpath_counts (edge epath, basic_block dup_bb,\n   FOR_EACH_EDGE (enonpath, ei, epath->src->succs)\n     {\n       if (enonpath == epath)\n-        continue;\n+\tcontinue;\n       total_orig_off_path_count += enonpath->count;\n     }\n \n@@ -959,31 +959,31 @@ update_joiner_offpath_counts (edge epath, basic_block dup_bb,\n     {\n       /* Look for edges going off of the threading path.  */\n       if (enonpath == epath)\n-        continue;\n+\tcontinue;\n \n       /* Find the corresponding edge out of the duplicated joiner.  */\n       edge enonpathdup = find_edge (dup_bb, enonpath->dest);\n       gcc_assert (enonpathdup);\n \n       /* We can't use the original probability of the joiner's out\n-         edges, since the probabilities of the original branch\n-         and the duplicated branches may vary after all threading is\n-         complete.  But apportion the duplicated joiner's off-path\n-         total edge count computed earlier (total_dup_off_path_count)\n-         among the duplicated off-path edges based on their original\n-         ratio to the full off-path count (total_orig_off_path_count).\n-         */\n+\t edges, since the probabilities of the original branch\n+\t and the duplicated branches may vary after all threading is\n+\t complete.  But apportion the duplicated joiner's off-path\n+\t total edge count computed earlier (total_dup_off_path_count)\n+\t among the duplicated off-path edges based on their original\n+\t ratio to the full off-path count (total_orig_off_path_count).\n+\t */\n       int scale = GCOV_COMPUTE_SCALE (enonpath->count,\n-                                      total_orig_off_path_count);\n+\t\t\t\t      total_orig_off_path_count);\n       /* Give the duplicated offpath edge a portion of the duplicated\n-         total.  */\n+\t total.  */\n       enonpathdup->count = apply_scale (scale,\n-                                        total_dup_off_path_count);\n+\t\t\t\t\ttotal_dup_off_path_count);\n       /* Now update the original offpath edge count, handling underflow\n-         due to rounding errors.  */\n+\t due to rounding errors.  */\n       enonpath->count -= enonpathdup->count;\n       if (enonpath->count < 0)\n-        enonpath->count = 0;\n+\tenonpath->count = 0;\n     }\n }\n \n@@ -1003,23 +1003,23 @@ estimated_freqs_path (struct redirection_data *rd)\n   FOR_EACH_EDGE (ein, ei, e->dest->preds)\n     {\n       if (ein->count)\n-        return false;\n+\treturn false;\n       non_zero_freq |= ein->src->frequency != 0;\n     }\n \n   for (unsigned int i = 1; i < path->length (); i++)\n     {\n       edge epath = (*path)[i]->e;\n       if (epath->src->count)\n-        return false;\n+\treturn false;\n       non_zero_freq |= epath->src->frequency != 0;\n       edge esucc;\n       FOR_EACH_EDGE (esucc, ei, epath->src->succs)\n-        {\n-          if (esucc->count)\n-            return false;\n-          non_zero_freq |= esucc->src->frequency != 0;\n-        }\n+\t{\n+\t  if (esucc->count)\n+\t    return false;\n+\t  non_zero_freq |= esucc->src->frequency != 0;\n+\t}\n     }\n   return non_zero_freq;\n }\n@@ -1045,23 +1045,23 @@ freqs_to_counts_path (struct redirection_data *rd)\n   FOR_EACH_EDGE (ein, ei, e->dest->preds)\n     {\n       /* Scale up the frequency by REG_BR_PROB_BASE, to avoid rounding\n-         errors applying the probability when the frequencies are very\n-         small.  */\n+\t errors applying the probability when the frequencies are very\n+\t small.  */\n       ein->count = apply_probability (ein->src->frequency * REG_BR_PROB_BASE,\n-                                      ein->probability);\n+\t\t\t\t      ein->probability);\n     }\n \n   for (unsigned int i = 1; i < path->length (); i++)\n     {\n       edge epath = (*path)[i]->e;\n       edge esucc;\n       /* Scale up the frequency by REG_BR_PROB_BASE, to avoid rounding\n-         errors applying the edge probability when the frequencies are very\n-         small.  */\n+\t errors applying the edge probability when the frequencies are very\n+\t small.  */\n       epath->src->count = epath->src->frequency * REG_BR_PROB_BASE;\n       FOR_EACH_EDGE (esucc, ei, epath->src->succs)\n-        esucc->count = apply_probability (esucc->src->count,\n-                                          esucc->probability);\n+\tesucc->count = apply_probability (esucc->src->count,\n+\t\t\t\t\t  esucc->probability);\n     }\n }\n \n@@ -1088,17 +1088,17 @@ clear_counts_path (struct redirection_data *rd)\n     {\n       edge epath = (*path)[i]->e;\n       FOR_EACH_EDGE (esucc, ei, epath->src->succs)\n-        esucc->count = 0;\n+\tesucc->count = 0;\n       epath->src->count = 0;\n     }\n   /* Also need to clear the counts along duplicated path.  */\n   for (unsigned int i = 0; i < 2; i++)\n     {\n       basic_block dup = rd->dup_blocks[i];\n       if (!dup)\n-        continue;\n+\tcontinue;\n       FOR_EACH_EDGE (esucc, ei, dup->succs)\n-        esucc->count = 0;\n+\tesucc->count = 0;\n       dup->count = 0;\n     }\n }\n@@ -1128,7 +1128,7 @@ ssa_fix_duplicate_block_edges (struct redirection_data *rd,\n      to see if the paths through RD are using estimated frequencies because\n      the routine had zero profile counts.  */\n   bool do_freqs_to_counts = (profile_status_for_fn (cfun) != PROFILE_READ\n-                             || estimated_freqs_path (rd));\n+\t\t\t     || estimated_freqs_path (rd));\n   if (do_freqs_to_counts)\n     freqs_to_counts_path (rd);\n \n@@ -1139,8 +1139,8 @@ ssa_fix_duplicate_block_edges (struct redirection_data *rd,\n      non-joiner case the path_in_count and path_out_count should be the\n      same.  */\n   bool has_joiner = compute_path_counts (rd, local_info,\n-                                         &path_in_count, &path_out_count,\n-                                         &path_in_freq);\n+\t\t\t\t\t &path_in_count, &path_out_count,\n+\t\t\t\t\t &path_in_freq);\n \n   int cur_path_freq = path_in_freq;\n   for (unsigned int count = 0, i = 1; i < path->length (); i++)\n@@ -1156,7 +1156,7 @@ ssa_fix_duplicate_block_edges (struct redirection_data *rd,\n \t  edge victim;\n \t  edge e2;\n \n-          gcc_assert (has_joiner);\n+\t  gcc_assert (has_joiner);\n \n \t  /* This updates the PHIs at the destination of the duplicate\n \t     block.  Pass 0 instead of i if we are threading a path which\n@@ -1221,7 +1221,7 @@ ssa_fix_duplicate_block_edges (struct redirection_data *rd,\n \t  /* Next we need to update the counts of the original and duplicated\n \t     edges from the joiner that go off path.  */\n \t  update_joiner_offpath_counts (epath, e2->src, path_in_count,\n-                                        path_out_count);\n+\t\t\t\t\tpath_out_count);\n \n \t  /* Finally, we need to set the probabilities on the duplicated\n \t     edges out of the duplicated joiner (e2->src).  The probabilities\n@@ -1255,7 +1255,7 @@ ssa_fix_duplicate_block_edges (struct redirection_data *rd,\n \t\t\t  cur_path_freq);\n \t}\n       else\n-        {\n+\t{\n \t  /* No copy case.  In this case we don't have an equivalent block\n \t     on the duplicated thread path to update, but we do need\n \t     to remove the portion of the counts/freqs that were moved\n@@ -1274,9 +1274,9 @@ ssa_fix_duplicate_block_edges (struct redirection_data *rd,\n \t}\n \n       /* Increment the index into the duplicated path when we processed\n-         a duplicated block.  */\n+\t a duplicated block.  */\n       if ((*path)[i]->type == EDGE_COPY_SRC_JOINER_BLOCK\n-          || (*path)[i]->type == EDGE_COPY_SRC_BLOCK)\n+\t  || (*path)[i]->type == EDGE_COPY_SRC_BLOCK)\n       {\n \t  count++;\n       }\n@@ -1320,7 +1320,7 @@ ssa_create_duplicates (struct redirection_data **slot,\n \t  || (*path)[i]->type == EDGE_COPY_SRC_JOINER_BLOCK)\n \t{\n \t  create_block_for_threading ((*path)[i]->e->src, rd, 1,\n-                                      &local_info->duplicate_blocks);\n+\t\t\t\t      &local_info->duplicate_blocks);\n \t  break;\n \t}\n     }\n@@ -1330,7 +1330,7 @@ ssa_create_duplicates (struct redirection_data **slot,\n   if (local_info->template_block == NULL)\n     {\n       create_block_for_threading ((*path)[1]->e->src, rd, 0,\n-                                  &local_info->duplicate_blocks);\n+\t\t\t\t  &local_info->duplicate_blocks);\n       local_info->template_block = rd->dup_blocks[0];\n \n       /* We do not create any outgoing edges for the template.  We will\n@@ -1340,7 +1340,7 @@ ssa_create_duplicates (struct redirection_data **slot,\n   else\n     {\n       create_block_for_threading (local_info->template_block, rd, 0,\n-                                  &local_info->duplicate_blocks);\n+\t\t\t\t  &local_info->duplicate_blocks);\n \n       /* Go ahead and wire up outgoing edges and update PHIs for the duplicate\n \t block.   */\n@@ -2156,20 +2156,20 @@ mark_threaded_blocks (bitmap threaded_blocks)\n       vec<jump_thread_edge *> *path = paths[i];\n \n       if ((*path)[1]->type == EDGE_COPY_SRC_JOINER_BLOCK)\n-        {\n+\t{\n \t  /* Attach the path to the starting edge if none is yet recorded.  */\n-          if ((*path)[0]->e->aux == NULL)\n+\t  if ((*path)[0]->e->aux == NULL)\n \t    {\n-              (*path)[0]->e->aux = path;\n+\t      (*path)[0]->e->aux = path;\n \t    }\n \t  else\n \t    {\n \t      paths.unordered_remove (i);\n \t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t        dump_jump_thread_path (dump_file, *path, false);\n+\t\tdump_jump_thread_path (dump_file, *path, false);\n \t      delete_jump_thread_path (path);\n \t    }\n-        }\n+\t}\n     }\n   /* Second, look for paths that have any other jump thread attached to\n      them, and either finish converting them or cancel them.  */\n@@ -2194,7 +2194,7 @@ mark_threaded_blocks (bitmap threaded_blocks)\n \t      e->aux = NULL;\n \t      paths.unordered_remove (i);\n \t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t        dump_jump_thread_path (dump_file, *path, false);\n+\t\tdump_jump_thread_path (dump_file, *path, false);\n \t      delete_jump_thread_path (path);\n \t    }\n \t}\n@@ -2714,13 +2714,13 @@ thread_through_all_blocks (bool may_peel_loop_headers)\n \t\t    }\n \n \t\t/* Our path is still valid, thread it.  */\n-\t        if (e->aux)\n+\t\tif (e->aux)\n \t\t  {\n \t\t    if (thread_block ((*path)[0]->e->dest, false))\n \t\t      e->aux = NULL;\n \t\t    else\n \t\t      {\n-\t\t        delete_jump_thread_path (path);\n+\t\t\tdelete_jump_thread_path (path);\n \t\t\te->aux = NULL;\n \t\t\tei_next (&ei);\n \t\t      }"}]}