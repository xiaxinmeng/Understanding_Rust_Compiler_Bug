{"sha": "a1023434a8dd3ce2281a726d30ef370caa425252", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTEwMjM0MzRhOGRkM2NlMjI4MWE3MjZkMzBlZjM3MGNhYTQyNTI1Mg==", "commit": {"author": {"name": "Justin Squirek", "email": "squirek@adacore.com", "date": "2020-11-16T14:08:51Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-12-15T11:41:56Z"}, "message": "[Ada] Postcondition checks performed before finalization\n\ngcc/ada/\n\n\t* contracts.adb, contracts.ads (Build_Postconditions_Procedure):\n\tAdd declarations for Postcond_Enabled,\n\tResult_Object_For_Postcondition, and\n\tReturn_Success_For_Postcond, and place all postconditions within\n\tan if statement to control their execution for interactions when\n\tcleanup actions get generated.\n\t(Get_Postcond_Enabled): Created to fetch object declared to\n\thandle new expansion of postconditions.\n\t(Get_Result_Object_For_Postcond): Created to fetch object\n\tdeclared to handle new expansion of postconditions.\n\t(Get_Return_Success_For_Postcond): Created to fetch object\n\tdeclared to handle new expansion of postconditions.\n\t* einfo.adb, einfo.ads: Modify flag Stores_Attribute_Old_Prefix\n\tto apply to constants, variables, and types.\n\t* exp_ch6.adb (Add_Return): Add assignment to\n\tReturn_Success_For_Postcond.\n\t(Expand_Non_Function_Return): Add assignment to\n\tReturn_Success_For_Postcond\n\t(Expand_Simple_Function_Return): Add assignment to\n\tResult_Object_For_Postcond and Return_Success_For_Postcond.\n\t* exp_ch7.adb (Build_Finalization_Master): Mark finalization\n\tmasters which finalize types created store 'Old objects as\n\tstoring 'Old objects.\n\t(Build_Finalizer): Created to generated a unified and special\n\texpansion for finalization when postconditions are present.\n\t(Build_Finalizer_Helper): Renamed Build_Finalizer and added\n\tparameter to facilitate the creation of separate finalization\n\troutines for 'Old objects and general objects.\n\t(Create_Finalizer): Add condition for the insertion of the\n\tfinalizer spec to avoid malformed trees.\n\t(Expand_Cleanup_Actions): Move _postconditions and related\n\tdeclarations to the new declarative section.  Fix the loop to\n\tproperly stop at the subprogram declaration for the\n\tpostconditions procedure and exclude its body from being moved\n\tto the new list of declarations to avoid freezing issues.\n\t* exp_prag.adb (Expand_Attributes): Mark temporary created to\n\tstore 'Old objects as storing a 'Old attribute.\n\t* sem_ch6.adb (Find_What_Applies_To): Remove strange exception\n\tto postconditions when traversing the scope stack.\n\t* sem_prag.adb (Find_Related_Declaration_Or_Body): Use the newly\n\tcreated Enclosing_HSS function to find the HSS for a potentially\n\tnested statement.\n\t* sem_util.adb, sem_util.ads (Declare_Indirect_Temp): Mark types\n\tcreated to store 'Old objects as storing 'Old attributes.\n\t(Enclosing_HSS): Created to find the enclosing handled sequence\n\tof statements for a given statement.\n\t* snames.ads-tmpl: Add multiple names to aid in the expansion of\n\tfinalization and to control the evaluation of postconditions.\n\tIncluding _finalization_controller, a new routine to centralize\n\tfinalization actions and postcondition evaluation.", "tree": {"sha": "96879e168c070a781a22b5670da318bf9bf47143", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/96879e168c070a781a22b5670da318bf9bf47143"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a1023434a8dd3ce2281a726d30ef370caa425252", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1023434a8dd3ce2281a726d30ef370caa425252", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1023434a8dd3ce2281a726d30ef370caa425252", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1023434a8dd3ce2281a726d30ef370caa425252/comments", "author": {"login": "AdaDoom3", "id": 3445599, "node_id": "MDQ6VXNlcjM0NDU1OTk=", "avatar_url": "https://avatars.githubusercontent.com/u/3445599?v=4", "gravatar_id": "", "url": "https://api.github.com/users/AdaDoom3", "html_url": "https://github.com/AdaDoom3", "followers_url": "https://api.github.com/users/AdaDoom3/followers", "following_url": "https://api.github.com/users/AdaDoom3/following{/other_user}", "gists_url": "https://api.github.com/users/AdaDoom3/gists{/gist_id}", "starred_url": "https://api.github.com/users/AdaDoom3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/AdaDoom3/subscriptions", "organizations_url": "https://api.github.com/users/AdaDoom3/orgs", "repos_url": "https://api.github.com/users/AdaDoom3/repos", "events_url": "https://api.github.com/users/AdaDoom3/events{/privacy}", "received_events_url": "https://api.github.com/users/AdaDoom3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "43852482cafa73da6408120722dcbe7ff6fd3ded", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43852482cafa73da6408120722dcbe7ff6fd3ded", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43852482cafa73da6408120722dcbe7ff6fd3ded"}], "stats": {"total": 1062, "additions": 998, "deletions": 64}, "files": [{"sha": "29557eca54f0be543f2fb16f17ece20239b1a1fe", "filename": "gcc/ada/contracts.adb", "status": "modified", "additions": 237, "deletions": 4, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1023434a8dd3ce2281a726d30ef370caa425252/gcc%2Fada%2Fcontracts.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1023434a8dd3ce2281a726d30ef370caa425252/gcc%2Fada%2Fcontracts.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcontracts.adb?ref=a1023434a8dd3ce2281a726d30ef370caa425252", "patch": "@@ -2198,19 +2198,54 @@ package body Contracts is\n          Result  : Entity_Id)\n       is\n          Loc       : constant Source_Ptr := Sloc (Body_Decl);\n+         Last_Decl : Node_Id;\n          Params    : List_Id := No_List;\n          Proc_Bod  : Node_Id;\n          Proc_Decl : Node_Id;\n          Proc_Id   : Entity_Id;\n          Proc_Spec : Node_Id;\n \n+         --  Extra declarations needed to handle interactions between\n+         --  postconditions and finalization.\n+\n+         Postcond_Enabled_Decl : Node_Id;\n+         Return_Success_Decl   : Node_Id;\n+         Result_Obj_Decl       : Node_Id;\n+         Result_Obj_Type_Decl  : Node_Id;\n+         Result_Obj_Type       : Entity_Id;\n+\n+      --  Start of processing for Build_Postconditions_Procedure\n+\n       begin\n          --  Nothing to do if there are no actions to check on exit\n \n          if No (Stmts) then\n             return;\n          end if;\n \n+         --  Otherwise, we generate the postcondition procedure and add\n+         --  associated objects and conditions used to coordinate postcondition\n+         --  evaluation with finalization.\n+\n+         --  Generate:\n+         --\n+         --    procedure _postconditions (Return_Exp : Result_Typ);\n+         --\n+         --    --  Result_Obj_Type created when Result_Type is non-elementary\n+         --    [type Result_Obj_Type is access all Result_Typ;]\n+         --\n+         --    Result_Obj : Result_Obj_Type;\n+         --\n+         --    Postcond_Enabled            : Boolean := True;\n+         --    Return_Success_For_Postcond : Boolean := False;\n+         --\n+         --    procedure _postconditions (Return_Exp : Result_Typ) is\n+         --    begin\n+         --       if Postcond_Enabled and then Return_Success_For_Postcond then\n+         --          [stmts];\n+         --       end if;\n+         --    end;\n+\n          Proc_Id := Make_Defining_Identifier (Loc, Name_uPostconditions);\n          Set_Debug_Info_Needed   (Proc_Id);\n          Set_Postconditions_Proc (Subp_Id, Proc_Id);\n@@ -2248,12 +2283,14 @@ package body Contracts is\n          --  body. This ensures that the body will not cause any premature\n          --  freezing, as it may mention types:\n \n+         --  Generate:\n+         --\n          --    procedure Proc (Obj : Array_Typ) is\n          --       procedure _postconditions is\n          --       begin\n          --          ... Obj ...\n          --       end _postconditions;\n-\n+         --\n          --       subtype T is Array_Typ (Obj'First (1) .. Obj'Last (1));\n          --    begin\n \n@@ -2265,23 +2302,144 @@ package body Contracts is\n          Insert_Before_First_Source_Declaration\n            (Proc_Decl, Declarations (Body_Decl));\n          Analyze (Proc_Decl);\n+         Last_Decl := Proc_Decl;\n+\n+         --  When Result is present (e.g. the postcondition checks apply to a\n+         --  function) we make a local object to capture the result, so, if\n+         --  needed, we can call the generated postconditions procedure during\n+         --  finalization instead of at the point of return.\n+\n+         --  Note: The placement of the following declarations before the\n+         --  declaration of the body of the postconditions, but after the\n+         --  declaration of the postconditions spec is deliberate and required\n+         --  since other code within the expander expects them to be located\n+         --  here. Perhaps when more space is available in the tree this will\n+         --  no longer be necessary ???\n+\n+         if Present (Result) then\n+            --  Elementary result types mean a copy is cheap and preferred over\n+            --  using pointers.\n+\n+            if Is_Elementary_Type (Etype (Result)) then\n+               Result_Obj_Type := Etype (Result);\n+\n+            --  Otherwise, we create a named access type to capture the result\n+\n+            --  Generate:\n+            --\n+            --  type Result_Obj_Type is access all [Result_Type];\n+\n+            else\n+               Result_Obj_Type := Make_Temporary (Loc, 'R');\n+\n+               Result_Obj_Type_Decl :=\n+                 Make_Full_Type_Declaration (Loc,\n+                   Defining_Identifier => Result_Obj_Type,\n+                   Type_Definition     =>\n+                     Make_Access_To_Object_Definition (Loc,\n+                       All_Present        => True,\n+                       Subtype_Indication => New_Occurrence_Of\n+                                               (Etype (Result), Loc)));\n+               Insert_After_And_Analyze (Proc_Decl, Result_Obj_Type_Decl);\n+               Last_Decl := Result_Obj_Type_Decl;\n+            end if;\n+\n+            --  Create the result obj declaration\n+\n+            --  Generate:\n+            --\n+            --  Result_Object_For_Postcond : Result_Obj_Type;\n+\n+            Result_Obj_Decl :=\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier =>\n+                  Make_Defining_Identifier\n+                    (Loc, Name_uResult_Object_For_Postcond),\n+                Object_Definition   =>\n+                  New_Occurrence_Of\n+                    (Result_Obj_Type, Loc));\n+            Set_No_Initialization (Result_Obj_Decl);\n+            Insert_After_And_Analyze (Last_Decl, Result_Obj_Decl);\n+            Last_Decl := Result_Obj_Decl;\n+         end if;\n+\n+         --  Build the Postcond_Enabled flag used to delay evaluation of\n+         --  postconditions until finalization has been performed when cleanup\n+         --  actions are present.\n+\n+         --  Generate:\n+         --\n+         --    Postcond_Enabled : Boolean := True;\n+\n+         Postcond_Enabled_Decl :=\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier =>\n+               Make_Defining_Identifier\n+                 (Loc, Name_uPostcond_Enabled),\n+             Object_Definition   => New_Occurrence_Of (Standard_Boolean, Loc),\n+             Expression          => New_Occurrence_Of (Standard_True, Loc));\n+         Insert_After_And_Analyze (Last_Decl, Postcond_Enabled_Decl);\n+         Last_Decl := Postcond_Enabled_Decl;\n+\n+         --  Create a flag to indicate that return has been reached\n+\n+         --  This is necessary for deciding whether to execute _postconditions\n+         --  during finalization.\n+\n+         --  Generate:\n+         --\n+         --    Return_Success_For_Postcond : Boolean := False;\n+\n+         Return_Success_Decl :=\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier =>\n+               Make_Defining_Identifier\n+                 (Loc, Name_uReturn_Success_For_Postcond),\n+             Object_Definition   => New_Occurrence_Of (Standard_Boolean, Loc),\n+             Expression          => New_Occurrence_Of (Standard_False, Loc));\n+         Insert_After_And_Analyze (Last_Decl, Return_Success_Decl);\n+         Last_Decl := Return_Success_Decl;\n \n          --  Set an explicit End_Label to override the sloc of the implicit\n          --  RETURN statement, and prevent it from inheriting the sloc of one\n          --  the postconditions: this would cause confusing debug info to be\n          --  produced, interfering with coverage-analysis tools.\n \n+         --  Also, wrap the postcondition checks in a conditional which can be\n+         --  used to delay their evaluation when clean-up actions are present.\n+\n+         --  Generate:\n+         --\n+         --    procedure _postconditions is\n+         --    begin\n+         --       if Postcond_Enabled and then Return_Success_For_Postcond then\n+         --          [Stmts];\n+         --       end if;\n+         --    end;\n+\n          Proc_Bod :=\n            Make_Subprogram_Body (Loc,\n              Specification              =>\n                Copy_Subprogram_Spec (Proc_Spec),\n              Declarations               => Empty_List,\n              Handled_Statement_Sequence =>\n                Make_Handled_Sequence_Of_Statements (Loc,\n-                 Statements => Stmts,\n-                 End_Label  => Make_Identifier (Loc, Chars (Proc_Id))));\n+                 End_Label  => Make_Identifier (Loc, Chars (Proc_Id)),\n+                 Statements => New_List (\n+                   Make_If_Statement (Loc,\n+                     Condition      =>\n+                       Make_And_Then (Loc,\n+                         Left_Opnd  =>\n+                           New_Occurrence_Of\n+                             (Defining_Identifier\n+                               (Postcond_Enabled_Decl), Loc),\n+                         Right_Opnd =>\n+                           New_Occurrence_Of\n+                             (Defining_Identifier\n+                               (Return_Success_Decl), Loc)),\n+                      Then_Statements => Stmts))));\n+         Insert_After_And_Analyze (Last_Decl, Proc_Bod);\n \n-         Insert_After_And_Analyze (Proc_Decl, Proc_Bod);\n       end Build_Postconditions_Procedure;\n \n       ----------------------------\n@@ -3280,6 +3438,81 @@ package body Contracts is\n       Freeze_Contracts;\n    end Freeze_Previous_Contracts;\n \n+   --------------------------\n+   -- Get_Postcond_Enabled --\n+   --------------------------\n+\n+   function Get_Postcond_Enabled (Subp : Entity_Id) return Node_Id is\n+      Decl : Node_Id;\n+   begin\n+      Decl :=\n+        Next (Unit_Declaration_Node (Postconditions_Proc (Subp)));\n+      while Present (Decl) loop\n+\n+         if Nkind (Decl) = N_Object_Declaration\n+          and then Chars (Defining_Identifier (Decl))\n+                     = Name_uPostcond_Enabled\n+         then\n+            return Defining_Identifier (Decl);\n+         end if;\n+\n+         Next (Decl);\n+      end loop;\n+\n+      return Empty;\n+   end Get_Postcond_Enabled;\n+\n+   ------------------------------------\n+   -- Get_Result_Object_For_Postcond --\n+   ------------------------------------\n+\n+   function Get_Result_Object_For_Postcond\n+     (Subp : Entity_Id) return Node_Id\n+   is\n+      Decl : Node_Id;\n+   begin\n+      Decl :=\n+        Next (Unit_Declaration_Node (Postconditions_Proc (Subp)));\n+      while Present (Decl) loop\n+\n+         if Nkind (Decl) = N_Object_Declaration\n+           and then Chars (Defining_Identifier (Decl))\n+                      = Name_uResult_Object_For_Postcond\n+         then\n+            return Defining_Identifier (Decl);\n+         end if;\n+\n+         Next (Decl);\n+      end loop;\n+\n+      return Empty;\n+   end Get_Result_Object_For_Postcond;\n+\n+   -------------------------------------\n+   -- Get_Return_Success_For_Postcond --\n+   -------------------------------------\n+\n+   function Get_Return_Success_For_Postcond (Subp : Entity_Id) return Node_Id\n+   is\n+      Decl : Node_Id;\n+   begin\n+      Decl :=\n+        Next (Unit_Declaration_Node (Postconditions_Proc (Subp)));\n+      while Present (Decl) loop\n+\n+         if Nkind (Decl) = N_Object_Declaration\n+          and then Chars (Defining_Identifier (Decl))\n+                     = Name_uReturn_Success_For_Postcond\n+         then\n+            return Defining_Identifier (Decl);\n+         end if;\n+\n+         Next (Decl);\n+      end loop;\n+\n+      return Empty;\n+   end Get_Return_Success_For_Postcond;\n+\n    ---------------------------------\n    -- Inherit_Subprogram_Contract --\n    ---------------------------------"}, {"sha": "b8a12ffd58ab13de509e72f33e4fd41a2d84bbc3", "filename": "gcc/ada/contracts.ads", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1023434a8dd3ce2281a726d30ef370caa425252/gcc%2Fada%2Fcontracts.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1023434a8dd3ce2281a726d30ef370caa425252/gcc%2Fada%2Fcontracts.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcontracts.ads?ref=a1023434a8dd3ce2281a726d30ef370caa425252", "patch": "@@ -188,6 +188,21 @@ package Contracts is\n    --  denoted by Body_Decl. In addition, freeze the contract of the nearest\n    --  enclosing package body.\n \n+   function Get_Postcond_Enabled (Subp : Entity_Id) return Entity_Id;\n+   --  Get the defining identifier for a subprogram's Postcond_Enabled\n+   --  object created during the expansion of the subprogram's postconditions.\n+\n+   function Get_Result_Object_For_Postcond (Subp : Entity_Id) return Entity_Id;\n+   --  Get the defining identifier for a subprogram's\n+   --  Result_Object_For_Postcond object created during the expansion of the\n+   --  subprogram's postconditions.\n+\n+   function Get_Return_Success_For_Postcond\n+     (Subp : Entity_Id) return Entity_Id;\n+   --  Get the defining identifier for a subprogram's\n+   --  Return_Success_For_Postcond object created during the expansion of the\n+   --  subprogram's postconditions.\n+\n    procedure Inherit_Subprogram_Contract\n      (Subp      : Entity_Id;\n       From_Subp : Entity_Id);"}, {"sha": "8c401ca0c6a6cf5f3acd3e117ef1f333381ce896", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1023434a8dd3ce2281a726d30ef370caa425252/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1023434a8dd3ce2281a726d30ef370caa425252/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=a1023434a8dd3ce2281a726d30ef370caa425252", "patch": "@@ -6802,7 +6802,9 @@ package body Einfo is\n \n    procedure Set_Stores_Attribute_Old_Prefix (Id : E; V : B := True) is\n    begin\n-      pragma Assert (Ekind (Id) = E_Constant);\n+      pragma Assert (Is_Type (Id)\n+                      or else (Ekind (Id) in E_Constant\n+                                           | E_Variable));\n       Set_Flag270 (Id, V);\n    end Set_Stores_Attribute_Old_Prefix;\n "}, {"sha": "cc0c815186ee1dd119db10bb259c390f63b10cf1", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1023434a8dd3ce2281a726d30ef370caa425252/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1023434a8dd3ce2281a726d30ef370caa425252/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=a1023434a8dd3ce2281a726d30ef370caa425252", "patch": "@@ -4503,8 +4503,8 @@ package Einfo is\n --       stored discriminants for the record (sub)type.\n \n --    Stores_Attribute_Old_Prefix (Flag270)\n---       Defined in constants. Set when the constant has been generated to save\n---       the value of attribute 'Old's prefix.\n+--       Defined in constants, variables, and types which are created during\n+--       expansion in order to save the value of attribute 'Old's prefix.\n \n --    Strict_Alignment (Flag145) [implementation base type only]\n --       Defined in all type entities. Indicates that the type is by-reference"}, {"sha": "afe7e8ba63e1f19d26250be30fe7892f5e0a12fc", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1023434a8dd3ce2281a726d30ef370caa425252/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1023434a8dd3ce2281a726d30ef370caa425252/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=a1023434a8dd3ce2281a726d30ef370caa425252", "patch": "@@ -6246,9 +6246,24 @@ package body Exp_Ch6 is\n             --  Call the _Postconditions procedure if the related subprogram\n             --  has contract assertions that need to be verified on exit.\n \n+            --  Also, mark the successful return to signal that postconditions\n+            --  need to be evaluated when finalization occurs.\n+\n             if Ekind (Spec_Id) = E_Procedure\n               and then Present (Postconditions_Proc (Spec_Id))\n             then\n+               --  Generate:\n+               --\n+               --    Return_Success_For_Postcond := True;\n+               --    _postconditions;\n+\n+               Insert_Action (Stmt,\n+                 Make_Assignment_Statement (Loc,\n+                   Name       =>\n+                     New_Occurrence_Of\n+                      (Get_Return_Success_For_Postcond (Spec_Id), Loc),\n+                   Expression => New_Occurrence_Of (Standard_True, Loc)));\n+\n                Insert_Action (Stmt,\n                  Make_Procedure_Call_Statement (Loc,\n                    Name =>\n@@ -6676,9 +6691,24 @@ package body Exp_Ch6 is\n       --  Call the _Postconditions procedure if the related subprogram has\n       --  contract assertions that need to be verified on exit.\n \n+      --  Also, mark the successful return to signal that postconditions need\n+      --  to be evaluated when finalization occurs.\n+\n       if Ekind (Scope_Id) in E_Entry | E_Entry_Family | E_Procedure\n         and then Present (Postconditions_Proc (Scope_Id))\n       then\n+         --  Generate:\n+         --\n+         --    Return_Success_For_Postcond := True;\n+         --    _postconditions;\n+\n+         Insert_Action (N,\n+           Make_Assignment_Statement (Loc,\n+             Name       =>\n+               New_Occurrence_Of\n+                (Get_Return_Success_For_Postcond (Scope_Id), Loc),\n+             Expression => New_Occurrence_Of (Standard_True, Loc)));\n+\n          Insert_Action (N,\n            Make_Procedure_Call_Statement (Loc,\n              Name => New_Occurrence_Of (Postconditions_Proc (Scope_Id), Loc)));\n@@ -7565,6 +7595,41 @@ package body Exp_Ch6 is\n \n          Force_Evaluation (Exp, Mode => Strict);\n \n+         --  Save the return value or a pointer to the return value since we\n+         --  may need to call postconditions after finalization when cleanup\n+         --  actions are present.\n+\n+         --  Generate:\n+         --\n+         --    Result_Object_For_Postcond := [Exp]'Unrestricted_Access;\n+\n+         Insert_Action (Exp,\n+           Make_Assignment_Statement (Loc,\n+             Name       =>\n+               New_Occurrence_Of\n+                (Get_Result_Object_For_Postcond (Scope_Id), Loc),\n+             Expression =>\n+               (if Is_Elementary_Type (Etype (R_Type)) then\n+                   New_Copy_Tree (Exp)\n+                else\n+                   Make_Attribute_Reference (Loc,\n+                     Attribute_Name => Name_Unrestricted_Access,\n+                     Prefix         => New_Copy_Tree (Exp)))));\n+\n+         --  Mark the successful return to signal that postconditions need to\n+         --  be evaluated when finalization occurs.\n+\n+         --  Generate:\n+         --\n+         --    Return_Success_For_Postcond := True;\n+\n+         Insert_Action (Exp,\n+           Make_Assignment_Statement (Loc,\n+             Name       =>\n+               New_Occurrence_Of\n+                (Get_Return_Success_For_Postcond (Scope_Id), Loc),\n+             Expression => New_Occurrence_Of (Standard_True, Loc)));\n+\n          --  Generate call to _Postconditions\n \n          Insert_Action (Exp,"}, {"sha": "43920993ff997cf2943aca2db1a928a1918f2943", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 615, "deletions": 49, "changes": 664, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1023434a8dd3ce2281a726d30ef370caa425252/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1023434a8dd3ce2281a726d30ef370caa425252/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=a1023434a8dd3ce2281a726d30ef370caa425252", "patch": "@@ -27,42 +27,43 @@\n --    - controlled types\n --    - transient scopes\n \n-with Atree;    use Atree;\n-with Debug;    use Debug;\n-with Einfo;    use Einfo;\n-with Elists;   use Elists;\n-with Errout;   use Errout;\n-with Exp_Ch6;  use Exp_Ch6;\n-with Exp_Ch9;  use Exp_Ch9;\n-with Exp_Ch11; use Exp_Ch11;\n-with Exp_Dbug; use Exp_Dbug;\n-with Exp_Dist; use Exp_Dist;\n-with Exp_Disp; use Exp_Disp;\n-with Exp_Prag; use Exp_Prag;\n-with Exp_Tss;  use Exp_Tss;\n-with Exp_Util; use Exp_Util;\n-with Freeze;   use Freeze;\n-with Lib;      use Lib;\n-with Nlists;   use Nlists;\n-with Nmake;    use Nmake;\n-with Opt;      use Opt;\n-with Output;   use Output;\n-with Restrict; use Restrict;\n-with Rident;   use Rident;\n-with Rtsfind;  use Rtsfind;\n-with Sinfo;    use Sinfo;\n-with Sem;      use Sem;\n-with Sem_Aux;  use Sem_Aux;\n-with Sem_Ch3;  use Sem_Ch3;\n-with Sem_Ch7;  use Sem_Ch7;\n-with Sem_Ch8;  use Sem_Ch8;\n-with Sem_Res;  use Sem_Res;\n-with Sem_Util; use Sem_Util;\n-with Snames;   use Snames;\n-with Stand;    use Stand;\n-with Tbuild;   use Tbuild;\n-with Ttypes;   use Ttypes;\n-with Uintp;    use Uintp;\n+with Atree;     use Atree;\n+with Contracts; use Contracts;\n+with Debug;     use Debug;\n+with Einfo;     use Einfo;\n+with Elists;    use Elists;\n+with Errout;    use Errout;\n+with Exp_Ch6;   use Exp_Ch6;\n+with Exp_Ch9;   use Exp_Ch9;\n+with Exp_Ch11;  use Exp_Ch11;\n+with Exp_Dbug;  use Exp_Dbug;\n+with Exp_Dist;  use Exp_Dist;\n+with Exp_Disp;  use Exp_Disp;\n+with Exp_Prag;  use Exp_Prag;\n+with Exp_Tss;   use Exp_Tss;\n+with Exp_Util;  use Exp_Util;\n+with Freeze;    use Freeze;\n+with Lib;       use Lib;\n+with Nlists;    use Nlists;\n+with Nmake;     use Nmake;\n+with Opt;       use Opt;\n+with Output;    use Output;\n+with Restrict;  use Restrict;\n+with Rident;    use Rident;\n+with Rtsfind;   use Rtsfind;\n+with Sinfo;     use Sinfo;\n+with Sem;       use Sem;\n+with Sem_Aux;   use Sem_Aux;\n+with Sem_Ch3;   use Sem_Ch3;\n+with Sem_Ch7;   use Sem_Ch7;\n+with Sem_Ch8;   use Sem_Ch8;\n+with Sem_Res;   use Sem_Res;\n+with Sem_Util;  use Sem_Util;\n+with Snames;    use Snames;\n+with Stand;     use Stand;\n+with Tbuild;    use Tbuild;\n+with Ttypes;    use Ttypes;\n+with Uintp;     use Uintp;\n \n package body Exp_Ch7 is\n \n@@ -339,6 +340,17 @@ package body Exp_Ch7 is\n    --  such as for task termination. Fin_Id is the finalizer declaration\n    --  entity.\n \n+   procedure Build_Finalizer_Helper\n+     (N                 : Node_Id;\n+      Clean_Stmts       : List_Id;\n+      Mark_Id           : Entity_Id;\n+      Top_Decls         : List_Id;\n+      Defer_Abort       : Boolean;\n+      Fin_Id            : out Entity_Id;\n+      Finalize_Old_Only : Boolean);\n+   --  An internal routine which does all of the heavy lifting on behalf of\n+   --  Build_Finalizer.\n+\n    procedure Build_Finalizer_Call (N : Node_Id; Fin_Id : Entity_Id);\n    --  N is a construct which contains a handled sequence of statements, Fin_Id\n    --  is the entity of a finalizer. Create an At_End handler which covers the\n@@ -1397,20 +1409,32 @@ package body Exp_Ch7 is\n          else\n             Append_Freeze_Actions (Ptr_Typ, Actions);\n          end if;\n+\n+         Analyze_List (Actions);\n+\n+         --  When the type the finalization master is being generated for was\n+         --  created to store a 'Old object, then mark it as such so its\n+         --  finalization can be delayed until after postconditions have been\n+         --  checked.\n+\n+         if Stores_Attribute_Old_Prefix (Ptr_Typ) then\n+            Set_Stores_Attribute_Old_Prefix (Fin_Mas_Id);\n+         end if;\n       end;\n    end Build_Finalization_Master;\n \n-   ---------------------\n-   -- Build_Finalizer --\n-   ---------------------\n+   ----------------------------\n+   -- Build_Finalizer_Helper --\n+   ----------------------------\n \n-   procedure Build_Finalizer\n+   procedure Build_Finalizer_Helper\n      (N                 : Node_Id;\n       Clean_Stmts       : List_Id;\n       Mark_Id           : Entity_Id;\n       Top_Decls         : List_Id;\n       Defer_Abort       : Boolean;\n-      Fin_Id            : out Entity_Id)\n+      Fin_Id            : out Entity_Id;\n+      Finalize_Old_Only : Boolean)\n    is\n       Acts_As_Clean    : constant Boolean :=\n                            Present (Mark_Id)\n@@ -1746,9 +1770,20 @@ package body Exp_Ch7 is\n          --  The default name is _finalizer\n \n          else\n-            Fin_Id :=\n-              Make_Defining_Identifier (Loc,\n-                Chars => New_External_Name (Name_uFinalizer));\n+            --  Generation of a finalization procedure exclusively for 'Old\n+            --  interally generated constants requires different name since\n+            --  there will need to be multiple finalization routines in the\n+            --  same scope. See Build_Finalizer for details.\n+\n+            if Finalize_Old_Only then\n+               Fin_Id :=\n+                 Make_Defining_Identifier (Loc,\n+                   Chars => New_External_Name (Name_uFinalizer_Old));\n+            else\n+               Fin_Id :=\n+                 Make_Defining_Identifier (Loc,\n+                   Chars => New_External_Name (Name_uFinalizer));\n+            end if;\n \n             --  The visibility semantics of AT_END handlers force a strange\n             --  separation of spec and body for stack-related finalizers:\n@@ -2051,8 +2086,26 @@ package body Exp_Ch7 is\n \n             pragma Assert (Present (Spec_Decls));\n \n-            Append_To (Spec_Decls, Fin_Spec);\n-            Analyze (Fin_Spec);\n+            --  It maybe possible that we are finalizing 'Old objects which\n+            --  exist in the spec declarations. When this is the case the\n+            --  Finalizer_Insert_Node will come before the end of the\n+            --  Spec_Decls. So, to mitigate this, we insert the finalizer spec\n+            --  earlier at the Finalizer_Insert_Nod instead of appending to the\n+            --  end of Spec_Decls to prevent its body appearing before its\n+            --  corresponding spec.\n+\n+            if Present (Finalizer_Insert_Nod)\n+              and then List_Containing (Finalizer_Insert_Nod) = Spec_Decls\n+            then\n+               Insert_After_And_Analyze (Finalizer_Insert_Nod, Fin_Spec);\n+               Finalizer_Insert_Nod := Fin_Spec;\n+\n+            --  Otherwise, Finalizer_Insert_Nod is not in Spec_Decls\n+\n+            else\n+               Append_To (Spec_Decls, Fin_Spec);\n+               Analyze (Fin_Spec);\n+            end if;\n \n             --  When the finalizer acts solely as a cleanup routine, the body\n             --  is inserted right after the spec.\n@@ -2194,9 +2247,26 @@ package body Exp_Ch7 is\n \n          Decl := Last_Non_Pragma (Decls);\n          while Present (Decl) loop\n+            --  Depending on the value of flag Finalize_Old_Only we determine\n+            --  which objects get finalized as part of the current finalizer\n+            --  being built.\n+\n+            --  When True, only temporaries capturing the value of attribute\n+            --  'Old are finalized and all other cases are ignored.\n+\n+            --  When False, temporary objects used to capture the value of 'Old\n+            --  are ignored and all others are considered.\n+\n+            if Finalize_Old_Only\n+                 xor (Nkind (Decl) = N_Object_Declaration\n+                       and then Stores_Attribute_Old_Prefix\n+                                  (Defining_Identifier (Decl)))\n+            then\n+               null;\n+\n             --  Library-level tagged types\n \n-            if Nkind (Decl) = N_Full_Type_Declaration then\n+            elsif Nkind (Decl) = N_Full_Type_Declaration then\n                Typ := Defining_Identifier (Decl);\n \n                --  Ignored Ghost types do not need any cleanup actions because\n@@ -3409,7 +3479,7 @@ package body Exp_Ch7 is\n                New_Occurrence_Of (DT_Ptr, Loc))));\n       end Process_Tagged_Type_Declaration;\n \n-   --  Start of processing for Build_Finalizer\n+   --  Start of processing for Build_Finalizer_Helper\n \n    begin\n       Fin_Id := Empty;\n@@ -3559,7 +3629,7 @@ package body Exp_Ch7 is\n       if Acts_As_Clean or else Has_Ctrl_Objs or else Has_Tagged_Types then\n          Create_Finalizer;\n       end if;\n-   end Build_Finalizer;\n+   end Build_Finalizer_Helper;\n \n    --------------------------\n    -- Build_Finalizer_Call --\n@@ -3642,6 +3712,468 @@ package body Exp_Ch7 is\n       Expand_At_End_Handler (HSS, Empty);\n    end Build_Finalizer_Call;\n \n+   ---------------------\n+   -- Build_Finalizer --\n+   ---------------------\n+\n+   procedure Build_Finalizer\n+     (N           : Node_Id;\n+      Clean_Stmts : List_Id;\n+      Mark_Id     : Entity_Id;\n+      Top_Decls   : List_Id;\n+      Defer_Abort : Boolean;\n+      Fin_Id      : out Entity_Id)\n+   is\n+      Def_Ent : constant Entity_Id  := Unique_Defining_Entity (N);\n+      Loc     : constant Source_Ptr := Sloc (N);\n+\n+      --  Declarations used for the creation of _finalization_controller\n+\n+      Fin_Old_Id           : Entity_Id := Empty;\n+      Fin_Controller_Id    : Entity_Id := Empty;\n+      Fin_Controller_Decls : List_Id;\n+      Fin_Controller_Stmts : List_Id;\n+      Fin_Controller_Body  : Node_Id   := Empty;\n+      Fin_Controller_Spec  : Node_Id   := Empty;\n+      Postconditions_Call  : Node_Id   := Empty;\n+\n+      --  Defining identifiers for local objects used to store exception info\n+\n+      Raised_Post_Exception_Id         : Entity_Id := Empty;\n+      Raised_Finalization_Exception_Id : Entity_Id := Empty;\n+      Saved_Exception_Id               : Entity_Id := Empty;\n+\n+   --  Start of processing for Build_Finalizer\n+\n+   begin\n+      --  Create the general finalization routine\n+\n+      Build_Finalizer_Helper\n+        (N                 => N,\n+         Clean_Stmts       => Clean_Stmts,\n+         Mark_Id           => Mark_Id,\n+         Top_Decls         => Top_Decls,\n+         Defer_Abort       => Defer_Abort,\n+         Fin_Id            => Fin_Id,\n+         Finalize_Old_Only => False);\n+\n+      --  When postconditions are present, expansion gets much more complicated\n+      --  due to both the fact that they must be called after finalization and\n+      --  that finalization of 'Old objects must occur after the postconditions\n+      --  get checked.\n+\n+      --  Additionally, exceptions between general finalization and 'Old\n+      --  finalization must be propagated correctly and exceptions which happen\n+      --  during _postconditions need to be saved and reraised after\n+      --  finalization of 'Old objects.\n+\n+      --  Generate:\n+      --\n+      --    Postcond_Enabled := False;\n+      --\n+      --    procedure _finalization_controller is\n+      --\n+      --       --  Exception capturing and tracking\n+      --\n+      --       Saved_Exception               : Exception_Occurrence;\n+      --       Raised_Post_Exception         : Boolean := False;\n+      --       Raised_Finalization_Exception : Boolean := False;\n+      --\n+      --    --  Start of processing for _finalization_controller\n+      --\n+      --    begin\n+      --       --  Perform general finalization\n+      --\n+      --       begin\n+      --          _finalizer;\n+      --       exception\n+      --          when others =>\n+      --             --  Save the exception\n+      --\n+      --             Raised_Finalization_Exception := True;\n+      --             Save_Occurrence\n+      --               (Saved_Exception, Get_Current_Excep.all);\n+      --       end;\n+      --\n+      --       --  Perform postcondition checks after general finalization, but\n+      --       --  before finalization of 'Old related objects.\n+      --\n+      --       if not Raised_Finalization_Exception then\n+      --          begin\n+      --             --  Re-enable postconditions and check them\n+      --\n+      --             Postcond_Enabled := True;\n+      --             _postconditions [(Result_Obj_For_Postcond[.all])];\n+      --          exception\n+      --             when others =>\n+      --                --  Save the exception\n+      --\n+      --                Raised_Post_Exception := True;\n+      --                Save_Occurrence\n+      --                  (Saved_Exception, Get_Current_Excep.all);\n+      --          end;\n+      --       end if;\n+      --\n+      --       --  Finally finalize 'Old related objects\n+      --\n+      --       begin\n+      --          _finalizer_old;\n+      --       exception\n+      --          when others =>\n+      --             --  Reraise the previous finalization error if there is\n+      --             --  one.\n+      --\n+      --             if Raised_Finalization_Exception then\n+      --                Reraise_Occurrence (Saved_Exception);\n+      --             end if;\n+      --\n+      --             --  Otherwise, reraise the current one\n+      --\n+      --             raise;\n+      --       end;\n+      --\n+      --       --  Reraise any saved exception\n+      --\n+      --       if Raised_Finalization_Exception\n+      --            or else Raised_Post_Exception\n+      --       then\n+      --          Reraise_Occurrence (Saved_Exception);\n+      --       end if;\n+      --    end _finalization_controller;\n+\n+      if Nkind (N) = N_Subprogram_Body\n+        and then Present (Postconditions_Proc (Def_Ent))\n+      then\n+         Fin_Controller_Stmts := New_List;\n+         Fin_Controller_Decls := New_List;\n+\n+         --  Build the 'Old finalizer\n+\n+         Build_Finalizer_Helper\n+           (N                 => N,\n+            Clean_Stmts       => Empty_List,\n+            Mark_Id           => Mark_Id,\n+            Top_Decls         => Top_Decls,\n+            Defer_Abort       => Defer_Abort,\n+            Fin_Id            => Fin_Old_Id,\n+            Finalize_Old_Only => True);\n+\n+         --  Create local declarations for _finalization_controller needed for\n+         --  saving exceptions.\n+         --\n+         --  Generate:\n+         --\n+         --    Saved_Exception               : Exception_Occurrence;\n+         --    Raised_Post_Exception         : Boolean := False;\n+         --    Raised_Finalization_Exception : Boolean := False;\n+\n+         Saved_Exception_Id               := Make_Temporary (Loc, 'S');\n+         Raised_Post_Exception_Id         := Make_Temporary (Loc, 'P');\n+         Raised_Finalization_Exception_Id := Make_Temporary (Loc, 'F');\n+\n+         Append_List_To (Fin_Controller_Decls, New_List (\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => Saved_Exception_Id,\n+             Object_Definition   =>\n+               New_Occurrence_Of (RTE (RE_Exception_Occurrence), Loc)),\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => Raised_Post_Exception_Id,\n+             Object_Definition   => New_Occurrence_Of (Standard_Boolean, Loc),\n+             Expression          => New_Occurrence_Of (Standard_False, Loc)),\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => Raised_Finalization_Exception_Id,\n+             Object_Definition   => New_Occurrence_Of (Standard_Boolean, Loc),\n+             Expression          => New_Occurrence_Of (Standard_False, Loc))));\n+\n+         --  Call _finalizer and save any exceptions which occur\n+\n+         --  Generate:\n+         --\n+         --    begin\n+         --       _finalizer;\n+         --    exception\n+         --       when others =>\n+         --          Raised_Finalization_Exception := True;\n+         --          Save_Occurrence\n+         --            (Saved_Exception, Get_Current_Excep.all);\n+         --    end;\n+\n+         if Present (Fin_Id) then\n+            Append_To (Fin_Controller_Stmts,\n+              Make_Block_Statement (Loc,\n+                Handled_Statement_Sequence =>\n+                  Make_Handled_Sequence_Of_Statements (Loc,\n+                    Statements         => New_List (\n+                      Make_Procedure_Call_Statement (Loc,\n+                        Name => New_Occurrence_Of (Fin_Id, Loc))),\n+                    Exception_Handlers => New_List (\n+                      Make_Exception_Handler (Loc,\n+                        Exception_Choices => New_List (\n+                          Make_Others_Choice (Loc)),\n+                        Statements        => New_List (\n+                          Make_Assignment_Statement (Loc,\n+                            Name       =>\n+                              New_Occurrence_Of\n+                                (Raised_Finalization_Exception_Id, Loc),\n+                            Expression =>\n+                              New_Occurrence_Of (Standard_True, Loc)),\n+                          Make_Procedure_Call_Statement (Loc,\n+                             Name                   =>\n+                               New_Occurrence_Of\n+                                 (RTE (RE_Save_Occurrence), Loc),\n+                             Parameter_Associations => New_List (\n+                               New_Occurrence_Of\n+                                 (Saved_Exception_Id, Loc),\n+                               Make_Explicit_Dereference (Loc,\n+                                 Prefix =>\n+                                   Make_Function_Call (Loc,\n+                                     Name =>\n+                                       Make_Explicit_Dereference (Loc,\n+                                         Prefix =>\n+                                           New_Occurrence_Of\n+                                             (RTE (RE_Get_Current_Excep),\n+                                              Loc))))))))))));\n+         end if;\n+\n+         --  Create the call to postconditions based on the kind of the current\n+         --  subprogram, and the type of the Result_Obj_For_Postcond.\n+\n+         --  Generate:\n+         --\n+         --    _postconditions (Result_Obj_For_Postcond[.all]);\n+         --\n+         --   or\n+         --\n+         --    _postconditions;\n+\n+         if Ekind (Def_Ent) = E_Procedure then\n+            Postconditions_Call :=\n+              Make_Procedure_Call_Statement (Loc,\n+                Name =>\n+                  New_Occurrence_Of\n+                    (Postconditions_Proc (Def_Ent), Loc));\n+         else\n+            Postconditions_Call :=\n+              Make_Procedure_Call_Statement (Loc,\n+                Name                   =>\n+                  New_Occurrence_Of\n+                    (Postconditions_Proc (Def_Ent), Loc),\n+                Parameter_Associations => New_List (\n+                  (if Is_Elementary_Type (Etype (Def_Ent)) then\n+                      New_Occurrence_Of\n+                        (Get_Result_Object_For_Postcond\n+                          (Def_Ent), Loc)\n+                   else\n+                      Make_Explicit_Dereference (Loc,\n+                        New_Occurrence_Of\n+                          (Get_Result_Object_For_Postcond\n+                            (Def_Ent), Loc)))));\n+         end if;\n+\n+         --  Call _postconditions when no general finalization exceptions have\n+         --  occured taking care to enable the postconditions and save any\n+         --  exception occurrences.\n+\n+         --  Generate:\n+         --\n+         --    if not Raised_Finalization_Exception then\n+         --       begin\n+         --          Postcond_Enabled := True;\n+         --          _postconditions [(Result_Obj_For_Postcond[.all])];\n+         --       exception\n+         --          when others =>\n+         --             Raised_Post_Exception := True;\n+         --             Save_Occurrence\n+         --               (Saved_Exception, Get_Current_Excep.all);\n+         --       end;\n+         --    end if;\n+\n+         Append_To (Fin_Controller_Stmts,\n+           Make_If_Statement (Loc,\n+             Condition       =>\n+               Make_Op_Not (Loc,\n+                 Right_Opnd =>\n+                   New_Occurrence_Of\n+                     (Raised_Finalization_Exception_Id, Loc)),\n+             Then_Statements => New_List (\n+               Make_Block_Statement (Loc,\n+                 Handled_Statement_Sequence =>\n+                   Make_Handled_Sequence_Of_Statements (Loc,\n+                     Statements         => New_List (\n+                       Make_Assignment_Statement (Loc,\n+                         Name       =>\n+                           New_Occurrence_Of\n+                             (Get_Postcond_Enabled (Def_Ent), Loc),\n+                         Expression =>\n+                            New_Occurrence_Of\n+                              (Standard_True, Loc)),\n+                       Postconditions_Call),\n+                     Exception_Handlers => New_List (\n+                       Make_Exception_Handler (Loc,\n+                         Exception_Choices => New_List (\n+                           Make_Others_Choice (Loc)),\n+                         Statements        => New_List (\n+                           Make_Assignment_Statement (Loc,\n+                             Name       =>\n+                               New_Occurrence_Of\n+                                 (Raised_Post_Exception_Id, Loc),\n+                             Expression =>\n+                               New_Occurrence_Of (Standard_True, Loc)),\n+                           Make_Procedure_Call_Statement (Loc,\n+                              Name                   =>\n+                                New_Occurrence_Of\n+                                  (RTE (RE_Save_Occurrence), Loc),\n+                              Parameter_Associations => New_List (\n+                                New_Occurrence_Of\n+                                  (Saved_Exception_Id, Loc),\n+                                Make_Explicit_Dereference (Loc,\n+                                  Prefix =>\n+                                    Make_Function_Call (Loc,\n+                                      Name =>\n+                                        Make_Explicit_Dereference (Loc,\n+                                          Prefix =>\n+                                            New_Occurrence_Of\n+                                              (RTE (RE_Get_Current_Excep),\n+                                               Loc))))))))))))));\n+\n+         --  Call _finalizer_old and reraise any exception that occurred during\n+         --  initial finalization within the exception handler. Otherwise,\n+         --  propagate the current exception.\n+\n+         --  Generate:\n+         --\n+         --    begin\n+         --       _finalizer_old;\n+         --    exception\n+         --       when others =>\n+         --          if Raised_Finalization_Exception then\n+         --             Reraise_Occurrence (Saved_Exception);\n+         --          end if;\n+         --          raise;\n+         --    end;\n+\n+         if Present (Fin_Old_Id) then\n+            Append_To (Fin_Controller_Stmts,\n+              Make_Block_Statement (Loc,\n+                Handled_Statement_Sequence =>\n+                  Make_Handled_Sequence_Of_Statements (Loc,\n+                    Statements         => New_List (\n+                      Make_Procedure_Call_Statement (Loc,\n+                        Name => New_Occurrence_Of (Fin_Old_Id, Loc))),\n+                    Exception_Handlers => New_List (\n+                      Make_Exception_Handler (Loc,\n+                        Exception_Choices => New_List (\n+                          Make_Others_Choice (Loc)),\n+                        Statements        => New_List (\n+                          Make_If_Statement (Loc,\n+                            Condition       =>\n+                              New_Occurrence_Of\n+                                (Raised_Finalization_Exception_Id, Loc),\n+                            Then_Statements => New_List (\n+                              Make_Procedure_Call_Statement (Loc,\n+                                Name                   =>\n+                                  New_Occurrence_Of\n+                                    (RTE (RE_Reraise_Occurrence), Loc),\n+                                Parameter_Associations => New_List (\n+                                  New_Occurrence_Of\n+                                    (Saved_Exception_Id, Loc))))),\n+                          Make_Raise_Statement (Loc)))))));\n+         end if;\n+\n+         --  Once finalization is complete reraise any pending exceptions\n+\n+         --  Generate:\n+         --\n+         --    if Raised_Post_Exception\n+         --      or else Raised_Finalization_Exception\n+         --    then\n+         --       Reraise_Occurrence (Saved_Exception);\n+         --    end if;\n+\n+         Append_To (Fin_Controller_Stmts,\n+           Make_If_Statement (Loc,\n+             Condition       =>\n+               Make_Or_Else (Loc,\n+                 Left_Opnd  =>\n+                   New_Occurrence_Of\n+                     (Raised_Post_Exception_Id, Loc),\n+                 Right_Opnd =>\n+                   New_Occurrence_Of\n+                     (Raised_Finalization_Exception_Id, Loc)),\n+             Then_Statements => New_List (\n+               Make_Procedure_Call_Statement (Loc,\n+                 Name            =>\n+                   New_Occurrence_Of (RTE (RE_Reraise_Occurrence), Loc),\n+                 Parameter_Associations => New_List (\n+                   New_Occurrence_Of\n+                     (Saved_Exception_Id, Loc))))));\n+\n+         --  Make the finalization controller subprogram body and declaration.\n+\n+         --  Generate:\n+         --    procedure _finalization_controller;\n+         --\n+         --    procedure _finalization_controller is\n+         --    begin\n+         --       [Fin_Controller_Stmts];\n+         --    end;\n+\n+         Fin_Controller_Id :=\n+           Make_Defining_Identifier (Loc,\n+             Chars => New_External_Name (Name_uFinalization_Controller));\n+\n+         Fin_Controller_Spec :=\n+           Make_Subprogram_Declaration (Loc,\n+             Specification =>\n+               Make_Procedure_Specification (Loc,\n+                 Defining_Unit_Name => Fin_Controller_Id));\n+\n+         Fin_Controller_Body :=\n+           Make_Subprogram_Body (Loc,\n+             Specification              =>\n+               Make_Procedure_Specification (Loc,\n+                 Defining_Unit_Name =>\n+                   Make_Defining_Identifier (Loc, Chars (Fin_Controller_Id))),\n+             Declarations               => Fin_Controller_Decls,\n+             Handled_Statement_Sequence =>\n+               Make_Handled_Sequence_Of_Statements (Loc,\n+                 Statements => Fin_Controller_Stmts));\n+\n+         --  Disable _postconditions calls which get generated before return\n+         --  statements to delay their evaluation until after finalization.\n+\n+         --  This is done by way of the local Postcond_Enabled object which is\n+         --  initially assigned to True - we then create an assignment within\n+         --  the subprogram's declaration to make it False and assign it back\n+         --  to True before _postconditions is called within\n+         --  _finalization_controller.\n+\n+         --  Generate:\n+         --\n+         --    Postcond_Enable := False;\n+\n+         Append_To (Top_Decls,\n+           Make_Assignment_Statement (Loc,\n+             Name       =>\n+               New_Occurrence_Of\n+                 (Get_Postcond_Enabled (Def_Ent), Loc),\n+             Expression =>\n+               New_Occurrence_Of\n+                 (Standard_False, Loc)));\n+\n+         --  Add the subprogram to the list of declarations an analyze it\n+\n+         Append_To (Top_Decls, Fin_Controller_Spec);\n+         Analyze (Fin_Controller_Spec);\n+         Insert_After (Fin_Controller_Spec, Fin_Controller_Body);\n+         Analyze (Fin_Controller_Body, Suppress => All_Checks);\n+\n+         --  Return the finalization controller as the result Fin_Id\n+\n+         Fin_Id := Fin_Controller_Id;\n+      end if;\n+   end Build_Finalizer;\n+\n    ---------------------\n    -- Build_Late_Proc --\n    ---------------------\n@@ -4806,6 +5338,12 @@ package body Exp_Ch7 is\n                                  Nkind (N) = N_Block_Statement\n                                    and then Present (Cleanup_Actions (N));\n \n+      Has_Postcondition      : constant Boolean :=\n+                                 Nkind (N) = N_Subprogram_Body\n+                                   and then Present\n+                                              (Postconditions_Proc\n+                                                (Unique_Defining_Entity (N)));\n+\n       Actions_Required       : constant Boolean :=\n                                  Requires_Cleanup_Actions (N, True)\n                                    or else Is_Asynchronous_Call\n@@ -5020,6 +5558,34 @@ package body Exp_Ch7 is\n             end;\n          end if;\n \n+         --  Move the _postconditions subprogram declaration and its associated\n+         --  objects into the declarations section so that it is callable\n+         --  within _postconditions.\n+\n+         if Has_Postcondition then\n+            declare\n+               Decl      : Node_Id;\n+               Prev_Decl : Node_Id;\n+\n+            begin\n+               Decl :=\n+                 Prev (Subprogram_Body\n+                        (Postconditions_Proc (Current_Subprogram)));\n+               while Present (Decl) loop\n+                  Prev_Decl := Prev (Decl);\n+\n+                  Remove (Decl);\n+                  Prepend_To (New_Decls, Decl);\n+\n+                  exit when Nkind (Decl) = N_Subprogram_Declaration\n+                              and then Chars (Corresponding_Body (Decl))\n+                                         = Name_uPostconditions;\n+\n+                  Decl := Prev_Decl;\n+               end loop;\n+            end;\n+         end if;\n+\n          --  Ensure the presence of a declaration list in order to successfully\n          --  append all original statements to it.\n "}, {"sha": "d616fb6d901b5de2a18600fe17b418c3e1ad5583", "filename": "gcc/ada/exp_prag.adb", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1023434a8dd3ce2281a726d30ef370caa425252/gcc%2Fada%2Fexp_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1023434a8dd3ce2281a726d30ef370caa425252/gcc%2Fada%2Fexp_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_prag.adb?ref=a1023434a8dd3ce2281a726d30ef370caa425252", "patch": "@@ -1581,6 +1581,12 @@ package body Exp_Prag is\n                       Expression => Pref));\n                end if;\n \n+               --  Mark the temporary as coming from a 'Old reference\n+\n+               if Present (Temp) then\n+                  Set_Stores_Attribute_Old_Prefix (Temp);\n+               end if;\n+\n                --  Ensure that the prefix is valid\n \n                if Validity_Checks_On and then Validity_Check_Operands then"}, {"sha": "29c11cd397c13fec36e8879ecfb8b52056d6b278", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1023434a8dd3ce2281a726d30ef370caa425252/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1023434a8dd3ce2281a726d30ef370caa425252/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=a1023434a8dd3ce2281a726d30ef370caa425252", "patch": "@@ -2490,13 +2490,11 @@ package body Sem_Ch6 is\n          Result : Entity_Id := Empty;\n \n       begin\n-         --  Loop outward through the Scope_Stack, skipping blocks, loops,\n-         --  and postconditions.\n+         --  Loop outward through the Scope_Stack, skipping blocks, and loops\n \n          for J in reverse 0 .. Scope_Stack.Last loop\n             Result := Scope_Stack.Table (J).Entity;\n-            exit when Ekind (Result) not in E_Block | E_Loop\n-              and then Chars (Result) /= Name_uPostconditions;\n+            exit when Ekind (Result) not in E_Block | E_Loop;\n          end loop;\n \n          pragma Assert (Present (Result));"}, {"sha": "1a2d2a2d125ab841b1ea3e2576c9bd2433b6b4ba", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1023434a8dd3ce2281a726d30ef370caa425252/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1023434a8dd3ce2281a726d30ef370caa425252/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=a1023434a8dd3ce2281a726d30ef370caa425252", "patch": "@@ -30651,8 +30651,10 @@ package body Sem_Prag is\n       --  The pragma appears inside the statements of a subprogram body. This\n       --  placement is the result of subprogram contract expansion.\n \n-      elsif Nkind (Context) = N_Handled_Sequence_Of_Statements then\n-         return Parent (Context);\n+      elsif Is_Statement (Context)\n+        and then Present (Enclosing_HSS (Context))\n+      then\n+         return Parent (Enclosing_HSS (Context));\n \n       --  The pragma appears inside the declarative part of a package body\n "}, {"sha": "bb078d285736e28e646c9c45355e6f43848d028f", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 40, "deletions": 2, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1023434a8dd3ce2281a726d30ef370caa425252/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1023434a8dd3ce2281a726d30ef370caa425252/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=a1023434a8dd3ce2281a726d30ef370caa425252", "patch": "@@ -7931,6 +7931,34 @@ package body Sem_Util is\n       return Empty;\n    end Enclosing_Generic_Unit;\n \n+   -------------------\n+   -- Enclosing_HSS --\n+   -------------------\n+\n+   function Enclosing_HSS (Stmt : Node_Id) return Node_Id is\n+      Par : Node_Id;\n+   begin\n+      pragma Assert (Is_Statement (Stmt));\n+\n+      Par := Parent (Stmt);\n+      while Present (Par) loop\n+\n+         if Nkind (Par) = N_Handled_Sequence_Of_Statements then\n+            return Par;\n+\n+         --  Prevent the search from going too far\n+\n+         elsif Is_Body_Or_Package_Declaration (Par) then\n+            return Empty;\n+\n+         end if;\n+\n+         Par := Parent (Par);\n+      end loop;\n+\n+      return Par;\n+   end Enclosing_HSS;\n+\n    -------------------------------\n    -- Enclosing_Lib_Unit_Entity --\n    -------------------------------\n@@ -31180,9 +31208,9 @@ package body Sem_Util is\n                --  If the prefix is of an anonymous access type, then returns\n                --  the designated type of that type.\n \n-            -----------------------------\n+               -----------------------------\n                -- Designated_Subtype_Mark --\n-            -----------------------------\n+               -----------------------------\n \n                function Designated_Subtype_Mark return Node_Id is\n                   Typ : Entity_Id := Prefix_Type;\n@@ -31220,6 +31248,16 @@ package body Sem_Util is\n                   Append_Item (Temp_Decl, Is_Eval_Stmt => False);\n                end if;\n \n+               --  When a type associated with an indirect temporary gets\n+               --  created for a 'Old attribute reference we need to mark\n+               --  the type as such. This allows, for example, finalization\n+               --  masters associated with them to be finalized in the correct\n+               --  order after postcondition checks.\n+\n+               if Attribute_Name (Parent (Attr_Prefix)) = Name_Old then\n+                  Set_Stores_Attribute_Old_Prefix (Access_Type_Id);\n+               end if;\n+\n                Analyze (Access_Type_Decl);\n                Analyze (Temp_Decl);\n "}, {"sha": "d812b295fcaa1880c2146f8df7b89124aef0ee16", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1023434a8dd3ce2281a726d30ef370caa425252/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1023434a8dd3ce2281a726d30ef370caa425252/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=a1023434a8dd3ce2281a726d30ef370caa425252", "patch": "@@ -765,6 +765,10 @@ package Sem_Util is\n    --  Returns the Node_Id associated with the innermost enclosing generic\n    --  unit, if any. If none, then returns Empty.\n \n+   function Enclosing_HSS (Stmt : Node_Id) return Node_Id;\n+   --  Returns the nearest handled sequence of statements that encloses a given\n+   --  statement, or Empty.\n+\n    function Enclosing_Lib_Unit_Entity\n      (E : Entity_Id := Current_Scope) return Entity_Id;\n    --  Returns the entity of enclosing library unit node which is the root of"}, {"sha": "715a53a5e4b5e226c3b74486ad96353c3e03e00d", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1023434a8dd3ce2281a726d30ef370caa425252/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1023434a8dd3ce2281a726d30ef370caa425252/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=a1023434a8dd3ce2281a726d30ef370caa425252", "patch": "@@ -168,6 +168,8 @@ package Snames is\n    Name_uEntry_Bodies                  : constant Name_Id := N + $;\n    Name_uExpunge                       : constant Name_Id := N + $;\n    Name_uFinalizer                     : constant Name_Id := N + $;\n+   Name_uFinalizer_Old                 : constant Name_Id := N + $;\n+   Name_uFinalization_Controller       : constant Name_Id := N + $;\n    Name_uIdepth                        : constant Name_Id := N + $;\n    Name_uInit                          : constant Name_Id := N + $;\n    Name_uInit_Level                    : constant Name_Id := N + $;\n@@ -176,11 +178,14 @@ package Snames is\n    Name_uObject                        : constant Name_Id := N + $;\n    Name_uPost                          : constant Name_Id := N + $;\n    Name_uPostconditions                : constant Name_Id := N + $;\n+   Name_uPostcond_Enabled              : constant Name_Id := N + $;\n    Name_uPre                           : constant Name_Id := N + $;\n    Name_uPriority                      : constant Name_Id := N + $;\n    Name_uProcess_ATSD                  : constant Name_Id := N + $;\n    Name_uRelative_Deadline             : constant Name_Id := N + $;\n    Name_uResult                        : constant Name_Id := N + $;\n+   Name_uResult_Object_For_Postcond    : constant Name_Id := N + $;\n+   Name_uReturn_Success_For_Postcond   : constant Name_Id := N + $;\n    Name_uSecondary_Stack               : constant Name_Id := N + $;\n    Name_uSecondary_Stack_Size          : constant Name_Id := N + $;\n    Name_uService                       : constant Name_Id := N + $;"}]}