{"sha": "248606ee91171899cccbfafeead6ff6e6039ea6d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjQ4NjA2ZWU5MTE3MTg5OWNjY2JmYWZlZWFkNmZmNmU2MDM5ZWE2ZA==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2003-02-11T11:16:18Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2003-02-11T11:16:18Z"}, "message": "ByteBufferImpl.java: Reformated and removed some code.\n\n2003-02-11  Michael Koch  <konqueror@gmx.de>\n\n\t* gnu/java/nio/ByteBufferImpl.java:\n\tReformated and removed some code.\n\t(backing_buffer): Removed.\n\t(array_offset): Removed.\n\t(ro): Renamed to readOnly.\n\t(ByteBufferImpl): Use parent constructor, initialize readOnly.\n\t* gnu/java/nio/CharBufferImpl.java:\n\tReformated and removed some code.\n\t(array_offset): Removed.\n\t(ro): Renamed to readOnly.\n\t(CharBufferImpl): Use parent constructor, initialize readOnly.\n\t(inc_pos): Removed.\n\t(order): New method.\n\t* gnu/java/nio/DoubleBufferImpl.java:\n\tReformated and removed some code.\n\t(array_offset): Removed.\n\t(ro): Renamed to readOnly.\n\t(DoubleBufferImpl): Use parent constructor, initialize readOnly.\n\t(inc_pos): Removed.\n\t(order): New method.\n\t* gnu/java/nio/FloatBufferImpl.java:\n\tReformated and removed some code.\n\t(array_offset): Removed.\n\t(ro): Renamed to readOnly.\n\t(FloatBufferImpl): Use parent constructor, initialize readOnly.\n\t(inc_pos): Removed.\n\t(order): New method.\n\t* gnu/java/nio/IntBufferImpl.java:\n\tReformated and removed some code.\n\t(array_offset): Removed.\n\t(ro): Renamed to readOnly.\n\t(IntBufferImpl): Use parent constructor, initialize readOnly.\n\t(inc_pos): Removed.\n\t(order): New method.\n\t* gnu/java/nio/LongBufferImpl.java:\n\tReformated and removed some code.\n\t(array_offset): Removed.\n\t(ro): Renamed to readOnly.\n\t(LongBufferImpl): Use parent constructor, initialize readOnly.\n\t(inc_pos): Removed.\n\t(order): New method.\n\t* gnu/java/nio/ShortBufferImpl.java:\n\tReformated and removed some code.\n\t(array_offset): Removed.\n\t(ro): Renamed to readOnly.\n\t(ShortBufferImpl): Use parent constructor, initialize readOnly.\n\t(inc_pos): Removed.\n\t(order): New method.\n\t* Makefile.am\n\t(ordinary_java_source_files): Added the following files:\n\tgnu/java/nio/ByteBufferImpl.java\n\tgnu/java/nio/CharBufferImpl.java\n\tgnu/java/nio/DoubleBufferImpl.java\n\tgnu/java/nio/FloatBufferImpl.java\n\tgnu/java/nio/IntBufferImpl.java\n\tgnu/java/nio/LongBufferImpl.java\n\tgnu/java/nio/ShortBufferImpl.java\n\tjava/nio/DoubleBuffer.java\n\tjava/nio/FloatBuffer.java\n\tjava/nio/IntBuffer.java\n\tjava/nio/LongBuffer.java\n\tjava/nio/ShortBuffer.java\n\t(nat_source_files): Added the following files:\n\tgnu/java/nio/natByteBufferImpl.cc\n\tgnu/java/nio/natCharBufferImpl.cc\n\tgnu/java/nio/natDoubleBufferImpl.cc\n\tgnu/java/nio/natFloatBufferImpl.cc\n\tgnu/java/nio/natIntBufferImpl.cc\n\tgnu/java/nio/natLongBufferImpl.cc\n\tgnu/java/nio/natShortBufferImpl.cc\n\t* Makefile.in: Regenerated.\n\nFrom-SVN: r62692", "tree": {"sha": "8d70c1cd582234d5bf13f28543498de380c7e6c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8d70c1cd582234d5bf13f28543498de380c7e6c9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/248606ee91171899cccbfafeead6ff6e6039ea6d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/248606ee91171899cccbfafeead6ff6e6039ea6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/248606ee91171899cccbfafeead6ff6e6039ea6d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/248606ee91171899cccbfafeead6ff6e6039ea6d/comments", "author": null, "committer": null, "parents": [{"sha": "dfc7d8996515160bc008f5e4c942f3fdd4c96545", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfc7d8996515160bc008f5e4c942f3fdd4c96545", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfc7d8996515160bc008f5e4c942f3fdd4c96545"}], "stats": {"total": 1259, "additions": 753, "deletions": 506}, "files": [{"sha": "57cf35c8f22d251aa369e7216c39679b3d52824e", "filename": "libjava/ChangeLog", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/248606ee91171899cccbfafeead6ff6e6039ea6d/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/248606ee91171899cccbfafeead6ff6e6039ea6d/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=248606ee91171899cccbfafeead6ff6e6039ea6d", "patch": "@@ -1,3 +1,77 @@\n+2003-02-11  Michael Koch  <konqueror@gmx.de>\n+\n+\t* gnu/java/nio/ByteBufferImpl.java:\n+\tReformated and removed some code.\n+\t(backing_buffer): Removed.\t\n+\t(array_offset): Removed.\n+\t(ro): Renamed to readOnly.\n+\t(ByteBufferImpl): Use parent constructor, initialize readOnly.\n+\t* gnu/java/nio/CharBufferImpl.java:\n+\tReformated and removed some code.\n+\t(array_offset): Removed.\n+\t(ro): Renamed to readOnly.\n+\t(CharBufferImpl): Use parent constructor, initialize readOnly.\n+\t(inc_pos): Removed.\n+\t(order): New method.\n+\t* gnu/java/nio/DoubleBufferImpl.java:\n+\tReformated and removed some code.\n+\t(array_offset): Removed.\n+\t(ro): Renamed to readOnly.\n+\t(DoubleBufferImpl): Use parent constructor, initialize readOnly.\n+\t(inc_pos): Removed.\n+\t(order): New method.\n+\t* gnu/java/nio/FloatBufferImpl.java:\n+\tReformated and removed some code.\n+\t(array_offset): Removed.\n+\t(ro): Renamed to readOnly.\n+\t(FloatBufferImpl): Use parent constructor, initialize readOnly.\n+\t(inc_pos): Removed.\n+\t(order): New method.\n+\t* gnu/java/nio/IntBufferImpl.java:\n+\tReformated and removed some code.\n+\t(array_offset): Removed.\n+\t(ro): Renamed to readOnly.\n+\t(IntBufferImpl): Use parent constructor, initialize readOnly.\n+\t(inc_pos): Removed.\n+\t(order): New method.\n+\t* gnu/java/nio/LongBufferImpl.java:\n+\tReformated and removed some code.\n+\t(array_offset): Removed.\n+\t(ro): Renamed to readOnly.\n+\t(LongBufferImpl): Use parent constructor, initialize readOnly.\n+\t(inc_pos): Removed.\n+\t(order): New method.\n+\t* gnu/java/nio/ShortBufferImpl.java:\n+\tReformated and removed some code.\n+\t(array_offset): Removed.\n+\t(ro): Renamed to readOnly.\n+\t(ShortBufferImpl): Use parent constructor, initialize readOnly.\n+\t(inc_pos): Removed.\n+\t(order): New method.\n+\t* Makefile.am\n+\t(ordinary_java_source_files): Added the following files:\n+\tgnu/java/nio/ByteBufferImpl.java\n+\tgnu/java/nio/CharBufferImpl.java\n+\tgnu/java/nio/DoubleBufferImpl.java\n+\tgnu/java/nio/FloatBufferImpl.java\n+\tgnu/java/nio/IntBufferImpl.java\n+\tgnu/java/nio/LongBufferImpl.java\n+\tgnu/java/nio/ShortBufferImpl.java\n+\tjava/nio/DoubleBuffer.java\n+\tjava/nio/FloatBuffer.java\n+\tjava/nio/IntBuffer.java\n+\tjava/nio/LongBuffer.java\n+\tjava/nio/ShortBuffer.java\n+\t(nat_source_files): Added the following files:\n+\tgnu/java/nio/natByteBufferImpl.cc\n+\tgnu/java/nio/natCharBufferImpl.cc\n+\tgnu/java/nio/natDoubleBufferImpl.cc\n+\tgnu/java/nio/natFloatBufferImpl.cc\n+\tgnu/java/nio/natIntBufferImpl.cc\n+\tgnu/java/nio/natLongBufferImpl.cc\n+\tgnu/java/nio/natShortBufferImpl.cc\n+\t* Makefile.in: Regenerated.\n+\n 2003-02-11  Michael Koch  <konqueror@gmx.de>\n \n \t* gnu/java/nio/natCharBufferImpl.cc"}, {"sha": "f8911f2909ef01e249b99270c4ed78cf492de964", "filename": "libjava/Makefile.am", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/248606ee91171899cccbfafeead6ff6e6039ea6d/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/248606ee91171899cccbfafeead6ff6e6039ea6d/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=248606ee91171899cccbfafeead6ff6e6039ea6d", "patch": "@@ -2037,6 +2037,13 @@ gnu/java/locale/LocaleInformation_zh_HK.java \\\n gnu/java/locale/LocaleInformation_zh_SG.java \\\n gnu/java/locale/LocaleInformation_zh_TW.java \\\n gnu/java/math/MPN.java \\\n+gnu/java/nio/ByteBufferImpl.java \\\n+gnu/java/nio/CharBufferImpl.java \\\n+gnu/java/nio/DoubleBufferImpl.java \\\n+gnu/java/nio/FloatBufferImpl.java \\\n+gnu/java/nio/IntBufferImpl.java \\\n+gnu/java/nio/LongBufferImpl.java \\\n+gnu/java/nio/ShortBufferImpl.java \\\n gnu/java/nio/charset/ISO_8859_1.java \\\n gnu/java/nio/charset/Provider.java \\\n gnu/java/nio/charset/US_ASCII.java \\\n@@ -2139,9 +2146,14 @@ java/nio/BufferUnderflowException.java \\\n java/nio/ByteBuffer.java \\\n java/nio/ByteOrder.java \\\n java/nio/CharBuffer.java \\\n+java/nio/DoubleBuffer.java \\\n+java/nio/FloatBuffer.java \\\n+java/nio/IntBuffer.java \\\n java/nio/InvalidMarkException.java \\\n+java/nio/LongBuffer.java \\\n java/nio/MappedByteBuffer.java \\\n java/nio/ReadOnlyBufferException.java \\\n+java/nio/ShortBuffer.java \\\n java/nio/channels/AlreadyConnectedException.java \\\n java/nio/channels/AsynchronousCloseException.java \\\n java/nio/channels/ByteChannel.java \\\n@@ -2431,6 +2443,13 @@ gnu/gcj/runtime/natSharedLibLoader.cc \\\n gnu/gcj/runtime/natStackTrace.cc \\\n gnu/gcj/runtime/natStringBuffer.cc \\\n gnu/gcj/runtime/natVMClassLoader.cc \\\n+gnu/java/nio/natByteBufferImpl.cc \\\n+gnu/java/nio/natCharBufferImpl.cc \\\n+gnu/java/nio/natDoubleBufferImpl.cc \\\n+gnu/java/nio/natFloatBufferImpl.cc \\\n+gnu/java/nio/natIntBufferImpl.cc \\\n+gnu/java/nio/natLongBufferImpl.cc \\\n+gnu/java/nio/natShortBufferImpl.cc \\\n java/io/natFile.cc \\\n java/io/natFileDescriptor.cc \\\n java/io/natObjectInputStream.cc \\"}, {"sha": "de893777ebf892f1462a38a95074996010e2b0bf", "filename": "libjava/Makefile.in", "status": "modified", "additions": 45, "deletions": 5, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/248606ee91171899cccbfafeead6ff6e6039ea6d/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/248606ee91171899cccbfafeead6ff6e6039ea6d/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=248606ee91171899cccbfafeead6ff6e6039ea6d", "patch": "@@ -1797,6 +1797,13 @@ gnu/java/locale/LocaleInformation_zh_HK.java \\\n gnu/java/locale/LocaleInformation_zh_SG.java \\\n gnu/java/locale/LocaleInformation_zh_TW.java \\\n gnu/java/math/MPN.java \\\n+gnu/java/nio/ByteBufferImpl.java \\\n+gnu/java/nio/CharBufferImpl.java \\\n+gnu/java/nio/DoubleBufferImpl.java \\\n+gnu/java/nio/FloatBufferImpl.java \\\n+gnu/java/nio/IntBufferImpl.java \\\n+gnu/java/nio/LongBufferImpl.java \\\n+gnu/java/nio/ShortBufferImpl.java \\\n gnu/java/nio/charset/ISO_8859_1.java \\\n gnu/java/nio/charset/Provider.java \\\n gnu/java/nio/charset/US_ASCII.java \\\n@@ -1899,9 +1906,14 @@ java/nio/BufferUnderflowException.java \\\n java/nio/ByteBuffer.java \\\n java/nio/ByteOrder.java \\\n java/nio/CharBuffer.java \\\n+java/nio/DoubleBuffer.java \\\n+java/nio/FloatBuffer.java \\\n+java/nio/IntBuffer.java \\\n java/nio/InvalidMarkException.java \\\n+java/nio/LongBuffer.java \\\n java/nio/MappedByteBuffer.java \\\n java/nio/ReadOnlyBufferException.java \\\n+java/nio/ShortBuffer.java \\\n java/nio/channels/AlreadyConnectedException.java \\\n java/nio/channels/AsynchronousCloseException.java \\\n java/nio/channels/ByteChannel.java \\\n@@ -2190,6 +2202,13 @@ gnu/gcj/runtime/natSharedLibLoader.cc \\\n gnu/gcj/runtime/natStackTrace.cc \\\n gnu/gcj/runtime/natStringBuffer.cc \\\n gnu/gcj/runtime/natVMClassLoader.cc \\\n+gnu/java/nio/natByteBufferImpl.cc \\\n+gnu/java/nio/natCharBufferImpl.cc \\\n+gnu/java/nio/natDoubleBufferImpl.cc \\\n+gnu/java/nio/natFloatBufferImpl.cc \\\n+gnu/java/nio/natIntBufferImpl.cc \\\n+gnu/java/nio/natLongBufferImpl.cc \\\n+gnu/java/nio/natShortBufferImpl.cc \\\n java/io/natFile.cc \\\n java/io/natFileDescriptor.cc \\\n java/io/natObjectInputStream.cc \\\n@@ -2361,8 +2380,14 @@ gnu/gcj/io/shs.lo gnu/gcj/protocol/core/natCoreInputStream.lo \\\n gnu/gcj/runtime/natFinalizerThread.lo gnu/gcj/runtime/natFirstThread.lo \\\n gnu/gcj/runtime/natNameFinder.lo gnu/gcj/runtime/natSharedLibLoader.lo \\\n gnu/gcj/runtime/natStackTrace.lo gnu/gcj/runtime/natStringBuffer.lo \\\n-gnu/gcj/runtime/natVMClassLoader.lo java/io/natFile.lo \\\n-java/io/natFileDescriptor.lo java/io/natObjectInputStream.lo \\\n+gnu/gcj/runtime/natVMClassLoader.lo gnu/java/nio/natByteBufferImpl.lo \\\n+gnu/java/nio/natCharBufferImpl.lo gnu/java/nio/natDoubleBufferImpl.lo \\\n+gnu/java/nio/natFloatBufferImpl.lo gnu/java/nio/natIntBufferImpl.lo \\\n+gnu/java/nio/natLongBufferImpl.lo \\\n+gnu/java/nio/natSelectorImpl.lo \\\n+gnu/java/nio/natShortBufferImpl.lo \\\n+java/io/natFile.lo java/io/natFileDescriptor.lo \\\n+java/io/natObjectInputStream.lo \\\n java/io/natObjectOutputStream.lo java/io/natVMObjectStreamClass.lo \\\n java/lang/natCharacter.lo java/lang/natClass.lo \\\n java/lang/natClassLoader.lo java/lang/natConcreteProcess.lo \\\n@@ -2820,7 +2845,13 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/gnu/java/locale/LocaleInformation_zh_HK.P \\\n .deps/gnu/java/locale/LocaleInformation_zh_SG.P \\\n .deps/gnu/java/locale/LocaleInformation_zh_TW.P \\\n-.deps/gnu/java/math/MPN.P .deps/gnu/java/nio/charset/ISO_8859_1.P \\\n+.deps/gnu/java/math/MPN.P .deps/gnu/java/nio/ByteBufferImpl.P \\\n+.deps/gnu/java/nio/CharBufferImpl.P \\\n+.deps/gnu/java/nio/DoubleBufferImpl.P \\\n+.deps/gnu/java/nio/FloatBufferImpl.P .deps/gnu/java/nio/IntBufferImpl.P \\\n+.deps/gnu/java/nio/LongBufferImpl.P \\\n+.deps/gnu/java/nio/ShortBufferImpl.P \\\n+.deps/gnu/java/nio/charset/ISO_8859_1.P \\\n .deps/gnu/java/nio/charset/Provider.P \\\n .deps/gnu/java/nio/charset/US_ASCII.P \\\n .deps/gnu/java/nio/charset/UTF_16.P \\\n@@ -2829,6 +2860,13 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/gnu/java/nio/charset/UTF_16Encoder.P \\\n .deps/gnu/java/nio/charset/UTF_16LE.P \\\n .deps/gnu/java/nio/charset/UTF_8.P \\\n+.deps/gnu/java/nio/natByteBufferImpl.P \\\n+.deps/gnu/java/nio/natCharBufferImpl.P \\\n+.deps/gnu/java/nio/natDoubleBufferImpl.P \\\n+.deps/gnu/java/nio/natFloatBufferImpl.P \\\n+.deps/gnu/java/nio/natIntBufferImpl.P \\\n+.deps/gnu/java/nio/natLongBufferImpl.P \\\n+.deps/gnu/java/nio/natShortBufferImpl.P \\\n .deps/gnu/java/rmi/RMIMarshalledObjectInputStream.P \\\n .deps/gnu/java/rmi/RMIMarshalledObjectOutputStream.P \\\n .deps/gnu/java/rmi/dgc/DGCImpl.P .deps/gnu/java/rmi/dgc/DGCImpl_Skel.P \\\n@@ -3298,8 +3336,10 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/nio/BufferOverflowException.P \\\n .deps/java/nio/BufferUnderflowException.P .deps/java/nio/ByteBuffer.P \\\n .deps/java/nio/ByteOrder.P .deps/java/nio/CharBuffer.P \\\n-.deps/java/nio/InvalidMarkException.P .deps/java/nio/MappedByteBuffer.P \\\n-.deps/java/nio/ReadOnlyBufferException.P \\\n+.deps/java/nio/DoubleBuffer.P .deps/java/nio/FloatBuffer.P \\\n+.deps/java/nio/IntBuffer.P .deps/java/nio/InvalidMarkException.P \\\n+.deps/java/nio/LongBuffer.P .deps/java/nio/MappedByteBuffer.P \\\n+.deps/java/nio/ReadOnlyBufferException.P .deps/java/nio/ShortBuffer.P \\\n .deps/java/nio/channels/AlreadyConnectedException.P \\\n .deps/java/nio/channels/AsynchronousCloseException.P \\\n .deps/java/nio/channels/ByteChannel.P \\"}, {"sha": "19783e578072d49253a2759c1f3c7755fa0dbe2c", "filename": "libjava/gnu/java/nio/ByteBufferImpl.java", "status": "modified", "additions": 331, "deletions": 55, "changes": 386, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/248606ee91171899cccbfafeead6ff6e6039ea6d/libjava%2Fgnu%2Fjava%2Fnio%2FByteBufferImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/248606ee91171899cccbfafeead6ff6e6039ea6d/libjava%2Fgnu%2Fjava%2Fnio%2FByteBufferImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnio%2FByteBufferImpl.java?ref=248606ee91171899cccbfafeead6ff6e6039ea6d", "patch": "@@ -43,37 +43,35 @@\n import java.nio.FloatBuffer;\n import java.nio.IntBuffer;\n import java.nio.LongBuffer;\n+import java.nio.ReadOnlyBufferException;\n import java.nio.ShortBuffer;\n \n+/**\n+ * This is a Heap memory implementation\n+ */\n public final class ByteBufferImpl extends ByteBuffer\n {\n-  private byte[] backing_buffer;\n-  private int array_offset;\n-  private boolean ro;\n-\n+  private boolean readOnly;\n+  \n   public ByteBufferImpl (int cap, int off, int lim)\n   {\n-    this.cap = cap;\n-    limit (lim);\n-    position (off);\n-    this.backing_buffer = new byte[cap];\n+    super (cap, lim, off, 0);\n+    this.backing_buffer = new byte [cap];\n+    readOnly = false;\n   }\n \n   public ByteBufferImpl (byte[] array, int off, int lim)\n   {\n-    this.cap = array.length;\n-    limit (lim);\n-    position (off);\n+    super (array.length, lim, off, 0);\n     this.backing_buffer = array;\n+    readOnly = false;\n   }\n \n   public ByteBufferImpl (ByteBufferImpl copy)\n   {\n-    this.cap = copy.capacity ();\n-    limit (copy.limit ());\n-    position (copy.position ());\n-    ro = copy.ro;\n+    super (copy.capacity (), copy.limit (), copy.position (), 0);\n     backing_buffer = copy.backing_buffer;\n+    readOnly = copy.isReadOnly ();\n   }\n \n   void inc_pos (int toAdd)\n@@ -89,52 +87,140 @@ void inc_pos (int toAdd)\n   private static native byte[] nio_cast(float[]copy);\n   private static native byte[] nio_cast(double[]copy);\n \n+  ByteBufferImpl (byte[] copy)\n+  {\n+    super (copy.length, copy.length, 0, 0);\n+    this.backing_buffer = copy != null ? nio_cast (copy) : null;\n+    readOnly = false;\n+  }\n \n-  ByteBufferImpl(byte[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n-  private static native byte nio_get_Byte(ByteBufferImpl b, int index, int limit);\n-  private static native void nio_put_Byte(ByteBufferImpl b, int index, int limit, byte value);\n-  public ByteBuffer asByteBuffer() { ByteBufferImpl res = new ByteBufferImpl(backing_buffer); res.limit((limit()*1)/1); return res; }\n+  private static native byte nio_get_Byte (ByteBufferImpl b, int index, int limit);\n+  \n+  private static native void nio_put_Byte (ByteBufferImpl b, int index, int limit, byte value);\n+  \n+  public ByteBuffer asByteBuffer ()\n+  {\n+    ByteBufferImpl res = new ByteBufferImpl (backing_buffer);\n+    res.limit ((limit () * 1) / 1);\n+    return res;\n+  }\n \n-  ByteBufferImpl(char[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n-  private static native char nio_get_Char(ByteBufferImpl b, int index, int limit);\n-  private static native void nio_put_Char(ByteBufferImpl b, int index, int limit, char value);\n-  public CharBuffer asCharBuffer() { CharBufferImpl res = new CharBufferImpl(backing_buffer); res.limit((limit()*2)/1); return res; }\n+  ByteBufferImpl (char[] copy)\n+  {\n+    super (copy.length * 2, copy.length * 2, 0, 0);\n+    this.backing_buffer = copy != null ? nio_cast (copy) : null;\n+    readOnly = false;\n+  }\n \n-  ByteBufferImpl(short[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n-  private static native short nio_get_Short(ByteBufferImpl b, int index, int limit);\n-  private static native void nio_put_Short(ByteBufferImpl b, int index, int limit, short value);\n-  public ShortBuffer asShortBuffer() { ShortBufferImpl res = new ShortBufferImpl(backing_buffer); res.limit((limit()*2)/1); return res; }\n+  private static native char nio_get_Char (ByteBufferImpl b, int index, int limit);\n \n-  ByteBufferImpl(int[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n-  private static native int nio_get_Int(ByteBufferImpl b, int index, int limit);\n-  private static native void nio_put_Int(ByteBufferImpl b, int index, int limit, int value);\n-  public IntBuffer asIntBuffer() { IntBufferImpl res = new IntBufferImpl(backing_buffer); res.limit((limit()*4)/1); return res; }\n+  private static native void nio_put_Char (ByteBufferImpl b, int index, int limit, char value);\n \n-  ByteBufferImpl(long[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n-  private static native long nio_get_Long(ByteBufferImpl b, int index, int limit);\n-  private static native void nio_put_Long(ByteBufferImpl b, int index, int limit, long value);\n-  public LongBuffer asLongBuffer() { LongBufferImpl res = new LongBufferImpl(backing_buffer); res.limit((limit()*8)/1); return res; }\n+  public CharBuffer asCharBuffer ()\n+  {\n+    CharBufferImpl res = new CharBufferImpl (backing_buffer);\n+    res.limit ((limit () * 2) / 1);\n+    return res;\n+  }\n \n-  ByteBufferImpl(float[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n-  private static native float nio_get_Float(ByteBufferImpl b, int index, int limit);\n-  private static native void nio_put_Float(ByteBufferImpl b, int index, int limit, float value);\n-  public FloatBuffer asFloatBuffer() { FloatBufferImpl res = new FloatBufferImpl(backing_buffer); res.limit((limit()*4)/1); return res; }\n+  ByteBufferImpl (short[] copy)\n+  {\n+    super (copy.length, copy.length, 0, 0);\n+    this.backing_buffer = copy != null ? nio_cast (copy) : null;\n+    readOnly = false;\n+  }\n+  \n+  private static native short nio_get_Short (ByteBufferImpl b, int index, int limit);\n+  \n+  private static native void nio_put_Short (ByteBufferImpl b, int index, int limit, short value);\n+  \n+  public ShortBuffer asShortBuffer ()\n+  {\n+    ShortBufferImpl res = new ShortBufferImpl (backing_buffer);\n+    res.limit ((limit () * 2) / 1);\n+    return res;\n+  }\n \n-  ByteBufferImpl(double[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n-  private static native double nio_get_Double(ByteBufferImpl b, int index, int limit);\n-  private static native void nio_put_Double(ByteBufferImpl b, int index, int limit, double value);\n-  public DoubleBuffer asDoubleBuffer() { DoubleBufferImpl res = new DoubleBufferImpl(backing_buffer); res.limit((limit()*8)/1); return res; }\n+  ByteBufferImpl (int[] copy)\n+  {\n+    super (copy.length * 4, copy.length * 4, 0, 0);\n+    this.backing_buffer = copy != null ? nio_cast(copy) : null;\n+    readOnly = false;\n+  }\n+  \n+  private static native int nio_get_Int (ByteBufferImpl b, int index, int limit);\n+  \n+  private static native void nio_put_Int (ByteBufferImpl b, int index, int limit, int value);\n+  \n+  public IntBuffer asIntBuffer ()\n+  {\n+    IntBufferImpl res = new IntBufferImpl (backing_buffer);\n+    res.limit ((limit() * 4) / 1);\n+    return res;\n+  }\n+\n+  ByteBufferImpl (long[] copy)\n+  {\n+    super (copy.length * 8, copy.length * 8, 0, 0);\n+    this.backing_buffer = copy != null ? nio_cast (copy) : null;\n+    readOnly = false;\n+  }\n+  \n+  private static native long nio_get_Long (ByteBufferImpl b, int index, int limit);\n+  \n+  private static native void nio_put_Long (ByteBufferImpl b, int index, int limit, long value);\n+  \n+  public LongBuffer asLongBuffer ()\n+  {\n+    LongBufferImpl res = new LongBufferImpl (backing_buffer);\n+    res.limit ((limit() * 8) / 1);\n+    return res;\n+  }\n+\n+  ByteBufferImpl (float[] copy)\n+  {\n+    super (copy.length * 4, copy.length * 4, 0, 0);\n+    this.backing_buffer = copy != null ? nio_cast (copy) : null;\n+    readOnly = false;\n+  }\n+  \n+  private static native float nio_get_Float (ByteBufferImpl b, int index, int limit);\n+  \n+  private static native void nio_put_Float (ByteBufferImpl b, int index, int limit, float value);\n+  \n+  public FloatBuffer asFloatBuffer ()\n+  {\n+    FloatBufferImpl res = new FloatBufferImpl (backing_buffer);\n+    res.limit ((limit() * 4) / 1);\n+    return res;\n+  }\n+\n+  ByteBufferImpl (double[] copy)\n+  {\n+    super (copy.length * 8, copy.length * 8, 0, 0);\n+    this.backing_buffer = copy != null ? nio_cast (copy) : null;\n+    readOnly = false;\n+  }\n+  \n+  private static native double nio_get_Double (ByteBufferImpl b, int index, int limit);\n+  \n+  private static native void nio_put_Double (ByteBufferImpl b, int index, int limit, double value);\n+  \n+  public DoubleBuffer asDoubleBuffer ()\n+  {\n+    DoubleBufferImpl res = new DoubleBufferImpl (backing_buffer);\n+    res.limit ((limit () * 8) / 1);\n+    return res;\n+  }\n \n   public boolean isReadOnly()\n   {\n-    return ro;\n+    return readOnly;\n   }\n   \n   public ByteBuffer slice()\n   {\n-    ByteBufferImpl A = new ByteBufferImpl(this);\n-    A.array_offset = position();\n-    return A;\n+    return new ByteBufferImpl(this);\n   }\n \n   public ByteBuffer duplicate()\n@@ -145,7 +231,7 @@ public ByteBuffer duplicate()\n   public ByteBuffer asReadOnlyBuffer()\n   {\n     ByteBufferImpl a = new ByteBufferImpl(this);\n-    a.ro = true;\n+    a.readOnly = true;\n     return a;\n   }\n \n@@ -156,7 +242,7 @@ public ByteBuffer compact()\n \n   public boolean isDirect()\n   {\n-    return backing_buffer != null;\n+    return false;\n   }\n   \n   final public byte get()\n@@ -168,6 +254,9 @@ final public byte get()\n   \n   final public ByteBuffer put(byte b)\n   {\n+    if (readOnly)\n+      throw new ReadOnlyBufferException ();\n+    \n     backing_buffer[position()] = b;\n     position(position()+1);\n     return this;\n@@ -180,14 +269,201 @@ final public byte get(int index)\n   \n   final public ByteBuffer put(int index, byte b)\n   {\n+    if (readOnly)\n+      throw new ReadOnlyBufferException ();\n+    \n     backing_buffer[index] = b;\n     return this;\n   }\n   \n-  final public char getChar() { char a = nio_get_Char(this, position(), limit()); inc_pos(2); return a; } final public ByteBuffer putChar(char value) { nio_put_Char(this, position(), limit(), value); inc_pos(2); return this; } final public char getChar(int index) { char a = nio_get_Char(this, index, limit()); return a; } final public ByteBuffer putChar(int index, char value) { nio_put_Char(this, index, limit(), value); return this; };\n-  final public short getShort() { short a = nio_get_Short(this, position(), limit()); inc_pos(2); return a; } final public ByteBuffer putShort(short value) { nio_put_Short(this, position(), limit(), value); inc_pos(2); return this; } final public short getShort(int index) { short a = nio_get_Short(this, index, limit()); return a; } final public ByteBuffer putShort(int index, short value) { nio_put_Short(this, index, limit(), value); return this; };\n-  final public int getInt() { int a = nio_get_Int(this, position(), limit()); inc_pos(4); return a; } final public ByteBuffer putInt(int value) { nio_put_Int(this, position(), limit(), value); inc_pos(4); return this; } final public int getInt(int index) { int a = nio_get_Int(this, index, limit()); return a; } final public ByteBuffer putInt(int index, int value) { nio_put_Int(this, index, limit(), value); return this; };\n-  final public long getLong() { long a = nio_get_Long(this, position(), limit()); inc_pos(8); return a; } final public ByteBuffer putLong(long value) { nio_put_Long(this, position(), limit(), value); inc_pos(8); return this; } final public long getLong(int index) { long a = nio_get_Long(this, index, limit()); return a; } final public ByteBuffer putLong(int index, long value) { nio_put_Long(this, index, limit(), value); return this; };\n-  final public float getFloat() { float a = nio_get_Float(this, position(), limit()); inc_pos(4); return a; } final public ByteBuffer putFloat(float value) { nio_put_Float(this, position(), limit(), value); inc_pos(4); return this; } final public float getFloat(int index) { float a = nio_get_Float(this, index, limit()); return a; } final public ByteBuffer putFloat(int index, float value) { nio_put_Float(this, index, limit(), value); return this; };\n-  final public double getDouble() { double a = nio_get_Double(this, position(), limit()); inc_pos(8); return a; } final public ByteBuffer putDouble(double value) { nio_put_Double(this, position(), limit(), value); inc_pos(8); return this; } final public double getDouble(int index) { double a = nio_get_Double(this, index, limit()); return a; } final public ByteBuffer putDouble(int index, double value) { nio_put_Double(this, index, limit(), value); return this; };\n+  final public char getChar ()\n+  {\n+    char a = nio_get_Char (this, position (), limit ());\n+    inc_pos (2);\n+    return a;\n+  }\n+  \n+  final public ByteBuffer putChar (char value)\n+  {\n+    if (readOnly)\n+      throw new ReadOnlyBufferException ();\n+    \n+    nio_put_Char (this, position (), limit (), value);\n+    inc_pos (2);\n+    return this;\n+  }\n+  \n+  final public char getChar (int index)\n+  {\n+    char a = nio_get_Char (this, index, limit ());\n+    return a;\n+  }\n+  \n+  final public ByteBuffer putChar (int index, char value)\n+  {\n+    if (readOnly)\n+      throw new ReadOnlyBufferException ();\n+    \n+    nio_put_Char (this, index, limit (), value);\n+    return this;\n+  }\n+\n+  final public short getShort ()\n+  {\n+    short a = nio_get_Short (this, position (), limit ());\n+    inc_pos (2);\n+    return a;\n+  }\n+  \n+  final public ByteBuffer putShort (short value)\n+  {\n+    if (readOnly)\n+      throw new ReadOnlyBufferException ();\n+    \n+    nio_put_Short (this, position (), limit(), value);\n+    inc_pos (2);\n+    return this;\n+  }\n+  \n+  final public short getShort (int index)\n+  {\n+    short a = nio_get_Short (this, index, limit ());\n+    return a;\n+  }\n+  \n+  final public ByteBuffer putShort (int index, short value)\n+  {\n+    if (readOnly)\n+      throw new ReadOnlyBufferException ();\n+    \n+    nio_put_Short (this, index, limit (), value);\n+    return this;\n+  }\n+\n+  final public int getInt ()\n+  {\n+    int a = nio_get_Int (this, position (), limit ());\n+    inc_pos (4);\n+    return a;\n+  }\n+  \n+  final public ByteBuffer putInt (int value)\n+  {\n+    if (readOnly)\n+      throw new ReadOnlyBufferException ();\n+    \n+    nio_put_Int (this, position (), limit , value);\n+    inc_pos (4);\n+    return this;\n+  }\n+  \n+  final public int getInt (int index)\n+  {\n+    int a = nio_get_Int (this, index, limit ());\n+    return a;\n+  }\n+  \n+  final public ByteBuffer putInt (int index, int value)\n+  {\n+    if (readOnly)\n+      throw new ReadOnlyBufferException ();\n+    \n+    nio_put_Int(this, index, limit (), value);\n+    return this;\n+  }\n+\n+  final public long getLong ()\n+  {\n+    long a = nio_get_Long (this, position (), limit ());\n+    inc_pos (8);\n+    return a;\n+  }\n+  \n+  final public ByteBuffer putLong (long value)\n+  {\n+    if (readOnly)\n+      throw new ReadOnlyBufferException ();\n+    \n+    nio_put_Long (this, position (), limit (), value);\n+    inc_pos (8);\n+    return this;\n+  }\n+  \n+  final public long getLong (int index)\n+  {\n+    long a = nio_get_Long (this, index, limit ());\n+    return a;\n+  }\n+  \n+  final public ByteBuffer putLong (int index, long value)\n+  {\n+    if (readOnly)\n+      throw new ReadOnlyBufferException ();\n+    \n+    nio_put_Long (this, index, limit (), value);\n+    return this;\n+  }\n+\n+  final public float getFloat ()\n+  {\n+    float a = nio_get_Float (this, position (), limit ());\n+    inc_pos (4);\n+    return a;\n+  }\n+  \n+  final public ByteBuffer putFloat (float value)\n+  {\n+    if (readOnly)\n+      throw new ReadOnlyBufferException ();\n+    \n+    nio_put_Float (this, position (), limit (), value);\n+    inc_pos (4);\n+    return this;\n+  }\n+  \n+  final public float getFloat (int index)\n+  {\n+    float a = nio_get_Float (this, index, limit ());\n+    return a;\n+  }\n+\n+  final public ByteBuffer putFloat (int index, float value)\n+  {\n+    if (readOnly)\n+      throw new ReadOnlyBufferException ();\n+    \n+    nio_put_Float (this, index, limit(), value);\n+    return this;\n+  }\n+\n+  final public double getDouble ()\n+  {\n+    double a = nio_get_Double (this, position (), limit ());\n+    inc_pos (8);\n+    return a;\n+  }\n+\n+  final public ByteBuffer putDouble (double value)\n+  {\n+    if (readOnly)\n+      throw new ReadOnlyBufferException ();\n+    \n+    nio_put_Double (this, position(), limit (), value);\n+    inc_pos (8);\n+    return this;\n+  }\n+  \n+  final public double getDouble (int index)\n+  {\n+    return nio_get_Double (this, index, limit ());\n+  }\n+  \n+  final public ByteBuffer putDouble (int index, double value)\n+  {\n+    if (readOnly)\n+      throw new ReadOnlyBufferException ();\n+    \n+    nio_put_Double (this, index, limit (), value);\n+    return this;\n+  }\n }"}, {"sha": "07a96fe9c36219f8b7711064f35d5004a5541a10", "filename": "libjava/gnu/java/nio/CharBufferImpl.java", "status": "modified", "additions": 70, "deletions": 76, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/248606ee91171899cccbfafeead6ff6e6039ea6d/libjava%2Fgnu%2Fjava%2Fnio%2FCharBufferImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/248606ee91171899cccbfafeead6ff6e6039ea6d/libjava%2Fgnu%2Fjava%2Fnio%2FCharBufferImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnio%2FCharBufferImpl.java?ref=248606ee91171899cccbfafeead6ff6e6039ea6d", "patch": "@@ -40,101 +40,65 @@\n import java.nio.ByteBuffer;\n import java.nio.ByteOrder;\n import java.nio.CharBuffer;\n-import java.nio.DoubleBuffer;\n-import java.nio.FloatBuffer;\n-import java.nio.IntBuffer;\n-import java.nio.LongBuffer;\n-import java.nio.ShortBuffer;\n+import java.nio.ReadOnlyBufferException;\n \n+/**\n+ * This is a Heap memory implementation\n+ */\n public final class CharBufferImpl extends CharBuffer\n {\n-  private boolean ro;\n+  private boolean readOnly;\n \n-  private ByteOrder endian = ByteOrder.BIG_ENDIAN;\n-  \n   public CharBufferImpl(int cap, int off, int lim)\n   {\n-    this.backing_buffer = new char[cap];\n-    this.cap = cap;\n-    this.limit(lim);\n-    this.position(off);\n+    super (cap, lim, off, 0);\n+    this.backing_buffer = new char [cap];\n+    readOnly = false;\n   }\n   \n   public CharBufferImpl(char[] array, int off, int lim)\n   {\n+    super (array.length, lim, off, 0);\n     this.backing_buffer = array;\n-    this.cap = array.length;\n-    this.limit(lim);\n-    this.position(off);\n+    readOnly = false;\n   }\n   \n   public CharBufferImpl (CharBufferImpl copy)\n   {\n+    super (copy.capacity (), copy.limit (), copy.position (), 0);\n     backing_buffer = copy.backing_buffer;\n-    ro = copy.ro;\n-    limit (copy.limit());\n-    position (copy.position ());\n+    readOnly = copy.isReadOnly ();\n   }\n   \n-  void inc_pos (int a)\n+  private static native char[] nio_cast (byte[] copy);\n+\n+  CharBufferImpl (byte[] copy)\n   {\n-    position (position () + a);\n+    super (copy.length / 2, copy.length / 2, 0, 0);\n+    this.backing_buffer = (copy != null ? nio_cast (copy) : null);\n+    readOnly = false;\n   }\n \n-  CharBufferImpl(byte[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n-  private static native byte nio_get_Byte(CharBufferImpl b, int index, int limit);\n-  private static native void nio_put_Byte(CharBufferImpl b, int index, int limit, byte value);\n-  public ByteBuffer asByteBuffer() { ByteBufferImpl res = new ByteBufferImpl(backing_buffer); res.limit((limit()*1)/2); return res; }\n-\n-  CharBufferImpl(char[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n-  private static native char nio_get_Char(CharBufferImpl b, int index, int limit);\n-  private static native void nio_put_Char(CharBufferImpl b, int index, int limit, char value);\n-  public CharBuffer asCharBuffer() { CharBufferImpl res = new CharBufferImpl(backing_buffer); res.limit((limit()*2)/2); return res; }\n-\n-  CharBufferImpl(short[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n-  private static native short nio_get_Short(CharBufferImpl b, int index, int limit);\n-  private static native void nio_put_Short(CharBufferImpl b, int index, int limit, short value);\n-  public ShortBuffer asShortBuffer() { ShortBufferImpl res = new ShortBufferImpl(backing_buffer); res.limit((limit()*2)/2); return res; }\n-\n-  CharBufferImpl(int[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n-  private static native int nio_get_Int(CharBufferImpl b, int index, int limit);\n-  private static native void nio_put_Int(CharBufferImpl b, int index, int limit, int value);\n-  public IntBuffer asIntBuffer() { IntBufferImpl res = new IntBufferImpl(backing_buffer); res.limit((limit()*4)/2); return res; }\n-\n-  CharBufferImpl(long[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n-  private static native long nio_get_Long(CharBufferImpl b, int index, int limit);\n-  private static native void nio_put_Long(CharBufferImpl b, int index, int limit, long value);\n-  public LongBuffer asLongBuffer() { LongBufferImpl res = new LongBufferImpl(backing_buffer); res.limit((limit()*8)/2); return res; }\n+  private static native byte nio_get_Byte (CharBufferImpl b, int index, int limit);\n \n-  CharBufferImpl(float[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n-  private static native float nio_get_Float(CharBufferImpl b, int index, int limit);\n-  private static native void nio_put_Float(CharBufferImpl b, int index, int limit, float value);\n-  public FloatBuffer asFloatBuffer() { FloatBufferImpl res = new FloatBufferImpl(backing_buffer); res.limit((limit()*4)/2); return res; }\n+  private static native void nio_put_Byte (CharBufferImpl b, int index, int limit, byte value);\n \n-  CharBufferImpl(double[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n-  private static native double nio_get_Double(CharBufferImpl b, int index, int limit);\n-  private static native void nio_put_Double(CharBufferImpl b, int index, int limit, double value);\n-  public DoubleBuffer asDoubleBuffer() { DoubleBufferImpl res = new DoubleBufferImpl(backing_buffer); res.limit((limit()*8)/2); return res; }\n-  \n-  private static native char[] nio_cast(byte[]copy);\n-  private static native char[] nio_cast(char[]copy);\n-  private static native char[] nio_cast(short[]copy);\n-  private static native char[] nio_cast(long[]copy);\n-  private static native char[] nio_cast(int[]copy);\n-  private static native char[] nio_cast(float[]copy);\n-  private static native char[] nio_cast(double[]copy);\n+  public ByteBuffer asByteBuffer ()\n+  {\n+    ByteBufferImpl res = new ByteBufferImpl (backing_buffer);\n+    res.limit ((limit () * 1) / 2);\n+    return res;\n+  }\n \n   \n   public boolean isReadOnly()\n   {\n-    return ro;\n+    return readOnly;\n   }\n   \n   public CharBuffer slice()\n   {\n-    CharBufferImpl buffer = new CharBufferImpl (this);\n-    buffer.array_offset = position ();\n-    return buffer;\n+    return new CharBufferImpl (this);\n   }\n   \n   public CharBuffer duplicate()\n@@ -144,9 +108,9 @@ public CharBuffer duplicate()\n   \n   public CharBuffer asReadOnlyBuffer()\n   {\n-    CharBufferImpl a = new CharBufferImpl(this);\n-    a.ro = true;\n-    return a;\n+    CharBufferImpl result = new CharBufferImpl (this);\n+    result.readOnly = true;\n+    return result;\n   }\n   \n   public CharBuffer compact()\n@@ -156,7 +120,7 @@ public CharBuffer compact()\n   \n   public boolean isDirect()\n   {\n-    return backing_buffer != null;\n+    return false;\n   }\n \n   final public CharSequence subSequence (int start, int end)\n@@ -172,41 +136,71 @@ end > length () ||\n                                position () + end);\n   }\n   \n+  /**\n+   * Relative get method. Reads the next character from the buffer.\n+   */\n   final public char get()\n   {\n     char e = backing_buffer[position()];\n     position(position()+1);\n     return e;\n   }\n   \n+  /**\n+   * Relative put method. Writes <code>value</code> to the next position\n+   * in the buffer.\n+   * \n+   * @exception ReadOnlyBufferException If this buffer is read-only.\n+   */\n   final public CharBuffer put(char b)\n   {\n+    if (readOnly)\n+      throw new ReadOnlyBufferException ();\n+    \n     backing_buffer[position()] = b;\n     position(position()+1);\n     return this;\n   }\n-  \n-  final public char getChar() { return get(); } final public CharBuffer putChar(char value) { return put(value); } final public char getChar(int index) { return get(index); } final public CharBuffer putChar(int index, char value) { return put(index, value); };\n-  final public short getShort() { short a = nio_get_Short(this, position(), limit()); inc_pos(2); return a; } final public CharBuffer putShort(short value) { nio_put_Short(this, position(), limit(), value); inc_pos(2); return this; } final public short getShort(int index) { short a = nio_get_Short(this, index, limit()); return a; } final public CharBuffer putShort(int index, short value) { nio_put_Short(this, index, limit(), value); return this; };\n-  final public int getInt() { int a = nio_get_Int(this, position(), limit()); inc_pos(4); return a; } final public CharBuffer putInt(int value) { nio_put_Int(this, position(), limit(), value); inc_pos(4); return this; } final public int getInt(int index) { int a = nio_get_Int(this, index, limit()); return a; } final public CharBuffer putInt(int index, int value) { nio_put_Int(this, index, limit(), value); return this; };\n-  final public long getLong() { long a = nio_get_Long(this, position(), limit()); inc_pos(8); return a; } final public CharBuffer putLong(long value) { nio_put_Long(this, position(), limit(), value); inc_pos(8); return this; } final public long getLong(int index) { long a = nio_get_Long(this, index, limit()); return a; } final public CharBuffer putLong(int index, long value) { nio_put_Long(this, index, limit(), value); return this; };\n-  final public float getFloat() { float a = nio_get_Float(this, position(), limit()); inc_pos(4); return a; } final public CharBuffer putFloat(float value) { nio_put_Float(this, position(), limit(), value); inc_pos(4); return this; } final public float getFloat(int index) { float a = nio_get_Float(this, index, limit()); return a; } final public CharBuffer putFloat(int index, float value) { nio_put_Float(this, index, limit(), value); return this; };\n-  final public double getDouble() { double a = nio_get_Double(this, position(), limit()); inc_pos(8); return a; } final public CharBuffer putDouble(double value) { nio_put_Double(this, position(), limit(), value); inc_pos(8); return this; } final public double getDouble(int index) { double a = nio_get_Double(this, index, limit()); return a; } final public CharBuffer putDouble(int index, double value) { nio_put_Double(this, index, limit(), value); return this; };\n \n+  /**\n+   * Absolute get method. Reads the character at position <code>index</code>.\n+   *\n+   * @exception IndexOutOfBoundsException If index is negative or not smaller\n+   * than the buffer's limit.\n+   */\n   final public char get(int index)\n   {\n+    if (index < 0\n+        || index >= limit ())\n+      throw new IndexOutOfBoundsException ();\n+    \n     return backing_buffer[index];\n   }\n   \n+  /**\n+   * Absolute put method. Writes <code>value</value> to position\n+   * <code>index</code> in the buffer.\n+   *\n+   * @exception IndexOutOfBoundsException If index is negative or not smaller\n+   * than the buffer's limit.\n+   * @exception ReadOnlyBufferException If this buffer is read-only.\n+   */\n   final public CharBuffer put(int index, char b)\n   {\n+    if (index < 0\n+        || index >= limit ())\n+      throw new IndexOutOfBoundsException ();\n+    \n+    if (readOnly)\n+      throw new ReadOnlyBufferException ();\n+    \n     backing_buffer[index] = b;\n     return this;\n   }\n \n \n   public final ByteOrder order()\n   {\n-    return endian;\n+    return ByteOrder.BIG_ENDIAN;\n   }\n }"}, {"sha": "973487555cb54cb7e45f63710ca90f0716afa8fd", "filename": "libjava/gnu/java/nio/DoubleBufferImpl.java", "status": "modified", "additions": 44, "deletions": 74, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/248606ee91171899cccbfafeead6ff6e6039ea6d/libjava%2Fgnu%2Fjava%2Fnio%2FDoubleBufferImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/248606ee91171899cccbfafeead6ff6e6039ea6d/libjava%2Fgnu%2Fjava%2Fnio%2FDoubleBufferImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnio%2FDoubleBufferImpl.java?ref=248606ee91171899cccbfafeead6ff6e6039ea6d", "patch": "@@ -38,100 +38,66 @@\n package gnu.java.nio;\n \n import java.nio.ByteBuffer;\n-import java.nio.CharBuffer;\n+import java.nio.ByteOrder;\n import java.nio.DoubleBuffer;\n-import java.nio.FloatBuffer;\n-import java.nio.IntBuffer;\n-import java.nio.LongBuffer;\n-import java.nio.ShortBuffer;\n+import java.nio.ReadOnlyBufferException;\n \n+/**\n+ * This is a Heap memory implementation\n+ */\n public final class DoubleBufferImpl extends DoubleBuffer\n {\n-  private int array_offset;\n-  private boolean ro;\n+  private boolean readOnly;\n   \n   public DoubleBufferImpl(int cap, int off, int lim)\n   {\n+    super (cap, lim, off, 0);\n     this.backing_buffer = new double[cap];\n-    this.cap = cap;\n-    this.limit(lim);\n-    this.position(off);\n+    readOnly = false;\n   }\n   \n   public DoubleBufferImpl(double[] array, int off, int lim)\n   {\n+    super (array.length, lim, off, 0);\n     this.backing_buffer = array;\n-    this.cap = array.length;\n-    this.limit(lim);\n-    this.position(off);\n+    readOnly = false;\n   }\n \n   public DoubleBufferImpl(DoubleBufferImpl copy)\n   {\n+    super (copy.capacity (), copy.limit (), copy.position (), 0);\n     backing_buffer = copy.backing_buffer;\n-    ro = copy.ro;\n-    limit(copy.limit());\n-    position(copy.position());\n+    readOnly = copy.isReadOnly ();\n   }\n   \n-  void inc_pos(int a)\n+  DoubleBufferImpl (byte[] copy)\n   {\n-    position(position() + a);\n+    super (copy.length, copy.length, 0, 0);\n+    this.backing_buffer = copy != null ? nio_cast (copy) : null;\n+    readOnly = false;\n   }\n-  \n-  DoubleBufferImpl(byte[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n-  private static native byte nio_get_Byte(DoubleBufferImpl b, int index, int limit);\n-  private static native void nio_put_Byte(DoubleBufferImpl b, int index, int limit, byte value);\n-  public ByteBuffer asByteBuffer() { ByteBufferImpl res = new ByteBufferImpl(backing_buffer); res.limit((limit()*1)/8); return res; }\n-\n-  DoubleBufferImpl(char[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n-  private static native char nio_get_Char(DoubleBufferImpl b, int index, int limit);\n-  private static native void nio_put_Char(DoubleBufferImpl b, int index, int limit, char value);\n-  public CharBuffer asCharBuffer() { CharBufferImpl res = new CharBufferImpl(backing_buffer); res.limit((limit()*2)/8); return res; }\n-\n-  DoubleBufferImpl(short[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n-  private static native short nio_get_Short(DoubleBufferImpl b, int index, int limit);\n-  private static native void nio_put_Short(DoubleBufferImpl b, int index, int limit, short value);\n-  public ShortBuffer asShortBuffer() { ShortBufferImpl res = new ShortBufferImpl(backing_buffer); res.limit((limit()*2)/8); return res; }\n \n-  DoubleBufferImpl(int[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n-  private static native int nio_get_Int(DoubleBufferImpl b, int index, int limit);\n-  private static native void nio_put_Int(DoubleBufferImpl b, int index, int limit, int value);\n-  public IntBuffer asIntBuffer() { IntBufferImpl res = new IntBufferImpl(backing_buffer); res.limit((limit()*4)/8); return res; }\n+  private static native byte nio_get_Byte (DoubleBufferImpl b, int index, int limit);\n \n-  DoubleBufferImpl(long[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n-  private static native long nio_get_Long(DoubleBufferImpl b, int index, int limit);\n-  private static native void nio_put_Long(DoubleBufferImpl b, int index, int limit, long value);\n-  public LongBuffer asLongBuffer() { LongBufferImpl res = new LongBufferImpl(backing_buffer); res.limit((limit()*8)/8); return res; }\n+  private static native void nio_put_Byte (DoubleBufferImpl b, int index, int limit, byte value);\n \n-  DoubleBufferImpl(float[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n-  private static native float nio_get_Float(DoubleBufferImpl b, int index, int limit);\n-  private static native void nio_put_Float(DoubleBufferImpl b, int index, int limit, float value);\n-  public FloatBuffer asFloatBuffer() { FloatBufferImpl res = new FloatBufferImpl(backing_buffer); res.limit((limit()*4)/8); return res; }\n-\n-  DoubleBufferImpl(double[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n-  private static native double nio_get_Double(DoubleBufferImpl b, int index, int limit);\n-  private static native void nio_put_Double(DoubleBufferImpl b, int index, int limit, double value);\n-  public DoubleBuffer asDoubleBuffer() { DoubleBufferImpl res = new DoubleBufferImpl(backing_buffer); res.limit((limit()*8)/8); return res; }\n+  public ByteBuffer asByteBuffer ()\n+  {\n+    ByteBufferImpl res = new ByteBufferImpl (backing_buffer);\n+    res.limit ((limit () * 1) / 8);\n+    return res;\n+  }\n \n-  private static native double[] nio_cast(byte[]copy);\n-  private static native double[] nio_cast(char[]copy);\n-  private static native double[] nio_cast(short[]copy);\n-  private static native double[] nio_cast(long[]copy);\n-  private static native double[] nio_cast(int[]copy);\n-  private static native double[] nio_cast(float[]copy);\n-  private static native double[] nio_cast(double[]copy);\n+  private static native double[] nio_cast (byte[] copy);\n \n-  public boolean isReadOnly()\n+  public boolean isReadOnly ()\n   {\n-    return ro;\n+    return readOnly;\n   }\n \n-  public DoubleBuffer slice()\n+  public DoubleBuffer slice ()\n   {\n-    DoubleBufferImpl A = new DoubleBufferImpl(this);\n-    A.array_offset = position();\n-    return A;\n+    return new DoubleBufferImpl (this);\n   }\n \n   public DoubleBuffer duplicate()\n@@ -141,9 +107,9 @@ public DoubleBuffer duplicate()\n \n   public DoubleBuffer asReadOnlyBuffer()\n   {\n-    DoubleBufferImpl a = new DoubleBufferImpl(this);\n-    a.ro = true;\n-    return a;\n+    DoubleBufferImpl result = new DoubleBufferImpl (this);\n+    result.readOnly = true;\n+    return result;\n   }\n \n   public DoubleBuffer compact()\n@@ -153,7 +119,7 @@ public DoubleBuffer compact()\n \n   public boolean isDirect()\n   {\n-    return backing_buffer != null;\n+    return false;\n   }\n \n   final public double get()\n@@ -165,6 +131,9 @@ final public double get()\n \n   final public DoubleBuffer put(double b)\n   {\n+    if (readOnly)\n+      throw new ReadOnlyBufferException ();\n+    \n     backing_buffer[position()] = b;\n     position(position()+1);\n     return this;\n@@ -177,14 +146,15 @@ final public double get(int index)\n \n   final public DoubleBuffer put(int index, double b)\n   {\n+    if (readOnly)\n+      throw new ReadOnlyBufferException ();\n+    \n     backing_buffer[index] = b;\n     return this;\n   }\n-\n-  final public char getChar() { char a = nio_get_Char(this, position(), limit()); inc_pos(2); return a; } final public DoubleBuffer putChar(char value) { nio_put_Char(this, position(), limit(), value); inc_pos(2); return this; } final public char getChar(int index) { char a = nio_get_Char(this, index, limit()); return a; } final public DoubleBuffer putChar(int index, char value) { nio_put_Char(this, index, limit(), value); return this; };\n-  final public short getShort() { short a = nio_get_Short(this, position(), limit()); inc_pos(2); return a; } final public DoubleBuffer putShort(short value) { nio_put_Short(this, position(), limit(), value); inc_pos(2); return this; } final public short getShort(int index) { short a = nio_get_Short(this, index, limit()); return a; } final public DoubleBuffer putShort(int index, short value) { nio_put_Short(this, index, limit(), value); return this; };\n-  final public int getInt() { int a = nio_get_Int(this, position(), limit()); inc_pos(4); return a; } final public DoubleBuffer putInt(int value) { nio_put_Int(this, position(), limit(), value); inc_pos(4); return this; } final public int getInt(int index) { int a = nio_get_Int(this, index, limit()); return a; } final public DoubleBuffer putInt(int index, int value) { nio_put_Int(this, index, limit(), value); return this; };\n-  final public long getLong() { long a = nio_get_Long(this, position(), limit()); inc_pos(8); return a; } final public DoubleBuffer putLong(long value) { nio_put_Long(this, position(), limit(), value); inc_pos(8); return this; } final public long getLong(int index) { long a = nio_get_Long(this, index, limit()); return a; } final public DoubleBuffer putLong(int index, long value) { nio_put_Long(this, index, limit(), value); return this; };\n-  final public float getFloat() { float a = nio_get_Float(this, position(), limit()); inc_pos(4); return a; } final public DoubleBuffer putFloat(float value) { nio_put_Float(this, position(), limit(), value); inc_pos(4); return this; } final public float getFloat(int index) { float a = nio_get_Float(this, index, limit()); return a; } final public DoubleBuffer putFloat(int index, float value) { nio_put_Float(this, index, limit(), value); return this; };\n-  final public double getDouble() { return get(); } final public DoubleBuffer putDouble(double value) { return put(value); } final public double getDouble(int index) { return get(index); } final public DoubleBuffer putDouble(int index, double value) { return put(index, value); };\n+  \n+  final public ByteOrder order ()\n+  {\n+    return ByteOrder.BIG_ENDIAN;\n+  }\n }"}, {"sha": "27a8deaf1c2559f26214ab58f7c57c810539856b", "filename": "libjava/gnu/java/nio/FloatBufferImpl.java", "status": "modified", "additions": 38, "deletions": 74, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/248606ee91171899cccbfafeead6ff6e6039ea6d/libjava%2Fgnu%2Fjava%2Fnio%2FFloatBufferImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/248606ee91171899cccbfafeead6ff6e6039ea6d/libjava%2Fgnu%2Fjava%2Fnio%2FFloatBufferImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnio%2FFloatBufferImpl.java?ref=248606ee91171899cccbfafeead6ff6e6039ea6d", "patch": "@@ -38,49 +38,49 @@\n package gnu.java.nio;\n \n import java.nio.ByteBuffer;\n-import java.nio.CharBuffer;\n-import java.nio.DoubleBuffer;\n+import java.nio.ByteOrder;\n import java.nio.FloatBuffer;\n-import java.nio.IntBuffer;\n-import java.nio.LongBuffer;\n-import java.nio.ShortBuffer;\n+import java.nio.ReadOnlyBufferException;\n \n+/**\n+ * This is a Heap memory implementation\n+ */\n public final class FloatBufferImpl extends FloatBuffer\n {\n-  private int array_offset;\n-  private boolean ro;\n+  private boolean readOnly;\n   \n   public FloatBufferImpl(int cap, int off, int lim)\n   {\n-    this.backing_buffer = new float[cap];\n-    this.cap = cap;\n-    this.limit(lim);\n-    this.position(off);\n+    super (cap, lim, off, 0);\n+    this.backing_buffer = new float [cap];\n+    readOnly = false;\n   }\n   \n   public FloatBufferImpl(float[] array, int off, int lim)\n   {\n+    super (array.length, lim, off, 0);\n     this.backing_buffer = array;\n-    this.cap = array.length;\n-    this.limit(lim);\n-    this.position(off);\n+    readOnly = false;\n   }\n   \n   public FloatBufferImpl(FloatBufferImpl copy)\n   {\n+    super (copy.capacity (), copy.limit (), copy.position (), 0);\n     backing_buffer = copy.backing_buffer;\n-    ro = copy.ro;\n-    limit(copy.limit());\n-    position(copy.position());\n+    readOnly = copy.isReadOnly ();\n   }\n   \n-  void inc_pos(int a)\n+  private static native float[] nio_cast (byte[] copy);\n+  \n+  FloatBufferImpl (byte[] copy)\n   {\n-    position(position() + a);\n+    super (copy.length, copy.length, 0, 0);\n+    this.backing_buffer = copy != null ? nio_cast  (copy) : null;\n+    readOnly = false;\n   }\n-  \n-  FloatBufferImpl(byte[] copy) { this.backing_buffer = copy != null ? nio_cast (copy) : null; }\n+\n   private static native byte nio_get_Byte (FloatBufferImpl b, int index, int limit);\n+\n   private static native void nio_put_Byte (FloatBufferImpl b, int index, int limit, byte value);\n \n   public ByteBuffer asByteBuffer()\n@@ -90,54 +90,14 @@ public ByteBuffer asByteBuffer()\n     return res;\n   }\n   \n-  FloatBufferImpl(char[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n-  private static native char nio_get_Char(FloatBufferImpl b, int index, int limit);\n-  private static native void nio_put_Char(FloatBufferImpl b, int index, int limit, char value);\n-  public CharBuffer asCharBuffer() { CharBufferImpl res = new CharBufferImpl(backing_buffer); res.limit((limit()*2)/4); return res; }\n-\n-  FloatBufferImpl(short[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n-  private static native short nio_get_Short(FloatBufferImpl b, int index, int limit);\n-  private static native void nio_put_Short(FloatBufferImpl b, int index, int limit, short value);\n-  public ShortBuffer asShortBuffer() { ShortBufferImpl res = new ShortBufferImpl(backing_buffer); res.limit((limit()*2)/4); return res; }\n-  \n-  FloatBufferImpl(int[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n-  private static native int nio_get_Int(FloatBufferImpl b, int index, int limit);\n-  private static native void nio_put_Int(FloatBufferImpl b, int index, int limit, int value);\n-  public IntBuffer asIntBuffer() { IntBufferImpl res = new IntBufferImpl(backing_buffer); res.limit((limit()*4)/4); return res; }\n-  \n-  FloatBufferImpl(long[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n-  private static native long nio_get_Long(FloatBufferImpl b, int index, int limit);\n-  private static native void nio_put_Long(FloatBufferImpl b, int index, int limit, long value);\n-  public LongBuffer asLongBuffer() { LongBufferImpl res = new LongBufferImpl(backing_buffer); res.limit((limit()*8)/4); return res; }\n-\n-  FloatBufferImpl(float[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n-  private static native float nio_get_Float(FloatBufferImpl b, int index, int limit);\n-  private static native void nio_put_Float(FloatBufferImpl b, int index, int limit, float value);\n-  public FloatBuffer asFloatBuffer() { FloatBufferImpl res = new FloatBufferImpl(backing_buffer); res.limit((limit()*4)/4); return res; }\n-\n-  FloatBufferImpl(double[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n-  private static native double nio_get_Double(FloatBufferImpl b, int index, int limit);\n-  private static native void nio_put_Double(FloatBufferImpl b, int index, int limit, double value);\n-  public DoubleBuffer asDoubleBuffer() { DoubleBufferImpl res = new DoubleBufferImpl(backing_buffer); res.limit((limit()*8)/4); return res; }\n-\n-  private static native float[] nio_cast(byte[]copy);\n-  private static native float[] nio_cast(char[]copy);\n-  private static native float[] nio_cast(short[]copy);\n-  private static native float[] nio_cast(long[]copy);\n-  private static native float[] nio_cast(int[]copy);\n-  private static native float[] nio_cast(float[]copy);\n-  private static native float[] nio_cast(double[]copy);\n-  \n-  public boolean isReadOnly()\n+  public boolean isReadOnly ()\n   {\n-    return ro;\n+    return readOnly;\n   }\n   \n   public FloatBuffer slice()\n   {\n-    FloatBufferImpl A = new FloatBufferImpl(this);\n-    A.array_offset = position();\n-    return A;\n+    return new FloatBufferImpl (this);\n   }\n   \n   public FloatBuffer duplicate()\n@@ -147,9 +107,9 @@ public FloatBuffer duplicate()\n   \n   public FloatBuffer asReadOnlyBuffer()\n   {\n-    FloatBufferImpl a = new FloatBufferImpl(this);\n-    a.ro = true;\n-    return a;\n+    FloatBufferImpl result = new FloatBufferImpl (this);\n+    result.readOnly = true;\n+    return result;\n   }\n   \n   public FloatBuffer compact()\n@@ -159,7 +119,7 @@ public FloatBuffer compact()\n   \n   public boolean isDirect()\n   {\n-    return backing_buffer != null;\n+    return false;\n   }\n   \n   final public float get()\n@@ -171,6 +131,9 @@ final public float get()\n   \n   final public FloatBuffer put(float b)\n   {\n+    if (readOnly)\n+      throw new ReadOnlyBufferException ();\n+    \n     backing_buffer[position()] = b;\n     position(position()+1);\n     return this;\n@@ -183,14 +146,15 @@ final public float get(int index)\n   \n   final public FloatBuffer put(int index, float b)\n   {\n+    if (readOnly)\n+      throw new ReadOnlyBufferException ();\n+    \n     backing_buffer[index] = b;\n     return this;\n   }\n   \n-  final public char getChar() { char a = nio_get_Char(this, position(), limit()); inc_pos(2); return a; } final public FloatBuffer putChar(char value) { nio_put_Char(this, position(), limit(), value); inc_pos(2); return this; } final public char getChar(int index) { char a = nio_get_Char(this, index, limit()); return a; } final public FloatBuffer putChar(int index, char value) { nio_put_Char(this, index, limit(), value); return this; };\n-  final public short getShort() { short a = nio_get_Short(this, position(), limit()); inc_pos(2); return a; } final public FloatBuffer putShort(short value) { nio_put_Short(this, position(), limit(), value); inc_pos(2); return this; } final public short getShort(int index) { short a = nio_get_Short(this, index, limit()); return a; } final public FloatBuffer putShort(int index, short value) { nio_put_Short(this, index, limit(), value); return this; };\n-  final public int getInt() { int a = nio_get_Int(this, position(), limit()); inc_pos(4); return a; } final public FloatBuffer putInt(int value) { nio_put_Int(this, position(), limit(), value); inc_pos(4); return this; } final public int getInt(int index) { int a = nio_get_Int(this, index, limit()); return a; } final public FloatBuffer putInt(int index, int value) { nio_put_Int(this, index, limit(), value); return this; };\n-  final public long getLong() { long a = nio_get_Long(this, position(), limit()); inc_pos(8); return a; } final public FloatBuffer putLong(long value) { nio_put_Long(this, position(), limit(), value); inc_pos(8); return this; } final public long getLong(int index) { long a = nio_get_Long(this, index, limit()); return a; } final public FloatBuffer putLong(int index, long value) { nio_put_Long(this, index, limit(), value); return this; };\n-  final public float getFloat() { return get(); } final public FloatBuffer putFloat(float value) { return put(value); } final public float getFloat(int index) { return get(index); } final public FloatBuffer putFloat(int index, float value) { return put(index, value); };\n-  final public double getDouble() { double a = nio_get_Double(this, position(), limit()); inc_pos(8); return a; } final public FloatBuffer putDouble(double value) { nio_put_Double(this, position(), limit(), value); inc_pos(8); return this; } final public double getDouble(int index) { double a = nio_get_Double(this, index, limit()); return a; } final public FloatBuffer putDouble(int index, double value) { nio_put_Double(this, index, limit(), value); return this; };\n+  final public ByteOrder order ()\n+  {\n+    return ByteOrder.BIG_ENDIAN;\n+  }\n }"}, {"sha": "fda2d68e00a2cf7151021f9f70d803f2b56f5b76", "filename": "libjava/gnu/java/nio/IntBufferImpl.java", "status": "modified", "additions": 43, "deletions": 73, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/248606ee91171899cccbfafeead6ff6e6039ea6d/libjava%2Fgnu%2Fjava%2Fnio%2FIntBufferImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/248606ee91171899cccbfafeead6ff6e6039ea6d/libjava%2Fgnu%2Fjava%2Fnio%2FIntBufferImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnio%2FIntBufferImpl.java?ref=248606ee91171899cccbfafeead6ff6e6039ea6d", "patch": "@@ -38,100 +38,66 @@\n package gnu.java.nio;\n \n import java.nio.ByteBuffer;\n-import java.nio.CharBuffer;\n-import java.nio.DoubleBuffer;\n-import java.nio.FloatBuffer;\n+import java.nio.ByteOrder;\n import java.nio.IntBuffer;\n-import java.nio.LongBuffer;\n-import java.nio.ShortBuffer;\n+import java.nio.ReadOnlyBufferException;\n \n+/**\n+ * This is a Heap memory implementation\n+ */\n public final class IntBufferImpl extends IntBuffer\n {\n-  private int array_offset;\n-  private boolean ro;\n+  private boolean readOnly;\n   \n   public IntBufferImpl(int cap, int off, int lim)\n   {\n+    super (cap, lim, off, 0);\n     this.backing_buffer = new int[cap];\n-    this.cap = cap;\n-    this.limit(lim);\n-    this.position(off);\n+    readOnly = false;\n   }\n \n   public IntBufferImpl(int[] array, int off, int lim)\n   {\n+    super (array.length, lim, off, 0);\n     this.backing_buffer = array;\n-    this.cap = array.length;\n-    this.limit(lim);\n-    this.position(off);\n+    readOnly = false;\n   }\n \n   public IntBufferImpl(IntBufferImpl copy)\n   {\n+    super (copy.capacity (), copy.limit (), copy.position (), 0);\n     backing_buffer = copy.backing_buffer;\n-    ro = copy.ro;\n-    limit(copy.limit());\n-    position(copy.position());\n+    readOnly = copy.isReadOnly ();\n   }\n \n-  void inc_pos(int a)\n+  private static native int[] nio_cast (byte[] copy);\n+\n+  IntBufferImpl (byte[] copy)\n   {\n-    position(position() + a);\n+    super (copy.length, copy.length, 0, 0);\n+    this.backing_buffer = copy != null ? nio_cast (copy) : null;\n+    readOnly = false;\n   }\n \n-  IntBufferImpl(byte[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n-  private static native byte nio_get_Byte(IntBufferImpl b, int index, int limit);\n-  private static native void nio_put_Byte(IntBufferImpl b, int index, int limit, byte value);\n-  public ByteBuffer asByteBuffer() { ByteBufferImpl res = new ByteBufferImpl(backing_buffer); res.limit((limit()*1)/4); return res; }\n-\n-  IntBufferImpl(char[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n-  private static native char nio_get_Char(IntBufferImpl b, int index, int limit);\n-  private static native void nio_put_Char(IntBufferImpl b, int index, int limit, char value);\n-  public CharBuffer asCharBuffer() { CharBufferImpl res = new CharBufferImpl(backing_buffer); res.limit((limit()*2)/4); return res; }\n-\n-  IntBufferImpl(short[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n-  private static native short nio_get_Short(IntBufferImpl b, int index, int limit);\n-  private static native void nio_put_Short(IntBufferImpl b, int index, int limit, short value);\n-  public ShortBuffer asShortBuffer() { ShortBufferImpl res = new ShortBufferImpl(backing_buffer); res.limit((limit()*2)/4); return res; }\n-\n-  IntBufferImpl(int[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n-  private static native int nio_get_Int(IntBufferImpl b, int index, int limit);\n-  private static native void nio_put_Int(IntBufferImpl b, int index, int limit, int value);\n-  public IntBuffer asIntBuffer() { IntBufferImpl res = new IntBufferImpl(backing_buffer); res.limit((limit()*4)/4); return res; }\n-\n-  IntBufferImpl(long[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n-  private static native long nio_get_Long(IntBufferImpl b, int index, int limit);\n-  private static native void nio_put_Long(IntBufferImpl b, int index, int limit, long value);\n-  public LongBuffer asLongBuffer() { LongBufferImpl res = new LongBufferImpl(backing_buffer); res.limit((limit()*8)/4); return res; }\n-\n-  IntBufferImpl(float[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n-  private static native float nio_get_Float(IntBufferImpl b, int index, int limit);\n-  private static native void nio_put_Float(IntBufferImpl b, int index, int limit, float value);\n-  public FloatBuffer asFloatBuffer() { FloatBufferImpl res = new FloatBufferImpl(backing_buffer); res.limit((limit()*4)/4); return res; }\n+  private static native byte nio_get_Byte (IntBufferImpl b, int index, int limit);\n \n-  IntBufferImpl(double[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n-  private static native double nio_get_Double(IntBufferImpl b, int index, int limit);\n-  private static native void nio_put_Double(IntBufferImpl b, int index, int limit, double value);\n-  public DoubleBuffer asDoubleBuffer() { DoubleBufferImpl res = new DoubleBufferImpl(backing_buffer); res.limit((limit()*8)/4); return res; }\n+  private static native void nio_put_Byte (IntBufferImpl b, int index, int limit, byte value);\n \n-  private static native int[] nio_cast(byte[]copy);\n-  private static native int[] nio_cast(char[]copy);\n-  private static native int[] nio_cast(short[]copy);\n-  private static native int[] nio_cast(long[]copy);\n-  private static native int[] nio_cast(int[]copy);\n-  private static native int[] nio_cast(float[]copy);\n-  private static native int[] nio_cast(double[]copy);\n+  public ByteBuffer asByteBuffer ()\n+  {\n+    ByteBufferImpl res = new ByteBufferImpl (backing_buffer);\n+    res.limit ((limit () * 1) / 4);\n+    return res;\n+  }\n \n   public boolean isReadOnly()\n   {\n-    return ro;\n+    return readOnly;\n   }\n \n   public IntBuffer slice()\n   {\n-    IntBufferImpl A = new IntBufferImpl(this);\n-    A.array_offset = position();\n-    return A;\n+    return new IntBufferImpl (this);\n   }\n \n   public IntBuffer duplicate()\n@@ -141,9 +107,9 @@ public IntBuffer duplicate()\n \n   public IntBuffer asReadOnlyBuffer()\n   {\n-    IntBufferImpl a = new IntBufferImpl(this);\n-    a.ro = true;\n-    return a;\n+    IntBufferImpl result = new IntBufferImpl (this);\n+    result.readOnly = true;\n+    return result;\n   }\n \n   public IntBuffer compact()\n@@ -153,7 +119,7 @@ public IntBuffer compact()\n \n   public boolean isDirect()\n   {\n-    return backing_buffer != null;\n+    return false;\n   }\n \n   final public int get()\n@@ -165,6 +131,9 @@ final public int get()\n \n   final public IntBuffer put(int b)\n   {\n+    if (readOnly)\n+      throw new ReadOnlyBufferException ();\n+    \n     backing_buffer[position()] = b;\n     position(position()+1);\n     return this;\n@@ -177,14 +146,15 @@ final public int get(int index)\n \n   final public IntBuffer put(int index, int b)\n   {\n+    if (readOnly)\n+      throw new ReadOnlyBufferException ();\n+    \n     backing_buffer[index] = b;\n     return this;\n   }\n-\n-  final public char getChar() { char a = nio_get_Char(this, position(), limit()); inc_pos(2); return a; } final public IntBuffer putChar(char value) { nio_put_Char(this, position(), limit(), value); inc_pos(2); return this; } final public char getChar(int index) { char a = nio_get_Char(this, index, limit()); return a; } final public IntBuffer putChar(int index, char value) { nio_put_Char(this, index, limit(), value); return this; };\n-  final public short getShort() { short a = nio_get_Short(this, position(), limit()); inc_pos(2); return a; } final public IntBuffer putShort(short value) { nio_put_Short(this, position(), limit(), value); inc_pos(2); return this; } final public short getShort(int index) { short a = nio_get_Short(this, index, limit()); return a; } final public IntBuffer putShort(int index, short value) { nio_put_Short(this, index, limit(), value); return this; };\n-  final public int getInt() { return get(); } final public IntBuffer putInt(int value) { return put(value); } final public int getInt(int index) { return get(index); } final public IntBuffer putInt(int index, int value) { return put(index, value); };\n-  final public long getLong() { long a = nio_get_Long(this, position(), limit()); inc_pos(8); return a; } final public IntBuffer putLong(long value) { nio_put_Long(this, position(), limit(), value); inc_pos(8); return this; } final public long getLong(int index) { long a = nio_get_Long(this, index, limit()); return a; } final public IntBuffer putLong(int index, long value) { nio_put_Long(this, index, limit(), value); return this; };\n-  final public float getFloat() { float a = nio_get_Float(this, position(), limit()); inc_pos(4); return a; } final public IntBuffer putFloat(float value) { nio_put_Float(this, position(), limit(), value); inc_pos(4); return this; } final public float getFloat(int index) { float a = nio_get_Float(this, index, limit()); return a; } final public IntBuffer putFloat(int index, float value) { nio_put_Float(this, index, limit(), value); return this; };\n-  final public double getDouble() { double a = nio_get_Double(this, position(), limit()); inc_pos(8); return a; } final public IntBuffer putDouble(double value) { nio_put_Double(this, position(), limit(), value); inc_pos(8); return this; } final public double getDouble(int index) { double a = nio_get_Double(this, index, limit()); return a; } final public IntBuffer putDouble(int index, double value) { nio_put_Double(this, index, limit(), value); return this; };\n+  \n+  final public ByteOrder order ()\n+  {\n+    return ByteOrder.BIG_ENDIAN;\n+  }\n }"}, {"sha": "5dc4992066a10b9817e2085d8392154f64417906", "filename": "libjava/gnu/java/nio/LongBufferImpl.java", "status": "modified", "additions": 42, "deletions": 72, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/248606ee91171899cccbfafeead6ff6e6039ea6d/libjava%2Fgnu%2Fjava%2Fnio%2FLongBufferImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/248606ee91171899cccbfafeead6ff6e6039ea6d/libjava%2Fgnu%2Fjava%2Fnio%2FLongBufferImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnio%2FLongBufferImpl.java?ref=248606ee91171899cccbfafeead6ff6e6039ea6d", "patch": "@@ -38,100 +38,66 @@\n package gnu.java.nio;\n \n import java.nio.ByteBuffer;\n-import java.nio.CharBuffer;\n-import java.nio.DoubleBuffer;\n-import java.nio.FloatBuffer;\n-import java.nio.IntBuffer;\n+import java.nio.ByteOrder;\n import java.nio.LongBuffer;\n-import java.nio.ShortBuffer;\n+import java.nio.ReadOnlyBufferException;\n \n+/**\n+ * This is a Heap memory implementation\n+ */\n public final class LongBufferImpl extends LongBuffer\n {\n-  private int array_offset;\n-  private boolean ro;\n+  private boolean readOnly;\n \n   public LongBufferImpl(int cap, int off, int lim)\n   {\n+    super (cap, lim, off, 0);\n     this.backing_buffer = new long[cap];\n-    this.cap = cap ;\n-    this.limit(lim);\n-    this.position(off);\n+    readOnly = false;\n   }\n \n   public LongBufferImpl(long[] array, int off, int lim)\n   {\n+    super (array.length, lim, off, 0);\n     this.backing_buffer = array;\n-    this.cap = array.length;\n-    this.limit(lim);\n-    this.position(off);\n+    readOnly = false;\n   }\n \n   public LongBufferImpl(LongBufferImpl copy)\n   {\n+    super (copy.capacity (), copy.limit (), copy.position (), 0);\n     backing_buffer = copy.backing_buffer;\n-    ro = copy.ro;\n-    limit(copy.limit());\n-    position(copy.position());\n+    readOnly = copy.isReadOnly ();\n   }\n \n-  void inc_pos(int a)\n+  private static native long[] nio_cast (byte[] copy);\n+\n+  LongBufferImpl (byte[] copy)\n   {\n-    position(position() + a);\n+    super (copy.length, copy.length, 0, 0);\n+    this.backing_buffer = copy != null ? nio_cast (copy) : null;\n+    readOnly = false;\n   }\n \n-  LongBufferImpl(byte[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n-  private static native byte nio_get_Byte(LongBufferImpl b, int index, int limit);\n-  private static native void nio_put_Byte(LongBufferImpl b, int index, int limit, byte value);\n-  public ByteBuffer asByteBuffer() { ByteBufferImpl res = new ByteBufferImpl(backing_buffer); res.limit((limit()*1)/8); return res; }\n-\n-  LongBufferImpl(char[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n-  private static native char nio_get_Char(LongBufferImpl b, int index, int limit);\n-  private static native void nio_put_Char(LongBufferImpl b, int index, int limit, char value);\n-  public CharBuffer asCharBuffer() { CharBufferImpl res = new CharBufferImpl(backing_buffer); res.limit((limit()*2)/8); return res; }\n-\n-  LongBufferImpl(short[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n-  private static native short nio_get_Short(LongBufferImpl b, int index, int limit);\n-  private static native void nio_put_Short(LongBufferImpl b, int index, int limit, short value);\n-  public ShortBuffer asShortBuffer() { ShortBufferImpl res = new ShortBufferImpl(backing_buffer); res.limit((limit()*2)/8); return res; }\n-\n-  LongBufferImpl(int[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n-  private static native int nio_get_Int(LongBufferImpl b, int index, int limit);\n-  private static native void nio_put_Int(LongBufferImpl b, int index, int limit, int value);\n-  public IntBuffer asIntBuffer() { IntBufferImpl res = new IntBufferImpl(backing_buffer); res.limit((limit()*4)/8); return res; }\n-\n-  LongBufferImpl(long[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n-  private static native long nio_get_Long(LongBufferImpl b, int index, int limit);\n-  private static native void nio_put_Long(LongBufferImpl b, int index, int limit, long value);\n-  public LongBuffer asLongBuffer() { LongBufferImpl res = new LongBufferImpl(backing_buffer); res.limit((limit()*8)/8); return res; }\n+  private static native byte nio_get_Byte (LongBufferImpl b, int index, int limit);\n \n-  LongBufferImpl(float[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n-  private static native float nio_get_Float(LongBufferImpl b, int index, int limit);\n-  private static native void nio_put_Float(LongBufferImpl b, int index, int limit, float value);\n-  public FloatBuffer asFloatBuffer() { FloatBufferImpl res = new FloatBufferImpl(backing_buffer); res.limit((limit()*4)/8); return res; }\n+  private static native void nio_put_Byte (LongBufferImpl b, int index, int limit, byte value);\n \n-  LongBufferImpl(double[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n-  private static native double nio_get_Double(LongBufferImpl b, int index, int limit);\n-  private static native void nio_put_Double(LongBufferImpl b, int index, int limit, double value);\n-  public DoubleBuffer asDoubleBuffer() { DoubleBufferImpl res = new DoubleBufferImpl(backing_buffer); res.limit((limit()*8)/8); return res; }\n-\n-  private static native long[] nio_cast(byte[]copy);\n-  private static native long[] nio_cast(char[]copy);\n-  private static native long[] nio_cast(short[]copy);\n-  private static native long[] nio_cast(long[]copy);\n-  private static native long[] nio_cast(int[]copy);\n-  private static native long[] nio_cast(float[]copy);\n-  private static native long[] nio_cast(double[]copy);\n+  public ByteBuffer asByteBuffer ()\n+  {\n+    ByteBufferImpl res = new ByteBufferImpl (backing_buffer);\n+    res.limit ((limit () * 1) / 8);\n+    return res;\n+  }\n \n   public boolean isReadOnly()\n   {\n-    return ro;\n+    return readOnly;\n   }\n \n   public LongBuffer slice()\n   {\n-    LongBufferImpl A = new LongBufferImpl(this);\n-    A.array_offset = position();\n-    return A;\n+    return new LongBufferImpl (this);\n   }\n \n   public LongBuffer duplicate()\n@@ -141,9 +107,9 @@ public LongBuffer duplicate()\n \n   public LongBuffer asReadOnlyBuffer()\n   {\n-    LongBufferImpl a = new LongBufferImpl(this);\n-    a.ro = true;\n-    return a;\n+    LongBufferImpl result = new LongBufferImpl (this);\n+    result.readOnly = true;\n+    return result;\n   }\n \n   public LongBuffer compact()\n@@ -153,7 +119,7 @@ public LongBuffer compact()\n \n   public boolean isDirect()\n   {\n-    return backing_buffer != null;\n+    return false;\n   }\n \n   final public long get()\n@@ -165,6 +131,9 @@ final public long get()\n \n   final public LongBuffer put(long b)\n   {\n+    if (readOnly)\n+      throw new ReadOnlyBufferException ();\n+    \n     backing_buffer[position()] = b;\n     position(position()+1);\n     return this;\n@@ -177,14 +146,15 @@ final public long get(int index)\n \n   final public LongBuffer put(int index, long b)\n   {\n+    if (readOnly)\n+      throw new ReadOnlyBufferException ();\n+    \n     backing_buffer[index] = b;\n     return this;\n   }\n \n-  final public char getChar() { char a = nio_get_Char(this, position(), limit()); inc_pos(2); return a; } final public LongBuffer putChar(char value) { nio_put_Char(this, position(), limit(), value); inc_pos(2); return this; } final public char getChar(int index) { char a = nio_get_Char(this, index, limit()); return a; } final public LongBuffer putChar(int index, char value) { nio_put_Char(this, index, limit(), value); return this; };\n-  final public short getShort() { short a = nio_get_Short(this, position(), limit()); inc_pos(2); return a; } final public LongBuffer putShort(short value) { nio_put_Short(this, position(), limit(), value); inc_pos(2); return this; } final public short getShort(int index) { short a = nio_get_Short(this, index, limit()); return a; } final public LongBuffer putShort(int index, short value) { nio_put_Short(this, index, limit(), value); return this; };\n-  final public int getInt() { int a = nio_get_Int(this, position(), limit()); inc_pos(4); return a; } final public LongBuffer putInt(int value) { nio_put_Int(this, position(), limit(), value); inc_pos(4); return this; } final public int getInt(int index) { int a = nio_get_Int(this, index, limit()); return a; } final public LongBuffer putInt(int index, int value) { nio_put_Int(this, index, limit(), value); return this; };\n-  final public long getLong() { return get(); } final public LongBuffer putLong(long value) { return put(value); } final public long getLong(int index) { return get(index); } final public LongBuffer putLong(int index, long value) { return put(index, value); };\n-  final public float getFloat() { float a = nio_get_Float(this, position(), limit()); inc_pos(4); return a; } final public LongBuffer putFloat(float value) { nio_put_Float(this, position(), limit(), value); inc_pos(4); return this; } final public float getFloat(int index) { float a = nio_get_Float(this, index, limit()); return a; } final public LongBuffer putFloat(int index, float value) { nio_put_Float(this, index, limit(), value); return this; };\n-  final public double getDouble() { double a = nio_get_Double(this, position(), limit()); inc_pos(8); return a; } final public LongBuffer putDouble(double value) { nio_put_Double(this, position(), limit(), value); inc_pos(8); return this; } final public double getDouble(int index) { double a = nio_get_Double(this, index, limit()); return a; } final public LongBuffer putDouble(int index, double value) { nio_put_Double(this, index, limit(), value); return this; };\n+  final public ByteOrder order ()\n+  {\n+    return ByteOrder.BIG_ENDIAN;\n+  }\n }"}, {"sha": "c55f0989ae92933fd3f8f724d143a47089674b7c", "filename": "libjava/gnu/java/nio/ShortBufferImpl.java", "status": "modified", "additions": 47, "deletions": 77, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/248606ee91171899cccbfafeead6ff6e6039ea6d/libjava%2Fgnu%2Fjava%2Fnio%2FShortBufferImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/248606ee91171899cccbfafeead6ff6e6039ea6d/libjava%2Fgnu%2Fjava%2Fnio%2FShortBufferImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnio%2FShortBufferImpl.java?ref=248606ee91171899cccbfafeead6ff6e6039ea6d", "patch": "@@ -38,100 +38,66 @@\n package gnu.java.nio;\n \n import java.nio.ByteBuffer;\n-import java.nio.CharBuffer;\n-import java.nio.DoubleBuffer;\n-import java.nio.FloatBuffer;\n-import java.nio.IntBuffer;\n-import java.nio.LongBuffer;\n+import java.nio.ByteOrder;\n import java.nio.ShortBuffer;\n+import java.nio.ReadOnlyBufferException;\n \n+/**\n+ * This is a Heap memory implementation\n+ */\n public final class ShortBufferImpl extends ShortBuffer\n {\n-  private int array_offset;\n-  private boolean ro;\n+  private boolean readOnly;\n \n   public ShortBufferImpl(int cap, int off, int lim)\n   {\n-    this.backing_buffer = new short[cap];\n-    this.cap = cap ;\n-    this.limit(lim);\n-    this.position(off);\n+    super (cap, lim, off, 0);\n+    this.backing_buffer = new short [cap];\n+    readOnly = false;\n   }\n \n   public ShortBufferImpl(short[] array, int off, int lim)\n   {\n+    super (array.length, lim, off, 0);\n     this.backing_buffer = array;\n-    this.cap = array.length;\n-    this.limit(lim);\n-    this.position(off);\n+    readOnly = false;\n   }\n \n   public ShortBufferImpl(ShortBufferImpl copy)\n   {\n+    super (copy.capacity (), copy.limit (), copy.position (), 0);\n     backing_buffer = copy.backing_buffer;\n-    ro = copy.ro;\n-    limit(copy.limit());\n-    position(copy.position());\n+    readOnly = copy.isReadOnly ();\n   }\n \n-  void inc_pos(int a)\n+  private static native short[] nio_cast (byte[] copy);\n+\n+  ShortBufferImpl (byte[] copy)\n   {\n-    position(position() + a);\n+    super (copy.length, copy.length, 0, 0);\n+    this.backing_buffer = copy != null ? nio_cast (copy) : null;\n+    readOnly = false;\n+  }\n+  \n+  private static native byte nio_get_Byte (ShortBufferImpl b, int index, int limit);\n+  \n+  private static native void nio_put_Byte (ShortBufferImpl b, int index, int limit, byte value);\n+  \n+  public ByteBuffer asByteBuffer ()\n+  {\n+    ByteBufferImpl res = new ByteBufferImpl (backing_buffer);\n+    res.limit ((limit () * 1) / 2);\n+    return res;\n   }\n-\n-  ShortBufferImpl(byte[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n-  private static native byte nio_get_Byte(ShortBufferImpl b, int index, int limit);\n-  private static native void nio_put_Byte(ShortBufferImpl b, int index, int limit, byte value);\n-  public ByteBuffer asByteBuffer() { ByteBufferImpl res = new ByteBufferImpl(backing_buffer); res.limit((limit()*1)/2); return res; }\n-\n-  ShortBufferImpl(char[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n-  private static native char nio_get_Char(ShortBufferImpl b, int index, int limit);\n-  private static native void nio_put_Char(ShortBufferImpl b, int index, int limit, char value);\n-  public CharBuffer asCharBuffer() { CharBufferImpl res = new CharBufferImpl(backing_buffer); res.limit((limit()*2)/2); return res; }\n-\n-  ShortBufferImpl(short[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n-  private static native short nio_get_Short(ShortBufferImpl b, int index, int limit);\n-  private static native void nio_put_Short(ShortBufferImpl b, int index, int limit, short value);\n-  public ShortBuffer asShortBuffer() { ShortBufferImpl res = new ShortBufferImpl(backing_buffer); res.limit((limit()*2)/2); return res; }\n-\n-  ShortBufferImpl(int[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n-  private static native int nio_get_Int(ShortBufferImpl b, int index, int limit);\n-  private static native void nio_put_Int(ShortBufferImpl b, int index, int limit, int value);\n-  public IntBuffer asIntBuffer() { IntBufferImpl res = new IntBufferImpl(backing_buffer); res.limit((limit()*4)/2); return res; }\n-\n-  ShortBufferImpl(long[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n-  private static native long nio_get_Long(ShortBufferImpl b, int index, int limit);\n-  private static native void nio_put_Long(ShortBufferImpl b, int index, int limit, long value);\n-  public LongBuffer asLongBuffer() { LongBufferImpl res = new LongBufferImpl(backing_buffer); res.limit((limit()*8)/2); return res; }\n-\n-  ShortBufferImpl(float[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n-  private static native float nio_get_Float(ShortBufferImpl b, int index, int limit);\n-  private static native void nio_put_Float(ShortBufferImpl b, int index, int limit, float value);\n-  public FloatBuffer asFloatBuffer() { FloatBufferImpl res = new FloatBufferImpl(backing_buffer); res.limit((limit()*4)/2); return res; }\n-\n-  ShortBufferImpl(double[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n-  private static native double nio_get_Double(ShortBufferImpl b, int index, int limit);\n-  private static native void nio_put_Double(ShortBufferImpl b, int index, int limit, double value);\n-  public DoubleBuffer asDoubleBuffer() { DoubleBufferImpl res = new DoubleBufferImpl(backing_buffer); res.limit((limit()*8)/2); return res; }\n-\n-  private static native short[] nio_cast(byte[]copy);\n-  private static native short[] nio_cast(char[]copy);\n-  private static native short[] nio_cast(short[]copy);\n-  private static native short[] nio_cast(long[]copy);\n-  private static native short[] nio_cast(int[]copy);\n-  private static native short[] nio_cast(float[]copy);\n-  private static native short[] nio_cast(double[]copy);\n \n   public boolean isReadOnly()\n   {\n-    return ro;\n+    return readOnly;\n   }\n \n   public ShortBuffer slice()\n   {\n-    ShortBufferImpl a = new ShortBufferImpl(this);\n-    a.array_offset = position();\n-    return a;\n+    return new ShortBufferImpl (this);\n   }\n \n   public ShortBuffer duplicate()\n@@ -141,9 +107,9 @@ public ShortBuffer duplicate()\n \n   public ShortBuffer asReadOnlyBuffer()\n   {\n-    ShortBufferImpl a = new ShortBufferImpl(this);\n-    a.ro = true;\n-    return a;\n+    ShortBufferImpl result = new ShortBufferImpl (this);\n+    result.readOnly = true;\n+    return result;\n   }\n \n   public ShortBuffer compact()\n@@ -153,7 +119,7 @@ public ShortBuffer compact()\n \n   public boolean isDirect()\n   {\n-    return backing_buffer != null;\n+    return false;\n   }\n \n   final public short get()\n@@ -165,6 +131,9 @@ final public short get()\n \n   final public ShortBuffer put(short b)\n   {\n+    if (readOnly)\n+      throw new ReadOnlyBufferException ();\n+    \n     backing_buffer[position()] = b;\n     position(position()+1);\n     return this;\n@@ -177,14 +146,15 @@ final public short get(int index)\n \n   final public ShortBuffer put(int index, short b)\n   {\n+    if (readOnly)\n+      throw new ReadOnlyBufferException ();\n+    \n     backing_buffer[index] = b;\n     return this;\n   }\n-\n-  final public char getChar() { char a = nio_get_Char(this, position(), limit()); inc_pos(2); return a; } final public ShortBuffer putChar(char value) { nio_put_Char(this, position(), limit(), value); inc_pos(2); return this; } final public char getChar(int index) { char a = nio_get_Char(this, index, limit()); return a; } final public ShortBuffer putChar(int index, char value) { nio_put_Char(this, index, limit(), value); return this; };\n-  final public short getShort() { return get(); } final public ShortBuffer putShort(short value) { return put(value); } final public short getShort(int index) { return get(index); } final public ShortBuffer putShort(int index, short value) { return put(index, value); };\n-  final public int getInt() { int a = nio_get_Int(this, position(), limit()); inc_pos(4); return a; } final public ShortBuffer putInt(int value) { nio_put_Int(this, position(), limit(), value); inc_pos(4); return this; } final public int getInt(int index) { int a = nio_get_Int(this, index, limit()); return a; } final public ShortBuffer putInt(int index, int value) { nio_put_Int(this, index, limit(), value); return this; };\n-  final public long getLong() { long a = nio_get_Long(this, position(), limit()); inc_pos(8); return a; } final public ShortBuffer putLong(long value) { nio_put_Long(this, position(), limit(), value); inc_pos(8); return this; } final public long getLong(int index) { long a = nio_get_Long(this, index, limit()); return a; } final public ShortBuffer putLong(int index, long value) { nio_put_Long(this, index, limit(), value); return this; };\n-  final public float getFloat() { float a = nio_get_Float(this, position(), limit()); inc_pos(4); return a; } final public ShortBuffer putFloat(float value) { nio_put_Float(this, position(), limit(), value); inc_pos(4); return this; } final public float getFloat(int index) { float a = nio_get_Float(this, index, limit()); return a; } final public ShortBuffer putFloat(int index, float value) { nio_put_Float(this, index, limit(), value); return this; };\n-  final public double getDouble() { double a = nio_get_Double(this, position(), limit()); inc_pos(8); return a; } final public ShortBuffer putDouble(double value) { nio_put_Double(this, position(), limit(), value); inc_pos(8); return this; } final public double getDouble(int index) { double a = nio_get_Double(this, index, limit()); return a; } final public ShortBuffer putDouble(int index, double value) { nio_put_Double(this, index, limit(), value); return this; };\n+  \n+  final public ByteOrder order ()\n+  {\n+    return ByteOrder.BIG_ENDIAN;\n+  }\n }"}]}