{"sha": "d1552d7b014918281e1bcb68388936b68094e354", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDE1NTJkN2IwMTQ5MTgyODFlMWJjYjY4Mzg4OTM2YjY4MDk0ZTM1NA==", "commit": {"author": {"name": "Joseph Myers", "email": "jsm28@cam.ac.uk", "date": "2002-01-21T06:22:28Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2002-01-21T06:22:28Z"}, "message": "alpha.h, [...]: Remove commented out target macro definitions and non-target-specific comments...\n\n\t* config/alpha/alpha.h, config/arc/arc.h, config/avr/avr.h,\n\tconfig/c4x/c4x.h, config/d30v/d30v.h, config/dsp16xx/dsp16xx.h,\n\tconfig/fr30/fr30.h, config/ia64/ia64.h, config/m68hc11/m68hc11.h,\n\tconfig/mips/mips.h, config/rs6000/rs6000.h, config/sparc/sparc.h,\n\tconfig/stormy16/stormy16.h, config/v850/v850.h: Remove commented\n\tout target macro definitions and non-target-specific comments\n\tmostly taken from old versions of the manual.\n\nFrom-SVN: r49033", "tree": {"sha": "dfd3c229aa1c8906416a1d3b27213c1a0a830653", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dfd3c229aa1c8906416a1d3b27213c1a0a830653"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d1552d7b014918281e1bcb68388936b68094e354", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1552d7b014918281e1bcb68388936b68094e354", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1552d7b014918281e1bcb68388936b68094e354", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1552d7b014918281e1bcb68388936b68094e354/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "93dbe8d76d1cdf06f6108260b0d35989e906ee9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93dbe8d76d1cdf06f6108260b0d35989e906ee9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93dbe8d76d1cdf06f6108260b0d35989e906ee9b"}], "stats": {"total": 2061, "additions": 45, "deletions": 2016}, "files": [{"sha": "86b1e94e5fc67c8335e132898e0d0b04e879baba", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1552d7b014918281e1bcb68388936b68094e354/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1552d7b014918281e1bcb68388936b68094e354/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d1552d7b014918281e1bcb68388936b68094e354", "patch": "@@ -1,3 +1,13 @@\n+2002-01-21  Joseph S. Myers  <jsm28@cam.ac.uk>\n+\n+\t* config/alpha/alpha.h, config/arc/arc.h, config/avr/avr.h,\n+\tconfig/c4x/c4x.h, config/d30v/d30v.h, config/dsp16xx/dsp16xx.h,\n+\tconfig/fr30/fr30.h, config/ia64/ia64.h, config/m68hc11/m68hc11.h,\n+\tconfig/mips/mips.h, config/rs6000/rs6000.h, config/sparc/sparc.h,\n+\tconfig/stormy16/stormy16.h, config/v850/v850.h: Remove commented\n+\tout target macro definitions and non-target-specific comments\n+\tmostly taken from old versions of the manual.\n+\n 2002-01-20  Kazu Hirata  <kazu@hxi.com>\n \n \t* config/h8300/h8300.h: Fix comment formatting."}, {"sha": "0ff8ae3d398d9901aebaf3efac58297862eead20", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1552d7b014918281e1bcb68388936b68094e354/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1552d7b014918281e1bcb68388936b68094e354/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=d1552d7b014918281e1bcb68388936b68094e354", "patch": "@@ -268,23 +268,6 @@ extern enum alpha_fp_trap_mode alpha_fptm;\n #endif\n #endif\n \n-/* This macro is similar to `TARGET_SWITCHES' but defines names of\n-   command options that have values.  Its definition is an initializer\n-   with a subgrouping for each command option.\n-\n-   Each subgrouping contains a string constant, that defines the fixed\n-   part of the option name, and the address of a variable.  The\n-   variable, type `char *', is set to the variable part of the given\n-   option if the fixed part matches.  The actual option name is made\n-   by appending `-m' to the specified name.\n-\n-   Here is an example which defines `-mshort-data-NUMBER'.  If the\n-   given option is `-mshort-data-512', the variable `m88k_short_data'\n-   will be set to the string `\"512\"'.\n-\n-\textern char *m88k_short_data;\n-\t#define TARGET_OPTIONS { { \"short-data-\", &m88k_short_data } }  */\n-\n extern const char *alpha_cpu_string;\t/* For -mcpu= */\n extern const char *alpha_tune_string;\t/* For -mtune= */\n extern const char *alpha_fprm_string;\t/* For -mfp-rounding-mode=[n|m|c|d] */"}, {"sha": "523ea72a57b2ce3683fc717451c2d67f32bc1639", "filename": "gcc/config/arc/arc.h", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1552d7b014918281e1bcb68388936b68094e354/gcc%2Fconfig%2Farc%2Farc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1552d7b014918281e1bcb68388936b68094e354/gcc%2Fconfig%2Farc%2Farc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.h?ref=d1552d7b014918281e1bcb68388936b68094e354", "patch": "@@ -130,23 +130,6 @@ extern int target_flags;\n /* Non-zero means the cpu has a barrel shifter.  */\n #define TARGET_SHIFTER 0\n \n-/* This macro is similar to `TARGET_SWITCHES' but defines names of\n-   command options that have values.  Its definition is an\n-   initializer with a subgrouping for each command option.\n-\n-   Each subgrouping contains a string constant, that defines the\n-   fixed part of the option name, and the address of a variable. \n-   The variable, type `char *', is set to the variable part of the\n-   given option if the fixed part matches.  The actual option name\n-   is made by appending `-m' to the specified name.\n-\n-   Here is an example which defines `-mshort-data-NUMBER'.  If the\n-   given option is `-mshort-data-512', the variable `m88k_short_data'\n-   will be set to the string `\"512\"'.\n-\n-\textern char *m88k_short_data;\n-\t#define TARGET_OPTIONS { { \"short-data-\", &m88k_short_data } }  */\n-\n extern const char *arc_cpu_string;\n extern const char *arc_text_string,*arc_data_string,*arc_rodata_string;\n "}, {"sha": "52cba88c45863c3f790665ff7e2b431c4ab3c498", "filename": "gcc/config/avr/avr.h", "status": "modified", "additions": 0, "deletions": 74, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1552d7b014918281e1bcb68388936b68094e354/gcc%2Fconfig%2Favr%2Favr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1552d7b014918281e1bcb68388936b68094e354/gcc%2Fconfig%2Favr%2Favr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.h?ref=d1552d7b014918281e1bcb68388936b68094e354", "patch": "@@ -23,23 +23,6 @@ Boston, MA 02111-1307, USA.  */\n /* Names to predefine in the preprocessor for this target machine. */\n \n #define CPP_PREDEFINES \"-DAVR\"\n-/* Define this to be a string constant containing `-D' options to\n-   define the predefined macros that identify this machine and system.\n-   These macros will be predefined unless the `-ansi' option is\n-   specified.\n-\n-   In addition, a parallel set of macros are predefined, whose names\n-   are made by appending `__' at the beginning and at the end.  These\n-   `__' macros are permitted by the ANSI standard, so they are\n-   predefined regardless of whether `-ansi' is specified.\n-\n-   For example, on the Sun, one can use the following value:\n-\n-   \"-Dmc68000 -Dsun -Dunix\"\n-\n-   The result is to define the macros `__mc68000__', `__sun__' and\n-   `__unix__' unconditionally, and the macros `mc68000', `sun' and\n-   `unix' provided `-ansi' is not specified.  */\n \n \n /* This declaration should be present. */\n@@ -71,25 +54,6 @@ extern int target_flags;\n #define TARGET_RTL_DUMP\t\t(target_flags & MASK_RTL_DUMP)\n #define TARGET_ALL_DEBUG \t(target_flags & MASK_ALL_DEBUG)\n \n-/* `TARGET_...'\n-   This series of macros is to allow compiler command arguments to\n-   enable or disable the use of optional features of the target\n-   machine.  For example, one machine description serves both the\n-   68000 and the 68020; a command argument tells the compiler whether\n-   it should use 68020-only instructions or not.  This command\n-   argument works by means of a macro `TARGET_68020' that tests a bit\n-   in `target_flags'.\n-\n-   Define a macro `TARGET_FEATURENAME' for each such option.  Its\n-   definition should test a bit in `target_flags'; for example:\n-\n-   #define TARGET_68020 (target_flags & 1)\n-\n-   One place where these macros are used is in the\n-   condition-expressions of instruction patterns.  Note how\n-   `TARGET_68020' appears frequently in the 68000 machine description\n-   file, `m68k.md'.  Another place they are used is in the\n-   definitions of the other macros in the `MACHINE.h' file.  */\n \n \n \n@@ -110,27 +74,6 @@ extern int target_flags;\n     N_(\"Output instruction sizes to the asm file\") },\t\t\t\\\n   { \"deb\", MASK_ALL_DEBUG, NULL },\t\t\t\t\t\\\n   { \"\", 0, NULL } }\n-/* This macro defines names of command options to set and clear bits\n-   in `target_flags'.  Its definition is an initializer with a\n-   subgrouping for each command option.\n-\n-   Each subgrouping contains a string constant, that defines the\n-   option name, and a number, which contains the bits to set in\n-   `target_flags'.  A negative number says to clear bits instead; the\n-   negative of the number is which bits to clear.  The actual option\n-   name is made by appending `-m' to the specified name.\n-\n-   One of the subgroupings should have a null string.  The number in\n-   this grouping is the default value for `target_flags'.  Any target\n-   options act starting with that value.\n-\n-   Here is an example which defines `-m68000' and `-m68020' with\n-   opposite meanings, and picks the latter as the default:\n-\n-   #define TARGET_SWITCHES \\\n-   { { \"68020\", 1},      \\\n-   { \"68000\", -1},     \\\n-   { \"\", 1}}  */\n \n extern const char *avr_init_stack;\n extern const char *avr_mcu_name;\n@@ -143,23 +86,6 @@ extern int avr_enhanced_p;\n #define TARGET_OPTIONS {\t\t\t\t\t\t      \\\n  { \"init-stack=\", &avr_init_stack, N_(\"Specify the initial stack address\") }, \\\n  { \"mcu=\", &avr_mcu_name, N_(\"Specify the MCU name\") } }\n-/* This macro is similar to `TARGET_SWITCHES' but defines names of\n-   command options that have values.  Its definition is an\n-   initializer with a subgrouping for each command option.\n-\n-   Each subgrouping contains a string constant, that defines the\n-   fixed part of the option name, and the address of a variable.  The\n-   variable, type `char *', is set to the variable part of the given\n-   option if the fixed part matches.  The actual option name is made\n-   by appending `-m' to the specified name.\n-\n-   Here is an example which defines `-mshort-data-NUMBER'.  If the\n-   given option is `-mshort-data-512', the variable `m88k_short_data'\n-   will be set to the string `\"512\"'.\n-\n-   extern char *m88k_short_data;\n-   #define TARGET_OPTIONS \\\n-   { { \"short-data-\", &m88k_short_data } }  */\n \n #define TARGET_VERSION fprintf (stderr, \" (GNU assembler syntax)\");\n /* This macro is a C statement to print on `stderr' a string"}, {"sha": "15c0a2b405dc9bd026d93c5ca2475604068a28cf", "filename": "gcc/config/c4x/c4x.h", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1552d7b014918281e1bcb68388936b68094e354/gcc%2Fconfig%2Fc4x%2Fc4x.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1552d7b014918281e1bcb68388936b68094e354/gcc%2Fconfig%2Fc4x%2Fc4x.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.h?ref=d1552d7b014918281e1bcb68388936b68094e354", "patch": "@@ -297,23 +297,6 @@ extern int target_flags;\n \n /* -mcpu=XX    with XX = target DSP version number.  */\n \n-/* This macro is similar to `TARGET_SWITCHES' but defines names of\n-   command options that have values.  Its definition is an\n-   initializer with a subgrouping for each command option.\n-\n-   Each subgrouping contains a string constant, that defines the\n-   fixed part of the option name, and the address of a variable.\n-   The variable, type `char *', is set to the variable part of the\n-   given option if the fixed part matches.  The actual option name\n-   is made by appending `-m' to the specified name.\n-\n-   Here is an example which defines `-mshort-data-NUMBER'.  If the\n-   given option is `-mshort-data-512', the variable `m88k_short_data'\n-   will be set to the string `\"512\"'.\n-\n-   extern char *m88k_short_data;\n-   #define TARGET_OPTIONS { { \"short-data-\", &m88k_short_data } }  */\n-\n extern const char *c4x_rpts_cycles_string, *c4x_cpu_version_string;\n \n #define TARGET_OPTIONS\t\t\t\t\t\t\\"}, {"sha": "5be4d47e1f0800f873529b7b83cb34e84a2f13ca", "filename": "gcc/config/d30v/d30v.h", "status": "modified", "additions": 16, "deletions": 769, "changes": 785, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1552d7b014918281e1bcb68388936b68094e354/gcc%2Fconfig%2Fd30v%2Fd30v.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1552d7b014918281e1bcb68388936b68094e354/gcc%2Fconfig%2Fd30v%2Fd30v.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fd30v%2Fd30v.h?ref=d1552d7b014918281e1bcb68388936b68094e354", "patch": "@@ -30,117 +30,22 @@\n \f\n /* Driver configuration */\n \n-/* A C expression which determines whether the option `-CHAR' takes arguments.\n-   The value should be the number of arguments that option takes-zero, for many\n-   options.\n-\n-   By default, this macro is defined to handle the standard options properly.\n-   You need not define it unless you wish to add additional options which take\n-   arguments.\n-\n-   Defined in svr4.h.  */\n+/* Defined in svr4.h.  */\n /* #define SWITCH_TAKES_ARG(CHAR) */\n \n-/* A C expression which determines whether the option `-NAME' takes arguments.\n-   The value should be the number of arguments that option takes-zero, for many\n-   options.  This macro rather than `SWITCH_TAKES_ARG' is used for\n-   multi-character option names.\n-\n-   By default, this macro is defined as `DEFAULT_WORD_SWITCH_TAKES_ARG', which\n-   handles the standard options properly.  You need not define\n-   `WORD_SWITCH_TAKES_ARG' unless you wish to add additional options which take\n-   arguments.  Any redefinition should call `DEFAULT_WORD_SWITCH_TAKES_ARG' and\n-   then check for additional options.\n-\n-   Defined in svr4.h.  */\n+/* Defined in svr4.h.  */\n /* #define WORD_SWITCH_TAKES_ARG(NAME) */\n \n-/* A string-valued C expression which is nonempty if the linker needs a space\n-   between the `-L' or `-o' option and its argument.\n-\n-   If this macro is not defined, the default value is 0.  */\n-/* #define SWITCHES_NEED_SPACES \"\" */\n-\n-/* A C string constant that tells the GNU CC driver program options to pass to\n-   CPP.  It can also specify how to translate options you give to GNU CC into\n-   options for GNU CC to pass to the CPP.\n-\n-   Do not define this macro if it does not need to do anything.  */\n-/* #define CPP_SPEC \"\" */\n-\n-/* If this macro is defined, the preprocessor will not define the builtin macro\n-   `__SIZE_TYPE__'.  The macro `__SIZE_TYPE__' must then be defined by\n-   `CPP_SPEC' instead.\n-\n-   This should be defined if `SIZE_TYPE' depends on target dependent flags\n-   which are not accessible to the preprocessor.  Otherwise, it should not be\n-   defined.  */\n-/* #define NO_BUILTIN_SIZE_TYPE */\n-\n-/* If this macro is defined, the preprocessor will not define the builtin macro\n-   `__PTRDIFF_TYPE__'.  The macro `__PTRDIFF_TYPE__' must then be defined by\n-   `CPP_SPEC' instead.\n-\n-   This should be defined if `PTRDIFF_TYPE' depends on target dependent flags\n-   which are not accessible to the preprocessor.  Otherwise, it should not be\n-   defined.  */\n-/* #define NO_BUILTIN_PTRDIFF_TYPE */\n-\n-/* A C string constant that tells the GNU CC driver program options to pass to\n-   CPP.  By default, this macro is defined to pass the option\n-   `-D__CHAR_UNSIGNED__' to CPP if `char' will be treated as `unsigned char' by\n-   `cc1'.\n-\n-   Do not define this macro unless you need to override the default definition.  */\n-/* #if DEFAULT_SIGNED_CHAR\n-   #define SIGNED_CHAR_SPEC \"%{funsigned-char:-D__CHAR_UNSIGNED__}\"\n-   #else\n-   #define SIGNED_CHAR_SPEC \"%{!fsigned-char:-D__CHAR_UNSIGNED__}\"\n-   #endif */\n-\n-/* A C string constant that tells the GNU CC driver program options to pass to\n-   `cc1'.  It can also specify how to translate options you give to GNU CC into\n-   options for GNU CC to pass to the `cc1'.\n-\n-   Do not define this macro if it does not need to do anything.  */\n-/* #define CC1_SPEC \"\" */\n-\n-/* A C string constant that tells the GNU CC driver program options to pass to\n-   `cc1plus'.  It can also specify how to translate options you give to GNU CC\n-   into options for GNU CC to pass to the `cc1plus'.\n-\n-   Do not define this macro if it does not need to do anything.  */\n-/* #define CC1PLUS_SPEC \"\" */\n-\n-/* A C string constant that tells the GNU CC driver program options to pass to\n-   the assembler.  It can also specify how to translate options you give to GNU\n-   CC into options for GNU CC to pass to the assembler.  See the file `sun3.h'\n-   for an example of this.\n-\n-   Do not define this macro if it does not need to do anything.\n-\n-   Defined in svr4.h.  */\n+/* Defined in svr4.h.  */\n #undef\tASM_SPEC\n #define ASM_SPEC \"\\\n %{!mno-asm-optimize: %{O*: %{!O0: -O} %{O0: %{masm-optimize: -O}}}} \\\n %{v} %{n} %{T} %{Ym,*} %{Yd,*} %{Wa,*:%*}\"\n \n-/* A C string constant that tells the GNU CC driver program how to run any\n-   programs which cleanup after the normal assembler.  Normally, this is not\n-   needed.  See the file `mips.h' for an example of this.\n-\n-   Do not define this macro if it does not need to do anything.\n-\n-   Defined in svr4.h.  */\n+/* Defined in svr4.h.  */\n /* #define ASM_FINAL_SPEC \"\" */\n \n-/* A C string constant that tells the GNU CC driver program options to pass to\n-   the linker.  It can also specify how to translate options you give to GNU CC\n-   into options for GNU CC to pass to the linker.\n-\n-   Do not define this macro if it does not need to do anything.\n-\n-   Defined in svr4.h.  */\n+/* Defined in svr4.h.  */\n #undef\tLINK_SPEC\n #define LINK_SPEC \"\\\n %{h*} %{v:-V} \\\n@@ -153,247 +58,32 @@\n %{Qy:} %{!Qn:-Qy} \\\n %{mextmem: -m d30v_e} %{mextmemory: -m d30v_e} %{monchip: -m d30v_o}\"\n \n-/* Another C string constant used much like `LINK_SPEC'.  The difference\n-   between the two is that `LIB_SPEC' is used at the end of the command given\n-   to the linker.\n-\n-   If this macro is not defined, a default is provided that loads the standard\n-   C library from the usual place.  See `gcc.c'.\n-\n-   Defined in svr4.h.  */\n+/* Defined in svr4.h.  */\n #undef\tLIB_SPEC\n #define LIB_SPEC \"--start-group -lsim -lc --end-group\"\n \n-/* Another C string constant that tells the GNU CC driver program how and when\n-   to place a reference to `libgcc.a' into the linker command line.  This\n-   constant is placed both before and after the value of `LIB_SPEC'.\n-\n-   If this macro is not defined, the GNU CC driver provides a default that\n-   passes the string `-lgcc' to the linker unless the `-shared' option is\n-   specified.  */\n-/* #define LIBGCC_SPEC \"\" */\n-\n-/* Another C string constant used much like `LINK_SPEC'.  The difference\n-   between the two is that `STARTFILE_SPEC' is used at the very beginning of\n-   the command given to the linker.\n-\n-   If this macro is not defined, a default is provided that loads the standard\n-   C startup file from the usual place.  See `gcc.c'.\n-\n-   Defined in svr4.h.  */\n-\n+/* Defined in svr4.h.  */\n #undef\tSTARTFILE_SPEC\n #define STARTFILE_SPEC \"crt0%O%s crtbegin%O%s\"\n \n-/* Another C string constant used much like `LINK_SPEC'.  The difference\n-   between the two is that `ENDFILE_SPEC' is used at the very end of the\n-   command given to the linker.\n-\n-   Do not define this macro if it does not need to do anything.\n-\n-   Defined in svr4.h.  */\n-\n+/* Defined in svr4.h.  */\n #undef\tENDFILE_SPEC\n #define ENDFILE_SPEC \"crtend%O%s\"\n \n-/* Define this macro if the driver program should find the library `libgcc.a'\n-   itself and should not pass `-L' options to the linker.  If you do not define\n-   this macro, the driver program will pass the argument `-lgcc' to tell the\n-   linker to do the search and will pass `-L' options to it.  */\n-/* #define LINK_LIBGCC_SPECIAL */\n-\n-/* Define this macro if the driver program should find the library `libgcc.a'.\n-   If you do not define this macro, the driver program will pass the argument\n-   `-lgcc' to tell the linker to do the search.  This macro is similar to\n-   `LINK_LIBGCC_SPECIAL', except that it does not affect `-L' options.  */\n-/* #define LINK_LIBGCC_SPECIAL_1 */\n-\n-/* Define this macro to provide additional specifications to put in the `specs'\n-   file that can be used in various specifications like `CC1_SPEC'.\n-\n-   The definition should be an initializer for an array of structures,\n-   containing a string constant, that defines the specification name, and a\n-   string constant that provides the specification.\n-\n-   Do not define this macro if it does not need to do anything.  */\n-/* #define EXTRA_SPECS {{}} */\n-\n-/* Define this macro as a C expression for the initializer of an array of\n-   string to tell the driver program which options are defaults for this target\n-   and thus do not need to be handled specially when using `MULTILIB_OPTIONS'.\n-\n-   Do not define this macro if `MULTILIB_OPTIONS' is not defined in the target\n-   makefile fragment or if none of the options listed in `MULTILIB_OPTIONS' are\n-   set by default.  *Note Target Fragment::.  */\n-/* #define MULTILIB_DEFAULTS {} */\n-\n-/* Define this macro to tell `gcc' that it should only translate a `-B' prefix\n-   into a `-L' linker option if the prefix indicates an absolute file name. */\n-/* #define RELATIVE_PREFIX_NOT_LINKDIR */\n-\n-/* Define this macro as a C string constant if you wish to override the\n-   standard choice of `/usr/local/lib/gcc-lib/' as the default prefix to try\n-   when searching for the executable files of the compiler. */\n-/* #define STANDARD_EXEC_PREFIX \"\" */\n-\n-/* If defined, this macro is an additional prefix to try after\n-   `STANDARD_EXEC_PREFIX'.  `MD_EXEC_PREFIX' is not searched when the `-b'\n-   option is used, or the compiler is built as a cross compiler.\n-\n-   Defined in svr4.h for host compilers.  */\n+/* Defined in svr4.h for host compilers.  */\n /* #define MD_EXEC_PREFIX \"\" */\n \n-/* Define this macro as a C string constant if you wish to override the\n-   standard choice of `/usr/local/lib/' as the default prefix to try when\n-   searching for startup files such as `crt0.o'. */\n-/* #define STANDARD_STARTFILE_PREFIX \"\" */\n-\n-/* If defined, this macro supplies an additional prefix to try after the\n-   standard prefixes.  `MD_EXEC_PREFIX' is not searched when the `-b' option is\n-   used, or when the compiler is built as a cross compiler.\n-\n-   Defined in svr4.h for host compilers.  */\n+/* Defined in svr4.h for host compilers.  */\n /* #define MD_STARTFILE_PREFIX \"\" */\n \n-/* If defined, this macro supplies yet another prefix to try after the standard\n-   prefixes.  It is not searched when the `-b' option is used, or when the\n-   compiler is built as a cross compiler. */\n-/* #define MD_STARTFILE_PREFIX_1 \"\" */\n-\n-/* Define this macro as a C string constant if you with to set environment\n-   variables for programs called by the driver, such as the assembler and\n-   loader.  The driver passes the value of this macro to `putenv' to initialize\n-   the necessary environment variables. */\n-/* #define INIT_ENVIRONMENT \"\" */\n-\n-/* Define this macro as a C string constant if you wish to override the\n-   standard choice of `/usr/local/include' as the default prefix to try when\n-   searching for local header files.  `LOCAL_INCLUDE_DIR' comes before\n-   `SYSTEM_INCLUDE_DIR' in the search order.\n-\n-   Cross compilers do not use this macro and do not search either\n-   `/usr/local/include' or its replacement.  */\n-/* #define LOCAL_INCLUDE_DIR \"\" */\n-\n-/* Define this macro as a C string constant if you wish to specify a\n-   system-specific directory to search for header files before the standard\n-   directory.  `SYSTEM_INCLUDE_DIR' comes before `STANDARD_INCLUDE_DIR' in the\n-   search order.\n-\n-   Cross compilers do not use this macro and do not search the directory\n-   specified. */\n-/* #define SYSTEM_INCLUDE_DIR \"\" */\n-\n-/* Define this macro as a C string constant if you wish to override the\n-   standard choice of `/usr/include' as the default prefix to try when\n-   searching for header files.\n-\n-   Cross compilers do not use this macro and do not search either\n-   `/usr/include' or its replacement. */\n-/* #define STANDARD_INCLUDE_DIR \"\" */\n-\n-/* Define this macro if you wish to override the entire default search path for\n-   include files.  The default search path includes `GCC_INCLUDE_DIR',\n-   `LOCAL_INCLUDE_DIR', `SYSTEM_INCLUDE_DIR', `GPLUSPLUS_INCLUDE_DIR', and\n-   `STANDARD_INCLUDE_DIR'.  In addition, `GPLUSPLUS_INCLUDE_DIR' and\n-   `GCC_INCLUDE_DIR' are defined automatically by `Makefile', and specify\n-   private search areas for GCC.  The directory `GPLUSPLUS_INCLUDE_DIR' is used\n-   only for C++ programs.\n-\n-     The definition should be an initializer for an array of structures.  Each\n-     array element should have two elements: the directory name (a string\n-     constant) and a flag for C++-only directories.  Mark the end of the array\n-     with a null element.  For example, here is the definition used for VMS:\n-\n-          #define INCLUDE_DEFAULTS \\\n-          {                                       \\\n-            { \"GNU_GXX_INCLUDE:\", 1},             \\\n-            { \"GNU_CC_INCLUDE:\", 0},              \\\n-            { \"SYS$SYSROOT:[SYSLIB.]\", 0},        \\\n-            { \".\", 0},                            \\\n-            { 0, 0}                               \\\n-          }\n-\n-   Here is the order of prefixes tried for exec files:\n-\n-  1. Any prefixes specified by the user with `-B'.\n-\n-  2. The environment variable `GCC_EXEC_PREFIX', if any.\n-\n-  3. The directories specified by the environment variable\n-     `COMPILER_PATH'.\n-\n-  4. The macro `STANDARD_EXEC_PREFIX'.\n-\n-  5. `/usr/lib/gcc/'.\n-\n-  6. The macro `MD_EXEC_PREFIX', if any.\n-\n-   Here is the order of prefixes tried for startfiles:\n-\n-  1. Any prefixes specified by the user with `-B'.\n-\n-  2. The environment variable `GCC_EXEC_PREFIX', if any.\n-\n-  3. The directories specified by the environment variable\n-     `LIBRARY_PATH' (native only, cross compilers do not use this).\n-\n-  4. The macro `STANDARD_EXEC_PREFIX'.\n-\n-  5. `/usr/lib/gcc/'.\n-\n-  6. The macro `MD_EXEC_PREFIX', if any.\n-\n-  7. The macro `MD_STARTFILE_PREFIX', if any.\n-\n-  8. The macro `STANDARD_STARTFILE_PREFIX'.\n-\n-  9. `/lib/'.\n-\n- 10. `/usr/lib/'.  */\n-/* #define INCLUDE_DEFAULTS {{ }} */\n-\n \f\n /* Run-time target specifications */\n \n-/* Define this to be a string constant containing `-D' options to define the\n-   predefined macros that identify this machine and system.  These macros will\n-   be predefined unless the `-ansi' option is specified.\n-\n-   In addition, a parallel set of macros are predefined, whose names are made\n-   by appending `__' at the beginning and at the end.  These `__' macros are\n-   permitted by the ANSI standard, so they are predefined regardless of whether\n-   `-ansi' is specified.\n-\n-   For example, on the Sun, one can use the following value:\n-\n-        \"-Dmc68000 -Dsun -Dunix\"\n-\n-   The result is to define the macros `__mc68000__', `__sun__' and `__unix__'\n-   unconditionally, and the macros `mc68000', `sun' and `unix' provided `-ansi'\n-   is not specified.  */\n #define CPP_PREDEFINES \"-D__D30V__ -Amachine=d30v\"\n \n /* This declaration should be present.  */\n extern int target_flags;\n \n-/* This series of macros is to allow compiler command arguments to enable or\n-   disable the use of optional features of the target machine.  For example,\n-   one machine description serves both the 68000 and the 68020; a command\n-   argument tells the compiler whether it should use 68020-only instructions or\n-   not.  This command argument works by means of a macro `TARGET_68020' that\n-   tests a bit in `target_flags'.\n-\n-   Define a macro `TARGET_FEATURENAME' for each such option.  Its definition\n-   should test a bit in `target_flags'; for example:\n-\n-        #define TARGET_68020 (target_flags & 1)\n-\n-   One place where these macros are used is in the condition-expressions of\n-   instruction patterns.  Note how `TARGET_68020' appears frequently in the\n-   68000 machine description file, `m68k.md'.  Another place they are used is\n-   in the definitions of the other macros in the `MACHINE.h' file.  */\n-\n #define MASK_NO_COND_MOVE\t0x00000001\t/* disable conditional moves */\n \n #define MASK_DEBUG_ARG\t\t0x10000000\t/* debug argument handling */\n@@ -412,31 +102,6 @@ extern int target_flags;\n #define TARGET_DEFAULT 0\n #endif\n \n-/* This macro defines names of command options to set and clear bits in\n-   `target_flags'.  Its definition is an initializer with a subgrouping for\n-   each command option.\n-\n-   Each subgrouping contains a string constant, that defines the option name, a\n-   number, which contains the bits to set in `target_flags', and a second\n-   string which is the description displayed by `--help'.  If the number is\n-   negative then the bits specified by the number are cleared instead of being\n-   set.  If the description string is present but empty, then no help\n-   information will be displayed for that option, but it will not count as an\n-   undocumented option.  The actual option name is made by appending `-m' to\n-   the specified name.\n-\n-   One of the subgroupings should have a null string.  The number in this\n-   grouping is the default value for target_flags.  Any target options act\n-   starting with that value.\n-\n-   Here is an example which defines -m68000 and -m68020 with opposite meanings,\n-   and picks the latter as the default:\n-\n-  #define TARGET_SWITCHES \\\n-    { { \"68020\", TARGET_MASK_68020, \"\" },      \\\n-      { \"68000\", -TARGET_MASK_68020, \"Compile for the 68000\" }, \\\n-      { \"\", TARGET_MASK_68020, \"\" }}  */\n-\n #define TARGET_SWITCHES\t\t\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n   { \"cond-move\",\t-MASK_NO_COND_MOVE,\t\t\t\t\\\n@@ -472,25 +137,6 @@ extern int target_flags;\n   { \"\",\t\t\t TARGET_DEFAULT, \"\" },\t\t\t\t\\\n }\n \n-/* This macro is similar to `TARGET_SWITCHES' but defines names of command\n-   options that have values.  Its definition is an initializer with a\n-   subgrouping for each command option.\n-\n-   Each subgrouping contains a string constant, that defines the fixed part of\n-   the option name, the address of a variable, and a description string.  The\n-   variable, type `char *', is set to the variable part of the given option if\n-   the fixed part matches.  The actual option name is made by appending `-m' to\n-   the specified name.\n-\n-   Here is an example which defines `-mshort-data-<number>'.  If the given\n-   option is `-mshort-data-512', the variable `m88k_short_data' will be set to\n-   the string \"512\".\n-\n-   extern char *m88k_short_data;\n-   #define TARGET_OPTIONS \\\n-     { { \"short-data-\", &m88k_short_data, \\\n-\t \"Specify the size of the short data section\" } } */\n-\n #define TARGET_OPTIONS\t\t\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n   {\"branch-cost=\",  &d30v_branch_cost_string,\t\t\t\t\\\n@@ -500,496 +146,97 @@ extern int target_flags;\n      N_(\"Change the threshold for conversion to conditional execution\") }, \\\n }\n \n-/* This macro is a C statement to print on `stderr' a string describing the\n-   particular machine description choice.  Every machine description should\n-   define `TARGET_VERSION'.  For example:\n-\n-        #ifdef MOTOROLA\n-        #define TARGET_VERSION \\\n-          fprintf (stderr, \" (68k, Motorola syntax)\");\n-        #else\n-        #define TARGET_VERSION \\\n-          fprintf (stderr, \" (68k, MIT syntax)\");\n-        #endif  */\n #define TARGET_VERSION fprintf (stderr, \" d30v\")\n \n-/* Sometimes certain combinations of command options do not make sense on a\n-   particular target machine.  You can define a macro `OVERRIDE_OPTIONS' to\n-   take account of this.  This macro, if defined, is executed once just after\n-   all the command options have been parsed.\n-\n-   Don't use this macro to turn on various extra optimizations for `-O'.  That\n-   is what `OPTIMIZATION_OPTIONS' is for.  */\n-\n #define OVERRIDE_OPTIONS override_options ()\n \n-/* Some machines may desire to change what optimizations are performed for\n-   various optimization levels.  This macro, if defined, is executed once just\n-   after the optimization level is determined and before the remainder of the\n-   command options have been parsed.  Values set in this macro are used as the\n-   default values for the other command line options.\n-\n-   LEVEL is the optimization level specified; 2 if `-O2' is specified, 1 if\n-   `-O' is specified, and 0 if neither is specified.\n-\n-   SIZE is non-zero if `-Os' is specified, 0 otherwise.  \n-\n-   You should not use this macro to change options that are not\n-   machine-specific.  These should uniformly selected by the same optimization\n-   level on all supported machines.  Use this macro to enable machbine-specific\n-   optimizations.\n-\n-   *Do not examine `write_symbols' in this macro!* The debugging options are\n-   *not supposed to alter the generated code.  */\n-\n-/* #define OPTIMIZATION_OPTIONS(LEVEL,SIZE) */\n-\n-/* Define this macro if debugging can be performed even without a frame\n-   pointer.  If this macro is defined, GNU CC will turn on the\n-   `-fomit-frame-pointer' option whenever `-O' is specified.  */\n #define CAN_DEBUG_WITHOUT_FP\n \n \f\n /* Storage Layout */\n \n-/* Define this macro to have the value 1 if the most significant bit in a byte\n-   has the lowest number; otherwise define it to have the value zero.  This\n-   means that bit-field instructions count from the most significant bit.  If\n-   the machine has no bit-field instructions, then this must still be defined,\n-   but it doesn't matter which value it is defined to.  This macro need not be\n-   a constant.\n-\n-   This macro does not affect the way structure fields are packed into bytes or\n-   words; that is controlled by `BYTES_BIG_ENDIAN'.  */\n #define BITS_BIG_ENDIAN 1\n \n-/* Define this macro to have the value 1 if the most significant byte in a word\n-   has the lowest number.  This macro need not be a constant.  */\n #define BYTES_BIG_ENDIAN 1\n \n-/* Define this macro to have the value 1 if, in a multiword object, the most\n-   significant word has the lowest number.  This applies to both memory\n-   locations and registers; GNU CC fundamentally assumes that the order of\n-   words in memory is the same as the order in registers.  This macro need not\n-   be a constant.  */\n #define WORDS_BIG_ENDIAN 1\n \n-/* Define this macro if WORDS_BIG_ENDIAN is not constant.  This must be a\n-   constant value with the same meaning as WORDS_BIG_ENDIAN, which will be used\n-   only when compiling libgcc2.c.  Typically the value will be set based on\n-   preprocessor defines.  */\n-/* #define LIBGCC2_WORDS_BIG_ENDIAN */\n-\n-/* Define this macro to have the value 1 if `DFmode', `XFmode' or `TFmode'\n-   floating point numbers are stored in memory with the word containing the\n-   sign bit at the lowest address; otherwise define it to have the value 0.\n-   This macro need not be a constant.\n-\n-   You need not define this macro if the ordering is the same as for multi-word\n-   integers.  */\n-/* #define FLOAT_WORDS_BIG_EnNDIAN */\n-\n-/* Define this macro to be the number of bits in an addressable storage unit\n-   (byte); normally 8.  */\n #define BITS_PER_UNIT 8\n \n-/* Number of bits in a word; normally 32.  */\n #define BITS_PER_WORD 32\n \n-/* Maximum number of bits in a word.  If this is undefined, the default is\n-   `BITS_PER_WORD'.  Otherwise, it is the constant value that is the largest\n-   value that `BITS_PER_WORD' can have at run-time.  */\n-/* #define MAX_BITS_PER_WORD */\n-\n-/* Number of storage units in a word; normally 4.  */\n #define UNITS_PER_WORD 4\n \n-/* Minimum number of units in a word.  If this is undefined, the default is\n-   `UNITS_PER_WORD'.  Otherwise, it is the constant value that is the smallest\n-   value that `UNITS_PER_WORD' can have at run-time.  */\n-/* #define MIN_UNITS_PER_WORD */\n-\n-/* Width of a pointer, in bits.  You must specify a value no wider than the\n-   width of `Pmode'.  If it is not equal to the width of `Pmode', you must\n-   define `POINTERS_EXTEND_UNSIGNED'.  */\n #define POINTER_SIZE 32\n \n-/* A C expression whose value is nonzero if pointers that need to be extended\n-   from being `POINTER_SIZE' bits wide to `Pmode' are sign-extended and zero if\n-   they are zero-extended.\n-\n-   You need not define this macro if the `POINTER_SIZE' is equal to the width\n-   of `Pmode'.  */\n-/* #define POINTERS_EXTEND_UNSIGNED */\n-\n-/* A macro to update M and UNSIGNEDP when an object whose type is TYPE and\n-   which has the specified mode and signedness is to be stored in a register.\n-   This macro is only called when TYPE is a scalar type.\n-\n-   On most RISC machines, which only have operations that operate on a full\n-   register, define this macro to set M to `word_mode' if M is an integer mode\n-   narrower than `BITS_PER_WORD'.  In most cases, only integer modes should be\n-   widened because wider-precision floating-point operations are usually more\n-   expensive than their narrower counterparts.\n-\n-   For most machines, the macro definition does not change UNSIGNEDP.  However,\n-   some machines, have instructions that preferentially handle either signed or\n-   unsigned quantities of certain modes.  For example, on the DEC Alpha, 32-bit\n-   loads from memory and 32-bit add instructions sign-extend the result to 64\n-   bits.  On such machines, set UNSIGNEDP according to which kind of extension\n-   is more efficient.\n-\n-   Do not define this macro if it would never modify M.  */\n #define PROMOTE_MODE(MODE,UNSIGNEDP,TYPE)\t\t\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n   if (GET_MODE_CLASS (MODE) == MODE_INT\t\t\t\t\t\\\n       && GET_MODE_SIZE (MODE) < 4)\t\t\t\t\t\\\n     (MODE) = SImode;\t\t\t\t\t\t\t\\\n } while (0)\n \n-/* Define this macro if the promotion described by `PROMOTE_MODE' should also\n-   be done for outgoing function arguments.  */\n-/* #define PROMOTE_FUNCTION_ARGS */\n-\n-/* Define this macro if the promotion described by `PROMOTE_MODE' should also\n-   be done for the return value of functions.\n-\n-   If this macro is defined, `FUNCTION_VALUE' must perform the same promotions\n-   done by `PROMOTE_MODE'.  */\n-/* #define PROMOTE_FUNCTION_RETURN */\n-\n-/* Define this macro if the promotion described by `PROMOTE_MODE' should *only*\n-   be performed for outgoing function arguments or function return values, as\n-   specified by `PROMOTE_FUNCTION_ARGS' and `PROMOTE_FUNCTION_RETURN',\n-   respectively.  */\n-/* #define PROMOTE_FOR_CALL_ONLY */\n-\n-/* Normal alignment required for function parameters on the stack, in bits.\n-   All stack parameters receive at least this much alignment regardless of data\n-   type.  On most machines, this is the same as the size of an integer.  */\n-\n #define PARM_BOUNDARY 32\n \n-/* Define this macro if you wish to preserve a certain alignment for the stack\n-   pointer.  The definition is a C expression for the desired alignment\n-   (measured in bits).\n-\n-   If `PUSH_ROUNDING' is not defined, the stack will always be aligned to the\n-   specified boundary.  If `PUSH_ROUNDING' is defined and specifies a less\n-   strict alignment than `STACK_BOUNDARY', the stack may be momentarily\n-   unaligned while pushing arguments.  */\n-\n #define STACK_BOUNDARY 64\n \n-/* Alignment required for a function entry point, in bits.  */\n-\n #define FUNCTION_BOUNDARY 64\n \n-/* Biggest alignment that any data type can require on this machine,\n-   in bits.  */\n-\n #define BIGGEST_ALIGNMENT 64\n \n-/* Biggest alignment that any structure field can require on this machine, in\n-   bits.  If defined, this overrides `BIGGEST_ALIGNMENT' for structure fields\n-   only.  */\n-/* #define BIGGEST_FIELD_ALIGNMENT */\n-\n-/* Biggest alignment supported by the object file format of this machine.  Use\n-   this macro to limit the alignment which can be specified using the\n-   `__attribute__ ((aligned (N)))' construct.  If not defined, the default\n-   value is `BIGGEST_ALIGNMENT'.\n-\n-   Defined in svr4.h.  */\n+/* Defined in svr4.h.  */\n /* #define MAX_OFILE_ALIGNMENT */\n \n-/* If defined, a C expression to compute the alignment for a static variable.\n-   TYPE is the data type, and BASIC-ALIGN is the alignment that the object\n-   would ordinarily have.  The value of this macro is used instead of that\n-   alignment to align the object.\n-\n-   If this macro is not defined, then BASIC-ALIGN is used.\n-\n-   One use of this macro is to increase alignment of medium-size data to make\n-   it all fit in fewer cache lines.  Another is to cause character arrays to be\n-   word-aligned so that `strcpy' calls that copy constants to character arrays\n-   can be done inline.  */\n-\n #define DATA_ALIGNMENT(TYPE, ALIGN)\t\t\\\n   (TREE_CODE (TYPE) == ARRAY_TYPE\t\t\\\n    && TYPE_MODE (TREE_TYPE (TYPE)) == QImode\t\\\n    && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))\n \n-/* If defined, a C expression to compute the alignment given to a constant that\n-   is being placed in memory.  CONSTANT is the constant and BASIC-ALIGN is the\n-   alignment that the object would ordinarily have.  The value of this macro is\n-   used instead of that alignment to align the object.\n-\n-   If this macro is not defined, then BASIC-ALIGN is used.\n-\n-   The typical use of this macro is to increase alignment for string constants\n-   to be word aligned so that `strcpy' calls that copy constants can be done\n-   inline.  */\n-\n #define CONSTANT_ALIGNMENT(EXP, ALIGN)  \\\n   (TREE_CODE (EXP) == STRING_CST\t\\\n    && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))\n \n-/* Alignment in bits to be given to a structure bit field that follows an empty\n-   field such as `int : 0;'.\n-\n-   Note that `PCC_BITFIELD_TYPE_MATTERS' also affects the alignment that\n-   results from an empty field.  */\n-/* #define EMPTY_FIELD_BOUNDARY */\n-\n-/* Number of bits which any structure or union's size must be a multiple of.\n-   Each structure or union's size is rounded up to a multiple of this.\n-\n-   If you do not define this macro, the default is the same as `BITS_PER_UNIT'.  */\n-/* #define STRUCTURE_SIZE_BOUNDARY */\n-\n-/* Define this macro to be the value 1 if instructions will fail to work if\n-   given data not on the nominal alignment.  If instructions will merely go\n-   slower in that case, define this macro as 0.  */\n-\n #define STRICT_ALIGNMENT 1\n \n-/* Define this if you wish to imitate the way many other C compilers handle\n-   alignment of bitfields and the structures that contain them.\n-\n-   The behavior is that the type written for a bitfield (`int', `short', or\n-   other integer type) imposes an alignment for the entire structure, as if the\n-   structure really did contain an ordinary field of that type.  In addition,\n-   the bitfield is placed within the structure so that it would fit within such\n-   a field, not crossing a boundary for it.\n-\n-   Thus, on most machines, a bitfield whose type is written as `int' would not\n-   cross a four-byte boundary, and would force four-byte alignment for the\n-   whole structure.  (The alignment used may not be four bytes; it is\n-   controlled by the other alignment parameters.)\n-\n-   If the macro is defined, its definition should be a C expression; a nonzero\n-   value for the expression enables this behavior.\n-\n-   Note that if this macro is not defined, or its value is zero, some bitfields\n-   may cross more than one alignment boundary.  The compiler can support such\n-   references if there are `insv', `extv', and `extzv' insns that can directly\n-   reference memory.\n-\n-   The other known way of making bitfields work is to define\n-   `STRUCTURE_SIZE_BOUNDARY' as large as `BIGGEST_ALIGNMENT'.  Then every\n-   structure can be accessed with fullwords.\n-\n-   Unless the machine has bitfield instructions or you define\n-   `STRUCTURE_SIZE_BOUNDARY' that way, you must define\n-   `PCC_BITFIELD_TYPE_MATTERS' to have a nonzero value.\n-\n-   If your aim is to make GNU CC use the same conventions for laying out\n-   bitfields as are used by another compiler, here is how to investigate what\n-   the other compiler does.  Compile and run this program:\n-\n-        struct foo1\n-        {\n-          char x;\n-          char :0;\n-          char y;\n-        };\n-\n-        struct foo2\n-        {\n-          char x;\n-          int :0;\n-          char y;\n-        };\n-\n-        main ()\n-        {\n-          printf (\"Size of foo1 is %d\\n\",\n-                  sizeof (struct foo1));\n-          printf (\"Size of foo2 is %d\\n\",\n-                  sizeof (struct foo2));\n-          exit (0);\n-        }\n-\n-   If this prints 2 and 5, then the compiler's behavior is what you would get\n-   from `PCC_BITFIELD_TYPE_MATTERS'.\n-\n-   Defined in svr4.h.  */\n+/* Defined in svr4.h.  */\n \n #define PCC_BITFIELD_TYPE_MATTERS 1\n \n-/* Like PCC_BITFIELD_TYPE_MATTERS except that its effect is limited to aligning\n-   a bitfield within the structure.  */\n-/* #define BITFIELD_NBYTES_LIMITED */\n-\n-/* Define this macro as an expression for the overall size of a structure\n-   (given by STRUCT as a tree node) when the size computed from the fields is\n-   SIZE and the alignment is ALIGN.\n-\n-   The default is to round SIZE up to a multiple of ALIGN.  */\n-/* #define ROUND_TYPE_SIZE(STRUCT, SIZE, ALIGN) */\n-\n-/* Define this macro as an expression for the alignment of a structure (given\n-   by STRUCT as a tree node) if the alignment computed in the usual way is\n-   COMPUTED and the alignment explicitly specified was SPECIFIED.\n-\n-   The default is to use SPECIFIED if it is larger; otherwise, use the smaller\n-   of COMPUTED and `BIGGEST_ALIGNMENT' */\n-/* #define ROUND_TYPE_ALIGN(STRUCT, COMPUTED, SPECIFIED) */\n-\n-/* An integer expression for the size in bits of the largest integer machine\n-   mode that should actually be used.  All integer machine modes of this size\n-   or smaller can be used for structures and unions with the appropriate sizes.\n-   If this macro is undefined, `GET_MODE_BITSIZE (DImode)' is assumed.  */\n-/* #define MAX_FIXED_MODE_SIZE */\n-\n-/* A C statement to validate the value VALUE (of type `double') for mode MODE.\n-   This means that you check whether VALUE fits within the possible range of\n-   values for mode MODE on this target machine.  The mode MODE is always a mode\n-   of class `MODE_FLOAT'.  OVERFLOW is nonzero if the value is already known to\n-   be out of range.\n-\n-   If VALUE is not valid or if OVERFLOW is nonzero, you should set OVERFLOW to\n-   1 and then assign some valid value to VALUE.  Allowing an invalid value to\n-   go through the compiler can produce incorrect assembler code which may even\n-   cause Unix assemblers to crash.\n-\n-   This macro need not be defined if there is no work for it to do.  */\n-/* #define CHECK_FLOAT_VALUE(MODE, VALUE, OVERFLOW) */\n-\n-/* A code distinguishing the floating point format of the target machine.\n-   There are three defined values:\n-\n-   IEEE_FLOAT_FORMAT'\n-        This code indicates IEEE floating point.  It is the default;\n-        there is no need to define this macro when the format is IEEE.\n-\n-   VAX_FLOAT_FORMAT'\n-        This code indicates the peculiar format used on the VAX.\n-\n-   UNKNOWN_FLOAT_FORMAT'\n-        This code indicates any other format.\n-\n-   The value of this macro is compared with `HOST_FLOAT_FORMAT' (*note\n-   Config::.) to determine whether the target machine has the same format as\n-   the host machine.  If any other formats are actually in use on supported\n-   machines, new codes should be defined for them.\n-\n-   The ordering of the component words of floating point values stored in\n-   memory is controlled by `FLOAT_WORDS_BIG_ENDIAN' for the target machine and\n-   `HOST_FLOAT_WORDS_BIG_ENDIAN' for the host.  */\n #define TARGET_FLOAT_FORMAT IEEE_FLOAT_FORMAT\n \n \f\n /* Layout of Source Language Data Types */\n \n-/* A C expression for the size in bits of the type `int' on the target machine.\n-   If you don't define this, the default is one word.  */\n #define INT_TYPE_SIZE 32\n \n-/* A C expression for the size in bits of the type `short' on the target\n-   machine.  If you don't define this, the default is half a word.  (If this\n-   would be less than one storage unit, it is rounded up to one unit.)  */\n #define SHORT_TYPE_SIZE 16\n \n-/* A C expression for the size in bits of the type `long' on the target\n-   machine.  If you don't define this, the default is one word.  */\n #define LONG_TYPE_SIZE 32\n \n-/* Maximum number for the size in bits of the type `long' on the target\n-   machine.  If this is undefined, the default is `LONG_TYPE_SIZE'.  Otherwise,\n-   it is the constant value that is the largest value that `LONG_TYPE_SIZE' can\n-   have at run-time.  This is used in `cpp'.  */\n-/* #define MAX_LONG_TYPE_SIZE */\n-\n-/* A C expression for the size in bits of the type `long long' on the target\n-   machine.  If you don't define this, the default is two words.  If you want\n-   to support GNU Ada on your machine, the value of macro must be at least 64.  */\n #define LONG_LONG_TYPE_SIZE 64\n \n-/* A C expression for the size in bits of the type `char' on the target\n-   machine.  If you don't define this, the default is one quarter of a word.\n-   (If this would be less than one storage unit, it is rounded up to one unit.)  */\n #define CHAR_TYPE_SIZE 8\n \n-/* Maximum number for the size in bits of the type `char' on the target\n-   machine.  If this is undefined, the default is `CHAR_TYPE_SIZE'.  Otherwise,\n-   it is the constant value that is the largest value that `CHAR_TYPE_SIZE' can\n-   have at run-time.  This is used in `cpp'.  */\n-/* #define MAX_CHAR_TYPE_SIZE */\n-\n-/* A C expression for the size in bits of the type `float' on the target\n-   machine.  If you don't define this, the default is one word.  */\n #define FLOAT_TYPE_SIZE 32\n \n-/* A C expression for the size in bits of the type `double' on the target\n-   machine.  If you don't define this, the default is two words.  */\n #define DOUBLE_TYPE_SIZE 64\n \n-/* A C expression for the size in bits of the type `long double' on the target\n-   machine.  If you don't define this, the default is two words.  */\n #define LONG_DOUBLE_TYPE_SIZE 64\n \n-/* An expression whose value is 1 or 0, according to whether the type `char'\n-   should be signed or unsigned by default.  The user can always override this\n-   default with the options `-fsigned-char' and `-funsigned-char'.  */\n #define DEFAULT_SIGNED_CHAR 1\n \n-/* A C expression to determine whether to give an `enum' type only as many\n-   bytes as it takes to represent the range of possible values of that type.  A\n-   nonzero value means to do that; a zero value means all `enum' types should\n-   be allocated like `int'.\n-\n-   If you don't define the macro, the default is 0.  */\n-/* #define DEFAULT_SHORT_ENUMS */\n-\n-/* A C expression for a string describing the name of the data type to use for\n-   size values.  The typedef name `size_t' is defined using the contents of the\n-   string.\n-\n-   The string can contain more than one keyword.  If so, separate them with\n-   spaces, and write first any length keyword, then `unsigned' if appropriate,\n-   and finally `int'.  The string must exactly match one of the data type names\n-   defined in the function `init_decl_processing' in the file `c-decl.c'.  You\n-   may not omit `int' or change the order--that would cause the compiler to\n-   crash on startup.\n-\n-   If you don't define this macro, the default is `\"long unsigned int\"'.\n-\n-   Defined in svr4.h.  */\n+/* Defined in svr4.h.  */\n /* #define SIZE_TYPE */\n \n-/* A C expression for a string describing the name of the data type to use for\n-   the result of subtracting two pointers.  The typedef name `ptrdiff_t' is\n-   defined using the contents of the string.  See `SIZE_TYPE' above for more\n-   information.\n-\n-   If you don't define this macro, the default is `\"long int\"'.\n-\n-   Defined in svr4.h.  */\n+/* Defined in svr4.h.  */\n /* #define PTRDIFF_TYPE */\n \n-/* A C expression for a string describing the name of the data type to use for\n-   wide characters.  The typedef name `wchar_t' is defined using the contents\n-   of the string.  See `SIZE_TYPE' above for more information.\n-\n-   If you don't define this macro, the default is `\"int\"'.\n-\n-   Defined in svr4.h.  */\n+/* Defined in svr4.h.  */\n /* #define WCHAR_TYPE */\n \n-/* A C expression for the size in bits of the data type for wide characters.\n-   This is used in `cpp', which cannot make use of `WCHAR_TYPE'.\n-\n-   Defined in svr4.h.  */\n+/* Defined in svr4.h.  */\n /* #define WCHAR_TYPE_SIZE */\n \n-/* Maximum number for the size in bits of the data type for wide characters.\n-   If this is undefined, the default is `WCHAR_TYPE_SIZE'.  Otherwise, it is\n-   the constant value that is the largest value that `WCHAR_TYPE_SIZE' can have\n-   at run-time.  This is used in `cpp'.  */\n-/* #define MAX_WCHAR_TYPE_SIZE */\n-\n \f\n /* D30V register layout.  */\n "}, {"sha": "8233b9275440e84f017e959c1dce61fae8d7d687", "filename": "gcc/config/dsp16xx/dsp16xx.h", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1552d7b014918281e1bcb68388936b68094e354/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1552d7b014918281e1bcb68388936b68094e354/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.h?ref=d1552d7b014918281e1bcb68388936b68094e354", "patch": "@@ -251,23 +251,6 @@ extern int target_flags;\n #define TARGET_DEFAULT  MASK_REGPARM|MASK_YBASE_HIGH\n #endif\n \n-/* This macro is similar to `TARGET_SWITCHES' but defines names of\n-   command options that have values.  Its definition is an\n-   initializer with a subgrouping for each command option.\n-\n-   Each subgrouping contains a string constant, that defines the\n-   fixed part of the option name, and the address of a variable. \n-   The variable, type `char *', is set to the variable part of the\n-   given option if the fixed part matches.  The actual option name\n-   is made by appending `-m' to the specified name.\n-\n-   Here is an example which defines `-mshort-data-NUMBER'.  If the\n-   given option is `-mshort-data-512', the variable `m88k_short_data'\n-   will be set to the string `\"512\"'.\n-\n-\textern char *m88k_short_data;\n-\t#define TARGET_OPTIONS { { \"short-data-\", &m88k_short_data } }  */\n-\n #define TARGET_OPTIONS\t\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\\\n   { \"text=\",\t&text_seg_name,\t\t\t\t        \\"}, {"sha": "34e52a8361b3102cd7490450ac62acb65f5ab2a6", "filename": "gcc/config/fr30/fr30.h", "status": "modified", "additions": 3, "deletions": 188, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1552d7b014918281e1bcb68388936b68094e354/gcc%2Fconfig%2Ffr30%2Ffr30.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1552d7b014918281e1bcb68388936b68094e354/gcc%2Fconfig%2Ffr30%2Ffr30.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Ffr30.h?ref=d1552d7b014918281e1bcb68388936b68094e354", "patch": "@@ -24,29 +24,10 @@ Boston, MA 02111-1307, USA.  */\n /*}}}*/ \f\n /*{{{  Driver configuration.  */ \n \n-/* A C expression which determines whether the option `-CHAR' takes arguments.\n-   The value should be the number of arguments that option takes-zero, for many\n-   options.\n-\n-   By default, this macro is defined to handle the standard options properly.\n-   You need not define it unless you wish to add additional options which take\n-   arguments.\n-\n-   Defined in svr4.h.  */\n+/* Defined in svr4.h.  */\n #undef SWITCH_TAKES_ARG\n \n-/* A C expression which determines whether the option `-NAME' takes arguments.\n-   The value should be the number of arguments that option takes-zero, for many\n-   options.  This macro rather than `SWITCH_TAKES_ARG' is used for\n-   multi-character option names.\n-\n-   By default, this macro is defined as `DEFAULT_WORD_SWITCH_TAKES_ARG', which\n-   handles the standard options properly.  You need not define\n-   `WORD_SWITCH_TAKES_ARG' unless you wish to add additional options which take\n-   arguments.  Any redefinition should call `DEFAULT_WORD_SWITCH_TAKES_ARG' and\n-   then check for additional options.\n-\n-   Defined in svr4.h.  */\n+/* Defined in svr4.h.  */\n #undef WORD_SWITCH_TAKES_ARG\n \n /*}}}*/ \f\n@@ -81,9 +62,6 @@ extern int target_flags;\n \n #define TARGET_VERSION fprintf (stderr, \" (fr30)\");\n \n-/* Define this macro if debugging can be performed even without a frame\n-   pointer.  If this macro is defined, GNU CC will turn on the\n-   `-fomit-frame-pointer' option whenever `-O' is specified.  */\n #define CAN_DEBUG_WITHOUT_FP\n \n #undef  STARTFILE_SPEC\n@@ -99,61 +77,20 @@ extern int target_flags;\n /*}}}*/ \f\n /*{{{  Storage Layout.  */ \n \n-/* Define this macro to have the value 1 if the most significant bit in a byte\n-   has the lowest number; otherwise define it to have the value zero.  This\n-   means that bit-field instructions count from the most significant bit.  If\n-   the machine has no bit-field instructions, then this must still be defined,\n-   but it doesn't matter which value it is defined to.  This macro need not be\n-   a constant.\n-\n-   This macro does not affect the way structure fields are packed into bytes or\n-   words; that is controlled by `BYTES_BIG_ENDIAN'.  */\n #define BITS_BIG_ENDIAN 1\n \n-/* Define this macro to have the value 1 if the most significant byte in a word\n-   has the lowest number.  This macro need not be a constant.  */\n #define BYTES_BIG_ENDIAN 1\n \n-/* Define this macro to have the value 1 if, in a multiword object, the most\n-   significant word has the lowest number.  This applies to both memory\n-   locations and registers; GNU CC fundamentally assumes that the order of\n-   words in memory is the same as the order in registers.  This macro need not\n-   be a constant.  */\n #define WORDS_BIG_ENDIAN 1\n \n-/* Define this macro to be the number of bits in an addressable storage unit\n-   (byte); normally 8.  */\n #define BITS_PER_UNIT \t8\n \n-/* Number of bits in a word; normally 32.  */\n #define BITS_PER_WORD \t32\n \n-/* Number of storage units in a word; normally 4.  */\n #define UNITS_PER_WORD \t4\n \n-/* Width of a pointer, in bits.  You must specify a value no wider than the\n-   width of `Pmode'.  If it is not equal to the width of `Pmode', you must\n-   define `POINTERS_EXTEND_UNSIGNED'.  */\n #define POINTER_SIZE \t32\n \n-/* A macro to update MODE and UNSIGNEDP when an object whose type is TYPE and\n-   which has the specified mode and signedness is to be stored in a register.\n-   This macro is only called when TYPE is a scalar type.\n-\n-   On most RISC machines, which only have operations that operate on a full\n-   register, define this macro to set M to `word_mode' if M is an integer mode\n-   narrower than `BITS_PER_WORD'.  In most cases, only integer modes should be\n-   widened because wider-precision floating-point operations are usually more\n-   expensive than their narrower counterparts.\n-\n-   For most machines, the macro definition does not change UNSIGNEDP.  However,\n-   some machines, have instructions that preferentially handle either signed or\n-   unsigned quantities of certain modes.  For example, on the DEC Alpha, 32-bit\n-   loads from memory and 32-bit add instructions sign-extend the result to 64\n-   bits.  On such machines, set UNSIGNEDP according to which kind of extension\n-   is more efficient.\n-\n-   Do not define this macro if it would never modify MODE.  */\n #define PROMOTE_MODE(MODE,UNSIGNEDP,TYPE)\t\\\n   do\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\\\n@@ -163,147 +100,28 @@ extern int target_flags;\n     }\t\t\t\t\t\t\\\n   while (0)\n \n-/* Normal alignment required for function parameters on the stack, in bits.\n-   All stack parameters receive at least this much alignment regardless of data\n-   type.  On most machines, this is the same as the size of an integer.  */\n #define PARM_BOUNDARY 32\n \n-/* Define this macro if you wish to preserve a certain alignment for the stack\n-   pointer.  The definition is a C expression for the desired alignment\n-   (measured in bits).\n-\n-   If `PUSH_ROUNDING' is not defined, the stack will always be aligned to the\n-   specified boundary.  If `PUSH_ROUNDING' is defined and specifies a less\n-   strict alignment than `STACK_BOUNDARY', the stack may be momentarily\n-   unaligned while pushing arguments.  */\n #define STACK_BOUNDARY 32\n \n-/* Alignment required for a function entry point, in bits.  */\n #define FUNCTION_BOUNDARY 32\n \n-/* Biggest alignment that any data type can require on this machine,\n-   in bits.  */\n #define BIGGEST_ALIGNMENT 32\n \n-/* If defined, a C expression to compute the alignment for a static variable.\n-   TYPE is the data type, and ALIGN is the alignment that the object\n-   would ordinarily have.  The value of this macro is used instead of that\n-   alignment to align the object.\n-\n-   If this macro is not defined, then ALIGN is used.\n-\n-   One use of this macro is to increase alignment of medium-size data to make\n-   it all fit in fewer cache lines.  Another is to cause character arrays to be\n-   word-aligned so that `strcpy' calls that copy constants to character arrays\n-   can be done inline.  */\n #define DATA_ALIGNMENT(TYPE, ALIGN)\t\t\\\n   (TREE_CODE (TYPE) == ARRAY_TYPE\t\t\\\n    && TYPE_MODE (TREE_TYPE (TYPE)) == QImode\t\\\n    && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))\n \n-/* If defined, a C expression to compute the alignment given to a constant that\n-   is being placed in memory.  CONSTANT is the constant and ALIGN is the\n-   alignment that the object would ordinarily have.  The value of this macro is\n-   used instead of that alignment to align the object.\n-\n-   If this macro is not defined, then ALIGN is used.\n-\n-   The typical use of this macro is to increase alignment for string constants\n-   to be word aligned so that `strcpy' calls that copy constants can be done\n-   inline.  */\n #define CONSTANT_ALIGNMENT(EXP, ALIGN)  \\\n   (TREE_CODE (EXP) == STRING_CST\t\\\n    && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))\n \n-/* Define this macro to be the value 1 if instructions will fail to work if\n-   given data not on the nominal alignment.  If instructions will merely go\n-   slower in that case, define this macro as 0.  */\n #define STRICT_ALIGNMENT 1\n \n-/* Define this if you wish to imitate the way many other C compilers handle\n-   alignment of bitfields and the structures that contain them.\n-\n-   The behavior is that the type written for a bitfield (`int', `short', or\n-   other integer type) imposes an alignment for the entire structure, as if the\n-   structure really did contain an ordinary field of that type.  In addition,\n-   the bitfield is placed within the structure so that it would fit within such\n-   a field, not crossing a boundary for it.\n-\n-   Thus, on most machines, a bitfield whose type is written as `int' would not\n-   cross a four-byte boundary, and would force four-byte alignment for the\n-   whole structure.  (The alignment used may not be four bytes; it is\n-   controlled by the other alignment parameters.)\n-\n-   If the macro is defined, its definition should be a C expression; a nonzero\n-   value for the expression enables this behavior.\n-\n-   Note that if this macro is not defined, or its value is zero, some bitfields\n-   may cross more than one alignment boundary.  The compiler can support such\n-   references if there are `insv', `extv', and `extzv' insns that can directly\n-   reference memory.\n-\n-   The other known way of making bitfields work is to define\n-   `STRUCTURE_SIZE_BOUNDARY' as large as `BIGGEST_ALIGNMENT'.  Then every\n-   structure can be accessed with fullwords.\n-\n-   Unless the machine has bitfield instructions or you define\n-   `STRUCTURE_SIZE_BOUNDARY' that way, you must define\n-   `PCC_BITFIELD_TYPE_MATTERS' to have a nonzero value.\n-\n-   If your aim is to make GNU CC use the same conventions for laying out\n-   bitfields as are used by another compiler, here is how to investigate what\n-   the other compiler does.  Compile and run this program:\n-\n-        struct foo1\n-        {\n-          char x;\n-          char :0;\n-          char y;\n-        };\n-\n-        struct foo2\n-        {\n-          char x;\n-          int :0;\n-          char y;\n-        };\n-\n-        main ()\n-        {\n-          printf (\"Size of foo1 is %d\\n\",\n-                  sizeof (struct foo1));\n-          printf (\"Size of foo2 is %d\\n\",\n-                  sizeof (struct foo2));\n-          exit (0);\n-        }\n-\n-   If this prints 2 and 5, then the compiler's behavior is what you would get\n-   from `PCC_BITFIELD_TYPE_MATTERS'.\n-\n-   Defined in svr4.h.  */\n+/* Defined in svr4.h.  */\n #define PCC_BITFIELD_TYPE_MATTERS 1\n \n-/* A code distinguishing the floating point format of the target machine.\n-   There are three defined values:\n-\n-   IEEE_FLOAT_FORMAT'\n-        This code indicates IEEE floating point.  It is the default;\n-        there is no need to define this macro when the format is IEEE.\n-\n-   VAX_FLOAT_FORMAT'\n-        This code indicates the peculiar format used on the VAX.\n-\n-   UNKNOWN_FLOAT_FORMAT'\n-        This code indicates any other format.\n-\n-   The value of this macro is compared with `HOST_FLOAT_FORMAT'\n-   to determine whether the target machine has the same format as\n-   the host machine.  If any other formats are actually in use on supported\n-   machines, new codes should be defined for them.\n-\n-   The ordering of the component words of floating point values stored in\n-   memory is controlled by `FLOAT_WORDS_BIG_ENDIAN' for the target machine and\n-   `HOST_FLOAT_WORDS_BIG_ENDIAN' for the host.  */\n #define TARGET_FLOAT_FORMAT IEEE_FLOAT_FORMAT\n \n /*}}}*/ \f\n@@ -318,9 +136,6 @@ extern int target_flags;\n #define DOUBLE_TYPE_SIZE \t64\n #define LONG_DOUBLE_TYPE_SIZE \t64\n \n-/* An expression whose value is 1 or 0, according to whether the type `char'\n-   should be signed or unsigned by default.  The user can always override this\n-   default with the options `-fsigned-char' and `-funsigned-char'.  */\n #define DEFAULT_SIGNED_CHAR 1\n \n /*}}}*/ \f"}, {"sha": "19007173c7132c27d2b1bf17626d6405c6b16742", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 0, "deletions": 76, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1552d7b014918281e1bcb68388936b68094e354/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1552d7b014918281e1bcb68388936b68094e354/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=d1552d7b014918281e1bcb68388936b68094e354", "patch": "@@ -205,23 +205,9 @@ extern const char *ia64_fixed_range_string;\n   \"%{mcpu=itanium:-D__itanium__} %{mbig-endian:-D__BIG_ENDIAN__}\t\\\n    -D__LONG_MAX__=9223372036854775807L\"\n \n-/* If this macro is defined, the preprocessor will not define the builtin macro\n-   `__SIZE_TYPE__'.  The macro `__SIZE_TYPE__' must then be defined by\n-   `CPP_SPEC' instead.\n-\n-   This should be defined if `SIZE_TYPE' depends on target dependent flags\n-   which are not accessible to the preprocessor.  Otherwise, it should not be\n-   defined.  */\n /* This is always \"long\" so it doesn't \"change\" in ILP32 vs. LP64.  */\n /* #define NO_BUILTIN_SIZE_TYPE */\n \n-/* If this macro is defined, the preprocessor will not define the builtin macro\n-   `__PTRDIFF_TYPE__'.  The macro `__PTRDIFF_TYPE__' must then be defined by\n-   `CPP_SPEC' instead.\n-\n-   This should be defined if `PTRDIFF_TYPE' depends on target dependent flags\n-   which are not accessible to the preprocessor.  Otherwise, it should not be\n-   defined.  */\n /* This is always \"long\" so it doesn't \"change\" in ILP32 vs. LP64.  */\n /* #define NO_BUILTIN_PTRDIFF_TYPE */\n \n@@ -245,39 +231,25 @@ extern const char *ia64_fixed_range_string;\n \n #define BITS_BIG_ENDIAN 0\n \n-/* Define this macro to have the value 1 if the most significant byte in a word\n-   has the lowest number.  This macro need not be a constant.  */\n-\n #define BYTES_BIG_ENDIAN (TARGET_BIG_ENDIAN != 0)\n \n /* Define this macro to have the value 1 if, in a multiword object, the most\n    significant word has the lowest number.  */\n \n #define WORDS_BIG_ENDIAN (TARGET_BIG_ENDIAN != 0)\n \n-/* Define this macro if WORDS_BIG_ENDIAN is not constant.  This must be a\n-   constant value with the same meaning as WORDS_BIG_ENDIAN, which will be used\n-   only when compiling libgcc2.c.  Typically the value will be set based on\n-   preprocessor defines.  */\n #if defined(__BIG_ENDIAN__)\n #define LIBGCC2_WORDS_BIG_ENDIAN 1\n #else\n #define LIBGCC2_WORDS_BIG_ENDIAN 0\n #endif\n \n-/* Define this macro to be the number of bits in an addressable storage unit\n-   (byte); normally 8.  */\n #define BITS_PER_UNIT 8\n \n-/* Number of bits in a word; normally 32.  */\n #define BITS_PER_WORD 64\n \n-/* Number of storage units in a word; normally 4.  */\n #define UNITS_PER_WORD 8\n \n-/* Width of a pointer, in bits.  You must specify a value no wider than the\n-   width of `Pmode'.  If it is not equal to the width of `Pmode', you must\n-   define `POINTERS_EXTEND_UNSIGNED'.  */\n #define POINTER_SIZE (TARGET_ILP32 ? 32 : 64)\n \n /* A C expression whose value is zero if pointers that need to be extended\n@@ -301,22 +273,12 @@ do\t\t\t\t\t\t\t\t\t\\\n   }\t\t\t\t\t\t\t\t\t\\\n while (0)\n \n-/* Define this macro if the promotion described by `PROMOTE_MODE' should also\n-   be done for outgoing function arguments.  */\n /* ??? ABI doesn't allow us to define this.  */\n /* #define PROMOTE_FUNCTION_ARGS */\n \n-/* Define this macro if the promotion described by `PROMOTE_MODE' should also\n-   be done for the return value of functions.\n-\n-   If this macro is defined, `FUNCTION_VALUE' must perform the same promotions\n-   done by `PROMOTE_MODE'.  */\n /* ??? ABI doesn't allow us to define this.  */\n /* #define PROMOTE_FUNCTION_RETURN */\n \n-/* Normal alignment required for function parameters on the stack, in bits.\n-   All stack parameters receive at least this much alignment regardless of data\n-   type.  On most machines, this is the same as the size of an integer.  */\n #define PARM_BOUNDARY 64\n \n /* Define this macro if you wish to preserve a certain alignment for the stack\n@@ -330,11 +292,8 @@ while (0)\n #define IA64_STACK_ALIGN(LOC) (((LOC) + 15) & ~15)\n #endif\n \n-/* Alignment required for a function entry point, in bits.  */\n #define FUNCTION_BOUNDARY 128\n \n-/* Biggest alignment that any data type can require on this machine,\n-   in bits.  */\n /* Optional x86 80-bit float, quad-precision 128-bit float, and quad-word\n    128 bit integers all require 128 bit alignment.  */\n #define BIGGEST_ALIGNMENT 128\n@@ -358,9 +317,6 @@ while (0)\n   (TREE_CODE (EXP) == STRING_CST\t\\\n    && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))\n \n-/* Define this macro to be the value 1 if instructions will fail to work if\n-   given data not on the nominal alignment.  If instructions will merely go\n-   slower in that case, define this macro as 0.  */\n #define STRICT_ALIGNMENT 1\n \n /* Define this if you wish to imitate the way many other C compilers handle\n@@ -391,55 +347,29 @@ while (0)\n \f\n /* Layout of Source Language Data Types */\n \n-/* A C expression for the size in bits of the type `int' on the target machine.\n-   If you don't define this, the default is one word.  */\n #define INT_TYPE_SIZE 32\n \n-/* A C expression for the size in bits of the type `short' on the target\n-   machine.  If you don't define this, the default is half a word.  (If this\n-   would be less than one storage unit, it is rounded up to one unit.)  */\n #define SHORT_TYPE_SIZE 16\n \n-/* A C expression for the size in bits of the type `long' on the target\n-   machine.  If you don't define this, the default is one word.  */\n #define LONG_TYPE_SIZE (TARGET_ILP32 ? 32 : 64)\n \n-/* Maximum number for the size in bits of the type `long' on the target\n-   machine.  If this is undefined, the default is `LONG_TYPE_SIZE'.  Otherwise,\n-   it is the constant value that is the largest value that `LONG_TYPE_SIZE' can\n-   have at run-time.  This is used in `cpp'.  */\n #define MAX_LONG_TYPE_SIZE 64\n \n-/* A C expression for the size in bits of the type `long long' on the target\n-   machine.  If you don't define this, the default is two words.  If you want\n-   to support GNU Ada on your machine, the value of macro must be at least 64.  */\n #define LONG_LONG_TYPE_SIZE 64\n \n-/* A C expression for the size in bits of the type `char' on the target\n-   machine.  If you don't define this, the default is one quarter of a word.\n-   (If this would be less than one storage unit, it is rounded up to one unit.)  */\n #define CHAR_TYPE_SIZE 8\n \n-/* A C expression for the size in bits of the type `float' on the target\n-   machine.  If you don't define this, the default is one word.  */\n #define FLOAT_TYPE_SIZE 32\n \n-/* A C expression for the size in bits of the type `double' on the target\n-   machine.  If you don't define this, the default is two words.  */\n #define DOUBLE_TYPE_SIZE 64\n \n-/* A C expression for the size in bits of the type `long double' on the target\n-   machine.  If you don't define this, the default is two words.  */\n #define LONG_DOUBLE_TYPE_SIZE 128\n \n /* Tell real.c that this is the 80-bit Intel extended float format\n    packaged in a 128-bit entity.  */\n \n #define INTEL_EXTENDED_IEEE_FORMAT 1\n \n-/* An expression whose value is 1 or 0, according to whether the type `char'\n-   should be signed or unsigned by default.  The user can always override this\n-   default with the options `-fsigned-char' and `-funsigned-char'.  */\n #define DEFAULT_SIGNED_CHAR 1\n \n /* A C expression for a string describing the name of the data type to use for\n@@ -464,12 +394,6 @@ while (0)\n    This is used in `cpp', which cannot make use of `WCHAR_TYPE'.  */\n /* #define WCHAR_TYPE_SIZE */\n \n-/* Maximum number for the size in bits of the data type for wide characters.\n-   If this is undefined, the default is `WCHAR_TYPE_SIZE'.  Otherwise, it is\n-   the constant value that is the largest value that `WCHAR_TYPE_SIZE' can have\n-   at run-time.  This is used in `cpp'.  */\n-/* #define MAX_WCHAR_TYPE_SIZE */\n-\n \f\n /* Register Basics */\n "}, {"sha": "2965fa5ddcfb9cc1d30666a2c9b044c00a975024", "filename": "gcc/config/m68hc11/m68hc11.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1552d7b014918281e1bcb68388936b68094e354/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1552d7b014918281e1bcb68388936b68094e354/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h?ref=d1552d7b014918281e1bcb68388936b68094e354", "patch": "@@ -281,8 +281,6 @@ extern const struct processor_costs *m68hc11_cost;\n /* Allocation boundary (bits) for the code of a function.  */\n #define FUNCTION_BOUNDARY\t8\n \n-/* Biggest alignment that any data type can require on this machine,\n-   in bits.  */\n #define BIGGEST_ALIGNMENT\t8\n \n /* Alignment of field after `int : 0' in a structure.  */"}, {"sha": "58fba77ceb5383a0430dd8f4246020cacaf5dc95", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1552d7b014918281e1bcb68388936b68094e354/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1552d7b014918281e1bcb68388936b68094e354/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=d1552d7b014918281e1bcb68388936b68094e354", "patch": "@@ -583,23 +583,6 @@ extern void\t\tsbss_section PARAMS ((void));\n #endif\n #endif\n \n-/* This macro is similar to `TARGET_SWITCHES' but defines names of\n-   command options that have values.  Its definition is an\n-   initializer with a subgrouping for each command option.\n-\n-   Each subgrouping contains a string constant, that defines the\n-   fixed part of the option name, and the address of a variable.\n-   The variable, type `char *', is set to the variable part of the\n-   given option if the fixed part matches.  The actual option name\n-   is made by appending `-m' to the specified name.\n-\n-   Here is an example which defines `-mshort-data-NUMBER'.  If the\n-   given option is `-mshort-data-512', the variable `m88k_short_data'\n-   will be set to the string `\"512\"'.\n-\n-\textern char *m88k_short_data;\n-\t#define TARGET_OPTIONS { { \"short-data-\", &m88k_short_data } }  */\n-\n #define TARGET_OPTIONS\t\t\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n   SUBTARGET_TARGET_OPTIONS\t\t\t\t\t\t\\\n@@ -2761,9 +2744,6 @@ extern struct mips_frame_info current_frame_info;\n #define RETURN_IN_MEMORY(TYPE)\t\\\n   (TYPE_MODE (TYPE) == BLKmode)\n \f\n-/* A code distinguishing the floating point format of the target\n-   machine.  There are three defined values: IEEE_FLOAT_FORMAT,\n-   VAX_FLOAT_FORMAT, and UNKNOWN_FLOAT_FORMAT.  */\n \n #define TARGET_FLOAT_FORMAT IEEE_FLOAT_FORMAT\n "}, {"sha": "10e16196232a647bc292154026350464d2c87702", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1552d7b014918281e1bcb68388936b68094e354/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1552d7b014918281e1bcb68388936b68094e354/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=d1552d7b014918281e1bcb68388936b68094e354", "patch": "@@ -417,23 +417,6 @@ extern enum processor_type rs6000_cpu;\n    and the old mnemonics are dialect zero.  */\n #define ASSEMBLER_DIALECT (TARGET_NEW_MNEMONICS ? 1 : 0)\n \n-/* This macro is similar to `TARGET_SWITCHES' but defines names of\n-   command options that have values.  Its definition is an\n-   initializer with a subgrouping for each command option.\n-\n-   Each subgrouping contains a string constant, that defines the\n-   fixed part of the option name, and the address of a variable.\n-   The variable, type `char *', is set to the variable part of the\n-   given option if the fixed part matches.  The actual option name\n-   is made by appending `-m' to the specified name.\n-\n-   Here is an example which defines `-mshort-data-NUMBER'.  If the\n-   given option is `-mshort-data-512', the variable `m88k_short_data'\n-   will be set to the string `\"512\"'.\n-\n-\textern char *m88k_short_data;\n-\t#define TARGET_OPTIONS { { \"short-data-\", &m88k_short_data } }  */\n-\n /* This is meant to be overridden in target specific files.  */\n #define\tSUBTARGET_OPTIONS\n "}, {"sha": "608b3938d72dd616d8837abc54b46913818e332f", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1552d7b014918281e1bcb68388936b68094e354/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1552d7b014918281e1bcb68388936b68094e354/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=d1552d7b014918281e1bcb68388936b68094e354", "patch": "@@ -660,23 +660,6 @@ extern enum processor_type sparc_cpu;\n    Every file includes us, but not every file includes insn-attr.h.  */\n #define sparc_cpu_attr ((enum attr_cpu) sparc_cpu)\n \n-/* This macro is similar to `TARGET_SWITCHES' but defines names of\n-   command options that have values.  Its definition is an\n-   initializer with a subgrouping for each command option.\n-\n-   Each subgrouping contains a string constant, that defines the\n-   fixed part of the option name, and the address of a variable. \n-   The variable, type `char *', is set to the variable part of the\n-   given option if the fixed part matches.  The actual option name\n-   is made by appending `-m' to the specified name.\n-\n-   Here is an example which defines `-mshort-data-NUMBER'.  If the\n-   given option is `-mshort-data-512', the variable `m88k_short_data'\n-   will be set to the string `\"512\"'.\n-\n-\textern char *m88k_short_data;\n-\t#define TARGET_OPTIONS { { \"short-data-\", &m88k_short_data } }  */\n-\n #define TARGET_OPTIONS \\\n {\t\t\t\t\t\t\t\t\\\n   { \"cpu=\",  &sparc_select[1].string,\t\t\t\t\\"}, {"sha": "c3539d22de12bea28caa7fb54bf3460e9cad3d39", "filename": "gcc/config/stormy16/stormy16.h", "status": "modified", "additions": 16, "deletions": 767, "changes": 783, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1552d7b014918281e1bcb68388936b68094e354/gcc%2Fconfig%2Fstormy16%2Fstormy16.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1552d7b014918281e1bcb68388936b68094e354/gcc%2Fconfig%2Fstormy16%2Fstormy16.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.h?ref=d1552d7b014918281e1bcb68388936b68094e354", "patch": "@@ -23,122 +23,23 @@ Boston, MA 02111-1307, USA.  */\n \f\n /* Driver configuration */\n \n-/* A C expression which determines whether the option `-CHAR' takes arguments.\n-   The value should be the number of arguments that option takes-zero, for many\n-   options.\n-\n-   By default, this macro is defined to handle the standard options properly.\n-   You need not define it unless you wish to add additional options which take\n-   arguments.\n-\n-   Defined in svr4.h.  */\n+/* Defined in svr4.h.  */\n /* #define SWITCH_TAKES_ARG(CHAR) */\n \n-/* A C expression which determines whether the option `-NAME' takes arguments.\n-   The value should be the number of arguments that option takes-zero, for many\n-   options.  This macro rather than `SWITCH_TAKES_ARG' is used for\n-   multi-character option names.\n-\n-   By default, this macro is defined as `DEFAULT_WORD_SWITCH_TAKES_ARG', which\n-   handles the standard options properly.  You need not define\n-   `WORD_SWITCH_TAKES_ARG' unless you wish to add additional options which take\n-   arguments.  Any redefinition should call `DEFAULT_WORD_SWITCH_TAKES_ARG' and\n-   then check for additional options.\n-\n-   Defined in svr4.h.  */\n+/* Defined in svr4.h.  */\n /* #define WORD_SWITCH_TAKES_ARG(NAME) */\n \n-/* A string-valued C expression which is nonempty if the linker needs a space\n-   between the `-L' or `-o' option and its argument.\n-\n-   If this macro is not defined, the default value is 0.  */\n-/* #define SWITCHES_NEED_SPACES \"\" */\n-\n-/* A C string constant that tells the GNU CC driver program options to pass to\n-   CPP.  It can also specify how to translate options you give to GNU CC into\n-   options for GNU CC to pass to the CPP.\n-\n-   Do not define this macro if it does not need to do anything.  */\n-/* #define CPP_SPEC \"\" */\n-\n-/* If this macro is defined, the preprocessor will not define the builtin macro\n-   `__SIZE_TYPE__'.  The macro `__SIZE_TYPE__' must then be defined by\n-   `CPP_SPEC' instead.\n-\n-   This should be defined if `SIZE_TYPE' depends on target dependent flags\n-   which are not accessible to the preprocessor.  Otherwise, it should not be\n-   defined.  */\n-/* #define NO_BUILTIN_SIZE_TYPE */\n-\n-/* If this macro is defined, the preprocessor will not define the builtin macro\n-   `__PTRDIFF_TYPE__'.  The macro `__PTRDIFF_TYPE__' must then be defined by\n-   `CPP_SPEC' instead.\n-\n-   This should be defined if `PTRDIFF_TYPE' depends on target dependent flags\n-   which are not accessible to the preprocessor.  Otherwise, it should not be\n-   defined.  */\n-/* #define NO_BUILTIN_PTRDIFF_TYPE */\n-\n-/* A C string constant that tells the GNU CC driver program options to pass to\n-   CPP.  By default, this macro is defined to pass the option\n-   `-D__CHAR_UNSIGNED__' to CPP if `char' will be treated as `unsigned char' by\n-   `cc1'.\n-\n-   Do not define this macro unless you need to override the default definition.  */\n-/* #if DEFAULT_SIGNED_CHAR\n-   #define SIGNED_CHAR_SPEC \"%{funsigned-char:-D__CHAR_UNSIGNED__}\"\n-   #else\n-   #define SIGNED_CHAR_SPEC \"%{!fsigned-char:-D__CHAR_UNSIGNED__}\"\n-   #endif */\n-\n-/* A C string constant that tells the GNU CC driver program options to pass to\n-   `cc1'.  It can also specify how to translate options you give to GNU CC into\n-   options for GNU CC to pass to the `cc1'.\n-\n-   Do not define this macro if it does not need to do anything.  */\n-/* #define CC1_SPEC \"\" */\n-\n-/* A C string constant that tells the GNU CC driver program options to pass to\n-   `cc1plus'.  It can also specify how to translate options you give to GNU CC\n-   into options for GNU CC to pass to the `cc1plus'.\n-\n-   Do not define this macro if it does not need to do anything.  */\n-/* #define CC1PLUS_SPEC \"\" */\n-\n-/* A C string constant that tells the GNU CC driver program options to pass to\n-   the assembler.  It can also specify how to translate options you give to GNU\n-   CC into options for GNU CC to pass to the assembler.  See the file `sun3.h'\n-   for an example of this.\n-\n-   Do not define this macro if it does not need to do anything.\n-\n-   Defined in svr4.h.  */\n+/* Defined in svr4.h.  */\n #undef ASM_SPEC\n #define ASM_SPEC \"\"\n \n-/* A C string constant that tells the GNU CC driver program how to run any\n-   programs which cleanup after the normal assembler.  Normally, this is not\n-   needed.  See the file `mips.h' for an example of this.\n-\n-   Do not define this macro if it does not need to do anything.\n-\n-   Defined in svr4.h.  */\n+/* Defined in svr4.h.  */\n /* #define ASM_FINAL_SPEC \"\" */\n \n-/* A C string constant that tells the GNU CC driver program options to pass to\n-   the linker.  It can also specify how to translate options you give to GNU CC\n-   into options for GNU CC to pass to the linker.\n-\n-   Do not define this macro if it does not need to do anything.\n-\n-   Defined in svr4.h.  */\n+/* Defined in svr4.h.  */\n /* #define LINK_SPEC \"\" */\n \n-/* Another C string constant used much like `LINK_SPEC'.  The difference\n-   between the two is that `LIB_SPEC' is used at the end of the command given\n-   to the linker.\n-\n-   For xstormy16:\n+/* For xstormy16:\n    - If -msim is specified, everything is built and linked as for the sim.\n    - If -T is specified, that linker script is used, and it should provide\n      appropriate libraries.\n@@ -149,777 +50,125 @@ Boston, MA 02111-1307, USA.  */\n #undef LIB_SPEC\n #define LIB_SPEC \"-( -lc %{msim:-lsim}%{!msim:%{!T*:-lnosys}} -)\"\n \n-/* Another C string constant that tells the GNU CC driver program how and when\n-   to place a reference to `libgcc.a' into the linker command line.  This\n-   constant is placed both before and after the value of `LIB_SPEC'.\n-\n-   If this macro is not defined, the GNU CC driver provides a default that\n-   passes the string `-lgcc' to the linker unless the `-shared' option is\n-   specified.  */\n-/* #define LIBGCC_SPEC \"\" */\n-\n-/* Another C string constant used much like `LINK_SPEC'.  The difference\n-   between the two is that `STARTFILE_SPEC' is used at the very beginning of\n-   the command given to the linker.\n-\n-   If this macro is not defined, a default is provided that loads the standard\n-   C startup file from the usual place.  See `gcc.c'.\n-\n-   Defined in svr4.h.  */\n+/* Defined in svr4.h.  */\n #undef STARTFILE_SPEC\n #define STARTFILE_SPEC \"crt0.o%s crti.o%s crtbegin.o%s\"\n \n-/* Another C string constant used much like `LINK_SPEC'.  The difference\n-   between the two is that `ENDFILE_SPEC' is used at the very end of the\n-   command given to the linker.\n-\n-   Do not define this macro if it does not need to do anything.\n-\n-   Defined in svr4.h.  */\n+/* Defined in svr4.h.  */\n #undef ENDFILE_SPEC\n #define ENDFILE_SPEC \"crtend.o%s crtn.o%s\"\n \n-/* Define this macro if the driver program should find the library `libgcc.a'\n-   itself and should not pass `-L' options to the linker.  If you do not define\n-   this macro, the driver program will pass the argument `-lgcc' to tell the\n-   linker to do the search and will pass `-L' options to it.  */\n-/* #define LINK_LIBGCC_SPECIAL */\n-\n-/* Define this macro if the driver program should find the library `libgcc.a'.\n-   If you do not define this macro, the driver program will pass the argument\n-   `-lgcc' to tell the linker to do the search.  This macro is similar to\n-   `LINK_LIBGCC_SPECIAL', except that it does not affect `-L' options.  */\n-/* #define LINK_LIBGCC_SPECIAL_1 */\n-\n-/* Define this macro to provide additional specifications to put in the `specs'\n-   file that can be used in various specifications like `CC1_SPEC'.\n-\n-   The definition should be an initializer for an array of structures,\n-   containing a string constant, that defines the specification name, and a\n-   string constant that provides the specification.\n-\n-   Do not define this macro if it does not need to do anything.  */\n-/* #define EXTRA_SPECS {{}} */\n-\n-/* Define this macro as a C expression for the initializer of an array of\n-   string to tell the driver program which options are defaults for this target\n-   and thus do not need to be handled specially when using `MULTILIB_OPTIONS'.\n-\n-   Do not define this macro if `MULTILIB_OPTIONS' is not defined in the target\n-   makefile fragment or if none of the options listed in `MULTILIB_OPTIONS' are\n-   set by default.  */\n-/* #define MULTILIB_DEFAULTS {} */\n-\n-/* Define this macro to tell `gcc' that it should only translate a `-B' prefix\n-   into a `-L' linker option if the prefix indicates an absolute file name.  */\n-/* #define RELATIVE_PREFIX_NOT_LINKDIR */\n-\n-/* Define this macro as a C string constant if you wish to override the\n-   standard choice of `/usr/local/lib/gcc-lib/' as the default prefix to try\n-   when searching for the executable files of the compiler.  */\n-/* #define STANDARD_EXEC_PREFIX \"\" */\n-\n-/* If defined, this macro is an additional prefix to try after\n-   `STANDARD_EXEC_PREFIX'.  `MD_EXEC_PREFIX' is not searched when the `-b'\n-   option is used, or the compiler is built as a cross compiler.\n-\n-   Defined in svr4.h for host compilers.  */\n+/* Defined in svr4.h for host compilers.  */\n /* #define MD_EXEC_PREFIX \"\" */\n \n-/* Define this macro as a C string constant if you wish to override the\n-   standard choice of `/usr/local/lib/' as the default prefix to try when\n-   searching for startup files such as `crt0.o'.  */\n-/* #define STANDARD_STARTFILE_PREFIX \"\" */\n-\n-/* If defined, this macro supplies an additional prefix to try after the\n-   standard prefixes.  `MD_EXEC_PREFIX' is not searched when the `-b' option is\n-   used, or when the compiler is built as a cross compiler.\n-\n-   Defined in svr4.h for host compilers.  */\n+/* Defined in svr4.h for host compilers.  */\n /* #define MD_STARTFILE_PREFIX \"\" */\n \n-/* If defined, this macro supplies yet another prefix to try after the standard\n-   prefixes.  It is not searched when the `-b' option is used, or when the\n-   compiler is built as a cross compiler.  */\n-/* #define MD_STARTFILE_PREFIX_1 \"\" */\n-\n-/* Define this macro as a C string constant if you with to set environment\n-   variables for programs called by the driver, such as the assembler and\n-   loader.  The driver passes the value of this macro to `putenv' to initialize\n-   the necessary environment variables.  */\n-/* #define INIT_ENVIRONMENT \"\" */\n-\n-/* Define this macro as a C string constant if you wish to override the\n-   standard choice of `/usr/local/include' as the default prefix to try when\n-   searching for local header files.  `LOCAL_INCLUDE_DIR' comes before\n-   `SYSTEM_INCLUDE_DIR' in the search order.\n-\n-   Cross compilers do not use this macro and do not search either\n-   `/usr/local/include' or its replacement.  */\n-/* #define LOCAL_INCLUDE_DIR \"\" */\n-\n-/* Define this macro as a C string constant if you wish to specify a\n-   system-specific directory to search for header files before the standard\n-   directory.  `SYSTEM_INCLUDE_DIR' comes before `STANDARD_INCLUDE_DIR' in the\n-   search order.\n-\n-   Cross compilers do not use this macro and do not search the directory\n-   specified.  */\n-/* #define SYSTEM_INCLUDE_DIR \"\" */\n-\n-/* Define this macro as a C string constant if you wish to override the\n-   standard choice of `/usr/include' as the default prefix to try when\n-   searching for header files.\n-\n-   Cross compilers do not use this macro and do not search either\n-   `/usr/include' or its replacement.  */\n-/* #define STANDARD_INCLUDE_DIR \"\" */\n-\n-/* Define this macro if you wish to override the entire default search path for\n-   include files.  The default search path includes `GCC_INCLUDE_DIR',\n-   `LOCAL_INCLUDE_DIR', `SYSTEM_INCLUDE_DIR', `GPLUSPLUS_INCLUDE_DIR', and\n-   `STANDARD_INCLUDE_DIR'.  In addition, `GPLUSPLUS_INCLUDE_DIR' and\n-   `GCC_INCLUDE_DIR' are defined automatically by `Makefile', and specify\n-   private search areas for GCC.  The directory `GPLUSPLUS_INCLUDE_DIR' is used\n-   only for C++ programs.\n-\n-     The definition should be an initializer for an array of structures.  Each\n-     array element should have two elements: the directory name (a string\n-     constant) and a flag for C++-only directories.  Mark the end of the array\n-     with a null element.  For example, here is the definition used for VMS:\n-\n-          #define INCLUDE_DEFAULTS \\\n-          {                                       \\\n-            { \"GNU_GXX_INCLUDE:\", 1},             \\\n-            { \"GNU_CC_INCLUDE:\", 0},              \\\n-            { \"SYS$SYSROOT:[SYSLIB.]\", 0},        \\\n-            { \".\", 0},                            \\\n-            { 0, 0}                               \\\n-          }\n-\n-   Here is the order of prefixes tried for exec files:\n-\n-  1. Any prefixes specified by the user with `-B'.\n-\n-  2. The environment variable `GCC_EXEC_PREFIX', if any.\n-\n-  3. The directories specified by the environment variable\n-     `COMPILER_PATH'.\n-\n-  4. The macro `STANDARD_EXEC_PREFIX'.\n-\n-  5. `/usr/lib/gcc/'.\n-\n-  6. The macro `MD_EXEC_PREFIX', if any.\n-\n-   Here is the order of prefixes tried for startfiles:\n-\n-  1. Any prefixes specified by the user with `-B'.\n-\n-  2. The environment variable `GCC_EXEC_PREFIX', if any.\n-\n-  3. The directories specified by the environment variable\n-     `LIBRARY_PATH' (native only, cross compilers do not use this).\n-\n-  4. The macro `STANDARD_EXEC_PREFIX'.\n-\n-  5. `/usr/lib/gcc/'.\n-\n-  6. The macro `MD_EXEC_PREFIX', if any.\n-\n-  7. The macro `MD_STARTFILE_PREFIX', if any.\n-\n-  8. The macro `STANDARD_STARTFILE_PREFIX'.\n-\n-  9. `/lib/'.\n-\n- 10. `/usr/lib/'.  */\n-/* #define INCLUDE_DEFAULTS {{ }} */\n-\n \f\n /* Run-time target specifications */\n \n-/* Define this to be a string constant containing `-D' options to define the\n-   predefined macros that identify this machine and system.  These macros will\n-   be predefined unless the `-ansi' option is specified.\n-\n-   In addition, a parallel set of macros are predefined, whose names are made\n-   by appending `__' at the beginning and at the end.  These `__' macros are\n-   permitted by the ANSI standard, so they are predefined regardless of whether\n-   `-ansi' is specified.\n-\n-   For example, on the Sun, one can use the following value:\n-\n-        \"-Dmc68000 -Dsun -Dunix\"\n-\n-   The result is to define the macros `__mc68000__', `__sun__' and `__unix__'\n-   unconditionally, and the macros `mc68000', `sun' and `unix' provided `-ansi'\n-   is not specified.  */\n #define CPP_PREDEFINES \"-Dxstormy16 -Amachine=xstormy16 -D__INT_MAX__=32767\"\n \n /* This declaration should be present.  */\n extern int target_flags;\n \n-/* This series of macros is to allow compiler command arguments to enable or\n-   disable the use of optional features of the target machine.  For example,\n-   one machine description serves both the 68000 and the 68020; a command\n-   argument tells the compiler whether it should use 68020-only instructions or\n-   not.  This command argument works by means of a macro `TARGET_68020' that\n-   tests a bit in `target_flags'.\n-\n-   Define a macro `TARGET_FEATURENAME' for each such option.  Its definition\n-   should test a bit in `target_flags'; for example:\n-\n-        #define TARGET_68020 (target_flags & 1)\n-\n-   One place where these macros are used is in the condition-expressions of\n-   instruction patterns.  Note how `TARGET_68020' appears frequently in the\n-   68000 machine description file, `m68k.md'.  Another place they are used is\n-   in the definitions of the other macros in the `MACHINE.h' file.  */\n-/* #define TARGET_...  */\n-\n-/* This macro defines names of command options to set and clear bits in\n-   `target_flags'.  Its definition is an initializer with a subgrouping for\n-   each command option.\n-\n-   Each subgrouping contains a string constant, that defines the\n-   option name, a number, which contains the bits to set in\n-   `target_flags', and an optional second string which is the textual\n-   description that will be displayed when the user passes --help on\n-   the command line.  If the number entry is negative then the\n-   specified bits will be cleared instead of being set.  If the second\n-   string entry is present but empty, then no help information will be\n-   displayed for that option, but it will not count as an undocumented\n-   option.  The actual option name, as seen on the command line is\n-   made by appending `-m' to the specified name.\n-\n-   One of the subgroupings should have a null string.  The number in this\n-   grouping is the default value for `target_flags'.  Any target options act\n-   starting with that value.\n-\n-   Here is an example which defines `-m68000' and `-m68020' with opposite\n-   meanings, and picks the latter as the default:\n-\n-        #define TARGET_SWITCHES \\\n-          { { \"68020\",  1, \"\"},      \\\n-            { \"68000\", -1, \"Compile for the m68000\"},     \\\n-            { \"\",       1, }}\n-\n-   This declaration must be present.  */\n-\n #define TARGET_SWITCHES\t\t\t\t\t\\\n   {{ \"sim\", 0, \"Provide libraries for the simulator\" },\t\\\n    { \"\", 0, \"\" }}\n \n-/* This macro is similar to `TARGET_SWITCHES' but defines names of command\n-   options that have values.  Its definition is an initializer with a\n-   subgrouping for each command option.\n-\n-   Each subgrouping contains a string constant, that defines the fixed part of\n-   the option name, the address of a variable, and an optional description string.\n-   The variable, of type `char *', is set to the text following the fixed part of\n-   the option as it is specified on the command line.  The actual option name is\n-   made by appending `-m' to the specified name.\n-\n-   Here is an example which defines `-mshort-data-NUMBER'.  If the given option\n-   is `-mshort-data-512', the variable `m88k_short_data' will be set to the\n-   string `\"512\"'.\n-\n-        extern char *m88k_short_data;\n-        #define TARGET_OPTIONS \\\n-         { { \"short-data-\", & m88k_short_data, \\\n-\t \"Specify the size of the short data section\"  } }\n-\n-   This declaration is optional.  */\n-/* #define TARGET_OPTIONS */\n-\n-/* This macro is a C statement to print on `stderr' a string describing the\n-   particular machine description choice.  Every machine description should\n-   define `TARGET_VERSION'.  For example:\n-\n-        #ifdef MOTOROLA\n-        #define TARGET_VERSION \\\n-          fprintf (stderr, \" (68k, Motorola syntax)\");\n-        #else\n-        #define TARGET_VERSION \\\n-          fprintf (stderr, \" (68k, MIT syntax)\");\n-        #endif  */\n #define TARGET_VERSION fprintf (stderr, \" (xstormy16 cpu core)\");\n \n-/* Sometimes certain combinations of command options do not make sense on a\n-   particular target machine.  You can define a macro `OVERRIDE_OPTIONS' to\n-   take account of this.  This macro, if defined, is executed once just after\n-   all the command options have been parsed.\n-\n-   Don't use this macro to turn on various extra optimizations for `-O'.  That\n-   is what `OPTIMIZATION_OPTIONS' is for.  */\n-/* #define OVERRIDE_OPTIONS */\n-\n-/* Some machines may desire to change what optimizations are performed for\n-   various optimization levels.  This macro, if defined, is executed once just\n-   after the optimization level is determined and before the remainder of the\n-   command options have been parsed.  Values set in this macro are used as the\n-   default values for the other command line options.\n-\n-   LEVEL is the optimization level specified; 2 if `-O2' is specified, 1 if\n-   `-O' is specified, and 0 if neither is specified.\n-\n-   SIZE is non-zero if `-Os' is specified, 0 otherwise.  \n-\n-   You should not use this macro to change options that are not\n-   machine-specific.  These should uniformly selected by the same optimization\n-   level on all supported machines.  Use this macro to enable machbine-specific\n-   optimizations.\n-\n-   *Do not examine `write_symbols' in this macro!* The debugging options are\n-   *not supposed to alter the generated code.  */\n-/* #define OPTIMIZATION_OPTIONS(LEVEL,SIZE) */\n-\n-/* Define this macro if debugging can be performed even without a frame\n-   pointer.  If this macro is defined, GNU CC will turn on the\n-   `-fomit-frame-pointer' option whenever `-O' is specified.  */\n #define CAN_DEBUG_WITHOUT_FP\n \n \f\n /* Storage Layout */\n \n-/* Define this macro to have the value 1 if the most significant bit in a byte\n-   has the lowest number; otherwise define it to have the value zero.  This\n-   means that bit-field instructions count from the most significant bit.  If\n-   the machine has no bit-field instructions, then this must still be defined,\n-   but it doesn't matter which value it is defined to.  This macro need not be\n-   a constant.\n-\n-   This macro does not affect the way structure fields are packed into bytes or\n-   words; that is controlled by `BYTES_BIG_ENDIAN'.  */\n #define BITS_BIG_ENDIAN 1\n \n-/* Define this macro to have the value 1 if the most significant byte in a word\n-   has the lowest number.  This macro need not be a constant.  */\n #define BYTES_BIG_ENDIAN 0\n \n-/* Define this macro to have the value 1 if, in a multiword object, the most\n-   significant word has the lowest number.  This applies to both memory\n-   locations and registers; GNU CC fundamentally assumes that the order of\n-   words in memory is the same as the order in registers.  This macro need not\n-   be a constant.  */\n #define WORDS_BIG_ENDIAN 0\n \n-/* Define this macro if WORDS_BIG_ENDIAN is not constant.  This must be a\n-   constant value with the same meaning as WORDS_BIG_ENDIAN, which will be used\n-   only when compiling libgcc2.c.  Typically the value will be set based on\n-   preprocessor defines.  */\n-/* #define LIBGCC2_WORDS_BIG_ENDIAN */\n-\n-/* Define this macro to have the value 1 if `DFmode', `XFmode' or `TFmode'\n-   floating point numbers are stored in memory with the word containing the\n-   sign bit at the lowest address; otherwise define it to have the value 0.\n-   This macro need not be a constant.\n-\n-   You need not define this macro if the ordering is the same as for multi-word\n-   integers.  */\n-/* #define FLOAT_WORDS_BIG_ENDIAN */\n-\n-/* Define this macro to be the number of bits in an addressable storage unit\n-   (byte); normally 8.  */\n #define BITS_PER_UNIT 8\n \n-/* Number of bits in a word; normally 32.  */\n #define BITS_PER_WORD 16\n \n-/* Maximum number of bits in a word.  If this is undefined, the default is\n-   `BITS_PER_WORD'.  Otherwise, it is the constant value that is the largest\n-   value that `BITS_PER_WORD' can have at run-time.  */\n-/* #define MAX_BITS_PER_WORD */\n-\n-/* Number of storage units in a word; normally 4.  */\n #define UNITS_PER_WORD 2\n \n-/* Minimum number of units in a word.  If this is undefined, the default is\n-   `UNITS_PER_WORD'.  Otherwise, it is the constant value that is the smallest\n-   value that `UNITS_PER_WORD' can have at run-time.  */\n-/* #define MIN_UNITS_PER_WORD */\n-\n-/* Width of a pointer, in bits.  You must specify a value no wider than the\n-   width of `Pmode'.  If it is not equal to the width of `Pmode', you must\n-   define `POINTERS_EXTEND_UNSIGNED'.  */\n #define POINTER_SIZE 16\n \n-/* A C expression whose value is nonzero if pointers that need to be extended\n-   from being `POINTER_SIZE' bits wide to `Pmode' are sign-extended and zero if\n-   they are zero-extended.\n-\n-   You need not define this macro if the `POINTER_SIZE' is equal to the width\n-   of `Pmode'.  */\n-/* #define POINTERS_EXTEND_UNSIGNED */\n-\n-/* A macro to update MODE and UNSIGNEDP when an object whose type is TYPE and\n-   which has the specified mode and signedness is to be stored in a register.\n-   This macro is only called when TYPE is a scalar type.\n-\n-   On most RISC machines, which only have operations that operate on a full\n-   register, define this macro to set M to `word_mode' if M is an integer mode\n-   narrower than `BITS_PER_WORD'.  In most cases, only integer modes should be\n-   widened because wider-precision floating-point operations are usually more\n-   expensive than their narrower counterparts.\n-\n-   For most machines, the macro definition does not change UNSIGNEDP.  However,\n-   some machines, have instructions that preferentially handle either signed or\n-   unsigned quantities of certain modes.  For example, on the DEC Alpha, 32-bit\n-   loads from memory and 32-bit add instructions sign-extend the result to 64\n-   bits.  On such machines, set UNSIGNEDP according to which kind of extension\n-   is more efficient.\n-\n-   Do not define this macro if it would never modify MODE.  */\n #define PROMOTE_MODE(MODE,UNSIGNEDP,TYPE)\t\t\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n   if (GET_MODE_CLASS (MODE) == MODE_INT\t\t\t\t\t\\\n       && GET_MODE_SIZE (MODE) < 2)\t\t\t\t\t\\\n     (MODE) = HImode;\t\t\t\t\t\t\t\\\n } while (0)\n \n-/* Define this macro if the promotion described by `PROMOTE_MODE' should also\n-   be done for outgoing function arguments.  */\n #define PROMOTE_FUNCTION_ARGS 1\n \n-/* Define this macro if the promotion described by `PROMOTE_MODE' should also\n-   be done for the return value of functions.\n-\n-   If this macro is defined, `FUNCTION_VALUE' must perform the same promotions\n-   done by `PROMOTE_MODE'.  */\n #define PROMOTE_FUNCTION_RETURN 1\n \n-/* Define this macro if the promotion described by `PROMOTE_MODE' should *only*\n-   be performed for outgoing function arguments or function return values, as\n-   specified by `PROMOTE_FUNCTION_ARGS' and `PROMOTE_FUNCTION_RETURN',\n-   respectively.  */\n-/* #define PROMOTE_FOR_CALL_ONLY */\n-\n-/* Normal alignment required for function parameters on the stack, in bits.\n-   All stack parameters receive at least this much alignment regardless of data\n-   type.  On most machines, this is the same as the size of an integer.  */\n #define PARM_BOUNDARY 16\n \n-/* Define this macro if you wish to preserve a certain alignment for the stack\n-   pointer.  The definition is a C expression for the desired alignment\n-   (measured in bits).\n-\n-   If `PUSH_ROUNDING' is not defined, the stack will always be aligned to the\n-   specified boundary.  If `PUSH_ROUNDING' is defined and specifies a less\n-   strict alignment than `STACK_BOUNDARY', the stack may be momentarily\n-   unaligned while pushing arguments.  */\n #define STACK_BOUNDARY 16\n \n-/* Alignment required for a function entry point, in bits.  */\n #define FUNCTION_BOUNDARY 16\n \n-/* Biggest alignment that any data type can require on this machine,\n-   in bits.  */\n #define BIGGEST_ALIGNMENT 16\n \n-/* Biggest alignment that any structure field can require on this machine, in\n-   bits.  If defined, this overrides `BIGGEST_ALIGNMENT' for structure fields\n-   only.  */\n-/* #define BIGGEST_FIELD_ALIGNMENT */\n-\n-/* An expression for the alignment of a structure field FIELD if the\n-   alignment computed in the usual way is COMPUTED.  GNU CC uses this\n-   value instead of the value in `BIGGEST_ALIGNMENT' or\n-   `BIGGEST_FIELD_ALIGNMENT', if defined, for structure fields only.  */\n-/* #define ADJUST_FIELD_ALIGN(FIELD, COMPUTED) */\n-\n-/* Biggest alignment supported by the object file format of this machine.  Use\n-   this macro to limit the alignment which can be specified using the\n-   `__attribute__ ((aligned (N)))' construct.  If not defined, the default\n-   value is `BIGGEST_ALIGNMENT'.\n-\n-   Defined in svr4.h.  */\n+/* Defined in svr4.h.  */\n /* #define MAX_OFILE_ALIGNMENT */\n \n-/* If defined, a C expression to compute the alignment for a static variable.\n-   TYPE is the data type, and ALIGN is the alignment that the object\n-   would ordinarily have.  The value of this macro is used instead of that\n-   alignment to align the object.\n-\n-   If this macro is not defined, then ALIGN is used.\n-\n-   One use of this macro is to increase alignment of medium-size data to make\n-   it all fit in fewer cache lines.  Another is to cause character arrays to be\n-   word-aligned so that `strcpy' calls that copy constants to character arrays\n-   can be done inline.  */\n #define DATA_ALIGNMENT(TYPE, ALIGN)\t\t\\\n   (TREE_CODE (TYPE) == ARRAY_TYPE\t\t\\\n    && TYPE_MODE (TREE_TYPE (TYPE)) == QImode\t\\\n    && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))\n \n-/* If defined, a C expression to compute the alignment given to a constant that\n-   is being placed in memory.  CONSTANT is the constant and ALIGN is the\n-   alignment that the object would ordinarily have.  The value of this macro is\n-   used instead of that alignment to align the object.\n-\n-   If this macro is not defined, then ALIGN is used.\n-\n-   The typical use of this macro is to increase alignment for string constants\n-   to be word aligned so that `strcpy' calls that copy constants can be done\n-   inline.  */\n #define CONSTANT_ALIGNMENT(EXP, ALIGN)  \\\n   (TREE_CODE (EXP) == STRING_CST\t\\\n    && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))\n \n-/* Alignment in bits to be given to a structure bit field that follows an empty\n-   field such as `int : 0;'.\n-\n-   Note that `PCC_BITFIELD_TYPE_MATTERS' also affects the alignment that\n-   results from an empty field.  */\n-/* #define EMPTY_FIELD_BOUNDARY */\n-\n-/* Number of bits which any structure or union's size must be a multiple of.\n-   Each structure or union's size is rounded up to a multiple of this.\n-\n-   If you do not define this macro, the default is the same as `BITS_PER_UNIT'.  */\n-/* #define STRUCTURE_SIZE_BOUNDARY */\n-\n-/* Define this macro to be the value 1 if instructions will fail to work if\n-   given data not on the nominal alignment.  If instructions will merely go\n-   slower in that case, define this macro as 0.  */\n #define STRICT_ALIGNMENT 1\n \n-/* Define this if you wish to imitate the way many other C compilers handle\n-   alignment of bitfields and the structures that contain them.\n-\n-   The behavior is that the type written for a bitfield (`int', `short', or\n-   other integer type) imposes an alignment for the entire structure, as if the\n-   structure really did contain an ordinary field of that type.  In addition,\n-   the bitfield is placed within the structure so that it would fit within such\n-   a field, not crossing a boundary for it.\n-\n-   Thus, on most machines, a bitfield whose type is written as `int' would not\n-   cross a four-byte boundary, and would force four-byte alignment for the\n-   whole structure.  (The alignment used may not be four bytes; it is\n-   controlled by the other alignment parameters.)\n-\n-   If the macro is defined, its definition should be a C expression; a nonzero\n-   value for the expression enables this behavior.\n-\n-   Note that if this macro is not defined, or its value is zero, some bitfields\n-   may cross more than one alignment boundary.  The compiler can support such\n-   references if there are `insv', `extv', and `extzv' insns that can directly\n-   reference memory.\n-\n-   The other known way of making bitfields work is to define\n-   `STRUCTURE_SIZE_BOUNDARY' as large as `BIGGEST_ALIGNMENT'.  Then every\n-   structure can be accessed with fullwords.\n-\n-   Unless the machine has bitfield instructions or you define\n-   `STRUCTURE_SIZE_BOUNDARY' that way, you must define\n-   `PCC_BITFIELD_TYPE_MATTERS' to have a nonzero value.\n-\n-   If your aim is to make GNU CC use the same conventions for laying out\n-   bitfields as are used by another compiler, here is how to investigate what\n-   the other compiler does.  Compile and run this program:\n-\n-        struct foo1\n-        {\n-          char x;\n-          char :0;\n-          char y;\n-        };\n-\n-        struct foo2\n-        {\n-          char x;\n-          int :0;\n-          char y;\n-        };\n-\n-        main ()\n-        {\n-          printf (\"Size of foo1 is %d\\n\",\n-                  sizeof (struct foo1));\n-          printf (\"Size of foo2 is %d\\n\",\n-                  sizeof (struct foo2));\n-          exit (0);\n-        }\n-\n-   If this prints 2 and 5, then the compiler's behavior is what you would get\n-   from `PCC_BITFIELD_TYPE_MATTERS'.\n-\n-   Defined in svr4.h.  */\n+/* Defined in svr4.h.  */\n #define PCC_BITFIELD_TYPE_MATTERS 1\n \n-/* Like PCC_BITFIELD_TYPE_MATTERS except that its effect is limited to aligning\n-   a bitfield within the structure.  */\n-/* #define BITFIELD_NBYTES_LIMITED */\n-\n-/* Define this macro as an expression for the overall size of a structure\n-   (given by STRUCT as a tree node) when the size computed from the fields is\n-   SIZE and the alignment is ALIGN.\n-\n-   The default is to round SIZE up to a multiple of ALIGN.  */\n-/* #define ROUND_TYPE_SIZE(STRUCT, SIZE, ALIGN) */\n-\n-/* Define this macro as an expression for the alignment of a structure (given\n-   by STRUCT as a tree node) if the alignment computed in the usual way is\n-   COMPUTED and the alignment explicitly specified was SPECIFIED.\n-\n-   The default is to use SPECIFIED if it is larger; otherwise, use the smaller\n-   of COMPUTED and `BIGGEST_ALIGNMENT' */\n-/* #define ROUND_TYPE_ALIGN(STRUCT, COMPUTED, SPECIFIED) */\n-\n-/* An integer expression for the size in bits of the largest integer machine\n-   mode that should actually be used.  All integer machine modes of this size\n-   or smaller can be used for structures and unions with the appropriate sizes.\n-   If this macro is undefined, `GET_MODE_BITSIZE (DImode)' is assumed.  */\n-/* #define MAX_FIXED_MODE_SIZE */\n-\n-/* A C statement to validate the value VALUE (of type `double') for mode MODE.\n-   This means that you check whether VALUE fits within the possible range of\n-   values for mode MODE on this target machine.  The mode MODE is always a mode\n-   of class `MODE_FLOAT'.  OVERFLOW is nonzero if the value is already known to\n-   be out of range.\n-\n-   If VALUE is not valid or if OVERFLOW is nonzero, you should set OVERFLOW to\n-   1 and then assign some valid value to VALUE.  Allowing an invalid value to\n-   go through the compiler can produce incorrect assembler code which may even\n-   cause Unix assemblers to crash.\n-\n-   This macro need not be defined if there is no work for it to do.  */\n-/* #define CHECK_FLOAT_VALUE(MODE, VALUE, OVERFLOW) */\n-\n-/* A code distinguishing the floating point format of the target machine.\n-   There are three defined values:\n-\n-   IEEE_FLOAT_FORMAT'\n-        This code indicates IEEE floating point.  It is the default;\n-        there is no need to define this macro when the format is IEEE.\n-\n-   VAX_FLOAT_FORMAT'\n-        This code indicates the peculiar format used on the Vax.\n-\n-   UNKNOWN_FLOAT_FORMAT'\n-        This code indicates any other format.\n-\n-   The value of this macro is compared with `HOST_FLOAT_FORMAT'\n-   to determine whether the target machine has the same format as\n-   the host machine.  If any other formats are actually in use on supported\n-   machines, new codes should be defined for them.\n-\n-   The ordering of the component words of floating point values stored in\n-   memory is controlled by `FLOAT_WORDS_BIG_ENDIAN' for the target machine and\n-   `HOST_FLOAT_WORDS_BIG_ENDIAN' for the host.  */\n #define TARGET_FLOAT_FORMAT IEEE_FLOAT_FORMAT\n \n \f\n /* Layout of Source Language Data Types */\n \n-/* A C expression for the size in bits of the type `int' on the target machine.\n-   If you don't define this, the default is one word.  */\n #define INT_TYPE_SIZE 16\n \n-/* A C expression for the size in bits of the type `short' on the target\n-   machine.  If you don't define this, the default is half a word.  (If this\n-   would be less than one storage unit, it is rounded up to one unit.)  */\n #define SHORT_TYPE_SIZE 16\n \n-/* A C expression for the size in bits of the type `long' on the target\n-   machine.  If you don't define this, the default is one word.  */\n #define LONG_TYPE_SIZE 32\n \n-/* Maximum number for the size in bits of the type `long' on the target\n-   machine.  If this is undefined, the default is `LONG_TYPE_SIZE'.  Otherwise,\n-   it is the constant value that is the largest value that `LONG_TYPE_SIZE' can\n-   have at run-time.  This is used in `cpp'.  */\n-/* #define MAX_LONG_TYPE_SIZE */\n-\n-/* A C expression for the size in bits of the type `long long' on the target\n-   machine.  If you don't define this, the default is two words.  If you want\n-   to support GNU Ada on your machine, the value of macro must be at least 64.  */\n #define LONG_LONG_TYPE_SIZE 64\n \n-/* A C expression for the size in bits of the type `char' on the target\n-   machine.  If you don't define this, the default is one quarter of a word.\n-   (If this would be less than one storage unit, it is rounded up to one unit.)  */\n #define CHAR_TYPE_SIZE 8\n \n-/* Maximum number for the size in bits of the type `char' on the target\n-   machine.  If this is undefined, the default is `CHAR_TYPE_SIZE'.  Otherwise,\n-   it is the constant value that is the largest value that `CHAR_TYPE_SIZE' can\n-   have at run-time.  This is used in `cpp'.  */\n-/* #define MAX_CHAR_TYPE_SIZE */\n-\n-/* A C expression for the size in bits of the type `float' on the target\n-   machine.  If you don't define this, the default is one word.  */\n #define FLOAT_TYPE_SIZE 32\n \n-/* A C expression for the size in bits of the type `double' on the target\n-   machine.  If you don't define this, the default is two words.  */\n #define DOUBLE_TYPE_SIZE 64\n \n-/* A C expression for the size in bits of the type `long double' on the target\n-   machine.  If you don't define this, the default is two words.  */\n #define LONG_DOUBLE_TYPE_SIZE 64\n \n-/* An expression whose value is 1 or 0, according to whether the type `char'\n-   should be signed or unsigned by default.  The user can always override this\n-   default with the options `-fsigned-char' and `-funsigned-char'.  */\n #define DEFAULT_SIGNED_CHAR 0\n \n-/* A C expression to determine whether to give an `enum' type only as many\n-   bytes as it takes to represent the range of possible values of that type.  A\n-   nonzero value means to do that; a zero value means all `enum' types should\n-   be allocated like `int'.\n-\n-   If you don't define the macro, the default is 0.  */\n-/* #define DEFAULT_SHORT_ENUMS */\n-\n-/* A C expression for a string describing the name of the data type to use for\n-   size values.  The typedef name `size_t' is defined using the contents of the\n-   string.\n-\n-   The string can contain more than one keyword.  If so, separate them with\n-   spaces, and write first any length keyword, then `unsigned' if appropriate,\n-   and finally `int'.  The string must exactly match one of the data type names\n-   defined in the function `init_decl_processing' in the file `c-decl.c'.  You\n-   may not omit `int' or change the order--that would cause the compiler to\n-   crash on startup.\n-\n-   If you don't define this macro, the default is `\"long unsigned int\"'.\n-\n-   Defined in svr4.h.  */\n+/* Defined in svr4.h.  */\n #define SIZE_TYPE \"unsigned int\"\n \n-/* A C expression for a string describing the name of the data type to use for\n-   the result of subtracting two pointers.  The typedef name `ptrdiff_t' is\n-   defined using the contents of the string.  See `SIZE_TYPE' above for more\n-   information.\n-\n-   If you don't define this macro, the default is `\"long int\"'.\n-\n-   Defined in svr4.h.  */\n+/* Defined in svr4.h.  */\n #define PTRDIFF_TYPE \"int\"\n \n-/* A C expression for a string describing the name of the data type to use for\n-   wide characters.  The typedef name `wchar_t' is defined using the contents\n-   of the string.  See `SIZE_TYPE' above for more information.\n-\n-   If you don't define this macro, the default is `\"int\"'.\n-\n-   Defined in svr4.h, to \"long int\".  */\n+/* Defined in svr4.h, to \"long int\".  */\n /* #define WCHAR_TYPE \"long int\" */\n \n-/* A C expression for the size in bits of the data type for wide characters.\n-   This is used in `cpp', which cannot make use of `WCHAR_TYPE'.\n-\n-   Defined in svr4.h.  */\n+/* Defined in svr4.h.  */\n #undef WCHAR_TYPE_SIZE\n #define WCHAR_TYPE_SIZE 32\n \n-/* Maximum number for the size in bits of the data type for wide characters.\n-   If this is undefined, the default is `WCHAR_TYPE_SIZE'.  Otherwise, it is\n-   the constant value that is the largest value that `WCHAR_TYPE_SIZE' can have\n-   at run-time.  This is used in `cpp'.  */\n-/* #define MAX_WCHAR_TYPE_SIZE */\n-\n /* Define this macro if the type of Objective C selectors should be `int'.\n \n    If this macro is not defined, then selectors should have the type `struct"}, {"sha": "6c5a4a6767ac7ecd1e615f5786fefc347e503997", "filename": "gcc/config/v850/v850.h", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1552d7b014918281e1bcb68388936b68094e354/gcc%2Fconfig%2Fv850%2Fv850.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1552d7b014918281e1bcb68388936b68094e354/gcc%2Fconfig%2Fv850%2Fv850.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.h?ref=d1552d7b014918281e1bcb68388936b68094e354", "patch": "@@ -158,24 +158,6 @@ enum small_memory_type {\n \n extern struct small_memory_info small_memory[(int)SMALL_MEMORY_max];\n \n-/* This macro is similar to `TARGET_SWITCHES' but defines names of\n-   command options that have values.  Its definition is an\n-   initializer with a subgrouping for each command option.\n-\n-   Each subgrouping contains a string constant, that defines the\n-   fixed part of the option name, and the address of a variable.  The\n-   variable, type `char *', is set to the variable part of the given\n-   option if the fixed part matches.  The actual option name is made\n-   by appending `-m' to the specified name.\n-\n-   Here is an example which defines `-mshort-data-NUMBER'.  If the\n-   given option is `-mshort-data-512', the variable `m88k_short_data'\n-   will be set to the string `\"512\"'.\n-\n-          extern char *m88k_short_data;\n-          #define TARGET_OPTIONS \\\n-           { { \"short-data-\", &m88k_short_data } } */\n-\n #define TARGET_OPTIONS\t\t\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n   { \"tda=\",\t&small_memory[ (int)SMALL_MEMORY_TDA ].value,\t\t\\"}]}