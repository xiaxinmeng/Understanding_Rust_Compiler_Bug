{"sha": "9fbcb61abb9860a9f508311bb5b5181ed625896f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWZiY2I2MWFiYjk4NjBhOWY1MDgzMTFiYjViNTE4MWVkNjI1ODk2Zg==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2002-01-08T19:57:01Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2002-01-08T19:57:01Z"}, "message": "[multiple changes]\n\n\n2002-01-08  Benjamin Kosnik  <bkoz@redhat.com>\n\n        libstdc++/2913\n        libstdc++/4879\n\t* include/bits/fstream.tcc (filebuf::_M_really_overflow): Test\n\treturn value of _M_file->sync().\n\t(filebuf::showmanyc): Check for is_open.\n\t* include/std/fstream (filebuf::sync): Tweak.\n\t* testsuite/27_io/filebuf.cc: Tweak.\n\n2002-01-08  John Fardo  <jfardo@laurelnetworks.com>\n\t    Brad Garcia  <garsh@attbi.com>\n\n\t* testsuite/27_io/filebuf_members.cc: Add test.\n\nFrom-SVN: r48654", "tree": {"sha": "4d2a0e09142e4c57137a2006fd234e9d7f7b0f64", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4d2a0e09142e4c57137a2006fd234e9d7f7b0f64"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9fbcb61abb9860a9f508311bb5b5181ed625896f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fbcb61abb9860a9f508311bb5b5181ed625896f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fbcb61abb9860a9f508311bb5b5181ed625896f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fbcb61abb9860a9f508311bb5b5181ed625896f/comments", "author": null, "committer": null, "parents": [{"sha": "234e114cffc7dd651aacc601069d25498f894673", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/234e114cffc7dd651aacc601069d25498f894673", "html_url": "https://github.com/Rust-GCC/gccrs/commit/234e114cffc7dd651aacc601069d25498f894673"}], "stats": {"total": 145, "additions": 108, "deletions": 37}, "files": [{"sha": "20367fb7dd14bffa0cce82408a7d55f2acbafe34", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fbcb61abb9860a9f508311bb5b5181ed625896f/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fbcb61abb9860a9f508311bb5b5181ed625896f/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=9fbcb61abb9860a9f508311bb5b5181ed625896f", "patch": "@@ -1,3 +1,18 @@\n+2002-01-08  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+        libstdc++/2913\n+        libstdc++/4879\n+\t* include/bits/fstream.tcc (filebuf::_M_really_overflow): Test\n+\treturn value of _M_file->sync().\n+\t(filebuf::showmanyc): Check for is_open.\n+\t* include/std/fstream (filebuf::sync): Tweak.\n+\t* testsuite/27_io/filebuf.cc: Tweak.\n+\n+2002-01-08  John Fardo  <jfardo@laurelnetworks.com>\n+\t    Brad Garcia  <garsh@attbi.com>\n+\t\n+\t* testsuite/27_io/filebuf_members.cc: Add test.\n+\t\n 2002-01-07  Benjamin Kosnik  <bkoz@redhat.com>\n  \t    Craig Rodrigues  <rodrigc@mediaone.net>\n "}, {"sha": "1e29e5d17c818524a2569656153ff9ec4ef75fe1", "filename": "libstdc++-v3/include/bits/fstream.tcc", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fbcb61abb9860a9f508311bb5b5181ed625896f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fbcb61abb9860a9f508311bb5b5181ed625896f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc?ref=9fbcb61abb9860a9f508311bb5b5181ed625896f", "patch": "@@ -182,11 +182,19 @@ namespace std\n       if (this->is_open())\n \t{\n \t  bool __testput = _M_out_cur && _M_out_beg < _M_out_end;\n-\t  if (__testput)\n-\t    _M_really_overflow(traits_type::eof());\n-\n-\t  // NB: Do this here so that re-opened filebufs will be cool...\n-\t  _M_pback_destroy();\n+\t  if (__testput\n+\t      && _M_really_overflow(traits_type::eof()) != traits_type::eof())\n+\t    {\n+\t      // NB: Do this here so that re-opened filebufs will be cool...\n+\t      _M_mode = ios_base::openmode(0);\n+\t      _M_destroy_internal_buffer();\n+\t      \n+\t      _M_pback_destroy();\n+\t      if (_M_pback)\n+\t\t{\n+\t\t  delete [] _M_pback;\n+\t\t  _M_pback = NULL;\n+\t\t}\n \n #if 0\n \t  // XXX not done\n@@ -196,16 +204,8 @@ namespace std\n \t      _M_really_overflow(traits_type::eof());\n \t    }\n #endif\n-\n-\t  _M_mode = ios_base::openmode(0);\n-\t  _M_destroy_internal_buffer();\n-\n-\t  if (_M_pback)\n-\t    {\n-\t      delete [] _M_pback;\n-\t      _M_pback = NULL;\n+\t      __ret = this;\n \t    }\n-\t  __ret = this;\n \t}\n \n       // Can actually allocate this file as part of an open and never\n@@ -227,7 +227,7 @@ namespace std\n       streamsize __ret = -1;\n       bool __testin = _M_mode & ios_base::in;\n \n-      if (__testin)\n+      if (__testin && this->is_open())\n \t{\n \t  if (_M_in_cur < _M_in_end)\n \t    __ret = _M_in_end - _M_in_cur;\n@@ -420,7 +420,7 @@ namespace std\n \t  if (__plen)\n \t    __len = _M_file->xsputn(_M_out_beg, __plen);\n \n-\t  if (__c !=traits_type::eof())\n+\t  if (__c != traits_type::eof())\n \t    {\n  \t      char_type __pending = traits_type::to_char_type(__c);\n  \t      __len += _M_file->xsputn(&__pending, 1);\n@@ -429,12 +429,11 @@ namespace std\n \n \t  // NB: Need this so that external byte sequence reflects\n \t  // internal buffer.\n-\t  _M_file->sync();\n \t  if (__len == __plen)\n-\t    {\n-\t      _M_set_indeterminate();\n-\t      __ret = traits_type::not_eof(__c);\n-\t    }\n+\t    _M_set_indeterminate();\n+\n+\t  if (!_M_file->sync())\n+\t    __ret = traits_type::not_eof(__c);\n #else\n \t  // Part one: Allocate temporary conversion buffer on\n \t  // stack. Convert internal buffer plus __c (ie,\n@@ -468,7 +467,7 @@ namespace std\n \t      streamsize __len = _M_file->xsputn(__conv_buf, __plen);\n \t      // NB: Need this so that external byte sequence reflects\n \t      // internal buffer.\n-\t      _M_file->sync();\n+\t      _M_file->sync(); // XXX error check\n \t      if (__len == __plen)\n \t\t{\n \t\t  _M_set_indeterminate();"}, {"sha": "a04ddf098dd1cdc81b7e2a05b445b2f26a9486e2", "filename": "libstdc++-v3/include/std/fstream", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fbcb61abb9860a9f508311bb5b5181ed625896f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffstream", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fbcb61abb9860a9f508311bb5b5181ed625896f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffstream", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffstream?ref=9fbcb61abb9860a9f508311bb5b5181ed625896f", "patch": "@@ -182,12 +182,11 @@ namespace std\n       sync(void)\n       {\n \tbool __testput = _M_out_cur && _M_out_beg < _M_out_end;\n-\tif (__testput)\n-\t  {\n-            // Make sure that libio resyncs its idea of the file position\n-            // with the external file.\n-            _M_file->sync();\n \n+\t// Make sure that the internal buffer resyncs its idea of\n+\t// the file position with the external file.\n+\tif (__testput && !_M_file->sync())\n+\t  {\n \t    // Need to restore current position. This interpreted as\n \t    // the position of the external byte sequence (_M_file)\n \t    // plus the offset in the current internal buffer\n@@ -354,7 +353,7 @@ namespace std\n       close(void)\n       { \n \tif (!_M_filebuf.close())\n-\t  setstate(ios_base::failbit); \n+\t  this->setstate(ios_base::failbit); \n       }\n     };\n "}, {"sha": "2ffaabd97ec78a9df08ef2419edc3d9417103228", "filename": "libstdc++-v3/testsuite/27_io/filebuf.cc", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fbcb61abb9860a9f508311bb5b5181ed625896f/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilebuf.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fbcb61abb9860a9f508311bb5b5181ed625896f/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilebuf.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilebuf.cc?ref=9fbcb61abb9860a9f508311bb5b5181ed625896f", "patch": "@@ -347,16 +347,15 @@ bool test03() {\n   for (int i = 50; i < 32 + 29; ++i)\n     fb_02.sputc(char(i));\n   fb_02.pubseekoff(0, std::ios_base::beg, std::ios_base::out);\n-  strmsz_1 = fb_02.in_avail();\n   c1 = fb_02.sgetc(); \n+  strmsz_1 = fb_02.in_avail();\n   c2 = fb_02.sungetc();\n-  strmsz_2 = fb_02.in_avail();\n   c3 = fb_02.sgetc();\n-  VERIFY( c1 == c2 );\n-  VERIFY( c3 == c2 );\n-  VERIFY( c1 == c3 );\n-  VERIFY( c2 == traits_type::eof() );\n-  VERIFY( strmsz_1 == strmsz_2 );\n+  strmsz_2 = fb_02.in_avail();\n+  VERIFY( c1 != c2 );\n+  VERIFY( c2 == c3 );\n+  VERIFY( c1 == traits_type::eof() );\n+  VERIFY( strmsz_1 != strmsz_2 );\n   //test for _in_cur == _in_end\n   fb_03.pubseekoff(0, std::ios_base::end);\n   strmsz_1 = fb_03.in_avail(); // -1 cuz at the end\n@@ -382,7 +381,7 @@ bool test03() {\n   fb_02.pubsync();\t\t\n   // 27filebuf-2.txt == 53 bytes after this.\n   strmsz_2 = fb_02.in_avail();\n-  VERIFY( strmsz_2 == -1 );\n+  VERIFY( strmsz_2 == 1 );\n   VERIFY( strmsz_2 == strmsz_1 );\n   strmsz_1 = fb_03.in_avail(); \n   fb_03.pubsync();"}, {"sha": "ab4a60f30944ccf3491f6a4dcd689b66fd8d521f", "filename": "libstdc++-v3/testsuite/27_io/filebuf_members.cc", "status": "modified", "additions": 60, "deletions": 1, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fbcb61abb9860a9f508311bb5b5181ed625896f/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilebuf_members.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fbcb61abb9860a9f508311bb5b5181ed625896f/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilebuf_members.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilebuf_members.cc?ref=9fbcb61abb9860a9f508311bb5b5181ed625896f", "patch": "@@ -23,9 +23,13 @@\n // various tests for filebuf::open() and filebuf::close() including\n // the non-portable functionality in the libstdc++-v3 IO library\n \n+#include <iostream>\n #include <fstream>\n #include <unistd.h>\n+#include <signal.h>\n #include <fcntl.h>\n+#include <sys/types.h>\n+#include <sys/stat.h>\n #include <testsuite_hooks.h>\n \n // verify that std::filebuf doesn't close files that it didn't open\n@@ -80,6 +84,7 @@ test_01()\n int\n test_02()\n {\n+  bool test = true;\n   int first_fd = ::open(name_01, O_RDONLY);\n   VERIFY( first_fd != -1 );\n   FILE* first_file = ::fdopen(first_fd, \"r\");\n@@ -88,7 +93,7 @@ test_02()\n \n   int second_fd = fb.fd();\n \n-  bool test = first_fd == second_fd;\n+  test = first_fd == second_fd;\n \n #ifdef DEBUG_ASSERT\n   assert(test);\n@@ -97,10 +102,64 @@ test_02()\n   return test;\n }\n \n+// libstdc++/2913, libstdc++/4879\n+// John Fardo  <jfardo@laurelnetworks.com>, Brad Garcia <garsh@attbi.com>\n+void\n+test_03()\n+{\n+  signal(SIGPIPE, SIG_IGN);\n+  \n+  if (0 != mkfifo(\"xxx\", S_IRWXU))\n+    {\n+      std::cerr << \"failed to creat fifo\" << std::endl;\n+      exit(-1);\n+    }\n+  \n+  int fval = fork();\n+  if (fval == -1)\n+    {\n+      std::cerr << \"failed to fork\" << std::endl;\n+      unlink(\"xxx\");\n+      exit(-1);\n+    }\n+  else if (fval == 0)\n+    {\n+      std::ifstream ifs(\"xxx\");\n+      sleep(1);\n+      ifs.close();\n+      exit(0);\n+    }\n+\n+  std::ofstream ofs(\"xxx\");\n+  sleep(2);\n+  ofs.put('t');\n+\n+  /*\n+   * ISO/IED 14882:1998(E) 27.8.1.10.4\n+   *\n+   * void close();\n+   *\n+   * Effects:  Calls rdbuf()->close() and, if that function fails\n+   * (returns a null pointer), calls setstate(failbit)...\n+   */\n+  ofs.close();\n+  if (!(ofs.rdstate() & std::ios::failbit))\n+    {\n+      std::cerr << \"fail bit was not set!\" << std::endl;\n+      unlink(\"xxx\");\n+      exit(-1);\n+    }\n+\n+  unlink(\"xxx\");\n+  exit(0);\n+}\n+\n int\n main()\n {\n   test_01();\n   test_02();\n+\n+  test_03();\n   return 0;\n }"}]}