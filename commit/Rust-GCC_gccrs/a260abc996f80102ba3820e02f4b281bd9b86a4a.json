{"sha": "a260abc996f80102ba3820e02f4b281bd9b86a4a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTI2MGFiYzk5NmY4MDEwMmJhMzgyMGUwMmY0YjI4MWJkOWI4NmE0YQ==", "commit": {"author": {"name": "David Edelsohn", "email": "edelsohn@mhpcc.edu", "date": "1998-06-04T11:47:15Z"}, "committer": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "1998-06-04T11:47:15Z"}, "message": "tree.c (get_inner_array_type): New function.\n\nThu Jun  4 14:35:27 1998  David Edelsohn  <edelsohn@mhpcc.edu>\n\t* tree.c (get_inner_array_type): New function.\n\t* tree.h (get_inner_array_type): Prototype.\n\t* expr.h (STACK_SAVEAREA_MODE): New macro.\n\t* expr.c (expand_builtin_setjmp): Initialize sa_mode using\n\tSTACK_SAVEAREA_MODE.\n\t(expand_builtin_longjmp): Likewise.\n\t* explow.c (emit_stack_save): Likewise.\n\t(allocate_dynamic_stack_space): Use Pmode not insn_operand_mode.\n\t* rs6000/aix41.h (ASM_CPU_SPEC): Define relative to ASM_DEFAULT_SPEC.\n\t(CPP_CPU_SPEC): Define relative to CPU_DEFAULT_SPEC.\n\t* rs6000/aix43.h: New file.\n\t* rs6000/t-aix43: New file.\n\t* rs6000/x-aix41: New file.\n\t* rs6000/x-aix43: New file.\n\t* configure.in (rs6000-ibm-aix*): Use them.\n\t* rs6000/powerpc.h: Delete.\n\t* rs6000/sysv4.h: Move necessary powerpc.h definitions to here.\n\t* rs6000/netware.h: and here.\n\t* rs6000/win-nt.h: and here.\n\t* rs6000/rs6000.c (processor_target_table, 620): Do not affect\n\tMASK_POWERPC64.\n\t(rs6000_override_options): Ignore flag_pic for AIX.\n\t(rs6000_immed_double_const): Delete.\n\t(u_short_cint_operand): Don't assume 32-bit CONST_INT.\n\t(reg_or_u_short_operand): Don't assume 32-bit CONST_INT.\n\t(num_insns_constant): mask64_operand() is 2 insns.\n\t(logical_operand): Don't assume 32-bit CONST_INT.\n\t(non_logical_cint_operand): Don't assume 32-bit CONST_INT.\n\t(easy_fp_constant): Any CONST_DOUBLE_HIGH is okay for 64-bit.\n\t(mask_constant): HOST_WIDE_INT parameter.\n\t(non_and_cint_operand): Delete.\n\t(mask64_operand): New function.\n\t(and64_operand): New function.\n\t(function_arg_advance): DImode arguments do not need special\n\talignment when 64-bit.\n\t(function_arg): Likewise.\n\t(setup_incoming_varargs): Reverse reg_size assignment.\n\t(print_operand): HOST_WIDE_INT second parameter.\n\t(print_operand, 'B'): New case.\n\t(print_operand, 'M'): Fix typo in lossage string.\n\t(print_operandm 'S'): New case.\n\t(rs6000_stack_info): Reverse reg_size assignment.  Use total_raw_size\n\tto compute AIX push_p.  Use reg_size to compute {cr,lr}_save_offset.\n\t(rs6000_output_load_toc_table): Reverse init_ptr assignment.  Use\n\tTARGET_64BIT not TARGET_POWERPC64.  Convert fprintf to fputs.\n\tLoad GOT highpart, don't add it.  Add lowpart with {cal|la}.\n\t(rs6000_allocate_stack_space): Use {cal|la}.\n\t(output_epilog): Use {cal|la}\n\t(output_function_profiler): Add call glue to mcount call.\n\tLoad GOT highpart, don't add it.  Add lowpart with {cal|la}.\n\t* rs6000/rs6000.h (TARGET_SWITCHES): Add powerpc64.\n\t(STACK_BOUNDARY): Depend on TARGET_32BIT.\n\t(ADJUST_FIELD_ALIGN): Calculate array alignment using innermost type.\n\t(CONST_OK_FOR_LETTER_P): Don't assume 32-bit CONST_INT.\n\t(EXTRA_CONSTRAINTS): Remove NT 'S' and 'T'.  Replace 'S' with\n\t64-bit mask operand.\n\t(RS6000_SAVE_TOC): Depend on TARGET_32BIT.\n\t(STACK_SAVEAREA_MODE): New macro.\n\t(LEGITIMATE_CONSTANT_P): DImode okay for 64bit.\n\t(LEGITIMIZE_RELOAD_ADDRESS): New macro.\n\t(RTX_COSTS, AND/IOR/XOR): Reflect current machine description.\n\t(ASM_FILE_START): Emit 64-bit ABI directive.\n\t(ASM_DECLARE_FUNCTION_NAME): Align CSECT on doubleword in 64-bit mode.\n\t(ASM_OUTPUT_SPECIAL_POOL_ENTRY): DImode okay for 64-bit.\n\t(PREDICATE_CODES): Add \"and64_operand\" and \"mask64_operand\".\n\tDelete \"non_and_cint_operand\".  \"input_operand\" includes CONST_DOUBLE.\n\t* rs6000/rs6000.md (iorsi3, xorsi3): Use HOST_WIDE_INT for mask.\n\tRestore define_splits.\n\t(floatsidf2, floatunssidf2): Remove !TARGET_POWERPC64 final constraint.\n\t(floatsidf2_internal, floatunssidf2_internal2): Likewise.\n\tDo not specify base register operand mode.\n\t(floatsidf2_loadaddr): Do not specify base register operand mode.\n\t(floatsidf2_store1, floatsidf2_store2): Operand 1 must be base\n\tregister; do not specify mode.  Remove !TARGET_POWERPC64 final\n\tconstraint.\n\t(floatsidf2_load): Do not specify base register operand mode.  Remove\n\t!TARGET_POWERPC64 final constraint.\n\t(fix_truncdfsi2_internal, fix_truncdfsi2_{store,load}): Do not specify\n\tbase register operand mode.\n\t(adddi3): Split large constants early.\n\t(absdi3): Shift by 63, not 31.\n\t(*mulsidi3_ppc64): New pattern.\n\t(rotldi3): Add masking combiner patterns.\n\t(anddi3): Add rldic{r,l} masking.  Remove split of large constants\n\tbecause PPC insns zero-extend.\n\t(iordi3, xordi3): Split large constants early.\n\t(movsi matcher): Remove S and T constraints.\n\t(movsf const_double): create SImode constant from TARGET_DOUBLE.\n\t(movdf_hardfloat32): Add default abort() case.\n\t(movdf easy_fp_const): create DImode constant from TARGET_DOUBLE.\n\t(movdi): Remove 64-bit constant generator.  Try to convert\n\tCONST_DOUBLE to CONST_INT.  Handle TOC memory constants.\n\t(movdi_32): Add default abort() case.\n\t(movdi_64): Add numerous ways to split 64-bit constants.\n\tMake catch-all define_split more optimal and never FAIL.\n\t(movti_ppc64): Add default abort() case.\n\t(allocate_stack): Remove operand modes.  Use Pmode.\n\t(restore_stack_block): Remove operand modes.  Generate Pmode\n\ttemporary.\n\t(save_stack_nonlocal, restore_stack_nonlocal):  Generate Pmode\n\ttemporary.  Save area is double Pmode.\n\t(call_indirect_aix64, call_value_indirect_aix64): New patterns.\n\t(call, call_value): Do not specify address operand mode.  Choose\n\tappropriate AIX ABI.\n\t(*call_local64, *ret_call_local64): New patterns.\n\t(*call_nonlocal_aix64, *ret_call_nonlocal_aix64): New patterns.\n\t(*ret_call_nonlocal_aix32): Use call_value_indirect for REG.\n\t(compare): Materialize DImode truthvalues.\n\nFrom-SVN: r20229", "tree": {"sha": "247f3a24f7b915cea6a0ba3261e58eac6c1ad9e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/247f3a24f7b915cea6a0ba3261e58eac6c1ad9e1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a260abc996f80102ba3820e02f4b281bd9b86a4a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a260abc996f80102ba3820e02f4b281bd9b86a4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a260abc996f80102ba3820e02f4b281bd9b86a4a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a260abc996f80102ba3820e02f4b281bd9b86a4a/comments", "author": null, "committer": null, "parents": [{"sha": "a66c6fe2a8a20cfd5d798fe9e667ef1aa3c4c648", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a66c6fe2a8a20cfd5d798fe9e667ef1aa3c4c648", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a66c6fe2a8a20cfd5d798fe9e667ef1aa3c4c648"}], "stats": {"total": 2203, "additions": 1646, "deletions": 557}, "files": [{"sha": "0e5a1d46d732be9c398b8d41265ac224df14a1b3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a260abc996f80102ba3820e02f4b281bd9b86a4a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a260abc996f80102ba3820e02f4b281bd9b86a4a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a260abc996f80102ba3820e02f4b281bd9b86a4a", "patch": "@@ -1,3 +1,118 @@\n+Thu Jun  4 14:35:27 1998  David Edelsohn  <edelsohn@mhpcc.edu>\n+\n+\t* tree.c (get_inner_array_type): New function.\n+\t* tree.h (get_inner_array_type): Prototype.\n+\t* expr.h (STACK_SAVEAREA_MODE): New macro.\n+\t* expr.c (expand_builtin_setjmp): Initialize sa_mode using\n+\tSTACK_SAVEAREA_MODE.\n+\t(expand_builtin_longjmp): Likewise.\n+\t* explow.c (emit_stack_save): Likewise.\n+\t(allocate_dynamic_stack_space): Use Pmode not insn_operand_mode.\n+\n+\t* rs6000/aix41.h (ASM_CPU_SPEC): Define relative to ASM_DEFAULT_SPEC.\n+\t(CPP_CPU_SPEC): Define relative to CPU_DEFAULT_SPEC.\n+\t* rs6000/aix43.h: New file.\n+\t* rs6000/t-aix43: New file.\n+\t* rs6000/x-aix41: New file.\n+\t* rs6000/x-aix43: New file.\n+\t* configure.in (rs6000-ibm-aix*): Use them.\n+\t* rs6000/powerpc.h: Delete.\n+\t* rs6000/sysv4.h: Move necessary powerpc.h definitions to here.\n+\t* rs6000/netware.h: and here.\n+\t* rs6000/win-nt.h: and here.\n+\n+\t* rs6000/rs6000.c (processor_target_table, 620): Do not affect\n+\tMASK_POWERPC64.\n+\t(rs6000_override_options): Ignore flag_pic for AIX.\n+\t(rs6000_immed_double_const): Delete.\n+\t(u_short_cint_operand): Don't assume 32-bit CONST_INT.\n+\t(reg_or_u_short_operand): Don't assume 32-bit CONST_INT.\n+\t(num_insns_constant): mask64_operand() is 2 insns.\n+\t(logical_operand): Don't assume 32-bit CONST_INT.\n+\t(non_logical_cint_operand): Don't assume 32-bit CONST_INT.\n+\t(easy_fp_constant): Any CONST_DOUBLE_HIGH is okay for 64-bit.\n+\t(mask_constant): HOST_WIDE_INT parameter.\n+\t(non_and_cint_operand): Delete.\n+\t(mask64_operand): New function.\n+\t(and64_operand): New function.\n+\t(function_arg_advance): DImode arguments do not need special\n+\talignment when 64-bit.\n+\t(function_arg): Likewise.\n+\t(setup_incoming_varargs): Reverse reg_size assignment.\n+\t(print_operand): HOST_WIDE_INT second parameter.\n+\t(print_operand, 'B'): New case.\n+\t(print_operand, 'M'): Fix typo in lossage string.\n+\t(print_operandm 'S'): New case.\n+\t(rs6000_stack_info): Reverse reg_size assignment.  Use total_raw_size\n+\tto compute AIX push_p.  Use reg_size to compute {cr,lr}_save_offset.\n+\t(rs6000_output_load_toc_table): Reverse init_ptr assignment.  Use\n+\tTARGET_64BIT not TARGET_POWERPC64.  Convert fprintf to fputs.\n+\tLoad GOT highpart, don't add it.  Add lowpart with {cal|la}.\n+\t(rs6000_allocate_stack_space): Use {cal|la}.\n+\t(output_epilog): Use {cal|la}\n+\t(output_function_profiler): Add call glue to mcount call.\n+\tLoad GOT highpart, don't add it.  Add lowpart with {cal|la}.\n+\n+\t* rs6000/rs6000.h (TARGET_SWITCHES): Add powerpc64.\n+\t(STACK_BOUNDARY): Depend on TARGET_32BIT.\n+\t(ADJUST_FIELD_ALIGN): Calculate array alignment using innermost type.\n+\t(CONST_OK_FOR_LETTER_P): Don't assume 32-bit CONST_INT.\n+\t(EXTRA_CONSTRAINTS): Remove NT 'S' and 'T'.  Replace 'S' with\n+\t64-bit mask operand.\n+\t(RS6000_SAVE_TOC): Depend on TARGET_32BIT.\n+\t(STACK_SAVEAREA_MODE): New macro.\n+\t(LEGITIMATE_CONSTANT_P): DImode okay for 64bit.\n+\t(LEGITIMIZE_RELOAD_ADDRESS): New macro.\n+\t(RTX_COSTS, AND/IOR/XOR): Reflect current machine description.\n+\t(ASM_FILE_START): Emit 64-bit ABI directive.\n+\t(ASM_DECLARE_FUNCTION_NAME): Align CSECT on doubleword in 64-bit mode.\n+\t(ASM_OUTPUT_SPECIAL_POOL_ENTRY): DImode okay for 64-bit.\n+\t(PREDICATE_CODES): Add \"and64_operand\" and \"mask64_operand\".\n+\tDelete \"non_and_cint_operand\".  \"input_operand\" includes CONST_DOUBLE.\n+\n+\t* rs6000/rs6000.md (iorsi3, xorsi3): Use HOST_WIDE_INT for mask.\n+\tRestore define_splits.\n+\t(floatsidf2, floatunssidf2): Remove !TARGET_POWERPC64 final constraint.\n+\t(floatsidf2_internal, floatunssidf2_internal2): Likewise.\n+\tDo not specify base register operand mode.\n+\t(floatsidf2_loadaddr): Do not specify base register operand mode.\n+\t(floatsidf2_store1, floatsidf2_store2): Operand 1 must be base\n+\tregister; do not specify mode.  Remove !TARGET_POWERPC64 final\n+\tconstraint.\n+\t(floatsidf2_load): Do not specify base register operand mode.  Remove\n+\t!TARGET_POWERPC64 final constraint.\n+\t(fix_truncdfsi2_internal, fix_truncdfsi2_{store,load}): Do not specify\n+\tbase register operand mode.\n+\t(adddi3): Split large constants early.\n+\t(absdi3): Shift by 63, not 31.\n+\t(*mulsidi3_ppc64): New pattern.\n+\t(rotldi3): Add masking combiner patterns.\n+\t(anddi3): Add rldic{r,l} masking.  Remove split of large constants\n+\tbecause PPC insns zero-extend.\n+\t(iordi3, xordi3): Split large constants early.\n+\t(movsi matcher): Remove S and T constraints.\n+\t(movsf const_double): create SImode constant from TARGET_DOUBLE.\n+\t(movdf_hardfloat32): Add default abort() case.\n+\t(movdf easy_fp_const): create DImode constant from TARGET_DOUBLE.\n+\t(movdi): Remove 64-bit constant generator.  Try to convert\n+\tCONST_DOUBLE to CONST_INT.  Handle TOC memory constants.\n+\t(movdi_32): Add default abort() case.\n+\t(movdi_64): Add numerous ways to split 64-bit constants.\n+\tMake catch-all define_split more optimal and never FAIL.\n+\t(movti_ppc64): Add default abort() case.\n+\t(allocate_stack): Remove operand modes.  Use Pmode.\n+\t(restore_stack_block): Remove operand modes.  Generate Pmode\n+\ttemporary.\n+\t(save_stack_nonlocal, restore_stack_nonlocal):  Generate Pmode\n+\ttemporary.  Save area is double Pmode.\n+\t(call_indirect_aix64, call_value_indirect_aix64): New patterns.\n+\t(call, call_value): Do not specify address operand mode.  Choose\n+\tappropriate AIX ABI.\n+\t(*call_local64, *ret_call_local64): New patterns.\n+\t(*call_nonlocal_aix64, *ret_call_nonlocal_aix64): New patterns.\n+\t(*ret_call_nonlocal_aix32): Use call_value_indirect for REG.\n+\t(compare): Materialize DImode truthvalues.\n+\n Thu Jun  4 01:26:57 1998  Craig Burley  <burley@gnu.org>\n \n \t* expr.c (safe_from_p): Avoid combinatorial explosion"}, {"sha": "a7664be572a3df490c512f8bca4c82ed517060f3", "filename": "gcc/config/rs6000/aix41.h", "status": "modified", "additions": 34, "deletions": 7, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a260abc996f80102ba3820e02f4b281bd9b86a4a/gcc%2Fconfig%2Frs6000%2Faix41.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a260abc996f80102ba3820e02f4b281bd9b86a4a/gcc%2Fconfig%2Frs6000%2Faix41.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faix41.h?ref=a260abc996f80102ba3820e02f4b281bd9b86a4a", "patch": "@@ -1,6 +1,6 @@\n /* Definitions of target machine for GNU compiler,\n    for IBM RS/6000 POWER running AIX version 4.1.\n-   Copyright (C) 1994, 1995, 1996, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1994, 1995, 1996, 1997, 1998 Free Software Foundation, Inc.\n    Contributed by David Edelsohn (edelsohn@npac.syr.edu).\n \n This file is part of GNU CC.\n@@ -38,15 +38,13 @@ Boston, MA 02111-1307, USA.  */\n \n /* Common ASM definitions used by ASM_SPEC amonst the various targets\n    for handling -mcpu=xxx switches.  */\n-\n #undef ASM_CPU_SPEC\n #define ASM_CPU_SPEC \\\n \"%{!mcpu*: \\\n   %{mpower: %{!mpower2: -mpwr}} \\\n   %{mpower2: -mpwr2} \\\n   %{mpowerpc*: -mppc} \\\n-  %{mno-power: %{!mpowerpc*: -mcom}} \\\n-  %{!mno-power: %{!mpower2: %(asm_default)}}} \\\n+  %{!mpower*: %{!mpowerpc*: %(asm_default)}}} \\\n %{mcpu=common: -mcom} \\\n %{mcpu=power: -mpwr} \\\n %{mcpu=power2: -mpwr2} \\\n@@ -67,6 +65,9 @@ Boston, MA 02111-1307, USA.  */\n %{mcpu=821: -mppc} \\\n %{mcpu=860: -mppc}\"\n \n+#undef\tASM_DEFAULT_SPEC\n+#define ASM_DEFAULT_SPEC \"-mcom\"\n+\n #undef CPP_PREDEFINES\n #define CPP_PREDEFINES \"-D_IBMR2 -D_POWER -D_AIX -D_AIX32 -D_AIX41 \\\n -Asystem(unix) -Asystem(aix)\"\n@@ -77,12 +78,38 @@ Boston, MA 02111-1307, USA.  */\n    %{mthreads: -D_THREAD_SAFE}\\\n    %(cpp_cpu)\"\n \n+/* Common CPP definitions used by CPP_SPEC among the various targets\n+   for handling -mcpu=xxx switches.  */\n+#undef CPP_CPU_SPEC\n+#define CPP_CPU_SPEC \\\n+\"%{!mcpu*: \\\n+  %{mpower: %{!mpower2: -D_ARCH_PWR}} \\\n+  %{mpower2: -D_ARCH_PWR2} \\\n+  %{mpowerpc*: -D_ARCH_PPC} \\\n+  %{!mpower*: %{!mpowerpc*: %(cpp_default)}}} \\\n+%{mcpu=common: -D_ARCH_COM} \\\n+%{mcpu=power: -D_ARCH_PWR} \\\n+%{mcpu=power2: -D_ARCH_PWR2} \\\n+%{mcpu=powerpc: -D_ARCH_PPC} \\\n+%{mcpu=rios: -D_ARCH_PWR} \\\n+%{mcpu=rios1: -D_ARCH_PWR} \\\n+%{mcpu=rios2: -D_ARCH_PWR2} \\\n+%{mcpu=rsc: -D_ARCH_PWR} \\\n+%{mcpu=rsc1: -D_ARCH_PWR} \\\n+%{mcpu=403: -D_ARCH_PPC} \\\n+%{mcpu=505: -D_ARCH_PPC} \\\n+%{mcpu=601: -D_ARCH_PPC -D_ARCH_PWR} \\\n+%{mcpu=602: -D_ARCH_PPC} \\\n+%{mcpu=603: -D_ARCH_PPC} \\\n+%{mcpu=603e: -D_ARCH_PPC} \\\n+%{mcpu=604: -D_ARCH_PPC} \\\n+%{mcpu=620: -D_ARCH_PPC} \\\n+%{mcpu=821: -D_ARCH_PPC} \\\n+%{mcpu=860: -D_ARCH_PPC}\"\n+\n #undef\tCPP_DEFAULT_SPEC\n #define CPP_DEFAULT_SPEC \"-D_ARCH_COM\"\n \n-#undef\tASM_DEFAULT_SPEC\n-#define ASM_DEFAULT_SPEC \"-mcom\"\n-\n #undef TARGET_DEFAULT\n #define TARGET_DEFAULT MASK_NEW_MNEMONICS\n "}, {"sha": "fa7b716476167d72a5049ac1082efbe2870ed931", "filename": "gcc/config/rs6000/aix43.h", "status": "added", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a260abc996f80102ba3820e02f4b281bd9b86a4a/gcc%2Fconfig%2Frs6000%2Faix43.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a260abc996f80102ba3820e02f4b281bd9b86a4a/gcc%2Fconfig%2Frs6000%2Faix43.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faix43.h?ref=a260abc996f80102ba3820e02f4b281bd9b86a4a", "patch": "@@ -0,0 +1,199 @@\n+/* Definitions of target machine for GNU compiler,\n+   for IBM RS/6000 POWER running AIX version 4.3.\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+   Contributed by David Edelsohn (edelsohn@mhpcc.edu).\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+\n+/* Enable AIX XL compiler calling convention breakage compatibility.  */\n+#define MASK_XL_CALL\t\t0x40000000\n+#define\tTARGET_XL_CALL\t\t(target_flags & MASK_XL_CALL)\n+#undef  SUBTARGET_SWITCHES\n+#define SUBTARGET_SWITCHES\t\t\t\t\t\\\n+  {\"aix64\", \t\tMASK_64BIT | MASK_POWERPC64 | MASK_POWERPC}, \\\n+  {\"aix32\",\t\t- (MASK_64BIT | MASK_POWERPC64)},\t\\\n+  {\"xl-call\", \t\tMASK_XL_CALL},\t\t\t\t\\\n+  {\"no-xl-call\",\t- MASK_XL_CALL}, \t\t\t\\\n+  {\"threads\",\t\t0},\t\t\t\t\t\\\n+  {\"pe\",\t\t0},\n+\n+/* Sometimes certain combinations of command options do not make sense\n+   on a particular target machine.  You can define a macro\n+   `OVERRIDE_OPTIONS' to take account of this.  This macro, if\n+   defined, is executed once just after all the command options have\n+   been parsed.\n+\n+   The macro SUBTARGET_OVERRIDE_OPTIONS is provided for subtargets, to\n+   get control.  */\n+\n+#define NON_POWERPC_MASKS (MASK_POWER | MASK_POWER2 | MASK_STRING)\n+#define SUBTARGET_OVERRIDE_OPTIONS\t\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  if (TARGET_64BIT && (target_flags & NON_POWERPC_MASKS))\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      target_flags &= ~NON_POWERPC_MASKS;\t\t\t\t\\\n+      error (\"-maix64 and POWER architecture are incompatible.\");\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+} while (0);\n+\n+#include \"rs6000/rs6000.h\"\n+\n+#undef ASM_SPEC\n+#define ASM_SPEC \"-u %{maix64:-a64 -mppc64} %(asm_cpu)\"\n+\n+/* Common ASM definitions used by ASM_SPEC amonst the various targets\n+   for handling -mcpu=xxx switches.  */\n+#undef ASM_CPU_SPEC\n+#define ASM_CPU_SPEC \\\n+\"%{!mcpu*: %{!maix64: \\\n+  %{mpower: %{!mpower2: -mpwr}} \\\n+  %{mpower2: -mpwr2} \\\n+  %{mpowerpc*: %{!mpowerpc64: -mppc}} \\\n+  %{mpowerpc64: -mppc64} \\\n+  %{!mpower*: %{!mpowerpc*: %(asm_default)}}}} \\\n+%{mcpu=common: -mcom} \\\n+%{mcpu=power: -mpwr} \\\n+%{mcpu=power2: -mpwr2} \\\n+%{mcpu=powerpc: -mppc} \\\n+%{mcpu=rios: -mpwr} \\\n+%{mcpu=rios1: -mpwr} \\\n+%{mcpu=rios2: -mpwr2} \\\n+%{mcpu=rsc: -mpwr} \\\n+%{mcpu=rsc1: -mpwr} \\\n+%{mcpu=403: -mppc} \\\n+%{mcpu=505: -mppc} \\\n+%{mcpu=601: -m601} \\\n+%{mcpu=602: -mppc} \\\n+%{mcpu=603: -m603} \\\n+%{mcpu=603e: -m603} \\\n+%{mcpu=604: -m604} \\\n+%{mcpu=620: -mppc} \\\n+%{mcpu=821: -mppc} \\\n+%{mcpu=860: -mppc}\"\n+\n+#undef\tASM_DEFAULT_SPEC\n+#define ASM_DEFAULT_SPEC \"-mcom\"\n+\n+#undef CPP_PREDEFINES\n+#define CPP_PREDEFINES \"-D_IBMR2 -D_POWER -D_AIX -D_AIX32 -D_AIX41 -D_AIX43 \\\n+-Asystem(unix) -Asystem(aix)\"\n+\n+#undef CPP_SPEC\n+#define CPP_SPEC \"%{posix: -D_POSIX_SOURCE}\\\n+   %{maix64: -D__64BIT__ -D_ARCH_PPC}\\\n+   %{mpe: -I/usr/lpp/ppe.poe/include}\\\n+   %{mthreads: -D_THREAD_SAFE}\\\n+   %(cpp_cpu)\"\n+\n+/* Common CPP definitions used by CPP_SPEC among the various targets\n+   for handling -mcpu=xxx switches.  */\n+#undef CPP_CPU_SPEC\n+#define CPP_CPU_SPEC \\\n+\"%{!mcpu*: %{!maix64: \\\n+  %{mpower: %{!mpower2: -D_ARCH_PWR}} \\\n+  %{mpower2: -D_ARCH_PWR2} \\\n+  %{mpowerpc*: -D_ARCH_PPC} \\\n+  %{!mpower*: %{!mpowerpc*: %(cpp_default)}}}} \\\n+%{mcpu=common: -D_ARCH_COM} \\\n+%{mcpu=power: -D_ARCH_PWR} \\\n+%{mcpu=power2: -D_ARCH_PWR2} \\\n+%{mcpu=powerpc: -D_ARCH_PPC} \\\n+%{mcpu=rios: -D_ARCH_PWR} \\\n+%{mcpu=rios1: -D_ARCH_PWR} \\\n+%{mcpu=rios2: -D_ARCH_PWR2} \\\n+%{mcpu=rsc: -D_ARCH_PWR} \\\n+%{mcpu=rsc1: -D_ARCH_PWR} \\\n+%{mcpu=403: -D_ARCH_PPC} \\\n+%{mcpu=505: -D_ARCH_PPC} \\\n+%{mcpu=601: -D_ARCH_PPC -D_ARCH_PWR} \\\n+%{mcpu=602: -D_ARCH_PPC} \\\n+%{mcpu=603: -D_ARCH_PPC} \\\n+%{mcpu=603e: -D_ARCH_PPC} \\\n+%{mcpu=604: -D_ARCH_PPC} \\\n+%{mcpu=620: -D_ARCH_PPC} \\\n+%{mcpu=821: -D_ARCH_PPC} \\\n+%{mcpu=860: -D_ARCH_PPC}\"\n+\n+#undef\tCPP_DEFAULT_SPEC\n+#define CPP_DEFAULT_SPEC \"-D_ARCH_COM\"\n+\n+#undef TARGET_DEFAULT\n+#define TARGET_DEFAULT MASK_NEW_MNEMONICS\n+\n+#undef PROCESSOR_DEFAULT\n+#define PROCESSOR_DEFAULT PROCESSOR_PPC604\n+\n+/* Define this macro as a C expression for the initializer of an\n+   array of string to tell the driver program which options are\n+   defaults for this target and thus do not need to be handled\n+   specially when using `MULTILIB_OPTIONS'.\n+\n+   Do not define this macro if `MULTILIB_OPTIONS' is not defined in\n+   the target makefile fragment or if none of the options listed in\n+   `MULTILIB_OPTIONS' are set by default.  *Note Target Fragment::.  */\n+\n+#undef\tMULTILIB_DEFAULTS\n+#define\tMULTILIB_DEFAULTS { \"mcpu=common\" }\n+\n+/* These are not necessary when we pass -u to the assembler, and undefining\n+   them saves a great deal of space in object files.  */\n+\n+#undef ASM_OUTPUT_EXTERNAL\n+#undef ASM_OUTPUT_EXTERNAL_LIBCALL\n+#define ASM_OUTPUT_EXTERNAL(FILE, DECL, NAME)\t\\\n+{ rtx _symref = XEXP (DECL_RTL (DECL), 0);\t\\\n+  if ((TREE_CODE (DECL) == VAR_DECL\t\t\\\n+       || TREE_CODE (DECL) == FUNCTION_DECL)\t\\\n+      && (NAME)[strlen (NAME) - 1] != ']')\t\\\n+    {\t\t\t\t\t\t\\\n+      char *_name = (char *) permalloc (strlen (XSTR (_symref, 0)) + 5); \\\n+      strcpy (_name, XSTR (_symref, 0));\t\\\n+      strcat (_name, TREE_CODE (DECL) == FUNCTION_DECL ? \"[DS]\" : \"[RW]\"); \\\n+      XSTR (_symref, 0) = _name;\t\t\\\n+    }\t\t\t\t\t\t\\\n+}\n+\n+#undef LIB_SPEC\n+#define LIB_SPEC \"%{pg:-L/lib/profiled -L/usr/lib/profiled}\\\n+   %{p:-L/lib/profiled -L/usr/lib/profiled} %{!shared:%{g*:-lg}}\\\n+   %{mpe:-L/usr/lpp/ppe.poe/lib -lmpi -lvtd}\\\n+   %{mthreads: -L/usr/lib/threads -lpthreads -lc_r /usr/lib/libc.a}\\\n+   %{!mthreads: -lc}\"\n+\n+#undef LINK_SPEC\n+#define LINK_SPEC \"-bpT:0x10000000 -bpD:0x20000000 %{!r:-btextro} -bnodelcsect\\\n+   %{static:-bnso %(link_syscalls) } %{!shared: %{g*: %(link_libg) }}\\\n+   %{shared:-bM:SRE %{!e:-bnoentry}} %{maix64:-b64}\"\n+\n+#undef STARTFILE_SPEC\n+#define STARTFILE_SPEC \"%{!shared:\\\n+   %{mpe:%{pg:/usr/lpp/ppe.poe/lib/gcrt0.o}\\\n+         %{!pg:%{p:/usr/lpp/ppe.poe/lib/mcrt0.o}\\\n+               %{!p:/usr/lpp/ppe.poe/lib/crt0.o}}}\\\n+   %{!mpe:\\\n+     %{maix64:%{pg:gcrt0_64%O%s}%{!pg:%{p:mcrt0_64%O%s}%{!p:crt0_64%O%s}}}\\\n+     %{!maix64:\\\n+       %{mthreads:%{pg:gcrt0_r%O%s}%{!pg:%{p:mcrt0_r%O%s}%{!p:crt0_r%O%s}}}\\\n+       %{!mthreads:%{pg:gcrt0%O%s}%{!pg:%{p:mcrt0%O%s}%{!p:crt0%O%s}}}}}}\"\n+\n+/* AIX 4.3 typedefs ptrdiff_t as \"long\" while earlier releases used \"int\".  */\n+\n+#undef PTRDIFF_TYPE\n+#define PTRDIFF_TYPE \"long int\"\n+"}, {"sha": "a465c63fe3b7e5fefbf017f3d297f29c9de3ac5d", "filename": "gcc/config/rs6000/netware.h", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a260abc996f80102ba3820e02f4b281bd9b86a4a/gcc%2Fconfig%2Frs6000%2Fnetware.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a260abc996f80102ba3820e02f4b281bd9b86a4a/gcc%2Fconfig%2Frs6000%2Fnetware.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fnetware.h?ref=a260abc996f80102ba3820e02f4b281bd9b86a4a", "patch": "@@ -1,6 +1,6 @@\n /* Core target definitions for GNU compiler\n    for IBM RS/6000 PowerPC running NetWare\n-   Copyright (C) 1994, 1995, 1996 Free Software Foundation, Inc.\n+   Copyright (C) 1994, 1995, 1996, 1998 Free Software Foundation, Inc.\n    Contributed by Cygnus Support.\n \n This file is part of GNU CC.\n@@ -21,7 +21,17 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n #define TARGET_AIX 0\n \n-#include \"rs6000/powerpc.h\"\n+#define CPP_DEFAULT_SPEC \"-D_ARCH_PPC\"\n+\n+#define ASM_DEFAULT_SPEC \"-mppc\"\n+\n+#include \"rs6000/rs6000.h\"\n+\n+#undef TARGET_DEFAULT\n+#define TARGET_DEFAULT (MASK_POWERPC | MASK_NEW_MNEMONICS)\n+\n+#undef PROCESSOR_DEFAULT\n+#define PROCESSOR_DEFAULT PROCESSOR_PPC601\n \n /* Don't generate XCOFF debugging information.  */\n "}, {"sha": "9f1ffd606cc23211528baa57de1c7549f962a685", "filename": "gcc/config/rs6000/powerpc.h", "status": "removed", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a66c6fe2a8a20cfd5d798fe9e667ef1aa3c4c648/gcc%2Fconfig%2Frs6000%2Fpowerpc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a66c6fe2a8a20cfd5d798fe9e667ef1aa3c4c648/gcc%2Fconfig%2Frs6000%2Fpowerpc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpowerpc.h?ref=a66c6fe2a8a20cfd5d798fe9e667ef1aa3c4c648", "patch": "@@ -1,61 +0,0 @@\n-/* Definitions of target machine for GNU compiler,\n-   for IBM RS/6000 PowerPC running AIX version 3.2.\n-   Copyright (C) 1993, 1994, 1995, 1996 Free Software Foundation, Inc.\n-   Contributed by David Edelsohn (edelsohn@npac.syr.edu).\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-\n-#include \"rs6000/rs6000.h\"\n-\n-#undef ASM_SPEC\n-#define ASM_SPEC \"-u %(asm_cpu)\"\n-\n-#undef CPP_PREDEFINES\n-#define CPP_PREDEFINES \"-D_IBMR2 -D_POWER -D_AIX -D_AIX32 \\\n--Asystem(unix) -Asystem(aix) -Acpu(powerpc) -Amachine(powerpc)\"\n-\n-#undef\tCPP_DEFAULT_SPEC\n-#define\tCPP_DEFAULT_SPEC \"-D_ARCH_PPC\"\n-\n-#undef\tASM_DEFAULT_SPEC\n-#define\tASM_DEFAULT_SPEC \"-mppc\"\n-\n-#undef TARGET_DEFAULT\n-#define TARGET_DEFAULT (MASK_POWERPC | MASK_NEW_MNEMONICS)\n-\n-#undef PROCESSOR_DEFAULT\n-#define PROCESSOR_DEFAULT PROCESSOR_PPC601\n-\n-/* These are not necessary when we pass -u to the assembler, and undefining\n-   them saves a great deal of space in object files.  */\n-\n-#undef ASM_OUTPUT_EXTERNAL\n-#undef ASM_OUTPUT_EXTERNAL_LIBCALL\n-#define ASM_OUTPUT_EXTERNAL(FILE, DECL, NAME)\t\\\n-{ rtx _symref = XEXP (DECL_RTL (DECL), 0);\t\\\n-  if ((TREE_CODE (DECL) == VAR_DECL\t\t\\\n-       || TREE_CODE (DECL) == FUNCTION_DECL)\t\\\n-      && (NAME)[strlen (NAME) - 1] != ']')\t\\\n-    {\t\t\t\t\t\t\\\n-      char *_name = (char *) permalloc (strlen (XSTR (_symref, 0)) + 5); \\\n-      strcpy (_name, XSTR (_symref, 0));\t\\\n-      strcat (_name, TREE_CODE (DECL) == FUNCTION_DECL ? \"[DS]\" : \"[RW]\"); \\\n-      XSTR (_symref, 0) = _name;\t\t\\\n-    }\t\t\t\t\t\t\\\n-}"}, {"sha": "6a04d552855eaf6ccabb1755b9eb57b8cd199abb", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 232, "deletions": 123, "changes": 355, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a260abc996f80102ba3820e02f4b281bd9b86a4a/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a260abc996f80102ba3820e02f4b281bd9b86a4a/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=a260abc996f80102ba3820e02f4b281bd9b86a4a", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines used for code generation on IBM RS/6000.\n-   Copyright (C) 1991, 93, 94, 95, 96, 97, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1991, 93-7, 1998 Free Software Foundation, Inc.\n    Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu)\n \n This file is part of GNU CC.\n@@ -226,7 +226,7 @@ rs6000_override_options (default_cpu)\n \t    POWER_MASKS | MASK_PPC_GPOPT | MASK_POWERPC64},\n \t {\"620\", PROCESSOR_PPC620,\n \t    MASK_POWERPC | MASK_PPC_GFXOPT | MASK_NEW_MNEMONICS,\n-\t    POWER_MASKS | MASK_PPC_GPOPT | MASK_POWERPC64},\n+\t    POWER_MASKS | MASK_PPC_GPOPT},\n \t {\"801\", PROCESSOR_MPCCORE,\n \t    MASK_POWERPC | MASK_SOFT_FLOAT | MASK_NEW_MNEMONICS,\n \t    POWER_MASKS | POWERPC_OPT_MASKS | MASK_POWERPC64},\n@@ -304,6 +304,13 @@ rs6000_override_options (default_cpu)\n \t}\n     }\n \n+  if (flag_pic && (DEFAULT_ABI == ABI_AIX))\n+    {\n+      warning (\"-f%s ignored for AIX (all code is position independent)\",\n+\t       (flag_pic > 1) ? \"PIC\" : \"pic\");\n+      flag_pic = 0;\n+    }\n+\n   /* Set debug flags */\n   if (rs6000_debug_name)\n     {\n@@ -388,22 +395,6 @@ rs6000_float_const (string, mode)\n   REAL_VALUE_TYPE value = REAL_VALUE_ATOF (string, mode);\n   return immed_real_const_1 (value, mode);\n }\n-\n-\f\n-/* Create a CONST_DOUBLE like immed_double_const, except reverse the\n-   two parts of the constant if the target is little endian.  */\n-\n-struct rtx_def *\n-rs6000_immed_double_const (i0, i1, mode)\n-     HOST_WIDE_INT i0, i1;\n-     enum machine_mode mode;\n-{\n-  if (! WORDS_BIG_ENDIAN)\n-    return immed_double_const (i1, i0, mode);\n-\n-  return immed_double_const (i0, i1, mode);\n-}\n-\n \f\n /* Return non-zero if this function is known to have a null epilogue.  */\n \n@@ -492,7 +483,8 @@ u_short_cint_operand (op, mode)\n      register rtx op;\n      enum machine_mode mode;\n {\n-  return (GET_CODE (op) == CONST_INT && (INTVAL (op) & 0xffff0000) == 0);\n+  return (GET_CODE (op) == CONST_INT\n+\t  && (INTVAL (op) & (~ (HOST_WIDE_INT) 0xffff)) == 0);\n }\n \n /* Return 1 if OP is a CONST_INT that cannot fit in a signed D field.  */\n@@ -569,7 +561,7 @@ reg_or_u_short_operand (op, mode)\n      enum machine_mode mode;\n {\n   if (GET_CODE (op) == CONST_INT\n-      && (INTVAL (op) & 0xffff0000) == 0)\n+      && (INTVAL (op) & (~ (HOST_WIDE_INT) 0xffff)) == 0)\n     return 1;\n \n   return gpc_reg_operand (op, mode);\n@@ -706,6 +698,9 @@ num_insns_constant (op, mode)\n \t\t   && ((low & 0x80000000) != 0))\n \t    return num_insns_constant_wide (low);\n \n+\t  else if (mask64_operand (op, mode))\n+\t    return 2;\n+\n \t  else if (low == 0)\n \t    return num_insns_constant_wide (high) + 1;\n \n@@ -770,8 +765,10 @@ easy_fp_constant (op, mode)\n       return num_insns_constant_wide (l) == 1;\n     }\n \n-  else if (mode == DImode && TARGET_32BIT)\n-    return num_insns_constant (op, DImode) == 2;\n+  else if (mode == DImode)\n+    return ((TARGET_64BIT\n+\t     && GET_CODE (op) == CONST_DOUBLE && CONST_DOUBLE_LOW (op) == 0)\n+\t    || (num_insns_constant (op, DImode) <= 2));\n \n   else\n     abort ();\n@@ -861,7 +858,7 @@ logical_operand (op, mode)\n {\n   return (gpc_reg_operand (op, mode)\n \t  || (GET_CODE (op) == CONST_INT\n-\t      && ((INTVAL (op) & 0xffff0000) == 0\n+\t      && ((INTVAL (op) & (~ (HOST_WIDE_INT) 0xffff)) == 0\n \t\t  || (INTVAL (op) & 0xffff) == 0)));\n }\n \n@@ -874,7 +871,7 @@ non_logical_cint_operand (op, mode)\n      enum machine_mode mode;\n {\n   return (GET_CODE (op) == CONST_INT\n-\t  && (INTVAL (op) & 0xffff0000) != 0\n+\t  && (INTVAL (op) & (~ (HOST_WIDE_INT) 0xffff)) != 0\n \t  && (INTVAL (op) & 0xffff) != 0);\n }\n \n@@ -885,7 +882,7 @@ non_logical_cint_operand (op, mode)\n \n int\n mask_constant (c)\n-     register int c;\n+     register HOST_WIDE_INT c;\n {\n   int i;\n   int last_bit_value;\n@@ -913,27 +910,105 @@ mask_operand (op, mode)\n   return GET_CODE (op) == CONST_INT && mask_constant (INTVAL (op));\n }\n \n-/* Return 1 if the operand is either a non-special register or a\n-   constant that can be used as the operand of an RS/6000 logical AND insn.  */\n+/* Return 1 if the operand is a constant that is a PowerPC64 mask.\n+   It is if there are no more than one 1->0 or 0->1 transitions.\n+   Reject all ones and all zeros, since these should have been optimized\n+   away and confuse the making of MB and ME.  */\n \n int\n-and_operand (op, mode)\n+mask64_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) == CONST_INT)\n+    {\n+      HOST_WIDE_INT c = INTVAL (op);\n+      int i;\n+      int last_bit_value;\n+      int transitions = 0;\n+\n+      if (c == 0 || c == ~0)\n+\treturn 0;\n+\n+      last_bit_value = c & 1;\n+\n+      for (i = 1; i < HOST_BITS_PER_WIDE_INT; i++)\n+\tif (((c >>= 1) & 1) != last_bit_value)\n+\t  last_bit_value ^= 1, transitions++;\n+\n+#if HOST_BITS_PER_INT == 32\n+      /* Consider CONST_INT sign-extended.  */\n+      transitions += (last_bit_value != 1);\n+#endif\n+\n+      return transitions <= 1;\n+    }\n+  else if (GET_CODE (op) == CONST_DOUBLE\n+\t   && (mode == VOIDmode || mode == DImode))\n+    {\n+      HOST_WIDE_INT low = CONST_DOUBLE_LOW (op);\n+#if HOST_BITS_PER_INT == 32\n+      HOST_WIDE_INT high = CONST_DOUBLE_HIGH (op);\n+#endif\n+      int i;\n+      int last_bit_value;\n+      int transitions = 0;\n+\n+      if ((low == 0\n+#if HOST_BITS_PER_INT == 32\n+\t  && high == 0\n+#endif\n+\t   )\n+\t  || (low == ~0\n+#if HOST_BITS_PER_INT == 32\n+\t      && high == ~0\n+#endif\n+\t      ))\n+\treturn 0;\n+\n+      last_bit_value = low & 1;\n+\n+      for (i = 1; i < HOST_BITS_PER_WIDE_INT; i++)\n+\tif (((low >>= 1) & 1) != last_bit_value)\n+\t  last_bit_value ^= 1, transitions++;\n+\n+#if HOST_BITS_PER_INT == 32\n+      if ((high & 1) != last_bit_value)\n+\tlast_bit_value ^= 1, transitions++;\n+\n+      for (i = 1; i < HOST_BITS_PER_WIDE_INT; i++)\n+\tif (((high >>= 1) & 1) != last_bit_value)\n+\t  last_bit_value ^= 1, transitions++;\n+#endif\n+\n+      return transitions <= 1;\n+    }\n+  else\n+    return 0;\n+}\n+\n+/* Return 1 if the operand is either a non-special register or a constant\n+   that can be used as the operand of a PowerPC64 logical AND insn.  */\n+\n+int\n+and64_operand (op, mode)\n     register rtx op;\n     enum machine_mode mode;\n {\n   return (logical_operand (op, mode)\n-\t  || mask_operand (op, mode));\n+\t  || mask64_operand (op, mode));\n }\n \n-/* Return 1 if the operand is a constant but not a valid operand for an AND\n-   insn.  */\n+/* Return 1 if the operand is either a non-special register or a\n+   constant that can be used as the operand of an RS/6000 logical AND insn.  */\n \n int\n-non_and_cint_operand (op, mode)\n-     register rtx op;\n-     enum machine_mode mode;\n+and_operand (op, mode)\n+    register rtx op;\n+    enum machine_mode mode;\n {\n-  return GET_CODE (op) == CONST_INT && ! and_operand (op, mode);\n+  return (logical_operand (op, mode)\n+\t  || mask_operand (op, mode));\n }\n \n /* Return 1 if the operand is a general register or memory operand.  */\n@@ -1240,7 +1315,8 @@ function_arg_advance (cum, mode, type, named)\n      tree type;\n      int named;\n {\n-  int align = ((cum->words & 1) != 0 && function_arg_boundary (mode, type) == 64) ? 1 : 0;\n+  int align = (TARGET_32BIT && (cum->words & 1) != 0\n+\t       && function_arg_boundary (mode, type) == 64) ? 1 : 0;\n   cum->words += align;\n   cum->nargs_prototype--;\n \n@@ -1313,7 +1389,8 @@ function_arg (cum, mode, type, named)\n      tree type;\n      int named;\n {\n-  int align = ((cum->words & 1) != 0 && function_arg_boundary (mode, type) == 64) ? 1 : 0;\n+  int align = (TARGET_32BIT && (cum->words & 1) != 0\n+\t       && function_arg_boundary (mode, type) == 64) ? 1 : 0;\n   int align_words = cum->words + align;\n \n   if (TARGET_DEBUG_ARG)\n@@ -1489,7 +1566,7 @@ setup_incoming_varargs (cum, mode, type, pretend_size, no_rtl)\n \n {\n   rtx save_area = virtual_incoming_args_rtx;\n-  int reg_size\t= (TARGET_64BIT) ? 8 : 4;\n+  int reg_size\t= TARGET_32BIT ? 4 : 8;\n \n   if (TARGET_DEBUG_ARG)\n     fprintf (stderr,\n@@ -2395,7 +2472,7 @@ print_operand (file, x, code)\n     char code;\n {\n   int i;\n-  int val;\n+  HOST_WIDE_INT val;\n \n   /* These macros test for integers and extract the low-order bits.  */\n #define INT_P(X)  \\\n@@ -2443,6 +2520,11 @@ print_operand (file, x, code)\n       fprintf (file, \"%d\", INT_LOWPART (x) & 0xffff);\n       return;\n \n+    case 'B':\n+      /* If the low-order bit is zero, write 'r'; otherwise, write 'l'\n+\t for 64-bit mask direction.  */\n+      putc ((INT_LOWPART(x) & 1 == 0 ? 'r' : 'l'), file);\n+\n     case 'C':\n       /* This is an optional cror needed for LE or GE floating-point\n \t comparisons.  Otherwise write nothing.  */\n@@ -2619,15 +2701,15 @@ print_operand (file, x, code)\n \tif (((val >>= 1) & 1) == 0)\n \t  break;\n \n-      /* If we ended in ...01, I would be 0.  The correct value is 31, so\n+      /* If we ended in ...01, i would be 0.  The correct value is 31, so\n \t we want 31 - i.  */\n       fprintf (file, \"%d\", 31 - i);\n       return;\n \n     case 'M':\n       /* ME value for a mask operand.  */\n       if (! mask_operand (x, VOIDmode))\n-\toutput_operand_lossage (\"invalid %%m value\");\n+\toutput_operand_lossage (\"invalid %%M value\");\n \n       val = INT_LOWPART (x);\n \n@@ -2645,7 +2727,7 @@ print_operand (file, x, code)\n \t    if ((val >>= 1) & 1)\n \t      break;\n \n-\t  /* If we had ....10, I would be 0.  The result should be\n+\t  /* If we had ....10, i would be 0.  The result should be\n \t     30, so we need 30 - i.  */\n \t  fprintf (file, \"%d\", 30 - i);\n \t  return;\n@@ -2711,6 +2793,72 @@ print_operand (file, x, code)\n       fprintf (file, \"%d\", (32 - INT_LOWPART (x)) & 31);\n       return;\n \n+    case 'S':\n+      /* PowerPC64 mask position.  All 0's and all 1's are excluded.\n+\t CONST_INT 32-bit mask is considered sign-extended so any\n+\t transition must occur within the CONST_INT, not on the boundary.  */\n+      if (! mask64_operand (x, VOIDmode))\n+\toutput_operand_lossage (\"invalid %%S value\");\n+\n+      val = INT_LOWPART (x);\n+\n+      if (val & 1)      /* Clear Left */\n+\t{\n+\t  if (val == 1)\n+\t    i = 0;\n+\t  else\n+\t    for (i = 1; i < HOST_BITS_PER_WIDE_INT; i++)\n+\t      if (!((val >>= 1) & 1))\n+\t\tbreak;\n+\n+#if HOST_BITS_PER_INT == 32\n+\tif (GET_CODE (x) == CONST_DOUBLE && i == 32)\n+\t  {\n+\t    val = CONST_DOUBLE_HIGH (x);\n+\n+\t    if (val == 0)\n+\t      --i;\n+\t    else if (val == 1)\n+\t      ;\n+\t    else\n+\t      for (i = 33; i < 64; i++)\n+\t\tif (!((val >>= 1) & 1))\n+\t\t  break;\n+\t  }\n+#endif\n+\t  fprintf (file, \"%d\", 63 - i);\n+\t  return;\n+\t}\n+      else\t/* Clear Right */\n+\t{\n+\t  val = (GET_CODE (x) == CONST_INT ? INTVAL (x) : CONST_DOUBLE_HIGH (x));\n+\n+\t  if (val == (-1 << (HOST_BITS_PER_WIDE_INT-1)))\n+\t    i = 0;\n+\t  else\n+\t    for (i = 1; i < HOST_BITS_PER_WIDE_INT; i++)\n+\t      if ((val <<= 1) < 0)\n+\t\tbreak;\n+\n+#if HOST_BITS_PER_INT == 32\n+\tif (GET_CODE (x) == CONST_DOUBLE && i == 32)\n+\t  {\n+\t    val = CONST_DOUBLE_LOW (x);\n+\n+\t    if (val == 0)\n+\t      --i;\n+\t    else if (val == (-1 << (HOST_BITS_PER_WIDE_INT-1)))\n+\t      ;\n+\t    else\n+\t      for (i = 33; i < 64; i++)\n+\t\tif ((val <<= 1) < 0)\n+\t\t  break;\n+\t  }\n+#endif\n+\t  fprintf (file, \"%d\", i);\n+\t  return;\n+\t}\n+\n     case 't':\n       /* Write 12 if this jump operation will branch if true, 4 otherwise. \n \t All floating-point operations except NE branch true and integer\n@@ -3006,23 +3154,23 @@ rs6000_makes_calls ()\n    sequence and the V.4 calling sequence.\n \n    AIX stack frames look like:\n-\n+\t\t\t\t\t\t\t  32-bit  64-bit\n \tSP---->\t+---------------------------------------+\n-\t\t| back chain to caller\t\t\t| 0\n+\t\t| back chain to caller\t\t\t| 0\t  0\n \t\t+---------------------------------------+\n-\t\t| saved CR\t\t\t\t| 4\n+\t\t| saved CR\t\t\t\t| 4       8 (8-11)\n \t\t+---------------------------------------+\n-\t\t| saved LR\t\t\t\t| 8\n+\t\t| saved LR\t\t\t\t| 8       16\n \t\t+---------------------------------------+\n-\t\t| reserved for compilers\t\t| 12\n+\t\t| reserved for compilers\t\t| 12      24\n \t\t+---------------------------------------+\n-\t\t| reserved for binders\t\t\t| 16\n+\t\t| reserved for binders\t\t\t| 16      32\n \t\t+---------------------------------------+\n-\t\t| saved TOC pointer\t\t\t| 20\n+\t\t| saved TOC pointer\t\t\t| 20      40\n \t\t+---------------------------------------+\n-\t\t| Parameter save area (P)\t\t| 24\n+\t\t| Parameter save area (P)\t\t| 24      48\n \t\t+---------------------------------------+\n-\t\t| Alloca space (A)\t\t\t| 24+P\n+\t\t| Alloca space (A)\t\t\t| 24+P    etc.\n \t\t+---------------------------------------+\n \t\t| Local variable space (L)\t\t| 24+P+A\n \t\t+---------------------------------------+\n@@ -3115,7 +3263,7 @@ rs6000_stack_info ()\n {\n   static rs6000_stack_t info, zero_info;\n   rs6000_stack_t *info_ptr = &info;\n-  int reg_size = TARGET_64BIT ? 8 : 4;\n+  int reg_size = TARGET_32BIT ? 4 : 8;\n   enum rs6000_abi abi;\n   int total_raw_size;\n \n@@ -3257,7 +3405,7 @@ rs6000_stack_info ()\n   else\n     info_ptr->push_p = (frame_pointer_needed\n \t\t\t|| write_symbols != NO_DEBUG\n-\t\t\t|| ((info_ptr->total_size - info_ptr->fixed_size)\n+\t\t\t|| ((total_raw_size - info_ptr->fixed_size)\n \t\t\t    > (TARGET_32BIT ? 220 : 296)));\n \n   /* Calculate the offsets */\n@@ -3272,8 +3420,8 @@ rs6000_stack_info ()\n       info_ptr->fp_save_offset   = - info_ptr->fp_size;\n       info_ptr->gp_save_offset   = info_ptr->fp_save_offset - info_ptr->gp_size;\n       info_ptr->main_save_offset = info_ptr->gp_save_offset - info_ptr->main_size;\n-      info_ptr->cr_save_offset   = 4;\n-      info_ptr->lr_save_offset   = 8;\n+      info_ptr->cr_save_offset   = reg_size; /* first word when 64-bit.  */\n+      info_ptr->lr_save_offset   = 2*reg_size;\n       break;\n \n     case ABI_V4:\n@@ -3287,13 +3435,13 @@ rs6000_stack_info ()\n       break;\n \n     case ABI_NT:\n-      info_ptr->lr_save_offset    = -4;\n+      info_ptr->lr_save_offset    = -reg_size;\n       info_ptr->toc_save_offset   = info_ptr->lr_save_offset - info_ptr->lr_size;\n       info_ptr->cr_save_offset    = info_ptr->toc_save_offset - info_ptr->toc_size;\n       info_ptr->gp_save_offset    = info_ptr->cr_save_offset - info_ptr->cr_size - info_ptr->gp_size + reg_size;\n       info_ptr->fp_save_offset    = info_ptr->gp_save_offset - info_ptr->fp_size;\n       if (info_ptr->fp_size && ((- info_ptr->fp_save_offset) % 8) != 0)\n-\tinfo_ptr->fp_save_offset -= 4;\n+\tinfo_ptr->fp_save_offset -= reg_size;\n \n       info_ptr->main_save_offset = info_ptr->fp_save_offset - info_ptr->main_size;\n       break;\n@@ -3303,9 +3451,9 @@ rs6000_stack_info ()\n     {\n       info_ptr->fpmem_offset = info_ptr->main_save_offset - info_ptr->fpmem_size;\n       rs6000_fpmem_size   = info_ptr->fpmem_size;\n-      rs6000_fpmem_offset = info_ptr->push_p\n-\t  ? info_ptr->total_size + info_ptr->fpmem_offset\n-\t  : info_ptr->fpmem_offset;\n+      rs6000_fpmem_offset = (info_ptr->push_p\n+\t\t\t     ? info_ptr->total_size + info_ptr->fpmem_offset\n+\t\t\t     : info_ptr->fpmem_offset);\n     }\n   else\n     info_ptr->fpmem_offset = 0;  \n@@ -3491,7 +3639,7 @@ rs6000_output_load_toc_table (file, reg)\n \t address before loading.  */\n       if (rs6000_pic_func_labelno != rs6000_pic_labelno)\n \t{\n-\t  char *init_ptr = (TARGET_64BIT) ? \".quad\" : \".long\";\n+\t  char *init_ptr = TARGET_32BIT ? \".long\" : \".quad\";\n \t  char *buf_ptr;\n \n \t  ASM_OUTPUT_INTERNAL_LABEL (file, \"LCL\", rs6000_pic_labelno);\n@@ -3508,26 +3656,14 @@ rs6000_output_load_toc_table (file, reg)\n       fprintf (file, \"\\tmflr %s\\n\", reg_names[reg]);\n \n       if (rs6000_pic_func_labelno != rs6000_pic_labelno)\n-\t{\n-\t  if (TARGET_POWERPC64)\n-\t    fprintf (file, \"\\taddi %s,%s,8\\n\", reg_names[reg], reg_names[reg]);\n-\t  else if (TARGET_NEW_MNEMONICS)\n-\t    fprintf (file, \"\\taddi %s,%s,4\\n\", reg_names[reg], reg_names[reg]);\n-\t  else\n-\t    fprintf (file, \"\\tcal %s,4(%s)\\n\", reg_names[reg], reg_names[reg]);\n-\t}\n+\t  asm_fprintf(file, \"\\t{cal|la} %s,%d(%s)\\n\", reg_names[reg],\n+\t\t      (TARGET_32BIT ? 4 : 8), reg_names[reg]);\n \n-      if (TARGET_POWERPC64)\n-\tfprintf (file, \"\\tld\");\n-      else if (TARGET_NEW_MNEMONICS)\n-\tfprintf (file, \"\\tlwz\");\n-      else\n-\tfprintf (file, \"\\tl\");\n-\n-      fprintf (file, \" %s,(\", reg_names[0]);\n+      asm_fprintf (file, (TARGET_32BIT) ? \"\\t{l|lwz} %s,(\" : \"\\tld %s,(\",\n+\t\t   reg_names[0]);\n       ASM_GENERATE_INTERNAL_LABEL (buf, \"LCL\", rs6000_pic_labelno);\n       assemble_name (file, buf);\n-      fprintf (file, \"-\");\n+      fputs (\"-\", file);\n       ASM_GENERATE_INTERNAL_LABEL (buf, \"LCF\", rs6000_pic_labelno);\n       assemble_name (file, buf);\n       fprintf (file, \")(%s)\\n\", reg_names[reg]);\n@@ -3538,21 +3674,12 @@ rs6000_output_load_toc_table (file, reg)\n   else if (!TARGET_64BIT)\n     {\n       ASM_GENERATE_INTERNAL_LABEL (buf, \"LCTOC\", 1);\n-      asm_fprintf (file, \"\\t{cau|addis} %s,%s,\", reg_names[reg], reg_names[0]);\n+      asm_fprintf (file, \"\\t{liu|lis} %s,\", reg_names[reg]);\n       assemble_name (file, buf);\n       asm_fprintf (file, \"@ha\\n\");\n-      if (TARGET_NEW_MNEMONICS)\n-\t{\n-\t  asm_fprintf (file, \"\\taddi %s,%s,\", reg_names[reg], reg_names[reg]);\n-\t  assemble_name (file, buf);\n-\t  asm_fprintf (file, \"@l\\n\");\n-\t}\n-      else\n-\t{\n-\t  asm_fprintf (file, \"\\tcal %s,\", reg_names[reg]);\n-\t  assemble_name (file, buf);\n-\t  asm_fprintf (file, \"@l(%s)\\n\", reg_names[reg]);\n-\t}\n+      asm_fprintf (file, \"\\t{cal|la} %s,\", reg_names[reg]);\n+      assemble_name (file, buf);\n+      asm_fprintf (file, \"@l(%s)\\n\", reg_names[reg]);\n     }\n   else\n     abort ();\n@@ -3599,12 +3726,8 @@ rs6000_allocate_stack_space (file, size, copy_r12)\n     {\n       fprintf (file, \"\\tmr %s,%s\\n\", reg_names[12], reg_names[1]);\n       if (size < 32767)\n-\t{\n-\t  if (TARGET_NEW_MNEMONICS)\n-\t    fprintf (file, \"\\taddi %s,%s,%d\\n\", reg_names[1], reg_names[1], neg_size);\n-\t  else\n-\t    fprintf (file, \"\\tcal %s,%d(%s)\\n\", reg_names[1], neg_size, reg_names[1]);\n-\t}\n+\tfprintf (file, \"\\t{cal|la} %s,%d(%s)\\n\",\n+\t\t reg_names[1], neg_size, reg_names[1]);\n       else\n \t{\n \t  asm_fprintf (file, \"\\t{liu|lis} %s,%d\\n\\t{oril|ori} %s,%s,%d\\n\",\n@@ -3912,10 +4035,9 @@ output_epilog (file, size)\n \t{\n \t  if (DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_SOLARIS)\n \t    sp_offset = info->total_size;\n-\t  else if (TARGET_NEW_MNEMONICS)\n-\t    asm_fprintf (file, \"\\taddi %s,%s,%d\\n\", reg_names[1], reg_names[1], info->total_size);\n \t  else\n-\t    asm_fprintf (file, \"\\tcal %s,%d(%s)\\n\", reg_names[1], info->total_size, reg_names[1]);\n+\t    asm_fprintf (file, \"\\t{cal|la} %s,%d(%s)\\n\",\n+\t\t\t reg_names[1], info->total_size, reg_names[1]);\n \t}\n \n       /* Get the old lr if we saved it.  */\n@@ -3967,12 +4089,8 @@ output_epilog (file, size)\n \n       /* If this is V.4, unwind the stack pointer after all of the loads have been done */\n       if (sp_offset)\n-\t{\n-\t  if (TARGET_NEW_MNEMONICS)\n-\t    asm_fprintf (file, \"\\taddi %s,%s,%d\\n\", reg_names[1], reg_names[1], sp_offset);\n-\t  else\n-\t    asm_fprintf (file, \"\\tcal %s,%d(%s)\\n\", reg_names[1], sp_offset, reg_names[1]);\n-\t}\n+\tasm_fprintf (file, \"\\t{cal|la} %s,%d(%s)\\n\",\n+\t\t     reg_names[1], sp_offset, reg_names[1]);\n       else if (sp_reg != 1)\n \tasm_fprintf (file, \"\\tmr %s,%s\\n\", reg_names[1], reg_names[sp_reg]);\n \n@@ -4521,25 +4639,15 @@ output_function_profiler (file, labelno)\n \t  fputs (\"\\n\\t.previous\\n\", file);\n \t}\n #endif\n-      else if (TARGET_NEW_MNEMONICS)\n-\t{\n-\t  fprintf (file, \"\\taddis %s,%s,\", reg_names[11], reg_names[11]);\n-\t  assemble_name (file, buf);\n-\t  fprintf (file, \"@ha\\n\");\n-\t  fprintf (file, \"\\tstw %s,4(%s)\\n\", reg_names[0], reg_names[1]);\n-\t  fprintf (file, \"\\taddi %s,%s,\", reg_names[0], reg_names[11]);\n-\t  assemble_name (file, buf);\n-\t  fputs (\"@l\\n\", file);\n-\t}\n       else\n \t{\n-\t  fprintf (file, \"\\tcau %s,%s,\", reg_names[11], reg_names[11]);\n+\t  asm_fprintf (file, \"\\t{liu|lis} %s,\", reg_names[11]);\n \t  assemble_name (file, buf);\n-\t  fprintf (file, \"@ha\\n\");\n-\t  fprintf (file, \"\\tst %s,4(%s)\\n\", reg_names[0], reg_names[1]);\n-\t  fprintf (file, \"\\tcal %s,\", reg_names[11]);\n+\t  asm_fprintf (file, \"@ha\\n\");\n+\t  asm_fprintf (file, \"\\t{st|stw} %s,4(%s)\\n\", reg_names[0], reg_names[1]);\n+\t  asm_fprintf (file, \"\\t{cal|la} %s,\", reg_names[0]);\n \t  assemble_name (file, buf);\n-\t  fprintf (file, \"@l(%s)\\n\", reg_names[11]);\n+\t  asm_fprintf (file, \"@l(%s)\\n\", reg_names[11]);\n \t}\n \n       fprintf (file, \"\\tbl %s\\n\", RS6000_MCOUNT);\n@@ -4585,7 +4693,8 @@ output_function_profiler (file, labelno)\n       ASM_GENERATE_INTERNAL_LABEL (buf, \"LPC\", labelno);\n       asm_fprintf (file, \"\\t{l|lwz} %s,\", reg_names[3]);\n       assemble_name (file, buf);\n-      asm_fprintf (file, \"(%s)\\n\\tbl %s\\n\", reg_names[2], RS6000_MCOUNT);\n+      asm_fprintf (file, \"(%s)\\n\\tbl %s\\n\\t%s\\n\",\n+\t\t   reg_names[2], RS6000_MCOUNT, RS6000_CALL_GLUE);\n \n   /* Restore parameter registers.  */\n \n@@ -5058,7 +5167,7 @@ rs6000_select_section (decl, reloc)\n    call.  For real AIX and NT calling sequences, we also replace the\n    function name with the real name (1 or 2 leading .'s), rather than\n    the function descriptor name.  This saves a lot of overriding code\n-   to readd the prefixes.  */\n+   to read the prefixes.  */\n \n void\n rs6000_encode_section_info (decl)"}, {"sha": "7190de757de40d32a64fb05e454cd2945289a252", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 85, "deletions": 33, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a260abc996f80102ba3820e02f4b281bd9b86a4a/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a260abc996f80102ba3820e02f4b281bd9b86a4a/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=a260abc996f80102ba3820e02f4b281bd9b86a4a", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler, for IBM RS/6000.\n-   Copyright (C) 1992, 93, 94, 95, 96, 97, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1992, 93-7, 1998 Free Software Foundation, Inc.\n    Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu)\n \n This file is part of GNU CC.\n@@ -351,6 +351,8 @@ extern int target_flags;\n   {\"no-powerpc-gpopt\",\t- MASK_PPC_GPOPT},\t\t\t\t\\\n   {\"powerpc-gfxopt\",\tMASK_POWERPC | MASK_PPC_GFXOPT},\t\t\\\n   {\"no-powerpc-gfxopt\",\t- MASK_PPC_GFXOPT},\t\t\t\t\\\n+  {\"powerpc64\",\t\tMASK_POWERPC64},\t\t\t\t\\\n+  {\"no-powerpc64\",\t- MASK_POWERPC64},\t\t\t\t\\\n   {\"new-mnemonics\",\tMASK_NEW_MNEMONICS},\t\t\t\t\\\n   {\"old-mnemonics\",\t-MASK_NEW_MNEMONICS},\t\t\t\t\\\n   {\"full-toc\",\t\t- (MASK_NO_FP_IN_TOC | MASK_NO_SUM_IN_TOC\t\\\n@@ -577,7 +579,7 @@ extern int rs6000_debug_arg;\t\t/* debug argument handling */\n #define PARM_BOUNDARY (TARGET_32BIT ? 32 : 64)\n \n /* Boundary (in *bits*) on which stack pointer should be aligned.  */\n-#define STACK_BOUNDARY 64\n+#define STACK_BOUNDARY (TARGET_32BIT ? 64 : 128)\n \n /* Allocation boundary (in *bits*) for the code of a function.  */\n #define FUNCTION_BOUNDARY 32\n@@ -587,7 +589,10 @@ extern int rs6000_debug_arg;\t\t/* debug argument handling */\n \n /* AIX word-aligns FP doubles but doubleword-aligns 64-bit ints.  */\n #define ADJUST_FIELD_ALIGN(FIELD, COMPUTED) \\\n-  (DECL_MODE (FIELD) != DFmode ? (COMPUTED) : MIN ((COMPUTED), 32))\n+  (TYPE_MODE (TREE_CODE (TREE_TYPE (FIELD)) == ARRAY_TYPE \\\n+\t      ? get_inner_array_type (FIELD) \\\n+\t      : TREE_TYPE (FIELD)) == DFmode \\\n+   ? MIN ((COMPUTED), 32) : (COMPUTED))\n \n /* Alignment of field after `int : 0' in a structure.  */\n #define EMPTY_FIELD_BOUNDARY 32\n@@ -737,8 +742,8 @@ extern int rs6000_debug_arg;\t\t/* debug argument handling */\n    This is ordinarily the length in words of a value of mode MODE\n    but can be less for certain modes in special long registers.\n \n-   On RS/6000, ordinary registers hold 32 bits worth;\n-   a single floating point register holds 64 bits worth.  */\n+   POWER and PowerPC GPRs hold 32 bits worth;\n+   PowerPC64 GPRs and FPRs point register holds 64 bits worth.  */\n \n #define HARD_REGNO_NREGS(REGNO, MODE)\t\t\t\t\t\\\n   (FP_REGNO_P (REGNO) || FPMEM_REGNO_P (REGNO)\t\t\t\t\\\n@@ -1042,7 +1047,7 @@ enum reg_class\n #define CONST_OK_FOR_LETTER_P(VALUE, C)\t\t\t\t\t\\\n    ( (C) == 'I' ? (unsigned HOST_WIDE_INT) ((VALUE) + 0x8000) < 0x10000\t\\\n    : (C) == 'J' ? ((VALUE) & 0xffff) == 0\t\t\t\t\\\n-   : (C) == 'K' ? ((VALUE) & 0xffff0000) == 0\t\t\t\t\\\n+   : (C) == 'K' ? ((VALUE) & (~ (HOST_WIDE_INT) 0xffff)) == 0\t\t\\\n    : (C) == 'L' ? mask_constant (VALUE)\t\t\t\t\t\\\n    : (C) == 'M' ? (VALUE) > 31\t\t\t\t\t\t\\\n    : (C) == 'N' ? exact_log2 (VALUE) >= 0\t\t\t\t\\\n@@ -1068,15 +1073,13 @@ enum reg_class\n \n    'Q' means that is a memory operand that is just an offset from a reg.\n    'R' is for AIX TOC entries.\n-   'S' is for Windows NT SYMBOL_REFs\n-   'T' is for Windows NT LABEL_REFs.\n+   'S' is a constant that can be placed into a 64-bit mask operand\n    'U' is for V.4 small data references.  */\n \n #define EXTRA_CONSTRAINT(OP, C)\t\t\t\t\t\t\\\n   ((C) == 'Q' ? GET_CODE (OP) == MEM && GET_CODE (XEXP (OP, 0)) == REG\t\\\n    : (C) == 'R' ? LEGITIMATE_CONSTANT_POOL_ADDRESS_P (OP)\t\t\\\n-   : (C) == 'S' ? (TARGET_WINDOWS_NT && DEFAULT_ABI == ABI_NT && GET_CODE (OP) == SYMBOL_REF)\\\n-   : (C) == 'T' ? (TARGET_WINDOWS_NT && DEFAULT_ABI == ABI_NT && GET_CODE (OP) == LABEL_REF) \\\n+   : (C) == 'S' ? mask64_operand (OP, VOIDmode)\t\t\t\t\\\n    : (C) == 'U' ? ((DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_SOLARIS) \\\n \t\t   && small_data_operand (OP, GET_MODE (OP)))\t\t\\\n    : 0)\n@@ -1201,7 +1204,7 @@ typedef struct rs6000_stack {\n #define RS6000_SAVE_AREA (TARGET_32BIT ? 24 : 48)\n \n /* Address to save the TOC register */\n-#define RS6000_SAVE_TOC plus_constant (stack_pointer_rtx, 20)\n+#define RS6000_SAVE_TOC plus_constant (stack_pointer_rtx, (TARGET_32BIT ? 20 : 40))\n \n /* Offset & size for fpmem stack locations used for converting between\n    float and integral types.  */\n@@ -1320,6 +1323,11 @@ extern int rs6000_sysv_varargs_p;\n   (TYPE_MODE (TYPE) == BLKmode\t\t\t\t\t\t\\\n    && (DEFAULT_ABI != ABI_SOLARIS || int_size_in_bytes (TYPE) > 8))\n \n+/* Mode of stack savearea.\n+   NONLOCAL needs twice Pmode to maintain both backchain and SP.  */\n+#define STACK_SAVEAREA_MODE(LEVEL)\t\\\n+    (LEVEL == SAVE_NONLOCAL ? (TARGET_32BIT ? DImode : TImode) : Pmode)\n+\n /* Minimum and maximum general purpose registers used to hold arguments.  */\n #define GP_ARG_MIN_REG 3\n #define GP_ARG_MAX_REG 10\n@@ -1723,6 +1731,7 @@ typedef struct rs6000_args\n \n #define LEGITIMATE_CONSTANT_P(X)\t\t\t\t\\\n   (GET_CODE (X) != CONST_DOUBLE || GET_MODE (X) == VOIDmode\t\\\n+   || (TARGET_POWERPC64 && GET_MODE (X) == DImode)\t\t\\\n    || easy_fp_constant (X, GET_MODE (X)))\n \n /* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n@@ -1777,7 +1786,7 @@ typedef struct rs6000_args\n    && CONSTANT_POOL_ADDRESS_P (X)\t\t\t\t\t\\\n    && ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (get_pool_constant (X)))\n \n-/* TARGET_64BIT TOC64 guaranteed to have 64 bit alignment.  */\n+/* AIX64 guaranteed to have 64 bit TOC alignment.  */\n #define LEGITIMATE_CONSTANT_POOL_ADDRESS_P(X)\t\t\t\t\\\n   (LEGITIMATE_CONSTANT_POOL_BASE_P (X)\t\t\t\t\t\\\n    || (TARGET_TOC\t\t\t\t\t\t\t\\\n@@ -1916,6 +1925,46 @@ typedef struct rs6000_args\n     }\t\t\t\t\t\t\t\t\t\\\n }\n \n+/* Try a machine-dependent way of reloading an illegitimate address\n+   operand.  If we find one, push the reload and jump to WIN.  This\n+   macro is used in only one place: `find_reloads_address' in reload.c.\n+\n+   For RS/6000, we wish to handle large displacements off a base\n+   register by splitting the addend across an addiu/addis and the mem insn.\n+   This cuts number of extra insns needed from 3 to 1.  */\n+   \n+#define LEGITIMIZE_RELOAD_ADDRESS(X,MODE,OPNUM,TYPE,IND_LEVELS,WIN)     \\\n+do {                                                                    \\\n+  if (GET_CODE (X) == PLUS                                              \\\n+      && GET_CODE (XEXP (X, 0)) == REG                                  \\\n+      && REGNO (XEXP (X, 0)) < FIRST_PSEUDO_REGISTER                    \\\n+      && REG_MODE_OK_FOR_BASE_P (XEXP (X, 0), MODE)                     \\\n+      && GET_CODE (XEXP (X, 1)) == CONST_INT)                           \\\n+    {                                                                   \\\n+      HOST_WIDE_INT val = INTVAL (XEXP (X, 1));                         \\\n+      HOST_WIDE_INT low = ((val & 0xffff) ^ 0x8000) - 0x8000;           \\\n+      HOST_WIDE_INT high                                                \\\n+        = (((val - low) & 0xffffffff) ^ 0x80000000) - 0x80000000;       \\\n+                                                                        \\\n+      /* Check for 32-bit overflow.  */                                 \\\n+      if (high + low != val)                                            \\\n+        break;                                                          \\\n+                                                                        \\\n+      /* Reload the high part into a base reg; leave the low part       \\\n+         in the mem directly.  */                                       \\\n+                                                                        \\\n+      X = gen_rtx_PLUS (GET_MODE (X),                                   \\\n+                        gen_rtx_PLUS (GET_MODE (X), XEXP (X, 0),        \\\n+                                      GEN_INT (high)),                  \\\n+                        GEN_INT (low));                                 \\\n+                                                                        \\\n+      push_reload (XEXP (X, 0), NULL_RTX, &XEXP (X, 0), NULL_PTR,       \\\n+                   BASE_REG_CLASS, GET_MODE (X), VOIDmode, 0, 0,        \\\n+                   OPNUM, TYPE);                                        \\\n+      goto WIN;                                                         \\\n+    }                                                                   \\\n+} while (0)\n+\n /* Go to LABEL if ADDR (a legitimate address expression)\n    has an effect that depends on the machine mode it is used for.\n \n@@ -2053,10 +2102,9 @@ typedef struct rs6000_args\n #define OBJECT_FORMAT_COFF\n \n /* Define the magic numbers that we recognize as COFF.\n-   AIX 4.3 adds U803XTOCMAGIC (0757) for 64-bit executables, but collect2.c\n-   does not include these files in the right order to conditionally define\n-   the value in the macro.  */\n-\n+   AIX 4.3 adds U803XTOCMAGIC (0757) for 64-bit objects, but collect2.c\n+   does not include files in the correct order to conditionally define\n+   the symbolic name in this macro.  */\n #define MY_ISCOFF(magic) \\\n   ((magic) == U802WRMAGIC || (magic) == U802ROMAGIC \\\n    || (magic) == U802TOCMAGIC || (magic) == 0757)\n@@ -2086,7 +2134,6 @@ typedef struct rs6000_args\n #define Pmode (TARGET_32BIT ? SImode : DImode)\n \n /* Mode of a function address in a call instruction (for indexing purposes).\n-\n    Doesn't matter on RS/6000.  */\n #define FUNCTION_MODE (TARGET_32BIT ? SImode : DImode)\n \n@@ -2131,17 +2178,17 @@ typedef struct rs6000_args\n #define RTX_COSTS(X,CODE,OUTER_CODE)\t\t\t\t\t\\\n   case PLUS:\t\t\t\t\t\t\t\t\\\n     return ((GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\t\\\n-\t     && (unsigned HOST_WIDE_INT) ((INTVAL (XEXP (X, 1))\t\t\\\n-\t\t\t\t\t   + 0x8000) >= 0x10000))\t\\\n+\t     && ((unsigned HOST_WIDE_INT) (INTVAL (XEXP (X, 1))\t\t\\\n+\t\t\t\t\t   + 0x8000) >= 0x10000)\t\\\n+\t     && (INTVAL (XEXP (X, 1)) & 0xffff != 0))\t\t\t\\\n \t    ? COSTS_N_INSNS (2)\t\t\t\t\t\t\\\n \t    : COSTS_N_INSNS (1));\t\t\t\t\t\\\n   case AND:\t\t\t\t\t\t\t\t\\\n-    return ((non_and_cint_operand (XEXP (X, 1), SImode))\t\t\\\n-\t    ? COSTS_N_INSNS (2)\t\t\t\t\t\t\\\n-\t    : COSTS_N_INSNS (1));\t\t\t\t\t\\\n   case IOR:\t\t\t\t\t\t\t\t\\\n   case XOR:\t\t\t\t\t\t\t\t\\\n-    return ((non_logical_cint_operand (XEXP (X, 1), SImode))\t\t\\\n+    return ((GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\t\\\n+\t     && (INTVAL (XEXP (X, 1)) & (~ (HOST_WIDE_INT) 0xffff)) != 0 \\\n+\t     && (INTVAL (XEXP (X, 1)) & 0xffff != 0))\t\t\t\\\n \t    ? COSTS_N_INSNS (2)\t\t\t\t\t\t\\\n \t    : COSTS_N_INSNS (1));\t\t\t\t\t\\\n   case MULT:\t\t\t\t\t\t\t\t\\\n@@ -2307,6 +2354,8 @@ extern int rs6000_trunc_used;\n \t\t\t   main_input_filename, \".ro_\");\t\\\n \t\t\t\t\t\t\t\t\\\n   output_file_directive (FILE, main_input_filename);\t\t\\\n+  if (TARGET_64BIT)\t\t\t\t\t\t\\\n+    fputs (\"\\t.machine\\t\\\"ppc64\\\"\\n\", FILE);\t\t\t\\\n   toc_section ();\t\t\t\t\t\t\\\n   if (write_symbols != NO_DEBUG)\t\t\t\t\\\n     private_data_section ();\t\t\t\t\t\\\n@@ -2469,10 +2518,10 @@ extern int toc_initialized;\n     }\t\t\t\t\t\t\t\t\\\n   fputs (\".csect \", FILE);\t\t\t\t\t\\\n   RS6000_OUTPUT_BASENAME (FILE, NAME);\t\t\t\t\\\n-  fputs (\"[DS]\\n\", FILE);\t\t\t\t\t\\\n+  fputs (TARGET_32BIT ? \"[DS]\\n\" : \"[DS],3\\n\", FILE);\t\t\\\n   RS6000_OUTPUT_BASENAME (FILE, NAME);\t\t\t\t\\\n   fputs (\":\\n\", FILE);\t\t\t\t\t\t\\\n-  fputs ((TARGET_32BIT) ? \"\\t.long .\" : \"\\t.llong .\", FILE);\t\\\n+  fputs (TARGET_32BIT ? \"\\t.long .\" : \"\\t.llong .\", FILE);\t\\\n   RS6000_OUTPUT_BASENAME (FILE, NAME);\t\t\t\t\\\n   fputs (\", TOC[tc0], 0\\n\", FILE);\t\t\t\t\\\n   fputs (\".csect .text[PR]\\n.\", FILE);\t\t\t\t\\\n@@ -2498,8 +2547,11 @@ extern int toc_initialized;\n        || GET_CODE (X) == LABEL_REF\t\t\t\t\t\\\n        || (! (TARGET_NO_FP_IN_TOC && ! TARGET_MINIMAL_TOC)\t\t\\\n \t   && GET_CODE (X) == CONST_DOUBLE\t\t\t\t\\\n-\t   && GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT\t\t\\\n+\t   && (GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT\t\t\\\n+\t       || (TARGET_POWERPC64 && GET_MODE (X) == DImode)))))\n+#if 0\n \t   && BITS_PER_WORD == HOST_BITS_PER_INT)))\n+#endif\n \n /* Select section for constant in constant pool.\n \n@@ -2949,7 +3001,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n #define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)\t\t\\\n   do { char buf[100];\t\t\t\t\t\\\n-       fputs ((TARGET_32BIT) ? \"\\t.long \" : \"\\t.llong \", FILE);\t\\\n+       fputs (TARGET_32BIT ? \"\\t.long \" : \"\\t.llong \", FILE);\t\\\n        ASM_GENERATE_INTERNAL_LABEL (buf, \"L\", VALUE);\t\\\n        assemble_name (FILE, buf);\t\t\t\\\n        putc ('\\n', FILE);\t\t\t\t\\\n@@ -2959,7 +3011,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n #define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)\\\n   do { char buf[100];\t\t\t\t\t\\\n-       fputs ((TARGET_32BIT) ? \"\\t.long \" : \"\\t.llong \", FILE);\t\\\n+       fputs (TARGET_32BIT ? \"\\t.long \" : \"\\t.llong \", FILE);\t\\\n        ASM_GENERATE_INTERNAL_LABEL (buf, \"L\", VALUE);\t\\\n        assemble_name (FILE, buf);\t\t\t\\\n        putc ('-', FILE);\t\t\t\t\\\n@@ -3061,15 +3113,16 @@ do {\t\t\t\t\t\t\t\t\t\\\n   {\"add_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n   {\"non_add_cint_operand\", {CONST_INT}},\t\t\t\\\n   {\"and_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n-  {\"non_and_cint_operand\", {CONST_INT}},\t\t\t\\\n+  {\"and64_operand\", {SUBREG, REG, CONST_INT, CONST_DOUBLE}},\t\\\n   {\"logical_operand\", {SUBREG, REG, CONST_INT}},\t\t\\\n   {\"non_logical_cint_operand\", {CONST_INT}},\t\t\t\\\n   {\"mask_operand\", {CONST_INT}},\t\t\t\t\\\n+  {\"mask64_operand\", {CONST_INT, CONST_DOUBLE}},\t\t\\\n   {\"count_register_operand\", {REG}},\t\t\t\t\\\n   {\"fpmem_operand\", {REG}},\t\t\t\t\t\\\n   {\"call_operand\", {SYMBOL_REF, REG}},\t\t\t\t\\\n   {\"current_file_function_operand\", {SYMBOL_REF}},\t\t\\\n-  {\"input_operand\", {SUBREG, MEM, REG, CONST_INT, SYMBOL_REF}},\t\\\n+  {\"input_operand\", {SUBREG, MEM, REG, CONST_INT, CONST_DOUBLE, SYMBOL_REF}}, \\\n   {\"load_multiple_operation\", {PARALLEL}},\t\t\t\\\n   {\"store_multiple_operation\", {PARALLEL}},\t\t\t\\\n   {\"branch_comparison_operator\", {EQ, NE, LE, LT, GE,\t\t\\\n@@ -3098,7 +3151,6 @@ extern void output_options ();\n extern void rs6000_override_options ();\n extern void rs6000_file_start ();\n extern struct rtx_def *rs6000_float_const ();\n-extern struct rtx_def *rs6000_immed_double_const ();\n extern struct rtx_def *rs6000_got_register ();\n extern int direct_return ();\n extern int get_issue_rate ();\n@@ -3123,13 +3175,13 @@ extern int add_operand ();\n extern int non_add_cint_operand ();\n extern int non_logical_cint_operand ();\n extern int logical_operand ();\n-extern int non_logical_operand ();\n extern int mask_constant ();\n extern int mask_operand ();\n+extern int mask64_operand ();\n+extern int and64_operand ();\n extern int and_operand ();\n extern int count_register_operand ();\n extern int fpmem_operand ();\n-extern int non_and_cint_operand ();\n extern int reg_or_mem_operand ();\n extern int lwa_operand ();\n extern int call_operand ();"}, {"sha": "61398db34b2ce6936adea91fb62bc0ebee1d4bf9", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 813, "deletions": 283, "changes": 1096, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a260abc996f80102ba3820e02f4b281bd9b86a4a/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a260abc996f80102ba3820e02f4b281bd9b86a4a/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=a260abc996f80102ba3820e02f4b281bd9b86a4a", "patch": "@@ -1,5 +1,5 @@\n ;; Machine description for IBM RISC System 6000 (POWER) for GNU C compiler\n-;; Copyright (C) 1990, 91-96, 1997, 1998 Free Software Foundation, Inc.\n+;; Copyright (C) 1990, 91-97, 1998 Free Software Foundation, Inc.\n ;; Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu)\n \n ;; This file is part of GNU CC.\n@@ -1761,8 +1761,9 @@\n \t\t  || rtx_equal_p (operands[0], operands[1]))\n \t\t ? operands[0] : gen_reg_rtx (SImode));\n \n-      emit_insn (gen_iorsi3 (tmp, operands[1], GEN_INT (value & 0xffff0000)));\n-      emit_insn (gen_iorsi3 (operands[0], tmp, GEN_INT (value & 0x0000ffff)));\n+      emit_insn (gen_iorsi3 (tmp, operands[1],\n+\t\t\t     GEN_INT (value & (~ (HOST_WIDE_INT) 0xffff))));\n+      emit_insn (gen_iorsi3 (operands[0], tmp, GEN_INT (value & 0xffff)));\n       DONE;\n     }\n }\")\n@@ -1799,6 +1800,22 @@\n   \"or. %0,%1,%2\"\n   [(set_attr \"type\" \"compare\")])\n \n+;; Split an IOR that we can't do in one insn into two insns, each of which\n+;; does one 16-bit part.  This is used by combine.\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n+\t(ior:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\")\n+\t\t(match_operand:SI 2 \"non_logical_cint_operand\" \"\")))]\n+  \"\"\n+  [(set (match_dup 0) (ior:SI (match_dup 1) (match_dup 3)))\n+   (set (match_dup 0) (ior:SI (match_dup 0) (match_dup 4)))]\n+\"\n+{\n+  operands[3] = GEN_INT (INTVAL (operands[2]) & (~ (HOST_WIDE_INT) 0xffff));\n+  operands[4] = GEN_INT (INTVAL (operands[2]) & 0xffff);\n+}\")\n+\n (define_expand \"xorsi3\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n \t(xor:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\")\n@@ -1814,8 +1831,9 @@\n \t\t  || rtx_equal_p (operands[0], operands[1]))\n \t\t ? operands[0] : gen_reg_rtx (SImode));\n \n-      emit_insn (gen_xorsi3 (tmp, operands[1], GEN_INT (value & 0xffff0000)));\n-      emit_insn (gen_xorsi3 (operands[0], tmp, GEN_INT (value & 0x0000ffff)));\n+      emit_insn (gen_xorsi3 (tmp, operands[1],\n+\t\t\t     GEN_INT (value & (~ (HOST_WIDE_INT) 0xffff))));\n+      emit_insn (gen_xorsi3 (operands[0], tmp, GEN_INT (value & 0xffff)));\n       DONE;\n     }\n }\")\n@@ -1852,14 +1870,30 @@\n   \"xor. %0,%1,%2\"\n   [(set_attr \"type\" \"compare\")])\n \n-(define_insn \"*eqv_internal1\"\n+;; Split an XOR that we can't do in one insn into two insns, each of which\n+;; does one 16-bit part.  This is used by combine.\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n+        (xor:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\")\n+                (match_operand:SI 2 \"non_logical_cint_operand\" \"\")))]\n+  \"\"\n+  [(set (match_dup 0) (xor:SI (match_dup 1) (match_dup 3)))\n+   (set (match_dup 0) (xor:SI (match_dup 0) (match_dup 4)))]\n+\"\n+{\n+  operands[3] = GEN_INT (INTVAL (operands[2]) & (~ (HOST_WIDE_INT) 0xffff));\n+  operands[4] = GEN_INT (INTVAL (operands[2]) & 0xffff);\n+}\")\n+\n+(define_insn \"*eqvsi3_internal1\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n \t(not:SI (xor:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r\")\n \t\t\t(match_operand:SI 2 \"gpc_reg_operand\" \"r\"))))]\n    \"\"\n    \"eqv %0,%1,%2\")\n \n-(define_insn \"*eqv_internal2\"\n+(define_insn \"*eqvsi3_internal2\"\n   [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x\")\n \t(compare:CC (not:SI (xor:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r\")\n \t\t\t\t    (match_operand:SI 2 \"gpc_reg_operand\" \"r\")))\n@@ -1869,7 +1903,7 @@\n    \"eqv. %3,%1,%2\"\n    [(set_attr \"type\" \"compare\")])\n \n-(define_insn \"*eqv_internal3\"\n+(define_insn \"*eqvsi3_internal3\"\n   [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x\")\n \t(compare:CC (not:SI (xor:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r\")\n \t\t\t\t    (match_operand:SI 2 \"gpc_reg_operand\" \"r\")))\n@@ -1880,14 +1914,14 @@\n    \"eqv. %0,%1,%2\"\n    [(set_attr \"type\" \"compare\")])\n \n-(define_insn \"*andc_internal1\"\n+(define_insn \"*andcsi3_internal1\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n \t(and:SI (not:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r\"))\n \t\t(match_operand:SI 2 \"gpc_reg_operand\" \"r\")))]\n   \"\"\n   \"andc %0,%2,%1\")\n \n-(define_insn \"*andc_internal2\"\n+(define_insn \"*andcsi3_internal2\"\n   [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x\")\n \t(compare:CC (and:SI (not:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r\"))\n \t\t\t    (match_operand:SI 2 \"gpc_reg_operand\" \"r\"))\n@@ -1897,7 +1931,7 @@\n   \"andc. %3,%2,%1\"\n   [(set_attr \"type\" \"compare\")])\n \n-(define_insn \"*andc_internal3\"\n+(define_insn \"*andcsi3_internal3\"\n   [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x\")\n \t(compare:CC (and:SI (not:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r\"))\n \t\t\t    (match_operand:SI 2 \"gpc_reg_operand\" \"r\"))\n@@ -1908,14 +1942,14 @@\n   \"andc. %0,%2,%1\"\n   [(set_attr \"type\" \"compare\")])\n \n-(define_insn \"*iorc_internal1\"\n+(define_insn \"*iorcsi3_internal1\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n \t(ior:SI (not:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r\"))\n \t\t(match_operand:SI 2 \"gpc_reg_operand\" \"r\")))]\n   \"\"\n   \"orc %0,%2,%1\")\n \n-(define_insn \"*iorc_internal2\"\n+(define_insn \"*iorcsi3_internal2\"\n   [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x\")\n \t(compare:CC (ior:SI (not:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r\"))\n \t\t\t    (match_operand:SI 2 \"gpc_reg_operand\" \"r\"))\n@@ -1925,7 +1959,7 @@\n   \"orc. %3,%2,%1\"\n   [(set_attr \"type\" \"compare\")])\n \n-(define_insn \"*iorc_internal3\"\n+(define_insn \"*iorcsi3_internal3\"\n   [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x\")\n \t(compare:CC (ior:SI (not:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r\"))\n \t\t\t    (match_operand:SI 2 \"gpc_reg_operand\" \"r\"))\n@@ -1936,14 +1970,14 @@\n   \"orc. %0,%2,%1\"\n   [(set_attr \"type\" \"compare\")])\n \n-(define_insn \"*nand_internal1\"\n+(define_insn \"*nandsi3_internal1\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n \t(ior:SI (not:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r\"))\n \t\t(not:SI (match_operand:SI 2 \"gpc_reg_operand\" \"r\"))))]\n   \"\"\n   \"nand %0,%1,%2\")\n \n-(define_insn \"*nand_internal2\"\n+(define_insn \"*nandsi3_internal2\"\n   [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x\")\n \t(compare:CC (ior:SI (not:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r\"))\n \t\t\t    (not:SI (match_operand:SI 2 \"gpc_reg_operand\" \"r\")))\n@@ -1953,7 +1987,7 @@\n   \"nand. %3,%1,%2\"\n   [(set_attr \"type\" \"compare\")])\n \n-(define_insn \"*nand_internal3\"\n+(define_insn \"*nandsi3_internal3\"\n   [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x\")\n \t(compare:CC (ior:SI (not:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r\"))\n \t\t\t    (not:SI (match_operand:SI 2 \"gpc_reg_operand\" \"r\")))\n@@ -1964,14 +1998,14 @@\n   \"nand. %0,%1,%2\"\n   [(set_attr \"type\" \"compare\")])\n \n-(define_insn \"*nor_internal1\"\n+(define_insn \"*norsi3_internal1\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n \t(and:SI (not:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r\"))\n \t\t(not:SI (match_operand:SI 2 \"gpc_reg_operand\" \"r\"))))]\n   \"\"\n   \"nor %0,%1,%2\")\n \n-(define_insn \"*nor_internal2\"\n+(define_insn \"*norsi3_internal2\"\n   [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x\")\n \t(compare:CC (and:SI (not:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r\"))\n \t\t\t    (not:SI (match_operand:SI 2 \"gpc_reg_operand\" \"r\")))\n@@ -1981,7 +2015,7 @@\n   \"nor. %3,%1,%2\"\n   [(set_attr \"type\" \"compare\")])\n \n-(define_insn \"*nor_internal3\"\n+(define_insn \"*norsi3_internal3\"\n   [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x\")\n \t(compare:CC (and:SI (not:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r\"))\n \t\t\t    (not:SI (match_operand:SI 2 \"gpc_reg_operand\" \"r\")))\n@@ -2384,7 +2418,7 @@\n   \"\"\n   \"{rl%I2nm|rlw%I2nm} %0,%1,%h2,0xffffffff\")\n \n-(define_insn \"\"\n+(define_insn \"*rotlsi3_internal2\"\n   [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x\")\n \t(compare:CC (rotate:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n \t\t\t       (match_operand:SI 2 \"reg_or_cint_operand\" \"ri\"))\n@@ -2394,7 +2428,7 @@\n   \"{rl%I2nm.|rlw%I2nm.} %3,%1,%h2,0xffffffff\"\n   [(set_attr \"type\" \"delayed_compare\")])\n \n-(define_insn \"\"\n+(define_insn \"*rotlsi3_internal3\"\n   [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x\")\n \t(compare:CC (rotate:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n \t\t\t       (match_operand:SI 2 \"reg_or_cint_operand\" \"ri\"))\n@@ -2405,15 +2439,15 @@\n   \"{rl%I2nm.|rlw%I2nm.} %0,%1,%h2,0xffffffff\"\n   [(set_attr \"type\" \"delayed_compare\")])\n \n-(define_insn \"\"\n+(define_insn \"*rotlsi3_internal4\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n \t(and:SI (rotate:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n \t\t\t   (match_operand:SI 2 \"reg_or_cint_operand\" \"ri\"))\n \t\t(match_operand:SI 3 \"mask_operand\" \"L\")))]\n   \"\"\n   \"{rl%I2nm|rlw%I2nm} %0,%1,%h2,%m3,%M3\")\n \n-(define_insn \"\"\n+(define_insn \"*rotlsi3_internal5\"\n   [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x\")\n \t(compare:CC (and:SI\n \t\t     (rotate:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n@@ -2425,7 +2459,7 @@\n   \"{rl%I2nm.|rlw%I2nm.} %4,%1,%h2,%m3,%M3\"\n   [(set_attr \"type\" \"delayed_compare\")])\n \n-(define_insn \"\"\n+(define_insn \"*rotlsi3_internal6\"\n   [(set (match_operand:CC 4 \"cc_reg_operand\" \"=x\")\n \t(compare:CC (and:SI\n \t\t     (rotate:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n@@ -2438,7 +2472,7 @@\n   \"{rl%I2nm.|rlw%I2nm.} %0,%1,%h2,%m3,%M3\"\n   [(set_attr \"type\" \"delayed_compare\")])\n \n-(define_insn \"\"\n+(define_insn \"*rotlsi3_internal7\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n \t(zero_extend:SI\n \t (subreg:QI\n@@ -2447,7 +2481,7 @@\n   \"\"\n   \"{rl%I2nm|rlw%I2nm} %0,%1,%h2,0xff\")\n \n-(define_insn \"\"\n+(define_insn \"*rotlsi3_internal8\"\n   [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x\")\n \t(compare:CC (zero_extend:SI\n \t\t     (subreg:QI\n@@ -2459,7 +2493,7 @@\n   \"{rl%I2nm.|rlw%I2nm.} %3,%1,%h2,0xff\"\n   [(set_attr \"type\" \"delayed_compare\")])\n \n-(define_insn \"\"\n+(define_insn \"*rotlsi3_internal9\"\n   [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x\")\n \t(compare:CC (zero_extend:SI\n \t\t     (subreg:QI\n@@ -2472,7 +2506,7 @@\n   \"{rl%I2nm.|rlw%I2nm.} %0,%1,%h2,0xff\"\n   [(set_attr \"type\" \"delayed_compare\")])\n \n-(define_insn \"\"\n+(define_insn \"*rotlsi3_internal10\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n \t(zero_extend:SI\n \t (subreg:HI\n@@ -2481,7 +2515,7 @@\n   \"\"\n   \"{rl%I2nm|rlw%I2nm} %0,%1,%h2,0xffff\")\n \n-(define_insn \"\"\n+(define_insn \"*rotlsi3_internal11\"\n   [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x\")\n \t(compare:CC (zero_extend:SI\n \t\t     (subreg:HI\n@@ -2493,7 +2527,7 @@\n   \"{rl%I2nm.|rlw%I2nm.} %3,%1,%h2,0xffff\"\n   [(set_attr \"type\" \"delayed_compare\")])\n \n-(define_insn \"\"\n+(define_insn \"*rotlsi3_internal12\"\n   [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x\")\n \t(compare:CC (zero_extend:SI\n \t\t     (subreg:HI\n@@ -3580,7 +3614,7 @@\n \t      (clobber (match_dup 4))\n \t      (clobber (match_dup 5))\n \t      (clobber (reg:DF 76))])]\n-  \"! TARGET_POWERPC64 && TARGET_HARD_FLOAT\"\n+  \"TARGET_HARD_FLOAT\"\n   \"\n {\n   operands[2] = force_reg (SImode, GEN_INT (0x43300000));\n@@ -3595,9 +3629,9 @@\n    (use (match_operand:SI 2 \"gpc_reg_operand\" \"r\"))\n    (use (match_operand:DF 3 \"gpc_reg_operand\" \"f\"))\n    (clobber (match_operand:SI 4 \"gpc_reg_operand\" \"=r\"))\n-   (clobber (match_operand:SI 5 \"gpc_reg_operand\" \"=b\"))\n+   (clobber (match_operand 5 \"gpc_reg_operand\" \"=b\"))\n    (clobber (reg:DF 76))]\n-  \"! TARGET_POWERPC64 && TARGET_HARD_FLOAT\"\n+  \"TARGET_HARD_FLOAT\"\n   \"#\"\n   [(set_attr \"length\" \"24\")])\n \n@@ -3607,9 +3641,9 @@\n    (use (match_operand:SI 2 \"gpc_reg_operand\" \"\"))\n    (use (match_operand:DF 3 \"gpc_reg_operand\" \"\"))\n    (clobber (match_operand:SI 4 \"gpc_reg_operand\" \"\"))\n-   (clobber (match_operand:SI 5 \"gpc_reg_operand\" \"\"))\n+   (clobber (match_operand 5 \"gpc_reg_operand\" \"\"))\n    (clobber (reg:DF 76))]\n-  \"! TARGET_POWERPC64 && TARGET_HARD_FLOAT\"\n+  \"TARGET_HARD_FLOAT\"\n   [(set (match_dup 4)\n \t(xor:SI (match_dup 1)\n \t\t(match_dup 6)))\n@@ -3641,7 +3675,7 @@\n \t      (use (match_dup 3))\n \t      (clobber (match_dup 4))\n \t      (clobber (reg:DF 76))])]\n-  \"! TARGET_POWERPC64 && TARGET_HARD_FLOAT\"\n+  \"TARGET_HARD_FLOAT\"\n   \"\n {\n   operands[2] = force_reg (SImode, GEN_INT (0x43300000));\n@@ -3654,9 +3688,9 @@\n \t(unsigned_float:DF (match_operand:SI 1 \"gpc_reg_operand\" \"r\")))\n    (use (match_operand:SI 2 \"gpc_reg_operand\" \"r\"))\n    (use (match_operand:DF 3 \"gpc_reg_operand\" \"f\"))\n-   (clobber (match_operand:SI 4 \"gpc_reg_operand\" \"=b\"))\n+   (clobber (match_operand 4 \"gpc_reg_operand\" \"=b\"))\n    (clobber (reg:DF 76))]\n-  \"! TARGET_POWERPC64 && TARGET_HARD_FLOAT\"\n+  \"TARGET_HARD_FLOAT\"\n   \"#\"\n   [(set_attr \"length\" \"20\")])\n \n@@ -3665,9 +3699,9 @@\n \t(unsigned_float:DF (match_operand:SI 1 \"gpc_reg_operand\" \"\")))\n    (use (match_operand:SI 2 \"gpc_reg_operand\" \"\"))\n    (use (match_operand:DF 3 \"gpc_reg_operand\" \"\"))\n-   (clobber (match_operand:SI 4 \"gpc_reg_operand\" \"=b\"))\n+   (clobber (match_operand 4 \"gpc_reg_operand\" \"=b\"))\n    (clobber (reg:DF 76))]\n-  \"! TARGET_POWERPC64 && TARGET_HARD_FLOAT\"\n+  \"TARGET_HARD_FLOAT\"\n   [(set (match_dup 4)\n \t(unspec [(const_int 0)] 11))\n    (set (match_dup 5)\n@@ -3687,7 +3721,7 @@\n \n ;; Load up scratch register with base address + offset if needed\n (define_insn \"*floatsidf2_loadaddr\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=b\")\n+  [(set (match_operand 0 \"gpc_reg_operand\" \"=b\")\n \t(unspec [(const_int 0)] 11))]\n   \"TARGET_HARD_FLOAT\"\n   \"*\n@@ -3709,8 +3743,8 @@\n (define_insn \"*floatsidf2_store1\"\n   [(set (reg:DF 76)\n \t(unspec [(match_operand:SI 0 \"gpc_reg_operand\" \"r\")\n-\t\t (match_operand:SI 1 \"gpc_reg_operand\" \"r\")] 12))]\n-  \"! TARGET_POWERPC64 && TARGET_HARD_FLOAT\"\n+\t\t (match_operand 1 \"gpc_reg_operand\" \"b\")] 12))]\n+  \"TARGET_HARD_FLOAT\"\n   \"*\n {\n   rtx indx;\n@@ -3735,9 +3769,9 @@\n (define_insn \"*floatsidf2_store2\"\n   [(set (reg:DF 76)\n \t(unspec [(match_operand:SI 0 \"gpc_reg_operand\" \"r\")\n-\t\t (match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n+\t\t (match_operand 1 \"gpc_reg_operand\" \"b\")\n \t\t (reg:DF 76)] 13))]\n-  \"! TARGET_POWERPC64 && TARGET_HARD_FLOAT\"\n+  \"TARGET_HARD_FLOAT\"\n   \"*\n {\n   rtx indx;\n@@ -3762,8 +3796,8 @@\n (define_insn \"*floatsidf2_load\"\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=f\")\n \t(unspec [(reg:DF 76)\n-\t\t (match_operand:SI 1 \"gpc_reg_operand\" \"b\")] 14))]\n-  \"! TARGET_POWERPC64 && TARGET_HARD_FLOAT\"\n+\t\t (match_operand 1 \"gpc_reg_operand\" \"b\")] 14))]\n+  \"TARGET_HARD_FLOAT\"\n   \"*\n {\n   rtx indx;\n@@ -3811,7 +3845,7 @@\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n \t(fix:SI (match_operand:DF 1 \"gpc_reg_operand\" \"f\")))\n    (clobber (match_operand:DI 2 \"gpc_reg_operand\" \"=f\"))\n-   (clobber (match_operand:SI 3 \"gpc_reg_operand\" \"=b\"))\n+   (clobber (match_operand 3 \"gpc_reg_operand\" \"=b\"))\n    (clobber (reg:DI 76))]\n   \"TARGET_HARD_FLOAT\"\n   \"#\"\n@@ -3821,7 +3855,7 @@\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n \t(fix:SI (match_operand:DF 1 \"gpc_reg_operand\" \"f\")))\n    (clobber (match_operand:DI 2 \"gpc_reg_operand\" \"\"))\n-   (clobber (match_operand:SI 3 \"gpc_reg_operand\" \"\"))\n+   (clobber (match_operand 3 \"gpc_reg_operand\" \"\"))\n    (clobber (reg:DI 76))]\n   \"TARGET_HARD_FLOAT\"\n   [(set (match_dup 2)\n@@ -3836,17 +3870,10 @@\n \t\t (match_dup 3)] 16))]\n   \"operands[4] = gen_rtx (REG, DImode, FPMEM_REGNUM);\")\n \n-(define_insn \"*fctiwz\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=f\")\n-\t(sign_extend:DI (fix:SI (match_operand:DF 1 \"gpc_reg_operand\" \"f\"))))]\n-  \"(TARGET_POWER2 || TARGET_POWERPC) && TARGET_HARD_FLOAT\"\n-  \"{fcirz|fctiwz} %0,%1\"\n-  [(set_attr \"type\" \"fp\")])\n-\n (define_insn \"*fix_truncdfsi2_store\"\n   [(set (reg:DI 76)\n \t(unspec [(match_operand:DI 0 \"gpc_reg_operand\" \"f\")\n-\t\t (match_operand:SI 1 \"gpc_reg_operand\" \"b\")] 15))]\n+\t\t (match_operand 1 \"gpc_reg_operand\" \"b\")] 15))]\n   \"(TARGET_POWER2 || TARGET_POWERPC) && TARGET_HARD_FLOAT\"\n   \"*\n {\n@@ -3872,7 +3899,7 @@\n (define_insn \"*fix_truncdfsi2_load\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n \t(unspec [(reg:DI 76)\n-\t\t (match_operand:SI 1 \"gpc_reg_operand\" \"b\")] 16))]\n+\t\t (match_operand 1 \"gpc_reg_operand\" \"b\")] 16))]\n   \"(TARGET_POWER2 || TARGET_POWERPC) && TARGET_HARD_FLOAT\"\n   \"*\n {\n@@ -3940,6 +3967,13 @@\n   rs6000_trunc_used = 1;\n }\")\n \n+(define_insn \"*fctiwz\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=f\")\n+\t(sign_extend:DI (fix:SI (match_operand:DF 1 \"gpc_reg_operand\" \"f\"))))]\n+  \"(TARGET_POWER2 || TARGET_POWERPC) && TARGET_HARD_FLOAT\"\n+  \"{fcirz|fctiwz} %0,%1\"\n+  [(set_attr \"type\" \"fp\")])\n+\n (define_insn \"floatdidf2\"\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=f\")\n \t(float:DF (match_operand:DI 1 \"gpc_reg_operand\" \"f\")))]\n@@ -4286,18 +4320,39 @@\n (define_expand \"adddi3\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n \t(plus:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n-\t\t (match_operand:DI 2 \"add_operand\" \"\")))]\n+\t\t (match_operand:DI 2 \"reg_or_cint_operand\" \"\")))]\n   \"\"\n   \"\n {\n-  if (! TARGET_POWERPC64 && non_short_cint_operand (operands[2], DImode))\n-    FAIL;\n+  if (! TARGET_POWERPC64)\n+    {\n+      if (non_short_cint_operand (operands[2], DImode))\n+\tFAIL;\n+    }\n+  else\n+    if (GET_CODE (operands[2]) == CONST_INT\n+\t&& !add_operand (operands[2], DImode))\n+      {\n+\trtx tmp = ((reload_in_progress || reload_completed\n+\t\t    || rtx_equal_p (operands[0], operands[1]))\n+\t\t   ? operands[0] : gen_reg_rtx (DImode));\n+\n+\tHOST_WIDE_INT low = INTVAL (operands[2]) & 0xffff;\n+\tHOST_WIDE_INT high = INTVAL (operands[2]) & (~ (HOST_WIDE_INT) 0xffff);\n+\n+\tif (low & 0x8000)\n+\t  high += 0x10000, low |= ((HOST_WIDE_INT) -1) << 16;\n+\n+\temit_insn (gen_adddi3 (tmp, operands[1], GEN_INT (high)));\n+\temit_insn (gen_adddi3 (operands[0], tmp, GEN_INT (low)));\n+\tDONE;\n+      }\n }\")\n \n ;; Discourage ai/addic because of carry but provide it in an alternative\n ;; allowing register zero as source.\n \n-(define_insn \"\"\n+(define_insn \"*adddi3_internal1\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r,?r,r\")\n \t(plus:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r,b,r,b\")\n \t\t (match_operand:DI 2 \"add_operand\" \"r,I,I,J\")))]\n@@ -4308,7 +4363,7 @@\n    addic %0,%1,%2\n    addis %0,%1,%v2\")\n \n-(define_insn \"\"\n+(define_insn \"*adddi3_internal2\"\n   [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x,x\")\n \t(compare:CC (plus:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r,r\")\n \t\t\t     (match_operand:DI 2 \"reg_or_short_operand\" \"r,I\"))\n@@ -4320,7 +4375,7 @@\n    addic. %3,%1,%2\"\n   [(set_attr \"type\" \"compare\")])\n \n-(define_insn \"\"\n+(define_insn \"*adddi3_internal3\"\n   [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,x\")\n \t(compare:CC (plus:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r,r\")\n \t\t\t     (match_operand:DI 2 \"reg_or_short_operand\" \"r,I\"))\n@@ -4431,15 +4486,15 @@\n \t(abs:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r,0\")))\n    (clobber (match_scratch:DI 2 \"=&r,&r\"))]\n   \"TARGET_POWERPC64\"\n-  \"sradi %2,%1,31\\;xor %0,%2,%1\\;subf %0,%2,%0\"\n+  \"sradi %2,%1,63\\;xor %0,%2,%1\\;subf %0,%2,%0\"\n   [(set_attr \"length\" \"12\")])\n \n (define_split\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=&r,r\")\n \t(abs:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r,0\")))\n    (clobber (match_scratch:DI 2 \"=&r,&r\"))]\n   \"TARGET_POWERPC64 && reload_completed\"\n-  [(set (match_dup 2) (ashiftrt:DI (match_dup 1) (const_int 31)))\n+  [(set (match_dup 2) (ashiftrt:DI (match_dup 1) (const_int 63)))\n    (set (match_dup 0) (xor:DI (match_dup 2) (match_dup 1)))\n    (set (match_dup 0) (minus:DI (match_dup 2) (match_dup 0)))]\n   \"\")\n@@ -4449,15 +4504,15 @@\n \t(neg:DI (abs:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r,0\"))))\n    (clobber (match_scratch:DI 2 \"=&r,&r\"))]\n   \"TARGET_POWERPC64\"\n-  \"sradi %2,%1,31\\;xor %0,%2,%1\\;subf %0,%0,%2\"\n+  \"sradi %2,%1,63\\;xor %0,%2,%1\\;subf %0,%0,%2\"\n   [(set_attr \"length\" \"12\")])\n \n (define_split\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=&r,r\")\n \t(neg:DI (abs:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r,0\"))))\n    (clobber (match_scratch:DI 2 \"=&r,&r\"))]\n   \"TARGET_POWERPC64 && reload_completed\"\n-  [(set (match_dup 2) (ashiftrt:DI (match_dup 1) (const_int 31)))\n+  [(set (match_dup 2) (ashiftrt:DI (match_dup 1) (const_int 63)))\n    (set (match_dup 0) (xor:DI (match_dup 2) (match_dup 1)))\n    (set (match_dup 0) (minus:DI (match_dup 0) (match_dup 2)))]\n   \"\")\n@@ -4508,6 +4563,14 @@\n   \"mulld %0,%1,%2\"\n    [(set_attr \"type\" \"imul\")])\n \n+(define_insn \"*mulsidi3_ppc64\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n+\t(mult:DI (sign_extend:DI (match_operand:SI 1 \"gpc_reg_operand\" \"%r\"))\n+\t\t (sign_extend:DI (match_operand:SI 2 \"gpc_reg_operand\" \"r\"))))]\n+  \"TARGET_POWERPC64\"\n+  \"mulld %0,%1,%2\"\n+  [(set_attr \"type\" \"imul\")])\n+\n (define_insn \"smuldi3_highpart\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n \t(truncate:DI\n@@ -4603,7 +4666,7 @@\n (define_insn \"\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n         (div:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n-                 (match_operand:DI 2 \"gpc_reg_operand\" \"r\")))]\n+                (match_operand:DI 2 \"gpc_reg_operand\" \"r\")))]\n   \"TARGET_POWERPC64\"\n   \"divd %0,%1,%2\"\n   [(set_attr \"type\" \"idiv\")])\n@@ -4623,7 +4686,7 @@\n   \"TARGET_POWERPC64\"\n   \"rld%I2cl %0,%1,%H2,0\")\n \n-(define_insn \"\"\n+(define_insn \"*rotldi3_internal2\"\n   [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x\")\n \t(compare:CC (rotate:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n \t\t\t       (match_operand:DI 2 \"reg_or_cint_operand\" \"ri\"))\n@@ -4633,7 +4696,7 @@\n   \"rld%I2cl. %3,%1,%H2,0\"\n   [(set_attr \"type\" \"delayed_compare\")])\n \n-(define_insn \"\"\n+(define_insn \"*rotldi3_internal3\"\n   [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x\")\n \t(compare:CC (rotate:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n \t\t\t       (match_operand:DI 2 \"reg_or_cint_operand\" \"ri\"))\n@@ -4644,6 +4707,141 @@\n   \"rld%I2cl. %0,%1,%H2,0\"\n   [(set_attr \"type\" \"delayed_compare\")])\n \n+(define_insn \"*rotldi3_internal4\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n+\t(and:DI (rotate:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n+\t\t\t   (match_operand:DI 2 \"reg_or_cint_operand\" \"ri\"))\n+\t\t(match_operand:DI 3 \"mask64_operand\" \"S\")))]\n+  \"TARGET_POWERPC64\"\n+  \"rld%I2c%B3 %0,%1,%H2,%S3\")\n+\n+(define_insn \"*rotldi3_internal5\"\n+  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x\")\n+\t(compare:CC (and:DI\n+\t\t     (rotate:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n+\t\t\t\t(match_operand:DI 2 \"reg_or_cint_operand\" \"ri\"))\n+\t\t     (match_operand:DI 3 \"mask64_operand\" \"S\"))\n+\t\t    (const_int 0)))\n+   (clobber (match_scratch:DI 4 \"=r\"))]\n+  \"TARGET_POWERPC64\"\n+  \"rld%I2c%B3. %4,%1,%H2,%S3\"\n+  [(set_attr \"type\" \"delayed_compare\")])\n+\n+(define_insn \"*rotldi3_internal6\"\n+  [(set (match_operand:CC 4 \"cc_reg_operand\" \"=x\")\n+\t(compare:CC (and:DI\n+\t\t     (rotate:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n+\t\t\t\t(match_operand:DI 2 \"reg_or_cint_operand\" \"ri\"))\n+\t\t     (match_operand:DI 3 \"mask64_operand\" \"S\"))\n+\t\t    (const_int 0)))\n+   (set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n+\t(and:DI (rotate:DI (match_dup 1) (match_dup 2)) (match_dup 3)))]\n+  \"TARGET_POWERPC64\"\n+  \"rld%I2c%B3. %0,%1,%H2,%S3\"\n+  [(set_attr \"type\" \"delayed_compare\")])\n+\n+(define_insn \"*rotldi3_internal7\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n+\t(zero_extend:DI\n+\t (subreg:QI\n+\t  (rotate:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n+\t\t     (match_operand:DI 2 \"reg_or_cint_operand\" \"ri\")) 0)))]\n+  \"TARGET_POWERPC64\"\n+  \"rld%I2cl %0,%1,%H2,56\")\n+\n+(define_insn \"*rotldi3_internal8\"\n+  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x\")\n+\t(compare:CC (zero_extend:DI\n+\t\t     (subreg:QI\n+\t\t      (rotate:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n+\t\t\t\t (match_operand:DI 2 \"reg_or_cint_operand\" \"ri\")) 0))\n+\t\t    (const_int 0)))\n+   (clobber (match_scratch:DI 3 \"=r\"))]\n+  \"TARGET_POWERPC64\"\n+  \"rld%I2cl. %3,%1,%H2,56\"\n+  [(set_attr \"type\" \"delayed_compare\")])\n+\n+(define_insn \"*rotldi3_internal9\"\n+  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x\")\n+\t(compare:CC (zero_extend:DI\n+\t\t     (subreg:QI\n+\t\t      (rotate:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n+\t\t\t\t (match_operand:DI 2 \"reg_or_cint_operand\" \"ri\")) 0))\n+\t\t    (const_int 0)))\n+   (set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n+\t(zero_extend:DI (subreg:QI (rotate:DI (match_dup 1) (match_dup 2)) 0)))]\n+  \"TARGET_POWERPC64\"\n+  \"rld%I2cl. %0,%1,%H2,56\"\n+  [(set_attr \"type\" \"delayed_compare\")])\n+\n+(define_insn \"*rotldi3_internal10\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n+\t(zero_extend:DI\n+\t (subreg:HI\n+\t  (rotate:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n+\t\t     (match_operand:DI 2 \"reg_or_cint_operand\" \"ri\")) 0)))]\n+  \"TARGET_POWERPC64\"\n+  \"rld%I2cl %0,%1,%H2,48\")\n+\n+(define_insn \"*rotldi3_internal11\"\n+  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x\")\n+\t(compare:CC (zero_extend:DI\n+\t\t     (subreg:HI\n+\t\t      (rotate:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n+\t\t\t\t (match_operand:DI 2 \"reg_or_cint_operand\" \"ri\")) 0))\n+\t\t    (const_int 0)))\n+   (clobber (match_scratch:DI 3 \"=r\"))]\n+  \"TARGET_POWERPC64\"\n+  \"rld%I2cl. %3,%1,%H2,48\"\n+  [(set_attr \"type\" \"delayed_compare\")])\n+\n+(define_insn \"*rotldi3_internal12\"\n+  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x\")\n+\t(compare:CC (zero_extend:DI\n+\t\t     (subreg:HI\n+\t\t      (rotate:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n+\t\t\t\t (match_operand:DI 2 \"reg_or_cint_operand\" \"ri\")) 0))\n+\t\t    (const_int 0)))\n+   (set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n+\t(zero_extend:DI (subreg:HI (rotate:DI (match_dup 1) (match_dup 2)) 0)))]\n+  \"TARGET_POWERPC64\"\n+  \"rld%I2cl. %0,%1,%H2,48\"\n+  [(set_attr \"type\" \"delayed_compare\")])\n+\n+(define_insn \"*rotldi3_internal13\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n+\t(zero_extend:DI\n+\t (subreg:SI\n+\t  (rotate:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n+\t\t     (match_operand:DI 2 \"reg_or_cint_operand\" \"ri\")) 0)))]\n+  \"TARGET_POWERPC64\"\n+  \"rld%I2cl %0,%1,%H2,32\")\n+\n+(define_insn \"*rotldi3_internal14\"\n+  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x\")\n+\t(compare:CC (zero_extend:DI\n+\t\t     (subreg:SI\n+\t\t      (rotate:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n+\t\t\t\t (match_operand:DI 2 \"reg_or_cint_operand\" \"ri\")) 0))\n+\t\t    (const_int 0)))\n+   (clobber (match_scratch:DI 3 \"=r\"))]\n+  \"TARGET_POWERPC64\"\n+  \"rld%I2cl. %3,%1,%H2,32\"\n+  [(set_attr \"type\" \"delayed_compare\")])\n+\n+(define_insn \"*rotldi3_internal15\"\n+  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x\")\n+\t(compare:CC (zero_extend:DI\n+\t\t     (subreg:SI\n+\t\t      (rotate:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n+\t\t\t\t (match_operand:DI 2 \"reg_or_cint_operand\" \"ri\")) 0))\n+\t\t    (const_int 0)))\n+   (set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n+\t(zero_extend:DI (subreg:SI (rotate:DI (match_dup 1) (match_dup 2)) 0)))]\n+  \"TARGET_POWERPC64\"\n+  \"rld%I2cl. %0,%1,%H2,32\"\n+  [(set_attr \"type\" \"delayed_compare\")])\n+\n (define_expand \"ashldi3\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n \t(ashift:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n@@ -4784,84 +4982,69 @@\n   [(set_attr \"type\" \"delayed_compare\")])\n \n (define_insn \"anddi3\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r,r\")\n-\t(and:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r,r,r\")\n-\t\t(match_operand:DI 2 \"and_operand\" \"?r,K,J\")))\n-   (clobber (match_scratch:CC 3 \"=X,x,x\"))]\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r,r,r\")\n+\t(and:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r,r,r,r\")\n+\t\t(match_operand:DI 2 \"and64_operand\" \"?r,S,K,J\")))\n+   (clobber (match_scratch:CC 3 \"=X,X,x,x\"))]\n   \"TARGET_POWERPC64\"\n   \"@\n    and %0,%1,%2\n+   rldic%B2 %0,%1,0,%S2\n    andi. %0,%1,%b2\n    andis. %0,%1,%u2\")\n \n-(define_insn \"\"\n-  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x,x,x\")\n-\t(compare:CC (and:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r,r,r\")\n-\t\t\t    (match_operand:DI 2 \"and_operand\" \"r,K,J\"))\n+(define_insn \"*anddi3_internal2\"\n+  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x,x,x,x\")\n+\t(compare:CC (and:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r,r,r,r\")\n+\t\t\t    (match_operand:DI 2 \"and64_operand\" \"r,K,J,S\"))\n \t\t    (const_int 0)))\n-   (clobber (match_scratch:DI 3 \"=r,r,r\"))]\n+   (clobber (match_scratch:DI 3 \"=r,r,r,r\"))]\n   \"TARGET_POWERPC64\"\n   \"@\n    and. %3,%1,%2\n    andi. %3,%1,%b2\n-   andis. %3,%1,%u2\"\n-  [(set_attr \"type\" \"compare,compare,compare\")])\n+   andis. %3,%1,%u2\n+   rldic%B2. %3,%1,0,%S2\"\n+  [(set_attr \"type\" \"compare,compare,compare,delayed_compare\")])\n \n-(define_insn \"\"\n-  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,x,x\")\n-\t(compare:CC (and:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r,r,r\")\n-\t\t\t    (match_operand:DI 2 \"and_operand\" \"r,K,J\"))\n+(define_insn \"*anddi3_internal3\"\n+  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,x,x,x\")\n+\t(compare:CC (and:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r,r,r,r\")\n+\t\t\t    (match_operand:DI 2 \"and64_operand\" \"r,K,J,S\"))\n \t\t    (const_int 0)))\n-   (set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r,r\")\n+   (set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r,r,r\")\n \t(and:DI (match_dup 1) (match_dup 2)))]\n   \"TARGET_POWERPC64\"\n   \"@\n    and. %0,%1,%2\n    andi. %0,%1,%b2\n-   andis. %0,%1,%u2\"\n-  [(set_attr \"type\" \"compare,compare,compare\")])\n-\n-;; Take a AND with a constant that cannot be done in a single insn and try to\n-;; split it into two insns.  This does not verify that the insns are valid\n-;; since this need not be done as combine will do it.\n+   andis. %0,%1,%u2\n+   rldic%B2. %3,%1,0,%S2\"\n+  [(set_attr \"type\" \"compare,compare,compare,delayed_compare\")])\n \n-(define_split\n+(define_expand \"iordi3\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n-\t(and:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n-\t\t(match_operand:DI 2 \"non_and_cint_operand\" \"\")))]\n+\t(ior:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n+\t\t(match_operand:DI 2 \"reg_or_cint_operand\" \"\")))]\n   \"TARGET_POWERPC64\"\n-  [(set (match_dup 0) (and:DI (match_dup 1) (match_dup 3)))\n-   (set (match_dup 0) (and:DI (match_dup 0) (match_dup 4)))]\n   \"\n {\n-  int maskval = INTVAL (operands[2]);\n-  int i, transitions, last_bit_value;\n-  int orig = maskval, first_c = maskval, second_c;\n-\n-  /* We know that MASKVAL must have more than 2 bit-transitions.  Start at\n-     the low-order bit and count for the third transition.  When we get there,\n-     make a first mask that has everything to the left of that position\n-     a one.  Then make the second mask to turn off whatever else is needed.  */\n-\n-  for (i = 1, transitions = 0, last_bit_value = maskval & 1; i < 32; i++)\n+  if (GET_CODE (operands[2]) == CONST_INT\n+      && !logical_operand (operands[2], DImode))\n     {\n-      if (((maskval >>= 1) & 1) != last_bit_value)\n-\tlast_bit_value ^= 1, transitions++;\n+      HOST_WIDE_INT value = INTVAL (operands[2]);\n+      rtx tmp = ((reload_in_progress || reload_completed\n+\t\t  || rtx_equal_p (operands[0], operands[1]))\n+\t\t ? operands[0] : gen_reg_rtx (DImode));\n \n-      if (transitions > 2)\n-\t{\n-\t  first_c |= (~0) << i;\n-\t  break;\n-\t}\n+      emit_insn (gen_iordi3 (tmp, operands[1],\n+\t\t\t     GEN_INT (value & (~ (HOST_WIDE_INT) 0xffff))));\n+      emit_insn (gen_iordi3 (operands[0], tmp, GEN_INT (value & 0xffff)));\n+      DONE;\n     }\n-\n-  second_c = orig | ~ first_c;\n-\n-  operands[3] = GEN_INT (first_c);\n-  operands[4] = GEN_INT (second_c);\n }\")\n \n-(define_insn \"iordi3\"\n+(define_insn \"*iordi3_internal1\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r,r\")\n \t(ior:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r,r,r\")\n \t\t(match_operand:DI 2 \"logical_operand\" \"r,K,J\")))]\n@@ -4871,7 +5054,7 @@\n    ori %0,%1,%b2\n    oris %0,%1,%u2\")\n \n-(define_insn \"\"\n+(define_insn \"*iordi3_internal2\"\n   [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x\")\n \t(compare:CC (ior:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r\")\n \t\t\t    (match_operand:DI 2 \"gpc_reg_operand\" \"r\"))\n@@ -4881,7 +5064,7 @@\n   \"or. %3,%1,%2\"\n   [(set_attr \"type\" \"compare\")])\n \n-(define_insn \"\"\n+(define_insn \"*iordi3_internal3\"\n   [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x\")\n \t(compare:CC (ior:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r\")\n \t\t\t    (match_operand:DI 2 \"gpc_reg_operand\" \"r\"))\n@@ -4908,7 +5091,29 @@\n   operands[4] = GEN_INT (INTVAL (operands[2]) & 0xffff);\n }\")\n \n-(define_insn \"xordi3\"\n+(define_expand \"xordi3\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n+\t(xor:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n+\t\t(match_operand:DI 2 \"reg_or_cint_operand\" \"\")))]\n+  \"TARGET_POWERPC64\"\n+  \"\n+{\n+  if (GET_CODE (operands[2]) == CONST_INT\n+      && !logical_operand (operands[2], DImode))\n+    {\n+      HOST_WIDE_INT value = INTVAL (operands[2]);\n+      rtx tmp = ((reload_in_progress || reload_completed\n+\t\t  || rtx_equal_p (operands[0], operands[1]))\n+\t\t ? operands[0] : gen_reg_rtx (DImode));\n+\n+      emit_insn (gen_xordi3 (tmp, operands[1],\n+\t\t\t     GEN_INT (value & (~ (HOST_WIDE_INT) 0xffff))));\n+      emit_insn (gen_xordi3 (operands[0], tmp, GEN_INT (value & 0xffff)));\n+      DONE;\n+    }\n+}\")\n+\n+(define_insn \"*xordi3_internal1\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r,r\")\n \t(xor:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r,r,r\")\n \t\t(match_operand:DI 2 \"logical_operand\" \"r,K,J\")))]\n@@ -4918,7 +5123,7 @@\n    xori %0,%1,%b2\n    xoris %0,%1,%u2\")\n \n-(define_insn \"\"\n+(define_insn \"*xordi3_internal2\"\n   [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x\")\n \t(compare:CC (xor:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r\")\n \t\t\t    (match_operand:DI 2 \"gpc_reg_operand\" \"r\"))\n@@ -4928,7 +5133,7 @@\n   \"xor. %3,%1,%2\"\n   [(set_attr \"type\" \"compare\")])\n \n-(define_insn \"\"\n+(define_insn \"*xordi3_internal3\"\n   [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x\")\n \t(compare:CC (xor:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r\")\n \t\t\t    (match_operand:DI 2 \"gpc_reg_operand\" \"r\"))\n@@ -4944,25 +5149,25 @@\n \n (define_split\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n-\t(xor:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n-\t\t(match_operand:DI 2 \"non_logical_cint_operand\" \"\")))]\n+        (xor:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n+                (match_operand:DI 2 \"non_logical_cint_operand\" \"\")))]\n   \"TARGET_POWERPC64\"\n   [(set (match_dup 0) (xor:DI (match_dup 1) (match_dup 3)))\n    (set (match_dup 0) (xor:DI (match_dup 0) (match_dup 4)))]\n \"\n {\n-  operands[3] = GEN_INT (INTVAL (operands[2]) & 0xffff0000);\n+  operands[3] = GEN_INT (INTVAL (operands[2]) & (~ (HOST_WIDE_INT) 0xffff));\n   operands[4] = GEN_INT (INTVAL (operands[2]) & 0xffff);\n }\")\n \n-(define_insn \"\"\n+(define_insn \"*eqvdi3_internal1\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n \t(not:DI (xor:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r\")\n \t\t\t(match_operand:DI 2 \"gpc_reg_operand\" \"r\"))))]\n    \"TARGET_POWERPC64\"\n    \"eqv %0,%1,%2\")\n \n-(define_insn \"\"\n+(define_insn \"*eqvdi3_internal2\"\n   [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x\")\n \t(compare:CC (not:DI (xor:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r\")\n \t\t\t\t    (match_operand:DI 2 \"gpc_reg_operand\" \"r\")))\n@@ -4972,7 +5177,7 @@\n    \"eqv. %3,%1,%2\"\n    [(set_attr \"type\" \"compare\")])\n \n-(define_insn \"\"\n+(define_insn \"*eqvdi3_internal3\"\n   [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x\")\n \t(compare:CC (not:DI (xor:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r\")\n \t\t\t\t    (match_operand:DI 2 \"gpc_reg_operand\" \"r\")))\n@@ -4983,14 +5188,14 @@\n    \"eqv. %0,%1,%2\"\n    [(set_attr \"type\" \"compare\")])\n \n-(define_insn \"\"\n+(define_insn \"*andcdi3_internal1\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n \t(and:DI (not:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\"))\n \t\t(match_operand:DI 2 \"gpc_reg_operand\" \"r\")))]\n   \"TARGET_POWERPC64\"\n   \"andc %0,%2,%1\")\n \n-(define_insn \"\"\n+(define_insn \"*andcdi3_internal2\"\n   [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x\")\n \t(compare:CC (and:DI (not:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\"))\n \t\t\t    (match_operand:DI 2 \"gpc_reg_operand\" \"r\"))\n@@ -5000,7 +5205,7 @@\n   \"andc. %3,%2,%1\"\n   [(set_attr \"type\" \"compare\")])\n \n-(define_insn \"\"\n+(define_insn \"*andcdi3_internal3\"\n   [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x\")\n \t(compare:CC (and:DI (not:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\"))\n \t\t\t    (match_operand:DI 2 \"gpc_reg_operand\" \"r\"))\n@@ -5011,14 +5216,14 @@\n   \"andc. %0,%2,%1\"\n   [(set_attr \"type\" \"compare\")])\n \n-(define_insn \"\"\n+(define_insn \"*iorcdi3_internal1\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n \t(ior:DI (not:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\"))\n \t\t(match_operand:DI 2 \"gpc_reg_operand\" \"r\")))]\n   \"TARGET_POWERPC64\"\n   \"orc %0,%2,%1\")\n \n-(define_insn \"\"\n+(define_insn \"*iorcdi3_inernal2\"\n   [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x\")\n \t(compare:CC (ior:DI (not:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\"))\n \t\t\t    (match_operand:DI 2 \"gpc_reg_operand\" \"r\"))\n@@ -5028,7 +5233,7 @@\n   \"orc. %3,%2,%1\"\n   [(set_attr \"type\" \"compare\")])\n \n-(define_insn \"\"\n+(define_insn \"*iorcdi3_internal3\"\n   [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x\")\n \t(compare:CC (ior:DI (not:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\"))\n \t\t\t    (match_operand:DI 2 \"gpc_reg_operand\" \"r\"))\n@@ -5039,14 +5244,14 @@\n   \"orc. %0,%2,%1\"\n   [(set_attr \"type\" \"compare\")])\n \n-(define_insn \"\"\n+(define_insn \"*nanddi3_internal1\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n \t(ior:DI (not:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r\"))\n \t\t(not:DI (match_operand:DI 2 \"gpc_reg_operand\" \"r\"))))]\n   \"TARGET_POWERPC64\"\n   \"nand %0,%1,%2\")\n \n-(define_insn \"\"\n+(define_insn \"*nanddi3_internal2\"\n   [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x\")\n \t(compare:CC (ior:DI (not:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r\"))\n \t\t\t    (not:DI (match_operand:DI 2 \"gpc_reg_operand\" \"r\")))\n@@ -5056,7 +5261,7 @@\n   \"nand. %3,%1,%2\"\n   [(set_attr \"type\" \"compare\")])\n \n-(define_insn \"\"\n+(define_insn \"*nanddi3_internal3\"\n   [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x\")\n \t(compare:CC (ior:DI (not:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r\"))\n \t\t\t    (not:DI (match_operand:DI 2 \"gpc_reg_operand\" \"r\")))\n@@ -5067,14 +5272,14 @@\n   \"nand. %0,%1,%2\"\n   [(set_attr \"type\" \"compare\")])\n \n-(define_insn \"\"\n+(define_insn \"*nordi3_internal1\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n \t(and:DI (not:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r\"))\n \t\t(not:DI (match_operand:DI 2 \"gpc_reg_operand\" \"r\"))))]\n   \"TARGET_POWERPC64\"\n   \"nor %0,%1,%2\")\n \n-(define_insn \"\"\n+(define_insn \"*nordi3_internal2\"\n   [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x\")\n \t(compare:CC (and:DI (not:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r\"))\n \t\t\t    (not:DI (match_operand:DI 2 \"gpc_reg_operand\" \"r\")))\n@@ -5084,7 +5289,7 @@\n   \"nor. %3,%1,%2\"\n   [(set_attr \"type\" \"compare\")])\n \n-(define_insn \"\"\n+(define_insn \"*nordi3_internal3\"\n   [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x\")\n \t(compare:CC (and:DI (not:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r\"))\n \t\t\t    (not:DI (match_operand:DI 2 \"gpc_reg_operand\" \"r\")))\n@@ -5312,14 +5517,12 @@\n }\")\n \n (define_insn \"\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,r,r,r,m,r,r,r,r,r,*q,*c*l,*h\")\n-\t(match_operand:SI 1 \"input_operand\" \"r,S,T,U,m,r,I,J,n,R,*h,r,r,0\"))]\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,r,m,r,r,r,r,r,*q,*c*l,*h\")\n+\t(match_operand:SI 1 \"input_operand\" \"r,U,m,r,I,J,n,R,*h,r,r,0\"))]\n   \"gpc_reg_operand (operands[0], SImode)\n    || gpc_reg_operand (operands[1], SImode)\"\n   \"@\n    mr %0,%1\n-   {l|lwz} %0,[toc]%1(2)\n-   {l|lwz} %0,[toc]%l1(2)\n    {cal|la} %0,%a1\n    {l%U1%X1|lwz%U1%X1} %0,%1\n    {st%U0%X0|stw%U0%X0} %1,%0\n@@ -5331,8 +5534,8 @@\n    mt%0 %1\n    mt%0 %1\n    cror 0,0,0\"\n-  [(set_attr \"type\" \"*,load,load,*,load,store,*,*,*,*,*,*,mtjmpr,*\")\n-   (set_attr \"length\" \"4,4,4,4,4,4,4,4,8,4,4,4,4,4\")])\n+  [(set_attr \"type\" \"*,*,load,store,*,*,*,*,*,*,mtjmpr,*\")\n+   (set_attr \"length\" \"4,4,4,4,4,4,8,4,4,4,4,4\")])\n \n ;; Split a load of a large constant into the appropriate two-insn\n ;; sequence.\n@@ -5567,7 +5770,7 @@\n (define_split\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"\")\n \t(match_operand:SF 1 \"const_double_operand\" \"\"))]\n-  \"TARGET_32BIT && reload_completed\n+  \"! TARGET_POWERPC64 && reload_completed\n    && ((GET_CODE (operands[0]) == REG && REGNO (operands[0]) <= 31)\n        || (GET_CODE (operands[0]) == SUBREG\n \t   && GET_CODE (SUBREG_REG (operands[0])) == REG\n@@ -5585,6 +5788,27 @@\n   operands[3] = GEN_INT(l);\n }\")\n \n+(define_split\n+  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"\")\n+\t(match_operand:SF 1 \"const_double_operand\" \"\"))]\n+  \"TARGET_POWERPC64 && reload_completed\n+   && ((GET_CODE (operands[0]) == REG && REGNO (operands[0]) <= 31)\n+       || (GET_CODE (operands[0]) == SUBREG\n+\t   && GET_CODE (SUBREG_REG (operands[0])) == REG\n+\t   && REGNO (SUBREG_REG (operands[0])) <= 31))\"\n+  [(set (match_dup 2) (match_dup 3))]\n+  \"\n+{\n+  long l;\n+  REAL_VALUE_TYPE rv;\n+\n+  REAL_VALUE_FROM_CONST_DOUBLE (rv, operands[1]);\n+  REAL_VALUE_TO_TARGET_SINGLE (rv, l);\n+\n+  operands[2] = gen_lowpart (SImode, operands[0]);\n+  operands[3] = GEN_INT(l);\n+}\")\n+\n (define_insn \"*movsf_hardfloat\"\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f,f,m,!r,!r\")\n \t(match_operand:SF 1 \"input_operand\" \"f,m,f,G,Fn\"))]\n@@ -5656,7 +5880,7 @@\n (define_split\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n \t(match_operand:DF 1 \"const_int_operand\" \"\"))]\n-  \"TARGET_32BIT && reload_completed\n+  \"! TARGET_POWERPC64 && reload_completed\n    && ((GET_CODE (operands[0]) == REG && REGNO (operands[0]) <= 31)\n        || (GET_CODE (operands[0]) == SUBREG\n \t   && GET_CODE (SUBREG_REG (operands[0])) == REG\n@@ -5674,7 +5898,7 @@\n (define_split\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n \t(match_operand:DF 1 \"const_double_operand\" \"\"))]\n-  \"TARGET_32BIT && reload_completed\n+  \"! TARGET_POWERPC64 && reload_completed\n    && ((GET_CODE (operands[0]) == REG && REGNO (operands[0]) <= 31)\n        || (GET_CODE (operands[0]) == SUBREG\n \t   && GET_CODE (SUBREG_REG (operands[0])) == REG\n@@ -5699,14 +5923,25 @@\n (define_split\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n \t(match_operand:DF 1 \"easy_fp_constant\" \"\"))]\n-  \"TARGET_64BIT && reload_completed\n+  \"TARGET_POWERPC64 && reload_completed\n    && ((GET_CODE (operands[0]) == REG && REGNO (operands[0]) <= 31)\n        || (GET_CODE (operands[0]) == SUBREG\n \t   && GET_CODE (SUBREG_REG (operands[0])) == REG\n \t   && REGNO (SUBREG_REG (operands[0])) <= 31))\"\n-  [(set (match_dup 2) (subreg:DI (match_dup 1) 0))]\n+  [(set (match_dup 2) (match_dup 3))]\n   \"\n-{ operands[2] = gen_lowpart (DImode, operands[0]); }\")\n+{\n+  int endian = (WORDS_BIG_ENDIAN == 0);\n+  long l[2];\n+  REAL_VALUE_TYPE rv;\n+\n+  REAL_VALUE_FROM_CONST_DOUBLE (rv, operands[1]);\n+  REAL_VALUE_TO_TARGET_DOUBLE (rv, l);\n+\n+  operands[2] = gen_lowpart (DImode, operands[0]);\n+  /* HIGHPART is lower memory address when WORDS_BIG_ENDIAN.  */\n+  operands[3] = immed_double_const (l[1 - endian], l[endian], DImode);\n+}\")\n \n ;; Don't have reload use general registers to load a constant.  First,\n ;; it might not work if the output operand has is the equivalent of\n@@ -5724,6 +5959,8 @@\n {\n   switch (which_alternative)\n     {\n+    default:\n+      abort();\n     case 0:\n       /* We normally copy the low-numbered register first.  However, if\n \t the first register operand 0 is the same as the second register of\n@@ -5769,6 +6006,8 @@\n {\n   switch (which_alternative)\n     {\n+    default:\n+      abort();\n     case 0:\n       /* We normally copy the low-numbered register first.  However, if\n \t the first register operand 0 is the same as the second register of\n@@ -5844,77 +6083,74 @@\n   if (GET_CODE (operands[0]) != REG)\n     operands[1] = force_reg (DImode, operands[1]);\n \n-  if (TARGET_64BIT\n-      && (GET_CODE (operands[1]) == CONST_DOUBLE\n-\t  || GET_CODE (operands[1]) == CONST_INT))\n-    {\n-      HOST_WIDE_INT low;\n-      HOST_WIDE_INT high;\n-\n-      if (GET_CODE (operands[1]) == CONST_DOUBLE)\n-\t{\n-\t  low = CONST_DOUBLE_LOW (operands[1]);\n-\t  high = CONST_DOUBLE_HIGH (operands[1]);\n-\t}\n-      else\n+  /* Convert a move of a CONST_DOUBLE into a CONST_INT\n+     only if sign-extended lower-half for 32-bit host.  */\n+  if (GET_CODE (operands[1]) == CONST_DOUBLE\n #if HOST_BITS_PER_WIDE_INT == 32\n-\t{\n-\t  low = INTVAL (operands[1]);\n-\t  high = (low < 0) ? ~0 : 0;\n-\t}\n-#else\n-\t{\n-          low = INTVAL (operands[1]) & 0xffffffff;\n-          high = (HOST_WIDE_INT) INTVAL (operands[1]) >> 32;\n-\t}\n+      && ((CONST_DOUBLE_HIGH (operands[1]) == 0\n+\t   && (CONST_DOUBLE_LOW (operands[1]) & 0x80000000) == 0)\n+\t  || (CONST_DOUBLE_HIGH (operands[1]) == 0xffffffff\n+\t      && (CONST_DOUBLE_LOW (operands[1]) & 0x80000000) != 0))\n #endif\n+\t )\n+    operands[1] = GEN_INT (CONST_DOUBLE_LOW (operands[1]));\n \n-\tif (high)\n-\t  {\n-\t    emit_move_insn (operands[0], GEN_INT (high));\n-\t    emit_insn (gen_ashldi3 (operands[0], operands[0], GEN_INT(32)));\n-\t    if (low)\n-\t      {\n-\t\tHOST_WIDE_INT low_low = low & 0xffff;\n-\t\tHOST_WIDE_INT low_high = low & (~ (HOST_WIDE_INT) 0xffff);\n-\t\tif (low_high)\n-\t\t  emit_insn (gen_iordi3 (operands[0], operands[0],\n-\t\t\t\t\t GEN_INT (low_high)));\n-\t\tif (low_low)\n-\t\t  emit_insn (gen_iordi3 (operands[0], operands[0],\n-\t\t\t\t\t GEN_INT (low_low)));\n-\t      }\n-\t      DONE;\n-\t  }\n-    }\n+  if (TARGET_64BIT\n+      && CONSTANT_P (operands[1])\n+#if HOST_BITS_PER_WIDE_INT == 32\n+      && GET_CODE (operands[1]) != CONST_INT\n+#endif\n+      && ! easy_fp_constant (operands[1], DImode)\n+      && ! LEGITIMATE_CONSTANT_POOL_ADDRESS_P (operands[1]))\n+    {\n+      /* Emit a USE operation so that the constant isn't deleted if\n+\t expensive optimizations are turned on because nobody\n+\t references it.  This should only be done for operands that\n+\t contain SYMBOL_REFs with CONSTANT_POOL_ADDRESS_P set.\n+\t This should not be done for operands that contain LABEL_REFs.\n+\t For now, we just handle the obvious case.  */\n+      if (GET_CODE (operands[1]) != LABEL_REF)\n+\temit_insn (gen_rtx (USE, VOIDmode, operands[1]));\n \n-      /* Stores between FPR and any non-FPR registers must go through a\n-         temporary stack slot.  */\n+      /* If we are to limit the number of things we put in the TOC and\n+\t this is a symbol plus a constant we can add in one insn,\n+\t just put the symbol in the TOC and add the constant.  Don't do\n+\t this if reload is in progress.  */\n+      if (GET_CODE (operands[1]) == CONST\n+\t  && TARGET_NO_SUM_IN_TOC && ! reload_in_progress\n+\t  && GET_CODE (XEXP (operands[1], 0)) == PLUS\n+\t  && add_operand (XEXP (XEXP (operands[1], 0), 1), DImode)\n+\t  && (GET_CODE (XEXP (XEXP (operands[1], 0), 0)) == LABEL_REF\n+\t      || GET_CODE (XEXP (XEXP (operands[1], 0), 0)) == SYMBOL_REF)\n+\t  && ! side_effects_p (operands[0]))\n+\t{\n+\t  rtx sym = force_const_mem (DImode, XEXP (XEXP (operands[1], 0), 0));\n+\t  rtx other = XEXP (XEXP (operands[1], 0), 1);\n \n-  if (GET_CODE (operands[0]) == REG && GET_CODE (operands[1]) == REG\n-      && ((FP_REGNO_P (REGNO (operands[0]))\n-\t   && ! FP_REGNO_P (REGNO (operands[1])))\n-\t  || (FP_REGNO_P (REGNO (operands[1]))\n-\t      && ! FP_REGNO_P (REGNO (operands[0])))))\n-    {\n-      rtx stack_slot = assign_stack_temp (DImode, 8, 0);\n+\t  emit_insn (gen_adddi3 (operands[0], force_reg (DImode, sym), other));\n+\t  DONE;\n+\t}\n \n-      emit_move_insn (stack_slot, operands[1]);\n-      emit_move_insn (operands[0], stack_slot);\n-      DONE;\n+      operands[1] = force_const_mem (DImode, operands[1]);\n+      if (! memory_address_p (DImode, XEXP (operands[1], 0))\n+\t  && ! reload_in_progress)\n+\toperands[1] = change_address (operands[1], DImode,\n+\t\t\t\t      XEXP (operands[1], 0));\n     }\n }\")\n \n (define_insn \"*movdi_32\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,m,f,f,m,r,r,r,r,r\")\n \t(match_operand:DI 1 \"input_operand\" \"r,m,r,f,m,f,IJK,n,G,H,F\"))]\n-  \"TARGET_32BIT\n+  \"! TARGET_POWERPC64\n    && (gpc_reg_operand (operands[0], DImode)\n        || gpc_reg_operand (operands[1], DImode))\"\n   \"*\n {\n   switch (which_alternative)\n     {\n+    default:\n+      abort();\n     case 0:\n       /* We normally copy the low-numbered register first.  However, if\n \t the first register operand 0 is the same as the second register of\n@@ -5955,7 +6191,7 @@\n (define_split\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n \t(match_operand:DI 1 \"const_int_operand\" \"\"))]\n-  \"TARGET_32BIT && reload_completed\"\n+  \"! TARGET_POWERPC64 && reload_completed\"\n   [(set (match_dup 2) (match_dup 4))\n    (set (match_dup 3) (match_dup 1))]\n   \"\n@@ -5968,7 +6204,7 @@\n (define_split\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n \t(match_operand:DI 1 \"const_double_operand\" \"\"))]\n-  \"TARGET_32BIT && reload_completed\"\n+  \"! TARGET_POWERPC64 && reload_completed\"\n   [(set (match_dup 2) (match_dup 4))\n    (set (match_dup 3) (match_dup 5))]\n   \"\n@@ -5982,7 +6218,7 @@\n (define_insn \"*movdi_64\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,m,r,r,r,r,f,f,m,r,*h,*h\")\n \t(match_operand:DI 1 \"input_operand\" \"r,m,r,I,J,nF,R,f,m,f,*h,r,0\"))]\n-  \"TARGET_64BIT\n+  \"TARGET_POWERPC64\n    && (gpc_reg_operand (operands[0], DImode)\n        || gpc_reg_operand (operands[1], DImode))\"\n   \"@\n@@ -6002,28 +6238,111 @@\n   [(set_attr \"type\" \"*,load,store,*,*,*,*,fp,fpload,fpstore,*,mtjmpr,*\")\n    (set_attr \"length\" \"4,4,4,4,4,20,4,4,4,4,4,4,4\")])\n \n-;; Split a load of a large constant into the appropriate five-instruction\n-;; sequence.  The expansion in movdi tries to perform the minimum number of\n-;; steps, but here we have to handle anything in a constant number of insns.\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n+\t(match_operand:DI 1 \"const_double_operand\" \"F\"))]\n+  \"TARGET_POWERPC64 && GET_CODE (operands[1]) == CONST_DOUBLE\n+   && num_insns_constant (operands[1], DImode) == 1\"\n+  \"*\n+{\n+  return ((unsigned HOST_WIDE_INT)\n+\t  (CONST_DOUBLE_LOW (operands[1]) + 0x8000) < 0x10000)\n+\t ? \\\"li %0,%1\\\" : \\\"lis %0,%v1\\\";\n+}\")\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n+\t(match_operand:DI 1 \"const_int_operand\" \"\"))]\n+  \"HOST_BITS_PER_WIDE_INT == 32 && TARGET_POWERPC64\n+   && num_insns_constant (operands[1], DImode) > 1\"\n+  [(set (match_dup 0)\n+\t(match_dup 2))\n+   (set (match_dup 0)\n+\t(ior:DI (match_dup 0)\n+\t\t(match_dup 3)))]\n+  \"\n+{\n+  operands[2] = GEN_INT (INTVAL (operands[1]) & 0xffff0000);\n+  operands[3] = GEN_INT (INTVAL (operands[1]) & 0xffff);\n+}\")\n \n (define_split\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n \t(match_operand:DI 1 \"const_double_operand\" \"\"))]\n-  \"TARGET_64BIT && num_insns_constant (operands[1], DImode) > 1\"\n+  \"HOST_BITS_PER_WIDE_INT == 32 && TARGET_POWERPC64\n+   && GET_CODE (operands[1]) == CONST_DOUBLE\n+   && ((CONST_DOUBLE_HIGH (operands[1]) == 0\n+        && (CONST_DOUBLE_LOW (operands[1]) & 0x80000000) == 0)\n+       || (CONST_DOUBLE_HIGH (operands[1]) == 0xffffffff\n+           && (CONST_DOUBLE_LOW (operands[1]) & 0x80000000) != 0))\"\n   [(set (match_dup 0)\n \t(match_dup 2))\n    (set (match_dup 0)\n \t(ior:DI (match_dup 0)\n-\t\t(match_dup 3)))\n+\t\t(match_dup 3)))]\n+  \"\n+{\n+  operands[2] = GEN_INT (CONST_DOUBLE_LOW (operands[1]) & 0xffff0000);\n+  operands[3] = GEN_INT (CONST_DOUBLE_LOW (operands[1]) & 0xffff);\n+}\")\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n+\t(match_operand:DI 1 \"const_double_operand\" \"\"))]\n+  \"HOST_BITS_PER_WIDE_INT == 32 && TARGET_POWERPC64\n+   && GET_CODE (operands[1]) == CONST_DOUBLE\n+   && CONST_DOUBLE_HIGH (operands[1]) == 0\n+   && (CONST_DOUBLE_LOW (operands[1]) & 0x80000000) != 0\"\n+  [(set (match_dup 0)\n+\t(match_dup 2))\n+   (set (match_dup 0)\n+\t(zero_extend:DI (subreg:SI (match_dup 0) 0)))]\n+  \"\n+{ operands[2] = GEN_INT (CONST_DOUBLE_LOW (operands[1])); }\")\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n+\t(match_operand:DI 1 \"const_double_operand\" \"\"))]\n+  \"HOST_BITS_PER_WIDE_INT == 32 && TARGET_POWERPC64\n+   && GET_CODE (operands[1]) == CONST_DOUBLE\n+   && CONST_DOUBLE_LOW (operands[1]) == 0\"\n+  [(set (match_dup 0)\n+\t(match_dup 2))\n    (set (match_dup 0)\n \t(ashift:DI (match_dup 0)\n-\t\t   (const_int 32)))\n+\t\t   (const_int 32)))]\n+  \"\n+{ operands[2] = GEN_INT (CONST_DOUBLE_HIGH (operands[1])); }\")\n+\n+;; Generate all one-bits and clear left or right.\n+;; Use (and:DI (rotate:DI ...)) to avoid anddi3 unnecessary clobber.\n+(define_split\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n+\t(match_operand:DI 1 \"mask64_operand\" \"\"))]\n+  \"TARGET_POWERPC64 && num_insns_constant (operands[1], DImode) > 1\"\n+  [(set (match_dup 0) (const_int -1))\n    (set (match_dup 0)\n-\t(ior:DI (match_dup 0)\n-\t\t(match_dup 4)))\n+\t(and:DI (rotate:DI (match_dup 0)\n+\t\t\t   (const_int 0))\n+\t\t(match_dup 1)))]\n+  \"\")\n+\n+;; Split a load of a large constant into the appropriate five-instruction\n+;; sequence.  Handle anything in a constant number of insns.\n+;; When non-easy constants can go in the TOC, this should use\n+;; easy_fp_constant predicate.\n+(define_split\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n+\t(match_operand:DI 1 \"const_double_operand\" \"\"))]\n+  \"TARGET_POWERPC64 && num_insns_constant (operands[1], DImode) > 1\"\n+  [(set (match_dup 0)\n+\t(match_dup 2))\n+   (set (match_dup 0)\n+\t(ashift:DI (match_dup 0)\n+\t\t   (const_int 32)))\n    (set (match_dup 0)\n \t(ior:DI (match_dup 0)\n-\t\t(match_dup 5)))]\n+\t\t(match_dup 3)))]\n   \"\n {\n   HOST_WIDE_INT low;\n@@ -6047,14 +6366,8 @@\n     }\n #endif\n \n-  if ((high + 0x8000) < 0x10000\n-      && ((low & 0xffff) == 0 || (low & (~ (HOST_WIDE_INT) 0xffff)) == 0))\n-    FAIL;\n-\n-  operands[2] = GEN_INT (high & (~ (HOST_WIDE_INT) 0xffff));\n-  operands[3] = GEN_INT (high & 0xffff);\n-  operands[4] = GEN_INT (low & (~ (HOST_WIDE_INT) 0xffff));\n-  operands[5] = GEN_INT (low & 0xffff);\n+  operands[2] = GEN_INT (high);\n+  operands[3] = GEN_INT (low);\n }\")\n \n (define_insn \"\"\n@@ -6097,7 +6410,7 @@\n ;; while the 2nd alternative would not.  We put memory cases first so they\n ;; are preferred.  Otherwise, we'd try to reload the output instead of\n ;; giving the SCRATCH mq.\n-(define_insn \"\"\n+(define_insn \"*movti_power\"\n   [(set (match_operand:TI 0 \"reg_or_mem_operand\" \"=Q,m,????r,????r,????r\")\n \t(match_operand:TI 1 \"reg_or_mem_operand\" \"r,r,r,Q,m\"))\n    (clobber (match_scratch:SI 2 \"=q,q#X,X,X,X\"))]\n@@ -6151,7 +6464,7 @@\n   [(set_attr \"type\" \"store,store,*,load,load\")\n    (set_attr \"length\" \"*,16,16,*,16\")])\n \n-(define_insn \"\"\n+(define_insn \"*movti_string\"\n   [(set (match_operand:TI 0 \"reg_or_mem_operand\" \"=m,????r,????r\")\n \t(match_operand:TI 1 \"reg_or_mem_operand\" \"r,r,m\"))\n    (clobber (match_scratch:SI 2 \"=X,X,X\"))]\n@@ -6196,7 +6509,7 @@\n   [(set_attr \"type\" \"store,*,load\")\n    (set_attr \"length\" \"16,16,16\")])\n \n-(define_insn \"\"\n+(define_insn \"*movti_ppc64\"\n   [(set (match_operand:TI 0 \"nonimmediate_operand\" \"=r,r,m\")\n \t(match_operand:TI 1 \"input_operand\" \"r,m,r\"))]\n   \"TARGET_POWERPC64 && (gpc_reg_operand (operands[0], TImode)\n@@ -6205,6 +6518,8 @@\n {\n   switch (which_alternative)\n     {\n+    default:\n+      abort();\n     case 0:\n       /* We normally copy the low-numbered register first.  However, if\n \t the first register operand 0 is the same as the second register of\n@@ -6919,10 +7234,10 @@\n ;; We move the back-chain and decrement the stack pointer.\n \n (define_expand \"allocate_stack\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(minus:SI (reg:SI 1) (match_operand:SI 1 \"reg_or_short_operand\" \"\")))\n-   (set (reg:SI 1)\n-\t(minus:SI (reg:SI 1) (match_dup 1)))]\n+  [(set (match_operand 0 \"register_operand\" \"=r\")\n+\t(minus (reg 1) (match_operand 1 \"reg_or_short_operand\" \"\")))\n+   (set (reg 1)\n+\t(minus (reg 1) (match_dup 1)))]\n   \"\"\n   \"\n { rtx chain = gen_reg_rtx (Pmode);\n@@ -6937,9 +7252,9 @@\n   if (DEFAULT_ABI == ABI_NT\n       && (GET_CODE (operands[1]) != CONST_INT || INTVAL (operands[1]) > 4096))\n     {\n-      rtx tmp = gen_reg_rtx (SImode);\n+      rtx tmp = gen_reg_rtx (Pmode);\n       emit_library_call_value (gen_rtx (SYMBOL_REF, Pmode, \\\"__allocate_stack\\\"),\n-\t\t\t       tmp, 0, SImode, 1, operands[1], Pmode);\n+\t\t\t       tmp, 0, Pmode, 1, operands[1], Pmode);\n       emit_insn (gen_set_sp (tmp));\n       emit_move_insn (operands[0], tmp);\n       DONE;\n@@ -6966,9 +7281,7 @@\n     {\n       emit_insn ((* ((TARGET_32BIT) ? gen_addsi3 : gen_adddi3))\n \t\t (stack_pointer_rtx, stack_pointer_rtx, neg_op0));\n-      emit_move_insn (gen_rtx (MEM, (TARGET_32BIT) ? SImode : DImode,\n-\t\t\t       stack_pointer_rtx),\n-\t\t      chain);\n+      emit_move_insn (gen_rtx (MEM, Pmode, stack_pointer_rtx), chain);\n     }\n \n   emit_move_insn (operands[0], virtual_stack_dynamic_rtx);\n@@ -7005,40 +7318,44 @@\n   \"\")\n \n (define_expand \"restore_stack_block\"\n-  [(set (match_dup 2) (mem:SI (match_operand:SI 0 \"register_operand\" \"\")))\n-   (set (match_dup 0) (match_operand:SI 1 \"register_operand\" \"\"))\n-   (set (mem:SI (match_dup 0)) (match_dup 2))]\n+  [(set (match_dup 2) (mem (match_operand 0 \"register_operand\" \"\")))\n+   (set (match_dup 0) (match_operand 1 \"register_operand\" \"\"))\n+   (set (mem (match_dup 0)) (match_dup 2))]\n   \"\"\n   \"\n-{ operands[2] = gen_reg_rtx (SImode); }\")\n+{ operands[2] = gen_reg_rtx (Pmode); }\")\n \n (define_expand \"save_stack_nonlocal\"\n-  [(match_operand:DI 0 \"memory_operand\" \"\")\n-   (match_operand:SI 1 \"register_operand\" \"\")]\n+  [(match_operand 0 \"memory_operand\" \"\")\n+   (match_operand 1 \"register_operand\" \"\")]\n   \"\"\n   \"\n {\n-  rtx temp = gen_reg_rtx (SImode);\n+  rtx temp = gen_reg_rtx (Pmode);\n \n   /* Copy the backchain to the first word, sp to the second.  */\n-  emit_move_insn (temp, gen_rtx (MEM, SImode, operands[1]));\n-  emit_move_insn (operand_subword (operands[0], 0, 0, DImode), temp);\n-  emit_move_insn (operand_subword (operands[0], 1, 0, DImode), operands[1]);\n+  emit_move_insn (temp, gen_rtx (MEM, Pmode, operands[1]));\n+  emit_move_insn (operand_subword (operands[0], 0, 0, (TARGET_32BIT ? DImode : TImode)),\n+\t\t  temp);\n+  emit_move_insn (operand_subword (operands[0], 1, 0, (TARGET_32BIT ? DImode : TImode)),\n+\t\t  operands[1]);\n   DONE;\n }\")\n \n (define_expand \"restore_stack_nonlocal\"\n-  [(match_operand:SI 0 \"register_operand\" \"\")\n-   (match_operand:DI 1 \"memory_operand\" \"\")]\n+  [(match_operand 0 \"register_operand\" \"\")\n+   (match_operand 1 \"memory_operand\" \"\")]\n   \"\"\n   \"\n {\n-  rtx temp = gen_reg_rtx (SImode);\n+  rtx temp = gen_reg_rtx (Pmode);\n \n   /* Restore the backchain from the first word, sp from the second.  */\n-  emit_move_insn (temp, operand_subword (operands[1], 0, 0, DImode));\n-  emit_move_insn (operands[0], operand_subword (operands[1], 1, 0, DImode));\n-  emit_move_insn (gen_rtx (MEM, SImode, operands[0]), temp);\n+  emit_move_insn (temp,\n+\t\t  operand_subword (operands[1], 0, 0, (TARGET_32BIT ? DImode : TImode)));\n+  emit_move_insn (operands[0],\n+\t\t  operand_subword (operands[1], 1, 0, (TARGET_32BIT ? DImode : TImode)));\n+  emit_move_insn (gen_rtx (MEM, Pmode, operands[0]), temp);\n   DONE;\n }\")\n \n@@ -7070,7 +7387,7 @@\n ;; We do not break this into separate insns, so that the scheduler will not try\n ;; to move the load of the new TOC before any loads from the TOC.\n \n-(define_insn \"call_indirect_aix\"\n+(define_insn \"call_indirect_aix32\"\n   [(call (mem:SI (match_operand:SI 0 \"register_operand\" \"b\"))\n \t (match_operand 1 \"const_int_operand\" \"n\"))\n    (use (match_operand 2 \"const_int_operand\" \"n\"))\n@@ -7085,7 +7402,22 @@\n   [(set_attr \"type\" \"load\")\n    (set_attr \"length\" \"28\")])\n \n-(define_insn \"call_value_indirect_aix\"\n+(define_insn \"call_indirect_aix64\"\n+  [(call (mem:SI (match_operand:DI 0 \"register_operand\" \"b\"))\n+\t (match_operand 1 \"const_int_operand\" \"n\"))\n+   (use (match_operand 2 \"const_int_operand\" \"n\"))\n+   (use (match_operand 3 \"offsettable_addr_operand\" \"p\"))\n+   (use (match_operand 4 \"register_operand\" \"r\"))\n+   (clobber (match_operand 5 \"register_operand\" \"=r\"))\n+   (clobber (match_scratch:SI 6 \"=&r\"))\n+   (clobber (match_scratch:SI 7 \"=l\"))]\n+  \"TARGET_64BIT && DEFAULT_ABI == ABI_AIX\n+   && (INTVAL (operands[2]) == CALL_NORMAL || (INTVAL (operands[2]) & CALL_LONG) != 0)\"\n+  \"stw %4,%a3\\;ld %6,0(%0)\\;ld %4,8(%0)\\;mt%7 %6\\;ld %5,16(%0)\\;blrl\\;ld %4,%a3\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"28\")])\n+\n+(define_insn \"call_value_indirect_aix32\"\n   [(set (match_operand 0 \"register_operand\" \"fg\")\n \t(call (mem:SI (match_operand:SI 1 \"register_operand\" \"b\"))\n \t      (match_operand 2 \"const_int_operand\" \"n\")))\n@@ -7097,7 +7429,23 @@\n    (clobber (match_scratch:SI 8 \"=l\"))]\n   \"DEFAULT_ABI == ABI_AIX\n    && (INTVAL (operands[3]) == CALL_NORMAL || (INTVAL (operands[3]) & CALL_LONG) != 0)\"\n-  \"{st|stw} %5,%a4\\;{l|lwz} %7,0(%1)\\;{l|lwz} %5,4(%1);\\;mt%8 %7\\;{l|lwz} %6,8(%1)\\;{brl|blrl}\\;{l|lwz} %5,%a4\"\n+  \"{st|stw} %5,%a4\\;{l|lwz} %7,0(%1)\\;{l|lwz} %5,4(%1)\\;mt%8 %7\\;{l|lwz} %6,8(%1)\\;{brl|blrl}\\;{l|lwz} %5,%a4\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"28\")])\n+\n+(define_insn \"call_value_indirect_aix64\"\n+  [(set (match_operand 0 \"register_operand\" \"fg\")\n+\t(call (mem:SI (match_operand:DI 1 \"register_operand\" \"b\"))\n+\t      (match_operand 2 \"const_int_operand\" \"n\")))\n+   (use (match_operand 3 \"const_int_operand\" \"n\"))\n+   (use (match_operand 4 \"offsettable_addr_operand\" \"p\"))\n+   (use (match_operand 5 \"register_operand\" \"r\"))\n+   (clobber (match_operand 6 \"register_operand\" \"=r\"))\n+   (clobber (match_scratch:SI 7 \"=&r\"))\n+   (clobber (match_scratch:SI 8 \"=l\"))]\n+  \"TARGET_64BIT && DEFAULT_ABI == ABI_AIX\n+   && (INTVAL (operands[3]) == CALL_NORMAL || (INTVAL (operands[3]) & CALL_LONG) != 0)\"\n+  \"stw %5,%a4\\;ld %7,0(%1)\\;ld %5,8(%1)\\;mt%8 %7\\;ld %6,16(%1)\\;blrl\\;ld %5,%a4\"\n   [(set_attr \"type\" \"load\")\n    (set_attr \"length\" \"28\")])\n \n@@ -7190,7 +7538,7 @@\n \n ;; Now the definitions for the call and call_value insns\n (define_expand \"call\"\n-  [(parallel [(call (mem:SI (match_operand:SI 0 \"address_operand\" \"\"))\n+  [(parallel [(call (mem:SI (match_operand 0 \"address_operand\" \"\"))\n \t\t    (match_operand 1 \"\" \"\"))\n \t      (use (match_operand 2 \"\" \"\"))\n \t      (clobber (scratch:SI))])]\n@@ -7228,9 +7576,13 @@\n \t    {\n \t      /* AIX function pointers are really pointers to a three word area */\n \t      rtx static_chain = gen_rtx (REG, Pmode, STATIC_CHAIN_REGNUM);\n-\t      emit_call_insn (gen_call_indirect_aix (force_reg (Pmode, operands[0]),\n-\t\t\t\t\t\t     operands[1], operands[2],\n-\t\t\t\t\t\t     toc_addr, toc_reg, static_chain));\n+\t      emit_call_insn (TARGET_32BIT\n+\t\t\t      ? gen_call_indirect_aix32 (force_reg (Pmode, operands[0]),\n+\t\t\t\t\t\t         operands[1], operands[2],\n+\t\t\t\t\t\t         toc_addr, toc_reg, static_chain)\n+\t\t\t      : gen_call_indirect_aix64 (force_reg (Pmode, operands[0]),\n+\t\t\t\t\t\t         operands[1], operands[2],\n+\t\t\t\t\t\t         toc_addr, toc_reg, static_chain));\n \t    }\n \t  else if (DEFAULT_ABI == ABI_NT)\n \t    {\n@@ -7248,7 +7600,7 @@\n \n (define_expand \"call_value\"\n   [(parallel [(set (match_operand 0 \"\" \"\")\n-\t\t   (call (mem:SI (match_operand:SI 1 \"address_operand\" \"\"))\n+\t\t   (call (mem:SI (match_operand 1 \"address_operand\" \"\"))\n \t\t\t (match_operand 2 \"\" \"\")))\n \t      (use (match_operand 3 \"\" \"\"))\n \t      (clobber (scratch:SI))])]\n@@ -7286,10 +7638,15 @@\n \t    {\n \t      /* AIX function pointers are really pointers to a three word area */\n \t      rtx static_chain = gen_rtx (REG, Pmode, STATIC_CHAIN_REGNUM);\n-\t      emit_call_insn (gen_call_value_indirect_aix (operands[0],\n-\t\t\t\t\t\t\t   force_reg (Pmode, operands[1]),\n-\t\t\t\t\t\t\t   operands[2], operands[3],\n-\t\t\t\t\t\t\t   toc_addr, toc_reg, static_chain));\n+\t      emit_call_insn (TARGET_32BIT\n+\t\t\t      ? gen_call_value_indirect_aix32 (operands[0],\n+\t\t\t\t\t\t\t       force_reg (Pmode, operands[1]),\n+\t\t\t\t\t\t\t       operands[2], operands[3],\n+\t\t\t\t\t\t\t       toc_addr, toc_reg, static_chain)\n+\t\t\t      : gen_call_value_indirect_aix64 (operands[0],\n+\t\t\t\t\t\t\t       force_reg (Pmode, operands[1]),\n+\t\t\t\t\t\t\t       operands[2], operands[3],\n+\t\t\t\t\t\t\t       toc_addr, toc_reg, static_chain));\n \t    }\n \t  else if (DEFAULT_ABI == ABI_NT)\n \t    {\n@@ -7312,7 +7669,7 @@\n ;; variable argument function.  It is > 0 if FP registers were passed\n ;; and < 0 if they were not.\n \n-(define_insn \"\"\n+(define_insn \"*call_local32\"\n   [(call (mem:SI (match_operand:SI 0 \"current_file_function_operand\" \"s,s\"))\n \t (match_operand 1 \"\" \"g,g\"))\n    (use (match_operand:SI 2 \"immediate_operand\" \"O,n\"))\n@@ -7331,14 +7688,74 @@\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"length\" \"4,8\")])\n \n+(define_insn \"*call_local64\"\n+  [(call (mem:SI (match_operand:DI 0 \"current_file_function_operand\" \"s,s\"))\n+\t (match_operand 1 \"\" \"g,g\"))\n+   (use (match_operand:SI 2 \"immediate_operand\" \"O,n\"))\n+   (clobber (match_scratch:SI 3 \"=l,l\"))]\n+  \"TARGET_64BIT && (INTVAL (operands[2]) & CALL_LONG) == 0\"\n+  \"*\n+{\n+  if (INTVAL (operands[2]) & CALL_V4_SET_FP_ARGS)\n+    output_asm_insn (\\\"crxor 6,6,6\\\", operands);\n+\n+  else if (INTVAL (operands[2]) & CALL_V4_CLEAR_FP_ARGS)\n+    output_asm_insn (\\\"creqv 6,6,6\\\", operands);\n+\n+  return (DEFAULT_ABI == ABI_V4 && flag_pic) ? \\\"bl %z0@local\\\" : \\\"bl %z0\\\";\n+}\"\n+  [(set_attr \"type\" \"branch\")\n+   (set_attr \"length\" \"4,8\")])\n+\n+(define_insn \"*ret_call_local32\"\n+  [(set (match_operand 0 \"\" \"=fg,fg\")\n+\t(call (mem:SI (match_operand:SI 1 \"current_file_function_operand\" \"s,s\"))\n+\t      (match_operand 2 \"\" \"g,g\")))\n+   (use (match_operand:SI 3 \"immediate_operand\" \"O,n\"))\n+   (clobber (match_scratch:SI 4 \"=l,l\"))]\n+  \"(INTVAL (operands[3]) & CALL_LONG) == 0\"\n+  \"*\n+{\n+  if (INTVAL (operands[3]) & CALL_V4_SET_FP_ARGS)\n+    output_asm_insn (\\\"crxor 6,6,6\\\", operands);\n+\n+  else if (INTVAL (operands[3]) & CALL_V4_CLEAR_FP_ARGS)\n+    output_asm_insn (\\\"creqv 6,6,6\\\", operands);\n+\n+  return (DEFAULT_ABI == ABI_V4 && flag_pic) ? \\\"bl %z1@local\\\" : \\\"bl %z1\\\";\n+}\"\n+  [(set_attr \"type\" \"branch\")\n+   (set_attr \"length\" \"4,8\")])\n+\n+\n+(define_insn \"*ret_call_local64\"\n+  [(set (match_operand 0 \"\" \"=fg,fg\")\n+\t(call (mem:SI (match_operand:DI 1 \"current_file_function_operand\" \"s,s\"))\n+\t      (match_operand 2 \"\" \"g,g\")))\n+   (use (match_operand:SI 3 \"immediate_operand\" \"O,n\"))\n+   (clobber (match_scratch:SI 4 \"=l,l\"))]\n+  \"TARGET_64BIT && (INTVAL (operands[3]) & CALL_LONG) == 0\"\n+  \"*\n+{\n+  if (INTVAL (operands[3]) & CALL_V4_SET_FP_ARGS)\n+    output_asm_insn (\\\"crxor 6,6,6\\\", operands);\n+\n+  else if (INTVAL (operands[3]) & CALL_V4_CLEAR_FP_ARGS)\n+    output_asm_insn (\\\"creqv 6,6,6\\\", operands);\n+\n+  return (DEFAULT_ABI == ABI_V4 && flag_pic) ? \\\"bl %z1@local\\\" : \\\"bl %z1\\\";\n+}\"\n+  [(set_attr \"type\" \"branch\")\n+   (set_attr \"length\" \"4,8\")])\n+\n ;; Call to function which may be in another module.  Restore the TOC\n ;; pointer (r2) after the call unless this is System V.\n ;; Operand2 is non-zero if we are using the V.4 calling sequence and\n ;; either the function was not prototyped, or it was prototyped as a\n ;; variable argument function.  It is > 0 if FP registers were passed\n ;; and < 0 if they were not.\n \n-(define_insn \"\"\n+(define_insn \"*call_nonlocal_aix32\"\n   [(call (mem:SI (match_operand:SI 0 \"call_operand\" \"s,s\"))\n \t (match_operand 1 \"\" \"fg,fg\"))\n    (use (match_operand:SI 2 \"immediate_operand\" \"O,n\"))\n@@ -7362,7 +7779,31 @@\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"length\" \"8,12\")])\n \n-(define_insn \"\"\n+(define_insn \"*call_nonlocal_aix64\"\n+  [(call (mem:SI (match_operand:DI 0 \"call_operand\" \"s,s\"))\n+\t (match_operand 1 \"\" \"fg,fg\"))\n+   (use (match_operand:SI 2 \"immediate_operand\" \"O,n\"))\n+   (clobber (match_scratch:SI 3 \"=l,l\"))]\n+  \"TARGET_64BIT && (DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_NT)\n+   && (INTVAL (operands[2]) & CALL_LONG) == 0\"\n+  \"*\n+{\n+  /* Indirect calls should go through call_indirect */\n+  if (GET_CODE (operands[0]) == REG)\n+    abort ();\n+\n+  if (INTVAL (operands[2]) & CALL_V4_SET_FP_ARGS)\n+    output_asm_insn (\\\"crxor 6,6,6\\\", operands);\n+\n+  else if (INTVAL (operands[2]) & CALL_V4_CLEAR_FP_ARGS)\n+    output_asm_insn (\\\"creqv 6,6,6\\\", operands);\n+\n+  return (TARGET_WINDOWS_NT) ? \\\"bl %z0\\;.znop %z0\\\" : \\\"bl %z0\\;%.\\\";\n+}\"\n+  [(set_attr \"type\" \"branch\")\n+   (set_attr \"length\" \"8,12\")])\n+\n+(define_insn \"*call_nonlocal_sysv\"\n   [(call (mem:SI (match_operand:SI 0 \"call_operand\" \"s,s\"))\n \t (match_operand 1 \"\" \"fg,fg\"))\n    (use (match_operand:SI 2 \"immediate_operand\" \"O,n\"))\n@@ -7386,33 +7827,38 @@\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"length\" \"4,8\")])\n \n-(define_insn \"\"\n+(define_insn \"*ret_call_nonlocal_aix32\"\n   [(set (match_operand 0 \"\" \"=fg,fg\")\n-\t(call (mem:SI (match_operand:SI 1 \"current_file_function_operand\" \"s,s\"))\n-\t      (match_operand 2 \"\" \"g,g\")))\n+\t(call (mem:SI (match_operand:SI 1 \"call_operand\" \"s,s\"))\n+\t      (match_operand 2 \"\" \"fg,fg\")))\n    (use (match_operand:SI 3 \"immediate_operand\" \"O,n\"))\n    (clobber (match_scratch:SI 4 \"=l,l\"))]\n-  \"(INTVAL (operands[3]) & CALL_LONG) == 0\"\n+  \"(DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_NT)\n+   && (INTVAL (operands[3]) & CALL_LONG) == 0\"\n   \"*\n {\n+  /* This should be handled by call_value_indirect */\n+  if (GET_CODE (operands[1]) == REG)\n+    abort ();\n+\n   if (INTVAL (operands[3]) & CALL_V4_SET_FP_ARGS)\n     output_asm_insn (\\\"crxor 6,6,6\\\", operands);\n \n   else if (INTVAL (operands[3]) & CALL_V4_CLEAR_FP_ARGS)\n     output_asm_insn (\\\"creqv 6,6,6\\\", operands);\n \n-  return (DEFAULT_ABI == ABI_V4 && flag_pic) ? \\\"bl %z1@local\\\" : \\\"bl %z1\\\";\n+  return (TARGET_WINDOWS_NT) ? \\\"bl %z1\\;.znop %z1\\\" : \\\"bl %z1\\;%.\\\";\n }\"\n   [(set_attr \"type\" \"branch\")\n-   (set_attr \"length\" \"4,8\")])\n+   (set_attr \"length\" \"8,12\")])\n \n-(define_insn \"\"\n+(define_insn \"*ret_call_nonlocal_aix64\"\n   [(set (match_operand 0 \"\" \"=fg,fg\")\n-\t(call (mem:SI (match_operand:SI 1 \"call_operand\" \"s,s\"))\n+\t(call (mem:SI (match_operand:DI 1 \"call_operand\" \"s,s\"))\n \t      (match_operand 2 \"\" \"fg,fg\")))\n    (use (match_operand:SI 3 \"immediate_operand\" \"O,n\"))\n    (clobber (match_scratch:SI 4 \"=l,l\"))]\n-  \"(DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_NT)\n+  \"TARGET_64BIT && (DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_NT)\n    && (INTVAL (operands[3]) & CALL_LONG) == 0\"\n   \"*\n {\n@@ -7431,7 +7877,7 @@\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"length\" \"8,12\")])\n \n-(define_insn \"\"\n+(define_insn \"*ret_call_nonlocal_sysv\"\n   [(set (match_operand 0 \"\" \"=fg,fg\")\n \t(call (mem:SI (match_operand:SI 1 \"call_operand\" \"s,s\"))\n \t      (match_operand 2 \"\" \"fg,fg\")))\n@@ -8138,6 +8584,20 @@\n    {sfi|subfic} %0,%1,%2\\;{sfi|subfic} %3,%0,0\\;{ae|adde} %0,%3,%0\"\n   [(set_attr \"length\" \"12,8,12,12,12\")])\n \n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r,r,r,r\")\n+\t(eq:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r,r,r,r,r\")\n+\t       (match_operand:DI 2 \"reg_or_cint_operand\" \"r,O,K,J,I\")))\n+   (clobber (match_scratch:DI 3 \"=r,&r,r,r,r\"))]\n+  \"TARGET_POWERPC64\"\n+  \"@\n+   xor %0,%1,%2\\;subfic %3,%0,0\\;adde %0,%3,%0\n+   subfic %3,%1,0\\;adde %0,%3,%1\n+   xori %0,%1,%b2\\;subfic %3,%0,0\\;adde %0,%3,%0\n+   xoris %0,%1,%u2\\;subfic %3,%0,0\\;adde %0,%3,%0\n+   subfic %0,%1,%2\\;subfic %3,%0,0\\;adde %0,%3,%0\"\n+  [(set_attr \"length\" \"12,8,12,12,12\")])\n+\n (define_insn \"\"\n   [(set (match_operand:CC 4 \"cc_reg_operand\" \"=x,x,x,x,x\")\n \t(compare:CC\n@@ -8157,6 +8617,25 @@\n   [(set_attr \"type\" \"compare\")\n    (set_attr \"length\" \"12,8,12,12,12\")])\n \n+(define_insn \"\"\n+  [(set (match_operand:CC 4 \"cc_reg_operand\" \"=x,x,x,x,x\")\n+\t(compare:CC\n+\t (eq:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r,r,r,r,r\")\n+\t\t(match_operand:DI 2 \"reg_or_cint_operand\" \"r,O,K,J,I\"))\n+\t (const_int 0)))\n+   (set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r,r,r,r\")\n+\t(eq:DI (match_dup 1) (match_dup 2)))\n+   (clobber (match_scratch:DI 3 \"=r,&r,r,r,r\"))]\n+  \"TARGET_POWERPC64\"\n+  \"@\n+   xor %0,%1,%2\\;subfic %3,%0,0\\;adde. %0,%3,%0\n+   subfic %3,%1,0\\;adde. %0,%3,%1\n+   xori %0,%1,%b2\\;subfic %3,%0,0\\;adde. %0,%3,%0\n+   xoris %0,%1,%u2\\;subfic %3,%0,0\\;adde. %0,%3,%0\n+   subfic %0,%1,%2\\;subfic %3,%0,0\\;adde. %0,%3,%0\"\n+  [(set_attr \"type\" \"compare\")\n+   (set_attr \"length\" \"12,8,12,12,12\")])\n+\n ;; We have insns of the form shown by the first define_insn below.  If\n ;; there is something inside the comparison operation, we must split it.\n (define_split\n@@ -8251,6 +8730,15 @@\n   \"{ai|addic} %2,%1,-1\\;{sfe|subfe} %0,%2,%1\"\n   [(set_attr \"length\" \"8\")])\n \n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n+\t(lshiftrt:DI (neg:DI (abs:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")))\n+\t\t     (const_int 63)))\n+   (clobber (match_scratch:DI 2 \"=&r\"))]\n+  \"TARGET_POWERPC64\"\n+  \"addic %2,%1,-1\\;subfe %0,%2,%1\"\n+  [(set_attr \"length\" \"8\")])\n+\n ;; This is what (plus (ne X (const_int 0)) Y) looks like.\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n@@ -8263,6 +8751,17 @@\n   \"{ai|addic} %3,%1,-1\\;{aze|addze} %0,%2\"\n   [(set_attr \"length\" \"8\")])\n \n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n+\t(plus:DI (lshiftrt:DI\n+\t\t  (neg:DI (abs:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")))\n+\t\t  (const_int 63))\n+\t\t (match_operand:DI 2 \"gpc_reg_operand\" \"r\")))\n+   (clobber (match_scratch:DI 3 \"=&r\"))]\n+  \"TARGET_POWERPC64\"\n+  \"addic %3,%1,-1\\;addze %0,%2\"\n+  [(set_attr \"length\" \"8\")])\n+\n (define_insn \"\"\n   [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x\")\n \t(compare:CC\n@@ -8277,6 +8776,20 @@\n   [(set_attr \"type\" \"compare\")\n    (set_attr \"length\" \"8\")])\n \n+(define_insn \"\"\n+  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x\")\n+\t(compare:CC\n+\t (plus:DI (lshiftrt:DI\n+\t\t   (neg:DI (abs:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")))\n+\t\t   (const_int 63))\n+\t\t  (match_operand:DI 2 \"gpc_reg_operand\" \"r\"))\n+\t (const_int 0)))\n+   (clobber (match_scratch:DI 3 \"=&r\"))]\n+  \"TARGET_POWERPC64\"\n+  \"addic %3,%1,-1\\;addze. %3,%2\"\n+  [(set_attr \"type\" \"compare\")\n+   (set_attr \"length\" \"8\")])\n+\n (define_insn \"\"\n   [(set (match_operand:CC 4 \"cc_reg_operand\" \"=x\")\n \t(compare:CC\n@@ -8294,6 +8807,23 @@\n   [(set_attr \"type\" \"compare\")\n    (set_attr \"length\" \"8\")])\n \n+(define_insn \"\"\n+  [(set (match_operand:CC 4 \"cc_reg_operand\" \"=x\")\n+\t(compare:CC\n+\t (plus:DI (lshiftrt:DI\n+\t\t   (neg:DI (abs:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")))\n+\t\t   (const_int 63))\n+\t\t  (match_operand:DI 2 \"gpc_reg_operand\" \"r\"))\n+\t (const_int 0)))\n+   (set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n+\t(plus:DI (lshiftrt:DI (neg:DI (abs:DI (match_dup 1))) (const_int 63))\n+\t\t (match_dup 2)))\n+   (clobber (match_scratch:DI 3 \"=&r\"))]\n+  \"TARGET_POWERPC64\"\n+  \"addic %3,%1,-1\\;addze. %0,%2\"\n+  [(set_attr \"type\" \"compare\")\n+   (set_attr \"length\" \"8\")])\n+\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r\")\n \t(le:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r,r\")"}, {"sha": "d85f51356e55520dd2aaf14f55bda0b5f9023e36", "filename": "gcc/config/rs6000/sysv4.h", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a260abc996f80102ba3820e02f4b281bd9b86a4a/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a260abc996f80102ba3820e02f4b281bd9b86a4a/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fsysv4.h?ref=a260abc996f80102ba3820e02f4b281bd9b86a4a", "patch": "@@ -266,7 +266,17 @@ do {\t\t\t\t\t\t\t\t\t\\\n /* Default ABI to compile code for */\n #define DEFAULT_ABI rs6000_current_abi\n \n-#include \"rs6000/powerpc.h\"\n+#define CPP_DEFAULT_SPEC \"-D_ARCH_PPC\"\n+\n+#define ASM_DEFAULT_SPEC \"-mppc\"\n+\n+#include \"rs6000/rs6000.h\"\n+\n+#undef TARGET_DEFAULT\n+#define TARGET_DEFAULT (MASK_POWERPC | MASK_NEW_MNEMONICS)\n+\n+#undef PROCESSOR_DEFAULT\n+#define PROCESSOR_DEFAULT PROCESSOR_PPC601\n \n /* System V.4 uses register 13 as a pointer to the small data area,\n    so it is not available to the normal user.  */"}, {"sha": "56ddb45395de4007a58c81d03d577356983b12c4", "filename": "gcc/config/rs6000/t-aix43", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a260abc996f80102ba3820e02f4b281bd9b86a4a/gcc%2Fconfig%2Frs6000%2Ft-aix43", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a260abc996f80102ba3820e02f4b281bd9b86a4a/gcc%2Fconfig%2Frs6000%2Ft-aix43", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Ft-aix43?ref=a260abc996f80102ba3820e02f4b281bd9b86a4a", "patch": "@@ -0,0 +1,48 @@\n+# Do not build libgcc1.\n+LIBGCC1 =\n+CROSS_LIBGCC1 =\n+\n+# These are really part of libgcc1, but this will cause them to be\n+# built correctly, so... [taken from t-sparclite]\n+LIB2FUNCS_EXTRA = fp-bit.c dp-bit.c\n+\n+dp-bit.c: $(srcdir)/config/fp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c > dp-bit.c\n+\n+fp-bit.c: $(srcdir)/config/fp-bit.c\n+\techo '#define FLOAT' > fp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n+\n+# Build the libraries for both hard and soft floating point and all of the \n+# different processor models\n+\n+MULTILIB_OPTIONS\t= msoft-float \\\n+\t\t\t  mcpu=common/mcpu=power/mcpu=powerpc/maix64\n+\n+MULTILIB_DIRNAMES\t= soft-float \\\n+\t\t\t  common power powerpc aix64\n+\n+MULTILIB_MATCHES\t= msoft-float=mcpu?403 \\\n+\t\t\t  maix64=maix64 \\\n+\t\t\t  mcpu?power=mpower \\\n+\t\t\t  mcpu?power=mrios1 \\\n+\t\t\t  mcpu?power=mcpu?rios1 \\\n+\t\t\t  mcpu?power=mcpu?rsc \\\n+\t\t\t  mcpu?power=mcpu?rsc1 \\\n+\t\t\t  mcpu?power=mpower2 \\\n+\t\t\t  mcpu?power=mrios2 \\\n+\t\t\t  mcpu?power=mcpu=rios2 \\\n+\t\t\t  mcpu?powerpc=mcpu?601 \\\n+\t\t\t  mcpu?powerpc=mcpu?602 \\\n+\t\t\t  mcpu?powerpc=mcpu?603 \\\n+\t\t\t  mcpu?powerpc=mcpu?603e \\\n+\t\t\t  mcpu?powerpc=mcpu?604 \\\n+\t\t\t  mcpu?powerpc=mcpu?620 \\\n+\t\t\t  mcpu?powerpc=mcpu?403 \\\n+\t\t\t  mcpu?powerpc=mpowerpc \\\n+\t\t\t  mcpu?powerpc=mpowerpc-gpopt \\\n+\t\t\t  mcpu?powerpc=mpowerpc-gfxopt\n+\n+LIBGCC = stmp-multilib\n+INSTALL_LIBGCC = install-multilib\n+"}, {"sha": "742a5e8c5fc67051b5b46a4369b31b6fcdca52ad", "filename": "gcc/config/rs6000/win-nt.h", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a260abc996f80102ba3820e02f4b281bd9b86a4a/gcc%2Fconfig%2Frs6000%2Fwin-nt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a260abc996f80102ba3820e02f4b281bd9b86a4a/gcc%2Fconfig%2Frs6000%2Fwin-nt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fwin-nt.h?ref=a260abc996f80102ba3820e02f4b281bd9b86a4a", "patch": "@@ -1,6 +1,6 @@\n /* Definitions of target machine for GNU compiler, for PowerPC\n    running Windows/NT.\n-   Copyright (C) 1995, 1996 Free Software Foundation, Inc.\n+   Copyright (C) 1995, 1996, 1997, 1998 Free Software Foundation, Inc.\n    Contributed by Cygnus Support.\n \n This file is part of GNU CC.\n@@ -27,12 +27,21 @@ Boston, MA 02111-1307, USA.  */\n /* Default ABI to compile code for */\n #define DEFAULT_ABI ABI_NT\n \n-#include \"rs6000/powerpc.h\"\n+#define CPP_DEFAULT_SPEC \"-D_ARCH_PPC\"\n+\n+#define ASM_DEFAULT_SPEC \"-mppc\"\n \n /* Pseudo target that we can test in the md file.  */\n-#undef \tTARGET_WINDOWS_NT\n #define\tTARGET_WINDOWS_NT 1\n \n+#include \"rs6000/rs6000.h\"\n+\n+#undef TARGET_DEFAULT\n+#define TARGET_DEFAULT (MASK_POWERPC | MASK_NEW_MNEMONICS)\n+\n+#undef PROCESSOR_DEFAULT\n+#define PROCESSOR_DEFAULT PROCESSOR_POWERPC\n+\n #undef\tCPP_PREDEFINES\n #define\tCPP_PREDEFINES \"-DWIN32 -D_WIN32 \\\n   -DWINNT -D__STDC__=0 -DALMOST_STDC \\\n@@ -71,9 +80,6 @@ Boston, MA 02111-1307, USA.  */\n #undef\tPREFERRED_DEBUGGING_TYPE\n #define PREFERRED_DEBUGGING_TYPE DBX_DEBUG\n \n-#undef PROCESSOR_DEFAULT\n-#define PROCESSOR_DEFAULT PROCESSOR_POWERPC\n-\n /* NT always runs little endian */\n #undef  BYTES_BIG_ENDIAN\n #define BYTES_BIG_ENDIAN 0 \n@@ -113,9 +119,6 @@ Boston, MA 02111-1307, USA.  */\n #undef TARGET_DEFAULT \n #define TARGET_DEFAULT (MASK_POWERPC | MASK_NEW_MNEMONICS | MASK_NO_FP_IN_TOC | MASK_NO_SUM_IN_TOC)\n \n-#undef PROCESSOR_DEFAULT\n-#define PROCESSOR_DEFAULT PROCESSOR_PPC601\n-\n /* Address to save the TOC register */\n #undef\tRS6000_SAVE_TOC\n #define RS6000_SAVE_TOC plus_constant (virtual_incoming_args_rtx, -RS6000_SAVE_AREA - 8)\n@@ -162,7 +165,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n   ASM_OUTPUT_SKIP (FILE, SIZE);\t\t\t\t\t\t\\\n } while (0)\n \n-/* Describe how to emit unitialized external linkage items  */\n+/* Describe how to emit uninitialized external linkage items  */\n #define ASM_OUTPUT_ALIGNED_BSS(FILE, DECL, NAME, SIZE, ALIGN)\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n   ASM_GLOBALIZE_LABEL (FILE, NAME);\t\t\t\t\t\\"}, {"sha": "69c666b43bc8db14b389e80832afe4cd60522f45", "filename": "gcc/config/rs6000/x-aix41", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a260abc996f80102ba3820e02f4b281bd9b86a4a/gcc%2Fconfig%2Frs6000%2Fx-aix41", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a260abc996f80102ba3820e02f4b281bd9b86a4a/gcc%2Fconfig%2Frs6000%2Fx-aix41", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fx-aix41?ref=a260abc996f80102ba3820e02f4b281bd9b86a4a", "patch": "@@ -0,0 +1,12 @@\n+# configuration for IBM RS/6000 running AIX 4.1+\n+\n+# Show we need to use the C version of ALLOCA\n+ALLOCA=alloca.o\n+\n+# We need -lld for collect2 (actually this only matters\n+# for a native compiler, but this is as good a place as any\n+# to define the symbol).\n+CLIB=-lld\n+\n+# f771 and cc1plus overflow the AIX TOC\n+BOOT_LDFLAGS=-Wl,-bbigtoc"}, {"sha": "69fe1b3537f0146e4a515039b8759c97116b46f5", "filename": "gcc/config/rs6000/x-aix43", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a260abc996f80102ba3820e02f4b281bd9b86a4a/gcc%2Fconfig%2Frs6000%2Fx-aix43", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a260abc996f80102ba3820e02f4b281bd9b86a4a/gcc%2Fconfig%2Frs6000%2Fx-aix43", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fx-aix43?ref=a260abc996f80102ba3820e02f4b281bd9b86a4a", "patch": "@@ -0,0 +1,15 @@\n+# configuration for IBM RS/6000 running AIX 4.3+\n+\n+# Show we need to use the C version of ALLOCA\n+ALLOCA=alloca.o\n+\n+# We need -lld for collect2 (actually this only matters\n+# for a native compiler, but this is as good a place as any\n+# to define the symbol).\n+CLIB=-lld\n+\n+# f771 and cc1plus overflow the AIX TOC\n+BOOT_LDFLAGS=-Wl,-bbigtoc\n+\n+# Both 32-bit and 64-bit objects in archives\n+AR=ar -X32_64"}, {"sha": "95c2fedec707b43862690c54234f0e057ec85aa8", "filename": "gcc/configure.in", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a260abc996f80102ba3820e02f4b281bd9b86a4a/gcc%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a260abc996f80102ba3820e02f4b281bd9b86a4a/gcc%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.in?ref=a260abc996f80102ba3820e02f4b281bd9b86a4a", "patch": "@@ -2443,15 +2443,37 @@ for machine in $build $host $target; do\n \t\tfi\n \t\tuse_collect2=yes\n \t\t;;\n-\trs6000-ibm-aix[[456789]].* | powerpc-ibm-aix[[456789]].*)\n+\trs6000-ibm-aix4.[[12]].* | powerpc-ibm-aix4.[[12]].*)\n \t\ttm_file=rs6000/aix41.h\n \t\tif [[ x$host != x$target ]]\n \t\tthen\n \t\t\ttmake_file=rs6000/t-xnewas\n \t\telse\n \t\t\ttmake_file=rs6000/t-newas\n \t\tfi\n-\t\txmake_file=rs6000/x-aix31\n+\t\txmake_file=rs6000/x-aix41\n+\t\tuse_collect2=yes\n+\t\t;;\n+\trs6000-ibm-aix4.[[3456789]].* | powerpc-ibm-aix4.[[3456789]].*)\n+\t\ttm_file=rs6000/aix43.h\n+\t\tif [[ x$host != x$target ]]\n+\t\tthen\n+\t\t\ttmake_file=rs6000/t-xaix43\n+\t\telse\n+\t\t\ttmake_file=rs6000/t-aix43\n+\t\tfi\n+\t\txmake_file=rs6000/x-aix43\n+\t\tuse_collect2=yes\n+\t\t;;\n+\trs6000-ibm-aix[[56789]].* | powerpc-ibm-aix[[56789]].*)\n+\t\ttm_file=rs6000/aix43.h\n+\t\tif [[ x$host != x$target ]]\n+\t\tthen\n+\t\t\ttmake_file=rs6000/t-xaix43\n+\t\telse\n+\t\t\ttmake_file=rs6000/t-aix43\n+\t\tfi\n+\t\txmake_file=rs6000/x-aix43\n \t\tuse_collect2=yes\n \t\t;;\n \trs6000-ibm-aix*)"}, {"sha": "affb2196bd956042d05f4dc9d2606d1b0b41f666", "filename": "gcc/explow.c", "status": "modified", "additions": 7, "deletions": 20, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a260abc996f80102ba3820e02f4b281bd9b86a4a/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a260abc996f80102ba3820e02f4b281bd9b86a4a/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=a260abc996f80102ba3820e02f4b281bd9b86a4a", "patch": "@@ -867,36 +867,27 @@ emit_stack_save (save_level, psave, after)\n   rtx sa = *psave;\n   /* The default is that we use a move insn and save in a Pmode object.  */\n   rtx (*fcn) () = gen_move_insn;\n-  enum machine_mode mode = Pmode;\n+  enum machine_mode mode = STACK_SAVEAREA_MODE (save_level);\n \n   /* See if this machine has anything special to do for this kind of save.  */\n   switch (save_level)\n     {\n #ifdef HAVE_save_stack_block\n     case SAVE_BLOCK:\n       if (HAVE_save_stack_block)\n-\t{\n-\t  fcn = gen_save_stack_block;\n-\t  mode = insn_operand_mode[CODE_FOR_save_stack_block][0];\n-\t}\n+\tfcn = gen_save_stack_block;\n       break;\n #endif\n #ifdef HAVE_save_stack_function\n     case SAVE_FUNCTION:\n       if (HAVE_save_stack_function)\n-\t{\n-\t  fcn = gen_save_stack_function;\n-\t  mode = insn_operand_mode[CODE_FOR_save_stack_function][0];\n-\t}\n+\tfcn = gen_save_stack_function;\n       break;\n #endif\n #ifdef HAVE_save_stack_nonlocal\n     case SAVE_NONLOCAL:\n       if (HAVE_save_stack_nonlocal)\n-\t{\n-\t  fcn = gen_save_stack_nonlocal;\n-\t  mode = insn_operand_mode[(int) CODE_FOR_save_stack_nonlocal][0];\n-\t}\n+\tfcn = gen_save_stack_nonlocal;\n       break;\n #endif\n     default:\n@@ -975,7 +966,6 @@ emit_stack_restore (save_level, sa, after)\n       break;\n #endif\n #ifdef HAVE_restore_stack_nonlocal\n-\n     case SAVE_NONLOCAL:\n       if (HAVE_restore_stack_nonlocal)\n \tfcn = gen_restore_stack_nonlocal;\n@@ -1243,18 +1233,15 @@ allocate_dynamic_stack_space (size, target, known_align)\n #ifdef HAVE_allocate_stack\n   if (HAVE_allocate_stack)\n     {\n-      enum machine_mode mode;\n-\n       if (insn_operand_predicate[(int) CODE_FOR_allocate_stack][0]\n \t  && ! ((*insn_operand_predicate[(int) CODE_FOR_allocate_stack][0])\n \t\t(target, Pmode)))\n \ttarget = copy_to_mode_reg (Pmode, target);\n-      mode = insn_operand_mode[(int) CODE_FOR_allocate_stack][1];\n-      size = convert_modes (mode, ptr_mode, size, 1);\n+      size = convert_modes (Pmode, ptr_mode, size, 1);\n       if (insn_operand_predicate[(int) CODE_FOR_allocate_stack][1]\n \t  && ! ((*insn_operand_predicate[(int) CODE_FOR_allocate_stack][1])\n-\t\t(size, mode)))\n-\tsize = copy_to_mode_reg (mode, size);\n+\t\t(size, Pmode)))\n+\tsize = copy_to_mode_reg (Pmode, size);\n \n       emit_insn (gen_allocate_stack (target, size));\n     }"}, {"sha": "dc5e5ebaf191eda2acae11a6fdedaef6f3f1e9a7", "filename": "gcc/expr.c", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a260abc996f80102ba3820e02f4b281bd9b86a4a/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a260abc996f80102ba3820e02f4b281bd9b86a4a/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=a260abc996f80102ba3820e02f4b281bd9b86a4a", "patch": "@@ -7771,7 +7771,8 @@ expand_builtin_setjmp (buf_addr, target, first_label, next_label)\n      rtx first_label, next_label;\n {\n   rtx lab1 = gen_label_rtx ();\n-  enum machine_mode sa_mode = Pmode, value_mode;\n+  enum machine_mode sa_mode = STACK_SAVEAREA_MODE (SAVE_NONLOCAL);\n+  enum machine_mode value_mode;\n   rtx stack_save;\n \n   value_mode = TYPE_MODE (integer_type_node);\n@@ -7803,11 +7804,6 @@ expand_builtin_setjmp (buf_addr, target, first_label, next_label)\n \t\t\t\t\t       GET_MODE_SIZE (Pmode)))),\n \t\t  gen_rtx_LABEL_REF (Pmode, lab1));\n \n-#ifdef HAVE_save_stack_nonlocal\n-  if (HAVE_save_stack_nonlocal)\n-    sa_mode = insn_operand_mode[(int) CODE_FOR_save_stack_nonlocal][0];\n-#endif\n-\n   stack_save = gen_rtx_MEM (sa_mode,\n \t\t\t    plus_constant (buf_addr,\n \t\t\t\t\t   2 * GET_MODE_SIZE (Pmode)));\n@@ -7899,7 +7895,7 @@ expand_builtin_longjmp (buf_addr, value)\n      rtx buf_addr, value;\n {\n   rtx fp, lab, stack;\n-  enum machine_mode sa_mode;\n+  enum machine_mode sa_mode = STACK_SAVEAREA_MODE (SAVE_NONLOCAL);\n \n #ifdef POINTERS_EXTEND_UNSIGNED\n   buf_addr = convert_memory_address (Pmode, buf_addr);\n@@ -7942,14 +7938,6 @@ expand_builtin_longjmp (buf_addr, value)\n       lab = gen_rtx_MEM (Pmode, plus_constant (buf_addr,\n \t\t\t\t\t       GET_MODE_SIZE (Pmode)));\n \n-#ifdef HAVE_save_stack_nonlocal\n-      sa_mode = (HAVE_save_stack_nonlocal\n-\t\t ? insn_operand_mode[(int) CODE_FOR_save_stack_nonlocal][0]\n-\t\t : Pmode);\n-#else\n-      sa_mode = Pmode;\n-#endif\n-\n       stack = gen_rtx_MEM (sa_mode, plus_constant (buf_addr,\n \t\t\t\t\t\t   2 * GET_MODE_SIZE (Pmode)));\n "}, {"sha": "30e8d8c2c019d8537684b11f37df2bb5a86c5349", "filename": "gcc/expr.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a260abc996f80102ba3820e02f4b281bd9b86a4a/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a260abc996f80102ba3820e02f4b281bd9b86a4a/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=a260abc996f80102ba3820e02f4b281bd9b86a4a", "patch": "@@ -245,6 +245,13 @@ enum direction {none, upward, downward};  /* Value has this type.  */\n #define RETURN_IN_MEMORY(TYPE) (TYPE_MODE (TYPE) == BLKmode)\n #endif\n \n+/* Supply a default definition of STACK_SAVEAREA_MODE for emit_stack_save.\n+   Normally move_insn, so Pmode stack pointer.  */\n+\n+#ifndef STACK_SAVEAREA_MODE\n+#define STACK_SAVEAREA_MODE(LEVEL) Pmode\n+#endif\n+\n /* Provide default values for the macros controlling stack checking.  */\n \n #ifndef STACK_CHECK_BUILTIN"}, {"sha": "de4e2f870c83c20707c850ba502b3e50cb7ce91f", "filename": "gcc/tree.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a260abc996f80102ba3820e02f4b281bd9b86a4a/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a260abc996f80102ba3820e02f4b281bd9b86a4a/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=a260abc996f80102ba3820e02f4b281bd9b86a4a", "patch": "@@ -4242,6 +4242,21 @@ build_array_type (elt_type, index_type)\n   return t;\n }\n \n+/* Return the TYPE of the elements comprising\n+   the innermost dimension of ARRAY.  */\n+\n+tree\n+get_inner_array_type (array)\n+    tree array;\n+{\n+  tree type = TREE_TYPE (array);\n+\n+  while (TREE_CODE (type) == ARRAY_TYPE)\n+    type = TREE_TYPE (type);\n+\n+  return type;\n+}\n+\n /* Construct, lay out and return\n    the type of functions returning type VALUE_TYPE\n    given arguments of types ARG_TYPES."}, {"sha": "9549d23ba9bb3088ce043acfc8e2359060307165", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a260abc996f80102ba3820e02f4b281bd9b86a4a/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a260abc996f80102ba3820e02f4b281bd9b86a4a/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=a260abc996f80102ba3820e02f4b281bd9b86a4a", "patch": "@@ -1393,6 +1393,7 @@ extern int tree_int_cst_equal\t\tPROTO((tree, tree));\n extern int tree_int_cst_lt\t\tPROTO((tree, tree));\n extern int tree_int_cst_sgn\t\tPROTO((tree));\n extern int index_type_equal\t\tPROTO((tree, tree));\n+extern tree get_inner_array_type\tPROTO((tree));\n \n /* From expmed.c.  Since rtl.h is included after tree.h, we can't\n    put the prototype here.  Rtl.h does declare the prototype if"}]}