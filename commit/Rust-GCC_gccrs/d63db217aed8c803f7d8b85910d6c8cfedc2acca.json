{"sha": "d63db217aed8c803f7d8b85910d6c8cfedc2acca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDYzZGIyMTdhZWQ4YzgwM2Y3ZDhiODU5MTBkNmM4Y2ZlZGMyYWNjYQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2005-06-28T02:20:29Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2005-06-28T02:20:29Z"}, "message": "cgraph.c (cgraph_remove_node): Do not release function bodies until full cgraph is built.\n\n\n\t* cgraph.c (cgraph_remove_node): Do not release function bodies until\n\tfull cgraph is built.\n\t* cgraph.h (cgraph_decide_inlining_incrementally): Add early argument.\n\t* cgraphunit.c (cgraph_finalize_function): Update call of\n\tcgraph_decide_inlining_incrementally.\n\t(initialize_inline_failed): Break out of ...\n\t(cgraph_analyze_function): ... here.\n\t(rebuild_cgraph_edges): New function.\n\t(pass_rebuild_cgraph_edges): New pass.\n\t* common.opt (fearly-inlining): New flag.\n\t* ipa-inline.c: Include ggc.h\n\t(cgraph_clone_inlined_nodes): Avoid re-using of original copy\n\twhen cgraph is not fully built.\n\t(cgraph_decide_inlining_incrementally): Add early mode.\n\t(cgraph_early_inlining): New function.\n\t(cgraph_gate_early_inlining): Likewise.\n\t(pass_early_ipa_inline): New pass.\n\t* ipa.c (cgraph_postorder): NULLify aux pointer.\n\t* tree-inline.c (expand_call_inline): Avoid warning early.\n\t* tree-optimize.c (pass_early_local_passes): New.\n\t(execute_cleanup_cfg_pre_ipa): New.\n\t(pass_cleanup_cfg): New.\n\t(register_dump_files): Fix handling subpasses of IPA pass.\n\t(init_tree_optimization_passes): Add early passes.\n\t(execute_ipa_pass_list): Fix handling of subpasses of IPA pass.\n\t* passes.h (pass_early_tree_profile, pass_rebuild_cgraph_edges,\n\tpass_early_ipa_inline): New passes.\n\t* tree-profile.c (do_early_tree_profiling, pass_early_tree_profile): New.\n\n\t* invoke.texi: Document early-inlining.\n\nFrom-SVN: r101369", "tree": {"sha": "02b6b104f2f54b8af2a5bad55640e994b28ecfb5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/02b6b104f2f54b8af2a5bad55640e994b28ecfb5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d63db217aed8c803f7d8b85910d6c8cfedc2acca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d63db217aed8c803f7d8b85910d6c8cfedc2acca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d63db217aed8c803f7d8b85910d6c8cfedc2acca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d63db217aed8c803f7d8b85910d6c8cfedc2acca/comments", "author": null, "committer": null, "parents": [{"sha": "2aba33dd6f2d9cf16b2c2e25e73071b5e6d4368c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2aba33dd6f2d9cf16b2c2e25e73071b5e6d4368c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2aba33dd6f2d9cf16b2c2e25e73071b5e6d4368c"}], "stats": {"total": 334, "additions": 308, "deletions": 26}, "files": [{"sha": "cd1f15cb4f9a5eedf5e7897f9c05c2d9758ee1c3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d63db217aed8c803f7d8b85910d6c8cfedc2acca/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d63db217aed8c803f7d8b85910d6c8cfedc2acca/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d63db217aed8c803f7d8b85910d6c8cfedc2acca", "patch": "@@ -1,3 +1,36 @@\n+2005-06-28  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.c (cgraph_remove_node): Do not release function bodies until\n+\tfull cgraph is built.\n+\t* cgraph.h (cgraph_decide_inlining_incrementally): Add early argument.\n+\t* cgraphunit.c (cgraph_finalize_function): Update call of\n+\tcgraph_decide_inlining_incrementally.\n+\t(initialize_inline_failed): Break out of ...\n+\t(cgraph_analyze_function): ... here.\n+\t(rebuild_cgraph_edges): New function.\n+\t(pass_rebuild_cgraph_edges): New pass.\n+\t* common.opt (fearly-inlining): New flag.\n+\t* ipa-inline.c: Include ggc.h\n+\t(cgraph_clone_inlined_nodes): Avoid re-using of original copy\n+\twhen cgraph is not fully built.\n+\t(cgraph_decide_inlining_incrementally): Add early mode.\n+\t(cgraph_early_inlining): New function.\n+\t(cgraph_gate_early_inlining): Likewise.\n+\t(pass_early_ipa_inline): New pass.\n+\t* ipa.c (cgraph_postorder): NULLify aux pointer.\n+\t* tree-inline.c (expand_call_inline): Avoid warning early.\n+\t* tree-optimize.c (pass_early_local_passes): New.\n+\t(execute_cleanup_cfg_pre_ipa): New.\n+\t(pass_cleanup_cfg): New.\n+\t(register_dump_files): Fix handling subpasses of IPA pass.\n+\t(init_tree_optimization_passes): Add early passes.\n+\t(execute_ipa_pass_list): Fix handling of subpasses of IPA pass.\n+\t* passes.h (pass_early_tree_profile, pass_rebuild_cgraph_edges,\n+\tpass_early_ipa_inline): New passes.\n+\t* tree-profile.c (do_early_tree_profiling, pass_early_tree_profile): New.\n+\n+\t* invoke.texi: Document early-inlining.\n+\n 2005-06-28  Kelley Cook  <kcook@gcc.gnu.org>\n \n \t* doc/include/fdl.texi: Merge in changes from upstream."}, {"sha": "93648327cf9549a8f3bccad42e0c3968cb00024b", "filename": "gcc/cgraph.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d63db217aed8c803f7d8b85910d6c8cfedc2acca/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d63db217aed8c803f7d8b85910d6c8cfedc2acca/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=d63db217aed8c803f7d8b85910d6c8cfedc2acca", "patch": "@@ -473,7 +473,8 @@ cgraph_remove_node (struct cgraph_node *node)\n     {\n       struct cgraph_node *n = *slot;\n       if (!n->next_clone && !n->global.inlined_to\n-\t  && (TREE_ASM_WRITTEN (n->decl) || DECL_EXTERNAL (n->decl)))\n+\t  && (cgraph_global_info_ready\n+\t      && (TREE_ASM_WRITTEN (n->decl) || DECL_EXTERNAL (n->decl))))\n \tkill_body = true;\n     }\n "}, {"sha": "40a2648b36ed3672d8a382cd91f8b517b4bc4bf4", "filename": "gcc/cgraph.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d63db217aed8c803f7d8b85910d6c8cfedc2acca/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d63db217aed8c803f7d8b85910d6c8cfedc2acca/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=d63db217aed8c803f7d8b85910d6c8cfedc2acca", "patch": "@@ -286,7 +286,7 @@ bool cgraph_remove_unreachable_nodes (bool, FILE *);\n int cgraph_postorder (struct cgraph_node **);\n \n /* In ipa-inline.c  */\n-void cgraph_decide_inlining_incrementally (struct cgraph_node *);\n+bool cgraph_decide_inlining_incrementally (struct cgraph_node *, bool);\n void cgraph_clone_inlined_nodes (struct cgraph_edge *, bool);\n void cgraph_mark_inline_edge (struct cgraph_edge *);\n bool cgraph_default_inline_p (struct cgraph_node *);"}, {"sha": "a29dace94dc48ee8a481961deb5070b027d5b684", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 69, "deletions": 12, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d63db217aed8c803f7d8b85910d6c8cfedc2acca/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d63db217aed8c803f7d8b85910d6c8cfedc2acca/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=d63db217aed8c803f7d8b85910d6c8cfedc2acca", "patch": "@@ -427,7 +427,7 @@ cgraph_finalize_function (tree decl, bool nested)\n   if (!flag_unit_at_a_time)\n     {\n       cgraph_analyze_function (node);\n-      cgraph_decide_inlining_incrementally (node);\n+      cgraph_decide_inlining_incrementally (node, false);\n     }\n \n   if (decide_is_function_needed (node, decl))\n@@ -569,6 +569,73 @@ cgraph_create_edges (struct cgraph_node *node, tree body)\n   visited_nodes = NULL;\n }\n \n+/* Give initial reasons why inlining would fail.  Those gets\n+   either NULLified or usually overwritten by more precise reason\n+   later.  */\n+static void\n+initialize_inline_failed (struct cgraph_node *node)\n+{\n+  struct cgraph_edge *e;\n+\n+  for (e = node->callers; e; e = e->next_caller)\n+    {\n+      gcc_assert (!e->callee->global.inlined_to);\n+      gcc_assert (e->inline_failed);\n+      if (node->local.redefined_extern_inline)\n+\te->inline_failed = N_(\"redefined extern inline functions are not \"\n+\t\t\t   \"considered for inlining\");\n+      else if (!node->local.inlinable)\n+\te->inline_failed = N_(\"function not inlinable\");\n+      else\n+\te->inline_failed = N_(\"function not considered for inlining\");\n+    }\n+}\n+\n+/* Rebuild call edges from current function after a passes not aware\n+   of cgraph updating.  */\n+static void\n+rebuild_cgraph_edges (void)\n+{\n+  basic_block bb;\n+  struct cgraph_node *node = cgraph_node (current_function_decl);\n+  block_stmt_iterator bsi;\n+\n+  cgraph_node_remove_callees (node);\n+\n+  node->count = ENTRY_BLOCK_PTR->count;\n+\n+  FOR_EACH_BB (bb)\n+    for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+      {\n+\ttree stmt = bsi_stmt (bsi);\n+\ttree call = get_call_expr_in (stmt);\n+\ttree decl;\n+\n+\tif (call && (decl = get_callee_fndecl (call)))\n+\t  cgraph_create_edge (node, cgraph_node (decl), stmt,\n+\t\t\t      bb->count,\n+\t\t\t      bb->loop_depth);\n+      }\n+  initialize_inline_failed (node);\n+  gcc_assert (!node->global.inlined_to);\n+}\n+\n+struct tree_opt_pass pass_rebuild_cgraph_edges =\n+{\n+  NULL,\t\t\t\t\t/* name */\n+  NULL,\t\t\t\t\t/* gate */\n+  rebuild_cgraph_edges,\t\t\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  0,\t\t\t\t\t/* tv_id */\n+  PROP_cfg,\t\t\t\t/* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  0,\t\t\t\t\t/* todo_flags_finish */\n+  0\t\t\t\t\t/* letter */\n+};\n \n /* Verify cgraph nodes of given cgraph node.  */\n void\n@@ -764,7 +831,6 @@ static void\n cgraph_analyze_function (struct cgraph_node *node)\n {\n   tree decl = node->decl;\n-  struct cgraph_edge *e;\n \n   current_function_decl = decl;\n   push_cfun (DECL_STRUCT_FUNCTION (decl));\n@@ -778,16 +844,7 @@ cgraph_analyze_function (struct cgraph_node *node)\n   if (node->local.inlinable)\n     node->local.disregard_inline_limits\n       = lang_hooks.tree_inlining.disregard_inline_limits (decl);\n-  for (e = node->callers; e; e = e->next_caller)\n-    {\n-      if (node->local.redefined_extern_inline)\n-\te->inline_failed = N_(\"redefined extern inline functions are not \"\n-\t\t\t   \"considered for inlining\");\n-      else if (!node->local.inlinable)\n-\te->inline_failed = N_(\"function not inlinable\");\n-      else\n-\te->inline_failed = N_(\"function not considered for inlining\");\n-    }\n+  initialize_inline_failed (node);\n   if (flag_really_no_inline && !node->local.disregard_inline_limits)\n     node->local.inlinable = 0;\n   /* Inlining characteristics are maintained by the cgraph_mark_inline.  */"}, {"sha": "66782ce32ae3bbae7e5f7fa9a85bccbfc3636f77", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d63db217aed8c803f7d8b85910d6c8cfedc2acca/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d63db217aed8c803f7d8b85910d6c8cfedc2acca/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=d63db217aed8c803f7d8b85910d6c8cfedc2acca", "patch": "@@ -476,6 +476,10 @@ finline-functions\n Common Report Var(flag_inline_functions)\n Integrate simple functions into their callers\n \n+fearly-inlining\n+Common Report Var(flag_early_inlining) Init(1)\n+Perform early inlining\n+\n finline-limit-\n Common RejectNegative Joined UInteger\n "}, {"sha": "140983bc2084194c1bd3dfe5402aa5ec198e6c9a", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d63db217aed8c803f7d8b85910d6c8cfedc2acca/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d63db217aed8c803f7d8b85910d6c8cfedc2acca/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=d63db217aed8c803f7d8b85910d6c8cfedc2acca", "patch": "@@ -300,7 +300,7 @@ Objective-C and Objective-C++ Dialects}.\n -fbranch-target-load-optimize2 -fbtr-bb-exclusive @gol\n -fcaller-saves  -fcprop-registers  -fcse-follow-jumps @gol\n -fcse-skip-blocks  -fcx-limited-range  -fdata-sections @gol\n--fdelayed-branch  -fdelete-null-pointer-checks @gol\n+-fdelayed-branch  -fdelete-null-pointer-checks -fearly-inlining @gol\n -fexpensive-optimizations  -ffast-math  -ffloat-store @gol\n -fforce-addr  -fforce-mem  -ffunction-sections @gol\n -fgcse  -fgcse-lm  -fgcse-sm  -fgcse-las  -fgcse-after-reload @gol\n@@ -4450,6 +4450,16 @@ assembler code in its own right.\n \n Enabled at level @option{-O3}.\n \n+@item -fearly-inlining\n+@opindex fearly-inlining\n+Inline functions marked by @code{always_inline} and functions whose body seems\n+smaller than the function call overhead early before doing\n+@option{-fprofile-generate} instrumentation and real inlining pass.  Doing so\n+makes profiling significantly cheaper and usually inlining faster on programs\n+having large chains of nested wrapper functions.\n+\n+Enabled by default.\n+\n @item -finline-limit=@var{n}\n @opindex finline-limit\n By default, GCC limits the size of functions that can be inlined.  This flag"}, {"sha": "26ea8f5e5c3d2f86d6aa45a88f6fd7f45bbf8494", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 96, "deletions": 7, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d63db217aed8c803f7d8b85910d6c8cfedc2acca/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d63db217aed8c803f7d8b85910d6c8cfedc2acca/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=d63db217aed8c803f7d8b85910d6c8cfedc2acca", "patch": "@@ -79,6 +79,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"intl.h\"\n #include \"tree-pass.h\"\n #include \"coverage.h\"\n+#include \"ggc.h\"\n \n /* Statistics we collect about inlining algorithm.  */\n static int ncalls_inlined;\n@@ -120,7 +121,7 @@ cgraph_clone_inlined_nodes (struct cgraph_edge *e, bool duplicate)\n   if (!e->callee->callers->next_caller\n       && (!e->callee->needed || DECL_EXTERNAL (e->callee->decl))\n       && duplicate\n-      && flag_unit_at_a_time)\n+      && (flag_unit_at_a_time && cgraph_global_info_ready))\n     {\n       gcc_assert (!e->callee->global.inlined_to);\n       if (!DECL_EXTERNAL (e->callee->decl))\n@@ -870,10 +871,11 @@ cgraph_decide_inlining (void)\n /* Decide on the inlining.  We do so in the topological order to avoid\n    expenses on updating data structures.  */\n \n-void\n-cgraph_decide_inlining_incrementally (struct cgraph_node *node)\n+bool\n+cgraph_decide_inlining_incrementally (struct cgraph_node *node, bool early)\n {\n   struct cgraph_edge *e;\n+  bool inlined = false;\n \n   /* First of all look for always inline functions.  */\n   for (e = node->callees; e; e = e->next_callee)\n@@ -883,7 +885,13 @@ cgraph_decide_inlining_incrementally (struct cgraph_node *node)\n \t/* ??? It is possible that renaming variable removed the function body\n \t   in duplicate_decls. See gcc.c-torture/compile/20011119-2.c  */\n \t&& DECL_SAVED_TREE (e->callee->decl))\n-      cgraph_mark_inline (e);\n+      {\n+        if (dump_file && early)\n+          fprintf (dump_file, \"  Early inlining %s into %s\\n\",\n+\t\t   cgraph_node_name (e->callee), cgraph_node_name (node));\n+\tcgraph_mark_inline (e);\n+\tinlined = true;\n+      }\n \n   /* Now do the automatic inlining.  */\n   if (!flag_really_no_inline)\n@@ -892,15 +900,36 @@ cgraph_decide_inlining_incrementally (struct cgraph_node *node)\n \t  && e->inline_failed\n \t  && !e->callee->local.disregard_inline_limits\n \t  && !cgraph_recursive_inlining_p (node, e->callee, &e->inline_failed)\n+\t  && (!early\n+\t      || (cgraph_estimate_size_after_inlining (1, e->caller, node)\n+\t          <= e->caller->global.insns))\n \t  && cgraph_check_inline_limits (node, e->callee, &e->inline_failed)\n \t  && DECL_SAVED_TREE (e->callee->decl))\n \t{\n \t  if (cgraph_default_inline_p (e->callee))\n-\t    cgraph_mark_inline (e);\n-\t  else\n+\t    {\n+\t      if (dump_file && early)\n+                fprintf (dump_file, \"  Early inlining %s into %s\\n\",\n+\t\t\t cgraph_node_name (e->callee), cgraph_node_name (node));\n+\t      cgraph_mark_inline (e);\n+\t      inlined = true;\n+\t    }\n+\t  else if (!early)\n \t    e->inline_failed\n \t      = N_(\"--param max-inline-insns-single limit reached\");\n \t}\n+  if (early && inlined)\n+    {\n+      push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n+      tree_register_cfg_hooks ();\n+      current_function_decl = node->decl;\n+      optimize_inline_calls (current_function_decl);\n+      node->local.self_insns = node->global.insns;\n+      current_function_decl = NULL;\n+      pop_cfun ();\n+      ggc_collect ();\n+    }\n+  return inlined;\n }\n \n /* When inlining shall be performed.  */\n@@ -920,7 +949,67 @@ struct tree_opt_pass pass_ipa_inline =\n   0,\t\t\t\t\t/* static_pass_number */\n   TV_INTEGRATION,\t\t\t/* tv_id */\n   0,\t                                /* properties_required */\n-  PROP_trees,\t\t\t\t/* properties_provided */\n+  PROP_cfg,\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  TODO_dump_cgraph | TODO_dump_func,\t/* todo_flags_finish */\n+  0\t\t\t\t\t/* letter */\n+};\n+\n+/* Do inlining of small functions.  Doing so early helps profiling and other\n+   passes to be somewhat more effective and avoids some code duplication in\n+   later real inlining pass for testcases with very many function calls.  */\n+static void\n+cgraph_early_inlining (void)\n+{\n+  struct cgraph_node *node;\n+  int nnodes;\n+  struct cgraph_node **order =\n+    xcalloc (cgraph_n_nodes, sizeof (struct cgraph_node *));\n+  int i;\n+\n+  if (sorrycount || errorcount)\n+    return;\n+#ifdef ENABLE_CHECKING\n+  for (node = cgraph_nodes; node; node = node->next)\n+    gcc_assert (!node->aux);\n+#endif\n+\n+  nnodes = cgraph_postorder (order);\n+  for (i = nnodes - 1; i >= 0; i--)\n+    {\n+      node = order[i];\n+      if (node->analyzed && node->local.inlinable\n+\t  && (node->needed || node->reachable)\n+\t  && node->callers)\n+\tcgraph_decide_inlining_incrementally (node, true);\n+    }\n+  cgraph_remove_unreachable_nodes (true, dump_file);\n+#ifdef ENABLE_CHECKING\n+  for (node = cgraph_nodes; node; node = node->next)\n+    gcc_assert (!node->global.inlined_to);\n+#endif\n+  free (order);\n+}\n+\n+/* When inlining shall be performed.  */\n+static bool\n+cgraph_gate_early_inlining (void)\n+{\n+  return flag_inline_trees && flag_early_inlining;\n+}\n+\n+struct tree_opt_pass pass_early_ipa_inline = \n+{\n+  \"einline\",\t \t\t\t/* name */\n+  cgraph_gate_early_inlining,\t\t/* gate */\n+  cgraph_early_inlining,\t\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  TV_INTEGRATION,\t\t\t/* tv_id */\n+  0,\t                                /* properties_required */\n+  PROP_cfg,\t\t\t\t/* properties_provided */\n   0,\t\t\t\t\t/* properties_destroyed */\n   0,\t\t\t\t\t/* todo_flags_start */\n   TODO_dump_cgraph | TODO_dump_func,\t/* todo_flags_finish */"}, {"sha": "20c90415e9d3db7d4ab84830fff89fa4ef23d279", "filename": "gcc/ipa.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d63db217aed8c803f7d8b85910d6c8cfedc2acca/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d63db217aed8c803f7d8b85910d6c8cfedc2acca/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=d63db217aed8c803f7d8b85910d6c8cfedc2acca", "patch": "@@ -83,6 +83,8 @@ cgraph_postorder (struct cgraph_node **order)\n \t  }\n       }\n   free (stack);\n+  for (node = cgraph_nodes; node; node = node->next)\n+    node->aux = NULL;\n   return order_pos;\n }\n "}, {"sha": "665707056f66fd548ffcac062eba939beb317c7a", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d63db217aed8c803f7d8b85910d6c8cfedc2acca/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d63db217aed8c803f7d8b85910d6c8cfedc2acca/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=d63db217aed8c803f7d8b85910d6c8cfedc2acca", "patch": "@@ -1969,7 +1969,9 @@ expand_call_inline (basic_block bb, tree stmt, tree *tp, void *data)\n       else if (warn_inline && DECL_DECLARED_INLINE_P (fn)\n \t       && !DECL_IN_SYSTEM_HEADER (fn)\n \t       && strlen (reason)\n-\t       && !lookup_attribute (\"noinline\", DECL_ATTRIBUTES (fn)))\n+\t       && !lookup_attribute (\"noinline\", DECL_ATTRIBUTES (fn))\n+\t       /* Avoid warnings during early inline pass. */\n+\t       && (!flag_unit_at_a_time || cgraph_global_info_ready))\n \t{\n \t  warning (0, \"%Jinlining failed in call to %qF: %s\", fn, fn, reason);\n \t  warning (0, \"called from here\");"}, {"sha": "5ebd204c1a9a61588e956ff322ca6d3e24cd4e2e", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 57, "deletions": 3, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d63db217aed8c803f7d8b85910d6c8cfedc2acca/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d63db217aed8c803f7d8b85910d6c8cfedc2acca/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=d63db217aed8c803f7d8b85910d6c8cfedc2acca", "patch": "@@ -55,7 +55,7 @@ int dump_flags;\n bool in_gimple_form;\n \n /* The root of the compilation pass tree, once constructed.  */\n-static struct tree_opt_pass *all_passes, *all_ipa_passes, * all_lowering_passes;\n+static struct tree_opt_pass *all_passes, *all_ipa_passes, *all_lowering_passes;\n \n /* Gate: execute, or not, all of the non-trivial optimizations.  */\n \n@@ -84,6 +84,52 @@ static struct tree_opt_pass pass_all_optimizations =\n   0\t\t\t\t\t/* letter */\n };\n \n+static struct tree_opt_pass pass_early_local_passes =\n+{\n+  NULL,\t\t\t\t\t/* name */\n+  gate_all_optimizations,\t\t/* gate */\n+  NULL,\t\t\t\t\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  0,\t\t\t\t\t/* tv_id */\n+  0,\t\t\t\t\t/* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  0,\t\t\t\t\t/* todo_flags_finish */\n+  0\t\t\t\t\t/* letter */\n+};\n+\n+/* Pass: cleanup the CFG just before expanding trees to RTL.\n+   This is just a round of label cleanups and case node grouping\n+   because after the tree optimizers have run such cleanups may\n+   be necessary.  */\n+\n+static void \n+execute_cleanup_cfg_pre_ipa (void)\n+{\n+  cleanup_tree_cfg ();\n+}\n+\n+static struct tree_opt_pass pass_cleanup_cfg =\n+{\n+  \"cleanup_cfg\",\t\t\t/* name */\n+  NULL,\t\t\t\t\t/* gate */\n+  execute_cleanup_cfg_pre_ipa,\t\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  0,\t\t\t\t\t/* tv_id */\n+  PROP_cfg,\t\t\t\t/* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  TODO_dump_func,\t\t\t\t\t/* todo_flags_finish */\n+  0\t\t\t\t\t/* letter */\n+};\n+\n+\n /* Pass: cleanup the CFG just before expanding trees to RTL.\n    This is just a round of label cleanups and case node grouping\n    because after the tree optimizers have run such cleanups may\n@@ -322,7 +368,7 @@ register_dump_files (struct tree_opt_pass *pass, bool ipa, int properties)\n         n++;\n \n       if (pass->sub)\n-        new_properties = register_dump_files (pass->sub, ipa, new_properties);\n+        new_properties = register_dump_files (pass->sub, false, new_properties);\n \n       /* If we have a gate, combine the properties that we could have with\n          and without the pass being examined.  */\n@@ -390,6 +436,8 @@ init_tree_optimization_passes (void)\n #define NEXT_PASS(PASS)  (p = next_pass_1 (p, &PASS))\n   /* Intraprocedural optimization passes.  */\n   p = &all_ipa_passes;\n+  NEXT_PASS (pass_early_ipa_inline);\n+  NEXT_PASS (pass_early_local_passes);\n   NEXT_PASS (pass_ipa_inline);\n   *p = NULL;\n \n@@ -405,7 +453,13 @@ init_tree_optimization_passes (void)\n   NEXT_PASS (pass_lower_complex_O0);\n   NEXT_PASS (pass_lower_vector);\n   NEXT_PASS (pass_warn_function_return);\n+  NEXT_PASS (pass_early_tree_profile);\n+  *p = NULL;\n+\n+  p = &pass_early_local_passes.sub;\n   NEXT_PASS (pass_tree_profile);\n+  NEXT_PASS (pass_cleanup_cfg);\n+  NEXT_PASS (pass_rebuild_cgraph_edges);\n   *p = NULL;\n \n   p = &all_passes;\n@@ -716,7 +770,7 @@ execute_ipa_pass_list (struct tree_opt_pass *pass)\n \t      {\n \t\tpush_cfun (DECL_STRUCT_FUNCTION (node->decl));\n \t\tcurrent_function_decl = node->decl;\n-\t\texecute_pass_list (pass);\n+\t\texecute_pass_list (pass->sub);\n \t\tfree_dominance_info (CDI_DOMINATORS);\n \t\tfree_dominance_info (CDI_POST_DOMINATORS);\n \t\tcurrent_function_decl = NULL;"}, {"sha": "e6acea4fdf1b10fe81bdadc50cff82803ecf0a5d", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d63db217aed8c803f7d8b85910d6c8cfedc2acca/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d63db217aed8c803f7d8b85910d6c8cfedc2acca/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=d63db217aed8c803f7d8b85910d6c8cfedc2acca", "patch": "@@ -164,6 +164,7 @@ extern struct tree_opt_pass pass_lower_cf;\n extern struct tree_opt_pass pass_lower_eh;\n extern struct tree_opt_pass pass_build_cfg;\n extern struct tree_opt_pass pass_tree_profile;\n+extern struct tree_opt_pass pass_early_tree_profile;\n extern struct tree_opt_pass pass_referenced_vars;\n extern struct tree_opt_pass pass_sra;\n extern struct tree_opt_pass pass_tail_recursion;\n@@ -227,8 +228,10 @@ extern struct tree_opt_pass pass_del_pta;\n extern struct tree_opt_pass pass_uncprop;\n extern struct tree_opt_pass pass_return_slot;\n extern struct tree_opt_pass pass_reassoc;\n+extern struct tree_opt_pass pass_rebuild_cgraph_edges;\n \n /* IPA Passes */\n extern struct tree_opt_pass pass_ipa_inline;\n+extern struct tree_opt_pass pass_early_ipa_inline;\n \n #endif /* GCC_TREE_PASS_H */"}, {"sha": "a19e3a42ad1c0b6a97a3676e0a64992a6e0b442a", "filename": "gcc/tree-profile.c", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d63db217aed8c803f7d8b85910d6c8cfedc2acca/gcc%2Ftree-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d63db217aed8c803f7d8b85910d6c8cfedc2acca/gcc%2Ftree-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-profile.c?ref=d63db217aed8c803f7d8b85910d6c8cfedc2acca", "patch": "@@ -273,6 +273,33 @@ struct tree_opt_pass pass_tree_profile =\n   0\t\t\t\t\t/* letter */\n };\n \n+/* Return 1 if tree-based profiling is in effect, else 0.\n+   If it is, set up hooks for tree-based profiling.\n+   Gate for pass_tree_profile.  */\n+\n+static bool\n+do_early_tree_profiling (void)\n+{\n+  return (do_tree_profiling () && (!flag_unit_at_a_time || !optimize));\n+}\n+\n+struct tree_opt_pass pass_early_tree_profile = \n+{\n+  \"early_tree_profile\",\t\t\t/* name */\n+  do_early_tree_profiling,\t\t/* gate */\n+  tree_profiling,\t\t\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  TV_BRANCH_PROB,\t\t\t/* tv_id */\n+  PROP_gimple_leh | PROP_cfg,\t\t/* properties_required */\n+  PROP_gimple_leh | PROP_cfg,\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  TODO_verify_stmts,\t\t\t/* todo_flags_finish */\n+  0\t\t\t\t\t/* letter */\n+};\n+\n struct profile_hooks tree_profile_hooks =\n {\n   tree_init_edge_profiler,      /* init_edge_profiler */"}]}