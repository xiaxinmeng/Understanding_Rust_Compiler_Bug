{"sha": "3ba4ff4130903a3ded931d715a2204bd8834fe60", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2JhNGZmNDEzMDkwM2EzZGVkOTMxZDcxNWEyMjA0YmQ4ODM0ZmU2MA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-05-09T10:35:31Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-05-09T10:35:31Z"}, "message": "Add clobbers around IFN_LOAD/STORE_LANES\n\nWe build up the input to IFN_STORE_LANES one vector at a time.\nIn RTL, each of these vector assignments becomes a write to\nsubregs of the form (subreg:VEC (reg:AGGR R)), where R is the\neventual input to the store lanes instruction.  The problem is\nthat RTL isn't very good at tracking liveness when things are\ninitialised piecemeal by subregs, so R tends to end up being\nlive on all paths from the entry block to the store.  This in\nturn leads to unnecessary spilling around calls, as well as to\nexcess register pressure in vector loops.\n\nThis patch adds gimple clobbers to indicate the liveness of the\nIFN_STORE_LANES variable and makes sure that gimple clobbers are\nexpanded to rtl clobbers where useful.  For consistency it also\nuses clobbers to mark the point at which an IFN_LOAD_LANES\nvariable is no longer needed.\n\n2018-05-08  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* cfgexpand.c (expand_clobber): New function.\n\t(expand_gimple_stmt_1): Use it.\n\t* tree-vect-stmts.c (vect_clobber_variable): New function,\n\tsplit out from...\n\t(vectorizable_simd_clone_call): ...here.\n\t(vectorizable_store): Emit a clobber either side of an\n\tIFN_STORE_LANES sequence.\n\t(vectorizable_load): Emit a clobber after an IFN_LOAD_LANES sequence.\n\ngcc/testsuite/\n\t* gcc.target/aarch64/store_lane_spill_1.c: New test.\n\t* gcc.target/aarch64/sve/store_lane_spill_1.c: Likewise.\n\nFrom-SVN: r260073", "tree": {"sha": "b4169b8ee2397d6e437e42db8eb32d752bd0347b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b4169b8ee2397d6e437e42db8eb32d752bd0347b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ba4ff4130903a3ded931d715a2204bd8834fe60", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ba4ff4130903a3ded931d715a2204bd8834fe60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ba4ff4130903a3ded931d715a2204bd8834fe60", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ba4ff4130903a3ded931d715a2204bd8834fe60/comments", "author": null, "committer": null, "parents": [{"sha": "82191cbf3f277d73b52a79599b329b52fd567f83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82191cbf3f277d73b52a79599b329b52fd567f83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82191cbf3f277d73b52a79599b329b52fd567f83"}], "stats": {"total": 122, "additions": 105, "deletions": 17}, "files": [{"sha": "83d01edb0408da1469880c157b5562c3c76a0c25", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ba4ff4130903a3ded931d715a2204bd8834fe60/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ba4ff4130903a3ded931d715a2204bd8834fe60/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3ba4ff4130903a3ded931d715a2204bd8834fe60", "patch": "@@ -1,3 +1,14 @@\n+2018-05-09  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* cfgexpand.c (expand_clobber): New function.\n+\t(expand_gimple_stmt_1): Use it.\n+\t* tree-vect-stmts.c (vect_clobber_variable): New function,\n+\tsplit out from...\n+\t(vectorizable_simd_clone_call): ...here.\n+\t(vectorizable_store): Emit a clobber either side of an\n+\tIFN_STORE_LANES sequence.\n+\t(vectorizable_load): Emit a clobber after an IFN_LOAD_LANES sequence.\n+\n 2018-05-09  Tom de Vries  <tom@codesourcery.com>\n \n \tPR target/85626"}, {"sha": "ef143a35aee5d0dcecfb19491d89dbbef8725ff0", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ba4ff4130903a3ded931d715a2204bd8834fe60/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ba4ff4130903a3ded931d715a2204bd8834fe60/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=3ba4ff4130903a3ded931d715a2204bd8834fe60", "patch": "@@ -3582,6 +3582,26 @@ expand_return (tree retval, tree bounds)\n     }\n }\n \n+/* Expand a clobber of LHS.  If LHS is stored it in a multi-part\n+   register, tell the rtl optimizers that its value is no longer\n+   needed.  */\n+\n+static void\n+expand_clobber (tree lhs)\n+{\n+  if (DECL_P (lhs))\n+    {\n+      rtx decl_rtl = DECL_RTL_IF_SET (lhs);\n+      if (decl_rtl && REG_P (decl_rtl))\n+\t{\n+\t  machine_mode decl_mode = GET_MODE (decl_rtl);\n+\t  if (maybe_gt (GET_MODE_SIZE (decl_mode),\n+\t\t\tREGMODE_NATURAL_SIZE (decl_mode)))\n+\t    emit_clobber (decl_rtl);\n+\t}\n+    }\n+}\n+\n /* A subroutine of expand_gimple_stmt, expanding one gimple statement\n    STMT that doesn't require special handling for outgoing edges.  That\n    is no tailcalls and no GIMPLE_COND.  */\n@@ -3687,7 +3707,7 @@ expand_gimple_stmt_1 (gimple *stmt)\n \t    if (TREE_CLOBBER_P (rhs))\n \t      /* This is a clobber to mark the going out of scope for\n \t\t this LHS.  */\n-\t      ;\n+\t      expand_clobber (lhs);\n \t    else\n \t      expand_assignment (lhs, rhs,\n \t\t\t\t gimple_assign_nontemporal_move_p ("}, {"sha": "85c22554bd48ac2c868e150b9a5b09ed3ab552f1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ba4ff4130903a3ded931d715a2204bd8834fe60/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ba4ff4130903a3ded931d715a2204bd8834fe60/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3ba4ff4130903a3ded931d715a2204bd8834fe60", "patch": "@@ -1,3 +1,8 @@\n+2018-05-09  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* gcc.target/aarch64/store_lane_spill_1.c: New test.\n+\t* gcc.target/aarch64/sve/store_lane_spill_1.c: Likewise.\n+\n 2018-05-08  Carl Love  <cel@us.ibm.com>\n \t* gcc.target/powerpc/builtins-8-p9-runnable.c: Add new test file.\n "}, {"sha": "80683c27353ba407fe33cf9e82d3658cdd4577c1", "filename": "gcc/testsuite/gcc.target/aarch64/store_lane_spill_1.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ba4ff4130903a3ded931d715a2204bd8834fe60/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstore_lane_spill_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ba4ff4130903a3ded931d715a2204bd8834fe60/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstore_lane_spill_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstore_lane_spill_1.c?ref=3ba4ff4130903a3ded931d715a2204bd8834fe60", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#pragma GCC target \"+nosve\"\n+\n+int cont (void);\n+\n+void\n+f (int (*x)[3], int *a, int *b, int *c, int n)\n+{\n+  do\n+    for (int i = 0; i < n; ++i)\n+      {\n+\tx[i][0] = a[i] + 1;\n+\tx[i][1] = b[i] + 2;\n+\tx[i][2] = c[i] + 3;\n+      }\n+  while (cont ());\n+}\n+\n+/* { dg-final { scan-assembler-not {\\tst1\\t} } } */"}, {"sha": "7e17f6268e33725767554a888111e3153d6e5ea4", "filename": "gcc/testsuite/gcc.target/aarch64/sve/store_lane_spill_1.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ba4ff4130903a3ded931d715a2204bd8834fe60/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstore_lane_spill_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ba4ff4130903a3ded931d715a2204bd8834fe60/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstore_lane_spill_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstore_lane_spill_1.c?ref=3ba4ff4130903a3ded931d715a2204bd8834fe60", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+int cont (void);\n+\n+void\n+f (int (*x)[3], int *a, int *b, int *c, int n)\n+{\n+  do\n+    for (int i = 0; i < n; ++i)\n+      {\n+\tx[i][0] = a[i] + 1;\n+\tx[i][1] = b[i] + 2;\n+\tx[i][2] = c[i] + 3;\n+      }\n+  while (cont ());\n+}\n+\n+/* { dg-final { scan-assembler-not {\\tstr\\tz[0-9]} } } */"}, {"sha": "1e8ccbce2af0d0c02ad2cd48a3ffabde4d0e9e7a", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 28, "deletions": 16, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ba4ff4130903a3ded931d715a2204bd8834fe60/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ba4ff4130903a3ded931d715a2204bd8834fe60/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=3ba4ff4130903a3ded931d715a2204bd8834fe60", "patch": "@@ -182,6 +182,17 @@ create_array_ref (tree type, tree ptr, tree alias_ptr_type)\n   return mem_ref;\n }\n \n+/* Add a clobber of variable VAR to the vectorization of STMT.\n+   Emit the clobber before *GSI.  */\n+\n+static void\n+vect_clobber_variable (gimple *stmt, gimple_stmt_iterator *gsi, tree var)\n+{\n+  tree clobber = build_clobber (TREE_TYPE (var));\n+  gimple *new_stmt = gimple_build_assign (var, clobber);\n+  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+}\n+\n /* Utility functions used by vect_mark_stmts_to_be_vectorized.  */\n \n /* Function vect_mark_relevant.\n@@ -4128,12 +4139,7 @@ vectorizable_simd_clone_call (gimple *stmt, gimple_stmt_iterator *gsi,\n \t\t}\n \n \t      if (ratype)\n-\t\t{\n-\t\t  tree clobber = build_constructor (ratype, NULL);\n-\t\t  TREE_THIS_VOLATILE (clobber) = 1;\n-\t\t  new_stmt = gimple_build_assign (new_temp, clobber);\n-\t\t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n-\t\t}\n+\t\tvect_clobber_variable (stmt, gsi, new_temp);\n \t      continue;\n \t    }\n \t  else if (simd_clone_subparts (vectype) > nunits)\n@@ -4156,10 +4162,7 @@ vectorizable_simd_clone_call (gimple *stmt, gimple_stmt_iterator *gsi,\n \t\t      CONSTRUCTOR_APPEND_ELT (ret_ctor_elts, NULL_TREE,\n \t\t\t\t\t      gimple_assign_lhs (new_stmt));\n \t\t    }\n-\t\t  tree clobber = build_constructor (ratype, NULL);\n-\t\t  TREE_THIS_VOLATILE (clobber) = 1;\n-\t\t  new_stmt = gimple_build_assign (new_temp, clobber);\n-\t\t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\t\t  vect_clobber_variable (stmt, gsi, new_temp);\n \t\t}\n \t      else\n \t\tCONSTRUCTOR_APPEND_ELT (ret_ctor_elts, NULL_TREE, new_temp);\n@@ -4186,11 +4189,7 @@ vectorizable_simd_clone_call (gimple *stmt, gimple_stmt_iterator *gsi,\n \t      new_stmt\n \t\t= gimple_build_assign (make_ssa_name (vec_dest), t);\n \t      vect_finish_stmt_generation (stmt, new_stmt, gsi);\n-\t      tree clobber = build_constructor (ratype, NULL);\n-\t      TREE_THIS_VOLATILE (clobber) = 1;\n-\t      vect_finish_stmt_generation (stmt,\n-\t\t\t\t\t   gimple_build_assign (new_temp,\n-\t\t\t\t\t\t\t\tclobber), gsi);\n+\t      vect_clobber_variable (stmt, gsi, new_temp);\n \t    }\n \t}\n \n@@ -6913,8 +6912,15 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t{\n \t  tree vec_array;\n \n-\t  /* Combine all the vectors into an array.  */\n+\t  /* Get an array into which we can store the individual vectors.  */\n \t  vec_array = create_vector_array (vectype, vec_num);\n+\n+\t  /* Invalidate the current contents of VEC_ARRAY.  This should\n+\t     become an RTL clobber too, which prevents the vector registers\n+\t     from being upward-exposed.  */\n+\t  vect_clobber_variable (stmt, gsi, vec_array);\n+\n+\t  /* Store the individual vectors into the array.  */\n \t  for (i = 0; i < vec_num; i++)\n \t    {\n \t      vec_oprnd = dr_chain[i];\n@@ -6953,6 +6959,9 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t  gimple_call_set_nothrow (call, true);\n \t  new_stmt = call;\n \t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\n+\t  /* Record that VEC_ARRAY is now dead.  */\n+\t  vect_clobber_variable (stmt, gsi, vec_array);\n \t}\n       else\n \t{\n@@ -8105,6 +8114,9 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \n \t  /* Record the mapping between SSA_NAMEs and statements.  */\n \t  vect_record_grouped_load_vectors (stmt, dr_chain);\n+\n+\t  /* Record that VEC_ARRAY is now dead.  */\n+\t  vect_clobber_variable (stmt, gsi, vec_array);\n \t}\n       else\n \t{"}]}