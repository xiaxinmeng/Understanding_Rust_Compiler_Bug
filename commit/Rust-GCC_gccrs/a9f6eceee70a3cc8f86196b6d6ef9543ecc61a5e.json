{"sha": "a9f6eceee70a3cc8f86196b6d6ef9543ecc61a5e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTlmNmVjZWVlNzBhM2NjOGY4NjE5NmI2ZDZlZjk1NDNlY2M2MWE1ZQ==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2009-06-02T17:47:33Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2009-06-02T17:47:33Z"}, "message": "loop-unroll.c (struct iv_to_split): Add pointer to next.\n\n* loop-unroll.c (struct iv_to_split): Add pointer to next.\n(struct var_to_expand): Likewise.\n(struct opt_info): Add head and tail for linked lists of the above.\n(analyze_insn_to_expand_var): Initialize next.\n(analyze_iv_to_split_insn): Likewise.\n(analyze_insns_in_loop): Create linked lists.\n(allocate_basic_variable): Simplify for use without hash table.\n(insert_var_expansion_initialization): Likewise, make it type-safer.\n(combine_var_copies_in_loop_exit): Likewise.\n(apply_opt_in_copies): Walk lists rather than hash tables.\n(release_var_copies): Simplified and inlined by hand into...\n(free_opt_info): ... this function.\n\nFrom-SVN: r148090", "tree": {"sha": "fff566f45e105f21094d680c335487d6024dd7a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fff566f45e105f21094d680c335487d6024dd7a9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a9f6eceee70a3cc8f86196b6d6ef9543ecc61a5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9f6eceee70a3cc8f86196b6d6ef9543ecc61a5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9f6eceee70a3cc8f86196b6d6ef9543ecc61a5e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9f6eceee70a3cc8f86196b6d6ef9543ecc61a5e/comments", "author": null, "committer": null, "parents": [{"sha": "4ea08463a743ae12a5273368c2cc50743818ad48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ea08463a743ae12a5273368c2cc50743818ad48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ea08463a743ae12a5273368c2cc50743818ad48"}], "stats": {"total": 142, "additions": 77, "deletions": 65}, "files": [{"sha": "8e95dfefb70e145a6cde1c55b07fe3fbf0961480", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9f6eceee70a3cc8f86196b6d6ef9543ecc61a5e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9f6eceee70a3cc8f86196b6d6ef9543ecc61a5e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a9f6eceee70a3cc8f86196b6d6ef9543ecc61a5e", "patch": "@@ -1,3 +1,18 @@\n+2009-06-02  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\t* loop-unroll.c (struct iv_to_split): Add pointer to next.\n+\t(struct var_to_expand): Likewise.\n+\t(struct opt_info): Add head and tail for linked lists of the above.\n+\t(analyze_insn_to_expand_var): Initialize next.\n+\t(analyze_iv_to_split_insn): Likewise.\n+\t(analyze_insns_in_loop): Create linked lists.\n+\t(allocate_basic_variable): Simplify for use without hash table.\n+\t(insert_var_expansion_initialization): Likewise, make it type-safer.\n+\t(combine_var_copies_in_loop_exit): Likewise.\n+\t(apply_opt_in_copies): Walk lists rather than hash tables.\n+\t(release_var_copies): Simplified and inlined by hand into...\n+\t(free_opt_info): ... this function.\n+\n 2009-06-02  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-ssa-sccvn.c (copy_reference_ops_from_ref): Use DECL_SIZE"}, {"sha": "8812e68805baab628640cd55345971c7afadaea8", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 62, "deletions": 65, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9f6eceee70a3cc8f86196b6d6ef9543ecc61a5e/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9f6eceee70a3cc8f86196b6d6ef9543ecc61a5e/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=a9f6eceee70a3cc8f86196b6d6ef9543ecc61a5e", "patch": "@@ -77,6 +77,7 @@ struct iv_to_split\n   rtx base_var;\t\t/* The variable on that the values in the further\n \t\t\t   iterations are based.  */\n   rtx step;\t\t/* Step of the induction variable.  */\n+  struct iv_to_split *next; /* Next entry in walking order.  */\n   unsigned n_loc;\n   unsigned loc[3];\t/* Location where the definition of the induction\n \t\t\t   variable occurs in the insn.  For example if\n@@ -91,6 +92,7 @@ struct var_to_expand\n   rtx insn;\t\t           /* The insn in that the variable expansion occurs.  */\n   rtx reg;                         /* The accumulator which is expanded.  */\n   VEC(rtx,heap) *var_expansions;   /* The copies of the accumulator which is expanded.  */ \n+  struct var_to_expand *next;\t   /* Next entry in walking order.  */\n   enum rtx_code op;                /* The type of the accumulation - addition, subtraction \n                                       or multiplication.  */\n   int expansion_count;             /* Count the number of expansions generated so far.  */\n@@ -110,8 +112,12 @@ struct var_to_expand\n struct opt_info\n {\n   htab_t insns_to_split;           /* A hashtable of insns to split.  */\n+  struct iv_to_split *iv_to_split_head; /* The first iv to split.  */\n+  struct iv_to_split **iv_to_split_tail; /* Pointer to the tail of the list.  */\n   htab_t insns_with_var_to_expand; /* A hashtable of insns with accumulators\n                                       to expand.  */\n+  struct var_to_expand *var_to_expand_head; /* The first var to expand.  */\n+  struct var_to_expand **var_to_expand_tail; /* Pointer to the tail of the list.  */\n   unsigned first_new_block;        /* The first basic block that was\n                                       duplicated.  */\n   basic_block loop_exit;           /* The loop exit basic block.  */\n@@ -139,9 +145,10 @@ static struct var_to_expand *analyze_insn_to_expand_var (struct loop*, rtx);\n static bool referenced_in_one_insn_in_loop_p (struct loop *, rtx);\n static struct iv_to_split *analyze_iv_to_split_insn (rtx);\n static void expand_var_during_unrolling (struct var_to_expand *, rtx);\n-static int insert_var_expansion_initialization (void **, void *);\n-static int combine_var_copies_in_loop_exit (void **, void *);\n-static int release_var_copies (void **, void *);\n+static void insert_var_expansion_initialization (struct var_to_expand *,\n+\t\t\t\t\t\t basic_block);\n+static void combine_var_copies_in_loop_exit (struct var_to_expand *,\n+\t\t\t\t\t     basic_block);\n static rtx get_expansion (struct var_to_expand *);\n \n /* Unroll and/or peel (depending on FLAGS) LOOPS.  */\n@@ -1646,8 +1653,9 @@ analyze_insn_to_expand_var (struct loop *loop, rtx insn)\n   /* Record the accumulator to expand.  */\n   ves = XNEW (struct var_to_expand);\n   ves->insn = insn;\n-  ves->var_expansions = VEC_alloc (rtx, heap, 1);\n   ves->reg = copy_rtx (dest);\n+  ves->var_expansions = VEC_alloc (rtx, heap, 1);\n+  ves->next = NULL;\n   ves->op = GET_CODE (src);\n   ves->expansion_count = 0;\n   ves->reuse_expansion = 0;\n@@ -1723,6 +1731,7 @@ analyze_iv_to_split_insn (rtx insn)\n   ivts->insn = insn;\n   ivts->base_var = NULL_RTX;\n   ivts->step = iv.step;\n+  ivts->next = NULL;\n   ivts->n_loc = 1;\n   ivts->loc[0] = 1;\n   \n@@ -1754,8 +1763,12 @@ analyze_insns_in_loop (struct loop *loop)\n   body = get_loop_body (loop);\n \n   if (flag_split_ivs_in_unroller)\n-    opt_info->insns_to_split = htab_create (5 * loop->num_nodes,\n-                                            si_info_hash, si_info_eq, free);\n+    {\n+      opt_info->insns_to_split = htab_create (5 * loop->num_nodes,\n+\t\t\t\t\t      si_info_hash, si_info_eq, free);\n+      opt_info->iv_to_split_head = NULL;\n+      opt_info->iv_to_split_tail = &opt_info->iv_to_split_head;\n+    }\n   \n   /* Record the loop exit bb and loop preheader before the unrolling.  */\n   opt_info->loop_preheader = loop_preheader_edge (loop)->src;\n@@ -1772,8 +1785,13 @@ analyze_insns_in_loop (struct loop *loop)\n   \n   if (flag_variable_expansion_in_unroller\n       && can_apply)\n-    opt_info->insns_with_var_to_expand = htab_create (5 * loop->num_nodes,\n-\t\t\t\t\t\t      ve_info_hash, ve_info_eq, free);\n+    {\n+      opt_info->insns_with_var_to_expand = htab_create (5 * loop->num_nodes,\n+\t\t\t\t\t\t\tve_info_hash,\n+\t\t\t\t\t\t\tve_info_eq, free);\n+      opt_info->var_to_expand_head = NULL;\n+      opt_info->var_to_expand_tail = &opt_info->var_to_expand_head;\n+    }\n   \n   for (i = 0; i < loop->num_nodes; i++)\n     {\n@@ -1792,7 +1810,10 @@ analyze_insns_in_loop (struct loop *loop)\n         if (ivts)\n           {\n             slot1 = htab_find_slot (opt_info->insns_to_split, ivts, INSERT);\n+\t    gcc_assert (*slot1 == NULL);\n             *slot1 = ivts;\n+\t    *opt_info->iv_to_split_tail = ivts;\n+\t    opt_info->iv_to_split_tail = &ivts->next;\n             continue;\n           }\n         \n@@ -1802,7 +1823,10 @@ analyze_insns_in_loop (struct loop *loop)\n         if (ves)\n           {\n             slot2 = htab_find_slot (opt_info->insns_with_var_to_expand, ves, INSERT);\n+\t    gcc_assert (*slot2 == NULL);\n             *slot2 = ves;\n+\t    *opt_info->var_to_expand_tail = ves;\n+\t    opt_info->var_to_expand_tail = &ves->next;\n           }\n       }\n     }\n@@ -1862,18 +1886,14 @@ get_ivts_expr (rtx expr, struct iv_to_split *ivts)\n   return ret;\n }\n \n-/* Allocate basic variable for the induction variable chain.  Callback for\n-   htab_traverse.  */\n+/* Allocate basic variable for the induction variable chain.  */\n \n-static int\n-allocate_basic_variable (void **slot, void *data ATTRIBUTE_UNUSED)\n+static void\n+allocate_basic_variable (struct iv_to_split *ivts)\n {\n-  struct iv_to_split *ivts = (struct iv_to_split *) *slot;\n   rtx expr = *get_ivts_expr (single_set (ivts->insn), ivts);\n \n   ivts->base_var = gen_reg_rtx (GET_MODE (expr));\n-\n-  return 1;\n }\n \n /* Insert initialization of basic variable of IVTS before INSN, taking\n@@ -2010,14 +2030,13 @@ expand_var_during_unrolling (struct var_to_expand *ve, rtx insn)\n       }\n }\n \n-/* Initialize the variable expansions in loop preheader.  \n-   Callbacks for htab_traverse.  PLACE_P is the loop-preheader \n-   basic block where the initialization of the expansions \n-   should take place.  The expansions are initialized with (-0)\n-   when the operation is plus or minus to honor sign zero.\n-   This way we can prevent cases where the sign of the final result is\n-   effected by the sign of the expansion.\n-   Here is an example to demonstrate this:\n+/* Initialize the variable expansions in loop preheader.  PLACE is the\n+   loop-preheader basic block where the initialization of the\n+   expansions should take place.  The expansions are initialized with\n+   (-0) when the operation is plus or minus to honor sign zero.  This\n+   way we can prevent cases where the sign of the final result is\n+   effected by the sign of the expansion.  Here is an example to\n+   demonstrate this:\n    \n    for (i = 0 ; i < n; i++)\n      sum += something;\n@@ -2038,18 +2057,17 @@ expand_var_during_unrolling (struct var_to_expand *ve, rtx insn)\n    should be initialized with -zero as well (otherwise we will get +zero\n    as the final result).  */\n \n-static int\n-insert_var_expansion_initialization (void **slot, void *place_p)\n+static void\n+insert_var_expansion_initialization (struct var_to_expand *ve,\n+\t\t\t\t     basic_block place)\n {\n-  struct var_to_expand *ve = (struct var_to_expand *) *slot;\n-  basic_block place = (basic_block)place_p;\n   rtx seq, var, zero_init, insn;\n   unsigned i;\n   enum machine_mode mode = GET_MODE (ve->reg);\n   bool honor_signed_zero_p = HONOR_SIGNED_ZEROS (mode);\n \n   if (VEC_length (rtx, ve->var_expansions) == 0)\n-    return 1;\n+    return;\n   \n   start_sequence ();\n   if (ve->op == PLUS || ve->op == MINUS) \n@@ -2077,26 +2095,21 @@ insert_var_expansion_initialization (void **slot, void *place_p)\n     insn = NEXT_INSN (insn);\n   \n   emit_insn_after (seq, insn); \n-  /* Continue traversing the hash table.  */\n-  return 1;   \n }\n \n-/*  Combine the variable expansions at the loop exit.  \n-    Callbacks for htab_traverse.  PLACE_P is the loop exit\n-    basic block where the summation of the expansions should \n-    take place.  */\n+/* Combine the variable expansions at the loop exit.  PLACE is the\n+   loop exit basic block where the summation of the expansions should\n+   take place.  */\n \n-static int\n-combine_var_copies_in_loop_exit (void **slot, void *place_p)\n+static void\n+combine_var_copies_in_loop_exit (struct var_to_expand *ve, basic_block place)\n {\n-  struct var_to_expand *ve = (struct var_to_expand *) *slot;\n-  basic_block place = (basic_block)place_p;\n   rtx sum = ve->reg;\n   rtx expr, seq, var, insn;\n   unsigned i;\n \n   if (VEC_length (rtx, ve->var_expansions) == 0)\n-    return 1;\n+    return;\n   \n   start_sequence ();\n   if (ve->op == PLUS || ve->op == MINUS)\n@@ -2123,9 +2136,6 @@ combine_var_copies_in_loop_exit (void **slot, void *place_p)\n     insn = NEXT_INSN (insn);\n \n   emit_insn_after (seq, insn);\n-  \n-  /* Continue traversing the hash table.  */\n-  return 1;\n }\n \n /* Apply loop optimizations in loop copies using the \n@@ -2154,7 +2164,8 @@ apply_opt_in_copies (struct opt_info *opt_info,\n   \n   /* Allocate the basic variables (i0).  */\n   if (opt_info->insns_to_split)\n-    htab_traverse (opt_info->insns_to_split, allocate_basic_variable, NULL);\n+    for (ivts = opt_info->iv_to_split_head; ivts; ivts = ivts->next)\n+      allocate_basic_variable (ivts);\n   \n   for (i = opt_info->first_new_block; i < (unsigned) last_basic_block; i++)\n     {\n@@ -2218,12 +2229,10 @@ apply_opt_in_copies (struct opt_info *opt_info,\n      and take care of combining them at the loop exit.  */ \n   if (opt_info->insns_with_var_to_expand)\n     {\n-      htab_traverse (opt_info->insns_with_var_to_expand, \n-                     insert_var_expansion_initialization, \n-                     opt_info->loop_preheader);\n-      htab_traverse (opt_info->insns_with_var_to_expand, \n-                     combine_var_copies_in_loop_exit, \n-                     opt_info->loop_exit);\n+      for (ves = opt_info->var_to_expand_head; ves; ves = ves->next)\n+\tinsert_var_expansion_initialization (ves, opt_info->loop_preheader);\n+      for (ves = opt_info->var_to_expand_head; ves; ves = ves->next)\n+\tcombine_var_copies_in_loop_exit (ves, opt_info->loop_exit);\n     }\n   \n   /* Rewrite also the original loop body.  Find them as originals of the blocks\n@@ -2264,20 +2273,6 @@ apply_opt_in_copies (struct opt_info *opt_info,\n     }\n }\n \n-/*  Release the data structures used for the variable expansion\n-    optimization.  Callbacks for htab_traverse.  */\n-\n-static int\n-release_var_copies (void **slot, void *data ATTRIBUTE_UNUSED)\n-{\n-  struct var_to_expand *ve = (struct var_to_expand *) *slot;\n-  \n-  VEC_free (rtx, heap, ve->var_expansions);\n-  \n-  /* Continue traversing the hash table.  */\n-  return 1;\n-}\n-\n /* Release OPT_INFO.  */\n \n static void\n@@ -2287,8 +2282,10 @@ free_opt_info (struct opt_info *opt_info)\n     htab_delete (opt_info->insns_to_split);\n   if (opt_info->insns_with_var_to_expand)\n     {\n-      htab_traverse (opt_info->insns_with_var_to_expand, \n-                     release_var_copies, NULL);\n+      struct var_to_expand *ves;\n+\n+      for (ves = opt_info->var_to_expand_head; ves; ves = ves->next)\n+\tVEC_free (rtx, heap, ves->var_expansions);\n       htab_delete (opt_info->insns_with_var_to_expand);\n     }\n   free (opt_info);"}]}