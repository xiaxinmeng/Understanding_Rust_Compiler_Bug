{"sha": "f15b9af9843e58e7c03df81098a8a15646f5058e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjE1YjlhZjk4NDNlNThlN2MwM2RmODEwOThhOGExNTY0NmY1MDU4ZQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-10-01T19:19:30Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-10-01T19:19:30Z"}, "message": "c-decl.c (c_expand_body): Don't generate RTL if flag_syntax_only.\n\n\t* c-decl.c (c_expand_body): Don't generate RTL if flag_syntax_only.\n\t(lang_mark_false_label_stack): Remove.\n\t* c-lex.c (init_c_lex): Add file_info_tree as GC root.  Allocate\n\t<top level> string in GC area.\n\t(mark_splay_tree_node): New function.\n\t(mark_splay_tree): Likewise.\n\t* except.c (mark_eh_status): Only call lang_mark_false_label_stack\n\tif it exists.\n\t* ggc-callbacks.c (lang_mark_false_label_stack): Remove.\n\t* ggc-common.c (lang_mark_false_label_stack): Change type.\n\t* ggc.h (ggc_alloc_string): Add comment.\n\t(ggc_strdup): New function.\n\n\t* decl.c (lang_mark_false_label_stack): Remove.\n\t* lex.c (cp_mang_lang_type): Use ggc_alloc_cleared.\n\n\t* com.c (lang_mark_false_label_stack): Remove.\n\n\tConvert to GC.\n\t* Make-lang.in (s-java): Don't depend on ggc-callbacks.o.\n\t* Makefile.in (BACKEND): Don't include ggc-callbacks.o.\n\t(typeck.o): Depend on ggc.h.\n\t* class.c (add_method_1): Use GC functions for allocation.\n\t(init_class_processing): Register roots.\n\t* decl.c (ggc_p): Set to 1.\n\t(pending_local_decls): Make it static.\n\t(push_jvm_slot): Use GC functions for allocation.\n\t(init_decl_processing): Register roots.\n\t(give_name_to_locals): Use GC functions for allocation.\n\t(lang_mark_tree): New function.\n\t* java-tree.h (MAYBE_CREATE_TYPE_TYPE_LANG_SPECIFIC): Use GC\n\tfunctions for allocation.\n\t* jcf-parse.c (jcf_parse_source): Use ggc_strdup.\n\t* lex.c (java_lex): Use build_string, rather than replicating it\n\tinline.\n\t* parse.y (goal): Add more roots.\n\t(mark_parser_ctxt): New function.\n\t* typeck.c: Include ggc.h.\n\n\t* splay-tree.c (splay_tree_insert): Fix formatting.\n\nFrom-SVN: r36687", "tree": {"sha": "0d6ccc526e9f4b851ecc829d656097c5b7e9c8f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0d6ccc526e9f4b851ecc829d656097c5b7e9c8f8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f15b9af9843e58e7c03df81098a8a15646f5058e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f15b9af9843e58e7c03df81098a8a15646f5058e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f15b9af9843e58e7c03df81098a8a15646f5058e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f15b9af9843e58e7c03df81098a8a15646f5058e/comments", "author": null, "committer": null, "parents": [{"sha": "51296ba047eb7f4f266f97d7a26748dc108f7fd5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51296ba047eb7f4f266f97d7a26748dc108f7fd5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51296ba047eb7f4f266f97d7a26748dc108f7fd5"}], "stats": {"total": 303, "additions": 230, "deletions": 73}, "files": [{"sha": "93353aa38c31b41e5544a975d8ce7c65009f67a2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15b9af9843e58e7c03df81098a8a15646f5058e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15b9af9843e58e7c03df81098a8a15646f5058e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f15b9af9843e58e7c03df81098a8a15646f5058e", "patch": "@@ -1,3 +1,18 @@\n+2000-10-01  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* c-decl.c (c_expand_body): Don't generate RTL if flag_syntax_only.\n+\t(lang_mark_false_label_stack): Remove.\n+\t* c-lex.c (init_c_lex): Add file_info_tree as GC root.  Allocate\n+\t<top level> string in GC area.\n+\t(mark_splay_tree_node): New function.\n+\t(mark_splay_tree): Likewise.\n+\t* except.c (mark_eh_status): Only call lang_mark_false_label_stack\n+\tif it exists.\n+\t* ggc-callbacks.c (lang_mark_false_label_stack): Remove.\n+\t* ggc-common.c (lang_mark_false_label_stack): Change type.\n+\t* ggc.h (ggc_alloc_string): Add comment.\n+\t(ggc_strdup): New function.\n+\t\n Sat Sep 23 19:10:20 2000  Denis Chertykov  <denisc@overta.ru>\n \n \t* config/avr/avr.h (BRANCH_COST): Define as 0."}, {"sha": "940d4b18393c7298208f13e55661c1e0353dbd14", "filename": "gcc/c-decl.c", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15b9af9843e58e7c03df81098a8a15646f5058e/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15b9af9843e58e7c03df81098a8a15646f5058e/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=f15b9af9843e58e7c03df81098a8a15646f5058e", "patch": "@@ -6705,6 +6705,11 @@ c_expand_body (fndecl, nested_p)\n      tree fndecl;\n      int nested_p;\n {\n+  /* There's no reason to do any of the work here if we're only doing\n+     semantic analysis; this code just generates RTL.  */\n+  if (flag_syntax_only)\n+    return;\n+\n   /* Squirrel away our current state.  */\n   if (nested_p)\n     push_function_context ();\n@@ -6982,17 +6987,6 @@ copy_lang_decl (decl)\n   DECL_LANG_SPECIFIC (decl) = ld;\n }\n \n-/* Mark ARG for GC.  */\n-\n-void\n-lang_mark_false_label_stack (arg)\n-     struct label_node *arg;\n-{\n-  /* C doesn't use false_label_stack.  It better be NULL.  */\n-  if (arg != NULL)\n-    abort ();\n-}\n-\n /* Mark the language specific bits in T for GC.  */\n \n void"}, {"sha": "693615361fc9afc41a90ad38430d9653816bad6a", "filename": "gcc/c-lex.c", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15b9af9843e58e7c03df81098a8a15646f5058e/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15b9af9843e58e7c03df81098a8a15646f5058e/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=f15b9af9843e58e7c03df81098a8a15646f5058e", "patch": "@@ -149,6 +149,8 @@ static tree lex_string\t\tPARAMS ((const char *, unsigned int, int));\n static tree lex_charconst\tPARAMS ((const char *, unsigned int, int));\n static void update_header_times\tPARAMS ((const char *));\n static int dump_one_header\tPARAMS ((splay_tree_node, void *));\n+static int mark_splay_tree_node PARAMS ((splay_tree_node, void *));\n+static void mark_splay_tree     PARAMS ((void *));\n \n #if !USE_CPPLIB\n static int skip_white_space\t\tPARAMS ((int));\n@@ -176,7 +178,10 @@ init_c_lex (filename)\n   file_info_tree = splay_tree_new ((splay_tree_compare_fn)strcmp,\n \t\t\t\t   0,\n \t\t\t\t   (splay_tree_delete_value_fn)free);\n-  toplevel = get_fileinfo (\"<top level>\");\n+  /* Make sure to mark the filenames in the tree for GC.  */\n+  ggc_add_root (&file_info_tree, 1, sizeof (file_info_tree), \n+\t\tmark_splay_tree);\n+  toplevel = get_fileinfo (ggc_strdup (\"<top level>\"));\n   if (flag_detailed_statistics)\n     {\n       header_time = 0;\n@@ -2540,3 +2545,25 @@ lex_charconst (str, len, wide)\n \n   return value;\n }\n+\n+/* Mark for GC a node in a splay tree whose keys are strings.  */\n+\n+static int\n+mark_splay_tree_node (n, data)\n+     splay_tree_node n;\n+     void *data ATTRIBUTE_UNUSED;\n+{\n+  ggc_mark_string ((char *) n->key);\n+  return 0;\n+}\n+\n+/* Mark for GC a splay tree whose keys are strings.  */\n+\n+static void\n+mark_splay_tree (p)\n+     void *p;\n+{\n+  splay_tree st = *(splay_tree *) p;\n+  \n+  splay_tree_foreach (st, mark_splay_tree_node, NULL);\n+}"}, {"sha": "2adea2e6094cd699f5b8ba8bc28312ae86d88cb2", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15b9af9843e58e7c03df81098a8a15646f5058e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15b9af9843e58e7c03df81098a8a15646f5058e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f15b9af9843e58e7c03df81098a8a15646f5058e", "patch": "@@ -1,3 +1,8 @@\n+2000-10-01  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* decl.c (lang_mark_false_label_stack): Remove.\n+\t* lex.c (cp_mang_lang_type): Use ggc_alloc_cleared.\n+\t\n 2000-09-30  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* gxxint.texi: Use @email for formatting email addresses."}, {"sha": "d467f5a5f1bb1311ec1752fcff49f57580b0daf6", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15b9af9843e58e7c03df81098a8a15646f5058e/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15b9af9843e58e7c03df81098a8a15646f5058e/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=f15b9af9843e58e7c03df81098a8a15646f5058e", "patch": "@@ -14646,14 +14646,6 @@ mark_cp_function_context (f)\n   mark_lang_function ((struct cp_language_function *) f->language);\n }\n \n-void\n-lang_mark_false_label_stack (l)\n-     struct label_node *l;\n-{\n-  /* C++ doesn't use false_label_stack.  It better be NULL.  */\n-  my_friendly_assert (l == NULL, 19990904);\n-}\n-\n void\n lang_mark_tree (t)\n      tree t;"}, {"sha": "2b32d01f4b36e9bfdeae87f5b4890023f517a2ad", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15b9af9843e58e7c03df81098a8a15646f5058e/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15b9af9843e58e7c03df81098a8a15646f5058e/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=f15b9af9843e58e7c03df81098a8a15646f5058e", "patch": "@@ -1616,8 +1616,8 @@ cp_make_lang_type (code)\n     {\n       struct lang_type *pi;\n \n-      pi = (struct lang_type *) ggc_alloc (sizeof (struct lang_type));\n-      bzero ((char *) pi, (int) sizeof (struct lang_type));\n+      pi = ((struct lang_type *) \n+\t    ggc_alloc_cleared (sizeof (struct lang_type)));\n \n       TYPE_LANG_SPECIFIC (t) = pi;\n       SET_CLASSTYPE_INTERFACE_UNKNOWN_X (t, interface_unknown);"}, {"sha": "efa61e5bbefbf221e7524a501ac95ba0cb64377f", "filename": "gcc/except.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15b9af9843e58e7c03df81098a8a15646f5058e/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15b9af9843e58e7c03df81098a8a15646f5058e/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=f15b9af9843e58e7c03df81098a8a15646f5058e", "patch": "@@ -2607,7 +2607,8 @@ mark_eh_status (eh)\n   mark_eh_queue (eh->x_ehqueue);\n   ggc_mark_rtx (eh->x_catch_clauses);\n \n-  lang_mark_false_label_stack (eh->x_false_label_stack);\n+  if (lang_mark_false_label_stack)\n+    (*lang_mark_false_label_stack) (eh->x_false_label_stack);\n   mark_tree_label_node (eh->x_caught_return_label_stack);\n \n   ggc_mark_tree (eh->x_protect_list);"}, {"sha": "3ec2c9e665517898c0f82460b85429c68e4dd4b1", "filename": "gcc/f/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15b9af9843e58e7c03df81098a8a15646f5058e/gcc%2Ff%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15b9af9843e58e7c03df81098a8a15646f5058e/gcc%2Ff%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2FChangeLog?ref=f15b9af9843e58e7c03df81098a8a15646f5058e", "patch": "@@ -1,3 +1,7 @@\n+Sun Oct  1 11:43:44 2000  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* com.c (lang_mark_false_label_stack): Remove.\n+\n 2000-09-10  Zack Weinberg  <zack@wolery.cumb.org>\n \n \t* com.c: Include defaults.h."}, {"sha": "9cc31e908b2ed83c97028ede9961c6116de5a99a", "filename": "gcc/f/com.c", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15b9af9843e58e7c03df81098a8a15646f5058e/gcc%2Ff%2Fcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15b9af9843e58e7c03df81098a8a15646f5058e/gcc%2Ff%2Fcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fcom.c?ref=f15b9af9843e58e7c03df81098a8a15646f5058e", "patch": "@@ -15824,15 +15824,6 @@ lang_mark_tree (t)\n     ggc_mark (TYPE_LANG_SPECIFIC (t));\n }\n \n-void\n-lang_mark_false_label_stack (l)\n-     struct label_node *l;\n-{\n-  /* Fortran doesn't use false_label_stack.  It better be NULL.  */\n-  if (l != NULL)\n-    abort();\n-}\n-\n #endif /* FFECOM_targetCURRENT == FFECOM_targetGCC */\n \f\n #if FFECOM_GCC_INCLUDE"}, {"sha": "b53af557978f6c2c7b09f651773d1762e094bdd5", "filename": "gcc/ggc-callbacks.c", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15b9af9843e58e7c03df81098a8a15646f5058e/gcc%2Fggc-callbacks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15b9af9843e58e7c03df81098a8a15646f5058e/gcc%2Fggc-callbacks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-callbacks.c?ref=f15b9af9843e58e7c03df81098a8a15646f5058e", "patch": "@@ -1,5 +1,5 @@\n /* Empty GC callbacks to be used by languages that don't support GC.\n-   Copyright (C) 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n \n    This file is part of GNU CC.\n \n@@ -36,11 +36,3 @@ lang_mark_tree (t)\n   abort ();\n }\n \n-void ATTRIBUTE_NORETURN\n-lang_mark_false_label_stack (l)\n-     struct label_node *l ATTRIBUTE_UNUSED;\n-{\n-  /* If this function is called, we are doing GC.  But, this file is\n-     only included in compilers for languages that don't support GC.  */\n-  abort ();\n-}"}, {"sha": "2915b731f396d1c3fd74b5d3a41741dfc979ee58", "filename": "gcc/ggc-common.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15b9af9843e58e7c03df81098a8a15646f5058e/gcc%2Fggc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15b9af9843e58e7c03df81098a8a15646f5058e/gcc%2Fggc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-common.c?ref=f15b9af9843e58e7c03df81098a8a15646f5058e", "patch": "@@ -33,6 +33,12 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n /* Statistics about the allocation.  */\n static ggc_statistics *ggc_stats;\n \n+/* The FALSE_LABEL_STACK, declared in except.h, has language-dependent\n+   semantics.  If a front-end needs to mark the false label stack, it\n+   should set this pointer to a non-NULL value.  Otherwise, no marking\n+   will be done.  */\n+void (*lang_mark_false_label_stack) PARAMS ((struct label_node *));\n+\n /* Trees that have been marked, but whose children still need marking.  */\n varray_type ggc_pending_trees;\n "}, {"sha": "1a5b4d886af1df18ce648363a15ff121451fe2ce", "filename": "gcc/ggc.h", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15b9af9843e58e7c03df81098a8a15646f5058e/gcc%2Fggc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15b9af9843e58e7c03df81098a8a15646f5058e/gcc%2Fggc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc.h?ref=f15b9af9843e58e7c03df81098a8a15646f5058e", "patch": "@@ -142,8 +142,15 @@ void *ggc_alloc_cleared PARAMS ((size_t));\n \n #define ggc_alloc_tree(LENGTH) ((union tree_node *) ggc_alloc (LENGTH))\n \n+/* Allocate a gc-able string.  If CONTENTS is null, then the memory will\n+   be uninitialized.  If LENGTH is -1, then CONTENTS is assumed to be a\n+   null-terminated string and the memory sized accordingly.  Otherwise,\n+   the memory is filled with LENGTH bytes from CONTENTS.  */\n char *ggc_alloc_string PARAMS ((const char *contents, int length));\n \n+/* Make a copy of S, in GC-able memory.  */\n+#define ggc_strdup(S) ggc_alloc_string((S), -1)\n+\n /* Invoke the collector.  This is really just a hint, but in the case of\n    the simple collector, the only time it will happen.  */\n void ggc_collect PARAMS ((void));\n@@ -161,10 +168,11 @@ int ggc_set_mark PARAMS ((const void *));\n    the lang_specific hooks in the tree.  */\n void lang_mark_tree PARAMS ((union tree_node *));\n \n-/* The FALSE_LABEL_STACK, declared in except.h, has\n-   language-dependent semantics.  Each front-end should define this\n-   function appropriately.  */\n-void lang_mark_false_label_stack PARAMS ((struct label_node *));\n+/* The FALSE_LABEL_STACK, declared in except.h, has language-dependent\n+   semantics.  If a front-end needs to mark the false label stack, it\n+   should set this pointer to a non-NULL value.  Otherwise, no marking\n+   will be done.  */\n+extern void (*lang_mark_false_label_stack) PARAMS ((struct label_node *));\n \n /* Mark functions for various structs scattered about.  */\n "}, {"sha": "4b6d3077ad8855306886227745714bf759ee6d84", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15b9af9843e58e7c03df81098a8a15646f5058e/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15b9af9843e58e7c03df81098a8a15646f5058e/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=f15b9af9843e58e7c03df81098a8a15646f5058e", "patch": "@@ -1,3 +1,26 @@\n+2000-10-01  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tConvert to GC.\n+\t* Make-lang.in (s-java): Don't depend on ggc-callbacks.o.\n+\t* Makefile.in (BACKEND): Don't include ggc-callbacks.o.\n+\t(typeck.o): Depend on ggc.h.\n+\t* class.c (add_method_1): Use GC functions for allocation.\n+\t(init_class_processing): Register roots.\n+\t* decl.c (ggc_p): Set to 1.\n+\t(pending_local_decls): Make it static.\n+\t(push_jvm_slot): Use GC functions for allocation.\n+\t(init_decl_processing): Register roots.\n+\t(give_name_to_locals): Use GC functions for allocation.\n+\t(lang_mark_tree): New function.\n+\t* java-tree.h (MAYBE_CREATE_TYPE_TYPE_LANG_SPECIFIC): Use GC\n+\tfunctions for allocation.\n+\t* jcf-parse.c (jcf_parse_source): Use ggc_strdup.\n+\t* lex.c (java_lex): Use build_string, rather than replicating it\n+\tinline.\n+\t* parse.y (goal): Add more roots.\n+\t(mark_parser_ctxt): New function.\n+\t* typeck.c: Include ggc.h.\n+\t\n 2000-09-29  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \n \t* parse.y (maybe_yank_clinit): Also keep <clinit> if its body"}, {"sha": "6036f60f9c5792e3040fba62c3256c434d61eec6", "filename": "gcc/java/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15b9af9843e58e7c03df81098a8a15646f5058e/gcc%2Fjava%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15b9af9843e58e7c03df81098a8a15646f5058e/gcc%2Fjava%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FMake-lang.in?ref=f15b9af9843e58e7c03df81098a8a15646f5058e", "patch": "@@ -139,7 +139,7 @@ JCF_DUMP_SOURCES = $(srcdir)/java/jcf-dump.c $(srcdir)/java/jcf-io.c \\\n \n jc1$(exeext) gcjh$(exeext) jv-scan$(exeext) jcf-dump$(exeext): s-java\n \n-s-java: $(P) $(JAVA_SRCS) $(LIBDEPS) $(BACKEND) ggc-callbacks.o \\\n+s-java: $(P) $(JAVA_SRCS) $(LIBDEPS) $(BACKEND) \\\n \t$(GCJH_SOURCES) $(LIBDEPS) $(TREE_H) \\\n \t$(JV_SCAN_SOURCES) $(BACKEND) $(LIBDEPS) \\\n \t$(JCF_DUMP_SOURCES)"}, {"sha": "7cec2851e37b421d59aff52676d8602731d78fe7", "filename": "gcc/java/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15b9af9843e58e7c03df81098a8a15646f5058e/gcc%2Fjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15b9af9843e58e7c03df81098a8a15646f5058e/gcc%2Fjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FMakefile.in?ref=f15b9af9843e58e7c03df81098a8a15646f5058e", "patch": "@@ -181,7 +181,7 @@ JAVA_OBJS = parse.o class.o decl.o expr.o constants.o lang.o typeck.o \\\n JAVA_OBJS_LITE = parse-scan.o jv-scan.o\n \n # Language-independent object files.\n-BACKEND = ../toplev.o ../ggc-callbacks.o ../libbackend.a\n+BACKEND = ../toplev.o ../libbackend.a\n \n compiler: ../jc1$(exeext) ../jv-scan$(exeext)\n ../jc1$(exeext): $(P) $(JAVA_OBJS) $(BACKEND) $(LIBDEPS)\n@@ -317,7 +317,7 @@ mangle.o : mangle.c $(CONFIG_H) jcf.h $(JAVA_TREE_H) $(srcdir)/../system.h \\\n parse-scan.o : $(CONFIG_H) $(srcdir)/../system.h $(srcdir)/../toplev.h \\\n   $(srcdir)/lex.c $(PARSE_H) $(srcdir)/lex.h\n typeck.o : typeck.c $(CONFIG_H) $(JAVA_TREE_H) jcf.h convert.h \\\n-  $(srcdir)/../toplev.h $(srcdir)/../system.h\n+  $(srcdir)/../toplev.h $(srcdir)/../system.h $(srcdir)/../ggc.h\n verify.o : verify.c $(CONFIG_H) $(JAVA_TREE_H) jcf.h javaop.h java-opcodes.h \\\n   java-except.h $(srcdir)/../toplev.h $(srcdir)/../system.h\n xref.o : xref.c xref.h $(CONFIG_H) $(JAVA_TREE_H) $(srcdir)/../toplev.h \\"}, {"sha": "f9300bc1be107ee08ad45343d26001ba1308907c", "filename": "gcc/java/class.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15b9af9843e58e7c03df81098a8a15646f5058e/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15b9af9843e58e7c03df81098a8a15646f5058e/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=f15b9af9843e58e7c03df81098a8a15646f5058e", "patch": "@@ -655,8 +655,7 @@ add_method_1 (handle_class, access_flags, name, function_type)\n   DECL_CONTEXT (fndecl) = handle_class;\n \n   DECL_LANG_SPECIFIC (fndecl)\n-    = (struct lang_decl *) permalloc (sizeof (struct lang_decl));\n-  bzero ((PTR) DECL_LANG_SPECIFIC (fndecl), sizeof (struct lang_decl));\n+    = (struct lang_decl *) ggc_alloc_cleared (sizeof (struct lang_decl));\n \n   /* Initialize the static initializer test table.  */\n   hash_table_init (&DECL_FUNCTION_INIT_TEST_TABLE (fndecl),\n@@ -2121,4 +2120,5 @@ init_class_processing ()\n {\n   registerClass_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"_Jv_RegisterClass\");\n   ggc_add_tree_root (&registered_class, 1);\n+  ggc_add_rtx_root (&registerClass_libfunc, 1);\n }"}, {"sha": "da44ca6ac815785ba20f174a7245110a4ebca39e", "filename": "gcc/java/decl.c", "status": "modified", "additions": 63, "deletions": 3, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15b9af9843e58e7c03df81098a8a15646f5058e/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15b9af9843e58e7c03df81098a8a15646f5058e/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=f15b9af9843e58e7c03df81098a8a15646f5058e", "patch": "@@ -55,6 +55,10 @@ static tree create_primitive_vtable PARAMS ((const char *));\n    before static field references.  */\n extern int always_initialize_class_p;\n \n+/* Use garbage collection.  */\n+\n+int ggc_p = 1;\n+\n /* The DECL_MAP is a mapping from (index, type) to a decl node.\n    If index < max_locals, it is the index of a local variable.\n    if index >= max_locals, then index-max_locals is a stack slot.\n@@ -68,7 +72,7 @@ tree decl_map;\n /* A list of local variables VAR_DECLs for this method that we have seen\n    debug information, but we have not reached their starting (byte) PC yet. */\n \n-tree pending_local_decls = NULL_TREE;\n+static tree pending_local_decls = NULL_TREE;\n \n tree throw_node [2];\n \n@@ -126,7 +130,7 @@ push_jvm_slot (index, decl)\n   if (DECL_LANG_SPECIFIC (decl) == NULL)\n     {\n       DECL_LANG_SPECIFIC (decl)\n-\t= (struct lang_decl *) permalloc (sizeof (struct lang_decl_var));\n+\t= (struct lang_decl *) ggc_alloc (sizeof (struct lang_decl_var));\n       DECL_LOCAL_START_PC (decl) = 0;\n       DECL_LOCAL_END_PC (decl) = DECL_CODE_LENGTH (current_function_decl);\n       DECL_LOCAL_SLOT_NUMBER (decl) = index;\n@@ -851,6 +855,8 @@ init_decl_processing ()\n \t\t     sizeof (throw_node) / sizeof (tree));\n   ggc_add_tree_root (predef_filenames,\n \t\t     sizeof (predef_filenames) / sizeof (tree));\n+  ggc_add_tree_root (&decl_map, 1);\n+  ggc_add_tree_root (&pending_local_decls, 1);\n }\n \n \n@@ -1548,7 +1554,7 @@ give_name_to_locals (jcf)\n \t      end_pc = DECL_CODE_LENGTH (current_function_decl);\n \t    }\n \t  DECL_LANG_SPECIFIC (decl)\n-\t    = (struct lang_decl *) permalloc (sizeof (struct lang_decl_var));\n+\t    = (struct lang_decl *) ggc_alloc (sizeof (struct lang_decl_var));\n \t  DECL_LOCAL_SLOT_NUMBER (decl) = slot;\n \t  DECL_LOCAL_START_PC (decl) = start_pc;\n #if 0\n@@ -1818,3 +1824,57 @@ end_java_method ()\n   permanent_allocation (1);\n   asynchronous_exceptions = flag_asynchronous_exceptions;\n }\n+\n+/* Mark language-specific parts of T for garbage-collection.  */\n+\n+void\n+lang_mark_tree (t)\n+     tree t;\n+{\n+  if (TREE_CODE (t) == IDENTIFIER_NODE)\n+    {\n+      struct lang_identifier *li = (struct lang_identifier *) t;\n+      ggc_mark_tree (li->global_value);\n+      ggc_mark_tree (li->local_value);\n+      ggc_mark_tree (li->utf8_ref);\n+    }\n+  else if (TREE_CODE (t) == VAR_DECL\n+\t   || TREE_CODE (t) == PARM_DECL)\n+    {\n+      struct lang_decl_var *ldv = \n+\t((struct lang_decl_var *) DECL_LANG_SPECIFIC (t));\n+      if (ldv)\n+\t{\n+\t  ggc_mark (ldv);\n+\t  ggc_mark_tree (ldv->slot_chain);\n+\t}\n+    }\n+  else if (TREE_CODE (t) == FUNCTION_DECL)\n+    {\n+      struct lang_decl *ld = DECL_LANG_SPECIFIC (t);\n+      \n+      if (ld)\n+\t{\n+\t  ggc_mark (ld);\n+\t  ggc_mark_tree (ld->throws_list);\n+\t  ggc_mark_tree (ld->function_decl_body);\n+\t  ggc_mark_tree (ld->called_constructor);\n+\t  ggc_mark_tree (ld->inner_access);\n+\t}\n+    }\n+  else if (TYPE_P (t))\n+    {\n+      struct lang_type *lt = TYPE_LANG_SPECIFIC (t);\n+      \n+      if (lt)\n+\t{\n+\t  ggc_mark (lt);\n+\t  ggc_mark_tree (lt->signature);\n+\t  ggc_mark_tree (lt->cpool_data_ref);\n+\t  ggc_mark_tree (lt->finit_stmt_list);\n+\t  ggc_mark_tree (lt->clinit_stmt_list);\n+\t  ggc_mark_tree (lt->ii_block);\n+\t  ggc_mark_tree (lt->dot_class);\n+\t}\n+    }\n+}"}, {"sha": "d22efecbc752711f9a74cf6c77a32210513e5f1f", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15b9af9843e58e7c03df81098a8a15646f5058e/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15b9af9843e58e7c03df81098a8a15646f5058e/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=f15b9af9843e58e7c03df81098a8a15646f5058e", "patch": "@@ -829,14 +829,12 @@ struct lang_decl_var\n #define TYPE_JCF(T) (TYPE_LANG_SPECIFIC(T)->jcf)\n #define TYPE_CPOOL(T) (TYPE_LANG_SPECIFIC(T)->cpool)\n #define TYPE_CPOOL_DATA_REF(T) (TYPE_LANG_SPECIFIC(T)->cpool_data_ref)\n-#define MAYBE_CREATE_TYPE_TYPE_LANG_SPECIFIC(T)\t\t\t\t\\\n-  if (TYPE_LANG_SPECIFIC ((T)) == NULL)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      TYPE_LANG_SPECIFIC ((T)) = \t\t\t\t\t\\\n-\t(struct lang_type *) xmalloc (sizeof (struct lang_type));\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      bzero ((char *) TYPE_LANG_SPECIFIC ((T)),\t\t\t\t\\\n-\t     sizeof (struct lang_type));\t\t\t\t\\\n+#define MAYBE_CREATE_TYPE_TYPE_LANG_SPECIFIC(T)\t\t\t\t \\\n+  if (TYPE_LANG_SPECIFIC ((T)) == NULL)\t\t\t\t\t \\\n+    {\t\t\t\t\t\t\t\t\t \\\n+      TYPE_LANG_SPECIFIC ((T)) = \t\t\t\t\t \\\n+\t((struct lang_type *) \t\t\t\t\t\t \\\n+         ggc_alloc_cleared (sizeof (struct lang_type)));\t\t \\\n     }\n \n #define TYPE_FINIT_STMT_LIST(T)  (TYPE_LANG_SPECIFIC(T)->finit_stmt_list)"}, {"sha": "ccfba7d7f86baf0ef9918b81cac883cc68ca362e", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15b9af9843e58e7c03df81098a8a15646f5058e/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15b9af9843e58e7c03df81098a8a15646f5058e/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=f15b9af9843e58e7c03df81098a8a15646f5058e", "patch": "@@ -568,7 +568,7 @@ jcf_parse_source ()\n \n   java_parser_context_save_global ();\n   java_push_parser_context ();\n-  input_filename = current_jcf->filename;\n+  input_filename = ggc_strdup (current_jcf->filename);\n   file = get_identifier (input_filename);\n   current_class = NULL_TREE;\n   current_function_decl = NULL_TREE;"}, {"sha": "5d106c416ec1a842fada4f64b0fa6cd92b216ac8", "filename": "gcc/java/lex.c", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15b9af9843e58e7c03df81098a8a15646f5058e/gcc%2Fjava%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15b9af9843e58e7c03df81098a8a15646f5058e/gcc%2Fjava%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flex.c?ref=f15b9af9843e58e7c03df81098a8a15646f5058e", "patch": "@@ -1081,14 +1081,7 @@ java_lex (java_lval)\n       if (!no_error || (c != '\"'))\n \tjava_lval->node = error_mark_node; /* Requires futher testing FIXME */\n       else\n-\t{\n-\t  tree s = make_node (STRING_CST);\n-\t  TREE_STRING_LENGTH (s) = strlen (string);\n-\t  TREE_STRING_POINTER (s) = \n-\t    obstack_alloc (expression_obstack, TREE_STRING_LENGTH (s)+1);\n-\t  strcpy (TREE_STRING_POINTER (s), string);\n-\t  java_lval->node = s;\n-\t}\n+\tjava_lval->node = build_string (strlen (string), string);\n #endif\n       return STRING_LIT_TK;\n     }"}, {"sha": "9ebeb44d1b4832c84c64b2ae8d74565a0019d321", "filename": "gcc/java/parse.y", "status": "modified", "additions": 44, "deletions": 1, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15b9af9843e58e7c03df81098a8a15646f5058e/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15b9af9843e58e7c03df81098a8a15646f5058e/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=f15b9af9843e58e7c03df81098a8a15646f5058e", "patch": "@@ -323,6 +323,7 @@ static void add_inner_class_fields PARAMS ((tree, tree));\n static tree build_dot_class_method PARAMS ((tree));\n static tree build_dot_class_method_invocation PARAMS ((tree));\n static void create_new_parser_context PARAMS ((int));\n+static void mark_parser_ctxt PARAMS ((void *));\n \n /* Number of error found so far. */\n int java_error_count; \n@@ -332,7 +333,7 @@ int java_warning_count;\n int do_not_fold;\n /* Cyclic inheritance report, as it can be set by layout_class */\n char *cyclic_inheritance_report;\n-\n+ \n /* Tell when we're within an instance initializer */\n static int in_instance_initializer;\n \n@@ -597,6 +598,12 @@ goal:\n \t\t  ggc_add_tree_root (&package_list, 1);\n \t\t  ggc_add_tree_root (&current_this, 1);\n \t\t  ggc_add_tree_root (&currently_caught_type_list, 1);\n+\t\t  ggc_add_root (&ctxp, 1, \n+\t\t\t\tsizeof (struct parser_ctxt *),\n+\t\t\t\tmark_parser_ctxt);\n+\t\t  ggc_add_root (&ctxp_for_generation, 1, \n+\t\t\t\tsizeof (struct parser_ctxt *),\n+\t\t\t\tmark_parser_ctxt);\n \t\t}\n \tcompilation_unit\n \t\t{}\n@@ -15215,3 +15222,39 @@ resolve_qualified_name (name, context)\n {\n }\n #endif\n+\n+/* Mark P, which is really a `struct parser_ctxt **' for GC.  */\n+\n+static void\n+mark_parser_ctxt (p)\n+     void *p;\n+{\n+  struct parser_ctxt *pc = *((struct parser_ctxt **) p);\n+  int i;\n+\n+  if (!pc)\n+    return;\n+\n+#ifndef JC1_LITE\n+  for (i = 0; i < 11; ++i)\n+    ggc_mark_tree (pc->modifier_ctx[i]);\n+  ggc_mark_tree (pc->class_type);\n+  ggc_mark_tree (pc->function_decl);\n+  ggc_mark_tree (pc->package);\n+  ggc_mark_tree (pc->incomplete_class);\n+  ggc_mark_tree (pc->gclass_list);\n+  ggc_mark_tree (pc->class_list);\n+  ggc_mark_tree (pc->current_parsed_class);\n+  ggc_mark_tree (pc->current_parsed_class_un);\n+  ggc_mark_tree (pc->non_static_initialized);\n+  ggc_mark_tree (pc->static_initialized);\n+  ggc_mark_tree (pc->instance_initializers);\n+  ggc_mark_tree (pc->import_list);\n+  ggc_mark_tree (pc->import_demand_list);\n+  ggc_mark_tree (pc->current_loop);\n+  ggc_mark_tree (pc->current_labeled_block);\n+#endif /* JC1_LITE */\n+\n+  if (pc->next)\n+    mark_parser_ctxt (&pc->next);\n+}"}, {"sha": "08ab30fa568b37e12810f790372ad000ac213082", "filename": "gcc/java/typeck.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15b9af9843e58e7c03df81098a8a15646f5058e/gcc%2Fjava%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15b9af9843e58e7c03df81098a8a15646f5058e/gcc%2Fjava%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Ftypeck.c?ref=f15b9af9843e58e7c03df81098a8a15646f5058e", "patch": "@@ -33,6 +33,7 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n #include \"jcf.h\"\n #include \"convert.h\"\n #include \"toplev.h\"\n+#include \"ggc.h\"\n \n static tree convert_ieee_real_to_integer PARAMS ((tree, tree));\n static tree parse_signature_type PARAMS ((const unsigned char **,"}, {"sha": "c689e240542cecb85e483e22f0a4227c1a892fc3", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15b9af9843e58e7c03df81098a8a15646f5058e/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15b9af9843e58e7c03df81098a8a15646f5058e/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=f15b9af9843e58e7c03df81098a8a15646f5058e", "patch": "@@ -1,3 +1,7 @@\n+2000-10-01  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* splay-tree.c (splay_tree_insert): Fix formatting.\n+\n 2000-09-16  Mark Mitchell  <mark@codesourcery.com>\n \n \t* splay-tree.c (splay_tree_predecessor): Fix typo in comment."}, {"sha": "52b57c088a79b638274320766e001b4c08b7446c", "filename": "libiberty/splay-tree.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15b9af9843e58e7c03df81098a8a15646f5058e/libiberty%2Fsplay-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15b9af9843e58e7c03df81098a8a15646f5058e/libiberty%2Fsplay-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fsplay-tree.c?ref=f15b9af9843e58e7c03df81098a8a15646f5058e", "patch": "@@ -305,8 +305,8 @@ splay_tree_insert (sp, key, value)\n \t  node->right->left = 0;\n \t}\n \n-    sp->root = node;\n-  }\n+      sp->root = node;\n+    }\n \n   return sp->root;\n }"}]}