{"sha": "6619e96c705d7c6f000587d8558040d90a9d23df", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjYxOWU5NmM3MDVkN2M2ZjAwMDU4N2Q4NTU4MDQwZDkwYTlkMjNkZg==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@one.net.au", "date": "2001-04-14T08:42:31Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2001-04-14T08:42:31Z"}, "message": "pa.c (force_mode): New function.\n\n\t* pa.c (force_mode): New function.\n\t(emit_move_sequence): Use it instead of generating new rtx_REGs.\n\nFrom-SVN: r41353", "tree": {"sha": "b955ff1b8ac89d2232d8eb45df94b5323af47f56", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b955ff1b8ac89d2232d8eb45df94b5323af47f56"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6619e96c705d7c6f000587d8558040d90a9d23df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6619e96c705d7c6f000587d8558040d90a9d23df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6619e96c705d7c6f000587d8558040d90a9d23df", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6619e96c705d7c6f000587d8558040d90a9d23df/comments", "author": null, "committer": null, "parents": [{"sha": "92547f1261bc91a64d4c004a795c226053cb0b9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92547f1261bc91a64d4c004a795c226053cb0b9f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92547f1261bc91a64d4c004a795c226053cb0b9f"}], "stats": {"total": 113, "additions": 68, "deletions": 45}, "files": [{"sha": "699056450d3b9ed43c14e3d4648f2b3e5a63ca77", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6619e96c705d7c6f000587d8558040d90a9d23df/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6619e96c705d7c6f000587d8558040d90a9d23df/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6619e96c705d7c6f000587d8558040d90a9d23df", "patch": "@@ -1,3 +1,8 @@\n+2001-04-14  Alan Modra  <amodra@one.net.au>\n+\n+\t* pa.c (force_mode): New function.\n+\t(emit_move_sequence): Use it instead of generating new rtx_REGs.\n+\n 2001-04-13  Jim Wilson  <wilson@redhat.com>\n \n \t* config/ia64/ia64.c (ia64_expand_epilogue): Emit alloc if sibcall_p."}, {"sha": "050681b54baf01a03893519ff989348a8e455517", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 63, "deletions": 45, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6619e96c705d7c6f000587d8558040d90a9d23df/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6619e96c705d7c6f000587d8558040d90a9d23df/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=6619e96c705d7c6f000587d8558040d90a9d23df", "patch": "@@ -53,6 +53,7 @@ Boston, MA 02111-1307, USA.  */\n static void pa_init_machine_status PARAMS ((struct function *));\n static void pa_mark_machine_status PARAMS ((struct function *));\n static void pa_free_machine_status PARAMS ((struct function *));\n+static inline rtx force_mode PARAMS ((enum machine_mode, rtx));\n static void pa_combine_instructions PARAMS ((rtx));\n static int pa_can_combine_p PARAMS ((rtx, rtx, rtx, int, rtx, rtx, rtx));\n static int forward_branch_p PARAMS ((rtx));\n@@ -948,7 +949,7 @@ hppa_legitimize_address (x, oldx, mode)\n \treg2 = force_reg (Pmode, force_operand (reg2, 0));\n \n       /* Figure out what the base and index are.  */\n-\t \n+\n       if (GET_CODE (reg1) == REG\n \t  && REG_POINTER (reg1))\n \t{\n@@ -1039,13 +1040,13 @@ hppa_legitimize_address (x, oldx, mode)\n \n       /* Add the result to our base register and return.  */\n       return force_reg (Pmode, gen_rtx_PLUS (Pmode, base, reg1));\n-      \n+\n     }\n \n   /* Uh-oh.  We might have an address for x[n-100000].  This needs\n      special handling to avoid creating an indexed memory address\n      with x-100000 as the base.\n-    \n+\n      If the constant part is small enough, then it's still safe because\n      there is a guard page at the beginning and end of the data segment.\n \n@@ -1074,7 +1075,7 @@ hppa_legitimize_address (x, oldx, mode)\n \t\t      (const (plus (symbol_ref) (const_int))))\n \n \t     Where const_int is small.  In that case the const\n-\t     expression is a valid pointer for indexing. \n+\t     expression is a valid pointer for indexing.\n \n \t     If const_int is big, but can be divided evenly by shadd_const\n \t     and added to (reg).  This allows more scaled indexed addresses.  */\n@@ -1173,11 +1174,27 @@ hppa_address_cost (X)\n   return 4;\n }\n \n+/* Ensure mode of ORIG, a REG rtx, is MODE.  Returns either ORIG or a\n+   new rtx with the correct mode.  */\n+static inline rtx\n+force_mode (mode, orig)\n+     enum machine_mode mode;\n+     rtx orig;\n+{\n+  if (mode == GET_MODE (orig))\n+    return orig;\n+\n+  if (REGNO (orig) >= FIRST_PSEUDO_REGISTER)\n+    abort ();\n+\n+  return gen_rtx_REG (mode, REGNO (orig));\n+}\n+\n /* Emit insns to move operands[1] into operands[0].\n \n    Return 1 if we have written out everything that needs to be done to\n    do the move.  Otherwise, return 0 and the caller will emit the move\n-   normally. \n+   normally.\n \n    Note SCRATCH_REG may not be in the proper mode depending on how it\n    will be used.  This routine is resposible for creating a new copy\n@@ -1237,7 +1254,7 @@ emit_move_sequence (operands, mode, scratch_reg)\n     operand1 = gen_rtx_MEM (GET_MODE (operand1), tem);\n \n   /* Handle secondary reloads for loads/stores of FP registers from\n-     REG+D addresses where D does not fit in 5 bits, including \n+     REG+D addresses where D does not fit in 5 bits, including\n      (subreg (mem (addr))) cases.  */\n   if (fp_reg_operand (operand0, mode)\n       && ((GET_CODE (operand1) == MEM\n@@ -1253,7 +1270,7 @@ emit_move_sequence (operands, mode, scratch_reg)\n       /* SCRATCH_REG will hold an address and maybe the actual data.  We want\n \t it in WORD_MODE regardless of what mode it was originally given\n \t to us.  */\n-      scratch_reg = gen_rtx_REG (word_mode, REGNO (scratch_reg));\n+      scratch_reg = force_mode (word_mode, scratch_reg);\n \n       /* D might not fit in 14 bits either; for such cases load D into\n \t scratch reg.  */\n@@ -1285,7 +1302,7 @@ emit_move_sequence (operands, mode, scratch_reg)\n       /* SCRATCH_REG will hold an address and maybe the actual data.  We want\n \t it in WORD_MODE regardless of what mode it was originally given\n \t to us.  */\n-      scratch_reg = gen_rtx_REG (word_mode, REGNO (scratch_reg));\n+      scratch_reg = force_mode (word_mode, scratch_reg);\n \n       /* D might not fit in 14 bits either; for such cases load D into\n \t scratch reg.  */\n@@ -1323,7 +1340,7 @@ emit_move_sequence (operands, mode, scratch_reg)\n       /* SCRATCH_REG will hold an address and maybe the actual data.  We want\n \t it in WORD_MODE regardless of what mode it was originally given\n \t to us.  */\n-      scratch_reg = gen_rtx_REG (word_mode, REGNO (scratch_reg));\n+      scratch_reg = force_mode (word_mode, scratch_reg);\n \n       /* Force the constant into memory and put the address of the\n \t memory location into scratch_reg.  */\n@@ -1354,9 +1371,9 @@ emit_move_sequence (operands, mode, scratch_reg)\n \t{\n \t  /* We are reloading the address into the scratch register, so we\n \t     want to make sure the scratch register is a full register.  */\n-\t  scratch_reg = gen_rtx_REG (word_mode, REGNO (scratch_reg));\n+\t  scratch_reg = force_mode (word_mode, scratch_reg);\n \n-\t  emit_move_insn (scratch_reg, XEXP (XEXP (operand1, 0), 1));\t\n+\t  emit_move_insn (scratch_reg, XEXP (XEXP (operand1, 0), 1));\n \t  emit_move_insn (scratch_reg, gen_rtx_fmt_ee (GET_CODE (XEXP (operand1,\n \t\t\t\t\t\t\t\t        0)),\n \t\t\t\t\t\t       Pmode,\n@@ -1368,16 +1385,17 @@ emit_move_sequence (operands, mode, scratch_reg)\n \t     we want to load it in the same width as the original MEM,\n \t     which must be the same as the width of the ultimate destination,\n \t     OPERAND0.  */\n-\t  scratch_reg = gen_rtx_REG (GET_MODE (operand0), REGNO (scratch_reg));\n-\t  \n+\t  scratch_reg = force_mode (GET_MODE (operand0), scratch_reg);\n+\n \t  emit_move_insn (scratch_reg, gen_rtx_MEM (GET_MODE (operand0),\n \t\t\t\t\t\t    scratch_reg));\n \t}\n       else\n \t{\n \t  /* We want to load the scratch register using the same mode as\n \t     the ultimate destination.  */\n-\t  scratch_reg = gen_rtx_REG (GET_MODE (operand0), REGNO (scratch_reg));\n+\t  scratch_reg = force_mode (GET_MODE (operand0), scratch_reg);\n+\n \t  emit_move_insn (scratch_reg, operand1);\n \t}\n \n@@ -1464,7 +1482,7 @@ emit_move_sequence (operands, mode, scratch_reg)\n \t\t  /* SCRATCH_REG will hold an address and maybe the actual\n \t\t     data.  We want it in WORD_MODE regardless of what mode it\n \t\t     was originally given to us.  */\n-\t\t  scratch_reg = gen_rtx_REG (word_mode, REGNO (scratch_reg));\n+\t\t  scratch_reg = force_mode (word_mode, scratch_reg);\n \t\t}\n \t      else if (flag_pic)\n \t\tscratch_reg = gen_reg_rtx (Pmode);\n@@ -1487,7 +1505,7 @@ emit_move_sequence (operands, mode, scratch_reg)\n \t\t  /* Force the function label into memory.  */\n \t\t  temp = force_const_mem (mode, operand1);\n \t\t}\n-\t\t\n+\n \n \t      /* Get the address of the memory location.  PIC-ify it if\n \t\t necessary.  */\n@@ -1522,7 +1540,7 @@ emit_move_sequence (operands, mode, scratch_reg)\n \t\t  /* TEMP will hold an address and maybe the actual\n \t\t     data.  We want it in WORD_MODE regardless of what mode it\n \t\t     was originally given to us.  */\n-\t\t  temp = gen_rtx_REG (word_mode, REGNO (temp));\n+\t\t  temp = force_mode (word_mode, temp);\n \t\t}\n \t      else\n \t\ttemp = gen_reg_rtx (Pmode);\n@@ -1561,13 +1579,13 @@ emit_move_sequence (operands, mode, scratch_reg)\n \t\t  /* TEMP will hold an address and maybe the actual\n \t\t     data.  We want it in WORD_MODE regardless of what mode it\n \t\t     was originally given to us.  */\n-\t\t  temp = gen_rtx_REG (word_mode, REGNO (temp));\n+\t\t  temp = force_mode (word_mode, temp);\n \t\t}\n \t      else\n \t\ttemp = gen_reg_rtx (mode);\n \n \t      /* Loading a SYMBOL_REF into a register makes that register\n-\t\t safe to be used as the base in an indexed address. \n+\t\t safe to be used as the base in an indexed address.\n \n \t\t Don't mark hard registers though.  That loses.  */\n \t      if (GET_CODE (operand0) == REG\n@@ -1633,7 +1651,7 @@ emit_move_sequence (operands, mode, scratch_reg)\n \t\t\t\t\t\t\t       operands[0],\n \t\t\t\t\t\t\t       0)));\n \t    }\n-\t\n+\n \t  return 1;\n \t}\n     }\n@@ -2060,10 +2078,10 @@ output_move_double (operands)\n \tcan create such insns.\n \n \tmem in this case will be either register indirect or register\n-\tindirect plus a valid offset. \n+\tindirect plus a valid offset.\n \n \tregister -> register move where REGNO(dst) == REGNO(src + 1)\n-\tsomeone (Tim/Tege?) claimed this can happen for parameter loads. \n+\tsomeone (Tim/Tege?) claimed this can happen for parameter loads.\n \n      Handle mem -> register case first.  */\n   if (optype0 == REGOP\n@@ -2180,7 +2198,7 @@ find_addr_reg (addr)\n    OPERANDS[2] is a register for temporary storage.\n    OPERANDS[4] is the size as a CONST_INT\n    OPERANDS[3] is a register for temporary storage.\n-   OPERANDS[5] is the alignment safe to use, as a CONST_INT. \n+   OPERANDS[5] is the alignment safe to use, as a CONST_INT.\n    OPERANDS[6] is another temporary register.   */\n \n const char *\n@@ -2590,7 +2608,7 @@ remove_useless_addtr_insns (insns, check_notes)\n \t      fcmp_count++;\n \t      continue;\n \t    }\n-\t    \n+\n \t  tmp = PATTERN (insn);\n \t  /* If this is an fbranch instruction, bump the fbranch counter.  */\n \t  if (GET_CODE (tmp) == SET\n@@ -3050,7 +3068,7 @@ hppa_expand_prologue ()\n \t  /* Prevent register spills from being scheduled before the\n \t     stack pointer is raised.  Necessary as we will be storing\n \t     registers using the frame pointer as a base register, and\n-\t     we happen to set fp before raising sp.  */ \n+\t     we happen to set fp before raising sp.  */\n \t  emit_insn (gen_blockage ());\n \t}\n       /* no frame pointer needed.  */\n@@ -3314,13 +3332,13 @@ hppa_expand_epilogue ()\n      restores are finished.  */\n   emit_insn (gen_blockage ());\n \n-  /* Reset stack pointer (and possibly frame pointer).  The stack \n+  /* Reset stack pointer (and possibly frame pointer).  The stack\n      pointer is initially set to fp + 64 to avoid a race condition.  */\n   if (frame_pointer_needed)\n     {\n       rtx delta = GEN_INT (-64);\n       FRP (set_reg_plus_d (STACK_POINTER_REGNUM, FRAME_POINTER_REGNUM, 64));\n-      FRP (emit_insn (gen_pre_load (frame_pointer_rtx, \n+      FRP (emit_insn (gen_pre_load (frame_pointer_rtx,\n \t\t\t\t    stack_pointer_rtx,\n \t\t\t\t    delta)));\n     }\n@@ -3859,7 +3877,7 @@ pa_adjust_insn_length (insn, length)\n       else\n \treturn 0;\n     }\n-  /* Jumps inside switch tables which have unfilled delay slots \n+  /* Jumps inside switch tables which have unfilled delay slots\n      also need adjustment.  */\n   else if (GET_CODE (insn) == JUMP_INSN\n \t   && simplejump_p (insn)\n@@ -4703,7 +4721,7 @@ secondary_reload_class (class, mode, in)\n         is_symbolic = 0;\n         break;\n     }\n-  \n+\n   if (!flag_pic\n       && is_symbolic\n       && read_only_operand (in, VOIDmode))\n@@ -4763,7 +4781,7 @@ hppa_builtin_saveregs ()\n   if (TARGET_64BIT)\n     {\n       int i, off;\n-      \n+\n       /* Adjust for varargs/stdarg differences.  */\n       if (argadj)\n \toffset = plus_constant (current_function_arg_offset_rtx, -argadj);\n@@ -4847,7 +4865,7 @@ hppa_va_arg (valist, type)\n         {\n           t = build (PLUS_EXPR, TREE_TYPE (valist), valist,\n                      build_int_2 (2 * UNITS_PER_WORD - 1, 0));\n-          t = build (BIT_AND_EXPR, TREE_TYPE (t), t, \n+          t = build (BIT_AND_EXPR, TREE_TYPE (t), t,\n                      build_int_2 (-2 * UNITS_PER_WORD, -1));\n           t = build (MODIFY_EXPR, TREE_TYPE (valist), valist, t);\n           TREE_SIDE_EFFECTS (t) = 1;\n@@ -4865,7 +4883,7 @@ hppa_va_arg (valist, type)\n   /* \"Large\" types are passed by reference.  */\n   if (size > 8)\n     {\n-      t = build (PREDECREMENT_EXPR, TREE_TYPE (valist), valist, \n+      t = build (PREDECREMENT_EXPR, TREE_TYPE (valist), valist,\n \t\t build_int_2 (POINTER_SIZE / BITS_PER_UNIT, 0));\n       TREE_SIDE_EFFECTS (t) = 1;\n \n@@ -4888,7 +4906,7 @@ hppa_va_arg (valist, type)\n \n       t = build (MODIFY_EXPR, TREE_TYPE (valist), valist, t);\n       TREE_SIDE_EFFECTS (t) = 1;\n-      \n+\n       ofs = (8 - size) % 4;\n       if (ofs)\n \t{\n@@ -5104,7 +5122,7 @@ output_cbranch (operands, nullify, length, negated, insn)\n \t/* Now restore the value of %r1 in the delay slot.  We're not\n \t   optimizing so we know nothing else can be in the delay slot.  */\n \treturn \"ldw -16(%%r30),%%r1\";\n-\t\n+\n       default:\n \tabort ();\n     }\n@@ -6404,7 +6422,7 @@ output_parallel_addb (operands, length)\n    It is also used to avoid filling the delay slot of a jump which\n    immediately follows a call since the jump can usually be eliminated\n    completely by modifying RP in the delay slot of the call.  */\n-   \n+\n int\n following_call (insn)\n      rtx insn;\n@@ -6454,10 +6472,10 @@ following_call (insn)\n    Reorg and the final jump pass can then optimize these branches and\n    fill their delay slots.  We end up with smaller, more efficient code.\n \n-   The jump instructions within the table are special; we must be able \n+   The jump instructions within the table are special; we must be able\n    to identify them during assembly output (if the jumps don't get filled\n    we need to emit a nop rather than nullifying the delay slot)).  We\n-   identify jumps in switch tables by marking the SET with DImode. \n+   identify jumps in switch tables by marking the SET with DImode.\n \n    We also surround the jump table itself with BEGIN_BRTAB and END_BRTAB\n    insns.  This serves two purposes, first it prevents jump.c from\n@@ -6753,7 +6771,7 @@ pa_combine_instructions (insns)\n \t\t      || (GET_CODE (floater) == INSN\n \t\t\t  && (GET_CODE (PATTERN (floater)) == USE\n \t\t\t      || GET_CODE (PATTERN (floater)) == CLOBBER)))\n-\t\t\t\n+\n \t\t    continue;\n \n \t\t  /* Anything except a regular INSN will stop our search.  */\n@@ -6913,7 +6931,7 @@ int\n insn_refs_are_delayed (insn)\n      rtx insn;\n {\n-  return ((GET_CODE (insn) == INSN \n+  return ((GET_CODE (insn) == INSN\n \t   && GET_CODE (PATTERN (insn)) != SEQUENCE\n \t   && GET_CODE (PATTERN (insn)) != USE\n \t   && GET_CODE (PATTERN (insn)) != CLOBBER\n@@ -6924,7 +6942,7 @@ insn_refs_are_delayed (insn)\n    if the parameter has any component that is passed in memory.\n \n    This is new code and will be pushed to into the net sources after\n-   further testing. \n+   further testing.\n \n    ??? We might want to restructure this so that it looks more like other\n    ports.  */\n@@ -6965,7 +6983,7 @@ function_arg (cum, mode, type, named, incoming)\n      particularly in their handling of FP registers.  We might\n      be able to cleverly share code between them, but I'm not\n      going to bother in the hope that splitting them up results\n-     in code that is more easily understood. \n+     in code that is more easily understood.\n \n      The 64bit code probably is very wrong for structure passing.  */\n   if (TARGET_64BIT)\n@@ -6978,7 +6996,7 @@ function_arg (cum, mode, type, named, incoming)\n \t varies based on the size of the target word.  */\n       gpr_reg_base = 26 - cum->words;\n       fpr_reg_base = 32 + cum->words;\n-\t  \n+\n       /* If the argument is more than a word long, then we need to align\n \t the base registers.  Same caveats as above.  */\n       if (FUNCTION_ARG_SIZE (mode, type) > 1)\n@@ -7002,7 +7020,7 @@ function_arg (cum, mode, type, named, incoming)\n \t    {\n \t      rtx loc[8];\n \t      int i, offset = 0, ub;\n-              ub = FUNCTION_ARG_SIZE (mode, type); \n+              ub = FUNCTION_ARG_SIZE (mode, type);\n \t      ub = MIN (ub,\n \t\t\tMAX (0, max_arg_words - cum->words - (cum->words & 1)));\n \t      gpr_reg_base -= (cum->words & 1);\n@@ -7130,7 +7148,7 @@ function_arg_partial_nregs (cum, mode, type, named)\n   if (cum->words + offset + FUNCTION_ARG_SIZE (mode, type) <= max_arg_words)\n     /* Arg fits fully into registers. */\n     return 0;\n-  else if (cum->words + offset >= max_arg_words) \n+  else if (cum->words + offset >= max_arg_words)\n     /* Arg fully on the stack. */\n     return 0;\n   else\n@@ -7174,7 +7192,7 @@ mark_deferred_plabels (arg)\n /* Called to register all of our global variables with the garbage\n    collector.  */\n \n-static void \n+static void\n pa_add_gc_roots ()\n {\n   ggc_add_rtx_root (&hppa_compare_op0, 1);"}]}