{"sha": "70b7b0376ecb761a23a30c4626cb14d9f6cecda6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzBiN2IwMzc2ZWNiNzYxYTIzYTMwYzQ2MjZjYjE0ZDlmNmNlY2RhNg==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2008-04-01T22:59:21Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2008-04-01T22:59:21Z"}, "message": "re PR tree-optimization/35787 (Revision 133680 breaks 447.dealII)\n\n2008-04-02  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-vrp.c (extract_range_from_assert): Make sure to not\n\tproduce range min/max with TREE_OVERFOW set.\n\tIf merging a anti-range and a range keep the anti-range if\n\tthe range covers all values of the type.\n\t(register_edge_assert_for_2): Only allow sign-changing\n\tconversions in detecting canonical range checks.  Also\n\tregister an assert for the unsigned name if useful.\n\n\tPR tree-optimization/35787\n\t* tree-vrp.c (vrp_val_max): New function.\n\t(vrp_val_min): Likewise.\n\t(vrp_val_is_max): Move earlier, use vrp_val_{min,max}.\n\t(vrp_val_is_min): Likewise.\n\t(supports_overflow_infinity): Use vrp_val_{min,max}.\n\t(negative_overflow_infinity): Likewise.\n\t(positive_overflow_infinity): Likewise.\n\t(is_negative_overflow_infinity): Use vrp_val_is_{min,max}.\n\t(is_positive_overflow_infinity): Likewise.\n\t(is_overflow_infinity): Likewise.\n\t(avoid_overflow_infinity): Use vrp_val_{min,max} and\n\tvrp_val_is_{min,max}.\n\t(set_and_canonicalize_value_range): Canonicalize anti-ranges\n\tto ranges if possible.  Avoid empty ranges.\n\n\t* gcc.dg/tree-ssa/vrp38.c: New testcase.\n\t* gcc.dg/tree-ssa/vrp39.c: Likewise.\n\nFrom-SVN: r133808", "tree": {"sha": "40f23dcdada81b8d07eede1a1d8ad564eff36e94", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/40f23dcdada81b8d07eede1a1d8ad564eff36e94"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/70b7b0376ecb761a23a30c4626cb14d9f6cecda6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70b7b0376ecb761a23a30c4626cb14d9f6cecda6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70b7b0376ecb761a23a30c4626cb14d9f6cecda6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70b7b0376ecb761a23a30c4626cb14d9f6cecda6/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a6a0635ec111936464b2529edf809b17fe29d4c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6a0635ec111936464b2529edf809b17fe29d4c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6a0635ec111936464b2529edf809b17fe29d4c3"}], "stats": {"total": 345, "additions": 256, "deletions": 89}, "files": [{"sha": "0f13284789b60f0b54412bf1400a49c0967c10e1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70b7b0376ecb761a23a30c4626cb14d9f6cecda6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70b7b0376ecb761a23a30c4626cb14d9f6cecda6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=70b7b0376ecb761a23a30c4626cb14d9f6cecda6", "patch": "@@ -1,3 +1,29 @@\n+2008-04-02  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-vrp.c (extract_range_from_assert): Make sure to not\n+\tproduce range min/max with TREE_OVERFOW set.\n+\tIf merging a anti-range and a range keep the anti-range if\n+\tthe range covers all values of the type.\n+\t(register_edge_assert_for_2): Only allow sign-changing\n+\tconversions in detecting canonical range checks.  Also\n+\tregister an assert for the unsigned name if useful.\n+\n+\tPR tree-optimization/35787\n+\t* tree-vrp.c (vrp_val_max): New function.\n+\t(vrp_val_min): Likewise.\n+\t(vrp_val_is_max): Move earlier, use vrp_val_{min,max}.\n+\t(vrp_val_is_min): Likewise.\n+\t(supports_overflow_infinity): Use vrp_val_{min,max}.\n+\t(negative_overflow_infinity): Likewise.\n+\t(positive_overflow_infinity): Likewise.\n+\t(is_negative_overflow_infinity): Use vrp_val_is_{min,max}.\n+\t(is_positive_overflow_infinity): Likewise.\n+\t(is_overflow_infinity): Likewise.\n+\t(avoid_overflow_infinity): Use vrp_val_{min,max} and\n+\tvrp_val_is_{min,max}.\n+\t(set_and_canonicalize_value_range): Canonicalize anti-ranges\n+\tto ranges if possible.  Avoid empty ranges.\n+\n 2008-04-01  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n \n \tPR middle-end/35705"}, {"sha": "c7b5920e9adc64fcf335f0f5069eab9a9435d636", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70b7b0376ecb761a23a30c4626cb14d9f6cecda6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70b7b0376ecb761a23a30c4626cb14d9f6cecda6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=70b7b0376ecb761a23a30c4626cb14d9f6cecda6", "patch": "@@ -1,3 +1,8 @@\n+2008-04-02  Richard Guenther  <rguenther@suse.de>\n+\n+\t* gcc.dg/tree-ssa/vrp38.c: New testcase.\n+\t* gcc.dg/tree-ssa/vrp39.c: Likewise.\n+\n 2008-04-01  George Helffrich  <george@gcc.gnu.org>\n \n \tPRs fortran/PR35154, fortran/PR23057"}, {"sha": "b740c60242c9c8d1c18f10adbf1da213639d108e", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp38.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70b7b0376ecb761a23a30c4626cb14d9f6cecda6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp38.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70b7b0376ecb761a23a30c4626cb14d9f6cecda6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp38.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp38.c?ref=70b7b0376ecb761a23a30c4626cb14d9f6cecda6", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2\" } */\n+\n+int __attribute__((noinline))\n+foo(char c)\n+{\n+  unsigned short a = (unsigned short)c;\n+  if (a >= -32000 && a <= 32000)\n+    return c == 0;\n+  return -1;\n+}\n+\n+extern void abort (void);\n+\n+int main()\n+{\n+  if (foo(1) == 1)\n+    abort ();\n+  return 0;\n+}\n+"}, {"sha": "69329affb364a416ffebd998d26aa512714e7719", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp39.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70b7b0376ecb761a23a30c4626cb14d9f6cecda6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp39.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70b7b0376ecb761a23a30c4626cb14d9f6cecda6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp39.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp39.c?ref=70b7b0376ecb761a23a30c4626cb14d9f6cecda6", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do link } */\n+/* { dg-options \"-O2\" } */\n+\n+extern void link_error (void);\n+\n+void test1(int i)\n+{\n+  if (i >= -5 && i <= 8)\n+    {\n+      unsigned int j = i;\n+      if (j == -6)\n+\tlink_error ();\n+      if (j == 9)\n+\tlink_error ();\n+    }\n+}\n+\n+int main() { return 0; }"}, {"sha": "1e22bd49bc8a1643dd7ad9b21c0ed1346aa13ddb", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 186, "deletions": 89, "changes": 275, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70b7b0376ecb761a23a30c4626cb14d9f6cecda6/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70b7b0376ecb761a23a30c4626cb14d9f6cecda6/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=70b7b0376ecb761a23a30c4626cb14d9f6cecda6", "patch": "@@ -105,6 +105,64 @@ static value_range_t **vr_value;\n static int *vr_phi_edge_counts;\n \n \n+/* Return the maximum value for TYPEs base type.  */\n+\n+static inline tree\n+vrp_val_max (const_tree type)\n+{\n+  if (!INTEGRAL_TYPE_P (type))\n+    return NULL_TREE;\n+\n+  /* For integer sub-types the values for the base type are relevant.  */\n+  if (TREE_TYPE (type))\n+    type = TREE_TYPE (type);\n+\n+  return TYPE_MAX_VALUE (type);\n+}\n+\n+/* Return the minimum value for TYPEs base type.  */\n+\n+static inline tree\n+vrp_val_min (const_tree type)\n+{\n+  if (!INTEGRAL_TYPE_P (type))\n+    return NULL_TREE;\n+\n+  /* For integer sub-types the values for the base type are relevant.  */\n+  if (TREE_TYPE (type))\n+    type = TREE_TYPE (type);\n+\n+  return TYPE_MIN_VALUE (type);\n+}\n+\n+/* Return whether VAL is equal to the maximum value of its type.  This\n+   will be true for a positive overflow infinity.  We can't do a\n+   simple equality comparison with TYPE_MAX_VALUE because C typedefs\n+   and Ada subtypes can produce types whose TYPE_MAX_VALUE is not ==\n+   to the integer constant with the same value in the type.  */\n+\n+static inline bool\n+vrp_val_is_max (const_tree val)\n+{\n+  tree type_max = vrp_val_max (TREE_TYPE (val));\n+  return (val == type_max\n+\t  || (type_max != NULL_TREE\n+\t      && operand_equal_p (val, type_max, 0)));\n+}\n+\n+/* Return whether VAL is equal to the minimum value of its type.  This\n+   will be true for a negative overflow infinity.  */\n+\n+static inline bool\n+vrp_val_is_min (const_tree val)\n+{\n+  tree type_min = vrp_val_min (TREE_TYPE (val));\n+  return (val == type_min\n+\t  || (type_min != NULL_TREE\n+\t      && operand_equal_p (val, type_min, 0)));\n+}\n+\n+\n /* Return whether TYPE should use an overflow infinity distinct from\n    TYPE_{MIN,MAX}_VALUE.  We use an overflow infinity value to\n    represent a signed overflow during VRP computations.  An infinity\n@@ -130,13 +188,14 @@ needs_overflow_infinity (const_tree type)\n static inline bool\n supports_overflow_infinity (const_tree type)\n {\n+  tree min = vrp_val_min (type), max = vrp_val_max (type);\n #ifdef ENABLE_CHECKING\n   gcc_assert (needs_overflow_infinity (type));\n #endif\n-  return (TYPE_MIN_VALUE (type) != NULL_TREE\n-\t  && CONSTANT_CLASS_P (TYPE_MIN_VALUE (type))\n-\t  && TYPE_MAX_VALUE (type) != NULL_TREE\n-\t  && CONSTANT_CLASS_P (TYPE_MAX_VALUE (type)));\n+  return (min != NULL_TREE\n+\t  && CONSTANT_CLASS_P (min)\n+\t  && max != NULL_TREE\n+\t  && CONSTANT_CLASS_P (max));\n }\n \n /* VAL is the maximum or minimum value of a type.  Return a\n@@ -161,7 +220,7 @@ negative_overflow_infinity (tree type)\n #ifdef ENABLE_CHECKING\n   gcc_assert (supports_overflow_infinity (type));\n #endif\n-  return make_overflow_infinity (TYPE_MIN_VALUE (type));\n+  return make_overflow_infinity (vrp_val_min (type));\n }\n \n /* Return a positive overflow infinity for TYPE.  */\n@@ -172,7 +231,7 @@ positive_overflow_infinity (tree type)\n #ifdef ENABLE_CHECKING\n   gcc_assert (supports_overflow_infinity (type));\n #endif\n-  return make_overflow_infinity (TYPE_MAX_VALUE (type));\n+  return make_overflow_infinity (vrp_val_max (type));\n }\n \n /* Return whether VAL is a negative overflow infinity.  */\n@@ -183,7 +242,7 @@ is_negative_overflow_infinity (const_tree val)\n   return (needs_overflow_infinity (TREE_TYPE (val))\n \t  && CONSTANT_CLASS_P (val)\n \t  && TREE_OVERFLOW (val)\n-\t  && operand_equal_p (val, TYPE_MIN_VALUE (TREE_TYPE (val)), 0));\n+\t  && vrp_val_is_min (val));\n }\n \n /* Return whether VAL is a positive overflow infinity.  */\n@@ -194,7 +253,7 @@ is_positive_overflow_infinity (const_tree val)\n   return (needs_overflow_infinity (TREE_TYPE (val))\n \t  && CONSTANT_CLASS_P (val)\n \t  && TREE_OVERFLOW (val)\n-\t  && operand_equal_p (val, TYPE_MAX_VALUE (TREE_TYPE (val)), 0));\n+\t  && vrp_val_is_max (val));\n }\n \n /* Return whether VAL is a positive or negative overflow infinity.  */\n@@ -205,8 +264,7 @@ is_overflow_infinity (const_tree val)\n   return (needs_overflow_infinity (TREE_TYPE (val))\n \t  && CONSTANT_CLASS_P (val)\n \t  && TREE_OVERFLOW (val)\n-\t  && (operand_equal_p (val, TYPE_MAX_VALUE (TREE_TYPE (val)), 0)\n-\t      || operand_equal_p (val, TYPE_MIN_VALUE (TREE_TYPE (val)), 0)));\n+\t  && (vrp_val_is_min (val) || vrp_val_is_max (val)));\n }\n \n /* If VAL is now an overflow infinity, return VAL.  Otherwise, return\n@@ -219,58 +277,18 @@ avoid_overflow_infinity (tree val)\n   if (!is_overflow_infinity (val))\n     return val;\n \n-  if (operand_equal_p (val, TYPE_MAX_VALUE (TREE_TYPE (val)), 0))\n-    return TYPE_MAX_VALUE (TREE_TYPE (val));\n+  if (vrp_val_is_max (val))\n+    return vrp_val_max (TREE_TYPE (val));\n   else\n     {\n #ifdef ENABLE_CHECKING\n-      gcc_assert (operand_equal_p (val, TYPE_MIN_VALUE (TREE_TYPE (val)), 0));\n+      gcc_assert (vrp_val_is_min (val));\n #endif\n-      return TYPE_MIN_VALUE (TREE_TYPE (val));\n+      return vrp_val_min (TREE_TYPE (val));\n     }\n }\n \n \n-/* Return whether VAL is equal to the maximum value of its type.  This\n-   will be true for a positive overflow infinity.  We can't do a\n-   simple equality comparison with TYPE_MAX_VALUE because C typedefs\n-   and Ada subtypes can produce types whose TYPE_MAX_VALUE is not ==\n-   to the integer constant with the same value in the type.  */\n-\n-static inline bool\n-vrp_val_is_max (const_tree val)\n-{\n-  tree type_max, type = TREE_TYPE (val);\n-\n-  /* For integer sub-types the values for the base type are relevant.  */\n-  if (TREE_TYPE (type))\n-    type = TREE_TYPE (type);\n-  type_max = TYPE_MAX_VALUE (type);\n-\n-  return (val == type_max\n-\t  || (type_max != NULL_TREE\n-\t      && operand_equal_p (val, type_max, 0)));\n-}\n-\n-/* Return whether VAL is equal to the minimum value of its type.  This\n-   will be true for a negative overflow infinity.  */\n-\n-static inline bool\n-vrp_val_is_min (const_tree val)\n-{\n-  tree type_min, type = TREE_TYPE (val);\n-\n-  /* For integer sub-types the values for the base type are relevant.  */\n-  if (TREE_TYPE (type))\n-    type = TREE_TYPE (type);\n-  type_min = TYPE_MIN_VALUE (type);\n-\n-  return (val == type_min\n-\t  || (type_min != NULL_TREE\n-\t      && operand_equal_p (val, type_min, 0)));\n-}\n-\n-\n /* Return true if ARG is marked with the nonnull attribute in the\n    current function signature.  */\n \n@@ -396,35 +414,68 @@ static void\n set_and_canonicalize_value_range (value_range_t *vr, enum value_range_type t,\n \t\t\t\t  tree min, tree max, bitmap equiv)\n {\n-  tree one, tmp;\n-\n+  /* Nothing to canonicalize for symbolic or unknown or varying ranges.  */\n   if ((t != VR_RANGE\n        && t != VR_ANTI_RANGE)\n       || TREE_CODE (min) != INTEGER_CST\n-      || TREE_CODE (max) != INTEGER_CST\n-      || !tree_int_cst_lt (max, min))\n+      || TREE_CODE (max) != INTEGER_CST)\n     {\n       set_value_range (vr, t, min, max, equiv);\n       return;\n     }\n \n   /* Wrong order for min and max, to swap them and the VR type we need\n      to adjust them.  */\n-  one = build_int_cst (TREE_TYPE (min), 1);\n-  tmp = int_const_binop (PLUS_EXPR, max, one, 0);\n-  max = int_const_binop (MINUS_EXPR, min, one, 0);\n-  min = tmp;\n-\n-  /* There's one corner case, if we had [C+1, C] before we now have\n-     that again.  But this represents an empty value range, so drop\n-     to varying in this case.  */\n   if (tree_int_cst_lt (max, min))\n     {\n-      set_value_range_to_varying (vr);\n-      return;\n+      tree one = build_int_cst (TREE_TYPE (min), 1);\n+      tree tmp = int_const_binop (PLUS_EXPR, max, one, 0);\n+      max = int_const_binop (MINUS_EXPR, min, one, 0);\n+      min = tmp;\n+\n+      /* There's one corner case, if we had [C+1, C] before we now have\n+\t that again.  But this represents an empty value range, so drop\n+\t to varying in this case.  */\n+      if (tree_int_cst_lt (max, min))\n+\t{\n+\t  set_value_range_to_varying (vr);\n+\t  return;\n+\t}\n+\n+      t = t == VR_RANGE ? VR_ANTI_RANGE : VR_RANGE;\n+    }\n+\n+  /* Anti-ranges that can be represented as ranges should be so.  */\n+  if (t == VR_ANTI_RANGE)\n+    {\n+      bool is_min = vrp_val_is_min (min);\n+      bool is_max = vrp_val_is_max (max);\n+\n+      if (is_min && is_max)\n+\t{\n+\t  /* We cannot deal with empty ranges, drop to varying.  */\n+\t  set_value_range_to_varying (vr);\n+\t  return;\n+\t}\n+      else if (is_min\n+\t       /* As a special exception preserve non-null ranges.  */\n+\t       && !(TYPE_UNSIGNED (TREE_TYPE (min))\n+\t\t    && integer_zerop (max)))\n+        {\n+\t  tree one = build_int_cst (TREE_TYPE (max), 1);\n+\t  min = int_const_binop (PLUS_EXPR, max, one, 0);\n+\t  max = vrp_val_max (TREE_TYPE (max));\n+\t  t = VR_RANGE;\n+        }\n+      else if (is_max)\n+        {\n+\t  tree one = build_int_cst (TREE_TYPE (min), 1);\n+\t  max = int_const_binop (MINUS_EXPR, min, one, 0);\n+\t  min = vrp_val_min (TREE_TYPE (min));\n+\t  t = VR_RANGE;\n+        }\n     }\n \n-  t = t == VR_RANGE ? VR_ANTI_RANGE : VR_RANGE;\n   set_value_range (vr, t, min, max, equiv);\n }\n \n@@ -1233,23 +1284,26 @@ extract_range_from_assert (value_range_t *vr_p, tree expr)\n   if (TREE_CODE (cond) == NOP_EXPR\n       || TREE_CODE (cond) == PLUS_EXPR)\n     {\n-      tree cst2 = NULL_TREE;\n-\n       if (TREE_CODE (cond) == PLUS_EXPR)\n         {\n-          min = TREE_OPERAND (cond, 1);\n-\t  cst2 = fold_build1 (NEGATE_EXPR, TREE_TYPE (min), min);\n-          min = fold_convert (TREE_TYPE (var), cst2);\n+          min = fold_build1 (NEGATE_EXPR, TREE_TYPE (TREE_OPERAND (cond, 1)),\n+\t\t\t     TREE_OPERAND (cond, 1));\n+          max = int_const_binop (PLUS_EXPR, limit, min, 0);\n \t  cond = TREE_OPERAND (cond, 0);\n \t}\n       else\n-\tmin = build_int_cst (TREE_TYPE (var), 0);\n+\t{\n+\t  min = build_int_cst (TREE_TYPE (var), 0);\n+\t  max = limit;\n+\t}\n \n-      if (cst2 != NULL_TREE)\n-        max = int_const_binop (PLUS_EXPR, limit, min, 0);\n-      else\n-\tmax = limit;\n-      max = fold_convert (TREE_TYPE (var), max);\n+      /* Make sure to not set TREE_OVERFLOW on the final type\n+\t conversion.  We are willingly interpreting large positive\n+\t unsigned values as negative singed values here.  */\n+      min = force_fit_type_double (TREE_TYPE (var), TREE_INT_CST_LOW (min),\n+\t\t\t\t   TREE_INT_CST_HIGH (min), 0, false);\n+      max = force_fit_type_double (TREE_TYPE (var), TREE_INT_CST_LOW (max),\n+\t\t\t\t   TREE_INT_CST_HIGH (max), 0, false);\n \n       /* We can transform a max, min range to an anti-range or\n          vice-versa.  Use set_and_canonicalize_value_range which does\n@@ -1547,8 +1601,12 @@ extract_range_from_assert (value_range_t *vr_p, tree expr)\n \t  if (compare_values (anti_max, real_max) == -1\n \t      && compare_values (anti_min, real_min) == 1)\n \t    {\n-\t      set_value_range (vr_p, VR_RANGE, real_min,\n-\t\t\t       real_max, vr_p->equiv);\n+\t      /* If the range is covering the whole valid range of\n+\t\t the type keep the anti-range.  */\n+\t      if (!vrp_val_is_min (real_min)\n+\t\t  || !vrp_val_is_max (real_max))\n+\t        set_value_range (vr_p, VR_RANGE, real_min,\n+\t\t\t\t real_max, vr_p->equiv);\n \t    }\n \t  /* Case 2, VR_ANTI_RANGE completely disjoint from\n \t     VR_RANGE.  */\n@@ -3754,7 +3812,7 @@ register_edge_assert_for_2 (tree name, edge e, block_stmt_iterator bsi,\n       && TYPE_UNSIGNED (TREE_TYPE (val)))\n     {\n       tree def_stmt = SSA_NAME_DEF_STMT (name);\n-      tree cst2 = NULL_TREE, name2 = NULL_TREE;\n+      tree cst2 = NULL_TREE, name2 = NULL_TREE, name3 = NULL_TREE;\n \n       /* Extract CST2 from the (optional) addition.  */\n       if (TREE_CODE (def_stmt) == GIMPLE_MODIFY_STMT\n@@ -3767,16 +3825,55 @@ register_edge_assert_for_2 (tree name, edge e, block_stmt_iterator bsi,\n \t    def_stmt = SSA_NAME_DEF_STMT (name2);\n \t}\n \n-      /* Extract NAME2 from the (optional) cast.  */\n+      /* Extract NAME2 from the (optional) sign-changing cast.  */\n       if (TREE_CODE (def_stmt) == GIMPLE_MODIFY_STMT\n-          && TREE_CODE (GIMPLE_STMT_OPERAND (def_stmt, 1)) == NOP_EXPR)\n-\tname2 = TREE_OPERAND (GIMPLE_STMT_OPERAND (def_stmt, 1), 0);\n+          && (TREE_CODE (GIMPLE_STMT_OPERAND (def_stmt, 1)) == NOP_EXPR\n+\t      || TREE_CODE (GIMPLE_STMT_OPERAND (def_stmt, 1)) == CONVERT_EXPR))\n+\t{\n+\t  tree rhs = GIMPLE_STMT_OPERAND (def_stmt, 1);\n+\t  if ((TREE_CODE (rhs) == NOP_EXPR\n+\t       || TREE_CODE (rhs) == CONVERT_EXPR)\n+\t      && ! TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (rhs, 0)))\n+\t      && (TYPE_PRECISION (TREE_TYPE (rhs))\n+\t\t  == TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (rhs, 0)))))\n+\t    name3 = TREE_OPERAND (GIMPLE_STMT_OPERAND (def_stmt, 1), 0);\n+\t}\n \n-      if (name2 != NULL_TREE\n-      \t  && TREE_CODE (name2) == SSA_NAME\n+      /* If name3 is used later, create an ASSERT_EXPR for it.  */\n+      if (name3 != NULL_TREE\n+      \t  && TREE_CODE (name3) == SSA_NAME\n \t  && (cst2 == NULL_TREE\n \t      || TREE_CODE (cst2) == INTEGER_CST)\n-\t  && TREE_CODE (TREE_TYPE (name2)) == INTEGER_TYPE\n+\t  && INTEGRAL_TYPE_P (TREE_TYPE (name3))\n+\t  && TEST_BIT (found_in_subgraph, SSA_NAME_VERSION (name3))\n+\t  && !has_single_use (name3))\n+\t{\n+\t  tree tmp;\n+\n+\t  /* Build an expression for the range test.  */\n+\t  tmp = build1 (NOP_EXPR, TREE_TYPE (name), name3);\n+\t  if (cst2 != NULL_TREE)\n+\t    tmp = build2 (PLUS_EXPR, TREE_TYPE (name), tmp, cst2);\n+\n+\t  if (dump_file)\n+\t    {\n+\t      fprintf (dump_file, \"Adding assert for \");\n+\t      print_generic_expr (dump_file, name3, 0);\n+\t      fprintf (dump_file, \" from \");\n+\t      print_generic_expr (dump_file, tmp, 0);\n+\t      fprintf (dump_file, \"\\n\");\n+\t    }\n+\n+\t  register_new_assert_for (name3, tmp, comp_code, val, NULL, e, bsi);\n+\n+\t  retval = true;\n+\t}\n+\n+      /* If name2 is used later, create an ASSERT_EXPR for it.  */\n+      if (name2 != NULL_TREE\n+      \t  && TREE_CODE (name2) == SSA_NAME\n+\t  && TREE_CODE (cst2) == INTEGER_CST\n+\t  && INTEGRAL_TYPE_P (TREE_TYPE (name2))\n \t  && TEST_BIT (found_in_subgraph, SSA_NAME_VERSION (name2))\n \t  && !has_single_use (name2))\n \t{"}]}