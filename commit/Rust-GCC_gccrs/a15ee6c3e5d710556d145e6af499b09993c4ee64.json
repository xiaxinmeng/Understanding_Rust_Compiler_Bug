{"sha": "a15ee6c3e5d710556d145e6af499b09993c4ee64", "node_id": "C_kwDOANBUbNoAKGExNWVlNmMzZTVkNzEwNTU2ZDE0NWU2YWY0OTliMDk5OTNjNGVlNjQ", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-08-23T13:48:25Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-08-23T13:48:25Z"}, "message": "Remove missed target hooks code", "tree": {"sha": "bb6dab2667f33075a4aa3bfcd9ebf32d60c596c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bb6dab2667f33075a4aa3bfcd9ebf32d60c596c7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a15ee6c3e5d710556d145e6af499b09993c4ee64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a15ee6c3e5d710556d145e6af499b09993c4ee64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a15ee6c3e5d710556d145e6af499b09993c4ee64", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a15ee6c3e5d710556d145e6af499b09993c4ee64/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8d1a6deb4e69e7dc162e741377674cf03459bcd9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d1a6deb4e69e7dc162e741377674cf03459bcd9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d1a6deb4e69e7dc162e741377674cf03459bcd9"}], "stats": {"total": 3087, "additions": 0, "deletions": 3087}, "files": [{"sha": "eb16a98891e33b3b0023fbde06bfad1eb30a53cd", "filename": "gcc/config/aarch64/aarch64-rust.cc", "status": "removed", "additions": 0, "deletions": 146, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d1a6deb4e69e7dc162e741377674cf03459bcd9/gcc%2Fconfig%2Faarch64%2Faarch64-rust.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d1a6deb4e69e7dc162e741377674cf03459bcd9/gcc%2Fconfig%2Faarch64%2Faarch64-rust.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-rust.cc?ref=8d1a6deb4e69e7dc162e741377674cf03459bcd9", "patch": "@@ -1,146 +0,0 @@\n-/* Subroutines for the Rust front end on the AArch64 architecture.\n-   Copyright (C) 2020-2022 Free Software Foundation, Inc.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"tm_p.h\"\n-#include \"rust/rust-target.h\"\n-#include \"rust/rust-target-def.h\"\n-\n-/* Implement TARGET_RUST_CPU_INFO for AArch64 targets.  */\n-\n-void aarch64_rust_target_cpu_info(void) {\n-    rust_add_target_info(\"target_arch\", \"aarch64\");\n-\n-    // TODO: almost feature-complete with rustc - missing \"ras\" feature (which is not in gcc)\n-\n-    // features from rustc\n-    if (TARGET_FLOAT) {\n-        rust_add_target_info(\"target_feature\", \"fp-armv8\");\n-        rust_add_target_info(\"target_feature\", \"fp\");\n-    }\n-    if (TARGET_SIMD)\n-        rust_add_target_info(\"target_feature\", \"neon\");\n-    if (TARGET_SVE)\n-        rust_add_target_info(\"target_feature\", \"sve\");\n-    if (TARGET_CRC32)\n-        rust_add_target_info(\"target_feature\", \"crc\");\n-    if (TARGET_CRYPTO)\n-        rust_add_target_info(\"target_feature\", \"crypto\");\n-    if (TARGET_LSE)\n-        rust_add_target_info(\"target_feature\", \"lse\");\n-    if (AARCH64_ISA_RDMA)\n-        rust_add_target_info(\"target_feature\", \"rdm\");\n-    if (TARGET_FP_F16INST) {\n-        rust_add_target_info(\"target_feature\", \"fullfp16\");\n-        rust_add_target_info(\"target_feature\", \"fp16\");\n-    }\n-    if (aarch64_isa_flags & AARCH64_FL_RCPC)\n-        rust_add_target_info(\"target_feature\", \"rcpc\");\n-    if (TARGET_DOTPROD)\n-        rust_add_target_info(\"target_feature\", \"dotprod\");\n-    if (aarch64_isa_flags & AARCH64_FL_V8_1)\n-        rust_add_target_info(\"target_feature\", \"v8.1a\");\n-    if (AARCH64_ISA_V8_2)\n-        rust_add_target_info(\"target_feature\", \"v8.2a\");\n-    if (AARCH64_ISA_V8_3)\n-        rust_add_target_info(\"target_feature\", \"v8.3a\");\n-\n-    // llvm-derived features\n-    if (TARGET_SM4)\n-        rust_add_target_info(\"target_feature\", \"sm4\");\n-    if (TARGET_SHA2)\n-        rust_add_target_info(\"target_feature\", \"sha2\");\n-    if (TARGET_SHA3)\n-        rust_add_target_info(\"target_feature\", \"sha3\");\n-    if (TARGET_AES)\n-        rust_add_target_info(\"target_feature\", \"aes\");\n-    if (TARGET_F16FML)\n-        rust_add_target_info(\"target_feature\", \"fp16fml\");\n-    if (aarch64_isa_flags & AARCH64_FL_PROFILE)\n-        rust_add_target_info(\"target_feature\", \"spe\");\n-    if (TARGET_SVE2)\n-        rust_add_target_info(\"target_feature\", \"sve2\");\n-    if (aarch64_isa_flags & AARCH64_FL_SVE2_AES)\n-        rust_add_target_info(\"target_feature\", \"sve2-aes\");\n-    if (aarch64_isa_flags & AARCH64_FL_SVE2_SM4)\n-        rust_add_target_info(\"target_feature\", \"sve2-sm4\");\n-    if (aarch64_isa_flags & AARCH64_FL_SVE2_SHA3)\n-        rust_add_target_info(\"target_feature\", \"sve2-sha3\");\n-    if (aarch64_isa_flags & AARCH64_FL_SVE2_BITPERM)\n-        rust_add_target_info(\"target_feature\", \"sve2-bitperm\");\n-    if (TARGET_STRICT_ALIGN)\n-        rust_add_target_info(\"target_feature\", \"strict-align\");\n-    if (flag_mrecip_low_precision_sqrt)\n-        rust_add_target_info(\"target_feature\", \"use-reciprocal-square-root\");\n-    if (TARGET_JSCVT)\n-        rust_add_target_info(\"target_feature\", \"jsconv\");\n-    if (TARGET_COMPLEX)\n-        rust_add_target_info(\"target_feature\", \"complxnum\");\n-    if (AARCH64_ISA_RCPC8_4)\n-        rust_add_target_info(\"target_feature\", \"rcpc-immo\");\n-    if (TARGET_FRINT)\n-        rust_add_target_info(\"target_feature\", \"fptoint\");\n-    if (aarch64_isa_flags & AARCH64_FL_SB)\n-        rust_add_target_info(\"target_feature\", \"sb\");\n-    if (aarch64_isa_flags & AARCH64_FL_SSBS)\n-        rust_add_target_info(\"target_feature\", \"ssbs\");\n-    if (aarch64_isa_flags & AARCH64_FL_PREDRES)\n-        rust_add_target_info(\"target_feature\", \"predres\");\n-    if (aarch64_enable_bti)\n-        rust_add_target_info(\"target_feature\", \"bti\");\n-    if (AARCH64_ISA_RNG)\n-        rust_add_target_info(\"target_feature\", \"rand\");\n-    if (TARGET_MEMTAG)\n-        rust_add_target_info(\"target_feature\", \"mte\");\n-    if (TARGET_TME)\n-        rust_add_target_info(\"target_feature\", \"tme\");\n-    if (AARCH64_ISA_BF16)\n-        rust_add_target_info(\"target_feature\", \"bf16\");\n-    if (AARCH64_ISA_I8MM)\n-        rust_add_target_info(\"target_feature\", \"i8mm\");\n-    if (AARCH64_ISA_F32MM)\n-        rust_add_target_info(\"target_feature\", \"f32mm\");\n-    if (AARCH64_ISA_F64MM)\n-        rust_add_target_info(\"target_feature\", \"f64mm\");\n-    if (AARCH64_ISA_V8_4)\n-        rust_add_target_info(\"target_feature\", \"v8.4a\");\n-    if (AARCH64_ISA_V8_5)\n-        rust_add_target_info(\"target_feature\", \"v8.5a\");\n-    if (AARCH64_ISA_V8_6)\n-        rust_add_target_info(\"target_feature\", \"v8.6a\");\n-\n-    /* TODO: find features for pan (Privileged Access-Never), lor (Limited Ordering Regions),\n-     * vh (Virtual Host), perfmon, pan-rwv (PAN s1e1R and s1e1W variants),\n-     * uaops (UAO PState), ccpp (Cache Clean to Point of Persistence), zcm (zero-cycle register move),\n-     * zcz-gp (zero-cycle zeroing for generic regs), zcz-fp (zero-cycle zeroing for FP regs), zcz\n-     * (both), zcz-fp-workaround, reserve specific registers, make specific registers callee saved,\n-     * use-aa (alias analysis), balance-fp-ops, predictable-select-expensive, custom-cheap-as-move,\n-     * exynos-cheap-as-move, use-postra-scheduler, slow-misaligned-128store, slow-paired-128,\n-     * slow-strqro-store, alternate-sextload-cvt-f32-pattern, arith-bcc-fusion, arith-cbz-fusion,\n-     * fuse-address, fuse-aes, fuse-arith-logic, fuse-csel, fuse-crypto-eor, fuse-literals,\n-     * disable-latency-sched-heuristic, force-32bit-jump-tables, pa\n-     * (Pointer Authentication), ccidx (extend CCSIDR number of sets),\n-     * nv (Nested Virtualisation), rasv8_4, mpam (Memory system Partitioning and Monitoring),\n-     * dit (Data Independent Timing), tracev8.4, am (Activity Monitors), amvs (Activity Monitors\n-     * Virtualisation), sel2 (Secure Exception Level 2), pmu, tlb-rmi (TLB Range and Maintenance), fmi\n-     * (Flag Manipulation), no-neg-immediates, lsl-fast, aggressive-fma,\n-     * altnzcv, specrestrict, ccdp, trbe, ete, tagged-globals, fgt, ecv, maybe cpus */\n-    // gcc supports pointer authentication, but i can only find builtins and no switch for it\n-}"}, {"sha": "74a6902a7d2bef62bd0001055de3771a81de12d0", "filename": "gcc/config/alpha/alpha-rust.cc", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d1a6deb4e69e7dc162e741377674cf03459bcd9/gcc%2Fconfig%2Falpha%2Falpha-rust.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d1a6deb4e69e7dc162e741377674cf03459bcd9/gcc%2Fconfig%2Falpha%2Falpha-rust.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha-rust.cc?ref=8d1a6deb4e69e7dc162e741377674cf03459bcd9", "patch": "@@ -1,44 +0,0 @@\n-/* Subroutines for the Rust front end on the DEC Alpha.\n-   Copyright (C) 2020-2022 Free Software Foundation, Inc.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"rust/rust-target.h\"\n-#include \"rust/rust-target-def.h\"\n-\n-/* Implement TARGET_RUST_CPU_INFO for DEC Alpha targets.  */\n-\n-void\n-alpha_rust_target_cpu_info (void)\n-{\n-  /* i couldn't actually confirm that this was the arch name (removed from llvm and no rustc support),\n-   * but i don't think they would choose something different to gcc */\n-  rust_add_target_info (\"target_arch\", \"alpha\");\n-\n-  // CIX was actually the only llvm option available when it was removed, but adding other gcc ones\n-  if (TARGET_CIX)\t\n-    rust_add_target_info (\"target_feature\", \"cix\");\t\n-  if (TARGET_FIX)\t\n-    rust_add_target_info (\"target_feature\", \"fix\");\t\n-  if (TARGET_BWX)\t\n-    rust_add_target_info (\"target_feature\", \"bwx\");\t\n-  // may be called \"mvi\" under rustc (but they have no support for it atm, so who cares amirite?)\n-  if (TARGET_MAX)\t\n-    rust_add_target_info (\"target_feature\", \"max\");\t\n-}"}, {"sha": "c94749f0559335819a27904a9fbee77644bc9ab7", "filename": "gcc/config/arc/arc-rust.cc", "status": "removed", "additions": 0, "deletions": 104, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d1a6deb4e69e7dc162e741377674cf03459bcd9/gcc%2Fconfig%2Farc%2Farc-rust.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d1a6deb4e69e7dc162e741377674cf03459bcd9/gcc%2Fconfig%2Farc%2Farc-rust.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc-rust.cc?ref=8d1a6deb4e69e7dc162e741377674cf03459bcd9", "patch": "@@ -1,104 +0,0 @@\n-/* Subroutines for the Rust front end on the Synopsys DesignWare ARC cpu.\n-   Copyright (C) 2020-2022 Free Software Foundation, Inc.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"rust/rust-target.h\"\n-#include \"rust/rust-target-def.h\"\n-\n-/* Implement TARGET_RUST_CPU_INFO for Synopsys DesignWare ARC targets.  */\n-\n-void\n-arc_rust_target_cpu_info (void)\n-{\n-  rust_add_target_info (\"target_arch\", \"arc\");\n-\n-  /* in llvm, the arc target has no \"subtargets\" (features according to rustc) as far as I can tell\n-   * gcc has a bunch of target macros that look like they could represent features, which I've added\n-   * provisionally. TODO add and rename features based on llvm. */\n-  if (TARGET_NORM)\n-    rust_add_target_info (\"target_feature\", \"norm\");\n-  if (TARGET_OPTFPE)\n-    rust_add_target_info (\"target_feature\", \"optfpe\");\n-  if (TARGET_SWAP)\n-    rust_add_target_info (\"target_feature\", \"swap\");\n-\n-  if (TARGET_UNALIGN_BRANCH)\n-    rust_add_target_info (\"target_feature\", \"unalign-branch\");\n-  if (TARGET_PAD_RETURN)\n-    rust_add_target_info (\"target_feature\", \"pad-return\");\n-  if (TARGET_AT_DBR_CONDEXEC)\n-    rust_add_target_info (\"target_feature\", \"at-dbr-condexec\");\n-\n-  // TODO: maybe define different cpu types? \n-\n-  // TODO: are all these below needed and useful?\n-  if (TARGET_MPYW)\n-    rust_add_target_info (\"target_feature\", \"mpyw\");\n-  if (TARGET_MULTI)\n-    rust_add_target_info (\"target_feature\", \"multi\");\n-  if (TARGET_MPY)\n-    rust_add_target_info (\"target_feature\", \"mpy\");\n-  if (TARGET_ARC700_MPY)\n-    rust_add_target_info (\"target_feature\", \"arc700-mpy\");\n-  if (TARGET_ANY_MPY)\n-    rust_add_target_info (\"target_feature\", \"any-mpy\");\n-  if (TARGET_PLUS_DMPY)\n-    rust_add_target_info (\"target_feature\", \"plus-dmpy\");\n-  if (TARGET_PLUS_MACD)\n-    rust_add_target_info (\"target_feature\", \"plus-macd\");\n-  if (TARGET_PLUS_QMACW)\n-    rust_add_target_info (\"target_feature\", \"plus-qmacw\");\n-  if (TARGET_LP_WR_INTERLOCK)\n-    rust_add_target_info (\"target_feature\", \"lp-wr-interlock\");\n-\n-  // TODO: should different cpu families be removed?\n-  if (TARGET_ARC600_FAMILY)\n-    rust_add_target_info (\"target_feature\", \"arc600-family\");\n-  if (TARGET_ARCOMPACT_FAMILY)\n-    rust_add_target_info (\"target_feature\", \"arcompact-family\");\n-\n-  if (TARGET_HARD_FLOAT)\n-    rust_add_target_info (\"target_feature\", \"hard-float\");\n-  if (TARGET_FP_SP_BASE)\n-    rust_add_target_info (\"target_feature\", \"fp-sp-base\");\n-  if (TARGET_FP_DP_BASE)\n-    rust_add_target_info (\"target_feature\", \"fp-dp-base\");\n-  if (TARGET_FP_SP_FUSED)\n-    rust_add_target_info (\"target_feature\", \"fp-sp-fused\");\n-  if (TARGET_FP_DP_FUSED)\n-    rust_add_target_info (\"target_feature\", \"fp-dp-fused\");\n-  if (TARGET_FP_SP_CONV)\n-    rust_add_target_info (\"target_feature\", \"fp-sp-conv\");\n-  if (TARGET_FP_DP_CONV)\n-    rust_add_target_info (\"target_feature\", \"fp-dp-conv\");\n-  if (TARGET_FP_SP_SQRT)\n-    rust_add_target_info (\"target_feature\", \"fp-sp-sqrt\");\n-  if (TARGET_FP_DP_SQRT)\n-    rust_add_target_info (\"target_feature\", \"fp-dp-sqrt\");\n-  if (TARGET_FP_DP_AX)\n-    rust_add_target_info (\"target_feature\", \"fp-dp-ax\");\n-  if (TARGET_FPX_QUARK)\n-    rust_add_target_info (\"target_feature\", \"fpx-quark\");\n-  if (TARGET_DBNZ)\n-    rust_add_target_info (\"target_feature\", \"dbnz\");\n-  \n-  if (TARGET_BI_BIH)\n-    rust_add_target_info (\"target_feature\", \"bi-bih\");\n-}"}, {"sha": "0c78ce6e92a9fda366ea52a9f42ac2e7ad0c1a70", "filename": "gcc/config/arm/arm-rust.cc", "status": "removed", "additions": 0, "deletions": 262, "changes": 262, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d1a6deb4e69e7dc162e741377674cf03459bcd9/gcc%2Fconfig%2Farm%2Farm-rust.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d1a6deb4e69e7dc162e741377674cf03459bcd9/gcc%2Fconfig%2Farm%2Farm-rust.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-rust.cc?ref=8d1a6deb4e69e7dc162e741377674cf03459bcd9", "patch": "@@ -1,262 +0,0 @@\n-/* Subroutines for the Rust front end on the ARM architecture.\n-   Copyright (C) 2020-2022 Free Software Foundation, Inc.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"tm_p.h\"\n-#include \"rust/rust-target.h\"\n-#include \"rust/rust-target-def.h\"\n-\n-/* Implement TARGET_RUST_CPU_INFO for ARM targets.  */\n-\n-void arm_rust_target_cpu_info(void) {\n-    rust_add_target_info(\"target_arch\", \"arm\");\n-\n-    // features stabilised in rustc:\n-    switch (TARGET_ARM_ARCH_PROFILE) {\n-        case 'A':\n-            rust_add_target_info(\"target_feature\", \"aclass\");\n-            break;\n-        case 'R':\n-            rust_add_target_info(\"target_feature\", \"rclass\");\n-            break;\n-        case 'M':\n-            rust_add_target_info(\"target_feature\", \"mclass\");\n-            break;\n-        default:\n-            fprintf(stderr, \"Screwed up profile selection in arm-rust.cc - unknown profile '%c'\",\n-              TARGET_ARM_ARCH_PROFILE);\n-            break;\n-    }\n-    if (TARGET_DSP_MULTIPLY)\n-        rust_add_target_info(\"target_feature\", \"dsp\");\n-    if (TARGET_NEON)\n-        rust_add_target_info(\"target_feature\", \"neon\");\n-    if (TARGET_CRC32)\n-        rust_add_target_info(\"target_feature\", \"crc\");\n-    /* TODO: note that sha2 is an option for aarch64 in gcc but not for arm, so no feature here\n-     * possible. The same goes for aes. However, as llvm has them as prerequisites for crypto, they\n-     * are enabled with it. */\n-    if (TARGET_CRYPTO) {\n-        rust_add_target_info(\"target_feature\", \"crypto\");\n-        rust_add_target_info(\"target_feature\", \"sha2\");\n-        rust_add_target_info(\"target_feature\", \"aes\");\n-    }\n-    if (arm_arch5te)\n-        rust_add_target_info(\"target_feature\", \"v5te\");\n-    if (arm_arch6)\n-        rust_add_target_info(\"target_feature\", \"v6\");\n-    if (arm_arch6k)\n-        rust_add_target_info(\"target_feature\", \"v6k\");\n-    // as gcc does not appear to consider \"v6t2\" a proper arch, it is defined when prequisites are met\n-    bool hasV6T2 = arm_arch6k && arm_arch_thumb2; // TODO: also \"v8m baseline\" stuff too\n-    if (hasV6T2)\n-        rust_add_target_info(\"target_feature\", \"v6t2\");\n-    if (arm_arch7)\n-        rust_add_target_info(\"target_feature\", \"v7\");\n-    if (arm_arch8)\n-        rust_add_target_info(\"target_feature\", \"v8\");\n-    if (bitmap_bit_p(arm_active_target.isa, isa_bit_vfpv2) && TARGET_VFP_DOUBLE)\n-        rust_add_target_info(\"target_feature\", \"vfp2\");\n-    if (TARGET_VFP3 && TARGET_VFP_DOUBLE && TARGET_VFPD32)\n-        rust_add_target_info(\"target_feature\", \"vfp3\");\n-    if (bitmap_bit_p(arm_active_target.isa, isa_bit_vfpv4)\n-        && bitmap_bit_p(arm_active_target.isa, isa_bit_fp16conv) && TARGET_VFP_DOUBLE\n-        && TARGET_VFPD32)\n-        rust_add_target_info(\"target_feature\", \"vfp4\");\n-\n-    // llvm features:\n-    // should be correct option (i.e. thumb mode rather than just thumb-aware) as TARGET_ARM is\n-    // inverse\n-    if (TARGET_THUMB)\n-        rust_add_target_info(\"target_feature\", \"thumb-mode\");\n-    if (TARGET_SOFT_FLOAT) {\n-        rust_add_target_info(\"target_feature\", \"soft-float\");\n-    } else {\n-        // only have fp features if hard float\n-        if (bitmap_bit_p(arm_active_target.isa, isa_bit_vfp_base))\n-            rust_add_target_info(\"target_feature\", \"fpregs\");\n-        if (TARGET_VFP_DOUBLE) {\n-            rust_add_target_info(\"target_feature\", \"fp64\");\n-            rust_add_target_info(\"target_feature\", \"fpregs64\");\n-        }\n-        if (TARGET_VFPD32)\n-            rust_add_target_info(\"target_feature\", \"d32\");\n-        if (bitmap_bit_p(arm_active_target.isa, isa_bit_vfpv2)) {\n-            rust_add_target_info(\"target_feature\", \"vfp2sp\");\n-\n-            if (TARGET_VFP_DOUBLE)\n-                rust_add_target_info(\"target_feature\", \"vfp2\");\n-        }\n-        if (TARGET_VFP3) {\n-            rust_add_target_info(\"target_feature\", \"vfp3d16sp\");\n-\n-            if (TARGET_VFPD32)\n-                rust_add_target_info(\"target_feature\", \"vfp3sp\");\n-\n-            if (TARGET_VFP_DOUBLE) {\n-                rust_add_target_info(\"target_feature\", \"vfp3d16\");\n-\n-                if (TARGET_VFPD32)\n-                    rust_add_target_info(\"target_feature\", \"vfp3\");\n-            }\n-        }\n-        if (bitmap_bit_p(arm_active_target.isa, isa_bit_fp16conv))\n-            rust_add_target_info(\"target_info\", \"fp16\");\n-        if (bitmap_bit_p(arm_active_target.isa, isa_bit_vfpv4)) {\n-            // should implicitly enable fp16conv as well\n-            rust_add_target_info(\"target_feature\", \"vfp4d16sp\");\n-\n-            if (TARGET_VFPD32)\n-                rust_add_target_info(\"target_feature\", \"vfp4sp\");\n-\n-            if (TARGET_VFP_DOUBLE) {\n-                rust_add_target_info(\"target_feature\", \"vfp4d16\");\n-\n-                if (TARGET_VFPD32)\n-                    rust_add_target_info(\"target_feature\", \"vfp4\");\n-            }\n-        }\n-        // assuming that fp-armv8 is the same as fpv5\n-        if (TARGET_VFP5) {\n-            rust_add_target_info(\"target_feature\", \"fp-armv8d16sp\");\n-\n-            if (TARGET_VFPD32)\n-                rust_add_target_info(\"target_feature\", \"fp-armv8sp\");\n-\n-            if (TARGET_VFP_DOUBLE) {\n-                rust_add_target_info(\"target_feature\", \"fp-armv8d16\");\n-\n-                if (TARGET_VFPD32)\n-                    rust_add_target_info(\"target_feature\", \"fp-armv8\");\n-            }\n-        }\n-        if (bitmap_bit_p(arm_active_target.isa, isa_bit_fp16))\n-            rust_add_target_info(\"target_feature\", \"fullfp16\");\n-        if (bitmap_bit_p(arm_active_target.isa, isa_bit_fp16fml))\n-            rust_add_target_info(\"target_feature\", \"fp16fml\");\n-        if (arm_arch_thumb_hwdiv)\n-            rust_add_target_info(\"target_feature\", \"hwdiv\");\n-        if (arm_arch_arm_hwdiv)\n-            rust_add_target_info(\"target_feature\", \"hwdiv-arm\");\n-    }\n-    // TODO: I'm not sure if there's an exact correlation here (data barrier), so maybe research\n-    // There's also the question of whether this also means \"full data barrier\" (\"dfb\" in llvm)\n-    if (TARGET_HAVE_MEMORY_BARRIER)\n-        rust_add_target_info(\"target_feature\", \"db\");\n-    if (bitmap_bit_p(arm_active_target.isa, isa_bit_cmse))\n-        rust_add_target_info(\"target_feature\", \"8msecext\");\n-    if (TARGET_DOTPROD)\n-        rust_add_target_info(\"target_feature\", \"dotprod\");\n-    // TODO: supposedly gcc supports RAS, but I couldn't find the option, so leaving out \"ras\" for now\n-    if (bitmap_bit_p(arm_active_target.isa, isa_bit_mp))\n-        rust_add_target_info(\"target_feature\", \"mp\");\n-    // TODO: figure out the exact strict-align feature, which I'm pretty sure GCC has\n-    // TODO: figure out how to access long call data (which is in GCC) for \"long-calls\"\n-    if (bitmap_bit_p(arm_active_target.isa, isa_bit_sb))\n-        rust_add_target_info(\"target_feature\", \"sb\");\n-    if (bitmap_bit_p(arm_active_target.isa, isa_bit_bf16))\n-        rust_add_target_info(\"target_feature\", \"bf16\");\n-    if (bitmap_bit_p(arm_active_target.isa, isa_bit_i8mm))\n-        rust_add_target_info(\"target_feature\", \"i8mm\");\n-    if (bitmap_bit_p(arm_active_target.isa, isa_bit_thumb2))\n-        rust_add_target_info(\"target_feature\", \"thumb2\");\n-    if (arm_arch4t)\n-        rust_add_target_info(\"target_feature\", \"v4t\");\n-    if (arm_arch5t)\n-        rust_add_target_info(\"target_feature\", \"v5t\");\n-    if (arm_arch5te)\n-        rust_add_target_info(\"target_feature\", \"v5te\");\n-    if (arm_arch6m)\n-        rust_add_target_info(\"target_feature\", \"v6m\");\n-    bool hasBaseline8MPreReqs = bitmap_bit_p(arm_active_target.isa, isa_bit_be8)\n-                                && arm_arch_thumb_hwdiv && arm_arch5t && arm_arch4 && arm_arch6\n-                                && arm_arch8 && bitmap_bit_p(arm_active_target.isa, isa_bit_armv5te)\n-                                && arm_arch_cmse && arm_arch_thumb1;\n-    if (hasBaseline8MPreReqs)\n-        rust_add_target_info(\"target_feature\", \"v8m\");\n-    if (hasBaseline8MPreReqs && arm_arch_thumb2 && arm_arch7)\n-        rust_add_target_info(\"target_feature\", \"v8m.main\");\n-    if (arm_arch8_1)\n-        rust_add_target_info(\"target_feature\", \"v8.1a\");\n-    if (arm_arch8_2)\n-        rust_add_target_info(\"target_feature\", \"v8.2a\");\n-    if (arm_arch8_3)\n-        rust_add_target_info(\"target_feature\", \"v8.3a\");\n-    if (arm_arch8_4)\n-        rust_add_target_info(\"target_feature\", \"v8.4a\");\n-    if (bitmap_bit_p(arm_active_target.isa, isa_bit_armv8_1m_main))\n-        rust_add_target_info(\"target_feature\", \"v8.1m.main\");\n-    if (bitmap_bit_p(arm_active_target.isa, isa_bit_mve)\n-        && bitmap_bit_p(arm_active_target.isa, isa_bit_vfp_base)\n-        && bitmap_bit_p(arm_active_target.isa, isa_bit_armv7em)) {\n-        rust_add_target_info(\"target_feature\", \"mve\");\n-\n-        if (bitmap_bit_p(arm_active_target.isa, isa_bit_fp16)\n-            && bitmap_bit_p(arm_active_target.isa, isa_bit_mve_float))\n-            rust_add_target_info(\"target_feature\", \"mve.fp\");\n-    }\n-    // Note: no direct option for \"cde\" found, but it is implicitly activated via cdecpx, so do it\n-    if (bitmap_bit_p(arm_active_target.isa, isa_bit_cdecp0)) {\n-        rust_add_target_info(\"target_feature\", \"cdecp0\");\n-        rust_add_target_info(\"target_feature\", \"cde\");\n-    }\n-    if (bitmap_bit_p(arm_active_target.isa, isa_bit_cdecp1)) {\n-        rust_add_target_info(\"target_feature\", \"cdecp1\");\n-        rust_add_target_info(\"target_feature\", \"cde\");\n-    }\n-    if (bitmap_bit_p(arm_active_target.isa, isa_bit_cdecp2)) {\n-        rust_add_target_info(\"target_feature\", \"cdecp2\");\n-        rust_add_target_info(\"target_feature\", \"cde\");\n-    }\n-    if (bitmap_bit_p(arm_active_target.isa, isa_bit_cdecp3)) {\n-        rust_add_target_info(\"target_feature\", \"cdecp3\");\n-        rust_add_target_info(\"target_feature\", \"cde\");\n-    }\n-    if (bitmap_bit_p(arm_active_target.isa, isa_bit_cdecp4)) {\n-        rust_add_target_info(\"target_feature\", \"cdecp4\");\n-        rust_add_target_info(\"target_feature\", \"cde\");\n-    }\n-    if (bitmap_bit_p(arm_active_target.isa, isa_bit_cdecp5)) {\n-        rust_add_target_info(\"target_feature\", \"cdecp5\");\n-        rust_add_target_info(\"target_feature\", \"cde\");\n-    }\n-    if (bitmap_bit_p(arm_active_target.isa, isa_bit_cdecp6)) {\n-        rust_add_target_info(\"target_feature\", \"cdecp6\");\n-        rust_add_target_info(\"target_feature\", \"cde\");\n-    }\n-    if (bitmap_bit_p(arm_active_target.isa, isa_bit_cdecp7)) {\n-        rust_add_target_info(\"target_feature\", \"cdecp7\");\n-        rust_add_target_info(\"target_feature\", \"cde\");\n-    }\n-    // TODO: consider doing the processors as target features, but honestly they don't seem to fit\n-\n-    /* TODO: further research support for CLREX (v7clrex), acquire-release (lda/ldaex), slow-fp-brcc\n-     * (slow FP compare and branch), perfmon, trustzone, fpao, fuse-aes, fuse-literals, read-tp-hard,\n-     * zcz, prof-unpr, slow-vgetlni32, slow-vdup32, prefer-vmovsr, prefer-ishst, muxed-units,\n-     * slow-odd-reg, slow-load-D-subreg, wide-stride-vfp, dont-widen-vmovs, splat-vfp-neon,\n-     * expand-fp-mlx, vmlx-hazards, neon-fpmovs, neonfp (as in using neon for scalar fp), vldn-align,\n-     * nonpipelined-vfp, slowfpvmlx, slowfpvfmx, vmlx-forwarding, 32bit (prefer 32-bit Thumb),\n-     * loop-align, mve1beat, mve2beat, mve4beat, avoid-partial-cpsr, cheap-predictable-cpsr,\n-     * avoid-movs-shop, ret-addr-stack, no-branch-predictor, virtualization, nacl-trap, execute-only,\n-     * reserve-r9, no-movt, no-neg-immediates, use-misched, disable-postra-scheduler, lob (Low\n-     * Overhead Branch), noarm - can't find them. */\n-    // note that apparently v7clrex and perfmon are prerequisites for v7 ops, so could maybe enable\n-    // them like that\n-}"}, {"sha": "31b0dd0f320e139eb416364292163fe929087b82", "filename": "gcc/config/c6x/c6x-rust.cc", "status": "removed", "additions": 0, "deletions": 55, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d1a6deb4e69e7dc162e741377674cf03459bcd9/gcc%2Fconfig%2Fc6x%2Fc6x-rust.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d1a6deb4e69e7dc162e741377674cf03459bcd9/gcc%2Fconfig%2Fc6x%2Fc6x-rust.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc6x%2Fc6x-rust.cc?ref=8d1a6deb4e69e7dc162e741377674cf03459bcd9", "patch": "@@ -1,55 +0,0 @@\n-/* Subroutines for the Rust front end on the TI C6X.\n-   Copyright (C) 2020-2022 Free Software Foundation, Inc.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"tm_p.h\"\n-#include \"rust/rust-target.h\"\n-#include \"rust/rust-target-def.h\"\n-\n-/* Implement TARGET_RUST_CPU_INFO for TI C6X targets.  */\n-\n-void c6x_rust_target_cpu_info(void) {\n-    rust_add_target_info(\"target_arch\", \"tic6x\");\n-\n-    // llvm seems to have no support for c6x (nor historical support), so names are made up by me\n-    // TODO maybe put in sub-arches as features? idk\n-    if (TARGET_DSBT)\n-        rust_add_target_info(\"target_feature\", \"dsbt\");\n-    \n-    if (TARGET_INSNS_64)\n-        rust_add_target_info(\"target_feature\", \"c64x\");\n-    if (TARGET_INSNS_64PLUS)\n-        rust_add_target_info(\"target_feature\", \"c64x+\");\n-    if (TARGET_INSNS_67)\n-        rust_add_target_info(\"target_feature\", \"c67x\");\n-    if (TARGET_INSNS_67PLUS)\n-        rust_add_target_info(\"target_feature\", \"c67x+\");\n-\n-    if (TARGET_LDDW)\n-        rust_add_target_info(\"target_feature\", \"lddw\");\n-    if (TARGET_STDW)\n-        rust_add_target_info(\"target_feature\", \"stdw\");\n-    if (TARGET_MPY32)\n-        rust_add_target_info(\"target_feature\", \"mpy32\");\n-    if (TARGET_FP)\n-        rust_add_target_info(\"target_feature\", \"fp\");\n-    if (TARGET_FP_EXT)\n-        rust_add_target_info(\"target_feature\", \"fp-ext\");\n-}"}, {"sha": "a999d05e50510ee3beeefc4f1d2be2e82ec2e202", "filename": "gcc/config/cr16/cr16-rust.cc", "status": "removed", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d1a6deb4e69e7dc162e741377674cf03459bcd9/gcc%2Fconfig%2Fcr16%2Fcr16-rust.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d1a6deb4e69e7dc162e741377674cf03459bcd9/gcc%2Fconfig%2Fcr16%2Fcr16-rust.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcr16%2Fcr16-rust.cc?ref=8d1a6deb4e69e7dc162e741377674cf03459bcd9", "patch": "@@ -1,53 +0,0 @@\n-/* Subroutines for the Rust front end on the CR16 architecture.\n-   Copyright (C) 2020-2022 Free Software Foundation, Inc.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"tm_p.h\"\n-#include \"rust/rust-target.h\"\n-#include \"rust/rust-target-def.h\"\n-\n-/* Implement TARGET_RUST_CPU_INFO for CR16 targets.  */\n-\n-void cr16_rust_target_cpu_info(void) {\n-    rust_add_target_info(\"target_arch\", \"cr16\");\n-\n-    // llvm seems to have no support for cr16 (nor historical support), so names are made up by me\n-    // TODO maybe put in sub-arches as features? idk\n-    if (TARGET_BIT_OPS)\n-        rust_add_target_info(\"target_feature\", \"bit-ops\");\n-    if (TARGET_MAC)\n-        rust_add_target_info(\"target_feature\", \"mac\");\n-    if (TARGET_DEBUG_ADDR)\n-        rust_add_target_info(\"target_feature\", \"debug-addr\");\n-    if (TARGET_INT32)\n-        rust_add_target_info(\"target_feature\", \"int32\");\n-\n-    if (CR16_TARGET_DATA_NEAR)             \n-        rust_add_target_info(\"target_feature\", \"data-model-near\");\n-    if (CR16_TARGET_DATA_MEDIUM)           \n-        rust_add_target_info(\"target_feature\", \"data-model-medium\");\n-    if (CR16_TARGET_DATA_FAR)              \n-        rust_add_target_info(\"target_feature\", \"data-model-far\");  \n-    \n-    if (TARGET_CR16C)\n-        rust_add_target_info(\"target_feature\", \"cr16c\");\n-    if (TARGET_CR16CP)\n-        rust_add_target_info(\"target_feature\", \"cr16cplus\");\n-}"}, {"sha": "07999073a8546e78895d0b42bc8b0058530216b2", "filename": "gcc/config/csky/csky-rust.cc", "status": "removed", "additions": 0, "deletions": 82, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d1a6deb4e69e7dc162e741377674cf03459bcd9/gcc%2Fconfig%2Fcsky%2Fcsky-rust.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d1a6deb4e69e7dc162e741377674cf03459bcd9/gcc%2Fconfig%2Fcsky%2Fcsky-rust.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcsky%2Fcsky-rust.cc?ref=8d1a6deb4e69e7dc162e741377674cf03459bcd9", "patch": "@@ -1,82 +0,0 @@\n-/* Subroutines for the Rust front end for C-SKY targets.\n-   Copyright (C) 2020-2022 Free Software Foundation, Inc.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"tm_p.h\"\n-#include \"rust/rust-target.h\"\n-#include \"rust/rust-target-def.h\"\n-\n-/* Implement TARGET_RUST_CPU_INFO for C-SKY targets.  */\n-\n-void cris_rust_target_cpu_info(void) {\n-    rust_add_target_info(\"target_arch\", \"csky\");\n-\n-    // llvm seems to have no support for sky (nor historical support), so names are made up by me\n-    // TODO maybe put in sub-arches as features? idk. might be useful in this case \n-    if (TARGET_HARD_FLOAT)\n-        rust_add_target_info(\"target_feature\", \"hard-float\");\n-    else\n-        rust_add_target_info(\"target_feature\", \"soft-float\");\n-    if (TARGET_DOUBLE_FLOAT)\n-        rust_add_target_info(\"target_feature\", \"double-float\");\n-    if (TARGET_FDIVDU)\n-        rust_add_target_info(\"target_feature\", \"fdivdu\");\n-    if (TARGET_ELRW)\n-        rust_add_target_info(\"target_feature\", \"elrw\");\n-    if (TARGET_ISTACK)\n-        rust_add_target_info(\"target_feature\", \"istack\");\n-    if (TARGET_MP)\n-        rust_add_target_info(\"target_feature\", \"mp\");\n-    if (TARGET_CP)\n-        rust_add_target_info(\"target_feature\", \"cp\");\n-    if (TARGET_CACHE)\n-        rust_add_target_info(\"target_feature\", \"cache\");\n-    if (TARGET_SECURITY)\n-        rust_add_target_info(\"target_feature\", \"security\"); // maybe also add define for \"mac\"?\n-    if (TARGET_TRUST)\n-        rust_add_target_info(\"target_feature\", \"trust\");\n-    if (TARGET_DSP)\n-        rust_add_target_info(\"target_feature\", \"dsp\");\n-    if (TARGET_EDSP)\n-        rust_add_target_info(\"target_feature\", \"edsp\");\n-    if (TARGET_VDSP)\n-        rust_add_target_info(\"target_feature\", \"vdsp\");\n-    if (TARGET_DIV)\n-        rust_add_target_info(\"target_feature\", \"div\");\n-    if (TARGET_MINI_REGISTERS)\n-        rust_add_target_info(\"target_feature\", \"smart\");\n-    if (TARGET_HIGH_REGISTERS)\n-        rust_add_target_info(\"target_feature\", \"high-registers\");\n-    if (TARGET_ANCHOR)\n-        rust_add_target_info(\"target_feature\", \"anchor\");\n-    if (TARGET_PUSHPOP)\n-        rust_add_target_info(\"target_feature\", \"pushpop\");\n-    if (TARGET_MULTIPLE_STLD)\n-        rust_add_target_info(\"target_feature\", \"multiple-stld\"); // maybe also add define for \"stm\"?\n-    if (TARGET_CONSTANT_POOL)\n-        rust_add_target_info(\"target_feature\", \"constpool\");\n-    if (TARGET_STACK_SIZE)\n-        rust_add_target_info(\"target_feature\", \"stack-size\");\n-    if (TARGET_LIBCCRT)\n-        rust_add_target_info(\"target_feature\", \"ccrt\");\n-    // maybe have branch cost as target feature? but kind of doesn't really fit as \"define\"\n-    if (flag_sched_prolog)\n-        rust_add_target_info(\"target_feature\", \"sched-prolog\");\n-}"}, {"sha": "a2754396e8ccbda92805f94e83950a18869eaac3", "filename": "gcc/config/default-rust.cc", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d1a6deb4e69e7dc162e741377674cf03459bcd9/gcc%2Fconfig%2Fdefault-rust.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d1a6deb4e69e7dc162e741377674cf03459bcd9/gcc%2Fconfig%2Fdefault-rust.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdefault-rust.cc?ref=8d1a6deb4e69e7dc162e741377674cf03459bcd9", "patch": "@@ -1,26 +0,0 @@\n-/* Default Rust language target hooks initializer.\n-   Copyright (C) 2020-2022 Free Software Foundation, Inc.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"memmodel.h\"\n-#include \"tm_rust.h\"\n-#include \"rust/rust-target.h\"\n-#include \"rust/rust-target-def.h\"\n-\n-struct gcc_targetrustm targetrustm = TARGETRUSTM_INITIALIZER;"}, {"sha": "254f14a8d74cd0f2beffcf1c3b4379274b7b0917", "filename": "gcc/config/epiphany/epiphany-rust.cc", "status": "removed", "additions": 0, "deletions": 81, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d1a6deb4e69e7dc162e741377674cf03459bcd9/gcc%2Fconfig%2Fepiphany%2Fepiphany-rust.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d1a6deb4e69e7dc162e741377674cf03459bcd9/gcc%2Fconfig%2Fepiphany%2Fepiphany-rust.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fepiphany%2Fepiphany-rust.cc?ref=8d1a6deb4e69e7dc162e741377674cf03459bcd9", "patch": "@@ -1,81 +0,0 @@\n-/* Subroutines for the Rust front end for the Adapteva Epiphany architecture.\n-   Copyright (C) 2020-2022 Free Software Foundation, Inc.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"tm_p.h\"\n-#include \"rust/rust-target.h\"\n-#include \"rust/rust-target-def.h\"\n-\n-/* Implement TARGET_RUST_CPU_INFO for Adapteva Epiphany targets.  */\n-\n-void epiphany_rust_target_cpu_info(void) {\n-    rust_add_target_info(\"target_arch\", \"epiphany\");\n-\n-    // llvm seems to have no support for sky (nor historical support), so names are made up by me\n-    // TODO: should the \"no\" dichotomy be preserved? probably not, but which should be chosen?\n-    if (TARGET_HALF_REG_FILE)\n-        rust_add_target_info(\"target_feature\", \"half-reg-file\");\n-    if (TARGET_PREFER_SHORT_INSN_REGS)\n-        rust_add_target_info(\"target_feature\", \"prefer-short-insn-regs\");\n-    // TODO: maybe have a \"branch-cost\" feature? doesn't really fit well with \"define-only\", though\n-    if (TARGET_CMOVE)\n-        rust_add_target_info(\"target_feature\", \"cmove\");\n-    // TODO: maybe have a \"nops\" feature? doesn't really fit well with \"define-only\", though\n-    if (TARGET_SOFT_CMPSF)\n-        rust_add_target_info(\"target_feature\", \"soft-cmpsf\");\n-    else\n-        rust_add_target_info(\"target_feature\", \"no-soft-cmpsf\");\n-    // TODO: maybe have a \"stack-offset\" feature? doesn't really fit well with \"define-only\", though\n-    if (TARGET_ROUND_NEAREST)\n-        rust_add_target_info(\"target_feature\", \"round-nearest\");\n-    else\n-        rust_add_target_info(\"target_feature\", \"no-round-nearest\");\n-    if (TARGET_LONG_CALLS)\n-        rust_add_target_info(\"target_feature\", \"long-calls\");\n-    if (TARGET_SHORT_CALLS)\n-        rust_add_target_info(\"target_feature\", \"short-calls\");\n-    if (TARGET_SMALL16)\n-        rust_add_target_info(\"target_feature\", \"small16\");\n-    // TODO: output mfp-mode somehow - \"define-only\" may work, but idk\n-    if (TARGET_SPLIT_LOHI)\n-        rust_add_target_info(\"target_feature\", \"split-lohi\");\n-    else\n-        rust_add_target_info(\"target_feature\", \"no-split-lohi\");\n-    if (TARGET_POST_INC)\n-        rust_add_target_info(\"target_feature\", \"postinc\");\n-    else\n-        rust_add_target_info(\"target_feature\", \"no-postinc\");\n-    if (TARGET_POST_MODIFY)\n-        rust_add_target_info(\"target_feature\", \"postmodify\");\n-    else\n-        rust_add_target_info(\"target_feature\", \"no-postmodify\");\n-    if (TARGET_VECT_DOUBLE)\n-        rust_add_target_info(\"target_feature\", \"vect-double\");\n-    else\n-        rust_add_target_info(\"target_feature\", \"no-vect-double\");\n-    // TODO: maybe have a \"max-vect-align\" feature? doesn't really fit well with \"define-only\", though\n-    if (TARGET_SPLIT_VECMOVE_EARLY)\n-        rust_add_target_info(\"target_feature\", \"split-vecmove-early\");\n-    // TODO: maybe a feature about having the -1 register (1reg)?\n-    if (TARGET_FP_IARITH)\n-        rust_add_target_info(\"target_feature\", \"fp-iarith\");\n-    if (TARGET_MAY_ROUND_FOR_TRUNC)\n-        rust_add_target_info(\"target_feature\", \"may-round-for-trunc\");\n-}"}, {"sha": "775481b86a3b90511475ee7e01ea093a93f76636", "filename": "gcc/config/frv/frv-rust.cc", "status": "removed", "additions": 0, "deletions": 111, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d1a6deb4e69e7dc162e741377674cf03459bcd9/gcc%2Fconfig%2Ffrv%2Ffrv-rust.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d1a6deb4e69e7dc162e741377674cf03459bcd9/gcc%2Fconfig%2Ffrv%2Ffrv-rust.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv-rust.cc?ref=8d1a6deb4e69e7dc162e741377674cf03459bcd9", "patch": "@@ -1,111 +0,0 @@\n-/* Subroutines for the Rust front end for the FRV architecture.\n-   Copyright (C) 2020-2022 Free Software Foundation, Inc.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"tm_p.h\"\n-#include \"rust/rust-target.h\"\n-#include \"rust/rust-target-def.h\"\n-\n-/* Implement TARGET_RUST_CPU_INFO for FRV targets.  */\n-\n-void frv_rust_target_cpu_info(void) {\n-    rust_add_target_info(\"target_arch\", \"frv\");\n-\n-    // llvm seems to have no support for sky (nor historical support), so names are made up by me\n-    // TODO maybe put in sub-arches as features? idk. might be useful in this case \n-    if (TARGET_ACC_4)\n-        rust_add_target_info(\"target_feature\", \"acc-4\");\n-    if (TARGET_ACC_8)\n-        rust_add_target_info(\"target_feature\", \"acc-8\");\n-    if (TARGET_ALIGN_LABELS)\n-        rust_add_target_info(\"target_feature\", \"align-labels\");\n-    if (TARGET_ALLOC_CC)\n-        rust_add_target_info(\"target_feature\", \"alloc-cc\");\n-    // TODO: maybe option on branch cost, but wouldn't work well as \"define only\" option\n-    if (TARGET_COND_EXEC)\n-        rust_add_target_info(\"target_feature\", \"cond-exec\");\n-    /* TODO: maybe option on cond-exec-insns, but wouldn't work well as \"define-only\" option. \n-     * also cond-exec-temps, sched-lookahead */\n-    if (TARGET_COND_MOVE)\n-        rust_add_target_info(\"target_feature\", \"cond-move\");\n-    if (TARGET_DEBUG)\n-        rust_add_target_info(\"target_feature\", \"debug\");\n-    if (TARGET_DEBUG_ARG)\n-        rust_add_target_info(\"target_feature\", \"debug-arg\");\n-    if (TARGET_DEBUG_ADDR)\n-        rust_add_target_info(\"target_feature\", \"debug-addr\");\n-    if (TARGET_DEBUG_COND_EXEC)\n-        rust_add_target_info(\"target_feature\", \"debug-cond-exec\");\n-    if (TARGET_DEBUG_LOC)\n-        rust_add_target_info(\"target_feature\", \"debug-loc\");\n-    if (TARGET_DEBUG_STACK)\n-        rust_add_target_info(\"target_feature\", \"debug-stack\");\n-    if (TARGET_DOUBLE)\n-        rust_add_target_info(\"target_feature\", \"double\");\n-    if (TARGET_DWORD)\n-        rust_add_target_info(\"target_feature\", \"dword\");\n-    if (TARGET_FDPIC)\n-        rust_add_target_info(\"target_feature\", \"fdpic\");\n-    if (TARGET_FIXED_CC)\n-        rust_add_target_info(\"target_feature\", \"fixed-cc\");\n-    if (TARGET_FPR_32)\n-        rust_add_target_info(\"target_feature\", \"fpr-32\");\n-    if (TARGET_FPR_64)\n-        rust_add_target_info(\"target_feature\", \"fpr-64\");\n-    if (TARGET_GPR_32)\n-        rust_add_target_info(\"target_feature\", \"gpr-32\");\n-    if (TARGET_GPR_64)\n-        rust_add_target_info(\"target_feature\", \"gpr-64\");\n-    if (TARGET_GPREL_RO)\n-        rust_add_target_info(\"target_feature\", \"gprel-ro\");\n-    if (TARGET_HARD_FLOAT)\n-        rust_add_target_info(\"target_feature\", \"hard-float\");\n-    else\n-        rust_add_target_info(\"target_feature\", \"soft-float\");\n-    if (TARGET_INLINE_PLT)\n-        rust_add_target_info(\"target_feature\", \"inline-plt\");\n-    if (TARGET_LIBPIC)\n-        rust_add_target_info(\"target_feature\", \"library-pic\");\n-    if (TARGET_LINKED_FP)\n-        rust_add_target_info(\"target_feature\", \"linked-fp\");\n-    if (TARGET_LONG_CALLS)\n-        rust_add_target_info(\"target_feature\", \"long-calls\");\n-    if (TARGET_MEDIA)\n-        rust_add_target_info(\"target_feature\", \"media\");\n-    if (TARGET_MULADD)\n-        rust_add_target_info(\"target_feature\", \"muladd\");\n-    if (TARGET_MULTI_CE)\n-        rust_add_target_info(\"target_feature\", \"multi-cond-exec\");\n-    if (TARGET_NESTED_CE)\n-        rust_add_target_info(\"target_feature\", \"nested-cond-exec\");\n-    // TODO: maybe something with no-eflags if possible? tomcat-stats? multilib-library-pic?\n-    if (TARGET_OPTIMIZE_MEMBAR)\n-        rust_add_target_info(\"target_feature\", \"optimize-membar\");\n-    if (TARGET_PACK)\n-        rust_add_target_info(\"target_feature\", \"pack\");\n-    if (TARGET_SCC)\n-        rust_add_target_info(\"target_feature\", \"scc\");\n-    if (TARGET_BIG_TLS)\n-        rust_add_target_info(\"target_feature\", \"large-tls\");\n-    else\n-        rust_add_target_info(\"target_feature\", \"small-tls\");\n-    if (TARGET_VLIW_BRANCH)\n-        rust_add_target_info(\"target_feature\", \"vliw-branch\");\n-}"}, {"sha": "1441a63f32cc0b5923a703c1a11dafc92672e474", "filename": "gcc/config/i386/i386-rust.cc", "status": "removed", "additions": 0, "deletions": 501, "changes": 501, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d1a6deb4e69e7dc162e741377674cf03459bcd9/gcc%2Fconfig%2Fi386%2Fi386-rust.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d1a6deb4e69e7dc162e741377674cf03459bcd9/gcc%2Fconfig%2Fi386%2Fi386-rust.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-rust.cc?ref=8d1a6deb4e69e7dc162e741377674cf03459bcd9", "patch": "@@ -1,501 +0,0 @@\n-/* Subroutines for the Rust front end on the x86 architecture.\n-   Copyright (C) 2020-2022 Free Software Foundation, Inc.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"tm_p.h\"\n-#include \"rust/rust-target.h\"\n-#include \"rust/rust-target-def.h\"\n-\n-/* Implement TARGET_RUST_CPU_INFO for x86 targets.  */\n-\n-void\n-ix86_rust_target_cpu_info (void)\n-{\n-    if (TARGET_64BIT) {\n-        rust_add_target_info(\"target_arch\", \"x86_64\");\n-\n-        if (TARGET_X32) {\n-            // this means it uses 32-bit pointers with 64-bit, basically (ILP32)\n-            //rust_add_target_info(\"target_pointer_width\", \"32\");\n-            // TODO: may also change x86_64-...-linux-gnu to x86_64-...-linux-gnux32\n-\n-            // is this better than just putting in pointer width outside of if statement?\n-\n-            /* TODO: compared to base linux, may also need to change max_atomic_width to 64, add \"-mx32\"\n-             * to pre-link args, make stack_probes true, make has_elf_tls false, make needs_plt true.\n-             * Also, still target_endian is \"little\", target_c_int_width is \"32\", maybe steal data layout\n-             * later from rustc spec, target_os is \"linux\", target_env is \"gnu\", target_vendor is \"unknown\"\n-             * There is no rustc support for non-gnu/linux targets with ILP32. */\n-        }\n-    } else {\n-        rust_add_target_info(\"target_arch\", \"x86\");\n-    }\n-\n-  // features officially \"stabilised\" in rustc\n-  if (TARGET_MMX)\n-    rust_add_target_info(\"target_feature\", \"mmx\");\n-  if (TARGET_SSE)\n-    rust_add_target_info(\"target_feature\", \"sse\");\n-  if (TARGET_SSE2)\n-    rust_add_target_info(\"target_feature\", \"sse2\");\n-  if (TARGET_SSE3)\n-    rust_add_target_info(\"target_feature\", \"sse3\");\n-  if (TARGET_SSSE3)\n-    rust_add_target_info(\"target_feature\", \"ssse3\");\n-  if (TARGET_SSE4_1)\n-    rust_add_target_info(\"target_feature\", \"sse4.1\");\n-  if (TARGET_SSE4_2)\n-    rust_add_target_info(\"target_feature\", \"sse4.2\");\n-  if (TARGET_AES)\n-    rust_add_target_info(\"target_feature\", \"aes\");\n-  if (TARGET_SHA)\n-    rust_add_target_info(\"target_feature\", \"sha\");\n-  if (TARGET_AVX)\n-    rust_add_target_info(\"target_feature\", \"avx\");\n-  if (TARGET_AVX2)\n-    rust_add_target_info(\"target_feature\", \"avx2\");\n-  if (TARGET_AVX512F)\n-    rust_add_target_info(\"target_feature\", \"avx512f\");\n-  if (TARGET_AVX512ER)\n-    rust_add_target_info(\"target_feature\", \"avx512er\");\n-  if (TARGET_AVX512CD)\n-    rust_add_target_info(\"target_feature\", \"avx512cd\");\n-  if (TARGET_AVX512PF)\n-    rust_add_target_info(\"target_feature\", \"avx512pf\");\n-  if (TARGET_AVX512DQ)\n-    rust_add_target_info(\"target_feature\", \"avx512dq\");\n-  if (TARGET_AVX512BW)\n-    rust_add_target_info(\"target_feature\", \"avx512bw\");\n-  if (TARGET_AVX512VL)\n-    rust_add_target_info(\"target_feature\", \"avx512vl\");\n-  if (TARGET_AVX512VBMI)\n-    rust_add_target_info(\"target_feature\", \"avx512vbmi\");\n-  if (TARGET_AVX512IFMA)\n-    rust_add_target_info(\"target_feature\", \"avx512ifma\");\n-  if (TARGET_AVX512VPOPCNTDQ)\n-    rust_add_target_info(\"target_feature\", \"avx512vpopcntdq\");\n-  if (TARGET_FMA)\n-    rust_add_target_info(\"target_feature\", \"fma\");\n-  if (TARGET_RTM)\n-    rust_add_target_info(\"target_feature\", \"rtm\");\n-  if (TARGET_SSE4A)\n-    rust_add_target_info(\"target_feature\", \"sse4a\");\n-  if (TARGET_BMI) {\n-    rust_add_target_info(\"target_feature\", \"bmi1\");\n-    rust_add_target_info(\"target_feature\", \"bmi\");\n-  }\n-  if (TARGET_BMI2)\n-    rust_add_target_info(\"target_feature\", \"bmi2\");\n-  if (TARGET_LZCNT)\n-    rust_add_target_info(\"target_feature\", \"lzcnt\");\n-  if (TARGET_TBM)\n-    rust_add_target_info(\"target_feature\", \"tbm\");\n-  if (TARGET_POPCNT)\n-    rust_add_target_info(\"target_feature\", \"popcnt\");\n-  if (TARGET_RDRND) {\n-    rust_add_target_info(\"target_feature\", \"rdrand\");\n-    rust_add_target_info(\"target_feature\", \"rdrnd\");\n-  }\n-  if (TARGET_F16C)\n-    rust_add_target_info(\"target_feature\", \"f16c\");\n-  if (TARGET_RDSEED)\n-    rust_add_target_info(\"target_feature\", \"rdseed\");\n-  if (TARGET_ADX)\n-    rust_add_target_info(\"target_feature\", \"adx\");\n-  if (TARGET_FXSR)\n-    rust_add_target_info(\"target_feature\", \"fxsr\");\n-  if (TARGET_XSAVE)\n-    rust_add_target_info(\"target_feature\", \"xsave\");\n-  if (TARGET_XSAVEOPT)\n-    rust_add_target_info(\"target_feature\", \"xsaveopt\");\n-  if (TARGET_XSAVEC)\n-    rust_add_target_info(\"target_feature\", \"xsavec\");\n-  if (TARGET_XSAVES)\n-    rust_add_target_info(\"target_feature\", \"xsaves\");\n-  if (TARGET_VPCLMULQDQ) {\n-    rust_add_target_info(\"target_feature\", \"pclmulqdq\");\n-    rust_add_target_info(\"target_feature\", \"vpclmulqdq\");\n-  }\n-  if (TARGET_CMPXCHG16B)\n-    rust_add_target_info(\"target_feature\", \"cmpxchg16b\");\n-  if (TARGET_MOVBE)\n-    rust_add_target_info(\"target_feature\", \"movbe\");\n-\n-  // features derived from llvm not yet in rustc:\n-  if (TARGET_64BIT)\n-    rust_add_target_info(\"target_feature\", \"64bit-mode\");\n-  else if (TARGET_CODE16)\n-    rust_add_target_info(\"target_feature\", \"16bit-mode\");\n-  else\n-    rust_add_target_info(\"target_feature\", \"32bit-mode\");\n-  \n-  // TODO: assuming that the TARGET_80387 (which seems to mean \"hard float\") is also required for x87\n-  if (TARGET_80387 && (ix86_fpmath & FPMATH_387) != 0)\n-    rust_add_target_info(\"target_feature\", \"x87\");\n-\n-  // nopl: hard-coded (as gcc doesn't technically have feature) to return true for cpu arches with it\n-  // maybe refactor into switch if multiple options\n-  bool hasNOPL = ix86_arch == PROCESSOR_PENTIUMPRO || ix86_arch == PROCESSOR_PENTIUM4 \n-    || ix86_arch == PROCESSOR_NOCONA || ix86_arch == PROCESSOR_CORE2 || ix86_arch == PROCESSOR_NEHALEM \n-    || ix86_arch == PROCESSOR_BONNELL || ix86_arch == PROCESSOR_SILVERMONT \n-    || ix86_arch == PROCESSOR_GOLDMONT || ix86_arch == PROCESSOR_GOLDMONT_PLUS \n-    || ix86_arch == PROCESSOR_TREMONT || ix86_arch == PROCESSOR_SANDYBRIDGE \n-    || ix86_arch == PROCESSOR_HASWELL || ix86_arch == PROCESSOR_SKYLAKE \n-    || ix86_arch == PROCESSOR_SKYLAKE_AVX512 || ix86_arch == PROCESSOR_CANNONLAKE \n-    || ix86_arch == PROCESSOR_CASCADELAKE  || ix86_arch == PROCESSOR_COOPERLAKE \n-    || ix86_arch == PROCESSOR_ICELAKE_CLIENT || ix86_arch == PROCESSOR_ICELAKE_SERVER \n-    || ix86_arch == PROCESSOR_TIGERLAKE || ix86_arch == PROCESSOR_KNL || ix86_arch == PROCESSOR_KNM \n-    || ix86_arch == PROCESSOR_AMDFAM10 || ix86_arch == PROCESSOR_BTVER1 || ix86_arch == PROCESSOR_BTVER2 \n-    || ix86_arch == PROCESSOR_BDVER1 || ix86_arch == PROCESSOR_BDVER2 || ix86_arch == PROCESSOR_BDVER3 \n-    || ix86_arch == PROCESSOR_BDVER4 || ix86_arch == PROCESSOR_ZNVER1 || ix86_arch == PROCESSOR_ZNVER2 \n-    || ix86_arch == PROCESSOR_ATHLON || ix86_arch == PROCESSOR_K8; \n-  // this list should be exhaustive\n-  if (hasNOPL)\n-    rust_add_target_info(\"target_feature\", \"nopl\");\n-  if (TARGET_CMOVE)\n-    rust_add_target_info(\"target_feature\", \"cmov\");\n-  if (TARGET_CMPXCHG8B)\n-    rust_add_target_info(\"target_feature\", \"cx8\");\n-  if (TARGET_3DNOW)\n-    rust_add_target_info(\"target_feature\", \"3dnow\");\n-  if (TARGET_3DNOW_A)\n-    rust_add_target_info(\"target_feature\", \"3dnowa\");\n-  if (TARGET_64BIT)\n-    rust_add_target_info(\"target_feature\", \"64bit\");\n-  if (TARGET_CMPXCHG16B)\n-    rust_add_target_info(\"target_feature\", \"cx16\");\n-\n-  bool hasSlowSHLD = ix86_arch == PROCESSOR_AMDFAM10 || ix86_arch == PROCESSOR_BTVER1 \n-    || ix86_arch == PROCESSOR_BTVER2 || ix86_arch == PROCESSOR_BDVER1 || ix86_arch == PROCESSOR_BDVER2 \n-    || ix86_arch == PROCESSOR_BDVER3 || ix86_arch == PROCESSOR_BDVER4 || ix86_arch == PROCESSOR_ZNVER1 \n-    || ix86_arch == PROCESSOR_ZNVER2 || ix86_arch == PROCESSOR_ATHLON || ix86_arch == PROCESSOR_K8; \n-  // TODO: this is not ideal as it marks the baseline x86-64 CPU as having it - only AMD ones do\n-  if (hasSlowSHLD)\n-    rust_add_target_info(\"target_feature\", \"slow-shld\");\n-  if (ix86_arch == PROCESSOR_SILVERMONT)\n-    rust_add_target_info(\"target_feature\", \"slow-pmulld\");\n-  if (ix86_arch == PROCESSOR_KNL || ix86_arch == PROCESSOR_KNM)\n-    rust_add_target_info(\"target_feature\", \"slow-pmaddwd\");\n-\n-  bool hasSlowUnaligned16 = ix86_arch == PROCESSOR_BONNELL || ix86_arch == PROCESSOR_GENERIC \n-    || ix86_arch == PROCESSOR_I386 || ix86_arch == PROCESSOR_I486 || ix86_arch == PROCESSOR_PENTIUM \n-    || ix86_arch == PROCESSOR_PENTIUMPRO || ix86_arch == PROCESSOR_PENTIUM4 \n-    || ix86_arch == PROCESSOR_NOCONA || ix86_arch == PROCESSOR_CORE2 || ix86_arch == PROCESSOR_K6 \n-    || ix86_arch == PROCESSOR_ATHLON || ix86_arch == PROCESSOR_K8 || ix86_arch == PROCESSOR_GEODE;\n-  if (hasSlowUnaligned16)\n-    rust_add_target_info(\"target_feature\", \"slow-unaligned-mem-16\");\n-  if (ix86_arch == PROCESSOR_SANDYBRIDGE)\n-    rust_add_target_info(\"target_feature\", \"slow-unaligned-mem-32\");\n-  if (TARGET_PREFETCHWT1)\n-    rust_add_target_info(\"target_feature\", \"prefetchwt1\");\n-  if (TARGET_AVX512VBMI2)\n-    rust_add_target_info(\"target_feature\", \"avx512vbmi2\");\n-  if (TARGET_PKU)\n-    rust_add_target_info(\"target_feature\", \"pku\");\n-  if (TARGET_AVX512VNNI)\n-    rust_add_target_info(\"target_feature\", \"avx512vnni\");\n-  if (TARGET_AVX512BF16)\n-    rust_add_target_info(\"target_feature\", \"avx512bf16\");\n-  if (TARGET_AVX512BITALG)\n-    rust_add_target_info(\"target_feature\", \"avx512bitalg\");\n-  if (TARGET_AVX512VP2INTERSECT)\n-    rust_add_target_info(\"target_feature\", \"avx512vp2intersect\");\n-  if (TARGET_PCLMUL)\n-    rust_add_target_info(\"target_feature\", \"pclmul\");\n-  if (TARGET_GFNI)\n-    rust_add_target_info(\"target_feature\", \"gfni\");\n-  if (TARGET_FMA4)\n-    rust_add_target_info(\"target_feature\", \"fma4\");\n-  if (TARGET_XOP)\n-    rust_add_target_info(\"target_feature\", \"xop\");\n-\n-  // this is only enabled by choice in llvm, never by default - TODO determine if gcc enables it\n-  // rust_add_target_info(\"target_feature\", \"sse-unaligned-mem\");\n-\n-  if (TARGET_VAES)\n-    rust_add_target_info(\"target_feature\", \"vaes\");\n-  if (TARGET_LWP)\n-    rust_add_target_info(\"target_feature\", \"lwp\");\n-  if (TARGET_FSGSBASE)\n-    rust_add_target_info(\"target_feature\", \"fsgsbase\");\n-  if (TARGET_SHSTK)\n-    rust_add_target_info(\"target_feature\", \"shstk\");\n-  if (TARGET_PRFCHW)\n-    rust_add_target_info(\"target_feature\", \"prfchw\");\n-  if (TARGET_SAHF) // would this be better as TARGET_USE_SAHF?\n-    rust_add_target_info(\"target_feature\", \"sahf\");\n-  if (TARGET_MWAITX)\n-    rust_add_target_info(\"target_feature\", \"mwaitx\");\n-  if (TARGET_CLZERO)\n-    rust_add_target_info(\"target_feature\", \"clzero\");\n-  if (TARGET_CLDEMOTE)\n-    rust_add_target_info(\"target_feature\", \"cldemote\");\n-  if (TARGET_PTWRITE)\n-    rust_add_target_info(\"target_feature\", \"ptwrite\");\n-  // TODO: add amx-tile, amx-int8, amx-bf16 features when gcc supports them \n-\n-  // TODO: can't find any gcc option relating to using LEA for adjusting stack pointer, so hardcoding\n-  if (ix86_arch == PROCESSOR_BONNELL)\n-    rust_add_target_info(\"target_feature\", \"lea-sp\");\n-\n-  // TODO: confirm that this is what it actually refers to\n-  if (TARGET_USE_8BIT_IDIV)\n-    rust_add_target_info(\"target_feature\", \"idivl-to-divb\");\n-\n-  /* TODO: can't find any gcc option corresponding to idivq-to-divl - does gcc perform this optimisation?\n-   * if so, add that feature (use 32-bit divide for positive values less than 2^32) */\n-  /* bool llvmHasSlowDivide64 = ix86_arch == PROCESSOR_SANDYBRIDGE || ix86_arch == PROCESSOR_HASWELL \n-    || ix86_arch == PROCESSOR_SKYLAKE || ix86_arch == PROCESSOR_SKYLAKE_AVX512 \n-    || ix86_arch == PROCESSOR_CANNONLAKE || ix86_arch == PROCESSOR_ICELAKE_CLIENT \n-    || ix86_arch == PROCESSOR_ICELAKE_SERVER || ix86_arch == PROCESSOR_CASCADELAKE \n-    || ix86_arch == PROCESSOR_TIGERLAKE || ix86_arch == PROCESSOR_COOPERLAKE \n-    || ix86_arch == PROCESSOR_BONNELL || ix86_arch == PROCESSOR_SILVERMONT || ix86_arch == PROCESSOR_KNL \n-    || ix86_arch == PROCESSOR_KNM || ix86_arch == PROCESSOR_K8;*/\n-\n-  if (TARGET_PAD_SHORT_FUNCTION)\n-    rust_add_target_info(\"target_feature\", \"pad-short-functions\");\n-\n-  // TODO: gcc seems to not record whether INVPCID exists, so basing it on llvm\n-  bool hasINVPCID = ix86_arch == PROCESSOR_HASWELL || ix86_arch == PROCESSOR_SKYLAKE \n-    || ix86_arch == PROCESSOR_SKYLAKE_AVX512 || ix86_arch == PROCESSOR_CANNONLAKE \n-    || ix86_arch == PROCESSOR_ICELAKE_CLIENT || ix86_arch == PROCESSOR_ICELAKE_SERVER \n-    || ix86_arch == PROCESSOR_CASCADELAKE || ix86_arch == PROCESSOR_TIGERLAKE \n-    || ix86_arch == PROCESSOR_COOPERLAKE; \n-  if (hasINVPCID)\n-    rust_add_target_info(\"target_feature\", \"invpcid\");\n-  if (TARGET_SGX)\n-    rust_add_target_info(\"target_feature\", \"sgx\");\n-  if (TARGET_CLFLUSHOPT)\n-    rust_add_target_info(\"target_feature\", \"clflushopt\");\n-  if (TARGET_CLWB)\n-    rust_add_target_info(\"target_feature\", \"clwb\");\n-  if (TARGET_WBNOINVD)\n-    rust_add_target_info(\"target_feature\", \"wbnoinvd\");\n-  if (TARGET_RDPID)\n-    rust_add_target_info(\"target_feature\", \"rdpid\");\n-  if (TARGET_WAITPKG)\n-    rust_add_target_info(\"target_feature\", \"waitpkg\");\n-  if (TARGET_ENQCMD)\n-    rust_add_target_info(\"target_feature\", \"enqcmd\");\n-\n-  // these are only enabled by choice in llvm, never by default - TODO determine if gcc supports them\n-  // rust_add_target_info(\"target_feature\", \"serialize\");\n-  // rust_add_target_info(\"target_feature\", \"tsxldtrk\");\n-\n-  // TODO: gcc seems to not record whether to avoid memory operanded instructions, so basing it on llvm\n-  bool hasSlowTwoMemOps = ix86_arch == PROCESSOR_BONNELL || ix86_arch == PROCESSOR_SILVERMONT \n-    || ix86_arch == PROCESSOR_GOLDMONT || ix86_arch == PROCESSOR_GOLDMONT_PLUS \n-    || ix86_arch == PROCESSOR_TREMONT || ix86_arch == PROCESSOR_KNL || ix86_arch == PROCESSOR_KNM; \n-  if (hasSlowTwoMemOps)\n-    rust_add_target_info(\"target_feature\", \"slow-two-mem-ops\");\n-\n-  // TODO: gcc seems to not record whether LEA needs input at AG stage, so basing it on llvm\n-  // TODO: maybe something to do with X86_TUNE_OPT_AGU?\n-  if (ix86_arch == PROCESSOR_BONNELL)\n-    rust_add_target_info(\"target_feature\", \"lea-uses-ag\");\n-\n-  // TODO: gcc seems to not record whether LEA with certain arguments is slow, so basing it on llvm\n-  // TODO: maybe TARGET_AVOID_LEA_FOR_ADDR has something to do with it?\n-  bool hasSlowLEA = ix86_arch == PROCESSOR_SILVERMONT || ix86_arch == PROCESSOR_GOLDMONT \n-    || ix86_arch == PROCESSOR_GOLDMONT_PLUS || ix86_arch == PROCESSOR_TREMONT;\n-  if (hasSlowLEA)\n-    rust_add_target_info(\"target_feature\", \"slow-lea\");\n-  \n-  // TODO: gcc seems to not record whether LEA with 3 ops or certain regs is slow, so basing it on llvm\n-  // TODO: maybe TARGET_AVOID_LEA_FOR_ADDR has something to do with it?\n-  bool hasSlow3OpsLEA = ix86_arch == PROCESSOR_SANDYBRIDGE || ix86_arch == PROCESSOR_HASWELL \n-    || ix86_arch == PROCESSOR_SKYLAKE || ix86_arch == PROCESSOR_SKYLAKE_AVX512 \n-    || ix86_arch == PROCESSOR_CANNONLAKE || ix86_arch == PROCESSOR_ICELAKE_CLIENT \n-    || ix86_arch == PROCESSOR_ICELAKE_SERVER || ix86_arch == PROCESSOR_CASCADELAKE \n-    || ix86_arch == PROCESSOR_TIGERLAKE || ix86_arch == PROCESSOR_COOPERLAKE \n-    || ix86_arch == PROCESSOR_KNL || ix86_arch == PROCESSOR_KNM || ix86_arch == PROCESSOR_K8; \n-  if (hasSlow3OpsLEA)\n-    rust_add_target_info(\"target_feature\", \"slow-3ops-lea\");\n-\n-  // TODO: assuming that this is equivalent option - it strictly doesn't cover same cpus\n-  if (!TARGET_USE_INCDEC)\n-    rust_add_target_info(\"target_feature\", \"slow-incdec\");\n-  // TODO: assuming that this mask actually refers to \"hard float\" and not x87 specifically\n-  if (!TARGET_80387)\n-    rust_add_target_info(\"target_feature\", \"soft-float\");\n-\n-  // TODO: gcc seems to not record if LZCNT/TZCNT has false deps on dest register, so basing it on llvm\n-  if (ix86_arch == PROCESSOR_HASWELL)\n-    rust_add_target_info(\"target_feature\", \"false-deps-lzcnt-tzcnt\");\n-\n-  if (TARGET_PCONFIG)\n-    rust_add_target_info(\"target_feature\", \"pconfig\");\n-\n-  // TODO: gcc seems to not record if variable-mask shuffles are fast, so basing it on llvm\n-  bool hasFastVariableShuffle = ix86_arch == PROCESSOR_HASWELL || ix86_arch == PROCESSOR_SKYLAKE \n-    || ix86_arch == PROCESSOR_SKYLAKE_AVX512 || ix86_arch == PROCESSOR_CANNONLAKE \n-    || ix86_arch == PROCESSOR_ICELAKE_CLIENT || ix86_arch == PROCESSOR_ICELAKE_SERVER \n-    || ix86_arch == PROCESSOR_CASCADELAKE || ix86_arch == PROCESSOR_TIGERLAKE \n-    || ix86_arch == PROCESSOR_COOPERLAKE; \n-  if (hasFastVariableShuffle)\n-    rust_add_target_info(\"target_feature\", \"fast-variable-shuffle\");\n-\n-  // TODO: ensure that this actually refers to the right thing - difference in gcc and llvm description\n-  if (TARGET_VZEROUPPER)\n-    rust_add_target_info(\"target_feature\", \"vzeroupper\");\n-\n-  // option based on llvm arch analysis as gcc tuning costs seem to indicate a different result\n-  bool hasFastScalarFSQRT = ix86_arch == PROCESSOR_SANDYBRIDGE || ix86_arch == PROCESSOR_HASWELL \n-    || ix86_arch == PROCESSOR_SKYLAKE || ix86_arch == PROCESSOR_SKYLAKE_AVX512 \n-    || ix86_arch == PROCESSOR_CANNONLAKE || ix86_arch == PROCESSOR_ICELAKE_CLIENT \n-    || ix86_arch == PROCESSOR_ICELAKE_SERVER || ix86_arch == PROCESSOR_CASCADELAKE \n-    || ix86_arch == PROCESSOR_TIGERLAKE || ix86_arch == PROCESSOR_COOPERLAKE;\n-  if (hasFastScalarFSQRT)\n-    rust_add_target_info(\"target_feature\", \"fast-scalar-fsqrt\");\n-\n-  // option also based on llvm arch analysis \n-  bool hasFastVectorFSQRT = ix86_arch == PROCESSOR_SKYLAKE || ix86_arch == PROCESSOR_SKYLAKE_AVX512 \n-    || ix86_arch == PROCESSOR_CANNONLAKE || ix86_arch == PROCESSOR_ICELAKE_CLIENT \n-    || ix86_arch == PROCESSOR_ICELAKE_SERVER || ix86_arch == PROCESSOR_CASCADELAKE \n-    || ix86_arch == PROCESSOR_TIGERLAKE || ix86_arch == PROCESSOR_COOPERLAKE;\n-  if (hasFastVectorFSQRT)\n-    rust_add_target_info(\"target_feature\", \"fast-vector-fsqrt\");\n-\n-  bool hasFastLZCNT = ix86_arch == PROCESSOR_BTVER2 || ix86_arch == PROCESSOR_ZNVER1 \n-    || ix86_arch == PROCESSOR_ZNVER2;\n-  if (hasFastLZCNT)\n-    rust_add_target_info(\"target_feature\", \"fast-lzcnt\");\n-\n-  if (ix86_arch == PROCESSOR_SILVERMONT)\n-    rust_add_target_info(\"target_feature\", \"fast-7bytenop\");\n-\n-  bool hasFast11ByteNOP = ix86_arch == PROCESSOR_BDVER1 || ix86_arch == PROCESSOR_BDVER2 \n-    || ix86_arch == PROCESSOR_BDVER3 || ix86_arch == PROCESSOR_BDVER4;\n-  if (hasFast11ByteNOP)\n-    rust_add_target_info(\"target_feature\", \"fast-11bytenop\");\n-\n-  bool hasFast15ByteNOP = ix86_arch == PROCESSOR_SANDYBRIDGE || ix86_arch == PROCESSOR_HASWELL \n-    || ix86_arch == PROCESSOR_SKYLAKE || ix86_arch == PROCESSOR_SKYLAKE_AVX512 \n-    || ix86_arch == PROCESSOR_CANNONLAKE || ix86_arch == PROCESSOR_ICELAKE_CLIENT \n-    || ix86_arch == PROCESSOR_ICELAKE_SERVER || ix86_arch == PROCESSOR_CASCADELAKE \n-    || ix86_arch == PROCESSOR_TIGERLAKE || ix86_arch == PROCESSOR_COOPERLAKE \n-    || ix86_arch == PROCESSOR_BTVER1 || ix86_arch == PROCESSOR_BTVER2\n-    || ix86_arch == PROCESSOR_ZNVER1 || ix86_arch == PROCESSOR_ZNVER2;\n-  if (hasFast15ByteNOP)\n-    rust_add_target_info(\"target_feature\", \"fast-15bytenop\");\n-\n-  bool hasFastSHLDRotate = ix86_arch == PROCESSOR_SANDYBRIDGE || ix86_arch == PROCESSOR_HASWELL \n-    || ix86_arch == PROCESSOR_SKYLAKE || ix86_arch == PROCESSOR_SKYLAKE_AVX512 \n-    || ix86_arch == PROCESSOR_CANNONLAKE || ix86_arch == PROCESSOR_ICELAKE_CLIENT \n-    || ix86_arch == PROCESSOR_ICELAKE_SERVER || ix86_arch == PROCESSOR_CASCADELAKE \n-    || ix86_arch == PROCESSOR_TIGERLAKE || ix86_arch == PROCESSOR_COOPERLAKE;\n-  if (hasFastSHLDRotate)\n-    rust_add_target_info(\"target_feature\", \"fast-shld-rotate\");\n-\n-  bool hasERMSB = ix86_arch == PROCESSOR_HASWELL || ix86_arch == PROCESSOR_SKYLAKE \n-    || ix86_arch == PROCESSOR_SKYLAKE_AVX512 || ix86_arch == PROCESSOR_CANNONLAKE \n-    || ix86_arch == PROCESSOR_ICELAKE_CLIENT || ix86_arch == PROCESSOR_ICELAKE_SERVER \n-    || ix86_arch == PROCESSOR_CASCADELAKE || ix86_arch == PROCESSOR_TIGERLAKE \n-    || ix86_arch == PROCESSOR_COOPERLAKE; \n-  if (hasERMSB)\n-    rust_add_target_info(\"target_feature\", \"ermsbd\");\n-\n-  // TODO: may exist in gcc as tune macros, but not sure, so based on llvm arches\n-  bool hasBranchFusion = ix86_arch == PROCESSOR_BDVER1 || ix86_arch == PROCESSOR_BDVER2 \n-    || ix86_arch == PROCESSOR_BDVER3 || ix86_arch == PROCESSOR_BDVER4 || ix86_arch == PROCESSOR_ZNVER1 \n-    || ix86_arch == PROCESSOR_ZNVER2;\n-  if (hasBranchFusion)\n-    rust_add_target_info(\"target_feature\", \"branchfusion\");\n-\n-  // TODO: again, may exist as tune macros, but again based on llvm arches\n-  bool hasMacroFusion = ix86_arch == PROCESSOR_CORE2 || ix86_arch == PROCESSOR_NEHALEM \n-    || ix86_arch == PROCESSOR_SANDYBRIDGE || ix86_arch == PROCESSOR_HASWELL \n-    || ix86_arch == PROCESSOR_SKYLAKE || ix86_arch == PROCESSOR_SKYLAKE_AVX512 \n-    || ix86_arch == PROCESSOR_CANNONLAKE || ix86_arch == PROCESSOR_ICELAKE_CLIENT \n-    || ix86_arch == PROCESSOR_ICELAKE_SERVER || ix86_arch == PROCESSOR_CASCADELAKE \n-    || ix86_arch == PROCESSOR_TIGERLAKE || ix86_arch == PROCESSOR_COOPERLAKE || ix86_arch == PROCESSOR_K8;\n-  if (hasMacroFusion)\n-    rust_add_target_info(\"target_feature\", \"macrofusion\");\n-\n-  // TODO: is this equivalent to TARGET_USE_GATHER?\n-  bool hasFastGather = ix86_arch == PROCESSOR_SKYLAKE || ix86_arch == PROCESSOR_SKYLAKE_AVX512 \n-    || ix86_arch == PROCESSOR_CASCADELAKE || ix86_arch == PROCESSOR_COOPERLAKE \n-    || ix86_arch == PROCESSOR_CANNONLAKE || ix86_arch == PROCESSOR_ICELAKE_CLIENT \n-    || ix86_arch == PROCESSOR_ICELAKE_SERVER || ix86_arch == PROCESSOR_TIGERLAKE \n-    || ix86_arch == PROCESSOR_KNL || ix86_arch == PROCESSOR_KNM;\n-  if (hasFastGather)\n-    rust_add_target_info(\"target_feature\", \"fast-gather\");\n-\n-  if (TARGET_PREFER_AVX128)\n-    rust_add_target_info(\"target_feature\", \"prefer-128-bit\");\n-  if (TARGET_PREFER_AVX256)\n-    rust_add_target_info(\"target_feature\", \"prefer-256-bit\");\n-\n-  bool preferMaskRegisters = ix86_arch == PROCESSOR_KNL || ix86_arch == PROCESSOR_KNM;\n-  if (preferMaskRegisters)\n-    rust_add_target_info(\"target_feature\", \"prefer-mask-registers\");\n-\n-  /* TODO: add retpoline-indirect-calls, retpoline-indirect-branches, retpoline, retpoline-external-thunk, \n-   * lvi-cfi (LVI control flow integrity), seses (speculative execution side-effect suppression)\n-   * lvi-load-hardening if gcc gets support */\n-\n-  if (TARGET_MOVDIRI)\n-    rust_add_target_info(\"target_feature\", \"movdiri\");\n-  if (TARGET_MOVDIR64B)\n-    rust_add_target_info(\"target_feature\", \"movdir64b\");\n-\n-  bool hasFastBEXTR = ix86_arch == PROCESSOR_BTVER2 || ix86_arch == PROCESSOR_BDVER2 \n-    || ix86_arch == PROCESSOR_BDVER3 || ix86_arch == PROCESSOR_BDVER4 || ix86_arch == PROCESSOR_ZNVER1 \n-    || ix86_arch == PROCESSOR_ZNVER2;\n-  if (hasFastBEXTR)\n-    rust_add_target_info(\"target_feature\", \"fast-bextr\");\n-\n-  if (ix86_arch == PROCESSOR_BTVER2)\n-    rust_add_target_info(\"target_feature\", \"fast-hops\");\n-\n-  bool hasFastScalarShiftMasks = ix86_arch == PROCESSOR_AMDFAM10 || ix86_arch == PROCESSOR_BTVER1 \n-    || ix86_arch == PROCESSOR_BTVER2 || ix86_arch == PROCESSOR_BDVER1 || ix86_arch == PROCESSOR_BDVER2 \n-    || ix86_arch == PROCESSOR_BDVER3 || ix86_arch == PROCESSOR_BDVER4 || ix86_arch == PROCESSOR_ZNVER1 \n-    || ix86_arch == PROCESSOR_ZNVER2 || ix86_arch == PROCESSOR_K8;\n-  if (hasFastScalarShiftMasks)\n-    rust_add_target_info(\"target_feature\", \"fast-scalar-shift-masks\");\n-\n-  bool hasFastVectorShiftMasks = ix86_arch == PROCESSOR_BTVER1 || ix86_arch == PROCESSOR_BTVER2;\n-  if (hasFastVectorShiftMasks)\n-    rust_add_target_info(\"target_feature\", \"fast-vector-shift-masks\");\n-\n-  bool useGoldmontDivSqrtCosts = ix86_arch == PROCESSOR_GOLDMONT || ix86_arch == PROCESSOR_GOLDMONT_PLUS \n-    || ix86_arch == PROCESSOR_TREMONT;\n-  if (useGoldmontDivSqrtCosts)\n-    rust_add_target_info(\"target_feature\", \"use-glm-div-sqrt-costs\");\n-  \n-  // TODO: determine if gcc supports alias analysis (in which case \"use-aa\" is defined)\n-\n-  // features not supported by llvm but important enough for c frontend to define macros for\n-  /*if (TARGET_AVX5124VNNIW)\n-    rust_add_target_info(\"target_feature\", \"avx5124vnniw\");\n-  if (TARGET_AVX5124FMAPS)\n-    rust_add_target_info(\"target_feature\", \"avx5124fmaps\");\n-  if (TARGET_ABM)\n-    rust_add_target_info(\"target_feature\", \"abm\");\n-  if ((ix86_fpmath & FPMATH_SSE) && TARGET_SSE)\n-    ; //def_or_undef (parse_in, \"__SSE_MATH__\");\n-  if ((ix86_fpmath & FPMATH_SSE) && TARGET_SSE2)\n-    ; //def_or_undef (parse_in, \"__SSE2_MATH__\");\n-  if (TARGET_MMX_WITH_SSE)\n-    ; //def_or_undef (parse_in, \"__MMX_WITH_SSE__\");\n-  if (TARGET_IAMCU)\n-    rust_add_target_info(\"target_feature\", \"iamcu\");*/\n-}"}, {"sha": "b1ee77aabc4faf150e17e2c0c467952e20c55ad5", "filename": "gcc/config/ia64/ia64-rust.cc", "status": "removed", "additions": 0, "deletions": 125, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d1a6deb4e69e7dc162e741377674cf03459bcd9/gcc%2Fconfig%2Fia64%2Fia64-rust.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d1a6deb4e69e7dc162e741377674cf03459bcd9/gcc%2Fconfig%2Fia64%2Fia64-rust.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64-rust.cc?ref=8d1a6deb4e69e7dc162e741377674cf03459bcd9", "patch": "@@ -1,125 +0,0 @@\n-/* Subroutines for the Rust front end for the IA-64 architecture.\n-   Copyright (C) 2020-2022 Free Software Foundation, Inc.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"tm_p.h\"\n-#include \"rust/rust-target.h\"\n-#include \"rust/rust-target-def.h\"\n-\n-/* Implement TARGET_RUST_CPU_INFO for IA-64 targets.  */\n-\n-void ia64_rust_target_cpu_info(void) {\n-    rust_add_target_info(\"target_arch\", \"ia64\");\n-\n-    // llvm does not appear to have defined features at any point for IA-64, so I made up names\n-    // TODO: should sub-arches be defined here?\n-    if (TARGET_GNU_AS)\n-        rust_add_target_info(\"target_feature\", \"gnu-as\");\n-    if (TARGET_GNU_LD)\n-        rust_add_target_info(\"target_feature\", \"gnu-ld\");\n-    if (TARGET_VOL_ASM_STOP)\n-        rust_add_target_info(\"target_feature\", \"volatile-asm-stop\");\n-    if (TARGET_REG_NAMES)\n-        rust_add_target_info(\"target_feature\", \"register-names\");\n-    if (TARGET_NO_SDATA)\n-        rust_add_target_info(\"target_feature\", \"no-sdata\");\n-    else\n-        rust_add_target_info(\"target_feature\", \"sdata\");\n-    if (TARGET_NO_PIC)\n-        rust_add_target_info(\"target_feature\", \"no-pic\");\n-    if (TARGET_CONST_GP)\n-        rust_add_target_info(\"target_feature\", \"constant-gp\");\n-    if (TARGET_AUTO_PIC)\n-        rust_add_target_info(\"target_feature\", \"auto-pic\");\n-    \n-    switch (TARGET_INLINE_FLOAT_DIV) {\n-        case 0:\n-            rust_add_target_info(\"target_feature\", \"no-inline-float-divide\");\n-            break;\n-        case 1:\n-            rust_add_target_info(\"target_feature\", \"inline-float-divide-min-latency\");\n-            break;\n-        case 2:\n-            rust_add_target_info(\"target_feature\", \"inline-float-divide-max-throughput\");\n-            break;\n-        default: // TODO: is this an error? should this be an error?\n-            break;\n-    }\n-    switch (TARGET_INLINE_INT_DIV) {\n-        case 0:\n-            rust_add_target_info(\"target_feature\", \"no-inline-int-divide\");\n-            break;\n-        case 1:\n-            rust_add_target_info(\"target_feature\", \"inline-int-divide-min-latency\");\n-            break;\n-        case 2:\n-            rust_add_target_info(\"target_feature\", \"inline-int-divide-max-throughput\");\n-            break;\n-        default: // TODO: is this an error? should this be an error?\n-            break;\n-    }\n-    switch (TARGET_INLINE_SQRT) {\n-        case 0:\n-            rust_add_target_info(\"target_feature\", \"no-inline-sqrt\");\n-            break;\n-        case 1:\n-            rust_add_target_info(\"target_feature\", \"inline-sqrt-min-latency\");\n-            break;\n-        case 2:\n-            rust_add_target_info(\"target_feature\", \"inline-sqrt-max-throughput\");\n-            break;\n-        default: // TODO: is this an error? should this be an error?\n-            break;\n-    }\n-\n-    if (TARGET_DWARF2_ASM)\n-        rust_add_target_info(\"target_feature\", \"dwarf2-asm\");\n-    if (TARGET_EARLY_STOP_BITS)\n-        rust_add_target_info(\"target_feature\", \"early-stop-bits\");\n-    // TODO: do fixed-range somehow (wouldn't work well as define, I don't think), same for tls-size\n-\n-    if (mflag_sched_br_data_spec)\n-        rust_add_target_info(\"target_feature\", \"sched-br-data-spec\");\n-    if (mflag_sched_ar_data_spec)\n-        rust_add_target_info(\"target_feature\", \"sched-ar-data-spec\");\n-    if (mflag_sched_control_spec)\n-        rust_add_target_info(\"target_feature\", \"sched-control-spec\");\n-    if (mflag_sched_br_in_data_spec)\n-        rust_add_target_info(\"target_feature\", \"sched-br-in-data-spec\");\n-    if (mflag_sched_ar_in_data_spec)\n-        rust_add_target_info(\"target_feature\", \"sched-ar-in-data-spec\");\n-    if (mflag_sched_in_control_spec)\n-        rust_add_target_info(\"target_feature\", \"sched-in-control-spec\");\n-    if (mflag_sched_spec_ldc)\n-        rust_add_target_info(\"target_feature\", \"sched-spec-ldc\");\n-    if (mflag_sched_spec_control_ldc)\n-        rust_add_target_info(\"target_feature\", \"sched-spec-control-ldc\");\n-    if (mflag_sched_count_spec_in_critical_path)\n-        rust_add_target_info(\"target_feature\", \"sched-count-spec-in-critical-path\");\n-    if (mflag_sched_stop_bits_after_every_cycle)\n-        rust_add_target_info(\"target_feature\", \"sched-stop-bits-after-every-cycle\");\n-    if (mflag_sched_fp_mem_deps_zero_cost)\n-        rust_add_target_info(\"target_feature\", \"sched-fp-mem-deps-zero-cost\");\n-    if (mflag_sched_mem_insns_hard_limit)\n-        rust_add_target_info(\"target_feature\", \"sched-max-memory-insns-hard-limit\");\n-    if (mflag_sel_sched_dont_check_control_spec)\n-        rust_add_target_info(\"target_feature\", \"sel-sched-dont-check-control-spec\");\n-    // TODO: do sched-max-memory-insns somehow (wouldn't work well as define)\n-}"}, {"sha": "bad94e4657df0d497b587d2ab252825f0be43b84", "filename": "gcc/config/m68k/m68k-rust.cc", "status": "removed", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d1a6deb4e69e7dc162e741377674cf03459bcd9/gcc%2Fconfig%2Fm68k%2Fm68k-rust.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d1a6deb4e69e7dc162e741377674cf03459bcd9/gcc%2Fconfig%2Fm68k%2Fm68k-rust.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k-rust.cc?ref=8d1a6deb4e69e7dc162e741377674cf03459bcd9", "patch": "@@ -1,63 +0,0 @@\n-/* Subroutines for the Rust front end for the Motorola 680x0/ColdFire architecture.\n-   Copyright (C) 2020-2022 Free Software Foundation, Inc.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"tm_p.h\"\n-#include \"rust/rust-target.h\"\n-#include \"rust/rust-target-def.h\"\n-\n-/* Implement TARGET_RUST_CPU_INFO for Motorola 680x0/ColdFire targets.  */\n-\n-void m68k_rust_target_cpu_info(void) {\n-    rust_add_target_info(\"target_arch\", \"m68k\");\n-\n-    /* llvm has no current or historical support for m68k, and llvm forks and mrustc don't suggest any \n-     * true target feature names, so I made up names and features */\n-    // TODO: maybe define subarches as features? probably needed, but not sure how well it interacts\n-    if (TARGET_ALIGN_INT)\n-        rust_add_target_info(\"target_feature\", \"align-int\");\n-    if (TARGET_BITFIELD)\n-        rust_add_target_info(\"target_feature\", \"bitfield\");\n-    if (TARGET_CF_HWDIV)\n-        rust_add_target_info(\"target_feature\", \"div\");\n-    if (TARGET_HARD_FLOAT)\n-        rust_add_target_info(\"target_feature\", \"hard-float\");\n-    else\n-        rust_add_target_info(\"target_feature\", \"soft-float\");\n-    if (TARGET_ID_SHARED_LIBRARY)\n-        rust_add_target_info(\"target_feature\", \"id-shared-library\");\n-    if (TARGET_LONG_JUMP_TABLE_OFFSETS)\n-        rust_add_target_info(\"target_feature\", \"long-jump-table-offsets\");\n-    if (TARGET_RTD)\n-        rust_add_target_info(\"target_feature\", \"rtd\");\n-    if (TARGET_SHORT)\n-        rust_add_target_info(\"target_feature\", \"short\");\n-    if (TARGET_PCREL)\n-        rust_add_target_info(\"target_feature\", \"pcrel\");\n-    if (TARGET_SEP_DATA)\n-        rust_add_target_info(\"target_feature\", \"sep-data\");\n-    // TODO: see if can get information about shared-library-id\n-    if (TARGET_STRICT_ALIGNMENT)\n-        rust_add_target_info(\"target_feature\", \"strict-align\");\n-    if (TARGET_XGOT)\n-        rust_add_target_info(\"target_feature\", \"xgot\");   \n-    if (TARGET_XTLS)\n-        rust_add_target_info(\"target_feature\", \"xtls\");\n-}"}, {"sha": "31b9c222de445e93ee31ebfe87345f54b80056e2", "filename": "gcc/config/mips/mips-rust.cc", "status": "removed", "additions": 0, "deletions": 297, "changes": 297, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d1a6deb4e69e7dc162e741377674cf03459bcd9/gcc%2Fconfig%2Fmips%2Fmips-rust.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d1a6deb4e69e7dc162e741377674cf03459bcd9/gcc%2Fconfig%2Fmips%2Fmips-rust.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-rust.cc?ref=8d1a6deb4e69e7dc162e741377674cf03459bcd9", "patch": "@@ -1,297 +0,0 @@\n-/* Subroutines for the Rust front end for the MIPS architecture.\n-   Copyright (C) 2020-2022 Free Software Foundation, Inc.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"tm_p.h\"\n-#include \"rust/rust-target.h\"\n-#include \"rust/rust-target-def.h\"\n-\n-/* Add target info for MIPS-I ISA support.  */\n-\n-static void mips1_target_info(void) {\n-    rust_add_target_info(\"target_feature\", \"mips1\");\n-}\n-\n-/* Add target info for MIPS-II ISA support.  */\n-\n-static void mips2_target_info(void) {\n-    rust_add_target_info(\"target_feature\", \"mips2\");\n-    mips1_target_info();\n-}\n-\n-/* Add target info for MIPS-III ISA (MIPS32 subset) support.  */\n-\n-static void mips3_32_target_info(void) {\n-    rust_add_target_info(\"target_feature\", \"mips3_32\");\n-}\n-\n-/* Add target info for MIPS-III ISA (MIPS32r2 subset) support.  */\n-\n-static void mips3_32r2_target_info(void) {\n-    rust_add_target_info(\"target_feature\", \"mips3_32r2\");\n-}\n-\n-/* Add target info for MIPS-III ISA support.  */\n-\n-static void mips3_target_info(void) {\n-    rust_add_target_info(\"target_feature\", \"mips3\");\n-    mips2_target_info();\n-    mips3_32_target_info();\n-    mips3_32r2_target_info();\n-    // maybe always have FeatureGP64Bit and FeatureFP64Bit? or maybe make them prereqs?\n-}\n-\n-/* Add target info for MIPS-IV ISA (MIPS32 subset) support.  */\n-\n-static void mips4_32_target_info(void) {\n-    rust_add_target_info(\"target_feature\", \"mips4_32\");\n-}\n-\n-/* Add target info for MIPS-IV ISA (MIPS32r2 subset) support.  */\n-\n-static void mips4_32r2_target_info(void) {\n-    rust_add_target_info(\"target_feature\", \"mips4_32r2\");\n-}\n-\n-/* Add target info for MIPS-IV ISA support.  */\n-\n-static void mips4_target_info(void) {\n-    rust_add_target_info(\"target_feature\", \"mips4\");\n-    mips3_target_info();\n-    mips4_32_target_info();\n-    mips4_32r2_target_info();\n-}\n-\n-/* Add target info for MIPS-V ISA (MIPS32r2 subset) support.  */\n-\n-static void mips5_32r2_target_info(void) {\n-    rust_add_target_info(\"target_feature\", \"mips5_32r2\");\n-}\n-\n-/* Add target info for MIPS-V ISA support.  */\n-\n-static void mips5_target_info(void) {\n-    rust_add_target_info(\"target_feature\", \"mips5\");\n-    mips4_target_info();\n-    mips5_32r2_target_info();\n-}\n-\n-/* Add target info for MIPS32 ISA support.  */\n-\n-static void mips32_target_info(void) {\n-    rust_add_target_info(\"target_feature\", \"mips32\");\n-    mips2_target_info();\n-    mips3_32_target_info();\n-    mips4_32_target_info();\n-}\n-\n-/* Add target info for MIPS32r2 ISA support.  */\n-\n-static void mips32r2_target_info(void) {\n-    rust_add_target_info(\"target_feature\", \"mips32r2\");\n-    mips32_target_info();\n-    mips3_32r2_target_info();\n-    mips4_32r2_target_info();\n-    mips5_32r2_target_info();\n-}\n-\n-/* Add target info for MIPS32r3 ISA support.  */\n-\n-static void mips32r3_target_info(void) {\n-    rust_add_target_info(\"target_feature\", \"mips32r3\");\n-    mips32r2_target_info();\n-}\n-\n-/* Add target info for MIPS32r5 ISA support.  */\n-\n-static void mips32r5_target_info(void) {\n-    rust_add_target_info(\"target_feature\", \"mips32r5\");\n-    mips32r3_target_info();\n-}\n-\n-/* Add target info for MIPS32r6 ISA support.  */\n-\n-static void mips32r6_target_info(void) {\n-    rust_add_target_info(\"target_feature\", \"mips32r6\");\n-    mips32r5_target_info();\n-    // maybe also hardcode having FeatureFP64Bit, FeatureNaN2008, and FeatureAbs2008, or have prereqs\n-}\n-\n-/* Add target info for MIPS64 ISA support.  */\n-\n-static void mips64_target_info(void) {\n-    rust_add_target_info(\"target_feature\", \"mips64\");\n-    mips32_target_info();\n-    mips5_target_info();\n-}\n-\n-/* Add target info for MIPS64r2 ISA support.  */\n-\n-static void mips64r2_target_info(void) {\n-    rust_add_target_info(\"target_feature\", \"mips64r2\");\n-    mips64_target_info();\n-    mips32r2_target_info();\n-}\n-\n-/* Add target info for MIPS64r3 ISA support.  */\n-\n-static void mips64r3_target_info(void) {\n-    rust_add_target_info(\"target_feature\", \"mips64r3\");\n-    mips64r2_target_info();\n-    mips32r3_target_info();\n-}\n-\n-/* Add target info for MIPS64r5 ISA support.  */\n-\n-static void mips64r5_target_info(void) {\n-    rust_add_target_info(\"target_feature\", \"mips64r5\");\n-    mips64r3_target_info();\n-    mips32r5_target_info();\n-}\n-\n-/* Add target info for MIPS64r6 ISA support.  */\n-\n-static void mips64r6_target_info(void) {\n-    rust_add_target_info(\"target_feature\", \"mips64r6\");\n-    mips64r5_target_info();\n-    mips32r6_target_info();\n-    // maybe hardcode FeatureNaN2008 and FeatureAbs2008, or just have them as prereqs?\n-}\n-\n-/* Implement TARGET_RUST_CPU_INFO for MIPS targets.  */\n-\n-void mips_rust_target_cpu_info(void) {\n-    if (TARGET_64BIT)\n-        rust_add_target_info(\"target_arch\", \"mips64\");\n-    else\n-        rust_add_target_info(\"target_arch\", \"mips\");\n-\n-    // features and names based on llvm if not in rustc\n-    // TODO maybe implement more features that aren't in llvm but are in gcc at some point?\n-    if (!(TARGET_ABICALLS))\n-        rust_add_target_info(\"target_feature\", \"noabicalls\");\n-    if (POINTER_SIZE == 64)\n-        rust_add_target_info(\"target_feature\", \"ptr64\");\n-    if (TARGET_64BIT) \n-        rust_add_target_info(\"target_feature\", \"gp64\");\n-    if (TARGET_FLOAT64)\n-        rust_add_target_info(\"target_feature\", \"fp64\");\n-    if (TARGET_FLOATXX)\n-        rust_add_target_info(\"target_feature\", \"fpxx\");\n-    // TODO: ensure below variables work\n-    if (mips_nan == MIPS_IEEE_754_2008)\n-        rust_add_target_info(\"target_feature\", \"nan2008\");\n-    if (mips_abs == MIPS_IEEE_754_2008)\n-        rust_add_target_info(\"target_feature\", \"abs2008\");\n-    if (TARGET_SINGLE_FLOAT)\n-        rust_add_target_info(\"target_feature\", \"single-float\");\n-    if (TARGET_SOFT_FLOAT_ABI)\n-        rust_add_target_info(\"target_feature\", \"soft-float\");\n-    if (!TARGET_ODD_SPREG)\n-        rust_add_target_info(\"target_feature\", \"nooddspreg\");\n-    // TODO: find if vfpu (vector FPU instructions) are supported by gcc at all\n-    // TODO: ensure below switch variable and whatever works\n-    switch (mips_isa_option) {\n-        case 0: \n-            mips1_target_info();\n-            break;\n-        case 1: \n-            mips2_target_info();\n-            break;\n-        case 2: \n-            mips3_target_info();\n-            break;\n-        case 3: \n-            mips4_target_info();\n-            break;\n-        case 4: \n-            mips32_target_info();\n-            break;\n-        case 5: \n-            mips32r2_target_info();\n-            break;\n-        case 6: \n-            mips32r3_target_info();\n-            break;\n-        case 7: \n-            mips32r5_target_info();\n-            break;\n-        case 8: \n-            mips32r6_target_info();\n-            break;\n-        case 9: \n-            mips64_target_info();\n-            break;\n-        case 10: \n-            mips64r2_target_info();\n-            break;\n-        case 11: \n-            mips64r3_target_info();\n-            break;\n-        case 12: \n-            mips64r5_target_info();\n-            break;\n-        case 13: \n-            mips64r6_target_info();\n-            break;\n-        default: // unknown isa level - should this be an error?\n-            break;\n-    }\n-    if (TARGET_SYM32)\n-        rust_add_target_info(\"target_feature\", \"sym32\");\n-    if (TARGET_MIPS16)\n-        rust_add_target_info(\"target_feature\", \"mips16\");\n-    if (TARGET_DSP) {\n-        rust_add_target_info(\"target_feature\", \"dsp\");\n-\n-        if (TARGET_DSPR2) {\n-            rust_add_target_info(\"target_feature\", \"dspr2\");\n-\n-            // TODO: add dspr3 if can find gcc equivalent option \n-        }\n-    }\n-    if (TARGET_MIPS3D)\n-        rust_add_target_info(\"target_feature\", \"mips3d\");\n-    if (TARGET_MSA)\n-        rust_add_target_info(\"target_feature\", \"msa\");\n-    if (TARGET_EVA)\n-        rust_add_target_info(\"target_feature\", \"eva\");\n-    if (TARGET_CRC)\n-        rust_add_target_info(\"target_feature\", \"crc\");\n-    if (TARGET_VIRT)\n-        rust_add_target_info(\"target_feature\", \"virt\");\n-    if (TARGET_GINV)\n-        rust_add_target_info(\"target_feature\", \"ginv\");\n-    if (TARGET_MICROMIPS)\n-        rust_add_target_info(\"target_feature\", \"micromips\");\n-    // TODO: add cnmips and cnmipsp if there are gcc equivalent features\n-    // TODO: find out what use-tcc-in-div (\"force the assembler to use trapping\") corresponds to\n-    // TODO ensure below variable works\n-    if (!mips_madd4)\n-        rust_add_target_info(\"target_feature\", \"nomadd4\");   \n-    if (TARGET_MT)\n-        rust_add_target_info(\"target_feature\", \"mt\");\n-    if (TARGET_LONG_CALLS)\n-        rust_add_target_info(\"target_feature\", \"long-calls\");   \n-    if (TARGET_XGOT)\n-        rust_add_target_info(\"target_feature\", \"xgot\");\n-    /* TODO: find out what use-indirect-jump-hazard corresponds with (\"use indirect jump guards to prevent\n-     * certain speculation based attacks\") */\n-}"}, {"sha": "e866674f7ad65c520be8efc415b3ccf1ba07333a", "filename": "gcc/config/nds32/nds32-rust.cc", "status": "removed", "additions": 0, "deletions": 194, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d1a6deb4e69e7dc162e741377674cf03459bcd9/gcc%2Fconfig%2Fnds32%2Fnds32-rust.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d1a6deb4e69e7dc162e741377674cf03459bcd9/gcc%2Fconfig%2Fnds32%2Fnds32-rust.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-rust.cc?ref=8d1a6deb4e69e7dc162e741377674cf03459bcd9", "patch": "@@ -1,194 +0,0 @@\n-/* Subroutines for the Rust front end for the NDS32 architecture.\n-   Copyright (C) 2020-2022 Free Software Foundation, Inc.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"tm_p.h\"\n-#include \"rust/rust-target.h\"\n-#include \"rust/rust-target-def.h\"\n-\n-/* Implement TARGET_RUST_CPU_INFO for NDS32 targets.  */\n-\n-void nds32_rust_target_cpu_info(void) {\n-    rust_add_target_info(\"target_arch\", \"nds32\");\n-\n-    // made up names as no apparent support (current or historical) in llvm\n-    // TODO: maybe have cpu types as features? might be a lot, though\n-    if (TARGET_REDUCED_REGS)\n-        rust_add_target_info(\"target_feature\", \"reduced-regs\");\n-    if (TARGET_ALWAYS_ALIGN)\n-        rust_add_target_info(\"target_feature\", \"always-align\");\n-    if (TARGET_ALIGN_FUNCTION)\n-        rust_add_target_info(\"target_feature\", \"align-functions\");\n-    if (TARGET_FORCE_FP_AS_GP)\n-        rust_add_target_info(\"target_feature\", \"force-fp-as-gp\");\n-    if (TARGET_FORBID_FP_AS_GP)\n-        rust_add_target_info(\"target_feature\", \"forbid-fp-as-gp\");\n-    // TODO: ensure below variables work\n-    if (nds32_ict_model == ICT_MODEL_SMALL)\n-        rust_add_target_info(\"target_feature\", \"ict-model-small\");\n-    else if (nds32_ict_model == ICT_MODEL_LARGE)\n-        rust_add_target_info(\"target_feature\", \"ict-model-large\");\n-    if (TARGET_CMOV)\n-        rust_add_target_info(\"target_feature\", \"cmov\");\n-    if (TARGET_HW_ABS)\n-        rust_add_target_info(\"target_feature\", \"hw-abs\");\n-    if (TARGET_EXT_PERF)\n-        rust_add_target_info(\"target_feature\", \"ext-perf\");\n-    if (TARGET_EXT_PERF2)\n-        rust_add_target_info(\"target_feature\", \"ext-perf2\");\n-    if (TARGET_EXT_STRING)\n-        rust_add_target_info(\"target_feature\", \"ext-string\");\n-    if (TARGET_EXT_DSP)\n-        rust_add_target_info(\"target_feature\", \"ext-dsp\");\n-    if (TARGET_V3PUSH)\n-        rust_add_target_info(\"target_feature\", \"v3push\");\n-    if (TARGET_16_BIT)\n-        rust_add_target_info(\"target_feature\", \"16-bit\");\n-    if (TARGET_RELAX_HINT)\n-        rust_add_target_info(\"target_feature\", \"relax-hint\");\n-    if (TARGET_VH)\n-        rust_add_target_info(\"target_feature\", \"vh\");\n-    if (TARGET_ISR_VECTOR_SIZE_4_BYTE)\n-        rust_add_target_info(\"target_feature\", \"isr-vector-size-4\");\n-    else\n-        rust_add_target_info(\"target_feature\", \"isr-vector-size-16\");\n-    // TODO: figure out how to handle nds32_isr_secure_level (isr-secure)\n-    // TODO: ensure below switch variable and whatever works\n-    switch (nds32_cache_block_size) {\n-        // note: supposedly only powers of 2 between 4 and 512\n-        case 4:\n-            rust_add_target_info(\"target_feature\", \"cache-block-size-4\");\n-            break;\n-        case 8:\n-            rust_add_target_info(\"target_feature\", \"cache-block-size-8\");\n-            break;\n-        case 16:\n-            rust_add_target_info(\"target_feature\", \"cache-block-size-16\");\n-            break;\n-        case 32:\n-            rust_add_target_info(\"target_feature\", \"cache-block-size-32\");\n-            break;\n-        case 64:\n-            rust_add_target_info(\"target_feature\", \"cache-block-size-64\");\n-            break;\n-        case 128:\n-            rust_add_target_info(\"target_feature\", \"cache-block-size-128\");\n-            break;\n-        case 256:\n-            rust_add_target_info(\"target_feature\", \"cache-block-size-256\");\n-            break;\n-        case 512:\n-            rust_add_target_info(\"target_feature\", \"cache-block-size-512\");\n-            break;\n-        default: // unknown cache block size - should this be an error?\n-            break;\n-    }\n-    // TODO: ensure below switch and variable works - should this be cumulative or exclusive like now?\n-    switch (nds32_arch_option) {\n-        case ARCH_V2:\n-            rust_add_target_info(\"target_feature\", \"v2\");\n-            break;\n-        case ARCH_V3:\n-            rust_add_target_info(\"target_feature\", \"v3\");\n-            break;\n-        case ARCH_V3J:\n-            rust_add_target_info(\"target_feature\", \"v3j\");\n-            break;\n-        case ARCH_V3M:\n-            rust_add_target_info(\"target_feature\", \"v3m\");\n-            break;\n-        case ARCH_V3F:\n-            rust_add_target_info(\"target_feature\", \"v3f\");\n-            break;\n-        case ARCH_V3S:\n-            rust_add_target_info(\"target_feature\", \"v3s\");\n-            break;\n-        default: // unknown arch (isa level) - should this be an error?\n-            break;\n-    }\n-    // TODO: stuff below is taken from cpp defines - may be better to define 4-7 separately?\n-    if (TARGET_FPU_SINGLE || TARGET_FPU_DOUBLE) {\n-        switch (nds32_fp_regnum) {\n-            case 0:\n-            case 4:\n-                rust_add_target_info(\"target_feature\", \"config-fpu-0\");\n-                break;\n-            case 1:\n-            case 5:\n-                rust_add_target_info(\"target_feature\", \"config-fpu-1\");\n-                break;\n-            case 2:\n-            case 6:\n-                rust_add_target_info(\"target_feature\", \"config-fpu-2\");\n-                break;\n-            case 3:\n-            case 7:\n-                rust_add_target_info(\"target_feature\", \"config-fpu-3\");\n-                break;\n-            default:\n-                gcc_unreachable();\n-        }\n-    }\n-    // TODO: ensure below switch and variable works\n-    switch (nds32_mul_config) {\n-        case MUL_TYPE_FAST_1:\n-            rust_add_target_info(\"target_feature\", \"config-mul-fast1\");\n-            break;\n-        case MUL_TYPE_FAST_2:\n-            rust_add_target_info(\"target_feature\", \"config-mul-fast2\");\n-            break;\n-        case MUL_TYPE_SLOW:\n-            rust_add_target_info(\"target_feature\", \"config-mul-slow\");\n-            break;\n-        default: // unknown arch (isa level) - should this be an error?\n-            break;\n-    }\n-    // TODO: ensure below switch and variable works\n-    switch (nds32_register_ports_config) {\n-        case REG_PORT_3R2W:\n-            rust_add_target_info(\"target_feature\", \"config-register-ports-3r2w\");\n-            break;\n-        case REG_PORT_2R1W:\n-            rust_add_target_info(\"target_feature\", \"config-register-ports-2r1w\");\n-            break;\n-        default: // unknown arch (isa level) - should this be an error?\n-            break;\n-    }\n-    // TODO: add ctor-dtor and relax if can figure out how to get data from it\n-    if (TARGET_EXT_FPU_FMA)\n-        rust_add_target_info(\"target_feature\", \"ext-fpu-fma\");\n-    if (TARGET_FPU_SINGLE)\n-        rust_add_target_info(\"target_feature\", \"ext-fpu-sp\");\n-    if (TARGET_FPU_DOUBLE)\n-        rust_add_target_info(\"target_feature\", \"ext-fpu-dp\");\n-    if (TARGET_FORCE_NO_EXT_DSP)\n-        rust_add_target_info(\"target_feature\", \"force-no-ext-dsp\");\n-    // TODO: ensure below variables work\n-    if (flag_sched_prolog_epilog)\n-        rust_add_target_info(\"target_feature\", \"sched-prolog-epilog\");\n-    if (flag_ret_in_naked_func)\n-        rust_add_target_info(\"target_feature\", \"ret-in-naked-func\");\n-    if (flag_always_save_lp)\n-        rust_add_target_info(\"target_feature\", \"always-save-lp\");\n-    if (flag_unaligned_access)\n-        rust_add_target_info(\"target_feature\", \"unaligned-access\");\n-    if (flag_inline_asm_r15)\n-        rust_add_target_info(\"target_feature\", \"inline-asm-r15\");\n-}"}, {"sha": "c00194ca08bc8fbe9c65c3deca4bb457dde41faa", "filename": "gcc/config/nios2/nios2-rust.cc", "status": "removed", "additions": 0, "deletions": 90, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d1a6deb4e69e7dc162e741377674cf03459bcd9/gcc%2Fconfig%2Fnios2%2Fnios2-rust.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d1a6deb4e69e7dc162e741377674cf03459bcd9/gcc%2Fconfig%2Fnios2%2Fnios2-rust.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnios2%2Fnios2-rust.cc?ref=8d1a6deb4e69e7dc162e741377674cf03459bcd9", "patch": "@@ -1,90 +0,0 @@\n-/* Subroutines for the Rust front end for the Altera Nios II architecture.\n-   Copyright (C) 2020-2022 Free Software Foundation, Inc.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"tm_p.h\"\n-#include \"rust/rust-target.h\"\n-#include \"rust/rust-target-def.h\"\n-\n-/* Implement TARGET_RUST_CPU_INFO for Altera Nios II targets.  */\n-\n-void nios2_rust_target_cpu_info(void) {\n-    rust_add_target_info(\"target_arch\", \"nios2\");\n-\n-    // made up (most) names as only apparently basic historical support in llvm\n-    if (TARGET_HAS_DIV)\n-        rust_add_target_info(\"target_feature\", \"hw-div\");\n-    if (TARGET_HAS_MUL)\n-        rust_add_target_info(\"target_feature\", \"hw-mul\");\n-    if (TARGET_HAS_MULX)\n-        rust_add_target_info(\"target_feature\", \"hw-mulx\");\n-    if (TARGET_FAST_SW_DIV)\n-        rust_add_target_info(\"target_feature\", \"fast-sw-div\");\n-    if (TARGET_BYPASS_CACHE)\n-        rust_add_target_info(\"target_feature\", \"bypass-cache\");\n-    if (TARGET_BYPASS_CACHE_VOLATILE)\n-        rust_add_target_info(\"target_feature\", \"no-cache-volatile\");\n-    // TODO: ensure below switch variable and whatever works\n-    // TODO: improve how this works? the defining kinda sucks a bit\n-    switch (nios2_gpopt_option) {\n-        case gpopt_none:\n-            rust_add_target_info(\"target_feature\", \"gpopt-none\");\n-            break;\n-        case gpopt_local:\n-            rust_add_target_info(\"target_feature\", \"gpopt-local\");\n-            break;\n-        case gpopt_global:\n-            rust_add_target_info(\"target_feature\", \"gpopt-global\");\n-            break;\n-        case gpopt_data:\n-            rust_add_target_info(\"target_feature\", \"gpopt-data\");\n-            break;\n-        case gpopt_all:\n-            rust_add_target_info(\"target_feature\", \"gpopt-all\");\n-            break;\n-        default: // unknown gpopt status - should this be an error?\n-            break;\n-    }\n-    if (TARGET_BIG_ENDIAN)\n-        rust_add_target_info(\"target_feature\", \"eb\");\n-    else\n-        rust_add_target_info(\"target_feature\", \"el\");\n-    /* TODO: figure out how to have custom-fpu-cfg, custom-ftruncds (including no-custom-ftruncds),\n-     * etc. (all custom instructions and their no- equivalents) in define form  */\n-    // TODO: ensure below switch and variable works\n-    switch (nios2_arch_option) {\n-        case ARCH_R1:\n-            rust_add_target_info(\"target_feature\", \"r1\");\n-            rust_add_target_info(\"target_feature\", \"nios2r1\");\n-            break;\n-        case ARCH_R2:\n-            rust_add_target_info(\"target_feature\", \"r2\");\n-            rust_add_target_info(\"target_feature\", \"nios2r2\");\n-            break;\n-        default: // should this be an error?\n-            break;\n-    }\n-    if (TARGET_HAS_BMX)\n-        rust_add_target_info(\"target_feature\", \"bmx\");\n-    if (TARGET_HAS_CDX)\n-        rust_add_target_info(\"target_feature\", \"cdx\");\n-    // TODO: figure out how to have gprel-sec and r0rel-sec as defines\n-    // TODO: maybe extra defines for features available on bare metal target? (hal, smallc, etc.)\n-}"}, {"sha": "0e18abd5435bbfc46ccfcadb02953038caaacc51", "filename": "gcc/config/nvptx/nvptx-rust.cc", "status": "removed", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d1a6deb4e69e7dc162e741377674cf03459bcd9/gcc%2Fconfig%2Fnvptx%2Fnvptx-rust.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d1a6deb4e69e7dc162e741377674cf03459bcd9/gcc%2Fconfig%2Fnvptx%2Fnvptx-rust.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx-rust.cc?ref=8d1a6deb4e69e7dc162e741377674cf03459bcd9", "patch": "@@ -1,64 +0,0 @@\n-/* Subroutines for the Rust front end for the Nvidia PTX architecture.\n-   Copyright (C) 2020-2022 Free Software Foundation, Inc.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"tm_p.h\"\n-#include \"rust/rust-target.h\"\n-#include \"rust/rust-target-def.h\"\n-\n-/* Implement TARGET_RUST_CPU_INFO for NVPTX targets.  */\n-\n-void nvptx_rust_target_cpu_info(void) {\n-    if (TARGET_ABI64)\n-        rust_add_target_info(\"target_arch\", \"nvptx64\");\n-    else\n-        rust_add_target_info(\"target_arch\", \"nvptx\");\n-\n-    // TODO: should this also override target_os and target_vendor to be \"cuda\" and \"nvidia\"?\n-\n-    // names derived from llvm\n-    // TODO: ensure below variable and switch works\n-    switch (ptx_isa_option) {\n-        /* TODO: if gcc adds other sm versions (llvm has 20, 21, 32, 37, 50, 52, 53, 60, 61, 62, 70, 72, \n-         * 75, 80 as well), add them here  */\n-        case PTX_ISA_SM30:\n-            rust_add_target_info(\"target_feature\", \"sm_30\");\n-            break;\n-        case PTX_ISA_SM35:\n-            rust_add_target_info(\"target_feature\", \"sm_35\");\n-            break;\n-        default: // should this be an error?\n-            break;\n-    }\n-    /* TODO: add ptx versions as separate features if gcc adds them (ptx32, 40, 41, 42, 43, 50, 60, 61, \n-     * 63, 64, 65, 70)  */\n-\n-    // NOTE: below are all gcc-derived features that do not appear in llvm. they appeared useful, so added\n-    // TODO: ensure below variable works\n-    if (nvptx_optimize)\n-        rust_add_target_info(\"target_feature\", \"optimize\");\n-    if (TARGET_SOFT_STACK)\n-        rust_add_target_info(\"target_feature\", \"soft-stack\");\n-    // TODO: find way to have soft-stack-reserve-local as define\n-    if (TARGET_UNIFORM_SIMT)\n-        rust_add_target_info(\"target_feature\", \"uniform-simt\");\n-    if (TARGET_GOMP)\n-        rust_add_target_info(\"target_feature\", \"gomp\");\n-}"}, {"sha": "f0b8cee260913de5e06adfdb4dab9c40066eacd2", "filename": "gcc/config/or1k/or1k-rust.cc", "status": "removed", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d1a6deb4e69e7dc162e741377674cf03459bcd9/gcc%2Fconfig%2For1k%2For1k-rust.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d1a6deb4e69e7dc162e741377674cf03459bcd9/gcc%2Fconfig%2For1k%2For1k-rust.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2For1k%2For1k-rust.cc?ref=8d1a6deb4e69e7dc162e741377674cf03459bcd9", "patch": "@@ -1,58 +0,0 @@\n-/* Subroutines for the Rust front end for the OpenRISC architecture.\n-   Copyright (C) 2020-2022 Free Software Foundation, Inc.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"tm_p.h\"\n-#include \"rust/rust-target.h\"\n-#include \"rust/rust-target-def.h\"\n-\n-/* Implement TARGET_RUST_CPU_INFO for OpenRISC targets.  */\n-\n-void or1k_rust_target_cpu_info(void) {\n-    rust_add_target_info(\"target_arch\", \"or1k\");\n-\n-    // names derived from llvm fork\n-    if (!(TARGET_SOFT_MUL)) \n-        rust_add_target_info(\"target_feature\", \"mul\");\n-    if (!(TARGET_SOFT_DIV))\n-        rust_add_target_info(\"target_feature\", \"div\");\n-    if (TARGET_ROR) \n-        rust_add_target_info(\"target_feature\", \"ror\");\n-    if (TARGET_CMOV)\n-        rust_add_target_info(\"target_feature\", \"cmov\");\n-    /* TODO: add options for addc (add with carry), ffl1 (find first/last one), interrupts (use \n-     * l.lwa/l.swa for atomic RMW ops) if can find gcc equivalents.  */\n-    if (TARGET_SEXT)\n-        rust_add_target_info(\"target_feature\", \"ext\");\n-\n-    // below are options not in llvm but derived from gcc, as they seemed potentially useful\n-    if (TARGET_HARD_FLOAT)\n-        rust_add_target_info(\"target_feature\", \"hard-float\");\n-    if (TARGET_DOUBLE_FLOAT)\n-        rust_add_target_info(\"target_feature\", \"double-float\");\n-    if (TARGET_FP_UNORDERED)\n-        rust_add_target_info(\"target_feature\", \"unordered-float\");\n-    if (TARGET_RORI) \n-        rust_add_target_info(\"target_feature\", \"rori\");\n-    if (TARGET_SFIMM)\n-        rust_add_target_info(\"target_feature\", \"sfimm\");\n-    if (TARGET_SHFTIMM) \n-        rust_add_target_info(\"target_feature\", \"shftimm\");\n-}"}, {"sha": "aab742f888d12b4553ed30c9bc3afda35e8ae0ee", "filename": "gcc/config/pa/pa-rust.cc", "status": "removed", "additions": 0, "deletions": 88, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d1a6deb4e69e7dc162e741377674cf03459bcd9/gcc%2Fconfig%2Fpa%2Fpa-rust.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d1a6deb4e69e7dc162e741377674cf03459bcd9/gcc%2Fconfig%2Fpa%2Fpa-rust.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-rust.cc?ref=8d1a6deb4e69e7dc162e741377674cf03459bcd9", "patch": "@@ -1,88 +0,0 @@\n-/* Subroutines for the Rust front end for the HPPA architecture.\n-   Copyright (C) 2020-2022 Free Software Foundation, Inc.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"tm_p.h\"\n-#include \"rust/rust-target.h\"\n-#include \"rust/rust-target-def.h\"\n-\n-/* Implement TARGET_RUST_CPU_INFO for HPPA targets.  */\n-\n-void pa_rust_target_cpu_info(void) {\n-    rust_add_target_info(\"target_arch\", \"hppa\");\n-\n-    // names made up by me (as no apparent current nor historical llvm support), based on gcc options\n-    /* TODO: figure out how to get data for linker-opt, nosnake - not defined in variable, apparently */\n-    if (TARGET_CALLER_COPIES) \n-        rust_add_target_info(\"target_feature\", \"caller-copies\");\n-    if (TARGET_COHERENT_LDCW)\n-        rust_add_target_info(\"target_feature\", \"coherent-ldcw\");\n-    if (TARGET_DISABLE_FPREGS) \n-        rust_add_target_info(\"target_feature\", \"disable-fpregs\");\n-    if (TARGET_DISABLE_INDEXING)\n-        rust_add_target_info(\"target_feature\", \"disable-indexing\");\n-    if (TARGET_FAST_INDIRECT_CALLS)\n-        rust_add_target_info(\"target_feature\", \"fast-indirect-calls\");\n-    // TODO: figure out how to represent fixed-range (ranges of registers to make fixed) as define\n-    if (TARGET_GAS)\n-        rust_add_target_info(\"target_feature\", \"gas\");\n-    if (TARGET_LONG_CALLS)\n-        rust_add_target_info(\"target_feature\", \"long-calls\");\n-    if (TARGET_LONG_LOAD_STORE)\n-        rust_add_target_info(\"target_feature\", \"long-load-store\");\n-    if (TARGET_NO_SPACE_REGS) \n-        rust_add_target_info(\"target_feature\", \"no-space-regs\");\n-    if (TARGET_ORDERED)\n-        rust_add_target_info(\"target_feature\", \"ordered\");\n-    if (TARGET_PORTABLE_RUNTIME)\n-        rust_add_target_info(\"target_feature\", \"portable-runtime\");\n-    if (TARGET_SOFT_FLOAT)\n-        rust_add_target_info(\"target_feature\", \"soft-float\");\n-\n-    // defines for generating PA 1.1 or PA 2.0 code - TODO should PA 2.0 imply PA 1.1 as well?\n-    if (TARGET_PA_11) \n-        rust_add_target_info(\"target_feature\", \"pa-risc-1-1\");\n-    if (TARGET_PA_20) \n-        rust_add_target_info(\"target_feature\", \"pa-risc-2-0\");\n-\n-    // TODO: ensure switch and variable work\n-    switch (pa_cpu) {\n-        case PROCESSOR_8000:\n-            rust_add_target_info(\"target_feature\", \"schedule-8000\");\n-            break;\n-        case PROCESSOR_7100:\n-            rust_add_target_info(\"target_feature\", \"schedule-7100\");\n-            break;\n-        case PROCESSOR_700:\n-            rust_add_target_info(\"target_feature\", \"schedule-700\");\n-            break;\n-        case PROCESSOR_7100LC:\n-            rust_add_target_info(\"target_feature\", \"schedule-7100lc\");\n-            break;\n-        case PROCESSOR_7200:\n-            rust_add_target_info(\"target_feature\", \"schedule-7200\");\n-            break;\n-        case PROCESSOR_7300:\n-            rust_add_target_info(\"target_feature\", \"schedule-7300\");\n-            break;\n-        default: // should this be an error?\n-            break;\n-    }\n-}"}, {"sha": "4b195657364bdc866a3651cd7eea4e4f501ab00c", "filename": "gcc/config/pdp11/pdp11-rust.cc", "status": "removed", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d1a6deb4e69e7dc162e741377674cf03459bcd9/gcc%2Fconfig%2Fpdp11%2Fpdp11-rust.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d1a6deb4e69e7dc162e741377674cf03459bcd9/gcc%2Fconfig%2Fpdp11%2Fpdp11-rust.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11-rust.cc?ref=8d1a6deb4e69e7dc162e741377674cf03459bcd9", "patch": "@@ -1,59 +0,0 @@\n-/* Subroutines for the Rust front end for the PDP-11 architecture.\n-   Copyright (C) 2020-2022 Free Software Foundation, Inc.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"tm_p.h\"\n-#include \"rust/rust-target.h\"\n-#include \"rust/rust-target-def.h\"\n-\n-/* Implement TARGET_RUST_CPU_INFO for PDP-11 targets.  */\n-\n-void pdp11_rust_target_cpu_info(void) {\n-    rust_add_target_info(\"target_arch\", \"pdp11\");\n-\n-    // names made up by me (as no apparent current nor historical llvm support), based on gcc options\n-    /* TODO: figure out how to get data for linker-opt, nosnake - not defined in variable, apparently */\n-    if (TARGET_AC0) \n-        rust_add_target_info(\"target_feature\", \"ac0\");\n-    if (TARGET_DEC_ASM)\n-        rust_add_target_info(\"target_feature\", \"dec-asm\");\n-    if (TARGET_GNU_ASM)\n-        rust_add_target_info(\"target_feature\", \"gnu-asm\");\n-    if (TARGET_UNIX_ASM) \n-        rust_add_target_info(\"target_feature\", \"unix-asm\");\n-    if (TARGET_FPU)\n-        rust_add_target_info(\"target_feature\", \"fpu\");\n-    else\n-        rust_add_target_info(\"target_feature\", \"soft-float\");\n-    if (TARGET_INT32)\n-        rust_add_target_info(\"target_feature\", \"int32\");\n-    else\n-        rust_add_target_info(\"target_feature\", \"int16\");\n-    if (TARGET_SPLIT)\n-        rust_add_target_info(\"target_feature\", \"split\");\n-    if (TARGET_LRA)\n-        rust_add_target_info(\"target_feature\", \"lra\");\n-\n-    // defines for generating -40 and -45 code - TODO should -45 imply -40 as well? -10 seems implicit\n-    if (TARGET_40) \n-        rust_add_target_info(\"target_feature\", \"pa-risc-1-1\");\n-    if (TARGET_45) \n-        rust_add_target_info(\"target_feature\", \"pa-risc-2-0\");\n-}"}, {"sha": "27d41aea8bff9be5956fd19662eedcd0130f8aec", "filename": "gcc/config/riscv/riscv-rust.cc", "status": "removed", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d1a6deb4e69e7dc162e741377674cf03459bcd9/gcc%2Fconfig%2Friscv%2Friscv-rust.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d1a6deb4e69e7dc162e741377674cf03459bcd9/gcc%2Fconfig%2Friscv%2Friscv-rust.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-rust.cc?ref=8d1a6deb4e69e7dc162e741377674cf03459bcd9", "patch": "@@ -1,60 +0,0 @@\n-/* Subroutines for the Rust front end for the RISC-V architecture.\n-   Copyright (C) 2020-2022 Free Software Foundation, Inc.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"tm_p.h\"\n-#include \"rust/rust-target.h\"\n-#include \"rust/rust-target-def.h\"\n-\n-/* Implement TARGET_RUST_CPU_INFO for RISC-V targets.  */\n-\n-void riscv_rust_target_cpu_info(void) {\n-    if (TARGET_64BIT)\n-        rust_add_target_info(\"target_arch\", \"riscv64\");\n-    else\n-        rust_add_target_info(\"target_arch\", \"riscv32\");\n-\n-    // names derived from rustc and llvm \n-    if (TARGET_SAVE_RESTORE) \n-        rust_add_target_info(\"target_feature\", \"save-restore\");\n-    // TODO: ensure below variable works\n-    if (riscv_mrelax)\n-        rust_add_target_info(\"target_feature\", \"relax\");\n-    if (TARGET_MUL)\n-        rust_add_target_info(\"target_feature\", \"m\");\n-    if (TARGET_ATOMIC)\n-        rust_add_target_info(\"target_feature\", \"a\");\n-    if (TARGET_HARD_FLOAT)\n-        rust_add_target_info(\"target_feature\", \"f\");\n-    if (TARGET_DOUBLE_FLOAT)\n-        rust_add_target_info(\"target_feature\", \"d\");\n-    if (TARGET_RVC)\n-        rust_add_target_info(\"target_feature\", \"c\");\n-    if (TARGET_RVE)\n-        rust_add_target_info(\"target_feature\", \"e\");\n-    // TODO: add features based on \"B\" and \"V\" extensions when gcc adds them\n-    // TODO: if gcc has it, add \"no-rvc-hints\" flag \n-    // TODO: if gcc has it, add reserve-x1 -> reserve-x31 (user reserve registers)\n-    if (TARGET_64BIT)\n-        rust_add_target_info(\"target_feature\", \"64bit\");\n-    /* TODO: maybe add gcc features with no llvm equivalent, e.g. align-data, riscv-attribute, \n-     * explicit-relocs, strict-align, cmodel, small-data-limit, branch-cost, plt, abi, \n-     * preferred-stack-boundary, fdiv, div */\n-}"}, {"sha": "f1211490e889eb9c6d60c8e573052216faa1cd6c", "filename": "gcc/config/rs6000/rs6000-rust.cc", "status": "removed", "additions": 0, "deletions": 81, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d1a6deb4e69e7dc162e741377674cf03459bcd9/gcc%2Fconfig%2Frs6000%2Frs6000-rust.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d1a6deb4e69e7dc162e741377674cf03459bcd9/gcc%2Fconfig%2Frs6000%2Frs6000-rust.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-rust.cc?ref=8d1a6deb4e69e7dc162e741377674cf03459bcd9", "patch": "@@ -1,81 +0,0 @@\n-/* Subroutines for the Rust front end on the PowerPC architecture.\n-   Copyright (C) 2020-2022 Free Software Foundation, Inc.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"rust/rust-target.h\"\n-#include \"rust/rust-target-def.h\"\n-\n-/* Implement TARGET_RUST_CPU_INFO for PowerPC targets.  */\n-\n-void\n-rs6000_rust_target_cpu_info (void)\n-{\n-  // note that rustc makes no arch distinction between powerpc64 and powerpc64 little endian\n-  if (TARGET_64BIT)\n-    rust_add_target_info (\"target_arch\", \"powerpc64\");\n-  else\n-    rust_add_target_info (\"target_arch\", \"powerpc\");\n-\n-  // TODO: define properly instead of macros\n-#ifdef flags\n-# error \"multiple flags already defined in rs6000-rust.cc\"\n-#endif\n-#define flags rs6000_isa_flags\n-\n-  // options should be (almost at least - i.e. power8-altivec and the like) feature complete with rustc\n-  if ((flags & OPTION_MASK_ALTIVEC) != 0)\n-    rust_add_target_info (\"target_feature\", \"altivec\");\n-  if ((flags & OPTION_MASK_VSX) != 0)\n-    rust_add_target_info (\"target_feature\", \"vsx\");\n-  /* I can't find any separate gcc equivalent to \"power8-altivec\" in llvm, but power8-vector has it as a\n-   * prerequisite, so just implicitly enable it when enabling the vector. TODO search for it. */\n-  if ((flags & OPTION_MASK_P8_VECTOR) != 0) {\n-    rust_add_target_info (\"target_feature\", \"power8-vector\");\n-    rust_add_target_info (\"target_feature\", \"power8-altivec\");\n-  }\n-  if ((flags & OPTION_MASK_CRYPTO) != 0)\n-    rust_add_target_info (\"target_feature\", \"crypto\");\n-  if ((flags & OPTION_MASK_HTM) != 0)\n-    rust_add_target_info (\"target_feature\", \"htm\");\n-  if ((flags & OPTION_MASK_FLOAT128_KEYWORD) != 0)\n-    rust_add_target_info (\"target_feature\", \"float128\");\n-  // Same implicit enabling of power9-altivec happens with power9-vector.\n-  if ((flags & OPTION_MASK_P9_VECTOR) != 0) {\n-    rust_add_target_info (\"target_feature\", \"power9-vector\");\n-    rust_add_target_info (\"target_feature\", \"power9-altivec\");\n-  }\n-  if ((flags & OPTION_MASK_DIRECT_MOVE) != 0)\n-    rust_add_target_info (\"target_feature\", \"direct-move\");\n-\n-  if (TARGET_SECURE_PLT)\n-    rust_add_target_info (\"target_feature\", \"secure-plt\");\n-\n-  if ((flags & OPTION_MASK_SOFT_FLOAT) != 0)\n-    ; // apparently not an option - TODO find out if it is\n-  else\n-    rust_add_target_info (\"target_feature\", \"hard-float\");\n-\n-  // TODO: some possible features (in rustc, listed under powerpc-wrs-vxworks-spe) - \"msync\"\n-  // other possible features (in clang) - \"qpx\" (when cpu = \"a2q\"), \"bpermd\", \"extdiv\", \"spe\"\n-\n-  // note: in gcc, it is possible bpermd is available if popcntd is available (which is power 7)\n-\n-#undef flags\n-}"}, {"sha": "62792b37079f966643928dbeeb9920e4c0d958e8", "filename": "gcc/config/rx/rx-rust.cc", "status": "removed", "additions": 0, "deletions": 75, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d1a6deb4e69e7dc162e741377674cf03459bcd9/gcc%2Fconfig%2Frx%2Frx-rust.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d1a6deb4e69e7dc162e741377674cf03459bcd9/gcc%2Fconfig%2Frx%2Frx-rust.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx-rust.cc?ref=8d1a6deb4e69e7dc162e741377674cf03459bcd9", "patch": "@@ -1,75 +0,0 @@\n-/* Subroutines for the Rust front end for the Renesas RX architecture.\n-   Copyright (C) 2020-2022 Free Software Foundation, Inc.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"tm_p.h\"\n-#include \"rust/rust-target.h\"\n-#include \"rust/rust-target-def.h\"\n-\n-/* Implement TARGET_RUST_CPU_INFO for RX targets.  */\n-\n-void rx_rust_target_cpu_info(void) {\n-    rust_add_target_info(\"target_arch\", \"rx\");\n-\n-    // llvm appears to have no (current or historical) support, so names made up by me\n-    if (TARGET_64BIT_DOUBLES) \n-        rust_add_target_info(\"target_feature\", \"64bit-doubles\");\n-    if (TARGET_NO_USE_FPU)\n-        rust_add_target_info(\"target_feature\", \"nofpu\");\n-    // TODO: ensure below switch and variable works\n-    switch (rx_cpu_type) {\n-        case RX610:\n-            rust_add_target_info(\"target_feature\", \"cpu-rx610\");\n-            break;\n-        case RX200:\n-            rust_add_target_info(\"target_feature\", \"cpu-rx200\");\n-            break;\n-        case RX600:\n-            rust_add_target_info(\"target_feature\", \"cpu-rx600\");\n-            break;\n-        case RX100:\n-            rust_add_target_info(\"target_feature\", \"cpu-rx100\");\n-            break;\n-        default: // should this be an error? probably shouldn't happen\n-            break;\n-    }\n-    if (TARGET_BIG_ENDIAN_DATA)\n-        rust_add_target_info(\"target_feature\", \"big-endian-data\");\n-    // TODO: find way of having small-data-limit, max-constant-size, int-register as defines\n-    // TODO: find way of getting info for relax\n-    if (TARGET_SAVE_ACC_REGISTER)\n-        rust_add_target_info(\"target_feature\", \"save-acc-in-interrupts\");\n-    if (TARGET_PID)\n-        rust_add_target_info(\"target_feature\", \"pid\");\n-    // TODO: ensure below variable works\n-    if (rx_warn_multiple_fast_interrupts)\n-        rust_add_target_info(\"target_feature\", \"warn-multiple-fast-interrupts\");\n-    if (TARGET_GCC_ABI)\n-        rust_add_target_info(\"target_feature\", \"gcc-abi\");\n-    else \n-        rust_add_target_info(\"target_feature\", \"rx-abi\");\n-    if (TARGET_ENABLE_LRA)\n-        rust_add_target_info(\"target_feature\", \"lra\");\n-    // TODO: ensure below variable works\n-    if (rx_allow_string_insns)\n-        rust_add_target_info(\"target_feature\", \"allow-string-insns\");\n-    if (TARGET_JSR)\n-        rust_add_target_info(\"target_feature\", \"jsr\");\n-}"}, {"sha": "8af43dcf5755d0911653ee79316020973da9d02d", "filename": "gcc/config/s390/s390-rust.cc", "status": "removed", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d1a6deb4e69e7dc162e741377674cf03459bcd9/gcc%2Fconfig%2Fs390%2Fs390-rust.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d1a6deb4e69e7dc162e741377674cf03459bcd9/gcc%2Fconfig%2Fs390%2Fs390-rust.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-rust.cc?ref=8d1a6deb4e69e7dc162e741377674cf03459bcd9", "patch": "@@ -1,57 +0,0 @@\n-/* Subroutines for the Rust front end for the IBM S/390 and zSeries architectures.\n-   Copyright (C) 2020-2022 Free Software Foundation, Inc.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"tm_p.h\"\n-#include \"rust/rust-target.h\"\n-#include \"rust/rust-target-def.h\"\n-\n-/* Implement TARGET_RUST_CPU_INFO for S/390 and zSeries targets.  */\n-\n-void s390_rust_target_cpu_info(void) {\n-    // TODO: ensure that this is right for llvm/rustc arch \n-    if (TARGET_64BIT)\n-        rust_add_target_info(\"target_arch\", \"s390x\");\n-    else\n-        rust_add_target_info(\"target_arch\", \"s390\");\n-\n-    // names derived from llvm and rustc\n-    if (TARGET_SOFT_FLOAT) \n-        rust_add_target_info(\"target_feature\", \"soft-float\");\n-    else\n-        rust_add_target_info(\"target_feature\", \"fp-extension\");\n-    // TODO: ensure that having hardware float is actually what fp-extension refers to\n-    /* TODO: find gcc equivalent of distinct-ops (distinct-operands facility), fast-serialization, \n-     * high-word, interlocked-access1, load-store-on-cond, population-count, \n-     * message-security-assist-extension3, message-security-assist-extension4, \n-     * reset-reference-bits-multiple, execution-hint, load-and-trap, miscellaneous-extensions, \n-     * processor-assist, dfp-zoned-conversion, enhanced-dat-2, load-and-zero-rightmost-byte, \n-     * load-store-on-cond-2, message-security-assist-extension5, dfp-packed-conversion, \n-     * miscellaneous-extensions-2, message-security-assist-extension7, message-security-assist-extension8, \n-     * vector-enhancements-1, vector-packed-decimal, insert-reference-bits-multiple, \n-     * miscellaneous-extensions-3, message-security-assist-extension9, vector-enhancements-2, \n-     * vector-packed-decimal-enhancement, enhanced-sort, deflate-conversion if they exist */    \n-    if (TARGET_OPT_HTM)\n-        rust_add_target_info(\"target_feature\", \"transactional-execution\");\n-    // TODO: ensure that \"vector\" only refers to code generation and not language exts and builtins\n-    if (TARGET_OPT_VX)\n-        rust_add_target_info(\"target_feature\", \"vector\");\n-    // TODO: is guarded-storage the same thing as stack-guard? if so, add that option mapping\n-}"}, {"sha": "bae718ddf956a4e806f9cefc8b50600dac8504d3", "filename": "gcc/config/sh/sh-rust.cc", "status": "removed", "additions": 0, "deletions": 163, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d1a6deb4e69e7dc162e741377674cf03459bcd9/gcc%2Fconfig%2Fsh%2Fsh-rust.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d1a6deb4e69e7dc162e741377674cf03459bcd9/gcc%2Fconfig%2Fsh%2Fsh-rust.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-rust.cc?ref=8d1a6deb4e69e7dc162e741377674cf03459bcd9", "patch": "@@ -1,163 +0,0 @@\n-/* Subroutines for the Rust front end for the Renesas / SuperH SH architecture.\n-   Copyright (C) 2020-2022 Free Software Foundation, Inc.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"tm_p.h\"\n-#include \"rust/rust-target.h\"\n-#include \"rust/rust-target-def.h\"\n-\n-/* Implement TARGET_RUST_CPU_INFO for Renesas / SuperH SH targets.  */\n-\n-void sh_rust_target_cpu_info(void) {\n-    rust_add_target_info(\"target_arch\", \"sh\");\n-\n-    // llvm appears to have no (current or historical) support, so names made up by me\n-    // TODO: should arch be cumulative or exclusive? if cumulative, what is dependency of stuff like \"e\"?\n-    // TODO: maybe distinguish between just \"sh4\" and stuff like \"sh4-200\" and \"sh4-300\"?\n-    switch ((int)sh_cpu) {\n-        case PROCESSOR_SH1:\n-            rust_add_target_info(\"target_feature\", \"sh1\");\n-            break;\n-        case PROCESSOR_SH2:\n-            rust_add_target_info(\"target_feature\", \"sh2\");\n-            break;\n-        case PROCESSOR_SH2E:\n-            rust_add_target_info(\"target_feature\", \"sh2e\");\n-            break;\n-        case PROCESSOR_SH2A:\n-            rust_add_target_info(\"target_feature\", \"sh2a\");\n-            if (TARGET_SH2A_DOUBLE) {\n-                if (TARGET_FPU_SINGLE)\n-                    rust_add_target_info(\"target_feature\", \"single\");\n-            } else {\n-                if (TARGET_FPU_ANY)\n-                    rust_add_target_info(\"target_feature\", \"single-only\");\n-                else\n-                    rust_add_target_info(\"target_feature\", \"nofpu\");\n-            }\n-            break;\n-        case PROCESSOR_SH3:      \n-            if (TARGET_HARD_SH4) {\n-                rust_add_target_info(\"target_feature\", \"sh4\");\n-                rust_add_target_info(\"target_feature\", \"nofpu\");\n-            } else {\n-                rust_add_target_info(\"target_feature\", \"sh3\");\n-            }\n-            break;\n-        case PROCESSOR_SH3E:\n-            if (TARGET_HARD_SH4) {\n-                rust_add_target_info(\"target_feature\", \"sh4\");\n-                rust_add_target_info(\"target_feature\", \"single-only\");\n-            } else {\n-                rust_add_target_info(\"target_feature\", \"sh3e\");\n-            }\n-            break;\n-        case PROCESSOR_SH4:\n-            rust_add_target_info(\"target_feature\", \"sh4\");\n-            if (TARGET_FPU_SINGLE)\n-                rust_add_target_info(\"target_feature\", \"single\");\n-            break;\n-        case PROCESSOR_SH4A:\n-            rust_add_target_info(\"target_feature\", \"sh4a\");\n-            if (TARGET_SH4) {\n-                if (TARGET_FPU_SINGLE)\n-                    rust_add_target_info(\"target_feature\", \"single\");\n-            } else {\n-                if (TARGET_FPU_ANY)\n-                    rust_add_target_info(\"target_feature\", \"single-only\");\n-                else\n-                    rust_add_target_info(\"target_feature\", \"nofpu\");\n-            }\n-            break;\n-        default: // should this be an error?\n-            break;\n-    }\n-\n-    if (TARGET_ACCUMULATE_OUTGOING_ARGS)\n-        rust_add_target_info(\"target_feature\", \"accumulate-outgoing-args\");\n-    if (TARGET_LITTLE_ENDIAN)\n-        rust_add_target_info(\"target_feature\", \"l\");\n-    else\n-        rust_add_target_info(\"target_feature\", \"b\");\n-    if (TARGET_BIGTABLE)\n-        rust_add_target_info(\"target_feature\", \"bigtable\");\n-    if (TARGET_BITOPS)\n-        rust_add_target_info(\"target_feature\", \"bitops\");\n-    // TODO: determine way of having branch-cost, fixed-range, multcost, divsi3_libfunc as defines\n-    if (TARGET_ZDCBRANCH)\n-        rust_add_target_info(\"target_feature\", \"zdcbranch\");\n-    if (TARGET_CBRANCH_FORCE_DELAY_SLOT)\n-        rust_add_target_info(\"target_feature\", \"cbranch-force-delay-slot\");\n-    if (TARGET_ALIGN_DOUBLE)\n-        rust_add_target_info(\"target_feature\", \"dalign\");\n-    if (TARGET_DIVIDE_CALL_DIV1)\n-        rust_add_target_info(\"target_feature\", \"div-call-div1\");\n-    else if (TARGET_DIVIDE_CALL_FP)\n-        rust_add_target_info(\"target_feature\", \"div-call-fp\");\n-    else if (TARGET_DIVIDE_CALL_TABLE)\n-        rust_add_target_info(\"target_feature\", \"div-call-table\");\n-    if (TARGET_FDPIC)\n-        rust_add_target_info(\"target_feature\", \"fdpic\");\n-    if (TARGET_FMOVD)\n-        rust_add_target_info(\"target_feature\", \"fmovd\");\n-    if (TARGET_HITACHI) {\n-        rust_add_target_info(\"target_feature\", \"hitachi\");\n-        rust_add_target_info(\"target_feature\", \"renesas\");\n-    }\n-    if (TARGET_IEEE)\n-        rust_add_target_info(\"target_feature\", \"ieee\");\n-    if (TARGET_INLINE_IC_INVALIDATE)\n-        rust_add_target_info(\"target_feature\", \"inline-ic_invalidate\");\n-    if (TARGET_DUMPISIZE)\n-        rust_add_target_info(\"target_feature\", \"isize\");\n-    if (TARGET_NOMACSAVE)\n-        rust_add_target_info(\"target_feature\", \"nomacsave\");\n-    // ignoring padstruct as set to be removed\n-    if (TARGET_PREFERGOT)\n-        rust_add_target_info(\"target_feature\", \"prefergot\");\n-    if (TARGET_RELAX)\n-        rust_add_target_info(\"target_feature\", \"relax\");\n-    if (TARGET_ENABLE_TAS)\n-        rust_add_target_info(\"target_feature\", \"tas\");\n-    if (TARGET_USERMODE)\n-        rust_add_target_info(\"target_feature\", \"usermode\");\n-    if (TARGET_PRETEND_CMOVE)\n-        rust_add_target_info(\"target_feature\", \"pretend-cmove\");\n-    if (TARGET_FSCA)\n-        rust_add_target_info(\"target_feature\", \"fsca\");\n-    if (TARGET_FSRRA)\n-        rust_add_target_info(\"target_feature\", \"fsrra\");\n-    if (sh_lra_flag)\n-        rust_add_target_info(\"target_feature\", \"lra\");\n-\n-    if (selected_atomic_model().type == sh_atomic_model::none)\n-        rust_add_target_info(\"target_feature\", \"atomic-model-none\");\n-    if (TARGET_ATOMIC_SOFT_GUSA)\n-        rust_add_target_info(\"target_feature\", \"atomic-model-soft-gusa\");\n-    if (TARGET_ATOMIC_SOFT_TCB)\n-        rust_add_target_info(\"target_feature\", \"atomic-model-soft-tcb\");\n-    if (TARGET_ATOMIC_SOFT_IMASK)\n-        rust_add_target_info(\"target_feature\", \"atomic-model-soft-imask\");\n-    if (TARGET_ATOMIC_HARD_LLCS)\n-        rust_add_target_info(\"target_feature\", \"atomic-model-hard-llcs\");\n-    if (TARGET_ATOMIC_STRICT)\n-        rust_add_target_info(\"target_feature\", \"atomic-model-strict\");\n-    // TODO: maybe have gbr-offset (from atomic-model) as define?\n-}"}, {"sha": "8921ba6376ce7b4a0a0858d7ff60c35de8e78784", "filename": "gcc/config/sparc/sparc-rust.cc", "status": "removed", "additions": 0, "deletions": 65, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d1a6deb4e69e7dc162e741377674cf03459bcd9/gcc%2Fconfig%2Fsparc%2Fsparc-rust.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d1a6deb4e69e7dc162e741377674cf03459bcd9/gcc%2Fconfig%2Fsparc%2Fsparc-rust.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-rust.cc?ref=8d1a6deb4e69e7dc162e741377674cf03459bcd9", "patch": "@@ -1,65 +0,0 @@\n-/* Subroutines for the Rust front end for the SPARC architecture.\n-   Copyright (C) 2020-2022 Free Software Foundation, Inc.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"memmodel.h\"\n-#include \"tm_p.h\"\n-#include \"rust/rust-target.h\"\n-#include \"rust/rust-target-def.h\"\n-\n-/* Implement TARGET_RUST_CPU_INFO for SPARC targets.  */\n-\n-void sparc_rust_target_cpu_info(void) {\n-    if (TARGET_64BIT)\n-        rust_add_target_info(\"target_arch\", \"sparc64\");\n-    else \n-        rust_add_target_info(\"target_arch\", \"sparc\");\n-\n-    // names based on llvm \n-    /* TODO: try to isolate soft-mul-div feature (software emulation for integer multiply and divide) \n-     * if doable? does gcc even support this? */\n-    if (!(TARGET_FSMULD))\n-        rust_add_target_info(\"target_feature\", \"no-fsmuld\");\n-    // TODO: add \"no-fmuls\" (fmuls instruction) option if can find in gcc\n-    if (TARGET_V9)\n-        rust_add_target_info(\"target_feature\", \"v9\");\n-    if (TARGET_DEPRECATED_V8_INSNS)\n-        rust_add_target_info(\"target_feature\", \"deprecated-v8\");\n-    if (TARGET_VIS)\n-        rust_add_target_info(\"target_feature\", \"vis\");\n-    if (TARGET_VIS2)\n-        rust_add_target_info(\"target_feature\", \"vis2\");\n-    if (TARGET_VIS3)\n-        rust_add_target_info(\"target_feature\", \"vis3\");\n-    if (TARGET_LEON) // TODO: does this mean just leon or also allow leon v3?\n-        rust_add_target_info(\"target_feature\", \"leon\");\n-    // TODO: add \"leonpwrpsr\" (PWRPSR instruction) option if can find in gcc\n-    if (TARGET_HARD_QUAD)\n-        rust_add_target_info(\"target_feature\", \"hard-quad-float\");\n-    if (TARGET_POPC)\n-        rust_add_target_info(\"target_feature\", \"popc\");\n-    if (!(TARGET_FPU))\n-        rust_add_target_info(\"target_feature\", \"soft-float\");\n-    /* TODO: add \"hasumacsmac\" (UMAC and SMAC insns), \"hasleoncasa\" (CASA insns), \n-     * \"insertnopload\" (LEON3 fix), \"detectroundchange\" (LEON3 fix), \"fixallfdivsqrt\" (LEON fix), \n-     * \"leoncyclecounter\" if in gcc */\n-\n-    // TODO: maybe add features in gcc that seem to have no llvm equivalent\n-}"}, {"sha": "e676e384cddb82b98b15911f4671362ad2e60171", "filename": "gcc/config/v850/v850-rust.cc", "status": "removed", "additions": 0, "deletions": 83, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d1a6deb4e69e7dc162e741377674cf03459bcd9/gcc%2Fconfig%2Fv850%2Fv850-rust.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d1a6deb4e69e7dc162e741377674cf03459bcd9/gcc%2Fconfig%2Fv850%2Fv850-rust.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850-rust.cc?ref=8d1a6deb4e69e7dc162e741377674cf03459bcd9", "patch": "@@ -1,83 +0,0 @@\n-/* Subroutines for the Rust front end for the NEC V850 architecture.\n-   Copyright (C) 2020-2022 Free Software Foundation, Inc.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"tm_p.h\"\n-#include \"rust/rust-target.h\"\n-#include \"rust/rust-target-def.h\"\n-\n-/* Implement TARGET_RUST_CPU_INFO for NEC V850 targets.  */\n-\n-void v850_rust_target_cpu_info(void) {\n-    rust_add_target_info(\"target_arch\", \"v850\");\n-\n-    // appears to have no current or historical support in llvm, so names made up by me\n-    if (TARGET_APP_REGS)\n-        rust_add_target_info(\"target_feature\", \"app-regs\");\n-    if (TARGET_BIG_SWITCH) {\n-        rust_add_target_info(\"target_feature\", \"big-switch\");\n-        rust_add_target_info(\"target_feature\", \"long-jumps\");\n-    }\n-    if (TARGET_DEBUG)\n-        rust_add_target_info(\"target_feature\", \"debug\");\n-    if (TARGET_DISABLE_CALLT)\n-        rust_add_target_info(\"target_feature\", \"disable-callt\");\n-    if (TARGET_EP)\n-        rust_add_target_info(\"target_feature\", \"ep\");\n-    if (TARGET_LONG_CALLS)\n-        rust_add_target_info(\"target_feature\", \"long-calls\");\n-    if (TARGET_PROLOG_FUNCTION) \n-        rust_add_target_info(\"target_feature\", \"prolog-function\");\n-    // TODO: find if can get info from sda, zda and tda options\n-    if (TARGET_SMALL_SLD)\n-        rust_add_target_info(\"target_feature\", \"small-sld\");\n-    if (TARGET_NO_STRICT_ALIGN)\n-        rust_add_target_info(\"target_feature\", \"no-strict-align\");\n-    if (TARGET_JUMP_TABLES_IN_DATA_SECTION)\n-        rust_add_target_info(\"target_feature\", \"jump-tables-in-data-section\");\n-    if (TARGET_US_BIT_SET)\n-        rust_add_target_info(\"target_feature\", \"US-bit-set\");\n-    if (TARGET_V850)\n-        rust_add_target_info(\"target_feature\", \"v850\");\n-    if (TARGET_V850E)\n-        rust_add_target_info(\"target_feature\", \"v850e\");\n-    if (TARGET_V850E1)\n-        rust_add_target_info(\"target_feature\", \"v850e1\");\n-    if (TARGET_V850E2)\n-        rust_add_target_info(\"target_feature\", \"v850e2\");\n-    if (TARGET_V850E2V3)\n-        rust_add_target_info(\"target_feature\", \"v850e2v3\");\n-    if (TARGET_V850E2V5) // TODO: how do i deal with V850E2V4 redirecting to this?\n-        rust_add_target_info(\"target_feature\", \"v850e2v5\");\n-    if (TARGET_LOOP)\n-        rust_add_target_info(\"target_feature\", \"loop\");\n-    if (TARGET_RELAX)\n-        rust_add_target_info(\"target_feature\", \"relax\");\n-    if (TARGET_SOFT_FLOAT)\n-        rust_add_target_info(\"target_feature\", \"soft-float\");\n-    else\n-        rust_add_target_info(\"target_feature\", \"hard-float\");\n-    if (TARGET_GCC_ABI)\n-        rust_add_target_info(\"target_feature\", \"gcc-abi\");\n-    else\n-        rust_add_target_info(\"target_feature\", \"rh850-abi\");\n-    if (TARGET_8BYTE_ALIGN)\n-        rust_add_target_info(\"target_feature\", \"8byte-align\");\n-}"}]}