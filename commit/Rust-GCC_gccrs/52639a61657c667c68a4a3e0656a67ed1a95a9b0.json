{"sha": "52639a61657c667c68a4a3e0656a67ed1a95a9b0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTI2MzlhNjE2NTdjNjY3YzY4YTRhM2UwNjU2YTY3ZWQxYTk1YTliMA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-08-03T07:13:36Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-08-03T07:13:36Z"}, "message": "re PR tree-optimization/66917 (ARM: NEON: memcpy compiles to vst1 with incorrect alignment)\n\n2015-08-03  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/66917\n\t* tree-vectorizer.h (struct dataref_aux): Add base_element_aligned\n\tfield.\n\t(DR_VECT_AUX): New macro.\n\t(set_dr_misalignment): Adjust.\n\t(dr_misalignment): Likewise.\n\t* tree-vect-data-refs.c (vect_compute_data_ref_alignment):\n\tCompute whether the base is at least element aligned.\n\t* tree-vect-stmts.c (ensure_base_align): Adjust.\n\t(vectorizable_store): If the base is not element aligned\n\tpreserve alignment of the original access if misalignment is unknown.\n\t(vectorizable_load): Likewise.\n\nFrom-SVN: r226487", "tree": {"sha": "03864e5caa088bc8f553b9ca5791287f5d2b5a45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/03864e5caa088bc8f553b9ca5791287f5d2b5a45"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/52639a61657c667c68a4a3e0656a67ed1a95a9b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52639a61657c667c68a4a3e0656a67ed1a95a9b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52639a61657c667c68a4a3e0656a67ed1a95a9b0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52639a61657c667c68a4a3e0656a67ed1a95a9b0/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "94b8fdccca7aa703f4cafc57eef3a7f8776e1290", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94b8fdccca7aa703f4cafc57eef3a7f8776e1290", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94b8fdccca7aa703f4cafc57eef3a7f8776e1290"}], "stats": {"total": 91, "additions": 58, "deletions": 33}, "files": [{"sha": "15ca9d15a049beefd06fced3bc2b78da0a6ed43a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52639a61657c667c68a4a3e0656a67ed1a95a9b0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52639a61657c667c68a4a3e0656a67ed1a95a9b0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=52639a61657c667c68a4a3e0656a67ed1a95a9b0", "patch": "@@ -1,3 +1,18 @@\n+2015-08-03  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/66917\n+\t* tree-vectorizer.h (struct dataref_aux): Add base_element_aligned\n+\tfield.\n+\t(DR_VECT_AUX): New macro.\n+\t(set_dr_misalignment): Adjust.\n+\t(dr_misalignment): Likewise.\n+\t* tree-vect-data-refs.c (vect_compute_data_ref_alignment):\n+\tCompute whether the base is at least element aligned.\n+\t* tree-vect-stmts.c (ensure_base_align): Adjust.\n+\t(vectorizable_store): If the base is not element aligned\n+\tpreserve alignment of the original access if misalignment is unknown.\n+\t(vectorizable_load): Likewise.\n+\n 2015-08-02  Martin Sebor  <msebor@redhat.com>\n \n \t* c-family/c.opt (-Wframe-address): New warning option."}, {"sha": "80df9dfe52e73fd9871c9dd10f1c5787ad67e7eb", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52639a61657c667c68a4a3e0656a67ed1a95a9b0/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52639a61657c667c68a4a3e0656a67ed1a95a9b0/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=52639a61657c667c68a4a3e0656a67ed1a95a9b0", "patch": "@@ -622,7 +622,6 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n   tree ref = DR_REF (dr);\n   tree vectype;\n   tree base, base_addr;\n-  bool base_aligned;\n   tree misalign = NULL_TREE;\n   tree aligned_to;\n   unsigned HOST_WIDE_INT alignment;\n@@ -698,6 +697,19 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n \t}\n     }\n \n+  /* To look at alignment of the base we have to preserve an inner MEM_REF\n+     as that carries alignment information of the actual access.  */\n+  base = ref;\n+  while (handled_component_p (base))\n+    base = TREE_OPERAND (base, 0);\n+  if (TREE_CODE (base) == MEM_REF)\n+    base = build2 (MEM_REF, TREE_TYPE (base), base_addr,\n+\t\t   build_int_cst (TREE_TYPE (TREE_OPERAND (base, 1)), 0));\n+  unsigned int base_alignment = get_object_alignment (base);\n+\n+  if (base_alignment >= TYPE_ALIGN (TREE_TYPE (vectype)))\n+    DR_VECT_AUX (dr)->base_element_aligned = true;\n+\n   alignment = TYPE_ALIGN_UNIT (vectype);\n \n   if ((compare_tree_int (aligned_to, alignment) < 0)\n@@ -713,21 +725,7 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n       return true;\n     }\n \n-  /* To look at alignment of the base we have to preserve an inner MEM_REF\n-     as that carries alignment information of the actual access.  */\n-  base = ref;\n-  while (handled_component_p (base))\n-    base = TREE_OPERAND (base, 0);\n-  if (TREE_CODE (base) == MEM_REF)\n-    base = build2 (MEM_REF, TREE_TYPE (base), base_addr,\n-\t\t   build_int_cst (TREE_TYPE (TREE_OPERAND (base, 1)), 0));\n-\n-  if (get_object_alignment (base) >= TYPE_ALIGN (vectype))\n-    base_aligned = true;\n-  else\n-    base_aligned = false;\n-\n-  if (!base_aligned)\n+  if (base_alignment < TYPE_ALIGN (vectype))\n     {\n       /* Strip an inner MEM_REF to a bare decl if possible.  */\n       if (TREE_CODE (base) == MEM_REF\n@@ -757,8 +755,9 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n           dump_printf (MSG_NOTE, \"\\n\");\n         }\n \n-      ((dataref_aux *)dr->aux)->base_decl = base;\n-      ((dataref_aux *)dr->aux)->base_misaligned = true;\n+      DR_VECT_AUX (dr)->base_decl = base;\n+      DR_VECT_AUX (dr)->base_misaligned = true;\n+      DR_VECT_AUX (dr)->base_element_aligned = true;\n     }\n \n   /* If this is a backward running DR then first access in the larger"}, {"sha": "1256b096a3dc8a1b9c6a32aa5ae26535b516a148", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52639a61657c667c68a4a3e0656a67ed1a95a9b0/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52639a61657c667c68a4a3e0656a67ed1a95a9b0/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=52639a61657c667c68a4a3e0656a67ed1a95a9b0", "patch": "@@ -5056,10 +5056,10 @@ ensure_base_align (stmt_vec_info stmt_info, struct data_reference *dr)\n   if (!dr->aux)\n     return;\n \n-  if (((dataref_aux *)dr->aux)->base_misaligned)\n+  if (DR_VECT_AUX (dr)->base_misaligned)\n     {\n       tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n-      tree base_decl = ((dataref_aux *)dr->aux)->base_decl;\n+      tree base_decl = DR_VECT_AUX (dr)->base_decl;\n \n       if (decl_in_symtab_p (base_decl))\n \tsymtab_node::get (base_decl)->increase_alignment (TYPE_ALIGN (vectype));\n@@ -5068,7 +5068,7 @@ ensure_base_align (stmt_vec_info stmt_info, struct data_reference *dr)\n           DECL_ALIGN (base_decl) = TYPE_ALIGN (vectype);\n           DECL_USER_ALIGN (base_decl) = 1;\n \t}\n-      ((dataref_aux *)dr->aux)->base_misaligned = false;\n+      DR_VECT_AUX (dr)->base_misaligned = false;\n     }\n }\n \n@@ -5739,11 +5739,15 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t\tmisalign = 0;\n \t      else if (DR_MISALIGNMENT (first_dr) == -1)\n \t\t{\n+\t\t  if (DR_VECT_AUX (first_dr)->base_element_aligned)\n+\t\t    align = TYPE_ALIGN_UNIT (elem_type);\n+\t\t  else\n+\t\t    align = get_object_alignment (DR_REF (first_dr))\n+\t\t\t/ BITS_PER_UNIT;\n+\t\t  misalign = 0;\n \t\t  TREE_TYPE (data_ref)\n \t\t    = build_aligned_type (TREE_TYPE (data_ref),\n-\t\t\t\t\t  TYPE_ALIGN (elem_type));\n-\t\t  align = TYPE_ALIGN_UNIT (elem_type);\n-\t\t  misalign = 0;\n+\t\t\t\t\t  align * BITS_PER_UNIT);\n \t\t}\n \t      else\n \t\t{\n@@ -6824,11 +6828,15 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t\t      }\n \t\t    else if (DR_MISALIGNMENT (first_dr) == -1)\n \t\t      {\n+\t\t\tif (DR_VECT_AUX (first_dr)->base_element_aligned)\n+\t\t\t  align = TYPE_ALIGN_UNIT (elem_type);\n+\t\t\telse\n+\t\t\t  align = (get_object_alignment (DR_REF (first_dr))\n+\t\t\t\t   / BITS_PER_UNIT);\n+\t\t\tmisalign = 0;\n \t\t\tTREE_TYPE (data_ref)\n \t\t\t  = build_aligned_type (TREE_TYPE (data_ref),\n-\t\t\t\t\t\tTYPE_ALIGN (elem_type));\n-\t\t\talign = TYPE_ALIGN_UNIT (elem_type);\n-\t\t\tmisalign = 0;\n+\t\t\t\t\t\talign * BITS_PER_UNIT);\n \t\t      }\n \t\t    else\n \t\t      {"}, {"sha": "170dd186d315679494db3eba696f7ef75e9bc2f1", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52639a61657c667c68a4a3e0656a67ed1a95a9b0/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52639a61657c667c68a4a3e0656a67ed1a95a9b0/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=52639a61657c667c68a4a3e0656a67ed1a95a9b0", "patch": "@@ -707,11 +707,16 @@ typedef struct _stmt_vec_info {\n #define STMT_SLP_TYPE(S)                   (S)->slp_type\n \n struct dataref_aux {\n-  tree base_decl;\n-  bool base_misaligned;\n   int misalignment;\n+  /* If true the alignment of base_decl needs to be increased.  */\n+  bool base_misaligned;\n+  /* If true we know the base is at least vector element alignment aligned.  */\n+  bool base_element_aligned;\n+  tree base_decl;\n };\n \n+#define DR_VECT_AUX(dr) ((dataref_aux *)(dr)->aux)\n+\n #define VECT_MAX_COST 1000\n \n /* The maximum number of intermediate steps required in multi-step type\n@@ -910,14 +915,13 @@ destroy_cost_data (void *data)\n   targetm.vectorize.destroy_cost_data (data);\n }\n \n-\n /*-----------------------------------------------------------------*/\n /* Info on data references alignment.                              */\n /*-----------------------------------------------------------------*/\n inline void\n set_dr_misalignment (struct data_reference *dr, int val)\n {\n-  dataref_aux *data_aux = (dataref_aux *) dr->aux;\n+  dataref_aux *data_aux = DR_VECT_AUX (dr);\n \n   if (!data_aux)\n     {\n@@ -931,8 +935,7 @@ set_dr_misalignment (struct data_reference *dr, int val)\n inline int\n dr_misalignment (struct data_reference *dr)\n {\n-  gcc_assert (dr->aux);\n-  return ((dataref_aux *) dr->aux)->misalignment;\n+  return DR_VECT_AUX (dr)->misalignment;\n }\n \n /* Reflects actual alignment of first access in the vectorized loop,"}]}