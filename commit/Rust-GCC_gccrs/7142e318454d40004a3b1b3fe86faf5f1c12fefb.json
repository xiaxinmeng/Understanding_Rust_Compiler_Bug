{"sha": "7142e318454d40004a3b1b3fe86faf5f1c12fefb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzE0MmUzMTg0NTRkNDAwMDRhM2IxYjNmZTg2ZmFmNWYxYzEyZmVmYg==", "commit": {"author": {"name": "John Wehle", "email": "john@feith.com", "date": "2001-04-04T05:03:29Z"}, "committer": {"name": "John Wehle", "email": "wehle@gcc.gnu.org", "date": "2001-04-04T05:03:29Z"}, "message": "rtl.h (set_noop_p): Declare.\n\n\t* rtl.h (set_noop_p): Declare.\n\t* flow.c (set_noop_p): Move from here ...\n\t* rtlanal.c (set_noop_p): ... to here and enhance.\n\t* cse.c (delete_trivially_dead_insns): Use it.\n\t* gcse.c (hash_scan_set): Likewise.\n\t* jump.c (delete_noop_moves): Likewise.\n\t* recog.c (split_all_insns): Likewise.\n\nFrom-SVN: r41077", "tree": {"sha": "540dcb2ec38a4d7571f50545eadd91725b7f7b97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/540dcb2ec38a4d7571f50545eadd91725b7f7b97"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7142e318454d40004a3b1b3fe86faf5f1c12fefb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7142e318454d40004a3b1b3fe86faf5f1c12fefb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7142e318454d40004a3b1b3fe86faf5f1c12fefb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7142e318454d40004a3b1b3fe86faf5f1c12fefb/comments", "author": {"login": "jlwehle", "id": 46985578, "node_id": "MDQ6VXNlcjQ2OTg1NTc4", "avatar_url": "https://avatars.githubusercontent.com/u/46985578?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jlwehle", "html_url": "https://github.com/jlwehle", "followers_url": "https://api.github.com/users/jlwehle/followers", "following_url": "https://api.github.com/users/jlwehle/following{/other_user}", "gists_url": "https://api.github.com/users/jlwehle/gists{/gist_id}", "starred_url": "https://api.github.com/users/jlwehle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jlwehle/subscriptions", "organizations_url": "https://api.github.com/users/jlwehle/orgs", "repos_url": "https://api.github.com/users/jlwehle/repos", "events_url": "https://api.github.com/users/jlwehle/events{/privacy}", "received_events_url": "https://api.github.com/users/jlwehle/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0c918ce59cdb3039f78d82bf848a311cac7cc5a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c918ce59cdb3039f78d82bf848a311cac7cc5a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c918ce59cdb3039f78d82bf848a311cac7cc5a3"}], "stats": {"total": 106, "additions": 52, "deletions": 54}, "files": [{"sha": "d99ef4affcb95d17926dc40248a8c186445eacd5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7142e318454d40004a3b1b3fe86faf5f1c12fefb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7142e318454d40004a3b1b3fe86faf5f1c12fefb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7142e318454d40004a3b1b3fe86faf5f1c12fefb", "patch": "@@ -1,3 +1,13 @@\n+Wed Apr  4 00:45:38 EDT 2001  John Wehle  (john@feith.com)\n+\n+\t* rtl.h (set_noop_p): Declare.\n+\t* flow.c (set_noop_p): Move from here ...\n+\t* rtlanal.c (set_noop_p): ... to here and enhance.\n+\t* cse.c (delete_trivially_dead_insns): Use it.\n+\t* gcse.c (hash_scan_set): Likewise.\n+\t* jump.c (delete_noop_moves): Likewise.\n+\t* recog.c (split_all_insns): Likewise.\n+\n 2001-04-04  Alan Modra  <alan@linuxcare.com.au>\n \n \t* dwarf2out.c (dwarf2out_frame_debug_expr): Support adjusting"}, {"sha": "6913aef32b514be478147000bad96f82baaa1ef6", "filename": "gcc/cse.c", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7142e318454d40004a3b1b3fe86faf5f1c12fefb/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7142e318454d40004a3b1b3fe86faf5f1c12fefb/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=7142e318454d40004a3b1b3fe86faf5f1c12fefb", "patch": "@@ -7612,14 +7612,7 @@ delete_trivially_dead_insns (insns, nreg)\n \tlive_insn = ! dead_libcall;\n       else if (GET_CODE (PATTERN (insn)) == SET)\n \t{\n-\t  if ((GET_CODE (SET_DEST (PATTERN (insn))) == REG\n-\t       || GET_CODE (SET_DEST (PATTERN (insn))) == SUBREG)\n-\t      && rtx_equal_p (SET_DEST (PATTERN (insn)),\n-\t\t\t      SET_SRC (PATTERN (insn))))\n-\t    ;\n-\t  else if (GET_CODE (SET_DEST (PATTERN (insn))) == STRICT_LOW_PART\n-\t\t   && rtx_equal_p (XEXP (SET_DEST (PATTERN (insn)), 0),\n-\t\t\t\t   SET_SRC (PATTERN (insn))))\n+\t  if (set_noop_p (PATTERN (insn)))\n \t    ;\n \n #ifdef HAVE_cc0\n@@ -7649,9 +7642,7 @@ delete_trivially_dead_insns (insns, nreg)\n \n \t    if (GET_CODE (elt) == SET)\n \t      {\n-\t\tif ((GET_CODE (SET_DEST (elt)) == REG\n-\t\t     || GET_CODE (SET_DEST (elt)) == SUBREG)\n-\t\t    && rtx_equal_p (SET_DEST (elt), SET_SRC (elt)))\n+\t\tif (set_noop_p (elt))\n \t\t  ;\n \n #ifdef HAVE_cc0"}, {"sha": "607ecb6a11517792051d14dc3a733b6372a4555b", "filename": "gcc/flow.c", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7142e318454d40004a3b1b3fe86faf5f1c12fefb/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7142e318454d40004a3b1b3fe86faf5f1c12fefb/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=7142e318454d40004a3b1b3fe86faf5f1c12fefb", "patch": "@@ -386,7 +386,6 @@ static void tidy_fallthru_edges\t\tPARAMS ((void));\n static int verify_wide_reg_1\t\tPARAMS ((rtx *, void *));\n static void verify_wide_reg\t\tPARAMS ((int, rtx, rtx));\n static void verify_local_live_at_start\tPARAMS ((regset, basic_block));\n-static int set_noop_p\t\t\tPARAMS ((rtx));\n static int noop_move_p\t\t\tPARAMS ((rtx));\n static void delete_noop_moves\t\tPARAMS ((rtx));\n static void notice_stack_pointer_modification_1 PARAMS ((rtx, rtx, void *));\n@@ -3077,27 +3076,6 @@ free_basic_block_vars (keep_head_end_p)\n     }\n }\n \n-/* Return nonzero if the destination of SET equals the source.  */\n-\n-static int\n-set_noop_p (set)\n-     rtx set;\n-{\n-  rtx src = SET_SRC (set);\n-  rtx dst = SET_DEST (set);\n-\n-  if (GET_CODE (src) == SUBREG && GET_CODE (dst) == SUBREG)\n-    {\n-      if (SUBREG_BYTE (src) != SUBREG_BYTE (dst))\n-\treturn 0;\n-      src = SUBREG_REG (src);\n-      dst = SUBREG_REG (dst);\n-    }\n-\n-  return (GET_CODE (src) == REG && GET_CODE (dst) == REG\n-\t  && REGNO (src) == REGNO (dst));\n-}\n-\n /* Return nonzero if an insn consists only of SETs, each of which only sets a\n    value to itself.  */\n "}, {"sha": "9eda522e859e07d68de6f077f033112ac6eb9ce9", "filename": "gcc/gcse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7142e318454d40004a3b1b3fe86faf5f1c12fefb/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7142e318454d40004a3b1b3fe86faf5f1c12fefb/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=7142e318454d40004a3b1b3fe86faf5f1c12fefb", "patch": "@@ -1964,7 +1964,7 @@ hash_scan_set (pat, insn, set_p)\n \t  /* Is SET_SRC something we want to gcse?  */\n \t  && want_to_gcse_p (src)\n \t  /* Don't CSE a nop.  */\n-\t  && src != dest)\n+\t  && ! set_noop_p (pat))\n \t{\n \t  /* An expression is not anticipatable if its operands are\n \t     modified before this insn or if this is not the only SET in"}, {"sha": "6bd6edd9c4883e57d83b947817cab3eed420b8d3", "filename": "gcc/jump.c", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7142e318454d40004a3b1b3fe86faf5f1c12fefb/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7142e318454d40004a3b1b3fe86faf5f1c12fefb/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=7142e318454d40004a3b1b3fe86faf5f1c12fefb", "patch": "@@ -956,15 +956,7 @@ delete_noop_moves (f)\n \t  /* Detect and delete no-op move instructions\n \t     resulting from not allocating a parameter in a register.  */\n \n-\t  if (GET_CODE (body) == SET\n-\t      && (SET_DEST (body) == SET_SRC (body)\n-\t\t  || (GET_CODE (SET_DEST (body)) == MEM\n-\t\t      && GET_CODE (SET_SRC (body)) == MEM\n-\t\t      && rtx_equal_p (SET_SRC (body), SET_DEST (body))))\n-\t      && ! (GET_CODE (SET_DEST (body)) == MEM\n-\t\t    && MEM_VOLATILE_P (SET_DEST (body)))\n-\t      && ! (GET_CODE (SET_SRC (body)) == MEM\n-\t\t    && MEM_VOLATILE_P (SET_SRC (body))))\n+\t  if (GET_CODE (body) == SET && set_noop_p (body))\n \t    delete_computation (insn);\n \n \t  /* Detect and ignore no-op move instructions\n@@ -1073,16 +1065,6 @@ delete_noop_moves (f)\n \t      if (i < 0)\n \t\tdelete_insn (insn);\n \t    }\n-\t  /* Also delete insns to store bit fields if they are no-ops.  */\n-\t  /* Not worth the hair to detect this in the big-endian case.  */\n-\t  else if (! BYTES_BIG_ENDIAN\n-\t\t   && GET_CODE (body) == SET\n-\t\t   && GET_CODE (SET_DEST (body)) == ZERO_EXTRACT\n-\t\t   && XEXP (SET_DEST (body), 2) == const0_rtx\n-\t\t   && XEXP (SET_DEST (body), 0) == SET_SRC (body)\n-\t\t   && ! (GET_CODE (SET_SRC (body)) == MEM\n-\t\t\t && MEM_VOLATILE_P (SET_SRC (body))))\n-\t    delete_insn (insn);\n \t}\n       insn = next;\n     }"}, {"sha": "bc7c712de24816ef1deaae97b8251c6b2dc77ec0", "filename": "gcc/recog.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7142e318454d40004a3b1b3fe86faf5f1c12fefb/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7142e318454d40004a3b1b3fe86faf5f1c12fefb/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=7142e318454d40004a3b1b3fe86faf5f1c12fefb", "patch": "@@ -2882,7 +2882,7 @@ split_all_insns (upd_life)\n \t     break the code that handles REG_NO_CONFLICT blocks.  */\n \n \t  else if ((set = single_set (insn)) != NULL\n-\t\t   && rtx_equal_p (SET_SRC (set), SET_DEST (set)))\n+\t\t   && set_noop_p (set))\n \t    {\n \t      /* Nops get in the way while scheduling, so delete them\n \t\t now if register allocation has already been done.  It"}, {"sha": "02f37b75018e9b55994d1b06f73595270b5d22da", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7142e318454d40004a3b1b3fe86faf5f1c12fefb/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7142e318454d40004a3b1b3fe86faf5f1c12fefb/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=7142e318454d40004a3b1b3fe86faf5f1c12fefb", "patch": "@@ -1401,6 +1401,7 @@ extern int insn_dependent_p\t\tPARAMS ((rtx, rtx));\n extern int reg_set_p\t\t\tPARAMS ((rtx, rtx));\n extern rtx single_set_2\t\t\tPARAMS ((rtx, rtx));\n extern int multiple_sets\t\tPARAMS ((rtx));\n+extern int set_noop_p\t\t\tPARAMS ((rtx));\n extern rtx find_last_value\t\tPARAMS ((rtx, rtx *, rtx, int));\n extern int refers_to_regno_p\t\tPARAMS ((unsigned int, unsigned int,\n \t\t\t\t\t\t rtx, rtx *));"}, {"sha": "3dd7c138b0db2cd065a3b2fd2f46089d5b6f0ce6", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7142e318454d40004a3b1b3fe86faf5f1c12fefb/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7142e318454d40004a3b1b3fe86faf5f1c12fefb/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=7142e318454d40004a3b1b3fe86faf5f1c12fefb", "patch": "@@ -980,6 +980,42 @@ multiple_sets (insn)\n   return 0;\n }\n \f\n+/* Return nonzero if the destination of SET equals the source\n+   and there are no side effects.  */\n+\n+int\n+set_noop_p (set)\n+     rtx set;\n+{\n+  rtx src = SET_SRC (set);\n+  rtx dst = SET_DEST (set);\n+\n+  if (side_effects_p (src) || side_effects_p (dst))\n+    return 0;\n+\n+  if (GET_CODE (dst) == MEM && GET_CODE (src) == MEM)\n+    return rtx_equal_p (dst, src);\n+\n+  if (GET_CODE (dst) == SIGN_EXTRACT\n+      || GET_CODE (dst) == ZERO_EXTRACT)\n+    return rtx_equal_p (XEXP (dst, 0), src)\n+\t   && ! BYTES_BIG_ENDIAN && XEXP (dst, 2) == const0_rtx;\n+\n+  if (GET_CODE (dst) == STRICT_LOW_PART)\n+    dst = XEXP (dst, 0);\n+\n+  if (GET_CODE (src) == SUBREG && GET_CODE (dst) == SUBREG)\n+    {\n+      if (SUBREG_BYTE (src) != SUBREG_BYTE (dst))\n+\treturn 0;\n+      src = SUBREG_REG (src);\n+      dst = SUBREG_REG (dst);\n+    }\n+\n+  return (GET_CODE (src) == REG && GET_CODE (dst) == REG\n+\t  && REGNO (src) == REGNO (dst));\n+}\n+\n /* Return the last thing that X was assigned from before *PINSN.  If VALID_TO\n    is not NULL_RTX then verify that the object is not modified up to VALID_TO.\n    If the object was modified, if we hit a partial assignment to X, or hit a"}]}