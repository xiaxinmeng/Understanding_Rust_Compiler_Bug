{"sha": "03dfc36daf0f94adc8eee3f8ddb88be5f3c4e576", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDNkZmMzNmRhZjBmOTRhZGM4ZWVlM2Y4ZGRiODhiZTVmM2M0ZTU3Ng==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2011-04-13T17:26:50Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2011-04-13T17:26:50Z"}, "message": "ipa-inline.h: New file.\n\n\t* ipa-inline.h: New file.\n\t* ipa-inline-analysis.c: New file. Broken out of ...\n\t* ipa-inline.c: ... this file; update toplevel comment;\n\tinclude ipa-inline.h\n\t(inline_summary): Move to ipa-inline.h\n\t(cgraph_estimate_edge_time): Rename to estimate_edge_time; move to\n\tipa-inline-analysis.c.\n\t(cgraph_estimate_time_after_inlining): Rename to estiamte_time_after_inlining;\n\tmove to ipa-inline-analysis.c\n\t(cgraph_estimate_edge_growth): Move to ipa-inline-analysis.c; rename\n\tto estimate_edge_growth.\n\t(cgraph_estimate_size_after_inlining): Move to ipa-inline-analysis.c;\n\trename to estimate_size_after_inlining.\n\t(cgraph_mark_inline_edge): Update for new naming convention.\n\t(cgraph_check_inline_limits): Likewise.\n\t(cgraph_edge_badness): Likewise.\n\t(cgraph_decide_recursive_inlining): Likewise.\n\t(cgraph_decide_inlining_of_small_functions): Likewise.\n\t(cgraph_decide_inlining_incrementally): Likewise.\n\t(cgraph_estimate_growth): Rename to estimate_growth; move to ipa-inline-analysis.c.\n\t(eliminated_by_inlining_prob): Move to ipa-inline-analysis.c.\n\t(estimate_function_body_sizes): Move to ipa-inline-analysis.c.\n\t(compute_inline_parameters): Likewise.\n\t(compute_inline_parameters_for_current): Likewise.\n\t(pass_inline_parameters): Likewise.\n\t(inline_indirect_intraprocedural_analysis): Likewise.\n\t(analyze_function): Rename to inline_analyze_function; likewise.\n\t(add_new_function): Move to ipa-inline-analysis.c.\n\t(inline_generate_summary): Likewise.\n\t(inline_read_summary): Likewise.\n\t(inline_write_summary): Likewise.\n\t* Makefile.in (ipa-inline-analysis.c): New file.\n\nFrom-SVN: r172388", "tree": {"sha": "70e379a6f9ceffd51efd849ff820056e3148cba8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/70e379a6f9ceffd51efd849ff820056e3148cba8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/03dfc36daf0f94adc8eee3f8ddb88be5f3c4e576", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03dfc36daf0f94adc8eee3f8ddb88be5f3c4e576", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03dfc36daf0f94adc8eee3f8ddb88be5f3c4e576", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03dfc36daf0f94adc8eee3f8ddb88be5f3c4e576/comments", "author": null, "committer": null, "parents": [{"sha": "7673c9623fa59ec8bcf9262af306a485905a35e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7673c9623fa59ec8bcf9262af306a485905a35e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7673c9623fa59ec8bcf9262af306a485905a35e4"}], "stats": {"total": 1036, "additions": 593, "deletions": 443}, "files": [{"sha": "4347718324944b8c20045f3f9eed1ada06173e29", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03dfc36daf0f94adc8eee3f8ddb88be5f3c4e576/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03dfc36daf0f94adc8eee3f8ddb88be5f3c4e576/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=03dfc36daf0f94adc8eee3f8ddb88be5f3c4e576", "patch": "@@ -1,3 +1,38 @@\n+2011-04-13  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa-inline.h: New file.\n+\t* ipa-inline-analysis.c: New file. Broken out of ...\n+\t* ipa-inline.c: ... this file; update toplevel comment;\n+\tinclude ipa-inline.h\n+\t(inline_summary): Move to ipa-inline.h\n+\t(cgraph_estimate_edge_time): Rename to estimate_edge_time; move to\n+\tipa-inline-analysis.c.\n+\t(cgraph_estimate_time_after_inlining): Rename to estiamte_time_after_inlining;\n+\tmove to ipa-inline-analysis.c\n+\t(cgraph_estimate_edge_growth): Move to ipa-inline-analysis.c; rename\n+\tto estimate_edge_growth.\n+\t(cgraph_estimate_size_after_inlining): Move to ipa-inline-analysis.c;\n+\trename to estimate_size_after_inlining.\n+\t(cgraph_mark_inline_edge): Update for new naming convention.\n+\t(cgraph_check_inline_limits): Likewise.\n+\t(cgraph_edge_badness): Likewise.\n+\t(cgraph_decide_recursive_inlining): Likewise.\n+\t(cgraph_decide_inlining_of_small_functions): Likewise.\n+\t(cgraph_decide_inlining_incrementally): Likewise.\n+\t(cgraph_estimate_growth): Rename to estimate_growth; move to ipa-inline-analysis.c.\n+\t(eliminated_by_inlining_prob): Move to ipa-inline-analysis.c.\n+\t(estimate_function_body_sizes): Move to ipa-inline-analysis.c.\n+\t(compute_inline_parameters): Likewise.\n+\t(compute_inline_parameters_for_current): Likewise.\n+\t(pass_inline_parameters): Likewise.\n+\t(inline_indirect_intraprocedural_analysis): Likewise.\n+\t(analyze_function): Rename to inline_analyze_function; likewise.\n+\t(add_new_function): Move to ipa-inline-analysis.c.\n+\t(inline_generate_summary): Likewise.\n+\t(inline_read_summary): Likewise.\n+\t(inline_write_summary): Likewise.\n+\t* Makefile.in (ipa-inline-analysis.c): New file.\n+\n 2011-04-13  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* configure.ac (gcc_cv_as_sparc_gotdata_op): Remove GNU ld check."}, {"sha": "1a0d98d2625167208de636f5cae50a7427bac936", "filename": "gcc/Makefile.in", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03dfc36daf0f94adc8eee3f8ddb88be5f3c4e576/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03dfc36daf0f94adc8eee3f8ddb88be5f3c4e576/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=03dfc36daf0f94adc8eee3f8ddb88be5f3c4e576", "patch": "@@ -1468,6 +1468,7 @@ OBJS-archive = \\\n \tipa-cp.o \\\n         ipa-split.o \\\n \tipa-inline.o \\\n+\tipa-inline-analysis.o \\\n \tipa-prop.o \\\n \tipa-pure-const.o \\\n \tipa-reference.o \\\n@@ -3026,7 +3027,12 @@ ipa-inline.o : ipa-inline.c gt-ipa-inline.h $(CONFIG_H) $(SYSTEM_H) coretypes.h\n    $(TREE_H) langhooks.h $(TREE_INLINE_H) $(FLAGS_H) $(CGRAPH_H) intl.h \\\n    $(DIAGNOSTIC_H) $(FIBHEAP_H) $(PARAMS_H) $(TIMEVAR_H) $(TREE_PASS_H) \\\n    $(HASHTAB_H) $(COVERAGE_H) $(GGC_H) $(TREE_FLOW_H) $(RTL_H) $(IPA_PROP_H) \\\n-   $(EXCEPT_H) gimple-pretty-print.h\n+   $(EXCEPT_H) gimple-pretty-print.h ipa-inline.h\n+ipa-inline-analysis.o : ipa-inline-analysis.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n+   $(TREE_H) langhooks.h $(TREE_INLINE_H) $(FLAGS_H) $(CGRAPH_H) intl.h \\\n+   $(DIAGNOSTIC_H) $(PARAMS_H) $(TIMEVAR_H) $(TREE_PASS_H) \\\n+   $(HASHTAB_H) $(COVERAGE_H) $(GGC_H) $(TREE_FLOW_H) $(IPA_PROP_H) \\\n+   gimple-pretty-print.h ipa-inline.h\n ipa-utils.o : ipa-utils.c $(IPA_UTILS_H) $(CONFIG_H) $(SYSTEM_H) \\\n    coretypes.h $(TM_H) $(TREE_H) $(TREE_FLOW_H) $(TREE_INLINE_H) langhooks.h \\\n    pointer-set.h $(GGC_H) $(GIMPLE_H) $(SPLAY_TREE_H) \\"}, {"sha": "8507c5e27d78170ee181ce569451daa4924956a5", "filename": "gcc/ipa-inline-analysis.c", "status": "added", "additions": 481, "deletions": 0, "changes": 481, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03dfc36daf0f94adc8eee3f8ddb88be5f3c4e576/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03dfc36daf0f94adc8eee3f8ddb88be5f3c4e576/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=03dfc36daf0f94adc8eee3f8ddb88be5f3c4e576", "patch": "@@ -0,0 +1,481 @@\n+/* Inlining decision heuristics.\n+   Copyright (C) 2003, 2004, 2007, 2008, 2009, 2010, 2011\n+   Free Software Foundation, Inc.\n+   Contributed by Jan Hubicka\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* Analysis used by the inliner and other passes limiting code size growth.\n+\n+   We estimate for each function\n+     - function body size\n+     - function runtime\n+     - inlining size benefit (that is how much of function body size\n+       and its call sequence is expected to disappear by inlining)\n+     - inlining time benefit\n+     - function frame size\n+   For each call\n+     - call sequence size\n+\n+   inlinie_summary datastructures store above information locally (i.e.\n+   parameters of the function itself) and globally (i.e. parameters of\n+   the function created by applying all the inline decisions already\n+   present in the callgraph).\n+\n+   We also provide accestor to the inline_summary datastructure and\n+   basic logic updating the parameters when inlining is performed. \n+\n+   Finally pass_inline_parameters is exported.  This is used to drive\n+   computation of function parameters used by the early inliner. IPA\n+   inlined performs analysis via its analyze_function method. */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"tree-inline.h\"\n+#include \"langhooks.h\"\n+#include \"flags.h\"\n+#include \"cgraph.h\"\n+#include \"diagnostic.h\"\n+#include \"gimple-pretty-print.h\"\n+#include \"timevar.h\"\n+#include \"params.h\"\n+#include \"tree-pass.h\"\n+#include \"coverage.h\"\n+#include \"ggc.h\"\n+#include \"tree-flow.h\"\n+#include \"ipa-prop.h\"\n+#include \"ipa-inline.h\"\n+\n+#define MAX_TIME 1000000000\n+\n+/* Holders of ipa cgraph hooks: */\n+static struct cgraph_node_hook_list *function_insertion_hook_holder;\n+\n+/* See if statement might disappear after inlining.\n+   0 - means not eliminated\n+   1 - half of statements goes away\n+   2 - for sure it is eliminated.\n+   We are not terribly sophisticated, basically looking for simple abstraction\n+   penalty wrappers.  */\n+\n+static int\n+eliminated_by_inlining_prob (gimple stmt)\n+{\n+  enum gimple_code code = gimple_code (stmt);\n+  switch (code)\n+    {\n+      case GIMPLE_RETURN:\n+        return 2;\n+      case GIMPLE_ASSIGN:\n+\tif (gimple_num_ops (stmt) != 2)\n+\t  return 0;\n+\n+\t/* Casts of parameters, loads from parameters passed by reference\n+\t   and stores to return value or parameters are often free after\n+\t   inlining dua to SRA and further combining.\n+\t   Assume that half of statements goes away.  */\n+\tif (gimple_assign_rhs_code (stmt) == CONVERT_EXPR\n+\t    || gimple_assign_rhs_code (stmt) == NOP_EXPR\n+\t    || gimple_assign_rhs_code (stmt) == VIEW_CONVERT_EXPR\n+\t    || gimple_assign_rhs_class (stmt) == GIMPLE_SINGLE_RHS)\n+\t  {\n+\t    tree rhs = gimple_assign_rhs1 (stmt);\n+            tree lhs = gimple_assign_lhs (stmt);\n+\t    tree inner_rhs = rhs;\n+\t    tree inner_lhs = lhs;\n+\t    bool rhs_free = false;\n+\t    bool lhs_free = false;\n+\n+ \t    while (handled_component_p (inner_lhs)\n+\t\t   || TREE_CODE (inner_lhs) == MEM_REF)\n+\t      inner_lhs = TREE_OPERAND (inner_lhs, 0);\n+ \t    while (handled_component_p (inner_rhs)\n+\t           || TREE_CODE (inner_rhs) == ADDR_EXPR\n+\t\t   || TREE_CODE (inner_rhs) == MEM_REF)\n+\t      inner_rhs = TREE_OPERAND (inner_rhs, 0);\n+\n+\n+\t    if (TREE_CODE (inner_rhs) == PARM_DECL\n+\t        || (TREE_CODE (inner_rhs) == SSA_NAME\n+\t\t    && SSA_NAME_IS_DEFAULT_DEF (inner_rhs)\n+\t\t    && TREE_CODE (SSA_NAME_VAR (inner_rhs)) == PARM_DECL))\n+\t      rhs_free = true;\n+\t    if (rhs_free && is_gimple_reg (lhs))\n+\t      lhs_free = true;\n+\t    if (((TREE_CODE (inner_lhs) == PARM_DECL\n+\t          || (TREE_CODE (inner_lhs) == SSA_NAME\n+\t\t      && SSA_NAME_IS_DEFAULT_DEF (inner_lhs)\n+\t\t      && TREE_CODE (SSA_NAME_VAR (inner_lhs)) == PARM_DECL))\n+\t\t && inner_lhs != lhs)\n+\t        || TREE_CODE (inner_lhs) == RESULT_DECL\n+\t        || (TREE_CODE (inner_lhs) == SSA_NAME\n+\t\t    && TREE_CODE (SSA_NAME_VAR (inner_lhs)) == RESULT_DECL))\n+\t      lhs_free = true;\n+\t    if (lhs_free\n+\t\t&& (is_gimple_reg (rhs) || is_gimple_min_invariant (rhs)))\n+\t      rhs_free = true;\n+\t    if (lhs_free && rhs_free)\n+\t      return 1;\n+\t  }\n+\treturn 0;\n+      default:\n+\treturn 0;\n+    }\n+}\n+\n+\n+/* Compute function body size parameters for NODE.  */\n+\n+static void\n+estimate_function_body_sizes (struct cgraph_node *node)\n+{\n+  gcov_type time = 0;\n+  gcov_type time_inlining_benefit = 0;\n+  /* Estimate static overhead for function prologue/epilogue and alignment. */\n+  int size = 2;\n+  /* Benefits are scaled by probability of elimination that is in range\n+     <0,2>.  */\n+  int size_inlining_benefit = 2 * 2;\n+  basic_block bb;\n+  gimple_stmt_iterator bsi;\n+  struct function *my_function = DECL_STRUCT_FUNCTION (node->decl);\n+  int freq;\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"Analyzing function body size: %s\\n\",\n+\t     cgraph_node_name (node));\n+\n+  gcc_assert (my_function && my_function->cfg);\n+  FOR_EACH_BB_FN (bb, my_function)\n+    {\n+      freq = compute_call_stmt_bb_frequency (node->decl, bb);\n+      for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n+\t{\n+\t  gimple stmt = gsi_stmt (bsi);\n+\t  int this_size = estimate_num_insns (stmt, &eni_size_weights);\n+\t  int this_time = estimate_num_insns (stmt, &eni_time_weights);\n+\t  int prob;\n+\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"  freq:%6i size:%3i time:%3i \",\n+\t\t       freq, this_size, this_time);\n+\t      print_gimple_stmt (dump_file, stmt, 0, 0);\n+\t    }\n+\t  this_time *= freq;\n+\t  time += this_time;\n+\t  size += this_size;\n+\t  prob = eliminated_by_inlining_prob (stmt);\n+\t  if (prob == 1 && dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"    50%% will be eliminated by inlining\\n\");\n+\t  if (prob == 2 && dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"    will eliminated by inlining\\n\");\n+\t  size_inlining_benefit += this_size * prob;\n+\t  time_inlining_benefit += this_time * prob;\n+\t  gcc_assert (time >= 0);\n+\t  gcc_assert (size >= 0);\n+\t}\n+    }\n+  time = (time + CGRAPH_FREQ_BASE / 2) / CGRAPH_FREQ_BASE;\n+  time_inlining_benefit = ((time_inlining_benefit + CGRAPH_FREQ_BASE)\n+  \t\t\t   / (CGRAPH_FREQ_BASE * 2));\n+  size_inlining_benefit = (size_inlining_benefit + 1) / 2;\n+  if (time_inlining_benefit > MAX_TIME)\n+    time_inlining_benefit = MAX_TIME;\n+  if (time > MAX_TIME)\n+    time = MAX_TIME;\n+  if (dump_file)\n+    fprintf (dump_file, \"Overall function body time: %i-%i size: %i-%i\\n\",\n+\t     (int)time, (int)time_inlining_benefit,\n+\t     size, size_inlining_benefit);\n+  inline_summary (node)->self_time = time;\n+  inline_summary (node)->self_size = size;\n+  inline_summary (node)->time_inlining_benefit = time_inlining_benefit;\n+  inline_summary (node)->size_inlining_benefit = size_inlining_benefit;\n+}\n+\n+\n+/* Compute parameters of functions used by inliner.  */\n+\n+void\n+compute_inline_parameters (struct cgraph_node *node)\n+{\n+  HOST_WIDE_INT self_stack_size;\n+  struct cgraph_edge *e;\n+\n+  gcc_assert (!node->global.inlined_to);\n+\n+  /* Estimate the stack size for the function if we're optimizing.  */\n+  self_stack_size = optimize ? estimated_stack_frame_size (node) : 0;\n+  inline_summary (node)->estimated_self_stack_size = self_stack_size;\n+  node->global.estimated_stack_size = self_stack_size;\n+  node->global.stack_frame_offset = 0;\n+\n+  /* Can this function be inlined at all?  */\n+  node->local.inlinable = tree_inlinable_function_p (node->decl);\n+  if (!node->local.inlinable)\n+    node->local.disregard_inline_limits = 0;\n+\n+  /* Inlinable functions always can change signature.  */\n+  if (node->local.inlinable)\n+    node->local.can_change_signature = true;\n+  else\n+    {\n+      /* Functions calling builtin_apply can not change signature.  */\n+      for (e = node->callees; e; e = e->next_callee)\n+\tif (DECL_BUILT_IN (e->callee->decl)\n+\t    && DECL_BUILT_IN_CLASS (e->callee->decl) == BUILT_IN_NORMAL\n+\t    && DECL_FUNCTION_CODE (e->callee->decl) == BUILT_IN_APPLY_ARGS)\n+\t  break;\n+      node->local.can_change_signature = !e;\n+    }\n+  estimate_function_body_sizes (node);\n+  /* Compute size of call statements.  We have to do this for callers here,\n+     those sizes need to be present for edges _to_ us as early as\n+     we are finished with early opts.  */\n+  for (e = node->callers; e; e = e->next_caller)\n+    if (e->call_stmt)\n+      {\n+\te->call_stmt_size\n+\t  = estimate_num_insns (e->call_stmt, &eni_size_weights);\n+\te->call_stmt_time\n+\t  = estimate_num_insns (e->call_stmt, &eni_time_weights);\n+      }\n+  /* Inlining characteristics are maintained by the cgraph_mark_inline.  */\n+  node->global.time = inline_summary (node)->self_time;\n+  node->global.size = inline_summary (node)->self_size;\n+}\n+\n+\n+/* Compute parameters of functions used by inliner using\n+   current_function_decl.  */\n+\n+static unsigned int\n+compute_inline_parameters_for_current (void)\n+{\n+  compute_inline_parameters (cgraph_get_node (current_function_decl));\n+  return 0;\n+}\n+\n+struct gimple_opt_pass pass_inline_parameters =\n+{\n+ {\n+  GIMPLE_PASS,\n+  \"inline_param\",\t\t\t/* name */\n+  NULL,\t\t\t\t\t/* gate */\n+  compute_inline_parameters_for_current,/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  TV_INLINE_HEURISTICS,\t\t\t/* tv_id */\n+  0,\t                                /* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  0\t\t\t\t\t/* todo_flags_finish */\n+ }\n+};\n+\n+\n+/* Estimate the time cost for the caller when inlining EDGE.  */\n+\n+static inline int\n+estimate_edge_time (struct cgraph_edge *edge)\n+{\n+  int call_stmt_time;\n+  /* ???  We throw away cgraph edges all the time so the information\n+     we store in edges doesn't persist for early inlining.  Ugh.  */\n+  if (!edge->call_stmt)\n+    call_stmt_time = edge->call_stmt_time;\n+  else\n+    call_stmt_time = estimate_num_insns (edge->call_stmt, &eni_time_weights);\n+  return (((gcov_type)edge->callee->global.time\n+\t   - inline_summary (edge->callee)->time_inlining_benefit\n+\t   - call_stmt_time) * edge->frequency\n+\t  + CGRAPH_FREQ_BASE / 2) / CGRAPH_FREQ_BASE;\n+}\n+\n+\n+/* Estimate self time of the function NODE after inlining EDGE.  */\n+\n+int\n+estimate_time_after_inlining (struct cgraph_node *node,\n+\t\t\t      struct cgraph_edge *edge)\n+{\n+  gcov_type time = node->global.time + estimate_edge_time (edge);\n+  if (time < 0)\n+    time = 0;\n+  if (time > MAX_TIME)\n+    time = MAX_TIME;\n+  return time;\n+}\n+\n+\n+/* Estimate the size of NODE after inlining EDGE which should be an\n+   edge to either NODE or a call inlined into NODE.  */\n+\n+int\n+estimate_size_after_inlining (struct cgraph_node *node,\n+\t\t\t\t     struct cgraph_edge *edge)\n+{\n+  int size = node->global.size + estimate_edge_growth (edge);\n+  gcc_assert (size >= 0);\n+  return size;\n+}\n+\n+\n+/* Estimate the growth caused by inlining NODE into all callees.  */\n+\n+int\n+estimate_growth (struct cgraph_node *node)\n+{\n+  int growth = 0;\n+  struct cgraph_edge *e;\n+  bool self_recursive = false;\n+\n+  if (node->global.estimated_growth != INT_MIN)\n+    return node->global.estimated_growth;\n+\n+  for (e = node->callers; e; e = e->next_caller)\n+    {\n+      if (e->caller == node)\n+        self_recursive = true;\n+      if (e->inline_failed)\n+\tgrowth += estimate_edge_growth (e);\n+    }\n+\n+  /* ??? Wrong for non-trivially self recursive functions or cases where\n+     we decide to not inline for different reasons, but it is not big deal\n+     as in that case we will keep the body around, but we will also avoid\n+     some inlining.  */\n+  if (cgraph_will_be_removed_from_program_if_no_direct_calls (node)\n+      && !DECL_EXTERNAL (node->decl) && !self_recursive)\n+    growth -= node->global.size;\n+  /* COMDAT functions are very often not shared across multiple units since they\n+     come from various template instantiations.  Take this into account.  */\n+  else  if (DECL_COMDAT (node->decl) && !self_recursive\n+\t    && cgraph_can_remove_if_no_direct_calls_p (node))\n+    growth -= (node->global.size\n+\t       * (100 - PARAM_VALUE (PARAM_COMDAT_SHARING_PROBABILITY)) + 50) / 100;\n+\n+  node->global.estimated_growth = growth;\n+  return growth;\n+}\n+\n+/* This function performs intraprocedural analysis in NODE that is required to\n+   inline indirect calls.  */\n+static void\n+inline_indirect_intraprocedural_analysis (struct cgraph_node *node)\n+{\n+  ipa_analyze_node (node);\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      ipa_print_node_params (dump_file, node);\n+      ipa_print_node_jump_functions (dump_file, node);\n+    }\n+}\n+\n+\n+/* Note function body size.  */\n+\n+static void\n+inline_analyze_function (struct cgraph_node *node)\n+{\n+  push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n+  current_function_decl = node->decl;\n+\n+  compute_inline_parameters (node);\n+  /* FIXME: We should remove the optimize check after we ensure we never run\n+     IPA passes when not optimizing.  */\n+  if (flag_indirect_inlining && optimize)\n+    inline_indirect_intraprocedural_analysis (node);\n+\n+  current_function_decl = NULL;\n+  pop_cfun ();\n+}\n+\n+\n+/* Called when new function is inserted to callgraph late.  */\n+\n+static void\n+add_new_function (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n+{\n+  inline_analyze_function (node);\n+}\n+\n+\n+/* Note function body size.  */\n+\n+void\n+inline_generate_summary (void)\n+{\n+  struct cgraph_node *node;\n+\n+  function_insertion_hook_holder =\n+      cgraph_add_function_insertion_hook (&add_new_function, NULL);\n+\n+  if (flag_indirect_inlining)\n+    ipa_register_cgraph_hooks ();\n+\n+  for (node = cgraph_nodes; node; node = node->next)\n+    if (node->analyzed)\n+      inline_analyze_function (node);\n+\n+  return;\n+}\n+\n+\n+/* Read inline summary.  Jump functions are shared among ipa-cp\n+   and inliner, so when ipa-cp is active, we don't need to write them\n+   twice.  */\n+\n+void\n+inline_read_summary (void)\n+{\n+  if (flag_indirect_inlining)\n+    {\n+      ipa_register_cgraph_hooks ();\n+      if (!flag_ipa_cp)\n+        ipa_prop_read_jump_functions ();\n+    }\n+  function_insertion_hook_holder =\n+      cgraph_add_function_insertion_hook (&add_new_function, NULL);\n+}\n+\n+\n+/* Write inline summary for node in SET.\n+   Jump functions are shared among ipa-cp and inliner, so when ipa-cp is\n+   active, we don't need to write them twice.  */\n+\n+void\n+inline_write_summary (cgraph_node_set set,\n+\t\t      varpool_node_set vset ATTRIBUTE_UNUSED)\n+{\n+  if (flag_indirect_inlining && !flag_ipa_cp)\n+    ipa_prop_write_jump_functions (set);\n+}\n+\n+/* Release inline summary.  */\n+\n+void\n+inline_free_summary (void)\n+{\n+  cgraph_remove_function_insertion_hook (function_insertion_hook_holder);\n+}"}, {"sha": "36bc1c2dbd65cffa16fdeade95d7003708d28e0b", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 18, "deletions": 442, "changes": 460, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03dfc36daf0f94adc8eee3f8ddb88be5f3c4e576/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03dfc36daf0f94adc8eee3f8ddb88be5f3c4e576/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=03dfc36daf0f94adc8eee3f8ddb88be5f3c4e576", "patch": "@@ -63,18 +63,7 @@ along with GCC; see the file COPYING3.  If not see\n       into account, while cgraph_decide_inlining_incrementally considers\n       only one function at a time and is used by early inliner.\n \n-   The inliner itself is split into several passes:\n-\n-   pass_inline_parameters\n-\n-     This pass computes local properties of functions that are used by inliner:\n-     estimated function body size, whether function is inlinable at all and\n-     stack frame consumption.\n-\n-     Before executing any of inliner passes, this local pass has to be applied\n-     to each function in the callgraph (ie run as subpass of some earlier\n-     IPA pass).  The results are made out of date by any optimization applied\n-     on the function body.\n+   The inliner itself is split into two passes:\n \n    pass_early_inlining\n \n@@ -123,6 +112,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"rtl.h\"\n #include \"ipa-prop.h\"\n #include \"except.h\"\n+#include \"ipa-inline.h\"\n \n #define MAX_TIME 1000000000\n \n@@ -133,76 +123,6 @@ static int nfunctions_inlined;\n static int overall_size;\n static gcov_type max_count, max_benefit;\n \n-/* Holders of ipa cgraph hooks: */\n-static struct cgraph_node_hook_list *function_insertion_hook_holder;\n-\n-static inline struct inline_summary *\n-inline_summary (struct cgraph_node *node)\n-{\n-  return &node->local.inline_summary;\n-}\n-\n-/* Estimate the time cost for the caller when inlining EDGE.  */\n-\n-static inline int\n-cgraph_estimate_edge_time (struct cgraph_edge *edge)\n-{\n-  int call_stmt_time;\n-  /* ???  We throw away cgraph edges all the time so the information\n-     we store in edges doesn't persist for early inlining.  Ugh.  */\n-  if (!edge->call_stmt)\n-    call_stmt_time = edge->call_stmt_time;\n-  else\n-    call_stmt_time = estimate_num_insns (edge->call_stmt, &eni_time_weights);\n-  return (((gcov_type)edge->callee->global.time\n-\t   - inline_summary (edge->callee)->time_inlining_benefit\n-\t   - call_stmt_time) * edge->frequency\n-\t  + CGRAPH_FREQ_BASE / 2) / CGRAPH_FREQ_BASE;\n-}\n-\n-/* Estimate self time of the function NODE after inlining EDGE.  */\n-\n-static int\n-cgraph_estimate_time_after_inlining (struct cgraph_node *node,\n-\t\t\t\t     struct cgraph_edge *edge)\n-{\n-  gcov_type time = node->global.time + cgraph_estimate_edge_time (edge);\n-  if (time < 0)\n-    time = 0;\n-  if (time > MAX_TIME)\n-    time = MAX_TIME;\n-  return time;\n-}\n-\n-/* Estimate the growth of the caller when inlining EDGE.  */\n-\n-static inline int\n-cgraph_estimate_edge_growth (struct cgraph_edge *edge)\n-{\n-  int call_stmt_size;\n-  /* ???  We throw away cgraph edges all the time so the information\n-     we store in edges doesn't persist for early inlining.  Ugh.  */\n-  if (!edge->call_stmt)\n-    call_stmt_size = edge->call_stmt_size;\n-  else\n-    call_stmt_size = estimate_num_insns (edge->call_stmt, &eni_size_weights);\n-  return (edge->callee->global.size\n-\t  - inline_summary (edge->callee)->size_inlining_benefit\n-\t  - call_stmt_size);\n-}\n-\n-/* Estimate the size of NODE after inlining EDGE which should be an\n-   edge to either NODE or a call inlined into NODE.  */\n-\n-static inline int\n-cgraph_estimate_size_after_inlining (struct cgraph_node *node,\n-\t\t\t\t     struct cgraph_edge *edge)\n-{\n-  int size = node->global.size + cgraph_estimate_edge_growth (edge);\n-  gcc_assert (size >= 0);\n-  return size;\n-}\n-\n /* Scale frequency of NODE edges by FREQ_SCALE and increase loop nest\n    by NEST.  */\n \n@@ -329,9 +249,9 @@ cgraph_mark_inline_edge (struct cgraph_edge *e, bool update_original,\n     {\n       to = e->caller;\n       old_size = e->caller->global.size;\n-      new_size = cgraph_estimate_size_after_inlining (to, curr);\n+      new_size = estimate_size_after_inlining (to, curr);\n       to->global.size = new_size;\n-      to->global.time = cgraph_estimate_time_after_inlining (to, curr);\n+      to->global.time = estimate_time_after_inlining (to, curr);\n     }\n   gcc_assert (curr->callee->global.inlined_to == to);\n   if (new_size > old_size)\n@@ -346,44 +266,6 @@ cgraph_mark_inline_edge (struct cgraph_edge *e, bool update_original,\n     return false;\n }\n \n-/* Estimate the growth caused by inlining NODE into all callees.  */\n-\n-static int\n-cgraph_estimate_growth (struct cgraph_node *node)\n-{\n-  int growth = 0;\n-  struct cgraph_edge *e;\n-  bool self_recursive = false;\n-\n-  if (node->global.estimated_growth != INT_MIN)\n-    return node->global.estimated_growth;\n-\n-  for (e = node->callers; e; e = e->next_caller)\n-    {\n-      if (e->caller == node)\n-        self_recursive = true;\n-      if (e->inline_failed)\n-\tgrowth += cgraph_estimate_edge_growth (e);\n-    }\n-\n-  /* ??? Wrong for non-trivially self recursive functions or cases where\n-     we decide to not inline for different reasons, but it is not big deal\n-     as in that case we will keep the body around, but we will also avoid\n-     some inlining.  */\n-  if (cgraph_will_be_removed_from_program_if_no_direct_calls (node)\n-      && !DECL_EXTERNAL (node->decl) && !self_recursive)\n-    growth -= node->global.size;\n-  /* COMDAT functions are very often not shared across multiple units since they\n-     come from various template instantiations.  Take this into account.  */\n-  else  if (DECL_COMDAT (node->decl) && !self_recursive\n-\t    && cgraph_can_remove_if_no_direct_calls_p (node))\n-    growth -= (node->global.size\n-\t       * (100 - PARAM_VALUE (PARAM_COMDAT_SHARING_PROBABILITY)) + 50) / 100;\n-\n-  node->global.estimated_growth = growth;\n-  return growth;\n-}\n-\n /* Return false when inlining edge E is not good idea\n    as it would cause too large growth of the callers function body\n    or stack frame size.  *REASON if non-NULL is updated if the\n@@ -413,7 +295,7 @@ cgraph_check_inline_limits (struct cgraph_edge *e,\n \n   /* Check the size after inlining against the function limits.  But allow\n      the function to shrink if it went over the limits by forced inlining.  */\n-  newsize = cgraph_estimate_size_after_inlining (to, e);\n+  newsize = estimate_size_after_inlining (to, e);\n   if (newsize >= to->global.size\n       && newsize > PARAM_VALUE (PARAM_LARGE_FUNCTION_INSNS)\n       && newsize > limit)\n@@ -507,7 +389,7 @@ cgraph_edge_badness (struct cgraph_edge *edge, bool dump)\n   if (edge->callee->local.disregard_inline_limits)\n     return INT_MIN;\n \n-  growth = cgraph_estimate_edge_growth (edge);\n+  growth = estimate_edge_growth (edge);\n \n   if (dump)\n     {\n@@ -585,7 +467,7 @@ cgraph_edge_badness (struct cgraph_edge *edge, bool dump)\n \tdiv = 1;\n       if (badness > 0)\n \tbadness /= div;\n-      growth_for_all = cgraph_estimate_growth (edge->callee);\n+      growth_for_all = estimate_growth (edge->callee);\n       badness += growth_for_all;\n       if (badness > INT_MAX)\n \tbadness = INT_MAX;\n@@ -604,7 +486,7 @@ cgraph_edge_badness (struct cgraph_edge *edge, bool dump)\n   else\n     {\n       int nest = MIN (edge->loop_nest, 8);\n-      badness = cgraph_estimate_growth (edge->callee) * 256;\n+      badness = estimate_growth (edge->callee) * 256;\n \n       /* Decrease badness if call is nested.  */\n       if (badness > 0)\n@@ -843,7 +725,7 @@ cgraph_decide_recursive_inlining (struct cgraph_edge *edge,\n \n   /* Make sure that function is small enough to be considered for inlining.  */\n   if (!max_depth\n-      || cgraph_estimate_size_after_inlining (node, edge)  >= limit)\n+      || estimate_size_after_inlining (node, edge)  >= limit)\n     return false;\n   heap = fibheap_new ();\n   lookup_recursive_calls (node, node, heap);\n@@ -873,7 +755,7 @@ cgraph_decide_recursive_inlining (struct cgraph_edge *edge,\n \t= (struct cgraph_edge *) fibheap_extract_min (heap);\n       struct cgraph_node *cnode;\n \n-      if (cgraph_estimate_size_after_inlining (node, curr) > limit)\n+      if (estimate_size_after_inlining (node, curr) > limit)\n \tbreak;\n \n       depth = 1;\n@@ -1075,7 +957,7 @@ cgraph_decide_inlining_of_small_functions (void)\n \t}\n       \n       callee = edge->callee;\n-      growth = cgraph_estimate_edge_growth (edge);\n+      growth = estimate_edge_growth (edge);\n       if (dump_file)\n \t{\n \t  fprintf (dump_file,\n@@ -1090,7 +972,7 @@ cgraph_decide_inlining_of_small_functions (void)\n \t\t   flag_wpa ? \"unknown\"\n \t\t   : gimple_filename ((const_gimple) edge->call_stmt),\n \t\t   flag_wpa ? -1 : gimple_lineno ((const_gimple) edge->call_stmt),\n-\t\t   cgraph_estimate_growth (edge->callee),\n+\t\t   estimate_growth (edge->callee),\n \t\t   badness,\n \t\t   edge->frequency / (double)CGRAPH_FREQ_BASE);\n \t  if (edge->count)\n@@ -1142,7 +1024,7 @@ cgraph_decide_inlining_of_small_functions (void)\n  \tnot_good = CIF_NOT_DECLARED_INLINED;\n       else if (optimize_function_for_size_p (DECL_STRUCT_FUNCTION(edge->caller->decl)))\n  \tnot_good = CIF_OPTIMIZING_FOR_SIZE;\n-      if (not_good && growth > 0 && cgraph_estimate_growth (edge->callee) > 0)\n+      if (not_good && growth > 0 && estimate_growth (edge->callee) > 0)\n \t{\n \t  edge->inline_failed = not_good;\n \t  if (dump_file)\n@@ -1269,7 +1151,7 @@ cgraph_decide_inlining_of_small_functions (void)\n \t\t   flag_wpa ? \"unknown\"\n \t\t   : gimple_filename ((const_gimple) edge->call_stmt),\n \t\t   flag_wpa ? -1 : gimple_lineno ((const_gimple) edge->call_stmt),\n-\t\t   cgraph_estimate_growth (edge->callee),\n+\t\t   estimate_growth (edge->callee),\n \t\t   badness,\n \t\t   edge->frequency / (double)CGRAPH_FREQ_BASE);\n \t  if (edge->count)\n@@ -1394,7 +1276,6 @@ cgraph_decide_inlining (void)\n   int i;\n   int initial_size = 0;\n \n-  cgraph_remove_function_insertion_hook (function_insertion_hook_holder);\n   if (in_lto_p && flag_indirect_inlining)\n     ipa_update_after_lto_read ();\n   if (flag_indirect_inlining)\n@@ -1534,6 +1415,7 @@ cgraph_decide_inlining (void)\n \t     ncalls_inlined, nfunctions_inlined, initial_size,\n \t     overall_size);\n   free (order);\n+  inline_free_summary ();\n   return 0;\n }\n \n@@ -1676,13 +1558,13 @@ cgraph_decide_inlining_incrementally (struct cgraph_node *node)\n       /* When the function body would grow and inlining the function\n \t won't eliminate the need for offline copy of the function,\n \t don't inline.  */\n-      if (cgraph_estimate_edge_growth (e) > allowed_growth\n-\t  && cgraph_estimate_growth (e->callee) > allowed_growth)\n+      if (estimate_edge_growth (e) > allowed_growth\n+\t  && estimate_growth (e->callee) > allowed_growth)\n \t{\n \t  if (dump_file)\n \t    fprintf (dump_file,\n \t\t     \"Not inlining: code size would grow by %i.\\n\",\n-\t\t     cgraph_estimate_edge_growth (e));\n+\t\t     estimate_edge_growth (e));\n \t  continue;\n \t}\n       if (!cgraph_check_inline_limits (e, &e->inline_failed))\n@@ -1798,283 +1680,6 @@ struct gimple_opt_pass pass_early_inline =\n };\n \n \n-/* See if statement might disappear after inlining.\n-   0 - means not eliminated\n-   1 - half of statements goes away\n-   2 - for sure it is eliminated.\n-   We are not terribly sophisticated, basically looking for simple abstraction\n-   penalty wrappers.  */\n-\n-static int\n-eliminated_by_inlining_prob (gimple stmt)\n-{\n-  enum gimple_code code = gimple_code (stmt);\n-  switch (code)\n-    {\n-      case GIMPLE_RETURN:\n-        return 2;\n-      case GIMPLE_ASSIGN:\n-\tif (gimple_num_ops (stmt) != 2)\n-\t  return 0;\n-\n-\t/* Casts of parameters, loads from parameters passed by reference\n-\t   and stores to return value or parameters are often free after\n-\t   inlining dua to SRA and further combining.\n-\t   Assume that half of statements goes away.  */\n-\tif (gimple_assign_rhs_code (stmt) == CONVERT_EXPR\n-\t    || gimple_assign_rhs_code (stmt) == NOP_EXPR\n-\t    || gimple_assign_rhs_code (stmt) == VIEW_CONVERT_EXPR\n-\t    || gimple_assign_rhs_class (stmt) == GIMPLE_SINGLE_RHS)\n-\t  {\n-\t    tree rhs = gimple_assign_rhs1 (stmt);\n-            tree lhs = gimple_assign_lhs (stmt);\n-\t    tree inner_rhs = rhs;\n-\t    tree inner_lhs = lhs;\n-\t    bool rhs_free = false;\n-\t    bool lhs_free = false;\n-\n- \t    while (handled_component_p (inner_lhs)\n-\t\t   || TREE_CODE (inner_lhs) == MEM_REF)\n-\t      inner_lhs = TREE_OPERAND (inner_lhs, 0);\n- \t    while (handled_component_p (inner_rhs)\n-\t           || TREE_CODE (inner_rhs) == ADDR_EXPR\n-\t\t   || TREE_CODE (inner_rhs) == MEM_REF)\n-\t      inner_rhs = TREE_OPERAND (inner_rhs, 0);\n-\n-\n-\t    if (TREE_CODE (inner_rhs) == PARM_DECL\n-\t        || (TREE_CODE (inner_rhs) == SSA_NAME\n-\t\t    && SSA_NAME_IS_DEFAULT_DEF (inner_rhs)\n-\t\t    && TREE_CODE (SSA_NAME_VAR (inner_rhs)) == PARM_DECL))\n-\t      rhs_free = true;\n-\t    if (rhs_free && is_gimple_reg (lhs))\n-\t      lhs_free = true;\n-\t    if (((TREE_CODE (inner_lhs) == PARM_DECL\n-\t          || (TREE_CODE (inner_lhs) == SSA_NAME\n-\t\t      && SSA_NAME_IS_DEFAULT_DEF (inner_lhs)\n-\t\t      && TREE_CODE (SSA_NAME_VAR (inner_lhs)) == PARM_DECL))\n-\t\t && inner_lhs != lhs)\n-\t        || TREE_CODE (inner_lhs) == RESULT_DECL\n-\t        || (TREE_CODE (inner_lhs) == SSA_NAME\n-\t\t    && TREE_CODE (SSA_NAME_VAR (inner_lhs)) == RESULT_DECL))\n-\t      lhs_free = true;\n-\t    if (lhs_free\n-\t\t&& (is_gimple_reg (rhs) || is_gimple_min_invariant (rhs)))\n-\t      rhs_free = true;\n-\t    if (lhs_free && rhs_free)\n-\t      return 1;\n-\t  }\n-\treturn 0;\n-      default:\n-\treturn 0;\n-    }\n-}\n-\n-/* Compute function body size parameters for NODE.  */\n-\n-static void\n-estimate_function_body_sizes (struct cgraph_node *node)\n-{\n-  gcov_type time = 0;\n-  gcov_type time_inlining_benefit = 0;\n-  /* Estimate static overhead for function prologue/epilogue and alignment. */\n-  int size = 2;\n-  /* Benefits are scaled by probability of elimination that is in range\n-     <0,2>.  */\n-  int size_inlining_benefit = 2 * 2;\n-  basic_block bb;\n-  gimple_stmt_iterator bsi;\n-  struct function *my_function = DECL_STRUCT_FUNCTION (node->decl);\n-  int freq;\n-\n-  if (dump_file)\n-    fprintf (dump_file, \"Analyzing function body size: %s\\n\",\n-\t     cgraph_node_name (node));\n-\n-  gcc_assert (my_function && my_function->cfg);\n-  FOR_EACH_BB_FN (bb, my_function)\n-    {\n-      freq = compute_call_stmt_bb_frequency (node->decl, bb);\n-      for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n-\t{\n-\t  gimple stmt = gsi_stmt (bsi);\n-\t  int this_size = estimate_num_insns (stmt, &eni_size_weights);\n-\t  int this_time = estimate_num_insns (stmt, &eni_time_weights);\n-\t  int prob;\n-\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    {\n-\t      fprintf (dump_file, \"  freq:%6i size:%3i time:%3i \",\n-\t\t       freq, this_size, this_time);\n-\t      print_gimple_stmt (dump_file, stmt, 0, 0);\n-\t    }\n-\t  this_time *= freq;\n-\t  time += this_time;\n-\t  size += this_size;\n-\t  prob = eliminated_by_inlining_prob (stmt);\n-\t  if (prob == 1 && dump_file && (dump_flags & TDF_DETAILS))\n-\t    fprintf (dump_file, \"    50%% will be eliminated by inlining\\n\");\n-\t  if (prob == 2 && dump_file && (dump_flags & TDF_DETAILS))\n-\t    fprintf (dump_file, \"    will eliminated by inlining\\n\");\n-\t  size_inlining_benefit += this_size * prob;\n-\t  time_inlining_benefit += this_time * prob;\n-\t  gcc_assert (time >= 0);\n-\t  gcc_assert (size >= 0);\n-\t}\n-    }\n-  time = (time + CGRAPH_FREQ_BASE / 2) / CGRAPH_FREQ_BASE;\n-  time_inlining_benefit = ((time_inlining_benefit + CGRAPH_FREQ_BASE)\n-  \t\t\t   / (CGRAPH_FREQ_BASE * 2));\n-  size_inlining_benefit = (size_inlining_benefit + 1) / 2;\n-  if (time_inlining_benefit > MAX_TIME)\n-    time_inlining_benefit = MAX_TIME;\n-  if (time > MAX_TIME)\n-    time = MAX_TIME;\n-  if (dump_file)\n-    fprintf (dump_file, \"Overall function body time: %i-%i size: %i-%i\\n\",\n-\t     (int)time, (int)time_inlining_benefit,\n-\t     size, size_inlining_benefit);\n-  inline_summary (node)->self_time = time;\n-  inline_summary (node)->self_size = size;\n-  inline_summary (node)->time_inlining_benefit = time_inlining_benefit;\n-  inline_summary (node)->size_inlining_benefit = size_inlining_benefit;\n-}\n-\n-/* Compute parameters of functions used by inliner.  */\n-void\n-compute_inline_parameters (struct cgraph_node *node)\n-{\n-  HOST_WIDE_INT self_stack_size;\n-  struct cgraph_edge *e;\n-\n-  gcc_assert (!node->global.inlined_to);\n-\n-  /* Estimate the stack size for the function if we're optimizing.  */\n-  self_stack_size = optimize ? estimated_stack_frame_size (node) : 0;\n-  inline_summary (node)->estimated_self_stack_size = self_stack_size;\n-  node->global.estimated_stack_size = self_stack_size;\n-  node->global.stack_frame_offset = 0;\n-\n-  /* Can this function be inlined at all?  */\n-  node->local.inlinable = tree_inlinable_function_p (node->decl);\n-  if (!node->local.inlinable)\n-    node->local.disregard_inline_limits = 0;\n-\n-  /* Inlinable functions always can change signature.  */\n-  if (node->local.inlinable)\n-    node->local.can_change_signature = true;\n-  else\n-    {\n-      /* Functions calling builtin_apply can not change signature.  */\n-      for (e = node->callees; e; e = e->next_callee)\n-\tif (DECL_BUILT_IN (e->callee->decl)\n-\t    && DECL_BUILT_IN_CLASS (e->callee->decl) == BUILT_IN_NORMAL\n-\t    && DECL_FUNCTION_CODE (e->callee->decl) == BUILT_IN_APPLY_ARGS)\n-\t  break;\n-      node->local.can_change_signature = !e;\n-    }\n-  estimate_function_body_sizes (node);\n-  /* Compute size of call statements.  We have to do this for callers here,\n-     those sizes need to be present for edges _to_ us as early as\n-     we are finished with early opts.  */\n-  for (e = node->callers; e; e = e->next_caller)\n-    if (e->call_stmt)\n-      {\n-\te->call_stmt_size\n-\t  = estimate_num_insns (e->call_stmt, &eni_size_weights);\n-\te->call_stmt_time\n-\t  = estimate_num_insns (e->call_stmt, &eni_time_weights);\n-      }\n-  /* Inlining characteristics are maintained by the cgraph_mark_inline.  */\n-  node->global.time = inline_summary (node)->self_time;\n-  node->global.size = inline_summary (node)->self_size;\n-}\n-\n-\n-/* Compute parameters of functions used by inliner using\n-   current_function_decl.  */\n-static unsigned int\n-compute_inline_parameters_for_current (void)\n-{\n-  compute_inline_parameters (cgraph_get_node (current_function_decl));\n-  return 0;\n-}\n-\n-struct gimple_opt_pass pass_inline_parameters =\n-{\n- {\n-  GIMPLE_PASS,\n-  \"inline_param\",\t\t\t/* name */\n-  NULL,\t\t\t\t\t/* gate */\n-  compute_inline_parameters_for_current,/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_INLINE_HEURISTICS,\t\t\t/* tv_id */\n-  0,\t                                /* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  0\t\t\t\t\t/* todo_flags_finish */\n- }\n-};\n-\n-/* This function performs intraprocedural analysis in NODE that is required to\n-   inline indirect calls.  */\n-static void\n-inline_indirect_intraprocedural_analysis (struct cgraph_node *node)\n-{\n-  ipa_analyze_node (node);\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      ipa_print_node_params (dump_file, node);\n-      ipa_print_node_jump_functions (dump_file, node);\n-    }\n-}\n-\n-/* Note function body size.  */\n-static void\n-analyze_function (struct cgraph_node *node)\n-{\n-  push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n-  current_function_decl = node->decl;\n-\n-  compute_inline_parameters (node);\n-  /* FIXME: We should remove the optimize check after we ensure we never run\n-     IPA passes when not optimizing.  */\n-  if (flag_indirect_inlining && optimize)\n-    inline_indirect_intraprocedural_analysis (node);\n-\n-  current_function_decl = NULL;\n-  pop_cfun ();\n-}\n-\n-/* Called when new function is inserted to callgraph late.  */\n-static void\n-add_new_function (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n-{\n-  analyze_function (node);\n-}\n-\n-/* Note function body size.  */\n-static void\n-inline_generate_summary (void)\n-{\n-  struct cgraph_node *node;\n-\n-  function_insertion_hook_holder =\n-      cgraph_add_function_insertion_hook (&add_new_function, NULL);\n-\n-  if (flag_indirect_inlining)\n-    ipa_register_cgraph_hooks ();\n-\n-  for (node = cgraph_nodes; node; node = node->next)\n-    if (node->analyzed)\n-      analyze_function (node);\n-\n-  return;\n-}\n-\n /* Apply inline plan to function.  */\n static unsigned int\n inline_transform (struct cgraph_node *node)\n@@ -2111,35 +1716,6 @@ inline_transform (struct cgraph_node *node)\n   return todo | execute_fixup_cfg ();\n }\n \n-/* Read inline summary.  Jump functions are shared among ipa-cp\n-   and inliner, so when ipa-cp is active, we don't need to write them\n-   twice.  */\n-\n-static void\n-inline_read_summary (void)\n-{\n-  if (flag_indirect_inlining)\n-    {\n-      ipa_register_cgraph_hooks ();\n-      if (!flag_ipa_cp)\n-        ipa_prop_read_jump_functions ();\n-    }\n-  function_insertion_hook_holder =\n-      cgraph_add_function_insertion_hook (&add_new_function, NULL);\n-}\n-\n-/* Write inline summary for node in SET.\n-   Jump functions are shared among ipa-cp and inliner, so when ipa-cp is\n-   active, we don't need to write them twice.  */\n-\n-static void\n-inline_write_summary (cgraph_node_set set,\n-\t\t      varpool_node_set vset ATTRIBUTE_UNUSED)\n-{\n-  if (flag_indirect_inlining && !flag_ipa_cp)\n-    ipa_prop_write_jump_functions (set);\n-}\n-\n /* When to run IPA inlining.  Inlining of always-inline functions\n    happens during early inlining.  */\n "}, {"sha": "d76a492a1d2130246f292ef44848105809219803", "filename": "gcc/ipa-inline.h", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03dfc36daf0f94adc8eee3f8ddb88be5f3c4e576/gcc%2Fipa-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03dfc36daf0f94adc8eee3f8ddb88be5f3c4e576/gcc%2Fipa-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.h?ref=03dfc36daf0f94adc8eee3f8ddb88be5f3c4e576", "patch": "@@ -0,0 +1,52 @@\n+/* Inlining decision heuristics.\n+   Copyright (C) 2003, 2004, 2007, 2008, 2009, 2010, 2011\n+   Free Software Foundation, Inc.\n+   Contributed by Jan Hubicka\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+void inline_generate_summary (void);\n+void inline_read_summary (void);\n+void inline_write_summary (cgraph_node_set, varpool_node_set);\n+void inline_free_summary (void);\n+int estimate_time_after_inlining (struct cgraph_node *, struct cgraph_edge *);\n+int estimate_size_after_inlining (struct cgraph_node *, struct cgraph_edge *);\n+int estimate_growth (struct cgraph_node *);\n+\n+static inline struct inline_summary *\n+inline_summary (struct cgraph_node *node)\n+{\n+  return &node->local.inline_summary;\n+}\n+\n+/* Estimate the growth of the caller when inlining EDGE.  */\n+\n+static inline int\n+estimate_edge_growth (struct cgraph_edge *edge)\n+{\n+  int call_stmt_size;\n+  /* ???  We throw away cgraph edges all the time so the information\n+     we store in edges doesn't persist for early inlining.  Ugh.  */\n+  if (!edge->call_stmt)\n+    call_stmt_size = edge->call_stmt_size;\n+  else\n+    call_stmt_size = estimate_num_insns (edge->call_stmt, &eni_size_weights);\n+  return (edge->callee->global.size\n+\t  - inline_summary (edge->callee)->size_inlining_benefit\n+\t  - call_stmt_size);\n+}\n+"}]}