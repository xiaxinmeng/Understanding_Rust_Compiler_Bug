{"sha": "66ba7273482a3c56accefba709e0dfe8f8d75824", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjZiYTcyNzM0ODJhM2M1NmFjY2VmYmE3MDllMGRmZThmOGQ3NTgyNA==", "commit": {"author": {"name": "Ranjit Mathew", "email": "rmathew@hotmail.com", "date": "2004-05-17T15:57:48Z"}, "committer": {"name": "Ranjit Mathew", "email": "rmathew@gcc.gnu.org", "date": "2004-05-17T15:57:48Z"}, "message": "* check-init.c: Correct minor typos.\n\nFrom-SVN: r81940", "tree": {"sha": "c3635e55fe2a44378b75c0223f4f85c5dd854e78", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c3635e55fe2a44378b75c0223f4f85c5dd854e78"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/66ba7273482a3c56accefba709e0dfe8f8d75824", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66ba7273482a3c56accefba709e0dfe8f8d75824", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66ba7273482a3c56accefba709e0dfe8f8d75824", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66ba7273482a3c56accefba709e0dfe8f8d75824/comments", "author": null, "committer": null, "parents": [{"sha": "a2824db366a429dd08c368dc56620a92d4a6542b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2824db366a429dd08c368dc56620a92d4a6542b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2824db366a429dd08c368dc56620a92d4a6542b"}], "stats": {"total": 28, "additions": 16, "deletions": 12}, "files": [{"sha": "4d1bd65877d13091c3659e2546229695284ee2f1", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66ba7273482a3c56accefba709e0dfe8f8d75824/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66ba7273482a3c56accefba709e0dfe8f8d75824/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=66ba7273482a3c56accefba709e0dfe8f8d75824", "patch": "@@ -1,3 +1,7 @@\n+2004-05-17  Ranjit Mathew  <rmathew@hotmail.com>\n+\n+\t* check-init.c: Correct minor typos.\n+\n 2004-05-13  Diego Novillo  <dnovillo@redhat.com>\n \n \t* Make-lang.in, expr.c, java-gimplify.c: Rename"}, {"sha": "0ef0343610bea324f2608157814438f7927909b5", "filename": "gcc/java/check-init.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66ba7273482a3c56accefba709e0dfe8f8d75824/gcc%2Fjava%2Fcheck-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66ba7273482a3c56accefba709e0dfe8f8d75824/gcc%2Fjava%2Fcheck-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fcheck-init.c?ref=66ba7273482a3c56accefba709e0dfe8f8d75824", "patch": "@@ -1,5 +1,5 @@\n /* Code to test for \"definitive [un]assignment\".\n-   Copyright (C) 1999, 2000, 2001, 2003 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2000, 2001, 2003, 2004 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -36,7 +36,7 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n /* The basic idea is that we assign each local variable declaration\n    and each blank final field an index, and then we pass around\n    bitstrings, where the (2*i)'th bit is set if decl whose DECL_BIT_INDEX\n-   is i is definitely assigned, and the the (2*i=1)'th bit is set if \n+   is i is definitely assigned, and the (2*i+1)'th bit is set if \n    decl whose DECL_BIT_INDEX is i is definitely unassigned */\n \n /* One segment of a bitstring. */\n@@ -45,7 +45,7 @@ typedef unsigned int word;\n /* Pointer to a bitstring. */\n typedef word *words;\n \n-/* Number of locals variables currently active. */\n+/* Number of local variables currently active. */\n static int num_current_locals = 0;\n \n /* The value of num_current_locals when we entered the closest\n@@ -198,7 +198,7 @@ static void\n final_assign_error (tree name)\n {\n   static const char format[]\n-    = \"can't reassign a value to the final variable '%s'\";\n+    = \"Can't reassign a value to the final variable `%s'\";\n   parse_error_context (wfl, format, IDENTIFIER_POINTER (name));\n }\n \n@@ -305,7 +305,7 @@ check_bool2_init (enum tree_code code, tree exp0, tree exp1,\n /* Check a boolean expression EXP for definite [un]assignment.\n    BEFORE is the set of variables definitely [un]assigned before the\n    conditional.  (This bitstring may be modified arbitrarily in this function.)\n-   On output, WHEN_FALSE is the set of variables [un]definitely assigned after\n+   On output, WHEN_FALSE is the set of variables definitely [un]assigned after\n    the conditional when the conditional is false.\n    On output, WHEN_TRUE is the set of variables definitely [un]assigned after\n    the conditional when the conditional is true.\n@@ -452,8 +452,8 @@ done_alternative (words after, struct alternatives *current)\n \t      WORDS_NEEDED (2 * current->num_locals));\n }\n \n-/* Used when we done with a control flow branch and are all merged again.\n- * AFTER is the merged state of [un]assigned variables,\n+/* Used when we are done with a control flow branch and are all merged again.\n+   AFTER is the merged state of [un]assigned variables,\n    CURRENT is a struct alt that was passed to BEGIN_ALTERNATIVES. */\n \n #define END_ALTERNATIVES(after, current) \\\n@@ -465,7 +465,7 @@ done_alternative (words after, struct alternatives *current)\n   start_current_locals = current.save_start_current_locals; \\\n }\n \n-/* Check for (un)initialized local variables in EXP.  */\n+/* Check for [un]initialized local variables in EXP.  */\n \n static void\n check_init (tree exp, words before)\n@@ -480,7 +480,7 @@ check_init (tree exp, words before)\n \t  && DECL_NAME (exp) != this_identifier_node)\n \t{\n \t  int index = DECL_BIT_INDEX (exp);\n-\t  /* We don't want to report and mark as non initialized class\n+\t  /* We don't want to report and mark as non-initialized class\n \t     initialization flags. */\n \t  if (! LOCAL_CLASS_INITIALIZATION_FLAG_P (exp)\n \t      && index >= 0 && ! ASSIGNED_P (before, index))\n@@ -502,7 +502,7 @@ check_init (tree exp, words before)\n \t  if (index >= 0 && ! ASSIGNED_P (before, index))\n \t    {\n \t      parse_error_context \n-\t\t(wfl, \"variable '%s' may not have been initialized\",\n+\t\t(wfl, \"variable `%s' may not have been initialized\",\n \t\t IDENTIFIER_POINTER (DECL_NAME (tmp)));\n \t      /* Suppress further errors. */\n \t      DECL_BIT_INDEX (tmp) = -2;\n@@ -623,7 +623,7 @@ check_init (tree exp, words before)\n \t   \"hypothetical\" analysis model.  We do something much\n \t   simpler: We just disallow assignments inside loops to final\n \t   variables declared outside the loop.  This means we may\n-\t   disallow some contrived assignments that the JLS, but I\n+\t   disallow some contrived assignments that the JLS allows, but I\n \t   can't see how anything except a very contrived testcase (a\n \t   do-while whose condition is false?) would care. */\n \n@@ -974,7 +974,7 @@ check_for_initialization (tree body, tree mdecl)\n \t      if (index >= 0 && ! ASSIGNED_P (before, index))\n \t\t{\n \t\t  if (! is_finit_method)\n-\t\t    error (\"%Jfinal field '%D' may not have been initialized\",\n+\t\t    error (\"%Jfinal field `%D' may not have been initialized\",\n                            decl, decl);\n \t\t}\n \t      else if (is_finit_method)"}]}