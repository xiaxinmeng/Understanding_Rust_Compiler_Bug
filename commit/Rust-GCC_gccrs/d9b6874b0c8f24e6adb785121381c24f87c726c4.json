{"sha": "d9b6874b0c8f24e6adb785121381c24f87c726c4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDliNjg3NGIwYzhmMjRlNmFkYjc4NTEyMTM4MWMyNGY4N2M3MjZjNA==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2001-08-17T01:27:49Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2001-08-17T01:27:49Z"}, "message": "final.c (shorten_branches): Clear the end of the label_align array only if we made it larger.\n\n\t* final.c (shorten_branches): Clear the end of the label_align\n\tarray only if we made it larger.  Break up messy expressions\n\tfor clarity.\n\n\t* diagnostic.c (internal_error): Check for error recursion\n\tbefore doing ICE suppression.\n\n\t* timevar.c: Timing variables now count in milliseconds.\n\t(init_timevar): Set up ticks_to_msec and clocks_to_msec here.\n\t(get_time): Not here.\n\t(timevar_print): Don't print any timer whose user, cpu, and\n\twall times are all zero as displayed.\n\t* timevar.h: Update comment aboout units.  Make timevar\n\tcounters unsigned.\n\nFrom-SVN: r44948", "tree": {"sha": "d06379f9caf82cb62fa1d7889ebb1309f38e52b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d06379f9caf82cb62fa1d7889ebb1309f38e52b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d9b6874b0c8f24e6adb785121381c24f87c726c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9b6874b0c8f24e6adb785121381c24f87c726c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9b6874b0c8f24e6adb785121381c24f87c726c4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9b6874b0c8f24e6adb785121381c24f87c726c4/comments", "author": null, "committer": null, "parents": [{"sha": "4266d0b2722db521925be85f61ca1fa643afe409", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4266d0b2722db521925be85f61ca1fa643afe409", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4266d0b2722db521925be85f61ca1fa643afe409"}], "stats": {"total": 144, "additions": 90, "deletions": 54}, "files": [{"sha": "58f6533fe1990acd3aa53b6222e9e69ef7f7e2b7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 9, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9b6874b0c8f24e6adb785121381c24f87c726c4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9b6874b0c8f24e6adb785121381c24f87c726c4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d9b6874b0c8f24e6adb785121381c24f87c726c4", "patch": "@@ -1,3 +1,20 @@\n+2001-08-16  Zack Weinberg  <zackw@panix.com>\n+\n+\t* final.c (shorten_branches): Clear the end of the label_align\n+\tarray only if we made it larger.  Break up messy expressions\n+\tfor clarity.\n+\n+\t* diagnostic.c (internal_error): Check for error recursion\n+\tbefore doing ICE suppression.\n+\n+\t* timevar.c: Timing variables now count in milliseconds.\n+\t(init_timevar): Set up ticks_to_msec and clocks_to_msec here.\n+\t(get_time): Not here.\n+\t(timevar_print): Don't print any timer whose user, cpu, and\n+\twall times are all zero as displayed.\n+\t* timevar.h: Update comment aboout units.  Make timevar\n+\tcounters unsigned.\n+\n Thu Aug 16 17:39:45 CEST 2001  Jan Hubicka  <jh@suse.cz>\n \n \t* function.c (put_var_into_stack): Temporarily clear DECL_RTL.\n@@ -60,7 +77,7 @@ Tue Aug 14 17:30:59 2001  Jeffrey A Law  (law@cygnus.com)\n \tnote from its associated jump.\n \n 2001-08-14  Ulrich Weigand  <uweigand@de.ibm.com>\n- \n+\n \t* config/s390/linux64.h (CPP_PREDEFINES): Define __s390__\n \talso on 64-bit s390x targets.\n \n@@ -74,7 +91,7 @@ Tue Aug 14 17:30:59 2001  Jeffrey A Law  (law@cygnus.com)\n \tmacro with an invocation of\n \tarm_compute_initial_elimination_offset.\n \t* config/arm/arm-protos.h: Prototype\n-\tarm_compute_initial_elimination_offset. \n+\tarm_compute_initial_elimination_offset.\n \n 2001-08-14  Gerald Pfeifer  <pfeifer@dbai.tuwien.ac.at>\n \n@@ -112,15 +129,15 @@ Tue Aug 14 17:30:59 2001  Jeffrey A Law  (law@cygnus.com)\n \n Tue Aug 14 14:57:07 CEST 2001  Jan Hubicka  <jh@suse.cz>\n \n-        * genattrtab.c (simplify_test_exp_in_temp): New function.\n-        (simplify_test_exp): Avoid explicit use of temporary obstack.\n-        (simplify_cond, insert_right_side, evaluate_eq_attr,\n-        simplify_and_tree, simplify_or_tree, eliminate_known_true):\n-        Use simplify_test_exp_in_temp.\n-        (optimize_attrs): Iterate until expression stabilizes.\n+\t* genattrtab.c (simplify_test_exp_in_temp): New function.\n+\t(simplify_test_exp): Avoid explicit use of temporary obstack.\n+\t(simplify_cond, insert_right_side, evaluate_eq_attr,\n+\tsimplify_and_tree, simplify_or_tree, eliminate_known_true):\n+\tUse simplify_test_exp_in_temp.\n+\t(optimize_attrs): Iterate until expression stabilizes.\n \n 2001-08-13  Ulrich Weigand  <uweigand@de.ibm.com>:\n- \n+\n \t* glimits.h: Remove the __LONG_MAX__ special case for s390x.\n \t* config/s390/linux64.h: Define __LONG_MAX__ in CPP_PREDEFINES.\n "}, {"sha": "4e5d3a814a6f4a2f70f40a11a5c0d07628bf3c8f", "filename": "gcc/diagnostic.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9b6874b0c8f24e6adb785121381c24f87c726c4/gcc%2Fdiagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9b6874b0c8f24e6adb785121381c24f87c726c4/gcc%2Fdiagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.c?ref=d9b6874b0c8f24e6adb785121381c24f87c726c4", "patch": "@@ -1314,6 +1314,9 @@ internal_error VPARAMS ((const char *msgid, ...))\n   msgid = va_arg (ap, const char *);\n #endif\n \n+  if (diagnostic_lock)\n+    error_recursion ();\n+\n   if (errorcount > 0 || sorrycount > 0)\n     {\n       fnotice (stderr, \"%s:%d: confused by earlier errors, bailing out\\n\","}, {"sha": "821a814fa45378fef1367c6b05ac9a105067c190", "filename": "gcc/final.c", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9b6874b0c8f24e6adb785121381c24f87c726c4/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9b6874b0c8f24e6adb785121381c24f87c726c4/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=d9b6874b0c8f24e6adb785121381c24f87c726c4", "patch": "@@ -1062,12 +1062,20 @@ shorten_branches (first)\n   if (max_labelno != max_label_num ())\n     {\n       int old = max_labelno;\n+      int n_labels;\n+      int n_old_labels;\n+\n       max_labelno = max_label_num ();\n+\n+      n_labels = max_labelno - min_labelno + 1;\n+      n_old_labels = old - min_labelno + 1;\n+\n       label_align = (struct label_alignment *) xrealloc\n-\t(label_align,\n-\t (max_labelno - min_labelno + 1) * sizeof (struct label_alignment));\n-      memset (label_align + old + 1 - min_labelno, 0,\n-\t      sizeof (struct label_alignment) * (max_labelno - old));\n+\t(label_align, n_labels * sizeof (struct label_alignment));\n+\n+      if (n_old_labels < n_labels)\n+\tmemset (label_align + n_old_labels, 0,\n+\t\t(n_labels - n_old_labels) * sizeof (struct label_alignment));\n     }\n \n   /* Initialize label_align and set up uid_shuid to be strictly"}, {"sha": "b0e013d39fe26605e02846c630c4238aa4f7e12e", "filename": "gcc/timevar.c", "status": "modified", "additions": 45, "deletions": 37, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9b6874b0c8f24e6adb785121381c24f87c726c4/gcc%2Ftimevar.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9b6874b0c8f24e6adb785121381c24f87c726c4/gcc%2Ftimevar.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.c?ref=d9b6874b0c8f24e6adb785121381c24f87c726c4", "patch": "@@ -74,9 +74,6 @@ extern clock_t clock PARAMS ((void));\n # endif\n #endif\n \n-#define TICKS_TO_USEC (1000000 / TICKS_PER_SECOND)\n-#define CLOCKS_TO_USEC (1000000 / CLOCKS_PER_SEC)\n-\n /* Prefer times to getrusage to clock (each gives successively less\n    information).  */\n #ifdef HAVE_TIMES\n@@ -97,6 +94,20 @@ extern clock_t clock PARAMS ((void));\n #endif\n #endif\n \n+/* libc is very likely to have snuck a call to sysconf() into one of\n+   the underlying constants, and that can be very slow, so we have to\n+   precompute them.  Whose wonderful idea was it to make all those\n+   _constants_ variable at run time, anyway?  */\n+#ifdef USE_TIMES\n+static int ticks_to_msec;\n+#define TICKS_TO_MSEC (1000 / TICKS_PER_SECOND)\n+#endif\n+\n+#ifdef USE_CLOCK\n+static int clocks_to_msec;\n+#define CLOCKS_TO_MSEC (1000 / CLOCKS_PER_SEC)\n+#endif\n+\n #include \"flags.h\"\n #include \"timevar.h\"\n \n@@ -179,32 +190,19 @@ get_time (now)\n \n   {\n #ifdef USE_TIMES\n-    /* libc is very likely to have snuck a call to sysconf() into one\n-       of the underlying constants, and that can make system calls, so\n-       we have to precompute the value.  Whose wonderful idea was it\n-       to make all those _constants_ variable at run time, anyway?  */\n-    static int ticks_to_usec;\n     struct tms tms;\n-    if (ticks_to_usec == 0)\n-      ticks_to_usec = TICKS_TO_USEC;\n-\n-    now->wall = times (&tms) * ticks_to_usec;\n-    now->user = tms.tms_utime * ticks_to_usec;\n-    now->sys = tms.tms_stime * ticks_to_usec;\n+    now->wall = times (&tms)  * ticks_to_msec;\n+    now->user = tms.tms_utime * ticks_to_msec;\n+    now->sys  = tms.tms_stime * ticks_to_msec;\n #endif\n #ifdef USE_GETRUSAGE\n     struct rusage rusage;\n     getrusage (RUSAGE_SELF, &rusage);\n-    now->user \n-      = rusage.ru_utime.tv_sec * 1000000 + rusage.ru_utime.tv_usec;\n-    now->sys \n-      = rusage.ru_stime.tv_sec * 1000000 + rusage.ru_stime.tv_usec;\n+    now->user = rusage.ru_utime.tv_sec * 1000 + rusage.ru_utime.tv_usec / 1000;\n+    now->sys  = rusage.ru_stime.tv_sec * 1000 + rusage.ru_stime.tv_usec / 1000;\n #endif\n #ifdef USE_CLOCK\n-    static int clocks_to_usec;\n-    if (clocks_to_usec == 0)\n-      clocks_to_usec = CLOCKS_TO_USEC;\n-    now->user = clock () * clocks_to_usec;\n+    now->user = clock () * clocks_to_msec;\n #endif\n   }\n }\n@@ -238,6 +236,13 @@ init_timevar ()\n   timevars[identifer__].name = name__;\n #include \"timevar.def\"\n #undef DEFTIMEVAR\n+\n+#ifdef USE_TIMES\n+  ticks_to_msec = TICKS_TO_MSEC;\n+#endif\n+#ifdef USE_CLOCK\n+  clocks_to_msec = CLOCKS_TO_MSEC;\n+#endif\n }\n \n /* Push TIMEVAR onto the timing stack.  No further elapsed time is\n@@ -439,7 +444,7 @@ timevar_print (fp)\n      TIMEVAR. */\n   start_time = now;\n \n-  fprintf (fp, _(\"\\nExecution times (seconds)\\n\"));\n+  fputs (_(\"\\nExecution times (seconds)\\n\"), fp);\n   for (id = 0; id < (unsigned int) TIMEVAR_LAST; ++id)\n     {\n       struct timevar_def *tv = &timevars[(timevar_id_t) id];\n@@ -453,52 +458,55 @@ timevar_print (fp)\n       if (!tv->used)\n \tcontinue;\n \n+      /* Don't print timing variables if we're going to get a row of\n+         zeroes.  */\n+      if (tv->elapsed.user < 10 && tv->elapsed.sys < 10\n+\t  && tv->elapsed.wall < 10)\n+\tcontinue;\n+\n       /* The timing variable name.  */\n       fprintf (fp, \" %-22s:\", tv->name);\n \n #ifdef HAVE_USER_TIME\n       /* Print user-mode time for this process.  */\n       fprintf (fp, \"%4ld.%02ld (%2.0f%%) usr\", \n-\t       tv->elapsed.user / 1000000, \n-\t       (tv->elapsed.user % 1000000) / 10000,\n-\t       (total->user == 0) ? 0.0 \n+\t       tv->elapsed.user / 1000, (tv->elapsed.user % 1000) / 10,\n+\t       (total->user == 0) ? 0.0\n \t       : (100.0 * tv->elapsed.user / (double) total->user));\n #endif /* HAVE_USER_TIME */\n \n #ifdef HAVE_SYS_TIME\n       /* Print system-mode time for this process.  */\n       fprintf (fp, \"%4ld.%02ld (%2.0f%%) sys\", \n-\t       tv->elapsed.sys / 1000000, \n-\t       (tv->elapsed.sys % 1000000) / 10000,\n-\t       (total->sys == 0) ? 0.0 \n+\t       tv->elapsed.sys / 1000, (tv->elapsed.sys % 1000) / 10,\n+\t       (total->sys == 0) ? 0.0\n \t       : (100.0 * tv->elapsed.sys / (double) total->sys));\n #endif /* HAVE_SYS_TIME */\n \n #ifdef HAVE_WALL_TIME\n       /* Print wall clock time elapsed.  */\n       fprintf (fp, \"%4ld.%02ld (%2.0f%%) wall\", \n-\t       tv->elapsed.wall / 1000000, \n-\t       (tv->elapsed.wall % 1000000) / 10000,\n-\t       (total->wall == 0) ? 0.0 \n+\t       tv->elapsed.wall / 1000, (tv->elapsed.wall % 1000) / 10,\n+\t       (total->wall == 0) ? 0.0\n \t       : (100.0 * tv->elapsed.wall / (double) total->wall));\n #endif /* HAVE_WALL_TIME */\n \n-      fprintf (fp, \"\\n\");\n+      putc ('\\n', fp);\n     }\n \n   /* Print total time.  */\n-  fprintf (fp, _(\" TOTAL                 :\"));\n+  fputs (_(\" TOTAL                 :\"), fp);\n #ifdef HAVE_USER_TIME\n   fprintf (fp, \"%4ld.%02ld          \", \n-\t   total->user / 1000000, (total->user % 1000000) / 10000);\n+\t   total->user / 1000, (total->user % 1000) / 10);\n #endif \n #ifdef HAVE_SYS_TIME\n   fprintf (fp, \"%4ld.%02ld          \", \n-\t   total->sys  / 1000000, (total->sys  % 1000000) / 10000);\n+\t   total->sys  / 1000, (total->sys  % 1000) / 10);\n #endif\n #ifdef HAVE_WALL_TIME\n   fprintf (fp, \"%4ld.%02ld\\n\",\n-\t   total->wall / 1000000, (total->wall % 1000000) / 10000);\n+\t   total->wall / 1000, (total->wall % 1000) / 10);\n #endif\n   \n #endif /* defined (HAVE_USER_TIME) || defined (HAVE_SYS_TIME) "}, {"sha": "5da847dff388db032fe694918da10948e11d22e0", "filename": "gcc/timevar.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9b6874b0c8f24e6adb785121381c24f87c726c4/gcc%2Ftimevar.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9b6874b0c8f24e6adb785121381c24f87c726c4/gcc%2Ftimevar.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.h?ref=d9b6874b0c8f24e6adb785121381c24f87c726c4", "patch": "@@ -45,22 +45,22 @@\n */\n    \n /* This structure stores the various varieties of time that can be\n-   measured.  Times are stored in microseconds.  The time may be an\n+   measured.  Times are stored in milliseconds.  The time may be an\n    absolute time or a time difference; in the former case, the time\n    base is undefined, except that the difference between two times\n    produces a valid time difference.  */\n \n struct timevar_time_def\n {\n   /* User time in this process.  */\n-  long user;\n+  unsigned long user;\n \n   /* System time (if applicable for this host platform) in this\n      process.  */\n-  long sys;\n+  unsigned long sys;\n \n   /* Wall clock time.  */\n-  long wall;\n+  unsigned long wall;\n };\n \n /* An enumeration of timing variable indentifiers.  Constructed from"}]}