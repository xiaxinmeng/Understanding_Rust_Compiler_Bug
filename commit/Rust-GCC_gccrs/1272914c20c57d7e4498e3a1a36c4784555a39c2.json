{"sha": "1272914c20c57d7e4498e3a1a36c4784555a39c2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTI3MjkxNGMyMGM1N2Q3ZTQ0OThlM2ExYTM2YzQ3ODQ1NTVhMzljMg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-04-24T07:59:22Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-04-24T07:59:22Z"}, "message": "re PR target/21101 (ICE: could not find a spill register on MMX intrinsics)\n\n        PR target/21101\n        * config/i386/i386.h (CANNOT_CHANGE_MODE_CLASS): Move guts to ...\n        * config/i386/i386.c (ix86_cannot_change_mode_class): ... here.\n        Deny modes smaller than 4 bytes.\n        * config/i386/i386-protos.h: Update.\n\nFrom-SVN: r98650", "tree": {"sha": "6ef27bbdc28738298b27a76311c4ff4faf90efb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6ef27bbdc28738298b27a76311c4ff4faf90efb3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1272914c20c57d7e4498e3a1a36c4784555a39c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1272914c20c57d7e4498e3a1a36c4784555a39c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1272914c20c57d7e4498e3a1a36c4784555a39c2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1272914c20c57d7e4498e3a1a36c4784555a39c2/comments", "author": null, "committer": null, "parents": [{"sha": "d076e5d27d8e986eed6e5397e2b8f79a69955728", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d076e5d27d8e986eed6e5397e2b8f79a69955728", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d076e5d27d8e986eed6e5397e2b8f79a69955728"}], "stats": {"total": 100, "additions": 84, "deletions": 16}, "files": [{"sha": "9f2ee990c9f4a1299f1a113335a9483b1c48b0d2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1272914c20c57d7e4498e3a1a36c4784555a39c2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1272914c20c57d7e4498e3a1a36c4784555a39c2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1272914c20c57d7e4498e3a1a36c4784555a39c2", "patch": "@@ -1,3 +1,11 @@\n+2005-04-24  Richard Henderson  <rth@redhat.com>\n+\n+\tPR target/21101\n+\t* config/i386/i386.h (CANNOT_CHANGE_MODE_CLASS): Move guts to ...\n+\t* config/i386/i386.c (ix86_cannot_change_mode_class): ... here.\n+\tDeny modes smaller than 4 bytes.\n+\t* config/i386/i386-protos.h: Update.\n+\n 2005-04-24  Ralf Corsepius  <ralf.corsepius@rtems.org>\n \n \t* config.gcc (h8300-*-rtems*): Add h8300-*-rtemscoff*.\n@@ -74,9 +82,9 @@\n \t\n 2005-04-23  Richard Henderson  <rth@redhat.com>\n \n-        PR rtl-opt/21102\n-        * simplify-rtx.c (simplify_binary_operation): Fix mode check before\n-        performing some integral scalar simplifications.\n+\tPR rtl-opt/21102\n+\t* simplify-rtx.c (simplify_binary_operation): Fix mode check before\n+\tperforming some integral scalar simplifications.\n \n 2005-04-23  Richard Henderson  <rth@redhat.com>\n "}, {"sha": "d8f15da9e4cdca18caad4fcd2105d1e6e40ee33d", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1272914c20c57d7e4498e3a1a36c4784555a39c2/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1272914c20c57d7e4498e3a1a36c4784555a39c2/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=1272914c20c57d7e4498e3a1a36c4784555a39c2", "patch": "@@ -187,6 +187,8 @@ extern int ix86_register_move_cost (enum machine_mode, enum reg_class,\n \t\t\t\t    enum reg_class);\n extern int ix86_secondary_memory_needed (enum reg_class, enum reg_class,\n \t\t\t\t\t enum machine_mode, int);\n+extern bool ix86_cannot_change_mode_class (enum machine_mode,\n+\t\t\t\t\t   enum machine_mode, enum reg_class);\n extern enum reg_class ix86_preferred_reload_class (rtx, enum reg_class);\n extern int ix86_memory_move_cost (enum machine_mode, enum reg_class, int);\n extern void emit_i387_cw_initialization (rtx, rtx, int);"}, {"sha": "110b23301a69c1e0dbfd5fffddb5897381141835", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1272914c20c57d7e4498e3a1a36c4784555a39c2/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1272914c20c57d7e4498e3a1a36c4784555a39c2/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=1272914c20c57d7e4498e3a1a36c4784555a39c2", "patch": "@@ -15297,6 +15297,41 @@ ix86_secondary_memory_needed (enum reg_class class1, enum reg_class class2,\n   return false;\n }\n \n+/* Return true if the registers in CLASS cannot represent the change from\n+   modes FROM to TO.  */\n+\n+bool\n+ix86_cannot_change_mode_class (enum machine_mode from, enum machine_mode to,\n+\t\t\t       enum reg_class class)\n+{\n+  if (from == to)\n+    return false;\n+\n+  /* x87 registers can't do subreg at all, as all values are reformated\n+     to extended precision.  */\n+  if (MAYBE_FLOAT_CLASS_P (class))\n+    return true;\n+\n+  if (MAYBE_SSE_CLASS_P (class) || MAYBE_MMX_CLASS_P (class))\n+    {\n+      /* Vector registers do not support QI or HImode loads.  If we don't\n+\t disallow a change to these modes, reload will assume it's ok to\n+\t drop the subreg from (subreg:SI (reg:HI 100) 0).  This affects\n+\t the vec_dupv4hi pattern.  */\n+      if (GET_MODE_SIZE (from) < 4)\n+\treturn true;\n+\n+      /* Vector registers do not support subreg with nonzero offsets, which\n+\t are otherwise valid for integer registers.  Since we can't see \n+\t whether we have a nonzero offset from here, prohibit all\n+         nonparadoxical subregs changing size.  */\n+      if (GET_MODE_SIZE (to) < GET_MODE_SIZE (from))\n+\treturn true;\n+    }\n+\n+  return false;\n+}\n+\n /* Return the cost of moving data from a register in class CLASS1 to\n    one in class CLASS2.\n "}, {"sha": "fc0596ba948faf15e50c7da75f1601ec7007be01", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1272914c20c57d7e4498e3a1a36c4784555a39c2/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1272914c20c57d7e4498e3a1a36c4784555a39c2/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=1272914c20c57d7e4498e3a1a36c4784555a39c2", "patch": "@@ -1338,19 +1338,10 @@ enum reg_class\n    || ((CLASS) == FP_TOP_REG)\t\t\t\t\t\t\\\n    || ((CLASS) == FP_SECOND_REG))\n \n-/* Return a class of registers that cannot change FROM mode to TO mode.\n-\n-   x87 registers can't do subreg as all values are reformated to extended\n-   precision.  XMM registers does not support with nonzero offsets equal\n-   to 4, 8 and 12 otherwise valid for integer registers. Since we can't\n-   determine these, prohibit all nonparadoxical subregs changing size.  */\n-\n-#define CANNOT_CHANGE_MODE_CLASS(FROM, TO, CLASS)\t\\\n-  (GET_MODE_SIZE (TO) < GET_MODE_SIZE (FROM)\t\t\\\n-   ? reg_classes_intersect_p (FLOAT_SSE_REGS, (CLASS))\t\\\n-     || MAYBE_MMX_CLASS_P (CLASS) \t\t\t\\\n-   : GET_MODE_SIZE (FROM) != GET_MODE_SIZE (TO)\t\t\\\n-   ? reg_classes_intersect_p (FLOAT_REGS, (CLASS)) : 0)\n+/* Return a class of registers that cannot change FROM mode to TO mode.  */\n+\n+#define CANNOT_CHANGE_MODE_CLASS(FROM, TO, CLASS) \\\n+  ix86_cannot_change_mode_class (FROM, TO, CLASS)\n \f\n /* Stack layout; function entry, exit and calling.  */\n "}, {"sha": "104b08cd2a90e55e2c04cf66e0fb00f5233aed5e", "filename": "gcc/testsuite/gcc.target/i386/pr21101.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1272914c20c57d7e4498e3a1a36c4784555a39c2/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr21101.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1272914c20c57d7e4498e3a1a36c4784555a39c2/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr21101.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr21101.c?ref=1272914c20c57d7e4498e3a1a36c4784555a39c2", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -funroll-loops -march=nocona\" } */\n+\n+#include <mmintrin.h>\n+\n+int W;\n+void f()\n+{\n+  int j;\n+  int B, C;\n+  unsigned char* S;\n+  __m64 *T = (__m64 *) &W;\n+\n+  for (j = 0; j < 16; j++, T++)\n+  {\n+    T[0] = T[1] = _mm_set1_pi8(*S);\n+    S += W;\n+  }\n+\n+  C = 3 * B;\n+\n+  __m64 E = _mm_set_pi16(3 * B, 3 * B, 3 * B, 5 * B);\n+  __m64 G = _mm_set1_pi16(3 * B);\n+\n+  for (j = 0; j < 16; j++)\n+  {\n+    __m64 R = _mm_set1_pi16(B + j * C);\n+    R = _m_paddw(R, E);\n+    R = _m_paddw(R, G);\n+    T[0] = _mm_srai_pi16(R, 3);\n+  }\n+}"}]}