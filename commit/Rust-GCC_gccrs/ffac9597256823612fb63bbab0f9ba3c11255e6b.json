{"sha": "ffac9597256823612fb63bbab0f9ba3c11255e6b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmZhYzk1OTcyNTY4MjM2MTJmYjYzYmJhYjBmOWJhM2MxMTI1NWU2Yg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2020-06-05T16:45:11Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2020-06-08T20:42:35Z"}, "message": "bootstrap: Fix --disable-bootstrap with older g++.\n\nPreviously I had AX_CXX_COMPILE_STDCXX in the gcc directory configure, which\nadded -std=c++11 to CXX if needed, but then CXX is overridden from the\ntoplevel directory, so it didn't have the desired effect.  Fixed by moving\nthe check to the toplevel.  Currently it is only used when building GCC\nwithout bootstrapping; other packages that share the toplevel directory\ncan adjust the condition if they also want to require C++11 support.\n\n/ChangeLog:\n\n\t* configure.ac: Check AX_CXX_COMPILE_STDCXX if not bootstrapping.\n\t* configure: Regenerate.\n\ngcc/ChangeLog:\n\n\t* aclocal.m4: Remove ax_cxx_compile_stdcxx.m4.\n\t* configure.ac: Remove AX_CXX_COMPILE_STDCXX.\n\t* configure: Regenerate.", "tree": {"sha": "c5f0a6a6042169bbd40d9030922b138d530eb34d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c5f0a6a6042169bbd40d9030922b138d530eb34d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ffac9597256823612fb63bbab0f9ba3c11255e6b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffac9597256823612fb63bbab0f9ba3c11255e6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffac9597256823612fb63bbab0f9ba3c11255e6b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffac9597256823612fb63bbab0f9ba3c11255e6b/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a37fbff12c3a441753f5eb677cebeab7350f24eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a37fbff12c3a441753f5eb677cebeab7350f24eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a37fbff12c3a441753f5eb677cebeab7350f24eb"}], "stats": {"total": 2005, "additions": 1004, "deletions": 1001}, "files": [{"sha": "a0c5aca9e8d5cae2782c8fe4625a501853dc226a", "filename": "configure", "status": "modified", "additions": 997, "deletions": 2, "changes": 999, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffac9597256823612fb63bbab0f9ba3c11255e6b/configure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffac9597256823612fb63bbab0f9ba3c11255e6b/configure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure?ref=ffac9597256823612fb63bbab0f9ba3c11255e6b", "patch": "@@ -694,6 +694,7 @@ extra_mpc_gmp_configure_flags\n extra_mpfr_configure_flags\n gmpinc\n gmplibs\n+HAVE_CXX11\n do_compare\n GNATMAKE\n GNATBIND\n@@ -5524,9 +5525,1002 @@ $as_echo \"$as_me: WARNING: trying to bootstrap a cross compiler\" >&2;}\n esac\n \n # When bootstrapping with GCC, build stage 1 in C++11 mode to ensure that a\n-# C++11 compiler can still start the bootstrap.\n+# C++11 compiler can still start the bootstrap.  Otherwise, if building GCC,\n+# require C++11 (or higher).\n if test \"$enable_bootstrap:$GXX\" = \"yes:yes\"; then\n   CXX=\"$CXX -std=c++11\"\n+elif test \"$have_compiler\" = yes; then\n+    ax_cxx_compile_alternatives=\"11 0x\"    ax_cxx_compile_cxx11_required=true\n+  ac_ext=cpp\n+ac_cpp='$CXXCPP $CPPFLAGS'\n+ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'\n+ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'\n+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu\n+  ac_success=no\n+\n+      { $as_echo \"$as_me:${as_lineno-$LINENO}: checking whether $CXX supports C++11 features by default\" >&5\n+$as_echo_n \"checking whether $CXX supports C++11 features by default... \" >&6; }\n+if ${ax_cv_cxx_compile_cxx11+:} false; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+\n+\n+// If the compiler admits that it is not ready for C++11, why torture it?\n+// Hopefully, this will speed up the test.\n+\n+#ifndef __cplusplus\n+\n+#error \"This is not a C++ compiler\"\n+\n+#elif __cplusplus < 201103L\n+\n+#error \"This is not a C++11 compiler\"\n+\n+#else\n+\n+namespace cxx11\n+{\n+\n+  namespace test_static_assert\n+  {\n+\n+    template <typename T>\n+    struct check\n+    {\n+      static_assert(sizeof(int) <= sizeof(T), \"not big enough\");\n+    };\n+\n+  }\n+\n+  namespace test_final_override\n+  {\n+\n+    struct Base\n+    {\n+      virtual ~Base() {}\n+      virtual void f() {}\n+    };\n+\n+    struct Derived : public Base\n+    {\n+      virtual ~Derived() override {}\n+      virtual void f() override {}\n+    };\n+\n+  }\n+\n+  namespace test_double_right_angle_brackets\n+  {\n+\n+    template < typename T >\n+    struct check {};\n+\n+    typedef check<void> single_type;\n+    typedef check<check<void>> double_type;\n+    typedef check<check<check<void>>> triple_type;\n+    typedef check<check<check<check<void>>>> quadruple_type;\n+\n+  }\n+\n+  namespace test_decltype\n+  {\n+\n+    int\n+    f()\n+    {\n+      int a = 1;\n+      decltype(a) b = 2;\n+      return a + b;\n+    }\n+\n+  }\n+\n+  namespace test_type_deduction\n+  {\n+\n+    template < typename T1, typename T2 >\n+    struct is_same\n+    {\n+      static const bool value = false;\n+    };\n+\n+    template < typename T >\n+    struct is_same<T, T>\n+    {\n+      static const bool value = true;\n+    };\n+\n+    template < typename T1, typename T2 >\n+    auto\n+    add(T1 a1, T2 a2) -> decltype(a1 + a2)\n+    {\n+      return a1 + a2;\n+    }\n+\n+    int\n+    test(const int c, volatile int v)\n+    {\n+      static_assert(is_same<int, decltype(0)>::value == true, \"\");\n+      static_assert(is_same<int, decltype(c)>::value == false, \"\");\n+      static_assert(is_same<int, decltype(v)>::value == false, \"\");\n+      auto ac = c;\n+      auto av = v;\n+      auto sumi = ac + av + 'x';\n+      auto sumf = ac + av + 1.0;\n+      static_assert(is_same<int, decltype(ac)>::value == true, \"\");\n+      static_assert(is_same<int, decltype(av)>::value == true, \"\");\n+      static_assert(is_same<int, decltype(sumi)>::value == true, \"\");\n+      static_assert(is_same<int, decltype(sumf)>::value == false, \"\");\n+      static_assert(is_same<int, decltype(add(c, v))>::value == true, \"\");\n+      return (sumf > 0.0) ? sumi : add(c, v);\n+    }\n+\n+  }\n+\n+  namespace test_noexcept\n+  {\n+\n+    int f() { return 0; }\n+    int g() noexcept { return 0; }\n+\n+    static_assert(noexcept(f()) == false, \"\");\n+    static_assert(noexcept(g()) == true, \"\");\n+\n+  }\n+\n+  namespace test_constexpr\n+  {\n+\n+    template < typename CharT >\n+    unsigned long constexpr\n+    strlen_c_r(const CharT *const s, const unsigned long acc) noexcept\n+    {\n+      return *s ? strlen_c_r(s + 1, acc + 1) : acc;\n+    }\n+\n+    template < typename CharT >\n+    unsigned long constexpr\n+    strlen_c(const CharT *const s) noexcept\n+    {\n+      return strlen_c_r(s, 0UL);\n+    }\n+\n+    static_assert(strlen_c(\"\") == 0UL, \"\");\n+    static_assert(strlen_c(\"1\") == 1UL, \"\");\n+    static_assert(strlen_c(\"example\") == 7UL, \"\");\n+    static_assert(strlen_c(\"another\\0example\") == 7UL, \"\");\n+\n+  }\n+\n+  namespace test_rvalue_references\n+  {\n+\n+    template < int N >\n+    struct answer\n+    {\n+      static constexpr int value = N;\n+    };\n+\n+    answer<1> f(int&)       { return answer<1>(); }\n+    answer<2> f(const int&) { return answer<2>(); }\n+    answer<3> f(int&&)      { return answer<3>(); }\n+\n+    void\n+    test()\n+    {\n+      int i = 0;\n+      const int c = 0;\n+      static_assert(decltype(f(i))::value == 1, \"\");\n+      static_assert(decltype(f(c))::value == 2, \"\");\n+      static_assert(decltype(f(0))::value == 3, \"\");\n+    }\n+\n+  }\n+\n+  namespace test_uniform_initialization\n+  {\n+\n+    struct test\n+    {\n+      static const int zero {};\n+      static const int one {1};\n+    };\n+\n+    static_assert(test::zero == 0, \"\");\n+    static_assert(test::one == 1, \"\");\n+\n+  }\n+\n+  namespace test_lambdas\n+  {\n+\n+    void\n+    test1()\n+    {\n+      auto lambda1 = [](){};\n+      auto lambda2 = lambda1;\n+      lambda1();\n+      lambda2();\n+    }\n+\n+    int\n+    test2()\n+    {\n+      auto a = [](int i, int j){ return i + j; }(1, 2);\n+      auto b = []() -> int { return '0'; }();\n+      auto c = [=](){ return a + b; }();\n+      auto d = [&](){ return c; }();\n+      auto e = [a, &b](int x) mutable {\n+        const auto identity = [](int y){ return y; };\n+        for (auto i = 0; i < a; ++i)\n+          a += b--;\n+        return x + identity(a + b);\n+      }(0);\n+      return a + b + c + d + e;\n+    }\n+\n+    int\n+    test3()\n+    {\n+      const auto nullary = [](){ return 0; };\n+      const auto unary = [](int x){ return x; };\n+      using nullary_t = decltype(nullary);\n+      using unary_t = decltype(unary);\n+      const auto higher1st = [](nullary_t f){ return f(); };\n+      const auto higher2nd = [unary](nullary_t f1){\n+        return [unary, f1](unary_t f2){ return f2(unary(f1())); };\n+      };\n+      return higher1st(nullary) + higher2nd(nullary)(unary);\n+    }\n+\n+  }\n+\n+  namespace test_variadic_templates\n+  {\n+\n+    template <int...>\n+    struct sum;\n+\n+    template <int N0, int... N1toN>\n+    struct sum<N0, N1toN...>\n+    {\n+      static constexpr auto value = N0 + sum<N1toN...>::value;\n+    };\n+\n+    template <>\n+    struct sum<>\n+    {\n+      static constexpr auto value = 0;\n+    };\n+\n+    static_assert(sum<>::value == 0, \"\");\n+    static_assert(sum<1>::value == 1, \"\");\n+    static_assert(sum<23>::value == 23, \"\");\n+    static_assert(sum<1, 2>::value == 3, \"\");\n+    static_assert(sum<5, 5, 11>::value == 21, \"\");\n+    static_assert(sum<2, 3, 5, 7, 11, 13>::value == 41, \"\");\n+\n+  }\n+\n+  // http://stackoverflow.com/questions/13728184/template-aliases-and-sfinae\n+  // Clang 3.1 fails with headers of libstd++ 4.8.3 when using std::function\n+  // because of this.\n+  namespace test_template_alias_sfinae\n+  {\n+\n+    struct foo {};\n+\n+    template<typename T>\n+    using member = typename T::member_type;\n+\n+    template<typename T>\n+    void func(...) {}\n+\n+    template<typename T>\n+    void func(member<T>*) {}\n+\n+    void test();\n+\n+    void test() { func<foo>(0); }\n+\n+  }\n+\n+}  // namespace cxx11\n+\n+#endif  // __cplusplus >= 201103L\n+\n+\n+\n+_ACEOF\n+if ac_fn_cxx_try_compile \"$LINENO\"; then :\n+  ax_cv_cxx_compile_cxx11=yes\n+else\n+  ax_cv_cxx_compile_cxx11=no\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+fi\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ax_cv_cxx_compile_cxx11\" >&5\n+$as_echo \"$ax_cv_cxx_compile_cxx11\" >&6; }\n+    if test x$ax_cv_cxx_compile_cxx11 = xyes; then\n+      ac_success=yes\n+    fi\n+\n+    if test x$ac_success = xno; then\n+    for alternative in ${ax_cxx_compile_alternatives}; do\n+      switch=\"-std=gnu++${alternative}\"\n+      cachevar=`$as_echo \"ax_cv_cxx_compile_cxx11_$switch\" | $as_tr_sh`\n+      { $as_echo \"$as_me:${as_lineno-$LINENO}: checking whether $CXX supports C++11 features with $switch\" >&5\n+$as_echo_n \"checking whether $CXX supports C++11 features with $switch... \" >&6; }\n+if eval \\${$cachevar+:} false; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  ac_save_CXX=\"$CXX\"\n+         CXX=\"$CXX $switch\"\n+         cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+\n+\n+// If the compiler admits that it is not ready for C++11, why torture it?\n+// Hopefully, this will speed up the test.\n+\n+#ifndef __cplusplus\n+\n+#error \"This is not a C++ compiler\"\n+\n+#elif __cplusplus < 201103L\n+\n+#error \"This is not a C++11 compiler\"\n+\n+#else\n+\n+namespace cxx11\n+{\n+\n+  namespace test_static_assert\n+  {\n+\n+    template <typename T>\n+    struct check\n+    {\n+      static_assert(sizeof(int) <= sizeof(T), \"not big enough\");\n+    };\n+\n+  }\n+\n+  namespace test_final_override\n+  {\n+\n+    struct Base\n+    {\n+      virtual ~Base() {}\n+      virtual void f() {}\n+    };\n+\n+    struct Derived : public Base\n+    {\n+      virtual ~Derived() override {}\n+      virtual void f() override {}\n+    };\n+\n+  }\n+\n+  namespace test_double_right_angle_brackets\n+  {\n+\n+    template < typename T >\n+    struct check {};\n+\n+    typedef check<void> single_type;\n+    typedef check<check<void>> double_type;\n+    typedef check<check<check<void>>> triple_type;\n+    typedef check<check<check<check<void>>>> quadruple_type;\n+\n+  }\n+\n+  namespace test_decltype\n+  {\n+\n+    int\n+    f()\n+    {\n+      int a = 1;\n+      decltype(a) b = 2;\n+      return a + b;\n+    }\n+\n+  }\n+\n+  namespace test_type_deduction\n+  {\n+\n+    template < typename T1, typename T2 >\n+    struct is_same\n+    {\n+      static const bool value = false;\n+    };\n+\n+    template < typename T >\n+    struct is_same<T, T>\n+    {\n+      static const bool value = true;\n+    };\n+\n+    template < typename T1, typename T2 >\n+    auto\n+    add(T1 a1, T2 a2) -> decltype(a1 + a2)\n+    {\n+      return a1 + a2;\n+    }\n+\n+    int\n+    test(const int c, volatile int v)\n+    {\n+      static_assert(is_same<int, decltype(0)>::value == true, \"\");\n+      static_assert(is_same<int, decltype(c)>::value == false, \"\");\n+      static_assert(is_same<int, decltype(v)>::value == false, \"\");\n+      auto ac = c;\n+      auto av = v;\n+      auto sumi = ac + av + 'x';\n+      auto sumf = ac + av + 1.0;\n+      static_assert(is_same<int, decltype(ac)>::value == true, \"\");\n+      static_assert(is_same<int, decltype(av)>::value == true, \"\");\n+      static_assert(is_same<int, decltype(sumi)>::value == true, \"\");\n+      static_assert(is_same<int, decltype(sumf)>::value == false, \"\");\n+      static_assert(is_same<int, decltype(add(c, v))>::value == true, \"\");\n+      return (sumf > 0.0) ? sumi : add(c, v);\n+    }\n+\n+  }\n+\n+  namespace test_noexcept\n+  {\n+\n+    int f() { return 0; }\n+    int g() noexcept { return 0; }\n+\n+    static_assert(noexcept(f()) == false, \"\");\n+    static_assert(noexcept(g()) == true, \"\");\n+\n+  }\n+\n+  namespace test_constexpr\n+  {\n+\n+    template < typename CharT >\n+    unsigned long constexpr\n+    strlen_c_r(const CharT *const s, const unsigned long acc) noexcept\n+    {\n+      return *s ? strlen_c_r(s + 1, acc + 1) : acc;\n+    }\n+\n+    template < typename CharT >\n+    unsigned long constexpr\n+    strlen_c(const CharT *const s) noexcept\n+    {\n+      return strlen_c_r(s, 0UL);\n+    }\n+\n+    static_assert(strlen_c(\"\") == 0UL, \"\");\n+    static_assert(strlen_c(\"1\") == 1UL, \"\");\n+    static_assert(strlen_c(\"example\") == 7UL, \"\");\n+    static_assert(strlen_c(\"another\\0example\") == 7UL, \"\");\n+\n+  }\n+\n+  namespace test_rvalue_references\n+  {\n+\n+    template < int N >\n+    struct answer\n+    {\n+      static constexpr int value = N;\n+    };\n+\n+    answer<1> f(int&)       { return answer<1>(); }\n+    answer<2> f(const int&) { return answer<2>(); }\n+    answer<3> f(int&&)      { return answer<3>(); }\n+\n+    void\n+    test()\n+    {\n+      int i = 0;\n+      const int c = 0;\n+      static_assert(decltype(f(i))::value == 1, \"\");\n+      static_assert(decltype(f(c))::value == 2, \"\");\n+      static_assert(decltype(f(0))::value == 3, \"\");\n+    }\n+\n+  }\n+\n+  namespace test_uniform_initialization\n+  {\n+\n+    struct test\n+    {\n+      static const int zero {};\n+      static const int one {1};\n+    };\n+\n+    static_assert(test::zero == 0, \"\");\n+    static_assert(test::one == 1, \"\");\n+\n+  }\n+\n+  namespace test_lambdas\n+  {\n+\n+    void\n+    test1()\n+    {\n+      auto lambda1 = [](){};\n+      auto lambda2 = lambda1;\n+      lambda1();\n+      lambda2();\n+    }\n+\n+    int\n+    test2()\n+    {\n+      auto a = [](int i, int j){ return i + j; }(1, 2);\n+      auto b = []() -> int { return '0'; }();\n+      auto c = [=](){ return a + b; }();\n+      auto d = [&](){ return c; }();\n+      auto e = [a, &b](int x) mutable {\n+        const auto identity = [](int y){ return y; };\n+        for (auto i = 0; i < a; ++i)\n+          a += b--;\n+        return x + identity(a + b);\n+      }(0);\n+      return a + b + c + d + e;\n+    }\n+\n+    int\n+    test3()\n+    {\n+      const auto nullary = [](){ return 0; };\n+      const auto unary = [](int x){ return x; };\n+      using nullary_t = decltype(nullary);\n+      using unary_t = decltype(unary);\n+      const auto higher1st = [](nullary_t f){ return f(); };\n+      const auto higher2nd = [unary](nullary_t f1){\n+        return [unary, f1](unary_t f2){ return f2(unary(f1())); };\n+      };\n+      return higher1st(nullary) + higher2nd(nullary)(unary);\n+    }\n+\n+  }\n+\n+  namespace test_variadic_templates\n+  {\n+\n+    template <int...>\n+    struct sum;\n+\n+    template <int N0, int... N1toN>\n+    struct sum<N0, N1toN...>\n+    {\n+      static constexpr auto value = N0 + sum<N1toN...>::value;\n+    };\n+\n+    template <>\n+    struct sum<>\n+    {\n+      static constexpr auto value = 0;\n+    };\n+\n+    static_assert(sum<>::value == 0, \"\");\n+    static_assert(sum<1>::value == 1, \"\");\n+    static_assert(sum<23>::value == 23, \"\");\n+    static_assert(sum<1, 2>::value == 3, \"\");\n+    static_assert(sum<5, 5, 11>::value == 21, \"\");\n+    static_assert(sum<2, 3, 5, 7, 11, 13>::value == 41, \"\");\n+\n+  }\n+\n+  // http://stackoverflow.com/questions/13728184/template-aliases-and-sfinae\n+  // Clang 3.1 fails with headers of libstd++ 4.8.3 when using std::function\n+  // because of this.\n+  namespace test_template_alias_sfinae\n+  {\n+\n+    struct foo {};\n+\n+    template<typename T>\n+    using member = typename T::member_type;\n+\n+    template<typename T>\n+    void func(...) {}\n+\n+    template<typename T>\n+    void func(member<T>*) {}\n+\n+    void test();\n+\n+    void test() { func<foo>(0); }\n+\n+  }\n+\n+}  // namespace cxx11\n+\n+#endif  // __cplusplus >= 201103L\n+\n+\n+\n+_ACEOF\n+if ac_fn_cxx_try_compile \"$LINENO\"; then :\n+  eval $cachevar=yes\n+else\n+  eval $cachevar=no\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+         CXX=\"$ac_save_CXX\"\n+fi\n+eval ac_res=\\$$cachevar\n+\t       { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_res\" >&5\n+$as_echo \"$ac_res\" >&6; }\n+      if eval test x\\$$cachevar = xyes; then\n+        CXX=\"$CXX $switch\"\n+        if test -n \"$CXXCPP\" ; then\n+          CXXCPP=\"$CXXCPP $switch\"\n+        fi\n+        ac_success=yes\n+        break\n+      fi\n+    done\n+  fi\n+\n+    if test x$ac_success = xno; then\n+                for alternative in ${ax_cxx_compile_alternatives}; do\n+      for switch in -std=c++${alternative} +std=c++${alternative} \"-h std=c++${alternative}\"; do\n+        cachevar=`$as_echo \"ax_cv_cxx_compile_cxx11_$switch\" | $as_tr_sh`\n+        { $as_echo \"$as_me:${as_lineno-$LINENO}: checking whether $CXX supports C++11 features with $switch\" >&5\n+$as_echo_n \"checking whether $CXX supports C++11 features with $switch... \" >&6; }\n+if eval \\${$cachevar+:} false; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  ac_save_CXX=\"$CXX\"\n+           CXX=\"$CXX $switch\"\n+           cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+\n+\n+// If the compiler admits that it is not ready for C++11, why torture it?\n+// Hopefully, this will speed up the test.\n+\n+#ifndef __cplusplus\n+\n+#error \"This is not a C++ compiler\"\n+\n+#elif __cplusplus < 201103L\n+\n+#error \"This is not a C++11 compiler\"\n+\n+#else\n+\n+namespace cxx11\n+{\n+\n+  namespace test_static_assert\n+  {\n+\n+    template <typename T>\n+    struct check\n+    {\n+      static_assert(sizeof(int) <= sizeof(T), \"not big enough\");\n+    };\n+\n+  }\n+\n+  namespace test_final_override\n+  {\n+\n+    struct Base\n+    {\n+      virtual ~Base() {}\n+      virtual void f() {}\n+    };\n+\n+    struct Derived : public Base\n+    {\n+      virtual ~Derived() override {}\n+      virtual void f() override {}\n+    };\n+\n+  }\n+\n+  namespace test_double_right_angle_brackets\n+  {\n+\n+    template < typename T >\n+    struct check {};\n+\n+    typedef check<void> single_type;\n+    typedef check<check<void>> double_type;\n+    typedef check<check<check<void>>> triple_type;\n+    typedef check<check<check<check<void>>>> quadruple_type;\n+\n+  }\n+\n+  namespace test_decltype\n+  {\n+\n+    int\n+    f()\n+    {\n+      int a = 1;\n+      decltype(a) b = 2;\n+      return a + b;\n+    }\n+\n+  }\n+\n+  namespace test_type_deduction\n+  {\n+\n+    template < typename T1, typename T2 >\n+    struct is_same\n+    {\n+      static const bool value = false;\n+    };\n+\n+    template < typename T >\n+    struct is_same<T, T>\n+    {\n+      static const bool value = true;\n+    };\n+\n+    template < typename T1, typename T2 >\n+    auto\n+    add(T1 a1, T2 a2) -> decltype(a1 + a2)\n+    {\n+      return a1 + a2;\n+    }\n+\n+    int\n+    test(const int c, volatile int v)\n+    {\n+      static_assert(is_same<int, decltype(0)>::value == true, \"\");\n+      static_assert(is_same<int, decltype(c)>::value == false, \"\");\n+      static_assert(is_same<int, decltype(v)>::value == false, \"\");\n+      auto ac = c;\n+      auto av = v;\n+      auto sumi = ac + av + 'x';\n+      auto sumf = ac + av + 1.0;\n+      static_assert(is_same<int, decltype(ac)>::value == true, \"\");\n+      static_assert(is_same<int, decltype(av)>::value == true, \"\");\n+      static_assert(is_same<int, decltype(sumi)>::value == true, \"\");\n+      static_assert(is_same<int, decltype(sumf)>::value == false, \"\");\n+      static_assert(is_same<int, decltype(add(c, v))>::value == true, \"\");\n+      return (sumf > 0.0) ? sumi : add(c, v);\n+    }\n+\n+  }\n+\n+  namespace test_noexcept\n+  {\n+\n+    int f() { return 0; }\n+    int g() noexcept { return 0; }\n+\n+    static_assert(noexcept(f()) == false, \"\");\n+    static_assert(noexcept(g()) == true, \"\");\n+\n+  }\n+\n+  namespace test_constexpr\n+  {\n+\n+    template < typename CharT >\n+    unsigned long constexpr\n+    strlen_c_r(const CharT *const s, const unsigned long acc) noexcept\n+    {\n+      return *s ? strlen_c_r(s + 1, acc + 1) : acc;\n+    }\n+\n+    template < typename CharT >\n+    unsigned long constexpr\n+    strlen_c(const CharT *const s) noexcept\n+    {\n+      return strlen_c_r(s, 0UL);\n+    }\n+\n+    static_assert(strlen_c(\"\") == 0UL, \"\");\n+    static_assert(strlen_c(\"1\") == 1UL, \"\");\n+    static_assert(strlen_c(\"example\") == 7UL, \"\");\n+    static_assert(strlen_c(\"another\\0example\") == 7UL, \"\");\n+\n+  }\n+\n+  namespace test_rvalue_references\n+  {\n+\n+    template < int N >\n+    struct answer\n+    {\n+      static constexpr int value = N;\n+    };\n+\n+    answer<1> f(int&)       { return answer<1>(); }\n+    answer<2> f(const int&) { return answer<2>(); }\n+    answer<3> f(int&&)      { return answer<3>(); }\n+\n+    void\n+    test()\n+    {\n+      int i = 0;\n+      const int c = 0;\n+      static_assert(decltype(f(i))::value == 1, \"\");\n+      static_assert(decltype(f(c))::value == 2, \"\");\n+      static_assert(decltype(f(0))::value == 3, \"\");\n+    }\n+\n+  }\n+\n+  namespace test_uniform_initialization\n+  {\n+\n+    struct test\n+    {\n+      static const int zero {};\n+      static const int one {1};\n+    };\n+\n+    static_assert(test::zero == 0, \"\");\n+    static_assert(test::one == 1, \"\");\n+\n+  }\n+\n+  namespace test_lambdas\n+  {\n+\n+    void\n+    test1()\n+    {\n+      auto lambda1 = [](){};\n+      auto lambda2 = lambda1;\n+      lambda1();\n+      lambda2();\n+    }\n+\n+    int\n+    test2()\n+    {\n+      auto a = [](int i, int j){ return i + j; }(1, 2);\n+      auto b = []() -> int { return '0'; }();\n+      auto c = [=](){ return a + b; }();\n+      auto d = [&](){ return c; }();\n+      auto e = [a, &b](int x) mutable {\n+        const auto identity = [](int y){ return y; };\n+        for (auto i = 0; i < a; ++i)\n+          a += b--;\n+        return x + identity(a + b);\n+      }(0);\n+      return a + b + c + d + e;\n+    }\n+\n+    int\n+    test3()\n+    {\n+      const auto nullary = [](){ return 0; };\n+      const auto unary = [](int x){ return x; };\n+      using nullary_t = decltype(nullary);\n+      using unary_t = decltype(unary);\n+      const auto higher1st = [](nullary_t f){ return f(); };\n+      const auto higher2nd = [unary](nullary_t f1){\n+        return [unary, f1](unary_t f2){ return f2(unary(f1())); };\n+      };\n+      return higher1st(nullary) + higher2nd(nullary)(unary);\n+    }\n+\n+  }\n+\n+  namespace test_variadic_templates\n+  {\n+\n+    template <int...>\n+    struct sum;\n+\n+    template <int N0, int... N1toN>\n+    struct sum<N0, N1toN...>\n+    {\n+      static constexpr auto value = N0 + sum<N1toN...>::value;\n+    };\n+\n+    template <>\n+    struct sum<>\n+    {\n+      static constexpr auto value = 0;\n+    };\n+\n+    static_assert(sum<>::value == 0, \"\");\n+    static_assert(sum<1>::value == 1, \"\");\n+    static_assert(sum<23>::value == 23, \"\");\n+    static_assert(sum<1, 2>::value == 3, \"\");\n+    static_assert(sum<5, 5, 11>::value == 21, \"\");\n+    static_assert(sum<2, 3, 5, 7, 11, 13>::value == 41, \"\");\n+\n+  }\n+\n+  // http://stackoverflow.com/questions/13728184/template-aliases-and-sfinae\n+  // Clang 3.1 fails with headers of libstd++ 4.8.3 when using std::function\n+  // because of this.\n+  namespace test_template_alias_sfinae\n+  {\n+\n+    struct foo {};\n+\n+    template<typename T>\n+    using member = typename T::member_type;\n+\n+    template<typename T>\n+    void func(...) {}\n+\n+    template<typename T>\n+    void func(member<T>*) {}\n+\n+    void test();\n+\n+    void test() { func<foo>(0); }\n+\n+  }\n+\n+}  // namespace cxx11\n+\n+#endif  // __cplusplus >= 201103L\n+\n+\n+\n+_ACEOF\n+if ac_fn_cxx_try_compile \"$LINENO\"; then :\n+  eval $cachevar=yes\n+else\n+  eval $cachevar=no\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+           CXX=\"$ac_save_CXX\"\n+fi\n+eval ac_res=\\$$cachevar\n+\t       { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_res\" >&5\n+$as_echo \"$ac_res\" >&6; }\n+        if eval test x\\$$cachevar = xyes; then\n+          CXX=\"$CXX $switch\"\n+          if test -n \"$CXXCPP\" ; then\n+            CXXCPP=\"$CXXCPP $switch\"\n+          fi\n+          ac_success=yes\n+          break\n+        fi\n+      done\n+      if test x$ac_success = xyes; then\n+        break\n+      fi\n+    done\n+  fi\n+  ac_ext=c\n+ac_cpp='$CPP $CPPFLAGS'\n+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'\n+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'\n+ac_compiler_gnu=$ac_cv_c_compiler_gnu\n+\n+  if test x$ax_cxx_compile_cxx11_required = xtrue; then\n+    if test x$ac_success = xno; then\n+      as_fn_error $? \"*** A compiler with support for C++11 language features is required.\" \"$LINENO\" 5\n+    fi\n+  fi\n+  if test x$ac_success = xno; then\n+    HAVE_CXX11=0\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: No compiler with C++11 support was found\" >&5\n+$as_echo \"$as_me: No compiler with C++11 support was found\" >&6;}\n+  else\n+    HAVE_CXX11=1\n+\n+$as_echo \"#define HAVE_CXX11 1\" >>confdefs.h\n+\n+  fi\n+\n+\n fi\n \n # Used for setting $lt_cv_objdir\n@@ -6489,7 +7483,8 @@ $as_echo \"$as_me: WARNING: GNAT is required to build $language\" >&2;}\n         esac\n \n         # Disable jit if -enable-host-shared not specified\n-        # but not if building for Mingw\n+        # but not if building for Mingw. All code in Windows\n+        # is position independent code (PIC).\n         case $target in\n           *mingw*) ;;\n           *)"}, {"sha": "1a53ed418e4d97606356b14a17b50186c79adcd3", "filename": "configure.ac", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffac9597256823612fb63bbab0f9ba3c11255e6b/configure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffac9597256823612fb63bbab0f9ba3c11255e6b/configure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure.ac?ref=ffac9597256823612fb63bbab0f9ba3c11255e6b", "patch": "@@ -23,6 +23,7 @@ m4_include(config/acx.m4)\n m4_include(config/override.m4)\n m4_include(config/proginstall.m4)\n m4_include(config/elf.m4)\n+m4_include(config/ax_cxx_compile_stdcxx.m4)\n m4_include([libtool.m4])\n m4_include([ltoptions.m4])\n m4_include([ltsugar.m4])\n@@ -1463,9 +1464,12 @@ case \"$have_compiler:$host:$target:$enable_bootstrap\" in\n esac\n \n # When bootstrapping with GCC, build stage 1 in C++11 mode to ensure that a\n-# C++11 compiler can still start the bootstrap.\n+# C++11 compiler can still start the bootstrap.  Otherwise, if building GCC,\n+# require C++11 (or higher).\n if test \"$enable_bootstrap:$GXX\" = \"yes:yes\"; then\n   CXX=\"$CXX -std=c++11\"\n+elif test \"$have_compiler\" = yes; then\n+  AX_CXX_COMPILE_STDCXX(11)\n fi\n \n # Used for setting $lt_cv_objdir"}, {"sha": "1737d59d1cb5469c4c68ea4cd71a2cce0252041c", "filename": "gcc/aclocal.m4", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffac9597256823612fb63bbab0f9ba3c11255e6b/gcc%2Faclocal.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffac9597256823612fb63bbab0f9ba3c11255e6b/gcc%2Faclocal.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Faclocal.m4?ref=ffac9597256823612fb63bbab0f9ba3c11255e6b", "patch": "@@ -18,7 +18,6 @@ m4_include([../ltsugar.m4])\n m4_include([../ltversion.m4])\n m4_include([../lt~obsolete.m4])\n m4_include([../config/acx.m4])\n-m4_include([../config/ax_cxx_compile_stdcxx.m4])\n m4_include([../config/cet.m4])\n m4_include([../config/codeset.m4])\n m4_include([../config/depstand.m4])"}, {"sha": "629c7c7e153b9fc0d8f451702ed96893917c01bf", "filename": "gcc/configure", "status": "modified", "additions": 2, "deletions": 995, "changes": 997, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffac9597256823612fb63bbab0f9ba3c11255e6b/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffac9597256823612fb63bbab0f9ba3c11255e6b/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=ffac9597256823612fb63bbab0f9ba3c11255e6b", "patch": "@@ -847,7 +847,6 @@ c_loose_warn\n loose_warn\n aliasing_flags\n CPP\n-HAVE_CXX11\n EGREP\n GREP\n CXXCPP\n@@ -5710,998 +5709,6 @@ $as_echo \"$ac_cv_safe_to_define___extensions__\" >&6; }\n \n \n \n-  ax_cxx_compile_alternatives=\"11 0x\"    ax_cxx_compile_cxx11_required=true\n-  ac_ext=cpp\n-ac_cpp='$CXXCPP $CPPFLAGS'\n-ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'\n-ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'\n-ac_compiler_gnu=$ac_cv_cxx_compiler_gnu\n-  ac_success=no\n-\n-      { $as_echo \"$as_me:${as_lineno-$LINENO}: checking whether $CXX supports C++11 features by default\" >&5\n-$as_echo_n \"checking whether $CXX supports C++11 features by default... \" >&6; }\n-if ${ax_cv_cxx_compile_cxx11+:} false; then :\n-  $as_echo_n \"(cached) \" >&6\n-else\n-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n-/* end confdefs.h.  */\n-\n-\n-// If the compiler admits that it is not ready for C++11, why torture it?\n-// Hopefully, this will speed up the test.\n-\n-#ifndef __cplusplus\n-\n-#error \"This is not a C++ compiler\"\n-\n-#elif __cplusplus < 201103L\n-\n-#error \"This is not a C++11 compiler\"\n-\n-#else\n-\n-namespace cxx11\n-{\n-\n-  namespace test_static_assert\n-  {\n-\n-    template <typename T>\n-    struct check\n-    {\n-      static_assert(sizeof(int) <= sizeof(T), \"not big enough\");\n-    };\n-\n-  }\n-\n-  namespace test_final_override\n-  {\n-\n-    struct Base\n-    {\n-      virtual ~Base() {}\n-      virtual void f() {}\n-    };\n-\n-    struct Derived : public Base\n-    {\n-      virtual ~Derived() override {}\n-      virtual void f() override {}\n-    };\n-\n-  }\n-\n-  namespace test_double_right_angle_brackets\n-  {\n-\n-    template < typename T >\n-    struct check {};\n-\n-    typedef check<void> single_type;\n-    typedef check<check<void>> double_type;\n-    typedef check<check<check<void>>> triple_type;\n-    typedef check<check<check<check<void>>>> quadruple_type;\n-\n-  }\n-\n-  namespace test_decltype\n-  {\n-\n-    int\n-    f()\n-    {\n-      int a = 1;\n-      decltype(a) b = 2;\n-      return a + b;\n-    }\n-\n-  }\n-\n-  namespace test_type_deduction\n-  {\n-\n-    template < typename T1, typename T2 >\n-    struct is_same\n-    {\n-      static const bool value = false;\n-    };\n-\n-    template < typename T >\n-    struct is_same<T, T>\n-    {\n-      static const bool value = true;\n-    };\n-\n-    template < typename T1, typename T2 >\n-    auto\n-    add(T1 a1, T2 a2) -> decltype(a1 + a2)\n-    {\n-      return a1 + a2;\n-    }\n-\n-    int\n-    test(const int c, volatile int v)\n-    {\n-      static_assert(is_same<int, decltype(0)>::value == true, \"\");\n-      static_assert(is_same<int, decltype(c)>::value == false, \"\");\n-      static_assert(is_same<int, decltype(v)>::value == false, \"\");\n-      auto ac = c;\n-      auto av = v;\n-      auto sumi = ac + av + 'x';\n-      auto sumf = ac + av + 1.0;\n-      static_assert(is_same<int, decltype(ac)>::value == true, \"\");\n-      static_assert(is_same<int, decltype(av)>::value == true, \"\");\n-      static_assert(is_same<int, decltype(sumi)>::value == true, \"\");\n-      static_assert(is_same<int, decltype(sumf)>::value == false, \"\");\n-      static_assert(is_same<int, decltype(add(c, v))>::value == true, \"\");\n-      return (sumf > 0.0) ? sumi : add(c, v);\n-    }\n-\n-  }\n-\n-  namespace test_noexcept\n-  {\n-\n-    int f() { return 0; }\n-    int g() noexcept { return 0; }\n-\n-    static_assert(noexcept(f()) == false, \"\");\n-    static_assert(noexcept(g()) == true, \"\");\n-\n-  }\n-\n-  namespace test_constexpr\n-  {\n-\n-    template < typename CharT >\n-    unsigned long constexpr\n-    strlen_c_r(const CharT *const s, const unsigned long acc) noexcept\n-    {\n-      return *s ? strlen_c_r(s + 1, acc + 1) : acc;\n-    }\n-\n-    template < typename CharT >\n-    unsigned long constexpr\n-    strlen_c(const CharT *const s) noexcept\n-    {\n-      return strlen_c_r(s, 0UL);\n-    }\n-\n-    static_assert(strlen_c(\"\") == 0UL, \"\");\n-    static_assert(strlen_c(\"1\") == 1UL, \"\");\n-    static_assert(strlen_c(\"example\") == 7UL, \"\");\n-    static_assert(strlen_c(\"another\\0example\") == 7UL, \"\");\n-\n-  }\n-\n-  namespace test_rvalue_references\n-  {\n-\n-    template < int N >\n-    struct answer\n-    {\n-      static constexpr int value = N;\n-    };\n-\n-    answer<1> f(int&)       { return answer<1>(); }\n-    answer<2> f(const int&) { return answer<2>(); }\n-    answer<3> f(int&&)      { return answer<3>(); }\n-\n-    void\n-    test()\n-    {\n-      int i = 0;\n-      const int c = 0;\n-      static_assert(decltype(f(i))::value == 1, \"\");\n-      static_assert(decltype(f(c))::value == 2, \"\");\n-      static_assert(decltype(f(0))::value == 3, \"\");\n-    }\n-\n-  }\n-\n-  namespace test_uniform_initialization\n-  {\n-\n-    struct test\n-    {\n-      static const int zero {};\n-      static const int one {1};\n-    };\n-\n-    static_assert(test::zero == 0, \"\");\n-    static_assert(test::one == 1, \"\");\n-\n-  }\n-\n-  namespace test_lambdas\n-  {\n-\n-    void\n-    test1()\n-    {\n-      auto lambda1 = [](){};\n-      auto lambda2 = lambda1;\n-      lambda1();\n-      lambda2();\n-    }\n-\n-    int\n-    test2()\n-    {\n-      auto a = [](int i, int j){ return i + j; }(1, 2);\n-      auto b = []() -> int { return '0'; }();\n-      auto c = [=](){ return a + b; }();\n-      auto d = [&](){ return c; }();\n-      auto e = [a, &b](int x) mutable {\n-        const auto identity = [](int y){ return y; };\n-        for (auto i = 0; i < a; ++i)\n-          a += b--;\n-        return x + identity(a + b);\n-      }(0);\n-      return a + b + c + d + e;\n-    }\n-\n-    int\n-    test3()\n-    {\n-      const auto nullary = [](){ return 0; };\n-      const auto unary = [](int x){ return x; };\n-      using nullary_t = decltype(nullary);\n-      using unary_t = decltype(unary);\n-      const auto higher1st = [](nullary_t f){ return f(); };\n-      const auto higher2nd = [unary](nullary_t f1){\n-        return [unary, f1](unary_t f2){ return f2(unary(f1())); };\n-      };\n-      return higher1st(nullary) + higher2nd(nullary)(unary);\n-    }\n-\n-  }\n-\n-  namespace test_variadic_templates\n-  {\n-\n-    template <int...>\n-    struct sum;\n-\n-    template <int N0, int... N1toN>\n-    struct sum<N0, N1toN...>\n-    {\n-      static constexpr auto value = N0 + sum<N1toN...>::value;\n-    };\n-\n-    template <>\n-    struct sum<>\n-    {\n-      static constexpr auto value = 0;\n-    };\n-\n-    static_assert(sum<>::value == 0, \"\");\n-    static_assert(sum<1>::value == 1, \"\");\n-    static_assert(sum<23>::value == 23, \"\");\n-    static_assert(sum<1, 2>::value == 3, \"\");\n-    static_assert(sum<5, 5, 11>::value == 21, \"\");\n-    static_assert(sum<2, 3, 5, 7, 11, 13>::value == 41, \"\");\n-\n-  }\n-\n-  // http://stackoverflow.com/questions/13728184/template-aliases-and-sfinae\n-  // Clang 3.1 fails with headers of libstd++ 4.8.3 when using std::function\n-  // because of this.\n-  namespace test_template_alias_sfinae\n-  {\n-\n-    struct foo {};\n-\n-    template<typename T>\n-    using member = typename T::member_type;\n-\n-    template<typename T>\n-    void func(...) {}\n-\n-    template<typename T>\n-    void func(member<T>*) {}\n-\n-    void test();\n-\n-    void test() { func<foo>(0); }\n-\n-  }\n-\n-}  // namespace cxx11\n-\n-#endif  // __cplusplus >= 201103L\n-\n-\n-\n-_ACEOF\n-if ac_fn_cxx_try_compile \"$LINENO\"; then :\n-  ax_cv_cxx_compile_cxx11=yes\n-else\n-  ax_cv_cxx_compile_cxx11=no\n-fi\n-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n-fi\n-{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ax_cv_cxx_compile_cxx11\" >&5\n-$as_echo \"$ax_cv_cxx_compile_cxx11\" >&6; }\n-    if test x$ax_cv_cxx_compile_cxx11 = xyes; then\n-      ac_success=yes\n-    fi\n-\n-    if test x$ac_success = xno; then\n-    for alternative in ${ax_cxx_compile_alternatives}; do\n-      switch=\"-std=gnu++${alternative}\"\n-      cachevar=`$as_echo \"ax_cv_cxx_compile_cxx11_$switch\" | $as_tr_sh`\n-      { $as_echo \"$as_me:${as_lineno-$LINENO}: checking whether $CXX supports C++11 features with $switch\" >&5\n-$as_echo_n \"checking whether $CXX supports C++11 features with $switch... \" >&6; }\n-if eval \\${$cachevar+:} false; then :\n-  $as_echo_n \"(cached) \" >&6\n-else\n-  ac_save_CXX=\"$CXX\"\n-         CXX=\"$CXX $switch\"\n-         cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n-/* end confdefs.h.  */\n-\n-\n-// If the compiler admits that it is not ready for C++11, why torture it?\n-// Hopefully, this will speed up the test.\n-\n-#ifndef __cplusplus\n-\n-#error \"This is not a C++ compiler\"\n-\n-#elif __cplusplus < 201103L\n-\n-#error \"This is not a C++11 compiler\"\n-\n-#else\n-\n-namespace cxx11\n-{\n-\n-  namespace test_static_assert\n-  {\n-\n-    template <typename T>\n-    struct check\n-    {\n-      static_assert(sizeof(int) <= sizeof(T), \"not big enough\");\n-    };\n-\n-  }\n-\n-  namespace test_final_override\n-  {\n-\n-    struct Base\n-    {\n-      virtual ~Base() {}\n-      virtual void f() {}\n-    };\n-\n-    struct Derived : public Base\n-    {\n-      virtual ~Derived() override {}\n-      virtual void f() override {}\n-    };\n-\n-  }\n-\n-  namespace test_double_right_angle_brackets\n-  {\n-\n-    template < typename T >\n-    struct check {};\n-\n-    typedef check<void> single_type;\n-    typedef check<check<void>> double_type;\n-    typedef check<check<check<void>>> triple_type;\n-    typedef check<check<check<check<void>>>> quadruple_type;\n-\n-  }\n-\n-  namespace test_decltype\n-  {\n-\n-    int\n-    f()\n-    {\n-      int a = 1;\n-      decltype(a) b = 2;\n-      return a + b;\n-    }\n-\n-  }\n-\n-  namespace test_type_deduction\n-  {\n-\n-    template < typename T1, typename T2 >\n-    struct is_same\n-    {\n-      static const bool value = false;\n-    };\n-\n-    template < typename T >\n-    struct is_same<T, T>\n-    {\n-      static const bool value = true;\n-    };\n-\n-    template < typename T1, typename T2 >\n-    auto\n-    add(T1 a1, T2 a2) -> decltype(a1 + a2)\n-    {\n-      return a1 + a2;\n-    }\n-\n-    int\n-    test(const int c, volatile int v)\n-    {\n-      static_assert(is_same<int, decltype(0)>::value == true, \"\");\n-      static_assert(is_same<int, decltype(c)>::value == false, \"\");\n-      static_assert(is_same<int, decltype(v)>::value == false, \"\");\n-      auto ac = c;\n-      auto av = v;\n-      auto sumi = ac + av + 'x';\n-      auto sumf = ac + av + 1.0;\n-      static_assert(is_same<int, decltype(ac)>::value == true, \"\");\n-      static_assert(is_same<int, decltype(av)>::value == true, \"\");\n-      static_assert(is_same<int, decltype(sumi)>::value == true, \"\");\n-      static_assert(is_same<int, decltype(sumf)>::value == false, \"\");\n-      static_assert(is_same<int, decltype(add(c, v))>::value == true, \"\");\n-      return (sumf > 0.0) ? sumi : add(c, v);\n-    }\n-\n-  }\n-\n-  namespace test_noexcept\n-  {\n-\n-    int f() { return 0; }\n-    int g() noexcept { return 0; }\n-\n-    static_assert(noexcept(f()) == false, \"\");\n-    static_assert(noexcept(g()) == true, \"\");\n-\n-  }\n-\n-  namespace test_constexpr\n-  {\n-\n-    template < typename CharT >\n-    unsigned long constexpr\n-    strlen_c_r(const CharT *const s, const unsigned long acc) noexcept\n-    {\n-      return *s ? strlen_c_r(s + 1, acc + 1) : acc;\n-    }\n-\n-    template < typename CharT >\n-    unsigned long constexpr\n-    strlen_c(const CharT *const s) noexcept\n-    {\n-      return strlen_c_r(s, 0UL);\n-    }\n-\n-    static_assert(strlen_c(\"\") == 0UL, \"\");\n-    static_assert(strlen_c(\"1\") == 1UL, \"\");\n-    static_assert(strlen_c(\"example\") == 7UL, \"\");\n-    static_assert(strlen_c(\"another\\0example\") == 7UL, \"\");\n-\n-  }\n-\n-  namespace test_rvalue_references\n-  {\n-\n-    template < int N >\n-    struct answer\n-    {\n-      static constexpr int value = N;\n-    };\n-\n-    answer<1> f(int&)       { return answer<1>(); }\n-    answer<2> f(const int&) { return answer<2>(); }\n-    answer<3> f(int&&)      { return answer<3>(); }\n-\n-    void\n-    test()\n-    {\n-      int i = 0;\n-      const int c = 0;\n-      static_assert(decltype(f(i))::value == 1, \"\");\n-      static_assert(decltype(f(c))::value == 2, \"\");\n-      static_assert(decltype(f(0))::value == 3, \"\");\n-    }\n-\n-  }\n-\n-  namespace test_uniform_initialization\n-  {\n-\n-    struct test\n-    {\n-      static const int zero {};\n-      static const int one {1};\n-    };\n-\n-    static_assert(test::zero == 0, \"\");\n-    static_assert(test::one == 1, \"\");\n-\n-  }\n-\n-  namespace test_lambdas\n-  {\n-\n-    void\n-    test1()\n-    {\n-      auto lambda1 = [](){};\n-      auto lambda2 = lambda1;\n-      lambda1();\n-      lambda2();\n-    }\n-\n-    int\n-    test2()\n-    {\n-      auto a = [](int i, int j){ return i + j; }(1, 2);\n-      auto b = []() -> int { return '0'; }();\n-      auto c = [=](){ return a + b; }();\n-      auto d = [&](){ return c; }();\n-      auto e = [a, &b](int x) mutable {\n-        const auto identity = [](int y){ return y; };\n-        for (auto i = 0; i < a; ++i)\n-          a += b--;\n-        return x + identity(a + b);\n-      }(0);\n-      return a + b + c + d + e;\n-    }\n-\n-    int\n-    test3()\n-    {\n-      const auto nullary = [](){ return 0; };\n-      const auto unary = [](int x){ return x; };\n-      using nullary_t = decltype(nullary);\n-      using unary_t = decltype(unary);\n-      const auto higher1st = [](nullary_t f){ return f(); };\n-      const auto higher2nd = [unary](nullary_t f1){\n-        return [unary, f1](unary_t f2){ return f2(unary(f1())); };\n-      };\n-      return higher1st(nullary) + higher2nd(nullary)(unary);\n-    }\n-\n-  }\n-\n-  namespace test_variadic_templates\n-  {\n-\n-    template <int...>\n-    struct sum;\n-\n-    template <int N0, int... N1toN>\n-    struct sum<N0, N1toN...>\n-    {\n-      static constexpr auto value = N0 + sum<N1toN...>::value;\n-    };\n-\n-    template <>\n-    struct sum<>\n-    {\n-      static constexpr auto value = 0;\n-    };\n-\n-    static_assert(sum<>::value == 0, \"\");\n-    static_assert(sum<1>::value == 1, \"\");\n-    static_assert(sum<23>::value == 23, \"\");\n-    static_assert(sum<1, 2>::value == 3, \"\");\n-    static_assert(sum<5, 5, 11>::value == 21, \"\");\n-    static_assert(sum<2, 3, 5, 7, 11, 13>::value == 41, \"\");\n-\n-  }\n-\n-  // http://stackoverflow.com/questions/13728184/template-aliases-and-sfinae\n-  // Clang 3.1 fails with headers of libstd++ 4.8.3 when using std::function\n-  // because of this.\n-  namespace test_template_alias_sfinae\n-  {\n-\n-    struct foo {};\n-\n-    template<typename T>\n-    using member = typename T::member_type;\n-\n-    template<typename T>\n-    void func(...) {}\n-\n-    template<typename T>\n-    void func(member<T>*) {}\n-\n-    void test();\n-\n-    void test() { func<foo>(0); }\n-\n-  }\n-\n-}  // namespace cxx11\n-\n-#endif  // __cplusplus >= 201103L\n-\n-\n-\n-_ACEOF\n-if ac_fn_cxx_try_compile \"$LINENO\"; then :\n-  eval $cachevar=yes\n-else\n-  eval $cachevar=no\n-fi\n-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n-         CXX=\"$ac_save_CXX\"\n-fi\n-eval ac_res=\\$$cachevar\n-\t       { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_res\" >&5\n-$as_echo \"$ac_res\" >&6; }\n-      if eval test x\\$$cachevar = xyes; then\n-        CXX=\"$CXX $switch\"\n-        if test -n \"$CXXCPP\" ; then\n-          CXXCPP=\"$CXXCPP $switch\"\n-        fi\n-        ac_success=yes\n-        break\n-      fi\n-    done\n-  fi\n-\n-    if test x$ac_success = xno; then\n-                for alternative in ${ax_cxx_compile_alternatives}; do\n-      for switch in -std=c++${alternative} +std=c++${alternative} \"-h std=c++${alternative}\"; do\n-        cachevar=`$as_echo \"ax_cv_cxx_compile_cxx11_$switch\" | $as_tr_sh`\n-        { $as_echo \"$as_me:${as_lineno-$LINENO}: checking whether $CXX supports C++11 features with $switch\" >&5\n-$as_echo_n \"checking whether $CXX supports C++11 features with $switch... \" >&6; }\n-if eval \\${$cachevar+:} false; then :\n-  $as_echo_n \"(cached) \" >&6\n-else\n-  ac_save_CXX=\"$CXX\"\n-           CXX=\"$CXX $switch\"\n-           cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n-/* end confdefs.h.  */\n-\n-\n-// If the compiler admits that it is not ready for C++11, why torture it?\n-// Hopefully, this will speed up the test.\n-\n-#ifndef __cplusplus\n-\n-#error \"This is not a C++ compiler\"\n-\n-#elif __cplusplus < 201103L\n-\n-#error \"This is not a C++11 compiler\"\n-\n-#else\n-\n-namespace cxx11\n-{\n-\n-  namespace test_static_assert\n-  {\n-\n-    template <typename T>\n-    struct check\n-    {\n-      static_assert(sizeof(int) <= sizeof(T), \"not big enough\");\n-    };\n-\n-  }\n-\n-  namespace test_final_override\n-  {\n-\n-    struct Base\n-    {\n-      virtual ~Base() {}\n-      virtual void f() {}\n-    };\n-\n-    struct Derived : public Base\n-    {\n-      virtual ~Derived() override {}\n-      virtual void f() override {}\n-    };\n-\n-  }\n-\n-  namespace test_double_right_angle_brackets\n-  {\n-\n-    template < typename T >\n-    struct check {};\n-\n-    typedef check<void> single_type;\n-    typedef check<check<void>> double_type;\n-    typedef check<check<check<void>>> triple_type;\n-    typedef check<check<check<check<void>>>> quadruple_type;\n-\n-  }\n-\n-  namespace test_decltype\n-  {\n-\n-    int\n-    f()\n-    {\n-      int a = 1;\n-      decltype(a) b = 2;\n-      return a + b;\n-    }\n-\n-  }\n-\n-  namespace test_type_deduction\n-  {\n-\n-    template < typename T1, typename T2 >\n-    struct is_same\n-    {\n-      static const bool value = false;\n-    };\n-\n-    template < typename T >\n-    struct is_same<T, T>\n-    {\n-      static const bool value = true;\n-    };\n-\n-    template < typename T1, typename T2 >\n-    auto\n-    add(T1 a1, T2 a2) -> decltype(a1 + a2)\n-    {\n-      return a1 + a2;\n-    }\n-\n-    int\n-    test(const int c, volatile int v)\n-    {\n-      static_assert(is_same<int, decltype(0)>::value == true, \"\");\n-      static_assert(is_same<int, decltype(c)>::value == false, \"\");\n-      static_assert(is_same<int, decltype(v)>::value == false, \"\");\n-      auto ac = c;\n-      auto av = v;\n-      auto sumi = ac + av + 'x';\n-      auto sumf = ac + av + 1.0;\n-      static_assert(is_same<int, decltype(ac)>::value == true, \"\");\n-      static_assert(is_same<int, decltype(av)>::value == true, \"\");\n-      static_assert(is_same<int, decltype(sumi)>::value == true, \"\");\n-      static_assert(is_same<int, decltype(sumf)>::value == false, \"\");\n-      static_assert(is_same<int, decltype(add(c, v))>::value == true, \"\");\n-      return (sumf > 0.0) ? sumi : add(c, v);\n-    }\n-\n-  }\n-\n-  namespace test_noexcept\n-  {\n-\n-    int f() { return 0; }\n-    int g() noexcept { return 0; }\n-\n-    static_assert(noexcept(f()) == false, \"\");\n-    static_assert(noexcept(g()) == true, \"\");\n-\n-  }\n-\n-  namespace test_constexpr\n-  {\n-\n-    template < typename CharT >\n-    unsigned long constexpr\n-    strlen_c_r(const CharT *const s, const unsigned long acc) noexcept\n-    {\n-      return *s ? strlen_c_r(s + 1, acc + 1) : acc;\n-    }\n-\n-    template < typename CharT >\n-    unsigned long constexpr\n-    strlen_c(const CharT *const s) noexcept\n-    {\n-      return strlen_c_r(s, 0UL);\n-    }\n-\n-    static_assert(strlen_c(\"\") == 0UL, \"\");\n-    static_assert(strlen_c(\"1\") == 1UL, \"\");\n-    static_assert(strlen_c(\"example\") == 7UL, \"\");\n-    static_assert(strlen_c(\"another\\0example\") == 7UL, \"\");\n-\n-  }\n-\n-  namespace test_rvalue_references\n-  {\n-\n-    template < int N >\n-    struct answer\n-    {\n-      static constexpr int value = N;\n-    };\n-\n-    answer<1> f(int&)       { return answer<1>(); }\n-    answer<2> f(const int&) { return answer<2>(); }\n-    answer<3> f(int&&)      { return answer<3>(); }\n-\n-    void\n-    test()\n-    {\n-      int i = 0;\n-      const int c = 0;\n-      static_assert(decltype(f(i))::value == 1, \"\");\n-      static_assert(decltype(f(c))::value == 2, \"\");\n-      static_assert(decltype(f(0))::value == 3, \"\");\n-    }\n-\n-  }\n-\n-  namespace test_uniform_initialization\n-  {\n-\n-    struct test\n-    {\n-      static const int zero {};\n-      static const int one {1};\n-    };\n-\n-    static_assert(test::zero == 0, \"\");\n-    static_assert(test::one == 1, \"\");\n-\n-  }\n-\n-  namespace test_lambdas\n-  {\n-\n-    void\n-    test1()\n-    {\n-      auto lambda1 = [](){};\n-      auto lambda2 = lambda1;\n-      lambda1();\n-      lambda2();\n-    }\n-\n-    int\n-    test2()\n-    {\n-      auto a = [](int i, int j){ return i + j; }(1, 2);\n-      auto b = []() -> int { return '0'; }();\n-      auto c = [=](){ return a + b; }();\n-      auto d = [&](){ return c; }();\n-      auto e = [a, &b](int x) mutable {\n-        const auto identity = [](int y){ return y; };\n-        for (auto i = 0; i < a; ++i)\n-          a += b--;\n-        return x + identity(a + b);\n-      }(0);\n-      return a + b + c + d + e;\n-    }\n-\n-    int\n-    test3()\n-    {\n-      const auto nullary = [](){ return 0; };\n-      const auto unary = [](int x){ return x; };\n-      using nullary_t = decltype(nullary);\n-      using unary_t = decltype(unary);\n-      const auto higher1st = [](nullary_t f){ return f(); };\n-      const auto higher2nd = [unary](nullary_t f1){\n-        return [unary, f1](unary_t f2){ return f2(unary(f1())); };\n-      };\n-      return higher1st(nullary) + higher2nd(nullary)(unary);\n-    }\n-\n-  }\n-\n-  namespace test_variadic_templates\n-  {\n-\n-    template <int...>\n-    struct sum;\n-\n-    template <int N0, int... N1toN>\n-    struct sum<N0, N1toN...>\n-    {\n-      static constexpr auto value = N0 + sum<N1toN...>::value;\n-    };\n-\n-    template <>\n-    struct sum<>\n-    {\n-      static constexpr auto value = 0;\n-    };\n-\n-    static_assert(sum<>::value == 0, \"\");\n-    static_assert(sum<1>::value == 1, \"\");\n-    static_assert(sum<23>::value == 23, \"\");\n-    static_assert(sum<1, 2>::value == 3, \"\");\n-    static_assert(sum<5, 5, 11>::value == 21, \"\");\n-    static_assert(sum<2, 3, 5, 7, 11, 13>::value == 41, \"\");\n-\n-  }\n-\n-  // http://stackoverflow.com/questions/13728184/template-aliases-and-sfinae\n-  // Clang 3.1 fails with headers of libstd++ 4.8.3 when using std::function\n-  // because of this.\n-  namespace test_template_alias_sfinae\n-  {\n-\n-    struct foo {};\n-\n-    template<typename T>\n-    using member = typename T::member_type;\n-\n-    template<typename T>\n-    void func(...) {}\n-\n-    template<typename T>\n-    void func(member<T>*) {}\n-\n-    void test();\n-\n-    void test() { func<foo>(0); }\n-\n-  }\n-\n-}  // namespace cxx11\n-\n-#endif  // __cplusplus >= 201103L\n-\n-\n-\n-_ACEOF\n-if ac_fn_cxx_try_compile \"$LINENO\"; then :\n-  eval $cachevar=yes\n-else\n-  eval $cachevar=no\n-fi\n-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n-           CXX=\"$ac_save_CXX\"\n-fi\n-eval ac_res=\\$$cachevar\n-\t       { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_res\" >&5\n-$as_echo \"$ac_res\" >&6; }\n-        if eval test x\\$$cachevar = xyes; then\n-          CXX=\"$CXX $switch\"\n-          if test -n \"$CXXCPP\" ; then\n-            CXXCPP=\"$CXXCPP $switch\"\n-          fi\n-          ac_success=yes\n-          break\n-        fi\n-      done\n-      if test x$ac_success = xyes; then\n-        break\n-      fi\n-    done\n-  fi\n-  ac_ext=cpp\n-ac_cpp='$CXXCPP $CPPFLAGS'\n-ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'\n-ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'\n-ac_compiler_gnu=$ac_cv_cxx_compiler_gnu\n-\n-  if test x$ax_cxx_compile_cxx11_required = xtrue; then\n-    if test x$ac_success = xno; then\n-      as_fn_error $? \"*** A compiler with support for C++11 language features is required.\" \"$LINENO\" 5\n-    fi\n-  fi\n-  if test x$ac_success = xno; then\n-    HAVE_CXX11=0\n-    { $as_echo \"$as_me:${as_lineno-$LINENO}: No compiler with C++11 support was found\" >&5\n-$as_echo \"$as_me: No compiler with C++11 support was found\" >&6;}\n-  else\n-    HAVE_CXX11=1\n-\n-$as_echo \"#define HAVE_CXX11 1\" >>confdefs.h\n-\n-  fi\n-\n-\n-\n ac_ext=c\n ac_cpp='$CPP $CPPFLAGS'\n ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'\n@@ -20012,7 +19019,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 20015 \"configure\"\n+#line 19022 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -20118,7 +19125,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 20121 \"configure\"\n+#line 19128 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H"}, {"sha": "9e7efd13eccf955aac2822ec34c4c2d3e6fdebec", "filename": "gcc/configure.ac", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffac9597256823612fb63bbab0f9ba3c11255e6b/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffac9597256823612fb63bbab0f9ba3c11255e6b/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=ffac9597256823612fb63bbab0f9ba3c11255e6b", "patch": "@@ -386,8 +386,6 @@ AC_SUBST(PICFLAG_FOR_TARGET)\n \n AC_USE_SYSTEM_EXTENSIONS\n \n-AX_CXX_COMPILE_STDCXX(11)\n-\n AC_PROG_CPP\n AC_C_INLINE\n "}]}