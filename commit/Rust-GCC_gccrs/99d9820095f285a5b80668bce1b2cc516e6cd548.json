{"sha": "99d9820095f285a5b80668bce1b2cc516e6cd548", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTlkOTgyMDA5NWYyODVhNWI4MDY2OGJjZTFiMmNjNTE2ZTZjZDU0OA==", "commit": {"author": {"name": "Segher Boessenkool", "email": "segher@kernel.crashing.org", "date": "2010-06-05T03:11:46Z"}, "committer": {"name": "Segher Boessenkool", "email": "segher@gcc.gnu.org", "date": "2010-06-05T03:11:46Z"}, "message": "genautomata.c (curr_state_pass_num): Delete.\n\n2010-06-05  Segher Boessenkool  <segher@kernel.crashing.org>\n\n        * genautomata.c (curr_state_pass_num): Delete.\n        (min_issue_delay_pass_states): Delete.\n        (min_issue_delay): Delete.\n        (initiate_min_issue_delay_pass_states): Delete.\n        (output_min_issue_delay_table): Compute min_issue_delay_vect\n        using a breadth-first search variant.\n        (output_tables): Don't call initiate_min_issue_delay_pass_states.\n\nFrom-SVN: r160306", "tree": {"sha": "bd81f8d1f2846b31fe7c9b27955b494877f401ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bd81f8d1f2846b31fe7c9b27955b494877f401ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/99d9820095f285a5b80668bce1b2cc516e6cd548", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99d9820095f285a5b80668bce1b2cc516e6cd548", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99d9820095f285a5b80668bce1b2cc516e6cd548", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99d9820095f285a5b80668bce1b2cc516e6cd548/comments", "author": {"login": "segher", "id": 417629, "node_id": "MDQ6VXNlcjQxNzYyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/417629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/segher", "html_url": "https://github.com/segher", "followers_url": "https://api.github.com/users/segher/followers", "following_url": "https://api.github.com/users/segher/following{/other_user}", "gists_url": "https://api.github.com/users/segher/gists{/gist_id}", "starred_url": "https://api.github.com/users/segher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/segher/subscriptions", "organizations_url": "https://api.github.com/users/segher/orgs", "repos_url": "https://api.github.com/users/segher/repos", "events_url": "https://api.github.com/users/segher/events{/privacy}", "received_events_url": "https://api.github.com/users/segher/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c69d3a0e59ba44609c1f4745f0dd5eb44b3d34fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c69d3a0e59ba44609c1f4745f0dd5eb44b3d34fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c69d3a0e59ba44609c1f4745f0dd5eb44b3d34fb"}], "stats": {"total": 166, "additions": 84, "deletions": 82}, "files": [{"sha": "c1514c914c5f8037264b7f7f833706d3f67584bc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99d9820095f285a5b80668bce1b2cc516e6cd548/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99d9820095f285a5b80668bce1b2cc516e6cd548/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=99d9820095f285a5b80668bce1b2cc516e6cd548", "patch": "@@ -1,3 +1,13 @@\n+2010-06-05  Segher Boessenkool  <segher@kernel.crashing.org>\n+\n+\t* genautomata.c (curr_state_pass_num): Delete.\n+\t(min_issue_delay_pass_states): Delete.\n+\t(min_issue_delay): Delete.\n+\t(initiate_min_issue_delay_pass_states): Delete.\n+\t(output_min_issue_delay_table): Compute min_issue_delay_vect\n+\tusing a breadth-first search variant.\n+\t(output_tables): Don't call initiate_min_issue_delay_pass_states.\n+\n 2010-06-04  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR boostrap/44421"}, {"sha": "463dbd47fed4efe9e62d0cbee86dfc8eda7b47bf", "filename": "gcc/genautomata.c", "status": "modified", "additions": 74, "deletions": 82, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99d9820095f285a5b80668bce1b2cc516e6cd548/gcc%2Fgenautomata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99d9820095f285a5b80668bce1b2cc516e6cd548/gcc%2Fgenautomata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenautomata.c?ref=99d9820095f285a5b80668bce1b2cc516e6cd548", "patch": "@@ -7488,72 +7488,6 @@ output_trans_table (automaton_t automaton)\n   VEC_free (vect_el_t, heap, transition_vect);\n }\n \n-/* The current number of passing states to find minimal issue delay\n-   value for an ainsn and state.  */\n-static int curr_state_pass_num;\n-\n-/* This recursive function passes states to find minimal issue delay\n-   value for AINSN.  The state being visited is STATE.  The function\n-   returns minimal issue delay value for AINSN in STATE or -1 if we\n-   enter into a loop.  */\n-static int\n-min_issue_delay_pass_states (state_t state, ainsn_t ainsn)\n-{\n-  arc_t arc;\n-  int min_insn_issue_delay, insn_issue_delay;\n-\n-  if (state->state_pass_num == curr_state_pass_num\n-      || state->min_insn_issue_delay != -1)\n-    /* We've entered into a loop or already have the correct value for\n-       given state and ainsn.  */\n-    return state->min_insn_issue_delay;\n-  state->state_pass_num = curr_state_pass_num;\n-  min_insn_issue_delay = -1;\n-  for (arc = first_out_arc (state); arc != NULL; arc = next_out_arc (arc))\n-    if (arc->insn == ainsn)\n-      {\n-\tmin_insn_issue_delay = 0;\n-\tbreak;\n-      }\n-    else\n-      {\n-        insn_issue_delay = min_issue_delay_pass_states (arc->to_state, ainsn);\n-\tif (insn_issue_delay != -1)\n-\t  {\n-\t    if (arc->insn->insn_reserv_decl\n-\t\t== DECL_INSN_RESERV (advance_cycle_insn_decl))\n-\t      insn_issue_delay++;\n-\t    if (min_insn_issue_delay == -1\n-\t\t|| min_insn_issue_delay > insn_issue_delay)\n-\t      {\n-\t\tmin_insn_issue_delay = insn_issue_delay;\n-\t\tif (insn_issue_delay == 0)\n-\t\t  break;\n-\t      }\n-\t  }\n-      }\n-  return min_insn_issue_delay;\n-}\n-\n-/* The function searches minimal issue delay value for AINSN in STATE.\n-   The function can return negative value if we can not issue AINSN.  We\n-   will report about it later.  */\n-static int\n-min_issue_delay (state_t state, ainsn_t ainsn)\n-{\n-  curr_state_pass_num++;\n-  state->min_insn_issue_delay = min_issue_delay_pass_states (state, ainsn);\n-  return state->min_insn_issue_delay;\n-}\n-\n-/* The function initiates code for finding minimal issue delay values.\n-   It should be called only once.  */\n-static void\n-initiate_min_issue_delay_pass_states (void)\n-{\n-  curr_state_pass_num = 0;\n-}\n-\n /* Form and output vectors representing minimal issue delay table of\n    AUTOMATON.  The table is state x ainsn -> minimal issue delay of\n    the ainsn.  */\n@@ -7562,11 +7496,11 @@ output_min_issue_delay_table (automaton_t automaton)\n {\n   vla_hwint_t min_issue_delay_vect;\n   vla_hwint_t compressed_min_issue_delay_vect;\n-  vect_el_t min_delay;\n   ainsn_t ainsn;\n-  size_t i, min_issue_delay_len;\n-  size_t compressed_min_issue_delay_len;\n+  size_t i;\n+  size_t min_issue_delay_len, compressed_min_issue_delay_len;\n   size_t cfactor;\n+  int changed;\n \n   /* Create vect of pointers to states ordered by num of transitions\n      from the state (state with the maximum num is the first).  */\n@@ -7577,27 +7511,86 @@ output_min_issue_delay_table (automaton_t automaton)\n \t\t\t * automaton->insn_equiv_classes_num);\n   min_issue_delay_vect = VEC_alloc (vect_el_t, heap, min_issue_delay_len);\n   for (i = 0; i < min_issue_delay_len; i++)\n-    VEC_quick_push (vect_el_t, min_issue_delay_vect, 0);\n+    VEC_quick_push (vect_el_t, min_issue_delay_vect, -1);\n \n   automaton->max_min_delay = 0;\n-  for (ainsn = automaton->ainsn_list; ainsn != NULL; ainsn = ainsn->next_ainsn)\n+\n+  do\n+    {\n+      size_t state_no;\n+\n+      changed = 0;\n+\n+      for (state_no = 0; state_no < VEC_length (state_t, output_states_vect);\n+           state_no++)\n+\t{\n+\t  state_t s = VEC_index (state_t, output_states_vect, state_no);\n+\t  arc_t arc;\n+\n+\t  for (arc = first_out_arc (s); arc; arc = next_out_arc (arc))\n+\t    {\n+\t      int k;\n+\n+\t      size_t asn = s->order_state_num\n+\t                   * automaton->insn_equiv_classes_num\n+\t                   + arc->insn->insn_equiv_class_num;\n+\n+\t      if (VEC_index (vect_el_t, min_issue_delay_vect, asn))\n+\t\t{\n+\t\t  VEC_replace (vect_el_t, min_issue_delay_vect, asn, 0);\n+\t\t  changed = 1;\n+\t\t}\n+\n+\t      for (k = 0; k < automaton->insn_equiv_classes_num; k++)\n+\t\t{\n+\t\t  size_t n0, n1;\n+\t\t  vect_el_t delay0, delay1;\n+\n+\t\t  n0 = s->order_state_num\n+\t\t       * automaton->insn_equiv_classes_num\n+\t\t       + k;\n+\t\t  n1 = arc->to_state->order_state_num\n+\t\t       * automaton->insn_equiv_classes_num\n+\t\t       + k;\n+\t\t  delay0 = VEC_index (vect_el_t, min_issue_delay_vect, n0);\n+\t\t  delay1 = VEC_index (vect_el_t, min_issue_delay_vect, n1);\n+\t\t  if (delay1 != -1)\n+\t\t    {\n+\t\t      if (arc->insn->insn_reserv_decl\n+\t\t          == DECL_INSN_RESERV (advance_cycle_insn_decl))\n+\t\t\tdelay1++;\n+\t\t      if (delay1 < delay0 || delay0 == -1)\n+\t\t\t{\n+\t\t\t  VEC_replace (vect_el_t, min_issue_delay_vect, n0, delay1);\n+\t\t\t  changed = 1;\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  while (changed);\n+\n+  automaton->max_min_delay = 0;\n+\n+  for (ainsn = automaton->ainsn_list; ainsn; ainsn = ainsn->next_ainsn)\n     if (ainsn->first_ainsn_with_given_equivalence_num)\n       {\n-\tfor (i = 0; i < VEC_length (state_t, output_states_vect); i++)\n-\t  VEC_index (state_t, output_states_vect, i)->min_insn_issue_delay = -1;\n \tfor (i = 0; i < VEC_length (state_t, output_states_vect); i++)\n \t  {\n \t    state_t s = VEC_index (state_t, output_states_vect, i);\n-            min_delay = min_issue_delay (s, ainsn);\n-\t    if (automaton->max_min_delay < min_delay)\n-\t      automaton->max_min_delay = min_delay;\n-\t    VEC_replace (vect_el_t, min_issue_delay_vect,\n-\t\t\t s->order_state_num\n-\t\t\t * automaton->insn_equiv_classes_num\n-\t\t\t + ainsn->insn_equiv_class_num,\n-\t\t\t min_delay);\n+\t    size_t np = s->order_state_num\n+\t                * automaton->insn_equiv_classes_num\n+\t                + ainsn->insn_equiv_class_num;\n+\t    vect_el_t x = VEC_index (vect_el_t, min_issue_delay_vect, np);\n+\n+\t    if (automaton->max_min_delay < x)\n+\t      automaton->max_min_delay = x;\n+\t    if (x == -1)\n+\t      VEC_replace (vect_el_t, min_issue_delay_vect, np, 0);\n \t  }\n       }\n+\n   fprintf (output_file, \"/* Vector of min issue delay of insns.  */\\n\");\n   fprintf (output_file, \"static const \");\n   output_range_type (output_file, 0, automaton->max_min_delay);\n@@ -7749,7 +7742,6 @@ output_tables (void)\n {\n   automaton_t automaton;\n \n-  initiate_min_issue_delay_pass_states ();\n   for (automaton = description->first_automaton;\n        automaton != NULL;\n        automaton = automaton->next_automaton)"}]}