{"sha": "b4c3a85be96585374bf95c981ba2f602667cf5b7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjRjM2E4NWJlOTY1ODUzNzRiZjk1Yzk4MWJhMmY2MDI2NjdjZjViNw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2016-11-10T11:38:05Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2016-11-10T11:38:05Z"}, "message": "omp-low.c (lower_omp_target): Fix up argument to is_reference.\n\ngcc/\n\t* omp-low.c (lower_omp_target): Fix up argument to is_reference.\n\t(expand_omp_ordered_sink): Handle TREE_PURPOSE of deps being\n\tTRUNC_DIV_EXPR.\n\t* gimplify.c (gimplify_scan_omp_clauses): Likewise.  Set\n\tctx->target_map_scalars_firstprivate on OMP_TARGET even for Fortran.\n\tRemove omp_no_lastprivate callers.  Propagate lastprivate on combined\n\tteams distribute parallel for simd even to distribute and teams\n\tconstruct.  For OMP_CLAUSE_DEPEND add missing break at the end of\n\tOMP_CLAUSE_DEPEND_SINK case.\n\t(omp_notice_variable): Use lang_hooks.decls.omp_scalar_p.\n\t(omp_no_lastprivate): Removed.\n\t(gimplify_adjust_omp_clauses): Remove omp_no_lastprivate callers.\n\t(gimplify_omp_for): Likewise.\n\t(computable_teams_clause): Fail for automatic vars from current\n\tfunction not yet seen in bind expr.\n\t* langhooks.c (lhd_omp_scalar_p): New function.\n\t* langhooks.h (struct lang_hooks_for_decls): Add omp_scalar_p.\n\t* varpool.c (varpool_node::get_create): Set node->offloading\n\teven for DECL_EXTERNAL decls.\n\t* langhooks-def.h (lhd_omp_scalar_p): New prototype.\n\t(LANG_HOOKS_OMP_SCALAR_P): Define.\n\t(LANG_HOOKS_DECLS): Use it.\ngcc/fortran/\n\t* openmp.c (gfc_free_omp_clauses): Free critical_name, grainsize,\n\thint, num_tasks, priority and if_exprs.\n\t(gfc_match_omp_to_link, gfc_match_omp_depend_sink): New functions.\n\t(enum omp_mask1, enum omp_mask2): New enums.\n\tChange all OMP_CLAUSE_* defines into enum values, and change their\n\tvalues from ((uint64_t) 1 << bit) to just bit.\n\t(omp_mask, omp_inv_mask): New classes.  Add ctors and operators.\n\t(gfc_match_omp_clauses): Change mask argument from uint64_t to\n\tconst omp_mask.  Assert OMP_MASK1_LAST and OMP_MASK2_LAST are\n\tat most 64.  Move delete clause handling to where it\n\talphabetically belongs.  Parse defaultmap, grainsize, hint,\n\tis_device_ptr, nogroup, nowait, num_tasks, priority, simd, threads\n\tand use_device_ptr clauses.  Parse if clause modifier.  Parse map\n\tclause always modifier, and release and delete kinds.  Parse ordered\n\tclause with argument.  Parse schedule clause modifiers.  Differentiate\n\tdevice clause parsing based on openacc flag.  Guard link clause\n\tparsing with openacc flag.  Add support for parsing\n\tlinear clause modifiers.  Parse depend(source) and depend(sink: ...).\n\tUse gfc_match_omp_to_link for to and link clauses in declare target\n\tconstruct.\n\t(match_acc): Change mask type from uint64_t to const omp_mask.\n\t(OMP_SINGLE_CLAUSES, OMP_ORDERED_CLAUSES,\n\tOMP_DECLARE_TARGET_CLAUSES, OMP_TASKLOOP_CLAUSES,\n\tOMP_TARGET_ENTER_DATA_CLAUSES, OMP_TARGET_EXIT_DATA_CLAUSES): Define.\n\t(OACC_PARALLEL_CLAUSES, OACC_KERNELS_CLAUSES, OACC_DATA_CLAUSES,\n\tOACC_LOOP_CLAUSES, OACC_HOST_DATA_CLAUSES, OACC_DECLARE_CLAUSES,\n\tOACC_ENTER_DATA_CLAUSES, OACC_EXIT_DATA_CLAUSES, OACC_WAIT_CLAUSES,\n\tOACC_ROUTINE_CLAUSES, OMP_PARALLEL_CLAUSES, OMP_DECLARE_SIMD_CLAUSES,\n\tOMP_SECTIONS_CLAUSES, OMP_TEAMS_CLAUSES, OMP_DISTRIBUTE_CLAUSES):\n\tReplace first or only OMP_CLAUSE_* value in bitset with\n\tomp_mask (OMP_CLAUSE_*).\n\t(OMP_DO_CLAUSES): Likewise.  Add OMP_CLAUSE_LINEAR.\n\t(OMP_SIMD_CLAUSES): Replace first or only OMP_CLAUSE_* value in\n\tbitset with omp_mask (OMP_CLAUSE_*).  Add OMP_CLAUSE_SIMDLEN.\n\t(OACC_UPDATE_CLAUSES): Replace first or only OMP_CLAUSE_* value in\n\tbitset with omp_mask (OMP_CLAUSE_*).  Replace OMP_CLAUSE_OACC_DEVICE\n\twith OMP_CLAUSE_DEVICE.\n\t(OMP_TASK_CLAUSES): Replace first or only OMP_CLAUSE_* value in\n\tbitset with omp_mask (OMP_CLAUSE_*).  Add OMP_CLAUSE_PRIORITY.\n\t(OMP_TARGET_CLAUSES): Replace first or only OMP_CLAUSE_* value in\n\tbitset with omp_mask (OMP_CLAUSE_*).  Add OMP_CLAUSE_DEPEND,\n\tOMP_CLAUSE_NOWAIT, OMP_CLAUSE_PRIVATE, OMP_CLAUSE_FIRSTPRIVATE,\n\tOMP_CLAUSE_DEFAULTMAP and OMP_CLAUSE_IS_DEVICE_PTR.\n\t(OMP_TARGET_DATA_CLAUSES): Replace first or only OMP_CLAUSE_* value in\n\tbitset with omp_mask (OMP_CLAUSE_*).  Add OMP_CLAUSE_USE_DEVICE_PTR.\n\t(OMP_TARGET_UPDATE_CLAUSES): Replace first or only OMP_CLAUSE_* value\n\tin bitset with omp_mask (OMP_CLAUSE_*).  Add OMP_CLAUSE_DEPEND and\n\tOMP_CLAUSE_NOWAIT.\n\t(match_omp): Change mask argument from unsigned int to\n\tconst omp_mask.\n\t(gfc_match_omp_critical): Parse optional clauses and use omp_clauses\n\tunion member instead of omp_name.\n\t(gfc_match_omp_end_critical): New function.\n\t(gfc_match_omp_distribute_parallel_do): Remove ordered and linear\n\tclauses from the mask.\n\t(gfc_match_omp_distribute_parallel_do_simd): Use\n\t& ~(omp_mask (OMP_CLAUSE_*)) instead of & ~OMP_CLAUSE_*.\n\t(gfc_match_omp_target_teams_distribute_parallel_do_simd): Likewise.\n\t(gfc_match_omp_teams_distribute_parallel_do_simd): Likewise.\n\t(gfc_match_omp_do_simd): Likewise.  Don't remove ordered clause from\n\tthe mask.\n\t(gfc_match_omp_parallel_do_simd): Likewise.\n\t(gfc_match_omp_target_teams_distribute_parallel_do): Likewise.\n\t(gfc_match_omp_teams_distribute_parallel_do): Likewise.\n\t(gfc_match_omp_declare_simd): If not using the form with\n\t(proc-name), require space before first clause.  Make (proc-name)\n\toptional.  If not present, set proc_name to NULL.\n\t(gfc_match_omp_declare_target): Rewritten for OpenMP 4.5.\n\t(gfc_match_omp_single): Use OMP_SINGLE_CLAUSES.\n\t(gfc_match_omp_task, gfc_match_omp_taskwait, gfc_match_omp_taskyield):\n\tMove around to where they belong alphabetically.\n\t(gfc_match_omp_target_enter_data, gfc_match_omp_target_exit_data,\n\tgfc_match_omp_target_parallel, gfc_match_omp_target_parallel_do,\n\tgfc_match_omp_target_parallel_do_simd, gfc_match_omp_target_simd,\n\tgfc_match_omp_taskloop, gfc_match_omp_taskloop_simd):\n\tNew functions.\n\t(gfc_match_omp_ordered): Parse clauses.\n\t(gfc_match_omp_ordered_depend): New function.\n\t(gfc_match_omp_cancel, gfc_match_omp_end_single): Use\n\tomp_mask (OMP_CLAUSE_*) instead of OMP_CLAUSE_*.\n\t(resolve_oacc_scalar_int_expr): Renamed to ...\n\t(resolve_scalar_int_expr): ... this.  Fix up formatting.\n\t(resolve_oacc_positive_int_expr): Renamed to ...\n\t(resolve_positive_int_expr): ... this.  Fix up formatting.\n\t(resolve_nonnegative_int_expr): New function.\n\t(resolve_omp_clauses): Adjust callers, use the above functions\n\teven for OpenMP clauses, add handling of new OpenMP 4.5 clauses.\n\tRequire orderedc >= collapse if specified. Handle depend(sink:)\n\tand depend(source) restrictions.  Disallow linear clause when\n\torderedc is non-zero.  Diagnose linear clause modifiers when not in\n\tdeclare simd.  Only check for integer type if ref modifier\n\tis not used.  Remove diagnostics for required VALUE attribute.\n\tDiagnose VALUE attribute with ref or uval modifiers.  Allow\n\tnon-constant linear-step, if it is a dummy argument alone and is\n\tmentioned in uniform clause.  Diagnose map kinds not allowed\n\tfor various constructs.  Diagnose target {enter ,exit ,}data without\n\tany map clauses.  Add dummy OMP_LIST_IS_DEVICE_PTR and\n\tOMP_LIST_USE_DEVICE_PTR cases.\n\t(gfc_resolve_omp_do_blocks): Set omp_current_do_collapse to orderedc\n\tif non-zero.\n\t(gfc_resolve_omp_parallel_blocks): Handle new OpenMP 4.5 constructs,\n\treplace underscores with spaces in a few construct names.\n\t(resolve_omp_do): Set collapse to orderedc if non-zero.  Handle new\n\tOpenMP 4.5 constructs.\n\t(resolve_oacc_loop_blocks): Call resolve_positive_int_expr instead\n\tof resolve_oacc_positive_int_expr.\n\t(gfc_resolve_omp_directive): Handle new OpenMP 4.5 constructs.\n\t(gfc_resolve_omp_declare_simd): Allow ods->proc_name to be NULL.\n\t* trans-openmp.c (gfc_omp_scalar_p): New function.\n\t(doacross_steps): New variable.\n\t(gfc_trans_omp_clauses): Handle new OpenMP 4.5 clauses and new clause\n\tmodifiers.\n\t(gfc_trans_omp_critical): Adjust EXEC_OMP_CRITICAL handling.\n\t(gfc_trans_omp_do): Handle doacross loops.  Clear sched_simd flag.\n\tHandle EXEC_OMP_TASKLOOP.\n\t(gfc_trans_omp_ordered): Translate omp clauses, allow NULL\n\tcode->block.\n\t(GFC_OMP_SPLIT_TASKLOOP, GFC_OMP_MASK_TASKLOOP): New enum constants.\n\t(gfc_split_omp_clauses): Copy orderedc together with ordered.  Change\n\tfirstprivate and lastprivate handling for OpenMP 4.5.\n\tHandle EXEC_OMP_TARGET_SIMD, EXEC_OMP_TARGET_PARALLEL{,_DO,_DO_SIMD}\n\tand EXEC_OMP_TASKLOOP{,_SIMD}.  Add handling for new OpenMP 4.5\n\tclauses and clause modifiers and handle if clause without/with\n\tmodifiers.\n\t(gfc_trans_omp_teams): Add omp_clauses argument, add it to other\n\tteams clauses.  Don't wrap into OMP_TEAMS if -fopenmp-simd.\n\t(gfc_trans_omp_target): For -fopenmp, translate num_teams and\n\tthread_limit clauses on combined target teams early and pass to\n\tgfc_trans_omp_teams.  Set OMP_TARGET_COMBINED if needed.\n\tHandle EXEC_OMP_TARGET_PARALLEL{,_DO,_DO_SIMD} and\n\tEXEC_OMP_TARGET_SIMD.\n\t(gfc_trans_omp_taskloop, gfc_trans_omp_target_enter_data,\n\tgfc_trans_omp_target_exit_data): New functions.\n\t(gfc_trans_omp_directive): Handle EXEC_OMP_TARGET_{ENTER,EXIT}_DATA\n\tEXEC_OMP_TASKLOOP{,_SIMD}, EXEC_OMP_TARGET_PARALLEL{,_DO,_DO_SIMD}\n\tand EXEC_OMP_TARGET_SIMD.  Adjust gfc_trans_omp_teams caller.\n\t* symbol.c (check_conflict): Handle omp_declare_target_link.\n\t(gfc_add_omp_declare_target_link): New function.\n\t(gfc_copy_attr): Copy omp_declare_target_link.\n\t* dump-parse-tree.c (show_omp_namelist): Handle OMP_DEPEND_SINK_FIRST\n\tdepend_op.  Print linear clause modifiers.\n\t(show_omp_clauses): Adjust for OpenMP 4.5 clause changes.\n\t(show_omp_node): Print clauses for EXEC_OMP_ORDERED.  Allow NULL\n\tc->block for EXEC_OMP_ORDERED.  Formatting fixes.  Adjust handling of\n\tEXEC_OMP_CRITICAL, handle new OpenMP 4.5 constructs and some\n\tforgotten OpenMP 4.0 constructs.\n\t(show_code_node): Handle new OpenMP 4.5 constructs and some forgotten\n\tOpenMP 4.0 constructs.\n\t* gfortran.h (symbol_attribute): Add omp_declare_target_link bitfield.\n\t(struct gfc_omp_namelist): Add u.common and u.linear_op fields.\n\t(struct gfc_common_head): Change omp_declare_target into bitfield.\n\tAdd omp_declare_target_link bitfield.\n\t(gfc_add_omp_declare_target_link): New prototype.\n\t(enum gfc_statement): Add ST_OMP_TARGET_PARALLEL,\n\tST_OMP_END_TARGET_PARALLEL, ST_OMP_TARGET_PARALLEL_DO,\n\tST_OMP_END_TARGET_PARALLEL_DO, ST_OMP_TARGET_PARALLEL_DO_SIMD,\n\tST_OMP_END_TARGET_PARALLEL_DO_SIMD, ST_OMP_TARGET_ENTER_DATA,\n\tST_OMP_TARGET_EXIT_DATA, ST_OMP_TARGET_SIMD, ST_OMP_END_TARGET_SIMD,\n\tST_OMP_TASKLOOP, ST_OMP_END_TASKLOOP, ST_OMP_TASKLOOP_SIMD,\n\tST_OMP_END_TASKLOOP_SIMD and ST_OMP_ORDERED_DEPEND.\n\t(enum gfc_omp_depend_op): Add OMP_DEPEND_SINK_FIRST and\n\tOMP_DEPEND_SINK.\n\t(enum gfc_omp_linear_op): New.\n\t(struct gfc_omp_clauses): Add critical_name, depend_source,\n\torderedc, defaultmap, nogroup, sched_simd, sched_monotonic,\n\tsched_nonmonotonic, simd, threads, grainsize, hint, num_tasks,\n\tpriority and if_exprs fields.\n\t(enum gfc_exec_op): Add EXEC_OMP_END_CRITICAL,\n\tEXEC_OMP_TARGET_ENTER_DATA, EXEC_OMP_TARGET_EXIT_DATA,\n\tEXEC_OMP_TARGET_PARALLEL, EXEC_OMP_TARGET_PARALLEL_DO,\n\tEXEC_OMP_TARGET_PARALLEL_DO_SIMD, EXEC_OMP_TARGET_SIMD,\n\tEXEC_OMP_TASKLOOP, EXEC_OMP_TASKLOOP_SIMD.\n\t(enum gfc_omp_map_op): Add OMP_MAP_RELEASE,\n\tOMP_MAP_ALWAYS_TO, OMP_MAP_ALWAYS_FROM and OMP_MAP_ALWAYS_TOFROM.\n\t(OMP_LIST_IS_DEVICE_PTR, OMP_LIST_USE_DEVICE_PTR): New.\n\t(enum gfc_omp_if_kind): New.\n\t* module.c (enum ab_attribute): Add AB_OMP_DECLARE_TARGET_LINK.\n\t(attr_bits): Add AB_OMP_DECLARE_TARGET_LINK entry.\n\t(mio_symbol_attribute): Save and restore omp_declare_target_link bit.\n\t* trans.h (gfc_omp_scalar_p): New prototype.\n\t* frontend-passes.c (gfc_code_walker): Handle new OpenMP 4.5\n\texpressions.\n\t* trans.c (trans_code): Handle new OpenMP 4.5 constructs.\n\t* resolve.c (gfc_resolve_blocks): Likewise.\n\t(gfc_resolve_code): Likewise.\n\t* f95-lang.c (LANG_HOOKS_OMP_SCALAR_P): Redefine to gfc_omp_scalar_p.\n\t(gfc_attribute_table): Add \"omp declare target link\".\n\t* st.c (gfc_free_statement): Handle EXEC_OMP_END_CRITICAL like\n\tEXEC_OMP_CRITICAL before, free clauses for EXEC_OMP_CRITICAL\n\tand new OpenMP 4.5 constructs.  Free omp clauses even for\n\tEXEC_OMP_ORDERED.\n\t* match.c (match_exit_cycle): Rename collapse variable to count,\n\tset it to orderedc if non-zero, instead of collapse.\n\t* trans-decl.c (add_attributes_to_decl): Add \"omp declare target link\"\n\tinstead of \"omp declare target\" for omp_declare_target_link.\n\t* trans-common.c (build_common_decl): Likewise.\n\t* match.h (gfc_match_omp_target_enter_data,\n\tgfc_match_omp_target_exit_data, gfc_match_omp_target_parallel,\n\tgfc_match_omp_target_parallel_do,\n\tgfc_match_omp_target_parallel_do_simd, gfc_match_omp_target_simd,\n\tgfc_match_omp_taskloop, gfc_match_omp_taskloop_simd,\n\tgfc_match_omp_end_critical, gfc_match_omp_ordered_depend): New\n\tprototypes.\n\t* parse.c (decode_omp_directive): Use gfc_match_omp_end_critical\n\tinstead of gfc_match_omp_critical for !$omp end critical.\n\tHandle new OpenMP 4.5 constructs.  If ordered directive has\n\tdepend clause as the first of the clauses, use\n\tgfc_match_omp_ordered_depend and ST_OMP_ORDERED_DEPEND instead of\n\tgfc_match_omp_ordered and ST_OMP_ORDERED.\n\t(case_executable): Add ST_OMP_TARGET_ENTER_DATA,\n\tST_OMP_TARGET_EXIT_DATA and ST_OMP_ORDERED_DEPEND cases.\n\t(case_exec_markers): Add ST_OMP_TARGET_PARALLEL,\n\tST_OMP_TARGET_PARALLEL_DO, ST_OMP_TARGET_PARALLEL_DO_SIMD,\n\tST_OMP_TARGET_SIMD, ST_OMP_TASKLOOP and ST_OMP_TASKLOOP_SIMD cases.\n\t(gfc_ascii_statement): Handle new OpenMP 4.5 constructs.\n\t(parse_omp_do): Handle ST_OMP_TARGET_PARALLEL_DO,\n\tST_OMP_TARGET_PARALLEL_DO_SIMD, ST_OMP_TASKLOOP and\n\tST_OMP_TASKLOOP_SIMD.\n\t(parse_omp_structured_block): Handle EXEC_OMP_END_CRITICAL instead\n\tof EXEC_OMP_CRITICAL, adjust for EXEC_OMP_CRITICAL having omp clauses\n\tnow.\n\t(parse_executable): Handle ST_OMP_TARGET_PARALLEL,\n\tST_OMP_TARGET_PARALLEL_DO, ST_OMP_TARGET_PARALLEL_DO_SIMD,\n\tST_OMP_TASKLOOP and ST_OMP_TASKLOOP_SIMD.\ngcc/testsuite/\n\t* gfortran.dg/gomp/pr77516.f90: Add dg-warning.\n\t* gfortran.dg/gomp/target1.f90: Remove ordered clause where it is\n\tno longer allowed and corresponding ordered construct.\n\t* gfortran.dg/gomp/linear-1.f90: New test.\n\t* gfortran.dg/gomp/declare-simd-2.f90: New test.\n\t* gfortran.dg/gomp/declare-target-1.f90: New test.\n\t* gfortran.dg/gomp/declare-target-2.f90: New test.\nlibgomp/\n\t* testsuite/libgomp.fortran/examples-4/declare_target-1.f90\n\t(fib_wrapper): Add map(from: x) clause.\n\t* testsuite/libgomp.fortran/examples-4/declare_target-2.f90\n\t(e_53_2): Likewise.\n\t* testsuite/libgomp.fortran/examples-4/declare_target-4.f90\n\t(accum): Add map(tmp) clause.\n\t* testsuite/libgomp.fortran/examples-4/declare_target-5.f90\n\t(accum): Add map(tofrom: tmp) clause.\n\t* testsuite/libgomp.fortran/examples-4/target_data-3.f90\n\t(gramSchmidt): Likewise.\n\t* testsuite/libgomp.fortran/examples-4/teams-2.f90 (dotprod): Add\n\tmap(tofrom: sum) clause.\n\t* testsuite/libgomp.fortran/nestedfn5.f90 (foo): Add twice\n\tmap (alloc: a, l) clause.  Add defaultmap(tofrom: scalar) clause.\n\t* testsuite/libgomp.fortran/pr66199-2.f90: Adjust for linear clause\n\tonly allowed on the loop iterator.\n\t* testsuite/libgomp.fortran/target4.f90 (foo): Add map(t) clause.\n\t* testsuite/libgomp.fortran/taskloop2.f90: New test.\n\t* testsuite/libgomp.fortran/taskloop4.f90: New test.\n\t* testsuite/libgomp.fortran/doacross1.f90: New test.\n\t* testsuite/libgomp.fortran/doacross3.f90: New test.\n\t* testsuite/libgomp.fortran/taskloop1.f90: New test.\n\t* testsuite/libgomp.fortran/taskloop3.f90: New test.\n\t* testsuite/libgomp.fortran/doacross2.f90: New test.\n\t* testsuite/libgomp.c/doacross-1.c (main): Add missing\n\t#pragma omp atomic read.\n\t* testsuite/libgomp.c/doacross-2.c (main): Likewise.\n\t* testsuite/libgomp.c/doacross-3.c (main): Likewise.\n\nFrom-SVN: r242037", "tree": {"sha": "3567be9879613f19b407cad1c5c4fdcbd2f5d4bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3567be9879613f19b407cad1c5c4fdcbd2f5d4bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b4c3a85be96585374bf95c981ba2f602667cf5b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4c3a85be96585374bf95c981ba2f602667cf5b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4c3a85be96585374bf95c981ba2f602667cf5b7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4c3a85be96585374bf95c981ba2f602667cf5b7/comments", "author": null, "committer": null, "parents": [{"sha": "86bc85065359e0f849a12115ee487d6a408a2fe0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86bc85065359e0f849a12115ee487d6a408a2fe0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86bc85065359e0f849a12115ee487d6a408a2fe0"}], "stats": {"total": 4650, "additions": 4102, "deletions": 548}, "files": [{"sha": "9e93f793453deff225c81b4a157b94aff4ca6577", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c3a85be96585374bf95c981ba2f602667cf5b7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c3a85be96585374bf95c981ba2f602667cf5b7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b4c3a85be96585374bf95c981ba2f602667cf5b7", "patch": "@@ -1,3 +1,28 @@\n+2016-11-10  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* omp-low.c (lower_omp_target): Fix up argument to is_reference.\n+\t(expand_omp_ordered_sink): Handle TREE_PURPOSE of deps being\n+\tTRUNC_DIV_EXPR.\n+\t* gimplify.c (gimplify_scan_omp_clauses): Likewise.  Set\n+\tctx->target_map_scalars_firstprivate on OMP_TARGET even for Fortran.\n+\tRemove omp_no_lastprivate callers.  Propagate lastprivate on combined\n+\tteams distribute parallel for simd even to distribute and teams\n+\tconstruct.  For OMP_CLAUSE_DEPEND add missing break at the end of\n+\tOMP_CLAUSE_DEPEND_SINK case.\n+\t(omp_notice_variable): Use lang_hooks.decls.omp_scalar_p.\n+\t(omp_no_lastprivate): Removed.\n+\t(gimplify_adjust_omp_clauses): Remove omp_no_lastprivate callers.\n+\t(gimplify_omp_for): Likewise.\n+\t(computable_teams_clause): Fail for automatic vars from current\n+\tfunction not yet seen in bind expr.\n+\t* langhooks.c (lhd_omp_scalar_p): New function.\n+\t* langhooks.h (struct lang_hooks_for_decls): Add omp_scalar_p.\n+\t* varpool.c (varpool_node::get_create): Set node->offloading\n+\teven for DECL_EXTERNAL decls.\n+\t* langhooks-def.h (lhd_omp_scalar_p): New prototype.\n+\t(LANG_HOOKS_OMP_SCALAR_P): Define.\n+\t(LANG_HOOKS_DECLS): Use it.\n+\n 2016-11-10  Martin Liska  <mliska@suse.cz>\n \n \tPR sanitizer/78270"}, {"sha": "f1ea9a3bc62313009cf21e20c49bb853434f9db4", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 227, "deletions": 0, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c3a85be96585374bf95c981ba2f602667cf5b7/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c3a85be96585374bf95c981ba2f602667cf5b7/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=b4c3a85be96585374bf95c981ba2f602667cf5b7", "patch": "@@ -1,3 +1,230 @@\n+2016-11-10  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* openmp.c (gfc_free_omp_clauses): Free critical_name, grainsize,\n+\thint, num_tasks, priority and if_exprs.\n+\t(gfc_match_omp_to_link, gfc_match_omp_depend_sink): New functions.\n+\t(enum omp_mask1, enum omp_mask2): New enums.\n+\tChange all OMP_CLAUSE_* defines into enum values, and change their\n+\tvalues from ((uint64_t) 1 << bit) to just bit.\n+\t(omp_mask, omp_inv_mask): New classes.  Add ctors and operators.\n+\t(gfc_match_omp_clauses): Change mask argument from uint64_t to\n+\tconst omp_mask.  Assert OMP_MASK1_LAST and OMP_MASK2_LAST are\n+\tat most 64.  Move delete clause handling to where it\n+\talphabetically belongs.  Parse defaultmap, grainsize, hint,\n+\tis_device_ptr, nogroup, nowait, num_tasks, priority, simd, threads\n+\tand use_device_ptr clauses.  Parse if clause modifier.  Parse map\n+\tclause always modifier, and release and delete kinds.  Parse ordered\n+\tclause with argument.  Parse schedule clause modifiers.  Differentiate\n+\tdevice clause parsing based on openacc flag.  Guard link clause\n+\tparsing with openacc flag.  Add support for parsing\n+\tlinear clause modifiers.  Parse depend(source) and depend(sink: ...).\n+\tUse gfc_match_omp_to_link for to and link clauses in declare target\n+\tconstruct.\n+\t(match_acc): Change mask type from uint64_t to const omp_mask.\n+\t(OMP_SINGLE_CLAUSES, OMP_ORDERED_CLAUSES,\n+\tOMP_DECLARE_TARGET_CLAUSES, OMP_TASKLOOP_CLAUSES,\n+\tOMP_TARGET_ENTER_DATA_CLAUSES, OMP_TARGET_EXIT_DATA_CLAUSES): Define.\n+\t(OACC_PARALLEL_CLAUSES, OACC_KERNELS_CLAUSES, OACC_DATA_CLAUSES,\n+\tOACC_LOOP_CLAUSES, OACC_HOST_DATA_CLAUSES, OACC_DECLARE_CLAUSES,\n+\tOACC_ENTER_DATA_CLAUSES, OACC_EXIT_DATA_CLAUSES, OACC_WAIT_CLAUSES,\n+\tOACC_ROUTINE_CLAUSES, OMP_PARALLEL_CLAUSES, OMP_DECLARE_SIMD_CLAUSES,\n+\tOMP_SECTIONS_CLAUSES, OMP_TEAMS_CLAUSES, OMP_DISTRIBUTE_CLAUSES):\n+\tReplace first or only OMP_CLAUSE_* value in bitset with\n+\tomp_mask (OMP_CLAUSE_*).\n+\t(OMP_DO_CLAUSES): Likewise.  Add OMP_CLAUSE_LINEAR.\n+\t(OMP_SIMD_CLAUSES): Replace first or only OMP_CLAUSE_* value in\n+\tbitset with omp_mask (OMP_CLAUSE_*).  Add OMP_CLAUSE_SIMDLEN.\n+\t(OACC_UPDATE_CLAUSES): Replace first or only OMP_CLAUSE_* value in\n+\tbitset with omp_mask (OMP_CLAUSE_*).  Replace OMP_CLAUSE_OACC_DEVICE\n+\twith OMP_CLAUSE_DEVICE.\n+\t(OMP_TASK_CLAUSES): Replace first or only OMP_CLAUSE_* value in\n+\tbitset with omp_mask (OMP_CLAUSE_*).  Add OMP_CLAUSE_PRIORITY.\n+\t(OMP_TARGET_CLAUSES): Replace first or only OMP_CLAUSE_* value in\n+\tbitset with omp_mask (OMP_CLAUSE_*).  Add OMP_CLAUSE_DEPEND,\n+\tOMP_CLAUSE_NOWAIT, OMP_CLAUSE_PRIVATE, OMP_CLAUSE_FIRSTPRIVATE,\n+\tOMP_CLAUSE_DEFAULTMAP and OMP_CLAUSE_IS_DEVICE_PTR.\n+\t(OMP_TARGET_DATA_CLAUSES): Replace first or only OMP_CLAUSE_* value in\n+\tbitset with omp_mask (OMP_CLAUSE_*).  Add OMP_CLAUSE_USE_DEVICE_PTR.\n+\t(OMP_TARGET_UPDATE_CLAUSES): Replace first or only OMP_CLAUSE_* value\n+\tin bitset with omp_mask (OMP_CLAUSE_*).  Add OMP_CLAUSE_DEPEND and\n+\tOMP_CLAUSE_NOWAIT.\n+\t(match_omp): Change mask argument from unsigned int to\n+\tconst omp_mask.\n+\t(gfc_match_omp_critical): Parse optional clauses and use omp_clauses\n+\tunion member instead of omp_name.\n+\t(gfc_match_omp_end_critical): New function.\n+\t(gfc_match_omp_distribute_parallel_do): Remove ordered and linear\n+\tclauses from the mask.\n+\t(gfc_match_omp_distribute_parallel_do_simd): Use\n+\t& ~(omp_mask (OMP_CLAUSE_*)) instead of & ~OMP_CLAUSE_*.\n+\t(gfc_match_omp_target_teams_distribute_parallel_do_simd): Likewise.\n+\t(gfc_match_omp_teams_distribute_parallel_do_simd): Likewise.\n+\t(gfc_match_omp_do_simd): Likewise.  Don't remove ordered clause from\n+\tthe mask.\n+\t(gfc_match_omp_parallel_do_simd): Likewise.\n+\t(gfc_match_omp_target_teams_distribute_parallel_do): Likewise.\n+\t(gfc_match_omp_teams_distribute_parallel_do): Likewise.\n+\t(gfc_match_omp_declare_simd): If not using the form with\n+\t(proc-name), require space before first clause.  Make (proc-name)\n+\toptional.  If not present, set proc_name to NULL.\n+\t(gfc_match_omp_declare_target): Rewritten for OpenMP 4.5.\n+\t(gfc_match_omp_single): Use OMP_SINGLE_CLAUSES.\n+\t(gfc_match_omp_task, gfc_match_omp_taskwait, gfc_match_omp_taskyield):\n+\tMove around to where they belong alphabetically.\n+\t(gfc_match_omp_target_enter_data, gfc_match_omp_target_exit_data,\n+\tgfc_match_omp_target_parallel, gfc_match_omp_target_parallel_do,\n+\tgfc_match_omp_target_parallel_do_simd, gfc_match_omp_target_simd,\n+\tgfc_match_omp_taskloop, gfc_match_omp_taskloop_simd):\n+\tNew functions.\n+\t(gfc_match_omp_ordered): Parse clauses.\n+\t(gfc_match_omp_ordered_depend): New function.\n+\t(gfc_match_omp_cancel, gfc_match_omp_end_single): Use\n+\tomp_mask (OMP_CLAUSE_*) instead of OMP_CLAUSE_*.\n+\t(resolve_oacc_scalar_int_expr): Renamed to ...\n+\t(resolve_scalar_int_expr): ... this.  Fix up formatting.\n+\t(resolve_oacc_positive_int_expr): Renamed to ...\n+\t(resolve_positive_int_expr): ... this.  Fix up formatting.\n+\t(resolve_nonnegative_int_expr): New function.\n+\t(resolve_omp_clauses): Adjust callers, use the above functions\n+\teven for OpenMP clauses, add handling of new OpenMP 4.5 clauses.\n+\tRequire orderedc >= collapse if specified. Handle depend(sink:)\n+\tand depend(source) restrictions.  Disallow linear clause when\n+\torderedc is non-zero.  Diagnose linear clause modifiers when not in\n+\tdeclare simd.  Only check for integer type if ref modifier\n+\tis not used.  Remove diagnostics for required VALUE attribute.\n+\tDiagnose VALUE attribute with ref or uval modifiers.  Allow\n+\tnon-constant linear-step, if it is a dummy argument alone and is\n+\tmentioned in uniform clause.  Diagnose map kinds not allowed\n+\tfor various constructs.  Diagnose target {enter ,exit ,}data without\n+\tany map clauses.  Add dummy OMP_LIST_IS_DEVICE_PTR and\n+\tOMP_LIST_USE_DEVICE_PTR cases.\n+\t(gfc_resolve_omp_do_blocks): Set omp_current_do_collapse to orderedc\n+\tif non-zero.\n+\t(gfc_resolve_omp_parallel_blocks): Handle new OpenMP 4.5 constructs,\n+\treplace underscores with spaces in a few construct names.\n+\t(resolve_omp_do): Set collapse to orderedc if non-zero.  Handle new\n+\tOpenMP 4.5 constructs.\n+\t(resolve_oacc_loop_blocks): Call resolve_positive_int_expr instead\n+\tof resolve_oacc_positive_int_expr.\n+\t(gfc_resolve_omp_directive): Handle new OpenMP 4.5 constructs.\n+\t(gfc_resolve_omp_declare_simd): Allow ods->proc_name to be NULL.\n+\t* trans-openmp.c (gfc_omp_scalar_p): New function.\n+\t(doacross_steps): New variable.\n+\t(gfc_trans_omp_clauses): Handle new OpenMP 4.5 clauses and new clause\n+\tmodifiers.\n+\t(gfc_trans_omp_critical): Adjust EXEC_OMP_CRITICAL handling.\n+\t(gfc_trans_omp_do): Handle doacross loops.  Clear sched_simd flag.\n+\tHandle EXEC_OMP_TASKLOOP.\n+\t(gfc_trans_omp_ordered): Translate omp clauses, allow NULL\n+\tcode->block.\n+\t(GFC_OMP_SPLIT_TASKLOOP, GFC_OMP_MASK_TASKLOOP): New enum constants.\n+\t(gfc_split_omp_clauses): Copy orderedc together with ordered.  Change\n+\tfirstprivate and lastprivate handling for OpenMP 4.5.\n+\tHandle EXEC_OMP_TARGET_SIMD, EXEC_OMP_TARGET_PARALLEL{,_DO,_DO_SIMD}\n+\tand EXEC_OMP_TASKLOOP{,_SIMD}.  Add handling for new OpenMP 4.5\n+\tclauses and clause modifiers and handle if clause without/with\n+\tmodifiers.\n+\t(gfc_trans_omp_teams): Add omp_clauses argument, add it to other\n+\tteams clauses.  Don't wrap into OMP_TEAMS if -fopenmp-simd.\n+\t(gfc_trans_omp_target): For -fopenmp, translate num_teams and\n+\tthread_limit clauses on combined target teams early and pass to\n+\tgfc_trans_omp_teams.  Set OMP_TARGET_COMBINED if needed.\n+\tHandle EXEC_OMP_TARGET_PARALLEL{,_DO,_DO_SIMD} and\n+\tEXEC_OMP_TARGET_SIMD.\n+\t(gfc_trans_omp_taskloop, gfc_trans_omp_target_enter_data,\n+\tgfc_trans_omp_target_exit_data): New functions.\n+\t(gfc_trans_omp_directive): Handle EXEC_OMP_TARGET_{ENTER,EXIT}_DATA\n+\tEXEC_OMP_TASKLOOP{,_SIMD}, EXEC_OMP_TARGET_PARALLEL{,_DO,_DO_SIMD}\n+\tand EXEC_OMP_TARGET_SIMD.  Adjust gfc_trans_omp_teams caller.\n+\t* symbol.c (check_conflict): Handle omp_declare_target_link.\n+\t(gfc_add_omp_declare_target_link): New function.\n+\t(gfc_copy_attr): Copy omp_declare_target_link.\n+\t* dump-parse-tree.c (show_omp_namelist): Handle OMP_DEPEND_SINK_FIRST\n+\tdepend_op.  Print linear clause modifiers.\n+\t(show_omp_clauses): Adjust for OpenMP 4.5 clause changes.\n+\t(show_omp_node): Print clauses for EXEC_OMP_ORDERED.  Allow NULL\n+\tc->block for EXEC_OMP_ORDERED.  Formatting fixes.  Adjust handling of\n+\tEXEC_OMP_CRITICAL, handle new OpenMP 4.5 constructs and some\n+\tforgotten OpenMP 4.0 constructs.\n+\t(show_code_node): Handle new OpenMP 4.5 constructs and some forgotten\n+\tOpenMP 4.0 constructs.\n+\t* gfortran.h (symbol_attribute): Add omp_declare_target_link bitfield.\n+\t(struct gfc_omp_namelist): Add u.common and u.linear_op fields.\n+\t(struct gfc_common_head): Change omp_declare_target into bitfield.\n+\tAdd omp_declare_target_link bitfield.\n+\t(gfc_add_omp_declare_target_link): New prototype.\n+\t(enum gfc_statement): Add ST_OMP_TARGET_PARALLEL,\n+\tST_OMP_END_TARGET_PARALLEL, ST_OMP_TARGET_PARALLEL_DO,\n+\tST_OMP_END_TARGET_PARALLEL_DO, ST_OMP_TARGET_PARALLEL_DO_SIMD,\n+\tST_OMP_END_TARGET_PARALLEL_DO_SIMD, ST_OMP_TARGET_ENTER_DATA,\n+\tST_OMP_TARGET_EXIT_DATA, ST_OMP_TARGET_SIMD, ST_OMP_END_TARGET_SIMD,\n+\tST_OMP_TASKLOOP, ST_OMP_END_TASKLOOP, ST_OMP_TASKLOOP_SIMD,\n+\tST_OMP_END_TASKLOOP_SIMD and ST_OMP_ORDERED_DEPEND.\n+\t(enum gfc_omp_depend_op): Add OMP_DEPEND_SINK_FIRST and\n+\tOMP_DEPEND_SINK.\n+\t(enum gfc_omp_linear_op): New.\n+\t(struct gfc_omp_clauses): Add critical_name, depend_source,\n+\torderedc, defaultmap, nogroup, sched_simd, sched_monotonic,\n+\tsched_nonmonotonic, simd, threads, grainsize, hint, num_tasks,\n+\tpriority and if_exprs fields.\n+\t(enum gfc_exec_op): Add EXEC_OMP_END_CRITICAL,\n+\tEXEC_OMP_TARGET_ENTER_DATA, EXEC_OMP_TARGET_EXIT_DATA,\n+\tEXEC_OMP_TARGET_PARALLEL, EXEC_OMP_TARGET_PARALLEL_DO,\n+\tEXEC_OMP_TARGET_PARALLEL_DO_SIMD, EXEC_OMP_TARGET_SIMD,\n+\tEXEC_OMP_TASKLOOP, EXEC_OMP_TASKLOOP_SIMD.\n+\t(enum gfc_omp_map_op): Add OMP_MAP_RELEASE,\n+\tOMP_MAP_ALWAYS_TO, OMP_MAP_ALWAYS_FROM and OMP_MAP_ALWAYS_TOFROM.\n+\t(OMP_LIST_IS_DEVICE_PTR, OMP_LIST_USE_DEVICE_PTR): New.\n+\t(enum gfc_omp_if_kind): New.\n+\t* module.c (enum ab_attribute): Add AB_OMP_DECLARE_TARGET_LINK.\n+\t(attr_bits): Add AB_OMP_DECLARE_TARGET_LINK entry.\n+\t(mio_symbol_attribute): Save and restore omp_declare_target_link bit.\n+\t* trans.h (gfc_omp_scalar_p): New prototype.\n+\t* frontend-passes.c (gfc_code_walker): Handle new OpenMP 4.5\n+\texpressions.\n+\t* trans.c (trans_code): Handle new OpenMP 4.5 constructs.\n+\t* resolve.c (gfc_resolve_blocks): Likewise.\n+\t(gfc_resolve_code): Likewise.\n+\t* f95-lang.c (LANG_HOOKS_OMP_SCALAR_P): Redefine to gfc_omp_scalar_p.\n+\t(gfc_attribute_table): Add \"omp declare target link\".\n+\t* st.c (gfc_free_statement): Handle EXEC_OMP_END_CRITICAL like\n+\tEXEC_OMP_CRITICAL before, free clauses for EXEC_OMP_CRITICAL\n+\tand new OpenMP 4.5 constructs.  Free omp clauses even for\n+\tEXEC_OMP_ORDERED.\n+\t* match.c (match_exit_cycle): Rename collapse variable to count,\n+\tset it to orderedc if non-zero, instead of collapse.\n+\t* trans-decl.c (add_attributes_to_decl): Add \"omp declare target link\"\n+\tinstead of \"omp declare target\" for omp_declare_target_link.\n+\t* trans-common.c (build_common_decl): Likewise.\n+\t* match.h (gfc_match_omp_target_enter_data,\n+\tgfc_match_omp_target_exit_data, gfc_match_omp_target_parallel,\n+\tgfc_match_omp_target_parallel_do,\n+\tgfc_match_omp_target_parallel_do_simd, gfc_match_omp_target_simd,\n+\tgfc_match_omp_taskloop, gfc_match_omp_taskloop_simd,\n+\tgfc_match_omp_end_critical, gfc_match_omp_ordered_depend): New\n+\tprototypes.\n+\t* parse.c (decode_omp_directive): Use gfc_match_omp_end_critical\n+\tinstead of gfc_match_omp_critical for !$omp end critical.\n+\tHandle new OpenMP 4.5 constructs.  If ordered directive has\n+\tdepend clause as the first of the clauses, use\n+\tgfc_match_omp_ordered_depend and ST_OMP_ORDERED_DEPEND instead of\n+\tgfc_match_omp_ordered and ST_OMP_ORDERED.\n+\t(case_executable): Add ST_OMP_TARGET_ENTER_DATA,\n+\tST_OMP_TARGET_EXIT_DATA and ST_OMP_ORDERED_DEPEND cases.\n+\t(case_exec_markers): Add ST_OMP_TARGET_PARALLEL,\n+\tST_OMP_TARGET_PARALLEL_DO, ST_OMP_TARGET_PARALLEL_DO_SIMD,\n+\tST_OMP_TARGET_SIMD, ST_OMP_TASKLOOP and ST_OMP_TASKLOOP_SIMD cases.\n+\t(gfc_ascii_statement): Handle new OpenMP 4.5 constructs.\n+\t(parse_omp_do): Handle ST_OMP_TARGET_PARALLEL_DO,\n+\tST_OMP_TARGET_PARALLEL_DO_SIMD, ST_OMP_TASKLOOP and\n+\tST_OMP_TASKLOOP_SIMD.\n+\t(parse_omp_structured_block): Handle EXEC_OMP_END_CRITICAL instead\n+\tof EXEC_OMP_CRITICAL, adjust for EXEC_OMP_CRITICAL having omp clauses\n+\tnow.\n+\t(parse_executable): Handle ST_OMP_TARGET_PARALLEL,\n+\tST_OMP_TARGET_PARALLEL_DO, ST_OMP_TARGET_PARALLEL_DO_SIMD,\n+\tST_OMP_TASKLOOP and ST_OMP_TASKLOOP_SIMD.\n+\n 2016-11-09  Mikael Morin  <mikael@gcc.gnu.org>\n \t    Janus Weil  <janus@gcc.gnu.org>\n "}, {"sha": "ff47f3fe853b1d74d9375c6465c5f2d0765e077d", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 209, "deletions": 15, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c3a85be96585374bf95c981ba2f602667cf5b7/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c3a85be96585374bf95c981ba2f602667cf5b7/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=b4c3a85be96585374bf95c981ba2f602667cf5b7", "patch": "@@ -1059,6 +1059,27 @@ show_omp_namelist (int list_type, gfc_omp_namelist *n)\n \t  case OMP_DEPEND_IN: fputs (\"in:\", dumpfile); break;\n \t  case OMP_DEPEND_OUT: fputs (\"out:\", dumpfile); break;\n \t  case OMP_DEPEND_INOUT: fputs (\"inout:\", dumpfile); break;\n+\t  case OMP_DEPEND_SINK_FIRST:\n+\t    fputs (\"sink:\", dumpfile);\n+\t    while (1)\n+\t      {\n+\t\tfprintf (dumpfile, \"%s\", n->sym->name);\n+\t\tif (n->expr)\n+\t\t  {\n+\t\t    fputc ('+', dumpfile);\n+\t\t    show_expr (n->expr);\n+\t\t  }\n+\t\tif (n->next == NULL)\n+\t\t  break;\n+\t\telse if (n->next->u.depend_op != OMP_DEPEND_SINK)\n+\t\t  {\n+\t\t    fputs (\") DEPEND(\", dumpfile);\n+\t\t    break;\n+\t\t  }\n+\t\tfputc (',', dumpfile);\n+\t\tn = n->next;\n+\t      }\n+\t    continue;\n \t  default: break;\n \t  }\n       else if (list_type == OMP_LIST_MAP)\n@@ -1070,7 +1091,17 @@ show_omp_namelist (int list_type, gfc_omp_namelist *n)\n \t  case OMP_MAP_TOFROM: fputs (\"tofrom:\", dumpfile); break;\n \t  default: break;\n \t  }\n+      else if (list_type == OMP_LIST_LINEAR)\n+\tswitch (n->u.linear_op)\n+\t  {\n+\t  case OMP_LINEAR_REF: fputs (\"ref(\", dumpfile); break;\n+\t  case OMP_LINEAR_VAL: fputs (\"val(\", dumpfile); break;\n+\t  case OMP_LINEAR_UVAL: fputs (\"uval(\", dumpfile); break;\n+\t  default: break;\n+\t  }\n       fprintf (dumpfile, \"%s\", n->sym->name);\n+      if (list_type == OMP_LIST_LINEAR && n->u.linear_op != OMP_LINEAR_DEFAULT)\n+\tfputc (')', dumpfile);\n       if (n->expr)\n \t{\n \t  fputc (':', dumpfile);\n@@ -1087,7 +1118,7 @@ show_omp_namelist (int list_type, gfc_omp_namelist *n)\n static void\n show_omp_clauses (gfc_omp_clauses *omp_clauses)\n {\n-  int list_type;\n+  int list_type, i;\n \n   switch (omp_clauses->cancel)\n     {\n@@ -1209,7 +1240,20 @@ show_omp_clauses (gfc_omp_clauses *omp_clauses)\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n-      fprintf (dumpfile, \" SCHEDULE (%s\", type);\n+      fputs (\" SCHEDULE (\", dumpfile);\n+      if (omp_clauses->sched_simd)\n+\t{\n+\t  if (omp_clauses->sched_monotonic\n+\t      || omp_clauses->sched_nonmonotonic)\n+\t    fputs (\"SIMD, \", dumpfile);\n+\t  else\n+\t    fputs (\"SIMD: \", dumpfile);\n+\t}\n+      if (omp_clauses->sched_monotonic)\n+\tfputs (\"MONOTONIC: \", dumpfile);\n+      else if (omp_clauses->sched_nonmonotonic)\n+\tfputs (\"NONMONOTONIC: \", dumpfile);\n+      fputs (type, dumpfile);\n       if (omp_clauses->chunk_size)\n \t{\n \t  fputc (',', dumpfile);\n@@ -1260,7 +1304,12 @@ show_omp_clauses (gfc_omp_clauses *omp_clauses)\n   if (omp_clauses->independent)\n     fputs (\" INDEPENDENT\", dumpfile);\n   if (omp_clauses->ordered)\n-    fputs (\" ORDERED\", dumpfile);\n+    {\n+      if (omp_clauses->orderedc)\n+\tfprintf (dumpfile, \" ORDERED(%d)\", omp_clauses->orderedc);\n+      else\n+\tfputs (\" ORDERED\", dumpfile);\n+    }\n   if (omp_clauses->untied)\n     fputs (\" UNTIED\", dumpfile);\n   if (omp_clauses->mergeable)\n@@ -1286,6 +1335,8 @@ show_omp_clauses (gfc_omp_clauses *omp_clauses)\n \t  case OMP_LIST_ALIGNED: type = \"ALIGNED\"; break;\n \t  case OMP_LIST_LINEAR: type = \"LINEAR\"; break;\n \t  case OMP_LIST_REDUCTION: type = \"REDUCTION\"; break;\n+\t  case OMP_LIST_IS_DEVICE_PTR: type = \"IS_DEVICE_PTR\"; break;\n+\t  case OMP_LIST_USE_DEVICE_PTR: type = \"USE_DEVICE_PTR\"; break;\n \t  case OMP_LIST_DEPEND: type = \"DEPEND\"; break;\n \t  default:\n \t    gcc_unreachable ();\n@@ -1343,14 +1394,67 @@ show_omp_clauses (gfc_omp_clauses *omp_clauses)\n     }\n   if (omp_clauses->dist_sched_kind != OMP_SCHED_NONE)\n     {\n-      fprintf (dumpfile, \" DIST_SCHEDULE (static\");\n+      fprintf (dumpfile, \" DIST_SCHEDULE (STATIC\");\n       if (omp_clauses->dist_chunk_size)\n \t{\n \t  fputc (',', dumpfile);\n \t  show_expr (omp_clauses->dist_chunk_size);\n \t}\n       fputc (')', dumpfile);\n     }\n+  if (omp_clauses->defaultmap)\n+    fputs (\" DEFALTMAP (TOFROM: SCALAR)\", dumpfile);\n+  if (omp_clauses->nogroup)\n+    fputs (\" NOGROUP\", dumpfile);\n+  if (omp_clauses->simd)\n+    fputs (\" SIMD\", dumpfile);\n+  if (omp_clauses->threads)\n+    fputs (\" THREADS\", dumpfile);\n+  if (omp_clauses->grainsize)\n+    {\n+      fputs (\" GRAINSIZE(\", dumpfile);\n+      show_expr (omp_clauses->grainsize);\n+      fputc (')', dumpfile);\n+    }\n+  if (omp_clauses->hint)\n+    {\n+      fputs (\" HINT(\", dumpfile);\n+      show_expr (omp_clauses->hint);\n+      fputc (')', dumpfile);\n+    }\n+  if (omp_clauses->num_tasks)\n+    {\n+      fputs (\" NUM_TASKS(\", dumpfile);\n+      show_expr (omp_clauses->num_tasks);\n+      fputc (')', dumpfile);\n+    }\n+  if (omp_clauses->priority)\n+    {\n+      fputs (\" PRIORITY(\", dumpfile);\n+      show_expr (omp_clauses->priority);\n+      fputc (')', dumpfile);\n+    }\n+  for (i = 0; i < OMP_IF_LAST; i++)\n+    if (omp_clauses->if_exprs[i])\n+      {\n+\tstatic const char *ifs[] = {\n+\t  \"PARALLEL\",\n+\t  \"TASK\",\n+\t  \"TASKLOOP\",\n+\t  \"TARGET\",\n+\t  \"TARGET DATA\",\n+\t  \"TARGET UPDATE\",\n+\t  \"TARGET ENTER DATA\",\n+\t  \"TARGET EXIT DATA\"\n+\t};\n+      fputs (\" IF(\", dumpfile);\n+      fputs (ifs[i], dumpfile);\n+      fputs (\": \", dumpfile);\n+      show_expr (omp_clauses->if_exprs[i]);\n+      fputc (')', dumpfile);\n+    }\n+  if (omp_clauses->depend_source)\n+    fputs (\" DEPEND(source)\", dumpfile);\n }\n \n /* Show a single OpenMP or OpenACC directive node and everything underneath it\n@@ -1365,7 +1469,8 @@ show_omp_node (int level, gfc_code *c)\n \n   switch (c->op)\n     {\n-    case EXEC_OACC_PARALLEL_LOOP: name = \"PARALLEL LOOP\"; is_oacc = true; break;\n+    case EXEC_OACC_PARALLEL_LOOP:\n+      name = \"PARALLEL LOOP\"; is_oacc = true; break;\n     case EXEC_OACC_PARALLEL: name = \"PARALLEL\"; is_oacc = true; break;\n     case EXEC_OACC_KERNELS_LOOP: name = \"KERNELS LOOP\"; is_oacc = true; break;\n     case EXEC_OACC_KERNELS: name = \"KERNELS\"; is_oacc = true; break;\n@@ -1382,9 +1487,15 @@ show_omp_node (int level, gfc_code *c)\n     case EXEC_OMP_CANCEL: name = \"CANCEL\"; break;\n     case EXEC_OMP_CANCELLATION_POINT: name = \"CANCELLATION POINT\"; break;\n     case EXEC_OMP_CRITICAL: name = \"CRITICAL\"; break;\n-    case EXEC_OMP_FLUSH: name = \"FLUSH\"; break;\n+    case EXEC_OMP_DISTRIBUTE: name = \"DISTRIBUTE\"; break;\n+    case EXEC_OMP_DISTRIBUTE_PARALLEL_DO:\n+      name = \"DISTRIBUTE PARALLEL DO\"; break;\n+    case EXEC_OMP_DISTRIBUTE_PARALLEL_DO_SIMD:\n+      name = \"DISTRIBUTE PARALLEL DO SIMD\"; break;\n+    case EXEC_OMP_DISTRIBUTE_SIMD: name = \"DISTRIBUTE SIMD\"; break;\n     case EXEC_OMP_DO: name = \"DO\"; break;\n     case EXEC_OMP_DO_SIMD: name = \"DO SIMD\"; break;\n+    case EXEC_OMP_FLUSH: name = \"FLUSH\"; break;\n     case EXEC_OMP_MASTER: name = \"MASTER\"; break;\n     case EXEC_OMP_ORDERED: name = \"ORDERED\"; break;\n     case EXEC_OMP_PARALLEL: name = \"PARALLEL\"; break;\n@@ -1395,10 +1506,38 @@ show_omp_node (int level, gfc_code *c)\n     case EXEC_OMP_SECTIONS: name = \"SECTIONS\"; break;\n     case EXEC_OMP_SIMD: name = \"SIMD\"; break;\n     case EXEC_OMP_SINGLE: name = \"SINGLE\"; break;\n+    case EXEC_OMP_TARGET: name = \"TARGET\"; break;\n+    case EXEC_OMP_TARGET_DATA: name = \"TARGET DATA\"; break;\n+    case EXEC_OMP_TARGET_ENTER_DATA: name = \"TARGET ENTER DATA\"; break;\n+    case EXEC_OMP_TARGET_EXIT_DATA: name = \"TARGET EXIT DATA\"; break;\n+    case EXEC_OMP_TARGET_PARALLEL: name = \"TARGET PARALLEL\"; break;\n+    case EXEC_OMP_TARGET_PARALLEL_DO: name = \"TARGET PARALLEL DO\"; break;\n+    case EXEC_OMP_TARGET_PARALLEL_DO_SIMD:\n+      name = \"TARGET_PARALLEL_DO_SIMD\"; break;\n+    case EXEC_OMP_TARGET_SIMD: name = \"TARGET SIMD\"; break;\n+    case EXEC_OMP_TARGET_TEAMS: name = \"TARGET TEAMS\"; break;\n+    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE:\n+      name = \"TARGET TEAMS DISTRIBUTE\"; break;\n+    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO:\n+      name = \"TARGET TEAMS DISTRIBUTE PARALLEL DO\"; break;\n+    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD:\n+      name = \"TARGET TEAMS DISTRIBUTE PARALLEL DO SIMD\"; break;\n+    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_SIMD:\n+      name = \"TARGET TEAMS DISTRIBUTE SIMD\"; break;\n+    case EXEC_OMP_TARGET_UPDATE: name = \"TARGET UPDATE\"; break;\n     case EXEC_OMP_TASK: name = \"TASK\"; break;\n     case EXEC_OMP_TASKGROUP: name = \"TASKGROUP\"; break;\n+    case EXEC_OMP_TASKLOOP: name = \"TASKLOOP\"; break;\n+    case EXEC_OMP_TASKLOOP_SIMD: name = \"TASKLOOP SIMD\"; break;\n     case EXEC_OMP_TASKWAIT: name = \"TASKWAIT\"; break;\n     case EXEC_OMP_TASKYIELD: name = \"TASKYIELD\"; break;\n+    case EXEC_OMP_TEAMS: name = \"TEAMS\"; break;\n+    case EXEC_OMP_TEAMS_DISTRIBUTE: name = \"TEAMS DISTRIBUTE\"; break;\n+    case EXEC_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO:\n+      name = \"TEAMS DISTRIBUTE PARALLEL DO\"; break;\n+    case EXEC_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD:\n+      name = \"TEAMS DISTRIBUTE PARALLEL DO SIMD\"; break;\n+    case EXEC_OMP_TEAMS_DISTRIBUTE_SIMD: name = \"TEAMS DISTRIBUTE SIMD\"; break;\n     case EXEC_OMP_WORKSHARE: name = \"WORKSHARE\"; break;\n     default:\n       gcc_unreachable ();\n@@ -1420,23 +1559,50 @@ show_omp_node (int level, gfc_code *c)\n     case EXEC_OACC_EXIT_DATA:\n     case EXEC_OMP_CANCEL:\n     case EXEC_OMP_CANCELLATION_POINT:\n+    case EXEC_OMP_DISTRIBUTE:\n+    case EXEC_OMP_DISTRIBUTE_PARALLEL_DO:\n+    case EXEC_OMP_DISTRIBUTE_PARALLEL_DO_SIMD:\n+    case EXEC_OMP_DISTRIBUTE_SIMD:\n     case EXEC_OMP_DO:\n     case EXEC_OMP_DO_SIMD:\n+    case EXEC_OMP_ORDERED:\n     case EXEC_OMP_PARALLEL:\n     case EXEC_OMP_PARALLEL_DO:\n     case EXEC_OMP_PARALLEL_DO_SIMD:\n     case EXEC_OMP_PARALLEL_SECTIONS:\n+    case EXEC_OMP_PARALLEL_WORKSHARE:\n     case EXEC_OMP_SECTIONS:\n     case EXEC_OMP_SIMD:\n     case EXEC_OMP_SINGLE:\n-    case EXEC_OMP_WORKSHARE:\n-    case EXEC_OMP_PARALLEL_WORKSHARE:\n+    case EXEC_OMP_TARGET:\n+    case EXEC_OMP_TARGET_DATA:\n+    case EXEC_OMP_TARGET_ENTER_DATA:\n+    case EXEC_OMP_TARGET_EXIT_DATA:\n+    case EXEC_OMP_TARGET_PARALLEL:\n+    case EXEC_OMP_TARGET_PARALLEL_DO:\n+    case EXEC_OMP_TARGET_PARALLEL_DO_SIMD:\n+    case EXEC_OMP_TARGET_SIMD:\n+    case EXEC_OMP_TARGET_TEAMS:\n+    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE:\n+    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO:\n+    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD:\n+    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_SIMD:\n+    case EXEC_OMP_TARGET_UPDATE:\n     case EXEC_OMP_TASK:\n+    case EXEC_OMP_TASKLOOP:\n+    case EXEC_OMP_TASKLOOP_SIMD:\n+    case EXEC_OMP_TEAMS:\n+    case EXEC_OMP_TEAMS_DISTRIBUTE:\n+    case EXEC_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO:\n+    case EXEC_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD:\n+    case EXEC_OMP_TEAMS_DISTRIBUTE_SIMD:\n+    case EXEC_OMP_WORKSHARE:\n       omp_clauses = c->ext.omp_clauses;\n       break;\n     case EXEC_OMP_CRITICAL:\n-      if (c->ext.omp_name)\n-\tfprintf (dumpfile, \" (%s)\", c->ext.omp_name);\n+      omp_clauses = c->ext.omp_clauses;\n+      if (omp_clauses)\n+\tfprintf (dumpfile, \" (%s)\", c->ext.omp_clauses->critical_name);\n       break;\n     case EXEC_OMP_FLUSH:\n       if (c->ext.omp_namelist)\n@@ -1457,9 +1623,12 @@ show_omp_node (int level, gfc_code *c)\n     show_omp_clauses (omp_clauses);\n   fputc ('\\n', dumpfile);\n \n-  /* OpenACC executable directives don't have associated blocks.  */\n+  /* OpenMP and OpenACC executable directives don't have associated blocks.  */\n   if (c->op == EXEC_OACC_CACHE || c->op == EXEC_OACC_UPDATE\n-      || c->op == EXEC_OACC_ENTER_DATA || c->op == EXEC_OACC_EXIT_DATA)\n+      || c->op == EXEC_OACC_ENTER_DATA || c->op == EXEC_OACC_EXIT_DATA\n+      || c->op == EXEC_OMP_TARGET_UPDATE || c->op == EXEC_OMP_TARGET_ENTER_DATA\n+      || c->op == EXEC_OMP_TARGET_EXIT_DATA\n+      || (c->op == EXEC_OMP_ORDERED && c->block == NULL))\n     return;\n   if (c->op == EXEC_OMP_SECTIONS || c->op == EXEC_OMP_PARALLEL_SECTIONS)\n     {\n@@ -1493,8 +1662,8 @@ show_omp_node (int level, gfc_code *c)\n       else if (omp_clauses->nowait)\n \tfputs (\" NOWAIT\", dumpfile);\n     }\n-  else if (c->op == EXEC_OMP_CRITICAL && c->ext.omp_name)\n-    fprintf (dumpfile, \" (%s)\", c->ext.omp_name);\n+  else if (c->op == EXEC_OMP_CRITICAL && c->ext.omp_clauses)\n+    fprintf (dumpfile, \" (%s)\", c->ext.omp_clauses->critical_name);\n }\n \n \n@@ -2520,9 +2689,13 @@ show_code_node (int level, gfc_code *c)\n     case EXEC_OMP_CANCELLATION_POINT:\n     case EXEC_OMP_BARRIER:\n     case EXEC_OMP_CRITICAL:\n-    case EXEC_OMP_FLUSH:\n+    case EXEC_OMP_DISTRIBUTE:\n+    case EXEC_OMP_DISTRIBUTE_PARALLEL_DO:\n+    case EXEC_OMP_DISTRIBUTE_PARALLEL_DO_SIMD:\n+    case EXEC_OMP_DISTRIBUTE_SIMD:\n     case EXEC_OMP_DO:\n     case EXEC_OMP_DO_SIMD:\n+    case EXEC_OMP_FLUSH:\n     case EXEC_OMP_MASTER:\n     case EXEC_OMP_ORDERED:\n     case EXEC_OMP_PARALLEL:\n@@ -2533,10 +2706,31 @@ show_code_node (int level, gfc_code *c)\n     case EXEC_OMP_SECTIONS:\n     case EXEC_OMP_SIMD:\n     case EXEC_OMP_SINGLE:\n+    case EXEC_OMP_TARGET:\n+    case EXEC_OMP_TARGET_DATA:\n+    case EXEC_OMP_TARGET_ENTER_DATA:\n+    case EXEC_OMP_TARGET_EXIT_DATA:\n+    case EXEC_OMP_TARGET_PARALLEL:\n+    case EXEC_OMP_TARGET_PARALLEL_DO:\n+    case EXEC_OMP_TARGET_PARALLEL_DO_SIMD:\n+    case EXEC_OMP_TARGET_SIMD:\n+    case EXEC_OMP_TARGET_TEAMS:\n+    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE:\n+    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO:\n+    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD:\n+    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_SIMD:\n+    case EXEC_OMP_TARGET_UPDATE:\n     case EXEC_OMP_TASK:\n     case EXEC_OMP_TASKGROUP:\n+    case EXEC_OMP_TASKLOOP:\n+    case EXEC_OMP_TASKLOOP_SIMD:\n     case EXEC_OMP_TASKWAIT:\n     case EXEC_OMP_TASKYIELD:\n+    case EXEC_OMP_TEAMS:\n+    case EXEC_OMP_TEAMS_DISTRIBUTE:\n+    case EXEC_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO:\n+    case EXEC_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD:\n+    case EXEC_OMP_TEAMS_DISTRIBUTE_SIMD:\n     case EXEC_OMP_WORKSHARE:\n       show_omp_node (level, c);\n       break;"}, {"sha": "cea6675d53a8c0bd68348d7f60eaf27a0ac11f78", "filename": "gcc/fortran/f95-lang.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c3a85be96585374bf95c981ba2f602667cf5b7/gcc%2Ffortran%2Ff95-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c3a85be96585374bf95c981ba2f602667cf5b7/gcc%2Ffortran%2Ff95-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.c?ref=b4c3a85be96585374bf95c981ba2f602667cf5b7", "patch": "@@ -92,6 +92,8 @@ static const struct attribute_spec gfc_attribute_table[] =\n        affects_type_identity } */\n   { \"omp declare target\", 0, 0, true,  false, false,\n     gfc_handle_omp_declare_target_attribute, false },\n+  { \"omp declare target link\", 0, 0, true,  false, false,\n+    gfc_handle_omp_declare_target_attribute, false },\n   { \"oacc function\", 0, -1, true,  false, false,\n     gfc_handle_omp_declare_target_attribute, false },\n   { NULL,\t\t  0, 0, false, false, false, NULL, false }\n@@ -119,6 +121,7 @@ static const struct attribute_spec gfc_attribute_table[] =\n #undef LANG_HOOKS_OMP_CLAUSE_LINEAR_CTOR\n #undef LANG_HOOKS_OMP_CLAUSE_DTOR\n #undef LANG_HOOKS_OMP_FINISH_CLAUSE\n+#undef LANG_HOOKS_OMP_SCALAR_P\n #undef LANG_HOOKS_OMP_DISREGARD_VALUE_EXPR\n #undef LANG_HOOKS_OMP_PRIVATE_DEBUG_CLAUSE\n #undef LANG_HOOKS_OMP_PRIVATE_OUTER_REF\n@@ -150,6 +153,7 @@ static const struct attribute_spec gfc_attribute_table[] =\n #define LANG_HOOKS_OMP_CLAUSE_LINEAR_CTOR\tgfc_omp_clause_linear_ctor\n #define LANG_HOOKS_OMP_CLAUSE_DTOR\t\tgfc_omp_clause_dtor\n #define LANG_HOOKS_OMP_FINISH_CLAUSE\t\tgfc_omp_finish_clause\n+#define LANG_HOOKS_OMP_SCALAR_P\t\t\tgfc_omp_scalar_p\n #define LANG_HOOKS_OMP_DISREGARD_VALUE_EXPR\tgfc_omp_disregard_value_expr\n #define LANG_HOOKS_OMP_PRIVATE_DEBUG_CLAUSE\tgfc_omp_private_debug_clause\n #define LANG_HOOKS_OMP_PRIVATE_OUTER_REF\tgfc_omp_private_outer_ref"}, {"sha": "44d2a4218b7efc19ffb75d027e89882320dcfd90", "filename": "gcc/fortran/frontend-passes.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c3a85be96585374bf95c981ba2f602667cf5b7/gcc%2Ffortran%2Ffrontend-passes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c3a85be96585374bf95c981ba2f602667cf5b7/gcc%2Ffortran%2Ffrontend-passes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ffrontend-passes.c?ref=b4c3a85be96585374bf95c981ba2f602667cf5b7", "patch": "@@ -3647,18 +3647,28 @@ gfc_code_walker (gfc_code **c, walk_code_fn_t codefn, walk_expr_fn_t exprfn,\n \n \t      /* Fall through  */\n \n+\t    case EXEC_OMP_CRITICAL:\n \t    case EXEC_OMP_DISTRIBUTE:\n \t    case EXEC_OMP_DISTRIBUTE_PARALLEL_DO:\n \t    case EXEC_OMP_DISTRIBUTE_PARALLEL_DO_SIMD:\n \t    case EXEC_OMP_DISTRIBUTE_SIMD:\n \t    case EXEC_OMP_DO:\n \t    case EXEC_OMP_DO_SIMD:\n+\t    case EXEC_OMP_ORDERED:\n \t    case EXEC_OMP_SECTIONS:\n \t    case EXEC_OMP_SINGLE:\n \t    case EXEC_OMP_END_SINGLE:\n \t    case EXEC_OMP_SIMD:\n+\t    case EXEC_OMP_TASKLOOP:\n+\t    case EXEC_OMP_TASKLOOP_SIMD:\n \t    case EXEC_OMP_TARGET:\n \t    case EXEC_OMP_TARGET_DATA:\n+\t    case EXEC_OMP_TARGET_ENTER_DATA:\n+\t    case EXEC_OMP_TARGET_EXIT_DATA:\n+\t    case EXEC_OMP_TARGET_PARALLEL:\n+\t    case EXEC_OMP_TARGET_PARALLEL_DO:\n+\t    case EXEC_OMP_TARGET_PARALLEL_DO_SIMD:\n+\t    case EXEC_OMP_TARGET_SIMD:\n \t    case EXEC_OMP_TARGET_TEAMS:\n \t    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE:\n \t    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO:\n@@ -3694,6 +3704,12 @@ gfc_code_walker (gfc_code **c, walk_code_fn_t codefn, walk_expr_fn_t exprfn,\n \t\t  WALK_SUBEXPR (co->ext.omp_clauses->device);\n \t\t  WALK_SUBEXPR (co->ext.omp_clauses->thread_limit);\n \t\t  WALK_SUBEXPR (co->ext.omp_clauses->dist_chunk_size);\n+\t\t  WALK_SUBEXPR (co->ext.omp_clauses->grainsize);\n+\t\t  WALK_SUBEXPR (co->ext.omp_clauses->hint);\n+\t\t  WALK_SUBEXPR (co->ext.omp_clauses->num_tasks);\n+\t\t  WALK_SUBEXPR (co->ext.omp_clauses->priority);\n+\t\t  for (idx = 0; idx < OMP_IF_LAST; idx++)\n+\t\t    WALK_SUBEXPR (co->ext.omp_clauses->if_exprs[idx]);\n \t\t  for (idx = 0;\n \t\t       idx < sizeof (list_types) / sizeof (list_types[0]);\n \t\t       idx++)"}, {"sha": "7956630f61dee8e9e7e52a8de2d50e56d7e5cd19", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 61, "deletions": 6, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c3a85be96585374bf95c981ba2f602667cf5b7/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c3a85be96585374bf95c981ba2f602667cf5b7/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=b4c3a85be96585374bf95c981ba2f602667cf5b7", "patch": "@@ -254,6 +254,13 @@ enum gfc_statement\n   ST_OMP_END_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD,\n   ST_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD,\n   ST_OMP_END_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD,\n+  ST_OMP_TARGET_PARALLEL, ST_OMP_END_TARGET_PARALLEL,\n+  ST_OMP_TARGET_PARALLEL_DO, ST_OMP_END_TARGET_PARALLEL_DO,\n+  ST_OMP_TARGET_PARALLEL_DO_SIMD, ST_OMP_END_TARGET_PARALLEL_DO_SIMD,\n+  ST_OMP_TARGET_ENTER_DATA, ST_OMP_TARGET_EXIT_DATA,\n+  ST_OMP_TARGET_SIMD, ST_OMP_END_TARGET_SIMD,\n+  ST_OMP_TASKLOOP, ST_OMP_END_TASKLOOP,\n+  ST_OMP_TASKLOOP_SIMD, ST_OMP_END_TASKLOOP_SIMD, ST_OMP_ORDERED_DEPEND,\n   ST_PROCEDURE, ST_GENERIC, ST_CRITICAL, ST_END_CRITICAL,\n   ST_GET_FCN_CHARACTERISTICS, ST_LOCK, ST_UNLOCK, ST_EVENT_POST,\n   ST_EVENT_WAIT,ST_NONE\n@@ -865,6 +872,7 @@ typedef struct\n \n   /* Mentioned in OMP DECLARE TARGET.  */\n   unsigned omp_declare_target:1;\n+  unsigned omp_declare_target_link:1;\n \n   /* Mentioned in OACC DECLARE.  */\n   unsigned oacc_declare_create:1;\n@@ -1128,7 +1136,9 @@ enum gfc_omp_depend_op\n {\n   OMP_DEPEND_IN,\n   OMP_DEPEND_OUT,\n-  OMP_DEPEND_INOUT\n+  OMP_DEPEND_INOUT,\n+  OMP_DEPEND_SINK_FIRST,\n+  OMP_DEPEND_SINK\n };\n \n enum gfc_omp_map_op\n@@ -1145,7 +1155,19 @@ enum gfc_omp_map_op\n   OMP_MAP_FORCE_PRESENT,\n   OMP_MAP_FORCE_DEVICEPTR,\n   OMP_MAP_DEVICE_RESIDENT,\n-  OMP_MAP_LINK\n+  OMP_MAP_LINK,\n+  OMP_MAP_RELEASE,\n+  OMP_MAP_ALWAYS_TO,\n+  OMP_MAP_ALWAYS_FROM,\n+  OMP_MAP_ALWAYS_TOFROM\n+};\n+\n+enum gfc_omp_linear_op\n+{\n+  OMP_LINEAR_DEFAULT,\n+  OMP_LINEAR_REF,\n+  OMP_LINEAR_VAL,\n+  OMP_LINEAR_UVAL\n };\n \n /* For use in OpenMP clauses in case we need extra information\n@@ -1160,6 +1182,8 @@ typedef struct gfc_omp_namelist\n       gfc_omp_reduction_op reduction_op;\n       gfc_omp_depend_op depend_op;\n       gfc_omp_map_op map_op;\n+      gfc_omp_linear_op linear_op;\n+      struct gfc_common_head *common;\n     } u;\n   struct gfc_omp_namelist_udr *udr;\n   struct gfc_omp_namelist *next;\n@@ -1190,6 +1214,8 @@ enum\n   OMP_LIST_LINK,\n   OMP_LIST_USE_DEVICE,\n   OMP_LIST_CACHE,\n+  OMP_LIST_IS_DEVICE_PTR,\n+  OMP_LIST_USE_DEVICE_PTR,\n   OMP_LIST_NUM\n };\n \n@@ -1232,6 +1258,19 @@ enum gfc_omp_cancel_kind\n   OMP_CANCEL_TASKGROUP\n };\n \n+enum gfc_omp_if_kind\n+{\n+  OMP_IF_PARALLEL,\n+  OMP_IF_TASK,\n+  OMP_IF_TASKLOOP,\n+  OMP_IF_TARGET,\n+  OMP_IF_TARGET_DATA,\n+  OMP_IF_TARGET_UPDATE,\n+  OMP_IF_TARGET_ENTER_DATA,\n+  OMP_IF_TARGET_EXIT_DATA,\n+  OMP_IF_LAST\n+};\n+\n typedef struct gfc_omp_clauses\n {\n   struct gfc_expr *if_expr;\n@@ -1241,18 +1280,26 @@ typedef struct gfc_omp_clauses\n   enum gfc_omp_sched_kind sched_kind;\n   struct gfc_expr *chunk_size;\n   enum gfc_omp_default_sharing default_sharing;\n-  int collapse;\n+  int collapse, orderedc;\n   bool nowait, ordered, untied, mergeable;\n-  bool inbranch, notinbranch;\n+  bool inbranch, notinbranch, defaultmap, nogroup;\n+  bool sched_simd, sched_monotonic, sched_nonmonotonic;\n+  bool simd, threads, depend_source;\n   enum gfc_omp_cancel_kind cancel;\n   enum gfc_omp_proc_bind_kind proc_bind;\n   struct gfc_expr *safelen_expr;\n   struct gfc_expr *simdlen_expr;\n   struct gfc_expr *num_teams;\n   struct gfc_expr *device;\n   struct gfc_expr *thread_limit;\n+  struct gfc_expr *grainsize;\n+  struct gfc_expr *hint;\n+  struct gfc_expr *num_tasks;\n+  struct gfc_expr *priority;\n+  struct gfc_expr *if_exprs[OMP_IF_LAST];\n   enum gfc_omp_sched_kind dist_sched_kind;\n   struct gfc_expr *dist_chunk_size;\n+  const char *critical_name;\n \n   /* OpenACC. */\n   struct gfc_expr *async_expr;\n@@ -1541,7 +1588,9 @@ struct gfc_undo_change_set\n typedef struct gfc_common_head\n {\n   locus where;\n-  char use_assoc, saved, threadprivate, omp_declare_target;\n+  char use_assoc, saved, threadprivate;\n+  unsigned char omp_declare_target : 1;\n+  unsigned char omp_declare_target_link : 1;\n   char name[GFC_MAX_SYMBOL_LEN + 1];\n   struct gfc_symbol *head;\n   const char* binding_label;\n@@ -2424,7 +2473,11 @@ enum gfc_exec_op\n   EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO,\n   EXEC_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD,\n   EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD,\n-  EXEC_OMP_TARGET_UPDATE\n+  EXEC_OMP_TARGET_UPDATE, EXEC_OMP_END_CRITICAL,\n+  EXEC_OMP_TARGET_ENTER_DATA, EXEC_OMP_TARGET_EXIT_DATA,\n+  EXEC_OMP_TARGET_PARALLEL, EXEC_OMP_TARGET_PARALLEL_DO,\n+  EXEC_OMP_TARGET_PARALLEL_DO_SIMD, EXEC_OMP_TARGET_SIMD,\n+  EXEC_OMP_TASKLOOP, EXEC_OMP_TASKLOOP_SIMD\n };\n \n enum gfc_omp_atomic_op\n@@ -2823,6 +2876,8 @@ bool gfc_add_automatic (symbol_attribute *, const char *, locus *);\n bool gfc_add_save (symbol_attribute *, save_state, const char *, locus *);\n bool gfc_add_threadprivate (symbol_attribute *, const char *, locus *);\n bool gfc_add_omp_declare_target (symbol_attribute *, const char *, locus *);\n+bool gfc_add_omp_declare_target_link (symbol_attribute *, const char *,\n+\t\t\t\t      locus *);\n bool gfc_add_saved_common (symbol_attribute *, locus *);\n bool gfc_add_target (symbol_attribute *, locus *);\n bool gfc_add_dummy (symbol_attribute *, const char *, locus *);"}, {"sha": "523cba45c7ea57942b9ba72ba59c1f353aacba5a", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c3a85be96585374bf95c981ba2f602667cf5b7/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c3a85be96585374bf95c981ba2f602667cf5b7/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=b4c3a85be96585374bf95c981ba2f602667cf5b7", "patch": "@@ -2787,21 +2787,25 @@ match_exit_cycle (gfc_statement st, gfc_exec_op op)\n \t  || o->head->op == EXEC_OMP_DO_SIMD\n \t  || o->head->op == EXEC_OMP_PARALLEL_DO_SIMD))\n     {\n-      int collapse = 1;\n+      int count = 1;\n       gcc_assert (o->head->next != NULL\n \t\t  && (o->head->next->op == EXEC_DO\n \t\t      || o->head->next->op == EXEC_DO_WHILE)\n \t\t  && o->previous != NULL\n \t\t  && o->previous->tail->op == o->head->op);\n-      if (o->previous->tail->ext.omp_clauses != NULL\n-\t  && o->previous->tail->ext.omp_clauses->collapse > 1)\n-\tcollapse = o->previous->tail->ext.omp_clauses->collapse;\n-      if (st == ST_EXIT && cnt <= collapse)\n+      if (o->previous->tail->ext.omp_clauses != NULL)\n+\t{\n+\t  if (o->previous->tail->ext.omp_clauses->collapse > 1)\n+\t    count = o->previous->tail->ext.omp_clauses->collapse;\n+\t  if (o->previous->tail->ext.omp_clauses->orderedc)\n+\t    count = o->previous->tail->ext.omp_clauses->orderedc;\n+\t}\n+      if (st == ST_EXIT && cnt <= count)\n \t{\n \t  gfc_error (\"EXIT statement at %C terminating !$OMP DO loop\");\n \t  return MATCH_ERROR;\n \t}\n-      if (st == ST_CYCLE && cnt < collapse)\n+      if (st == ST_CYCLE && cnt < count)\n \t{\n \t  gfc_error (\"CYCLE statement at %C to non-innermost collapsed\"\n \t\t     \" !$OMP DO loop\");"}, {"sha": "e87e939a812dd81bd2f08ae10f5304c2d45a5d48", "filename": "gcc/fortran/match.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c3a85be96585374bf95c981ba2f602667cf5b7/gcc%2Ffortran%2Fmatch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c3a85be96585374bf95c981ba2f602667cf5b7/gcc%2Ffortran%2Fmatch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.h?ref=b4c3a85be96585374bf95c981ba2f602667cf5b7", "patch": "@@ -162,6 +162,7 @@ match gfc_match_omp_do_simd (void);\n match gfc_match_omp_flush (void);\n match gfc_match_omp_master (void);\n match gfc_match_omp_ordered (void);\n+match gfc_match_omp_ordered_depend (void);\n match gfc_match_omp_parallel (void);\n match gfc_match_omp_parallel_do (void);\n match gfc_match_omp_parallel_do_simd (void);\n@@ -172,6 +173,12 @@ match gfc_match_omp_simd (void);\n match gfc_match_omp_single (void);\n match gfc_match_omp_target (void);\n match gfc_match_omp_target_data (void);\n+match gfc_match_omp_target_enter_data (void);\n+match gfc_match_omp_target_exit_data (void);\n+match gfc_match_omp_target_parallel (void);\n+match gfc_match_omp_target_parallel_do (void);\n+match gfc_match_omp_target_parallel_do_simd (void);\n+match gfc_match_omp_target_simd (void);\n match gfc_match_omp_target_teams (void);\n match gfc_match_omp_target_teams_distribute (void);\n match gfc_match_omp_target_teams_distribute_parallel_do (void);\n@@ -180,6 +187,8 @@ match gfc_match_omp_target_teams_distribute_simd (void);\n match gfc_match_omp_target_update (void);\n match gfc_match_omp_task (void);\n match gfc_match_omp_taskgroup (void);\n+match gfc_match_omp_taskloop (void);\n+match gfc_match_omp_taskloop_simd (void);\n match gfc_match_omp_taskwait (void);\n match gfc_match_omp_taskyield (void);\n match gfc_match_omp_teams (void);\n@@ -189,6 +198,7 @@ match gfc_match_omp_teams_distribute_parallel_do_simd (void);\n match gfc_match_omp_teams_distribute_simd (void);\n match gfc_match_omp_threadprivate (void);\n match gfc_match_omp_workshare (void);\n+match gfc_match_omp_end_critical (void);\n match gfc_match_omp_end_nowait (void);\n match gfc_match_omp_end_single (void);\n "}, {"sha": "4116db8ecadee9984519c760364b55a04f5f223f", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c3a85be96585374bf95c981ba2f602667cf5b7/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c3a85be96585374bf95c981ba2f602667cf5b7/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=b4c3a85be96585374bf95c981ba2f602667cf5b7", "patch": "@@ -1988,7 +1988,8 @@ enum ab_attribute\n   AB_IMPLICIT_PURE, AB_ARTIFICIAL, AB_UNLIMITED_POLY, AB_OMP_DECLARE_TARGET,\n   AB_ARRAY_OUTER_DEPENDENCY, AB_MODULE_PROCEDURE, AB_OACC_DECLARE_CREATE,\n   AB_OACC_DECLARE_COPYIN, AB_OACC_DECLARE_DEVICEPTR,\n-  AB_OACC_DECLARE_DEVICE_RESIDENT, AB_OACC_DECLARE_LINK\n+  AB_OACC_DECLARE_DEVICE_RESIDENT, AB_OACC_DECLARE_LINK,\n+  AB_OMP_DECLARE_TARGET_LINK\n };\n \n static const mstring attr_bits[] =\n@@ -2051,6 +2052,7 @@ static const mstring attr_bits[] =\n     minit (\"OACC_DECLARE_DEVICEPTR\", AB_OACC_DECLARE_DEVICEPTR),\n     minit (\"OACC_DECLARE_DEVICE_RESIDENT\", AB_OACC_DECLARE_DEVICE_RESIDENT),\n     minit (\"OACC_DECLARE_LINK\", AB_OACC_DECLARE_LINK),\n+    minit (\"OMP_DECLARE_TARGET_LINK\", AB_OMP_DECLARE_TARGET_LINK),\n     minit (NULL, -1)\n };\n \n@@ -2250,6 +2252,8 @@ mio_symbol_attribute (symbol_attribute *attr)\n \tMIO_NAME (ab_attribute) (AB_OACC_DECLARE_DEVICE_RESIDENT, attr_bits);\n       if (attr->oacc_declare_link)\n \tMIO_NAME (ab_attribute) (AB_OACC_DECLARE_LINK, attr_bits);\n+      if (attr->omp_declare_target_link)\n+\tMIO_NAME (ab_attribute) (AB_OMP_DECLARE_TARGET_LINK, attr_bits);\n \n       mio_rparen ();\n \n@@ -2419,6 +2423,9 @@ mio_symbol_attribute (symbol_attribute *attr)\n \t    case AB_OMP_DECLARE_TARGET:\n \t      attr->omp_declare_target = 1;\n \t      break;\n+\t    case AB_OMP_DECLARE_TARGET_LINK:\n+\t      attr->omp_declare_target_link = 1;\n+\t      break;\n \t    case AB_ARRAY_OUTER_DEPENDENCY:\n \t      attr->array_outer_dependency =1;\n \t      break;"}, {"sha": "11ffb5d884c582a1524e608e2a294d038ea13d56", "filename": "gcc/fortran/openmp.c", "status": "modified", "additions": 1264, "deletions": 316, "changes": 1580, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c3a85be96585374bf95c981ba2f602667cf5b7/gcc%2Ffortran%2Fopenmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c3a85be96585374bf95c981ba2f602667cf5b7/gcc%2Ffortran%2Fopenmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fopenmp.c?ref=b4c3a85be96585374bf95c981ba2f602667cf5b7", "patch": "@@ -76,6 +76,12 @@ gfc_free_omp_clauses (gfc_omp_clauses *c)\n   gfc_free_expr (c->device);\n   gfc_free_expr (c->thread_limit);\n   gfc_free_expr (c->dist_chunk_size);\n+  gfc_free_expr (c->grainsize);\n+  gfc_free_expr (c->hint);\n+  gfc_free_expr (c->num_tasks);\n+  gfc_free_expr (c->priority);\n+  for (i = 0; i < OMP_IF_LAST; i++)\n+    gfc_free_expr (c->if_exprs[i]);\n   gfc_free_expr (c->async_expr);\n   gfc_free_expr (c->gang_num_expr);\n   gfc_free_expr (c->gang_static_expr);\n@@ -88,6 +94,7 @@ gfc_free_omp_clauses (gfc_omp_clauses *c)\n     gfc_free_omp_namelist (c->lists[i]);\n   gfc_free_expr_list (c->wait_list);\n   gfc_free_expr_list (c->tile_list);\n+  free (CONST_CAST (char *, c->critical_name));\n   free (c);\n }\n \n@@ -333,6 +340,170 @@ gfc_match_omp_variable_list (const char *str, gfc_omp_namelist **list,\n   return MATCH_ERROR;\n }\n \n+/* Match a variable/procedure/common block list and construct a namelist\n+   from it.  */\n+\n+static match\n+gfc_match_omp_to_link (const char *str, gfc_omp_namelist **list)\n+{\n+  gfc_omp_namelist *head, *tail, *p;\n+  locus old_loc, cur_loc;\n+  char n[GFC_MAX_SYMBOL_LEN+1];\n+  gfc_symbol *sym;\n+  match m;\n+  gfc_symtree *st;\n+\n+  head = tail = NULL;\n+\n+  old_loc = gfc_current_locus;\n+\n+  m = gfc_match (str);\n+  if (m != MATCH_YES)\n+    return m;\n+\n+  for (;;)\n+    {\n+      cur_loc = gfc_current_locus;\n+      m = gfc_match_symbol (&sym, 1);\n+      switch (m)\n+\t{\n+\tcase MATCH_YES:\n+\t  p = gfc_get_omp_namelist ();\n+\t  if (head == NULL)\n+\t    head = tail = p;\n+\t  else\n+\t    {\n+\t      tail->next = p;\n+\t      tail = tail->next;\n+\t    }\n+\t  tail->sym = sym;\n+\t  tail->where = cur_loc;\n+\t  goto next_item;\n+\tcase MATCH_NO:\n+\t  break;\n+\tcase MATCH_ERROR:\n+\t  goto cleanup;\n+\t}\n+\n+      m = gfc_match (\" / %n /\", n);\n+      if (m == MATCH_ERROR)\n+\tgoto cleanup;\n+      if (m == MATCH_NO)\n+\tgoto syntax;\n+\n+      st = gfc_find_symtree (gfc_current_ns->common_root, n);\n+      if (st == NULL)\n+\t{\n+\t  gfc_error (\"COMMON block /%s/ not found at %C\", n);\n+\t  goto cleanup;\n+\t}\n+      p = gfc_get_omp_namelist ();\n+      if (head == NULL)\n+\thead = tail = p;\n+      else\n+\t{\n+\t  tail->next = p;\n+\t  tail = tail->next;\n+\t}\n+      tail->u.common = st->n.common;\n+      tail->where = cur_loc;\n+\n+    next_item:\n+      if (gfc_match_char (')') == MATCH_YES)\n+\tbreak;\n+      if (gfc_match_char (',') != MATCH_YES)\n+\tgoto syntax;\n+    }\n+\n+  while (*list)\n+    list = &(*list)->next;\n+\n+  *list = head;\n+  return MATCH_YES;\n+\n+syntax:\n+  gfc_error (\"Syntax error in OpenMP variable list at %C\");\n+\n+cleanup:\n+  gfc_free_omp_namelist (head);\n+  gfc_current_locus = old_loc;\n+  return MATCH_ERROR;\n+}\n+\n+/* Match depend(sink : ...) construct a namelist from it.  */\n+\n+static match\n+gfc_match_omp_depend_sink (gfc_omp_namelist **list)\n+{\n+  gfc_omp_namelist *head, *tail, *p;\n+  locus old_loc, cur_loc;\n+  gfc_symbol *sym;\n+\n+  head = tail = NULL;\n+\n+  old_loc = gfc_current_locus;\n+\n+  for (;;)\n+    {\n+      cur_loc = gfc_current_locus;\n+      switch (gfc_match_symbol (&sym, 1))\n+\t{\n+\tcase MATCH_YES:\n+\t  gfc_set_sym_referenced (sym);\n+\t  p = gfc_get_omp_namelist ();\n+\t  if (head == NULL)\n+\t    {\n+\t      head = tail = p;\n+\t      head->u.depend_op = OMP_DEPEND_SINK_FIRST;\n+\t    }\n+\t  else\n+\t    {\n+\t      tail->next = p;\n+\t      tail = tail->next;\n+\t      tail->u.depend_op = OMP_DEPEND_SINK;\n+\t    }\n+\t  tail->sym = sym;\n+\t  tail->expr = NULL;\n+\t  tail->where = cur_loc;\n+\t  if (gfc_match_char ('+') == MATCH_YES)\n+\t    {\n+\t      if (gfc_match_literal_constant (&tail->expr, 0) != MATCH_YES)\n+\t\tgoto syntax;\n+\t    }\n+\t  else if (gfc_match_char ('-') == MATCH_YES)\n+\t    {\n+\t      if (gfc_match_literal_constant (&tail->expr, 0) != MATCH_YES)\n+\t\tgoto syntax;\n+\t      tail->expr = gfc_uminus (tail->expr);\n+\t    }\n+\t  break;\n+\tcase MATCH_NO:\n+\t  goto syntax;\n+\tcase MATCH_ERROR:\n+\t  goto cleanup;\n+\t}\n+\n+      if (gfc_match_char (')') == MATCH_YES)\n+\tbreak;\n+      if (gfc_match_char (',') != MATCH_YES)\n+\tgoto syntax;\n+    }\n+\n+  while (*list)\n+    list = &(*list)->next;\n+\n+  *list = head;\n+  return MATCH_YES;\n+\n+syntax:\n+  gfc_error (\"Syntax error in OpenMP DEPEND SINK list at %C\");\n+\n+cleanup:\n+  gfc_free_omp_namelist (head);\n+  gfc_current_locus = old_loc;\n+  return MATCH_ERROR;\n+}\n+\n static match\n match_oacc_expr_list (const char *str, gfc_expr_list **list,\n \t\t      bool allow_asterisk)\n@@ -563,67 +734,183 @@ gfc_match_oacc_clause_link (const char *str, gfc_omp_namelist **list)\n   return MATCH_ERROR;\n }\n \n-#define OMP_CLAUSE_PRIVATE\t\t((uint64_t) 1 << 0)\n-#define OMP_CLAUSE_FIRSTPRIVATE\t\t((uint64_t) 1 << 1)\n-#define OMP_CLAUSE_LASTPRIVATE\t\t((uint64_t) 1 << 2)\n-#define OMP_CLAUSE_COPYPRIVATE\t\t((uint64_t) 1 << 3)\n-#define OMP_CLAUSE_SHARED\t\t((uint64_t) 1 << 4)\n-#define OMP_CLAUSE_COPYIN\t\t((uint64_t) 1 << 5)\n-#define OMP_CLAUSE_REDUCTION\t\t((uint64_t) 1 << 6)\n-#define OMP_CLAUSE_IF\t\t\t((uint64_t) 1 << 7)\n-#define OMP_CLAUSE_NUM_THREADS\t\t((uint64_t) 1 << 8)\n-#define OMP_CLAUSE_SCHEDULE\t\t((uint64_t) 1 << 9)\n-#define OMP_CLAUSE_DEFAULT\t\t((uint64_t) 1 << 10)\n-#define OMP_CLAUSE_ORDERED\t\t((uint64_t) 1 << 11)\n-#define OMP_CLAUSE_COLLAPSE\t\t((uint64_t) 1 << 12)\n-#define OMP_CLAUSE_UNTIED\t\t((uint64_t) 1 << 13)\n-#define OMP_CLAUSE_FINAL\t\t((uint64_t) 1 << 14)\n-#define OMP_CLAUSE_MERGEABLE\t\t((uint64_t) 1 << 15)\n-#define OMP_CLAUSE_ALIGNED\t\t((uint64_t) 1 << 16)\n-#define OMP_CLAUSE_DEPEND\t\t((uint64_t) 1 << 17)\n-#define OMP_CLAUSE_INBRANCH\t\t((uint64_t) 1 << 18)\n-#define OMP_CLAUSE_LINEAR\t\t((uint64_t) 1 << 19)\n-#define OMP_CLAUSE_NOTINBRANCH\t\t((uint64_t) 1 << 20)\n-#define OMP_CLAUSE_PROC_BIND\t\t((uint64_t) 1 << 21)\n-#define OMP_CLAUSE_SAFELEN\t\t((uint64_t) 1 << 22)\n-#define OMP_CLAUSE_SIMDLEN\t\t((uint64_t) 1 << 23)\n-#define OMP_CLAUSE_UNIFORM\t\t((uint64_t) 1 << 24)\n-#define OMP_CLAUSE_DEVICE\t\t((uint64_t) 1 << 25)\n-#define OMP_CLAUSE_MAP\t\t\t((uint64_t) 1 << 26)\n-#define OMP_CLAUSE_TO\t\t\t((uint64_t) 1 << 27)\n-#define OMP_CLAUSE_FROM\t\t\t((uint64_t) 1 << 28)\n-#define OMP_CLAUSE_NUM_TEAMS\t\t((uint64_t) 1 << 29)\n-#define OMP_CLAUSE_THREAD_LIMIT\t\t((uint64_t) 1 << 30)\n-#define OMP_CLAUSE_DIST_SCHEDULE\t((uint64_t) 1 << 31)\n-\n-/* OpenACC 2.0 clauses. */\n-#define OMP_CLAUSE_ASYNC\t\t((uint64_t) 1 << 32)\n-#define OMP_CLAUSE_NUM_GANGS\t\t((uint64_t) 1 << 33)\n-#define OMP_CLAUSE_NUM_WORKERS\t\t((uint64_t) 1 << 34)\n-#define OMP_CLAUSE_VECTOR_LENGTH\t((uint64_t) 1 << 35)\n-#define OMP_CLAUSE_COPY\t\t\t((uint64_t) 1 << 36)\n-#define OMP_CLAUSE_COPYOUT\t\t((uint64_t) 1 << 37)\n-#define OMP_CLAUSE_CREATE\t\t((uint64_t) 1 << 38)\n-#define OMP_CLAUSE_PRESENT\t\t((uint64_t) 1 << 39)\n-#define OMP_CLAUSE_PRESENT_OR_COPY\t((uint64_t) 1 << 40)\n-#define OMP_CLAUSE_PRESENT_OR_COPYIN\t((uint64_t) 1 << 41)\n-#define OMP_CLAUSE_PRESENT_OR_COPYOUT\t((uint64_t) 1 << 42)\n-#define OMP_CLAUSE_PRESENT_OR_CREATE\t((uint64_t) 1 << 43)\n-#define OMP_CLAUSE_DEVICEPTR\t\t((uint64_t) 1 << 44)\n-#define OMP_CLAUSE_GANG\t\t\t((uint64_t) 1 << 45)\n-#define OMP_CLAUSE_WORKER\t\t((uint64_t) 1 << 46)\n-#define OMP_CLAUSE_VECTOR\t\t((uint64_t) 1 << 47)\n-#define OMP_CLAUSE_SEQ\t\t\t((uint64_t) 1 << 48)\n-#define OMP_CLAUSE_INDEPENDENT\t\t((uint64_t) 1 << 49)\n-#define OMP_CLAUSE_USE_DEVICE\t\t((uint64_t) 1 << 50)\n-#define OMP_CLAUSE_DEVICE_RESIDENT\t((uint64_t) 1 << 51)\n-#define OMP_CLAUSE_HOST_SELF\t\t((uint64_t) 1 << 52)\n-#define OMP_CLAUSE_OACC_DEVICE\t\t((uint64_t) 1 << 53)\n-#define OMP_CLAUSE_WAIT\t\t\t((uint64_t) 1 << 54)\n-#define OMP_CLAUSE_DELETE\t\t((uint64_t) 1 << 55)\n-#define OMP_CLAUSE_AUTO\t\t\t((uint64_t) 1 << 56)\n-#define OMP_CLAUSE_TILE\t\t\t((uint64_t) 1 << 57)\n-#define OMP_CLAUSE_LINK\t\t\t((uint64_t) 1 << 58)\n+/* OpenMP 4.5 clauses.  */\n+enum omp_mask1\n+{\n+  OMP_CLAUSE_PRIVATE,\n+  OMP_CLAUSE_FIRSTPRIVATE,\n+  OMP_CLAUSE_LASTPRIVATE,\n+  OMP_CLAUSE_COPYPRIVATE,\n+  OMP_CLAUSE_SHARED,\n+  OMP_CLAUSE_COPYIN,\n+  OMP_CLAUSE_REDUCTION,\n+  OMP_CLAUSE_IF,\n+  OMP_CLAUSE_NUM_THREADS,\n+  OMP_CLAUSE_SCHEDULE,\n+  OMP_CLAUSE_DEFAULT,\n+  OMP_CLAUSE_ORDERED,\n+  OMP_CLAUSE_COLLAPSE,\n+  OMP_CLAUSE_UNTIED,\n+  OMP_CLAUSE_FINAL,\n+  OMP_CLAUSE_MERGEABLE,\n+  OMP_CLAUSE_ALIGNED,\n+  OMP_CLAUSE_DEPEND,\n+  OMP_CLAUSE_INBRANCH,\n+  OMP_CLAUSE_LINEAR,\n+  OMP_CLAUSE_NOTINBRANCH,\n+  OMP_CLAUSE_PROC_BIND,\n+  OMP_CLAUSE_SAFELEN,\n+  OMP_CLAUSE_SIMDLEN,\n+  OMP_CLAUSE_UNIFORM,\n+  OMP_CLAUSE_DEVICE,\n+  OMP_CLAUSE_MAP,\n+  OMP_CLAUSE_TO,\n+  OMP_CLAUSE_FROM,\n+  OMP_CLAUSE_NUM_TEAMS,\n+  OMP_CLAUSE_THREAD_LIMIT,\n+  OMP_CLAUSE_DIST_SCHEDULE,\n+  OMP_CLAUSE_DEFAULTMAP,\n+  OMP_CLAUSE_GRAINSIZE,\n+  OMP_CLAUSE_HINT,\n+  OMP_CLAUSE_IS_DEVICE_PTR,\n+  OMP_CLAUSE_LINK,\n+  OMP_CLAUSE_NOGROUP,\n+  OMP_CLAUSE_NUM_TASKS,\n+  OMP_CLAUSE_PRIORITY,\n+  OMP_CLAUSE_SIMD,\n+  OMP_CLAUSE_THREADS,\n+  OMP_CLAUSE_USE_DEVICE_PTR,\n+  OMP_CLAUSE_NOWAIT,\n+  /* This must come last.  */\n+  OMP_MASK1_LAST\n+};\n+\n+/* OpenACC 2.0 specific clauses. */\n+enum omp_mask2\n+{\n+  OMP_CLAUSE_ASYNC,\n+  OMP_CLAUSE_NUM_GANGS,\n+  OMP_CLAUSE_NUM_WORKERS,\n+  OMP_CLAUSE_VECTOR_LENGTH,\n+  OMP_CLAUSE_COPY,\n+  OMP_CLAUSE_COPYOUT,\n+  OMP_CLAUSE_CREATE,\n+  OMP_CLAUSE_PRESENT,\n+  OMP_CLAUSE_PRESENT_OR_COPY,\n+  OMP_CLAUSE_PRESENT_OR_COPYIN,\n+  OMP_CLAUSE_PRESENT_OR_COPYOUT,\n+  OMP_CLAUSE_PRESENT_OR_CREATE,\n+  OMP_CLAUSE_DEVICEPTR,\n+  OMP_CLAUSE_GANG,\n+  OMP_CLAUSE_WORKER,\n+  OMP_CLAUSE_VECTOR,\n+  OMP_CLAUSE_SEQ,\n+  OMP_CLAUSE_INDEPENDENT,\n+  OMP_CLAUSE_USE_DEVICE,\n+  OMP_CLAUSE_DEVICE_RESIDENT,\n+  OMP_CLAUSE_HOST_SELF,\n+  OMP_CLAUSE_WAIT,\n+  OMP_CLAUSE_DELETE,\n+  OMP_CLAUSE_AUTO,\n+  OMP_CLAUSE_TILE,\n+  /* This must come last.  */\n+  OMP_MASK2_LAST\n+};\n+\n+struct omp_inv_mask;\n+\n+/* Customized bitset for up to 128-bits.\n+   The two enums above provide bit numbers to use, and which of the\n+   two enums it is determines which of the two mask fields is used.\n+   Supported operations are defining a mask, like:\n+   #define XXX_CLAUSES \\\n+     (omp_mask (OMP_CLAUSE_XXX) | OMP_CLAUSE_YYY | OMP_CLAUSE_ZZZ)\n+   oring such bitsets together or removing selected bits:\n+   (XXX_CLAUSES | YYY_CLAUSES) & ~(omp_mask (OMP_CLAUSE_VVV))\n+   and testing individual bits:\n+   if (mask & OMP_CLAUSE_UUU)  */\n+\n+struct omp_mask {\n+  const uint64_t mask1;\n+  const uint64_t mask2;\n+  inline omp_mask ();\n+  inline omp_mask (omp_mask1);\n+  inline omp_mask (omp_mask2);\n+  inline omp_mask (uint64_t, uint64_t);\n+  inline omp_mask operator| (omp_mask1) const;\n+  inline omp_mask operator| (omp_mask2) const;\n+  inline omp_mask operator| (omp_mask) const;\n+  inline omp_mask operator& (const omp_inv_mask &) const;\n+  inline bool operator& (omp_mask1) const;\n+  inline bool operator& (omp_mask2) const;\n+  inline omp_inv_mask operator~ () const;\n+};\n+\n+struct omp_inv_mask : public omp_mask {\n+  inline omp_inv_mask (const omp_mask &);\n+};\n+\n+omp_mask::omp_mask () : mask1 (0), mask2 (0)\n+{\n+}\n+\n+omp_mask::omp_mask (omp_mask1 m) : mask1 (((uint64_t) 1) << m), mask2 (0)\n+{\n+}\n+\n+omp_mask::omp_mask (omp_mask2 m) : mask1 (0), mask2 (((uint64_t) 1) << m)\n+{\n+}\n+\n+omp_mask::omp_mask (uint64_t m1, uint64_t m2) : mask1 (m1), mask2 (m2)\n+{\n+}\n+\n+omp_mask\n+omp_mask::operator| (omp_mask1 m) const\n+{\n+  return omp_mask (mask1 | (((uint64_t) 1) << m), mask2);\n+}\n+\n+omp_mask\n+omp_mask::operator| (omp_mask2 m) const\n+{\n+  return omp_mask (mask1, mask2 | (((uint64_t) 1) << m));\n+}\n+\n+omp_mask\n+omp_mask::operator| (omp_mask m) const\n+{\n+  return omp_mask (mask1 | m.mask1, mask2 | m.mask2);\n+}\n+\n+omp_mask\n+omp_mask::operator& (const omp_inv_mask &m) const\n+{\n+  return omp_mask (mask1 & ~m.mask1, mask2 & ~m.mask2);\n+}\n+\n+bool\n+omp_mask::operator& (omp_mask1 m) const\n+{\n+  return (mask1 & (((uint64_t) 1) << m)) != 0;\n+}\n+\n+bool\n+omp_mask::operator& (omp_mask2 m) const\n+{\n+  return (mask2 & (((uint64_t) 1) << m)) != 0;\n+}\n+\n+omp_inv_mask\n+omp_mask::operator~ () const\n+{\n+  return omp_inv_mask (*this);\n+}\n+\n+omp_inv_mask::omp_inv_mask (const omp_mask &m) : omp_mask (m)\n+{\n+}\n \n /* Helper function for OpenACC and OpenMP clauses involving memory\n    mapping.  */\n@@ -648,13 +935,14 @@ gfc_match_omp_map_clause (gfc_omp_namelist **list, gfc_omp_map_op map_op)\n    clauses that are allowed for a particular directive.  */\n \n static match\n-gfc_match_omp_clauses (gfc_omp_clauses **cp, uint64_t mask,\n+gfc_match_omp_clauses (gfc_omp_clauses **cp, const omp_mask mask,\n \t\t       bool first = true, bool needs_space = true,\n \t\t       bool openacc = false)\n {\n   gfc_omp_clauses *c = gfc_get_omp_clauses ();\n   locus old_loc;\n \n+  gcc_checking_assert (OMP_MASK1_LAST <= 64 && OMP_MASK2_LAST <= 64);\n   *cp = NULL;\n   while (1)\n     {\n@@ -790,11 +1078,6 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, uint64_t mask,\n \t    continue;\n \t  break;\n \tcase 'd':\n-\t  if ((mask & OMP_CLAUSE_DELETE)\n-\t      && gfc_match (\"delete ( \") == MATCH_YES\n-\t      && gfc_match_omp_map_clause (&c->lists[OMP_LIST_MAP],\n-\t\t\t\t\t   OMP_MAP_DELETE))\n-\t    continue;\n \t  if ((mask & OMP_CLAUSE_DEFAULT)\n \t      && c->default_sharing == OMP_DEFAULT_UNKNOWN)\n \t    {\n@@ -811,6 +1094,18 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, uint64_t mask,\n \t      if (c->default_sharing != OMP_DEFAULT_UNKNOWN)\n \t\tcontinue;\n \t    }\n+\t  if ((mask & OMP_CLAUSE_DEFAULTMAP)\n+\t      && !c->defaultmap\n+\t      && gfc_match (\"defaultmap ( tofrom : scalar )\") == MATCH_YES)\n+\t    {\n+\t      c->defaultmap = true;\n+\t      continue;\n+\t    }\n+\t  if ((mask & OMP_CLAUSE_DELETE)\n+\t      && gfc_match (\"delete ( \") == MATCH_YES\n+\t      && gfc_match_omp_map_clause (&c->lists[OMP_LIST_MAP],\n+\t\t\t\t\t   OMP_MAP_DELETE))\n+\t    continue;\n \t  if ((mask & OMP_CLAUSE_DEPEND)\n \t      && gfc_match (\"depend ( \") == MATCH_YES)\n \t    {\n@@ -822,6 +1117,19 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, uint64_t mask,\n \t\tdepend_op = OMP_DEPEND_IN;\n \t      else if (gfc_match (\"out\") == MATCH_YES)\n \t\tdepend_op = OMP_DEPEND_OUT;\n+\t      else if (!c->depend_source\n+\t\t       && gfc_match (\"source )\") == MATCH_YES)\n+\t\t{\n+\t\t  c->depend_source = true;\n+\t\t  continue;\n+\t\t}\n+\t      else if (gfc_match (\"sink : \") == MATCH_YES)\n+\t\t{\n+\t\t  if (gfc_match_omp_depend_sink (&c->lists[OMP_LIST_DEPEND])\n+\t\t      == MATCH_YES)\n+\t\t    continue;\n+\t\t  m = MATCH_NO;\n+\t\t}\n \t      else\n \t\tm = MATCH_NO;\n \t      head = NULL;\n@@ -840,10 +1148,12 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, uint64_t mask,\n \t\tgfc_current_locus = old_loc;\n \t    }\n \t  if ((mask & OMP_CLAUSE_DEVICE)\n+\t      && !openacc\n \t      && c->device == NULL\n \t      && gfc_match (\"device ( %e )\", &c->device) == MATCH_YES)\n \t    continue;\n-\t  if ((mask & OMP_CLAUSE_OACC_DEVICE)\n+\t  if ((mask & OMP_CLAUSE_DEVICE)\n+\t      && openacc\n \t      && gfc_match (\"device ( \") == MATCH_YES\n \t      && gfc_match_omp_map_clause (&c->lists[OMP_LIST_MAP],\n \t\t\t\t\t   OMP_MAP_FORCE_TO))\n@@ -917,8 +1227,16 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, uint64_t mask,\n \t\tneeds_space = true;\n \t      continue;\n \t    }\n+\t  if ((mask & OMP_CLAUSE_GRAINSIZE)\n+\t      && c->grainsize == NULL\n+\t      && gfc_match (\"grainsize ( %e )\", &c->grainsize) == MATCH_YES)\n+\t    continue;\n \t  break;\n \tcase 'h':\n+\t  if ((mask & OMP_CLAUSE_HINT)\n+\t      && c->hint == NULL\n+\t      && gfc_match (\"hint ( %e )\", &c->hint) == MATCH_YES)\n+\t    continue;\n \t  if ((mask & OMP_CLAUSE_HOST_SELF)\n \t      && gfc_match (\"host ( \") == MATCH_YES\n \t      && gfc_match_omp_map_clause (&c->lists[OMP_LIST_MAP],\n@@ -928,8 +1246,32 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, uint64_t mask,\n \tcase 'i':\n \t  if ((mask & OMP_CLAUSE_IF)\n \t      && c->if_expr == NULL\n-\t      && gfc_match (\"if ( %e )\", &c->if_expr) == MATCH_YES)\n-\t    continue;\n+\t      && gfc_match (\"if ( \") == MATCH_YES)\n+\t    {\n+\t      if (gfc_match (\"%e )\", &c->if_expr) == MATCH_YES)\n+\t\tcontinue;\n+\t      if (!openacc)\n+\t\t{\n+\t\t  /* This should match the enum gfc_omp_if_kind order.  */\n+\t\t  static const char *ifs[OMP_IF_LAST] = {\n+\t\t    \" parallel : %e )\",\n+\t\t    \" task : %e )\",\n+\t\t    \" taskloop : %e )\",\n+\t\t    \" target : %e )\",\n+\t\t    \" target data : %e )\",\n+\t\t    \" target update : %e )\",\n+\t\t    \" target enter data : %e )\",\n+\t\t    \" target exit data : %e )\" };\n+\t\t  int i;\n+\t\t  for (i = 0; i < OMP_IF_LAST; i++)\n+\t\t    if (c->if_exprs[i] == NULL\n+\t\t\t&& gfc_match (ifs[i], &c->if_exprs[i]) == MATCH_YES)\n+\t\t      break;\n+\t\t  if (i < OMP_IF_LAST)\n+\t\t    continue;\n+\t\t}\n+\t      gfc_current_locus = old_loc;\n+\t    }\n \t  if ((mask & OMP_CLAUSE_INBRANCH)\n \t      && !c->inbranch\n \t      && !c->notinbranch\n@@ -946,6 +1288,11 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, uint64_t mask,\n \t      needs_space = true;\n \t      continue;\n \t    }\n+\t  if ((mask & OMP_CLAUSE_IS_DEVICE_PTR)\n+\t      && gfc_match_omp_variable_list\n+\t\t   (\"is_device_ptr (\",\n+\t\t    &c->lists[OMP_LIST_IS_DEVICE_PTR], false) == MATCH_YES)\n+\t    continue;\n \t  break;\n \tcase 'l':\n \t  if ((mask & OMP_CLAUSE_LASTPRIVATE)\n@@ -956,13 +1303,50 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, uint64_t mask,\n \t  end_colon = false;\n \t  head = NULL;\n \t  if ((mask & OMP_CLAUSE_LINEAR)\n-\t      && gfc_match_omp_variable_list (\"linear (\",\n-\t\t\t\t\t      &c->lists[OMP_LIST_LINEAR],\n-\t\t\t\t\t      false, &end_colon,\n-\t\t\t\t\t      &head) == MATCH_YES)\n+\t      && gfc_match (\"linear (\") == MATCH_YES)\n \t    {\n+\t      gfc_omp_linear_op linear_op = OMP_LINEAR_DEFAULT;\n \t      gfc_expr *step = NULL;\n \n+\t      if (gfc_match_omp_variable_list (\" ref (\",\n+\t\t\t\t\t       &c->lists[OMP_LIST_LINEAR],\n+\t\t\t\t\t       false, NULL, &head)\n+\t\t  == MATCH_YES)\n+\t\tlinear_op = OMP_LINEAR_REF;\n+\t      else if (gfc_match_omp_variable_list (\" val (\",\n+\t\t\t\t\t\t    &c->lists[OMP_LIST_LINEAR],\n+\t\t\t\t\t\t    false, NULL, &head)\n+\t\t  == MATCH_YES)\n+\t\tlinear_op = OMP_LINEAR_VAL;\n+\t      else if (gfc_match_omp_variable_list (\" uval (\",\n+\t\t\t\t\t\t    &c->lists[OMP_LIST_LINEAR],\n+\t\t\t\t\t\t    false, NULL, &head)\n+\t\t  == MATCH_YES)\n+\t\tlinear_op = OMP_LINEAR_UVAL;\n+\t      else if (gfc_match_omp_variable_list (\"\",\n+\t\t\t\t\t\t    &c->lists[OMP_LIST_LINEAR],\n+\t\t\t\t\t\t    false, &end_colon, &head)\n+\t\t  == MATCH_YES)\n+\t\tlinear_op = OMP_LINEAR_DEFAULT;\n+\t      else\n+\t\t{\n+\t\t  gfc_free_omp_namelist (*head);\n+\t\t  gfc_current_locus = old_loc;\n+\t\t  *head = NULL;\n+\t\t  break;\n+\t\t}\n+\t      if (linear_op != OMP_LINEAR_DEFAULT)\n+\t\t{\n+\t\t  if (gfc_match (\" :\") == MATCH_YES)\n+\t\t    end_colon = true;\n+\t\t  else if (gfc_match (\" )\") != MATCH_YES)\n+\t\t    {\n+\t\t      gfc_free_omp_namelist (*head);\n+\t\t      gfc_current_locus = old_loc;\n+\t\t      *head = NULL;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n \t      if (end_colon && gfc_match (\" %e )\", &step) != MATCH_YES)\n \t\t{\n \t\t  gfc_free_omp_namelist (*head);\n@@ -978,27 +1362,50 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, uint64_t mask,\n \t\t  mpz_set_si (step->value.integer, 1);\n \t\t}\n \t      (*head)->expr = step;\n+\t      if (linear_op != OMP_LINEAR_DEFAULT)\n+\t\tfor (gfc_omp_namelist *n = *head; n; n = n->next)\n+\t\t  n->u.linear_op = linear_op;\n \t      continue;\n \t    }\n \t  if ((mask & OMP_CLAUSE_LINK)\n+\t      && openacc\n \t      && (gfc_match_oacc_clause_link (\"link (\",\n \t\t\t\t\t      &c->lists[OMP_LIST_LINK])\n \t\t  == MATCH_YES))\n \t    continue;\n+\t  else if ((mask & OMP_CLAUSE_LINK)\n+\t\t   && !openacc\n+\t\t   && (gfc_match_omp_to_link (\"link (\",\n+\t\t\t\t\t      &c->lists[OMP_LIST_LINK])\n+\t\t       == MATCH_YES))\n+\t    continue;\n \t  break;\n \tcase 'm':\n \t  if ((mask & OMP_CLAUSE_MAP)\n \t      && gfc_match (\"map ( \") == MATCH_YES)\n \t    {\n+\t      locus old_loc2 = gfc_current_locus;\n+\t      bool always = false;\n \t      gfc_omp_map_op map_op = OMP_MAP_TOFROM;\n+\t      if (gfc_match (\"always , \") == MATCH_YES)\n+\t\talways = true;\n \t      if (gfc_match (\"alloc : \") == MATCH_YES)\n \t\tmap_op = OMP_MAP_ALLOC;\n \t      else if (gfc_match (\"tofrom : \") == MATCH_YES)\n-\t\tmap_op = OMP_MAP_TOFROM;\n+\t\tmap_op = always ? OMP_MAP_ALWAYS_TOFROM : OMP_MAP_TOFROM;\n \t      else if (gfc_match (\"to : \") == MATCH_YES)\n-\t\tmap_op = OMP_MAP_TO;\n+\t\tmap_op = always ? OMP_MAP_ALWAYS_TO : OMP_MAP_TO;\n \t      else if (gfc_match (\"from : \") == MATCH_YES)\n-\t\tmap_op = OMP_MAP_FROM;\n+\t\tmap_op = always ? OMP_MAP_ALWAYS_FROM : OMP_MAP_FROM;\n+\t      else if (gfc_match (\"release : \") == MATCH_YES)\n+\t\tmap_op = OMP_MAP_RELEASE;\n+\t      else if (gfc_match (\"delete : \") == MATCH_YES)\n+\t\tmap_op = OMP_MAP_DELETE;\n+\t      else if (always)\n+\t\t{\n+\t\t  gfc_current_locus = old_loc2;\n+\t\t  always = false;\n+\t\t}\n \t      head = NULL;\n \t      if (gfc_match_omp_variable_list (\"\", &c->lists[OMP_LIST_MAP],\n \t\t\t\t\t       false, NULL, &head,\n@@ -1020,6 +1427,13 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, uint64_t mask,\n \t    }\n \t  break;\n \tcase 'n':\n+\t  if ((mask & OMP_CLAUSE_NOGROUP)\n+\t      && !c->nogroup\n+\t      && gfc_match (\"nogroup\") == MATCH_YES)\n+\t    {\n+\t      c->nogroup = needs_space = true;\n+\t      continue;\n+\t    }\n \t  if ((mask & OMP_CLAUSE_NOTINBRANCH)\n \t      && !c->notinbranch\n \t      && !c->inbranch\n@@ -1028,11 +1442,22 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, uint64_t mask,\n \t      c->notinbranch = needs_space = true;\n \t      continue;\n \t    }\n+\t  if ((mask & OMP_CLAUSE_NOWAIT)\n+\t      && !c->nowait\n+\t      && gfc_match (\"nowait\") == MATCH_YES)\n+\t    {\n+\t      c->nowait = needs_space = true;\n+\t      continue;\n+\t    }\n \t  if ((mask & OMP_CLAUSE_NUM_GANGS)\n \t      && c->num_gangs_expr == NULL\n \t      && gfc_match (\"num_gangs ( %e )\",\n \t\t\t    &c->num_gangs_expr) == MATCH_YES)\n \t    continue;\n+\t  if ((mask & OMP_CLAUSE_NUM_TASKS)\n+\t      && c->num_tasks == NULL\n+\t      && gfc_match (\"num_tasks ( %e )\", &c->num_tasks) == MATCH_YES)\n+\t    continue;\n \t  if ((mask & OMP_CLAUSE_NUM_TEAMS)\n \t      && c->num_teams == NULL\n \t      && gfc_match (\"num_teams ( %e )\", &c->num_teams) == MATCH_YES)\n@@ -1053,7 +1478,31 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, uint64_t mask,\n \t      && !c->ordered\n \t      && gfc_match (\"ordered\") == MATCH_YES)\n \t    {\n-\t      c->ordered = needs_space = true;\n+\t      gfc_expr *cexpr = NULL;\n+\t      match m = gfc_match (\" ( %e )\", &cexpr);\n+\n+\t      c->ordered = true;\n+\t      if (m == MATCH_YES)\n+\t\t{\n+\t\t  int ordered = 0;\n+\t\t  const char *p = gfc_extract_int (cexpr, &ordered);\n+\t\t  if (p)\n+\t\t    {\n+\t\t      gfc_error_now (p);\n+\t\t      ordered = 0;\n+\t\t    }\n+\t\t  else if (ordered <= 0)\n+\t\t    {\n+\t\t      gfc_error_now (\"ORDERED clause argument not\"\n+\t\t\t\t     \" constant positive integer at %C\");\n+\t\t      ordered = 0;\n+\t\t    }\n+\t\t  c->orderedc = ordered;\n+\t\t  gfc_free_expr (cexpr);\n+\t\t  continue;\n+\t\t}\n+\n+\t      needs_space = true;\n \t      continue;\n \t    }\n \t  break;\n@@ -1103,6 +1552,10 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, uint64_t mask,\n \t      && gfc_match_omp_map_clause (&c->lists[OMP_LIST_MAP],\n \t\t\t\t\t   OMP_MAP_ALLOC))\n \t    continue;\n+\t  if ((mask & OMP_CLAUSE_PRIORITY)\n+\t      && c->priority == NULL\n+\t      && gfc_match (\"priority ( %e )\", &c->priority) == MATCH_YES)\n+\t    continue;\n \t  if ((mask & OMP_CLAUSE_PRIVATE)\n \t      && gfc_match_omp_variable_list (\"private (\",\n \t\t\t\t\t      &c->lists[OMP_LIST_PRIVATE],\n@@ -1252,6 +1705,45 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, uint64_t mask,\n \t      && c->sched_kind == OMP_SCHED_NONE\n \t      && gfc_match (\"schedule ( \") == MATCH_YES)\n \t    {\n+\t      int nmodifiers = 0;\n+\t      locus old_loc2 = gfc_current_locus;\n+\t      do\n+\t\t{\n+\t\t  if (!c->sched_simd\n+\t\t      && gfc_match (\"simd\") == MATCH_YES)\n+\t\t    {\n+\t\t      c->sched_simd = true;\n+\t\t      nmodifiers++;\n+\t\t    }\n+\t\t  else if (!c->sched_monotonic\n+\t\t\t   && !c->sched_nonmonotonic\n+\t\t\t   && gfc_match (\"monotonic\") == MATCH_YES)\n+\t\t    {\n+\t\t      c->sched_monotonic = true;\n+\t\t      nmodifiers++;\n+\t\t    }\n+\t\t  else if (!c->sched_monotonic\n+\t\t\t   && !c->sched_nonmonotonic\n+\t\t\t   && gfc_match (\"nonmonotonic\") == MATCH_YES)\n+\t\t    {\n+\t\t      c->sched_nonmonotonic = true;\n+\t\t      nmodifiers++;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      if (nmodifiers)\n+\t\t\tgfc_current_locus = old_loc2;\n+\t\t      break;\n+\t\t    }\n+\t\t  if (nmodifiers == 0\n+\t\t      && gfc_match (\" , \") == MATCH_YES)\n+\t\t    continue;\n+\t\t  else if (gfc_match (\" : \") == MATCH_YES)\n+\t\t    break;\n+\t\t  gfc_current_locus = old_loc2;\n+\t\t  break;\n+\t\t}\n+\t      while (1);\n \t      if (gfc_match (\"static\") == MATCH_YES)\n \t\tc->sched_kind = OMP_SCHED_STATIC;\n \t      else if (gfc_match (\"dynamic\") == MATCH_YES)\n@@ -1300,19 +1792,39 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, uint64_t mask,\n \t      && c->simdlen_expr == NULL\n \t      && gfc_match (\"simdlen ( %e )\", &c->simdlen_expr) == MATCH_YES)\n \t    continue;\n+\t  if ((mask & OMP_CLAUSE_SIMD)\n+\t      && !c->simd\n+\t      && gfc_match (\"simd\") == MATCH_YES)\n+\t    {\n+\t      c->simd = needs_space = true;\n+\t      continue;\n+\t    }\n \t  break;\n \tcase 't':\n \t  if ((mask & OMP_CLAUSE_THREAD_LIMIT)\n \t      && c->thread_limit == NULL\n \t      && gfc_match (\"thread_limit ( %e )\",\n \t\t\t    &c->thread_limit) == MATCH_YES)\n \t    continue;\n+\t  if ((mask & OMP_CLAUSE_THREADS)\n+\t      && !c->threads\n+\t      && gfc_match (\"threads\") == MATCH_YES)\n+\t    {\n+\t      c->threads = needs_space = true;\n+\t      continue;\n+\t    }\n \t  if ((mask & OMP_CLAUSE_TILE)\n \t      && !c->tile_list\n \t      && match_oacc_expr_list (\"tile (\", &c->tile_list,\n \t\t\t\t       true) == MATCH_YES)\n \t    continue;\n-\t  if ((mask & OMP_CLAUSE_TO)\n+\t  if ((mask & OMP_CLAUSE_TO) && (mask & OMP_CLAUSE_LINK))\n+\t    {\n+\t      if (gfc_match_omp_to_link (\"to (\", &c->lists[OMP_LIST_TO])\n+\t\t  == MATCH_YES)\n+\t\tcontinue;\n+\t    }\n+\t  else if ((mask & OMP_CLAUSE_TO)\n \t      && gfc_match_omp_variable_list (\"to (\",\n \t\t\t\t\t      &c->lists[OMP_LIST_TO], false,\n \t\t\t\t\t      NULL, &head, true) == MATCH_YES)\n@@ -1336,6 +1848,11 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, uint64_t mask,\n \t\t\t\t\t      &c->lists[OMP_LIST_USE_DEVICE],\n \t\t\t\t\t      true) == MATCH_YES)\n \t    continue;\n+\t  if ((mask & OMP_CLAUSE_USE_DEVICE_PTR)\n+\t      && gfc_match_omp_variable_list\n+\t\t   (\"use_device_ptr (\",\n+\t\t    &c->lists[OMP_LIST_USE_DEVICE_PTR], false) == MATCH_YES)\n+\t    continue;\n \t  break;\n \tcase 'v':\n \t  /* VECTOR_LENGTH must be matched before VECTOR, because the latter\n@@ -1409,59 +1926,60 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, uint64_t mask,\n \n \n #define OACC_PARALLEL_CLAUSES \\\n-  (OMP_CLAUSE_IF | OMP_CLAUSE_ASYNC | OMP_CLAUSE_NUM_GANGS                    \\\n+  (omp_mask (OMP_CLAUSE_IF) | OMP_CLAUSE_ASYNC | OMP_CLAUSE_NUM_GANGS\t      \\\n    | OMP_CLAUSE_NUM_WORKERS | OMP_CLAUSE_VECTOR_LENGTH | OMP_CLAUSE_REDUCTION \\\n-   | OMP_CLAUSE_COPY | OMP_CLAUSE_COPYIN | OMP_CLAUSE_COPYOUT                 \\\n+   | OMP_CLAUSE_COPY | OMP_CLAUSE_COPYIN | OMP_CLAUSE_COPYOUT\t\t      \\\n    | OMP_CLAUSE_CREATE | OMP_CLAUSE_PRESENT | OMP_CLAUSE_PRESENT_OR_COPY      \\\n-   | OMP_CLAUSE_PRESENT_OR_COPYIN | OMP_CLAUSE_PRESENT_OR_COPYOUT             \\\n+   | OMP_CLAUSE_PRESENT_OR_COPYIN | OMP_CLAUSE_PRESENT_OR_COPYOUT\t      \\\n    | OMP_CLAUSE_PRESENT_OR_CREATE | OMP_CLAUSE_DEVICEPTR | OMP_CLAUSE_PRIVATE \\\n    | OMP_CLAUSE_FIRSTPRIVATE | OMP_CLAUSE_DEFAULT | OMP_CLAUSE_WAIT)\n #define OACC_KERNELS_CLAUSES \\\n-  (OMP_CLAUSE_IF | OMP_CLAUSE_ASYNC | OMP_CLAUSE_DEVICEPTR                    \\\n-   | OMP_CLAUSE_COPY | OMP_CLAUSE_COPYIN | OMP_CLAUSE_COPYOUT                 \\\n+  (omp_mask (OMP_CLAUSE_IF) | OMP_CLAUSE_ASYNC | OMP_CLAUSE_DEVICEPTR\t      \\\n+   | OMP_CLAUSE_COPY | OMP_CLAUSE_COPYIN | OMP_CLAUSE_COPYOUT\t\t      \\\n    | OMP_CLAUSE_CREATE | OMP_CLAUSE_PRESENT | OMP_CLAUSE_PRESENT_OR_COPY      \\\n-   | OMP_CLAUSE_PRESENT_OR_COPYIN | OMP_CLAUSE_PRESENT_OR_COPYOUT             \\\n+   | OMP_CLAUSE_PRESENT_OR_COPYIN | OMP_CLAUSE_PRESENT_OR_COPYOUT\t      \\\n    | OMP_CLAUSE_PRESENT_OR_CREATE | OMP_CLAUSE_DEFAULT | OMP_CLAUSE_WAIT)\n #define OACC_DATA_CLAUSES \\\n-  (OMP_CLAUSE_IF | OMP_CLAUSE_DEVICEPTR  | OMP_CLAUSE_COPY                    \\\n-   | OMP_CLAUSE_COPYIN | OMP_CLAUSE_COPYOUT | OMP_CLAUSE_CREATE               \\\n-   | OMP_CLAUSE_PRESENT | OMP_CLAUSE_PRESENT_OR_COPY                          \\\n-   | OMP_CLAUSE_PRESENT_OR_COPYIN | OMP_CLAUSE_PRESENT_OR_COPYOUT             \\\n+  (omp_mask (OMP_CLAUSE_IF) | OMP_CLAUSE_DEVICEPTR  | OMP_CLAUSE_COPY\t      \\\n+   | OMP_CLAUSE_COPYIN | OMP_CLAUSE_COPYOUT | OMP_CLAUSE_CREATE\t\t      \\\n+   | OMP_CLAUSE_PRESENT | OMP_CLAUSE_PRESENT_OR_COPY\t\t\t      \\\n+   | OMP_CLAUSE_PRESENT_OR_COPYIN | OMP_CLAUSE_PRESENT_OR_COPYOUT\t      \\\n    | OMP_CLAUSE_PRESENT_OR_CREATE)\n #define OACC_LOOP_CLAUSES \\\n-  (OMP_CLAUSE_COLLAPSE | OMP_CLAUSE_GANG | OMP_CLAUSE_WORKER     \\\n-   | OMP_CLAUSE_VECTOR | OMP_CLAUSE_SEQ | OMP_CLAUSE_INDEPENDENT \\\n-   | OMP_CLAUSE_PRIVATE | OMP_CLAUSE_REDUCTION | OMP_CLAUSE_AUTO \\\n+  (omp_mask (OMP_CLAUSE_COLLAPSE) | OMP_CLAUSE_GANG | OMP_CLAUSE_WORKER\t      \\\n+   | OMP_CLAUSE_VECTOR | OMP_CLAUSE_SEQ | OMP_CLAUSE_INDEPENDENT\t      \\\n+   | OMP_CLAUSE_PRIVATE | OMP_CLAUSE_REDUCTION | OMP_CLAUSE_AUTO\t      \\\n    | OMP_CLAUSE_TILE)\n #define OACC_PARALLEL_LOOP_CLAUSES \\\n   (OACC_LOOP_CLAUSES | OACC_PARALLEL_CLAUSES)\n #define OACC_KERNELS_LOOP_CLAUSES \\\n   (OACC_LOOP_CLAUSES | OACC_KERNELS_CLAUSES)\n-#define OACC_HOST_DATA_CLAUSES OMP_CLAUSE_USE_DEVICE\n+#define OACC_HOST_DATA_CLAUSES omp_mask (OMP_CLAUSE_USE_DEVICE)\n #define OACC_DECLARE_CLAUSES \\\n-  (OMP_CLAUSE_COPY | OMP_CLAUSE_COPYIN | OMP_CLAUSE_COPYOUT                   \\\n+  (omp_mask (OMP_CLAUSE_COPY) | OMP_CLAUSE_COPYIN | OMP_CLAUSE_COPYOUT\t      \\\n    | OMP_CLAUSE_CREATE | OMP_CLAUSE_DEVICEPTR | OMP_CLAUSE_DEVICE_RESIDENT    \\\n-   | OMP_CLAUSE_PRESENT | OMP_CLAUSE_PRESENT_OR_COPY                          \\\n-   | OMP_CLAUSE_PRESENT_OR_COPYIN | OMP_CLAUSE_PRESENT_OR_COPYOUT             \\\n+   | OMP_CLAUSE_PRESENT | OMP_CLAUSE_PRESENT_OR_COPY\t\t\t      \\\n+   | OMP_CLAUSE_PRESENT_OR_COPYIN | OMP_CLAUSE_PRESENT_OR_COPYOUT\t      \\\n    | OMP_CLAUSE_PRESENT_OR_CREATE | OMP_CLAUSE_LINK)\n #define OACC_UPDATE_CLAUSES \\\n-  (OMP_CLAUSE_IF | OMP_CLAUSE_ASYNC | OMP_CLAUSE_HOST_SELF \\\n-   | OMP_CLAUSE_OACC_DEVICE | OMP_CLAUSE_WAIT)\n+  (omp_mask (OMP_CLAUSE_IF) | OMP_CLAUSE_ASYNC | OMP_CLAUSE_HOST_SELF\t      \\\n+   | OMP_CLAUSE_DEVICE | OMP_CLAUSE_WAIT)\n #define OACC_ENTER_DATA_CLAUSES \\\n-  (OMP_CLAUSE_IF | OMP_CLAUSE_ASYNC | OMP_CLAUSE_WAIT | OMP_CLAUSE_COPYIN    \\\n-   | OMP_CLAUSE_CREATE | OMP_CLAUSE_PRESENT_OR_COPYIN                          \\\n+  (omp_mask (OMP_CLAUSE_IF) | OMP_CLAUSE_ASYNC | OMP_CLAUSE_WAIT\t      \\\n+   | OMP_CLAUSE_COPYIN | OMP_CLAUSE_CREATE | OMP_CLAUSE_PRESENT_OR_COPYIN     \\\n    | OMP_CLAUSE_PRESENT_OR_CREATE)\n #define OACC_EXIT_DATA_CLAUSES \\\n-  (OMP_CLAUSE_IF | OMP_CLAUSE_ASYNC | OMP_CLAUSE_WAIT | OMP_CLAUSE_COPYOUT \\\n-   | OMP_CLAUSE_DELETE)\n+  (omp_mask (OMP_CLAUSE_IF) | OMP_CLAUSE_ASYNC | OMP_CLAUSE_WAIT\t      \\\n+   | OMP_CLAUSE_COPYOUT | OMP_CLAUSE_DELETE)\n #define OACC_WAIT_CLAUSES \\\n-  (OMP_CLAUSE_ASYNC)\n+  omp_mask (OMP_CLAUSE_ASYNC)\n #define OACC_ROUTINE_CLAUSES \\\n-  (OMP_CLAUSE_GANG | OMP_CLAUSE_WORKER | OMP_CLAUSE_VECTOR | OMP_CLAUSE_SEQ)\n+  (omp_mask (OMP_CLAUSE_GANG) | OMP_CLAUSE_WORKER | OMP_CLAUSE_VECTOR\t      \\\n+   | OMP_CLAUSE_SEQ)\n \n \n static match\n-match_acc (gfc_exec_op op, uint64_t mask)\n+match_acc (gfc_exec_op op, const omp_mask mask)\n {\n   gfc_omp_clauses *c;\n   if (gfc_match_omp_clauses (&c, mask, false, false, true) != MATCH_YES)\n@@ -1853,44 +2371,71 @@ gfc_match_oacc_routine (void)\n \n \n #define OMP_PARALLEL_CLAUSES \\\n-  (OMP_CLAUSE_PRIVATE | OMP_CLAUSE_FIRSTPRIVATE | OMP_CLAUSE_SHARED\t\\\n-   | OMP_CLAUSE_COPYIN | OMP_CLAUSE_REDUCTION | OMP_CLAUSE_IF\t\t\\\n-   | OMP_CLAUSE_NUM_THREADS | OMP_CLAUSE_DEFAULT | OMP_CLAUSE_PROC_BIND)\n+  (omp_mask (OMP_CLAUSE_PRIVATE) | OMP_CLAUSE_FIRSTPRIVATE\t\t\\\n+   | OMP_CLAUSE_SHARED | OMP_CLAUSE_COPYIN | OMP_CLAUSE_REDUCTION\t\\\n+   | OMP_CLAUSE_IF | OMP_CLAUSE_NUM_THREADS | OMP_CLAUSE_DEFAULT\t\\\n+   | OMP_CLAUSE_PROC_BIND)\n #define OMP_DECLARE_SIMD_CLAUSES \\\n-  (OMP_CLAUSE_SIMDLEN | OMP_CLAUSE_LINEAR | OMP_CLAUSE_UNIFORM\t\t\\\n-   | OMP_CLAUSE_ALIGNED | OMP_CLAUSE_INBRANCH | OMP_CLAUSE_NOTINBRANCH)\n+  (omp_mask (OMP_CLAUSE_SIMDLEN) | OMP_CLAUSE_LINEAR\t\t\t\\\n+   | OMP_CLAUSE_UNIFORM\t| OMP_CLAUSE_ALIGNED | OMP_CLAUSE_INBRANCH\t\\\n+   | OMP_CLAUSE_NOTINBRANCH)\n #define OMP_DO_CLAUSES \\\n-  (OMP_CLAUSE_PRIVATE | OMP_CLAUSE_FIRSTPRIVATE\t\t\t\t\\\n+  (omp_mask (OMP_CLAUSE_PRIVATE) | OMP_CLAUSE_FIRSTPRIVATE\t\t\\\n    | OMP_CLAUSE_LASTPRIVATE | OMP_CLAUSE_REDUCTION\t\t\t\\\n-   | OMP_CLAUSE_SCHEDULE | OMP_CLAUSE_ORDERED | OMP_CLAUSE_COLLAPSE)\n+   | OMP_CLAUSE_SCHEDULE | OMP_CLAUSE_ORDERED | OMP_CLAUSE_COLLAPSE\t\\\n+   | OMP_CLAUSE_LINEAR)\n #define OMP_SECTIONS_CLAUSES \\\n-  (OMP_CLAUSE_PRIVATE | OMP_CLAUSE_FIRSTPRIVATE\t\t\t\t\\\n+  (omp_mask (OMP_CLAUSE_PRIVATE) | OMP_CLAUSE_FIRSTPRIVATE\t\t\\\n    | OMP_CLAUSE_LASTPRIVATE | OMP_CLAUSE_REDUCTION)\n #define OMP_SIMD_CLAUSES \\\n-  (OMP_CLAUSE_PRIVATE | OMP_CLAUSE_LASTPRIVATE | OMP_CLAUSE_REDUCTION\t\\\n-   | OMP_CLAUSE_COLLAPSE | OMP_CLAUSE_SAFELEN | OMP_CLAUSE_LINEAR\t\\\n-   | OMP_CLAUSE_ALIGNED)\n+  (omp_mask (OMP_CLAUSE_PRIVATE) | OMP_CLAUSE_LASTPRIVATE\t\t\\\n+   | OMP_CLAUSE_REDUCTION | OMP_CLAUSE_COLLAPSE | OMP_CLAUSE_SAFELEN\t\\\n+   | OMP_CLAUSE_LINEAR | OMP_CLAUSE_ALIGNED | OMP_CLAUSE_SIMDLEN)\n #define OMP_TASK_CLAUSES \\\n-  (OMP_CLAUSE_PRIVATE | OMP_CLAUSE_FIRSTPRIVATE | OMP_CLAUSE_SHARED\t\\\n-   | OMP_CLAUSE_IF | OMP_CLAUSE_DEFAULT | OMP_CLAUSE_UNTIED\t\t\\\n-   | OMP_CLAUSE_FINAL | OMP_CLAUSE_MERGEABLE | OMP_CLAUSE_DEPEND)\n+  (omp_mask (OMP_CLAUSE_PRIVATE) | OMP_CLAUSE_FIRSTPRIVATE\t\t\\\n+   | OMP_CLAUSE_SHARED | OMP_CLAUSE_IF | OMP_CLAUSE_DEFAULT\t\t\\\n+   | OMP_CLAUSE_UNTIED | OMP_CLAUSE_FINAL | OMP_CLAUSE_MERGEABLE\t\\\n+   | OMP_CLAUSE_DEPEND | OMP_CLAUSE_PRIORITY)\n+#define OMP_TASKLOOP_CLAUSES \\\n+  (omp_mask (OMP_CLAUSE_PRIVATE) | OMP_CLAUSE_FIRSTPRIVATE\t\t\\\n+   | OMP_CLAUSE_LASTPRIVATE | OMP_CLAUSE_SHARED | OMP_CLAUSE_IF\t\t\\\n+   | OMP_CLAUSE_DEFAULT\t| OMP_CLAUSE_UNTIED | OMP_CLAUSE_FINAL\t\t\\\n+   | OMP_CLAUSE_MERGEABLE | OMP_CLAUSE_PRIORITY | OMP_CLAUSE_GRAINSIZE\t\\\n+   | OMP_CLAUSE_NUM_TASKS | OMP_CLAUSE_COLLAPSE | OMP_CLAUSE_NOGROUP)\n #define OMP_TARGET_CLAUSES \\\n-  (OMP_CLAUSE_DEVICE | OMP_CLAUSE_MAP | OMP_CLAUSE_IF)\n+  (omp_mask (OMP_CLAUSE_DEVICE) | OMP_CLAUSE_MAP | OMP_CLAUSE_IF\t\\\n+   | OMP_CLAUSE_DEPEND | OMP_CLAUSE_NOWAIT | OMP_CLAUSE_PRIVATE\t\t\\\n+   | OMP_CLAUSE_FIRSTPRIVATE | OMP_CLAUSE_DEFAULTMAP\t\t\t\\\n+   | OMP_CLAUSE_IS_DEVICE_PTR)\n #define OMP_TARGET_DATA_CLAUSES \\\n-  (OMP_CLAUSE_DEVICE | OMP_CLAUSE_MAP | OMP_CLAUSE_IF)\n+  (omp_mask (OMP_CLAUSE_DEVICE) | OMP_CLAUSE_MAP | OMP_CLAUSE_IF\t\\\n+   | OMP_CLAUSE_USE_DEVICE_PTR)\n+#define OMP_TARGET_ENTER_DATA_CLAUSES \\\n+  (omp_mask (OMP_CLAUSE_DEVICE) | OMP_CLAUSE_MAP | OMP_CLAUSE_IF\t\\\n+   | OMP_CLAUSE_DEPEND | OMP_CLAUSE_NOWAIT)\n+#define OMP_TARGET_EXIT_DATA_CLAUSES \\\n+  (omp_mask (OMP_CLAUSE_DEVICE) | OMP_CLAUSE_MAP | OMP_CLAUSE_IF\t\\\n+   | OMP_CLAUSE_DEPEND | OMP_CLAUSE_NOWAIT)\n #define OMP_TARGET_UPDATE_CLAUSES \\\n-  (OMP_CLAUSE_DEVICE | OMP_CLAUSE_IF | OMP_CLAUSE_TO | OMP_CLAUSE_FROM)\n+  (omp_mask (OMP_CLAUSE_DEVICE) | OMP_CLAUSE_IF | OMP_CLAUSE_TO\t\t\\\n+   | OMP_CLAUSE_FROM | OMP_CLAUSE_DEPEND | OMP_CLAUSE_NOWAIT)\n #define OMP_TEAMS_CLAUSES \\\n-  (OMP_CLAUSE_NUM_TEAMS | OMP_CLAUSE_THREAD_LIMIT | OMP_CLAUSE_DEFAULT\t\\\n-   | OMP_CLAUSE_PRIVATE | OMP_CLAUSE_FIRSTPRIVATE | OMP_CLAUSE_SHARED\t\\\n-   | OMP_CLAUSE_REDUCTION)\n+  (omp_mask (OMP_CLAUSE_NUM_TEAMS) | OMP_CLAUSE_THREAD_LIMIT\t\t\\\n+   | OMP_CLAUSE_DEFAULT\t| OMP_CLAUSE_PRIVATE | OMP_CLAUSE_FIRSTPRIVATE\t\\\n+   | OMP_CLAUSE_SHARED | OMP_CLAUSE_REDUCTION)\n #define OMP_DISTRIBUTE_CLAUSES \\\n-  (OMP_CLAUSE_PRIVATE | OMP_CLAUSE_FIRSTPRIVATE | OMP_CLAUSE_COLLAPSE\t\\\n-   | OMP_CLAUSE_DIST_SCHEDULE)\n+  (omp_mask (OMP_CLAUSE_PRIVATE) | OMP_CLAUSE_FIRSTPRIVATE\t\t\\\n+   | OMP_CLAUSE_COLLAPSE | OMP_CLAUSE_DIST_SCHEDULE)\n+#define OMP_SINGLE_CLAUSES \\\n+  (omp_mask (OMP_CLAUSE_PRIVATE) | OMP_CLAUSE_FIRSTPRIVATE)\n+#define OMP_ORDERED_CLAUSES \\\n+  (omp_mask (OMP_CLAUSE_THREADS) | OMP_CLAUSE_SIMD)\n+#define OMP_DECLARE_TARGET_CLAUSES \\\n+  (omp_mask (OMP_CLAUSE_TO) | OMP_CLAUSE_LINK)\n \n \n static match\n-match_omp (gfc_exec_op op, unsigned int mask)\n+match_omp (gfc_exec_op op, const omp_mask mask)\n {\n   gfc_omp_clauses *c;\n   if (gfc_match_omp_clauses (&c, mask) != MATCH_YES)\n@@ -1903,6 +2448,32 @@ match_omp (gfc_exec_op op, unsigned int mask)\n \n match\n gfc_match_omp_critical (void)\n+{\n+  char n[GFC_MAX_SYMBOL_LEN+1];\n+  gfc_omp_clauses *c = NULL;\n+\n+  if (gfc_match (\" ( %n )\", n) != MATCH_YES)\n+    {\n+      n[0] = '\\0';\n+      if (gfc_match_omp_eos () != MATCH_YES)\n+\t{\n+\t  gfc_error (\"Unexpected junk after $OMP CRITICAL statement at %C\");\n+\t  return MATCH_ERROR;\n+\t}\n+    }\n+  else if (gfc_match_omp_clauses (&c, omp_mask (OMP_CLAUSE_HINT)) != MATCH_YES)\n+    return MATCH_ERROR;\n+\n+  new_st.op = EXEC_OMP_CRITICAL;\n+  new_st.ext.omp_clauses = c;\n+  if (n[0])\n+    c->critical_name = xstrdup (n);\n+  return MATCH_YES;\n+}\n+\n+\n+match\n+gfc_match_omp_end_critical (void)\n {\n   char n[GFC_MAX_SYMBOL_LEN+1];\n \n@@ -1913,7 +2484,8 @@ gfc_match_omp_critical (void)\n       gfc_error (\"Unexpected junk after $OMP CRITICAL statement at %C\");\n       return MATCH_ERROR;\n     }\n-  new_st.op = EXEC_OMP_CRITICAL;\n+\n+  new_st.op = EXEC_OMP_END_CRITICAL;\n   new_st.ext.omp_name = n[0] ? xstrdup (n) : NULL;\n   return MATCH_YES;\n }\n@@ -1930,8 +2502,10 @@ match\n gfc_match_omp_distribute_parallel_do (void)\n {\n   return match_omp (EXEC_OMP_DISTRIBUTE_PARALLEL_DO,\n-\t\t    OMP_DISTRIBUTE_CLAUSES | OMP_PARALLEL_CLAUSES\n-\t\t    | OMP_DO_CLAUSES);\n+\t\t    (OMP_DISTRIBUTE_CLAUSES | OMP_PARALLEL_CLAUSES\n+\t\t     | OMP_DO_CLAUSES)\n+\t\t    & ~(omp_mask (OMP_CLAUSE_ORDERED))\n+\t\t    & ~(omp_mask (OMP_CLAUSE_LINEAR)));\n }\n \n \n@@ -1941,7 +2515,7 @@ gfc_match_omp_distribute_parallel_do_simd (void)\n   return match_omp (EXEC_OMP_DISTRIBUTE_PARALLEL_DO_SIMD,\n \t\t    (OMP_DISTRIBUTE_CLAUSES | OMP_PARALLEL_CLAUSES\n \t\t     | OMP_DO_CLAUSES | OMP_SIMD_CLAUSES)\n-\t\t    & ~OMP_CLAUSE_ORDERED);\n+\t\t    & ~(omp_mask (OMP_CLAUSE_ORDERED)));\n }\n \n \n@@ -1963,8 +2537,7 @@ gfc_match_omp_do (void)\n match\n gfc_match_omp_do_simd (void)\n {\n-  return match_omp (EXEC_OMP_DO_SIMD, ((OMP_DO_CLAUSES | OMP_SIMD_CLAUSES)\n-\t\t\t\t       & ~OMP_CLAUSE_ORDERED));\n+  return match_omp (EXEC_OMP_DO_SIMD, OMP_DO_CLAUSES | OMP_SIMD_CLAUSES);\n }\n \n \n@@ -1992,12 +2565,17 @@ gfc_match_omp_declare_simd (void)\n   gfc_symbol *proc_name;\n   gfc_omp_clauses *c;\n   gfc_omp_declare_simd *ods;\n+  bool needs_space = false;\n \n-  if (gfc_match (\" ( %s ) \", &proc_name) != MATCH_YES)\n-    return MATCH_ERROR;\n+  switch (gfc_match (\" ( %s ) \", &proc_name))\n+    {\n+    case MATCH_YES: break;\n+    case MATCH_NO: proc_name = NULL; needs_space = true; break;\n+    case MATCH_ERROR: return MATCH_ERROR;\n+    }\n \n   if (gfc_match_omp_clauses (&c, OMP_DECLARE_SIMD_CLAUSES, true,\n-\t\t\t     false) != MATCH_YES)\n+\t\t\t     needs_space) != MATCH_YES)\n     return MATCH_ERROR;\n \n   if (gfc_current_ns->is_block_data)\n@@ -2411,26 +2989,15 @@ match\n gfc_match_omp_declare_target (void)\n {\n   locus old_loc;\n-  char n[GFC_MAX_SYMBOL_LEN+1];\n-  gfc_symbol *sym;\n   match m;\n-  gfc_symtree *st;\n+  gfc_omp_clauses *c = NULL;\n+  int list;\n+  gfc_omp_namelist *n;\n+  gfc_symbol *s;\n \n   old_loc = gfc_current_locus;\n \n-  m = gfc_match (\" (\");\n-\n   if (gfc_current_ns->proc_name\n-      && gfc_current_ns->proc_name->attr.if_source == IFSRC_IFBODY\n-      && m == MATCH_YES)\n-    {\n-      gfc_error (\"Only the !$OMP DECLARE TARGET form without \"\n-\t\t \"list is allowed in interface block at %C\");\n-      goto cleanup;\n-    }\n-\n-  if (m == MATCH_NO\n-      && gfc_current_ns->proc_name\n       && gfc_match_omp_eos () == MATCH_YES)\n     {\n       if (!gfc_add_omp_declare_target (&gfc_current_ns->proc_name->attr,\n@@ -2440,65 +3007,120 @@ gfc_match_omp_declare_target (void)\n       return MATCH_YES;\n     }\n \n-  if (m != MATCH_YES)\n-    return m;\n+  if (gfc_current_ns->proc_name\n+      && gfc_current_ns->proc_name->attr.if_source == IFSRC_IFBODY)\n+    {\n+      gfc_error (\"Only the !$OMP DECLARE TARGET form without \"\n+\t\t \"clauses is allowed in interface block at %C\");\n+      goto cleanup;\n+    }\n \n-  for (;;)\n+  m = gfc_match (\" (\");\n+  if (m == MATCH_YES)\n     {\n-      m = gfc_match_symbol (&sym, 0);\n-      switch (m)\n+      c = gfc_get_omp_clauses ();\n+      gfc_current_locus = old_loc;\n+      m = gfc_match_omp_to_link (\" (\", &c->lists[OMP_LIST_TO]);\n+      if (m != MATCH_YES)\n+\tgoto syntax;\n+      if (gfc_match_omp_eos () != MATCH_YES)\n \t{\n-\tcase MATCH_YES:\n-\t  if (sym->attr.in_common)\n-\t    gfc_error_now (\"OMP DECLARE TARGET on a variable at %C is an \"\n-\t\t\t   \"element of a COMMON block\");\n-\t  else if (!gfc_add_omp_declare_target (&sym->attr, sym->name,\n-\t\t\t\t\t\t&sym->declared_at))\n-\t    goto cleanup;\n-\t  goto next_item;\n-\tcase MATCH_NO:\n-\t  break;\n-\tcase MATCH_ERROR:\n+\t  gfc_error (\"Unexpected junk after !$OMP DECLARE TARGET at %C\");\n \t  goto cleanup;\n \t}\n+    }\n+  else if (gfc_match_omp_clauses (&c, OMP_DECLARE_TARGET_CLAUSES) != MATCH_YES)\n+    return MATCH_ERROR;\n \n-      m = gfc_match (\" / %n /\", n);\n-      if (m == MATCH_ERROR)\n-\tgoto cleanup;\n-      if (m == MATCH_NO || n[0] == '\\0')\n-\tgoto syntax;\n+  gfc_buffer_error (false);\n \n-      st = gfc_find_symtree (gfc_current_ns->common_root, n);\n-      if (st == NULL)\n+  for (list = OMP_LIST_TO; list != OMP_LIST_NUM;\n+       list = (list == OMP_LIST_TO ? OMP_LIST_LINK : OMP_LIST_NUM))\n+    for (n = c->lists[list]; n; n = n->next)\n+      if (n->sym)\n+\tn->sym->mark = 0;\n+      else if (n->u.common->head)\n+\tn->u.common->head->mark = 0;\n+\n+  for (list = OMP_LIST_TO; list != OMP_LIST_NUM;\n+       list = (list == OMP_LIST_TO ? OMP_LIST_LINK : OMP_LIST_NUM))\n+    for (n = c->lists[list]; n; n = n->next)\n+      if (n->sym)\n \t{\n-\t  gfc_error (\"COMMON block /%s/ not found at %C\", n);\n-\t  goto cleanup;\n+\t  if (n->sym->attr.in_common)\n+\t    gfc_error_now (\"OMP DECLARE TARGET variable at %L is an \"\n+\t\t\t   \"element of a COMMON block\", &n->where);\n+\t  else if (n->sym->attr.omp_declare_target\n+\t\t   && n->sym->attr.omp_declare_target_link\n+\t\t   && list != OMP_LIST_LINK)\n+\t    gfc_error_now (\"OMP DECLARE TARGET variable at %L previously \"\n+\t\t\t   \"mentioned in LINK clause and later in TO clause\",\n+\t\t\t   &n->where);\n+\t  else if (n->sym->attr.omp_declare_target\n+\t\t   && !n->sym->attr.omp_declare_target_link\n+\t\t   && list == OMP_LIST_LINK)\n+\t    gfc_error_now (\"OMP DECLARE TARGET variable at %L previously \"\n+\t\t\t   \"mentioned in TO clause and later in LINK clause\",\n+\t\t\t   &n->where);\n+\t  else if (n->sym->mark)\n+\t    gfc_error_now (\"Variable at %L mentioned multiple times in \"\n+\t\t\t   \"clauses of the same OMP DECLARE TARGET directive\",\n+\t\t\t   &n->where);\n+\t  else if (gfc_add_omp_declare_target (&n->sym->attr, n->sym->name,\n+\t\t\t\t\t       &n->sym->declared_at))\n+\t    {\n+\t      if (list == OMP_LIST_LINK)\n+\t\tgfc_add_omp_declare_target_link (&n->sym->attr, n->sym->name,\n+\t\t\t\t\t\t &n->sym->declared_at);\n+\t    }\n+\t  n->sym->mark = 1;\n+\t}\n+      else if (n->u.common->omp_declare_target\n+\t       && n->u.common->omp_declare_target_link\n+\t       && list != OMP_LIST_LINK)\n+\tgfc_error_now (\"OMP DECLARE TARGET COMMON at %L previously \"\n+\t\t       \"mentioned in LINK clause and later in TO clause\",\n+\t\t       &n->where);\n+      else if (n->u.common->omp_declare_target\n+\t       && !n->u.common->omp_declare_target_link\n+\t       && list == OMP_LIST_LINK)\n+\tgfc_error_now (\"OMP DECLARE TARGET COMMON at %L previously \"\n+\t\t       \"mentioned in TO clause and later in LINK clause\",\n+\t\t       &n->where);\n+      else if (n->u.common->head && n->u.common->head->mark)\n+\tgfc_error_now (\"COMMON at %L mentioned multiple times in \"\n+\t\t       \"clauses of the same OMP DECLARE TARGET directive\",\n+\t\t       &n->where);\n+      else\n+\t{\n+\t  n->u.common->omp_declare_target = 1;\n+\t  n->u.common->omp_declare_target_link = (list == OMP_LIST_LINK);\n+\t  for (s = n->u.common->head; s; s = s->common_next)\n+\t    {\n+\t      s->mark = 1;\n+\t      if (gfc_add_omp_declare_target (&s->attr, s->name,\n+\t\t\t\t\t      &s->declared_at))\n+\t\t{\n+\t\t  if (list == OMP_LIST_LINK)\n+\t\t    gfc_add_omp_declare_target_link (&s->attr, s->name,\n+\t\t\t\t\t\t     &s->declared_at);\n+\t\t}\n+\t    }\n \t}\n-      st->n.common->omp_declare_target = 1;\n-      for (sym = st->n.common->head; sym; sym = sym->common_next)\n-\tif (!gfc_add_omp_declare_target (&sym->attr, sym->name,\n-\t\t\t\t\t &sym->declared_at))\n-\t  goto cleanup;\n \n-    next_item:\n-      if (gfc_match_char (')') == MATCH_YES)\n-\tbreak;\n-      if (gfc_match_char (',') != MATCH_YES)\n-\tgoto syntax;\n-    }\n+  gfc_buffer_error (true);\n \n-  if (gfc_match_omp_eos () != MATCH_YES)\n-    {\n-      gfc_error (\"Unexpected junk after !$OMP DECLARE TARGET at %C\");\n-      goto cleanup;\n-    }\n+  if (c)\n+    gfc_free_omp_clauses (c);\n   return MATCH_YES;\n \n syntax:\n   gfc_error (\"Syntax error in !$OMP DECLARE TARGET list at %C\");\n \n cleanup:\n   gfc_current_locus = old_loc;\n+  if (c)\n+    gfc_free_omp_clauses (c);\n   return MATCH_ERROR;\n }\n \n@@ -2596,8 +3218,7 @@ match\n gfc_match_omp_parallel_do_simd (void)\n {\n   return match_omp (EXEC_OMP_PARALLEL_DO_SIMD,\n-\t\t    (OMP_PARALLEL_CLAUSES | OMP_DO_CLAUSES | OMP_SIMD_CLAUSES)\n-\t\t    & ~OMP_CLAUSE_ORDERED);\n+\t\t    OMP_PARALLEL_CLAUSES | OMP_DO_CLAUSES | OMP_SIMD_CLAUSES);\n }\n \n \n@@ -2633,57 +3254,70 @@ gfc_match_omp_simd (void)\n match\n gfc_match_omp_single (void)\n {\n-  return match_omp (EXEC_OMP_SINGLE,\n-\t\t    OMP_CLAUSE_PRIVATE | OMP_CLAUSE_FIRSTPRIVATE);\n+  return match_omp (EXEC_OMP_SINGLE, OMP_SINGLE_CLAUSES);\n }\n \n \n match\n-gfc_match_omp_task (void)\n+gfc_match_omp_target (void)\n {\n-  return match_omp (EXEC_OMP_TASK, OMP_TASK_CLAUSES);\n+  return match_omp (EXEC_OMP_TARGET, OMP_TARGET_CLAUSES);\n }\n \n \n match\n-gfc_match_omp_taskwait (void)\n+gfc_match_omp_target_data (void)\n {\n-  if (gfc_match_omp_eos () != MATCH_YES)\n-    {\n-      gfc_error (\"Unexpected junk after TASKWAIT clause at %C\");\n-      return MATCH_ERROR;\n-    }\n-  new_st.op = EXEC_OMP_TASKWAIT;\n-  new_st.ext.omp_clauses = NULL;\n-  return MATCH_YES;\n+  return match_omp (EXEC_OMP_TARGET_DATA, OMP_TARGET_DATA_CLAUSES);\n }\n \n \n match\n-gfc_match_omp_taskyield (void)\n+gfc_match_omp_target_enter_data (void)\n {\n-  if (gfc_match_omp_eos () != MATCH_YES)\n-    {\n-      gfc_error (\"Unexpected junk after TASKYIELD clause at %C\");\n-      return MATCH_ERROR;\n-    }\n-  new_st.op = EXEC_OMP_TASKYIELD;\n-  new_st.ext.omp_clauses = NULL;\n-  return MATCH_YES;\n+  return match_omp (EXEC_OMP_TARGET_ENTER_DATA, OMP_TARGET_ENTER_DATA_CLAUSES);\n }\n \n \n match\n-gfc_match_omp_target (void)\n+gfc_match_omp_target_exit_data (void)\n {\n-  return match_omp (EXEC_OMP_TARGET, OMP_TARGET_CLAUSES);\n+  return match_omp (EXEC_OMP_TARGET_EXIT_DATA, OMP_TARGET_EXIT_DATA_CLAUSES);\n }\n \n \n match\n-gfc_match_omp_target_data (void)\n+gfc_match_omp_target_parallel (void)\n {\n-  return match_omp (EXEC_OMP_TARGET_DATA, OMP_TARGET_DATA_CLAUSES);\n+  return match_omp (EXEC_OMP_TARGET_PARALLEL,\n+\t\t    (OMP_TARGET_CLAUSES | OMP_PARALLEL_CLAUSES)\n+\t\t    & ~(omp_mask (OMP_CLAUSE_COPYIN)));\n+}\n+\n+\n+match\n+gfc_match_omp_target_parallel_do (void)\n+{\n+  return match_omp (EXEC_OMP_TARGET_PARALLEL_DO,\n+\t\t    (OMP_TARGET_CLAUSES | OMP_PARALLEL_CLAUSES\n+\t\t     | OMP_DO_CLAUSES) & ~(omp_mask (OMP_CLAUSE_COPYIN)));\n+}\n+\n+\n+match\n+gfc_match_omp_target_parallel_do_simd (void)\n+{\n+  return match_omp (EXEC_OMP_TARGET_PARALLEL_DO_SIMD,\n+\t\t    (OMP_TARGET_CLAUSES | OMP_PARALLEL_CLAUSES | OMP_DO_CLAUSES\n+\t\t     | OMP_SIMD_CLAUSES) & ~(omp_mask (OMP_CLAUSE_COPYIN)));\n+}\n+\n+\n+match\n+gfc_match_omp_target_simd (void)\n+{\n+  return match_omp (EXEC_OMP_TARGET_SIMD,\n+\t\t    OMP_TARGET_CLAUSES | OMP_SIMD_CLAUSES);\n }\n \n \n@@ -2708,9 +3342,11 @@ match\n gfc_match_omp_target_teams_distribute_parallel_do (void)\n {\n   return match_omp (EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO,\n-\t\t    OMP_TARGET_CLAUSES | OMP_TEAMS_CLAUSES\n-\t\t    | OMP_DISTRIBUTE_CLAUSES | OMP_PARALLEL_CLAUSES\n-\t\t    | OMP_DO_CLAUSES);\n+\t\t    (OMP_TARGET_CLAUSES | OMP_TEAMS_CLAUSES\n+\t\t     | OMP_DISTRIBUTE_CLAUSES | OMP_PARALLEL_CLAUSES\n+\t\t     | OMP_DO_CLAUSES)\n+\t\t    & ~(omp_mask (OMP_CLAUSE_ORDERED))\n+\t\t    & ~(omp_mask (OMP_CLAUSE_LINEAR)));\n }\n \n \n@@ -2721,7 +3357,7 @@ gfc_match_omp_target_teams_distribute_parallel_do_simd (void)\n \t\t    (OMP_TARGET_CLAUSES | OMP_TEAMS_CLAUSES\n \t\t     | OMP_DISTRIBUTE_CLAUSES | OMP_PARALLEL_CLAUSES\n \t\t     | OMP_DO_CLAUSES | OMP_SIMD_CLAUSES)\n-\t\t    & ~OMP_CLAUSE_ORDERED);\n+\t\t    & ~(omp_mask (OMP_CLAUSE_ORDERED)));\n }\n \n \n@@ -2741,6 +3377,57 @@ gfc_match_omp_target_update (void)\n }\n \n \n+match\n+gfc_match_omp_task (void)\n+{\n+  return match_omp (EXEC_OMP_TASK, OMP_TASK_CLAUSES);\n+}\n+\n+\n+match\n+gfc_match_omp_taskloop (void)\n+{\n+  return match_omp (EXEC_OMP_TASKLOOP, OMP_TASKLOOP_CLAUSES);\n+}\n+\n+\n+match\n+gfc_match_omp_taskloop_simd (void)\n+{\n+  return match_omp (EXEC_OMP_TASKLOOP_SIMD,\n+\t\t    (OMP_TASKLOOP_CLAUSES | OMP_SIMD_CLAUSES)\n+\t\t    & ~(omp_mask (OMP_CLAUSE_REDUCTION)));\n+}\n+\n+\n+match\n+gfc_match_omp_taskwait (void)\n+{\n+  if (gfc_match_omp_eos () != MATCH_YES)\n+    {\n+      gfc_error (\"Unexpected junk after TASKWAIT clause at %C\");\n+      return MATCH_ERROR;\n+    }\n+  new_st.op = EXEC_OMP_TASKWAIT;\n+  new_st.ext.omp_clauses = NULL;\n+  return MATCH_YES;\n+}\n+\n+\n+match\n+gfc_match_omp_taskyield (void)\n+{\n+  if (gfc_match_omp_eos () != MATCH_YES)\n+    {\n+      gfc_error (\"Unexpected junk after TASKYIELD clause at %C\");\n+      return MATCH_ERROR;\n+    }\n+  new_st.op = EXEC_OMP_TASKYIELD;\n+  new_st.ext.omp_clauses = NULL;\n+  return MATCH_YES;\n+}\n+\n+\n match\n gfc_match_omp_teams (void)\n {\n@@ -2760,8 +3447,10 @@ match\n gfc_match_omp_teams_distribute_parallel_do (void)\n {\n   return match_omp (EXEC_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO,\n-\t\t    OMP_TEAMS_CLAUSES | OMP_DISTRIBUTE_CLAUSES\n-\t\t    | OMP_PARALLEL_CLAUSES | OMP_DO_CLAUSES);\n+\t\t    (OMP_TEAMS_CLAUSES | OMP_DISTRIBUTE_CLAUSES\n+\t\t     | OMP_PARALLEL_CLAUSES | OMP_DO_CLAUSES)\n+\t\t    & ~(omp_mask (OMP_CLAUSE_ORDERED))\n+\t\t    & ~(omp_mask (OMP_CLAUSE_LINEAR)));\n }\n \n \n@@ -2771,7 +3460,7 @@ gfc_match_omp_teams_distribute_parallel_do_simd (void)\n   return match_omp (EXEC_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD,\n \t\t    (OMP_TEAMS_CLAUSES | OMP_DISTRIBUTE_CLAUSES\n \t\t     | OMP_PARALLEL_CLAUSES | OMP_DO_CLAUSES\n-\t\t     | OMP_SIMD_CLAUSES) & ~OMP_CLAUSE_ORDERED);\n+\t\t     | OMP_SIMD_CLAUSES) & ~(omp_mask (OMP_CLAUSE_ORDERED)));\n }\n \n \n@@ -2815,14 +3504,14 @@ gfc_match_omp_master (void)\n match\n gfc_match_omp_ordered (void)\n {\n-  if (gfc_match_omp_eos () != MATCH_YES)\n-    {\n-      gfc_error (\"Unexpected junk after $OMP ORDERED statement at %C\");\n-      return MATCH_ERROR;\n-    }\n-  new_st.op = EXEC_OMP_ORDERED;\n-  new_st.ext.omp_clauses = NULL;\n-  return MATCH_YES;\n+  return match_omp (EXEC_OMP_ORDERED, OMP_ORDERED_CLAUSES);\n+}\n+\n+\n+match\n+gfc_match_omp_ordered_depend (void)\n+{\n+  return match_omp (EXEC_OMP_ORDERED, omp_mask (OMP_CLAUSE_DEPEND));\n }\n \n \n@@ -2935,7 +3624,7 @@ gfc_match_omp_cancel (void)\n   enum gfc_omp_cancel_kind kind = gfc_match_omp_cancel_kind ();\n   if (kind == OMP_CANCEL_UNKNOWN)\n     return MATCH_ERROR;\n-  if (gfc_match_omp_clauses (&c, OMP_CLAUSE_IF, false) != MATCH_YES)\n+  if (gfc_match_omp_clauses (&c, omp_mask (OMP_CLAUSE_IF), false) != MATCH_YES)\n     return MATCH_ERROR;\n   c->cancel = kind;\n   new_st.op = EXEC_OMP_CANCEL;\n@@ -2992,7 +3681,8 @@ gfc_match_omp_end_single (void)\n       new_st.ext.omp_bool = true;\n       return MATCH_YES;\n     }\n-  if (gfc_match_omp_clauses (&c, OMP_CLAUSE_COPYPRIVATE) != MATCH_YES)\n+  if (gfc_match_omp_clauses (&c, omp_mask (OMP_CLAUSE_COPYPRIVATE))\n+      != MATCH_YES)\n     return MATCH_ERROR;\n   new_st.op = EXEC_OMP_END_SINGLE;\n   new_st.ext.omp_clauses = c;\n@@ -3009,23 +3699,35 @@ oacc_is_loop (gfc_code *code)\n }\n \n static void\n-resolve_oacc_scalar_int_expr (gfc_expr *expr, const char *clause)\n+resolve_scalar_int_expr (gfc_expr *expr, const char *clause)\n {\n   if (!gfc_resolve_expr (expr)\n-      || expr->ts.type != BT_INTEGER || expr->rank != 0)\n+      || expr->ts.type != BT_INTEGER\n+      || expr->rank != 0)\n     gfc_error (\"%s clause at %L requires a scalar INTEGER expression\",\n-\t\t     clause, &expr->where);\n+\t       clause, &expr->where);\n }\n \n-\n static void\n-resolve_oacc_positive_int_expr (gfc_expr *expr, const char *clause)\n+resolve_positive_int_expr (gfc_expr *expr, const char *clause)\n {\n-  resolve_oacc_scalar_int_expr (expr, clause);\n-  if (expr->expr_type == EXPR_CONSTANT && expr->ts.type == BT_INTEGER\n-      && mpz_sgn(expr->value.integer) <= 0)\n+  resolve_scalar_int_expr (expr, clause);\n+  if (expr->expr_type == EXPR_CONSTANT\n+      && expr->ts.type == BT_INTEGER\n+      && mpz_sgn (expr->value.integer) <= 0)\n     gfc_warning (0, \"INTEGER expression of %s clause at %L must be positive\",\n-\t\t     clause, &expr->where);\n+\t\t clause, &expr->where);\n+}\n+\n+static void\n+resolve_nonnegative_int_expr (gfc_expr *expr, const char *clause)\n+{\n+  resolve_scalar_int_expr (expr, clause);\n+  if (expr->expr_type == EXPR_CONSTANT\n+      && expr->ts.type == BT_INTEGER\n+      && mpz_sgn (expr->value.integer) < 0)\n+    gfc_warning (0, \"INTEGER expression of %s clause at %L must be \"\n+\t\t \"non-negative\", clause, &expr->where);\n }\n \n /* Emits error when symbol is pointer, cray pointer or cray pointee\n@@ -3229,23 +3931,124 @@ resolve_omp_clauses (gfc_code *code, gfc_omp_clauses *omp_clauses,\n   gfc_omp_namelist *n;\n   gfc_expr_list *el;\n   int list;\n+  int ifc;\n+  bool if_without_mod = false;\n+  gfc_omp_linear_op linear_op = OMP_LINEAR_DEFAULT;\n   static const char *clause_names[]\n     = { \"PRIVATE\", \"FIRSTPRIVATE\", \"LASTPRIVATE\", \"COPYPRIVATE\", \"SHARED\",\n \t\"COPYIN\", \"UNIFORM\", \"ALIGNED\", \"LINEAR\", \"DEPEND\", \"MAP\",\n \t\"TO\", \"FROM\", \"REDUCTION\", \"DEVICE_RESIDENT\", \"LINK\", \"USE_DEVICE\",\n-\t\"CACHE\" };\n+\t\"CACHE\", \"IS_DEVICE_PTR\", \"USE_DEVICE_PTR\" };\n \n   if (omp_clauses == NULL)\n     return;\n \n+  if (omp_clauses->orderedc && omp_clauses->orderedc < omp_clauses->collapse)\n+    gfc_error (\"ORDERED clause parameter is less than COLLAPSE at %L\",\n+\t       &code->loc);\n+\n   if (omp_clauses->if_expr)\n     {\n       gfc_expr *expr = omp_clauses->if_expr;\n       if (!gfc_resolve_expr (expr)\n \t  || expr->ts.type != BT_LOGICAL || expr->rank != 0)\n \tgfc_error (\"IF clause at %L requires a scalar LOGICAL expression\",\n \t\t   &expr->where);\n+      if_without_mod = true;\n     }\n+  for (ifc = 0; ifc < OMP_IF_LAST; ifc++)\n+    if (omp_clauses->if_exprs[ifc])\n+      {\n+\tgfc_expr *expr = omp_clauses->if_exprs[ifc];\n+\tbool ok = true;\n+\tif (!gfc_resolve_expr (expr)\n+\t    || expr->ts.type != BT_LOGICAL || expr->rank != 0)\n+\t  gfc_error (\"IF clause at %L requires a scalar LOGICAL expression\",\n+\t\t     &expr->where);\n+\telse if (if_without_mod)\n+\t  {\n+\t    gfc_error (\"IF clause without modifier at %L used together with\"\n+\t\t       \"IF clauses with modifiers\",\n+\t\t       &omp_clauses->if_expr->where);\n+\t    if_without_mod = false;\n+\t  }\n+\telse\n+\t  switch (code->op)\n+\t    {\n+\t    case EXEC_OMP_PARALLEL:\n+\t    case EXEC_OMP_PARALLEL_DO:\n+\t    case EXEC_OMP_PARALLEL_SECTIONS:\n+\t    case EXEC_OMP_PARALLEL_WORKSHARE:\n+\t    case EXEC_OMP_PARALLEL_DO_SIMD:\n+\t    case EXEC_OMP_DISTRIBUTE_PARALLEL_DO:\n+\t    case EXEC_OMP_DISTRIBUTE_PARALLEL_DO_SIMD:\n+\t    case EXEC_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO:\n+\t    case EXEC_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD:\n+\t      ok = ifc == OMP_IF_PARALLEL;\n+\t      break;\n+\n+\t    case EXEC_OMP_TASK:\n+\t      ok = ifc == OMP_IF_TASK;\n+\t      break;\n+\n+\t    case EXEC_OMP_TASKLOOP:\n+\t    case EXEC_OMP_TASKLOOP_SIMD:\n+\t      ok = ifc == OMP_IF_TASKLOOP;\n+\t      break;\n+\n+\t    case EXEC_OMP_TARGET:\n+\t    case EXEC_OMP_TARGET_TEAMS:\n+\t    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE:\n+\t    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_SIMD:\n+\t    case EXEC_OMP_TARGET_SIMD:\n+\t      ok = ifc == OMP_IF_TARGET;\n+\t      break;\n+\n+\t    case EXEC_OMP_TARGET_DATA:\n+\t      ok = ifc == OMP_IF_TARGET_DATA;\n+\t      break;\n+\n+\t    case EXEC_OMP_TARGET_UPDATE:\n+\t      ok = ifc == OMP_IF_TARGET_UPDATE;\n+\t      break;\n+\n+\t    case EXEC_OMP_TARGET_ENTER_DATA:\n+\t      ok = ifc == OMP_IF_TARGET_ENTER_DATA;\n+\t      break;\n+\n+\t    case EXEC_OMP_TARGET_EXIT_DATA:\n+\t      ok = ifc == OMP_IF_TARGET_EXIT_DATA;\n+\t      break;\n+\n+\t    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO:\n+\t    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD:\n+\t    case EXEC_OMP_TARGET_PARALLEL:\n+\t    case EXEC_OMP_TARGET_PARALLEL_DO:\n+\t    case EXEC_OMP_TARGET_PARALLEL_DO_SIMD:\n+\t      ok = ifc == OMP_IF_TARGET || ifc == OMP_IF_PARALLEL;\n+\t      break;\n+\n+\t    default:\n+\t      ok = false;\n+\t      break;\n+\t  }\n+\tif (!ok)\n+\t  {\n+\t    static const char *ifs[] = {\n+\t      \"PARALLEL\",\n+\t      \"TASK\",\n+\t      \"TASKLOOP\",\n+\t      \"TARGET\",\n+\t      \"TARGET DATA\",\n+\t      \"TARGET UPDATE\",\n+\t      \"TARGET ENTER DATA\",\n+\t      \"TARGET EXIT DATA\"\n+\t    };\n+\t    gfc_error (\"IF clause modifier %s at %L not appropriate for \"\n+\t\t       \"the current OpenMP construct\", ifs[ifc], &expr->where);\n+\t  }\n+      }\n+\n   if (omp_clauses->final_expr)\n     {\n       gfc_expr *expr = omp_clauses->final_expr;\n@@ -3255,13 +4058,7 @@ resolve_omp_clauses (gfc_code *code, gfc_omp_clauses *omp_clauses,\n \t\t   &expr->where);\n     }\n   if (omp_clauses->num_threads)\n-    {\n-      gfc_expr *expr = omp_clauses->num_threads;\n-      if (!gfc_resolve_expr (expr)\n-\t  || expr->ts.type != BT_INTEGER || expr->rank != 0)\n-\tgfc_error (\"NUM_THREADS clause at %L requires a scalar \"\n-\t\t   \"INTEGER expression\", &expr->where);\n-    }\n+    resolve_positive_int_expr (omp_clauses->num_threads, \"NUM_THREADS\");\n   if (omp_clauses->chunk_size)\n     {\n       gfc_expr *expr = omp_clauses->chunk_size;\n@@ -3499,6 +4296,36 @@ resolve_omp_clauses (gfc_code *code, gfc_omp_clauses *omp_clauses,\n \t  case OMP_LIST_CACHE:\n \t    for (; n != NULL; n = n->next)\n \t      {\n+\t\tif (list == OMP_LIST_DEPEND)\n+\t\t  {\n+\t\t    if (n->u.depend_op == OMP_DEPEND_SINK_FIRST\n+\t\t\t|| n->u.depend_op == OMP_DEPEND_SINK)\n+\t\t      {\n+\t\t\tif (code->op != EXEC_OMP_ORDERED)\n+\t\t\t  gfc_error (\"SINK dependence type only allowed \"\n+\t\t\t\t     \"on ORDERED directive at %L\", &n->where);\n+\t\t\telse if (omp_clauses->depend_source)\n+\t\t\t  {\n+\t\t\t    gfc_error (\"DEPEND SINK used together with \"\n+\t\t\t\t       \"DEPEND SOURCE on the same construct \"\n+\t\t\t\t       \"at %L\", &n->where);\n+\t\t\t    omp_clauses->depend_source = false;\n+\t\t\t  }\n+\t\t\telse if (n->expr)\n+\t\t\t  {\n+\t\t\t    if (!gfc_resolve_expr (n->expr)\n+\t\t\t\t|| n->expr->ts.type != BT_INTEGER\n+\t\t\t\t|| n->expr->rank != 0)\n+\t\t\t      gfc_error (\"SINK addend not a constant integer\"\n+\t\t\t\t\t \"at %L\", &n->where);\n+\t\t\t  }\n+\t\t\tcontinue;\n+\t\t      }\n+\t\t    else if (code->op == EXEC_OMP_ORDERED)\n+\t\t      gfc_error (\"Only SOURCE or SINK dependence types \"\n+\t\t\t\t \"are allowed on ORDERED directive at %L\",\n+\t\t\t\t &n->where);\n+\t\t  }\n \t\tif (n->expr)\n \t\t  {\n \t\t    if (!gfc_resolve_expr (n->expr)\n@@ -3555,6 +4382,62 @@ resolve_omp_clauses (gfc_code *code, gfc_omp_clauses *omp_clauses,\n \t\t    else\n \t\t      resolve_oacc_data_clauses (n->sym, n->where, name);\n \t\t  }\n+\t\tif (list == OMP_LIST_MAP && !openacc)\n+\t\t  switch (code->op)\n+\t\t    {\n+\t\t    case EXEC_OMP_TARGET:\n+\t\t    case EXEC_OMP_TARGET_DATA:\n+\t\t      switch (n->u.map_op)\n+\t\t\t{\n+\t\t\tcase OMP_MAP_TO:\n+\t\t\tcase OMP_MAP_ALWAYS_TO:\n+\t\t\tcase OMP_MAP_FROM:\n+\t\t\tcase OMP_MAP_ALWAYS_FROM:\n+\t\t\tcase OMP_MAP_TOFROM:\n+\t\t\tcase OMP_MAP_ALWAYS_TOFROM:\n+\t\t\tcase OMP_MAP_ALLOC:\n+\t\t\t  break;\n+\t\t\tdefault:\n+\t\t\t  gfc_error (\"TARGET%s with map-type other than TO, \"\n+\t\t\t\t     \"FROM, TOFROM, or ALLOC on MAP clause \"\n+\t\t\t\t     \"at %L\",\n+\t\t\t\t     code->op == EXEC_OMP_TARGET\n+\t\t\t\t     ? \"\" : \" DATA\", &n->where);\n+\t\t\t  break;\n+\t\t\t}\n+\t\t      break;\n+\t\t    case EXEC_OMP_TARGET_ENTER_DATA:\n+\t\t      switch (n->u.map_op)\n+\t\t\t{\n+\t\t\tcase OMP_MAP_TO:\n+\t\t\tcase OMP_MAP_ALWAYS_TO:\n+\t\t\tcase OMP_MAP_ALLOC:\n+\t\t\t  break;\n+\t\t\tdefault:\n+\t\t\t  gfc_error (\"TARGET ENTER DATA with map-type other \"\n+\t\t\t\t     \"than TO, or ALLOC on MAP clause at %L\",\n+\t\t\t\t     &n->where);\n+\t\t\t  break;\n+\t\t\t}\n+\t\t      break;\n+\t\t    case EXEC_OMP_TARGET_EXIT_DATA:\n+\t\t      switch (n->u.map_op)\n+\t\t\t{\n+\t\t\tcase OMP_MAP_FROM:\n+\t\t\tcase OMP_MAP_ALWAYS_FROM:\n+\t\t\tcase OMP_MAP_RELEASE:\n+\t\t\tcase OMP_MAP_DELETE:\n+\t\t\t  break;\n+\t\t\tdefault:\n+\t\t\t  gfc_error (\"TARGET EXIT DATA with map-type other \"\n+\t\t\t\t     \"than FROM, RELEASE, or DELETE on MAP \"\n+\t\t\t\t     \"clause at %L\", &n->where);\n+\t\t\t  break;\n+\t\t\t}\n+\t\t      break;\n+\t\t    default:\n+\t\t      break;\n+\t\t    }\n \t      }\n \n \t    if (list != OMP_LIST_DEPEND)\n@@ -3569,6 +4452,10 @@ resolve_omp_clauses (gfc_code *code, gfc_omp_clauses *omp_clauses,\n \t\t\t       n->sym->name, name, &n->where);\n \t\t}\n \t    break;\n+\t  case OMP_LIST_IS_DEVICE_PTR:\n+\t  case OMP_LIST_USE_DEVICE_PTR:\n+\t    /* FIXME: Handle these.  */\n+\t    break;\n \t  default:\n \t    for (; n != NULL; n = n->next)\n \t      {\n@@ -3726,12 +4613,30 @@ resolve_omp_clauses (gfc_code *code, gfc_omp_clauses *omp_clauses,\n \t\t      }\n \t\t    break;\n \t\t  case OMP_LIST_LINEAR:\n-\t\t    if (n->sym->ts.type != BT_INTEGER)\n+\t\t    if (code\n+\t\t\t&& n->u.linear_op != OMP_LINEAR_DEFAULT\n+\t\t\t&& n->u.linear_op != linear_op)\n+\t\t      {\n+\t\t\tgfc_error (\"LINEAR clause modifier used on DO or SIMD\"\n+\t\t\t\t   \" construct at %L\", &n->where);\n+\t\t\tlinear_op = n->u.linear_op;\n+\t\t      }\n+\t\t    else if (omp_clauses->orderedc)\n+\t\t      gfc_error (\"LINEAR clause specified together with\"\n+\t\t\t\t \"ORDERED clause with argument at %L\",\n+\t\t\t\t &n->where);\n+\t\t    else if (n->u.linear_op != OMP_LINEAR_REF\n+\t\t\t     && n->sym->ts.type != BT_INTEGER)\n \t\t      gfc_error (\"LINEAR variable %qs must be INTEGER \"\n \t\t\t\t \"at %L\", n->sym->name, &n->where);\n-\t\t    else if (!code && !n->sym->attr.value)\n-\t\t      gfc_error (\"LINEAR dummy argument %qs must have VALUE \"\n-\t\t\t\t \"attribute at %L\", n->sym->name, &n->where);\n+\t\t    else if ((n->u.linear_op == OMP_LINEAR_REF\n+\t\t\t      || n->u.linear_op == OMP_LINEAR_UVAL)\n+\t\t\t     && n->sym->attr.value)\n+\t\t      gfc_error (\"LINEAR dummy argument %qs with VALUE \"\n+\t\t\t\t \"attribute with %s modifier at %L\",\n+\t\t\t\t n->sym->name,\n+\t\t\t\t n->u.linear_op == OMP_LINEAR_REF\n+\t\t\t\t ? \"REF\" : \"UVAL\", &n->where);\n \t\t    else if (n->expr)\n \t\t      {\n \t\t\tgfc_expr *expr = n->expr;\n@@ -3742,9 +4647,25 @@ resolve_omp_clauses (gfc_code *code, gfc_omp_clauses *omp_clauses,\n \t\t\t\t     \"a scalar integer linear-step expression\",\n \t\t\t\t     n->sym->name, &n->where);\n \t\t\telse if (!code && expr->expr_type != EXPR_CONSTANT)\n-\t\t\t  gfc_error (\"%qs in LINEAR clause at %L requires \"\n-\t\t\t\t     \"a constant integer linear-step expression\",\n-\t\t\t\t     n->sym->name, &n->where);\n+\t\t\t  {\n+\t\t\t    if (expr->expr_type == EXPR_VARIABLE\n+\t\t\t\t&& expr->symtree->n.sym->attr.dummy\n+\t\t\t\t&& expr->symtree->n.sym->ns == ns)\n+\t\t\t      {\n+\t\t\t\tgfc_omp_namelist *n2;\n+\t\t\t\tfor (n2 = omp_clauses->lists[OMP_LIST_UNIFORM];\n+\t\t\t\t     n2; n2 = n2->next)\n+\t\t\t\t  if (n2->sym == expr->symtree->n.sym)\n+\t\t\t\t    break;\n+\t\t\t\tif (n2)\n+\t\t\t\t  break;\n+\t\t\t      }\n+\t\t\t    gfc_error (\"%qs in LINEAR clause at %L requires \"\n+\t\t\t\t       \"a constant integer linear-step \"\n+\t\t\t\t       \"expression or dummy argument \"\n+\t\t\t\t       \"specified in UNIFORM clause\",\n+\t\t\t\t       n->sym->name, &n->where);\n+\t\t\t  }\n \t\t      }\n \t\t    break;\n \t\t  /* Workaround for PR middle-end/26316, nothing really needs\n@@ -3789,37 +4710,17 @@ resolve_omp_clauses (gfc_code *code, gfc_omp_clauses *omp_clauses,\n \t  }\n       }\n   if (omp_clauses->safelen_expr)\n-    {\n-      gfc_expr *expr = omp_clauses->safelen_expr;\n-      if (!gfc_resolve_expr (expr)\n-\t  || expr->ts.type != BT_INTEGER || expr->rank != 0)\n-\tgfc_error (\"SAFELEN clause at %L requires a scalar \"\n-\t\t   \"INTEGER expression\", &expr->where);\n-    }\n+    resolve_positive_int_expr (omp_clauses->safelen_expr, \"SAFELEN\");\n   if (omp_clauses->simdlen_expr)\n-    {\n-      gfc_expr *expr = omp_clauses->simdlen_expr;\n-      if (!gfc_resolve_expr (expr)\n-\t  || expr->ts.type != BT_INTEGER || expr->rank != 0)\n-\tgfc_error (\"SIMDLEN clause at %L requires a scalar \"\n-\t\t   \"INTEGER expression\", &expr->where);\n-    }\n+    resolve_positive_int_expr (omp_clauses->simdlen_expr, \"SIMDLEN\");\n   if (omp_clauses->num_teams)\n-    {\n-      gfc_expr *expr = omp_clauses->num_teams;\n-      if (!gfc_resolve_expr (expr)\n-\t  || expr->ts.type != BT_INTEGER || expr->rank != 0)\n-\tgfc_error (\"NUM_TEAMS clause at %L requires a scalar \"\n-\t\t   \"INTEGER expression\", &expr->where);\n-    }\n+    resolve_positive_int_expr (omp_clauses->num_teams, \"NUM_TEAMS\");\n   if (omp_clauses->device)\n-    {\n-      gfc_expr *expr = omp_clauses->device;\n-      if (!gfc_resolve_expr (expr)\n-\t  || expr->ts.type != BT_INTEGER || expr->rank != 0)\n-\tgfc_error (\"DEVICE clause at %L requires a scalar \"\n-\t\t   \"INTEGER expression\", &expr->where);\n-    }\n+    resolve_nonnegative_int_expr (omp_clauses->device, \"DEVICE\");\n+  if (omp_clauses->hint)\n+    resolve_scalar_int_expr (omp_clauses->hint, \"HINT\");\n+  if (omp_clauses->priority)\n+    resolve_nonnegative_int_expr (omp_clauses->priority, \"PRIORITY\");\n   if (omp_clauses->dist_chunk_size)\n     {\n       gfc_expr *expr = omp_clauses->dist_chunk_size;\n@@ -3829,36 +4730,50 @@ resolve_omp_clauses (gfc_code *code, gfc_omp_clauses *omp_clauses,\n \t\t   \"a scalar INTEGER expression\", &expr->where);\n     }\n   if (omp_clauses->thread_limit)\n-    {\n-      gfc_expr *expr = omp_clauses->thread_limit;\n-      if (!gfc_resolve_expr (expr)\n-\t  || expr->ts.type != BT_INTEGER || expr->rank != 0)\n-\tgfc_error (\"THREAD_LIMIT clause at %L requires a scalar \"\n-\t\t   \"INTEGER expression\", &expr->where);\n-    }\n+    resolve_positive_int_expr (omp_clauses->thread_limit, \"THREAD_LIMIT\");\n+  if (omp_clauses->grainsize)\n+    resolve_positive_int_expr (omp_clauses->grainsize, \"GRAINSIZE\");\n+  if (omp_clauses->num_tasks)\n+    resolve_positive_int_expr (omp_clauses->num_tasks, \"NUM_TASKS\");\n   if (omp_clauses->async)\n     if (omp_clauses->async_expr)\n-      resolve_oacc_scalar_int_expr (omp_clauses->async_expr, \"ASYNC\");\n+      resolve_scalar_int_expr (omp_clauses->async_expr, \"ASYNC\");\n   if (omp_clauses->num_gangs_expr)\n-    resolve_oacc_positive_int_expr (omp_clauses->num_gangs_expr, \"NUM_GANGS\");\n+    resolve_positive_int_expr (omp_clauses->num_gangs_expr, \"NUM_GANGS\");\n   if (omp_clauses->num_workers_expr)\n-    resolve_oacc_positive_int_expr (omp_clauses->num_workers_expr,\n-\t\t\t\t    \"NUM_WORKERS\");\n+    resolve_positive_int_expr (omp_clauses->num_workers_expr, \"NUM_WORKERS\");\n   if (omp_clauses->vector_length_expr)\n-    resolve_oacc_positive_int_expr (omp_clauses->vector_length_expr,\n-\t\t\t\t    \"VECTOR_LENGTH\");\n+    resolve_positive_int_expr (omp_clauses->vector_length_expr,\n+\t\t\t       \"VECTOR_LENGTH\");\n   if (omp_clauses->gang_num_expr)\n-    resolve_oacc_positive_int_expr (omp_clauses->gang_num_expr, \"GANG\");\n+    resolve_positive_int_expr (omp_clauses->gang_num_expr, \"GANG\");\n   if (omp_clauses->gang_static_expr)\n-    resolve_oacc_positive_int_expr (omp_clauses->gang_static_expr, \"GANG\");\n+    resolve_positive_int_expr (omp_clauses->gang_static_expr, \"GANG\");\n   if (omp_clauses->worker_expr)\n-    resolve_oacc_positive_int_expr (omp_clauses->worker_expr, \"WORKER\");\n+    resolve_positive_int_expr (omp_clauses->worker_expr, \"WORKER\");\n   if (omp_clauses->vector_expr)\n-    resolve_oacc_positive_int_expr (omp_clauses->vector_expr, \"VECTOR\");\n+    resolve_positive_int_expr (omp_clauses->vector_expr, \"VECTOR\");\n   if (omp_clauses->wait)\n     if (omp_clauses->wait_list)\n       for (el = omp_clauses->wait_list; el; el = el->next)\n-\tresolve_oacc_scalar_int_expr (el->expr, \"WAIT\");\n+\tresolve_scalar_int_expr (el->expr, \"WAIT\");\n+  if (omp_clauses->depend_source && code->op != EXEC_OMP_ORDERED)\n+    gfc_error (\"SOURCE dependence type only allowed \"\n+\t       \"on ORDERED directive at %L\", &code->loc);\n+  if (!openacc && code && omp_clauses->lists[OMP_LIST_MAP] == NULL)\n+    {\n+      const char *p = NULL;\n+      switch (code->op)\n+\t{\n+\tcase EXEC_OMP_TARGET_DATA: p = \"TARGET DATA\"; break;\n+\tcase EXEC_OMP_TARGET_ENTER_DATA: p = \"TARGET ENTER DATA\"; break;\n+\tcase EXEC_OMP_TARGET_EXIT_DATA: p = \"TARGET EXIT DATA\"; break;\n+\tdefault: break;\n+\t}\n+      if (p)\n+\tgfc_error (\"%s must contain at least one MAP clause at %L\",\n+\t\t   p, &code->loc);\n+    }\n }\n \n \n@@ -4361,7 +5276,10 @@ gfc_resolve_omp_do_blocks (gfc_code *code, gfc_namespace *ns)\n       gfc_code *c;\n \n       omp_current_do_code = code->block->next;\n-      omp_current_do_collapse = code->ext.omp_clauses->collapse;\n+      if (code->ext.omp_clauses->orderedc)\n+\tomp_current_do_collapse = code->ext.omp_clauses->orderedc;\n+      else\n+\tomp_current_do_collapse = code->ext.omp_clauses->collapse;\n       for (i = 1, c = omp_current_do_code; i < omp_current_do_collapse; i++)\n \t{\n \t  c = c->block;\n@@ -4415,6 +5333,8 @@ gfc_resolve_omp_parallel_blocks (gfc_code *code, gfc_namespace *ns)\n     {\n     case EXEC_OMP_PARALLEL_DO:\n     case EXEC_OMP_PARALLEL_DO_SIMD:\n+    case EXEC_OMP_TARGET_PARALLEL_DO:\n+    case EXEC_OMP_TARGET_PARALLEL_DO_SIMD:\n     case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE:\n     case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO:\n     case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD:\n@@ -4540,8 +5460,17 @@ resolve_omp_do (gfc_code *code)\n       is_simd = true;\n       break;\n     case EXEC_OMP_SIMD: name = \"!$OMP SIMD\"; is_simd = true; break;\n+    case EXEC_OMP_TARGET_PARALLEL_DO: name = \"!$OMP TARGET PARALLEL DO\"; break;\n+    case EXEC_OMP_TARGET_PARALLEL_DO_SIMD:\n+      name = \"!$OMP TARGET PARALLEL DO SIMD\";\n+      is_simd = true;\n+      break;\n+    case EXEC_OMP_TARGET_SIMD:\n+      name = \"!$OMP TARGET SIMD\";\n+      is_simd = true;\n+      break;\n     case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE:\n-      name = \"!$OMP TARGET TEAMS_DISTRIBUTE\";\n+      name = \"!$OMP TARGET TEAMS DISTRIBUTE\";\n       break;\n     case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO:\n       name = \"!$OMP TARGET TEAMS DISTRIBUTE PARALLEL DO\";\n@@ -4554,7 +5483,12 @@ resolve_omp_do (gfc_code *code)\n       name = \"!$OMP TARGET TEAMS DISTRIBUTE SIMD\";\n       is_simd = true;\n       break;\n-    case EXEC_OMP_TEAMS_DISTRIBUTE: name = \"!$OMP TEAMS_DISTRIBUTE\"; break;\n+    case EXEC_OMP_TASKLOOP: name = \"!$OMP TASKLOOP\"; break;\n+    case EXEC_OMP_TASKLOOP_SIMD:\n+      name = \"!$OMP TASKLOOP SIMD\";\n+      is_simd = true;\n+      break;\n+    case EXEC_OMP_TEAMS_DISTRIBUTE: name = \"!$OMP TEAMS DISTRIBUTE\"; break;\n     case EXEC_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO:\n       name = \"!$OMP TEAMS DISTRIBUTE PARALLEL DO\";\n       break;\n@@ -4573,9 +5507,14 @@ resolve_omp_do (gfc_code *code)\n     resolve_omp_clauses (code, code->ext.omp_clauses, NULL);\n \n   do_code = code->block->next;\n-  collapse = code->ext.omp_clauses->collapse;\n-  if (collapse <= 0)\n-    collapse = 1;\n+  if (code->ext.omp_clauses->orderedc)\n+    collapse = code->ext.omp_clauses->orderedc;\n+  else\n+    {\n+      collapse = code->ext.omp_clauses->collapse;\n+      if (collapse <= 0)\n+\tcollapse = 1;\n+    }\n   for (i = 1; i <= collapse; i++)\n     {\n       if (do_code->op == EXEC_DO_WHILE)\n@@ -4972,7 +5911,7 @@ resolve_oacc_loop_blocks (gfc_code *code)\n \t    }\n \t  else\n \t    {\n-\t      resolve_oacc_positive_int_expr (el->expr, \"TILE\");\n+\t      resolve_positive_int_expr (el->expr, \"TILE\");\n \t      if (el->expr->expr_type != EXPR_CONSTANT)\n \t\tgfc_error (\"TILE requires constant expression at %L\",\n \t\t\t   &code->loc);\n@@ -5134,10 +6073,15 @@ gfc_resolve_omp_directive (gfc_code *code, gfc_namespace *ns ATTRIBUTE_UNUSED)\n     case EXEC_OMP_PARALLEL_DO:\n     case EXEC_OMP_PARALLEL_DO_SIMD:\n     case EXEC_OMP_SIMD:\n+    case EXEC_OMP_TARGET_PARALLEL_DO:\n+    case EXEC_OMP_TARGET_PARALLEL_DO_SIMD:\n+    case EXEC_OMP_TARGET_SIMD:\n     case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE:\n     case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO:\n     case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD:\n     case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_SIMD:\n+    case EXEC_OMP_TASKLOOP:\n+    case EXEC_OMP_TASKLOOP_SIMD:\n     case EXEC_OMP_TEAMS_DISTRIBUTE:\n     case EXEC_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO:\n     case EXEC_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD:\n@@ -5152,6 +6096,9 @@ gfc_resolve_omp_directive (gfc_code *code, gfc_namespace *ns ATTRIBUTE_UNUSED)\n     case EXEC_OMP_SINGLE:\n     case EXEC_OMP_TARGET:\n     case EXEC_OMP_TARGET_DATA:\n+    case EXEC_OMP_TARGET_ENTER_DATA:\n+    case EXEC_OMP_TARGET_EXIT_DATA:\n+    case EXEC_OMP_TARGET_PARALLEL:\n     case EXEC_OMP_TARGET_TEAMS:\n     case EXEC_OMP_TASK:\n     case EXEC_OMP_TEAMS:\n@@ -5185,7 +6132,8 @@ gfc_resolve_omp_declare_simd (gfc_namespace *ns)\n \n   for (ods = ns->omp_declare_simd; ods; ods = ods->next)\n     {\n-      if (ods->proc_name != ns->proc_name)\n+      if (ods->proc_name != NULL\n+\t  && ods->proc_name != ns->proc_name)\n \tgfc_error (\"!$OMP DECLARE SIMD should refer to containing procedure \"\n \t\t   \"%qs at %L\", ns->proc_name->name, &ods->where);\n       if (ods->clauses)"}, {"sha": "ec1d0d692bf0df6191433d58dfac2b48b2cd2990", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 101, "deletions": 7, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c3a85be96585374bf95c981ba2f602667cf5b7/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c3a85be96585374bf95c981ba2f602667cf5b7/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=b4c3a85be96585374bf95c981ba2f602667cf5b7", "patch": "@@ -836,7 +836,7 @@ decode_omp_directive (void)\n       break;\n     case 'e':\n       matcho (\"end atomic\", gfc_match_omp_eos, ST_OMP_END_ATOMIC);\n-      matcho (\"end critical\", gfc_match_omp_critical, ST_OMP_END_CRITICAL);\n+      matcho (\"end critical\", gfc_match_omp_end_critical, ST_OMP_END_CRITICAL);\n       matchs (\"end distribute parallel do simd\", gfc_match_omp_eos,\n \t      ST_OMP_END_DISTRIBUTE_PARALLEL_DO_SIMD);\n       matcho (\"end distribute parallel do\", gfc_match_omp_eos,\n@@ -860,6 +860,13 @@ decode_omp_directive (void)\n       matcho (\"end sections\", gfc_match_omp_end_nowait, ST_OMP_END_SECTIONS);\n       matcho (\"end single\", gfc_match_omp_end_single, ST_OMP_END_SINGLE);\n       matcho (\"end target data\", gfc_match_omp_eos, ST_OMP_END_TARGET_DATA);\n+      matchs (\"end target parallel do simd\", gfc_match_omp_eos,\n+\t      ST_OMP_END_TARGET_PARALLEL_DO_SIMD);\n+      matcho (\"end target parallel do\", gfc_match_omp_eos,\n+\t      ST_OMP_END_TARGET_PARALLEL_DO);\n+      matcho (\"end target parallel\", gfc_match_omp_eos,\n+\t      ST_OMP_END_TARGET_PARALLEL);\n+      matchs (\"end target simd\", gfc_match_omp_eos, ST_OMP_END_TARGET_SIMD);\n       matchs (\"end target teams distribute parallel do simd\",\n \t      gfc_match_omp_eos,\n \t      ST_OMP_END_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD);\n@@ -872,6 +879,9 @@ decode_omp_directive (void)\n       matcho (\"end target teams\", gfc_match_omp_eos, ST_OMP_END_TARGET_TEAMS);\n       matcho (\"end target\", gfc_match_omp_eos, ST_OMP_END_TARGET);\n       matcho (\"end taskgroup\", gfc_match_omp_eos, ST_OMP_END_TASKGROUP);\n+      matchs (\"end taskloop simd\", gfc_match_omp_eos,\n+\t      ST_OMP_END_TASKLOOP_SIMD);\n+      matcho (\"end taskloop\", gfc_match_omp_eos, ST_OMP_END_TASKLOOP);\n       matcho (\"end task\", gfc_match_omp_eos, ST_OMP_END_TASK);\n       matchs (\"end teams distribute parallel do simd\", gfc_match_omp_eos,\n \t      ST_OMP_END_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD);\n@@ -892,7 +902,14 @@ decode_omp_directive (void)\n       matcho (\"master\", gfc_match_omp_master, ST_OMP_MASTER);\n       break;\n     case 'o':\n-      matcho (\"ordered\", gfc_match_omp_ordered, ST_OMP_ORDERED);\n+      if (flag_openmp && gfc_match (\"ordered depend (\") == MATCH_YES)\n+\t{\n+\t  gfc_current_locus = old_locus;\n+\t  matcho (\"ordered\", gfc_match_omp_ordered_depend,\n+\t\t  ST_OMP_ORDERED_DEPEND);\n+\t}\n+      else\n+\tmatcho (\"ordered\", gfc_match_omp_ordered, ST_OMP_ORDERED);\n       break;\n     case 'p':\n       matchs (\"parallel do simd\", gfc_match_omp_parallel_do_simd,\n@@ -912,6 +929,17 @@ decode_omp_directive (void)\n       break;\n     case 't':\n       matcho (\"target data\", gfc_match_omp_target_data, ST_OMP_TARGET_DATA);\n+      matcho (\"target enter data\", gfc_match_omp_target_enter_data,\n+\t      ST_OMP_TARGET_ENTER_DATA);\n+      matcho (\"target exit data\", gfc_match_omp_target_exit_data,\n+\t      ST_OMP_TARGET_EXIT_DATA);\n+      matchs (\"target parallel do simd\", gfc_match_omp_target_parallel_do_simd,\n+\t      ST_OMP_TARGET_PARALLEL_DO_SIMD);\n+      matcho (\"target parallel do\", gfc_match_omp_target_parallel_do,\n+\t      ST_OMP_TARGET_PARALLEL_DO);\n+      matcho (\"target parallel\", gfc_match_omp_target_parallel,\n+\t      ST_OMP_TARGET_PARALLEL);\n+      matchs (\"target simd\", gfc_match_omp_target_simd, ST_OMP_TARGET_SIMD);\n       matchs (\"target teams distribute parallel do simd\",\n \t      gfc_match_omp_target_teams_distribute_parallel_do_simd,\n \t      ST_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD);\n@@ -928,6 +956,9 @@ decode_omp_directive (void)\n \t      ST_OMP_TARGET_UPDATE);\n       matcho (\"target\", gfc_match_omp_target, ST_OMP_TARGET);\n       matcho (\"taskgroup\", gfc_match_omp_taskgroup, ST_OMP_TASKGROUP);\n+      matchs (\"taskloop simd\", gfc_match_omp_taskloop_simd,\n+\t      ST_OMP_TASKLOOP_SIMD);\n+      matcho (\"taskloop\", gfc_match_omp_taskloop, ST_OMP_TASKLOOP);\n       matcho (\"taskwait\", gfc_match_omp_taskwait, ST_OMP_TASKWAIT);\n       matcho (\"taskyield\", gfc_match_omp_taskyield, ST_OMP_TASKYIELD);\n       matcho (\"task\", gfc_match_omp_task, ST_OMP_TASK);\n@@ -1423,7 +1454,9 @@ next_statement (void)\n   case ST_LABEL_ASSIGNMENT: case ST_FLUSH: case ST_OMP_FLUSH: \\\n   case ST_OMP_BARRIER: case ST_OMP_TASKWAIT: case ST_OMP_TASKYIELD: \\\n   case ST_OMP_CANCEL: case ST_OMP_CANCELLATION_POINT: \\\n-  case ST_OMP_TARGET_UPDATE: case ST_ERROR_STOP: case ST_SYNC_ALL: \\\n+  case ST_OMP_TARGET_UPDATE: case ST_OMP_TARGET_ENTER_DATA: \\\n+  case ST_OMP_TARGET_EXIT_DATA: case ST_OMP_ORDERED_DEPEND: \\\n+  case ST_ERROR_STOP: case ST_SYNC_ALL: \\\n   case ST_SYNC_IMAGES: case ST_SYNC_MEMORY: case ST_LOCK: case ST_UNLOCK: \\\n   case ST_EVENT_POST: case ST_EVENT_WAIT: \\\n   case ST_OACC_UPDATE: case ST_OACC_WAIT: case ST_OACC_CACHE: \\\n@@ -1451,7 +1484,9 @@ next_statement (void)\n   case ST_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO: \\\n   case ST_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD: case ST_OMP_DISTRIBUTE: \\\n   case ST_OMP_DISTRIBUTE_SIMD: case ST_OMP_DISTRIBUTE_PARALLEL_DO: \\\n-  case ST_OMP_DISTRIBUTE_PARALLEL_DO_SIMD: \\\n+  case ST_OMP_DISTRIBUTE_PARALLEL_DO_SIMD: case ST_OMP_TARGET_PARALLEL: \\\n+  case ST_OMP_TARGET_PARALLEL_DO: case ST_OMP_TARGET_PARALLEL_DO_SIMD: \\\n+  case ST_OMP_TARGET_SIMD: case ST_OMP_TASKLOOP: case ST_OMP_TASKLOOP_SIMD: \\\n   case ST_CRITICAL: \\\n   case ST_OACC_PARALLEL_LOOP: case ST_OACC_PARALLEL: case ST_OACC_KERNELS: \\\n   case ST_OACC_DATA: case ST_OACC_HOST_DATA: case ST_OACC_LOOP: \\\n@@ -2158,6 +2193,18 @@ gfc_ascii_statement (gfc_statement st)\n     case ST_OMP_END_TARGET_DATA:\n       p = \"!$OMP END TARGET DATA\";\n       break;\n+    case ST_OMP_END_TARGET_PARALLEL:\n+      p = \"!$OMP END TARGET PARALLEL\";\n+      break;\n+    case ST_OMP_END_TARGET_PARALLEL_DO:\n+      p = \"!$OMP END TARGET PARALLEL DO\";\n+      break;\n+    case ST_OMP_END_TARGET_PARALLEL_DO_SIMD:\n+      p = \"!$OMP END TARGET PARALLEL DO SIMD\";\n+      break;\n+    case ST_OMP_END_TARGET_SIMD:\n+      p = \"!$OMP END TARGET SIMD\";\n+      break;\n     case ST_OMP_END_TARGET_TEAMS:\n       p = \"!$OMP END TARGET TEAMS\";\n       break;\n@@ -2176,6 +2223,12 @@ gfc_ascii_statement (gfc_statement st)\n     case ST_OMP_END_TASKGROUP:\n       p = \"!$OMP END TASKGROUP\";\n       break;\n+    case ST_OMP_END_TASKLOOP:\n+      p = \"!$OMP END TASKLOOP\";\n+      break;\n+    case ST_OMP_END_TASKLOOP_SIMD:\n+      p = \"!$OMP END TASKLOOP SIMD\";\n+      break;\n     case ST_OMP_END_TEAMS:\n       p = \"!$OMP END TEAMS\";\n       break;\n@@ -2201,6 +2254,7 @@ gfc_ascii_statement (gfc_statement st)\n       p = \"!$OMP MASTER\";\n       break;\n     case ST_OMP_ORDERED:\n+    case ST_OMP_ORDERED_DEPEND:\n       p = \"!$OMP ORDERED\";\n       break;\n     case ST_OMP_PARALLEL:\n@@ -2236,6 +2290,24 @@ gfc_ascii_statement (gfc_statement st)\n     case ST_OMP_TARGET_DATA:\n       p = \"!$OMP TARGET DATA\";\n       break;\n+    case ST_OMP_TARGET_ENTER_DATA:\n+      p = \"!$OMP TARGET ENTER DATA\";\n+      break;\n+    case ST_OMP_TARGET_EXIT_DATA:\n+      p = \"!$OMP TARGET EXIT DATA\";\n+      break;\n+    case ST_OMP_TARGET_PARALLEL:\n+      p = \"!$OMP TARGET PARALLEL\";\n+      break;\n+    case ST_OMP_TARGET_PARALLEL_DO:\n+      p = \"!$OMP TARGET PARALLEL DO\";\n+      break;\n+    case ST_OMP_TARGET_PARALLEL_DO_SIMD:\n+      p = \"!$OMP TARGET PARALLEL DO SIMD\";\n+      break;\n+    case ST_OMP_TARGET_SIMD:\n+      p = \"!$OMP TARGET SIMD\";\n+      break;\n     case ST_OMP_TARGET_TEAMS:\n       p = \"!$OMP TARGET TEAMS\";\n       break;\n@@ -2260,6 +2332,12 @@ gfc_ascii_statement (gfc_statement st)\n     case ST_OMP_TASKGROUP:\n       p = \"!$OMP TASKGROUP\";\n       break;\n+    case ST_OMP_TASKLOOP:\n+      p = \"!$OMP TASKLOOP\";\n+      break;\n+    case ST_OMP_TASKLOOP_SIMD:\n+      p = \"!$OMP TASKLOOP SIMD\";\n+      break;\n     case ST_OMP_TASKWAIT:\n       p = \"!$OMP TASKWAIT\";\n       break;\n@@ -4660,6 +4738,13 @@ parse_omp_do (gfc_statement omp_st)\n       omp_end_st = ST_OMP_END_PARALLEL_DO_SIMD;\n       break;\n     case ST_OMP_SIMD: omp_end_st = ST_OMP_END_SIMD; break;\n+    case ST_OMP_TARGET_PARALLEL_DO:\n+      omp_end_st = ST_OMP_END_TARGET_PARALLEL_DO;\n+      break;\n+    case ST_OMP_TARGET_PARALLEL_DO_SIMD:\n+      omp_end_st = ST_OMP_END_TARGET_PARALLEL_DO_SIMD;\n+      break;\n+    case ST_OMP_TARGET_SIMD: omp_end_st = ST_OMP_END_TARGET_SIMD; break;\n     case ST_OMP_TARGET_TEAMS_DISTRIBUTE:\n       omp_end_st = ST_OMP_END_TARGET_TEAMS_DISTRIBUTE;\n       break;\n@@ -4672,6 +4757,8 @@ parse_omp_do (gfc_statement omp_st)\n     case ST_OMP_TARGET_TEAMS_DISTRIBUTE_SIMD:\n       omp_end_st = ST_OMP_END_TARGET_TEAMS_DISTRIBUTE_SIMD;\n       break;\n+    case ST_OMP_TASKLOOP: omp_end_st = ST_OMP_END_TASKLOOP; break;\n+    case ST_OMP_TASKLOOP_SIMD: omp_end_st = ST_OMP_END_TASKLOOP_SIMD; break;\n     case ST_OMP_TEAMS_DISTRIBUTE:\n       omp_end_st = ST_OMP_END_TEAMS_DISTRIBUTE;\n       break;\n@@ -5081,13 +5168,15 @@ parse_omp_structured_block (gfc_statement omp_st, bool workshare_stmts_only)\n     case EXEC_OMP_END_NOWAIT:\n       cp->ext.omp_clauses->nowait |= new_st.ext.omp_bool;\n       break;\n-    case EXEC_OMP_CRITICAL:\n-      if (((cp->ext.omp_name == NULL) ^ (new_st.ext.omp_name == NULL))\n+    case EXEC_OMP_END_CRITICAL:\n+      if (((cp->ext.omp_clauses == NULL) ^ (new_st.ext.omp_name == NULL))\n \t  || (new_st.ext.omp_name != NULL\n-\t      && strcmp (cp->ext.omp_name, new_st.ext.omp_name) != 0))\n+\t      && strcmp (cp->ext.omp_clauses->critical_name,\n+\t\t\t new_st.ext.omp_name) != 0))\n \tgfc_error (\"Name after !$omp critical and !$omp end critical does \"\n \t\t   \"not match at %C\");\n       free (CONST_CAST (char *, new_st.ext.omp_name));\n+      new_st.ext.omp_name = NULL;\n       break;\n     case EXEC_OMP_END_SINGLE:\n       cp->ext.omp_clauses->lists[OMP_LIST_COPYPRIVATE]\n@@ -5230,6 +5319,7 @@ parse_executable (gfc_statement st)\n \tcase ST_OMP_SINGLE:\n \tcase ST_OMP_TARGET:\n \tcase ST_OMP_TARGET_DATA:\n+\tcase ST_OMP_TARGET_PARALLEL:\n \tcase ST_OMP_TARGET_TEAMS:\n \tcase ST_OMP_TEAMS:\n \tcase ST_OMP_TASK:\n@@ -5251,10 +5341,14 @@ parse_executable (gfc_statement st)\n \tcase ST_OMP_PARALLEL_DO:\n \tcase ST_OMP_PARALLEL_DO_SIMD:\n \tcase ST_OMP_SIMD:\n+\tcase ST_OMP_TARGET_PARALLEL_DO:\n+\tcase ST_OMP_TARGET_PARALLEL_DO_SIMD:\n \tcase ST_OMP_TARGET_TEAMS_DISTRIBUTE:\n \tcase ST_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO:\n \tcase ST_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD:\n \tcase ST_OMP_TARGET_TEAMS_DISTRIBUTE_SIMD:\n+\tcase ST_OMP_TASKLOOP:\n+\tcase ST_OMP_TASKLOOP_SIMD:\n \tcase ST_OMP_TEAMS_DISTRIBUTE:\n \tcase ST_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO:\n \tcase ST_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD:"}, {"sha": "faf7dde41831abeafed0d59306282dd665b15a5a", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c3a85be96585374bf95c981ba2f602667cf5b7/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c3a85be96585374bf95c981ba2f602667cf5b7/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=b4c3a85be96585374bf95c981ba2f602667cf5b7", "patch": "@@ -9821,6 +9821,12 @@ gfc_resolve_blocks (gfc_code *b, gfc_namespace *ns)\n \tcase EXEC_OMP_SINGLE:\n \tcase EXEC_OMP_TARGET:\n \tcase EXEC_OMP_TARGET_DATA:\n+\tcase EXEC_OMP_TARGET_ENTER_DATA:\n+\tcase EXEC_OMP_TARGET_EXIT_DATA:\n+\tcase EXEC_OMP_TARGET_PARALLEL:\n+\tcase EXEC_OMP_TARGET_PARALLEL_DO:\n+\tcase EXEC_OMP_TARGET_PARALLEL_DO_SIMD:\n+\tcase EXEC_OMP_TARGET_SIMD:\n \tcase EXEC_OMP_TARGET_TEAMS:\n \tcase EXEC_OMP_TARGET_TEAMS_DISTRIBUTE:\n \tcase EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO:\n@@ -9829,6 +9835,8 @@ gfc_resolve_blocks (gfc_code *b, gfc_namespace *ns)\n \tcase EXEC_OMP_TARGET_UPDATE:\n \tcase EXEC_OMP_TASK:\n \tcase EXEC_OMP_TASKGROUP:\n+\tcase EXEC_OMP_TASKLOOP:\n+\tcase EXEC_OMP_TASKLOOP_SIMD:\n \tcase EXEC_OMP_TASKWAIT:\n \tcase EXEC_OMP_TASKYIELD:\n \tcase EXEC_OMP_TEAMS:\n@@ -10744,6 +10752,9 @@ gfc_resolve_code (gfc_code *code, gfc_namespace *ns)\n \t    case EXEC_OMP_PARALLEL_DO:\n \t    case EXEC_OMP_PARALLEL_DO_SIMD:\n \t    case EXEC_OMP_PARALLEL_SECTIONS:\n+\t    case EXEC_OMP_TARGET_PARALLEL:\n+\t    case EXEC_OMP_TARGET_PARALLEL_DO:\n+\t    case EXEC_OMP_TARGET_PARALLEL_DO_SIMD:\n \t    case EXEC_OMP_TARGET_TEAMS:\n \t    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE:\n \t    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO:\n@@ -10764,6 +10775,9 @@ gfc_resolve_code (gfc_code *code, gfc_namespace *ns)\n \t    case EXEC_OMP_DO:\n \t    case EXEC_OMP_DO_SIMD:\n \t    case EXEC_OMP_SIMD:\n+\t    case EXEC_OMP_TARGET_SIMD:\n+\t    case EXEC_OMP_TASKLOOP:\n+\t    case EXEC_OMP_TASKLOOP_SIMD:\n \t      gfc_resolve_omp_do_blocks (code, ns);\n \t      break;\n \t    case EXEC_SELECT_TYPE:\n@@ -11159,6 +11173,12 @@ gfc_resolve_code (gfc_code *code, gfc_namespace *ns)\n \tcase EXEC_OMP_SINGLE:\n \tcase EXEC_OMP_TARGET:\n \tcase EXEC_OMP_TARGET_DATA:\n+\tcase EXEC_OMP_TARGET_ENTER_DATA:\n+\tcase EXEC_OMP_TARGET_EXIT_DATA:\n+\tcase EXEC_OMP_TARGET_PARALLEL:\n+\tcase EXEC_OMP_TARGET_PARALLEL_DO:\n+\tcase EXEC_OMP_TARGET_PARALLEL_DO_SIMD:\n+\tcase EXEC_OMP_TARGET_SIMD:\n \tcase EXEC_OMP_TARGET_TEAMS:\n \tcase EXEC_OMP_TARGET_TEAMS_DISTRIBUTE:\n \tcase EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO:\n@@ -11167,6 +11187,8 @@ gfc_resolve_code (gfc_code *code, gfc_namespace *ns)\n \tcase EXEC_OMP_TARGET_UPDATE:\n \tcase EXEC_OMP_TASK:\n \tcase EXEC_OMP_TASKGROUP:\n+\tcase EXEC_OMP_TASKLOOP:\n+\tcase EXEC_OMP_TASKLOOP_SIMD:\n \tcase EXEC_OMP_TASKWAIT:\n \tcase EXEC_OMP_TASKYIELD:\n \tcase EXEC_OMP_TEAMS:"}, {"sha": "9af58fc1dce406d2cd094481982f564de83f9d3b", "filename": "gcc/fortran/st.c", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c3a85be96585374bf95c981ba2f602667cf5b7/gcc%2Ffortran%2Fst.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c3a85be96585374bf95c981ba2f602667cf5b7/gcc%2Ffortran%2Fst.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fst.c?ref=b4c3a85be96585374bf95c981ba2f602667cf5b7", "patch": "@@ -207,40 +207,50 @@ gfc_free_statement (gfc_code *p)\n     case EXEC_OACC_ROUTINE:\n     case EXEC_OMP_CANCEL:\n     case EXEC_OMP_CANCELLATION_POINT:\n+    case EXEC_OMP_CRITICAL:\n     case EXEC_OMP_DISTRIBUTE:\n     case EXEC_OMP_DISTRIBUTE_PARALLEL_DO:\n     case EXEC_OMP_DISTRIBUTE_PARALLEL_DO_SIMD:\n     case EXEC_OMP_DISTRIBUTE_SIMD:\n     case EXEC_OMP_DO:\n     case EXEC_OMP_DO_SIMD:\n     case EXEC_OMP_END_SINGLE:\n+    case EXEC_OMP_ORDERED:\n     case EXEC_OMP_PARALLEL:\n     case EXEC_OMP_PARALLEL_DO:\n     case EXEC_OMP_PARALLEL_DO_SIMD:\n     case EXEC_OMP_PARALLEL_SECTIONS:\n+    case EXEC_OMP_PARALLEL_WORKSHARE:\n     case EXEC_OMP_SECTIONS:\n     case EXEC_OMP_SIMD:\n     case EXEC_OMP_SINGLE:\n     case EXEC_OMP_TARGET:\n     case EXEC_OMP_TARGET_DATA:\n+    case EXEC_OMP_TARGET_ENTER_DATA:\n+    case EXEC_OMP_TARGET_EXIT_DATA:\n+    case EXEC_OMP_TARGET_PARALLEL:\n+    case EXEC_OMP_TARGET_PARALLEL_DO:\n+    case EXEC_OMP_TARGET_PARALLEL_DO_SIMD:\n+    case EXEC_OMP_TARGET_SIMD:\n     case EXEC_OMP_TARGET_TEAMS:\n     case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE:\n     case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO:\n     case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD:\n     case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_SIMD:\n     case EXEC_OMP_TARGET_UPDATE:\n     case EXEC_OMP_TASK:\n+    case EXEC_OMP_TASKLOOP:\n+    case EXEC_OMP_TASKLOOP_SIMD:\n     case EXEC_OMP_TEAMS:\n     case EXEC_OMP_TEAMS_DISTRIBUTE:\n     case EXEC_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO:\n     case EXEC_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD:\n     case EXEC_OMP_TEAMS_DISTRIBUTE_SIMD:\n     case EXEC_OMP_WORKSHARE:\n-    case EXEC_OMP_PARALLEL_WORKSHARE:\n       gfc_free_omp_clauses (p->ext.omp_clauses);\n       break;\n \n-    case EXEC_OMP_CRITICAL:\n+    case EXEC_OMP_END_CRITICAL:\n       free (CONST_CAST (char *, p->ext.omp_name));\n       break;\n \n@@ -252,7 +262,6 @@ gfc_free_statement (gfc_code *p)\n     case EXEC_OMP_ATOMIC:\n     case EXEC_OMP_BARRIER:\n     case EXEC_OMP_MASTER:\n-    case EXEC_OMP_ORDERED:\n     case EXEC_OMP_END_NOWAIT:\n     case EXEC_OMP_TASKGROUP:\n     case EXEC_OMP_TASKWAIT:"}, {"sha": "0b711ca20b4b0fe3e4348ee719b0e4e6444543d1", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c3a85be96585374bf95c981ba2f602667cf5b7/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c3a85be96585374bf95c981ba2f602667cf5b7/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=b4c3a85be96585374bf95c981ba2f602667cf5b7", "patch": "@@ -385,6 +385,7 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n     *contiguous = \"CONTIGUOUS\", *generic = \"GENERIC\", *automatic = \"AUTOMATIC\";\n   static const char *threadprivate = \"THREADPRIVATE\";\n   static const char *omp_declare_target = \"OMP DECLARE TARGET\";\n+  static const char *omp_declare_target_link = \"OMP DECLARE TARGET LINK\";\n   static const char *oacc_declare_copyin = \"OACC DECLARE COPYIN\";\n   static const char *oacc_declare_create = \"OACC DECLARE CREATE\";\n   static const char *oacc_declare_deviceptr = \"OACC DECLARE DEVICEPTR\";\n@@ -482,6 +483,7 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n   conf (dummy, intrinsic);\n   conf (dummy, threadprivate);\n   conf (dummy, omp_declare_target);\n+  conf (dummy, omp_declare_target_link);\n   conf (pointer, target);\n   conf (pointer, intrinsic);\n   conf (pointer, elemental);\n@@ -532,6 +534,7 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n   conf (in_equivalence, allocatable);\n   conf (in_equivalence, threadprivate);\n   conf (in_equivalence, omp_declare_target);\n+  conf (in_equivalence, omp_declare_target_link);\n   conf (in_equivalence, oacc_declare_create);\n   conf (in_equivalence, oacc_declare_copyin);\n   conf (in_equivalence, oacc_declare_deviceptr);\n@@ -540,6 +543,8 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n   conf (dummy, result);\n   conf (entry, result);\n   conf (generic, result);\n+  conf (generic, omp_declare_target);\n+  conf (generic, omp_declare_target_link);\n \n   conf (function, subroutine);\n \n@@ -585,6 +590,7 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n   conf (cray_pointee, in_equivalence);\n   conf (cray_pointee, threadprivate);\n   conf (cray_pointee, omp_declare_target);\n+  conf (cray_pointee, omp_declare_target_link);\n   conf (cray_pointee, oacc_declare_create);\n   conf (cray_pointee, oacc_declare_copyin);\n   conf (cray_pointee, oacc_declare_deviceptr);\n@@ -641,8 +647,11 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n   conf (procedure, entry)\n \n   conf (proc_pointer, abstract)\n+  conf (proc_pointer, omp_declare_target)\n+  conf (proc_pointer, omp_declare_target_link)\n \n   conf (entry, omp_declare_target)\n+  conf (entry, omp_declare_target_link)\n   conf (entry, oacc_declare_create)\n   conf (entry, oacc_declare_copyin)\n   conf (entry, oacc_declare_deviceptr)\n@@ -684,6 +693,7 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n       conf2 (subroutine);\n       conf2 (threadprivate);\n       conf2 (omp_declare_target);\n+      conf2 (omp_declare_target_link);\n       conf2 (oacc_declare_create);\n       conf2 (oacc_declare_copyin);\n       conf2 (oacc_declare_deviceptr);\n@@ -734,6 +744,8 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n       if (!attr->proc_pointer)\n \tconf2 (in_common);\n \n+      conf2 (omp_declare_target_link);\n+\n       switch (attr->proc)\n \t{\n \tcase PROC_ST_FUNCTION:\n@@ -770,6 +782,7 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n       conf2 (threadprivate);\n       conf2 (result);\n       conf2 (omp_declare_target);\n+      conf2 (omp_declare_target_link);\n       conf2 (oacc_declare_create);\n       conf2 (oacc_declare_copyin);\n       conf2 (oacc_declare_deviceptr);\n@@ -1299,6 +1312,22 @@ gfc_add_omp_declare_target (symbol_attribute *attr, const char *name,\n }\n \n \n+bool\n+gfc_add_omp_declare_target_link (symbol_attribute *attr, const char *name,\n+\t\t\t\t locus *where)\n+{\n+\n+  if (check_used (attr, name, where))\n+    return false;\n+\n+  if (attr->omp_declare_target_link)\n+    return true;\n+\n+  attr->omp_declare_target_link = 1;\n+  return check_conflict (attr, name, where);\n+}\n+\n+\n bool\n gfc_add_oacc_declare_create (symbol_attribute *attr, const char *name,\n \t\t\t     locus *where)\n@@ -1938,6 +1967,9 @@ gfc_copy_attr (symbol_attribute *dest, symbol_attribute *src, locus *where)\n   if (src->omp_declare_target\n       && !gfc_add_omp_declare_target (dest, NULL, where))\n     goto fail;\n+  if (src->omp_declare_target_link\n+      && !gfc_add_omp_declare_target_link (dest, NULL, where))\n+    goto fail;\n   if (src->oacc_declare_create\n       && !gfc_add_oacc_declare_create (dest, NULL, where))\n     goto fail;"}, {"sha": "cd06e154ef31bcf2363a9bc3d0c3e5450ab6546a", "filename": "gcc/fortran/trans-common.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c3a85be96585374bf95c981ba2f602667cf5b7/gcc%2Ffortran%2Ftrans-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c3a85be96585374bf95c981ba2f602667cf5b7/gcc%2Ffortran%2Ftrans-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-common.c?ref=b4c3a85be96585374bf95c981ba2f602667cf5b7", "patch": "@@ -457,7 +457,11 @@ build_common_decl (gfc_common_head *com, tree union_type, bool is_init)\n       if (com->threadprivate)\n \tset_decl_tls_model (decl, decl_default_tls_model (decl));\n \n-      if (com->omp_declare_target)\n+      if (com->omp_declare_target_link)\n+\tDECL_ATTRIBUTES (decl)\n+\t  = tree_cons (get_identifier (\"omp declare target link\"),\n+\t\t       NULL_TREE, DECL_ATTRIBUTES (decl));\n+      else if (com->omp_declare_target)\n \tDECL_ATTRIBUTES (decl)\n \t  = tree_cons (get_identifier (\"omp declare target\"),\n \t\t       NULL_TREE, DECL_ATTRIBUTES (decl));"}, {"sha": "7c9730c7a859be2c63c7cc6619a15cac3f6858a4", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c3a85be96585374bf95c981ba2f602667cf5b7/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c3a85be96585374bf95c981ba2f602667cf5b7/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=b4c3a85be96585374bf95c981ba2f602667cf5b7", "patch": "@@ -1376,7 +1376,10 @@ add_attributes_to_decl (symbol_attribute sym_attr, tree list)\n \tlist = chainon (list, attr);\n       }\n \n-  if (sym_attr.omp_declare_target)\n+  if (sym_attr.omp_declare_target_link)\n+    list = tree_cons (get_identifier (\"omp declare target link\"),\n+\t\t      NULL_TREE, list);\n+  else if (sym_attr.omp_declare_target)\n     list = tree_cons (get_identifier (\"omp declare target\"),\n \t\t      NULL_TREE, list);\n "}, {"sha": "59fd6b3e6a00615b33116d9b31d3d8b5139abe8a", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 624, "deletions": 54, "changes": 678, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c3a85be96585374bf95c981ba2f602667cf5b7/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c3a85be96585374bf95c981ba2f602667cf5b7/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=b4c3a85be96585374bf95c981ba2f602667cf5b7", "patch": "@@ -1140,6 +1140,34 @@ gfc_omp_finish_clause (tree c, gimple_seq *pre_p)\n }\n \n \n+/* Return true if DECL is a scalar variable (for the purpose of\n+   implicit firstprivatization).  */\n+\n+bool\n+gfc_omp_scalar_p (tree decl)\n+{\n+  tree type = TREE_TYPE (decl);\n+  if (TREE_CODE (type) == REFERENCE_TYPE)\n+    type = TREE_TYPE (type);\n+  if (TREE_CODE (type) == POINTER_TYPE)\n+    {\n+      if (GFC_DECL_GET_SCALAR_ALLOCATABLE (decl)\n+\t  || GFC_DECL_GET_SCALAR_POINTER (decl))\n+\ttype = TREE_TYPE (type);\n+      if (GFC_ARRAY_TYPE_P (type)\n+\t  || GFC_CLASS_TYPE_P (type))\n+\treturn false;\n+    }\n+  if (TYPE_STRING_FLAG (type))\n+    return false;\n+  if (INTEGRAL_TYPE_P (type)\n+      || SCALAR_FLOAT_TYPE_P (type)\n+      || COMPLEX_FLOAT_TYPE_P (type))\n+    return true;\n+  return false;\n+}\n+\n+\n /* Return true if DECL's DECL_VALUE_EXPR (if any) should be\n    disregarded in OpenMP construct, because it is going to be\n    remapped during OpenMP lowering.  SHARED is true if DECL\n@@ -1727,12 +1755,14 @@ gfc_convert_expr_to_tree (stmtblock_t *block, gfc_expr *expr)\n   return result;\n }\n \n+static vec<tree, va_heap, vl_embed> *doacross_steps;\n+\n static tree\n gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t\t       locus where, bool declare_simd = false)\n {\n   tree omp_clauses = NULL_TREE, chunk_size, c;\n-  int list;\n+  int list, ifc;\n   enum omp_clause_code clause_code;\n   gfc_se se;\n \n@@ -1775,8 +1805,12 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t  clause_code = OMP_CLAUSE_UNIFORM;\n \t  goto add_clause;\n \tcase OMP_LIST_USE_DEVICE:\n+\tcase OMP_LIST_USE_DEVICE_PTR:\n \t  clause_code = OMP_CLAUSE_USE_DEVICE_PTR;\n \t  goto add_clause;\n+\tcase OMP_LIST_IS_DEVICE_PTR:\n+\t  clause_code = OMP_CLAUSE_IS_DEVICE_PTR;\n+\t  goto add_clause;\n \n \tadd_clause:\n \t  omp_clauses\n@@ -1797,7 +1831,7 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t\t      {\n \t\t\ttree alignment_var;\n \n-\t\t\tif (block == NULL)\n+\t\t\tif (declare_simd)\n \t\t\t  alignment_var = gfc_conv_constant_to_tree (n->expr);\n \t\t\telse\n \t\t\t  {\n@@ -1817,13 +1851,15 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t  {\n \t    gfc_expr *last_step_expr = NULL;\n \t    tree last_step = NULL_TREE;\n+\t    bool last_step_parm = false;\n \n \t    for (; n != NULL; n = n->next)\n \t      {\n \t\tif (n->expr)\n \t\t  {\n \t\t    last_step_expr = n->expr;\n \t\t    last_step = NULL_TREE;\n+\t\t    last_step_parm = false;\n \t\t  }\n \t\tif (n->sym->attr.referenced || declare_simd)\n \t\t  {\n@@ -1833,23 +1869,56 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t\t\ttree node = build_omp_clause (input_location,\n \t\t\t\t\t\t      OMP_CLAUSE_LINEAR);\n \t\t\tOMP_CLAUSE_DECL (node) = t;\n+\t\t\tomp_clause_linear_kind kind;\n+\t\t\tswitch (n->u.linear_op)\n+\t\t\t  {\n+\t\t\t  case OMP_LINEAR_DEFAULT:\n+\t\t\t    kind = OMP_CLAUSE_LINEAR_DEFAULT;\n+\t\t\t    break;\n+\t\t\t  case OMP_LINEAR_REF:\n+\t\t\t    kind = OMP_CLAUSE_LINEAR_REF;\n+\t\t\t    break;\n+\t\t\t  case OMP_LINEAR_VAL:\n+\t\t\t    kind = OMP_CLAUSE_LINEAR_VAL;\n+\t\t\t    break;\n+\t\t\t  case OMP_LINEAR_UVAL:\n+\t\t\t    kind = OMP_CLAUSE_LINEAR_UVAL;\n+\t\t\t    break;\n+\t\t\t  default:\n+\t\t\t    gcc_unreachable ();\n+\t\t\t  }\n+\t\t\tOMP_CLAUSE_LINEAR_KIND (node) = kind;\n \t\t\tif (last_step_expr && last_step == NULL_TREE)\n \t\t\t  {\n-\t\t\t    if (block == NULL)\n-\t\t\t      last_step\n-\t\t\t\t= gfc_conv_constant_to_tree (last_step_expr);\n-\t\t\t    else\n+\t\t\t    if (!declare_simd)\n \t\t\t      {\n \t\t\t\tgfc_init_se (&se, NULL);\n \t\t\t\tgfc_conv_expr (&se, last_step_expr);\n \t\t\t\tgfc_add_block_to_block (block, &se.pre);\n \t\t\t\tlast_step = gfc_evaluate_now (se.expr, block);\n \t\t\t\tgfc_add_block_to_block (block, &se.post);\n \t\t\t      }\n+\t\t\t    else if (last_step_expr->expr_type == EXPR_VARIABLE)\n+\t\t\t      {\n+\t\t\t\tgfc_symbol *s = last_step_expr->symtree->n.sym;\n+\t\t\t\tlast_step = gfc_trans_omp_variable (s, true);\n+\t\t\t\tlast_step_parm = true;\n+\t\t\t      }\n+\t\t\t    else\n+\t\t\t      last_step\n+\t\t\t\t= gfc_conv_constant_to_tree (last_step_expr);\n+\t\t\t  }\n+\t\t\tif (last_step_parm)\n+\t\t\t  {\n+\t\t\t    OMP_CLAUSE_LINEAR_VARIABLE_STRIDE (node) = 1;\n+\t\t\t    OMP_CLAUSE_LINEAR_STEP (node) = last_step;\n+\t\t\t  }\n+\t\t\telse\n+\t\t\t  {\n+\t\t\t    tree type = gfc_typenode_for_spec (&n->sym->ts);\n+\t\t\t    OMP_CLAUSE_LINEAR_STEP (node)\n+\t\t\t      = fold_convert (type, last_step);\n \t\t\t  }\n-\t\t\tOMP_CLAUSE_LINEAR_STEP (node)\n-\t\t\t  = fold_convert (gfc_typenode_for_spec (&n->sym->ts),\n-\t\t\t\t\t  last_step);\n \t\t\tif (n->sym->attr.dimension || n->sym->attr.allocatable)\n \t\t\t  OMP_CLAUSE_LINEAR_ARRAY (node) = 1;\n \t\t\tomp_clauses = gfc_trans_add_clause (node, omp_clauses);\n@@ -1861,6 +1930,57 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \tcase OMP_LIST_DEPEND:\n \t  for (; n != NULL; n = n->next)\n \t    {\n+\t      if (n->u.depend_op == OMP_DEPEND_SINK_FIRST)\n+\t\t{\n+\t\t  tree vec = NULL_TREE;\n+\t\t  unsigned int i;\n+\t\t  for (i = 0; ; i++)\n+\t\t    {\n+\t\t      tree addend = integer_zero_node, t;\n+\t\t      bool neg = false;\n+\t\t      if (n->expr)\n+\t\t\t{\n+\t\t\t  addend = gfc_conv_constant_to_tree (n->expr);\n+\t\t\t  if (TREE_CODE (addend) == INTEGER_CST\n+\t\t\t      && tree_int_cst_sgn (addend) == -1)\n+\t\t\t    {\n+\t\t\t      neg = true;\n+\t\t\t      addend = const_unop (NEGATE_EXPR,\n+\t\t\t\t\t\t   TREE_TYPE (addend), addend);\n+\t\t\t    }\n+\t\t\t}\n+\t\t      t = gfc_trans_omp_variable (n->sym, false);\n+\t\t      if (t != error_mark_node)\n+\t\t\t{\n+\t\t\t  if (i < vec_safe_length (doacross_steps)\n+\t\t\t      && !integer_zerop (addend)\n+\t\t\t      && (*doacross_steps)[i])\n+\t\t\t    {\n+\t\t\t      tree step = (*doacross_steps)[i];\n+\t\t\t      addend = fold_convert (TREE_TYPE (step), addend);\n+\t\t\t      addend = build2 (TRUNC_DIV_EXPR,\n+\t\t\t\t\t       TREE_TYPE (step), addend, step);\n+\t\t\t    }\n+\t\t\t  vec = tree_cons (addend, t, vec);\n+\t\t\t  if (neg)\n+\t\t\t    OMP_CLAUSE_DEPEND_SINK_NEGATIVE (vec) = 1;\n+\t\t\t}\n+\t\t      if (n->next == NULL\n+\t\t\t  || n->next->u.depend_op != OMP_DEPEND_SINK)\n+\t\t\tbreak;\n+\t\t      n = n->next;\n+\t\t    }\n+\t\t  if (vec == NULL_TREE)\n+\t\t    continue;\n+\n+\t\t  tree node = build_omp_clause (input_location,\n+\t\t\t\t\t\tOMP_CLAUSE_DEPEND);\n+\t\t  OMP_CLAUSE_DEPEND_KIND (node) = OMP_CLAUSE_DEPEND_SINK;\n+\t\t  OMP_CLAUSE_DECL (node) = nreverse (vec);\n+\t\t  omp_clauses = gfc_trans_add_clause (node, omp_clauses);\n+\t\t  continue;\n+\t\t}\n+\n \t      if (!n->sym->attr.referenced)\n \t\tcontinue;\n \n@@ -2120,6 +2240,18 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t\tcase OMP_MAP_TOFROM:\n \t\t  OMP_CLAUSE_SET_MAP_KIND (node, GOMP_MAP_TOFROM);\n \t\t  break;\n+\t\tcase OMP_MAP_ALWAYS_TO:\n+\t\t  OMP_CLAUSE_SET_MAP_KIND (node, GOMP_MAP_ALWAYS_TO);\n+\t\t  break;\n+\t\tcase OMP_MAP_ALWAYS_FROM:\n+\t\t  OMP_CLAUSE_SET_MAP_KIND (node, GOMP_MAP_ALWAYS_FROM);\n+\t\t  break;\n+\t\tcase OMP_MAP_ALWAYS_TOFROM:\n+\t\t  OMP_CLAUSE_SET_MAP_KIND (node, GOMP_MAP_ALWAYS_TOFROM);\n+\t\t  break;\n+\t\tcase OMP_MAP_RELEASE:\n+\t\t  OMP_CLAUSE_SET_MAP_KIND (node, GOMP_MAP_RELEASE);\n+\t\t  break;\n \t\tcase OMP_MAP_DELETE:\n \t\t  OMP_CLAUSE_SET_MAP_KIND (node, GOMP_MAP_DELETE);\n \t\t  break;\n@@ -2260,6 +2392,50 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n       OMP_CLAUSE_IF_EXPR (c) = if_var;\n       omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n     }\n+  for (ifc = 0; ifc < OMP_IF_LAST; ifc++)\n+    if (clauses->if_exprs[ifc])\n+      {\n+\ttree if_var;\n+\n+\tgfc_init_se (&se, NULL);\n+\tgfc_conv_expr (&se, clauses->if_exprs[ifc]);\n+\tgfc_add_block_to_block (block, &se.pre);\n+\tif_var = gfc_evaluate_now (se.expr, block);\n+\tgfc_add_block_to_block (block, &se.post);\n+\n+\tc = build_omp_clause (where.lb->location, OMP_CLAUSE_IF);\n+\tswitch (ifc)\n+\t  {\n+\t  case OMP_IF_PARALLEL:\n+\t    OMP_CLAUSE_IF_MODIFIER (c) = OMP_PARALLEL;\n+\t    break;\n+\t  case OMP_IF_TASK:\n+\t    OMP_CLAUSE_IF_MODIFIER (c) = OMP_TASK;\n+\t    break;\n+\t  case OMP_IF_TASKLOOP:\n+\t    OMP_CLAUSE_IF_MODIFIER (c) = OMP_TASKLOOP;\n+\t    break;\n+\t  case OMP_IF_TARGET:\n+\t    OMP_CLAUSE_IF_MODIFIER (c) = OMP_TARGET;\n+\t    break;\n+\t  case OMP_IF_TARGET_DATA:\n+\t    OMP_CLAUSE_IF_MODIFIER (c) = OMP_TARGET_DATA;\n+\t    break;\n+\t  case OMP_IF_TARGET_UPDATE:\n+\t    OMP_CLAUSE_IF_MODIFIER (c) = OMP_TARGET_UPDATE;\n+\t    break;\n+\t  case OMP_IF_TARGET_ENTER_DATA:\n+\t    OMP_CLAUSE_IF_MODIFIER (c) = OMP_TARGET_ENTER_DATA;\n+\t    break;\n+\t  case OMP_IF_TARGET_EXIT_DATA:\n+\t    OMP_CLAUSE_IF_MODIFIER (c) = OMP_TARGET_EXIT_DATA;\n+\t    break;\n+\t  default:\n+\t    gcc_unreachable ();\n+\t  }\n+\tOMP_CLAUSE_IF_EXPR (c) = if_var;\n+\tomp_clauses = gfc_trans_add_clause (c, omp_clauses);\n+      }\n \n   if (clauses->final_expr)\n     {\n@@ -2325,6 +2501,16 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n+      if (clauses->sched_monotonic)\n+\tOMP_CLAUSE_SCHEDULE_KIND (c)\n+\t  = (omp_clause_schedule_kind) (OMP_CLAUSE_SCHEDULE_KIND (c)\n+\t\t\t\t\t| OMP_CLAUSE_SCHEDULE_MONOTONIC);\n+      else if (clauses->sched_nonmonotonic)\n+\tOMP_CLAUSE_SCHEDULE_KIND (c)\n+\t  = (omp_clause_schedule_kind) (OMP_CLAUSE_SCHEDULE_KIND (c)\n+\t\t\t\t\t| OMP_CLAUSE_SCHEDULE_NONMONOTONIC);\n+      if (clauses->sched_simd)\n+\tOMP_CLAUSE_SCHEDULE_SIMD (c) = 1;\n       omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n     }\n \n@@ -2360,7 +2546,9 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n   if (clauses->ordered)\n     {\n       c = build_omp_clause (where.lb->location, OMP_CLAUSE_ORDERED);\n-      OMP_CLAUSE_ORDERED_EXPR (c) = NULL_TREE;\n+      OMP_CLAUSE_ORDERED_EXPR (c)\n+\t= clauses->orderedc ? build_int_cst (integer_type_node,\n+\t\t\t\t\t     clauses->orderedc) : NULL_TREE;\n       omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n     }\n \n@@ -2455,10 +2643,27 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \n   if (clauses->simdlen_expr)\n     {\n-      c = build_omp_clause (where.lb->location, OMP_CLAUSE_SIMDLEN);\n-      OMP_CLAUSE_SIMDLEN_EXPR (c)\n-\t= gfc_conv_constant_to_tree (clauses->simdlen_expr);\n-      omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n+      if (declare_simd)\n+\t{\n+\t  c = build_omp_clause (where.lb->location, OMP_CLAUSE_SIMDLEN);\n+\t  OMP_CLAUSE_SIMDLEN_EXPR (c)\n+\t    = gfc_conv_constant_to_tree (clauses->simdlen_expr);\n+\t  omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n+\t}\n+      else\n+\t{\n+\t  tree simdlen_var;\n+\n+\t  gfc_init_se (&se, NULL);\n+\t  gfc_conv_expr (&se, clauses->simdlen_expr);\n+\t  gfc_add_block_to_block (block, &se.pre);\n+\t  simdlen_var = gfc_evaluate_now (se.expr, block);\n+\t  gfc_add_block_to_block (block, &se.post);\n+\n+\t  c = build_omp_clause (where.lb->location, OMP_CLAUSE_SIMDLEN);\n+\t  OMP_CLAUSE_SIMDLEN_EXPR (c) = simdlen_var;\n+\t  omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n+\t}\n     }\n \n   if (clauses->num_teams)\n@@ -2523,6 +2728,93 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n       omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n     }\n \n+  if (clauses->grainsize)\n+    {\n+      tree grainsize;\n+\n+      gfc_init_se (&se, NULL);\n+      gfc_conv_expr (&se, clauses->grainsize);\n+      gfc_add_block_to_block (block, &se.pre);\n+      grainsize = gfc_evaluate_now (se.expr, block);\n+      gfc_add_block_to_block (block, &se.post);\n+\n+      c = build_omp_clause (where.lb->location, OMP_CLAUSE_GRAINSIZE);\n+      OMP_CLAUSE_GRAINSIZE_EXPR (c) = grainsize;\n+      omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n+    }\n+\n+  if (clauses->num_tasks)\n+    {\n+      tree num_tasks;\n+\n+      gfc_init_se (&se, NULL);\n+      gfc_conv_expr (&se, clauses->num_tasks);\n+      gfc_add_block_to_block (block, &se.pre);\n+      num_tasks = gfc_evaluate_now (se.expr, block);\n+      gfc_add_block_to_block (block, &se.post);\n+\n+      c = build_omp_clause (where.lb->location, OMP_CLAUSE_NUM_TASKS);\n+      OMP_CLAUSE_NUM_TASKS_EXPR (c) = num_tasks;\n+      omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n+    }\n+\n+  if (clauses->priority)\n+    {\n+      tree priority;\n+\n+      gfc_init_se (&se, NULL);\n+      gfc_conv_expr (&se, clauses->priority);\n+      gfc_add_block_to_block (block, &se.pre);\n+      priority = gfc_evaluate_now (se.expr, block);\n+      gfc_add_block_to_block (block, &se.post);\n+\n+      c = build_omp_clause (where.lb->location, OMP_CLAUSE_PRIORITY);\n+      OMP_CLAUSE_PRIORITY_EXPR (c) = priority;\n+      omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n+    }\n+\n+  if (clauses->hint)\n+    {\n+      tree hint;\n+\n+      gfc_init_se (&se, NULL);\n+      gfc_conv_expr (&se, clauses->hint);\n+      gfc_add_block_to_block (block, &se.pre);\n+      hint = gfc_evaluate_now (se.expr, block);\n+      gfc_add_block_to_block (block, &se.post);\n+\n+      c = build_omp_clause (where.lb->location, OMP_CLAUSE_HINT);\n+      OMP_CLAUSE_HINT_EXPR (c) = hint;\n+      omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n+    }\n+\n+  if (clauses->simd)\n+    {\n+      c = build_omp_clause (where.lb->location, OMP_CLAUSE_SIMD);\n+      omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n+    }\n+  if (clauses->threads)\n+    {\n+      c = build_omp_clause (where.lb->location, OMP_CLAUSE_THREADS);\n+      omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n+    }\n+  if (clauses->nogroup)\n+    {\n+      c = build_omp_clause (where.lb->location, OMP_CLAUSE_NOGROUP);\n+      omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n+    }\n+  if (clauses->defaultmap)\n+    {\n+      c = build_omp_clause (where.lb->location, OMP_CLAUSE_DEFAULTMAP);\n+      omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n+    }\n+  if (clauses->depend_source)\n+    {\n+      c = build_omp_clause (where.lb->location, OMP_CLAUSE_DEPEND);\n+      OMP_CLAUSE_DEPEND_KIND (c) = OMP_CLAUSE_DEPEND_SOURCE;\n+      omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n+    }\n+\n   if (clauses->async)\n     {\n       c = build_omp_clause (where.lb->location, OMP_CLAUSE_ASYNC);\n@@ -3135,8 +3427,8 @@ static tree\n gfc_trans_omp_critical (gfc_code *code)\n {\n   tree name = NULL_TREE, stmt;\n-  if (code->ext.omp_name != NULL)\n-    name = get_identifier (code->ext.omp_name);\n+  if (code->ext.omp_clauses != NULL)\n+    name = get_identifier (code->ext.omp_clauses->critical_name);\n   stmt = gfc_trans_code (code->block->next);\n   return build3_loc (input_location, OMP_CRITICAL, void_type_node, stmt,\n \t\t     NULL_TREE, name);\n@@ -3153,7 +3445,7 @@ gfc_trans_omp_do (gfc_code *code, gfc_exec_op op, stmtblock_t *pblock,\n \t\t  gfc_omp_clauses *do_clauses, tree par_clauses)\n {\n   gfc_se se;\n-  tree dovar, stmt, from, to, step, type, init, cond, incr;\n+  tree dovar, stmt, from, to, step, type, init, cond, incr, orig_decls;\n   tree count = NULL_TREE, cycle_label, tmp, omp_clauses;\n   stmtblock_t block;\n   stmtblock_t body;\n@@ -3162,7 +3454,11 @@ gfc_trans_omp_do (gfc_code *code, gfc_exec_op op, stmtblock_t *pblock,\n   vec<dovar_init> inits = vNULL;\n   dovar_init *di;\n   unsigned ix;\n+  vec<tree, va_heap, vl_embed> *saved_doacross_steps = doacross_steps;\n \n+  doacross_steps = NULL;\n+  if (clauses->orderedc)\n+    collapse = clauses->orderedc;\n   if (collapse <= 0)\n     collapse = 1;\n \n@@ -3172,13 +3468,19 @@ gfc_trans_omp_do (gfc_code *code, gfc_exec_op op, stmtblock_t *pblock,\n   init = make_tree_vec (collapse);\n   cond = make_tree_vec (collapse);\n   incr = make_tree_vec (collapse);\n+  orig_decls = clauses->orderedc ? make_tree_vec (collapse) : NULL_TREE;\n \n   if (pblock == NULL)\n     {\n       gfc_start_block (&block);\n       pblock = &block;\n     }\n \n+  /* simd schedule modifier is only useful for composite do simd and other\n+     constructs including that, where gfc_trans_omp_do is only called\n+     on the simd construct and DO's clauses are translated elsewhere.  */\n+  do_clauses->sched_simd = false;\n+\n   omp_clauses = gfc_trans_omp_clauses (pblock, do_clauses, code->loc);\n \n   for (i = 0; i < collapse; i++)\n@@ -3291,7 +3593,15 @@ gfc_trans_omp_do (gfc_code *code, gfc_exec_op op, stmtblock_t *pblock,\n \t  tmp = fold_build2_loc (input_location, PLUS_EXPR, type, from, tmp);\n \t  dovar_init e = {dovar, tmp};\n \t  inits.safe_push (e);\n+\t  if (clauses->orderedc)\n+\t    {\n+\t      if (doacross_steps == NULL)\n+\t\tvec_safe_grow_cleared (doacross_steps, clauses->orderedc);\n+\t      (*doacross_steps)[i] = step;\n+\t    }\n \t}\n+      if (orig_decls)\n+\tTREE_VEC_ELT (orig_decls, i) = dovar_decl;\n \n       if (dovar_found == 2\n \t  && op == EXEC_OMP_SIMD\n@@ -3338,9 +3648,24 @@ gfc_trans_omp_do (gfc_code *code, gfc_exec_op op, stmtblock_t *pblock,\n \t\t OMP_CLAUSE_LASTPRIVATE_STMT, otherwise the copied dovar\n \t\t will have the value on entry of the last loop, rather\n \t\t than value after iterator increment.  */\n-\t      tmp = gfc_evaluate_now (step, pblock);\n-\t      tmp = fold_build2_loc (input_location, PLUS_EXPR, type, dovar,\n-\t\t\t\t     tmp);\n+\t      if (clauses->orderedc)\n+\t\t{\n+\t\t  if (clauses->collapse <= 1 || i >= clauses->collapse)\n+\t\t    tmp = count;\n+\t\t  else\n+\t\t    tmp = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t\t   type, count, build_one_cst (type));\n+\t\t  tmp = fold_build2_loc (input_location, MULT_EXPR, type,\n+\t\t\t\t\t tmp, step);\n+\t\t  tmp = fold_build2_loc (input_location, PLUS_EXPR, type,\n+\t\t\t\t\t from, tmp);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  tmp = gfc_evaluate_now (step, pblock);\n+\t\t  tmp = fold_build2_loc (input_location, PLUS_EXPR, type,\n+\t\t\t\t\t dovar, tmp);\n+\t\t}\n \t      tmp = fold_build2_loc (input_location, MODIFY_EXPR, type,\n \t\t\t\t     dovar, tmp);\n \t      for (c = omp_clauses; c ; c = OMP_CLAUSE_CHAIN (c))\n@@ -3434,6 +3759,7 @@ gfc_trans_omp_do (gfc_code *code, gfc_exec_op op, stmtblock_t *pblock,\n     case EXEC_OMP_SIMD: stmt = make_node (OMP_SIMD); break;\n     case EXEC_OMP_DO: stmt = make_node (OMP_FOR); break;\n     case EXEC_OMP_DISTRIBUTE: stmt = make_node (OMP_DISTRIBUTE); break;\n+    case EXEC_OMP_TASKLOOP: stmt = make_node (OMP_TASKLOOP); break;\n     case EXEC_OACC_LOOP: stmt = make_node (OACC_LOOP); break;\n     default: gcc_unreachable ();\n     }\n@@ -3444,8 +3770,13 @@ gfc_trans_omp_do (gfc_code *code, gfc_exec_op op, stmtblock_t *pblock,\n   OMP_FOR_INIT (stmt) = init;\n   OMP_FOR_COND (stmt) = cond;\n   OMP_FOR_INCR (stmt) = incr;\n+  if (orig_decls)\n+    OMP_FOR_ORIG_DECLS (stmt) = orig_decls;\n   gfc_add_expr_to_block (&block, stmt);\n \n+  vec_free (doacross_steps);\n+  doacross_steps = saved_doacross_steps;\n+\n   return gfc_finish_block (&block);\n }\n \n@@ -3547,8 +3878,11 @@ gfc_trans_omp_master (gfc_code *code)\n static tree\n gfc_trans_omp_ordered (gfc_code *code)\n {\n+  tree omp_clauses = gfc_trans_omp_clauses (NULL, code->ext.omp_clauses,\n+\t\t\t\t\t    code->loc);\n   return build2_loc (input_location, OMP_ORDERED, void_type_node,\n-\t\t     gfc_trans_code (code->block->next), NULL_TREE);\n+\t\t     code->block ? gfc_trans_code (code->block->next)\n+\t\t     : NULL_TREE, omp_clauses);\n }\n \n static tree\n@@ -3577,6 +3911,7 @@ enum\n   GFC_OMP_SPLIT_DISTRIBUTE,\n   GFC_OMP_SPLIT_TEAMS,\n   GFC_OMP_SPLIT_TARGET,\n+  GFC_OMP_SPLIT_TASKLOOP,\n   GFC_OMP_SPLIT_NUM\n };\n \n@@ -3587,7 +3922,8 @@ enum\n   GFC_OMP_MASK_PARALLEL = (1 << GFC_OMP_SPLIT_PARALLEL),\n   GFC_OMP_MASK_DISTRIBUTE = (1 << GFC_OMP_SPLIT_DISTRIBUTE),\n   GFC_OMP_MASK_TEAMS = (1 << GFC_OMP_SPLIT_TEAMS),\n-  GFC_OMP_MASK_TARGET = (1 << GFC_OMP_SPLIT_TARGET)\n+  GFC_OMP_MASK_TARGET = (1 << GFC_OMP_SPLIT_TARGET),\n+  GFC_OMP_MASK_TASKLOOP = (1 << GFC_OMP_SPLIT_TASKLOOP)\n };\n \n static void\n@@ -3638,6 +3974,23 @@ gfc_split_omp_clauses (gfc_code *code,\n     case EXEC_OMP_TARGET:\n       innermost = GFC_OMP_SPLIT_TARGET;\n       break;\n+    case EXEC_OMP_TARGET_PARALLEL:\n+      mask = GFC_OMP_MASK_TARGET | GFC_OMP_MASK_PARALLEL;\n+      innermost = GFC_OMP_SPLIT_PARALLEL;\n+      break;\n+    case EXEC_OMP_TARGET_PARALLEL_DO:\n+      mask = GFC_OMP_MASK_TARGET | GFC_OMP_MASK_PARALLEL | GFC_OMP_MASK_DO;\n+      innermost = GFC_OMP_SPLIT_DO;\n+      break;\n+    case EXEC_OMP_TARGET_PARALLEL_DO_SIMD:\n+      mask = GFC_OMP_MASK_TARGET | GFC_OMP_MASK_PARALLEL | GFC_OMP_MASK_DO\n+\t     | GFC_OMP_MASK_SIMD;\n+      innermost = GFC_OMP_SPLIT_SIMD;\n+      break;\n+    case EXEC_OMP_TARGET_SIMD:\n+      mask = GFC_OMP_MASK_TARGET | GFC_OMP_MASK_SIMD;\n+      innermost = GFC_OMP_SPLIT_SIMD;\n+      break;\n     case EXEC_OMP_TARGET_TEAMS:\n       mask = GFC_OMP_MASK_TARGET | GFC_OMP_MASK_TEAMS;\n       innermost = GFC_OMP_SPLIT_TEAMS;\n@@ -3662,6 +4015,13 @@ gfc_split_omp_clauses (gfc_code *code,\n \t     | GFC_OMP_MASK_DISTRIBUTE | GFC_OMP_MASK_SIMD;\n       innermost = GFC_OMP_SPLIT_SIMD;\n       break;\n+    case EXEC_OMP_TASKLOOP:\n+      innermost = GFC_OMP_SPLIT_TASKLOOP;\n+      break;\n+    case EXEC_OMP_TASKLOOP_SIMD:\n+      mask = GFC_OMP_MASK_TASKLOOP | GFC_OMP_MASK_SIMD;\n+      innermost = GFC_OMP_SPLIT_SIMD;\n+      break;\n     case EXEC_OMP_TEAMS:\n       innermost = GFC_OMP_SPLIT_TEAMS;\n       break;\n@@ -3698,8 +4058,17 @@ gfc_split_omp_clauses (gfc_code *code,\n \t  /* First the clauses that are unique to some constructs.  */\n \t  clausesa[GFC_OMP_SPLIT_TARGET].lists[OMP_LIST_MAP]\n \t    = code->ext.omp_clauses->lists[OMP_LIST_MAP];\n+\t  clausesa[GFC_OMP_SPLIT_TARGET].lists[OMP_LIST_IS_DEVICE_PTR]\n+\t    = code->ext.omp_clauses->lists[OMP_LIST_IS_DEVICE_PTR];\n \t  clausesa[GFC_OMP_SPLIT_TARGET].device\n \t    = code->ext.omp_clauses->device;\n+\t  clausesa[GFC_OMP_SPLIT_TARGET].defaultmap\n+\t    = code->ext.omp_clauses->defaultmap;\n+\t  clausesa[GFC_OMP_SPLIT_TARGET].if_exprs[OMP_IF_TARGET]\n+\t    = code->ext.omp_clauses->if_exprs[OMP_IF_TARGET];\n+\t  /* And this is copied to all.  */\n+\t  clausesa[GFC_OMP_SPLIT_PARALLEL].if_expr\n+\t    = code->ext.omp_clauses->if_expr;\n \t}\n       if (mask & GFC_OMP_MASK_TEAMS)\n \t{\n@@ -3708,7 +4077,8 @@ gfc_split_omp_clauses (gfc_code *code,\n \t    = code->ext.omp_clauses->num_teams;\n \t  clausesa[GFC_OMP_SPLIT_TEAMS].thread_limit\n \t    = code->ext.omp_clauses->thread_limit;\n-\t  /* Shared and default clauses are allowed on parallel and teams.  */\n+\t  /* Shared and default clauses are allowed on parallel, teams\n+\t     and taskloop.  */\n \t  clausesa[GFC_OMP_SPLIT_TEAMS].lists[OMP_LIST_SHARED]\n \t    = code->ext.omp_clauses->lists[OMP_LIST_SHARED];\n \t  clausesa[GFC_OMP_SPLIT_TEAMS].default_sharing\n@@ -3734,19 +4104,34 @@ gfc_split_omp_clauses (gfc_code *code,\n \t    = code->ext.omp_clauses->num_threads;\n \t  clausesa[GFC_OMP_SPLIT_PARALLEL].proc_bind\n \t    = code->ext.omp_clauses->proc_bind;\n-\t  /* Shared and default clauses are allowed on parallel and teams.  */\n+\t  /* Shared and default clauses are allowed on parallel, teams\n+\t     and taskloop.  */\n \t  clausesa[GFC_OMP_SPLIT_PARALLEL].lists[OMP_LIST_SHARED]\n \t    = code->ext.omp_clauses->lists[OMP_LIST_SHARED];\n \t  clausesa[GFC_OMP_SPLIT_PARALLEL].default_sharing\n \t    = code->ext.omp_clauses->default_sharing;\n+\t  clausesa[GFC_OMP_SPLIT_PARALLEL].if_exprs[OMP_IF_PARALLEL]\n+\t    = code->ext.omp_clauses->if_exprs[OMP_IF_PARALLEL];\n+\t  /* And this is copied to all.  */\n+\t  clausesa[GFC_OMP_SPLIT_PARALLEL].if_expr\n+\t    = code->ext.omp_clauses->if_expr;\n \t}\n       if (mask & GFC_OMP_MASK_DO)\n \t{\n \t  /* First the clauses that are unique to some constructs.  */\n \t  clausesa[GFC_OMP_SPLIT_DO].ordered\n \t    = code->ext.omp_clauses->ordered;\n+\t  clausesa[GFC_OMP_SPLIT_DO].orderedc\n+\t    = code->ext.omp_clauses->orderedc;\n \t  clausesa[GFC_OMP_SPLIT_DO].sched_kind\n \t    = code->ext.omp_clauses->sched_kind;\n+\t  if (innermost == GFC_OMP_SPLIT_SIMD)\n+\t    clausesa[GFC_OMP_SPLIT_DO].sched_simd\n+\t      = code->ext.omp_clauses->sched_simd;\n+\t  clausesa[GFC_OMP_SPLIT_DO].sched_monotonic\n+\t    = code->ext.omp_clauses->sched_monotonic;\n+\t  clausesa[GFC_OMP_SPLIT_DO].sched_nonmonotonic\n+\t    = code->ext.omp_clauses->sched_nonmonotonic;\n \t  clausesa[GFC_OMP_SPLIT_DO].chunk_size\n \t    = code->ext.omp_clauses->chunk_size;\n \t  clausesa[GFC_OMP_SPLIT_DO].nowait\n@@ -3759,25 +4144,60 @@ gfc_split_omp_clauses (gfc_code *code,\n \t{\n \t  clausesa[GFC_OMP_SPLIT_SIMD].safelen_expr\n \t    = code->ext.omp_clauses->safelen_expr;\n-\t  clausesa[GFC_OMP_SPLIT_SIMD].lists[OMP_LIST_LINEAR]\n-\t    = code->ext.omp_clauses->lists[OMP_LIST_LINEAR];\n+\t  clausesa[GFC_OMP_SPLIT_SIMD].simdlen_expr\n+\t    = code->ext.omp_clauses->simdlen_expr;\n \t  clausesa[GFC_OMP_SPLIT_SIMD].lists[OMP_LIST_ALIGNED]\n \t    = code->ext.omp_clauses->lists[OMP_LIST_ALIGNED];\n \t  /* Duplicate collapse.  */\n \t  clausesa[GFC_OMP_SPLIT_SIMD].collapse\n \t    = code->ext.omp_clauses->collapse;\n \t}\n-      /* Private clause is supported on all constructs but target,\n+      if (mask & GFC_OMP_MASK_TASKLOOP)\n+\t{\n+\t  /* First the clauses that are unique to some constructs.  */\n+\t  clausesa[GFC_OMP_SPLIT_TASKLOOP].nogroup\n+\t    = code->ext.omp_clauses->nogroup;\n+\t  clausesa[GFC_OMP_SPLIT_TASKLOOP].grainsize\n+\t    = code->ext.omp_clauses->grainsize;\n+\t  clausesa[GFC_OMP_SPLIT_TASKLOOP].num_tasks\n+\t    = code->ext.omp_clauses->num_tasks;\n+\t  clausesa[GFC_OMP_SPLIT_TASKLOOP].priority\n+\t    = code->ext.omp_clauses->priority;\n+\t  clausesa[GFC_OMP_SPLIT_TASKLOOP].final_expr\n+\t    = code->ext.omp_clauses->final_expr;\n+\t  clausesa[GFC_OMP_SPLIT_TASKLOOP].untied\n+\t    = code->ext.omp_clauses->untied;\n+\t  clausesa[GFC_OMP_SPLIT_TASKLOOP].mergeable\n+\t    = code->ext.omp_clauses->mergeable;\n+\t  clausesa[GFC_OMP_SPLIT_TASKLOOP].if_exprs[OMP_IF_TASKLOOP]\n+\t    = code->ext.omp_clauses->if_exprs[OMP_IF_TASKLOOP];\n+\t  /* And this is copied to all.  */\n+\t  clausesa[GFC_OMP_SPLIT_TASKLOOP].if_expr\n+\t    = code->ext.omp_clauses->if_expr;\n+\t  /* Shared and default clauses are allowed on parallel, teams\n+\t     and taskloop.  */\n+\t  clausesa[GFC_OMP_SPLIT_TASKLOOP].lists[OMP_LIST_SHARED]\n+\t    = code->ext.omp_clauses->lists[OMP_LIST_SHARED];\n+\t  clausesa[GFC_OMP_SPLIT_TASKLOOP].default_sharing\n+\t    = code->ext.omp_clauses->default_sharing;\n+\t  /* Duplicate collapse.  */\n+\t  clausesa[GFC_OMP_SPLIT_TASKLOOP].collapse\n+\t    = code->ext.omp_clauses->collapse;\n+\t}\n+      /* Private clause is supported on all constructs,\n \t it is enough to put it on the innermost one.  For\n-\t !$ omp do put it on parallel though,\n+\t !$ omp parallel do put it on parallel though,\n \t as that's what we did for OpenMP 3.1.  */\n       clausesa[innermost == GFC_OMP_SPLIT_DO\n \t       ? (int) GFC_OMP_SPLIT_PARALLEL\n \t       : innermost].lists[OMP_LIST_PRIVATE]\n \t= code->ext.omp_clauses->lists[OMP_LIST_PRIVATE];\n       /* Firstprivate clause is supported on all constructs but\n-\t target and simd.  Put it on the outermost of those and\n-\t duplicate on parallel.  */\n+\t simd.  Put it on the outermost of those and duplicate\n+\t on parallel and teams.  */\n+      if (mask & GFC_OMP_MASK_TARGET)\n+\tclausesa[GFC_OMP_SPLIT_TARGET].lists[OMP_LIST_FIRSTPRIVATE]\n+\t  = code->ext.omp_clauses->lists[OMP_LIST_FIRSTPRIVATE];\n       if (mask & GFC_OMP_MASK_TEAMS)\n \tclausesa[GFC_OMP_SPLIT_TEAMS].lists[OMP_LIST_FIRSTPRIVATE]\n \t  = code->ext.omp_clauses->lists[OMP_LIST_FIRSTPRIVATE];\n@@ -3790,9 +4210,12 @@ gfc_split_omp_clauses (gfc_code *code,\n       else if (mask & GFC_OMP_MASK_DO)\n \tclausesa[GFC_OMP_SPLIT_DO].lists[OMP_LIST_FIRSTPRIVATE]\n \t  = code->ext.omp_clauses->lists[OMP_LIST_FIRSTPRIVATE];\n-      /* Lastprivate is allowed on do and simd.  In\n-\t parallel do{, simd} we actually want to put it on\n+      /* Lastprivate is allowed on distribute, do and simd.\n+         In parallel do{, simd} we actually want to put it on\n \t parallel rather than do.  */\n+      if (mask & GFC_OMP_MASK_DISTRIBUTE)\n+\tclausesa[GFC_OMP_SPLIT_DISTRIBUTE].lists[OMP_LIST_LASTPRIVATE]\n+\t  = code->ext.omp_clauses->lists[OMP_LIST_LASTPRIVATE];\n       if (mask & GFC_OMP_MASK_PARALLEL)\n \tclausesa[GFC_OMP_SPLIT_PARALLEL].lists[OMP_LIST_LASTPRIVATE]\n \t  = code->ext.omp_clauses->lists[OMP_LIST_LASTPRIVATE];\n@@ -3817,13 +4240,10 @@ gfc_split_omp_clauses (gfc_code *code,\n       if (mask & GFC_OMP_MASK_SIMD)\n \tclausesa[GFC_OMP_SPLIT_SIMD].lists[OMP_LIST_REDUCTION]\n \t  = code->ext.omp_clauses->lists[OMP_LIST_REDUCTION];\n-      /* FIXME: This is currently being discussed.  */\n-      if (mask & GFC_OMP_MASK_PARALLEL)\n-\tclausesa[GFC_OMP_SPLIT_PARALLEL].if_expr\n-\t  = code->ext.omp_clauses->if_expr;\n-      else\n-\tclausesa[GFC_OMP_SPLIT_TARGET].if_expr\n-\t  = code->ext.omp_clauses->if_expr;\n+      /* Linear clause is supported on do and simd,\n+\t put it on the innermost one.  */\n+      clausesa[innermost].lists[OMP_LIST_LINEAR]\n+\t= code->ext.omp_clauses->lists[OMP_LIST_LINEAR];\n     }\n   if ((mask & (GFC_OMP_MASK_PARALLEL | GFC_OMP_MASK_DO))\n       == (GFC_OMP_MASK_PARALLEL | GFC_OMP_MASK_DO))\n@@ -4166,11 +4586,12 @@ gfc_trans_omp_distribute (gfc_code *code, gfc_omp_clauses *clausesa)\n }\n \n static tree\n-gfc_trans_omp_teams (gfc_code *code, gfc_omp_clauses *clausesa)\n+gfc_trans_omp_teams (gfc_code *code, gfc_omp_clauses *clausesa,\n+\t\t     tree omp_clauses)\n {\n   stmtblock_t block;\n   gfc_omp_clauses clausesa_buf[GFC_OMP_SPLIT_NUM];\n-  tree stmt, omp_clauses = NULL_TREE;\n+  tree stmt;\n   bool combined = true;\n \n   gfc_start_block (&block);\n@@ -4181,8 +4602,9 @@ gfc_trans_omp_teams (gfc_code *code, gfc_omp_clauses *clausesa)\n     }\n   if (flag_openmp)\n     omp_clauses\n-      = gfc_trans_omp_clauses (&block, &clausesa[GFC_OMP_SPLIT_TEAMS],\n-\t\t\t       code->loc);\n+      = chainon (omp_clauses,\n+\t\t gfc_trans_omp_clauses (&block, &clausesa[GFC_OMP_SPLIT_TEAMS],\n+\t\t\t\t\tcode->loc));\n   switch (code->op)\n     {\n     case EXEC_OMP_TARGET_TEAMS:\n@@ -4200,10 +4622,13 @@ gfc_trans_omp_teams (gfc_code *code, gfc_omp_clauses *clausesa)\n       stmt = gfc_trans_omp_distribute (code, clausesa);\n       break;\n     }\n-  stmt = build2_loc (input_location, OMP_TEAMS, void_type_node, stmt,\n-\t\t     omp_clauses);\n-  if (combined)\n-    OMP_TEAMS_COMBINED (stmt) = 1;\n+  if (flag_openmp)\n+    {\n+      stmt = build2_loc (input_location, OMP_TEAMS, void_type_node, stmt,\n+\t\t\t omp_clauses);\n+      if (combined)\n+\tOMP_TEAMS_COMBINED (stmt) = 1;\n+    }\n   gfc_add_expr_to_block (&block, stmt);\n   return gfc_finish_block (&block);\n }\n@@ -4221,24 +4646,128 @@ gfc_trans_omp_target (gfc_code *code)\n     omp_clauses\n       = gfc_trans_omp_clauses (&block, &clausesa[GFC_OMP_SPLIT_TARGET],\n \t\t\t       code->loc);\n-  if (code->op == EXEC_OMP_TARGET)\n+  switch (code->op)\n     {\n+    case EXEC_OMP_TARGET:\n       pushlevel ();\n       stmt = gfc_trans_omp_code (code->block->next, true);\n       stmt = build3_v (BIND_EXPR, NULL, stmt, poplevel (1, 0));\n+      break;\n+    case EXEC_OMP_TARGET_PARALLEL:\n+      {\n+\tstmtblock_t iblock;\n+\n+\tgfc_start_block (&iblock);\n+\ttree inner_clauses\n+\t  = gfc_trans_omp_clauses (&block, &clausesa[GFC_OMP_SPLIT_PARALLEL],\n+\t\t\t\t   code->loc);\n+\tstmt = gfc_trans_omp_code (code->block->next, true);\n+\tstmt = build2_loc (input_location, OMP_PARALLEL, void_type_node, stmt,\n+\t\t\t   inner_clauses);\n+\tgfc_add_expr_to_block (&iblock, stmt);\n+\tstmt = gfc_finish_block (&iblock);\n+\tif (TREE_CODE (stmt) != BIND_EXPR)\n+\t  stmt = build3_v (BIND_EXPR, NULL, stmt, poplevel (1, 0));\n+\telse\n+\t  poplevel (0, 0);\n+      }\n+      break;\n+    case EXEC_OMP_TARGET_PARALLEL_DO:\n+    case EXEC_OMP_TARGET_PARALLEL_DO_SIMD:\n+      stmt = gfc_trans_omp_parallel_do (code, &block, clausesa);\n+      if (TREE_CODE (stmt) != BIND_EXPR)\n+\tstmt = build3_v (BIND_EXPR, NULL, stmt, poplevel (1, 0));\n+      else\n+\tpoplevel (0, 0);\n+      break;\n+    case EXEC_OMP_TARGET_SIMD:\n+      stmt = gfc_trans_omp_do (code, EXEC_OMP_SIMD, &block,\n+\t\t\t       &clausesa[GFC_OMP_SPLIT_SIMD], NULL_TREE);\n+      if (TREE_CODE (stmt) != BIND_EXPR)\n+\tstmt = build3_v (BIND_EXPR, NULL, stmt, poplevel (1, 0));\n+      else\n+\tpoplevel (0, 0);\n+      break;\n+    default:\n+      if (flag_openmp\n+\t  && (clausesa[GFC_OMP_SPLIT_TEAMS].num_teams\n+\t      || clausesa[GFC_OMP_SPLIT_TEAMS].thread_limit))\n+\t{\n+\t  gfc_omp_clauses clausesb;\n+\t  tree teams_clauses;\n+\t  /* For combined !$omp target teams, the num_teams and\n+\t     thread_limit clauses are evaluated before entering the\n+\t     target construct.  */\n+\t  memset (&clausesb, '\\0', sizeof (clausesb));\n+\t  clausesb.num_teams = clausesa[GFC_OMP_SPLIT_TEAMS].num_teams;\n+\t  clausesb.thread_limit = clausesa[GFC_OMP_SPLIT_TEAMS].thread_limit;\n+\t  clausesa[GFC_OMP_SPLIT_TEAMS].num_teams = NULL;\n+\t  clausesa[GFC_OMP_SPLIT_TEAMS].thread_limit = NULL;\n+\t  teams_clauses\n+\t    = gfc_trans_omp_clauses (&block, &clausesb, code->loc);\n+\t  pushlevel ();\n+\t  stmt = gfc_trans_omp_teams (code, clausesa, teams_clauses);\n+\t}\n+      else\n+\t{\n+\t  pushlevel ();\n+\t  stmt = gfc_trans_omp_teams (code, clausesa, NULL_TREE);\n+\t}\n+      if (TREE_CODE (stmt) != BIND_EXPR)\n+\tstmt = build3_v (BIND_EXPR, NULL, stmt, poplevel (1, 0));\n+      else\n+\tpoplevel (0, 0);\n+      break;\n     }\n-  else\n+  if (flag_openmp)\n     {\n-      pushlevel ();\n-      stmt = gfc_trans_omp_teams (code, clausesa);\n+      stmt = build2_loc (input_location, OMP_TARGET, void_type_node, stmt,\n+\t\t\t omp_clauses);\n+      if (code->op != EXEC_OMP_TARGET)\n+\tOMP_TARGET_COMBINED (stmt) = 1;\n+    }\n+  gfc_add_expr_to_block (&block, stmt);\n+  return gfc_finish_block (&block);\n+}\n+\n+static tree\n+gfc_trans_omp_taskloop (gfc_code *code)\n+{\n+  stmtblock_t block;\n+  gfc_omp_clauses clausesa[GFC_OMP_SPLIT_NUM];\n+  tree stmt, omp_clauses = NULL_TREE;\n+\n+  gfc_start_block (&block);\n+  gfc_split_omp_clauses (code, clausesa);\n+  if (flag_openmp)\n+    omp_clauses\n+      = gfc_trans_omp_clauses (&block, &clausesa[GFC_OMP_SPLIT_TASKLOOP],\n+\t\t\t       code->loc);\n+  switch (code->op)\n+    {\n+    case EXEC_OMP_TASKLOOP:\n+      /* This is handled in gfc_trans_omp_do.  */\n+      gcc_unreachable ();\n+      break;\n+    case EXEC_OMP_TASKLOOP_SIMD:\n+      stmt = gfc_trans_omp_do (code, EXEC_OMP_SIMD, &block,\n+\t\t\t       &clausesa[GFC_OMP_SPLIT_SIMD], NULL_TREE);\n       if (TREE_CODE (stmt) != BIND_EXPR)\n \tstmt = build3_v (BIND_EXPR, NULL, stmt, poplevel (1, 0));\n       else\n \tpoplevel (0, 0);\n+      break;\n+    default:\n+      gcc_unreachable ();\n     }\n   if (flag_openmp)\n-    stmt = build2_loc (input_location, OMP_TARGET, void_type_node, stmt,\n-\t\t       omp_clauses);\n+    {\n+      tree taskloop = make_node (OMP_TASKLOOP);\n+      TREE_TYPE (taskloop) = void_type_node;\n+      OMP_FOR_BODY (taskloop) = stmt;\n+      OMP_FOR_CLAUSES (taskloop) = omp_clauses;\n+      stmt = taskloop;\n+    }\n   gfc_add_expr_to_block (&block, stmt);\n   return gfc_finish_block (&block);\n }\n@@ -4259,6 +4788,36 @@ gfc_trans_omp_target_data (gfc_code *code)\n   return gfc_finish_block (&block);\n }\n \n+static tree\n+gfc_trans_omp_target_enter_data (gfc_code *code)\n+{\n+  stmtblock_t block;\n+  tree stmt, omp_clauses;\n+\n+  gfc_start_block (&block);\n+  omp_clauses = gfc_trans_omp_clauses (&block, code->ext.omp_clauses,\n+\t\t\t\t       code->loc);\n+  stmt = build1_loc (input_location, OMP_TARGET_ENTER_DATA, void_type_node,\n+\t\t     omp_clauses);\n+  gfc_add_expr_to_block (&block, stmt);\n+  return gfc_finish_block (&block);\n+}\n+\n+static tree\n+gfc_trans_omp_target_exit_data (gfc_code *code)\n+{\n+  stmtblock_t block;\n+  tree stmt, omp_clauses;\n+\n+  gfc_start_block (&block);\n+  omp_clauses = gfc_trans_omp_clauses (&block, code->ext.omp_clauses,\n+\t\t\t\t       code->loc);\n+  stmt = build1_loc (input_location, OMP_TARGET_EXIT_DATA, void_type_node,\n+\t\t     omp_clauses);\n+  gfc_add_expr_to_block (&block, stmt);\n+  return gfc_finish_block (&block);\n+}\n+\n static tree\n gfc_trans_omp_target_update (gfc_code *code)\n {\n@@ -4503,6 +5062,7 @@ gfc_trans_omp_directive (gfc_code *code)\n     case EXEC_OMP_DISTRIBUTE:\n     case EXEC_OMP_DO:\n     case EXEC_OMP_SIMD:\n+    case EXEC_OMP_TASKLOOP:\n       return gfc_trans_omp_do (code, code->op, NULL, code->ext.omp_clauses,\n \t\t\t       NULL);\n     case EXEC_OMP_DISTRIBUTE_PARALLEL_DO:\n@@ -4532,6 +5092,10 @@ gfc_trans_omp_directive (gfc_code *code)\n     case EXEC_OMP_SINGLE:\n       return gfc_trans_omp_single (code, code->ext.omp_clauses);\n     case EXEC_OMP_TARGET:\n+    case EXEC_OMP_TARGET_PARALLEL:\n+    case EXEC_OMP_TARGET_PARALLEL_DO:\n+    case EXEC_OMP_TARGET_PARALLEL_DO_SIMD:\n+    case EXEC_OMP_TARGET_SIMD:\n     case EXEC_OMP_TARGET_TEAMS:\n     case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE:\n     case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO:\n@@ -4540,12 +5104,18 @@ gfc_trans_omp_directive (gfc_code *code)\n       return gfc_trans_omp_target (code);\n     case EXEC_OMP_TARGET_DATA:\n       return gfc_trans_omp_target_data (code);\n+    case EXEC_OMP_TARGET_ENTER_DATA:\n+      return gfc_trans_omp_target_enter_data (code);\n+    case EXEC_OMP_TARGET_EXIT_DATA:\n+      return gfc_trans_omp_target_exit_data (code);\n     case EXEC_OMP_TARGET_UPDATE:\n       return gfc_trans_omp_target_update (code);\n     case EXEC_OMP_TASK:\n       return gfc_trans_omp_task (code);\n     case EXEC_OMP_TASKGROUP:\n       return gfc_trans_omp_taskgroup (code);\n+    case EXEC_OMP_TASKLOOP_SIMD:\n+      return gfc_trans_omp_taskloop (code);\n     case EXEC_OMP_TASKWAIT:\n       return gfc_trans_omp_taskwait ();\n     case EXEC_OMP_TASKYIELD:\n@@ -4555,7 +5125,7 @@ gfc_trans_omp_directive (gfc_code *code)\n     case EXEC_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO:\n     case EXEC_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD:\n     case EXEC_OMP_TEAMS_DISTRIBUTE_SIMD:\n-      return gfc_trans_omp_teams (code, NULL);\n+      return gfc_trans_omp_teams (code, NULL, NULL_TREE);\n     case EXEC_OMP_WORKSHARE:\n       return gfc_trans_omp_workshare (code, code->ext.omp_clauses);\n     default:"}, {"sha": "aaec1c22753a16e506d3a904d7edbda49482e011", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c3a85be96585374bf95c981ba2f602667cf5b7/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c3a85be96585374bf95c981ba2f602667cf5b7/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=b4c3a85be96585374bf95c981ba2f602667cf5b7", "patch": "@@ -1930,6 +1930,12 @@ trans_code (gfc_code * code, tree cond)\n \tcase EXEC_OMP_SINGLE:\n \tcase EXEC_OMP_TARGET:\n \tcase EXEC_OMP_TARGET_DATA:\n+\tcase EXEC_OMP_TARGET_ENTER_DATA:\n+\tcase EXEC_OMP_TARGET_EXIT_DATA:\n+\tcase EXEC_OMP_TARGET_PARALLEL:\n+\tcase EXEC_OMP_TARGET_PARALLEL_DO:\n+\tcase EXEC_OMP_TARGET_PARALLEL_DO_SIMD:\n+\tcase EXEC_OMP_TARGET_SIMD:\n \tcase EXEC_OMP_TARGET_TEAMS:\n \tcase EXEC_OMP_TARGET_TEAMS_DISTRIBUTE:\n \tcase EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO:\n@@ -1938,6 +1944,8 @@ trans_code (gfc_code * code, tree cond)\n \tcase EXEC_OMP_TARGET_UPDATE:\n \tcase EXEC_OMP_TASK:\n \tcase EXEC_OMP_TASKGROUP:\n+\tcase EXEC_OMP_TASKLOOP:\n+\tcase EXEC_OMP_TASKLOOP_SIMD:\n \tcase EXEC_OMP_TASKWAIT:\n \tcase EXEC_OMP_TASKYIELD:\n \tcase EXEC_OMP_TEAMS:"}, {"sha": "02a8a564250089fe9afc4c737c27ca54970d5523", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c3a85be96585374bf95c981ba2f602667cf5b7/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c3a85be96585374bf95c981ba2f602667cf5b7/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=b4c3a85be96585374bf95c981ba2f602667cf5b7", "patch": "@@ -742,6 +742,7 @@ tree gfc_omp_clause_assign_op (tree, tree, tree);\n tree gfc_omp_clause_linear_ctor (tree, tree, tree, tree);\n tree gfc_omp_clause_dtor (tree, tree);\n void gfc_omp_finish_clause (tree, gimple_seq *);\n+bool gfc_omp_scalar_p (tree);\n bool gfc_omp_disregard_value_expr (tree, bool);\n bool gfc_omp_private_debug_clause (tree, bool);\n bool gfc_omp_private_outer_ref (tree);"}, {"sha": "16573ddaba9cb958b765164fdc10717b103cb011", "filename": "gcc/gimplify.c", "status": "modified", "additions": 53, "deletions": 74, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c3a85be96585374bf95c981ba2f602667cf5b7/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c3a85be96585374bf95c981ba2f602667cf5b7/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=b4c3a85be96585374bf95c981ba2f602667cf5b7", "patch": "@@ -7011,17 +7011,7 @@ omp_notice_variable (struct gimplify_omp_ctx *ctx, tree decl, bool in_code)\n \t\t  is_declare_target = octx == NULL;\n \t\t}\n \t      if (!is_declare_target && ctx->target_map_scalars_firstprivate)\n-\t\t{\n-\t\t  tree type = TREE_TYPE (decl);\n-\t\t  if (TREE_CODE (type) == REFERENCE_TYPE)\n-\t\t    type = TREE_TYPE (type);\n-\t\t  if (TREE_CODE (type) == COMPLEX_TYPE)\n-\t\t    type = TREE_TYPE (type);\n-\t\t  if (INTEGRAL_TYPE_P (type)\n-\t\t      || SCALAR_FLOAT_TYPE_P (type)\n-\t\t      || TREE_CODE (type) == POINTER_TYPE)\n-\t\t    is_scalar = true;\n-\t\t}\n+\t\tis_scalar = lang_hooks.decls.omp_scalar_p (decl);\n \t      if (is_declare_target)\n \t\t;\n \t      else if (ctx->target_map_pointers_as_0len_arrays\n@@ -7293,36 +7283,6 @@ omp_check_private (struct gimplify_omp_ctx *ctx, tree decl, bool copyprivate)\n   return false;\n }\n \n-/* Return true if the CTX is combined with distribute and thus\n-   lastprivate can't be supported.  */\n-\n-static bool\n-omp_no_lastprivate (struct gimplify_omp_ctx *ctx)\n-{\n-  do\n-    {\n-      if (ctx->outer_context == NULL)\n-\treturn false;\n-      ctx = ctx->outer_context;\n-      switch (ctx->region_type)\n-\t{\n-\tcase ORT_WORKSHARE:\n-\t  if (!ctx->combined_loop)\n-\t    return false;\n-\t  if (ctx->distribute)\n-\t    return lang_GNU_Fortran ();\n-\t  break;\n-\tcase ORT_COMBINED_PARALLEL:\n-\t  break;\n-\tcase ORT_COMBINED_TEAMS:\n-\t  return lang_GNU_Fortran ();\n-\tdefault:\n-\t  return false;\n-\t}\n-    }\n-  while (1);\n-}\n-\n /* Callback for walk_tree to find a DECL_EXPR for the given DECL.  */\n \n static tree\n@@ -7354,11 +7314,10 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \n   ctx = new_omp_context (region_type);\n   outer_ctx = ctx->outer_context;\n-  if (code == OMP_TARGET && !lang_GNU_Fortran ())\n+  if (code == OMP_TARGET)\n     {\n-      ctx->target_map_pointers_as_0len_arrays = true;\n-      /* FIXME: For Fortran we want to set this too, when\n-\t the Fortran FE is updated to OpenMP 4.5.  */\n+      if (!lang_GNU_Fortran ())\n+\tctx->target_map_pointers_as_0len_arrays = true;\n       ctx->target_map_scalars_firstprivate = true;\n     }\n   if (!lang_GNU_Fortran ())\n@@ -7405,12 +7364,7 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t  flags = GOVD_LASTPRIVATE | GOVD_SEEN | GOVD_EXPLICIT;\n \t  check_non_private = \"lastprivate\";\n \t  decl = OMP_CLAUSE_DECL (c);\n-\t  if (omp_no_lastprivate (ctx))\n-\t    {\n-\t      notice_outer = false;\n-\t      flags |= GOVD_LINEAR_LASTPRIVATE_NO_OUTER;\n-\t    }\n-\t  else if (error_operand_p (decl))\n+\t  if (error_operand_p (decl))\n \t    goto do_add;\n \t  else if (outer_ctx\n \t\t   && (outer_ctx->region_type == ORT_COMBINED_PARALLEL\n@@ -7450,7 +7404,31 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t  struct gimplify_omp_ctx *octx = outer_ctx->outer_context;\n \t\t  omp_add_variable (octx, decl, GOVD_SHARED | GOVD_SEEN);\n \t\t  if (octx->outer_context)\n-\t\t    omp_notice_variable (octx->outer_context, decl, true);\n+\t\t    {\n+\t\t      octx = octx->outer_context;\n+\t\t      if (octx->region_type == ORT_WORKSHARE\n+\t\t\t  && octx->combined_loop\n+\t\t\t  && splay_tree_lookup (octx->variables,\n+\t\t\t\t\t\t(splay_tree_key) decl) == NULL\n+\t\t\t  && !omp_check_private (octx, decl, false))\n+\t\t\t{\n+\t\t\t  omp_add_variable (octx, decl,\n+\t\t\t\t\t    GOVD_LASTPRIVATE | GOVD_SEEN);\n+\t\t\t  octx = octx->outer_context;\n+\t\t\t  if (octx\n+\t\t\t      && octx->region_type == ORT_COMBINED_TEAMS\n+\t\t\t      && (splay_tree_lookup (octx->variables,\n+\t\t\t\t\t\t     (splay_tree_key) decl)\n+\t\t\t\t  == NULL))\n+\t\t\t    {\n+\t\t\t      omp_add_variable (octx, decl,\n+\t\t\t\t\t\tGOVD_SHARED | GOVD_SEEN);\n+\t\t\t      octx = octx->outer_context;\n+\t\t\t    }\n+\t\t\t}\n+\t\t      if (octx)\n+\t\t\tomp_notice_variable (octx, decl, true);\n+\t\t    }\n \t\t}\n \t      else if (outer_ctx->outer_context)\n \t\tomp_notice_variable (outer_ctx->outer_context, decl, true);\n@@ -7529,8 +7507,7 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t  if (octx\n \t\t      && octx->region_type == ORT_WORKSHARE\n \t\t      && octx->combined_loop\n-\t\t      && octx->distribute\n-\t\t      && !lang_GNU_Fortran ())\n+\t\t      && octx->distribute)\n \t\t    {\n \t\t      error_at (OMP_CLAUSE_LOCATION (c),\n \t\t\t\t\"%<linear%> clause for variable other than \"\n@@ -7545,8 +7522,6 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t parallel.  Similarly for #pragma omp for simd.  */\n \t      struct gimplify_omp_ctx *octx = outer_ctx;\n \t      decl = NULL_TREE;\n-\t      if (omp_no_lastprivate (ctx))\n-\t\tOMP_CLAUSE_LINEAR_NO_COPYOUT (c) = 1;\n \t      do\n \t\t{\n \t\t  if (OMP_CLAUSE_LINEAR_NO_COPYIN (c)\n@@ -8052,13 +8027,21 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t  goto do_add;\n \n \tcase OMP_CLAUSE_DEPEND:\n-\t  if (OMP_CLAUSE_DEPEND_KIND (c) == OMP_CLAUSE_DEPEND_SINK\n-\t      || OMP_CLAUSE_DEPEND_KIND (c) == OMP_CLAUSE_DEPEND_SOURCE)\n+\t  if (OMP_CLAUSE_DEPEND_KIND (c) == OMP_CLAUSE_DEPEND_SINK)\n \t    {\n-\t      /* Nothing to do.  OMP_CLAUSE_DECL will be lowered in\n-\t\t omp-low.c.  */\n+\t      tree deps = OMP_CLAUSE_DECL (c);\n+\t      while (deps && TREE_CODE (deps) == TREE_LIST)\n+\t\t{\n+\t\t  if (TREE_CODE (TREE_PURPOSE (deps)) == TRUNC_DIV_EXPR\n+\t\t      && DECL_P (TREE_OPERAND (TREE_PURPOSE (deps), 1)))\n+\t\t    gimplify_expr (&TREE_OPERAND (TREE_PURPOSE (deps), 1),\n+\t\t\t\t   pre_p, NULL, is_gimple_val, fb_rvalue);\n+\t\t  deps = TREE_CHAIN (deps);\n+\t\t}\n \t      break;\n \t    }\n+\t  else if (OMP_CLAUSE_DEPEND_KIND (c) == OMP_CLAUSE_DEPEND_SOURCE)\n+\t    break;\n \t  if (TREE_CODE (OMP_CLAUSE_DECL (c)) == COMPOUND_EXPR)\n \t    {\n \t      gimplify_expr (&TREE_OPERAND (OMP_CLAUSE_DECL (c), 0), pre_p,\n@@ -8822,15 +8805,8 @@ gimplify_adjust_omp_clauses (gimple_seq *pre_p, gimple_seq body, tree *list_p,\n \t  n = splay_tree_lookup (ctx->variables, (splay_tree_key) decl);\n \t  OMP_CLAUSE_LASTPRIVATE_FIRSTPRIVATE (c)\n \t    = (n->value & GOVD_FIRSTPRIVATE) != 0;\n-\t  if (omp_no_lastprivate (ctx))\n-\t    {\n-\t      if (OMP_CLAUSE_LASTPRIVATE_FIRSTPRIVATE (c))\n-\t\tremove = true;\n-\t      else\n-\t\tOMP_CLAUSE_CODE (c) = OMP_CLAUSE_PRIVATE;\n-\t    }\n-\t  else if (code == OMP_DISTRIBUTE\n-\t\t   && OMP_CLAUSE_LASTPRIVATE_FIRSTPRIVATE (c))\n+\t  if (code == OMP_DISTRIBUTE\n+\t      && OMP_CLAUSE_LASTPRIVATE_FIRSTPRIVATE (c))\n \t    {\n \t      remove = true;\n \t      error_at (OMP_CLAUSE_LOCATION (c),\n@@ -9629,9 +9605,8 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \t      c = build_omp_clause (input_location, OMP_CLAUSE_LINEAR);\n \t      OMP_CLAUSE_LINEAR_NO_COPYIN (c) = 1;\n \t      unsigned int flags = GOVD_LINEAR | GOVD_EXPLICIT | GOVD_SEEN;\n-\t      if ((has_decl_expr\n-\t\t   && bitmap_bit_p (has_decl_expr, DECL_UID (decl)))\n-\t\t  || omp_no_lastprivate (gimplify_omp_ctxp))\n+\t      if (has_decl_expr\n+\t\t  && bitmap_bit_p (has_decl_expr, DECL_UID (decl)))\n \t\t{\n \t\t  OMP_CLAUSE_LINEAR_NO_COPYOUT (c) = 1;\n \t\t  flags |= GOVD_LINEAR_LASTPRIVATE_NO_OUTER;\n@@ -9752,8 +9727,7 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \t    {\n \t      bool lastprivate\n \t\t= (!has_decl_expr\n-\t\t   || !bitmap_bit_p (has_decl_expr, DECL_UID (decl)))\n-\t\t  && !omp_no_lastprivate (gimplify_omp_ctxp);\n+\t\t   || !bitmap_bit_p (has_decl_expr, DECL_UID (decl)));\n \t      struct gimplify_omp_ctx *outer\n \t\t= gimplify_omp_ctxp->outer_context;\n \t      if (outer && lastprivate)\n@@ -10323,6 +10297,11 @@ computable_teams_clause (tree *tp, int *walk_subtrees, void *)\n \t      || lookup_attribute (\"omp declare target link\",\n \t\t\t\t   DECL_ATTRIBUTES (*tp))))\n \treturn *tp;\n+      if (VAR_P (*tp)\n+\t  && !DECL_SEEN_IN_BIND_EXPR_P (*tp)\n+\t  && !is_global_var (*tp)\n+\t  && decl_function_context (*tp) == current_function_decl)\n+\treturn *tp;\n       n = splay_tree_lookup (gimplify_omp_ctxp->variables,\n \t\t\t     (splay_tree_key) *tp);\n       if (n == NULL)"}, {"sha": "e4c0ffb799d4859d4d4de49fb018999b37bcdc75", "filename": "gcc/langhooks-def.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c3a85be96585374bf95c981ba2f602667cf5b7/gcc%2Flanghooks-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c3a85be96585374bf95c981ba2f602667cf5b7/gcc%2Flanghooks-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks-def.h?ref=b4c3a85be96585374bf95c981ba2f602667cf5b7", "patch": "@@ -80,6 +80,7 @@ struct gimplify_omp_ctx;\n extern void lhd_omp_firstprivatize_type_sizes (struct gimplify_omp_ctx *,\n \t\t\t\t\t       tree);\n extern bool lhd_omp_mappable_type (tree);\n+extern bool lhd_omp_scalar_p (tree);\n \n extern const char *lhd_get_substring_location (const substring_loc &,\n \t\t\t\t\t       location_t *out_loc);\n@@ -234,6 +235,7 @@ extern tree lhd_make_node (enum tree_code);\n #define LANG_HOOKS_OMP_CLAUSE_LINEAR_CTOR NULL\n #define LANG_HOOKS_OMP_CLAUSE_DTOR hook_tree_tree_tree_null\n #define LANG_HOOKS_OMP_FINISH_CLAUSE lhd_omp_finish_clause\n+#define LANG_HOOKS_OMP_SCALAR_P lhd_omp_scalar_p\n \n #define LANG_HOOKS_DECLS { \\\n   LANG_HOOKS_GLOBAL_BINDINGS_P, \\\n@@ -257,7 +259,8 @@ extern tree lhd_make_node (enum tree_code);\n   LANG_HOOKS_OMP_CLAUSE_ASSIGN_OP, \\\n   LANG_HOOKS_OMP_CLAUSE_LINEAR_CTOR, \\\n   LANG_HOOKS_OMP_CLAUSE_DTOR, \\\n-  LANG_HOOKS_OMP_FINISH_CLAUSE \\\n+  LANG_HOOKS_OMP_FINISH_CLAUSE, \\\n+  LANG_HOOKS_OMP_SCALAR_P \\\n }\n \n /* LTO hooks.  */"}, {"sha": "1ce19628b2a04d459121fad529a59ad3f63103f4", "filename": "gcc/langhooks.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c3a85be96585374bf95c981ba2f602667cf5b7/gcc%2Flanghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c3a85be96585374bf95c981ba2f602667cf5b7/gcc%2Flanghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.c?ref=b4c3a85be96585374bf95c981ba2f602667cf5b7", "patch": "@@ -507,6 +507,24 @@ lhd_omp_finish_clause (tree, gimple_seq *)\n {\n }\n \n+/* Return true if DECL is a scalar variable (for the purpose of\n+   implicit firstprivatization).  */\n+\n+bool\n+lhd_omp_scalar_p (tree decl)\n+{\n+  tree type = TREE_TYPE (decl);\n+  if (TREE_CODE (type) == REFERENCE_TYPE)\n+    type = TREE_TYPE (type);\n+  if (TREE_CODE (type) == COMPLEX_TYPE)\n+    type = TREE_TYPE (type);\n+  if (INTEGRAL_TYPE_P (type)\n+      || SCALAR_FLOAT_TYPE_P (type)\n+      || TREE_CODE (type) == POINTER_TYPE)\n+    return true;\n+  return false;\n+}\n+\n /* Register language specific type size variables as potentially OpenMP\n    firstprivate variables.  */\n "}, {"sha": "4e925ad69021d0c26a0907c5403fc2bc64e84dea", "filename": "gcc/langhooks.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c3a85be96585374bf95c981ba2f602667cf5b7/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c3a85be96585374bf95c981ba2f602667cf5b7/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=b4c3a85be96585374bf95c981ba2f602667cf5b7", "patch": "@@ -261,6 +261,10 @@ struct lang_hooks_for_decls\n \n   /* Do language specific checking on an implicitly determined clause.  */\n   void (*omp_finish_clause) (tree clause, gimple_seq *pre_p);\n+\n+  /* Return true if DECL is a scalar variable (for the purpose of\n+     implicit firstprivatization).  */\n+  bool (*omp_scalar_p) (tree decl);\n };\n \n /* Language hooks related to LTO serialization.  */"}, {"sha": "331da6a1bef5a638d74d96f69c7a26bb2a65d7e3", "filename": "gcc/omp-low.c", "status": "modified", "additions": 79, "deletions": 13, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c3a85be96585374bf95c981ba2f602667cf5b7/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c3a85be96585374bf95c981ba2f602667cf5b7/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=b4c3a85be96585374bf95c981ba2f602667cf5b7", "patch": "@@ -8010,12 +8010,27 @@ expand_omp_ordered_sink (gimple_stmt_iterator *gsi, struct omp_for_data *fd,\n \n   for (i = 0; i < fd->ordered; i++)\n     {\n+      tree step = NULL_TREE;\n       off = TREE_PURPOSE (deps);\n+      if (TREE_CODE (off) == TRUNC_DIV_EXPR)\n+\t{\n+\t  step = TREE_OPERAND (off, 1);\n+\t  off = TREE_OPERAND (off, 0);\n+\t}\n       if (!integer_zerop (off))\n \t{\n \t  gcc_assert (fd->loops[i].cond_code == LT_EXPR\n \t\t      || fd->loops[i].cond_code == GT_EXPR);\n \t  bool forward = fd->loops[i].cond_code == LT_EXPR;\n+\t  if (step)\n+\t    {\n+\t      /* Non-simple Fortran DO loops.  If step is variable,\n+\t\t we don't know at compile even the direction, so can't\n+\t\t warn.  */\n+\t      if (TREE_CODE (step) != INTEGER_CST)\n+\t\tbreak;\n+\t      forward = tree_int_cst_sgn (step) != -1;\n+\t    }\n \t  if (forward ^ OMP_CLAUSE_DEPEND_SINK_NEGATIVE (deps))\n \t    warning_at (loc, 0, \"%<depend(sink)%> clause waiting for \"\n \t\t\t\t\"lexically later iteration\");\n@@ -8036,16 +8051,33 @@ expand_omp_ordered_sink (gimple_stmt_iterator *gsi, struct omp_for_data *fd,\n   edge e1 = split_block (gsi_bb (gsi2), gsi_stmt (gsi2));\n   edge e2 = split_block_after_labels (e1->dest);\n \n-  *gsi = gsi_after_labels (e1->dest);\n+  gsi2 = gsi_after_labels (e1->dest);\n+  *gsi = gsi_last_bb (e1->src);\n   for (i = 0; i < fd->ordered; i++)\n     {\n       tree itype = TREE_TYPE (fd->loops[i].v);\n+      tree step = NULL_TREE;\n+      tree orig_off = NULL_TREE;\n       if (POINTER_TYPE_P (itype))\n \titype = sizetype;\n       if (i)\n \tdeps = TREE_CHAIN (deps);\n       off = TREE_PURPOSE (deps);\n-      tree s = fold_convert_loc (loc, itype, fd->loops[i].step);\n+      if (TREE_CODE (off) == TRUNC_DIV_EXPR)\n+\t{\n+\t  step = TREE_OPERAND (off, 1);\n+\t  off = TREE_OPERAND (off, 0);\n+\t  gcc_assert (fd->loops[i].cond_code == LT_EXPR\n+\t\t      && integer_onep (fd->loops[i].step)\n+\t\t      && !POINTER_TYPE_P (TREE_TYPE (fd->loops[i].v)));\n+\t}\n+      tree s = fold_convert_loc (loc, itype, step ? step : fd->loops[i].step);\n+      if (step)\n+\t{\n+\t  off = fold_convert_loc (loc, itype, off);\n+\t  orig_off = off;\n+\t  off = fold_build2_loc (loc, TRUNC_DIV_EXPR, itype, off, s);\n+\t}\n \n       if (integer_zerop (off))\n \tt = boolean_true_node;\n@@ -8067,7 +8099,36 @@ expand_omp_ordered_sink (gimple_stmt_iterator *gsi, struct omp_for_data *fd,\n \t  else\n \t    a = fold_build2_loc (loc, PLUS_EXPR, TREE_TYPE (fd->loops[i].v),\n \t\t\t\t fd->loops[i].v, co);\n-\t  if (fd->loops[i].cond_code == LT_EXPR)\n+\t  if (step)\n+\t    {\n+\t      tree t1, t2;\n+\t      if (OMP_CLAUSE_DEPEND_SINK_NEGATIVE (deps))\n+\t\tt1 = fold_build2_loc (loc, GE_EXPR, boolean_type_node, a,\n+\t\t\t\t      fd->loops[i].n1);\n+\t      else\n+\t\tt1 = fold_build2_loc (loc, LT_EXPR, boolean_type_node, a,\n+\t\t\t\t      fd->loops[i].n2);\n+\t      if (OMP_CLAUSE_DEPEND_SINK_NEGATIVE (deps))\n+\t\tt2 = fold_build2_loc (loc, LT_EXPR, boolean_type_node, a,\n+\t\t\t\t      fd->loops[i].n2);\n+\t      else\n+\t\tt2 = fold_build2_loc (loc, GE_EXPR, boolean_type_node, a,\n+\t\t\t\t      fd->loops[i].n1);\n+\t      t = fold_build2_loc (loc, LT_EXPR, boolean_type_node,\n+\t\t\t\t   step, build_int_cst (TREE_TYPE (step), 0));\n+\t      if (TREE_CODE (step) != INTEGER_CST)\n+\t\t{\n+\t\t  t1 = unshare_expr (t1);\n+\t\t  t1 = force_gimple_operand_gsi (gsi, t1, true, NULL_TREE,\n+\t\t\t\t\t\t false, GSI_CONTINUE_LINKING);\n+\t\t  t2 = unshare_expr (t2);\n+\t\t  t2 = force_gimple_operand_gsi (gsi, t2, true, NULL_TREE,\n+\t\t\t\t\t\t false, GSI_CONTINUE_LINKING);\n+\t\t}\n+\t      t = fold_build3_loc (loc, COND_EXPR, boolean_type_node,\n+\t\t\t\t   t, t2, t1);\n+\t    }\n+\t  else if (fd->loops[i].cond_code == LT_EXPR)\n \t    {\n \t      if (OMP_CLAUSE_DEPEND_SINK_NEGATIVE (deps))\n \t\tt = fold_build2_loc (loc, GE_EXPR, boolean_type_node, a,\n@@ -8090,16 +8151,20 @@ expand_omp_ordered_sink (gimple_stmt_iterator *gsi, struct omp_for_data *fd,\n \n       off = fold_convert_loc (loc, itype, off);\n \n-      if (fd->loops[i].cond_code == LT_EXPR\n-\t  ? !integer_onep (fd->loops[i].step)\n-\t  : !integer_minus_onep (fd->loops[i].step))\n+      if (step\n+\t  || (fd->loops[i].cond_code == LT_EXPR\n+\t      ? !integer_onep (fd->loops[i].step)\n+\t      : !integer_minus_onep (fd->loops[i].step)))\n \t{\n-\t  if (TYPE_UNSIGNED (itype) && fd->loops[i].cond_code == GT_EXPR)\n+\t  if (step == NULL_TREE\n+\t      && TYPE_UNSIGNED (itype)\n+\t      && fd->loops[i].cond_code == GT_EXPR)\n \t    t = fold_build2_loc (loc, TRUNC_MOD_EXPR, itype, off,\n \t\t\t\t fold_build1_loc (loc, NEGATE_EXPR, itype,\n \t\t\t\t\t\t  s));\n \t  else\n-\t    t = fold_build2_loc (loc, TRUNC_MOD_EXPR, itype, off, s);\n+\t    t = fold_build2_loc (loc, TRUNC_MOD_EXPR, itype,\n+\t\t\t\t orig_off ? orig_off : off, s);\n \t  t = fold_build2_loc (loc, EQ_EXPR, boolean_type_node, t,\n \t\t\t       build_int_cst (itype, 0));\n \t  if (integer_zerop (t) && !warned_step)\n@@ -8122,7 +8187,9 @@ expand_omp_ordered_sink (gimple_stmt_iterator *gsi, struct omp_for_data *fd,\n \t\t\t       fd->loops[i].v, fd->loops[i].n1);\n \t  t = fold_convert_loc (loc, fd->iter_type, t);\n \t}\n-      if (TYPE_UNSIGNED (itype) && fd->loops[i].cond_code == GT_EXPR)\n+      if (step)\n+\t/* We have divided off by step already earlier.  */;\n+      else if (TYPE_UNSIGNED (itype) && fd->loops[i].cond_code == GT_EXPR)\n \toff = fold_build2_loc (loc, TRUNC_DIV_EXPR, itype, off,\n \t\t\t       fold_build1_loc (loc, NEGATE_EXPR, itype,\n \t\t\t\t\t\ts));\n@@ -8145,15 +8212,14 @@ expand_omp_ordered_sink (gimple_stmt_iterator *gsi, struct omp_for_data *fd,\n \t}\n       off = unshare_expr (off);\n       t = fold_build2_loc (loc, PLUS_EXPR, fd->iter_type, t, off);\n-      t = force_gimple_operand_gsi (gsi, t, true, NULL_TREE,\n+      t = force_gimple_operand_gsi (&gsi2, t, true, NULL_TREE,\n \t\t\t\t    true, GSI_SAME_STMT);\n       args.safe_push (t);\n     }\n   gimple *g = gimple_build_call_vec (builtin_decl_explicit (sink_ix), args);\n   gimple_set_location (g, loc);\n-  gsi_insert_before (gsi, g, GSI_SAME_STMT);\n+  gsi_insert_before (&gsi2, g, GSI_SAME_STMT);\n \n-  *gsi = gsi_last_bb (e1->src);\n   cond = unshare_expr (cond);\n   cond = force_gimple_operand_gsi (gsi, cond, true, NULL_TREE, false,\n \t\t\t\t   GSI_CONTINUE_LINKING);\n@@ -16339,7 +16405,7 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t      }\n \t    if (tkind == GOMP_MAP_FIRSTPRIVATE_INT)\n \t      s = size_int (0);\n-\t    else if (is_reference (var))\n+\t    else if (is_reference (ovar))\n \t      s = TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (ovar)));\n \t    else\n \t      s = TYPE_SIZE_UNIT (TREE_TYPE (ovar));"}, {"sha": "03dcd5b651581094fe81d28a5afb007af89286f7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c3a85be96585374bf95c981ba2f602667cf5b7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c3a85be96585374bf95c981ba2f602667cf5b7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b4c3a85be96585374bf95c981ba2f602667cf5b7", "patch": "@@ -1,3 +1,13 @@\n+2016-11-10  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* gfortran.dg/gomp/pr77516.f90: Add dg-warning.\n+\t* gfortran.dg/gomp/target1.f90: Remove ordered clause where it is\n+\tno longer allowed and corresponding ordered construct.\n+\t* gfortran.dg/gomp/linear-1.f90: New test.\n+\t* gfortran.dg/gomp/declare-simd-2.f90: New test.\n+\t* gfortran.dg/gomp/declare-target-1.f90: New test.\n+\t* gfortran.dg/gomp/declare-target-2.f90: New test.\n+\n 2016-11-10  Martin Liska  <mliska@suse.cz>\n \n \tPR sanitizer/78270\n@@ -7,7 +17,7 @@\n \t    Jakub Jelinek  <jakub@redhat.com>\n \n \tPR debug/78112\n-\t* g++.dg/pr78112.C: New testcase\n+\t* g++.dg/pr78112.C: New testcase.\n \n 2016-11-09  Jakub Jelinek  <jakub@redhat.com>\n "}, {"sha": "8f76774fd6e0cc3a4ee327161496524392833179", "filename": "gcc/testsuite/gfortran.dg/gomp/declare-simd-2.f90", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c3a85be96585374bf95c981ba2f602667cf5b7/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-simd-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c3a85be96585374bf95c981ba2f602667cf5b7/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-simd-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-simd-2.f90?ref=b4c3a85be96585374bf95c981ba2f602667cf5b7", "patch": "@@ -0,0 +1,20 @@\n+! { dg-do compile }\n+\n+function f1 (a, b, c, d, e, f)\n+  integer, value :: a, b, c\n+  integer :: d, e, f, f1\n+!$omp declare simd (f1) uniform(b) linear(c, d) linear(uval(e)) linear(ref(f))\n+  a = a + 1\n+  b = b + 1\n+  c = c + 1\n+  d = d + 1\n+  e = e + 1\n+  f = f + 1\n+  f1 = a + b + c + d + e + f\n+end function f1\n+integer function f2 (a, b)\n+  integer :: a, b\n+!$omp declare simd uniform(b) linear(ref(a):b)\n+  a = a + 1\n+  f2 = a + b\n+end function f2"}, {"sha": "bf64e72d082fbcd934b4f147850b3055007d6a24", "filename": "gcc/testsuite/gfortran.dg/gomp/declare-target-1.f90", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c3a85be96585374bf95c981ba2f602667cf5b7/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-target-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c3a85be96585374bf95c981ba2f602667cf5b7/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-target-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-target-1.f90?ref=b4c3a85be96585374bf95c981ba2f602667cf5b7", "patch": "@@ -0,0 +1,27 @@\n+! { dg-do compile }\n+\n+module declare_target_1\n+  !$omp declare target to (var_1, var_4) link (var_2, var_3) &\n+  !$omp & link (var_5) to (var_6)\n+  integer :: var_1, var_2, var_3, var_4, var_5, var_6\n+  interface\n+    subroutine foo\n+      !$omp declare target\n+    end subroutine\n+  end interface\n+end\n+subroutine bar\n+  !$omp declare target\n+  integer, save :: var_9\n+  !$omp declare target link (var_8) to (baz, var_7) link (var_9) to (var_10)\n+  integer, save :: var_7, var_8, var_10\n+  integer :: var_11, var_12, var_13, var_14\n+  common /c1/ var_11, var_12\n+  common /c2/ var_13\n+  common /c3/ var_14\n+  !$omp declare target (baz, var_7, var_10, /c1/)\n+  !$omp declare target to (/c2/)\n+  !$omp declare target link (/c3/)\n+  !$omp declare target (bar)\n+  call baz\n+end subroutine"}, {"sha": "2217eab07e56b413c521a0d524c2f86379417e6e", "filename": "gcc/testsuite/gfortran.dg/gomp/declare-target-2.f90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c3a85be96585374bf95c981ba2f602667cf5b7/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-target-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c3a85be96585374bf95c981ba2f602667cf5b7/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-target-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-target-2.f90?ref=b4c3a85be96585374bf95c981ba2f602667cf5b7", "patch": "@@ -0,0 +1,51 @@\n+! { dg-do compile }\n+\n+module declare_target_2\n+  !$omp declare target to (a) link (a)\t! { dg-error \"TO clause and later in LINK\" }\n+  !$omp declare target (b)\n+  !$omp declare target link (b)\t\t! { dg-error \"TO clause and later in LINK\" }\n+  !$omp declare target link (f)\n+  !$omp declare target to (f)\t\t! { dg-error \"LINK clause and later in TO\" }\n+  !$omp declare target(c, c)\t\t! { dg-error \"mentioned multiple times in clauses of the same\" }\n+  !$omp declare target to (d) to (d)\t! { dg-error \"mentioned multiple times in clauses of the same\" }\n+  !$omp declare target link (e, e)\t! { dg-error \"mentioned multiple times in clauses of the same\" }\n+  integer, save :: a, b, c, d, e, f\n+  interface\n+    integer function f1 (a)\n+      !$omp declare target (f1)\t\t! { dg-error \"form without clauses is allowed in interface block\" }\n+      integer :: a\n+    end function\n+  end interface\n+  interface\n+    integer function f2 (a)\n+      !$omp declare target to (f2)\t! { dg-error \"form without clauses is allowed in interface block\" }\n+      integer :: a\n+    end function\n+  end interface\n+end\n+subroutine bar\n+  !$omp declare target link (baz)\t! { dg-error \"isn.t SAVEd\" }\n+  call baz\t\t\t\t! { dg-error \"attribute conflicts\" }\n+end subroutine\n+subroutine foo\t\t\t\t! { dg-error \"attribute conflicts\" }\n+  integer :: g, h, i, j, k, l, m, n, o, p, q\n+  common /c1/ g, h\n+  common /c2/ i, j\n+  common /c3/ k, l\n+  common /c4/ m, n\n+  common /c5/ o, p, q\n+  !$omp declare target to (g)\t\t! { dg-error \"is an element of a COMMON block\" }\n+  !$omp declare target link (foo)\n+  !$omp declare target to (/c2/)\n+  !$omp declare target (/c2/)\n+  !$omp declare target to(/c2/)\n+  !$omp declare target link(/c2/)\t! { dg-error \"TO clause and later in LINK\" }\n+  !$omp declare target link(/c3/)\n+  !$omp declare target (/c3/)\t\t! { dg-error \"LINK clause and later in TO\" }\n+  !$omp declare target (/c4/, /c4/)\t! { dg-error \"mentioned multiple times in clauses of the same\" }\n+  !$omp declare target to (/c4/) to(/c4/) ! { dg-error \"mentioned multiple times in clauses of the same\" }\n+  !$omp declare target link (/c5/)\n+  !$omp declare target link (/c5/)\n+  !$omp declare target link(/c5/)link(/c5/) ! { dg-error \"mentioned multiple times in clauses of the same\" }\n+  !$omp declare target link(/c5/,/c5/)\t! { dg-error \"mentioned multiple times in clauses of the same\" }\n+end subroutine"}, {"sha": "0d7eb8e3f8fd4f46a5565d68bcfbbfe64e322d79", "filename": "gcc/testsuite/gfortran.dg/gomp/linear-1.f90", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c3a85be96585374bf95c981ba2f602667cf5b7/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Flinear-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c3a85be96585374bf95c981ba2f602667cf5b7/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Flinear-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Flinear-1.f90?ref=b4c3a85be96585374bf95c981ba2f602667cf5b7", "patch": "@@ -0,0 +1,58 @@\n+subroutine foo (x, y)\n+  integer :: i, x, y\n+  common /i/ i\n+  interface\n+    function bar (x, y)\n+      integer :: x, y, bar\n+      !$omp declare simd (bar) linear (ref (x) : 1) linear (uval (y))\n+    end function bar\n+  end interface\n+  !$omp simd linear (x : y + 1)\n+  do i = 1, 10\n+    x = x + y + 1\n+  end do\n+  !$omp simd linear (val (x) : y + 1)\t! { dg-error \"LINEAR clause modifier used on DO or SIMD construct\" }\n+  do i = 1, 10\n+    x = x + y + 1\n+  end do\n+  !$omp simd linear (ref (x) : y + 1)\t! { dg-error \"LINEAR clause modifier used on DO or SIMD construct\" }\n+  do i = 1, 10\n+    x = x + y + 1\n+  end do\n+  !$omp simd linear (uval (x) : y + 1)\t! { dg-error \"LINEAR clause modifier used on DO or SIMD construct\" }\n+  do i = 1, 10\n+    x = x + y + 1\n+  end do\n+  !$omp do linear (x : y + 1)\n+  do i = 1, 10\n+    x = x + y + 1\n+  end do\n+  !$omp do linear (val (x) : y + 1)\t! { dg-error \"LINEAR clause modifier used on DO or SIMD construct\" }\n+  do i = 1, 10\n+    x = x + y + 1\n+  end do\n+  !$omp do linear (ref (x) : y + 1)\t! { dg-error \"LINEAR clause modifier used on DO or SIMD construct\" }\n+  do i = 1, 10\n+    x = x + y + 1\n+  end do\n+  !$omp do linear (uval (x) : y + 1)\t! { dg-error \"LINEAR clause modifier used on DO or SIMD construct\" }\n+  do i = 1, 10\n+    x = x + y + 1\n+  end do\n+  !$omp do simd linear (x : y + 1)\n+  do i = 1, 10\n+    x = x + y + 1\n+  end do\n+  !$omp do simd linear (val (x) : y + 1) ! { dg-error \"LINEAR clause modifier used on DO or SIMD construct\" }\n+  do i = 1, 10\n+    x = x + y + 1\n+  end do\n+  !$omp do simd linear (ref (x) : y + 1) ! { dg-error \"LINEAR clause modifier used on DO or SIMD construct\" }\n+  do i = 1, 10\n+    x = x + y + 1\n+  end do\n+  !$omp do simd linear (uval (x) : y + 1) ! { dg-error \"LINEAR clause modifier used on DO or SIMD construct\" }\n+  do i = 1, 10\n+    x = x + y + 1\n+  end do\n+end"}, {"sha": "9c0a95b9f79a18b0b868a70225dfeee9c4bad886", "filename": "gcc/testsuite/gfortran.dg/gomp/pr77516.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c3a85be96585374bf95c981ba2f602667cf5b7/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fpr77516.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c3a85be96585374bf95c981ba2f602667cf5b7/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fpr77516.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fpr77516.f90?ref=b4c3a85be96585374bf95c981ba2f602667cf5b7", "patch": "@@ -4,7 +4,7 @@\n program pr77516\n    integer :: i, x\n    x = 0\n-!$omp simd safelen(0) reduction(+:x)\n+!$omp simd safelen(0) reduction(+:x)\t! { dg-warning \"must be positive\" }\n    do i = 1, 8\n       x = x + 1\n    end do"}, {"sha": "da930b92422f01d91d23f0f91d091c4cd0a51c77", "filename": "gcc/testsuite/gfortran.dg/gomp/target1.f90", "status": "modified", "additions": 8, "deletions": 32, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c3a85be96585374bf95c981ba2f602667cf5b7/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ftarget1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c3a85be96585374bf95c981ba2f602667cf5b7/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ftarget1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ftarget1.f90?ref=b4c3a85be96585374bf95c981ba2f602667cf5b7", "patch": "@@ -51,32 +51,26 @@ subroutine foo (n, o, p, q, r, pp)\n     !$omp & private (p) firstprivate (q) shared (n) reduction (+: r) &\n     !$omp & thread_limit (n * 2) dist_schedule (static, 4) collapse (2) &\n     !$omp & num_threads (n + 4) proc_bind (spread) lastprivate (s) &\n-    !$omp & ordered schedule (static, 8)\n+    !$omp & schedule (static, 8)\n       do i = 1, 10\n         do j = 1, 10\n           r = r + 1\n           p = q\n           call dosomething (a, n, p + q)\n-\t  !$omp ordered\n-\t    p = q\n-\t  !$omp end ordered\n \t  s = i * 10 + j\n         end do\n       end do\n     !$omp target teams distribute parallel do device (n + 1) num_teams (n + 4) &\n     !$omp & if (n .ne. 6)map (from: n) map (alloc: a(2:o)) default(shared) &\n     !$omp & private (p) firstprivate (q) shared (n) reduction (+: r) &\n     !$omp & thread_limit (n * 2) dist_schedule (static, 4) num_threads (n + 4) &\n-    !$omp & proc_bind (master) lastprivate (s) ordered schedule (static, 8)\n+    !$omp & proc_bind (master) lastprivate (s) schedule (static, 8)\n       do i = 1, 10\n         do j = 1, 10\n           r = r + 1\n           p = q\n           call dosomething (a, n, p + q)\n         end do\n-        !$omp ordered\n-          p = q\n-        !$omp end ordered\n \ts = i * 10\n       end do\n     !$omp end target teams distribute parallel do\n@@ -167,7 +161,7 @@ subroutine foo (n, o, p, q, r, pp)\n     !$omp end target\n     !$omp target device (n + 1) if (n .ne. 6)map (from: n) map (alloc: a(2:o))\n     !$omp teams distribute parallel do num_teams (n + 4) &\n-    !$omp & if (n .ne. 6) default(shared) ordered schedule (static, 8) &\n+    !$omp & if (n .ne. 6) default(shared) schedule (static, 8) &\n     !$omp & private (p) firstprivate (q) shared (n) reduction (+: r) &\n     !$omp & thread_limit (n * 2) dist_schedule (static, 4) collapse (2) &\n     !$omp & num_threads (n + 4) proc_bind (spread) lastprivate (s)\n@@ -176,9 +170,6 @@ subroutine foo (n, o, p, q, r, pp)\n           r = r + 1\n           p = q\n           call dosomething (a, n, p + q)\n-\t  !$omp ordered\n-\t    p = q\n-\t  !$omp end ordered\n \t  s = i * 10 + j\n         end do\n       end do\n@@ -187,16 +178,13 @@ subroutine foo (n, o, p, q, r, pp)\n     !$omp teams distribute parallel do num_teams (n + 4)if(n.ne.6)default(shared)&\n     !$omp & private (p) firstprivate (q) shared (n) reduction (+: r) &\n     !$omp & thread_limit (n * 2) dist_schedule (static, 4) num_threads (n + 4) &\n-    !$omp & proc_bind (master) lastprivate (s) ordered schedule (static, 8)\n+    !$omp & proc_bind (master) lastprivate (s) schedule (static, 8)\n       do i = 1, 10\n         do j = 1, 10\n           r = r + 1\n           p = q\n           call dosomething (a, n, p + q)\n         end do\n-        !$omp ordered\n-          p = q\n-        !$omp end ordered\n \ts = i * 10\n       end do\n     !$omp end teams distribute parallel do\n@@ -285,17 +273,14 @@ subroutine foo (n, o, p, q, r, pp)\n     !$omp & map (alloc: a(2:o)) num_teams (n + 4) thread_limit (n * 2) &\n     !$omp & default(shared) shared(n) private (p) reduction(+:r)\n     !$omp distribute parallel do if (n .ne. 6) default(shared) &\n-    !$omp & ordered schedule (static, 8) private (p) firstprivate (q) &\n+    !$omp & schedule (static, 8) private (p) firstprivate (q) &\n     !$omp & shared(n)reduction(+:r)dist_schedule(static,4)collapse(2)&\n     !$omp & num_threads (n + 4) proc_bind (spread) lastprivate (s)\n       do i = 1, 10\n         do j = 1, 10\n           r = r + 1\n           p = q\n           call dosomething (a, n, p + q)\n-\t  !$omp ordered\n-\t    p = q\n-\t  !$omp end ordered\n \t  s = i * 10 + j\n         end do\n       end do\n@@ -306,16 +291,13 @@ subroutine foo (n, o, p, q, r, pp)\n     !$omp distribute parallel do if(n.ne.6)default(shared)&\n     !$omp & private (p) firstprivate (q) shared (n) reduction (+: r) &\n     !$omp & dist_schedule (static, 4) num_threads (n + 4) &\n-    !$omp & proc_bind (master) lastprivate (s) ordered schedule (static, 8)\n+    !$omp & proc_bind (master) lastprivate (s) schedule (static, 8)\n       do i = 1, 10\n         do j = 1, 10\n           r = r + 1\n           p = q\n           call dosomething (a, n, p + q)\n         end do\n-        !$omp ordered\n-          p = q\n-        !$omp end ordered\n \ts = i * 10\n       end do\n     !$omp end distribute parallel do\n@@ -418,17 +400,14 @@ subroutine bar (n, o, p, r, pp)\n     !$omp & map (alloc: a(2:o)) num_teams (n + 4) thread_limit (n * 2) &\n     !$omp & default(shared) shared(n) private (p) reduction(+:r)\n     !$omp distribute parallel do if (n .ne. 6) default(shared) &\n-    !$omp & ordered schedule (static, 8) private (p) firstprivate (q) &\n+    !$omp & schedule (static, 8) private (p) firstprivate (q) &\n     !$omp & shared(n)reduction(+:r)dist_schedule(static,4)collapse(2)&\n     !$omp & num_threads (n + 4) proc_bind (spread) lastprivate (s)\n       do i = 1, 10\n         do j = 1, 10\n           r = r + 1\n           p = q\n           call dosomething (a, n, p + q)\n-\t  !$omp ordered\n-\t    p = q\n-\t  !$omp end ordered\n \t  s = i * 10 + j\n         end do\n       end do\n@@ -439,16 +418,13 @@ subroutine bar (n, o, p, r, pp)\n     !$omp distribute parallel do if(n.ne.6)default(shared)&\n     !$omp & private (p) firstprivate (q) shared (n) reduction (+: r) &\n     !$omp & dist_schedule (static, 4) num_threads (n + 4) &\n-    !$omp & proc_bind (master) lastprivate (s) ordered schedule (static, 8)\n+    !$omp & proc_bind (master) lastprivate (s) schedule (static, 8)\n       do i = 1, 10\n         do j = 1, 10\n           r = r + 1\n           p = q\n           call dosomething (a, n, p + q)\n         end do\n-        !$omp ordered\n-          p = q\n-        !$omp end ordered\n \ts = i * 10\n       end do\n     !$omp end distribute parallel do"}, {"sha": "71fb4b88df129d8fb8cafad9241c160a8fa93bdd", "filename": "gcc/varpool.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c3a85be96585374bf95c981ba2f602667cf5b7/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c3a85be96585374bf95c981ba2f602667cf5b7/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=b4c3a85be96585374bf95c981ba2f602667cf5b7", "patch": "@@ -149,11 +149,11 @@ varpool_node::get_create (tree decl)\n   node = varpool_node::create_empty ();\n   node->decl = decl;\n \n-  if ((flag_openacc || flag_openmp) && !DECL_EXTERNAL (decl)\n+  if ((flag_openacc || flag_openmp)\n       && lookup_attribute (\"omp declare target\", DECL_ATTRIBUTES (decl)))\n     {\n       node->offloadable = 1;\n-      if (ENABLE_OFFLOADING)\n+      if (ENABLE_OFFLOADING && !DECL_EXTERNAL (decl))\n \t{\n \t  g->have_offload = true;\n \t  if (!in_lto_p)"}, {"sha": "920e3780f192238a0c841de2b46182f732bef72d", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c3a85be96585374bf95c981ba2f602667cf5b7/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c3a85be96585374bf95c981ba2f602667cf5b7/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=b4c3a85be96585374bf95c981ba2f602667cf5b7", "patch": "@@ -1,3 +1,34 @@\n+2016-11-10  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* testsuite/libgomp.fortran/examples-4/declare_target-1.f90\n+\t(fib_wrapper): Add map(from: x) clause.\n+\t* testsuite/libgomp.fortran/examples-4/declare_target-2.f90\n+\t(e_53_2): Likewise.\n+\t* testsuite/libgomp.fortran/examples-4/declare_target-4.f90\n+\t(accum): Add map(tmp) clause.\n+\t* testsuite/libgomp.fortran/examples-4/declare_target-5.f90\n+\t(accum): Add map(tofrom: tmp) clause.\n+\t* testsuite/libgomp.fortran/examples-4/target_data-3.f90\n+\t(gramSchmidt): Likewise.\n+\t* testsuite/libgomp.fortran/examples-4/teams-2.f90 (dotprod): Add\n+\tmap(tofrom: sum) clause.\n+\t* testsuite/libgomp.fortran/nestedfn5.f90 (foo): Add twice\n+\tmap (alloc: a, l) clause.  Add defaultmap(tofrom: scalar) clause.\n+\t* testsuite/libgomp.fortran/pr66199-2.f90: Adjust for linear clause\n+\tonly allowed on the loop iterator.\n+\t* testsuite/libgomp.fortran/target4.f90 (foo): Add map(t) clause.\n+\t* testsuite/libgomp.fortran/taskloop2.f90: New test.\n+\t* testsuite/libgomp.fortran/taskloop4.f90: New test.\n+\t* testsuite/libgomp.fortran/doacross1.f90: New test.\n+\t* testsuite/libgomp.fortran/doacross3.f90: New test.\n+\t* testsuite/libgomp.fortran/taskloop1.f90: New test.\n+\t* testsuite/libgomp.fortran/taskloop3.f90: New test.\n+\t* testsuite/libgomp.fortran/doacross2.f90: New test.\n+\t* testsuite/libgomp.c/doacross-1.c (main): Add missing\n+\t#pragma omp atomic read.\n+\t* testsuite/libgomp.c/doacross-2.c (main): Likewise.\n+\t* testsuite/libgomp.c/doacross-3.c (main): Likewise.\n+\n 2016-11-02  Cesar Philippidis  <cesar@codesourcery.com>\n \t    Nathan Sidwell  <nathan@acm.org>\n "}, {"sha": "3d12f1cfc02b5990ab1d3caf71385c2a82802abd", "filename": "libgomp/testsuite/libgomp.c/doacross-1.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c3a85be96585374bf95c981ba2f602667cf5b7/libgomp%2Ftestsuite%2Flibgomp.c%2Fdoacross-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c3a85be96585374bf95c981ba2f602667cf5b7/libgomp%2Ftestsuite%2Flibgomp.c%2Fdoacross-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fdoacross-1.c?ref=b4c3a85be96585374bf95c981ba2f602667cf5b7", "patch": "@@ -96,6 +96,7 @@ main ()\n \t\t\t\t  depend(sink: i - 1, j - 2, k - 2 E(m))\n \t      if (k <= 4)\n \t\t{\n+\t\t  #pragma omp atomic read\n \t\t  l = c[i][j][k + 2];\n \t\t  if (l < 2)\n \t\t    abort ();\n@@ -104,12 +105,14 @@ main ()\n \t      c[i][j][k] = 2;\n \t      if (i >= 2 && j < 7 && k >= 4)\n \t\t{\n+\t\t  #pragma omp atomic read\n \t\t  l = c[i - 2][j + 1][k - 4];\n \t\t  if (l < 2)\n \t\t    abort ();\n \t\t}\n \t      if (i >= 1 && j >= 4 && k >= 2)\n \t\t{\n+\t\t  #pragma omp atomic read\n \t\t  l = c[i - 1][j - 2][k - 2];\n \t\t  if (l < 2)\n \t\t    abort ();"}, {"sha": "0911dd207d9398e1e0a40a296d629a9a5e076593", "filename": "libgomp/testsuite/libgomp.c/doacross-2.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c3a85be96585374bf95c981ba2f602667cf5b7/libgomp%2Ftestsuite%2Flibgomp.c%2Fdoacross-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c3a85be96585374bf95c981ba2f602667cf5b7/libgomp%2Ftestsuite%2Flibgomp.c%2Fdoacross-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fdoacross-2.c?ref=b4c3a85be96585374bf95c981ba2f602667cf5b7", "patch": "@@ -98,6 +98,7 @@ main ()\n \t\t\t\t  depend(sink: i - 1, j - 2, k - 2 E(m))\n \t      if (k <= 4)\n \t\t{\n+\t\t  #pragma omp atomic read\n \t\t  l = c[i][j][k + 2];\n \t\t  if (l < 2)\n \t\t    abort ();\n@@ -106,12 +107,14 @@ main ()\n \t      c[i][j][k] = 2;\n \t      if (i >= 4 && j < 7 && k >= 4)\n \t\t{\n+\t\t  #pragma omp atomic read\n \t\t  l = c[i - 2][j + 1][k - 4];\n \t\t  if (l < 2)\n \t\t    abort ();\n \t\t}\n \t      if (i >= 3 && j >= 4 && k >= 2)\n \t\t{\n+\t\t  #pragma omp atomic read\n \t\t  l = c[i - 1][j - 2][k - 2];\n \t\t  if (l < 2)\n \t\t    abort ();"}, {"sha": "9a70b108772405d1361ecbd8ec0185b212eb280a", "filename": "libgomp/testsuite/libgomp.c/doacross-3.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c3a85be96585374bf95c981ba2f602667cf5b7/libgomp%2Ftestsuite%2Flibgomp.c%2Fdoacross-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c3a85be96585374bf95c981ba2f602667cf5b7/libgomp%2Ftestsuite%2Flibgomp.c%2Fdoacross-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fdoacross-3.c?ref=b4c3a85be96585374bf95c981ba2f602667cf5b7", "patch": "@@ -98,6 +98,7 @@ main ()\n \t\t\t\t  depend(sink: i - 1, j - 2, k - 2 E(m))\n \t      if (k <= 4)\n \t\t{\n+\t\t  #pragma omp atomic read\n \t\t  l = c[i][j][k + 2];\n \t\t  if (l < 2)\n \t\t    abort ();\n@@ -106,12 +107,14 @@ main ()\n \t      c[i][j][k] = 2;\n \t      if (i >= 4 && j < 7 && k >= 4)\n \t\t{\n+\t\t  #pragma omp atomic read\n \t\t  l = c[i - 2][j + 1][k - 4];\n \t\t  if (l < 2)\n \t\t    abort ();\n \t\t}\n \t      if (i >= 3 && j >= 4 && k >= 2)\n \t\t{\n+\t\t  #pragma omp atomic read\n \t\t  l = c[i - 1][j - 2][k - 2];\n \t\t  if (l < 2)\n \t\t    abort ();"}, {"sha": "b4eda8fef64397cfdb7bb08e7d25caa270b042d7", "filename": "libgomp/testsuite/libgomp.fortran/doacross1.f90", "status": "added", "additions": 209, "deletions": 0, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c3a85be96585374bf95c981ba2f602667cf5b7/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fdoacross1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c3a85be96585374bf95c981ba2f602667cf5b7/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fdoacross1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fdoacross1.f90?ref=b4c3a85be96585374bf95c981ba2f602667cf5b7", "patch": "@@ -0,0 +1,209 @@\n+! { dg-do run }\n+\n+  integer, parameter :: N = 256\n+  integer, save :: a(N), b(N / 16, 8, 4), c(N / 32, 8, 8)\n+  integer, save, volatile :: d, e\n+  integer :: i, j, k, l, m\n+  integer :: m1, m2, m3, m4, m5, m6, m7, m8\n+  integer :: m9, m10, m11, m12, m13, m14, m15, m16\n+  d = 0\n+  e = 0\n+  !$omp parallel private (l) shared(k)\n+    !$omp do schedule(static, 1) ordered(1)\n+    do i = 1, N\n+      !$omp atomic write\n+      a(i) = 1\n+      !$omp ordered depend ( sink : i - 1 )\n+      if (i.gt.1) then\n+        !$omp atomic read\n+        l = a(i - 1)\n+        if (l.lt.2) call abort\n+      end if\n+      !$omp atomic write\n+      a(i) = 2\n+      if (i.lt.N) then\n+        !$omp atomic read\n+        l = a(i + 1)\n+        if (l.eq.3) call abort\n+      end if\n+      !$omp ordered depend(source)\n+      !$omp atomic write\n+      a(i) = 3\n+    end do\n+    !$omp end do nowait\n+    !$omp do schedule(static) ordered ( 3 )\n+    do i = 3, N / 16 - 1\n+      do j = 1, 8, 2\n+        do k = 2, 4\n+          !$omp atomic write\n+          b(i, j, k) = 1\n+          !$omp ordered depend(sink:i,j-2,k-1) &\n+          !$omp& depend(sink: i - 2, j - 2, k + 1)\n+          !$omp ordered depend(sink:i-3,j+2,k-2)\n+          if (j.gt.2.and.k.gt.2) then\n+            !$omp atomic read\n+            l = b(i,j-2,k-1)\n+            if (l.lt.2) call abort\n+          end if\n+          !$omp atomic write\n+          b(i,j,k) = 2\n+          if (i.gt.4.and.j.gt.2.and.k.lt.4) then\n+            !$omp atomic read\n+            l = b(i-2,j-2, k+1)\n+            if (l.lt.2) call abort\n+          end if\n+          if (i.gt.5.and.j.le.N/16-3.and.k.eq.4) then\n+            !$omp atomic read\n+            l = b( i - 3, j+2, k-2)\n+            if (l.lt.2) call abort\n+          end if\n+          !$omp ordered depend(source)\n+          !$omp atomic write\n+          b(i, j, k) = 3\n+        end do\n+      end do\n+    end do\n+    !$omp end do nowait\n+    !$omp do schedule(dynamic, 15) collapse(2) ordered(13)\n+    do i = 1, N / 32\n+      do j = 8, 3, -1\n+        do k = 7, 1, -2\n+          do m1 = 4, 4\n+          do m2 = 4, 4\n+          do m3 = 4, 4\n+          do m4 = 4, 4\n+          do m5 = 4, 4\n+          do m6 = 4, 4\n+          do m7 = 4, 4\n+          do m8 = 4, 4\n+          do m9 = 4, 4\n+          do m10 = 4, 4\n+          do m11 = 4, 4\n+          do m12 = 4, 4\n+          do m13 = 4, 4\n+          do m14 = 4, 4\n+          do m15 = 4, 4\n+          do m16 = 4, 4\n+            !$omp atomic write\n+            c(i, j, k) = 1\n+            !$omp ordered depend(sink: i, j, k + 2, m1, m2, m3, m4, &\n+            !$omp & m5, m6, m7, m8, m9, m10) &\n+            !$omp depend(sink: i - 2, j + 1, k - 4, m1,m2,m3,m4,m5, &\n+            !$omp & m6,m7,m8,m9,m10) depend ( sink : i-1,j-2,k-2, &\n+            !$omp& m1,m2,m3,m4 , m5, m6,m7,m8,m9,m10 )\n+            if (k.le.5) then\n+              !$omp atomic read\n+              l = c(i, j, k + 2)\n+              if (l.lt.2) call abort\n+            end if\n+            !$omp atomic write\n+            c(i, j, k) = 2\n+            if (i.ge.3.and.j.lt.8.and.k.ge.5) then\n+              !$omp atomic read\n+              l = c(i - 2, j + 1, k - 4)\n+              if (l.lt.2) call abort\n+            end if\n+            if (i.ge.2.and.j.ge.5.and.k.ge.3) then\n+              !$omp atomic read\n+              l = c(i - 1, j - 2, k - 2)\n+              if (l.lt.2) call abort\n+            end if\n+            !$omp ordered depend ( source )\n+            !$omp atomic write\n+            c(i,j,k)=3\n+          end do\n+          end do\n+          end do\n+          end do\n+          end do\n+          end do\n+          end do\n+          end do\n+          end do\n+          end do\n+          end do\n+          end do\n+          end do\n+          end do\n+          end do\n+          end do\n+        end do\n+      end do\n+    end do\n+    !$omp do collapse(2) ordered(4) lastprivate (i,j,k)\n+    do i = 0, d\n+      do j = d + 1, 0, -1\n+        do k = 0, d - 1\n+          do l = 0, d + 1\n+            !$omp ordered depend(source)\n+            !$omp ordered depend(sink: i-2,j+2,k-2,l)\n+            if (e.eq.0) call abort\n+          end do\n+        end do\n+      end do\n+    end do\n+    !$omp single\n+    if (i.ne.1.or.j.ne.-1.or.k.ne.0) call abort\n+    i = 8; j = 9; k = 10\n+    !$omp end single\n+    !$omp do ordered(4) collapse(2) lastprivate (i, j, k, m)\n+    do i = 0, d\n+      do j = d + 1, 0, -1\n+        do k = 0, d + 1\n+          do m = 0, d-1\n+            !$omp ordered depend(source)\n+            !$omp ordered depend(sink: i - 2, j + 2, k - 2, m)\n+            call abort\n+          end do\n+        end do\n+      end do\n+    end do\n+    !$omp single\n+    if (i.ne.1.or.j.ne.-1.or.k.ne.2.or.m.ne.0) call abort\n+    !$omp end single\n+    !$omp do collapse(2) ordered(4) lastprivate (i,j,k)\n+    do i = 0, d\n+      do j = d, 1, -1\n+        do k = 0, d + 1\n+          do l = 0, d + 3\n+            !$omp ordered depend(source)\n+            !$omp ordered depend(sink: i-2,j+2,k-2,l)\n+            if (e.eq.0) call abort\n+          end do\n+        end do\n+      end do\n+    end do\n+    !$omp end do nowait\n+    !$omp do\n+    do i = 1, N\n+      if (a(i) .ne. 3) call abort\n+    end do\n+    !$omp end do nowait\n+    !$omp do collapse(2) private(k)\n+    do i = 1, N / 16\n+      do j = 1, 8\n+        do k = 1, 4\n+          if (i.ge.3.and.i.lt.N/16.and.iand(j,1).ne.0.and.k.ge.2) then\n+            if (b(i,j,k).ne.3) call abort\n+          else\n+            if (b(i,j,k).ne.0) call abort\n+          end if\n+        end do\n+      end do\n+    end do\n+    !$omp end do nowait\n+    !$omp do collapse(3)\n+    do i = 1, N / 32\n+      do j = 1, 8\n+        do k = 1, 4\n+          if (j.ge.3.and.iand(k,1).ne.0) then\n+            if (c(i,j,k).ne.3) call abort\n+          else\n+            if (c(i,j,k).ne.0) call abort\n+          end if\n+        end do\n+      end do\n+    end do\n+    !$omp end do nowait\n+  !$omp end parallel\n+end"}, {"sha": "ddc0c99fd1753d423bf8c55d44f419891bca25a2", "filename": "libgomp/testsuite/libgomp.fortran/doacross2.f90", "status": "added", "additions": 261, "deletions": 0, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c3a85be96585374bf95c981ba2f602667cf5b7/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fdoacross2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c3a85be96585374bf95c981ba2f602667cf5b7/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fdoacross2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fdoacross2.f90?ref=b4c3a85be96585374bf95c981ba2f602667cf5b7", "patch": "@@ -0,0 +1,261 @@\n+! { dg-do run }\n+\n+  integer, parameter :: N = 256\n+  integer, save :: a(N), b(N / 16, 8, 4), c(N / 32, 8, 8), g(N/16,8,6)\n+  integer, save, volatile :: d, e\n+  integer(kind=8), save, volatile :: f\n+  integer(kind=8) :: i\n+  integer :: j, k, l, m\n+  integer :: m1, m2, m3, m4, m5, m6, m7, m8\n+  integer :: m9, m10, m11, m12, m13, m14, m15, m16\n+  d = 0\n+  e = 0\n+  f = 0\n+  !$omp parallel private (l) shared(k)\n+    !$omp do schedule(static, 1) ordered(1)\n+    do i = 2, N + f\n+      !$omp atomic write\n+      a(i) = 1\n+      !$omp ordered depend ( sink : i - 1 )\n+      if (i.gt.2) then\n+        !$omp atomic read\n+        l = a(i - 1)\n+        if (l.lt.2) call abort\n+      end if\n+      !$omp atomic write\n+      a(i) = 2\n+      if (i.lt.N) then\n+        !$omp atomic read\n+        l = a(i + 1)\n+        if (l.eq.3) call abort\n+      end if\n+      !$omp ordered depend(source)\n+      !$omp atomic write\n+      a(i) = 3\n+    end do\n+    !$omp end do nowait\n+    !$omp do schedule(static) ordered ( 3 )\n+    do i = 4, N / 16 - 1 + f\n+      do j = 1, 8, 2\n+        do k = 2, 4\n+          !$omp atomic write\n+          b(i, j, k) = 1\n+          !$omp ordered depend(sink:i,j-2,k-1) &\n+          !$omp& depend(sink: i - 2, j - 2, k + 1)\n+          !$omp ordered depend(sink:i-3,j+2,k-2)\n+          if (j.gt.2.and.k.gt.2) then\n+            !$omp atomic read\n+            l = b(i,j-2,k-1)\n+            if (l.lt.2) call abort\n+          end if\n+          !$omp atomic write\n+          b(i,j,k) = 2\n+          if (i.gt.5.and.j.gt.2.and.k.lt.4) then\n+            !$omp atomic read\n+            l = b(i-2,j-2, k+1)\n+            if (l.lt.2) call abort\n+          end if\n+          if (i.gt.6.and.j.le.N/16-3.and.k.eq.4) then\n+            !$omp atomic read\n+            l = b( i - 3, j+2, k-2)\n+            if (l.lt.2) call abort\n+          end if\n+          !$omp ordered depend(source)\n+          !$omp atomic write\n+          b(i, j, k) = 3\n+        end do\n+      end do\n+    end do\n+    !$omp end do nowait\n+    !$omp do schedule(dynamic, 15) collapse(2) ordered(13)\n+    do i = 3, N / 32 + f\n+      do j = 8, 3, -1\n+        do k = 7, 1, -2\n+          do m1 = 4, 4\n+          do m2 = 4, 4\n+          do m3 = 4, 4\n+          do m4 = 4, 4\n+          do m5 = 4, 4\n+          do m6 = 4, 4\n+          do m7 = 4, 4\n+          do m8 = 4, 4\n+          do m9 = 4, 4\n+          do m10 = 4, 4\n+          do m11 = 4, 4\n+          do m12 = 4, 4\n+          do m13 = 4, 4\n+          do m14 = 4, 4\n+          do m15 = 4, 4\n+          do m16 = 4, 4\n+            !$omp atomic write\n+            c(i, j, k) = 1\n+            !$omp ordered depend(sink: i, j, k + 2, m1, m2, m3, m4, &\n+            !$omp & m5, m6, m7, m8, m9, m10) &\n+            !$omp depend(sink: i - 2, j + 1, k - 4, m1,m2,m3,m4,m5, &\n+            !$omp & m6,m7,m8,m9,m10) depend ( sink : i-1,j-2,k-2, &\n+            !$omp& m1,m2,m3,m4 , m5, m6,m7,m8,m9,m10 )\n+            if (k.le.5) then\n+              !$omp atomic read\n+              l = c(i, j, k + 2)\n+              if (l.lt.2) call abort\n+            end if\n+            !$omp atomic write\n+            c(i, j, k) = 2\n+            if (i.ge.5.and.j.lt.8.and.k.ge.5) then\n+              !$omp atomic read\n+              l = c(i - 2, j + 1, k - 4)\n+              if (l.lt.2) call abort\n+            end if\n+            if (i.ge.4.and.j.ge.5.and.k.ge.3) then\n+              !$omp atomic read\n+              l = c(i - 1, j - 2, k - 2)\n+              if (l.lt.2) call abort\n+            end if\n+            !$omp ordered depend ( source )\n+            !$omp atomic write\n+            c(i,j,k)=3\n+          end do\n+          end do\n+          end do\n+          end do\n+          end do\n+          end do\n+          end do\n+          end do\n+          end do\n+          end do\n+          end do\n+          end do\n+          end do\n+          end do\n+          end do\n+          end do\n+        end do\n+      end do\n+    end do\n+    !$omp do schedule(static) ordered(3)\n+    do j = 1, N / 16 - 1\n+      do k = 1, 7, 2\n+        do i = 4, 6 + f\n+          !$omp atomic write\n+          g(j, k, i) = 1\n+          !$omp ordered depend(sink: j, k-2,i-1) &\n+          !$omp& depend(sink: j - 2, k - 2, i + 1)\n+          !$omp ordered depend(sink:j-3,k+2,i-2)\n+          if (k.gt.2.and.i.gt.4) then\n+            !$omp atomic read\n+            l = g(j,k-2,i-1)\n+            if (l.lt.2) call abort\n+          end if\n+          !$omp atomic write\n+          g(j,k,i) = 2\n+          if (j.gt.2.and.k.gt.2.and.i.lt.6) then\n+            !$omp atomic read\n+            l = g(j-2,k-2, i+1)\n+            if (l.lt.2) call abort\n+          end if\n+          if (j.gt.3.and.k.le.N/16-3.and.i.eq.6) then\n+            !$omp atomic read\n+            l = g( j - 3, k+2, i-2)\n+            if (l.lt.2) call abort\n+          end if\n+          !$omp ordered depend(source)\n+          !$omp atomic write\n+          g(j, k, i) = 3\n+        end do\n+      end do\n+    end do\n+    !$omp end do nowait\n+    !$omp do collapse(2) ordered(4) lastprivate (i,j,k)\n+    do i = 2, f + 2\n+      do j = d + 1, 0, -1\n+        do k = 0, d - 1\n+          do l = 0, d + 1\n+            !$omp ordered depend(source)\n+            !$omp ordered depend(sink: i-2,j+2,k-2,l)\n+            if (e.eq.0) call abort\n+          end do\n+        end do\n+      end do\n+    end do\n+    !$omp single\n+    if (i.ne.3.or.j.ne.-1.or.k.ne.0) call abort\n+    i = 8; j = 9; k = 10\n+    !$omp end single\n+    !$omp do ordered(4) collapse(2) lastprivate (i, j, k, m)\n+    do i = 2, f + 2\n+      do j = d + 1, 0, -1\n+        do k = 0, d + 1\n+          do m = 0, d-1\n+            !$omp ordered depend(source)\n+            !$omp ordered depend(sink: i - 2, j + 2, k - 2, m)\n+            call abort\n+          end do\n+        end do\n+      end do\n+    end do\n+    !$omp single\n+    if (i.ne.3.or.j.ne.-1.or.k.ne.2.or.m.ne.0) call abort\n+    !$omp end single\n+    !$omp do collapse(2) ordered(4) lastprivate (i,j,k)\n+    do i = 2, f + 2\n+      do j = d, 1, -1\n+        do k = 0, d + 1\n+          do l = 0, d + 3\n+            !$omp ordered depend(source)\n+            !$omp ordered depend(sink: i-2,j+2,k-2,l)\n+            if (e.eq.0) call abort\n+          end do\n+        end do\n+      end do\n+    end do\n+    !$omp end do nowait\n+    !$omp single\n+    if (a(1) .ne. 0) call abort\n+    !$omp end single nowait\n+    !$omp do\n+    do i = 2, N\n+      if (a(i) .ne. 3) call abort\n+    end do\n+    !$omp end do nowait\n+    !$omp do collapse(2) private(k)\n+    do i = 1, N / 16\n+      do j = 1, 8\n+        do k = 1, 4\n+          if (i.ge.4.and.i.lt.N/16.and.iand(j,1).ne.0.and.k.ge.2) then\n+            if (b(i,j,k).ne.3) call abort\n+          else\n+            if (b(i,j,k).ne.0) call abort\n+          end if\n+        end do\n+      end do\n+    end do\n+    !$omp end do nowait\n+    !$omp do collapse(3)\n+    do i = 1, N / 32\n+      do j = 1, 8\n+        do k = 1, 4\n+          if (i.ge.3.and.j.ge.3.and.iand(k,1).ne.0) then\n+            if (c(i,j,k).ne.3) call abort\n+          else\n+            if (c(i,j,k).ne.0) call abort\n+          end if\n+        end do\n+      end do\n+    end do\n+    !$omp end do nowait\n+    !$omp do collapse(2) private(k)\n+    do i = 1, N / 16\n+      do j = 1, 8\n+        do k = 1, 6\n+          if (i.lt.N/16.and.iand(j,1).ne.0.and.k.ge.4) then\n+            if (g(i,j,k).ne.3) call abort\n+          else\n+            if (g(i,j,k).ne.0) call abort\n+          end if\n+        end do\n+      end do\n+    end do\n+    !$omp end do nowait\n+  !$omp end parallel\n+end"}, {"sha": "66cfb06284b2a6b1772ca3a01dbcd602ac68c722", "filename": "libgomp/testsuite/libgomp.fortran/doacross3.f90", "status": "added", "additions": 261, "deletions": 0, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c3a85be96585374bf95c981ba2f602667cf5b7/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fdoacross3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c3a85be96585374bf95c981ba2f602667cf5b7/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fdoacross3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fdoacross3.f90?ref=b4c3a85be96585374bf95c981ba2f602667cf5b7", "patch": "@@ -0,0 +1,261 @@\n+! { dg-do run }\n+\n+  integer, parameter :: N = 256\n+  integer, save :: a(N), b(N / 16, 8, 4), c(N / 32, 8, 8), g(N/16,8,6)\n+  integer, save, volatile :: d, e\n+  integer(kind=8), save, volatile :: f\n+  integer(kind=8) :: i\n+  integer :: j, k, l, m\n+  integer :: m1, m2, m3, m4, m5, m6, m7, m8\n+  integer :: m9, m10, m11, m12, m13, m14, m15, m16\n+  d = 0\n+  e = 0\n+  f = 0\n+  !$omp parallel private (l) shared(k)\n+    !$omp do schedule(guided, 3) ordered(1)\n+    do i = 2, N + f, f + 1\n+      !$omp atomic write\n+      a(i) = 1\n+      !$omp ordered depend ( sink : i - 1 )\n+      if (i.gt.2) then\n+        !$omp atomic read\n+        l = a(i - 1)\n+        if (l.lt.2) call abort\n+      end if\n+      !$omp atomic write\n+      a(i) = 2\n+      if (i.lt.N) then\n+        !$omp atomic read\n+        l = a(i + 1)\n+        if (l.eq.3) call abort\n+      end if\n+      !$omp ordered depend(source)\n+      !$omp atomic write\n+      a(i) = 3\n+    end do\n+    !$omp end do nowait\n+    !$omp do schedule(guided) ordered ( 3 )\n+    do i = 4, N / 16 - 1 + f, 1 + f\n+      do j = 1, 8, d + 2\n+        do k = 2, 4, 1 + d\n+          !$omp atomic write\n+          b(i, j, k) = 1\n+          !$omp ordered depend(sink:i,j-2,k-1) &\n+          !$omp& depend(sink: i - 2, j - 2, k + 1)\n+          !$omp ordered depend(sink:i-3,j+2,k-2)\n+          if (j.gt.2.and.k.gt.2) then\n+            !$omp atomic read\n+            l = b(i,j-2,k-1)\n+            if (l.lt.2) call abort\n+          end if\n+          !$omp atomic write\n+          b(i,j,k) = 2\n+          if (i.gt.5.and.j.gt.2.and.k.lt.4) then\n+            !$omp atomic read\n+            l = b(i-2,j-2, k+1)\n+            if (l.lt.2) call abort\n+          end if\n+          if (i.gt.6.and.j.le.N/16-3.and.k.eq.4) then\n+            !$omp atomic read\n+            l = b( i - 3, j+2, k-2)\n+            if (l.lt.2) call abort\n+          end if\n+          !$omp ordered depend(source)\n+          !$omp atomic write\n+          b(i, j, k) = 3\n+        end do\n+      end do\n+    end do\n+    !$omp end do nowait\n+    !$omp do schedule(guided, 15) collapse(2) ordered(13)\n+    do i = 3, N / 32 + f, d + 1\n+      do j = 8, 3, d - 1\n+        do k = 7, 1, d - 2\n+          do m1 = 4, 4, d + 1\n+          do m2 = 4, 4, 1 + d\n+          do m3 = 4, 4, d + 1\n+          do m4 = 4, 4, 1 + d\n+          do m5 = 4, 4, d + 1\n+          do m6 = 4, 4, 1 + d\n+          do m7 = 4, 4, d + 1\n+          do m8 = 4, 4, 1 + d\n+          do m9 = 4, 4\n+          do m10 = 4, 4, d + 1\n+          do m11 = 4, 4, 1 + d\n+          do m12 = 4, 4, d + 1\n+          do m13 = 4, 4\n+          do m14 = 4, 4, 1 + d\n+          do m15 = 4, 4, d + 1\n+          do m16 = 4, 4, 1 + d\n+            !$omp atomic write\n+            c(i, j, k) = 1\n+            !$omp ordered depend(sink: i, j, k + 2, m1, m2, m3, m4, &\n+            !$omp & m5, m6, m7, m8, m9, m10) &\n+            !$omp depend(sink: i - 2, j + 1, k - 4, m1,m2,m3,m4,m5, &\n+            !$omp & m6,m7,m8,m9,m10) depend ( sink : i-1,j-2,k-2, &\n+            !$omp& m1,m2,m3,m4 , m5, m6,m7,m8,m9,m10 )\n+            if (k.le.5) then\n+              !$omp atomic read\n+              l = c(i, j, k + 2)\n+              if (l.lt.2) call abort\n+            end if\n+            !$omp atomic write\n+            c(i, j, k) = 2\n+            if (i.ge.5.and.j.lt.8.and.k.ge.5) then\n+              !$omp atomic read\n+              l = c(i - 2, j + 1, k - 4)\n+              if (l.lt.2) call abort\n+            end if\n+            if (i.ge.4.and.j.ge.5.and.k.ge.3) then\n+              !$omp atomic read\n+              l = c(i - 1, j - 2, k - 2)\n+              if (l.lt.2) call abort\n+            end if\n+            !$omp ordered depend ( source )\n+            !$omp atomic write\n+            c(i,j,k)=3\n+          end do\n+          end do\n+          end do\n+          end do\n+          end do\n+          end do\n+          end do\n+          end do\n+          end do\n+          end do\n+          end do\n+          end do\n+          end do\n+          end do\n+          end do\n+          end do\n+        end do\n+      end do\n+    end do\n+    !$omp do schedule(guided, 5) ordered(3)\n+    do j = 1, N / 16 - 1, d + 1\n+      do k = 1, 7, 2 + d\n+        do i = 4, 6 + f, f + 1\n+          !$omp atomic write\n+          g(j, k, i) = 1\n+          !$omp ordered depend(sink: j, k-2,i-1) &\n+          !$omp& depend(sink: j - 2, k - 2, i + 1)\n+          !$omp ordered depend(sink:j-3,k+2,i-2)\n+          if (k.gt.2.and.i.gt.4) then\n+            !$omp atomic read\n+            l = g(j,k-2,i-1)\n+            if (l.lt.2) call abort\n+          end if\n+          !$omp atomic write\n+          g(j,k,i) = 2\n+          if (j.gt.2.and.k.gt.2.and.i.lt.6) then\n+            !$omp atomic read\n+            l = g(j-2,k-2, i+1)\n+            if (l.lt.2) call abort\n+          end if\n+          if (j.gt.3.and.k.le.N/16-3.and.i.eq.6) then\n+            !$omp atomic read\n+            l = g( j - 3, k+2, i-2)\n+            if (l.lt.2) call abort\n+          end if\n+          !$omp ordered depend(source)\n+          !$omp atomic write\n+          g(j, k, i) = 3\n+        end do\n+      end do\n+    end do\n+    !$omp end do nowait\n+    !$omp do collapse(2) ordered(4) lastprivate (i,j,k)\n+    do i = 2, f + 2, 1 + f\n+      do j = d + 1, 0, d - 1\n+        do k = 0, d - 1, d + 1\n+          do l = 0, d + 1, 1 + d\n+            !$omp ordered depend(source)\n+            !$omp ordered depend(sink: i-2,j+2,k-2,l)\n+            if (e.eq.0) call abort\n+          end do\n+        end do\n+      end do\n+    end do\n+    !$omp single\n+    if (i.ne.3.or.j.ne.-1.or.k.ne.0) call abort\n+    i = 8; j = 9; k = 10\n+    !$omp end single\n+    !$omp do ordered(4) collapse(2) lastprivate (i, j, k, m)\n+    do i = 2, f + 2, 1 + f\n+      do j = d + 1, 0, d - 1\n+        do k = 0, d + 1, 1 + d\n+          do m = 0, d-1, d+1\n+            !$omp ordered depend(source)\n+            !$omp ordered depend(sink: i - 2, j + 2, k - 2, m)\n+            call abort\n+          end do\n+        end do\n+      end do\n+    end do\n+    !$omp single\n+    if (i.ne.3.or.j.ne.-1.or.k.ne.2.or.m.ne.0) call abort\n+    !$omp end single\n+    !$omp do collapse(2) ordered(4) lastprivate (i,j,k)\n+    do i = 2, f + 2, 1 + f\n+      do j = d, 1, d -1\n+        do k = 0, d + 1, 1 + d\n+          do l = 0, d + 3, d + 1\n+            !$omp ordered depend(source)\n+            !$omp ordered depend(sink: i-2,j+2,k-2,l)\n+            if (e.eq.0) call abort\n+          end do\n+        end do\n+      end do\n+    end do\n+    !$omp end do nowait\n+    !$omp single\n+    if (a(1) .ne. 0) call abort\n+    !$omp end single nowait\n+    !$omp do\n+    do i = 2, N\n+      if (a(i) .ne. 3) call abort\n+    end do\n+    !$omp end do nowait\n+    !$omp do collapse(2) private(k)\n+    do i = 1, N / 16\n+      do j = 1, 8\n+        do k = 1, 4\n+          if (i.ge.4.and.i.lt.N/16.and.iand(j,1).ne.0.and.k.ge.2) then\n+            if (b(i,j,k).ne.3) call abort\n+          else\n+            if (b(i,j,k).ne.0) call abort\n+          end if\n+        end do\n+      end do\n+    end do\n+    !$omp end do nowait\n+    !$omp do collapse(3)\n+    do i = 1, N / 32\n+      do j = 1, 8\n+        do k = 1, 4\n+          if (i.ge.3.and.j.ge.3.and.iand(k,1).ne.0) then\n+            if (c(i,j,k).ne.3) call abort\n+          else\n+            if (c(i,j,k).ne.0) call abort\n+          end if\n+        end do\n+      end do\n+    end do\n+    !$omp end do nowait\n+    !$omp do collapse(2) private(k)\n+    do i = 1, N / 16\n+      do j = 1, 8\n+        do k = 1, 6\n+          if (i.lt.N/16.and.iand(j,1).ne.0.and.k.ge.4) then\n+            if (g(i,j,k).ne.3) call abort\n+          else\n+            if (g(i,j,k).ne.0) call abort\n+          end if\n+        end do\n+      end do\n+    end do\n+    !$omp end do nowait\n+  !$omp end parallel\n+end"}, {"sha": "dcd2c4a0c25ad32e6ca3688381ac4e6f24bd03fe", "filename": "libgomp/testsuite/libgomp.fortran/examples-4/declare_target-1.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c3a85be96585374bf95c981ba2f602667cf5b7/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fdeclare_target-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c3a85be96585374bf95c981ba2f602667cf5b7/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fdeclare_target-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fdeclare_target-1.f90?ref=b4c3a85be96585374bf95c981ba2f602667cf5b7", "patch": "@@ -17,7 +17,7 @@ integer recursive function fib (n) result (f)\n \n   integer function fib_wrapper (n)\n     integer :: x\n-    !$omp target map(to: n) if(n > THRESHOLD)\n+    !$omp target map(to: n) map(from: x) if(n > THRESHOLD)\n       x = fib (n)\n     !$omp end target\n     fib_wrapper = x"}, {"sha": "0fb64af7e6d77258bf92d6489da4b7047866acc7", "filename": "libgomp/testsuite/libgomp.fortran/examples-4/declare_target-2.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c3a85be96585374bf95c981ba2f602667cf5b7/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fdeclare_target-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c3a85be96585374bf95c981ba2f602667cf5b7/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fdeclare_target-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fdeclare_target-2.f90?ref=b4c3a85be96585374bf95c981ba2f602667cf5b7", "patch": "@@ -3,7 +3,7 @@\n program e_53_2\n   !$omp declare target (fib)\n   integer :: x, fib\n-  !$omp target\n+  !$omp target map(from: x)\n     x = fib (25)\n   !$omp end target\n   if (x /= fib (25)) call abort"}, {"sha": "7b4d7e37eb26f44eb5f201783351affdc3db69fd", "filename": "libgomp/testsuite/libgomp.fortran/examples-4/declare_target-4.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c3a85be96585374bf95c981ba2f602667cf5b7/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fdeclare_target-4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c3a85be96585374bf95c981ba2f602667cf5b7/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fdeclare_target-4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fdeclare_target-4.f90?ref=b4c3a85be96585374bf95c981ba2f602667cf5b7", "patch": "@@ -16,7 +16,7 @@ real function accum (k) result (tmp)\n   use e_53_4_mod\n   integer :: i, k\n   tmp = 0.0e0\n-  !$omp target\n+  !$omp target map(tmp)\n     !$omp parallel do reduction(+:tmp)\n     do i = 1, N\n       tmp = tmp + Pfun (k, i)"}, {"sha": "94bd6c1a21ae0a84b171c9ebee28badfa5df6224", "filename": "libgomp/testsuite/libgomp.fortran/examples-4/declare_target-5.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c3a85be96585374bf95c981ba2f602667cf5b7/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fdeclare_target-5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c3a85be96585374bf95c981ba2f602667cf5b7/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fdeclare_target-5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fdeclare_target-5.f90?ref=b4c3a85be96585374bf95c981ba2f602667cf5b7", "patch": "@@ -21,7 +21,7 @@ real function accum () result (tmp)\n   real :: tmp1\n   integer :: i\n   tmp = 0.0e0\n-  !$omp target\n+  !$omp target map(tofrom: tmp)\n     !$omp parallel do private(tmp1) reduction(+:tmp)\n     do i = 1, N\n       tmp1 = 0.0e0"}, {"sha": "a05c54fb20ff148e3841e52a3d55f9bc19d52822", "filename": "libgomp/testsuite/libgomp.fortran/examples-4/target_data-3.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c3a85be96585374bf95c981ba2f602667cf5b7/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Ftarget_data-3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c3a85be96585374bf95c981ba2f602667cf5b7/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Ftarget_data-3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Ftarget_data-3.f90?ref=b4c3a85be96585374bf95c981ba2f602667cf5b7", "patch": "@@ -45,7 +45,7 @@ subroutine gramSchmidt (Q, rows, cols)\n     !$omp target data map(Q)\n       do k = 1, cols\n         tmp = 0.0d0\n-        !$omp target\n+        !$omp target map(tofrom: tmp)\n           !$omp parallel do reduction(+:tmp)\n           do i = 1, rows\n             tmp = tmp + (Q(i,k) * Q(i,k))"}, {"sha": "da5816adb4af617564205a2cde397c4fac4d902a", "filename": "libgomp/testsuite/libgomp.fortran/examples-4/teams-2.f90", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c3a85be96585374bf95c981ba2f602667cf5b7/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fteams-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c3a85be96585374bf95c981ba2f602667cf5b7/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fteams-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fteams-2.f90?ref=b4c3a85be96585374bf95c981ba2f602667cf5b7", "patch": "@@ -15,7 +15,8 @@ function dotprod (B, C, N, block_size, num_teams, block_threads) result (sum)\n   real :: B(N), C(N), sum\n   integer :: N, block_size, num_teams, block_threads, i, i0\n   sum = 0.0e0\n-  !$omp target map(to: B, C, block_size, num_teams, block_threads)\n+  !$omp target map(to: B, C, block_size, num_teams, block_threads) &\n+  !$omp& map(tofrom: sum)\n     !$omp teams num_teams(num_teams) thread_limit(block_threads) &\n     !$omp& reduction(+:sum)\n       !$omp distribute"}, {"sha": "6f306f01d6d4d4e270a2cb82e626645bbd5f801a", "filename": "libgomp/testsuite/libgomp.fortran/nestedfn5.f90", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c3a85be96585374bf95c981ba2f602667cf5b7/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fnestedfn5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c3a85be96585374bf95c981ba2f602667cf5b7/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fnestedfn5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fnestedfn5.f90?ref=b4c3a85be96585374bf95c981ba2f602667cf5b7", "patch": "@@ -52,7 +52,7 @@ subroutine foo\n !$omp end parallel\n     b = 10\n !$omp target data map (tofrom: a, d(2:3,4:4), q) map (from: l)\n-!$omp target map (tofrom: b, d(2:3,4:4))\n+!$omp target map (tofrom: b, d(2:3,4:4)) map (alloc: a, l)\n     l = .false.\n     if (a /= 22 .or. any (q /= 5)) l = .true.\n     if (lbound (q, 1) /= 19 .or. ubound (q, 1) /= 27) l = .true.\n@@ -71,7 +71,7 @@ subroutine foo\n     q = 14\n     d = 15\n !$omp target update to (a, q, d(2:3,4:4))\n-!$omp target map (tofrom: b, d(2:3,4:4))\n+!$omp target map (tofrom: b, d(2:3,4:4)) map (alloc: a, l)\n     if (a /= 12 .or. b /= 13 .or. any (q /= 14)) l = .true.\n     l = l .or. any (d(2:3,4:4) /= 15)\n !$omp end target\n@@ -85,7 +85,8 @@ subroutine foo\n     if (l) call abort\n !$omp target teams distribute parallel do simd if (.not.l) device(a) &\n !$omp & num_teams(b) dist_schedule(static, c) num_threads (h) &\n-!$omp & reduction (+: m) safelen (n) schedule(static, o)\n+!$omp & reduction (+: m) safelen (n) schedule(static, o) &\n+!$omp & defaultmap(tofrom: scalar)\n     do p = 1, 64\n       m = m + 1\n     end do"}, {"sha": "e17ab96c7dc391483d12d5c99283acd4849f7cae", "filename": "libgomp/testsuite/libgomp.fortran/pr66199-2.f90", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c3a85be96585374bf95c981ba2f602667cf5b7/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fpr66199-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c3a85be96585374bf95c981ba2f602667cf5b7/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fpr66199-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fpr66199-2.f90?ref=b4c3a85be96585374bf95c981ba2f602667cf5b7", "patch": "@@ -14,12 +14,11 @@\n   c = 17\n   d = 75\n   !$omp target teams distribute parallel do simd default(none) &\n-  !$omp& firstprivate (a, b) shared(u, v, w) &\n-  !$omp& linear(d) linear(c:5) lastprivate(e)\n+  !$omp& firstprivate (a, b, c) shared(u, v, w) &\n+  !$omp& linear(d) lastprivate(e)\n   do d = a, b\n     u(d) = v(d) + w(d)\n-    c = c + 5\n-    e = c\n+    e = c + d * 5\n   end do\n   a1 = 0\n   a2 = 0"}, {"sha": "2ff5db81bc8d959f8b81cc44198336bf7baade17", "filename": "libgomp/testsuite/libgomp.fortran/target4.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c3a85be96585374bf95c981ba2f602667cf5b7/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c3a85be96585374bf95c981ba2f602667cf5b7/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget4.f90?ref=b4c3a85be96585374bf95c981ba2f602667cf5b7", "patch": "@@ -8,7 +8,7 @@ subroutine foo (a,m,n)\n     !$omp target data map(a) map(to: m, n)\n     do i=1,n\n       t = 0.0d0\n-      !$omp target\n+      !$omp target map(t)\n         !$omp parallel do reduction(+:t)\n           do j=1,m\n             t = t + a(j,i) * a(j,i)"}, {"sha": "92f414c4d50d40fdec8a46188f1cbd75703385df", "filename": "libgomp/testsuite/libgomp.fortran/taskloop1.f90", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c3a85be96585374bf95c981ba2f602667cf5b7/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftaskloop1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c3a85be96585374bf95c981ba2f602667cf5b7/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftaskloop1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftaskloop1.f90?ref=b4c3a85be96585374bf95c981ba2f602667cf5b7", "patch": "@@ -0,0 +1,44 @@\n+  common /blk/ q, e\n+  integer :: q, r\n+  logical :: e\n+!$omp parallel\n+!$omp single\n+  call foo (2, 7)\n+  r = bar (12, 18)\n+!$omp end single\n+!$omp end parallel\n+  if (q .ne. 6 .or. r .ne. 17 .or. e) call abort\n+contains\n+  subroutine foo (a, b)\n+    integer, intent (in) :: a, b\n+    common /blk/ q, e\n+    integer :: q, r, d\n+    logical :: e\n+!$omp taskloop lastprivate (q) nogroup\n+    do d = a, b, 2\n+      q = d\n+      if (d < 2 .or. d > 6 .or. iand (d, 1) .ne. 0) then\n+!$omp atomic write\n+        e = .true.\n+      end if\n+    end do\n+  end subroutine foo\n+  function bar (a, b)\n+    integer, intent (in) :: a, b\n+    integer :: bar\n+    common /blk/ q, e\n+    integer :: q, r, d, s\n+    logical :: e\n+    s = 7\n+!$omp taskloop lastprivate (s)\n+    do d = a, b - 1\n+      if (d < 12 .or. d > 17) then\n+!$omp atomic write\n+        e = .true.\n+      end if\n+      s = d\n+    end do\n+!$omp end taskloop\n+    bar = s\n+  end function bar\n+end"}, {"sha": "dfd003b7682ec23bd691d2090d7d0cb92a83cc48", "filename": "libgomp/testsuite/libgomp.fortran/taskloop2.f90", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c3a85be96585374bf95c981ba2f602667cf5b7/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftaskloop2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c3a85be96585374bf95c981ba2f602667cf5b7/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftaskloop2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftaskloop2.f90?ref=b4c3a85be96585374bf95c981ba2f602667cf5b7", "patch": "@@ -0,0 +1,134 @@\n+! { dg-do run }\n+! { dg-options \"-O2\" }\n+! { dg-additional-options \"-msse2\" { target sse2_runtime } }\n+! { dg-additional-options \"-mavx\" { target avx_runtime } }\n+\n+  integer, save :: u(1024), v(1024), w(1024), m\n+  integer :: i\n+  v = (/ (i, i = 1, 1024) /)\n+  w = (/ (i + 1, i = 1, 1024) /)\n+  !$omp parallel\n+  !$omp single\n+  call f1 (1, 1024)\n+  !$omp end single\n+  !$omp end parallel\n+  do i = 1, 1024\n+    if (u(i) .ne. 2 * i + 1) call abort\n+    v(i) = 1024 - i\n+    w(i) = 512 - i\n+  end do\n+  !$omp parallel\n+  !$omp single\n+    call f2 (2, 1022, 17)\n+  !$omp end single\n+  !$omp end parallel\n+  do i = 1, 1024\n+    if (i .lt. 2 .or. i .gt. 1022) then\n+      if (u(i) .ne. 2 * i + 1) call abort\n+    else\n+      if (u(i) .ne. 1536 - 2 * i) call abort\n+    end if\n+    v(i) = i\n+    w(i) = i + 1\n+  end do\n+  if (m .ne. (1023 + 2 * (1021 * 5 + 17) + 9)) call abort\n+  !$omp parallel\n+  !$omp single\n+    call f3 (1, 1024)\n+  !$omp end single\n+  !$omp end parallel \n+  do i = 1, 1024\n+    if (u(i) .ne. 2 * i + 1) call abort\n+    v(i) = 1024 - i\n+    w(i) = 512 - i\n+  end do\n+  if (m .ne. 1025) call abort\n+  !$omp parallel\n+  !$omp single\n+    call f4 (0, 31, 1, 32)\n+  !$omp end single\n+  !$omp end parallel \n+  do i = 1, 1024\n+    if (u(i) .ne. 1536 - 2 * i) call abort\n+    v(i) = i\n+    w(i) = i + 1\n+  end do\n+  if (m .ne. 32 + 33 + 1024) call abort\n+  !$omp parallel\n+  !$omp single\n+    call f5 (0, 31, 1, 32)\n+  !$omp end single\n+  !$omp end parallel \n+  do i = 1, 1024\n+    if (u(i) .ne. 2 * i + 1) call abort\n+  end do\n+  if (m .ne. 32 + 33) call abort\n+contains\n+  subroutine f1 (a, b)\n+    integer, intent(in) :: a, b\n+    integer :: d\n+    !$omp taskloop simd default(none) shared(u, v, w) nogroup\n+    do d = a, b\n+      u(d) = v(d) + w(d)\n+    end do\n+    ! d is predetermined linear, so we can't let the tasks continue past\n+    ! end of this function.\n+    !$omp taskwait\n+  end subroutine f1\n+  subroutine f2 (a, b, cx)\n+    integer, intent(in) :: a, b, cx\n+    integer :: c, d, e\n+    c = cx\n+    !$omp taskloop simd default(none) shared(u, v, w) linear(d:1) linear(c:5) lastprivate(e)\n+    do d = a, b\n+      u(d) = v(d) + w(d)\n+      c = c + 5\n+      e = c + 9\n+    end do\n+    !$omp end taskloop simd\n+    m = d + c + e\n+  end subroutine f2\n+  subroutine f3 (a, b)\n+    integer, intent(in) :: a, b\n+    integer, target :: d\n+    integer, pointer :: p\n+    !$omp taskloop simd default(none) shared(u, v, w) private (p)\n+    do d = a, b\n+      p => d\n+      u(d) = v(d) + w(d)\n+      p => null()\n+    end do\n+    m = d\n+  end subroutine f3\n+  subroutine f4 (a, b, c, d)\n+    integer, intent(in) :: a, b, c, d\n+    integer, target :: e, f\n+    integer, pointer :: p, q\n+    integer :: g, r\n+    !$omp taskloop simd default(none) shared(u, v, w) lastprivate(g) collapse(2) private (r, p, q)\n+    do e = a, b\n+      do f = c, d\n+        p => e\n+        q => f\n+        r = 32 * e + f\n+        u(r) = v(r) + w(r)\n+        g = r\n+        p => null()\n+        q => null()\n+      end do\n+    end do\n+    m = e + f + g\n+  end subroutine f4\n+  subroutine f5 (a, b, c, d)\n+    integer, intent(in) :: a, b, c, d\n+    integer :: e, f, r\n+    !$omp taskloop simd default(none) shared(u, v, w) collapse(2) private (r)\n+    do e = a, b\n+      do f = c, d\n+        r = 32 * e + f\n+        u(r) = v(r) + w(r)\n+      end do\n+    end do\n+    m = e + f\n+  end subroutine f5\n+end"}, {"sha": "748433baf553b6c9d644c63f63e1897cb6a7f91e", "filename": "libgomp/testsuite/libgomp.fortran/taskloop3.f90", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c3a85be96585374bf95c981ba2f602667cf5b7/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftaskloop3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c3a85be96585374bf95c981ba2f602667cf5b7/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftaskloop3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftaskloop3.f90?ref=b4c3a85be96585374bf95c981ba2f602667cf5b7", "patch": "@@ -0,0 +1,72 @@\n+! { dg-do run }\n+! { dg-options \"-O2\" }\n+\n+  integer, save :: g\n+  integer :: i\n+  !$omp parallel\n+  !$omp single\n+    if (f1 (74) .ne. 63 + 4) call abort\n+    g = 77\n+    call f2\n+    !$omp taskwait\n+    if (g .ne. 63 + 9) call abort\n+    if (f3 (7_8, 11_8, 2_8) .ne. 11 * 7 + 13) call abort\n+    if (f4 (0_8, 31_8, 16_8, 46_8, 1_8, 2_8, 73) .ne. 32 + 5 * 48 &\n+&       + 11 * 31 + 17 * 46) call abort\n+  !$omp end single\n+  !$omp end parallel\n+contains\n+  function f1 (y)\n+    integer, intent(in) :: y\n+    integer :: i, f1, x\n+    x = y\n+    !$omp taskloop firstprivate(x)lastprivate(x)\n+    do i = 0, 63\n+      if (x .ne. 74) call abort\n+      if (i .eq. 63) then\n+        x = i + 4\n+      end if\n+    end do\n+    f1 = x\n+  end function f1\n+  subroutine f2 ()\n+    integer :: i\n+    !$omp taskloop firstprivate(g)lastprivate(g)nogroup\n+    do i = 0, 63\n+      if (g .ne. 77) call abort\n+      if (i .eq. 63) then\n+        g = i + 9\n+      end if\n+    end do\n+  end subroutine f2\n+  function f3 (a, b, c)\n+    integer(kind=8), intent(in) :: a, b, c\n+    integer(kind=8) :: i, f3\n+    integer :: l\n+    !$omp taskloop default(none) lastprivate (i, l)\n+    do i = a, b, c\n+      l = i\n+    end do\n+    !$omp end taskloop\n+    f3 = l * 7 + i\n+  end function f3\n+  function f4 (a, b, c, d, e, f, m)\n+    integer(kind=8), intent(in) :: a, b, c, d, e, f\n+    integer(kind=8) :: i, j, f4\n+    integer, intent(in) :: m\n+    integer :: l, k\n+    k = m\n+    !$omp taskloop default (none) collapse (2) firstprivate (k) &\n+    !$omp & lastprivate (i, j, k, l)\n+    do i = a, b, e\n+      do j = c, d, f\n+        if (k .ne. 73) call abort\n+        if (i .eq. 31 .and. j .eq. 46) then\n+          k = i\n+        end if\n+        l = j\n+      end do\n+    end do\n+    f4 = i + 5 * j + 11 * k + 17 * l\n+  end function f4\n+end"}, {"sha": "ad44f098d00d0c792ca5ae808edbcbb928c3358f", "filename": "libgomp/testsuite/libgomp.fortran/taskloop4.f90", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c3a85be96585374bf95c981ba2f602667cf5b7/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftaskloop4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c3a85be96585374bf95c981ba2f602667cf5b7/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftaskloop4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftaskloop4.f90?ref=b4c3a85be96585374bf95c981ba2f602667cf5b7", "patch": "@@ -0,0 +1,87 @@\n+! { dg-do run }\n+! { dg-options \"-O2\" }\n+\n+  integer, save :: u(64), v\n+  integer :: min_iters, max_iters, ntasks, cnt\n+  procedure(grainsize), pointer :: fn\n+  !$omp parallel\n+  !$omp single\n+    fn => grainsize\n+    ! If grainsize is present, # of task loop iters is\n+    ! >= grainsize && < 2 * grainsize,\n+    ! unless # of loop iterations is smaller than grainsize.\n+    call test (0, 79, 1, 17, fn, ntasks, min_iters, max_iters, cnt)\n+    if (cnt .ne. 79) call abort\n+    if (min_iters .lt. 17 .or. max_iters .ge. 17 * 2) call abort\n+    call test (-49, 2541, 7, 28, fn, ntasks, min_iters, max_iters, cnt)\n+    if (cnt .ne. 370) call abort\n+    if (min_iters .lt. 28 .or. max_iters .ge. 28 * 2) call abort\n+    call test (7, 21, 2, 15, fn, ntasks, min_iters, max_iters, cnt)\n+    if (cnt .ne. 7) call abort\n+    if (min_iters .ne. 7 .or. max_iters .ne. 7) call abort\n+    if (ntasks .ne. 1) call abort\n+    fn => num_tasks\n+    ! If num_tasks is present, # of task loop iters is\n+    ! min (# of loop iters, num_tasks).\n+    call test (-51, 2500, 48, 9, fn, ntasks, min_iters, max_iters, cnt)\n+    if (cnt .ne. 54 .or. ntasks .ne. 9) call abort\n+    call test (0, 25, 2, 17, fn, ntasks, min_iters, max_iters, cnt)\n+    if (cnt .ne. 13 .or. ntasks .ne. 13) call abort\n+  !$omp end single\n+  !$omp end parallel\n+contains\n+  subroutine grainsize (a, b, c, d)\n+    integer, intent (in) :: a, b, c, d\n+    integer :: i, j, k\n+    j = 0\n+    k = 0\n+    !$omp taskloop firstprivate (j, k) grainsize (d)\n+    do i = a, b - 1, c\n+      if (j .eq. 0) then\n+        !$omp atomic capture\n+          k = v\n+          v = v + 1\n+        !$omp end atomic\n+        if (k .ge. 64) call abort\n+      end if\n+      j = j + 1\n+      u(k + 1) = j\n+    end do\n+  end subroutine grainsize\n+  subroutine num_tasks (a, b, c, d)\n+    integer, intent (in) :: a, b, c, d\n+    integer :: i, j, k\n+    j = 0\n+    k = 0\n+    !$omp taskloop firstprivate (j, k) num_tasks (d)\n+    do i = a, b - 1, c\n+      if (j .eq. 0) then\n+        !$omp atomic capture\n+          k = v\n+          v = v + 1\n+        !$omp end atomic\n+        if (k .ge. 64) call abort\n+      end if\n+      j = j + 1\n+      u(k + 1) = j\n+    end do\n+  end subroutine num_tasks\n+  subroutine test (a, b, c, d, fn, num_tasks, min_iters, max_iters, cnt)\n+    integer, intent (in) :: a, b, c, d\n+    procedure(grainsize), pointer :: fn\n+    integer, intent (out) :: num_tasks, min_iters, max_iters, cnt\n+    integer :: i\n+    u(:) = 0\n+    v = 0\n+    cnt = 0\n+    call fn (a, b, c, d)\n+    min_iters = 0\n+    max_iters = 0\n+    num_tasks = v\n+    if (v .ne. 0) then\n+      min_iters = minval (u(1:v))\n+      max_iters = maxval (u(1:v))\n+      cnt = sum (u(1:v))\n+    end if\n+  end subroutine test\n+end"}]}