{"sha": "aa53f657aaa7d4cddf810d504b61cf08e4fc5528", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWE1M2Y2NTdhYWE3ZDRjZGRmODEwZDUwNGI2MWNmMDhlNGZjNTUyOA==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.ibm.com", "date": "2020-09-10T23:11:45Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@linux.ibm.com", "date": "2020-09-10T23:11:45Z"}, "message": "PowerPC: Change cmove function return to bool.\n\nIn doing the other work for adding ISA 3.1 128-bit minimum, maximum, and\nconditional move support, I noticed the two functions that process conditional\nmoves return 'int' instead of 'bool'.  This patch changes these functions to\nreturn 'bool'.\n\ngcc/\n2020-09-10  Michael Meissner  <meissner@linux.ibm.com>\n\n\t* config/rs6000/rs6000-protos.h (rs6000_emit_cmove): Change return\n\ttype to bool.\n\t(rs6000_emit_int_cmove): Change return type to bool.\n\t* config/rs6000/rs6000.c (rs6000_emit_cmove): Change return type\n\tto bool.\n\t(rs6000_emit_int_cmove): Change return type to bool.", "tree": {"sha": "de77c0dc37775164b04988b3c93defacb4b33542", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/de77c0dc37775164b04988b3c93defacb4b33542"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa53f657aaa7d4cddf810d504b61cf08e4fc5528", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa53f657aaa7d4cddf810d504b61cf08e4fc5528", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa53f657aaa7d4cddf810d504b61cf08e4fc5528", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa53f657aaa7d4cddf810d504b61cf08e4fc5528/comments", "author": null, "committer": null, "parents": [{"sha": "af47a2035a4882e6d4506e3d00b5a42414e3ee2b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af47a2035a4882e6d4506e3d00b5a42414e3ee2b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af47a2035a4882e6d4506e3d00b5a42414e3ee2b"}], "stats": {"total": 36, "additions": 18, "deletions": 18}, "files": [{"sha": "02e4d71922fb0a2ed3b76036d80f7d59489a6fb9", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa53f657aaa7d4cddf810d504b61cf08e4fc5528/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa53f657aaa7d4cddf810d504b61cf08e4fc5528/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=aa53f657aaa7d4cddf810d504b61cf08e4fc5528", "patch": "@@ -119,8 +119,8 @@ extern char * output_cbranch (rtx, const char *, int, rtx_insn *);\n extern const char * output_probe_stack_range (rtx, rtx, rtx);\n extern void rs6000_emit_dot_insn (rtx dst, rtx src, int dot, rtx ccreg);\n extern bool rs6000_emit_set_const (rtx, rtx);\n-extern int rs6000_emit_cmove (rtx, rtx, rtx, rtx);\n-extern int rs6000_emit_int_cmove (rtx, rtx, rtx, rtx);\n+extern bool rs6000_emit_cmove (rtx, rtx, rtx, rtx);\n+extern bool rs6000_emit_int_cmove (rtx, rtx, rtx, rtx);\n extern int rs6000_emit_vector_cond_expr (rtx, rtx, rtx, rtx, rtx, rtx);\n extern void rs6000_emit_minmax (rtx, enum rtx_code, rtx, rtx);\n extern void rs6000_expand_atomic_compare_and_swap (rtx op[]);"}, {"sha": "f6a3ff6f0896d5ae6d043cc354c653fb2df07d88", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa53f657aaa7d4cddf810d504b61cf08e4fc5528/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa53f657aaa7d4cddf810d504b61cf08e4fc5528/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=aa53f657aaa7d4cddf810d504b61cf08e4fc5528", "patch": "@@ -15159,7 +15159,7 @@ rs6000_emit_p9_fp_cmove (rtx dest, rtx op, rtx true_cond, rtx false_cond)\n    operands of the last comparison is nonzero/true, FALSE_COND if it\n    is zero/false.  Return 0 if the hardware has no such operation.  */\n \n-int\n+bool\n rs6000_emit_cmove (rtx dest, rtx op, rtx true_cond, rtx false_cond)\n {\n   enum rtx_code code = GET_CODE (op);\n@@ -15175,36 +15175,36 @@ rs6000_emit_cmove (rtx dest, rtx op, rtx true_cond, rtx false_cond)\n       /* In the isel case however, we can use a compare immediate, so\n \t op1 may be a small constant.  */\n       && (!TARGET_ISEL || !short_cint_operand (op1, VOIDmode)))\n-    return 0;\n+    return false;\n   if (GET_MODE (true_cond) != result_mode)\n-    return 0;\n+    return false;\n   if (GET_MODE (false_cond) != result_mode)\n-    return 0;\n+    return false;\n \n   /* See if we can use the ISA 3.0 (power9) min/max/compare functions.  */\n   if (TARGET_P9_MINMAX\n       && (compare_mode == SFmode || compare_mode == DFmode)\n       && (result_mode == SFmode || result_mode == DFmode))\n     {\n       if (rs6000_emit_p9_fp_minmax (dest, op, true_cond, false_cond))\n-\treturn 1;\n+\treturn true;\n \n       if (rs6000_emit_p9_fp_cmove (dest, op, true_cond, false_cond))\n-\treturn 1;\n+\treturn true;\n     }\n \n   /* Don't allow using floating point comparisons for integer results for\n      now.  */\n   if (FLOAT_MODE_P (compare_mode) && !FLOAT_MODE_P (result_mode))\n-    return 0;\n+    return false;\n \n   /* First, work out if the hardware can do this at all, or\n      if it's too slow....  */\n   if (!FLOAT_MODE_P (compare_mode))\n     {\n       if (TARGET_ISEL)\n \treturn rs6000_emit_int_cmove (dest, op, true_cond, false_cond);\n-      return 0;\n+      return false;\n     }\n \n   is_against_zero = op1 == CONST0_RTX (compare_mode);\n@@ -15216,7 +15216,7 @@ rs6000_emit_cmove (rtx dest, rtx op, rtx true_cond, rtx false_cond)\n      generated.  */\n   if (SCALAR_FLOAT_MODE_P (compare_mode)\n       && flag_trapping_math && ! is_against_zero)\n-    return 0;\n+    return false;\n \n   /* Eliminate half of the comparisons by switching operands, this\n      makes the remaining code simpler.  */\n@@ -15232,7 +15232,7 @@ rs6000_emit_cmove (rtx dest, rtx op, rtx true_cond, rtx false_cond)\n   /* UNEQ and LTGT take four instructions for a comparison with zero,\n      it'll probably be faster to use a branch here too.  */\n   if (code == UNEQ && HONOR_NANS (compare_mode))\n-    return 0;\n+    return false;\n \n   /* We're going to try to implement comparisons by performing\n      a subtract, then comparing against zero.  Unfortunately,\n@@ -15247,14 +15247,14 @@ rs6000_emit_cmove (rtx dest, rtx op, rtx true_cond, rtx false_cond)\n       && ((! rtx_equal_p (op0, false_cond) && ! rtx_equal_p (op1, false_cond))\n \t  || (! rtx_equal_p (op0, true_cond)\n \t      && ! rtx_equal_p (op1, true_cond))))\n-    return 0;\n+    return false;\n \n   /* At this point we know we can use fsel.  */\n \n   /* Don't allow compare_mode other than SFmode or DFmode, for others there\n      is no fsel instruction.  */\n   if (compare_mode != SFmode && compare_mode != DFmode)\n-    return 0;\n+    return false;\n \n   /* Reduce the comparison to a comparison against zero.  */\n   if (! is_against_zero)\n@@ -15353,12 +15353,12 @@ rs6000_emit_cmove (rtx dest, rtx op, rtx true_cond, rtx false_cond)\n \t\t\t\t\t\tgen_rtx_GE (VOIDmode,\n \t\t\t\t\t\t\t    op0, op1),\n \t\t\t\t\t\ttrue_cond, false_cond)));\n-  return 1;\n+  return true;\n }\n \n /* Same as above, but for ints (isel).  */\n \n-int\n+bool\n rs6000_emit_int_cmove (rtx dest, rtx op, rtx true_cond, rtx false_cond)\n {\n   rtx condition_rtx, cr;\n@@ -15368,7 +15368,7 @@ rs6000_emit_int_cmove (rtx dest, rtx op, rtx true_cond, rtx false_cond)\n   bool signedp;\n \n   if (mode != SImode && (!TARGET_POWERPC64 || mode != DImode))\n-    return 0;\n+    return false;\n \n   /* We still have to do the compare, because isel doesn't do a\n      compare, it just looks at the CRx bits set by a previous compare\n@@ -15403,7 +15403,7 @@ rs6000_emit_int_cmove (rtx dest, rtx op, rtx true_cond, rtx false_cond)\n \n   emit_insn (isel_func (dest, condition_rtx, true_cond, false_cond, cr));\n \n-  return 1;\n+  return true;\n }\n \n void"}]}