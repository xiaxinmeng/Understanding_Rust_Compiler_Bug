{"sha": "004f2c07b6d3fa543f0fe86c55a7b3c227de2bb6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDA0ZjJjMDdiNmQzZmE1NDNmMGZlODZjNTVhN2IzYzIyN2RlMmJiNg==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2020-02-22T00:25:40Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2020-02-24T16:01:09Z"}, "message": "analyzer: eliminate irrelevant control-flow edges from paths\n\nPaths emitted by the analyzer can be quite verbose at the default of\n-fanalyzer-verbosity=2.\n\nConsider the double-free in this example:\n\n  #include <stdlib.h>\n\n  int foo ();\n  int bar ();\n\n  void test (int a, int b, int c)\n  {\n    void *p = malloc (1024);\n    while (a)\n      foo ();\n    if (b)\n      foo ();\n    else\n      bar ();\n    if (c)\n      free (p);\n    free (p);\n  }\n\nPreviously, the analyzer would emit a checker_path containing all\ncontrol-flow information on the exploded_path leading to the\ndouble-free:\n\n  test.c: In function 'test':\n  test.c:17:3: warning: double-'free' of 'p' [CWE-415] [-Wanalyzer-double-free]\n     17 |   free (p);\n        |   ^~~~~~~~\n    'test': events 1-9\n      |\n      |    8 |   void *p = malloc (1024);\n      |      |             ^~~~~~~~~~~~~\n      |      |             |\n      |      |             (1) allocated here\n      |    9 |   while (a)\n      |      |         ~\n      |      |         |\n      |      |         (2) following 'false' branch (when 'a == 0')...\n      |   10 |     foo ();\n      |   11 |   if (b)\n      |      |      ~\n      |      |      |\n      |      |      (3) ...to here\n      |      |      (4) following 'false' branch (when 'b == 0')...\n      |......\n      |   14 |     bar ();\n      |      |     ~~~~~~\n      |      |     |\n      |      |     (5) ...to here\n      |   15 |   if (c)\n      |      |      ~\n      |      |      |\n      |      |      (6) following 'true' branch (when 'c != 0')...\n      |   16 |     free (p);\n      |      |     ~~~~~~~~\n      |      |     |\n      |      |     (7) ...to here\n      |      |     (8) first 'free' here\n      |   17 |   free (p);\n      |      |   ~~~~~~~~\n      |      |   |\n      |      |   (9) second 'free' here; first 'free' was at (8)\n      |\n\ndespite the fact that only the \"if (c)\" is relevant to triggering the\ndouble-free.\n\nThis patch implements pruning of control flow events at\n-fanalyzer-verbosity=2, based on reachability information within the\nexploded_graph.\nThe diagnostic_manager pre-computes reachability information about\nwhich exploded_nodes can reach the exploded_node of the diagnostic,\nand uses this to prune irrelvent control flow edges.\n\nThe patch also adds a -fanalyzer-verbosity=3 to preserve these edges,\nso that the \"show me everything\" debugging level becomes\n-fanalyzer-verbosity=4.\n\nWith these changes, the \"while (a)\" and \"if (b)\" edges are pruned from\nthe above example, leading to:\n\n  test.c: In function 'test':\n  test.c:17:3: warning: double-'free' of 'p' [CWE-415] [-Wanalyzer-double-free]\n     17 |   free (p);\n        |   ^~~~~~~~\n    'test': events 1-5\n      |\n      |    8 |   void *p = malloc (1024);\n      |      |             ^~~~~~~~~~~~~\n      |      |             |\n      |      |             (1) allocated here\n      |......\n      |   15 |   if (c)\n      |      |      ~\n      |      |      |\n      |      |      (2) following 'true' branch (when 'c != 0')...\n      |   16 |     free (p);\n      |      |     ~~~~~~~~\n      |      |     |\n      |      |     (3) ...to here\n      |      |     (4) first 'free' here\n      |   17 |   free (p);\n      |      |   ~~~~~~~~\n      |      |   |\n      |      |   (5) second 'free' here; first 'free' was at (4)\n      |\n\nThe above example is gcc.dg/analyzer/edges-2.c.\n\ngcc/analyzer/ChangeLog:\n\t* checker-path.cc (superedge_event::should_filter_p): Update\n\tfilter for empty descriptions to cover verbosity level 3 as well\n\tas 2.\n\t* diagnostic-manager.cc: Include \"analyzer/reachability.h\".\n\t(class path_builder): New class.\n\t(diagnostic_manager::emit_saved_diagnostic): Create a path_builder\n\tand pass it to build_emission_path, rather passing eg; similarly\n\tfor add_events_for_eedge and ext_state.\n\t(diagnostic_manager::build_emission_path): Replace \"eg\" param\n\twith a path_builder, pass it to add_events_for_eedge.\n\t(diagnostic_manager::add_events_for_eedge): Replace ext_state\n\tparam with path_builder; pass it to add_events_for_superedge.\n\t(diagnostic_manager::significant_edge_p): New.\n\t(diagnostic_manager::add_events_for_superedge): Add path_builder\n\tparam.  Reject insignificant edges at verbosity levels below 3.\n\t(diagnostic_manager::prune_for_sm_diagnostic): Update highest\n\tverbosity level to 4.\n\t* diagnostic-manager.h (class path_builder): New forward decl.\n\t(diagnostic_manager::build_emission_path): Replace \"eg\" param\n\twith a path_builder.\n\t(diagnostic_manager::add_events_for_eedge): Replace ext_state\n\tparam with path_builder.\n\t(diagnostic_manager::significant_edge_p): New.\n\t(diagnostic_manager::add_events_for_superedge): Add path_builder\n\tparam.\n\t* reachability.h: New file.\n\ngcc/ChangeLog:\n\t* doc/invoke.texi (-fanalyzer-verbosity=): \"2\" only shows\n\tsignificant control flow events; add a \"3\" which shows all\n\tcontrol flow events; the old \"3\" becomes \"4\".\n\ngcc/testsuite/ChangeLog:\n\t* gcc.dg/analyzer/analyzer-verbosity-2a.c: New test.\n\t* gcc.dg/analyzer/analyzer-verbosity-3.c: New test, based on\n\tanalyzer-verbosity-2.c\n\t* gcc.dg/analyzer/analyzer-verbosity-3a.c: New test.\n\t* gcc.dg/analyzer/edges-1.c: New test.\n\t* gcc.dg/analyzer/edges-2.c: New test.\n\t* gcc.dg/analyzer/file-paths-1.c: Add -fanalyzer-verbosity=3.", "tree": {"sha": "ed0929d7a363a32f202af63574b35ef4caae8d06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ed0929d7a363a32f202af63574b35ef4caae8d06"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/004f2c07b6d3fa543f0fe86c55a7b3c227de2bb6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/004f2c07b6d3fa543f0fe86c55a7b3c227de2bb6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/004f2c07b6d3fa543f0fe86c55a7b3c227de2bb6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/004f2c07b6d3fa543f0fe86c55a7b3c227de2bb6/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cae5ff6036a21c9bbe521d615d88e283b80fe695", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cae5ff6036a21c9bbe521d615d88e283b80fe695", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cae5ff6036a21c9bbe521d615d88e283b80fe695"}], "stats": {"total": 628, "additions": 607, "deletions": 21}, "files": [{"sha": "2049bf5cf3f2ba4bcc953dfc29aceca7fe5f888e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004f2c07b6d3fa543f0fe86c55a7b3c227de2bb6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004f2c07b6d3fa543f0fe86c55a7b3c227de2bb6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=004f2c07b6d3fa543f0fe86c55a7b3c227de2bb6", "patch": "@@ -1,3 +1,9 @@\n+2020-02-24  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* doc/invoke.texi (-fanalyzer-verbosity=): \"2\" only shows\n+\tsignificant control flow events; add a \"3\" which shows all\n+\tcontrol flow events; the old \"3\" becomes \"4\".\n+\n 2020-02-24  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/93582"}, {"sha": "bc70e88e814c446f4f819bb540d1c1b87320a455", "filename": "gcc/analyzer/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004f2c07b6d3fa543f0fe86c55a7b3c227de2bb6/gcc%2Fanalyzer%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004f2c07b6d3fa543f0fe86c55a7b3c227de2bb6/gcc%2Fanalyzer%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2FChangeLog?ref=004f2c07b6d3fa543f0fe86c55a7b3c227de2bb6", "patch": "@@ -1,3 +1,32 @@\n+2020-02-24  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* checker-path.cc (superedge_event::should_filter_p): Update\n+\tfilter for empty descriptions to cover verbosity level 3 as well\n+\tas 2.\n+\t* diagnostic-manager.cc: Include \"analyzer/reachability.h\".\n+\t(class path_builder): New class.\n+\t(diagnostic_manager::emit_saved_diagnostic): Create a path_builder\n+\tand pass it to build_emission_path, rather passing eg; similarly\n+\tfor add_events_for_eedge and ext_state.\n+\t(diagnostic_manager::build_emission_path): Replace \"eg\" param\n+\twith a path_builder, pass it to add_events_for_eedge.\n+\t(diagnostic_manager::add_events_for_eedge): Replace ext_state\n+\tparam with path_builder; pass it to add_events_for_superedge.\n+\t(diagnostic_manager::significant_edge_p): New.\n+\t(diagnostic_manager::add_events_for_superedge): Add path_builder\n+\tparam.  Reject insignificant edges at verbosity levels below 3.\n+\t(diagnostic_manager::prune_for_sm_diagnostic): Update highest\n+\tverbosity level to 4.\n+\t* diagnostic-manager.h (class path_builder): New forward decl.\n+\t(diagnostic_manager::build_emission_path): Replace \"eg\" param\n+\twith a path_builder.\n+\t(diagnostic_manager::add_events_for_eedge): Replace ext_state\n+\tparam with path_builder.\n+\t(diagnostic_manager::significant_edge_p): New.\n+\t(diagnostic_manager::add_events_for_superedge): Add path_builder\n+\tparam.\n+\t* reachability.h: New file.\n+\n 2020-02-18  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR analyzer/93692"}, {"sha": "c781cd8dbeba69e969f75e8971986290fd6fdc99", "filename": "gcc/analyzer/checker-path.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004f2c07b6d3fa543f0fe86c55a7b3c227de2bb6/gcc%2Fanalyzer%2Fchecker-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004f2c07b6d3fa543f0fe86c55a7b3c227de2bb6/gcc%2Fanalyzer%2Fchecker-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fchecker-path.cc?ref=004f2c07b6d3fa543f0fe86c55a7b3c227de2bb6", "patch": "@@ -334,7 +334,7 @@ superedge_event::should_filter_p (int verbosity) const\n \tif (verbosity < 2)\n \t  return true;\n \n-\tif (verbosity == 2)\n+\tif (verbosity < 4)\n \t  {\n \t    /* Filter events with empty descriptions.  This ought to filter\n \t       FALLTHRU, but retain true/false/switch edges.  */"}, {"sha": "78c5890054f3b47fcff98e38d5290fe672c9f5e6", "filename": "gcc/analyzer/diagnostic-manager.cc", "status": "modified", "additions": 130, "deletions": 14, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004f2c07b6d3fa543f0fe86c55a7b3c227de2bb6/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004f2c07b6d3fa543f0fe86c55a7b3c227de2bb6/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fdiagnostic-manager.cc?ref=004f2c07b6d3fa543f0fe86c55a7b3c227de2bb6", "patch": "@@ -55,6 +55,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"analyzer/program-state.h\"\n #include \"analyzer/exploded-graph.h\"\n #include \"analyzer/checker-path.h\"\n+#include \"analyzer/reachability.h\"\n \n #if ENABLE_ANALYZER\n \n@@ -107,6 +108,41 @@ saved_diagnostic::operator== (const saved_diagnostic &other) const\n \t  && m_trailing_eedge == other.m_trailing_eedge);\n }\n \n+/* State for building a checker_path from a particular exploded_path.\n+   In particular, this precomputes reachability information: the set of\n+   source enodes for which a a path be found to the diagnostic enode.  */\n+\n+class path_builder\n+{\n+public:\n+  path_builder (const exploded_graph &eg,\n+\t\tconst exploded_path &epath)\n+  : m_eg (eg),\n+    m_diag_enode (epath.get_final_enode ()),\n+    m_reachability (eg, m_diag_enode)\n+  {}\n+\n+  const exploded_node *get_diag_node () const { return m_diag_enode; }\n+\n+  bool reachable_from_p (const exploded_node *src_enode) const\n+  {\n+    return m_reachability.reachable_from_p (src_enode);\n+  }\n+\n+  const extrinsic_state &get_ext_state () const { return m_eg.get_ext_state (); }\n+\n+private:\n+  typedef reachability<eg_traits> enode_reachability;\n+\n+  const exploded_graph &m_eg;\n+\n+  /* The enode where the diagnostic occurs.  */\n+  const exploded_node *m_diag_enode;\n+\n+  /* Precompute all enodes from which the diagnostic is reachable.  */\n+  enode_reachability m_reachability;\n+};\n+\n /* class diagnostic_manager.  */\n \n /* diagnostic_manager's ctor.  */\n@@ -470,10 +506,15 @@ diagnostic_manager::emit_saved_diagnostic (const exploded_graph &eg,\n \n   pretty_printer *pp = global_dc->printer->clone ();\n \n+  /* Precompute all enodes from which the diagnostic is reachable.  */\n+  path_builder pb (eg, epath);\n+\n+  /* This is the diagnostic_path subclass that will be built for\n+     the diagnostic.  */\n   checker_path emission_path;\n \n   /* Populate emission_path with a full description of EPATH.  */\n-  build_emission_path (eg, epath, &emission_path);\n+  build_emission_path (pb, epath, &emission_path);\n \n   /* Now prune it to just cover the most pertinent events.  */\n   prune_path (&emission_path, sd.m_sm, sd.m_var, sd.m_state);\n@@ -489,8 +530,7 @@ diagnostic_manager::emit_saved_diagnostic (const exploded_graph &eg,\n      trailing eedge stashed, add any events for it.  This is for use\n      in handling longjmp, to show where a longjmp is rewinding to.  */\n   if (sd.m_trailing_eedge)\n-    add_events_for_eedge (*sd.m_trailing_eedge, eg.get_ext_state (),\n-\t\t\t  &emission_path);\n+    add_events_for_eedge (pb, *sd.m_trailing_eedge, &emission_path);\n \n   emission_path.prepare_for_emission (sd.m_d);\n \n@@ -558,16 +598,15 @@ get_any_origin (const gimple *stmt,\n    EPATH within EG.  */\n \n void\n-diagnostic_manager::build_emission_path (const exploded_graph &eg,\n+diagnostic_manager::build_emission_path (const path_builder &pb,\n \t\t\t\t\t const exploded_path &epath,\n \t\t\t\t\t checker_path *emission_path) const\n {\n   LOG_SCOPE (get_logger ());\n-  const extrinsic_state &ext_state = eg.get_ext_state ();\n   for (unsigned i = 0; i < epath.m_edges.length (); i++)\n     {\n       const exploded_edge *eedge = epath.m_edges[i];\n-      add_events_for_eedge (*eedge, ext_state, emission_path);\n+      add_events_for_eedge (pb, *eedge, emission_path);\n     }\n }\n \n@@ -746,8 +785,8 @@ for_each_state_change (const program_state &src_state,\n    Add any events for EEDGE to EMISSION_PATH.  */\n \n void\n-diagnostic_manager::add_events_for_eedge (const exploded_edge &eedge,\n-\t\t\t\t\t  const extrinsic_state &ext_state,\n+diagnostic_manager::add_events_for_eedge (const path_builder &pb,\n+\t\t\t\t\t  const exploded_edge &eedge,\n \t\t\t\t\t  checker_path *emission_path) const\n {\n   const exploded_node *src_node = eedge.m_src;\n@@ -786,7 +825,7 @@ diagnostic_manager::add_events_for_eedge (const exploded_edge &eedge,\n       |              |\n       |              (3) ...to here        (end_cfg_edge_event).  */\n   state_change_event_creator visitor (eedge, emission_path);\n-  for_each_state_change (src_state, dst_state, ext_state,\n+  for_each_state_change (src_state, dst_state, pb.get_ext_state (),\n \t\t\t &visitor);\n \n   /* Allow non-standard edges to add events, e.g. when rewinding from\n@@ -803,7 +842,7 @@ diagnostic_manager::add_events_for_eedge (const exploded_edge &eedge,\n       if (src_point.get_kind () == PK_AFTER_SUPERNODE)\n \t{\n \t  if (eedge.m_sedge)\n-\t    add_events_for_superedge (eedge, emission_path);\n+\t    add_events_for_superedge (pb, eedge, emission_path);\n \t}\n       /* Add function entry events.  */\n       if (dst_point.get_supernode ()->entry_p ())\n@@ -836,18 +875,95 @@ diagnostic_manager::add_events_for_eedge (const exploded_edge &eedge,\n     }\n }\n \n+/* Return true if EEDGE is a significant edge in the path to the diagnostic\n+   for PB.\n+\n+   Consider all of the sibling out-eedges from the same source enode\n+   as EEDGE.\n+   If there's no path from the destinations of those eedges to the\n+   diagnostic enode, then we have to take this eedge and thus it's\n+   significant.\n+\n+   Conversely if there is a path from the destination of any other sibling\n+   eedge to the diagnostic enode, then this edge is insignificant.\n+\n+   Example 1: redundant if-else:\n+\n+     (A) if (...)            A\n+     (B)   ...              / \\\n+         else              B   C\n+     (C)   ...              \\ /\n+     (D) [DIAGNOSTIC]        D\n+\n+     D is reachable by either B or C, so neither of these edges\n+     are significant.\n+\n+   Example 2: pertinent if-else:\n+\n+     (A) if (...)                         A\n+     (B)   ...                           / \\\n+         else                           B   C\n+     (C)   [NECESSARY CONDITION]        |   |\n+     (D) [POSSIBLE DIAGNOSTIC]          D1  D2\n+\n+     D becomes D1 and D2 in the exploded graph, where the diagnostic occurs\n+     at D2.  D2 is only reachable via C, so the A -> C edge is significant.\n+\n+   Example 3: redundant loop:\n+\n+     (A) while (...)          +-->A\n+     (B)   ...                |  / \\\n+     (C) ...                  +-B  C\n+     (D) [DIAGNOSTIC]              |\n+                                   D\n+\n+     D is reachable from both B and C, so the A->C edge is not significant.  */\n+\n+bool\n+diagnostic_manager::significant_edge_p (const path_builder &pb,\n+\t\t\t\t\tconst exploded_edge &eedge) const\n+{\n+  int i;\n+  exploded_edge *sibling;\n+  FOR_EACH_VEC_ELT (eedge.m_src->m_succs, i, sibling)\n+    {\n+      if (sibling == &eedge)\n+\tcontinue;\n+      if (pb.reachable_from_p (sibling->m_dest))\n+\t{\n+\t  if (get_logger ())\n+\t    get_logger ()->log (\"  edge EN: %i -> EN: %i is insignificant as\"\n+\t\t\t\t\" EN: %i is also reachable via\"\n+\t\t\t\t\" EN: %i -> EN: %i\",\n+\t\t\t\teedge.m_src->m_index, eedge.m_dest->m_index,\n+\t\t\t\tpb.get_diag_node ()->m_index,\n+\t\t\t\tsibling->m_src->m_index,\n+\t\t\t\tsibling->m_dest->m_index);\n+\t  return false;\n+\t}\n+    }\n+\n+  return true;\n+}\n+\n /* Subroutine of diagnostic_manager::add_events_for_eedge\n    where EEDGE has an underlying superedge i.e. a CFG edge,\n    or an interprocedural call/return.\n    Add any events for the superedge to EMISSION_PATH.  */\n \n void\n-diagnostic_manager::add_events_for_superedge (const exploded_edge &eedge,\n+diagnostic_manager::add_events_for_superedge (const path_builder &pb,\n+\t\t\t\t\t      const exploded_edge &eedge,\n \t\t\t\t\t      checker_path *emission_path)\n   const\n {\n   gcc_assert (eedge.m_sedge);\n \n+  /* Don't add events for insignificant edges at verbosity levels below 3.  */\n+  if (m_verbosity < 3)\n+    if (!significant_edge_p (pb, eedge))\n+      return;\n+\n   const exploded_node *src_node = eedge.m_src;\n   const program_point &src_point = src_node->get_point ();\n   const exploded_node *dst_node = eedge.m_dest;\n@@ -995,7 +1111,7 @@ diagnostic_manager::prune_for_sm_diagnostic (checker_path *path,\n \t  gcc_unreachable ();\n \n \tcase EK_DEBUG:\n-\t  if (m_verbosity < 3)\n+\t  if (m_verbosity < 4)\n \t    {\n \t      log (\"filtering event %i: debug event\", idx);\n \t      path->delete_event (idx);\n@@ -1021,7 +1137,7 @@ diagnostic_manager::prune_for_sm_diagnostic (checker_path *path,\n \t\t    var = new_var;\n \t\t  }\n \t      }\n-\t    if (m_verbosity < 3)\n+\t    if (m_verbosity < 4)\n \t      {\n \t\tlog (\"filtering event %i: statement event\", idx);\n \t\tpath->delete_event (idx);\n@@ -1054,7 +1170,7 @@ diagnostic_manager::prune_for_sm_diagnostic (checker_path *path,\n \t\t     sm->get_state_name (state_change->m_from));\n \t\tstate = state_change->m_from;\n \t      }\n-\t    else if (m_verbosity < 3)\n+\t    else if (m_verbosity < 4)\n \t      {\n \t\tif (var)\n \t\t  log (\"filtering event %i:\""}, {"sha": "f32ca75e2791485ffc3de70e952bf580aeeaf6c2", "filename": "gcc/analyzer/diagnostic-manager.h", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004f2c07b6d3fa543f0fe86c55a7b3c227de2bb6/gcc%2Fanalyzer%2Fdiagnostic-manager.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004f2c07b6d3fa543f0fe86c55a7b3c227de2bb6/gcc%2Fanalyzer%2Fdiagnostic-manager.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fdiagnostic-manager.h?ref=004f2c07b6d3fa543f0fe86c55a7b3c227de2bb6", "patch": "@@ -53,6 +53,8 @@ class saved_diagnostic\n   DISABLE_COPY_AND_ASSIGN (saved_diagnostic);\n };\n \n+class path_builder;\n+\n /* A class with responsibility for saving pending diagnostics, so that\n    they can be emitted after the exploded_graph is complete.\n    This lets us de-duplicate diagnostics, and find the shortest path\n@@ -101,15 +103,19 @@ class diagnostic_manager : public log_user\n   }\n \n private:\n-  void build_emission_path (const exploded_graph &eg,\n+  void build_emission_path (const path_builder &pb,\n \t\t\t    const exploded_path &epath,\n \t\t\t    checker_path *emission_path) const;\n \n-  void add_events_for_eedge (const exploded_edge &eedge,\n-\t\t\t     const extrinsic_state &ext_state,\n+  void add_events_for_eedge (const path_builder &pb,\n+\t\t\t     const exploded_edge &eedge,\n \t\t\t     checker_path *emission_path) const;\n \n-  void add_events_for_superedge (const exploded_edge &eedge,\n+  bool significant_edge_p (const path_builder &pb,\n+\t\t\t   const exploded_edge &eedge) const;\n+\n+  void add_events_for_superedge (const path_builder &pb,\n+\t\t\t\t const exploded_edge &eedge,\n \t\t\t\t checker_path *emission_path) const;\n \n   void prune_path (checker_path *path,"}, {"sha": "445cc7dc7901bd8f32c94f5b6fb9e03f240ad351", "filename": "gcc/analyzer/reachability.h", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004f2c07b6d3fa543f0fe86c55a7b3c227de2bb6/gcc%2Fanalyzer%2Freachability.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004f2c07b6d3fa543f0fe86c55a7b3c227de2bb6/gcc%2Fanalyzer%2Freachability.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Freachability.h?ref=004f2c07b6d3fa543f0fe86c55a7b3c227de2bb6", "patch": "@@ -0,0 +1,76 @@\n+/* Digraph reachability.\n+   Copyright (C) 2020 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_ANALYZER_REACHABILITY_H\n+#define GCC_ANALYZER_REACHABILITY_H\n+\n+namespace ana {\n+\n+/* The set of nodes from which a target node in a digraph can be reached.  */\n+// TODO(stage1): move to gcc\n+\n+template <typename GraphTraits>\n+class reachability\n+{\n+public:\n+  typedef typename GraphTraits::graph_t graph_t;\n+  typedef typename GraphTraits::node_t node_t;\n+  typedef typename GraphTraits::edge_t edge_t;\n+\n+  reachability (const graph_t &graph,\n+\t\tconst node_t *target_node)\n+  : m_indices (graph.m_nodes.length ())\n+  {\n+    bitmap_clear (m_indices);\n+    auto_vec<const node_t *> worklist;\n+    worklist.safe_push (target_node);\n+    bitmap_set_bit (m_indices, target_node->m_index);\n+\n+    while (worklist.length () > 0)\n+      {\n+\tconst node_t *next = worklist.pop ();\n+\tunsigned i;\n+\tedge_t *pred;\n+\tFOR_EACH_VEC_ELT (next->m_preds, i, pred)\n+\t  {\n+\t    if (!reachable_from_p (pred->m_src))\n+\t      {\n+\t\tworklist.safe_push (pred->m_src);\n+\t\tbitmap_set_bit (m_indices, pred->m_src->m_index);\n+\t      }\n+\t  }\n+      }\n+  }\n+\n+  bool reachable_from_p (const node_t *src_node) const\n+  {\n+    return bitmap_bit_p (m_indices, src_node->m_index);\n+  }\n+\n+private:\n+  /* The nodes that can reach the target.  */\n+  auto_sbitmap m_indices;\n+};\n+\n+//TODO: selftests for reachability\n+\n+} // namespace ana\n+\n+#endif /* GCC_ANALYZER_REACHABILITY_H */"}, {"sha": "183c25602d653f1fac9b150c158c52a12f6aba69", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004f2c07b6d3fa543f0fe86c55a7b3c227de2bb6/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004f2c07b6d3fa543f0fe86c55a7b3c227de2bb6/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=004f2c07b6d3fa543f0fe86c55a7b3c227de2bb6", "patch": "@@ -8506,12 +8506,17 @@ As per the previous level, but also show events for the entry\n to each function.\n \n @item 2\n-As per the previous level, but also show  events relating to\n-control flow (e.g. ``true path taken'' at a conditional).\n+As per the previous level, but also show events relating to\n+control flow that are significant to triggering the issue\n+(e.g. ``true path taken'' at a conditional).\n \n This level is the default.\n \n @item 3\n+As per the previous level, but show all control flow events, not\n+just significant ones.\n+\n+@item 4\n This level is intended for analyzer developers; it adds various\n other events intended for debugging the analyzer.\n "}, {"sha": "6d5abbb3c39765331a75464e3cbf9dd01e476474", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004f2c07b6d3fa543f0fe86c55a7b3c227de2bb6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004f2c07b6d3fa543f0fe86c55a7b3c227de2bb6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=004f2c07b6d3fa543f0fe86c55a7b3c227de2bb6", "patch": "@@ -1,3 +1,13 @@\n+2020-02-24  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* gcc.dg/analyzer/analyzer-verbosity-2a.c: New test.\n+\t* gcc.dg/analyzer/analyzer-verbosity-3.c: New test, based on\n+\tanalyzer-verbosity-2.c\n+\t* gcc.dg/analyzer/analyzer-verbosity-3a.c: New test.\n+\t* gcc.dg/analyzer/edges-1.c: New test.\n+\t* gcc.dg/analyzer/edges-2.c: New test.\n+\t* gcc.dg/analyzer/file-paths-1.c: Add -fanalyzer-verbosity=3.\n+\n 2020-02-24  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/93869 - ICE with -Wmismatched-tags."}, {"sha": "9faf5da3a4fb15139050902cc21fcd0abedfed49", "filename": "gcc/testsuite/gcc.dg/analyzer/analyzer-verbosity-2a.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004f2c07b6d3fa543f0fe86c55a7b3c227de2bb6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fanalyzer-verbosity-2a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004f2c07b6d3fa543f0fe86c55a7b3c227de2bb6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fanalyzer-verbosity-2a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fanalyzer-verbosity-2a.c?ref=004f2c07b6d3fa543f0fe86c55a7b3c227de2bb6", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-additional-options \"-fanalyzer-verbosity=2\" } */\n+\n+#include <stdio.h>\n+\n+extern int foo ();\n+extern void bar ();\n+\n+void test (const char *path, int flag)\n+{\n+  FILE *fp = fopen (path, \"r\"); /* { dg-message \"opened here\" } */\n+\n+  /* We shouldn't report this control flow at -fanalyzer-verbosity=2.  */\n+  if (foo ()) /* { dg-bogus \"\" } */\n+    bar ();\n+  else\n+    bar ();\n+\n+  if (flag) /* { dg-message \"when 'flag == 0'\" } */\n+    fclose (fp); \n+} /* { dg-warning \"leak of FILE 'fp'\" } */"}, {"sha": "fb87d16f8334ef7b20462ff8072efc62618ec18d", "filename": "gcc/testsuite/gcc.dg/analyzer/analyzer-verbosity-3.c", "status": "added", "additions": 222, "deletions": 0, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004f2c07b6d3fa543f0fe86c55a7b3c227de2bb6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fanalyzer-verbosity-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004f2c07b6d3fa543f0fe86c55a7b3c227de2bb6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fanalyzer-verbosity-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fanalyzer-verbosity-3.c?ref=004f2c07b6d3fa543f0fe86c55a7b3c227de2bb6", "patch": "@@ -0,0 +1,222 @@\n+/* { dg-additional-options \"-fdiagnostics-show-line-numbers -fdiagnostics-path-format=inline-events -fdiagnostics-show-caret -fanalyzer-verbosity=3\" } */\n+/* { dg-enable-nn-line-numbers \"\" } */\n+\n+#include <stdlib.h>\n+\n+void calls_free_1 (void *ptr)\n+{\n+  free (ptr); /* { dg-warning \"double-'free' of 'ptr'\" } */\n+}\n+\n+void test_1 (void *ptr, int a, int b)\n+{\n+  if (a)\n+    calls_free_1 (ptr);\n+\n+  if (b)\n+    {\n+    }\n+  else\n+    calls_free_1 (ptr);\n+}\n+\n+/* { dg-begin-multiline-output \"\" }\n+   NN |   free (ptr);\n+      |   ^~~~~~~~~~\n+  'test_1': events 1-4\n+    |\n+    |   NN | void test_1 (void *ptr, int a, int b)\n+    |      |      ^~~~~~\n+    |      |      |\n+    |      |      (1) entry to 'test_1'\n+    |   NN | {\n+    |   NN |   if (a)\n+    |      |      ~\n+    |      |      |\n+    |      |      (2) following 'true' branch (when 'a != 0')...\n+    |   NN |     calls_free_1 (ptr);\n+    |      |     ~~~~~~~~~~~~~~~~~~\n+    |      |     |\n+    |      |     (3) ...to here\n+    |      |     (4) calling 'calls_free_1' from 'test_1'\n+    |\n+    +--> 'calls_free_1': events 5-6\n+           |\n+           |   NN | void calls_free_1 (void *ptr)\n+           |      |      ^~~~~~~~~~~~\n+           |      |      |\n+           |      |      (5) entry to 'calls_free_1'\n+           |   NN | {\n+           |   NN |   free (ptr);\n+           |      |   ~~~~~~~~~~\n+           |      |   |\n+           |      |   (6) first 'free' here\n+           |\n+    <------+\n+    |\n+  'test_1': events 7-10\n+    |\n+    |   NN |     calls_free_1 (ptr);\n+    |      |     ^~~~~~~~~~~~~~~~~~\n+    |      |     |\n+    |      |     (7) returning to 'test_1' from 'calls_free_1'\n+    |   NN | \n+    |   NN |   if (b)\n+    |      |      ~\n+    |      |      |\n+    |      |      (8) following 'false' branch (when 'b == 0')...\n+    |......\n+    |   NN |     calls_free_1 (ptr);\n+    |      |     ~~~~~~~~~~~~~~~~~~\n+    |      |     |\n+    |      |     (9) ...to here\n+    |      |     (10) passing freed pointer 'ptr' in call to 'calls_free_1' from 'test_1'\n+    |\n+    +--> 'calls_free_1': events 11-12\n+           |\n+           |   NN | void calls_free_1 (void *ptr)\n+           |      |      ^~~~~~~~~~~~\n+           |      |      |\n+           |      |      (11) entry to 'calls_free_1'\n+           |   NN | {\n+           |   NN |   free (ptr);\n+           |      |   ~~~~~~~~~~\n+           |      |   |\n+           |      |   (12) second 'free' here; first 'free' was at (6)\n+           |\n+  { dg-end-multiline-output \"\" } */\n+\n+void calls_free_2 (void *ptr)\n+{\n+  free (ptr); /* { dg-warning \"double-'free' of 'ptr'\" } */\n+}\n+\n+void test_2 (void *ptr, int a, int b)\n+{\n+  switch (a)\n+    {\n+    default:\n+      break;\n+    case 1:\n+      break;\n+    case 3:\n+      calls_free_2 (ptr);\n+      break;\n+    }\n+\n+  switch (b)\n+    {\n+    default:\n+      calls_free_2 (ptr);\n+      break;\n+    case 1:\n+      break;\n+    case 42:\n+      break;\n+    }\n+}\n+\n+/* { dg-begin-multiline-output \"\" }\n+   NN |   free (ptr);\n+      |   ^~~~~~~~~~\n+  'test_2': events 1-4\n+    |\n+    |   NN | void test_2 (void *ptr, int a, int b)\n+    |      |      ^~~~~~\n+    |      |      |\n+    |      |      (1) entry to 'test_2'\n+    |   NN | {\n+    |   NN |   switch (a)\n+    |      |   ~~~~~~\n+    |      |   |\n+    |      |   (2) following 'case 3:' branch...\n+    |......\n+    |   NN |     case 3:\n+    |      |     ~~~~\n+    |      |     |\n+    |      |     (3) ...to here\n+    |   NN |       calls_free_2 (ptr);\n+    |      |       ~~~~~~~~~~~~~~~~~~\n+    |      |       |\n+    |      |       (4) calling 'calls_free_2' from 'test_2'\n+    |\n+    +--> 'calls_free_2': events 5-6\n+           |\n+           |   NN | void calls_free_2 (void *ptr)\n+           |      |      ^~~~~~~~~~~~\n+           |      |      |\n+           |      |      (5) entry to 'calls_free_2'\n+           |   NN | {\n+           |   NN |   free (ptr);\n+           |      |   ~~~~~~~~~~\n+           |      |   |\n+           |      |   (6) first 'free' here\n+           |\n+    <------+\n+    |\n+  'test_2': events 7-10\n+    |\n+    |   NN |       calls_free_2 (ptr);\n+    |      |       ^~~~~~~~~~~~~~~~~~\n+    |      |       |\n+    |      |       (7) returning to 'test_2' from 'calls_free_2'\n+    |......\n+    |   NN |   switch (b)\n+    |      |   ~~~~~~\n+    |      |   |\n+    |      |   (8) following 'default:' branch...\n+    |   NN |     {\n+    |   NN |     default:\n+    |      |     ~~~~~~~\n+    |      |     |\n+    |      |     (9) ...to here\n+    |   NN |       calls_free_2 (ptr);\n+    |      |       ~~~~~~~~~~~~~~~~~~\n+    |      |       |\n+    |      |       (10) passing freed pointer 'ptr' in call to 'calls_free_2' from 'test_2'\n+    |\n+    +--> 'calls_free_2': events 11-12\n+           |\n+           |   NN | void calls_free_2 (void *ptr)\n+           |      |      ^~~~~~~~~~~~\n+           |      |      |\n+           |      |      (11) entry to 'calls_free_2'\n+           |   NN | {\n+           |   NN |   free (ptr);\n+           |      |   ~~~~~~~~~~\n+           |      |   |\n+           |      |   (12) second 'free' here; first 'free' was at (6)\n+           |\n+  { dg-end-multiline-output \"\" } */\n+\n+// TODO: range cases\n+\n+/* The call/return to this function shouldn't appear in the path.  */\n+\n+void called_by_test_3 (void)\n+{\n+}\n+\n+void test_3 (void *ptr)\n+{\n+  free (ptr);\n+  called_by_test_3 ();\n+  free (ptr); /* { dg-warning \"double-'free' of 'ptr'\" } */\n+}\n+\n+/* { dg-begin-multiline-output \"\" }\n+   NN |   free (ptr);\n+      |   ^~~~~~~~~~\n+  'test_3': events 1-2\n+    |\n+    |   NN |   free (ptr);\n+    |      |   ^~~~~~~~~~\n+    |      |   |\n+    |      |   (1) first 'free' here\n+    |   NN |   called_by_test_3 ();\n+    |   NN |   free (ptr);\n+    |      |   ~~~~~~~~~~\n+    |      |   |\n+    |      |   (2) second 'free' here; first 'free' was at (1)\n+    |\n+  { dg-end-multiline-output \"\" } */"}, {"sha": "1b2b79836249f782e464d5b9a84b490ef68a44b1", "filename": "gcc/testsuite/gcc.dg/analyzer/analyzer-verbosity-3a.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004f2c07b6d3fa543f0fe86c55a7b3c227de2bb6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fanalyzer-verbosity-3a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004f2c07b6d3fa543f0fe86c55a7b3c227de2bb6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fanalyzer-verbosity-3a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fanalyzer-verbosity-3a.c?ref=004f2c07b6d3fa543f0fe86c55a7b3c227de2bb6", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-additional-options \"-fanalyzer-verbosity=3\" } */\n+\n+#include <stdio.h>\n+\n+extern int foo ();\n+extern void bar ();\n+\n+void test (const char *path, int flag)\n+{\n+  FILE *fp = fopen (path, \"r\"); /* { dg-message \"opened here\" } */\n+\n+  /* We should report this control flow at -fanalyzer-verbosity=3.  */\n+  if (foo ()) /* { dg-message \"branch\" } */\n+    bar ();\n+  else\n+    bar ();\n+\n+  if (flag) /* { dg-message \"when 'flag == 0'\" } */\n+    fclose (fp); \n+} /* { dg-warning \"leak of FILE 'fp'\" } */"}, {"sha": "6b53ddddc057483ba454dd6a04955829256b706e", "filename": "gcc/testsuite/gcc.dg/analyzer/edges-1.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004f2c07b6d3fa543f0fe86c55a7b3c227de2bb6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fedges-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004f2c07b6d3fa543f0fe86c55a7b3c227de2bb6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fedges-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fedges-1.c?ref=004f2c07b6d3fa543f0fe86c55a7b3c227de2bb6", "patch": "@@ -0,0 +1,54 @@\n+#include <stdio.h>\n+\n+extern int foo ();\n+extern void bar ();\n+\n+/* Verify that only significant edges are reported.  */\n+\n+void test_1 (const char *path, int flag)\n+{\n+  FILE *fp = fopen (path, \"r\");\n+\n+  if (!fp) /* { dg-message \"when 'fp' is non-NULL\" } */\n+    return;\n+\n+  /* We shouldn't report this control flow.  */\n+  while (foo ()) /* { dg-bogus \"\" } */\n+    bar ();\n+\n+  if (flag) /* { dg-message \"when 'flag == 0'\" \"branch event\" } */\n+    fclose (fp); /* { dg-bogus \"leak\" \"warning at wrong location\" { xfail *-*-* } .-1 } */\n+} /* { dg-warning \"leak of FILE 'fp'\" \"warning\" { xfail *-*-* } } */\n+// TODO(xfail): location of leak message ought to be on closing brace\n+\n+void test_2 (const char *path, int flag)\n+{\n+  FILE *fp = fopen (path, \"r\");\n+\n+  /* We shouldn't report this control flow.  */\n+  if (foo ()) /* { dg-bogus \"\" } */\n+    bar ();\n+  else\n+    bar ();\n+\n+  if (flag) /* { dg-message \"when 'flag == 0'\" } */\n+    fclose (fp); \n+} /* { dg-warning \"leak of FILE 'fp'\" } */\n+\n+static void __attribute__((noinline))\n+called_by_test_3 (int flag)\n+{\n+  if (flag)\n+    foo ();\n+}\n+\n+void test_3 (const char *path, int flag)\n+{\n+  FILE *fp = fopen (path, \"r\");\n+\n+  /* We shouldn't report the call/return here.  */\n+  called_by_test_3 (flag); /* { dg-bogus \"\" } */\n+\n+  if (flag) /* { dg-message \"when 'flag == 0'\" } */\n+    fclose (fp);\n+} /* { dg-warning \"leak of FILE 'fp'\" } */"}, {"sha": "847a70883fb63d0992cc3e28090d53d1b61ceeae", "filename": "gcc/testsuite/gcc.dg/analyzer/edges-2.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004f2c07b6d3fa543f0fe86c55a7b3c227de2bb6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fedges-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004f2c07b6d3fa543f0fe86c55a7b3c227de2bb6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fedges-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fedges-2.c?ref=004f2c07b6d3fa543f0fe86c55a7b3c227de2bb6", "patch": "@@ -0,0 +1,20 @@\n+#include <stdlib.h>\n+\n+int foo ();\n+int bar ();\n+\n+/* Verify that only significant edges are reported.  */\n+\n+void test (int a, int b, int c)\n+{\n+  void *p = malloc (1024); /* { dg-message \"allocated here\" } */\n+  while (a) /* { dg-bogus \"\" } */\n+    foo ();\n+  if (b) /* { dg-bogus \"\" } */\n+    foo ();\n+  else\n+    bar ();\n+  if (c) /* { dg-message \"following 'true' branch\" } */\n+    free (p); /* { dg-message \"first 'free' here\" } */\n+  free (p); /* { dg-warning \"double-'free' of 'p'\" } */\n+}"}, {"sha": "d346f7a7c9aa6aec5775e9da35276c7f685d518d", "filename": "gcc/testsuite/gcc.dg/analyzer/file-paths-1.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004f2c07b6d3fa543f0fe86c55a7b3c227de2bb6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffile-paths-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004f2c07b6d3fa543f0fe86c55a7b3c227de2bb6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffile-paths-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffile-paths-1.c?ref=004f2c07b6d3fa543f0fe86c55a7b3c227de2bb6", "patch": "@@ -1,3 +1,5 @@\n+/* { dg-additional-options \"-fanalyzer-verbosity=3\" } */\n+\n #include <stdio.h>\n \n /* Verify that we correctly emit CFG events in the face of buffers"}]}