{"sha": "35bea1710d301269ce90069b11087b35f48b121a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzViZWExNzEwZDMwMTI2OWNlOTAwNjliMTEwODdiMzVmNDhiMTIxYQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2005-02-22T16:48:34Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-02-22T16:48:34Z"}, "message": "tree-outof-ssa.c (SSANORM_USE_COALESCE_LIST): Remove.\n\n\t* tree-outof-ssa.c (SSANORM_USE_COALESCE_LIST): Remove.\n\t(coalesce_ssa_name): Don't check for\n\tSSANORM_USE_COALESCE_LIST.\n\t(rewrite_out_of_ssa): Don't use SSANORM_USE_COALESCE_LIST.\n\nFrom-SVN: r95397", "tree": {"sha": "4ec44ffce9c5e0e318a3844b130f851c9d1e8b5a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4ec44ffce9c5e0e318a3844b130f851c9d1e8b5a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/35bea1710d301269ce90069b11087b35f48b121a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35bea1710d301269ce90069b11087b35f48b121a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35bea1710d301269ce90069b11087b35f48b121a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35bea1710d301269ce90069b11087b35f48b121a/comments", "author": null, "committer": null, "parents": [{"sha": "e2c879a1333c185ffac0e8c4da749ac1a09ca6ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2c879a1333c185ffac0e8c4da749ac1a09ca6ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2c879a1333c185ffac0e8c4da749ac1a09ca6ce"}], "stats": {"total": 93, "additions": 44, "deletions": 49}, "files": [{"sha": "266ce0d190d9f4f3f82285f8bb27f660dbdc8463", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35bea1710d301269ce90069b11087b35f48b121a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35bea1710d301269ce90069b11087b35f48b121a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=35bea1710d301269ce90069b11087b35f48b121a", "patch": "@@ -4,6 +4,11 @@\n \tnot available.  Use tail calls wherever possible.\n \t(make_edge): Call unchecked_make_edge to create an edge.\n \n+\t* tree-outof-ssa.c (SSANORM_USE_COALESCE_LIST): Remove.\n+\t(coalesce_ssa_name): Don't check for\n+\tSSANORM_USE_COALESCE_LIST.\n+\t(rewrite_out_of_ssa): Don't use SSANORM_USE_COALESCE_LIST.\n+\n 2005-02-22  Diego Novillo  <dnovillo@redhat.com>\n \n \t* tree-into-ssa.c (rewrite_blocks): Move debug dumps from ..."}, {"sha": "2eaa2713984f7094e881e2664e37267bad77be83", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 39, "deletions": 49, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35bea1710d301269ce90069b11087b35f48b121a/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35bea1710d301269ce90069b11087b35f48b121a/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=35bea1710d301269ce90069b11087b35f48b121a", "patch": "@@ -52,7 +52,6 @@ Boston, MA 02111-1307, USA.  */\n #define SSANORM_PERFORM_TER\t\t0x1\n #define SSANORM_COMBINE_TEMPS\t\t0x2\n #define SSANORM_COALESCE_PARTITIONS\t0x4\n-#define SSANORM_USE_COALESCE_LIST\t0x8\n \n /* Used to hold all the components required to do SSA PHI elimination.\n    The node and pred/succ list is a simple linear list of nodes and\n@@ -696,62 +695,55 @@ coalesce_ssa_name (var_map map, int flags)\n   if (num_var_partitions (map) <= 1)\n     return NULL;\n \n-  /* If no preference given, use cheap coalescing of all partitions.  */\n-  if ((flags & (SSANORM_COALESCE_PARTITIONS | SSANORM_USE_COALESCE_LIST)) == 0)\n-    flags |= SSANORM_COALESCE_PARTITIONS;\n-  \n   liveinfo = calculate_live_on_entry (map);\n   calculate_live_on_exit (liveinfo);\n   rv = root_var_init (map);\n \n   /* Remove single element variable from the list.  */\n   root_var_compact (rv);\n \n-  if (flags & SSANORM_USE_COALESCE_LIST)\n+  cl = create_coalesce_list (map);\n+\n+  /* Add all potential copies via PHI arguments to the list.  */\n+  FOR_EACH_BB (bb)\n     {\n-      cl = create_coalesce_list (map);\n-      \n-      /* Add all potential copies via PHI arguments to the list.  */\n-      FOR_EACH_BB (bb)\n+      for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n \t{\n-\t  for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n+\t  tree res = PHI_RESULT (phi);\n+\t  int p = var_to_partition (map, res);\n+\t  if (p == NO_PARTITION)\n+\t    continue;\n+\t  for (x = 0; x < (unsigned)PHI_NUM_ARGS (phi); x++)\n \t    {\n-\t      tree res = PHI_RESULT (phi);\n-\t      int p = var_to_partition (map, res);\n-\t      if (p == NO_PARTITION)\n+\t      tree arg = PHI_ARG_DEF (phi, x);\n+\t      int p2;\n+\n+\t      if (TREE_CODE (arg) != SSA_NAME)\n \t\tcontinue;\n-\t      for (x = 0; x < (unsigned)PHI_NUM_ARGS (phi); x++)\n-\t\t{\n-\t\t  tree arg = PHI_ARG_DEF (phi, x);\n-\t\t  int p2;\n-\n-\t\t  if (TREE_CODE (arg) != SSA_NAME)\n-\t\t    continue;\n-\t\t  if (SSA_NAME_VAR (res) != SSA_NAME_VAR (arg))\n-\t\t    continue;\n-\t\t  p2 = var_to_partition (map, PHI_ARG_DEF (phi, x));\n-\t\t  if (p2 != NO_PARTITION)\n-\t\t    add_coalesce (cl, p, p2, 1);\n-\t\t}\n+\t      if (SSA_NAME_VAR (res) != SSA_NAME_VAR (arg))\n+\t\tcontinue;\n+\t      p2 = var_to_partition (map, PHI_ARG_DEF (phi, x));\n+\t      if (p2 != NO_PARTITION)\n+\t\tadd_coalesce (cl, p, p2, 1);\n \t    }\n \t}\n+    }\n \n-      /* Coalesce all the result decls together.  */\n-      var = NULL_TREE;\n-      i = 0;\n-      for (x = 0; x < num_var_partitions (map); x++)\n+  /* Coalesce all the result decls together.  */\n+  var = NULL_TREE;\n+  i = 0;\n+  for (x = 0; x < num_var_partitions (map); x++)\n+    {\n+      tree p = partition_to_var (map, x);\n+      if (TREE_CODE (SSA_NAME_VAR(p)) == RESULT_DECL)\n \t{\n-\t  tree p = partition_to_var (map, x);\n-\t  if (TREE_CODE (SSA_NAME_VAR(p)) == RESULT_DECL)\n+\t  if (var == NULL_TREE)\n \t    {\n-\t      if (var == NULL_TREE)\n-\t\t{\n-\t\t  var = p;\n-\t\t  i = x;\n-\t\t}\n-\t      else\n-\t\tadd_coalesce (cl, i, x, 1);\n+\t      var = p;\n+\t      i = x;\n \t    }\n+\t  else\n+\t    add_coalesce (cl, i, x, 1);\n \t}\n     }\n \n@@ -832,16 +824,14 @@ coalesce_ssa_name (var_map map, int flags)\n     dump_var_map (dump_file, map);\n \n   /* Coalesce partitions.  */\n-  if (flags & SSANORM_USE_COALESCE_LIST)\n-    coalesce_tpa_members (rv, graph, map, cl, \n-\t\t\t  ((dump_flags & TDF_DETAILS) ? dump_file \n-\t\t\t\t\t\t\t   : NULL));\n+  coalesce_tpa_members (rv, graph, map, cl,\n+\t\t\t((dump_flags & TDF_DETAILS) ? dump_file\n+\t\t\t : NULL));\n \n-  \n   if (flags & SSANORM_COALESCE_PARTITIONS)\n-    coalesce_tpa_members (rv, graph, map, NULL, \n-\t\t\t  ((dump_flags & TDF_DETAILS) ? dump_file \n-\t\t\t\t\t\t\t   : NULL));\n+    coalesce_tpa_members (rv, graph, map, NULL,\n+\t\t\t  ((dump_flags & TDF_DETAILS) ? dump_file\n+\t\t\t   : NULL));\n   if (cl)\n     delete_coalesce_list (cl);\n   root_var_delete (rv);\n@@ -2489,7 +2479,7 @@ rewrite_out_of_ssa (void)\n {\n   var_map map;\n   int var_flags = 0;\n-  int ssa_flags = SSANORM_USE_COALESCE_LIST;\n+  int ssa_flags = 0;\n \n   /* If elimination of a PHI requires inserting a copy on a backedge,\n      then we will have to split the backedge which has numerous"}]}