{"sha": "0d682900c62864d3a11399087144d72c27a88c73", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGQ2ODI5MDBjNjI4NjRkM2ExMTM5OTA4NzE0NGQ3MmMyN2E4OGM3Mw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2002-06-06T21:20:43Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2002-06-06T21:20:43Z"}, "message": "i386.md (and promoting splitters): Disable QI to SImode promoting when doing so changes immediate to be 32bit.\n\n\n\t* i386.md (and promoting splitters): Disable QI to SImode promoting\n\twhen doing so changes immediate to be 32bit.\n\n\t* rtl.h (emit_*_scope): Declare.\n\t* emit-rtl.c (emit_*_scope): New global functions.\n\t(try_split): Copy scope.\n\t* ifcvt.c (noce_try_store_flag, noce_try_store_flag_constants,\n\tnoce_try_flag_inc, noce_try_store_flag_mask, noce_try_cmove,\n\tnoce_try_cmove_arith, noce_try_minmax, noce_try_abs,\n\tnoce_process_if_block, find_cond_trap): Copy scopes.\n\t* recog.c (peephole2_optimize): likewise.\n\nFrom-SVN: r54327", "tree": {"sha": "faa2390f8f70ae3e60f4e184669ef5304b7cb309", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/faa2390f8f70ae3e60f4e184669ef5304b7cb309"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0d682900c62864d3a11399087144d72c27a88c73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d682900c62864d3a11399087144d72c27a88c73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d682900c62864d3a11399087144d72c27a88c73", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d682900c62864d3a11399087144d72c27a88c73/comments", "author": null, "committer": null, "parents": [{"sha": "c991649cef7449cefc631fcbcf54c5fd181661c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c991649cef7449cefc631fcbcf54c5fd181661c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c991649cef7449cefc631fcbcf54c5fd181661c2"}], "stats": {"total": 139, "additions": 122, "deletions": 17}, "files": [{"sha": "d42f67447fc19cdd28278700a438d3284eb4aa19", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d682900c62864d3a11399087144d72c27a88c73/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d682900c62864d3a11399087144d72c27a88c73/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0d682900c62864d3a11399087144d72c27a88c73", "patch": "@@ -1,3 +1,17 @@\n+Thu Jun  6 23:14:46 CEST 2002  Jan Hubicka  <jh@suse.cz>\n+\n+\t* i386.md (and promoting splitters): Disable QI to SImode promoting\n+\twhen doing so changes immediate to be 32bit.\n+\n+\t* rtl.h (emit_*_scope): Declare.\n+\t* emit-rtl.c (emit_*_scope): New global functions.\n+\t(try_split): Copy scope.\n+\t* ifcvt.c (noce_try_store_flag, noce_try_store_flag_constants,\n+\tnoce_try_flag_inc, noce_try_store_flag_mask, noce_try_cmove,\n+\tnoce_try_cmove_arith, noce_try_minmax, noce_try_abs,\n+\tnoce_process_if_block, find_cond_trap): Copy scopes.\n+\t* recog.c (peephole2_optimize): likewise.\n+\n 2002-06-06  Jeffrey Law  <law@redhat.com>\n \n \t* h8300.h (OK_FOR_U): Fix thinko exposed by flag checking."}, {"sha": "10c31295fd39039ddf812349da9d891b89a82dca", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d682900c62864d3a11399087144d72c27a88c73/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d682900c62864d3a11399087144d72c27a88c73/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=0d682900c62864d3a11399087144d72c27a88c73", "patch": "@@ -16358,6 +16358,8 @@\n    && ix86_match_ccmode (insn, CCNOmode)\n    && (GET_MODE (operands[0]) == HImode\n        || (GET_MODE (operands[0]) == QImode \n+\t   /* Ensure that the operand will remain sign extended immedaite.  */\n+\t   && INTVAL (operands[2]) >= 0\n \t   && (TARGET_PROMOTE_QImode || optimize_size)))\"\n   [(parallel [(set (reg:CCNO 17)\n \t\t   (compare:CCNO (and:SI (match_dup 1) (match_dup 2))\n@@ -16371,16 +16373,17 @@\n    operands[0] = gen_lowpart (SImode, operands[0]);\n    operands[1] = gen_lowpart (SImode, operands[1]);\")\n \n+; Don't promote the QImode tests, as i386 don't have encoding of\n+; the test instruction with 32bit sign extended immediate and thus\n+; the code grows.\n (define_split\n   [(set (reg 17)\n-\t(compare (and (match_operand 0 \"aligned_operand\" \"\")\n-\t\t      (match_operand 1 \"const_int_operand\" \"\"))\n+\t(compare (and (match_operand:HI 0 \"aligned_operand\" \"\")\n+\t\t      (match_operand:HI 1 \"const_int_operand\" \"\"))\n \t\t (const_int 0)))]\n   \"! TARGET_PARTIAL_REG_STALL && reload_completed\n    && ix86_match_ccmode (insn, CCNOmode)\n-   && (GET_MODE (operands[0]) == HImode\n-       || (GET_MODE (operands[0]) == QImode \n-\t   && (TARGET_PROMOTE_QImode || optimize_size)))\"\n+   && GET_MODE (operands[0]) == HImode\"\n   [(set (reg:CCNO 17)\n \t(compare:CCNO (and:SI (match_dup 0) (match_dup 1))\n \t\t      (const_int 0)))]"}, {"sha": "724244baae459763ec8c7016e2bcd68d6ec2e6b3", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 77, "deletions": 1, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d682900c62864d3a11399087144d72c27a88c73/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d682900c62864d3a11399087144d72c27a88c73/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=0d682900c62864d3a11399087144d72c27a88c73", "patch": "@@ -3205,7 +3205,7 @@ try_split (pat, trial, last)\n \t      if (GET_CODE (XVECEXP (seq, 0, i)) == INSN)\n \t\tmark_label_nuses (PATTERN (XVECEXP (seq, 0, i)));\n \n-\t  tem = emit_insn_after (seq, trial);\n+\t  tem = emit_insn_after_scope (seq, trial, INSN_SCOPE (trial));\n \n \t  delete_insn (trial);\n \t  if (has_barrier)\n@@ -4069,6 +4069,82 @@ emit_line_note_after (file, line, after)\n   return note;\n }\n \f\n+/* Like emit_insn_after, but set INSN_SCOPE according to SCOPE.  */\n+rtx\n+emit_insn_after_scope (pattern, after, scope)\n+     rtx pattern, after;\n+     tree scope;\n+{\n+  rtx last = emit_insn_after (pattern, after);\n+  for (after = NEXT_INSN (after); after != last; after = NEXT_INSN (after))\n+    INSN_SCOPE (after) = scope;\n+  return last;\n+}\n+\n+/* Like emit_insns_after, but set INSN_SCOPE according to SCOPE.  */\n+rtx\n+emit_insns_after_scope (pattern, after, scope)\n+     rtx pattern, after;\n+     tree scope;\n+{\n+  rtx last = emit_insns_after (pattern, after);\n+  for (after = NEXT_INSN (after); after != last; after = NEXT_INSN (after))\n+    INSN_SCOPE (after) = scope;\n+  return last;\n+}\n+\n+/* Like emit_jump_insn_after, but set INSN_SCOPE according to SCOPE.  */\n+rtx\n+emit_jump_insn_after_scope (pattern, after, scope)\n+     rtx pattern, after;\n+     tree scope;\n+{\n+  rtx last = emit_jump_insn_after (pattern, after);\n+  for (after = NEXT_INSN (after); after != last; after = NEXT_INSN (after))\n+    INSN_SCOPE (after) = scope;\n+  return last;\n+}\n+\n+/* Like emit_call_insn_after, but set INSN_SCOPE according to SCOPE.  */\n+rtx\n+emit_call_insn_after_scope (pattern, after, scope)\n+     rtx pattern, after;\n+     tree scope;\n+{\n+  rtx last = emit_call_insn_after (pattern, after);\n+  for (after = NEXT_INSN (after); after != last; after = NEXT_INSN (after))\n+    INSN_SCOPE (after) = scope;\n+  return last;\n+}\n+\n+/* Like emit_insn_before, but set INSN_SCOPE according to SCOPE.  */\n+rtx\n+emit_insn_before_scope (pattern, before, scope)\n+     rtx pattern, before;\n+     tree scope;\n+{\n+  rtx first = PREV_INSN (before);\n+  rtx last = emit_insn_before (pattern, before);\n+\n+  for (first = NEXT_INSN (first); first != last; first = NEXT_INSN (first))\n+    INSN_SCOPE (first) = scope;\n+  return last;\n+}\n+\n+/* Like emit_insns_before, but set INSN_SCOPE according to SCOPE.  */\n+rtx\n+emit_insns_before_scope (pattern, before, scope)\n+     rtx pattern, before;\n+     tree scope;\n+{\n+  rtx first = PREV_INSN (before);\n+  rtx last = emit_insns_before (pattern, before);\n+\n+  for (first = NEXT_INSN (first); first != last; first = NEXT_INSN (first))\n+    INSN_SCOPE (first) = scope;\n+  return last;\n+}\n+\f\n /* Make an insn of code INSN with pattern PATTERN\n    and add it to the end of the doubly-linked list.\n    If PATTERN is a SEQUENCE, take the elements of it"}, {"sha": "842eb547383f27ecda912db2e4a8e05fad4eae8e", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d682900c62864d3a11399087144d72c27a88c73/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d682900c62864d3a11399087144d72c27a88c73/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=0d682900c62864d3a11399087144d72c27a88c73", "patch": "@@ -612,7 +612,7 @@ noce_try_store_flag (if_info)\n \n       seq = get_insns ();\n       end_sequence ();\n-      emit_insns_before (seq, if_info->jump);\n+      emit_insns_before_scope (seq, if_info->jump, INSN_SCOPE (if_info->insn_a));\n \n       return TRUE;\n     }\n@@ -747,7 +747,7 @@ noce_try_store_flag_constants (if_info)\n       if (seq_contains_jump (seq))\n \treturn FALSE;\n \n-      emit_insns_before (seq, if_info->jump);\n+      emit_insns_before_scope (seq, if_info->jump, INSN_SCOPE (if_info->insn_a));\n \n       return TRUE;\n     }\n@@ -807,7 +807,8 @@ noce_try_store_flag_inc (if_info)\n \t  if (seq_contains_jump (seq))\n \t    return FALSE;\n \n-\t  emit_insns_before (seq, if_info->jump);\n+\t  emit_insns_before_scope (seq, if_info->jump,\n+\t\t\t  \t   INSN_SCOPE (if_info->insn_a));\n \n \t  return TRUE;\n \t}\n@@ -859,7 +860,8 @@ noce_try_store_flag_mask (if_info)\n \t  if (seq_contains_jump (seq))\n \t    return FALSE;\n \n-\t  emit_insns_before (seq, if_info->jump);\n+\t  emit_insns_before_scope (seq, if_info->jump,\n+\t\t\t  \t   INSN_SCOPE (if_info->insn_a));\n \n \t  return TRUE;\n \t}\n@@ -954,7 +956,8 @@ noce_try_cmove (if_info)\n \n \t  seq = get_insns ();\n \t  end_sequence ();\n-\t  emit_insns_before (seq, if_info->jump);\n+\t  emit_insns_before_scope (seq, if_info->jump,\n+\t\t\t  \t   INSN_SCOPE (if_info->insn_a));\n \t  return TRUE;\n \t}\n       else\n@@ -1116,7 +1119,7 @@ noce_try_cmove_arith (if_info)\n \n   tmp = get_insns ();\n   end_sequence ();\n-  emit_insns_before (tmp, if_info->jump);\n+  emit_insns_before_scope (tmp, if_info->jump, INSN_SCOPE (if_info->insn_a));\n   return TRUE;\n \n  end_seq_and_fail:\n@@ -1368,7 +1371,7 @@ noce_try_minmax (if_info)\n   if (seq_contains_jump (seq))\n     return FALSE;\n \n-  emit_insns_before (seq, if_info->jump);\n+  emit_insns_before_scope (seq, if_info->jump, INSN_SCOPE (if_info->insn_a));\n   if_info->cond = cond;\n   if_info->cond_earliest = earliest;\n \n@@ -1486,7 +1489,7 @@ noce_try_abs (if_info)\n   if (seq_contains_jump (seq))\n     return FALSE;\n \n-  emit_insns_before (seq, if_info->jump);\n+  emit_insns_before_scope (seq, if_info->jump, INSN_SCOPE (if_info->insn_a));\n   if_info->cond = cond;\n   if_info->cond_earliest = earliest;\n \n@@ -1758,7 +1761,7 @@ noce_process_if_block (test_bb, then_bb, else_bb, join_bb)\n       insn_b = gen_sequence ();\n       end_sequence ();\n \n-      emit_insn_after (insn_b, test_bb->end);\n+      emit_insn_after_scope (insn_b, test_bb->end, INSN_SCOPE (insn_a));\n     }\n \n   /* Merge the blocks!  */\n@@ -2126,7 +2129,7 @@ find_cond_trap (test_bb, then_edge, else_edge)\n     return FALSE;\n \n   /* Emit the new insns before cond_earliest.  */\n-  emit_insn_before (seq, cond_earliest);\n+  emit_insn_before_scope (seq, cond_earliest, INSN_SCOPE (trap));\n \n   /* Delete the trap block if possible.  */\n   remove_edge (trap_bb == then_bb ? then_edge : else_edge);"}, {"sha": "cbc691d99686cc1537b9f433f20d445cd13b1ec4", "filename": "gcc/recog.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d682900c62864d3a11399087144d72c27a88c73/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d682900c62864d3a11399087144d72c27a88c73/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=0d682900c62864d3a11399087144d72c27a88c73", "patch": "@@ -3133,7 +3133,8 @@ peephole2_optimize (dump_file)\n \t\t\t\t\tREG_EH_REGION, NULL_RTX);\n \n \t\t  /* Replace the old sequence with the new.  */\n-\t\t  try = emit_insn_after (try, peep2_insn_data[i].insn);\n+\t\t  try = emit_insn_after_scope (try, peep2_insn_data[i].insn,\n+\t\t\t\t\t       INSN_SCOPE (peep2_insn_data[i].insn));\n \t\t  before_try = PREV_INSN (insn);\n \t\t  delete_insn_chain (insn, peep2_insn_data[i].insn);\n "}, {"sha": "314adf1567e95d3b6aec37b70df49d2c2b21e855", "filename": "gcc/rtl.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d682900c62864d3a11399087144d72c27a88c73/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d682900c62864d3a11399087144d72c27a88c73/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=0d682900c62864d3a11399087144d72c27a88c73", "patch": "@@ -1375,22 +1375,30 @@ extern rtx assign_stack_temp_for_type\tPARAMS ((enum machine_mode,\n extern rtx assign_temp\t\t\tPARAMS ((tree, int, int, int));\n /* In emit-rtl.c */\n extern rtx emit_insn_before\t\tPARAMS ((rtx, rtx));\n+extern rtx emit_insn_before_scope\tPARAMS ((rtx, rtx, tree));\n extern rtx emit_jump_insn_before\tPARAMS ((rtx, rtx));\n+extern rtx emit_jump_insn_before_scope\tPARAMS ((rtx, rtx, tree));\n extern rtx emit_call_insn_before\tPARAMS ((rtx, rtx));\n+extern rtx emit_call_insn_before_scope\tPARAMS ((rtx, rtx, tree));\n extern rtx emit_barrier_before\t\tPARAMS ((rtx));\n extern rtx emit_label_before\t\tPARAMS ((rtx, rtx));\n extern rtx emit_note_before\t\tPARAMS ((int, rtx));\n extern rtx emit_insn_after\t\tPARAMS ((rtx, rtx));\n+extern rtx emit_insn_after_scope\tPARAMS ((rtx, rtx, tree));\n extern rtx emit_jump_insn_after\t\tPARAMS ((rtx, rtx));\n+extern rtx emit_jump_insn_after_scope\tPARAMS ((rtx, rtx, tree));\n extern rtx emit_call_insn_after\t\tPARAMS ((rtx, rtx));\n+extern rtx emit_call_insn_after_scope\tPARAMS ((rtx, rtx, tree));\n extern rtx emit_barrier_after\t\tPARAMS ((rtx));\n extern rtx emit_label_after\t\tPARAMS ((rtx, rtx));\n extern rtx emit_note_after\t\tPARAMS ((int, rtx));\n extern rtx emit_line_note_after\t\tPARAMS ((const char *, int, rtx));\n extern rtx emit_insn\t\t\tPARAMS ((rtx));\n extern rtx emit_insns\t\t\tPARAMS ((rtx));\n extern rtx emit_insns_before\t\tPARAMS ((rtx, rtx));\n+extern rtx emit_insns_before_scope\tPARAMS ((rtx, rtx, tree));\n extern rtx emit_insns_after\t\tPARAMS ((rtx, rtx));\n+extern rtx emit_insns_after_scope\tPARAMS ((rtx, rtx, tree));\n extern rtx emit_jump_insn\t\tPARAMS ((rtx));\n extern rtx emit_call_insn\t\tPARAMS ((rtx));\n extern rtx emit_label\t\t\tPARAMS ((rtx));"}]}