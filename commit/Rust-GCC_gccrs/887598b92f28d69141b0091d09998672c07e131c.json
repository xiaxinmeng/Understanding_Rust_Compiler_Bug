{"sha": "887598b92f28d69141b0091d09998672c07e131c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODg3NTk4YjkyZjI4ZDY5MTQxYjAwOTFkMDk5OTg2NzJjMDdlMTMxYw==", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-09-15T15:29:42Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-09-15T15:29:42Z"}, "message": "Merge #679\n\n679: Fix bug when calling method from generic reciever type-bound r=philberty a=philberty\n\nWhen we have a generic function with a specified type bound, this means the\r\nmethod resolution can only resolve this to the trait item. During code\r\ngeneration we must then monomorphize this and lookup the associated impl\r\nblock item for this trait (if it exists) and call this function.\r\n\r\nFixes #678\r\n\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "82d424164ca7e906c477de1cf3bb2c359a837df6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/82d424164ca7e906c477de1cf3bb2c359a837df6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/887598b92f28d69141b0091d09998672c07e131c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhQhFmCRBK7hj4Ov3rIwAAjZMIAArgYu7Oa8BnPawJvLSL24vr\nJ072tnEYoLyfYpvibsDeNtsFZ+aRT2HwPa60Txr/3RFZ8GjznAGN0srgKZLricfc\nQ9pXG/Mgtxx2Q8sgx5TJ5O+EoZcZLUgnLht6rtnSCJxMDNfFkzDzKnj56Z7+mH+Z\nYH+DrwdQMrVIbqhaoJqwBU9N+gFRZZI3f+eESvz2ILxl9Ri0b5J5S9bIrCL8ZkS3\nyxWFWpl+9A/Wc1ueMamYI7P9nR1Pvn8KAWXitiPwlOJZslJJvbCCuqm2hOf5bpL/\nUTKi7p8UntpEHH+zDO3nSgaLX/5P7EapwbRG9od/r9C/l0Rf+wakodMiDeM1j58=\n=1364\n-----END PGP SIGNATURE-----\n", "payload": "tree 82d424164ca7e906c477de1cf3bb2c359a837df6\nparent af472f5931920b821d2e483749563c902424096c\nparent 04549bf8c34cdb3ea435d8542f2cac6d46bcd30f\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1631719782 +0000\ncommitter GitHub <noreply@github.com> 1631719782 +0000\n\nMerge #679\n\n679: Fix bug when calling method from generic reciever type-bound r=philberty a=philberty\n\nWhen we have a generic function with a specified type bound, this means the\r\nmethod resolution can only resolve this to the trait item. During code\r\ngeneration we must then monomorphize this and lookup the associated impl\r\nblock item for this trait (if it exists) and call this function.\r\n\r\nFixes #678\r\n\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/887598b92f28d69141b0091d09998672c07e131c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/887598b92f28d69141b0091d09998672c07e131c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/887598b92f28d69141b0091d09998672c07e131c/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af472f5931920b821d2e483749563c902424096c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af472f5931920b821d2e483749563c902424096c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af472f5931920b821d2e483749563c902424096c"}, {"sha": "04549bf8c34cdb3ea435d8542f2cac6d46bcd30f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04549bf8c34cdb3ea435d8542f2cac6d46bcd30f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04549bf8c34cdb3ea435d8542f2cac6d46bcd30f"}], "stats": {"total": 64, "additions": 58, "deletions": 6}, "files": [{"sha": "f0e26dc9b44e53727ef39ff5754d184f1a10f58d", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/887598b92f28d69141b0091d09998672c07e131c/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/887598b92f28d69141b0091d09998672c07e131c/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=887598b92f28d69141b0091d09998672c07e131c", "patch": "@@ -22,6 +22,7 @@\n #include \"rust-compile-struct-field-expr.h\"\n #include \"rust-hir-trait-resolve.h\"\n #include \"rust-hir-path-probe.h\"\n+#include \"rust-hir-dot-operator.h\"\n \n namespace Rust {\n namespace Compile {\n@@ -171,10 +172,11 @@ CompileExpr::visit (HIR::MethodCallExpr &expr)\n \t  // item so its up to us to figure out if this path should resolve\n \t  // to an trait-impl-block-item or if it can be defaulted to the\n \t  // trait-impl-item's definition\n+\n+\t  auto root = receiver->get_root ();\n \t  std::vector<Resolver::PathProbeCandidate> candidates\n \t    = Resolver::PathProbeType::Probe (\n-\t      receiver, expr.get_method_name ().get_segment (), true, false,\n-\t      true);\n+\t      root, expr.get_method_name ().get_segment (), true, false, true);\n \n \t  if (candidates.size () == 0)\n \t    {\n@@ -186,6 +188,11 @@ CompileExpr::visit (HIR::MethodCallExpr &expr)\n \t      rust_assert (ok);\t\t\t\t    // found\n \t      rust_assert (trait_item_ref->is_optional ()); // has definition\n \n+\t      // FIXME Optional means it has a definition and an associated\n+\t      // block which can be a default implementation, if it does not\n+\t      // contain an implementation we should actually return\n+\t      // error_mark_node\n+\n \t      TyTy::BaseType *self_type = nullptr;\n \t      if (!ctx->get_tyctx ()->lookup_type (\n \t\t    expr.get_receiver ()->get_mappings ().get_hirid (),\n@@ -209,10 +216,19 @@ CompileExpr::visit (HIR::MethodCallExpr &expr)\n \t    }\n \t  else\n \t    {\n-\t      Resolver::PathProbeCandidate &candidate = candidates.at (0);\n-\t      rust_assert (candidate.is_impl_candidate ());\n-\n-\t      HIR::ImplItem *impl_item = candidate.item.impl.impl_item;\n+\t      std::vector<Resolver::Adjustment> adjustments;\n+\t      Resolver::PathProbeCandidate *candidate\n+\t\t= Resolver::MethodResolution::Select (candidates, root,\n+\t\t\t\t\t\t      adjustments);\n+\n+\t      // FIXME this will be a case to return error_mark_node, there is\n+\t      // an error scenario where a Trait Foo has a method Bar, but this\n+\t      // receiver does not implement this trait or has an incompatible\n+\t      // implementation and we should just return error_mark_node\n+\t      rust_assert (candidate != nullptr);\n+\t      rust_assert (candidate->is_impl_candidate ());\n+\n+\t      HIR::ImplItem *impl_item = candidate->item.impl.impl_item;\n \n \t      TyTy::BaseType *self_type = nullptr;\n \t      if (!ctx->get_tyctx ()->lookup_type ("}, {"sha": "8c9b7409c2063363a0d6a9d11acc7f47418a634c", "filename": "gcc/testsuite/rust/execute/torture/trait4.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/887598b92f28d69141b0091d09998672c07e131c/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Ftrait4.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/887598b92f28d69141b0091d09998672c07e131c/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Ftrait4.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Ftrait4.rs?ref=887598b92f28d69141b0091d09998672c07e131c", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-output \"123\\n\" }*/\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+struct Foo(i32);\n+trait Bar {\n+    fn baz(&self);\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+}\n+\n+impl Bar for Foo {\n+    fn baz(&self) {\n+        // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+        unsafe {\n+            let a = \"%i\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c, self.0);\n+        }\n+    }\n+}\n+\n+fn type_bound<T: Bar>(t: &T) {\n+    t.baz();\n+}\n+\n+fn main() -> i32 {\n+    let a;\n+\n+    a = &Foo(123);\n+    type_bound(a);\n+\n+    0\n+}"}]}