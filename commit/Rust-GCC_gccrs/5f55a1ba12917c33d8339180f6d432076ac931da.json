{"sha": "5f55a1ba12917c33d8339180f6d432076ac931da", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWY1NWExYmExMjkxN2MzM2Q4MzM5MTgwZjZkNDMyMDc2YWM5MzFkYQ==", "commit": {"author": {"name": "Dorit Naishlos", "email": "dorit@il.ibm.com", "date": "2005-03-15T18:33:09Z"}, "committer": {"name": "Dorit Nuzman", "email": "dorit@gcc.gnu.org", "date": "2005-03-15T18:33:09Z"}, "message": "tree-vectorizer.h (unknown_alignment_for_access_p): Replaced by known_alignment_for_access_p.\n\n        * tree-vectorizer.h (unknown_alignment_for_access_p): Replaced by\n        known_alignment_for_access_p.\n        (known_alignment_for_access_p): New.\n        (do_peeling_for_alignment): Field made int instead of bool and renamed\n        to peeling_for_alignment.\n        (LOOP_DO_PEELING_FOR_ALIGNMENT): Renamed to LOOP_PEELING_FOR_ALIGNMENT.\n        * tree-vect-analyze.c (vect_determine_vectorization_factor): New. This\n        functionality used to be in vect_analyze_operations.\n        (vect_analyze_operations): Code to determine vectorization factor was\n        moved to vect_determine_vectorization_factor.\n        (vect_enhance_data_refs_alignment): Update to correct alignment when it\n        is known instead of -1.  Set LOOP_PEELING_FOR_ALIGNMENT to peeling\n        factor.\n        (vect_analyze_loop): Call vect_determine_vectorization_factor (used to\n        be part of vect_analyze_operations).\n        * tree-vectorizer.c (slpeel_tree_peel_loop_to_edge): Use fold when\n        creating the guard condition, as the number of iterations may be\n        constant.\n        (slpeel_tree_peel_loop_to_edge): Use new name of\n        LOOP_DO_PEELING_FOR_ALIGNMENT. Set it to 0 instead of false.\n        * tree-vect-transform.c (vect_gen_niters_for_prolog_loop): Handle known\n        alignment case more efficiently. Use LOOP_PEELING_FOR_ALIGNMENT.\n        (vect_do_peeling_for_alignment): Use fold.\n        (vect_transform_loop): Use new name of LOOP_DO_PEELING_FOR_ALIGNMENT.\n\n        (vect_update_inits_of_dr): Renamed to\n        vect_update_init_of_dr.\n        (vect_update_inits_of_drs): Use new name of vect_update_inits_of_dr.\n        (vectorizable_store): Fix assertion to use == instead of =.\n\nFrom-SVN: r96526", "tree": {"sha": "aa609c29139804fa11435795fdbdacaccff79d8f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aa609c29139804fa11435795fdbdacaccff79d8f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5f55a1ba12917c33d8339180f6d432076ac931da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f55a1ba12917c33d8339180f6d432076ac931da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f55a1ba12917c33d8339180f6d432076ac931da", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f55a1ba12917c33d8339180f6d432076ac931da/comments", "author": null, "committer": null, "parents": [{"sha": "119bb233e2d4a695ec26cff09be08f6c2b6f7a44", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/119bb233e2d4a695ec26cff09be08f6c2b6f7a44", "html_url": "https://github.com/Rust-GCC/gccrs/commit/119bb233e2d4a695ec26cff09be08f6c2b6f7a44"}], "stats": {"total": 678, "additions": 504, "deletions": 174}, "files": [{"sha": "0d3e60f7d3a24ad3f6c3a3207e175acfa5908220", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f55a1ba12917c33d8339180f6d432076ac931da/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f55a1ba12917c33d8339180f6d432076ac931da/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5f55a1ba12917c33d8339180f6d432076ac931da", "patch": "@@ -1,3 +1,35 @@\n+2005-03-15  Dorit Naishlos  <dorit@il.ibm.com>\n+\n+\t* tree-vectorizer.h (unknown_alignment_for_access_p): Replaced by\n+\tknown_alignment_for_access_p.\n+\t(known_alignment_for_access_p): New.\n+\t(do_peeling_for_alignment): Field made int instead of bool and renamed\n+\tto peeling_for_alignment.\n+\t(LOOP_DO_PEELING_FOR_ALIGNMENT): Renamed to LOOP_PEELING_FOR_ALIGNMENT.\n+\t* tree-vect-analyze.c (vect_determine_vectorization_factor): New. This\n+\tfunctionality used to be in vect_analyze_operations.\n+\t(vect_analyze_operations): Code to determine vectorization factor was\n+\tmoved to vect_determine_vectorization_factor.\n+\t(vect_enhance_data_refs_alignment): Update to correct alignment when it\n+\tis known instead of -1.  Set LOOP_PEELING_FOR_ALIGNMENT to peeling\n+\tfactor.\n+\t(vect_analyze_loop): Call vect_determine_vectorization_factor (used to\n+\tbe part of vect_analyze_operations).\n+\t* tree-vectorizer.c (slpeel_tree_peel_loop_to_edge): Use fold when\n+\tcreating the guard condition, as the number of iterations may be\n+\tconstant.\n+\t(slpeel_tree_peel_loop_to_edge): Use new name of\n+\tLOOP_DO_PEELING_FOR_ALIGNMENT. Set it to 0 instead of false.\n+\t* tree-vect-transform.c (vect_gen_niters_for_prolog_loop): Handle known\n+\talignment case more efficiently. Use LOOP_PEELING_FOR_ALIGNMENT.\n+\t(vect_do_peeling_for_alignment): Use fold.\n+\t(vect_transform_loop): Use new name of LOOP_DO_PEELING_FOR_ALIGNMENT.\n+\n+\t(vect_update_inits_of_dr): Renamed to\n+\tvect_update_init_of_dr.\n+\t(vect_update_inits_of_drs): Use new name of vect_update_inits_of_dr.\n+\t(vectorizable_store): Fix assertion to use == instead of =.\n+\n 2005-03-15  Daniel Jacobowitz  <dan@codesourcery.com>\n \n \t* config/arm/arm.h (CONDITIONAL_REGISTER_USAGE): Don't clear"}, {"sha": "442e6c044619c329c521821bbd7c3a923a9d8d1a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f55a1ba12917c33d8339180f6d432076ac931da/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f55a1ba12917c33d8339180f6d432076ac931da/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5f55a1ba12917c33d8339180f6d432076ac931da", "patch": "@@ -1,3 +1,11 @@\n+2005-03-15  Dorit Naishlos  <dorit@il.ibm.com>\n+\n+\t* gcc.dg/vect/vect-54.c: Now vectorizable on targets that don't support\n+\tmisaligned accesses.\n+\t* gcc.dg/vect/vect-58.c: Likewise.\n+\t* gcc.dg/vect/vect-92.c: New.\n+\t* gcc.dg/vect/vect-93.c: New.\n+\n 2005-03-15  Feng Wang  <fengwang@nudt.edu.cn>\n \n \tPR fortran/18827"}, {"sha": "5ced09a3f63f495bc51d14526529ef04e860460e", "filename": "gcc/testsuite/gcc.dg/vect/vect-54.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f55a1ba12917c33d8339180f6d432076ac931da/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-54.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f55a1ba12917c33d8339180f6d432076ac931da/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-54.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-54.c?ref=5f55a1ba12917c33d8339180f6d432076ac931da", "patch": "@@ -50,6 +50,6 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail vect_no_align } } } */\n-/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 2 \"vect\" { xfail vect_no_align } } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { xfail vect_no_align } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 0 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" } } */"}, {"sha": "275e465f882a03e694742005fb605b5e53e18035", "filename": "gcc/testsuite/gcc.dg/vect/vect-58.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f55a1ba12917c33d8339180f6d432076ac931da/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-58.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f55a1ba12917c33d8339180f6d432076ac931da/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-58.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-58.c?ref=5f55a1ba12917c33d8339180f6d432076ac931da", "patch": "@@ -51,6 +51,6 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail vect_no_align } } } */\n-/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 2 \"vect\" { xfail vect_no_align } } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { xfail vect_no_align } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 0 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" } } */"}, {"sha": "02efc6c43264a717a85bf58cf9ed6859062c23f7", "filename": "gcc/testsuite/gcc.dg/vect/vect-92.c", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f55a1ba12917c33d8339180f6d432076ac931da/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-92.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f55a1ba12917c33d8339180f6d432076ac931da/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-92.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-92.c?ref=5f55a1ba12917c33d8339180f6d432076ac931da", "patch": "@@ -0,0 +1,90 @@\n+/* { dg-require-effective-target vect_float } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 256\n+\n+typedef float afloat __attribute__ ((__aligned__(16)));\n+\n+/* known misalignment: same alignment  */\n+\n+int\n+main1 (afloat * __restrict__ pa, afloat * __restrict__ pb, afloat * __restrict__ pc)\n+{\n+  int i;\n+\n+  for (i = 0; i < 5; i++)\n+    {\n+      pa[i+1] = pb[i+1] * pc[i+1];\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < 5; i++)\n+    {\n+      if (pa[i+1] != (pb[i+1] * pc[i+1]))\n+\tabort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int\n+main2 (afloat * __restrict__ pa, afloat * __restrict__ pb, afloat * __restrict__ pc)\n+{\n+  int i;\n+\n+  for (i = 0; i < 6; i++)\n+    {\n+      pa[i+1] = pb[i+1] * pc[i+1];\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < 6; i++)\n+    {\n+      if (pa[i+1] != (pb[i+1] * pc[i+1]))\n+\tabort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int\n+main3 (afloat * __restrict__ pa, afloat * __restrict__ pb, afloat * __restrict__ pc, int n)\n+{\n+  int i;\n+\n+  for (i = 0; i < n; i++)\n+    {\n+      pa[i+1] = pb[i+1] * pc[i+1];\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < n; i++)\n+    {\n+      if (pa[i+1] != (pb[i+1] * pc[i+1]))\n+\tabort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  int i;\n+  afloat a[N];\n+  afloat b[N] = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57};\n+  afloat c[N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19};\n+\n+  check_vect ();\n+\n+  main1 (a,b,c);\n+  main2 (a,b,c);\n+  main3 (a,b,c,N);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 3 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 0 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 3 \"vect\" } } */"}, {"sha": "fe3a81b1ba05be1efed12854cae744f2426d65cf", "filename": "gcc/testsuite/gcc.dg/vect/vect-93.c", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f55a1ba12917c33d8339180f6d432076ac931da/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-93.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f55a1ba12917c33d8339180f6d432076ac931da/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-93.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-93.c?ref=5f55a1ba12917c33d8339180f6d432076ac931da", "patch": "@@ -0,0 +1,76 @@\n+/* { dg-require-effective-target vect_float } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 3001\n+\n+typedef float afloat __attribute__ ((__aligned__(16)));\n+\n+int\n+main1 (float *pa)\n+{\n+  int i;\n+\n+  for (i = 0; i < 3001; i++)\n+    {\n+      pa[i] = 2.0;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < 3001; i++)\n+    {\n+      if (pa[i] != 2.0)\n+\tabort ();\n+    }\n+\n+  for (i = 1; i <= 10; i++)\n+    {\n+      pa[i] = 3.0;\n+    }\n+\n+  /* check results:  */\n+  for (i = 1; i <= 10; i++)\n+    {\n+      if (pa[i] != 3.0)\n+\tabort ();\n+    }\n+  \n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  int i;\n+  afloat a[N];\n+  afloat b[N];\n+\n+  check_vect ();\n+\n+  /* from bzip2: */\n+  for (i=0; i<N; i++) b[i] = i;\n+  a[0] = 0;\n+  for (i = 1; i <= 256; i++) a[i] = b[i-1];\n+\n+  /* check results:  */\n+  for (i = 1; i <= 256; i++)\n+    {\n+      if (a[i] != i-1)\n+\tabort ();\n+    }\n+  if (a[0] != 0)\n+    abort ();\n+\n+  main1 (a);\n+\n+  return 0;\n+}\n+\n+/* in main1 */\n+/* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 2 \"vect\" { target vect_no_align } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 3 \"vect\" { xfail vect_no_align } } } */\n+\n+/* in main */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail vect_no_align } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 1 \"vect\" { xfail vect_no_align } } } */"}, {"sha": "d1b274b56ecfa3e0da0f327430720ffc1051c29e", "filename": "gcc/tree-vect-analyze.c", "status": "modified", "additions": 215, "deletions": 122, "changes": 337, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f55a1ba12917c33d8339180f6d432076ac931da/gcc%2Ftree-vect-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f55a1ba12917c33d8339180f6d432076ac931da/gcc%2Ftree-vect-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-analyze.c?ref=5f55a1ba12917c33d8339180f6d432076ac931da", "patch": "@@ -50,6 +50,7 @@ static bool vect_analyze_data_refs_alignment (loop_vec_info);\n static bool vect_compute_data_refs_alignment (loop_vec_info);\n static void vect_enhance_data_refs_alignment (loop_vec_info);\n static bool vect_analyze_operations (loop_vec_info);\n+static bool vect_determine_vectorization_factor (loop_vec_info);\n \n /* Utility functions for the analyses.  */\n static bool exist_non_indexing_operands_for_use_p (tree, tree);\n@@ -285,6 +286,150 @@ vect_analyze_offset_expr (tree expr,\n }\n \n \n+/* Function vect_determine_vectorization_factor\n+\n+   Determine the vectorization factor (VF). VF is the number of data elements\n+   that are operated upon in parallel in a single iteration of the vectorized\n+   loop. For example, when vectorizing a loop that operates on 4byte elements,\n+   on a target with vector size (VS) 16byte, the VF is set to 4, since 4\n+   elements can fit in a single vector register.\n+\n+   We currently support vectorization of loops in which all types operated upon\n+   are of the same size. Therefore this function currently sets VF according to\n+   the size of the types operated upon, and fails if there are multiple sizes\n+   in the loop.\n+\n+   VF is also the factor by which the loop iterations are strip-mined, e.g.:\n+   original loop:\n+        for (i=0; i<N; i++){\n+          a[i] = b[i] + c[i];\n+        }\n+\n+   vectorized loop:\n+        for (i=0; i<N; i+=VF){\n+          a[i:VF] = b[i:VF] + c[i:VF];\n+        }\n+*/\n+\n+static bool\n+vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n+{\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  basic_block *bbs = LOOP_VINFO_BBS (loop_vinfo);\n+  int nbbs = loop->num_nodes;\n+  block_stmt_iterator si;\n+  unsigned int vectorization_factor = 0;\n+  int i;\n+  tree scalar_type;\n+\n+  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+    fprintf (vect_dump, \"=== vect_determine_vectorization_factor ===\");\n+\n+  for (i = 0; i < nbbs; i++)\n+    {\n+      basic_block bb = bbs[i];\n+\n+      for (si = bsi_start (bb); !bsi_end_p (si); bsi_next (&si))\n+        {\n+          tree stmt = bsi_stmt (si);\n+          unsigned int nunits;\n+          stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+          tree vectype;\n+\n+          if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+            {\n+              fprintf (vect_dump, \"==> examining statement: \");\n+              print_generic_expr (vect_dump, stmt, TDF_SLIM);\n+            }\n+\n+          gcc_assert (stmt_info);\n+          /* skip stmts which do not need to be vectorized.  */\n+          if (!STMT_VINFO_RELEVANT_P (stmt_info))\n+            continue;\n+\n+          if (VECTOR_MODE_P (TYPE_MODE (TREE_TYPE (stmt))))\n+            {\n+              if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n+                                        LOOP_LOC (loop_vinfo)))\n+                {\n+                  fprintf (vect_dump, \"not vectorized: vector stmt in loop:\");\n+                  print_generic_expr (vect_dump, stmt, TDF_SLIM);\n+                }\n+              return false;\n+            }\n+\n+          if (STMT_VINFO_DATA_REF (stmt_info))\n+            scalar_type = TREE_TYPE (DR_REF (STMT_VINFO_DATA_REF (stmt_info)));\n+          else if (TREE_CODE (stmt) == MODIFY_EXPR)\n+            scalar_type = TREE_TYPE (TREE_OPERAND (stmt, 0));\n+          else\n+            scalar_type = TREE_TYPE (stmt);\n+\n+          if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+            {\n+              fprintf (vect_dump, \"get vectype for scalar type:  \");\n+              print_generic_expr (vect_dump, scalar_type, TDF_SLIM);\n+            }\n+\n+          vectype = get_vectype_for_scalar_type (scalar_type);\n+          if (!vectype)\n+            {\n+              if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n+                                        LOOP_LOC (loop_vinfo)))\n+                {\n+                  fprintf (vect_dump, \"not vectorized: unsupported data-type \");\n+                  print_generic_expr (vect_dump, scalar_type, TDF_SLIM);\n+                }\n+              return false;\n+            }\n+          if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+            {\n+              fprintf (vect_dump, \"vectype: \");\n+              print_generic_expr (vect_dump, vectype, TDF_SLIM);\n+            }\n+          STMT_VINFO_VECTYPE (stmt_info) = vectype;\n+\n+          nunits = GET_MODE_NUNITS (TYPE_MODE (vectype));\n+          if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+            fprintf (vect_dump, \"nunits = %d\", nunits);\n+\n+          if (vectorization_factor)\n+            {\n+              /* FORNOW: don't allow mixed units. \n+                 This restriction will be relaxed in the future.  */\n+              if (nunits != vectorization_factor) \n+                {\n+                  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n+                                            LOOP_LOC (loop_vinfo)))\n+                    fprintf (vect_dump, \"not vectorized: mixed data-types\");\n+                  return false;\n+                }\n+            }\n+          else\n+            vectorization_factor = nunits;\n+\n+#ifdef ENABLE_CHECKING\n+          gcc_assert (GET_MODE_SIZE (TYPE_MODE (scalar_type))\n+                        * vectorization_factor == UNITS_PER_SIMD_WORD);\n+#endif\n+        }\n+    }\n+\n+  /* TODO: Analyze cost. Decide if worth while to vectorize.  */\n+\n+  if (vectorization_factor <= 1)\n+    {\n+      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n+                                LOOP_LOC (loop_vinfo)))\n+        fprintf (vect_dump, \"not vectorized: unsupported data-type\");\n+      return false;\n+    }\n+  LOOP_VINFO_VECT_FACTOR (loop_vinfo) = vectorization_factor;\n+\n+  return true;\n+}\n+\n+\n /* Function vect_analyze_operations.\n \n    Scan the loop stmts and make sure they are all vectorizable.  */\n@@ -299,21 +444,21 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n   unsigned int vectorization_factor = 0;\n   int i;\n   bool ok;\n-  tree scalar_type;\n \n   if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n     fprintf (vect_dump, \"=== vect_analyze_operations ===\");\n \n+  gcc_assert (LOOP_VINFO_VECT_FACTOR (loop_vinfo));\n+  vectorization_factor = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+\n   for (i = 0; i < nbbs; i++)\n     {\n       basic_block bb = bbs[i];\n \n       for (si = bsi_start (bb); !bsi_end_p (si); bsi_next (&si))\n \t{\n \t  tree stmt = bsi_stmt (si);\n-\t  unsigned int nunits;\n \t  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n-\t  tree vectype;\n \n \t  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n \t    {\n@@ -337,49 +482,13 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n \t      continue;\n \t    }\n \n-\t  if (VECTOR_MODE_P (TYPE_MODE (TREE_TYPE (stmt))))\n-\t    {\n-\t      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n-                                         LOOP_LOC (loop_vinfo)))\n-\t\t{\n-                  fprintf (vect_dump, \"not vectorized: vector stmt in loop:\");\n-\t\t  print_generic_expr (vect_dump, stmt, TDF_SLIM);\n-\t\t}\n-\t      return false;\n-\t    }\n-\n-          if (STMT_VINFO_DATA_REF (stmt_info))\n-            scalar_type = TREE_TYPE (DR_REF (STMT_VINFO_DATA_REF (stmt_info)));    \n-          else if (TREE_CODE (stmt) == MODIFY_EXPR)\n-\t    scalar_type = TREE_TYPE (TREE_OPERAND (stmt, 0));\n-\t  else\n-\t    scalar_type = TREE_TYPE (stmt);\n-\n-\t  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n-\t    {\n-\t      fprintf (vect_dump, \"get vectype for scalar type:  \");\n-\t      print_generic_expr (vect_dump, scalar_type, TDF_SLIM);\n-\t    }\n-\n-\t  vectype = get_vectype_for_scalar_type (scalar_type);\n-\t  if (!vectype)\n-\t    {\n-\t      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n-                                         LOOP_LOC (loop_vinfo)))\n-\t\t{\n-                  fprintf (vect_dump,\n-                           \"not vectorized: unsupported data-type \");\n-\t\t  print_generic_expr (vect_dump, scalar_type, TDF_SLIM);\n-\t\t}\n-\t      return false;\n-\t    }\n-\n-\t  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n-\t    {\n-\t      fprintf (vect_dump, \"vectype: \");\n-\t      print_generic_expr (vect_dump, vectype, TDF_SLIM);\n-\t    }\n-\t  STMT_VINFO_VECTYPE (stmt_info) = vectype;\n+#ifdef ENABLE_CHECKING\n+          if (STMT_VINFO_RELEVANT_P (stmt_info))\n+            {\n+              gcc_assert (!VECTOR_MODE_P (TYPE_MODE (TREE_TYPE (stmt))));\n+              gcc_assert (STMT_VINFO_VECTYPE (stmt_info));\n+            }\n+#endif\n \n \t  ok = (vectorizable_operation (stmt, NULL, NULL)\n \t\t|| vectorizable_assignment (stmt, NULL, NULL)\n@@ -396,44 +505,11 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n \t\t}\n \t      return false;\n \t    }\n-\n-\t  nunits = GET_MODE_NUNITS (TYPE_MODE (vectype));\n-\t  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n-\t    fprintf (vect_dump, \"nunits = %d\", nunits);\n-\n-\t  if (vectorization_factor)\n-\t    {\n-\t      /* FORNOW: don't allow mixed units.\n-\t         This restriction will be relaxed in the future.  */\n-\t      if (nunits != vectorization_factor)\n-\t\t{\n-\t          if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n-                                             LOOP_LOC (loop_vinfo)))\n-\t\t    fprintf (vect_dump, \"not vectorized: mixed data-types\");\n-\t\t  return false;\n-\t\t}\n-\t    }\n-\t  else\n-\t    vectorization_factor = nunits;\n-\n-#ifdef ENABLE_CHECKING\n-\t  gcc_assert (GET_MODE_SIZE (TYPE_MODE (scalar_type))\n-\t\t\t* vectorization_factor == UNITS_PER_SIMD_WORD);\n-#endif\n \t}\n     }\n \n   /* TODO: Analyze cost. Decide if worth while to vectorize.  */\n \n-  if (vectorization_factor <= 1)\n-    {\n-      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n-                                 LOOP_LOC (loop_vinfo)))\n-        fprintf (vect_dump, \"not vectorized: unsupported data-type\");\n-      return false;\n-    }\n-  LOOP_VINFO_VECT_FACTOR (loop_vinfo) = vectorization_factor;\n-\n   if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n       && vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n     fprintf (vect_dump,\n@@ -933,7 +1009,9 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n {\n   varray_type loop_read_datarefs = LOOP_VINFO_DATAREF_READS (loop_vinfo);\n   varray_type loop_write_datarefs = LOOP_VINFO_DATAREF_WRITES (loop_vinfo);\n-  unsigned int i;\n+  varray_type datarefs;\n+  struct data_reference *dr0 = NULL;\n+  unsigned int i, j;\n \n   /*\n      This pass will require a cost model to guide it whether to apply peeling \n@@ -1036,64 +1114,70 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \n   for (i = 0; i < VARRAY_ACTIVE_SIZE (loop_write_datarefs); i++)\n     {\n-      struct data_reference *dr = VARRAY_GENERIC_PTR (loop_write_datarefs, i);\n-      if (!aligned_access_p (dr))\n-        {\n-          LOOP_VINFO_UNALIGNED_DR (loop_vinfo) = dr;\n-          LOOP_DO_PEELING_FOR_ALIGNMENT (loop_vinfo) = true;\n+      dr0 = VARRAY_GENERIC_PTR (loop_write_datarefs, i);\n+      if (!aligned_access_p (dr0))\n+\t{\n+\t  LOOP_VINFO_UNALIGNED_DR (loop_vinfo) = dr0;\n+\t  LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo) = DR_MISALIGNMENT (dr0);\n \t  break;\n-        }\n+\t}\n     }\n \n-  if (!LOOP_VINFO_UNALIGNED_DR (loop_vinfo))\n-    {\n-      if (vect_print_dump_info (REPORT_DETAILS, LOOP_LOC (loop_vinfo)))\n-\tfprintf (vect_dump, \"Peeling for alignment will not be applied.\");\n-      return;\n-    }\n-  else\n-    if (vect_print_dump_info (REPORT_DETAILS, LOOP_LOC (loop_vinfo)))\n-      fprintf (vect_dump, \"Peeling for alignment will be applied.\");\n-\n-\n   /* (1.2) Update the alignment info according to the peeling factor.\n \t   If the misalignment of the DR we peel for is M, then the\n \t   peeling factor is VF - M, and the misalignment of each access DR_i\n \t   in the loop is DR_MISALIGNMENT (DR_i) + VF - M.\n \t   If the misalignment of the DR we peel for is unknown, then the \n \t   misalignment of each access DR_i in the loop is also unknown.\n \n-\t   FORNOW: set the misalignment of the accesses to unknown even\n-\t           if the peeling factor is known at compile time.\n+           TODO: - consider accesses that are known to have the same\n+                   alignment, even if that alignment is unknown.  */\n \n-\t   TODO: - if the peeling factor is known at compile time, use that\n-\t\t   when updating the misalignment info of the loop DRs.\n-\t\t - consider accesses that are known to have the same \n-\t\t   alignment, even if that alignment is unknown.  */\n-   \n-  for (i = 0; i < VARRAY_ACTIVE_SIZE (loop_write_datarefs); i++)\n+  if (LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo))\n     {\n-      struct data_reference *dr = VARRAY_GENERIC_PTR (loop_write_datarefs, i);\n-      if (dr == LOOP_VINFO_UNALIGNED_DR (loop_vinfo))\n+      int mis;\n+      int npeel = 0;\n+\n+      if (known_alignment_for_access_p (dr0))\n \t{\n-\t  DR_MISALIGNMENT (dr) = 0;\n-\t  if (vect_print_dump_info (REPORT_ALIGNMENT, LOOP_LOC (loop_vinfo)))\n-\t    fprintf (vect_dump, \"Alignment of access forced using peeling.\");\n+\t  /* Since it's known at compile time, compute the number of iterations\n+\t     in the peeled loop (the peeling factor) for use in updating\n+\t     DR_MISALIGNMENT values.  The peeling factor is the vectorization\n+\t     factor minus the misalignment as an element count.  */\n+\t  mis = DR_MISALIGNMENT (dr0);\n+\t  mis /= GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (DR_REF (dr0))));\n+\t  npeel = LOOP_VINFO_VECT_FACTOR (loop_vinfo) - mis;\n \t}\n-      else\n-\tDR_MISALIGNMENT (dr) = -1;\n-    }\n-  for (i = 0; i < VARRAY_ACTIVE_SIZE (loop_read_datarefs); i++)\n-    {\n-      struct data_reference *dr = VARRAY_GENERIC_PTR (loop_read_datarefs, i);\n-      if (dr == LOOP_VINFO_UNALIGNED_DR (loop_vinfo))\n+\n+      datarefs = loop_write_datarefs;\n+      for (j = 0; j < 2; j++)\n \t{\n-\t  DR_MISALIGNMENT (dr) = 0;\n-\t  if (vect_print_dump_info (REPORT_ALIGNMENT, LOOP_LOC (loop_vinfo)))\n-\t    fprintf (vect_dump, \"Alignment of access forced using peeling.\");\n+\t  for (i = 0; i < VARRAY_ACTIVE_SIZE (datarefs); i++)\n+\t    {\n+\t      struct data_reference *dr = VARRAY_GENERIC_PTR (datarefs, i);\n+\n+\t      if (dr == dr0)\n+\t\tcontinue;\n+\t      if (known_alignment_for_access_p (dr)\n+\t\t  && DR_MISALIGNMENT (dr) == DR_MISALIGNMENT (dr0))\n+\t\tDR_MISALIGNMENT (dr) = 0;\n+\t      else if (known_alignment_for_access_p (dr)\n+\t\t       && known_alignment_for_access_p (dr0))\n+\t\t{\n+\t\t  int drsize = GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (DR_REF (dr))));\n+\n+\t\t  DR_MISALIGNMENT (dr) += npeel * drsize;\n+\t\t  DR_MISALIGNMENT (dr) %= UNITS_PER_SIMD_WORD;\n+\t\t}\n+\t      else\n+\t\tDR_MISALIGNMENT (dr) = -1;\n+\t    }\n+\t  datarefs = loop_read_datarefs;\n \t}\n-      else\n-\tDR_MISALIGNMENT (dr) = -1;\n+\n+      DR_MISALIGNMENT (dr0) = 0;\n+      if (vect_print_dump_info (REPORT_ALIGNMENT, LOOP_LOC (loop_vinfo)))\n+\tfprintf (vect_dump, \"Alignment of access forced using peeling.\");\n     }\n }\n \n@@ -2479,6 +2563,15 @@ vect_analyze_loop (struct loop *loop)\n       return NULL;\n     }\n \n+  ok = vect_determine_vectorization_factor (loop_vinfo);\n+  if (!ok)\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS, LOOP_LOC (loop_vinfo)))\n+        fprintf (vect_dump, \"can't determine vectorization factor.\");\n+      destroy_loop_vec_info (loop_vinfo);\n+      return NULL;\n+    }\n+\n   /* Analyze the alignment of the data-refs in the loop.\n      FORNOW: Only aligned accesses are handled.  */\n "}, {"sha": "5dd9efecdbc90b85d7c6deb616246be9322534f4", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 59, "deletions": 36, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f55a1ba12917c33d8339180f6d432076ac931da/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f55a1ba12917c33d8339180f6d432076ac931da/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=5f55a1ba12917c33d8339180f6d432076ac931da", "patch": "@@ -64,7 +64,7 @@ static void vect_generate_tmps_on_preheader\n static tree vect_build_loop_niters (loop_vec_info);\n static void vect_update_ivs_after_vectorizer (loop_vec_info, tree, edge); \n static tree vect_gen_niters_for_prolog_loop (loop_vec_info, tree);\n-static void vect_update_inits_of_dr (struct data_reference *, tree niters);\n+static void vect_update_init_of_dr (struct data_reference *, tree niters);\n static void vect_update_inits_of_drs (loop_vec_info, tree);\n static void vect_do_peeling_for_alignment (loop_vec_info, struct loops *);\n static void vect_do_peeling_for_loop_bound \n@@ -907,7 +907,7 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \n   alignment_support_cheme = vect_supportable_dr_alignment (dr);\n   gcc_assert (alignment_support_cheme);\n-  gcc_assert (alignment_support_cheme = dr_aligned);  /* FORNOW */\n+  gcc_assert (alignment_support_cheme == dr_aligned);  /* FORNOW */\n \n   /* Handle use - get the vectorized def from the defining stmt.  */\n   vec_oprnd1 = vect_get_vec_def_for_operand (op, stmt);\n@@ -1451,14 +1451,16 @@ vect_do_peeling_for_loop_bound (loop_vec_info loop_vinfo, tree *ratio,\n \n    Set the number of iterations for the loop represented by LOOP_VINFO\n    to the minimum between LOOP_NITERS (the original iteration count of the loop)\n-   and the misalignment of DR - the first data reference recorded in\n+   and the misalignment of DR - the data reference recorded in\n    LOOP_VINFO_UNALIGNED_DR (LOOP_VINFO).  As a result, after the execution of \n    this loop, the data reference DR will refer to an aligned location.\n \n    The following computation is generated:\n \n-   compute address misalignment in bytes:\n-   addr_mis = addr & (vectype_size - 1)\n+   If the misalignment of DR is known at compile time:\n+     addr_mis = int mis = DR_MISALIGNMENT (dr);\n+   Else, compute address misalignment in bytes:\n+     addr_mis = addr & (vectype_size - 1)\n \n    prolog_niters = min ( LOOP_NITERS , (VF - addr_mis/elem_size)&(VF-1) )\n    \n@@ -1479,50 +1481,71 @@ vect_gen_niters_for_prolog_loop (loop_vec_info loop_vinfo, tree loop_niters)\n   stmt_vec_info stmt_info = vinfo_for_stmt (dr_stmt);\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   int vectype_align = TYPE_ALIGN (vectype) / BITS_PER_UNIT;\n-  tree elem_misalign;\n-  tree byte_misalign;\n-  tree new_stmts = NULL_TREE;\n-  tree start_addr = \n-\tvect_create_addr_base_for_vector_ref (dr_stmt, &new_stmts, NULL_TREE);\n-  tree ptr_type = TREE_TYPE (start_addr);\n-  tree size = TYPE_SIZE (ptr_type);\n-  tree type = lang_hooks.types.type_for_size (tree_low_cst (size, 1), 1);\n-  tree vectype_size_minus_1 = build_int_cst (type, vectype_align - 1);\n   tree vf_minus_1 = build_int_cst (unsigned_type_node, vf - 1);\n   tree niters_type = TREE_TYPE (loop_niters);\n-  tree elem_size_log = \n-\tbuild_int_cst (unsigned_type_node, exact_log2 (vectype_align/vf));\n-  tree vf_tree = build_int_cst (unsigned_type_node, vf);\n \n   pe = loop_preheader_edge (loop); \n-  new_bb = bsi_insert_on_edge_immediate (pe, new_stmts); \n-  gcc_assert (!new_bb);\n \n-  /* Create:  byte_misalign = addr & (vectype_size - 1)  */\n-  byte_misalign = build2 (BIT_AND_EXPR, type, start_addr, vectype_size_minus_1);\n+  if (LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo) > 0)\n+    {\n+      int byte_misalign = LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo);\n+      int element_size = vectype_align/vf;\n+      int elem_misalign = byte_misalign / element_size;\n \n-  /* Create:  elem_misalign = byte_misalign / element_size  */\n-  elem_misalign = \n-\tbuild2 (RSHIFT_EXPR, unsigned_type_node, byte_misalign, elem_size_log);\n+      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+        fprintf (vect_dump, \"known alignment = %d.\", byte_misalign);\n+      iters = build_int_cst (niters_type, (vf - elem_misalign)&(vf-1));\n+    }\n+  else\n+    {\n+      tree new_stmts = NULL_TREE;\n+      tree start_addr =\n+        vect_create_addr_base_for_vector_ref (dr_stmt, &new_stmts, NULL_TREE);\n+      tree ptr_type = TREE_TYPE (start_addr);\n+      tree size = TYPE_SIZE (ptr_type);\n+      tree type = lang_hooks.types.type_for_size (tree_low_cst (size, 1), 1);\n+      tree vectype_size_minus_1 = build_int_cst (type, vectype_align - 1);\n+      tree elem_size_log =\n+        build_int_cst (unsigned_type_node, exact_log2 (vectype_align/vf));\n+      tree vf_tree = build_int_cst (unsigned_type_node, vf);\n+      tree byte_misalign;\n+      tree elem_misalign;\n+\n+      new_bb = bsi_insert_on_edge_immediate (pe, new_stmts);\n+      gcc_assert (!new_bb);\n   \n-  /* Create:  (niters_type) (VF - elem_misalign)&(VF - 1)  */\n-  iters = build2 (MINUS_EXPR, unsigned_type_node, vf_tree, elem_misalign);\n-  iters = build2 (BIT_AND_EXPR, unsigned_type_node, iters, vf_minus_1);\n-  iters = fold_convert (niters_type, iters);\n+      /* Create:  byte_misalign = addr & (vectype_size - 1)  */\n+      byte_misalign = \n+        build2 (BIT_AND_EXPR, type, start_addr, vectype_size_minus_1);\n   \n+      /* Create:  elem_misalign = byte_misalign / element_size  */\n+      elem_misalign =\n+        build2 (RSHIFT_EXPR, unsigned_type_node, byte_misalign, elem_size_log);\n+\n+      /* Create:  (niters_type) (VF - elem_misalign)&(VF - 1)  */\n+      iters = build2 (MINUS_EXPR, unsigned_type_node, vf_tree, elem_misalign);\n+      iters = build2 (BIT_AND_EXPR, unsigned_type_node, iters, vf_minus_1);\n+      iters = fold_convert (niters_type, iters);\n+    }\n+\n   /* Create:  prolog_loop_niters = min (iters, loop_niters) */\n   /* If the loop bound is known at compile time we already verified that it is\n      greater than vf; since the misalignment ('iters') is at most vf, there's\n      no need to generate the MIN_EXPR in this case.  */\n   if (TREE_CODE (loop_niters) != INTEGER_CST)\n     iters = build2 (MIN_EXPR, niters_type, iters, loop_niters);\n \n+  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+    {\n+      fprintf (vect_dump, \"niters for prolog loop: \");\n+      print_generic_expr (vect_dump, iters, TDF_SLIM);\n+    }\n+\n   var = create_tmp_var (niters_type, \"prolog_loop_niters\");\n   add_referenced_tmp_var (var);\n   iters_name = force_gimple_operand (iters, &stmt, false, var);\n \n   /* Insert stmt on loop preheader edge.  */\n-  pe = loop_preheader_edge (loop);\n   if (stmt)\n     {\n       basic_block new_bb = bsi_insert_on_edge_immediate (pe, stmt);\n@@ -1533,15 +1556,15 @@ vect_gen_niters_for_prolog_loop (loop_vec_info loop_vinfo, tree loop_niters)\n }\n \n \n-/* Function vect_update_inits_of_dr\n+/* Function vect_update_init_of_dr\n \n    NITERS iterations were peeled from LOOP.  DR represents a data reference\n    in LOOP.  This function updates the information recorded in DR to\n    account for the fact that the first NITERS iterations had already been \n    executed.  Specifically, it updates the OFFSET field of stmt_info.  */\n \n static void\n-vect_update_inits_of_dr (struct data_reference *dr, tree niters)\n+vect_update_init_of_dr (struct data_reference *dr, tree niters)\n {\n   stmt_vec_info stmt_info = vinfo_for_stmt (DR_STMT (dr));\n   tree offset = STMT_VINFO_VECT_INIT_OFFSET (stmt_info);\n@@ -1574,13 +1597,13 @@ vect_update_inits_of_drs (loop_vec_info loop_vinfo, tree niters)\n   for (i = 0; i < VARRAY_ACTIVE_SIZE (loop_write_datarefs); i++)\n     {\n       struct data_reference *dr = VARRAY_GENERIC_PTR (loop_write_datarefs, i);\n-      vect_update_inits_of_dr (dr, niters);\n+      vect_update_init_of_dr (dr, niters);\n     }\n \n   for (i = 0; i < VARRAY_ACTIVE_SIZE (loop_read_datarefs); i++)\n     {\n       struct data_reference *dr = VARRAY_GENERIC_PTR (loop_read_datarefs, i);\n-      vect_update_inits_of_dr (dr, niters);\n+      vect_update_init_of_dr (dr, niters);\n     }\n }\n \n@@ -1618,8 +1641,8 @@ vect_do_peeling_for_alignment (loop_vec_info loop_vinfo, struct loops *loops)\n \n   /* Update number of times loop executes.  */\n   n_iters = LOOP_VINFO_NITERS (loop_vinfo);\n-  LOOP_VINFO_NITERS (loop_vinfo) =\n-    build2 (MINUS_EXPR, TREE_TYPE (n_iters), n_iters, niters_of_prolog_loop);\n+  LOOP_VINFO_NITERS (loop_vinfo) = fold (build2 (MINUS_EXPR,\n+\t\tTREE_TYPE (n_iters), n_iters, niters_of_prolog_loop));\n \n   /* Update the init conditions of the access functions of all data refs.  */\n   vect_update_inits_of_drs (loop_vinfo, niters_of_prolog_loop);\n@@ -1656,7 +1679,7 @@ vect_transform_loop (loop_vec_info loop_vinfo,\n   /* Peel the loop if there are data refs with unknown alignment.\n      Only one data ref with unknown store is allowed.  */\n \n-  if (LOOP_DO_PEELING_FOR_ALIGNMENT (loop_vinfo))\n+  if (LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo))\n     vect_do_peeling_for_alignment (loop_vinfo, loops);\n   \n   /* If the loop has a symbolic number of iterations 'n' (i.e. it's not a"}, {"sha": "82c108888acb566ae0a15701d7ca4e3456dcbf8e", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f55a1ba12917c33d8339180f6d432076ac931da/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f55a1ba12917c33d8339180f6d432076ac931da/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=5f55a1ba12917c33d8339180f6d432076ac931da", "patch": "@@ -963,7 +963,7 @@ slpeel_tree_peel_loop_to_edge (struct loop *loop, struct loops *loops,\n   add_bb_to_loop (bb_before_second_loop, first_loop->outer);\n \n   pre_condition =\n-        build2 (LE_EXPR, boolean_type_node, first_niters, integer_zero_node);\n+    fold (build2 (LE_EXPR, boolean_type_node, first_niters, integer_zero_node));\n   skip_e = slpeel_add_loop_guard (bb_before_first_loop, pre_condition,\n                                   bb_before_second_loop, bb_before_first_loop);\n   slpeel_update_phi_nodes_for_guard (skip_e, first_loop, true /* entry-phis */,\n@@ -1001,7 +1001,8 @@ slpeel_tree_peel_loop_to_edge (struct loop *loop, struct loops *loops,\n   bb_after_second_loop = split_edge (second_loop->single_exit);\n   add_bb_to_loop (bb_after_second_loop, second_loop->outer);\n \n-  pre_condition = build2 (EQ_EXPR, boolean_type_node, first_niters, niters);\n+  pre_condition = \n+\tfold (build2 (EQ_EXPR, boolean_type_node, first_niters, niters));\n   skip_e = slpeel_add_loop_guard (bb_between_loops, pre_condition,\n                                   bb_after_second_loop, bb_before_first_loop);\n   slpeel_update_phi_nodes_for_guard (skip_e, second_loop, false /* exit-phis */,\n@@ -1213,7 +1214,7 @@ new_loop_vec_info (struct loop *loop)\n   LOOP_VINFO_EXIT_COND (res) = NULL;\n   LOOP_VINFO_NITERS (res) = NULL;\n   LOOP_VINFO_VECTORIZABLE_P (res) = 0;\n-  LOOP_DO_PEELING_FOR_ALIGNMENT (res) = false;\n+  LOOP_PEELING_FOR_ALIGNMENT (res) = 0;\n   LOOP_VINFO_VECT_FACTOR (res) = 0;\n   VARRAY_GENERIC_PTR_INIT (LOOP_VINFO_DATAREF_WRITES (res), 20,\n \t\t\t   \"loop_write_datarefs\");"}, {"sha": "e32eed2364a27b9458288c73638a21f82873abd1", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f55a1ba12917c33d8339180f6d432076ac931da/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f55a1ba12917c33d8339180f6d432076ac931da/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=5f55a1ba12917c33d8339180f6d432076ac931da", "patch": "@@ -95,9 +95,15 @@ typedef struct _loop_vec_info {\n   /* Unknown DRs according to which loop was peeled.  */\n   struct data_reference *unaligned_dr;\n \n-  /* If true, loop is peeled.\n-   unaligned_drs show in this case DRs used for peeling.  */\n-  bool do_peeling_for_alignment;\n+  /* peeling_for_alignment indicates whether peeling for alignment will take\n+     place, and what the peeling factor should be:\n+     peeling_for_alignment = X means:\n+        If X=0: Peeling for alignment will not be applied.\n+        If X>0: Peel first X iterations.\n+        If X=-1: Generate a runtime test to calculate the number of iterations\n+                 to be peeled, using the dataref recorded in the field\n+                 unaligned_dr.  */\n+  int peeling_for_alignment;\n \n   /* All data references in the loop that are being written to.  */\n   varray_type data_ref_writes;\n@@ -119,7 +125,7 @@ typedef struct _loop_vec_info {\n #define LOOP_VINFO_DATAREF_WRITES(L) (L)->data_ref_writes\n #define LOOP_VINFO_DATAREF_READS(L)  (L)->data_ref_reads\n #define LOOP_VINFO_INT_NITERS(L) (TREE_INT_CST_LOW ((L)->num_iters))\n-#define LOOP_DO_PEELING_FOR_ALIGNMENT(L) (L)->do_peeling_for_alignment\n+#define LOOP_PEELING_FOR_ALIGNMENT(L) (L)->peeling_for_alignment\n #define LOOP_VINFO_UNALIGNED_DR(L) (L)->unaligned_dr\n #define LOOP_VINFO_LOC(L)          (L)->loop_line_number\n \n@@ -242,7 +248,8 @@ vinfo_for_stmt (tree stmt)\n /* Info on data references alignment.                              */\n /*-----------------------------------------------------------------*/\n \n-/* The misalignment of the memory access in bytes.  */\n+/* Reflects actual alignment of first access in the vectorized loop,\n+   taking into account peeling/versioning if applied.  */\n #define DR_MISALIGNMENT(DR)   (DR)->aux\n \n static inline bool\n@@ -252,9 +259,9 @@ aligned_access_p (struct data_reference *data_ref_info)\n }\n \n static inline bool\n-unknown_alignment_for_access_p (struct data_reference *data_ref_info)\n+known_alignment_for_access_p (struct data_reference *data_ref_info)\n {\n-  return (DR_MISALIGNMENT (data_ref_info) == -1);\n+  return (DR_MISALIGNMENT (data_ref_info) != -1);\n }\n \n /* Perform signed modulo, always returning a non-negative value.  */"}]}