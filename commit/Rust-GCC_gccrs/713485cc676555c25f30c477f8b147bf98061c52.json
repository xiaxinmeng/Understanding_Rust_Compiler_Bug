{"sha": "713485cc676555c25f30c477f8b147bf98061c52", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzEzNDg1Y2M2NzY1NTVjMjVmMzBjNDc3ZjhiMTQ3YmY5ODA2MWM1Mg==", "commit": {"author": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2009-05-06T21:17:16Z"}, "committer": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2009-05-06T21:17:16Z"}, "message": "re PR fortran/39630 ([F03] Procedure Pointer Components)\n\n2009-05-06  Janus Weil  <janus@gcc.gnu.org>\n\t    Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/39630\n\t* decl.c (match_procedure_interface): New function to match the\n\tinterface for a PROCEDURE statement.\n\t(match_procedure_decl): Call match_procedure_interface.\n\t(match_ppc_decl): New function to match the declaration of a\n\tprocedure pointer component.\n\t(gfc_match_procedure):  Call match_ppc_decl.\n\t(match_binding_attributes): Add new argument 'ppc' and handle the\n\tPOINTER attribute for procedure pointer components.\n\t(match_procedure_in_type,gfc_match_generic): Added new argument to\n\tmatch_binding_attributes.\n\t* dump-parse-tree.c (show_expr,show_components,show_code_node): Handle\n\tprocedure pointer components.\n\t* expr.c (free_expr0,gfc_copy_expr,gfc_simplify_expr): Handle EXPR_PPC.\n\t(gfc_check_pointer_assign): Handle procedure pointer components, but no\n\tfull checking yet.\n\t(is_proc_ptr_comp): New function to determine if an expression is a\n\tprocedure pointer component.\n\t* gfortran.h (expr_t): Add EXPR_PPC.\n\t(symbol_attribute): Add new member 'proc_pointer_comp'.\n\t(gfc_component): Add new member 'formal'.\n\t(gfc_exec_op): Add EXEC_CALL_PPC.\n\t(gfc_get_default_type): Changed first argument.\n\t(is_proc_ptr_comp): Add prototype.\n\t(gfc_match_varspec): Add new argument.\n\t* interface.c (compare_actual_formal): Handle procedure pointer\n\tcomponents.\n\t* match.c (gfc_match_pointer_assignment,match_typebound_call): Handle\n\tprocedure pointer components.\n\t* module.c (mio_expr): Handle EXPR_PPC.\n\t* parse.c (parse_derived): Handle procedure pointer components.\n\t* primary.c (gfc_match_varspec): Add new argument 'ppc_arg' and handle\n\tprocedure pointer components.\n\t(gfc_variable_attr): Handle procedure pointer components.\n\t(gfc_match_rvalue): Added new argument to gfc_match_varspec and changed\n\tfirst argument of gfc_get_default_type.\n\t(match_variable): Added new argument to gfc_match_varspec.\n\t* resolve.c (resolve_entries,set_type,resolve_fl_parameter): Changed\n\tfirst argument of gfc_get_default_type.\n\t(resolve_structure_cons,resolve_actual_arglist): Handle procedure\n\tpointer components.\n\t(resolve_ppc_call): New function to resolve a call to a procedure\n\tpointer component (subroutine).\n\t(resolve_expr_ppc): New function to resolve a call to a procedure\n\tpointer component (function).\n\t(gfc_resolve_expr): Handle EXPR_PPC.\n\t(resolve_code): Handle EXEC_CALL_PPC.\n\t(resolve_fl_derived): Copy the interface for a procedure pointer\n\tcomponent.\n\t(resolve_symbol): Fix overlong line.\n\t* st.c (gfc_free_statement): Handle EXEC_CALL_PPC.\n\t* symbol.c (gfc_get_default_type): Changed first argument.\n\t(gfc_set_default_type): Changed first argument of gfc_get_default_type.\n\t(gfc_add_component): Initialize ts.type to BT_UNKNOWN.\n\t* trans.h (gfc_conv_function_call): Renamed.\n\t* trans.c (gfc_trans_code): Handle EXEC_CALL_PPC.\n\t* trans-expr.c (gfc_conv_component_ref): Ditto.\n\t(gfc_conv_function_val): Rename to 'conv_function_val', add new\n\targument 'expr' and handle procedure pointer components.\n\t(gfc_conv_operator_assign): Renamed gfc_conv_function_val.\n\t(gfc_apply_interface_mapping_to_expr): Handle EXPR_PPC.\n\t(gfc_conv_function_call): Rename to 'gfc_conv_procedure_call', add new\n\targument 'expr' and handle procedure pointer components.\n\t(gfc_get_proc_ptr_comp): New function to get the backend decl for a\n\tprocedure pointer component.\n\t(gfc_conv_function_expr): Renamed gfc_conv_function_call.\n\t(gfc_conv_structure): Handle procedure pointer components.\n\t* trans-intrinsic.c (gfc_conv_intrinsic_funcall,\n\tconv_generic_with_optional_char_arg): Renamed gfc_conv_function_call.\n\t* trans-stmt.h (gfc_get_proc_ptr_comp): Add prototype.\n\t* trans-stmt.c (gfc_trans_call): Renamed gfc_conv_function_call.\n\t* trans-types.h (gfc_get_ppc_type): Add prototype.\n\t* trans-types.c (gfc_get_ppc_type): New function to build a tree node\n\tfor a procedure pointer component.\n\t(gfc_get_derived_type): Handle procedure pointer components.\n\n\n2009-05-06  Janus Weil  <janus@gcc.gnu.org>\n\n\tPR fortran/39630\n\t* gfortran.dg/proc_decl_1.f90: Modified.\n\t* gfortran.dg/proc_ptr_comp_1.f90: New.\n\t* gfortran.dg/proc_ptr_comp_2.f90: New.\n\t* gfortran.dg/proc_ptr_comp_3.f90: New.\n\t* gfortran.dg/proc_ptr_comp_4.f90: New.\n\t* gfortran.dg/proc_ptr_comp_5.f90: New.\n\t* gfortran.dg/proc_ptr_comp_6.f90: New.\n\n\nCo-Authored-By: Paul Thomas <pault@gcc.gnu.org>\n\nFrom-SVN: r147206", "tree": {"sha": "0bf13a907194f732406ab43f087a5e03de7889c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0bf13a907194f732406ab43f087a5e03de7889c7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/713485cc676555c25f30c477f8b147bf98061c52", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/713485cc676555c25f30c477f8b147bf98061c52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/713485cc676555c25f30c477f8b147bf98061c52", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/713485cc676555c25f30c477f8b147bf98061c52/comments", "author": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "641cac0b195f01af249f6e96207b7b27c3094557", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/641cac0b195f01af249f6e96207b7b27c3094557", "html_url": "https://github.com/Rust-GCC/gccrs/commit/641cac0b195f01af249f6e96207b7b27c3094557"}], "stats": {"total": 1272, "additions": 1110, "deletions": 162}, "files": [{"sha": "2bb9a540fc446779700ced0b7f7fae889135988d", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/713485cc676555c25f30c477f8b147bf98061c52/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/713485cc676555c25f30c477f8b147bf98061c52/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=713485cc676555c25f30c477f8b147bf98061c52", "patch": "@@ -1,3 +1,82 @@\n+2009-05-06  Janus Weil  <janus@gcc.gnu.org>\n+\t    Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/39630\n+\t* decl.c (match_procedure_interface): New function to match the\n+\tinterface for a PROCEDURE statement.\n+\t(match_procedure_decl): Call match_procedure_interface.\n+\t(match_ppc_decl): New function to match the declaration of a\n+\tprocedure pointer component.\n+\t(gfc_match_procedure):  Call match_ppc_decl.\n+\t(match_binding_attributes): Add new argument 'ppc' and handle the\n+\tPOINTER attribute for procedure pointer components.\n+\t(match_procedure_in_type,gfc_match_generic): Added new argument to\n+\tmatch_binding_attributes.\n+\t* dump-parse-tree.c (show_expr,show_components,show_code_node): Handle\n+\tprocedure pointer components.\n+\t* expr.c (free_expr0,gfc_copy_expr,gfc_simplify_expr): Handle EXPR_PPC.\n+\t(gfc_check_pointer_assign): Handle procedure pointer components, but no\n+\tfull checking yet.\n+\t(is_proc_ptr_comp): New function to determine if an expression is a\n+\tprocedure pointer component.\n+\t* gfortran.h (expr_t): Add EXPR_PPC.\n+\t(symbol_attribute): Add new member 'proc_pointer_comp'.\n+\t(gfc_component): Add new member 'formal'.\n+\t(gfc_exec_op): Add EXEC_CALL_PPC.\n+\t(gfc_get_default_type): Changed first argument.\n+\t(is_proc_ptr_comp): Add prototype.\n+\t(gfc_match_varspec): Add new argument.\n+\t* interface.c (compare_actual_formal): Handle procedure pointer\n+\tcomponents.\n+\t* match.c (gfc_match_pointer_assignment,match_typebound_call): Handle\n+\tprocedure pointer components.\n+\t* module.c (mio_expr): Handle EXPR_PPC.\n+\t* parse.c (parse_derived): Handle procedure pointer components.\n+\t* primary.c (gfc_match_varspec): Add new argument 'ppc_arg' and handle\n+\tprocedure pointer components.\n+\t(gfc_variable_attr): Handle procedure pointer components.\n+\t(gfc_match_rvalue): Added new argument to gfc_match_varspec and changed\n+\tfirst argument of gfc_get_default_type.\n+\t(match_variable): Added new argument to gfc_match_varspec.\n+\t* resolve.c (resolve_entries,set_type,resolve_fl_parameter): Changed\n+\tfirst argument of gfc_get_default_type.\n+\t(resolve_structure_cons,resolve_actual_arglist): Handle procedure\n+\tpointer components.\n+\t(resolve_ppc_call): New function to resolve a call to a procedure\n+\tpointer component (subroutine).\n+\t(resolve_expr_ppc): New function to resolve a call to a procedure\n+\tpointer component (function).\n+\t(gfc_resolve_expr): Handle EXPR_PPC.\n+\t(resolve_code): Handle EXEC_CALL_PPC.\n+\t(resolve_fl_derived): Copy the interface for a procedure pointer\n+\tcomponent.\n+\t(resolve_symbol): Fix overlong line.\n+\t* st.c (gfc_free_statement): Handle EXEC_CALL_PPC.\n+\t* symbol.c (gfc_get_default_type): Changed first argument.\n+\t(gfc_set_default_type): Changed first argument of gfc_get_default_type.\n+\t(gfc_add_component): Initialize ts.type to BT_UNKNOWN.\n+\t* trans.h (gfc_conv_function_call): Renamed.\n+\t* trans.c (gfc_trans_code): Handle EXEC_CALL_PPC.\n+\t* trans-expr.c (gfc_conv_component_ref): Ditto.\n+\t(gfc_conv_function_val): Rename to 'conv_function_val', add new\n+\targument 'expr' and handle procedure pointer components.\n+\t(gfc_conv_operator_assign): Renamed gfc_conv_function_val.\n+\t(gfc_apply_interface_mapping_to_expr): Handle EXPR_PPC.\n+\t(gfc_conv_function_call): Rename to 'gfc_conv_procedure_call', add new\n+\targument 'expr' and handle procedure pointer components.\n+\t(gfc_get_proc_ptr_comp): New function to get the backend decl for a\n+\tprocedure pointer component.\n+\t(gfc_conv_function_expr): Renamed gfc_conv_function_call.\n+\t(gfc_conv_structure): Handle procedure pointer components.\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_funcall,\n+\tconv_generic_with_optional_char_arg): Renamed gfc_conv_function_call.\n+\t* trans-stmt.h (gfc_get_proc_ptr_comp): Add prototype.\n+\t* trans-stmt.c (gfc_trans_call): Renamed gfc_conv_function_call.\n+\t* trans-types.h (gfc_get_ppc_type): Add prototype.\n+\t* trans-types.c (gfc_get_ppc_type): New function to build a tree node\n+\tfor a procedure pointer component.\n+\t(gfc_get_derived_type): Handle procedure pointer components.\n+\n 2009-05-06  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/40041"}, {"sha": "f3ff0e683809fffa107e3edf3cafa77550a937b7", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 241, "deletions": 66, "changes": 307, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/713485cc676555c25f30c477f8b147bf98061c52/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/713485cc676555c25f30c477f8b147bf98061c52/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=713485cc676555c25f30c477f8b147bf98061c52", "patch": "@@ -4145,17 +4145,14 @@ add_hidden_procptr_result (gfc_symbol *sym)\n }\n \n \n-/* Match a PROCEDURE declaration (R1211).  */\n+/* Match the interface for a PROCEDURE declaration,\n+   including brackets (R1212).  */\n \n static match\n-match_procedure_decl (void)\n+match_procedure_interface (gfc_symbol **proc_if)\n {\n   match m;\n   locus old_loc, entry_loc;\n-  gfc_symbol *sym, *proc_if = NULL;\n-  int num;\n-  gfc_expr *initializer = NULL;\n-\n   old_loc = entry_loc = gfc_current_locus;\n \n   gfc_clear_ts (&current_ts);\n@@ -4180,45 +4177,43 @@ match_procedure_decl (void)\n \n   /* Get the name of the procedure or abstract interface\n   to inherit the interface from.  */\n-  m = gfc_match_symbol (&proc_if, 1);\n-\n-  if (m == MATCH_NO)\n-    goto syntax;\n-  else if (m == MATCH_ERROR)\n+  m = gfc_match_symbol (proc_if, 1);\n+  if (m != MATCH_YES)\n     return m;\n \n   /* Various interface checks.  */\n-  if (proc_if)\n+  if (*proc_if)\n     {\n-      proc_if->refs++;\n+      (*proc_if)->refs++;\n       /* Resolve interface if possible. That way, attr.procedure is only set\n \t if it is declared by a later procedure-declaration-stmt, which is\n \t invalid per C1212.  */\n-      while (proc_if->ts.interface)\n-\tproc_if = proc_if->ts.interface;\n+      while ((*proc_if)->ts.interface)\n+\t*proc_if = (*proc_if)->ts.interface;\n \n-      if (proc_if->generic)\n+      if ((*proc_if)->generic)\n \t{\n-\t  gfc_error (\"Interface '%s' at %C may not be generic\", proc_if->name);\n+\t  gfc_error (\"Interface '%s' at %C may not be generic\",\n+\t\t     (*proc_if)->name);\n \t  return MATCH_ERROR;\n \t}\n-      if (proc_if->attr.proc == PROC_ST_FUNCTION)\n+      if ((*proc_if)->attr.proc == PROC_ST_FUNCTION)\n \t{\n \t  gfc_error (\"Interface '%s' at %C may not be a statement function\",\n-\t\t    proc_if->name);\n+\t\t     (*proc_if)->name);\n \t  return MATCH_ERROR;\n \t}\n       /* Handle intrinsic procedures.  */\n-      if (!(proc_if->attr.external || proc_if->attr.use_assoc\n-\t    || proc_if->attr.if_source == IFSRC_IFBODY)\n-\t  && (gfc_is_intrinsic (proc_if, 0, gfc_current_locus)\n-\t      || gfc_is_intrinsic (proc_if, 1, gfc_current_locus)))\n-\tproc_if->attr.intrinsic = 1;\n-      if (proc_if->attr.intrinsic\n-\t  && !gfc_intrinsic_actual_ok (proc_if->name, 0))\n+      if (!((*proc_if)->attr.external || (*proc_if)->attr.use_assoc\n+\t    || (*proc_if)->attr.if_source == IFSRC_IFBODY)\n+\t  && (gfc_is_intrinsic ((*proc_if), 0, gfc_current_locus)\n+\t      || gfc_is_intrinsic ((*proc_if), 1, gfc_current_locus)))\n+\t(*proc_if)->attr.intrinsic = 1;\n+      if ((*proc_if)->attr.intrinsic\n+\t  && !gfc_intrinsic_actual_ok ((*proc_if)->name, 0))\n \t{\n \t  gfc_error (\"Intrinsic procedure '%s' not allowed \"\n-\t\t    \"in PROCEDURE statement at %C\", proc_if->name);\n+\t\t    \"in PROCEDURE statement at %C\", (*proc_if)->name);\n \t  return MATCH_ERROR;\n \t}\n     }\n@@ -4230,7 +4225,26 @@ match_procedure_decl (void)\n       return MATCH_NO;\n     }\n \n-  /* Parse attributes.  */\n+  return MATCH_YES;\n+}\n+\n+\n+/* Match a PROCEDURE declaration (R1211).  */\n+\n+static match\n+match_procedure_decl (void)\n+{\n+  match m;\n+  gfc_symbol *sym, *proc_if = NULL;\n+  int num;\n+  gfc_expr *initializer = NULL;\n+\n+  /* Parse interface (with brackets). */\n+  m = match_procedure_interface (&proc_if);\n+  if (m != MATCH_YES)\n+    return m;\n+\n+  /* Parse attributes (with colons).  */\n   m = match_attr_spec();\n   if (m == MATCH_ERROR)\n     return MATCH_ERROR;\n@@ -4360,6 +4374,138 @@ match_procedure_decl (void)\n }\n \n \n+static match\n+match_binding_attributes (gfc_typebound_proc* ba, bool generic, bool ppc);\n+\n+\n+/* Match a procedure pointer component declaration (R445).  */\n+\n+static match\n+match_ppc_decl (void)\n+{\n+  match m;\n+  gfc_symbol *proc_if = NULL;\n+  gfc_typespec ts;\n+  int num;\n+  gfc_component *c;\n+  gfc_expr *initializer = NULL;\n+  gfc_typebound_proc* tb;\n+  char name[GFC_MAX_SYMBOL_LEN + 1];\n+\n+  /* Parse interface (with brackets).  */\n+  m = match_procedure_interface (&proc_if);\n+  if (m != MATCH_YES)\n+    goto syntax;\n+\n+  /* Parse attributes.  */\n+  tb = XCNEW (gfc_typebound_proc);\n+  tb->where = gfc_current_locus;\n+  m = match_binding_attributes (tb, false, true);\n+  if (m == MATCH_ERROR)\n+    return m;\n+\n+  /* TODO: Implement PASS.  */\n+  if (!tb->nopass)\n+    {\n+      gfc_error (\"Procedure Pointer Component with PASS at %C \"\n+\t\t \"not yet implemented\");\n+      return MATCH_ERROR;\n+    }\n+\n+  gfc_clear_attr (&current_attr);\n+  current_attr.procedure = 1;\n+  current_attr.proc_pointer = 1;\n+  current_attr.access = tb->access;\n+  current_attr.flavor = FL_PROCEDURE;\n+\n+  /* Match the colons (required).  */\n+  if (gfc_match (\" ::\") != MATCH_YES)\n+    {\n+      gfc_error (\"Expected '::' after binding-attributes at %C\");\n+      return MATCH_ERROR;\n+    }\n+\n+  /* Check for C450.  */\n+  if (!tb->nopass && proc_if == NULL)\n+    {\n+      gfc_error(\"NOPASS or explicit interface required at %C\");\n+      return MATCH_ERROR;\n+    }\n+\n+  /* Match PPC names.  */\n+  ts = current_ts;\n+  for(num=1;;num++)\n+    {\n+      m = gfc_match_name (name);\n+      if (m == MATCH_NO)\n+\tgoto syntax;\n+      else if (m == MATCH_ERROR)\n+\treturn m;\n+\n+      if (gfc_add_component (gfc_current_block (), name, &c) == FAILURE)\n+\treturn MATCH_ERROR;\n+\n+      /* Add current_attr to the symbol attributes.  */\n+      if (gfc_copy_attr (&c->attr, &current_attr, NULL) == FAILURE)\n+\treturn MATCH_ERROR;\n+\n+      if (gfc_add_external (&c->attr, NULL) == FAILURE)\n+\treturn MATCH_ERROR;\n+\n+      if (gfc_add_proc (&c->attr, name, NULL) == FAILURE)\n+\treturn MATCH_ERROR;\n+\n+      /* Set interface.  */\n+      if (proc_if != NULL)\n+\t{\n+\t  c->ts.interface = proc_if;\n+\t  c->attr.untyped = 1;\n+\t  c->attr.if_source = IFSRC_IFBODY;\n+\t}\n+      else if (ts.type != BT_UNKNOWN)\n+\t{\n+\t  c->ts = ts;\n+\t  c->ts.interface = gfc_new_symbol (\"\", gfc_current_ns);\n+\t  c->ts.interface->ts = ts;\n+\t  c->ts.interface->attr.function = 1;\n+\t  c->attr.function = c->ts.interface->attr.function;\n+\t  c->attr.if_source = IFSRC_UNKNOWN;\n+\t}\n+\n+      if (gfc_match (\" =>\") == MATCH_YES)\n+\t{\n+\t  m = gfc_match_null (&initializer);\n+\t  if (m == MATCH_NO)\n+\t    {\n+\t      gfc_error (\"Pointer initialization requires a NULL() at %C\");\n+\t      m = MATCH_ERROR;\n+\t    }\n+\t  if (gfc_pure (NULL))\n+\t    {\n+\t      gfc_error (\"Initialization of pointer at %C is not allowed in \"\n+\t\t\t \"a PURE procedure\");\n+\t      m = MATCH_ERROR;\n+\t    }\n+\t  if (m != MATCH_YES)\n+\t    {\n+\t      gfc_free_expr (initializer);\n+\t      return m;\n+\t    }\n+\t  c->initializer = initializer;\n+\t}\n+\n+      if (gfc_match_eos () == MATCH_YES)\n+\treturn MATCH_YES;\n+      if (gfc_match_char (',') != MATCH_YES)\n+\tgoto syntax;\n+    }\n+\n+syntax:\n+  gfc_error (\"Syntax error in procedure pointer component at %C\");\n+  return MATCH_ERROR;\n+}\n+\n+\n /* Match a PROCEDURE declaration inside an interface (R1206).  */\n \n static match\n@@ -4425,9 +4571,8 @@ gfc_match_procedure (void)\n       m = match_procedure_in_interface ();\n       break;\n     case COMP_DERIVED:\n-      gfc_error (\"Fortran 2003: Procedure components at %C are not yet\"\n-\t\t \" implemented in gfortran\");\n-      return MATCH_ERROR;\n+      m = match_ppc_decl ();\n+      break;\n     case COMP_DERIVED_CONTAINS:\n       m = match_procedure_in_type ();\n       break;\n@@ -6830,9 +6975,10 @@ gfc_match_enumerator_def (void)\n /* Match binding attributes.  */\n \n static match\n-match_binding_attributes (gfc_typebound_proc* ba, bool generic)\n+match_binding_attributes (gfc_typebound_proc* ba, bool generic, bool ppc)\n {\n   bool found_passing = false;\n+  bool seen_ptr = false;\n   match m;\n \n   /* Intialize to defaults.  Do so even before the MATCH_NO check so that in\n@@ -6907,38 +7053,6 @@ match_binding_attributes (gfc_typebound_proc* ba, bool generic)\n \t      continue;\n \t    }\n \n-\t  /* NON_OVERRIDABLE flag.  */\n-\t  m = gfc_match (\" non_overridable\");\n-\t  if (m == MATCH_ERROR)\n-\t    goto error;\n-\t  if (m == MATCH_YES)\n-\t    {\n-\t      if (ba->non_overridable)\n-\t\t{\n-\t\t  gfc_error (\"Duplicate NON_OVERRIDABLE at %C\");\n-\t\t  goto error;\n-\t\t}\n-\n-\t      ba->non_overridable = 1;\n-\t      continue;\n-\t    }\n-\n-\t  /* DEFERRED flag.  */\n-\t  m = gfc_match (\" deferred\");\n-\t  if (m == MATCH_ERROR)\n-\t    goto error;\n-\t  if (m == MATCH_YES)\n-\t    {\n-\t      if (ba->deferred)\n-\t\t{\n-\t\t  gfc_error (\"Duplicate DEFERRED at %C\");\n-\t\t  goto error;\n-\t\t}\n-\n-\t      ba->deferred = 1;\n-\t      continue;\n-\t    }\n-\n \t  /* PASS possibly including argument.  */\n \t  m = gfc_match (\" pass\");\n \t  if (m == MATCH_ERROR)\n@@ -6966,6 +7080,60 @@ match_binding_attributes (gfc_typebound_proc* ba, bool generic)\n \t      continue;\n \t    }\n \n+\t  if (ppc)\n+\t    {\n+\t      /* POINTER flag.  */\n+\t      m = gfc_match (\" pointer\");\n+\t      if (m == MATCH_ERROR)\n+\t\tgoto error;\n+\t      if (m == MATCH_YES)\n+\t\t{\n+\t\t  if (seen_ptr)\n+\t\t    {\n+\t\t      gfc_error (\"Duplicate POINTER attribute at %C\");\n+\t\t      goto error;\n+\t\t    }\n+\n+\t\t  seen_ptr = true;\n+\t\t  /*ba->ppc = 1;*/\n+        \t  continue;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      /* NON_OVERRIDABLE flag.  */\n+\t      m = gfc_match (\" non_overridable\");\n+\t      if (m == MATCH_ERROR)\n+\t\tgoto error;\n+\t      if (m == MATCH_YES)\n+\t\t{\n+\t\t  if (ba->non_overridable)\n+\t\t    {\n+\t\t      gfc_error (\"Duplicate NON_OVERRIDABLE at %C\");\n+\t\t      goto error;\n+\t\t    }\n+\n+\t\t  ba->non_overridable = 1;\n+\t\t  continue;\n+\t\t}\n+\n+\t      /* DEFERRED flag.  */\n+\t      m = gfc_match (\" deferred\");\n+\t      if (m == MATCH_ERROR)\n+\t\tgoto error;\n+\t      if (m == MATCH_YES)\n+\t\t{\n+\t\t  if (ba->deferred)\n+\t\t    {\n+\t\t      gfc_error (\"Duplicate DEFERRED at %C\");\n+\t\t      goto error;\n+\t\t    }\n+\n+\t\t  ba->deferred = 1;\n+\t\t  continue;\n+\t\t}\n+\t    }\n+\n \t}\n \n       /* Nothing matching found.  */\n@@ -6987,6 +7155,13 @@ match_binding_attributes (gfc_typebound_proc* ba, bool generic)\n   if (ba->access == ACCESS_UNKNOWN)\n     ba->access = gfc_typebound_default_access;\n \n+  if (ppc && !seen_ptr)\n+    {\n+      gfc_error (\"POINTER attribute is required for procedure pointer component\"\n+                 \" at %C\");\n+      goto error;\n+    }\n+\n   return MATCH_YES;\n \n error:\n@@ -7043,7 +7218,7 @@ match_procedure_in_type (void)\n   tb->is_generic = 0;\n \n   /* Match binding attributes.  */\n-  m = match_binding_attributes (tb, false);\n+  m = match_binding_attributes (tb, false, false);\n   if (m == MATCH_ERROR)\n     return m;\n   seen_attrs = (m == MATCH_YES);\n@@ -7192,7 +7367,7 @@ gfc_match_generic (void)\n   gcc_assert (block && ns);\n \n   /* See if we get an access-specifier.  */\n-  m = match_binding_attributes (&tbattr, true);\n+  m = match_binding_attributes (&tbattr, true, false);\n   if (m == MATCH_ERROR)\n     goto error;\n "}, {"sha": "e007a54aea037edba85bc868838bcb759ff2caaa", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/713485cc676555c25f30c477f8b147bf98061c52/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/713485cc676555c25f30c477f8b147bf98061c52/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=713485cc676555c25f30c477f8b147bf98061c52", "patch": "@@ -541,13 +541,20 @@ show_expr (gfc_expr *p)\n     case EXPR_FUNCTION:\n       if (p->value.function.name == NULL)\n \t{\n-\t  fprintf (dumpfile, \"%s[\", p->symtree->n.sym->name);\n+\t  fprintf (dumpfile, \"%s\", p->symtree->n.sym->name);\n+\t  if (is_proc_ptr_comp (p, NULL))\n+\t    show_ref (p->ref);\n+\t  fputc ('[', dumpfile);\n \t  show_actual_arglist (p->value.function.actual);\n \t  fputc (']', dumpfile);\n \t}\n       else\n \t{\n-\t  fprintf (dumpfile, \"%s[[\", p->value.function.name);\n+\t  fprintf (dumpfile, \"%s\", p->value.function.name);\n+\t  if (is_proc_ptr_comp (p, NULL))\n+\t    show_ref (p->ref);\n+\t  fputc ('[', dumpfile);\n+\t  fputc ('[', dumpfile);\n \t  show_actual_arglist (p->value.function.actual);\n \t  fputc (']', dumpfile);\n \t  fputc (']', dumpfile);\n@@ -653,6 +660,8 @@ show_components (gfc_symbol *sym)\n       show_typespec (&c->ts);\n       if (c->attr.pointer)\n \tfputs (\" POINTER\", dumpfile);\n+      if (c->attr.proc_pointer)\n+\tfputs (\" PPC\", dumpfile);\n       if (c->attr.dimension)\n \tfputs (\" DIMENSION\", dumpfile);\n       fputc (' ', dumpfile);\n@@ -1212,6 +1221,12 @@ show_code_node (int level, gfc_code *c)\n       show_compcall (c->expr);\n       break;\n \n+    case EXEC_CALL_PPC:\n+      fputs (\"CALL \", dumpfile);\n+      show_expr (c->expr);\n+      show_actual_arglist (c->ext.actual);\n+      break;\n+\n     case EXEC_RETURN:\n       fputs (\"RETURN \", dumpfile);\n       if (c->expr)"}, {"sha": "feaa625484002f8d210af9a6b438b291afd87535", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 44, "deletions": 6, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/713485cc676555c25f30c477f8b147bf98061c52/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/713485cc676555c25f30c477f8b147bf98061c52/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=713485cc676555c25f30c477f8b147bf98061c52", "patch": "@@ -182,6 +182,7 @@ free_expr0 (gfc_expr *e)\n       break;\n \n     case EXPR_COMPCALL:\n+    case EXPR_PPC:\n       gfc_free_actual_arglist (e->value.compcall.actual);\n       break;\n \n@@ -507,6 +508,7 @@ gfc_copy_expr (gfc_expr *p)\n       break;\n \n     case EXPR_COMPCALL:\n+    case EXPR_PPC:\n       q->value.compcall.actual =\n \tgfc_copy_actual_arglist (p->value.compcall.actual);\n       q->value.compcall.tbp = p->value.compcall.tbp;\n@@ -1728,6 +1730,7 @@ gfc_simplify_expr (gfc_expr *p, int type)\n       break;\n \n     case EXPR_COMPCALL:\n+    case EXPR_PPC:\n       gcc_unreachable ();\n       break;\n     }\n@@ -3038,7 +3041,7 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n   symbol_attribute attr;\n   gfc_ref *ref;\n   int is_pure;\n-  int pointer, check_intent_in;\n+  int pointer, check_intent_in, proc_pointer;\n \n   if (lvalue->symtree->n.sym->ts.type == BT_UNKNOWN\n       && !lvalue->symtree->n.sym->attr.proc_pointer)\n@@ -3062,16 +3065,19 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n   /* Check INTENT(IN), unless the object itself is the component or\n      sub-component of a pointer.  */\n   check_intent_in = 1;\n-  pointer = lvalue->symtree->n.sym->attr.pointer\n-\t      | lvalue->symtree->n.sym->attr.proc_pointer;\n+  pointer = lvalue->symtree->n.sym->attr.pointer;\n+  proc_pointer = lvalue->symtree->n.sym->attr.proc_pointer;\n \n   for (ref = lvalue->ref; ref; ref = ref->next)\n     {\n       if (pointer)\n \tcheck_intent_in = 0;\n \n       if (ref->type == REF_COMPONENT)\n-\tpointer = ref->u.c.component->attr.pointer;\n+\t{\n+\t  pointer = ref->u.c.component->attr.pointer;\n+\t  proc_pointer = ref->u.c.component->attr.proc_pointer;\n+\t}\n \n       if (ref->type == REF_ARRAY && ref->next == NULL)\n \t{\n@@ -3107,7 +3113,7 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n       return FAILURE;\n     }\n \n-  if (!pointer)\n+  if (!pointer && !proc_pointer)\n     {\n       gfc_error (\"Pointer assignment to non-POINTER at %L\", &lvalue->where);\n       return FAILURE;\n@@ -3129,11 +3135,12 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n     return SUCCESS;\n \n   /* Checks on rvalue for procedure pointer assignments.  */\n-  if (lvalue->symtree->n.sym->attr.proc_pointer)\n+  if (proc_pointer)\n     {\n       attr = gfc_expr_attr (rvalue);\n       if (!((rvalue->expr_type == EXPR_NULL)\n \t    || (rvalue->expr_type == EXPR_FUNCTION && attr.proc_pointer)\n+\t    || (rvalue->expr_type == EXPR_VARIABLE && attr.proc_pointer)\n \t    || (rvalue->expr_type == EXPR_VARIABLE\n \t\t&& attr.flavor == FL_PROCEDURE)))\n \t{\n@@ -3164,6 +3171,9 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n \t\t\t      rvalue->symtree->name, &rvalue->where) == FAILURE)\n \t    return FAILURE;\n \t}\n+      /* TODO: Enable interface check for PPCs.  */\n+      if (is_proc_ptr_comp (rvalue, NULL))\n+\treturn SUCCESS;\n       if (rvalue->expr_type == EXPR_VARIABLE\n \t  && !gfc_compare_interfaces (lvalue->symtree->n.sym,\n \t\t\t\t      rvalue->symtree->n.sym, 0))\n@@ -3497,6 +3507,34 @@ gfc_expr_set_symbols_referenced (gfc_expr *expr)\n }\n \n \n+/* Determine if an expression is a procedure pointer component. If yes, the\n+   argument 'comp' will point to the component (provided that 'comp' was\n+   provided).  */\n+\n+bool\n+is_proc_ptr_comp (gfc_expr *expr, gfc_component **comp)\n+{\n+  gfc_ref *ref;\n+  bool ppc = false;\n+\n+  if (!expr || !expr->ref)\n+    return false;\n+\n+  ref = expr->ref;\n+  while (ref->next)\n+    ref = ref->next;\n+\n+  if (ref->type == REF_COMPONENT)\n+    {\n+      ppc = ref->u.c.component->attr.proc_pointer;\n+      if (ppc && comp)\n+\t*comp = ref->u.c.component;\n+    }\n+\n+  return ppc;\n+}\n+\n+\n /* Walk an expression tree and check each variable encountered for being typed.\n    If strict is not set, a top-level variable is tolerated untyped in -std=gnu\n    mode as is a basic arithmetic expression using those; this is for things in"}, {"sha": "afd3edbf292aa26dde5024165be09f709569b640", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/713485cc676555c25f30c477f8b147bf98061c52/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/713485cc676555c25f30c477f8b147bf98061c52/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=713485cc676555c25f30c477f8b147bf98061c52", "patch": "@@ -151,7 +151,7 @@ bt;\n /* Expression node types.  */\n typedef enum\n { EXPR_OP = 1, EXPR_FUNCTION, EXPR_CONSTANT, EXPR_VARIABLE,\n-  EXPR_SUBSTRING, EXPR_STRUCTURE, EXPR_ARRAY, EXPR_NULL, EXPR_COMPCALL\n+  EXPR_SUBSTRING, EXPR_STRUCTURE, EXPR_ARRAY, EXPR_NULL, EXPR_COMPCALL, EXPR_PPC\n }\n expr_t;\n \n@@ -698,9 +698,11 @@ typedef struct\n   unsigned cray_pointer:1, cray_pointee:1;\n \n   /* The symbol is a derived type with allocatable components, pointer \n-     components or private components, possibly nested.  zero_comp\n-     is true if the derived type has no component at all.  */\n-  unsigned alloc_comp:1, pointer_comp:1, private_comp:1, zero_comp:1;\n+     components or private components, procedure pointer components,\n+     possibly nested.  zero_comp is true if the derived type has no\n+     component at all.  */\n+  unsigned alloc_comp:1, pointer_comp:1, proc_pointer_comp:1,\n+\t   private_comp:1, zero_comp:1;\n \n   /* The namespace where the VOLATILE attribute has been set.  */\n   struct gfc_namespace *volatile_ns;\n@@ -851,6 +853,8 @@ typedef struct gfc_component\n   locus loc;\n   struct gfc_expr *initializer;\n   struct gfc_component *next;\n+\n+  struct gfc_formal_arglist *formal;\n }\n gfc_component;\n \n@@ -1883,7 +1887,7 @@ typedef enum\n   EXEC_GOTO, EXEC_CALL, EXEC_COMPCALL, EXEC_ASSIGN_CALL, EXEC_RETURN,\n   EXEC_ENTRY, EXEC_PAUSE, EXEC_STOP, EXEC_CONTINUE, EXEC_INIT_ASSIGN,\n   EXEC_IF, EXEC_ARITHMETIC_IF, EXEC_DO, EXEC_DO_WHILE, EXEC_SELECT,\n-  EXEC_FORALL, EXEC_WHERE, EXEC_CYCLE, EXEC_EXIT,\n+  EXEC_FORALL, EXEC_WHERE, EXEC_CYCLE, EXEC_EXIT, EXEC_CALL_PPC,\n   EXEC_ALLOCATE, EXEC_DEALLOCATE,\n   EXEC_OPEN, EXEC_CLOSE, EXEC_WAIT,\n   EXEC_READ, EXEC_WRITE, EXEC_IOLENGTH, EXEC_TRANSFER, EXEC_DT_END,\n@@ -2265,7 +2269,7 @@ void gfc_set_implicit_none (void);\n void gfc_check_function_type (gfc_namespace *);\n bool gfc_is_intrinsic_typename (const char *);\n \n-gfc_typespec *gfc_get_default_type (gfc_symbol *, gfc_namespace *);\n+gfc_typespec *gfc_get_default_type (const char *, gfc_namespace *);\n gfc_try gfc_set_default_type (gfc_symbol *, int, gfc_namespace *);\n \n void gfc_set_sym_referenced (gfc_symbol *);\n@@ -2484,6 +2488,8 @@ void gfc_expr_set_symbols_referenced (gfc_expr *);\n gfc_try gfc_expr_check_typed (gfc_expr*, gfc_namespace*, bool);\n void gfc_expr_replace_symbols (gfc_expr *, gfc_symbol *);\n \n+bool is_proc_ptr_comp (gfc_expr *, gfc_component **);\n+\n /* st.c */\n extern gfc_code new_st;\n \n@@ -2592,7 +2598,7 @@ void gfc_free_use_stmts (gfc_use_list *);\n symbol_attribute gfc_variable_attr (gfc_expr *, gfc_typespec *);\n symbol_attribute gfc_expr_attr (gfc_expr *);\n match gfc_match_rvalue (gfc_expr **);\n-match gfc_match_varspec (gfc_expr*, int, bool);\n+match gfc_match_varspec (gfc_expr*, int, bool, bool);\n int gfc_check_digit (char, int);\n \n /* trans.c */"}, {"sha": "3c03f959fb21d31da472a0825932f3adaae2d672", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/713485cc676555c25f30c477f8b147bf98061c52/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/713485cc676555c25f30c477f8b147bf98061c52/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=713485cc676555c25f30c477f8b147bf98061c52", "patch": "@@ -1864,7 +1864,8 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n       /* Satisfy 12.4.1.3 by ensuring that a procedure pointer actual argument\n \t is provided for a procedure pointer formal argument.  */\n       if (f->sym->attr.proc_pointer\n-\t  && !a->expr->symtree->n.sym->attr.proc_pointer)\n+\t  && !(a->expr->symtree->n.sym->attr.proc_pointer\n+\t       || is_proc_ptr_comp (a->expr, NULL)))\n \t{\n \t  if (where)\n \t    gfc_error (\"Expected a procedure pointer for argument '%s' at %L\",\n@@ -1874,7 +1875,7 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \n       /* Satisfy 12.4.1.2 by ensuring that a procedure actual argument is\n \t provided for a procedure formal argument.  */\n-      if (a->expr->ts.type != BT_PROCEDURE\n+      if (a->expr->ts.type != BT_PROCEDURE && !is_proc_ptr_comp (a->expr, NULL)\n \t  && a->expr->expr_type == EXPR_VARIABLE\n \t  && f->sym->attr.flavor == FL_PROCEDURE)\n \t{"}, {"sha": "6faedec1ce832a75e6284f5bfa5c5628712a13f7", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/713485cc676555c25f30c477f8b147bf98061c52/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/713485cc676555c25f30c477f8b147bf98061c52/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=713485cc676555c25f30c477f8b147bf98061c52", "patch": "@@ -1336,7 +1336,8 @@ gfc_match_pointer_assignment (void)\n       goto cleanup;\n     }\n \n-  if (lvalue->symtree->n.sym->attr.proc_pointer)\n+  if (lvalue->symtree->n.sym->attr.proc_pointer\n+      || is_proc_ptr_comp (lvalue, NULL))\n     gfc_matching_procptr_assignment = 1;\n \n   m = gfc_match (\" %e%t\", &rvalue);\n@@ -2629,7 +2630,7 @@ match_typebound_call (gfc_symtree* varst)\n   base->where = gfc_current_locus;\n   gfc_set_sym_referenced (varst->n.sym);\n   \n-  m = gfc_match_varspec (base, 0, true);\n+  m = gfc_match_varspec (base, 0, true, true);\n   if (m == MATCH_NO)\n     gfc_error (\"Expected component reference at %C\");\n   if (m != MATCH_YES)\n@@ -2641,13 +2642,16 @@ match_typebound_call (gfc_symtree* varst)\n       return MATCH_ERROR;\n     }\n \n-  if (base->expr_type != EXPR_COMPCALL)\n+  if (base->expr_type == EXPR_COMPCALL)\n+    new_st.op = EXEC_COMPCALL;\n+  else if (base->expr_type == EXPR_PPC)\n+    new_st.op = EXEC_CALL_PPC;\n+  else\n     {\n-      gfc_error (\"Expected type-bound procedure reference at %C\");\n+      gfc_error (\"Expected type-bound procedure or procedure pointer component \"\n+\t\t \"at %C\");\n       return MATCH_ERROR;\n     }\n-\n-  new_st.op = EXEC_COMPCALL;\n   new_st.expr = base;\n \n   return MATCH_YES;"}, {"sha": "7f4dba5dcee7863619a916da3e4bdda977d0cf51", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/713485cc676555c25f30c477f8b147bf98061c52/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/713485cc676555c25f30c477f8b147bf98061c52/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=713485cc676555c25f30c477f8b147bf98061c52", "patch": "@@ -3043,6 +3043,7 @@ mio_expr (gfc_expr **ep)\n       break;\n \n     case EXPR_COMPCALL:\n+    case EXPR_PPC:\n       gcc_unreachable ();\n       break;\n     }"}, {"sha": "59296b104fabf507439220a06a204b6ce8e386d8", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/713485cc676555c25f30c477f8b147bf98061c52/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/713485cc676555c25f30c477f8b147bf98061c52/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=713485cc676555c25f30c477f8b147bf98061c52", "patch": "@@ -1878,15 +1878,11 @@ parse_derived (void)\n \t  unexpected_eof ();\n \n \tcase ST_DATA_DECL:\n+\tcase ST_PROCEDURE:\n \t  accept_statement (st);\n \t  seen_component = 1;\n \t  break;\n \n-\tcase ST_PROCEDURE:\n-\t  gfc_error (\"PROCEDURE binding at %C must be inside CONTAINS\");\n-\t  error_flag = 1;\n-\t  break;\n-\n \tcase ST_FINAL:\n \t  gfc_error (\"FINAL declaration at %C must be inside CONTAINS\");\n \t  error_flag = 1;\n@@ -1993,6 +1989,12 @@ parse_derived (void)\n \t  || (c->ts.type == BT_DERIVED && c->ts.derived->attr.pointer_comp))\n \tsym->attr.pointer_comp = 1;\n \n+      /* Look for procedure pointer components.  */\n+      if (c->attr.proc_pointer\n+\t  || (c->ts.type == BT_DERIVED\n+\t      && c->ts.derived->attr.proc_pointer_comp))\n+\tsym->attr.proc_pointer_comp = 1;\n+\n       /* Look for private components.  */\n       if (sym->component_access == ACCESS_PRIVATE\n \t  || c->attr.access == ACCESS_PRIVATE"}, {"sha": "96fbddce92a75b685a0c9a70e3fd0ad9b098c988", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 34, "deletions": 17, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/713485cc676555c25f30c477f8b147bf98061c52/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/713485cc676555c25f30c477f8b147bf98061c52/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=713485cc676555c25f30c477f8b147bf98061c52", "patch": "@@ -1708,10 +1708,13 @@ extend_ref (gfc_expr *primary, gfc_ref *tail)\n    variable like member references or substrings.  If equiv_flag is\n    set we only match stuff that is allowed inside an EQUIVALENCE\n    statement.  sub_flag tells whether we expect a type-bound procedure found\n-   to be a subroutine as part of CALL or a FUNCTION.  */\n+   to be a subroutine as part of CALL or a FUNCTION. For procedure pointer\n+   components, 'ppc_arg' determines whether the PPC may be called (with an\n+   argument list), or whether it may just be referred to as a pointer.  */\n \n match\n-gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag)\n+gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,\n+\t\t   bool ppc_arg)\n {\n   char name[GFC_MAX_SYMBOL_LEN + 1];\n   gfc_ref *substring, *tail;\n@@ -1754,7 +1757,7 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag)\n     return MATCH_YES;\n \n   if (sym->ts.type == BT_UNKNOWN && gfc_peek_ascii_char () == '%'\n-      && gfc_get_default_type (sym, sym->ns)->type == BT_DERIVED)\n+      && gfc_get_default_type (sym->name, sym->ns)->type == BT_DERIVED)\n     gfc_set_default_type (sym, 0, sym->ns);\n \n   if (sym->ts.type != BT_DERIVED || gfc_match_char ('%') != MATCH_YES)\n@@ -1826,6 +1829,20 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag)\n \n       primary->ts = component->ts;\n \n+      if (component->attr.proc_pointer && ppc_arg\n+\t  && !gfc_matching_procptr_assignment)\n+\t{\n+\t  primary->expr_type = EXPR_PPC;\n+\t  m = gfc_match_actual_arglist (component->attr.subroutine,\n+\t\t\t\t\t&primary->value.compcall.actual);\n+\t  if (m == MATCH_ERROR)\n+\t    return MATCH_ERROR;\n+\t  if (m == MATCH_NO)\n+\t    primary->value.compcall.actual = NULL;\n+\n+          break;\n+\t}\n+\n       if (component->as != NULL)\n \t{\n \t  tail = extend_ref (primary, tail);\n@@ -1847,7 +1864,7 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag)\n   unknown = false;\n   if (primary->ts.type == BT_UNKNOWN)\n     {\n-      if (gfc_get_default_type (sym, sym->ns)->type == BT_CHARACTER)\n+      if (gfc_get_default_type (sym->name, sym->ns)->type == BT_CHARACTER)\n        {\n \t gfc_set_default_type (sym, 0, sym->ns);\n \t primary->ts = sym->ts;\n@@ -1925,7 +1942,7 @@ gfc_variable_attr (gfc_expr *expr, gfc_typespec *ts)\n   allocatable = attr.allocatable;\n \n   target = attr.target;\n-  if (pointer)\n+  if (pointer || attr.proc_pointer)\n     target = 1;\n \n   if (ts != NULL && expr->ts.type == BT_UNKNOWN)\n@@ -1971,7 +1988,7 @@ gfc_variable_attr (gfc_expr *expr, gfc_typespec *ts)\n \n \tpointer = ref->u.c.component->attr.pointer;\n \tallocatable = ref->u.c.component->attr.allocatable;\n-\tif (pointer)\n+\tif (pointer || attr.proc_pointer)\n \t  target = 1;\n \n \tbreak;\n@@ -2478,7 +2495,7 @@ gfc_match_rvalue (gfc_expr **result)\n       e->expr_type = EXPR_VARIABLE;\n       e->symtree = symtree;\n \n-      m = gfc_match_varspec (e, 0, false);\n+      m = gfc_match_varspec (e, 0, false, true);\n       break;\n \n     case FL_PARAMETER:\n@@ -2495,7 +2512,7 @@ gfc_match_rvalue (gfc_expr **result)\n \t}\n \n       e->symtree = symtree;\n-      m = gfc_match_varspec (e, 0, false);\n+      m = gfc_match_varspec (e, 0, false, true);\n \n       if (sym->ts.is_c_interop || sym->ts.is_iso_c)\n \tbreak;\n@@ -2551,7 +2568,7 @@ gfc_match_rvalue (gfc_expr **result)\n \t  e = gfc_get_expr ();\n \t  e->expr_type = EXPR_VARIABLE;\n \t  e->symtree = symtree;\n-\t  m = gfc_match_varspec (e, 0, false);\n+\t  m = gfc_match_varspec (e, 0, false, true);\n \t  break;\n \t}\n \n@@ -2578,7 +2595,7 @@ gfc_match_rvalue (gfc_expr **result)\n \t  e->symtree = symtree;\n \t  e->expr_type = EXPR_VARIABLE;\n \n-\t  m = gfc_match_varspec (e, 0, false);\n+\t  m = gfc_match_varspec (e, 0, false, true);\n \t  break;\n \t}\n \n@@ -2658,7 +2675,7 @@ gfc_match_rvalue (gfc_expr **result)\n \n       if (gfc_peek_ascii_char () == '%'\n \t  && sym->ts.type == BT_UNKNOWN\n-\t  && gfc_get_default_type (sym, sym->ns)->type == BT_DERIVED)\n+\t  && gfc_get_default_type (sym->name, sym->ns)->type == BT_DERIVED)\n \tgfc_set_default_type (sym, 0, sym->ns);\n \n       /* If the symbol has a dimension attribute, the expression is a\n@@ -2676,7 +2693,7 @@ gfc_match_rvalue (gfc_expr **result)\n \t  e = gfc_get_expr ();\n \t  e->symtree = symtree;\n \t  e->expr_type = EXPR_VARIABLE;\n-\t  m = gfc_match_varspec (e, 0, false);\n+\t  m = gfc_match_varspec (e, 0, false, true);\n \t  break;\n \t}\n \n@@ -2701,7 +2718,7 @@ gfc_match_rvalue (gfc_expr **result)\n \n \t  /*FIXME:??? gfc_match_varspec does set this for us: */\n \t  e->ts = sym->ts;\n-\t  m = gfc_match_varspec (e, 0, false);\n+\t  m = gfc_match_varspec (e, 0, false, true);\n \t  break;\n \t}\n \n@@ -2725,7 +2742,7 @@ gfc_match_rvalue (gfc_expr **result)\n \t  implicit_char = false;\n \t  if (sym->ts.type == BT_UNKNOWN)\n \t    {\n-\t      ts = gfc_get_default_type (sym,NULL);\n+\t      ts = gfc_get_default_type (sym->name, NULL);\n \t      if (ts->type == BT_CHARACTER)\n \t\timplicit_char = true;\n \t    }\n@@ -2790,7 +2807,7 @@ gfc_match_rvalue (gfc_expr **result)\n       /* If our new function returns a character, array or structure\n \t type, it might have subsequent references.  */\n \n-      m = gfc_match_varspec (e, 0, false);\n+      m = gfc_match_varspec (e, 0, false, true);\n       if (m == MATCH_NO)\n \tm = MATCH_YES;\n \n@@ -2963,7 +2980,7 @@ match_variable (gfc_expr **result, int equiv_flag, int host_flag)\n \t\n       if (gfc_peek_ascii_char () == '%'\n \t  && sym->ts.type == BT_UNKNOWN\n-\t  && gfc_get_default_type (sym, implicit_ns)->type == BT_DERIVED)\n+\t  && gfc_get_default_type (sym->name, implicit_ns)->type == BT_DERIVED)\n \tgfc_set_default_type (sym, 0, implicit_ns);\n     }\n \n@@ -2975,7 +2992,7 @@ match_variable (gfc_expr **result, int equiv_flag, int host_flag)\n   expr->where = where;\n \n   /* Now see if we have to do more.  */\n-  m = gfc_match_varspec (expr, equiv_flag, false);\n+  m = gfc_match_varspec (expr, equiv_flag, false, false);\n   if (m != MATCH_YES)\n     {\n       gfc_free_expr (expr);"}, {"sha": "34cb365a5629ddc3a1a8b4dd9771a1e1d1ea2ee8", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 154, "deletions": 8, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/713485cc676555c25f30c477f8b147bf98061c52/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/713485cc676555c25f30c477f8b147bf98061c52/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=713485cc676555c25f30c477f8b147bf98061c52", "patch": "@@ -528,14 +528,14 @@ resolve_entries (gfc_namespace *ns)\n       fas = fas ? fas : ns->entries->sym->result->as;\n       fts = &ns->entries->sym->result->ts;\n       if (fts->type == BT_UNKNOWN)\n-\tfts = gfc_get_default_type (ns->entries->sym->result, NULL);\n+\tfts = gfc_get_default_type (ns->entries->sym->result->name, NULL);\n       for (el = ns->entries->next; el; el = el->next)\n \t{\n \t  ts = &el->sym->result->ts;\n \t  as = el->sym->as;\n \t  as = as ? as : el->sym->result->as;\n \t  if (ts->type == BT_UNKNOWN)\n-\t    ts = gfc_get_default_type (el->sym->result, NULL);\n+\t    ts = gfc_get_default_type (el->sym->result->name, NULL);\n \n \t  if (! gfc_compare_types (ts, fts)\n \t      || (el->sym->result->attr.dimension\n@@ -612,7 +612,7 @@ resolve_entries (gfc_namespace *ns)\n \t\t{\n \t\t  ts = &sym->ts;\n \t\t  if (ts->type == BT_UNKNOWN)\n-\t\t    ts = gfc_get_default_type (sym, NULL);\n+\t\t    ts = gfc_get_default_type (sym->name, NULL);\n \t\t  switch (ts->type)\n \t\t    {\n \t\t    case BT_INTEGER:\n@@ -878,7 +878,8 @@ resolve_structure_cons (gfc_expr *expr)\n \t}\n \n       if (cons->expr->expr_type == EXPR_NULL\n-\t    && !(comp->attr.pointer || comp->attr.allocatable))\n+\t  && !(comp->attr.pointer || comp->attr.allocatable\n+\t       || comp->attr.proc_pointer))\n \t{\n \t  t = FAILURE;\n \t  gfc_error (\"The NULL in the derived type constructor at %L is \"\n@@ -1215,6 +1216,7 @@ resolve_actual_arglist (gfc_actual_arglist *arg, procedure_type ptype,\n   gfc_symtree *parent_st;\n   gfc_expr *e;\n   int save_need_full_assumed_size;\n+  gfc_component *comp;\n \t\n   for (; arg; arg = arg->next)\n     {\n@@ -1234,6 +1236,13 @@ resolve_actual_arglist (gfc_actual_arglist *arg, procedure_type ptype,\n \t  continue;\n \t}\n \n+      if (is_proc_ptr_comp (e, &comp))\n+\t{\n+\t  e->ts = comp->ts;\n+\t  e->expr_type = EXPR_VARIABLE;\n+\t  goto argument_list;\n+\t}\n+\n       if (e->expr_type == EXPR_VARIABLE\n \t    && e->symtree->n.sym->attr.generic\n \t    && no_formal_args\n@@ -1906,7 +1915,7 @@ resolve_unknown_f (gfc_expr *expr)\n     expr->ts = sym->ts;\n   else\n     {\n-      ts = gfc_get_default_type (sym, sym->ns);\n+      ts = gfc_get_default_type (sym->name, sym->ns);\n \n       if (ts->type == BT_UNKNOWN)\n \t{\n@@ -4804,6 +4813,61 @@ resolve_compcall (gfc_expr* e)\n }\n \n \n+/* Resolve a CALL to a Procedure Pointer Component (Subroutine).  */\n+\n+static gfc_try\n+resolve_ppc_call (gfc_code* c)\n+{\n+  gfc_component *comp;\n+  gcc_assert (is_proc_ptr_comp (c->expr, &comp));\n+\n+  c->resolved_sym = c->expr->symtree->n.sym;\n+  c->expr->expr_type = EXPR_VARIABLE;\n+  c->ext.actual = c->expr->value.compcall.actual;\n+\n+  if (!comp->attr.subroutine)\n+    gfc_add_subroutine (&comp->attr, comp->name, &c->expr->where);\n+\n+  if (resolve_actual_arglist (c->ext.actual, comp->attr.proc,\n+\t\t\t      comp->formal == NULL) == FAILURE)\n+    return FAILURE;\n+\n+  /* TODO: Check actual arguments.\n+     gfc_procedure_use (stree->n.sym, &c->expr->value.compcall.actual,\n+\t\t\t&c->expr->where);*/\n+\n+  return SUCCESS;\n+}\n+\n+\n+/* Resolve a Function Call to a Procedure Pointer Component (Function).  */\n+\n+static gfc_try\n+resolve_expr_ppc (gfc_expr* e)\n+{\n+  gfc_component *comp;\n+  gcc_assert (is_proc_ptr_comp (e, &comp));\n+\n+  /* Convert to EXPR_FUNCTION.  */\n+  e->expr_type = EXPR_FUNCTION;\n+  e->value.function.isym = NULL;\n+  e->value.function.actual = e->value.compcall.actual;\n+  e->ts = comp->ts;\n+\n+  if (!comp->attr.function)\n+    gfc_add_function (&comp->attr, comp->name, &e->where);\n+\n+  if (resolve_actual_arglist (e->value.function.actual, comp->attr.proc,\n+\t\t\t      comp->formal == NULL) == FAILURE)\n+    return FAILURE;\n+\n+  /* TODO: Check actual arguments.\n+     gfc_procedure_use (stree->n.sym, &e->value.compcall.actual, &e->where);  */\n+\n+  return SUCCESS;\n+}\n+\n+\n /* Resolve an expression.  That is, make sure that types of operands agree\n    with their operators, intrinsic operators are converted to function calls\n    for overloaded types and unresolved function references are resolved.  */\n@@ -4853,6 +4917,10 @@ gfc_resolve_expr (gfc_expr *e)\n       t = SUCCESS;\n       break;\n \n+    case EXPR_PPC:\n+      t = resolve_expr_ppc (e);\n+      break;\n+\n     case EXPR_ARRAY:\n       t = FAILURE;\n       if (resolve_ref (e) == FAILURE)\n@@ -6819,7 +6887,7 @@ resolve_code (gfc_code *code, gfc_namespace *ns)\n \t}\n \n       t = SUCCESS;\n-      if (code->op != EXEC_COMPCALL)\n+      if (code->op != EXEC_COMPCALL && code->op != EXEC_CALL_PPC)\n \tt = gfc_resolve_expr (code->expr);\n       forall_flag = forall_save;\n \n@@ -6931,6 +6999,10 @@ resolve_code (gfc_code *code, gfc_namespace *ns)\n \t  resolve_typebound_call (code);\n \t  break;\n \n+\tcase EXEC_CALL_PPC:\n+          resolve_ppc_call (code);\n+\t  break;\n+\n \tcase EXEC_SELECT:\n \t  /* Select is complicated. Also, a SELECT construct could be\n \t     a transformed computed GOTO.  */\n@@ -8906,6 +8978,78 @@ resolve_fl_derived (gfc_symbol *sym)\n \n   for (c = sym->components; c != NULL; c = c->next)\n     {\n+      if (c->attr.proc_pointer && c->ts.interface)\n+\t{\n+\t  if (c->ts.interface->attr.procedure)\n+\t    gfc_error (\"Interface '%s', used by procedure pointer component \"\n+\t\t       \"'%s' at %L, is declared in a later PROCEDURE statement\",\n+\t\t       c->ts.interface->name, c->name, &c->loc);\n+\n+\t  /* Get the attributes from the interface (now resolved).  */\n+\t  if (c->ts.interface->attr.if_source\n+\t      || c->ts.interface->attr.intrinsic)\n+\t    {\n+\t      gfc_symbol *ifc = c->ts.interface;\n+\n+\t      if (ifc->attr.intrinsic)\n+\t\tresolve_intrinsic (ifc, &ifc->declared_at);\n+\n+\t      if (ifc->result)\n+\t\tc->ts = ifc->result->ts;\n+\t      else   \n+\t\tc->ts = ifc->ts;\n+\t      c->ts.interface = ifc;\n+\t      c->attr.function = ifc->attr.function;\n+\t      c->attr.subroutine = ifc->attr.subroutine;\n+\t      /* TODO: gfc_copy_formal_args (c, ifc);  */\n+\n+\t      c->attr.allocatable = ifc->attr.allocatable;\n+\t      c->attr.pointer = ifc->attr.pointer;\n+\t      c->attr.pure = ifc->attr.pure;\n+\t      c->attr.elemental = ifc->attr.elemental;\n+\t      c->attr.dimension = ifc->attr.dimension;\n+\t      c->attr.recursive = ifc->attr.recursive;\n+\t      c->attr.always_explicit = ifc->attr.always_explicit;\n+\t      /* Copy array spec.  */\n+\t      c->as = gfc_copy_array_spec (ifc->as);\n+\t      /*if (c->as)\n+\t\t{\n+\t\t  int i;\n+\t\t  for (i = 0; i < c->as->rank; i++)\n+\t\t    {\n+\t\t      gfc_expr_replace_symbols (c->as->lower[i], c);\n+\t\t      gfc_expr_replace_symbols (c->as->upper[i], c);\n+\t\t    }\n+\t        }*/\n+\t      /* Copy char length.  */\n+\t      if (ifc->ts.cl)\n+\t\t{\n+\t\t  c->ts.cl = gfc_get_charlen();\n+\t          c->ts.cl->resolved = ifc->ts.cl->resolved;\n+\t\t  c->ts.cl->length = gfc_copy_expr (ifc->ts.cl->length);\n+\t\t  /*gfc_expr_replace_symbols (c->ts.cl->length, c);*/\n+\t\t  /* Add charlen to namespace.  */\n+\t\t  /*if (c->formal_ns)\n+\t\t    {\n+\t\t      c->ts.cl->next = c->formal_ns->cl_list;\n+\t\t      c->formal_ns->cl_list = c->ts.cl;\n+\t\t    }*/\n+\t\t}\n+\t    }\n+\t  else if (c->ts.interface->name[0] != '\\0')\n+\t    {\n+\t      gfc_error (\"Interface '%s' of procedure pointer component \"\n+\t\t\t \"'%s' at %L must be explicit\", c->ts.interface->name,\n+\t\t\t c->name, &c->loc);\n+\t      return FAILURE;\n+ \t    }\n+\t}\n+      else if (c->attr.proc_pointer && c->ts.type == BT_UNKNOWN)\n+\t{\n+\t  c->ts = *gfc_get_default_type (c->name, NULL);\n+\t  c->attr.implicit_type = 1;\n+\t}\n+\n       /* Check type-spec if this is not the parent-type component.  */\n       if ((!sym->attr.extension || c != sym->components)\n \t  && resolve_typespec_used (&c->ts, &c->loc, c->name) == FAILURE)\n@@ -9157,7 +9301,8 @@ resolve_fl_parameter (gfc_symbol *sym)\n      matches the implicit type, since PARAMETER statements can precede\n      IMPLICIT statements.  */\n   if (sym->attr.implicit_type\n-      && !gfc_compare_types (&sym->ts, gfc_get_default_type (sym, sym->ns)))\n+      && !gfc_compare_types (&sym->ts, gfc_get_default_type (sym->name,\n+\t\t\t\t\t\t\t     sym->ns)))\n     {\n       gfc_error (\"Implicitly typed PARAMETER '%s' at %L doesn't match a \"\n \t\t \"later IMPLICIT type\", sym->name, &sym->declared_at);\n@@ -9237,7 +9382,8 @@ resolve_symbol (gfc_symbol *sym)\n \t\t   sym->name,&sym->declared_at);\n \n       /* Get the attributes from the interface (now resolved).  */\n-      if (sym->ts.interface->attr.if_source || sym->ts.interface->attr.intrinsic)\n+      if (sym->ts.interface->attr.if_source\n+\t  || sym->ts.interface->attr.intrinsic)\n \t{\n \t  gfc_symbol *ifc = sym->ts.interface;\n "}, {"sha": "d0cdb0e868c88496d4dd8d3cb46efa225b61922b", "filename": "gcc/fortran/st.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/713485cc676555c25f30c477f8b147bf98061c52/gcc%2Ffortran%2Fst.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/713485cc676555c25f30c477f8b147bf98061c52/gcc%2Ffortran%2Fst.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fst.c?ref=713485cc676555c25f30c477f8b147bf98061c52", "patch": "@@ -110,6 +110,7 @@ gfc_free_statement (gfc_code *p)\n       break;\n \n     case EXEC_COMPCALL:\n+    case EXEC_CALL_PPC:\n     case EXEC_CALL:\n     case EXEC_ASSIGN_CALL:\n       gfc_free_actual_arglist (p->ext.actual);"}, {"sha": "2160afa14c02e88f36d9efc0a4d35f01d3bb8566", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/713485cc676555c25f30c477f8b147bf98061c52/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/713485cc676555c25f30c477f8b147bf98061c52/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=713485cc676555c25f30c477f8b147bf98061c52", "patch": "@@ -219,19 +219,19 @@ gfc_merge_new_implicit (gfc_typespec *ts)\n /* Given a symbol, return a pointer to the typespec for its default type.  */\n \n gfc_typespec *\n-gfc_get_default_type (gfc_symbol *sym, gfc_namespace *ns)\n+gfc_get_default_type (const char *name, gfc_namespace *ns)\n {\n   char letter;\n \n-  letter = sym->name[0];\n+  letter = name[0];\n \n   if (gfc_option.flag_allow_leading_underscore && letter == '_')\n     gfc_internal_error (\"Option -fallow-leading-underscore is for use only by \"\n \t\t\t\"gfortran developers, and should not be used for \"\n \t\t\t\"implicitly typed variables\");\n \n   if (letter < 'a' || letter > 'z')\n-    gfc_internal_error (\"gfc_get_default_type(): Bad symbol '%s'\",sym->name);\n+    gfc_internal_error (\"gfc_get_default_type(): Bad symbol '%s'\", name);\n \n   if (ns == NULL)\n     ns = gfc_current_ns;\n@@ -252,7 +252,7 @@ gfc_set_default_type (gfc_symbol *sym, int error_flag, gfc_namespace *ns)\n   if (sym->ts.type != BT_UNKNOWN)\n     gfc_internal_error (\"gfc_set_default_type(): symbol already has a type\");\n \n-  ts = gfc_get_default_type (sym, ns);\n+  ts = gfc_get_default_type (sym->name, ns);\n \n   if (ts->type == BT_UNKNOWN)\n     {\n@@ -1779,6 +1779,7 @@ gfc_add_component (gfc_symbol *sym, const char *name,\n \n   p->name = gfc_get_string (name);\n   p->loc = gfc_current_locus;\n+  p->ts.type = BT_UNKNOWN;\n \n   *component = p;\n   return SUCCESS;\n@@ -4494,3 +4495,4 @@ gfc_get_tbp_symtree (gfc_symtree **root, const char *name)\n \n   return result;\n }\n+"}, {"sha": "280a1922a8b5935ac2e365698d5fb7a12e387818", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 45, "deletions": 17, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/713485cc676555c25f30c477f8b147bf98061c52/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/713485cc676555c25f30c477f8b147bf98061c52/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=713485cc676555c25f30c477f8b147bf98061c52", "patch": "@@ -476,7 +476,8 @@ gfc_conv_component_ref (gfc_se * se, gfc_ref * ref)\n       se->string_length = tmp;\n     }\n \n-  if (c->attr.pointer && c->attr.dimension == 0 && c->ts.type != BT_CHARACTER)\n+  if ((c->attr.pointer || c->attr.proc_pointer) && c->attr.dimension == 0\n+      && c->ts.type != BT_CHARACTER)\n     se->expr = build_fold_indirect_ref (se->expr);\n }\n \n@@ -1487,11 +1488,13 @@ gfc_build_compare_string (tree len1, tree str1, tree len2, tree str2, int kind)\n }\n \n static void\n-gfc_conv_function_val (gfc_se * se, gfc_symbol * sym)\n+conv_function_val (gfc_se * se, gfc_symbol * sym, gfc_expr * expr)\n {\n   tree tmp;\n \n-  if (sym->attr.dummy)\n+  if (is_proc_ptr_comp (expr, NULL))\n+    tmp = gfc_get_proc_ptr_comp (se, expr);\n+  else if (sym->attr.dummy)\n     {\n       tmp = gfc_get_symbol_decl (sym);\n       if (sym->attr.proc_pointer)\n@@ -1527,7 +1530,7 @@ gfc_conv_function_val (gfc_se * se, gfc_symbol * sym)\n \n \n /* Translate the call for an elemental subroutine call used in an operator\n-   assignment.  This is a simplified version of gfc_conv_function_call.  */\n+   assignment.  This is a simplified version of gfc_conv_procedure_call.  */\n \n tree\n gfc_conv_operator_assign (gfc_se *lse, gfc_se *rse, gfc_symbol *sym)\n@@ -1556,7 +1559,7 @@ gfc_conv_operator_assign (gfc_se *lse, gfc_se *rse, gfc_symbol *sym)\n \n   /* Build the function call.  */\n   gfc_init_se (&se, NULL);\n-  gfc_conv_function_val (&se, sym);\n+  conv_function_val (&se, sym, NULL);\n   tmp = TREE_TYPE (TREE_TYPE (TREE_TYPE (se.expr)));\n   tmp = build_call_list (tmp, se.expr, args);\n   gfc_add_expr_to_block (&block, tmp);\n@@ -2133,6 +2136,7 @@ gfc_apply_interface_mapping_to_expr (gfc_interface_mapping * mapping,\n       break;\n \n     case EXPR_COMPCALL:\n+    case EXPR_PPC:\n       gcc_unreachable ();\n       break;\n     }\n@@ -2402,11 +2406,13 @@ conv_arglist_function (gfc_se *se, gfc_expr *expr, const char *name)\n \n /* Generate code for a procedure call.  Note can return se->post != NULL.\n    If se->direct_byref is set then se->expr contains the return parameter.\n-   Return nonzero, if the call has alternate specifiers.  */\n+   Return nonzero, if the call has alternate specifiers.\n+   'expr' is only needed for procedure pointer components.  */\n \n int\n-gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n-\t\t\tgfc_actual_arglist * arg, tree append_args)\n+gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n+\t\t\t gfc_actual_arglist * arg, gfc_expr * expr,\n+\t\t\t tree append_args)\n {\n   gfc_interface_mapping mapping;\n   tree arglist;\n@@ -2496,16 +2502,20 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n \t  gfc_add_block_to_block (&se->post, &cptrse.post);\n \n \t  gfc_init_se (&fptrse, NULL);\n-\t  if (sym->intmod_sym_id == ISOCBINDING_F_POINTER)\n-\t      fptrse.want_pointer = 1;\n+\t  if (sym->intmod_sym_id == ISOCBINDING_F_POINTER\n+\t      || is_proc_ptr_comp (arg->next->expr, NULL))\n+\t    fptrse.want_pointer = 1;\n \n \t  gfc_conv_expr (&fptrse, arg->next->expr);\n \t  gfc_add_block_to_block (&se->pre, &fptrse.pre);\n \t  gfc_add_block_to_block (&se->post, &fptrse.post);\n \n-\t  tmp = arg->next->expr->symtree->n.sym->backend_decl;\n-\t  se->expr = fold_build2 (MODIFY_EXPR, TREE_TYPE (tmp), fptrse.expr,\n-\t\t\t\t  fold_convert (TREE_TYPE (tmp), cptrse.expr));\n+\t  if (is_proc_ptr_comp (arg->next->expr, NULL))\n+\t    tmp = gfc_get_ppc_type (arg->next->expr->ref->u.c.component);\n+\t  else\n+\t    tmp = TREE_TYPE (arg->next->expr->symtree->n.sym->backend_decl);\n+\t  se->expr = fold_build2 (MODIFY_EXPR, tmp, fptrse.expr,\n+\t\t\t\t  fold_convert (tmp, cptrse.expr));\n \n \t  return 0;\n \t}\n@@ -2942,7 +2952,7 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n     arglist = chainon (arglist, append_args);\n \n   /* Generate the actual call.  */\n-  gfc_conv_function_val (se, sym);\n+  conv_function_val (se, sym, expr);\n \n   /* If there are alternate return labels, function type should be\n      integer.  Can't modify the type in place though, since it can be shared\n@@ -2969,7 +2979,8 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n      something like\n         x = f()\n      where f is pointer valued, we have to dereference the result.  */\n-  if (!se->want_pointer && !byref && sym->attr.pointer)\n+  if (!se->want_pointer && !byref && sym->attr.pointer\n+      && !is_proc_ptr_comp (expr, NULL))\n     se->expr = build_fold_indirect_ref (se->expr);\n \n   /* f2c calling conventions require a scalar default real function to\n@@ -3346,6 +3357,20 @@ gfc_conv_statement_function (gfc_se * se, gfc_expr * expr)\n }\n \n \n+/* Return the backend_decl for a procedure pointer component.  */\n+\n+tree\n+gfc_get_proc_ptr_comp (gfc_se *se, gfc_expr *e)\n+{\n+  gfc_se comp_se;\n+  gfc_init_se (&comp_se, NULL);\n+  e->expr_type = EXPR_VARIABLE;\n+  gfc_conv_expr (&comp_se, e);\n+  comp_se.expr = build_fold_addr_expr (comp_se.expr);\n+  return gfc_evaluate_now (comp_se.expr, &se->pre);  \n+}\n+\n+\n /* Translate a function expression.  */\n \n static void\n@@ -3372,7 +3397,9 @@ gfc_conv_function_expr (gfc_se * se, gfc_expr * expr)\n   sym = expr->value.function.esym;\n   if (!sym)\n     sym = expr->symtree->n.sym;\n-  gfc_conv_function_call (se, sym, expr->value.function.actual, NULL_TREE);\n+\n+  gfc_conv_procedure_call (se, sym, expr->value.function.actual, expr,\n+\t\t\t  NULL_TREE);\n }\n \n \n@@ -3794,7 +3821,8 @@ gfc_conv_structure (gfc_se * se, gfc_expr * expr, int init)\n         continue;\n \n       val = gfc_conv_initializer (c->expr, &cm->ts,\n-\t  TREE_TYPE (cm->backend_decl), cm->attr.dimension, cm->attr.pointer);\n+\t  TREE_TYPE (cm->backend_decl), cm->attr.dimension,\n+\t  cm->attr.pointer || cm->attr.proc_pointer);\n \n       /* Append it to the constructor list.  */\n       CONSTRUCTOR_APPEND_ELT (v, cm->backend_decl, val);"}, {"sha": "d00a35b5eb841f69b5a311dfed8bf1bd8b8ab2d6", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/713485cc676555c25f30c477f8b147bf98061c52/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/713485cc676555c25f30c477f8b147bf98061c52/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=713485cc676555c25f30c477f8b147bf98061c52", "patch": "@@ -1702,7 +1702,8 @@ gfc_conv_intrinsic_funcall (gfc_se * se, gfc_expr * expr)\n \t}\n     }\n \n-  gfc_conv_function_call (se, sym, expr->value.function.actual, append_args);\n+  gfc_conv_procedure_call (se, sym, expr->value.function.actual, expr,\n+\t\t\t  append_args);\n   gfc_free (sym);\n }\n \n@@ -2877,7 +2878,8 @@ conv_generic_with_optional_char_arg (gfc_se* se, gfc_expr* expr,\n \n   /* Build the call itself.  */\n   sym = gfc_get_symbol_for_expr (expr);\n-  gfc_conv_function_call (se, sym, expr->value.function.actual, append_args);\n+  gfc_conv_procedure_call (se, sym, expr->value.function.actual, expr,\n+\t\t\t  append_args);\n   gfc_free (sym);\n }\n "}, {"sha": "d695759477a4ffc1ab3bcdf5f3ca1868fb0845c8", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/713485cc676555c25f30c477f8b147bf98061c52/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/713485cc676555c25f30c477f8b147bf98061c52/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=713485cc676555c25f30c477f8b147bf98061c52", "patch": "@@ -356,8 +356,8 @@ gfc_trans_call (gfc_code * code, bool dependency_check)\n \n       /* Translate the call.  */\n       has_alternate_specifier\n-\t= gfc_conv_function_call (&se, code->resolved_sym, code->ext.actual,\n-\t\t\t\t  NULL_TREE);\n+\t= gfc_conv_procedure_call (&se, code->resolved_sym, code->ext.actual,\n+\t\t\t\t  code->expr, NULL_TREE);\n \n       /* A subroutine without side-effect, by definition, does nothing!  */\n       TREE_SIDE_EFFECTS (se.expr) = 1;\n@@ -430,8 +430,8 @@ gfc_trans_call (gfc_code * code, bool dependency_check)\n       gfc_init_block (&block);\n \n       /* Add the subroutine call to the block.  */\n-      gfc_conv_function_call (&loopse, code->resolved_sym, code->ext.actual,\n-\t\t\t      NULL_TREE);\n+      gfc_conv_procedure_call (&loopse, code->resolved_sym, code->ext.actual,\n+\t\t\t      code->expr, NULL_TREE);\n       gfc_add_expr_to_block (&loopse.pre, loopse.expr);\n \n       gfc_add_block_to_block (&block, &loopse.pre);"}, {"sha": "ff8a8384a4c09561383e5991fd7579526b4060c8", "filename": "gcc/fortran/trans-stmt.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/713485cc676555c25f30c477f8b147bf98061c52/gcc%2Ffortran%2Ftrans-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/713485cc676555c25f30c477f8b147bf98061c52/gcc%2Ffortran%2Ftrans-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.h?ref=713485cc676555c25f30c477f8b147bf98061c52", "patch": "@@ -29,6 +29,7 @@ tree gfc_trans_code (gfc_code *);\n tree gfc_trans_assign (gfc_code *);\n tree gfc_trans_pointer_assign (gfc_code *);\n tree gfc_trans_init_assign (gfc_code *);\n+tree gfc_get_proc_ptr_comp (gfc_se *, gfc_expr *);\n \n /* trans-stmt.c */\n tree gfc_trans_cycle (gfc_code *);"}, {"sha": "694d0e289802efc9c02ee8ee5cec9629c8adc228", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/713485cc676555c25f30c477f8b147bf98061c52/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/713485cc676555c25f30c477f8b147bf98061c52/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=713485cc676555c25f30c477f8b147bf98061c52", "patch": "@@ -1777,6 +1777,21 @@ copy_dt_decls_ifequal (gfc_symbol *from, gfc_symbol *to)\n }\n \n \n+/* Build a tree node for a procedure pointer component.  */\n+\n+tree\n+gfc_get_ppc_type (gfc_component* c)\n+{\n+  tree t;\n+  if (c->attr.function)\n+    t = gfc_typenode_for_spec (&c->ts);\n+  else\n+    t = void_type_node;\n+  /* TODO: Build argument list.  */\n+  return build_pointer_type (build_function_type (t, NULL_TREE));\n+}\n+\n+\n /* Build a tree node for a derived type.  If there are equal\n    derived types, with different local names, these are built\n    at the same time.  If an equal derived type has been built\n@@ -1823,16 +1838,9 @@ gfc_get_derived_type (gfc_symbol * derived)\n   /* derived->backend_decl != 0 means we saw it before, but its\n      components' backend_decl may have not been built.  */\n   if (derived->backend_decl)\n-    {\n-      /* Its components' backend_decl have been built.  */\n-      if (TYPE_FIELDS (derived->backend_decl))\n-        return derived->backend_decl;\n-      else\n-        typenode = derived->backend_decl;\n-    }\n+    return derived->backend_decl;\n   else\n     {\n-\n       /* We see this derived type first time, so build the type node.  */\n       typenode = make_node (RECORD_TYPE);\n       TYPE_NAME (typenode) = get_identifier (derived->name);\n@@ -1881,6 +1889,8 @@ gfc_get_derived_type (gfc_symbol * derived)\n     {\n       if (c->ts.type == BT_DERIVED)\n         field_type = c->ts.derived->backend_decl;\n+      else if (c->attr.proc_pointer)\n+\tfield_type = gfc_get_ppc_type (c);\n       else\n \t{\n \t  if (c->ts.type == BT_CHARACTER)"}, {"sha": "c3e51a11c8e1102c223302d12b21a2b3fcbd3466", "filename": "gcc/fortran/trans-types.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/713485cc676555c25f30c477f8b147bf98061c52/gcc%2Ffortran%2Ftrans-types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/713485cc676555c25f30c477f8b147bf98061c52/gcc%2Ffortran%2Ftrans-types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.h?ref=713485cc676555c25f30c477f8b147bf98061c52", "patch": "@@ -89,4 +89,6 @@ int gfc_is_nodesc_array (gfc_symbol *);\n /* Return the DTYPE for an array.  */\n tree gfc_get_dtype (tree);\n \n+tree gfc_get_ppc_type (gfc_component *);\n+\n #endif"}, {"sha": "54d40d7c3e3abc66d21a1d6dc96acaf54ec0cf29", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/713485cc676555c25f30c477f8b147bf98061c52/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/713485cc676555c25f30c477f8b147bf98061c52/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=713485cc676555c25f30c477f8b147bf98061c52", "patch": "@@ -1115,6 +1115,10 @@ gfc_trans_code (gfc_code * code)\n \t  }\n \t  break;\n \n+\tcase EXEC_CALL_PPC:\n+\t  res = gfc_trans_call (code, false);\n+\t  break;\n+\n \tcase EXEC_ASSIGN_CALL:\n \t  res = gfc_trans_call (code, true);\n \t  break;"}, {"sha": "c75f40eb6fe1258468ea7c231a2b5dfef7ffb2bd", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/713485cc676555c25f30c477f8b147bf98061c52/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/713485cc676555c25f30c477f8b147bf98061c52/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=713485cc676555c25f30c477f8b147bf98061c52", "patch": "@@ -71,7 +71,7 @@ typedef struct gfc_se\n      are NULL.  Used by intrinsic size.  */\n   unsigned data_not_needed:1;\n \n-  /* If set, gfc_conv_function_call does not put byref calls into se->pre.  */\n+  /* If set, gfc_conv_procedure_call does not put byref calls into se->pre.  */\n   unsigned no_function_call:1;\n \n   /* Scalarization parameters.  */\n@@ -313,9 +313,10 @@ int gfc_is_intrinsic_libcall (gfc_expr *);\n /* Used to call the elemental subroutines used in operator assignments.  */\n tree gfc_conv_operator_assign (gfc_se *, gfc_se *, gfc_symbol *);\n \n-/* Also used to CALL subroutines.  */\n-int gfc_conv_function_call (gfc_se *, gfc_symbol *, gfc_actual_arglist *,\n-\t\t\t    tree);\n+/* Used to call ordinary functions/subroutines\n+   and procedure pointer components.  */\n+int gfc_conv_procedure_call (gfc_se *, gfc_symbol *, gfc_actual_arglist *,\n+\t\t\t    gfc_expr *, tree);\n \n void gfc_conv_subref_array_arg (gfc_se *, gfc_expr *, int, sym_intent);\n "}, {"sha": "7ba49100a34e019924a6f8ebb1ea7b8d427a8137", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/713485cc676555c25f30c477f8b147bf98061c52/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/713485cc676555c25f30c477f8b147bf98061c52/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=713485cc676555c25f30c477f8b147bf98061c52", "patch": "@@ -1,3 +1,14 @@\n+2009-05-06  Janus Weil  <janus@gcc.gnu.org>\n+\n+\tPR fortran/39630\n+\t* gfortran.dg/proc_decl_1.f90: Modified.\n+\t* gfortran.dg/proc_ptr_comp_1.f90: New.\n+\t* gfortran.dg/proc_ptr_comp_2.f90: New.\n+\t* gfortran.dg/proc_ptr_comp_3.f90: New.\n+\t* gfortran.dg/proc_ptr_comp_4.f90: New.\n+\t* gfortran.dg/proc_ptr_comp_5.f90: New.\n+\t* gfortran.dg/proc_ptr_comp_6.f90: New.\n+\n 2009-05-06  Dodji Seketeli  <dodji@redhat.com>\n \n \tPR c++/17395"}, {"sha": "25c018301f31e341d85c7571d6d02d5aabcc8652", "filename": "gcc/testsuite/gfortran.dg/proc_decl_1.f90", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/713485cc676555c25f30c477f8b147bf98061c52/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_decl_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/713485cc676555c25f30c477f8b147bf98061c52/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_decl_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_decl_1.f90?ref=713485cc676555c25f30c477f8b147bf98061c52", "patch": "@@ -47,10 +47,6 @@ subroutine z2(a)\n   procedure(dcos) :: my1\n   procedure(amax0) :: my2  ! { dg-error \"not allowed in PROCEDURE statement\" }\n \n-  type t\n-    procedure(),pointer:: p  ! { dg-error \"not yet implemented\" }\n-  end type\n-\n   real f, x\n   f(x) = sin(x**2)\n   external oo"}, {"sha": "cbb69f1d50e7bdf5509e0333220e42655604413f", "filename": "gcc/testsuite/gfortran.dg/proc_ptr_comp_1.f90", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/713485cc676555c25f30c477f8b147bf98061c52/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/713485cc676555c25f30c477f8b147bf98061c52/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_1.f90?ref=713485cc676555c25f30c477f8b147bf98061c52", "patch": "@@ -0,0 +1,65 @@\n+! { dg-do run }\n+!\n+! PR39630: Fortran 2003: Procedure pointer components.\n+!\n+! Basic test for PPCs with SUBROUTINE interface and NOPASS.\n+!\n+! Contributed by Janus Weil <janus@gcc.gnu.org>\n+\n+  type t\n+    integer :: i\n+    procedure(sub), pointer, nopass :: ppc\n+    procedure(), pointer, nopass :: proc\n+  end type\n+\n+  type, extends(t) :: t2\n+    procedure(), pointer, nopass :: proc2\n+  end type t2\n+\n+  type(t) :: x\n+  type(t2) :: x2\n+\n+  procedure(sub),pointer :: pp\n+  integer :: sum = 0\n+\n+  x%i = 1\n+  x%ppc => sub\n+  pp => x%ppc\n+\n+  call sub(1)\n+  if (sum/=1) call abort\n+  call pp(2)\n+  if (sum/=3) call abort\n+  call x%ppc(3)\n+  if (sum/=6) call abort\n+\n+  ! calling object as argument\n+  x%proc => sub2\n+  call x%proc(x)\n+  if (x%i/=7) call abort\n+\n+  ! type extension\n+  x%proc => sub\n+  call x%proc(4)\n+  if (sum/=10) call abort\n+  x2%proc => sub\n+  call x2%proc(5)\n+  if (sum/=15) call abort\n+  x2%proc2 => sub\n+  call x2%proc2(6)\n+  if (sum/=21) call abort\n+\n+contains\n+\n+  subroutine sub(y)\n+    integer, intent(in) :: y\n+    sum = sum + y\n+  end subroutine\n+\n+  subroutine sub2(arg)\n+    type(t),intent(inout) :: arg\n+    arg%i = arg%i + sum\n+  end subroutine\n+\n+end\n+"}, {"sha": "886e8bf70fe76f207086ce2034e86e8c15db1c15", "filename": "gcc/testsuite/gfortran.dg/proc_ptr_comp_2.f90", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/713485cc676555c25f30c477f8b147bf98061c52/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/713485cc676555c25f30c477f8b147bf98061c52/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_2.f90?ref=713485cc676555c25f30c477f8b147bf98061c52", "patch": "@@ -0,0 +1,64 @@\n+! { dg-do run }\n+!\n+! PR39630: Fortran 2003: Procedure pointer components.\n+!\n+! Basic test for PPCs with FUNCTION interface and NOPASS.\n+!\n+! Contributed by Janus Weil <janus@gcc.gnu.org>\n+\n+  type t\r\n+    procedure(fcn), pointer, nopass :: ppc\r\n+    procedure(abstr), pointer, nopass :: ppc1\n+    procedure(), nopass, pointer:: iptr3\r\n+    integer :: i\r\n+  end type\r\n+\r\n+  abstract interface\r\n+    integer function abstr(x)\r\n+      integer, intent(in) :: x\r\n+    end function\r\n+  end interface\r\n+\r\n+  type(t) :: obj\r\n+  procedure(fcn), pointer :: f\r\n+  integer :: base\n+\n+  intrinsic :: iabs\r\n+\r\n+! Check with interface from contained function\r\n+  obj%ppc => fcn\r\n+  base=obj%ppc(2)\n+  if (base/=4) call abort\r\n+  call foo (obj%ppc,3)\r\n+\r\n+! Check with abstract interface\r\n+  obj%ppc1 => obj%ppc\r\n+  base=obj%ppc1(4)\n+  if (base/=8) call abort\r\n+  call foo (obj%ppc1,5)\r\n+\r\n+! Check compatibility components with non-components  \r\n+  f => obj%ppc\r\n+  base=f(6)\n+  if (base/=12) call abort\r\n+  call foo (f,7)\n+\n+! Check with implicit interface\n+  obj%iptr3 => iabs\n+  base=obj%iptr3(-9)\n+  if (base/=9) call abort\r\n+\r\n+contains\r\n+\r\n+  integer function fcn(x)\r\n+    integer, intent(in) :: x\r\n+    fcn = 2 * x\r\n+  end function\r\n+\n+  subroutine foo (arg, i)\n+    procedure (fcn), pointer :: arg\n+    integer :: i\n+    if (arg(i)/=2*i) call abort\n+  end subroutine\n+\r\n+end\r"}, {"sha": "34c27f3c451f6b6915e6c162c4178c35e7958d58", "filename": "gcc/testsuite/gfortran.dg/proc_ptr_comp_3.f90", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/713485cc676555c25f30c477f8b147bf98061c52/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/713485cc676555c25f30c477f8b147bf98061c52/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_3.f90?ref=713485cc676555c25f30c477f8b147bf98061c52", "patch": "@@ -0,0 +1,46 @@\n+! { dg-do compile }\n+!\n+! PR39630: Fortran 2003: Procedure pointer components.\n+!\n+! Probing some error messages.\n+!\n+! Contributed by Janus Weil <janus@gcc.gnu.org>\n+\n+implicit none\n+\n+interface\n+ subroutine sub\n+ end subroutine\n+end interface\n+\n+external :: aaargh\n+\n+type :: t\n+  procedure(sub), pointer :: ptr1                ! { dg-error \"not yet implemented\" }\n+  procedure(real), pointer, nopass :: ptr2\n+  procedure(sub), pointer, nopass :: ptr3\n+  procedure(), pointer, nopass ptr4              ! { dg-error \"Expected '::'\" }\n+  procedure(), pointer, nopass, pointer :: ptr5  ! { dg-error \"Duplicate\" }\n+  procedure, pointer, nopass :: ptr6             ! { dg-error \"Syntax error\" }\n+  procedure(), pointer, nopass :: ptr7 => ptr2   ! { dg-error \"requires a NULL\" }\n+  procedure(), nopass :: ptr8                    ! { dg-error \"POINTER attribute is required\" }\n+  procedure(pp), pointer, nopass :: ptr9         ! { dg-error \"declared in a later PROCEDURE statement\" }\n+  procedure(aaargh), pointer, nopass :: ptr10    ! { dg-error \"must be explicit\" }\n+  real :: y\n+end type t\n+\n+procedure(sub), pointer :: pp\n+\n+type(t) :: x\n+\n+x%ptr2 => x       ! { dg-error \"Invalid procedure pointer assignment\" }\n+\n+x => x%ptr2       ! { dg-error \"Pointer assignment to non-POINTER\" }\n+\n+call x%ptr2()     ! { dg-error \"attribute conflicts with\" }\n+print *,x%ptr3()  ! { dg-error \"attribute conflicts with\" }\n+\n+call x%y          ! { dg-error \"Expected type-bound procedure or procedure pointer component\" }\n+\n+end\n+"}, {"sha": "b904a2f86aafd6a02e8d9fdf5912a14c6148320a", "filename": "gcc/testsuite/gfortran.dg/proc_ptr_comp_4.f90", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/713485cc676555c25f30c477f8b147bf98061c52/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/713485cc676555c25f30c477f8b147bf98061c52/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_4.f90?ref=713485cc676555c25f30c477f8b147bf98061c52", "patch": "@@ -0,0 +1,120 @@\n+! { dg-do compile }\n+!\n+! PR39630: Fortran 2003: Procedure pointer components.\n+!\n+! Original code by Juergen Reuter <juergen.reuter@physik.uni-freiburg.de>\n+!\n+! Adapted by Janus Weil <janus@gcc.gnu.org>\n+\n+\n+! Test for infinte recursion in trans-types.c when a PPC interface\n+! refers to the original type.\n+\n+module expressions\n+\n+  type :: eval_node_t\n+     logical, pointer :: lval => null ()\n+     type(eval_node_t), pointer :: arg1 => null ()\n+     procedure(unary_log), nopass, pointer :: op1_log  => null ()\n+  end type eval_node_t\n+\n+  abstract interface\n+     logical function unary_log (arg)\n+       import eval_node_t\n+       type(eval_node_t), intent(in) :: arg\n+     end function unary_log\n+  end interface\n+\n+contains\n+\n+  subroutine eval_node_set_op1_log (en, op)\n+    type(eval_node_t), intent(inout) :: en\n+    procedure(unary_log) :: op\n+    en%op1_log => op\n+  end subroutine eval_node_set_op1_log\n+\n+  subroutine eval_node_evaluate (en)\n+    type(eval_node_t), intent(inout) :: en\n+    en%lval = en%op1_log  (en%arg1)\n+  end subroutine\n+\n+end module\n+\n+\n+! Test for C_F_PROCPOINTER and pointers to derived types\n+\n+module process_libraries\n+\n+  implicit none\n+\n+  type :: process_library_t\n+     procedure(), nopass, pointer :: write_list\n+  end type process_library_t\n+\n+contains\n+\n+  subroutine process_library_load (prc_lib)\n+    use iso_c_binding \n+    type(process_library_t) :: prc_lib\n+    type(c_funptr) :: c_fptr\n+    call c_f_procpointer (c_fptr, prc_lib%write_list)\n+  end subroutine process_library_load\n+\n+  subroutine process_libraries_test ()\n+    type(process_library_t), pointer :: prc_lib\n+    call prc_lib%write_list ()\n+  end subroutine process_libraries_test\n+\n+end module process_libraries\n+\n+\n+! Test for argument resolution\n+\n+module hard_interactions\n+\n+  implicit none\n+\n+  type :: hard_interaction_t\n+     procedure(), nopass, pointer :: new_event\n+  end type hard_interaction_t\n+\n+  interface afv\n+     module procedure afv_1\n+  end interface\n+\n+contains\n+\n+  function afv_1 () result (a)\n+    real, dimension(0:3) :: a\n+  end function\n+\n+  subroutine hard_interaction_evaluate (hi)\n+    type(hard_interaction_t) :: hi\n+    call hi%new_event (afv ())\n+  end subroutine\n+\n+end module hard_interactions\n+\n+\n+! Test for derived types with PPC working properly as function result.\n+\n+  implicit none\n+\n+  type :: var_entry_t\n+    procedure(), nopass, pointer :: obs1_int\n+  end type var_entry_t\n+  \n+  type(var_entry_t), pointer :: var\n+\n+  var => var_list_get_var_ptr ()\n+\n+contains\n+\n+  function var_list_get_var_ptr ()\n+    type(var_entry_t), pointer :: var_list_get_var_ptr\n+  end function var_list_get_var_ptr\n+\n+end\n+\n+! { dg-final { cleanup-modules \"expressions process_libraries hard_interactions\" } }\n+"}, {"sha": "216cb4e9b3a4f91a215c43b95a510dedf052a6e3", "filename": "gcc/testsuite/gfortran.dg/proc_ptr_comp_5.f90", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/713485cc676555c25f30c477f8b147bf98061c52/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/713485cc676555c25f30c477f8b147bf98061c52/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_5.f90?ref=713485cc676555c25f30c477f8b147bf98061c52", "patch": "@@ -0,0 +1,47 @@\n+! { dg-do run }\n+!\n+! PR39630: Fortran 2003: Procedure pointer components.\n+!\n+! Nested types / double component references.\n+!\n+! Contributed by Janus Weil <janus@gcc.gnu.org>\n+\n+abstract interface\n+  subroutine as\n+  end subroutine\n+  integer function af()\n+  end function\n+end interface\n+\n+type :: t1\n+  procedure(as), pointer, nopass :: s\n+  procedure(af), pointer, nopass :: f\n+end type\n+\n+type :: t2\n+  type(t1) :: c\n+end type\n+\n+type(t2) :: x\n+integer :: j = 0\n+\n+x%c%s => is\n+call x%c%s\n+if (j/=5) call abort\n+\n+x%c%f => if\n+j=x%c%f()\n+if (j/=42) call abort\n+\n+contains\n+\n+subroutine is\n+  j = 5\n+end subroutine\n+\n+integer function if()\n+  if = 42\n+end function\n+\n+end\n+"}, {"sha": "f0dcf4ccf01dedab60fa0ce05f9fdf680ab750c3", "filename": "gcc/testsuite/gfortran.dg/proc_ptr_comp_6.f90", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/713485cc676555c25f30c477f8b147bf98061c52/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/713485cc676555c25f30c477f8b147bf98061c52/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_6.f90?ref=713485cc676555c25f30c477f8b147bf98061c52", "patch": "@@ -0,0 +1,64 @@\n+! { dg-do run }\n+!\n+! PR39630: Fortran 2003: Procedure pointer components.\n+!\n+! test case taken from:\n+! http://groups.google.com/group/comp.lang.fortran/browse_thread/thread/4a827e8ced6efb0f/884b9eca6d7e6742?#884b9eca6d7e6742\n+! http://fortranwiki.org/fortran/show/proc_component_example\n+\n+module proc_component_example\n+\n+  type t\n+    real :: a\n+    procedure(print_int), pointer, &\n+                          nopass :: proc\n+  end type t\n+\n+  abstract interface\n+    subroutine print_int (arg, lun)\n+      import\n+      type(t), intent(in) :: arg\n+      integer, intent(in) :: lun\n+    end subroutine print_int\n+  end interface\n+\n+  integer :: calls = 0\n+\n+contains\n+\n+  subroutine print_me (arg, lun)\n+    type(t), intent(in) :: arg\n+    integer, intent(in) :: lun\n+    write (lun,*) arg%a\n+    calls = calls + 1\n+  end subroutine print_me\n+\n+  subroutine print_my_square (arg, lun)\n+    type(t), intent(in) :: arg\n+    integer, intent(in) :: lun\n+    write (lun,*) arg%a**2\n+    calls = calls + 1\n+  end subroutine print_my_square\n+\n+end module proc_component_example\n+\n+program main\n+\n+    use proc_component_example\n+    use iso_fortran_env, only : output_unit\n+\n+    type(t) :: x\n+\n+    x%a = 2.71828\n+\n+    x%proc => print_me\n+    call x%proc(x, output_unit)\n+    x%proc => print_my_square\n+    call x%proc(x, output_unit)\n+\n+    if (calls/=2) call abort\n+\n+end program main \n+\n+! { dg-final { cleanup-modules \"proc_component_example\" } }\n+"}]}