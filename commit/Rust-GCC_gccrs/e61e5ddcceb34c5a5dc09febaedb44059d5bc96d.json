{"sha": "e61e5ddcceb34c5a5dc09febaedb44059d5bc96d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTYxZTVkZGNjZWIzNGM1YTVkYzA5ZmViYWVkYjQ0MDU5ZDViYzk2ZA==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2006-11-10T04:26:31Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2006-11-10T04:26:31Z"}, "message": "builtins.c (do_mpfr_arg3): New.\n\n\t* builtins.c (do_mpfr_arg3): New.\n\t(fold_builtin_1): Handle builtins fma, fmin and fmax.\n\ntestsuite:\n\t* gcc.dg/torture/builtin-math-2.c: Test builtin fma.\n\t* gcc.dg/torture/builtin-math-3.c (CKSGN_F, CKSGN, CKSGN_L):\n\tNew macros. Use them in exact tests.\n\t(TESTIT3): New macro.\n\tAdd tests for fmin, fmax and fma.\n\nFrom-SVN: r118648", "tree": {"sha": "d2a42a3fc751ccbee76f918df6150e8a533f1ba2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d2a42a3fc751ccbee76f918df6150e8a533f1ba2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e61e5ddcceb34c5a5dc09febaedb44059d5bc96d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e61e5ddcceb34c5a5dc09febaedb44059d5bc96d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e61e5ddcceb34c5a5dc09febaedb44059d5bc96d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e61e5ddcceb34c5a5dc09febaedb44059d5bc96d/comments", "author": null, "committer": null, "parents": [{"sha": "f5bf550c9dc6510b4f89262d767a37c2966786ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5bf550c9dc6510b4f89262d767a37c2966786ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5bf550c9dc6510b4f89262d767a37c2966786ed"}], "stats": {"total": 197, "additions": 191, "deletions": 6}, "files": [{"sha": "9c2b5891a98308ee28735b07e280d75c0bcfb69c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e61e5ddcceb34c5a5dc09febaedb44059d5bc96d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e61e5ddcceb34c5a5dc09febaedb44059d5bc96d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e61e5ddcceb34c5a5dc09febaedb44059d5bc96d", "patch": "@@ -1,3 +1,8 @@\n+2006-11-09  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* builtins.c (do_mpfr_arg3): New.\n+\t(fold_builtin_1): Handle builtins fma, fmin and fmax.\n+\n 2006-11-09  Eric Christopher  <echristo@apple.com>\n \n \tPR bootstrap/26892"}, {"sha": "9d27243bd22e6f82870e85f927468db9c08dd45e", "filename": "gcc/builtins.c", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e61e5ddcceb34c5a5dc09febaedb44059d5bc96d/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e61e5ddcceb34c5a5dc09febaedb44059d5bc96d/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=e61e5ddcceb34c5a5dc09febaedb44059d5bc96d", "patch": "@@ -207,6 +207,8 @@ static tree do_mpfr_arg1 (tree, tree, int (*)(mpfr_ptr, mpfr_srcptr, mp_rnd_t),\n \t\t\t  const REAL_VALUE_TYPE *, const REAL_VALUE_TYPE *, bool);\n static tree do_mpfr_arg2 (tree, tree, tree,\n \t\t\t  int (*)(mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mp_rnd_t));\n+static tree do_mpfr_arg3 (tree, tree, tree, tree,\n+\t\t\t  int (*)(mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_srcptr, mp_rnd_t));\n static tree do_mpfr_sincos (tree, tree, tree);\n \n /* Return true if NODE should be considered for inline expansion regardless\n@@ -9256,6 +9258,28 @@ fold_builtin_1 (tree fndecl, tree arglist, bool ignore)\n \t\t\t     type, mpfr_atan2);\n     break;\n \n+    CASE_FLT_FN (BUILT_IN_FMA):\n+      if (validate_arglist (arglist, REAL_TYPE, REAL_TYPE, REAL_TYPE, VOID_TYPE))\n+\treturn do_mpfr_arg3 (TREE_VALUE (arglist),\n+\t\t\t     TREE_VALUE (TREE_CHAIN (arglist)),\n+\t\t\t     TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist))),\n+\t\t\t     type, mpfr_fma);\n+    break;\n+\n+    CASE_FLT_FN (BUILT_IN_FMIN):\n+      if (validate_arglist (arglist, REAL_TYPE, REAL_TYPE, VOID_TYPE))\n+\treturn do_mpfr_arg2 (TREE_VALUE (arglist),\n+\t\t\t     TREE_VALUE (TREE_CHAIN (arglist)),\n+\t\t\t     type, mpfr_min);\n+    break;\n+\n+    CASE_FLT_FN (BUILT_IN_FMAX):\n+      if (validate_arglist (arglist, REAL_TYPE, REAL_TYPE, VOID_TYPE))\n+\treturn do_mpfr_arg2 (TREE_VALUE (arglist),\n+\t\t\t     TREE_VALUE (TREE_CHAIN (arglist)),\n+\t\t\t     type, mpfr_max);\n+    break;\n+\n     CASE_FLT_FN (BUILT_IN_HYPOT):\n       return fold_builtin_hypot (fndecl, arglist, type);\n     \n@@ -11593,6 +11617,52 @@ do_mpfr_arg2 (tree arg1, tree arg2, tree type,\n   return result;\n }\n \n+/* If argument ARG is a REAL_CST, call the three-argument mpfr function\n+   FUNC on it and return the resulting value as a tree with type TYPE.\n+   The mpfr precision is set to the precision of TYPE.  We assume that\n+   function FUNC returns zero if the result could be calculated\n+   exactly within the requested precision.  */\n+\n+static tree\n+do_mpfr_arg3 (tree arg1, tree arg2, tree arg3, tree type,\n+\t      int (*func)(mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_srcptr, mp_rnd_t))\n+{\n+  tree result = NULL_TREE;\n+  \n+  STRIP_NOPS (arg1);\n+  STRIP_NOPS (arg2);\n+  STRIP_NOPS (arg3);\n+\n+  if (TREE_CODE (arg1) == REAL_CST && ! TREE_CONSTANT_OVERFLOW (arg1)\n+      && TREE_CODE (arg2) == REAL_CST && ! TREE_CONSTANT_OVERFLOW (arg2)\n+      && TREE_CODE (arg3) == REAL_CST && ! TREE_CONSTANT_OVERFLOW (arg3))\n+    {\n+      const REAL_VALUE_TYPE *const ra1 = &TREE_REAL_CST (arg1);\n+      const REAL_VALUE_TYPE *const ra2 = &TREE_REAL_CST (arg2);\n+      const REAL_VALUE_TYPE *const ra3 = &TREE_REAL_CST (arg3);\n+\n+      if (!real_isnan (ra1) && !real_isinf (ra1)\n+\t  && !real_isnan (ra2) && !real_isinf (ra2)\n+\t  && !real_isnan (ra3) && !real_isinf (ra3))\n+        {\n+\t  const int prec = REAL_MODE_FORMAT (TYPE_MODE (type))->p;\n+\t  int inexact;\n+\t  mpfr_t m1, m2, m3;\n+\n+\t  mpfr_inits2 (prec, m1, m2, m3, NULL);\n+\t  mpfr_from_real (m1, ra1);\n+\t  mpfr_from_real (m2, ra2);\n+\t  mpfr_from_real (m3, ra3);\n+\t  mpfr_clear_flags();\n+\t  inexact = func (m1, m1, m2, m3, GMP_RNDN);\n+\t  result = do_mpfr_ckconv (m1, type, inexact);\n+\t  mpfr_clears (m1, m2, m3, NULL);\n+\t}\n+    }\n+  \n+  return result;\n+}\n+\n /* If argument ARG is a REAL_CST, call mpfr_sin_cos() on it and set\n    the pointers *(ARG_SINP) and *(ARG_COSP) to the resulting values.\n    The type is taken from the type of ARG and is used for setting the"}, {"sha": "659aa50cac3ad530f30eed26e197fd161d90afd0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e61e5ddcceb34c5a5dc09febaedb44059d5bc96d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e61e5ddcceb34c5a5dc09febaedb44059d5bc96d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e61e5ddcceb34c5a5dc09febaedb44059d5bc96d", "patch": "@@ -1,3 +1,11 @@\n+2006-11-09  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* gcc.dg/torture/builtin-math-2.c: Test builtin fma.\n+\t* gcc.dg/torture/builtin-math-3.c (CKSGN_F, CKSGN, CKSGN_L):\n+\tNew macros. Use them in exact tests.\n+\t(TESTIT3): New macro.\n+\tAdd tests for fmin, fmax and fma.\n+\n 2006-11-09 Paul Thomas <pault@gcc.gnu.org>\n \n \tPR fortran/29431"}, {"sha": "f0dbf2e115159f86894d15b74d4d22d42eab2a54", "filename": "gcc/testsuite/gcc.dg/torture/builtin-math-2.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e61e5ddcceb34c5a5dc09febaedb44059d5bc96d/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e61e5ddcceb34c5a5dc09febaedb44059d5bc96d/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-2.c?ref=e61e5ddcceb34c5a5dc09febaedb44059d5bc96d", "patch": "@@ -133,6 +133,18 @@ void bar()\n   foo (__builtin_pow (__DBL_MAX__, -3.5));\n   fool (__builtin_powl (__LDBL_MAX__, -3.5L));\n   TESTIT2 (pow, 2.0, -0x1p50);\n+  \n+  foof (__builtin_fmaf (__FLT_MAX__, __FLT_MAX__, 0.0F));\n+  foof (__builtin_fmaf (__FLT_MAX__, 1.0F, __FLT_MAX__));\n+  foof (__builtin_fmaf (__FLT_MIN__, __FLT_MIN__, 0.0F));\n+  \n+  foo (__builtin_fma (__DBL_MAX__, __DBL_MAX__, 0.0));\n+  foo (__builtin_fma (__DBL_MAX__, 1.0, __DBL_MAX__));\n+  foo (__builtin_fma (__DBL_MIN__, __DBL_MIN__, 0.0));\n+  \n+  fool (__builtin_fmal (__LDBL_MAX__, __LDBL_MAX__, 0.0L));\n+  fool (__builtin_fmal (__LDBL_MAX__, 1.0L, __LDBL_MAX__));\n+  fool (__builtin_fmal (__LDBL_MIN__, __LDBL_MIN__, 0.0L));\n }\n \n /* { dg-final { scan-tree-dump-times \"exp2 \" 9 \"original\" } } */\n@@ -168,4 +180,7 @@ void bar()\n /* { dg-final { scan-tree-dump-times \"pow \" 13 \"original\" } } */\n /* { dg-final { scan-tree-dump-times \"powf\" 13 \"original\" } } */\n /* { dg-final { scan-tree-dump-times \"powl\" 13 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"fma \" 3 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"fmaf\" 3 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"fmal\" 3 \"original\" } } */\n /* { dg-final { cleanup-tree-dump \"original\" } } */"}, {"sha": "67304f8191e55d0ad5196f76a8842e7f16048eb5", "filename": "gcc/testsuite/gcc.dg/torture/builtin-math-3.c", "status": "modified", "additions": 93, "deletions": 6, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e61e5ddcceb34c5a5dc09febaedb44059d5bc96d/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e61e5ddcceb34c5a5dc09febaedb44059d5bc96d/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-3.c?ref=e61e5ddcceb34c5a5dc09febaedb44059d5bc96d", "patch": "@@ -13,13 +13,25 @@\n /* All references to link_error should go away at compile-time.  */\n extern void link_error(int);\n \n+/* Return TRUE if the sign of X != sign of Y.  This is important when\n+   comparing signed zeros.  */\n+#define CKSGN_F(X,Y) \\\n+  (__builtin_copysignf(1.0F,(X)) != __builtin_copysignf(1.0F,(Y)))\n+#define CKSGN(X,Y) \\\n+  (__builtin_copysign(1.0,(X)) != __builtin_copysign(1.0,(Y)))\n+#define CKSGN_L(X,Y) \\\n+  (__builtin_copysignl(1.0L,(X)) != __builtin_copysignl(1.0L,(Y)))\n+\n /* Test that FUNC(ARG) == (RES).  */\n #define TESTIT(FUNC,ARG,RES) do { \\\n-  if (__builtin_##FUNC##f(ARG##F) != RES##F) \\\n+  if (__builtin_##FUNC##f(ARG##F) != RES##F \\\n+      || CKSGN_F(__builtin_##FUNC##f(ARG##F),RES##F)) \\\n     link_error(__LINE__); \\\n-  if (__builtin_##FUNC(ARG) != RES) \\\n+  if (__builtin_##FUNC(ARG) != RES \\\n+      || CKSGN(__builtin_##FUNC(ARG),RES)) \\\n     link_error(__LINE__); \\\n-  if (__builtin_##FUNC##l(ARG##L) != RES##L) \\\n+  if (__builtin_##FUNC##l(ARG##L) != RES##L \\\n+      || CKSGN_L(__builtin_##FUNC##l(ARG##L),RES##L)) \\\n     link_error(__LINE__); \\\n   } while (0)\n \n@@ -35,11 +47,14 @@ extern void link_error(int);\n \n /* Test that FUNC(ARG1, ARG2) == (RES).  */\n #define TESTIT2(FUNC,ARG1,ARG2,RES) do { \\\n-  if (__builtin_##FUNC##f(ARG1##F, ARG2##F) != RES##F) \\\n+  if (__builtin_##FUNC##f(ARG1##F, ARG2##F) != RES##F \\\n+      || CKSGN_F(__builtin_##FUNC##f(ARG1##F,ARG2##F),RES##F)) \\\n     link_error(__LINE__); \\\n-  if (__builtin_##FUNC(ARG1, ARG2) != RES) \\\n+  if (__builtin_##FUNC(ARG1, ARG2) != RES \\\n+      || CKSGN(__builtin_##FUNC(ARG1,ARG2),RES)) \\\n     link_error(__LINE__); \\\n-  if (__builtin_##FUNC##l(ARG1##L, ARG2##L) != RES##L) \\\n+  if (__builtin_##FUNC##l(ARG1##L, ARG2##L) != RES##L \\\n+      || CKSGN_L(__builtin_##FUNC##l(ARG1##L,ARG2##L),RES##L)) \\\n     link_error(__LINE__); \\\n   } while (0)\n \n@@ -56,6 +71,19 @@ extern void link_error(int);\n     link_error(__LINE__); \\\n   } while (0)\n \n+/* Test that FUNC(ARG1, ARG2, ARG3) == (RES).  */\n+#define TESTIT3(FUNC,ARG1,ARG2,ARG3,RES) do { \\\n+  if (__builtin_##FUNC##f(ARG1##F, ARG2##F, ARG3##F) != RES##F \\\n+      || CKSGN_F(__builtin_##FUNC##f(ARG1##F,ARG2##F,ARG3##F),RES##F)) \\\n+    link_error(__LINE__); \\\n+  if (__builtin_##FUNC(ARG1, ARG2, ARG3) != RES \\\n+      || CKSGN(__builtin_##FUNC(ARG1,ARG2,ARG3),RES)) \\\n+    link_error(__LINE__); \\\n+  if (__builtin_##FUNC##l(ARG1##L, ARG2##L, ARG3##L) != RES##L \\\n+      || CKSGN_L(__builtin_##FUNC##l(ARG1##L,ARG2##L,ARG3##L),RES##L)) \\\n+    link_error(__LINE__); \\\n+  } while (0)\n+\n /* Test that for FUNC(ARG, &ARG_S, &ARG_C);\n    assert (ARG_S == RES_S && ARG_C == RES_C);.  */\n #define TESTIT_2P(FUNC,ARG,ARG_S,ARG_C,RES_S,RES_C) do { \\\n@@ -266,5 +294,64 @@ int main (void)\n   TESTIT2_R (atan2, -1.0, 0.0, -1.58, -1.57); /* atan2(-1,0) == -pi/2 */\n   TESTIT2_R (atan2, 1.0, 0.0, 1.57, 1.58); /* atan2(1,0) == pi/2 */\n \n+  TESTIT2 (fmin, 5.0, 6.0, 5.0); /* fmin(5,6) == 5 */\n+  TESTIT2 (fmin, 6.0, 5.0, 5.0); /* fmin(6,5) == 5 */\n+  TESTIT2 (fmin, -5.0, -6.0, -6.0); /* fmin(-5,-6) == -6 */\n+  TESTIT2 (fmin, -6.0, -5.0, -6.0); /* fmin(-6,-5) == -6 */\n+  TESTIT2 (fmin, -0.0, 0.0, -0.0); /* fmin(-0,0) == -0 */\n+  TESTIT2 (fmin, 0.0, -0.0, -0.0); /* fmin(-0,0) == -0 */\n+\n+  TESTIT2 (fmax, 5.0, 6.0, 6.0); /* fmax(5,6) == 6 */\n+  TESTIT2 (fmax, 6.0, 5.0, 6.0); /* fmax(6,5) == 6 */\n+  TESTIT2 (fmax, -5.0, -6.0, -5.0); /* fmax(-5,-6) == -5 */\n+  TESTIT2 (fmax, -6.0, -5.0, -5.0); /* fmax(-6,-5) == -5 */\n+  TESTIT2 (fmax, -0.0, 0.0, 0.0); /* fmax(-0,0) == 0 */\n+  TESTIT2 (fmax, 0.0, -0.0, 0.0); /* fmax(-0,0) == 0 */\n+\n+  TESTIT3 (fma, 2.0, 3.0, 4.0, 10.0); /* fma(2,3,4) == 10 */\n+  TESTIT3 (fma, 2.0, -3.0, 4.0, -2.0); /* fma(2,-3,4) == -2 */\n+  TESTIT3 (fma, 2.0, 3.0, -4.0, 2.0); /* fma(2,3,-4) == 2 */\n+  TESTIT3 (fma, 2.0, -3.0, -4.0, -10.0); /* fma(2,-3,-4) == -10 */\n+  TESTIT3 (fma, -2.0, -3.0, -4.0, 2.0); /* fma(-2,-3,-4) == 2 */\n+  TESTIT3 (fma, 6.0, -0.0, 0.0, 0.0); /* fma(6,-0,0) == 0 */\n+  TESTIT3 (fma, -0.0, 6.0, 0.0, 0.0); /* fma(-0,6,0) == 0 */\n+  TESTIT3 (fma, 6.0, -0.0, -0.0, -0.0); /* fma(6,-0,-0) == -0 */\n+  TESTIT3 (fma, -0.0, 6.0, -0.0, -0.0); /* fma(-0,6,-0) == -0 */\n+  TESTIT3 (fma, 0.0, 0.0, 0.0, 0.0); /* fma(0,0,0) == 0 */\n+  TESTIT3 (fma, -0.0, 0.0, 0.0, 0.0); /* fma(-0,0,0) == 0 */\n+  TESTIT3 (fma, 0.0, -0.0, 0.0, 0.0); /* fma(0,-0,0) == 0 */\n+  TESTIT3 (fma, -0.0, -0.0, 0.0, 0.0); /* fma(-0,-0,0) == 0 */\n+  TESTIT3 (fma, 0.0, 0.0, -0.0, 0.0); /* fma(0,0,-0) == 0 */\n+  TESTIT3 (fma, -0.0, 0.0, -0.0, -0.0); /* fma(-0,0,-0) == -0 */\n+  TESTIT3 (fma, 0.0, -0.0, -0.0, -0.0); /* fma(0,-0,-0) == -0 */\n+  TESTIT3 (fma, -0.0, -0.0, -0.0, 0.0); /* fma(-0,-0,-0) == 0 */\n+\n+  if (__builtin_fmaf(__FLT_MAX__, 2.0F, -__FLT_MAX__) != __FLT_MAX__)\n+    link_error (__LINE__);\n+  if (__builtin_fmaf(2.0F,__FLT_MAX__, -__FLT_MAX__) != __FLT_MAX__)\n+    link_error (__LINE__);\n+  if (__builtin_fmaf(__FLT_MIN__, 0.5F, __FLT_MIN__) != __FLT_MIN__*1.5F)\n+    link_error (__LINE__);\n+  if (__builtin_fmaf(0.5F,__FLT_MIN__, __FLT_MIN__) != __FLT_MIN__*1.5F)\n+    link_error (__LINE__);\n+\n+  if (__builtin_fma(__DBL_MAX__, 2.0, -__DBL_MAX__) != __DBL_MAX__)\n+    link_error (__LINE__);\n+  if (__builtin_fma(2.0,__DBL_MAX__, -__DBL_MAX__) != __DBL_MAX__)\n+    link_error (__LINE__);\n+  if (__builtin_fma(__DBL_MIN__, 0.5, __DBL_MIN__) != __DBL_MIN__*1.5)\n+    link_error (__LINE__);\n+  if (__builtin_fma(0.5,__DBL_MIN__, __DBL_MIN__) != __DBL_MIN__*1.5)\n+    link_error (__LINE__);\n+\n+  if (__builtin_fmal(__LDBL_MAX__, 2.0L, -__LDBL_MAX__) != __LDBL_MAX__)\n+    link_error (__LINE__);\n+  if (__builtin_fmal(2.0L,__LDBL_MAX__, -__LDBL_MAX__) != __LDBL_MAX__)\n+    link_error (__LINE__);\n+  if (__builtin_fmal(__LDBL_MIN__, 0.5L, __LDBL_MIN__) != __LDBL_MIN__*1.5L)\n+    link_error (__LINE__);\n+  if (__builtin_fmal(0.5L,__LDBL_MIN__, __LDBL_MIN__) != __LDBL_MIN__*1.5L)\n+    link_error (__LINE__);\n+\n   return 0;\n }"}]}