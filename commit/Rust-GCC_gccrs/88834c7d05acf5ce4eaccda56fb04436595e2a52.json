{"sha": "88834c7d05acf5ce4eaccda56fb04436595e2a52", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODg4MzRjN2QwNWFjZjVjZTRlYWNjZGE1NmZiMDQ0MzY1OTVlMmE1Mg==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-05-26T12:37:30Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-05-26T12:37:30Z"}, "message": "c++: constexpr and copy elision within mem init [PR100368]\n\nIn the testcase below, the member initializer b(f()) inside C's default\nconstructor is encoded as a TARGET_EXPR wrapping the CALL_EXPR f() in\nC++17 mode.  During massaging of this constexpr constructor,\nbuild_target_expr_with_type called from bot_manip on this initializer\ntries to add an extra copy using B's implicitly deleted copy constructor\nrather than just preserving the copy elision.\n\nSince it's wrong to introduce an extra copy when initializing a\ntemporary from a CALL_EXPR, this patch makes build_target_expr_with_type\navoid calling force_rvalue in this case.  Additionally, bot_manip should\nbe copying TARGET_EXPRs in a more oblivious manner, so this patch makes\nbot_manip use force_target_expr instead of build_target_expr_with_type.\nAnd since bot_manip is now no longer a caller, we can remove the void\ninitializer handling in build_target_expr_with_type.\n\n\tPR c++/100368\n\ngcc/cp/ChangeLog:\n\n\t* tree.c (build_target_expr_with_type): Don't call force_rvalue\n\ton CALL_EXPR initializer.  Simplify now that bot_manip is no\n\tlonger a caller.\n\t(bot_manip): Use force_target_expr instead of\n\tbuild_target_expr_with_type.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp1z/elide6.C: New test.", "tree": {"sha": "1e568bdbd5eacf4883a7a5df569add056eeb8442", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1e568bdbd5eacf4883a7a5df569add056eeb8442"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/88834c7d05acf5ce4eaccda56fb04436595e2a52", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88834c7d05acf5ce4eaccda56fb04436595e2a52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88834c7d05acf5ce4eaccda56fb04436595e2a52", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88834c7d05acf5ce4eaccda56fb04436595e2a52/comments", "author": null, "committer": null, "parents": [{"sha": "b4329e3dd6fb7c78948fcf9d2f5b9d873deec284", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4329e3dd6fb7c78948fcf9d2f5b9d873deec284", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4329e3dd6fb7c78948fcf9d2f5b9d873deec284"}], "stats": {"total": 31, "additions": 24, "deletions": 7}, "files": [{"sha": "372d89fa9edd05c79c67bba9914f1c5ab8fe6a32", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88834c7d05acf5ce4eaccda56fb04436595e2a52/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88834c7d05acf5ce4eaccda56fb04436595e2a52/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=88834c7d05acf5ce4eaccda56fb04436595e2a52", "patch": "@@ -843,21 +843,22 @@ tree\n build_target_expr_with_type (tree init, tree type, tsubst_flags_t complain)\n {\n   gcc_assert (!VOID_TYPE_P (type));\n+  gcc_assert (!VOID_TYPE_P (TREE_TYPE (init)));\n \n   if (TREE_CODE (init) == TARGET_EXPR\n       || init == error_mark_node)\n     return init;\n   else if (CLASS_TYPE_P (type) && type_has_nontrivial_copy_init (type)\n-\t   && !VOID_TYPE_P (TREE_TYPE (init))\n \t   && TREE_CODE (init) != COND_EXPR\n \t   && TREE_CODE (init) != CONSTRUCTOR\n-\t   && TREE_CODE (init) != VA_ARG_EXPR)\n-    /* We need to build up a copy constructor call.  A void initializer\n-       means we're being called from bot_manip.  COND_EXPR is a special\n+\t   && TREE_CODE (init) != VA_ARG_EXPR\n+\t   && TREE_CODE (init) != CALL_EXPR)\n+    /* We need to build up a copy constructor call.  COND_EXPR is a special\n        case because we already have copies on the arms and we don't want\n        another one here.  A CONSTRUCTOR is aggregate initialization, which\n        is handled separately.  A VA_ARG_EXPR is magic creation of an\n-       aggregate; there's no additional work to be done.  */\n+       aggregate; there's no additional work to be done.  A CALL_EXPR\n+       already creates a prvalue.  */\n     return force_rvalue (init, complain);\n \n   return force_target_expr (type, init, complain);\n@@ -3112,8 +3113,8 @@ bot_manip (tree* tp, int* walk_subtrees, void* data_)\n \t    AGGR_INIT_ZERO_FIRST (TREE_OPERAND (u, 1)) = true;\n \t}\n       else\n-\tu = build_target_expr_with_type (TREE_OPERAND (t, 1), TREE_TYPE (t),\n-\t\t\t\t\t tf_warning_or_error);\n+\tu = force_target_expr (TREE_TYPE (t), TREE_OPERAND (t, 1),\n+\t\t\t       tf_warning_or_error);\n \n       TARGET_EXPR_IMPLICIT_P (u) = TARGET_EXPR_IMPLICIT_P (t);\n       TARGET_EXPR_LIST_INIT_P (u) = TARGET_EXPR_LIST_INIT_P (t);"}, {"sha": "399e1a9a1ef07a902b1c538f96f8a5e530286beb", "filename": "gcc/testsuite/g++.dg/cpp1z/elide6.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88834c7d05acf5ce4eaccda56fb04436595e2a52/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Felide6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88834c7d05acf5ce4eaccda56fb04436595e2a52/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Felide6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Felide6.C?ref=88834c7d05acf5ce4eaccda56fb04436595e2a52", "patch": "@@ -0,0 +1,16 @@\n+// PR c++/100368\n+// { dg-do compile { target c++11 } }\n+\n+struct A {\n+  A() = default;\n+  A(const A&) = delete;\n+};\n+\n+struct B { A a; }; // { dg-error \"deleted\" \"\" { target c++14_down } }\n+\n+constexpr B f() { return {}; }\n+\n+struct C {\n+  constexpr C() : b(f()) {} // { dg-error \"deleted\" \"\" { target c++14_down } }\n+  B b;\n+};"}]}