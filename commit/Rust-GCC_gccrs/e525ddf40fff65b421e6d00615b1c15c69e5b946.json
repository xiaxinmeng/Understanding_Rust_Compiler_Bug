{"sha": "e525ddf40fff65b421e6d00615b1c15c69e5b946", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTUyNWRkZjQwZmZmNjViNDIxZTZkMDA2MTViMWMxNWM2OWU1Yjk0Ng==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2017-06-10T20:37:34Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2017-06-10T20:37:34Z"}, "message": "predict.c (drop_profile): Also drop individual bb/edge and cgraph edge counts.\n\n\n\t* predict.c (drop_profile): Also drop individual bb/edge and cgraph\n\tedge counts.\n\t(handle_missing_profiles): Fix computation of tp_first_run.\n\t(counts_to_freqs): Do not touch freqs when count is 0.\n\nFrom-SVN: r249094", "tree": {"sha": "360bcca82b59f226f23ce495a738ad209a84582e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/360bcca82b59f226f23ce495a738ad209a84582e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e525ddf40fff65b421e6d00615b1c15c69e5b946", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e525ddf40fff65b421e6d00615b1c15c69e5b946", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e525ddf40fff65b421e6d00615b1c15c69e5b946", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e525ddf40fff65b421e6d00615b1c15c69e5b946/comments", "author": null, "committer": null, "parents": [{"sha": "9a73a3c38e01890fcc4615c53c3946b8e46fc252", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a73a3c38e01890fcc4615c53c3946b8e46fc252", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a73a3c38e01890fcc4615c53c3946b8e46fc252"}], "stats": {"total": 50, "additions": 41, "deletions": 9}, "files": [{"sha": "9799675e9133ecf7d0eaa0ea0592501237f211f1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e525ddf40fff65b421e6d00615b1c15c69e5b946/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e525ddf40fff65b421e6d00615b1c15c69e5b946/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e525ddf40fff65b421e6d00615b1c15c69e5b946", "patch": "@@ -1,3 +1,10 @@\n+2017-06-10  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* predict.c (drop_profile): Also drop individual bb/edge and cgraph\n+\tedge counts.\n+\t(handle_missing_profiles): Fix computation of tp_first_run.\n+\t(counts_to_freqs): Do not touch freqs when count is 0.\n+\n 2017-06-10  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* cgraphbuild.c (cgraph_edge::rebuild_references): Do not touch"}, {"sha": "1cb7dc5010366fbec0e67aab2742569604b4bf2f", "filename": "gcc/predict.c", "status": "modified", "additions": 34, "deletions": 9, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e525ddf40fff65b421e6d00615b1c15c69e5b946/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e525ddf40fff65b421e6d00615b1c15c69e5b946/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=e525ddf40fff65b421e6d00615b1c15c69e5b946", "patch": "@@ -3251,6 +3251,26 @@ drop_profile (struct cgraph_node *node, profile_count call_count)\n \t\t node->dump_name ());\n     }\n \n+  basic_block bb;\n+  FOR_ALL_BB_FN (bb, fn)\n+    {\n+      bb->count = profile_count::uninitialized ();\n+\n+      edge_iterator ei;\n+      edge e;\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n+\te->count = profile_count::uninitialized ();\n+    }\n+\n+  struct cgraph_edge *e;\n+  for (e = node->callees; e; e = e->next_caller)\n+    {\n+      e->count = profile_count::uninitialized ();\n+      e->frequency = compute_call_stmt_bb_frequency (e->caller->decl,\n+\t\t\t\t\t\t     gimple_bb (e->call_stmt));\n+    }\n+  node->count = profile_count::uninitialized ();\n+  \n   profile_status_for_fn (fn)\n       = (flag_guess_branch_prob ? PROFILE_GUESSED : PROFILE_ABSENT);\n   node->frequency\n@@ -3289,15 +3309,13 @@ handle_missing_profiles (void)\n       if (!(node->count == profile_count::zero ()))\n         continue;\n       for (e = node->callers; e; e = e->next_caller)\n-      {\n-\tif (e->count.initialized_p () > 0)\n+\tif (e->count.initialized_p () && e->count > 0)\n \t  {\n             call_count = call_count + e->count;\n \n \t    if (e->caller->tp_first_run > max_tp_first_run)\n \t      max_tp_first_run = e->caller->tp_first_run;\n \t  }\n-      }\n \n       /* If time profile is missing, let assign the maximum that comes from\n \t caller functions.  */\n@@ -3306,7 +3324,8 @@ handle_missing_profiles (void)\n \n       if (call_count > 0\n           && fn && fn->cfg\n-          && (call_count.apply_scale (unlikely_count_fraction, 1) >= profile_info->runs))\n+          && (call_count.apply_scale (unlikely_count_fraction, 1)\n+\t      >= profile_info->runs))\n         {\n           drop_profile (node, call_count);\n           worklist.safe_push (node);\n@@ -3327,7 +3346,8 @@ handle_missing_profiles (void)\n \n           if (callee->count > 0)\n             continue;\n-          if (DECL_COMDAT (callee->decl) && fn && fn->cfg\n+          if ((DECL_COMDAT (callee->decl) || DECL_EXTERNAL (callee->decl))\n+\t      && fn && fn->cfg\n               && profile_status_for_fn (fn) == PROFILE_READ)\n             {\n               drop_profile (node, profile_count::zero ());\n@@ -3352,19 +3372,24 @@ counts_to_freqs (void)\n      later in drop_profile ().  */\n   if (!ENTRY_BLOCK_PTR_FOR_FN (cfun)->count.initialized_p ()\n       || ENTRY_BLOCK_PTR_FOR_FN (cfun)->count == profile_count::zero ())\n-    return 0;\n+    return false;\n \n   FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun), NULL, next_bb)\n     if (bb->count > true_count_max)\n       true_count_max = bb->count;\n \n-  count_max = MAX (true_count_max.to_gcov_type (), 1);\n+  /* If we have no counts to base frequencies on, keep those that are\n+     already there.  */\n+  if (!(true_count_max > 0))\n+    return false;\n \n-  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun), NULL, next_bb)\n+  count_max = true_count_max.to_gcov_type ();\n+\n+  FOR_ALL_BB_FN (bb, cfun)\n     if (bb->count.initialized_p ())\n       bb->frequency = RDIV (bb->count.to_gcov_type () * BB_FREQ_MAX, count_max);\n \n-  return !(true_count_max == profile_count::zero ());\n+  return true;\n }\n \n /* Return true if function is likely to be expensive, so there is no point to"}]}