{"sha": "859fd598cb7a5f449fa3ce9aaafb65ade064b2ed", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODU5ZmQ1OThjYjdhNWY0NDlmYTNjZTlhYWFmYjY1YWRlMDY0YjJlZA==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2007-12-13T10:29:52Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-12-13T10:29:52Z"}, "message": "sem_ch12.adb (Instantiate_Formal_Subprogram): In the subprogram renaming declaration...\n\n2007-12-06  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch12.adb (Instantiate_Formal_Subprogram): In the subprogram\n\trenaming declaration, use the Slocs of the formal parameters from the\n\tdeclaration of the formal subprogram when creating the formal parameter\n\tentities in the renaming declaration.\n\t(Analyze_Formal_Type_Declaration): Change the placement of the error\n\tmessage concerning illegal known discriminants. It is now posted on the\n\ttype rather than on the first discriminant. This change ensures early\n\terror report.\n\t(Freeze_Subprogram_Body): If the generic subprogram is nested within\n\tthe package body that contains the instance, do not generate an\n\tout-of-place freeze node for the enclosing package.\n\t(Collect_Previous_Instantiations): Ignore internal instantiations\n\tgenerated for formal packages.\n\t(Validate_Derived_Type_Instance): Add a check that when a formal\n\tderived type is Known_To_Have_Preelab_Init then the actual type must\n\thave preelaborable initialization, and issue an error when this\n\tcondition is violated.\n\nFrom-SVN: r130851", "tree": {"sha": "555f346d0e322181559c667f7c58a325908b4c71", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/555f346d0e322181559c667f7c58a325908b4c71"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/859fd598cb7a5f449fa3ce9aaafb65ade064b2ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/859fd598cb7a5f449fa3ce9aaafb65ade064b2ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/859fd598cb7a5f449fa3ce9aaafb65ade064b2ed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/859fd598cb7a5f449fa3ce9aaafb65ade064b2ed/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e116d16c19904addc54c93b3c5b272fb414c2f99", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e116d16c19904addc54c93b3c5b272fb414c2f99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e116d16c19904addc54c93b3c5b272fb414c2f99"}], "stats": {"total": 85, "additions": 59, "deletions": 26}, "files": [{"sha": "4a830603f129ae7fee183130db8f738b69cc655b", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 59, "deletions": 26, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/859fd598cb7a5f449fa3ce9aaafb65ade064b2ed/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/859fd598cb7a5f449fa3ce9aaafb65ade064b2ed/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=859fd598cb7a5f449fa3ce9aaafb65ade064b2ed", "patch": "@@ -589,8 +589,8 @@ package body Sem_Ch12 is\n    --  is true in the declarative region of the formal package, that is to say\n    --  in the enclosing generic or instantiation. For an instantiation, the\n    --  parameters of the formal package are made visible in an explicit step.\n-   --  Furthermore, if the actual is a visible use_clause, these formals must\n-   --  be made potentially use_visible as well. On exit from the enclosing\n+   --  Furthermore, if the actual has a visible USE clause, these formals must\n+   --  be made potentially use-visible as well. On exit from the enclosing\n    --  instantiation, the reverse must be done.\n \n    --  For a formal package declared without a box, there are conformance rules\n@@ -603,7 +603,7 @@ package body Sem_Ch12 is\n    --  formals: the visible and private declarations themselves need not be\n    --  created.\n \n-   --  In Ada2005, the formal package may be only partially parametrized. In\n+   --  In Ada 2005, the formal package may be only partially parametrized. In\n    --  that case the visibility step must make visible those actuals whose\n    --  corresponding formals were given with a box. A final complication\n    --  involves inherited operations from formal derived types, which must be\n@@ -1575,18 +1575,15 @@ package body Sem_Ch12 is\n       Def : Node_Id)\n    is\n       Loc   : constant Source_Ptr := Sloc (Def);\n-      New_N : Node_Id;\n \n    begin\n       --  Rewrite as a type declaration of a derived type. This ensures that\n       --  the interface list and primitive operations are properly captured.\n \n-      New_N :=\n+      Rewrite (N,\n         Make_Full_Type_Declaration (Loc,\n           Defining_Identifier => T,\n-           Type_Definition => Def);\n-\n-      Rewrite (N, New_N);\n+          Type_Definition     => Def));\n       Analyze (N);\n       Set_Is_Generic_Type (T);\n    end Analyze_Formal_Derived_Interface_Type;\n@@ -1626,9 +1623,9 @@ package body Sem_Ch12 is\n              Defining_Identifier => T,\n              Discriminant_Specifications =>\n                Discriminant_Specifications (Parent (T)),\n-              Type_Definition =>\n-                Make_Derived_Type_Definition (Loc,\n-                  Subtype_Indication => Subtype_Mark (Def)));\n+             Type_Definition =>\n+               Make_Derived_Type_Definition (Loc,\n+                 Subtype_Indication => Subtype_Mark (Def)));\n \n          Set_Abstract_Present\n            (Type_Definition (New_N), Abstract_Present (Def));\n@@ -2482,8 +2479,7 @@ package body Sem_Ch12 is\n         and then Nkind (Def) /= N_Formal_Private_Type_Definition\n       then\n          Error_Msg_N\n-           (\"discriminants not allowed for this formal type\",\n-            Defining_Identifier (First (Discriminant_Specifications (N))));\n+           (\"discriminants not allowed for this formal type\", T);\n       end if;\n \n       --  Enter the new name, and branch to specific routine\n@@ -3934,7 +3930,6 @@ package body Sem_Ch12 is\n          if Nkind (Parent (N)) = N_Compilation_Unit then\n             Set_Body_Required (Parent (N), False);\n          end if;\n-\n       end Analyze_Instance_And_Renamings;\n \n    --  Start of processing for Analyze_Subprogram_Instantiation\n@@ -6430,9 +6425,26 @@ package body Sem_Ch12 is\n          --  Freeze package that encloses instance, and place node after\n          --  package that encloses generic. If enclosing package is already\n          --  frozen we have to assume it is at the proper place. This may be\n-         --  a potential ABE that requires dynamic checking.\n+         --  a potential ABE that requires dynamic checking. Do not add a\n+         --  freeze node if the package that encloses the generic is inside\n+         --  the body that encloses the instance, because the freeze node\n+         --  would be in the wrong scope. Additional contortions needed if\n+         --  the bodies are within a subunit.\n+\n+         declare\n+            Enclosing_Body : Node_Id;\n+\n+         begin\n+            if Nkind (Enc_I) = N_Package_Body_Stub then\n+               Enclosing_Body := Proper_Body (Unit (Library_Unit (Enc_I)));\n+            else\n+               Enclosing_Body := Enc_I;\n+            end if;\n \n-         Insert_After_Last_Decl (Enc_G, Package_Freeze_Node (Enc_I));\n+            if Parent (List_Containing (Enc_G)) /= Enclosing_Body then\n+               Insert_After_Last_Decl (Enc_G, Package_Freeze_Node (Enc_I));\n+            end if;\n+         end;\n \n          --  Freeze enclosing subunit before instance\n \n@@ -6887,7 +6899,7 @@ package body Sem_Ch12 is\n       --  stub in the current compilation, not the subunit itself.\n \n       if Nkind (Parent (Gen_Body)) = N_Subunit then\n-         Orig_Body :=  Corresponding_Stub (Parent (Gen_Body));\n+         Orig_Body := Corresponding_Stub (Parent (Gen_Body));\n       else\n          Orig_Body := Gen_Body;\n       end if;\n@@ -7856,7 +7868,7 @@ package body Sem_Ch12 is\n             F := First (Parameter_Specifications (New_Spec));\n             while Present (F) loop\n                Set_Defining_Identifier (F,\n-                  Make_Defining_Identifier (Loc,\n+                  Make_Defining_Identifier (Sloc (F),\n                     Chars => Chars (Defining_Identifier (F))));\n                Next (F);\n             end loop;\n@@ -9299,6 +9311,17 @@ package body Sem_Ch12 is\n             Ancestor := Get_Instance_Of (Etype (Base_Type (A_Gen_T)));\n          end if;\n \n+         --  If the formal derived type has pragma Preelaborable_Initialization\n+         --  then the actual type must have preelaborable initialization.\n+\n+         if Known_To_Have_Preelab_Init (A_Gen_T)\n+           and then not Has_Preelaborable_Initialization (Act_T)\n+         then\n+            Error_Msg_NE\n+              (\"actual for & must have preelaborable initialization\",\n+               Actual, Gen_T);\n+         end if;\n+\n          --  Ada 2005 (AI-251)\n \n          if Ada_Version >= Ada_05\n@@ -10194,12 +10217,12 @@ package body Sem_Ch12 is\n       Previous_Instances : constant Elist_Id := New_Elmt_List;\n \n       procedure Collect_Previous_Instances (Decls : List_Id);\n-      --  Collect all instantiations in the given list of declarations,\n-      --  that precedes the generic that we need to load. If the bodies\n-      --  of these instantiations are available, we must analyze them,\n-      --  to ensure that the public symbols generated are the same when\n-      --  the unit is compiled to generate code, and when it is compiled\n-      --  in the context of the unit that needs a particular nested instance.\n+      --  Collect all instantiations in the given list of declarations, that\n+      --  precede the generic that we need to load. If the bodies of these\n+      --  instantiations are available, we must analyze them, to ensure that\n+      --  the public symbols generated are the same when the unit is compiled\n+      --  to generate code, and when it is compiled in the context of a unit\n+      --  that needs a particular nested instance.\n \n       --------------------------------\n       -- Collect_Previous_Instances --\n@@ -10214,7 +10237,17 @@ package body Sem_Ch12 is\n             if Sloc (Decl) >= Sloc (Inst_Node) then\n                return;\n \n-            elsif Nkind (Decl) = N_Package_Instantiation then\n+            --  If Decl is an instantiation, then record it as requiring\n+            --  instantiation of the corresponding body, except if it is an\n+            --  abbreviated instantiation generated internally for conformance\n+            --  checking purposes only for the case of a formal package\n+            --  declared without a box (see Instantiate_Formal_Package). Such\n+            --  an instantiation does not generate any code (the actual code\n+            --  comes from actual) and thus does not need to be analyzed here.\n+\n+            elsif Nkind (Decl) = N_Package_Instantiation\n+              and then not Is_Internal (Defining_Entity (Decl))\n+            then\n                Append_Elmt (Decl, Previous_Instances);\n \n             elsif Nkind (Decl) = N_Package_Declaration then\n@@ -10342,7 +10375,7 @@ package body Sem_Ch12 is\n                   end loop;\n \n                   --  Collect previous instantiations in the unit that\n-                  --  contains the desired generic,\n+                  --  contains the desired generic.\n \n                   if Nkind (Parent (True_Parent)) /= N_Compilation_Unit\n                     and then not Body_Optional"}]}