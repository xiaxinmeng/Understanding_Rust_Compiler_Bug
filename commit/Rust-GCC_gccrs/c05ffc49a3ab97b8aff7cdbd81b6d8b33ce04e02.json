{"sha": "c05ffc49a3ab97b8aff7cdbd81b6d8b33ce04e02", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzA1ZmZjNDlhM2FiOTdiOGFmZjdjZGJkODFiNmQ4YjMzY2UwNGUwMg==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@redhat.com", "date": "2002-07-21T14:32:25Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2002-07-21T14:32:25Z"}, "message": "Enhancements for the if-conversion pass\n\nFrom-SVN: r55624", "tree": {"sha": "66a3886f2195412511d8733665eafec2bcfe9319", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/66a3886f2195412511d8733665eafec2bcfe9319"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c05ffc49a3ab97b8aff7cdbd81b6d8b33ce04e02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c05ffc49a3ab97b8aff7cdbd81b6d8b33ce04e02", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c05ffc49a3ab97b8aff7cdbd81b6d8b33ce04e02", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c05ffc49a3ab97b8aff7cdbd81b6d8b33ce04e02/comments", "author": null, "committer": null, "parents": [{"sha": "753e29b1458fdd939341a155bdb488d7aa6b72c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/753e29b1458fdd939341a155bdb488d7aa6b72c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/753e29b1458fdd939341a155bdb488d7aa6b72c2"}], "stats": {"total": 850, "additions": 668, "deletions": 182}, "files": [{"sha": "8ec80f5928724ad0261480777c84fdb6a234e9dc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c05ffc49a3ab97b8aff7cdbd81b6d8b33ce04e02/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c05ffc49a3ab97b8aff7cdbd81b6d8b33ce04e02/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c05ffc49a3ab97b8aff7cdbd81b6d8b33ce04e02", "patch": "@@ -1,3 +1,49 @@\n+2002-07-21  Bernd Schmidt  <bernds@redhat.com>\n+\n+\tImprovements for the ifcvt pass from Michael Meissner, with patches\n+\tby Richard Sandiford <rsandifo@redhat.com>\n+\t* basic-block.h (struct ce_if_block, ce_if_block_t): New types.\n+\t* ifcvt.c (cond_exec_changed_p): New static variable.\n+\t(last_active_insn): New function, renamed from last_active_insn_p\n+\tand changed to return the last active insn in a basic block. All\n+\tcallers updated.\n+\t(block_fallthru): New function.\n+\t(cond_exec_process_insns): New argument CE_INFO.  Pass it to\n+\tIFCVT_MODIFY_INSN.  All callers updated.\n+\tReturn false if START or END are NULL.\n+\tHandle case where we're processing an insn that is already\n+\tconditional.\n+\n+\t(noce_process_if_block): CE_INFO argument rather than\n+\tmultiple args containing the involved basic blocks.  All callers\n+\tchanged.\n+\t(process_if_block, merge_if_block, find_if_block,\n+\tcond_exec_process_if_block): Likewise.\n+\n+\t(cond_exec_process_if_block): New arg DO_MULTIPLE_P.  All callers\n+\tchanged.\n+\tUse new function last_active_insn to simplify some code.\n+\tNew code to handle multiple tests.\n+\tCall IFCVT_MODIFY_CANCEL in all failure cases, otherwise set\n+\tcond_exec_changed_p to TRUE.\n+\n+\t(process_if_block): New code to handle multiple tests.\n+\t(merge_if_block): Likewise.\n+\t(find_if_header): New arg PASS.  Changed to return the currently\n+\tprocessed basic block or NULL instead of true/false. All callers\n+\tchanged.\n+\tCall IFCVT_INIT_EXTRA_FIELDS.\n+\t(block_jumps_and_fallthru_p): New function.\n+\t(find_if_block): Discover opportunities to convert multiple tests.\n+\tAdd additional debugging output.\n+\tUpdate the ce_info structure before returning.\n+\n+\t(if_convert): Run multiple passes of if-conversion.\n+\t* doc/tm.texi (IFCVT_MODIFY_TESTS, IFCVT_MODIFY_INSN,\n+\tIFCVT_MODIFY_FINAL, IFCVT_MODIFY_CANCEL, IFCVT_MODIFY_MULTIPLE_TESTS,\n+\tIFCVT_INIT_EXTRA_FIELDS, IFCVT_EXTRA_FIELDS): Update documentation for\n+\tthese macros.\n+\n Sun Jul 21 00:54:54 CEST 2002  Jan Hubicka  <jh@suse.cz>\n \n \t* gcse.c: Include cselib.h"}, {"sha": "ad7f1f65dd687089591e3900c4bd57fa514df5f4", "filename": "gcc/basic-block.h", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c05ffc49a3ab97b8aff7cdbd81b6d8b33ce04e02/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c05ffc49a3ab97b8aff7cdbd81b6d8b33ce04e02/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=c05ffc49a3ab97b8aff7cdbd81b6d8b33ce04e02", "patch": "@@ -523,6 +523,33 @@ struct loops\n   sbitmap shared_headers;\n };\n \n+/* Structure to group all of the information to process IF-THEN and\n+   IF-THEN-ELSE blocks for the conditional execution support.  This\n+   needs to be in a public file in case the IFCVT macros call\n+   functions passing the ce_if_block data structure.  */\n+\n+typedef struct ce_if_block\n+{\n+  basic_block test_bb;\t\t\t/* First test block.  */\n+  basic_block then_bb;\t\t\t/* THEN block.  */\n+  basic_block else_bb;\t\t\t/* ELSE block or NULL.  */\n+  basic_block join_bb;\t\t\t/* Join THEN/ELSE blocks.  */\n+  basic_block last_test_bb;\t\t/* Last bb to hold && or || tests.  */\n+  int num_multiple_test_blocks;\t\t/* # of && and || basic blocks.  */\n+  int num_and_and_blocks;\t\t/* # of && blocks.  */\n+  int num_or_or_blocks;\t\t\t/* # of || blocks.  */\n+  int num_multiple_test_insns;\t\t/* # of insns in && and || blocks.  */\n+  int and_and_p;\t\t\t/* Complex test is &&.  */\n+  int num_then_insns;\t\t\t/* # of insns in THEN block.  */\n+  int num_else_insns;\t\t\t/* # of insns in ELSE block.  */\n+  int pass;\t\t\t\t/* Pass number.  */\n+\n+#ifdef IFCVT_EXTRA_FIELDS\n+  IFCVT_EXTRA_FIELDS\t\t\t/* Any machine dependent fields.  */\n+#endif\n+\n+} ce_if_block_t;\n+\n extern int flow_loops_find PARAMS ((struct loops *, int flags));\n extern int flow_loops_update PARAMS ((struct loops *, int flags));\n extern void flow_loops_free PARAMS ((struct loops *));"}, {"sha": "7b4a80a1b0ef4233dfe42b5eaa842ebcaaa5fe43", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 40, "deletions": 15, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c05ffc49a3ab97b8aff7cdbd81b6d8b33ce04e02/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c05ffc49a3ab97b8aff7cdbd81b6d8b33ce04e02/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=c05ffc49a3ab97b8aff7cdbd81b6d8b33ce04e02", "patch": "@@ -8813,29 +8813,54 @@ conditional execution instructions instead of a branch.  A value of\n 1 if it does use cc0.\n \n @findex IFCVT_MODIFY_TESTS\n-@item IFCVT_MODIFY_TESTS\n-A C expression to modify the tests in @code{TRUE_EXPR}, and\n-@code{FALSE_EXPR} for use in converting insns in @code{TEST_BB},\n-@code{THEN_BB}, @code{ELSE_BB}, and @code{JOIN_BB} basic blocks to\n-conditional execution.  Set either @code{TRUE_EXPR} or @code{FALSE_EXPR}\n-to a null pointer if the tests cannot be converted.\n+@item IFCVT_MODIFY_TESTS(@var{ce_info}, @var{true_expr}, @var{false_expr})\n+Used if the target needs to perform machine-dependent modifications on the\n+conditionals used for turning basic blocks into conditionally executed code.\n+@var{ce_info} points to a data structure, @code{struct ce_if_block}, which\n+contains information about the currently processed blocks.  @var{true_expr}\n+and @var{false_expr} are the tests that are used for converting the\n+then-block and the else-block, respectively.  Set either @var{true_expr} or\n+@var{false_expr} to a null pointer if the tests cannot be converted.\n+\n+@findex IFCVT_MODIFY_MULTIPLE_TESTS\n+@item IFCVT_MODIFY_MULTIPLE_TESTS(@var{ce_info}, @var{bb}, @var{true_expr}, @var{false_expr})\n+Like @code{IFCVT_MODIFY_TESTS}, but used when converting more complicated\n+if-statements into conditions combined by @code{and} and @code{or} operations.\n+@var{bb} contains the basic block that contains the test that is currently\n+being processed and about to be turned into a condition.\n \n @findex IFCVT_MODIFY_INSN\n-@item IFCVT_MODIFY_INSN\n-A C expression to modify the @code{PATTERN} of an @code{INSN} that is to\n-be converted to conditional execution format.\n+@item IFCVT_MODIFY_INSN(@var{ce_info}, @var{pattern}, @var{insn})\n+A C expression to modify the @var{PATTERN} of an @var{INSN} that is to\n+be converted to conditional execution format.  @var{ce_info} points to\n+a data structure, @code{struct ce_if_block}, which contains information\n+about the currently processed blocks.\n \n @findex IFCVT_MODIFY_FINAL\n-@item IFCVT_MODIFY_FINAL\n+@item IFCVT_MODIFY_FINAL(@var{ce_info})\n A C expression to perform any final machine dependent modifications in\n-converting code to conditional execution in the basic blocks\n-@code{TEST_BB}, @code{THEN_BB}, @code{ELSE_BB}, and @code{JOIN_BB}.\n+converting code to conditional execution.  The involved basic blocks\n+can be found in the @code{struct ce_if_block} structure that is pointed\n+to by @var{ce_info}.\n \n @findex IFCVT_MODIFY_CANCEL\n-@item IFCVT_MODIFY_CANCEL\n+@item IFCVT_MODIFY_CANCEL(@var{ce_info})\n A C expression to cancel any machine dependent modifications in\n-converting code to conditional execution in the basic blocks\n-@code{TEST_BB}, @code{THEN_BB}, @code{ELSE_BB}, and @code{JOIN_BB}.\n+converting code to conditional execution.  The involved basic blocks\n+can be found in the @code{struct ce_if_block} structure that is pointed\n+to by @var{ce_info}.\n+\n+@findex IFCVT_INIT_EXTRA_FIELDS\n+@item IFCVT_INIT_EXTRA_FIELDS(@var{ce_info})\n+A C expression to initialize any extra fields in a @code{struct ce_if_block}\n+structure, which are defined by the @code{IFCVT_EXTRA_FIELDS} macro.\n+\n+@findex IFCVT_EXTRA_FIELDS\n+@item IFCVT_EXTRA_FIELDS\n+If defined, it should expand to a set of field declarations that will be\n+added to the @code{struct ce_if_block} structure.  These should be intialized\n+by the @code{IFCVT_INIT_EXTRA_FIELDS} macro.\n+\n @end table\n \n @deftypefn {Target Hook} void TARGET_INIT_BUILTINS ()"}, {"sha": "61dd48d7ce35fad8e01aa640085cb2e092879148", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 555, "deletions": 167, "changes": 722, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c05ffc49a3ab97b8aff7cdbd81b6d8b33ce04e02/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c05ffc49a3ab97b8aff7cdbd81b6d8b33ce04e02/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=c05ffc49a3ab97b8aff7cdbd81b6d8b33ce04e02", "patch": "@@ -73,6 +73,9 @@ static int num_updated_if_blocks;\n /* # of basic blocks that were removed.  */\n static int num_removed_blocks;\n \n+/* Whether conditional execution changes were made.  */\n+static int cond_exec_changed_p;\n+\n /* True if life data ok at present.  */\n static bool life_data_ok;\n \n@@ -82,34 +85,29 @@ static dominance_info post_dominators;\n /* Forward references.  */\n static int count_bb_insns\t\tPARAMS ((basic_block));\n static rtx first_active_insn\t\tPARAMS ((basic_block));\n-static int last_active_insn_p\t\tPARAMS ((basic_block, rtx));\n+static rtx last_active_insn\t\tPARAMS ((basic_block, int));\n static int seq_contains_jump\t\tPARAMS ((rtx));\n-\n-static int cond_exec_process_insns\tPARAMS ((rtx, rtx, rtx, rtx, int));\n+static basic_block block_fallthru\tPARAMS ((basic_block));\n+static int cond_exec_process_insns\tPARAMS ((ce_if_block_t *,\n+\t\t\t\t\t\t rtx, rtx, rtx, rtx, int));\n static rtx cond_exec_get_condition\tPARAMS ((rtx));\n-static int cond_exec_process_if_block\tPARAMS ((basic_block, basic_block,\n-\t\t\t\t\t\t basic_block, basic_block));\n-\n+static int cond_exec_process_if_block\tPARAMS ((ce_if_block_t *, int));\n static rtx noce_get_condition\t\tPARAMS ((rtx, rtx *));\n static int noce_operand_ok\t\tPARAMS ((rtx));\n-static int noce_process_if_block\tPARAMS ((basic_block, basic_block,\n-\t\t\t\t\t\t basic_block, basic_block));\n-\n-static int process_if_block\t\tPARAMS ((basic_block, basic_block,\n-\t\t\t\t\t\t basic_block, basic_block));\n-static void merge_if_block\t\tPARAMS ((basic_block, basic_block,\n-\t\t\t\t\t\t basic_block, basic_block));\n-\n-static int find_if_header\t\tPARAMS ((basic_block));\n-static int find_if_block\t\tPARAMS ((basic_block, edge, edge));\n+static int noce_process_if_block\tPARAMS ((ce_if_block_t *));\n+static int process_if_block\t\tPARAMS ((ce_if_block_t *));\n+static void merge_if_block\t\tPARAMS ((ce_if_block_t *));\n+static int find_cond_trap\t\tPARAMS ((basic_block, edge, edge));\n+static basic_block find_if_header\tPARAMS ((basic_block, int));\n+static int block_jumps_and_fallthru_p\tPARAMS ((basic_block, basic_block));\n+static int find_if_block\t\tPARAMS ((ce_if_block_t *));\n static int find_if_case_1\t\tPARAMS ((basic_block, edge, edge));\n static int find_if_case_2\t\tPARAMS ((basic_block, edge, edge));\n-static int find_cond_trap\t\tPARAMS ((basic_block, edge, edge));\n-static rtx block_has_only_trap\t\tPARAMS ((basic_block));\n static int find_memory\t\t\tPARAMS ((rtx *, void *));\n static int dead_or_predicable\t\tPARAMS ((basic_block, basic_block,\n \t\t\t\t\t\t basic_block, basic_block, int));\n static void noce_emit_move_insn\t\tPARAMS ((rtx, rtx));\n+static rtx block_has_only_trap\t\tPARAMS ((basic_block));\n \f\n /* Count the number of non-jump active insns in BB.  */\n \n@@ -161,22 +159,31 @@ first_active_insn (bb)\n   return insn;\n }\n \n-/* Return true if INSN is the last active non-jump insn in BB.  */\n+/* Return the last non-jump active (non-jump) insn in the basic block.  */\n \n-static int\n-last_active_insn_p (bb, insn)\n+static rtx\n+last_active_insn (bb, skip_use_p)\n      basic_block bb;\n-     rtx insn;\n+     int skip_use_p;\n {\n-  do\n+  rtx insn = bb->end;\n+  rtx head = bb->head;\n+\n+  while (GET_CODE (insn) == NOTE\n+\t || GET_CODE (insn) == JUMP_INSN\n+\t || (skip_use_p\n+\t     && GET_CODE (insn) == INSN\n+\t     && GET_CODE (PATTERN (insn)) == USE))\n     {\n-      if (insn == bb->end)\n-\treturn TRUE;\n-      insn = NEXT_INSN (insn);\n+      if (insn == head)\n+\treturn NULL_RTX;\n+      insn = PREV_INSN (insn);\n     }\n-  while (GET_CODE (insn) == NOTE);\n \n-  return GET_CODE (insn) == JUMP_INSN;\n+  if (GET_CODE (insn) == CODE_LABEL)\n+    return NULL_RTX;\n+\n+  return insn;\n }\n \n /* It is possible, especially when having dealt with multi-word \n@@ -196,13 +203,28 @@ seq_contains_jump (insn)\n     }\n   return 0;\n }\n+\n+static basic_block\n+block_fallthru (bb)\n+     basic_block bb;\n+{\n+  edge e;\n+\n+  for (e = bb->succ;\n+       e != NULL_EDGE && (e->flags & EDGE_FALLTHRU) == 0;\n+       e = e->succ_next)\n+    ;\n+\n+  return (e) ? e->dest : NULL_BLOCK;\n+}\n \f\n /* Go through a bunch of insns, converting them to conditional\n    execution format if possible.  Return TRUE if all of the non-note\n    insns were processed.  */\n \n static int\n-cond_exec_process_insns (start, end, test, prob_val, mod_ok)\n+cond_exec_process_insns (ce_info, start, end, test, prob_val, mod_ok)\n+     ce_if_block_t *ce_info;\t/* if block information */\n      rtx start;\t\t\t/* first insn to look at */\n      rtx end;\t\t\t/* last insn to look at */\n      rtx test;\t\t\t/* conditional execution test */\n@@ -211,8 +233,12 @@ cond_exec_process_insns (start, end, test, prob_val, mod_ok)\n {\n   int must_be_last = FALSE;\n   rtx insn;\n+  rtx xtest;\n   rtx pattern;\n \n+  if (!start || !end)\n+    return FALSE;\n+\n   for (insn = start; ; insn = NEXT_INSN (insn))\n     {\n       if (GET_CODE (insn) == NOTE)\n@@ -245,19 +271,32 @@ cond_exec_process_insns (start, end, test, prob_val, mod_ok)\n \n       /* Now build the conditional form of the instruction.  */\n       pattern = PATTERN (insn);\n+      xtest = copy_rtx (test);\n+\n+      /* If this is already a COND_EXEC, rewrite the test to be an AND of the\n+         two conditions.  */\n+      if (GET_CODE (pattern) == COND_EXEC)\n+\t{\n+\t  if (GET_MODE (xtest) != GET_MODE (COND_EXEC_TEST (pattern)))\n+\t    return FALSE;\n+\n+\t  xtest = gen_rtx_AND (GET_MODE (xtest), xtest,\n+\t\t\t       COND_EXEC_TEST (pattern));\n+\t  pattern = COND_EXEC_CODE (pattern);\n+\t}\n+\n+      pattern = gen_rtx_COND_EXEC (VOIDmode, xtest, pattern);\n \n       /* If the machine needs to modify the insn being conditionally executed,\n          say for example to force a constant integer operand into a temp\n          register, do so here.  */\n #ifdef IFCVT_MODIFY_INSN\n-      IFCVT_MODIFY_INSN (pattern, insn);\n+      IFCVT_MODIFY_INSN (ce_info, pattern, insn);\n       if (! pattern)\n \treturn FALSE;\n #endif\n \n-      validate_change (insn, &PATTERN (insn),\n-\t\t       gen_rtx_COND_EXEC (VOIDmode, copy_rtx (test),\n-\t\t\t\t\t  pattern), 1);\n+      validate_change (insn, &PATTERN (insn), pattern, 1);\n \n       if (GET_CODE (insn) == CALL_INSN && prob_val)\n \tvalidate_change (insn, &REG_NOTES (insn),\n@@ -307,18 +346,19 @@ cond_exec_get_condition (jump)\n    converting the the block.  */\n \n static int\n-cond_exec_process_if_block (test_bb, then_bb, else_bb, join_bb)\n-     basic_block test_bb;\t/* Basic block test is in */\n-     basic_block then_bb;\t/* Basic block for THEN block */\n-     basic_block else_bb;\t/* Basic block for ELSE block */\n-     basic_block join_bb;\t/* Basic block the join label is in */\n+cond_exec_process_if_block (ce_info, do_multiple_p)\n+     ce_if_block_t * ce_info;\t/* if block information */\n+     int do_multiple_p;\t\t/* != 0 if we should handle && and || blocks */\n {\n+  basic_block test_bb = ce_info->test_bb;\t/* last test block */\n+  basic_block then_bb = ce_info->then_bb;\t/* THEN */\n+  basic_block else_bb = ce_info->else_bb;\t/* ELSE or NULL */\n   rtx test_expr;\t\t/* expression in IF_THEN_ELSE that is tested */\n   rtx then_start;\t\t/* first insn in THEN block */\n   rtx then_end;\t\t\t/* last insn + 1 in THEN block */\n   rtx else_start = NULL_RTX;\t/* first insn in ELSE block or NULL */\n   rtx else_end = NULL_RTX;\t/* last insn + 1 in ELSE block */\n-  int max;\t\t\t/* max # of insns to convert.  */\n+  int max;\t\t\t/* max # of insns to convert. */\n   int then_mod_ok;\t\t/* whether conditional mods are ok in THEN */\n   rtx true_expr;\t\t/* test for else block insns */\n   rtx false_expr;\t\t/* test for then block insns */\n@@ -327,6 +367,20 @@ cond_exec_process_if_block (test_bb, then_bb, else_bb, join_bb)\n   int n_insns;\n   enum rtx_code false_code;\n \n+  /* If test is comprised of && or || elements, and we've failed at handling\n+     all of them together, just use the last test if it is the special case of\n+     && elements without an ELSE block.  */\n+  if (!do_multiple_p && ce_info->num_multiple_test_blocks)\n+    {\n+      if (else_bb || ! ce_info->and_and_p)\n+\treturn FALSE;\n+\n+      ce_info->test_bb = test_bb = ce_info->last_test_bb;\n+      ce_info->num_multiple_test_blocks = 0;\n+      ce_info->num_and_and_blocks = 0;\n+      ce_info->num_or_or_blocks = 0;\n+    }\n+\n   /* Find the conditional jump to the ELSE or JOIN part, and isolate\n      the test.  */\n   test_expr = cond_exec_get_condition (test_bb->end);\n@@ -335,51 +389,25 @@ cond_exec_process_if_block (test_bb, then_bb, else_bb, join_bb)\n \n   /* If the conditional jump is more than just a conditional jump,\n      then we can not do conditional execution conversion on this block.  */\n-  if (!onlyjump_p (test_bb->end))\n+  if (! onlyjump_p (test_bb->end))\n     return FALSE;\n \n-  /* Collect the bounds of where we're to search.  */\n-\n-  then_start = then_bb->head;\n-  then_end = then_bb->end;\n-\n-  /* Skip a label heading THEN block.  */\n-  if (GET_CODE (then_start) == CODE_LABEL)\n-    then_start = NEXT_INSN (then_start);\n-\n-  /* Skip a (use (const_int 0)) or branch as the final insn.  */\n-  if (GET_CODE (then_end) == INSN\n-      && GET_CODE (PATTERN (then_end)) == USE\n-      && GET_CODE (XEXP (PATTERN (then_end), 0)) == CONST_INT)\n-    then_end = PREV_INSN (then_end);\n-  else if (GET_CODE (then_end) == JUMP_INSN)\n-    then_end = PREV_INSN (then_end);\n+  /* Collect the bounds of where we're to search, skipping any labels, jumps\n+     and notes at the beginning and end of the block.  Then count the total\n+     number of insns and see if it is small enough to convert.  */\n+  then_start = first_active_insn (then_bb);\n+  then_end = last_active_insn (then_bb, TRUE);\n+  n_insns = ce_info->num_then_insns = count_bb_insns (then_bb);\n+  max = MAX_CONDITIONAL_EXECUTE;\n \n   if (else_bb)\n     {\n-      /* Skip the ELSE block's label.  */\n-      else_start = NEXT_INSN (else_bb->head);\n-      else_end = else_bb->end;\n-\n-      /* Skip a (use (const_int 0)) or branch as the final insn.  */\n-      if (GET_CODE (else_end) == INSN\n-\t  && GET_CODE (PATTERN (else_end)) == USE\n-\t  && GET_CODE (XEXP (PATTERN (else_end), 0)) == CONST_INT)\n-\telse_end = PREV_INSN (else_end);\n-      else if (GET_CODE (else_end) == JUMP_INSN)\n-\telse_end = PREV_INSN (else_end);\n+      max *= 2;\n+      else_start = first_active_insn (else_bb);\n+      else_end = last_active_insn (else_bb, TRUE);\n+      n_insns += ce_info->num_else_insns = count_bb_insns (else_bb);\n     }\n \n-  /* How many instructions should we convert in total?  */\n-  n_insns = 0;\n-  if (else_bb)\n-    {\n-      max = 2 * MAX_CONDITIONAL_EXECUTE;\n-      n_insns = count_bb_insns (else_bb);\n-    }\n-  else\n-    max = MAX_CONDITIONAL_EXECUTE;\n-  n_insns += count_bb_insns (then_bb);\n   if (n_insns > max)\n     return FALSE;\n \n@@ -406,6 +434,16 @@ cond_exec_process_if_block (test_bb, then_bb, else_bb, join_bb)\n     goto fail;\n #endif\n \n+#ifdef IFCVT_MODIFY_TESTS\n+  /* If the machine description needs to modify the tests, such as setting a\n+     conditional execution register from a comparison, it can do so here.  */\n+  IFCVT_MODIFY_TESTS (ce_info, true_expr, false_expr);\n+\n+  /* See if the conversion failed */\n+  if (!true_expr || !false_expr)\n+    goto fail;\n+#endif\n+\n   true_prob_val = find_reg_note (test_bb->end, REG_BR_PROB, NULL_RTX);\n   if (true_prob_val)\n     {\n@@ -415,6 +453,69 @@ cond_exec_process_if_block (test_bb, then_bb, else_bb, join_bb)\n   else\n     false_prob_val = NULL_RTX;\n \n+  /* If we have && or || tests, do them here.  These tests are in the adjacent\n+     blocks after the first block containing the test.  */\n+  if (ce_info->num_multiple_test_blocks > 0)\n+    {\n+      basic_block bb = test_bb;\n+      basic_block last_test_bb = ce_info->last_test_bb;\n+\n+      do\n+\t{\n+\t  rtx start, end;\n+\t  rtx t, f;\n+\n+\t  bb = block_fallthru (bb);\n+\t  start = first_active_insn (bb);\n+\t  end = last_active_insn (bb, TRUE);\n+\t  if (start\n+\t      && ! cond_exec_process_insns (ce_info, start, end, false_expr,\n+\t\t\t\t\t    false_prob_val, FALSE))\n+\t    goto fail;\n+\n+\t  /* If the conditional jump is more than just a conditional jump, then\n+\t     we can not do conditional execution conversion on this block.  */\n+\t  if (! onlyjump_p (bb->end))\n+\t    goto fail;\n+\n+\t  /* Find the conditional jump and isolate the test.  */\n+\t  t = cond_exec_get_condition (bb->end);\n+\t  if (! t)\n+\t    goto fail;\n+\n+\t  f = gen_rtx_fmt_ee (reverse_condition (GET_CODE (t)),\n+\t\t\t      GET_MODE (t),\n+\t\t\t      XEXP (t, 0),\n+\t\t\t      XEXP (t, 1));\n+\n+\t  if (ce_info->and_and_p)\n+\t    {\n+\t      t = gen_rtx_AND (GET_MODE (t), true_expr, t);\n+\t      f = gen_rtx_IOR (GET_MODE (t), false_expr, f);\n+\t    }\n+\t  else\n+\t    {\n+\t      t = gen_rtx_IOR (GET_MODE (t), true_expr, t);\n+\t      f = gen_rtx_AND (GET_MODE (t), false_expr, f);\n+\t    }\n+\n+\t  /* If the machine description needs to modify the tests, such as\n+\t     setting a conditional execution register from a comparison, it can\n+\t     do so here.  */\n+#ifdef IFCVT_MODIFY_MULTIPLE_TESTS\n+\t  IFCVT_MODIFY_MULTIPLE_TESTS (ce_info, bb, t, f);\n+\n+\t  /* See if the conversion failed */\n+\t  if (!t || !f)\n+\t    goto fail;\n+#endif\n+\n+\t  true_expr = t;\n+\t  false_expr = f;\n+\t}\n+      while (bb != last_test_bb);\n+    }\n+\n   /* For IF-THEN-ELSE blocks, we don't allow modifications of the test\n      on then THEN block.  */\n   then_mod_ok = (else_bb == NULL_BLOCK);\n@@ -424,21 +525,30 @@ cond_exec_process_if_block (test_bb, then_bb, else_bb, join_bb)\n \n   if (then_end\n       && (! false_expr\n-\t  || ! cond_exec_process_insns (then_start, then_end, false_expr,\n-\t\t\t\t\tfalse_prob_val, then_mod_ok)))\n+\t  || ! cond_exec_process_insns (ce_info, then_start, then_end,\n+\t\t\t\t\tfalse_expr, false_prob_val,\n+\t\t\t\t\tthen_mod_ok)))\n     goto fail;\n \n-  if (else_bb\n-      && ! cond_exec_process_insns (else_start, else_end,\n+  if (else_bb && else_end\n+      && ! cond_exec_process_insns (ce_info, else_start, else_end,\n \t\t\t\t    true_expr, true_prob_val, TRUE))\n     goto fail;\n \n+  /* If we cannot apply the changes, fail.  Do not go through the normal fail\n+     processing, since apply_change_group will call cancel_changes.  */\n   if (! apply_change_group ())\n-    return FALSE;\n+    {\n+#ifdef IFCVT_MODIFY_CANCEL\n+      /* Cancel any machine dependent changes.  */\n+      IFCVT_MODIFY_CANCEL (ce_info);\n+#endif\n+      return FALSE;\n+    }\n \n #ifdef IFCVT_MODIFY_FINAL\n   /* Do any machine dependent final modifications */\n-  IFCVT_MODIFY_FINAL (test_bb, then_bb, else_bb, join_bb);\n+  IFCVT_MODIFY_FINAL (ce_info);\n #endif\n \n   /* Conversion succeeded.  */\n@@ -447,13 +557,14 @@ cond_exec_process_if_block (test_bb, then_bb, else_bb, join_bb)\n \t     n_insns, (n_insns == 1) ? \" was\" : \"s were\");\n \n   /* Merge the blocks!  */\n-  merge_if_block (test_bb, then_bb, else_bb, join_bb);\n+  merge_if_block (ce_info);\n+  cond_exec_changed_p = TRUE;\n   return TRUE;\n \n  fail:\n #ifdef IFCVT_MODIFY_CANCEL\n   /* Cancel any machine dependent changes.  */\n-  IFCVT_MODIFY_CANCEL (test_bb, then_bb, else_bb, join_bb);\n+  IFCVT_MODIFY_CANCEL (ce_info);\n #endif\n \n   cancel_changes (0);\n@@ -1587,12 +1698,18 @@ noce_operand_ok (op)\n    successful at converting the the block.  */\n \n static int\n-noce_process_if_block (test_bb, then_bb, else_bb, join_bb)\n-     basic_block test_bb;\t/* Basic block test is in */\n-     basic_block then_bb;\t/* Basic block for THEN block */\n-     basic_block else_bb;\t/* Basic block for ELSE block */\n-     basic_block join_bb;\t/* Basic block the join label is in */\n+noce_process_if_block (ce_info)\n+     struct ce_if_block * ce_info;\n {\n+  basic_block test_bb = ce_info->test_bb;\t/* test block */\n+  basic_block then_bb = ce_info->then_bb;\t/* THEN */\n+  basic_block else_bb = ce_info->else_bb;\t/* ELSE or NULL */\n+  struct noce_if_info if_info;\n+  rtx insn_a, insn_b;\n+  rtx set_a, set_b;\n+  rtx orig_x, x, a, b;\n+  rtx jump, cond, insn;\n+\n   /* We're looking for patterns of the form\n \n      (1) if (...) x = a; else x = b;\n@@ -1603,20 +1720,27 @@ noce_process_if_block (test_bb, then_bb, else_bb, join_bb)\n \n      ??? For future expansion, look for multiple X in such patterns.  */\n \n-  struct noce_if_info if_info;\n-  rtx insn_a, insn_b;\n-  rtx set_a, set_b;\n-  rtx orig_x, x, a, b;\n-  rtx jump, cond, insn;\n+  /* If test is comprised of && or || elements, don't handle it unless it is\n+     the special case of && elements without an ELSE block.  */\n+  if (ce_info->num_multiple_test_blocks)\n+    {\n+      if (else_bb || ! ce_info->and_and_p)\n+\treturn FALSE;\n+\n+      ce_info->test_bb = test_bb = ce_info->last_test_bb;\n+      ce_info->num_multiple_test_blocks = 0;\n+      ce_info->num_and_and_blocks = 0;\n+      ce_info->num_or_or_blocks = 0;\n+    }\n \n   /* If this is not a standard conditional jump, we can't parse it.  */\n   jump = test_bb->end;\n   cond = noce_get_condition (jump, &if_info.cond_earliest);\n   if (! cond)\n     return FALSE;\n \n-  /* If the conditional jump is more than just a conditional jump,\n-     then we can not do if-conversion on this block.  */\n+  /* If the conditional jump is more than just a conditional\n+     jump, then we can not do if-conversion on this block.  */\n   if (! onlyjump_p (jump))\n     return FALSE;\n \n@@ -1627,7 +1751,7 @@ noce_process_if_block (test_bb, then_bb, else_bb, join_bb)\n   /* Look for one of the potential sets.  */\n   insn_a = first_active_insn (then_bb);\n   if (! insn_a\n-      || ! last_active_insn_p (then_bb, insn_a)\n+      || insn_a != last_active_insn (then_bb, FALSE)\n       || (set_a = single_set (insn_a)) == NULL_RTX)\n     return FALSE;\n \n@@ -1646,7 +1770,7 @@ noce_process_if_block (test_bb, then_bb, else_bb, join_bb)\n     {\n       insn_b = first_active_insn (else_bb);\n       if (! insn_b\n-\t  || ! last_active_insn_p (else_bb, insn_b)\n+\t  || insn_b != last_active_insn (else_bb, FALSE)\n \t  || (set_b = single_set (insn_b)) == NULL_RTX\n \t  || ! rtx_equal_p (x, SET_DEST (set_b)))\n \treturn FALSE;\n@@ -1776,7 +1900,7 @@ noce_process_if_block (test_bb, then_bb, else_bb, join_bb)\n   if (insn_b && else_bb)\n     delete_insn (insn_b);\n \n-  /* The new insns will have been inserted just before the jump.  We should\n+  /* The new insns will have been inserted before cond_earliest.  We should\n      be able to remove the jump with impunity, but the condition itself may\n      have been modified by gcse to be shared across basic blocks.  */\n   delete_insn (jump);\n@@ -1793,7 +1917,7 @@ noce_process_if_block (test_bb, then_bb, else_bb, join_bb)\n     }\n \n   /* Merge the blocks!  */\n-  merge_if_block (test_bb, then_bb, else_bb, join_bb);\n+  merge_if_block (ce_info);\n \n   return TRUE;\n }\n@@ -1802,41 +1926,74 @@ noce_process_if_block (test_bb, then_bb, else_bb, join_bb)\n    straight line code.  Return true if successful.  */\n \n static int\n-process_if_block (test_bb, then_bb, else_bb, join_bb)\n-     basic_block test_bb;\t/* Basic block test is in */\n-     basic_block then_bb;\t/* Basic block for THEN block */\n-     basic_block else_bb;\t/* Basic block for ELSE block */\n-     basic_block join_bb;\t/* Basic block the join label is in */\n+process_if_block (ce_info)\n+     struct ce_if_block * ce_info;\n {\n   if (! reload_completed\n-      && noce_process_if_block (test_bb, then_bb, else_bb, join_bb))\n+      && noce_process_if_block (ce_info))\n     return TRUE;\n \n-  if (HAVE_conditional_execution\n-      && reload_completed\n-      && cond_exec_process_if_block (test_bb, then_bb, else_bb, join_bb))\n-    return TRUE;\n+  if (HAVE_conditional_execution && reload_completed)\n+    {\n+      /* If we have && and || tests, try to first handle combining the && and\n+         || tests into the conditional code, and if that fails, go back and\n+         handle it without the && and ||, which at present handles the && case\n+         if there was no ELSE block.  */\n+      if (cond_exec_process_if_block (ce_info, TRUE))\n+\treturn TRUE;\n+\n+      if (ce_info->num_multiple_test_blocks)\n+\t{\n+\t  cancel_changes (0);\n+\n+\t  if (cond_exec_process_if_block (ce_info, FALSE))\n+\t    return TRUE;\n+\t}\n+    }\n \n   return FALSE;\n }\n \n /* Merge the blocks and mark for local life update.  */\n \n static void\n-merge_if_block (test_bb, then_bb, else_bb, join_bb)\n-     basic_block test_bb;\t/* Basic block test is in */\n-     basic_block then_bb;\t/* Basic block for THEN block */\n-     basic_block else_bb;\t/* Basic block for ELSE block */\n-     basic_block join_bb;\t/* Basic block the join label is in */\n+merge_if_block (ce_info)\n+     struct ce_if_block * ce_info;\n {\n+  basic_block test_bb = ce_info->test_bb;\t/* last test block */\n+  basic_block then_bb = ce_info->then_bb;\t/* THEN */\n+  basic_block else_bb = ce_info->else_bb;\t/* ELSE or NULL */\n+  basic_block join_bb = ce_info->join_bb;\t/* join block */\n   basic_block combo_bb;\n \n   /* All block merging is done into the lower block numbers.  */\n \n   combo_bb = test_bb;\n \n-  /* First merge TEST block into THEN block.  This is a no-brainer since\n-     the THEN block did not have a code label to begin with.  */\n+  /* Merge any basic blocks to handle && and || subtests.  Each of\n+     the blocks are on the fallthru path from the predecessor block.  */\n+  if (ce_info->num_multiple_test_blocks > 0)\n+    {\n+      basic_block bb = test_bb;\n+      basic_block last_test_bb = ce_info->last_test_bb;\n+      basic_block fallthru = block_fallthru (bb);\n+      \n+      do\n+\t{\n+\t  bb = fallthru;\n+\t  fallthru = block_fallthru (bb);\n+\t  if (post_dominators)\n+\t    delete_from_dominance_info (post_dominators, bb);\n+\t  merge_blocks_nomove (combo_bb, bb);\n+\t  num_removed_blocks++;\n+\t}\n+      while (bb != last_test_bb);\n+    }\n+\n+  /* Merge TEST block into THEN block.  Normally the THEN block won't have a\n+     label, but it might if there were || tests.  That label's count should be\n+     zero, and it normally should be removed.  */\n+\n   if (then_bb)\n     {\n       if (combo_bb->global_live_at_end)\n@@ -1909,6 +2066,7 @@ merge_if_block (test_bb, then_bb, else_bb, join_bb)\n       if (combo_bb->global_live_at_end)\n \tCOPY_REG_SET (combo_bb->global_live_at_end,\n \t\t      join_bb->global_live_at_end);\n+\n       if (post_dominators)\n \tdelete_from_dominance_info (post_dominators, join_bb);\n       merge_blocks_nomove (combo_bb, join_bb);\n@@ -1926,32 +2084,36 @@ merge_if_block (test_bb, then_bb, else_bb, join_bb)\n \n       /* Remove the jump and cruft from the end of the COMBO block.  */\n       if (join_bb != EXIT_BLOCK_PTR)\n-        tidy_fallthru_edge (combo_bb->succ, combo_bb, join_bb);\n+\ttidy_fallthru_edge (combo_bb->succ, combo_bb, join_bb);\n     }\n \n   num_updated_if_blocks++;\n }\n \f\n-/* Find a block ending in a simple IF condition.  Return TRUE if\n-   we were able to transform it in some way.  */\n+/* Find a block ending in a simple IF condition and try to transform it\n+   in some way.  When converting a multi-block condition, put the new code\n+   in the first such block and delete the rest.  Return a pointer to this\n+   first block if some transformation was done.  Return NULL otherwise.  */\n \n-static int\n-find_if_header (test_bb)\n+static basic_block\n+find_if_header (test_bb, pass)\n      basic_block test_bb;\n+     int pass;\n {\n+  ce_if_block_t ce_info;\n   edge then_edge;\n   edge else_edge;\n \n   /* The kind of block we're looking for has exactly two successors.  */\n   if ((then_edge = test_bb->succ) == NULL_EDGE\n       || (else_edge = then_edge->succ_next) == NULL_EDGE\n       || else_edge->succ_next != NULL_EDGE)\n-    return FALSE;\n+    return NULL;\n \n   /* Neither edge should be abnormal.  */\n   if ((then_edge->flags & EDGE_COMPLEX)\n       || (else_edge->flags & EDGE_COMPLEX))\n-    return FALSE;\n+    return NULL;\n \n   /* The THEN edge is canonically the one that falls through.  */\n   if (then_edge->flags & EDGE_FALLTHRU)\n@@ -1964,13 +2126,25 @@ find_if_header (test_bb)\n     }\n   else\n     /* Otherwise this must be a multiway branch of some sort.  */\n-    return FALSE;\n+    return NULL;\n+\n+  memset ((PTR) &ce_info, '\\0', sizeof (ce_info));\n+  ce_info.test_bb = test_bb;\n+  ce_info.then_bb = then_edge->dest;\n+  ce_info.else_bb = else_edge->dest;\n+  ce_info.pass = pass;\n \n-  if (find_if_block (test_bb, then_edge, else_edge))\n+#ifdef IFCVT_INIT_EXTRA_FIELDS\n+  IFCVT_INIT_EXTRA_FIELDS (&ce_info);\n+#endif\n+\n+  if (find_if_block (&ce_info))\n     goto success;\n+\n   if (HAVE_trap && HAVE_conditional_trap\n       && find_cond_trap (test_bb, then_edge, else_edge))\n     goto success;\n+\n   if (post_dominators\n       && (! HAVE_conditional_execution || reload_completed))\n     {\n@@ -1980,32 +2154,190 @@ find_if_header (test_bb)\n \tgoto success;\n     }\n \n-  return FALSE;\n+  return NULL;\n \n  success:\n   if (rtl_dump_file)\n-    fprintf (rtl_dump_file, \"Conversion succeeded.\\n\");\n-  return TRUE;\n+    fprintf (rtl_dump_file, \"Conversion succeeded on pass %d.\\n\", pass);\n+  return ce_info.test_bb;\n+}\n+\n+/* Return true if a block has two edges, one of which falls through to the next\n+   block, and the other jumps to a specific block, so that we can tell if the\n+   block is part of an && test or an || test.  Returns either -1 or the number\n+   of non-note, non-jump, non-USE/CLOBBER insns in the block.  */\n+\n+static int\n+block_jumps_and_fallthru_p (cur_bb, target_bb)\n+     basic_block cur_bb;\n+     basic_block target_bb;\n+{\n+  edge cur_edge;\n+  int fallthru_p = FALSE;\n+  int jump_p = FALSE;\n+  rtx insn;\n+  rtx end;\n+  int n_insns = 0;\n+\n+  if (!cur_bb || !target_bb)\n+    return -1;\n+\n+  /* If no edges, obviously it doesn't jump or fallthru.  */\n+  if (cur_bb->succ == NULL_EDGE)\n+    return FALSE;\n+\n+  for (cur_edge = cur_bb->succ;\n+       cur_edge != NULL_EDGE;\n+       cur_edge = cur_edge->succ_next)\n+    {\n+      if (cur_edge->flags & EDGE_COMPLEX)\n+\t/* Anything complex isn't what we want.  */\n+\treturn -1;\n+\n+      else if (cur_edge->flags & EDGE_FALLTHRU)\n+\tfallthru_p = TRUE;\n+\n+      else if (cur_edge->dest == target_bb)\n+\tjump_p = TRUE;\n+\n+      else\n+\treturn -1;\n+    }\n+\n+  if ((jump_p & fallthru_p) == 0)\n+    return -1;\n+\n+  /* Don't allow calls in the block, since this is used to group && and ||\n+     together for conditional execution support.  ??? we should support\n+     conditional execution support across calls for IA-64 some day, but\n+     for now it makes the code simpler.  */\n+  end = cur_bb->end;\n+  insn = cur_bb->head;\n+\n+  while (insn != NULL_RTX)\n+    {\n+      if (GET_CODE (insn) == CALL_INSN)\n+\treturn -1;\n+\n+      if (INSN_P (insn)\n+\t  && GET_CODE (insn) != JUMP_INSN\n+\t  && GET_CODE (PATTERN (insn)) != USE\n+\t  && GET_CODE (PATTERN (insn)) != CLOBBER)\n+\tn_insns++;\n+\n+      if (insn == end)\n+\tbreak;\n+\n+      insn = NEXT_INSN (insn);\n+    }\n+\n+  return n_insns;\n }\n \n /* Determine if a given basic block heads a simple IF-THEN or IF-THEN-ELSE\n    block.  If so, we'll try to convert the insns to not require the branch.\n    Return TRUE if we were successful at converting the the block.  */\n \n static int\n-find_if_block (test_bb, then_edge, else_edge)\n-      basic_block test_bb;\n-      edge then_edge, else_edge;\n+find_if_block (ce_info)\n+     struct ce_if_block * ce_info;\n {\n-  basic_block then_bb = then_edge->dest;\n-  basic_block else_bb = else_edge->dest;\n+  basic_block test_bb = ce_info->test_bb;\n+  basic_block then_bb = ce_info->then_bb;\n+  basic_block else_bb = ce_info->else_bb;\n   basic_block join_bb = NULL_BLOCK;\n   edge then_succ = then_bb->succ;\n   edge else_succ = else_bb->succ;\n+  int then_predecessors;\n+  int else_predecessors;\n+  edge cur_edge;\n   basic_block next;\n \n-  /* The THEN block of an IF-THEN combo must have exactly one predecessor.  */\n-  if (then_bb->pred->pred_next != NULL_EDGE)\n+  ce_info->last_test_bb = test_bb;\n+\n+  /* Discover if any fall through predecessors of the current test basic block\n+     were && tests (which jump to the else block) or || tests (which jump to\n+     the then block).  */\n+  if (HAVE_conditional_execution && reload_completed\n+      && test_bb->pred != NULL_EDGE\n+      && test_bb->pred->pred_next == NULL_EDGE\n+      && test_bb->pred->flags == EDGE_FALLTHRU)\n+    {\n+      basic_block bb = test_bb->pred->src;\n+      basic_block target_bb;\n+      int max_insns = MAX_CONDITIONAL_EXECUTE;\n+      int n_insns;\n+\n+      /* Determine if the preceeding block is an && or || block.  */\n+      if ((n_insns = block_jumps_and_fallthru_p (bb, else_bb)) >= 0)\n+\t{\n+\t  ce_info->and_and_p = TRUE;\n+\t  target_bb = else_bb;\n+\t}\n+      else if ((n_insns = block_jumps_and_fallthru_p (bb, then_bb)) >= 0)\n+\t{\n+\t  ce_info->and_and_p = FALSE;\t  \n+\t  target_bb = then_bb;\n+\t}\n+      else\n+\ttarget_bb = NULL_BLOCK;\n+\n+      if (target_bb && n_insns <= max_insns)\n+\t{\n+\t  int total_insns = 0;\n+\t  int blocks = 0;\n+\n+\t  ce_info->last_test_bb = test_bb;\n+\n+\t  /* Found at least one && or || block, look for more.  */\n+\t  do\n+\t    {\n+\t      ce_info->test_bb = test_bb = bb;\n+\t      total_insns += n_insns;\n+\t      blocks++;\n+\n+\t      if (bb->pred == NULL_EDGE || bb->pred->pred_next != NULL_EDGE)\n+\t\tbreak;\n+\n+\t      bb = bb->pred->src;\n+\t      n_insns = block_jumps_and_fallthru_p (bb, target_bb);\n+\t    }\n+\t  while (n_insns >= 0 && (total_insns + n_insns) <= max_insns);\n+\n+\t  ce_info->num_multiple_test_blocks = blocks;\n+\t  ce_info->num_multiple_test_insns = total_insns;\n+\n+\t  if (ce_info->and_and_p)\n+\t    ce_info->num_and_and_blocks = blocks;\n+\t  else\n+\t    ce_info->num_or_or_blocks = blocks;\n+\t}\n+    }\n+\n+  /* Count the number of edges the THEN and ELSE blocks have.  */\n+  then_predecessors = 0;\n+  for (cur_edge = then_bb->pred;\n+       cur_edge != NULL_EDGE;\n+       cur_edge = cur_edge->pred_next)\n+    {\n+      then_predecessors++;\n+      if (cur_edge->flags & EDGE_COMPLEX)\n+\treturn FALSE;\n+    }\n+\n+  else_predecessors = 0;\n+  for (cur_edge = else_bb->pred;\n+       cur_edge != NULL_EDGE;\n+       cur_edge = cur_edge->pred_next)\n+    {\n+      else_predecessors++;\n+      if (cur_edge->flags & EDGE_COMPLEX)\n+\treturn FALSE;\n+    }\n+\n+  /* The THEN block of an IF-THEN combo must have exactly one predecessor,\n+     other than any || blocks which jump to the THEN block.  */\n+  if ((then_predecessors - ce_info->num_or_or_blocks) != 1)\n     return FALSE;\n \n   /* The THEN block of an IF-THEN combo must have zero or one successors.  */\n@@ -2019,7 +2351,7 @@ find_if_block (test_bb, then_edge, else_edge)\n      only one incoming edge -- the CFG manipulation is too ugly otherwise.\n      Check for the last insn of the THEN block being an indirect jump, which\n      is listed as not having any successors, but confuses the rest of the CE\n-     code processing.  XXX we should fix this in the future.  */\n+     code processing.  ??? we should fix this in the future.  */\n   if (then_succ == NULL)\n     {\n       if (else_bb->pred->pred_next == NULL_EDGE)\n@@ -2069,20 +2401,37 @@ find_if_block (test_bb, then_edge, else_edge)\n \n   if (rtl_dump_file)\n     {\n-      if (else_bb)\n-\tfprintf (rtl_dump_file,\n-\t\t \"\\nIF-THEN-ELSE block found, start %d, then %d, else %d, join %d\\n\",\n-\t\t test_bb->index, then_bb->index, else_bb->index,\n-\t\t join_bb->index);\n-      else\n-\tfprintf (rtl_dump_file,\n-\t\t \"\\nIF-THEN block found, start %d, then %d, join %d\\n\",\n-\t\t test_bb->index, then_bb->index, join_bb->index);\n-    }\n+      fprintf (rtl_dump_file, \"\\nIF-THEN%s block found, pass %d, start block %d [insn %d], then %d [%d]\",\n+\t       (else_bb) ? \"-ELSE\" : \"\",\n+\t       ce_info->pass,\n+\t       test_bb->index, (test_bb->head) ? (int)INSN_UID (test_bb->head) : -1,\n+\t       then_bb->index, (then_bb->head) ? (int)INSN_UID (then_bb->head) : -1);\n \n-  /* Make sure IF, THEN, and ELSE, blocks are adjacent.  Actually, we\n-     get the first condition for free, since we've already asserted that\n-     there's a fallthru edge from IF to THEN.  */\n+      if (else_bb)\n+\tfprintf (rtl_dump_file, \", else %d [%d]\",\n+\t\t else_bb->index, (else_bb->head) ? (int)INSN_UID (else_bb->head) : -1);\n+\n+      fprintf (rtl_dump_file, \", join %d [%d]\",\n+\t       join_bb->index, (join_bb->head) ? (int)INSN_UID (join_bb->head) : -1);\n+\n+      if (ce_info->num_multiple_test_blocks > 0)\n+\tfprintf (rtl_dump_file, \", %d %s block%s last test %d [%d]\",\n+\t\t ce_info->num_multiple_test_blocks,\n+\t\t (ce_info->and_and_p) ? \"&&\" : \"||\",\n+\t\t (ce_info->num_multiple_test_blocks == 1) ? \"\" : \"s\",\n+\t\t ce_info->last_test_bb->index,\n+\t\t ((ce_info->last_test_bb->head)\n+\t\t  ? (int)INSN_UID (ce_info->last_test_bb->head)\n+\t\t  : -1));\n+\n+      fputc ('\\n', rtl_dump_file);\n+    }\n+\n+  /* Make sure IF, THEN, and ELSE, blocks are adjacent.  Actually, we get the\n+     first condition for free, since we've already asserted that there's a\n+     fallthru edge from IF to THEN.  Likewise for the && and || blocks, since\n+     we checked the FALLTHRU flag, those are already adjacent to the last IF\n+     block.  */\n   /* ??? As an enhancement, move the ELSE block.  Have to deal with\n      BLOCK notes, if by no other means than aborting the merge if they\n      exist.  Sticky enough I don't want to think about it now.  */\n@@ -2098,24 +2447,26 @@ find_if_block (test_bb, then_edge, else_edge)\n     }\n \n   /* Do the real work.  */\n-  return process_if_block (test_bb, then_bb, else_bb, join_bb);\n+  ce_info->else_bb = else_bb;\n+  ce_info->join_bb = join_bb;\n+\n+  return process_if_block (ce_info);\n }\n \n-/* Convert a branch over a trap, or a branch to a trap,\n-   into a conditional trap.  */\n+/* Convert a branch over a trap, or a branch\n+   to a trap, into a conditional trap.  */\n \n static int\n find_cond_trap (test_bb, then_edge, else_edge)\n      basic_block test_bb;\n      edge then_edge, else_edge;\n {\n-  basic_block then_bb, else_bb, trap_bb, other_bb;\n+  basic_block then_bb = then_edge->dest;\n+  basic_block else_bb = else_edge->dest;\n+  basic_block other_bb, trap_bb;\n   rtx trap, jump, cond, cond_earliest, seq;\n   enum rtx_code code;\n \n-  then_bb = then_edge->dest;\n-  else_bb = else_edge->dest;\n-\n   /* Locate the block with the trap instruction.  */\n   /* ??? While we look for no successors, we really ought to allow\n      EH successors.  Need to fix merge_if_block for that to work.  */\n@@ -2138,8 +2489,8 @@ find_cond_trap (test_bb, then_edge, else_edge)\n   if (! cond)\n     return FALSE;\n \n-  /* If the conditional jump is more than just a conditional jump,\n-     then we can not do if-conversion on this block.  */\n+  /* If the conditional jump is more than just a conditional jump, then\n+     we can not do if-conversion on this block.  */\n   if (! onlyjump_p (jump))\n     return FALSE;\n \n@@ -2179,8 +2530,14 @@ find_cond_trap (test_bb, then_edge, else_edge)\n      Otherwise we must insert a direct branch.  */\n   if (test_bb->next_bb == other_bb)\n     {\n+      struct ce_if_block new_ce_info;\n       delete_insn (jump);\n-      merge_if_block (test_bb, NULL, NULL, other_bb);\n+      memset ((PTR) &new_ce_info, '\\0', sizeof (new_ce_info));\n+      new_ce_info.test_bb = test_bb;\n+      new_ce_info.then_bb = NULL;\n+      new_ce_info.else_bb = NULL;\n+      new_ce_info.join_bb = other_bb;\n+      merge_if_block (&new_ce_info);\n     }\n   else\n     {\n@@ -2355,6 +2712,7 @@ find_if_case_1 (test_bb, then_edge, else_edge)\n   if (post_dominators)\n     delete_from_dominance_info (post_dominators, then_bb);\n   flow_delete_block (then_bb);\n+\n   /* Make rest of code believe that the newly created block is the THEN_BB\n      block we removed.  */\n   if (new_bb)\n@@ -2531,7 +2889,8 @@ dead_or_predicable (test_bb, merge_bb, other_bb, new_dest, reversep)\n \t    prob_val = GEN_INT (REG_BR_PROB_BASE - INTVAL (prob_val));\n \t}\n \n-      if (! cond_exec_process_insns (head, end, cond, prob_val, 0))\n+      if (! cond_exec_process_insns ((ce_if_block_t *)0, head, end, cond,\n+\t\t\t\t     prob_val, 0))\n \tgoto cancel;\n \n       earliest = jump;\n@@ -2726,13 +3085,14 @@ if_convert (x_life_data_ok)\n      int x_life_data_ok;\n {\n   basic_block bb;\n+  int pass;\n \n   num_possible_if_blocks = 0;\n   num_updated_if_blocks = 0;\n   num_removed_blocks = 0;\n   life_data_ok = (x_life_data_ok != 0);\n \n-  /* Free up basic_block_for_insn so that we don't have to keep it \n+  /* Free up basic_block_for_insn so that we don't have to keep it\n      up to date, either here or in merge_blocks_nomove.  */\n   free_basic_block_vars (1);\n \n@@ -2745,10 +3105,38 @@ if_convert (x_life_data_ok)\n   if (life_data_ok)\n     clear_bb_flags ();\n \n-  /* Go through each of the basic blocks looking for things to convert.  */\n-  FOR_EACH_BB (bb)\n-    while (find_if_header (bb))\n-      continue;\n+  /* Go through each of the basic blocks looking for things to convert.  If we\n+     have conditional execution, we make multiple passes to allow us to handle\n+     IF-THEN{-ELSE} blocks within other IF-THEN{-ELSE} blocks.  */\n+  pass = 0;\n+  do\n+    {\n+      cond_exec_changed_p = FALSE;\n+      pass++;\n+\n+#ifdef IFCVT_MULTIPLE_DUMPS\n+      if (rtl_dump_file && pass > 1)\n+\tfprintf (rtl_dump_file, \"\\n\\n========== Pass %d ==========\\n\", pass);\n+#endif\n+\n+      FOR_EACH_BB (bb)\n+\t{\n+\t  basic_block new_bb = find_if_header (bb, pass);\n+\t  if (new_bb)\n+\t    bb = new_bb;\n+\t}\n+\n+#ifdef IFCVT_MULTIPLE_DUMPS\n+      if (rtl_dump_file && cond_exec_changed_p)\n+\tprint_rtl_with_bb (rtl_dump_file, get_insns ());\n+#endif\n+    }\n+  while (cond_exec_changed_p);\n+\n+#ifdef IFCVT_MULTIPLE_DUMPS\n+  if (rtl_dump_file)\n+    fprintf (rtl_dump_file, \"\\n\\n========== no more changes\\n\");\n+#endif\n \n   if (post_dominators)\n     free_dominance_info (post_dominators);"}]}