{"sha": "ada353b87909fd6cd37a30083b4fdcb76acbf5fe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWRhMzUzYjg3OTA5ZmQ2Y2QzN2EzMDA4M2I0ZmRjYjc2YWNiZjVmZQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-09-26T08:43:57Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-09-26T08:43:57Z"}, "message": "Implement iterative dataflow in mod-ref\n\ncc1plus stats are now:\n\nAlias oracle query stats:\n  refs_may_alias_p: 62971744 disambiguations, 73160711 queries\n  ref_maybe_used_by_call_p: 141176 disambiguations, 63867883 queries\n  call_may_clobber_ref_p: 23573 disambiguations, 29322 queries\n  nonoverlapping_component_refs_p: 0 disambiguations, 37720 queries\n  nonoverlapping_refs_since_match_p: 19432 disambiguations, 55659 must overlaps, 75860 queries\n  aliasing_component_refs_p: 54724 disambiguations, 753570 queries\n  TBAA oracle: 24124230 disambiguations 56228428 queries\n               16058141 are in alias set 0\n               10338303 queries asked about the same object\n               125 queries asked about the same alias set\n               0 access volatile\n               3919230 are dependent in the DAG\n               1788399 are aritificially in conflict with void *\n\nModref stats:\n  modref use: 10408 disambiguations, 46993 queries\n  modref clobber: 1418549 disambiguations, 1951251 queries\n  4898707 tbaa queries (2.510547 per modref query)\n  396878 base compares (0.203397 per modref query)\n\nPTA query stats:\n  pt_solution_includes: 975364 disambiguations, 13604284 queries\n  pt_solutions_intersect: 1026606 disambiguations, 13181198 queries\n\nSo compared to\nhttps://gcc.gnu.org/pipermail/gcc-patches/2020-September/554692.html we get 25%\nuse disambiguations and 91% more clobber disambiguations.\n\nTramp3d is\n\nAlias oracle query stats:\n  refs_may_alias_p: 2056905 disambiguations, 2317461 queries\n  ref_maybe_used_by_call_p: 7137 disambiguations, 2093762 queries\n  call_may_clobber_ref_p: 234 disambiguations, 234 queries\n  nonoverlapping_component_refs_p: 0 disambiguations, 4313 queries\n  nonoverlapping_refs_since_match_p: 329 disambiguations, 10200 must overlaps, 10616 queries\n  aliasing_component_refs_p: 858 disambiguations, 34600 queries\n  TBAA oracle: 894996 disambiguations 1695991 queries\n               138346 are in alias set 0\n               470668 queries asked about the same object\n               0 queries asked about the same alias set\n               0 access volatile\n               191666 are dependent in the DAG\n               315 are aritificially in conflict with void *\n\nModref stats:\n  modref use: 842 disambiguations, 2265 queries\n  modref clobber: 14833 disambiguations, 28900 queries\n  34884 tbaa queries (1.207059 per modref query)\n  5041 base compares (0.174429 per modref query)\n\nPTA query stats:\n  pt_solution_includes: 313372 disambiguations, 525724 queries\n  pt_solutions_intersect: 130374 disambiguations, 415138 queries\n\nSo about twice many use and 40% clobber disambiguations.\n\nBootstrapped/regtested x86_64-linux, I plan to commit it later today after\nmore testing.\n\n2020-09-26  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* ipa-inline-transform.c: Include ipa-modref-tree.h and ipa-modref.h.\n\t(inline_call): Call ipa_merge_modref_summary_after_inlining.\n\t* ipa-inline.c (ipa_inline): Do not free summaries.\n\t* ipa-modref.c (dump_records): Fix formating.\n\t(merge_call_side_effects): Break out from ...\n\t(analyze_call): ... here; record recursive calls.\n\t(analyze_stmt): Add new parameter RECURSIVE_CALLS.\n\t(analyze_function): Do iterative dataflow on recursive calls.\n\t(compute_parm_map): New function.\n\t(ipa_merge_modref_summary_after_inlining): New function.\n\t(collapse_loads): New function.\n\t(modref_propagate_in_scc): Break out from ...\n\t(pass_ipa_modref::execute): ... here; Do iterative dataflow.\n\t* ipa-modref.h (ipa_merge_modref_summary_after_inlining): Declare.", "tree": {"sha": "ff2ec46538de621c079b2de5c1aaa83b3451d672", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff2ec46538de621c079b2de5c1aaa83b3451d672"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ada353b87909fd6cd37a30083b4fdcb76acbf5fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ada353b87909fd6cd37a30083b4fdcb76acbf5fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ada353b87909fd6cd37a30083b4fdcb76acbf5fe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ada353b87909fd6cd37a30083b4fdcb76acbf5fe/comments", "author": null, "committer": null, "parents": [{"sha": "a29bd4f59e9eebf52ac41f7d7a6fa83cf2aae09d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a29bd4f59e9eebf52ac41f7d7a6fa83cf2aae09d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a29bd4f59e9eebf52ac41f7d7a6fa83cf2aae09d"}], "stats": {"total": 578, "additions": 373, "deletions": 205}, "files": [{"sha": "af2c2856aaac7bbb11a4a1968aad4e1a5e8d4c3d", "filename": "gcc/ipa-inline-transform.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ada353b87909fd6cd37a30083b4fdcb76acbf5fe/gcc%2Fipa-inline-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ada353b87909fd6cd37a30083b4fdcb76acbf5fe/gcc%2Fipa-inline-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-transform.c?ref=ada353b87909fd6cd37a30083b4fdcb76acbf5fe", "patch": "@@ -48,6 +48,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cfg.h\"\n #include \"basic-block.h\"\n #include \"ipa-utils.h\"\n+#include \"ipa-modref-tree.h\"\n+#include \"ipa-modref.h\"\n \n int ncalls_inlined;\n int nfunctions_inlined;\n@@ -487,6 +489,7 @@ inline_call (struct cgraph_edge *e, bool update_original,\n   gcc_assert (curr->callee->inlined_to == to);\n \n   old_size = ipa_size_summaries->get (to)->size;\n+  ipa_merge_modref_summary_after_inlining (e);\n   ipa_merge_fn_summary_after_inlining (e);\n   if (e->in_polymorphic_cdtor)\n     mark_all_inlined_calls_cdtor (e->callee);"}, {"sha": "225a014072508dde55c95f8163b12fe4a74f661f", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ada353b87909fd6cd37a30083b4fdcb76acbf5fe/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ada353b87909fd6cd37a30083b4fdcb76acbf5fe/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=ada353b87909fd6cd37a30083b4fdcb76acbf5fe", "patch": "@@ -2770,9 +2770,6 @@ ipa_inline (void)\n \t}\n     }\n \n-  /* Free ipa-prop structures if they are no longer needed.  */\n-  ipa_free_all_structures_after_iinln ();\n-\n   if (dump_enabled_p ())\n     dump_printf (MSG_NOTE,\n \t\t \"\\nInlined %i calls, eliminated %i functions\\n\\n\","}, {"sha": "73a7900883a5020d49a1162bc672f1237386866b", "filename": "gcc/ipa-modref.c", "status": "modified", "additions": 369, "deletions": 202, "changes": 571, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ada353b87909fd6cd37a30083b4fdcb76acbf5fe/gcc%2Fipa-modref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ada353b87909fd6cd37a30083b4fdcb76acbf5fe/gcc%2Fipa-modref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.c?ref=ada353b87909fd6cd37a30083b4fdcb76acbf5fe", "patch": "@@ -175,7 +175,7 @@ dump_records (modref_records *tt, FILE *out)\n \t  fprintf (out, \"        Ref %i: alias set %i\\n\", (int)j, r->ref);\n \t  if (r->every_access)\n \t    {\n-\t      fprintf (out, \"        Every access\\n\");\n+\t      fprintf (out, \"          Every access\\n\");\n \t      continue;\n \t    }\n \t  size_t k;\n@@ -437,11 +437,70 @@ ignore_stores_p (tree caller, int flags)\n   return false;\n }\n \n-/* Analyze function call STMT in function F.  */\n+/* Merge side effects of call STMT to function with CALLEE_SUMMARY\n+   int CUR_SUMMARY.  Return true if something changed.\n+   If IGNORE_STORES is true, do not merge stores.  */\n+\n+bool\n+merge_call_side_effects (modref_summary *cur_summary,\n+\t\t\t gimple *stmt, modref_summary *callee_summary,\n+\t\t\t bool ignore_stores)\n+{\n+  auto_vec <int, 32> parm_map;\n+  bool changed = false;\n+\n+  parm_map.safe_grow (gimple_call_num_args (stmt));\n+  for (unsigned i = 0; i < gimple_call_num_args (stmt); i++)\n+    {\n+      tree op = gimple_call_arg (stmt, i);\n+      STRIP_NOPS (op);\n+      if (TREE_CODE (op) == SSA_NAME\n+\t  && SSA_NAME_IS_DEFAULT_DEF (op)\n+\t  && TREE_CODE (SSA_NAME_VAR (op)) == PARM_DECL)\n+\t{\n+\t  int index = 0;\n+\t  for (tree t = DECL_ARGUMENTS (current_function_decl);\n+\t       t != SSA_NAME_VAR (op); t = DECL_CHAIN (t))\n+\t    {\n+\t      if (!t)\n+\t\t{\n+\t\t  index = -1;\n+\t\t  break;\n+\t\t}\n+\t      index++;\n+\t    }\n+\t  parm_map[i] = index;\n+\t}\n+      else if (points_to_local_or_readonly_memory_p (op))\n+\tparm_map[i] = -2;\n+      else\n+\tparm_map[i] = -1;\n+    }\n+\n+  /* Merge with callee's summary.  */\n+  if (cur_summary->loads)\n+    changed |= cur_summary->loads->merge (callee_summary->loads, &parm_map);\n+  if (cur_summary->loads_lto)\n+    changed |= cur_summary->loads_lto->merge (callee_summary->loads_lto,\n+\t\t\t\t\t      &parm_map);\n+  if (!ignore_stores)\n+    {\n+      if (cur_summary->stores)\n+\tchanged |= cur_summary->stores->merge (callee_summary->stores,\n+\t\t\t\t\t       &parm_map);\n+      if (cur_summary->stores_lto)\n+\tchanged |= cur_summary->stores_lto->merge (callee_summary->stores_lto,\n+\t\t\t\t\t\t   &parm_map);\n+    }\n+  return changed;\n+}\n+\n+/* Analyze function call STMT in function F.\n+   Remember recursive calls in RECURSIVE_CALLS.  */\n \n static bool\n analyze_call (modref_summary *cur_summary,\n-\t      gimple *stmt)\n+\t      gimple *stmt, vec <gimple *> *recursive_calls)\n {\n   /* Check flags on the function call.  In certain cases, analysis can be\n      simplified.  */\n@@ -505,6 +564,7 @@ analyze_call (modref_summary *cur_summary,\n      there's nothing to do.  */\n   if (recursive_call_p (current_function_decl, callee))\n     {\n+      recursive_calls->safe_push (stmt);\n       if (dump_file)\n \tfprintf (dump_file, \" - Skipping recursive call.\\n\");\n       return true;\n@@ -550,48 +610,7 @@ analyze_call (modref_summary *cur_summary,\n       return false;\n     }\n \n-  auto_vec <int, 32> parm_map;\n-\n-  parm_map.safe_grow (gimple_call_num_args (stmt));\n-  for (unsigned i = 0; i < gimple_call_num_args (stmt); i++)\n-    {\n-      tree op = gimple_call_arg (stmt, i);\n-      STRIP_NOPS (op);\n-      if (TREE_CODE (op) == SSA_NAME\n-\t  && SSA_NAME_IS_DEFAULT_DEF (op)\n-\t  && TREE_CODE (SSA_NAME_VAR (op)) == PARM_DECL)\n-\t{\n-\t  int index = 0;\n-\t  for (tree t = DECL_ARGUMENTS (current_function_decl);\n-\t       t != SSA_NAME_VAR (op); t = DECL_CHAIN (t))\n-\t    {\n-\t      if (!t)\n-\t\t{\n-\t\t  index = -1;\n-\t\t  break;\n-\t\t}\n-\t      index++;\n-\t    }\n-\t  parm_map[i] = index;\n-\t}\n-      else if (points_to_local_or_readonly_memory_p (op))\n-\tparm_map[i] = -2;\n-      else\n-\tparm_map[i] = -1;\n-    }\n-\n-  /* Merge with callee's summary.  */\n-  if (cur_summary->loads)\n-    cur_summary->loads->merge (callee_summary->loads, &parm_map);\n-  if (cur_summary->loads_lto)\n-    cur_summary->loads_lto->merge (callee_summary->loads_lto, &parm_map);\n-  if (!ignore_stores)\n-    {\n-      if (cur_summary->stores)\n-\tcur_summary->stores->merge (callee_summary->stores, &parm_map);\n-      if (cur_summary->stores_lto)\n-\tcur_summary->stores_lto->merge (callee_summary->stores_lto, &parm_map);\n-    }\n+  merge_call_side_effects (cur_summary, stmt, callee_summary, ignore_stores);\n \n   return true;\n }\n@@ -654,7 +673,8 @@ analyze_store (gimple *, tree, tree op, void *data)\n    If IPA is true do not merge in side effects of calls.  */\n \n static bool\n-analyze_stmt (modref_summary *summary, gimple *stmt, bool ipa)\n+analyze_stmt (modref_summary *summary, gimple *stmt, bool ipa,\n+\t      vec <gimple *> *recursive_calls)\n {\n   /* There is no need to record clobbers.  */\n   if (gimple_clobber_p (stmt))\n@@ -677,7 +697,7 @@ analyze_stmt (modref_summary *summary, gimple *stmt, bool ipa)\n      return false;\n    case GIMPLE_CALL:\n      if (!ipa)\n-       return analyze_call (summary, stmt);\n+       return analyze_call (summary, stmt, recursive_calls);\n      return true;\n    default:\n      /* Nothing to do for other types of statements.  */\n@@ -750,6 +770,7 @@ analyze_function (function *f, bool ipa)\n     }\n   summary->finished = false;\n   int ecf_flags = flags_from_decl_or_type (current_function_decl);\n+  auto_vec <gimple *, 32> recursive_calls;\n \n   /* Analyze each statement in each basic block of the function.  If the\n      statement cannot be analyzed (for any reason), the entire function cannot\n@@ -760,7 +781,7 @@ analyze_function (function *f, bool ipa)\n       gimple_stmt_iterator si;\n       for (si = gsi_after_labels (bb); !gsi_end_p (si); gsi_next (&si))\n \t{\n-\t  if (!analyze_stmt (summary, gsi_stmt (si), ipa)\n+\t  if (!analyze_stmt (summary, gsi_stmt (si), ipa, &recursive_calls)\n \t      || !summary->useful_p (ecf_flags))\n \t    {\n \t      cgraph_node *fnode = cgraph_node::get (current_function_decl);\n@@ -773,6 +794,34 @@ analyze_function (function *f, bool ipa)\n \t}\n     }\n \n+  /* In non-IPA mode we need to perform iterative datafow on recursive calls.\n+     This needs to be done after all other side effects are computed.  */\n+  if (!ipa)\n+    {\n+      bool changed = true;\n+      while (changed)\n+\t{\n+\t  changed = false;\n+\t  for (unsigned i = 0; i < recursive_calls.length (); i++)\n+\t    {\n+\t      changed |= merge_call_side_effects\n+\t\t\t  (summary, recursive_calls[i], summary,\n+\t\t\t   ignore_stores_p (current_function_decl,\n+\t\t\t\t\t    gimple_call_flags\n+\t\t\t\t\t\t (recursive_calls[i])));\n+\t      if (!summary->useful_p (ecf_flags))\n+\t\t{\n+\t\t  cgraph_node *fnode = cgraph_node::get (current_function_decl);\n+\t\t  summaries->remove (fnode);\n+\t\t  if (dump_file)\n+\t\t    fprintf (dump_file,\n+\t\t\t     \" - modref done with result: not tracked.\\n\");\n+\t\t  return;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n   if (!ipa)\n     summary->finished = true;\n \n@@ -1276,71 +1325,176 @@ ignore_edge (struct cgraph_edge *e)\n \t     & (ECF_CONST | ECF_NOVOPS));\n }\n \n-/* Run the IPA pass.  This will take a function's summaries and calls and\n-   construct new summaries which represent a transitive closure.  So that\n-   summary of an analyzed function contains information about the loads and\n-   stores that the function or any function that it calls does.  */\n+/* Compute parm_map for CALLE_EDGE.  */\n \n-unsigned int pass_ipa_modref::execute (function *)\n+static void\n+compute_parm_map (cgraph_edge *callee_edge, vec<int> *parm_map)\n+{\n+  class ipa_edge_args *args;\n+  if (ipa_node_params_sum\n+      && !callee_edge->call_stmt_cannot_inline_p\n+      && (args = IPA_EDGE_REF (callee_edge)) != NULL)\n+    {\n+      int i, count = ipa_get_cs_argument_count (args);\n+      class ipa_node_params *caller_parms_info, *callee_pi;\n+      class ipa_call_summary *es\n+\t     = ipa_call_summaries->get (callee_edge);\n+      cgraph_node *callee\n+\t = callee_edge->callee->function_or_virtual_thunk_symbol\n+\t\t\t      (NULL, callee_edge->caller);\n+\n+      caller_parms_info = IPA_NODE_REF (callee_edge->caller->inlined_to\n+\t\t\t\t\t? callee_edge->caller->inlined_to\n+\t\t\t\t\t: callee_edge->caller);\n+      callee_pi = IPA_NODE_REF (callee);\n+\n+      (*parm_map).safe_grow (count);\n+\n+      for (i = 0; i < count; i++)\n+\t{\n+\t  if (es && es->param[i].points_to_local_or_readonly_memory)\n+\t    {\n+\t      (*parm_map)[i] = -2;\n+\t      continue;\n+\t    }\n+\n+\t  struct ipa_jump_func *jf\n+\t     = ipa_get_ith_jump_func (args, i);\n+\t  if (jf)\n+\t    {\n+\t      tree cst = ipa_value_from_jfunc (caller_parms_info,\n+\t\t\t\t\t       jf,\n+\t\t\t\t\t       ipa_get_type\n+\t\t\t\t\t\t (callee_pi, i));\n+\t      if (cst && points_to_local_or_readonly_memory_p (cst))\n+\t\t{\n+\t\t  (*parm_map)[i] = -2;\n+\t\t  continue;\n+\t\t}\n+\t    }\n+\t  if (jf && jf->type == IPA_JF_PASS_THROUGH)\n+\t    {\n+\t      (*parm_map)[i]\n+\t\t = ipa_get_jf_pass_through_formal_id (jf);\n+\t      continue;\n+\t    }\n+\t  if (jf && jf->type == IPA_JF_ANCESTOR)\n+\t    (*parm_map)[i] = ipa_get_jf_ancestor_formal_id (jf);\n+\t  else\n+\t    (*parm_map)[i] = -1;\n+\t}\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"  Parm map: \");\n+\t  for (i = 0; i < count; i++)\n+\t    fprintf (dump_file, \" %i\", (*parm_map)[i]);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n+    }\n+}\n+\n+/* Call EDGE was inlined; merge summary from callee to the caller.  */\n+\n+void\n+ipa_merge_modref_summary_after_inlining (cgraph_edge *edge)\n {\n   if (!summaries)\n-    return 0;\n+    return;\n \n-  struct cgraph_node **order = XCNEWVEC (struct cgraph_node *,\n-\t\t\t\t\t symtab->cgraph_count);\n-  int order_pos;\n-  order_pos = ipa_reduced_postorder (order, true, ignore_edge);\n-  int i;\n+  struct cgraph_node *to = (edge->caller->inlined_to\n+\t\t\t    ? edge->caller->inlined_to : edge->caller);\n+  class modref_summary *to_info = summaries->get (to);\n \n-  /* Iterate over all strongly connected components in post-order.  */\n-  for (i = 0; i < order_pos; i++)\n+  if (!to_info)\n+    return;\n+\n+  class modref_summary *callee_info = summaries->get (edge->callee);\n+  int flags = flags_from_decl_or_type (edge->callee->decl);\n+\n+  if (!callee_info)\n     {\n-      bool its_hopeless = false;\n-      modref_records *loads = NULL;\n-      modref_records *stores = NULL;\n-      modref_records_lto *loads_lto = NULL;\n-      modref_records_lto *stores_lto = NULL;\n+      if (ignore_stores_p (edge->callee->decl, flags))\n+\t{\n+\t  if (to_info->loads)\n+\t    to_info->loads->collapse ();\n+\t  if (to_info->loads_lto)\n+\t    to_info->loads_lto->collapse ();\n+\t}\n+      else\n+\t{\n+\t  summaries->remove (to);\n+\t  summaries->remove (edge->callee);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      auto_vec <int, 32> parm_map;\n+\n+      compute_parm_map (edge, &parm_map);\n+\n+      if (to_info->loads)\n+\tto_info->loads->merge (callee_info->loads, &parm_map);\n+      if (to_info->stores)\n+\tto_info->stores->merge (callee_info->stores, &parm_map);\n+      if (to_info->loads_lto)\n+\tto_info->loads_lto->merge (callee_info->loads_lto, &parm_map);\n+      if (to_info->stores_lto)\n+\tto_info->stores_lto->merge (callee_info->stores_lto, &parm_map);\n+    }\n+  if (!to_info->useful_p (flags))\n+    summaries->remove (to);\n+  summaries->remove (edge->callee);\n+  return;\n+}\n \n-      /* Get the component's representative.  That's just any node in the\n-\t component from which we can traverse the entire component.  */\n-      struct cgraph_node *component_node = order[i];\n-      cgraph_node *first = NULL;\n+/* Collapse loads and return true if something changed.  */\n \n-      if (dump_file)\n-\tfprintf (dump_file, \"Start of SCC component\\n\");\n+bool\n+collapse_loads (modref_summary *cur_summary)\n+{\n+  bool changed = false;\n+\n+  if (cur_summary->loads && !cur_summary->loads->every_base)\n+    {\n+      cur_summary->loads->collapse ();\n+      changed = true;\n+    }\n+  if (cur_summary->loads_lto\n+      && !cur_summary->loads_lto->every_base)\n+    {\n+      cur_summary->loads_lto->collapse ();\n+      changed = true;\n+    }\n+  return changed;\n+}\n \n-      /* Walk the component.  CUR is the current node of the component that's\n-\t being processed.  */\n-      for (struct cgraph_node *cur = component_node; cur && !its_hopeless;\n+/* Perform iterative dataflow on SCC component starting in COMPONENT_NODE.  */\n+\n+static void\n+modref_propagate_in_scc (cgraph_node *component_node)\n+{\n+  bool changed = true;\n+  int iteration = 0;\n+\n+  while (changed)\n+    {\n+      changed = false;\n+      for (struct cgraph_node *cur = component_node; cur;\n \t   cur = ((struct ipa_dfs_info *) cur->aux)->next_cycle)\n \t{\n-\t  /* Merge in summaries from CUR.  */\n-\t  modref_summary *cur_summary = summaries->get (cur);\n-\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \"  Processing %s\\n\",\n-\t\t     cur->dump_name ());\n+\t  cgraph_node *node = cur->inlined_to ? cur->inlined_to : cur;\n+\t  modref_summary *cur_summary = summaries->get (node);\n \n-\t  /* We don't know anything about CUR, hence we cannot tell anything\n-\t     about the entire component.  */\n \t  if (!cur_summary)\n-\t    {\n-\t      if (dump_file)\n-\t\tfprintf (dump_file, \"    No summary\\n\");\n-\t      its_hopeless = true;\n-\t      break;\n-\t    }\n+\t    continue;\n+\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"  Processing %s%s%s\\n\",\n+\t\t     cur->dump_name (),\n+\t\t     TREE_READONLY (cur->decl) ? \" (const)\" : \"\",\n+\t\t     DECL_PURE_P (cur->decl) ? \" (pure)\" : \"\");\n \n-\t  /* Summaries are all going to be same, pick first ones and merge\n-\t     everything in.  */\n-\t  if (!first)\n-\t    {\n-\t      first = cur;\n-\t      loads = cur_summary->loads;\n-\t      stores = cur_summary->stores;\n-\t      loads_lto = cur_summary->loads_lto;\n-\t      stores_lto = cur_summary->stores_lto;\n-\t    }\n \t  for (cgraph_edge *e = cur->indirect_calls; e; e = e->next_callee)\n \t    {\n \t      if (e->indirect_info->ecf_flags & (ECF_CONST | ECF_NOVOPS))\n@@ -1350,63 +1504,49 @@ unsigned int pass_ipa_modref::execute (function *)\n \t\t  if (dump_file)\n \t\t    fprintf (dump_file, \"    Indirect call: \"\n \t\t\t     \"collapsing loads\\n\");\n-\t\t  if (loads)\n-\t\t    loads->collapse ();\n-\t\t  if (loads_lto)\n-\t\t    loads_lto->collapse ();\n+\t\t  changed |= collapse_loads (cur_summary);\n \t\t}\n \t      else\n \t\t{\n \t\t  if (dump_file)\n \t\t    fprintf (dump_file, \"    Indirect call: giving up\\n\");\n-\t\t  its_hopeless = true;\n+\t\t  summaries->remove (node);\n+\t\t  changed = true;\n+\t\t  cur_summary = NULL;\n+\t\t  break;\n \t\t}\n \t    }\n \n-\t  /* Walk every function that CUR calls and merge its summary.  */\n+\t  if (!cur_summary)\n+\t    continue;\n+\n \t  for (cgraph_edge *callee_edge = cur->callees; callee_edge;\n \t       callee_edge = callee_edge->next_callee)\n \t    {\n \t      int flags = flags_from_decl_or_type (callee_edge->callee->decl);\n \t      modref_summary *callee_summary;\n \t      struct cgraph_node *callee;\n \n-\t      if (flags & (ECF_CONST | ECF_NOVOPS))\n+\t      if (flags & (ECF_CONST | ECF_NOVOPS)\n+\t\t  || !callee_edge->inline_failed)\n \t\tcontinue;\n \n-\t      if (dump_file)\n-\t\tfprintf (dump_file, \"    Call to %s\\n\",\n-\t\t\t callee_edge->callee->dump_name ());\n-\n-\t      /* We can not safely optimize based on summary of callee if it\n-\t\t does not always bind to current def: it is possible that\n-\t\t memory load was optimized out earlier which may not happen in\n-\t\t the interposed variant.  */\n-\t      if (!callee_edge->binds_to_current_def_p ())\n-\t\t{\n-\t\t  if (loads)\n-\t\t    loads->collapse ();\n-\t\t  if (loads_lto)\n-\t\t    loads_lto->collapse ();\n-\t\t  if (dump_file)\n-\t\t    fprintf (dump_file, \"      May not bind local;\"\n-\t\t\t     \" collapsing loads\\n\");\n-\t\t}\n-\n \t      /* Get the callee and its summary.  */\n \t      enum availability avail;\n \t      callee = callee_edge->callee->function_or_virtual_thunk_symbol\n \t\t\t (&avail, cur);\n \n-\t      /* See if we can derive something from ECF flags.  Be careful on\n-\t\t not skipping calls within the SCC component:  we must merge\n-\t\t all their summaries.\n-\t\t If we switch to iterative dataflow that may be necessary\n-\t\t for future improvements this may go away.  */\n-\t      if (callee->aux\n-\t\t  && ((struct ipa_dfs_info *)cur->aux)->scc_no\n-\t\t     == ((struct ipa_dfs_info *)callee->aux)->scc_no)\n-\t\tflags = 0;\n+\t      /* It is not necessary to re-process calls outside of the\n+\t\t SCC component.  */\n+\t      if (iteration > 0\n+\t\t  && (!callee->aux\n+\t\t      || ((struct ipa_dfs_info *)cur->aux)->scc_no\n+\t\t\t  != ((struct ipa_dfs_info *)callee->aux)->scc_no))\n+\t\tcontinue;\n+\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \"    Call to %s\\n\",\n+\t\t\t callee_edge->callee->dump_name ());\n \n \t      bool ignore_stores = ignore_stores_p (cur->decl, flags);\n \n@@ -1418,101 +1558,128 @@ unsigned int pass_ipa_modref::execute (function *)\n \t\t{\n \t\t  if (!ignore_stores)\n \t\t    {\n-\t\t      its_hopeless = true;\n \t\t      if (dump_file && avail <= AVAIL_INTERPOSABLE)\n \t\t\tfprintf (dump_file, \"      Call target interposable\"\n \t\t\t\t \" or not available\\n\");\n \t\t      else if (dump_file)\n \t\t\tfprintf (dump_file, \"      No call target summary\\n\");\n+\n+\t\t      summaries->remove (node);\n+\t\t      changed = true;\n \t\t      break;\n \t\t    }\n \t\t  else\n \t\t    {\n-\t\t      if (loads)\n-\t\t\tloads->collapse ();\n-\t\t      if (loads_lto)\n-\t\t\tloads_lto->collapse ();\n \t\t      if (dump_file && avail <= AVAIL_INTERPOSABLE)\n \t\t\tfprintf (dump_file, \"      Call target interposable\"\n-\t\t\t\t \"or not available; collapsing loads\\n\");\n+\t\t\t\t \" or not available; collapsing loads\\n\");\n \t\t      else if (dump_file)\n \t\t\tfprintf (dump_file, \"      No call target summary;\"\n \t\t\t\t \" collapsing loads\\n\");\n+\n+\t\t      changed |= collapse_loads (cur_summary);\n \t\t      continue;\n \t\t    }\n \t\t}\n \n+\t      /* We can not safely optimize based on summary of callee if it\n+\t\t does not always bind to current def: it is possible that\n+\t\t memory load was optimized out earlier which may not happen in\n+\t\t the interposed variant.  */\n+\t      if (!callee_edge->binds_to_current_def_p ())\n+\t\t{\n+\t\t  changed |= collapse_loads (cur_summary);\n+\t\t  if (dump_file)\n+\t\t    fprintf (dump_file, \"      May not bind local;\"\n+\t\t\t     \" collapsing loads\\n\");\n+\t\t}\n+\n+\n \t      auto_vec <int, 32> parm_map;\n-\t      /* TODO: compute parm_map.  */\n+\n+\t      compute_parm_map (callee_edge, &parm_map);\n \n \t      /* Merge in callee's information.  */\n-\t      if (callee_summary->loads\n-\t\t  && callee_summary->loads != loads)\n-\t\tloads->merge (callee_summary->loads, &parm_map);\n-\t      if (callee_summary->stores\n-\t\t  && callee_summary->stores != stores)\n-\t\tstores->merge (callee_summary->stores, &parm_map);\n-\t      if (callee_summary->loads_lto\n-\t\t  && callee_summary->loads_lto != loads_lto)\n-\t\tloads_lto->merge (callee_summary->loads_lto, &parm_map);\n-\t      if (callee_summary->stores_lto\n-\t\t  && callee_summary->stores_lto != stores_lto)\n-\t\tstores_lto->merge (callee_summary->stores_lto, &parm_map);\n+\t      if (callee_summary->loads)\n+\t\tchanged |= cur_summary->loads->merge\n+\t\t\t\t(callee_summary->loads, &parm_map);\n+\t      if (callee_summary->stores)\n+\t\tchanged |= cur_summary->stores->merge\n+\t\t\t\t(callee_summary->stores, &parm_map);\n+\t      if (callee_summary->loads_lto)\n+\t\tchanged |= cur_summary->loads_lto->merge\n+\t\t\t\t(callee_summary->loads_lto, &parm_map);\n+\t      if (callee_summary->stores_lto)\n+\t\tchanged |= cur_summary->stores_lto->merge\n+\t\t\t\t(callee_summary->stores_lto, &parm_map);\n+\t      if (dump_file && changed)\n+\t\tcur_summary->dump (dump_file);\n \t    }\n \t}\n-\n-\t/* At this time, ipa_loads and ipa_stores contain information\n-\t   about all loads and stores done by any of the component's nodes and\n-\t   all functions that any of the nodes calls.  We will now propagate\n-\t   this information to all nodes in the component.  Therefore, we will\n-\t   walk the component one more time to do it.  */\n-\tfor (struct cgraph_node *cur = component_node; cur;\n+      iteration++;\n+    }\n+  for (struct cgraph_node *cur = component_node; cur;\n+       cur = ((struct ipa_dfs_info *) cur->aux)->next_cycle)\n+    {\n+      modref_summary *cur_summary = summaries->get (cur);\n+      if (cur_summary)\n+\tcur_summary->finished = true;\n+    }\n+  if (dump_file)\n+    {\n+      fprintf (dump_file,\n+\t       \"Propagation finished in %i iterations\\n\", iteration);\n+      for (struct cgraph_node *cur = component_node; cur;\n \t   cur = ((struct ipa_dfs_info *) cur->aux)->next_cycle)\n-\t{\n-\t  modref_summary *cur_summary = summaries->get (cur);\n-\t  if (!cur_summary)\n-\t    {\n-\t      /* The function doesn't have a summary.  We must have noticed\n-\t\t that during the first pass and the hopeless flag must\n-\t\t therefore be set.  Skip the function.  */\n-\t      gcc_assert (its_hopeless);\n-\t    }\n-\t  else if (its_hopeless)\n-\t    {\n-\t      if (dump_file)\n-\t\tfprintf (dump_file, \"Cleared modref info for %s\\n\",\n-\t\t\t cur->dump_name ());\n-\t      summaries->remove (cur);\n-\t    }\n-\t  else\n-\t    {\n-\t      if (cur == first)\n-\t\t;\n-\t      else\n-\t\t{\n-\t\t  if (loads)\n-\t\t    cur_summary->loads->merge (loads, NULL);\n-\t\t  if (stores)\n-\t\t    cur_summary->stores->merge (stores, NULL);\n-\t\t  if (loads_lto)\n-\t\t    cur_summary->loads_lto->merge (loads_lto, NULL);\n-\t\t  if (stores_lto)\n-\t\t    cur_summary->stores_lto->merge (stores_lto, NULL);\n-\t\t}\n-\t      cur_summary->finished = true;\n-\t      if (dump_file)\n-\t\t{\n-\t\t  fprintf (dump_file, \"Propagated modref for %s%s%s\\n\",\n-\t\t\t   cur->dump_name (),\n-\t\t\t   TREE_READONLY (cur->decl) ? \" (const)\" : \"\",\n-\t\t\t   DECL_PURE_P (cur->decl) ? \" (pure)\" : \"\");\n-\t\t  cur_summary->dump (dump_file);\n-\t\t}\n-\t    }\n-\t}\n+\tif (!cur->inlined_to)\n+\t  {\n+\t    modref_summary *cur_summary = summaries->get (cur);\n+\n+\t    fprintf (dump_file, \"Propagated modref for %s%s%s\\n\",\n+\t\t     cur->dump_name (),\n+\t\t     TREE_READONLY (cur->decl) ? \" (const)\" : \"\",\n+\t\t     DECL_PURE_P (cur->decl) ? \" (pure)\" : \"\");\n+\t    if (cur_summary)\n+\t      cur_summary->dump (dump_file);\n+\t    else\n+\t      fprintf (dump_file, \"  Not tracked\\n\");\n+\t  }\n+   }\n+}\n+\n+/* Run the IPA pass.  This will take a function's summaries and calls and\n+   construct new summaries which represent a transitive closure.  So that\n+   summary of an analyzed function contains information about the loads and\n+   stores that the function or any function that it calls does.  */\n+\n+unsigned int\n+pass_ipa_modref::execute (function *)\n+{\n+  if (!summaries)\n+    return 0;\n+\n+  struct cgraph_node **order = XCNEWVEC (struct cgraph_node *,\n+\t\t\t\t\t symtab->cgraph_count);\n+  int order_pos;\n+  order_pos = ipa_reduced_postorder (order, true, ignore_edge);\n+  int i;\n+\n+  /* Iterate over all strongly connected components in post-order.  */\n+  for (i = 0; i < order_pos; i++)\n+    {\n+      /* Get the component's representative.  That's just any node in the\n+\t component from which we can traverse the entire component.  */\n+      struct cgraph_node *component_node = order[i];\n+\n+      if (dump_file)\n+\tfprintf (dump_file, \"\\n\\nStart of SCC component\\n\");\n+\n+      modref_propagate_in_scc (component_node);\n     }\n   ((modref_summaries *)summaries)->ipa = false;\n   ipa_free_postorder_info ();\n+  /* Free ipa-prop structures if they are no longer needed.  */\n+  ipa_free_all_structures_after_iinln ();\n   return 0;\n }\n "}, {"sha": "b6621b498f0ce5eccc977d8adcb2060be665f685", "filename": "gcc/ipa-modref.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ada353b87909fd6cd37a30083b4fdcb76acbf5fe/gcc%2Fipa-modref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ada353b87909fd6cd37a30083b4fdcb76acbf5fe/gcc%2Fipa-modref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.h?ref=ada353b87909fd6cd37a30083b4fdcb76acbf5fe", "patch": "@@ -47,5 +47,6 @@ struct GTY(()) modref_summary\n \n modref_summary *get_modref_function_summary (cgraph_node *func);\n void ipa_modref_c_finalize ();\n+void ipa_merge_modref_summary_after_inlining (cgraph_edge *e);\n \n #endif"}]}