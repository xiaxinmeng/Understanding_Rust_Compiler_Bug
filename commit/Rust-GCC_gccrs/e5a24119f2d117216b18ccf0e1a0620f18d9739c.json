{"sha": "e5a24119f2d117216b18ccf0e1a0620f18d9739c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTVhMjQxMTlmMmQxMTcyMTZiMThjY2YwZTFhMDYyMGYxOGQ5NzM5Yw==", "commit": {"author": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2012-08-02T19:48:50Z"}, "committer": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2012-08-02T19:48:50Z"}, "message": "re PR fortran/48820 (TR 29113: Implement parts needed for MPI 3)\n\nfortran/\n\tPR fortran/48820\n\t* trans-array.c (gfc_conv_ss_startstride): Set the intrinsic\n\tresult's lower and upper bounds according to the rank.\n\t(set_loop_bounds): Set the loop upper bound in the intrinsic case.\n\ntestsuite/\n\tPR fortran/48820\n\t* gfortran.dg/assumed_rank_bounds_1.f90:  New test.\n\t* gfortran.dg/assumed_rank_bounds_2.f90:  New test.\n\nFrom-SVN: r190098", "tree": {"sha": "5d2a87b55e2491858ef9c60a627013cbfe35796c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5d2a87b55e2491858ef9c60a627013cbfe35796c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e5a24119f2d117216b18ccf0e1a0620f18d9739c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5a24119f2d117216b18ccf0e1a0620f18d9739c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5a24119f2d117216b18ccf0e1a0620f18d9739c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5a24119f2d117216b18ccf0e1a0620f18d9739c/comments", "author": null, "committer": null, "parents": [{"sha": "c0febbd3cdaff455175eddc99bb4adef5f4a4383", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0febbd3cdaff455175eddc99bb4adef5f4a4383", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0febbd3cdaff455175eddc99bb4adef5f4a4383"}], "stats": {"total": 315, "additions": 315, "deletions": 0}, "files": [{"sha": "167244977242a80368203a8aea23de366b920d5d", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5a24119f2d117216b18ccf0e1a0620f18d9739c/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5a24119f2d117216b18ccf0e1a0620f18d9739c/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=e5a24119f2d117216b18ccf0e1a0620f18d9739c", "patch": "@@ -1,3 +1,9 @@\n+2012-08-02  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\t* trans-array.c (gfc_conv_ss_startstride): Set the intrinsic\n+\tresult's lower and upper bounds according to the rank.\n+\t(set_loop_bounds): Set the loop upper bound in the intrinsic case.\n+\n 2012-08-02  Mikael Morin  <mikael@gcc.gnu.org>\n \n \t* trans-array.c (set_loop_bounds): Allow non-array-section to be"}, {"sha": "187eab01b008171a3ed62e2e819cca963438a488", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5a24119f2d117216b18ccf0e1a0620f18d9739c/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5a24119f2d117216b18ccf0e1a0620f18d9739c/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=e5a24119f2d117216b18ccf0e1a0620f18d9739c", "patch": "@@ -3808,6 +3808,40 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t    /* Fall through to supply start and stride.  */\n \t    case GFC_ISYM_LBOUND:\n \t    case GFC_ISYM_UBOUND:\n+\t      {\n+\t\tgfc_expr *arg;\n+\n+\t\t/* This is the variant without DIM=...  */\n+\t\tgcc_assert (expr->value.function.actual->next->expr == NULL);\n+\n+\t\targ = expr->value.function.actual->expr;\n+\t\tif (arg->rank == -1)\n+\t\t  {\n+\t\t    gfc_se se;\n+\t\t    tree rank, tmp;\n+\n+\t\t    /* The rank (hence the return value's shape) is unknown,\n+\t\t       we have to retrieve it.  */\n+\t\t    gfc_init_se (&se, NULL);\n+\t\t    se.descriptor_only = 1;\n+\t\t    gfc_conv_expr (&se, arg);\n+\t\t    /* This is a bare variable, so there is no preliminary\n+\t\t       or cleanup code.  */\n+\t\t    gcc_assert (se.pre.head == NULL_TREE\n+\t\t\t\t&& se.post.head == NULL_TREE);\n+\t\t    rank = gfc_conv_descriptor_rank (se.expr);\n+\t\t    tmp = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\t\t   gfc_array_index_type,\n+\t\t\t\t\t   fold_convert (gfc_array_index_type,\n+\t\t\t\t\t\t\t rank),\n+\t\t\t\t\t   gfc_index_one_node);\n+\t\t    info->end[0] = gfc_evaluate_now (tmp, &loop->pre);\n+\t\t    info->start[0] = gfc_index_zero_node;\n+\t\t    info->stride[0] = gfc_index_one_node;\n+\t\t    continue;\n+\t\t  }\n+\t\t  /* Otherwise fall through GFC_SS_FUNCTION.  */\n+\t      }\n \t    case GFC_ISYM_LCOBOUND:\n \t    case GFC_ISYM_UCOBOUND:\n \t    case GFC_ISYM_THIS_IMAGE:\n@@ -4526,6 +4560,20 @@ set_loop_bounds (gfc_loopinfo *loop)\n \t      gcc_assert (loop->to[n] == NULL_TREE);\n \t      break;\n \n+\t    case GFC_SS_INTRINSIC:\n+\t      {\n+\t\tgfc_expr *expr = loopspec[n]->info->expr;\n+\n+\t\t/* The {l,u}bound of an assumed rank.  */\n+\t\tgcc_assert ((expr->value.function.isym->id == GFC_ISYM_LBOUND\n+\t\t\t     || expr->value.function.isym->id == GFC_ISYM_UBOUND)\n+\t\t\t     && expr->value.function.actual->next->expr == NULL\n+\t\t\t     && expr->value.function.actual->expr->rank == -1);\n+\n+\t\tloop->to[n] = info->end[dim];\n+\t\tbreak;\n+\t      }\n+\n \t    default:\n \t      gcc_unreachable ();\n \t    }"}, {"sha": "4198578994cb20106bd487de0ef3142f6d3c880f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5a24119f2d117216b18ccf0e1a0620f18d9739c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5a24119f2d117216b18ccf0e1a0620f18d9739c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e5a24119f2d117216b18ccf0e1a0620f18d9739c", "patch": "@@ -1,3 +1,9 @@\n+2012-08-02  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\tPR fortran/48820\n+\t* gfortran.dg/assumed_rank_bounds_1.f90:  New test.\n+\t* gfortran.dg/assumed_rank_bounds_2.f90:  New test.\n+\n 2012-08-02  Jason Merrill  <jason@redhat.com>\n \t    Paolo Carlini  <paolo.carlini@oracle.com>\n "}, {"sha": "11d15f6a537c3b715e2ba24e51128682ad1e2aa0", "filename": "gcc/testsuite/gfortran.dg/assumed_rank_bounds_1.f90", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5a24119f2d117216b18ccf0e1a0620f18d9739c/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_bounds_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5a24119f2d117216b18ccf0e1a0620f18d9739c/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_bounds_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_bounds_1.f90?ref=e5a24119f2d117216b18ccf0e1a0620f18d9739c", "patch": "@@ -0,0 +1,143 @@\n+! { dg-do run }\n+!\n+! Test the behaviour of lbound, ubound of shape with assumed rank arguments\n+! in an array context (without DIM argument).\n+!\n+\n+program test\n+\n+  integer              :: a(2:4,-2:5)\n+  integer, allocatable :: b(:,:)\n+  integer, pointer     :: c(:,:)\n+  character(52)        :: buffer\n+\n+  call foo(a)\n+\n+  allocate(b(2:4,-2:5))\n+  call foo(b)\n+  call bar(b)\n+\n+  allocate(c(2:4,-2:5))\n+  call foo(c)\n+  call baz(c)\n+\n+contains\n+  subroutine foo(arg)\n+    integer :: arg(..)\n+\n+    !print *, lbound(arg)\n+    !print *, id(lbound(arg))\n+    if (any(lbound(arg) /= [1, 1])) call abort\n+    if (any(id(lbound(arg)) /= [1, 1])) call abort\n+    buffer = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'\n+    write(buffer,*) lbound(arg)\n+    if (buffer /= '           1           1') call abort\n+    buffer = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'\n+    write(buffer,*) id(lbound(arg))\n+    if (buffer /= '           1           1') call abort\n+\n+    !print *, ubound(arg)\n+    !print *, id(ubound(arg))\n+    if (any(ubound(arg) /= [3, 8])) call abort\n+    if (any(id(ubound(arg)) /= [3, 8])) call abort\n+    buffer = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'\n+    write(buffer,*) ubound(arg)\n+    if (buffer /= '           3           8') call abort\n+    buffer = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'\n+    write(buffer,*) id(ubound(arg))\n+    if (buffer /= '           3           8') call abort\n+\n+    !print *, shape(arg)\n+    !print *, id(shape(arg))\n+    if (any(shape(arg) /= [3, 8])) call abort\n+    if (any(id(shape(arg)) /= [3, 8])) call abort\n+    buffer = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'\n+    write(buffer,*) shape(arg)\n+    if (buffer /= '           3           8') call abort\n+    buffer = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'\n+    write(buffer,*) id(shape(arg))\n+    if (buffer /= '           3           8') call abort\n+\n+  end subroutine foo\n+  subroutine bar(arg)\n+    integer, allocatable :: arg(:,:)\n+\n+    !print *, lbound(arg)\n+    !print *, id(lbound(arg))\n+    if (any(lbound(arg) /= [2, -2])) call abort\n+    if (any(id(lbound(arg)) /= [2, -2])) call abort\n+    buffer = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'\n+    write(buffer,*) lbound(arg)\n+    if (buffer /= '           2          -2') call abort\n+    buffer = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'\n+    write(buffer,*) id(lbound(arg))\n+    if (buffer /= '           2          -2') call abort\n+\n+    !print *, ubound(arg)\n+    !print *, id(ubound(arg))\n+    if (any(ubound(arg) /= [4, 5])) call abort\n+    if (any(id(ubound(arg)) /= [4, 5])) call abort\n+    buffer = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'\n+    write(buffer,*) ubound(arg)\n+    if (buffer /= '           4           5') call abort\n+    buffer = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'\n+    write(buffer,*) id(ubound(arg))\n+    if (buffer /= '           4           5') call abort\n+\n+    !print *, shape(arg)\n+    !print *, id(shape(arg))\n+    if (any(shape(arg) /= [3, 8])) call abort\n+    if (any(id(shape(arg)) /= [3, 8])) call abort\n+    buffer = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'\n+    write(buffer,*) shape(arg)\n+    if (buffer /= '           3           8') call abort\n+    buffer = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'\n+    write(buffer,*) id(shape(arg))\n+    if (buffer /= '           3           8') call abort\n+\n+  end subroutine bar\n+  subroutine baz(arg)\n+    integer, pointer :: arg(..)\n+\n+    !print *, lbound(arg)\n+    !print *, id(lbound(arg))\n+    if (any(lbound(arg) /= [2, -2])) call abort\n+    if (any(id(lbound(arg)) /= [2, -2])) call abort\n+    buffer = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'\n+    write(buffer,*) lbound(arg)\n+    if (buffer /= '           2          -2') call abort\n+    buffer = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'\n+    write(buffer,*) id(lbound(arg))\n+    if (buffer /= '           2          -2') call abort\n+\n+    !print *, ubound(arg)\n+    !print *, id(ubound(arg))\n+    if (any(ubound(arg) /= [4, 5])) call abort\n+    if (any(id(ubound(arg)) /= [4, 5])) call abort\n+    buffer = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'\n+    write(buffer,*) ubound(arg)\n+    if (buffer /= '           4           5') call abort\n+    buffer = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'\n+    write(buffer,*) id(ubound(arg))\n+    if (buffer /= '           4           5') call abort\n+\n+    !print *, shape(arg)\n+    !print *, id(shape(arg))\n+    if (any(shape(arg) /= [3, 8])) call abort\n+    if (any(id(shape(arg)) /= [3, 8])) call abort\n+    buffer = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'\n+    write(buffer,*) shape(arg)\n+    if (buffer /= '           3           8') call abort\n+    buffer = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'\n+    write(buffer,*) id(shape(arg))\n+    if (buffer /= '           3           8') call abort\n+\n+  end subroutine baz\n+  elemental function id(arg)\n+    integer, intent(in) :: arg\n+    integer             :: id\n+\n+    id = arg\n+  end function id\n+end program test\n+"}, {"sha": "b9c8e56f42f4e27a8695db96914cb919693e14dd", "filename": "gcc/testsuite/gfortran.dg/assumed_rank_bounds_2.f90", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5a24119f2d117216b18ccf0e1a0620f18d9739c/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_bounds_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5a24119f2d117216b18ccf0e1a0620f18d9739c/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_bounds_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_bounds_2.f90?ref=e5a24119f2d117216b18ccf0e1a0620f18d9739c", "patch": "@@ -0,0 +1,112 @@\n+! { dg-do run }\n+!\n+! Test the behaviour of lbound, ubound of shape with assumed rank arguments\n+! in an array context (without DIM argument).\n+!\n+\n+program test\n+\n+  integer              :: a(2:4,-2:5)\n+  integer, allocatable :: b(:,:)\n+  integer, allocatable :: c(:,:)\n+  integer, pointer     :: d(:,:)\n+  character(52)        :: buffer\n+\n+  b = foo(a)\n+  !print *,b(:,1)\n+  if (any(b(:,1) /= [11, 101])) call abort\n+  buffer = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'\n+  write(buffer,*) b(:,1)\n+  if (buffer /= '          11         101') call abort\n+\n+  !print *,b(:,2)\n+  if (any(b(:,2) /= [3, 8])) call abort\n+  buffer = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'\n+  write(buffer,*) b(:,2)\n+  if (buffer /= '           3           8') call abort\n+\n+  !print *,b(:,3)\n+  if (any(b(:,3) /= [13, 108])) call abort\n+  buffer = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'\n+  write(buffer,*) b(:,3)\n+  if (buffer /= '          13         108') call abort\n+\n+\n+  allocate(c(1:2,-3:6))\n+  b = bar(c)\n+  !print *,b(:,1)\n+  if (any(b(:,1) /= [11, 97])) call abort\n+  buffer = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'\n+  write(buffer,*) b(:,1)\n+  if (buffer /= '          11          97') call abort\n+\n+  !print *,b(:,2)\n+  if (any(b(:,2) /= [12, 106])) call abort\n+  buffer = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'\n+  write(buffer,*) b(:,2)\n+  if (buffer /= '          12         106') call abort\n+\n+  !print *,b(:,3)\n+  if (any(b(:,3) /= [2, 10])) call abort\n+  buffer = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'\n+  write(buffer,*) b(:,3)\n+  if (buffer /= '           2          10') call abort\n+\n+\n+  allocate(d(3:5,-1:10))\n+  b = baz(d)\n+  !print *,b(:,1)\n+  if (any(b(:,1) /= [3, -1])) call abort\n+  buffer = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'\n+  write(buffer,*) b(:,1)\n+  if (buffer /= '           3          -1') call abort\n+\n+  !print *,b(:,2)\n+  if (any(b(:,2) /= [15, 110])) call abort\n+  buffer = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'\n+  write(buffer,*) b(:,2)\n+  if (buffer /= '          15         110') call abort\n+\n+  !print *,b(:,3)\n+  if (any(b(:,3) /= [13, 112])) call abort\n+  buffer = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'\n+  write(buffer,*) b(:,3)\n+  if (buffer /= '          13         112') call abort\n+\n+\n+contains\n+  function foo(arg) result(res)\n+    integer :: arg(..)\n+    integer, allocatable :: res(:,:)\n+\n+    allocate(res(rank(arg), 3))\n+\n+    res(:,1) = lbound(arg) + (/ 10, 100 /)\n+    res(:,2) = ubound(arg)\n+    res(:,3) = (/ 10, 100 /) + shape(arg)\n+\n+  end function foo\n+  function bar(arg) result(res)\n+    integer, allocatable :: arg(..)\n+    integer, allocatable :: res(:,:)\n+\n+    allocate(res(-1:rank(arg)-2, 3))\n+\n+    res(:,1) = lbound(arg) + (/ 10, 100 /)\n+    res(:,2) = (/ 10, 100 /) + ubound(arg)\n+    res(:,3) = shape(arg)\n+\n+  end function bar\n+  function baz(arg) result(res)\n+    integer, pointer     :: arg(..)\n+    integer, allocatable :: res(:,:)\n+\n+    allocate(res(2:rank(arg)+1, 3))\n+\n+    res(:,1) = lbound(arg)\n+    res(:,2) = (/ 10, 100 /) + ubound(arg)\n+    res(:,3) = shape(arg) + (/ 10, 100 /)\n+\n+  end function baz\n+end program test\n+"}]}