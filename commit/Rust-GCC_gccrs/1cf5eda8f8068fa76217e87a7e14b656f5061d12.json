{"sha": "1cf5eda8f8068fa76217e87a7e14b656f5061d12", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWNmNWVkYThmODA2OGZhNzYyMTdlODdhN2UxNGI2NTZmNTA2MWQxMg==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1994-10-19T00:58:49Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1994-10-19T00:58:49Z"}, "message": "Move block profile support to i386.h\n\nFrom-SVN: r8312", "tree": {"sha": "d78c5376e5de0a29f498d78c0cc38ba74acf3254", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d78c5376e5de0a29f498d78c0cc38ba74acf3254"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1cf5eda8f8068fa76217e87a7e14b656f5061d12", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1cf5eda8f8068fa76217e87a7e14b656f5061d12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1cf5eda8f8068fa76217e87a7e14b656f5061d12", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1cf5eda8f8068fa76217e87a7e14b656f5061d12/comments", "author": null, "committer": null, "parents": [{"sha": "9f8b85b87275a7ce9153d13d61cde20b0b649c8a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f8b85b87275a7ce9153d13d61cde20b0b649c8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f8b85b87275a7ce9153d13d61cde20b0b649c8a"}], "stats": {"total": 246, "additions": 92, "deletions": 154}, "files": [{"sha": "d402d8a5901c8ff295d60dee26a77d5822fb4fe9", "filename": "gcc/config/i386/freebsd.h", "status": "modified", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cf5eda8f8068fa76217e87a7e14b656f5061d12/gcc%2Fconfig%2Fi386%2Ffreebsd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cf5eda8f8068fa76217e87a7e14b656f5061d12/gcc%2Fconfig%2Fi386%2Ffreebsd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Ffreebsd.h?ref=1cf5eda8f8068fa76217e87a7e14b656f5061d12", "patch": "@@ -223,83 +223,6 @@ do {                                                                    \\\n #define LINK_SPEC \\\n   \"%{!nostdlib:%{!r*:%{!e*:-e start}}} -dc -dp %{static:-Bstatic} %{assert*}\"\n \n-/* This section copied from i386/osfrose.h */\n-\n-/* A C statement or compound statement to output to FILE some\n-   assembler code to initialize basic-block profiling for the current\n-   object module.  This code should call the subroutine\n-   `__bb_init_func' once per object module, passing it as its sole\n-   argument the address of a block allocated in the object module.\n-\n-   The name of the block is a local symbol made with this statement:\n-\n-\tASM_GENERATE_INTERNAL_LABEL (BUFFER, \"LPBX\", 0);\n-\n-   Of course, since you are writing the definition of\n-   `ASM_GENERATE_INTERNAL_LABEL' as well as that of this macro, you\n-   can take a short cut in the definition of this macro and use the\n-   name that you know will result.\n-\n-   The first word of this block is a flag which will be nonzero if the\n-   object module has already been initialized.  So test this word\n-   first, and do not call `__bb_init_func' if the flag is nonzero.  */\n-\n-#undef\tFUNCTION_BLOCK_PROFILER\n-#define FUNCTION_BLOCK_PROFILER(STREAM, LABELNO)\t\t\t\\\n-do\t\t\t\t\t\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\t\\\n-    if (!flag_pic)\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tfprintf (STREAM, \"\\tcmpl $0,%sPBX0\\n\", LPREFIX);\t\t\\\n-\tfprintf (STREAM, \"\\tjne 0f\\n\");\t\t\t\t\t\\\n-\tfprintf (STREAM, \"\\tpushl $%sPBX0\\n\", LPREFIX);\t\t\t\\\n-\tfprintf (STREAM, \"\\tcall ___bb_init_func\\n\");\t\t\t\\\n-\tfprintf (STREAM, \"0:\\n\");\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tfprintf (STREAM, \"\\tpushl %eax\\n\");\t\t\t\t\\\n-\tfprintf (STREAM, \"\\tmovl %sPBX0@GOT(%ebx),%eax\\n\");\t\t\\\n-\tfprintf (STREAM, \"\\tcmpl $0,(%eax)\\n\");\t\t\t\t\\\n-\tfprintf (STREAM, \"\\tjne 0f\\n\");\t\t\t\t\t\\\n-\tfprintf (STREAM, \"\\tpushl %eax\\n\");\t\t\t\t\\\n-\tfprintf (STREAM, \"\\tcall ___bb_init_func@PLT\\n\");\t\t\\\n-\tfprintf (STREAM, \"0:\\n\");\t\t\t\t\t\\\n-\tfprintf (STREAM, \"\\tpopl %eax\\n\");\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-  }\t\t\t\t\t\t\t\t\t\\\n-while (0)\n-\n-/* A C statement or compound statement to increment the count\n-   associated with the basic block number BLOCKNO.  Basic blocks are\n-   numbered separately from zero within each compilation.  The count\n-   associated with block number BLOCKNO is at index BLOCKNO in a\n-   vector of words; the name of this array is a local symbol made\n-   with this statement:\n-\n-\tASM_GENERATE_INTERNAL_LABEL (BUFFER, \"LPBX\", 2);\n-\n-   Of course, since you are writing the definition of\n-   `ASM_GENERATE_INTERNAL_LABEL' as well as that of this macro, you\n-   can take a short cut in the definition of this macro and use the\n-   name that you know will result.  */\n-\n-#undef\tBLOCK_PROFILER\n-#define BLOCK_PROFILER(STREAM, BLOCKNO)\t\t\t\t\t\\\n-do\t\t\t\t\t\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\t\\\n-    if (!flag_pic)\t\t\t\t\t\t\t\\\n-      fprintf (STREAM, \"\\tincl %sPBX2+%d\\n\", LPREFIX, (BLOCKNO)*4);\t\\\n-    else\t\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tfprintf (STREAM, \"\\tpushl %eax\\n\");\t\t\t\t\\\n-\tfprintf (STREAM, \"\\tmovl %sPBX2@GOT(%ebx),%eax\\n\", LPREFIX);\t\\\n-\tfprintf (STREAM, \"\\tincl %d(%eax)\\n\", (BLOCKNO)*4);\t\t\\\n-\tfprintf (STREAM, \"\\tpopl %eax\\n\");\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-  }\t\t\t\t\t\t\t\t\t\\\n-while (0)\n-\n /* This is defined when gcc is compiled in the BSD-directory-tree, and must\n  * make up for the gap to all the stuff done in the GNU-makefiles.\n  */"}, {"sha": "e5fd7e478252b9acce180b3c5075743553574b88", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cf5eda8f8068fa76217e87a7e14b656f5061d12/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cf5eda8f8068fa76217e87a7e14b656f5061d12/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=1cf5eda8f8068fa76217e87a7e14b656f5061d12", "patch": "@@ -889,6 +889,98 @@ enum reg_class\n     }\t\t\t\t\t\t\t\t\t\\\n }\n \n+/* A C statement or compound statement to output to FILE some\n+   assembler code to initialize basic-block profiling for the current\n+   object module.  This code should call the subroutine\n+   `__bb_init_func' once per object module, passing it as its sole\n+   argument the address of a block allocated in the object module.\n+\n+   The name of the block is a local symbol made with this statement:\n+\n+\tASM_GENERATE_INTERNAL_LABEL (BUFFER, \"LPBX\", 0);\n+\n+   Of course, since you are writing the definition of\n+   `ASM_GENERATE_INTERNAL_LABEL' as well as that of this macro, you\n+   can take a short cut in the definition of this macro and use the\n+   name that you know will result.\n+\n+   The first word of this block is a flag which will be nonzero if the\n+   object module has already been initialized.  So test this word\n+   first, and do not call `__bb_init_func' if the flag is nonzero.  */\n+\n+#undef\tFUNCTION_BLOCK_PROFILER\n+#define FUNCTION_BLOCK_PROFILER(STREAM, LABELNO)\t\t\t\\\n+do\t\t\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    static int num_func = 0;\t\t\t\t\t\t\\\n+    rtx xops[9];\t\t\t\t\t\t\t\\\n+    char block_table[80], false_label[80];\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    ASM_GENERATE_INTERNAL_LABEL (block_table, \"LPBX\", 0);\t\t\\\n+    ASM_GENERATE_INTERNAL_LABEL (false_label, \"LPBZ\", num_func);\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    xops[0] = const0_rtx;\t\t\t\t\t\t\\\n+    xops[1] = gen_rtx (SYMBOL_REF, VOIDmode, block_table);\t\t\\\n+    xops[2] = gen_rtx (MEM, Pmode, gen_rtx (SYMBOL_REF, VOIDmode, false_label)); \\\n+    xops[3] = gen_rtx (MEM, Pmode, gen_rtx (SYMBOL_REF, VOIDmode, \"__bb_init_func\")); \\\n+    xops[4] = gen_rtx (MEM, Pmode, xops[1]);\t\t\t\t\\\n+    xops[5] = stack_pointer_rtx;\t\t\t\t\t\\\n+    xops[6] = GEN_INT (4);\t\t\t\t\t\t\\\n+    xops[7] = gen_rtx (REG, Pmode, 0);\t/* eax */\t\t\t\\\n+    xops[8] = gen_rtx (MEM, SImode, stack_pointer_rtx);\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    CONSTANT_POOL_ADDRESS_P (xops[1]) = TRUE;\t\t\t\t\\\n+    CONSTANT_POOL_ADDRESS_P (xops[2]) = TRUE;\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    output_asm_insn (AS2(cmp%L4,%0,%4), xops);\t\t\t\t\\\n+    output_asm_insn (AS1(jne,%2), xops);\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    if (!flag_pic)\t\t\t\t\t\t\t\\\n+      output_asm_insn (AS1(push%L1,%1), xops);\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\toutput_asm_insn (AS1 (push%L7,%7), xops);\t\t\t\\\n+\toutput_asm_insn (AS2 (lea%L7,%a1,%7), xops);\t\t\t\\\n+\toutput_asm_insn (AS2 (xchg%L7,%8,%7), xops);\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    output_asm_insn (AS1(call,%P3), xops);\t\t\t\t\\\n+    output_asm_insn (AS2(add%L0,%6,%5), xops);\t\t\t\t\\\n+    ASM_OUTPUT_INTERNAL_LABEL (STREAM, \"LPBZ\", num_func);\t\t\\\n+    num_func++;\t\t\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+while (0)\n+\n+\n+/* A C statement or compound statement to increment the count\n+   associated with the basic block number BLOCKNO.  Basic blocks are\n+   numbered separately from zero within each compilation.  The count\n+   associated with block number BLOCKNO is at index BLOCKNO in a\n+   vector of words; the name of this array is a local symbol made\n+   with this statement:\n+\n+\tASM_GENERATE_INTERNAL_LABEL (BUFFER, \"LPBX\", 2);\n+\n+   Of course, since you are writing the definition of\n+   `ASM_GENERATE_INTERNAL_LABEL' as well as that of this macro, you\n+   can take a short cut in the definition of this macro and use the\n+   name that you know will result.  */\n+\n+#define BLOCK_PROFILER(STREAM, BLOCKNO)\t\t\t\t\t\\\n+do\t\t\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    rtx xops[1], cnt_rtx;\t\t\t\t\t\t\\\n+    char counts[80];\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    ASM_GENERATE_INTERNAL_LABEL (counts, \"LPBX\", 2);\t\t\t\\\n+    cnt_rtx = gen_rtx (SYMBOL_REF, VOIDmode, counts);\t\t\t\\\n+    CONSTANT_POOL_ADDRESS_P (cnt_rtx) = TRUE;\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    xops[0] = gen_rtx (MEM, SImode, plus_constant (cnt_rtx, (BLOCKNO)*4)); \\\n+    output_asm_insn (AS1(inc%L0,%0), xops);\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+while (0)\n+\n /* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n    the stack pointer does not matter.  The value is tested only in\n    functions that have frame pointers."}, {"sha": "8a0781e98354011caa73f89de2cb26fe3aaaf487", "filename": "gcc/config/i386/osfrose.h", "status": "modified", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cf5eda8f8068fa76217e87a7e14b656f5061d12/gcc%2Fconfig%2Fi386%2Fosfrose.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cf5eda8f8068fa76217e87a7e14b656f5061d12/gcc%2Fconfig%2Fi386%2Fosfrose.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fosfrose.h?ref=1cf5eda8f8068fa76217e87a7e14b656f5061d12", "patch": "@@ -341,83 +341,6 @@ do\t\t\t\t\t\t\t\t\t\\\n   }\t\t\t\t\t\t\t\t\t\\\n while (0)\n \n-/* A C statement or compound statement to output to FILE some\n-   assembler code to initialize basic-block profiling for the current\n-   object module.  This code should call the subroutine\n-   `__bb_init_func' once per object module, passing it as its sole\n-   argument the address of a block allocated in the object module.\n-\n-   The name of the block is a local symbol made with this statement:\n-\n-\tASM_GENERATE_INTERNAL_LABEL (BUFFER, \"LPBX\", 0);\n-\n-   Of course, since you are writing the definition of\n-   `ASM_GENERATE_INTERNAL_LABEL' as well as that of this macro, you\n-   can take a short cut in the definition of this macro and use the\n-   name that you know will result.\n-\n-   The first word of this block is a flag which will be nonzero if the\n-   object module has already been initialized.  So test this word\n-   first, and do not call `__bb_init_func' if the flag is nonzero.  */\n-\n-#undef\tFUNCTION_BLOCK_PROFILER\n-#define FUNCTION_BLOCK_PROFILER(STREAM, LABELNO)\t\t\t\\\n-do\t\t\t\t\t\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\t\\\n-    if (!flag_pic)\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tfprintf (STREAM, \"\\tcmpl $0,%sPBX0\\n\", LPREFIX);\t\t\\\n-\tfprintf (STREAM, \"\\tjne 0f\\n\");\t\t\t\t\t\\\n-\tfprintf (STREAM, \"\\tpushl $%sPBX0\\n\", LPREFIX);\t\t\t\\\n-\tfprintf (STREAM, \"\\tcall %s__bb_init_func\\n\",\t\t\t\\\n-\t\t (TARGET_UNDERSCORES) ? \"_\" : \"\");\t\t\t\\\n-\tfprintf (STREAM, \"0:\\n\");\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tfprintf (STREAM, \"\\tpushl %eax\\n\");\t\t\t\t\\\n-\tfprintf (STREAM, \"\\tmovl %sPBX0@GOT(%ebx),%eax\\n\");\t\t\\\n-\tfprintf (STREAM, \"\\tcmpl $0,(%eax)\\n\");\t\t\t\t\\\n-\tfprintf (STREAM, \"\\tjne 0f\\n\");\t\t\t\t\t\\\n-\tfprintf (STREAM, \"\\tpushl %eax\\n\");\t\t\t\t\\\n-\tfprintf (STREAM, \"\\tcall %s__bb_init_func@PLT\\n\",\t\t\\\n-\t\t (TARGET_UNDERSCORES) ? \"_\" : \"\");\t\t\t\\\n-\tfprintf (STREAM, \"0:\\n\");\t\t\t\t\t\\\n-\tfprintf (STREAM, \"\\tpopl %eax\\n\");\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-  }\t\t\t\t\t\t\t\t\t\\\n-while (0)\n-\n-/* A C statement or compound statement to increment the count\n-   associated with the basic block number BLOCKNO.  Basic blocks are\n-   numbered separately from zero within each compilation.  The count\n-   associated with block number BLOCKNO is at index BLOCKNO in a\n-   vector of words; the name of this array is a local symbol made\n-   with this statement:\n-\n-\tASM_GENERATE_INTERNAL_LABEL (BUFFER, \"LPBX\", 2);\n-\n-   Of course, since you are writing the definition of\n-   `ASM_GENERATE_INTERNAL_LABEL' as well as that of this macro, you\n-   can take a short cut in the definition of this macro and use the\n-   name that you know will result.  */\n-\n-#undef\tBLOCK_PROFILER\n-#define BLOCK_PROFILER(STREAM, BLOCKNO)\t\t\t\t\t\\\n-do\t\t\t\t\t\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\t\\\n-    if (!flag_pic)\t\t\t\t\t\t\t\\\n-      fprintf (STREAM, \"\\tincl %sPBX2+%d\\n\", LPREFIX, (BLOCKNO)*4);\t\\\n-    else\t\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tfprintf (STREAM, \"\\tpushl %eax\\n\");\t\t\t\t\\\n-\tfprintf (STREAM, \"\\tmovl %sPBX2@GOT(%ebx),%eax\\n\", LPREFIX);\t\\\n-\tfprintf (STREAM, \"\\tincl %d(%eax)\\n\", (BLOCKNO)*4);\t\t\\\n-\tfprintf (STREAM, \"\\tpopl %eax\\n\");\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-  }\t\t\t\t\t\t\t\t\t\\\n-while (0)\n-\n /* A C function or functions which are needed in the library to\n    support block profiling.  When support goes into libc, undo\n    the #if 0.  */"}]}