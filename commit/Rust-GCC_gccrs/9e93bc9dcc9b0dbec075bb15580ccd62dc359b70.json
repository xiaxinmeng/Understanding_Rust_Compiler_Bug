{"sha": "9e93bc9dcc9b0dbec075bb15580ccd62dc359b70", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWU5M2JjOWRjYzliMGRiZWMwNzViYjE1NTgwY2NkNjJkYzM1OWI3MA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "1999-09-27T08:26:00Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "1999-09-27T08:26:00Z"}, "message": "Augment stringification of trees.\n\n\t* cp-tree.h (tree_string_flags): New error stringifying enumeration.\n\t(fndecl_as_string, type_as_string_real, args_as_string,\n\tcode_as_string, language_as_string, parm_as_string,\n\top_as_string, assop_as_string, cv_as_string): Remove.\n\t(type_as_string, decl_as_string, expr_as_string): Adjust prototype.\n\t(context_as_string): Declare new function.\n\t* error.c (cp_printers): Move definition.\n\t(OB_UNPUT): Remove.\n\t(OB_END_TEMPLATE_ID): Adjust.\n\t(interesting_scope_p): Remove.\n\t(dump_scope): New static function.\n\t(dump_qualifiers): Adjust prototype, reimplement.\n\t(dump_template_value): Use tree_string_flags.\n\t(dump_type_real): Move back to dump_type.\n\t(dump_type): Adjust prototype. Use tree_string_flags.\n\t(dump_aggr_type): Likewise. Use dump_template_parms.\n\t(dump_type_prefix): Adjust prototype. Use tree_string_flags. Return pad flag.\n\t(dump_type_suffix): Adjust prototype. Use tree_string_flags.\n\t(dump_simple_decl): Likewise.\n\t(dump_decl): Likewise. Use dump_template_decl.\n\t(dump_template_decl): New static function broken out of dump_decl.\n\t(dump_function_decl): Adjust prototype. Use tree_string_flags.\n\t(dump_parameters): Likewise. Prefix space.\n\t(dump_exception_spec): Adjust prototype. Use tree_string_flags.\n\t(dump_function_name): Likewise. Use dump_template_parms.\n\t(dump_template_parms): New static function broken out of\n\tdump_function_name.\n\t(dump_expr_list): Adjust prototype. Use tree_string_flags.\n\t(dump_expr): Likewise.\n\t(fndecl_as_string): Removed\n\t(type_as_string_real): Removed\n\t(dump_binary_op): Adjust prototype. Use tree_string_flags.\n\t(dump_unary_op): Likewise.\n\t(type_as_string): Likewise.\n\t(expr_as_string): Likewise.\n\t(decl_as_string): Likewise.\n\t(context_as_string): New function.\n\t(lang_decl_name): Adjust.\n\t(decl_to_string): New static print callback.\n\t(expr_to_string): Likewise.\n\t(fndecl_to_string): Likewise.\n\t(code_as_string): Renamed to ...\n\t(code_to_string): ... here. Adjust.\n\t(language_as_string): Renamed to ...\n\t(language_to_string): ... here. Adjust.\n\t(parm_as_string): Renamed to ...\n\t(parm_to_string): ... here.\n\t(op_as_string): Renamed to ...\n\t(op_to_string): ... here.\n\t(assop_as_string): Renamed to ...\n\t(assop_to_string): ... here.\n\t(type_to_string): New static print callback.\n\t(args_as_string): Renamed to ...\n\t(args_to_string): ... here. Adjust.\n\t(cv_as_string): Renamed to ...\n\t(cv_to_string): ... here. Adjust.\n\t* pt.c (mangle_class_name_for_template): Use tree_string_flags.\n\t(print_template_context): Likewise.\n\nFrom-SVN: r29673", "tree": {"sha": "b9a8cff7e4d793f4fa255bf1d72bf5ece69e1257", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b9a8cff7e4d793f4fa255bf1d72bf5ece69e1257"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e93bc9dcc9b0dbec075bb15580ccd62dc359b70", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e93bc9dcc9b0dbec075bb15580ccd62dc359b70", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e93bc9dcc9b0dbec075bb15580ccd62dc359b70", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e93bc9dcc9b0dbec075bb15580ccd62dc359b70/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cf9d61d5691d213db5f3f1a06178604cecf15998", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf9d61d5691d213db5f3f1a06178604cecf15998", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf9d61d5691d213db5f3f1a06178604cecf15998"}], "stats": {"total": 1487, "additions": 880, "deletions": 607}, "files": [{"sha": "fa5f56b4cb0dd0751b54c46003b069ed94435159", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e93bc9dcc9b0dbec075bb15580ccd62dc359b70/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e93bc9dcc9b0dbec075bb15580ccd62dc359b70/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9e93bc9dcc9b0dbec075bb15580ccd62dc359b70", "patch": "@@ -1,3 +1,65 @@\n+1999-09-27  Nathan Sidwell  <nathan@acm.org>\n+\n+\tAugment stringification of trees.\n+\t* cp-tree.h (tree_string_flags): New error stringifying enumeration.\n+\t(fndecl_as_string, type_as_string_real, args_as_string,\n+\tcode_as_string, language_as_string, parm_as_string,\n+\top_as_string, assop_as_string, cv_as_string): Remove.\n+\t(type_as_string, decl_as_string, expr_as_string): Adjust prototype.\n+\t(context_as_string): Declare new function.\n+\t* error.c (cp_printers): Move definition.\n+\t(OB_UNPUT): Remove.\n+\t(OB_END_TEMPLATE_ID): Adjust.\n+\t(interesting_scope_p): Remove.\n+\t(dump_scope): New static function.\n+\t(dump_qualifiers): Adjust prototype, reimplement.\n+\t(dump_template_value): Use tree_string_flags.\n+\t(dump_type_real): Move back to dump_type.\n+\t(dump_type): Adjust prototype. Use tree_string_flags.\n+\t(dump_aggr_type): Likewise. Use dump_template_parms.\n+\t(dump_type_prefix): Adjust prototype. Use tree_string_flags. Return pad flag.\n+\t(dump_type_suffix): Adjust prototype. Use tree_string_flags.\n+\t(dump_simple_decl): Likewise.\n+\t(dump_decl): Likewise. Use dump_template_decl.\n+\t(dump_template_decl): New static function broken out of dump_decl.\n+\t(dump_function_decl): Adjust prototype. Use tree_string_flags.\n+\t(dump_parameters): Likewise. Prefix space.\n+\t(dump_exception_spec): Adjust prototype. Use tree_string_flags.\n+\t(dump_function_name): Likewise. Use dump_template_parms.\n+\t(dump_template_parms): New static function broken out of\n+\tdump_function_name.\n+\t(dump_expr_list): Adjust prototype. Use tree_string_flags.\n+\t(dump_expr): Likewise.\n+\t(fndecl_as_string): Removed\n+\t(type_as_string_real): Removed\n+\t(dump_binary_op): Adjust prototype. Use tree_string_flags.\n+\t(dump_unary_op): Likewise.\n+\t(type_as_string): Likewise.\n+\t(expr_as_string): Likewise.\n+\t(decl_as_string): Likewise.\n+\t(context_as_string): New function.\n+\t(lang_decl_name): Adjust.\n+\t(decl_to_string): New static print callback.\n+\t(expr_to_string): Likewise.\n+\t(fndecl_to_string): Likewise.\n+\t(code_as_string): Renamed to ...\n+\t(code_to_string): ... here. Adjust.\n+\t(language_as_string): Renamed to ...\n+\t(language_to_string): ... here. Adjust.\n+\t(parm_as_string): Renamed to ...\n+\t(parm_to_string): ... here.\n+\t(op_as_string): Renamed to ...\n+\t(op_to_string): ... here.\n+\t(assop_as_string): Renamed to ...\n+\t(assop_to_string): ... here.\n+\t(type_to_string): New static print callback.\n+\t(args_as_string): Renamed to ...\n+\t(args_to_string): ... here. Adjust.\n+\t(cv_as_string): Renamed to ...\n+\t(cv_to_string): ... here. Adjust.\n+\t* pt.c (mangle_class_name_for_template): Use tree_string_flags.\n+\t(print_template_context): Likewise.\n+\n 1999-09-26  Mark Mitchell  <mark@codesourcery.com>\n \n \t* cp-tree.h (expand_throw): Remove prototype."}, {"sha": "9202354af59e174b4c9bd3f39a5a121ad2c3a4c4", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 28, "deletions": 12, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e93bc9dcc9b0dbec075bb15580ccd62dc359b70/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e93bc9dcc9b0dbec075bb15580ccd62dc359b70/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=9e93bc9dcc9b0dbec075bb15580ccd62dc359b70", "patch": "@@ -3122,6 +3122,30 @@ enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, OP_FLAG, TYPENAME_FLAG };\n #define TEMPLATE_TYPE_DECL(NODE) \\\n   (TEMPLATE_PARM_DECL (TEMPLATE_TYPE_PARM_INDEX (NODE)))\n \n+/* Control stringification of trees (types, decls & exprs).\n+   Bit or them together.  */\n+enum tree_string_flags\n+{\n+    TS_PLAIN,                    /* nothing special */\n+    TS_CHASE_TYPEDEFS = 1 <<  0, /* look through typedefs */\n+    TS_DECORATE       = 1 <<  1, /* decorate things */\n+    TS_FUNC_NORETURN  = 1 <<  2, /* inhibit function return type */\n+    TS_FUNC_THROW     = 1 <<  3, /* show throw spec */\n+    TS_PARM_DEFAULTS  = 1 <<  4, /* show parm defaults */\n+    TS_EXPR_PARENS    = 1 <<  5, /* enclose in parens */\n+    TS_AGGR_TAGS      = 1 <<  6, /* show struct tags */\n+    TS_DECL_TYPE      = 1 <<  7, /* show decl's type */\n+    TS_FUNC_SCOPE     = 1 <<  8, /* show function scope */\n+    TS_PEDANTIC_NAME  = 1 <<  9, /* pedantically name things */\n+    TS_TEMPLATE_PREFIX= 1 << 10, /* show template <parms> prefix */\n+    \n+    /* Internal use flags */\n+    TS_TEMPLATE_PARM  = 1 << 11, /* decl is really a non-type template parm */\n+    TS_TEMPLATE_PLAIN = 1 << 12, /* don't decorate primary template_name */\n+    \n+    TS_NEXT_BIT       = 13       /* next available bit */\n+};\n+\n /* in lex.c  */\n /* Indexed by TREE_CODE, these tables give C-looking names to\n    operators represented by TREE_CODES.  For example,\n@@ -3430,18 +3454,10 @@ extern void cp_deprecated                       PROTO((const char*));\n \n /* in error.c */\n extern void init_error\t\t\t\tPROTO((void));\n-extern const char *fndecl_as_string\t\tPROTO((tree, int));\n-extern const char *type_as_string\t\tPROTO((tree, int));\n-extern const char *type_as_string_real\t\tPROTO((tree, int, int));\n-extern const char *args_as_string\t\tPROTO((tree, int));\n-extern const char *decl_as_string\t\tPROTO((tree, int));\n-extern const char *expr_as_string\t\tPROTO((tree, int));\n-extern const char *code_as_string\t\tPROTO((enum tree_code, int));\n-extern const char *language_as_string\t\tPROTO((enum languages, int));\n-extern const char *parm_as_string\t\tPROTO((int, int));\n-extern const char *op_as_string\t\t\tPROTO((enum tree_code, int));\n-extern const char *assop_as_string\t\tPROTO((enum tree_code, int));\n-extern const char *cv_as_string\t\t\tPROTO((tree, int));\n+extern const char *type_as_string\t\tPROTO((tree, enum tree_string_flags));\n+extern const char *decl_as_string\t\tPROTO((tree, enum tree_string_flags));\n+extern const char *expr_as_string\t\tPROTO((tree, enum tree_string_flags));\n+extern const char *context_as_string            PROTO((tree, enum tree_string_flags));\n extern const char *lang_decl_name\t\tPROTO((tree, int));\n extern const char *cp_file_of\t\t\tPROTO((tree));\n extern int cp_line_of\t\t\t\tPROTO((tree));"}, {"sha": "fc64cab07384e4cd803f1f1f0fe37062d695d733", "filename": "gcc/cp/error.c", "status": "modified", "additions": 786, "deletions": 591, "changes": 1377, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e93bc9dcc9b0dbec075bb15580ccd62dc359b70/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e93bc9dcc9b0dbec075bb15580ccd62dc359b70/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=9e93bc9dcc9b0dbec075bb15580ccd62dc359b70", "patch": "@@ -28,43 +28,6 @@ Boston, MA 02111-1307, USA.  */\n \n typedef const char *cp_printer ();\n \n-#define A args_as_string\n-#define C code_as_string\n-#define D decl_as_string\n-#define E expr_as_string\n-#define F fndecl_as_string\n-#define L language_as_string\n-#define O op_as_string\n-#define P parm_as_string\n-#define Q assop_as_string\n-#define T type_as_string\n-#define V cv_as_string\n-\n-#define o (cp_printer *) 0\n-cp_printer * cp_printers[256] =\n-{\n-/*0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */\n-  o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, /* 0x00 */\n-  o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, /* 0x10 */\n-  o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, /* 0x20 */\n-  o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, /* 0x30 */\n-  o, A, o, C, D, E, F, o, o, o, o, o, L, o, o, O, /* 0x40 */\n-  P, Q, o, o, T, o, V, o, o, o, o, o, o, o, o, o, /* 0x50 */\n-  o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, /* 0x60 */\n-  o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, /* 0x70 */\n-};\n-#undef C\n-#undef D\n-#undef E\n-#undef F\n-#undef L\n-#undef O\n-#undef P\n-#undef Q\n-#undef T\n-#undef V\n-#undef o\n-\n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free free\n \n@@ -84,39 +47,88 @@ static char *scratch_firstobj;\n # define OB_FINISH() (obstack_1grow (&scratch_obstack, '\\0'))\n # define OB_PUTI(CST) do { sprintf (digit_buffer, HOST_WIDE_INT_PRINT_DEC, (HOST_WIDE_INT)(CST)); \\\n \t\t\t   OB_PUTCP (digit_buffer); } while (0)\n-# define OB_UNPUT(N) obstack_blank (&scratch_obstack, - (N));\n \n # define OB_END_TEMPLATE_ID() \t\t\t\t\t\t    \\\n-  ((obstack_next_free (&scratch_obstack) != obstack_base (&scratch_obstack) \\\n+  (((obstack_next_free (&scratch_obstack) != obstack_base (&scratch_obstack) \\\n     && obstack_next_free (&scratch_obstack)[-1] == '>')\t\t\t    \\\n-   ? OB_PUTC2 (' ', '>') : OB_PUTC ('>'))\n+   ? OB_PUTC (' ') : (void)0), OB_PUTC ('>'))\n \n # define NEXT_CODE(t) (TREE_CODE (TREE_TYPE (t)))\n \n enum pad { none, before, after };\n \n-static void dump_type PROTO((tree, int));\n-static void dump_type_real PROTO((tree, int, int));\n-static void dump_simple_decl PROTO((tree, tree, int));\n-static void dump_decl PROTO((tree, int));\n-static void dump_function_decl PROTO((tree, int));\n-static void dump_expr PROTO((tree, int));\n-static void dump_unary_op PROTO((const char *, tree, int));\n-static void dump_binary_op PROTO((const char *, tree));\n-static void dump_aggr_type PROTO((tree, int, int));\n-static void dump_type_prefix PROTO((tree, int, int));\n-static void dump_type_suffix PROTO((tree, int, int));\n-static void dump_function_name PROTO((tree));\n-static void dump_expr_list PROTO((tree));\n+static const char *args_to_string\t\tPROTO((tree, int));\n+static const char *assop_to_string\t\tPROTO((enum tree_code, int));\n+static const char *code_to_string\t\tPROTO((enum tree_code, int));\n+static const char *cv_to_string\t\t\tPROTO((tree, int));\n+static const char *decl_to_string\t\tPROTO((tree, int));\n+static const char *expr_to_string\t\tPROTO((tree, int));\n+static const char *fndecl_to_string\t\tPROTO((tree, int));\n+static const char *language_to_string\t\tPROTO((enum languages, int));\n+static const char *op_to_string\t\t\tPROTO((enum tree_code, int));\n+static const char *parm_to_string\t\tPROTO((int, int));\n+static const char *type_to_string\t\tPROTO((tree, int));\n+\n+static void dump_type PROTO((tree, enum tree_string_flags));\n+static void dump_simple_decl PROTO((tree, tree, enum tree_string_flags));\n+static void dump_decl PROTO((tree, enum tree_string_flags));\n+static void dump_template_decl PROTO((tree, enum tree_string_flags));\n+static void dump_function_decl PROTO((tree, enum tree_string_flags));\n+static void dump_expr PROTO((tree, enum tree_string_flags));\n+static void dump_unary_op PROTO((const char *, tree, enum tree_string_flags));\n+static void dump_binary_op PROTO((const char *, tree, enum tree_string_flags));\n+static void dump_aggr_type PROTO((tree, enum tree_string_flags));\n+static enum pad dump_type_prefix PROTO((tree, enum tree_string_flags));\n+static void dump_type_suffix PROTO((tree, enum tree_string_flags));\n+static void dump_function_name PROTO((tree, enum tree_string_flags));\n+static void dump_expr_list PROTO((tree, enum tree_string_flags));\n static void dump_global_iord PROTO((tree));\n-static void dump_qualifiers PROTO((tree, enum pad));\n+static enum pad dump_qualifiers PROTO((tree, enum pad));\n static void dump_char PROTO((int));\n-static void dump_parameters PROTO((tree, int, int));\n-static void dump_exception_spec PROTO((tree, int));\n+static void dump_parameters PROTO((tree, enum tree_string_flags));\n+static void dump_exception_spec PROTO((tree, enum tree_string_flags));\n static const char *aggr_variety PROTO((tree));\n static tree ident_fndecl PROTO((tree));\n-static int interesting_scope_p PROTO((tree));\n-static void dump_template_value PROTO((tree, int, int));\n+static void dump_template_value PROTO((tree, enum tree_string_flags));\n+static void dump_scope PROTO((tree, enum tree_string_flags));\n+static void dump_template_parms PROTO((tree, int, enum tree_string_flags));\n+\n+#define A args_to_string\n+#define C code_to_string\n+#define D decl_to_string\n+#define E expr_to_string\n+#define F fndecl_to_string\n+#define L language_to_string\n+#define O op_to_string\n+#define P parm_to_string\n+#define Q assop_to_string\n+#define T type_to_string\n+#define V cv_to_string\n+\n+#define o (cp_printer *) 0\n+cp_printer * cp_printers[256] =\n+{\n+/*0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */\n+  o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, /* 0x00 */\n+  o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, /* 0x10 */\n+  o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, /* 0x20 */\n+  o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, /* 0x30 */\n+  o, A, o, C, D, E, F, o, o, o, o, o, L, o, o, O, /* 0x40 */\n+  P, Q, o, o, T, o, V, o, o, o, o, o, o, o, o, o, /* 0x50 */\n+  o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, /* 0x60 */\n+  o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, /* 0x70 */\n+};\n+#undef C\n+#undef D\n+#undef E\n+#undef F\n+#undef L\n+#undef O\n+#undef P\n+#undef Q\n+#undef T\n+#undef V\n+#undef o\n \n void\n init_error ()\n@@ -125,92 +137,102 @@ init_error ()\n   scratch_firstobj = (char *)obstack_alloc (&scratch_obstack, 0);\n }\n \n-/* Returns nonzero if SCOPE is something we want to print for random decls.  */\n+/* Dump a scope, if deemed necessary.  */\n \n-static int\n-interesting_scope_p (scope)\n+static void\n+dump_scope (scope, flags)\n      tree scope;\n+     enum tree_string_flags flags;\n {\n-  if (scope == NULL_TREE\n-      || scope == global_namespace)\n-    return 0;\n-\n-  return (TREE_CODE (scope) == NAMESPACE_DECL\n-\t  || AGGREGATE_TYPE_P (scope));\n+  if (scope == NULL_TREE)\n+    return;\n+  \n+  if (TREE_CODE (scope) == NAMESPACE_DECL)\n+    {\n+      if (scope != global_namespace)\n+        {\n+          dump_decl (scope, (flags & (TS_PEDANTIC_NAME | TS_FUNC_SCOPE | TS_CHASE_TYPEDEFS))\n+                             | TS_FUNC_NORETURN | TS_DECL_TYPE);\n+          OB_PUTS (\"::\");\n+        }\n+      else if (flags & TS_PEDANTIC_NAME)\n+        OB_PUTS (\"::\");\n+    }\n+  else if (AGGREGATE_TYPE_P (scope))\n+    {\n+      dump_type (scope, (flags & (TS_PEDANTIC_NAME | TS_FUNC_SCOPE | TS_CHASE_TYPEDEFS))\n+                           | TS_FUNC_NORETURN | TS_DECL_TYPE);\n+      OB_PUTS (\"::\");\n+    }\n+  else if ((flags & (TS_PEDANTIC_NAME | TS_FUNC_SCOPE))\n+            && TREE_CODE (scope) == FUNCTION_DECL)\n+    {\n+      dump_function_decl (scope, (flags & (TS_PEDANTIC_NAME | TS_FUNC_SCOPE | TS_CHASE_TYPEDEFS))\n+                           | TS_FUNC_NORETURN | TS_DECL_TYPE);\n+      OB_PUTS (\"::\");\n+    }\n }\n \n-static void\n+/* Dump type qualifiers, providing padding as requested. Return an\n+   indication of whether we dumped something.  */\n+\n+static enum pad\n dump_qualifiers (t, p)\n      tree t;\n      enum pad p;\n {\n-  if (TYPE_QUALS (t))\n+  static const int masks[] =\n+    {TYPE_QUAL_CONST, TYPE_QUAL_VOLATILE, TYPE_QUAL_RESTRICT};\n+  static const char *const names[] =\n+    {\"const\", \"volatile\", \"__restrict\"};\n+  int ix;\n+  int quals = TYPE_QUALS (t);\n+  int do_after = p == after;\n+  \n+  if (quals)\n     {\n-      if (p == before) OB_PUTC (' ');\n-      switch (TYPE_QUALS (t))\n-\t{\n-\tcase TYPE_QUAL_CONST:\n-\t  OB_PUTS (\"const\");\n-\t  break;\n-\n-\tcase TYPE_QUAL_VOLATILE:\n-\t  OB_PUTS (\"volatile\");\n-\t  break;\n-\n-\tcase TYPE_QUAL_RESTRICT:\n-\t  OB_PUTS (\"__restrict\");\n-\t  break;\n-\n-\tcase TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE:\n-\t  OB_PUTS (\"const volatile\");\n-\t  break;\n-\n-\tcase TYPE_QUAL_CONST | TYPE_QUAL_RESTRICT:\n-\t  OB_PUTS (\"const __restrict\");\n-\t  break;\n-\n-\tcase TYPE_QUAL_VOLATILE | TYPE_QUAL_RESTRICT:\n-\t  OB_PUTS (\"volatile __restrict\");\n-\t  break;\n-\n-\tcase TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE | TYPE_QUAL_RESTRICT:\n-\t  OB_PUTS (\"const volatile __restrict\");\n-\t  break;\n-\n-\tdefault:\n-\t  my_friendly_abort (0);\n-\t}\n-      if (p == after) OB_PUTC (' ');\n+      for (ix = 0; ix != 3; ix++)\n+        if (masks[ix] & quals)\n+          {\n+            if (p == before)\n+              OB_PUTC (' ');\n+            p = before;\n+            OB_PUTCP (names[ix]);\n+          }\n+      if (do_after)\n+        OB_PUTC (' ');\n     }\n+  else\n+    p = none;\n+  return p;\n }\n \n /* This must be large enough to hold any printed integer or floating-point\n    value.  */\n static char digit_buffer[128];\n \n-/* Dump a template parameter or template argument VALUE at VERBOSITY\n-   level.  The boolean CANONICAL_NAME indicates whether to dump abstract\n-   names, e.g. typedefs, or not. */\n+/* Dump a template parameter or template argument VALUE under\n+   control of FLAGS. */\n \n static void\n-dump_template_value (value, verbosity, canonical_name)\n+dump_template_value (value, flags)\n      tree value;\n-     int verbosity, canonical_name;\n+     enum tree_string_flags flags;\n {\n   if (TREE_CODE_CLASS (TREE_CODE (value)) == 't'\n       || TREE_CODE (value) == TEMPLATE_DECL)\n-    dump_type_real (value, verbosity, canonical_name);\n+    dump_type (value, flags & ~TS_AGGR_TAGS);\n   else\n-    dump_expr (value, verbosity);\n+    dump_expr (value, (flags | TS_EXPR_PARENS) & ~TS_AGGR_TAGS);\n }\n \n-/* Dump into the obstack a human-readable equivalent of TYPE.  */\n+/* Dump into the obstack a human-readable equivalent of TYPE.  FLAGS\n+   controls the format.  */\n \n static void\n-dump_type_real (t, v, canonical_name)\n+dump_type (t, flags)\n      tree t;\n-     int v;\t\t\t/* verbose? */\n-     int canonical_name;\n+     enum tree_string_flags flags;\n {\n   if (t == NULL_TREE)\n     return;\n@@ -220,42 +242,46 @@ dump_type_real (t, v, canonical_name)\n \n   switch (TREE_CODE (t))\n     {\n-    case ERROR_MARK:\n-      OB_PUTS (\"{error}\");\n-      break;\n-\n     case UNKNOWN_TYPE:\n       OB_PUTS (\"{unknown type}\");\n       break;\n \n     case TREE_LIST:\n       /* A list of function parms.  */\n-      dump_parameters (t, 0, canonical_name);\n+      dump_parameters (t, flags);\n       break;\n \n     case IDENTIFIER_NODE:\n       OB_PUTID (t);\n       break;\n \n     case TREE_VEC:\n-      dump_type_real (BINFO_TYPE (t), v, canonical_name);\n+      dump_type (BINFO_TYPE (t), flags);\n       break;\n \n     case RECORD_TYPE:\n     case UNION_TYPE:\n     case ENUMERAL_TYPE:\n-      dump_aggr_type (t, v, canonical_name);\n+      dump_aggr_type (t, flags);\n       break;\n \n     case TYPE_DECL:\n+      if (flags & TS_CHASE_TYPEDEFS)\n+        {\n+          dump_type (DECL_ORIGINAL_TYPE (t)\n+                     ? DECL_ORIGINAL_TYPE (t) : TREE_TYPE (t), flags);\n+          break;\n+        }\n+      /* else fallthrough */\n+    \n     case TEMPLATE_DECL:\n     case NAMESPACE_DECL:\n-      dump_decl (t, v);\n+      dump_decl (t, flags & ~TS_DECL_TYPE);\n       break;\n-\n+    \n     case COMPLEX_TYPE:\n       OB_PUTS (\"complex \");\n-      dump_type_real (TREE_TYPE (t), v, canonical_name);\n+      dump_type (TREE_TYPE (t), flags);\n       break;\n \n     case INTEGER_TYPE:\n@@ -271,7 +297,7 @@ dump_type_real (t, v, canonical_name)\n       {\n \ttree type;\n \tdump_qualifiers (t, after);\n-\ttype = canonical_name ? TYPE_MAIN_VARIANT (t) : t;\n+\ttype = flags & TS_CHASE_TYPEDEFS ? TYPE_MAIN_VARIANT (t) : t;\n \tif (TYPE_NAME (type) && TYPE_IDENTIFIER (type))\n \t  OB_PUTID (TYPE_IDENTIFIER (type));\n \telse\n@@ -299,9 +325,10 @@ dump_type_real (t, v, canonical_name)\n \t  OB_PUTC ('<');\n \t  for (i = 0; i < TREE_VEC_LENGTH (args); i++)\n \t    {\n-              dump_template_value (TREE_VEC_ELT (args, i), 0, canonical_name);\n-\t      if (i < TREE_VEC_LENGTH (args)-1)\n-\t        OB_PUTC2 (',', ' ');\n+\t      tree arg = TREE_VEC_ELT (args, i);\n+\t      if (i)\n+\t        OB_PUTS (\", \");\n+\t      dump_template_value (arg, flags);\n \t    }\n \t  OB_END_TEMPLATE_ID ();\n \t}\n@@ -324,29 +351,37 @@ dump_type_real (t, v, canonical_name)\n     offset_type:\n     case FUNCTION_TYPE:\n     case METHOD_TYPE:\n-      dump_type_prefix (t, v, canonical_name);\n-      dump_type_suffix (t, v, canonical_name);\n+    {\n+      dump_type_prefix (t, flags);\n+      dump_type_suffix (t, flags);\n       break;\n-\n+    }\n     case TYPENAME_TYPE:\n       OB_PUTS (\"typename \");\n-      dump_type_real (TYPE_CONTEXT (t), 0, canonical_name);\n+      dump_type (TYPE_CONTEXT (t), flags);\n       OB_PUTS (\"::\");\n-      dump_decl (TYPENAME_TYPE_FULLNAME (t), v);\n+      dump_decl (TYPENAME_TYPE_FULLNAME (t), flags);\n       break;\n \n     case TYPEOF_TYPE:\n       OB_PUTS (\"__typeof (\");\n-      dump_expr (TYPE_FIELDS (t), 1);\n+      dump_expr (TYPE_FIELDS (t), flags & ~TS_EXPR_PARENS);\n       OB_PUTC (')');\n       break;\n \n     default:\n       sorry (\"`%s' not supported by dump_type\",\n \t     tree_code_name[(int) TREE_CODE (t)]);\n+      /* Fall through to error. */\n+\n+    case ERROR_MARK:\n+      OB_PUTS (\"{typeerror}\");\n+      break;\n     }\n }\n \n+/* Return the name of the supplied aggregate, or enumeral type.  */\n+\n static const char *\n aggr_variety (t)\n      tree t;\n@@ -361,50 +396,59 @@ aggr_variety (t)\n     return \"struct\";\n }\n \n-static void\n-dump_type (t, v)\n-     tree t;\n-     int v;\t\t\t/* verbose? */\n-{\n-  dump_type_real (t, v, 0);\n-}\n-\n-/* Print out a class declaration, in the form `class foo'.  */\n+/* Print out a class declaration T under the control of FLAGS,\n+   in the form `class foo'.  */\n \n static void\n-dump_aggr_type (t, v, canonical_name)\n+dump_aggr_type (t, flags)\n      tree t;\n-     int v;\t\t\t/* verbose? */\n-     int canonical_name;\n+     enum tree_string_flags flags;\n {\n   tree name;\n   const char *variety = aggr_variety (t);\n+  int typdef = 0;\n+  int tmplate = 0;\n \n   dump_qualifiers (t, after);\n \n-  if (v > 0)\n+  if (flags & TS_AGGR_TAGS)\n     {\n       OB_PUTCP (variety);\n       OB_PUTC (' ');\n     }\n   \n-  name = TYPE_NAME (canonical_name ? TYPE_MAIN_VARIANT (t) : t);\n+  if (flags & TS_CHASE_TYPEDEFS)\n+    t = TYPE_MAIN_VARIANT (t);\n \n-  if (name && CP_DECL_CONTEXT (name) != global_namespace)\n+  name = TYPE_NAME (t);\n+\n+  if (name)\n     {\n-      /* FUNCTION_DECL or RECORD_TYPE */\n-      dump_decl (DECL_CONTEXT (name), 0);\n-      OB_PUTC2 (':', ':');\n+      typdef = !DECL_ARTIFICIAL (name);\n+      tmplate = !typdef && TREE_CODE (t) != ENUMERAL_TYPE\n+                && TYPE_LANG_SPECIFIC (t) && CLASSTYPE_TEMPLATE_INFO (t)\n+                && (CLASSTYPE_TEMPLATE_SPECIALIZATION (t)\n+                    || TREE_CODE (CLASSTYPE_TI_TEMPLATE (t)) != TEMPLATE_DECL\n+                    || DECL_TEMPLATE_SPECIALIZATION (CLASSTYPE_TI_TEMPLATE (t))\n+                    || PRIMARY_TEMPLATE_P (CLASSTYPE_TI_TEMPLATE (t)));\n+      dump_scope (CP_DECL_CONTEXT (name), flags | TS_FUNC_SCOPE);\n+      if (tmplate)\n+        {\n+          /* Because the template names are mangled, we have to locate\n+             the most general template, and use that name.  */\n+          tree tpl = CLASSTYPE_TI_TEMPLATE (t);\n+          \n+          while (DECL_TEMPLATE_INFO (tpl))\n+            tpl = DECL_TI_TEMPLATE (tpl);\n+          name = tpl;\n+        }\n+      name = DECL_NAME (name);\n     }\n \n-  /* kludge around weird behavior on g++.brendan/line1.C */\n-  if (name && TREE_CODE (name) != IDENTIFIER_NODE)\n-    name = DECL_NAME (name);\n-\n   if (name == 0 || ANON_AGGRNAME_P (name))\n     {\n       OB_PUTS (\"{anonymous\");\n-      if (!v)\n+      if (!(flags & TS_AGGR_TAGS))\n \t{\n \t  OB_PUTC (' ');\n \t  OB_PUTCP (variety);\n@@ -413,6 +457,10 @@ dump_aggr_type (t, v, canonical_name)\n     }\n   else\n     OB_PUTID (name);\n+  if (tmplate)\n+    dump_template_parms (TYPE_TEMPLATE_INFO (t),\n+                         !CLASSTYPE_USE_TEMPLATE (t),\n+                         flags & ~TS_TEMPLATE_PREFIX);\n }\n \n /* Dump into the obstack the initial part of the output for a given type.\n@@ -424,14 +472,18 @@ dump_aggr_type (t, v, canonical_name)\n    deal with prefix and suffix.\n \n    Arrays must also do this for DECL nodes, like int a[], and for things like\n-   int *[]&.  */\n+   int *[]&.  \n+   \n+   Return indicates how you should pad an object name after this. I.e. you\n+   want to pad non-*, non-& cores, but not pad * or & types.  */\n \n-static void\n-dump_type_prefix (t, v, canonical_name)\n+static enum pad\n+dump_type_prefix (t, flags)\n      tree t;\n-     int v;\t\t\t/* verbosity */\n-     int canonical_name;\n+     enum tree_string_flags flags;\n {\n+  enum pad padding = before;\n+  \n   if (TYPE_PTRMEMFUNC_P (t))\n     {\n       t = TYPE_PTRMEMFUNC_FN_TYPE (t);\n@@ -445,73 +497,60 @@ dump_type_prefix (t, v, canonical_name)\n       {\n \ttree sub = TREE_TYPE (t);\n \t\n-\tdump_type_prefix (sub, v, canonical_name);\n+\tpadding = dump_type_prefix (sub, flags);\n \t/* A tree for a member pointer looks like pointer to offset,\n \t   so let the OFFSET_TYPE case handle it.  */\n \tif (!TYPE_PTRMEM_P (t))\n \t  {\n-\t    switch (TREE_CODE (sub))\n-\t      {\n-\t\t/* We don't want int ( *)() */\n-\t      case FUNCTION_TYPE:\n-\t      case METHOD_TYPE:\n-\t\tbreak;\n-\t\t\n-\t      case ARRAY_TYPE:\n-\t\tOB_PUTC2 (' ', '(');\n-\t\tbreak;\n-\n-\t      case POINTER_TYPE:\n-\t\t/* We don't want \"char * *\" */\n-\t\tif (TYPE_QUALS (sub) == TYPE_UNQUALIFIED)\n-\t\t  break;\n-\t\t/* But we do want \"char *const *\" */\n-\t\t\n-\t      default:\n-\t\tOB_PUTC (' ');\n-\t      }\n-\t    if (TREE_CODE (t) == POINTER_TYPE)\n-\t      OB_PUTC ('*');\n-\t    else\n-\t      OB_PUTC ('&');\n-\t    dump_qualifiers (t, none);\n+\t    if (padding != none)\n+\t      OB_PUTC (' ');\n+\t    if (TREE_CODE (sub) == ARRAY_TYPE)\n+\t      OB_PUTC ('(');\n+            OB_PUTC (\"&*\"[TREE_CODE (t) == POINTER_TYPE]);\n+\t    padding = dump_qualifiers (t, none);\n \t  }\n       }\n       break;\n \n     case OFFSET_TYPE:\n     offset_type:\n-      dump_type_prefix (TREE_TYPE (t), v, canonical_name);\n+      padding = dump_type_prefix (TREE_TYPE (t), flags);\n       if (TREE_CODE (t) == OFFSET_TYPE)\t/* pmfs deal with this in d_t_p */\n \t{\n-\t  OB_PUTC (' ');\n-\t  dump_type_real (TYPE_OFFSET_BASETYPE (t), 0, canonical_name);\n-\t  OB_PUTC2 (':', ':');\n+\t  if (padding != none)\n+\t    OB_PUTC (' ');\n+\t  dump_type (TYPE_OFFSET_BASETYPE (t), flags);\n+\t  OB_PUTS (\"::\");\n \t}\n       OB_PUTC ('*');\n-      dump_qualifiers (t, none);\n+      padding = dump_qualifiers (t, none);\n       break;\n \n       /* Can only be reached through function pointer -- this would not be\n          correct if FUNCTION_DECLs used it.  */\n     case FUNCTION_TYPE:\n-      dump_type_prefix (TREE_TYPE (t), v, canonical_name);\n-      OB_PUTC2 (' ', '(');\n+      padding = dump_type_prefix (TREE_TYPE (t), flags);\n+      if (padding != none)\n+        OB_PUTC (' ');\n+      OB_PUTC ('(');\n+      padding = none;\n       break;\n \n     case METHOD_TYPE:\n-      dump_type_prefix (TREE_TYPE (t), v, canonical_name);\n-      OB_PUTC2 (' ', '(');\n-      dump_aggr_type (TYPE_METHOD_BASETYPE (t), 0, canonical_name);\n-      OB_PUTC2 (':', ':');\n+      padding = dump_type_prefix (TREE_TYPE (t), flags);\n+      if (padding != none)\n+        OB_PUTC (' ');\n+      OB_PUTC ('(');\n+      padding = none;\n+      dump_aggr_type (TYPE_METHOD_BASETYPE (t), flags);\n+      OB_PUTS (\"::\");\n       break;\n \n     case ARRAY_TYPE:\n-      dump_type_prefix (TREE_TYPE (t), v, canonical_name);\n+      padding = dump_type_prefix (TREE_TYPE (t), flags);\n       break;\n \n     case ENUMERAL_TYPE:\n-    case ERROR_MARK:\n     case IDENTIFIER_NODE:\n     case INTEGER_TYPE:\n     case BOOLEAN_TYPE:\n@@ -527,20 +566,28 @@ dump_type_prefix (t, v, canonical_name)\n     case VOID_TYPE:\n     case TYPENAME_TYPE:\n     case COMPLEX_TYPE:\n-      dump_type_real (t, v, canonical_name);\n+      dump_type (t, flags);\n+      padding = before;\n       break;\n       \n     default:\n       sorry (\"`%s' not supported by dump_type_prefix\",\n \t     tree_code_name[(int) TREE_CODE (t)]);\n+\n+    case ERROR_MARK:\n+      OB_PUTS (\"{typeprefixerror}\");\n+      break;\n     }\n+  return padding;\n }\n \n+/* Dump the suffix of type T, under control of FLAGS.  This is the part\n+   which appears after the identifier (or function parms).  */\n+\n static void\n-dump_type_suffix (t, v, canonical_name)\n+dump_type_suffix (t, flags)\n      tree t;\n-     int v;\t\t\t/* verbose? */\n-     int canonical_name;\n+     enum tree_string_flags flags;\n {\n   if (TYPE_PTRMEMFUNC_P (t))\n     t = TYPE_PTRMEMFUNC_FN_TYPE (t);\n@@ -552,7 +599,7 @@ dump_type_suffix (t, v, canonical_name)\n     case OFFSET_TYPE:\n       if (TREE_CODE (TREE_TYPE (t)) == ARRAY_TYPE)\n \tOB_PUTC (')');\n-      dump_type_suffix (TREE_TYPE (t), v, canonical_name);\n+      dump_type_suffix (TREE_TYPE (t), flags);\n       break;\n \n       /* Can only be reached through function pointer */\n@@ -567,13 +614,13 @@ dump_type_suffix (t, v, canonical_name)\n \n \t/* Function pointers don't have default args.  Not in standard C++,\n \t   anyway; they may in g++, but we'll just pretend otherwise.  */\n-\tdump_parameters (arg, 0, canonical_name);\n+\tdump_parameters (arg, flags & ~TS_PARM_DEFAULTS);\n \n \tif (TREE_CODE (t) == METHOD_TYPE)\n \t  dump_qualifiers\n \t    (TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (t))), before);\n-\tdump_type_suffix (TREE_TYPE (t), v, canonical_name);\n-\tdump_exception_spec (TYPE_RAISES_EXCEPTIONS (t), canonical_name);\n+\tdump_type_suffix (TREE_TYPE (t), flags);\n+\tdump_exception_spec (TYPE_RAISES_EXCEPTIONS (t), flags);\n \tbreak;\n       }\n \n@@ -584,18 +631,19 @@ dump_type_suffix (t, v, canonical_name)\n \t  if (TREE_CODE (TYPE_MAX_VALUE (TYPE_DOMAIN (t))) == INTEGER_CST)\n \t    OB_PUTI (TREE_INT_CST_LOW (TYPE_MAX_VALUE (TYPE_DOMAIN (t))) + 1);\n \t  else if (TREE_CODE (TYPE_MAX_VALUE (TYPE_DOMAIN (t))) == MINUS_EXPR)\n-\t    dump_expr (TREE_OPERAND (TYPE_MAX_VALUE (TYPE_DOMAIN (t)), 0), 0);\n+\t    dump_expr (TREE_OPERAND (TYPE_MAX_VALUE (TYPE_DOMAIN (t)), 0),\n+\t               flags & ~TS_EXPR_PARENS);\n \t  else\n \t    dump_expr (fold (build_binary_op\n \t\t\t     (PLUS_EXPR, TYPE_MAX_VALUE (TYPE_DOMAIN (t)),\n-\t\t\t      integer_one_node)), 0);\n+\t\t\t      integer_one_node)),\n+\t               flags & ~TS_EXPR_PARENS);\n \t}\n       OB_PUTC (']');\n-      dump_type_suffix (TREE_TYPE (t), v, canonical_name);\n+      dump_type_suffix (TREE_TYPE (t), flags);\n       break;\n       \n     case ENUMERAL_TYPE:\n-    case ERROR_MARK:\n     case IDENTIFIER_NODE:\n     case INTEGER_TYPE:\n     case BOOLEAN_TYPE:\n@@ -616,6 +664,11 @@ dump_type_suffix (t, v, canonical_name)\n     default:\n       sorry (\"`%s' not supported by dump_type_suffix\",\n \t     tree_code_name[(int) TREE_CODE (t)]);\n+\n+    case ERROR_MARK:\n+      /* Don't mark it here, we should have already done in\n+         dump_type_prefix.  */\n+      break;\n     }\n }\n \n@@ -674,68 +727,65 @@ dump_global_iord (t)\n }\n \n static void\n-dump_simple_decl (t, type, v)\n+dump_simple_decl (t, type, flags)\n      tree t;\n      tree type;\n-     int v;\n+     enum tree_string_flags flags;\n {\n-  if (v > 0)\n+  if (flags & TS_DECL_TYPE)\n     {\n-      dump_type_prefix (type, v, 0);\n-      OB_PUTC (' ');\n-    }\n-  if (interesting_scope_p (DECL_CONTEXT (t)))\n-    {\n-      dump_decl (DECL_CONTEXT (t), 0);\n-      OB_PUTC2 (':',':');\n+      if (dump_type_prefix (type, flags) != none)\n+        OB_PUTC (' ');\n     }\n+  if (!DECL_INITIAL (t) || TREE_CODE (DECL_INITIAL (t)) != TEMPLATE_PARM_INDEX)\n+    dump_scope (CP_DECL_CONTEXT (t), flags);\n   if (DECL_NAME (t))\n-    dump_decl (DECL_NAME (t), v);\n+    dump_decl (DECL_NAME (t), flags);\n   else\n     OB_PUTS (\"{anon}\");\n-  if (v > 0)\n-    dump_type_suffix (type, v, 0);\n+  if (flags & TS_DECL_TYPE)\n+    dump_type_suffix (type, flags);\n }\n \n+/* Dump a human readable string for the decl T under control of FLAGS.  */\n+\n static void\n-dump_decl (t, v)\n+dump_decl (t, flags)\n      tree t;\n-     int v;\t\t\t/* verbosity */\n+     enum tree_string_flags flags;\n {\n   if (t == NULL_TREE)\n     return;\n \n   switch (TREE_CODE (t))\n     {\n-    case ERROR_MARK:\n-      OB_PUTS (\" /* decl error */ \");\n-      break;\n-\n     case TYPE_DECL:\n       {\n \t/* Don't say 'typedef class A' */\n         if (DECL_ARTIFICIAL (t))\n \t  {\n-\t    if (v > 0 && TREE_CODE (TREE_TYPE (t)) == TEMPLATE_TYPE_PARM)\n+\t    if ((flags & TS_DECL_TYPE)\n+\t        && TREE_CODE (TREE_TYPE (t)) == TEMPLATE_TYPE_PARM)\n \t      /* Say `class T' not just `T'. */\n \t      OB_PUTS (\"class \");\n \n-\t    dump_type (TREE_TYPE (t), v);\n+\t    dump_type (TREE_TYPE (t), flags);\n \t    break;\n \t  }\n       }\n-      if (v > 0)\n+      if (flags & TS_DECORATE)\n \tOB_PUTS (\"typedef \");\n       dump_simple_decl (t, DECL_ORIGINAL_TYPE (t) \n-\t\t\t? DECL_ORIGINAL_TYPE (t) : TREE_TYPE (t), v);\n+\t\t\t? DECL_ORIGINAL_TYPE (t) : TREE_TYPE (t),\n+\t                flags);\n       break;\n       \n     case VAR_DECL:\n       if (DECL_NAME (t) && VTABLE_NAME_P (DECL_NAME (t)))\n \t{\n \t  OB_PUTS (\"vtable for \");\n \t  if (TYPE_P (DECL_CONTEXT (t)))\n-\t    dump_type (DECL_CONTEXT (t), v);\n+\t    dump_type (DECL_CONTEXT (t), flags);\n \t  else\n \t    /* This case can arise with -fno-vtable-thunks.  See\n \t       expand_upcast_fixups.  It's not clear what to print\n@@ -746,40 +796,35 @@ dump_decl (t, v)\n       /* else fall through */\n     case FIELD_DECL:\n     case PARM_DECL:\n-      dump_simple_decl (t, TREE_TYPE (t), v);\n+      dump_simple_decl (t, TREE_TYPE (t), flags);\n       break;\n \n     case NAMESPACE_DECL:\n-      if (CP_DECL_CONTEXT (t) != global_namespace)\n-\t{\n-\t  dump_decl (DECL_CONTEXT (t), v);\n-\t  OB_PUTC2 (':',':');\n-\t}\n+      dump_scope (CP_DECL_CONTEXT (t), flags);\n       if (DECL_NAME (t) == anonymous_namespace_name)\n \tOB_PUTS (\"{anonymous}\");\n       else\n \tOB_PUTID (DECL_NAME (t));\n       break;\n \n     case SCOPE_REF:\n-      dump_decl (TREE_OPERAND (t, 0), 0);\n+      dump_decl (TREE_OPERAND (t, 0), flags & ~TS_DECL_TYPE);\n       OB_PUTS (\"::\");\n-      dump_decl (TREE_OPERAND (t, 1), 0);\n+      dump_decl (TREE_OPERAND (t, 1), flags);\n       break;      \n \n     case ARRAY_REF:\n-      dump_decl (TREE_OPERAND (t, 0), v);\n+      dump_decl (TREE_OPERAND (t, 0), flags);\n       OB_PUTC ('[');\n-      dump_decl (TREE_OPERAND (t, 1), v);\n+      dump_decl (TREE_OPERAND (t, 1), flags);\n       OB_PUTC (']');\n       break;\n \n-      /* So that we can do dump_decl in dump_aggr_type and have it work for\n-\t both class and function scope.  */\n+      /* So that we can do dump_decl on an aggr type.  */\n     case RECORD_TYPE:\n     case UNION_TYPE:\n     case ENUMERAL_TYPE:\n-      dump_type (t, v);\n+      dump_type (t, flags);\n       break;\n \n     case TYPE_EXPR:\n@@ -795,13 +840,13 @@ dump_decl (t, v)\n \t    && DECL_LANGUAGE (f) == lang_cplusplus)\n \t  {\n \t    OB_PUTC ('~');\n-\t    dump_decl (DECL_NAME (f), 0);\n+\t    dump_decl (DECL_NAME (f), flags);\n \t  }\n \telse if (IDENTIFIER_TYPENAME_P (t))\n \t  {\n \t    OB_PUTS (\"operator \");\n \t    /* Not exactly IDENTIFIER_TYPE_VALUE.  */\n-\t    dump_type (TREE_TYPE (t), 0);\n+\t    dump_type (TREE_TYPE (t), flags);\n \t    break;\n \t  }\n \telse if (IDENTIFIER_OPNAME_P (t))\n@@ -824,77 +869,17 @@ dump_decl (t, v)\n \tdump_global_iord (DECL_ASSEMBLER_NAME (t));\n       else if (! DECL_LANG_SPECIFIC (t))\n \tOB_PUTS (\"{internal}\");\n+      else if (flags & TS_PEDANTIC_NAME)\n+        dump_function_decl (t, flags | TS_FUNC_NORETURN | TS_DECL_TYPE);\n       else\n-\tdump_function_decl (t, v);\n+        dump_function_decl (t, flags);\n       break;\n \n     case TEMPLATE_DECL:\n-      {\n-\ttree orig_args = DECL_TEMPLATE_PARMS (t);\n-\ttree args;\n-\tint i; \n-\tfor (args = orig_args = nreverse (orig_args); \n-\t     args;\n-\t     args = TREE_CHAIN (args))\n-\t  {\n-\t    int len = TREE_VEC_LENGTH (TREE_VALUE (args));\n-\n-\t    OB_PUTS (\"template <\");\n-\t    for (i = 0; i < len; i++)\n-\t      {\n-\t\ttree arg = TREE_VEC_ELT (TREE_VALUE (args), i);\n-\t\ttree defval = TREE_PURPOSE (arg);\n-\t\targ = TREE_VALUE (arg);\n-\t\tif (TREE_CODE (arg) == TYPE_DECL)\n-\t\t  {\n-\t\t    if (DECL_NAME (arg))\n-\t\t      {\n-\t\t\tOB_PUTS (\"class \");\n-\t\t\tOB_PUTID (DECL_NAME (arg));\n-\t\t      }\n-\t\t    else\n-\t\t      OB_PUTS (\"class\");\n-\t\t  }\n-\t\telse\n-\t\t  dump_decl (arg, 1);\n-\t\t\n-\t\tif (defval)\n-\t\t  {\n-\t\t    OB_PUTS (\" = \");\n-\t\t    if (TREE_CODE (arg) == TYPE_DECL\n-\t\t\t|| TREE_CODE (arg) == TEMPLATE_DECL)\n-\t\t      dump_type (defval, 1);\n-\t\t    else\n-\t\t      dump_expr (defval, 1);\n-\t\t  }\n-\t\t\n-\t\tOB_PUTC2 (',', ' ');\n-\t      }\n-\t    if (len != 0)\n-\t      OB_UNPUT (2);\n-\t    OB_END_TEMPLATE_ID ();\n-\t    OB_PUTC (' ');\n-\t  }\n-\tnreverse(orig_args);\n-\n-\tif (TREE_CODE (DECL_TEMPLATE_RESULT (t)) == TYPE_DECL)\n-\t  dump_type (TREE_TYPE (t), v);\n-\telse if (TREE_CODE (DECL_TEMPLATE_RESULT (t)) == VAR_DECL)\n-\t  dump_decl (DECL_TEMPLATE_RESULT (t), v);\n-\telse if (TREE_TYPE (t) == NULL_TREE)\n-\t   my_friendly_abort (353);\n-\telse switch (NEXT_CODE (t))\n-\t  {\n-\t  case METHOD_TYPE:\n-\t  case FUNCTION_TYPE:\n-\t    dump_function_decl (t, v);\n-\t    break;\n-\n-\t  default:\n-\t    /* This case can occur with some illegal code.  */\n-\t    dump_type (TREE_TYPE (t), v);\n-\t  }\n-      }\n+      if (flags & TS_PEDANTIC_NAME)\n+        dump_template_decl (t, flags | TS_FUNC_NORETURN | TS_DECL_TYPE);\n+      else\n+        dump_template_decl (t, flags);\n       break;\n \n     case TEMPLATE_ID_EXPR:\n@@ -903,20 +888,20 @@ dump_decl (t, v)\n \ttree name = TREE_OPERAND (t, 0);\n \tif (is_overloaded_fn (name))\n \t  name = DECL_NAME (get_first_fn (name));\n-\tdump_decl (name, v);\n+\tdump_decl (name, flags);\n \tOB_PUTC ('<');\n \tfor (args = TREE_OPERAND (t, 1); args; args = TREE_CHAIN (args))\n \t  {\n-            dump_template_value (TREE_VALUE (args), 0, 0);\n+\t    dump_template_value (TREE_VALUE (args), flags);\n \t    if (TREE_CHAIN (args))\n-\t      OB_PUTC2 (',', ' ');\n+\t      OB_PUTS (\", \");\n \t  }\n \tOB_END_TEMPLATE_ID ();\n       }\n       break;\n \n     case LOOKUP_EXPR:\n-      dump_decl (TREE_OPERAND (t, 0), v);\n+      dump_decl (TREE_OPERAND (t, 0), flags);\n       break;\n \n     case LABEL_DECL:\n@@ -927,52 +912,133 @@ dump_decl (t, v)\n       if ((TREE_TYPE (t) != NULL_TREE && NEXT_CODE (t) == ENUMERAL_TYPE)\n \t  || (DECL_INITIAL (t) &&\n \t      TREE_CODE (DECL_INITIAL (t)) == TEMPLATE_PARM_INDEX))\n-\tdump_simple_decl (t, TREE_TYPE (t), v);\n+\tdump_simple_decl (t, TREE_TYPE (t), flags);\n       else if (DECL_NAME (t))\n-\tdump_decl (DECL_NAME (t), v);\n+\tdump_decl (DECL_NAME (t), flags);\n       else if (DECL_INITIAL (t))\n-\tdump_expr (DECL_INITIAL (t), 0);\n+\tdump_expr (DECL_INITIAL (t), flags | TS_EXPR_PARENS);\n       else\n \tOB_PUTS (\"enumerator\");\n       break;\n \n     case USING_DECL:\n       OB_PUTS (\"using \");\n-      dump_type (DECL_INITIAL (t), 0);\n+      dump_type (DECL_INITIAL (t), flags);\n       OB_PUTS (\"::\");\n       OB_PUTID (DECL_NAME (t));\n       break;\n \n     default:\n       sorry (\"`%s' not supported by dump_decl\",\n \t     tree_code_name[(int) TREE_CODE (t)]);\n+      /* Fallthrough to error.  */\n+\n+    case ERROR_MARK:\n+      OB_PUTS (\"{declerror}\");\n+      break;\n+    }\n+}\n+\n+/* Dump a template declaration T under control of FLAGS. This means the\n+   'template <...> leaders plus the 'class X' or 'void fn(...)' part.  */\n+\n+static void\n+dump_template_decl (t, flags)\n+     tree t;\n+     enum tree_string_flags flags;\n+{\n+  tree orig_args = DECL_TEMPLATE_PARMS (t);\n+  tree args;\n+  int i; \n+  \n+  if (flags & TS_TEMPLATE_PREFIX)\n+    {\n+      for (args = orig_args = nreverse (orig_args); \n+           args;\n+           args = TREE_CHAIN (args))\n+        {\n+          int len = TREE_VEC_LENGTH (TREE_VALUE (args));\n+          \n+          OB_PUTS (\"template <\");\n+          for (i = 0; i < len; i++)\n+            {\n+\t      tree arg = TREE_VEC_ELT (TREE_VALUE (args), i);\n+\t      tree defval = TREE_PURPOSE (arg);\n+\t      arg = TREE_VALUE (arg);\n+              if (i)\n+                OB_PUTS (\", \");\n+\t      if (TREE_CODE (arg) == TYPE_DECL)\n+\t        {\n+\t          if (DECL_NAME (arg))\n+\t            {\n+\t\t      OB_PUTS (\"class \");\n+\t\t      OB_PUTID (DECL_NAME (arg));\n+\t            }\n+\t          else\n+\t            OB_PUTS (\"class\");\n+\t        }\n+\t      else\n+\t        dump_decl (arg, flags | TS_DECL_TYPE);\n+\t      \n+\t      if (defval)\n+\t        {\n+\t          OB_PUTS (\" = \");\n+\t          if (TREE_CODE (arg) == TYPE_DECL\n+\t\t      || TREE_CODE (arg) == TEMPLATE_DECL)\n+\t            dump_type (defval, flags);\n+\t          else\n+\t            dump_expr (defval, flags | TS_EXPR_PARENS);\n+\t        }\n+            }\n+          OB_END_TEMPLATE_ID ();\n+          OB_PUTC (' ');\n+        }\n+      nreverse(orig_args);\n+      /* If we've shown the template<args> prefix, we'd better show the\n+       * decl's type too.  */\n+      flags |= TS_DECL_TYPE;\n+    }\n+  if (TREE_CODE (DECL_TEMPLATE_RESULT (t)) == TYPE_DECL)\n+    dump_type (TREE_TYPE (t),\n+               ((flags & ~TS_AGGR_TAGS) | TS_TEMPLATE_PLAIN\n+                | (flags & TS_DECL_TYPE ? TS_AGGR_TAGS : 0)));\n+  else if (TREE_CODE (DECL_TEMPLATE_RESULT (t)) == VAR_DECL)\n+    dump_decl (DECL_TEMPLATE_RESULT (t), flags | TS_TEMPLATE_PLAIN);\n+  else if (TREE_TYPE (t) == NULL_TREE)\n+    my_friendly_abort (353);\n+  else\n+    switch (NEXT_CODE (t))\n+    {\n+      case METHOD_TYPE:\n+      case FUNCTION_TYPE:\n+        dump_function_decl (t, flags | TS_TEMPLATE_PLAIN);\n+        break;\n+      default:\n+        /* This case can occur with some illegal code.  */\n+        dump_type (TREE_TYPE (t),\n+                   (flags & ~TS_AGGR_TAGS) | TS_TEMPLATE_PLAIN\n+                   | (flags & TS_DECL_TYPE ? TS_AGGR_TAGS : 0));\n     }\n }\n \n /* Pretty print a function decl. There are several ways we want to print a\n-   function declaration. We use V to tell us what.\n-     V    - 01 23\n-   args   - ++ ++\n-   retval - -+ ++\n-   default- -+ -+\n-   throw  - -- ++\n+   function declaration. The TS_FUNC bits in FLAGS tells us how to behave.\n    As cp_error can only apply the '#' flag once to give 0 and 1 for V, there\n    is %D which doesn't print the throw specs, and %F which does. */\n \n static void\n-dump_function_decl (t, v)\n+dump_function_decl (t, flags)\n      tree t;\n-     int v;\n+     enum tree_string_flags flags;\n {\n-  tree name;\n   tree fntype;\n   tree parmtypes;\n   tree cname = NULL_TREE;\n+  int show_return = !(flags & TS_FUNC_NORETURN) && (flags & TS_DECL_TYPE);\n \n   if (TREE_CODE (t) == TEMPLATE_DECL)\n     t = DECL_TEMPLATE_RESULT (t);\n \n-  name = DECL_ASSEMBLER_NAME (t);\n   fntype = TREE_TYPE (t);\n   parmtypes = TYPE_ARG_TYPES (fntype);\n \n@@ -983,90 +1049,86 @@ dump_function_decl (t, v)\n   else if (TREE_CODE (fntype) == METHOD_TYPE)\n     cname = TREE_TYPE (TREE_VALUE (parmtypes));\n \n-  /* Print the return type.  */\n-  if (v > 0)\n+  if (!(flags & TS_DECORATE))\n+    /* OK */;\n+  else if (DECL_STATIC_FUNCTION_P (t))\n+    OB_PUTS (\"static \");\n+  else if (TYPE_VIRTUAL_P (t))\n+    OB_PUTS (\"virtual \");\n+  \n+  /* Print the return type?  */\n+  if (show_return)\n+    show_return = !DECL_CONV_FN_P (t)  && !DECL_CONSTRUCTOR_P (t)\n+                  && !DECL_DESTRUCTOR_P (t);\n+  if (show_return)\n     {\n-      if (DECL_STATIC_FUNCTION_P (t))\n-\tOB_PUTS (\"static \");\n-    \n-      if (! DECL_CONV_FN_P (t)\n-\t  && ! DECL_CONSTRUCTOR_P (t)\n-\t  && ! DECL_DESTRUCTOR_P (t))\n-\t{\n-\t  dump_type_prefix (TREE_TYPE (fntype), 0, 0);\n-\t  OB_PUTC (' ');\n-\t}\n+      if (dump_type_prefix (TREE_TYPE (fntype), flags) != none)\n+        OB_PUTC (' ');\n     }\n \n   /* Print the function name.  */\n   if (cname)\n     {\n-      dump_type (cname, 0);\n-      OB_PUTC2 (':', ':');\n-      if (TREE_CODE (fntype) == METHOD_TYPE && parmtypes)\n-\tparmtypes = TREE_CHAIN (parmtypes);\n-      if (DECL_CONSTRUCTOR_FOR_VBASE_P (t))\n-\t/* Skip past \"in_charge\" identifier.  */\n-\tparmtypes = TREE_CHAIN (parmtypes);\n-    }\n-  else if (CP_DECL_CONTEXT (t) != global_namespace)\n-    {\n-      dump_decl (DECL_CONTEXT (t), 0);\n-      OB_PUTC2 (':',':');\n+      dump_type (cname, flags);\n+      OB_PUTS (\"::\");\n     }\n+  else\n+    dump_scope (CP_DECL_CONTEXT (t), flags);\n \n-  if (DESTRUCTOR_NAME_P (name) && DECL_LANGUAGE (t) == lang_cplusplus)\n-    parmtypes = TREE_CHAIN (parmtypes);\n+  dump_function_name (t, flags);\n   \n-  dump_function_name (t);\n-\n-  /* If V is negative, we don't print the argument types.  */\n-  if (v < 0)\n+  if (!(flags & TS_DECL_TYPE))\n     return;\n-\n-  dump_parameters (parmtypes, v & 1, 0);\n+  if (TREE_CODE (fntype) == METHOD_TYPE && parmtypes)\n+    /* Skip \"this\" parameter.  */\n+    parmtypes = TREE_CHAIN (parmtypes);\n+    \n+  if (DECL_DESTRUCTOR_P (t) || DECL_CONSTRUCTOR_FOR_VBASE_P (t))\n+    /* Skip past \"in_charge\" identifier.  */\n+    parmtypes = TREE_CHAIN (parmtypes);\n+  \n+  dump_parameters (parmtypes, flags);\n   \n-  if (v && ! DECL_CONV_FN_P (t))\n-    dump_type_suffix (TREE_TYPE (fntype), 1, 0);\n+  if (show_return)\n+    dump_type_suffix (TREE_TYPE (fntype), flags);\n \n   if (TREE_CODE (fntype) == METHOD_TYPE)\n     dump_qualifiers (TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (fntype))),\n \t\t     before);\n   \n-  if (v >= 2)\n-    dump_exception_spec (TYPE_RAISES_EXCEPTIONS (fntype), 0);\n+  if (flags & TS_FUNC_THROW)\n+    dump_exception_spec (TYPE_RAISES_EXCEPTIONS (fntype), flags);\n }\n \n-/* Print a parameter list. V indicates if we show default values or not. If\n-   these are for a member function, the member object ptr\n-   (and any other hidden args) should have already been removed. */\n+/* Print a parameter list. If this is for a member function, the\n+   member object ptr (and any other hidden args) should have\n+   already been removed. */\n \n static void\n-dump_parameters (parmtypes, v, canonical_name)\n+dump_parameters (parmtypes, flags)\n      tree parmtypes;\n-     int v;\n-     int canonical_name;\n+     enum tree_string_flags flags;\n {\n   int first;\n-  OB_PUTC ('(');\n+  OB_PUTS (\" (\");\n \n   for (first = 1; parmtypes != void_list_node;\n        parmtypes = TREE_CHAIN (parmtypes))\n     {\n       if (!first)\n-        OB_PUTC2 (',', ' ');\n+        OB_PUTS (\", \");\n       first = 0;\n       if (!parmtypes)\n         {\n           OB_PUTS (\"...\");\n           break;\n         }\n-      dump_type_real (TREE_VALUE (parmtypes), 0, canonical_name);\n+      dump_type (TREE_VALUE (parmtypes), flags);\n       \n-      if (TREE_PURPOSE (parmtypes) && v)\n+      if ((flags & TS_PARM_DEFAULTS) && TREE_PURPOSE (parmtypes))\n         {\n           OB_PUTS (\" = \");\n-          dump_expr (TREE_PURPOSE (parmtypes), 0);\n+          dump_expr (TREE_PURPOSE (parmtypes), flags | TS_EXPR_PARENS);\n         }\n     }\n \n@@ -1076,21 +1138,21 @@ dump_parameters (parmtypes, v, canonical_name)\n /* Print an exception specification. T is the exception specification. */\n \n static void\n-dump_exception_spec (t, canonical_name)\n+dump_exception_spec (t, flags)\n      tree t;\n-     int canonical_name;\n+     enum tree_string_flags flags;\n {\n   if (t)\n     {\n       OB_PUTS (\" throw (\");\n       if (TREE_VALUE (t) != NULL_TREE)\n         while (1)\n           {\n-            dump_type_real (TREE_VALUE (t), 0, canonical_name);\n+            dump_type (TREE_VALUE (t), flags);\n             t = TREE_CHAIN (t);\n             if (!t)\n               break;\n-            OB_PUTC2 (',', ' ');\n+            OB_PUTS (\", \");\n           }\n       OB_PUTC (')');\n     }\n@@ -1100,15 +1162,16 @@ dump_exception_spec (t, canonical_name)\n    and destructors properly.  */\n \n static void\n-dump_function_name (t)\n+dump_function_name (t, flags)\n      tree t;\n+     enum tree_string_flags flags;\n {\n   tree name = DECL_NAME (t);\n \n   if (DECL_DESTRUCTOR_P (t))\n     {\n       OB_PUTC ('~');\n-      dump_decl (name, 0);\n+      dump_decl (name, TS_PLAIN);\n     }\n   else if (DECL_CONV_FN_P (t))\n     {\n@@ -1119,7 +1182,7 @@ dump_function_name (t)\n \t the types will be different, hence the TREE_TYPE field\n \t of the first name will be clobbered by the second.  */\n       OB_PUTS (\"operator \");\n-      dump_type (TREE_TYPE (TREE_TYPE (t)), 0);\n+      dump_type (TREE_TYPE (TREE_TYPE (t)), flags);\n     }\n   else if (IDENTIFIER_OPNAME_P (name))\n     {\n@@ -1128,66 +1191,118 @@ dump_function_name (t)\n       OB_PUTCP (name_string);\n     }\n   else\n-    dump_decl (name, 0);\n+    dump_decl (name, flags);\n \n-  if (DECL_LANG_SPECIFIC (t) && DECL_USE_TEMPLATE (t) \n-      && DECL_TEMPLATE_INFO (t)\n+  if (DECL_LANG_SPECIFIC (t) && DECL_TEMPLATE_INFO (t)\n       && (DECL_TEMPLATE_SPECIALIZATION (t) \n \t  || TREE_CODE (DECL_TI_TEMPLATE (t)) != TEMPLATE_DECL\n \t  || DECL_TEMPLATE_SPECIALIZATION (DECL_TI_TEMPLATE (t))\n \t  || PRIMARY_TEMPLATE_P (DECL_TI_TEMPLATE (t))))\n-    {\n-      tree args = DECL_TEMPLATE_INFO (t) ? DECL_TI_ARGS (t) : NULL_TREE; \n-      OB_PUTC ('<');\n+    dump_template_parms (DECL_TEMPLATE_INFO (t), !DECL_USE_TEMPLATE (t), flags);\n+}\n \n-      /* Be careful only to print things when we have them, so as not\n+/* Dump the template parameters from the template info INFO under control of\n+   FLAGS. PRIMARY indicates whether this is a primary template decl, or\n+   specialization (partial or complete). For partial specializations we show\n+   the specialized parameter values. For a primary template we show no\n+   decoration.  */\n+\n+static void\n+dump_template_parms (info, primary, flags)\n+     tree info;\n+     int primary;\n+     enum tree_string_flags flags;\n+{\n+  tree args = info ? TI_ARGS (info) : NULL_TREE;\n+  \n+  if (primary && flags & TS_TEMPLATE_PLAIN)\n+    return;\n+  flags &= ~(TS_AGGR_TAGS | TS_TEMPLATE_PLAIN);\n+  OB_PUTC ('<');\n+\n+  /* Be careful only to print things when we have them, so as not\n \t to crash producing error messages.  */\n-      if (args)\n-\t{\n-\t  if (TREE_CODE (args) == TREE_LIST)\n-\t    {\n-\t      tree arg;\n-\t      int need_comma = 0;\n-\t      \n-\t      for (arg = args; arg; arg = TREE_CHAIN (arg))\n-\t\t{\n-\t\t  tree a = TREE_VALUE (arg);\n-\t\t  \n-\t\t  if (need_comma)\n-\t\t    OB_PUTS (\", \");\n-\t\t  \n-\t\t  if (a)\n-                    dump_template_value (a, 0, 0);\n-\t\t  \n-\t\t  need_comma = 1;\n-\t\t}\n-\t    }\n-\t  else if (TREE_CODE (args) == TREE_VEC)\n-\t    {\n-\t      int i;\n-\t      int need_comma = 0;\n-\t      \n-\t      if (TREE_VEC_LENGTH (args) > 0\n-\t\t  && TREE_CODE (TREE_VEC_ELT (args, 0)) == TREE_VEC)\n-\t\targs = TREE_VEC_ELT (args, \n-\t\t\t\t     TREE_VEC_LENGTH (args) - 1);\n-\t      \n-\t      for (i = 0; i < TREE_VEC_LENGTH (args); i++)\n-\t\t{\n-\t\t  tree a = TREE_VEC_ELT (args, i);\n-\t\t  \n-\t\t  if (need_comma)\n-\t\t    OB_PUTS (\", \");\n-\t\t  \n-\t\t  if (a)\n-                    dump_template_value (a, 0, 0);\n-\t\t  \n-\t\t  need_comma = 1;\n-\t\t}\n-\t    }\n-\t}\n-      OB_END_TEMPLATE_ID ();\n+  if (args && !primary)\n+    {\n+      int len = 0;\n+      int ix = 0;\n+      int need_comma = 0;\n+      \n+      if (TREE_CODE (args) == TREE_VEC)\n+        {\n+          if (TREE_VEC_LENGTH (args) > 0\n+    \t      && TREE_CODE (TREE_VEC_ELT (args, 0)) == TREE_VEC)\n+    \t    args = TREE_VEC_ELT (args, TREE_VEC_LENGTH (args) - 1);\n+          \n+          len = TREE_VEC_LENGTH (args);\n+        }\n+      else if (TREE_CODE (args) == TREE_LIST)\n+        len = -1;\n+      while (ix != len && args)\n+        {\n+          tree arg;\n+          if (len >= 0)\n+            {\n+              arg = TREE_VEC_ELT (args, ix);\n+              ix++;\n+            }\n+          else\n+            {\n+              arg = TREE_VALUE (args);\n+              args = TREE_CHAIN (args);\n+            }\n+          if (need_comma)\n+            OB_PUTS (\", \");\n+              \n+          if (!arg)\n+            OB_PUTS (\"{tplparmerror}\");\n+          else\n+            dump_template_value (arg, flags);\n+          need_comma = 1;\n+        }\n+    }\n+  else if (flags & TS_PEDANTIC_NAME)\n+    {\n+      tree tpl = TI_TEMPLATE (info);\n+      tree parms = TREE_VALUE (DECL_TEMPLATE_PARMS (tpl));\n+      int len = TREE_VEC_LENGTH (parms);\n+      int ix;\n+      \n+      for (ix = 0; ix != len; ix++)\n+        {\n+          tree parm = TREE_VALUE (TREE_VEC_ELT (parms, ix));\n+          \n+          if (ix)\n+            OB_PUTS (\", \");\n+          if (TREE_CODE (parm) == TYPE_DECL)\n+            OB_PUTS (\"class\");\n+          else if (TREE_CODE (parm) == TEMPLATE_DECL)\n+            dump_decl (DECL_TEMPLATE_RESULT (parm), flags);\n+          else\n+            dump_type (TREE_TYPE (parm),\n+                       flags | TS_TEMPLATE_PARM);\n+        }\n+    }\n+  else if (primary)\n+    {\n+      tree tpl = TI_TEMPLATE (info);\n+      tree parms = DECL_TEMPLATE_PARMS (tpl);\n+      int len, ix;\n+      \n+      parms = TREE_CODE (parms) == TREE_LIST ? TREE_VALUE (parms) : NULL_TREE;\n+      len = parms ? TREE_VEC_LENGTH (parms) : 0;\n+      \n+      for (ix = 0; ix != len; ix++)\n+        {\n+          tree parm = TREE_VALUE (TREE_VEC_ELT (parms, ix));\n+\n+          if (ix)\n+            OB_PUTS (\", \");\n+          \n+          dump_decl (parm, flags & ~TS_DECL_TYPE);\n+        }\n     }\n+  OB_END_TEMPLATE_ID ();\n }\n \n static void\n@@ -1240,24 +1355,25 @@ dump_char (c)\n /* Print out a list of initializers (subr of dump_expr) */\n \n static void\n-dump_expr_list (l)\n+dump_expr_list (l, flags)\n      tree l;\n+     enum tree_string_flags flags;\n {\n   while (l)\n     {\n-      dump_expr (TREE_VALUE (l), 0);\n-      if (TREE_CHAIN (l))\n-\tOB_PUTC2 (',', ' ');\n+      dump_expr (TREE_VALUE (l), flags | TS_EXPR_PARENS);\n       l = TREE_CHAIN (l);\n+      if (l)\n+\tOB_PUTS (\", \");\n     }\n }\n \n-/* Print out an expression */\n+/* Print out an expression E under control of FLAGS. */\n \n static void\n-dump_expr (t, nop)\n+dump_expr (t, flags)\n      tree t;\n-     int nop;\t\t\t/* suppress parens */\n+     enum tree_string_flags flags;\n {\n   switch (TREE_CODE (t))\n     {\n@@ -1269,7 +1385,7 @@ dump_expr (t, nop)\n     case TEMPLATE_DECL:\n     case NAMESPACE_DECL:\n     case OVERLOAD:\n-      dump_decl (t, -1);\n+      dump_decl (t, flags & ~TS_DECL_TYPE);\n       break;\n \n     case INTEGER_CST:\n@@ -1341,7 +1457,7 @@ dump_expr (t, nop)\n \n     case PTRMEM_CST:\n       OB_PUTC ('&');\n-      dump_type (PTRMEM_CST_CLASS (t), 0);\n+      dump_type (PTRMEM_CST_CLASS (t), flags);\n       OB_PUTS (\"::\");\n       OB_PUTID (DECL_NAME (PTRMEM_CST_MEMBER (t)));\n       break;\n@@ -1360,28 +1476,32 @@ dump_expr (t, nop)\n       break;\n \n     case COMPOUND_EXPR:\n-      dump_binary_op (\",\", t);\n+      OB_PUTC ('(');\n+      dump_expr (TREE_OPERAND (t, 0), flags | TS_EXPR_PARENS);\n+      OB_PUTS (\", \");\n+      dump_expr (TREE_OPERAND (t, 1), flags | TS_EXPR_PARENS);\n+      OB_PUTC (')');\n       break;\n \n     case COND_EXPR:\n       OB_PUTC ('(');\n-      dump_expr (TREE_OPERAND (t, 0), 0);\n+      dump_expr (TREE_OPERAND (t, 0), flags | TS_EXPR_PARENS);\n       OB_PUTS (\" ? \");\n-      dump_expr (TREE_OPERAND (t, 1), 0);\n+      dump_expr (TREE_OPERAND (t, 1), flags | TS_EXPR_PARENS);\n       OB_PUTS (\" : \");\n-      dump_expr (TREE_OPERAND (t, 2), 0);\n+      dump_expr (TREE_OPERAND (t, 2), flags | TS_EXPR_PARENS);\n       OB_PUTC (')');\n       break;\n \n     case SAVE_EXPR:\n       if (TREE_HAS_CONSTRUCTOR (t))\n \t{\n \t  OB_PUTS (\"new \");\n-\t  dump_type (TREE_TYPE (TREE_TYPE (t)), 0);\n+\t  dump_type (TREE_TYPE (TREE_TYPE (t)), flags);\n \t}\n       else\n \t{\n-\t  dump_expr (TREE_OPERAND (t, 0), 0);\n+\t  dump_expr (TREE_OPERAND (t, 0), flags | TS_EXPR_PARENS);\n \t}\n       break;\n \n@@ -1404,7 +1524,7 @@ dump_expr (t, nop)\n       }\n       OB_PUTC ('(');\n       if (TREE_OPERAND (t, 1))\n-\tdump_expr_list (TREE_CHAIN (TREE_OPERAND (t, 1)));\n+\tdump_expr_list (TREE_CHAIN (TREE_OPERAND (t, 1)), flags);\n       OB_PUTC (')');\n       break;\n \n@@ -1421,20 +1541,20 @@ dump_expr (t, nop)\n \t    tree ob = TREE_VALUE (args);\n \t    if (TREE_CODE (ob) == ADDR_EXPR)\n \t      {\n-\t\tdump_expr (TREE_OPERAND (ob, 0), 0);\n+\t\tdump_expr (TREE_OPERAND (ob, 0), flags | TS_EXPR_PARENS);\n \t\tOB_PUTC ('.');\n \t      }\n \t    else if (TREE_CODE (ob) != PARM_DECL\n \t\t     || strcmp (IDENTIFIER_POINTER (DECL_NAME (ob)), \"this\"))\n \t      {\n-\t\tdump_expr (ob, 0);\n-\t\tOB_PUTC2 ('-', '>');\n+\t\tdump_expr (ob, flags | TS_EXPR_PARENS);\n+\t\tOB_PUTS (\"->\");\n \t      }\n \t    args = TREE_CHAIN (args);\n \t  }\n-\tdump_expr (fn, 0);\n+\tdump_expr (fn, flags | TS_EXPR_PARENS);\n \tOB_PUTC ('(');\n-\tdump_expr_list (args);\n+\tdump_expr_list (args, flags);\n \tOB_PUTC (')');\n       }\n       break;\n@@ -1448,19 +1568,19 @@ dump_expr (t, nop)\n \tif (TREE_OPERAND (t, 0))\n \t  {\n \t    OB_PUTC ('(');\n-\t    dump_expr_list (TREE_OPERAND (t, 0));\n+\t    dump_expr_list (TREE_OPERAND (t, 0), flags);\n \t    OB_PUTS (\") \");\n \t  }\n \tif (TREE_CODE (type) == ARRAY_REF)\n \t  type = build_cplus_array_type\n \t    (TREE_OPERAND (type, 0),\n \t     build_index_type (size_binop (MINUS_EXPR, TREE_OPERAND (type, 1),\n \t\t\t\t\t   integer_one_node)));\n-\tdump_type (type, 0);\n+\tdump_type (type, flags);\n \tif (TREE_OPERAND (t, 2))\n \t  {\n \t    OB_PUTC ('(');\n-\t    dump_expr_list (TREE_OPERAND (t, 2));\n+\t    dump_expr_list (TREE_OPERAND (t, 2), flags);\n \t    OB_PUTC (')');\n \t  }\n       }\n@@ -1473,7 +1593,7 @@ dump_expr (t, nop)\n \t default argument.  Note we may have cleared out the first\n \t operand in expand_expr, so don't go killing ourselves.  */\n       if (TREE_OPERAND (t, 1))\n-\tdump_expr (TREE_OPERAND (t, 1), 0);\n+\tdump_expr (TREE_OPERAND (t, 1), flags | TS_EXPR_PARENS);\n       break;\n \n     case INIT_EXPR:\n@@ -1500,19 +1620,19 @@ dump_expr (t, nop)\n     case EQ_EXPR:\n     case NE_EXPR:\n     case EXACT_DIV_EXPR:\n-      dump_binary_op (opname_tab[(int) TREE_CODE (t)], t);\n+      dump_binary_op (opname_tab[(int) TREE_CODE (t)], t, flags);\n       break;\n \n     case CEIL_DIV_EXPR:\n     case FLOOR_DIV_EXPR:\n     case ROUND_DIV_EXPR:\n-      dump_binary_op (\"/\", t);\n+      dump_binary_op (\"/\", t, flags);\n       break;\n \n     case CEIL_MOD_EXPR:\n     case FLOOR_MOD_EXPR:\n     case ROUND_MOD_EXPR:\n-      dump_binary_op (\"%\", t);\n+      dump_binary_op (\"%\", t, flags);\n       break;\n \n     case COMPONENT_REF:\n@@ -1524,62 +1644,62 @@ dump_expr (t, nop)\n \t    if (TREE_CODE (ob) != PARM_DECL\n \t\t|| strcmp (IDENTIFIER_POINTER (DECL_NAME (ob)), \"this\"))\n \t      {\n-\t\tdump_expr (ob, 0);\n-\t\tOB_PUTC2 ('-', '>');\n+\t\tdump_expr (ob, flags | TS_EXPR_PARENS);\n+\t\tOB_PUTS (\"->\");\n \t      }\n \t  }\n \telse\n \t  {\n-\t    dump_expr (ob, 0);\n+\t    dump_expr (ob, flags | TS_EXPR_PARENS);\n \t    OB_PUTC ('.');\n \t  }\n-\tdump_expr (TREE_OPERAND (t, 1), 1);\n+\tdump_expr (TREE_OPERAND (t, 1), flags & ~TS_EXPR_PARENS);\n       }\n       break;\n \n     case ARRAY_REF:\n-      dump_expr (TREE_OPERAND (t, 0), 0);\n+      dump_expr (TREE_OPERAND (t, 0), flags | TS_EXPR_PARENS);\n       OB_PUTC ('[');\n-      dump_expr (TREE_OPERAND (t, 1), 0);\n+      dump_expr (TREE_OPERAND (t, 1), flags | TS_EXPR_PARENS);\n       OB_PUTC (']');\n       break;\n \n     case CONVERT_EXPR:\n       if (same_type_p (TREE_TYPE (t), void_type_node))\n \t{\n \t  OB_PUTS (\"(void)\");\n-\t  dump_expr (TREE_OPERAND (t, 0), 0);\n+\t  dump_expr (TREE_OPERAND (t, 0), flags);\n \t}\n       else\n-\tdump_unary_op (\"+\", t, nop);\n+\tdump_unary_op (\"+\", t, flags);\n       break;\n \n     case ADDR_EXPR:\n       if (TREE_CODE (TREE_OPERAND (t, 0)) == FUNCTION_DECL\n \t  || TREE_CODE (TREE_OPERAND (t, 0)) == STRING_CST)\n-\tdump_expr (TREE_OPERAND (t, 0), 0);\n+\tdump_expr (TREE_OPERAND (t, 0), flags | TS_EXPR_PARENS);\n       else\n-\tdump_unary_op (\"&\", t, nop);\n+\tdump_unary_op (\"&\", t, flags);\n       break;\n \n     case INDIRECT_REF:\n       if (TREE_HAS_CONSTRUCTOR (t))\n \t{\n \t  t = TREE_OPERAND (t, 0);\n \t  my_friendly_assert (TREE_CODE (t) == CALL_EXPR, 237);\n-\t  dump_expr (TREE_OPERAND (t, 0), 0);\n+\t  dump_expr (TREE_OPERAND (t, 0), flags | TS_EXPR_PARENS);\n \t  OB_PUTC ('(');\n-\t  dump_expr_list (TREE_CHAIN (TREE_OPERAND (t, 1)));\n+\t  dump_expr_list (TREE_CHAIN (TREE_OPERAND (t, 1)), flags);\n \t  OB_PUTC (')');\n \t}\n       else\n \t{\n \t  if (TREE_OPERAND (t,0) != NULL_TREE\n \t      && TREE_TYPE (TREE_OPERAND (t, 0))\n \t      && NEXT_CODE (TREE_OPERAND (t, 0)) == REFERENCE_TYPE)\n-\t    dump_expr (TREE_OPERAND (t, 0), nop);\n+\t    dump_expr (TREE_OPERAND (t, 0), flags);\n \t  else\n-\t    dump_unary_op (\"*\", t, nop);\n+\t    dump_unary_op (\"*\", t, flags);\n \t}\n       break;\n \n@@ -1588,13 +1708,13 @@ dump_expr (t, nop)\n     case TRUTH_NOT_EXPR:\n     case PREDECREMENT_EXPR:\n     case PREINCREMENT_EXPR:\n-      dump_unary_op (opname_tab [(int)TREE_CODE (t)], t, nop);\n+      dump_unary_op (opname_tab [(int)TREE_CODE (t)], t, flags);\n       break;\n \n     case POSTDECREMENT_EXPR:\n     case POSTINCREMENT_EXPR:\n       OB_PUTC ('(');\n-      dump_expr (TREE_OPERAND (t, 0), 0);\n+      dump_expr (TREE_OPERAND (t, 0), flags | TS_EXPR_PARENS);\n       OB_PUTCP (opname_tab[(int)TREE_CODE (t)]);\n       OB_PUTC (')');\n       break;\n@@ -1612,19 +1732,21 @@ dump_expr (t, nop)\n \t  \n \t  if (TREE_CODE (next) == FUNCTION_TYPE)\n \t    {\n-\t      if (!nop) OB_PUTC ('(');\n+\t      if (flags & TS_EXPR_PARENS)\n+\t        OB_PUTC ('(');\n \t      OB_PUTC ('*');\n-\t      dump_expr (TREE_OPERAND (t, 0), 1);\n-\t      if (!nop) OB_PUTC (')');\n+\t      dump_expr (TREE_OPERAND (t, 0), flags & ~TS_EXPR_PARENS);\n+\t      if (flags & TS_EXPR_PARENS)\n+\t        OB_PUTC (')');\n \t      break;\n \t    }\n \t  /* else FALLTHRU */\n \t}\n-      dump_expr (TREE_OPERAND (t, 0), 0);\n+      dump_expr (TREE_OPERAND (t, 0), flags | TS_EXPR_PARENS);\n       break;\n \n     case NOP_EXPR:\n-      dump_expr (TREE_OPERAND (t, 0), nop);\n+      dump_expr (TREE_OPERAND (t, 0), flags);\n       break;\n \n     case CONSTRUCTOR:\n@@ -1635,15 +1757,15 @@ dump_expr (t, nop)\n \t  if (integer_all_onesp (idx))\n \t    {\n \t      tree pfn = PFN_FROM_PTRMEMFUNC (t);\n-\t      dump_unary_op (\"&\", pfn, 0);\n+\t      dump_unary_op (\"&\", pfn, flags | TS_EXPR_PARENS);\n \t      break;\n \t    }\n \t  else if (TREE_CODE (idx) == INTEGER_CST\n \t\t   && tree_int_cst_equal (idx, integer_zero_node))\n \t    {\n \t      /* A NULL pointer-to-member constant.  */\n \t      OB_PUTS (\"((\");\n-\t      dump_type (TREE_TYPE (t), 0);\n+\t      dump_type (TREE_TYPE (t), flags);\n \t      OB_PUTS (\") 0)\");\n \t      break;\n \t    }\n@@ -1670,13 +1792,14 @@ dump_expr (t, nop)\n \t\t}\n \t      if (virtuals)\n \t\t{\n-\t\t  dump_expr (TREE_VALUE (virtuals), 0);\n+\t\t  dump_expr (TREE_VALUE (virtuals),\n+\t                     flags | TS_EXPR_PARENS);\n \t\t  break;\n \t\t}\n \t    }\n \t}\n       OB_PUTC ('{');\n-      dump_expr_list (CONSTRUCTOR_ELTS (t));\n+      dump_expr_list (CONSTRUCTOR_ELTS (t), flags);\n       OB_PUTC ('}');\n       break;\n \n@@ -1688,59 +1811,59 @@ dump_expr (t, nop)\n \t    t = TREE_OPERAND (t, 1);\n \t    if (TREE_CODE (t) == FUNCTION_DECL)\n \t      /* A::f */\n-\t      dump_expr (t, 0);\n+\t      dump_expr (t, flags | TS_EXPR_PARENS);\n \t    else if (BASELINK_P (t))\n-\t      dump_expr (OVL_CURRENT (TREE_VALUE (t)), 0);\n+\t      dump_expr (OVL_CURRENT (TREE_VALUE (t)), flags | TS_EXPR_PARENS);\n \t    else\n-\t      dump_decl (t, 0);\n+\t      dump_decl (t, flags);\n \t  }\n \telse\n \t  {\n \t    if (TREE_CODE (ob) == INDIRECT_REF)\n \t      {\n-\t\tdump_expr (TREE_OPERAND (ob, 0), 0);\n+\t\tdump_expr (TREE_OPERAND (ob, 0), flags | TS_EXPR_PARENS);\n \t\tOB_PUTS (\" ->* \");\n \t      }\n \t    else\n \t      {\n-\t\tdump_expr (ob, 0);\n+\t\tdump_expr (ob, flags | TS_EXPR_PARENS);\n \t\tOB_PUTS (\" .* \");\n \t      }\n-\t    dump_expr (TREE_OPERAND (t, 1), 0);\n+\t    dump_expr (TREE_OPERAND (t, 1), flags | TS_EXPR_PARENS);\n \t  }\n \tbreak;\n       }\n \n     case TEMPLATE_PARM_INDEX:\n-      dump_decl (TEMPLATE_PARM_DECL (t), -1);\n+      dump_decl (TEMPLATE_PARM_DECL (t), flags & ~TS_DECL_TYPE);\n       break;\n \n     case IDENTIFIER_NODE:\n       OB_PUTID (t);\n       break;\n \n     case SCOPE_REF:\n-      dump_type (TREE_OPERAND (t, 0), 0);\n+      dump_type (TREE_OPERAND (t, 0), flags);\n       OB_PUTS (\"::\");\n-      dump_expr (TREE_OPERAND (t, 1), 0);\n+      dump_expr (TREE_OPERAND (t, 1), flags | TS_EXPR_PARENS);\n       break;\n \n     case CAST_EXPR:\n       if (TREE_OPERAND (t, 0) == NULL_TREE\n \t  || TREE_CHAIN (TREE_OPERAND (t, 0)))\n \t{\n-\t  dump_type (TREE_TYPE (t), 0);\n+\t  dump_type (TREE_TYPE (t), flags);\n \t  OB_PUTC ('(');\n-\t  dump_expr_list (TREE_OPERAND (t, 0));\n+\t  dump_expr_list (TREE_OPERAND (t, 0), flags);\n \t  OB_PUTC (')');\n \t}\n       else\n \t{\n \t  OB_PUTC ('(');\n-\t  dump_type (TREE_TYPE (t), 0);\n+\t  dump_type (TREE_TYPE (t), flags);\n \t  OB_PUTC (')');\n \t  OB_PUTC ('(');\n-\t  dump_expr_list (TREE_OPERAND (t, 0));\n+\t  dump_expr_list (TREE_OPERAND (t, 0), flags);\n \t  OB_PUTC (')');\n \t}\n       break;\n@@ -1750,7 +1873,7 @@ dump_expr (t, nop)\n       break;\n \n     case ARROW_EXPR:\n-      dump_expr (TREE_OPERAND (t, 0), nop);\n+      dump_expr (TREE_OPERAND (t, 0), flags);\n       OB_PUTS (\"->\");\n       break;\n \n@@ -1764,9 +1887,9 @@ dump_expr (t, nop)\n \t  OB_PUTS (\"__alignof__ (\");\n \t}\n       if (TREE_CODE_CLASS (TREE_CODE (TREE_OPERAND (t, 0))) == 't')\n-\tdump_type (TREE_OPERAND (t, 0), 0);\n+\tdump_type (TREE_OPERAND (t, 0), flags);\n       else\n-\tdump_unary_op (\"*\", t, 0);\n+\tdump_unary_op (\"*\", t, flags | TS_EXPR_PARENS);\n       OB_PUTC (')');\n       break;\n \n@@ -1777,19 +1900,19 @@ dump_expr (t, nop)\n     case TRY_CATCH_EXPR:\n     case WITH_CLEANUP_EXPR:\n     case CLEANUP_POINT_EXPR:\n-      dump_expr (TREE_OPERAND (t, 0), nop);\n+      dump_expr (TREE_OPERAND (t, 0), flags);\n       break;\n \n     case PSEUDO_DTOR_EXPR:\n-      dump_expr (TREE_OPERAND (t, 2), nop);\n+      dump_expr (TREE_OPERAND (t, 2), flags);\n       OB_PUTS (\".\");\n-      dump_type (TREE_OPERAND (t, 0), nop);\n+      dump_type (TREE_OPERAND (t, 0), flags);\n       OB_PUTS (\"::~\");\n-      dump_type (TREE_OPERAND (t, 1), nop);\n+      dump_type (TREE_OPERAND (t, 1), flags);\n       break;\n \n     case TEMPLATE_ID_EXPR:\n-      dump_decl (t, 0);\n+      dump_decl (t, flags);\n       break;\n \n     case STMT_EXPR:\n@@ -1800,19 +1923,19 @@ dump_expr (t, nop)\n \n     case BIND_EXPR:\n       OB_PUTS (\"{ \");\n-      dump_expr (TREE_OPERAND (t, 1), nop);\n+      dump_expr (TREE_OPERAND (t, 1), flags & ~TS_EXPR_PARENS);\n       OB_PUTS (\"} \");\n       break;\n       \n     case LOOP_EXPR:\n       OB_PUTS (\"while (1) { \");\n-      dump_expr (TREE_OPERAND (t, 0), nop);\n+      dump_expr (TREE_OPERAND (t, 0), flags & ~TS_EXPR_PARENS);\n       OB_PUTS (\"} \");\n       break;\n \n     case EXIT_EXPR:\n       OB_PUTS (\"if (\");\n-      dump_expr (TREE_OPERAND (t, 0), nop);\n+      dump_expr (TREE_OPERAND (t, 0), flags & ~TS_EXPR_PARENS);\n       OB_PUTS (\") break; \");\n       break;\n \n@@ -1833,112 +1956,97 @@ dump_expr (t, nop)\n \n       /* fall through to ERROR_MARK...  */\n     case ERROR_MARK:\n-      OB_PUTCP (\"{error}\");\n+      OB_PUTCP (\"{exprerror}\");\n       break;\n     }\n }\n \n static void\n-dump_binary_op (opstring, t)\n+dump_binary_op (opstring, t, flags)\n      const char *opstring;\n      tree t;\n+     enum tree_string_flags flags;\n {\n   OB_PUTC ('(');\n-  dump_expr (TREE_OPERAND (t, 0), 1);\n+  dump_expr (TREE_OPERAND (t, 0), flags | TS_EXPR_PARENS);\n   OB_PUTC (' ');\n   if (opstring)\n     OB_PUTCP (opstring);\n   else\n     OB_PUTS (\"<unknown operator>\");\n   OB_PUTC (' ');\n-  dump_expr (TREE_OPERAND (t, 1), 1);\n+  dump_expr (TREE_OPERAND (t, 1), flags | TS_EXPR_PARENS);\n   OB_PUTC (')');\n }\n \n static void\n-dump_unary_op (opstring, t, nop)\n+dump_unary_op (opstring, t, flags)\n      const char *opstring;\n      tree t;\n-     int nop;\n+     enum tree_string_flags flags;\n {\n-  if (!nop) OB_PUTC ('(');\n+  if (flags & TS_EXPR_PARENS)\n+    OB_PUTC ('(');\n   OB_PUTCP (opstring);\n-  dump_expr (TREE_OPERAND (t, 0), 1);\n-  if (!nop) OB_PUTC (')');\n+  dump_expr (TREE_OPERAND (t, 0), flags & ~TS_EXPR_PARENS);\n+  if (flags & TS_EXPR_PARENS)\n+    OB_PUTC (')');\n }\n \n-/* Print a function decl with exception specification included. */\n+/* Exported interface to stringifying types, exprs and decls under TS_*\n+   control.  */\n \n const char *\n-fndecl_as_string (fndecl, print_default_args_p)\n-     tree fndecl;\n-     int print_default_args_p;\n+type_as_string (typ, flags)\n+     tree typ;\n+     enum tree_string_flags flags;\n {\n   OB_INIT ();\n \n-  dump_function_decl (fndecl, 2 + print_default_args_p);\n-  \n+  dump_type (typ, flags);\n+\n   OB_FINISH ();\n \n   return (char *)obstack_base (&scratch_obstack);\n }\n \n-/* Same, but handle a _TYPE.\n-   Called from convert_to_reference, mangle_class_name_for_template,\n-   build_unary_op, and GNU_xref_decl.  If CANONICAL_NAME is non-zero,\n-   when describing a typedef, we use the name of the type described,\n-   rather than the name of the typedef.  */\n-\n const char *\n-type_as_string_real (typ, v, canonical_name)\n-     tree typ;\n-     int v;\n-     int canonical_name;\n+expr_as_string (decl, flags)\n+     tree decl;\n+     enum tree_string_flags flags;\n {\n   OB_INIT ();\n \n-  dump_type_real (typ, v, canonical_name);\n+  dump_expr (decl, flags);\n \n   OB_FINISH ();\n \n   return (char *)obstack_base (&scratch_obstack);\n }\n \n-\n const char *\n-type_as_string (typ, v)\n-     tree typ;\n-     int v;\n-{\n-  return type_as_string_real (typ, v, 0);\n-}\n-\n-const char *\n-expr_as_string (decl, v)\n+decl_as_string (decl, flags)\n      tree decl;\n-     int v ATTRIBUTE_UNUSED;\n+     enum tree_string_flags flags;\n {\n   OB_INIT ();\n \n-  dump_expr (decl, 1);\n+  dump_decl (decl, flags);\n \n   OB_FINISH ();\n \n   return (char *)obstack_base (&scratch_obstack);\n }\n \n-/* A cross between type_as_string and fndecl_as_string.\n-   Only called from substitute_nice_name.  */\n-\n const char *\n-decl_as_string (decl, v)\n-     tree decl;\n-     int v;\n+context_as_string (context, flags)\n+     tree context;\n+     enum tree_string_flags flags;\n {\n   OB_INIT ();\n-\n-  dump_decl (decl, v);\n-\n+  \n+  dump_scope (context, flags);\n+  \n   OB_FINISH ();\n \n   return (char *)obstack_base (&scratch_obstack);\n@@ -1952,7 +2060,7 @@ lang_decl_name (decl, v)\n      int v;\n {\n   if (v >= 2)\n-    return decl_as_string (decl, 1);\n+    return decl_as_string (decl, TS_DECL_TYPE);\n \n   OB_INIT ();\n \n@@ -1963,20 +2071,19 @@ lang_decl_name (decl, v)\n \tcname = DECL_CLASS_CONTEXT (decl);\n       else\n \tcname = DECL_CONTEXT (decl);\n-      dump_type (cname, 0);\n-      OB_PUTC2 (':', ':');\n+      dump_type (cname, TS_PLAIN);\n+      OB_PUTS (\"::\");\n     }\n \n   if (TREE_CODE (decl) == FUNCTION_DECL)\n-    dump_function_name (decl);\n+    dump_function_name (decl, TS_PLAIN);\n   else\n-    dump_decl (DECL_NAME (decl), 0);\n+    dump_decl (DECL_NAME (decl), TS_PLAIN);\n \n   OB_FINISH ();\n \n   return (char *)obstack_base (&scratch_obstack);\n }\n-  \n \n const char *\n cp_file_of (t)\n@@ -2016,16 +2123,79 @@ cp_line_of (t)\n   return line;\n }\n \n-const char *\n-code_as_string (c, v)\n+/* Now the interfaces from cp_error et al to dump_type et al. Each takes an\n+   on/off VERBOSE flag and supply the appropriate TS_ flags to a dump_\n+   function.  */\n+\n+static const char *\n+decl_to_string (decl, verbose)\n+     tree decl;\n+     int verbose;\n+{\n+  enum tree_string_flags flags = 0;\n+  \n+  if (TREE_CODE (decl) == TYPE_DECL || TREE_CODE (decl) == RECORD_TYPE\n+      || TREE_CODE (decl) == UNION_TYPE || TREE_CODE (decl) == ENUMERAL_TYPE)\n+    flags = TS_AGGR_TAGS;\n+  if (verbose)\n+    flags |= TS_DECL_TYPE | TS_DECORATE | TS_PARM_DEFAULTS;\n+  else if (TREE_CODE (decl) == FUNCTION_DECL)\n+    flags |= TS_DECL_TYPE | TS_FUNC_NORETURN;\n+  flags |= TS_TEMPLATE_PREFIX;\n+  \n+  OB_INIT ();\n+\n+  dump_decl (decl, flags);\n+\n+  OB_FINISH ();\n+\n+  return (char *)obstack_base (&scratch_obstack);\n+}\n+\n+static const char *\n+expr_to_string (decl, verbose)\n+     tree decl;\n+     int verbose ATTRIBUTE_UNUSED;\n+{\n+  OB_INIT ();\n+\n+  dump_expr (decl, 0);\n+\n+  OB_FINISH ();\n+\n+  return (char *)obstack_base (&scratch_obstack);\n+}\n+\n+static const char *\n+fndecl_to_string (fndecl, verbose)\n+     tree fndecl;\n+     int verbose;\n+{\n+  enum tree_string_flags flags;\n+  \n+  flags = TS_FUNC_THROW | TS_DECL_TYPE;\n+  if (verbose)\n+    flags |= TS_PARM_DEFAULTS;\n+  OB_INIT ();\n+\n+  dump_decl (fndecl, flags);\n+  \n+  OB_FINISH ();\n+\n+  return (char *)obstack_base (&scratch_obstack);\n+}\n+\n+\n+static const char *\n+code_to_string (c, v)\n      enum tree_code c;\n      int v ATTRIBUTE_UNUSED;\n {\n   return tree_code_name [c];\n }\n \n-const char *\n-language_as_string (c, v)\n+static const char *\n+language_to_string (c, v)\n      enum languages c;\n      int v ATTRIBUTE_UNUSED;\n {\n@@ -2048,8 +2218,8 @@ language_as_string (c, v)\n \n /* Return the proper printed version of a parameter to a C++ function.  */\n \n-const char *\n-parm_as_string (p, v)\n+static const char *\n+parm_to_string (p, v)\n      int p;\n      int v ATTRIBUTE_UNUSED;\n {\n@@ -2060,8 +2230,8 @@ parm_as_string (p, v)\n   return digit_buffer;\n }\n \n-const char *\n-op_as_string (p, v)\n+static const char *\n+op_to_string (p, v)\n      enum tree_code p;\n      int v ATTRIBUTE_UNUSED;\n {\n@@ -2074,8 +2244,29 @@ op_as_string (p, v)\n   return buf;\n }\n \n-const char *\n-assop_as_string (p, v)\n+static const char *\n+type_to_string (typ, verbose)\n+     tree typ;\n+     int verbose;\n+{\n+  enum tree_string_flags flags;\n+  \n+  flags = 0;\n+  if (verbose)\n+    flags |= TS_AGGR_TAGS;\n+  flags |= TS_TEMPLATE_PREFIX;\n+  \n+  OB_INIT ();\n+\n+  dump_type (typ, flags);\n+\n+  OB_FINISH ();\n+\n+  return (char *)obstack_base (&scratch_obstack);\n+}\n+\n+static const char *\n+assop_to_string (p, v)\n      enum tree_code p;\n      int v ATTRIBUTE_UNUSED;\n {\n@@ -2088,33 +2279,37 @@ assop_as_string (p, v)\n   return buf;\n }\n \n-const char *\n-args_as_string (p, v)\n+static const char *\n+args_to_string (p, verbose)\n      tree p;\n-     int v;\n+     int verbose;\n {\n+  enum tree_string_flags flags = 0;\n+  if (verbose)\n+    flags |= TS_AGGR_TAGS;\n+  \n   if (p == NULL_TREE)\n     return \"\";\n \n   if (TREE_CODE_CLASS (TREE_CODE (TREE_VALUE (p))) == 't')\n-    return type_as_string (p, v);\n+    return type_as_string (p, flags);\n \n   OB_INIT ();\n   for (; p; p = TREE_CHAIN (p))\n     {\n       if (TREE_VALUE (p) == null_node)\n \tOB_PUTS (\"NULL\");\n       else\n-\tdump_type (error_type (TREE_VALUE (p)), v);\n+\tdump_type (error_type (TREE_VALUE (p)), flags);\n       if (TREE_CHAIN (p))\n \tOB_PUTS (\", \");\n     }\n   OB_FINISH ();\n   return (char *)obstack_base (&scratch_obstack);\n }\n \n-const char *\n-cv_as_string (p, v)\n+static const char *\n+cv_to_string (p, v)\n      tree p;\n      int v ATTRIBUTE_UNUSED;\n {"}, {"sha": "a4cb4224c5625e2f6dd5293470ae74a85ee45710", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e93bc9dcc9b0dbec075bb15580ccd62dc359b70/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e93bc9dcc9b0dbec075bb15580ccd62dc359b70/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=9e93bc9dcc9b0dbec075bb15580ccd62dc359b70", "patch": "@@ -3527,7 +3527,7 @@ mangle_class_name_for_template (name, parms, arglist)\n \n       if (TREE_CODE (parm) == TYPE_DECL)\n \t{\n-\t  cat (type_as_string_real (arg, 0, 1));\n+\t  cat (type_as_string (arg, TS_CHASE_TYPEDEFS));\n \t  continue;\n \t}\n       else if (TREE_CODE (parm) == TEMPLATE_DECL)\n@@ -3551,7 +3551,7 @@ mangle_class_name_for_template (name, parms, arglist)\n \t    }\n \t  else\n \t    /* Output the parameter declaration */\n-\t    cat (type_as_string_real (arg, 0, 1));\n+\t    cat (type_as_string (arg, TS_CHASE_TYPEDEFS));\n \t  continue;\n \t}\n       else\n@@ -4401,7 +4401,7 @@ print_template_context (err)\n \t    /* Avoid redundancy with the the \"In function\" line.  */;\n \t  else \n \t    fprintf (stderr, \"%s: In instantiation of `%s':\\n\",\n-\t\t     file, decl_as_string (p->decl, 0));\n+\t\t     file, decl_as_string (p->decl, TS_DECL_TYPE | TS_FUNC_NORETURN));\n \t  \n \t  line = p->line;\n \t  file = p->file;\n@@ -4412,7 +4412,7 @@ print_template_context (err)\n   for (; p; p = p->next)\n     {\n       fprintf (stderr, \"%s:%d:   instantiated from `%s'\\n\", file, line,\n-\t       decl_as_string (p->decl, 0));\n+\t       decl_as_string (p->decl, TS_DECL_TYPE | TS_FUNC_NORETURN));\n       line = p->line;\n       file = p->file;\n     }"}]}