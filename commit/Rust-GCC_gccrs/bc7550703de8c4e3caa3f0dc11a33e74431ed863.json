{"sha": "bc7550703de8c4e3caa3f0dc11a33e74431ed863", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmM3NTUwNzAzZGU4YzRlM2NhYTNmMGRjMTFhMzNlNzQ0MzFlZDg2Mw==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-04-29T16:38:05Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-04-29T16:38:05Z"}, "message": "Initial revision\n\nFrom-SVN: r19496", "tree": {"sha": "370efeb7d9448e2ff6b0f218d19c554dd314c933", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/370efeb7d9448e2ff6b0f218d19c554dd314c933"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bc7550703de8c4e3caa3f0dc11a33e74431ed863", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc7550703de8c4e3caa3f0dc11a33e74431ed863", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc7550703de8c4e3caa3f0dc11a33e74431ed863", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc7550703de8c4e3caa3f0dc11a33e74431ed863/comments", "author": null, "committer": null, "parents": [{"sha": "1ada4c55ae87436c4b93e204cb157ae7e1074257", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ada4c55ae87436c4b93e204cb157ae7e1074257", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ada4c55ae87436c4b93e204cb157ae7e1074257"}], "stats": {"total": 411, "additions": 411, "deletions": 0}, "files": [{"sha": "9c7dc18360ff7901da699b99f6d8dc7a53d3e992", "filename": "gcc/intl/l10nflist.c", "status": "added", "additions": 411, "deletions": 0, "changes": 411, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc7550703de8c4e3caa3f0dc11a33e74431ed863/gcc%2Fintl%2Fl10nflist.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc7550703de8c4e3caa3f0dc11a33e74431ed863/gcc%2Fintl%2Fl10nflist.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintl%2Fl10nflist.c?ref=bc7550703de8c4e3caa3f0dc11a33e74431ed863", "patch": "@@ -0,0 +1,411 @@\n+/* Handle list of needed message catalogs\n+   Copyright (C) 1995, 1996, 1997 Free Software Foundation, Inc.\n+   Contributed by Ulrich Drepper <drepper@gnu.ai.mit.edu>, 1995.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; if not, write to the Free Software Foundation,\n+   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n+\n+#ifdef HAVE_CONFIG_H\n+# include <config.h>\n+#endif\n+\n+\n+#if defined HAVE_STRING_H || defined _LIBC\n+# ifndef _GNU_SOURCE\n+#  define _GNU_SOURCE\t1\n+# endif\n+# include <string.h>\n+#else\n+# include <strings.h>\n+# ifndef memcpy\n+#  define memcpy(Dst, Src, Num) bcopy (Src, Dst, Num)\n+# endif\n+#endif\n+#if !HAVE_STRCHR && !defined _LIBC\n+# ifndef strchr\n+#  define strchr index\n+# endif\n+#endif\n+\n+#if defined _LIBC || defined HAVE_ARGZ_H\n+# include <argz.h>\n+#endif\n+#include <ctype.h>\n+#include <sys/types.h>\n+\n+#if defined STDC_HEADERS || defined _LIBC\n+# include <stdlib.h>\n+#endif\n+\n+#include \"loadinfo.h\"\n+\n+/* On some strange systems still no definition of NULL is found.  Sigh!  */\n+#ifndef NULL\n+# if defined __STDC__ && __STDC__\n+#  define NULL ((void *) 0)\n+# else\n+#  define NULL 0\n+# endif\n+#endif\n+\n+/* @@ end of prolog @@ */\n+\n+#ifdef _LIBC\n+/* Rename the non ANSI C functions.  This is required by the standard\n+   because some ANSI C functions will require linking with this object\n+   file and the name space must not be polluted.  */\n+# ifndef stpcpy\n+#  define stpcpy(dest, src) __stpcpy(dest, src)\n+# endif\n+#else\n+# ifndef HAVE_STPCPY\n+static char *stpcpy PARAMS ((char *dest, const char *src));\n+# endif\n+#endif\n+\n+/* Define function which are usually not available.  */\n+\n+#if !defined _LIBC && !defined HAVE___ARGZ_COUNT\n+/* Returns the number of strings in ARGZ.  */\n+static size_t argz_count__ PARAMS ((const char *argz, size_t len));\n+\n+static size_t\n+argz_count__ (argz, len)\n+     const char *argz;\n+     size_t len;\n+{\n+  size_t count = 0;\n+  while (len > 0)\n+    {\n+      size_t part_len = strlen (argz);\n+      argz += part_len + 1;\n+      len -= part_len + 1;\n+      count++;\n+    }\n+  return count;\n+}\n+# undef __argz_count\n+# define __argz_count(argz, len) argz_count__ (argz, len)\n+#endif\t/* !_LIBC && !HAVE___ARGZ_COUNT */\n+\n+#if !defined _LIBC && !defined HAVE___ARGZ_STRINGIFY\n+/* Make '\\0' separated arg vector ARGZ printable by converting all the '\\0's\n+   except the last into the character SEP.  */\n+static void argz_stringify__ PARAMS ((char *argz, size_t len, int sep));\n+\n+static void\n+argz_stringify__ (argz, len, sep)\n+     char *argz;\n+     size_t len;\n+     int sep;\n+{\n+  while (len > 0)\n+    {\n+      size_t part_len = strlen (argz);\n+      argz += part_len;\n+      len -= part_len + 1;\n+      if (len > 0)\n+\t*argz++ = sep;\n+    }\n+}\n+# undef __argz_stringify\n+# define __argz_stringify(argz, len, sep) argz_stringify__ (argz, len, sep)\n+#endif\t/* !_LIBC && !HAVE___ARGZ_STRINGIFY */\n+\n+#if !defined _LIBC && !defined HAVE___ARGZ_NEXT\n+static char *argz_next__ PARAMS ((char *argz, size_t argz_len,\n+\t\t\t\t  const char *entry));\n+\n+static char *\n+argz_next__ (argz, argz_len, entry)\n+     char *argz;\n+     size_t argz_len;\n+     const char *entry;\n+{\n+  if (entry)\n+    {\n+      if (entry < argz + argz_len)\n+        entry = strchr (entry, '\\0') + 1;\n+\n+      return entry >= argz + argz_len ? NULL : (char *) entry;\n+    }\n+  else\n+    if (argz_len > 0)\n+      return argz;\n+    else\n+      return 0;\n+}\n+# undef __argz_next\n+# define __argz_next(argz, len, entry) argz_next__ (argz, len, entry)\n+#endif\t/* !_LIBC && !HAVE___ARGZ_NEXT */\n+\n+\n+/* Return number of bits set in X.  */\n+static int pop PARAMS ((int x));\n+\n+static inline int\n+pop (x)\n+     int x;\n+{\n+  /* We assume that no more than 16 bits are used.  */\n+  x = ((x & ~0x5555) >> 1) + (x & 0x5555);\n+  x = ((x & ~0x3333) >> 2) + (x & 0x3333);\n+  x = ((x >> 4) + x) & 0x0f0f;\n+  x = ((x >> 8) + x) & 0xff;\n+\n+  return x;\n+}\n+\n+\f\n+struct loaded_l10nfile *\n+_nl_make_l10nflist (l10nfile_list, dirlist, dirlist_len, mask, language,\n+\t\t    territory, codeset, normalized_codeset, modifier, special,\n+\t\t    sponsor, revision, filename, do_allocate)\n+     struct loaded_l10nfile **l10nfile_list;\n+     const char *dirlist;\n+     size_t dirlist_len;\n+     int mask;\n+     const char *language;\n+     const char *territory;\n+     const char *codeset;\n+     const char *normalized_codeset;\n+     const char *modifier;\n+     const char *special;\n+     const char *sponsor;\n+     const char *revision;\n+     const char *filename;\n+     int do_allocate;\n+{\n+  char *abs_filename;\n+  struct loaded_l10nfile *last = NULL;\n+  struct loaded_l10nfile *retval;\n+  char *cp;\n+  size_t entries;\n+  int cnt;\n+\n+  /* Allocate room for the full file name.  */\n+  abs_filename = (char *) malloc (dirlist_len\n+\t\t\t\t  + strlen (language)\n+\t\t\t\t  + ((mask & TERRITORY) != 0\n+\t\t\t\t     ? strlen (territory) + 1 : 0)\n+\t\t\t\t  + ((mask & XPG_CODESET) != 0\n+\t\t\t\t     ? strlen (codeset) + 1 : 0)\n+\t\t\t\t  + ((mask & XPG_NORM_CODESET) != 0\n+\t\t\t\t     ? strlen (normalized_codeset) + 1 : 0)\n+\t\t\t\t  + (((mask & XPG_MODIFIER) != 0\n+\t\t\t\t      || (mask & CEN_AUDIENCE) != 0)\n+\t\t\t\t     ? strlen (modifier) + 1 : 0)\n+\t\t\t\t  + ((mask & CEN_SPECIAL) != 0\n+\t\t\t\t     ? strlen (special) + 1 : 0)\n+\t\t\t\t  + (((mask & CEN_SPONSOR) != 0\n+\t\t\t\t      || (mask & CEN_REVISION) != 0)\n+\t\t\t\t     ? (1 + ((mask & CEN_SPONSOR) != 0\n+\t\t\t\t\t     ? strlen (sponsor) + 1 : 0)\n+\t\t\t\t\t+ ((mask & CEN_REVISION) != 0\n+\t\t\t\t\t   ? strlen (revision) + 1 : 0)) : 0)\n+\t\t\t\t  + 1 + strlen (filename) + 1);\n+\n+  if (abs_filename == NULL)\n+    return NULL;\n+\n+  retval = NULL;\n+  last = NULL;\n+\n+  /* Construct file name.  */\n+  memcpy (abs_filename, dirlist, dirlist_len);\n+  __argz_stringify (abs_filename, dirlist_len, ':');\n+  cp = abs_filename + (dirlist_len - 1);\n+  *cp++ = '/';\n+  cp = stpcpy (cp, language);\n+\n+  if ((mask & TERRITORY) != 0)\n+    {\n+      *cp++ = '_';\n+      cp = stpcpy (cp, territory);\n+    }\n+  if ((mask & XPG_CODESET) != 0)\n+    {\n+      *cp++ = '.';\n+      cp = stpcpy (cp, codeset);\n+    }\n+  if ((mask & XPG_NORM_CODESET) != 0)\n+    {\n+      *cp++ = '.';\n+      cp = stpcpy (cp, normalized_codeset);\n+    }\n+  if ((mask & (XPG_MODIFIER | CEN_AUDIENCE)) != 0)\n+    {\n+      /* This component can be part of both syntaces but has different\n+\t leading characters.  For CEN we use `+', else `@'.  */\n+      *cp++ = (mask & CEN_AUDIENCE) != 0 ? '+' : '@';\n+      cp = stpcpy (cp, modifier);\n+    }\n+  if ((mask & CEN_SPECIAL) != 0)\n+    {\n+      *cp++ = '+';\n+      cp = stpcpy (cp, special);\n+    }\n+  if ((mask & (CEN_SPONSOR | CEN_REVISION)) != 0)\n+    {\n+      *cp++ = ',';\n+      if ((mask & CEN_SPONSOR) != 0)\n+\tcp = stpcpy (cp, sponsor);\n+      if ((mask & CEN_REVISION) != 0)\n+\t{\n+\t  *cp++ = '_';\n+\t  cp = stpcpy (cp, revision);\n+\t}\n+    }\n+\n+  *cp++ = '/';\n+  stpcpy (cp, filename);\n+\n+  /* Look in list of already loaded domains whether it is already\n+     available.  */\n+  last = NULL;\n+  for (retval = *l10nfile_list; retval != NULL; retval = retval->next)\n+    if (retval->filename != NULL)\n+      {\n+\tint compare = strcmp (retval->filename, abs_filename);\n+\tif (compare == 0)\n+\t  /* We found it!  */\n+\t  break;\n+\tif (compare < 0)\n+\t  {\n+\t    /* It's not in the list.  */\n+\t    retval = NULL;\n+\t    break;\n+\t  }\n+\n+\tlast = retval;\n+      }\n+\n+  if (retval != NULL || do_allocate == 0)\n+    {\n+      free (abs_filename);\n+      return retval;\n+    }\n+\n+  retval = (struct loaded_l10nfile *)\n+    malloc (sizeof (*retval) + (__argz_count (dirlist, dirlist_len)\n+\t\t\t\t* (1 << pop (mask))\n+\t\t\t\t* sizeof (struct loaded_l10nfile *)));\n+  if (retval == NULL)\n+    return NULL;\n+\n+  retval->filename = abs_filename;\n+  retval->decided = (__argz_count (dirlist, dirlist_len) != 1\n+\t\t     || ((mask & XPG_CODESET) != 0\n+\t\t\t && (mask & XPG_NORM_CODESET) != 0));\n+  retval->data = NULL;\n+\n+  if (last == NULL)\n+    {\n+      retval->next = *l10nfile_list;\n+      *l10nfile_list = retval;\n+    }\n+  else\n+    {\n+      retval->next = last->next;\n+      last->next = retval;\n+    }\n+\n+  entries = 0;\n+  /* If the DIRLIST is a real list the RETVAL entry corresponds not to\n+     a real file.  So we have to use the DIRLIST separation mechanism\n+     of the inner loop.  */\n+  cnt = __argz_count (dirlist, dirlist_len) == 1 ? mask - 1 : mask;\n+  for (; cnt >= 0; --cnt)\n+    if ((cnt & ~mask) == 0\n+\t&& ((cnt & CEN_SPECIFIC) == 0 || (cnt & XPG_SPECIFIC) == 0)\n+\t&& ((cnt & XPG_CODESET) == 0 || (cnt & XPG_NORM_CODESET) == 0))\n+      {\n+\t/* Iterate over all elements of the DIRLIST.  */\n+\tchar *dir = NULL;\n+\n+\twhile ((dir = __argz_next ((char *) dirlist, dirlist_len, dir))\n+\t       != NULL)\n+\t  retval->successor[entries++]\n+\t    = _nl_make_l10nflist (l10nfile_list, dir, strlen (dir) + 1, cnt,\n+\t\t\t\t  language, territory, codeset,\n+\t\t\t\t  normalized_codeset, modifier, special,\n+\t\t\t\t  sponsor, revision, filename, 1);\n+      }\n+  retval->successor[entries] = NULL;\n+\n+  return retval;\n+}\n+\f\n+/* Normalize codeset name.  There is no standard for the codeset\n+   names.  Normalization allows the user to use any of the common\n+   names.  */\n+const char *\n+_nl_normalize_codeset (codeset, name_len)\n+     const unsigned char *codeset;\n+     size_t name_len;\n+{\n+  int len = 0;\n+  int only_digit = 1;\n+  char *retval;\n+  char *wp;\n+  size_t cnt;\n+\n+  for (cnt = 0; cnt < name_len; ++cnt)\n+    if (isalnum (codeset[cnt]))\n+      {\n+\t++len;\n+\n+\tif (isalpha (codeset[cnt]))\n+\t  only_digit = 0;\n+      }\n+\n+  retval = (char *) malloc ((only_digit ? 3 : 0) + len + 1);\n+\n+  if (retval != NULL)\n+    {\n+      if (only_digit)\n+\twp = stpcpy (retval, \"iso\");\n+      else\n+\twp = retval;\n+\n+      for (cnt = 0; cnt < name_len; ++cnt)\n+\tif (isalpha (codeset[cnt]))\n+\t  *wp++ = tolower (codeset[cnt]);\n+\telse if (isdigit (codeset[cnt]))\n+\t  *wp++ = codeset[cnt];\n+\n+      *wp = '\\0';\n+    }\n+\n+  return (const char *) retval;\n+}\n+\n+\n+/* @@ begin of epilog @@ */\n+\n+/* We don't want libintl.a to depend on any other library.  So we\n+   avoid the non-standard function stpcpy.  In GNU C Library this\n+   function is available, though.  Also allow the symbol HAVE_STPCPY\n+   to be defined.  */\n+#if !_LIBC && !HAVE_STPCPY\n+static char *\n+stpcpy (dest, src)\n+     char *dest;\n+     const char *src;\n+{\n+  while ((*dest++ = *src++) != '\\0')\n+    /* Do nothing. */ ;\n+  return dest - 1;\n+}\n+#endif"}]}