{"sha": "09e0175327d333360fbe45346c411a8bc7eee1f1", "node_id": "C_kwDOANBUbNoAKDA5ZTAxNzUzMjdkMzMzMzYwZmJlNDUzNDZjNDExYThiYzdlZWUxZjE", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2022-12-21T11:41:50Z"}, "committer": {"name": "Marc Poulhi\u00e8s", "email": "poulhies@adacore.com", "date": "2023-01-05T14:30:02Z"}, "message": "ada: Clean up interface handling in Expand_N_Object_Declaration\n\nThe code performing the expansion of objects with (class-wide) interface\ntype in Expand_N_Object_Declaration is fairly low-level, fiddling with the\nhomonym and entity chains, which is unnecessary.\n\ngcc/ada/\n\n\t* exp_ch3.adb (Expand_N_Object_Declaration): Rewrite the end of the\n\thandling of objects with (class-wide) interface type by using the\n\tsame idiom as the other cases generating a renaming.\n\t* exp_util.adb (Is_Displacement_Of_Object_Or_Function_Result): Tweak\n\tpattern matching code and exclude special return objects.\n\t(Requires_Cleanup_Actions): Adjust comment.\n\t* exp_ch7.adb (Build_Finalizer): Likewise.", "tree": {"sha": "000b1577a2df5815cb7c44be20377c0a1f284ace", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/000b1577a2df5815cb7c44be20377c0a1f284ace"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/09e0175327d333360fbe45346c411a8bc7eee1f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09e0175327d333360fbe45346c411a8bc7eee1f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09e0175327d333360fbe45346c411a8bc7eee1f1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09e0175327d333360fbe45346c411a8bc7eee1f1/comments", "author": null, "committer": {"login": "dkm", "id": 87603, "node_id": "MDQ6VXNlcjg3NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/87603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dkm", "html_url": "https://github.com/dkm", "followers_url": "https://api.github.com/users/dkm/followers", "following_url": "https://api.github.com/users/dkm/following{/other_user}", "gists_url": "https://api.github.com/users/dkm/gists{/gist_id}", "starred_url": "https://api.github.com/users/dkm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dkm/subscriptions", "organizations_url": "https://api.github.com/users/dkm/orgs", "repos_url": "https://api.github.com/users/dkm/repos", "events_url": "https://api.github.com/users/dkm/events{/privacy}", "received_events_url": "https://api.github.com/users/dkm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9ff806899bfa38ade0bddbdfb413ca3444425bcf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ff806899bfa38ade0bddbdfb413ca3444425bcf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ff806899bfa38ade0bddbdfb413ca3444425bcf"}], "stats": {"total": 207, "additions": 93, "deletions": 114}, "files": [{"sha": "fc4089dc123a5f9021d27824e9addb557a726db0", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 59, "deletions": 96, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e0175327d333360fbe45346c411a8bc7eee1f1/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e0175327d333360fbe45346c411a8bc7eee1f1/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=09e0175327d333360fbe45346c411a8bc7eee1f1", "patch": "@@ -7501,12 +7501,14 @@ package body Exp_Ch3 is\n \n             elsif Tagged_Type_Expansion then\n                declare\n-                  Iface    : constant Entity_Id := Root_Type (Typ);\n-                  Expr_N   : Node_Id := Expr;\n-                  Expr_Typ : Entity_Id;\n-                  New_Expr : Node_Id;\n-                  Obj_Id   : Entity_Id;\n-                  Tag_Comp : Node_Id;\n+                  Iface : constant Entity_Id := Root_Type (Typ);\n+\n+                  Expr_Typ     : Entity_Id;\n+                  New_Expr     : Node_Id;\n+                  Obj_Id       : Entity_Id;\n+                  Ptr_Obj_Decl : Node_Id;\n+                  Ptr_Obj_Id   : Entity_Id;\n+                  Tag_Comp     : Node_Id;\n \n                begin\n                   --  If the original node of the expression was a conversion\n@@ -7516,26 +7518,27 @@ package body Exp_Ch3 is\n                   --  component. This code must be kept synchronized with the\n                   --  expansion done by routine Expand_Interface_Conversion\n \n-                  if not Comes_From_Source (Expr_N)\n-                    and then Nkind (Expr_N) = N_Explicit_Dereference\n-                    and then Nkind (Original_Node (Expr_N)) = N_Type_Conversion\n-                    and then Etype (Original_Node (Expr_N)) = Typ\n+                  if not Comes_From_Source (Expr)\n+                    and then Nkind (Expr) = N_Explicit_Dereference\n+                    and then Nkind (Original_Node (Expr)) = N_Type_Conversion\n+                    and then Etype (Original_Node (Expr)) = Typ\n                   then\n-                     Rewrite (Expr_N, Original_Node (Expression (N)));\n+                     Rewrite (Expr, Original_Node (Expression (N)));\n                   end if;\n \n                   --  Avoid expansion of redundant interface conversion\n \n-                  if Is_Interface (Etype (Expr_N))\n-                    and then Nkind (Expr_N) = N_Type_Conversion\n-                    and then Etype (Expr_N) = Typ\n+                  if Is_Interface (Etype (Expr))\n+                    and then Nkind (Expr) = N_Type_Conversion\n+                    and then Etype (Expr) = Typ\n                   then\n-                     Expr_N := Expression (Expr_N);\n-                     Set_Expression (N, Expr_N);\n+                     Expr_Q := Expression (Expr);\n+                  else\n+                     Expr_Q := Expr;\n                   end if;\n \n-                  Obj_Id   := Make_Temporary (Loc, 'D', Expr_N);\n-                  Expr_Typ := Base_Type (Etype (Expr_N));\n+                  Obj_Id   := Make_Temporary (Loc, 'D', Expr_Q);\n+                  Expr_Typ := Base_Type (Etype (Expr_Q));\n \n                   if Is_Class_Wide_Type (Expr_Typ) then\n                      Expr_Typ := Root_Type (Expr_Typ);\n@@ -7544,12 +7547,13 @@ package body Exp_Ch3 is\n                   --  Replace\n                   --     CW : I'Class := Obj;\n                   --  by\n-                  --     Tmp : T := Obj;\n+                  --     Tmp : Typ := Obj;\n                   --     type Ityp is not null access I'Class;\n-                  --     CW  : I'Class renames Ityp (Tmp.I_Tag'Address).all;\n+                  --     Rnn : constant Ityp := Ityp (Tmp.I_Tag'Address);\n+                  --     CW  : I'Class renames Rnn.all;\n \n-                  if Comes_From_Source (Expr_N)\n-                    and then Nkind (Expr_N) = N_Identifier\n+                  if Comes_From_Source (Expr_Q)\n+                    and then Is_Entity_Name (Expr_Q)\n                     and then not Is_Interface (Expr_Typ)\n                     and then Interface_Present_In_Ancestor (Expr_Typ, Typ)\n                     and then (Expr_Typ = Etype (Expr_Typ)\n@@ -7563,7 +7567,7 @@ package body Exp_Ch3 is\n                          Defining_Identifier => Obj_Id,\n                          Object_Definition   =>\n                            New_Occurrence_Of (Expr_Typ, Loc),\n-                         Expression          => Relocate_Node (Expr_N)));\n+                         Expression          => Relocate_Node (Expr_Q)));\n \n                      --  Statically reference the tag associated with the\n                      --  interface\n@@ -7582,8 +7586,9 @@ package body Exp_Ch3 is\n                   --     implicit subtype CW is <Class_Wide_Subtype>;\n                   --     Tmp : CW := CW!(Obj);\n                   --     type Ityp is not null access I'Class;\n-                  --     IW : I'Class renames\n-                  --            Ityp!(Displace (Temp'Address, I'Tag)).all;\n+                  --     Rnn : constant Ityp :=\n+                  --             Ityp!(Displace (Tmp'Address, I'Tag));\n+                  --     IW : I'Class renames Rnn.all;\n \n                   else\n                      --  Generate the equivalent record type and update the\n@@ -7593,10 +7598,10 @@ package body Exp_Ch3 is\n                        (N             => N,\n                         Unc_Type      => Typ,\n                         Subtype_Indic => Obj_Def,\n-                        Exp           => Expr_N);\n+                        Exp           => Expr_Q);\n \n-                     if not Is_Interface (Etype (Expr_N)) then\n-                        New_Expr := Relocate_Node (Expr_N);\n+                     if not Is_Interface (Etype (Expr_Q)) then\n+                        New_Expr := Relocate_Node (Expr_Q);\n \n                      --  For interface types we use 'Address which displaces\n                      --  the pointer to the base of the object (if required)\n@@ -7607,7 +7612,7 @@ package body Exp_Ch3 is\n                             Make_Explicit_Dereference (Loc,\n                               Unchecked_Convert_To (RTE (RE_Tag_Ptr),\n                                 Make_Attribute_Reference (Loc,\n-                                  Prefix => Relocate_Node (Expr_N),\n+                                  Prefix => Relocate_Node (Expr_Q),\n                                   Attribute_Name => Name_Address))));\n                      end if;\n \n@@ -7625,7 +7630,7 @@ package body Exp_Ch3 is\n                      --  This case occurs when the initialization expression\n                      --  has been previously expanded into a temporary object.\n \n-                     else pragma Assert (not Comes_From_Source (Expr_Q));\n+                     else\n                         Insert_Action (N,\n                           Make_Object_Renaming_Declaration (Loc,\n                             Defining_Identifier => Obj_Id,\n@@ -7651,80 +7656,38 @@ package body Exp_Ch3 is\n                               Loc)));\n                   end if;\n \n-                  Rewrite (N,\n-                    Make_Object_Renaming_Declaration (Loc,\n-                      Defining_Identifier => Make_Temporary (Loc, 'D'),\n-                      Subtype_Mark        => New_Occurrence_Of (Typ, Loc),\n-                      Name                =>\n-                        Convert_Tag_To_Interface (Typ, Tag_Comp)));\n-\n-                  --  If the original entity comes from source, then mark the\n-                  --  new entity as needing debug information, even though it's\n-                  --  defined by a generated renaming that does not come from\n-                  --  source, so that Materialize_Entity will be set on the\n-                  --  entity when Debug_Renaming_Declaration is called during\n-                  --  analysis.\n-\n-                  if Comes_From_Source (Def_Id) then\n-                     Set_Debug_Info_Needed (Defining_Identifier (N));\n-                  end if;\n-\n-                  Analyze (N, Suppress => All_Checks);\n-\n-                  --  Replace internal identifier of rewritten node by the\n-                  --  identifier found in the sources. We also have to exchange\n-                  --  entities containing their defining identifiers to ensure\n-                  --  the correct replacement of the object declaration by this\n-                  --  object renaming declaration because these identifiers\n-                  --  were previously added by Enter_Name to the current scope.\n-                  --  We must preserve the homonym chain of the source entity\n-                  --  as well. We must also preserve the kind of the entity,\n-                  --  which may be a constant. Preserve entity chain because\n-                  --  itypes may have been generated already, and the full\n-                  --  chain must be preserved for final freezing. Finally,\n-                  --  preserve Comes_From_Source setting, so that debugging\n-                  --  and cross-referencing information is properly kept, and\n-                  --  preserve source location, to prevent spurious errors when\n-                  --  entities are declared (they must have their own Sloc).\n-\n-                  declare\n-                     New_Id    : constant Entity_Id := Defining_Identifier (N);\n-                     Next_Temp : constant Entity_Id := Next_Entity (New_Id);\n-                     Save_CFS  : constant Boolean   :=\n-                                   Comes_From_Source (Def_Id);\n-                     Save_SP   : constant Node_Id   := SPARK_Pragma (Def_Id);\n-                     Save_SPI  : constant Boolean   :=\n-                                   SPARK_Pragma_Inherited (Def_Id);\n-\n-                  begin\n-                     Link_Entities (New_Id, Next_Entity (Def_Id));\n-                     Link_Entities (Def_Id, Next_Temp);\n+                  --  As explained in Exp_Disp, we use Convert_Tag_To_Interface\n+                  --  to do the final conversion, but we insert an intermediate\n+                  --  temporary before the dereference so that we can process\n+                  --  the expansion as part of the analysis of the declaration\n+                  --  of this temporary, and then rewrite manually the original\n+                  --  object as the simple renaming of this dereference.\n \n-                     Set_Chars (Defining_Identifier (N), Chars (Def_Id));\n-                     Set_Homonym (Defining_Identifier (N), Homonym (Def_Id));\n-                     Mutate_Ekind (Defining_Identifier (N), Ekind (Def_Id));\n-                     Set_Sloc (Defining_Identifier (N), Sloc (Def_Id));\n+                  Tag_Comp := Convert_Tag_To_Interface (Typ, Tag_Comp);\n+                  pragma Assert (Nkind (Tag_Comp) = N_Explicit_Dereference\n+                    and then\n+                      Nkind (Prefix (Tag_Comp)) = N_Unchecked_Type_Conversion);\n \n-                     Set_Comes_From_Source (Def_Id, False);\n+                  Ptr_Obj_Id := Make_Temporary (Loc, 'R');\n \n-                     --  ??? This is extremely dangerous!!! Exchanging entities\n-                     --  is very low level, and as a result it resets flags and\n-                     --  fields which belong to the original Def_Id. Several of\n-                     --  these attributes are saved and restored, but there may\n-                     --  be many more that need to be preserverd.\n+                  Ptr_Obj_Decl :=\n+                    Make_Object_Declaration (Loc,\n+                      Defining_Identifier => Ptr_Obj_Id,\n+                      Constant_Present    => True,\n+                      Object_Definition   =>\n+                        New_Occurrence_Of\n+                          (Entity (Subtype_Mark (Prefix (Tag_Comp))), Loc),\n+                      Expression => Prefix (Tag_Comp));\n \n-                     Exchange_Entities (Defining_Identifier (N), Def_Id);\n+                  Insert_Action (N, Ptr_Obj_Decl, Suppress => All_Checks);\n \n-                     --  Restore clobbered attributes\n+                  Set_Prefix (Tag_Comp, New_Occurrence_Of (Ptr_Obj_Id, Loc));\n+                  Expr_Q := Tag_Comp;\n+                  Set_Etype (Expr_Q, Typ);\n \n-                     Set_Comes_From_Source      (Def_Id, Save_CFS);\n-                     Set_SPARK_Pragma           (Def_Id, Save_SP);\n-                     Set_SPARK_Pragma_Inherited (Def_Id, Save_SPI);\n-                  end;\n+                  Rewrite_As_Renaming := True;\n                end;\n \n-               return;\n-\n             else\n                return;\n             end if;"}, {"sha": "4cb26890ea222f6b145118919aa1f01cd3250a17", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e0175327d333360fbe45346c411a8bc7eee1f1/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e0175327d333360fbe45346c411a8bc7eee1f1/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=09e0175327d333360fbe45346c411a8bc7eee1f1", "patch": "@@ -2391,14 +2391,17 @@ package body Exp_Ch7 is\n \n                --  Detect a case where a source object has been initialized by\n                --  a controlled function call or another object which was later\n-               --  rewritten as a class-wide conversion of Ada.Tags.Displace.\n+               --  rewritten as a class-wide conversion of Ada.Tags.Displace:\n \n-               --     Obj1 : CW_Type := Src_Obj;\n-               --     Obj2 : CW_Type := Function_Call (...);\n+               --     Obj1 : CW_Type := Function_Call (...);\n+               --     Obj2 : CW_Type := Src_Obj;\n \n-               --     Obj1 : CW_Type renames (... Ada.Tags.Displace (Src_Obj));\n                --     Tmp  : ... := Function_Call (...)'reference;\n-               --     Obj2 : CW_Type renames (... Ada.Tags.Displace (Tmp));\n+               --     Rnn  : access CW_Type := (... Ada.Tags.Displace (Tmp));\n+               --     Obj1 : CW_Type renames Rnn.all;\n+\n+               --     Rnn : access CW_Type := (...Ada.Tags.Displace (Src_Obj));\n+               --     Obj2 : CW_Type renames Rnn.all;\n \n                elsif Is_Displacement_Of_Object_Or_Function_Result (Obj_Id) then\n                   Processing_Actions (Has_No_Init => True);"}, {"sha": "245c3cd9dc7e8b980f280e8bf79c060f490b5fe5", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 26, "deletions": 13, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e0175327d333360fbe45346c411a8bc7eee1f1/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e0175327d333360fbe45346c411a8bc7eee1f1/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=09e0175327d333360fbe45346c411a8bc7eee1f1", "patch": "@@ -8339,8 +8339,9 @@ package body Exp_Util is\n \n       --  is rewritten into:\n \n-      --     Temp : ... := Function_Call (...)'reference;\n-      --     Obj  : CW_Type renames (... Ada.Tags.Displace (Temp));\n+      --     Tmp : ... := Function_Call (...)'reference;\n+      --     Rnn : constant access CW_Type := (... Ada.Tags.Displace (Tmp));\n+      --     Obj : CW_Type renames Rnn.all;\n \n       --  where the return type of the function and the class-wide type require\n       --  dispatch table pointer displacement.\n@@ -8351,8 +8352,9 @@ package body Exp_Util is\n \n       --  is rewritten into:\n \n-      --     Temp : ... := Function_Call (Container, ...)'reference;\n-      --     Obj  : CW_Type renames (... Ada.Tags.Displace (Temp));\n+      --     Tmp : ... := Function_Call (Container, ...)'reference;\n+      --     Rnn : constant access CW_Type := (... Ada.Tags.Displace (Tmp));\n+      --     Obj : CW_Type renames Rnn.all;\n \n       --  where the container element type and the class-wide type require\n       --  dispatch table pointer dispacement.\n@@ -8363,14 +8365,21 @@ package body Exp_Util is\n \n       --  is rewritten into:\n \n-      --     Obj : CW_Type renames (... Ada.Tags.Displace (Src_Obj));\n+      --     Rnn : constant access CW_Type := (...Ada.Tags.Displace (Src_Obj));\n+      --     Obj : CW_Type renames Rnn.all;\n \n       --  where the type of the source object and the class-wide type require\n       --  dispatch table pointer displacement.\n \n       if Nkind (Obj_Decl) = N_Object_Renaming_Declaration\n         and then Is_Class_Wide_Type (Obj_Typ)\n-        and then Is_Displace_Call (Renamed_Object (Obj_Id))\n+        and then not Is_Special_Return_Object (Obj_Id)\n+        and then Nkind (Renamed_Object (Obj_Id)) = N_Explicit_Dereference\n+        and then Is_Entity_Name (Prefix (Renamed_Object (Obj_Id)))\n+        and then Ekind (Entity (Prefix (Renamed_Object (Obj_Id)))) = E_Constant\n+        and then\n+          Is_Displace_Call\n+            (Constant_Value (Entity (Prefix (Renamed_Object (Obj_Id)))))\n         and then Nkind (Orig_Decl) = N_Object_Declaration\n         and then Comes_From_Source (Orig_Decl)\n       then\n@@ -8380,9 +8389,10 @@ package body Exp_Util is\n            Is_Controlled_Function_Call (Orig_Expr)\n              or else Is_Controlled_Indexing (Orig_Expr)\n              or else Is_Source_Object (Orig_Expr);\n-      end if;\n \n-      return False;\n+      else\n+         return False;\n+      end if;\n    end Is_Displacement_Of_Object_Or_Function_Result;\n \n    ------------------------------\n@@ -12968,14 +12978,17 @@ package body Exp_Util is\n \n             --  Detect a case where a source object has been initialized by\n             --  a controlled function call or another object which was later\n-            --  rewritten as a class-wide conversion of Ada.Tags.Displace.\n+            --  rewritten as a class-wide conversion of Ada.Tags.Displace:\n \n-            --     Obj1 : CW_Type := Src_Obj;\n-            --     Obj2 : CW_Type := Function_Call (...);\n+            --     Obj1 : CW_Type := Function_Call (...);\n+            --     Obj2 : CW_Type := Src_Obj;\n \n-            --     Obj1 : CW_Type renames (... Ada.Tags.Displace (Src_Obj));\n             --     Tmp  : ... := Function_Call (...)'reference;\n-            --     Obj2 : CW_Type renames (... Ada.Tags.Displace (Tmp));\n+            --     Rnn  : access CW_Type := (... Ada.Tags.Displace (Tmp));\n+            --     Obj1 : CW_Type renames Rnn.all;\n+\n+            --     Rnn  : access CW_Type := (... Ada.Tags.Displace (Src_Obj));\n+            --     Obj2 : CW_Type renames Rnn.all;\n \n             elsif Is_Displacement_Of_Object_Or_Function_Result (Obj_Id) then\n                return True;"}]}