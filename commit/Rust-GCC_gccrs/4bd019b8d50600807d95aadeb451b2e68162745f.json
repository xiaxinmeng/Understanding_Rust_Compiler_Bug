{"sha": "4bd019b8d50600807d95aadeb451b2e68162745f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGJkMDE5YjhkNTA2MDA4MDdkOTVhYWRlYjQ1MWIyZTY4MTYyNzQ1Zg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-02-11T09:11:06Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-02-11T09:11:06Z"}, "message": "re PR ipa/65005 (FAIL: c-c++-common/torture/builtin-arith-overflow-12.c)\n\n\tPR ipa/65005\n\t* ipa-visibility.c (cgraph_node::non_local_p): Turn into static\n\tfunction.\n\t* symtab.c (symtab_node::verify_base): Remove check that non-definitions\n\thave no comdat group.\n\t* lto-cgraph.c (lto_output_node): Always output thunk and alias info.\n\t(lto_output_varpool_node): Always output alias info.\n\t(output_refs): Output refs of boundary aliases, too.\n\t(compute_ltrans_boundary): Add alias and thunk target into boundaries.\n\t(output_symtab): Output call eges in thunks in boundary.\n\t(get_alias_symbol): Remove.\n\t(input_node, input_varpool_node): Do not special case weakrefs.\n\t* ipa.c (symbol_table::remove_unreachable_nodes): Do not remove\n\talias and thunks targets in the boundary; do not take removed symbols\n\tfrom their comdat groups.\n\t* cgraph.c (cgraph_node::local_info): Look through aliases and thunks.\n\t(cgraph_node::global_info): Remove.\n\t(cgraph_node::rtl_info): Look through aliases and thunks.\n\t* cgrpah.h (global_info): Remove.\n\t(non_local_p): Remove.\n\nFrom-SVN: r220608", "tree": {"sha": "b7dae2a1fbb3c0a2609733cd211669c59ad0e68b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b7dae2a1fbb3c0a2609733cd211669c59ad0e68b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4bd019b8d50600807d95aadeb451b2e68162745f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bd019b8d50600807d95aadeb451b2e68162745f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4bd019b8d50600807d95aadeb451b2e68162745f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bd019b8d50600807d95aadeb451b2e68162745f/comments", "author": null, "committer": null, "parents": [{"sha": "80f6181e2727fc2c2d74b603f94d44ae36daae66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80f6181e2727fc2c2d74b603f94d44ae36daae66", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80f6181e2727fc2c2d74b603f94d44ae36daae66"}], "stats": {"total": 140, "additions": 76, "deletions": 64}, "files": [{"sha": "c9e0a22552cdd1e310cfd59cbaf8575d0054d717", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bd019b8d50600807d95aadeb451b2e68162745f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bd019b8d50600807d95aadeb451b2e68162745f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4bd019b8d50600807d95aadeb451b2e68162745f", "patch": "@@ -1,3 +1,26 @@\n+2015-02-10  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR ipa/65005\n+\t* ipa-visibility.c (cgraph_node::non_local_p): Turn into static\n+\tfunction.\n+\t* symtab.c (symtab_node::verify_base): Remove check that non-definitions\n+\thave no comdat group.\n+\t* lto-cgraph.c (lto_output_node): Always output thunk and alias info.\n+\t(lto_output_varpool_node): Always output alias info.\n+\t(output_refs): Output refs of boundary aliases, too.\n+\t(compute_ltrans_boundary): Add alias and thunk target into boundaries.\n+\t(output_symtab): Output call eges in thunks in boundary.\n+\t(get_alias_symbol): Remove.\n+\t(input_node, input_varpool_node): Do not special case weakrefs.\n+\t* ipa.c (symbol_table::remove_unreachable_nodes): Do not remove\n+\talias and thunks targets in the boundary; do not take removed symbols\n+\tfrom their comdat groups.\n+\t* cgraph.c (cgraph_node::local_info): Look through aliases and thunks.\n+\t(cgraph_node::global_info): Remove.\n+\t(cgraph_node::rtl_info): Look through aliases and thunks.\n+\t* cgrpah.h (global_info): Remove.\n+\t(non_local_p): Remove.\n+\n 2015-02-10  David Wohlferd  <dw@LimeGreenSocks.com>\n \t    Sandra Loosemore  <sandra@codesourcery.com>\n "}, {"sha": "a71f68ca4e0c692379a0c662f2799a0adbec6c0f", "filename": "gcc/cgraph.c", "status": "modified", "additions": 7, "deletions": 18, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bd019b8d50600807d95aadeb451b2e68162745f/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bd019b8d50600807d95aadeb451b2e68162745f/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=4bd019b8d50600807d95aadeb451b2e68162745f", "patch": "@@ -1846,20 +1846,7 @@ cgraph_node::local_info (tree decl)\n   cgraph_node *node = get (decl);\n   if (!node)\n     return NULL;\n-  return &node->local;\n-}\n-\n-/* Return global info for the compiled function.  */\n-\n-cgraph_global_info *\n-cgraph_node::global_info (tree decl)\n-{\n-  gcc_assert (TREE_CODE (decl) == FUNCTION_DECL\n-    && symtab->global_info_ready);\n-  cgraph_node *node = get (decl);\n-  if (!node)\n-    return NULL;\n-  return &node->global;\n+  return &node->ultimate_alias_target ()->local;\n }\n \n /* Return local info for the compiled function.  */\n@@ -1869,11 +1856,13 @@ cgraph_node::rtl_info (tree decl)\n {\n   gcc_assert (TREE_CODE (decl) == FUNCTION_DECL);\n   cgraph_node *node = get (decl);\n-  if (!node\n-      || (decl != current_function_decl\n-\t  && !TREE_ASM_WRITTEN (node->decl)))\n+  if (!node)\n+    return NULL;\n+  node = node->ultimate_alias_target ();\n+  if (node->decl != current_function_decl\n+      && !TREE_ASM_WRITTEN (node->decl))\n     return NULL;\n-  return &node->rtl;\n+  return &node->ultimate_alias_target ()->rtl;\n }\n \n /* Return a string describing the failure REASON.  */"}, {"sha": "b9a276c3715d5e993728e19cb5020790f999400a", "filename": "gcc/cgraph.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bd019b8d50600807d95aadeb451b2e68162745f/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bd019b8d50600807d95aadeb451b2e68162745f/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=4bd019b8d50600807d95aadeb451b2e68162745f", "patch": "@@ -1164,9 +1164,6 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node {\n   /* Return local info for the compiled function.  */\n   static cgraph_local_info *local_info (tree decl);\n \n-  /* Return global info for the compiled function.  */\n-  static cgraph_global_info *global_info (tree);\n-\n   /* Return local info for the compiled function.  */\n   static cgraph_rtl_info *rtl_info (tree);\n \n@@ -1187,10 +1184,6 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node {\n     return node->used_from_object_file_p ();\n   }\n \n-  /* Return true when cgraph_node can not be local.\n-     Worker for cgraph_local_node_p.  */\n-  static bool non_local_p (cgraph_node *node, void *);\n-\n   /* Verify whole cgraph structure.  */\n   static void DEBUG_FUNCTION verify_cgraph_nodes (void);\n "}, {"sha": "c33ee469dbe96cf3873c3dc60901175a002662d9", "filename": "gcc/ipa-visibility.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bd019b8d50600807d95aadeb451b2e68162745f/gcc%2Fipa-visibility.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bd019b8d50600807d95aadeb451b2e68162745f/gcc%2Fipa-visibility.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-visibility.c?ref=4bd019b8d50600807d95aadeb451b2e68162745f", "patch": "@@ -101,8 +101,8 @@ along with GCC; see the file COPYING3.  If not see\n \n /* Return true when NODE can not be local. Worker for cgraph_local_node_p.  */\n \n-bool\n-cgraph_node::non_local_p (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n+static bool\n+non_local_p (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n {\n   return !(node->only_called_directly_or_aliased_p ()\n \t   /* i386 would need update to output thunk with locak calling\n@@ -124,7 +124,7 @@ cgraph_node::local_p (void)\n \n    if (n->thunk.thunk_p)\n      return n->callees->callee->local_p ();\n-   return !n->call_for_symbol_thunks_and_aliases (cgraph_node::non_local_p,\n+   return !n->call_for_symbol_thunks_and_aliases (non_local_p,\n \t\t\t\t\t\t  NULL, true);\n \t\t\t\t\t\n }"}, {"sha": "620431c54d6b1c2c7b86c877ab18aea3010daec9", "filename": "gcc/ipa.c", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bd019b8d50600807d95aadeb451b2e68162745f/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bd019b8d50600807d95aadeb451b2e68162745f/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=4bd019b8d50600807d95aadeb451b2e68162745f", "patch": "@@ -383,7 +383,11 @@ symbol_table::remove_unreachable_nodes (FILE *file)\n       /* If we are processing symbol in boundary, mark its AUX pointer for\n \t possible later re-processing in enqueue_node.  */\n       if (in_boundary_p)\n-\tnode->aux = (void *)2;\n+\t{\n+\t  node->aux = (void *)2;\n+\t  if (node->alias && node->analyzed)\n+\t    enqueue_node (node->get_alias_target (), &first, &reachable);\n+\t}\n       else\n \t{\n \t  if (TREE_CODE (node->decl) == FUNCTION_DECL\n@@ -486,6 +490,9 @@ symbol_table::remove_unreachable_nodes (FILE *file)\n \t\t}\n \n \t    }\n+\t  else if (cnode->thunk.thunk_p)\n+\t    enqueue_node (cnode->callees->callee, &first, &reachable);\n+\t      \n \t  /* If any reachable function has simd clones, mark them as\n \t     reachable as well.  */\n \t  if (cnode->simd_clones)\n@@ -534,7 +541,7 @@ symbol_table::remove_unreachable_nodes (FILE *file)\n \t    node->release_body ();\n \t  else if (!node->clone_of)\n \t    gcc_assert (in_lto_p || DECL_RESULT (node->decl));\n-\t  if (node->definition)\n+\t  if (node->definition && !node->alias && !node->thunk.thunk_p)\n \t    {\n \t      if (file)\n \t\tfprintf (file, \" %s/%i\", node->name (), node->order);\n@@ -554,7 +561,6 @@ symbol_table::remove_unreachable_nodes (FILE *file)\n \t      if (!node->in_other_partition)\n \t\tnode->local.local = false;\n \t      node->remove_callees ();\n-\t      node->remove_from_same_comdat_group ();\n \t      node->remove_all_references ();\n \t      changed = true;\n \t      if (node->thunk.thunk_p\n@@ -614,7 +620,7 @@ symbol_table::remove_unreachable_nodes (FILE *file)\n \t  vnode->remove ();\n \t  changed = true;\n \t}\n-      else if (!reachable.contains (vnode))\n+      else if (!reachable.contains (vnode) && !vnode->alias)\n         {\n \t  tree init;\n \t  if (vnode->definition)"}, {"sha": "c0fa47d2c25aea672f4bd10229afddc02a974415", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 33, "deletions": 27, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bd019b8d50600807d95aadeb451b2e68162745f/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bd019b8d50600807d95aadeb451b2e68162745f/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=4bd019b8d50600807d95aadeb451b2e68162745f", "patch": "@@ -432,14 +432,13 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n   struct cgraph_node *clone_of, *ultimate_clone_of;\n   ipa_opt_pass_d *pass;\n   int i;\n-  bool alias_p;\n   const char *comdat;\n   const char *section;\n   tree group;\n \n   boundary_p = !lto_symtab_encoder_in_partition_p (encoder, node);\n \n-  if (node->analyzed && !boundary_p)\n+  if (node->analyzed && (!boundary_p || node->alias || node->thunk.thunk_p))\n     tag = LTO_symtab_analyzed_node;\n   else\n     tag = LTO_symtab_unavail_node;\n@@ -565,14 +564,7 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n \t\t     || referenced_from_other_partition_p (node, encoder)), 1);\n   bp_pack_value (&bp, node->lowered, 1);\n   bp_pack_value (&bp, in_other_partition, 1);\n-  /* Real aliases in a boundary become non-aliases. However we still stream\n-     alias info on weakrefs. \n-     TODO: We lose a bit of information here - when we know that variable is\n-     defined in other unit, we may use the info on aliases to resolve \n-     symbol1 != symbol2 type tests that we can do only for locally defined objects\n-     otherwise.  */\n-  alias_p = node->alias && (!boundary_p || node->weakref);\n-  bp_pack_value (&bp, alias_p, 1);\n+  bp_pack_value (&bp, node->alias, 1);\n   bp_pack_value (&bp, node->weakref, 1);\n   bp_pack_value (&bp, node->frequency, 2);\n   bp_pack_value (&bp, node->only_called_at_startup, 1);\n@@ -581,14 +573,14 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n   bp_pack_value (&bp, node->calls_comdat_local, 1);\n   bp_pack_value (&bp, node->icf_merged, 1);\n   bp_pack_value (&bp, node->nonfreeing_fn, 1);\n-  bp_pack_value (&bp, node->thunk.thunk_p && !boundary_p, 1);\n+  bp_pack_value (&bp, node->thunk.thunk_p, 1);\n   bp_pack_enum (&bp, ld_plugin_symbol_resolution,\n \t        LDPR_NUM_KNOWN, node->resolution);\n   bp_pack_value (&bp, node->instrumentation_clone, 1);\n   streamer_write_bitpack (&bp);\n   streamer_write_data_stream (ob->main_stream, section, strlen (section) + 1);\n \n-  if (node->thunk.thunk_p && !boundary_p)\n+  if (node->thunk.thunk_p)\n     {\n       streamer_write_uhwi_stream\n \t (ob->main_stream,\n@@ -618,7 +610,6 @@ lto_output_varpool_node (struct lto_simple_output_block *ob, varpool_node *node,\n   bool boundary_p = !lto_symtab_encoder_in_partition_p (encoder, node);\n   struct bitpack_d bp;\n   int ref;\n-  bool alias_p;\n   const char *comdat;\n   const char *section;\n   tree group;\n@@ -638,8 +629,7 @@ lto_output_varpool_node (struct lto_simple_output_block *ob, varpool_node *node,\n   bp_pack_value (&bp, node->implicit_section, 1);\n   bp_pack_value (&bp, node->writeonly, 1);\n   bp_pack_value (&bp, node->definition, 1);\n-  alias_p = node->alias && (!boundary_p || node->weakref);\n-  bp_pack_value (&bp, alias_p, 1);\n+  bp_pack_value (&bp, node->alias, 1);\n   bp_pack_value (&bp, node->weakref, 1);\n   bp_pack_value (&bp, node->analyzed && !boundary_p, 1);\n   gcc_assert (node->definition || !node->analyzed);\n@@ -794,26 +784,26 @@ output_outgoing_cgraph_edges (struct cgraph_edge *edge,\n static void\n output_refs (lto_symtab_encoder_t encoder)\n {\n-  lto_symtab_encoder_iterator lsei;\n   struct lto_simple_output_block *ob;\n   int count;\n   struct ipa_ref *ref;\n-  int i;\n \n   ob = lto_create_simple_output_block (LTO_section_refs);\n \n-  for (lsei = lsei_start_in_partition (encoder); !lsei_end_p (lsei);\n-       lsei_next_in_partition (&lsei))\n+  for (int i = 0; i < lto_symtab_encoder_size (encoder); i++)\n     {\n-      symtab_node *node = lsei_node (lsei);\n+      symtab_node *node = lto_symtab_encoder_deref (encoder, i);\n+\n+      if (!node->alias && !lto_symtab_encoder_in_partition_p (encoder, node))\n+\tcontinue;\n \n       count = node->ref_list.nreferences ();\n       if (count)\n \t{\n \t  streamer_write_gcov_count_stream (ob->main_stream, count);\n \t  streamer_write_uhwi_stream (ob->main_stream,\n \t\t\t\t     lto_symtab_encoder_lookup (encoder, node));\n-\t  for (i = 0; node->iterate_reference (i, ref); i++)\n+\t  for (int i = 0; node->iterate_reference (i, ref); i++)\n \t    lto_output_ref (ob, ref, encoder);\n \t}\n     }\n@@ -987,6 +977,19 @@ compute_ltrans_boundary (lto_symtab_encoder_t in_encoder)\n \t\t}\n \t    }\n     }\n+  /* Be sure to also insert alias targert and thunk callees.  These needs\n+     to stay to aid local calling conventions.  */\n+  for (i = 0; i < lto_symtab_encoder_size (encoder); i++)\n+    {\n+      symtab_node *node = lto_symtab_encoder_deref (encoder, i);\n+      cgraph_node *cnode = dyn_cast <cgraph_node *> (node);\n+\n+      if (node->alias && node->analyzed)\n+\tcreate_references (encoder, node);\n+      if (cnode\n+\t  && cnode->thunk.thunk_p)\n+\tadd_node_to (encoder, cnode->callees->callee, false);\n+    }\n   lto_symtab_encoder_delete (in_encoder);\n   return encoder;\n }\n@@ -998,7 +1001,6 @@ output_symtab (void)\n {\n   struct cgraph_node *node;\n   struct lto_simple_output_block *ob;\n-  lto_symtab_encoder_iterator lsei;\n   int i, n_nodes;\n   lto_symtab_encoder_t encoder;\n \n@@ -1028,12 +1030,16 @@ output_symtab (void)\n     }\n \n   /* Go over the nodes in SET again to write edges.  */\n-  for (lsei = lsei_start_function_in_partition (encoder); !lsei_end_p (lsei);\n-       lsei_next_function_in_partition (&lsei))\n+  for (int i = 0; i < lto_symtab_encoder_size (encoder); i++)\n     {\n-      node = lsei_cgraph_node (lsei);\n-      output_outgoing_cgraph_edges (node->callees, ob, encoder);\n-      output_outgoing_cgraph_edges (node->indirect_calls, ob, encoder);\n+      node = dyn_cast <cgraph_node *> (lto_symtab_encoder_deref (encoder, i));\n+      if (node\n+\t  && (node->thunk.thunk_p\n+\t      || lto_symtab_encoder_in_partition_p (encoder, node)))\n+\t{\n+\t  output_outgoing_cgraph_edges (node->callees, ob, encoder);\n+\t  output_outgoing_cgraph_edges (node->indirect_calls, ob, encoder);\n+\t}\n     }\n \n   streamer_write_uhwi_stream (ob->main_stream, 0);"}, {"sha": "3bfb04a25c12474f0702e22e75c55633248bee34", "filename": "gcc/symtab.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bd019b8d50600807d95aadeb451b2e68162745f/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bd019b8d50600807d95aadeb451b2e68162745f/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=4bd019b8d50600807d95aadeb451b2e68162745f", "patch": "@@ -1070,11 +1070,6 @@ symtab_node::verify_base (void)\n \t  error (\"same_comdat_group list across different groups\");\n \t  error_found = true;\n \t}\n-      if (!n->definition)\n-\t{\n-\t  error (\"Node has same_comdat_group but it is not a definition\");\n-\t  error_found = true;\n-\t}\n       if (n->type != type)\n \t{\n \t  error (\"mixing different types of symbol in same comdat groups is not supported\");"}]}