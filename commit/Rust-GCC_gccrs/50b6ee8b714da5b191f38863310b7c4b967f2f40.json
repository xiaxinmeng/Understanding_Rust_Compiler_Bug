{"sha": "50b6ee8b714da5b191f38863310b7c4b967f2f40", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTBiNmVlOGI3MTRkYTViMTkxZjM4ODYzMzEwYjdjNGI5NjdmMmY0MA==", "commit": {"author": {"name": "DJ Delorie", "email": "dj@redhat.com", "date": "2014-08-29T23:35:12Z"}, "committer": {"name": "DJ Delorie", "email": "dj@gcc.gnu.org", "date": "2014-08-29T23:35:12Z"}, "message": "cppbuiltin.c (define_builtin_macros_for_type_sizes): Round pointer size up to a power of two.\n\n* cppbuiltin.c (define_builtin_macros_for_type_sizes): Round\npointer size up to a power of two.\n* defaults.h (DWARF2_ADDR_SIZE): Round up.\n(POINTER_SIZE_UNITS): New, rounded up value.\n* dwarf2asm.c (size_of_encoded_value): Use it.\n(dw2_output_indirect_constant_1): Likewise.\n* expmed.c (init_expmed_one_conv): We now know the sizes of\npartial int modes.\n* loop-iv.c (iv_number_of_iterations): Use precision, not size.\n* optabs.c (expand_float): Use precision, not size.\n(expand_fix): Likewise.\n* simplify-rtx (simplify_unary_operation_1): Likewise.\n* tree-dfa.c (get_ref_base_and_extent): Likewise.\n* varasm.c (assemble_addr_to_section): Round up pointer sizes.\n(default_assemble_integer) Likewise.\n(dump_tm_clone_pairs): Likewise.\n* dwarf2out.c (mem_loc_descriptor): Allow partial-int modes also.\n* var-tracking.c (adjust_mems): Allow partial-int modes also.\n(prepare_call_arguments): Likewise.\n* stor-layout.c (finalize_type_size): Preserve precision.\n(layout_type): Use precision, not size.\n\nFrom-SVN: r214748", "tree": {"sha": "94afbeb41e705981bf09d1e0992c8f8c7f911054", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/94afbeb41e705981bf09d1e0992c8f8c7f911054"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/50b6ee8b714da5b191f38863310b7c4b967f2f40", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50b6ee8b714da5b191f38863310b7c4b967f2f40", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50b6ee8b714da5b191f38863310b7c4b967f2f40", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50b6ee8b714da5b191f38863310b7c4b967f2f40/comments", "author": null, "committer": null, "parents": [{"sha": "aea3d681ec784b1a44ee3b37b0df2b71bdfadfc3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aea3d681ec784b1a44ee3b37b0df2b71bdfadfc3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aea3d681ec784b1a44ee3b37b0df2b71bdfadfc3"}], "stats": {"total": 130, "additions": 87, "deletions": 43}, "files": [{"sha": "44ad2b2bbaee21acf9a57ce594a9788d239b163e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50b6ee8b714da5b191f38863310b7c4b967f2f40/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50b6ee8b714da5b191f38863310b7c4b967f2f40/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=50b6ee8b714da5b191f38863310b7c4b967f2f40", "patch": "@@ -1,5 +1,27 @@\n 2014-08-29  DJ Delorie  <dj@redhat.com>\n \n+\t* cppbuiltin.c (define_builtin_macros_for_type_sizes): Round\n+\tpointer size up to a power of two.\n+\t* defaults.h (DWARF2_ADDR_SIZE): Round up.\n+\t(POINTER_SIZE_UNITS): New, rounded up value.\n+\t* dwarf2asm.c (size_of_encoded_value): Use it.\n+\t(dw2_output_indirect_constant_1): Likewise.\n+\t* expmed.c (init_expmed_one_conv): We now know the sizes of\n+\tpartial int modes.\n+\t* loop-iv.c (iv_number_of_iterations): Use precision, not size.\n+\t* optabs.c (expand_float): Use precision, not size.\n+\t(expand_fix): Likewise.\n+\t* simplify-rtx (simplify_unary_operation_1): Likewise.\n+\t* tree-dfa.c (get_ref_base_and_extent): Likewise.\n+\t* varasm.c (assemble_addr_to_section): Round up pointer sizes.\n+\t(default_assemble_integer) Likewise.\n+\t(dump_tm_clone_pairs): Likewise.\n+\t* dwarf2out.c (mem_loc_descriptor): Allow partial-int modes also.\n+\t* var-tracking.c (adjust_mems): Allow partial-int modes also.\n+\t(prepare_call_arguments): Likewise.\n+\t* stor-layout.c (finalize_type_size): Preserve precision.\n+\t(layout_type): Use precision, not size.\n+\n \t* expr.c (convert_move): If the target has an explicit converter,\n \tuse it.\n "}, {"sha": "fbcd9b06c657ab897e9752675eff4c6a4a6b9c12", "filename": "gcc/cppbuiltin.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50b6ee8b714da5b191f38863310b7c4b967f2f40/gcc%2Fcppbuiltin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50b6ee8b714da5b191f38863310b7c4b967f2f40/gcc%2Fcppbuiltin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppbuiltin.c?ref=50b6ee8b714da5b191f38863310b7c4b967f2f40", "patch": "@@ -175,7 +175,7 @@ define_builtin_macros_for_type_sizes (cpp_reader *pfile)\n   /* ptr_type_node can't be used here since ptr_mode is only set when\n      toplev calls backend_init which is not done with -E switch.  */\n   cpp_define_formatted (pfile, \"__SIZEOF_POINTER__=%d\",\n-\t\t\tPOINTER_SIZE / BITS_PER_UNIT);\n+\t\t\t1 << ceil_log2 ((POINTER_SIZE + BITS_PER_UNIT - 1) / BITS_PER_UNIT));\n }\n \n "}, {"sha": "1a9950dd4f6eee60c0ba8f4f07e844142dfe7edc", "filename": "gcc/defaults.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50b6ee8b714da5b191f38863310b7c4b967f2f40/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50b6ee8b714da5b191f38863310b7c4b967f2f40/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=50b6ee8b714da5b191f38863310b7c4b967f2f40", "patch": "@@ -451,7 +451,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n    Dwarf 2 addresses need to be larger than the architecture's\n    pointers.  */\n #ifndef DWARF2_ADDR_SIZE\n-#define DWARF2_ADDR_SIZE (POINTER_SIZE / BITS_PER_UNIT)\n+#define DWARF2_ADDR_SIZE ((POINTER_SIZE + BITS_PER_UNIT - 1) / BITS_PER_UNIT)\n #endif\n \n /* The size in bytes of a DWARF field indicating an offset or length\n@@ -751,6 +751,10 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #ifndef POINTER_SIZE\n #define POINTER_SIZE BITS_PER_WORD\n #endif\n+#ifndef POINTER_SIZE_UNITS\n+#define POINTER_SIZE_UNITS ((POINTER_SIZE + BITS_PER_UNIT - 1) / BITS_PER_UNIT)\n+#endif\n+\n \n #ifndef PIC_OFFSET_TABLE_REGNUM\n #define PIC_OFFSET_TABLE_REGNUM INVALID_REGNUM"}, {"sha": "b437005461d8b00b8f4e4a147e6f4f172ed76d3b", "filename": "gcc/dwarf2asm.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50b6ee8b714da5b191f38863310b7c4b967f2f40/gcc%2Fdwarf2asm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50b6ee8b714da5b191f38863310b7c4b967f2f40/gcc%2Fdwarf2asm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2asm.c?ref=50b6ee8b714da5b191f38863310b7c4b967f2f40", "patch": "@@ -390,7 +390,7 @@ size_of_encoded_value (int encoding)\n   switch (encoding & 0x07)\n     {\n     case DW_EH_PE_absptr:\n-      return POINTER_SIZE / BITS_PER_UNIT;\n+      return POINTER_SIZE_UNITS;\n     case DW_EH_PE_udata2:\n       return 2;\n     case DW_EH_PE_udata4:\n@@ -920,7 +920,7 @@ dw2_output_indirect_constant_1 (splay_tree_node node,\n \n   sym_ref = gen_rtx_SYMBOL_REF (Pmode, sym);\n   assemble_variable (decl, 1, 1, 1);\n-  assemble_integer (sym_ref, POINTER_SIZE / BITS_PER_UNIT, POINTER_SIZE, 1);\n+  assemble_integer (sym_ref, POINTER_SIZE_UNITS, POINTER_SIZE, 1);\n \n   return 0;\n }"}, {"sha": "7c0be8686efbb2295bef8a7b67447a875c94292a", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50b6ee8b714da5b191f38863310b7c4b967f2f40/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50b6ee8b714da5b191f38863310b7c4b967f2f40/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=50b6ee8b714da5b191f38863310b7c4b967f2f40", "patch": "@@ -12576,7 +12576,8 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n \t pool.  */\n     case CONST:\n     case SYMBOL_REF:\n-      if (GET_MODE_CLASS (mode) != MODE_INT\n+      if ((GET_MODE_CLASS (mode) != MODE_INT\n+\t   && GET_MODE_CLASS (mode) != MODE_PARTIAL_INT)\n \t  || (GET_MODE_SIZE (mode) > DWARF2_ADDR_SIZE\n #ifdef POINTERS_EXTEND_UNSIGNED\n \t      && (mode != Pmode || mem_mode == VOIDmode)"}, {"sha": "1eb712e84ba82091ce00b85bacaa05c886a5f97a", "filename": "gcc/expmed.c", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50b6ee8b714da5b191f38863310b7c4b967f2f40/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50b6ee8b714da5b191f38863310b7c4b967f2f40/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=50b6ee8b714da5b191f38863310b7c4b967f2f40", "patch": "@@ -118,13 +118,19 @@ init_expmed_one_conv (struct init_expmed_rtl *all, enum machine_mode to_mode,\n   int to_size, from_size;\n   rtx which;\n \n-  /* We're given no information about the true size of a partial integer,\n-     only the size of the \"full\" integer it requires for storage.  For\n-     comparison purposes here, reduce the bit size by one in that case.  */\n-  to_size = (GET_MODE_BITSIZE (to_mode)\n-\t     - (GET_MODE_CLASS (to_mode) == MODE_PARTIAL_INT));\n-  from_size = (GET_MODE_BITSIZE (from_mode)\n-\t       - (GET_MODE_CLASS (from_mode) == MODE_PARTIAL_INT));\n+  to_size = GET_MODE_PRECISION (to_mode);\n+  from_size = GET_MODE_PRECISION (from_mode);\n+\n+  /* Most partial integers have a precision less than the \"full\"\n+     integer it requires for storage.  In case one doesn't, for\n+     comparison purposes here, reduce the bit size by one in that\n+     case.  */\n+  if (GET_MODE_CLASS (to_mode) == MODE_PARTIAL_INT\n+      && exact_log2 (to_size) != -1)\n+    to_size --;\n+  if (GET_MODE_CLASS (from_mode) == MODE_PARTIAL_INT\n+      && exact_log2 (from_size) != -1)\n+    from_size --;\n   \n   /* Assume cost of zero-extend and sign-extend is the same.  */\n   which = (to_size < from_size ? all->trunc : all->zext);"}, {"sha": "2e766630fd6af201eddc384355d12e0408012169", "filename": "gcc/loop-iv.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50b6ee8b714da5b191f38863310b7c4b967f2f40/gcc%2Floop-iv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50b6ee8b714da5b191f38863310b7c4b967f2f40/gcc%2Floop-iv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-iv.c?ref=50b6ee8b714da5b191f38863310b7c4b967f2f40", "patch": "@@ -2430,7 +2430,7 @@ iv_number_of_iterations (struct loop *loop, rtx_insn *insn, rtx condition,\n \n   comp_mode = iv0.extend_mode;\n   mode = iv0.mode;\n-  size = GET_MODE_BITSIZE (mode);\n+  size = GET_MODE_PRECISION (mode);\n   get_mode_bounds (mode, (cond == LE || cond == LT), comp_mode, &mmin, &mmax);\n   mode_mmin = lowpart_subreg (mode, mmin, comp_mode);\n   mode_mmax = lowpart_subreg (mode, mmax, comp_mode);"}, {"sha": "84d38e7ce8415a896f67f079301ff0624e05d1cb", "filename": "gcc/optabs.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50b6ee8b714da5b191f38863310b7c4b967f2f40/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50b6ee8b714da5b191f38863310b7c4b967f2f40/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=50b6ee8b714da5b191f38863310b7c4b967f2f40", "patch": "@@ -5205,7 +5205,7 @@ expand_float (rtx to, rtx from, int unsignedp)\n       rtx value;\n       convert_optab tab = unsignedp ? ufloat_optab : sfloat_optab;\n \n-      if (GET_MODE_SIZE (GET_MODE (from)) < GET_MODE_SIZE (SImode))\n+      if (GET_MODE_PRECISION (GET_MODE (from)) < GET_MODE_PRECISION (SImode))\n \tfrom = convert_to_mode (SImode, from, unsignedp);\n \n       libfunc = convert_optab_libfunc (tab, GET_MODE (to), GET_MODE (from));\n@@ -5383,7 +5383,7 @@ expand_fix (rtx to, rtx from, int unsignedp)\n      that the mode of TO is at least as wide as SImode, since those are the\n      only library calls we know about.  */\n \n-  if (GET_MODE_SIZE (GET_MODE (to)) < GET_MODE_SIZE (SImode))\n+  if (GET_MODE_PRECISION (GET_MODE (to)) < GET_MODE_PRECISION (SImode))\n     {\n       target = gen_reg_rtx (SImode);\n "}, {"sha": "9478b3c1f1ee43935be8bed67b9016c93985209d", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50b6ee8b714da5b191f38863310b7c4b967f2f40/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50b6ee8b714da5b191f38863310b7c4b967f2f40/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=50b6ee8b714da5b191f38863310b7c4b967f2f40", "patch": "@@ -1364,8 +1364,8 @@ simplify_unary_operation_1 (enum rtx_code code, enum machine_mode mode, rtx op)\n \t (sign_extend:M (zero_extend:N <X>)) is (zero_extend:M <X>).  */\n       if (GET_CODE (op) == SIGN_EXTEND || GET_CODE (op) == ZERO_EXTEND)\n \t{\n-\t  gcc_assert (GET_MODE_BITSIZE (mode)\n-\t\t      > GET_MODE_BITSIZE (GET_MODE (op)));\n+\t  gcc_assert (GET_MODE_PRECISION (mode)\n+\t\t      > GET_MODE_PRECISION (GET_MODE (op)));\n \t  return simplify_gen_unary (GET_CODE (op), mode, XEXP (op, 0),\n \t\t\t\t     GET_MODE (XEXP (op, 0)));\n \t}\n@@ -1476,15 +1476,15 @@ simplify_unary_operation_1 (enum rtx_code code, enum machine_mode mode, rtx op)\n \n       /* (zero_extend:M (lshiftrt:N (ashift <X> (const_int I)) (const_int I)))\n \t is (zero_extend:M (subreg:O <X>)) if there is mode with\n-\t GET_MODE_BITSIZE (N) - I bits.  */\n+\t GET_MODE_PRECISION (N) - I bits.  */\n       if (GET_CODE (op) == LSHIFTRT\n \t  && GET_CODE (XEXP (op, 0)) == ASHIFT\n \t  && CONST_INT_P (XEXP (op, 1))\n \t  && XEXP (XEXP (op, 0), 1) == XEXP (op, 1)\n-\t  && GET_MODE_BITSIZE (GET_MODE (op)) > INTVAL (XEXP (op, 1)))\n+\t  && GET_MODE_PRECISION (GET_MODE (op)) > INTVAL (XEXP (op, 1)))\n \t{\n \t  enum machine_mode tmode\n-\t    = mode_for_size (GET_MODE_BITSIZE (GET_MODE (op))\n+\t    = mode_for_size (GET_MODE_PRECISION (GET_MODE (op))\n \t\t\t     - INTVAL (XEXP (op, 1)), MODE_INT, 1);\n \t  if (tmode != BLKmode)\n \t    {\n@@ -3079,10 +3079,10 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n #if defined(HAVE_rotate) && defined(HAVE_rotatert)\n       if (CONST_INT_P (trueop1)\n \t  && IN_RANGE (INTVAL (trueop1),\n-\t\t       GET_MODE_BITSIZE (mode) / 2 + (code == ROTATE),\n-\t\t       GET_MODE_BITSIZE (mode) - 1))\n+\t\t       GET_MODE_PRECISION (mode) / 2 + (code == ROTATE),\n+\t\t       GET_MODE_PRECISION (mode) - 1))\n \treturn simplify_gen_binary (code == ROTATE ? ROTATERT : ROTATE,\n-\t\t\t\t    mode, op0, GEN_INT (GET_MODE_BITSIZE (mode)\n+\t\t\t\t    mode, op0, GEN_INT (GET_MODE_PRECISION (mode)\n \t\t\t\t\t\t\t- INTVAL (trueop1)));\n #endif\n       /* FALLTHRU */\n@@ -3099,7 +3099,7 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n     canonicalize_shift:\n       if (SHIFT_COUNT_TRUNCATED && CONST_INT_P (op1))\n \t{\n-\t  val = INTVAL (op1) & (GET_MODE_BITSIZE (mode) - 1);\n+\t  val = INTVAL (op1) & (GET_MODE_PRECISION (mode) - 1);\n \t  if (val != INTVAL (op1))\n \t    return simplify_gen_binary (code, mode, op0, GEN_INT (val));\n \t}\n@@ -3779,7 +3779,8 @@ simplify_const_binary_operation (enum rtx_code code, enum machine_mode mode,\n     }\n \n   /* We can fold some multi-word operations.  */\n-  if (GET_MODE_CLASS (mode) == MODE_INT\n+  if ((GET_MODE_CLASS (mode) == MODE_INT\n+       || GET_MODE_CLASS (mode) == MODE_PARTIAL_INT)\n       && CONST_SCALAR_INT_P (op0)\n       && CONST_SCALAR_INT_P (op1))\n     {"}, {"sha": "8328326facff143a128ad1e69dd95cfffad0a073", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50b6ee8b714da5b191f38863310b7c4b967f2f40/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50b6ee8b714da5b191f38863310b7c4b967f2f40/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=50b6ee8b714da5b191f38863310b7c4b967f2f40", "patch": "@@ -1785,6 +1785,7 @@ finalize_type_size (tree type)\n       tree size = TYPE_SIZE (type);\n       tree size_unit = TYPE_SIZE_UNIT (type);\n       unsigned int align = TYPE_ALIGN (type);\n+      unsigned int precision = TYPE_PRECISION (type);\n       unsigned int user_align = TYPE_USER_ALIGN (type);\n       enum machine_mode mode = TYPE_MODE (type);\n \n@@ -1796,6 +1797,7 @@ finalize_type_size (tree type)\n \t  TYPE_SIZE (variant) = size;\n \t  TYPE_SIZE_UNIT (variant) = size_unit;\n \t  TYPE_ALIGN (variant) = align;\n+\t  TYPE_PRECISION (variant) = precision;\n \t  TYPE_USER_ALIGN (variant) = user_align;\n \t  SET_TYPE_MODE (variant, mode);\n \t}\n@@ -2132,6 +2134,7 @@ layout_type (tree type)\n       SET_TYPE_MODE (type,\n \t\t     smallest_mode_for_size (TYPE_PRECISION (type), MODE_INT));\n       TYPE_SIZE (type) = bitsize_int (GET_MODE_BITSIZE (TYPE_MODE (type)));\n+      /* Don't set TYPE_PRECISION here, as it may be set by a bitfield.  */\n       TYPE_SIZE_UNIT (type) = size_int (GET_MODE_SIZE (TYPE_MODE (type)));\n       break;\n \n@@ -2202,9 +2205,9 @@ layout_type (tree type)\n \n     case OFFSET_TYPE:\n       TYPE_SIZE (type) = bitsize_int (POINTER_SIZE);\n-      TYPE_SIZE_UNIT (type) = size_int (POINTER_SIZE / BITS_PER_UNIT);\n-      /* A pointer might be MODE_PARTIAL_INT,\n-\t but ptrdiff_t must be integral.  */\n+      TYPE_SIZE_UNIT (type) = size_int (POINTER_SIZE_UNITS);\n+      /* A pointer might be MODE_PARTIAL_INT, but ptrdiff_t must be\n+\t integral, which may be an __intN.  */\n       SET_TYPE_MODE (type, mode_for_size (POINTER_SIZE, MODE_INT, 0));\n       TYPE_PRECISION (type) = POINTER_SIZE;\n       break;\n@@ -2232,7 +2235,7 @@ layout_type (tree type)\n \tTYPE_SIZE (type) = bitsize_int (GET_MODE_BITSIZE (mode));\n \tTYPE_SIZE_UNIT (type) = size_int (GET_MODE_SIZE (mode));\n \tTYPE_UNSIGNED (type) = 1;\n-\tTYPE_PRECISION (type) = GET_MODE_BITSIZE (mode);\n+\tTYPE_PRECISION (type) = GET_MODE_PRECISION (mode);\n       }\n       break;\n "}, {"sha": "8459043f750df3154e40638581e3cd786d482249", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50b6ee8b714da5b191f38863310b7c4b967f2f40/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50b6ee8b714da5b191f38863310b7c4b967f2f40/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=50b6ee8b714da5b191f38863310b7c4b967f2f40", "patch": "@@ -407,7 +407,7 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n       if (mode == BLKmode)\n \tsize_tree = TYPE_SIZE (TREE_TYPE (exp));\n       else\n-\tbitsize = int (GET_MODE_BITSIZE (mode));\n+\tbitsize = int (GET_MODE_PRECISION (mode));\n     }\n   if (size_tree != NULL_TREE\n       && TREE_CODE (size_tree) == INTEGER_CST)"}, {"sha": "52b7344458086b40bfa6c468b460e7f8e320eb72", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50b6ee8b714da5b191f38863310b7c4b967f2f40/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50b6ee8b714da5b191f38863310b7c4b967f2f40/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=50b6ee8b714da5b191f38863310b7c4b967f2f40", "patch": "@@ -1141,10 +1141,12 @@ adjust_mems (rtx loc, const_rtx old_rtx, void *data)\n \t      || GET_CODE (SUBREG_REG (tem)) == MINUS\n \t      || GET_CODE (SUBREG_REG (tem)) == MULT\n \t      || GET_CODE (SUBREG_REG (tem)) == ASHIFT)\n-\t  && GET_MODE_CLASS (GET_MODE (tem)) == MODE_INT\n-\t  && GET_MODE_CLASS (GET_MODE (SUBREG_REG (tem))) == MODE_INT\n-\t  && GET_MODE_SIZE (GET_MODE (tem))\n-\t     < GET_MODE_SIZE (GET_MODE (SUBREG_REG (tem)))\n+\t  && (GET_MODE_CLASS (GET_MODE (tem)) == MODE_INT\n+\t      || GET_MODE_CLASS (GET_MODE (tem)) == MODE_PARTIAL_INT)\n+\t  && (GET_MODE_CLASS (GET_MODE (SUBREG_REG (tem))) == MODE_INT\n+\t      || GET_MODE_CLASS (GET_MODE (SUBREG_REG (tem))) == MODE_PARTIAL_INT)\n+\t  && GET_MODE_PRECISION (GET_MODE (tem))\n+\t     < GET_MODE_PRECISION (GET_MODE (SUBREG_REG (tem)))\n \t  && subreg_lowpart_p (tem)\n \t  && use_narrower_mode_test (SUBREG_REG (tem), tem))\n \treturn use_narrower_mode (SUBREG_REG (tem), GET_MODE (tem),\n@@ -6240,16 +6242,19 @@ prepare_call_arguments (basic_block bb, rtx_insn *insn)\n \tif (GET_MODE (link) == VOIDmode\n \t    || GET_MODE (link) == BLKmode\n \t    || (GET_MODE (link) != GET_MODE (x)\n-\t\t&& (GET_MODE_CLASS (GET_MODE (link)) != MODE_INT\n-\t\t    || GET_MODE_CLASS (GET_MODE (x)) != MODE_INT)))\n+\t\t&& ((GET_MODE_CLASS (GET_MODE (link)) != MODE_INT\n+\t\t     && GET_MODE_CLASS (GET_MODE (link)) != MODE_PARTIAL_INT)\n+\t\t    || (GET_MODE_CLASS (GET_MODE (x)) != MODE_INT\n+\t\t\t&& GET_MODE_CLASS (GET_MODE (x)) != MODE_PARTIAL_INT))))\n \t  /* Can't do anything for these, if the original type mode\n \t     isn't known or can't be converted.  */;\n \telse if (REG_P (x))\n \t  {\n \t    cselib_val *val = cselib_lookup (x, GET_MODE (x), 0, VOIDmode);\n \t    if (val && cselib_preserved_value_p (val))\n \t      item = val->val_rtx;\n-\t    else if (GET_MODE_CLASS (GET_MODE (x)) == MODE_INT)\n+\t    else if (GET_MODE_CLASS (GET_MODE (x)) == MODE_INT\n+\t\t     || GET_MODE_CLASS (GET_MODE (x)) == MODE_PARTIAL_INT)\n \t      {\n \t\tenum machine_mode mode = GET_MODE (x);\n \n@@ -6288,7 +6293,8 @@ prepare_call_arguments (basic_block bb, rtx_insn *insn)\n \t    val = cselib_lookup (mem, GET_MODE (mem), 0, VOIDmode);\n \t    if (val && cselib_preserved_value_p (val))\n \t      item = val->val_rtx;\n-\t    else if (GET_MODE_CLASS (GET_MODE (mem)) != MODE_INT)\n+\t    else if (GET_MODE_CLASS (GET_MODE (mem)) != MODE_INT\n+\t\t     && GET_MODE_CLASS (GET_MODE (mem)) != MODE_PARTIAL_INT)\n \t      {\n \t\t/* For non-integer stack argument see also if they weren't\n \t\t   initialized by integers.  */\n@@ -6331,7 +6337,8 @@ prepare_call_arguments (basic_block bb, rtx_insn *insn)\n \t\t&& reg\n \t\t&& REG_P (reg)\n \t\t&& GET_MODE (reg) == mode\n-\t\t&& GET_MODE_CLASS (mode) == MODE_INT\n+\t\t&& (GET_MODE_CLASS (mode) == MODE_INT\n+\t\t    || GET_MODE_CLASS (mode) == MODE_PARTIAL_INT)\n \t\t&& REG_P (x)\n \t\t&& REGNO (x) == REGNO (reg)\n \t\t&& GET_MODE (x) == mode"}, {"sha": "de4479ccac9895244064556486d7cddd6bc883c4", "filename": "gcc/varasm.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50b6ee8b714da5b191f38863310b7c4b967f2f40/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50b6ee8b714da5b191f38863310b7c4b967f2f40/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=50b6ee8b714da5b191f38863310b7c4b967f2f40", "patch": "@@ -1489,7 +1489,7 @@ assemble_addr_to_section (rtx symbol, section *sec)\n {\n   switch_to_section (sec);\n   assemble_align (POINTER_SIZE);\n-  assemble_integer (symbol, POINTER_SIZE / BITS_PER_UNIT, POINTER_SIZE, 1);\n+  assemble_integer (symbol, POINTER_SIZE_UNITS, POINTER_SIZE, 1);\n }\n \n /* Return the numbered .ctors.N (if CONSTRUCTOR_P) or .dtors.N (if\n@@ -2645,7 +2645,7 @@ default_assemble_integer (rtx x ATTRIBUTE_UNUSED,\n   const char *op = integer_asm_op (size, aligned_p);\n   /* Avoid GAS bugs for large values.  Specifically negative values whose\n      absolute value fits in a bfd_vma, but not in a bfd_signed_vma.  */\n-  if (size > UNITS_PER_WORD && size > POINTER_SIZE / BITS_PER_UNIT)\n+  if (size > UNITS_PER_WORD && size > POINTER_SIZE_UNITS)\n     return false;\n   return op && (assemble_integer_with_op (op, x), true);\n }\n@@ -5765,9 +5765,9 @@ dump_tm_clone_pairs (vec<tm_alias_pair> tm_alias_pairs)\n \t}\n \n       assemble_integer (XEXP (DECL_RTL (src), 0),\n-\t\t\tPOINTER_SIZE / BITS_PER_UNIT, POINTER_SIZE, 1);\n+\t\t\tPOINTER_SIZE_UNITS, POINTER_SIZE, 1);\n       assemble_integer (XEXP (DECL_RTL (dst), 0),\n-\t\t\tPOINTER_SIZE / BITS_PER_UNIT, POINTER_SIZE, 1);\n+\t\t\tPOINTER_SIZE_UNITS, POINTER_SIZE, 1);\n     }\n }\n "}]}