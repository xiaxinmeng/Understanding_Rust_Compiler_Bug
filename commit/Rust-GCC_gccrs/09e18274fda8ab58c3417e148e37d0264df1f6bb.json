{"sha": "09e18274fda8ab58c3417e148e37d0264df1f6bb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDllMTgyNzRmZGE4YWI1OGMzNDE3ZTE0OGUzN2QwMjY0ZGYxZjZiYg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@nildram.co.uk", "date": "2007-05-22T20:52:39Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2007-05-22T20:52:39Z"}, "message": "regs.h (end_hard_regno): New function.\n\ngcc/\n\t* regs.h (end_hard_regno): New function.\n\t(END_HARD_REGNO, END_REGNO): New macros.\n\t(add_to_hard_reg_set): New function.\n\t(remove_from_hard_reg_set): Likewise.\n\t(in_hard_reg_set_p): Likewise.\n\t(overlaps_hard_reg_set_p): Likewise.\n\t* bt-load.c (find_btr_reference): Use overlaps_hard_reg_set_p.\n\t(note_btr_set): Use END_HARD_REGNO.\n\t* caller-save.c (setup_save_areas): Use end_hard_regno.\n\t(mark_set_regs): Use END_HARD_REGNO.\n\t(add_stored_regs): Use end_hard_regno.\n\t(mark_referenced_regs): Use add_to_hard_reg_set.\n\t* combine.c (update_table_tick): Use END_REGNO.\n\t(record_value_for_reg): Likewise.\n\t(record_dead_and_set_regs): Likewise.\n\t(get_last_value_validate): Likewise.\n\t(use_crosses_set_p): Likewise.\n\t(reg_dead_at_p_1): Likewise.\n\t(reg_dead_at_p): Likewise.\n\t(mark_used_regs_combine): Use add_to_hard_reg_set.\n\t(move_deaths): Use END_HARD_REGNO.\n\t(reg_bitfield_target_p): Use end_hard_regno.\n\t(distribute_notes): Use END_HARD_REGNO.\n\t* cse.c (mention_regs): Use END_REGNO.\n\t(insert): Use add_to_hard_reg_set.\n\t(invalidate): Use END_HARD_REGNO.\n\t(invalidate_for_call): Likewise.\n\t(exp_equiv_p): Use END_REGNO.\n\t(cse_insn): Likewise.\n\t* cselib.c (cselib_invalidate_regno): Use end_hard_regno.\n\t* df-problems.c (df_urec_mark_reg_change): Use END_HARD_REGNO.\n\t* df-scan.c (df_ref_record): Use END_HARD_REGNO.\n\t* function.c (keep_stack_depressed): Use end_hard_regno.\n\t* global.c (global_alloc): Use end_hard_regno.\n\t(global_conflicts): Use add_to_hard_reg_set instead of\n\tmark_reg_live_nc.\n\t(find_reg): Likewise.\n\t(mark_reg_store): Likewise.\n\t(mark_reg_conflicts): Likewise.\n\t(mark_reg_death): Use remove_from_hard_reg_set.\n\t(mark_reg_live_nc): Delete.\n\t(set_preference): Use end_hard_regno.\n\t* local-alloc.c (mark_life): Use add_to_hard_reg_set and\n\tremove_from_hard_reg_set.\n\t(post_mark_life): Use add_to_hard_reg_set.\n\t* mode-switching.c (reg_dies): Use remove_from_hard_reg_set.\n\t(reg_becomes_live): Use add_to_hard_reg_set.\n\t* recog.c (reg_fits_class_p): Use in_hard_reg_set_p.\n\t(peep2_find_free_register): Use add_to_hard_reg_set.\n\t* reg-stack.c (convert_regs_exit): Use END_HARD_REGNO.\n\t* regclass.c (record_reg_classes): Use in_hard_reg_set_p.\n\t* regrename.c (note_sets): Use add_to_hard_reg_set.\n\t(clear_dead_regs): Use remove_from_hard_reg_set.\n\t(regrename_optimize): Use add_to_hard_reg_set.\n\t(find_oldest_value_reg): Use in_hard_reg_set_p.\n\t* reload.c (push_reload): Use in_hard_reg_set_p and end_hard_regno.\n\t(hard_reg_set_here_p): Use end_hard_regno.\n\t(decompose): Likewise.\n\t(reg_overlap_mentioned_for_reload_p): Use END_HARD_REGNO.\n\t(find_equiv_reg): Use in_hard_reg_set_p and end_hard_regno.\n\t* reload1.c (compute_use_by_pseudos): Use add_to_hard_reg_set.\n\t(mark_home_live): Use end_hard_regno.\n\t(spill_hard_reg): Likewise.\n\t(clear_reload_reg_in_use): Likewise.\n\t* reorg.c (delete_prior_computation): Use END_REGNO.\n\t* resource.c (update_live_status): Use END_HARD_REGNO.\n\t(mark_referenced_resources): Use add_to_hard_reg_set.\n\t(mark_set_resources): Likewise.\n\t(mark_target_live_regs): Likewise.  Use remove_from_hard_reg_set.\n\t* rtlanal.c (refers_to_regno_p): Use END_REGNO.\n\t(reg_overlap_mentioned_p): Likewise.\n\t(dead_or_set_p): Likewise.  Use an exclusive upper loop bound.\n\t(covers_regno_no_parallel_p): Use END_REGNO.\n\t(find_regno_note): Likewise.\n\t(find_reg_fusage): Use END_HARD_REGNO.\n\t* stmt.c (decl_overlaps_hard_reg_set_p): Use overlaps_hard_reg_set_p.\n\t* var-tracking.c (emit_note_insn_var_location): Use end_hard_regno.\n\nFrom-SVN: r124961", "tree": {"sha": "9e698cb3b5286c709642b8db45a05193e856c5fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9e698cb3b5286c709642b8db45a05193e856c5fc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/09e18274fda8ab58c3417e148e37d0264df1f6bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09e18274fda8ab58c3417e148e37d0264df1f6bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09e18274fda8ab58c3417e148e37d0264df1f6bb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09e18274fda8ab58c3417e148e37d0264df1f6bb/comments", "author": null, "committer": null, "parents": [{"sha": "6936461f13040d03e5371a9069fe477ac8a7c705", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6936461f13040d03e5371a9069fe477ac8a7c705", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6936461f13040d03e5371a9069fe477ac8a7c705"}], "stats": {"total": 634, "additions": 288, "deletions": 346}, "files": [{"sha": "45d889bcf2fcc943cb42280b7cacffa09f9dc1d2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e18274fda8ab58c3417e148e37d0264df1f6bb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e18274fda8ab58c3417e148e37d0264df1f6bb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=09e18274fda8ab58c3417e148e37d0264df1f6bb", "patch": "@@ -1,3 +1,83 @@\n+2007-05-22  Richard Sandiford  <rsandifo@nildram.co.uk>\n+\n+\t* regs.h (end_hard_regno): New function.\n+\t(END_HARD_REGNO, END_REGNO): New macros.\n+\t(add_to_hard_reg_set): New function.\n+\t(remove_from_hard_reg_set): Likewise.\n+\t(in_hard_reg_set_p): Likewise.\n+\t(overlaps_hard_reg_set_p): Likewise.\n+\t* bt-load.c (find_btr_reference): Use overlaps_hard_reg_set_p.\n+\t(note_btr_set): Use END_HARD_REGNO.\n+\t* caller-save.c (setup_save_areas): Use end_hard_regno.\n+\t(mark_set_regs): Use END_HARD_REGNO.\n+\t(add_stored_regs): Use end_hard_regno.\n+\t(mark_referenced_regs): Use add_to_hard_reg_set.\n+\t* combine.c (update_table_tick): Use END_REGNO.\n+\t(record_value_for_reg): Likewise.\n+\t(record_dead_and_set_regs): Likewise.\n+\t(get_last_value_validate): Likewise.\n+\t(use_crosses_set_p): Likewise.\n+\t(reg_dead_at_p_1): Likewise.\n+\t(reg_dead_at_p): Likewise.\n+\t(mark_used_regs_combine): Use add_to_hard_reg_set.\n+\t(move_deaths): Use END_HARD_REGNO.\n+\t(reg_bitfield_target_p): Use end_hard_regno.\n+\t(distribute_notes): Use END_HARD_REGNO.\n+\t* cse.c (mention_regs): Use END_REGNO.\n+\t(insert): Use add_to_hard_reg_set.\n+\t(invalidate): Use END_HARD_REGNO.\n+\t(invalidate_for_call): Likewise.\n+\t(exp_equiv_p): Use END_REGNO.\n+\t(cse_insn): Likewise.\n+\t* cselib.c (cselib_invalidate_regno): Use end_hard_regno.\n+\t* df-problems.c (df_urec_mark_reg_change): Use END_HARD_REGNO.\n+\t* df-scan.c (df_ref_record): Use END_HARD_REGNO.\n+\t* function.c (keep_stack_depressed): Use end_hard_regno.\n+\t* global.c (global_alloc): Use end_hard_regno.\n+\t(global_conflicts): Use add_to_hard_reg_set instead of\n+\tmark_reg_live_nc.\n+\t(find_reg): Likewise.\n+\t(mark_reg_store): Likewise.\n+\t(mark_reg_conflicts): Likewise.\n+\t(mark_reg_death): Use remove_from_hard_reg_set.\n+\t(mark_reg_live_nc): Delete.\n+\t(set_preference): Use end_hard_regno.\n+\t* local-alloc.c (mark_life): Use add_to_hard_reg_set and\n+\tremove_from_hard_reg_set.\n+\t(post_mark_life): Use add_to_hard_reg_set.\n+\t* mode-switching.c (reg_dies): Use remove_from_hard_reg_set.\n+\t(reg_becomes_live): Use add_to_hard_reg_set.\n+\t* recog.c (reg_fits_class_p): Use in_hard_reg_set_p.\n+\t(peep2_find_free_register): Use add_to_hard_reg_set.\n+\t* reg-stack.c (convert_regs_exit): Use END_HARD_REGNO.\n+\t* regclass.c (record_reg_classes): Use in_hard_reg_set_p.\n+\t* regrename.c (note_sets): Use add_to_hard_reg_set.\n+\t(clear_dead_regs): Use remove_from_hard_reg_set.\n+\t(regrename_optimize): Use add_to_hard_reg_set.\n+\t(find_oldest_value_reg): Use in_hard_reg_set_p.\n+\t* reload.c (push_reload): Use in_hard_reg_set_p and end_hard_regno.\n+\t(hard_reg_set_here_p): Use end_hard_regno.\n+\t(decompose): Likewise.\n+\t(reg_overlap_mentioned_for_reload_p): Use END_HARD_REGNO.\n+\t(find_equiv_reg): Use in_hard_reg_set_p and end_hard_regno.\n+\t* reload1.c (compute_use_by_pseudos): Use add_to_hard_reg_set.\n+\t(mark_home_live): Use end_hard_regno.\n+\t(spill_hard_reg): Likewise.\n+\t(clear_reload_reg_in_use): Likewise.\n+\t* reorg.c (delete_prior_computation): Use END_REGNO.\n+\t* resource.c (update_live_status): Use END_HARD_REGNO.\n+\t(mark_referenced_resources): Use add_to_hard_reg_set.\n+\t(mark_set_resources): Likewise.\n+\t(mark_target_live_regs): Likewise.  Use remove_from_hard_reg_set.\n+\t* rtlanal.c (refers_to_regno_p): Use END_REGNO.\n+\t(reg_overlap_mentioned_p): Likewise.\n+\t(dead_or_set_p): Likewise.  Use an exclusive upper loop bound.\n+\t(covers_regno_no_parallel_p): Use END_REGNO.\n+\t(find_regno_note): Likewise.\n+\t(find_reg_fusage): Use END_HARD_REGNO.\n+\t* stmt.c (decl_overlaps_hard_reg_set_p): Use overlaps_hard_reg_set_p.\n+\t* var-tracking.c (emit_note_insn_var_location): Use end_hard_regno.\n+\n 2007-05-22  Richard Sandiford  <rsandifo@nildram.co.uk>\n \n \t* mode-switching.c (reg_dies): Change type of second argument to"}, {"sha": "4a33940fe3f8cdfab8847723d367e21101763bd8", "filename": "gcc/bt-load.c", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e18274fda8ab58c3417e148e37d0264df1f6bb/gcc%2Fbt-load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e18274fda8ab58c3417e148e37d0264df1f6bb/gcc%2Fbt-load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbt-load.c?ref=09e18274fda8ab58c3417e148e37d0264df1f6bb", "patch": "@@ -193,20 +193,17 @@ static int\n find_btr_reference (rtx *px, void *preg)\n {\n   rtx x;\n-  int regno, i;\n \n   if (px == preg)\n     return -1;\n   x = *px;\n   if (!REG_P (x))\n     return 0;\n-  regno = REGNO (x);\n-  for (i = hard_regno_nregs[regno][GET_MODE (x)] - 1; i >= 0; i--)\n-    if (TEST_HARD_REG_BIT (all_btrs, regno+i))\n-      {\n-\tbtr_reference_found = px;\n-\treturn 1;\n-      }\n+  if (overlaps_hard_reg_set_p (all_btrs, GET_MODE (x), REGNO (x)))\n+    {\n+      btr_reference_found = px;\n+      return 1;\n+    }\n   return -1;\n }\n \n@@ -433,7 +430,7 @@ note_btr_set (rtx dest, rtx set ATTRIBUTE_UNUSED, void *data)\n   if (!REG_P (dest))\n     return;\n   regno = REGNO (dest);\n-  end_regno = regno + hard_regno_nregs[regno][GET_MODE (dest)];\n+  end_regno = END_HARD_REGNO (dest);\n   for (; regno < end_regno; regno++)\n     if (TEST_HARD_REG_BIT (all_btrs, regno))\n       {"}, {"sha": "22b928e772464ff042d9b59c81b21c93b259afa5", "filename": "gcc/caller-save.c", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e18274fda8ab58c3417e148e37d0264df1f6bb/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e18274fda8ab58c3417e148e37d0264df1f6bb/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=09e18274fda8ab58c3417e148e37d0264df1f6bb", "patch": "@@ -296,7 +296,7 @@ setup_save_areas (void)\n       {\n \tunsigned int regno = reg_renumber[i];\n \tunsigned int endregno\n-\t  = regno + hard_regno_nregs[regno][GET_MODE (regno_reg_rtx[i])];\n+\t  = end_hard_regno (GET_MODE (regno_reg_rtx[i]), regno);\n \n \tfor (r = regno; r < endregno; r++)\n \t  if (call_used_regs[r])\n@@ -496,7 +496,6 @@ static void\n mark_set_regs (rtx reg, rtx setter ATTRIBUTE_UNUSED, void *data)\n {\n   int regno, endregno, i;\n-  enum machine_mode mode = GET_MODE (reg);\n   HARD_REG_SET *this_insn_sets = data;\n \n   if (GET_CODE (reg) == SUBREG)\n@@ -511,7 +510,7 @@ mark_set_regs (rtx reg, rtx setter ATTRIBUTE_UNUSED, void *data)\n \t   && REGNO (reg) < FIRST_PSEUDO_REGISTER)\n     {\n       regno = REGNO (reg);\n-      endregno = regno + hard_regno_nregs[regno][mode];\n+      endregno = END_HARD_REGNO (reg);\n     }\n   else\n     return;\n@@ -551,7 +550,7 @@ add_stored_regs (rtx reg, rtx setter, void *data)\n \treturn;\n \n       regno = REGNO (reg) + offset;\n-      endregno = regno + hard_regno_nregs[regno][mode];\n+      endregno = end_hard_regno (mode, regno);\n     }\n \n   for (i = regno; i < endregno; i++)\n@@ -598,11 +597,7 @@ mark_referenced_regs (rtx x)\n \t\t       : reg_renumber[regno]);\n \n       if (hardregno >= 0)\n-\t{\n-\t  int nregs = hard_regno_nregs[hardregno][GET_MODE (x)];\n-\t  while (nregs-- > 0)\n-\t    SET_HARD_REG_BIT (referenced_regs, hardregno + nregs);\n-\t}\n+\tadd_to_hard_reg_set (&referenced_regs, GET_MODE (x), hardregno);\n       /* If this is a pseudo that did not get a hard register, scan its\n \t memory location, since it might involve the use of another\n \t register, which might be saved.  */"}, {"sha": "268fa76275a42709514a8db59aa59fa70af8b2a6", "filename": "gcc/combine.c", "status": "modified", "additions": 14, "deletions": 39, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e18274fda8ab58c3417e148e37d0264df1f6bb/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e18274fda8ab58c3417e148e37d0264df1f6bb/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=09e18274fda8ab58c3417e148e37d0264df1f6bb", "patch": "@@ -10796,9 +10796,7 @@ update_table_tick (rtx x)\n   if (code == REG)\n     {\n       unsigned int regno = REGNO (x);\n-      unsigned int endregno\n-\t= regno + (regno < FIRST_PSEUDO_REGISTER\n-\t\t   ? hard_regno_nregs[regno][GET_MODE (x)] : 1);\n+      unsigned int endregno = END_REGNO (x);\n       unsigned int r;\n \n       for (r = regno; r < endregno; r++)\n@@ -10858,9 +10856,7 @@ static void\n record_value_for_reg (rtx reg, rtx insn, rtx value)\n {\n   unsigned int regno = REGNO (reg);\n-  unsigned int endregno\n-    = regno + (regno < FIRST_PSEUDO_REGISTER\n-\t       ? hard_regno_nregs[regno][GET_MODE (reg)] : 1);\n+  unsigned int endregno = END_REGNO (reg);\n   unsigned int i;\n \n   /* If VALUE contains REG and we have a previous value for REG, substitute\n@@ -11029,10 +11025,7 @@ record_dead_and_set_regs (rtx insn)\n \t  && REG_P (XEXP (link, 0)))\n \t{\n \t  unsigned int regno = REGNO (XEXP (link, 0));\n-\t  unsigned int endregno\n-\t    = regno + (regno < FIRST_PSEUDO_REGISTER\n-\t\t       ? hard_regno_nregs[regno][GET_MODE (XEXP (link, 0))]\n-\t\t       : 1);\n+\t  unsigned int endregno = END_REGNO (XEXP (link, 0));\n \n \t  for (i = regno; i < endregno; i++)\n \t    reg_stat[i].last_death = insn;\n@@ -11231,9 +11224,7 @@ get_last_value_validate (rtx *loc, rtx insn, int tick, int replace)\n   if (REG_P (x))\n     {\n       unsigned int regno = REGNO (x);\n-      unsigned int endregno\n-\t= regno + (regno < FIRST_PSEUDO_REGISTER\n-\t\t   ? hard_regno_nregs[regno][GET_MODE (x)] : 1);\n+      unsigned int endregno = END_REGNO (x);\n       unsigned int j;\n \n       for (j = regno; j < endregno; j++)\n@@ -11392,8 +11383,7 @@ use_crosses_set_p (rtx x, int from_cuid)\n   if (code == REG)\n     {\n       unsigned int regno = REGNO (x);\n-      unsigned endreg = regno + (regno < FIRST_PSEUDO_REGISTER\n-\t\t\t\t ? hard_regno_nregs[regno][GET_MODE (x)] : 1);\n+      unsigned endreg = END_REGNO (x);\n \n #ifdef PUSH_ROUNDING\n       /* Don't allow uses of the stack pointer to be moved,\n@@ -11449,9 +11439,7 @@ reg_dead_at_p_1 (rtx dest, rtx x, void *data ATTRIBUTE_UNUSED)\n     return;\n \n   regno = REGNO (dest);\n-  endregno = regno + (regno < FIRST_PSEUDO_REGISTER\n-\t\t      ? hard_regno_nregs[regno][GET_MODE (dest)] : 1);\n-\n+  endregno = END_REGNO (dest);\n   if (reg_dead_endregno > regno && reg_dead_regno < endregno)\n     reg_dead_flag = (GET_CODE (x) == CLOBBER) ? 1 : -1;\n }\n@@ -11472,10 +11460,7 @@ reg_dead_at_p (rtx reg, rtx insn)\n \n   /* Set variables for reg_dead_at_p_1.  */\n   reg_dead_regno = REGNO (reg);\n-  reg_dead_endregno = reg_dead_regno + (reg_dead_regno < FIRST_PSEUDO_REGISTER\n-\t\t\t\t\t? hard_regno_nregs[reg_dead_regno]\n-\t\t\t\t\t\t\t  [GET_MODE (reg)]\n-\t\t\t\t\t: 1);\n+  reg_dead_endregno = END_REGNO (reg);\n \n   reg_dead_flag = 0;\n \n@@ -11564,8 +11549,6 @@ mark_used_regs_combine (rtx x)\n \t If so, mark all of them just like the first.  */\n       if (regno < FIRST_PSEUDO_REGISTER)\n \t{\n-\t  unsigned int endregno, r;\n-\n \t  /* None of this applies to the stack, frame or arg pointers.  */\n \t  if (regno == STACK_POINTER_REGNUM\n #if FRAME_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM\n@@ -11577,9 +11560,7 @@ mark_used_regs_combine (rtx x)\n \t      || regno == FRAME_POINTER_REGNUM)\n \t    return;\n \n-\t  endregno = regno + hard_regno_nregs[regno][GET_MODE (x)];\n-\t  for (r = regno; r < endregno; r++)\n-\t    SET_HARD_REG_BIT (newpat_used_regs, r);\n+\t  add_to_hard_reg_set (&newpat_used_regs, GET_MODE (x), regno);\n \t}\n       return;\n \n@@ -11704,11 +11685,8 @@ move_deaths (rtx x, rtx maybe_kill_insn, int from_cuid, rtx to_insn,\n \t\t  > GET_MODE_SIZE (GET_MODE (x))))\n \t    {\n \t      unsigned int deadregno = REGNO (XEXP (note, 0));\n-\t      unsigned int deadend\n-\t\t= (deadregno + hard_regno_nregs[deadregno]\n-\t\t\t\t\t       [GET_MODE (XEXP (note, 0))]);\n-\t      unsigned int ourend\n-\t\t= regno + hard_regno_nregs[regno][GET_MODE (x)];\n+\t      unsigned int deadend = END_HARD_REGNO (XEXP (note, 0));\n+\t      unsigned int ourend = END_HARD_REGNO (x);\n \t      unsigned int i;\n \n \t      for (i = deadregno; i < deadend; i++)\n@@ -11731,8 +11709,7 @@ move_deaths (rtx x, rtx maybe_kill_insn, int from_cuid, rtx to_insn,\n \t\t   && regno < FIRST_PSEUDO_REGISTER\n \t\t   && hard_regno_nregs[regno][GET_MODE (x)] > 1)\n \t    {\n-\t      unsigned int ourend\n-\t\t= regno + hard_regno_nregs[regno][GET_MODE (x)];\n+\t      unsigned int ourend = END_HARD_REGNO (x);\n \t      unsigned int i, offset;\n \t      rtx oldnotes = 0;\n \n@@ -11850,8 +11827,8 @@ reg_bitfield_target_p (rtx x, rtx body)\n       if (tregno >= FIRST_PSEUDO_REGISTER || regno >= FIRST_PSEUDO_REGISTER)\n \treturn target == x;\n \n-      endtregno = tregno + hard_regno_nregs[tregno][GET_MODE (target)];\n-      endregno = regno + hard_regno_nregs[regno][GET_MODE (x)];\n+      endtregno = end_hard_regno (GET_MODE (target), tregno);\n+      endregno = end_hard_regno (GET_MODE (x), regno);\n \n       return endregno > tregno && regno < endtregno;\n     }\n@@ -12352,9 +12329,7 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2, rtx elim_i2,\n \t      if (place && regno < FIRST_PSEUDO_REGISTER\n \t\t  && hard_regno_nregs[regno][GET_MODE (XEXP (note, 0))] > 1)\n \t\t{\n-\t\t  unsigned int endregno\n-\t\t    = regno + hard_regno_nregs[regno]\n-\t\t\t\t\t      [GET_MODE (XEXP (note, 0))];\n+\t\t  unsigned int endregno = END_HARD_REGNO (XEXP (note, 0));\n \t\t  int all_used = 1;\n \t\t  unsigned int i;\n "}, {"sha": "e166ce99bbe6b984e0289229e704bf6efe2cf755", "filename": "gcc/cse.c", "status": "modified", "additions": 7, "deletions": 22, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e18274fda8ab58c3417e148e37d0264df1f6bb/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e18274fda8ab58c3417e148e37d0264df1f6bb/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=09e18274fda8ab58c3417e148e37d0264df1f6bb", "patch": "@@ -1045,9 +1045,7 @@ mention_regs (rtx x)\n   if (code == REG)\n     {\n       unsigned int regno = REGNO (x);\n-      unsigned int endregno\n-\t= regno + (regno >= FIRST_PSEUDO_REGISTER ? 1\n-\t\t   : hard_regno_nregs[regno][GET_MODE (x)]);\n+      unsigned int endregno = END_REGNO (x);\n       unsigned int i;\n \n       for (i = regno; i < endregno; i++)\n@@ -1429,14 +1427,7 @@ insert (rtx x, struct table_elt *classp, unsigned int hash, enum machine_mode mo\n \n   /* If X is a hard register, show it is being put in the table.  */\n   if (REG_P (x) && REGNO (x) < FIRST_PSEUDO_REGISTER)\n-    {\n-      unsigned int regno = REGNO (x);\n-      unsigned int endregno = regno + hard_regno_nregs[regno][GET_MODE (x)];\n-      unsigned int i;\n-\n-      for (i = regno; i < endregno; i++)\n-\tSET_HARD_REG_BIT (hard_regs_in_table, i);\n-    }\n+    add_to_hard_reg_set (&hard_regs_in_table, GET_MODE (x), REGNO (x));\n \n   /* Put an element for X into the right hash bucket.  */\n \n@@ -1739,8 +1730,7 @@ invalidate (rtx x, enum machine_mode full_mode)\n \t  {\n \t    HOST_WIDE_INT in_table\n \t      = TEST_HARD_REG_BIT (hard_regs_in_table, regno);\n-\t    unsigned int endregno\n-\t      = regno + hard_regno_nregs[regno][GET_MODE (x)];\n+\t    unsigned int endregno = END_HARD_REGNO (x);\n \t    unsigned int tregno, tendregno, rn;\n \t    struct table_elt *p, *next;\n \n@@ -1766,8 +1756,7 @@ invalidate (rtx x, enum machine_mode full_mode)\n \t\t      continue;\n \n \t\t    tregno = REGNO (p->exp);\n-\t\t    tendregno\n-\t\t      = tregno + hard_regno_nregs[tregno][GET_MODE (p->exp)];\n+\t\t    tendregno = END_HARD_REGNO (p->exp);\n \t\t    if (tendregno > regno && tregno < endregno)\n \t\t      remove_from_table (p, hash);\n \t\t  }\n@@ -1978,7 +1967,7 @@ invalidate_for_call (void)\n \t    continue;\n \n \t  regno = REGNO (p->exp);\n-\t  endregno = regno + hard_regno_nregs[regno][GET_MODE (p->exp)];\n+\t  endregno = END_HARD_REGNO (p->exp);\n \n \t  for (i = regno; i < endregno; i++)\n \t    if (TEST_HARD_REG_BIT (regs_invalidated_by_call, i))\n@@ -2447,9 +2436,7 @@ exp_equiv_p (rtx x, rtx y, int validate, bool for_gcse)\n \t{\n \t  unsigned int regno = REGNO (y);\n \t  unsigned int i;\n-\t  unsigned int endregno\n-\t    = regno + (regno >= FIRST_PSEUDO_REGISTER ? 1\n-\t\t       : hard_regno_nregs[regno][GET_MODE (y)]);\n+\t  unsigned int endregno = END_REGNO (y);\n \n \t  /* If the quantities are not the same, the expressions are not\n \t     equivalent.  If there are and we are not to validate, they\n@@ -5380,9 +5367,7 @@ cse_insn (rtx insn, rtx libcall_insn)\n \t\t but it knows that reg_tick has been incremented, and\n \t\t it leaves reg_in_table as -1 .  */\n \t      unsigned int regno = REGNO (x);\n-\t      unsigned int endregno\n-\t\t= regno + (regno >= FIRST_PSEUDO_REGISTER ? 1\n-\t\t\t   : hard_regno_nregs[regno][GET_MODE (x)]);\n+\t      unsigned int endregno = END_REGNO (x);\n \t      unsigned int i;\n \n \t      for (i = regno; i < endregno; i++)"}, {"sha": "b791d9d803ed9252dd9ea121753e292a51961eb6", "filename": "gcc/cselib.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e18274fda8ab58c3417e148e37d0264df1f6bb/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e18274fda8ab58c3417e148e37d0264df1f6bb/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=09e18274fda8ab58c3417e148e37d0264df1f6bb", "patch": "@@ -1029,7 +1029,7 @@ cselib_invalidate_regno (unsigned int regno, enum machine_mode mode)\n       else\n \ti = regno - max_value_regs;\n \n-      endregno = regno + hard_regno_nregs[regno][mode];\n+      endregno = end_hard_regno (mode, regno);\n     }\n   else\n     {\n@@ -1050,7 +1050,7 @@ cselib_invalidate_regno (unsigned int regno, enum machine_mode mode)\n \t  unsigned int this_last = i;\n \n \t  if (i < FIRST_PSEUDO_REGISTER && v != NULL)\n-\t    this_last += hard_regno_nregs[i][GET_MODE (v->val_rtx)] - 1;\n+\t    this_last = end_hard_regno (GET_MODE (v->val_rtx), i) - 1;\n \n \t  if (this_last < regno || v == NULL)\n \t    {"}, {"sha": "ab2ebfc528967c5acfc5f4524f8b974b38f37a97", "filename": "gcc/df-problems.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e18274fda8ab58c3417e148e37d0264df1f6bb/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e18274fda8ab58c3417e148e37d0264df1f6bb/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=09e18274fda8ab58c3417e148e37d0264df1f6bb", "patch": "@@ -2259,12 +2259,10 @@ df_urec_mark_reg_change (rtx reg, rtx setter, void *data)\n   if (!REG_P (reg))\n     return;\n   \n-  \n-  endregno = regno = REGNO (reg);\n+  regno = REGNO (reg);\n   if (regno < FIRST_PSEUDO_REGISTER)\n     {\n-      endregno +=hard_regno_nregs[regno][GET_MODE (reg)];\n-      \n+      endregno = END_HARD_REGNO (reg);\n       for (i = regno; i < endregno; i++)\n \t{\n \t  bitmap_set_bit (bb_info->kill, i);"}, {"sha": "69ba04d6fa969839c5eb9c6c6cbc6b2197e9ec05", "filename": "gcc/df-scan.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e18274fda8ab58c3417e148e37d0264df1f6bb/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e18274fda8ab58c3417e148e37d0264df1f6bb/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=09e18274fda8ab58c3417e148e37d0264df1f6bb", "patch": "@@ -1093,11 +1093,10 @@ df_ref_record (struct dataflow *dflow, rtx reg, rtx *loc,\n \t{\n \t  regno += subreg_regno_offset (regno, GET_MODE (SUBREG_REG (reg)),\n \t\t\t\t\tSUBREG_BYTE (reg), GET_MODE (reg));\n-\t  endregno = subreg_nregs (reg);\n+\t  endregno = regno + subreg_nregs (reg);\n \t}\n       else\n-\tendregno = hard_regno_nregs[regno][GET_MODE (reg)];\n-      endregno += regno;\n+\tendregno = END_HARD_REGNO (reg);\n \n       /*  If this is a multiword hardreg, we create some extra datastructures that \n \t  will enable us to easily build REG_DEAD and REG_UNUSED notes.  */"}, {"sha": "8338894802a8c1ea0974dc7305a5274096220147", "filename": "gcc/function.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e18274fda8ab58c3417e148e37d0264df1f6bb/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e18274fda8ab58c3417e148e37d0264df1f6bb/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=09e18274fda8ab58c3417e148e37d0264df1f6bb", "patch": "@@ -4771,8 +4771,7 @@ keep_stack_depressed (rtx insns)\n \t\t    && !REGNO_REG_SET_P\n \t\t         (EXIT_BLOCK_PTR->il.rtl->global_live_at_start, regno)\n \t\t    && !refers_to_regno_p (regno,\n-\t\t\t\t\t   regno + hard_regno_nregs[regno]\n-\t\t\t\t\t\t\t\t   [Pmode],\n+\t\t\t\t\t   end_hard_regno (Pmode, regno),\n \t\t\t\t\t   info.equiv_reg_src, NULL)\n \t\t    && info.const_equiv[regno] == 0)\n \t\t  break;"}, {"sha": "a3da8a28d60fb6c93fca640c2fca6d77902efbb5", "filename": "gcc/global.c", "status": "modified", "additions": 17, "deletions": 43, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e18274fda8ab58c3417e148e37d0264df1f6bb/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e18274fda8ab58c3417e148e37d0264df1f6bb/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=09e18274fda8ab58c3417e148e37d0264df1f6bb", "patch": "@@ -306,7 +306,6 @@ static void mark_reg_store (rtx, rtx, void *);\n static void mark_reg_clobber (rtx, rtx, void *);\n static void mark_reg_conflicts (rtx);\n static void mark_reg_death (rtx);\n-static void mark_reg_live_nc (int, enum machine_mode);\n static void set_preference (rtx, rtx);\n static void dump_conflicts (FILE *);\n static void reg_becomes_live (rtx, rtx, void *);\n@@ -529,7 +528,7 @@ global_alloc (void)\n     if (reg_renumber[i] >= 0)\n       {\n \tint regno = reg_renumber[i];\n-\tint endregno = regno + hard_regno_nregs[regno][PSEUDO_REGNO_MODE (i)];\n+\tint endregno = end_hard_regno (PSEUDO_REGNO_MODE (i), regno);\n \tint j;\n \n \tfor (j = regno; j < endregno; j++)\n@@ -737,7 +736,7 @@ global_conflicts (void)\n \t\tblock_start_allocnos[ax++] = a;\n \t      }\n \t    else if ((a = reg_renumber[i]) >= 0)\n-\t      mark_reg_live_nc (a, PSEUDO_REGNO_MODE (i));\n+\t      add_to_hard_reg_set (&hard_regs_live, PSEUDO_REGNO_MODE (i), a);\n \t  }\n \n \t/* Record that each allocno now live conflicts with each hard reg\n@@ -1132,7 +1131,7 @@ find_reg (int num, HARD_REG_SET losers, int alt_regs_p, int accept_call_clobbere\n \t\t  || ! HARD_REGNO_CALL_PART_CLOBBERED (regno, mode)))\n \t    {\n \t      int j;\n-\t      int lim = regno + hard_regno_nregs[regno][mode];\n+\t      int lim = end_hard_regno (mode, regno);\n \t      for (j = regno + 1;\n \t\t   (j < lim\n \t\t    && ! TEST_HARD_REG_BIT (used, j));\n@@ -1177,7 +1176,7 @@ find_reg (int num, HARD_REG_SET losers, int alt_regs_p, int accept_call_clobbere\n \t\t\t\t       REGNO_REG_CLASS (i))))\n \t    {\n \t      int j;\n-\t      int lim = i + hard_regno_nregs[i][mode];\n+\t      int lim = end_hard_regno (mode, i);\n \t      for (j = i + 1;\n \t\t   (j < lim\n \t\t    && ! TEST_HARD_REG_BIT (used, j)\n@@ -1213,7 +1212,7 @@ find_reg (int num, HARD_REG_SET losers, int alt_regs_p, int accept_call_clobbere\n \t\t\t\t       REGNO_REG_CLASS (i))))\n \t    {\n \t      int j;\n-\t      int lim = i + hard_regno_nregs[i][mode];\n+\t      int lim = end_hard_regno (mode, i);\n \t      for (j = i + 1;\n \t\t   (j < lim\n \t\t    && ! TEST_HARD_REG_BIT (used, j)\n@@ -1339,7 +1338,7 @@ find_reg (int num, HARD_REG_SET losers, int alt_regs_p, int accept_call_clobbere\n \t\t      {\n \t\t\tint r = reg_renumber[k];\n \t\t\tint endregno\n-\t\t\t  = r + hard_regno_nregs[r][PSEUDO_REGNO_MODE (k)];\n+\t\t\t  = end_hard_regno (PSEUDO_REGNO_MODE (k), r);\n \n \t\t\tif (regno >= r && regno < endregno)\n \t\t\t  {\n@@ -1374,7 +1373,7 @@ find_reg (int num, HARD_REG_SET losers, int alt_regs_p, int accept_call_clobbere\n \n       /* Make a set of the hard regs being allocated.  */\n       CLEAR_HARD_REG_SET (this_reg);\n-      lim = best_reg + hard_regno_nregs[best_reg][mode];\n+      lim = end_hard_regno (mode, best_reg);\n       for (j = best_reg; j < lim; j++)\n \t{\n \t  SET_HARD_REG_BIT (this_reg, j);\n@@ -1555,7 +1554,7 @@ mark_reg_store (rtx reg, rtx setter, void *data ATTRIBUTE_UNUSED)\n   /* Handle hardware regs (and pseudos allocated to hard regs).  */\n   if (regno < FIRST_PSEUDO_REGISTER && ! fixed_regs[regno])\n     {\n-      int last = regno + hard_regno_nregs[regno][GET_MODE (reg)];\n+      int last = end_hard_regno (GET_MODE (reg), regno);\n       while (regno < last)\n \t{\n \t  record_one_conflict (regno);\n@@ -1604,7 +1603,7 @@ mark_reg_conflicts (rtx reg)\n   /* Handle hardware regs (and pseudos allocated to hard regs).  */\n   if (regno < FIRST_PSEUDO_REGISTER && ! fixed_regs[regno])\n     {\n-      int last = regno + hard_regno_nregs[regno][GET_MODE (reg)];\n+      int last = end_hard_regno (GET_MODE (reg), regno);\n       while (regno < last)\n \t{\n \t  record_one_conflict (regno);\n@@ -1635,32 +1634,9 @@ mark_reg_death (rtx reg)\n \n   /* Handle hardware regs (and pseudos allocated to hard regs).  */\n   if (regno < FIRST_PSEUDO_REGISTER && ! fixed_regs[regno])\n-    {\n-      /* Pseudo regs already assigned hardware regs are treated\n-\t almost the same as explicit hardware regs.  */\n-      int last = regno + hard_regno_nregs[regno][GET_MODE (reg)];\n-      while (regno < last)\n-\t{\n-\t  CLEAR_HARD_REG_BIT (hard_regs_live, regno);\n-\t  regno++;\n-\t}\n-    }\n-}\n-\n-/* Mark hard reg REGNO as currently live, assuming machine mode MODE\n-   for the value stored in it.  MODE determines how many consecutive\n-   registers are actually in use.  Do not record conflicts;\n-   it is assumed that the caller will do that.  */\n-\n-static void\n-mark_reg_live_nc (int regno, enum machine_mode mode)\n-{\n-  int last = regno + hard_regno_nregs[regno][mode];\n-  while (regno < last)\n-    {\n-      SET_HARD_REG_BIT (hard_regs_live, regno);\n-      regno++;\n-    }\n+    /* Pseudo regs already assigned hardware regs are treated\n+       almost the same as explicit hardware regs.  */\n+    remove_from_hard_reg_set (&hard_regs_live, GET_MODE (reg), regno);\n }\n \f\n /* Try to set a preference for an allocno to a hard register.\n@@ -1675,7 +1651,7 @@ mark_reg_live_nc (int regno, enum machine_mode mode)\n static void\n set_preference (rtx dest, rtx src)\n {\n-  unsigned int src_regno, dest_regno;\n+  unsigned int src_regno, dest_regno, end_regno;\n   /* Amount to add to the hard regno for SRC, or subtract from that for DEST,\n      to compensate for subregs in SRC or DEST.  */\n   int offset = 0;\n@@ -1747,9 +1723,8 @@ set_preference (rtx dest, rtx src)\n \n \t  SET_REGBIT (hard_reg_preferences,\n \t\t      reg_allocno[src_regno], dest_regno);\n-\t  for (i = dest_regno;\n-\t       i < dest_regno + hard_regno_nregs[dest_regno][GET_MODE (dest)];\n-\t       i++)\n+\t  end_regno = end_hard_regno (GET_MODE (dest), dest_regno);\n+\t  for (i = dest_regno; i < end_regno; i++)\n \t    SET_REGBIT (hard_reg_full_preferences, reg_allocno[src_regno], i);\n \t}\n     }\n@@ -1766,9 +1741,8 @@ set_preference (rtx dest, rtx src)\n \n \t  SET_REGBIT (hard_reg_preferences,\n \t\t      reg_allocno[dest_regno], src_regno);\n-\t  for (i = src_regno;\n-\t       i < src_regno + hard_regno_nregs[src_regno][GET_MODE (src)];\n-\t       i++)\n+\t  end_regno = end_hard_regno (GET_MODE (src), src_regno);\n+\t  for (i = src_regno; i < end_regno; i++)\n \t    SET_REGBIT (hard_reg_full_preferences, reg_allocno[dest_regno], i);\n \t}\n     }"}, {"sha": "01d107e5fea5436aa5ecd51867c0854832a37fa4", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e18274fda8ab58c3417e148e37d0264df1f6bb/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e18274fda8ab58c3417e148e37d0264df1f6bb/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=09e18274fda8ab58c3417e148e37d0264df1f6bb", "patch": "@@ -2363,13 +2363,10 @@ find_free_reg (enum reg_class class, enum machine_mode mode, int qtyno,\n static void\n mark_life (int regno, enum machine_mode mode, int life)\n {\n-  int j = hard_regno_nregs[regno][mode];\n   if (life)\n-    while (--j >= 0)\n-      SET_HARD_REG_BIT (regs_live, regno + j);\n+    add_to_hard_reg_set (&regs_live, mode, regno);\n   else\n-    while (--j >= 0)\n-      CLEAR_HARD_REG_BIT (regs_live, regno + j);\n+    remove_from_hard_reg_set (&regs_live, mode, regno);\n }\n \n /* Mark register number REGNO (with machine-mode MODE) as live (if LIFE\n@@ -2380,12 +2377,10 @@ static void\n post_mark_life (int regno, enum machine_mode mode, int life, int birth,\n \t\tint death)\n {\n-  int j = hard_regno_nregs[regno][mode];\n   HARD_REG_SET this_reg;\n \n   CLEAR_HARD_REG_SET (this_reg);\n-  while (--j >= 0)\n-    SET_HARD_REG_BIT (this_reg, regno + j);\n+  add_to_hard_reg_set (&this_reg, mode, regno);\n \n   if (life)\n     while (birth < death)"}, {"sha": "448192a9b4eb5144f1f9eb1f85518a457be290e6", "filename": "gcc/mode-switching.c", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e18274fda8ab58c3417e148e37d0264df1f6bb/gcc%2Fmode-switching.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e18274fda8ab58c3417e148e37d0264df1f6bb/gcc%2Fmode-switching.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmode-switching.c?ref=09e18274fda8ab58c3417e148e37d0264df1f6bb", "patch": "@@ -162,16 +162,14 @@ make_preds_opaque (basic_block b, int j)\n static void\n reg_dies (rtx reg, HARD_REG_SET *live)\n {\n-  int regno, nregs;\n+  int regno;\n \n   if (!REG_P (reg))\n     return;\n \n   regno = REGNO (reg);\n   if (regno < FIRST_PSEUDO_REGISTER)\n-    for (nregs = hard_regno_nregs[regno][GET_MODE (reg)] - 1; nregs >= 0;\n-\t nregs--)\n-      CLEAR_HARD_REG_BIT (*live, regno + nregs);\n+    remove_from_hard_reg_set (live, GET_MODE (reg), regno);\n }\n \n /* Record in LIVE that register REG became live.\n@@ -180,7 +178,7 @@ reg_dies (rtx reg, HARD_REG_SET *live)\n static void\n reg_becomes_live (rtx reg, rtx setter ATTRIBUTE_UNUSED, void *live)\n {\n-  int regno, nregs;\n+  int regno;\n \n   if (GET_CODE (reg) == SUBREG)\n     reg = SUBREG_REG (reg);\n@@ -190,9 +188,7 @@ reg_becomes_live (rtx reg, rtx setter ATTRIBUTE_UNUSED, void *live)\n \n   regno = REGNO (reg);\n   if (regno < FIRST_PSEUDO_REGISTER)\n-    for (nregs = hard_regno_nregs[regno][GET_MODE (reg)] - 1; nregs >= 0;\n-\t nregs--)\n-      SET_HARD_REG_BIT (* (HARD_REG_SET *) live, regno + nregs);\n+    add_to_hard_reg_set ((HARD_REG_SET *) live, GET_MODE (reg), regno);\n }\n \n /* Make sure if MODE_ENTRY is defined the MODE_EXIT is defined"}, {"sha": "1b81704d5375dd19395e6e7e10f838fe9f9e3ad1", "filename": "gcc/recog.c", "status": "modified", "additions": 4, "deletions": 17, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e18274fda8ab58c3417e148e37d0264df1f6bb/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e18274fda8ab58c3417e148e37d0264df1f6bb/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=09e18274fda8ab58c3417e148e37d0264df1f6bb", "patch": "@@ -2713,21 +2713,9 @@ reg_fits_class_p (rtx operand, enum reg_class cl, int offset,\n   if (cl == NO_REGS)\n     return 0;\n \n-  if (regno < FIRST_PSEUDO_REGISTER\n-      && TEST_HARD_REG_BIT (reg_class_contents[(int) cl],\n-\t\t\t    regno + offset))\n-    {\n-      int sr;\n-      regno += offset;\n-      for (sr = hard_regno_nregs[regno][mode] - 1;\n-\t   sr > 0; sr--)\n-\tif (! TEST_HARD_REG_BIT (reg_class_contents[(int) cl],\n-\t\t\t\t regno + sr))\n-\t  break;\n-      return sr == 0;\n-    }\n-\n-  return 0;\n+  return (regno < FIRST_PSEUDO_REGISTER\n+\t  && in_hard_reg_set_p (reg_class_contents[(int) cl],\n+\t\t\t\tmode, regno + offset));\n }\n \f\n /* Split single instruction.  Helper function for split_all_insns and\n@@ -3054,8 +3042,7 @@ peep2_find_free_register (int from, int to, const char *class_str,\n \t}\n       if (success)\n \t{\n-\t  for (j = hard_regno_nregs[regno][mode] - 1; j >= 0; j--)\n-\t    SET_HARD_REG_BIT (*reg_set, regno + j);\n+\t  add_to_hard_reg_set (reg_set, mode, regno);\n \n \t  /* Start the next search with the next register.  */\n \t  if (++raw_regno >= FIRST_PSEUDO_REGISTER)"}, {"sha": "81240135de5fad597f0c648a28f74d3aa40fb738", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e18274fda8ab58c3417e148e37d0264df1f6bb/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e18274fda8ab58c3417e148e37d0264df1f6bb/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=09e18274fda8ab58c3417e148e37d0264df1f6bb", "patch": "@@ -2625,8 +2625,7 @@ convert_regs_exit (void)\n   if (retvalue)\n     {\n       value_reg_low = REGNO (retvalue);\n-      value_reg_high = value_reg_low\n-\t+ hard_regno_nregs[value_reg_low][GET_MODE (retvalue)] - 1;\n+      value_reg_high = END_HARD_REGNO (retvalue) - 1;\n     }\n \n   output_stack = &BLOCK_INFO (EXIT_BLOCK_PTR)->stack_in;"}, {"sha": "635f2d3a411c855576c50b59210a5aed00e83fde", "filename": "gcc/regclass.c", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e18274fda8ab58c3417e148e37d0264df1f6bb/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e18274fda8ab58c3417e148e37d0264df1f6bb/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=09e18274fda8ab58c3417e148e37d0264df1f6bb", "patch": "@@ -1766,7 +1766,6 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t  unsigned int regno = REGNO (ops[!i]);\n \t  enum machine_mode mode = GET_MODE (ops[!i]);\n \t  int class;\n-\t  unsigned int nr;\n \n \t  if (regno >= FIRST_PSEUDO_REGISTER && reg_pref != 0\n \t      && reg_pref[regno].prefclass != NO_REGS)\n@@ -1785,18 +1784,9 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t\t{\n \t\t  if (reg_class_size[class] == 1)\n \t\t    op_costs[i].cost[class] = -1;\n-\t\t  else\n-\t\t    {\n-\t\t      for (nr = 0; nr < (unsigned) hard_regno_nregs[regno][mode]; nr++)\n-\t\t\t{\n-\t\t\t  if (! TEST_HARD_REG_BIT (reg_class_contents[class],\n-\t\t\t\t\t\t   regno + nr))\n-\t\t\t    break;\n-\t\t\t}\n-\n-\t\t      if (nr == (unsigned) hard_regno_nregs[regno][mode])\n-\t\t\top_costs[i].cost[class] = -1;\n-\t\t    }\n+\t\t  else if (in_hard_reg_set_p (reg_class_contents[class],\n+\t\t\t\t\t     mode, regno))\n+\t\t    op_costs[i].cost[class] = -1;\n \t\t}\n \t}\n }"}, {"sha": "6cabe434e1cbc5a38c7f985d677dd0b655aad488", "filename": "gcc/regrename.c", "status": "modified", "additions": 8, "deletions": 27, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e18274fda8ab58c3417e148e37d0264df1f6bb/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e18274fda8ab58c3417e148e37d0264df1f6bb/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=09e18274fda8ab58c3417e148e37d0264df1f6bb", "patch": "@@ -100,21 +100,14 @@ static void\n note_sets (rtx x, rtx set ATTRIBUTE_UNUSED, void *data)\n {\n   HARD_REG_SET *pset = (HARD_REG_SET *) data;\n-  unsigned int regno;\n-  int nregs;\n \n   if (GET_CODE (x) == SUBREG)\n     x = SUBREG_REG (x);\n   if (!REG_P (x))\n     return;\n-  regno = REGNO (x);\n-  nregs = hard_regno_nregs[regno][GET_MODE (x)];\n-\n   /* There must not be pseudos at this point.  */\n-  gcc_assert (regno + nregs <= FIRST_PSEUDO_REGISTER);\n-\n-  while (nregs-- > 0)\n-    SET_HARD_REG_BIT (*pset, regno + nregs);\n+  gcc_assert (HARD_REGISTER_P (x));\n+  add_to_hard_reg_set (pset, GET_MODE (x), REGNO (x));\n }\n \n /* Clear all registers from *PSET for which a note of kind KIND can be found\n@@ -128,14 +121,9 @@ clear_dead_regs (HARD_REG_SET *pset, enum machine_mode kind, rtx notes)\n     if (REG_NOTE_KIND (note) == kind && REG_P (XEXP (note, 0)))\n       {\n \trtx reg = XEXP (note, 0);\n-\tunsigned int regno = REGNO (reg);\n-\tint nregs = hard_regno_nregs[regno][GET_MODE (reg)];\n-\n \t/* There must not be pseudos at this point.  */\n-\tgcc_assert (regno + nregs <= FIRST_PSEUDO_REGISTER);\n-\n-\twhile (nregs-- > 0)\n-\t  CLEAR_HARD_REG_BIT (*pset, regno + nregs);\n+\tgcc_assert (HARD_REGISTER_P (reg));\n+\tremove_from_hard_reg_set (pset, GET_MODE (reg), REGNO (reg));\n       }\n }\n \n@@ -218,14 +206,9 @@ regrename_optimize (void)\n       /* Don't clobber traceback for noreturn functions.  */\n       if (frame_pointer_needed)\n \t{\n-\t  int i;\n-\n-\t  for (i = hard_regno_nregs[FRAME_POINTER_REGNUM][Pmode]; i--;)\n-\t    SET_HARD_REG_BIT (unavailable, FRAME_POINTER_REGNUM + i);\n-\n+\t  add_to_hard_reg_set (&unavailable, Pmode, FRAME_POINTER_REGNUM);\n #if FRAME_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM\n-\t  for (i = hard_regno_nregs[HARD_FRAME_POINTER_REGNUM][Pmode]; i--;)\n-\t    SET_HARD_REG_BIT (unavailable, HARD_FRAME_POINTER_REGNUM + i);\n+\t  add_to_hard_reg_set (&unavailable, Pmode, HARD_FRAME_POINTER_REGNUM);\n #endif\n \t}\n \n@@ -1388,11 +1371,9 @@ find_oldest_value_reg (enum reg_class cl, rtx reg, struct value_data *vd)\n     {\n       enum machine_mode oldmode = vd->e[i].mode;\n       rtx new;\n-      unsigned int last;\n \n-      for (last = i; last < i + hard_regno_nregs[i][mode]; last++)\n-\tif (!TEST_HARD_REG_BIT (reg_class_contents[cl], last))\n-\t  return NULL_RTX;\n+      if (!in_hard_reg_set_p (reg_class_contents[cl], mode, i))\n+\treturn NULL_RTX;\n \n       new = maybe_mode_change (oldmode, vd->e[regno].mode, mode, i, regno);\n       if (new)"}, {"sha": "35b1d9f0f34e3a8a9bde79b72daa1e8d42cb2087", "filename": "gcc/regs.h", "status": "modified", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e18274fda8ab58c3417e148e37d0264df1f6bb/gcc%2Fregs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e18274fda8ab58c3417e148e37d0264df1f6bb/gcc%2Fregs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregs.h?ref=09e18274fda8ab58c3417e148e37d0264df1f6bb", "patch": "@@ -243,4 +243,88 @@ extern void clear_reg_info_regno (unsigned int);\n /* Specify number of hard registers given machine mode occupy.  */\n extern unsigned char hard_regno_nregs[FIRST_PSEUDO_REGISTER][MAX_MACHINE_MODE];\n \n+/* Return an exclusive upper bound on the registers occupied by hard\n+   register (reg:MODE REGNO).  */\n+\n+static inline unsigned int\n+end_hard_regno (enum machine_mode mode, unsigned int regno)\n+{\n+  return regno + hard_regno_nregs[regno][(int) mode];\n+}\n+\n+/* Likewise for hard register X.  */\n+\n+#define END_HARD_REGNO(X) end_hard_regno (GET_MODE (X), REGNO (X))\n+\n+/* Likewise for hard or pseudo register X.  */\n+\n+#define END_REGNO(X) (HARD_REGISTER_P (X) ? END_HARD_REGNO (X) : REGNO (X) + 1)\n+\n+/* Add to REGS all the registers required to store a value of mode MODE\n+   in register REGNO.  */\n+\n+static inline void\n+add_to_hard_reg_set (HARD_REG_SET *regs, enum machine_mode mode,\n+\t\t     unsigned int regno)\n+{\n+  unsigned int end_regno;\n+\n+  end_regno = end_hard_regno (mode, regno);\n+  do\n+    SET_HARD_REG_BIT (*regs, regno);\n+  while (++regno < end_regno);\n+}\n+\n+/* Likewise, but remove the registers.  */\n+\n+static inline void\n+remove_from_hard_reg_set (HARD_REG_SET *regs, enum machine_mode mode,\n+\t\t\t  unsigned int regno)\n+{\n+  unsigned int end_regno;\n+\n+  end_regno = end_hard_regno (mode, regno);\n+  do\n+    CLEAR_HARD_REG_BIT (*regs, regno);\n+  while (++regno < end_regno);\n+}\n+\n+/* Return true if REGS contains the whole of (reg:MODE REGNO).  */\n+\n+static inline bool\n+in_hard_reg_set_p (const HARD_REG_SET regs, enum machine_mode mode,\n+\t\t   unsigned int regno)\n+{\n+  unsigned int end_regno;\n+\n+  if (!TEST_HARD_REG_BIT (regs, regno))\n+    return false;\n+\n+  end_regno = end_hard_regno (mode, regno);\n+  while (++regno < end_regno)\n+    if (!TEST_HARD_REG_BIT (regs, regno))\n+      return false;\n+\n+  return true;\n+}\n+\n+/* Return true if (reg:MODE REGNO) includes an element of REGS.  */\n+\n+static inline bool\n+overlaps_hard_reg_set_p (const HARD_REG_SET regs, enum machine_mode mode,\n+\t\t\t unsigned int regno)\n+{\n+  unsigned int end_regno;\n+\n+  if (TEST_HARD_REG_BIT (regs, regno))\n+    return true;\n+\n+  end_regno = end_hard_regno (mode, regno);\n+  while (++regno < end_regno)\n+    if (TEST_HARD_REG_BIT (regs, regno))\n+      return true;\n+\n+  return false;\n+}\n+\n #endif /* GCC_REGS_H */"}, {"sha": "16a7e474e66210d2bcd1cea6ea5474b29bb4c82f", "filename": "gcc/reload.c", "status": "modified", "additions": 13, "deletions": 36, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e18274fda8ab58c3417e148e37d0264df1f6bb/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e18274fda8ab58c3417e148e37d0264df1f6bb/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=09e18274fda8ab58c3417e148e37d0264df1f6bb", "patch": "@@ -1259,17 +1259,8 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \t}\n       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \tif (HARD_REGNO_MODE_OK (i, mode)\n-\t    && TEST_HARD_REG_BIT (reg_class_contents[(int) class], i))\n-\t  {\n-\t    int nregs = hard_regno_nregs[i][mode];\n-\n-\t    int j;\n-\t    for (j = 1; j < nregs; j++)\n-\t      if (! TEST_HARD_REG_BIT (reg_class_contents[(int) class], i + j))\n-\t\tbreak;\n-\t    if (j == nregs)\n-\t      break;\n-\t  }\n+\t    && in_hard_reg_set_p (reg_class_contents[(int) class], mode, i))\n+\t  break;\n       if (i == FIRST_PSEUDO_REGISTER)\n \t{\n \t  error_for_asm (this_insn, \"impossible register constraint \"\n@@ -1533,18 +1524,15 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \t\t|| ! bitmap_bit_p (ENTRY_BLOCK_PTR->il.rtl->global_live_at_end,\n \t\t\t\t   ORIGINAL_REGNO (XEXP (note, 0))))\n \t    && ! refers_to_regno_for_reload_p (regno,\n-\t\t\t\t\t       (regno\n-\t\t\t\t\t\t+ hard_regno_nregs[regno]\n-\t\t\t\t\t\t\t\t  [rel_mode]),\n+\t\t\t\t\t       end_hard_regno (rel_mode,\n+\t\t\t\t\t\t\t       regno),\n \t\t\t\t\t       PATTERN (this_insn), inloc)\n \t    /* If this is also an output reload, IN cannot be used as\n \t       the reload register if it is set in this insn unless IN\n \t       is also OUT.  */\n \t    && (out == 0 || in == out\n \t\t|| ! hard_reg_set_here_p (regno,\n-\t\t\t\t\t  (regno\n-\t\t\t\t\t   + hard_regno_nregs[regno]\n-\t\t\t\t\t\t\t     [rel_mode]),\n+\t\t\t\t\t  end_hard_regno (rel_mode, regno),\n \t\t\t\t\t  PATTERN (this_insn)))\n \t    /* ??? Why is this code so different from the previous?\n \t       Is there any simple coherent way to describe the two together?\n@@ -1573,8 +1561,7 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \n \t    if (offs == nregs\n \t\t&& (! (refers_to_regno_for_reload_p\n-\t\t       (regno, (regno + hard_regno_nregs[regno][inmode]),\n-\t\t\t\tin, (rtx *)0))\n+\t\t       (regno, end_hard_regno (inmode, regno), in, (rtx *) 0))\n \t\t    || can_reload_into (in, regno, inmode)))\n \t      {\n \t\trld[i].reg_rtx = gen_rtx_REG (rel_mode, regno);\n@@ -2089,7 +2076,7 @@ hard_reg_set_here_p (unsigned int beg_regno, unsigned int end_regno, rtx x)\n \n \t  /* See if this reg overlaps range under consideration.  */\n \t  if (r < end_regno\n-\t      && r + hard_regno_nregs[r][GET_MODE (op0)] > beg_regno)\n+\t      && end_hard_regno (GET_MODE (op0), r) > beg_regno)\n \t    return 1;\n \t}\n     }\n@@ -2409,7 +2396,7 @@ decompose (rtx x)\n \t}\n       else\n \t/* A hard reg.  */\n-\tval.end = val.start + hard_regno_nregs[val.start][GET_MODE (x)];\n+\tval.end = end_hard_regno (GET_MODE (x), val.start);\n       break;\n \n     case SUBREG:\n@@ -6500,7 +6487,7 @@ reg_overlap_mentioned_for_reload_p (rtx x, rtx in)\n \t  return 0;\n \t}\n \n-      endregno = regno + hard_regno_nregs[regno][GET_MODE (x)];\n+      endregno = END_HARD_REGNO (x);\n \n       return refers_to_regno_for_reload_p (regno, endregno, in, (rtx*) 0);\n     }\n@@ -6733,17 +6720,9 @@ find_equiv_reg (rtx goal, rtx insn, enum reg_class class, int other,\n \t\t}\n \t      else if ((unsigned) valueno >= FIRST_PSEUDO_REGISTER)\n \t\tcontinue;\n-\t      else\n-\t\t{\n-\t\t  int i;\n-\n-\t\t  for (i = hard_regno_nregs[valueno][mode] - 1; i >= 0; i--)\n-\t\t    if (! TEST_HARD_REG_BIT (reg_class_contents[(int) class],\n-\t\t\t\t\t     valueno + i))\n-\t\t      break;\n-\t\t  if (i >= 0)\n-\t\t    continue;\n-\t\t}\n+\t      else if (!in_hard_reg_set_p (reg_class_contents[(int) class],\n+\t\t\t\t\t  mode, valueno))\n+\t\tcontinue;\n \t      value = valtry;\n \t      where = p;\n \t      break;\n@@ -6777,9 +6756,7 @@ find_equiv_reg (rtx goal, rtx insn, enum reg_class class, int other,\n      and is also a register that appears in the address of GOAL.  */\n \n   if (goal_mem && value == SET_DEST (single_set (where))\n-      && refers_to_regno_for_reload_p (valueno,\n-\t\t\t\t       (valueno\n-\t\t\t\t\t+ hard_regno_nregs[valueno][mode]),\n+      && refers_to_regno_for_reload_p (valueno, end_hard_regno (mode, valueno),\n \t\t\t\t       goal, (rtx*) 0))\n     return 0;\n "}, {"sha": "7a3e78a798124d7fbbc0b2b2455606fc0d97ac2d", "filename": "gcc/reload1.c", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e18274fda8ab58c3417e148e37d0264df1f6bb/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e18274fda8ab58c3417e148e37d0264df1f6bb/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=09e18274fda8ab58c3417e148e37d0264df1f6bb", "patch": "@@ -542,7 +542,6 @@ compute_use_by_pseudos (HARD_REG_SET *to, regset from)\n   EXECUTE_IF_SET_IN_REG_SET (from, FIRST_PSEUDO_REGISTER, regno, rsi)\n     {\n       int r = reg_renumber[regno];\n-      int nregs;\n \n       if (r < 0)\n \t{\n@@ -553,11 +552,7 @@ compute_use_by_pseudos (HARD_REG_SET *to, regset from)\n \t  gcc_assert (reload_completed);\n \t}\n       else\n-\t{\n-\t  nregs = hard_regno_nregs[r][PSEUDO_REGNO_MODE (regno)];\n-\t  while (nregs-- > 0)\n-\t    SET_HARD_REG_BIT (*to, r + nregs);\n-\t}\n+\tadd_to_hard_reg_set (to, PSEUDO_REGNO_MODE (regno), r);\n     }\n }\n \n@@ -2194,7 +2189,7 @@ mark_home_live (int regno)\n   i = reg_renumber[regno];\n   if (i < 0)\n     return;\n-  lim = i + hard_regno_nregs[i][PSEUDO_REGNO_MODE (regno)];\n+  lim = end_hard_regno (PSEUDO_REGNO_MODE (regno), i);\n   while (i < lim)\n     regs_ever_live[i++] = 1;\n }\n@@ -3763,10 +3758,7 @@ spill_hard_reg (unsigned int regno, int cant_eliminate)\n   for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n     if (reg_renumber[i] >= 0\n \t&& (unsigned int) reg_renumber[i] <= regno\n-\t&& ((unsigned int) reg_renumber[i]\n-\t    + hard_regno_nregs[(unsigned int) reg_renumber[i]]\n-\t\t\t      [PSEUDO_REGNO_MODE (i)]\n-\t    > regno))\n+\t&& end_hard_regno (PSEUDO_REGNO_MODE (i), reg_renumber[i]) > regno)\n       SET_REGNO_REG_SET (&spilled_pseudos, i);\n }\n \n@@ -4586,8 +4578,7 @@ clear_reload_reg_in_use (unsigned int regno, int opnum,\n \t    {\n \t      unsigned int conflict_start = true_regnum (rld[i].reg_rtx);\n \t      unsigned int conflict_end\n-\t\t= (conflict_start\n-\t\t   + hard_regno_nregs[conflict_start][rld[i].mode]);\n+\t\t= end_hard_regno (rld[i].mode, conflict_start);\n \n \t      /* If there is an overlap with the first to-be-freed register,\n \t\t adjust the interval start.  */"}, {"sha": "bdf2c313b51f045ee1372b35d33728d0b131ff99", "filename": "gcc/reorg.c", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e18274fda8ab58c3417e148e37d0264df1f6bb/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e18274fda8ab58c3417e148e37d0264df1f6bb/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=09e18274fda8ab58c3417e148e37d0264df1f6bb", "patch": "@@ -3170,16 +3170,9 @@ delete_prior_computation (rtx note, rtx insn)\n \t\t   && REG_P (SET_DEST (pat)))\n \t    {\n \t      int dest_regno = REGNO (SET_DEST (pat));\n-\t      int dest_endregno\n-\t\t= (dest_regno\n-\t\t   + (dest_regno < FIRST_PSEUDO_REGISTER\n-\t\t      ? hard_regno_nregs[dest_regno]\n-\t\t\t\t\t[GET_MODE (SET_DEST (pat))] : 1));\n+\t      int dest_endregno = END_REGNO (SET_DEST (pat));\n \t      int regno = REGNO (reg);\n-\t      int endregno\n-\t\t= (regno\n-\t\t   + (regno < FIRST_PSEUDO_REGISTER\n-\t\t      ? hard_regno_nregs[regno][GET_MODE (reg)] : 1));\n+\t      int endregno = END_REGNO (reg);\n \n \t      if (dest_regno >= regno\n \t\t  && dest_endregno <= endregno)"}, {"sha": "2e3f3d4b0bc3578d3ce8665925a34ea56b98dbd7", "filename": "gcc/resource.c", "status": "modified", "additions": 13, "deletions": 47, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e18274fda8ab58c3417e148e37d0264df1f6bb/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e18274fda8ab58c3417e148e37d0264df1f6bb/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=09e18274fda8ab58c3417e148e37d0264df1f6bb", "patch": "@@ -107,8 +107,7 @@ update_live_status (rtx dest, rtx x, void *data ATTRIBUTE_UNUSED)\n   else\n     {\n       first_regno = REGNO (dest);\n-      last_regno\n-\t= first_regno + hard_regno_nregs[first_regno][GET_MODE (dest)];\n+      last_regno = END_HARD_REGNO (dest);\n     }\n \n   if (GET_CODE (x) == CLOBBER)\n@@ -244,15 +243,8 @@ mark_referenced_resources (rtx x, struct resources *res,\n       return;\n \n     case REG:\n-\t{\n-\t  unsigned int regno = REGNO (x);\n-\t  unsigned int last_regno\n-\t    = regno + hard_regno_nregs[regno][GET_MODE (x)];\n-\n-\t  gcc_assert (last_regno <= FIRST_PSEUDO_REGISTER);\n-\t  for (r = regno; r < last_regno; r++)\n-\t    SET_HARD_REG_BIT (res->regs, r);\n-\t}\n+      gcc_assert (HARD_REGISTER_P (x));\n+      add_to_hard_reg_set (&res->regs, GET_MODE (x), REGNO (x));\n       return;\n \n     case MEM:\n@@ -780,13 +772,8 @@ mark_set_resources (rtx x, struct resources *res, int in_dest,\n     case REG:\n       if (in_dest)\n \t{\n-\t  unsigned int regno = REGNO (x);\n-\t  unsigned int last_regno\n-\t    = regno + hard_regno_nregs[regno][GET_MODE (x)];\n-\n-\t  gcc_assert (last_regno <= FIRST_PSEUDO_REGISTER);\n-\t  for (r = regno; r < last_regno; r++)\n-\t    SET_HARD_REG_BIT (res->regs, r);\n+\t  gcc_assert (HARD_REGISTER_P (x));\n+\t  add_to_hard_reg_set (&res->regs, GET_MODE (x), REGNO (x));\n \t}\n       return;\n \n@@ -970,8 +957,6 @@ mark_target_live_regs (rtx insns, rtx target, struct resources *res)\n   if (b != -1)\n     {\n       regset regs_live = BASIC_BLOCK (b)->il.rtl->global_live_at_start;\n-      unsigned int j;\n-      unsigned int regno;\n       rtx start_insn, stop_insn;\n       reg_set_iterator rsi;\n \n@@ -984,13 +969,8 @@ mark_target_live_regs (rtx insns, rtx target, struct resources *res)\n       EXECUTE_IF_SET_IN_REG_SET (regs_live, FIRST_PSEUDO_REGISTER, i, rsi)\n \t{\n \t  if (reg_renumber[i] >= 0)\n-\t    {\n-\t      regno = reg_renumber[i];\n-\t      for (j = regno;\n-\t\t   j < regno + hard_regno_nregs[regno][PSEUDO_REGNO_MODE (i)];\n-\t\t   j++)\n-\t\tSET_HARD_REG_BIT (current_live_regs, j);\n-\t    }\n+\t    add_to_hard_reg_set (&current_live_regs, PSEUDO_REGNO_MODE (i),\n+\t\t\t\treg_renumber[i]);\n \t}\n \n       /* Get starting and ending insn, handling the case where each might\n@@ -1056,16 +1036,9 @@ mark_target_live_regs (rtx insns, rtx target, struct resources *res)\n \t\tif (REG_NOTE_KIND (link) == REG_DEAD\n \t\t    && REG_P (XEXP (link, 0))\n \t\t    && REGNO (XEXP (link, 0)) < FIRST_PSEUDO_REGISTER)\n-\t\t  {\n-\t\t    unsigned int first_regno = REGNO (XEXP (link, 0));\n-\t\t    unsigned int last_regno\n-\t\t      = (first_regno\n-\t\t\t + hard_regno_nregs[first_regno]\n-\t\t\t\t\t   [GET_MODE (XEXP (link, 0))]);\n-\n-\t\t    for (i = first_regno; i < last_regno; i++)\n-\t\t      SET_HARD_REG_BIT (pending_dead_regs, i);\n-\t\t  }\n+\t\t  add_to_hard_reg_set (&pending_dead_regs,\n+\t\t\t\t      GET_MODE (XEXP (link, 0)),\n+\t\t\t\t      REGNO (XEXP (link, 0)));\n \n \t      note_stores (PATTERN (real_insn), update_live_status, NULL);\n \n@@ -1075,16 +1048,9 @@ mark_target_live_regs (rtx insns, rtx target, struct resources *res)\n \t\tif (REG_NOTE_KIND (link) == REG_UNUSED\n \t\t    && REG_P (XEXP (link, 0))\n \t\t    && REGNO (XEXP (link, 0)) < FIRST_PSEUDO_REGISTER)\n-\t\t  {\n-\t\t    unsigned int first_regno = REGNO (XEXP (link, 0));\n-\t\t    unsigned int last_regno\n-\t\t      = (first_regno\n-\t\t\t + hard_regno_nregs[first_regno]\n-\t\t\t\t\t   [GET_MODE (XEXP (link, 0))]);\n-\n-\t\t    for (i = first_regno; i < last_regno; i++)\n-\t\t      CLEAR_HARD_REG_BIT (current_live_regs, i);\n-\t\t  }\n+\t\t  remove_from_hard_reg_set (&current_live_regs,\n+\t\t\t\t\t   GET_MODE (XEXP (link, 0)),\n+\t\t\t\t\t   REGNO (XEXP (link, 0)));\n \t    }\n \n \t  else if (LABEL_P (real_insn))"}, {"sha": "6a06f30abead5d0a9a916a725dd81e03ce5ccb2f", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 10, "deletions": 23, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e18274fda8ab58c3417e148e37d0264df1f6bb/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e18274fda8ab58c3417e148e37d0264df1f6bb/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=09e18274fda8ab58c3417e148e37d0264df1f6bb", "patch": "@@ -1233,10 +1233,7 @@ refers_to_regno_p (unsigned int regno, unsigned int endregno, rtx x,\n \t  && regno >= FIRST_VIRTUAL_REGISTER && regno <= LAST_VIRTUAL_REGISTER)\n \treturn 1;\n \n-      return (endregno > x_regno\n-\t      && regno < x_regno + (x_regno < FIRST_PSEUDO_REGISTER\n-\t\t\t\t    ? hard_regno_nregs[x_regno][GET_MODE (x)]\n-\t\t\t      : 1));\n+      return endregno > x_regno && regno < END_REGNO (x);\n \n     case SUBREG:\n       /* If this is a SUBREG of a hard reg, we can see exactly which\n@@ -1343,8 +1340,7 @@ reg_overlap_mentioned_p (rtx x, rtx in)\n \n     case REG:\n       regno = REGNO (x);\n-      endregno = regno + (regno < FIRST_PSEUDO_REGISTER\n-\t\t\t  ? hard_regno_nregs[regno][GET_MODE (x)] : 1);\n+      endregno = END_REGNO (x);\n     do_reg:\n       return refers_to_regno_p (regno, endregno, in, (rtx*) 0);\n \n@@ -1551,7 +1547,7 @@ note_uses (rtx *pbody, void (*fun) (rtx *, void *), void *data)\n int\n dead_or_set_p (rtx insn, rtx x)\n {\n-  unsigned int regno, last_regno;\n+  unsigned int regno, end_regno;\n   unsigned int i;\n \n   /* Can't use cc0_rtx below since this file is used by genattrtab.c.  */\n@@ -1561,10 +1557,8 @@ dead_or_set_p (rtx insn, rtx x)\n   gcc_assert (REG_P (x));\n \n   regno = REGNO (x);\n-  last_regno = (regno >= FIRST_PSEUDO_REGISTER ? regno\n-\t\t: regno + hard_regno_nregs[regno][GET_MODE (x)] - 1);\n-\n-  for (i = regno; i <= last_regno; i++)\n+  end_regno = END_REGNO (x);\n+  for (i = regno; i < end_regno; i++)\n     if (! dead_or_set_regno_p (insn, i))\n       return 0;\n \n@@ -1591,8 +1585,7 @@ covers_regno_no_parallel_p (rtx dest, unsigned int test_regno)\n     return false;\n \n   regno = REGNO (dest);\n-  endregno = (regno >= FIRST_PSEUDO_REGISTER ? regno + 1\n-\t      : regno + hard_regno_nregs[regno][GET_MODE (dest)]);\n+  endregno = END_REGNO (dest);\n   return (test_regno >= regno && test_regno < endregno);\n }\n \n@@ -1713,11 +1706,7 @@ find_regno_note (rtx insn, enum reg_note kind, unsigned int regno)\n \t   problem here.  */\n \t&& REG_P (XEXP (link, 0))\n \t&& REGNO (XEXP (link, 0)) <= regno\n-\t&& ((REGNO (XEXP (link, 0))\n-\t     + (REGNO (XEXP (link, 0)) >= FIRST_PSEUDO_REGISTER ? 1\n-\t\t: hard_regno_nregs[REGNO (XEXP (link, 0))]\n-\t\t\t\t  [GET_MODE (XEXP (link, 0))]))\n-\t    > regno))\n+\t&& END_REGNO (XEXP (link, 0)) > regno)\n       return link;\n   return 0;\n }\n@@ -1807,8 +1796,7 @@ find_reg_fusage (rtx insn, enum rtx_code code, rtx datum)\n \n       if (regno < FIRST_PSEUDO_REGISTER)\n \t{\n-\t  unsigned int end_regno\n-\t    = regno + hard_regno_nregs[regno][GET_MODE (datum)];\n+\t  unsigned int end_regno = END_HARD_REGNO (datum);\n \t  unsigned int i;\n \n \t  for (i = regno; i < end_regno; i++)\n@@ -1837,13 +1825,12 @@ find_regno_fusage (rtx insn, enum rtx_code code, unsigned int regno)\n \n   for (link = CALL_INSN_FUNCTION_USAGE (insn); link; link = XEXP (link, 1))\n     {\n-      unsigned int regnote;\n       rtx op, reg;\n \n       if (GET_CODE (op = XEXP (link, 0)) == code\n \t  && REG_P (reg = XEXP (op, 0))\n-\t  && (regnote = REGNO (reg)) <= regno\n-\t  && regnote + hard_regno_nregs[regnote][GET_MODE (reg)] > regno)\n+\t  && REGNO (reg) <= regno\n+\t  && END_HARD_REGNO (reg) > regno)\n \treturn 1;\n     }\n "}, {"sha": "bd3c7b1a9be67a1a3fc0fcfd800771d3d74cf162", "filename": "gcc/stmt.c", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e18274fda8ab58c3417e148e37d0264df1f6bb/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e18274fda8ab58c3417e148e37d0264df1f6bb/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=09e18274fda8ab58c3417e148e37d0264df1f6bb", "patch": "@@ -575,14 +575,9 @@ decl_overlaps_hard_reg_set_p (tree *declp, int *walk_subtrees ATTRIBUTE_UNUSED,\n \t  && REGNO (DECL_RTL (decl)) < FIRST_PSEUDO_REGISTER)\n \t{\n \t  rtx reg = DECL_RTL (decl);\n-\t  unsigned int regno;\n-\n-\t  for (regno = REGNO (reg);\n-\t       regno < (REGNO (reg)\n-\t\t\t+ hard_regno_nregs[REGNO (reg)][GET_MODE (reg)]);\n-\t       regno++)\n-\t    if (TEST_HARD_REG_BIT (*regs, regno))\n-\t      return decl;\n+\n+\t  if (overlaps_hard_reg_set_p (*regs, GET_MODE (reg), REGNO (reg)))\n+\t    return decl;\n \t}\n       walk_subtrees = 0;\n     }"}, {"sha": "94a025a002b0418c533f75f8b2fbe9a5cea759a1", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e18274fda8ab58c3417e148e37d0264df1f6bb/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e18274fda8ab58c3417e148e37d0264df1f6bb/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=09e18274fda8ab58c3417e148e37d0264df1f6bb", "patch": "@@ -2389,8 +2389,7 @@ emit_note_insn_var_location (void **varp, void *data)\n \t  if (REG_P (loc[n_var_parts])\n \t      && hard_regno_nregs[REGNO (loc[n_var_parts])][mode] * 2\n \t\t == hard_regno_nregs[REGNO (loc[n_var_parts])][wider_mode]\n-\t      && REGNO (loc[n_var_parts])\n-\t\t + hard_regno_nregs[REGNO (loc[n_var_parts])][mode]\n+\t      && end_hard_regno (mode, REGNO (loc[n_var_parts]))\n \t\t == REGNO (loc2))\n \t    {\n \t      if (! WORDS_BIG_ENDIAN && ! BYTES_BIG_ENDIAN)"}]}