{"sha": "557b744a6e41a13dd44770dc64e19a34a32092c5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTU3Yjc0NGE2ZTQxYTEzZGQ0NDc3MGRjNjRlMTlhMzRhMzIwOTJjNQ==", "commit": {"author": {"name": "Olivier Hainque", "email": "hainque@adacore.com", "date": "2018-06-11T09:19:22Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2018-06-11T09:19:22Z"}, "message": "[Ada] Improve last exception info availability from C++ handlers\n\nThe Most_Recent_Exception service failed to provide accurate information on an\nAda exception caught by a C++ handler for foreign exceptions. The service\nrelies on updates of a \"current exception buffer\" from live exception objects\nat various points of the propagation process and this update was not performed\nearly enough for the case of foreign exception handlers in non-Ada handlers.\n\nThe correction applied here consists in moving one of the updates earlier in\nthe raise process, just before unwinding starts, then refine the update API to\nprevent a redundant copy during the unwinding search phase for the same\nexception.\n\nThe example below, compiled with\n\ngcc -c b.cc\ngnatmake -g main.adb -largs b.o --LINK=g++\n\nis expected to run and display\n\nada info:\nChecking Most_Recent_Exception for CONSTRAINT_ERROR ... OK!\n\n// b.cc\n\nextern \"C\" {\n void foo ();\n extern void _ada_trigger ();\n extern void _ada_occurrence_info ();\n}\n\nvoid foo ()\n{\n try {\n   _ada_trigger ();\n } catch (const abi::__foreign_exception &e) {\n   printf (\"ada info:\\n\");\n   _ada_occurrence_info();\n }\n}\n\n-- main.adb\n\nwith EH;\nprocedure Main is\nbegin\n  EH.Foo;\nend;\n\n-- eh.adb\n\nwith Gnat.Most_Recent_Exception;\nwith Ada.Text_IO; use Ada.Text_IO;\n\npackage body EH is\n\n  procedure Ada_Trigger is\n  begin\n     raise Constraint_Error;\n  end;\n\n  procedure Ada_Occurrence_Info is\n  begin\n     Check_MRE (\"CONSTRAINT_ERROR\");\n  end;\n\n  function Pre_Check_MRE (Ename : String) return Exception_Id is\n     MROA : Exception_Occurrence_Access :=\n       GNAT.Most_Recent_Exception.Occurrence_Access;\n  begin\n     Put (\"Checking Most_Recent_Exception for \" & Ename & \" ... \");\n\n     if MROA = null then\n        Put_Line (\"Most recent exception occurrence access is NULL\");\n        return Null_Id;\n     else\n        return Exception_Identity (MROA.all);\n     end if;\n  end;\n\n  procedure Diagnose_MRE (MRID : Exception_Id; Ok : Boolean) is\n  begin\n     if Ok then\n        Put_Line (\"OK!\");\n     else\n        Put_Line (\"Err, Most_Recent_Exception was \" & Exception_Name (MRID));\n     end if;\n  end;\n\n  procedure Check_MRE (Eid : Exception_Id) is\n     MRID : Exception_Id := Pre_Check_MRE (Ename => Exception_Name (Eid));\n  begin\n     Diagnose_MRE (MRID, Ok => Eid = MRID);\n  end;\n\n  procedure Check_MRE (Ename : String) is\n     MRID : Exception_Id := Pre_Check_MRE (Ename => Ename);\n  begin\n     Diagnose_MRE (MRID, Ok => Ename = Exception_Name (MRID));\n  end;\n\nend;\n\n-- eh.ads\n\nwith Ada.Exceptions; use Ada.Exceptions;\npackage EH is\n  procedure Ada_Trigger with\n    Export, Convention => C, External_Name => \"_ada_trigger\";\n\n  procedure Ada_Occurrence_Info with\n    Export, Convention => C, External_Name => \"_ada_occurrence_info\";\n\n  procedure Foo with Import, Convention => C, External_Name => \"foo\";\n\n  procedure Check_MRE (Eid : Exception_Id);\n  procedure Check_MRE (Ename : String);\n\nend;\n\n2018-06-11  Olivier Hainque  <hainque@adacore.com>\n\ngcc/ada/\n\n\t* libgnat/s-excmac*.ads: Factorize Unwind_Action definitions ...\n\t* libgnat/a-exexpr.adb: ... Here, then add comments describing the\n\tmajor datastructures associated with the current exception raised.\n\t(Setup_Current_Excep): Accept a \"Phase\" argument conveying the\n\tunwinding phase during which this subprogram is called.  For an Ada\n\texception, don't update the current exception buffer from the raised\n\texception object during SEARCH_PHASE, as this is redundant with the\n\tcall now issued just before propagation starts.\n\t(Propagate_GCC_Exception): Move call to Setup_Current_Excep ahead of\n\tthe unwinding start, conveying Phase 0.\n\t(Unhandled_Except_Handler): Pass UA_CLEANUP_PHASE as the Phase value on\n\tthe call to Setup_Current_Excep.\n\t* raise-gcc.c (personality_body): Pass uw_phases as the Phase argument\n\ton calls to Setup_Current_Excep.\n\nFrom-SVN: r261426", "tree": {"sha": "9666d6086ce5175b23c9768eb52cb5561871b528", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9666d6086ce5175b23c9768eb52cb5561871b528"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/557b744a6e41a13dd44770dc64e19a34a32092c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/557b744a6e41a13dd44770dc64e19a34a32092c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/557b744a6e41a13dd44770dc64e19a34a32092c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/557b744a6e41a13dd44770dc64e19a34a32092c5/comments", "author": {"login": "hainque", "id": 18735142, "node_id": "MDQ6VXNlcjE4NzM1MTQy", "avatar_url": "https://avatars.githubusercontent.com/u/18735142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hainque", "html_url": "https://github.com/hainque", "followers_url": "https://api.github.com/users/hainque/followers", "following_url": "https://api.github.com/users/hainque/following{/other_user}", "gists_url": "https://api.github.com/users/hainque/gists{/gist_id}", "starred_url": "https://api.github.com/users/hainque/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hainque/subscriptions", "organizations_url": "https://api.github.com/users/hainque/orgs", "repos_url": "https://api.github.com/users/hainque/repos", "events_url": "https://api.github.com/users/hainque/events{/privacy}", "received_events_url": "https://api.github.com/users/hainque/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fc0e632a9972a43cd40daeacb2884beb421587dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc0e632a9972a43cd40daeacb2884beb421587dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc0e632a9972a43cd40daeacb2884beb421587dd"}], "stats": {"total": 181, "additions": 137, "deletions": 44}, "files": [{"sha": "b713c4964f191f55258445577bb396a722df0174", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/557b744a6e41a13dd44770dc64e19a34a32092c5/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/557b744a6e41a13dd44770dc64e19a34a32092c5/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=557b744a6e41a13dd44770dc64e19a34a32092c5", "patch": "@@ -1,3 +1,20 @@\n+2018-06-11  Olivier Hainque  <hainque@adacore.com>\n+\n+\t* libgnat/s-excmac*.ads: Factorize Unwind_Action definitions ...\n+\t* libgnat/a-exexpr.adb: ... Here, then add comments describing the\n+\tmajor datastructures associated with the current exception raised.\n+\t(Setup_Current_Excep): Accept a \"Phase\" argument conveying the\n+\tunwinding phase during which this subprogram is called.  For an Ada\n+\texception, don't update the current exception buffer from the raised\n+\texception object during SEARCH_PHASE, as this is redundant with the\n+\tcall now issued just before propagation starts.\n+\t(Propagate_GCC_Exception): Move call to Setup_Current_Excep ahead of\n+\tthe unwinding start, conveying Phase 0.\n+\t(Unhandled_Except_Handler): Pass UA_CLEANUP_PHASE as the Phase value on\n+\tthe call to Setup_Current_Excep.\n+\t* raise-gcc.c (personality_body): Pass uw_phases as the Phase argument\n+\ton calls to Setup_Current_Excep.\n+\n 2018-06-11  Ed Schonberg  <schonberg@adacore.com>\n \n \t* exp_unst.ads, exp_unst.adb (Needs_Fat_Pointer,"}, {"sha": "20baf0b5e6d946f3ed4966027c52c076381edbe0", "filename": "gcc/ada/libgnat/a-exexpr.adb", "status": "modified", "additions": 104, "deletions": 12, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/557b744a6e41a13dd44770dc64e19a34a32092c5/gcc%2Fada%2Flibgnat%2Fa-exexpr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/557b744a6e41a13dd44770dc64e19a34a32092c5/gcc%2Fada%2Flibgnat%2Fa-exexpr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-exexpr.adb?ref=557b744a6e41a13dd44770dc64e19a34a32092c5", "patch": "@@ -29,7 +29,56 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This is the version using the GCC EH mechanism\n+--  This is the version using the GCC EH mechanism, which could rely on\n+--  different underlying unwinding engines, for example DWARF or ARM unwind\n+--  info based. Here is a sketch of the most prominent data structures\n+--  involved:\n+\n+--      (s-excmac.ads)\n+--      GNAT_GCC_Exception:\n+--      *-----------------------------------*\n+--  o-->|          (s-excmac.ads)           |\n+--  |   | Header : <gcc occurrence type>    |\n+--  |   |   - Class                         |\n+--  |   |   ...                             |    Constraint_Error:\n+--  |   |-----------------------------------*    Program_Error:\n+--  |   |              (a-except.ads)       |    Foreign_Exception:\n+--  |   | Occurrence : Exception_Occurrence |\n+--  |   |                                   |    (s-stalib. ads)\n+--  |   |   - Id : Exception_Id  --------------> Exception_Data\n+--  o------ - Machine_Occurrence            |   *------------------------*\n+--      |   - Msg                           |   | Not_Handled_By_Others  |\n+--      |   - Traceback                     |   | Lang                   |\n+--      |   ...                             |   | Foreign_Data --o       |\n+--      *-----------------------------------*   | Full_Name      |       |\n+--        ||                                    | ...            |       |\n+--        ||          foreign rtti blob         *----------------|-------*\n+--        ||          *---------------*                          |\n+--        ||          |   ...   ...   |<-------------------------o\n+--        ||          *---------------*\n+--        ||\n+--     Setup_Current_Excep()\n+--        ||\n+--        ||   Latch into ATCB or\n+--        ||   environment Current Exception Buffer:\n+--        ||\n+--        vv\n+--     <> : Exception_Occurrence\n+--     *---------------------------*\n+--     | ...  ...  ... ... ... ... * --- Get_Current_Excep() ---->\n+--     *---------------------------*\n+\n+--  On \"raise\" events, the runtime allocates a new GNAT_GCC_Exception\n+--  instance and eventually calls into libgcc's Unwind_RaiseException.\n+--  This part handles the object through the header part only.\n+\n+--  During execution, Get_Current_Excep provides a pointer to the\n+--  Exception_Occurrence being raised or last raised by the current task.\n+\n+--  This is actually the address of a statically allocated\n+--  Exception_Occurrence attached to the current ATCB or to the environment\n+--  thread into which an occurrence being raised is synchronized at critical\n+--  points during the raise process, via Setup_Current_Excep.\n \n with Ada.Unchecked_Conversion;\n with Ada.Unchecked_Deallocation;\n@@ -51,6 +100,22 @@ package body Exception_Propagation is\n    -- GNAT Specific Entities To Deal With The GCC EH Circuitry --\n    --------------------------------------------------------------\n \n+   --  Phase identifiers (Unwind Actions)\n+\n+   type Unwind_Action is new Integer;\n+   pragma Convention (C, Unwind_Action);\n+\n+   UA_SEARCH_PHASE  : constant Unwind_Action := 1;\n+   UA_CLEANUP_PHASE : constant Unwind_Action := 2;\n+   UA_HANDLER_FRAME : constant Unwind_Action := 4;\n+   UA_FORCE_UNWIND  : constant Unwind_Action := 8;\n+   UA_END_OF_STACK  : constant Unwind_Action := 16;  --  GCC extension\n+\n+   pragma Unreferenced\n+     (UA_HANDLER_FRAME,\n+      UA_FORCE_UNWIND,\n+      UA_END_OF_STACK);\n+\n    procedure GNAT_GCC_Exception_Cleanup\n      (Reason : Unwind_Reason_Code;\n       Excep  : not null GNAT_GCC_Exception_Access);\n@@ -70,10 +135,19 @@ package body Exception_Propagation is\n    --  directly from gigi.\n \n    function Setup_Current_Excep\n-     (GCC_Exception : not null GCC_Exception_Access) return EOA;\n+     (GCC_Exception : not null GCC_Exception_Access;\n+      Phase : Unwind_Action) return EOA;\n    pragma Export (C, Setup_Current_Excep, \"__gnat_setup_current_excep\");\n-   --  Write Get_Current_Excep.all from GCC_Exception. Called by the\n-   --  personality routine.\n+   --  Acknowledge GCC_Exception as the current exception object being\n+   --  raised, which could be an Ada or a foreign exception object.  Return\n+   --  a pointer to the embedded Ada occurrence for an Ada exception object,\n+   --  to the current exception buffer otherwise.\n+   --\n+   --  Synchronize the current exception buffer as needed for possible\n+   --  accesses through Get_Current_Except.all afterwards, depending on the\n+   --  Phase bits, received either from the personality routine, from a\n+   --  forced_unwind cleanup handler, or just before the start of propagation\n+   --  for an Ada exception (Phase 0 in this case).\n \n    procedure Unhandled_Except_Handler\n      (GCC_Exception : not null GCC_Exception_Access);\n@@ -236,27 +310,41 @@ package body Exception_Propagation is\n    -------------------------\n \n    function Setup_Current_Excep\n-     (GCC_Exception : not null GCC_Exception_Access) return EOA\n+     (GCC_Exception : not null GCC_Exception_Access;\n+      Phase : Unwind_Action) return EOA\n    is\n       Excep : constant EOA := Get_Current_Excep.all;\n \n    begin\n-      --  Setup the exception occurrence\n \n       if GCC_Exception.Class = GNAT_Exception_Class then\n \n-         --  From the GCC exception\n+         --  Ada exception : latch the occurrence data in the Current\n+         --  Exception Buffer if needed and return a pointer to the original\n+         --  Ada exception object. This particular object was specifically\n+         --  allocated for this raise and is thus more precise than the fixed\n+         --  Current Exception Buffer address.\n \n          declare\n             GNAT_Occurrence : constant GNAT_GCC_Exception_Access :=\n                                 To_GNAT_GCC_Exception (GCC_Exception);\n          begin\n-            Excep.all := GNAT_Occurrence.Occurrence;\n+\n+            --  When reaching here during SEARCH_PHASE, no need to\n+            --  replicate the copy performed at the propagation start.\n+\n+            if Phase /= UA_SEARCH_PHASE then\n+               Excep.all := GNAT_Occurrence.Occurrence;\n+            end if;\n             return GNAT_Occurrence.Occurrence'Access;\n          end;\n \n       else\n-         --  A default one\n+\n+         --  Foreign exception (caught by Ada handler, reaching here from\n+         --  personality routine) : The original exception object doesn't hold\n+         --  an Ada occurrence info.  Set the foreign data pointer in the\n+         --  Current Exception Buffer and return the address of the latter.\n \n          Set_Foreign_Occurrence (Excep, GCC_Exception.all'Address);\n \n@@ -312,7 +400,12 @@ package body Exception_Propagation is\n    procedure Propagate_GCC_Exception\n      (GCC_Exception : not null GCC_Exception_Access)\n    is\n-      Excep : EOA;\n+      --  Acknowledge the current exception info now, before unwinding\n+      --  starts so it is available even from C++ handlers involved before\n+      --  our personality routine.\n+\n+      Excep : constant EOA :=\n+        Setup_Current_Excep (GCC_Exception, Phase => 0);\n \n    begin\n       --  Perform a standard raise first. If a regular handler is found, it\n@@ -326,7 +419,6 @@ package body Exception_Propagation is\n       --  the necessary steps to enable the debugger to gain control while the\n       --  stack is still intact.\n \n-      Excep := Setup_Current_Excep (GCC_Exception);\n       Notify_Unhandled_Exception (Excep);\n \n       --  Now, un a forced unwind to trigger cleanups. Control should not\n@@ -392,7 +484,7 @@ package body Exception_Propagation is\n    is\n       Excep : EOA;\n    begin\n-      Excep := Setup_Current_Excep (GCC_Exception);\n+      Excep := Setup_Current_Excep (GCC_Exception, Phase => UA_CLEANUP_PHASE);\n       Unhandled_Exception_Terminate (Excep);\n    end Unhandled_Except_Handler;\n "}, {"sha": "b188046c40eb100a284c1558a71a161755f70fd9", "filename": "gcc/ada/libgnat/s-excmac__arm.ads", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/557b744a6e41a13dd44770dc64e19a34a32092c5/gcc%2Fada%2Flibgnat%2Fs-excmac__arm.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/557b744a6e41a13dd44770dc64e19a34a32092c5/gcc%2Fada%2Flibgnat%2Fs-excmac__arm.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-excmac__arm.ads?ref=557b744a6e41a13dd44770dc64e19a34a32092c5", "patch": "@@ -58,6 +58,7 @@ package System.Exceptions.Machine is\n       URC_INSTALL_CONTEXT,\n       URC_CONTINUE_UNWIND,\n       URC_FAILURE);\n+   pragma Convention (C, Unwind_Reason_Code);\n \n    pragma Unreferenced\n      (URC_OK,\n@@ -71,9 +72,7 @@ package System.Exceptions.Machine is\n       URC_CONTINUE_UNWIND,\n       URC_FAILURE);\n \n-   pragma Convention (C, Unwind_Reason_Code);\n-   subtype Unwind_Action is Unwind_Reason_Code;\n-   --  Phase identifiers\n+   --  ARM Unwinding State\n \n    type uint32_t is mod 2**32;\n    pragma Convention (C, uint32_t);"}, {"sha": "a828a0201280955511c7de105b076b48485a9a1c", "filename": "gcc/ada/libgnat/s-excmac__gcc.ads", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/557b744a6e41a13dd44770dc64e19a34a32092c5/gcc%2Fada%2Flibgnat%2Fs-excmac__gcc.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/557b744a6e41a13dd44770dc64e19a34a32092c5/gcc%2Fada%2Flibgnat%2Fs-excmac__gcc.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-excmac__gcc.ads?ref=557b744a6e41a13dd44770dc64e19a34a32092c5", "patch": "@@ -75,24 +75,6 @@ package System.Exceptions.Machine is\n \n    pragma Convention (C, Unwind_Reason_Code);\n \n-   --  Phase identifiers\n-\n-   type Unwind_Action is new Integer;\n-   pragma Convention (C, Unwind_Action);\n-\n-   UA_SEARCH_PHASE  : constant Unwind_Action := 1;\n-   UA_CLEANUP_PHASE : constant Unwind_Action := 2;\n-   UA_HANDLER_FRAME : constant Unwind_Action := 4;\n-   UA_FORCE_UNWIND  : constant Unwind_Action := 8;\n-   UA_END_OF_STACK  : constant Unwind_Action := 16;  --  GCC extension\n-\n-   pragma Unreferenced\n-     (UA_SEARCH_PHASE,\n-      UA_CLEANUP_PHASE,\n-      UA_HANDLER_FRAME,\n-      UA_FORCE_UNWIND,\n-      UA_END_OF_STACK);\n-\n    --  Mandatory common header for any exception object handled by the\n    --  GCC unwinding runtime.\n "}, {"sha": "5c2cc43bcb3cfd21f071cdf5b94e404d5cb4e563", "filename": "gcc/ada/raise-gcc.c", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/557b744a6e41a13dd44770dc64e19a34a32092c5/gcc%2Fada%2Fraise-gcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/557b744a6e41a13dd44770dc64e19a34a32092c5/gcc%2Fada%2Fraise-gcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fraise-gcc.c?ref=557b744a6e41a13dd44770dc64e19a34a32092c5", "patch": "@@ -106,8 +106,9 @@ __gnat_Unwind_RaiseException (_Unwind_Exception *);\n _Unwind_Reason_Code\n __gnat_Unwind_ForcedUnwind (_Unwind_Exception *, _Unwind_Stop_Fn, void *);\n \n-extern struct Exception_Occurrence *__gnat_setup_current_excep\n- (_Unwind_Exception *);\n+extern struct Exception_Occurrence *\n+__gnat_setup_current_excep (_Unwind_Exception *, _Unwind_Action);\n+\n extern void __gnat_unhandled_except_handler (_Unwind_Exception *);\n \n #ifdef CERT\n@@ -1220,12 +1221,14 @@ personality_body (_Unwind_Action uw_phases,\n       else\n \t{\n #ifndef CERT\n-\t  struct Exception_Occurrence *excep;\n-\n \t  /* Trigger the appropriate notification routines before the second\n-\t     phase starts, which ensures the stack is still intact.\n-             First, setup the Ada occurrence.  */\n-          excep = __gnat_setup_current_excep (uw_exception);\n+\t     phase starts, when the stack is still intact.  First install what\n+\t     needs to be installed in the current exception buffer and fetch\n+\t     the Ada occurrence pointer to use.  */\n+\n+\t  struct Exception_Occurrence *excep\n+\t    = __gnat_setup_current_excep (uw_exception, uw_phases);\n+\n \t  if (action.kind == unhandler)\n \t    __gnat_notify_unhandled_exception (excep);\n \t  else\n@@ -1245,10 +1248,10 @@ personality_body (_Unwind_Action uw_phases,\n     (uw_context, uw_exception, action.landing_pad, action.ttype_filter);\n \n #ifndef CERT\n-  /* Write current exception, so that it can be retrieved from Ada.  It was\n-     already done during phase 1 (just above), but in between, one or several\n-     exceptions may have been raised (in cleanup handlers).  */\n-  __gnat_setup_current_excep (uw_exception);\n+  /* Write current exception so that it can be retrieved from Ada.  It was\n+     already done during phase 1, but one or several exceptions may have been\n+     raised in cleanup handlers in between.  */\n+  __gnat_setup_current_excep (uw_exception, uw_phases);\n #endif\n \n   return _URC_INSTALL_CONTEXT;"}]}