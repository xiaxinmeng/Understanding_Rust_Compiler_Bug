{"sha": "31924665c86d47af6b1f22a74f594f2e1dc0ed2d", "node_id": "C_kwDOANBUbNoAKDMxOTI0NjY1Yzg2ZDQ3YWY2YjFmMjJhNzRmNTk0ZjJlMWRjMGVkMmQ", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2023-02-06T02:35:33Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2023-02-06T02:35:33Z"}, "message": "c++: equivalence of non-dependent calls [PR107461]\n\nAfter r13-5684-g59e0376f607805 the (pruned) callee of a non-dependent\nCALL_EXPR is a bare FUNCTION_DECL rather than ADDR_EXPR of FUNCTION_DECL.\nThis innocent change revealed that cp_tree_equal doesn't first check\ndependence of a CALL_EXPR before treating a FUNCTION_DECL callee as a\ndependent name, which leads to us incorrectly accepting the first two\ntestcases below and rejecting the third:\n\n * In the first testcase, cp_tree_equal incorrectly returns true for\n   the two non-dependent CALL_EXPRs f(0) and f(0) (whose CALL_EXPR_FN\n   are different FUNCTION_DECLs) which causes us to treat #2 as a\n   redeclaration of #1.\n\n * Same issue in the second testcase, for f<int*>() and f<char>().\n\n * In the third testcase, cp_tree_equal incorrectly returns true for\n   f<int>() and f<void(*)(int)>() which causes us to conflate the two\n   dependent specializations A<decltype(f<int>()(U()))> and\n   A<decltype(f<void(*)(int)>()(U()))>.\n\nThis patch fixes this by making called_fns_equal treat two callees as\ndependent names only if the overall CALL_EXPRs are dependent, via a new\nconvenience function call_expr_dependent_name that is like dependent_name\nbut also checks dependence of the overall CALL_EXPR.\n\n\tPR c++/107461\n\ngcc/cp/ChangeLog:\n\n\t* cp-tree.h (call_expr_dependent_name): Declare.\n\t* pt.cc (iterative_hash_template_arg) <case CALL_EXPR>: Use\n\tcall_expr_dependent_name instead of dependent_name.\n\t* tree.cc (call_expr_dependent_name): Define.\n\t(called_fns_equal): Adjust to take two CALL_EXPRs instead of\n\tCALL_EXPR_FNs thereof.  Use call_expr_dependent_name instead\n\tof dependent_name.\n\t(cp_tree_equal) <case CALL_EXPR>: Adjust call to called_fns_equal.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp0x/overload5.C: New test.\n\t* g++.dg/cpp0x/overload5a.C: New test.\n\t* g++.dg/cpp0x/overload6.C: New test.", "tree": {"sha": "2b92f40ff91d210b9a3e34b77d7097bc619a5fb5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2b92f40ff91d210b9a3e34b77d7097bc619a5fb5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/31924665c86d47af6b1f22a74f594f2e1dc0ed2d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31924665c86d47af6b1f22a74f594f2e1dc0ed2d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31924665c86d47af6b1f22a74f594f2e1dc0ed2d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31924665c86d47af6b1f22a74f594f2e1dc0ed2d/comments", "author": null, "committer": null, "parents": [{"sha": "e4421a770d42477736a6598ee2cf61c6c737cc37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4421a770d42477736a6598ee2cf61c6c737cc37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4421a770d42477736a6598ee2cf61c6c737cc37"}], "stats": {"total": 65, "additions": 59, "deletions": 6}, "files": [{"sha": "06bc64a6b8d4cfebd2c4aef0a5ae3d405433df5d", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31924665c86d47af6b1f22a74f594f2e1dc0ed2d/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31924665c86d47af6b1f22a74f594f2e1dc0ed2d/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=31924665c86d47af6b1f22a74f594f2e1dc0ed2d", "patch": "@@ -7902,6 +7902,7 @@ extern tree lookup_maybe_add\t\t\t(tree fns, tree lookup,\n extern int is_overloaded_fn\t\t\t(tree) ATTRIBUTE_PURE;\n extern bool really_overloaded_fn\t\t(tree) ATTRIBUTE_PURE;\n extern tree dependent_name\t\t\t(tree);\n+extern tree call_expr_dependent_name\t\t(tree);\n extern tree maybe_get_fns\t\t\t(tree) ATTRIBUTE_PURE;\n extern tree get_fns\t\t\t\t(tree) ATTRIBUTE_PURE;\n extern tree get_first_fn\t\t\t(tree) ATTRIBUTE_PURE;"}, {"sha": "e89dbf4709749158f87b370fa427c7c951858060", "filename": "gcc/cp/pt.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31924665c86d47af6b1f22a74f594f2e1dc0ed2d/gcc%2Fcp%2Fpt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31924665c86d47af6b1f22a74f594f2e1dc0ed2d/gcc%2Fcp%2Fpt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.cc?ref=31924665c86d47af6b1f22a74f594f2e1dc0ed2d", "patch": "@@ -1841,7 +1841,7 @@ iterative_hash_template_arg (tree arg, hashval_t val)\n     case CALL_EXPR:\n       {\n \ttree fn = CALL_EXPR_FN (arg);\n-\tif (tree name = dependent_name (fn))\n+\tif (tree name = call_expr_dependent_name (arg))\n \t  {\n \t    if (TREE_CODE (fn) == TEMPLATE_ID_EXPR)\n \t      val = iterative_hash_template_arg (TREE_OPERAND (fn, 1), val);"}, {"sha": "cd0dd963532ccbd8ac728ff980b3c12a6f52d943", "filename": "gcc/cp/tree.cc", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31924665c86d47af6b1f22a74f594f2e1dc0ed2d/gcc%2Fcp%2Ftree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31924665c86d47af6b1f22a74f594f2e1dc0ed2d/gcc%2Fcp%2Ftree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.cc?ref=31924665c86d47af6b1f22a74f594f2e1dc0ed2d", "patch": "@@ -2608,6 +2608,18 @@ dependent_name (tree x)\n   return NULL_TREE;\n }\n \n+/* Like dependent_name, but instead takes a CALL_EXPR and also checks\n+   its dependence.  */\n+\n+tree\n+call_expr_dependent_name (tree x)\n+{\n+  if (TREE_TYPE (x) != NULL_TREE)\n+    /* X isn't dependent, so its callee isn't a dependent name.  */\n+    return NULL_TREE;\n+  return dependent_name (CALL_EXPR_FN (x));\n+}\n+\n /* Returns true iff X is an expression for an overloaded function\n    whose type cannot be known without performing overload\n    resolution.  */\n@@ -3870,16 +3882,18 @@ decl_internal_context_p (const_tree decl)\n   return !TREE_PUBLIC (decl);\n }\n \n-/* Subroutine of cp_tree_equal: t1 and t2 are the CALL_EXPR_FNs of two\n-   CALL_EXPRS.  Return whether they are equivalent.  */\n+/* Subroutine of cp_tree_equal: t1 and t2 are two CALL_EXPRs.\n+   Return whether their CALL_EXPR_FNs are equivalent.  */\n \n static bool\n called_fns_equal (tree t1, tree t2)\n {\n   /* Core 1321: dependent names are equivalent even if the overload sets\n      are different.  But do compare explicit template arguments.  */\n-  tree name1 = dependent_name (t1);\n-  tree name2 = dependent_name (t2);\n+  tree name1 = call_expr_dependent_name (t1);\n+  tree name2 = call_expr_dependent_name (t2);\n+  t1 = CALL_EXPR_FN (t1);\n+  t2 = CALL_EXPR_FN (t2);\n   if (name1 || name2)\n     {\n       tree targs1 = NULL_TREE, targs2 = NULL_TREE;\n@@ -4037,7 +4051,7 @@ cp_tree_equal (tree t1, tree t2)\n \tif (KOENIG_LOOKUP_P (t1) != KOENIG_LOOKUP_P (t2))\n \t  return false;\n \n-\tif (!called_fns_equal (CALL_EXPR_FN (t1), CALL_EXPR_FN (t2)))\n+\tif (!called_fns_equal (t1, t2))\n \t  return false;\n \n \tcall_expr_arg_iterator iter1, iter2;"}, {"sha": "e05b1594f51aaaad61e0c48ab7c452d459b06f0a", "filename": "gcc/testsuite/g++.dg/cpp0x/overload5.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31924665c86d47af6b1f22a74f594f2e1dc0ed2d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Foverload5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31924665c86d47af6b1f22a74f594f2e1dc0ed2d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Foverload5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Foverload5.C?ref=31924665c86d47af6b1f22a74f594f2e1dc0ed2d", "patch": "@@ -0,0 +1,12 @@\n+// PR c++/107461\n+// { dg-do compile { target c++11 } }\n+\n+int f(...);\n+template<class T> decltype(T() + f(0)) g(); // #1\n+\n+char f(int);\n+template<class T> decltype(T() + f(0)) g(); // #2, distinct from #1\n+\n+int main() {\n+  g<int>(); // { dg-error \"ambiguous\" }\n+}"}, {"sha": "037114f199c6954cf9f45515537bbf9d1a32ad3d", "filename": "gcc/testsuite/g++.dg/cpp0x/overload5a.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31924665c86d47af6b1f22a74f594f2e1dc0ed2d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Foverload5a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31924665c86d47af6b1f22a74f594f2e1dc0ed2d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Foverload5a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Foverload5a.C?ref=31924665c86d47af6b1f22a74f594f2e1dc0ed2d", "patch": "@@ -0,0 +1,10 @@\n+// PR c++/107461\n+// { dg-do compile { target c++11 } }\n+\n+template<class T> T f();\n+template<class T> decltype(T() + f<int*>()) g(); // #1\n+template<class T> decltype(T() + f<char>()) g(); // #2, distinct from #1\n+\n+int main() {\n+  g<int>(); // { dg-error \"ambiguous\" }\n+}"}, {"sha": "1fbee0501de9f7f083142f299d82f7d694ab0c42", "filename": "gcc/testsuite/g++.dg/cpp0x/overload6.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31924665c86d47af6b1f22a74f594f2e1dc0ed2d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Foverload6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31924665c86d47af6b1f22a74f594f2e1dc0ed2d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Foverload6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Foverload6.C?ref=31924665c86d47af6b1f22a74f594f2e1dc0ed2d", "patch": "@@ -0,0 +1,16 @@\n+// PR c++/107461\n+// { dg-do compile { target c++11 } }\n+\n+template<class T> T f();\n+\n+template<class> struct A { };\n+\n+template<class T> struct B {\n+  template<class U, class = A<decltype(f<T>()(U()))>>\n+  static void g(U);\n+};\n+\n+int main() {\n+  B<int> b;\n+  B<void(*)(int)>::g(0); // { dg-bogus \"no match\" }\n+}"}]}