{"sha": "1feb8238582fa4ffe90e44934a9105cb3855e551", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWZlYjgyMzg1ODJmYTRmZmU5MGU0NDkzNGE5MTA1Y2IzODU1ZTU1MQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2010-03-08T13:33:31Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2010-03-08T13:33:31Z"}, "message": "var-tracking.c (remove_cselib_value_chains): Define only for ENABLE_CHECKING.\n\n\t* var-tracking.c (remove_cselib_value_chains): Define only for\n\tENABLE_CHECKING.\n\t(dataflow_set_preserve_mem_locs, dataflow_set_remove_mem_locs,\n\tdelete_slot_part, emit_notes_for_differences_1): Don't call\n\tremove_cselib_value_chains here.\n\t(set_slot_part, emit_notes_for_differences_2): Don't call\n\tadd_cselib_value_chains here.\n\t(preserved_values): New vector.\n\t(preserve_value): New function.\n\t(add_uses, add_stores, vt_add_function_parameters): Use it\n\tinstead of cselib_preserve_value.\n\t(changed_values_stack): New vector.\n\t(check_changed_vars_0): New function.\n\t(check_changed_vars_1, check_changed_vars_2): Use it.\n\t(emit_notes_for_changes): Call set_dv_changed (*, false) on all\n\tchanged_values_stack VALUEs.\n\t(vt_emit_notes): For all preserved_values call\n\tadd_cselib_value_chains.  If ENABLE_CHECKING call\n\tremove_cselib_value_chains before verifying value_chains is empty.\n\tInitialize and free changed_values_stack.\n\t(vt_initialize): Initialize preserved_values.\n\t(vt_finalize): Free preserved_values.\n\nFrom-SVN: r157277", "tree": {"sha": "73f40a27b1e1c9911bf31251366ccfed60436f1e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/73f40a27b1e1c9911bf31251366ccfed60436f1e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1feb8238582fa4ffe90e44934a9105cb3855e551", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1feb8238582fa4ffe90e44934a9105cb3855e551", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1feb8238582fa4ffe90e44934a9105cb3855e551", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1feb8238582fa4ffe90e44934a9105cb3855e551/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cc788fcc70a93b25b78cb72f31da3a2159930824", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc788fcc70a93b25b78cb72f31da3a2159930824", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc788fcc70a93b25b78cb72f31da3a2159930824"}], "stats": {"total": 175, "additions": 113, "deletions": 62}, "files": [{"sha": "67086f5965c3a91f75107d5486325cd085e0cbf7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1feb8238582fa4ffe90e44934a9105cb3855e551/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1feb8238582fa4ffe90e44934a9105cb3855e551/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1feb8238582fa4ffe90e44934a9105cb3855e551", "patch": "@@ -1,3 +1,28 @@\n+2010-03-08  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* var-tracking.c (remove_cselib_value_chains): Define only for\n+\tENABLE_CHECKING.\n+\t(dataflow_set_preserve_mem_locs, dataflow_set_remove_mem_locs,\n+\tdelete_slot_part, emit_notes_for_differences_1): Don't call\n+\tremove_cselib_value_chains here.\n+\t(set_slot_part, emit_notes_for_differences_2): Don't call\n+\tadd_cselib_value_chains here.\n+\t(preserved_values): New vector.\n+\t(preserve_value): New function.\n+\t(add_uses, add_stores, vt_add_function_parameters): Use it\n+\tinstead of cselib_preserve_value.\n+\t(changed_values_stack): New vector.\n+\t(check_changed_vars_0): New function.\n+\t(check_changed_vars_1, check_changed_vars_2): Use it.\n+\t(emit_notes_for_changes): Call set_dv_changed (*, false) on all\n+\tchanged_values_stack VALUEs.\n+\t(vt_emit_notes): For all preserved_values call\n+\tadd_cselib_value_chains.  If ENABLE_CHECKING call\n+\tremove_cselib_value_chains before verifying value_chains is empty.\n+\tInitialize and free changed_values_stack.\n+\t(vt_initialize): Initialize preserved_values.\n+\t(vt_finalize): Free preserved_values.\n+\n 2010-03-08  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/43269"}, {"sha": "0cd5dfc45aadfa0f1a4e1e93081e3182224a3e4e", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 88, "deletions": 62, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1feb8238582fa4ffe90e44934a9105cb3855e551/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1feb8238582fa4ffe90e44934a9105cb3855e551/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=1feb8238582fa4ffe90e44934a9105cb3855e551", "patch": "@@ -2674,6 +2674,7 @@ remove_value_chains (decl_or_value dv, rtx loc)\n   for_each_rtx (&loc, remove_value_chain, dv_as_opaque (dv));\n }\n \n+#if ENABLE_CHECKING\n /* If CSELIB_VAL_PTR of value DV refer to VALUEs, remove backlinks from those\n    VALUEs to DV.  */\n \n@@ -2686,7 +2687,6 @@ remove_cselib_value_chains (decl_or_value dv)\n     for_each_rtx (&l->loc, remove_value_chain, dv_as_opaque (dv));\n }\n \n-#if ENABLE_CHECKING\n /* Check the order of entries in one-part variables.   */\n \n static int\n@@ -3825,8 +3825,6 @@ dataflow_set_preserve_mem_locs (void **slot, void *data)\n       if (!var->var_part[0].loc_chain)\n \t{\n \t  var->n_var_parts--;\n-\t  if (emit_notes && dv_is_value_p (var->dv))\n-\t    remove_cselib_value_chains (var->dv);\n \t  changed = true;\n \t}\n       if (changed)\n@@ -3895,8 +3893,6 @@ dataflow_set_remove_mem_locs (void **slot, void *data)\n       if (!var->var_part[0].loc_chain)\n \t{\n \t  var->n_var_parts--;\n-\t  if (emit_notes && dv_is_value_p (var->dv))\n-\t    remove_cselib_value_chains (var->dv);\n \t  changed = true;\n \t}\n       if (changed)\n@@ -4654,6 +4650,20 @@ count_with_sets (rtx insn, struct cselib_set *sets, int n_sets)\n #define VAL_EXPR_HAS_REVERSE(x) \\\n   (RTL_FLAG_CHECK1 (\"VAL_EXPR_HAS_REVERSE\", (x), CONCAT)->return_val)\n \n+/* All preserved VALUEs.  */\n+static VEC (rtx, heap) *preserved_values;\n+\n+/* Ensure VAL is preserved and remember it in a vector for vt_emit_notes.\n+   This must be only called when cselib_preserve_only_values will be called\n+   with true, the counting phase must use cselib_preserve_value.  */\n+\n+static void\n+preserve_value (cselib_val *val)\n+{\n+  cselib_preserve_value (val);\n+  VEC_safe_push (rtx, heap, preserved_values, val->val_rtx);\n+}\n+\n /* Add uses (register and memory references) LOC which will be tracked\n    to VTI (bb)->mos.  INSN is instruction which the LOC is part of.  */\n \n@@ -4697,7 +4707,7 @@ add_uses (rtx *ploc, void *data)\n \t\t  mon->type = mo->type;\n \t\t  mon->u.loc = mo->u.loc;\n \t\t  mon->insn = mo->insn;\n-\t\t  cselib_preserve_value (val);\n+\t\t  preserve_value (val);\n \t\t  mo->type = MO_VAL_USE;\n \t\t  mloc = cselib_subst_to_values (XEXP (mloc, 0));\n \t\t  mo->u.loc = gen_rtx_CONCAT (address_mode,\n@@ -4733,7 +4743,7 @@ add_uses (rtx *ploc, void *data)\n \t\t  && !cselib_preserved_value_p (val))\n \t\t{\n \t\t  VAL_NEEDS_RESOLUTION (oloc) = 1;\n-\t\t  cselib_preserve_value (val);\n+\t\t  preserve_value (val);\n \t\t}\n \t    }\n \t  else if (!VAR_LOC_UNKNOWN_P (vloc))\n@@ -4768,7 +4778,7 @@ add_uses (rtx *ploc, void *data)\n \t\t  mon->type = mo->type;\n \t\t  mon->u.loc = mo->u.loc;\n \t\t  mon->insn = mo->insn;\n-\t\t  cselib_preserve_value (val);\n+\t\t  preserve_value (val);\n \t\t  mo->type = MO_VAL_USE;\n \t\t  mloc = cselib_subst_to_values (XEXP (mloc, 0));\n \t\t  mo->u.loc = gen_rtx_CONCAT (address_mode,\n@@ -4817,7 +4827,7 @@ add_uses (rtx *ploc, void *data)\n \t  if (!cselib_preserved_value_p (val))\n \t    {\n \t      VAL_NEEDS_RESOLUTION (mo->u.loc) = 1;\n-\t      cselib_preserve_value (val);\n+\t      preserve_value (val);\n \t    }\n \t}\n       else\n@@ -5000,7 +5010,7 @@ add_stores (rtx loc, const_rtx expr, void *cuip)\n \n \t  if (val && !cselib_preserved_value_p (val))\n \t    {\n-\t      cselib_preserve_value (val);\n+\t      preserve_value (val);\n \t      mo->type = MO_VAL_USE;\n \t      mloc = cselib_subst_to_values (XEXP (mloc, 0));\n \t      mo->u.loc = gen_rtx_CONCAT (address_mode, val->val_rtx, mloc);\n@@ -5073,7 +5083,7 @@ add_stores (rtx loc, const_rtx expr, void *cuip)\n \t{\n \t  micro_operation *nmo = VTI (bb)->mos + VTI (bb)->n_mos++;\n \n-\t  cselib_preserve_value (oval);\n+\t  preserve_value (oval);\n \n \t  nmo->type = MO_VAL_USE;\n \t  nmo->u.loc = gen_rtx_CONCAT (mode, oval->val_rtx, oloc);\n@@ -5161,7 +5171,7 @@ add_stores (rtx loc, const_rtx expr, void *cuip)\n   if (preserve)\n     {\n       VAL_NEEDS_RESOLUTION (loc) = resolve;\n-      cselib_preserve_value (v);\n+      preserve_value (v);\n     }\n   if (mo->type == MO_CLOBBER)\n     VAL_EXPR_IS_CLOBBERED (loc) = 1;\n@@ -6094,8 +6104,6 @@ set_slot_part (dataflow_set *set, rtx loc, void **slot,\n       *slot = var;\n       pos = 0;\n       nextp = &var->var_part[0].loc_chain;\n-      if (emit_notes && dv_is_value_p (dv))\n-\tadd_cselib_value_chains (dv);\n     }\n   else if (onepart)\n     {\n@@ -6483,11 +6491,7 @@ delete_slot_part (dataflow_set *set, rtx loc, void **slot,\n \t  changed = true;\n \t  var->n_var_parts--;\n \t  if (emit_notes)\n-\t    {\n-\t      var->cur_loc_changed = true;\n-\t      if (var->n_var_parts == 0 && dv_is_value_p (var->dv))\n-\t\tremove_cselib_value_chains (var->dv);\n-\t    }\n+\t    var->cur_loc_changed = true;\n \t  while (pos < var->n_var_parts)\n \t    {\n \t      var->var_part[pos] = var->var_part[pos + 1];\n@@ -6968,6 +6972,42 @@ DEF_VEC_ALLOC_P (variable, heap);\n \n static VEC (variable, heap) *changed_variables_stack;\n \n+/* VALUEs with no variables that need set_dv_changed (val, false)\n+   called before check_changed_vars_3.  */\n+\n+static VEC (rtx, heap) *changed_values_stack;\n+\n+/* Helper function for check_changed_vars_1 and check_changed_vars_2.  */\n+\n+static void\n+check_changed_vars_0 (decl_or_value dv, htab_t htab)\n+{\n+  value_chain vc\n+    = (value_chain) htab_find_with_hash (value_chains, dv, dv_htab_hash (dv));\n+\n+  if (vc == NULL)\n+    return;\n+  for (vc = vc->next; vc; vc = vc->next)\n+    if (!dv_changed_p (vc->dv))\n+      {\n+\tvariable vcvar\n+\t  = (variable) htab_find_with_hash (htab, vc->dv,\n+\t\t\t\t\t    dv_htab_hash (vc->dv));\n+\tif (vcvar)\n+\t  {\n+\t    set_dv_changed (vc->dv, true);\n+\t    VEC_safe_push (variable, heap, changed_variables_stack, vcvar);\n+\t  }\n+\telse if (dv_is_value_p (vc->dv))\n+\t  {\n+\t    set_dv_changed (vc->dv, true);\n+\t    VEC_safe_push (rtx, heap, changed_values_stack,\n+\t\t\t   dv_as_value (vc->dv));\n+\t    check_changed_vars_0 (vc->dv, htab);\n+\t  }\n+      }\n+}\n+\n /* Populate changed_variables_stack with variable_def pointers\n    that need variable_was_changed called on them.  */\n \n@@ -6979,24 +7019,7 @@ check_changed_vars_1 (void **slot, void *data)\n \n   if (dv_is_value_p (var->dv)\n       || TREE_CODE (dv_as_decl (var->dv)) == DEBUG_EXPR_DECL)\n-    {\n-      value_chain vc\n-\t= (value_chain) htab_find_with_hash (value_chains, var->dv,\n-\t\t\t\t\t     dv_htab_hash (var->dv));\n-\n-      if (vc == NULL)\n-\treturn 1;\n-      for (vc = vc->next; vc; vc = vc->next)\n-\tif (!dv_changed_p (vc->dv))\n-\t  {\n-\t    variable vcvar\n-\t      = (variable) htab_find_with_hash (htab, vc->dv,\n-\t\t\t\t\t\tdv_htab_hash (vc->dv));\n-\t    if (vcvar)\n-\t      VEC_safe_push (variable, heap, changed_variables_stack,\n-\t\t\t     vcvar);\n-\t  }\n-    }\n+    check_changed_vars_0 (var->dv, htab);\n   return 1;\n }\n \n@@ -7010,23 +7033,7 @@ check_changed_vars_2 (variable var, htab_t htab)\n   variable_was_changed (var, NULL);\n   if (dv_is_value_p (var->dv)\n       || TREE_CODE (dv_as_decl (var->dv)) == DEBUG_EXPR_DECL)\n-    {\n-      value_chain vc\n-\t= (value_chain) htab_find_with_hash (value_chains, var->dv,\n-\t\t\t\t\t     dv_htab_hash (var->dv));\n-\n-      if (vc == NULL)\n-\treturn;\n-      for (vc = vc->next; vc; vc = vc->next)\n-\tif (!dv_changed_p (vc->dv))\n-\t  {\n-\t    variable vcvar\n-\t      = (variable) htab_find_with_hash (htab, vc->dv,\n-\t\t\t\t\t\tdv_htab_hash (vc->dv));\n-\t    if (vcvar)\n-\t      check_changed_vars_2 (vcvar, htab);\n-\t  }\n-    }\n+    check_changed_vars_0 (var->dv, htab);\n }\n \n /* For each changed decl (except DEBUG_EXPR_DECLs) recompute\n@@ -7094,6 +7101,9 @@ emit_notes_for_changes (rtx insn, enum emit_note_where where,\n       while (VEC_length (variable, changed_variables_stack) > 0)\n \tcheck_changed_vars_2 (VEC_pop (variable, changed_variables_stack),\n \t\t\t      htab);\n+      while (VEC_length (rtx, changed_values_stack) > 0)\n+\tset_dv_changed (dv_from_value (VEC_pop (rtx, changed_values_stack)),\n+\t\t\tfalse);\n       htab_traverse (changed_variables, check_changed_vars_3, htab);\n     }\n \n@@ -7135,8 +7145,6 @@ emit_notes_for_differences_1 (void **slot, void *data)\n \t  gcc_assert (old_var->n_var_parts == 1);\n \t  for (lc = old_var->var_part[0].loc_chain; lc; lc = lc->next)\n \t    remove_value_chains (old_var->dv, lc->loc);\n-\t  if (dv_is_value_p (old_var->dv))\n-\t    remove_cselib_value_chains (old_var->dv);\n \t}\n       variable_was_changed (empty_var, NULL);\n       /* Continue traversing the hash table.  */\n@@ -7222,8 +7230,6 @@ emit_notes_for_differences_2 (void **slot, void *data)\n \t  gcc_assert (new_var->n_var_parts == 1);\n \t  for (lc = new_var->var_part[0].loc_chain; lc; lc = lc->next)\n \t    add_value_chains (new_var->dv, lc->loc);\n-\t  if (dv_is_value_p (new_var->dv))\n-\t    add_cselib_value_chains (new_var->dv);\n \t}\n       for (i = 0; i < new_var->n_var_parts; i++)\n \tnew_var->var_part[i].cur_loc = NULL;\n@@ -7546,7 +7552,15 @@ vt_emit_notes (void)\n   emit_notes = true;\n \n   if (MAY_HAVE_DEBUG_INSNS)\n-    changed_variables_stack = VEC_alloc (variable, heap, 40);\n+    {\n+      unsigned int i;\n+      rtx val;\n+\n+      for (i = 0; VEC_iterate (rtx, preserved_values, i, val); i++)\n+\tadd_cselib_value_chains (dv_from_value (val));\n+      changed_variables_stack = VEC_alloc (variable, heap, 40);\n+      changed_values_stack = VEC_alloc (rtx, heap, 40);\n+    }\n \n   dataflow_set_init (&cur);\n \n@@ -7568,12 +7582,22 @@ vt_emit_notes (void)\n \t\t emit_notes_for_differences_1,\n \t\t shared_hash_htab (empty_shared_hash));\n   if (MAY_HAVE_DEBUG_INSNS)\n-    gcc_assert (htab_elements (value_chains) == 0);\n+    {\n+      unsigned int i;\n+      rtx val;\n+\n+      for (i = 0; VEC_iterate (rtx, preserved_values, i, val); i++)\n+\tremove_cselib_value_chains (dv_from_value (val));\n+      gcc_assert (htab_elements (value_chains) == 0);\n+    }\n #endif\n   dataflow_set_destroy (&cur);\n \n   if (MAY_HAVE_DEBUG_INSNS)\n-    VEC_free (variable, heap, changed_variables_stack);\n+    {\n+      VEC_free (variable, heap, changed_variables_stack);\n+      VEC_free (rtx, heap, changed_values_stack);\n+    }\n \n #ifdef ENABLE_RTL_CHECKING\n   pointer_map_destroy (emitted_notes);\n@@ -7699,7 +7723,7 @@ vt_add_function_parameters (void)\n \t     cselib.  */\n \t  if (val)\n \t    {\n-\t      cselib_preserve_value (val);\n+\t      preserve_value (val);\n \t      set_variable_part (out, val->val_rtx, dv, offset,\n \t\t\t\t VAR_INIT_STATUS_INITIALIZED, NULL, INSERT);\n \t      dv = dv_from_value (val->val_rtx);\n@@ -7747,6 +7771,7 @@ vt_initialize (void)\n       scratch_regs = BITMAP_ALLOC (NULL);\n       valvar_pool = create_alloc_pool (\"small variable_def pool\",\n \t\t\t\t       sizeof (struct variable_def), 256);\n+      preserved_values = VEC_alloc (rtx, heap, 256);\n     }\n   else\n     {\n@@ -8023,6 +8048,7 @@ vt_finalize (void)\n       htab_delete (value_chains);\n       free_alloc_pool (value_chain_pool);\n       free_alloc_pool (valvar_pool);\n+      VEC_free (rtx, heap, preserved_values);\n       cselib_finish ();\n       BITMAP_FREE (scratch_regs);\n       scratch_regs = NULL;"}]}