{"sha": "1661473b7f96b42c272b8bf8945ece6b60a2d5b2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTY2MTQ3M2I3Zjk2YjQyYzI3MmI4YmY4OTQ1ZWNlNmI2MGEyZDViMg==", "commit": {"author": {"name": "Johannes Singler", "email": "singler@ira.uka.de", "date": "2007-11-28T17:38:49Z"}, "committer": {"name": "Johannes Singler", "email": "singler@gcc.gnu.org", "date": "2007-11-28T17:38:49Z"}, "message": "multiway_merge.h: Destruct only elements that were have been constructed before.\n\n2007-11-28  Johannes Singler  <singler@ira.uka.de>\n\n        * include/parallel/multiway_merge.h: Destruct only elements that\n        were have been constructed before. Code beautifying and formatting.\n        * include/parallel/losertree.h: (Copy) construct all loser tree\n        item keys, so they can be deconstructed all at once.\n        * include/parallel/quicksort.h: Fix memory leak.\n        * include/parallel/random_shuffle.h: Use copy constructor instead\n        of assignment. Code beautifying and formatting.\n        * include/parallel/unique_copy.h: Use assignment instead of copy\n        constructor.\n        * include/parallel/multiway_mergesort.h: Use copy constructor\n        instead of assignment. Code beautifying and formatting.\n        * include/parallel/random_shuffle.h: Use copy constructor instead\n        of assignment. Code beautifying.\n\nFrom-SVN: r130490", "tree": {"sha": "cb23e3e43eb7495f3a7ea038e5fdb64ef33ea416", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cb23e3e43eb7495f3a7ea038e5fdb64ef33ea416"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1661473b7f96b42c272b8bf8945ece6b60a2d5b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1661473b7f96b42c272b8bf8945ece6b60a2d5b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1661473b7f96b42c272b8bf8945ece6b60a2d5b2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1661473b7f96b42c272b8bf8945ece6b60a2d5b2/comments", "author": null, "committer": null, "parents": [{"sha": "87300e8c8102f83f8770da9a1d8758970bf28949", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87300e8c8102f83f8770da9a1d8758970bf28949", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87300e8c8102f83f8770da9a1d8758970bf28949"}], "stats": {"total": 515, "additions": 281, "deletions": 234}, "files": [{"sha": "a235f8c3cf50dbed20321d08818db0fff74d3a8b", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1661473b7f96b42c272b8bf8945ece6b60a2d5b2/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1661473b7f96b42c272b8bf8945ece6b60a2d5b2/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=1661473b7f96b42c272b8bf8945ece6b60a2d5b2", "patch": "@@ -1,3 +1,19 @@\n+2007-11-28  Johannes Singler  <singler@ira.uka.de>\n+\n+        * include/parallel/multiway_merge.h: Destruct only elements that \n+        were have been constructed before. Code beautifying and formatting.\n+        * include/parallel/losertree.h: (Copy) construct all loser tree \n+        item keys, so they can be deconstructed all at once.\n+        * include/parallel/quicksort.h: Fix memory leak.\n+        * include/parallel/random_shuffle.h: Use copy constructor instead \n+        of assignment. Code beautifying and formatting.\n+        * include/parallel/unique_copy.h: Use assignment instead of copy \n+        constructor.\n+        * include/parallel/multiway_mergesort.h: Use copy constructor \n+        instead of assignment. Code beautifying and formatting.\n+        * include/parallel/random_shuffle.h: Use copy constructor instead \n+        of assignment. Code beautifying.\n+\n 2007-11-27  Kaz Kojima  <kkojima@gcc.gnu.org>\n \n \t* testsuite/tr1/5_numerical_facilities/special_functions/"}, {"sha": "42cb54f2f503189026bec81b1182e848299bf036", "filename": "libstdc++-v3/include/parallel/losertree.h", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1661473b7f96b42c272b8bf8945ece6b60a2d5b2/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Flosertree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1661473b7f96b42c272b8bf8945ece6b60a2d5b2/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Flosertree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Flosertree.h?ref=1661473b7f96b42c272b8bf8945ece6b60a2d5b2", "patch": "@@ -230,6 +230,7 @@ template<typename T, typename Comparator = std::less<T> >\n     unsigned int ik, k, offset;\n     Loser* losers;\n     Comparator comp;\n+    bool first_insert;\n \n   public:\n     inline LoserTree(unsigned int _k, Comparator _comp = std::less<T>())\n@@ -240,9 +241,12 @@ template<typename T, typename Comparator = std::less<T> >\n       // Next greater power of 2.\n       k = 1 << (log2(ik - 1) + 1);\n       offset = k;\n-      losers = static_cast<Loser*>(::operator new(k * 2 * sizeof(Loser)));\n-      for (unsigned int i = ik - 1; i < k; i++)\n+      // Avoid default-constructing losers[].key\n+      losers = static_cast<Loser*>(::operator new(2 * k * sizeof(Loser)));\n+      for (unsigned int i = ik - 1; i < k; ++i)\n         losers[i + k].sup = true;\n+\n+      first_insert = true;\n     }\n \n     inline ~LoserTree()\n@@ -257,9 +261,18 @@ template<typename T, typename Comparator = std::less<T> >\n     {\n       unsigned int pos = k + source;\n \n+      if(first_insert)\n+        {\n+          // Construct all keys, so we can easily deconstruct them.\n+          for (unsigned int i = 0; i < (2 * k); ++i)\n+            new(&(losers[i].key)) T(key);\n+          first_insert = false;\n+        }\n+      else\n+        new(&(losers[pos].key)) T(key);\n+\n       losers[pos].sup = sup;\n       losers[pos].source = source;\n-      new(&(losers[pos].key)) T(key);\n     }\n \n     unsigned int\n@@ -282,7 +295,8 @@ template<typename T, typename Comparator = std::less<T> >\n               return left;\n             }\n           else\n-            {\t// Right one is less.\n+            {\n+              // Right one is less.\n               losers[root] = losers[left];\n               return right;\n             }"}, {"sha": "c1bf2518c36bb52b957f264330dce5f85152f3dd", "filename": "libstdc++-v3/include/parallel/multiway_merge.h", "status": "modified", "additions": 174, "deletions": 172, "changes": 346, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1661473b7f96b42c272b8bf8945ece6b60a2d5b2/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_merge.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1661473b7f96b42c272b8bf8945ece6b60a2d5b2/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_merge.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_merge.h?ref=1661473b7f96b42c272b8bf8945ece6b60a2d5b2", "patch": "@@ -57,7 +57,7 @@\n #endif\n \n /** @brief Length of a sequence described by a pair of iterators. */\n-#define LENGTH(s) ((s).second - (s).first)\n+#define _GLIBCXX_PARALLEL_LENGTH(s) ((s).second - (s).first)\n \n // XXX need iterator typedefs\n namespace __gnu_parallel\n@@ -204,7 +204,7 @@ template<typename RandomAccessIterator, typename Comparator>\n     inline  unguarded_iterator<RandomAccessIterator, Comparator>&\n     operator++()\n     {\n-      current++;\n+      ++current;\n       return *this;\n     }\n \n@@ -293,7 +293,7 @@ template<typename RandomAccessIteratorIterator, typename Comparator>\n     // Last element in sequence.\n     value_type min = *((*seqs_begin).second - 1);\n     min_sequence = 0;\n-    for (RandomAccessIteratorIterator s = seqs_begin + 1; s != seqs_end; s++)\n+    for (RandomAccessIteratorIterator s = seqs_begin + 1; s != seqs_end; ++s)\n       {\n         if ((*s).first == (*s).second)\n           {\n@@ -314,7 +314,7 @@ template<typename RandomAccessIteratorIterator, typename Comparator>\n     difference_type overhang_size = 0;\n \n     int s = 0;\n-    for (s = 0; s <= min_sequence; s++)\n+    for (s = 0; s <= min_sequence; ++s)\n       {\n         RandomAccessIterator1 split;\n         if (stable)\n@@ -327,7 +327,7 @@ template<typename RandomAccessIteratorIterator, typename Comparator>\n         overhang_size += seqs_begin[s].second - split;\n       }\n \n-    for (; s < (seqs_end - seqs_begin); s++)\n+    for (; s < (seqs_end - seqs_begin); ++s)\n       {\n         RandomAccessIterator1 split = std::lower_bound(\n             seqs_begin[s].first, seqs_begin[s].second, min, comp);\n@@ -363,7 +363,7 @@ template<typename RandomAccessIteratorIterator, typename Comparator>\n \n     // Last element in sequence.\n     value_type* max = NULL;\n-    for (RandomAccessIteratorIterator s = seqs_begin; s != seqs_end; s++)\n+    for (RandomAccessIteratorIterator s = seqs_begin; s != seqs_end; ++s)\n       {\n         if ((*s).first == (*s).second)\n           continue;\n@@ -377,7 +377,7 @@ template<typename RandomAccessIteratorIterator, typename Comparator>\n       }\n \n     difference_type overhang_size = 0;\n-    for (RandomAccessIteratorIterator s = seqs_begin; s != seqs_end; s++)\n+    for (RandomAccessIteratorIterator s = seqs_begin; s != seqs_end; ++s)\n       {\n         RandomAccessIterator1 split =\n             std::lower_bound((*s).first, (*s).second, *max, comp);\n@@ -453,25 +453,25 @@ template<\n           goto s210;\n       }\n \n-#define Merge3Case(a,b,c,c0,c1)\t\t\t\t\\\n-    s ## a ## b ## c :\t\t\t\t\t\\\n-      *target = *seq ## a;\t\t\t\t\\\n-    ++target;\t\t\t\t\t\t\\\n-    length--;\t\t\t\t\t\t\\\n-    ++seq ## a;\t\t\t\t\t\t\\\n-    if (length == 0) goto finish;\t\t\t\\\n-    if (seq ## a c0 seq ## b) goto s ## a ## b ## c;\t\\\n-    if (seq ## a c1 seq ## c) goto s ## b ## a ## c;\t\\\n+#define _GLIBCXX_PARALLEL_MERGE_3_CASE(a,b,c,c0,c1)\\\n+    s ## a ## b ## c :                                  \\\n+      *target = *seq ## a;                              \\\n+    ++target;                                           \\\n+    --length;                                           \\\n+    ++seq ## a;                                         \\\n+    if (length == 0) goto finish;                       \\\n+    if (seq ## a c0 seq ## b) goto s ## a ## b ## c;    \\\n+    if (seq ## a c1 seq ## c) goto s ## b ## a ## c;    \\\n     goto s ## b ## c ## a;\n \n-    Merge3Case(0, 1, 2, <=, <=);\n-    Merge3Case(1, 2, 0, <=, < );\n-    Merge3Case(2, 0, 1, < , < );\n-    Merge3Case(1, 0, 2, < , <=);\n-    Merge3Case(0, 2, 1, <=, <=);\n-    Merge3Case(2, 1, 0, < , < );\n+    _GLIBCXX_PARALLEL_MERGE_3_CASE(0, 1, 2, <=, <=);\n+    _GLIBCXX_PARALLEL_MERGE_3_CASE(1, 2, 0, <=, < );\n+    _GLIBCXX_PARALLEL_MERGE_3_CASE(2, 0, 1, < , < );\n+    _GLIBCXX_PARALLEL_MERGE_3_CASE(1, 0, 2, < , <=);\n+    _GLIBCXX_PARALLEL_MERGE_3_CASE(0, 2, 1, <=, <=);\n+    _GLIBCXX_PARALLEL_MERGE_3_CASE(2, 1, 0, < , < );\n \n-#undef Merge3Case\n+#undef _GLIBCXX_PARALLEL_MERGE_3_CASE\n \n   finish:\n     ;\n@@ -513,7 +513,7 @@ template<\n \n     difference_type total_length = 0;\n     for (RandomAccessIteratorIterator s = seqs_begin; s != seqs_end; ++s)\n-      total_length += LENGTH(*s);\n+      total_length += _GLIBCXX_PARALLEL_LENGTH(*s);\n \n     if (overhang != -1)\n       {\n@@ -600,7 +600,7 @@ template<\n       seq2(seqs_begin[2].first, seqs_begin[2].second, comp),\n       seq3(seqs_begin[3].first, seqs_begin[3].second, comp);\n \n-#define Decision(a,b,c,d) {\t\t\t\t\t\\\n+#define _GLIBCXX_PARALLEL_DECISION(a,b,c,d) {                   \\\n       if (seq ## d < seq ## a) goto s ## d ## a ## b ## c;\t\\\n       if (seq ## d < seq ## b) goto s ## a ## d ## b ## c;\t\\\n       if (seq ## d < seq ## c) goto s ## a ## b ## d ## c;\t\\\n@@ -609,65 +609,65 @@ template<\n     if (seq0 <= seq1)\n       {\n         if (seq1 <= seq2)\n-          Decision(0,1,2,3)\n+          _GLIBCXX_PARALLEL_DECISION(0,1,2,3)\n           else\n             if (seq2 < seq0)\n-              Decision(2,0,1,3)\n+              _GLIBCXX_PARALLEL_DECISION(2,0,1,3)\n               else\n-                Decision(0,2,1,3)\n+                _GLIBCXX_PARALLEL_DECISION(0,2,1,3)\n                   }\n     else\n       {\n         if (seq1 <= seq2)\n           {\n             if (seq0 <= seq2)\n-              Decision(1,0,2,3)\n+              _GLIBCXX_PARALLEL_DECISION(1,0,2,3)\n               else\n-                Decision(1,2,0,3)\n+                _GLIBCXX_PARALLEL_DECISION(1,2,0,3)\n                   }\n         else\n-          Decision(2,1,0,3)\n+          _GLIBCXX_PARALLEL_DECISION(2,1,0,3)\n             }\n \n-#define Merge4Case(a,b,c,d,c0,c1,c2)\t\t\t\t\\\n-    s ## a ## b ## c ## d:\t\t\t\t\t\\\n-      if (length == 0) goto finish;\t\t\t\t\\\n-    *target = *seq ## a;\t\t\t\t\t\\\n-    ++target;\t\t\t\t\t\t\t\\\n-    length--;\t\t\t\t\t\t\t\\\n-    ++seq ## a;\t\t\t\t\t\t\t\\\n-    if (seq ## a c0 seq ## b) goto s ## a ## b ## c ## d;\t\\\n-    if (seq ## a c1 seq ## c) goto s ## b ## a ## c ## d;\t\\\n-    if (seq ## a c2 seq ## d) goto s ## b ## c ## a ## d;\t\\\n+#define _GLIBCXX_PARALLEL_MERGE_4_CASE(a,b,c,d,c0,c1,c2)        \\\n+    s ## a ## b ## c ## d:                                      \\\n+      if (length == 0) goto finish;                             \\\n+    *target = *seq ## a;                                        \\\n+    ++target;                                                   \\\n+    --length;                                                   \\\n+    ++seq ## a;                                                 \\\n+    if (seq ## a c0 seq ## b) goto s ## a ## b ## c ## d;       \\\n+    if (seq ## a c1 seq ## c) goto s ## b ## a ## c ## d;       \\\n+    if (seq ## a c2 seq ## d) goto s ## b ## c ## a ## d;       \\\n     goto s ## b ## c ## d ## a;\n \n-    Merge4Case(0, 1, 2, 3, <=, <=, <=);\n-    Merge4Case(0, 1, 3, 2, <=, <=, <=);\n-    Merge4Case(0, 2, 1, 3, <=, <=, <=);\n-    Merge4Case(0, 2, 3, 1, <=, <=, <=);\n-    Merge4Case(0, 3, 1, 2, <=, <=, <=);\n-    Merge4Case(0, 3, 2, 1, <=, <=, <=);\n-    Merge4Case(1, 0, 2, 3, < , <=, <=);\n-    Merge4Case(1, 0, 3, 2, < , <=, <=);\n-    Merge4Case(1, 2, 0, 3, <=, < , <=);\n-    Merge4Case(1, 2, 3, 0, <=, <=, < );\n-    Merge4Case(1, 3, 0, 2, <=, < , <=);\n-    Merge4Case(1, 3, 2, 0, <=, <=, < );\n-    Merge4Case(2, 0, 1, 3, < , < , <=);\n-    Merge4Case(2, 0, 3, 1, < , <=, < );\n-    Merge4Case(2, 1, 0, 3, < , < , <=);\n-    Merge4Case(2, 1, 3, 0, < , <=, < );\n-    Merge4Case(2, 3, 0, 1, <=, < , < );\n-    Merge4Case(2, 3, 1, 0, <=, < , < );\n-    Merge4Case(3, 0, 1, 2, < , < , < );\n-    Merge4Case(3, 0, 2, 1, < , < , < );\n-    Merge4Case(3, 1, 0, 2, < , < , < );\n-    Merge4Case(3, 1, 2, 0, < , < , < );\n-    Merge4Case(3, 2, 0, 1, < , < , < );\n-    Merge4Case(3, 2, 1, 0, < , < , < );\n-\n-#undef Merge4Case\n-#undef Decision\n+    _GLIBCXX_PARALLEL_MERGE_4_CASE(0, 1, 2, 3, <=, <=, <=);\n+    _GLIBCXX_PARALLEL_MERGE_4_CASE(0, 1, 3, 2, <=, <=, <=);\n+    _GLIBCXX_PARALLEL_MERGE_4_CASE(0, 2, 1, 3, <=, <=, <=);\n+    _GLIBCXX_PARALLEL_MERGE_4_CASE(0, 2, 3, 1, <=, <=, <=);\n+    _GLIBCXX_PARALLEL_MERGE_4_CASE(0, 3, 1, 2, <=, <=, <=);\n+    _GLIBCXX_PARALLEL_MERGE_4_CASE(0, 3, 2, 1, <=, <=, <=);\n+    _GLIBCXX_PARALLEL_MERGE_4_CASE(1, 0, 2, 3, < , <=, <=);\n+    _GLIBCXX_PARALLEL_MERGE_4_CASE(1, 0, 3, 2, < , <=, <=);\n+    _GLIBCXX_PARALLEL_MERGE_4_CASE(1, 2, 0, 3, <=, < , <=);\n+    _GLIBCXX_PARALLEL_MERGE_4_CASE(1, 2, 3, 0, <=, <=, < );\n+    _GLIBCXX_PARALLEL_MERGE_4_CASE(1, 3, 0, 2, <=, < , <=);\n+    _GLIBCXX_PARALLEL_MERGE_4_CASE(1, 3, 2, 0, <=, <=, < );\n+    _GLIBCXX_PARALLEL_MERGE_4_CASE(2, 0, 1, 3, < , < , <=);\n+    _GLIBCXX_PARALLEL_MERGE_4_CASE(2, 0, 3, 1, < , <=, < );\n+    _GLIBCXX_PARALLEL_MERGE_4_CASE(2, 1, 0, 3, < , < , <=);\n+    _GLIBCXX_PARALLEL_MERGE_4_CASE(2, 1, 3, 0, < , <=, < );\n+    _GLIBCXX_PARALLEL_MERGE_4_CASE(2, 3, 0, 1, <=, < , < );\n+    _GLIBCXX_PARALLEL_MERGE_4_CASE(2, 3, 1, 0, <=, < , < );\n+    _GLIBCXX_PARALLEL_MERGE_4_CASE(3, 0, 1, 2, < , < , < );\n+    _GLIBCXX_PARALLEL_MERGE_4_CASE(3, 0, 2, 1, < , < , < );\n+    _GLIBCXX_PARALLEL_MERGE_4_CASE(3, 1, 0, 2, < , < , < );\n+    _GLIBCXX_PARALLEL_MERGE_4_CASE(3, 1, 2, 0, < , < , < );\n+    _GLIBCXX_PARALLEL_MERGE_4_CASE(3, 2, 0, 1, < , < , < );\n+    _GLIBCXX_PARALLEL_MERGE_4_CASE(3, 2, 1, 0, < , < , < );\n+\n+#undef _GLIBCXX_PARALLEL_MERGE_4_CASE\n+#undef _GLIBCXX_PARALLEL_DECISION\n \n   finish:\n     ;\n@@ -710,7 +710,7 @@ template<\n \n     difference_type total_length = 0;\n     for (RandomAccessIteratorIterator s = seqs_begin; s != seqs_end; ++s)\n-      total_length += LENGTH(*s);\n+      total_length += _GLIBCXX_PARALLEL_LENGTH(*s);\n \n     if (overhang != -1)\n       {\n@@ -785,48 +785,47 @@ template<\n     typedef typename std::iterator_traits<RandomAccessIterator1>::value_type\n       value_type;\n \n-    // Num remaining pieces.\n-    int k = static_cast<int>(seqs_end - seqs_begin), nrp;\n+    int k = static_cast<int>(seqs_end - seqs_begin);\n+    int nrs;  // Number of remaining sequences.\n \n-    value_type* pl = static_cast<value_type*>(\n-      ::operator new(sizeof(value_type) * k));\n+    // Avoid default constructor.\n+    value_type* fe = static_cast<value_type*>(\n+      ::operator new(sizeof(value_type) * k));  // Front elements.\n     int* source = new int[k];\n     difference_type total_length = 0;\n \n-#define POS(i) seqs_begin[(i)].first\n-#define STOPS(i) seqs_begin[(i)].second\n-\n     // Write entries into queue.\n-    nrp = 0;\n-    for (int pi = 0; pi < k; pi++)\n+    nrs = 0;\n+    for (int pi = 0; pi < k; ++pi)\n       {\n-        if (STOPS(pi) != POS(pi))\n+        if (seqs_begin[pi].first != seqs_begin[pi].second)\n           {\n-            pl[nrp] = *(POS(pi));\n-            source[nrp] = pi;\n-            nrp++;\n-            total_length += LENGTH(seqs_begin[pi]);\n+            new(&(fe[nrs])) value_type(*(seqs_begin[pi].first));\n+            source[nrs] = pi;\n+            ++nrs;\n+            total_length += _GLIBCXX_PARALLEL_LENGTH(seqs_begin[pi]);\n           }\n       }\n \n     if (stable)\n       {\n-        for (int k = 0; k < nrp - 1; k++)\n-          for (int pi = nrp - 1; pi > k; pi--)\n-            if (comp(pl[pi], pl[pi - 1]) ||\n-                (!comp(pl[pi - 1], pl[pi]) && source[pi] < source[pi - 1]))\n+        // Bubble sort fe and source by fe.\n+        for (int k = 0; k < nrs - 1; ++k)\n+          for (int pi = nrs - 1; pi > k; --pi)\n+            if (comp(fe[pi], fe[pi - 1]) ||\n+                (!comp(fe[pi - 1], fe[pi]) && source[pi] < source[pi - 1]))\n               {\n-                std::swap(pl[pi - 1], pl[pi]);\n+                std::swap(fe[pi - 1], fe[pi]);\n                 std::swap(source[pi - 1], source[pi]);\n               }\n       }\n     else\n       {\n-        for (int k = 0; k < nrp - 1; k++)\n-          for (int pi = nrp - 1; pi > k; pi--)\n-            if (comp(pl[pi], pl[pi-1]))\n+        for (int k = 0; k < nrs - 1; ++k)\n+          for (int pi = nrs - 1; pi > k; --pi)\n+            if (comp(fe[pi], fe[pi-1]))\n               {\n-                std::swap(pl[pi-1], pl[pi]);\n+                std::swap(fe[pi-1], fe[pi]);\n                 std::swap(source[pi-1], source[pi]);\n               }\n       }\n@@ -835,106 +834,109 @@ template<\n     if (stable)\n       {\n         int j;\n-        while (nrp > 0 && length > 0)\n+        while (nrs > 0 && length > 0)\n           {\n             if (source[0] < source[1])\n               {\n-                // pl[0] <= pl[1]\n-                while ((nrp == 1 || !(comp(pl[1], pl[0]))) && length > 0)\n+                // fe[0] <= fe[1]\n+                while ((nrs == 1 || !comp(fe[1], fe[0])) && length > 0)\n                   {\n-                    *target = pl[0];\n+                    *target = fe[0];\n                     ++target;\n-                    ++POS(source[0]);\n-                    length--;\n-                    if (POS(source[0]) == STOPS(source[0]))\n+                    ++(seqs_begin[source[0]].first);\n+                    --length;\n+                    if (seqs_begin[source[0]].first == seqs_begin[source[0]].second)\n                       {\n                         // Move everything to the left.\n-                        for (int s = 0; s < nrp - 1; s++)\n+                        for (int s = 0; s < nrs - 1; ++s)\n                           {\n-                            pl[s] = pl[s + 1];\n+                            fe[s] = fe[s + 1];\n                             source[s] = source[s + 1];\n                           }\n-                        nrp--;\n+                        fe[nrs - 1].~value_type();  //Destruct explicitly.\n+                        --nrs;\n                         break;\n                       }\n                     else\n-                      pl[0] = *(POS(source[0]));\n+                      fe[0] = *(seqs_begin[source[0]].first);\n                   }\n               }\n             else\n               {\n-                // pl[0] < pl[1]\n-                while ((nrp == 1 || comp(pl[0], pl[1])) && length > 0)\n+                // fe[0] < fe[1]\n+                while ((nrs == 1 || comp(fe[0], fe[1])) && length > 0)\n                   {\n-                    *target = pl[0];\n+                    *target = fe[0];\n                     ++target;\n-                    ++POS(source[0]);\n-                    length--;\n-                    if (POS(source[0]) == STOPS(source[0]))\n+                    ++(seqs_begin[source[0]].first);\n+                    --length;\n+                    if (seqs_begin[source[0]].first == seqs_begin[source[0]].second)\n                       {\n-                        for (int s = 0; s < nrp - 1; s++)\n+                        for (int s = 0; s < nrs - 1; ++s)\n                           {\n-                            pl[s] = pl[s + 1];\n+                            fe[s] = fe[s + 1];\n                             source[s] = source[s + 1];\n                           }\n-                        nrp--;\n+                        fe[nrs - 1].~value_type();  //Destruct explicitly.\n+                        --nrs;\n                         break;\n                       }\n                     else\n-                      pl[0] = *(POS(source[0]));\n+                      fe[0] = *(seqs_begin[source[0]].first);\n                   }\n               }\n \n             // Sink down.\n             j = 1;\n-            while ((j < nrp) && (comp(pl[j], pl[j - 1]) ||\n-                                (!comp(pl[j - 1], pl[j])\n+            while ((j < nrs) && (comp(fe[j], fe[j - 1]) ||\n+                                (!comp(fe[j - 1], fe[j])\n                                     && (source[j] < source[j - 1]))))\n               {\n-                std::swap(pl[j - 1], pl[j]);\n+                std::swap(fe[j - 1], fe[j]);\n                 std::swap(source[j - 1], source[j]);\n-                j++;\n+                ++j;\n               }\n           }\n       }\n     else\n       {\n         int j;\n-        while (nrp > 0 && length > 0)\n+        while (nrs > 0 && length > 0)\n           {\n-            // pl[0] <= pl[1]\n-            while (nrp == 1 || (!comp(pl[1], pl[0])) && length > 0)\n+            // fe[0] <= fe[1]\n+            while (nrs == 1 || (!comp(fe[1], fe[0])) && length > 0)\n               {\n-                *target = pl[0];\n+                *target = fe[0];\n                 ++target;\n-                ++POS(source[0]);\n-                length--;\n-                if (POS(source[0]) == STOPS(source[0]))\n+                ++seqs_begin[source[0]].first;\n+                --length;\n+                if (seqs_begin[source[0]].first == seqs_begin[source[0]].second)\n                   {\n-                    for (int s = 0; s < (nrp - 1); s++)\n+                    for (int s = 0; s < (nrs - 1); ++s)\n                       {\n-                        pl[s] = pl[s + 1];\n+                        fe[s] = fe[s + 1];\n                         source[s] = source[s + 1];\n                       }\n-                    nrp--;\n+                    fe[nrs - 1].~value_type();  //Destruct explicitly.\n+                    --nrs;\n                     break;\n                   }\n                 else\n-                  pl[0] = *(POS(source[0]));\n+                  fe[0] = *(seqs_begin[source[0]].first);\n               }\n \n             // Sink down.\n             j = 1;\n-            while ((j < nrp) && comp(pl[j], pl[j - 1]))\n+            while ((j < nrs) && comp(fe[j], fe[j - 1]))\n               {\n-                std::swap(pl[j - 1], pl[j]);\n+                std::swap(fe[j - 1], fe[j]);\n                 std::swap(source[j - 1], source[j]);\n-                j++;\n+                ++j;\n               }\n           }\n       }\n \n-    delete[] pl;\n+    delete fe;  //Destructors already called.\n     delete[] source;\n \n     return target;\n@@ -983,17 +985,17 @@ template<\n     // Default value for potentially non-default-constructible types.\n     value_type* arbitrary_element = NULL;\n \n-    for (int t = 0; t < k; t++)\n+    for (int t = 0; t < k; ++t)\n       {\n-        if(arbitrary_element == NULL && LENGTH(seqs_begin[t]) > 0)\n+        if(arbitrary_element == NULL && _GLIBCXX_PARALLEL_LENGTH(seqs_begin[t]) > 0)\n           arbitrary_element = &(*seqs_begin[t].first);\n-        total_length += LENGTH(seqs_begin[t]);\n+        total_length += _GLIBCXX_PARALLEL_LENGTH(seqs_begin[t]);\n       }\n \n     if(total_length == 0)\n       return target;\n \n-    for (int t = 0; t < k; t++)\n+    for (int t = 0; t < k; ++t)\n       {\n         if (stable)\n           {\n@@ -1022,7 +1024,7 @@ template<\n \n     if (stable)\n       {\n-        for (difference_type i = 0; i < total_length; i++)\n+        for (difference_type i = 0; i < total_length; ++i)\n           {\n             // Take out.\n             source = lt.get_min_source();\n@@ -1040,7 +1042,7 @@ template<\n       }\n     else\n       {\n-        for (difference_type i = 0; i < total_length; i++)\n+        for (difference_type i = 0; i < total_length; ++i)\n           {\n             //take out\n             source = lt.get_min_source();\n@@ -1099,7 +1101,7 @@ template<\n \n     difference_type total_length = 0;\n \n-    for (int t = 0; t < k; t++)\n+    for (int t = 0; t < k; ++t)\n       {\n #if _GLIBCXX_ASSERTIONS\n         _GLIBCXX_PARALLEL_ASSERT(seqs_begin[t].first != seqs_begin[t].second);\n@@ -1109,7 +1111,7 @@ template<\n         else\n           lt.insert_start(*seqs_begin[t].first, t, false);\n \n-        total_length += LENGTH(seqs_begin[t]);\n+        total_length += _GLIBCXX_PARALLEL_LENGTH(seqs_begin[t]);\n       }\n \n     if (stable)\n@@ -1145,7 +1147,7 @@ template<\n             _GLIBCXX_PARALLEL_ASSERT(\n                 (seqs_begin[source].first != seqs_begin[source].second)\n                 || (i == length - 1));\n-            i++;\n+            ++i;\n #endif\n             // Feed.\n             // Replace from same source.\n@@ -1177,7 +1179,7 @@ template<\n             _GLIBCXX_PARALLEL_ASSERT(\n                 (seqs_begin[source].first != seqs_begin[source].second)\n                 || (i >= length - 1));\n-            i++;\n+            ++i;\n #endif\n             // Feed.\n             // Replace from same source.\n@@ -1216,8 +1218,8 @@ template<\n                                           comp, min_seq, stable);\n \n     difference_type total_length = 0;\n-    for (RandomAccessIteratorIterator s = seqs_begin; s != seqs_end; s++)\n-      total_length += LENGTH(*s);\n+    for (RandomAccessIteratorIterator s = seqs_begin; s != seqs_end; ++s)\n+      total_length += _GLIBCXX_PARALLEL_LENGTH(*s);\n \n     if (overhang != -1)\n       {\n@@ -1279,12 +1281,12 @@ template<\n         prepare_unguarded_sentinel(seqs_begin, seqs_end, comp);\n \n     difference_type total_length = 0;\n-    for (RandomAccessIteratorIterator s = seqs_begin; s != seqs_end; s++)\n+    for (RandomAccessIteratorIterator s = seqs_begin; s != seqs_end; ++s)\n       {\n-        total_length += LENGTH(*s);\n+        total_length += _GLIBCXX_PARALLEL_LENGTH(*s);\n \n         // Sentinel spot.\n-        (*s).second++;\n+        ++((*s).second);\n       }\n \n     difference_type unguarded_length =\n@@ -1301,12 +1303,12 @@ template<\n \n     // Copy rest stable.\n     for (RandomAccessIteratorIterator s = seqs_begin;\n-         s != seqs_end && overhang > 0; s++)\n+         s != seqs_end && overhang > 0; ++s)\n       {\n         // Restore.\n-        (*s).second--;\n+        --((*s).second);\n         difference_type local_length =\n-            std::min<difference_type>(overhang, LENGTH(*s));\n+            std::min<difference_type>(overhang, _GLIBCXX_PARALLEL_LENGTH(*s));\n         target_end = std::copy((*s).first, (*s).first + local_length,\n                                target_end);\n         (*s).first += local_length;\n@@ -1324,7 +1326,7 @@ template<\n \n /** @brief Sequential multi-way merging switch.\n  *\n- *  The decision if based on the branching factor and runtime settings.\n+ *  The _GLIBCXX_PARALLEL_DECISION if based on the branching factor and runtime settings.\n  *  @param seqs_begin Begin iterator of iterator pair input sequence.\n  *  @param seqs_end End iterator of iterator pair input sequence.\n  *  @param target Begin iterator out output sequence.\n@@ -1356,7 +1358,7 @@ template<\n       value_type;\n \n #if _GLIBCXX_ASSERTIONS\n-    for (RandomAccessIteratorIterator s = seqs_begin; s != seqs_end; s++)\n+    for (RandomAccessIteratorIterator s = seqs_begin; s != seqs_end; ++s)\n       _GLIBCXX_PARALLEL_ASSERT(is_sorted((*s).first, (*s).second, comp));\n #endif\n \n@@ -1502,7 +1504,7 @@ template<\n \n /** @brief Parallel multi-way merge routine.\n  *\n- *  The decision if based on the branching factor and runtime settings.\n+ *  The _GLIBCXX_PARALLEL_DECISION if based on the branching factor and runtime settings.\n  *  @param seqs_begin Begin iterator of iterator pair input sequence.\n  *  @param seqs_end End iterator of iterator pair input sequence.\n  *  @param target Begin iterator out output sequence.\n@@ -1538,8 +1540,8 @@ template<\n \n       difference_type total_length = 0;\n       for (RandomAccessIteratorIterator raii = seqs_begin;\n-           raii != seqs_end; raii++)\n-        total_length += LENGTH(*raii);\n+           raii != seqs_end; ++raii)\n+        total_length += _GLIBCXX_PARALLEL_LENGTH(*raii);\n \n       _GLIBCXX_CALL(total_length)\n \n@@ -1561,7 +1563,7 @@ template<\n               // Thread t will have to merge pieces[iam][0..k - 1]\n               pieces = new std::vector<\n                   std::pair<difference_type, difference_type> >[num_threads];\n-              for (int s = 0; s < num_threads; s++)\n+              for (int s = 0; s < num_threads; ++s)\n                 pieces[s].resize(k);\n \n               difference_type num_samples =\n@@ -1572,16 +1574,16 @@ template<\n                   value_type* samples = static_cast<value_type*>(\n                     ::operator new(sizeof(value_type) * k * num_samples));\n                   // Sample.\n-                  for (int s = 0; s < k; s++)\n-                    for (int i = 0; (difference_type)i < num_samples; i++)\n+                  for (int s = 0; s < k; ++s)\n+                    for (difference_type i = 0; i < num_samples; ++i)\n                       {\n                         difference_type sample_index =\n                             static_cast<difference_type>(\n-                                LENGTH(seqs_begin[s]) * (double(i + 1) /\n+                                _GLIBCXX_PARALLEL_LENGTH(seqs_begin[s]) * (double(i + 1) /\n                                 (num_samples + 1)) * (double(length)\n                                 / total_length));\n-                        samples[s * num_samples + i] =\n-                            seqs_begin[s].first[sample_index];\n+                        new(&(samples[s * num_samples + i])) value_type(\n+                            seqs_begin[s].first[sample_index]);\n                       }\n \n                   if (stable)\n@@ -1591,9 +1593,9 @@ template<\n                     __gnu_sequential::sort(\n                       samples, samples + (num_samples * k), comp);\n \n-                  for (int slab = 0; slab < num_threads; slab++)\n+                  for (int slab = 0; slab < num_threads; ++slab)\n                     // For each slab / processor.\n-                    for (int seq = 0; seq < k; seq++)\n+                    for (int seq = 0; seq < k; ++seq)\n                       {\n                         // For each sequence.\n                         if (slab > 0)\n@@ -1618,7 +1620,7 @@ template<\n                                       num_threads], comp)\n                               - seqs_begin[seq].first;\n                         else\n-                        pieces[slab][seq].second = LENGTH(seqs_begin[seq]);\n+                        pieces[slab][seq].second = _GLIBCXX_PARALLEL_LENGTH(seqs_begin[seq]);\n                       }\n                     delete[] samples;\n                 }\n@@ -1637,7 +1639,7 @@ template<\n                       new difference_type[num_threads + 1];\n                   equally_split(length, num_threads, borders);\n \n-                  for (int s = 0; s < (num_threads - 1); s++)\n+                  for (int s = 0; s < (num_threads - 1); ++s)\n                     {\n                       offsets[s].resize(k);\n                       multiseq_partition(\n@@ -1655,10 +1657,10 @@ template<\n                     }\n \n \n-                  for (int slab = 0; slab < num_threads; slab++)\n+                  for (int slab = 0; slab < num_threads; ++slab)\n                     {\n                       // For each slab / processor.\n-                      for (int seq = 0; seq < k; seq++)\n+                      for (int seq = 0; seq < k; ++seq)\n                         {\n                           // For each sequence.\n                           if (slab == 0)\n@@ -1676,7 +1678,7 @@ template<\n                             {\n                               // slab == num_threads - 1\n                               pieces[slab][seq].second =\n-                                  LENGTH(seqs_begin[seq]);\n+                                  _GLIBCXX_PARALLEL_LENGTH(seqs_begin[seq]);\n                             }\n                         }\n                     }\n@@ -1688,7 +1690,7 @@ template<\n \n           difference_type target_position = 0;\n \n-          for (int c = 0; c < k; c++)\n+          for (int c = 0; c < k; ++c)\n             target_position += pieces[iam][c].first;\n \n           if (k > 2)\n@@ -1698,12 +1700,12 @@ template<\n                   std::pair<RandomAccessIterator1, RandomAccessIterator1>[k];\n \n               difference_type local_length = 0;\n-              for (int s = 0; s < k; s++)\n+              for (int s = 0; s < k; ++s)\n                 {\n                   chunks[s] = std::make_pair(\n                       seqs_begin[s].first + pieces[iam][s].first,\n                       seqs_begin[s].first + pieces[iam][s].second);\n-                  local_length += LENGTH(chunks[s]);\n+                  local_length += _GLIBCXX_PARALLEL_LENGTH(chunks[s]);\n                 }\n \n               multiway_merge(\n@@ -1734,7 +1736,7 @@ template<\n #endif\n \n       // Update ends of sequences.\n-      for (int s = 0; s < k; s++)\n+      for (int s = 0; s < k; ++s)\n         seqs_begin[s].first += pieces[num_threads - 1][s].second;\n \n       delete[] pieces;"}, {"sha": "0476474cb1ff64216873c4ce70012348a75a5818", "filename": "libstdc++-v3/include/parallel/multiway_mergesort.h", "status": "modified", "additions": 24, "deletions": 12, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1661473b7f96b42c272b8bf8945ece6b60a2d5b2/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_mergesort.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1661473b7f96b42c272b8bf8945ece6b60a2d5b2/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_mergesort.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_mergesort.h?ref=1661473b7f96b42c272b8bf8945ece6b60a2d5b2", "patch": "@@ -124,6 +124,8 @@ template<typename RandomAccessIterator, typename _DifferenceTp>\n   determine_samples(PMWMSSortingData<RandomAccessIterator>* sd,\n                     _DifferenceTp& num_samples)\n   {\n+    typedef std::iterator_traits<RandomAccessIterator> traits_type;\n+    typedef typename traits_type::value_type value_type;\n     typedef _DifferenceTp difference_type;\n \n     thread_index_t iam = omp_get_thread_num();\n@@ -137,8 +139,8 @@ template<typename RandomAccessIterator, typename _DifferenceTp>\n                   num_samples + 1, es);\n \n     for (difference_type i = 0; i < num_samples; i++)\n-      sd->samples[iam * num_samples + i] =\n-          sd->source[sd->starts[iam] + es[i + 1]];\n+      new(&(sd->samples[iam * num_samples + i])) value_type(\n+          sd->source[sd->starts[iam] + es[i + 1]]);\n \n     delete[] es;\n   }\n@@ -213,7 +215,8 @@ template<typename RandomAccessIterator, typename Comparator>\n               if (num_samples * iam > 0)\n                 sd->pieces[iam][s].begin = \n                     std::lower_bound(sd->sorting_places[s],\n-                        sd->sorting_places[s] + sd->starts[s + 1] - sd->starts[s],\n+                        sd->sorting_places[s]\n+                            + (sd->starts[s + 1] - sd->starts[s]),\n                         sd->samples[num_samples * iam],\n                         comp)\n                     - sd->sorting_places[s];\n@@ -224,8 +227,10 @@ template<typename RandomAccessIterator, typename Comparator>\n             if ((num_samples * (iam + 1)) < (num_samples * sd->num_threads))\n               sd->pieces[iam][s].end =\n                   std::lower_bound(sd->sorting_places[s],\n-                                   sd->sorting_places[s] + sd->starts[s + 1] - sd->starts[s],\n-                                   sd->samples[num_samples * (iam + 1)], comp)\n+                          sd->sorting_places[s]\n+                              + (sd->starts[s + 1] - sd->starts[s]),\n+                          sd->samples[num_samples * (iam + 1)],\n+                          comp)\n                   - sd->sorting_places[s];\n             else\n               // Absolute end.\n@@ -240,7 +245,8 @@ template<typename RandomAccessIterator, typename Comparator>\n             seqs(sd->num_threads);\n         for (int s = 0; s < sd->num_threads; s++)\n           seqs[s] = std::make_pair(sd->sorting_places[s],\n-                                   sd->sorting_places[s] + sd->starts[s + 1] - sd->starts[s]);\n+                                   sd->sorting_places[s]\n+                                       + (sd->starts[s + 1] - sd->starts[s]));\n \n         std::vector<SortingPlacesIterator> offsets(sd->num_threads);\n \n@@ -256,7 +262,8 @@ template<typename RandomAccessIterator, typename Comparator>\n               sd->pieces[iam][seq].end = offsets[seq] - seqs[seq].first;\n             else\n               // very end of this sequence\n-              sd->pieces[iam][seq].end = sd->starts[seq + 1] - sd->starts[seq];\n+              sd->pieces[iam][seq].end =\n+                  sd->starts[seq + 1] - sd->starts[seq];\n           }\n \n #       pragma omp barrier\n@@ -284,6 +291,7 @@ template<typename RandomAccessIterator, typename Comparator>\n     // Merge to temporary storage, uninitialized creation not possible\n     // since there is no multiway_merge calling the placement new\n     // instead of the assignment operator.\n+    // XXX incorrect (de)construction\n     sd->merging_places[iam] = sd->temporaries[iam] =\n         static_cast<value_type*>(\n         ::operator new(sizeof(value_type) * length_am));\n@@ -296,11 +304,13 @@ template<typename RandomAccessIterator, typename Comparator>\n \n     for (int s = 0; s < sd->num_threads; s++)\n       {\n-        seqs[s] = std::make_pair(sd->sorting_places[s] + sd->pieces[iam][s].begin,\n-                                 sd->sorting_places[s] + sd->pieces[iam][s].end);\n+        seqs[s] =\n+            std::make_pair(sd->sorting_places[s] + sd->pieces[iam][s].begin,\n+                           sd->sorting_places[s] + sd->pieces[iam][s].end);\n       }\n \n-    multiway_merge(seqs.begin(), seqs.end(), sd->merging_places[iam], comp, length_am, sd->stable, false, sequential_tag());\n+    multiway_merge(seqs.begin(), seqs.end(), sd->merging_places[iam], comp,\n+                   length_am, sd->stable, false, sequential_tag());\n \n #   pragma omp barrier\n \n@@ -326,7 +336,8 @@ template<typename RandomAccessIterator, typename Comparator>\n   inline void\n   parallel_sort_mwms(RandomAccessIterator begin, RandomAccessIterator end,\n                      Comparator comp, \n-                     typename std::iterator_traits<RandomAccessIterator>::difference_type n,\n+                     typename std::iterator_traits<RandomAccessIterator>\n+                        ::difference_type n,\n                      int num_threads,\n                      bool stable)\n   {\n@@ -368,7 +379,8 @@ template<typename RandomAccessIterator, typename Comparator>\n             if (Settings::sort_splitting == Settings::SAMPLING)\n               {\n                 unsigned int size = \n-                    (Settings::sort_mwms_oversampling * num_threads - 1) * num_threads;\n+                    (Settings::sort_mwms_oversampling * num_threads - 1)\n+                        * num_threads;\n                 sd.samples = static_cast<value_type*>(\n                     ::operator new(size * sizeof(value_type)));\n               }"}, {"sha": "b168e4653d4b2d21594ca507b982fdb84718ab23", "filename": "libstdc++-v3/include/parallel/partial_sum.h", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1661473b7f96b42c272b8bf8945ece6b60a2d5b2/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpartial_sum.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1661473b7f96b42c272b8bf8945ece6b60a2d5b2/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpartial_sum.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpartial_sum.h?ref=1661473b7f96b42c272b8bf8945ece6b60a2d5b2", "patch": "@@ -73,8 +73,8 @@ template<\n       {\n         value = bin_op(value, *begin);\n         *result = value;\n-        result++;\n-        begin++;\n+        ++result;\n+        ++begin;\n       }\n     return result;\n   }\n@@ -103,6 +103,9 @@ template<\n     typedef typename traits_type::value_type value_type;\n     typedef typename traits_type::difference_type difference_type;\n \n+    if (begin == end)\n+      return result;\n+\n     thread_index_t num_threads =\n         std::min<difference_type>(get_max_threads(), n - 1);\n \n@@ -133,7 +136,7 @@ template<\n                     ((double)num_threads + Settings::partial_sum_dilatation)),\n                     borderstart = n - num_threads * chunk_length;\n                 borders[0] = 0;\n-                for (int i = 1; i < (num_threads + 1); i++)\n+                for (int i = 1; i < (num_threads + 1); ++i)\n                   {\n                     borders[i] = borderstart;\n                     borderstart += chunk_length;\n@@ -146,20 +149,21 @@ template<\n             OutputIterator target_end;\n           } //single\n \n-        int iam = omp_get_thread_num();\n+        thread_index_t iam = omp_get_thread_num();\n         if (iam == 0)\n           {\n             *result = *begin;\n             parallel_partial_sum_basecase(begin + 1, begin + borders[1],\n                           result + 1, bin_op, *begin);\n-            sums[0] = *(result + borders[1] - 1);\n+            new(&(sums[iam])) value_type(*(result + borders[1] - 1));\n           }\n         else\n           {\n-            sums[iam] = std::accumulate(begin + borders[iam] + 1,\n-                            begin + borders[iam + 1],\n-                            *(begin + borders[iam]),\n-                            bin_op, __gnu_parallel::sequential_tag());\n+            new(&(sums[iam])) value_type(\n+                                std::accumulate(begin + borders[iam] + 1,\n+                                begin + borders[iam + 1],\n+                                *(begin + borders[iam]),\n+                                bin_op, __gnu_parallel::sequential_tag()));\n           }\n \n #       pragma omp barrier"}, {"sha": "16901ede84efd3f9488c9e45adb272a82685fbf5", "filename": "libstdc++-v3/include/parallel/quicksort.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1661473b7f96b42c272b8bf8945ece6b60a2d5b2/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fquicksort.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1661473b7f96b42c272b8bf8945ece6b60a2d5b2/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fquicksort.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fquicksort.h?ref=1661473b7f96b42c272b8bf8945ece6b60a2d5b2", "patch": "@@ -74,13 +74,13 @@ namespace __gnu_parallel\n \n     // Allocate uninitialized, to avoid default constructor.\n     value_type* samples = static_cast<value_type*>(\n-        operator new(num_samples * sizeof(value_type)));\n+      ::operator new(num_samples * sizeof(value_type)));\n \n-    for (difference_type s = 0; s < num_samples; s++)\n+    for (difference_type s = 0; s < num_samples; ++s)\n       {\n         const unsigned long long index = static_cast<unsigned long long>(s)\n                         * n / num_samples;\n-        new(samples + s) value_type(begin[index]);\n+        new(&(samples[s])) value_type(begin[index]);\n       }\n \n     __gnu_sequential::sort(samples, samples + num_samples, comp);\n@@ -91,6 +91,8 @@ namespace __gnu_parallel\n         pred(comp, pivot);\n     difference_type split = parallel_partition(begin, end, pred, num_threads);\n \n+    delete[] samples;\n+\n     return split;\n   }\n "}, {"sha": "6bce8d6b0e57377968ac4a4e76c50cbe966a4849", "filename": "libstdc++-v3/include/parallel/random_shuffle.h", "status": "modified", "additions": 27, "deletions": 26, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1661473b7f96b42c272b8bf8945ece6b60a2d5b2/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Frandom_shuffle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1661473b7f96b42c272b8bf8945ece6b60a2d5b2/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Frandom_shuffle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Frandom_shuffle.h?ref=1661473b7f96b42c272b8bf8945ece6b60a2d5b2", "patch": "@@ -144,23 +144,23 @@ template<typename RandomAccessIterator, typename RandomNumberGenerator>\n     value_type** temporaries = new value_type*[d->num_threads];\n \n     // Compute oracles and count appearances.\n-    for (bin_index b = 0; b < sd->num_bins + 1; b++)\n+    for (bin_index b = 0; b < sd->num_bins + 1; ++b)\n       dist[b] = 0;\n     int num_bits = sd->num_bits;\n \n     random_number rng(d->seed);\n \n     // First main loop.\n-    for (difference_type i = 0; i < length; i++)\n+    for (difference_type i = 0; i < length; ++i)\n       {\n         bin_index oracle = random_number_pow2(num_bits, rng);\n         oracles[i] = oracle;\n \n         // To allow prefix (partial) sum.\n-        dist[oracle + 1]++;\n+        ++(dist[oracle + 1]);\n       }\n \n-    for (bin_index b = 0; b < sd->num_bins + 1; b++)\n+    for (bin_index b = 0; b < sd->num_bins + 1; ++b)\n       sd->dist[b][iam + 1] = dist[b];\n \n #   pragma omp barrier\n@@ -169,7 +169,7 @@ template<typename RandomAccessIterator, typename RandomNumberGenerator>\n     {\n       // Sum up bins, sd->dist[s + 1][d->num_threads] now contains the\n       // total number of items in bin s\n-      for (bin_index s = 0; s < sd->num_bins; s++)\n+      for (bin_index s = 0; s < sd->num_bins; ++s)\n         __gnu_sequential::partial_sum(sd->dist[s + 1],\n                                       sd->dist[s + 1] + d->num_threads + 1,\n                                       sd->dist[s + 1]);\n@@ -178,14 +178,14 @@ template<typename RandomAccessIterator, typename RandomNumberGenerator>\n #   pragma omp barrier\n \n     sequence_index_t offset = 0, global_offset = 0;\n-    for (bin_index s = 0; s < d->bins_begin; s++)\n+    for (bin_index s = 0; s < d->bins_begin; ++s)\n       global_offset += sd->dist[s + 1][d->num_threads];\n \n #   pragma omp barrier\n \n-    for (bin_index s = d->bins_begin; s < d->bins_end; s++)\n+    for (bin_index s = d->bins_begin; s < d->bins_end; ++s)\n       {\n-\tfor (int t = 0; t < d->num_threads + 1; t++)\n+\tfor (int t = 0; t < d->num_threads + 1; ++t)\n \t  sd->dist[s + 1][t] += offset;\n \toffset = sd->dist[s + 1][d->num_threads];\n       }\n@@ -196,24 +196,25 @@ template<typename RandomAccessIterator, typename RandomNumberGenerator>\n #   pragma omp barrier\n \n     // Draw local copies to avoid false sharing.\n-    for (bin_index b = 0; b < sd->num_bins + 1; b++)\n+    for (bin_index b = 0; b < sd->num_bins + 1; ++b)\n       dist[b] = sd->dist[b][iam];\n-    for (bin_index b = 0; b < sd->num_bins; b++)\n+    for (bin_index b = 0; b < sd->num_bins; ++b)\n       bin_proc[b] = sd->bin_proc[b];\n-    for (thread_index_t t = 0; t < d->num_threads; t++)\n+    for (thread_index_t t = 0; t < d->num_threads; ++t)\n       temporaries[t] = sd->temporaries[t];\n \n     RandomAccessIterator source = sd->source;\n     difference_type start = sd->starts[iam];\n \n     // Distribute according to oracles, second main loop.\n-    for (difference_type i = 0; i < length; i++)\n+    for (difference_type i = 0; i < length; ++i)\n       {\n         bin_index target_bin = oracles[i];\n         thread_index_t target_p = bin_proc[target_bin];\n \n         // Last column [d->num_threads] stays unchanged.\n-        temporaries[target_p][dist[target_bin + 1]++] = *(source + i + start);\n+        new(&(temporaries[target_p][dist[target_bin + 1]++])) value_type(\n+              *(source + i + start));\n       }\n \n     delete[] oracles;\n@@ -224,7 +225,7 @@ template<typename RandomAccessIterator, typename RandomNumberGenerator>\n #   pragma omp barrier\n \n     // Shuffle bins internally.\n-    for (bin_index b = d->bins_begin; b < d->bins_end; b++)\n+    for (bin_index b = d->bins_begin; b < d->bins_end; ++b)\n       {\n         value_type* begin =\n                     sd->temporaries[iam] +\n@@ -338,9 +339,9 @@ template<typename RandomAccessIterator, typename RandomNumberGenerator>\n             sd.temporaries = new value_type*[num_threads];\n             sd.dist = new difference_type*[num_bins + 1];\n             sd.bin_proc = new thread_index_t[num_bins];\n-            for (bin_index b = 0; b < num_bins + 1; b++)\n+            for (bin_index b = 0; b < num_bins + 1; ++b)\n               sd.dist[b] = new difference_type[num_threads + 1];\n-            for (bin_index b = 0; b < (num_bins + 1); b++)\n+            for (bin_index b = 0; b < (num_bins + 1); ++b)\n               {\n                 sd.dist[0][0] = 0;\n                 sd.dist[b][0] = 0;\n@@ -354,7 +355,7 @@ template<typename RandomAccessIterator, typename RandomNumberGenerator>\n                             split = n % num_threads, start = 0;\n             difference_type bin_chunk_length = num_bins / num_threads,\n                             bin_split = num_bins % num_threads;\n-            for (thread_index_t i = 0; i < num_threads; i++)\n+            for (thread_index_t i = 0; i < num_threads; ++i)\n               {\n                 starts[i] = start;\n                 start += (i < split) ? (chunk_length + 1) : chunk_length;\n@@ -364,7 +365,7 @@ template<typename RandomAccessIterator, typename RandomNumberGenerator>\n                 bin_cursor += (i < bin_split) ?\n                     (bin_chunk_length + 1) : bin_chunk_length;\n                 pus[i].bins_end = bin_cursor;\n-                for (; j < bin_cursor; j++)\n+                for (; j < bin_cursor; ++j)\n                   sd.bin_proc[j] = i;\n                 pus[i].num_threads = num_threads;\n                 pus[i].seed = rng(std::numeric_limits<uint32>::max());\n@@ -378,7 +379,7 @@ template<typename RandomAccessIterator, typename RandomNumberGenerator>\n \n     delete[] starts;\n     delete[] sd.bin_proc;\n-    for (int s = 0; s < (num_bins + 1); s++)\n+    for (int s = 0; s < (num_bins + 1); ++s)\n       delete[] sd.dist[s];\n     delete[] sd.dist;\n     delete[] sd.temporaries;\n@@ -455,31 +456,31 @@ template<typename RandomAccessIterator, typename RandomNumberGenerator>\n         difference_type* dist0 = new difference_type[num_bins + 1],\n                        * dist1 = new difference_type[num_bins + 1];\n \n-        for (int b = 0; b < num_bins + 1; b++)\n+        for (int b = 0; b < num_bins + 1; ++b)\n           dist0[b] = 0;\n \n         random_number bitrng(rng(0xFFFFFFFF));\n \n-        for (difference_type i = 0; i < n; i++)\n+        for (difference_type i = 0; i < n; ++i)\n           {\n             bin_index oracle = random_number_pow2(num_bits, bitrng);\n             oracles[i] = oracle;\n \n             // To allow prefix (partial) sum.\n-            dist0[oracle + 1]++;\n+            ++(dist0[oracle + 1]);\n           }\n \n         // Sum up bins.\n         __gnu_sequential::partial_sum(dist0, dist0 + num_bins + 1, dist0);\n \n-        for (int b = 0; b < num_bins + 1; b++)\n+        for (int b = 0; b < num_bins + 1; ++b)\n           dist1[b] = dist0[b];\n \n         // Distribute according to oracles.\n-        for (difference_type i = 0; i < n; i++)\n-          target[(dist0[oracles[i]])++] = *(begin + i);\n+        for (difference_type i = 0; i < n; ++i)\n+          new(&(target[(dist0[oracles[i]])++])) value_type(*(begin + i));\n \n-        for (int b = 0; b < num_bins; b++)\n+        for (int b = 0; b < num_bins; ++b)\n           {\n             sequential_random_shuffle(target + dist1[b],\n                                       target + dist1[b + 1],"}, {"sha": "e3599b4a312f601ed8819299ee7b99a64b7473a1", "filename": "libstdc++-v3/include/parallel/unique_copy.h", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1661473b7f96b42c272b8bf8945ece6b60a2d5b2/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Funique_copy.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1661473b7f96b42c272b8bf8945ece6b60a2d5b2/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Funique_copy.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Funique_copy.h?ref=1661473b7f96b42c272b8bf8945ece6b60a2d5b2", "patch": "@@ -100,16 +100,14 @@ template<\n           end = borders[iam + 1];\n \n           i++;\n-          new (static_cast<void *>(&*out)) value_type(*first);\n-          out++;\n+          *out++ = *first;\n \n           for (InputIterator iter = first + begin; iter < first + end; ++iter)\n             {\n               if (!binary_pred(*iter, *(iter-1)))\n                 {\n                   i++;\n-                  new (static_cast<void *>(&*out)) value_type(*iter);\n-                  out++;\n+                  *out++ = *iter;\n                 }\n             }\n         }\n@@ -153,8 +151,7 @@ template<\n               if (iter == first || !binary_pred(*iter, *(iter-1)))\n                 {\n                   i++;\n-                  new (static_cast<void *>(&*iter_out)) value_type(*iter);\n-                  iter_out++;\n+                  *iter_out++ = *iter;\n                 }\n             }\n \n@@ -170,8 +167,7 @@ template<\n             {\n               if (!binary_pred(*iter, *(iter-1)))\n                 {\n-                  new (static_cast<void *> (&*iter_out)) value_type(*iter);\n-                  iter_out++;\n+                  *iter_out++ = *iter;\n                 }\n             }\n         }"}]}