{"sha": "f177a087002cef5c40eab070151d6dee4e39d346", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjE3N2EwODcwMDJjZWY1YzQwZWFiMDcwMTUxZDZkZWU0ZTM5ZDM0Ng==", "commit": {"author": {"name": "Steven G. Kargl", "email": "kargls@comcast.net", "date": "2004-12-02T04:20:09Z"}, "committer": {"name": "Paul Brook", "email": "pbrook@gcc.gnu.org", "date": "2004-12-02T04:20:09Z"}, "message": "flush.c: New file.\n\n2004-12-02  Steven G. Kargl  <kargls@comcast.net>\n\tPaul Brook  <paul@codesourcery.com>\n\nlibgfortran/\n\t* intrinsics/flush.c: New file.\n\t* intrinsics/fnum.c: ditto\n\t* intrinsics/stat.c: ditto\n\t* io/io.h (unit_to_fd): Add prototype.\n\t* io/unix.c (unit_to_fd): New function.\n\t* configure.ac: Add test for members of struct stat.  Check for\n\tsys/types.h and sys/stat.h\n\t* Makefile.am: Add intrinsics/{flush.c,fnum.c,stat.c}\n\t* configure.in: Regenerate.\n\t* config.h.in: Regenerate.\n\t* Makefile.in: Regenerate.\nfortran/\n\t* check.c (gfc_check_flush, gfc_check_fnum): New functions.\n\t(gfc_check_fstat, gfc_check_fstat_sub): New functions.\n\t(gfc_check_stat, gfc_check_stat_sub): New functions.\n\t* gfortran.h (GFC_ISYM_FNUM,GFC_ISYM_FSTAT,GFC_ISYM_STAT): New symbols\n\t* intrinsic.c (add_functions,add_subroutines): Add flush, fnum,\n\tfstat, and stat to intrinsics symbol tables.\n\t* intrinsic.h (gfc_check_flush, gfc_resolve_stat_sub): Add prototypes.\n\t(gfc_resolve_fstat_sub, gfc_resolve_stat): Ditto.\n\t* iresolve.c (gfc_resolve_fnum, gfc_resolve_fstat): New functions.\n\t(gfc_resolve_stat, gfc_resolve_flush): New functions.\n\t(gfc_resolve_stat_sub,gfc_resolve_fstat_sub): New functions\n\t* trans-intrinsic.c (gfc_conv_intrinsic_function): Add new intrinsics.\n\nFrom-SVN: r91611", "tree": {"sha": "382601a1781d98e810c8d33fb16fea4c4a7349e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/382601a1781d98e810c8d33fb16fea4c4a7349e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f177a087002cef5c40eab070151d6dee4e39d346", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f177a087002cef5c40eab070151d6dee4e39d346", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f177a087002cef5c40eab070151d6dee4e39d346", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f177a087002cef5c40eab070151d6dee4e39d346/comments", "author": null, "committer": null, "parents": [{"sha": "8dc4d66aa7ec5bfe543ac3842ea9d4b3d535b3dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8dc4d66aa7ec5bfe543ac3842ea9d4b3d535b3dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8dc4d66aa7ec5bfe543ac3842ea9d4b3d535b3dc"}], "stats": {"total": 564, "additions": 564, "deletions": 0}, "files": [{"sha": "4603d709f484c4dd682be29b95fe9c1a7c3dbb99", "filename": "libgfortran/intrinsics/flush.c", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f177a087002cef5c40eab070151d6dee4e39d346/libgfortran%2Fintrinsics%2Fflush.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f177a087002cef5c40eab070151d6dee4e39d346/libgfortran%2Fintrinsics%2Fflush.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fflush.c?ref=f177a087002cef5c40eab070151d6dee4e39d346", "patch": "@@ -0,0 +1,66 @@\n+/* Implementation of the FLUSH intrinsic.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+   Contributed by Steven G. Kargl <kargls@comcast.net>.\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU Lesser General Public\n+License as published by the Free Software Foundation; either\n+version 2.1 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU Lesser General Public License for more details.\n+\n+You should have received a copy of the GNU Lesser General Public\n+License along with libgfor; see the file COPYING.LIB.  If not,\n+write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+\n+#include \"config.h\"\n+#include \"libgfortran.h\"\n+\n+#ifdef HAVE_STDLIB_H\n+#include <stdlib.h>\n+#endif\n+\n+#include \"../io/io.h\"\n+\n+/* SUBROUTINE FLUSH(UNIT)\n+   INTEGER, INTENT(IN), OPTIONAL :: UNIT  */\n+\n+static void\n+recursive_flush (gfc_unit *us)\n+{\n+  /* There can be no open files.  */\n+  if (us == NULL)\n+    return;\n+\n+  flush (us->s);\n+  recursive_flush (us->left);\n+  recursive_flush (us->right);\n+}\n+\n+\n+void\n+prefix(flush_i4) (GFC_INTEGER_4 * unit)\n+{\n+\n+  gfc_unit *us;\n+\n+  /* flush all streams */\n+  if (unit == NULL)\n+    {\n+      us = g.unit_root;\n+      recursive_flush(us);\n+    }\n+  else\n+    {\n+      us = find_unit(*unit);\n+      if (us != NULL)\n+        flush (us->s);\n+    }\n+}"}, {"sha": "251cfb4e937d78cf62f18671e1c8179ccb77bf57", "filename": "libgfortran/intrinsics/fnum.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f177a087002cef5c40eab070151d6dee4e39d346/libgfortran%2Fintrinsics%2Ffnum.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f177a087002cef5c40eab070151d6dee4e39d346/libgfortran%2Fintrinsics%2Ffnum.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Ffnum.c?ref=f177a087002cef5c40eab070151d6dee4e39d346", "patch": "@@ -0,0 +1,42 @@\n+/* Implementation of the FNUM intrinsics.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+   Contributed by Steven G. Kargl <kargls@comcast.net>.\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU Lesser General Public\n+License as published by the Free Software Foundation; either\n+version 2.1 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU Lesser General Public License for more details.\n+\n+You should have received a copy of the GNU Lesser General Public\n+License along with libgfor; see the file COPYING.LIB.  If not,\n+write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"libgfortran.h\"\n+\n+#include \"../io/io.h\"\n+\n+/* FUNCTION FNUM(UNIT)\n+   INTEGER FNUM\n+   INTEGER, INTENT(IN), :: UNIT  */\n+\n+GFC_INTEGER_4\n+prefix(fnum_i4) (GFC_INTEGER_4 * unit)\n+{\n+  return unit_to_fd (*unit);\n+}\n+\n+\n+GFC_INTEGER_8\n+prefix(fnum_i8) (GFC_INTEGER_8 * unit)\n+{\n+  return unit_to_fd (*unit);\n+}"}, {"sha": "e597e44aa1cc3d6e8292ac7dbd271ba2360d7255", "filename": "libgfortran/intrinsics/stat.c", "status": "added", "additions": 456, "deletions": 0, "changes": 456, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f177a087002cef5c40eab070151d6dee4e39d346/libgfortran%2Fintrinsics%2Fstat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f177a087002cef5c40eab070151d6dee4e39d346/libgfortran%2Fintrinsics%2Fstat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fstat.c?ref=f177a087002cef5c40eab070151d6dee4e39d346", "patch": "@@ -0,0 +1,456 @@\n+/* Implementation of the STAT and FSTAT intrinsics.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+   Contributed by Steven G. Kargl <kargls@comcast.net>.\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU Lesser General Public\n+License as published by the Free Software Foundation; either\n+version 2.1 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU Lesser General Public License for more details.\n+\n+You should have received a copy of the GNU Lesser General Public\n+License along with libgfor; see the file COPYING.LIB.  If not,\n+write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"libgfortran.h\"\n+\n+#ifdef HAVE_SYS_TYPES_H\n+#include <sys/types.h>\n+#endif\n+\n+#ifdef HAVE_SYS_STAT_H\n+#include <sys/stat.h>\n+#endif\n+\n+#ifdef HAVE_STDLIB_H\n+#include <stdlib.h>\n+#endif\n+\n+#ifdef HAVE_STRING_H\n+#include <string.h>\n+#endif\n+\n+#include <errno.h>\n+\n+#include \"../io/io.h\"\n+\n+/* SUBROUTINE STAT(FILE, SARRAY, STATUS)\n+   CHARACTER(len=*), INTENT(IN) :: FILE\n+   INTEGER, INTENT(OUT), :: SARRAY(13)\n+   INTEGER, INTENT(OUT), OPTIONAL :: STATUS\n+\n+   FUNCTION STAT(FILE, SARRAY)\n+   INTEGER STAT\n+   CHARACTER(len=*), INTENT(IN) :: FILE\n+   INTEGER, INTENT(OUT), :: SARRAY(13)  */\n+\n+void\n+prefix(stat_i4_sub) (char * name, gfc_array_i4 * sarray,\n+                     GFC_INTEGER_4 * status,  gfc_charlen_type name_len)\n+{\n+ \n+  int val;\n+  char *str;\n+  struct stat sb;\n+\n+  index_type stride[GFC_MAX_DIMENSIONS - 1];\n+      \n+  /* If the rank of the array is not 1, abort.  */\n+  if (GFC_DESCRIPTOR_RANK (sarray) != 1)\n+    runtime_error (\"Array rank of SARRAY is not 1.\");\n+\n+  /* If the array is too small, abort.  */\n+  if (sarray->dim[0].ubound + 1 - sarray->dim[0].lbound < 13)\n+\truntime_error (\"Array size of SARRAY is too small.\");\n+\n+  if (sarray->dim[0].stride == 0)\n+\tsarray->dim[0].stride = 1;\n+\n+  /* Trim trailing spaces from name.  */\n+  while (name_len > 0 && name[name_len - 1] == ' ')\n+    name_len--;\n+\n+  /* Make a null terminated copy of the string.  */\n+  str = gfc_alloca (name_len + 1);\n+  memcpy (str, name, name_len);\n+  str[name_len] = '\\0'; \n+\n+  val = stat(str, &sb);\n+\n+  if (val == 0) \n+    {\n+      /* Device ID  */\n+      sarray->data[0 * sarray->dim[0].stride] = sb.st_dev;\n+\n+      /* Inode number  */\n+      sarray->data[1 * sarray->dim[0].stride] = sb.st_ino;\n+\n+      /* File mode  */\n+      sarray->data[2 * sarray->dim[0].stride] = sb.st_mode;\n+\n+      /* Number of (hard) links  */\n+      sarray->data[3 * sarray->dim[0].stride] = sb.st_nlink;\n+\n+      /* Owner's uid  */\n+      sarray->data[4 * sarray->dim[0].stride] = sb.st_uid;\n+\n+      /* Owner's gid  */\n+      sarray->data[5 * sarray->dim[0].stride] = sb.st_gid;\n+  \n+      /* ID of device containing directory entry for file (0 if not available) */\n+#if HAVE_STRUCT_STAT_ST_RDEV\n+      sarray->data[6 * sarray->dim[0].stride] = sb.st_rdev;\n+#else\n+      sarray->data[6 * sarray->dim[0].stride] = 0;\n+#endif\n+\n+      /* File size (bytes)  */\n+      sarray->data[7 * sarray->dim[0].stride] = sb.st_size;\n+\n+      /* Last access time  */\n+      sarray->data[8 * sarray->dim[0].stride] = sb.st_atime;\n+\n+      /* Last modification time  */\n+      sarray->data[9 * sarray->dim[0].stride] = sb.st_mtime;\n+\n+      /* Last file status change time  */\n+      sarray->data[10 * sarray->dim[0].stride] = sb.st_ctime;\n+\n+      /* Preferred I/O block size (-1 if not available)  */\n+#if HAVE_STRUCT_STAT_ST_BLKSIZE\n+      sarray->data[11 * sarray->dim[0].stride] = sb.st_blksize;\n+#else\n+      sarray->data[11 * sarray->dim[0].stride] = -1;\n+#endif\n+\n+      /* Number of blocks allocated (-1 if not available)  */\n+#if HAVE_STRUCT_STAT_ST_BLOCKS\n+      sarray->data[12 * sarray->dim[0].stride] = sb.st_blocks;\n+#else\n+      sarray->data[12 * sarray->dim[0].stride] = -1;\n+#endif\n+    }\n+\n+  if (status != NULL) \n+    *status = (val == 0) ? 0 : errno;\n+}\n+\n+void\n+prefix(stat_i8_sub) (char * name, gfc_array_i8 * sarray,\n+                     GFC_INTEGER_8 * status, gfc_charlen_type name_len)\n+{\n+ \n+  int val;\n+  char *str;\n+  struct stat sb;\n+\n+  index_type stride[GFC_MAX_DIMENSIONS - 1];\n+      \n+  /* If the rank of the array is not 1, abort.  */\n+  if (GFC_DESCRIPTOR_RANK (sarray) != 1)\n+    runtime_error (\"Array rank of SARRAY is not 1.\");\n+\n+  /* If the array is too small, abort.  */\n+  if (sarray->dim[0].ubound + 1 - sarray->dim[0].lbound < 13)\n+\truntime_error (\"Array size of SARRAY is too small.\");\n+\n+  if (sarray->dim[0].stride == 0)\n+\tsarray->dim[0].stride = 1;\n+\n+  /* Trim trailing spaces from name.  */\n+  while (name_len > 0 && name[name_len - 1] == ' ')\n+    name_len--;\n+\n+  /* Make a null terminated copy of the string.  */\n+  str = gfc_alloca (name_len + 1);\n+  memcpy (str, name, name_len);\n+  str[name_len] = '\\0'; \n+\n+  val = stat(str, &sb);\n+\n+  if (val == 0)\n+    {\n+      /* Device ID  */\n+      sarray->data[0] = sb.st_dev;\n+\n+      /* Inode number  */\n+      sarray->data[sarray->dim[0].stride] = sb.st_ino;\n+\n+      /* File mode  */\n+      sarray->data[2 * sarray->dim[0].stride] = sb.st_mode;\n+\n+      /* Number of (hard) links  */\n+      sarray->data[3 * sarray->dim[0].stride] = sb.st_nlink;\n+  \n+      /* Owner's uid  */\n+      sarray->data[4 * sarray->dim[0].stride] = sb.st_uid;\n+\n+      /* Owner's gid  */\n+      sarray->data[5 * sarray->dim[0].stride] = sb.st_gid;\n+  \n+      /* ID of device containing directory entry for file (0 if not available) */\n+#if HAVE_STRUCT_STAT_ST_RDEV\n+      sarray->data[6 * sarray->dim[0].stride] = sb.st_rdev;\n+#else\n+      sarray->data[6 * sarray->dim[0].stride] = 0;\n+#endif\n+\n+      /* File size (bytes)  */\n+      sarray->data[7 * sarray->dim[0].stride] = sb.st_size;\n+\n+      /* Last access time  */\n+      sarray->data[8 * sarray->dim[0].stride] = sb.st_atime;\n+\n+      /* Last modification time  */\n+      sarray->data[9 * sarray->dim[0].stride] = sb.st_mtime;\n+\n+      /* Last file status change time  */\n+      sarray->data[10 * sarray->dim[0].stride] = sb.st_ctime;\n+\n+      /* Preferred I/O block size (-1 if not available)  */\n+#if HAVE_STRUCT_STAT_ST_BLKSIZE\n+      sarray->data[11 * sarray->dim[0].stride] = sb.st_blksize;\n+#else\n+      sarray->data[11 * sarray->dim[0].stride] = -1;\n+#endif\n+\n+      /* Number of blocks allocated (-1 if not available)  */\n+#if HAVE_STRUCT_STAT_ST_BLOCKS\n+      sarray->data[12 * sarray->dim[0].stride] = sb.st_blocks;\n+#else\n+      sarray->data[12 * sarray->dim[0].stride] = -1;\n+#endif\n+    }\n+\n+  if (status != NULL) \n+    *status = (val == 0) ? 0 : errno;\n+}\n+\n+\n+GFC_INTEGER_4\n+prefix(stat_i4) (char * name, gfc_array_i4 * sarray,\n+                 gfc_charlen_type name_len)\n+{\n+\n+  GFC_INTEGER_4 val;\n+  prefix(stat_i4_sub) (name, sarray, &val, name_len);\n+  return val;\n+}\n+\n+\n+GFC_INTEGER_8\n+prefix(stat_i8) (char * name, gfc_array_i8 * sarray,\n+                 gfc_charlen_type name_len)\n+{\n+\n+  GFC_INTEGER_8 val;\n+  prefix(stat_i8_sub) (name, sarray, &val, name_len);\n+  return val;\n+}\n+\n+\n+/* SUBROUTINE FSTAT(UNIT, SARRAY, STATUS)\n+   INTEGER, INTENT(IN) :: UNIT \n+   INTEGER, INTENT(OUT) :: SARRAY(13)\n+   INTEGER, INTENT(OUT), OPTIONAL :: STATUS \n+\n+   FUNCTION FSTAT(UNIT, SARRAY)\n+   INTEGER FSTAT\n+   INTEGER, INTENT(IN) :: UNIT \n+   INTEGER, INTENT(OUT) :: SARRAY(13)  */\n+\n+void\n+prefix(fstat_i4_sub) (GFC_INTEGER_4 * unit, gfc_array_i4 * sarray,\n+                     GFC_INTEGER_4 * status)\n+{\n+ \n+  int val;\n+  struct stat sb;\n+\n+  index_type stride[GFC_MAX_DIMENSIONS - 1];\n+      \n+  /* If the rank of the array is not 1, abort.  */\n+  if (GFC_DESCRIPTOR_RANK (sarray) != 1)\n+    runtime_error (\"Array rank of SARRAY is not 1.\");\n+\n+  /* If the array is too small, abort.  */\n+  if (sarray->dim[0].ubound + 1 - sarray->dim[0].lbound < 13)\n+\truntime_error (\"Array size of SARRAY is too small.\");\n+\n+  if (sarray->dim[0].stride == 0)\n+\tsarray->dim[0].stride = 1;\n+\n+  /* Convert Fortran unit number to C file descriptor.  */\n+  val = unit_to_fd (*unit);\n+  if (val >= 0)\n+    val = fstat(val, &sb);\n+\n+  if (val == 0)\n+    {\n+      /* Device ID  */\n+      sarray->data[0 * sarray->dim[0].stride] = sb.st_dev;\n+\n+      /* Inode number  */\n+      sarray->data[1 * sarray->dim[0].stride] = sb.st_ino;\n+  \n+      /* File mode  */\n+      sarray->data[2 * sarray->dim[0].stride] = sb.st_mode;\n+\n+      /* Number of (hard) links  */\n+      sarray->data[3 * sarray->dim[0].stride] = sb.st_nlink;\n+\n+      /* Owner's uid  */\n+      sarray->data[4 * sarray->dim[0].stride] = sb.st_uid;\n+\n+      /* Owner's gid  */\n+      sarray->data[5 * sarray->dim[0].stride] = sb.st_gid;\n+  \n+      /* ID of device containing directory entry for file (0 if not available) */\n+#if HAVE_STRUCT_STAT_ST_RDEV\n+      sarray->data[6 * sarray->dim[0].stride] = sb.st_rdev;\n+#else\n+      sarray->data[6 * sarray->dim[0].stride] = 0;\n+#endif\n+\n+      /* File size (bytes)  */\n+      sarray->data[7 * sarray->dim[0].stride] = sb.st_size;\n+\n+      /* Last access time  */\n+      sarray->data[8 * sarray->dim[0].stride] = sb.st_atime;\n+\n+      /* Last modification time  */\n+      sarray->data[9 * sarray->dim[0].stride] = sb.st_mtime;\n+\n+      /* Last file status change time  */\n+      sarray->data[10 * sarray->dim[0].stride] = sb.st_ctime;\n+\n+      /* Preferred I/O block size (-1 if not available)  */\n+#if HAVE_STRUCT_STAT_ST_BLKSIZE\n+      sarray->data[11 * sarray->dim[0].stride] = sb.st_blksize;\n+#else\n+      sarray->data[11 * sarray->dim[0].stride] = -1;\n+#endif\n+\n+      /* Number of blocks allocated (-1 if not available)  */\n+#if HAVE_STRUCT_STAT_ST_BLOCKS\n+      sarray->data[12 * sarray->dim[0].stride] = sb.st_blocks;\n+#else\n+      sarray->data[12 * sarray->dim[0].stride] = -1;\n+#endif\n+    }\n+\n+  if (status != NULL) \n+    *status = (val == 0) ? 0 : errno;\n+}\n+\n+void\n+prefix(fstat_i8_sub) (GFC_INTEGER_8 * unit, gfc_array_i8 * sarray,\n+                     GFC_INTEGER_8 * status)\n+{\n+ \n+  int val;\n+  struct stat sb;\n+\n+  index_type stride[GFC_MAX_DIMENSIONS - 1];\n+      \n+  /* If the rank of the array is not 1, abort.  */\n+  if (GFC_DESCRIPTOR_RANK (sarray) != 1)\n+    runtime_error (\"Array rank of SARRAY is not 1.\");\n+\n+  /* If the array is too small, abort.  */\n+  if (sarray->dim[0].ubound + 1 - sarray->dim[0].lbound < 13)\n+\truntime_error (\"Array size of SARRAY is too small.\");\n+\n+  if (sarray->dim[0].stride == 0)\n+\tsarray->dim[0].stride = 1;\n+\n+  /* Convert Fortran unit number to C file descriptor.  */\n+  val = unit_to_fd ((int) *unit);\n+  if (val >= 0)\n+    val = fstat(val, &sb);\n+\n+  if (val == 0)\n+    {\n+      /* Device ID  */\n+      sarray->data[0] = sb.st_dev;\n+\n+      /* Inode number  */\n+      sarray->data[sarray->dim[0].stride] = sb.st_ino;\n+\n+      /* File mode  */\n+      sarray->data[2 * sarray->dim[0].stride] = sb.st_mode;\n+\n+      /* Number of (hard) links  */\n+      sarray->data[3 * sarray->dim[0].stride] = sb.st_nlink;\n+\n+      /* Owner's uid  */\n+      sarray->data[4 * sarray->dim[0].stride] = sb.st_uid;\n+\n+      /* Owner's gid  */\n+      sarray->data[5 * sarray->dim[0].stride] = sb.st_gid;\n+  \n+      /* ID of device containing directory entry for file (0 if not available) */\n+#if HAVE_STRUCT_STAT_ST_RDEV\n+      sarray->data[6 * sarray->dim[0].stride] = sb.st_rdev;\n+#else\n+      sarray->data[6 * sarray->dim[0].stride] = 0;\n+#endif\n+\n+      /* File size (bytes)  */\n+      sarray->data[7 * sarray->dim[0].stride] = sb.st_size;\n+\n+      /* Last access time  */\n+      sarray->data[8 * sarray->dim[0].stride] = sb.st_atime;\n+\n+      /* Last modification time  */\n+      sarray->data[9 * sarray->dim[0].stride] = sb.st_mtime;\n+\n+      /* Last file status change time  */\n+      sarray->data[10 * sarray->dim[0].stride] = sb.st_ctime;\n+\n+      /* Preferred I/O block size (-1 if not available)  */\n+#if HAVE_STRUCT_STAT_ST_BLKSIZE\n+      sarray->data[11 * sarray->dim[0].stride] = sb.st_blksize;\n+#else\n+      sarray->data[11 * sarray->dim[0].stride] = -1;\n+#endif\n+\n+      /* Number of blocks allocated (-1 if not available)  */\n+#if HAVE_STRUCT_STAT_ST_BLOCKS\n+      sarray->data[12 * sarray->dim[0].stride] = sb.st_blocks;\n+#else\n+      sarray->data[12 * sarray->dim[0].stride] = -1;\n+#endif\n+    }\n+\n+  if (status != NULL) \n+    *status = (val == 0) ? 0 : errno;\n+}\n+\n+\n+GFC_INTEGER_4\n+prefix(fstat_i4) (GFC_INTEGER_4 * unit, gfc_array_i4 * sarray)\n+{\n+\n+  GFC_INTEGER_4 val;\n+  prefix(fstat_i4_sub) (unit, sarray, &val);\n+  return val;\n+}\n+\n+\n+GFC_INTEGER_8\n+prefix(fstat_i8) (GFC_INTEGER_8 * unit, gfc_array_i8 * sarray)\n+{\n+\n+  GFC_INTEGER_8 val;\n+  prefix(fstat_i8_sub) (unit, sarray, &val);\n+  return val;\n+}"}]}