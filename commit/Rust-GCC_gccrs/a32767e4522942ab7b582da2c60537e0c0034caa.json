{"sha": "a32767e4522942ab7b582da2c60537e0c0034caa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTMyNzY3ZTQ1MjI5NDJhYjdiNTgyZGEyYzYwNTM3ZTBjMDAzNGNhYQ==", "commit": {"author": {"name": "David Mosberger", "email": "davidm@hpl.hp.com", "date": "2003-08-06T21:08:29Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2003-08-06T21:08:29Z"}, "message": "extend.texi (Function Attributes): Document the IA-64 version of the \"model\" attribute.\n\n        * doc/extend.texi (Function Attributes): Document the IA-64 version\n        of the \"model\" attribute.\n\n        * config/ia64/ia64.h (SYMBOL_FLAG_SMALL_ADDR): New macro.\n        (SYMBOL_REF_SMALL_ADDR_P): Ditto.\n        (PREDICATE_CODES): Mention \"small_addr_symbolic_operand\".\n\n        * config/ia64/ia64.c (ia64_handle_model_attribute): New function.\n        (ia64_encode_section_info): Likewise.\n        (ia64_attribute_table): Add \"model\" attribute.\n        (TARGET_ENCODE_SECTION_INFO): Define.\n        (small_addr_symbolic_operand): New function.\n        (got_symbolic_operand): Return 0 for a symbolref to an object\n        in the small address area.\n        (enum ia64_addr_area): New type.\n        (small_ident1): New variable.\n        (small_ident2): Likewise.\n        (init_idents): New function.\n        (ia64_get_addr_area): Likewise.\n        (ia64_encode_addr_area): Likewise.\n        (ia64_encode_section_info): Likewise.\n        (ia64_expand_load_address): For symbolic references to objects in\n        the small-address-area, load the address via gen_rtx_SET() (which,\n        eventually, will expand into \"addl\").\n\nFrom-SVN: r70209", "tree": {"sha": "9ec1859d91b52189e69960725b5d8fa34f4ef273", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9ec1859d91b52189e69960725b5d8fa34f4ef273"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a32767e4522942ab7b582da2c60537e0c0034caa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a32767e4522942ab7b582da2c60537e0c0034caa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a32767e4522942ab7b582da2c60537e0c0034caa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a32767e4522942ab7b582da2c60537e0c0034caa/comments", "author": null, "committer": null, "parents": [{"sha": "333384df239a366f7e017c6fb86ec52be139191a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/333384df239a366f7e017c6fb86ec52be139191a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/333384df239a366f7e017c6fb86ec52be139191a"}], "stats": {"total": 205, "additions": 198, "deletions": 7}, "files": [{"sha": "afc2de1fbc92c933730182d59c94568ad77e3a83", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a32767e4522942ab7b582da2c60537e0c0034caa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a32767e4522942ab7b582da2c60537e0c0034caa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a32767e4522942ab7b582da2c60537e0c0034caa", "patch": "@@ -1,3 +1,30 @@\n+2003-08-06  David Mosberger  <davidm@hpl.hp.com>\n+\n+        * doc/extend.texi (Function Attributes): Document the IA-64 version\n+        of the \"model\" attribute.\n+\n+        * config/ia64/ia64.h (SYMBOL_FLAG_SMALL_ADDR): New macro.\n+        (SYMBOL_REF_SMALL_ADDR_P): Ditto.\n+        (PREDICATE_CODES): Mention \"small_addr_symbolic_operand\".\n+\n+        * config/ia64/ia64.c (ia64_handle_model_attribute): New function.\n+        (ia64_encode_section_info): Likewise.\n+        (ia64_attribute_table): Add \"model\" attribute.\n+        (TARGET_ENCODE_SECTION_INFO): Define.\n+        (small_addr_symbolic_operand): New function.\n+        (got_symbolic_operand): Return 0 for a symbolref to an object\n+        in the small address area.\n+        (enum ia64_addr_area): New type.\n+        (small_ident1): New variable.\n+        (small_ident2): Likewise.\n+        (init_idents): New function.\n+        (ia64_get_addr_area): Likewise.\n+        (ia64_encode_addr_area): Likewise.\n+        (ia64_encode_section_info): Likewise.\n+        (ia64_expand_load_address): For symbolic references to objects in\n+        the small-address-area, load the address via gen_rtx_SET() (which,\n+        eventually, will expand into \"addl\").\n+\n 2003-08-06  Per Bothner  <pbothner@apple.com>\n \n \t* line-map.h (fileline):  New typedef."}, {"sha": "f2e27d0105fff111af0bbd947a07f59765c92af8", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 145, "deletions": 2, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a32767e4522942ab7b582da2c60537e0c0034caa/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a32767e4522942ab7b582da2c60537e0c0034caa/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=a32767e4522942ab7b582da2c60537e0c0034caa", "patch": "@@ -262,13 +262,17 @@ static void ia64_hpux_add_extern_decl PARAMS ((const char *name))\n static void ia64_hpux_file_end PARAMS ((void))\n      ATTRIBUTE_UNUSED;\n \n+static tree ia64_handle_model_attribute (tree *, tree, tree, int, bool *);\n+static void ia64_encode_section_info (tree, rtx, int);\n+\n \f\n /* Table of valid machine attributes.  */\n static const struct attribute_spec ia64_attribute_table[] =\n {\n   /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n   { \"syscall_linkage\", 0, 0, false, true,  true,  NULL },\n-  { NULL,              0, 0, false, false, false, NULL }\n+  { \"model\",\t       1, 1, true, false, false, ia64_handle_model_attribute },\n+  { NULL,\t       0, 0, false, false, false, NULL }\n };\n \n /* Initialize the GCC target structure.  */\n@@ -368,6 +372,9 @@ static const struct attribute_spec ia64_attribute_table[] =\n #undef TARGET_MACHINE_DEPENDENT_REORG\n #define TARGET_MACHINE_DEPENDENT_REORG ia64_reorg\n \n+#undef TARGET_ENCODE_SECTION_INFO\n+#define TARGET_ENCODE_SECTION_INFO ia64_encode_section_info\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Return 1 if OP is a valid operand for the MEM of a CALL insn.  */\n@@ -413,6 +420,12 @@ sdata_symbolic_operand (op, mode)\n   return 0;\n }\n \n+int\n+small_addr_symbolic_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  return SYMBOL_REF_SMALL_ADDR_P (op);\n+}\n+\n /* Return 1 if OP refers to a symbol, and is appropriate for a GOT load.  */\n \n int\n@@ -449,6 +462,8 @@ got_symbolic_operand (op, mode)\n       return (INTVAL (op) & 0x3fff) == 0;\n \n     case SYMBOL_REF:\n+      if (SYMBOL_REF_SMALL_ADDR_P (op))\n+\treturn 0;\n     case LABEL_REF:\n       return 1;\n \n@@ -1040,6 +1055,129 @@ basereg_operand (op, mode)\n \t  REG_POINTER ((GET_CODE (op) == SUBREG) ? SUBREG_REG (op) : op));\n }\n \f\n+typedef enum\n+  {\n+    ADDR_AREA_NORMAL,\t/* normal address area */\n+    ADDR_AREA_SMALL\t/* addressable by \"addl\" (-2MB < addr < 2MB) */\n+  }\n+ia64_addr_area;\n+\n+static GTY(()) tree small_ident1;\n+static GTY(()) tree small_ident2;\n+\n+static void\n+init_idents (void)\n+{\n+  if (small_ident1 == 0)\n+    {\n+      small_ident1 = get_identifier (\"small\");\n+      small_ident2 = get_identifier (\"__small__\");\n+    }\n+}\n+\n+/* Retrieve the address area that has been chosen for the given decl.  */\n+\n+static ia64_addr_area\n+ia64_get_addr_area (tree decl)\n+{\n+  tree model_attr;\n+\n+  model_attr = lookup_attribute (\"model\", DECL_ATTRIBUTES (decl));\n+  if (model_attr)\n+    {\n+      tree id;\n+\n+      init_idents ();\n+      id = TREE_VALUE (TREE_VALUE (model_attr));\n+      if (id == small_ident1 || id == small_ident2)\n+\treturn ADDR_AREA_SMALL;\n+    }\n+  return ADDR_AREA_NORMAL;\n+}\n+\n+static tree\n+ia64_handle_model_attribute (tree *node, tree name,\n+\t\t\t     tree args,\n+\t\t\t     int flags ATTRIBUTE_UNUSED,\n+\t\t\t     bool *no_add_attrs)\n+{\n+  ia64_addr_area addr_area = ADDR_AREA_NORMAL;\n+  ia64_addr_area area;\n+  tree arg, decl = *node;\n+\n+  init_idents ();\n+  arg = TREE_VALUE (args);\n+  if (arg == small_ident1 || arg == small_ident2)\n+    {\n+      addr_area = ADDR_AREA_SMALL;\n+    }\n+  else\n+    {\n+      warning (\"invalid argument of `%s' attribute\",\n+\t       IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+\n+  switch (TREE_CODE (decl))\n+    {\n+    case VAR_DECL:\n+      if ((DECL_CONTEXT (decl) && TREE_CODE (DECL_CONTEXT (decl))\n+\t   == FUNCTION_DECL)\n+\t  && !TREE_STATIC (decl))\n+\t{\n+\t  error (\"%Ha an address area attribute cannot be specified for \"\n+\t\t \"local variables\", &DECL_SOURCE_LOCATION (decl), decl);\n+\t  *no_add_attrs = true;\n+\t}\n+      area = ia64_get_addr_area (decl);\n+      if (area != ADDR_AREA_NORMAL && addr_area != area)\n+\t{\n+\t  error (\"%Ha address area of '%s' conflicts with previous \"\n+\t\t \"declaration\", &DECL_SOURCE_LOCATION (decl), decl);\n+\t  *no_add_attrs = true;\n+\t}\n+      break;\n+\n+    case FUNCTION_DECL:\n+      error (\"%Ha address area attribute cannot be specified for functions\",\n+\t     &DECL_SOURCE_LOCATION (decl), decl);\n+      *no_add_attrs = true;\n+      break;\n+\n+    default:\n+      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+      break;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+static void\n+ia64_encode_addr_area (tree decl, rtx symbol)\n+{\n+  int flags;\n+\n+  flags = SYMBOL_REF_FLAGS (symbol);\n+  switch (ia64_get_addr_area (decl))\n+    {\n+    case ADDR_AREA_NORMAL: break;\n+    case ADDR_AREA_SMALL: flags |= SYMBOL_FLAG_SMALL_ADDR; break;\n+    default: abort ();\n+    }\n+  SYMBOL_REF_FLAGS (symbol) = flags;\n+}\n+\n+static void\n+ia64_encode_section_info (tree decl, rtx rtl, int first)\n+{\n+  default_encode_section_info (decl, rtl, first);\n+\n+  if (TREE_CODE (decl) == VAR_DECL\n+      && (TREE_STATIC (decl) || DECL_EXTERNAL (decl)))\n+    ia64_encode_addr_area (decl, XEXP (rtl, 0));\n+}\n+\f\n /* Return 1 if the operands of a move are ok.  */\n \n int\n@@ -1114,7 +1252,12 @@ ia64_expand_load_address (dest, src)\n   if (GET_MODE (dest) != Pmode)\n     dest = gen_rtx_REG (Pmode, REGNO (dest));\n \n-  if (TARGET_AUTO_PIC)\n+  if (GET_CODE (src) == SYMBOL_REF && SYMBOL_REF_SMALL_ADDR_P (src))\n+    {\n+      emit_insn (gen_rtx_SET (VOIDmode, dest, src));\n+      return;\n+    }\n+  else if (TARGET_AUTO_PIC)\n     {\n       emit_insn (gen_load_gprel64 (dest, src));\n       return;"}, {"sha": "fe2c8038ebf0501a9a80ab975deba23aedd31391", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a32767e4522942ab7b582da2c60537e0c0034caa/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a32767e4522942ab7b582da2c60537e0c0034caa/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=a32767e4522942ab7b582da2c60537e0c0034caa", "patch": "@@ -1098,11 +1098,15 @@ enum reg_class\n   (GET_CODE (VALUE) == MEM\t\t\t\t\t\\\n    && GET_RTX_CLASS (GET_CODE (XEXP ((VALUE), 0))) != 'a'\t\\\n    && (reload_in_progress || memory_operand ((VALUE), VOIDmode)))\n+/* Symbol ref to small-address-area: */\n+#define CONSTRAINT_OK_FOR_T(VALUE)\t\t\t\t\t\t\\\n+\t(GET_CODE (VALUE) == SYMBOL_REF && SYMBOL_REF_SMALL_ADDR_P (VALUE))\n \n #define EXTRA_CONSTRAINT(VALUE, C) \\\n   ((C) == 'Q' ? CONSTRAINT_OK_FOR_Q (VALUE)\t\\\n    : (C) == 'R' ? CONSTRAINT_OK_FOR_R (VALUE)\t\\\n    : (C) == 'S' ? CONSTRAINT_OK_FOR_S (VALUE)\t\\\n+   : (C) == 'T' ? CONSTRAINT_OK_FOR_T (VALUE)\t\\\n    : 0)\n \f\n /* Basic Stack Layout */\n@@ -2172,6 +2176,12 @@ do {\t\t\t\t\t\t\t\t\t\\\n \f\n /* Miscellaneous Parameters.  */\n \n+/* Flag to mark data that is in the small address area (addressable\n+   via \"addl\", that is, within a 2MByte offset of 0.  */\n+#define SYMBOL_FLAG_SMALL_ADDR\t\t(SYMBOL_FLAG_MACH_DEP << 0)\n+#define SYMBOL_REF_SMALL_ADDR_P(X)\t\\\n+\t((SYMBOL_REF_FLAGS (X) & SYMBOL_FLAG_SMALL_ADDR) != 0)\n+\n /* Define this if you have defined special-purpose predicates in the file\n    `MACHINE.c'.  For each predicate, list all rtl codes that can be in\n    expressions matched by the predicate.  */\n@@ -2180,6 +2190,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n { \"call_operand\", {SUBREG, REG, SYMBOL_REF}},\t\t\t\t\\\n { \"got_symbolic_operand\", {SYMBOL_REF, CONST, LABEL_REF}},\t\t\\\n { \"sdata_symbolic_operand\", {SYMBOL_REF, CONST}},\t\t\t\\\n+{ \"small_addr_symbolic_operand\", {SYMBOL_REF}},\t\t\t\t\\\n { \"symbolic_operand\", {SYMBOL_REF, CONST, LABEL_REF}},\t\t\t\\\n { \"function_operand\", {SYMBOL_REF}},\t\t\t\t\t\\\n { \"setjmp_operand\", {SYMBOL_REF}},\t\t\t\t\t\\"}, {"sha": "faff0ee5c55fd1d9cf0c9271dbba55dfd41f7e5e", "filename": "gcc/config/ia64/ia64.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a32767e4522942ab7b582da2c60537e0c0034caa/gcc%2Fconfig%2Fia64%2Fia64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a32767e4522942ab7b582da2c60537e0c0034caa/gcc%2Fconfig%2Fia64%2Fia64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.md?ref=a32767e4522942ab7b582da2c60537e0c0034caa", "patch": "@@ -325,7 +325,7 @@\n   [(set (match_operand:DI 0 \"destination_operand\"\n \t\t    \"=r,r,r,r, m, r,*f,*f,*f, Q, r,*b, r,*e, r,*d, r,*c\")\n \t(match_operand:DI 1 \"move_operand\"\n-\t\t    \"rO,J,i,m,rO,*f,rO,*f, Q,*f,*b,rO,*e,rK,*d,rK,*c,rO\"))]\n+\t\t    \"rO,JT,i,m,rO,*f,rO,*f, Q,*f,*b,rO,*e,rK,*d,rK,*c,rO\"))]\n   \"ia64_move_ok (operands[0], operands[1])\"\n {\n   static const char * const alt[] = {"}, {"sha": "f9ac87e3f468fad70cf82df7c7b7d5dd86e1dc7e", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a32767e4522942ab7b582da2c60537e0c0034caa/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a32767e4522942ab7b582da2c60537e0c0034caa/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=a32767e4522942ab7b582da2c60537e0c0034caa", "patch": "@@ -2540,10 +2540,12 @@ the compiler.  It is up to the programmer to provide these sequences.\n \n @item model (@var{model-name})\n @cindex function addressability on the M32R/D\n-Use this attribute on the M32R/D to set the addressability of an object,\n-and of the code generated for a function.\n-The identifier @var{model-name} is one of @code{small}, @code{medium},\n-or @code{large}, representing each of the code models.\n+@cindex variable addressability on the IA-64\n+\n+On the M32R/D, use this attribute to set the addressability of an\n+object, and of the code generated for a function.  The identifier\n+@var{model-name} is one of @code{small}, @code{medium}, or\n+@code{large}, representing each of the code models.\n \n Small model objects live in the lower 16MB of memory (so that their\n addresses can be loaded with the @code{ld24} instruction), and are\n@@ -2558,6 +2560,14 @@ compiler will generate @code{seth/add3} instructions to load their addresses),\n and may not be reachable with the @code{bl} instruction (the compiler will\n generate the much slower @code{seth/add3/jl} instruction sequence).\n \n+On IA-64, use this attribute to set the addressability of an object.\n+At present, the only supported identifier for @var{model-name} is\n+@code{small}, indicating addressability via ``small'' (22-bit)\n+addresses (so that their addresses can be loaded with the @code{addl}\n+instruction).  Caveat: such addressing is by definition not position\n+independent and hence this attribute must not be used for objects\n+defined by shared libraries.\n+\n @item far\n @cindex functions which handle memory bank switching\n On 68HC11 and 68HC12 the @code{far} attribute causes the compiler to"}]}