{"sha": "1aa4ccd4289970165bdfe3b39de3db0f4ed75af3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWFhNGNjZDQyODk5NzAxNjViZGZlM2IzOWRlM2RiMGY0ZWQ3NWFmMw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "sidwell@codesourcery.com", "date": "2000-01-24T10:59:02Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2000-01-24T10:59:02Z"}, "message": "cp-tree.h (get_vtable_decl): Prototype new function.\n\n\t* cp-tree.h (get_vtable_decl): Prototype new function.\n\t* class.c (get_vtable_decl): New function. Broken out from ...\n\t(build_vtable): ... here. Use it.\n\t* decl2.c (finish_vtable_vardecl): Ignore dummy vtables created\n\tby get_vtable_decl.\n\nFrom-SVN: r31583", "tree": {"sha": "2439ae1d2be86a3c044f0296508ee341d9dba2e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2439ae1d2be86a3c044f0296508ee341d9dba2e9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1aa4ccd4289970165bdfe3b39de3db0f4ed75af3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1aa4ccd4289970165bdfe3b39de3db0f4ed75af3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1aa4ccd4289970165bdfe3b39de3db0f4ed75af3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1aa4ccd4289970165bdfe3b39de3db0f4ed75af3/comments", "author": null, "committer": null, "parents": [{"sha": "db1147b2e23d260580bb08ce65259b28abe1d0fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db1147b2e23d260580bb08ce65259b28abe1d0fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db1147b2e23d260580bb08ce65259b28abe1d0fd"}], "stats": {"total": 90, "additions": 67, "deletions": 23}, "files": [{"sha": "c50831b139fc4300dc14f6461b29acc5d0d1c058", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1aa4ccd4289970165bdfe3b39de3db0f4ed75af3/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1aa4ccd4289970165bdfe3b39de3db0f4ed75af3/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=1aa4ccd4289970165bdfe3b39de3db0f4ed75af3", "patch": "@@ -1,3 +1,11 @@\n+2000-01-24  Nathan Sidwell  <sidwell@codesourcery.com>\n+\n+\t* cp-tree.h (get_vtable_decl): Prototype new function.\n+\t* class.c (get_vtable_decl): New function. Broken out from ...\n+\t(build_vtable): ... here. Use it.\n+\t* decl2.c (finish_vtable_vardecl): Ignore dummy vtables created\n+\tby get_vtable_decl.\n+\n 2000-01-24  Nathan Sidwell  <sidwell@codesourcery.com>\n \n \t* cp-tree.h (CPTI_TP_DESC_TYPE, CPTI_ACCESS_MODE_TYPE,"}, {"sha": "c14232476824b0633859a156e43690f4de5352fe", "filename": "gcc/cp/class.c", "status": "modified", "additions": 54, "deletions": 23, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1aa4ccd4289970165bdfe3b39de3db0f4ed75af3/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1aa4ccd4289970165bdfe3b39de3db0f4ed75af3/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=1aa4ccd4289970165bdfe3b39de3db0f4ed75af3", "patch": "@@ -853,6 +853,54 @@ set_rtti_entry (virtuals, offset, type)\n   TREE_VALUE (virtuals) = fn;\n }\n \n+/* Get the VAR_DECL of the vtable for TYPE. TYPE need not be polymorphic,\n+   or even complete.  If this does not exist, create it.  If COMPLETE is\n+   non-zero, then complete the definition of it -- that will render it\n+   impossible to actually build the vtable, but is useful to get at those\n+   which are known to exist in the runtime.  */\n+\n+tree get_vtable_decl (type, complete)\n+     tree type;\n+     int complete;\n+{\n+  tree name = get_vtable_name (type);\n+  tree decl = IDENTIFIER_GLOBAL_VALUE (name);\n+  \n+  if (decl)\n+    {\n+      my_friendly_assert (TREE_CODE (decl) == VAR_DECL\n+                          && DECL_VIRTUAL_P (decl), 20000118);\n+      return decl;\n+    }\n+  \n+  decl = build_lang_decl (VAR_DECL, name, void_type_node);\n+  \n+  /* Set TREE_PUBLIC and TREE_EXTERN as appropriate.  */\n+  import_export_vtable (decl, type, 0);\n+\n+  decl = pushdecl_top_level (decl);\n+  SET_IDENTIFIER_GLOBAL_VALUE (name, decl);\n+  \n+  DECL_ARTIFICIAL (decl) = 1;\n+  TREE_STATIC (decl) = 1;\n+#ifndef WRITABLE_VTABLES\n+  /* Make them READONLY by default. (mrs) */\n+  TREE_READONLY (decl) = 1;\n+#endif\n+  /* At one time the vtable info was grabbed 2 words at a time.  This\n+     fails on sparc unless you have 8-byte alignment.  (tiemann) */\n+  DECL_ALIGN (decl) = MAX (TYPE_ALIGN (double_type_node),\n+\t\t\t   DECL_ALIGN (decl));\n+\n+  DECL_VIRTUAL_P (decl) = 1;\n+  \n+  if (complete)\n+    cp_finish_decl (decl, NULL_TREE, NULL_TREE, 0);\n+\n+  DECL_CONTEXT (decl) = type;\n+  return decl;\n+}\n+\n /* Build a virtual function for type TYPE.\n    If BINFO is non-NULL, build the vtable starting with the initial\n    approximation that it is the same as the one which is the head of\n@@ -862,9 +910,10 @@ static void\n build_vtable (binfo, type)\n      tree binfo, type;\n {\n-  tree name = get_vtable_name (type);\n   tree virtuals, decl;\n \n+  decl = get_vtable_decl (type, /*complete=*/0);\n+  \n   if (binfo)\n     {\n       tree offset;\n@@ -875,8 +924,8 @@ build_vtable (binfo, type)\n \treturn;\n \n       virtuals = copy_list (BINFO_VIRTUALS (binfo));\n-      decl = build_lang_decl (VAR_DECL, name, \n-\t\t\t      TREE_TYPE (BINFO_VTABLE (binfo)));\n+      TREE_TYPE (decl) = TREE_TYPE (BINFO_VTABLE (binfo));\n+      DECL_SIZE (decl) = TYPE_SIZE (TREE_TYPE (BINFO_VTABLE (binfo)));\n \n       /* Now do rtti stuff.  */\n       offset = get_derived_offset (TYPE_BINFO (type), NULL_TREE);\n@@ -885,39 +934,21 @@ build_vtable (binfo, type)\n     }\n   else\n     {\n+      my_friendly_assert (TREE_CODE (TREE_TYPE (decl)) == VOID_TYPE,\n+                          20000118);\n       virtuals = NULL_TREE;\n-      decl = build_lang_decl (VAR_DECL, name, void_type_node);\n     }\n \n #ifdef GATHER_STATISTICS\n   n_vtables += 1;\n   n_vtable_elems += list_length (virtuals);\n #endif\n \n-  /* Set TREE_PUBLIC and TREE_EXTERN as appropriate.  */\n-  import_export_vtable (decl, type, 0);\n-\n-  decl = pushdecl_top_level (decl);\n-  SET_IDENTIFIER_GLOBAL_VALUE (name, decl);\n   /* Initialize the association list for this type, based\n      on our first approximation.  */\n   TYPE_BINFO_VTABLE (type) = decl;\n   TYPE_BINFO_VIRTUALS (type) = virtuals;\n \n-  DECL_ARTIFICIAL (decl) = 1;\n-  TREE_STATIC (decl) = 1;\n-#ifndef WRITABLE_VTABLES\n-  /* Make them READONLY by default. (mrs) */\n-  TREE_READONLY (decl) = 1;\n-#endif\n-  /* At one time the vtable info was grabbed 2 words at a time.  This\n-     fails on sparc unless you have 8-byte alignment.  (tiemann) */\n-  DECL_ALIGN (decl) = MAX (TYPE_ALIGN (double_type_node),\n-\t\t\t   DECL_ALIGN (decl));\n-\n-  DECL_VIRTUAL_P (decl) = 1;\n-  DECL_CONTEXT (decl) = type;\n-\n   binfo = TYPE_BINFO (type);\n   SET_BINFO_NEW_VTABLE_MARKED (binfo);\n }"}, {"sha": "8b2a3df247566600462fd66bb15c71b9d5b3e4f8", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1aa4ccd4289970165bdfe3b39de3db0f4ed75af3/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1aa4ccd4289970165bdfe3b39de3db0f4ed75af3/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=1aa4ccd4289970165bdfe3b39de3db0f4ed75af3", "patch": "@@ -3492,6 +3492,7 @@ extern tree perform_implicit_conversion         PROTO((tree, tree));\n extern tree build_vbase_path\t\t\tPROTO((enum tree_code, tree, tree, tree, int));\n extern tree build_vtbl_ref\t\t\tPROTO((tree, tree));\n extern tree build_vfn_ref\t\t\tPROTO((tree *, tree, tree));\n+extern tree get_vtable_decl                     PROTO((tree, int));\n extern void add_method\t\t\t\tPROTO((tree, tree *, tree));\n extern int currently_open_class\t\t\tPROTO((tree));\n extern tree get_vfield_offset\t\t\tPROTO((tree));"}, {"sha": "51f02ecea4bc3b60de75c3a5acf71f04f9d56fd0", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1aa4ccd4289970165bdfe3b39de3db0f4ed75af3/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1aa4ccd4289970165bdfe3b39de3db0f4ed75af3/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=1aa4ccd4289970165bdfe3b39de3db0f4ed75af3", "patch": "@@ -2551,6 +2551,10 @@ finish_vtable_vardecl (t, data)\n \t  || (hack_decl_function_context (vars) && TREE_USED (vars)))\n       && ! TREE_ASM_WRITTEN (vars))\n     {\n+      if (TREE_TYPE (vars) == void_type_node)\n+        /* It is a dummy vtable made by get_vtable_decl. Ignore it.  */\n+        return 0;\n+      \n       /* Write it out.  */\n       mark_vtable_entries (vars);\n       if (TREE_TYPE (DECL_INITIAL (vars)) == 0)"}]}