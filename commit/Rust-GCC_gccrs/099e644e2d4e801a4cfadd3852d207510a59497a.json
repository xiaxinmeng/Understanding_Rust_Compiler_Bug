{"sha": "099e644e2d4e801a4cfadd3852d207510a59497a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDk5ZTY0NGUyZDRlODAxYTRjZmFkZDM4NTJkMjA3NTEwYTU5NDk3YQ==", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2012-10-27T12:20:18Z"}, "committer": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2012-10-27T12:20:18Z"}, "message": "unordered_map.h (unordered_map<>): Prefer aggregation to inheritance with _Hashtable.\n\n2012-10-27  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n\n\t* include/bits/unordered_map.h (unordered_map<>): Prefer\n\taggregation to inheritance with _Hashtable.\n\t(unordered_multimap<>): Likewise.\n\t* include/bits/unordered_set.h\n\t(unordered_set<>(const unordered_set&)):  Use default\n\timplementation.\n\t(unordered_set<>(unordered_set&&)): Likewise.\n\t(unordered_set<>::operator=(const unordered_set&)): Likewise.\n\t(unordered_set<>::operator=(unordered_set&&)): Likewise.\n\t(unordered_multiset<>(const unordered_multiset&)): Likewise.\n\t(unordered_multiset<>(unordered_multiset&&)): Likewise.\n\t(unordered_multiset<>::operator=(const unordered_multiset&)):\n\tLikewise.\n\t(unordered_multiset<>::operator=(unordered_multiset&&)): Likewise.\n\t* include/debug/unordered_map (operator==): Adapt.\n\t* include/profile/unordered_map (operator==): Adapt.\n\nFrom-SVN: r192876", "tree": {"sha": "debbb2fe9eace0f2432c1f441c4d639bf4eba0d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/debbb2fe9eace0f2432c1f441c4d639bf4eba0d4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/099e644e2d4e801a4cfadd3852d207510a59497a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/099e644e2d4e801a4cfadd3852d207510a59497a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/099e644e2d4e801a4cfadd3852d207510a59497a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/099e644e2d4e801a4cfadd3852d207510a59497a/comments", "author": null, "committer": null, "parents": [{"sha": "7999d7b4e6f6a225d8afddd54fd499ec6448a0cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7999d7b4e6f6a225d8afddd54fd499ec6448a0cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7999d7b4e6f6a225d8afddd54fd499ec6448a0cd"}], "stats": {"total": 1354, "additions": 1230, "deletions": 124}, "files": [{"sha": "fa0ce759d61875de78238888c90e46bec77a49be", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/099e644e2d4e801a4cfadd3852d207510a59497a/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/099e644e2d4e801a4cfadd3852d207510a59497a/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=099e644e2d4e801a4cfadd3852d207510a59497a", "patch": "@@ -1,3 +1,22 @@\n+2012-10-27  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n+\n+\t* include/bits/unordered_map.h (unordered_map<>): Prefer\n+\taggregation to inheritance with _Hashtable.\n+\t(unordered_multimap<>): Likewise.\n+\t* include/bits/unordered_set.h\n+\t(unordered_set<>(const unordered_set&)):  Use default\n+\timplementation.\n+\t(unordered_set<>(unordered_set&&)): Likewise.\n+\t(unordered_set<>::operator=(const unordered_set&)): Likewise.\n+\t(unordered_set<>::operator=(unordered_set&&)): Likewise.\n+\t(unordered_multiset<>(const unordered_multiset&)): Likewise.\n+\t(unordered_multiset<>(unordered_multiset&&)): Likewise.\n+\t(unordered_multiset<>::operator=(const unordered_multiset&)):\n+\tLikewise.\n+\t(unordered_multiset<>::operator=(unordered_multiset&&)): Likewise.\n+\t* include/debug/unordered_map (operator==): Adapt.\n+\t* include/profile/unordered_map (operator==): Adapt.\n+\n 2012-10-24  Daniel Krugler  <daniel.kruegler@gmail.com>\n \n \t* include/std/type_traits (common_type): Implement LWG 2141."}, {"sha": "973467e3b7d96c1e8e74d48fd0349c1b481b184b", "filename": "libstdc++-v3/include/bits/unordered_map.h", "status": "modified", "additions": 1189, "deletions": 22, "changes": 1211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/099e644e2d4e801a4cfadd3852d207510a59497a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/099e644e2d4e801a4cfadd3852d207510a59497a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_map.h?ref=099e644e2d4e801a4cfadd3852d207510a59497a", "patch": "@@ -95,41 +95,654 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t   class _Pred = std::equal_to<_Key>,\n \t   class _Alloc = std::allocator<std::pair<const _Key, _Tp> > >\n     class unordered_map\n-    : public __umap_hashtable<_Key, _Tp, _Hash, _Pred, _Alloc>\n     {\n-      typedef __umap_hashtable<_Key, _Tp, _Hash, _Pred, _Alloc>  _Base;\n+      typedef __umap_hashtable<_Key, _Tp, _Hash, _Pred, _Alloc>  _Hashtable;\n+      _Hashtable _M_h;\n \n     public:\n-      typedef typename _Base::value_type      value_type;\n-      typedef typename _Base::size_type       size_type;\n-      typedef typename _Base::hasher          hasher;\n-      typedef typename _Base::key_equal       key_equal;\n-      typedef typename _Base::allocator_type  allocator_type;\n+      // typedefs:\n+      //@{\n+      /// Public typedefs.\n+      typedef typename _Hashtable::key_type\tkey_type;\n+      typedef typename _Hashtable::value_type\tvalue_type;\n+      typedef typename _Hashtable::mapped_type\tmapped_type;\n+      typedef typename _Hashtable::hasher\thasher;\n+      typedef typename _Hashtable::key_equal\tkey_equal;\n+      typedef typename _Hashtable::allocator_type allocator_type;\n+      //@}\n \n+      //@{\n+      ///  Iterator-related typedefs.\n+      typedef typename allocator_type::pointer\t\tpointer;\n+      typedef typename allocator_type::const_pointer\tconst_pointer;\n+      typedef typename allocator_type::reference\treference;\n+      typedef typename allocator_type::const_reference\tconst_reference;\n+      typedef typename _Hashtable::iterator\t\titerator;\n+      typedef typename _Hashtable::const_iterator\tconst_iterator;\n+      typedef typename _Hashtable::local_iterator\tlocal_iterator;\n+      typedef typename _Hashtable::const_local_iterator\tconst_local_iterator;\n+      typedef typename _Hashtable::size_type\t\tsize_type;\n+      typedef typename _Hashtable::difference_type\tdifference_type;\n+      //@}\n+\n+      //construct/destroy/copy\n+\n+      /**\n+       *  @brief  Default constructor creates no elements.\n+       *  @param __n  Initial number of buckets.\n+       *  @param __hf  A hash functor.\n+       *  @param __eql  A key equality functor.\n+       *  @param __a  An allocator object.\n+       */\n       explicit\n       unordered_map(size_type __n = 10,\n \t\t    const hasher& __hf = hasher(),\n \t\t    const key_equal& __eql = key_equal(),\n \t\t    const allocator_type& __a = allocator_type())\n-      : _Base(__n, __hf, __eql, __a)\n+      : _M_h(__n, __hf, __eql, __a)\n       { }\n \n+      /**\n+       *  @brief  Builds an %unordered_map from a range.\n+       *  @param  __first  An input iterator.\n+       *  @param  __last  An input iterator.\n+       *  @param __n  Minimal initial number of buckets.\n+       *  @param __hf  A hash functor.\n+       *  @param __eql  A key equality functor.\n+       *  @param __a  An allocator object.\n+       *\n+       *  Create an %unordered_map consisting of copies of the elements from\n+       *  [__first,__last).  This is linear in N (where N is\n+       *  distance(__first,__last)).\n+       */\n       template<typename _InputIterator>\n \tunordered_map(_InputIterator __f, _InputIterator __l,\n \t\t      size_type __n = 0,\n \t\t      const hasher& __hf = hasher(),\n \t\t      const key_equal& __eql = key_equal(),\n \t\t      const allocator_type& __a = allocator_type())\n-\t: _Base(__f, __l, __n, __hf, __eql, __a)\n+\t: _M_h(__f, __l, __n, __hf, __eql, __a)\n \t{ }\n \n+      /// Copy constructor.\n+      unordered_map(const unordered_map&) = default;\n+\n+      /// Move constrcutor.\n+      unordered_map(unordered_map&&) = default;\n+\n+      /**\n+       *  @brief  Builds an %unordered_map from an initializer_list.\n+       *  @param  __l  An initializer_list.\n+       *  @param __n  Minimal initial number of buckets.\n+       *  @param __hf  A hash functor.\n+       *  @param __eql  A key equality functor.\n+       *  @param  __a  An allocator object.\n+       *\n+       *  Create an %unordered_map consisting of copies of the elements in the\n+       *  list. This is linear in N (where N is @a __l.size()).\n+       */\n       unordered_map(initializer_list<value_type> __l,\n \t\t    size_type __n = 0,\n \t\t    const hasher& __hf = hasher(),\n \t\t    const key_equal& __eql = key_equal(),\n \t\t    const allocator_type& __a = allocator_type())\n-      : _Base(__l.begin(), __l.end(), __n, __hf, __eql, __a)\n+\t: _M_h(__l, __n, __hf, __eql, __a)\n       { }\n+\n+      /// Copy assignment operator.\n+      unordered_map&\n+      operator=(const unordered_map&) = default;\n+\n+      /// Move assignment operator.\n+      unordered_map&\n+      operator=(unordered_map&&) = default;\n+\n+      /**\n+       *  @brief  %Unordered_map list assignment operator.\n+       *  @param  __l  An initializer_list.\n+       *\n+       *  This function fills an %unordered_map with copies of the elements in\n+       *  the initializer list @a __l.\n+       *\n+       *  Note that the assignment completely changes the %unordered_map and\n+       *  that the resulting %unordered_map's size is the same as the number\n+       *  of elements assigned.  Old data may be lost.\n+       */\n+      unordered_map&\n+      operator=(initializer_list<value_type> __l)\n+      {\n+\t_M_h = __l;\n+\treturn *this;\n+      }\n+\n+      ///  Returns the allocator object with which the %unordered_map was\n+      ///  constructed.\n+      allocator_type\n+      get_allocator() const noexcept\n+      { return _M_h.get_allocator(); }\n+\n+      // size and capacity:\n+\n+      ///  Returns true if the %unordered_map is empty.\n+      bool\n+      empty() const noexcept\n+      { return _M_h.empty(); }\n+\n+      ///  Returns the size of the %unordered_map.\n+      size_type\n+      size() const noexcept\n+      { return _M_h.size(); }\n+\n+      ///  Returns the maximum size of the %unordered_map.\n+      size_type\n+      max_size() const noexcept\n+      { return _M_h.max_size(); }\n+\n+      // iterators.\n+\n+      /**\n+       *  Returns a read/write iterator that points to the first element in the\n+       *  %unordered_map.\n+       */\n+      iterator\n+      begin() noexcept\n+      { return _M_h.begin(); }\n+\n+      //@{\n+      /**\n+       *  Returns a read-only (constant) iterator that points to the first\n+       *  element in the %unordered_map.\n+       */\n+      const_iterator\n+      begin() const noexcept\n+      { return _M_h.begin(); }\n+\n+      const_iterator\n+      cbegin() const noexcept\n+      { return _M_h.begin(); }\n+      //@}\n+\n+      /**\n+       *  Returns a read/write iterator that points one past the last element in\n+       *  the %unordered_map.\n+       */\n+      iterator\n+      end() noexcept\n+      { return _M_h.end(); }\n+\n+      //@{\n+      /**\n+       *  Returns a read-only (constant) iterator that points one past the last\n+       *  element in the %unordered_map.\n+       */\n+      const_iterator\n+      end() const noexcept\n+      { return _M_h.end(); }\n+\n+      const_iterator\n+      cend() const noexcept\n+      { return _M_h.end(); }\n+      //@}\n+\n+      // modifiers.\n+\n+      /**\n+       *  @brief Attempts to build and insert a std::pair into the %unordered_map.\n+       *\n+       *  @param __args  Arguments used to generate a new pair instance (see\n+       *\t        std::piecewise_contruct for passing arguments to each\n+       *\t        part of the pair constructor).\n+       *\n+       *  @return  A pair, of which the first element is an iterator that points\n+       *           to the possibly inserted pair, and the second is a bool that\n+       *           is true if the pair was actually inserted.\n+       *\n+       *  This function attempts to build and insert a (key, value) %pair into\n+       *  the %unordered_map.\n+       *  An %unordered_map relies on unique keys and thus a %pair is only\n+       *  inserted if its first element (the key) is not already present in the\n+       *  %unordered_map.\n+       *\n+       *  Insertion requires amortized constant time.\n+       */\n+      template<typename... _Args>\n+\tstd::pair<iterator, bool>\n+\templace(_Args&&... __args)\n+\t{ return _M_h.emplace(std::forward<_Args>(__args)...); }\n+\n+      /**\n+       *  @brief Attempts to build and insert a std::pair into the %unordered_map.\n+       *\n+       *  @param  __pos  An iterator that serves as a hint as to where the pair\n+       *                should be inserted.\n+       *  @param  __args  Arguments used to generate a new pair instance (see\n+       *\t         std::piecewise_contruct for passing arguments to each\n+       *\t         part of the pair constructor).\n+       *  @return An iterator that points to the element with key of the\n+       *          std::pair built from @a __args (may or may not be that\n+       *          std::pair).\n+       *\n+       *  This function is not concerned about whether the insertion took place,\n+       *  and thus does not return a boolean like the single-argument emplace()\n+       *  does.\n+       *  Note that the first parameter is only a hint and can potentially\n+       *  improve the performance of the insertion process. A bad hint would\n+       *  cause no gains in efficiency.\n+       *\n+       *  See\n+       *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt07ch17.html\n+       *  for more on @a hinting.\n+       *\n+       *  Insertion requires amortized constant time.\n+       */\n+      template<typename... _Args>\n+\titerator\n+\templace_hint(const_iterator __pos, _Args&&... __args)\n+\t{ return _M_h.emplace_hint(__pos, std::forward<_Args>(__args)...); }\n+\n+      //@{\n+      /**\n+       *  @brief Attempts to insert a std::pair into the %unordered_map.\n+\n+       *  @param __x Pair to be inserted (see std::make_pair for easy\n+       *\t     creation of pairs).\n+       *\n+       *  @return  A pair, of which the first element is an iterator that \n+       *           points to the possibly inserted pair, and the second is \n+       *           a bool that is true if the pair was actually inserted.\n+       *\n+       *  This function attempts to insert a (key, value) %pair into the\n+       *  %unordered_map. An %unordered_map relies on unique keys and thus a\n+       *  %pair is only inserted if its first element (the key) is not already\n+       *  present in the %unordered_map.\n+       *\n+       *  Insertion requires amortized constant time.\n+       */\n+      std::pair<iterator, bool>\n+      insert(const value_type& __x)\n+      { return _M_h.insert(__x); }\n+\n+      template<typename _Pair>\n+\tstd::pair<iterator, bool>\n+\tinsert(_Pair&& __x)\n+\t{ return _M_h.insert(std::move(__x)); }\n+      //@}\n+\n+      //@{\n+      /**\n+       *  @brief Attempts to insert a std::pair into the %unordered_map.\n+       *  @param  __hint  An iterator that serves as a hint as to where the\n+       *                 pair should be inserted.\n+       *  @param  __x  Pair to be inserted (see std::make_pair for easy creation\n+       *               of pairs).\n+       *  @return An iterator that points to the element with key of\n+       *           @a __x (may or may not be the %pair passed in).\n+       *\n+       *  This function is not concerned about whether the insertion took place,\n+       *  and thus does not return a boolean like the single-argument insert()\n+       *  does.  Note that the first parameter is only a hint and can\n+       *  potentially improve the performance of the insertion process.  A bad\n+       *  hint would cause no gains in efficiency.\n+       *\n+       *  See\n+       *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt07ch17.html\n+       *  for more on @a hinting.\n+       *\n+       *  Insertion requires amortized constant time.\n+       */\n+      iterator\n+      insert(const_iterator __hint, const value_type& __x)\n+      { return _M_h.insert(__hint, __x); }\n+\n+      template<typename _Pair>\n+\titerator\n+\tinsert(const_iterator __hint, _Pair&& __x)\n+\t{ return _M_h.insert(__hint, std::move(__x)); }\n+      //@}\n+\n+      /**\n+       *  @brief A template function that attempts to insert a range of\n+       *  elements.\n+       *  @param  __first  Iterator pointing to the start of the range to be\n+       *                   inserted.\n+       *  @param  __last  Iterator pointing to the end of the range.\n+       *\n+       *  Complexity similar to that of the range constructor.\n+       */\n+      template<typename _InputIterator>\n+\tvoid\n+\tinsert(_InputIterator __first, _InputIterator __last)\n+\t{ _M_h.insert(__first, __last); }\n+\n+      /**\n+       *  @brief Attempts to insert a list of elements into the %unordered_map.\n+       *  @param  __l  A std::initializer_list<value_type> of elements\n+       *               to be inserted.\n+       *\n+       *  Complexity similar to that of the range constructor.\n+       */\n+      void\n+      insert(initializer_list<value_type> __l)\n+      { _M_h.insert(__l); }\n+\n+      //@{\n+      /**\n+       *  @brief Erases an element from an %unordered_map.\n+       *  @param  __position  An iterator pointing to the element to be erased.\n+       *  @return An iterator pointing to the element immediately following\n+       *          @a __position prior to the element being erased. If no such\n+       *          element exists, end() is returned.\n+       *\n+       *  This function erases an element, pointed to by the given iterator,\n+       *  from an %unordered_map.\n+       *  Note that this function only erases the element, and that if the\n+       *  element is itself a pointer, the pointed-to memory is not touched in\n+       *  any way.  Managing the pointer is the user's responsibility.\n+       */\n+      iterator\n+      erase(const_iterator __position)\n+      { return _M_h.erase(__position); }\n+\n+      // LWG 2059.\n+      iterator\n+      erase(iterator __it)\n+      { return _M_h.erase(__it); }\n+      //@}\n+\n+      /**\n+       *  @brief Erases elements according to the provided key.\n+       *  @param  __x  Key of element to be erased.\n+       *  @return  The number of elements erased.\n+       *\n+       *  This function erases all the elements located by the given key from\n+       *  an %unordered_map. For an %unordered_map the result of this function\n+       *  can only be 0 (not present) or 1 (present).\n+       *  Note that this function only erases the element, and that if the\n+       *  element is itself a pointer, the pointed-to memory is not touched in\n+       *  any way.  Managing the pointer is the user's responsibility.\n+       */\n+      size_type\n+      erase(const key_type& __x)\n+      { return _M_h.erase(__x); }\n+\n+      /**\n+       *  @brief Erases a [__first,__last) range of elements from an\n+       *  %unordered_map.\n+       *  @param  __first  Iterator pointing to the start of the range to be\n+       *                  erased.\n+       *  @param __last  Iterator pointing to the end of the range to\n+       *                be erased.\n+       *  @return The iterator @a __last.\n+       *\n+       *  This function erases a sequence of elements from an %unordered_map.\n+       *  Note that this function only erases the elements, and that if\n+       *  the element is itself a pointer, the pointed-to memory is not touched\n+       *  in any way.  Managing the pointer is the user's responsibility.\n+       */\n+      iterator\n+      erase(const_iterator __first, const_iterator __last)\n+      { return _M_h.erase(__first, __last); }\n+\n+      /**\n+       *  Erases all elements in an %unordered_map.\n+       *  Note that this function only erases the elements, and that if the\n+       *  elements themselves are pointers, the pointed-to memory is not touched\n+       *  in any way.  Managing the pointer is the user's responsibility.\n+       */\n+      void\n+      clear() noexcept\n+      { _M_h.clear(); }\n+\n+      /**\n+       *  @brief  Swaps data with another %unordered_map.\n+       *  @param  __x  An %unordered_map of the same element and allocator\n+       *  types.\n+       *\n+       *  This exchanges the elements between two %unordered_map in constant time.\n+       *  Note that the global std::swap() function is specialized such that\n+       *  std::swap(m1,m2) will feed to this function.\n+       */\n+      void\n+      swap(unordered_map& __x)\n+      { _M_h.swap(__x._M_h); }\n+\n+      // observers.\n+\n+      ///  Returns the hash functor object with which the %unordered_map was\n+      ///  constructed.\n+      hasher\n+      hash_function() const\n+      { return _M_h.hash_function(); }\n+\n+      ///  Returns the key comparison object with which the %unordered_map was\n+      ///  constructed.\n+      key_equal\n+      key_eq() const\n+      { return _M_h.key_eq(); }\n+\n+      // lookup.\n+\n+      //@{\n+      /**\n+       *  @brief Tries to locate an element in an %unordered_map.\n+       *  @param  __x  Key to be located.\n+       *  @return  Iterator pointing to sought-after element, or end() if not\n+       *           found.\n+       *\n+       *  This function takes a key and tries to locate the element with which\n+       *  the key matches.  If successful the function returns an iterator\n+       *  pointing to the sought after element.  If unsuccessful it returns the\n+       *  past-the-end ( @c end() ) iterator.\n+       */\n+      iterator\n+      find(const key_type& __x)\n+      { return _M_h.find(__x); }\n+\n+      const_iterator\n+      find(const key_type& __x) const\n+      { return _M_h.find(__x); }\n+      //@}\n+\n+      /**\n+       *  @brief  Finds the number of elements.\n+       *  @param  __x  Key to count.\n+       *  @return  Number of elements with specified key.\n+       *\n+       *  This function only makes sense for %unordered_multimap; for\n+       *  %unordered_map the result will either be 0 (not present) or 1\n+       *  (present).\n+       */\n+      size_type\n+      count(const key_type& __x) const\n+      { return _M_h.count(__x); }\n+\n+      //@{\n+      /**\n+       *  @brief Finds a subsequence matching given key.\n+       *  @param  __x  Key to be located.\n+       *  @return  Pair of iterators that possibly points to the subsequence\n+       *           matching given key.\n+       *\n+       *  This function probably only makes sense for %unordered_multimap.\n+       */\n+      std::pair<iterator, iterator>\n+      equal_range(const key_type& __x)\n+      { return _M_h.equal_range(__x); }\n+\n+      std::pair<const_iterator, const_iterator>\n+      equal_range(const key_type& __x) const\n+      { return _M_h.equal_range(__x); }\n+      //@}\n+\n+      //@{\n+      /**\n+       *  @brief  Subscript ( @c [] ) access to %unordered_map data.\n+       *  @param  __k  The key for which data should be retrieved.\n+       *  @return  A reference to the data of the (key,data) %pair.\n+       *\n+       *  Allows for easy lookup with the subscript ( @c [] )operator.  Returns\n+       *  data associated with the key specified in subscript.  If the key does\n+       *  not exist, a pair with that key is created using default values, which\n+       *  is then returned.\n+       *\n+       *  Lookup requires constant time.\n+       */\n+      mapped_type&\n+      operator[](const key_type& __k)\n+      { return _M_h[__k]; }\n+\n+      mapped_type&\n+      operator[](key_type&& __k)\n+      { return _M_h[std::move(__k)]; }\n+      //@}\n+\n+      //@{\n+      /**\n+       *  @brief  Access to %unordered_map data.\n+       *  @param  __k  The key for which data should be retrieved.\n+       *  @return  A reference to the data whose key is equal to @a __k, if\n+       *           such a data is present in the %unordered_map.\n+       *  @throw  std::out_of_range  If no such data is present.\n+       */\n+      mapped_type&\n+      at(const key_type& __k)\n+      { return _M_h.at(__k); }\n+\n+      const mapped_type&\n+      at(const key_type& __k) const\n+      { return _M_h.at(__k); }\n+      //@}\n+\n+      // bucket interface.\n+\n+      /// Returns the number of buckets of the %unordered_map.\n+      size_type\n+      bucket_count() const noexcept\n+      { return _M_h.bucket_count(); }\n+\n+      /// Returns the maximum number of buckets of the %unordered_map.\n+      size_type\n+      max_bucket_count() const noexcept\n+      { return _M_h.max_bucket_count(); }\n+\n+      /*\n+       * @brief  Returns the number of elements in a given bucket.\n+       * @param  __n  A bucket index.\n+       * @return  The number of elements in the bucket.\n+       */\n+      size_type\n+      bucket_size(size_type __n) const\n+      { return _M_h.bucket_size(__n); }\n+\n+      /*\n+       * @brief  Returns the bucket index of a given element.\n+       * @param  __key  A key instance.\n+       * @return  The key bucket index.\n+       */\n+      size_type\n+      bucket(const key_type& __key) const\n+      { return _M_h.bucket(__key); }\n+      \n+      /**\n+       *  @brief  Returns a read/write iterator pointing to the first bucket\n+       *         element.\n+       *  @param  __n The bucket index.\n+       *  @return  A read/write local iterator.\n+       */\n+      local_iterator\n+      begin(size_type __n)\n+      { return _M_h.begin(__n); }\n+\n+      //@{\n+      /**\n+       *  @brief  Returns a read-only (constant) iterator pointing to the first\n+       *         bucket element.\n+       *  @param  __n The bucket index.\n+       *  @return  A read-only local iterator.\n+       */\n+      const_local_iterator\n+      begin(size_type __n) const\n+      { return _M_h.begin(__n); }\n+\n+      const_local_iterator\n+      cbegin(size_type __n) const\n+      { return _M_h.cbegin(__n); }\n+      //@}\n+\n+      /**\n+       *  @brief  Returns a read/write iterator pointing to one past the last\n+       *         bucket elements.\n+       *  @param  __n The bucket index.\n+       *  @return  A read/write local iterator.\n+       */\n+      local_iterator\n+      end(size_type __n)\n+      { return _M_h.end(__n); }\n+\n+      //@{\n+      /**\n+       *  @brief  Returns a read-only (constant) iterator pointing to one past\n+       *         the last bucket elements.\n+       *  @param  __n The bucket index.\n+       *  @return  A read-only local iterator.\n+       */\n+      const_local_iterator\n+      end(size_type __n) const\n+      { return _M_h.end(__n); }\n+\n+      const_local_iterator\n+      cend(size_type __n) const\n+      { return _M_h.cend(__n); }\n+      //@}\n+\n+      // hash policy.\n+\n+      /// Returns the average number of elements per bucket.\n+      float\n+      load_factor() const noexcept\n+      { return _M_h.load_factor(); }\n+\n+      /// Returns a positive number that the %unordered_map tries to keep the\n+      /// load factor less than or equal to.\n+      float\n+      max_load_factor() const noexcept\n+      { return _M_h.max_load_factor(); }\n+\n+      /**\n+       *  @brief  Change the %unordered_map maximum load factor.\n+       *  @param  __z The new maximum load factor.\n+       */\n+      void\n+      max_load_factor(float __z)\n+      { _M_h.max_load_factor(__z); }\n+\n+      /**\n+       *  @brief  May rehash the %unordered_map.\n+       *  @param  __n The new number of buckets.\n+       *\n+       *  Rehash will occur only if the new number of buckets respect the\n+       *  %unordered_map maximum load factor.\n+       */\n+      void\n+      rehash(size_type __n)\n+      { _M_h.rehash(__n); }\n+\n+      /**\n+       *  @brief  Prepare the %unordered_map for a specified number of\n+       *          elements.\n+       *  @param  __n Number of elements required.\n+       *\n+       *  Same as rehash(ceil(n / max_load_factor())).\n+       */\n+      void\n+      reserve(size_type __n)\n+      { _M_h.reserve(__n); }\n+\n+      template<typename _Key1, typename _Tp1, typename _Hash1, typename _Pred1,\n+\t       typename _Alloc1>\n+        friend bool\n+      operator==(const unordered_map<_Key1, _Tp1, _Hash1, _Pred1, _Alloc1>&,\n+\t\t const unordered_map<_Key1, _Tp1, _Hash1, _Pred1, _Alloc1>&);\n     };\n \n   /**\n@@ -159,41 +772,595 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t   class _Pred = std::equal_to<_Key>,\n \t   class _Alloc = std::allocator<std::pair<const _Key, _Tp> > >\n     class unordered_multimap\n-    : public __ummap_hashtable<_Key, _Tp, _Hash, _Pred, _Alloc>\n     {\n-      typedef __ummap_hashtable<_Key, _Tp, _Hash, _Pred, _Alloc>  _Base;\n+      typedef __ummap_hashtable<_Key, _Tp, _Hash, _Pred, _Alloc>  _Hashtable;\n+      _Hashtable _M_h;\n \n     public:\n-      typedef typename _Base::value_type      value_type;\n-      typedef typename _Base::size_type       size_type;\n-      typedef typename _Base::hasher          hasher;\n-      typedef typename _Base::key_equal       key_equal;\n-      typedef typename _Base::allocator_type  allocator_type;\n+      // typedefs:\n+      //@{\n+      /// Public typedefs.\n+      typedef typename _Hashtable::key_type\tkey_type;\n+      typedef typename _Hashtable::value_type\tvalue_type;\n+      typedef typename _Hashtable::mapped_type\tmapped_type;\n+      typedef typename _Hashtable::hasher\thasher;\n+      typedef typename _Hashtable::key_equal\tkey_equal;\n+      typedef typename _Hashtable::allocator_type allocator_type;\n+      //@}\n+\n+      //@{\n+      ///  Iterator-related typedefs.\n+      typedef typename allocator_type::pointer\t\tpointer;\n+      typedef typename allocator_type::const_pointer\tconst_pointer;\n+      typedef typename allocator_type::reference\treference;\n+      typedef typename allocator_type::const_reference\tconst_reference;\n+      typedef typename _Hashtable::iterator\t\titerator;\n+      typedef typename _Hashtable::const_iterator\tconst_iterator;\n+      typedef typename _Hashtable::local_iterator\tlocal_iterator;\n+      typedef typename _Hashtable::const_local_iterator\tconst_local_iterator;\n+      typedef typename _Hashtable::size_type\t\tsize_type;\n+      typedef typename _Hashtable::difference_type\tdifference_type;\n+      //@}\n+\n+      //construct/destroy/copy\n \n+      /**\n+       *  @brief  Default constructor creates no elements.\n+       *  @param __n  Initial number of buckets.\n+       *  @param __hf  A hash functor.\n+       *  @param __eql  A key equality functor.\n+       *  @param __a  An allocator object.\n+       */\n       explicit\n       unordered_multimap(size_type __n = 10,\n \t\t\t const hasher& __hf = hasher(),\n \t\t\t const key_equal& __eql = key_equal(),\n \t\t\t const allocator_type& __a = allocator_type())\n-      : _Base(__n, __hf, __eql, __a)\n+      : _M_h(__n, __hf, __eql, __a)\n       { }\n \n+      /**\n+       *  @brief  Builds an %unordered_multimap from a range.\n+       *  @param  __first  An input iterator.\n+       *  @param  __last  An input iterator.\n+       *  @param __n  Minimal initial number of buckets.\n+       *  @param __hf  A hash functor.\n+       *  @param __eql  A key equality functor.\n+       *  @param __a  An allocator object.\n+       *\n+       *  Create an %unordered_multimap consisting of copies of the elements\n+       *  from [__first,__last).  This is linear in N (where N is\n+       *  distance(__first,__last)).\n+       */\n       template<typename _InputIterator>\n \tunordered_multimap(_InputIterator __f, _InputIterator __l,\n \t\t\t   size_type __n = 0,\n \t\t\t   const hasher& __hf = hasher(),\n \t\t\t   const key_equal& __eql = key_equal(),\n \t\t\t   const allocator_type& __a = allocator_type())\n-\t: _Base(__f, __l, __n, __hf, __eql, __a)\n+\t: _M_h(__f, __l, __n, __hf, __eql, __a)\n \t{ }\n \n+      /// Copy constructor.\n+      unordered_multimap(const unordered_multimap&) = default;\n+\n+      /// Move constrcutor.\n+      unordered_multimap(unordered_multimap&&) = default;\n+\n+      /**\n+       *  @brief  Builds an %unordered_multimap from an initializer_list.\n+       *  @param  __l  An initializer_list.\n+       *  @param __n  Minimal initial number of buckets.\n+       *  @param __hf  A hash functor.\n+       *  @param __eql  A key equality functor.\n+       *  @param  __a  An allocator object.\n+       *\n+       *  Create an %unordered_multimap consisting of copies of the elements in\n+       *  the list. This is linear in N (where N is @a __l.size()).\n+       */\n       unordered_multimap(initializer_list<value_type> __l,\n \t\t\t size_type __n = 0,\n \t\t\t const hasher& __hf = hasher(),\n \t\t\t const key_equal& __eql = key_equal(),\n \t\t\t const allocator_type& __a = allocator_type())\n-      : _Base(__l.begin(), __l.end(), __n, __hf, __eql, __a)\n+\t: _M_h(__l, __n, __hf, __eql, __a)\n       { }\n+\n+      /// Copy assignment operator.\n+      unordered_multimap&\n+      operator=(const unordered_multimap&) = default;\n+\n+      /// Move assignment operator.\n+      unordered_multimap&\n+      operator=(unordered_multimap&&) = default;\n+\n+      /**\n+       *  @brief  %Unordered_multimap list assignment operator.\n+       *  @param  __l  An initializer_list.\n+       *\n+       *  This function fills an %unordered_multimap with copies of the elements\n+       *  in the initializer list @a __l.\n+       *\n+       *  Note that the assignment completely changes the %unordered_multimap\n+       *  and that the resulting %unordered_multimap's size is the same as the\n+       *  number of elements assigned.  Old data may be lost.\n+       */\n+      unordered_multimap&\n+      operator=(initializer_list<value_type> __l)\n+      {\n+\t_M_h = __l;\n+\treturn *this;\n+      }\n+\n+      ///  Returns the allocator object with which the %unordered_multimap was\n+      ///  constructed.\n+      allocator_type\n+      get_allocator() const noexcept\n+      { return _M_h.get_allocator(); }\n+\n+      // size and capacity:\n+\n+      ///  Returns true if the %unordered_multimap is empty.\n+      bool\n+      empty() const noexcept\n+      { return _M_h.empty(); }\n+\n+      ///  Returns the size of the %unordered_multimap.\n+      size_type\n+      size() const noexcept\n+      { return _M_h.size(); }\n+\n+      ///  Returns the maximum size of the %unordered_multimap.\n+      size_type\n+      max_size() const noexcept\n+      { return _M_h.max_size(); }\n+\n+      // iterators.\n+\n+      /**\n+       *  Returns a read/write iterator that points to the first element in the\n+       *  %unordered_multimap.\n+       */\n+      iterator\n+      begin() noexcept\n+      { return _M_h.begin(); }\n+\n+      //@{\n+      /**\n+       *  Returns a read-only (constant) iterator that points to the first\n+       *  element in the %unordered_multimap.\n+       */\n+      const_iterator\n+      begin() const noexcept\n+      { return _M_h.begin(); }\n+\n+      const_iterator\n+      cbegin() const noexcept\n+      { return _M_h.begin(); }\n+      //@}\n+\n+      /**\n+       *  Returns a read/write iterator that points one past the last element in\n+       *  the %unordered_multimap.\n+       */\n+      iterator\n+      end() noexcept\n+      { return _M_h.end(); }\n+\n+      //@{\n+      /**\n+       *  Returns a read-only (constant) iterator that points one past the last\n+       *  element in the %unordered_multimap.\n+       */\n+      const_iterator\n+      end() const noexcept\n+      { return _M_h.end(); }\n+\n+      const_iterator\n+      cend() const noexcept\n+      { return _M_h.end(); }\n+      //@}\n+\n+      // modifiers.\n+\n+      /**\n+       *  @brief Attempts to build and insert a std::pair into the\n+       *  %unordered_multimap.\n+       *\n+       *  @param __args  Arguments used to generate a new pair instance (see\n+       *\t        std::piecewise_contruct for passing arguments to each\n+       *\t        part of the pair constructor).\n+       *\n+       *  @return  An iterator that points to the inserted pair.\n+       *\n+       *  This function attempts to build and insert a (key, value) %pair into\n+       *  the %unordered_multimap.\n+       *\n+       *  Insertion requires amortized constant time.\n+       */\n+      template<typename... _Args>\n+\titerator\n+\templace(_Args&&... __args)\n+\t{ return _M_h.emplace(std::forward<_Args>(__args)...); }\n+\n+      /**\n+       *  @brief Attempts to build and insert a std::pair into the %unordered_multimap.\n+       *\n+       *  @param  __pos  An iterator that serves as a hint as to where the pair\n+       *                should be inserted.\n+       *  @param  __args  Arguments used to generate a new pair instance (see\n+       *\t         std::piecewise_contruct for passing arguments to each\n+       *\t         part of the pair constructor).\n+       *  @return An iterator that points to the element with key of the\n+       *          std::pair built from @a __args.\n+       *\n+       *  Note that the first parameter is only a hint and can potentially\n+       *  improve the performance of the insertion process. A bad hint would\n+       *  cause no gains in efficiency.\n+       *\n+       *  See\n+       *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt07ch17.html\n+       *  for more on @a hinting.\n+       *\n+       *  Insertion requires amortized constant time.\n+       */\n+      template<typename... _Args>\n+\titerator\n+\templace_hint(const_iterator __pos, _Args&&... __args)\n+\t{ return _M_h.emplace_hint(__pos, std::forward<_Args>(__args)...); }\n+\n+      //@{\n+      /**\n+       *  @brief Inserts a std::pair into the %unordered_multimap.\n+       *  @param __x Pair to be inserted (see std::make_pair for easy\n+       *\t     creation of pairs).\n+       *\n+       *  @return  An iterator that points to the inserted pair.\n+       *\n+       *  Insertion requires amortized constant time.\n+       */\n+      iterator\n+      insert(const value_type& __x)\n+      { return _M_h.insert(__x); }\n+\n+      template<typename _Pair>\n+\titerator\n+\tinsert(_Pair&& __x)\n+\t{ return _M_h.insert(std::move(__x)); }\n+      //@}\n+\n+      //@{\n+      /**\n+       *  @brief Inserts a std::pair into the %unordered_multimap.\n+       *  @param  __hint  An iterator that serves as a hint as to where the\n+       *                 pair should be inserted.\n+       *  @param  __x  Pair to be inserted (see std::make_pair for easy creation\n+       *               of pairs).\n+       *  @return An iterator that points to the element with key of\n+       *           @a __x (may or may not be the %pair passed in).\n+       *\n+       *  Note that the first parameter is only a hint and can potentially\n+       *  improve the performance of the insertion process.  A bad hint would\n+       *  cause no gains in efficiency.\n+       *\n+       *  See\n+       *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt07ch17.html\n+       *  for more on @a hinting.\n+       *\n+       *  Insertion requires amortized constant time.\n+       */\n+      iterator\n+      insert(const_iterator __hint, const value_type& __x)\n+      { return _M_h.insert(__hint, __x); }\n+\n+      template<typename _Pair>\n+\titerator\n+\tinsert(const_iterator __hint, _Pair&& __x)\n+\t{ return _M_h.insert(__hint, std::move(__x)); }\n+      //@}\n+\n+      /**\n+       *  @brief A template function that attempts to insert a range of\n+       *  elements.\n+       *  @param  __first  Iterator pointing to the start of the range to be\n+       *                   inserted.\n+       *  @param  __last  Iterator pointing to the end of the range.\n+       *\n+       *  Complexity similar to that of the range constructor.\n+       */\n+      template<typename _InputIterator>\n+\tvoid\n+\tinsert(_InputIterator __first, _InputIterator __last)\n+\t{ _M_h.insert(__first, __last); }\n+\n+      /**\n+       *  @brief Attempts to insert a list of elements into the\n+       *  %unordered_multimap.\n+       *  @param  __l  A std::initializer_list<value_type> of elements\n+       *               to be inserted.\n+       *\n+       *  Complexity similar to that of the range constructor.\n+       */\n+      void\n+      insert(initializer_list<value_type> __l)\n+      { _M_h.insert(__l); }\n+\n+      //@{\n+      /**\n+       *  @brief Erases an element from an %unordered_multimap.\n+       *  @param  __position  An iterator pointing to the element to be erased.\n+       *  @return An iterator pointing to the element immediately following\n+       *          @a __position prior to the element being erased. If no such\n+       *          element exists, end() is returned.\n+       *\n+       *  This function erases an element, pointed to by the given iterator,\n+       *  from an %unordered_multimap.\n+       *  Note that this function only erases the element, and that if the\n+       *  element is itself a pointer, the pointed-to memory is not touched in\n+       *  any way.  Managing the pointer is the user's responsibility.\n+       */\n+      iterator\n+      erase(const_iterator __position)\n+      { return _M_h.erase(__position); }\n+\n+      // LWG 2059.\n+      iterator\n+      erase(iterator __it)\n+      { return _M_h.erase(__it); }\n+      //@}\n+\n+      /**\n+       *  @brief Erases elements according to the provided key.\n+       *  @param  __x  Key of elements to be erased.\n+       *  @return  The number of elements erased.\n+       *\n+       *  This function erases all the elements located by the given key from\n+       *  an %unordered_multimap.\n+       *  Note that this function only erases the element, and that if the\n+       *  element is itself a pointer, the pointed-to memory is not touched in\n+       *  any way.  Managing the pointer is the user's responsibility.\n+       */\n+      size_type\n+      erase(const key_type& __x)\n+      { return _M_h.erase(__x); }\n+\n+      /**\n+       *  @brief Erases a [__first,__last) range of elements from an\n+       *  %unordered_multimap.\n+       *  @param  __first  Iterator pointing to the start of the range to be\n+       *                  erased.\n+       *  @param __last  Iterator pointing to the end of the range to\n+       *                be erased.\n+       *  @return The iterator @a __last.\n+       *\n+       *  This function erases a sequence of elements from an\n+       *  %unordered_multimap.\n+       *  Note that this function only erases the elements, and that if\n+       *  the element is itself a pointer, the pointed-to memory is not touched\n+       *  in any way.  Managing the pointer is the user's responsibility.\n+       */\n+      iterator\n+      erase(const_iterator __first, const_iterator __last)\n+      { return _M_h.erase(__first, __last); }\n+\n+      /**\n+       *  Erases all elements in an %unordered_multimap.\n+       *  Note that this function only erases the elements, and that if the\n+       *  elements themselves are pointers, the pointed-to memory is not touched\n+       *  in any way.  Managing the pointer is the user's responsibility.\n+       */\n+      void\n+      clear() noexcept\n+      { _M_h.clear(); }\n+\n+      /**\n+       *  @brief  Swaps data with another %unordered_multimap.\n+       *  @param  __x  An %unordered_multimap of the same element and allocator\n+       *  types.\n+       *\n+       *  This exchanges the elements between two %unordered_multimap in\n+       *  constant time.\n+       *  Note that the global std::swap() function is specialized such that\n+       *  std::swap(m1,m2) will feed to this function.\n+       */\n+      void\n+      swap(unordered_multimap& __x)\n+      { _M_h.swap(__x._M_h); }\n+\n+      // observers.\n+\n+      ///  Returns the hash functor object with which the %unordered_multimap\n+      ///  was constructed.\n+      hasher\n+      hash_function() const\n+      { return _M_h.hash_function(); }\n+\n+      ///  Returns the key comparison object with which the %unordered_multimap\n+      ///  was constructed.\n+      key_equal\n+      key_eq() const\n+      { return _M_h.key_eq(); }\n+\n+      // lookup.\n+\n+      //@{\n+      /**\n+       *  @brief Tries to locate an element in an %unordered_multimap.\n+       *  @param  __x  Key to be located.\n+       *  @return  Iterator pointing to sought-after element, or end() if not\n+       *           found.\n+       *\n+       *  This function takes a key and tries to locate the element with which\n+       *  the key matches.  If successful the function returns an iterator\n+       *  pointing to the sought after element.  If unsuccessful it returns the\n+       *  past-the-end ( @c end() ) iterator.\n+       */\n+      iterator\n+      find(const key_type& __x)\n+      { return _M_h.find(__x); }\n+\n+      const_iterator\n+      find(const key_type& __x) const\n+      { return _M_h.find(__x); }\n+      //@}\n+\n+      /**\n+       *  @brief  Finds the number of elements.\n+       *  @param  __x  Key to count.\n+       *  @return  Number of elements with specified key.\n+       */\n+      size_type\n+      count(const key_type& __x) const\n+      { return _M_h.count(__x); }\n+\n+      //@{\n+      /**\n+       *  @brief Finds a subsequence matching given key.\n+       *  @param  __x  Key to be located.\n+       *  @return  Pair of iterators that possibly points to the subsequence\n+       *           matching given key.\n+       */\n+      std::pair<iterator, iterator>\n+      equal_range(const key_type& __x)\n+      { return _M_h.equal_range(__x); }\n+\n+      std::pair<const_iterator, const_iterator>\n+      equal_range(const key_type& __x) const\n+      { return _M_h.equal_range(__x); }\n+      //@}\n+\n+      // bucket interface.\n+\n+      /// Returns the number of buckets of the %unordered_multimap.\n+      size_type\n+      bucket_count() const noexcept\n+      { return _M_h.bucket_count(); }\n+\n+      /// Returns the maximum number of buckets of the %unordered_multimap.\n+      size_type\n+      max_bucket_count() const noexcept\n+      { return _M_h.max_bucket_count(); }\n+\n+      /*\n+       * @brief  Returns the number of elements in a given bucket.\n+       * @param  __n  A bucket index.\n+       * @return  The number of elements in the bucket.\n+       */\n+      size_type\n+      bucket_size(size_type __n) const\n+      { return _M_h.bucket_size(__n); }\n+\n+      /*\n+       * @brief  Returns the bucket index of a given element.\n+       * @param  __key  A key instance.\n+       * @return  The key bucket index.\n+       */\n+      size_type\n+      bucket(const key_type& __key) const\n+      { return _M_h.bucket(__key); }\n+      \n+      /**\n+       *  @brief  Returns a read/write iterator pointing to the first bucket\n+       *         element.\n+       *  @param  __n The bucket index.\n+       *  @return  A read/write local iterator.\n+       */\n+      local_iterator\n+      begin(size_type __n)\n+      { return _M_h.begin(__n); }\n+\n+      //@{\n+      /**\n+       *  @brief  Returns a read-only (constant) iterator pointing to the first\n+       *         bucket element.\n+       *  @param  __n The bucket index.\n+       *  @return  A read-only local iterator.\n+       */\n+      const_local_iterator\n+      begin(size_type __n) const\n+      { return _M_h.begin(__n); }\n+\n+      const_local_iterator\n+      cbegin(size_type __n) const\n+      { return _M_h.cbegin(__n); }\n+      //@}\n+\n+      /**\n+       *  @brief  Returns a read/write iterator pointing to one past the last\n+       *         bucket elements.\n+       *  @param  __n The bucket index.\n+       *  @return  A read/write local iterator.\n+       */\n+      local_iterator\n+      end(size_type __n)\n+      { return _M_h.end(__n); }\n+\n+      //@{\n+      /**\n+       *  @brief  Returns a read-only (constant) iterator pointing to one past\n+       *         the last bucket elements.\n+       *  @param  __n The bucket index.\n+       *  @return  A read-only local iterator.\n+       */\n+      const_local_iterator\n+      end(size_type __n) const\n+      { return _M_h.end(__n); }\n+\n+      const_local_iterator\n+      cend(size_type __n) const\n+      { return _M_h.cend(__n); }\n+      //@}\n+\n+      // hash policy.\n+\n+      /// Returns the average number of elements per bucket.\n+      float\n+      load_factor() const noexcept\n+      { return _M_h.load_factor(); }\n+\n+      /// Returns a positive number that the %unordered_multimap tries to keep\n+      /// the load factor less than or equal to.\n+      float\n+      max_load_factor() const noexcept\n+      { return _M_h.max_load_factor(); }\n+\n+      /**\n+       *  @brief  Change the %unordered_multimap maximum load factor.\n+       *  @param  __z The new maximum load factor.\n+       */\n+      void\n+      max_load_factor(float __z)\n+      { _M_h.max_load_factor(__z); }\n+\n+      /**\n+       *  @brief  May rehash the %unordered_multimap.\n+       *  @param  __n The new number of buckets.\n+       *\n+       *  Rehash will occur only if the new number of buckets respect the\n+       *  %unordered_multimap maximum load factor.\n+       */\n+      void\n+      rehash(size_type __n)\n+      { _M_h.rehash(__n); }\n+\n+      /**\n+       *  @brief  Prepare the %unordered_multimap for a specified number of\n+       *          elements.\n+       *  @param  __n Number of elements required.\n+       *\n+       *  Same as rehash(ceil(n / max_load_factor())).\n+       */\n+      void\n+      reserve(size_type __n)\n+      { _M_h.reserve(__n); }\n+\n+      template<typename _Key1, typename _Tp1, typename _Hash1, typename _Pred1,\n+\t       typename _Alloc1>\n+        friend bool\n+\toperator==(const unordered_multimap<_Key1, _Tp1,\n+\t\t\t\t\t    _Hash1, _Pred1, _Alloc1>&,\n+\t\t   const unordered_multimap<_Key1, _Tp1,\n+\t\t\t\t\t    _Hash1, _Pred1, _Alloc1>&);\n     };\n \n   template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\n@@ -212,7 +1379,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     inline bool\n     operator==(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n \t       const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n-    { return __x._M_equal(__y); }\n+    { return __x._M_h._M_equal(__y._M_h); }\n \n   template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\n     inline bool\n@@ -224,7 +1391,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     inline bool\n     operator==(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n \t       const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n-    { return __x._M_equal(__y); }\n+    { return __x._M_h._M_equal(__y._M_h); }\n \n   template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\n     inline bool"}, {"sha": "c3eaa48f5dad1a215d051518417b3abe36ba9aef", "filename": "libstdc++-v3/include/bits/unordered_set.h", "status": "modified", "additions": 18, "deletions": 98, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/099e644e2d4e801a4cfadd3852d207510a59497a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/099e644e2d4e801a4cfadd3852d207510a59497a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_set.h?ref=099e644e2d4e801a4cfadd3852d207510a59497a", "patch": "@@ -158,29 +158,11 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t: _M_h(__f, __l, __n, __hf, __eql, __a)\n \t{ }\n \n-      /**\n-       *  @brief  %Unordered_set copy constructor.\n-       *  @param  __x  An %unordered_set of identical element and allocator\n-       *  types.\n-       *\n-       *  The newly-created %unordered_set uses a copy of the allocation object\n-       *  used by @a __x.\n-       */\n-      unordered_set(const unordered_set& __x)\n-\t: _M_h(__x._M_h) { }\n+      /// Copy constructor.\n+      unordered_set(const unordered_set&) = default;\n \n-     /**\n-       *  @brief %Unordered_set move constructor\n-       *  @param __x  An %unordered_set of identical element and allocator\n-       *  types.\n-       *\n-       *  The newly-created %unordered_set contains the exact contents of @a\n-       *  __x. The contents of @a __x are a valid, but unspecified\n-       *  %unordered_set.\n-       */\n-      unordered_set(unordered_set&& __x)\n-\t: _M_h(std::move(__x._M_h))\n-      { }\n+      /// Move constructor.\n+      unordered_set(unordered_set&&) = default;\n \n       /**\n        *  @brief  Builds an %unordered_set from an initializer_list.\n@@ -201,35 +183,13 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t: _M_h(__l, __n, __hf, __eql, __a)\n       { }\n \n-      /**\n-       *  @brief  %Unordered_set assignment operator.\n-       *  @param  __x  An %unordered_set of identical element and allocator\n-       *  types.\n-       *\n-       *  All the elements of @a __x are copied, but unlike the copy\n-       *  constructor, the allocator object is not copied.\n-       */\n+      /// Copy assignment operator.\n       unordered_set&\n-      operator=(const unordered_set& __x)\n-      {\n-\t_M_h = __x._M_h;\n-\treturn *this;\n-      }\n+      operator=(const unordered_set&) = default;\n \n-      /**\n-       *  @brief %Unordered_set move assignment operator.\n-       *  @param __x  An %unordered_set of identical element and allocator\n-       *  types.\n-       *\n-       *  The contents of @a __x are moved into this %unordered_set (without\n-       *  copying). @a __x is a valid, but unspecified %unordered_set.\n-       */\n+      /// Move assignment operator.\n       unordered_set&\n-      operator=(unordered_set&& __x)\n-      {\n-\t_M_h = std::move(__x._M_h);\n-\treturn *this;\n-      }\n+      operator=(unordered_set&&) = default;\n \n       /**\n        *  @brief  %Unordered_set list assignment operator.\n@@ -330,7 +290,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *\n        *  This function attempts to build and insert an element into the\n        *  %unordered_set. An %unordered_set relies on unique keys and thus an\n-       *  element is only inserted if it is not already present in the %set.\n+       *  element is only inserted if it is not already present in the\n+       *  %unordered_set.\n        *\n        *  Insertion requires amortized constant time.\n        */\n@@ -802,29 +763,11 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t: _M_h(__f, __l, __n, __hf, __eql, __a)\n \t{ }\n \n-      /**\n-       *  @brief  %Unordered_multiset copy constructor.\n-       *  @param  __x  An %unordered_multiset of identical element and allocator\n-       *  types.\n-       *\n-       *  The newly-created %unordered_multiset uses a copy of the allocation object\n-       *  used by @a __x.\n-       */\n-      unordered_multiset(const unordered_multiset& __x)\n-\t: _M_h(__x._M_h) { }\n+      /// Copy constructor.\n+      unordered_multiset(const unordered_multiset&) = default;\n \n-     /**\n-       *  @brief %Unordered_multiset move constructor\n-       *  @param __x  An %unordered_multiset of identical element and allocator\n-       *  types.\n-       *\n-       *  The newly-created %unordered_multiset contains the exact contents of\n-       *  @a __x. The contents of @a __x are a valid, but unspecified\n-       *  %unordered_multiset.\n-       */\n-      unordered_multiset(unordered_multiset&& __x)\n-\t: _M_h(std::move(__x._M_h))\n-      { }\n+      /// Move constructor.\n+      unordered_multiset(unordered_multiset&&) = default;\n \n       /**\n        *  @brief  Builds an %unordered_multiset from an initializer_list.\n@@ -845,36 +788,13 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t: _M_h(__l, __n, __hf, __eql, __a)\n       { }\n \n-      /**\n-       *  @brief  %Unordered_multiset assignment operator.\n-       *  @param  __x  An %unordered_multiset of identical element and allocator\n-       *  types.\n-       *\n-       *  All the elements of @a __x are copied, but unlike the copy\n-       *  constructor, the allocator object is not copied.\n-       */\n+      /// Copy assignment operator.\n       unordered_multiset&\n-      operator=(const unordered_multiset& __x)\n-      {\n-\t_M_h = __x._M_h;\n-\treturn *this;\n-      }\n+      operator=(const unordered_multiset&) = default;\n \n-      /**\n-       *  @brief %Unordered_multiset move assignment operator.\n-       *  @param __x  An %unordered_multiset of identical element and allocator\n-       *  types.\n-       *\n-       *  The contents of @a __x are moved into this %unordered_multiset\n-       *  (without copying). @a __x is a valid, but unspecified\n-       *  %unordered_multiset.\n-       */\n+      /// Move assignment operator.\n       unordered_multiset&\n-      operator=(unordered_multiset&& __x)\n-      {\n-\t_M_h = std::move(__x._M_h);\n-\treturn *this;\n-      }\n+      operator=(unordered_multiset&& __x) = default;\n \n       /**\n        *  @brief  %Unordered_multiset list assignment operator."}, {"sha": "16cf1768e42c3931d97ba738c4e360bef2df37e3", "filename": "libstdc++-v3/include/debug/unordered_map", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/099e644e2d4e801a4cfadd3852d207510a59497a/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/099e644e2d4e801a4cfadd3852d207510a59497a/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_map?ref=099e644e2d4e801a4cfadd3852d207510a59497a", "patch": "@@ -482,7 +482,7 @@ namespace __debug\n     inline bool\n     operator==(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n \t       const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n-    { return __x._M_equal(__y); }\n+    { return __x._M_base() == __y._M_base(); }\n \n   template<typename _Key, typename _Tp, typename _Hash,\n \t   typename _Pred, typename _Alloc>\n@@ -929,7 +929,7 @@ namespace __debug\n     inline bool\n     operator==(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n \t       const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n-    { return __x._M_equal(__y); }\n+    { return __x._M_base() == __y._M_base(); }\n \n   template<typename _Key, typename _Tp, typename _Hash,\n \t   typename _Pred, typename _Alloc>"}, {"sha": "3663ab58aa9bbb097a3da3e3292fc0c0c2a943e6", "filename": "libstdc++-v3/include/profile/unordered_map", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/099e644e2d4e801a4cfadd3852d207510a59497a/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/099e644e2d4e801a4cfadd3852d207510a59497a/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_map?ref=099e644e2d4e801a4cfadd3852d207510a59497a", "patch": "@@ -330,7 +330,7 @@ namespace __profile\n     inline bool\n     operator==(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n \t       const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n-    { return __x._M_equal(__y); }\n+    { return static_cast<const _GLIBCXX_STD_BASE&>(__x) == __y; }\n \n   template<typename _Key, typename _Tp, typename _Hash,\n \t   typename _Pred, typename _Alloc>\n@@ -599,7 +599,7 @@ namespace __profile\n     inline bool\n     operator==(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n \t       const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n-    { return __x._M_equal(__y); }\n+    { return static_cast<const _GLIBCXX_STD_BASE&>(__x) == __y; }\n \n   template<typename _Key, typename _Tp, typename _Hash,\n \t   typename _Pred, typename _Alloc>"}]}