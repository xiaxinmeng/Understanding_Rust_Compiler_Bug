{"sha": "56c0e8fa11b8dc2b396f0652756b4596b399f64b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTZjMGU4ZmExMWI4ZGMyYjM5NmYwNjUyNzU2YjQ1OTZiMzk5ZjY0Yg==", "commit": {"author": {"name": "James Van Artsdalen", "email": "jrv@gnu.org", "date": "1992-05-11T19:53:17Z"}, "committer": {"name": "James Van Artsdalen", "email": "jrv@gnu.org", "date": "1992-05-11T19:53:17Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r959", "tree": {"sha": "371be80e2c91a6fa25a8beb8baea168cf0a62d08", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/371be80e2c91a6fa25a8beb8baea168cf0a62d08"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/56c0e8fa11b8dc2b396f0652756b4596b399f64b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56c0e8fa11b8dc2b396f0652756b4596b399f64b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56c0e8fa11b8dc2b396f0652756b4596b399f64b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56c0e8fa11b8dc2b396f0652756b4596b399f64b/comments", "author": null, "committer": null, "parents": [{"sha": "c258506581e6275edf3c0aa11d28af04aebe4d1e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c258506581e6275edf3c0aa11d28af04aebe4d1e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c258506581e6275edf3c0aa11d28af04aebe4d1e"}], "stats": {"total": 447, "additions": 294, "deletions": 153}, "files": [{"sha": "d8454a3fdd4371b18d812361d98d9c3fb12737ac", "filename": "gcc/config/i386/gas.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56c0e8fa11b8dc2b396f0652756b4596b399f64b/gcc%2Fconfig%2Fi386%2Fgas.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56c0e8fa11b8dc2b396f0652756b4596b399f64b/gcc%2Fconfig%2Fi386%2Fgas.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fgas.h?ref=56c0e8fa11b8dc2b396f0652756b4596b399f64b", "patch": "@@ -17,6 +17,8 @@ You should have received a copy of the GNU General Public License\n along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n+/* Note that seq386gas.h is a GAS configuration that does not use this\n+   file. */\n \n #include \"i386.h\"\n /* Use the bsd assembler syntax.  */\n@@ -128,3 +130,15 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n       (PTR) += 4;\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n }\n+\n+/* Define macro used to output shift-double opcodes when the shift\n+   count is in %cl.  Some assemblers require %cl as an argument;\n+   some don't.\n+\n+   GAS requires the %cl argument, so override unx386.h. */\n+\n+#undef AS3_SHIFT_DOUBLE\n+#define AS3_SHIFT_DOUBLE(a,b,c,d) AS3 (a,b,c,d)\n+\n+/* Print opcodes the way that GAS expects them. */\n+#define GAS_MNEMONICS 1"}, {"sha": "5b441ac155ea663f11a7a581c3793abe482dd69f", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56c0e8fa11b8dc2b396f0652756b4596b399f64b/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56c0e8fa11b8dc2b396f0652756b4596b399f64b/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=56c0e8fa11b8dc2b396f0652756b4596b399f64b", "patch": "@@ -1033,7 +1033,14 @@ print_operand (file, x, code)\n \n \t    case 8:\n \t      if (GET_MODE_CLASS (GET_MODE (x)) == MODE_INT)\n-\t\tPUT_OP_SIZE ('Q', 'l', file);\n+\t\t{\n+#ifdef GAS_MNEMONICS\n+\t\t  PUT_OP_SIZE ('Q', 'q', file);\n+\t\t  return;\n+#else\n+\t\t  PUT_OP_SIZE ('Q', 'l', file);\t/* Fall through */\n+#endif\n+\t\t}\n \n \t      PUT_OP_SIZE ('Q', 'l', file);\n \t      return;"}, {"sha": "e387281e2d54b2d6859757f034713e77ae4e6315", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 260, "deletions": 152, "changes": 412, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56c0e8fa11b8dc2b396f0652756b4596b399f64b/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56c0e8fa11b8dc2b396f0652756b4596b399f64b/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=56c0e8fa11b8dc2b396f0652756b4596b399f64b", "patch": "@@ -2241,11 +2241,30 @@\n ;; shift pair, instead using moves and sign extension for counts greater\n ;; than 31.\n \n-(define_insn \"ashldi3\"\n-  [(set (match_operand:DI 0 \"general_operand\" \"=&r\")\n-\t(ashift:DI (match_operand:DI 1 \"general_operand\" \"0\")\n-\t\t   (match_operand:QI 2 \"general_operand\" \"cJ\")))\n-   (clobber (match_dup 2))]\n+(define_expand \"ashldi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(ashift:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t   (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (! GET_CODE (operands[2]) == CONST_INT\n+      || ! CONST_OK_FOR_LETTER_P (INTVAL (operands[2]), 'J'))\n+    {\n+      operands[2] = copy_to_mode_reg (QImode, operands[2]);\n+      emit_insn (gen_ashldi3_non_const_int (operands[0], operands[1],\n+\t\t\t\t\t    operands[2]));\n+    }\n+  else\n+    emit_insn (gen_ashldi3_const_int (operands[0], operands[1], operands[2]));\n+\n+  DONE;\n+}\")\n+\n+(define_insn \"ashldi3_const_int\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=&r\")\n+\t(ashift:DI (match_operand:DI 1 \"register_operand\" \"0\")\n+\t\t   (match_operand:QI 2 \"const_int_operand\" \"J\")))]\n   \"\"\n   \"*\n {\n@@ -2259,42 +2278,58 @@\n   xops[2] = low[0];\n   xops[3] = high[0];\n \n-  if (REG_P (xops[0]))\t/* If shift count in %cl */\n+  if (INTVAL (xops[0]) > 31)\n     {\n-      output_asm_insn (AS2 (ror%B0,%1,%0), xops);\t/* shift count / 2 */\n+      output_asm_insn (AS2 (mov%L3,%2,%3), xops);\t/* Fast shift by 32 */\n+      output_asm_insn (AS2 (xor%L2,%2,%2), xops);\n \n-      output_asm_insn (AS2 (shld%L3,%2,%3), xops);\n-      output_asm_insn (AS2 (sal%L2,%0,%2), xops);\n-      output_asm_insn (AS2 (shld%L3,%2,%3), xops);\n+      if (INTVAL (xops[0]) > 32)\n+        {\n+\t  xops[0] = gen_rtx (CONST_INT, VOIDmode, INTVAL (xops[0]) - 32);\n+\n+\t  output_asm_insn (AS2 (sal%L3,%0,%3), xops); /* Remaining shift */\n+\t}\n+    }\n+  else\n+    {\n+      output_asm_insn (AS3 (shld%L3,%0,%2,%3), xops);\n       output_asm_insn (AS2 (sal%L2,%0,%2), xops);\n+    }\n+  RET;\n+}\")\n \n-      xops[1] = gen_rtx (CONST_INT, VOIDmode, 7);\t/* shift count & 1 */\n+(define_insn \"ashldi3_non_const_int\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=&r\")\n+\t(ashift:DI (match_operand:DI 1 \"register_operand\" \"0\")\n+\t\t   (match_operand:QI 2 \"register_operand\" \"c\")))\n+   (clobber (match_dup 2))]\n+  \"\"\n+  \"*\n+{\n+  rtx xops[4], low[1], high[1];\n \n-      output_asm_insn (AS2 (shr%B0,%1,%0), xops);\n+  CC_STATUS_INIT;\n \n-      output_asm_insn (AS2 (shld%L3,%2,%3), xops);\n-      output_asm_insn (AS2 (sal%L2,%0,%2), xops);\n-    }\n-  else if (GET_CODE (xops[0]) == CONST_INT)\n-    {\n-      if (INTVAL (xops[0]) > 31)\n-\t{\n-\t  output_asm_insn (AS2 (mov%L3,%2,%3), xops);\t/* Fast shift by 32 */\n-\t  output_asm_insn (AS2 (xor%L2,%2,%2), xops);\n+  split_di (operands, 1, low, high);\n+  xops[0] = operands[2];\n+  xops[1] = const1_rtx;\n+  xops[2] = low[0];\n+  xops[3] = high[0];\n \n-\t  if (INTVAL (xops[0]) > 32)\n-\t    {\n-\t      xops[0] = gen_rtx (CONST_INT, VOIDmode, INTVAL (xops[0]) - 32);\n+  output_asm_insn (AS2 (ror%B0,%1,%0), xops);\t/* shift count / 2 */\n+\n+  output_asm_insn (AS3_SHIFT_DOUBLE (shld%L3,%0,%2,%3), xops);\n+  output_asm_insn (AS2 (sal%L2,%0,%2), xops);\n+  output_asm_insn (AS3_SHIFT_DOUBLE (shld%L3,%0,%2,%3), xops);\n+  output_asm_insn (AS2 (sal%L2,%0,%2), xops);\n+\n+  xops[1] = gen_rtx (CONST_INT, VOIDmode, 7);\t/* shift count & 1 */\n+\n+  output_asm_insn (AS2 (shr%B0,%1,%0), xops);\n+\n+  output_asm_insn (AS3_SHIFT_DOUBLE (shld%L3,%0,%2,%3), xops);\n+  output_asm_insn (AS2 (sal%L2,%0,%2), xops);\n \n-\t      output_asm_insn (AS2 (sal%L3,%0,%3), xops); /* Remaining shift */\n-\t    }\n-\t}\n-      else\n-        {\n-\t  output_asm_insn (AS3 (shld%L3,%0,%2,%3), xops);\n-\t  output_asm_insn (AS2 (sal%L2,%0,%2), xops);\n-\t}\n-    }\n   RET;\n }\")\n \n@@ -2305,7 +2340,7 @@\n (define_insn \"ashlsi3\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=r,rm\")\n \t(ashift:SI (match_operand:SI 1 \"general_operand\" \"r,0\")\n-\t\t   (match_operand:SI 2 \"general_operand\" \"M,cI\")))]\n+\t\t   (match_operand:SI 2 \"nonmemory_operand\" \"M,cI\")))]\n   \"\"\n   \"*\n {\n@@ -2338,7 +2373,7 @@\n (define_insn \"ashlhi3\"\n   [(set (match_operand:HI 0 \"general_operand\" \"=rm\")\n \t(ashift:HI (match_operand:HI 1 \"general_operand\" \"0\")\n-\t\t   (match_operand:HI 2 \"general_operand\" \"cI\")))]\n+\t\t   (match_operand:HI 2 \"nonmemory_operand\" \"cI\")))]\n   \"\"\n   \"*\n {\n@@ -2354,7 +2389,7 @@\n (define_insn \"ashlqi3\"\n   [(set (match_operand:QI 0 \"general_operand\" \"=qm\")\n \t(ashift:QI (match_operand:QI 1 \"general_operand\" \"0\")\n-\t\t   (match_operand:QI 2 \"general_operand\" \"cI\")))]\n+\t\t   (match_operand:QI 2 \"nonmemory_operand\" \"cI\")))]\n   \"\"\n   \"*\n {\n@@ -2369,15 +2404,34 @@\n \n ;; See comment above `ashldi3' about how this works.\n \n-(define_insn \"ashrdi3\"\n-  [(set (match_operand:DI 0 \"general_operand\" \"=&r\")\n-\t(ashiftrt:DI (match_operand:DI 1 \"general_operand\" \"0\")\n-\t\t     (match_operand:QI 2 \"general_operand\" \"cJ\")))\n-   (clobber (match_dup 2))]\n+(define_expand \"ashrdi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(ashiftrt:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (! GET_CODE (operands[2]) == CONST_INT\n+      || ! CONST_OK_FOR_LETTER_P (INTVAL (operands[2]), 'J'))\n+    {\n+      operands[2] = copy_to_mode_reg (QImode, operands[2]);\n+      emit_insn (gen_ashrdi3_non_const_int (operands[0], operands[1],\n+\t\t\t\t\t    operands[2]));\n+    }\n+  else\n+    emit_insn (gen_ashrdi3_const_int (operands[0], operands[1], operands[2]));\n+\n+  DONE;\n+}\")\n+\n+(define_insn \"ashrdi3_const_int\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=&r\")\n+\t(ashiftrt:DI (match_operand:DI 1 \"register_operand\" \"0\")\n+\t\t     (match_operand:QI 2 \"const_int_operand\" \"J\")))]\n   \"\"\n   \"*\n {\n-  rtx xops[5], low[1], high[1];\n+  rtx xops[4], low[1], high[1];\n \n   CC_STATUS_INIT;\n \n@@ -2387,50 +2441,67 @@\n   xops[2] = low[0];\n   xops[3] = high[0];\n \n-  if (REG_P (xops[0]))\t/* If shift count in %cl */\n+  if (INTVAL (xops[0]) > 31)\n     {\n-      output_asm_insn (AS2 (ror%B0,%1,%0), xops);\t/* shift count / 2 */\n+      xops[1] = gen_rtx (CONST_INT, VOIDmode, 31);\n+      output_asm_insn (AS2 (mov%L2,%3,%2), xops);\n+      output_asm_insn (AS2 (sar%L3,%1,%3), xops);\t/* shift by 32 */\n \n-      output_asm_insn (AS2 (shrd%L2,%3,%2), xops);\n-      output_asm_insn (AS2 (sar%L3,%0,%3), xops);\n-      output_asm_insn (AS2 (shrd%L2,%3,%2), xops);\n+      if (INTVAL (xops[0]) > 32)\n+        {\n+\t  xops[0] = gen_rtx (CONST_INT, VOIDmode, INTVAL (xops[0]) - 32);\n+\n+\t  output_asm_insn (AS2 (sar%2,%0,%2), xops); /* Remaining shift */\n+\t}\n+    }\n+  else\n+    {\n+      output_asm_insn (AS3 (shrd%L2,%0,%3,%2), xops);\n       output_asm_insn (AS2 (sar%L3,%0,%3), xops);\n+    }\n \n-      xops[1] = gen_rtx (CONST_INT, VOIDmode, 7);\t/* shift count & 1 */\n+  RET;\n+}\")\n \n-      output_asm_insn (AS2 (shr%B0,%1,%0), xops);\n+(define_insn \"ashrdi3_non_const_int\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=&r\")\n+\t(ashiftrt:DI (match_operand:DI 1 \"register_operand\" \"0\")\n+\t\t     (match_operand:QI 2 \"register_operand\" \"c\")))\n+   (clobber (match_dup 2))]\n+  \"\"\n+  \"*\n+{\n+  rtx xops[4], low[1], high[1];\n \n-      output_asm_insn (AS2 (shrd%L2,%3,%2), xops);\n-      output_asm_insn (AS2 (sar%L3,%0,%3), xops);\n-    }\n-  else if (GET_CODE (xops[0]) == CONST_INT)\n-    {\n-      if (INTVAL (xops[0]) > 31)\n-\t{\n-\t  xops[1] = gen_rtx (CONST_INT, VOIDmode, 31);\n-\t  output_asm_insn (AS2 (mov%L2,%3,%2), xops);\n-\t  output_asm_insn (AS2 (sar%L3,%1,%3), xops);\t/* shift by 32 */\n+  CC_STATUS_INIT;\n \n-\t  if (INTVAL (xops[0]) > 32)\n-\t    {\n-\t      xops[0] = gen_rtx (CONST_INT, VOIDmode, INTVAL (xops[0]) - 32);\n+  split_di (operands, 1, low, high);\n+  xops[0] = operands[2];\n+  xops[1] = const1_rtx;\n+  xops[2] = low[0];\n+  xops[3] = high[0];\n+\n+  output_asm_insn (AS2 (ror%B0,%1,%0), xops);\t/* shift count / 2 */\n+\n+  output_asm_insn (AS3_SHIFT_DOUBLE (shrd%L2,%0,%3,%2), xops);\n+  output_asm_insn (AS2 (sar%L3,%0,%3), xops);\n+  output_asm_insn (AS3_SHIFT_DOUBLE (shrd%L2,%0,%3,%2), xops);\n+  output_asm_insn (AS2 (sar%L3,%0,%3), xops);\n+\n+  xops[1] = gen_rtx (CONST_INT, VOIDmode, 7);\t/* shift count & 1 */\n+\n+  output_asm_insn (AS2 (shr%B0,%1,%0), xops);\n+\n+  output_asm_insn (AS3_SHIFT_DOUBLE (shrd%L2,%0,%3,%2), xops);\n+  output_asm_insn (AS2 (sar%L3,%0,%3), xops);\n \n-\t      output_asm_insn (AS2 (sar%L2,%0,%2), xops); /* Remaining shift */\n-\t    }\n-\t}\n-      else\n-        {\n-\t  output_asm_insn (AS3 (shrd%L2,%0,%3,%2), xops);\n-\t  output_asm_insn (AS2 (sar%L3,%0,%3), xops);\n-        }\n-    }\n   RET;\n }\")\n \n (define_insn \"ashrsi3\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n \t(ashiftrt:SI (match_operand:SI 1 \"general_operand\" \"0\")\n-\t\t     (match_operand:SI 2 \"general_operand\" \"cI\")))]\n+\t\t     (match_operand:SI 2 \"nonmemory_operand\" \"cI\")))]\n   \"\"\n   \"*\n {\n@@ -2443,7 +2514,7 @@\n (define_insn \"ashrhi3\"\n   [(set (match_operand:HI 0 \"general_operand\" \"=rm\")\n \t(ashiftrt:HI (match_operand:HI 1 \"general_operand\" \"0\")\n-\t\t     (match_operand:HI 2 \"general_operand\" \"cI\")))]\n+\t\t     (match_operand:HI 2 \"nonmemory_operand\" \"cI\")))]\n   \"\"\n   \"*\n {\n@@ -2456,7 +2527,7 @@\n (define_insn \"ashrqi3\"\n   [(set (match_operand:QI 0 \"general_operand\" \"=qm\")\n \t(ashiftrt:QI (match_operand:QI 1 \"general_operand\" \"0\")\n-\t\t     (match_operand:QI 2 \"general_operand\" \"cI\")))]\n+\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"cI\")))]\n   \"\"\n   \"*\n {\n@@ -2470,15 +2541,34 @@\n \n ;; See comment above `ashldi3' about how this works.\n \n-(define_insn \"lshrdi3\"\n-  [(set (match_operand:DI 0 \"general_operand\" \"=&r\")\n-\t(lshiftrt:DI (match_operand:DI 1 \"general_operand\" \"0\")\n-\t\t     (match_operand:QI 2 \"general_operand\" \"cJ\")))\n-   (clobber (match_dup 2))]\n+(define_expand \"lshrdi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(lshiftrt:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (! GET_CODE (operands[2]) == CONST_INT\n+      || ! CONST_OK_FOR_LETTER_P (INTVAL (operands[2]), 'J'))\n+    {\n+      operands[2] = copy_to_mode_reg (QImode, operands[2]);\n+      emit_insn (gen_lshrdi3_non_const_int (operands[0], operands[1],\n+\t\t\t\t\t    operands[2]));\n+    }\n+  else\n+    emit_insn (gen_lshrdi3_const_int (operands[0], operands[1], operands[2]));\n+\n+  DONE;\n+}\")\n+\n+(define_insn \"lshrdi3_const_int\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=&r\")\n+\t(lshiftrt:DI (match_operand:DI 1 \"register_operand\" \"0\")\n+\t\t     (match_operand:QI 2 \"const_int_operand\" \"J\")))]\n   \"\"\n   \"*\n {\n-  rtx xops[5], low[1], high[1];\n+  rtx xops[4], low[1], high[1];\n \n   CC_STATUS_INIT;\n \n@@ -2488,49 +2578,66 @@\n   xops[2] = low[0];\n   xops[3] = high[0];\n \n-  if (REG_P (xops[0]))\t/* If shift count in %cl */\n+  if (INTVAL (xops[0]) > 31)\n     {\n-      output_asm_insn (AS2 (ror%B0,%1,%0), xops);\t/* shift count / 2 */\n+      output_asm_insn (AS2 (mov%L2,%3,%2), xops);\t/* Fast shift by 32 */\n+      output_asm_insn (AS2 (xor%L3,%3,%3), xops);\n \n-      output_asm_insn (AS2 (shrd%L2,%3,%2), xops);\n-      output_asm_insn (AS2 (shr%L3,%0,%3), xops);\n-      output_asm_insn (AS2 (shrd%L2,%3,%2), xops);\n+      if (INTVAL (xops[0]) > 32)\n+        {\n+\t  xops[0] = gen_rtx (CONST_INT, VOIDmode, INTVAL (xops[0]) - 32);\n+\n+\t  output_asm_insn (AS2 (shr%2,%0,%2), xops); /* Remaining shift */\n+\t}\n+    }\n+  else\n+    {\n+      output_asm_insn (AS3 (shrd%L2,%0,%3,%2), xops);\n       output_asm_insn (AS2 (shr%L3,%0,%3), xops);\n+    }\n \n-      xops[1] = gen_rtx (CONST_INT, VOIDmode, 7);\t/* shift count & 1 */\n+  RET;\n+}\")\n \n-      output_asm_insn (AS2 (shr%B0,%1,%0), xops);\n+(define_insn \"lshrdi3_non_const_int\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=&r\")\n+\t(lshiftrt:DI (match_operand:DI 1 \"register_operand\" \"0\")\n+\t\t     (match_operand:QI 2 \"register_operand\" \"c\")))\n+   (clobber (match_dup 2))]\n+  \"\"\n+  \"*\n+{\n+  rtx xops[4], low[1], high[1];\n \n-      output_asm_insn (AS2 (shrd%L2,%3,%2), xops);\n-      output_asm_insn (AS2 (shr%L3,%0,%3), xops);\n-    }\n-  else if (GET_CODE (xops[0]) == CONST_INT)\n-    {\n-      if (INTVAL (xops[0]) > 31)\n-\t{\n-\t  output_asm_insn (AS2 (mov%L2,%3,%2), xops);\t/* Fast shift by 32 */\n-\t  output_asm_insn (AS2 (xor%L3,%3,%3), xops);\n+  CC_STATUS_INIT;\n \n-\t  if (INTVAL (xops[0]) > 32)\n-\t    {\n-\t      xops[0] = gen_rtx (CONST_INT, VOIDmode, INTVAL (xops[0]) - 32);\n+  split_di (operands, 1, low, high);\n+  xops[0] = operands[2];\n+  xops[1] = const1_rtx;\n+  xops[2] = low[0];\n+  xops[3] = high[0];\n+\n+  output_asm_insn (AS2 (ror%B0,%1,%0), xops);\t/* shift count / 2 */\n+\n+  output_asm_insn (AS3_SHIFT_DOUBLE (shrd%L2,%0,%3,%2), xops);\n+  output_asm_insn (AS2 (shr%L3,%0,%3), xops);\n+  output_asm_insn (AS3_SHIFT_DOUBLE (shrd%L2,%0,%3,%2), xops);\n+  output_asm_insn (AS2 (shr%L3,%0,%3), xops);\n+\n+  xops[1] = gen_rtx (CONST_INT, VOIDmode, 7);\t/* shift count & 1 */\n+\n+  output_asm_insn (AS2 (shr%B0,%1,%0), xops);\n+\n+  output_asm_insn (AS3_SHIFT_DOUBLE (shrd%L2,%0,%3,%2), xops);\n+  output_asm_insn (AS2 (shr%L3,%0,%3), xops);\n \n-\t      output_asm_insn (AS2 (shr%L2,%0,%2), xops); /* Remaining shift */\n-\t    }\n-\t}\n-      else\n-        {\n-\t  output_asm_insn (AS3 (shrd%L2,%0,%3,%2), xops);\n-\t  output_asm_insn (AS2 (shr%L3,%0,%3), xops);\n-        }\n-    }\n   RET;\n }\")\n \n (define_insn \"lshrsi3\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n \t(lshiftrt:SI (match_operand:SI 1 \"general_operand\" \"0\")\n-\t\t     (match_operand:SI 2 \"general_operand\" \"cI\")))]\n+\t\t     (match_operand:SI 2 \"nonmemory_operand\" \"cI\")))]\n   \"\"\n   \"*\n {\n@@ -2543,7 +2650,7 @@\n (define_insn \"lshrhi3\"\n   [(set (match_operand:HI 0 \"general_operand\" \"=rm\")\n \t(lshiftrt:HI (match_operand:HI 1 \"general_operand\" \"0\")\n-\t\t     (match_operand:HI 2 \"general_operand\" \"cI\")))]\n+\t\t     (match_operand:HI 2 \"nonmemory_operand\" \"cI\")))]\n   \"\"\n   \"*\n {\n@@ -2556,7 +2663,7 @@\n (define_insn \"lshrqi3\"\n   [(set (match_operand:QI 0 \"general_operand\" \"=qm\")\n \t(lshiftrt:QI (match_operand:QI 1 \"general_operand\" \"0\")\n-\t\t     (match_operand:QI 2 \"general_operand\" \"cI\")))]\n+\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"cI\")))]\n   \"\"\n   \"*\n {\n@@ -2571,7 +2678,7 @@\n (define_insn \"rotlsi3\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n \t(rotate:SI (match_operand:SI 1 \"general_operand\" \"0\")\n-\t\t   (match_operand:SI 2 \"general_operand\" \"cI\")))]\n+\t\t   (match_operand:SI 2 \"nonmemory_operand\" \"cI\")))]\n   \"\"\n   \"*\n {\n@@ -2584,7 +2691,7 @@\n (define_insn \"rotlhi3\"\n   [(set (match_operand:HI 0 \"general_operand\" \"=rm\")\n \t(rotate:HI (match_operand:HI 1 \"general_operand\" \"0\")\n-\t\t   (match_operand:HI 2 \"general_operand\" \"cI\")))]\n+\t\t   (match_operand:HI 2 \"nonmemory_operand\" \"cI\")))]\n   \"\"\n   \"*\n {\n@@ -2597,7 +2704,7 @@\n (define_insn \"rotlqi3\"\n   [(set (match_operand:QI 0 \"general_operand\" \"=qm\")\n \t(rotate:QI (match_operand:QI 1 \"general_operand\" \"0\")\n-\t\t   (match_operand:QI 2 \"general_operand\" \"cI\")))]\n+\t\t   (match_operand:QI 2 \"nonmemory_operand\" \"cI\")))]\n   \"\"\n   \"*\n {\n@@ -2610,7 +2717,7 @@\n (define_insn \"rotrsi3\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n \t(rotatert:SI (match_operand:SI 1 \"general_operand\" \"0\")\n-\t\t     (match_operand:SI 2 \"general_operand\" \"cI\")))]\n+\t\t     (match_operand:SI 2 \"nonmemory_operand\" \"cI\")))]\n   \"\"\n   \"*\n {\n@@ -2623,7 +2730,7 @@\n (define_insn \"rotrhi3\"\n   [(set (match_operand:HI 0 \"general_operand\" \"=rm\")\n \t(rotatert:HI (match_operand:HI 1 \"general_operand\" \"0\")\n-\t\t     (match_operand:HI 2 \"general_operand\" \"cI\")))]\n+\t\t     (match_operand:HI 2 \"nonmemory_operand\" \"cI\")))]\n   \"\"\n   \"*\n {\n@@ -2636,7 +2743,7 @@\n (define_insn \"rotrqi3\"\n   [(set (match_operand:QI 0 \"general_operand\" \"=qm\")\n \t(rotatert:QI (match_operand:QI 1 \"general_operand\" \"0\")\n-\t\t     (match_operand:QI 2 \"general_operand\" \"cI\")))]\n+\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"cI\")))]\n   \"\"\n   \"*\n {\n@@ -2739,7 +2846,7 @@\n   [(set (zero_extract:SI (match_operand:SI 0 \"general_operand\" \"+rm\")\n \t\t\t (const_int 1)\n \t\t\t (match_operand:SI 2 \"general_operand\" \"r\"))\n-\t(match_operand:SI 3 \"immediate_operand\" \"i\"))]\n+\t(match_operand:SI 3 \"const_int_operand\" \"n\"))]\n   \"! TARGET_486 && GET_CODE (operands[2]) != CONST_INT\"\n   \"*\n {\n@@ -3669,41 +3776,34 @@\n   \"nop\")\n \n (define_expand \"movstrsi\"\n-  [(parallel [(set (mem:BLK (match_operand:BLK 0 \"general_operand\" \"\"))\n-\t\t   (mem:BLK (match_operand:BLK 1 \"general_operand\" \"\")))\n-\t      (use (match_operand:SI 2 \"immediate_operand\" \"\"))\n-\t      (use (match_operand:SI 3 \"immediate_operand\" \"\"))\n-\t      (set (match_operand:SI 4 \"register_operand\" \"\")\n-\t\t   (const_int 0))\n-\t      (set (match_dup 0)\n-\t\t   (plus:SI (match_dup 0)\n-\t\t\t    (match_dup 2)))\n-\t      (set (match_dup 1)\n-\t\t   (plus:SI (match_dup 1)\n-\t\t\t    (match_dup 2)))])]\n+  [(parallel [(set (mem:BLK (match_operand:BLK 0 \"address_operand\" \"\"))\n+\t\t   (mem:BLK (match_operand:BLK 1 \"address_operand\" \"\")))\n+\t      (use (match_operand:SI 2 \"const_int_operand\" \"\"))\n+\t      (use (match_operand:SI 3 \"const_int_operand\" \"\"))\n+\t      (clobber (match_scratch:SI 4 \"\"))\n+\t      (clobber (match_dup 0))\n+\t      (clobber (match_dup 1))])]\n   \"\"\n   \"\n {\n   if (GET_CODE (operands[2]) != CONST_INT)\n     FAIL;\n   operands[0] = copy_to_mode_reg (SImode, XEXP (operands[0], 0));\n   operands[1] = copy_to_mode_reg (SImode, XEXP (operands[1], 0));\n-  operands[4] = gen_reg_rtx (SImode);\n }\")\n \n+;; It might seem that operands 0 & 1 could use predicate register_operand.\n+;; But strength reduction might offset the MEM expression.  So we let\n+;; reload put the address into %edi & %esi.\n+\n (define_insn \"\"\n-  [(set (mem:BLK (match_operand:SI 0 \"register_operand\" \"D\"))\n-\t(mem:BLK (match_operand:SI 1 \"register_operand\" \"S\")))\n-   (use (match_operand:SI 2 \"immediate_operand\" \"n\"))\n+  [(set (mem:BLK (match_operand:SI 0 \"address_operand\" \"D\"))\n+\t(mem:BLK (match_operand:SI 1 \"address_operand\" \"S\")))\n+   (use (match_operand:SI 2 \"const_int_operand\" \"n\"))\n    (use (match_operand:SI 3 \"immediate_operand\" \"i\"))\n-   (set (match_operand:SI 4 \"register_operand\" \"c\")\n-\t(const_int 0))\n-   (set (match_operand:SI 5 \"register_operand\" \"=0\")\n-\t(plus:SI (match_dup 0)\n-\t\t (match_dup 2)))\n-   (set (match_operand:SI 7 \"register_operand\" \"=1\")\n-\t(plus:SI (match_dup 1)\n-\t\t (match_dup 2)))]\n+   (clobber (match_scratch:SI 4 \"=&c\"))\n+   (clobber (match_dup 0))\n+   (clobber (match_dup 1))]\n   \"\"\n   \"*\n {\n@@ -3714,7 +3814,7 @@\n       if (INTVAL (operands[2]) & ~0x03)\n \t{\n \t  xops[0] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[2]) >> 2);\n-\t  xops[1] = gen_rtx (REG, SImode, 2);\n+\t  xops[1] = operands[4];\n \n \t  output_asm_insn (AS2 (mov%L1,%0,%1), xops);\n #ifdef INTEL_SYNTAX\n@@ -3736,8 +3836,8 @@\n (define_expand \"cmpstrsi\"\n   [(parallel [(set (match_operand:QI 0 \"general_operand\" \"\")\n \t\t   (compare:CC\n-\t\t    (mem:BLK (match_operand:BLK 1 \"general_operand\" \"\"))\n-\t\t    (mem:BLK (match_operand:BLK 2 \"general_operand\" \"\"))))\n+\t\t    (mem:BLK (match_operand:BLK 1 \"address_operand\" \"\"))\n+\t\t    (mem:BLK (match_operand:BLK 2 \"address_operand\" \"\"))))\n \t      (use (match_operand:SI 3 \"general_operand\" \"\"))\n \t      (use (match_operand:SI 4 \"immediate_operand\" \"\"))\n \t      (clobber (match_dup 1))\n@@ -3754,15 +3854,19 @@\n ;; memcmp recognizers.  The `cmpsb' opcode does nothing if the count is\n ;; zero.  Emit extra code to make sure that a zero-length compare is EQ.\n \n+;; It might seem that operands 0 & 1 could use predicate register_operand.\n+;; But strength reduction might offset the MEM expression.  So we let\n+;; reload put the address into %edi & %esi.\n+\n ;; ??? Most comparisons have a constant length, and it's therefore\n ;; possible to know that the length is non-zero, and to avoid the extra\n ;; code to handle zero-length compares.\n \n (define_insn \"\"\n   [(set (match_operand:QI 0 \"general_operand\" \"=&q\")\n-\t(compare:CC (mem:BLK (match_operand:SI 1 \"general_operand\" \"S\"))\n-\t\t    (mem:BLK (match_operand:SI 2 \"general_operand\" \"D\"))))\n-   (use (match_operand:SI 3 \"general_operand\" \"c\"))\n+\t(compare:CC (mem:BLK (match_operand:SI 1 \"address_operand\" \"S\"))\n+\t\t    (mem:BLK (match_operand:SI 2 \"address_operand\" \"D\"))))\n+   (use (match_operand:SI 3 \"register_operand\" \"c\"))\n    (use (match_operand:SI 4 \"immediate_operand\" \"i\"))\n    (clobber (match_dup 1))\n    (clobber (match_dup 2))\n@@ -3792,9 +3896,9 @@\n \n (define_insn \"\"\n   [(set (cc0)\n-\t(compare:CC (mem:BLK (match_operand:SI 0 \"general_operand\" \"S\"))\n-\t\t    (mem:BLK (match_operand:SI 1 \"general_operand\" \"D\"))))\n-   (use (match_operand:SI 2 \"general_operand\" \"c\"))\n+\t(compare:CC (mem:BLK (match_operand:SI 0 \"address_operand\" \"S\"))\n+\t\t    (mem:BLK (match_operand:SI 1 \"address_operand\" \"D\"))))\n+   (use (match_operand:SI 2 \"register_operand\" \"c\"))\n    (use (match_operand:SI 3 \"immediate_operand\" \"i\"))\n    (clobber (match_dup 0))\n    (clobber (match_dup 1))\n@@ -3951,9 +4055,13 @@\n   operands[5] = gen_reg_rtx (SImode);\n }\")\n \n+;; It might seem that operands 0 & 1 could use predicate register_operand.\n+;; But strength reduction might offset the MEM expression.  So we let\n+;; reload put the address into %edi & %esi.\n+\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=&c\")\n-\t(unspec:SI [(mem:BLK (match_operand:SI 1 \"register_operand\" \"D\"))\n+\t(unspec:SI [(mem:BLK (match_operand:SI 1 \"address_operand\" \"D\"))\n \t\t    (match_operand:QI 2 \"register_operand\" \"a\")\n \t\t    (match_operand:SI 3 \"immediate_operand\" \"i\")] 0))\n    (clobber (match_dup 1))]"}, {"sha": "25df562a1ae96f5ae71301721b5977afd3d11089", "filename": "gcc/config/i386/seq-gas.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56c0e8fa11b8dc2b396f0652756b4596b399f64b/gcc%2Fconfig%2Fi386%2Fseq-gas.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56c0e8fa11b8dc2b396f0652756b4596b399f64b/gcc%2Fconfig%2Fi386%2Fseq-gas.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fseq-gas.h?ref=56c0e8fa11b8dc2b396f0652756b4596b399f64b", "patch": "@@ -25,3 +25,15 @@\n       (PTR) += 4;\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n }\n+\n+/* Define macro used to output shift-double opcodes when the shift\n+   count is in %cl.  Some assemblers require %cl as an argument;\n+   some don't.\n+\n+   GAS requires the %cl argument, so override unx386.h. */\n+\n+#undef AS3_SHIFT_DOUBLE\n+#define AS3_SHIFT_DOUBLE(a,b,c,d) AS3 (a,b,c,d)\n+\n+/* Print opcodes the way that GAS expects them. */\n+#define GAS_MNEMONICS 1"}]}