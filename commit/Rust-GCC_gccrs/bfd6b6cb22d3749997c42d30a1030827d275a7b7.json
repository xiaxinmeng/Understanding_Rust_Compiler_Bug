{"sha": "bfd6b6cb22d3749997c42d30a1030827d275a7b7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmZkNmI2Y2IyMmQzNzQ5OTk3YzQyZDMwYTEwMzA4MjdkMjc1YTdiNw==", "commit": {"author": {"name": "Kyle Galloway", "email": "kgallowa@redhat.com", "date": "2007-04-02T13:45:52Z"}, "committer": {"name": "Kyle Galloway", "email": "kgallowa@gcc.gnu.org", "date": "2007-04-02T13:45:52Z"}, "message": "interpret-run.cc: Add code to properly set up variable slots when debugging.\n\n2007-04-02  Kyle Galloway  <kgallowa@redhat.com>\n\n\t* interpret-run.cc: Add code to properly set up variable slots\n\twhen debugging.\n\t* gnu/classpath/jdwp/natVMFrame.cc (checkJVMTIError): New function.\n\t(getObjectJVMTI): New function.\n\t(setObjectJVMTI): New function.\n\t(getIntJVMTI): New function.\n\t(setIntJVMTI): New function.\n\t(getLongJVMTI): New function.\n\t(setLongJVMTI): New function.\n\t(getFloatJVMTI): New function.\n\t(setFloatJVMTI): New function.\n\t(getDoubleJVMTI): New function.\n\t(setDoubleJVMTI): New function.\n\t(getFrameDepth): New function.\n\t(getValue): Implement.\n\t(setValue): Implement.\n\nFrom-SVN: r123427", "tree": {"sha": "9b7cc1b138514f8f786690b4f8a0406922ece04b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9b7cc1b138514f8f786690b4f8a0406922ece04b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bfd6b6cb22d3749997c42d30a1030827d275a7b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfd6b6cb22d3749997c42d30a1030827d275a7b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bfd6b6cb22d3749997c42d30a1030827d275a7b7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfd6b6cb22d3749997c42d30a1030827d275a7b7/comments", "author": null, "committer": null, "parents": [{"sha": "c6756b72575a6e705a754474d476f4fb9b838b33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6756b72575a6e705a754474d476f4fb9b838b33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6756b72575a6e705a754474d476f4fb9b838b33"}], "stats": {"total": 420, "additions": 401, "deletions": 19}, "files": [{"sha": "bc7e363195719ac905d30b1ad96a3503a6c90a4e", "filename": "libjava/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfd6b6cb22d3749997c42d30a1030827d275a7b7/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfd6b6cb22d3749997c42d30a1030827d275a7b7/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=bfd6b6cb22d3749997c42d30a1030827d275a7b7", "patch": "@@ -1,3 +1,22 @@\n+2007-04-02  Kyle Galloway  <kgallowa@redhat.com>\n+\n+\t* interpret-run.cc: Add code to properly set up variable slots\n+\twhen debugging.\n+\t* gnu/classpath/jdwp/natVMFrame.cc (checkJVMTIError): New function.\n+\t(getObjectJVMTI): New function.\n+\t(setObjectJVMTI): New function.\n+\t(getIntJVMTI): New function.\n+\t(setIntJVMTI): New function.\n+\t(getLongJVMTI): New function.\n+\t(setLongJVMTI): New function.\n+\t(getFloatJVMTI): New function.\n+\t(setFloatJVMTI): New function.\n+\t(getDoubleJVMTI): New function.\n+\t(setDoubleJVMTI): New function.\n+\t(getFrameDepth): New function.\n+\t(getValue): Implement.\n+\t(setValue): Implement. \n+\n 2007-04-02  Kyle Galloway  <kgallowa@redhat.com>\n \n \t* classpath/gnu/classpath/jdwp/processor/ThreadReferenceCommandSet.java"}, {"sha": "e32e7334136204e01d867a5f28a6292dd12d2f97", "filename": "libjava/gnu/classpath/jdwp/natVMFrame.cc", "status": "modified", "additions": 300, "deletions": 7, "changes": 307, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfd6b6cb22d3749997c42d30a1030827d275a7b7/libjava%2Fgnu%2Fclasspath%2Fjdwp%2FnatVMFrame.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfd6b6cb22d3749997c42d30a1030827d275a7b7/libjava%2Fgnu%2Fclasspath%2Fjdwp%2FnatVMFrame.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fclasspath%2Fjdwp%2FnatVMFrame.cc?ref=bfd6b6cb22d3749997c42d30a1030827d275a7b7", "patch": "@@ -8,23 +8,316 @@ This software is copyrighted work licensed under the terms of the\n Libgcj License. Please consult the file \"LIBGCJ_LICENSE\" for\n details. */\n \n+#include <config.h>\n #include <gcj/cni.h>\n #include <jvm.h>\n+#include <jvmti.h>\n+#include \"jvmti-int.h\"\n+\n+#include <java-interp.h>\n \n #include <gnu/classpath/jdwp/VMFrame.h>\n+#include <gnu/classpath/jdwp/VMVirtualMachine.h>\n+#include <gnu/classpath/jdwp/exception/InvalidFrameException.h>\n+#include <gnu/classpath/jdwp/exception/InvalidSlotException.h>\n+#include <gnu/classpath/jdwp/exception/InvalidThreadException.h>\n+#include <gnu/classpath/jdwp/exception/JdwpInternalErrorException.h>\n+#include <gnu/classpath/jdwp/exception/TypeMismatchException.h>\n+#include <gnu/classpath/jdwp/util/NullObject.h>\n+#include <gnu/classpath/jdwp/value/ByteValue.h>\n+#include <gnu/classpath/jdwp/value/BooleanValue.h>\n+#include <gnu/classpath/jdwp/value/CharValue.h>\n+#include <gnu/classpath/jdwp/value/DoubleValue.h>\n+#include <gnu/classpath/jdwp/value/FloatValue.h>\n+#include <gnu/classpath/jdwp/value/IntValue.h>\n+#include <gnu/classpath/jdwp/value/LongValue.h>\n+#include <gnu/classpath/jdwp/value/ObjectValue.h>\n+#include <gnu/classpath/jdwp/value/ShortValue.h>\n #include <gnu/classpath/jdwp/value/Value.h>\n+#include <gnu/classpath/jdwp/value/VoidValue.h>\n \n using namespace java::lang;\n+using namespace gnu::classpath::jdwp;\n+using namespace gnu::classpath::jdwp::exception;\n+\n \n-gnu::classpath::jdwp::value::Value *\n-gnu::classpath::jdwp::VMFrame::getValue (MAYBE_UNUSED jint slot,\n-\t\t\t\t\t MAYBE_UNUSED jbyte tag)\n+// All the jvmti GetLocalXX and SetLocalXX functions return the same potential\n+// errors, so this function handles them all and throws the appropriate JDWP\n+// exception.\n+static void\n+checkJVMTIError (jvmtiEnv *env, jthread thread, jvmtiError jerr, jint slot,\n+                 jbyte sig)\n {\n-  return 0;\n+  if (jerr != JVMTI_ERROR_NONE)\n+    {\n+      char *error;\n+      env->GetErrorName (jerr, &error);\n+      String *msg = reinterpret_cast<String *> (JvNewStringUTF (error));\n+      env->Deallocate ((unsigned char *) error);\n+      \n+      if (jerr == JVMTI_ERROR_INVALID_THREAD)\n+        throw new InvalidThreadException ((jlong) thread);\n+      else if (jerr == JVMTI_ERROR_NO_MORE_FRAMES)\n+        throw new InvalidFrameException (msg);\n+      else if (jerr == JVMTI_ERROR_INVALID_SLOT)\n+        throw new InvalidSlotException (slot);\n+      else if (jerr == JVMTI_ERROR_TYPE_MISMATCH)\n+        throw new TypeMismatchException (sig);\n+      else\n+        throw new JdwpInternalErrorException (msg);\n+    }\n }\n \n-void\n-gnu::classpath::jdwp::VMFrame::setValue (MAYBE_UNUSED jint slot,\n-\t\t\t\t\t MAYBE_UNUSED gnu::classpath::jdwp::value::Value *value)\n+\n+static jobject\n+getObjectJVMTI (jvmtiEnv *env, jthread thread, jint slot, jint depth, jbyte sig)\n+{\n+  jobject value;\n+  jvmtiError jerr = env->GetLocalObject (thread, depth, slot, &value);\n+  \n+  checkJVMTIError (env, thread, jerr, slot, sig);\n+  \n+  return value;\n+}\n+\n+static void\n+setObjectJVMTI (jvmtiEnv *env, jthread thread, jint slot, jint depth,\n+                jbyte sig, jobject value)\n+{\n+  if (value->getClass ()->isAssignableFrom (&util::NullObject::class$))\n+    value = NULL;\n+\t\n+  jvmtiError jerr = env->SetLocalObject (thread, depth, slot, value);\n+  \n+  checkJVMTIError (env, thread, jerr, slot, sig);\n+}\n+\n+static jint\n+getIntJVMTI (jvmtiEnv *env, jthread thread, jint slot, jint depth, jbyte sig)\n+{\n+  jint value;\n+  jvmtiError jerr = env->GetLocalInt (thread, depth, slot, &value);\n+  \n+  checkJVMTIError (env, thread, jerr, slot, sig);\n+  return value;\n+}\n+\n+static void\n+setIntJVMTI (jvmtiEnv *env, jthread thread, jint slot, jint depth, jbyte sig,\n+             jint value)\n+{\n+  jvmtiError jerr = env->SetLocalInt (thread, depth, slot, value);\n+  \n+  checkJVMTIError (env, thread, jerr, slot, sig);\n+}\n+\n+static jlong\n+getLongJVMTI (jvmtiEnv *env, jthread thread, jint slot, jint depth, jbyte sig)\n+{\n+  jlong value;\n+  jvmtiError jerr = env->GetLocalLong (thread, depth, slot, &value);\n+  \n+  checkJVMTIError (env, thread, jerr, slot, sig);\n+  \n+  return value;\n+}\n+\n+static void\n+setLongJVMTI (jvmtiEnv *env, jthread thread, jint slot, jint depth, jbyte sig,\n+              jlong value)\n+{\n+  jvmtiError jerr = env->SetLocalLong (thread, depth, slot, value);\n+  \n+  checkJVMTIError (env, thread, jerr, slot, sig);\n+}\n+\n+static jfloat\n+getFloatJVMTI (jvmtiEnv *env, jthread thread, jint slot, jint depth, jbyte sig)\n+{\n+  jfloat value;\n+  jvmtiError jerr = env->GetLocalFloat (thread, depth, slot, &value);\n+  \n+  checkJVMTIError (env, thread, jerr, slot, sig);\n+  \n+  return value;\n+}\n+\n+static void\n+setFloatJVMTI (jvmtiEnv *env, jthread thread, jint slot, jint depth, jbyte sig,\n+               jfloat value)\n {\n+  jvmtiError jerr = env->SetLocalFloat (thread, depth, slot, value);\n+  \n+  checkJVMTIError (env, thread, jerr, slot, sig);\n+}\n+\n+static jdouble\n+getDoubleJVMTI (jvmtiEnv *env, jthread thread, jint slot, jint depth,\n+                jbyte sig)\n+{\n+  jdouble value;\n+  jvmtiError jerr = env->GetLocalDouble (thread, depth, slot, &value);\n+  \n+  checkJVMTIError (env, thread, jerr, slot, sig);\n+  \n+  return value;\n+}\n+\n+static void\n+setDoubleJVMTI (jvmtiEnv *env, jthread thread, jint slot, jint depth, \n+                jbyte sig, jdouble value)\n+{\n+  jvmtiError jerr = env->SetLocalDouble (thread, depth, slot, value);\n+  \n+  checkJVMTIError (env, thread, jerr, slot, sig);\n+}\n+\n+// This is necessary since JVMTI requires a stack depth as a parameter in all\n+// its local variable functions.  Since JDWP needs frameids, we have to run\n+// through the call stack to translate these ids into the parameters JVMTI\n+// wants.\n+static jint\n+getFrameDepth (_Jv_Frame *frame)\n+{\n+  jint depth = 0;\n+  _Jv_Frame *top_frame = (_Jv_Frame *) frame->thread->frame;\n+  jint num_frames = VMVirtualMachine::getFrameCount (frame->thread);\n+  \n+  while (frame != top_frame)\n+    {\n+      top_frame = top_frame->next;\n+      depth++;\n+      \n+      if (depth >= num_frames || top_frame == NULL)\n+        throw new InvalidFrameException ((jlong) frame);\n+    }\n+  \n+  return depth;\n+}\n+\n+using namespace gnu::classpath::jdwp::value;\n+\n+Value *\n+gnu::classpath::jdwp::VMFrame::getValue (jint slot, jbyte sig)\n+{\n+  _Jv_Frame *frame = reinterpret_cast<_Jv_Frame *> (id);\n+  jint depth = getFrameDepth (frame);\n+  jthread thread = reinterpret_cast<jthread> (frame->thread);\n+  jvmtiEnv *env = _Jv_GetJDWP_JVMTIEnv ();\n+  \n+  Value *value = NULL;\n+\n+  switch (sig)\n+    {\n+    case 'B':\n+      value = new ByteValue ((jbyte) getIntJVMTI (env, thread, slot, depth, \n+                                                  sig));\n+      break;\n+    case 'Z':\n+      value = new BooleanValue ((jboolean) getIntJVMTI (env, thread, slot,\n+                                                        depth, sig));\n+      break;\n+    case 'C':\n+      value = new CharValue ((jchar) getIntJVMTI (env, thread, slot, depth,\n+                                                  sig));\n+      break;\n+    case 'S':\n+      value = new ShortValue ((jshort) getIntJVMTI (env, thread, slot, depth,\n+                                                    sig));\n+      break;\n+    case 'I':\n+      value = new IntValue (getIntJVMTI (env, thread, slot, depth, sig));\n+      break;\n+    case 'J':\n+      value = new LongValue (getLongJVMTI (env, thread, slot, depth, sig));\n+      break;\n+    case 'F':\n+      value = new FloatValue (getFloatJVMTI (env, thread, slot, depth, sig));\n+      break;\n+    case 'D':\n+      value = new DoubleValue (getDoubleJVMTI (env, thread, slot, depth, sig));\n+      break;\n+    case 'V':\n+      value = new VoidValue ();\n+      break;\n+    default:\n+      Object *obj = getObjectJVMTI (env, thread, slot, depth, sig);\n+      if (obj == NULL)\n+        obj = new util::NullObject ();\n+      value = new ObjectValue (obj);\n+      break;\n+    }\n+  \n+  return value;\n+}\n+\n+void\n+gnu::classpath::jdwp::VMFrame::setValue (jint slot, Value* value)\n+{\t\n+  jbyte sig = value->getTag ();\n+  \n+  _Jv_Frame *frame = reinterpret_cast<_Jv_Frame *> (id);\n+  jint depth = getFrameDepth (frame);\n+  jthread thread = reinterpret_cast<jthread> (frame->thread);\n+  jvmtiEnv *env = _Jv_GetJDWP_JVMTIEnv ();\n+  \n+  switch (sig)\n+    {\n+    case 'B':\n+      {\n+        ByteValue *val = reinterpret_cast<ByteValue *> (value);\n+        setIntJVMTI (env, thread, slot, depth, sig, (jint) val->getValue ());\n+        break;\n+      }\n+    case 'Z':\n+      {\n+        BooleanValue *val = reinterpret_cast<BooleanValue *> (value);\n+        setIntJVMTI (env, thread, slot, depth, sig, (jint) val->getValue ());\n+        break;\n+      }\n+    case 'C':\n+      {\n+        CharValue *val = reinterpret_cast<CharValue *> (value);\n+        setIntJVMTI (env, thread, slot, depth, sig, (jint) val->getValue ());\n+        break;\n+      }\n+    case 'S':\n+      {\n+        ShortValue *val = reinterpret_cast<ShortValue *> (value);\n+        setIntJVMTI (env, thread, slot, depth, sig, (jint) val->getValue ());\n+        break;\n+      }\n+    case 'I':\n+      {\n+        IntValue *val = reinterpret_cast<IntValue *> (value);\n+        setIntJVMTI (env, thread, slot, depth, sig, val->getValue ());\n+        break;\n+      }\n+    case 'J':\n+      {\n+        LongValue *val = reinterpret_cast<LongValue *> (value);\n+        setLongJVMTI (env, thread, slot, depth, sig, val->getValue ());\n+        break;\n+      }\n+    case 'F':\n+      {\n+        FloatValue *val = reinterpret_cast<FloatValue *> (value);\n+        setFloatJVMTI (env, thread, slot, depth, sig, val->getValue ());\n+        break;\n+      }\n+    case 'D':\n+      {\n+        DoubleValue *val = reinterpret_cast<DoubleValue *> (value);\n+        setDoubleJVMTI (env, thread, slot, depth, sig, val->getValue ());\n+        break;\n+      }\n+    case 'V':\n+      break;\n+    default:\n+      {\n+        ObjectValue *val = reinterpret_cast<ObjectValue *> (value);\n+        setObjectJVMTI (env, thread, slot, depth, sig, val->getObject());\n+        break;\n+      }\n+    }\n }"}, {"sha": "30e55daec3c06519f2c418d26a18bf7b2ff0af82", "filename": "libjava/interpret-run.cc", "status": "modified", "additions": 82, "deletions": 12, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfd6b6cb22d3749997c42d30a1030827d275a7b7/libjava%2Finterpret-run.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfd6b6cb22d3749997c42d30a1030827d275a7b7/libjava%2Finterpret-run.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finterpret-run.cc?ref=bfd6b6cb22d3749997c42d30a1030827d275a7b7", "patch": "@@ -27,12 +27,91 @@ details.  */\n \n   _Jv_word locals[meth->max_locals];\n \n-#ifdef DEBUG  \n+#ifdef DEBUG\n+  // This is the information needed to get and set local variables with\n+  // proper type checking.\n   frame_desc.locals = locals;\n   char locals_type[meth->max_locals];\n-  memset (locals_type, 'x', meth->max_locals);\n   frame_desc.locals_type = locals_type;\n-#endif\n+  \n+  // Set all slots as invalid until they are written to.\n+  memset (locals_type, 'x', meth->max_locals);\n+  \n+  // We need to set the local variable types for the method arguments since\n+  // they are valid at invocation.\n+  \n+  _Jv_Method *method = meth->get_method ();\n+  int type_ctr = 0;\n+  \n+  // If the method is non-static, we need to set the type for the \"this\" pointer.\n+  if ((method->accflags & java::lang::reflect::Modifier::STATIC) == 0)\n+    {\n+      // Set the \"this\" pointer for this frame\n+      _Jv_word *this_ptr = reinterpret_cast<_Jv_word *> (args);\n+      frame_desc.obj_ptr = this_ptr[0].o;\n+      frame_desc.locals_type[0] = 'o';\n+      type_ctr++;\n+    }\n+  \n+  // Now parse the method signature to set the types of the other arguments.  \n+  int sig_len = method->signature->len ();\n+  char *signature = method->signature->chars ();\n+  for (int i = 1; signature[i] != ')' && i <= sig_len; i++)\n+    {\n+      if (signature[i] == 'Z' || signature[i] == 'B' || signature[i] == 'C' \n+          || signature[i] == 'S' || signature[i] == 'I')\n+        {\n+          frame_desc.locals_type[type_ctr] = 'i';\n+          type_ctr++;\n+          continue;\n+        }\n+      else if (signature[i] == 'F')\n+        {\n+          frame_desc.locals_type[type_ctr] = 'f';\n+          type_ctr++;\n+          continue;\n+        }\n+      else if (signature[i] == 'J')\n+        {\n+          frame_desc.locals_type[type_ctr] = 'l';\n+          frame_desc.locals_type[type_ctr+1] = 'x';\n+          type_ctr += 2;\n+          continue;\n+        }\n+      else if (signature[i] == 'D')\n+        {\n+          frame_desc.locals_type[type_ctr] = 'd';\n+          frame_desc.locals_type[type_ctr+1] = 'x';\n+          type_ctr += 2;\n+          continue;\n+        }\n+      else if (signature[i] == 'L')\n+        {\n+          frame_desc.locals_type[type_ctr] = 'o';\n+          type_ctr++;\n+          while (signature[i] != ';')\n+            i++;\n+          continue;\n+        }\n+      else if (signature[i] == '[')\n+        {\n+          frame_desc.locals_type[type_ctr] = 'o';\n+          type_ctr++;\n+          \n+          // Ignore multi-dimensional arrays.\n+          while (signature[i] == '[')\n+            i++;\n+          \n+          // Check for an object array\n+          if (signature[i] == 'L')\n+            {\n+              while (signature[i] != ';')\n+                i++;\n+            }\n+          continue;\n+        }\n+    }\n+#endif /* DEBUG */\n \n #define INSN_LABEL(op) &&insn_##op\n \n@@ -356,15 +435,6 @@ details.  */\n   */\n   memcpy ((void*) locals, (void*) args, meth->args_raw_size);\n \n-#ifdef DEBUG\n-  // Get the object pointer for this method, after checking that it is\n-  // non-static.\n-  _Jv_Method *method = meth->get_method ();\n-   \n-  if ((method->accflags & java::lang::reflect::Modifier::STATIC) == 0)\n-    frame_desc.obj_ptr = locals[0].o;\n-#endif\n-\n   _Jv_word *pool_data = meth->defining_class->constants.data;\n \n   /* These three are temporaries for common code used by several"}]}