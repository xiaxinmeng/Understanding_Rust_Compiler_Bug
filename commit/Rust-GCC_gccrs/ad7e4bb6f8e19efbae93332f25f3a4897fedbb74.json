{"sha": "ad7e4bb6f8e19efbae93332f25f3a4897fedbb74", "node_id": "C_kwDOANBUbNoAKGFkN2U0YmI2ZjhlMTllZmJhZTkzMzMyZjI1ZjNhNDg5N2ZlZGJiNzQ", "commit": {"author": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-02-18T11:15:14Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-02-18T15:46:10Z"}, "message": "macro-repetitions: Match repetitions properly", "tree": {"sha": "e0fdee248bbb8e874c9e5d3dc9231cafe29a6065", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e0fdee248bbb8e874c9e5d3dc9231cafe29a6065"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ad7e4bb6f8e19efbae93332f25f3a4897fedbb74", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad7e4bb6f8e19efbae93332f25f3a4897fedbb74", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad7e4bb6f8e19efbae93332f25f3a4897fedbb74", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad7e4bb6f8e19efbae93332f25f3a4897fedbb74/comments", "author": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "472c0a3057454247e121c574f2e8cf71fdbfd0c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/472c0a3057454247e121c574f2e8cf71fdbfd0c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/472c0a3057454247e121c574f2e8cf71fdbfd0c9"}], "stats": {"total": 145, "additions": 142, "deletions": 3}, "files": [{"sha": "995b255294df7fc6c5004a4d7cd0166a412c5a5f", "filename": "gcc/rust/ast/rust-macro.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad7e4bb6f8e19efbae93332f25f3a4897fedbb74/gcc%2Frust%2Fast%2Frust-macro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad7e4bb6f8e19efbae93332f25f3a4897fedbb74/gcc%2Frust%2Fast%2Frust-macro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-macro.h?ref=ad7e4bb6f8e19efbae93332f25f3a4897fedbb74", "patch": "@@ -206,6 +206,9 @@ class MacroMatchRepetition : public MacroMatch\n     return MacroMatchType::Repetition;\n   }\n \n+  MacroRepOp get_op () const { return op; }\n+  std::vector<std::unique_ptr<MacroMatch> > &get_matches () { return matches; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "68859291873b54cc81eb2968046b7766ef2a1dc3", "filename": "gcc/rust/expand/rust-macro-expand.cc", "status": "modified", "additions": 114, "deletions": 3, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad7e4bb6f8e19efbae93332f25f3a4897fedbb74/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad7e4bb6f8e19efbae93332f25f3a4897fedbb74/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc?ref=ad7e4bb6f8e19efbae93332f25f3a4897fedbb74", "patch": "@@ -3520,6 +3520,7 @@ MacroExpander::match_matcher (Parser<MacroInvocLexer> &parser,\n   for (auto &match : matcher.get_matches ())\n     {\n       size_t offs_begin = source.get_offs ();\n+\n       switch (match->get_macro_match_type ())\n \t{\n \t  case AST::MacroMatch::MacroMatchType::Fragment: {\n@@ -3597,13 +3598,123 @@ MacroExpander::match_token (Parser<MacroInvocLexer> &parser, AST::Token &token)\n   return parser.skip_token (token.get_id ());\n }\n \n+bool\n+MacroExpander::match_n_matches (\n+  Parser<MacroInvocLexer> &parser,\n+  std::vector<std::unique_ptr<AST::MacroMatch>> &matches, size_t &match_amount,\n+  size_t lo_bound, size_t hi_bound)\n+{\n+  match_amount = 0;\n+\n+  const MacroInvocLexer &source = parser.get_token_source ();\n+  while (true)\n+    {\n+      // If the current token is a closing macro delimiter, break away.\n+      // TODO: Is this correct?\n+      auto t_id = parser.peek_current_token ()->get_id ();\n+      if (t_id == RIGHT_PAREN || t_id == RIGHT_SQUARE || t_id == RIGHT_CURLY)\n+\tbreak;\n+\n+      bool valid_current_match = false;\n+      for (auto &match : matches)\n+\t{\n+\t  size_t offs_begin = source.get_offs ();\n+\t  switch (match->get_macro_match_type ())\n+\t    {\n+\t      case AST::MacroMatch::MacroMatchType::Fragment: {\n+\t\tAST::MacroMatchFragment *fragment\n+\t\t  = static_cast<AST::MacroMatchFragment *> (match.get ());\n+\t\tvalid_current_match = match_fragment (parser, *fragment);\n+\n+\t\t// matched fragment get the offset in the token stream\n+\t\tsize_t offs_end = source.get_offs ();\n+\t\tsub_stack.peek ().insert (\n+\t\t  {fragment->get_ident (),\n+\t\t   {fragment->get_ident (), offs_begin, offs_end}});\n+\t      }\n+\t      break;\n+\n+\t      case AST::MacroMatch::MacroMatchType::Tok: {\n+\t\tAST::Token *tok = static_cast<AST::Token *> (match.get ());\n+\t\tvalid_current_match = match_token (parser, *tok);\n+\t      }\n+\t      break;\n+\n+\t      case AST::MacroMatch::MacroMatchType::Repetition: {\n+\t\tAST::MacroMatchRepetition *rep\n+\t\t  = static_cast<AST::MacroMatchRepetition *> (match.get ());\n+\t\tvalid_current_match = match_repetition (parser, *rep);\n+\t      }\n+\t      break;\n+\n+\t      case AST::MacroMatch::MacroMatchType::Matcher: {\n+\t\tAST::MacroMatcher *m\n+\t\t  = static_cast<AST::MacroMatcher *> (match.get ());\n+\t\tvalid_current_match = match_matcher (parser, *m);\n+\t      }\n+\t      break;\n+\t    }\n+\t}\n+      // If we've encountered an error once, stop trying to match more\n+      // repetitions\n+      if (!valid_current_match)\n+\tbreak;\n+\n+      match_amount++;\n+\n+      // Break early if we notice there's too many expressions already\n+      if (hi_bound && match_amount > hi_bound)\n+\tbreak;\n+    }\n+\n+  // Check if the amount of matches we got is valid: Is it more than the lower\n+  // bound and less than the higher bound?\n+  if (!hi_bound) // infinite amount, no upper bound\n+    return match_amount >= lo_bound;\n+  else\n+    return match_amount >= lo_bound && match_amount <= hi_bound;\n+}\n+\n bool\n MacroExpander::match_repetition (Parser<MacroInvocLexer> &parser,\n \t\t\t\t AST::MacroMatchRepetition &rep)\n {\n-  // TODO\n-  gcc_unreachable ();\n-  return false;\n+  size_t match_amount = 0;\n+  bool res = false;\n+\n+  std::string lo_str;\n+  std::string hi_str;\n+  switch (rep.get_op ())\n+    {\n+    case AST::MacroMatchRepetition::MacroRepOp::ANY:\n+      lo_str = \"0\";\n+      hi_str = \"+inf\";\n+      res = match_n_matches (parser, rep.get_matches (), match_amount);\n+      break;\n+    case AST::MacroMatchRepetition::MacroRepOp::ONE_OR_MORE:\n+      lo_str = \"1\";\n+      hi_str = \"+inf\";\n+      res = match_n_matches (parser, rep.get_matches (), match_amount, 1);\n+      break;\n+    case AST::MacroMatchRepetition::MacroRepOp::ZERO_OR_ONE:\n+      lo_str = \"0\";\n+      hi_str = \"1\";\n+      res = match_n_matches (parser, rep.get_matches (), match_amount, 0, 1);\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  if (!res)\n+    rust_error_at (rep.get_match_locus (),\n+\t\t   \"invalid amount of matches for macro invocation. Expected \"\n+\t\t   \"between %s and %s, got %lu\",\n+\t\t   lo_str.c_str (), hi_str.c_str (), match_amount);\n+\n+  rust_debug_loc (rep.get_match_locus (), \"%s matched %lu times\",\n+\t\t  res ? \"successfully\" : \"unsuccessfully\", match_amount);\n+\n+  return res;\n }\n \n AST::ASTFragment"}, {"sha": "d49c77571b23bc3d5b5582987701a5bf01c95bc0", "filename": "gcc/rust/expand/rust-macro-expand.h", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad7e4bb6f8e19efbae93332f25f3a4897fedbb74/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad7e4bb6f8e19efbae93332f25f3a4897fedbb74/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.h?ref=ad7e4bb6f8e19efbae93332f25f3a4897fedbb74", "patch": "@@ -193,6 +193,31 @@ struct MacroExpander\n   bool match_matcher (Parser<MacroInvocLexer> &parser,\n \t\t      AST::MacroMatcher &matcher);\n \n+  /**\n+   * Match any amount of matches\n+   *\n+   * @param parser Parser to use for matching\n+   * @param matches All consecutive matches to identify\n+   * @param match_amount Reference in which to store the ammount of succesful\n+   * and valid matches\n+   *\n+   * @param lo_bound Lower bound of the matcher. When specified, the matcher\n+   * will only succeed if it parses at *least* `lo_bound` fragments. If\n+   * unspecified, the matcher could succeed when parsing 0 fragments.\n+   *\n+   * @param hi_bound Higher bound of the matcher. When specified, the matcher\n+   * will only succeed if it parses *less than* `hi_bound` fragments. If\n+   * unspecified, the matcher could succeed when parsing an infinity of\n+   * fragments.\n+   *\n+   * @return true if matching was successful and within the given limits, false\n+   * otherwise\n+   */\n+  bool match_n_matches (Parser<MacroInvocLexer> &parser,\n+\t\t\tstd::vector<std::unique_ptr<AST::MacroMatch>> &matches,\n+\t\t\tsize_t &match_amount, size_t lo_bound = 0,\n+\t\t\tsize_t hi_bound = 0);\n+\n   static std::vector<std::unique_ptr<AST::Token>>\n   substitute_tokens (std::vector<std::unique_ptr<AST::Token>> &input,\n \t\t     std::vector<std::unique_ptr<AST::Token>> &macro,"}]}