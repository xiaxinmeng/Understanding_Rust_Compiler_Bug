{"sha": "f01a0d8d2cb090fc5d83f001989d472c49d6bd4c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjAxYTBkOGQyY2IwOTBmYzVkODNmMDAxOTg5ZDQ3MmM0OWQ2YmQ0Yw==", "commit": {"author": {"name": "Ian Dall", "email": "ian@sibyl.beware.dropbear.id.au", "date": "2002-06-19T17:45:15Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-06-19T17:45:15Z"}, "message": "ns32k.md: Give \"*xxx\" names to all unnamed insn's.\n\n        * config/ns32k/ns32k.md: Give \"*xxx\" names to all unnamed insn's.\n        (sCOND): Restrict operand class so that gcc knows how to reload them.\n        (bitfield_set): Merge two unnamed insn's using alternatives.\n        (call_value): Remove constraint on unused uperand.\n        (udivmodhi4, udivmodsi4, udivmoddihi4_internal): Remove.\n        (udivmoddiqi4_internal, udivmoddihi4, udivmoddiqi4): Remove.\n\n        * longlong.h (count_trailing_zeros): Escape newline and beautify.\n\nFrom-SVN: r54788", "tree": {"sha": "5de328c9e1ada4702eeb0c81f96ace80d8511848", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5de328c9e1ada4702eeb0c81f96ace80d8511848"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f01a0d8d2cb090fc5d83f001989d472c49d6bd4c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f01a0d8d2cb090fc5d83f001989d472c49d6bd4c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f01a0d8d2cb090fc5d83f001989d472c49d6bd4c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f01a0d8d2cb090fc5d83f001989d472c49d6bd4c/comments", "author": null, "committer": null, "parents": [{"sha": "b4caab5c9433517de5577934c38eb6e0ab6fa85c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4caab5c9433517de5577934c38eb6e0ab6fa85c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4caab5c9433517de5577934c38eb6e0ab6fa85c"}], "stats": {"total": 517, "additions": 257, "deletions": 260}, "files": [{"sha": "53734cad6838985f98b6e3b383837ad780dbb88a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f01a0d8d2cb090fc5d83f001989d472c49d6bd4c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f01a0d8d2cb090fc5d83f001989d472c49d6bd4c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f01a0d8d2cb090fc5d83f001989d472c49d6bd4c", "patch": "@@ -1,3 +1,14 @@\n+2002-06-19  Ian Dall  <ian@sibyl.beware.dropbear.id.au>\n+\n+\t* config/ns32k/ns32k.md: Give \"*xxx\" names to all unnamed insn's.\n+\t(sCOND): Restrict operand class so that gcc knows how to reload them.\n+\t(bitfield_set): Merge two unnamed insn's using alternatives.\n+\t(call_value): Remove constraint on unused uperand.\n+\t(udivmodhi4, udivmodsi4, udivmoddihi4_internal): Remove.\n+\t(udivmoddiqi4_internal, udivmoddihi4, udivmoddiqi4): Remove.\n+ \n+\t* longlong.h (count_trailing_zeros): Escape newline and beautify.\n+\n 2002-06-19  Mark Mitchell  <mark@codesourcery.com>\n \n \t* Makefile.in (QMTEST_DIR): Simplify definition.\n@@ -30,7 +41,7 @@\n \t(_cpp_replacement_text_len, _cpp_copy_replacement_text): New.\n \n 2002-06-18  Hans-Peter Nilsson  <hp@axis.com>\n-            Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\t    Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* config/fp-bit.c (_fpmul_parts, _fpdiv_parts): Mark with\n \tattribute __always_inline__.\n@@ -219,7 +230,7 @@ Sun Jun 16 22:16:10 CEST 2002  Jan Hubicka  <jh@suse.cz>\n \n 2002-06-16  Richard Henderson  <rth@redhat.com>\n \n-        * vax.md (casesi): Use emit_jump_insn.  Tidy expander pattern.\n+\t* vax.md (casesi): Use emit_jump_insn.  Tidy expander pattern.\n \n 2002-06-16  Richard Henderson  <rth@redhat.com>\n \n@@ -295,16 +306,16 @@ Sun Jun 16 22:16:10 CEST 2002  Jan Hubicka  <jh@suse.cz>\n \n 2002-06-15  Aldy Hernandez  <aldyh@redhat.com>\n \n-        * tm.texi (MEMBER_TYPE_FORCES_BLK): Document MODE argument.\n+\t* tm.texi (MEMBER_TYPE_FORCES_BLK): Document MODE argument.\n \n-        * stor-layout.c (compute_record_mode): Remove check for\n-        FUNCTION_ARG_REG_LITTLE_ENDIAN and VOIDmode when checking for\n-        MEMBER_TYPE_FORCES_BLK.  Pass new mode field to\n-        MEMBER_TYPE_FORCES_BLK.\n+\t* stor-layout.c (compute_record_mode): Remove check for\n+\tFUNCTION_ARG_REG_LITTLE_ENDIAN and VOIDmode when checking for\n+\tMEMBER_TYPE_FORCES_BLK.  Pass new mode field to\n+\tMEMBER_TYPE_FORCES_BLK.\n \n-        * config/ia64/hpux.h (MEMBER_TYPE_FORCES_BLK): Same.\n+\t* config/ia64/hpux.h (MEMBER_TYPE_FORCES_BLK): Same.\n \n-        * config/c4x/c4x.h (MEMBER_TYPE_FORCES_BLK): Same.\n+\t* config/c4x/c4x.h (MEMBER_TYPE_FORCES_BLK): Same.\n \n 2002-06-14  Jeff Sturm  <jsturm@one-point.com>\n "}, {"sha": "44db48071383298e772ff7e90e69162ce9861851", "filename": "gcc/config/ns32k/ns32k.md", "status": "modified", "additions": 237, "deletions": 251, "changes": 488, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f01a0d8d2cb090fc5d83f001989d472c49d6bd4c/gcc%2Fconfig%2Fns32k%2Fns32k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f01a0d8d2cb090fc5d83f001989d472c49d6bd4c/gcc%2Fconfig%2Fns32k%2Fns32k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fns32k.md?ref=f01a0d8d2cb090fc5d83f001989d472c49d6bd4c", "patch": "@@ -293,7 +293,7 @@\n   else return \\\"movd %1,%0\\\";\n }\")\n \n-(define_insn \"\"\n+(define_insn \"*movti\"\n   [(set (match_operand:TI 0 \"memory_operand\" \"=m\")\n \t(match_operand:TI 1 \"memory_operand\" \"m\"))]\n   \"\"\n@@ -334,7 +334,7 @@\n }\")\n \n ;; This special case must precede movsi.\n-(define_insn \"\"\n+(define_insn \"*ldsp\"\n   [(set (reg:SI 25)\n \t(match_operand:SI 0 \"general_operand\" \"g\"))]\n   \"\"\n@@ -797,7 +797,7 @@\n   \"truncld %1,%0\")\n \f\n ;; Multiply-add instructions\n-(define_insn \"\"\n+(define_insn \"*madddf\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=v,v,lm\")\n \t(plus:DF (mult:DF (match_operand:DF 1 \"general_operand\" \"%lmF,0,0\")\n \t\t          (match_operand:DF 2 \"general_operand\" \"lmF,lmF,lmF\"))\n@@ -808,7 +808,7 @@\n    polyl %2,%3\n    mull %2,%0\\;addl %3,%0\")\n \n-(define_insn \"\"\n+(define_insn \"*maddsf\"\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=u,u,fm\")\n \t(plus:SF (mult:SF (match_operand:SF 1 \"general_operand\" \"%fmF,0,0\")\n \t\t          (match_operand:SF 2 \"general_operand\" \"fmF,fmF,fmF\"))\n@@ -821,7 +821,7 @@\n \n \n ;; Multiply-sub instructions\n-(define_insn \"\"\n+(define_insn \"*msubdf\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=v,lm\")\n \t(minus:DF (mult:DF (match_operand:DF 1 \"general_operand\" \"%lmF,0\")\n \t\t          (match_operand:DF 2 \"general_operand\" \"lmF,lmF\"))\n@@ -831,7 +831,7 @@\n    negl %3,%0\\;dotl %1,%2\n    mull %2,%0\\;subl %3,%0\")\n \n-(define_insn \"\"\n+(define_insn \"*msubsf\"\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=u,fm\")\n \t(minus:SF (mult:SF (match_operand:SF 1 \"general_operand\" \"%fmF,0\")\n \t\t          (match_operand:SF 2 \"general_operand\" \"fmF,fmF\"))\n@@ -858,7 +858,7 @@\n   \"TARGET_32081\"\n   \"addf %2,%0\")\n \n-(define_insn \"\"\n+(define_insn \"*add_to_sp\"\n   [(set (reg:SI 25)\n \t(plus:SI (reg:SI 25)\n \t\t (match_operand:SI 0 \"immediate_operand\" \"i\")))]\n@@ -883,14 +883,14 @@\n   return \\\"adjspd %n0\\\";\n }\")\n \n-(define_insn \"\"\n+(define_insn \"*frame_addr\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm<\")\n \t(plus:SI (reg:SI 24)\n \t\t (match_operand:SI 1 \"immediate_operand\" \"i\")))]\n   \"GET_CODE (operands[1]) == CONST_INT\"\n   \"addr %c1(fp),%0\")\n \n-(define_insn \"\"\n+(define_insn \"*stack_addr\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm<\")\n \t(plus:SI (reg:SI 25)\n \t\t (match_operand:SI 1 \"immediate_operand\" \"i\")))]\n@@ -992,7 +992,7 @@\n   return \\\"addw %2,%0\\\";\n }\")\n \n-(define_insn \"\"\n+(define_insn \"*addhi_strict_low3\"\n   [(set (strict_low_part (match_operand:HI 0 \"register_operand\" \"+r\"))\n \t(plus:HI (match_operand:HI 1 \"general_operand\" \"0\")\n \t\t (match_operand:HI 2 \"general_operand\" \"g\")))]\n@@ -1020,7 +1020,7 @@\n   return \\\"addb %2,%0\\\";\n }\")\n \n-(define_insn \"\"\n+(define_insn \"*addqi_strict_low3\"\n   [(set (strict_low_part (match_operand:QI 0 \"register_operand\" \"+r\"))\n \t(plus:QI (match_operand:QI 1 \"general_operand\" \"0\")\n \t\t (match_operand:QI 2 \"general_operand\" \"g\")))]\n@@ -1049,7 +1049,7 @@\n   \"TARGET_32081\"\n   \"subf %2,%0\")\n \n-(define_insn \"\"\n+(define_insn \"*sub_from_sp\"\n   [(set (reg:SI 25)\n \t(minus:SI (reg:SI 25)\n \t\t  (match_operand:SI 0 \"immediate_operand\" \"i\")))]\n@@ -1135,7 +1135,7 @@\n   return \\\"subw %2,%0\\\";\n }\")\n \n-(define_insn \"\"\n+(define_insn \"*subhi_strict_low3\"\n   [(set (strict_low_part (match_operand:HI 0 \"register_operand\" \"+r\"))\n \t(minus:HI (match_operand:HI 1 \"general_operand\" \"0\")\n \t\t  (match_operand:HI 2 \"general_operand\" \"g\")))]\n@@ -1164,7 +1164,7 @@\n   return \\\"subb %2,%0\\\";\n }\")\n \n-(define_insn \"\"\n+(define_insn \"*subqi_strict_low3\"\n   [(set (strict_low_part (match_operand:QI 0 \"register_operand\" \"+r\"))\n \t(minus:QI (match_operand:QI 1 \"general_operand\" \"0\")\n \t\t  (match_operand:QI 2 \"general_operand\" \"g\")))]\n@@ -1283,125 +1283,125 @@\n   \"\"\n   \"deid %2,%0\")\n \n-;; Part word variants. These seem to never be used at the moment (gcc\n-;; 2.7.2.2). The code generation prefers to zero extend hi's and qi's\n-;; and use signed div and mod. Keep these insns incase that changes.\n-;; divmod should have an advantage when both div and mod are needed. However,\n-;; divmod uses two registers, so maybe the compiler knows best.\n-\n-(define_expand \"udivmodhi4\"\n-  [(parallel\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"\")\n-\t(udiv:HI (match_operand:HI 1 \"general_operand\" \"\")\n-\t\t     (match_operand:HI 2 \"general_operand\" \"\")))\n-   (set (match_operand:HI 3 \"nonimmediate_operand\" \"\")\n-\t(umod:HI (match_dup 1) (match_dup 2)))])]\n-  \"\"\n-  \"\n-{\n-  rtx temp = gen_reg_rtx(DImode);\n-  rtx insn, first, last;\n-  first = emit_move_insn(gen_lowpart(HImode, temp), operands[1]);\n-  emit_move_insn(gen_highpart (HImode, temp), const0_rtx);\n-  operands[2] = force_reg(HImode, operands[2]);\n-  emit_insn(gen_udivmoddihi4_internal(temp, temp, operands[2]));\n-  last = emit_move_insn(temp, temp);\n-  {\n-    rtx divdi, moddi, divhi, modhi;\n-    divhi = gen_rtx (UDIV, HImode, operands[1], operands[2]);\n-    modhi = gen_rtx (UMOD, HImode, operands[1], operands[2]);\n-    divdi = gen_rtx (ZERO_EXTEND, DImode, divhi);\n-    moddi = gen_rtx (ZERO_EXTEND, DImode, modhi);\n-    REG_NOTES (first) = gen_rtx (INSN_LIST, REG_LIBCALL, last,\n-\t\t\t         REG_NOTES (first));\n-    REG_NOTES (last) = gen_rtx (INSN_LIST, REG_RETVAL, first,\n-                                gen_rtx (EXPR_LIST, REG_EQUAL,\n-                       gen_rtx(IOR, DImode, moddi,\n-                               gen_rtx(ASHIFT, DImode, divdi, GEN_INT(32))),\n-                       REG_NOTES (last)));\n-  }\n-\n-  insn = emit_move_insn(operands[0], gen_highpart(HImode, temp));\n-  insn = emit_move_insn(operands[3], gen_lowpart(HImode, temp));\n-  DONE;\n-}\")\n-\n-;; deiw wants two hi's in separate registers or else they can be adjacent\n-;; in memory. DI mode will ensure two registers are available, but if we\n-;; want to allow memory as an operand we would need SI mode. There is no\n-;; way to do this, so just restrict operand 0 and 1 to be in registers.\n-(define_insn \"udivmoddihi4_internal\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-        (unspec:DI [(match_operand:DI 1 \"register_operand\" \"0\")\n-                    (match_operand:HI 2 \"general_operand\" \"g\")] 0))]\n-  \"\"\n-  \"deiw %2,%0\")\n-\n-(define_insn \"udivmoddihi4\"\n-  [(set (subreg:HI (match_operand:DI 0 \"register_operand\" \"=r\") 2)\n-\t(truncate:HI (udiv:DI (match_operand:DI 1 \"register_operand\" \"0\")\n-\t\t (zero_extend:DI (match_operand:HI 2 \"nonimmediate_operand\" \"rm\")))))\n-   (set (subreg:HI (match_operand:DI 3 \"register_operand\" \"=0\") 0)\n-\t(truncate:HI (umod:DI (match_dup 1) (zero_extend:DI (match_dup 2)))))]\n-  \"\"\n-  \"deiw %2,%0\")\n-\n-(define_expand \"udivmodqi4\"\n-  [(parallel\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"\")\n-\t(udiv:QI (match_operand:QI 1 \"general_operand\" \"\")\n-\t\t     (match_operand:QI 2 \"general_operand\" \"\")))\n-   (set (match_operand:QI 3 \"nonimmediate_operand\" \"\")\n-\t(umod:QI (match_dup 1) (match_dup 2)))])]\n-  \"\"\n-  \"\n-{\n-  rtx temp = gen_reg_rtx(DImode);\n-  rtx insn, first, last;\n-  first = emit_move_insn(gen_lowpart(QImode, temp), operands[1]);\n-  emit_move_insn(gen_highpart(QImode, temp), const0_rtx);\n-  operands[2] = force_reg(QImode, operands[2]);\n-  emit_insn(gen_udivmoddiqi4_internal(temp, temp, operands[2]));\n-  last = emit_move_insn(temp, temp);\n-  {\n-    rtx divdi, moddi, divqi, modqi;\n-    divqi = gen_rtx (UDIV, QImode, operands[1], operands[2]);\n-    modqi = gen_rtx (UMOD, QImode, operands[1], operands[2]);\n-    divdi = gen_rtx (ZERO_EXTEND, DImode, divqi);\n-    moddi = gen_rtx (ZERO_EXTEND, DImode, modqi);\n-    REG_NOTES (first) = gen_rtx (INSN_LIST, REG_LIBCALL, last,\n-\t\t\t         REG_NOTES (first));\n-    REG_NOTES (last) = gen_rtx (INSN_LIST, REG_RETVAL, first,\n-                                gen_rtx (EXPR_LIST, REG_EQUAL,\n-                       gen_rtx(IOR, DImode, moddi,\n-                               gen_rtx(ASHIFT, DImode, divdi, GEN_INT(32))),\n-                       REG_NOTES (last)));\n-  }\n-\n-  insn = emit_move_insn(operands[0], gen_highpart(QImode, temp));\n-  insn = emit_move_insn(operands[3], gen_lowpart(QImode, temp));\n-  DONE;\n-}\")\n-\n-;; deib wants two qi's in separate registers or else they can be adjacent\n-;; in memory. DI mode will ensure two registers are available, but if we\n-;; want to allow memory as an operand we would need HI mode. There is no\n-;; way to do this, so just restrict operand 0 and 1 to be in registers.\n-(define_insn \"udivmoddiqi4_internal\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-        (unspec:DI [(match_operand:DI 1 \"register_operand\" \"0\")\n-                    (match_operand:QI 2 \"general_operand\" \"g\")] 0))]\n-  \"\"\n-  \"deib %2,%0\")\n-\n-(define_insn \"udivmoddiqi4\"\n-  [(set (subreg:QI (match_operand:DI 0 \"register_operand\" \"=r\") 1)\n-\t(truncate:QI (udiv:DI (match_operand:DI 1 \"register_operand\" \"0\")\n-\t\t (zero_extend:DI (match_operand:QI 2 \"nonimmediate_operand\" \"rm\")))))\n-   (set (subreg:QI (match_operand:DI 3 \"register_operand\" \"=0\") 0)\n-\t(truncate:QI (umod:DI (match_dup 1) (zero_extend:DI (match_dup 2)))))]\n-  \"\"\n-  \"deib %2,%0\")\n+;;;; Part word variants. These seem to never be used at the moment (gcc\n+;;;; 2.7.2.2). The code generation prefers to zero extend hi's and qi's\n+;;;; and use signed div and mod. Keep these insns incase that changes.\n+;;;; divmod should have an advantage when both div and mod are needed. However,\n+;;;; divmod uses two registers, so maybe the compiler knows best.\n+;;\n+;;(define_expand \"udivmodhi4\"\n+;;  [(parallel\n+;;  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"\")\n+;;\t(udiv:HI (match_operand:HI 1 \"general_operand\" \"\")\n+;;\t\t     (match_operand:HI 2 \"general_operand\" \"\")))\n+;;   (set (match_operand:HI 3 \"nonimmediate_operand\" \"\")\n+;;\t(umod:HI (match_dup 1) (match_dup 2)))])]\n+;;  \"\"\n+;;  \"\n+;;{\n+;;  rtx temp = gen_reg_rtx(DImode);\n+;;  rtx insn, first, last;\n+;;  first = emit_move_insn(gen_lowpart(HImode, temp), operands[1]);\n+;;  emit_move_insn(gen_highpart (HImode, temp), const0_rtx);\n+;;  operands[2] = force_reg(HImode, operands[2]);\n+;;  emit_insn(gen_udivmoddihi4_internal(temp, temp, operands[2]));\n+;;  last = emit_move_insn(temp, temp);\n+;;  {\n+;;    rtx divdi, moddi, divhi, modhi;\n+;;    divhi = gen_rtx (UDIV, HImode, operands[1], operands[2]);\n+;;    modhi = gen_rtx (UMOD, HImode, operands[1], operands[2]);\n+;;    divdi = gen_rtx (ZERO_EXTEND, DImode, divhi);\n+;;    moddi = gen_rtx (ZERO_EXTEND, DImode, modhi);\n+;;    REG_NOTES (first) = gen_rtx (INSN_LIST, REG_LIBCALL, last,\n+;;\t\t\t         REG_NOTES (first));\n+;;    REG_NOTES (last) = gen_rtx (INSN_LIST, REG_RETVAL, first,\n+;;                                gen_rtx (EXPR_LIST, REG_EQUAL,\n+;;                       gen_rtx(IOR, DImode, moddi,\n+;;                               gen_rtx(ASHIFT, DImode, divdi, GEN_INT(32))),\n+;;                       REG_NOTES (last)));\n+;;  }\n+;;\n+;;  insn = emit_move_insn(operands[0], gen_highpart(HImode, temp));\n+;;  insn = emit_move_insn(operands[3], gen_lowpart(HImode, temp));\n+;;  DONE;\n+;;}\")\n+;;\n+;;;; deiw wants two hi's in separate registers or else they can be adjacent\n+;;;; in memory. DI mode will ensure two registers are available, but if we\n+;;;; want to allow memory as an operand we would need SI mode. There is no\n+;;;; way to do this, so just restrict operand 0 and 1 to be in registers.\n+;;(define_insn \"udivmoddihi4_internal\"\n+;;  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+;;        (unspec:DI [(match_operand:DI 1 \"register_operand\" \"0\")\n+;;                    (match_operand:HI 2 \"general_operand\" \"g\")] 0))]\n+;;  \"\"\n+;;  \"deiw %2,%0\")\n+;;\n+;;(define_insn \"udivmoddihi4\"\n+;;  [(set (subreg:HI (match_operand:DI 0 \"register_operand\" \"=r\") 2)\n+;;\t(truncate:HI (udiv:DI (match_operand:DI 1 \"register_operand\" \"0\")\n+;;\t\t (zero_extend:DI (match_operand:HI 2 \"nonimmediate_operand\" \"rm\")))))\n+;;   (set (subreg:HI (match_operand:DI 3 \"register_operand\" \"=0\") 0)\n+;;\t(truncate:HI (umod:DI (match_dup 1) (zero_extend:DI (match_dup 2)))))]\n+;;  \"\"\n+;;  \"deiw %2,%0\")\n+;;\n+;;(define_expand \"udivmodqi4\"\n+;;  [(parallel\n+;;  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"\")\n+;;\t(udiv:QI (match_operand:QI 1 \"general_operand\" \"\")\n+;;\t\t     (match_operand:QI 2 \"general_operand\" \"\")))\n+;;   (set (match_operand:QI 3 \"nonimmediate_operand\" \"\")\n+;;\t(umod:QI (match_dup 1) (match_dup 2)))])]\n+;;  \"\"\n+;;  \"\n+;;{\n+;;  rtx temp = gen_reg_rtx(DImode);\n+;;  rtx insn, first, last;\n+;;  first = emit_move_insn(gen_lowpart(QImode, temp), operands[1]);\n+;;  emit_move_insn(gen_highpart(QImode, temp), const0_rtx);\n+;;  operands[2] = force_reg(QImode, operands[2]);\n+;;  emit_insn(gen_udivmoddiqi4_internal(temp, temp, operands[2]));\n+;;  last = emit_move_insn(temp, temp);\n+;;  {\n+;;    rtx divdi, moddi, divqi, modqi;\n+;;    divqi = gen_rtx (UDIV, QImode, operands[1], operands[2]);\n+;;    modqi = gen_rtx (UMOD, QImode, operands[1], operands[2]);\n+;;    divdi = gen_rtx (ZERO_EXTEND, DImode, divqi);\n+;;    moddi = gen_rtx (ZERO_EXTEND, DImode, modqi);\n+;;    REG_NOTES (first) = gen_rtx (INSN_LIST, REG_LIBCALL, last,\n+;;\t\t\t         REG_NOTES (first));\n+;;    REG_NOTES (last) = gen_rtx (INSN_LIST, REG_RETVAL, first,\n+;;                                gen_rtx (EXPR_LIST, REG_EQUAL,\n+;;                       gen_rtx(IOR, DImode, moddi,\n+;;                               gen_rtx(ASHIFT, DImode, divdi, GEN_INT(32))),\n+;;                       REG_NOTES (last)));\n+;;  }\n+;;\n+;;  insn = emit_move_insn(operands[0], gen_highpart(QImode, temp));\n+;;  insn = emit_move_insn(operands[3], gen_lowpart(QImode, temp));\n+;;  DONE;\n+;;}\")\n+;;\n+;;;; deib wants two qi's in separate registers or else they can be adjacent\n+;;;; in memory. DI mode will ensure two registers are available, but if we\n+;;;; want to allow memory as an operand we would need HI mode. There is no\n+;;;; way to do this, so just restrict operand 0 and 1 to be in registers.\n+;;(define_insn \"udivmoddiqi4_internal\"\n+;;  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+;;        (unspec:DI [(match_operand:DI 1 \"register_operand\" \"0\")\n+;;                    (match_operand:QI 2 \"general_operand\" \"g\")] 0))]\n+;;  \"\"\n+;;  \"deib %2,%0\")\n+;;\n+;;(define_insn \"udivmoddiqi4\"\n+;;  [(set (subreg:QI (match_operand:DI 0 \"register_operand\" \"=r\") 1)\n+;;\t(truncate:QI (udiv:DI (match_operand:DI 1 \"register_operand\" \"0\")\n+;;\t\t (zero_extend:DI (match_operand:QI 2 \"nonimmediate_operand\" \"rm\")))))\n+;;   (set (subreg:QI (match_operand:DI 3 \"register_operand\" \"=0\") 0)\n+;;\t(truncate:QI (umod:DI (match_dup 1) (zero_extend:DI (match_dup 2)))))]\n+;;  \"\"\n+;;  \"deib %2,%0\")\n \f\n ;;- Divide instructions.\n \n@@ -1531,21 +1531,21 @@\n   \"andb %2,%0\")\n \n ;; See note 1\n-(define_insn \"\"\n+(define_insn \"*bicsi\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm\")\n \t(and:SI (not:SI (match_operand:SI 1 \"general_operand\" \"g\"))\n \t\t(match_operand:SI 2 \"general_operand\" \"0\")))]\n   \"\"\n   \"bicd %1,%0\")\n \n-(define_insn \"\"\n+(define_insn \"*bichi\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm\")\n \t(and:HI (not:HI (match_operand:HI 1 \"general_operand\" \"g\"))\n \t\t(match_operand:HI 2 \"general_operand\" \"0\")))]\n   \"\"\n   \"bicw %1,%0\")\n \n-(define_insn \"\"\n+(define_insn \"*bicqi\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=rm\")\n \t(and:QI (not:QI (match_operand:QI 1 \"general_operand\" \"g\"))\n \t\t(match_operand:QI 2 \"general_operand\" \"0\")))]\n@@ -1778,14 +1778,14 @@\n     operands[2] = gen_rtx_NEG (SImode, negate_rtx (SImode, operands[2]));\n }\")\n \n-(define_insn \"\"\n+(define_insn \"*ashrisi3\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm\")\n \t(ashiftrt:SI (match_operand:SI 1 \"general_operand\" \"0\")\n \t\t     (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n   \"\"\n   \"ashd %n2,%0\")\n \n-(define_insn \"\"\n+(define_insn \"*ashrsi3\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm\")\n \t(ashiftrt:SI (match_operand:SI 1 \"general_operand\" \"0\")\n \t\t     (neg:SI (match_operand:SI 2 \"register_operand\" \"r\"))))]\n@@ -1803,14 +1803,14 @@\n     operands[2] = gen_rtx_NEG (SImode, negate_rtx (SImode, operands[2]));\n }\")\n \n-(define_insn \"\"\n+(define_insn \"*ashrihi3\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm\")\n \t(ashiftrt:HI (match_operand:HI 1 \"general_operand\" \"0\")\n \t\t     (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n   \"\"\n   \"ashw %n2,%0\")\n \n-(define_insn \"\"\n+(define_insn \"*ashrhi3\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm\")\n \t(ashiftrt:HI (match_operand:HI 1 \"general_operand\" \"0\")\n \t\t     (neg:SI (match_operand:SI 2 \"register_operand\" \"r\"))))]\n@@ -1828,14 +1828,14 @@\n     operands[2] = gen_rtx_NEG (SImode, negate_rtx (SImode, operands[2]));\n }\")\n \n-(define_insn \"\"\n+(define_insn \"*ashriqi3\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=rm\")\n \t(ashiftrt:QI (match_operand:QI 1 \"general_operand\" \"0\")\n \t\t     (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n   \"\"\n   \"ashb %n2,%0\")\n \n-(define_insn \"\"\n+(define_insn \"*ashrqi3\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=rm\")\n \t(ashiftrt:QI (match_operand:QI 1 \"general_operand\" \"0\")\n \t\t     (neg:SI (match_operand:SI 2 \"register_operand\" \"r\"))))]\n@@ -1856,14 +1856,14 @@\n     operands[2] = gen_rtx_NEG (SImode, negate_rtx (SImode, operands[2]));\n }\")\n \n-(define_insn \"\"\n+(define_insn \"*lshrisi3\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm\")\n \t(lshiftrt:SI (match_operand:SI 1 \"general_operand\" \"0\")\n \t\t     (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n   \"\"\n   \"lshd %n2,%0\")\n \n-(define_insn \"\"\n+(define_insn \"*lshrsi3\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm\")\n \t(lshiftrt:SI (match_operand:SI 1 \"general_operand\" \"0\")\n \t\t     (neg:SI (match_operand:SI 2 \"register_operand\" \"r\"))))]\n@@ -1881,14 +1881,14 @@\n     operands[2] = gen_rtx_NEG (SImode, negate_rtx (SImode, operands[2]));\n }\")\n \n-(define_insn \"\"\n+(define_insn \"*lshrihi3\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm\")\n \t(lshiftrt:HI (match_operand:HI 1 \"general_operand\" \"0\")\n \t\t     (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n   \"\"\n   \"lshw %n2,%0\")\n \n-(define_insn \"\"\n+(define_insn \"*lshrhi3\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm\")\n \t(lshiftrt:HI (match_operand:HI 1 \"general_operand\" \"0\")\n \t\t     (neg:SI (match_operand:SI 2 \"register_operand\" \"r\"))))]\n@@ -1906,14 +1906,14 @@\n     operands[2] = gen_rtx_NEG (SImode, negate_rtx (SImode, operands[2]));\n }\")\n \n-(define_insn \"\"\n+(define_insn \"*lshriqi3\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=rm\")\n \t(lshiftrt:QI (match_operand:QI 1 \"general_operand\" \"0\")\n \t\t     (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n   \"\"\n   \"lshb %n2,%0\")\n \n-(define_insn \"\"\n+(define_insn \"*lshrqi3\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=rm\")\n \t(lshiftrt:QI (match_operand:QI 1 \"general_operand\" \"0\")\n \t\t     (neg:SI (match_operand:SI 2 \"register_operand\" \"r\"))))]\n@@ -1956,14 +1956,14 @@\n     operands[2] = gen_rtx_NEG (SImode, negate_rtx (SImode, operands[2]));\n }\")\n \n-(define_insn \"\"\n+(define_insn \"*rotrisi3\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm\")\n \t(rotatert:SI (match_operand:SI 1 \"general_operand\" \"0\")\n \t\t     (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n   \"\"\n   \"rotd %n2,%0\")\n \n-(define_insn \"\"\n+(define_insn \"*rotrsi3\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm\")\n \t(rotatert:SI (match_operand:SI 1 \"general_operand\" \"0\")\n \t\t     (neg:SI (match_operand:SI 2 \"register_operand\" \"r\"))))]\n@@ -1981,14 +1981,14 @@\n     operands[2] = gen_rtx_NEG (SImode, negate_rtx (SImode, operands[2]));\n }\")\n \n-(define_insn \"\"\n+(define_insn \"*rotrihi3\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm\")\n \t(rotatert:HI (match_operand:HI 1 \"general_operand\" \"0\")\n \t\t     (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n   \"\"\n   \"rotw %n2,%0\")\n \n-(define_insn \"\"\n+(define_insn \"*rotrhi3\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm\")\n \t(rotatert:HI (match_operand:HI 1 \"general_operand\" \"0\")\n \t\t     (neg:SI (match_operand:SI 2 \"register_operand\" \"r\"))))]\n@@ -2006,14 +2006,14 @@\n     operands[2] = gen_rtx_NEG (SImode, negate_rtx (SImode, operands[2]));\n }\")\n \n-(define_insn \"\"\n+(define_insn \"*rotriqi3\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=rm\")\n \t(rotatert:QI (match_operand:QI 1 \"general_operand\" \"0\")\n \t\t     (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n   \"\"\n   \"rotb %n2,%0\")\n \n-(define_insn \"\"\n+(define_insn \"*rotrqi3\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=rm\")\n \t(rotatert:QI (match_operand:QI 1 \"general_operand\" \"0\")\n \t\t     (neg:SI (match_operand:SI 2 \"register_operand\" \"r\"))))]\n@@ -2024,7 +2024,7 @@\n ;; These come after the move, add, and multiply patterns\n ;; because we don't want pushl $1 turned into pushad 1.\n \n-(define_insn \"\"\n+(define_insn \"*addrsi\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm<\")\n \t(match_operand:QI 1 \"address_operand\" \"p\"))]\n   \"\"\n@@ -2068,7 +2068,7 @@\n ;; Set, Clear, and Invert bit\n \n ;; See note 1\n-(define_insn \"\"\n+(define_insn \"*sbitsi\"\n   [(set (zero_extract:SI (match_operand:SI 0 \"nonimmediate_operand\" \"+rm\")\n \t\t\t (const_int 1)\n \t\t\t (match_operand:SI 1 \"general_operand\" \"g\"))\n@@ -2077,7 +2077,7 @@\n   \"sbitd %1,%0\")\n \n ;; See note 1\n-(define_insn \"\"\n+(define_insn \"*cbitsi\"\n   [(set (zero_extract:SI (match_operand:SI 0 \"nonimmediate_operand\" \"+rm\")\n \t\t\t (const_int 1)\n \t\t\t (match_operand:SI 1 \"general_operand\" \"g\"))\n@@ -2086,7 +2086,7 @@\n   \"cbitd %1,%0\")\n \n ;; See note 1\n-(define_insn \"\"\n+(define_insn \"*ibitsi\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"+rm\")\n \t(xor:SI (ashift:SI (const_int 1)\n \t\t\t   (match_operand:SI 1 \"general_operand\" \"g\"))\n@@ -2095,7 +2095,7 @@\n   \"ibitd %1,%0\")\n \n ;; See note 1\n-(define_insn \"\"\n+(define_insn \"*ibitqi\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=rm\")\n \t(xor:QI (subreg:QI\n \t\t (ashift:SI (const_int 1)\n@@ -2106,7 +2106,7 @@\n \n ;; Recognize jbs and jbc instructions.\n \n-(define_insn \"\"\n+(define_insn \"*tbit\"\n   [(set (cc0)\n \t(zero_extract (match_operand:SI 0 \"nonimmediate_operand\" \"rm\")\n \t\t      (const_int 1)\n@@ -2130,7 +2130,7 @@\n ;; we cannot use it for a destination.  Perhaps things are fast\n ;; enough on the 32532 that such hacks are not needed.\n \n-(define_insn \"\"\n+(define_insn \"*extract_bytes\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=ro\")\n \t(zero_extract:SI (match_operand:SI 1 \"register_operand\" \"r\")\n \t\t\t (match_operand:SI 2 \"const_int_operand\" \"i\")\n@@ -2182,7 +2182,7 @@\n ;; A machine specific option (-mbitfield/-mnobitfield) is used\n ;; to allow/disallow the use of these instructions.\n \n-(define_insn \"\"\n+(define_insn \"*bitfield_ext\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm<\")\n \t(zero_extract:SI (match_operand:SI 1 \"register_operand\" \"g\")\n \t\t\t (match_operand:SI 2 \"const_int_operand\" \"i\")\n@@ -2206,16 +2206,16 @@\n   else return \\\"extd %3,%1,%0,%2\\\";\n }\")\n \n-(define_insn \"\"\n-  [(set (zero_extract:SI (match_operand:SI 0 \"memory_operand\" \"+o\")\n-\t\t\t (match_operand:SI 1 \"const_int_operand\" \"i\")\n-\t\t\t (match_operand:SI 2 \"nonmemory_operand\" \"rn\"))\n-\t(match_operand:SI 3 \"nonimmediate_operand\" \"rm\"))]\n+(define_insn \"*bitfield_set\"\n+  [(set (zero_extract:SI (match_operand:SI 0 \"memory_operand\" \"+o,+r\")\n+\t\t\t (match_operand:SI 1 \"const_int_operand\" \"i,i\")\n+\t\t\t (match_operand:SI 2 \"nonmemory_operand\" \"rn,rK\"))\n+\t(match_operand:SI 3 \"nonimmediate_operand\" \"rm,rm\"))]\n   \"TARGET_BITFIELD\"\n   \"*\n { if (GET_CODE (operands[2]) == CONST_INT)\n     {\n-      if (INTVAL (operands[2]) >= 8)\n+      if (which_alternative == 0 && INTVAL (operands[2]) >= 8)\n \t{\n \t  operands[0] = adjust_address (operands[0], QImode,\n \t\t\t\t\tINTVAL (operands[2]) / 8);\n@@ -2231,24 +2231,6 @@\n   return \\\"insd %2,%3,%0,%1\\\";\n }\")\n \n-(define_insn \"\"\n-  [(set (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"+r\")\n-\t\t\t (match_operand:SI 1 \"const_int_operand\" \"i\")\n-\t\t\t (match_operand:SI 2 \"nonmemory_operand\" \"rK\"))\n-\t(match_operand:SI 3 \"nonimmediate_operand\" \"rm\"))]\n-  \"TARGET_BITFIELD\"\n-  \"*\n-{ if (GET_CODE (operands[2]) == CONST_INT)\n-  {  \n-    if (INTVAL (operands[1]) <= 8)\n-      return \\\"inssb %3,%0,%2,%1\\\";\n-    else if (INTVAL (operands[1]) <= 16)\n-      return \\\"inssw %3,%0,%2,%1\\\";\n-    else\n-      return \\\"inssd %3,%0,%2,%1\\\";\n-  }\n-  return \\\"insd %2,%3,%0,%1\\\";\n-}\")\n \n (define_insn \"insv\"\n   [(set (zero_extract:SI (match_operand:QI 0 \"nonimmediate_operand\" \"+rm\")\n@@ -2378,7 +2360,9 @@\n   \"\"\n   \"bls %l0\")\n \f\n-(define_insn \"\"\n+;; \"Reversed\" jump instructions. Are these ever generated?\n+\n+(define_insn \"*bne\"\n   [(set (pc)\n \t(if_then_else (eq (cc0)\n \t\t\t  (const_int 0))\n@@ -2393,7 +2377,7 @@\n   else return \\\"bne %l0\\\";\n }\")\n \n-(define_insn \"\"\n+(define_insn \"*beq\"\n   [(set (pc)\n \t(if_then_else (ne (cc0)\n \t\t\t  (const_int 0))\n@@ -2408,7 +2392,7 @@\n   else return \\\"beq %l0\\\";\n }\")\n \n-(define_insn \"\"\n+(define_insn \"*ble\"\n   [(set (pc)\n \t(if_then_else (gt (cc0)\n \t\t\t  (const_int 0))\n@@ -2417,7 +2401,7 @@\n   \"\"\n   \"ble %l0\")\n \n-(define_insn \"\"\n+(define_insn \"*bleu\"\n   [(set (pc)\n \t(if_then_else (gtu (cc0)\n \t\t\t   (const_int 0))\n@@ -2426,7 +2410,7 @@\n   \"\"\n   \"bls %l0\")\n \n-(define_insn \"\"\n+(define_insn \"*bge\"\n   [(set (pc)\n \t(if_then_else (lt (cc0)\n \t\t\t  (const_int 0))\n@@ -2435,7 +2419,7 @@\n   \"\"\n   \"bge %l0\")\n \n-(define_insn \"\"\n+(define_insn \"*bgeu\"\n   [(set (pc)\n \t(if_then_else (ltu (cc0)\n \t\t\t   (const_int 0))\n@@ -2444,7 +2428,7 @@\n   \"\"\n   \"bhs %l0\")\n \n-(define_insn \"\"\n+(define_insn \"*blt\"\n   [(set (pc)\n \t(if_then_else (ge (cc0)\n \t\t\t  (const_int 0))\n@@ -2453,7 +2437,7 @@\n   \"\"\n   \"blt %l0\")\n \n-(define_insn \"\"\n+(define_insn \"*bltu\"\n   [(set (pc)\n \t(if_then_else (geu (cc0)\n \t\t\t   (const_int 0))\n@@ -2462,7 +2446,7 @@\n   \"\"\n   \"blo %l0\")\n \n-(define_insn \"\"\n+(define_insn \"*bgt\"\n   [(set (pc)\n \t(if_then_else (le (cc0)\n \t\t\t  (const_int 0))\n@@ -2471,7 +2455,7 @@\n   \"\"\n   \"bgt %l0\")\n \n-(define_insn \"\"\n+(define_insn \"*bgtu\"\n   [(set (pc)\n \t(if_then_else (leu (cc0)\n \t\t\t   (const_int 0))\n@@ -2483,7 +2467,7 @@\n ;; Subtract-and-jump and Add-and-jump insns.\n ;; These can actually be used for adding numbers in the range -8 to 7\n \n-(define_insn \"\"\n+(define_insn \"*sub_br\"\n   [(set (pc)\n \t(if_then_else\n \t (ne (match_operand:SI 0 \"nonimmediate_operand\" \"+rm\")\n@@ -2496,7 +2480,7 @@\n   \"INTVAL (operands[1]) > -8 && INTVAL (operands[1]) <= 8\"\n   \"acbd %n1,%0,%l2\")\n \n-(define_insn \"\"\n+(define_insn \"*add_br\"\n   [(set (pc)\n \t(if_then_else\n \t (ne (match_operand:SI 0 \"nonimmediate_operand\" \"+rm\")\n@@ -2512,7 +2496,8 @@\n \f\n (define_insn \"call\"\n   [(call (match_operand:QI 0 \"memory_operand\" \"m\")\n-\t (match_operand:QI 1 \"general_operand\" \"g\"))]\n+\t (match_operand 1 \"\" \"\"))]\n+  ;; Operand 1 is not used\n   \"\"\n   \"*\n {\n@@ -2551,7 +2536,8 @@\n (define_insn \"call_value\"\n   [(set (match_operand 0 \"\" \"=rf\")\n \t(call (match_operand:QI 1 \"memory_operand\" \"m\")\n-\t      (match_operand:QI 2 \"general_operand\" \"g\")))]\n+\t      (match_operand 2 \"\" \"\")))]\n+   ;; Operand 2 is not used\n   \"\"\n   \"*\n {\n@@ -2684,7 +2670,7 @@\n \n ;; Scondi instructions\n (define_insn \"seq\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm<\")\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r<\")\n \t(eq:SI (cc0) (const_int 0)))]\n   \"\"\n   \"*\n@@ -2695,8 +2681,8 @@\n   else return \\\"seqd %0\\\";\n }\")\n \n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm<\")\n+(define_insn \"*seqhi\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r<\")\n \t(eq:HI (cc0) (const_int 0)))]\n   \"\"\n   \"*\n@@ -2707,8 +2693,8 @@\n   else return \\\"seqw %0\\\";\n }\")\n \n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=rm<\")\n+(define_insn \"*seqqi\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=r<\")\n \t(eq:QI (cc0) (const_int 0)))]\n   \"\"\n   \"*\n@@ -2720,7 +2706,7 @@\n }\")\n \n (define_insn \"sne\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm<\")\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r<\")\n \t(ne:SI (cc0) (const_int 0)))]\n   \"\"\n   \"*\n@@ -2731,8 +2717,8 @@\n   else return \\\"sned %0\\\";\n }\")\n \n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm<\")\n+(define_insn \"*snehi\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r<\")\n \t(ne:HI (cc0) (const_int 0)))]\n   \"\"\n   \"*\n@@ -2743,8 +2729,8 @@\n   else return \\\"snew %0\\\";\n }\")\n \n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=rm<\")\n+(define_insn \"*sneqi\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=r<\")\n \t(ne:QI (cc0) (const_int 0)))]\n   \"\"\n   \"*\n@@ -2756,152 +2742,152 @@\n }\")\n \n (define_insn \"sgt\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm<\")\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r<\")\n \t(gt:SI (cc0) (const_int 0)))]\n   \"\"\n   \"sgtd %0\")\n \n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm<\")\n+(define_insn \"*sgthi\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r<\")\n \t(gt:HI (cc0) (const_int 0)))]\n   \"\"\n   \"sgtw %0\")\n \n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=rm<\")\n+(define_insn \"*sgtqi\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=r<\")\n \t(gt:QI (cc0) (const_int 0)))]\n   \"\"\n   \"sgtb %0\")\n \n (define_insn \"sgtu\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm<\")\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r<\")\n \t(gtu:SI (cc0) (const_int 0)))]\n   \"\"\n   \"shid %0\")\n \n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm<\")\n+(define_insn \"*sgtuhi\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r<\")\n \t(gtu:HI (cc0) (const_int 0)))]\n   \"\"\n   \"shiw %0\")\n \n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=rm<\")\n+(define_insn \"*sgtuqi\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=r<\")\n \t(gtu:QI (cc0) (const_int 0)))]\n   \"\"\n   \"shib %0\")\n \n (define_insn \"slt\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm<\")\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r<\")\n \t(lt:SI (cc0) (const_int 0)))]\n   \"\"\n   \"sltd %0\")\n \n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm<\")\n+(define_insn \"*slthi\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r<\")\n \t(lt:HI (cc0) (const_int 0)))]\n   \"\"\n   \"sltw %0\")\n \n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=rm<\")\n+(define_insn \"*sltqi\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=r<\")\n \t(lt:QI (cc0) (const_int 0)))]\n   \"\"\n   \"sltb %0\")\n \n (define_insn \"sltu\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm<\")\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r<\")\n \t(ltu:SI (cc0) (const_int 0)))]\n   \"\"\n   \"slod %0\")\n \n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm<\")\n+(define_insn \"*sltuhi\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r<\")\n \t(ltu:HI (cc0) (const_int 0)))]\n   \"\"\n   \"slow %0\")\n \n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=rm<\")\n+(define_insn \"*sltuqi\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=r<\")\n \t(ltu:QI (cc0) (const_int 0)))]\n   \"\"\n   \"slob %0\")\n \n (define_insn \"sge\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm<\")\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r<\")\n \t(ge:SI (cc0) (const_int 0)))]\n   \"\"\n   \"sged %0\")\n \n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm<\")\n+(define_insn \"*sgehi\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r<\")\n \t(ge:HI (cc0) (const_int 0)))]\n   \"\"\n   \"sgew %0\")\n \n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=rm<\")\n+(define_insn \"*sgeqi\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=r<\")\n \t(ge:QI (cc0) (const_int 0)))]\n   \"\"\n   \"sgeb %0\")\n \n (define_insn \"sgeu\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm<\")\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r<\")\n \t(geu:SI (cc0) (const_int 0)))]\n   \"\"\n   \"shsd %0\")  \n \n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm<\")\n+(define_insn \"*sgeuhi\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r<\")\n \t(geu:HI (cc0) (const_int 0)))]\n   \"\"\n   \"shsw %0\")  \n \n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=rm<\")\n+(define_insn \"*sgeuqi\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=r<\")\n \t(geu:QI (cc0) (const_int 0)))]\n   \"\"\n   \"shsb %0\")  \n \n (define_insn \"sle\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm<\")\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r<\")\n \t(le:SI (cc0) (const_int 0)))]\n   \"\"\n   \"sled %0\")\n \n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm<\")\n+(define_insn \"*slehi\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r<\")\n \t(le:HI (cc0) (const_int 0)))]\n   \"\"\n   \"slew %0\")\n \n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=rm<\")\n+(define_insn \"*sleqi\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=r<\")\n \t(le:QI (cc0) (const_int 0)))]\n   \"\"\n   \"sleb %0\")\n \n (define_insn \"sleu\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm<\")\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r<\")\n \t(leu:SI (cc0) (const_int 0)))]\n   \"\"\n   \"slsd %0\")\n \n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm<\")\n+(define_insn \"*sleuhi\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r<\")\n \t(leu:HI (cc0) (const_int 0)))]\n   \"\"\n   \"slsw %0\")\n \n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=rm<\")\n+(define_insn \"*sleuqi\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=r<\")\n \t(leu:QI (cc0) (const_int 0)))]\n   \"\"\n   \"slsb %0\")\n \f\n ;; ffs instructions\n \n-(define_insn \"\"\n+(define_insn \"*ffs\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=ro\")\n \t(minus:SI \n \t\t(plus:SI (ffs:SI (zero_extract:SI "}]}