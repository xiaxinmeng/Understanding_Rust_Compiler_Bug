{"sha": "af2728a4b41b45ab6d24a4142070a8cf620c1ebc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWYyNzI4YTRiNDFiNDVhYjZkMjRhNDE0MjA3MGE4Y2Y2MjBjMWViYw==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "2002-05-09T23:41:39Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2002-05-09T23:41:39Z"}, "message": "athlon.md, [...]: New files.\n\n        * athlon.md, k6.md, pentium.md, ppro.md): New files.\n        * i386.md: Move scheduling information into new files.\n\nFrom-SVN: r53350", "tree": {"sha": "14cba3e2277fd2ccfc0a010859ca346c5e56512f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/14cba3e2277fd2ccfc0a010859ca346c5e56512f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/af2728a4b41b45ab6d24a4142070a8cf620c1ebc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af2728a4b41b45ab6d24a4142070a8cf620c1ebc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af2728a4b41b45ab6d24a4142070a8cf620c1ebc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af2728a4b41b45ab6d24a4142070a8cf620c1ebc/comments", "author": null, "committer": null, "parents": [{"sha": "3df892916c733cfa42ffa9eaaab1c115ebfe45ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3df892916c733cfa42ffa9eaaab1c115ebfe45ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3df892916c733cfa42ffa9eaaab1c115ebfe45ce"}], "stats": {"total": 1534, "additions": 805, "deletions": 729}, "files": [{"sha": "19c06885752afb8052877065f28623280df8cefa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af2728a4b41b45ab6d24a4142070a8cf620c1ebc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af2728a4b41b45ab6d24a4142070a8cf620c1ebc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=af2728a4b41b45ab6d24a4142070a8cf620c1ebc", "patch": "@@ -62,6 +62,9 @@ doc:\n \n Thu May  9 11:50:09 2002  Jeffrey A Law  (law@cygnus.com)\n \n+\t* athlon.md, k6.md, pentium.md, ppro.md): New files.\n+\t* i386.md: Move scheduling information into new files.\n+\n \t* i386.md (type attribute): Add \"rotate\" for rotate insns.\n \t(rotate insns): Set type to \"rotate\".\n \t(various attributes and function units): Treat rotate like shift."}, {"sha": "d6a52f2cbdd95044e2d3e1408feb0c8b40baac14", "filename": "gcc/config/i386/athlon.md", "status": "added", "additions": 206, "deletions": 0, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af2728a4b41b45ab6d24a4142070a8cf620c1ebc/gcc%2Fconfig%2Fi386%2Fathlon.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af2728a4b41b45ab6d24a4142070a8cf620c1ebc/gcc%2Fconfig%2Fi386%2Fathlon.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fathlon.md?ref=af2728a4b41b45ab6d24a4142070a8cf620c1ebc", "patch": "@@ -0,0 +1,206 @@\n+;; AMD Athlon Scheduling\n+;; Copyright (C) 2002 Free Software Foundation, Inc.\n+;;\n+;; This file is part of GNU CC.\n+;;\n+;; GNU CC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+;;\n+;; GNU CC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GNU CC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 59 Temple Place - Suite 330,\n+;; Boston, MA 02111-1307, USA.  */\n+(define_attr \"athlon_decode\" \"direct,vector\"\n+  (cond [(eq_attr \"type\" \"call,imul,idiv,other,multi,fcmov,fpspc,str,pop,cld,fcmov\")\n+\t   (const_string \"vector\")\n+         (and (eq_attr \"type\" \"push\")\n+              (match_operand 1 \"memory_operand\" \"\"))\n+\t   (const_string \"vector\")\n+         (and (eq_attr \"type\" \"fmov\")\n+\t      (and (eq_attr \"memory\" \"load,store\")\n+\t\t   (eq_attr \"mode\" \"XF\")))\n+\t   (const_string \"vector\")]\n+\t(const_string \"direct\")))\n+\n+;; The Athlon does contain three pipelined FP units, three integer units and\n+;; three address generation units. \n+;;\n+;; The predecode logic is determining boundaries of instructions in the 64\n+;; byte cache line. So the cache line straddling problem of K6 might be issue\n+;; here as well, but it is not noted in the documentation.\n+;;\n+;; Three DirectPath instructions decoders and only one VectorPath decoder\n+;; is available. They can decode three DirectPath instructions or one VectorPath\n+;; instruction per cycle.\n+;; Decoded macro instructions are then passed to 72 entry instruction control\n+;; unit, that passes\n+;; it to the specialized integer (18 entry) and fp (36 entry) schedulers.\n+;;\n+;; The load/store queue unit is not attached to the schedulers but\n+;; communicates with all the execution units separately instead.\n+\n+(define_function_unit \"athlon_vectordec\" 1 0\n+  (and (eq_attr \"cpu\" \"athlon\")\n+       (eq_attr \"athlon_decode\" \"vector\"))\n+  1 1)\n+\n+(define_function_unit \"athlon_directdec\" 3 0\n+  (and (eq_attr \"cpu\" \"athlon\")\n+       (eq_attr \"athlon_decode\" \"direct\"))\n+  1 1)\n+\n+(define_function_unit \"athlon_vectordec\" 1 0\n+  (and (eq_attr \"cpu\" \"athlon\")\n+       (eq_attr \"athlon_decode\" \"direct\"))\n+  1 1 [(eq_attr \"athlon_decode\" \"vector\")])\n+\n+(define_function_unit \"athlon_ieu\" 3 0\n+  (and (eq_attr \"cpu\" \"athlon\")\n+       (eq_attr \"type\" \"alu1,negnot,alu,icmp,test,imov,imovx,lea,incdec,ishift,rotate,ibr,call,callv,icmov,cld,pop,setcc,push,pop\"))\n+  1 1)\n+\n+(define_function_unit \"athlon_ieu\" 3 0\n+  (and (eq_attr \"cpu\" \"athlon\")\n+       (eq_attr \"type\" \"str\"))\n+  15 15)\n+\n+(define_function_unit \"athlon_ieu\" 3 0\n+  (and (eq_attr \"cpu\" \"athlon\")\n+       (eq_attr \"type\" \"imul\"))\n+  5 0)\n+\n+(define_function_unit \"athlon_ieu\" 3 0\n+  (and (eq_attr \"cpu\" \"athlon\")\n+       (eq_attr \"type\" \"idiv\"))\n+  42 0)\n+\n+(define_function_unit \"athlon_muldiv\" 1 0\n+  (and (eq_attr \"cpu\" \"athlon\")\n+       (eq_attr \"type\" \"imul\"))\n+  5 0)\n+\n+(define_function_unit \"athlon_muldiv\" 1 0\n+  (and (eq_attr \"cpu\" \"athlon\")\n+       (eq_attr \"type\" \"idiv\"))\n+  42 42)\n+\n+(define_attr \"athlon_fpunits\" \"none,store,mul,add,muladd,any\"\n+  (cond [(eq_attr \"type\" \"fop,fcmp,fistp\")\n+\t   (const_string \"add\")\n+         (eq_attr \"type\" \"fmul,fdiv,fpspc,fsgn,fcmov\")\n+\t   (const_string \"mul\")\n+\t (and (eq_attr \"type\" \"fmov\") (eq_attr \"memory\" \"store,both\"))\n+\t   (const_string \"store\")\n+\t (and (eq_attr \"type\" \"fmov\") (eq_attr \"memory\" \"load\"))\n+\t   (const_string \"any\")\n+         (and (eq_attr \"type\" \"fmov\")\n+              (ior (match_operand:SI 1 \"register_operand\" \"\")\n+                   (match_operand 1 \"immediate_operand\" \"\")))\n+\t   (const_string \"store\")\n+         (eq_attr \"type\" \"fmov\")\n+\t   (const_string \"muladd\")]\n+\t(const_string \"none\")))\n+\n+;; We use latencies 1 for definitions.  This is OK to model colisions\n+;; in execution units.  The real latencies are modeled in the \"fp\" pipeline.\n+\n+;; fsin, fcos: 96-192\n+;; fsincos: 107-211\n+;; fsqrt: 19 for SFmode, 27 for DFmode, 35 for XFmode.\n+(define_function_unit \"athlon_fp\" 3 0\n+  (and (eq_attr \"cpu\" \"athlon\")\n+       (eq_attr \"type\" \"fpspc\"))\n+  100 1)\n+\n+;; 16 cycles for SFmode, 20 for DFmode and 24 for XFmode.\n+(define_function_unit \"athlon_fp\" 3 0\n+  (and (eq_attr \"cpu\" \"athlon\")\n+       (eq_attr \"type\" \"fdiv\"))\n+  24 1)\n+\n+(define_function_unit \"athlon_fp\" 3 0\n+  (and (eq_attr \"cpu\" \"athlon\")\n+       (eq_attr \"type\" \"fop,fmul,fistp\"))\n+  4 1)\n+\n+;; XFmode loads are slow.\n+;; XFmode store is slow too (8 cycles), but we don't need to model it, because\n+;; there are no dependent instructions.\n+\n+(define_function_unit \"athlon_fp\" 3 0\n+  (and (eq_attr \"cpu\" \"athlon\")\n+       (and (eq_attr \"type\" \"fmov\")\n+\t    (and (eq_attr \"memory\" \"load\")\n+\t\t (eq_attr \"mode\" \"XF\"))))\n+  10 1)\n+\n+(define_function_unit \"athlon_fp\" 3 0\n+  (and (eq_attr \"cpu\" \"athlon\")\n+       (eq_attr \"type\" \"fmov,fsgn\"))\n+  2 1)\n+\n+;; fcmp and ftst instructions\n+(define_function_unit \"athlon_fp\" 3 0\n+  (and (eq_attr \"cpu\" \"athlon\")\n+       (and (eq_attr \"type\" \"fcmp\")\n+\t    (eq_attr \"athlon_decode\" \"direct\")))\n+  3 1)\n+\n+;; fcmpi instructions.\n+(define_function_unit \"athlon_fp\" 3 0\n+  (and (eq_attr \"cpu\" \"athlon\")\n+       (and (eq_attr \"type\" \"fcmp\")\n+\t    (eq_attr \"athlon_decode\" \"vector\")))\n+  3 1)\n+\n+(define_function_unit \"athlon_fp\" 3 0\n+  (and (eq_attr \"cpu\" \"athlon\")\n+       (eq_attr \"type\" \"fcmov\"))\n+  7 1)\n+\n+(define_function_unit \"athlon_fp_mul\" 1 0\n+  (and (eq_attr \"cpu\" \"athlon\")\n+       (eq_attr \"athlon_fpunits\" \"mul\"))\n+  1 1)\n+\n+(define_function_unit \"athlon_fp_add\" 1 0\n+  (and (eq_attr \"cpu\" \"athlon\")\n+       (eq_attr \"athlon_fpunits\" \"add\"))\n+  1 1)\n+\n+(define_function_unit \"athlon_fp_muladd\" 2 0\n+  (and (eq_attr \"cpu\" \"athlon\")\n+       (eq_attr \"athlon_fpunits\" \"muladd,mul,add\"))\n+  1 1)\n+\n+(define_function_unit \"athlon_fp_store\" 1 0\n+  (and (eq_attr \"cpu\" \"athlon\")\n+       (eq_attr \"athlon_fpunits\" \"store\"))\n+  1 1)\n+\n+;; We don't need to model the Address Generation Unit, since we don't model\n+;; the re-order buffer yet and thus we never schedule more than three operations\n+;; at time.  Later we may want to experiment with MD_SCHED macros modeling the\n+;; decoders independently on the functional units.\n+\n+;(define_function_unit \"athlon_agu\" 3 0\n+;  (and (eq_attr \"cpu\" \"athlon\")\n+;       (and (eq_attr \"memory\" \"!none\")\n+;            (eq_attr \"athlon_fpunits\" \"none\")))\n+;  1 1)\n+\n+;; Model load unit to avoid too long sequences of loads.  We don't need to\n+;; model store queue, since it is hardly going to be bottleneck.\n+\n+(define_function_unit \"athlon_load\" 2 0\n+  (and (eq_attr \"cpu\" \"athlon\")\n+       (eq_attr \"memory\" \"load,both\"))\n+  1 1)\n+"}, {"sha": "fea9d981c067716e9c7f22b206adb6b444914b03", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 4, "deletions": 729, "changes": 733, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af2728a4b41b45ab6d24a4142070a8cf620c1ebc/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af2728a4b41b45ab6d24a4142070a8cf620c1ebc/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=af2728a4b41b45ab6d24a4142070a8cf620c1ebc", "patch": "@@ -322,735 +322,10 @@\n   [(set_attr \"length\" \"128\")\n    (set_attr \"type\" \"multi\")])\n \f\n-;; Pentium Scheduling\n-;;\n-;; The Pentium is an in-order core with two integer pipelines.\n-\n-;; True for insns that behave like prefixed insns on the Pentium.\n-(define_attr \"pent_prefix\" \"false,true\"\n-  (if_then_else (ior (eq_attr \"prefix_0f\" \"1\")\n-  \t\t     (ior (eq_attr \"prefix_data16\" \"1\")\n-\t\t\t  (eq_attr \"prefix_rep\" \"1\")))\n-    (const_string \"true\")\n-    (const_string \"false\")))\n-\n-;; Categorize how an instruction slots.\n-\n-;; The non-MMX Pentium slots an instruction with prefixes on U pipe only,\n-;; while MMX Pentium can slot it on either U or V.  Model non-MMX Pentium\n-;; rules, because it results in noticeably better code on non-MMX Pentium\n-;; and doesn't hurt much on MMX.  (Prefixed instructions are not very\n-;; common, so the scheduler usualy has a non-prefixed insn to pair).\n-\n-(define_attr \"pent_pair\" \"uv,pu,pv,np\"\n-  (cond [(eq_attr \"imm_disp\" \"true\")\n-\t   (const_string \"np\")\n-\t (ior (eq_attr \"type\" \"alu1,alu,imov,icmp,test,lea,incdec\")\n-\t      (and (eq_attr \"type\" \"pop,push\")\n-\t\t   (eq_attr \"memory\" \"!both\")))\n-\t   (if_then_else (eq_attr \"pent_prefix\" \"true\")\n-\t     (const_string \"pu\")\n-\t     (const_string \"uv\"))\n-\t (eq_attr \"type\" \"ibr\")\n-\t   (const_string \"pv\")\n-\t (and (eq_attr \"type\" \"ishift\")\n-\t      (match_operand 2 \"const_int_operand\" \"\"))\n-\t   (const_string \"pu\")\n-\t (and (eq_attr \"type\" \"rotate\")\n-\t      (match_operand 2 \"const_int_1_operand\" \"\"))\n-\t   (const_string \"pu\")\n-\t (and (eq_attr \"type\" \"call\")\n-\t      (match_operand 0 \"constant_call_address_operand\" \"\"))\n-\t   (const_string \"pv\")\n-\t (and (eq_attr \"type\" \"callv\")\n-\t      (match_operand 1 \"constant_call_address_operand\" \"\"))\n-\t   (const_string \"pv\")\n-\t]\n-\t(const_string \"np\")))\n-\n-(define_automaton \"pentium,pentium_fpu\")\n-\n-;; Pentium do have U and V pipes.  Instruction to both pipes\n-;; are alwyas issued together, much like on VLIW.\n-;;\n-;;                    predecode\n-;;                   /         \\\n-;;               decodeu     decodev\n-;;             /    |           |\n-;;           fpu executeu    executev\n-;;            |     |           |\n-;;           fpu  retire     retire\n-;;            |\n-;;           fpu\n-;; We add dummy \"port\" pipes allocated only first cycle of\n-;; instruction to specify this behaviour.\n-\n-(define_cpu_unit \"pentium-portu,pentium-portv\" \"pentium\")\n-(define_cpu_unit \"pentium-u,pentium-v\" \"pentium\")\n-(absence_set \"pentium-portu\" \"pentium-u,pentium-v\")\n-(presence_set \"pentium-portv\" \"pentium-portu\")\n-\n-;; Floating point instructions can overlap with new issue of integer\n-;; instructions.  We model only first cycle of FP pipeline, as it is\n-;; fully pipelined.\n-(define_cpu_unit \"pentium-fp\" \"pentium_fpu\")\n-\n-;; There is non-pipelined multiplier unit used for complex operations.\n-(define_cpu_unit \"pentium-fmul\" \"pentium_fpu\")\n-\n-;; Pentium preserves memory ordering, so when load-execute-store\n-;; instruction is executed together with other instruction loading\n-;; data, the execution of the other instruction is delayed to very\n-;; last cycle of first instruction, when data are bypassed.\n-;; We model this by allocating \"memory\" unit when store is pending\n-;; and using conflicting load units together.\n-\n-(define_cpu_unit \"pentium-memory\" \"pentium\")\n-(define_cpu_unit \"pentium-load0\" \"pentium\")\n-(define_cpu_unit \"pentium-load1\" \"pentium\")\n-(absence_set \"pentium-load0,pentium-load1\" \"pentium-memory\")\n-\n-(define_reservation \"pentium-load\" \"(pentium-load0 | pentium-load1)\")\n-(define_reservation \"pentium-np\" \"(pentium-u + pentium-v)\")\n-(define_reservation \"pentium-uv\" \"(pentium-u | pentium-v)\")\n-(define_reservation \"pentium-portuv\" \"(pentium-portu | pentium-portv)\")\n-(define_reservation \"pentium-firstu\" \"(pentium-u + pentium-portu)\")\n-(define_reservation \"pentium-firstv\" \"(pentium-v + pentium-portuv)\")\n-(define_reservation \"pentium-firstuv\" \"(pentium-uv + pentium-portuv)\")\n-(define_reservation \"pentium-firstuload\" \"(pentium-load + pentium-firstu)\")\n-(define_reservation \"pentium-firstvload\" \"(pentium-load + pentium-firstv)\")\n-(define_reservation \"pentium-firstuvload\" \"(pentium-load + pentium-firstuv)\n-\t\t\t\t\t   | (pentium-firstv,pentium-v,\n-\t\t\t\t\t      (pentium-load+pentium-firstv))\")\n-(define_reservation \"pentium-firstuboth\" \"(pentium-load + pentium-firstu\n-\t\t\t\t\t   + pentium-memory)\")\n-(define_reservation \"pentium-firstvboth\" \"(pentium-load + pentium-firstu\n-\t\t\t\t\t   + pentium-memory)\")\n-(define_reservation \"pentium-firstuvboth\" \"(pentium-load + pentium-firstuv\n-\t\t\t\t\t    + pentium-memory)\n-\t\t\t\t\t   | (pentium-firstv,pentium-v,\n-\t\t\t\t\t      (pentium-load+pentium-firstv))\")\n-\n-;; Few common long latency instructions\n-(define_insn_reservation \"pent_mul\" 11\n-  (and (eq_attr \"cpu\" \"pentium\")\n-       (eq_attr \"type\" \"imul\"))\n-  \"pentium-np*11\")\n-\n-(define_insn_reservation \"pent_str\" 12\n-  (and (eq_attr \"cpu\" \"pentium\")\n-       (eq_attr \"type\" \"str\"))\n-  \"pentium-np*12\")\n-\n-;; Integer division and some other long latency instruction block all\n-;; units, including the FP pipe.  There is no value in modeling the\n-;; latency of these instructions and not modeling the latency\n-;; decreases the size of the DFA.\n-(define_insn_reservation \"pent_block\" 1\n-  (and (eq_attr \"cpu\" \"pentium\")\n-       (eq_attr \"type\" \"idiv\"))\n-  \"pentium-np+pentium-fp\")\n-\n-(define_insn_reservation \"pent_cld\" 2\n-  (and (eq_attr \"cpu\" \"pentium\")\n-       (eq_attr \"type\" \"cld\"))\n-  \"pentium-np*2\")\n-\n-;;  Moves usually have one cycle penalty, but there are exceptions.\n-(define_insn_reservation \"pent_fmov\" 1\n-  (and (eq_attr \"cpu\" \"pentium\")\n-       (and (eq_attr \"type\" \"fmov\")\n-\t    (eq_attr \"memory\" \"none,load\")))\n-  \"(pentium-fp+pentium-np)\")\n-\n-(define_insn_reservation \"pent_fpmovxf\" 3\n-  (and (eq_attr \"cpu\" \"pentium\")\n-       (and (eq_attr \"type\" \"fmov\")\n-\t    (and (eq_attr \"memory\" \"load,store\")\n-\t\t (eq_attr \"mode\" \"XF\"))))\n-  \"(pentium-fp+pentium-np)*3\")\n-\n-(define_insn_reservation \"pent_fpstore\" 2\n-  (and (eq_attr \"cpu\" \"pentium\")\n-       (and (eq_attr \"type\" \"fmov\")\n-\t    (ior (match_operand 1 \"immediate_operand\" \"\")\n-\t\t (eq_attr \"memory\" \"store\"))))\n-  \"(pentium-fp+pentium-np)*2\")\n-\n-(define_insn_reservation \"pent_imov\" 1\n-  (and (eq_attr \"cpu\" \"pentium\")\n-       (eq_attr \"type\" \"imov\"))\n-  \"pentium-firstuv\")\n-\n-;; Push and pop instructions have 1 cycle latency and special\n-;; hardware bypass allows them to be paired with other push,pop\n-;; and call instructions.\n-(define_bypass 0 \"pent_push,pent_pop\" \"pent_push,pent_pop,pent_call\")\n-(define_insn_reservation \"pent_push\" 1\n-  (and (eq_attr \"cpu\" \"pentium\")\n-       (and (eq_attr \"type\" \"push\")\n-\t    (eq_attr \"memory\" \"store\")))\n-  \"pentium-firstuv\")\n-\n-(define_insn_reservation \"pent_pop\" 1\n-  (and (eq_attr \"cpu\" \"pentium\")\n-       (eq_attr \"type\" \"pop\"))\n-  \"pentium-firstuv\")\n-\n-;; Call and branch instruction can execute in either pipe, but\n-;; they are only pairable when in the v pipe.\n-(define_insn_reservation \"pent_call\" 10\n-  (and (eq_attr \"cpu\" \"pentium\")\n-       (eq_attr \"type\" \"call,callv\"))\n-  \"pentium-firstv,pentium-v*9\")\n-\n-(define_insn_reservation \"pent_branch\" 1\n-  (and (eq_attr \"cpu\" \"pentium\")\n-       (eq_attr \"type\" \"ibr\"))\n-  \"pentium-firstv\")\n-\n-;; Floating point instruction dispatch in U pipe, but continue\n-;; in FP pipeline allowing other isntructions to be executed.\n-(define_insn_reservation \"pent_fp\" 3\n-  (and (eq_attr \"cpu\" \"pentium\")\n-       (eq_attr \"type\" \"fop,fistp\"))\n-  \"(pentium-firstu+pentium-fp),nothing,nothing\")\n-\n-;; First two cycles of fmul are not pipelined.\n-(define_insn_reservation \"pent_fmul\" 3\n-  (and (eq_attr \"cpu\" \"pentium\")\n-       (eq_attr \"type\" \"fmul\"))\n-  \"(pentium-firstuv+pentium-fp+pentium-fmul),pentium-fmul,nothing\")\n-\n-;; Long latency FP instructions overlap with integer instructions,\n-;; but only last 2 cycles with FP ones.\n-(define_insn_reservation \"pent_fdiv\" 39\n-  (and (eq_attr \"cpu\" \"pentium\")\n-       (eq_attr \"type\" \"fdiv\"))\n-  \"(pentium-np+pentium-fp+pentium-fmul),\n-   (pentium-fp+pentium-fmul)*36,pentium-fmul*2\")\n-\n-(define_insn_reservation \"pent_fpspc\" 70\n-  (and (eq_attr \"cpu\" \"pentium\")\n-       (eq_attr \"type\" \"fpspc\"))\n-  \"(pentium-np+pentium-fp+pentium-fmul),\n-   (pentium-fp+pentium-fmul)*67,pentium-fmul*2\")\n-\n-;; Integer instructions.  Load/execute/store takes 3 cycles,\n-;; load/execute 2 cycles and execute only one cycle.\n-(define_insn_reservation \"pent_uv_both\" 3\n-  (and (eq_attr \"cpu\" \"pentium\")\n-       (and (eq_attr \"pent_pair\" \"uv\")\n-\t    (eq_attr \"memory\" \"both\")))\n-  \"pentium-firstuvboth,pentium-uv+pentium-memory,pentium-uv\")\n-\n-(define_insn_reservation \"pent_u_both\" 3\n-  (and (eq_attr \"cpu\" \"pentium\")\n-       (and (eq_attr \"pent_pair\" \"pu\")\n-\t    (eq_attr \"memory\" \"both\")))\n-  \"pentium-firstuboth,pentium-u+pentium-memory,pentium-u\")\n-\n-(define_insn_reservation \"pent_v_both\" 3\n-  (and (eq_attr \"cpu\" \"pentium\")\n-       (and (eq_attr \"pent_pair\" \"pv\")\n-\t    (eq_attr \"memory\" \"both\")))\n-  \"pentium-firstvboth,pentium-v+pentium-memory,pentium-v\")\n-\n-(define_insn_reservation \"pent_np_both\" 3\n-  (and (eq_attr \"cpu\" \"pentium\")\n-       (and (eq_attr \"pent_pair\" \"np\")\n-\t    (eq_attr \"memory\" \"both\")))\n-  \"pentium-np,pentium-np,pentium-np\")\n-\n-(define_insn_reservation \"pent_uv_load\" 2\n-  (and (eq_attr \"cpu\" \"pentium\")\n-       (and (eq_attr \"pent_pair\" \"uv\")\n-\t    (eq_attr \"memory\" \"load\")))\n-  \"pentium-firstuvload,pentium-uv\")\n-\n-(define_insn_reservation \"pent_u_load\" 2\n-  (and (eq_attr \"cpu\" \"pentium\")\n-       (and (eq_attr \"pent_pair\" \"pu\")\n-\t    (eq_attr \"memory\" \"load\")))\n-  \"pentium-firstuload,pentium-u\")\n-\n-(define_insn_reservation \"pent_v_load\" 2\n-  (and (eq_attr \"cpu\" \"pentium\")\n-       (and (eq_attr \"pent_pair\" \"pv\")\n-\t    (eq_attr \"memory\" \"load\")))\n-  \"pentium-firstvload,pentium-v\")\n-\n-(define_insn_reservation \"pent_np_load\" 2\n-  (and (eq_attr \"cpu\" \"pentium\")\n-       (and (eq_attr \"pent_pair\" \"np\")\n-\t    (eq_attr \"memory\" \"load\")))\n-  \"pentium-np,pentium-np\")\n-\n-(define_insn_reservation \"pent_uv\" 1\n-  (and (eq_attr \"cpu\" \"pentium\")\n-       (and (eq_attr \"pent_pair\" \"uv\")\n-\t    (eq_attr \"memory\" \"none\")))\n-  \"pentium-firstuv\")\n-\n-(define_insn_reservation \"pent_u\" 1\n-  (and (eq_attr \"cpu\" \"pentium\")\n-       (and (eq_attr \"pent_pair\" \"pu\")\n-\t    (eq_attr \"memory\" \"none\")))\n-  \"pentium-firstu\")\n-\n-(define_insn_reservation \"pent_v\" 1\n-  (and (eq_attr \"cpu\" \"pentium\")\n-       (and (eq_attr \"pent_pair\" \"pv\")\n-\t    (eq_attr \"memory\" \"none\")))\n-  \"pentium-firstv\")\n-\n-(define_insn_reservation \"pent_np\" 1\n-  (and (eq_attr \"cpu\" \"pentium\")\n-       (and (eq_attr \"pent_pair\" \"np\")\n-\t    (eq_attr \"memory\" \"none\")))\n-  \"pentium-np\")\n-\n-\f\n-;; Pentium Pro/PII Scheduling\n-;;\n-;; The PPro has an out-of-order core, but the instruction decoders are\n-;; naturally in-order and asymmetric.  We get best performance by scheduling\n-;; for the decoders, for in doing so we give the oo execution unit the \n-;; most choices.\n-\n-;; Categorize how many uops an ia32 instruction evaluates to:\n-;;   one --  an instruction with 1 uop can be decoded by any of the\n-;;           three decoders.\n-;;   few --  an instruction with 1 to 4 uops can be decoded only by \n-;;\t     decoder 0.\n-;;   many -- a complex instruction may take an unspecified number of\n-;;\t     cycles to decode in decoder 0.\n-\n-(define_attr \"ppro_uops\" \"one,few,many\"\n-  (cond [(eq_attr \"type\" \"other,multi,call,callv,fpspc,str\")\n-\t   (const_string \"many\")\n-\t (eq_attr \"type\" \"icmov,fcmov,str,cld\")\n-\t   (const_string \"few\")\n-\t (eq_attr \"type\" \"imov\")\n-\t   (if_then_else (eq_attr \"memory\" \"store,both\")\n-\t     (const_string \"few\")\n-\t     (const_string \"one\"))\n-\t (eq_attr \"memory\" \"!none\")\n-\t   (const_string \"few\")\n-\t]\n-\t(const_string \"one\")))\n-\n-;; Rough readiness numbers.  Fine tuning happens in i386.c.\n-;;\n-;; p0\tdescribes port 0.\n-;; p01\tdescribes ports 0 and 1 as a pair; alu insns can issue to either.\n-;; p2\tdescribes port 2 for loads.\n-;; p34\tdescribes ports 3 and 4 for stores.\n-;; fpu\tdescribes the fpu accessed via port 0. \n-;;\t??? It is less than clear if there are separate fadd and fmul units\n-;;\tthat could operate in parallel.\n-;;\n-;; ??? fxch isn't handled; not an issue until sched3 after reg-stack is real.\n-\n-(define_function_unit \"ppro_p0\" 1 0\n-  (and (eq_attr \"cpu\" \"pentiumpro\")\n-       (eq_attr \"type\" \"ishift,rotate,lea,ibr,cld\"))\n-  1 1)\n-\n-(define_function_unit \"ppro_p0\" 1 0\n-  (and (eq_attr \"cpu\" \"pentiumpro\")\n-       (eq_attr \"type\" \"imul\"))\n-  4 1)\n-\n-;; ??? Does the divider lock out the pipe while it works,\n-;; or is there a disconnected unit?\n-(define_function_unit \"ppro_p0\" 1 0\n-  (and (eq_attr \"cpu\" \"pentiumpro\")\n-       (eq_attr \"type\" \"idiv\"))\n-  17 17)\n-\n-(define_function_unit \"ppro_p0\" 1 0\n-  (and (eq_attr \"cpu\" \"pentiumpro\")\n-       (eq_attr \"type\" \"fop,fsgn,fistp\"))\n-  3 1)\n-\n-(define_function_unit \"ppro_p0\" 1 0\n-  (and (eq_attr \"cpu\" \"pentiumpro\")\n-       (eq_attr \"type\" \"fcmov\"))\n-  2 1)\n-\n-(define_function_unit \"ppro_p0\" 1 0\n-  (and (eq_attr \"cpu\" \"pentiumpro\")\n-       (eq_attr \"type\" \"fcmp\"))\n-  1 1)\n-\n-(define_function_unit \"ppro_p0\" 1 0\n-  (and (eq_attr \"cpu\" \"pentiumpro\")\n-       (eq_attr \"type\" \"fmov\"))\n-  1 1)\n-\n-(define_function_unit \"ppro_p0\" 1 0\n-  (and (eq_attr \"cpu\" \"pentiumpro\")\n-       (eq_attr \"type\" \"fmul\"))\n-  5 1)\n-\n-(define_function_unit \"ppro_p0\" 1 0\n-  (and (eq_attr \"cpu\" \"pentiumpro\")\n-       (eq_attr \"type\" \"fdiv,fpspc\"))\n-  56 1)\n-\n-(define_function_unit \"ppro_p01\" 2 0\n-  (and (eq_attr \"cpu\" \"pentiumpro\")\n-       (eq_attr \"type\" \"!imov,fmov\"))\n-  1 1)\n-\n-(define_function_unit \"ppro_p01\" 2 0\n-  (and (and (eq_attr \"cpu\" \"pentiumpro\")\n-            (eq_attr \"type\" \"imov,fmov\"))\n-       (eq_attr \"memory\" \"none\"))\n-  1 1)\n-\n-(define_function_unit \"ppro_p2\" 1 0\n-  (and (eq_attr \"cpu\" \"pentiumpro\")\n-       (ior (eq_attr \"type\" \"pop\")\n-\t    (eq_attr \"memory\" \"load,both\")))\n-  3 1)\n-\n-(define_function_unit \"ppro_p34\" 1 0\n-  (and (eq_attr \"cpu\" \"pentiumpro\")\n-       (ior (eq_attr \"type\" \"push\")\n-\t    (eq_attr \"memory\" \"store,both\")))\n-  1 1)\n-\n-(define_function_unit \"fpu\" 1 0\n-  (and (eq_attr \"cpu\" \"pentiumpro\")\n-       (eq_attr \"type\" \"fop,fsgn,fmov,fcmp,fcmov,fistp\"))\n-  1 1)\n-\n-(define_function_unit \"fpu\" 1 0\n-  (and (eq_attr \"cpu\" \"pentiumpro\")\n-       (eq_attr \"type\" \"fmul\"))\n-  5 2)\n-\n-(define_function_unit \"fpu\" 1 0\n-  (and (eq_attr \"cpu\" \"pentiumpro\")\n-       (eq_attr \"type\" \"fdiv,fpspc\"))\n-  56 56)\n-\n-;; imul uses the fpu.  ??? does it have the same throughput as fmul?\n-(define_function_unit \"fpu\" 1 0\n-  (and (eq_attr \"cpu\" \"pentiumpro\")\n-       (eq_attr \"type\" \"imul\"))\n-  4 1)\n-\f\n-;; AMD K6/K6-2 Scheduling\n-;;\n-;; The K6 has similar architecture to PPro.  Important difference is, that\n-;; there are only two decoders and they seems to be much slower than execution\n-;; units.  So we have to pay much more attention to proper decoding for\n-;; schedulers.  We share most of scheduler code for PPro in i386.c\n-;;\n-;; The fp unit is not pipelined and do one operation per two cycles including\n-;; the FXCH.\n-;;\n-;; alu\t  describes both ALU units (ALU-X and ALU-Y).\n-;; alux   describes X alu unit\n-;; fpu    describes FPU unit\n-;; load   describes load unit.\n-;; branch describes branch unit.\n-;; store  decsribes store unit.  This unit is not modelled completely and only\n-;;        used to model lea operation.  Otherwise it lie outside of the critical\n-;;        path.\n-;;\n-;; ??? fxch isn't handled; not an issue until sched3 after reg-stack is real.\n-\n-;; The decoder specification is in the PPro section above!\n-\n-;; Shift instructions and certain arithmetic are issued only to X pipe.\n-(define_function_unit \"k6_alux\" 1 0\n-  (and (eq_attr \"cpu\" \"k6\")\n-       (eq_attr \"type\" \"ishift,rotate,alu1,negnot,cld\"))\n-  1 1)\n-\n-;; The QI mode arithmetic is issued to X pipe only.\n-(define_function_unit \"k6_alux\" 1 0\n-  (and (eq_attr \"cpu\" \"k6\")\n-       (and (eq_attr \"type\" \"alu,alu1,negnot,icmp,test,imovx,incdec\")\n-\t    (match_operand:QI 0 \"general_operand\" \"\")))\n-  1 1)\n-\n-(define_function_unit \"k6_alu\" 2 0\n-  (and (eq_attr \"cpu\" \"k6\")\n-       (eq_attr \"type\" \"ishift,rotate,alu1,negnot,alu,icmp,test,imovx,incdec,setcc,lea\"))\n-  1 1)\n-\n-(define_function_unit \"k6_alu\" 2 0\n-  (and (eq_attr \"cpu\" \"k6\")\n-       (and (eq_attr \"type\" \"imov\")\n-       \t    (eq_attr \"memory\" \"none\")))\n-  1 1)\n-\n-(define_function_unit \"k6_branch\" 1 0\n-  (and (eq_attr \"cpu\" \"k6\")\n-       (eq_attr \"type\" \"call,callv,ibr\"))\n-  1 1)\n-\n-;; Load unit have two cycle latency, but we take care for it in adjust_cost\n-(define_function_unit \"k6_load\" 1 0\n-  (and (eq_attr \"cpu\" \"k6\")\n-       (ior (eq_attr \"type\" \"pop\")\n-\t    (eq_attr \"memory\" \"load,both\")))\n-  1 1)\n-\n-(define_function_unit \"k6_load\" 1 0\n-  (and (eq_attr \"cpu\" \"k6\")\n-       (and (eq_attr \"type\" \"str\")\n-\t    (eq_attr \"memory\" \"load,both\")))\n-  10 10)\n-\n-;; Lea have two instructions, so latency is probably 2\n-(define_function_unit \"k6_store\" 1 0\n-  (and (eq_attr \"cpu\" \"k6\")\n-       (eq_attr \"type\" \"lea\"))\n-  2 1)\n-\n-(define_function_unit \"k6_store\" 1 0\n-  (and (eq_attr \"cpu\" \"k6\")\n-       (eq_attr \"type\" \"str\"))\n-  10 10)\n-\n-(define_function_unit \"k6_store\" 1 0\n-  (and (eq_attr \"cpu\" \"k6\")\n-       (ior (eq_attr \"type\" \"push\")\n-\t    (eq_attr \"memory\" \"store,both\")))\n-  1 1)\n-\n-(define_function_unit \"k6_fpu\" 1 1\n-  (and (eq_attr \"cpu\" \"k6\")\n-       (eq_attr \"type\" \"fop,fmov,fcmp,fistp\"))\n-  2 2)\n-\n-(define_function_unit \"k6_fpu\" 1 1\n-  (and (eq_attr \"cpu\" \"k6\")\n-       (eq_attr \"type\" \"fmul\"))\n-  2 2)\n-\n-;; ??? Guess\n-(define_function_unit \"k6_fpu\" 1 1\n-  (and (eq_attr \"cpu\" \"k6\")\n-       (eq_attr \"type\" \"fdiv,fpspc\"))\n-  56 56)\n-\n-(define_function_unit \"k6_alu\" 2 0\n-  (and (eq_attr \"cpu\" \"k6\")\n-       (eq_attr \"type\" \"imul\"))\n-  2 2)\n-\n-(define_function_unit \"k6_alux\" 1 0\n-  (and (eq_attr \"cpu\" \"k6\")\n-       (eq_attr \"type\" \"imul\"))\n-  2 2)\n-\n-;; ??? Guess\n-(define_function_unit \"k6_alu\" 2 0\n-  (and (eq_attr \"cpu\" \"k6\")\n-       (eq_attr \"type\" \"idiv\"))\n-  17 17)\n-\n-(define_function_unit \"k6_alux\" 1 0\n-  (and (eq_attr \"cpu\" \"k6\")\n-       (eq_attr \"type\" \"idiv\"))\n-  17 17)\n-\f\n-;; AMD Athlon Scheduling\n-;;\n-;; The Athlon does contain three pipelined FP units, three integer units and\n-;; three address generation units. \n-;;\n-;; The predecode logic is determining boundaries of instructions in the 64\n-;; byte cache line. So the cache line straddling problem of K6 might be issue\n-;; here as well, but it is not noted in the documentation.\n-;;\n-;; Three DirectPath instructions decoders and only one VectorPath decoder\n-;; is available. They can decode three DirectPath instructions or one VectorPath\n-;; instruction per cycle.\n-;; Decoded macro instructions are then passed to 72 entry instruction control\n-;; unit, that passes\n-;; it to the specialized integer (18 entry) and fp (36 entry) schedulers.\n-;;\n-;; The load/store queue unit is not attached to the schedulers but\n-;; communicates with all the execution units separately instead.\n-\n-(define_attr \"athlon_decode\" \"direct,vector\"\n-  (cond [(eq_attr \"type\" \"call,imul,idiv,other,multi,fcmov,fpspc,str,pop,cld,fcmov\")\n-\t   (const_string \"vector\")\n-         (and (eq_attr \"type\" \"push\")\n-              (match_operand 1 \"memory_operand\" \"\"))\n-\t   (const_string \"vector\")\n-         (and (eq_attr \"type\" \"fmov\")\n-\t      (and (eq_attr \"memory\" \"load,store\")\n-\t\t   (eq_attr \"mode\" \"XF\")))\n-\t   (const_string \"vector\")]\n-\t(const_string \"direct\")))\n-\n-(define_function_unit \"athlon_vectordec\" 1 0\n-  (and (eq_attr \"cpu\" \"athlon\")\n-       (eq_attr \"athlon_decode\" \"vector\"))\n-  1 1)\n-\n-(define_function_unit \"athlon_directdec\" 3 0\n-  (and (eq_attr \"cpu\" \"athlon\")\n-       (eq_attr \"athlon_decode\" \"direct\"))\n-  1 1)\n-\n-(define_function_unit \"athlon_vectordec\" 1 0\n-  (and (eq_attr \"cpu\" \"athlon\")\n-       (eq_attr \"athlon_decode\" \"direct\"))\n-  1 1 [(eq_attr \"athlon_decode\" \"vector\")])\n-\n-(define_function_unit \"athlon_ieu\" 3 0\n-  (and (eq_attr \"cpu\" \"athlon\")\n-       (eq_attr \"type\" \"alu1,negnot,alu,icmp,test,imov,imovx,lea,incdec,ishift,rotate,ibr,call,callv,icmov,cld,pop,setcc,push,pop\"))\n-  1 1)\n-\n-(define_function_unit \"athlon_ieu\" 3 0\n-  (and (eq_attr \"cpu\" \"athlon\")\n-       (eq_attr \"type\" \"str\"))\n-  15 15)\n-\n-(define_function_unit \"athlon_ieu\" 3 0\n-  (and (eq_attr \"cpu\" \"athlon\")\n-       (eq_attr \"type\" \"imul\"))\n-  5 0)\n-\n-(define_function_unit \"athlon_ieu\" 3 0\n-  (and (eq_attr \"cpu\" \"athlon\")\n-       (eq_attr \"type\" \"idiv\"))\n-  42 0)\n-\n-(define_function_unit \"athlon_muldiv\" 1 0\n-  (and (eq_attr \"cpu\" \"athlon\")\n-       (eq_attr \"type\" \"imul\"))\n-  5 0)\n-\n-(define_function_unit \"athlon_muldiv\" 1 0\n-  (and (eq_attr \"cpu\" \"athlon\")\n-       (eq_attr \"type\" \"idiv\"))\n-  42 42)\n-\n-(define_attr \"athlon_fpunits\" \"none,store,mul,add,muladd,any\"\n-  (cond [(eq_attr \"type\" \"fop,fcmp,fistp\")\n-\t   (const_string \"add\")\n-         (eq_attr \"type\" \"fmul,fdiv,fpspc,fsgn,fcmov\")\n-\t   (const_string \"mul\")\n-\t (and (eq_attr \"type\" \"fmov\") (eq_attr \"memory\" \"store,both\"))\n-\t   (const_string \"store\")\n-\t (and (eq_attr \"type\" \"fmov\") (eq_attr \"memory\" \"load\"))\n-\t   (const_string \"any\")\n-         (and (eq_attr \"type\" \"fmov\")\n-              (ior (match_operand:SI 1 \"register_operand\" \"\")\n-                   (match_operand 1 \"immediate_operand\" \"\")))\n-\t   (const_string \"store\")\n-         (eq_attr \"type\" \"fmov\")\n-\t   (const_string \"muladd\")]\n-\t(const_string \"none\")))\n-\n-;; We use latencies 1 for definitions.  This is OK to model colisions\n-;; in execution units.  The real latencies are modeled in the \"fp\" pipeline.\n-\n-;; fsin, fcos: 96-192\n-;; fsincos: 107-211\n-;; fsqrt: 19 for SFmode, 27 for DFmode, 35 for XFmode.\n-(define_function_unit \"athlon_fp\" 3 0\n-  (and (eq_attr \"cpu\" \"athlon\")\n-       (eq_attr \"type\" \"fpspc\"))\n-  100 1)\n-\n-;; 16 cycles for SFmode, 20 for DFmode and 24 for XFmode.\n-(define_function_unit \"athlon_fp\" 3 0\n-  (and (eq_attr \"cpu\" \"athlon\")\n-       (eq_attr \"type\" \"fdiv\"))\n-  24 1)\n-\n-(define_function_unit \"athlon_fp\" 3 0\n-  (and (eq_attr \"cpu\" \"athlon\")\n-       (eq_attr \"type\" \"fop,fmul,fistp\"))\n-  4 1)\n-\n-;; XFmode loads are slow.\n-;; XFmode store is slow too (8 cycles), but we don't need to model it, because\n-;; there are no dependent instructions.\n-\n-(define_function_unit \"athlon_fp\" 3 0\n-  (and (eq_attr \"cpu\" \"athlon\")\n-       (and (eq_attr \"type\" \"fmov\")\n-\t    (and (eq_attr \"memory\" \"load\")\n-\t\t (eq_attr \"mode\" \"XF\"))))\n-  10 1)\n-\n-(define_function_unit \"athlon_fp\" 3 0\n-  (and (eq_attr \"cpu\" \"athlon\")\n-       (eq_attr \"type\" \"fmov,fsgn\"))\n-  2 1)\n-\n-;; fcmp and ftst instructions\n-(define_function_unit \"athlon_fp\" 3 0\n-  (and (eq_attr \"cpu\" \"athlon\")\n-       (and (eq_attr \"type\" \"fcmp\")\n-\t    (eq_attr \"athlon_decode\" \"direct\")))\n-  3 1)\n-\n-;; fcmpi instructions.\n-(define_function_unit \"athlon_fp\" 3 0\n-  (and (eq_attr \"cpu\" \"athlon\")\n-       (and (eq_attr \"type\" \"fcmp\")\n-\t    (eq_attr \"athlon_decode\" \"vector\")))\n-  3 1)\n-\n-(define_function_unit \"athlon_fp\" 3 0\n-  (and (eq_attr \"cpu\" \"athlon\")\n-       (eq_attr \"type\" \"fcmov\"))\n-  7 1)\n-\n-(define_function_unit \"athlon_fp_mul\" 1 0\n-  (and (eq_attr \"cpu\" \"athlon\")\n-       (eq_attr \"athlon_fpunits\" \"mul\"))\n-  1 1)\n-\n-(define_function_unit \"athlon_fp_add\" 1 0\n-  (and (eq_attr \"cpu\" \"athlon\")\n-       (eq_attr \"athlon_fpunits\" \"add\"))\n-  1 1)\n-\n-(define_function_unit \"athlon_fp_muladd\" 2 0\n-  (and (eq_attr \"cpu\" \"athlon\")\n-       (eq_attr \"athlon_fpunits\" \"muladd,mul,add\"))\n-  1 1)\n-\n-(define_function_unit \"athlon_fp_store\" 1 0\n-  (and (eq_attr \"cpu\" \"athlon\")\n-       (eq_attr \"athlon_fpunits\" \"store\"))\n-  1 1)\n-\n-;; We don't need to model the Address Generation Unit, since we don't model\n-;; the re-order buffer yet and thus we never schedule more than three operations\n-;; at time.  Later we may want to experiment with MD_SCHED macros modeling the\n-;; decoders independently on the functional units.\n-\n-;(define_function_unit \"athlon_agu\" 3 0\n-;  (and (eq_attr \"cpu\" \"athlon\")\n-;       (and (eq_attr \"memory\" \"!none\")\n-;            (eq_attr \"athlon_fpunits\" \"none\")))\n-;  1 1)\n-\n-;; Model load unit to avoid too long sequences of loads.  We don't need to\n-;; model store queue, since it is hardly going to be bottleneck.\n-\n-(define_function_unit \"athlon_load\" 2 0\n-  (and (eq_attr \"cpu\" \"athlon\")\n-       (eq_attr \"memory\" \"load,both\"))\n-  1 1)\n-\n+(include \"pentium.md\")\n+(include \"ppro.md\")\n+(include \"k6.md\")\n+(include \"athlon.md\")\n \f\n ;; Compare instructions.\n "}, {"sha": "a68983a0d66d50b4964e0b77f9da796bce5a9342", "filename": "gcc/config/i386/k6.md", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af2728a4b41b45ab6d24a4142070a8cf620c1ebc/gcc%2Fconfig%2Fi386%2Fk6.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af2728a4b41b45ab6d24a4142070a8cf620c1ebc/gcc%2Fconfig%2Fi386%2Fk6.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fk6.md?ref=af2728a4b41b45ab6d24a4142070a8cf620c1ebc", "patch": "@@ -0,0 +1,136 @@\n+;; AMD K6/K6-2 Scheduling\n+;; Copyright (C) 2002 ;; Free Software Foundation, Inc.\n+;;\n+;; This file is part of GNU CC.\n+;;\n+;; GNU CC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+;;\n+;; GNU CC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GNU CC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 59 Temple Place - Suite 330,\n+;; Boston, MA 02111-1307, USA.  */\n+;;\n+;; The K6 has similar architecture to PPro.  Important difference is, that\n+;; there are only two decoders and they seems to be much slower than execution\n+;; units.  So we have to pay much more attention to proper decoding for\n+;; schedulers.  We share most of scheduler code for PPro in i386.c\n+;;\n+;; The fp unit is not pipelined and do one operation per two cycles including\n+;; the FXCH.\n+;;\n+;; alu\t  describes both ALU units (ALU-X and ALU-Y).\n+;; alux   describes X alu unit\n+;; fpu    describes FPU unit\n+;; load   describes load unit.\n+;; branch describes branch unit.\n+;; store  decsribes store unit.  This unit is not modelled completely and only\n+;;        used to model lea operation.  Otherwise it lie outside of the critical\n+;;        path.\n+;;\n+;; ??? fxch isn't handled; not an issue until sched3 after reg-stack is real.\n+\n+;; The decoder specification is in the PPro section above!\n+\n+;; Shift instructions and certain arithmetic are issued only to X pipe.\n+(define_function_unit \"k6_alux\" 1 0\n+  (and (eq_attr \"cpu\" \"k6\")\n+       (eq_attr \"type\" \"ishift,rotate,alu1,negnot,cld\"))\n+  1 1)\n+\n+;; The QI mode arithmetic is issued to X pipe only.\n+(define_function_unit \"k6_alux\" 1 0\n+  (and (eq_attr \"cpu\" \"k6\")\n+       (and (eq_attr \"type\" \"alu,alu1,negnot,icmp,test,imovx,incdec\")\n+\t    (match_operand:QI 0 \"general_operand\" \"\")))\n+  1 1)\n+\n+(define_function_unit \"k6_alu\" 2 0\n+  (and (eq_attr \"cpu\" \"k6\")\n+       (eq_attr \"type\" \"ishift,rotate,alu1,negnot,alu,icmp,test,imovx,incdec,setcc,lea\"))\n+  1 1)\n+\n+(define_function_unit \"k6_alu\" 2 0\n+  (and (eq_attr \"cpu\" \"k6\")\n+       (and (eq_attr \"type\" \"imov\")\n+       \t    (eq_attr \"memory\" \"none\")))\n+  1 1)\n+\n+(define_function_unit \"k6_branch\" 1 0\n+  (and (eq_attr \"cpu\" \"k6\")\n+       (eq_attr \"type\" \"call,callv,ibr\"))\n+  1 1)\n+\n+;; Load unit have two cycle latency, but we take care for it in adjust_cost\n+(define_function_unit \"k6_load\" 1 0\n+  (and (eq_attr \"cpu\" \"k6\")\n+       (ior (eq_attr \"type\" \"pop\")\n+\t    (eq_attr \"memory\" \"load,both\")))\n+  1 1)\n+\n+(define_function_unit \"k6_load\" 1 0\n+  (and (eq_attr \"cpu\" \"k6\")\n+       (and (eq_attr \"type\" \"str\")\n+\t    (eq_attr \"memory\" \"load,both\")))\n+  10 10)\n+\n+;; Lea have two instructions, so latency is probably 2\n+(define_function_unit \"k6_store\" 1 0\n+  (and (eq_attr \"cpu\" \"k6\")\n+       (eq_attr \"type\" \"lea\"))\n+  2 1)\n+\n+(define_function_unit \"k6_store\" 1 0\n+  (and (eq_attr \"cpu\" \"k6\")\n+       (eq_attr \"type\" \"str\"))\n+  10 10)\n+\n+(define_function_unit \"k6_store\" 1 0\n+  (and (eq_attr \"cpu\" \"k6\")\n+       (ior (eq_attr \"type\" \"push\")\n+\t    (eq_attr \"memory\" \"store,both\")))\n+  1 1)\n+\n+(define_function_unit \"k6_fpu\" 1 1\n+  (and (eq_attr \"cpu\" \"k6\")\n+       (eq_attr \"type\" \"fop,fmov,fcmp,fistp\"))\n+  2 2)\n+\n+(define_function_unit \"k6_fpu\" 1 1\n+  (and (eq_attr \"cpu\" \"k6\")\n+       (eq_attr \"type\" \"fmul\"))\n+  2 2)\n+\n+;; ??? Guess\n+(define_function_unit \"k6_fpu\" 1 1\n+  (and (eq_attr \"cpu\" \"k6\")\n+       (eq_attr \"type\" \"fdiv,fpspc\"))\n+  56 56)\n+\n+(define_function_unit \"k6_alu\" 2 0\n+  (and (eq_attr \"cpu\" \"k6\")\n+       (eq_attr \"type\" \"imul\"))\n+  2 2)\n+\n+(define_function_unit \"k6_alux\" 1 0\n+  (and (eq_attr \"cpu\" \"k6\")\n+       (eq_attr \"type\" \"imul\"))\n+  2 2)\n+\n+;; ??? Guess\n+(define_function_unit \"k6_alu\" 2 0\n+  (and (eq_attr \"cpu\" \"k6\")\n+       (eq_attr \"type\" \"idiv\"))\n+  17 17)\n+\n+(define_function_unit \"k6_alux\" 1 0\n+  (and (eq_attr \"cpu\" \"k6\")\n+       (eq_attr \"type\" \"idiv\"))\n+  17 17)"}, {"sha": "2d418bdf119ff117bb5ed951ad6874a1dacda24b", "filename": "gcc/config/i386/pentium.md", "status": "added", "additions": 306, "deletions": 0, "changes": 306, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af2728a4b41b45ab6d24a4142070a8cf620c1ebc/gcc%2Fconfig%2Fi386%2Fpentium.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af2728a4b41b45ab6d24a4142070a8cf620c1ebc/gcc%2Fconfig%2Fi386%2Fpentium.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpentium.md?ref=af2728a4b41b45ab6d24a4142070a8cf620c1ebc", "patch": "@@ -0,0 +1,306 @@\n+;; Pentium Scheduling\n+;; Copyright (C) 2002 Free Software Foundation, Inc.\n+;;\n+;; This file is part of GNU CC.\n+;;\n+;; GNU CC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+;;\n+;; GNU CC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GNU CC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 59 Temple Place - Suite 330,\n+;; Boston, MA 02111-1307, USA.  */\n+;;\n+;; The Pentium is an in-order core with two integer pipelines.\n+\n+;; True for insns that behave like prefixed insns on the Pentium.\n+(define_attr \"pent_prefix\" \"false,true\"\n+  (if_then_else (ior (eq_attr \"prefix_0f\" \"1\")\n+  \t\t     (ior (eq_attr \"prefix_data16\" \"1\")\n+\t\t\t  (eq_attr \"prefix_rep\" \"1\")))\n+    (const_string \"true\")\n+    (const_string \"false\")))\n+\n+;; Categorize how an instruction slots.\n+\n+;; The non-MMX Pentium slots an instruction with prefixes on U pipe only,\n+;; while MMX Pentium can slot it on either U or V.  Model non-MMX Pentium\n+;; rules, because it results in noticeably better code on non-MMX Pentium\n+;; and doesn't hurt much on MMX.  (Prefixed instructions are not very\n+;; common, so the scheduler usualy has a non-prefixed insn to pair).\n+\n+(define_attr \"pent_pair\" \"uv,pu,pv,np\"\n+  (cond [(eq_attr \"imm_disp\" \"true\")\n+\t   (const_string \"np\")\n+\t (ior (eq_attr \"type\" \"alu1,alu,imov,icmp,test,lea,incdec\")\n+\t      (and (eq_attr \"type\" \"pop,push\")\n+\t\t   (eq_attr \"memory\" \"!both\")))\n+\t   (if_then_else (eq_attr \"pent_prefix\" \"true\")\n+\t     (const_string \"pu\")\n+\t     (const_string \"uv\"))\n+\t (eq_attr \"type\" \"ibr\")\n+\t   (const_string \"pv\")\n+\t (and (eq_attr \"type\" \"ishift\")\n+\t      (match_operand 2 \"const_int_operand\" \"\"))\n+\t   (const_string \"pu\")\n+\t (and (eq_attr \"type\" \"rotate\")\n+\t      (match_operand 2 \"const_int_1_operand\" \"\"))\n+\t   (const_string \"pu\")\n+\t (and (eq_attr \"type\" \"call\")\n+\t      (match_operand 0 \"constant_call_address_operand\" \"\"))\n+\t   (const_string \"pv\")\n+\t (and (eq_attr \"type\" \"callv\")\n+\t      (match_operand 1 \"constant_call_address_operand\" \"\"))\n+\t   (const_string \"pv\")\n+\t]\n+\t(const_string \"np\")))\n+\n+(define_automaton \"pentium,pentium_fpu\")\n+\n+;; Pentium do have U and V pipes.  Instruction to both pipes\n+;; are alwyas issued together, much like on VLIW.\n+;;\n+;;                    predecode\n+;;                   /         \\\n+;;               decodeu     decodev\n+;;             /    |           |\n+;;           fpu executeu    executev\n+;;            |     |           |\n+;;           fpu  retire     retire\n+;;            |\n+;;           fpu\n+;; We add dummy \"port\" pipes allocated only first cycle of\n+;; instruction to specify this behaviour.\n+\n+(define_cpu_unit \"pentium-portu,pentium-portv\" \"pentium\")\n+(define_cpu_unit \"pentium-u,pentium-v\" \"pentium\")\n+(absence_set \"pentium-portu\" \"pentium-u,pentium-v\")\n+(presence_set \"pentium-portv\" \"pentium-portu\")\n+\n+;; Floating point instructions can overlap with new issue of integer\n+;; instructions.  We model only first cycle of FP pipeline, as it is\n+;; fully pipelined.\n+(define_cpu_unit \"pentium-fp\" \"pentium_fpu\")\n+\n+;; There is non-pipelined multiplier unit used for complex operations.\n+(define_cpu_unit \"pentium-fmul\" \"pentium_fpu\")\n+\n+;; Pentium preserves memory ordering, so when load-execute-store\n+;; instruction is executed together with other instruction loading\n+;; data, the execution of the other instruction is delayed to very\n+;; last cycle of first instruction, when data are bypassed.\n+;; We model this by allocating \"memory\" unit when store is pending\n+;; and using conflicting load units together.\n+\n+(define_cpu_unit \"pentium-memory\" \"pentium\")\n+(define_cpu_unit \"pentium-load0\" \"pentium\")\n+(define_cpu_unit \"pentium-load1\" \"pentium\")\n+(absence_set \"pentium-load0,pentium-load1\" \"pentium-memory\")\n+\n+(define_reservation \"pentium-load\" \"(pentium-load0 | pentium-load1)\")\n+(define_reservation \"pentium-np\" \"(pentium-u + pentium-v)\")\n+(define_reservation \"pentium-uv\" \"(pentium-u | pentium-v)\")\n+(define_reservation \"pentium-portuv\" \"(pentium-portu | pentium-portv)\")\n+(define_reservation \"pentium-firstu\" \"(pentium-u + pentium-portu)\")\n+(define_reservation \"pentium-firstv\" \"(pentium-v + pentium-portuv)\")\n+(define_reservation \"pentium-firstuv\" \"(pentium-uv + pentium-portuv)\")\n+(define_reservation \"pentium-firstuload\" \"(pentium-load + pentium-firstu)\")\n+(define_reservation \"pentium-firstvload\" \"(pentium-load + pentium-firstv)\")\n+(define_reservation \"pentium-firstuvload\" \"(pentium-load + pentium-firstuv)\n+\t\t\t\t\t   | (pentium-firstv,pentium-v,\n+\t\t\t\t\t      (pentium-load+pentium-firstv))\")\n+(define_reservation \"pentium-firstuboth\" \"(pentium-load + pentium-firstu\n+\t\t\t\t\t   + pentium-memory)\")\n+(define_reservation \"pentium-firstvboth\" \"(pentium-load + pentium-firstu\n+\t\t\t\t\t   + pentium-memory)\")\n+(define_reservation \"pentium-firstuvboth\" \"(pentium-load + pentium-firstuv\n+\t\t\t\t\t    + pentium-memory)\n+\t\t\t\t\t   | (pentium-firstv,pentium-v,\n+\t\t\t\t\t      (pentium-load+pentium-firstv))\")\n+\n+;; Few common long latency instructions\n+(define_insn_reservation \"pent_mul\" 11\n+  (and (eq_attr \"cpu\" \"pentium\")\n+       (eq_attr \"type\" \"imul\"))\n+  \"pentium-np*11\")\n+\n+(define_insn_reservation \"pent_str\" 12\n+  (and (eq_attr \"cpu\" \"pentium\")\n+       (eq_attr \"type\" \"str\"))\n+  \"pentium-np*12\")\n+\n+;; Integer division and some other long latency instruction block all\n+;; units, including the FP pipe.  There is no value in modeling the\n+;; latency of these instructions and not modeling the latency\n+;; decreases the size of the DFA.\n+(define_insn_reservation \"pent_block\" 1\n+  (and (eq_attr \"cpu\" \"pentium\")\n+       (eq_attr \"type\" \"idiv\"))\n+  \"pentium-np+pentium-fp\")\n+\n+(define_insn_reservation \"pent_cld\" 2\n+  (and (eq_attr \"cpu\" \"pentium\")\n+       (eq_attr \"type\" \"cld\"))\n+  \"pentium-np*2\")\n+\n+;;  Moves usually have one cycle penalty, but there are exceptions.\n+(define_insn_reservation \"pent_fmov\" 1\n+  (and (eq_attr \"cpu\" \"pentium\")\n+       (and (eq_attr \"type\" \"fmov\")\n+\t    (eq_attr \"memory\" \"none,load\")))\n+  \"(pentium-fp+pentium-np)\")\n+\n+(define_insn_reservation \"pent_fpmovxf\" 3\n+  (and (eq_attr \"cpu\" \"pentium\")\n+       (and (eq_attr \"type\" \"fmov\")\n+\t    (and (eq_attr \"memory\" \"load,store\")\n+\t\t (eq_attr \"mode\" \"XF\"))))\n+  \"(pentium-fp+pentium-np)*3\")\n+\n+(define_insn_reservation \"pent_fpstore\" 2\n+  (and (eq_attr \"cpu\" \"pentium\")\n+       (and (eq_attr \"type\" \"fmov\")\n+\t    (ior (match_operand 1 \"immediate_operand\" \"\")\n+\t\t (eq_attr \"memory\" \"store\"))))\n+  \"(pentium-fp+pentium-np)*2\")\n+\n+(define_insn_reservation \"pent_imov\" 1\n+  (and (eq_attr \"cpu\" \"pentium\")\n+       (eq_attr \"type\" \"imov\"))\n+  \"pentium-firstuv\")\n+\n+;; Push and pop instructions have 1 cycle latency and special\n+;; hardware bypass allows them to be paired with other push,pop\n+;; and call instructions.\n+(define_bypass 0 \"pent_push,pent_pop\" \"pent_push,pent_pop,pent_call\")\n+(define_insn_reservation \"pent_push\" 1\n+  (and (eq_attr \"cpu\" \"pentium\")\n+       (and (eq_attr \"type\" \"push\")\n+\t    (eq_attr \"memory\" \"store\")))\n+  \"pentium-firstuv\")\n+\n+(define_insn_reservation \"pent_pop\" 1\n+  (and (eq_attr \"cpu\" \"pentium\")\n+       (eq_attr \"type\" \"pop\"))\n+  \"pentium-firstuv\")\n+\n+;; Call and branch instruction can execute in either pipe, but\n+;; they are only pairable when in the v pipe.\n+(define_insn_reservation \"pent_call\" 10\n+  (and (eq_attr \"cpu\" \"pentium\")\n+       (eq_attr \"type\" \"call,callv\"))\n+  \"pentium-firstv,pentium-v*9\")\n+\n+(define_insn_reservation \"pent_branch\" 1\n+  (and (eq_attr \"cpu\" \"pentium\")\n+       (eq_attr \"type\" \"ibr\"))\n+  \"pentium-firstv\")\n+\n+;; Floating point instruction dispatch in U pipe, but continue\n+;; in FP pipeline allowing other isntructions to be executed.\n+(define_insn_reservation \"pent_fp\" 3\n+  (and (eq_attr \"cpu\" \"pentium\")\n+       (eq_attr \"type\" \"fop,fistp\"))\n+  \"(pentium-firstu+pentium-fp),nothing,nothing\")\n+\n+;; First two cycles of fmul are not pipelined.\n+(define_insn_reservation \"pent_fmul\" 3\n+  (and (eq_attr \"cpu\" \"pentium\")\n+       (eq_attr \"type\" \"fmul\"))\n+  \"(pentium-firstuv+pentium-fp+pentium-fmul),pentium-fmul,nothing\")\n+\n+;; Long latency FP instructions overlap with integer instructions,\n+;; but only last 2 cycles with FP ones.\n+(define_insn_reservation \"pent_fdiv\" 39\n+  (and (eq_attr \"cpu\" \"pentium\")\n+       (eq_attr \"type\" \"fdiv\"))\n+  \"(pentium-np+pentium-fp+pentium-fmul),\n+   (pentium-fp+pentium-fmul)*36,pentium-fmul*2\")\n+\n+(define_insn_reservation \"pent_fpspc\" 70\n+  (and (eq_attr \"cpu\" \"pentium\")\n+       (eq_attr \"type\" \"fpspc\"))\n+  \"(pentium-np+pentium-fp+pentium-fmul),\n+   (pentium-fp+pentium-fmul)*67,pentium-fmul*2\")\n+\n+;; Integer instructions.  Load/execute/store takes 3 cycles,\n+;; load/execute 2 cycles and execute only one cycle.\n+(define_insn_reservation \"pent_uv_both\" 3\n+  (and (eq_attr \"cpu\" \"pentium\")\n+       (and (eq_attr \"pent_pair\" \"uv\")\n+\t    (eq_attr \"memory\" \"both\")))\n+  \"pentium-firstuvboth,pentium-uv+pentium-memory,pentium-uv\")\n+\n+(define_insn_reservation \"pent_u_both\" 3\n+  (and (eq_attr \"cpu\" \"pentium\")\n+       (and (eq_attr \"pent_pair\" \"pu\")\n+\t    (eq_attr \"memory\" \"both\")))\n+  \"pentium-firstuboth,pentium-u+pentium-memory,pentium-u\")\n+\n+(define_insn_reservation \"pent_v_both\" 3\n+  (and (eq_attr \"cpu\" \"pentium\")\n+       (and (eq_attr \"pent_pair\" \"pv\")\n+\t    (eq_attr \"memory\" \"both\")))\n+  \"pentium-firstvboth,pentium-v+pentium-memory,pentium-v\")\n+\n+(define_insn_reservation \"pent_np_both\" 3\n+  (and (eq_attr \"cpu\" \"pentium\")\n+       (and (eq_attr \"pent_pair\" \"np\")\n+\t    (eq_attr \"memory\" \"both\")))\n+  \"pentium-np,pentium-np,pentium-np\")\n+\n+(define_insn_reservation \"pent_uv_load\" 2\n+  (and (eq_attr \"cpu\" \"pentium\")\n+       (and (eq_attr \"pent_pair\" \"uv\")\n+\t    (eq_attr \"memory\" \"load\")))\n+  \"pentium-firstuvload,pentium-uv\")\n+\n+(define_insn_reservation \"pent_u_load\" 2\n+  (and (eq_attr \"cpu\" \"pentium\")\n+       (and (eq_attr \"pent_pair\" \"pu\")\n+\t    (eq_attr \"memory\" \"load\")))\n+  \"pentium-firstuload,pentium-u\")\n+\n+(define_insn_reservation \"pent_v_load\" 2\n+  (and (eq_attr \"cpu\" \"pentium\")\n+       (and (eq_attr \"pent_pair\" \"pv\")\n+\t    (eq_attr \"memory\" \"load\")))\n+  \"pentium-firstvload,pentium-v\")\n+\n+(define_insn_reservation \"pent_np_load\" 2\n+  (and (eq_attr \"cpu\" \"pentium\")\n+       (and (eq_attr \"pent_pair\" \"np\")\n+\t    (eq_attr \"memory\" \"load\")))\n+  \"pentium-np,pentium-np\")\n+\n+(define_insn_reservation \"pent_uv\" 1\n+  (and (eq_attr \"cpu\" \"pentium\")\n+       (and (eq_attr \"pent_pair\" \"uv\")\n+\t    (eq_attr \"memory\" \"none\")))\n+  \"pentium-firstuv\")\n+\n+(define_insn_reservation \"pent_u\" 1\n+  (and (eq_attr \"cpu\" \"pentium\")\n+       (and (eq_attr \"pent_pair\" \"pu\")\n+\t    (eq_attr \"memory\" \"none\")))\n+  \"pentium-firstu\")\n+\n+(define_insn_reservation \"pent_v\" 1\n+  (and (eq_attr \"cpu\" \"pentium\")\n+       (and (eq_attr \"pent_pair\" \"pv\")\n+\t    (eq_attr \"memory\" \"none\")))\n+  \"pentium-firstv\")\n+\n+(define_insn_reservation \"pent_np\" 1\n+  (and (eq_attr \"cpu\" \"pentium\")\n+       (and (eq_attr \"pent_pair\" \"np\")\n+\t    (eq_attr \"memory\" \"none\")))\n+  \"pentium-np\")\n+"}, {"sha": "f7afa4f644e85f399c73695d64a5b63798e69a13", "filename": "gcc/config/i386/ppro.md", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af2728a4b41b45ab6d24a4142070a8cf620c1ebc/gcc%2Fconfig%2Fi386%2Fppro.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af2728a4b41b45ab6d24a4142070a8cf620c1ebc/gcc%2Fconfig%2Fi386%2Fppro.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fppro.md?ref=af2728a4b41b45ab6d24a4142070a8cf620c1ebc", "patch": "@@ -0,0 +1,150 @@\n+;; Pentium Pro/PII Scheduling\n+;; Copyright (C) 2002 Free Software Foundation, Inc.\n+;;\n+;; This file is part of GNU CC.\n+;;\n+;; GNU CC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+;;\n+;; GNU CC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GNU CC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 59 Temple Place - Suite 330,\n+;; Boston, MA 02111-1307, USA.  */\n+\n+;; Categorize how many uops an ia32 instruction evaluates to:\n+;;   one --  an instruction with 1 uop can be decoded by any of the\n+;;           three decoders.\n+;;   few --  an instruction with 1 to 4 uops can be decoded only by \n+;;\t     decoder 0.\n+;;   many -- a complex instruction may take an unspecified number of\n+;;\t     cycles to decode in decoder 0.\n+\n+(define_attr \"ppro_uops\" \"one,few,many\"\n+  (cond [(eq_attr \"type\" \"other,multi,call,callv,fpspc,str\")\n+\t   (const_string \"many\")\n+\t (eq_attr \"type\" \"icmov,fcmov,str,cld\")\n+\t   (const_string \"few\")\n+\t (eq_attr \"type\" \"imov\")\n+\t   (if_then_else (eq_attr \"memory\" \"store,both\")\n+\t     (const_string \"few\")\n+\t     (const_string \"one\"))\n+\t (eq_attr \"memory\" \"!none\")\n+\t   (const_string \"few\")\n+\t]\n+\t(const_string \"one\")))\n+\n+;;\n+;; The PPro has an out-of-order core, but the instruction decoders are\n+;; naturally in-order and asymmetric.  We get best performance by scheduling\n+;; for the decoders, for in doing so we give the oo execution unit the \n+;; most choices.\n+;;\n+;; Rough readiness numbers.  Fine tuning happens in i386.c.\n+;;\n+;; p0\tdescribes port 0.\n+;; p01\tdescribes ports 0 and 1 as a pair; alu insns can issue to either.\n+;; p2\tdescribes port 2 for loads.\n+;; p34\tdescribes ports 3 and 4 for stores.\n+;; fpu\tdescribes the fpu accessed via port 0. \n+;;\t??? It is less than clear if there are separate fadd and fmul units\n+;;\tthat could operate in parallel.\n+;;\n+;; ??? fxch isn't handled; not an issue until sched3 after reg-stack is real.\n+\n+(define_function_unit \"ppro_p0\" 1 0\n+  (and (eq_attr \"cpu\" \"pentiumpro\")\n+       (eq_attr \"type\" \"ishift,rotate,lea,ibr,cld\"))\n+  1 1)\n+\n+(define_function_unit \"ppro_p0\" 1 0\n+  (and (eq_attr \"cpu\" \"pentiumpro\")\n+       (eq_attr \"type\" \"imul\"))\n+  4 1)\n+\n+;; ??? Does the divider lock out the pipe while it works,\n+;; or is there a disconnected unit?\n+(define_function_unit \"ppro_p0\" 1 0\n+  (and (eq_attr \"cpu\" \"pentiumpro\")\n+       (eq_attr \"type\" \"idiv\"))\n+  17 17)\n+\n+(define_function_unit \"ppro_p0\" 1 0\n+  (and (eq_attr \"cpu\" \"pentiumpro\")\n+       (eq_attr \"type\" \"fop,fsgn,fistp\"))\n+  3 1)\n+\n+(define_function_unit \"ppro_p0\" 1 0\n+  (and (eq_attr \"cpu\" \"pentiumpro\")\n+       (eq_attr \"type\" \"fcmov\"))\n+  2 1)\n+\n+(define_function_unit \"ppro_p0\" 1 0\n+  (and (eq_attr \"cpu\" \"pentiumpro\")\n+       (eq_attr \"type\" \"fcmp\"))\n+  1 1)\n+\n+(define_function_unit \"ppro_p0\" 1 0\n+  (and (eq_attr \"cpu\" \"pentiumpro\")\n+       (eq_attr \"type\" \"fmov\"))\n+  1 1)\n+\n+(define_function_unit \"ppro_p0\" 1 0\n+  (and (eq_attr \"cpu\" \"pentiumpro\")\n+       (eq_attr \"type\" \"fmul\"))\n+  5 1)\n+\n+(define_function_unit \"ppro_p0\" 1 0\n+  (and (eq_attr \"cpu\" \"pentiumpro\")\n+       (eq_attr \"type\" \"fdiv,fpspc\"))\n+  56 1)\n+\n+(define_function_unit \"ppro_p01\" 2 0\n+  (and (eq_attr \"cpu\" \"pentiumpro\")\n+       (eq_attr \"type\" \"!imov,fmov\"))\n+  1 1)\n+\n+(define_function_unit \"ppro_p01\" 2 0\n+  (and (and (eq_attr \"cpu\" \"pentiumpro\")\n+            (eq_attr \"type\" \"imov,fmov\"))\n+       (eq_attr \"memory\" \"none\"))\n+  1 1)\n+\n+(define_function_unit \"ppro_p2\" 1 0\n+  (and (eq_attr \"cpu\" \"pentiumpro\")\n+       (ior (eq_attr \"type\" \"pop\")\n+\t    (eq_attr \"memory\" \"load,both\")))\n+  3 1)\n+\n+(define_function_unit \"ppro_p34\" 1 0\n+  (and (eq_attr \"cpu\" \"pentiumpro\")\n+       (ior (eq_attr \"type\" \"push\")\n+\t    (eq_attr \"memory\" \"store,both\")))\n+  1 1)\n+\n+(define_function_unit \"fpu\" 1 0\n+  (and (eq_attr \"cpu\" \"pentiumpro\")\n+       (eq_attr \"type\" \"fop,fsgn,fmov,fcmp,fcmov,fistp\"))\n+  1 1)\n+\n+(define_function_unit \"fpu\" 1 0\n+  (and (eq_attr \"cpu\" \"pentiumpro\")\n+       (eq_attr \"type\" \"fmul\"))\n+  5 2)\n+\n+(define_function_unit \"fpu\" 1 0\n+  (and (eq_attr \"cpu\" \"pentiumpro\")\n+       (eq_attr \"type\" \"fdiv,fpspc\"))\n+  56 56)\n+\n+;; imul uses the fpu.  ??? does it have the same throughput as fmul?\n+(define_function_unit \"fpu\" 1 0\n+  (and (eq_attr \"cpu\" \"pentiumpro\")\n+       (eq_attr \"type\" \"imul\"))\n+  4 1)"}]}