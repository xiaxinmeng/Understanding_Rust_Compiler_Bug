{"sha": "3e605b20a0c804d57d4be0f4f2bbab8b4e42fce6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2U2MDViMjBhMGM4MDRkNTdkNGJlMGY0ZjJiYmFiOGI0ZTQyZmNlNg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2014-10-27T17:42:12Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2014-10-27T17:42:12Z"}, "message": "Implement N3653 (Member initializers and aggregates) and fix references to 'this' in constexpr constructors.\n\n\tImplement N3653 (Member initializers and aggregates) and fix\n\treferences to 'this' in constexpr constructors.\n\t* class.c (check_field_decls): In C++14 an NSDMI does not make the\n\tclass non-aggregate.\n\t* constexpr.c (struct constexpr_ctx): New.\n\t(cxx_bind_parameters_in_call): Handle 'this'.\n\t(cxx_eval_call_expression): Create new constexpr_ctx.\n\t(cxx_eval_component_reference): Check CONSTRUCTOR_NO_IMPLICIT_ZERO.\n\t(initialized_type, init_subob_ctx, verify_ctor_sanity): New.\n\t(cxx_eval_bare_aggregate): Use them.  Build CONSTRUCTOR early.\n\t(cxx_eval_vec_init_1): Likewise.\n\t(cxx_eval_constant_expression) [PARM_DECL]: Allow 'this'.\n\t[TARGET_EXPR]: Build new constexpr_ctx.\n\t[PLACEHOLDER_EXPR]: New.\n\t(cxx_eval_outermost_constant_expr): Build new constexpr_ctx.  Add\n\tobject parameter.\n\t(is_sub_constant_expr): Build new constexpr_ctx.\n\t(potential_constant_expression_1): Handle PLACEHOLDER_EXPR.\n\tAllow 'this'.\n\t* cp-gimplify.c (cp_gimplify_init_expr): Call replace_placeholders.\n\t* cp-tree.h (CONSTRUCTOR_NO_IMPLICIT_ZERO): New.\n\t* error.c (dump_expr): Handle PLACEHOLDER_EXPR.\n\t* init.c (get_nsdmi): Generate PLACEHOLDER_EXPR.\n\t* tree.c (lvalue_kind): Handle PLACEHOLDER_EXPR.\n\t(build_ctor_subob_ref, replace_placeholders): New.\n\t* typeck2.c (store_init_value): Use replace_placeholders.\n\t(process_init_constructor_record): Make zero-init before NSDMI\n\texplicit.\n\nFrom-SVN: r216750", "tree": {"sha": "ac2bca0b20f76ea658c7bbcb7dda73ababce83b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ac2bca0b20f76ea658c7bbcb7dda73ababce83b9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3e605b20a0c804d57d4be0f4f2bbab8b4e42fce6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e605b20a0c804d57d4be0f4f2bbab8b4e42fce6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e605b20a0c804d57d4be0f4f2bbab8b4e42fce6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e605b20a0c804d57d4be0f4f2bbab8b4e42fce6/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ddc8de034a1f79861fed57b231813a5c5c48a130", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddc8de034a1f79861fed57b231813a5c5c48a130", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ddc8de034a1f79861fed57b231813a5c5c48a130"}], "stats": {"total": 814, "additions": 624, "deletions": 190}, "files": [{"sha": "90e69a36bc47d536b00c8c468ec2a946c3b4fc20", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e605b20a0c804d57d4be0f4f2bbab8b4e42fce6/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e605b20a0c804d57d4be0f4f2bbab8b4e42fce6/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=3e605b20a0c804d57d4be0f4f2bbab8b4e42fce6", "patch": "@@ -1,3 +1,34 @@\n+2014-10-24  Jason Merrill  <jason@redhat.com>\n+\n+\tImplement N3653 (Member initializers and aggregates) and fix\n+\treferences to 'this' in constexpr constructors.\n+\t* class.c (check_field_decls): In C++14 an NSDMI does not make the\n+\tclass non-aggregate.\n+\t* constexpr.c (struct constexpr_ctx): New.\n+\t(cxx_bind_parameters_in_call): Handle 'this'.\n+\t(cxx_eval_call_expression): Create new constexpr_ctx.\n+\t(cxx_eval_component_reference): Check CONSTRUCTOR_NO_IMPLICIT_ZERO.\n+\t(initialized_type, init_subob_ctx, verify_ctor_sanity): New.\n+\t(cxx_eval_bare_aggregate): Use them.  Build CONSTRUCTOR early.\n+\t(cxx_eval_vec_init_1): Likewise.\n+\t(cxx_eval_constant_expression) [PARM_DECL]: Allow 'this'.\n+\t[TARGET_EXPR]: Build new constexpr_ctx.\n+\t[PLACEHOLDER_EXPR]: New.\n+\t(cxx_eval_outermost_constant_expr): Build new constexpr_ctx.  Add\n+\tobject parameter.\n+\t(is_sub_constant_expr): Build new constexpr_ctx.\n+\t(potential_constant_expression_1): Handle PLACEHOLDER_EXPR.\n+\tAllow 'this'.\n+\t* cp-gimplify.c (cp_gimplify_init_expr): Call replace_placeholders.\n+\t* cp-tree.h (CONSTRUCTOR_NO_IMPLICIT_ZERO): New.\n+\t* error.c (dump_expr): Handle PLACEHOLDER_EXPR.\n+\t* init.c (get_nsdmi): Generate PLACEHOLDER_EXPR.\n+\t* tree.c (lvalue_kind): Handle PLACEHOLDER_EXPR.\n+\t(build_ctor_subob_ref, replace_placeholders): New.\n+\t* typeck2.c (store_init_value): Use replace_placeholders.\n+\t(process_init_constructor_record): Make zero-init before NSDMI\n+\texplicit.\n+\n 2014-10-27  Andrew MacLeod  <amacleod@redhat.com>\n \n \t* cp-gimplify.c: Adjust include files."}, {"sha": "5f50aff2417fc2556e481327cf565a4f13e1b7b9", "filename": "gcc/cp/class.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e605b20a0c804d57d4be0f4f2bbab8b4e42fce6/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e605b20a0c804d57d4be0f4f2bbab8b4e42fce6/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=3e605b20a0c804d57d4be0f4f2bbab8b4e42fce6", "patch": "@@ -3659,8 +3659,8 @@ check_field_decls (tree t, tree *access_decls,\n \n       /* Now that we've removed bit-field widths from DECL_INITIAL,\n \t anything left in DECL_INITIAL is an NSDMI that makes the class\n-\t non-aggregate.  */\n-      if (DECL_INITIAL (x))\n+\t non-aggregate in C++11.  */\n+      if (DECL_INITIAL (x) && cxx_dialect < cxx14)\n \tCLASSTYPE_NON_AGGREGATE (t) = true;\n \n       /* If any field is const, the structure type is pseudo-const.  */"}, {"sha": "cd10766aebd861fa96bf7cebbdcfd28720af30c2", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 346, "deletions": 166, "changes": 512, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e605b20a0c804d57d4be0f4f2bbab8b4e42fce6/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e605b20a0c804d57d4be0f4f2bbab8b4e42fce6/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=3e605b20a0c804d57d4be0f4f2bbab8b4e42fce6", "patch": "@@ -846,14 +846,26 @@ struct constexpr_call_hasher : ggc_hasher<constexpr_call *>\n {\n   static hashval_t hash (constexpr_call *);\n   static bool equal (constexpr_call *, constexpr_call *);\n-\t\t     };\n+};\n+\n+/* The constexpr expansion context.  CALL is the current function\n+   expansion, CTOR is the current aggregate initializer, OBJECT is the\n+   object being initialized by CTOR, either a VAR_DECL or a _REF.  VALUES\n+   is a map of values of variables initialized within the expression.  */\n+\n+struct constexpr_ctx {\n+  constexpr_call *call;\n+  hash_map<tree,tree> *values;\n+  tree ctor;\n+  tree object;\n+};\n \n /* A table of all constexpr calls that have been evaluated by the\n    compiler in this translation unit.  */\n \n static GTY (()) hash_table<constexpr_call_hasher> *constexpr_call_table;\n \n-static tree cxx_eval_constant_expression (const constexpr_call *, tree,\n+static tree cxx_eval_constant_expression (const constexpr_ctx *, tree,\n \t\t\t\t\t  bool, bool, bool *, bool *);\n \n /* Compute a hash value for a constexpr call representation.  */\n@@ -964,7 +976,7 @@ lookup_parameter_binding (const constexpr_call *call, tree t)\n    represented by _CST nodes.  */\n \n static tree\n-cxx_eval_builtin_function_call (const constexpr_call *call, tree t,\n+cxx_eval_builtin_function_call (const constexpr_ctx *ctx, tree t,\n \t\t\t\tbool allow_non_constant, bool addr,\n \t\t\t\tbool *non_constant_p, bool *overflow_p)\n {\n@@ -974,7 +986,7 @@ cxx_eval_builtin_function_call (const constexpr_call *call, tree t,\n   int i;\n   for (i = 0; i < nargs; ++i)\n     {\n-      args[i] = cxx_eval_constant_expression (call, CALL_EXPR_ARG (t, i),\n+      args[i] = cxx_eval_constant_expression (ctx, CALL_EXPR_ARG (t, i),\n \t\t\t\t\t      allow_non_constant, addr,\n \t\t\t\t\t      non_constant_p, overflow_p);\n       if (allow_non_constant && *non_constant_p)\n@@ -1006,12 +1018,12 @@ adjust_temp_type (tree type, tree temp)\n \n /* Subroutine of cxx_eval_call_expression.\n    We are processing a call expression (either CALL_EXPR or\n-   AGGR_INIT_EXPR) in the call context of OLD_CALL.  Evaluate\n+   AGGR_INIT_EXPR) in the context of CTX.  Evaluate\n    all arguments and bind their values to correspondings\n    parameters, making up the NEW_CALL context.  */\n \n static void\n-cxx_bind_parameters_in_call (const constexpr_call *old_call, tree t,\n+cxx_bind_parameters_in_call (const constexpr_ctx *ctx, tree t,\n                              constexpr_call *new_call,\n \t\t\t     bool allow_non_constant,\n \t\t\t     bool *non_constant_p, bool *overflow_p)\n@@ -1024,12 +1036,18 @@ cxx_bind_parameters_in_call (const constexpr_call *old_call, tree t,\n     {\n       tree x, arg;\n       tree type = parms ? TREE_TYPE (parms) : void_type_node;\n-      /* For member function, the first argument is a pointer to the implied\n-         object.  And for an object construction, don't bind `this' before\n-         it is fully constructed.  */\n-      if (i == 0 && DECL_CONSTRUCTOR_P (fun))\n-        goto next;\n       x = get_nth_callarg (t, i);\n+      /* For member function, the first argument is a pointer to the implied\n+         object.  For a constructor, it might still be a dummy object, in\n+         which case we get the real argument from ctx or the AGGR_INIT_EXPR. */\n+      if (i == 0 && DECL_CONSTRUCTOR_P (fun)\n+\t  && is_dummy_object (x))\n+\t{\n+\t  x = ctx->object;\n+\t  if (!x)\n+\t    x = AGGR_INIT_EXPR_SLOT (t);\n+\t  x = cp_build_addr_expr (x, tf_warning_or_error);\n+\t}\n       if (parms && DECL_BY_REFERENCE (parms))\n \t{\n \t  /* cp_genericize made this a reference for argument passing, but\n@@ -1039,7 +1057,7 @@ cxx_bind_parameters_in_call (const constexpr_call *old_call, tree t,\n \t  type = TREE_TYPE (type);\n \t  x = convert_from_reference (x);\n \t}\n-      arg = cxx_eval_constant_expression (old_call, x, allow_non_constant,\n+      arg = cxx_eval_constant_expression (ctx, x, allow_non_constant,\n \t\t\t\t\t  TREE_CODE (type) == REFERENCE_TYPE,\n \t\t\t\t\t  non_constant_p, overflow_p);\n       /* Don't VERIFY_CONSTANT here.  */\n@@ -1104,7 +1122,7 @@ cx_error_context (void)\n    evaluation.  */\n \n static tree\n-cxx_eval_call_expression (const constexpr_call *old_call, tree t,\n+cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n \t\t\t  bool allow_non_constant, bool addr,\n \t\t\t  bool *non_constant_p, bool *overflow_p)\n {\n@@ -1119,7 +1137,7 @@ cxx_eval_call_expression (const constexpr_call *old_call, tree t,\n   if (TREE_CODE (fun) != FUNCTION_DECL)\n     {\n       /* Might be a constexpr function pointer.  */\n-      fun = cxx_eval_constant_expression (old_call, fun, allow_non_constant,\n+      fun = cxx_eval_constant_expression (ctx, fun, allow_non_constant,\n \t\t\t\t\t  /*addr*/false, non_constant_p,\n \t\t\t\t\t  overflow_p);\n       STRIP_NOPS (fun);\n@@ -1137,7 +1155,7 @@ cxx_eval_call_expression (const constexpr_call *old_call, tree t,\n   if (DECL_CLONED_FUNCTION_P (fun))\n     fun = DECL_CLONED_FUNCTION (fun);\n   if (is_builtin_fn (fun))\n-    return cxx_eval_builtin_function_call (old_call, t, allow_non_constant,\n+    return cxx_eval_builtin_function_call (ctx, t, allow_non_constant,\n \t\t\t\t\t   addr, non_constant_p, overflow_p);\n   if (!DECL_DECLARED_CONSTEXPR_P (fun))\n     {\n@@ -1156,7 +1174,7 @@ cxx_eval_call_expression (const constexpr_call *old_call, tree t,\n       if (call_expr_nargs (t) == 2)\n \t{\n \t  tree arg = convert_from_reference (get_nth_callarg (t, 1));\n-\t  return cxx_eval_constant_expression (old_call, arg, allow_non_constant,\n+\t  return cxx_eval_constant_expression (ctx, arg, allow_non_constant,\n \t\t\t\t\t       addr, non_constant_p, overflow_p);\n \t}\n       else if (TREE_CODE (t) == AGGR_INIT_EXPR\n@@ -1165,8 +1183,8 @@ cxx_eval_call_expression (const constexpr_call *old_call, tree t,\n     }\n \n   /* If in direct recursive call, optimize definition search.  */\n-  if (old_call != NULL && old_call->fundef->decl == fun)\n-    new_call.fundef = old_call->fundef;\n+  if (ctx && ctx->call && ctx->call->fundef->decl == fun)\n+    new_call.fundef = ctx->call->fundef;\n   else\n     {\n       new_call.fundef = retrieve_constexpr_fundef (fun);\n@@ -1187,7 +1205,7 @@ cxx_eval_call_expression (const constexpr_call *old_call, tree t,\n           return t;\n         }\n     }\n-  cxx_bind_parameters_in_call (old_call, t, &new_call,\n+  cxx_bind_parameters_in_call (ctx, t, &new_call,\n \t\t\t       allow_non_constant, non_constant_p, overflow_p);\n   if (*non_constant_p)\n     return t;\n@@ -1232,10 +1250,14 @@ cxx_eval_call_expression (const constexpr_call *old_call, tree t,\n     {\n       result = entry->result;\n       if (!result || result == error_mark_node)\n-\tresult = (cxx_eval_constant_expression\n-\t\t  (&new_call, new_call.fundef->body,\n-\t\t   allow_non_constant, addr,\n-\t\t   non_constant_p, overflow_p));\n+\t{\n+\t  constexpr_ctx new_ctx = *ctx;\n+\t  new_ctx.call = &new_call;\n+\t  result = (cxx_eval_constant_expression\n+\t\t    (&new_ctx, new_call.fundef->body,\n+\t\t     allow_non_constant, addr,\n+\t\t     non_constant_p, overflow_p));\n+\t}\n       if (result == error_mark_node)\n \t*non_constant_p = true;\n       if (*non_constant_p)\n@@ -1326,13 +1348,13 @@ verify_constant (tree t, bool allow_non_constant, bool *non_constant_p,\n    and return error_mark_node.  */\n \n static tree\n-cxx_eval_unary_expression (const constexpr_call *call, tree t,\n+cxx_eval_unary_expression (const constexpr_ctx *ctx, tree t,\n \t\t\t   bool allow_non_constant, bool addr,\n \t\t\t   bool *non_constant_p, bool *overflow_p)\n {\n   tree r;\n   tree orig_arg = TREE_OPERAND (t, 0);\n-  tree arg = cxx_eval_constant_expression (call, orig_arg, allow_non_constant,\n+  tree arg = cxx_eval_constant_expression (ctx, orig_arg, allow_non_constant,\n \t\t\t\t\t   addr, non_constant_p, overflow_p);\n   VERIFY_CONSTANT (arg);\n   if (arg == orig_arg)\n@@ -1346,19 +1368,19 @@ cxx_eval_unary_expression (const constexpr_call *call, tree t,\n    Like cxx_eval_unary_expression, except for binary expressions.  */\n \n static tree\n-cxx_eval_binary_expression (const constexpr_call *call, tree t,\n+cxx_eval_binary_expression (const constexpr_ctx *ctx, tree t,\n \t\t\t    bool allow_non_constant, bool addr,\n \t\t\t    bool *non_constant_p, bool *overflow_p)\n {\n   tree r;\n   tree orig_lhs = TREE_OPERAND (t, 0);\n   tree orig_rhs = TREE_OPERAND (t, 1);\n   tree lhs, rhs;\n-  lhs = cxx_eval_constant_expression (call, orig_lhs,\n+  lhs = cxx_eval_constant_expression (ctx, orig_lhs,\n \t\t\t\t      allow_non_constant, addr,\n \t\t\t\t      non_constant_p, overflow_p);\n   VERIFY_CONSTANT (lhs);\n-  rhs = cxx_eval_constant_expression (call, orig_rhs,\n+  rhs = cxx_eval_constant_expression (ctx, orig_rhs,\n \t\t\t\t      allow_non_constant, addr,\n \t\t\t\t      non_constant_p, overflow_p);\n   VERIFY_CONSTANT (rhs);\n@@ -1374,20 +1396,20 @@ cxx_eval_binary_expression (const constexpr_call *call, tree t,\n    looked into.  */\n \n static tree\n-cxx_eval_conditional_expression (const constexpr_call *call, tree t,\n+cxx_eval_conditional_expression (const constexpr_ctx *ctx, tree t,\n \t\t\t\t bool allow_non_constant, bool addr,\n \t\t\t\t bool *non_constant_p, bool *overflow_p)\n {\n-  tree val = cxx_eval_constant_expression (call, TREE_OPERAND (t, 0),\n+  tree val = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 0),\n \t\t\t\t\t   allow_non_constant, addr,\n \t\t\t\t\t   non_constant_p, overflow_p);\n   VERIFY_CONSTANT (val);\n   /* Don't VERIFY_CONSTANT the other operands.  */\n   if (integer_zerop (val))\n-    return cxx_eval_constant_expression (call, TREE_OPERAND (t, 2),\n+    return cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 2),\n \t\t\t\t\t allow_non_constant, addr,\n \t\t\t\t\t non_constant_p, overflow_p);\n-  return cxx_eval_constant_expression (call, TREE_OPERAND (t, 1),\n+  return cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 1),\n \t\t\t\t       allow_non_constant, addr,\n \t\t\t\t       non_constant_p, overflow_p);\n }\n@@ -1396,12 +1418,12 @@ cxx_eval_conditional_expression (const constexpr_call *call, tree t,\n    Attempt to reduce a reference to an array slot.  */\n \n static tree\n-cxx_eval_array_reference (const constexpr_call *call, tree t,\n+cxx_eval_array_reference (const constexpr_ctx *ctx, tree t,\n \t\t\t  bool allow_non_constant, bool addr,\n \t\t\t  bool *non_constant_p, bool *overflow_p)\n {\n   tree oldary = TREE_OPERAND (t, 0);\n-  tree ary = cxx_eval_constant_expression (call, oldary,\n+  tree ary = cxx_eval_constant_expression (ctx, oldary,\n \t\t\t\t\t   allow_non_constant, addr,\n \t\t\t\t\t   non_constant_p, overflow_p);\n   tree index, oldidx;\n@@ -1411,7 +1433,7 @@ cxx_eval_array_reference (const constexpr_call *call, tree t,\n   if (*non_constant_p)\n     return t;\n   oldidx = TREE_OPERAND (t, 1);\n-  index = cxx_eval_constant_expression (call, oldidx,\n+  index = cxx_eval_constant_expression (ctx, oldidx,\n \t\t\t\t\tallow_non_constant, false,\n \t\t\t\t\tnon_constant_p, overflow_p);\n   VERIFY_CONSTANT (index);\n@@ -1442,7 +1464,7 @@ cxx_eval_array_reference (const constexpr_call *call, tree t,\n \t  /* If it's within the array bounds but doesn't have an explicit\n \t     initializer, it's value-initialized.  */\n \t  tree val = build_value_init (elem_type, tf_warning_or_error);\n-\t  return cxx_eval_constant_expression (call, val,\n+\t  return cxx_eval_constant_expression (ctx, val,\n \t\t\t\t\t       allow_non_constant, addr,\n \t\t\t\t\t       non_constant_p, overflow_p);\n \t}\n@@ -1479,7 +1501,7 @@ cxx_eval_array_reference (const constexpr_call *call, tree t,\n    Attempt to reduce a field access of a value of class type.  */\n \n static tree\n-cxx_eval_component_reference (const constexpr_call *call, tree t,\n+cxx_eval_component_reference (const constexpr_ctx *ctx, tree t,\n \t\t\t      bool allow_non_constant, bool addr,\n \t\t\t      bool *non_constant_p, bool *overflow_p)\n {\n@@ -1488,7 +1510,7 @@ cxx_eval_component_reference (const constexpr_call *call, tree t,\n   tree value;\n   tree part = TREE_OPERAND (t, 1);\n   tree orig_whole = TREE_OPERAND (t, 0);\n-  tree whole = cxx_eval_constant_expression (call, orig_whole,\n+  tree whole = cxx_eval_constant_expression (ctx, orig_whole,\n \t\t\t\t\t     allow_non_constant, addr,\n \t\t\t\t\t     non_constant_p, overflow_p);\n   if (whole == orig_whole)\n@@ -1528,9 +1550,20 @@ cxx_eval_component_reference (const constexpr_call *call, tree t,\n       return t;\n     }\n \n+  if (CONSTRUCTOR_NO_IMPLICIT_ZERO (whole))\n+    {\n+      /* 'whole' is part of the aggregate initializer we're currently\n+\t building; if there's no initializer for this member yet, that's an\n+\t error. */\n+      if (!allow_non_constant)\n+\terror (\"accessing uninitialized member %qD\", part);\n+      *non_constant_p = true;\n+      return t;\n+    }\n+\n   /* If there's no explicit init for this field, it's value-initialized.  */\n   value = build_value_init (TREE_TYPE (t), tf_warning_or_error);\n-  return cxx_eval_constant_expression (call, value,\n+  return cxx_eval_constant_expression (ctx, value,\n \t\t\t\t       allow_non_constant, addr,\n \t\t\t\t       non_constant_p, overflow_p);\n }\n@@ -1540,15 +1573,15 @@ cxx_eval_component_reference (const constexpr_call *call, tree t,\n    expressed as a BIT_FIELD_REF.  */\n \n static tree\n-cxx_eval_bit_field_ref (const constexpr_call *call, tree t,\n+cxx_eval_bit_field_ref (const constexpr_ctx *ctx, tree t,\n \t\t\tbool allow_non_constant, bool addr,\n \t\t\tbool *non_constant_p, bool *overflow_p)\n {\n   tree orig_whole = TREE_OPERAND (t, 0);\n   tree retval, fldval, utype, mask;\n   bool fld_seen = false;\n   HOST_WIDE_INT istart, isize;\n-  tree whole = cxx_eval_constant_expression (call, orig_whole,\n+  tree whole = cxx_eval_constant_expression (ctx, orig_whole,\n \t\t\t\t\t     allow_non_constant, addr,\n \t\t\t\t\t     non_constant_p, overflow_p);\n   tree start, field, value;\n@@ -1625,20 +1658,20 @@ cxx_eval_bit_field_ref (const constexpr_call *call, tree t,\n    sanity check purposes.  */\n \n static tree\n-cxx_eval_logical_expression (const constexpr_call *call, tree t,\n+cxx_eval_logical_expression (const constexpr_ctx *ctx, tree t,\n                              tree bailout_value, tree continue_value,\n \t\t\t     bool allow_non_constant, bool addr,\n \t\t\t     bool *non_constant_p, bool *overflow_p)\n {\n   tree r;\n-  tree lhs = cxx_eval_constant_expression (call, TREE_OPERAND (t, 0),\n+  tree lhs = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 0),\n \t\t\t\t\t   allow_non_constant, addr,\n \t\t\t\t\t   non_constant_p, overflow_p);\n   VERIFY_CONSTANT (lhs);\n   if (tree_int_cst_equal (lhs, bailout_value))\n     return lhs;\n   gcc_assert (tree_int_cst_equal (lhs, continue_value));\n-  r = cxx_eval_constant_expression (call, TREE_OPERAND (t, 1),\n+  r = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 1),\n \t\t\t\t    allow_non_constant, addr, non_constant_p, overflow_p);\n   VERIFY_CONSTANT (r);\n   return r;\n@@ -1674,59 +1707,153 @@ base_field_constructor_elt (vec<constructor_elt, va_gc> *v, tree ref)\n   return NULL;\n }\n \n+/* Some of the expressions fed to the constexpr mechanism are calls to\n+   constructors, which have type void.  In that case, return the type being\n+   initialized by the constructor.  */\n+\n+static tree\n+initialized_type (tree t)\n+{\n+  if (TYPE_P (t))\n+    return t;\n+  tree type = cv_unqualified (TREE_TYPE (t));\n+  if (TREE_CODE (t) == CALL_EXPR || TREE_CODE (t) == AGGR_INIT_EXPR)\n+    {\n+      /* A constructor call has void type, so we need to look deeper.  */\n+      tree fn = get_function_named_in_call (t);\n+      if (fn && TREE_CODE (fn) == FUNCTION_DECL\n+\t  && DECL_CXX_CONSTRUCTOR_P (fn))\n+\ttype = DECL_CONTEXT (fn);\n+    }\n+  return type;\n+}\n+\n+/* We're about to initialize element INDEX of an array or class from VALUE.\n+   Set up NEW_CTX appropriately by adjusting .object to refer to the\n+   subobject and creating a new CONSTRUCTOR if the element is itself\n+   a class or array.  */\n+\n+static void\n+init_subob_ctx (const constexpr_ctx *ctx, constexpr_ctx &new_ctx,\n+\t       tree index, tree &value)\n+{\n+  new_ctx = *ctx;\n+\n+  if (index && TREE_CODE (index) != INTEGER_CST\n+      && TREE_CODE (index) != FIELD_DECL)\n+    /* This won't have an element in the new CONSTRUCTOR.  */\n+    return;\n+\n+  tree type = initialized_type (value);\n+  if (!AGGREGATE_TYPE_P (type) && !VECTOR_TYPE_P (type))\n+    /* A non-aggregate member doesn't get its own CONSTRUCTOR.  */\n+    return;\n+\n+  /* The sub-aggregate initializer might contain a placeholder;\n+     update object to refer to the subobject and ctor to refer to\n+     the (newly created) sub-initializer.  */\n+  if (ctx->object)\n+    new_ctx.object = build_ctor_subob_ref (index, type, ctx->object);\n+  tree elt = build_constructor (type, NULL);\n+  CONSTRUCTOR_NO_IMPLICIT_ZERO (elt) = true;\n+  new_ctx.ctor = elt;\n+\n+  if (TREE_CODE (value) == TARGET_EXPR)\n+    /* Avoid creating another CONSTRUCTOR when we expand the TARGET_EXPR.  */\n+    value = TARGET_EXPR_INITIAL (value);\n+}\n+\n+/* We're about to process an initializer for a class or array TYPE.  Make\n+   sure that CTX is set up appropriately.  */\n+\n+static void\n+verify_ctor_sanity (const constexpr_ctx *ctx, tree type)\n+{\n+  /* We don't bother building a ctor for an empty base subobject.  */\n+  if (is_empty_class (type))\n+    return;\n+\n+  /* We're in the middle of an initializer that might involve placeholders;\n+     our caller should have created a CONSTRUCTOR for us to put the\n+     initializer into.  We will either return that constructor or T.  */\n+  gcc_assert (ctx->ctor);\n+  gcc_assert (same_type_ignoring_top_level_qualifiers_p\n+\t      (type, TREE_TYPE (ctx->ctor)));\n+  gcc_assert (CONSTRUCTOR_NELTS (ctx->ctor) == 0);\n+  if (ctx->object)\n+    gcc_assert (same_type_ignoring_top_level_qualifiers_p\n+\t\t(type, TREE_TYPE (ctx->object)));\n+  gcc_assert (!ctx->object || !DECL_P (ctx->object)\n+\t      || *(ctx->values->get (ctx->object)) == ctx->ctor);\n+}\n+\n /* Subroutine of cxx_eval_constant_expression.\n    The expression tree T denotes a C-style array or a C-style\n    aggregate.  Reduce it to a constant expression.  */\n \n static tree\n-cxx_eval_bare_aggregate (const constexpr_call *call, tree t,\n+cxx_eval_bare_aggregate (const constexpr_ctx *ctx, tree t,\n \t\t\t bool allow_non_constant, bool addr,\n \t\t\t bool *non_constant_p, bool *overflow_p)\n {\n   vec<constructor_elt, va_gc> *v = CONSTRUCTOR_ELTS (t);\n-  vec<constructor_elt, va_gc> *n;\n-  vec_alloc (n, vec_safe_length (v));\n-  constructor_elt *ce;\n-  HOST_WIDE_INT i;\n   bool changed = false;\n   gcc_assert (!BRACE_ENCLOSED_INITIALIZER_P (t));\n-  for (i = 0; vec_safe_iterate (v, i, &ce); ++i)\n+\n+  verify_ctor_sanity (ctx, TREE_TYPE (t));\n+  vec<constructor_elt, va_gc> **p = &CONSTRUCTOR_ELTS (ctx->ctor);\n+  vec_alloc (*p, vec_safe_length (v));\n+\n+  unsigned i; tree index, value;\n+  FOR_EACH_CONSTRUCTOR_ELT (v, i, index, value)\n     {\n-      tree elt = cxx_eval_constant_expression (call, ce->value,\n+      constexpr_ctx new_ctx;\n+      init_subob_ctx (ctx, new_ctx, index, value);\n+      if (new_ctx.ctor != ctx->ctor)\n+\t/* If we built a new CONSTRUCTOR, attach it now so that other\n+\t   initializers can refer to it.  */\n+\tCONSTRUCTOR_APPEND_ELT (*p, index, new_ctx.ctor);\n+      tree elt = cxx_eval_constant_expression (&new_ctx, value,\n \t\t\t\t\t       allow_non_constant, addr,\n \t\t\t\t\t       non_constant_p, overflow_p);\n       /* Don't VERIFY_CONSTANT here.  */\n       if (allow_non_constant && *non_constant_p)\n-\tgoto fail;\n-      if (elt != ce->value)\n+\tbreak;\n+      if (elt != value)\n \tchanged = true;\n-      if (ce->index && TREE_CODE (ce->index) == COMPONENT_REF)\n+      if (index && TREE_CODE (index) == COMPONENT_REF)\n \t{\n \t  /* This is an initialization of a vfield inside a base\n \t     subaggregate that we already initialized; push this\n \t     initialization into the previous initialization.  */\n-\t  constructor_elt *inner = base_field_constructor_elt (n, ce->index);\n+\t  constructor_elt *inner = base_field_constructor_elt (*p, index);\n \t  inner->value = elt;\n+\t  changed = true;\n \t}\n-      else if (ce->index\n-\t       && (TREE_CODE (ce->index) == NOP_EXPR\n-\t\t   || TREE_CODE (ce->index) == POINTER_PLUS_EXPR))\n+      else if (index\n+\t       && (TREE_CODE (index) == NOP_EXPR\n+\t\t   || TREE_CODE (index) == POINTER_PLUS_EXPR))\n \t{\n \t  /* This is an initializer for an empty base; now that we've\n \t     checked that it's constant, we can ignore it.  */\n-\t  gcc_assert (is_empty_class (TREE_TYPE (TREE_TYPE (ce->index))));\n+\t  gcc_assert (is_empty_class (TREE_TYPE (TREE_TYPE (index))));\n+\t  changed = true;\n+\t}\n+      else if (new_ctx.ctor != ctx->ctor)\n+\t{\n+\t  /* We appended this element above; update the value.  */\n+\t  gcc_assert ((*p)->last().index == index);\n+\t  (*p)->last().value = elt;\n \t}\n       else\n-\tCONSTRUCTOR_APPEND_ELT (n, ce->index, elt);\n+\tCONSTRUCTOR_APPEND_ELT (*p, index, elt);\n     }\n   if (*non_constant_p || !changed)\n-    {\n-    fail:\n-      vec_free (n);\n-      return t;\n-    }\n-  t = build_constructor (TREE_TYPE (t), n);\n-  TREE_CONSTANT (t) = true;\n+    return t;\n+  t = ctx->ctor;\n+  /* We're done building this CONSTRUCTOR, so now we can interpret an\n+     element without an explicit initializer as value-initialized.  */\n+  CONSTRUCTOR_NO_IMPLICIT_ZERO (t) = false;\n   if (TREE_CODE (TREE_TYPE (t)) == VECTOR_TYPE)\n     t = fold (t);\n   return t;\n@@ -1745,14 +1872,15 @@ cxx_eval_bare_aggregate (const constexpr_call *call, tree t,\n    for the copy/move constructor.  */\n \n static tree\n-cxx_eval_vec_init_1 (const constexpr_call *call, tree atype, tree init,\n+cxx_eval_vec_init_1 (const constexpr_ctx *ctx, tree atype, tree init,\n \t\t     bool value_init, bool allow_non_constant, bool addr,\n \t\t     bool *non_constant_p, bool *overflow_p)\n {\n   tree elttype = TREE_TYPE (atype);\n   int max = tree_to_shwi (array_type_nelts (atype));\n-  vec<constructor_elt, va_gc> *n;\n-  vec_alloc (n, max + 1);\n+  verify_ctor_sanity (ctx, atype);\n+  vec<constructor_elt, va_gc> **p = &CONSTRUCTOR_ELTS (ctx->ctor);\n+  vec_alloc (*p, max + 1);\n   bool pre_init = false;\n   int i;\n \n@@ -1766,8 +1894,6 @@ cxx_eval_vec_init_1 (const constexpr_call *call, tree atype, tree init,\n   else if (value_init)\n     {\n       init = build_value_init (elttype, tf_warning_or_error);\n-      init = cxx_eval_constant_expression\n-\t    (call, init, allow_non_constant, addr, non_constant_p, overflow_p);\n       pre_init = true;\n     }\n   else if (!init)\n@@ -1777,18 +1903,17 @@ cxx_eval_vec_init_1 (const constexpr_call *call, tree atype, tree init,\n \t\t\t\t\t&argvec, elttype, LOOKUP_NORMAL,\n \t\t\t\t\ttf_warning_or_error);\n       release_tree_vector (argvec);\n-      init = cxx_eval_constant_expression (call, init, allow_non_constant,\n-\t\t\t\t\t   addr, non_constant_p, overflow_p);\n       pre_init = true;\n     }\n \n-  if (*non_constant_p && !allow_non_constant)\n-    goto fail;\n-\n   for (i = 0; i <= max; ++i)\n     {\n       tree idx = build_int_cst (size_type_node, i);\n       tree eltinit;\n+      constexpr_ctx new_ctx;\n+      init_subob_ctx (ctx, new_ctx, idx, pre_init ? init : elttype);\n+      if (new_ctx.ctor != ctx->ctor)\n+\tCONSTRUCTOR_APPEND_ELT (*p, idx, new_ctx.ctor);\n       if (TREE_CODE (elttype) == ARRAY_TYPE)\n \t{\n \t  /* A multidimensional array; recurse.  */\n@@ -1797,18 +1922,17 @@ cxx_eval_vec_init_1 (const constexpr_call *call, tree atype, tree init,\n \t  else\n \t    eltinit = cp_build_array_ref (input_location, init, idx,\n \t\t\t\t\t  tf_warning_or_error);\n-\t  eltinit = cxx_eval_vec_init_1 (call, elttype, eltinit, value_init,\n+\t  eltinit = cxx_eval_vec_init_1 (&new_ctx, elttype, eltinit, value_init,\n \t\t\t\t\t allow_non_constant, addr,\n \t\t\t\t\t non_constant_p, overflow_p);\n \t}\n       else if (pre_init)\n \t{\n \t  /* Initializing an element using value or default initialization\n \t     we just pre-built above.  */\n-\t  if (i == 0)\n-\t    eltinit = init;\n-\t  else\n-\t    eltinit = unshare_expr (init);\n+\t  eltinit = (cxx_eval_constant_expression\n+\t\t     (&new_ctx, init, allow_non_constant,\n+\t\t      addr, non_constant_p, overflow_p));\n \t}\n       else\n \t{\n@@ -1820,34 +1944,38 @@ cxx_eval_vec_init_1 (const constexpr_call *call, tree atype, tree init,\n \t  if (!real_lvalue_p (init))\n \t    eltinit = move (eltinit);\n \t  eltinit = force_rvalue (eltinit, tf_warning_or_error);\n-\t  eltinit = cxx_eval_constant_expression\n-\t    (call, eltinit, allow_non_constant, addr, non_constant_p, overflow_p);\n+\t  eltinit = (cxx_eval_constant_expression\n+\t\t     (&new_ctx, eltinit, allow_non_constant, addr,\n+\t\t      non_constant_p, overflow_p));\n \t}\n       if (*non_constant_p && !allow_non_constant)\n-\tgoto fail;\n-      CONSTRUCTOR_APPEND_ELT (n, idx, eltinit);\n+\tbreak;\n+      if (new_ctx.ctor != ctx->ctor)\n+\t{\n+\t  /* We appended this element above; update the value.  */\n+\t  gcc_assert ((*p)->last().index == idx);\n+\t  (*p)->last().value = eltinit;\n+\t}\n+      else\n+\tCONSTRUCTOR_APPEND_ELT (*p, idx, eltinit);\n     }\n \n   if (!*non_constant_p)\n     {\n-      init = build_constructor (atype, n);\n-      TREE_CONSTANT (init) = true;\n-      return init;\n+      init = ctx->ctor;\n+      CONSTRUCTOR_NO_IMPLICIT_ZERO (init) = false;\n     }\n-\n- fail:\n-  vec_free (n);\n   return init;\n }\n \n static tree\n-cxx_eval_vec_init (const constexpr_call *call, tree t,\n+cxx_eval_vec_init (const constexpr_ctx *ctx, tree t,\n \t\t   bool allow_non_constant, bool addr,\n \t\t   bool *non_constant_p, bool *overflow_p)\n {\n   tree atype = TREE_TYPE (t);\n   tree init = VEC_INIT_EXPR_INIT (t);\n-  tree r = cxx_eval_vec_init_1 (call, atype, init,\n+  tree r = cxx_eval_vec_init_1 (ctx, atype, init,\n \t\t\t\tVEC_INIT_EXPR_VALUE_INIT (t),\n \t\t\t\tallow_non_constant, addr, non_constant_p, overflow_p);\n   if (*non_constant_p)\n@@ -2048,12 +2176,12 @@ cxx_fold_indirect_ref (location_t loc, tree type, tree op0, bool *empty_base)\n }\n \n static tree\n-cxx_eval_indirect_ref (const constexpr_call *call, tree t,\n+cxx_eval_indirect_ref (const constexpr_ctx *ctx, tree t,\n \t\t       bool allow_non_constant, bool addr,\n \t\t       bool *non_constant_p, bool *overflow_p)\n {\n   tree orig_op0 = TREE_OPERAND (t, 0);\n-  tree op0 = cxx_eval_constant_expression (call, orig_op0, allow_non_constant,\n+  tree op0 = cxx_eval_constant_expression (ctx, orig_op0, allow_non_constant,\n \t\t\t\t\t   /*addr*/false, non_constant_p, overflow_p);\n   bool empty_base = false;\n   tree r;\n@@ -2066,7 +2194,7 @@ cxx_eval_indirect_ref (const constexpr_call *call, tree t,\n \t\t\t     &empty_base);\n \n   if (r)\n-    r = cxx_eval_constant_expression (call, r, allow_non_constant,\n+    r = cxx_eval_constant_expression (ctx, r, allow_non_constant,\n \t\t\t\t      addr, non_constant_p, overflow_p);\n   else\n     {\n@@ -2157,7 +2285,7 @@ non_const_var_error (tree r)\n    Like cxx_eval_unary_expression, except for trinary expressions.  */\n \n static tree\n-cxx_eval_trinary_expression (const constexpr_call *call, tree t,\n+cxx_eval_trinary_expression (const constexpr_ctx *ctx, tree t,\n \t\t\t     bool allow_non_constant, bool addr,\n \t\t\t     bool *non_constant_p, bool *overflow_p)\n {\n@@ -2167,7 +2295,7 @@ cxx_eval_trinary_expression (const constexpr_call *call, tree t,\n \n   for (i = 0; i < 3; i++)\n     {\n-      args[i] = cxx_eval_constant_expression (call, TREE_OPERAND (t, i),\n+      args[i] = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, i),\n \t\t\t\t\t      allow_non_constant, addr,\n \t\t\t\t\t      non_constant_p, overflow_p);\n       VERIFY_CONSTANT (args[i]);\n@@ -2194,10 +2322,11 @@ var_in_constexpr_fn (tree t)\n /* FIXME unify with c_fully_fold */\n \n static tree\n-cxx_eval_constant_expression (const constexpr_call *call, tree t,\n+cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t\t\t      bool allow_non_constant, bool addr,\n \t\t\t      bool *non_constant_p, bool *overflow_p)\n {\n+  constexpr_ctx new_ctx;\n   tree r = t;\n \n   if (t == error_mark_node)\n@@ -2228,11 +2357,14 @@ cxx_eval_constant_expression (const constexpr_call *call, tree t,\n       if (TREE_CODE (r) == TARGET_EXPR\n \t  && TREE_CODE (TARGET_EXPR_INITIAL (r)) == CONSTRUCTOR)\n \tr = TARGET_EXPR_INITIAL (r);\n-      if (DECL_P (r) && var_in_constexpr_fn (r)\n+      if (TREE_CODE (r) == VAR_DECL && var_in_constexpr_fn (r)\n \t  && DECL_INITIAL (r))\n-\tr = cxx_eval_constant_expression (call, DECL_INITIAL (r),\n+\tr = cxx_eval_constant_expression (ctx, DECL_INITIAL (r),\n \t\t\t\t\t  allow_non_constant, false,\n \t\t\t\t\t  non_constant_p, overflow_p);\n+      if (TREE_CODE (r) == VAR_DECL)\n+\tif (tree *p = ctx->values->get (r))\n+\t  r = *p;\n       if (DECL_P (r))\n \t{\n \t  if (!allow_non_constant)\n@@ -2247,18 +2379,8 @@ cxx_eval_constant_expression (const constexpr_call *call, tree t,\n       return t;\n \n     case PARM_DECL:\n-      if (call && DECL_CONTEXT (t) == call->fundef->decl)\n-\t{\n-\t  if (DECL_ARTIFICIAL (t) && DECL_CONSTRUCTOR_P (DECL_CONTEXT (t)))\n-\t    {\n-\t      if (!allow_non_constant)\n-\t\tsorry (\"use of the value of the object being constructed \"\n-\t\t       \"in a constant expression\");\n-\t      *non_constant_p = true;\n-\t    }\n-\t  else\n-\t    r = lookup_parameter_binding (call, t);\n-\t}\n+      if (ctx && ctx->call && DECL_CONTEXT (t) == ctx->call->fundef->decl)\n+\tr = lookup_parameter_binding (ctx->call, t);\n       else if (addr)\n \t/* Defer in case this is only used for its type.  */;\n       else\n@@ -2271,7 +2393,7 @@ cxx_eval_constant_expression (const constexpr_call *call, tree t,\n \n     case CALL_EXPR:\n     case AGGR_INIT_EXPR:\n-      r = cxx_eval_call_expression (call, t, allow_non_constant, addr,\n+      r = cxx_eval_call_expression (ctx, t, allow_non_constant, addr,\n \t\t\t\t    non_constant_p, overflow_p);\n       break;\n \n@@ -2287,11 +2409,23 @@ cxx_eval_constant_expression (const constexpr_call *call, tree t,\n \t  *non_constant_p = true;\n \t  break;\n \t}\n+      if ((AGGREGATE_TYPE_P (TREE_TYPE (t)) || VECTOR_TYPE_P (TREE_TYPE (t))))\n+\t{\n+\t  /* We're being expanded without an explicit target, so start\n+\t     initializing a new object; expansion with an explicit target\n+\t     strips the TARGET_EXPR before we get here.  */\n+\t  new_ctx = *ctx;\n+\t  new_ctx.ctor = build_constructor (TREE_TYPE (t), NULL);\n+\t  CONSTRUCTOR_NO_IMPLICIT_ZERO (new_ctx.ctor) = true;\n+\t  new_ctx.object = TARGET_EXPR_SLOT (t);\n+\t  ctx->values->put (new_ctx.object, new_ctx.ctor);\n+\t  ctx = &new_ctx;\n+\t}\n       /* else fall through.  */\n     case INIT_EXPR:\n       /* Pass false for 'addr' because these codes indicate\n \t initialization of a temporary.  */\n-      r = cxx_eval_constant_expression (call, TREE_OPERAND (t, 1),\n+      r = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 1),\n \t\t\t\t\tallow_non_constant, false,\n \t\t\t\t\tnon_constant_p, overflow_p);\n       if (!*non_constant_p)\n@@ -2300,7 +2434,7 @@ cxx_eval_constant_expression (const constexpr_call *call, tree t,\n       break;\n \n     case SCOPE_REF:\n-      r = cxx_eval_constant_expression (call, TREE_OPERAND (t, 1),\n+      r = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 1),\n \t\t\t\t\tallow_non_constant, addr,\n \t\t\t\t\tnon_constant_p, overflow_p);\n       break;\n@@ -2311,7 +2445,7 @@ cxx_eval_constant_expression (const constexpr_call *call, tree t,\n     case CLEANUP_POINT_EXPR:\n     case MUST_NOT_THROW_EXPR:\n     case SAVE_EXPR:\n-      r = cxx_eval_constant_expression (call, TREE_OPERAND (t, 0),\n+      r = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 0),\n \t\t\t\t\tallow_non_constant, addr,\n \t\t\t\t\tnon_constant_p, overflow_p);\n       break;\n@@ -2320,14 +2454,14 @@ cxx_eval_constant_expression (const constexpr_call *call, tree t,\n \t check for a constant operand or result; an address can be\n \t constant without its operand being, and vice versa.  */\n     case INDIRECT_REF:\n-      r = cxx_eval_indirect_ref (call, t, allow_non_constant, addr,\n+      r = cxx_eval_indirect_ref (ctx, t, allow_non_constant, addr,\n \t\t\t\t non_constant_p, overflow_p);\n       break;\n \n     case ADDR_EXPR:\n       {\n \ttree oldop = TREE_OPERAND (t, 0);\n-\ttree op = cxx_eval_constant_expression (call, oldop,\n+\ttree op = cxx_eval_constant_expression (ctx, oldop,\n \t\t\t\t\t\tallow_non_constant,\n \t\t\t\t\t\t/*addr*/true,\n \t\t\t\t\t\tnon_constant_p, overflow_p);\n@@ -2351,7 +2485,7 @@ cxx_eval_constant_expression (const constexpr_call *call, tree t,\n     case BIT_NOT_EXPR:\n     case TRUTH_NOT_EXPR:\n     case FIXED_CONVERT_EXPR:\n-      r = cxx_eval_unary_expression (call, t, allow_non_constant, addr,\n+      r = cxx_eval_unary_expression (ctx, t, allow_non_constant, addr,\n \t\t\t\t     non_constant_p, overflow_p);\n       break;\n \n@@ -2380,15 +2514,15 @@ cxx_eval_constant_expression (const constexpr_call *call, tree t,\n \tSTRIP_NOPS (op1);\n \tif ((TREE_CODE (op0) == TARGET_EXPR && op1 == TARGET_EXPR_SLOT (op0))\n \t    || TREE_CODE (op1) == EMPTY_CLASS_EXPR)\n-\t  r = cxx_eval_constant_expression (call, op0, allow_non_constant,\n+\t  r = cxx_eval_constant_expression (ctx, op0, allow_non_constant,\n \t\t\t\t\t    addr, non_constant_p, overflow_p);\n \telse\n \t  {\n \t    /* Check that the LHS is constant and then discard it.  */\n-\t    cxx_eval_constant_expression (call, op0, allow_non_constant,\n+\t    cxx_eval_constant_expression (ctx, op0, allow_non_constant,\n \t\t\t\t\t  false, non_constant_p, overflow_p);\n \t    op1 = TREE_OPERAND (t, 1);\n-\t    r = cxx_eval_constant_expression (call, op1, allow_non_constant,\n+\t    r = cxx_eval_constant_expression (ctx, op1, allow_non_constant,\n \t\t\t\t\t      addr, non_constant_p, overflow_p);\n \t  }\n       }\n@@ -2433,30 +2567,30 @@ cxx_eval_constant_expression (const constexpr_call *call, tree t,\n     case LTGT_EXPR:\n     case RANGE_EXPR:\n     case COMPLEX_EXPR:\n-      r = cxx_eval_binary_expression (call, t, allow_non_constant, addr,\n+      r = cxx_eval_binary_expression (ctx, t, allow_non_constant, addr,\n \t\t\t\t      non_constant_p, overflow_p);\n       break;\n \n       /* fold can introduce non-IF versions of these; still treat them as\n \t short-circuiting.  */\n     case TRUTH_AND_EXPR:\n     case TRUTH_ANDIF_EXPR:\n-      r = cxx_eval_logical_expression (call, t, boolean_false_node,\n+      r = cxx_eval_logical_expression (ctx, t, boolean_false_node,\n \t\t\t\t       boolean_true_node,\n \t\t\t\t       allow_non_constant, addr,\n \t\t\t\t       non_constant_p, overflow_p);\n       break;\n \n     case TRUTH_OR_EXPR:\n     case TRUTH_ORIF_EXPR:\n-      r = cxx_eval_logical_expression (call, t, boolean_true_node,\n+      r = cxx_eval_logical_expression (ctx, t, boolean_true_node,\n \t\t\t\t       boolean_false_node,\n \t\t\t\t       allow_non_constant, addr,\n \t\t\t\t       non_constant_p, overflow_p);\n       break;\n \n     case ARRAY_REF:\n-      r = cxx_eval_array_reference (call, t, allow_non_constant, addr,\n+      r = cxx_eval_array_reference (ctx, t, allow_non_constant, addr,\n \t\t\t\t    non_constant_p, overflow_p);\n       break;\n \n@@ -2471,23 +2605,23 @@ cxx_eval_constant_expression (const constexpr_call *call, tree t,\n \t  *non_constant_p = true;\n \t  return t;\n \t}\n-      r = cxx_eval_component_reference (call, t, allow_non_constant, addr,\n+      r = cxx_eval_component_reference (ctx, t, allow_non_constant, addr,\n \t\t\t\t\tnon_constant_p, overflow_p);\n       break;\n \n     case BIT_FIELD_REF:\n-      r = cxx_eval_bit_field_ref (call, t, allow_non_constant, addr,\n+      r = cxx_eval_bit_field_ref (ctx, t, allow_non_constant, addr,\n \t\t\t\t  non_constant_p, overflow_p);\n       break;\n \n     case COND_EXPR:\n     case VEC_COND_EXPR:\n-      r = cxx_eval_conditional_expression (call, t, allow_non_constant, addr,\n+      r = cxx_eval_conditional_expression (ctx, t, allow_non_constant, addr,\n \t\t\t\t\t   non_constant_p, overflow_p);\n       break;\n \n     case CONSTRUCTOR:\n-      r = cxx_eval_bare_aggregate (call, t, allow_non_constant, addr,\n+      r = cxx_eval_bare_aggregate (ctx, t, allow_non_constant, addr,\n \t\t\t\t   non_constant_p, overflow_p);\n       break;\n \n@@ -2497,13 +2631,13 @@ cxx_eval_constant_expression (const constexpr_call *call, tree t,\n \t be NULL, meaning default-initialization, or it will be an lvalue\n \t or xvalue of the same type, meaning direct-initialization from the\n \t corresponding member.  */\n-      r = cxx_eval_vec_init (call, t, allow_non_constant, addr,\n+      r = cxx_eval_vec_init (ctx, t, allow_non_constant, addr,\n \t\t\t     non_constant_p, overflow_p);\n       break;\n \n     case FMA_EXPR:\n     case VEC_PERM_EXPR:\n-      r = cxx_eval_trinary_expression (call, t, allow_non_constant, addr,\n+      r = cxx_eval_trinary_expression (ctx, t, allow_non_constant, addr,\n \t\t\t\t       non_constant_p, overflow_p);\n       break;\n \n@@ -2512,7 +2646,7 @@ cxx_eval_constant_expression (const constexpr_call *call, tree t,\n     case NOP_EXPR:\n       {\n \ttree oldop = TREE_OPERAND (t, 0);\n-\ttree op = cxx_eval_constant_expression (call, oldop,\n+\ttree op = cxx_eval_constant_expression (ctx, oldop,\n \t\t\t\t\t\tallow_non_constant, addr,\n \t\t\t\t\t\tnon_constant_p, overflow_p);\n \tif (*non_constant_p)\n@@ -2573,6 +2707,29 @@ cxx_eval_constant_expression (const constexpr_call *call, tree t,\n       *non_constant_p = true;\n       break;\n \n+    case PLACEHOLDER_EXPR:\n+      if (!ctx || !ctx->ctor || (addr && !ctx->object))\n+\t{\n+\t  /* A placeholder without a referent.  We can get here when\n+\t     checking whether NSDMIs are noexcept, or in massage_init_elt;\n+\t     just say it's non-constant for now.  */\n+\t  gcc_assert (allow_non_constant);\n+\t  *non_constant_p = true;\n+\t  break;\n+\t}\n+      else\n+\t{\n+\t  /* Use of the value or address of the current object.  We could\n+\t     use ctx->object unconditionally, but using ctx->ctor when we\n+\t     can is a minor optimization.  */\n+\t  tree ctor = addr ? ctx->object : ctx->ctor;\n+\t  gcc_assert (same_type_ignoring_top_level_qualifiers_p\n+\t\t      (TREE_TYPE (t), TREE_TYPE (ctor)));\n+\t  return cxx_eval_constant_expression\n+\t    (ctx, ctor, allow_non_constant, addr, non_constant_p, overflow_p);\n+\t}\n+      break;\n+\n     default:\n       internal_error (\"unexpected expression %qE of kind %s\", t,\n \t\t      get_tree_code_name (TREE_CODE (t)));\n@@ -2590,12 +2747,43 @@ cxx_eval_constant_expression (const constexpr_call *call, tree t,\n }\n \n static tree\n-cxx_eval_outermost_constant_expr (tree t, bool allow_non_constant)\n+cxx_eval_outermost_constant_expr (tree t, bool allow_non_constant,\n+\t\t\t\t  tree object = NULL_TREE)\n {\n   bool non_constant_p = false;\n   bool overflow_p = false;\n-  tree r = cxx_eval_constant_expression (NULL, t, allow_non_constant,\n-\t\t\t\t\t false, &non_constant_p, &overflow_p);\n+  constexpr_ctx ctx = { NULL, NULL, NULL, NULL };\n+  hash_map<tree,tree> map;\n+  ctx.values = &map;\n+  tree type = initialized_type (t);\n+  if (!object && TREE_CODE (t) == TARGET_EXPR)\n+    object = TARGET_EXPR_SLOT (t);\n+  tree r = t;\n+  if (AGGREGATE_TYPE_P (type) || VECTOR_TYPE_P (type))\n+    {\n+      /* In C++14 an NSDMI can participate in aggregate initialization,\n+\t and can refer to the address of the object being initialized, so\n+\t we need to pass in the relevant VAR_DECL if we want to do the\n+\t evaluation in a single pass.  The evaluation will dynamically\n+\t update ctx.values for the VAR_DECL.  We use the same strategy\n+\t for C++11 constexpr constructors that refer to the object being\n+\t initialized.  */\n+      ctx.ctor = build_constructor (type, NULL);\n+      CONSTRUCTOR_NO_IMPLICIT_ZERO (ctx.ctor) = true;\n+      ctx.object = object;\n+      if (object)\n+\tgcc_assert (same_type_ignoring_top_level_qualifiers_p\n+\t\t    (type, TREE_TYPE (object)));\n+      if (object && DECL_P (object))\n+\tmap.put (object, ctx.ctor);\n+      if (TREE_CODE (r) == TARGET_EXPR)\n+\t/* Avoid creating another CONSTRUCTOR when we expand the\n+\t   TARGET_EXPR.  */\n+\tr = TARGET_EXPR_INITIAL (r);\n+    }\n+\n+  r = cxx_eval_constant_expression (&ctx, r, allow_non_constant,\n+\t\t\t\t    false, &non_constant_p, &overflow_p);\n \n   verify_constant (r, allow_non_constant, &non_constant_p, &overflow_p);\n \n@@ -2607,7 +2795,7 @@ cxx_eval_outermost_constant_expr (tree t, bool allow_non_constant)\n \t constexpr variables.  */\n       if (!allow_non_constant)\n \terror (\"%qT cannot be the type of a complete constant expression \"\n-\t       \"because it has mutable sub-objects\", TREE_TYPE (t));\n+\t       \"because it has mutable sub-objects\", type);\n       non_constant_p = true;\n     }\n \n@@ -2668,7 +2856,17 @@ is_sub_constant_expr (tree t)\n {\n   bool non_constant_p = false;\n   bool overflow_p = false;\n-  cxx_eval_constant_expression (NULL, t, true, false, &non_constant_p,\n+  constexpr_ctx ctx = { NULL, NULL, NULL, NULL };\n+  hash_map <tree, tree> map;\n+  ctx.values = &map;\n+  tree type = initialized_type (t);\n+  if ((AGGREGATE_TYPE_P (type) || VECTOR_TYPE_P (type))\n+      && TREE_CODE (t) != TARGET_EXPR)\n+    {\n+      ctx.ctor = build_constructor (type, NULL);\n+      CONSTRUCTOR_NO_IMPLICIT_ZERO (ctx.ctor) = true;\n+    }\n+  cxx_eval_constant_expression (&ctx, t, true, false, &non_constant_p,\n \t\t\t\t&overflow_p);\n   return !non_constant_p && !overflow_p;\n }\n@@ -2678,17 +2876,17 @@ is_sub_constant_expr (tree t)\n    return NULL.  */\n \n tree\n-cxx_constant_value (tree t)\n+cxx_constant_value (tree t, tree decl)\n {\n-  return cxx_eval_outermost_constant_expr (t, false);\n+  return cxx_eval_outermost_constant_expr (t, false, decl);\n }\n \n /* If T is a constant expression, returns its reduced value.\n    Otherwise, if T does not have TREE_CONSTANT set, returns T.\n    Otherwise, returns a version of T without TREE_CONSTANT.  */\n \n tree\n-maybe_constant_value (tree t)\n+maybe_constant_value (tree t, tree decl)\n {\n   tree r;\n \n@@ -2705,7 +2903,7 @@ maybe_constant_value (tree t)\n       return t;\n     }\n \n-  r = cxx_eval_outermost_constant_expr (t, true);\n+  r = cxx_eval_outermost_constant_expr (t, true, decl);\n #ifdef ENABLE_CHECKING\n   /* cp_tree_equal looks through NOPs, so allow them.  */\n   gcc_assert (r == t\n@@ -2720,14 +2918,14 @@ maybe_constant_value (tree t)\n    than wrapped in a TARGET_EXPR.  */\n \n tree\n-maybe_constant_init (tree t)\n+maybe_constant_init (tree t, tree decl)\n {\n   if (TREE_CODE (t) == EXPR_STMT)\n     t = TREE_OPERAND (t, 0);\n   if (TREE_CODE (t) == CONVERT_EXPR\n       && VOID_TYPE_P (TREE_TYPE (t)))\n     t = TREE_OPERAND (t, 0);\n-  t = maybe_constant_value (t);\n+  t = maybe_constant_value (t, decl);\n   if (TREE_CODE (t) == TARGET_EXPR)\n     {\n       tree init = TARGET_EXPR_INITIAL (t);\n@@ -2822,6 +3020,7 @@ potential_constant_expression_1 (tree t, bool want_rval, tsubst_flags_t flags)\n     case FIELD_DECL:\n     case PARM_DECL:\n     case USING_DECL:\n+    case PLACEHOLDER_EXPR:\n       return true;\n \n     case AGGR_INIT_EXPR:\n@@ -2861,18 +3060,7 @@ potential_constant_expression_1 (tree t, bool want_rval, tsubst_flags_t flags)\n \t\t  {\n \t\t    tree x = get_nth_callarg (t, 0);\n \t\t    if (is_this_parameter (x))\n-\t\t      {\n-\t\t\tif (DECL_CONTEXT (x) == NULL_TREE\n-\t\t\t    || DECL_CONSTRUCTOR_P (DECL_CONTEXT (x)))\n-\t\t\t  {\n-\t\t\t    if (flags & tf_error)\n-\t\t\t      sorry (\"calling a member function of the \"\n-\t\t\t\t     \"object being constructed in a constant \"\n-\t\t\t\t     \"expression\");\n-\t\t\t    return false;\n-\t\t\t  }\n-\t\t\t/* Otherwise OK.  */;\n-\t\t      }\n+\t\t      return true;\n \t\t    else if (!potential_constant_expression_1 (x, rval, flags))\n \t\t      return false;\n \t\t    i = 1;\n@@ -3002,14 +3190,6 @@ potential_constant_expression_1 (tree t, bool want_rval, tsubst_flags_t flags)\n \t\t  error (\"use of %<this%> in a constant expression\");\n \t\treturn false;\n \t      }\n-\t    if (want_rval && DECL_CONTEXT (x)\n-\t\t&& DECL_CONSTRUCTOR_P (DECL_CONTEXT (x)))\n-\t      {\n-\t\tif (flags & tf_error)\n-\t\t  sorry (\"use of the value of the object being constructed \"\n-\t\t\t \"in a constant expression\");\n-\t\treturn false;\n-\t      }\n \t    return true;\n \t  }\n \treturn potential_constant_expression_1 (x, rval, flags);"}, {"sha": "e5436bbc747fbdf7a4899ded8b9f4725ae46b048", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e605b20a0c804d57d4be0f4f2bbab8b4e42fce6/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e605b20a0c804d57d4be0f4f2bbab8b4e42fce6/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=3e605b20a0c804d57d4be0f4f2bbab8b4e42fce6", "patch": "@@ -495,6 +495,10 @@ cp_gimplify_init_expr (tree *expr_p)\n \t    TREE_TYPE (from) = void_type_node;\n \t}\n \n+      if (cxx_dialect >= cxx14 && TREE_CODE (sub) == CONSTRUCTOR)\n+\t/* Handle aggregate NSDMI.  */\n+\treplace_placeholders (sub, to);\n+\n       if (t == sub)\n \tbreak;\n       else"}, {"sha": "abc3d6fd19ff2631c5344f3fb1ceeec197cfff2c", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e605b20a0c804d57d4be0f4f2bbab8b4e42fce6/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e605b20a0c804d57d4be0f4f2bbab8b4e42fce6/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=3e605b20a0c804d57d4be0f4f2bbab8b4e42fce6", "patch": "@@ -98,6 +98,7 @@ c-common.h, not after.\n       DECL_FINAL_P (in FUNCTION_DECL)\n       QUALIFIED_NAME_IS_TEMPLATE (in SCOPE_REF)\n       DECLTYPE_FOR_INIT_CAPTURE (in DECLTYPE_TYPE)\n+      CONSTRUCTOR_NO_IMPLICIT_ZERO (in CONSTRUCTOR)\n    2: IDENTIFIER_OPNAME_P (in IDENTIFIER_NODE)\n       ICS_THIS_FLAG (in _CONV)\n       DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (in VAR_DECL)\n@@ -3479,6 +3480,11 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n    B b{1,2}, not B b({1,2}) or B b = {1,2}.  */\n #define CONSTRUCTOR_IS_DIRECT_INIT(NODE) (TREE_LANG_FLAG_0 (CONSTRUCTOR_CHECK (NODE)))\n \n+/* True if an uninitialized element in NODE should not be treated as\n+   implicitly value-initialized.  Only used in constexpr evaluation.  */\n+#define CONSTRUCTOR_NO_IMPLICIT_ZERO(NODE) \\\n+  (TREE_LANG_FLAG_1 (CONSTRUCTOR_CHECK (NODE)))\n+\n #define DIRECT_LIST_INIT_P(NODE) \\\n    (BRACE_ENCLOSED_INITIALIZER_P (NODE) && CONSTRUCTOR_IS_DIRECT_INIT (NODE))\n \n@@ -6033,6 +6039,8 @@ extern tree bind_template_template_parm\t\t(tree, tree);\n extern tree array_type_nelts_total\t\t(tree);\n extern tree array_type_nelts_top\t\t(tree);\n extern tree break_out_target_exprs\t\t(tree);\n+extern tree build_ctor_subob_ref\t\t(tree, tree, tree);\n+extern tree replace_placeholders\t\t(tree, tree);\n extern tree get_type_decl\t\t\t(tree);\n extern tree decl_namespace_context\t\t(tree);\n extern bool decl_anon_ns_mem_p\t\t\t(const_tree);\n@@ -6320,9 +6328,9 @@ extern bool potential_constant_expression       (tree);\n extern bool potential_rvalue_constant_expression (tree);\n extern bool require_potential_constant_expression (tree);\n extern bool require_potential_rvalue_constant_expression (tree);\n-extern tree cxx_constant_value                  (tree);\n-extern tree maybe_constant_value                (tree);\n-extern tree maybe_constant_init                 (tree);\n+extern tree cxx_constant_value\t\t\t(tree, tree = NULL_TREE);\n+extern tree maybe_constant_value\t\t(tree, tree = NULL_TREE);\n+extern tree maybe_constant_init\t\t\t(tree, tree = NULL_TREE);\n extern bool is_sub_constant_expr                (tree);\n extern bool reduced_constant_expression_p       (tree);\n extern bool is_instantiation_of_constexpr       (tree);"}, {"sha": "76f86cb0d74bc43d3e2b842ec1a170b0eb939eb0", "filename": "gcc/cp/error.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e605b20a0c804d57d4be0f4f2bbab8b4e42fce6/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e605b20a0c804d57d4be0f4f2bbab8b4e42fce6/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=3e605b20a0c804d57d4be0f4f2bbab8b4e42fce6", "patch": "@@ -2673,6 +2673,10 @@ dump_expr (cxx_pretty_printer *pp, tree t, int flags)\n       pp_cxx_right_paren (pp);\n       break;\n \n+    case PLACEHOLDER_EXPR:\n+      pp_string (pp, M_(\"*this\"));\n+      break;\n+\n       /*  This list is incomplete, but should suffice for now.\n \t  It is very important that `sorry' does not call\n \t  `report_error_function'.  That could cause an infinite loop.  */"}, {"sha": "5c61107b7f4fa1c25c7b88af73b7d18da63ee3c9", "filename": "gcc/cp/init.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e605b20a0c804d57d4be0f4f2bbab8b4e42fce6/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e605b20a0c804d57d4be0f4f2bbab8b4e42fce6/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=3e605b20a0c804d57d4be0f4f2bbab8b4e42fce6", "patch": "@@ -540,7 +540,12 @@ get_nsdmi (tree member, bool in_ctor)\n   tree save_ccp = current_class_ptr;\n   tree save_ccr = current_class_ref;\n   if (!in_ctor)\n-    inject_this_parameter (DECL_CONTEXT (member), TYPE_UNQUALIFIED);\n+    {\n+      /* Use a PLACEHOLDER_EXPR when we don't have a 'this' parameter to\n+\t refer to; constexpr evaluation knows what to do with it.  */\n+      current_class_ref = build0 (PLACEHOLDER_EXPR, DECL_CONTEXT (member));\n+      current_class_ptr = build_address (current_class_ref);\n+    }\n   if (DECL_LANG_SPECIFIC (member) && DECL_TEMPLATE_INFO (member))\n     {\n       /* Do deferred instantiation of the NSDMI.  */\n@@ -560,7 +565,7 @@ get_nsdmi (tree member, bool in_ctor)\n \t  error (\"constructor required before non-static data member \"\n \t\t \"for %qD has been parsed\", member);\n \t  DECL_INITIAL (member) = error_mark_node;\n-\t  init = NULL_TREE;\n+\t  init = error_mark_node;\n \t}\n       /* Strip redundant TARGET_EXPR so we don't need to remap it, and\n \t so the aggregate init code below will see a CONSTRUCTOR.  */\n@@ -1723,7 +1728,7 @@ expand_default_init (tree binfo, tree true_exp, tree exp, tree init, int flags,\n       tree fn = get_callee_fndecl (rval);\n       if (fn && DECL_DECLARED_CONSTEXPR_P (fn))\n \t{\n-\t  tree e = maybe_constant_init (rval);\n+\t  tree e = maybe_constant_init (rval, exp);\n \t  if (TREE_CONSTANT (e))\n \t    rval = build2 (INIT_EXPR, type, exp, e);\n \t}"}, {"sha": "ef7f6756ef6bf44836878242922ecc6b4cb64e15", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e605b20a0c804d57d4be0f4f2bbab8b4e42fce6/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e605b20a0c804d57d4be0f4f2bbab8b4e42fce6/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=3e605b20a0c804d57d4be0f4f2bbab8b4e42fce6", "patch": "@@ -158,6 +158,7 @@ lvalue_kind (const_tree ref)\n     case ARRAY_NOTATION_REF:\n     case PARM_DECL:\n     case RESULT_DECL:\n+    case PLACEHOLDER_EXPR:\n       return clk_ordinary;\n \n       /* A scope ref in a template, left as SCOPE_REF to support later\n@@ -2450,6 +2451,103 @@ break_out_target_exprs (tree t)\n   return t;\n }\n \n+/* Build an expression for the subobject of OBJ at CONSTRUCTOR index INDEX,\n+   which we expect to have type TYPE.  */\n+\n+tree\n+build_ctor_subob_ref (tree index, tree type, tree obj)\n+{\n+  if (index == NULL_TREE)\n+    /* Can't refer to a particular member of a vector.  */\n+    obj = NULL_TREE;\n+  else if (TREE_CODE (index) == INTEGER_CST)\n+    obj = cp_build_array_ref (input_location, obj, index, tf_none);\n+  else\n+    obj = build_class_member_access_expr (obj, index, NULL_TREE,\n+\t\t\t\t\t  /*reference*/false, tf_none);\n+  if (obj)\n+    gcc_assert (same_type_ignoring_top_level_qualifiers_p (type,\n+\t\t\t\t\t\t\t   TREE_TYPE (obj)));\n+  return obj;\n+}\n+\n+/* Like substitute_placeholder_in_expr, but handle C++ tree codes and\n+   build up subexpressions as we go deeper.  */\n+\n+struct replace_placeholders_t\n+{\n+  tree obj;\n+  hash_set<tree> *pset;\n+};\n+\n+static tree\n+replace_placeholders_r (tree* t, int* walk_subtrees, void* data_)\n+{\n+  tree obj = static_cast<tree>(data_);\n+\n+  if (TREE_CONSTANT (*t))\n+    {\n+      *walk_subtrees = false;\n+      return NULL_TREE;\n+    }\n+\n+  switch (TREE_CODE (*t))\n+    {\n+    case PLACEHOLDER_EXPR:\n+      gcc_assert (same_type_ignoring_top_level_qualifiers_p\n+\t\t  (TREE_TYPE (*t), TREE_TYPE (obj)));\n+      *t = obj;\n+      *walk_subtrees = false;\n+      break;\n+\n+    case TARGET_EXPR:\n+      /* Don't mess with placeholders in an unrelated object.  */\n+      *walk_subtrees = false;\n+      break;\n+\n+    case CONSTRUCTOR:\n+      {\n+\tconstructor_elt *ce;\n+\tvec<constructor_elt,va_gc> *v = CONSTRUCTOR_ELTS (*t);\n+\tfor (unsigned i = 0; vec_safe_iterate (v, i, &ce); ++i)\n+\t  {\n+\t    tree *valp = &ce->value;\n+\t    tree type = TREE_TYPE (*valp);\n+\t    tree subob = obj;\n+\n+\t    if (TREE_CODE (*valp) == CONSTRUCTOR\n+\t\t&& AGGREGATE_TYPE_P (type))\n+\t      {\n+\t\tsubob = build_ctor_subob_ref (ce->index, type, obj);\n+\t\tif (TREE_CODE (*valp) == TARGET_EXPR)\n+\t\t  valp = &TARGET_EXPR_INITIAL (*valp);\n+\t      }\n+\n+\t    cp_walk_tree (valp, replace_placeholders_r,\n+\t\t\t  subob, NULL);\n+\t  }\n+\t*walk_subtrees = false;\n+\tbreak;\n+      }\n+\n+    default:\n+      break;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+tree\n+replace_placeholders (tree exp, tree obj)\n+{\n+  hash_set<tree> pset;\n+  tree *tp = &exp;\n+  if (TREE_CODE (exp) == TARGET_EXPR)\n+    tp = &TARGET_EXPR_INITIAL (exp);\n+  cp_walk_tree (tp, replace_placeholders_r, obj, NULL);\n+  return exp;\n+}\n+\n /* Similar to `build_nt', but for template definitions of dependent\n    expressions  */\n "}, {"sha": "d57f75dadc59d529d8ac544987fd87396c4833d5", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 31, "deletions": 8, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e605b20a0c804d57d4be0f4f2bbab8b4e42fce6/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e605b20a0c804d57d4be0f4f2bbab8b4e42fce6/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=3e605b20a0c804d57d4be0f4f2bbab8b4e42fce6", "patch": "@@ -806,15 +806,19 @@ store_init_value (tree decl, tree init, vec<tree, va_gc>** cleanups, int flags)\n \t      && !require_potential_constant_expression (value))\n \t    value = error_mark_node;\n \t  else\n-\t    value = cxx_constant_value (value);\n+\t    value = cxx_constant_value (value, decl);\n \t}\n-      value = maybe_constant_init (value);\n+      value = maybe_constant_init (value, decl);\n       const_init = (reduced_constant_expression_p (value)\n \t\t    || error_operand_p (value));\n       DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (decl) = const_init;\n       TREE_CONSTANT (decl) = const_init && decl_maybe_constant_var_p (decl);\n     }\n \n+  if (cxx_dialect >= cxx14)\n+    /* Handle aggregate NSDMI in non-constant initializers, too.  */\n+    value = replace_placeholders (value, decl);\n+\n   /* If the initializer is not a constant, fill in DECL_INITIAL with\n      the bits that are constant, and then return an expression that\n      will perform the dynamic initialization.  */\n@@ -1292,16 +1296,18 @@ process_init_constructor_record (tree type, tree init,\n \t\t\t\t tsubst_flags_t complain)\n {\n   vec<constructor_elt, va_gc> *v = NULL;\n-  int flags = 0;\n   tree field;\n-  unsigned HOST_WIDE_INT idx = 0;\n+  int skipped = 0;\n \n   gcc_assert (TREE_CODE (type) == RECORD_TYPE);\n   gcc_assert (!CLASSTYPE_VBASECLASSES (type));\n   gcc_assert (!TYPE_BINFO (type)\n \t      || !BINFO_N_BASE_BINFOS (TYPE_BINFO (type)));\n   gcc_assert (!TYPE_POLYMORPHIC_P (type));\n \n+ restart:\n+  int flags = 0;\n+  unsigned HOST_WIDE_INT idx = 0;\n   /* Generally, we will always have an index for each initializer (which is\n      a FIELD_DECL, put by reshape_init), but compound literals don't go trough\n      reshape_init. So we need to handle both cases.  */\n@@ -1345,6 +1351,19 @@ process_init_constructor_record (tree type, tree init,\n \t  next = massage_init_elt (type, ce->value, complain);\n \t  ++idx;\n \t}\n+      else if (DECL_INITIAL (field))\n+\t{\n+\t  if (skipped > 0)\n+\t    {\n+\t      /* We're using an NSDMI past a field with implicit\n+\t         zero-init.  Go back and make it explicit.  */\n+\t      skipped = -1;\n+\t      vec_safe_truncate (v, 0);\n+\t      goto restart;\n+\t    }\n+\t  /* C++14 aggregate NSDMI.  */\n+\t  next = get_nsdmi (field, /*ctor*/false);\n+\t}\n       else if (type_build_ctor_call (TREE_TYPE (field)))\n \t{\n \t  /* If this type needs constructors run for\n@@ -1387,13 +1406,17 @@ process_init_constructor_record (tree type, tree init,\n \t    warning (OPT_Wmissing_field_initializers,\n \t\t     \"missing initializer for member %qD\", field);\n \n-\t  if (!zero_init_p (TREE_TYPE (field)))\n+\t  if (!zero_init_p (TREE_TYPE (field))\n+\t      || skipped < 0)\n \t    next = build_zero_init (TREE_TYPE (field), /*nelts=*/NULL_TREE,\n \t\t\t\t    /*static_storage_p=*/false);\n \t  else\n-\t    /* The default zero-initialization is fine for us; don't\n-\t    add anything to the CONSTRUCTOR.  */\n-\t    continue;\n+\t    {\n+\t      /* The default zero-initialization is fine for us; don't\n+\t\t add anything to the CONSTRUCTOR.  */\n+\t      skipped = 1;\n+\t      continue;\n+\t    }\n \t}\n \n       /* If this is a bitfield, now convert to the lowered type.  */"}, {"sha": "31010ed2355f5a5f686d25c4dbe1d4531803d990", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-48089.C", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e605b20a0c804d57d4be0f4f2bbab8b4e42fce6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-48089.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e605b20a0c804d57d4be0f4f2bbab8b4e42fce6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-48089.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-48089.C?ref=3e605b20a0c804d57d4be0f4f2bbab8b4e42fce6", "patch": "@@ -10,18 +10,18 @@\n // R() is well-formed because i is initialized before j.\n \n struct s {\n-  constexpr s() : v(v) { }\t// { dg-message \"\" }\n+  constexpr s() : v(v) { }\n   int v;\n };\n \n-constexpr s bang;\t\t// { dg-message \"\" }\n+constexpr s bang;\t\t// { dg-error \"\" }\n \n struct R {\n   int i,j;\n-  constexpr R() : i(42),j(i) { } // { dg-bogus \"\" \"\" { xfail *-*-* } }\n+  constexpr R() : i(42),j(i) { } // { dg-bogus \"\" }\n };\n \n-constexpr R r;\t\t\t// { dg-bogus \"\" \"\" { xfail *-*-* } }\n+constexpr R r;\t\t\t// { dg-bogus \"\" }\n \n // Ill-formed (no diagnostic required)\n struct T {\n@@ -41,10 +41,10 @@ struct U {\n   constexpr int f(int _i) { return _i; }\n   constexpr int g() { return i; }\n   constexpr U(): i(0), j(0) { }\n-  constexpr U(const U& t) : i(f(t.i)),j(0) { } // { dg-bogus \"\" \"\" { xfail *-*-* } }\n-  constexpr U(int _i) : i(_i),j(g()) { } // { dg-bogus \"\" \"\" { xfail *-*-* } }\n+  constexpr U(const U& t) : i(f(t.i)),j(0) { } // { dg-bogus \"\" }\n+  constexpr U(int _i) : i(_i),j(g()) { } // { dg-bogus \"\" }\n };\n \n constexpr U u1;\n-constexpr U u2(u1);\t\t// { dg-bogus \"\" \"\" { xfail *-*-* } }\n-constexpr U u3(1);\t\t// { dg-bogus \"\" \"\" { xfail *-*-* } }\n+constexpr U u2(u1);\t\t// { dg-bogus \"\" }\n+constexpr U u3(1);\t\t// { dg-bogus \"\" }"}, {"sha": "17309952886ab54aa6e76b5cadad1dc63c5ba1aa", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-ctor14.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e605b20a0c804d57d4be0f4f2bbab8b4e42fce6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-ctor14.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e605b20a0c804d57d4be0f4f2bbab8b4e42fce6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-ctor14.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-ctor14.C?ref=3e605b20a0c804d57d4be0f4f2bbab8b4e42fce6", "patch": "@@ -0,0 +1,14 @@\n+// { dg-do compile { target c++11 } }\n+\n+struct A\n+{\n+  void *p;\n+  constexpr A(): p(this) {}\n+};\n+\n+constexpr A a;\n+constexpr A b = A();\n+\n+#define SA(X) static_assert ((X), #X)\n+SA(a.p == &a);\n+SA(b.p == &b);"}, {"sha": "644ae63fe0d0e81703fb870beb7afa2bc54c2862", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-ctor14a.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e605b20a0c804d57d4be0f4f2bbab8b4e42fce6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-ctor14a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e605b20a0c804d57d4be0f4f2bbab8b4e42fce6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-ctor14a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-ctor14a.C?ref=3e605b20a0c804d57d4be0f4f2bbab8b4e42fce6", "patch": "@@ -0,0 +1,14 @@\n+// { dg-do compile { target c++11 } }\n+// { dg-options \"-fno-elide-constructors\" }\n+\n+struct A\n+{\n+  void *p;\n+  constexpr A(): p(this) {}\n+};\n+\n+constexpr A a;\n+constexpr A b = A();\t\t// { dg-error \"\" }\n+\n+#define SA(X) static_assert ((X), #X)\n+SA(a.p == &a);"}, {"sha": "e378360a75912df44802254b096ae6a8c57ef0dc", "filename": "gcc/testsuite/g++.dg/cpp0x/nsdmi7.C", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e605b20a0c804d57d4be0f4f2bbab8b4e42fce6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnsdmi7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e605b20a0c804d57d4be0f4f2bbab8b4e42fce6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnsdmi7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnsdmi7.C?ref=3e605b20a0c804d57d4be0f4f2bbab8b4e42fce6", "patch": "@@ -11,6 +11,7 @@ struct A\n \n struct B\n {\n+  virtual void g();\n   const int d;\t\t// { dg-warning \"non-static const member\" }\n   int &e;\t\t// { dg-warning \"non-static reference\" }\n   int f = 7;"}, {"sha": "97bcc056b432882a475ba89a4ed74fbcb3e41fef", "filename": "gcc/testsuite/g++.dg/cpp1y/nsdmi-aggr1.C", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e605b20a0c804d57d4be0f4f2bbab8b4e42fce6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fnsdmi-aggr1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e605b20a0c804d57d4be0f4f2bbab8b4e42fce6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fnsdmi-aggr1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fnsdmi-aggr1.C?ref=3e605b20a0c804d57d4be0f4f2bbab8b4e42fce6", "patch": "@@ -0,0 +1,41 @@\n+// { dg-do run { target c++14 } }\n+\n+struct S { int a; const char* b; int c; int d = b[a]; void *p = this+1; };\n+constexpr S ss = S(S{ 1, \"asdf\" });\n+\n+#define SA(X) static_assert ((X),#X)\n+\n+SA(ss.a==1);\n+SA(ss.b[0] == 'a' && ss.b[1] == 's' && ss.b[2] == 'd' && ss.b[3] == 'f');\n+SA(ss.d == 's');\n+SA(ss.p == &ss+1);\n+\n+struct A\n+{\n+  struct B {\n+    int i;\n+    int j = i+1;\n+  } b;\n+  int a = b.j+1;\n+};\n+\n+extern constexpr A a = { };\n+SA(a.b.i == 0 && a.b.j == 1 && a.a == 2);\n+\n+int f(const A& ar) { return ar.a; }\n+\n+int main()\n+{\n+  S ss2 = { 1, \"asdf\" };\n+  if (ss2.a != 1\n+      || __builtin_strcmp(ss2.b,\"asdf\") != 0\n+      || ss2.c != int()\n+      || ss2.d != 's'\n+      || ss2.p != &ss2+1)\n+    __builtin_abort();\n+\n+  A a = {};\n+  int i = f(A{});\n+  if (a.a != 2 || i != 2)\n+    __builtin_abort();\n+}"}, {"sha": "83cb6c2439bdf2ea8237d393cb132dba1166b6aa", "filename": "gcc/testsuite/g++.dg/cpp1y/nsdmi-aggr2.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e605b20a0c804d57d4be0f4f2bbab8b4e42fce6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fnsdmi-aggr2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e605b20a0c804d57d4be0f4f2bbab8b4e42fce6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fnsdmi-aggr2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fnsdmi-aggr2.C?ref=3e605b20a0c804d57d4be0f4f2bbab8b4e42fce6", "patch": "@@ -0,0 +1,10 @@\n+// { dg-do compile { target c++14 } }\n+\n+struct S { int a; const char* b; int c; int d = b[a]; };\n+\n+constexpr int f(const S& s) { return s.a; }\n+\n+int main()\n+{\n+  constexpr int i = f(S{ 1, \"asdf\" });\n+}"}, {"sha": "859d25ef8015c4fca74be60d79e4dadab81b57e4", "filename": "gcc/testsuite/lib/prune.exp", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e605b20a0c804d57d4be0f4f2bbab8b4e42fce6/gcc%2Ftestsuite%2Flib%2Fprune.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e605b20a0c804d57d4be0f4f2bbab8b4e42fce6/gcc%2Ftestsuite%2Flib%2Fprune.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fprune.exp?ref=3e605b20a0c804d57d4be0f4f2bbab8b4e42fce6", "patch": "@@ -28,6 +28,7 @@ proc prune_gcc_output { text } {\n     regsub -all \"(^|\\n)\\[^\\n\\]*(: )?At (top level|global scope):\\[^\\n\\]*\" $text \"\" text\n     regsub -all \"(^|\\n)\\[^\\n\\]*:   (recursively )?required \\[^\\n\\]*\" $text \"\" text\n     regsub -all \"(^|\\n)\\[^\\n\\]*:   . skipping \\[0-9\\]* instantiation contexts \\[^\\n\\]*\" $text \"\" text\n+    regsub -all \"(^|\\n)\\[^\\n\\]*:   in constexpr expansion \\[^\\n\\]*\" $text \"\" text\n     regsub -all \"(^|\\n)    inlined from \\[^\\n\\]*\" $text \"\" text\n     regsub -all \"(^|\\n)collect2: error: ld returned \\[^\\n\\]*\" $text \"\" text\n     regsub -all \"(^|\\n)collect: re(compiling|linking)\\[^\\n\\]*\" $text \"\" text"}]}