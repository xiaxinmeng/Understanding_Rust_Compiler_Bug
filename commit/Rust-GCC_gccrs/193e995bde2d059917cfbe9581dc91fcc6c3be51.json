{"sha": "193e995bde2d059917cfbe9581dc91fcc6c3be51", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTkzZTk5NWJkZTJkMDU5OTE3Y2ZiZTk1ODFkYzkxZmNjNmMzYmU1MQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-05-04T23:05:54Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-05-04T23:05:54Z"}, "message": "entered into RCS\n\nFrom-SVN: r889", "tree": {"sha": "d7781604b397e581d6adcb3408318a29f789939d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d7781604b397e581d6adcb3408318a29f789939d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/193e995bde2d059917cfbe9581dc91fcc6c3be51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/193e995bde2d059917cfbe9581dc91fcc6c3be51", "html_url": "https://github.com/Rust-GCC/gccrs/commit/193e995bde2d059917cfbe9581dc91fcc6c3be51", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/193e995bde2d059917cfbe9581dc91fcc6c3be51/comments", "author": null, "committer": null, "parents": [{"sha": "7339c88dc58d3f64a28e8f08fe9ed4cf929be7a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7339c88dc58d3f64a28e8f08fe9ed4cf929be7a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7339c88dc58d3f64a28e8f08fe9ed4cf929be7a0"}], "stats": {"total": 133, "additions": 133, "deletions": 0}, "files": [{"sha": "e25c793cc1871bcb5d932a4027b7c94ab55dd2e3", "filename": "gcc/config/we32k/we32k.c", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/193e995bde2d059917cfbe9581dc91fcc6c3be51/gcc%2Fconfig%2Fwe32k%2Fwe32k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/193e995bde2d059917cfbe9581dc91fcc6c3be51/gcc%2Fconfig%2Fwe32k%2Fwe32k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fwe32k%2Fwe32k.c?ref=193e995bde2d059917cfbe9581dc91fcc6c3be51", "patch": "@@ -0,0 +1,133 @@\n+/* Subroutines for insn-output.c for AT&T we32000 Family.\n+   Contributed by John Wehle (john@feith1.uucp)\n+   Copyright (C) 1991-1992 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 1, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+#include <stdio.h>\n+#include \"config.h\"\n+#include \"rtl.h\"\n+#include \"real.h\"\n+\n+\n+void output_move_double(operands)\n+rtx *operands;\n+  {\n+  rtx lsw_operands[2];\n+  rtx lsw_sreg = NULL;\n+  rtx msw_dreg = NULL;\n+\n+  if (GET_CODE (operands[0]) == REG) {\n+    lsw_operands[0] = gen_rtx(REG, SImode, REGNO (operands[0]) + 1);\n+    msw_dreg = operands[0];\n+    }\n+  else\n+    if (GET_CODE (operands[0]) == MEM && offsettable_memref_p (operands[0]))\n+      lsw_operands[0] = adj_offsettable_operand(operands[0], 4);\n+    else\n+      abort();\n+\n+  if (GET_CODE (operands[1]) == REG) {\n+    lsw_operands[1] = gen_rtx(REG, SImode, REGNO (operands[1]) + 1);\n+    lsw_sreg = lsw_operands[1];\n+    }\n+  else\n+    if (GET_CODE (operands[1]) == MEM && offsettable_memref_p (operands[1])) {\n+      lsw_operands[1] = adj_offsettable_operand(operands[1], 4);\n+      lsw_sreg = operands[1];\n+      for ( ; ; ) {\n+        if (REG_P (lsw_sreg))\n+          break;\n+        if (CONSTANT_ADDRESS_P (lsw_sreg)) {\n+          lsw_sreg = NULL;\n+          break;\n+          }\n+        if (GET_CODE (lsw_sreg) == MEM) {\n+          lsw_sreg = XEXP (lsw_sreg, 0);\n+          continue;\n+          }\n+        if (GET_CODE (lsw_sreg) == PLUS)\n+          if (CONSTANT_ADDRESS_P (XEXP (lsw_sreg, 1))) {\n+            lsw_sreg = XEXP (lsw_sreg, 0);\n+            continue;\n+            }\n+          else\n+            if (CONSTANT_ADDRESS_P (XEXP (lsw_sreg, 0))) {\n+              lsw_sreg = XEXP (lsw_sreg, 1);\n+              continue;\n+              }\n+        abort();\n+        }\n+      }\n+    else\n+      if (GET_CODE (operands[1]) == CONST_DOUBLE)\n+        {\n+        lsw_operands[1] = gen_rtx(CONST_INT, SImode,\n+                                  CONST_DOUBLE_HIGH(operands[1]));\n+        operands[1] = gen_rtx(CONST_INT, SImode,\n+                              CONST_DOUBLE_LOW(operands[1]));\n+        }\n+      else\n+        if (GET_CODE (operands[1]) == CONST_INT)\n+          {\n+          lsw_operands[1] = operands[1];\n+          operands[1] = const0_rtx;\n+          }\n+        else\n+          abort();\n+\n+  if ( !msw_dreg || !lsw_sreg || REGNO (msw_dreg) != REGNO (lsw_sreg)) {\n+    output_asm_insn(\"movw %1, %0\", operands);\n+    output_asm_insn(\"movw %1, %0\", lsw_operands);\n+    }\n+  else {\n+    output_asm_insn(\"movw %1, %0\", lsw_operands);\n+    output_asm_insn(\"movw %1, %0\", operands);\n+    }\n+  }\n+\n+void output_push_double(operands)\n+rtx *operands;\n+  {\n+  rtx lsw_operands[1];\n+\n+  if (GET_CODE (operands[0]) == REG)\n+    lsw_operands[0] = gen_rtx(REG, SImode, REGNO (operands[0]) + 1);\n+  else\n+    if (GET_CODE (operands[0]) == MEM && offsettable_memref_p (operands[0]))\n+      lsw_operands[0] = adj_offsettable_operand(operands[0], 4);\n+    else\n+      if (GET_CODE (operands[0]) == CONST_DOUBLE)\n+        {\n+        lsw_operands[0] = gen_rtx(CONST_INT, SImode,\n+                                  CONST_DOUBLE_HIGH(operands[0]));\n+        operands[0] = gen_rtx(CONST_INT, SImode,\n+                              CONST_DOUBLE_LOW(operands[0]));\n+        }\n+      else\n+        if (GET_CODE (operands[0]) == CONST_INT)\n+          {\n+          lsw_operands[0] = operands[0];\n+          operands[0] = const0_rtx;\n+          }\n+        else\n+          abort();\n+\n+  output_asm_insn(\"pushw %0\", operands);\n+  output_asm_insn(\"pushw %0\", lsw_operands);\n+  }"}]}