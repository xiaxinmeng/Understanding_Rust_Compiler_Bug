{"sha": "ebbcd0c6ea5d565ffa743079449e9ad6169fcf4e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWJiY2QwYzZlYTVkNTY1ZmZhNzQzMDc5NDQ5ZTlhZDYxNjlmY2Y0ZQ==", "commit": {"author": {"name": "Paul Koning", "email": "pkoning@gcc.gnu.org", "date": "2011-10-12T15:16:14Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2011-10-12T15:16:14Z"}, "message": "re PR middle-end/50189 (Wrong code error in -O2 [-fstrict-enums] compile, target independent)\n\n2011-10-12  Paul Koning  <pkoning@gcc.gnu.org>\n\n\tPR tree-optimization/50189\n\t* tree-vrp.c (extract_range_from_assert): Use the type of\n\tthe variable, not the limit.\n\n\t* g++.dg/torture/pr50189.C: New testcase.\n\nFrom-SVN: r179857", "tree": {"sha": "3ffba0dcaa6b493eae88e206b1ecc248b9a7f350", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3ffba0dcaa6b493eae88e206b1ecc248b9a7f350"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ebbcd0c6ea5d565ffa743079449e9ad6169fcf4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebbcd0c6ea5d565ffa743079449e9ad6169fcf4e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebbcd0c6ea5d565ffa743079449e9ad6169fcf4e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebbcd0c6ea5d565ffa743079449e9ad6169fcf4e/comments", "author": null, "committer": null, "parents": [{"sha": "7e19152238f44ead7b8fc2dea1c73ba845fb2d9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e19152238f44ead7b8fc2dea1c73ba845fb2d9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e19152238f44ead7b8fc2dea1c73ba845fb2d9b"}], "stats": {"total": 142, "additions": 137, "deletions": 5}, "files": [{"sha": "194fdb5a7ada575a1fceebaae3be6a7a40df3d3e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebbcd0c6ea5d565ffa743079449e9ad6169fcf4e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebbcd0c6ea5d565ffa743079449e9ad6169fcf4e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ebbcd0c6ea5d565ffa743079449e9ad6169fcf4e", "patch": "@@ -1,3 +1,9 @@\n+2011-10-12  Paul Koning  <pkoning@gcc.gnu.org>\n+\n+\tPR tree-optimization/50189\n+\t* tree-vrp.c (extract_range_from_assert): Use the type of\n+\tthe variable, not the limit.\n+\n 2011-10-12  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/50700"}, {"sha": "5af301f78237d740f7f03f397b878911041ace9d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebbcd0c6ea5d565ffa743079449e9ad6169fcf4e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebbcd0c6ea5d565ffa743079449e9ad6169fcf4e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ebbcd0c6ea5d565ffa743079449e9ad6169fcf4e", "patch": "@@ -1,3 +1,8 @@\n+2011-10-12  Paul Koning  <pkoning@gcc.gnu.org>\n+\n+\tPR tree-optimization/50189\n+\t* g++.dg/torture/pr50189.C: New testcase.\n+\n 2011-10-12  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/50700"}, {"sha": "06f1d3695c1d476235fc10d01001515f05628fd0", "filename": "gcc/testsuite/g++.dg/torture/pr50189.C", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebbcd0c6ea5d565ffa743079449e9ad6169fcf4e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr50189.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebbcd0c6ea5d565ffa743079449e9ad6169fcf4e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr50189.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr50189.C?ref=ebbcd0c6ea5d565ffa743079449e9ad6169fcf4e", "patch": "@@ -0,0 +1,121 @@\n+// { dg-do run }\n+// { dg-options \"-fstrict-enums\" }\n+\n+extern \"C\" void abort (void);\n+class CCUTILS_KeyedScalarLevelPosition\n+{\n+public:\n+\n+    typedef enum\n+    {\n+        UNINITED = 0,\n+        AT_BEGIN = 1,\n+        AT_END = 2,\n+        AT_KEY = 3\n+\n+    } position_t;\n+\n+    bool is_init() const\n+    { return(m_timestamp != UNINITED); }\n+\n+    bool is_at_begin() const\n+    { return(m_timestamp == AT_BEGIN); }\n+\n+    position_t get_state() const\n+    {\n+        return((m_timestamp >= AT_KEY)\n+             ? AT_KEY\n+             : ((position_t)m_timestamp));\n+    }\n+\n+    void set_at_begin()\n+    { m_timestamp = AT_BEGIN; }\n+\n+    unsigned int get_index() const\n+    { return(m_index); }\n+\n+    void set_pos(unsigned int a_index, unsigned int a_timestmap)\n+    {\n+        m_index = a_index;\n+        m_timestamp = a_timestmap;\n+    }\n+\n+    bool check_pos(unsigned int a_num_entries, unsigned int a_timestamp) const\n+    {\n+        if (get_state() != AT_KEY)\n+            return(false);\n+\n+        if (m_timestamp != a_timestamp)\n+            return(false);\n+\n+        return(m_index < a_num_entries);\n+    }\n+\n+    void set_not_init()\n+    { m_timestamp = 0; }\n+\n+private:\n+\n+    unsigned int m_timestamp;\n+    unsigned int m_index;\n+\n+};\n+\n+class CCUTILS_KeyedScalarPosition\n+{\n+public:\n+\n+    CCUTILS_KeyedScalarLevelPosition m_L1;\n+    CCUTILS_KeyedScalarLevelPosition m_L2;\n+};\n+\n+class baz\n+{\n+public:\n+    int *n[20];\n+    unsigned int m_cur_array_len;\n+    unsigned int m_timestamp;\n+\n+    unsigned int _get_timestamp() const\n+    { return(m_timestamp); }\n+\n+    bool _check_L1_pos(const CCUTILS_KeyedScalarPosition &a_position) const\n+    {\n+        return(a_position.m_L1.check_pos(\n+                   m_cur_array_len, _get_timestamp()));\n+    }\n+\n+    void *next (CCUTILS_KeyedScalarPosition &);\n+};\n+\n+void * baz::next (CCUTILS_KeyedScalarPosition &a_position)\n+{\n+    if (a_position.m_L1.is_at_begin() || (!a_position.m_L1.is_init()))\n+    {\n+        a_position.m_L1.set_pos(0, _get_timestamp());\n+        a_position.m_L2.set_at_begin();\n+    }\n+    else if (!_check_L1_pos(a_position))\n+        return(0);\n+\n+    return n[a_position.m_L1.get_index ()];\n+}\n+\n+int main (int, char **)\n+{\n+    baz obj;\n+    CCUTILS_KeyedScalarPosition a_pos;\n+    void *ret;\n+    int n[5];\n+    \n+    obj.n[0] = n;\n+    obj.m_cur_array_len = 1;\n+    obj.m_timestamp = 42;\n+    \n+    a_pos.m_L1.set_pos (0, 42);\n+    \n+    ret = obj.next (a_pos);\n+    if (ret == 0)\n+      abort ();\n+    return 0;\n+}"}, {"sha": "604e7f0ad02aaaec8531edf6a98fcb9df0b4dea9", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebbcd0c6ea5d565ffa743079449e9ad6169fcf4e/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebbcd0c6ea5d565ffa743079449e9ad6169fcf4e/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=ebbcd0c6ea5d565ffa743079449e9ad6169fcf4e", "patch": "@@ -1519,7 +1519,7 @@ extract_range_from_assert (value_range_t *vr_p, tree expr)\n \n   limit = avoid_overflow_infinity (limit);\n \n-  type = TREE_TYPE (limit);\n+  type = TREE_TYPE (var);\n   gcc_assert (limit != var);\n \n   /* For pointer arithmetic, we only keep track of pointer equality\n@@ -1693,8 +1693,8 @@ extract_range_from_assert (value_range_t *vr_p, tree expr)\n \t  /* For LT_EXPR, we create the range [MIN, MAX - 1].  */\n \t  if (cond_code == LT_EXPR)\n \t    {\n-\t      tree one = build_int_cst (type, 1);\n-\t      max = fold_build2 (MINUS_EXPR, type, max, one);\n+\t      tree one = build_int_cst (TREE_TYPE (max), 1);\n+\t      max = fold_build2 (MINUS_EXPR, TREE_TYPE (max), max, one);\n \t      if (EXPR_P (max))\n \t\tTREE_NO_WARNING (max) = 1;\n \t    }\n@@ -1728,8 +1728,8 @@ extract_range_from_assert (value_range_t *vr_p, tree expr)\n \t  /* For GT_EXPR, we create the range [MIN + 1, MAX].  */\n \t  if (cond_code == GT_EXPR)\n \t    {\n-\t      tree one = build_int_cst (type, 1);\n-\t      min = fold_build2 (PLUS_EXPR, type, min, one);\n+\t      tree one = build_int_cst (TREE_TYPE (min), 1);\n+\t      min = fold_build2 (PLUS_EXPR, TREE_TYPE (min), min, one);\n \t      if (EXPR_P (min))\n \t\tTREE_NO_WARNING (min) = 1;\n \t    }"}]}