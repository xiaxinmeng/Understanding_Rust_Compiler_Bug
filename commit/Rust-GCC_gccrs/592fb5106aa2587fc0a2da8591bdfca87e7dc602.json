{"sha": "592fb5106aa2587fc0a2da8591bdfca87e7dc602", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTkyZmI1MTA2YWEyNTg3ZmMwYTJkYTg1OTFiZGZjYTg3ZTdkYzYwMg==", "commit": {"author": {"name": "Robert Schuster", "email": "robertschuster@fsfe.org", "date": "2006-02-21T10:32:31Z"}, "committer": {"name": "Robert Schuster", "email": "rschuster@gcc.gnu.org", "date": "2006-02-21T10:32:31Z"}, "message": "link.cc: Added variant of create_error_method that will not complain about unused...\n\n2006-02-21  Robert Schuster  <robertschuster@fsfe.org>\n\n        * link.cc: Added variant of create_error_method that\n        will not complain about unused parameter if compiled with\n        USE_LIBFFI not being defined.\n        (_Jv_Linker::find_field_helper): Fixed indentation.\n        (_Jv_Linker::create_error_method): Fixed indentation.\n        (_Jv_Linker::link_symbol_table): Fixed indentation.\n\nFrom-SVN: r111331", "tree": {"sha": "a94a9736eee084631b817aa6a3374972ac8bb77f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a94a9736eee084631b817aa6a3374972ac8bb77f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/592fb5106aa2587fc0a2da8591bdfca87e7dc602", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/592fb5106aa2587fc0a2da8591bdfca87e7dc602", "html_url": "https://github.com/Rust-GCC/gccrs/commit/592fb5106aa2587fc0a2da8591bdfca87e7dc602", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/592fb5106aa2587fc0a2da8591bdfca87e7dc602/comments", "author": null, "committer": null, "parents": [{"sha": "f5e605e540df272484a4b36779fc4d942a2e9455", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5e605e540df272484a4b36779fc4d942a2e9455", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5e605e540df272484a4b36779fc4d942a2e9455"}], "stats": {"total": 41, "additions": 27, "deletions": 14}, "files": [{"sha": "d96d0316a4105141ce4f6d627145fdbee2539b69", "filename": "libjava/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/592fb5106aa2587fc0a2da8591bdfca87e7dc602/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/592fb5106aa2587fc0a2da8591bdfca87e7dc602/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=592fb5106aa2587fc0a2da8591bdfca87e7dc602", "patch": "@@ -1,3 +1,12 @@\n+2006-02-21  Robert Schuster  <robertschuster@fsfe.org>\n+\n+\t* link.cc: Added variant of create_error_method that\n+\twill not complain about unused parameter if compiled with\n+\tUSE_LIBFFI not being defined.\n+\t(_Jv_Linker::find_field_helper): Fixed indentation.\n+\t(_Jv_Linker::create_error_method): Fixed indentation.\n+\t(_Jv_Linker::link_symbol_table): Fixed indentation.\n+\n 2006-02-16  Andrew Haley  <aph@redhat.com>\n \n \t* stacktrace.cc (GetStackTraceElements): Call"}, {"sha": "e1dc23f5bcb50919721c1afeed8743d333d98441", "filename": "libjava/link.cc", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/592fb5106aa2587fc0a2da8591bdfca87e7dc602/libjava%2Flink.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/592fb5106aa2587fc0a2da8591bdfca87e7dc602/libjava%2Flink.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Flink.cc?ref=592fb5106aa2587fc0a2da8591bdfca87e7dc602", "patch": "@@ -142,10 +142,10 @@ _Jv_Linker::find_field_helper (jclass search, _Jv_Utf8Const *name,\n \t  // pass in the descriptor and check that way, because when\n \t  // the field is already resolved there is no easy way to\n \t  // find its descriptor again.\n-\t  if ( (field->isResolved () ? \n-                _Jv_equalUtf8Classnames (type_name, field->type->name) :\n-                _Jv_equalUtf8Classnames (\n-                  type_name, (_Jv_Utf8Const *) field->type)) )\n+\t  if ((field->isResolved ()\n+               ? _Jv_equalUtf8Classnames (type_name, field->type->name)\n+               : _Jv_equalUtf8Classnames (type_name,\n+                                          (_Jv_Utf8Const *) field->type)))\n \t    {\n \t      *declarer = search;\n \t      return field;\n@@ -771,7 +771,7 @@ _Jv_ThrowNoClassDefFoundErrorTrampoline(ffi_cif *,\n                                         void *data)\n {\n   throw new java::lang::NoClassDefFoundError(\n-    _Jv_NewStringUtf8Const( (_Jv_Utf8Const *) data));\n+    _Jv_NewStringUtf8Const((_Jv_Utf8Const *) data));\n }\n #else\n // A variant of the NoClassDefFoundError throwing method that can\n@@ -947,7 +947,6 @@ _Jv_Linker::find_iindex (jclass *ifaces, jshort *offsets, jshort num)\n }\n \n #ifdef USE_LIBFFI\n-\n // We use a structure of this type to store the closure that\n // represents a missing method.\n struct method_closure\n@@ -960,12 +959,9 @@ struct method_closure\n   ffi_type *arg_types[1];\n };\n \n-#endif // USE_LIBFFI\n-\n void *\n _Jv_Linker::create_error_method (_Jv_Utf8Const *class_name)\n {\n-#ifdef USE_LIBFFI\n   method_closure *closure\n     = (method_closure *) _Jv_AllocBytes(sizeof (method_closure));\n \n@@ -974,9 +970,13 @@ _Jv_Linker::create_error_method (_Jv_Utf8Const *class_name)\n   // Initializes the cif and the closure.  If that worked the closure\n   // is returned and can be used as a function pointer in a class'\n   // atable.\n-  if (ffi_prep_cif (&closure->cif, FFI_DEFAULT_ABI, 1, &ffi_type_void,\n-\t\t    closure->arg_types) == FFI_OK\n-      && ffi_prep_closure (&closure->closure, &closure->cif,\n+  if (   ffi_prep_cif (&closure->cif,\n+                       FFI_DEFAULT_ABI,\n+                       1,\n+                       &ffi_type_void,\n+\t\t       closure->arg_types) == FFI_OK\n+      && ffi_prep_closure (&closure->closure,\n+                           &closure->cif,\n \t\t\t   _Jv_ThrowNoClassDefFoundErrorTrampoline,\n \t\t\t   class_name) == FFI_OK)\n     return &closure->closure;\n@@ -989,13 +989,17 @@ _Jv_Linker::create_error_method (_Jv_Utf8Const *class_name)\n       buffer->append (_Jv_NewStringUtf8Const(class_name));\n       throw new java::lang::InternalError(buffer->toString());\n     }\n+}\n #else\n+void *\n+_Jv_Linker::create_error_method (_Jv_Utf8Const *)\n+{\n   // Codepath for platforms which do not support (or want) libffi.\n   // You have to accept that it is impossible to provide the name\n   // of the missing class then.\n   return (void *) _Jv_ThrowNoClassDefFoundError;\n-#endif\n }\n+#endif // USE_LIBFFI\n \n // Functions for indirect dispatch (symbolic virtual binding) support.\n \n@@ -1213,7 +1217,7 @@ _Jv_Linker::link_symbol_table (jclass klass)\n \t}\n \n       // Try fields only if the target class exists.\n-      if ( target_class != NULL )\n+      if (target_class != NULL)\n       {\n \twait_for_state(target_class, JV_STATE_PREPARED);\n \tjclass found_class;"}]}