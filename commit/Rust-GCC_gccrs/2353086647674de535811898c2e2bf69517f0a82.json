{"sha": "2353086647674de535811898c2e2bf69517f0a82", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjM1MzA4NjY0NzY3NGRlNTM1ODExODk4YzJlMmJmNjk1MTdmMGE4Mg==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2004-09-22T04:12:01Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2004-09-22T04:12:01Z"}, "message": "tree-ssa-dom.c (opt_stats): Move so that it lives just after the opt_stats_d structure.\n\n        * tree-ssa-dom.c (opt_stats): Move so that it lives just after\n        the opt_stats_d structure.\n        (vrp_data): Change from a varray into a hash table.\n        (vrp_hash_elt): New structure for elements in the vrp hash table.\n        (vrp_hash, vrp_eq):New functions for hashing and testing equality\n        in the vrp hash table.\n        (tree_ssa_dominator_optimize): Initialize VRP_DATA.  Reorganize\n        initialization slightly to make it easier to read.  No longer need\n        to grow/clear the varray.  Instead empty and delete the hash table.\n        (dom_opt_finalize_block): Update due to change of VRP_DATA from\n        a varray to a hash table.\n        (simplify_cond_and_loop_avail_expr, record_range): Similarly.\n\nFrom-SVN: r87845", "tree": {"sha": "3e19d5ae866b50e4b2f87b22bd6c24591c54d3a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3e19d5ae866b50e4b2f87b22bd6c24591c54d3a4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2353086647674de535811898c2e2bf69517f0a82", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2353086647674de535811898c2e2bf69517f0a82", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2353086647674de535811898c2e2bf69517f0a82", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2353086647674de535811898c2e2bf69517f0a82/comments", "author": null, "committer": null, "parents": [{"sha": "195da47bbbf6402e3147dc1e6be6cacde140f7f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/195da47bbbf6402e3147dc1e6be6cacde140f7f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/195da47bbbf6402e3147dc1e6be6cacde140f7f3"}], "stats": {"total": 112, "additions": 91, "deletions": 21}, "files": [{"sha": "0902a1dff3ba39d4f61f6e1d2f14c7d3316fa05a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2353086647674de535811898c2e2bf69517f0a82/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2353086647674de535811898c2e2bf69517f0a82/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2353086647674de535811898c2e2bf69517f0a82", "patch": "@@ -1,5 +1,18 @@\n 2004-09-21 Jeff Law  <law@redhat.com>\n \n+\t* tree-ssa-dom.c (opt_stats): Move so that it lives just after\n+\tthe opt_stats_d structure.\n+\t(vrp_data): Change from a varray into a hash table.\n+\t(vrp_hash_elt): New structure for elements in the vrp hash table.\n+\t(vrp_hash, vrp_eq):New functions for hashing and testing equality\n+\tin the vrp hash table.\n+\t(tree_ssa_dominator_optimize): Initialize VRP_DATA.  Reorganize\n+\tinitialization slightly to make it easier to read.  No longer need\n+\tto grow/clear the varray.  Instead empty and delete the hash table.\n+\t(dom_opt_finalize_block): Update due to change of VRP_DATA from\n+\ta varray to a hash table.\n+\t(simplify_cond_and_loop_avail_expr, record_range): Similarly.\n+\n \t* tree-ssa-ccp.c (get_default_value): If we have a constant\n \tvalue recorded for an SSA_NAME, then use that constant as\n \tthe initial lattice value."}, {"sha": "057e72af6daf485bfcb73ae9e63c22fe8dc28f58", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 78, "deletions": 21, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2353086647674de535811898c2e2bf69517f0a82/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2353086647674de535811898c2e2bf69517f0a82/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=2353086647674de535811898c2e2bf69517f0a82", "patch": "@@ -141,6 +141,8 @@ struct opt_stats_d\n   long num_re;\n };\n \n+static struct opt_stats_d opt_stats;\n+\n /* Value range propagation record.  Each time we encounter a conditional\n    of the form SSA_NAME COND CONST we create a new vrp_element to record\n    how the condition affects the possible values SSA_NAME may have.\n@@ -192,11 +194,20 @@ struct vrp_element\n   basic_block bb;\n };\n \n-static struct opt_stats_d opt_stats;\n+/* A hash table holding value range records (VRP_ELEMENTs) for a given\n+   SSA_NAME.  We used to use a varray indexed by SSA_NAME_VERSION, but\n+   that gets awful wasteful, particularly since the density objects\n+   with useful information is very low.  */\n+static htab_t vrp_data;\n+\n+/* An entry in the VRP_DATA hash table.  We record the variable and a\n+   varray of VRP_ELEMENT records associated with that variable.   */\n \n-/* A virtual array holding value range records for the variable identified\n-   by the index, SSA_VERSION.  */\n-static varray_type vrp_data;\n+struct vrp_hash_elt\n+{\n+  tree var;\n+  varray_type records;\n+};\n \n /* Array of variables which have their values constrained by operations\n    in this basic block.  We use this during finalization to know\n@@ -221,6 +232,8 @@ static void optimize_stmt (struct dom_walk_data *,\n \t\t\t   block_stmt_iterator);\n static tree lookup_avail_expr (tree, bool);\n static struct eq_expr_value get_eq_expr_value (tree, int, basic_block);\n+static hashval_t vrp_hash (const void *);\n+static int vrp_eq (const void *, const void *);\n static hashval_t avail_expr_hash (const void *);\n static hashval_t real_avail_expr_hash (const void *);\n static int avail_expr_eq (const void *, const void *);\n@@ -291,15 +304,15 @@ tree_ssa_dominator_optimize (void)\n \n   /* Create our hash tables.  */\n   avail_exprs = htab_create (1024, real_avail_expr_hash, avail_expr_eq, free);\n+  vrp_data = htab_create (ceil_log2 (num_ssa_names), vrp_hash, vrp_eq, free);\n   VARRAY_TREE_INIT (avail_exprs_stack, 20, \"Available expression stack\");\n   VARRAY_TREE_INIT (block_defs_stack, 20, \"Block DEFS stack\");\n   VARRAY_TREE_INIT (const_and_copies_stack, 20, \"Block const_and_copies stack\");\n   VARRAY_TREE_INIT (nonzero_vars_stack, 20, \"Block nonzero_vars stack\");\n   VARRAY_TREE_INIT (vrp_variables_stack, 20, \"Block vrp_variables stack\");\n+  VARRAY_TREE_INIT (stmts_to_rescan, 20, \"Statements to rescan\");\n   nonzero_vars = BITMAP_XMALLOC ();\n-  VARRAY_GENERIC_PTR_INIT (vrp_data, num_ssa_names, \"vrp_data\");\n   need_eh_cleanup = BITMAP_XMALLOC ();\n-  VARRAY_TREE_INIT (stmts_to_rescan, 20, \"Statements to rescan\");\n \n   /* Setup callbacks for the generic dominator tree walker.  */\n   walk_data.walk_stmts_backward = false;\n@@ -363,13 +376,10 @@ tree_ssa_dominator_optimize (void)\n \n       rewrite_ssa_into_ssa ();\n \n-      if (VARRAY_ACTIVE_SIZE (vrp_data) <= num_ssa_names)\n-\tVARRAY_GROW (vrp_data, num_ssa_names);\n-\n       /* Reinitialize the various tables.  */\n       bitmap_clear (nonzero_vars);\n       htab_empty (avail_exprs);\n-      VARRAY_CLEAR (vrp_data);\n+      htab_empty (vrp_data);\n \n       for (i = 0; i < num_referenced_vars; i++)\n \tvar_ann (referenced_var (i))->current_def = NULL;\n@@ -382,6 +392,7 @@ tree_ssa_dominator_optimize (void)\n \n   /* We emptied the hash table earlier, now delete it completely.  */\n   htab_delete (avail_exprs);\n+  htab_delete (vrp_data);\n \n   /* It is not necessary to clear CURRDEFS, REDIRECTION_EDGES, VRP_DATA,\n      CONST_AND_COPIES, and NONZERO_VARS as they all get cleared at the bottom\n@@ -949,6 +960,8 @@ dom_opt_finalize_block (struct dom_walk_data *walk_data, basic_block bb)\n   while (VARRAY_ACTIVE_SIZE (vrp_variables_stack) > 0)\n     {\n       tree var = VARRAY_TOP_TREE (vrp_variables_stack);\n+      struct vrp_hash_elt vrp_hash_elt;\n+      void **slot;\n \n       /* Each variable has a stack of value range records.  We want to\n \t invalidate those associated with our basic block.  So we walk\n@@ -962,7 +975,12 @@ dom_opt_finalize_block (struct dom_walk_data *walk_data, basic_block bb)\n       if (var == NULL)\n \tbreak;\n \n-      var_vrp_records = VARRAY_GENERIC_PTR (vrp_data, SSA_NAME_VERSION (var));\n+      vrp_hash_elt.var = var;\n+      vrp_hash_elt.records = NULL;\n+\n+      slot = htab_find_slot (vrp_data, &vrp_hash_elt, NO_INSERT);\n+\n+      var_vrp_records = (*(struct vrp_hash_elt **)slot)->records;\n       while (VARRAY_ACTIVE_SIZE (var_vrp_records) > 0)\n \t{\n \t  struct vrp_element *element\n@@ -973,7 +991,6 @@ dom_opt_finalize_block (struct dom_walk_data *walk_data, basic_block bb)\n   \n \t  VARRAY_POP (var_vrp_records);\n \t}\n-\n     }\n \n   /* If we queued any statements to rescan in this block, then\n@@ -1859,6 +1876,8 @@ simplify_cond_and_lookup_avail_expr (tree stmt,\n \t  int lowequal, highequal, swapped, no_overlap, subset, cond_inverted;\n \t  varray_type vrp_records;\n \t  struct vrp_element *element;\n+\t  struct vrp_hash_elt vrp_hash_elt;\n+\t  void **slot;\n \n \t  /* First see if we have test of an SSA_NAME against a constant\n \t     where the SSA_NAME is defined by an earlier typecast which\n@@ -1901,7 +1920,13 @@ simplify_cond_and_lookup_avail_expr (tree stmt,\n \t     Also note the vast majority of conditionals are not testing\n \t     a variable which has had its range constrained by an earlier\n \t     conditional.  So this filter avoids a lot of unnecessary work.  */\n-\t  vrp_records = VARRAY_GENERIC_PTR (vrp_data, SSA_NAME_VERSION (op0));\n+\t  vrp_hash_elt.var = op0;\n+\t  vrp_hash_elt.records = NULL;\n+          slot = htab_find_slot (vrp_data, &vrp_hash_elt, NO_INSERT);\n+          if (slot == NULL)\n+\t    return NULL;\n+\n+\t  vrp_records = (*(struct vrp_hash_elt **)slot)->records;\n \t  if (vrp_records == NULL)\n \t    return NULL;\n \n@@ -2947,22 +2972,31 @@ record_range (tree cond, basic_block bb)\n       && TREE_CODE (cond) != NE_EXPR\n       && TREE_CODE (TREE_TYPE (TREE_OPERAND (cond, 1))) == INTEGER_TYPE)\n     {\n-      struct vrp_element *element = ggc_alloc (sizeof (struct vrp_element));\n-      int ssa_version = SSA_NAME_VERSION (TREE_OPERAND (cond, 0));\n+      struct vrp_hash_elt *vrp_hash_elt;\n+      struct vrp_element *element;\n+      varray_type *vrp_records_p;\n+      void **slot;\n+\n+\n+      vrp_hash_elt = xmalloc (sizeof (struct vrp_hash_elt));\n+      vrp_hash_elt->var = TREE_OPERAND (cond, 0);\n+      vrp_hash_elt->records = NULL;\n+      slot = htab_find_slot (vrp_data, vrp_hash_elt, INSERT);\n \n-      varray_type *vrp_records_p\n-\t= (varray_type *)&VARRAY_GENERIC_PTR (vrp_data, ssa_version);\n+      if (*slot == NULL)\n+\t*slot = (void *)vrp_hash_elt;\n \n+      vrp_hash_elt = *(struct vrp_hash_elt **)slot;\n+      vrp_records_p = &vrp_hash_elt->records;\n+\n+      element = ggc_alloc (sizeof (struct vrp_element));\n       element->low = NULL;\n       element->high = NULL;\n       element->cond = cond;\n       element->bb = bb;\n \n       if (*vrp_records_p == NULL)\n-\t{\n-\t  VARRAY_GENERIC_PTR_INIT (*vrp_records_p, 2, \"vrp records\");\n-\t  VARRAY_GENERIC_PTR (vrp_data, ssa_version) = *vrp_records_p;\n-\t}\n+\tVARRAY_GENERIC_PTR_INIT (*vrp_records_p, 2, \"vrp records\");\n       \n       VARRAY_PUSH_GENERIC_PTR (*vrp_records_p, element);\n       VARRAY_PUSH_TREE (vrp_variables_stack, TREE_OPERAND (cond, 0));\n@@ -3093,6 +3127,29 @@ get_eq_expr_value (tree if_stmt,\n   return retval;\n }\n \n+/* Hashing and equality functions for VRP_DATA.\n+\n+   Since this hash table is addressed by SSA_NAMEs, we can hash on\n+   their version number and equality can be determined with a \n+   pointer comparison.  */\n+\n+static hashval_t\n+vrp_hash (const void *p)\n+{\n+  tree var = ((struct vrp_hash_elt *)p)->var;\n+\n+  return SSA_NAME_VERSION (var);\n+}\n+\n+static int\n+vrp_eq (const void *p1, const void *p2)\n+{\n+  tree var1 = ((struct vrp_hash_elt *)p1)->var;\n+  tree var2 = ((struct vrp_hash_elt *)p2)->var;\n+\n+  return var1 == var2;\n+}\n+\n /* Hashing and equality functions for AVAIL_EXPRS.  The table stores\n    MODIFY_EXPR statements.  We compute a value number for expressions using\n    the code of the expression and the SSA numbers of its operands.  */"}]}