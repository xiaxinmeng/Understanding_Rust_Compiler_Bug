{"sha": "a360da3a3d66e12a477381aab8d4e8a995ab62fc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTM2MGRhM2EzZDY2ZTEyYTQ3NzM4MWFhYjhkNGU4YTk5NWFiNjJmYw==", "commit": {"author": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1995-01-17T21:43:40Z"}, "committer": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1995-01-17T21:43:40Z"}, "message": "Use boolean_* instead of integer_* where appropriate.\n\nFrom-SVN: r8768", "tree": {"sha": "08a6350513e2573eb787cb6ab1e8b1056117e9c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/08a6350513e2573eb787cb6ab1e8b1056117e9c3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a360da3a3d66e12a477381aab8d4e8a995ab62fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a360da3a3d66e12a477381aab8d4e8a995ab62fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a360da3a3d66e12a477381aab8d4e8a995ab62fc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a360da3a3d66e12a477381aab8d4e8a995ab62fc/comments", "author": null, "committer": null, "parents": [{"sha": "4812480a45423a5f3c2630054ff9c3d161f8d3ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4812480a45423a5f3c2630054ff9c3d161f8d3ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4812480a45423a5f3c2630054ff9c3d161f8d3ec"}], "stats": {"total": 61, "additions": 31, "deletions": 30}, "files": [{"sha": "fc7a23a3d89ac0bf6171a5d9a7edf6236cecd29b", "filename": "gcc/c-common.c", "status": "modified", "additions": 31, "deletions": 30, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a360da3a3d66e12a477381aab8d4e8a995ab62fc/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a360da3a3d66e12a477381aab8d4e8a995ab62fc/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=a360da3a3d66e12a477381aab8d4e8a995ab62fc", "patch": "@@ -1660,40 +1660,40 @@ shorten_compare (op0_ptr, op1_ptr, restype_ptr, rescode_ptr)\n       if (code == NE_EXPR)\n \t{\n \t  if (max_lt || min_gt)\n-\t    val = integer_one_node;\n+\t    val = boolean_true_node;\n \t}\n       else if (code == EQ_EXPR)\n \t{\n \t  if (max_lt || min_gt)\n-\t    val = integer_zero_node;\n+\t    val = boolean_false_node;\n \t}\n       else if (code == LT_EXPR)\n \t{\n \t  if (max_lt)\n-\t    val = integer_one_node;\n+\t    val = boolean_true_node;\n \t  if (!min_lt)\n-\t    val = integer_zero_node;\n+\t    val = boolean_false_node;\n \t}\n       else if (code == GT_EXPR)\n \t{\n \t  if (min_gt)\n-\t    val = integer_one_node;\n+\t    val = boolean_true_node;\n \t  if (!max_gt)\n-\t    val = integer_zero_node;\n+\t    val = boolean_false_node;\n \t}\n       else if (code == LE_EXPR)\n \t{\n \t  if (!max_gt)\n-\t    val = integer_one_node;\n+\t    val = boolean_true_node;\n \t  if (min_gt)\n-\t    val = integer_zero_node;\n+\t    val = boolean_false_node;\n \t}\n       else if (code == GE_EXPR)\n \t{\n \t  if (!min_lt)\n-\t    val = integer_one_node;\n+\t    val = boolean_true_node;\n \t  if (max_lt)\n-\t    val = integer_zero_node;\n+\t    val = boolean_false_node;\n \t}\n \n       /* If primop0 was sign-extended and unsigned comparison specd,\n@@ -1731,18 +1731,18 @@ shorten_compare (op0_ptr, op1_ptr, restype_ptr, rescode_ptr)\n \t{\n \t  /* This is the case of (char)x >?< 0x80, which people used to use\n \t     expecting old C compilers to change the 0x80 into -0x80.  */\n-\t  if (val == integer_zero_node)\n+\t  if (val == boolean_false_node)\n \t    warning (\"comparison is always 0 due to limited range of data type\");\n-\t  if (val == integer_one_node)\n+\t  if (val == boolean_true_node)\n \t    warning (\"comparison is always 1 due to limited range of data type\");\n \t}\n \n       if (!min_lt && unsignedp0 && TREE_CODE (primop0) != INTEGER_CST)\n \t{\n \t  /* This is the case of (unsigned char)x >?< -1 or < 0.  */\n-\t  if (val == integer_zero_node)\n+\t  if (val == boolean_false_node)\n \t    warning (\"comparison is always 0 due to limited range of data type\");\n-\t  if (val == integer_one_node)\n+\t  if (val == boolean_true_node)\n \t    warning (\"comparison is always 1 due to limited range of data type\");\n \t}\n \n@@ -1810,7 +1810,7 @@ shorten_compare (op0_ptr, op1_ptr, restype_ptr, rescode_ptr)\n \t\t\t&& ! TREE_OVERFLOW (convert (signed_type (type),\n \t\t\t\t\t\t     primop0))))\n \t\twarning (\"unsigned value >= 0 is always 1\");\n-\t      value = integer_one_node;\n+\t      value = boolean_true_node;\n \t      break;\n \n \t    case LT_EXPR:\n@@ -1819,7 +1819,7 @@ shorten_compare (op0_ptr, op1_ptr, restype_ptr, rescode_ptr)\n \t\t\t&& ! TREE_OVERFLOW (convert (signed_type (type),\n \t\t\t\t\t\t     primop0))))\n \t\twarning (\"unsigned value < 0 is always 0\");\n-\t      value = integer_zero_node;\n+\t      value = boolean_false_node;\n \t    }\n \n \t  if (value != 0)\n@@ -1836,7 +1836,7 @@ shorten_compare (op0_ptr, op1_ptr, restype_ptr, rescode_ptr)\n   *op0_ptr = convert (type, primop0);\n   *op1_ptr = convert (type, primop1);\n \n-  *restype_ptr = integer_type_node;\n+  *restype_ptr = boolean_type_node;\n \n   return 0;\n }\n@@ -1847,10 +1847,10 @@ shorten_compare (op0_ptr, op1_ptr, restype_ptr, rescode_ptr)\n    This preparation consists of taking the ordinary\n    representation of an expression expr and producing a valid tree\n    boolean expression describing whether expr is nonzero.  We could\n-   simply always do build_binary_op (NE_EXPR, expr, integer_zero_node, 1),\n+   simply always do build_binary_op (NE_EXPR, expr, boolean_false_node, 1),\n    but we optimize comparisons, &&, ||, and !.\n \n-   The resulting type should always be `integer_type_node'.  */\n+   The resulting type should always be `boolean_type_node'.  */\n \n tree\n truthvalue_conversion (expr)\n@@ -1866,15 +1866,15 @@ truthvalue_conversion (expr)\n     {\n     case RECORD_TYPE:\n       error (\"struct type value used where scalar is required\");\n-      return integer_zero_node;\n+      return boolean_false_node;\n \n     case UNION_TYPE:\n       error (\"union type value used where scalar is required\");\n-      return integer_zero_node;\n+      return boolean_false_node;\n \n     case ARRAY_TYPE:\n       error (\"array type value used where scalar is required\");\n-      return integer_zero_node;\n+      return boolean_false_node;\n \n     default:\n       break;\n@@ -1907,23 +1907,24 @@ truthvalue_conversion (expr)\n     case TRUTH_AND_EXPR:\n     case TRUTH_OR_EXPR:\n     case TRUTH_XOR_EXPR:\n-      return convert (integer_type_node, expr);\n+      TREE_TYPE (expr) = boolean_type_node;\n+      return expr;\n \n     case ERROR_MARK:\n       return expr;\n \n     case INTEGER_CST:\n-      return integer_zerop (expr) ? integer_zero_node : integer_one_node;\n+      return integer_zerop (expr) ? boolean_false_node : boolean_true_node;\n \n     case REAL_CST:\n-      return real_zerop (expr) ? integer_zero_node : integer_one_node;\n+      return real_zerop (expr) ? boolean_false_node : boolean_true_node;\n \n     case ADDR_EXPR:\n       if (TREE_SIDE_EFFECTS (TREE_OPERAND (expr, 0)))\n-\treturn build (COMPOUND_EXPR, integer_type_node,\n-\t\t      TREE_OPERAND (expr, 0), integer_one_node);\n+\treturn build (COMPOUND_EXPR, boolean_type_node,\n+\t\t      TREE_OPERAND (expr, 0), boolean_true_node);\n       else\n-\treturn integer_one_node;\n+\treturn boolean_true_node;\n \n     case COMPLEX_EXPR:\n       return build_binary_op ((TREE_SIDE_EFFECTS (TREE_OPERAND (expr, 1))\n@@ -1944,14 +1945,14 @@ truthvalue_conversion (expr)\n       /* These don't change whether an object is zero or non-zero, but\n \t we can't ignore them if their second arg has side-effects.  */\n       if (TREE_SIDE_EFFECTS (TREE_OPERAND (expr, 1)))\n-\treturn build (COMPOUND_EXPR, integer_type_node, TREE_OPERAND (expr, 1),\n+\treturn build (COMPOUND_EXPR, boolean_type_node, TREE_OPERAND (expr, 1),\n \t\t      truthvalue_conversion (TREE_OPERAND (expr, 0)));\n       else\n \treturn truthvalue_conversion (TREE_OPERAND (expr, 0));\n       \n     case COND_EXPR:\n       /* Distribute the conversion into the arms of a COND_EXPR.  */\n-      return fold (build (COND_EXPR, integer_type_node, TREE_OPERAND (expr, 0),\n+      return fold (build (COND_EXPR, boolean_type_node, TREE_OPERAND (expr, 0),\n \t\t\t  truthvalue_conversion (TREE_OPERAND (expr, 1)),\n \t\t\t  truthvalue_conversion (TREE_OPERAND (expr, 2))));\n "}]}