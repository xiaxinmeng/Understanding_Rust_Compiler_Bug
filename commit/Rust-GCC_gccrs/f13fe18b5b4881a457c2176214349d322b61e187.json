{"sha": "f13fe18b5b4881a457c2176214349d322b61e187", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjEzZmUxOGI1YjQ4ODFhNDU3YzIxNzYyMTQzNDlkMzIyYjYxZTE4Nw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2016-04-16T16:30:48Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2016-04-16T16:30:48Z"}, "message": "re PR c++/70018 (Possible issue around IPO and C++ comdats discovered as pure/const)\n\n\n\tPR ipa/70018\n\t* cgraph.c (cgraph_node::get_availability): Add REF parameter.\n\t(cgraph_node::function_symbol): Likewise.\n\t(cgraph_node::function_or_virtual_thunk_symbol): Likewise.\n\t* cgraph.h (symtab_node::get_availabbility): Add REF parameter.\n\t(symtab_node::ultimate_alias_target): Add REF parameter.\n\t(symtab_node::binds_to_current_def_p): Declare.\n\t(symtab_node;:ultimate_alias_target_1): Add REF parameter.\n\t(cgraph_node::function_symbol): Likewise.\n\t(cgraph_node::function_or_virtual_thunk_symbol): Likewise.\n\t(cgraph_node::get_availability): Likewise.\n\t(cgraph_edge::binds_to_current_def_p): New inline function.\n\t(varpool_node::get_availability): Add REF parameter.\n\t(varpool_node::ultimate_alias_target): Likewise.\n\t* symtab.c (symtab_node::ultimate_alias_target_1): Likewise.\n\t(symtab_node::binds_to_current_def_p): Likewise.\n\t* varpool.c (varpool_node::get_availability): Likewise.\n\nFrom-SVN: r235063", "tree": {"sha": "4cef7161787b418b3d579ca1e2fc6cd70a647584", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4cef7161787b418b3d579ca1e2fc6cd70a647584"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f13fe18b5b4881a457c2176214349d322b61e187", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f13fe18b5b4881a457c2176214349d322b61e187", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f13fe18b5b4881a457c2176214349d322b61e187", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f13fe18b5b4881a457c2176214349d322b61e187/comments", "author": null, "committer": null, "parents": [{"sha": "06c3ddc04956997f9a45769cf44cc85f013e0245", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06c3ddc04956997f9a45769cf44cc85f013e0245", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06c3ddc04956997f9a45769cf44cc85f013e0245"}], "stats": {"total": 251, "additions": 199, "deletions": 52}, "files": [{"sha": "98ced2828f07bd9d560b5d55145482365b97e3dd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f13fe18b5b4881a457c2176214349d322b61e187/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f13fe18b5b4881a457c2176214349d322b61e187/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f13fe18b5b4881a457c2176214349d322b61e187", "patch": "@@ -1,3 +1,23 @@\n+2016-04-15  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR ipa/70018\n+\t* cgraph.c (cgraph_node::get_availability): Add REF parameter.\n+\t(cgraph_node::function_symbol): Likewise.\n+\t(cgraph_node::function_or_virtual_thunk_symbol): Likewise.\n+\t* cgraph.h (symtab_node::get_availabbility): Add REF parameter.\n+\t(symtab_node::ultimate_alias_target): Add REF parameter.\n+\t(symtab_node::binds_to_current_def_p): Declare.\n+\t(symtab_node;:ultimate_alias_target_1): Add REF parameter.\n+\t(cgraph_node::function_symbol): Likewise.\n+\t(cgraph_node::function_or_virtual_thunk_symbol): Likewise.\n+\t(cgraph_node::get_availability): Likewise.\n+\t(cgraph_edge::binds_to_current_def_p): New inline function.\n+\t(varpool_node::get_availability): Add REF parameter.\n+\t(varpool_node::ultimate_alias_target): Likewise.\n+\t* symtab.c (symtab_node::ultimate_alias_target_1): Likewise.\n+\t(symtab_node::binds_to_current_def_p): Likewise.\n+\t* varpool.c (varpool_node::get_availability): Likewise.\n+\n 2016-04-15  Kirill Yukhin  <kirill.yukhin@intel.com>\n \n \tPR target/70662"}, {"sha": "0ced2dbc2f4e70e5d18a9e6b3e25664d5ad98395", "filename": "gcc/cgraph.c", "status": "modified", "additions": 38, "deletions": 17, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f13fe18b5b4881a457c2176214349d322b61e187/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f13fe18b5b4881a457c2176214349d322b61e187/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=f13fe18b5b4881a457c2176214349d322b61e187", "patch": "@@ -2209,19 +2209,36 @@ cgraph_node::unnest (void)\n /* Return function availability.  See cgraph.h for description of individual\n    return values.  */\n enum availability\n-cgraph_node::get_availability (void)\n+cgraph_node::get_availability (symtab_node *ref)\n {\n+  if (ref)\n+    {\n+      cgraph_node *cref = dyn_cast <cgraph_node *> (ref);\n+      if (cref)\n+\tref = cref->global.inlined_to;\n+    }\n   enum availability avail;\n   if (!analyzed)\n     avail = AVAIL_NOT_AVAILABLE;\n   else if (local.local)\n     avail = AVAIL_LOCAL;\n+  else if (global.inlined_to)\n+    avail = AVAIL_AVAILABLE;\n   else if (transparent_alias)\n-    ultimate_alias_target (&avail);\n+    ultimate_alias_target (&avail, ref);\n   else if (lookup_attribute (\"ifunc\", DECL_ATTRIBUTES (decl)))\n     avail = AVAIL_INTERPOSABLE;\n   else if (!externally_visible)\n     avail = AVAIL_AVAILABLE;\n+  /* If this is a reference from symbol itself and there are no aliases, we\n+     may be sure that the symbol was not interposed by soemthing else because\n+     the symbol itself would be unreachable otherwise.\n+\n+     Also comdat groups are always resolved in groups.  */\n+  else if ((this == ref && !has_aliases_p ())\n+           || (ref && get_comdat_group ()\n+               && get_comdat_group () == ref->get_comdat_group ()))\n+    avail = AVAIL_AVAILABLE;\n   /* Inline functions are safe to be analyzed even if their symbol can\n      be overwritten at runtime.  It is not meaningful to enforce any sane\n      behavior on replacing inline function by different body.  */\n@@ -2232,11 +2249,7 @@ cgraph_node::get_availability (void)\n      care at least of two notable extensions - the COMDAT functions\n      used to share template instantiations in C++ (this is symmetric\n      to code cp_cannot_inline_tree_fn and probably shall be shared and\n-     the inlinability hooks completely eliminated).\n-\n-     ??? Does the C++ one definition rule allow us to always return\n-     AVAIL_AVAILABLE here?  That would be good reason to preserve this\n-     bit.  */\n+     the inlinability hooks completely eliminated).  */\n \n   else if (decl_replaceable_p (decl) && !DECL_EXTERNAL (decl))\n     avail = AVAIL_INTERPOSABLE;\n@@ -3250,50 +3263,58 @@ cgraph_node::verify_cgraph_nodes (void)\n \n /* Walk the alias chain to return the function cgraph_node is alias of.\n    Walk through thunks, too.\n-   When AVAILABILITY is non-NULL, get minimal availability in the chain.  */\n+   When AVAILABILITY is non-NULL, get minimal availability in the chain.\n+   When REF is non-NULL, assume that reference happens in symbol REF\n+   when determining the availability.  */\n \n cgraph_node *\n-cgraph_node::function_symbol (enum availability *availability)\n+cgraph_node::function_symbol (enum availability *availability,\n+\t\t\t      struct symtab_node *ref)\n {\n-  cgraph_node *node = ultimate_alias_target (availability);\n+  cgraph_node *node = ultimate_alias_target (availability, ref);\n \n   while (node->thunk.thunk_p)\n     {\n+      ref = node;\n       node = node->callees->callee;\n       if (availability)\n \t{\n \t  enum availability a;\n-\t  a = node->get_availability ();\n+\t  a = node->get_availability (ref);\n \t  if (a < *availability)\n \t    *availability = a;\n \t}\n-      node = node->ultimate_alias_target (availability);\n+      node = node->ultimate_alias_target (availability, ref);\n     }\n   return node;\n }\n \n /* Walk the alias chain to return the function cgraph_node is alias of.\n    Walk through non virtual thunks, too.  Thus we return either a function\n    or a virtual thunk node.\n-   When AVAILABILITY is non-NULL, get minimal availability in the chain.  */\n+   When AVAILABILITY is non-NULL, get minimal availability in the chain. \n+   When REF is non-NULL, assume that reference happens in symbol REF\n+   when determining the availability.  */\n \n cgraph_node *\n cgraph_node::function_or_virtual_thunk_symbol\n-\t\t\t\t(enum availability *availability)\n+\t\t\t\t(enum availability *availability,\n+\t\t\t\t struct symtab_node *ref)\n {\n-  cgraph_node *node = ultimate_alias_target (availability);\n+  cgraph_node *node = ultimate_alias_target (availability, ref);\n \n   while (node->thunk.thunk_p && !node->thunk.virtual_offset_p)\n     {\n+      ref = node;\n       node = node->callees->callee;\n       if (availability)\n \t{\n \t  enum availability a;\n-\t  a = node->get_availability ();\n+\t  a = node->get_availability (ref);\n \t  if (a < *availability)\n \t    *availability = a;\n \t}\n-      node = node->ultimate_alias_target (availability);\n+      node = node->ultimate_alias_target (availability, ref);\n     }\n   return node;\n }"}, {"sha": "5b2b4bcd4c187b5ce955c47331bdbdf255216e8e", "filename": "gcc/cgraph.h", "status": "modified", "additions": 72, "deletions": 29, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f13fe18b5b4881a457c2176214349d322b61e187/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f13fe18b5b4881a457c2176214349d322b61e187/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=f13fe18b5b4881a457c2176214349d322b61e187", "patch": "@@ -242,8 +242,11 @@ class GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n \n   /* Walk the alias chain to return the symbol NODE is alias of.\n      If NODE is not an alias, return NODE.\n-     When AVAILABILITY is non-NULL, get minimal availability in the chain.  */\n-  symtab_node *ultimate_alias_target (enum availability *avail = NULL);\n+     When AVAILABILITY is non-NULL, get minimal availability in the chain.\n+     When REF is non-NULL, assume that reference happens in symbol REF\n+     when determining the availability.  */\n+  symtab_node *ultimate_alias_target (enum availability *avail = NULL,\n+\t\t\t\t      struct symtab_node *ref = NULL);\n \n   /* Return next reachable static symbol with initializer after NODE.  */\n   inline symtab_node *next_defined_symbol (void);\n@@ -287,8 +290,13 @@ class GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n   /* Return the initialization priority.  */\n   priority_type get_init_priority ();\n \n-  /* Return availability of NODE.  */\n-  enum availability get_availability (void);\n+  /* Return availability of NODE when referenced from REF.  */\n+  enum availability get_availability (symtab_node *ref = NULL);\n+\n+  /* Return true if NODE binds to current definition in final executable\n+     when referenced from REF.  If REF is NULL return conservative value\n+     for any reference.  */\n+  bool binds_to_current_def_p (symtab_node *ref = NULL);\n \n   /* Make DECL local.  */\n   void make_decl_local (void);\n@@ -595,7 +603,8 @@ class GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n   static bool noninterposable_alias (symtab_node *node, void *data);\n \n   /* Worker for ultimate_alias_target.  */\n-  symtab_node *ultimate_alias_target_1 (enum availability *avail = NULL);\n+  symtab_node *ultimate_alias_target_1 (enum availability *avail = NULL,\n+\t\t\t\t\tsymtab_node *ref = NULL);\n };\n \n inline void\n@@ -867,15 +876,21 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node {\n \n   /* Walk the alias chain to return the function cgraph_node is alias of.\n      Walk through thunk, too.\n-     When AVAILABILITY is non-NULL, get minimal availability in the chain.  */\n-  cgraph_node *function_symbol (enum availability *avail = NULL);\n+     When AVAILABILITY is non-NULL, get minimal availability in the chain. \n+     When REF is non-NULL, assume that reference happens in symbol REF\n+     when determining the availability.  */\n+  cgraph_node *function_symbol (enum availability *avail = NULL,\n+\t\t\t\tstruct symtab_node *ref = NULL);\n \n   /* Walk the alias chain to return the function cgraph_node is alias of.\n      Walk through non virtual thunks, too.  Thus we return either a function\n      or a virtual thunk node.\n-     When AVAILABILITY is non-NULL, get minimal availability in the chain.  */\n+     When AVAILABILITY is non-NULL, get minimal availability in the chain.  \n+     When REF is non-NULL, assume that reference happens in symbol REF\n+     when determining the availability.  */\n   cgraph_node *function_or_virtual_thunk_symbol\n-\t\t\t\t(enum availability *avail = NULL);\n+\t\t\t\t(enum availability *avail = NULL,\n+\t\t\t\t struct symtab_node *ref = NULL);\n \n   /* Create node representing clone of N executed COUNT times.  Decrease\n      the execution counts from original node too.\n@@ -974,9 +989,12 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node {\n \n   /* Given function symbol, walk the alias chain to return the function node\n      is alias of. Do not walk through thunks.\n-     When AVAILABILITY is non-NULL, get minimal availability in the chain.  */\n+     When AVAILABILITY is non-NULL, get minimal availability in the chain.\n+     When REF is non-NULL, assume that reference happens in symbol REF\n+     when determining the availability.  */\n \n-  cgraph_node *ultimate_alias_target (availability *availability = NULL);\n+  cgraph_node *ultimate_alias_target (availability *availability = NULL,\n+\t\t\t\t      symtab_node *ref = NULL);\n \n   /* Expand thunk NODE to gimple if possible.\n      When FORCE_GIMPLE_THUNK is true, gimple thunk is created and\n@@ -1089,7 +1107,7 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node {\n \n   /* Return function availability.  See cgraph.h for description of individual\n      return values.  */\n-  enum availability get_availability (void);\n+  enum availability get_availability (symtab_node *ref = NULL);\n \n   /* Set TREE_NOTHROW on cgraph_node's decl and on aliases of the node\n      if any to NOTHROW.  */\n@@ -1689,6 +1707,9 @@ struct GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_caller\"),\n      type.  */\n   unsigned in_polymorphic_cdtor : 1;\n \n+  /* Return true if call must bind to current definition.  */\n+  bool binds_to_current_def_p ();\n+\n private:\n   /* Remove the edge from the list of the callers of the callee.  */\n   void remove_caller (void);\n@@ -1731,7 +1752,7 @@ class GTY((tag (\"SYMTAB_VARIABLE\"))) varpool_node : public symtab_node {\n   void analyze (void);\n \n   /* Return variable availability.  */\n-  availability get_availability (void);\n+  availability get_availability (symtab_node *ref = NULL);\n \n   /* When doing LTO, read variable's constructor from disk if\n      it is not already present.  */\n@@ -1742,9 +1763,11 @@ class GTY((tag (\"SYMTAB_VARIABLE\"))) varpool_node : public symtab_node {\n \n   /* For given variable pool node, walk the alias chain to return the function\n      the variable is alias of. Do not walk through thunks.\n-     When AVAILABILITY is non-NULL, get minimal availability in the chain.  */\n+     When AVAILABILITY is non-NULL, get minimal availability in the chain.\n+     When REF is non-NULL, assume that reference happens in symbol REF\n+     when determining the availability.  */\n   inline varpool_node *ultimate_alias_target\n-    (availability *availability = NULL);\n+    (availability *availability = NULL, symtab_node *ref = NULL);\n \n   /* Return node that alias is aliasing.  */\n   inline varpool_node *get_alias_target (void);\n@@ -2888,44 +2911,53 @@ varpool_node::get_alias_target (void)\n \n /* Walk the alias chain to return the symbol NODE is alias of.\n    If NODE is not an alias, return NODE.\n-   When AVAILABILITY is non-NULL, get minimal availability in the chain.  */\n+   When AVAILABILITY is non-NULL, get minimal availability in the chain.\n+   When REF is non-NULL, assume that reference happens in symbol REF\n+   when determining the availability.  */\n \n inline symtab_node *\n-symtab_node::ultimate_alias_target (enum availability *availability)\n+symtab_node::ultimate_alias_target (enum availability *availability,\n+\t\t\t\t    symtab_node *ref)\n {\n   if (!alias)\n     {\n       if (availability)\n-\t*availability = get_availability ();\n+\t*availability = get_availability (ref);\n       return this;\n     }\n \n-  return ultimate_alias_target_1 (availability);\n+  return ultimate_alias_target_1 (availability, ref);\n }\n \n /* Given function symbol, walk the alias chain to return the function node\n    is alias of. Do not walk through thunks.\n-   When AVAILABILITY is non-NULL, get minimal availability in the chain.  */\n+   When AVAILABILITY is non-NULL, get minimal availability in the chain.\n+   When REF is non-NULL, assume that reference happens in symbol REF\n+   when determining the availability.  */\n \n inline cgraph_node *\n-cgraph_node::ultimate_alias_target (enum availability *availability)\n+cgraph_node::ultimate_alias_target (enum availability *availability,\n+\t\t\t\t    symtab_node *ref)\n {\n   cgraph_node *n = dyn_cast <cgraph_node *>\n-    (symtab_node::ultimate_alias_target (availability));\n+    (symtab_node::ultimate_alias_target (availability, ref));\n   if (!n && availability)\n     *availability = AVAIL_NOT_AVAILABLE;\n   return n;\n }\n \n /* For given variable pool node, walk the alias chain to return the function\n    the variable is alias of. Do not walk through thunks.\n-   When AVAILABILITY is non-NULL, get minimal availability in the chain.  */\n+   When AVAILABILITY is non-NULL, get minimal availability in the chain.\n+   When REF is non-NULL, assume that reference happens in symbol REF\n+   when determining the availability.  */\n \n inline varpool_node *\n-varpool_node::ultimate_alias_target (availability *availability)\n+varpool_node::ultimate_alias_target (availability *availability,\n+\t\t\t\t     symtab_node *ref)\n {\n   varpool_node *n = dyn_cast <varpool_node *>\n-    (symtab_node::ultimate_alias_target (availability));\n+    (symtab_node::ultimate_alias_target (availability, ref));\n \n   if (!n && availability)\n     *availability = AVAIL_NOT_AVAILABLE;\n@@ -2985,6 +3017,17 @@ cgraph_edge::remove_callee (void)\n     callee->callers = next_caller;\n }\n \n+/* Return true if call must bind to current definition.  */\n+\n+inline bool\n+cgraph_edge::binds_to_current_def_p ()\n+{\n+  if (callee)\n+    return callee->binds_to_current_def_p (caller);\n+  else\n+    return NULL;\n+}\n+\n /* Return true if the TM_CLONE bit is set for a given FNDECL.  */\n static inline bool\n decl_is_tm_clone (const_tree fndecl)\n@@ -3030,15 +3073,15 @@ symtab_node::get_create (tree node)\n     return cgraph_node::get_create (node);\n }\n \n-/* Return availability of NODE.  */\n+/* Return availability of NODE when referenced from REF.  */\n \n inline enum availability\n-symtab_node::get_availability (void)\n+symtab_node::get_availability (symtab_node *ref)\n {\n   if (is_a <cgraph_node *> (this))\n-    return dyn_cast <cgraph_node *> (this)->get_availability ();\n+    return dyn_cast <cgraph_node *> (this)->get_availability (ref);\n   else\n-    return dyn_cast <varpool_node *> (this)->get_availability ();\n+    return dyn_cast <varpool_node *> (this)->get_availability (ref);\n }\n \n /* Call calback on symtab node and aliases associated to this node."}, {"sha": "e69dc1789f02c4b5c47f7eb7928bb86abd8b3e14", "filename": "gcc/symtab.c", "status": "modified", "additions": 60, "deletions": 4, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f13fe18b5b4881a457c2176214349d322b61e187/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f13fe18b5b4881a457c2176214349d322b61e187/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=f13fe18b5b4881a457c2176214349d322b61e187", "patch": "@@ -1347,7 +1347,8 @@ symtab_node::copy_visibility_from (symtab_node *n)\n    Assumes NODE is known to be alias.  */\n \n symtab_node *\n-symtab_node::ultimate_alias_target_1 (enum availability *availability)\n+symtab_node::ultimate_alias_target_1 (enum availability *availability,\n+\t\t\t\t      symtab_node *ref)\n {\n   bool transparent_p = false;\n \n@@ -1368,7 +1369,7 @@ symtab_node::ultimate_alias_target_1 (enum availability *availability)\n     {\n       transparent_p = transparent_alias;\n       if (!transparent_p)\n-\t*availability = get_availability ();\n+\t*availability = get_availability (ref);\n       else\n \t*availability = AVAIL_NOT_AVAILABLE;\n     }\n@@ -1383,15 +1384,15 @@ symtab_node::ultimate_alias_target_1 (enum availability *availability)\n \t  if (!availability || (!transparent_p && node->analyzed))\n \t    ;\n \t  else if (node->analyzed && !node->transparent_alias)\n-\t    *availability = node->get_availability ();\n+\t    *availability = node->get_availability (ref);\n \t  else\n \t    *availability = AVAIL_NOT_AVAILABLE;\n \t  return node;\n \t}\n       if (node && availability && transparent_p\n \t  && node->transparent_alias)\n \t{\n-\t  *availability = node->get_availability ();\n+\t  *availability = node->get_availability (ref);\n \t  transparent_p = false;\n \t}\n     }\n@@ -2206,3 +2207,58 @@ symbol_table::symbol_suffix_separator ()\n   return '_';\n #endif\n }\n+\n+/* Return true when references to this symbol from REF must bind to current\n+   definition in final executable.  */\n+\n+bool\n+symtab_node::binds_to_current_def_p (symtab_node *ref)\n+{\n+  if (!definition)\n+    return false;\n+  if (decl_binds_to_current_def_p (decl))\n+    return true;\n+\n+  /* Inline clones always binds locally.  */\n+  cgraph_node *cnode = dyn_cast <cgraph_node *> (this);\n+  if (cnode && cnode->global.inlined_to)\n+    return true;\n+\n+  if (DECL_EXTERNAL (decl))\n+    return false;\n+\n+  if (!externally_visible)\n+    debug ();\n+  gcc_assert (externally_visible);\n+\n+  if (ref)\n+    {\n+      cgraph_node *cref = dyn_cast <cgraph_node *> (ref);\n+      if (cref)\n+\tref = cref->global.inlined_to;\n+    }\n+\n+  /* If this is a reference from symbol itself and there are no aliases, we\n+     may be sure that the symbol was not interposed by soemthing else because\n+     the symbol itself would be unreachable otherwise.  This is important\n+     to optimize recursive functions well.\n+\n+     This assumption may be broken by inlining: if symbol is interposable\n+     but the body is available (i.e. declared inline), inliner may make\n+     the body reachable even with interposition.  */\n+  if (this == ref && !has_aliases_p ()\n+      && (!cnode\n+\t  || symtab->state >= IPA_SSA_AFTER_INLINING\n+\t  || get_availability () >= AVAIL_INTERPOSABLE))\n+    return true;\n+\n+\n+  /* References within one comdat group are always bound in a group.  */\n+  if (ref\n+      && symtab->state >= IPA_SSA_AFTER_INLINING\n+      && get_comdat_group ()\n+      && get_comdat_group () == ref->get_comdat_group ())\n+    return true;\n+\n+  return false;\n+}"}, {"sha": "12696a4faaaf89efe54cbe0b18cda61cb30702a7", "filename": "gcc/varpool.c", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f13fe18b5b4881a457c2176214349d322b61e187/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f13fe18b5b4881a457c2176214349d322b61e187/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=f13fe18b5b4881a457c2176214349d322b61e187", "patch": "@@ -482,7 +482,7 @@ varpool_node::add (tree decl)\n /* Return variable availability.  See cgraph.h for description of individual\n    return values.  */\n enum availability\n-varpool_node::get_availability (void)\n+varpool_node::get_availability (symtab_node *ref)\n {\n   if (!definition)\n     return AVAIL_NOT_AVAILABLE;\n@@ -495,9 +495,16 @@ varpool_node::get_availability (void)\n     {\n       enum availability avail;\n \n-      ultimate_alias_target (&avail);\n+      ultimate_alias_target (&avail, ref);\n       return avail;\n     }\n+  /* If this is a reference from symbol itself and there are no aliases, we\n+     may be sure that the symbol was not interposed by soemthing else because\n+     the symbol itself would be unreachable otherwise.  */\n+  if ((this == ref && !has_aliases_p ())\n+      || (ref && get_comdat_group ()\n+          && get_comdat_group () == ref->get_comdat_group ()))\n+    return AVAIL_AVAILABLE;\n   /* If the variable can be overwritten, return OVERWRITABLE.  Takes\n      care of at least one notable extension - the COMDAT variables\n      used to share template instantiations in C++.  */"}]}