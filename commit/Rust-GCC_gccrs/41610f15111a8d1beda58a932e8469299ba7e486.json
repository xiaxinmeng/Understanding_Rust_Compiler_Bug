{"sha": "41610f15111a8d1beda58a932e8469299ba7e486", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDE2MTBmMTUxMTFhOGQxYmVkYTU4YTkzMmU4NDY5Mjk5YmE3ZTQ4Ng==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2018-05-25T09:03:59Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2018-05-25T09:03:59Z"}, "message": "[Ada] Strengthen checks for instantiation with interface types\n\n2018-05-25  Ed Schonberg  <schonberg@adacore.com>\n\ngcc/ada/\n\n\t* sem_ch12.adb (Instance_Exists): New function, subsidiary of\n\tValidate_Derived_Type_Instance, to verify that all interfaces\n\timplemented by the formal type are also implemented by the actual. The\n\tverification is complicated when an interface of the formal is declared\n\tin a generic unit and the actual is declared in an instance of it.\n\tThere is currently no mechanism to relate an interface declared within\n\ta generic to the corresponding interface in an instance, so we must\n\ttraverse the list of interfaces of the actual, looking for a name\n\tmatch, and verifying that that interface is declared in an instance.\n\nFrom-SVN: r260726", "tree": {"sha": "7a9da9455d51fcacb39528c7ef055c95b31b94de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7a9da9455d51fcacb39528c7ef055c95b31b94de"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/41610f15111a8d1beda58a932e8469299ba7e486", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41610f15111a8d1beda58a932e8469299ba7e486", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41610f15111a8d1beda58a932e8469299ba7e486", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41610f15111a8d1beda58a932e8469299ba7e486/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9da8032d4b0b5ca8cf5397b617cbcef55f735e19", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9da8032d4b0b5ca8cf5397b617cbcef55f735e19", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9da8032d4b0b5ca8cf5397b617cbcef55f735e19"}], "stats": {"total": 66, "additions": 58, "deletions": 8}, "files": [{"sha": "5cd546a6d277df6acb5a059099b4459da3eb0eed", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41610f15111a8d1beda58a932e8469299ba7e486/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41610f15111a8d1beda58a932e8469299ba7e486/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=41610f15111a8d1beda58a932e8469299ba7e486", "patch": "@@ -1,3 +1,15 @@\n+2018-05-25  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch12.adb (Instance_Exists): New function, subsidiary of\n+\tValidate_Derived_Type_Instance, to verify that all interfaces\n+\timplemented by the formal type are also implemented by the actual. The\n+\tverification is complicated when an interface of the formal is declared\n+\tin a generic unit and the actual is declared in an instance of it.\n+\tThere is currently no mechanism to relate an interface declared within\n+\ta generic to the corresponding interface in an instance, so we must\n+\ttraverse the list of interfaces of the actual, looking for a name\n+\tmatch, and verifying that that interface is declared in an instance.\n+\n 2018-05-25  Piotr Trojanek  <trojanek@adacore.com>\n \n \t* sem_util.adb (Iterate_Call_Parameters): Rewrite with extra"}, {"sha": "f97f08375cc92d5a105aed74bae188fc715d5790", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 46, "deletions": 8, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41610f15111a8d1beda58a932e8469299ba7e486/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41610f15111a8d1beda58a932e8469299ba7e486/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=41610f15111a8d1beda58a932e8469299ba7e486", "patch": "@@ -12362,9 +12362,6 @@ package body Sem_Ch12 is\n          --  The actual may be an extension of an interface, in which case\n          --  it does not appear in the interface list, so this must be\n          --  checked separately.\n-         --  We omit the check if the interface is declared in an (enclosing)\n-         --  generic because the interface implemented by the actual may have\n-         --  the same name but a different entity. A small remaining gap ???\n \n          if Present (Interface_List (Def)) then\n             if not Has_Interfaces (Act_T) then\n@@ -12374,18 +12371,59 @@ package body Sem_Ch12 is\n \n             else\n                declare\n-                  Iface : Node_Id;\n-                  Iface_Ent : Entity_Id;\n+                  Iface          : Node_Id;\n+                  Iface_Ent      : Entity_Id;\n+                  Act_Iface_List : Elist_Id;\n+\n+                  function Instance_Exists (I : Entity_Id) return Boolean;\n+                  --  If the interface entity is declared in a generic unit,\n+                  --  this can only be legal if we are within an instantiation\n+                  --  of a child of that generic. There is currently no\n+                  --  mechanism to relate an interface declared within a\n+                  --  generic to the corresponding interface in an instance,\n+                  --  so we traverse the list of interfaces of the actual,\n+                  --  looking for a name match.\n+\n+                  ---------------------\n+                  -- Instance_Exists --\n+                  ---------------------\n+\n+                  function Instance_Exists (I : Entity_Id) return Boolean is\n+                     Iface_Elmt : Elmt_Id;\n+\n+                  begin\n+                     Iface_Elmt := First_Elmt (Act_Iface_List);\n+                     while Present (Iface_Elmt) loop\n+                        if Is_Generic_Instance (Scope (Node (Iface_Elmt)))\n+                          and then Chars (Node (Iface_Elmt)) = Chars (I)\n+                        then\n+                           return True;\n+                        end if;\n+\n+                        Next_Elmt (Iface_Elmt);\n+                     end loop;\n+\n+                     return False;\n+                  end Instance_Exists;\n \n                begin\n                   Iface := First (Abstract_Interface_List (A_Gen_T));\n+                  Collect_Interfaces (Act_T, Act_Iface_List);\n \n                   while Present (Iface) loop\n                      Iface_Ent := Get_Instance_Of (Entity (Iface));\n-                     if not Is_Progenitor (Iface_Ent, Act_T)\n-                     and then not Is_Ancestor (Iface_Ent, Act_T)\n-                     and then Ekind (Scope (Iface_Ent)) /= E_Generic_Package\n+\n+                     if  Is_Ancestor (Iface_Ent, Act_T)\n+                      or else  Is_Progenitor (Iface_Ent, Act_T)\n+                     then\n+                        null;\n+\n+                     elsif Ekind (Scope (Iface_Ent)) = E_Generic_Package\n+                       and then Instance_Exists (Iface_Ent)\n                      then\n+                        null;\n+\n+                     else\n                         Error_Msg_Name_1 := Chars (Act_T);\n                         Error_Msg_NE\n                           (\"Actual% must implement interface&\","}]}