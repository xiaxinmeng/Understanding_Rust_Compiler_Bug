{"sha": "f3dd0581a51be1e4354bdcf23f1eee7f5c707a3a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjNkZDA1ODFhNTFiZTFlNDM1NGJkY2YyM2YxZWVlN2Y1YzcwN2EzYQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2020-11-19T14:35:35Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-12-14T15:51:52Z"}, "message": "[Ada] Implement part of System.Fat_Gen more efficiently\n\ngcc/ada/\n\n\t* libgnat/s-fatgen.ads (Compose): Add pragma Inline.\n\t(Copy_Sign): Likewise.\n\t(Exponent): Likewise.\n\t(Fraction): Likewise.\n\t* libgnat/s-fatgen.adb: Remove with clause for System, add\n\twith and use clauses for System.Unsigned_Types.\n\tAdd pragma Warnings (Off) for non-static constants.\n\tRemove precomputed tables of powers of radix and add a few\n\tconstants describing the floating-point format.\n\t(Gradual_Scaling): Delete.\n\t(Copy_Sign): Reimplement directly.\n\t(Decompose): Likewise.\n\t(Scaling): Likewise.\n\t(Pred): Speed up.\n\t(Succ): Likewise.\n\t(Truncation): Tidy up.\n\t(Valid): Move constants to library level.", "tree": {"sha": "4ff2a0588200a32fe7e68f97b7769bb10835a810", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4ff2a0588200a32fe7e68f97b7769bb10835a810"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f3dd0581a51be1e4354bdcf23f1eee7f5c707a3a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3dd0581a51be1e4354bdcf23f1eee7f5c707a3a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3dd0581a51be1e4354bdcf23f1eee7f5c707a3a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3dd0581a51be1e4354bdcf23f1eee7f5c707a3a/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3cde9f1cc56d7039f44d3cd4f4ebebd02815b8a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cde9f1cc56d7039f44d3cd4f4ebebd02815b8a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3cde9f1cc56d7039f44d3cd4f4ebebd02815b8a9"}], "stats": {"total": 596, "additions": 267, "deletions": 329}, "files": [{"sha": "bebe73748ae7514ccd73d2614524c9af74a9c05b", "filename": "gcc/ada/libgnat/s-fatgen.adb", "status": "modified", "additions": 261, "deletions": 326, "changes": 587, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3dd0581a51be1e4354bdcf23f1eee7f5c707a3a/gcc%2Fada%2Flibgnat%2Fs-fatgen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3dd0581a51be1e4354bdcf23f1eee7f5c707a3a/gcc%2Fada%2Flibgnat%2Fs-fatgen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-fatgen.adb?ref=f3dd0581a51be1e4354bdcf23f1eee7f5c707a3a", "patch": "@@ -29,51 +29,124 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  The implementation here is portable to any IEEE implementation. It does\n---  not handle nonbinary radix, and also assumes that model numbers and\n---  machine numbers are basically identical, which is not true of all possible\n---  floating-point implementations. On a non-IEEE machine, this body must be\n---  specialized appropriately, or better still, its generic instantiations\n---  should be replaced by efficient machine-specific code.\n+--  This implementation is portable to any IEEE implementation. It does not\n+--  handle nonbinary radix, and also assumes that model numbers and machine\n+--  numbers are basically identical, which is not true of all possible\n+--  floating-point implementations.\n \n with Ada.Unchecked_Conversion;\n-with System;\n+with System.Unsigned_Types; use System.Unsigned_Types;\n \n-package body System.Fat_Gen is\n-\n-   Float_Radix        : constant T := T (T'Machine_Radix);\n-   Radix_To_M_Minus_1 : constant T := Float_Radix ** (T'Machine_Mantissa - 1);\n+pragma Warnings (Off, \"non-static constant in preelaborated unit\");\n+--  Every constant is static given our instantiation model\n \n+package body System.Fat_Gen is\n    pragma Assert (T'Machine_Radix = 2);\n    --  This version does not handle radix 16\n \n-   --  Constants for Decompose and Scaling\n+   Rad : constant T := T (T'Machine_Radix);\n+   --  Renaming for the machine radix\n \n-   Rad    : constant T := T (T'Machine_Radix);\n-   Invrad : constant T := 1.0 / Rad;\n+   Mantissa : constant Integer := T'Machine_Mantissa;\n+   --  Renaming for the machine mantissa\n \n-   subtype Expbits is Integer range 0 .. 6;\n-   --  2 ** (2 ** 7) might overflow.  How big can radix-16 exponents get?\n-\n-   Log_Power : constant array (Expbits) of Integer := (1, 2, 4, 8, 16, 32, 64);\n-\n-   R_Power : constant array (Expbits) of T :=\n-     (Rad **  1,\n-      Rad **  2,\n-      Rad **  4,\n-      Rad **  8,\n-      Rad ** 16,\n-      Rad ** 32,\n-      Rad ** 64);\n-\n-   R_Neg_Power : constant array (Expbits) of T :=\n-     (Invrad **  1,\n-      Invrad **  2,\n-      Invrad **  4,\n-      Invrad **  8,\n-      Invrad ** 16,\n-      Invrad ** 32,\n-      Invrad ** 64);\n+   Invrad : constant T := 1.0 / Rad;\n+   --  Smallest positive mantissa in the canonical form (RM A.5.3(4))\n+\n+   Small : constant T := Rad ** (T'Machine_Emin - 1);\n+   pragma Unreferenced (Small);\n+   --  Smallest positive normalized number\n+\n+   Tiny : constant T := Rad ** (T'Machine_Emin - Mantissa);\n+   --  Smallest positive denormalized number\n+\n+   RM1 : constant T := Rad ** (Mantissa - 1);\n+   --  Smallest positive member of the large consecutive integers. It is equal\n+   --  to the ratio Small / Tiny, which means that multiplying by it normalizes\n+   --  any nonzero denormalized number.\n+\n+   IEEE_Emin : constant Integer := T'Machine_Emin - 1;\n+   IEEE_Emax : constant Integer := T'Machine_Emax - 1;\n+   --  The mantissa is a fraction with first digit set in Ada whereas it is\n+   --  shifted by 1 digit to the left in the IEEE floating-point format.\n+\n+   subtype IEEE_Erange is Integer range IEEE_Emin - 1 .. IEEE_Emax + 1;\n+   --  The IEEE floating-point format extends the machine range by 1 to the\n+   --  left for denormalized numbers and 1 to the right for infinities/NaNs.\n+\n+   IEEE_Ebias : constant Integer := -(IEEE_Emin - 1);\n+   --  The exponent is biased such that denormalized numbers have it zero\n+\n+   --  The implementation uses a representation type Float_Rep that allows\n+   --  direct access to exponent and mantissa of the floating point number.\n+\n+   --  The Float_Rep type is a simple array of Float_Word elements. This\n+   --  representation is chosen to make it possible to size the type based\n+   --  on a generic parameter. Since the array size is known at compile\n+   --  time, efficient code can still be generated. The size of Float_Word\n+   --  elements should be large enough to allow accessing the exponent in\n+   --  one read, but small enough so that all floating-point object sizes\n+   --  are a multiple of Float_Word'Size.\n+\n+   --  The following conditions must be met for all possible instantiations\n+   --  of the attribute package:\n+\n+   --    - T'Size is an integral multiple of Float_Word'Size\n+\n+   --    - The exponent and sign are completely contained in a single\n+   --      component of Float_Rep, named Most Significant Word (MSW).\n+\n+   --    - The sign occupies the most significant bit of the MSW and the\n+   --      exponent is in the following bits. The exception is 80-bit\n+   --      double extended, where they occupy the low 16-bit halfword.\n+\n+   --  The low-level primitives Copy_Sign, Decompose, Scaling and Valid are\n+   --  implemented by accessing the bit pattern of the floating-point number.\n+   --  Only the normalization of denormalized numbers, if any, and the gradual\n+   --  underflow are left to the hardware, mainly because there is some leeway\n+   --  for the hardware implementation in this area: for example, the MSB of\n+   --  the mantissa, which is 1 for normalized numbers and 0 for denormalized\n+   --  numbers, may or may not be stored by the hardware.\n+\n+   Siz : constant := (if System.Word_Size > 32 then 32 else System.Word_Size);\n+   type Float_Word is mod 2**Siz;\n+\n+   N : constant Natural := (T'Size + Siz - 1) / Siz;\n+   Rep_Last : constant Natural := Natural'Min (N - 1, (Mantissa + 16) / Siz);\n+   --  Determine the number of Float_Words needed for representing the\n+   --  entire floating-point value. Do not take into account excessive\n+   --  padding, as occurs on IA-64 where 80 bits floats get padded to 128\n+   --  bits. In general, the exponent field cannot be larger than 15 bits,\n+   --  even for 128-bit floating-point types, so the final format size\n+   --  won't be larger than Mantissa + 16.\n+\n+   type Float_Rep is array (Natural range 0 .. N - 1) of Float_Word;\n+   pragma Suppress_Initialization (Float_Rep);\n+   --  This pragma suppresses the generation of an initialization procedure\n+   --  for type Float_Rep when operating in Initialize/Normalize_Scalars mode.\n+\n+   MSW : constant Natural := Rep_Last * Standard'Default_Bit_Order;\n+   --  Finding the location of the Exponent_Word is a bit tricky. In general\n+   --  we assume Word_Order = Bit_Order.\n+\n+   Exp_Factor : constant Float_Word :=\n+                  (if Mantissa = 64\n+                   then 1\n+                   else 2**(Siz - 1) / Float_Word (IEEE_Emax - IEEE_Emin + 3));\n+   --  Factor that the extracted exponent needs to be divided by to be in\n+   --  range 0 .. IEEE_Emax - IEEE_Emin + 2. The special case is 80-bit\n+   --  double extended, where the exponent starts the 3rd float word.\n+\n+   Exp_Mask : constant Float_Word :=\n+                Float_Word (IEEE_Emax - IEEE_Emin + 2) * Exp_Factor;\n+   --  Value needed to mask out the exponent field. This assumes that the\n+   --  range 0 .. IEEE_Emax - IEEE_Emin + 2 contains 2**N values, for some\n+   --  N in Natural.\n+\n+   Sign_Mask : constant Float_Word :=\n+                 (if Mantissa = 64 then 2**15 else 2**(Siz - 1));\n+   --  Value needed to mask out the sign field. The special case is 80-bit\n+   --  double extended, where the exponent starts the 3rd float word.\n \n    -----------------------\n    -- Local Subprograms --\n@@ -85,11 +158,6 @@ package body System.Fat_Gen is\n    --  the sign of the exponent. The absolute value of Frac is in the range\n    --  0.0 <= Frac < 1.0. If Frac = 0.0 or -0.0, then Expo is always zero.\n \n-   function Gradual_Scaling (Adjustment : UI) return T;\n-   --  Like Scaling with a first argument of 1.0, but returns the smallest\n-   --  denormal rather than zero when the adjustment is smaller than\n-   --  Machine_Emin. Used for Succ and Pred.\n-\n    --------------\n    -- Adjacent --\n    --------------\n@@ -139,114 +207,76 @@ package body System.Fat_Gen is\n    ---------------\n \n    function Copy_Sign (Value, Sign : T) return T is\n-      Result : T;\n+      S : constant T := T'Machine (Sign);\n \n-      function Is_Negative (V : T) return Boolean;\n-      pragma Import (Intrinsic, Is_Negative);\n+      Rep_S : Float_Rep;\n+      for Rep_S'Address use S'Address;\n+      --  Rep_S is a view of the Sign parameter\n \n-   begin\n-      Result := abs Value;\n+      V : T := T'Machine (Value);\n \n-      if Is_Negative (Sign) then\n-         return -Result;\n-      else\n-         return Result;\n-      end if;\n+      Rep_V : Float_Rep;\n+      for Rep_V'Address use V'Address;\n+      --  Rep_V is a view of the Value parameter\n+\n+   begin\n+      Rep_V (MSW) :=\n+        (Rep_V (MSW) and not Sign_Mask) or (Rep_S (MSW) and Sign_Mask);\n+      return V;\n    end Copy_Sign;\n \n    ---------------\n    -- Decompose --\n    ---------------\n \n    procedure Decompose (XX : T; Frac : out T; Expo : out UI) is\n-      X : constant T := T'Machine (XX);\n-\n-   begin\n-      if X = 0.0 then\n-\n-         --  The normalized exponent of zero is zero, see RM A.5.2(15)\n+      X : T := T'Machine (XX);\n \n-         Frac := X;\n-         Expo := 0;\n-\n-      --  Check for infinities, transfinites, whatnot\n+      Rep : Float_Rep;\n+      for Rep'Address use X'Address;\n+      --  Rep is a view of the input floating-point parameter\n \n-      elsif X > T'Safe_Last then\n-         Frac := Invrad;\n-         pragma Annotate (CodePeer, Intentional, \"dead code\",\n-                          \"Check float range.\");\n-         Expo := T'Machine_Emax + 1;\n+      Exp : constant IEEE_Erange :=\n+              Integer ((Rep (MSW) and Exp_Mask) / Exp_Factor) - IEEE_Ebias;\n+      --  Mask/Shift X to only get bits from the exponent. Then convert biased\n+      --  value to final value.\n \n-      elsif X < T'Safe_First then\n-         Frac := -Invrad;\n-         pragma Annotate (CodePeer, Intentional, \"dead code\",\n-                          \"Check float range.\");\n-         Expo := T'Machine_Emax + 2;    -- how many extra negative values?\n+      Minus : constant Boolean := (Rep (MSW) and Sign_Mask) /= 0;\n+      --  Mask/Shift X to only get bit from the sign\n \n-      else\n-         --  Case of nonzero finite x. Essentially, we just multiply\n-         --  by Rad ** (+-2**N) to reduce the range.\n+   begin\n+      --  The normalized exponent of zero is zero, see RM A.5.3(15)\n \n-         declare\n-            Ax : T  := abs X;\n-            Ex : UI := 0;\n+      if X = 0.0 then\n+         Expo := 0;\n+         Frac := X;\n \n-         --  Ax * Rad ** Ex is invariant\n+      --  Check for infinities and NaNs\n \n-         begin\n-            if Ax >= 1.0 then\n-               while Ax >= R_Power (Expbits'Last) loop\n-                  Ax := Ax * R_Neg_Power (Expbits'Last);\n-                  Ex := Ex + Log_Power (Expbits'Last);\n-               end loop;\n+      elsif Exp = IEEE_Emax + 1 then\n+         Expo := T'Machine_Emax + 1;\n+         Frac := (if Minus then -Invrad else Invrad);\n \n-               --  Ax < Rad ** 64\n+      --  Check for nonzero denormalized numbers\n \n-               for N in reverse Expbits'First .. Expbits'Last - 1 loop\n-                  if Ax >= R_Power (N) then\n-                     Ax := Ax * R_Neg_Power (N);\n-                     Ex := Ex + Log_Power (N);\n-                  end if;\n+      elsif Exp = IEEE_Emin - 1 then\n+         --  Normalize by multiplying by Radix ** (Mantissa - 1)\n \n-                  --  Ax < R_Power (N)\n+         Decompose (X * RM1, Frac, Expo);\n+         Expo := Expo - (Mantissa - 1);\n \n-               end loop;\n+      --  Case of normalized numbers\n \n-               --  1 <= Ax < Rad\n+      else\n+         --  The Ada exponent is the IEEE exponent plus 1, see above\n \n-               Ax := Ax * Invrad;\n-               Ex := Ex + 1;\n+         Expo := Exp + 1;\n \n-            else\n-               --  0 < ax < 1\n-\n-               while Ax < R_Neg_Power (Expbits'Last) loop\n-                  Ax := Ax * R_Power (Expbits'Last);\n-                  pragma Annotate (CodePeer, Intentional, \"dead code\",\n-                                   \"Check float range.\");\n-                  Ex := Ex - Log_Power (Expbits'Last);\n-               end loop;\n-               pragma Annotate\n-                 (CodePeer, Intentional,\n-                  \"test always false\",\n-                  \"expected for some instantiations\");\n-\n-               --  Rad ** -64 <= Ax < 1\n-\n-               for N in reverse Expbits'First .. Expbits'Last - 1 loop\n-                  if Ax < R_Neg_Power (N) then\n-                     Ax := Ax * R_Power (N);\n-                     Ex := Ex - Log_Power (N);\n-                  end if;\n-\n-                  --  R_Neg_Power (N) <= Ax < 1\n-\n-               end loop;\n-            end if;\n+         --  Set Ada exponent of X to zero, so we end up with the fraction\n \n-            Frac := (if X > 0.0 then Ax else -Ax);\n-            Expo := Ex;\n-         end;\n+         Rep (MSW) := (Rep (MSW) and not Exp_Mask) +\n+                        Float_Word (IEEE_Ebias - 1) * Exp_Factor;\n+         Frac := X;\n       end if;\n    end Decompose;\n \n@@ -292,38 +322,6 @@ package body System.Fat_Gen is\n       return X_Frac;\n    end Fraction;\n \n-   ---------------------\n-   -- Gradual_Scaling --\n-   ---------------------\n-\n-   function Gradual_Scaling  (Adjustment : UI) return T is\n-      Y  : T;\n-      Y1 : T;\n-      Ex : UI := Adjustment;\n-\n-   begin\n-      if Adjustment < T'Machine_Emin - 1 then\n-         Y  := 2.0 ** T'Machine_Emin;\n-         Y1 := Y;\n-         Ex := Ex - T'Machine_Emin;\n-         while Ex < 0 loop\n-            Y := T'Machine (Y / 2.0);\n-\n-            if Y = 0.0 then\n-               return Y1;\n-            end if;\n-\n-            Ex := Ex + 1;\n-            Y1 := Y;\n-         end loop;\n-\n-         return Y1;\n-\n-      else\n-         return Scaling (1.0, Adjustment);\n-      end if;\n-   end Gradual_Scaling;\n-\n    ------------------\n    -- Leading_Part --\n    ------------------\n@@ -333,7 +331,7 @@ package body System.Fat_Gen is\n       Y, Z : T;\n \n    begin\n-      if Radix_Digits >= T'Machine_Mantissa then\n+      if Radix_Digits >= Mantissa then\n          return X;\n \n       elsif Radix_Digits <= 0 then\n@@ -420,12 +418,11 @@ package body System.Fat_Gen is\n       --  Zero has to be treated specially, since its exponent is zero\n \n       if X = 0.0 then\n-         return -Succ (X);\n+         return -Tiny;\n \n-      --  Special treatment for most negative number\n+      --  Special treatment for largest negative number: raise Constraint_Error\n \n       elsif X = T'First then\n-\n          raise Constraint_Error with \"Pred of largest negative number\";\n \n       --  For infinities, return unchanged\n@@ -439,28 +436,33 @@ package body System.Fat_Gen is\n \n       --  Subtract from the given number a number equivalent to the value\n       --  of its least significant bit. Given that the most significant bit\n-      --  represents a value of 1.0 * radix ** (exp - 1), the value we want\n-      --  is obtained by shifting this by (mantissa-1) bits to the right,\n+      --  represents a value of 1.0 * Radix ** (Exp - 1), the value we want\n+      --  is obtained by shifting this by (Mantissa-1) bits to the right,\n       --  i.e. decreasing the exponent by that amount.\n \n       else\n          Decompose (X, X_Frac, X_Exp);\n \n-         --  A special case, if the number we had was a positive power of\n-         --  two, then we want to subtract half of what we would otherwise\n-         --  subtract, since the exponent is going to be reduced.\n+         --  For a denormalized number or a normalized number with the lowest\n+         --  exponent, just subtract the Tiny.\n+\n+         if X_Exp <= T'Machine_Emin then\n+            return X - Tiny;\n \n-         --  Note that X_Frac has the same sign as X, so if X_Frac is 0.5,\n-         --  then we know that we have a positive number (and hence a\n-         --  positive power of 2).\n+         --  A special case, if the number we had was a power of two on the\n+         --  positive side of zero, then we want to subtract half of what we\n+         --  would have subtracted, since the exponent is going to be reduced.\n \n-         if X_Frac = 0.5 then\n-            return X - Gradual_Scaling (X_Exp - T'Machine_Mantissa - 1);\n+         --  Note that X_Frac has the same sign as X so, if X_Frac is Invrad,\n+         --  then we know that we had a power of two on the positive side.\n \n-         --  Otherwise the exponent is unchanged\n+         elsif X_Frac = Invrad then\n+            return X - Scaling (1.0, X_Exp - Mantissa - 1);\n+\n+         --  Otherwise the adjustment is unchanged\n \n          else\n-            return X - Gradual_Scaling (X_Exp - T'Machine_Mantissa);\n+            return X - Scaling (1.0, X_Exp - Mantissa);\n          end if;\n       end if;\n    end Pred;\n@@ -580,70 +582,90 @@ package body System.Fat_Gen is\n    -- Scaling --\n    -------------\n \n-   --  Return x * rad ** adjustment quickly, or quietly underflow to zero,\n-   --  or overflow naturally.\n-\n    function Scaling (X : T; Adjustment : UI) return T is\n+      pragma Assert (Mantissa <= 64);\n+      --  This implementation handles only 80-bit IEEE Extended or smaller\n+\n+      XX : T := T'Machine (X);\n+\n+      Rep : Float_Rep;\n+      for Rep'Address use XX'Address;\n+      --  Rep is a view of the input floating-point parameter\n+\n+      Exp : constant IEEE_Erange :=\n+              Integer ((Rep (MSW) and Exp_Mask) / Exp_Factor) - IEEE_Ebias;\n+      --  Mask/Shift X to only get bits from the exponent. Then convert biased\n+      --  value to final value.\n+\n+      Minus : constant Boolean := (Rep (MSW) and Sign_Mask) /= 0;\n+      --  Mask/Shift X to only get bit from the sign\n+\n+      Expi, Expf : IEEE_Erange;\n+\n    begin\n-      if X = 0.0 or else Adjustment = 0 then\n+      --  Check for zero, infinities, NaNs as well as no adjustment\n+\n+      if X = 0.0 or else Exp = IEEE_Emax + 1 or else Adjustment = 0 then\n          return X;\n-      end if;\n \n-      --  Nonzero x essentially, just multiply repeatedly by Rad ** (+-2**n)\n+      --  Check for nonzero denormalized numbers\n \n-      declare\n-         Y  : T  := X;\n-         Ex : UI := Adjustment;\n+      elsif Exp = IEEE_Emin - 1 then\n+         --  Check for zero result to protect the subtraction below\n \n-      --  Y * Rad ** Ex is invariant\n+         if Adjustment < -(Mantissa - 1) then\n+            XX := 0.0;\n+            return (if Minus then -XX else XX);\n \n-      begin\n-         if Ex < 0 then\n-            while Ex <= -Log_Power (Expbits'Last) loop\n-               Y := Y * R_Neg_Power (Expbits'Last);\n-               Ex := Ex + Log_Power (Expbits'Last);\n-            end loop;\n+         --  Normalize by multiplying by Radix ** (Mantissa - 1)\n \n-            --  -64 < Ex <= 0\n+         else\n+            return Scaling (XX * RM1, Adjustment - (Mantissa - 1));\n+         end if;\n \n-            for N in reverse Expbits'First .. Expbits'Last - 1 loop\n-               if Ex <= -Log_Power (N) then\n-                  Y := Y * R_Neg_Power (N);\n-                  Ex := Ex + Log_Power (N);\n-               end if;\n+      --  Case of normalized numbers\n \n-               --  -Log_Power (N) < Ex <= 0\n+      else\n+         --  Check for overflow\n \n-            end loop;\n+         if Adjustment > IEEE_Emax - Exp then\n+            XX := 0.0;\n+            return (if Minus then -1.0 / XX else 1.0 / XX);\n \n-            --  Ex = 0\n+         --  Check for underflow\n \n-         else\n-            --  Ex >= 0\n+         elsif Adjustment < IEEE_Emin - Exp then\n+            --  Check for gradual underflow\n \n-            while Ex >= Log_Power (Expbits'Last) loop\n-               Y := Y * R_Power (Expbits'Last);\n-               Ex := Ex - Log_Power (Expbits'Last);\n-            end loop;\n+            if T'Denorm\n+              and then Adjustment >= IEEE_Emin - (Mantissa - 1) - Exp\n+            then\n+               Expf := IEEE_Emin;\n+               Expi := Exp + Adjustment - Expf;\n \n-            --  0 <= Ex < 64\n+            --  Case of zero result\n \n-            for N in reverse Expbits'First .. Expbits'Last - 1 loop\n-               if Ex >= Log_Power (N) then\n-                  Y := Y * R_Power (N);\n-                  Ex := Ex - Log_Power (N);\n-               end if;\n+            else\n+               XX := 0.0;\n+               return (if Minus then -XX else XX);\n+            end if;\n \n-               --  0 <= Ex < Log_Power (N)\n+         --  Case of normalized results\n \n-            end loop;\n+         else\n+            Expf := Exp + Adjustment;\n+            Expi := 0;\n+         end if;\n \n-            --  Ex = 0\n+         Rep (MSW) := (Rep (MSW) and not Exp_Mask) +\n+                        Float_Word (IEEE_Ebias + Expf) * Exp_Factor;\n \n+         if Expi < 0 then\n+            XX := XX / T (Long_Long_Unsigned (2) ** (-Expi));\n          end if;\n \n-         return Y;\n-      end;\n+         return XX;\n+      end if;\n    end Scaling;\n \n    ----------\n@@ -653,34 +675,18 @@ package body System.Fat_Gen is\n    function Succ (X : T) return T is\n       X_Frac : T;\n       X_Exp  : UI;\n-      X1, X2 : T;\n \n    begin\n       --  Treat zero specially since it has a zero exponent\n \n       if X = 0.0 then\n-         X1 := 2.0 ** T'Machine_Emin;\n+         return Tiny;\n \n-         --  Following loop generates smallest denormal\n-\n-         loop\n-            X2 := T'Machine (X1 / 2.0);\n-            exit when X2 = 0.0;\n-            X1 := X2;\n-         end loop;\n-\n-         return X1;\n-\n-      --  Special treatment for largest positive number\n+      --  Special treatment for largest positive number: raise Constraint_Error\n \n       elsif X = T'Last then\n-\n-         --  If not generating infinities, we raise a constraint error\n-\n          raise Constraint_Error with \"Succ of largest positive number\";\n \n-         --  Otherwise generate a positive infinity\n-\n       --  For infinities, return unchanged\n \n       elsif X < T'First or else X > T'Last then\n@@ -690,30 +696,35 @@ package body System.Fat_Gen is\n          pragma Annotate (CodePeer, Intentional, \"dead code\",\n                           \"Check float range.\");\n \n-      --  Add to the given number a number equivalent to the value\n-      --  of its least significant bit. Given that the most significant bit\n-      --  represents a value of 1.0 * radix ** (exp - 1), the value we want\n-      --  is obtained by shifting this by (mantissa-1) bits to the right,\n+      --  Add to the given number a number equivalent to the value of its\n+      --  least significant bit. Given that the most significant bit\n+      --  represents a value of 1.0 * Radix ** (Exp - 1), the value we want\n+      --  is obtained by shifting this by (Mantissa-1) bits to the right,\n       --  i.e. decreasing the exponent by that amount.\n \n       else\n          Decompose (X, X_Frac, X_Exp);\n \n-         --  A special case, if the number we had was a negative power of two,\n-         --  then we want to add half of what we would otherwise add, since the\n-         --  exponent is going to be reduced.\n+         --  For a denormalized number or a normalized number with the lowest\n+         --  exponent, just add the Tiny.\n+\n+         if X_Exp <= T'Machine_Emin then\n+            return X + Tiny;\n \n-         --  Note that X_Frac has the same sign as X, so if X_Frac is -0.5,\n-         --  then we know that we have a negative number (and hence a negative\n-         --  power of 2).\n+         --  A special case, if the number we had was a power of two on the\n+         --  negative side of zero, then we want to add half of what we would\n+         --  have added, since the exponent is going to be reduced.\n \n-         if X_Frac = -0.5 then\n-            return X + Gradual_Scaling (X_Exp - T'Machine_Mantissa - 1);\n+         --  Note that X_Frac has the same sign as X, so if X_Frac is -Invrad,\n+         --  then we know that we had a power of two on the negative side.\n \n-         --  Otherwise the exponent is unchanged\n+         elsif X_Frac = -Invrad then\n+            return X + Scaling (1.0, X_Exp - Mantissa - 1);\n+\n+         --  Otherwise the adjustment is unchanged\n \n          else\n-            return X + Gradual_Scaling (X_Exp - T'Machine_Mantissa);\n+            return X + Scaling (1.0, X_Exp - Mantissa);\n          end if;\n       end if;\n    end Succ;\n@@ -726,7 +737,7 @@ package body System.Fat_Gen is\n \n    --    T'Machine (RM1 + N) - RM1\n \n-   --  where N >= 0.0 and RM1 = radix ** (mantissa - 1)\n+   --  where N >= 0.0 and RM1 = Radix ** (Mantissa - 1)\n \n    --  This works provided that the intermediate result (RM1 + N) does not\n    --  have extra precision (which is why we call Machine). When we compute\n@@ -743,19 +754,18 @@ package body System.Fat_Gen is\n    begin\n       Result := abs X;\n \n-      if Result >= Radix_To_M_Minus_1 then\n+      if Result >= RM1 then\n          return T'Machine (X);\n \n       else\n-         Result :=\n-           T'Machine (Radix_To_M_Minus_1 + Result) - Radix_To_M_Minus_1;\n+         Result := T'Machine (RM1 + Result) - RM1;\n \n          if Result > abs X then\n             Result := Result - 1.0;\n          end if;\n \n          if X > 0.0 then\n-            return  Result;\n+            return Result;\n \n          elsif X < 0.0 then\n             return -Result;\n@@ -806,86 +816,11 @@ package body System.Fat_Gen is\n    -----------\n \n    function Valid (X : not null access T) return Boolean is\n-      IEEE_Emin : constant Integer := T'Machine_Emin - 1;\n-      IEEE_Emax : constant Integer := T'Machine_Emax - 1;\n-      --  The mantissa is a fraction with first digit set in Ada whereas it is\n-      --  shifted by 1 digit to the left in the IEEE floating-point format.\n-\n-      subtype IEEE_Erange is Integer range IEEE_Emin - 1 .. IEEE_Emax + 1;\n-      --  The IEEE floating-point format extends the machine range by 1 to the\n-      --  left for denormalized numbers and 1 to the right for infinities/NaNs.\n-\n-      IEEE_Ebias : constant Integer := -(IEEE_Emin - 1);\n-      --  The exponent is biased such that denormalized numbers have it zero\n-\n-      --  The implementation uses a representation type Float_Rep that allows\n-      --  direct access to exponent and mantissa of the floating point number.\n-\n-      --  The Float_Rep type is a simple array of Float_Word elements. This\n-      --  representation is chosen to make it possible to size the type based\n-      --  on a generic parameter. Since the array size is known at compile\n-      --  time, efficient code can still be generated. The size of Float_Word\n-      --  elements should be large enough to allow accessing the exponent in\n-      --  one read, but small enough so that all floating-point object sizes\n-      --  are a multiple of Float_Word'Size.\n-\n-      --  The following conditions must be met for all possible instantiations\n-      --  of the attribute package:\n-\n-      --    - T'Size is an integral multiple of Float_Word'Size\n-\n-      --    - The exponent and sign are completely contained in a single\n-      --      component of Float_Rep, named Most Significant Word (MSW).\n-\n-      --    - The sign occupies the most significant bit of the MSW and the\n-      --      exponent is in the following bits. The exception is 80-bit\n-      --      double extended, where they occupy the low 16-bit halfword.\n-\n-      Siz : constant :=\n-              (if System.Word_Size > 32 then 32 else System.Word_Size);\n-      type Float_Word is mod 2**Siz;\n-\n-      N : constant Natural := (T'Size + Siz - 1) / Siz;\n-      Rep_Last : constant Natural :=\n-                   Natural'Min (N - 1, (T'Machine_Mantissa + 16) / Siz);\n-      --  Determine the number of Float_Words needed for representing the\n-      --  entire floating-point value. Do not take into account excessive\n-      --  padding, as occurs on IA-64 where 80 bits floats get padded to 128\n-      --  bits. In general, the exponent field cannot be larger than 15 bits,\n-      --  even for 128-bit floating-point types, so the final format size\n-      --  won't be larger than T'Machine_Mantissa + 16.\n-\n-      type Float_Rep is array (Natural range 0 .. N - 1) of Float_Word;\n-      pragma Suppress_Initialization (Float_Rep);\n-      --  This pragma suppresses the generation of an initialization procedure\n-      --  for type Float_Rep when operating in Initialize/Normalize_Scalars\n-      --  mode, which would be annoying since Valid has got a pragma Inline.\n-\n-      MSW : constant Natural := Rep_Last * Standard'Default_Bit_Order;\n-      --  Finding the location of the Exponent_Word is a bit tricky. In general\n-      --  we assume Word_Order = Bit_Order.\n-\n-      Exp_Factor : constant Float_Word :=\n-                     (if T'Machine_Mantissa = 64\n-                       then 1\n-                       else 2**(Siz - 1) /\n-                              Float_Word (IEEE_Emax - IEEE_Emin + 3));\n-      --  Factor that the extracted exponent needs to be divided by to be in\n-      --  range 0 .. IEEE_Emax - IEEE_Emin + 2. The special case is 80-bit\n-      --  double extended, where the exponent starts the 3rd float word.\n-\n-      Exp_Mask : constant Float_Word :=\n-                   Float_Word (IEEE_Emax - IEEE_Emin + 2) * Exp_Factor;\n-      --  Value needed to mask out the exponent field. This assumes that the\n-      --  range 0 .. IEEE_Emax - IEEE_Emin + 2 contains 2**N values, for some\n-      --  N in Natural.\n-\n       type Access_T is access all T;\n       function To_Address is\n         new Ada.Unchecked_Conversion (Access_T, System.Address);\n \n       Rep : Float_Rep;\n-      pragma Import (Ada, Rep);\n       for Rep'Address use To_Address (Access_T (X));\n       --  Rep is a view of the input floating-point parameter. Note that we\n       --  must avoid reading the actual bits of this parameter in float form"}, {"sha": "700cfdc027d881a074c6d02bea14b9ef39672467", "filename": "gcc/ada/libgnat/s-fatgen.ads", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3dd0581a51be1e4354bdcf23f1eee7f5c707a3a/gcc%2Fada%2Flibgnat%2Fs-fatgen.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3dd0581a51be1e4354bdcf23f1eee7f5c707a3a/gcc%2Fada%2Flibgnat%2Fs-fatgen.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-fatgen.ads?ref=f3dd0581a51be1e4354bdcf23f1eee7f5c707a3a", "patch": "@@ -31,9 +31,8 @@\n \n --  This generic package provides a target independent implementation of the\n --  floating-point attributes that denote functions. The implementations here\n---  are portable, but very slow. The runtime contains a set of instantiations\n---  of this package for all predefined floating-point types, and these should\n---  be replaced by efficient assembly language code where possible.\n+--  should be portable and reasonably efficient. The runtime contains a set of\n+--  instantiations of this package for all predefined floating-point types.\n \n generic\n     type T is digits <>;\n@@ -107,6 +106,10 @@ package System.Fat_Gen is\n    --  floating point register).\n \n private\n+   pragma Inline (Compose);\n+   pragma Inline (Copy_Sign);\n+   pragma Inline (Exponent);\n+   pragma Inline (Fraction);\n    pragma Inline (Machine);\n    pragma Inline (Model);\n    pragma Inline (Valid);"}]}