{"sha": "3aceff0d36536f9136f1b3a957e6f7da1d19b41a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2FjZWZmMGQzNjUzNmY5MTM2ZjFiM2E5NTdlNmY3ZGExZDE5YjQxYQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-06-27T23:42:23Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-06-27T23:42:23Z"}, "message": "(force_to_mode, case NE): Fix typo and logical error.\n\n(simplify_comparison): Don't swap args if op1 is CONST_INT.\n\nFrom-SVN: r12339", "tree": {"sha": "05f8a6a5a24b13b1080f27746c351a0a34e8fc4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/05f8a6a5a24b13b1080f27746c351a0a34e8fc4e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3aceff0d36536f9136f1b3a957e6f7da1d19b41a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3aceff0d36536f9136f1b3a957e6f7da1d19b41a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3aceff0d36536f9136f1b3a957e6f7da1d19b41a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3aceff0d36536f9136f1b3a957e6f7da1d19b41a/comments", "author": null, "committer": null, "parents": [{"sha": "f8fe20b224e983e7cb930a04ed6b574cf0f01d60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8fe20b224e983e7cb930a04ed6b574cf0f01d60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8fe20b224e983e7cb930a04ed6b574cf0f01d60"}], "stats": {"total": 12, "additions": 7, "deletions": 5}, "files": [{"sha": "e3c8a17b4119a24462de57a641c1638a8359ad3d", "filename": "gcc/combine.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aceff0d36536f9136f1b3a957e6f7da1d19b41a/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aceff0d36536f9136f1b3a957e6f7da1d19b41a/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=3aceff0d36536f9136f1b3a957e6f7da1d19b41a", "patch": "@@ -6231,9 +6231,10 @@ force_to_mode (x, mode, mask, reg, just_select)\n \n     case NE:\n       /* (and (ne FOO 0) CONST) can be (and FOO CONST) if CONST is included\n-\t in STORE_FLAG_VALUE and FOO has no bits that might be nonzero not\n-\t in CONST.  */\n-      if ((mask & ~ STORE_FLAG_VALUE) == 0 && XEXP (x, 0) == const0_rtx\n+\t in STORE_FLAG_VALUE and FOO has a single bit that might be nonzero,\n+\t which is in CONST.  */\n+      if ((mask & ~ STORE_FLAG_VALUE) == 0 && XEXP (x, 1) == const0_rtx\n+\t  && exact_log2 (nonzero_bits (XEXP (x, 0), mode)) >= 0\n \t  && (nonzero_bits (XEXP (x, 0), mode) & ~ mask) == 0)\n \treturn force_to_mode (XEXP (x, 0), mode, mask, reg, next_select);\n \n@@ -8992,8 +8993,9 @@ simplify_comparison (code, pop0, pop1)\n     }\n      \n   /* If the first operand is a constant, swap the operands and adjust the\n-     comparison code appropriately.  */\n-  if (CONSTANT_P (op0))\n+     comparison code appropriately, but don't do this if the second operand\n+     is already a constant integer.  */\n+  if (CONSTANT_P (op0) && GET_CODE (op1) != CONST_INT)\n     {\n       tem = op0, op0 = op1, op1 = tem;\n       code = swap_condition (code);"}]}