{"sha": "91b30ee5b9c83187fe1d7459cbd29abe302d60ed", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTFiMzBlZTViOWM4MzE4N2ZlMWQ3NDU5Y2JkMjlhYmUzMDJkNjBlZA==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2006-08-15T23:06:44Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2006-08-15T23:06:44Z"}, "message": "re PR fortran/25828 ([f2003] ACCESS='STREAM' io support)\n\n2006-08-15  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\tPR libgfortran/25828\n\t* libgfortran.h: Rename GFC_LARGE_IO_INT to GFC_IO_INT.\n\t* io/file_pos.c (st_backspace): Ignore if access=STREAM.\n\t(st_rewind): Handle case of access=STREAM.\n\t* io/open.c (access_opt): Add STREAM_ACCESS.\n\t(edit_modes): Set current_record to zero only if not STREAM.\n\t(new_unit): Initialize maxrec, recl, and last_record for STREAM.\n\t* io/read.c (read_x): Advance file position for STREAM.\n\t* io/io.h (enum unit_access): Align IOPARM flags with frontend.\n\tAdd ACCESS_STREAM. Add prototype for is_stream_io () function.\n\tUse GFC_IO_INT.\n\t* io/inquire.c (inquire_via_unit): Add text for access = \"STREAM\".\n\t* io/unit.c (is_stream_io): New function to return true if access =\n\tSTREAM.\n\t* io/transfer.c (file_mode): Add modes for unformatted stream and\n\tformatted stream. (current_mode): Return appropriate file mode based\n\ton access flags.\n\t(read_block): Handle formatted stream reads.\n\t(read_block_direct): Handle unformatted stream reads.\n\t(write_block): Handle formatted stream writes.\n\t(write_buf): Handle unformatted stream writes.\n\t(unformatted_read): Fix up, use temporary for size.\n\t(pre_position): Position file for STREAM access.\n\t(data_transfer_init): Initialize for stream access, skip irrelevent\n\terror checks.\n\t(next_record_r),(next_record_w), and (next_record): Do nothing for\n\tstream I/O.\n\t(finalize_transfer): Flush when all done if stream I/O.\n\nFrom-SVN: r116172", "tree": {"sha": "a00eb1bf11f7cace4d681ea98e21b7e72e529de0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a00eb1bf11f7cace4d681ea98e21b7e72e529de0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/91b30ee5b9c83187fe1d7459cbd29abe302d60ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91b30ee5b9c83187fe1d7459cbd29abe302d60ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91b30ee5b9c83187fe1d7459cbd29abe302d60ed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91b30ee5b9c83187fe1d7459cbd29abe302d60ed/comments", "author": null, "committer": null, "parents": [{"sha": "014ec6ee5fcb77e38dca4a6f272349f4859b03c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/014ec6ee5fcb77e38dca4a6f272349f4859b03c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/014ec6ee5fcb77e38dca4a6f272349f4859b03c5"}], "stats": {"total": 490, "additions": 336, "deletions": 154}, "files": [{"sha": "773f80636dbe0104da39d0dc7f026faad1f670ef", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91b30ee5b9c83187fe1d7459cbd29abe302d60ed/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91b30ee5b9c83187fe1d7459cbd29abe302d60ed/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=91b30ee5b9c83187fe1d7459cbd29abe302d60ed", "patch": "@@ -1,3 +1,34 @@\n+2006-08-15  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR libgfortran/25828\n+\t* libgfortran.h: Rename GFC_LARGE_IO_INT to GFC_IO_INT.\n+\t* io/file_pos.c (st_backspace): Ignore if access=STREAM.\n+\t(st_rewind): Handle case of access=STREAM.\n+\t* io/open.c (access_opt): Add STREAM_ACCESS.\n+\t(edit_modes): Set current_record to zero only if not STREAM.\n+\t(new_unit): Initialize maxrec, recl, and last_record for STREAM.\n+\t* io/read.c (read_x): Advance file position for STREAM.\n+\t* io/io.h (enum unit_access): Align IOPARM flags with frontend.\n+\tAdd ACCESS_STREAM. Add prototype for is_stream_io () function.\n+\tUse GFC_IO_INT.\n+\t* io/inquire.c (inquire_via_unit): Add text for access = \"STREAM\".\n+\t* io/unit.c (is_stream_io): New function to return true if access =\n+\tSTREAM.\n+\t* io/transfer.c (file_mode): Add modes for unformatted stream and\n+\tformatted stream. (current_mode): Return appropriate file mode based\n+\ton access flags.\n+\t(read_block): Handle formatted stream reads.\n+\t(read_block_direct): Handle unformatted stream reads.\n+\t(write_block): Handle formatted stream writes.\n+\t(write_buf): Handle unformatted stream writes.\n+\t(unformatted_read): Fix up, use temporary for size.\n+\t(pre_position): Position file for STREAM access.\n+\t(data_transfer_init): Initialize for stream access, skip irrelevent\n+\terror checks.\n+\t(next_record_r),(next_record_w), and (next_record): Do nothing for\n+\tstream I/O.\n+\t(finalize_transfer): Flush when all done if stream I/O.\n+\n 2006-08-12  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n \n \t* intrinsics/bessel.c: Add prototypes for all functions."}, {"sha": "3f6a332d979989f07ab2817a4def5a0affe7db8e", "filename": "libgfortran/io/file_pos.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91b30ee5b9c83187fe1d7459cbd29abe302d60ed/libgfortran%2Fio%2Ffile_pos.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91b30ee5b9c83187fe1d7459cbd29abe302d60ed/libgfortran%2Fio%2Ffile_pos.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ffile_pos.c?ref=91b30ee5b9c83187fe1d7459cbd29abe302d60ed", "patch": "@@ -205,7 +205,7 @@ st_backspace (st_parameter_filepos *fpp)\n      sequential I/O and the next direct access transfer repositions the file \n      anyway.  */\n \n-  if (u->flags.access == ACCESS_DIRECT)\n+  if (u->flags.access == ACCESS_DIRECT || u->flags.access == ACCESS_STREAM)\n     goto done;\n \n   /* Check for special cases involving the ENDFILE record first.  */\n@@ -291,7 +291,7 @@ st_rewind (st_parameter_filepos *fpp)\n   u = find_unit (fpp->common.unit);\n   if (u != NULL)\n     {\n-      if (u->flags.access != ACCESS_SEQUENTIAL)\n+      if (u->flags.access == ACCESS_DIRECT)\n \tgenerate_error (&fpp->common, ERROR_BAD_OPTION,\n \t\t\t\"Cannot REWIND a file opened for DIRECT access\");\n       else\n@@ -301,7 +301,7 @@ st_rewind (st_parameter_filepos *fpp)\n \t       file now.  Reset to read mode so two consecutive rewind\n \t       statements do not delete the file contents.  */\n \t  flush (u->s);\n-\t  if (u->mode == WRITING)\n+\t  if (u->mode == WRITING && u->flags.access != ACCESS_STREAM)\n \t    struncate (u->s);\n \n \t  u->mode = READING;"}, {"sha": "8a24f498575d79336299bfbec4c5680a12064219", "filename": "libgfortran/io/inquire.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91b30ee5b9c83187fe1d7459cbd29abe302d60ed/libgfortran%2Fio%2Finquire.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91b30ee5b9c83187fe1d7459cbd29abe302d60ed/libgfortran%2Fio%2Finquire.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Finquire.c?ref=91b30ee5b9c83187fe1d7459cbd29abe302d60ed", "patch": "@@ -75,6 +75,9 @@ inquire_via_unit (st_parameter_inquire *iqp, gfc_unit * u)\n \t  case ACCESS_DIRECT:\n \t    p = \"DIRECT\";\n \t    break;\n+\t  case ACCESS_STREAM:\n+\t    p = \"STREAM\";\n+\t    break;\n \t  default:\n \t    internal_error (&iqp->common, \"inquire_via_unit(): Bad access\");\n \t  }\n@@ -145,6 +148,9 @@ inquire_via_unit (st_parameter_inquire *iqp, gfc_unit * u)\n   if ((cf & IOPARM_INQUIRE_HAS_RECL_OUT) != 0)\n     *iqp->recl_out = (u != NULL) ? u->recl : 0;\n \n+  if ((cf & IOPARM_INQUIRE_HAS_STRM_POS_OUT) != 0)\n+    *iqp->strm_pos_out = (u != NULL) ? u->last_record : 0;\n+\n   if ((cf & IOPARM_INQUIRE_HAS_NEXTREC) != 0)\n     *iqp->nextrec = (u != NULL) ? u->last_record + 1 : 0;\n "}, {"sha": "fba0ae83991437fc15d4d3bf93a9aa34a007e142", "filename": "libgfortran/io/io.h", "status": "modified", "additions": 24, "deletions": 19, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91b30ee5b9c83187fe1d7459cbd29abe302d60ed/libgfortran%2Fio%2Fio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91b30ee5b9c83187fe1d7459cbd29abe302d60ed/libgfortran%2Fio%2Fio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fio.h?ref=91b30ee5b9c83187fe1d7459cbd29abe302d60ed", "patch": "@@ -156,7 +156,7 @@ namelist_info;\n /* Options for the OPEN statement.  */\n \n typedef enum\n-{ ACCESS_SEQUENTIAL, ACCESS_DIRECT, ACCESS_APPEND,\n+{ ACCESS_SEQUENTIAL, ACCESS_DIRECT, ACCESS_APPEND, ACCESS_STREAM,\n   ACCESS_UNSPECIFIED\n }\n unit_access;\n@@ -290,29 +290,31 @@ st_parameter_filepos;\n #define IOPARM_INQUIRE_HAS_NAMED\t(1 << 10)\n #define IOPARM_INQUIRE_HAS_NEXTREC\t(1 << 11)\n #define IOPARM_INQUIRE_HAS_RECL_OUT\t(1 << 12)\n-#define IOPARM_INQUIRE_HAS_FILE\t\t(1 << 13)\n-#define IOPARM_INQUIRE_HAS_ACCESS\t(1 << 14)\n-#define IOPARM_INQUIRE_HAS_FORM\t\t(1 << 15)\n-#define IOPARM_INQUIRE_HAS_BLANK\t(1 << 16)\n-#define IOPARM_INQUIRE_HAS_POSITION\t(1 << 17)\n-#define IOPARM_INQUIRE_HAS_ACTION\t(1 << 18)\n-#define IOPARM_INQUIRE_HAS_DELIM\t(1 << 19)\n-#define IOPARM_INQUIRE_HAS_PAD\t\t(1 << 20)\n-#define IOPARM_INQUIRE_HAS_NAME\t\t(1 << 21)\n-#define IOPARM_INQUIRE_HAS_SEQUENTIAL\t(1 << 22)\n-#define IOPARM_INQUIRE_HAS_DIRECT\t(1 << 23)\n-#define IOPARM_INQUIRE_HAS_FORMATTED\t(1 << 24)\n-#define IOPARM_INQUIRE_HAS_UNFORMATTED\t(1 << 25)\n-#define IOPARM_INQUIRE_HAS_READ\t\t(1 << 26)\n-#define IOPARM_INQUIRE_HAS_WRITE\t(1 << 27)\n-#define IOPARM_INQUIRE_HAS_READWRITE\t(1 << 28)\n-#define IOPARM_INQUIRE_HAS_CONVERT\t(1 << 29)\n+#define IOPARM_INQUIRE_HAS_STRM_POS_OUT (1 << 13)\n+#define IOPARM_INQUIRE_HAS_FILE\t\t(1 << 14)\n+#define IOPARM_INQUIRE_HAS_ACCESS\t(1 << 15)\n+#define IOPARM_INQUIRE_HAS_FORM\t\t(1 << 16)\n+#define IOPARM_INQUIRE_HAS_BLANK\t(1 << 17)\n+#define IOPARM_INQUIRE_HAS_POSITION\t(1 << 18)\n+#define IOPARM_INQUIRE_HAS_ACTION\t(1 << 19)\n+#define IOPARM_INQUIRE_HAS_DELIM\t(1 << 20)\n+#define IOPARM_INQUIRE_HAS_PAD\t\t(1 << 21)\n+#define IOPARM_INQUIRE_HAS_NAME\t\t(1 << 22)\n+#define IOPARM_INQUIRE_HAS_SEQUENTIAL\t(1 << 23)\n+#define IOPARM_INQUIRE_HAS_DIRECT\t(1 << 24)\n+#define IOPARM_INQUIRE_HAS_FORMATTED\t(1 << 25)\n+#define IOPARM_INQUIRE_HAS_UNFORMATTED\t(1 << 26)\n+#define IOPARM_INQUIRE_HAS_READ\t\t(1 << 27)\n+#define IOPARM_INQUIRE_HAS_WRITE\t(1 << 28)\n+#define IOPARM_INQUIRE_HAS_READWRITE\t(1 << 29)\n+#define IOPARM_INQUIRE_HAS_CONVERT\t(1 << 30)\n \n typedef struct\n {\n   st_parameter_common common;\n   GFC_INTEGER_4 *exist, *opened, *number, *named;\n   GFC_INTEGER_4 *nextrec, *recl_out;\n+  GFC_IO_INT *strm_pos_out;\n   CHARACTER1 (file);\n   CHARACTER2 (access);\n   CHARACTER1 (form);\n@@ -351,7 +353,7 @@ struct format_data;\n typedef struct st_parameter_dt\n {\n   st_parameter_common common;\n-  GFC_LARGE_IO_INT rec;\n+  GFC_IO_INT rec;\n   GFC_INTEGER_4 *size, *iolength;\n   gfc_array_char *internal_unit_desc;\n   CHARACTER1 (format);\n@@ -709,6 +711,9 @@ internal_proto(is_internal_unit);\n extern int is_array_io (st_parameter_dt *);\n internal_proto(is_array_io);\n \n+extern int is_stream_io (st_parameter_dt *);\n+internal_proto(is_stream_io);\n+\n extern gfc_unit *find_unit (int);\n internal_proto(find_unit);\n "}, {"sha": "b3360792a22e15c163550a15e73c6d1eaf155e7f", "filename": "libgfortran/io/open.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91b30ee5b9c83187fe1d7459cbd29abe302d60ed/libgfortran%2Fio%2Fopen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91b30ee5b9c83187fe1d7459cbd29abe302d60ed/libgfortran%2Fio%2Fopen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fopen.c?ref=91b30ee5b9c83187fe1d7459cbd29abe302d60ed", "patch": "@@ -40,6 +40,7 @@ static const st_option access_opt[] = {\n   {\"sequential\", ACCESS_SEQUENTIAL},\n   {\"direct\", ACCESS_DIRECT},\n   {\"append\", ACCESS_APPEND},\n+  {\"stream\", ACCESS_STREAM},\n   {NULL, 0}\n };\n \n@@ -214,7 +215,9 @@ edit_modes (st_parameter_open *opp, gfc_unit * u, unit_flags * flags)\n       if (sseek (u->s, file_length (u->s)) == FAILURE)\n \tgoto seek_error;\n \n-      u->current_record = 0;\n+      if (flags->access != ACCESS_STREAM)\n+\tu->current_record = 0;\n+\n       u->endfile = AT_ENDFILE;\t/* We are at the end.  */\n       break;\n \n@@ -432,6 +435,13 @@ new_unit (st_parameter_open *opp, gfc_unit *u, unit_flags * flags)\n \n   if (flags->access == ACCESS_DIRECT)\n     u->maxrec = max_offset / u->recl;\n+  \n+  if (flags->access == ACCESS_STREAM)\n+    {\n+      u->maxrec = max_offset;\n+      u->recl = 1;\n+      u->last_record = 1;\n+    }\n \n   memmove (u->file, opp->file, opp->file_len);\n   u->file_len = opp->file_len;"}, {"sha": "db9ff99cd12190cf23d2db726b6129ed3ef16b33", "filename": "libgfortran/io/read.c", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91b30ee5b9c83187fe1d7459cbd29abe302d60ed/libgfortran%2Fio%2Fread.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91b30ee5b9c83187fe1d7459cbd29abe302d60ed/libgfortran%2Fio%2Fread.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fread.c?ref=91b30ee5b9c83187fe1d7459cbd29abe302d60ed", "patch": "@@ -841,13 +841,17 @@ read_f (st_parameter_dt *dtp, const fnode *f, char *dest, int length)\n void\n read_x (st_parameter_dt *dtp, int n)\n {\n-  if ((dtp->u.p.current_unit->flags.pad == PAD_NO || is_internal_unit (dtp))\n-      && dtp->u.p.current_unit->bytes_left < n)\n-    n = dtp->u.p.current_unit->bytes_left;\n-\n-  dtp->u.p.sf_read_comma = 0;\n-  if (n > 0)\n-    read_sf (dtp, &n, 1);\n-  dtp->u.p.sf_read_comma = 1;\n-\n+  if (!is_stream_io (dtp))\n+    {\n+      if ((dtp->u.p.current_unit->flags.pad == PAD_NO || is_internal_unit (dtp))\n+\t  && dtp->u.p.current_unit->bytes_left < n)\n+\tn = dtp->u.p.current_unit->bytes_left;\n+\n+      dtp->u.p.sf_read_comma = 0;\n+      if (n > 0)\n+\tread_sf (dtp, &n, 1);\n+      dtp->u.p.sf_read_comma = 1;\n+    }\n+  else\n+    dtp->rec += (GFC_IO_INT) n;\n }"}, {"sha": "99e897944177b7fff352eb27b7aad6446011726e", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 237, "deletions": 120, "changes": 357, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91b30ee5b9c83187fe1d7459cbd29abe302d60ed/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91b30ee5b9c83187fe1d7459cbd29abe302d60ed/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=91b30ee5b9c83187fe1d7459cbd29abe302d60ed", "patch": "@@ -91,7 +91,7 @@ static const st_option advance_opt[] = {\n \n typedef enum\n { FORMATTED_SEQUENTIAL, UNFORMATTED_SEQUENTIAL,\n-  FORMATTED_DIRECT, UNFORMATTED_DIRECT\n+  FORMATTED_DIRECT, UNFORMATTED_DIRECT, FORMATTED_STREAM, UNFORMATTED_STREAM\n }\n file_mode;\n \n@@ -101,16 +101,23 @@ current_mode (st_parameter_dt *dtp)\n {\n   file_mode m;\n \n+  m = FORM_UNSPECIFIED;\n+\n   if (dtp->u.p.current_unit->flags.access == ACCESS_DIRECT)\n     {\n       m = dtp->u.p.current_unit->flags.form == FORM_FORMATTED ?\n \tFORMATTED_DIRECT : UNFORMATTED_DIRECT;\n     }\n-  else\n+  else if (dtp->u.p.current_unit->flags.access == ACCESS_SEQUENTIAL)\n     {\n       m = dtp->u.p.current_unit->flags.form == FORM_FORMATTED ?\n \tFORMATTED_SEQUENTIAL : UNFORMATTED_SEQUENTIAL;\n     }\n+  else if (dtp->u.p.current_unit->flags.access == ACCESS_STREAM)\n+    {\n+      m = dtp->u.p.current_unit->flags.form == FORM_FORMATTED ?\n+\tFORMATTED_STREAM : UNFORMATTED_STREAM;\n+    }\n \n   return m;\n }\n@@ -128,7 +135,7 @@ current_mode (st_parameter_dt *dtp)\n    an I/O error.\n \n    Given this, the solution is to read a byte at a time, stopping if\n-   we hit the newline.  For small locations, we use a static buffer.\n+   we hit the newline.  For small allocations, we use a static buffer.\n    For larger allocations, we are forced to allocate memory on the\n    heap.  Hopefully this won't happen very often.  */\n \n@@ -256,56 +263,86 @@ read_block (st_parameter_dt *dtp, int *length)\n   char *source;\n   int nread;\n \n-  if (dtp->u.p.current_unit->bytes_left < *length)\n+  if (!is_stream_io (dtp))\n     {\n-      /* For preconnected units with default record length, set bytes left\n-\t to unit record length and proceed, otherwise error.  */\n-      if (dtp->u.p.current_unit->unit_number == options.stdin_unit\n-\t  && dtp->u.p.current_unit->recl == DEFAULT_RECL)\n-        dtp->u.p.current_unit->bytes_left = dtp->u.p.current_unit->recl;\n-      else\n+      if (dtp->u.p.current_unit->bytes_left < (gfc_offset) *length)\n \t{\n-\t  if (dtp->u.p.current_unit->flags.pad == PAD_NO)\n+\t  /* For preconnected units with default record length, set bytes left\n+\t   to unit record length and proceed, otherwise error.  */\n+\t  if (dtp->u.p.current_unit->unit_number == options.stdin_unit\n+\t      && dtp->u.p.current_unit->recl == DEFAULT_RECL)\n+          dtp->u.p.current_unit->bytes_left = dtp->u.p.current_unit->recl;\n+\t  else\n \t    {\n-\t      /* Not enough data left.  */\n-\t      generate_error (&dtp->common, ERROR_EOR, NULL);\n+\t      if (dtp->u.p.current_unit->flags.pad == PAD_NO)\n+\t\t{\n+\t\t  /* Not enough data left.  */\n+\t\t  generate_error (&dtp->common, ERROR_EOR, NULL);\n+\t\t  return NULL;\n+\t\t}\n+\t    }\n+\n+\t  if (dtp->u.p.current_unit->bytes_left == 0)\n+\t    {\n+\t      dtp->u.p.current_unit->endfile = AT_ENDFILE;\n+\t      generate_error (&dtp->common, ERROR_END, NULL);\n \t      return NULL;\n \t    }\n+\n+\t  *length = dtp->u.p.current_unit->bytes_left;\n \t}\n \n-      if (dtp->u.p.current_unit->bytes_left == 0)\n+      if (dtp->u.p.current_unit->flags.form == FORM_FORMATTED &&\n+\tdtp->u.p.current_unit->flags.access == ACCESS_SEQUENTIAL)\n+\t  return read_sf (dtp, length, 0);\t/* Special case.  */\n+\n+      dtp->u.p.current_unit->bytes_left -= (gfc_offset) *length;\n+\n+      nread = *length;\n+      source = salloc_r (dtp->u.p.current_unit->s, &nread);\n+\n+      if ((dtp->common.flags & IOPARM_DT_HAS_SIZE) != 0)\n+\tdtp->u.p.size_used += (gfc_offset) nread;\n+\n+      if (nread != *length)\n+\t{\t\t\t\t/* Short read, this shouldn't happen.  */\n+\t  if (dtp->u.p.current_unit->flags.pad == PAD_YES)\n+\t    *length = nread;\n+\t  else\n+\t    {\n+\t      generate_error (&dtp->common, ERROR_EOR, NULL);\n+\t      source = NULL;\n+\t    }\n+\t}\n+    }\n+  else\n+    {\n+      if (sseek (dtp->u.p.current_unit->s,\n+\t\t (gfc_offset) (dtp->rec - 1)) == FAILURE)\n \t{\n-\t  dtp->u.p.current_unit->endfile = AT_ENDFILE;\n \t  generate_error (&dtp->common, ERROR_END, NULL);\n \t  return NULL;\n \t}\n \n-      *length = dtp->u.p.current_unit->bytes_left;\n-    }\n-\n-  if (dtp->u.p.current_unit->flags.form == FORM_FORMATTED &&\n-      dtp->u.p.current_unit->flags.access == ACCESS_SEQUENTIAL)\n-    return read_sf (dtp, length, 0);\t/* Special case.  */\n-\n-  dtp->u.p.current_unit->bytes_left -= *length;\n-\n-  nread = *length;\n-  source = salloc_r (dtp->u.p.current_unit->s, &nread);\n+      nread = *length;\n+      source = salloc_r (dtp->u.p.current_unit->s, &nread);\n \n-  if ((dtp->common.flags & IOPARM_DT_HAS_SIZE) != 0)\n-    dtp->u.p.size_used += (gfc_offset) nread;\n+      if ((dtp->common.flags & IOPARM_DT_HAS_SIZE) != 0)\n+\tdtp->u.p.size_used += (gfc_offset) nread;\n \n-  if (nread != *length)\n-    {\t\t\t\t/* Short read, this shouldn't happen.  */\n-      if (dtp->u.p.current_unit->flags.pad == PAD_YES)\n-\t*length = nread;\n-      else\n-\t{\n-\t  generate_error (&dtp->common, ERROR_EOR, NULL);\n-\t  source = NULL;\n+      if (nread != *length)\n+\t{\t\t\t\t/* Short read, this shouldn't happen.  */\n+\t  if (dtp->u.p.current_unit->flags.pad == PAD_YES)\n+\t    *length = nread;\n+\t  else\n+\t    {\n+\t      generate_error (&dtp->common, ERROR_END, NULL);\n+\t      source = NULL;\n+\t    }\n \t}\n-    }\n \n+      dtp->rec += (GFC_IO_INT) nread;\n+    }\n   return source;\n }\n \n@@ -319,63 +356,78 @@ read_block_direct (st_parameter_dt *dtp, void *buf, size_t *nbytes)\n   void *data;\n   size_t nread;\n \n-  if (dtp->u.p.current_unit->bytes_left < *nbytes)\n+  if (!is_stream_io (dtp))\n     {\n-      /* For preconnected units with default record length, set bytes left\n-\t to unit record length and proceed, otherwise error.  */\n-      if (dtp->u.p.current_unit->unit_number == options.stdin_unit\n-\t  && dtp->u.p.current_unit->recl == DEFAULT_RECL)\n-        dtp->u.p.current_unit->bytes_left = dtp->u.p.current_unit->recl;\n-      else\n+      if (dtp->u.p.current_unit->bytes_left < (gfc_offset) *nbytes)\n \t{\n-\t  if (dtp->u.p.current_unit->flags.pad == PAD_NO)\n+\t  /* For preconnected units with default record length, set\n+\t     bytes left to unit record length and proceed, otherwise\n+\t     error.  */\n+\t  if (dtp->u.p.current_unit->unit_number == options.stdin_unit\n+\t      && dtp->u.p.current_unit->recl == DEFAULT_RECL)\n+\t    dtp->u.p.current_unit->bytes_left = dtp->u.p.current_unit->recl;\n+\t  else\n \t    {\n-\t      /* Not enough data left.  */\n-\t      generate_error (&dtp->common, ERROR_EOR, NULL);\n+\t      if (dtp->u.p.current_unit->flags.pad == PAD_NO)\n+\t\t{\n+\t\t  /* Not enough data left.  */\n+\t\t  generate_error (&dtp->common, ERROR_EOR, NULL);\n+\t\t  return;\n+\t\t}\n+\t    }\n+\t  \n+\t  if (dtp->u.p.current_unit->bytes_left == 0)\n+\t    {\n+\t      dtp->u.p.current_unit->endfile = AT_ENDFILE;\n+\t      generate_error (&dtp->common, ERROR_END, NULL);\n \t      return;\n \t    }\n+\n+\t  *nbytes = (size_t) dtp->u.p.current_unit->bytes_left;\n \t}\n \n-      if (dtp->u.p.current_unit->bytes_left == 0)\n+      if (dtp->u.p.current_unit->flags.form == FORM_FORMATTED &&\n+\t  dtp->u.p.current_unit->flags.access == ACCESS_SEQUENTIAL)\n \t{\n-\t  dtp->u.p.current_unit->endfile = AT_ENDFILE;\n-\t  generate_error (&dtp->common, ERROR_END, NULL);\n+\t  length = (int *) nbytes;\n+\t  data = read_sf (dtp, length, 0);\t/* Special case.  */\n+\t  memcpy (buf, data, (size_t) *length);\n \t  return;\n \t}\n \n-      *nbytes = dtp->u.p.current_unit->bytes_left;\n+      dtp->u.p.current_unit->bytes_left -= (gfc_offset) *nbytes;\n     }\n-\n-  if (dtp->u.p.current_unit->flags.form == FORM_FORMATTED &&\n-      dtp->u.p.current_unit->flags.access == ACCESS_SEQUENTIAL)\n+  else\n     {\n-      length = (int *) nbytes;\n-      data = read_sf (dtp, length, 0);\t/* Special case.  */\n-      memcpy (buf, data, (size_t) *length);\n-      return;\n+      if (sseek (dtp->u.p.current_unit->s,\n+\t  (gfc_offset) (dtp->rec - 1)) == FAILURE)\n+\t{\n+\t  generate_error (&dtp->common, ERROR_END, NULL);\n+\t  return;\n+\t}\n     }\n \n-  dtp->u.p.current_unit->bytes_left -= *nbytes;\n-\n   nread = *nbytes;\n   if (sread (dtp->u.p.current_unit->s, buf, &nread) != 0)\n     {\n       generate_error (&dtp->common, ERROR_OS, NULL);\n       return;\n     }\n \n-  if ((dtp->common.flags & IOPARM_DT_HAS_SIZE) != 0)\n-    dtp->u.p.size_used += (gfc_offset) nread;\n+  if (!is_stream_io (dtp))\n+    {\n+      if ((dtp->common.flags & IOPARM_DT_HAS_SIZE) != 0)\n+\tdtp->u.p.size_used += (gfc_offset) nread;\n+    }\n+  else\n+    dtp->rec += (GFC_IO_INT) nread; \n \n-  if (nread != *nbytes)\n-    {\t\t\t\t/* Short read, e.g. if we hit EOF.  */\n-      if (dtp->u.p.current_unit->flags.pad == PAD_YES)\n-\t{\n-\t  memset (((char *) buf) + nread, ' ', *nbytes - nread);\n-\t  *nbytes = nread;\n-\t}\n-      else\n+  if (nread != *nbytes)  /* Short read, e.g. if we hit EOF.  */\n+    {\n+      if (!is_stream_io (dtp))\n \tgenerate_error (&dtp->common, ERROR_EOR, NULL);\n+      else\n+\tgenerate_error (&dtp->common, ERROR_END, NULL);\t  \n     }\n }\n \n@@ -390,35 +442,59 @@ write_block (st_parameter_dt *dtp, int length)\n {\n   char *dest;\n \n-  if (dtp->u.p.current_unit->bytes_left < length)\n+  if (!is_stream_io (dtp))\n     {\n-      /* For preconnected units with default record length, set bytes left\n-\t to unit record length and proceed, otherwise error.  */\n-      if ((dtp->u.p.current_unit->unit_number == options.stdout_unit\n-\t  || dtp->u.p.current_unit->unit_number == options.stderr_unit)\n-\t  && dtp->u.p.current_unit->recl == DEFAULT_RECL)\n-        dtp->u.p.current_unit->bytes_left = dtp->u.p.current_unit->recl;\n-      else\n+      if (dtp->u.p.current_unit->bytes_left < (gfc_offset) length)\n \t{\n-\t  generate_error (&dtp->common, ERROR_EOR, NULL);\n-\t  return NULL;\n+\t  /* For preconnected units with default record length, set bytes left\n+\t     to unit record length and proceed, otherwise error.  */\n+\t  if ((dtp->u.p.current_unit->unit_number == options.stdout_unit\n+\t\t|| dtp->u.p.current_unit->unit_number == options.stderr_unit)\n+\t\t&& dtp->u.p.current_unit->recl == DEFAULT_RECL)\n+\t    dtp->u.p.current_unit->bytes_left = dtp->u.p.current_unit->recl;\n+\t  else\n+\t    {\n+\t      generate_error (&dtp->common, ERROR_EOR, NULL);\n+\t      return NULL;\n+\t    }\n \t}\n-    }\n \n-  dtp->u.p.current_unit->bytes_left -= (gfc_offset) length;\n-  dest = salloc_w (dtp->u.p.current_unit->s, &length);\n+      dtp->u.p.current_unit->bytes_left -= (gfc_offset) length;\n+\n+\n+      dest = salloc_w (dtp->u.p.current_unit->s, &length);\n   \n-  if (dest == NULL)\n-    {\n-      generate_error (&dtp->common, ERROR_END, NULL);\n-      return NULL;\n+      if (dest == NULL)\n+\t{\n+\t  generate_error (&dtp->common, ERROR_END, NULL);\n+\t  return NULL;\n+\t}\n+\n+      if (is_internal_unit (dtp) && dtp->u.p.current_unit->endfile == AT_ENDFILE)\n+\tgenerate_error (&dtp->common, ERROR_END, NULL);\n+\n+      if ((dtp->common.flags & IOPARM_DT_HAS_SIZE) != 0)\n+\tdtp->u.p.size_used += (gfc_offset) length;\n     }\n+  else\n+    {\n+      if (sseek (dtp->u.p.current_unit->s,\n+\t  (gfc_offset) (dtp->rec - 1)) == FAILURE)\n+\t{\n+\t  generate_error (&dtp->common, ERROR_END, NULL);\n+\t  return NULL;\n+\t}\n \n-  if (is_internal_unit (dtp) && dtp->u.p.current_unit->endfile == AT_ENDFILE)\n-    generate_error (&dtp->common, ERROR_END, NULL);\n+      dest = salloc_w (dtp->u.p.current_unit->s, &length);\n \n-  if ((dtp->common.flags & IOPARM_DT_HAS_SIZE) != 0)\n-    dtp->u.p.size_used += (gfc_offset) length;\n+      if (dest == NULL)\n+\t{\n+\t  generate_error (&dtp->common, ERROR_END, NULL);\n+\t  return NULL;\n+\t}\n+\n+      dtp->rec += (GFC_IO_INT) length;\n+    }\n \n   return dest;\n }\n@@ -429,34 +505,52 @@ write_block (st_parameter_dt *dtp, int length)\n static try\n write_buf (st_parameter_dt *dtp, void *buf, size_t nbytes)\n {\n-  if (dtp->u.p.current_unit->bytes_left < nbytes)\n+  if (!is_stream_io (dtp))\n     {\n-      /* For preconnected units with default record length, set bytes left\n-\t to unit record length and proceed, otherwise error.  */\n-      if ((dtp->u.p.current_unit->unit_number == options.stdout_unit\n-\t  || dtp->u.p.current_unit->unit_number == options.stderr_unit)\n-\t  && dtp->u.p.current_unit->recl == DEFAULT_RECL)\n-        dtp->u.p.current_unit->bytes_left = dtp->u.p.current_unit->recl;\n-      else\n+      if (dtp->u.p.current_unit->bytes_left < (gfc_offset) nbytes)\n \t{\n-\t  if (dtp->u.p.current_unit->flags.access == ACCESS_DIRECT)\n-\t    generate_error (&dtp->common, ERROR_DIRECT_EOR, NULL);\n+\t  /* For preconnected units with default record length, set\n+\t     bytes left to unit record length and proceed, otherwise\n+\t     error.  */\n+\t  if ((dtp->u.p.current_unit->unit_number == options.stdout_unit\n+\t       || dtp->u.p.current_unit->unit_number == options.stderr_unit)\n+\t      && dtp->u.p.current_unit->recl == DEFAULT_RECL)\n+\t    dtp->u.p.current_unit->bytes_left = dtp->u.p.current_unit->recl;\n \t  else\n-\t    generate_error (&dtp->common, ERROR_EOR, NULL);\n+\t    {\n+\t      if (dtp->u.p.current_unit->flags.access == ACCESS_DIRECT)\n+\t\tgenerate_error (&dtp->common, ERROR_DIRECT_EOR, NULL);\n+\t      else\n+\t\tgenerate_error (&dtp->common, ERROR_EOR, NULL);\n+\t      return FAILURE;\n+\t    }\n+\t}\n+\n+      dtp->u.p.current_unit->bytes_left -= (gfc_offset) nbytes;\n+    }\n+  else\n+    {\n+      if (sseek (dtp->u.p.current_unit->s,\n+\t\t (gfc_offset) (dtp->rec - 1)) == FAILURE)\n+\t{\n+\t  generate_error (&dtp->common, ERROR_OS, NULL);\n \t  return FAILURE;\n \t}\n     }\n \n-  dtp->u.p.current_unit->bytes_left -= (gfc_offset) nbytes;\n-\n   if (swrite (dtp->u.p.current_unit->s, buf, &nbytes) != 0)\n     {\n       generate_error (&dtp->common, ERROR_OS, NULL);\n       return FAILURE;\n     }\n \n-  if ((dtp->common.flags & IOPARM_DT_HAS_SIZE) != 0)\n-    dtp->u.p.size_used += (gfc_offset) nbytes;\n+  if (!is_stream_io (dtp))\n+    {\n+      if ((dtp->common.flags & IOPARM_DT_HAS_SIZE) != 0)\n+\tdtp->u.p.size_used += (gfc_offset) nbytes;\n+    }\n+  else\n+    dtp->rec += (GFC_IO_INT) nbytes; \n \n   return SUCCESS;\n }\n@@ -469,18 +563,19 @@ unformatted_read (st_parameter_dt *dtp, bt type,\n \t\t  void *dest, int kind,\n \t\t  size_t size, size_t nelems)\n {\n+  size_t i, sz;\n+\n   /* Currently, character implies size=1.  */\n   if (dtp->u.p.current_unit->flags.convert == CONVERT_NATIVE\n       || size == 1 || type == BT_CHARACTER)\n     {\n-      size *= nelems;\n-      read_block_direct (dtp, dest, &size);\n+      sz = size * nelems;\n+      read_block_direct (dtp, dest, &sz);\n     }\n   else\n     {\n       char buffer[16];\n       char *p;\n-      size_t i, sz;\n       \n       /* Break up complex into its constituent reals.  */\n       if (type == BT_COMPLEX)\n@@ -721,7 +816,8 @@ formatted_transfer_scalar (st_parameter_dt *dtp, bt type, void *p, int len,\n \t  dtp->u.p.skips = dtp->u.p.pending_spaces = 0;\n \t}\n \n-      bytes_used = (int)(dtp->u.p.current_unit->recl - dtp->u.p.current_unit->bytes_left);\n+      bytes_used = (int)(dtp->u.p.current_unit->recl\n+\t\t\t - dtp->u.p.current_unit->bytes_left);\n \n       switch (t)\n \t{\n@@ -1405,6 +1501,14 @@ pre_position (st_parameter_dt *dtp)\n \n   switch (current_mode (dtp))\n     {\n+    case FORMATTED_STREAM:\n+    case UNFORMATTED_STREAM:\n+      /* There are no records with stream I/O.  Set the default position\n+\t to the beginning of the file if no position was specified.  */\n+      if ((dtp->common.flags & IOPARM_DT_HAS_REC) == 0)\n+        dtp->rec = 1;\n+      break;\n+    \n     case UNFORMATTED_SEQUENTIAL:\n       if (dtp->u.p.mode == READING)\n \tus_read (dtp);\n@@ -1549,13 +1653,12 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n     generate_error (&dtp->common, ERROR_OPTION_CONFLICT,\n \t\t    \"Missing format for FORMATTED data transfer\");\n \n-\n   if (is_internal_unit (dtp)\n       && dtp->u.p.current_unit->flags.form == FORM_UNFORMATTED)\n     generate_error (&dtp->common, ERROR_OPTION_CONFLICT,\n \t\t    \"Internal file cannot be accessed by UNFORMATTED data transfer\");\n \n-  /* Check the record number.  */\n+  /* Check the record or position number.  */\n \n   if (dtp->u.p.current_unit->flags.access == ACCESS_DIRECT\n       && (cf & IOPARM_DT_HAS_REC) == 0)\n@@ -1628,7 +1731,6 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n     return;\n \n   /* Sanity checks on the record number.  */\n-\n   if ((cf & IOPARM_DT_HAS_REC) != 0)\n     {\n       if (dtp->rec <= 0)\n@@ -1664,8 +1766,8 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n \t}\n \n       /* Position the file.  */\n-      if (sseek (dtp->u.p.current_unit->s,\n-\t       (dtp->rec - 1) * dtp->u.p.current_unit->recl) == FAILURE)\n+      if (sseek (dtp->u.p.current_unit->s, (gfc_offset) (dtp->rec - 1)\n+\t\t  * dtp->u.p.current_unit->recl) == FAILURE)\n \t{\n \t  generate_error (&dtp->common, ERROR_OS, NULL);\n \t  return;\n@@ -1723,7 +1825,7 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n \n   if (read_flag)\n     {\n-      if (dtp->u.p.current_unit->read_bad)\n+      if (dtp->u.p.current_unit->read_bad && !is_stream_io (dtp))\n \t{\n \t  generate_error (&dtp->common, ERROR_BAD_OPTION,\n \t\t\t  \"Cannot READ after a nonadvancing WRITE\");\n@@ -1813,6 +1915,11 @@ next_record_r (st_parameter_dt *dtp)\n \n   switch (current_mode (dtp))\n     {\n+    /* No records in STREAM I/O.  */\n+    case FORMATTED_STREAM:\n+    case UNFORMATTED_STREAM:\n+      return;\n+    \n     case UNFORMATTED_SEQUENTIAL:\n \n       /* Skip over tail */\n@@ -2003,6 +2110,11 @@ next_record_w (st_parameter_dt *dtp, int done)\n \n   switch (current_mode (dtp))\n     {\n+    /* No records in STREAM I/O.  */\n+    case FORMATTED_STREAM:\n+    case UNFORMATTED_STREAM:\n+      return;\n+\n     case FORMATTED_DIRECT:\n       if (dtp->u.p.current_unit->bytes_left == 0)\n \tbreak;\n@@ -2166,6 +2278,9 @@ next_record_w (st_parameter_dt *dtp, int done)\n void\n next_record (st_parameter_dt *dtp, int done)\n {\n+  if (is_stream_io (dtp))\n+    return;\n+\n   gfc_offset fp; /* File position.  */\n \n   dtp->u.p.current_unit->read_bad = 0;\n@@ -2177,7 +2292,6 @@ next_record (st_parameter_dt *dtp, int done)\n \n   /* keep position up to date for INQUIRE */\n   dtp->u.p.current_unit->flags.position = POSITION_ASIS;\n-\n   dtp->u.p.current_unit->current_record = 0;\n   if (dtp->u.p.current_unit->flags.access == ACCESS_DIRECT)\n    {\n@@ -2238,7 +2352,7 @@ finalize_transfer (st_parameter_dt *dtp)\n \n   if ((cf & IOPARM_DT_LIST_FORMAT) != 0 && dtp->u.p.mode == READING)\n     finish_list_read (dtp);\n-  else\n+  else if (!is_stream_io (dtp))\n     {\n       dtp->u.p.current_unit->current_record = 0;\n       if (dtp->u.p.advance_status == ADVANCE_NO || dtp->u.p.seen_dollar)\n@@ -2250,9 +2364,13 @@ finalize_transfer (st_parameter_dt *dtp)\n \t  dtp->u.p.seen_dollar = 0;\n \t  return;\n \t}\n-\n       next_record (dtp, 1);\n     }\n+  else\n+    {\n+      flush (dtp->u.p.current_unit->s);\n+      dtp->u.p.current_unit->last_record = dtp->rec;\n+    }\n \n   sfree (dtp->u.p.current_unit->s);\n }\n@@ -2325,7 +2443,6 @@ export_proto(st_read);\n void\n st_read (st_parameter_dt *dtp)\n {\n-\n   library_start (&dtp->common);\n \n   data_transfer_init (dtp, 1);"}, {"sha": "6a22784564919298f29e1839a7f3d41752e1e3fd", "filename": "libgfortran/io/unit.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91b30ee5b9c83187fe1d7459cbd29abe302d60ed/libgfortran%2Fio%2Funit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91b30ee5b9c83187fe1d7459cbd29abe302d60ed/libgfortran%2Fio%2Funit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funit.c?ref=91b30ee5b9c83187fe1d7459cbd29abe302d60ed", "patch": "@@ -493,6 +493,15 @@ is_array_io (st_parameter_dt *dtp)\n }\n \n \n+/* is_stream_io () -- Determine if I/O is access=\"stream\" mode */\n+\n+int\n+is_stream_io (st_parameter_dt *dtp)\n+{\n+  return dtp->u.p.current_unit->flags.access == ACCESS_STREAM;\n+}\n+\n+\n /*************************/\n /* Initialize everything */\n "}, {"sha": "0c0e6cd29be3eb0c751d6504ca6b090bab6ef65c", "filename": "libgfortran/libgfortran.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91b30ee5b9c83187fe1d7459cbd29abe302d60ed/libgfortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91b30ee5b9c83187fe1d7459cbd29abe302d60ed/libgfortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Flibgfortran.h?ref=91b30ee5b9c83187fe1d7459cbd29abe302d60ed", "patch": "@@ -200,10 +200,10 @@ typedef off_t gfc_offset;\n /* Define the type used for the current record number for large file I/O.\n    The size must be consistent with the size defined on the compiler side.  */\n #ifdef HAVE_GFC_INTEGER_8\n-typedef GFC_INTEGER_8 GFC_LARGE_IO_INT;\n+typedef GFC_INTEGER_8 GFC_IO_INT;\n #else\n #ifdef HAVE_GFC_INTEGER_4\n-typedef GFC_INTEGER_4 GFC_LARGE_IO_INT;\n+typedef GFC_INTEGER_4 GFC_IO_INT;\n #else\n #error \"GFC_INTEGER_4 should be available for the library to compile\".\n #endif"}]}