{"sha": "81c402418540b5a9476b52ba14b5096f87b0a6e5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODFjNDAyNDE4NTQwYjVhOTQ3NmI1MmJhMTRiNTA5NmY4N2IwYTZlNQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-10-14T13:57:09Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-10-14T13:57:09Z"}, "message": "tree-vectorizer.h (vect_is_simple_use): Remove unused parameters.\n\n2015-10-14  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vectorizer.h (vect_is_simple_use): Remove unused parameters.\n\t(vect_is_simple_use_1): Likewise.  Make overload of vect_is_simple_use.\n\t(vect_get_vec_def_for_operand): Remove unused parameter.\n\t* tree-vect-loop.c (get_initial_def_for_induction): Adjust.\n\t(vect_create_epilog_for_reduction): Likewise.\n\t(vectorizable_reduction): Likewise.\n\t(vectorizable_live_operation): Likewise.\n\t* tree-vect-patterns.c (type_conversion_p): Likewise.\n\t(vect_recog_vector_vector_shift_pattern): Likewise.\n\t(check_bool_pattern): Likewise.\n\t* tree-vect-slp.c (vect_get_and_check_slp_defs): Likewise.\n\t(vect_analyze_slp_cost_1): Likewise.\n\t* tree-vect-stmts.c (process_use): Likewise.\n\t(vect_get_vec_def_for_operand): Do not handle reductions.\n\t(vect_get_vec_defs): Adjust.\n\t(vectorizable_mask_load_store): Likewise.\n\t(vectorizable_call): Likewise.\n\t(vectorizable_simd_clone_call): Likewise.\n\t(vect_get_loop_based_defs): Likewise.\n\t(vectorizable_conversion): Likewise.\n\t(vectorizable_assignment): Likewise.\n\t(vectorizable_shift): Likewise.\n\t(vectorizable_operation): Likewise.\n\t(vectorizable_store): Likewise.\n\t(vectorizable_load): Likewise.\n\t(vect_is_simple_cond): Likewise.\n\t(vectorizable_condition): Likewise.\n\t(vect_is_simple_use): Remove unused parameters.\n\t(vect_is_simple_use_1): Adjust and rename.\n\nFrom-SVN: r228811", "tree": {"sha": "1b0af7b6089c8538a8c1b2dfaf0b52da3153a586", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1b0af7b6089c8538a8c1b2dfaf0b52da3153a586"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/81c402418540b5a9476b52ba14b5096f87b0a6e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81c402418540b5a9476b52ba14b5096f87b0a6e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81c402418540b5a9476b52ba14b5096f87b0a6e5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81c402418540b5a9476b52ba14b5096f87b0a6e5/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c3bea07622b9a0ffc7a6724c06a04c9801642dfd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3bea07622b9a0ffc7a6724c06a04c9801642dfd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3bea07622b9a0ffc7a6724c06a04c9801642dfd"}], "stats": {"total": 455, "additions": 177, "deletions": 278}, "files": [{"sha": "a555d2be390be7b0ed2fa71cea849826be4fb647", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81c402418540b5a9476b52ba14b5096f87b0a6e5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81c402418540b5a9476b52ba14b5096f87b0a6e5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=81c402418540b5a9476b52ba14b5096f87b0a6e5", "patch": "@@ -1,3 +1,35 @@\n+2015-10-14  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vectorizer.h (vect_is_simple_use): Remove unused parameters.\n+\t(vect_is_simple_use_1): Likewise.  Make overload of vect_is_simple_use.\n+\t(vect_get_vec_def_for_operand): Remove unused parameter.\n+\t* tree-vect-loop.c (get_initial_def_for_induction): Adjust.\n+\t(vect_create_epilog_for_reduction): Likewise.\n+\t(vectorizable_reduction): Likewise.\n+\t(vectorizable_live_operation): Likewise.\n+\t* tree-vect-patterns.c (type_conversion_p): Likewise.\n+\t(vect_recog_vector_vector_shift_pattern): Likewise.\n+\t(check_bool_pattern): Likewise.\n+\t* tree-vect-slp.c (vect_get_and_check_slp_defs): Likewise.\n+\t(vect_analyze_slp_cost_1): Likewise.\n+\t* tree-vect-stmts.c (process_use): Likewise.\n+\t(vect_get_vec_def_for_operand): Do not handle reductions.\n+\t(vect_get_vec_defs): Adjust.\n+\t(vectorizable_mask_load_store): Likewise.\n+\t(vectorizable_call): Likewise.\n+\t(vectorizable_simd_clone_call): Likewise.\n+\t(vect_get_loop_based_defs): Likewise.\n+\t(vectorizable_conversion): Likewise.\n+\t(vectorizable_assignment): Likewise.\n+\t(vectorizable_shift): Likewise.\n+\t(vectorizable_operation): Likewise.\n+\t(vectorizable_store): Likewise.\n+\t(vectorizable_load): Likewise.\n+\t(vect_is_simple_cond): Likewise.\n+\t(vectorizable_condition): Likewise.\n+\t(vect_is_simple_use): Remove unused parameters.\n+\t(vect_is_simple_use_1): Adjust and rename.\n+\n 2015-10-14  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/67915"}, {"sha": "9285e516b46afd0d54a8e54a22617e3c1c5c0f96", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 18, "deletions": 24, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81c402418540b5a9476b52ba14b5096f87b0a6e5/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81c402418540b5a9476b52ba14b5096f87b0a6e5/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=81c402418540b5a9476b52ba14b5096f87b0a6e5", "patch": "@@ -3412,7 +3412,7 @@ get_initial_def_for_induction (gimple *iv_phi)\n       /* iv_loop is nested in the loop to be vectorized.  init_expr had already\n \t been created during vectorization of previous stmts.  We obtain it\n \t from the STMT_VINFO_VEC_STMT of the defining stmt.  */\n-      vec_init = vect_get_vec_def_for_operand (init_expr, iv_phi, NULL);\n+      vec_init = vect_get_vec_def_for_operand (init_expr, iv_phi);\n       /* If the initial value is not of proper type, convert it.  */\n       if (!useless_type_conversion_p (vectype, TREE_TYPE (vec_init)))\n \t{\n@@ -3798,8 +3798,7 @@ get_initial_def_for_reduction (gimple *stmt, tree init_val,\n         if (adjustment_def)\n           {\n             if (nested_in_vect_loop)\n-              *adjustment_def = vect_get_vec_def_for_operand (init_val, stmt,\n-                                                              NULL);\n+              *adjustment_def = vect_get_vec_def_for_operand (init_val, stmt);\n             else\n               *adjustment_def = init_val;\n           }\n@@ -3853,7 +3852,7 @@ get_initial_def_for_reduction (gimple *stmt, tree init_val,\n         if (adjustment_def)\n           {\n             *adjustment_def = NULL_TREE;\n-            init_def = vect_get_vec_def_for_operand (init_val, stmt, NULL);\n+            init_def = vect_get_vec_def_for_operand (init_val, stmt);\n             break;\n           }\n \n@@ -4012,12 +4011,13 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n                        NULL, slp_node, reduc_index);\n   else\n     {\n+      /* Get at the scalar def before the loop, that defines the initial value\n+\t of the reduction variable.  */\n+      gimple *def_stmt = SSA_NAME_DEF_STMT (reduction_op);\n+      tree op = PHI_ARG_DEF_FROM_EDGE (def_stmt, loop_preheader_edge (loop));\n       vec_initial_defs.create (1);\n-     /* For the case of reduction, vect_get_vec_def_for_operand returns\n-        the scalar def before the loop, that defines the initial value\n-        of the reduction variable.  */\n-      vec_initial_def = vect_get_vec_def_for_operand (reduction_op, stmt,\n-                                                      &adjustment_def);\n+      vec_initial_def = get_initial_def_for_reduction (stmt, op,\n+\t\t\t\t\t\t       &adjustment_def);\n       vec_initial_defs.quick_push (vec_initial_def);\n     }\n \n@@ -4800,7 +4800,6 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n   int op_type;\n   optab optab, reduc_optab;\n   tree new_temp = NULL_TREE;\n-  tree def;\n   gimple *def_stmt;\n   enum vect_def_type dt;\n   gphi *new_phi = NULL;\n@@ -4956,8 +4955,8 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n       if (i == 0 && code == COND_EXPR)\n         continue;\n \n-      is_simple_use = vect_is_simple_use_1 (ops[i], stmt, loop_vinfo,\n-\t\t\t\t\t    &def_stmt, &def, &dt, &tem);\n+      is_simple_use = vect_is_simple_use (ops[i], loop_vinfo,\n+\t\t\t\t\t  &def_stmt, &dt, &tem);\n       if (!vectype_in)\n \tvectype_in = tem;\n       gcc_assert (is_simple_use);\n@@ -4977,8 +4976,7 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n         }\n     }\n \n-  is_simple_use = vect_is_simple_use_1 (ops[i], stmt, loop_vinfo,\n-\t\t\t\t\t&def_stmt, &def, &dt, &tem);\n+  is_simple_use = vect_is_simple_use (ops[i], loop_vinfo, &def_stmt, &dt, &tem);\n   if (!vectype_in)\n     vectype_in = tem;\n   gcc_assert (is_simple_use);\n@@ -5340,12 +5338,11 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n           else\n             {\n               loop_vec_def0 = vect_get_vec_def_for_operand (ops[!reduc_index],\n-                                                            stmt, NULL);\n+                                                            stmt);\n               vec_oprnds0.quick_push (loop_vec_def0);\n               if (op_type == ternary_op)\n                {\n-                 loop_vec_def1 = vect_get_vec_def_for_operand (op1, stmt,\n-                                                               NULL);\n+                 loop_vec_def1 = vect_get_vec_def_for_operand (op1, stmt);\n                  vec_oprnds1.quick_push (loop_vec_def1);\n                }\n             }\n@@ -5356,17 +5353,15 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n             {\n               enum vect_def_type dt;\n \t      gimple *dummy_stmt;\n-              tree dummy;\n \n-              vect_is_simple_use (ops[!reduc_index], stmt, loop_vinfo,\n-                                  &dummy_stmt, &dummy, &dt);\n+              vect_is_simple_use (ops[!reduc_index], loop_vinfo,\n+                                  &dummy_stmt, &dt);\n               loop_vec_def0 = vect_get_vec_def_for_stmt_copy (dt,\n                                                               loop_vec_def0);\n               vec_oprnds0[0] = loop_vec_def0;\n               if (op_type == ternary_op)\n                 {\n-                  vect_is_simple_use (op1, stmt, loop_vinfo, &dummy_stmt,\n-                                      &dummy, &dt);\n+                  vect_is_simple_use (op1, loop_vinfo, &dummy_stmt, &dt);\n                   loop_vec_def1 = vect_get_vec_def_for_stmt_copy (dt,\n                                                                 loop_vec_def1);\n                   vec_oprnds1[0] = loop_vec_def1;\n@@ -5595,7 +5590,6 @@ vectorizable_live_operation (gimple *stmt,\n   int i;\n   int op_type;\n   tree op;\n-  tree def;\n   gimple *def_stmt;\n   enum vect_def_type dt;\n   enum tree_code code;\n@@ -5667,7 +5661,7 @@ vectorizable_live_operation (gimple *stmt,\n       else\n \top = gimple_op (stmt, i + 1);\n       if (op\n-          && !vect_is_simple_use (op, stmt, loop_vinfo, &def_stmt, &def, &dt))\n+          && !vect_is_simple_use (op, loop_vinfo, &def_stmt, &dt))\n         {\n           if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,"}, {"sha": "3fe094cb92d3df4f628d0ded9b9ae74a4aa6fab9", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81c402418540b5a9476b52ba14b5096f87b0a6e5/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81c402418540b5a9476b52ba14b5096f87b0a6e5/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=81c402418540b5a9476b52ba14b5096f87b0a6e5", "patch": "@@ -169,17 +169,14 @@ static bool\n type_conversion_p (tree name, gimple *use_stmt, bool check_sign,\n \t\t   tree *orig_type, gimple **def_stmt, bool *promotion)\n {\n-  tree dummy;\n   gimple *dummy_gimple;\n   stmt_vec_info stmt_vinfo;\n   tree type = TREE_TYPE (name);\n   tree oprnd0;\n   enum vect_def_type dt;\n-  tree def;\n \n   stmt_vinfo = vinfo_for_stmt (use_stmt);\n-  if (!vect_is_simple_use (name, use_stmt, stmt_vinfo->vinfo, def_stmt,\n-\t\t\t   &def, &dt))\n+  if (!vect_is_simple_use (name, stmt_vinfo->vinfo, def_stmt, &dt))\n     return false;\n \n   if (dt != vect_internal_def\n@@ -207,8 +204,7 @@ type_conversion_p (tree name, gimple *use_stmt, bool check_sign,\n   else\n     *promotion = false;\n \n-  if (!vect_is_simple_use (oprnd0, *def_stmt, stmt_vinfo->vinfo,\n-\t\t\t   &dummy_gimple, &dummy, &dt))\n+  if (!vect_is_simple_use (oprnd0, stmt_vinfo->vinfo, &dummy_gimple, &dt))\n     return false;\n \n   return true;\n@@ -1830,7 +1826,7 @@ vect_recog_rotate_pattern (vec<gimple *> *stmts, tree *type_in, tree *type_out)\n       || !TYPE_UNSIGNED (type))\n     return NULL;\n \n-  if (!vect_is_simple_use (oprnd1, last_stmt, vinfo, &def_stmt, &def, &dt))\n+  if (!vect_is_simple_use (oprnd1, vinfo, &def_stmt, &dt))\n     return NULL;\n \n   if (dt != vect_internal_def\n@@ -2058,7 +2054,6 @@ vect_recog_vector_vector_shift_pattern (vec<gimple *> *stmts,\n   stmt_vec_info stmt_vinfo = vinfo_for_stmt (last_stmt);\n   vec_info *vinfo = stmt_vinfo->vinfo;\n   enum vect_def_type dt;\n-  tree def;\n \n   if (!is_gimple_assign (last_stmt))\n     return NULL;\n@@ -2090,8 +2085,7 @@ vect_recog_vector_vector_shift_pattern (vec<gimple *> *stmts,\n \t != TYPE_PRECISION (TREE_TYPE (oprnd0)))\n     return NULL;\n \n-  if (!vect_is_simple_use (oprnd1, last_stmt, vinfo, &def_stmt,\n-\t\t\t   &def, &dt))\n+  if (!vect_is_simple_use (oprnd1, vinfo, &def_stmt, &dt))\n     return NULL;\n \n   if (dt != vect_internal_def)\n@@ -2102,7 +2096,7 @@ vect_recog_vector_vector_shift_pattern (vec<gimple *> *stmts,\n   if (*type_in == NULL_TREE)\n     return NULL;\n \n-  def = NULL_TREE;\n+  tree def = NULL_TREE;\n   if (gimple_assign_cast_p (def_stmt))\n     {\n       tree rhs1 = gimple_assign_rhs1 (def_stmt);\n@@ -2892,11 +2886,10 @@ check_bool_pattern (tree var, vec_info *vinfo)\n {\n   gimple *def_stmt;\n   enum vect_def_type dt;\n-  tree def, rhs1;\n+  tree rhs1;\n   enum tree_code rhs_code;\n \n-  if (!vect_is_simple_use (var, NULL, vinfo, &def_stmt, &def,\n-\t\t\t   &dt))\n+  if (!vect_is_simple_use (var, vinfo, &def_stmt, &dt))\n     return false;\n \n   if (dt != vect_internal_def)\n@@ -2905,7 +2898,7 @@ check_bool_pattern (tree var, vec_info *vinfo)\n   if (!is_gimple_assign (def_stmt))\n     return false;\n \n-  if (!has_single_use (def))\n+  if (!has_single_use (var))\n     return false;\n \n   rhs1 = gimple_assign_rhs1 (def_stmt);"}, {"sha": "142412314c129db2e1cf22f6a474965af6e4345a", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81c402418540b5a9476b52ba14b5096f87b0a6e5/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81c402418540b5a9476b52ba14b5096f87b0a6e5/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=81c402418540b5a9476b52ba14b5096f87b0a6e5", "patch": "@@ -234,7 +234,6 @@ vect_get_and_check_slp_defs (vec_info *vinfo,\n {\n   tree oprnd;\n   unsigned int i, number_of_oprnds;\n-  tree def;\n   gimple *def_stmt;\n   enum vect_def_type dt = vect_uninitialized_def;\n   struct loop *loop = NULL;\n@@ -287,8 +286,7 @@ vect_get_and_check_slp_defs (vec_info *vinfo,\n \n       oprnd_info = (*oprnds_info)[i];\n \n-      if (!vect_is_simple_use (oprnd, NULL, vinfo, &def_stmt,\n-\t\t\t       &def, &dt))\n+      if (!vect_is_simple_use (oprnd, vinfo, &def_stmt, &dt))\n \t{\n \t  if (dump_enabled_p ())\n \t    {\n@@ -355,19 +353,15 @@ vect_get_and_check_slp_defs (vec_info *vinfo,\n \n           switch (gimple_code (def_stmt))\n             {\n-              case GIMPLE_PHI:\n-                def = gimple_phi_result (def_stmt);\n-                break;\n+            case GIMPLE_PHI:\n+            case GIMPLE_ASSIGN:\n+\t      break;\n \n-              case GIMPLE_ASSIGN:\n-                def = gimple_assign_lhs (def_stmt);\n-                break;\n-\n-              default:\n-                if (dump_enabled_p ())\n-                  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t   \"unsupported defining stmt:\\n\");\n-                return -1;\n+\t    default:\n+\t      if (dump_enabled_p ())\n+\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t \"unsupported defining stmt:\\n\");\n+\t      return -1;\n             }\n         }\n \n@@ -432,7 +426,7 @@ vect_get_and_check_slp_defs (vec_info *vinfo,\n \t    {\n \t      dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t       \"Build SLP failed: illegal type of def \");\n-\t      dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, def);\n+\t      dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, oprnd);\n               dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n \t    }\n \n@@ -1555,12 +1549,12 @@ vect_analyze_slp_cost_1 (slp_instance instance, slp_tree node,\n   lhs = gimple_get_lhs (stmt);\n   for (i = 0; i < gimple_num_ops (stmt); ++i)\n     {\n-      tree def, op = gimple_op (stmt, i);\n+      tree op = gimple_op (stmt, i);\n       gimple *def_stmt;\n       enum vect_def_type dt;\n       if (!op || op == lhs)\n \tcontinue;\n-      if (vect_is_simple_use (op, NULL, stmt_info->vinfo, &def_stmt, &def, &dt))\n+      if (vect_is_simple_use (op, stmt_info->vinfo, &def_stmt, &dt))\n \t{\n \t  /* Without looking at the actual initializer a vector of\n \t     constants can be implemented as load from the constant pool."}, {"sha": "4f5895c195babe02ed58acc4bee5ce03c7c6dd02", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 102, "deletions": 216, "changes": 318, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81c402418540b5a9476b52ba14b5096f87b0a6e5/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81c402418540b5a9476b52ba14b5096f87b0a6e5/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=81c402418540b5a9476b52ba14b5096f87b0a6e5", "patch": "@@ -450,7 +450,6 @@ process_use (gimple *stmt, tree use, loop_vec_info loop_vinfo, bool live_p,\n   stmt_vec_info stmt_vinfo = vinfo_for_stmt (stmt);\n   stmt_vec_info dstmt_vinfo;\n   basic_block bb, def_bb;\n-  tree def;\n   gimple *def_stmt;\n   enum vect_def_type dt;\n \n@@ -459,7 +458,7 @@ process_use (gimple *stmt, tree use, loop_vec_info loop_vinfo, bool live_p,\n   if (!force && !exist_non_indexing_operands_for_use_p (use, stmt))\n      return true;\n \n-  if (!vect_is_simple_use (use, stmt, loop_vinfo, &def_stmt, &def, &dt))\n+  if (!vect_is_simple_use (use, loop_vinfo, &def_stmt, &dt))\n     {\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -1342,16 +1341,14 @@ vect_init_vector (gimple *stmt, tree val, tree type, gimple_stmt_iterator *gsi)\n    needs to be introduced.  */\n \n tree\n-vect_get_vec_def_for_operand (tree op, gimple *stmt, tree *scalar_def)\n+vect_get_vec_def_for_operand (tree op, gimple *stmt)\n {\n   tree vec_oprnd;\n   gimple *vec_stmt;\n   gimple *def_stmt;\n   stmt_vec_info def_stmt_info = NULL;\n   stmt_vec_info stmt_vinfo = vinfo_for_stmt (stmt);\n-  unsigned int nunits;\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n-  tree def;\n   enum vect_def_type dt;\n   bool is_simple_use;\n   tree vector_type;\n@@ -1364,19 +1361,11 @@ vect_get_vec_def_for_operand (tree op, gimple *stmt, tree *scalar_def)\n       dump_printf (MSG_NOTE, \"\\n\");\n     }\n \n-  is_simple_use = vect_is_simple_use (op, stmt, loop_vinfo,\n-\t\t\t\t      &def_stmt, &def, &dt);\n+  is_simple_use = vect_is_simple_use (op, loop_vinfo, &def_stmt, &dt);\n   gcc_assert (is_simple_use);\n   if (dump_enabled_p ())\n     {\n       int loc_printed = 0;\n-      if (def)\n-        {\n-          dump_printf_loc (MSG_NOTE, vect_location, \"def =  \");\n-          loc_printed = 1;\n-          dump_generic_expr (MSG_NOTE, TDF_SLIM, def);\n-          dump_printf (MSG_NOTE, \"\\n\");\n-        }\n       if (def_stmt)\n         {\n           if (loc_printed)\n@@ -1389,46 +1378,18 @@ vect_get_vec_def_for_operand (tree op, gimple *stmt, tree *scalar_def)\n \n   switch (dt)\n     {\n-    /* Case 1: operand is a constant.  */\n+    /* operand is a constant or a loop invariant.  */\n     case vect_constant_def:\n+    case vect_external_def:\n       {\n \tvector_type = get_vectype_for_scalar_type (TREE_TYPE (op));\n \tgcc_assert (vector_type);\n-\tnunits = TYPE_VECTOR_SUBPARTS (vector_type);\n-\n-\tif (scalar_def)\n-\t  *scalar_def = op;\n-\n-        /* Create 'vect_cst_ = {cst,cst,...,cst}'  */\n-        if (dump_enabled_p ())\n-          dump_printf_loc (MSG_NOTE, vect_location,\n-                           \"Create vector_cst. nunits = %d\\n\", nunits);\n-\n         return vect_init_vector (stmt, op, vector_type, NULL);\n       }\n \n-    /* Case 2: operand is defined outside the loop - loop invariant.  */\n-    case vect_external_def:\n-      {\n-\tvector_type = get_vectype_for_scalar_type (TREE_TYPE (def));\n-\tgcc_assert (vector_type);\n-\n-\tif (scalar_def)\n-\t  *scalar_def = def;\n-\n-        /* Create 'vec_inv = {inv,inv,..,inv}'  */\n-        if (dump_enabled_p ())\n-          dump_printf_loc (MSG_NOTE, vect_location, \"Create vector_inv.\\n\");\n-\n-        return vect_init_vector (stmt, def, vector_type, NULL);\n-      }\n-\n-    /* Case 3: operand is defined inside the loop.  */\n+    /* operand is defined inside the loop.  */\n     case vect_internal_def:\n       {\n-\tif (scalar_def)\n-\t  *scalar_def = NULL/* FIXME tuples: def_stmt*/;\n-\n         /* Get the def from the vectorized stmt.  */\n         def_stmt_info = vinfo_for_stmt (def_stmt);\n \n@@ -1449,22 +1410,14 @@ vect_get_vec_def_for_operand (tree op, gimple *stmt, tree *scalar_def)\n         return vec_oprnd;\n       }\n \n-    /* Case 4: operand is defined by a loop header phi - reduction  */\n+    /* operand is defined by a loop header phi - reduction  */\n     case vect_reduction_def:\n     case vect_double_reduction_def:\n     case vect_nested_cycle:\n-      {\n-\tstruct loop *loop;\n-\n-\tgcc_assert (gimple_code (def_stmt) == GIMPLE_PHI);\n-\tloop = (gimple_bb (def_stmt))->loop_father;\n-\n-        /* Get the def before the loop  */\n-        op = PHI_ARG_DEF_FROM_EDGE (def_stmt, loop_preheader_edge (loop));\n-        return get_initial_def_for_reduction (stmt, op, scalar_def);\n-     }\n+      /* Code should use get_initial_def_for_reduction.  */\n+      gcc_unreachable ();\n \n-    /* Case 5: operand is defined by loop-header phi - induction.  */\n+    /* operand is defined by loop-header phi - induction.  */\n     case vect_induction_def:\n       {\n \tgcc_assert (gimple_code (def_stmt) == GIMPLE_PHI);\n@@ -1618,13 +1571,13 @@ vect_get_vec_defs (tree op0, tree op1, gimple *stmt,\n       tree vec_oprnd;\n \n       vec_oprnds0->create (1);\n-      vec_oprnd = vect_get_vec_def_for_operand (op0, stmt, NULL);\n+      vec_oprnd = vect_get_vec_def_for_operand (op0, stmt);\n       vec_oprnds0->quick_push (vec_oprnd);\n \n       if (op1)\n \t{\n \t  vec_oprnds1->create (1);\n-\t  vec_oprnd = vect_get_vec_def_for_operand (op1, stmt, NULL);\n+\t  vec_oprnd = vect_get_vec_def_for_operand (op1, stmt);\n \t  vec_oprnds1->quick_push (vec_oprnd);\n \t}\n     }\n@@ -1753,7 +1706,6 @@ vectorizable_mask_load_store (gimple *stmt, gimple_stmt_iterator *gsi,\n   bool is_store;\n   tree mask;\n   gimple *def_stmt;\n-  tree def;\n   enum vect_def_type dt;\n \n   if (slp_node != NULL)\n@@ -1797,13 +1749,11 @@ vectorizable_mask_load_store (gimple *stmt, gimple_stmt_iterator *gsi,\n   if (STMT_VINFO_GATHER_SCATTER_P (stmt_info))\n     {\n       gimple *def_stmt;\n-      tree def;\n       gather_decl = vect_check_gather_scatter (stmt, loop_vinfo, &gather_base,\n \t\t\t\t       &gather_off, &gather_scale);\n       gcc_assert (gather_decl);\n-      if (!vect_is_simple_use_1 (gather_off, NULL, loop_vinfo,\n-\t\t\t\t &def_stmt, &def, &gather_dt,\n-\t\t\t\t &gather_off_vectype))\n+      if (!vect_is_simple_use (gather_off, loop_vinfo, &def_stmt, &gather_dt,\n+\t\t\t       &gather_off_vectype))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -1833,15 +1783,13 @@ vectorizable_mask_load_store (gimple *stmt, gimple_stmt_iterator *gsi,\n   if (TREE_CODE (mask) != SSA_NAME)\n     return false;\n \n-  if (!vect_is_simple_use (mask, stmt, loop_vinfo,\n-\t\t\t   &def_stmt, &def, &dt))\n+  if (!vect_is_simple_use (mask, loop_vinfo, &def_stmt, &dt))\n     return false;\n \n   if (is_store)\n     {\n       tree rhs = gimple_call_arg (stmt, 3);\n-      if (!vect_is_simple_use (rhs, stmt, loop_vinfo,\n-\t\t\t       &def_stmt, &def, &dt))\n+      if (!vect_is_simple_use (rhs, loop_vinfo, &def_stmt, &dt))\n \treturn false;\n     }\n \n@@ -1931,7 +1879,7 @@ vectorizable_mask_load_store (gimple *stmt, gimple_stmt_iterator *gsi,\n \t\t\t\t       perm_mask, stmt, gsi);\n \t  else if (j == 0)\n \t    op = vec_oprnd0\n-\t      = vect_get_vec_def_for_operand (gather_off, stmt, NULL);\n+\t      = vect_get_vec_def_for_operand (gather_off, stmt);\n \t  else\n \t    op = vec_oprnd0\n \t      = vect_get_vec_def_for_stmt_copy (gather_dt, vec_oprnd0);\n@@ -1955,11 +1903,10 @@ vectorizable_mask_load_store (gimple *stmt, gimple_stmt_iterator *gsi,\n \t  else\n \t    {\n \t      if (j == 0)\n-\t\tvec_mask = vect_get_vec_def_for_operand (mask, stmt, NULL);\n+\t\tvec_mask = vect_get_vec_def_for_operand (mask, stmt);\n \t      else\n \t\t{\n-\t\t  vect_is_simple_use (vec_mask, NULL, loop_vinfo,\n-\t\t\t\t      &def_stmt, &def, &dt);\n+\t\t  vect_is_simple_use (vec_mask, loop_vinfo, &def_stmt, &dt);\n \t\t  vec_mask = vect_get_vec_def_for_stmt_copy (dt, vec_mask);\n \t\t}\n \n@@ -2043,8 +1990,8 @@ vectorizable_mask_load_store (gimple *stmt, gimple_stmt_iterator *gsi,\n \t  if (i == 0)\n \t    {\n \t      tree rhs = gimple_call_arg (stmt, 3);\n-\t      vec_rhs = vect_get_vec_def_for_operand (rhs, stmt, NULL);\n-\t      vec_mask = vect_get_vec_def_for_operand (mask, stmt, NULL);\n+\t      vec_rhs = vect_get_vec_def_for_operand (rhs, stmt);\n+\t      vec_mask = vect_get_vec_def_for_operand (mask, stmt);\n \t      /* We should have catched mismatched types earlier.  */\n \t      gcc_assert (useless_type_conversion_p (vectype,\n \t\t\t\t\t\t     TREE_TYPE (vec_rhs)));\n@@ -2055,11 +2002,9 @@ vectorizable_mask_load_store (gimple *stmt, gimple_stmt_iterator *gsi,\n \t    }\n \t  else\n \t    {\n-\t      vect_is_simple_use (vec_rhs, NULL, loop_vinfo, &def_stmt,\n-\t\t\t\t  &def, &dt);\n+\t      vect_is_simple_use (vec_rhs, loop_vinfo, &def_stmt, &dt);\n \t      vec_rhs = vect_get_vec_def_for_stmt_copy (dt, vec_rhs);\n-\t      vect_is_simple_use (vec_mask, NULL, loop_vinfo, &def_stmt,\n-\t\t\t\t  &def, &dt);\n+\t      vect_is_simple_use (vec_mask, loop_vinfo, &def_stmt, &dt);\n \t      vec_mask = vect_get_vec_def_for_stmt_copy (dt, vec_mask);\n \t      dataref_ptr = bump_vector_ptr (dataref_ptr, ptr_incr, gsi, stmt,\n \t\t\t\t\t     TYPE_SIZE_UNIT (vectype));\n@@ -2100,16 +2045,15 @@ vectorizable_mask_load_store (gimple *stmt, gimple_stmt_iterator *gsi,\n \n \t  if (i == 0)\n \t    {\n-\t      vec_mask = vect_get_vec_def_for_operand (mask, stmt, NULL);\n+\t      vec_mask = vect_get_vec_def_for_operand (mask, stmt);\n \t      dataref_ptr = vect_create_data_ref_ptr (stmt, vectype, NULL,\n \t\t\t\t\t\t      NULL_TREE, &dummy, gsi,\n \t\t\t\t\t\t      &ptr_incr, false, &inv_p);\n \t      gcc_assert (!inv_p);\n \t    }\n \t  else\n \t    {\n-\t      vect_is_simple_use (vec_mask, NULL, loop_vinfo, &def_stmt,\n-\t\t\t\t  &def, &dt);\n+\t      vect_is_simple_use (vec_mask, loop_vinfo, &def_stmt, &dt);\n \t      vec_mask = vect_get_vec_def_for_stmt_copy (dt, vec_mask);\n \t      dataref_ptr = bump_vector_ptr (dataref_ptr, ptr_incr, gsi, stmt,\n \t\t\t\t\t     TYPE_SIZE_UNIT (vectype));\n@@ -2180,7 +2124,7 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n   vec_info *vinfo = stmt_info->vinfo;\n-  tree fndecl, new_temp, def, rhs_type;\n+  tree fndecl, new_temp, rhs_type;\n   gimple *def_stmt;\n   enum vect_def_type dt[3]\n     = {vect_unknown_def_type, vect_unknown_def_type, vect_unknown_def_type};\n@@ -2253,8 +2197,7 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n       if (!rhs_type)\n \trhs_type = TREE_TYPE (op);\n \n-      if (!vect_is_simple_use_1 (op, stmt, vinfo,\n-\t\t\t\t &def_stmt, &def, &dt[i], &opvectype))\n+      if (!vect_is_simple_use (op, vinfo, &def_stmt, &dt[i], &opvectype))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -2416,7 +2359,7 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t      op = gimple_call_arg (stmt, i);\n \t      if (j == 0)\n \t\tvec_oprnd0\n-\t\t  = vect_get_vec_def_for_operand (op, stmt, NULL);\n+\t\t  = vect_get_vec_def_for_operand (op, stmt);\n \t      else\n \t\t{\n \t\t  vec_oprnd0 = gimple_call_arg (new_stmt, i);\n@@ -2514,7 +2457,7 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t      if (j == 0)\n \t\t{\n \t\t  vec_oprnd0\n-\t\t    = vect_get_vec_def_for_operand (op, stmt, NULL);\n+\t\t    = vect_get_vec_def_for_operand (op, stmt);\n \t\t  vec_oprnd1\n \t\t    = vect_get_vec_def_for_stmt_copy (dt[i], vec_oprnd0);\n \t\t}\n@@ -2705,7 +2648,7 @@ vectorizable_simd_clone_call (gimple *stmt, gimple_stmt_iterator *gsi,\n   bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n   vec_info *vinfo = stmt_info->vinfo;\n   struct loop *loop = loop_vinfo ? LOOP_VINFO_LOOP (loop_vinfo) : NULL;\n-  tree fndecl, new_temp, def;\n+  tree fndecl, new_temp;\n   gimple *def_stmt;\n   gimple *new_stmt = NULL;\n   int ncopies, j;\n@@ -2768,9 +2711,8 @@ vectorizable_simd_clone_call (gimple *stmt, gimple_stmt_iterator *gsi,\n       thisarginfo.simd_lane_linear = false;\n \n       op = gimple_call_arg (stmt, i);\n-      if (!vect_is_simple_use_1 (op, stmt, vinfo,\n-\t\t\t\t &def_stmt, &def, &thisarginfo.dt,\n-\t\t\t\t &thisarginfo.vectype)\n+      if (!vect_is_simple_use (op, vinfo, &def_stmt, &thisarginfo.dt,\n+\t\t\t       &thisarginfo.vectype)\n \t  || thisarginfo.dt == vect_uninitialized_def)\n \t{\n \t  if (dump_enabled_p ())\n@@ -3047,7 +2989,7 @@ vectorizable_simd_clone_call (gimple *stmt, gimple_stmt_iterator *gsi,\n \t\t      gcc_assert ((k & (k - 1)) == 0);\n \t\t      if (m == 0)\n \t\t\tvec_oprnd0\n-\t\t\t  = vect_get_vec_def_for_operand (op, stmt, NULL);\n+\t\t\t  = vect_get_vec_def_for_operand (op, stmt);\n \t\t      else\n \t\t\t{\n \t\t\t  vec_oprnd0 = arginfo[i].op;\n@@ -3081,7 +3023,7 @@ vectorizable_simd_clone_call (gimple *stmt, gimple_stmt_iterator *gsi,\n \t\t\t{\n \t\t\t  if (m == 0 && l == 0)\n \t\t\t    vec_oprnd0\n-\t\t\t      = vect_get_vec_def_for_operand (op, stmt, NULL);\n+\t\t\t      = vect_get_vec_def_for_operand (op, stmt);\n \t\t\t  else\n \t\t\t    vec_oprnd0\n \t\t\t      = vect_get_vec_def_for_stmt_copy (arginfo[i].dt,\n@@ -3395,7 +3337,7 @@ vect_get_loop_based_defs (tree *oprnd, gimple *stmt, enum vect_def_type dt,\n   /* All the vector operands except the very first one (that is scalar oprnd)\n      are stmt copies.  */\n   if (TREE_CODE (TREE_TYPE (*oprnd)) != VECTOR_TYPE)\n-    vec_oprnd = vect_get_vec_def_for_operand (*oprnd, stmt, NULL);\n+    vec_oprnd = vect_get_vec_def_for_operand (*oprnd, stmt);\n   else\n     vec_oprnd = vect_get_vec_def_for_stmt_copy (dt, *oprnd);\n \n@@ -3555,7 +3497,6 @@ vectorizable_conversion (gimple *stmt, gimple_stmt_iterator *gsi,\n   enum tree_code codecvt1 = ERROR_MARK, codecvt2 = ERROR_MARK;\n   tree decl1 = NULL_TREE, decl2 = NULL_TREE;\n   tree new_temp;\n-  tree def;\n   gimple *def_stmt;\n   enum vect_def_type dt[2] = {vect_unknown_def_type, vect_unknown_def_type};\n   gimple *new_stmt = NULL;\n@@ -3633,8 +3574,7 @@ vectorizable_conversion (gimple *stmt, gimple_stmt_iterator *gsi,\n     }\n \n   /* Check the operands of the operation.  */\n-  if (!vect_is_simple_use_1 (op0, stmt, vinfo,\n-\t\t\t     &def_stmt, &def, &dt[0], &vectype_in))\n+  if (!vect_is_simple_use (op0, vinfo, &def_stmt, &dt[0], &vectype_in))\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -3650,11 +3590,9 @@ vectorizable_conversion (gimple *stmt, gimple_stmt_iterator *gsi,\n       /* For WIDEN_MULT_EXPR, if OP0 is a constant, use the type of\n \t OP1.  */\n       if (CONSTANT_CLASS_P (op0))\n-\tok = vect_is_simple_use_1 (op1, stmt, vinfo,\n-\t\t\t\t   &def_stmt, &def, &dt[1], &vectype_in);\n+\tok = vect_is_simple_use (op1, vinfo, &def_stmt, &dt[1], &vectype_in);\n       else\n-\tok = vect_is_simple_use (op1, stmt, vinfo, &def_stmt,\n-\t\t\t\t &def, &dt[1]);\n+\tok = vect_is_simple_use (op1, vinfo, &def_stmt, &dt[1]);\n \n       if (!ok)\n \t{\n@@ -3971,15 +3909,14 @@ vectorizable_conversion (gimple *stmt, gimple_stmt_iterator *gsi,\n \t\t}\n \t      else\n \t\t{\n-\t\t  vec_oprnd0 = vect_get_vec_def_for_operand (op0, stmt, NULL);\n+\t\t  vec_oprnd0 = vect_get_vec_def_for_operand (op0, stmt);\n \t\t  vec_oprnds0.quick_push (vec_oprnd0);\n \t\t  if (op_type == binary_op)\n \t\t    {\n \t\t      if (code == WIDEN_LSHIFT_EXPR)\n \t\t\tvec_oprnd1 = op1;\n \t\t      else\n-\t\t\tvec_oprnd1 = vect_get_vec_def_for_operand (op1, stmt,\n-\t\t\t\t\t\t\t\t   NULL);\n+\t\t\tvec_oprnd1 = vect_get_vec_def_for_operand (op1, stmt);\n \t\t      vec_oprnds1.quick_push (vec_oprnd1);\n \t\t    }\n \t\t}\n@@ -4133,7 +4070,6 @@ vectorizable_assignment (gimple *stmt, gimple_stmt_iterator *gsi,\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   tree new_temp;\n-  tree def;\n   gimple *def_stmt;\n   enum vect_def_type dt[2] = {vect_unknown_def_type, vect_unknown_def_type};\n   int ncopies;\n@@ -4185,8 +4121,7 @@ vectorizable_assignment (gimple *stmt, gimple_stmt_iterator *gsi,\n \n   gcc_assert (ncopies >= 1);\n \n-  if (!vect_is_simple_use_1 (op, stmt, vinfo,\n-\t\t\t     &def_stmt, &def, &dt[0], &vectype_in))\n+  if (!vect_is_simple_use (op, vinfo, &def_stmt, &dt[0], &vectype_in))\n     {\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -4340,7 +4275,6 @@ vectorizable_shift (gimple *stmt, gimple_stmt_iterator *gsi,\n   optab optab;\n   int icode;\n   machine_mode optab_op2_mode;\n-  tree def;\n   gimple *def_stmt;\n   enum vect_def_type dt[2] = {vect_unknown_def_type, vect_unknown_def_type};\n   gimple *new_stmt = NULL;\n@@ -4391,8 +4325,7 @@ vectorizable_shift (gimple *stmt, gimple_stmt_iterator *gsi,\n     }\n \n   op0 = gimple_assign_rhs1 (stmt);\n-  if (!vect_is_simple_use_1 (op0, stmt, vinfo,\n-                             &def_stmt, &def, &dt[0], &vectype))\n+  if (!vect_is_simple_use (op0, vinfo, &def_stmt, &dt[0], &vectype))\n     {\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -4419,8 +4352,7 @@ vectorizable_shift (gimple *stmt, gimple_stmt_iterator *gsi,\n     return false;\n \n   op1 = gimple_assign_rhs2 (stmt);\n-  if (!vect_is_simple_use_1 (op1, stmt, vinfo, &def_stmt,\n-\t\t\t     &def, &dt[1], &op1_vectype))\n+  if (!vect_is_simple_use (op1, vinfo, &def_stmt, &dt[1], &op1_vectype))\n     {\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -4705,7 +4637,6 @@ vectorizable_operation (gimple *stmt, gimple_stmt_iterator *gsi,\n   int op_type;\n   optab optab;\n   bool target_support_p;\n-  tree def;\n   gimple *def_stmt;\n   enum vect_def_type dt[3]\n     = {vect_unknown_def_type, vect_unknown_def_type, vect_unknown_def_type};\n@@ -4774,8 +4705,7 @@ vectorizable_operation (gimple *stmt, gimple_stmt_iterator *gsi,\n     }\n \n   op0 = gimple_assign_rhs1 (stmt);\n-  if (!vect_is_simple_use_1 (op0, stmt, vinfo,\n-\t\t\t     &def_stmt, &def, &dt[0], &vectype))\n+  if (!vect_is_simple_use (op0, vinfo, &def_stmt, &dt[0], &vectype))\n     {\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -4810,8 +4740,7 @@ vectorizable_operation (gimple *stmt, gimple_stmt_iterator *gsi,\n   if (op_type == binary_op || op_type == ternary_op)\n     {\n       op1 = gimple_assign_rhs2 (stmt);\n-      if (!vect_is_simple_use (op1, stmt, vinfo, &def_stmt,\n-\t\t\t       &def, &dt[1]))\n+      if (!vect_is_simple_use (op1, vinfo, &def_stmt, &dt[1]))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -4822,8 +4751,7 @@ vectorizable_operation (gimple *stmt, gimple_stmt_iterator *gsi,\n   if (op_type == ternary_op)\n     {\n       op2 = gimple_assign_rhs3 (stmt);\n-      if (!vect_is_simple_use (op2, stmt, vinfo, &def_stmt,\n-\t\t\t       &def, &dt[2]))\n+      if (!vect_is_simple_use (op2, vinfo, &def_stmt, &dt[2]))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -4984,8 +4912,7 @@ vectorizable_operation (gimple *stmt, gimple_stmt_iterator *gsi,\n \t    {\n \t      vec_oprnds2.create (1);\n \t      vec_oprnds2.quick_push (vect_get_vec_def_for_operand (op2,\n-\t\t                                                    stmt,\n-\t\t\t\t\t\t\t\t    NULL));\n+\t\t                                                    stmt));\n \t    }\n \t}\n       else\n@@ -5102,7 +5029,6 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n   machine_mode vec_mode;\n   tree dummy;\n   enum dr_alignment_support alignment_support_scheme;\n-  tree def;\n   gimple *def_stmt;\n   enum vect_def_type dt;\n   stmt_vec_info prev_stmt_info = NULL;\n@@ -5186,8 +5112,7 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n     }\n \n   op = gimple_assign_rhs1 (stmt);\n-  if (!vect_is_simple_use (op, stmt, vinfo, &def_stmt,\n-\t\t\t   &def, &dt))\n+  if (!vect_is_simple_use (op, vinfo, &def_stmt, &dt))\n     {\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -5277,8 +5202,7 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n             {\n \t      gcc_assert (gimple_assign_single_p (next_stmt));\n \t      op = gimple_assign_rhs1 (next_stmt);\n-              if (!vect_is_simple_use (op, next_stmt, vinfo,\n-\t\t\t\t       &def_stmt, &def, &dt))\n+              if (!vect_is_simple_use (op, vinfo, &def_stmt, &dt))\n                 {\n                   if (dump_enabled_p ())\n                     dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -5293,13 +5217,11 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n   if (STMT_VINFO_GATHER_SCATTER_P (stmt_info))\n     {\n       gimple *def_stmt;\n-      tree def;\n       scatter_decl = vect_check_gather_scatter (stmt, loop_vinfo, &scatter_base,\n \t\t\t\t\t\t&scatter_off, &scatter_scale);\n       gcc_assert (scatter_decl);\n-      if (!vect_is_simple_use_1 (scatter_off, NULL, vinfo,\n-\t\t\t\t &def_stmt, &def, &scatter_idx_dt,\n-\t\t\t\t &scatter_off_vectype))\n+      if (!vect_is_simple_use (scatter_off, vinfo, &def_stmt, &scatter_idx_dt,\n+\t\t\t       &scatter_off_vectype))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -5393,9 +5315,9 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t  if (j == 0)\n \t    {\n \t      src = vec_oprnd1\n-\t\t= vect_get_vec_def_for_operand (gimple_assign_rhs1 (stmt), stmt, NULL);\n+\t\t= vect_get_vec_def_for_operand (gimple_assign_rhs1 (stmt), stmt);\n \t      op = vec_oprnd0\n-\t\t= vect_get_vec_def_for_operand (scatter_off, stmt, NULL);\n+\t\t= vect_get_vec_def_for_operand (scatter_off, stmt);\n \t    }\n \t  else if (modifier != NONE && (j & 1))\n \t    {\n@@ -5613,8 +5535,7 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\t    {\n \t\t      gcc_assert (gimple_assign_single_p (next_stmt));\n \t\t      op = gimple_assign_rhs1 (next_stmt);\n-\t\t      vec_oprnd = vect_get_vec_def_for_operand (op, next_stmt,\n-\t\t\t\t\t\t\t\tNULL);\n+\t\t      vec_oprnd = vect_get_vec_def_for_operand (op, next_stmt);\n \t\t    }\n \t\t}\n \t      else\n@@ -5623,8 +5544,7 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\t    vec_oprnd = vec_oprnds[j];\n \t\t  else\n \t\t    {\n-\t\t      vect_is_simple_use (vec_oprnd, NULL, vinfo,\n-\t\t\t\t\t  &def_stmt, &def, &dt);\n+\t\t      vect_is_simple_use (vec_oprnd, vinfo, &def_stmt, &dt);\n \t\t      vec_oprnd = vect_get_vec_def_for_stmt_copy (dt, vec_oprnd);\n \t\t    }\n \t\t}\n@@ -5767,8 +5687,7 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\t\t      && gimple_assign_single_p (next_stmt));\n \t\t  op = gimple_assign_rhs1 (next_stmt);\n \n-\t\t  vec_oprnd = vect_get_vec_def_for_operand (op, next_stmt,\n-\t\t\t\t\t\t\t    NULL);\n+\t\t  vec_oprnd = vect_get_vec_def_for_operand (op, next_stmt);\n \t\t  dr_chain.quick_push (vec_oprnd);\n \t\t  oprnds.quick_push (vec_oprnd);\n \t\t  next_stmt = GROUP_NEXT_ELEMENT (vinfo_for_stmt (next_stmt));\n@@ -5813,8 +5732,7 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t  for (i = 0; i < group_size; i++)\n \t    {\n \t      op = oprnds[i];\n-\t      vect_is_simple_use (op, NULL, vinfo, &def_stmt,\n-\t\t\t\t  &def, &dt);\n+\t      vect_is_simple_use (op, vinfo, &def_stmt, &dt);\n \t      vec_oprnd = vect_get_vec_def_for_stmt_copy (dt, op);\n \t      dr_chain[i] = vec_oprnd;\n \t      oprnds[i] = vec_oprnd;\n@@ -6288,13 +6206,11 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n   if (STMT_VINFO_GATHER_SCATTER_P (stmt_info))\n     {\n       gimple *def_stmt;\n-      tree def;\n       gather_decl = vect_check_gather_scatter (stmt, loop_vinfo, &gather_base,\n \t\t\t\t\t       &gather_off, &gather_scale);\n       gcc_assert (gather_decl);\n-      if (!vect_is_simple_use_1 (gather_off, NULL, vinfo,\n-\t\t\t\t &def_stmt, &def, &gather_dt,\n-\t\t\t\t &gather_off_vectype))\n+      if (!vect_is_simple_use (gather_off, vinfo, &def_stmt, &gather_dt,\n+\t\t\t       &gather_off_vectype))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -6483,7 +6399,7 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\t\t\t       perm_mask, stmt, gsi);\n \t  else if (j == 0)\n \t    op = vec_oprnd0\n-\t      = vect_get_vec_def_for_operand (gather_off, stmt, NULL);\n+\t      = vect_get_vec_def_for_operand (gather_off, stmt);\n \t  else\n \t    op = vec_oprnd0\n \t      = vect_get_vec_def_for_stmt_copy (gather_dt, vec_oprnd0);\n@@ -7224,11 +7140,9 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n    condition operands are supportable using vec_is_simple_use.  */\n \n static bool\n-vect_is_simple_cond (tree cond, gimple *stmt, vec_info *vinfo,\n-\t\t     tree *comp_vectype)\n+vect_is_simple_cond (tree cond, vec_info *vinfo, tree *comp_vectype)\n {\n   tree lhs, rhs;\n-  tree def;\n   enum vect_def_type dt;\n   tree vectype1 = NULL_TREE, vectype2 = NULL_TREE;\n \n@@ -7241,8 +7155,7 @@ vect_is_simple_cond (tree cond, gimple *stmt, vec_info *vinfo,\n   if (TREE_CODE (lhs) == SSA_NAME)\n     {\n       gimple *lhs_def_stmt = SSA_NAME_DEF_STMT (lhs);\n-      if (!vect_is_simple_use_1 (lhs, stmt, vinfo,\n-\t\t\t\t &lhs_def_stmt, &def, &dt, &vectype1))\n+      if (!vect_is_simple_use (lhs, vinfo, &lhs_def_stmt, &dt, &vectype1))\n \treturn false;\n     }\n   else if (TREE_CODE (lhs) != INTEGER_CST && TREE_CODE (lhs) != REAL_CST\n@@ -7252,8 +7165,7 @@ vect_is_simple_cond (tree cond, gimple *stmt, vec_info *vinfo,\n   if (TREE_CODE (rhs) == SSA_NAME)\n     {\n       gimple *rhs_def_stmt = SSA_NAME_DEF_STMT (rhs);\n-      if (!vect_is_simple_use_1 (rhs, stmt, vinfo,\n-\t\t\t\t &rhs_def_stmt, &def, &dt, &vectype2))\n+      if (!vect_is_simple_use (rhs, vinfo, &rhs_def_stmt, &dt, &vectype2))\n \treturn false;\n     }\n   else if (TREE_CODE (rhs) != INTEGER_CST && TREE_CODE (rhs) != REAL_CST\n@@ -7292,7 +7204,6 @@ vectorizable_condition (gimple *stmt, gimple_stmt_iterator *gsi,\n   tree vec_compare, vec_cond_expr;\n   tree new_temp;\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n-  tree def;\n   enum vect_def_type dt, dts[4];\n   int ncopies;\n   enum tree_code code;\n@@ -7350,32 +7261,14 @@ vectorizable_condition (gimple *stmt, gimple_stmt_iterator *gsi,\n   then_clause = gimple_assign_rhs2 (stmt);\n   else_clause = gimple_assign_rhs3 (stmt);\n \n-  if (!vect_is_simple_cond (cond_expr, stmt, stmt_info->vinfo, &comp_vectype)\n+  if (!vect_is_simple_cond (cond_expr, stmt_info->vinfo, &comp_vectype)\n       || !comp_vectype)\n     return false;\n \n-  if (TREE_CODE (then_clause) == SSA_NAME)\n-    {\n-      gimple *then_def_stmt = SSA_NAME_DEF_STMT (then_clause);\n-      if (!vect_is_simple_use (then_clause, stmt, stmt_info->vinfo,\n-\t\t\t       &then_def_stmt, &def, &dt))\n-\treturn false;\n-    }\n-  else if (TREE_CODE (then_clause) != INTEGER_CST\n-\t   && TREE_CODE (then_clause) != REAL_CST\n-\t   && TREE_CODE (then_clause) != FIXED_CST)\n+  gimple *def_stmt;\n+  if (!vect_is_simple_use (then_clause, stmt_info->vinfo, &def_stmt, &dt))\n     return false;\n-\n-  if (TREE_CODE (else_clause) == SSA_NAME)\n-    {\n-      gimple *else_def_stmt = SSA_NAME_DEF_STMT (else_clause);\n-      if (!vect_is_simple_use (else_clause, stmt, stmt_info->vinfo,\n-\t\t\t       &else_def_stmt, &def, &dt))\n-\treturn false;\n-    }\n-  else if (TREE_CODE (else_clause) != INTEGER_CST\n-\t   && TREE_CODE (else_clause) != REAL_CST\n-\t   && TREE_CODE (else_clause) != FIXED_CST)\n+  if (!vect_is_simple_use (else_clause, stmt_info->vinfo, &def_stmt, &dt))\n     return false;\n \n   unsigned int prec = GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (vectype)));\n@@ -7433,33 +7326,31 @@ vectorizable_condition (gimple *stmt, gimple_stmt_iterator *gsi,\n             {\n \t      gimple *gtemp;\n \t      vec_cond_lhs =\n-\t      vect_get_vec_def_for_operand (TREE_OPERAND (cond_expr, 0),\n-\t\t\t\t\t    stmt, NULL);\n-\t      vect_is_simple_use (TREE_OPERAND (cond_expr, 0), stmt,\n-\t\t\t\t  loop_vinfo, &gtemp, &def, &dts[0]);\n+\t      vect_get_vec_def_for_operand (TREE_OPERAND (cond_expr, 0), stmt);\n+\t      vect_is_simple_use (TREE_OPERAND (cond_expr, 0),\n+\t\t\t\t  loop_vinfo, &gtemp, &dts[0]);\n \n \t      vec_cond_rhs =\n \t\tvect_get_vec_def_for_operand (TREE_OPERAND (cond_expr, 1),\n-\t\t\t\t\t\tstmt, NULL);\n-\t      vect_is_simple_use (TREE_OPERAND (cond_expr, 1), stmt,\n-\t\t\t\t  loop_vinfo, &gtemp, &def, &dts[1]);\n+\t\t\t\t\t      stmt);\n+\t      vect_is_simple_use (TREE_OPERAND (cond_expr, 1),\n+\t\t\t\t  loop_vinfo, &gtemp, &dts[1]);\n \t      if (reduc_index == 1)\n \t\tvec_then_clause = reduc_def;\n \t      else\n \t\t{\n \t\t  vec_then_clause = vect_get_vec_def_for_operand (then_clause,\n-\t\t \t\t  \t\t\t      stmt, NULL);\n-\t          vect_is_simple_use (then_clause, stmt, loop_vinfo,\n-\t\t\t\t      &gtemp, &def, &dts[2]);\n+\t\t\t\t\t\t\t\t  stmt);\n+\t          vect_is_simple_use (then_clause, loop_vinfo,\n+\t\t\t\t      &gtemp, &dts[2]);\n \t\t}\n \t      if (reduc_index == 2)\n \t\tvec_else_clause = reduc_def;\n \t      else\n \t\t{\n \t\t  vec_else_clause = vect_get_vec_def_for_operand (else_clause,\n-\t\t\t\t\t\t\t      stmt, NULL);\n-\t\t  vect_is_simple_use (else_clause, stmt, loop_vinfo,\n-\t\t\t\t      &gtemp, &def, &dts[3]);\n+\t\t\t\t\t\t\t\t  stmt);\n+\t\t  vect_is_simple_use (else_clause, loop_vinfo, &gtemp, &dts[3]);\n \t\t}\n \t    }\n \t}\n@@ -8200,10 +8091,11 @@ get_same_sized_vectype (tree scalar_type, tree vector_type)\n /* Function vect_is_simple_use.\n \n    Input:\n-   LOOP_VINFO - the vect info of the loop that is being vectorized.\n-   BB_VINFO - the vect info of the basic block that is being vectorized.\n-   OPERAND - operand of STMT in the loop or bb.\n-   DEF - the defining stmt in case OPERAND is an SSA_NAME.\n+   VINFO - the vect info of the loop or basic block that is being vectorized.\n+   OPERAND - operand in the loop or bb.\n+   Output:\n+   DEF_STMT - the defining stmt in case OPERAND is an SSA_NAME.\n+   DT - the type of definition\n \n    Returns whether a stmt with OPERAND can be vectorized.\n    For loops, supportable operands are constants, loop invariants, and operands\n@@ -8214,11 +8106,10 @@ get_same_sized_vectype (tree scalar_type, tree vector_type)\n    For now, operands defined outside the basic block are not supported.  */\n \n bool\n-vect_is_simple_use (tree operand, gimple *stmt, vec_info *vinfo,\n-                    gimple **def_stmt, tree *def, enum vect_def_type *dt)\n+vect_is_simple_use (tree operand, vec_info *vinfo,\n+                    gimple **def_stmt, enum vect_def_type *dt)\n {\n   *def_stmt = NULL;\n-  *def = NULL_TREE;\n   *dt = vect_unknown_def_type;\n \n   if (dump_enabled_p ())\n@@ -8237,7 +8128,6 @@ vect_is_simple_use (tree operand, gimple *stmt, vec_info *vinfo,\n \n   if (is_gimple_min_invariant (operand))\n     {\n-      *def = operand;\n       *dt = vect_external_def;\n       return true;\n     }\n@@ -8252,7 +8142,6 @@ vect_is_simple_use (tree operand, gimple *stmt, vec_info *vinfo,\n \n   if (SSA_NAME_IS_DEFAULT_DEF (operand))\n     {\n-      *def = operand;\n       *dt = vect_external_def;\n       return true;\n     }\n@@ -8315,10 +8204,7 @@ vect_is_simple_use (tree operand, gimple *stmt, vec_info *vinfo,\n \t}\n     }\n \n-  if (*dt == vect_unknown_def_type\n-      || (stmt\n-\t  && *dt == vect_double_reduction_def\n-\t  && gimple_code (stmt) != GIMPLE_PHI))\n+  if (*dt == vect_unknown_def_type)\n     {\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -8329,18 +8215,9 @@ vect_is_simple_use (tree operand, gimple *stmt, vec_info *vinfo,\n   switch (gimple_code (*def_stmt))\n     {\n     case GIMPLE_PHI:\n-      *def = gimple_phi_result (*def_stmt);\n-      break;\n-\n     case GIMPLE_ASSIGN:\n-      *def = gimple_assign_lhs (*def_stmt);\n-      break;\n-\n     case GIMPLE_CALL:\n-      *def = gimple_call_lhs (*def_stmt);\n-      if (*def != NULL)\n-\tbreak;\n-      /* FALLTHRU */\n+      break;\n     default:\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -8351,21 +8228,20 @@ vect_is_simple_use (tree operand, gimple *stmt, vec_info *vinfo,\n   return true;\n }\n \n-/* Function vect_is_simple_use_1.\n+/* Function vect_is_simple_use.\n \n-   Same as vect_is_simple_use_1 but also determines the vector operand\n+   Same as vect_is_simple_use but also determines the vector operand\n    type of OPERAND and stores it to *VECTYPE.  If the definition of\n    OPERAND is vect_uninitialized_def, vect_constant_def or\n    vect_external_def *VECTYPE will be set to NULL_TREE and the caller\n    is responsible to compute the best suited vector type for the\n    scalar operand.  */\n \n bool\n-vect_is_simple_use_1 (tree operand, gimple *stmt, vec_info *vinfo,\n-\t\t      gimple **def_stmt,\n-\t\t      tree *def, enum vect_def_type *dt, tree *vectype)\n+vect_is_simple_use (tree operand, vec_info *vinfo,\n+\t\t    gimple **def_stmt, enum vect_def_type *dt, tree *vectype)\n {\n-  if (!vect_is_simple_use (operand, stmt, vinfo, def_stmt, def, dt))\n+  if (!vect_is_simple_use (operand, vinfo, def_stmt, dt))\n     return false;\n \n   /* Now get a vector type if the def is internal, otherwise supply\n@@ -8506,6 +8382,16 @@ supportable_widening_operation (enum tree_code code, gimple *stmt,\n       c2 = VEC_WIDEN_MULT_HI_EXPR;\n       break;\n \n+    case DOT_PROD_EXPR:\n+      c1 = DOT_PROD_EXPR;\n+      c2 = DOT_PROD_EXPR;\n+      break;\n+\n+    case SAD_EXPR:\n+      c1 = SAD_EXPR;\n+      c2 = SAD_EXPR;\n+      break;\n+\n     case VEC_WIDEN_MULT_EVEN_EXPR:\n       /* Support the recursion induced just above.  */\n       c1 = VEC_WIDEN_MULT_EVEN_EXPR;"}, {"sha": "aca3ccc286a5f3d7ff34b7b13ac7b32103e542d7", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81c402418540b5a9476b52ba14b5096f87b0a6e5/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81c402418540b5a9476b52ba14b5096f87b0a6e5/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=81c402418540b5a9476b52ba14b5096f87b0a6e5", "patch": "@@ -932,10 +932,10 @@ extern bool vect_can_advance_ivs_p (loop_vec_info);\n extern unsigned int current_vector_size;\n extern tree get_vectype_for_scalar_type (tree);\n extern tree get_same_sized_vectype (tree, tree);\n-extern bool vect_is_simple_use (tree, gimple *, vec_info *, gimple **,\n-                                tree *,  enum vect_def_type *);\n-extern bool vect_is_simple_use_1 (tree, gimple *, vec_info *, gimple **,\n-\t\t\t\t  tree *,  enum vect_def_type *, tree *);\n+extern bool vect_is_simple_use (tree, vec_info *, gimple **,\n+                                enum vect_def_type *);\n+extern bool vect_is_simple_use (tree, vec_info *, gimple **,\n+\t\t\t\tenum vect_def_type *, tree *);\n extern bool supportable_widening_operation (enum tree_code, gimple *, tree,\n \t\t\t\t\t    tree, enum tree_code *,\n \t\t\t\t\t    enum tree_code *, int *,\n@@ -962,7 +962,7 @@ extern unsigned record_stmt_cost (stmt_vector_for_cost *, int,\n extern void vect_finish_stmt_generation (gimple *, gimple *,\n                                          gimple_stmt_iterator *);\n extern bool vect_mark_stmts_to_be_vectorized (loop_vec_info);\n-extern tree vect_get_vec_def_for_operand (tree, gimple *, tree *);\n+extern tree vect_get_vec_def_for_operand (tree, gimple *);\n extern tree vect_init_vector (gimple *, tree, tree,\n                               gimple_stmt_iterator *);\n extern tree vect_get_vec_def_for_stmt_copy (enum vect_def_type, tree);"}]}