{"sha": "4fd20a8f82fb5cd17fd32a5218054447d45ada69", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGZkMjBhOGY4MmZiNWNkMTdmZDMyYTUyMTgwNTQ0NDdkNDVhZGE2OQ==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2005-06-03T17:07:48Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2005-06-03T17:07:48Z"}, "message": "re PR libstdc++/21770 (rebinding allocator::value type vs. container::value_type)\n\n2005-06-03  Paolo Carlini  <pcarlini@suse.de>\n\n\tPR libstdc++/21770\n\t* include/bits/stl_deque.h: Add concept-check. In class _Deque_base\n\trebind _Alloc to  _Tp_alloc_type, change _Deque_impl to inherit from\n\tthe latter and add _M_get_Tp_allocator() which returns it. Use\n\teverywhere _M_get_Tp_allocator() instead of get_allocator().\n\t* include/bits/deque.tcc: Likewise, use _M_get_Tp_allocator().\n\t* include/bits/stl_list.h: Add concept-check. In class _List_base\n\trebind _Alloc to _Tp_alloc_type and add _M_get_Tp_allocator(), which\n\treturns the allocator (of type _Node_alloc_type) converted to\n\t_Tp_alloc_type. Use everywhere _M_get_Tp_allocator() instead of\n\tget_allocator().\n\t* include/bits/list.tcc: Likewise, use _M_get_Tp_allocator().\n\t* include/bits/stl_vector.h: Add concept-check. In class _Vector_base\n\trebind _Alloc to _Tp_alloc_type, change _Vector_impl to inherit from\n\tthe latter and add _M_get_Tp_allocator() which returns it. Use\n\teverywhere _M_get_Tp_allocator() instead of get_allocator().\n\t* include/bits/vector.tcc: Likewise, use _M_get_Tp_allocator().\n\t* include/bits/stl_map.h: Add concept-check. Rebind _Alloc to\n\t_Pair_alloc_type and use it for _Rb_tree.\n\t* include/bits/stl_multimap.h: Likewise.\n\t* include/bits/stl_multiset.h: Add concept-check. Rebind _Alloc to\n\t_Key_alloc_type and use it for _Rb_tree.\n\t* include/bits/stl_set.h: Likewise.\n\t* include/bits/basic_string.h: Rebind _Alloc to _CharT_alloc_type and\n\tuse it for the allocator typedefs.\n\t* testsuite/21_strings/basic_string/1.cc: New.\n\t* testsuite/23_containers/deque/explicit_instantiation.cc: Move to...\n\t* testsuite/23_containers/deque/explicit_instantiation/1.cc: ... here.\n\t* testsuite/23_containers/deque/explicit_instantiation/3.cc: New.\n\t* testsuite/23_containers/list/explicit_instantiation.cc: Move to...\n\t* testsuite/23_containers/list/explicit_instantiation/1.cc: ... here.\n\t* testsuite/23_containers/list/explicit_instantiation/3.cc: New.\n\t* testsuite/23_containers/map/explicit_instantiation.cc: Move to...\n\t* testsuite/23_containers/map/explicit_instantiation/1.cc: ... here.\n\t* testsuite/23_containers/map/explicit_instantiation/3.cc: New.\n\t* testsuite/23_containers/multimap/explicit_instantiation.cc: Move to...\n\t* testsuite/23_containers/multimap/explicit_instantiation/1.cc: .. here.\n\t* testsuite/23_containers/multimap/explicit_instantiation/3.cc: New.\n\t* testsuite/23_containers/multiset/explicit_instantiation.cc: Move to...\n\t* testsuite/23_containers/multiset/explicit_instantiation/1.cc: .. here.\n\t* testsuite/23_containers/multiset/explicit_instantiation/3.cc: New.\n\t* testsuite/23_containers/set/explicit_instantiation.cc: Move to...\n\t* testsuite/23_containers/set/explicit_instantiation/1.cc: .. here.\n\t* testsuite/23_containers/set/explicit_instantiation/3.cc: New.\n\t* testsuite/23_containers/vector/explicit_instantiation.cc: Move to...\n\t* testsuite/23_containers/vector/explicit_instantiation/1.cc: ... here.\n\t* testsuite/23_containers/vector/explicit_instantiation/3.cc: New.\n\nFrom-SVN: r100546", "tree": {"sha": "3dc79fd4bce1161aa370210090c89aa751651c79", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3dc79fd4bce1161aa370210090c89aa751651c79"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4fd20a8f82fb5cd17fd32a5218054447d45ada69", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fd20a8f82fb5cd17fd32a5218054447d45ada69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fd20a8f82fb5cd17fd32a5218054447d45ada69", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fd20a8f82fb5cd17fd32a5218054447d45ada69/comments", "author": null, "committer": null, "parents": [{"sha": "7e45bd18daca810d7ecbd83ffcd9e97d31de0f12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e45bd18daca810d7ecbd83ffcd9e97d31de0f12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e45bd18daca810d7ecbd83ffcd9e97d31de0f12"}], "stats": {"total": 926, "additions": 660, "deletions": 266}, "files": [{"sha": "77cc306df75e4da0df12f27bc01fd6a639fbbcc1", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fd20a8f82fb5cd17fd32a5218054447d45ada69/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fd20a8f82fb5cd17fd32a5218054447d45ada69/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=4fd20a8f82fb5cd17fd32a5218054447d45ada69", "patch": "@@ -1,3 +1,53 @@\n+2005-06-03  Paolo Carlini  <pcarlini@suse.de>\n+\n+\tPR libstdc++/21770\n+\t* include/bits/stl_deque.h: Add concept-check. In class _Deque_base\n+\trebind _Alloc to  _Tp_alloc_type, change _Deque_impl to inherit from\n+\tthe latter and add _M_get_Tp_allocator() which returns it. Use\n+\teverywhere _M_get_Tp_allocator() instead of get_allocator().\n+\t* include/bits/deque.tcc: Likewise, use _M_get_Tp_allocator().\n+\t* include/bits/stl_list.h: Add concept-check. In class _List_base\n+\trebind _Alloc to _Tp_alloc_type and add _M_get_Tp_allocator(), which\n+\treturns the allocator (of type _Node_alloc_type) converted to\n+\t_Tp_alloc_type. Use everywhere _M_get_Tp_allocator() instead of\n+\tget_allocator().\n+\t* include/bits/list.tcc: Likewise, use _M_get_Tp_allocator().\n+\t* include/bits/stl_vector.h: Add concept-check. In class _Vector_base\n+\trebind _Alloc to _Tp_alloc_type, change _Vector_impl to inherit from\n+\tthe latter and add _M_get_Tp_allocator() which returns it. Use\n+\teverywhere _M_get_Tp_allocator() instead of get_allocator().\n+\t* include/bits/vector.tcc: Likewise, use _M_get_Tp_allocator().\n+\t* include/bits/stl_map.h: Add concept-check. Rebind _Alloc to\n+\t_Pair_alloc_type and use it for _Rb_tree.\n+\t* include/bits/stl_multimap.h: Likewise.\n+\t* include/bits/stl_multiset.h: Add concept-check. Rebind _Alloc to\n+\t_Key_alloc_type and use it for _Rb_tree.\n+\t* include/bits/stl_set.h: Likewise.\n+\t* include/bits/basic_string.h: Rebind _Alloc to _CharT_alloc_type and\n+\tuse it for the allocator typedefs.\n+\t* testsuite/21_strings/basic_string/1.cc: New.\n+\t* testsuite/23_containers/deque/explicit_instantiation.cc: Move to...\n+\t* testsuite/23_containers/deque/explicit_instantiation/1.cc: ... here.\n+\t* testsuite/23_containers/deque/explicit_instantiation/3.cc: New.\n+\t* testsuite/23_containers/list/explicit_instantiation.cc: Move to...\n+\t* testsuite/23_containers/list/explicit_instantiation/1.cc: ... here.\n+\t* testsuite/23_containers/list/explicit_instantiation/3.cc: New.\n+\t* testsuite/23_containers/map/explicit_instantiation.cc: Move to...\n+\t* testsuite/23_containers/map/explicit_instantiation/1.cc: ... here.\n+\t* testsuite/23_containers/map/explicit_instantiation/3.cc: New.\n+\t* testsuite/23_containers/multimap/explicit_instantiation.cc: Move to...\n+\t* testsuite/23_containers/multimap/explicit_instantiation/1.cc: .. here.\n+\t* testsuite/23_containers/multimap/explicit_instantiation/3.cc: New.\n+\t* testsuite/23_containers/multiset/explicit_instantiation.cc: Move to...\n+\t* testsuite/23_containers/multiset/explicit_instantiation/1.cc: .. here.\n+\t* testsuite/23_containers/multiset/explicit_instantiation/3.cc: New.\n+\t* testsuite/23_containers/set/explicit_instantiation.cc: Move to...\n+\t* testsuite/23_containers/set/explicit_instantiation/1.cc: .. here.\n+\t* testsuite/23_containers/set/explicit_instantiation/3.cc: New.\n+\t* testsuite/23_containers/vector/explicit_instantiation.cc: Move to...\n+\t* testsuite/23_containers/vector/explicit_instantiation/1.cc: ... here.\n+\t* testsuite/23_containers/vector/explicit_instantiation/3.cc: New.\n+\n 2005-06-02  Nathan Sidwell  <nathan@codesourcery.com>\n \n \tPR c++/21280"}, {"sha": "07b66d6d615954825704d721eea7ad14217ab745", "filename": "libstdc++-v3/include/bits/basic_string.h", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fd20a8f82fb5cd17fd32a5218054447d45ada69/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fd20a8f82fb5cd17fd32a5218054447d45ada69/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.h?ref=4fd20a8f82fb5cd17fd32a5218054447d45ada69", "patch": "@@ -109,17 +109,19 @@ namespace std\n   template<typename _CharT, typename _Traits, typename _Alloc>\n     class basic_string\n     {\n+      typedef typename _Alloc::template rebind<_CharT>::other _CharT_alloc_type;\n+\n       // Types:\n     public:\n       typedef _Traits\t\t\t\t\t    traits_type;\n       typedef typename _Traits::char_type\t\t    value_type;\n       typedef _Alloc\t\t\t\t\t    allocator_type;\n-      typedef typename _Alloc::size_type\t\t    size_type;\n-      typedef typename _Alloc::difference_type\t\t    difference_type;\n-      typedef typename _Alloc::reference\t\t    reference;\n-      typedef typename _Alloc::const_reference\t\t    const_reference;\n-      typedef typename _Alloc::pointer\t\t\t    pointer;\n-      typedef typename _Alloc::const_pointer\t\t    const_pointer;\n+      typedef typename _CharT_alloc_type::size_type\t    size_type;\n+      typedef typename _CharT_alloc_type::difference_type   difference_type;\n+      typedef typename _CharT_alloc_type::reference\t    reference;\n+      typedef typename _CharT_alloc_type::const_reference   const_reference;\n+      typedef typename _CharT_alloc_type::pointer\t    pointer;\n+      typedef typename _CharT_alloc_type::const_pointer\t    const_pointer;\n       typedef __gnu_cxx::__normal_iterator<pointer, basic_string>  iterator;\n       typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>\n                                                             const_iterator;"}, {"sha": "35ceb69b402f43a9df508518bd20839624d59c49", "filename": "libstdc++-v3/include/bits/deque.tcc", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fd20a8f82fb5cd17fd32a5218054447d45ada69/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fdeque.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fd20a8f82fb5cd17fd32a5218054447d45ada69/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fdeque.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fdeque.tcc?ref=4fd20a8f82fb5cd17fd32a5218054447d45ada69", "patch": "@@ -147,7 +147,7 @@ namespace _GLIBCXX_STD\n \t      std::copy_backward(this->_M_impl._M_start, __first, __last);\n \t      iterator __new_start = this->_M_impl._M_start + __n;\n \t      std::_Destroy(this->_M_impl._M_start, __new_start,\n-\t\t\t    this->get_allocator());\n+\t\t\t    _M_get_Tp_allocator());\n \t      _M_destroy_nodes(this->_M_impl._M_start._M_node,\n \t\t\t       __new_start._M_node);\n \t      this->_M_impl._M_start = __new_start;\n@@ -157,7 +157,7 @@ namespace _GLIBCXX_STD\n \t      std::copy(__last, this->_M_impl._M_finish, __first);\n \t      iterator __new_finish = this->_M_impl._M_finish - __n;\n \t      std::_Destroy(__new_finish, this->_M_impl._M_finish,\n-\t\t\t    this->get_allocator());\n+\t\t\t    _M_get_Tp_allocator());\n \t      _M_destroy_nodes(__new_finish._M_node + 1,\n \t\t\t       this->_M_impl._M_finish._M_node + 1);\n \t      this->_M_impl._M_finish = __new_finish;\n@@ -176,24 +176,24 @@ namespace _GLIBCXX_STD\n            ++__node)\n \t{\n \t  std::_Destroy(*__node, *__node + _S_buffer_size(),\n-\t\t\tthis->get_allocator());\n+\t\t\t_M_get_Tp_allocator());\n \t  _M_deallocate_node(*__node);\n \t}\n \n       if (this->_M_impl._M_start._M_node != this->_M_impl._M_finish._M_node)\n \t{\n \t  std::_Destroy(this->_M_impl._M_start._M_cur,\n \t\t\tthis->_M_impl._M_start._M_last,\n-\t\t\tthis->get_allocator());\n+\t\t\t_M_get_Tp_allocator());\n \t  std::_Destroy(this->_M_impl._M_finish._M_first,\n \t\t\tthis->_M_impl._M_finish._M_cur,\n-\t\t\tthis->get_allocator());\n+\t\t\t_M_get_Tp_allocator());\n \t  _M_deallocate_node(this->_M_impl._M_finish._M_first);\n \t}\n       else\n         std::_Destroy(this->_M_impl._M_start._M_cur,\n \t\t      this->_M_impl._M_finish._M_cur,\n-\t\t      this->get_allocator());\n+\t\t      _M_get_Tp_allocator());\n \n       this->_M_impl._M_finish = this->_M_impl._M_start;\n     }\n@@ -226,7 +226,7 @@ namespace _GLIBCXX_STD\n \t    {\n \t      std::__uninitialized_fill_a(__new_start, this->_M_impl._M_start,\n \t\t\t\t\t  __x,\n-\t\t\t\t\t  this->get_allocator());\n+\t\t\t\t\t  _M_get_Tp_allocator());\n \t      this->_M_impl._M_start = __new_start;\n \t    }\n \t  catch(...)\n@@ -243,7 +243,7 @@ namespace _GLIBCXX_STD\n \t    {\n \t      std::__uninitialized_fill_a(this->_M_impl._M_finish,\n \t\t\t\t\t  __new_finish, __x,\n-\t\t\t\t\t  this->get_allocator());\n+\t\t\t\t\t  _M_get_Tp_allocator());\n \t      this->_M_impl._M_finish = __new_finish;\n \t    }\n \t  catch(...)\n@@ -269,15 +269,15 @@ namespace _GLIBCXX_STD\n \t       __cur < this->_M_impl._M_finish._M_node;\n \t       ++__cur)\n             std::__uninitialized_fill_a(*__cur, *__cur + _S_buffer_size(),\n-\t\t\t\t\t__value, this->get_allocator());\n+\t\t\t\t\t__value, _M_get_Tp_allocator());\n           std::__uninitialized_fill_a(this->_M_impl._M_finish._M_first,\n \t\t\t\t      this->_M_impl._M_finish._M_cur,\n-\t\t\t\t      __value, this->get_allocator());\n+\t\t\t\t      __value, _M_get_Tp_allocator());\n         }\n       catch(...)\n         {\n           std::_Destroy(this->_M_impl._M_start, iterator(*__cur, __cur),\n-\t\t\tthis->get_allocator());\n+\t\t\t_M_get_Tp_allocator());\n           __throw_exception_again;\n         }\n     }\n@@ -322,18 +322,18 @@ namespace _GLIBCXX_STD\n               _ForwardIterator __mid = __first;\n               std::advance(__mid, _S_buffer_size());\n               std::__uninitialized_copy_a(__first, __mid, *__cur_node,\n-\t\t\t\t\t  this->get_allocator());\n+\t\t\t\t\t  _M_get_Tp_allocator());\n               __first = __mid;\n             }\n             std::__uninitialized_copy_a(__first, __last,\n \t\t\t\t\tthis->_M_impl._M_finish._M_first,\n-\t\t\t\t\tthis->get_allocator());\n+\t\t\t\t\t_M_get_Tp_allocator());\n           }\n         catch(...)\n           {\n             std::_Destroy(this->_M_impl._M_start,\n \t\t\t  iterator(*__cur_node, __cur_node),\n-\t\t\t  this->get_allocator());\n+\t\t\t  _M_get_Tp_allocator());\n             __throw_exception_again;\n           }\n       }\n@@ -435,7 +435,7 @@ namespace _GLIBCXX_STD\n \t    try\n \t      {\n \t\tstd::__uninitialized_copy_a(__first, __last, __new_start,\n-\t\t\t\t\t    this->get_allocator());\n+\t\t\t\t\t    _M_get_Tp_allocator());\n \t\tthis->_M_impl._M_start = __new_start;\n \t      }\n \t    catch(...)\n@@ -452,7 +452,7 @@ namespace _GLIBCXX_STD\n \t      {\n \t\tstd::__uninitialized_copy_a(__first, __last,\n \t\t\t\t\t    this->_M_impl._M_finish,\n-\t\t\t\t\t    this->get_allocator());\n+\t\t\t\t\t    _M_get_Tp_allocator());\n \t\tthis->_M_impl._M_finish = __new_finish;\n \t      }\n \t    catch(...)\n@@ -520,7 +520,7 @@ namespace _GLIBCXX_STD\n \t\t\t\t\t+ difference_type(__n));\n \t\t  std::__uninitialized_copy_a(this->_M_impl._M_start,\n \t\t\t\t\t      __start_n, __new_start,\n-\t\t\t\t\t      this->get_allocator());\n+\t\t\t\t\t      _M_get_Tp_allocator());\n \t\t  this->_M_impl._M_start = __new_start;\n \t\t  std::copy(__start_n, __pos, __old_start);\n \t\t  fill(__pos - difference_type(__n), __pos, __x_copy);\n@@ -531,7 +531,7 @@ namespace _GLIBCXX_STD\n \t\t\t\t\t\t __pos, __new_start,\n \t\t\t\t\t\t this->_M_impl._M_start,\n \t\t\t\t\t\t __x_copy,\n-\t\t\t\t\t\t this->get_allocator());\n+\t\t\t\t\t\t _M_get_Tp_allocator());\n \t\t  this->_M_impl._M_start = __new_start;\n \t\t  std::fill(__old_start, __pos, __x_copy);\n \t\t}\n@@ -559,7 +559,7 @@ namespace _GLIBCXX_STD\n \t\t  std::__uninitialized_copy_a(__finish_n,\n \t\t\t\t\t      this->_M_impl._M_finish,\n \t\t\t\t\t      this->_M_impl._M_finish,\n-\t\t\t\t\t      this->get_allocator());\n+\t\t\t\t\t      _M_get_Tp_allocator());\n \t\t  this->_M_impl._M_finish = __new_finish;\n \t\t  std::copy_backward(__pos, __finish_n, __old_finish);\n \t\t  std::fill(__pos, __pos + difference_type(__n), __x_copy);\n@@ -570,7 +570,7 @@ namespace _GLIBCXX_STD\n \t\t\t\t\t\t __pos + difference_type(__n),\n \t\t\t\t\t\t __x_copy, __pos,\n \t\t\t\t\t\t this->_M_impl._M_finish,\n-\t\t\t\t\t\t this->get_allocator());\n+\t\t\t\t\t\t _M_get_Tp_allocator());\n \t\t  this->_M_impl._M_finish = __new_finish;\n \t\t  std::fill(__pos, __old_finish, __x_copy);\n \t\t}\n@@ -607,7 +607,7 @@ namespace _GLIBCXX_STD\n \t\t\t\t\t  + difference_type(__n));\n \t\t    std::__uninitialized_copy_a(this->_M_impl._M_start,\n \t\t\t\t\t\t__start_n, __new_start,\n-\t\t\t\t\t\tthis->get_allocator());\n+\t\t\t\t\t\t_M_get_Tp_allocator());\n \t\t    this->_M_impl._M_start = __new_start;\n \t\t    std::copy(__start_n, __pos, __old_start);\n \t\t    std::copy(__first, __last, __pos - difference_type(__n));\n@@ -619,7 +619,7 @@ namespace _GLIBCXX_STD\n \t\t    std::__uninitialized_copy_copy(this->_M_impl._M_start,\n \t\t\t\t\t\t   __pos, __first, __mid,\n \t\t\t\t\t\t   __new_start,\n-\t\t\t\t\t\t   this->get_allocator());\n+\t\t\t\t\t\t   _M_get_Tp_allocator());\n \t\t    this->_M_impl._M_start = __new_start;\n \t\t    std::copy(__mid, __last, __old_start);\n \t\t  }\n@@ -647,7 +647,7 @@ namespace _GLIBCXX_STD\n \t\t  std::__uninitialized_copy_a(__finish_n,\n \t\t\t\t\t      this->_M_impl._M_finish,\n \t\t\t\t\t      this->_M_impl._M_finish,\n-\t\t\t\t\t      this->get_allocator());\n+\t\t\t\t\t      _M_get_Tp_allocator());\n \t\t  this->_M_impl._M_finish = __new_finish;\n \t\t  std::copy_backward(__pos, __finish_n, __old_finish);\n \t\t  std::copy(__first, __last, __pos);\n@@ -659,7 +659,7 @@ namespace _GLIBCXX_STD\n \t\t  std::__uninitialized_copy_copy(__mid, __last, __pos,\n \t\t\t\t\t\t this->_M_impl._M_finish,\n \t\t\t\t\t\t this->_M_impl._M_finish,\n-\t\t\t\t\t\t this->get_allocator());\n+\t\t\t\t\t\t _M_get_Tp_allocator());\n \t\t  this->_M_impl._M_finish = __new_finish;\n \t\t  std::copy(__first, __mid, __pos);\n \t\t}"}, {"sha": "14ea0f0dbfac778616c41e43e29e1e53b2b8fd4c", "filename": "libstdc++-v3/include/bits/list.tcc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fd20a8f82fb5cd17fd32a5218054447d45ada69/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flist.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fd20a8f82fb5cd17fd32a5218054447d45ada69/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flist.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flist.tcc?ref=4fd20a8f82fb5cd17fd32a5218054447d45ada69", "patch": "@@ -74,7 +74,7 @@ namespace _GLIBCXX_STD\n \t{\n \t  _Node* __tmp = __cur;\n \t  __cur = static_cast<_Node*>(__cur->_M_next);\n-\t  this->get_allocator().destroy(&__tmp->_M_data);\n+\t  _M_get_Tp_allocator().destroy(&__tmp->_M_data);\n \t  _M_put_node(__tmp);\n \t}\n     }"}, {"sha": "249c4f2e7ee88b43e4ee6c87b0b664e3bb4b2cc3", "filename": "libstdc++-v3/include/bits/stl_deque.h", "status": "modified", "additions": 38, "deletions": 21, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fd20a8f82fb5cd17fd32a5218054447d45ada69/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fd20a8f82fb5cd17fd32a5218054447d45ada69/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h?ref=4fd20a8f82fb5cd17fd32a5218054447d45ada69", "patch": "@@ -358,7 +358,7 @@ namespace _GLIBCXX_STD\n \n       allocator_type\n       get_allocator() const\n-      { return *static_cast<const _Alloc*>(&this->_M_impl); }\n+      { return _M_get_Tp_allocator(); }\n \n       typedef _Deque_iterator<_Tp, _Tp&, _Tp*>             iterator;\n       typedef _Deque_iterator<_Tp, const _Tp&, const _Tp*> const_iterator;\n@@ -377,30 +377,43 @@ namespace _GLIBCXX_STD\n       //This struct encapsulates the implementation of the std::deque\n       //standard container and at the same time makes use of the EBO\n       //for empty allocators.\n+      typedef typename _Alloc::template rebind<_Tp*>::other _Map_alloc_type;\n+\n+      typedef typename _Alloc::template rebind<_Tp>::other  _Tp_alloc_type;\n+\n       struct _Deque_impl\n-      : public _Alloc\n+      : public _Tp_alloc_type\n       {\n \t_Tp** _M_map;\n \tsize_t _M_map_size;\n \titerator _M_start;\n \titerator _M_finish;\n \n-\t_Deque_impl(const _Alloc& __a)\n-\t: _Alloc(__a), _M_map(0), _M_map_size(0), _M_start(), _M_finish()\n+\t_Deque_impl(const _Tp_alloc_type& __a)\n+\t: _Tp_alloc_type(__a), _M_map(0), _M_map_size(0),\n+\t  _M_start(), _M_finish()\n \t{ }\n       };\n \n-      typedef typename _Alloc::template rebind<_Tp*>::other _Map_alloc_type;\n-      _Map_alloc_type _M_get_map_allocator() const\n-      { return _Map_alloc_type(this->get_allocator()); }\n+      _Tp_alloc_type\n+      _M_get_Tp_allocator() const\n+      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }\n+\n+      _Map_alloc_type\n+      _M_get_map_allocator() const\n+      { return _M_get_Tp_allocator(); }\n \n       _Tp*\n       _M_allocate_node()\n-      { return _M_impl._Alloc::allocate(__deque_buf_size(sizeof(_Tp))); }\n+      { \n+\treturn _M_impl._Tp_alloc_type::allocate(__deque_buf_size(sizeof(_Tp)));\n+      }\n \n       void\n       _M_deallocate_node(_Tp* __p)\n-      { _M_impl._Alloc::deallocate(__p, __deque_buf_size(sizeof(_Tp))); }\n+      {\n+\t_M_impl._Tp_alloc_type::deallocate(__p, __deque_buf_size(sizeof(_Tp)));\n+      }\n \n       _Tp**\n       _M_allocate_map(size_t __n)\n@@ -595,23 +608,26 @@ namespace _GLIBCXX_STD\n     class deque : protected _Deque_base<_Tp, _Alloc>\n     {\n       // concept requirements\n+      typedef typename _Alloc::value_type        _Alloc_value_type;\n       __glibcxx_class_requires(_Tp, _SGIAssignableConcept)\n+      __glibcxx_class_requires2(_Tp, _Alloc_value_type, _SameTypeConcept)\n \n       typedef _Deque_base<_Tp, _Alloc>           _Base;\n+      typedef typename _Base::_Tp_alloc_type\t _Tp_alloc_type;\n \n     public:\n-      typedef _Tp                                value_type;\n-      typedef typename _Alloc::pointer           pointer;\n-      typedef typename _Alloc::const_pointer     const_pointer;\n-      typedef typename _Alloc::reference         reference;\n-      typedef typename _Alloc::const_reference   const_reference;\n-      typedef typename _Base::iterator           iterator;\n-      typedef typename _Base::const_iterator     const_iterator;\n-      typedef std::reverse_iterator<const_iterator>   const_reverse_iterator;\n-      typedef std::reverse_iterator<iterator>         reverse_iterator;\n+      typedef _Tp                                        value_type;\n+      typedef typename _Tp_alloc_type::pointer           pointer;\n+      typedef typename _Tp_alloc_type::const_pointer     const_pointer;\n+      typedef typename _Tp_alloc_type::reference         reference;\n+      typedef typename _Tp_alloc_type::const_reference   const_reference;\n+      typedef typename _Base::iterator                   iterator;\n+      typedef typename _Base::const_iterator             const_iterator;\n+      typedef std::reverse_iterator<const_iterator>      const_reverse_iterator;\n+      typedef std::reverse_iterator<iterator>            reverse_iterator;\n       typedef size_t                             size_type;\n       typedef ptrdiff_t                          difference_type;\n-      typedef typename _Base::allocator_type     allocator_type;\n+      typedef _Alloc                             allocator_type;\n \n     protected:\n       typedef pointer*                           _Map_pointer;\n@@ -627,6 +643,7 @@ namespace _GLIBCXX_STD\n       using _Base::_M_deallocate_node;\n       using _Base::_M_allocate_map;\n       using _Base::_M_deallocate_map;\n+      using _Base::_M_get_Tp_allocator;\n \n       /** @if maint\n        *  A total of four data members accumulated down the heirarchy.\n@@ -680,7 +697,7 @@ namespace _GLIBCXX_STD\n       : _Base(__x.get_allocator(), __x.size())\n       { std::__uninitialized_copy_a(__x.begin(), __x.end(), \n \t\t\t\t    this->_M_impl._M_start,\n-\t\t\t\t    this->get_allocator()); }\n+\t\t\t\t    _M_get_Tp_allocator()); }\n \n       /**\n        *  @brief  Builds a %deque from a range.\n@@ -713,7 +730,7 @@ namespace _GLIBCXX_STD\n        */\n       ~deque()\n       { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,\n-\t\t      this->get_allocator()); }\n+\t\t      _M_get_Tp_allocator()); }\n \n       /**\n        *  @brief  %Deque assignment operator."}, {"sha": "879048063d1e99617a68eeab5a6ba7e969d29768", "filename": "libstdc++-v3/include/bits/stl_list.h", "status": "modified", "additions": 26, "deletions": 18, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fd20a8f82fb5cd17fd32a5218054447d45ada69/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fd20a8f82fb5cd17fd32a5218054447d45ada69/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h?ref=4fd20a8f82fb5cd17fd32a5218054447d45ada69", "patch": "@@ -290,38 +290,42 @@ namespace _GLIBCXX_STD\n       //\n       // We put this to the test in the constructors and in\n       // get_allocator, where we use conversions between\n-      // allocator_type and _Node_Alloc_type. The conversion is\n+      // allocator_type and _Node_alloc_type. The conversion is\n       // required by table 32 in [20.1.5].\n       typedef typename _Alloc::template rebind<_List_node<_Tp> >::other\n+        _Node_alloc_type;\n \n-      _Node_Alloc_type;\n+      typedef typename _Alloc::template rebind<_Tp>::other _Tp_alloc_type;\n \n       struct _List_impl \n-      : public _Node_Alloc_type\n+      : public _Node_alloc_type\n       {\n \t_List_node_base _M_node;\n-\t_List_impl (const _Node_Alloc_type& __a)\n-\t: _Node_Alloc_type(__a)\n+\t_List_impl(const _Node_alloc_type& __a)\n+\t: _Node_alloc_type(__a)\n \t{ }\n       };\n \n       _List_impl _M_impl;\n \n       _List_node<_Tp>*\n       _M_get_node()\n-      { return _M_impl._Node_Alloc_type::allocate(1); }\n+      { return _M_impl._Node_alloc_type::allocate(1); }\n       \n       void\n       _M_put_node(_List_node<_Tp>* __p)\n-      { _M_impl._Node_Alloc_type::deallocate(__p, 1); }\n+      { _M_impl._Node_alloc_type::deallocate(__p, 1); }\n       \n   public:\n       typedef _Alloc allocator_type;\n \n+      _Tp_alloc_type\n+      _M_get_Tp_allocator() const\n+      { return *static_cast<const _Node_alloc_type*>(&this->_M_impl); }\n+\n       allocator_type\n       get_allocator() const\n-      { return allocator_type(*static_cast<\n-\t\t\t      const _Node_Alloc_type*>(&this->_M_impl)); }\n+      { return _M_get_Tp_allocator(); }\n \n       _List_base(const allocator_type& __a)\n       : _M_impl(__a)\n@@ -391,28 +395,31 @@ namespace _GLIBCXX_STD\n     class list : protected _List_base<_Tp, _Alloc>\n     {\n       // concept requirements\n+      typedef typename _Alloc::value_type                _Alloc_value_type;\n       __glibcxx_class_requires(_Tp, _SGIAssignableConcept)\n+      __glibcxx_class_requires2(_Tp, _Alloc_value_type, _SameTypeConcept)\n \n-      typedef _List_base<_Tp, _Alloc>                   _Base;\n+      typedef _List_base<_Tp, _Alloc>                    _Base;\n+      typedef typename _Base::_Tp_alloc_type\t\t _Tp_alloc_type;\n \n     public:\n       typedef _Tp                                        value_type;\n-      typedef typename _Alloc::pointer                   pointer;\n-      typedef typename _Alloc::const_pointer             const_pointer;\n-      typedef typename _Alloc::reference                 reference;\n-      typedef typename _Alloc::const_reference           const_reference;\n+      typedef typename _Tp_alloc_type::pointer           pointer;\n+      typedef typename _Tp_alloc_type::const_pointer     const_pointer;\n+      typedef typename _Tp_alloc_type::reference         reference;\n+      typedef typename _Tp_alloc_type::const_reference   const_reference;\n       typedef _List_iterator<_Tp>                        iterator;\n       typedef _List_const_iterator<_Tp>                  const_iterator;\n       typedef std::reverse_iterator<const_iterator>      const_reverse_iterator;\n       typedef std::reverse_iterator<iterator>            reverse_iterator;\n       typedef size_t                                     size_type;\n       typedef ptrdiff_t                                  difference_type;\n-      typedef typename _Base::allocator_type             allocator_type;\n+      typedef _Alloc                                     allocator_type;\n \n     protected:\n       // Note that pointers-to-_Node's can be ctor-converted to\n       // iterator types.\n-      typedef _List_node<_Tp>\t\t\t\t_Node;\n+      typedef _List_node<_Tp>\t\t\t\t _Node;\n \n       /** @if maint\n        *  One data member plus two memory-handling functions.  If the\n@@ -423,6 +430,7 @@ namespace _GLIBCXX_STD\n       using _Base::_M_impl;\n       using _Base::_M_put_node;\n       using _Base::_M_get_node;\n+      using _Base::_M_get_Tp_allocator;\n \n       /**\n        *  @if maint\n@@ -437,7 +445,7 @@ namespace _GLIBCXX_STD\n \t_Node* __p = this->_M_get_node();\n \ttry\n \t  {\n-\t    this->get_allocator().construct(&__p->_M_data, __x);\n+\t    _M_get_Tp_allocator().construct(&__p->_M_data, __x);\n \t  }\n \tcatch(...)\n \t  {\n@@ -1158,7 +1166,7 @@ namespace _GLIBCXX_STD\n       {\n         __position._M_node->unhook();\n         _Node* __n = static_cast<_Node*>(__position._M_node);\n-        this->get_allocator().destroy(&__n->_M_data);\n+        _M_get_Tp_allocator().destroy(&__n->_M_data);\n         _M_put_node(__n);\n       }\n     };"}, {"sha": "5f4be568a6977ae341f7f5b4fed45ac5b61dd1c4", "filename": "libstdc++-v3/include/bits/stl_map.h", "status": "modified", "additions": 41, "deletions": 32, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fd20a8f82fb5cd17fd32a5218054447d45ada69/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fd20a8f82fb5cd17fd32a5218054447d45ada69/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h?ref=4fd20a8f82fb5cd17fd32a5218054447d45ada69", "patch": "@@ -90,21 +90,26 @@ namespace _GLIBCXX_STD\n             typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >\n     class map\n     {\n-      // concept requirements\n-      __glibcxx_class_requires(_Tp, _SGIAssignableConcept)\n-      __glibcxx_class_requires4(_Compare, bool, _Key, _Key,\n-\t\t\t\t_BinaryFunctionConcept)\n-\n     public:\n       typedef _Key                                          key_type;\n       typedef _Tp                                           mapped_type;\n       typedef std::pair<const _Key, _Tp>                    value_type;\n       typedef _Compare                                      key_compare;\n+      typedef _Alloc                                        allocator_type;\n+\n+    private:\n+      // concept requirements\n+      typedef typename _Alloc::value_type                   _Alloc_value_type;\n+      __glibcxx_class_requires(_Tp, _SGIAssignableConcept)\n+      __glibcxx_class_requires4(_Compare, bool, _Key, _Key,\n+\t\t\t\t_BinaryFunctionConcept)\n+      __glibcxx_class_requires2(value_type, _Alloc_value_type, _SameTypeConcept)\n \n+    public:\n       class value_compare\n       : public std::binary_function<value_type, value_type, bool>\n       {\n-\tfriend class map<_Key,_Tp,_Compare,_Alloc>;\n+\tfriend class map<_Key, _Tp, _Compare, _Alloc>;\n       protected:\n \t_Compare comp;\n \n@@ -118,19 +123,22 @@ namespace _GLIBCXX_STD\n \n     private:\n       /// @if maint  This turns a red-black tree into a [multi]map.  @endif\n-      typedef _Rb_tree<key_type, value_type,\n-\t\t       _Select1st<value_type>, key_compare, _Alloc> _Rep_type;\n+      typedef typename _Alloc::template rebind<value_type>::other \n+        _Pair_alloc_type;\n+\n+      typedef _Rb_tree<key_type, value_type, _Select1st<value_type>,\n+\t\t       key_compare, _Pair_alloc_type> _Rep_type;\n+\n       /// @if maint  The actual tree structure.  @endif\n       _Rep_type _M_t;\n \n     public:\n       // many of these are specified differently in ISO, but the following are\n       // \"functionally equivalent\"\n-      typedef typename _Alloc::pointer                   pointer;\n-      typedef typename _Alloc::const_pointer             const_pointer;\n-      typedef typename _Alloc::reference                 reference;\n-      typedef typename _Alloc::const_reference           const_reference;\n-      typedef typename _Rep_type::allocator_type         allocator_type;\n+      typedef typename _Pair_alloc_type::pointer         pointer;\n+      typedef typename _Pair_alloc_type::const_pointer   const_pointer;\n+      typedef typename _Pair_alloc_type::reference       reference;\n+      typedef typename _Pair_alloc_type::const_reference const_reference;\n       typedef typename _Rep_type::iterator               iterator;\n       typedef typename _Rep_type::const_iterator         const_iterator;\n       typedef typename _Rep_type::size_type              size_type;\n@@ -589,7 +597,7 @@ namespace _GLIBCXX_STD\n        *\n        *  This function probably only makes sense for multimaps.\n        */\n-      std::pair<iterator,iterator>\n+      std::pair<iterator, iterator>\n       equal_range(const key_type& __x)\n       { return _M_t.equal_range(__x); }\n \n@@ -608,19 +616,19 @@ namespace _GLIBCXX_STD\n        *\n        *  This function probably only makes sense for multimaps.\n        */\n-      std::pair<const_iterator,const_iterator>\n+      std::pair<const_iterator, const_iterator>\n       equal_range(const key_type& __x) const\n       { return _M_t.equal_range(__x); }\n \n       template <typename _K1, typename _T1, typename _C1, typename _A1>\n         friend bool\n-        operator== (const map<_K1,_T1,_C1,_A1>&,\n-\t\t    const map<_K1,_T1,_C1,_A1>&);\n+        operator== (const map<_K1, _T1, _C1, _A1>&,\n+\t\t    const map<_K1, _T1, _C1, _A1>&);\n \n       template <typename _K1, typename _T1, typename _C1, typename _A1>\n         friend bool\n-        operator< (const map<_K1,_T1,_C1,_A1>&,\n-\t\t   const map<_K1,_T1,_C1,_A1>&);\n+        operator< (const map<_K1, _T1, _C1, _A1>&,\n+\t\t   const map<_K1, _T1, _C1, _A1>&);\n     };\n \n   /**\n@@ -635,8 +643,8 @@ namespace _GLIBCXX_STD\n   */\n   template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n     inline bool\n-    operator==(const map<_Key,_Tp,_Compare,_Alloc>& __x,\n-               const map<_Key,_Tp,_Compare,_Alloc>& __y)\n+    operator==(const map<_Key, _Tp, _Compare, _Alloc>& __x,\n+               const map<_Key, _Tp, _Compare, _Alloc>& __y)\n     { return __x._M_t == __y._M_t; }\n \n   /**\n@@ -652,42 +660,43 @@ namespace _GLIBCXX_STD\n   */\n   template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n     inline bool\n-    operator<(const map<_Key,_Tp,_Compare,_Alloc>& __x,\n-              const map<_Key,_Tp,_Compare,_Alloc>& __y)\n+    operator<(const map<_Key, _Tp, _Compare, _Alloc>& __x,\n+              const map<_Key, _Tp, _Compare, _Alloc>& __y)\n     { return __x._M_t < __y._M_t; }\n \n   /// Based on operator==\n   template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n     inline bool\n-    operator!=(const map<_Key,_Tp,_Compare,_Alloc>& __x,\n-               const map<_Key,_Tp,_Compare,_Alloc>& __y)\n+    operator!=(const map<_Key, _Tp, _Compare, _Alloc>& __x,\n+               const map<_Key, _Tp, _Compare, _Alloc>& __y)\n     { return !(__x == __y); }\n \n   /// Based on operator<\n   template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n     inline bool\n-    operator>(const map<_Key,_Tp,_Compare,_Alloc>& __x,\n-              const map<_Key,_Tp,_Compare,_Alloc>& __y)\n+    operator>(const map<_Key, _Tp, _Compare, _Alloc>& __x,\n+              const map<_Key, _Tp, _Compare, _Alloc>& __y)\n     { return __y < __x; }\n \n   /// Based on operator<\n   template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n     inline bool\n-    operator<=(const map<_Key,_Tp,_Compare,_Alloc>& __x,\n-               const map<_Key,_Tp,_Compare,_Alloc>& __y)\n+    operator<=(const map<_Key, _Tp, _Compare, _Alloc>& __x,\n+               const map<_Key, _Tp, _Compare, _Alloc>& __y)\n     { return !(__y < __x); }\n \n   /// Based on operator<\n   template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n     inline bool\n-    operator>=(const map<_Key,_Tp,_Compare,_Alloc>& __x,\n-               const map<_Key,_Tp,_Compare,_Alloc>& __y)\n+    operator>=(const map<_Key, _Tp, _Compare, _Alloc>& __x,\n+               const map<_Key, _Tp, _Compare, _Alloc>& __y)\n     { return !(__x < __y); }\n \n   /// See std::map::swap().\n   template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n     inline void\n-    swap(map<_Key,_Tp,_Compare,_Alloc>& __x, map<_Key,_Tp,_Compare,_Alloc>& __y)\n+    swap(map<_Key, _Tp, _Compare, _Alloc>& __x,\n+\t map<_Key, _Tp, _Compare, _Alloc>& __y)\n     { __x.swap(__y); }\n } // namespace std\n "}, {"sha": "dca95563343d284eb2d8c3a911d476ca5441a63c", "filename": "libstdc++-v3/include/bits/stl_multimap.h", "status": "modified", "additions": 44, "deletions": 37, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fd20a8f82fb5cd17fd32a5218054447d45ada69/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fd20a8f82fb5cd17fd32a5218054447d45ada69/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h?ref=4fd20a8f82fb5cd17fd32a5218054447d45ada69", "patch": "@@ -74,13 +74,13 @@ namespace _GLIBCXX_STD\n \n   template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n     inline bool\n-    operator==(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,\n-\t       const multimap<_Key,_Tp,_Compare,_Alloc>& __y);\n+    operator==(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,\n+\t       const multimap<_Key, _Tp, _Compare, _Alloc>& __y);\n \n   template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n     inline bool\n-    operator<(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,\n-\t      const multimap<_Key,_Tp,_Compare,_Alloc>& __y);\n+    operator<(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,\n+\t      const multimap<_Key, _Tp, _Compare, _Alloc>& __y);\n \n   /**\n    *  @brief A standard container made up of (key,value) pairs, which can be\n@@ -106,21 +106,26 @@ namespace _GLIBCXX_STD\n   template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n     class multimap\n     {\n-      // concept requirements\n-      __glibcxx_class_requires(_Tp, _SGIAssignableConcept)\n-      __glibcxx_class_requires4(_Compare, bool, _Key, _Key,\n-\t\t\t\t_BinaryFunctionConcept)\n-\n     public:\n       typedef _Key                                          key_type;\n       typedef _Tp                                           mapped_type;\n       typedef std::pair<const _Key, _Tp>                    value_type;\n       typedef _Compare                                      key_compare;\n+      typedef _Alloc                                        allocator_type;\n \n+    private:\n+      // concept requirements\n+      typedef typename _Alloc::value_type                   _Alloc_value_type;\n+      __glibcxx_class_requires(_Tp, _SGIAssignableConcept)\n+      __glibcxx_class_requires4(_Compare, bool, _Key, _Key,\n+\t\t\t\t_BinaryFunctionConcept)\n+      __glibcxx_class_requires2(value_type, _Alloc_value_type, _SameTypeConcept)\t\n+\n+    public:\n       class value_compare\n       : public std::binary_function<value_type, value_type, bool>\n       {\n-\tfriend class multimap<_Key,_Tp,_Compare,_Alloc>;\n+\tfriend class multimap<_Key, _Tp, _Compare, _Alloc>;\n       protected:\n \t_Compare comp;\n \n@@ -134,19 +139,21 @@ namespace _GLIBCXX_STD\n \n     private:\n       /// @if maint  This turns a red-black tree into a [multi]map.  @endif\n-      typedef _Rb_tree<key_type, value_type,\n-\t\t       _Select1st<value_type>, key_compare, _Alloc> _Rep_type;\n+      typedef typename _Alloc::template rebind<value_type>::other \n+        _Pair_alloc_type;\n+\n+      typedef _Rb_tree<key_type, value_type, _Select1st<value_type>,\n+\t\t       key_compare, _Pair_alloc_type> _Rep_type;\n       /// @if maint  The actual tree structure.  @endif\n       _Rep_type _M_t;\n \n     public:\n       // many of these are specified differently in ISO, but the following are\n       // \"functionally equivalent\"\n-      typedef typename _Alloc::pointer                   pointer;\n-      typedef typename _Alloc::const_pointer             const_pointer;\n-      typedef typename _Alloc::reference                 reference;\n-      typedef typename _Alloc::const_reference           const_reference;\n-      typedef typename _Rep_type::allocator_type         allocator_type;\n+      typedef typename _Pair_alloc_type::pointer         pointer;\n+      typedef typename _Pair_alloc_type::const_pointer   const_pointer;\n+      typedef typename _Pair_alloc_type::reference       reference;\n+      typedef typename _Pair_alloc_type::const_reference const_reference;\n       typedef typename _Rep_type::iterator               iterator;\n       typedef typename _Rep_type::const_iterator         const_iterator;\n       typedef typename _Rep_type::size_type              size_type;\n@@ -573,7 +580,7 @@ namespace _GLIBCXX_STD\n        *  @endcode\n        *  (but is faster than making the calls separately).\n        */\n-      std::pair<iterator,iterator>\n+      std::pair<iterator, iterator>\n       equal_range(const key_type& __x)\n       { return _M_t.equal_range(__x); }\n \n@@ -590,19 +597,19 @@ namespace _GLIBCXX_STD\n        *  @endcode\n        *  (but is faster than making the calls separately).\n        */\n-      std::pair<const_iterator,const_iterator>\n+      std::pair<const_iterator, const_iterator>\n       equal_range(const key_type& __x) const\n       { return _M_t.equal_range(__x); }\n \n       template <typename _K1, typename _T1, typename _C1, typename _A1>\n         friend bool\n-        operator== (const multimap<_K1,_T1,_C1,_A1>&,\n-\t\t    const multimap<_K1,_T1,_C1,_A1>&);\n+        operator== (const multimap<_K1, _T1, _C1, _A1>&,\n+\t\t    const multimap<_K1, _T1, _C1, _A1>&);\n \n       template <typename _K1, typename _T1, typename _C1, typename _A1>\n         friend bool\n-        operator< (const multimap<_K1,_T1,_C1,_A1>&,\n-\t\t   const multimap<_K1,_T1,_C1,_A1>&);\n+        operator< (const multimap<_K1, _T1, _C1, _A1>&,\n+\t\t   const multimap<_K1, _T1, _C1, _A1>&);\n   };\n \n   /**\n@@ -617,8 +624,8 @@ namespace _GLIBCXX_STD\n   */\n   template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n     inline bool\n-    operator==(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,\n-               const multimap<_Key,_Tp,_Compare,_Alloc>& __y)\n+    operator==(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,\n+               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)\n     { return __x._M_t == __y._M_t; }\n \n   /**\n@@ -634,43 +641,43 @@ namespace _GLIBCXX_STD\n   */\n   template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n     inline bool\n-    operator<(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,\n-              const multimap<_Key,_Tp,_Compare,_Alloc>& __y)\n+    operator<(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,\n+              const multimap<_Key, _Tp, _Compare, _Alloc>& __y)\n     { return __x._M_t < __y._M_t; }\n \n   /// Based on operator==\n   template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n     inline bool\n-    operator!=(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,\n-               const multimap<_Key,_Tp,_Compare,_Alloc>& __y)\n+    operator!=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,\n+               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)\n     { return !(__x == __y); }\n \n   /// Based on operator<\n   template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n     inline bool\n-    operator>(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,\n-              const multimap<_Key,_Tp,_Compare,_Alloc>& __y)\n+    operator>(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,\n+              const multimap<_Key, _Tp, _Compare, _Alloc>& __y)\n     { return __y < __x; }\n \n   /// Based on operator<\n   template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n     inline bool\n-    operator<=(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,\n-               const multimap<_Key,_Tp,_Compare,_Alloc>& __y)\n+    operator<=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,\n+               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)\n     { return !(__y < __x); }\n \n   /// Based on operator<\n   template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n     inline bool\n-    operator>=(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,\n-               const multimap<_Key,_Tp,_Compare,_Alloc>& __y)\n+    operator>=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,\n+               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)\n     { return !(__x < __y); }\n \n   /// See std::multimap::swap().\n   template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n     inline void\n-    swap(multimap<_Key,_Tp,_Compare,_Alloc>& __x,\n-         multimap<_Key,_Tp,_Compare,_Alloc>& __y)\n+    swap(multimap<_Key, _Tp, _Compare, _Alloc>& __x,\n+         multimap<_Key, _Tp, _Compare, _Alloc>& __y)\n     { __x.swap(__y); }\n } // namespace std\n "}, {"sha": "f401db76fd534e5a621c09ccdb6ebf60bbf33ceb", "filename": "libstdc++-v3/include/bits/stl_multiset.h", "status": "modified", "additions": 46, "deletions": 42, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fd20a8f82fb5cd17fd32a5218054447d45ada69/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fd20a8f82fb5cd17fd32a5218054447d45ada69/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h?ref=4fd20a8f82fb5cd17fd32a5218054447d45ada69", "patch": "@@ -73,13 +73,13 @@ namespace _GLIBCXX_STD\n \n   template <class _Key, class _Compare, class _Alloc>\n     inline bool\n-    operator==(const multiset<_Key,_Compare,_Alloc>& __x,\n-\t       const multiset<_Key,_Compare,_Alloc>& __y);\n+    operator==(const multiset<_Key, _Compare, _Alloc>& __x,\n+\t       const multiset<_Key, _Compare, _Alloc>& __y);\n \n   template <class _Key, class _Compare, class _Alloc>\n     inline bool\n-    operator<(const multiset<_Key,_Compare,_Alloc>& __x,\n-\t      const multiset<_Key,_Compare,_Alloc>& __y);\n+    operator<(const multiset<_Key, _Compare, _Alloc>& __x,\n+\t      const multiset<_Key, _Compare, _Alloc>& __y);\n \n   /**\n    *  @brief A standard container made up of elements, which can be retrieved\n@@ -105,45 +105,49 @@ namespace _GLIBCXX_STD\n     class multiset\n     {\n       // concept requirements\n+      typedef typename _Alloc::value_type                   _Alloc_value_type;\n       __glibcxx_class_requires(_Key, _SGIAssignableConcept)\n       __glibcxx_class_requires4(_Compare, bool, _Key, _Key,\n \t\t\t\t_BinaryFunctionConcept)\n+      __glibcxx_class_requires2(_Key, _Alloc_value_type, _SameTypeConcept)\t\n \n     public:\n       // typedefs:\n       typedef _Key     key_type;\n       typedef _Key     value_type;\n       typedef _Compare key_compare;\n       typedef _Compare value_compare;\n+      typedef _Alloc   allocator_type;\n \n     private:\n       /// @if maint  This turns a red-black tree into a [multi]set.  @endif\n-      typedef _Rb_tree<key_type, value_type,\n-\t\t       _Identity<value_type>, key_compare, _Alloc> _Rep_type;\n+      typedef typename _Alloc::template rebind<_Key>::other _Key_alloc_type;\n+\n+      typedef _Rb_tree<key_type, value_type, _Identity<value_type>,\n+\t\t       key_compare, _Key_alloc_type> _Rep_type;\n       /// @if maint  The actual tree structure.  @endif\n       _Rep_type _M_t;\n \n     public:\n-      typedef typename _Alloc::pointer pointer;\n-      typedef typename _Alloc::const_pointer const_pointer;\n-      typedef typename _Alloc::reference reference;\n-      typedef typename _Alloc::const_reference const_reference;\n+      typedef typename _Key_alloc_type::pointer             pointer;\n+      typedef typename _Key_alloc_type::const_pointer       const_pointer;\n+      typedef typename _Key_alloc_type::reference           reference;\n+      typedef typename _Key_alloc_type::const_reference     const_reference;\n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // DR 103. set::iterator is required to be modifiable,\n       // but this allows modification of keys.\n-      typedef typename _Rep_type::const_iterator iterator;\n-      typedef typename _Rep_type::const_iterator const_iterator;\n-      typedef typename _Rep_type::const_reverse_iterator reverse_iterator;\n-      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;\n-      typedef typename _Rep_type::size_type size_type;\n-      typedef typename _Rep_type::difference_type difference_type;\n-      typedef typename _Rep_type::allocator_type allocator_type;\n-\n-    // allocation/deallocation\n-\n-    /**\n-     *  @brief  Default constructor creates no elements.\n-     */\n+      typedef typename _Rep_type::const_iterator            iterator;\n+      typedef typename _Rep_type::const_iterator            const_iterator;\n+      typedef typename _Rep_type::const_reverse_iterator    reverse_iterator;\n+      typedef typename _Rep_type::const_reverse_iterator    const_reverse_iterator;\n+      typedef typename _Rep_type::size_type                 size_type;\n+      typedef typename _Rep_type::difference_type           difference_type;\n+\n+      // allocation/deallocation\n+\n+      /**\n+       *  @brief  Default constructor creates no elements.\n+       */\n       multiset()\n       : _M_t(_Compare(), allocator_type()) { }\n \n@@ -286,7 +290,7 @@ namespace _GLIBCXX_STD\n        *  std::swap(s1,s2) will feed to this function.\n        */\n       void\n-      swap(multiset<_Key,_Compare,_Alloc>& __x)\n+      swap(multiset<_Key, _Compare, _Alloc>& __x)\n       { _M_t.swap(__x._M_t); }\n \n       // insert/erase\n@@ -492,23 +496,23 @@ namespace _GLIBCXX_STD\n        *\n        *  This function probably only makes sense for multisets.\n        */\n-      std::pair<iterator,iterator>\n+      std::pair<iterator, iterator>\n       equal_range(const key_type& __x)\n       { return _M_t.equal_range(__x); }\n \n-      std::pair<const_iterator,const_iterator>\n+      std::pair<const_iterator, const_iterator>\n       equal_range(const key_type& __x) const\n       { return _M_t.equal_range(__x); }\n \n       template <class _K1, class _C1, class _A1>\n         friend bool\n-        operator== (const multiset<_K1,_C1,_A1>&,\n-\t\t    const multiset<_K1,_C1,_A1>&);\n+        operator== (const multiset<_K1, _C1, _A1>&,\n+\t\t    const multiset<_K1, _C1, _A1>&);\n \n       template <class _K1, class _C1, class _A1>\n         friend bool\n-        operator< (const multiset<_K1,_C1,_A1>&,\n-\t\t   const multiset<_K1,_C1,_A1>&);\n+        operator< (const multiset<_K1, _C1, _A1>&,\n+\t\t   const multiset<_K1, _C1, _A1>&);\n     };\n \n   /**\n@@ -524,8 +528,8 @@ namespace _GLIBCXX_STD\n   */\n   template <class _Key, class _Compare, class _Alloc>\n     inline bool\n-    operator==(const multiset<_Key,_Compare,_Alloc>& __x,\n-\t       const multiset<_Key,_Compare,_Alloc>& __y)\n+    operator==(const multiset<_Key, _Compare, _Alloc>& __x,\n+\t       const multiset<_Key, _Compare, _Alloc>& __y)\n     { return __x._M_t == __y._M_t; }\n \n   /**\n@@ -541,15 +545,15 @@ namespace _GLIBCXX_STD\n   */\n   template <class _Key, class _Compare, class _Alloc>\n     inline bool\n-    operator<(const multiset<_Key,_Compare,_Alloc>& __x,\n-\t      const multiset<_Key,_Compare,_Alloc>& __y)\n+    operator<(const multiset<_Key, _Compare, _Alloc>& __x,\n+\t      const multiset<_Key, _Compare, _Alloc>& __y)\n     { return __x._M_t < __y._M_t; }\n \n   ///  Returns !(x == y).\n   template <class _Key, class _Compare, class _Alloc>\n     inline bool\n-    operator!=(const multiset<_Key,_Compare,_Alloc>& __x,\n-\t       const multiset<_Key,_Compare,_Alloc>& __y)\n+    operator!=(const multiset<_Key, _Compare, _Alloc>& __x,\n+\t       const multiset<_Key, _Compare, _Alloc>& __y)\n     { return !(__x == __y); }\n \n   ///  Returns y < x.\n@@ -562,22 +566,22 @@ namespace _GLIBCXX_STD\n   ///  Returns !(y < x)\n   template <class _Key, class _Compare, class _Alloc>\n     inline bool\n-    operator<=(const multiset<_Key,_Compare,_Alloc>& __x,\n-\t       const multiset<_Key,_Compare,_Alloc>& __y)\n+    operator<=(const multiset<_Key, _Compare, _Alloc>& __x,\n+\t       const multiset<_Key, _Compare, _Alloc>& __y)\n     { return !(__y < __x); }\n \n   ///  Returns !(x < y)\n   template <class _Key, class _Compare, class _Alloc>\n     inline bool\n-    operator>=(const multiset<_Key,_Compare,_Alloc>& __x,\n-\t       const multiset<_Key,_Compare,_Alloc>& __y)\n+    operator>=(const multiset<_Key, _Compare, _Alloc>& __x,\n+\t       const multiset<_Key, _Compare, _Alloc>& __y)\n     { return !(__x < __y); }\n \n   /// See std::multiset::swap().\n   template <class _Key, class _Compare, class _Alloc>\n     inline void\n-    swap(multiset<_Key,_Compare,_Alloc>& __x,\n-\t multiset<_Key,_Compare,_Alloc>& __y)\n+    swap(multiset<_Key, _Compare, _Alloc>& __x,\n+\t multiset<_Key, _Compare, _Alloc>& __y)\n     { __x.swap(__y); }\n \n } // namespace std"}, {"sha": "c76e55475c6afbe4fb172d60af0da8ce9d5e2d4c", "filename": "libstdc++-v3/include/bits/stl_set.h", "status": "modified", "additions": 42, "deletions": 36, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fd20a8f82fb5cd17fd32a5218054447d45ada69/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fd20a8f82fb5cd17fd32a5218054447d45ada69/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h?ref=4fd20a8f82fb5cd17fd32a5218054447d45ada69", "patch": "@@ -72,13 +72,13 @@ namespace _GLIBCXX_STD\n \n   template<class _Key, class _Compare, class _Alloc>\n     inline bool\n-    operator==(const set<_Key,_Compare,_Alloc>& __x,\n-\t       const set<_Key,_Compare,_Alloc>& __y);\n+    operator==(const set<_Key, _Compare, _Alloc>& __x,\n+\t       const set<_Key, _Compare, _Alloc>& __y);\n \n   template<class _Key, class _Compare, class _Alloc>\n     inline bool\n-    operator<(const set<_Key,_Compare,_Alloc>& __x,\n-\t      const set<_Key,_Compare,_Alloc>& __y);\n+    operator<(const set<_Key, _Compare, _Alloc>& __x,\n+\t      const set<_Key, _Compare, _Alloc>& __y);\n \n   /**\n    *  @brief A standard container made up of unique keys, which can be\n@@ -107,9 +107,11 @@ namespace _GLIBCXX_STD\n     class set\n     {\n       // concept requirements\n+      typedef typename _Alloc::value_type                   _Alloc_value_type;\n       __glibcxx_class_requires(_Key, _SGIAssignableConcept)\n       __glibcxx_class_requires4(_Compare, bool, _Key, _Key,\n \t\t\t\t_BinaryFunctionConcept)\n+      __glibcxx_class_requires2(_Key, _Alloc_value_type, _SameTypeConcept)\t\n \n     public:\n       // typedefs:\n@@ -119,29 +121,32 @@ namespace _GLIBCXX_STD\n       typedef _Key     value_type;\n       typedef _Compare key_compare;\n       typedef _Compare value_compare;\n+      typedef _Alloc   allocator_type;\n       //@}\n \n     private:\n-      typedef _Rb_tree<key_type, value_type,\n-\t\t       _Identity<value_type>, key_compare, _Alloc> _Rep_type;\n+      typedef typename _Alloc::template rebind<_Key>::other _Key_alloc_type;\n+\n+      typedef _Rb_tree<key_type, value_type, _Identity<value_type>,\n+\t\t       key_compare, _Key_alloc_type> _Rep_type;\n       _Rep_type _M_t;  // red-black tree representing set\n+\n     public:\n       //@{\n       ///  Iterator-related typedefs.\n-      typedef typename _Alloc::pointer pointer;\n-      typedef typename _Alloc::const_pointer const_pointer;\n-      typedef typename _Alloc::reference reference;\n-      typedef typename _Alloc::const_reference const_reference;\n+      typedef typename _Key_alloc_type::pointer             pointer;\n+      typedef typename _Key_alloc_type::const_pointer       const_pointer;\n+      typedef typename _Key_alloc_type::reference           reference;\n+      typedef typename _Key_alloc_type::const_reference     const_reference;\n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // DR 103. set::iterator is required to be modifiable,\n       // but this allows modification of keys.\n-      typedef typename _Rep_type::const_iterator iterator;\n-      typedef typename _Rep_type::const_iterator const_iterator;\n-      typedef typename _Rep_type::const_reverse_iterator reverse_iterator;\n-      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;\n-      typedef typename _Rep_type::size_type size_type;\n-      typedef typename _Rep_type::difference_type difference_type;\n-      typedef typename _Rep_type::allocator_type allocator_type;\n+      typedef typename _Rep_type::const_iterator            iterator;\n+      typedef typename _Rep_type::const_iterator            const_iterator;\n+      typedef typename _Rep_type::const_reverse_iterator    reverse_iterator;\n+      typedef typename _Rep_type::const_reverse_iterator    const_reverse_iterator;\n+      typedef typename _Rep_type::size_type                 size_type;\n+      typedef typename _Rep_type::difference_type           difference_type;\n       //@}\n \n       // allocation/deallocation\n@@ -155,8 +160,9 @@ namespace _GLIBCXX_STD\n        *  @param  comp  Comparator to use.\n        *  @param  a  Allocator to use.\n        */\n-      explicit set(const _Compare& __comp,\n-\t\t   const allocator_type& __a = allocator_type())\n+      explicit\n+      set(const _Compare& __comp,\n+\t  const allocator_type& __a = allocator_type())\n       : _M_t(__comp, __a) {}\n \n       /**\n@@ -503,22 +509,22 @@ namespace _GLIBCXX_STD\n        *\n        *  This function probably only makes sense for multisets.\n        */\n-      std::pair<iterator,iterator>\n+      std::pair<iterator, iterator>\n       equal_range(const key_type& __x)\n       { return _M_t.equal_range(__x); }\n \n-      std::pair<const_iterator,const_iterator>\n+      std::pair<const_iterator, const_iterator>\n       equal_range(const key_type& __x) const\n       { return _M_t.equal_range(__x); }\n       //@}\n \n       template<class _K1, class _C1, class _A1>\n         friend bool\n-        operator== (const set<_K1,_C1,_A1>&, const set<_K1,_C1,_A1>&);\n+        operator== (const set<_K1, _C1, _A1>&, const set<_K1, _C1, _A1>&);\n \n       template<class _K1, class _C1, class _A1>\n         friend bool\n-        operator< (const set<_K1,_C1,_A1>&, const set<_K1,_C1,_A1>&);\n+        operator< (const set<_K1, _C1, _A1>&, const set<_K1, _C1, _A1>&);\n     };\n \n \n@@ -534,8 +540,8 @@ namespace _GLIBCXX_STD\n   */\n   template<class _Key, class _Compare, class _Alloc>\n     inline bool\n-    operator==(const set<_Key,_Compare,_Alloc>& __x,\n-\t       const set<_Key,_Compare,_Alloc>& __y)\n+    operator==(const set<_Key, _Compare, _Alloc>& __x,\n+\t       const set<_Key, _Compare, _Alloc>& __y)\n     { return __x._M_t == __y._M_t; }\n \n   /**\n@@ -551,42 +557,42 @@ namespace _GLIBCXX_STD\n   */\n   template<class _Key, class _Compare, class _Alloc>\n     inline bool\n-    operator<(const set<_Key,_Compare,_Alloc>& __x,\n-\t      const set<_Key,_Compare,_Alloc>& __y)\n+    operator<(const set<_Key, _Compare, _Alloc>& __x,\n+\t      const set<_Key, _Compare, _Alloc>& __y)\n     { return __x._M_t < __y._M_t; }\n \n   ///  Returns !(x == y).\n   template<class _Key, class _Compare, class _Alloc>\n     inline bool\n-    operator!=(const set<_Key,_Compare,_Alloc>& __x,\n-\t       const set<_Key,_Compare,_Alloc>& __y)\n+    operator!=(const set<_Key, _Compare, _Alloc>& __x,\n+\t       const set<_Key, _Compare, _Alloc>& __y)\n     { return !(__x == __y); }\n \n   ///  Returns y < x.\n   template<class _Key, class _Compare, class _Alloc>\n     inline bool\n-    operator>(const set<_Key,_Compare,_Alloc>& __x,\n-\t      const set<_Key,_Compare,_Alloc>& __y)\n+    operator>(const set<_Key, _Compare, _Alloc>& __x,\n+\t      const set<_Key, _Compare, _Alloc>& __y)\n     { return __y < __x; }\n \n   ///  Returns !(y < x)\n   template<class _Key, class _Compare, class _Alloc>\n     inline bool\n-    operator<=(const set<_Key,_Compare,_Alloc>& __x,\n-\t       const set<_Key,_Compare,_Alloc>& __y)\n+    operator<=(const set<_Key, _Compare, _Alloc>& __x,\n+\t       const set<_Key, _Compare, _Alloc>& __y)\n     { return !(__y < __x); }\n \n   ///  Returns !(x < y)\n   template<class _Key, class _Compare, class _Alloc>\n     inline bool\n-    operator>=(const set<_Key,_Compare,_Alloc>& __x,\n-\t       const set<_Key,_Compare,_Alloc>& __y)\n+    operator>=(const set<_Key, _Compare, _Alloc>& __x,\n+\t       const set<_Key, _Compare, _Alloc>& __y)\n     { return !(__x < __y); }\n \n   /// See std::set::swap().\n   template<class _Key, class _Compare, class _Alloc>\n     inline void\n-    swap(set<_Key,_Compare,_Alloc>& __x, set<_Key,_Compare,_Alloc>& __y)\n+    swap(set<_Key, _Compare, _Alloc>& __x, set<_Key, _Compare, _Alloc>& __y)\n     { __x.swap(__y); }\n \n } // namespace std"}, {"sha": "dccc9dd96234d8c572bdd36ed48bb7d4af7f6546", "filename": "libstdc++-v3/include/bits/stl_vector.h", "status": "modified", "additions": 29, "deletions": 19, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fd20a8f82fb5cd17fd32a5218054447d45ada69/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fd20a8f82fb5cd17fd32a5218054447d45ada69/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h?ref=4fd20a8f82fb5cd17fd32a5218054447d45ada69", "patch": "@@ -75,23 +75,29 @@ namespace _GLIBCXX_STD\n   template<typename _Tp, typename _Alloc>\n     struct _Vector_base\n     {\n+      typedef typename _Alloc::template rebind<_Tp>::other _Tp_alloc_type;\n+\n       struct _Vector_impl \n-      : public _Alloc\n+      : public _Tp_alloc_type\n       {\n \t_Tp*           _M_start;\n \t_Tp*           _M_finish;\n \t_Tp*           _M_end_of_storage;\n-\t_Vector_impl(_Alloc const& __a)\n-\t: _Alloc(__a), _M_start(0), _M_finish(0), _M_end_of_storage(0)\n+\t_Vector_impl(_Tp_alloc_type const& __a)\n+\t: _Tp_alloc_type(__a), _M_start(0), _M_finish(0), _M_end_of_storage(0)\n \t{ }\n       };\n       \n     public:\n       typedef _Alloc allocator_type;\n \n+      _Tp_alloc_type\n+      _M_get_Tp_allocator() const\n+      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }\n+\n       allocator_type\n       get_allocator() const\n-      { return *static_cast<const _Alloc*>(&this->_M_impl); }\n+      { return _M_get_Tp_allocator(); }\n \n       _Vector_base(const allocator_type& __a)\n       : _M_impl(__a)\n@@ -148,25 +154,28 @@ namespace _GLIBCXX_STD\n     class vector : protected _Vector_base<_Tp, _Alloc>\n     {\n       // Concept requirements.\n+      typedef typename _Alloc::value_type                _Alloc_value_type;\n       __glibcxx_class_requires(_Tp, _SGIAssignableConcept)\n-\n-      typedef _Vector_base<_Tp, _Alloc>\t\t\t_Base;\n-      typedef vector<_Tp, _Alloc>\t\t\tvector_type;\n+      __glibcxx_class_requires2(_Tp, _Alloc_value_type, _SameTypeConcept)\n+      \n+      typedef _Vector_base<_Tp, _Alloc>\t\t\t _Base;\n+      typedef vector<_Tp, _Alloc>\t\t\t vector_type;\n+      typedef typename _Base::_Tp_alloc_type\t\t _Tp_alloc_type;\n \n     public:\n       typedef _Tp\t\t\t\t\t value_type;\n-      typedef typename _Alloc::pointer                   pointer;\n-      typedef typename _Alloc::const_pointer             const_pointer;\n-      typedef typename _Alloc::reference                 reference;\n-      typedef typename _Alloc::const_reference           const_reference;\n+      typedef typename _Tp_alloc_type::pointer           pointer;\n+      typedef typename _Tp_alloc_type::const_pointer     const_pointer;\n+      typedef typename _Tp_alloc_type::reference         reference;\n+      typedef typename _Tp_alloc_type::const_reference   const_reference;\n       typedef __gnu_cxx::__normal_iterator<pointer, vector_type> iterator;\n       typedef __gnu_cxx::__normal_iterator<const_pointer, vector_type>\n       const_iterator;\n       typedef std::reverse_iterator<const_iterator>  const_reverse_iterator;\n       typedef std::reverse_iterator<iterator>\t\t reverse_iterator;\n       typedef size_t\t\t\t\t\t size_type;\n       typedef ptrdiff_t\t\t\t\t\t difference_type;\n-      typedef typename _Base::allocator_type\t\t allocator_type;\n+      typedef _Alloc                        \t\t allocator_type;\n \n     protected:\n       /** @if maint\n@@ -177,6 +186,7 @@ namespace _GLIBCXX_STD\n       using _Base::_M_allocate;\n       using _Base::_M_deallocate;\n       using _Base::_M_impl;\n+      using _Base::_M_get_Tp_allocator;\n \n     public:\n       // [23.2.4.1] construct/copy/destroy\n@@ -201,7 +211,7 @@ namespace _GLIBCXX_STD\n       : _Base(__n, __a)\n       {\n \tstd::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,\n-\t\t\t\t      this->get_allocator());\n+\t\t\t\t      _M_get_Tp_allocator());\n \tthis->_M_impl._M_finish = this->_M_impl._M_start + __n;\n       }\n \n@@ -217,7 +227,7 @@ namespace _GLIBCXX_STD\n       : _Base(__n, allocator_type())\n       {\n \tstd::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, value_type(),\n-\t\t\t\t      this->get_allocator());\n+\t\t\t\t      _M_get_Tp_allocator());\n \tthis->_M_impl._M_finish = this->_M_impl._M_start + __n;\t\n       }\n \n@@ -235,7 +245,7 @@ namespace _GLIBCXX_STD\n       { this->_M_impl._M_finish =\n \t  std::__uninitialized_copy_a(__x.begin(), __x.end(),\n \t\t\t\t      this->_M_impl._M_start,\n-\t\t\t\t      this->get_allocator());\n+\t\t\t\t      _M_get_Tp_allocator());\n       }\n \n       /**\n@@ -271,7 +281,7 @@ namespace _GLIBCXX_STD\n        */\n       ~vector()\n       { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,\n-\t\t      this->get_allocator());\n+\t\t      _M_get_Tp_allocator());\n       }\n \n       /**\n@@ -764,7 +774,7 @@ namespace _GLIBCXX_STD\n \t  try\n \t    {\n \t      std::__uninitialized_copy_a(__first, __last, __result,\n-\t\t\t\t\t  this->get_allocator());\n+\t\t\t\t\t  _M_get_Tp_allocator());\n \t      return __result;\n \t    }\n \t  catch(...)\n@@ -785,7 +795,7 @@ namespace _GLIBCXX_STD\n \t  this->_M_impl._M_start = _M_allocate(__n);\n \t  this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;\n \t  std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,\n-\t\t\t\t\tthis->get_allocator());\n+\t\t\t\t\t_M_get_Tp_allocator());\n \t  this->_M_impl._M_finish = this->_M_impl._M_end_of_storage;\n \t}\n \n@@ -822,7 +832,7 @@ namespace _GLIBCXX_STD\n \t  this->_M_impl._M_finish =\n \t    std::__uninitialized_copy_a(__first, __last,\n \t\t\t\t\tthis->_M_impl._M_start,\n-\t\t\t\t\tthis->get_allocator());\n+\t\t\t\t\t_M_get_Tp_allocator());\n \t}\n \n "}, {"sha": "aa1634bbc5e1f55006242e6e885aeb9020098af6", "filename": "libstdc++-v3/include/bits/vector.tcc", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fd20a8f82fb5cd17fd32a5218054447d45ada69/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvector.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fd20a8f82fb5cd17fd32a5218054447d45ada69/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvector.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvector.tcc?ref=4fd20a8f82fb5cd17fd32a5218054447d45ada69", "patch": "@@ -77,7 +77,7 @@ namespace _GLIBCXX_STD\n \t\t\t\t\t       this->_M_impl._M_start,\n \t\t\t\t\t       this->_M_impl._M_finish);\n \t  std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,\n-\t\t\tthis->get_allocator());\n+\t\t\t_M_get_Tp_allocator());\n \t  _M_deallocate(this->_M_impl._M_start,\n \t\t\tthis->_M_impl._M_end_of_storage\n \t\t\t- this->_M_impl._M_start);\n@@ -122,7 +122,7 @@ namespace _GLIBCXX_STD\n     erase(iterator __first, iterator __last)\n     {\n       iterator __i(std::copy(__last, end(), __first));\n-      std::_Destroy(__i, end(), this->get_allocator());\n+      std::_Destroy(__i, end(), _M_get_Tp_allocator());\n       this->_M_impl._M_finish = this->_M_impl._M_finish - (__last - __first);\n       return __first;\n     }\n@@ -140,7 +140,7 @@ namespace _GLIBCXX_STD\n \t      pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(),\n \t\t\t\t\t\t   __x.end());\n \t      std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,\n-\t\t\t    this->get_allocator());\n+\t\t\t    _M_get_Tp_allocator());\n \t      _M_deallocate(this->_M_impl._M_start,\n \t\t\t    this->_M_impl._M_end_of_storage\n \t\t\t    - this->_M_impl._M_start);\n@@ -150,15 +150,15 @@ namespace _GLIBCXX_STD\n \t  else if (size() >= __xlen)\n \t    {\n \t      iterator __i(std::copy(__x.begin(), __x.end(), begin()));\n-\t      std::_Destroy(__i, end(), this->get_allocator());\n+\t      std::_Destroy(__i, end(), _M_get_Tp_allocator());\n \t    }\n \t  else\n \t    {\n \t      std::copy(__x.begin(), __x.begin() + size(),\n \t\t\tthis->_M_impl._M_start);\n \t      std::__uninitialized_copy_a(__x.begin() + size(),\n \t\t\t\t\t  __x.end(), this->_M_impl._M_finish,\n-\t\t\t\t\t  this->get_allocator());\n+\t\t\t\t\t  _M_get_Tp_allocator());\n \t    }\n \t  this->_M_impl._M_finish = this->_M_impl._M_start + __xlen;\n \t}\n@@ -172,15 +172,15 @@ namespace _GLIBCXX_STD\n     {\n       if (__n > capacity())\n \t{\n-\t  vector __tmp(__n, __val, get_allocator());\n+\t  vector __tmp(__n, __val, _M_get_Tp_allocator());\n \t  __tmp.swap(*this);\n \t}\n       else if (__n > size())\n \t{\n \t  std::fill(begin(), end(), __val);\n \t  std::__uninitialized_fill_n_a(this->_M_impl._M_finish,\n \t\t\t\t\t__n - size(), __val,\n-\t\t\t\t\tthis->get_allocator());\n+\t\t\t\t\t_M_get_Tp_allocator());\n \t  this->_M_impl._M_finish += __n - size();\n \t}\n       else\n@@ -216,7 +216,7 @@ namespace _GLIBCXX_STD\n \t  {\n \t    pointer __tmp(_M_allocate_and_copy(__len, __first, __last));\n \t    std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,\n-\t\t\t  this->get_allocator());\n+\t\t\t  _M_get_Tp_allocator());\n \t    _M_deallocate(this->_M_impl._M_start,\n \t\t\t  this->_M_impl._M_end_of_storage\n \t\t\t  - this->_M_impl._M_start);\n@@ -228,7 +228,7 @@ namespace _GLIBCXX_STD\n \t  {\n \t    iterator __new_finish(std::copy(__first, __last,\n \t\t\t\t       this->_M_impl._M_start));\n-\t    std::_Destroy(__new_finish, end(), this->get_allocator());\n+\t    std::_Destroy(__new_finish, end(), _M_get_Tp_allocator());\n \t    this->_M_impl._M_finish = __new_finish.base();\n \t  }\n \telse\n@@ -239,7 +239,7 @@ namespace _GLIBCXX_STD\n \t    this->_M_impl._M_finish =\n \t      std::__uninitialized_copy_a(__mid, __last,\n \t\t\t\t\t  this->_M_impl._M_finish,\n-\t\t\t\t\t  this->get_allocator());\n+\t\t\t\t\t  _M_get_Tp_allocator());\n \t  }\n       }\n \n@@ -280,22 +280,22 @@ namespace _GLIBCXX_STD\n \t\tstd::__uninitialized_copy_a(iterator(this->_M_impl._M_start),\n \t\t\t\t\t    __position,\n \t\t\t\t\t    __new_start,\n-\t\t\t\t\t    this->get_allocator());\n+\t\t\t\t\t    _M_get_Tp_allocator());\n \t      this->_M_impl.construct(__new_finish.base(), __x);\n \t      ++__new_finish;\n \t      __new_finish =\n \t\tstd::__uninitialized_copy_a(__position,\n \t\t\t\t\t    iterator(this->_M_impl._M_finish),\n \t\t\t\t\t    __new_finish,\n-\t\t\t\t\t    this->get_allocator());\n+\t\t\t\t\t    _M_get_Tp_allocator());\n \t    }\n \t  catch(...)\n \t    {\n-\t      std::_Destroy(__new_start, __new_finish, this->get_allocator());\n+\t      std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());\n \t      _M_deallocate(__new_start.base(),__len);\n \t      __throw_exception_again;\n \t    }\n-\t  std::_Destroy(begin(), end(), this->get_allocator());\n+\t  std::_Destroy(begin(), end(), _M_get_Tp_allocator());\n \t  _M_deallocate(this->_M_impl._M_start,\n \t\t\tthis->_M_impl._M_end_of_storage\n \t\t\t- this->_M_impl._M_start);\n@@ -323,7 +323,7 @@ namespace _GLIBCXX_STD\n \t\t  std::__uninitialized_copy_a(this->_M_impl._M_finish - __n,\n \t\t\t\t\t      this->_M_impl._M_finish,\n \t\t\t\t\t      this->_M_impl._M_finish,\n-\t\t\t\t\t      this->get_allocator());\n+\t\t\t\t\t      _M_get_Tp_allocator());\n \t\t  this->_M_impl._M_finish += __n;\n \t\t  std::copy_backward(__position, __old_finish - __n,\n \t\t\t\t     __old_finish);\n@@ -334,11 +334,11 @@ namespace _GLIBCXX_STD\n \t\t  std::__uninitialized_fill_n_a(this->_M_impl._M_finish,\n \t\t\t\t\t\t__n - __elems_after,\n \t\t\t\t\t\t__x_copy,\n-\t\t\t\t\t\tthis->get_allocator());\n+\t\t\t\t\t\t_M_get_Tp_allocator());\n \t\t  this->_M_impl._M_finish += __n - __elems_after;\n \t\t  std::__uninitialized_copy_a(__position, __old_finish,\n \t\t\t\t\t      this->_M_impl._M_finish,\n-\t\t\t\t\t      this->get_allocator());\n+\t\t\t\t\t      _M_get_Tp_allocator());\n \t\t  this->_M_impl._M_finish += __elems_after;\n \t\t  std::fill(__position, __old_finish, __x_copy);\n \t\t}\n@@ -361,23 +361,23 @@ namespace _GLIBCXX_STD\n \t\t  __new_finish =\n \t\t    std::__uninitialized_copy_a(begin(), __position,\n \t\t\t\t\t\t__new_start,\n-\t\t\t\t\t\tthis->get_allocator());\n+\t\t\t\t\t\t_M_get_Tp_allocator());\n \t\t  std::__uninitialized_fill_n_a(__new_finish, __n, __x,\n-\t\t\t\t\t\tthis->get_allocator());\n+\t\t\t\t\t\t_M_get_Tp_allocator());\n \t\t  __new_finish += __n;\n \t\t  __new_finish =\n \t\t    std::__uninitialized_copy_a(__position, end(), __new_finish,\n-\t\t\t\t\t\tthis->get_allocator());\n+\t\t\t\t\t\t_M_get_Tp_allocator());\n \t\t}\n \t      catch(...)\n \t\t{\n \t\t  std::_Destroy(__new_start, __new_finish,\n-\t\t\t\tthis->get_allocator());\n+\t\t\t\t_M_get_Tp_allocator());\n \t\t  _M_deallocate(__new_start.base(), __len);\n \t\t  __throw_exception_again;\n \t\t}\n \t      std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,\n-\t\t\t    this->get_allocator());\n+\t\t\t    _M_get_Tp_allocator());\n \t      _M_deallocate(this->_M_impl._M_start,\n \t\t\t    this->_M_impl._M_end_of_storage\n \t\t\t    - this->_M_impl._M_start);\n@@ -421,7 +421,7 @@ namespace _GLIBCXX_STD\n \t\t    std::__uninitialized_copy_a(this->_M_impl._M_finish - __n,\n \t\t\t\t\t\tthis->_M_impl._M_finish,\n \t\t\t\t\t\tthis->_M_impl._M_finish,\n-\t\t\t\t\t\tthis->get_allocator());\n+\t\t\t\t\t\t_M_get_Tp_allocator());\n \t\t    this->_M_impl._M_finish += __n;\n \t\t    std::copy_backward(__position, __old_finish - __n,\n \t\t\t\t       __old_finish);\n@@ -433,11 +433,11 @@ namespace _GLIBCXX_STD\n \t\t    std::advance(__mid, __elems_after);\n \t\t    std::__uninitialized_copy_a(__mid, __last,\n \t\t\t\t\t\tthis->_M_impl._M_finish,\n-\t\t\t\t\t\tthis->get_allocator());\n+\t\t\t\t\t\t_M_get_Tp_allocator());\n \t\t    this->_M_impl._M_finish += __n - __elems_after;\n \t\t    std::__uninitialized_copy_a(__position, __old_finish,\n \t\t\t\t\t\tthis->_M_impl._M_finish,\n-\t\t\t\t\t\tthis->get_allocator());\n+\t\t\t\t\t\t_M_get_Tp_allocator());\n \t\t    this->_M_impl._M_finish += __elems_after;\n \t\t    std::copy(__first, __mid, __position);\n \t\t  }\n@@ -461,25 +461,25 @@ namespace _GLIBCXX_STD\n \t\t      std::__uninitialized_copy_a(iterator(this->_M_impl._M_start),\n \t\t\t\t\t\t  __position,\n \t\t\t\t\t\t  __new_start,\n-\t\t\t\t\t\t  this->get_allocator());\n+\t\t\t\t\t\t  _M_get_Tp_allocator());\n \t\t    __new_finish =\n \t\t      std::__uninitialized_copy_a(__first, __last, __new_finish,\n-\t\t\t\t\t\t  this->get_allocator());\n+\t\t\t\t\t\t  _M_get_Tp_allocator());\n \t\t    __new_finish =\n \t\t      std::__uninitialized_copy_a(__position,\n \t\t\t\t\t\t  iterator(this->_M_impl._M_finish),\n \t\t\t\t\t\t  __new_finish,\n-\t\t\t\t\t\t  this->get_allocator());\n+\t\t\t\t\t\t  _M_get_Tp_allocator());\n \t\t  }\n \t\tcatch(...)\n \t\t  {\n \t\t    std::_Destroy(__new_start,__new_finish,\n-\t\t\t\t  this->get_allocator());\n+\t\t\t\t  _M_get_Tp_allocator());\n \t\t    _M_deallocate(__new_start.base(), __len);\n \t\t    __throw_exception_again;\n \t\t  }\n \t\tstd::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,\n-\t\t\t      this->get_allocator());\n+\t\t\t      _M_get_Tp_allocator());\n \t\t_M_deallocate(this->_M_impl._M_start,\n \t\t\t      this->_M_impl._M_end_of_storage\n \t\t\t      - this->_M_impl._M_start);"}, {"sha": "e65fdd8b86ae6fbe9b9a7de7e8504de3e5871d3b", "filename": "libstdc++-v3/testsuite/21_strings/basic_string/1.cc", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fd20a8f82fb5cd17fd32a5218054447d45ada69/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fbasic_string%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fd20a8f82fb5cd17fd32a5218054447d45ada69/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fbasic_string%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fbasic_string%2F1.cc?ref=4fd20a8f82fb5cd17fd32a5218054447d45ada69", "patch": "@@ -0,0 +1,36 @@\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// This file tests explicit instantiation of basic_string\n+\n+#include <string>\n+\n+// { dg-do compile }\n+\n+// libstdc++/21770\n+template class std::basic_string<int, std::char_traits<int>,\n+\t\t\t\t std::allocator<char> >;"}, {"sha": "e6e758d0c74ba33e7b98235079c83a6f0ff993b8", "filename": "libstdc++-v3/testsuite/23_containers/deque/explicit_instantiation/1.cc", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fd20a8f82fb5cd17fd32a5218054447d45ada69/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Fexplicit_instantiation%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fd20a8f82fb5cd17fd32a5218054447d45ada69/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Fexplicit_instantiation%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Fexplicit_instantiation%2F1.cc?ref=4fd20a8f82fb5cd17fd32a5218054447d45ada69", "previous_filename": "libstdc++-v3/testsuite/23_containers/deque/explicit_instantiation.cc"}, {"sha": "51b4551c4da1d0b3f5f2d905e3c59d867d27592a", "filename": "libstdc++-v3/testsuite/23_containers/deque/explicit_instantiation/3.cc", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fd20a8f82fb5cd17fd32a5218054447d45ada69/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Fexplicit_instantiation%2F3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fd20a8f82fb5cd17fd32a5218054447d45ada69/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Fexplicit_instantiation%2F3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Fexplicit_instantiation%2F3.cc?ref=4fd20a8f82fb5cd17fd32a5218054447d45ada69", "patch": "@@ -0,0 +1,35 @@\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// This file tests explicit instantiation of library containers\n+\n+#include <deque>\n+\n+// { dg-do compile }\n+\n+// libstdc++/21770\n+template class std::deque<int, std::allocator<char> >;"}, {"sha": "2c9db8d3f866ec1870e6dc8a44665cb6faa84639", "filename": "libstdc++-v3/testsuite/23_containers/list/explicit_instantiation/1.cc", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fd20a8f82fb5cd17fd32a5218054447d45ada69/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Fexplicit_instantiation%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fd20a8f82fb5cd17fd32a5218054447d45ada69/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Fexplicit_instantiation%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Fexplicit_instantiation%2F1.cc?ref=4fd20a8f82fb5cd17fd32a5218054447d45ada69", "previous_filename": "libstdc++-v3/testsuite/23_containers/list/explicit_instantiation.cc"}, {"sha": "19f719dfff4893a04378ce787695766bfa505b4d", "filename": "libstdc++-v3/testsuite/23_containers/list/explicit_instantiation/3.cc", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fd20a8f82fb5cd17fd32a5218054447d45ada69/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Fexplicit_instantiation%2F3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fd20a8f82fb5cd17fd32a5218054447d45ada69/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Fexplicit_instantiation%2F3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Fexplicit_instantiation%2F3.cc?ref=4fd20a8f82fb5cd17fd32a5218054447d45ada69", "patch": "@@ -0,0 +1,35 @@\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// This file tests explicit instantiation of library containers\n+\n+#include <list>\n+\n+// { dg-do compile }\n+\n+// libstdc++/21770\n+template class std::list<int, std::allocator<char> >;"}, {"sha": "4ceb250156936f9d93099259a7b2b49079c2e6f8", "filename": "libstdc++-v3/testsuite/23_containers/map/explicit_instantiation/1.cc", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fd20a8f82fb5cd17fd32a5218054447d45ada69/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fexplicit_instantiation%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fd20a8f82fb5cd17fd32a5218054447d45ada69/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fexplicit_instantiation%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fexplicit_instantiation%2F1.cc?ref=4fd20a8f82fb5cd17fd32a5218054447d45ada69", "previous_filename": "libstdc++-v3/testsuite/23_containers/map/explicit_instantiation.cc"}, {"sha": "8ce3b6feda34dc2dc9b10edb23f694d49721d2cb", "filename": "libstdc++-v3/testsuite/23_containers/map/explicit_instantiation/3.cc", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fd20a8f82fb5cd17fd32a5218054447d45ada69/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fexplicit_instantiation%2F3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fd20a8f82fb5cd17fd32a5218054447d45ada69/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fexplicit_instantiation%2F3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fexplicit_instantiation%2F3.cc?ref=4fd20a8f82fb5cd17fd32a5218054447d45ada69", "patch": "@@ -0,0 +1,35 @@\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// This file tests explicit instantiation of library containers\n+\n+#include <map>\n+\n+// { dg-do compile }\n+\n+// libstdc++/21770\n+template class std::map<int, double, std::less<int>, std::allocator<char> >;"}, {"sha": "4a740b250f67c40a295846b55ebd5f7cc37b8d61", "filename": "libstdc++-v3/testsuite/23_containers/multimap/explicit_instantiation/1.cc", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fd20a8f82fb5cd17fd32a5218054447d45ada69/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fexplicit_instantiation%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fd20a8f82fb5cd17fd32a5218054447d45ada69/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fexplicit_instantiation%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fexplicit_instantiation%2F1.cc?ref=4fd20a8f82fb5cd17fd32a5218054447d45ada69", "previous_filename": "libstdc++-v3/testsuite/23_containers/multimap/explicit_instantiation.cc"}, {"sha": "1c434b8501f0e03a69f927be4be26a95fc8ba721", "filename": "libstdc++-v3/testsuite/23_containers/multimap/explicit_instantiation/3.cc", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fd20a8f82fb5cd17fd32a5218054447d45ada69/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fexplicit_instantiation%2F3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fd20a8f82fb5cd17fd32a5218054447d45ada69/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fexplicit_instantiation%2F3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fexplicit_instantiation%2F3.cc?ref=4fd20a8f82fb5cd17fd32a5218054447d45ada69", "patch": "@@ -0,0 +1,35 @@\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// This file tests explicit instantiation of library containers\n+\n+#include <map>\n+\n+// { dg-do compile }\n+\n+// libstdc++/21770\n+template class std::multimap<int, double, std::less<int>, std::allocator<char> >;"}, {"sha": "fb6b5f1db19139512b039aa36e2c0731fbc0df0b", "filename": "libstdc++-v3/testsuite/23_containers/multiset/explicit_instantiation/1.cc", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fd20a8f82fb5cd17fd32a5218054447d45ada69/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fexplicit_instantiation%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fd20a8f82fb5cd17fd32a5218054447d45ada69/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fexplicit_instantiation%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fexplicit_instantiation%2F1.cc?ref=4fd20a8f82fb5cd17fd32a5218054447d45ada69", "previous_filename": "libstdc++-v3/testsuite/23_containers/multiset/explicit_instantiation.cc"}, {"sha": "2b36bb92646dbef85df7db563da88e2376a0db5d", "filename": "libstdc++-v3/testsuite/23_containers/multiset/explicit_instantiation/3.cc", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fd20a8f82fb5cd17fd32a5218054447d45ada69/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fexplicit_instantiation%2F3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fd20a8f82fb5cd17fd32a5218054447d45ada69/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fexplicit_instantiation%2F3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fexplicit_instantiation%2F3.cc?ref=4fd20a8f82fb5cd17fd32a5218054447d45ada69", "patch": "@@ -0,0 +1,35 @@\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// This file tests explicit instantiation of library containers\n+\n+#include <set>\n+\n+// { dg-do compile }\n+\n+// libstdc++/21770\n+template class std::multiset<int, std::less<int>, std::allocator<char> >;"}, {"sha": "02e33be0456dd0c1ed5fe2b699b7c8a7ec812fa0", "filename": "libstdc++-v3/testsuite/23_containers/set/explicit_instantiation/1.cc", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fd20a8f82fb5cd17fd32a5218054447d45ada69/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fexplicit_instantiation%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fd20a8f82fb5cd17fd32a5218054447d45ada69/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fexplicit_instantiation%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fexplicit_instantiation%2F1.cc?ref=4fd20a8f82fb5cd17fd32a5218054447d45ada69", "previous_filename": "libstdc++-v3/testsuite/23_containers/set/explicit_instantiation.cc"}, {"sha": "c2323226916fe6b8775890c52095af8d0852884a", "filename": "libstdc++-v3/testsuite/23_containers/set/explicit_instantiation/3.cc", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fd20a8f82fb5cd17fd32a5218054447d45ada69/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fexplicit_instantiation%2F3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fd20a8f82fb5cd17fd32a5218054447d45ada69/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fexplicit_instantiation%2F3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fexplicit_instantiation%2F3.cc?ref=4fd20a8f82fb5cd17fd32a5218054447d45ada69", "patch": "@@ -0,0 +1,35 @@\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// This file tests explicit instantiation of library containers\n+\n+#include <set>\n+\n+// { dg-do compile }\n+\n+// libstdc++/21770\n+template class std::set<int, std::less<int>, std::allocator<char> >;"}, {"sha": "0668bbd12abdf5efc14187a33f4b508257e4552e", "filename": "libstdc++-v3/testsuite/23_containers/vector/explicit_instantiation/1.cc", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fd20a8f82fb5cd17fd32a5218054447d45ada69/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fexplicit_instantiation%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fd20a8f82fb5cd17fd32a5218054447d45ada69/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fexplicit_instantiation%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fexplicit_instantiation%2F1.cc?ref=4fd20a8f82fb5cd17fd32a5218054447d45ada69", "previous_filename": "libstdc++-v3/testsuite/23_containers/vector/explicit_instantiation.cc"}, {"sha": "2cd0b23fcb6b0007f133c6c95d51e6ecccd82469", "filename": "libstdc++-v3/testsuite/23_containers/vector/explicit_instantiation/3.cc", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fd20a8f82fb5cd17fd32a5218054447d45ada69/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fexplicit_instantiation%2F3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fd20a8f82fb5cd17fd32a5218054447d45ada69/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fexplicit_instantiation%2F3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fexplicit_instantiation%2F3.cc?ref=4fd20a8f82fb5cd17fd32a5218054447d45ada69", "patch": "@@ -0,0 +1,35 @@\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// This file tests explicit instantiation of library containers\n+\n+#include <vector>\n+\n+// { dg-do compile }\n+\n+// libstdc++/21770\n+template class std::vector<int, std::allocator<char> >;"}]}