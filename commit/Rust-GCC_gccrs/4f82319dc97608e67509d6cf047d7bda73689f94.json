{"sha": "4f82319dc97608e67509d6cf047d7bda73689f94", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGY4MjMxOWRjOTc2MDhlNjc1MDlkNmNmMDQ3ZDdiZGE3MzY4OWY5NA==", "commit": {"author": {"name": "Chung-Lin Tang", "email": "cltang@codesourcery.com", "date": "2011-05-08T19:30:36Z"}, "committer": {"name": "Chung-Lin Tang", "email": "cltang@gcc.gnu.org", "date": "2011-05-08T19:30:36Z"}, "message": "combine.c (simplify_comparison): Abstract out parts into...\n\n2011-05-08  Chung-Lin Tang  <cltang@codesourcery.com>\n\n\t* combine.c (simplify_comparison): Abstract out parts into...\n\t(simplify_compare_const): ... new function.\n\t(try_combine): Generalize parallel arithmetic/compare combining\n\tto call simplify_compare_const() and CANONICALIZE_COMPARE().\n\nFrom-SVN: r173552", "tree": {"sha": "76e08c60e6e6bf1b0949acd86913307d55ed1dee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/76e08c60e6e6bf1b0949acd86913307d55ed1dee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4f82319dc97608e67509d6cf047d7bda73689f94", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f82319dc97608e67509d6cf047d7bda73689f94", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f82319dc97608e67509d6cf047d7bda73689f94", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f82319dc97608e67509d6cf047d7bda73689f94/comments", "author": {"login": "cltang", "id": 4055966, "node_id": "MDQ6VXNlcjQwNTU5NjY=", "avatar_url": "https://avatars.githubusercontent.com/u/4055966?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cltang", "html_url": "https://github.com/cltang", "followers_url": "https://api.github.com/users/cltang/followers", "following_url": "https://api.github.com/users/cltang/following{/other_user}", "gists_url": "https://api.github.com/users/cltang/gists{/gist_id}", "starred_url": "https://api.github.com/users/cltang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cltang/subscriptions", "organizations_url": "https://api.github.com/users/cltang/orgs", "repos_url": "https://api.github.com/users/cltang/repos", "events_url": "https://api.github.com/users/cltang/events{/privacy}", "received_events_url": "https://api.github.com/users/cltang/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "74605a11f3c482656558d332058870d15cc718d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74605a11f3c482656558d332058870d15cc718d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74605a11f3c482656558d332058870d15cc718d5"}], "stats": {"total": 492, "additions": 275, "deletions": 217}, "files": [{"sha": "b7f6d3b6f02fb8d7723ac9f5d951bfa08421e5ff", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f82319dc97608e67509d6cf047d7bda73689f94/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f82319dc97608e67509d6cf047d7bda73689f94/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4f82319dc97608e67509d6cf047d7bda73689f94", "patch": "@@ -1,3 +1,10 @@\n+2011-05-08  Chung-Lin Tang  <cltang@codesourcery.com>\n+\n+\t* combine.c (simplify_comparison): Abstract out parts into...\n+\t(simplify_compare_const): ... new function.\n+\t(try_combine): Generalize parallel arithmetic/compare combining\n+\tto call simplify_compare_const() and CANONICALIZE_COMPARE().\n+\n 2011-05-08  Jan Hubicka  <jh@suse.cz>\n \n \t* cgraph.c (cgraph_clone_node): Add call_duplication_hook parameter."}, {"sha": "8af86f2c545aa25af204ff3ed76652a24b520521", "filename": "gcc/combine.c", "status": "modified", "additions": 268, "deletions": 217, "changes": 485, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f82319dc97608e67509d6cf047d7bda73689f94/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f82319dc97608e67509d6cf047d7bda73689f94/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=4f82319dc97608e67509d6cf047d7bda73689f94", "patch": "@@ -450,6 +450,7 @@ static rtx simplify_shift_const (rtx, enum rtx_code, enum machine_mode, rtx,\n \t\t\t\t int);\n static int recog_for_combine (rtx *, rtx, rtx *);\n static rtx gen_lowpart_for_combine (enum machine_mode, rtx);\n+static enum rtx_code simplify_compare_const (enum rtx_code, rtx, rtx *);\n static enum rtx_code simplify_comparison (enum rtx_code, rtx *, rtx *);\n static void update_table_tick (rtx);\n static void record_value_for_reg (rtx, rtx, rtx);\n@@ -3046,58 +3047,98 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p,\n \n   if (i1 == 0 && added_sets_2 && GET_CODE (PATTERN (i3)) == SET\n       && GET_CODE (SET_SRC (PATTERN (i3))) == COMPARE\n-      && XEXP (SET_SRC (PATTERN (i3)), 1) == const0_rtx\n+      && CONST_INT_P (XEXP (SET_SRC (PATTERN (i3)), 1))\n       && rtx_equal_p (XEXP (SET_SRC (PATTERN (i3)), 0), i2dest))\n     {\n-#ifdef SELECT_CC_MODE\n-      rtx *cc_use;\n-      enum machine_mode compare_mode;\n-#endif\n+      rtx newpat_dest;\n+      rtx *cc_use_loc = NULL, cc_use_insn = NULL_RTX;\n+      rtx op0 = i2src, op1 = XEXP (SET_SRC (PATTERN (i3)), 1);\n+      enum machine_mode compare_mode, orig_compare_mode;\n+      enum rtx_code compare_code = UNKNOWN, orig_compare_code = UNKNOWN;\n \n       newpat = PATTERN (i3);\n-      SUBST (XEXP (SET_SRC (newpat), 0), i2src);\n-\n-      i2_is_used = 1;\n+      newpat_dest = SET_DEST (newpat);\n+      compare_mode = orig_compare_mode = GET_MODE (newpat_dest);\n \n-#ifdef SELECT_CC_MODE\n-      /* See if a COMPARE with the operand we substituted in should be done\n-\t with the mode that is currently being used.  If not, do the same\n-\t processing we do in `subst' for a SET; namely, if the destination\n-\t is used only once, try to replace it with a register of the proper\n-\t mode and also replace the COMPARE.  */\n       if (undobuf.other_insn == 0\n-\t  && (cc_use = find_single_use (SET_DEST (newpat), i3,\n-\t\t\t\t\t&undobuf.other_insn))\n-\t  && ((compare_mode = SELECT_CC_MODE (GET_CODE (*cc_use),\n-\t\t\t\t\t      i2src, const0_rtx))\n-\t      != GET_MODE (SET_DEST (newpat))))\n+\t  && (cc_use_loc = find_single_use (SET_DEST (newpat), i3,\n+\t\t\t\t\t    &cc_use_insn)))\n \t{\n-\t  if (can_change_dest_mode (SET_DEST (newpat), added_sets_2,\n-\t\t\t\t    compare_mode))\n-\t    {\n-\t      unsigned int regno = REGNO (SET_DEST (newpat));\n-\t      rtx new_dest;\n+\t  compare_code = orig_compare_code = GET_CODE (*cc_use_loc);\n+\t  compare_code = simplify_compare_const (compare_code,\n+\t\t\t\t\t\t op0, &op1);\n+#ifdef CANONICALIZE_COMPARISON\n+\t  CANONICALIZE_COMPARISON (compare_code, op0, op1);\n+#endif\n+\t}\n \n-\t      if (regno < FIRST_PSEUDO_REGISTER)\n-\t\tnew_dest = gen_rtx_REG (compare_mode, regno);\n-\t      else\n+      /* Do the rest only if op1 is const0_rtx, which may be the\n+\t result of simplification.  */\n+      if (op1 == const0_rtx)\n+\t{\n+\t  /* If a single use of the CC is found, prepare to modify it\n+\t     when SELECT_CC_MODE returns a new CC-class mode, or when\n+\t     the above simplify_compare_const() returned a new comparison\n+\t     operator.  undobuf.other_insn is assigned the CC use insn\n+\t     when modifying it.  */\n+\t  if (cc_use_loc)\n+\t    {\n+#ifdef SELECT_CC_MODE\n+\t      enum machine_mode new_mode\n+\t\t= SELECT_CC_MODE (compare_code, op0, op1);\n+\t      if (new_mode != orig_compare_mode\n+\t\t  && can_change_dest_mode (SET_DEST (newpat),\n+\t\t\t\t\t   added_sets_2, new_mode))\n \t\t{\n-\t\t  SUBST_MODE (regno_reg_rtx[regno], compare_mode);\n-\t\t  new_dest = regno_reg_rtx[regno];\n+\t\t  unsigned int regno = REGNO (newpat_dest);\n+\t\t  compare_mode = new_mode;\n+\t\t  if (regno < FIRST_PSEUDO_REGISTER)\n+\t\t    newpat_dest = gen_rtx_REG (compare_mode, regno);\n+\t\t  else\n+\t\t    {\n+\t\t      SUBST_MODE (regno_reg_rtx[regno], compare_mode);\n+\t\t      newpat_dest = regno_reg_rtx[regno];\n+\t\t    }\n \t\t}\n-\n-\t      SUBST (SET_DEST (newpat), new_dest);\n-\t      SUBST (XEXP (*cc_use, 0), new_dest);\n-\t      SUBST (SET_SRC (newpat),\n-\t\t     gen_rtx_COMPARE (compare_mode, i2src, const0_rtx));\n-\t    }\n-\t  else\n-\t    undobuf.other_insn = 0;\n-\t}\n #endif\n+\t      /* Cases for modifying the CC-using comparison.  */\n+\t      if (compare_code != orig_compare_code\n+\t\t  /* ??? Do we need to verify the zero rtx?  */\n+\t\t  && XEXP (*cc_use_loc, 1) == const0_rtx)\n+\t\t{\n+\t\t  /* Replace cc_use_loc with entire new RTX.  */\n+\t\t  SUBST (*cc_use_loc,\n+\t\t\t gen_rtx_fmt_ee (compare_code, compare_mode,\n+\t\t\t\t\t newpat_dest, const0_rtx));\n+\t\t  undobuf.other_insn = cc_use_insn;\n+\t\t}\n+\t      else if (compare_mode != orig_compare_mode)\n+\t\t{\n+\t\t  /* Just replace the CC reg with a new mode.  */\n+\t\t  SUBST (XEXP (*cc_use_loc, 0), newpat_dest);\n+\t\t  undobuf.other_insn = cc_use_insn;\n+\t\t}\t      \n+\t    }\n+\n+\t  /* Now we modify the current newpat:\n+\t     First, SET_DEST(newpat) is updated if the CC mode has been\n+\t     altered. For targets without SELECT_CC_MODE, this should be\n+\t     optimized away.  */\n+\t  if (compare_mode != orig_compare_mode)\n+\t    SUBST (SET_DEST (newpat), newpat_dest);\n+\t  /* This is always done to propagate i2src into newpat.  */\n+\t  SUBST (SET_SRC (newpat),\n+\t\t gen_rtx_COMPARE (compare_mode, op0, op1));\n+\t  /* Create new version of i2pat if needed; the below PARALLEL\n+\t     creation needs this to work correctly.  */\n+\t  if (! rtx_equal_p (i2src, op0))\n+\t    i2pat = gen_rtx_SET (VOIDmode, i2dest, op0);\n+\t  i2_is_used = 1;\n+\t}\n     }\n-  else\n #endif\n+\n+  if (i2_is_used == 0)\n     {\n       /* It is possible that the source of I2 or I1 may be performing\n \t an unneeded operation, such as a ZERO_EXTEND of something\n@@ -10811,6 +10852,191 @@ gen_lowpart_for_combine (enum machine_mode omode, rtx x)\n   return gen_rtx_CLOBBER (omode, const0_rtx);\n }\n \f\n+/* Try to simplify a comparison between OP0 and a constant OP1,\n+   where CODE is the comparison code that will be tested, into a\n+   (CODE OP0 const0_rtx) form.\n+\n+   The result is a possibly different comparison code to use.\n+   *POP1 may be updated.  */\n+\n+static enum rtx_code\n+simplify_compare_const (enum rtx_code code, rtx op0, rtx *pop1)\n+{\n+  enum machine_mode mode = GET_MODE (op0);\n+  unsigned int mode_width = GET_MODE_BITSIZE (mode);\n+  HOST_WIDE_INT const_op = INTVAL (*pop1);\n+\n+  /* Get the constant we are comparing against and turn off all bits\n+     not on in our mode.  */\n+  if (mode != VOIDmode)\n+    const_op = trunc_int_for_mode (const_op, mode);\n+\n+  /* If we are comparing against a constant power of two and the value\n+     being compared can only have that single bit nonzero (e.g., it was\n+     `and'ed with that bit), we can replace this with a comparison\n+     with zero.  */\n+  if (const_op\n+      && (code == EQ || code == NE || code == GE || code == GEU\n+\t  || code == LT || code == LTU)\n+      && mode_width <= HOST_BITS_PER_WIDE_INT\n+      && exact_log2 (const_op) >= 0\n+      && nonzero_bits (op0, mode) == (unsigned HOST_WIDE_INT) const_op)\n+    {\n+      code = (code == EQ || code == GE || code == GEU ? NE : EQ);\n+      const_op = 0;\n+    }\n+\n+  /* Similarly, if we are comparing a value known to be either -1 or\n+     0 with -1, change it to the opposite comparison against zero.  */\n+  if (const_op == -1\n+      && (code == EQ || code == NE || code == GT || code == LE\n+\t  || code == GEU || code == LTU)\n+      && num_sign_bit_copies (op0, mode) == mode_width)\n+    {\n+      code = (code == EQ || code == LE || code == GEU ? NE : EQ);\n+      const_op = 0;\n+    }\n+\n+  /* Do some canonicalizations based on the comparison code.  We prefer\n+     comparisons against zero and then prefer equality comparisons.\n+     If we can reduce the size of a constant, we will do that too.  */\n+  switch (code)\n+    {\n+    case LT:\n+      /* < C is equivalent to <= (C - 1) */\n+      if (const_op > 0)\n+\t{\n+\t  const_op -= 1;\n+\t  code = LE;\n+\t  /* ... fall through to LE case below.  */\n+\t}\n+      else\n+\tbreak;\n+\n+    case LE:\n+      /* <= C is equivalent to < (C + 1); we do this for C < 0  */\n+      if (const_op < 0)\n+\t{\n+\t  const_op += 1;\n+\t  code = LT;\n+\t}\n+\n+      /* If we are doing a <= 0 comparison on a value known to have\n+\t a zero sign bit, we can replace this with == 0.  */\n+      else if (const_op == 0\n+\t       && mode_width <= HOST_BITS_PER_WIDE_INT\n+\t       && (nonzero_bits (op0, mode)\n+\t\t   & ((unsigned HOST_WIDE_INT) 1 << (mode_width - 1)))\n+\t       == 0)\n+\tcode = EQ;\n+      break;\n+\n+    case GE:\n+      /* >= C is equivalent to > (C - 1).  */\n+      if (const_op > 0)\n+\t{\n+\t  const_op -= 1;\n+\t  code = GT;\n+\t  /* ... fall through to GT below.  */\n+\t}\n+      else\n+\tbreak;\n+\n+    case GT:\n+      /* > C is equivalent to >= (C + 1); we do this for C < 0.  */\n+      if (const_op < 0)\n+\t{\n+\t  const_op += 1;\n+\t  code = GE;\n+\t}\n+\n+      /* If we are doing a > 0 comparison on a value known to have\n+\t a zero sign bit, we can replace this with != 0.  */\n+      else if (const_op == 0\n+\t       && mode_width <= HOST_BITS_PER_WIDE_INT\n+\t       && (nonzero_bits (op0, mode)\n+\t\t   & ((unsigned HOST_WIDE_INT) 1 << (mode_width - 1)))\n+\t       == 0)\n+\tcode = NE;\n+      break;\n+\n+    case LTU:\n+      /* < C is equivalent to <= (C - 1).  */\n+      if (const_op > 0)\n+\t{\n+\t  const_op -= 1;\n+\t  code = LEU;\n+\t  /* ... fall through ...  */\n+\t}\n+      /* (unsigned) < 0x80000000 is equivalent to >= 0.  */\n+      else if (mode_width <= HOST_BITS_PER_WIDE_INT\n+\t       && (unsigned HOST_WIDE_INT) const_op\n+\t       == (unsigned HOST_WIDE_INT) 1 << (mode_width - 1))\n+\t{\n+\t  const_op = 0;\n+\t  code = GE;\n+\t  break;\n+\t}\n+      else\n+\tbreak;\n+\n+    case LEU:\n+      /* unsigned <= 0 is equivalent to == 0 */\n+      if (const_op == 0)\n+\tcode = EQ;\n+      /* (unsigned) <= 0x7fffffff is equivalent to >= 0.  */\n+      else if (mode_width <= HOST_BITS_PER_WIDE_INT\n+\t       && (unsigned HOST_WIDE_INT) const_op\n+\t       == ((unsigned HOST_WIDE_INT) 1 << (mode_width - 1)) - 1)\n+\t{\n+\t  const_op = 0;\n+\t  code = GE;\n+\t}\n+      break;\n+\n+    case GEU:\n+      /* >= C is equivalent to > (C - 1).  */\n+      if (const_op > 1)\n+\t{\n+\t  const_op -= 1;\n+\t  code = GTU;\n+\t  /* ... fall through ...  */\n+\t}\n+\n+      /* (unsigned) >= 0x80000000 is equivalent to < 0.  */\n+      else if (mode_width <= HOST_BITS_PER_WIDE_INT\n+\t       && (unsigned HOST_WIDE_INT) const_op\n+\t       == (unsigned HOST_WIDE_INT) 1 << (mode_width - 1))\n+\t{\n+\t  const_op = 0;\n+\t  code = LT;\n+\t  break;\n+\t}\n+      else\n+\tbreak;\n+\n+    case GTU:\n+      /* unsigned > 0 is equivalent to != 0 */\n+      if (const_op == 0)\n+\tcode = NE;\n+      /* (unsigned) > 0x7fffffff is equivalent to < 0.  */\n+      else if (mode_width <= HOST_BITS_PER_WIDE_INT\n+\t       && (unsigned HOST_WIDE_INT) const_op\n+\t       == ((unsigned HOST_WIDE_INT) 1 << (mode_width - 1)) - 1)\n+\t{\n+\t  const_op = 0;\n+\t  code = LT;\n+\t}\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  *pop1 = GEN_INT (const_op);\n+  return code;\n+}\n+\f\n /* Simplify a comparison between *POP0 and *POP1 where CODE is the\n    comparison code that will be tested.\n \n@@ -11000,185 +11226,10 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t\t&& (GET_CODE (op0) == COMPARE || COMPARISON_P (op0))))\n \tbreak;\n \n-      /* Get the constant we are comparing against and turn off all bits\n-\t not on in our mode.  */\n+      /* Try to simplify the compare to constant, possibly changing the\n+\t comparison op, and/or changing op1 to zero.  */\n+      code = simplify_compare_const (code, op0, &op1);\n       const_op = INTVAL (op1);\n-      if (mode != VOIDmode)\n-\tconst_op = trunc_int_for_mode (const_op, mode);\n-      op1 = GEN_INT (const_op);\n-\n-      /* If we are comparing against a constant power of two and the value\n-\t being compared can only have that single bit nonzero (e.g., it was\n-\t `and'ed with that bit), we can replace this with a comparison\n-\t with zero.  */\n-      if (const_op\n-\t  && (code == EQ || code == NE || code == GE || code == GEU\n-\t      || code == LT || code == LTU)\n-\t  && mode_width <= HOST_BITS_PER_WIDE_INT\n-\t  && exact_log2 (const_op) >= 0\n-\t  && nonzero_bits (op0, mode) == (unsigned HOST_WIDE_INT) const_op)\n-\t{\n-\t  code = (code == EQ || code == GE || code == GEU ? NE : EQ);\n-\t  op1 = const0_rtx, const_op = 0;\n-\t}\n-\n-      /* Similarly, if we are comparing a value known to be either -1 or\n-\t 0 with -1, change it to the opposite comparison against zero.  */\n-\n-      if (const_op == -1\n-\t  && (code == EQ || code == NE || code == GT || code == LE\n-\t      || code == GEU || code == LTU)\n-\t  && num_sign_bit_copies (op0, mode) == mode_width)\n-\t{\n-\t  code = (code == EQ || code == LE || code == GEU ? NE : EQ);\n-\t  op1 = const0_rtx, const_op = 0;\n-\t}\n-\n-      /* Do some canonicalizations based on the comparison code.  We prefer\n-\t comparisons against zero and then prefer equality comparisons.\n-\t If we can reduce the size of a constant, we will do that too.  */\n-\n-      switch (code)\n-\t{\n-\tcase LT:\n-\t  /* < C is equivalent to <= (C - 1) */\n-\t  if (const_op > 0)\n-\t    {\n-\t      const_op -= 1;\n-\t      op1 = GEN_INT (const_op);\n-\t      code = LE;\n-\t      /* ... fall through to LE case below.  */\n-\t    }\n-\t  else\n-\t    break;\n-\n-\tcase LE:\n-\t  /* <= C is equivalent to < (C + 1); we do this for C < 0  */\n-\t  if (const_op < 0)\n-\t    {\n-\t      const_op += 1;\n-\t      op1 = GEN_INT (const_op);\n-\t      code = LT;\n-\t    }\n-\n-\t  /* If we are doing a <= 0 comparison on a value known to have\n-\t     a zero sign bit, we can replace this with == 0.  */\n-\t  else if (const_op == 0\n-\t\t   && mode_width <= HOST_BITS_PER_WIDE_INT\n-\t\t   && (nonzero_bits (op0, mode)\n-\t\t       & ((unsigned HOST_WIDE_INT) 1 << (mode_width - 1)))\n-\t\t         == 0)\n-\t    code = EQ;\n-\t  break;\n-\n-\tcase GE:\n-\t  /* >= C is equivalent to > (C - 1).  */\n-\t  if (const_op > 0)\n-\t    {\n-\t      const_op -= 1;\n-\t      op1 = GEN_INT (const_op);\n-\t      code = GT;\n-\t      /* ... fall through to GT below.  */\n-\t    }\n-\t  else\n-\t    break;\n-\n-\tcase GT:\n-\t  /* > C is equivalent to >= (C + 1); we do this for C < 0.  */\n-\t  if (const_op < 0)\n-\t    {\n-\t      const_op += 1;\n-\t      op1 = GEN_INT (const_op);\n-\t      code = GE;\n-\t    }\n-\n-\t  /* If we are doing a > 0 comparison on a value known to have\n-\t     a zero sign bit, we can replace this with != 0.  */\n-\t  else if (const_op == 0\n-\t\t   && mode_width <= HOST_BITS_PER_WIDE_INT\n-\t\t   && (nonzero_bits (op0, mode)\n-\t\t       & ((unsigned HOST_WIDE_INT) 1 << (mode_width - 1)))\n-\t\t       == 0)\n-\t    code = NE;\n-\t  break;\n-\n-\tcase LTU:\n-\t  /* < C is equivalent to <= (C - 1).  */\n-\t  if (const_op > 0)\n-\t    {\n-\t      const_op -= 1;\n-\t      op1 = GEN_INT (const_op);\n-\t      code = LEU;\n-\t      /* ... fall through ...  */\n-\t    }\n-\n-\t  /* (unsigned) < 0x80000000 is equivalent to >= 0.  */\n-\t  else if (mode_width <= HOST_BITS_PER_WIDE_INT\n-\t\t   && (unsigned HOST_WIDE_INT) const_op\n-\t\t      == (unsigned HOST_WIDE_INT) 1 << (mode_width - 1))\n-\t    {\n-\t      const_op = 0, op1 = const0_rtx;\n-\t      code = GE;\n-\t      break;\n-\t    }\n-\t  else\n-\t    break;\n-\n-\tcase LEU:\n-\t  /* unsigned <= 0 is equivalent to == 0 */\n-\t  if (const_op == 0)\n-\t    code = EQ;\n-\n-\t  /* (unsigned) <= 0x7fffffff is equivalent to >= 0.  */\n-\t  else if (mode_width <= HOST_BITS_PER_WIDE_INT\n-\t\t   && (unsigned HOST_WIDE_INT) const_op\n-\t\t      == ((unsigned HOST_WIDE_INT) 1 << (mode_width - 1)) - 1)\n-\t    {\n-\t      const_op = 0, op1 = const0_rtx;\n-\t      code = GE;\n-\t    }\n-\t  break;\n-\n-\tcase GEU:\n-\t  /* >= C is equivalent to > (C - 1).  */\n-\t  if (const_op > 1)\n-\t    {\n-\t      const_op -= 1;\n-\t      op1 = GEN_INT (const_op);\n-\t      code = GTU;\n-\t      /* ... fall through ...  */\n-\t    }\n-\n-\t  /* (unsigned) >= 0x80000000 is equivalent to < 0.  */\n-\t  else if (mode_width <= HOST_BITS_PER_WIDE_INT\n-\t\t   && (unsigned HOST_WIDE_INT) const_op\n-\t\t      == (unsigned HOST_WIDE_INT) 1 << (mode_width - 1))\n-\t    {\n-\t      const_op = 0, op1 = const0_rtx;\n-\t      code = LT;\n-\t      break;\n-\t    }\n-\t  else\n-\t    break;\n-\n-\tcase GTU:\n-\t  /* unsigned > 0 is equivalent to != 0 */\n-\t  if (const_op == 0)\n-\t    code = NE;\n-\n-\t  /* (unsigned) > 0x7fffffff is equivalent to < 0.  */\n-\t  else if (mode_width <= HOST_BITS_PER_WIDE_INT\n-\t\t   && (unsigned HOST_WIDE_INT) const_op\n-\t\t      == ((unsigned HOST_WIDE_INT) 1 << (mode_width - 1)) - 1)\n-\t    {\n-\t      const_op = 0, op1 = const0_rtx;\n-\t      code = LT;\n-\t    }\n-\t  break;\n-\n-\tdefault:\n-\t  break;\n-\t}\n \n       /* Compute some predicates to simplify code below.  */\n "}]}