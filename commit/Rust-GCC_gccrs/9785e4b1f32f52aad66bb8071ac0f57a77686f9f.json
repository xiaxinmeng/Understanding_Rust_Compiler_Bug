{"sha": "9785e4b1f32f52aad66bb8071ac0f57a77686f9f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTc4NWU0YjFmMzJmNTJhYWQ2NmJiODA3MWFjMGY1N2E3NzY4NmY5Zg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-03-22T01:32:09Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-03-22T01:32:09Z"}, "message": "class.c (record_base_offsets): New function.\n\n\t* class.c (record_base_offsets): New function.\n\t(layout_conflict_p): Likewise.\n\t(layout_nonempty_base_or_field): Use it.\n\t(layout_empty_base): New function.\n\t(build_base_field): Use it.\n\t(build_base_fields): Update comment.\n\t(layout_virtual_bases): Fold in a little code form\n\tlayout_basetypes.  Use layout_empty_base.\n\t(layout_basetypes): Remove.\n\t(end_of_class): New function.\n\t(layout_class_type): Use it.  Adjust.\n\n\t* cp-tree.h (CLASSTYPE_VBASECLASSES): Fix typo in comment.\n\t(fntype_p): Remove.\n\t* search.c (dfs_skip_nonprimary_vbases_unmarkedp): Fix typo in\n\tcomment.\n\t(dfs_skip_nonprimary_vbases_markedp): Likewise.\n\t* typeck.c (fntype_p): Remove.\n\nFrom-SVN: r32679", "tree": {"sha": "bb1c066b4cceecc5bc492b906102efaff5c3e7ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bb1c066b4cceecc5bc492b906102efaff5c3e7ea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9785e4b1f32f52aad66bb8071ac0f57a77686f9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9785e4b1f32f52aad66bb8071ac0f57a77686f9f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9785e4b1f32f52aad66bb8071ac0f57a77686f9f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9785e4b1f32f52aad66bb8071ac0f57a77686f9f/comments", "author": null, "committer": null, "parents": [{"sha": "d8b64f80a019ea0fef5edc01e34eef40d214313f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8b64f80a019ea0fef5edc01e34eef40d214313f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8b64f80a019ea0fef5edc01e34eef40d214313f"}], "stats": {"total": 332, "additions": 216, "deletions": 116}, "files": [{"sha": "18593169e7b70fb0b249df69ebd8777fb22f7d15", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9785e4b1f32f52aad66bb8071ac0f57a77686f9f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9785e4b1f32f52aad66bb8071ac0f57a77686f9f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9785e4b1f32f52aad66bb8071ac0f57a77686f9f", "patch": "@@ -1,5 +1,24 @@\n 2000-03-21  Mark Mitchell  <mark@codesourcery.com>\n \n+\t* class.c (record_base_offsets): New function.\n+\t(layout_conflict_p): Likewise.\n+\t(layout_nonempty_base_or_field): Use it.\n+\t(layout_empty_base): New function.\n+\t(build_base_field): Use it.\n+\t(build_base_fields): Update comment.\n+\t(layout_virtual_bases): Fold in a little code form\n+\tlayout_basetypes.  Use layout_empty_base.\n+\t(layout_basetypes): Remove.\n+\t(end_of_class): New function.\n+\t(layout_class_type): Use it.  Adjust.\n+\n+\t* cp-tree.h (CLASSTYPE_VBASECLASSES): Fix typo in comment.\n+\t(fntype_p): Remove.\n+\t* search.c (dfs_skip_nonprimary_vbases_unmarkedp): Fix typo in\n+\tcomment. \n+\t(dfs_skip_nonprimary_vbases_markedp): Likewise.\n+\t* typeck.c (fntype_p): Remove.\n+\n \t* cp-tree.h (TI_SPEC_INFO): Remove.\n \t(CLASSTYPE_TI_SPEC_INFO): Likewise.\n \t* pt.c (process_partial_specialization): Likewise."}, {"sha": "3298b7ad3ad076775d3fdcd124eed144656e16d4", "filename": "gcc/cp/class.c", "status": "modified", "additions": 194, "deletions": 100, "changes": 294, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9785e4b1f32f52aad66bb8071ac0f57a77686f9f/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9785e4b1f32f52aad66bb8071ac0f57a77686f9f/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=9785e4b1f32f52aad66bb8071ac0f57a77686f9f", "patch": "@@ -133,8 +133,7 @@ static void fixup_inline_methods PARAMS ((tree));\n static void set_primary_base PARAMS ((tree, int, int *));\n static tree dfs_propagate_binfo_offsets PARAMS ((tree, void *));\n static void propagate_binfo_offsets PARAMS ((tree, tree));\n-static void layout_basetypes PARAMS ((tree));\n-static void layout_virtual_bases PARAMS ((tree));\n+static void layout_virtual_bases PARAMS ((tree, varray_type *));\n static tree dfs_set_offset_for_shared_vbases PARAMS ((tree, void *));\n static tree dfs_set_offset_for_unshared_vbases PARAMS ((tree, void *));\n static tree dfs_build_vbase_offset_vtbl_entries PARAMS ((tree, void *));\n@@ -156,6 +155,12 @@ static void initialize_vtable PARAMS ((tree, tree));\n static void layout_nonempty_base_or_field PARAMS ((record_layout_info,\n \t\t\t\t\t\t   tree, tree,\n \t\t\t\t\t\t   varray_type));\n+static tree dfs_record_base_offsets PARAMS ((tree, void *));\n+static void record_base_offsets PARAMS ((tree, varray_type *));\n+static tree dfs_search_base_offsets PARAMS ((tree, void *));\n+static int layout_conflict_p PARAMS ((tree, varray_type));\n+static unsigned HOST_WIDE_INT end_of_class PARAMS ((tree, int));\n+static void layout_empty_base PARAMS ((tree, tree, varray_type));\n \n /* Variables shared between class.c and call.c.  */\n \n@@ -4130,6 +4135,26 @@ dfs_record_base_offsets (binfo, data)\n   return NULL_TREE;\n }\n \n+/* Add the offset of BINFO and its bases to BASE_OFFSETS.  */\n+\n+static void\n+record_base_offsets (binfo, base_offsets)\n+     tree binfo;\n+     varray_type *base_offsets;\n+{\n+  int virtual_p;\n+\n+  /* If BINFO is virtual, we still want to mention its offset in\n+     BASE_OFFSETS.  */\n+  virtual_p = TREE_VIA_VIRTUAL (binfo);\n+  TREE_VIA_VIRTUAL (binfo) = 0;\n+  dfs_walk (binfo,\n+\t    dfs_record_base_offsets,\n+\t    dfs_skip_vbases,\n+\t    base_offsets);\n+  TREE_VIA_VIRTUAL (binfo) = virtual_p;\n+}\n+\n /* Returns non-NULL if there is already an entry in DATA (which is\n    really a `varray_type') indicating that an object with the same\n    type of BINFO is already at the BINFO_OFFSET for BINFO.  */\n@@ -4161,6 +4186,19 @@ dfs_search_base_offsets (binfo, data)\n   return NULL_TREE;\n }\n \n+/* Returns non-zero if there's a conflict between BINFO and a base\n+   already mentioned in BASE_OFFSETS if BINFO is placed at its current\n+   BINFO_OFFSET.  */\n+\n+static int\n+layout_conflict_p (binfo, base_offsets)\n+     tree binfo;\n+     varray_type base_offsets;\n+{\n+  return dfs_walk (binfo, dfs_search_base_offsets, dfs_skip_vbases,\n+\t\t   base_offsets) != NULL_TREE;\n+}\n+\n /* DECL is a FIELD_DECL corresponding either to a base subobject of a\n    non-static data member of the type indicated by RLI.  BINFO is the\n    binfo corresponding to the base subobject, or, if this is a\n@@ -4209,10 +4247,7 @@ layout_nonempty_base_or_field (rli, decl, binfo, v)\n \t empty class, have non-zero size, any overlap can happen only\n \t with a direct or indirect base-class -- it can't happen with\n \t a data member.  */\n-      if (binfo && flag_new_abi && dfs_walk (binfo,\n-\t\t\t\t\t     dfs_search_base_offsets,\n-\t\t\t\t\t     dfs_skip_vbases,\n-\t\t\t\t\t     v))\n+      if (binfo && flag_new_abi && layout_conflict_p (binfo, v))\n \t{\n \t  /* Undo the propogate_binfo_offsets call.  */\n \t  offset = convert (sizetype,\n@@ -4233,6 +4268,46 @@ layout_nonempty_base_or_field (rli, decl, binfo, v)\n     }\n }\n \n+/* Layout the empty base BINFO.  EOC indicates the byte currently just\n+   past the end of the class; BINFO_OFFSETS gives the offsets of the\n+   other bases allocated so far.  */\n+\n+static void\n+layout_empty_base (binfo, eoc, binfo_offsets)\n+     tree binfo;\n+     tree eoc;\n+     varray_type binfo_offsets;\n+{\n+  tree basetype = BINFO_TYPE (binfo);\n+  \n+  /* This routine should only be used for empty classes.  */\n+  my_friendly_assert (is_empty_class (basetype), 20000321);\n+\n+  /* This code assumes that zero-sized classes have one-byte\n+     alignment.  There might someday be a system where that's not\n+     true.  */\n+  my_friendly_assert (TYPE_ALIGN (basetype) == BITS_PER_UNIT, \n+\t\t      20000314);\n+\n+  /* This is an empty base class.  We first try to put it at offset\n+     zero.  */\n+  if (layout_conflict_p (binfo, binfo_offsets))\n+    {\n+      /* That didn't work.  Now, we move forward from the next\n+\t available spot in the class.  */\n+      propagate_binfo_offsets (binfo, eoc);\n+      while (1) \n+\t{\n+\t  if (!layout_conflict_p (binfo, binfo_offsets))\n+\t    /* We finally found a spot where there's no overlap.  */\n+\t    break;\n+\n+\t  /* There's overlap here, too.  Bump along to the next spot.  */\n+\t  propagate_binfo_offsets (binfo, size_one_node);\n+\t}\n+    }\n+}\n+\n /* Build a FIELD_DECL for the base given by BINFO in the class\n    *indicated by RLI.  If the new object is non-empty, clear *EMPTY_P.\n    *BASE_ALIGN is a running maximum of the alignments of any base\n@@ -4264,10 +4339,9 @@ build_base_field (rli, binfo, empty_p, base_align, v)\n   if (! flag_new_abi)\n     {\n       /* Brain damage for backwards compatibility.  For no good\n-\t reason, the old layout_basetypes made every base at least\n+\t reason, the old basetype layout made every base have at least\n \t as large as the alignment for the bases up to that point,\n-\t gratuitously wasting space.  So we do the same thing\n-\t here.  */\n+\t gratuitously wasting space.  So we do the same thing here.  */\n       *base_align = MAX (*base_align, DECL_ALIGN (decl));\n       DECL_SIZE (decl)\n \t= size_binop (MAX_EXPR, DECL_SIZE (decl), bitsize_int (*base_align));\n@@ -4288,34 +4362,9 @@ build_base_field (rli, binfo, empty_p, base_align, v)\n       layout_nonempty_base_or_field (rli, decl, binfo, *v);\n     }\n   else\n-    {\n-      /* This code assumes that zero-sized classes have one-byte\n-\t alignment.  There might someday be a system where that's not\n-\t true.  */\n-      my_friendly_assert (TYPE_ALIGN (basetype) == BITS_PER_UNIT, \n-\t\t\t  20000314);\n-\n-      /* This is an empty base class.  We first try to put it at\n-\t offset zero.  */\n-      if (dfs_walk (binfo, dfs_search_base_offsets, dfs_skip_vbases, *v))\n-\t{\n-\t  /* That didn't work.  Now, we move forward from the next\n-\t     available spot in the class.  */\n-\t  propagate_binfo_offsets (binfo, \n-\t\t\t\t   size_int (rli->const_size / BITS_PER_UNIT));\n-\t  while (1) \n-\t    {\n-\t      if (!dfs_walk (binfo, dfs_search_base_offsets, \n-\t\t\t     dfs_skip_vbases, *v))\n-\t\t/* We finally found a spot where there's no overlap.  */\n-\t\tbreak;\n-\n-\t      /* There's overlap here, too.  Bump along to the next\n-\t\t spot.  */\n-\t      propagate_binfo_offsets (binfo, size_one_node);\n-\t    }\n-\t}\n-    }\n+    layout_empty_base (binfo,\n+\t\t       size_int (CEIL (rli->const_size, BITS_PER_UNIT)),\n+\t\t       *v);\n \n   /* Check for inaccessible base classes.  If the same base class\n      appears more than once in the hierarchy, but isn't virtual, then\n@@ -4325,10 +4374,7 @@ build_base_field (rli, binfo, empty_p, base_align, v)\n \t\tbasetype, rli->t);\n   \n   /* Record the offsets of BINFO and its base subobjects.  */\n-  dfs_walk (binfo,\n-\t    dfs_record_base_offsets,\n-\t    dfs_skip_vbases,\n-\t    v);\n+  record_base_offsets (binfo, v);\n }\n \n /* Layout all of the non-virtual base classes.  Returns a map from\n@@ -4370,7 +4416,7 @@ build_base_fields (rli, empty_p)\n \n       /* A primary virtual base class is allocated just like any other\n \t base class, but a non-primary virtual base is allocated\n-\t later, in layout_basetypes.  */\n+\t later, in layout_virtual_bases.  */\n       if (TREE_VIA_VIRTUAL (base_binfo) \n \t  && !BINFO_PRIMARY_MARKED_P (base_binfo))\n \tcontinue;\n@@ -4764,14 +4810,26 @@ dfs_set_offset_for_unshared_vbases (binfo, data)\n }\n \n /* Set BINFO_OFFSET for all of the virtual bases for T.  Update\n-   TYPE_ALIGN and TYPE_SIZE for T.  */\n+   TYPE_ALIGN and TYPE_SIZE for T.  BASE_OFFSETS is a varray mapping\n+   offsets to the types at those offsets.  */\n \n static void\n-layout_virtual_bases (t)\n+layout_virtual_bases (t, base_offsets)\n      tree t;\n+     varray_type *base_offsets;\n {\n   tree vbase;\n   unsigned HOST_WIDE_INT dsize;\n+  unsigned HOST_WIDE_INT eoc;\n+\n+  if (CLASSTYPE_N_BASECLASSES (t) == 0)\n+    return;\n+\n+#ifdef STRUCTURE_SIZE_BOUNDARY\n+  /* Packed structures don't need to have minimum size.  */\n+  if (! TYPE_PACKED (rec))\n+    TYPE_ALIGN (rec) = MAX (TYPE_ALIGN (rec), STRUCTURE_SIZE_BOUNDARY);\n+#endif\n \n   /* DSIZE is the size of the class without the virtual bases.  */\n   dsize = tree_low_cst (TYPE_SIZE (t), 1);\n@@ -4792,19 +4850,39 @@ layout_virtual_bases (t)\n \tunsigned int desired_align;\n \n \tbasetype = BINFO_TYPE (vbase);\n-\tdesired_align = TYPE_ALIGN (basetype);\n-\tTYPE_ALIGN (t) = MAX (TYPE_ALIGN (t), desired_align);\n-\n-\t/* Add padding so that we can put the virtual base class at an\n-\t   appropriately aligned offset.  */\n-\tdsize = CEIL (dsize, desired_align) * desired_align;\n-\t/* And compute the offset of the virtual base.  */\n-\tpropagate_binfo_offsets (vbase, \n-\t\t\t\t size_int (CEIL (dsize, BITS_PER_UNIT)));\n-\t/* Every virtual baseclass takes a least a UNIT, so that we can\n-\t   take it's address and get something different for each base.  */\n-\tdsize += MAX (BITS_PER_UNIT,\n-\t\t      tree_low_cst (CLASSTYPE_SIZE (basetype), 0));\n+\n+\t/* Under the new ABI, we try to squish empty virtual bases in\n+\t   just like ordinary empty bases.  */\n+\tif (flag_new_abi && is_empty_class (basetype))\n+\t  layout_empty_base (vbase,\n+\t\t\t     size_int (CEIL (dsize, BITS_PER_UNIT)),\n+\t\t\t     *base_offsets);\n+\telse\n+\t  {\n+\t    if (flag_new_abi)\n+\t      desired_align = CLASSTYPE_ALIGN (basetype);\n+\t    else\n+\t      /* Under the old ABI, virtual bases were aligned as for\n+\t\t the entire base object (including its virtual bases).\n+\t\t That's wasteful, in general.  */\n+\t      desired_align = TYPE_ALIGN (basetype);\n+\t    TYPE_ALIGN (t) = MAX (TYPE_ALIGN (t), desired_align);\n+\n+\t    /* Add padding so that we can put the virtual base class at an\n+\t       appropriately aligned offset.  */\n+\t    dsize = CEIL (dsize, desired_align) * desired_align;\n+\t    /* And compute the offset of the virtual base.  */\n+\t    propagate_binfo_offsets (vbase, \n+\t\t\t\t     size_int (CEIL (dsize, BITS_PER_UNIT)));\n+\t    /* Every virtual baseclass takes a least a UNIT, so that\n+\t       we can take it's address and get something different\n+\t       for each base.  */\n+\t    dsize += MAX (BITS_PER_UNIT,\n+\t\t\t  tree_low_cst (CLASSTYPE_SIZE (basetype), 0));\n+\t  }\n+\n+\t/* Keep track of the offsets assigned to this virtual base.  */\n+\trecord_base_offsets (vbase, base_offsets);\n       }\n \n   /* Make sure that all of the CLASSTYPE_VBASECLASSES have their\n@@ -4827,51 +4905,68 @@ layout_virtual_bases (t)\n        vbase = TREE_CHAIN (vbase))\n     dfs_walk (vbase, dfs_set_offset_for_unshared_vbases, NULL, t);\n \n+  /* If we had empty base classes that protruded beyond the end of the\n+     class, we didn't update DSIZE above; we were hoping to overlay\n+     multiple such bases at the same location.  */\n+  eoc = end_of_class (t, /*include_virtuals_p=*/1);\n+  if (eoc * BITS_PER_UNIT > dsize)\n+    dsize = (eoc + 1) * BITS_PER_UNIT;\n+\n   /* Now, make sure that the total size of the type is a multiple of\n      its alignment.  */\n   dsize = CEIL (dsize, TYPE_ALIGN (t)) * TYPE_ALIGN (t);\n   TYPE_SIZE (t) = bitsize_int (dsize);\n   TYPE_SIZE_UNIT (t) = convert (sizetype,\n \t\t\t\tsize_binop (FLOOR_DIV_EXPR, TYPE_SIZE (t),\n \t\t\t\t\t    bitsize_int (BITS_PER_UNIT)));\n+\n+  /* Check for ambiguous virtual bases.  */\n+  if (extra_warnings)\n+    for (vbase = CLASSTYPE_VBASECLASSES (t); \n+\t vbase; \n+\t vbase = TREE_CHAIN (vbase))\n+      {\n+\ttree basetype = BINFO_TYPE (vbase);\n+\tif (get_base_distance (basetype, t, 0, (tree*)0) == -2)\n+\t  cp_warning (\"virtual base `%T' inaccessible in `%T' due to ambiguity\",\n+\t\t      basetype, t);\n+      }\n }\n \n-/* Finish the work of layout_record, now taking virtual bases into account.\n-   Also compute the actual offsets that our base classes will have.\n-   This must be performed after the fields are laid out, since virtual\n-   baseclasses must lay down at the end of the record.  */\n+/* Returns the offset of the byte just past the end of the base class\n+   with the highest offset in T.  If INCLUDE_VIRTUALS_P is zero, then\n+   only non-virtual bases are included.  */\n \n-static void\n-layout_basetypes (rec)\n-     tree rec;\n+static unsigned HOST_WIDE_INT\n+end_of_class (t, include_virtuals_p)\n+     tree t;\n+     int include_virtuals_p;\n {\n-  tree vbase_types;\n+  unsigned HOST_WIDE_INT result = 0;\n+  int i;\n \n-  if (CLASSTYPE_N_BASECLASSES (rec) == 0)\n-    return;\n+  for (i = 0; i < CLASSTYPE_N_BASECLASSES (t); ++i)\n+    {\n+      tree base_binfo;\n+      tree offset;\n+      unsigned HOST_WIDE_INT end_of_base;\n \n-#ifdef STRUCTURE_SIZE_BOUNDARY\n-  /* Packed structures don't need to have minimum size.  */\n-  if (! TYPE_PACKED (rec))\n-    TYPE_ALIGN (rec) = MAX (TYPE_ALIGN (rec), STRUCTURE_SIZE_BOUNDARY);\n-#endif\n+      base_binfo = BINFO_BASETYPE (TYPE_BINFO (t), i);\n+\n+      if (!include_virtuals_p\n+\t  && TREE_VIA_VIRTUAL (base_binfo) \n+\t  && !BINFO_PRIMARY_MARKED_P (base_binfo))\n+\tcontinue;\n \n-  /* Allocate the virtual base classes.  */\n-  layout_virtual_bases (rec);\n+      offset = size_binop (PLUS_EXPR, \n+\t\t\t   BINFO_OFFSET (base_binfo),\n+\t\t\t   CLASSTYPE_SIZE_UNIT (BINFO_TYPE (base_binfo)));\n+      end_of_base = tree_low_cst (offset, /*pos=*/1);\n+      if (end_of_base > result)\n+\tresult = end_of_base;\n+    }\n \n-  /* Get all the virtual base types that this type uses.  The\n-     TREE_VALUE slot holds the virtual baseclass type.  Note that\n-     get_vbase_types makes copies of the virtual base BINFOs, so that\n-     the vbase_types are unshared.  */\n-  for (vbase_types = CLASSTYPE_VBASECLASSES (rec); vbase_types;\n-       vbase_types = TREE_CHAIN (vbase_types))\n-    if (extra_warnings)\n-      {\n-\ttree basetype = BINFO_TYPE (vbase_types);\n-\tif (get_base_distance (basetype, rec, 0, (tree*)0) == -2)\n-\t  cp_warning (\"virtual base `%T' inaccessible in `%T' due to ambiguity\",\n-\t\t      basetype, rec);\n-      }\n+  return result;\n }\n \n /* Calculate the TYPE_SIZE, TYPE_ALIGN, etc for T.  Calculate\n@@ -4892,7 +4987,7 @@ layout_class_type (t, empty_p, has_virtual_p,\n   tree vptr;\n   record_layout_info rli;\n   varray_type v;\n-  int i;\n+  unsigned HOST_WIDE_INT eoc;\n \n   /* Keep track of the first non-static data member.  */\n   non_static_data_members = TYPE_FIELDS (t);\n@@ -5004,23 +5099,19 @@ layout_class_type (t, empty_p, has_virtual_p,\n \t}\n     }\n \n-  /* Clean up.  */\n-  VARRAY_FREE (v);\n-  \n   /* It might be the case that we grew the class to allocate a\n      zero-sized base class.  That won't be reflected in RLI, yet,\n      because we are willing to overlay multiple bases at the same\n      offset.  However, now we need to make sure that RLI is big enough\n      to reflect the entire class.  */\n-  for (i = 0; i < CLASSTYPE_N_BASECLASSES (t); ++i)\n+  eoc = end_of_class (t, /*include_virtuals_p=*/0);\n+  if (eoc * BITS_PER_UNIT > rli->const_size)\n     {\n-      tree base_binfo;\n-      unsigned HOST_WIDE_INT offset;\n-\n-      base_binfo = BINFO_BASETYPE (TYPE_BINFO (t), i);\n-      offset = get_binfo_offset_as_int (base_binfo);\n-      if (offset * BITS_PER_UNIT > rli->const_size)\n-\trli->const_size = (offset + 1) * BITS_PER_UNIT;\n+      /* We don't handle zero-sized base classes specially under the\n+\t old ABI, so if we get here, we had better be operating under\n+\t the new ABI rules.  */\n+      my_friendly_assert (flag_new_abi, 20000321);\n+      rli->const_size = (eoc + 1) * BITS_PER_UNIT;\n     }\n \n   /* We make all structures have at least one element, so that they\n@@ -5088,7 +5179,10 @@ layout_class_type (t, empty_p, has_virtual_p,\n      around.  We must get these done before we try to lay out the\n      virtual function table.  As a side-effect, this will remove the\n      base subobject fields.  */\n-  layout_basetypes (t);\n+  layout_virtual_bases (t, &v);\n+\n+  /* Clean up.  */\n+  VARRAY_FREE (v);\n }\n      \n /* Create a RECORD_TYPE or UNION_TYPE node for a C struct or union declaration"}, {"sha": "04fd943a15d4bfc01390a92d6f89d7cee54235bd", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9785e4b1f32f52aad66bb8071ac0f57a77686f9f/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9785e4b1f32f52aad66bb8071ac0f57a77686f9f/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=9785e4b1f32f52aad66bb8071ac0f57a77686f9f", "patch": "@@ -1562,7 +1562,7 @@ struct lang_type\n \n    there will be two copies of `A' and `B' in the TYPE_BINFO hierarchy\n    for `E'.  On the CLASSTYPE_VBASECLASSES list, there will be just\n-   one copy of `A' (distinct from the other two) with its own copy of `B'\n+   one copy of `B' (distinct from the other two) with its own copy of `A'\n    (also distinct from the copies in the TYPE_BINFO hierarchy.)  */\n #define CLASSTYPE_VBASECLASSES(NODE) (TYPE_LANG_SPECIFIC(NODE)->vbases)\n \n@@ -4388,7 +4388,6 @@ extern tree require_complete_type\t\tPARAMS ((tree));\n extern tree complete_type\t\t\tPARAMS ((tree));\n extern tree complete_type_or_else               PARAMS ((tree, tree));\n extern int type_unknown_p\t\t\tPARAMS ((tree));\n-extern int fntype_p\t\t\t\tPARAMS ((tree));\n extern tree commonparms\t\t\t\tPARAMS ((tree, tree));\n extern tree original_type\t\t\tPARAMS ((tree));\n extern tree common_type\t\t\t\tPARAMS ((tree, tree));"}, {"sha": "9d75476c97e9eb4b85f8222f91ccbf5e1c7b72f8", "filename": "gcc/cp/search.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9785e4b1f32f52aad66bb8071ac0f57a77686f9f/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9785e4b1f32f52aad66bb8071ac0f57a77686f9f/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=9785e4b1f32f52aad66bb8071ac0f57a77686f9f", "patch": "@@ -2166,7 +2166,7 @@ dfs_skip_nonprimary_vbases_unmarkedp (binfo, data)\n      void *data ATTRIBUTE_UNUSED;\n {\n   if (TREE_VIA_VIRTUAL (binfo) && !BINFO_PRIMARY_MARKED_P (binfo))\n-    /* This is a non-primary virtual base.  SKip it.  */\n+    /* This is a non-primary virtual base.  Skip it.  */\n     return NULL_TREE;\n \n   return unmarkedp (binfo, NULL);\n@@ -2181,7 +2181,7 @@ dfs_skip_nonprimary_vbases_markedp (binfo, data)\n      void *data ATTRIBUTE_UNUSED;\n {\n   if (TREE_VIA_VIRTUAL (binfo) && !BINFO_PRIMARY_MARKED_P (binfo))\n-    /* This is a non-primary virtual base.  SKip it.  */\n+    /* This is a non-primary virtual base.  Skip it.  */\n     return NULL_TREE;\n \n   return markedp (binfo, NULL);"}, {"sha": "2a239604479851ea49cfd7563300a5cfa26e678a", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9785e4b1f32f52aad66bb8071ac0f57a77686f9f/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9785e4b1f32f52aad66bb8071ac0f57a77686f9f/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=9785e4b1f32f52aad66bb8071ac0f57a77686f9f", "patch": "@@ -198,18 +198,6 @@ type_unknown_p (exp)\n \t      && TREE_TYPE (TREE_TYPE (exp)) == unknown_type_node));\n }\n \n-/* Return truthvalue of whether T is function (or pfn) type.  */\n-\n-int\n-fntype_p (t)\n-     tree t;\n-{\n-  return (TREE_CODE (t) == FUNCTION_TYPE || TREE_CODE (t) == METHOD_TYPE\n-\t  || (TREE_CODE (t) == POINTER_TYPE\n-\t      && (TREE_CODE (TREE_TYPE (t)) == FUNCTION_TYPE\n-\t\t  || TREE_CODE (TREE_TYPE (t)) == METHOD_TYPE)));\n-}\n-\n /* Return a variant of TYPE which has all the type qualifiers of LIKE\n    as well as those of TYPE.  */\n "}]}