{"sha": "29ad9694303d826163fd471c5e4bfc2fe3391481", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjlhZDk2OTQzMDNkODI2MTYzZmQ0NzFjNWU0YmZjMmZlMzM5MTQ4MQ==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2003-03-10T17:53:19Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2003-03-10T17:53:19Z"}, "message": "arm.h (enum floating_point_type): Delete.\n\n* arm.h (enum floating_point_type): Delete.  Replace with...\n(enum fputype): ... new.\n(FPUTYPE_DEFAULT): Renamed from FP_DEFAULT.  Values reworked.\n* linux-elf.h (FPUTYPE_DEFAULT): Likewise.\n* arm.md (attr fpu): Reworked for new underlying enum values.\n* arm.c\t(arm_fpu_arch): Now enum fputype.\n(arm_fpu_tune): Renamed from arm_fpu.  Now enum fputype.\n(arm_override_options, arm_output_epilogue, arm_expand_prologue):\nUpdate uses of arm_fpu_arch and arm_fpu_tune.\n\nFrom-SVN: r64099", "tree": {"sha": "d2e3929b2eaf4c7010f467bf2a2ee1f95672c56f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d2e3929b2eaf4c7010f467bf2a2ee1f95672c56f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/29ad9694303d826163fd471c5e4bfc2fe3391481", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29ad9694303d826163fd471c5e4bfc2fe3391481", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29ad9694303d826163fd471c5e4bfc2fe3391481", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29ad9694303d826163fd471c5e4bfc2fe3391481/comments", "author": null, "committer": null, "parents": [{"sha": "c94432c5502800431e9822b60ac28c1d7b74a1e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c94432c5502800431e9822b60ac28c1d7b74a1e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c94432c5502800431e9822b60ac28c1d7b74a1e7"}], "stats": {"total": 93, "additions": 57, "deletions": 36}, "files": [{"sha": "fafe995009a33728888c1ac660d19223c4639fc0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29ad9694303d826163fd471c5e4bfc2fe3391481/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29ad9694303d826163fd471c5e4bfc2fe3391481/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=29ad9694303d826163fd471c5e4bfc2fe3391481", "patch": "@@ -1,3 +1,15 @@\n+2003-03-10  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* arm.h (enum floating_point_type): Delete.  Replace with...\n+\t(enum fputype): ... new.\n+\t(FPUTYPE_DEFAULT): Renamed from FP_DEFAULT.  Values reworked.\n+\t* linux-elf.h (FPUTYPE_DEFAULT): Likewise.\n+\t* arm.md (attr fpu): Reworked for new underlying enum values.\n+\t* arm.c\t(arm_fpu_arch): Now enum fputype.\n+\t(arm_fpu_tune): Renamed from arm_fpu.  Now enum fputype.\n+\t(arm_override_options, arm_output_epilogue, arm_expand_prologue):\n+\tUpdate uses of arm_fpu_arch and arm_fpu_tune.\n+\n 2003-03-10  Josef Zlomek  <zlomekj@suse.cz>\n \n \t* cfgcleanup.c (outgoing_edges_match): Compare the jump tables. "}, {"sha": "808fb8c2c96565094856e27232c6493ccc3b19d9", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29ad9694303d826163fd471c5e4bfc2fe3391481/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29ad9694303d826163fd471c5e4bfc2fe3391481/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=29ad9694303d826163fd471c5e4bfc2fe3391481", "patch": "@@ -239,10 +239,10 @@ int making_const_table;\n rtx arm_compare_op0, arm_compare_op1;\n \n /* What type of floating point are we tuning for?  */\n-enum floating_point_type arm_fpu;\n+enum fputype arm_fpu_tune;\n \n /* What type of floating point instructions are available?  */\n-enum floating_point_type arm_fpu_arch;\n+enum fputype arm_fpu_arch;\n \n /* What program mode is the cpu running in? 26-bit mode or 32-bit mode.  */\n enum prog_mode_type arm_prgmode;\n@@ -726,7 +726,7 @@ arm_override_options ()\n \n   if (arm_is_cirrus)\n     {\n-      arm_fpu = FP_CIRRUS;\n+      arm_fpu_tune = FPUTYPE_MAVERICK;\n \n       /* Ignore -mhard-float if -mcpu=ep9312.  */\n       if (TARGET_HARD_FLOAT)\n@@ -738,34 +738,34 @@ arm_override_options ()\n        assume the user has an FPA.\n        Note: this does not prevent use of floating point instructions,\n        -msoft-float does that.  */\n-    arm_fpu = (tune_flags & FL_CO_PROC) ? FP_HARD : FP_SOFT3;\n+    arm_fpu_tune = (tune_flags & FL_CO_PROC) ? FPUTYPE_FPA : FPUTYPE_FPA_EMU3;\n   \n   if (target_fp_name)\n     {\n       if (streq (target_fp_name, \"2\"))\n-\tarm_fpu_arch = FP_SOFT2;\n+\tarm_fpu_arch = FPUTYPE_FPA_EMU2;\n       else if (streq (target_fp_name, \"3\"))\n-\tarm_fpu_arch = FP_SOFT3;\n+\tarm_fpu_arch = FPUTYPE_FPA_EMU3;\n       else\n \terror (\"invalid floating point emulation option: -mfpe-%s\",\n \t       target_fp_name);\n     }\n   else\n-    arm_fpu_arch = FP_DEFAULT;\n+    arm_fpu_arch = FPUTYPE_DEFAULT;\n   \n   if (TARGET_FPE)\n     {\n-      if (arm_fpu == FP_SOFT3)\n-\tarm_fpu = FP_SOFT2;\n-      else if (arm_fpu == FP_CIRRUS)\n-\twarning (\"-mpfpe switch not supported by ep9312 target cpu - ignored.\");\n-      else if (arm_fpu != FP_HARD)\n-    arm_fpu = FP_SOFT2;\n+      if (arm_fpu_tune == FPUTYPE_FPA_EMU3)\n+\tarm_fpu_tune = FPUTYPE_FPA_EMU2;\n+      else if (arm_fpu_tune == FPUTYPE_MAVERICK)\n+\twarning (\"-mfpe switch not supported by ep9312 target cpu - ignored.\");\n+      else if (arm_fpu_tune != FPUTYPE_FPA)\n+\tarm_fpu_tune = FPUTYPE_FPA_EMU2;\n     }\n   \n   /* For arm2/3 there is no need to do any scheduling if there is only\n      a floating point emulator, or we are doing software floating-point.  */\n-  if ((TARGET_SOFT_FLOAT || arm_fpu != FP_HARD)\n+  if ((TARGET_SOFT_FLOAT || arm_fpu_tune != FPUTYPE_FPA)\n       && (tune_flags & FL_MODE32) == 0)\n     flag_schedule_insns = flag_schedule_insns_after_reload = 0;\n   \n@@ -8452,7 +8452,7 @@ arm_output_epilogue (really_return)\n     {\n       int vfp_offset = 4;\n \n-      if (arm_fpu_arch == FP_SOFT2)\n+      if (arm_fpu_arch == FPUTYPE_FPA_EMU2)\n \t{\n \t  for (reg = LAST_ARM_FP_REGNUM; reg >= FIRST_ARM_FP_REGNUM; reg--)\n \t    if (regs_ever_live[reg] && !call_used_regs[reg])\n@@ -8535,7 +8535,7 @@ arm_output_epilogue (really_return)\n \t  output_add_immediate (operands);\n \t}\n \n-      if (arm_fpu_arch == FP_SOFT2)\n+      if (arm_fpu_arch == FPUTYPE_FPA_EMU2)\n \t{\n \t  for (reg = FIRST_ARM_FP_REGNUM; reg <= LAST_ARM_FP_REGNUM; reg++)\n \t    if (regs_ever_live[reg] && !call_used_regs[reg])\n@@ -9294,10 +9294,11 @@ arm_expand_prologue ()\n \n   if (! IS_VOLATILE (func_type))\n     {\n-      /* Save any floating point call-saved registers used by this function.  */\n-      if (arm_fpu_arch == FP_SOFT2)\n+      /* Save any floating point call-saved registers used by this\n+\t function.  */\n+      if (arm_fpu_arch == FPUTYPE_FPA_EMU2)\n \t{\n-\t  for (reg = LAST_ARM_FP_REGNUM; reg >= FIRST_ARM_FP_REGNUM; reg --)\n+\t  for (reg = LAST_ARM_FP_REGNUM; reg >= FIRST_ARM_FP_REGNUM; reg--)\n \t    if (regs_ever_live[reg] && !call_used_regs[reg])\n \t      {\n \t\tinsn = gen_rtx_PRE_DEC (XFmode, stack_pointer_rtx);\n@@ -9311,7 +9312,7 @@ arm_expand_prologue ()\n \t{\n \t  int start_reg = LAST_ARM_FP_REGNUM;\n \n-\t  for (reg = LAST_ARM_FP_REGNUM; reg >= FIRST_ARM_FP_REGNUM; reg --)\n+\t  for (reg = LAST_ARM_FP_REGNUM; reg >= FIRST_ARM_FP_REGNUM; reg--)\n \t    {\n \t      if (regs_ever_live[reg] && !call_used_regs[reg])\n \t\t{\n@@ -9356,7 +9357,8 @@ arm_expand_prologue ()\n \t    insn = gen_rtx_REG (SImode, 3);\n \t  else /* if (current_function_pretend_args_size == 0) */\n \t    {\n-\t      insn = gen_rtx_PLUS (SImode, hard_frame_pointer_rtx, GEN_INT (4));\n+\t      insn = gen_rtx_PLUS (SImode, hard_frame_pointer_rtx,\n+\t\t\t\t   GEN_INT (4));\n \t      insn = gen_rtx_MEM (SImode, insn);\n \t    }\n "}, {"sha": "33f3da0af979212b009ec251920d77d4a28b1c53", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29ad9694303d826163fd471c5e4bfc2fe3391481/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29ad9694303d826163fd471c5e4bfc2fe3391481/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=29ad9694303d826163fd471c5e4bfc2fe3391481", "patch": "@@ -550,32 +550,38 @@ extern enum prog_mode_type arm_prgmode;\n \n /* What sort of floating point unit do we have? Hardware or software.\n    If software, is it issue 2 or issue 3?  */\n-enum floating_point_type\n+enum fputype\n {\n-  FP_HARD,\n-  FP_SOFT2,\n-  FP_SOFT3,\n-  FP_CIRRUS\n+  /* Software floating point, FPA style double fmt.  */\n+  FPUTYPE_SOFT_FPA,\n+  /* Full FPA support.  */\n+  FPUTYPE_FPA,\n+  /* Emulated FPA hardware, Issue 2 emulator (no LFM/SFM).  */\n+  FPUTYPE_FPA_EMU2,\n+  /* Emulated FPA hardware, Issue 3 emulator.  */\n+  FPUTYPE_FPA_EMU3,\n+  /* Cirrus Maverick floating point co-processor.  */\n+  FPUTYPE_MAVERICK\n };\n \n /* Recast the floating point class to be the floating point attribute.  */\n-#define arm_fpu_attr ((enum attr_fpu) arm_fpu)\n+#define arm_fpu_attr ((enum attr_fpu) arm_fpu_tune)\n \n /* What type of floating point to tune for */\n-extern enum floating_point_type arm_fpu;\n+extern enum fputype arm_fpu_tune;\n \n /* What type of floating point instructions are available */\n-extern enum floating_point_type arm_fpu_arch;\n+extern enum fputype arm_fpu_arch;\n \n /* Default floating point architecture.  Override in sub-target if\n    necessary.  */\n-#ifndef FP_DEFAULT\n-#define FP_DEFAULT FP_SOFT2\n+#ifndef FPUTYPE_DEFAULT\n+#define FPUTYPE_DEFAULT FPUTYPE_FPA_EMU2\n #endif\n \n #if TARGET_CPU_DEFAULT == TARGET_CPU_ep9312\n-#undef  FP_DEFAULT\n-#define FP_DEFAULT FP_CIRRUS\n+#undef  FPUTYPE_DEFAULT\n+#define FPUTYPE_DEFAULT FPUTYPE_MAVERICK\n #endif\n \n /* Nonzero if the processor has a fast multiply insn, and one that does"}, {"sha": "7ad63f2d989cb4787132ba4b116ee44d7a5b9407", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29ad9694303d826163fd471c5e4bfc2fe3391481/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29ad9694303d826163fd471c5e4bfc2fe3391481/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=29ad9694303d826163fd471c5e4bfc2fe3391481", "patch": "@@ -116,7 +116,8 @@\n ; Floating Point Unit.  If we only have floating point emulation, then there\n ; is no point in scheduling the floating point insns.  (Well, for best\n ; performance we should try and group them together).\n-(define_attr \"fpu\" \"fpa,fpe2,fpe3\" (const (symbol_ref \"arm_fpu_attr\")))\n+(define_attr \"fpu\" \"softfpa,fpa,fpe2,fpe3,maverick\"\n+  (const (symbol_ref \"arm_fpu_attr\")))\n \n ; LENGTH of an instruction (in bytes)\n (define_attr \"length\" \"\" (const_int 4))"}, {"sha": "ec5c69f36ff11e84aba13f734a73162419110068", "filename": "gcc/config/arm/linux-elf.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29ad9694303d826163fd471c5e4bfc2fe3391481/gcc%2Fconfig%2Farm%2Flinux-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29ad9694303d826163fd471c5e4bfc2fe3391481/gcc%2Fconfig%2Farm%2Flinux-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Flinux-elf.h?ref=29ad9694303d826163fd471c5e4bfc2fe3391481", "patch": "@@ -111,8 +111,8 @@\n   while (0)\n \n /* NWFPE always understands FPA instructions.  */\n-#undef  FP_DEFAULT\n-#define FP_DEFAULT FP_SOFT3\n+#undef  FPUTYPE_DEFAULT\n+#define FPUTYPE_DEFAULT FPUTYPE_FPA_EMU3\n \n /* Call the function profiler with a given profile label.  */\n #undef  ARM_FUNCTION_PROFILER"}]}