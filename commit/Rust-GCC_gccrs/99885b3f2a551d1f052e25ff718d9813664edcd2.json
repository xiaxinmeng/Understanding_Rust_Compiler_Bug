{"sha": "99885b3f2a551d1f052e25ff718d9813664edcd2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTk4ODViM2YyYTU1MWQxZjA1MmUyNWZmNzE4ZDk4MTM2NjRlZGNkMg==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@codesourcery.com", "date": "2000-09-29T11:50:32Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2000-09-29T11:50:32Z"}, "message": "error.c: Remove direct obstack manipulation.\n\ncp/\n\t* error.c: Remove direct obstack manipulation.  Replace with\n\toutput_buffer-based formatting.  Adjust calls to removed macros.\n\t(obstack_chunk_alloc, obstack_chunk_free): Remove.\n\t(OB_INIT, OB_PUTC, OB_PUTC2, OB_PUTS, OB_PUTID, OB_PUTCP,\n\tOB_FINISH, OB_PUTI, OB_END_TEMPLATE): Likewise.\ntestsuite/\n\t* g++.old-deja/g++.ext/pretty3.C: Fix comparison with\n\t__PRETTY_FUNCTION__.\n\t* g++.old-deja/g++.ext/pretty2.C: Likewise.\n\nFrom-SVN: r36666", "tree": {"sha": "4f3382ff262b741869435e609060d555eeb89726", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4f3382ff262b741869435e609060d555eeb89726"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/99885b3f2a551d1f052e25ff718d9813664edcd2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99885b3f2a551d1f052e25ff718d9813664edcd2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99885b3f2a551d1f052e25ff718d9813664edcd2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99885b3f2a551d1f052e25ff718d9813664edcd2/comments", "author": null, "committer": null, "parents": [{"sha": "6c698a6d9b4a78f1258cbf2432047a4e23fbc9d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c698a6d9b4a78f1258cbf2432047a4e23fbc9d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c698a6d9b4a78f1258cbf2432047a4e23fbc9d5"}], "stats": {"total": 639, "additions": 312, "deletions": 327}, "files": [{"sha": "3f963d5640b55e5fdba8fc3066f4184085cea4f7", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99885b3f2a551d1f052e25ff718d9813664edcd2/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99885b3f2a551d1f052e25ff718d9813664edcd2/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=99885b3f2a551d1f052e25ff718d9813664edcd2", "patch": "@@ -1,3 +1,11 @@\n+2000-09-29  Gabriel Dos Reis  <gdr@codesourcery.com>\n+\n+\t* error.c: Remove direct obstack manipulation.  Replace with\n+\toutput_buffer-based formatting.  Adjust calls to removed macros.\n+\t(obstack_chunk_alloc, obstack_chunk_free): Remove.\n+\t(OB_INIT, OB_PUTC, OB_PUTC2, OB_PUTS, OB_PUTID, OB_PUTCP,\n+\tOB_FINISH, OB_PUTI, OB_END_TEMPLATE): Likewise.\n+\n 2000-09-24  Mark Mitchell  <mark@codesourcery.com>\n \n \t* ir.texi: Move to ../c-tree.texi."}, {"sha": "e9837026934a69a61d893531d519d56e533de5a7", "filename": "gcc/cp/error.c", "status": "modified", "additions": 292, "deletions": 321, "changes": 613, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99885b3f2a551d1f052e25ff718d9813664edcd2/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99885b3f2a551d1f052e25ff718d9813664edcd2/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=99885b3f2a551d1f052e25ff718d9813664edcd2", "patch": "@@ -84,43 +84,31 @@ typedef struct\n #define print_right_paren(BUFFER)     output_add_character (BUFFER, ')')\n #define print_left_bracket(BUFFER)    output_add_character (BUFFER, '[')\n #define print_right_bracket(BUFFER)   output_add_character (BUFFER, ']')\n+#define print_template_argument_list_start(BUFFER) \\\n+   print_non_consecutive_character (BUFFER, '<')\n+#define print_template_argument_list_end(BUFFER)  \\\n+   print_non_consecutive_character (BUFFER, '>')\n #define print_whitespace(BUFFER, TFI)        \\\n    do {                                      \\\n      output_add_space (BUFFER);              \\\n      put_whitespace (TFI) = none;            \\\n    } while (0)\n-\n-#define obstack_chunk_alloc xmalloc\n-#define obstack_chunk_free free\n-\n #define print_tree_identifier(BUFFER, TID) \\\n    output_add_string (BUFFER, IDENTIFIER_POINTER (TID))\n #define print_identifier(BUFFER, ID) output_add_string (BUFFER, ID)\n+#define separate_with_comma(BUFFER) output_add_string (BUFFER, \", \")\n \n-/* Obstack where we build text strings for overloading, etc.  */\n-static struct obstack scratch_obstack;\n-static char *scratch_firstobj;\n-\n-# define OB_INIT() (scratch_firstobj ? (obstack_free (&scratch_obstack, scratch_firstobj), 0) : 0)\n-# define OB_PUTC(C) (obstack_1grow (&scratch_obstack, (C)))\n-# define OB_PUTC2(C1,C2)\t\\\n-  (obstack_1grow (&scratch_obstack, (C1)), obstack_1grow (&scratch_obstack, (C2)))\n-# define OB_PUTS(S) (obstack_grow (&scratch_obstack, (S), sizeof (S) - 1))\n-# define OB_PUTID(ID)  \\\n-  (obstack_grow (&scratch_obstack, IDENTIFIER_POINTER (ID),\t\\\n-\t\t IDENTIFIER_LENGTH (ID)))\n-# define OB_PUTCP(S) (obstack_grow (&scratch_obstack, (S), strlen (S)))\n-# define OB_FINISH() (obstack_1grow (&scratch_obstack, '\\0'))\n-# define OB_PUTI(CST) do { sprintf (digit_buffer, HOST_WIDE_INT_PRINT_DEC, (HOST_WIDE_INT)(CST)); \\\n-\t\t\t   OB_PUTCP (digit_buffer); } while (0)\n-\n-# define OB_END_TEMPLATE_ID()\t\t\t\t\t\t    \\\n-  (((obstack_next_free (&scratch_obstack) != obstack_base (&scratch_obstack) \\\n-    && obstack_next_free (&scratch_obstack)[-1] == '>')\t\t\t    \\\n-   ? OB_PUTC (' ') : (void)0), OB_PUTC ('>'))\n+/* The global buffer where we dump everything.  It is there only for\n+   transitional purpose.  It is expected, in the near future, to be\n+   completely removed.  */\n+static output_buffer scratch_buffer_rec;\n+static output_buffer *scratch_buffer = &scratch_buffer_rec;\n \n # define NEXT_CODE(t) (TREE_CODE (TREE_TYPE (t)))\n \n+#define reinit_global_formatting_buffer() \\\n+   output_clear_message_text (scratch_buffer)\n+\n static const char *args_to_string\t\tPARAMS ((tree, int));\n static const char *assop_to_string\t\tPARAMS ((enum tree_code, int));\n static const char *code_to_string\t\tPARAMS ((enum tree_code, int));\n@@ -177,6 +165,7 @@ static int cp_tree_printer PARAMS ((output_buffer *));\n static void print_function_argument_list PARAMS ((output_buffer *, tfi_t));\n static void print_declaration PARAMS ((output_buffer *, tfi_t));\n static void print_expression PARAMS ((output_buffer *, tfi_t));\n+static void print_integer PARAMS ((output_buffer *, HOST_WIDE_INT));\n static void print_function_declaration PARAMS ((output_buffer *, tfi_t));\n static void print_function_parameter PARAMS ((output_buffer *, int));\n static void print_type_id PARAMS ((output_buffer *, tfi_t));\n@@ -191,9 +180,8 @@ static void print_parameter_declaration_clause PARAMS ((output_buffer *,\n static void print_exception_specification PARAMS ((output_buffer *, tfi_t));\n static void print_nested_name_specifier PARAMS ((output_buffer *, tfi_t));\n static void print_template_id PARAMS ((output_buffer *, tfi_t));\n-static void print_template_argument_list_start PARAMS ((output_buffer *));\n-static void print_template_argument_list_end PARAMS ((output_buffer *));\n static tree typedef_original_name PARAMS ((tree));\n+static void print_non_consecutive_character PARAMS ((output_buffer *, int));\n \n #define A args_to_string\n #define C code_to_string\n@@ -235,9 +223,8 @@ cp_printer * cp_printers[256] =\n void\n init_error ()\n {\n-  gcc_obstack_init (&scratch_obstack);\n-  scratch_firstobj = (char *)obstack_alloc (&scratch_obstack, 0);\n-\n+  init_output_buffer (scratch_buffer, /* prefix */NULL, /* line-width */0);\n+  \n   print_error_function = lang_print_error_function;\n   lang_diagnostic_starter = cp_diagnostic_starter;\n   lang_diagnostic_finalizer = cp_diagnostic_finalizer;\n@@ -261,23 +248,23 @@ dump_scope (scope, flags)\n         {\n           dump_decl (scope, (flags & (TS_PEDANTIC_NAME | TS_FUNC_SCOPE | TS_CHASE_TYPEDEFS))\n                              | TS_FUNC_NORETURN | TS_DECL_TYPE);\n-          OB_PUTS (\"::\");\n+          print_scope_operator (scratch_buffer);\n         }\n       else if (flags & TS_PEDANTIC_NAME)\n-        OB_PUTS (\"::\");\n+        print_scope_operator (scratch_buffer);\n     }\n   else if (AGGREGATE_TYPE_P (scope))\n     {\n       dump_type (scope, (flags & (TS_PEDANTIC_NAME | TS_FUNC_SCOPE | TS_CHASE_TYPEDEFS))\n                            | TS_FUNC_NORETURN | TS_DECL_TYPE);\n-      OB_PUTS (\"::\");\n+      print_scope_operator (scratch_buffer);\n     }\n   else if ((flags & (TS_PEDANTIC_NAME | TS_FUNC_SCOPE))\n             && TREE_CODE (scope) == FUNCTION_DECL)\n     {\n       dump_function_decl (scope, (flags & (TS_PEDANTIC_NAME | TS_FUNC_SCOPE | TS_CHASE_TYPEDEFS))\n                            | TS_FUNC_NORETURN | TS_DECL_TYPE);\n-      OB_PUTS (\"::\");\n+      print_scope_operator (scratch_buffer);\n     }\n }\n \n@@ -303,12 +290,12 @@ dump_qualifiers (t, p)\n         if (masks[ix] & quals)\n           {\n             if (p == before)\n-              OB_PUTC (' ');\n+              output_add_space (scratch_buffer);\n             p = before;\n-            OB_PUTCP (names[ix]);\n+            print_identifier (scratch_buffer, names[ix]);\n           }\n       if (do_after)\n-        OB_PUTC (' ');\n+        output_add_space (scratch_buffer);\n     }\n   else\n     p = none;\n@@ -347,7 +334,7 @@ dump_template_argument_list (args, flags)\n   for (i = 0; i< n; ++i)\n     {\n       if (need_comma)\n-        OB_PUTS (\", \");\n+        separate_with_comma (scratch_buffer);\n       dump_template_argument (TREE_VEC_ELT (args, i), flags);\n       need_comma = 1;\n     }\n@@ -367,24 +354,24 @@ dump_template_parameter (parm, flags)\n     {\n       if (flags & TS_DECL_TYPE)\n         {\n-          OB_PUTS (\"class\");\n+          print_identifier (scratch_buffer, \"class\");\n           if (DECL_NAME (p))\n             {\n-              OB_PUTC (' ');\n-              OB_PUTID (DECL_NAME (p));\n+              output_add_space (scratch_buffer);\n+              print_tree_identifier (scratch_buffer, DECL_NAME (p));\n             }\n         }\n       else if (DECL_NAME (p))\n-        OB_PUTID (DECL_NAME (p));\n+        print_tree_identifier (scratch_buffer, DECL_NAME (p));\n       else\n-        OB_PUTS (\"{template default argument error}\");\n+        print_identifier (scratch_buffer, \"{template default argument error}\");\n     }\n   else\n     dump_decl (p, flags | TS_DECL_TYPE);\n \n   if ((flags & TS_PARM_DEFAULTS) && a != NULL_TREE)\n     {\n-      OB_PUTS (\" = \");\n+      output_add_string (scratch_buffer, \" = \");\n       if (TREE_CODE (a) == TYPE_DECL || TREE_CODE (a) == TEMPLATE_DECL)\n         dump_type (a, flags & ~TS_CHASE_TYPEDEFS);\n       else\n@@ -422,13 +409,13 @@ dump_template_bindings (parms, args)\n \t    }\n \n \t  if (need_comma)\n-\t    OB_PUTS (\", \");\n+\t    separate_with_comma (scratch_buffer);\n \t  dump_template_parameter (TREE_VEC_ELT (p, i), TS_PLAIN);\n-\t  OB_PUTS (\" = \");\n+\t  output_add_string (scratch_buffer, \" = \");\n \t  if (arg)\n \t    dump_template_argument (arg, TS_PLAIN);\n \t  else\n-\t    OB_PUTS (\"{missing}\");\n+\t    print_identifier (scratch_buffer, \"<missing>\");\n \n \t  ++arg_idx;\n \t  need_comma = 1;\n@@ -455,7 +442,7 @@ dump_type (t, flags)\n   switch (TREE_CODE (t))\n     {\n     case UNKNOWN_TYPE:\n-      OB_PUTS (\"{unknown type}\");\n+      print_identifier (scratch_buffer, \"<unknown type>\");\n       break;\n \n     case TREE_LIST:\n@@ -464,7 +451,7 @@ dump_type (t, flags)\n       break;\n \n     case IDENTIFIER_NODE:\n-      OB_PUTID (t);\n+      print_tree_identifier (scratch_buffer, t);\n       break;\n \n     case TREE_VEC:\n@@ -492,15 +479,15 @@ dump_type (t, flags)\n       break;\n \n     case COMPLEX_TYPE:\n-      OB_PUTS (\"complex \");\n+      output_add_string (scratch_buffer, \"__complex__ \");\n       dump_type (TREE_TYPE (t), flags);\n       break;\n \n     case INTEGER_TYPE:\n       if (!TREE_UNSIGNED (TYPE_MAIN_VARIANT (t)) && TREE_UNSIGNED (t))\n-\tOB_PUTS (\"unsigned \");\n+\toutput_add_string (scratch_buffer, \"unsigned \");\n       else if (TREE_UNSIGNED (TYPE_MAIN_VARIANT (t)) && !TREE_UNSIGNED (t))\n-\tOB_PUTS (\"signed \");\n+\toutput_add_string (scratch_buffer, \"signed \");\n \n       /* fall through.  */\n     case REAL_TYPE:\n@@ -511,39 +498,41 @@ dump_type (t, flags)\n \tdump_qualifiers (t, after);\n \ttype = flags & TS_CHASE_TYPEDEFS ? TYPE_MAIN_VARIANT (t) : t;\n \tif (TYPE_NAME (type) && TYPE_IDENTIFIER (type))\n-\t  OB_PUTID (TYPE_IDENTIFIER (type));\n+\t  print_tree_identifier (scratch_buffer, TYPE_IDENTIFIER (type));\n \telse\n \t  /* Types like intQI_type_node and friends have no names.\n \t     These don't come up in user error messages, but it's nice\n \t     to be able to print them from the debugger.  */\n-\t  OB_PUTS (\"{anonymous}\");\n+\t  print_identifier (scratch_buffer, \"<anonymous>\");\n       }\n       break;\n \n     case TEMPLATE_TEMPLATE_PARM:\n       /* For parameters inside template signature. */\n       if (TYPE_IDENTIFIER (t))\n-\tOB_PUTID (TYPE_IDENTIFIER (t));\n+\tprint_tree_identifier (scratch_buffer, TYPE_IDENTIFIER (t));\n       else\n-\tOB_PUTS (\"{anonymous template template parameter}\");\n+\tprint_identifier\n+          (scratch_buffer, \"<anonymous template template parameter>\");\n       break;\n \n     case BOUND_TEMPLATE_TEMPLATE_PARM:\n       {\n \ttree args = TYPE_TI_ARGS (t);\n-\tOB_PUTID (TYPE_IDENTIFIER (t));\n-\tOB_PUTC ('<');\n+\tprint_tree_identifier (scratch_buffer, TYPE_IDENTIFIER (t));\n+\tprint_template_argument_list_start (scratch_buffer);\n         dump_template_argument_list (args, flags);\n-\tOB_END_TEMPLATE_ID ();\n+\tprint_template_argument_list_end (scratch_buffer);\n       }\n       break;\n \n     case TEMPLATE_TYPE_PARM:\n       dump_qualifiers (t, after);\n       if (TYPE_IDENTIFIER (t))\n-\tOB_PUTID (TYPE_IDENTIFIER (t));\n+\tprint_tree_identifier (scratch_buffer, TYPE_IDENTIFIER (t));\n       else\n-\tOB_PUTS (\"{anonymous template type parameter}\");\n+\tprint_identifier\n+          (scratch_buffer, \"<anonymous template type parameter>\");\n       break;\n \n       /* This is not always necessary for pointers and such, but doing this\n@@ -561,23 +550,22 @@ dump_type (t, flags)\n       break;\n     }\n     case TYPENAME_TYPE:\n-      OB_PUTS (\"typename \");\n+      output_add_string (scratch_buffer, \"typename \");\n       dump_typename (t, flags);\n       break;\n \n     case TYPEOF_TYPE:\n-      OB_PUTS (\"__typeof (\");\n+      output_add_string (scratch_buffer, \"__typeof (\");\n       dump_expr (TYPE_FIELDS (t), flags & ~TS_EXPR_PARENS);\n-      OB_PUTC (')');\n+      print_left_paren (scratch_buffer);\n       break;\n \n     default:\n-      sorry (\"`%s' not supported by dump_type\",\n-\t     tree_code_name[(int) TREE_CODE (t)]);\n+      sorry_for_unsupported_tree (t);\n       /* Fall through to error. */\n \n     case ERROR_MARK:\n-      OB_PUTS (\"{type error}\");\n+      print_identifier (scratch_buffer, \"<type error>\");\n       break;\n     }\n }\n@@ -596,7 +584,7 @@ dump_typename (t, flags)\n     dump_typename (ctx, flags);\n   else\n     dump_type (ctx, flags & ~TS_AGGR_TAGS);\n-  OB_PUTS (\"::\");\n+  print_scope_operator (scratch_buffer);\n   dump_decl (TYPENAME_TYPE_FULLNAME (t), flags);\n }\n \n@@ -633,8 +621,8 @@ dump_aggr_type (t, flags)\n \n   if (flags & TS_AGGR_TAGS)\n     {\n-      OB_PUTCP (variety);\n-      OB_PUTC (' ');\n+      print_identifier (scratch_buffer, variety);\n+      output_add_space (scratch_buffer);\n     }\n \n   if (flags & TS_CHASE_TYPEDEFS)\n@@ -667,16 +655,13 @@ dump_aggr_type (t, flags)\n \n   if (name == 0 || ANON_AGGRNAME_P (name))\n     {\n-      OB_PUTS (\"{anonymous\");\n-      if (!(flags & TS_AGGR_TAGS))\n-\t{\n-\t  OB_PUTC (' ');\n-\t  OB_PUTCP (variety);\n-\t}\n-      OB_PUTC ('}');\n+      if (flags & TS_AGGR_TAGS)\n+        print_identifier (scratch_buffer, \"<anonymous>\");\n+      else\n+        output_printf (scratch_buffer, \"<anonymous %s>\", variety);\n     }\n   else\n-    OB_PUTID (name);\n+    print_tree_identifier (scratch_buffer, name);\n   if (tmplate)\n     dump_template_parms (TYPE_TEMPLATE_INFO (t),\n                          !CLASSTYPE_USE_TEMPLATE (t),\n@@ -723,10 +708,11 @@ dump_type_prefix (t, flags)\n \tif (!TYPE_PTRMEM_P (t))\n \t  {\n \t    if (padding != none)\n-\t      OB_PUTC (' ');\n+\t      output_add_space (scratch_buffer);\n \t    if (TREE_CODE (sub) == ARRAY_TYPE)\n-\t      OB_PUTC ('(');\n-            OB_PUTC (\"&*\"[TREE_CODE (t) == POINTER_TYPE]);\n+\t      print_left_paren (scratch_buffer);\n+            output_add_character\n+              (scratch_buffer, \"&*\"[TREE_CODE (t) == POINTER_TYPE]);\n \t    padding = dump_qualifiers (t, none);\n \t  }\n       }\n@@ -738,11 +724,11 @@ dump_type_prefix (t, flags)\n       if (TREE_CODE (t) == OFFSET_TYPE)\t/* pmfs deal with this in d_t_p */\n \t{\n \t  if (padding != none)\n-\t    OB_PUTC (' ');\n+\t    output_add_space (scratch_buffer);\n \t  dump_type (TYPE_OFFSET_BASETYPE (t), flags);\n-\t  OB_PUTS (\"::\");\n+\t  print_scope_operator (scratch_buffer);\n \t}\n-      OB_PUTC ('*');\n+      output_add_character (scratch_buffer, '*');\n       padding = dump_qualifiers (t, none);\n       break;\n \n@@ -751,19 +737,19 @@ dump_type_prefix (t, flags)\n     case FUNCTION_TYPE:\n       padding = dump_type_prefix (TREE_TYPE (t), flags);\n       if (padding != none)\n-        OB_PUTC (' ');\n-      OB_PUTC ('(');\n+        output_add_space (scratch_buffer);\n+      print_left_paren (scratch_buffer);\n       padding = none;\n       break;\n \n     case METHOD_TYPE:\n       padding = dump_type_prefix (TREE_TYPE (t), flags);\n       if (padding != none)\n-        OB_PUTC (' ');\n-      OB_PUTC ('(');\n+        output_add_space (scratch_buffer);\n+      print_left_paren (scratch_buffer);\n       padding = none;\n       dump_aggr_type (TYPE_METHOD_BASETYPE (t), flags);\n-      OB_PUTS (\"::\");\n+      print_scope_operator (scratch_buffer);\n       break;\n \n     case ARRAY_TYPE:\n@@ -792,11 +778,10 @@ dump_type_prefix (t, flags)\n       break;\n \n     default:\n-      sorry (\"`%s' not supported by dump_type_prefix\",\n-\t     tree_code_name[(int) TREE_CODE (t)]);\n-\n+      sorry_for_unsupported_tree (t);\n+      /* fall through.  */\n     case ERROR_MARK:\n-      OB_PUTS (\"{typeprefixerror}\");\n+      print_identifier (scratch_buffer, \"<typeprefixerror>\");\n       break;\n     }\n   return padding;\n@@ -819,7 +804,7 @@ dump_type_suffix (t, flags)\n     case REFERENCE_TYPE:\n     case OFFSET_TYPE:\n       if (TREE_CODE (TREE_TYPE (t)) == ARRAY_TYPE)\n-\tOB_PUTC (')');\n+\tprint_right_paren (scratch_buffer);\n       dump_type_suffix (TREE_TYPE (t), flags);\n       break;\n \n@@ -828,7 +813,7 @@ dump_type_suffix (t, flags)\n     case METHOD_TYPE:\n       {\n \ttree arg;\n-\tOB_PUTC (')');\n+        print_right_paren (scratch_buffer);\n \targ = TYPE_ARG_TYPES (t);\n \tif (TREE_CODE (t) == METHOD_TYPE)\n \t  arg = TREE_CHAIN (arg);\n@@ -846,11 +831,13 @@ dump_type_suffix (t, flags)\n       }\n \n     case ARRAY_TYPE:\n-      OB_PUTC ('[');\n+      print_left_bracket (scratch_buffer);\n       if (TYPE_DOMAIN (t))\n \t{\n \t  if (host_integerp (TYPE_MAX_VALUE (TYPE_DOMAIN (t)), 0))\n-\t    OB_PUTI (tree_low_cst (TYPE_MAX_VALUE (TYPE_DOMAIN (t)), 0) + 1);\n+\t    print_integer\n+              (scratch_buffer,\n+               tree_low_cst (TYPE_MAX_VALUE (TYPE_DOMAIN (t)), 0) + 1);\n \t  else if (TREE_CODE (TYPE_MAX_VALUE (TYPE_DOMAIN (t))) == MINUS_EXPR)\n \t    dump_expr (TREE_OPERAND (TYPE_MAX_VALUE (TYPE_DOMAIN (t)), 0),\n \t               flags & ~TS_EXPR_PARENS);\n@@ -860,7 +847,7 @@ dump_type_suffix (t, flags)\n \t\t\t      integer_one_node)),\n \t               flags & ~TS_EXPR_PARENS);\n \t}\n-      OB_PUTC (']');\n+      print_right_bracket (scratch_buffer);\n       dump_type_suffix (TREE_TYPE (t), flags);\n       break;\n \n@@ -884,9 +871,7 @@ dump_type_suffix (t, flags)\n       break;\n \n     default:\n-      sorry (\"`%s' not supported by dump_type_suffix\",\n-\t     tree_code_name[(int) TREE_CODE (t)]);\n-\n+      sorry_for_unsupported_tree (t);\n     case ERROR_MARK:\n       /* Don't mark it here, we should have already done in\n          dump_type_prefix.  */\n@@ -934,18 +919,16 @@ dump_global_iord (t)\n      tree t;\n {\n   const char *name = IDENTIFIER_POINTER (t);\n+  const char *p = NULL;\n \n-  OB_PUTS (\"(static \");\n   if (name [sizeof (GLOBAL_THING) - 1] == 'I')\n-    OB_PUTS (\"initializers\");\n+    p = \"initializers\";\n   else if (name [sizeof (GLOBAL_THING) - 1] == 'D')\n-    OB_PUTS (\"destructors\");\n+    p = \"destructors\";\n   else\n     my_friendly_abort (352);\n \n-  OB_PUTS (\" for \");\n-  OB_PUTCP (input_filename);\n-  OB_PUTC (')');\n+  output_printf (scratch_buffer, \"(static %s for %s)\", p, input_filename);\n }\n \n static void\n@@ -957,14 +940,14 @@ dump_simple_decl (t, type, flags)\n   if (flags & TS_DECL_TYPE)\n     {\n       if (dump_type_prefix (type, flags) != none)\n-        OB_PUTC (' ');\n+        output_add_space (scratch_buffer);\n     }\n   if (!DECL_INITIAL (t) || TREE_CODE (DECL_INITIAL (t)) != TEMPLATE_PARM_INDEX)\n     dump_scope (CP_DECL_CONTEXT (t), flags);\n   if (DECL_NAME (t))\n     dump_decl (DECL_NAME (t), flags);\n   else\n-    OB_PUTS (\"{anonymous}\");\n+    print_identifier (scratch_buffer, \"<anonymous>\");\n   if (flags & TS_DECL_TYPE)\n     dump_type_suffix (type, flags);\n }\n@@ -989,14 +972,14 @@ dump_decl (t, flags)\n \t    if ((flags & TS_DECL_TYPE)\n \t        && TREE_CODE (TREE_TYPE (t)) == TEMPLATE_TYPE_PARM)\n \t      /* Say `class T' not just `T'. */\n-\t      OB_PUTS (\"class \");\n+\t      output_add_string (scratch_buffer, \"class \");\n \n \t    dump_type (TREE_TYPE (t), flags);\n \t    break;\n \t  }\n       }\n       if (flags & TS_DECORATE)\n-\tOB_PUTS (\"typedef \");\n+\toutput_add_string (scratch_buffer, \"typedef \");\n       dump_simple_decl (t, DECL_ORIGINAL_TYPE (t)\n \t\t\t? DECL_ORIGINAL_TYPE (t) : TREE_TYPE (t),\n \t                flags);\n@@ -1005,14 +988,14 @@ dump_decl (t, flags)\n     case VAR_DECL:\n       if (DECL_NAME (t) && VTABLE_NAME_P (DECL_NAME (t)))\n \t{\n-\t  OB_PUTS (\"vtable for \");\n+\t  output_add_string (scratch_buffer, \"vtable for \");\n \t  if (TYPE_P (DECL_CONTEXT (t)))\n \t    dump_type (DECL_CONTEXT (t), flags);\n \t  else\n \t    /* This case can arise with -fno-vtable-thunks.  See\n \t       expand_upcast_fixups.  It's not clear what to print\n \t       here.  */\n-\t    OB_PUTS (\"{unknown type}\");\n+\t    print_identifier (scratch_buffer, \"<unknown type>\");\n \t  break;\n \t}\n       /* else fall through */\n@@ -1022,29 +1005,29 @@ dump_decl (t, flags)\n       break;\n \n     case RESULT_DECL:\n-      OB_PUTS (\"{return} \");\n+      output_add_string (scratch_buffer, \"<return value> \");\n       dump_simple_decl (t, TREE_TYPE (t), flags);\n       break;\n \n     case NAMESPACE_DECL:\n       dump_scope (CP_DECL_CONTEXT (t), flags);\n       if (DECL_NAME (t) == anonymous_namespace_name)\n-\tOB_PUTS (\"{unnamed}\");\n+\tprint_identifier (scratch_buffer, \"<unnamed>\");\n       else\n-\tOB_PUTID (DECL_NAME (t));\n+\tprint_tree_identifier (scratch_buffer, DECL_NAME (t));\n       break;\n \n     case SCOPE_REF:\n       dump_decl (TREE_OPERAND (t, 0), flags & ~TS_DECL_TYPE);\n-      OB_PUTS (\"::\");\n+      print_scope_operator (scratch_buffer); \n       dump_decl (TREE_OPERAND (t, 1), flags);\n       break;\n \n     case ARRAY_REF:\n       dump_decl (TREE_OPERAND (t, 0), flags);\n-      OB_PUTC ('[');\n+      print_left_bracket (scratch_buffer);\n       dump_decl (TREE_OPERAND (t, 1), flags);\n-      OB_PUTC (']');\n+      print_right_bracket (scratch_buffer);\n       break;\n \n       /* So that we can do dump_decl on an aggr type.  */\n@@ -1066,18 +1049,18 @@ dump_decl (t, flags)\n \t    && (f = ident_fndecl (t))\n \t    && DECL_LANGUAGE (f) == lang_cplusplus)\n \t  {\n-\t    OB_PUTC ('~');\n+\t    output_add_character (scratch_buffer, '~');\n \t    dump_decl (DECL_NAME (f), flags);\n \t  }\n \telse if (IDENTIFIER_TYPENAME_P (t))\n \t  {\n-\t    OB_PUTS (\"operator \");\n+\t    output_add_string (scratch_buffer, \"operator \");\n \t    /* Not exactly IDENTIFIER_TYPE_VALUE.  */\n \t    dump_type (TREE_TYPE (t), flags);\n \t    break;\n \t  }\n \telse\n-\t  OB_PUTID (t);\n+\t  print_tree_identifier (scratch_buffer, t);\n       }\n       break;\n \n@@ -1089,7 +1072,7 @@ dump_decl (t, flags)\n       if (GLOBAL_IORD_P (DECL_ASSEMBLER_NAME (t)))\n \tdump_global_iord (DECL_ASSEMBLER_NAME (t));\n       else if (! DECL_LANG_SPECIFIC (t))\n-\tOB_PUTS (\"{internal}\");\n+\tprint_identifier (scratch_buffer, \"<internal>\");\n       else if (flags & TS_PEDANTIC_NAME)\n         dump_function_decl (t, flags | TS_FUNC_NORETURN | TS_DECL_TYPE);\n       else\n@@ -1110,14 +1093,14 @@ dump_decl (t, flags)\n \tif (is_overloaded_fn (name))\n \t  name = DECL_NAME (get_first_fn (name));\n \tdump_decl (name, flags);\n-\tOB_PUTC ('<');\n+\tprint_template_argument_list_start (scratch_buffer);\n \tfor (args = TREE_OPERAND (t, 1); args; args = TREE_CHAIN (args))\n \t  {\n \t    dump_template_argument (TREE_VALUE (args), flags);\n \t    if (TREE_CHAIN (args))\n-\t      OB_PUTS (\", \");\n+\t      separate_with_comma (scratch_buffer);\n \t  }\n-\tOB_END_TEMPLATE_ID ();\n+\tprint_template_argument_list_end (scratch_buffer);\n       }\n       break;\n \n@@ -1126,7 +1109,7 @@ dump_decl (t, flags)\n       break;\n \n     case LABEL_DECL:\n-      OB_PUTID (DECL_NAME (t));\n+      print_tree_identifier (scratch_buffer, DECL_NAME (t));\n       break;\n \n     case CONST_DECL:\n@@ -1139,23 +1122,22 @@ dump_decl (t, flags)\n       else if (DECL_INITIAL (t))\n \tdump_expr (DECL_INITIAL (t), flags | TS_EXPR_PARENS);\n       else\n-\tOB_PUTS (\"enumerator\");\n+\tprint_identifier (scratch_buffer, \"enumerator\");\n       break;\n \n     case USING_DECL:\n-      OB_PUTS (\"using \");\n+      output_add_string (scratch_buffer, \"using \");\n       dump_type (DECL_INITIAL (t), flags);\n-      OB_PUTS (\"::\");\n-      OB_PUTID (DECL_NAME (t));\n+      print_scope_operator (scratch_buffer);\n+      print_tree_identifier (scratch_buffer, DECL_NAME (t));\n       break;\n \n     default:\n-      sorry (\"`%s' not supported by dump_decl\",\n-\t     tree_code_name[(int) TREE_CODE (t)]);\n+      sorry_for_unsupported_tree (t);\n       /* Fallthrough to error.  */\n \n     case ERROR_MARK:\n-      OB_PUTS (\"{declaration error}\");\n+      print_identifier (scratch_buffer, \"<declaration error>\");\n       break;\n     }\n }\n@@ -1181,15 +1163,15 @@ dump_template_decl (t, flags)\n \t  tree inner_parms = INNERMOST_TEMPLATE_PARMS (parms);\n           int len = TREE_VEC_LENGTH (inner_parms);\n \n-          OB_PUTS (\"template <\");\n+          output_add_string (scratch_buffer, \"template<\");\n           for (i = 0; i < len; i++)\n             {\n               if (i)\n-                OB_PUTS (\", \");\n+                separate_with_comma (scratch_buffer);\n               dump_template_parameter (TREE_VEC_ELT (inner_parms, i), flags);\n             }\n-          OB_END_TEMPLATE_ID ();\n-          OB_PUTC (' ');\n+          print_template_argument_list_end (scratch_buffer);\n+          separate_with_comma (scratch_buffer);\n         }\n       nreverse(orig_parms);\n       /* If we've shown the template<args> prefix, we'd better show the\n@@ -1265,9 +1247,9 @@ dump_function_decl (t, flags)\n   if (!(flags & TS_DECORATE))\n     /* OK */;\n   else if (DECL_STATIC_FUNCTION_P (t))\n-    OB_PUTS (\"static \");\n+    print_identifier (scratch_buffer, \"static \");\n   else if (TYPE_POLYMORPHIC_P (t))\n-    OB_PUTS (\"virtual \");\n+    print_identifier (scratch_buffer, \"virtual \");\n \n   /* Print the return type?  */\n   if (show_return)\n@@ -1276,14 +1258,14 @@ dump_function_decl (t, flags)\n   if (show_return)\n     {\n       if (dump_type_prefix (TREE_TYPE (fntype), flags) != none)\n-        OB_PUTC (' ');\n+        output_add_space (scratch_buffer);\n     }\n \n   /* Print the function name.  */\n   if (cname)\n     {\n       dump_type (cname, flags);\n-      OB_PUTS (\"::\");\n+      print_scope_operator (scratch_buffer);\n     }\n   else\n     dump_scope (CP_DECL_CONTEXT (t), flags);\n@@ -1315,9 +1297,9 @@ dump_function_decl (t, flags)\n   /* If T is a template instantiation, dump the parameter binding.  */\n   if (template_parms != NULL_TREE && template_args != NULL_TREE)\n     {\n-      OB_PUTS (\" [with \");\n+      output_add_string (scratch_buffer, \" [with \");\n       dump_template_bindings (template_parms, template_args);\n-      OB_PUTC (']');\n+      print_right_bracket (scratch_buffer);\n     }\n }\n \n@@ -1331,29 +1313,30 @@ dump_parameters (parmtypes, flags)\n      enum tree_string_flags flags;\n {\n   int first;\n-  OB_PUTS (\" (\");\n+\n+  print_left_paren (scratch_buffer);\n \n   for (first = 1; parmtypes != void_list_node;\n        parmtypes = TREE_CHAIN (parmtypes))\n     {\n       if (!first)\n-        OB_PUTS (\", \");\n+        separate_with_comma (scratch_buffer);\n       first = 0;\n       if (!parmtypes)\n         {\n-          OB_PUTS (\"...\");\n+          print_identifier (scratch_buffer, \"...\");\n           break;\n         }\n       dump_type (TREE_VALUE (parmtypes), flags);\n \n       if ((flags & TS_PARM_DEFAULTS) && TREE_PURPOSE (parmtypes))\n         {\n-          OB_PUTS (\" = \");\n+          output_add_string (scratch_buffer, \" = \");\n           dump_expr (TREE_PURPOSE (parmtypes), flags | TS_EXPR_PARENS);\n         }\n     }\n \n-  OB_PUTC (')');\n+  print_right_paren (scratch_buffer);\n }\n \n /* Print an exception specification. T is the exception specification. */\n@@ -1365,17 +1348,17 @@ dump_exception_spec (t, flags)\n {\n   if (t)\n     {\n-      OB_PUTS (\" throw (\");\n+      output_add_string (scratch_buffer, \" throw (\");\n       if (TREE_VALUE (t) != NULL_TREE)\n         while (1)\n           {\n             dump_type (TREE_VALUE (t), flags);\n             t = TREE_CHAIN (t);\n             if (!t)\n               break;\n-            OB_PUTS (\", \");\n+            separate_with_comma (scratch_buffer);\n           }\n-      OB_PUTC (')');\n+      print_right_paren (scratch_buffer);\n     }\n }\n \n@@ -1391,7 +1374,7 @@ dump_function_name (t, flags)\n \n   if (DECL_DESTRUCTOR_P (t))\n     {\n-      OB_PUTC ('~');\n+      output_add_character (scratch_buffer, '~');\n       dump_decl (name, TS_PLAIN);\n     }\n   else if (DECL_CONV_FN_P (t))\n@@ -1402,11 +1385,11 @@ dump_function_name (t, flags)\n \t declarations, both will have the same name, yet\n \t the types will be different, hence the TREE_TYPE field\n \t of the first name will be clobbered by the second.  */\n-      OB_PUTS (\"operator \");\n+      output_add_string (scratch_buffer, \"operator \");\n       dump_type (TREE_TYPE (TREE_TYPE (t)), flags);\n     }\n   else if (IDENTIFIER_OPNAME_P (name))\n-    OB_PUTID (name);\n+    print_tree_identifier (scratch_buffer, name);\n   else\n     dump_decl (name, flags);\n \n@@ -1436,7 +1419,7 @@ dump_template_parms (info, primary, flags)\n   if (primary && flags & TS_TEMPLATE_PLAIN)\n     return;\n   flags &= ~(TS_AGGR_TAGS | TS_TEMPLATE_PLAIN);\n-  OB_PUTC ('<');\n+  print_template_argument_list_start (scratch_buffer);\n \n   /* Be careful only to print things when we have them, so as not\n \t to crash producing error messages.  */\n@@ -1470,10 +1453,10 @@ dump_template_parms (info, primary, flags)\n               args = TREE_CHAIN (args);\n             }\n           if (need_comma)\n-            OB_PUTS (\", \");\n-\n+            separate_with_comma (scratch_buffer);\n+          \n           if (!arg)\n-            OB_PUTS (\"{template parameter error}\");\n+            print_identifier (scratch_buffer, \"<template parameter error>\");\n           else\n             dump_template_argument (arg, flags);\n           need_comma = 1;\n@@ -1493,12 +1476,12 @@ dump_template_parms (info, primary, flags)\n           tree parm = TREE_VALUE (TREE_VEC_ELT (parms, ix));\n \n           if (ix)\n-            OB_PUTS (\", \");\n+            separate_with_comma (scratch_buffer);\n \n           dump_decl (parm, flags & ~TS_DECL_TYPE);\n         }\n     }\n-  OB_END_TEMPLATE_ID ();\n+  print_template_argument_list_end (scratch_buffer);\n }\n \n static void\n@@ -1508,42 +1491,42 @@ dump_char (c)\n   switch (c)\n     {\n     case TARGET_NEWLINE:\n-      OB_PUTS (\"\\\\n\");\n+      output_add_string (scratch_buffer, \"\\\\n\");\n       break;\n     case TARGET_TAB:\n-      OB_PUTS (\"\\\\t\");\n+      output_add_string (scratch_buffer, \"\\\\t\");\n       break;\n     case TARGET_VT:\n-      OB_PUTS (\"\\\\v\");\n+      output_add_string (scratch_buffer, \"\\\\v\");\n       break;\n     case TARGET_BS:\n-      OB_PUTS (\"\\\\b\");\n+      output_add_string (scratch_buffer, \"\\\\b\");\n       break;\n     case TARGET_CR:\n-      OB_PUTS (\"\\\\r\");\n+      output_add_string (scratch_buffer, \"\\\\r\");\n       break;\n     case TARGET_FF:\n-      OB_PUTS (\"\\\\f\");\n+      output_add_string (scratch_buffer, \"\\\\f\");\n       break;\n     case TARGET_BELL:\n-      OB_PUTS (\"\\\\a\");\n+      output_add_string (scratch_buffer, \"\\\\a\");\n       break;\n     case '\\\\':\n-      OB_PUTS (\"\\\\\\\\\");\n+      output_add_string (scratch_buffer, \"\\\\\\\\\");\n       break;\n     case '\\'':\n-      OB_PUTS (\"\\\\'\");\n+      output_add_string (scratch_buffer, \"\\\\'\");\n       break;\n     case '\\\"':\n-      OB_PUTS (\"\\\\\\\"\");\n+      output_add_string (scratch_buffer, \"\\\\\\\"\");\n       break;\n     default:\n       if (ISPRINT (c))\n-\tOB_PUTC (c);\n+\toutput_add_character (scratch_buffer, c);\n       else\n \t{\n \t  sprintf (digit_buffer, \"\\\\%03o\", (int) c);\n-\t  OB_PUTCP (digit_buffer);\n+\t  output_add_string (scratch_buffer, digit_buffer);\n \t}\n     }\n }\n@@ -1560,7 +1543,7 @@ dump_expr_list (l, flags)\n       dump_expr (TREE_VALUE (l), flags | TS_EXPR_PARENS);\n       l = TREE_CHAIN (l);\n       if (l)\n-\tOB_PUTS (\", \");\n+\tseparate_with_comma (scratch_buffer);\n     }\n }\n \n@@ -1600,28 +1583,28 @@ dump_expr (t, flags)\n \t        break;\n \n \t    if (values)\n-\t      OB_PUTID (TREE_PURPOSE (values));\n+\t      print_tree_identifier (scratch_buffer, TREE_PURPOSE (values));\n \t    else\n \t      {\n                 /* Value must have been cast.  */\n-                OB_PUTC ('(');\n+                print_left_paren (scratch_buffer);\n                 dump_type (type, flags);\n-                OB_PUTC (')');\n+                print_right_paren (scratch_buffer);\n                 goto do_int;\n \t      }\n \t  }\n \telse if (type == boolean_type_node)\n \t  {\n \t    if (t == boolean_false_node || integer_zerop (t))\n-\t      OB_PUTS (\"false\");\n+\t      print_identifier (scratch_buffer, \"false\");\n \t    else if (t == boolean_true_node)\n-\t      OB_PUTS (\"true\");\n+\t      print_identifier (scratch_buffer, \"true\");\n \t  }\n \telse if (type == char_type_node)\n \t  {\n-\t    OB_PUTC ('\\'');\n+\t    output_add_character (scratch_buffer, '\\'');\n \t    dump_char (tree_low_cst (t, 0));\n-\t    OB_PUTC ('\\'');\n+\t    output_add_character (scratch_buffer, '\\'');\n \t  }\n \telse\n \t  {\n@@ -1633,7 +1616,7 @@ dump_expr (t, flags)\n \n \t        if (tree_int_cst_sgn (val) < 0)\n \t          {\n-\t\t    OB_PUTC ('-');\n+\t\t    output_add_character (scratch_buffer, '-');\n \t\t    val = build_int_2 (-TREE_INT_CST_LOW (val),\n \t\t\t\t       ~TREE_INT_CST_HIGH (val)\n \t                               + !TREE_INT_CST_LOW (val));\n@@ -1646,11 +1629,11 @@ dump_expr (t, flags)\n \t\t    sprintf (format, \"%%x%%0%dx\", HOST_BITS_PER_INT / 4);\n \t          sprintf (digit_buffer, format, TREE_INT_CST_HIGH (val),\n \t\t           TREE_INT_CST_LOW (val));\n-\t          OB_PUTCP (digit_buffer);\n+\t          output_add_string (scratch_buffer, digit_buffer);\n \t        }\n \t      }\n \t    else\n-\t      OB_PUTI (TREE_INT_CST_LOW (t));\n+\t      print_integer (scratch_buffer, TREE_INT_CST_LOW (t));\n \t  }\n       }\n       break;\n@@ -1667,14 +1650,15 @@ dump_expr (t, flags)\n \t  sprintf (digit_buffer + 2 + 2*i, \"%02x\", *p++);\n       }\n #endif\n-      OB_PUTCP (digit_buffer);\n+      output_add_string (scratch_buffer, digit_buffer);\n       break;\n \n     case PTRMEM_CST:\n-      OB_PUTC ('&');\n+      output_add_character (scratch_buffer, '&');\n       dump_type (PTRMEM_CST_CLASS (t), flags);\n-      OB_PUTS (\"::\");\n-      OB_PUTID (DECL_NAME (PTRMEM_CST_MEMBER (t)));\n+      print_scope_operator (scratch_buffer);\n+      print_tree_identifier\n+        (scratch_buffer, DECL_NAME (PTRMEM_CST_MEMBER (t)));\n       break;\n \n     case STRING_CST:\n@@ -1683,35 +1667,35 @@ dump_expr (t, flags)\n \tint len = TREE_STRING_LENGTH (t) - 1;\n \tint i;\n \n-\tOB_PUTC ('\\\"');\n+\toutput_add_character (scratch_buffer, '\\\"');\n \tfor (i = 0; i < len; i++)\n \t  dump_char (p[i]);\n-\tOB_PUTC ('\\\"');\n+\toutput_add_character (scratch_buffer, '\\\"');\n       }\n       break;\n \n     case COMPOUND_EXPR:\n-      OB_PUTC ('(');\n+      print_left_paren (scratch_buffer);\n       dump_expr (TREE_OPERAND (t, 0), flags | TS_EXPR_PARENS);\n-      OB_PUTS (\", \");\n+      separate_with_comma (scratch_buffer);\n       dump_expr (TREE_OPERAND (t, 1), flags | TS_EXPR_PARENS);\n-      OB_PUTC (')');\n+      print_right_paren (scratch_buffer);\n       break;\n \n     case COND_EXPR:\n-      OB_PUTC ('(');\n+      print_left_paren (scratch_buffer);\n       dump_expr (TREE_OPERAND (t, 0), flags | TS_EXPR_PARENS);\n-      OB_PUTS (\" ? \");\n+      output_add_string (scratch_buffer, \" ? \");\n       dump_expr (TREE_OPERAND (t, 1), flags | TS_EXPR_PARENS);\n-      OB_PUTS (\" : \");\n+      output_add_string (scratch_buffer, \" : \");\n       dump_expr (TREE_OPERAND (t, 2), flags | TS_EXPR_PARENS);\n-      OB_PUTC (')');\n+      print_right_paren (scratch_buffer);\n       break;\n \n     case SAVE_EXPR:\n       if (TREE_HAS_CONSTRUCTOR (t))\n \t{\n-\t  OB_PUTS (\"new \");\n+\t  output_add_string (scratch_buffer, \"new \");\n \t  dump_type (TREE_TYPE (TREE_TYPE (t)), flags);\n \t}\n       else\n@@ -1730,17 +1714,18 @@ dump_expr (t, flags)\n \tif (fn && TREE_CODE (fn) == FUNCTION_DECL)\n \t  {\n \t    if (DECL_CONSTRUCTOR_P (fn))\n-\t      OB_PUTID (TYPE_IDENTIFIER (TREE_TYPE (t)));\n+\t      print_tree_identifier\n+                (scratch_buffer, TYPE_IDENTIFIER (TREE_TYPE (t)));\n \t    else\n \t      dump_decl (fn, 0);\n \t  }\n \telse\n \t  dump_expr (TREE_OPERAND (t, 0), 0);\n       }\n-      OB_PUTC ('(');\n+      print_left_paren (scratch_buffer);\n       if (TREE_OPERAND (t, 1))\n \tdump_expr_list (TREE_CHAIN (TREE_OPERAND (t, 1)), flags);\n-      OB_PUTC (')');\n+      print_right_paren (scratch_buffer);\n       break;\n \n     case CALL_EXPR:\n@@ -1757,34 +1742,34 @@ dump_expr (t, flags)\n \t    if (TREE_CODE (ob) == ADDR_EXPR)\n \t      {\n \t\tdump_expr (TREE_OPERAND (ob, 0), flags | TS_EXPR_PARENS);\n-\t\tOB_PUTC ('.');\n+\t\toutput_add_character (scratch_buffer, '.');\n \t      }\n \t    else if (TREE_CODE (ob) != PARM_DECL\n \t\t     || strcmp (IDENTIFIER_POINTER (DECL_NAME (ob)), \"this\"))\n \t      {\n \t\tdump_expr (ob, flags | TS_EXPR_PARENS);\n-\t\tOB_PUTS (\"->\");\n+\t\toutput_add_string (scratch_buffer, \"->\");\n \t      }\n \t    args = TREE_CHAIN (args);\n \t  }\n \tdump_expr (fn, flags | TS_EXPR_PARENS);\n-\tOB_PUTC ('(');\n+\tprint_left_paren (scratch_buffer);\n \tdump_expr_list (args, flags);\n-\tOB_PUTC (')');\n+\tprint_right_paren (scratch_buffer);\n       }\n       break;\n \n     case NEW_EXPR:\n       {\n \ttree type = TREE_OPERAND (t, 1);\n \tif (NEW_EXPR_USE_GLOBAL (t))\n-\t  OB_PUTS (\"::\");\n-\tOB_PUTS (\"new \");\n+\t  print_scope_operator (scratch_buffer);\n+\toutput_add_string (scratch_buffer, \"new \");\n \tif (TREE_OPERAND (t, 0))\n \t  {\n-\t    OB_PUTC ('(');\n+\t    print_left_paren (scratch_buffer);\n \t    dump_expr_list (TREE_OPERAND (t, 0), flags);\n-\t    OB_PUTS (\") \");\n+\t    output_add_string (scratch_buffer, \") \");\n \t  }\n \tif (TREE_CODE (type) == ARRAY_REF)\n \t  type = build_cplus_array_type\n@@ -1795,9 +1780,9 @@ dump_expr (t, flags)\n \tdump_type (type, flags);\n \tif (TREE_OPERAND (t, 2))\n \t  {\n-\t    OB_PUTC ('(');\n+\t    print_left_paren (scratch_buffer);\n \t    dump_expr_list (TREE_OPERAND (t, 2), flags);\n-\t    OB_PUTC (')');\n+\t    print_right_paren (scratch_buffer);\n \t  }\n       }\n       break;\n@@ -1861,31 +1846,31 @@ dump_expr (t, flags)\n \t\t|| strcmp (IDENTIFIER_POINTER (DECL_NAME (ob)), \"this\"))\n \t      {\n \t\tdump_expr (ob, flags | TS_EXPR_PARENS);\n-\t\tOB_PUTS (\"->\");\n+\t\toutput_add_string (scratch_buffer, \"->\");\n \t      }\n \t  }\n \telse\n \t  {\n \t    dump_expr (ob, flags | TS_EXPR_PARENS);\n-\t    OB_PUTC ('.');\n+\t    output_add_character (scratch_buffer, '.');\n \t  }\n \tdump_expr (TREE_OPERAND (t, 1), flags & ~TS_EXPR_PARENS);\n       }\n       break;\n \n     case ARRAY_REF:\n       dump_expr (TREE_OPERAND (t, 0), flags | TS_EXPR_PARENS);\n-      OB_PUTC ('[');\n+      print_left_bracket (scratch_buffer);\n       dump_expr (TREE_OPERAND (t, 1), flags | TS_EXPR_PARENS);\n-      OB_PUTC (']');\n+      print_right_bracket (scratch_buffer);\n       break;\n \n     case CONVERT_EXPR:\n       if (VOID_TYPE_P (TREE_TYPE (t)))\n \t{\n-\t  OB_PUTC ('(');\n+\t  print_left_paren (scratch_buffer);\n \t  dump_type (TREE_TYPE (t), flags);\n-\t  OB_PUTC (')');\n+\t  print_right_paren (scratch_buffer);\n \t  dump_expr (TREE_OPERAND (t, 0), flags);\n \t}\n       else\n@@ -1911,9 +1896,9 @@ dump_expr (t, flags)\n \t  t = TREE_OPERAND (t, 0);\n \t  my_friendly_assert (TREE_CODE (t) == CALL_EXPR, 237);\n \t  dump_expr (TREE_OPERAND (t, 0), flags | TS_EXPR_PARENS);\n-\t  OB_PUTC ('(');\n+\t  print_left_paren (scratch_buffer);\n \t  dump_expr_list (TREE_CHAIN (TREE_OPERAND (t, 1)), flags);\n-\t  OB_PUTC (')');\n+\t  print_right_paren (scratch_buffer);\n \t}\n       else\n \t{\n@@ -1936,10 +1921,11 @@ dump_expr (t, flags)\n \n     case POSTDECREMENT_EXPR:\n     case POSTINCREMENT_EXPR:\n-      OB_PUTC ('(');\n+      print_left_paren (scratch_buffer);\n       dump_expr (TREE_OPERAND (t, 0), flags | TS_EXPR_PARENS);\n-      OB_PUTCP (operator_name_info[(int)TREE_CODE (t)].name);\n-      OB_PUTC (')');\n+      print_identifier\n+        (scratch_buffer, operator_name_info[(int)TREE_CODE (t)].name);\n+      print_right_paren (scratch_buffer);\n       break;\n \n     case NON_LVALUE_EXPR:\n@@ -1956,11 +1942,11 @@ dump_expr (t, flags)\n \t  if (TREE_CODE (next) == FUNCTION_TYPE)\n \t    {\n \t      if (flags & TS_EXPR_PARENS)\n-\t        OB_PUTC ('(');\n-\t      OB_PUTC ('*');\n+\t        print_left_paren (scratch_buffer);\n+\t      output_add_character (scratch_buffer, '*');\n \t      dump_expr (TREE_OPERAND (t, 0), flags & ~TS_EXPR_PARENS);\n \t      if (flags & TS_EXPR_PARENS)\n-\t        OB_PUTC (')');\n+\t        print_right_paren (scratch_buffer);\n \t      break;\n \t    }\n \t  /* else FALLTHRU */\n@@ -1991,9 +1977,9 @@ dump_expr (t, flags)\n \t\t   && tree_int_cst_equal (idx, integer_zero_node))\n \t    {\n \t      /* A NULL pointer-to-member constant.  */\n-\t      OB_PUTS (\"((\");\n+\t      output_add_string (scratch_buffer, \"((\");\n \t      dump_type (TREE_TYPE (t), flags);\n-\t      OB_PUTS (\") 0)\");\n+\t      output_add_string (scratch_buffer, \") 0)\");\n \t      break;\n \t    }\n \t  else if (host_integerp (idx, 0))\n@@ -2024,9 +2010,9 @@ dump_expr (t, flags)\n \t\t}\n \t    }\n \t}\n-      OB_PUTC ('{');\n+      output_add_character (scratch_buffer, '{');\n       dump_expr_list (CONSTRUCTOR_ELTS (t), flags);\n-      OB_PUTC ('}');\n+      output_add_character (scratch_buffer, '}');\n       break;\n \n     case OFFSET_REF:\n@@ -2048,12 +2034,12 @@ dump_expr (t, flags)\n \t    if (TREE_CODE (ob) == INDIRECT_REF)\n \t      {\n \t\tdump_expr (TREE_OPERAND (ob, 0), flags | TS_EXPR_PARENS);\n-\t\tOB_PUTS (\" ->* \");\n+\t\toutput_add_string (scratch_buffer, \"->*\");\n \t      }\n \t    else\n \t      {\n \t\tdump_expr (ob, flags | TS_EXPR_PARENS);\n-\t\tOB_PUTS (\" .* \");\n+\t\toutput_add_string (scratch_buffer, \".*\");\n \t      }\n \t    dump_expr (TREE_OPERAND (t, 1), flags | TS_EXPR_PARENS);\n \t  }\n@@ -2065,12 +2051,12 @@ dump_expr (t, flags)\n       break;\n \n     case IDENTIFIER_NODE:\n-      OB_PUTID (t);\n+      print_tree_identifier (scratch_buffer, t);\n       break;\n \n     case SCOPE_REF:\n       dump_type (TREE_OPERAND (t, 0), flags);\n-      OB_PUTS (\"::\");\n+      print_scope_operator (scratch_buffer);\n       dump_expr (TREE_OPERAND (t, 1), flags | TS_EXPR_PARENS);\n       break;\n \n@@ -2079,48 +2065,47 @@ dump_expr (t, flags)\n \t  || TREE_CHAIN (TREE_OPERAND (t, 0)))\n \t{\n \t  dump_type (TREE_TYPE (t), flags);\n-\t  OB_PUTC ('(');\n+\t  print_left_paren (scratch_buffer);\n \t  dump_expr_list (TREE_OPERAND (t, 0), flags);\n-\t  OB_PUTC (')');\n+\t  print_right_paren (scratch_buffer);\n \t}\n       else\n \t{\n-\t  OB_PUTC ('(');\n+\t  print_left_paren (scratch_buffer);\n \t  dump_type (TREE_TYPE (t), flags);\n-\t  OB_PUTC (')');\n-\t  OB_PUTC ('(');\n+          output_add_string (scratch_buffer, \")(\");\n \t  dump_expr_list (TREE_OPERAND (t, 0), flags);\n-\t  OB_PUTC (')');\n+\t  print_right_paren (scratch_buffer);\n \t}\n       break;\n \n     case LOOKUP_EXPR:\n-      OB_PUTID (TREE_OPERAND (t, 0));\n+      print_tree_identifier (scratch_buffer, TREE_OPERAND (t, 0));\n       break;\n \n     case ARROW_EXPR:\n       dump_expr (TREE_OPERAND (t, 0), flags);\n-      OB_PUTS (\"->\");\n+      output_add_string (scratch_buffer, \"->\");\n       break;\n \n     case SIZEOF_EXPR:\n     case ALIGNOF_EXPR:\n       if (TREE_CODE (t) == SIZEOF_EXPR)\n-\tOB_PUTS (\"sizeof (\");\n+\toutput_add_string (scratch_buffer, \"sizeof (\");\n       else\n \t{\n \t  my_friendly_assert (TREE_CODE (t) == ALIGNOF_EXPR, 0);\n-\t  OB_PUTS (\"__alignof__ (\");\n+\t  output_add_string (scratch_buffer, \"__alignof__ (\");\n \t}\n       if (TYPE_P (TREE_OPERAND (t, 0)))\n \tdump_type (TREE_OPERAND (t, 0), flags);\n       else\n \tdump_unary_op (\"*\", t, flags | TS_EXPR_PARENS);\n-      OB_PUTC (')');\n+      print_right_paren (scratch_buffer);\n       break;\n \n     case DEFAULT_ARG:\n-      OB_PUTS (\"{unparsed}\");\n+      print_identifier (scratch_buffer, \"<unparsed>\");\n       break;\n \n     case TRY_CATCH_EXPR:\n@@ -2131,9 +2116,9 @@ dump_expr (t, flags)\n \n     case PSEUDO_DTOR_EXPR:\n       dump_expr (TREE_OPERAND (t, 2), flags);\n-      OB_PUTS (\".\");\n+      output_add_character (scratch_buffer, '.');\n       dump_type (TREE_OPERAND (t, 0), flags);\n-      OB_PUTS (\"::~\");\n+      output_add_string (scratch_buffer, \"::~\");\n       dump_type (TREE_OPERAND (t, 1), flags);\n       break;\n \n@@ -2144,31 +2129,31 @@ dump_expr (t, flags)\n     case STMT_EXPR:\n       /* We don't yet have a way of dumping statements in a\n \t human-readable format.  */\n-      OB_PUTS (\"{ ... }\");\n+      output_add_string (scratch_buffer, \"({...})\");\n       break;\n \n     case BIND_EXPR:\n-      OB_PUTS (\"{ \");\n+      output_add_character (scratch_buffer, '}');\n       dump_expr (TREE_OPERAND (t, 1), flags & ~TS_EXPR_PARENS);\n-      OB_PUTS (\"} \");\n+      output_add_character (scratch_buffer, '}');\n       break;\n \n     case LOOP_EXPR:\n-      OB_PUTS (\"while (1) { \");\n+      output_add_string (scratch_buffer, \"while (1) { \");\n       dump_expr (TREE_OPERAND (t, 0), flags & ~TS_EXPR_PARENS);\n-      OB_PUTS (\"} \");\n+      output_add_character (scratch_buffer, '}');\n       break;\n \n     case EXIT_EXPR:\n-      OB_PUTS (\"if (\");\n+      output_add_string (scratch_buffer, \"if (\");\n       dump_expr (TREE_OPERAND (t, 0), flags & ~TS_EXPR_PARENS);\n-      OB_PUTS (\") break; \");\n+      output_add_string (scratch_buffer, \") break; \");\n       break;\n \n     case TREE_LIST:\n       if (TREE_VALUE (t) && TREE_CODE (TREE_VALUE (t)) == FUNCTION_DECL)\n \t{\n-\t  OB_PUTID (DECL_NAME (TREE_VALUE (t)));\n+\t  print_tree_identifier (scratch_buffer, DECL_NAME (TREE_VALUE (t)));\n \t  break;\n \t}\n       /* else fall through */\n@@ -2177,12 +2162,10 @@ dump_expr (t, flags)\n \t  It is very important that `sorry' does not call\n \t  `report_error_function'.  That could cause an infinite loop.  */\n     default:\n-      sorry (\"`%s' not supported by dump_expr\",\n-\t     tree_code_name[(int) TREE_CODE (t)]);\n-\n+      sorry_for_unsupported_tree (t);\n       /* fall through to ERROR_MARK...  */\n     case ERROR_MARK:\n-      OB_PUTCP (\"{expression error}\");\n+      print_identifier (scratch_buffer, \"<expression error>\");\n       break;\n     }\n }\n@@ -2193,16 +2176,16 @@ dump_binary_op (opstring, t, flags)\n      tree t;\n      enum tree_string_flags flags;\n {\n-  OB_PUTC ('(');\n+  print_left_paren (scratch_buffer);\n   dump_expr (TREE_OPERAND (t, 0), flags | TS_EXPR_PARENS);\n-  OB_PUTC (' ');\n+  output_add_space (scratch_buffer);\n   if (opstring)\n-    OB_PUTCP (opstring);\n+    print_identifier (scratch_buffer, opstring);\n   else\n-    OB_PUTS (\"<unknown operator>\");\n-  OB_PUTC (' ');\n+    print_identifier (scratch_buffer, \"<unknown operator>\");\n+  output_add_space (scratch_buffer);\n   dump_expr (TREE_OPERAND (t, 1), flags | TS_EXPR_PARENS);\n-  OB_PUTC (')');\n+  print_right_paren (scratch_buffer);\n }\n \n static void\n@@ -2212,11 +2195,11 @@ dump_unary_op (opstring, t, flags)\n      enum tree_string_flags flags;\n {\n   if (flags & TS_EXPR_PARENS)\n-    OB_PUTC ('(');\n-  OB_PUTCP (opstring);\n+    print_left_paren (scratch_buffer);\n+  print_identifier (scratch_buffer, opstring);\n   dump_expr (TREE_OPERAND (t, 0), flags & ~TS_EXPR_PARENS);\n   if (flags & TS_EXPR_PARENS)\n-    OB_PUTC (')');\n+    print_right_paren (scratch_buffer);\n }\n \n /* Exported interface to stringifying types, exprs and decls under TS_*\n@@ -2227,55 +2210,47 @@ type_as_string (typ, flags)\n      tree typ;\n      enum tree_string_flags flags;\n {\n-  OB_INIT ();\n+  reinit_global_formatting_buffer ();\n \n   dump_type (typ, flags);\n \n-  OB_FINISH ();\n-\n-  return (char *)obstack_base (&scratch_obstack);\n+  return output_finalize_message (scratch_buffer);\n }\n \n const char *\n expr_as_string (decl, flags)\n      tree decl;\n      enum tree_string_flags flags;\n {\n-  OB_INIT ();\n+  reinit_global_formatting_buffer ();\n \n   dump_expr (decl, flags);\n \n-  OB_FINISH ();\n-\n-  return (char *)obstack_base (&scratch_obstack);\n+  return output_finalize_message (scratch_buffer);\n }\n \n const char *\n decl_as_string (decl, flags)\n      tree decl;\n      enum tree_string_flags flags;\n {\n-  OB_INIT ();\n+  reinit_global_formatting_buffer ();\n \n   dump_decl (decl, flags);\n \n-  OB_FINISH ();\n-\n-  return (char *)obstack_base (&scratch_obstack);\n+  return output_finalize_message (scratch_buffer);\n }\n \n const char *\n context_as_string (context, flags)\n      tree context;\n      enum tree_string_flags flags;\n {\n-  OB_INIT ();\n+  reinit_global_formatting_buffer ();\n \n   dump_scope (context, flags);\n \n-  OB_FINISH ();\n-\n-  return (char *)obstack_base (&scratch_obstack);\n+  return output_finalize_message (scratch_buffer);\n }\n \n /* Generate the three forms of printable names for lang_printable_name.  */\n@@ -2288,22 +2263,20 @@ lang_decl_name (decl, v)\n   if (v >= 2)\n     return decl_as_string (decl, TS_DECL_TYPE);\n \n-  OB_INIT ();\n+  reinit_global_formatting_buffer ();\n \n   if (v == 1 && DECL_CLASS_SCOPE_P (decl))\n     {\n       dump_type (CP_DECL_CONTEXT (decl), TS_PLAIN);\n-      OB_PUTS (\"::\");\n+      print_scope_operator (scratch_buffer);\n     }\n \n   if (TREE_CODE (decl) == FUNCTION_DECL)\n     dump_function_name (decl, TS_PLAIN);\n   else\n     dump_decl (DECL_NAME (decl), TS_PLAIN);\n \n-  OB_FINISH ();\n-\n-  return (char *)obstack_base (&scratch_obstack);\n+  return output_finalize_message (scratch_buffer);\n }\n \n const char *\n@@ -2364,27 +2337,23 @@ decl_to_string (decl, verbose)\n     flags |= TS_DECL_TYPE | TS_FUNC_NORETURN;\n   flags |= TS_TEMPLATE_PREFIX;\n \n-  OB_INIT ();\n+  reinit_global_formatting_buffer ();\n \n   dump_decl (decl, flags);\n \n-  OB_FINISH ();\n-\n-  return (char *)obstack_base (&scratch_obstack);\n+  return output_finalize_message (scratch_buffer);\n }\n \n static const char *\n expr_to_string (decl, verbose)\n      tree decl;\n      int verbose ATTRIBUTE_UNUSED;\n {\n-  OB_INIT ();\n+  reinit_global_formatting_buffer ();\n \n   dump_expr (decl, 0);\n \n-  OB_FINISH ();\n-\n-  return (char *)obstack_base (&scratch_obstack);\n+  return output_finalize_message (scratch_buffer);\n }\n \n static const char *\n@@ -2397,13 +2366,11 @@ fndecl_to_string (fndecl, verbose)\n   flags = TS_FUNC_THROW | TS_DECL_TYPE;\n   if (verbose)\n     flags |= TS_PARM_DEFAULTS;\n-  OB_INIT ();\n+  reinit_global_formatting_buffer ();\n \n   dump_decl (fndecl, flags);\n \n-  OB_FINISH ();\n-\n-  return (char *)obstack_base (&scratch_obstack);\n+  return output_finalize_message (scratch_buffer);\n }\n \n \n@@ -2474,13 +2441,11 @@ type_to_string (typ, verbose)\n     flags |= TS_AGGR_TAGS;\n   flags |= TS_TEMPLATE_PREFIX;\n \n-  OB_INIT ();\n+  reinit_global_formatting_buffer ();\n \n   dump_type (typ, flags);\n \n-  OB_FINISH ();\n-\n-  return (char *)obstack_base (&scratch_obstack);\n+  return output_finalize_message (scratch_buffer);\n }\n \n static const char *\n@@ -2509,32 +2474,29 @@ args_to_string (p, verbose)\n   if (TYPE_P (TREE_VALUE (p)))\n     return type_as_string (p, flags);\n \n-  OB_INIT ();\n+  reinit_global_formatting_buffer ();\n   for (; p; p = TREE_CHAIN (p))\n     {\n       if (TREE_VALUE (p) == null_node)\n-\tOB_PUTS (\"NULL\");\n+\tprint_identifier (scratch_buffer, \"NULL\");\n       else\n \tdump_type (error_type (TREE_VALUE (p)), flags);\n       if (TREE_CHAIN (p))\n-\tOB_PUTS (\", \");\n+\tseparate_with_comma (scratch_buffer);\n     }\n-  OB_FINISH ();\n-  return (char *)obstack_base (&scratch_obstack);\n+  return output_finalize_message (scratch_buffer);\n }\n \n static const char *\n cv_to_string (p, v)\n      tree p;\n      int v ATTRIBUTE_UNUSED;\n {\n-  OB_INIT ();\n+  reinit_global_formatting_buffer ();\n \n   dump_qualifiers (p, before);\n \n-  OB_FINISH ();\n-\n-  return (char *)obstack_base (&scratch_obstack);\n+  return output_finalize_message (scratch_buffer);\n }\n \n static void\n@@ -2821,6 +2783,15 @@ print_expression (buffer, tfi)\n {\n }\n \n+static void\n+print_integer (buffer, i)\n+     output_buffer *buffer;\n+     HOST_WIDE_INT i;\n+{\n+  sprintf (digit_buffer, HOST_WIDE_INT_PRINT_DEC, (HOST_WIDE_INT) i);\n+  output_add_string (buffer, digit_buffer);\n+}\n+\n /* Print a function declaration represented by tree_being_formatted (TFI)\n    onto BUFFER.  */\n static void\n@@ -3425,13 +3396,13 @@ typedef_original_name (t)\n }\n \n static void\n-print_template_argument_list_start (buffer)\n-     output_buffer *buffer __attribute__ ((__unused__));\n+print_non_consecutive_character (buffer, c)\n+     output_buffer *buffer;\n+     int c;\n {\n-}\n+  const char *p = output_last_position (buffer);\n \n-static void\n-print_template_argument_list_end (buffer)\n-     output_buffer *buffer __attribute__ ((__unused__));\n-{\n+  if (p != NULL && *p == c)\n+    output_add_space (buffer);\n+  output_add_character (buffer, c);\n }"}, {"sha": "17bd2bd33169e3c4c3be71b32e83eec0a653b0d8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99885b3f2a551d1f052e25ff718d9813664edcd2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99885b3f2a551d1f052e25ff718d9813664edcd2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=99885b3f2a551d1f052e25ff718d9813664edcd2", "patch": "@@ -1,3 +1,9 @@\n+2000-09-29  Gabriel Dos Reis  <gdr@codesourcery.com>\n+\n+\t* g++.old-deja/g++.ext/pretty3.C: Fix comparison with\n+\t__PRETTY_FUNCTION__.\t \n+\t* g++.old-deja/g++.ext/pretty2.C: Likewise.\n+\n 2000-09-28  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* gcc.dg/wtr-int-type-1.c: Don't expect a warning from system headers."}, {"sha": "d48d5fa7b468e14086d1fb0ea94821ce96a60c37", "filename": "gcc/testsuite/g++.old-deja/g++.ext/pretty2.C", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99885b3f2a551d1f052e25ff718d9813664edcd2/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.ext%2Fpretty2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99885b3f2a551d1f052e25ff718d9813664edcd2/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.ext%2Fpretty2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.ext%2Fpretty2.C?ref=99885b3f2a551d1f052e25ff718d9813664edcd2", "patch": "@@ -27,7 +27,7 @@ X::X ()\n   \n   if (strcmp (function, \"X\"))\n     bad = true;\n-  if (strcmp (pretty, \"X::X ()\"))\n+  if (strcmp (pretty, \"X::X()\"))\n     bad = true;\n }\n X::~X ()\n@@ -41,7 +41,7 @@ X::~X ()\n   \n   if (strcmp (function, \"X\"))\n     bad = true;\n-  if (strcmp (pretty, \"X::~X ()\"))\n+  if (strcmp (pretty, \"X::~X()\"))\n     bad = true;\n }\n void X::fn ()\n@@ -55,7 +55,7 @@ void X::fn ()\n   \n   if (strcmp (function, \"fn\"))\n     bad = true;\n-  if (strcmp (pretty, \"void X::fn ()\"))\n+  if (strcmp (pretty, \"void X::fn()\"))\n     bad = true;\n }\n X::operator int ()\n@@ -69,7 +69,7 @@ X::operator int ()\n   \n   if (strcmp (function, \"__opi\"))\n     bad = true;\n-  if (strcmp (pretty, \"X::operator int ()\"))\n+  if (strcmp (pretty, \"X::operator int()\"))\n     bad = true;\n   return 0;\n }"}, {"sha": "9d49f63dd15f848ee9acefb3da282a048121ad78", "filename": "gcc/testsuite/g++.old-deja/g++.ext/pretty3.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99885b3f2a551d1f052e25ff718d9813664edcd2/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.ext%2Fpretty3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99885b3f2a551d1f052e25ff718d9813664edcd2/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.ext%2Fpretty3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.ext%2Fpretty3.C?ref=99885b3f2a551d1f052e25ff718d9813664edcd2", "patch": "@@ -19,7 +19,7 @@ template<class T> void f1 (T)\n   \n   if (strcmp (function, \"f1\"))\n     bad = true;\n-  if (strcmp (pretty, \"void f1 (T) [with T = float]\")) // only for float instantiation\n+  if (strcmp (pretty, \"void f1(T) [with T = float]\")) // only for float instantiation\n     bad = true;\n }\n \n@@ -34,7 +34,7 @@ template<> void f1<int> (int)\n   \n   if (strcmp (function, \"f1\"))\n     bad = true;\n-  if (strcmp (pretty, \"void f1 (T) [with T = int]\"))\n+  if (strcmp (pretty, \"void f1(T) [with T = int]\"))\n     bad = true;\n }\n "}]}