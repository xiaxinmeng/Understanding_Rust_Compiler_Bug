{"sha": "d9a5f1807c4b954ec5c0d256838cbbcf784431b1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDlhNWYxODA3YzRiOTU0ZWM1YzBkMjU2ODM4Y2JiY2Y3ODQ0MzFiMQ==", "commit": {"author": {"name": "Graham Stott", "email": "grahams@redhat.com", "date": "2002-01-07T09:06:00Z"}, "committer": {"name": "Graham Stott", "email": "grahams@gcc.gnu.org", "date": "2002-01-07T09:06:00Z"}, "message": "i386.h: Update copyright date.\n\n        * config/i386/i386.h: Update copyright date.\n        (HALF_PIC_PTR): Add parenthesis.\n        (OPTIMIZATION_OPTIONS): Whitespace, add parenthesis and wrap.\n        (CONSTANT_ALIGNMENT): Add parenthesis.\n        (DATA_ALIGNMENT): Likewise.\n        (LOCAL_ALIGNMENT): Likewise.\n        (FUNCTION_ARG_BOUNDARY): Whitespace, add parenthesis and wrap.\n        (IS_STACK_MODE): Uppercase macro parameter, add parenthesis and wrap.\n        (CONDITIONAL_REGISTER_USAGE): Wrap in do {...} while (0).\n        (HARD_REGNO_NREGS): Add paranethesis.\n        (VALID_SSE_REG_MODE): Whitespace.\n        (VALID_MMX_REG_MODE): Whitespace.\n        (VALID_FP_MODE_P): Uppercase macros parameter and whitespace.\n        (ix86_hard_regno_mode_ok): Add parenthesis.\n        (HARD_REGNO_CALLER_SAVE_MODE): Whitespace.\n        (RETURN_IN_MEMORY): Whitespace.\n        (N_REG_CLASSES): Add parenthesis.\n        (INTEGER_CLASS_P): Add parenthesis and wrap.\n        (FLOAT_CLASS_P): Likewise.\n        (SSE_CLASS_P): Likewise.\n        (MMX_CLASS_P): Likewise.\n        (MAYBE_INTEGER_CLASS_P): Likewise.\n        (MAYBE_FLOAT_CLASS_P): Likewise.\n        (MAYBE_SSE_CLASS_P): Likewise.\n        (MAYBE_MMX_CLASS_P): Likewise.\n        (Q_CLASS_P): Likewise.\n        (REGNO_REG_CLASS): Add parenthesis.\n        (GENERAL_REGNO_P): Uppercase macro parameter.\n        (REX_INT_REGNO_P): Uppercase macro parameter and wrap.\n        (FP_REGNO_P): Likewise.\n        (ANY_FP_REGNO_P): Uppercase macro parameter.\n        (SSE_REGNO_P): Likewise.\n        (SSE_REGNO): Likewise.\n        (SSE_REG_P): Likewise.\n        (SSE_FLOAT_MODE_P): Likewise.\n        (MMX_REGNO_P): Likewise.\n        (MMX_REG_P):Likewise.\n        (STACK_REG_P): Likewise.\n        (NON_STACK_REG_P): Likewise.\n        (STACK_TOP_P): Likewise.\n        (CONVERT_HARD_REGISTER_TO_SSA_P): Add parenthesis.\n        (PREFERRED_RELOAD_CLASS): Add parenthesis and whitespace.\n        (SECONDARY_MEMORY_NEEDED): Likewise.\n        (SECONDARY_OUTPUT_RELOAD_CLASS): Whitespace.\n        (MD_ASM_CLOBBERS): Whitespace and wrap.\n        (MUST_PASS_IN_STACK): Whitespace and wrap.\n        (RETURN_POPS_ARGS): Add parenthesis.\n        (INIT_CUMULATIVE_ARGS): Likewise.\n        (FUNCTION_ARG): Likewise.\n        (FUNCTION_OK_FOR_SIBCALL): Add parenthesis and whitespace.\n        (SETUP_INCOMING_VARARGS): Likewise.\n        (BUILD_VA_LIST_TYPE):  Add parenthesis.\n        (EXPAND_BUILTIN_VA_START): Uppercase macro paremeters and add\n        parenthsis.\n        (EXPAND_BUILTIN_VA_ARG): Likewise.\n        (FUNCTION_PROFILER): Wrap in do { ... } while (0) and add parenthesis.\n        (INITIALIZE_TRAMPOLINE): Add parenthesis.\n        (INITIAL_ELIMINATION_OFFSET): Likewise.\n        (REGNO_OK_FOR_INDEX_P): Add parenthesis.\n        (REGNO_OK_FOR_BASE_P): Likewise.\n        (REGNO_OK_FOR_SIREG_P): Add parenthesis and wrap.\n        (REGNO_OK_FOR_DIREG_P): Likewise.\n        (REG_OK_FOR_INDEX_P): Whitespace.\n        (REG_OK_FOR_BASE_P): Whitespace.\n        (GO_IF_LEGITIMATE_ADDRESS): Wrap in do { ... } while (0) and add\n        parenthesis.\n        (FIND_BASE_TERM): Fix typo.\n        (LEGITIMIZE_ADDRESS): Wrap in  { .. } while (0) and add parenthesis.\n        (REWRITE_ADDRESS): Uppercase macro parameter and whitespace.\n        (SYMBOLIC_CONST; Whitespace.\n        (GO_IF_MODE_DEPENDENT_ADDRESS):Wrap in  { .. } while (0) and wrap.\n        (ENCODE_SECTION_INFO): Whitespace.\n        (FINALIZE_PIC): Remove do { ... } while (0).\n        (PROMOTE_MODE): Wrap in do { ... } while (0).\n        (CONST_COSTS): Whitespace.\n        (RTX_COSTS): Add paramethesis, whitespace and wrap.\n        (REGISTER_MOVE_COST): Add parenthesis.\n        (MEMORY_MOVE_COST): Likewise.\n        (EXTRA_CC_MODES): Whitespace.\n        (SELECT_CC_MODE): Add parenthesis and whitespace.\n        (DBX_REGISTER_NUMBER): Uppercase macro parameter and add parenthsis.\n        (ASM_PREFERRED_EH_DATA_FORMAT): Add parenthesis and whitespace.\n        (ASM_OUTPUT_LABEL): Add paranethesis.\n        (ASM_OUTPUT_REG_PUSH): Add parenthesis and whitespace.\n        (ASM_OUTPUT_REG_POP): Likewise.\n        (ASM_OUTPUT_ADDR_VEC_ELT): Add parenthesis.\n        (ASM_OUTPUT_ADDR_DIFF_ELT): Likewise.\n\nFrom-SVN: r48598", "tree": {"sha": "f0563732758dd10db3e46c64adb4ac848b1b38a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f0563732758dd10db3e46c64adb4ac848b1b38a0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d9a5f1807c4b954ec5c0d256838cbbcf784431b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9a5f1807c4b954ec5c0d256838cbbcf784431b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9a5f1807c4b954ec5c0d256838cbbcf784431b1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9a5f1807c4b954ec5c0d256838cbbcf784431b1/comments", "author": null, "committer": null, "parents": [{"sha": "07933f7233603dafab21527c681a9e656c75435c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07933f7233603dafab21527c681a9e656c75435c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07933f7233603dafab21527c681a9e656c75435c"}], "stats": {"total": 562, "additions": 336, "deletions": 226}, "files": [{"sha": "122981b288a20247e5ae4b779c7279434781ae36", "filename": "gcc/ChangeLog", "status": "modified", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a5f1807c4b954ec5c0d256838cbbcf784431b1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a5f1807c4b954ec5c0d256838cbbcf784431b1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d9a5f1807c4b954ec5c0d256838cbbcf784431b1", "patch": "@@ -1,5 +1,92 @@\n 2002-01-07  Graham Stott  <grahams@redhat.com>\n \n+        * config/i386/i386.h: Update copyright date.\n+        (HALF_PIC_PTR): Add parenthesis.\n+        (OPTIMIZATION_OPTIONS): Whitespace, add parenthesis and wrap.\n+        (CONSTANT_ALIGNMENT): Add parenthesis.\n+        (DATA_ALIGNMENT): Likewise.\n+        (LOCAL_ALIGNMENT): Likewise.\n+        (FUNCTION_ARG_BOUNDARY): Whitespace, add parenthesis and wrap.\n+        (IS_STACK_MODE): Uppercase macro parameter, add parenthesis and wrap.\n+        (CONDITIONAL_REGISTER_USAGE): Wrap in do {...} while (0).\n+        (HARD_REGNO_NREGS): Add paranethesis.\n+        (VALID_SSE_REG_MODE): Whitespace.\n+        (VALID_MMX_REG_MODE): Whitespace.\n+        (VALID_FP_MODE_P): Uppercase macros parameter and whitespace.\n+        (ix86_hard_regno_mode_ok): Add parenthesis.\n+        (HARD_REGNO_CALLER_SAVE_MODE): Whitespace.\n+        (RETURN_IN_MEMORY): Whitespace.\n+        (N_REG_CLASSES): Add parenthesis.\n+        (INTEGER_CLASS_P): Add parenthesis and wrap.\n+        (FLOAT_CLASS_P): Likewise.\n+        (SSE_CLASS_P): Likewise.\n+        (MMX_CLASS_P): Likewise.\n+        (MAYBE_INTEGER_CLASS_P): Likewise.\n+        (MAYBE_FLOAT_CLASS_P): Likewise.\n+        (MAYBE_SSE_CLASS_P): Likewise.\n+        (MAYBE_MMX_CLASS_P): Likewise. \n+        (Q_CLASS_P): Likewise.\n+        (GENERAL_REGNO_P): Uppercase macro parameter.\n+        (REX_INT_REGNO_P): Uppercase macro parameter and wrap.\n+        (FP_REGNO_P): Likewise.\n+        (ANY_FP_REGNO_P): Uppercase macro parameter.\n+        (SSE_REGNO_P): Likewise.\n+        (SSE_REGNO): Likewise.\n+        (SSE_REG_P): Likewise.\n+        (SSE_FLOAT_MODE_P): Likewise.\n+        (MMX_REGNO_P): Likewise.\n+        (MMX_REG_P):Likewise. \n+        (STACK_REG_P): Likewise.\n+        (NON_STACK_REG_P): Likewise.\n+        (STACK_TOP_P): Likewise.\n+        (CONVERT_HARD_REGISTER_TO_SSA_P): Add parenthesis.\n+        (PREFERRED_RELOAD_CLASS): Add parenthesis and whitespace.\n+        (SECONDARY_MEMORY_NEEDED): Likewise.\n+        (SECONDARY_OUTPUT_RELOAD_CLASS): Whitespace.\n+        (MD_ASM_CLOBBERS): Whitespace and wrap.\n+        (MUST_PASS_IN_STACK): Whitespace and wrap.\n+        (RETURN_POPS_ARGS): Add parenthesis.\n+        (INIT_CUMULATIVE_ARGS): Likewise.\n+        (FUNCTION_ARG): Likewise.\n+        (FUNCTION_OK_FOR_SIBCALL): Add parenthesis and whitespace.\n+        (SETUP_INCOMING_VARARGS): Likewise.\n+        (BUILD_VA_LIST_TYPE):  Add parenthesis.\n+        (EXPAND_BUILTIN_VA_START): Uppercase macro paremeters and add\n+        parenthsis.\n+        (EXPAND_BUILTIN_VA_ARG): Likewise.\n+        (FUNCTION_PROFILER): Wrap in do { ... } while (0) and add parenthesis.\n+        (INITIALIZE_TRAMPOLINE): Add parenthesis.\n+        (INITIAL_ELIMINATION_OFFSET): Likewise.\n+        (REGNO_OK_FOR_INDEX_P): Add parenthesis.\n+        (REGNO_OK_FOR_BASE_P): Likewise.\n+        (REGNO_OK_FOR_SIREG_P): Add parenthesis and wrap.\n+        (REGNO_OK_FOR_DIREG_P): Likewise.\n+        (REG_OK_FOR_INDEX_P): Whitespace.\n+        (REG_OK_FOR_BASE_P): Whitespace.\n+        (GO_IF_LEGITIMATE_ADDRESS): Wrap in do { ... } while (0) and add\n+        parenthesis.\n+        (FIND_BASE_TERM): Fix typo.\n+        (LEGITIMIZE_ADDRESS): Wrap in  { .. } while (0) and add parenthesis.\n+        (REWRITE_ADDRESS): Uppercase macro parameter and whitespace.\n+        (SYMBOLIC_CONST; Whitespace.\n+        (GO_IF_MODE_DEPENDENT_ADDRESS):Wrap in  { .. } while (0) and wrap.\n+        (ENCODE_SECTION_INFO): Whitespace.\n+        (FINALIZE_PIC): Remove do { ... } while (0).\n+        (PROMOTE_MODE): Wrap in do { ... } while (0).\n+        (CONST_COSTS): Whitespace.\n+        (RTX_COSTS): Add paramethesis, whitespace and wrap.\n+        (REGISTER_MOVE_COST): Add parenthesis.\n+        (MEMORY_MOVE_COST): Likewise.\n+        (EXTRA_CC_MODES): Whitespace.\n+        (SELECT_CC_MODE): Add parenthesis and whitespace.\n+        (DBX_REGISTER_NUMBER): Uppercase macro parameter and add parenthsis.\n+        (ASM_PREFERRED_EH_DATA_FORMAT): Add parenthesis and whitespace.\n+        (ASM_OUTPUT_LABEL): Add paramethesis.\n+        (ASM_OUTPUT_REG_PUSH): Add parenthesis and whitespace.\n+        (ASM_OUTPUT_REG_POP): Likewise.\n+        (ASM_OUTPUT_ADDR_VEC_ELT): Add parenthesis.\n+        (ASM_OUTPUT_ADDR_DIFF_ELT): Likewise.\n+\n \t* config/i386/i386.c: Update copyright.\n \t(CHECK_STACK_LIMIT): Add parenthesis.\n \t(AT_BP): Uppercase macro parameter."}, {"sha": "38a3f37e8590aca0ac66b494720f0bf84c48a5b5", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 249, "deletions": 226, "changes": 475, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a5f1807c4b954ec5c0d256838cbbcf784431b1/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a5f1807c4b954ec5c0d256838cbbcf784431b1/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=d9a5f1807c4b954ec5c0d256838cbbcf784431b1", "patch": "@@ -1,6 +1,6 @@\n /* Definitions of target machine for GNU compiler for IA-32.\n    Copyright (C) 1988, 1992, 1994, 1995, 1996, 1997, 1998, 1999, 2000,\n-   2001 Free Software Foundation, Inc.\n+   2001, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -44,7 +44,7 @@ Boston, MA 02111-1307, USA.  */\n #define HALF_PIC_DECLARE(NAME)\n #define HALF_PIC_INIT()\terror (\"half-pic init called on systems that don't support it\")\n #define HALF_PIC_ADDRESS_P(X) 0\n-#define HALF_PIC_PTR(X) X\n+#define HALF_PIC_PTR(X) (X)\n #define HALF_PIC_FINISH(STREAM)\n #endif\n \n@@ -464,7 +464,8 @@ extern int ix86_arch;\n #define SUBTARGET_OPTIONS\n \n /* Define this to change the optimizations performed by default.  */\n-#define OPTIMIZATION_OPTIONS(LEVEL,SIZE) optimization_options(LEVEL,SIZE)\n+#define OPTIMIZATION_OPTIONS(LEVEL, SIZE) \\\n+  optimization_options ((LEVEL), (SIZE))\n \n /* Specs for the compiler proper */\n \n@@ -794,7 +795,7 @@ march=athlon|march=athlon-tbird|march=athlon-4|march=athlon-xp\\\n    constants to be word aligned so that `strcpy' calls that copy\n    constants can be done inline.  */\n \n-#define CONSTANT_ALIGNMENT(EXP, ALIGN) ix86_constant_alignment (EXP, ALIGN)\n+#define CONSTANT_ALIGNMENT(EXP, ALIGN) ix86_constant_alignment ((EXP), (ALIGN))\n \n /* If defined, a C expression to compute the alignment for a static\n    variable.  TYPE is the data type, and ALIGN is the alignment that\n@@ -808,7 +809,7 @@ march=athlon|march=athlon-tbird|march=athlon-4|march=athlon-xp\\\n    cause character arrays to be word-aligned so that `strcpy' calls\n    that copy constants to character arrays can be done inline.  */\n \n-#define DATA_ALIGNMENT(TYPE, ALIGN) ix86_data_alignment (TYPE, ALIGN)\n+#define DATA_ALIGNMENT(TYPE, ALIGN) ix86_data_alignment ((TYPE), (ALIGN))\n \n /* If defined, a C expression to compute the alignment for a local\n    variable.  TYPE is the data type, and ALIGN is the alignment that\n@@ -820,13 +821,14 @@ march=athlon|march=athlon-tbird|march=athlon-4|march=athlon-xp\\\n    One use of this macro is to increase alignment of medium-size\n    data to make it all fit in fewer cache lines.  */\n \n-#define LOCAL_ALIGNMENT(TYPE, ALIGN) ix86_local_alignment (TYPE, ALIGN)\n+#define LOCAL_ALIGNMENT(TYPE, ALIGN) ix86_local_alignment ((TYPE), (ALIGN))\n \n /* If defined, a C expression that gives the alignment boundary, in\n    bits, of an argument with the specified mode and type.  If it is\n    not defined, `PARM_BOUNDARY' is used for all arguments.  */\n \n-#define FUNCTION_ARG_BOUNDARY(MODE,TYPE) ix86_function_arg_boundary (MODE, TYPE)\n+#define FUNCTION_ARG_BOUNDARY(MODE, TYPE) \\\n+  ix86_function_arg_boundary ((MODE), (TYPE))\n \n /* Set this non-zero if move instructions will actually fail to work\n    when given unaligned data.  */\n@@ -843,8 +845,9 @@ march=athlon|march=athlon-tbird|march=athlon-4|march=athlon-xp\\\n    for details.  */\n \n #define STACK_REGS\n-#define IS_STACK_MODE(mode) (mode==DFmode || mode==SFmode \\\n-\t\t\t     || mode==XFmode || mode==TFmode)\n+#define IS_STACK_MODE(MODE)\t\t\t\t\t\\\n+  ((MODE) == DFmode || (MODE) == SFmode || (MODE) == XFmode\t\\\n+   || (MODE) == TFmode)\n \n /* Number of actual hardware registers.\n    The hardware registers are assigned numbers for the compiler\n@@ -958,7 +961,7 @@ march=athlon|march=athlon-tbird|march=athlon-4|march=athlon-xp\\\n \n /* Macro to conditionally modify fixed_regs/call_used_regs.  */\n #define CONDITIONAL_REGISTER_USAGE\t\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n     int i;\t\t\t\t\t\t\t\t\\\n     for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n@@ -994,7 +997,7 @@ march=athlon|march=athlon-tbird|march=athlon-4|march=athlon-xp\\\n           if (TEST_HARD_REG_BIT (x, i)) \t\t\t\t\\\n \t    fixed_regs[i] = call_used_regs[i] = 1;\t\t\t\\\n       }\t\t\t\t\t\t\t\t\t\\\n-  }\n+  } while (0)\n \n /* Return number of consecutive hard regs needed starting at reg REGNO\n    to hold something of mode MODE.\n@@ -1009,46 +1012,46 @@ march=athlon|march=athlon-tbird|march=athlon-4|march=athlon-xp\\\n #define HARD_REGNO_NREGS(REGNO, MODE)   \\\n   (FP_REGNO_P (REGNO) || SSE_REGNO_P (REGNO) || MMX_REGNO_P (REGNO)\t\\\n    ? (COMPLEX_MODE_P (MODE) ? 2 : 1)\t\t\t\t\t\\\n-   : (MODE == TFmode\t\t\t\t\t\t\t\\\n+   : ((MODE) == TFmode\t\t\t\t\t\t\t\\\n       ? (TARGET_64BIT ? 2 : 3)\t\t\t\t\t\t\\\n-      : MODE == TCmode\t\t\t\t\t\t\t\\\n+      : (MODE) == TCmode\t\t\t\t\t\t\\\n       ? (TARGET_64BIT ? 4 : 6)\t\t\t\t\t\t\\\n       : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)))\n \n-#define VALID_SSE_REG_MODE(MODE) \\\n-    ((MODE) == TImode || (MODE) == V4SFmode || (MODE) == V4SImode \\\n-     || (MODE) == SFmode \\\n+#define VALID_SSE_REG_MODE(MODE)\t\t\t\t\t\\\n+    ((MODE) == TImode || (MODE) == V4SFmode || (MODE) == V4SImode\t\\\n+     || (MODE) == SFmode\t\t\t\t\t\t\\\n      || (TARGET_SSE2 && ((MODE) == DFmode || VALID_MMX_REG_MODE (MODE))))\n \n #define VALID_MMX_REG_MODE_3DNOW(MODE) \\\n     ((MODE) == V2SFmode || (MODE) == SFmode)\n \n-#define VALID_MMX_REG_MODE(MODE) \\\n-    ((MODE) == DImode || (MODE) == V8QImode || (MODE) == V4HImode \\\n+#define VALID_MMX_REG_MODE(MODE)\t\t\t\t\t\\\n+    ((MODE) == DImode || (MODE) == V8QImode || (MODE) == V4HImode\t\\\n      || (MODE) == V2SImode || (MODE) == SImode)\n \n #define VECTOR_MODE_SUPPORTED_P(MODE)\t\t\t\t\t\\\n     (VALID_SSE_REG_MODE (MODE) && TARGET_SSE ? 1\t\t\t\\\n      : VALID_MMX_REG_MODE (MODE) && TARGET_MMX ? 1\t\t\t\\\n      : VALID_MMX_REG_MODE_3DNOW (MODE) && TARGET_3DNOW ? 1 : 0)\n \n-#define VALID_FP_MODE_P(mode) \\\n-    ((mode) == SFmode || (mode) == DFmode || (mode) == TFmode\t\\\n-     || (!TARGET_64BIT && (mode) == XFmode)\t\t\t\\\n-     || (mode) == SCmode || (mode) == DCmode || (mode) == TCmode\\\n-     || (!TARGET_64BIT && (mode) == XCmode))\n+#define VALID_FP_MODE_P(MODE)\t\t\t\t\t\t\\\n+    ((MODE) == SFmode || (MODE) == DFmode || (MODE) == TFmode\t\t\\\n+     || (!TARGET_64BIT && (MODE) == XFmode)\t\t\t\t\\\n+     || (MODE) == SCmode || (MODE) == DCmode || (MODE) == TCmode\t\\\n+     || (!TARGET_64BIT && (MODE) == XCmode))\n \n-#define VALID_INT_MODE_P(mode) \\\n-    ((mode) == QImode || (mode) == HImode || (mode) == SImode\t\\\n-     || (mode) == DImode\t\t\t\t\t\\\n-     || (mode) == CQImode || (mode) == CHImode || (mode) == CSImode \\\n-     || (mode) == CDImode\t\t\t\t\t\\\n-     || (TARGET_64BIT && ((mode) == TImode || (mode) == CTImode)))\n+#define VALID_INT_MODE_P(MODE)\t\t\t\t\t\t\\\n+    ((MODE) == QImode || (MODE) == HImode || (MODE) == SImode\t\t\\\n+     || (MODE) == DImode\t\t\t\t\t\t\\\n+     || (MODE) == CQImode || (MODE) == CHImode || (MODE) == CSImode\t\\\n+     || (MODE) == CDImode\t\t\t\t\t\t\\\n+     || (TARGET_64BIT && ((MODE) == TImode || (MODE) == CTImode)))\n \n /* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.  */\n \n #define HARD_REGNO_MODE_OK(REGNO, MODE)\t\\\n-   ix86_hard_regno_mode_ok (REGNO, MODE)\n+   ix86_hard_regno_mode_ok ((REGNO), (MODE))\n \n /* Value is 1 if it is a good idea to tie two pseudo registers\n    when one has mode MODE1 and one has mode MODE2.\n@@ -1072,12 +1075,12 @@ march=athlon|march=athlon-tbird|march=athlon-4|march=athlon-xp\\\n \n    Kill any attempts to combine saving of modes.  */\n \n-#define HARD_REGNO_CALLER_SAVE_MODE(REGNO, NREGS, MODE)\t\t\\\n-  (CC_REGNO_P (REGNO) ? VOIDmode\t\t\t\t\\\n-   : (MODE) == VOIDmode && (NREGS) != 1 ? VOIDmode\t\t\\\n-   : (MODE) == VOIDmode ? choose_hard_reg_mode ((REGNO), (NREGS)) \\\n-   : (MODE) == HImode && !TARGET_PARTIAL_REG_STALL ? SImode\t\\\n-   : (MODE) == QImode && (REGNO) >= 4 && !TARGET_64BIT ? SImode \\\n+#define HARD_REGNO_CALLER_SAVE_MODE(REGNO, NREGS, MODE)\t\t\t\\\n+  (CC_REGNO_P (REGNO) ? VOIDmode\t\t\t\t\t\\\n+   : (MODE) == VOIDmode && (NREGS) != 1 ? VOIDmode\t\t\t\\\n+   : (MODE) == VOIDmode ? choose_hard_reg_mode ((REGNO), (NREGS))\t\\\n+   : (MODE) == HImode && !TARGET_PARTIAL_REG_STALL ? SImode\t\t\\\n+   : (MODE) == QImode && (REGNO) >= 4 && !TARGET_64BIT ? SImode \t\\\n    : (MODE))\n /* Specify the registers used for certain standard purposes.\n    The values of these macros are register numbers.  */\n@@ -1174,7 +1177,7 @@ march=athlon|march=athlon-tbird|march=athlon-4|march=athlon-xp\\\n    should always be returned in memory.  You should instead use\n    `DEFAULT_PCC_STRUCT_RETURN' to indicate this.  */\n \n-#define RETURN_IN_MEMORY(TYPE)\t\t\t\t\t\t\\\n+#define RETURN_IN_MEMORY(TYPE) \\\n   ix86_return_in_memory (TYPE)\n \n \f\n@@ -1227,18 +1230,27 @@ enum reg_class\n   ALL_REGS, LIM_REG_CLASSES\n };\n \n-#define N_REG_CLASSES (int) LIM_REG_CLASSES\n-\n-#define INTEGER_CLASS_P(CLASS) (reg_class_subset_p (CLASS, GENERAL_REGS))\n-#define FLOAT_CLASS_P(CLASS) (reg_class_subset_p (CLASS, FLOAT_REGS))\n-#define SSE_CLASS_P(CLASS) (reg_class_subset_p (CLASS, SSE_REGS))\n-#define MMX_CLASS_P(CLASS) (reg_class_subset_p (CLASS, MMX_REGS))\n-#define MAYBE_INTEGER_CLASS_P(CLASS) (reg_classes_intersect_p (CLASS, GENERAL_REGS))\n-#define MAYBE_FLOAT_CLASS_P(CLASS) (reg_classes_intersect_p (CLASS, FLOAT_REGS))\n-#define MAYBE_SSE_CLASS_P(CLASS) (reg_classes_intersect_p (SSE_REGS, CLASS))\n-#define MAYBE_MMX_CLASS_P(CLASS) (reg_classes_intersect_p (MMX_REGS, CLASS))\n-\n-#define Q_CLASS_P(CLASS) (reg_class_subset_p (CLASS, Q_REGS))\n+#define N_REG_CLASSES ((int) LIM_REG_CLASSES)\n+\n+#define INTEGER_CLASS_P(CLASS) \\\n+  reg_class_subset_p ((CLASS), GENERAL_REGS)\n+#define FLOAT_CLASS_P(CLASS) \\\n+  reg_class_subset_p ((CLASS), FLOAT_REGS)\n+#define SSE_CLASS_P(CLASS) \\\n+  reg_class_subset_p ((CLASS), SSE_REGS)\n+#define MMX_CLASS_P(CLASS) \\\n+  reg_class_subset_p ((CLASS), MMX_REGS)\n+#define MAYBE_INTEGER_CLASS_P(CLASS) \\\n+  reg_classes_intersect_p ((CLASS), GENERAL_REGS)\n+#define MAYBE_FLOAT_CLASS_P(CLASS) \\\n+  reg_classes_intersect_p ((CLASS), FLOAT_REGS)\n+#define MAYBE_SSE_CLASS_P(CLASS) \\\n+  reg_classes_intersect_p (SSE_REGS, (CLASS))\n+#define MAYBE_MMX_CLASS_P(CLASS) \\\n+  reg_classes_intersect_p (MMX_REGS, (CLASS))\n+\n+#define Q_CLASS_P(CLASS) \\\n+  reg_class_subset_p ((CLASS), Q_REGS)\n \n /* Give names of register classes as strings for dump file.   */\n \n@@ -1307,8 +1319,8 @@ enum reg_class\n #define QI_REG_P(X) \\\n   (REG_P (X) && REGNO (X) < 4)\n \n-#define GENERAL_REGNO_P(n) \\\n-  ((n) < 8 || REX_INT_REGNO_P (n))\n+#define GENERAL_REGNO_P(N) \\\n+  ((N) < 8 || REX_INT_REGNO_P (N))\n \n #define GENERAL_REG_P(X) \\\n   (REG_P (X) && GENERAL_REGNO_P (REGNO (X)))\n@@ -1318,43 +1330,44 @@ enum reg_class\n #define NON_QI_REG_P(X) \\\n   (REG_P (X) && REGNO (X) >= 4 && REGNO (X) < FIRST_PSEUDO_REGISTER)\n \n-#define REX_INT_REGNO_P(n) ((n) >= FIRST_REX_INT_REG && (n) <= LAST_REX_INT_REG)\n+#define REX_INT_REGNO_P(N) ((N) >= FIRST_REX_INT_REG && (N) <= LAST_REX_INT_REG)\n #define REX_INT_REG_P(X) (REG_P (X) && REX_INT_REGNO_P (REGNO (X)))\n \n #define FP_REG_P(X) (REG_P (X) && FP_REGNO_P (REGNO (X)))\n-#define FP_REGNO_P(n) ((n) >= FIRST_STACK_REG && (n) <= LAST_STACK_REG)\n+#define FP_REGNO_P(N) ((N) >= FIRST_STACK_REG && (N) <= LAST_STACK_REG)\n #define ANY_FP_REG_P(X) (REG_P (X) && ANY_FP_REGNO_P (REGNO (X)))\n-#define ANY_FP_REGNO_P(n) (FP_REGNO_P (n) || SSE_REGNO_P (n))\n+#define ANY_FP_REGNO_P(N) (FP_REGNO_P (N) || SSE_REGNO_P (N))\n \n-#define SSE_REGNO_P(n) \\\n-  (((n) >= FIRST_SSE_REG && (n) <= LAST_SSE_REG) \\\n-   || ((n) >= FIRST_REX_SSE_REG && (n) <= LAST_REX_SSE_REG))\n+#define SSE_REGNO_P(N) \\\n+  (((N) >= FIRST_SSE_REG && (N) <= LAST_SSE_REG) \\\n+   || ((N) >= FIRST_REX_SSE_REG && (N) <= LAST_REX_SSE_REG))\n \n-#define SSE_REGNO(n) \\\n-  ((n) < 8 ? FIRST_SSE_REG + (n) : FIRST_REX_SSE_REG + (n) - 8)\n-#define SSE_REG_P(n) (REG_P (n) && SSE_REGNO_P (REGNO (n)))\n+#define SSE_REGNO(N) \\\n+  ((N) < 8 ? FIRST_SSE_REG + (N) : FIRST_REX_SSE_REG + (N) - 8)\n+#define SSE_REG_P(N) (REG_P (N) && SSE_REGNO_P (REGNO (N)))\n \n-#define SSE_FLOAT_MODE_P(m) \\\n-  ((TARGET_SSE_MATH && (m) == SFmode) || (TARGET_SSE2 && (m) == DFmode))\n+#define SSE_FLOAT_MODE_P(MODE) \\\n+  ((TARGET_SSE_MATH && (MODE) == SFmode) || (TARGET_SSE2 && (MODE) == DFmode))\n \n-#define MMX_REGNO_P(n) ((n) >= FIRST_MMX_REG && (n) <= LAST_MMX_REG)\n-#define MMX_REG_P(xop) (REG_P (xop) && MMX_REGNO_P (REGNO (xop)))\n+#define MMX_REGNO_P(N) ((N) >= FIRST_MMX_REG && (N) <= LAST_MMX_REG)\n+#define MMX_REG_P(XOP) (REG_P (XOP) && MMX_REGNO_P (REGNO (XOP)))\n   \n-#define STACK_REG_P(xop) (REG_P (xop) &&\t\t       \t\\\n-\t\t\t  REGNO (xop) >= FIRST_STACK_REG &&\t\\\n-\t\t\t  REGNO (xop) <= LAST_STACK_REG)\n+#define STACK_REG_P(XOP)\t\t\\\n+  (REG_P (XOP) &&\t\t       \t\\\n+   REGNO (XOP) >= FIRST_STACK_REG &&\t\\\n+   REGNO (XOP) <= LAST_STACK_REG)\n \n-#define NON_STACK_REG_P(xop) (REG_P (xop) && ! STACK_REG_P (xop))\n+#define NON_STACK_REG_P(XOP) (REG_P (XOP) && ! STACK_REG_P (XOP))\n \n-#define STACK_TOP_P(xop) (REG_P (xop) && REGNO (xop) == FIRST_STACK_REG)\n+#define STACK_TOP_P(XOP) (REG_P (XOP) && REGNO (XOP) == FIRST_STACK_REG)\n \n #define CC_REG_P(X) (REG_P (X) && CC_REGNO_P (REGNO (X)))\n #define CC_REGNO_P(X) ((X) == FLAGS_REG || (X) == FPSR_REG)\n \n /* Indicate whether hard register numbered REG_NO should be converted\n    to SSA form.  */\n #define CONVERT_HARD_REGISTER_TO_SSA_P(REG_NO) \\\n-  (REG_NO == FLAGS_REG || REG_NO == ARG_POINTER_REGNUM)\n+  ((REG_NO) == FLAGS_REG || (REG_NO) == ARG_POINTER_REGNUM)\n \n /* The class value for index registers, and the one for base regs.  */\n \n@@ -1459,19 +1472,19 @@ enum reg_class\n    Narrow ALL_REGS to GENERAL_REGS.  This supports allowing movsf and\n    movdf to do mem-to-mem moves through integer regs.  */\n \n-#define PREFERRED_RELOAD_CLASS(X,CLASS)\t\t\t\t\t\\\n-   ix86_preferred_reload_class (X, CLASS)\n+#define PREFERRED_RELOAD_CLASS(X, CLASS) \\\n+   ix86_preferred_reload_class ((X), (CLASS))\n \n /* If we are copying between general and FP registers, we need a memory\n    location. The same is true for SSE and MMX registers.  */\n-#define SECONDARY_MEMORY_NEEDED(CLASS1,CLASS2,MODE) \\\n-  ix86_secondary_memory_needed (CLASS1, CLASS2, MODE, 1)\n+#define SECONDARY_MEMORY_NEEDED(CLASS1, CLASS2, MODE) \\\n+  ix86_secondary_memory_needed ((CLASS1), (CLASS2), (MODE), 1)\n \n /* QImode spills from non-QI registers need a scratch.  This does not\n    happen often -- the only example so far requires an uninitialized \n    pseudo.  */\n \n-#define SECONDARY_OUTPUT_RELOAD_CLASS(CLASS,MODE,OUT) \\\n+#define SECONDARY_OUTPUT_RELOAD_CLASS(CLASS, MODE, OUT)\t\t\t\\\n   ((CLASS) == GENERAL_REGS && !TARGET_64BIT && (MODE) == QImode\t\t\\\n    ? Q_REGS : NO_REGS)\n \n@@ -1519,11 +1532,14 @@ enum reg_class\n    We do this in the new i386 backend to maintain source compatibility\n    with the old cc0-based compiler.  */\n \n-#define MD_ASM_CLOBBERS(CLOBBERS)\t\t\t\t\t      \\\n-  do {\t\t\t\t\t\t\t\t\t      \\\n-    (CLOBBERS) = tree_cons (NULL_TREE, build_string (5, \"flags\"), (CLOBBERS));\\\n-    (CLOBBERS) = tree_cons (NULL_TREE, build_string (4, \"fpsr\"), (CLOBBERS)); \\\n-    (CLOBBERS) = tree_cons (NULL_TREE, build_string (7, \"dirflag\"), (CLOBBERS)); \\\n+#define MD_ASM_CLOBBERS(CLOBBERS)\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    (CLOBBERS) = tree_cons (NULL_TREE, build_string (5, \"flags\"),\t\\\n+\t\t\t    (CLOBBERS));\t\t\t\t\\\n+    (CLOBBERS) = tree_cons (NULL_TREE, build_string (4, \"fpsr\"),\t\\\n+\t\t\t    (CLOBBERS));\t\t\t\t\\\n+    (CLOBBERS) = tree_cons (NULL_TREE, build_string (7, \"dirflag\"),\t\\\n+\t\t\t    (CLOBBERS));\t\t\t\t\\\n   } while (0)\n \f\n /* Stack layout; function entry, exit and calling.  */\n@@ -1590,16 +1606,17 @@ enum reg_class\n    definition that is usually appropriate, refer to expr.h for additional\n    documentation. If `REG_PARM_STACK_SPACE' is defined, the argument will be\n    computed in the stack and then loaded into a register.  */\n-#define MUST_PASS_IN_STACK(MODE,TYPE)\t\t\t\\\n-  ((TYPE) != 0\t\t\t\t\t\t\\\n-   && (TREE_CODE (TYPE_SIZE (TYPE)) != INTEGER_CST\t\\\n-       || TREE_ADDRESSABLE (TYPE)\t\t\t\\\n-       || ((MODE) == TImode)\t\t\t\t\\\n-       || ((MODE) == BLKmode \t\t\t\t\\\n-\t   && ! ((TYPE) != 0 && TREE_CODE (TYPE_SIZE (TYPE)) == INTEGER_CST \\\n-\t\t && 0 == (int_size_in_bytes (TYPE)\t\\\n-\t\t\t  % (PARM_BOUNDARY / BITS_PER_UNIT))) \\\n-\t   && (FUNCTION_ARG_PADDING (MODE, TYPE)\t\\\n+#define MUST_PASS_IN_STACK(MODE, TYPE)\t\t\t\t\\\n+  ((TYPE) != 0\t\t\t\t\t\t\t\\\n+   && (TREE_CODE (TYPE_SIZE (TYPE)) != INTEGER_CST\t\t\\\n+       || TREE_ADDRESSABLE (TYPE)\t\t\t\t\\\n+       || ((MODE) == TImode)\t\t\t\t\t\\\n+       || ((MODE) == BLKmode \t\t\t\t\t\\\n+\t   && ! ((TYPE) != 0\t\t\t\t\t\\\n+\t\t && TREE_CODE (TYPE_SIZE (TYPE)) == INTEGER_CST \\\n+\t\t && 0 == (int_size_in_bytes (TYPE)\t\t\\\n+\t\t\t  % (PARM_BOUNDARY / BITS_PER_UNIT)))\t\\\n+\t   && (FUNCTION_ARG_PADDING (MODE, TYPE)\t\t\\\n \t       == (BYTES_BIG_ENDIAN ? upward : downward)))))\n \n /* Value is the number of bytes of arguments automatically\n@@ -1619,8 +1636,8 @@ enum reg_class\n \n    The attribute stdcall is equivalent to RTD on a per module basis.  */\n \n-#define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE) \\\n-  (ix86_return_pops_args (FUNDECL, FUNTYPE, SIZE))\n+#define RETURN_POPS_ARGS(FUNDECL, FUNTYPE, SIZE) \\\n+  ix86_return_pops_args ((FUNDECL), (FUNTYPE), (SIZE))\n \n /* Define how to find the value returned by a function.\n    VALTYPE is the data type of the value (as a tree).\n@@ -1667,15 +1684,15 @@ typedef struct ix86_args {\n    for a call to a function whose data type is FNTYPE.\n    For a library call, FNTYPE is 0.  */\n \n-#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME,INDIRECT)\t\\\n-  (init_cumulative_args (&CUM, FNTYPE, LIBNAME))\n+#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, INDIRECT) \\\n+  init_cumulative_args (&(CUM), (FNTYPE), (LIBNAME))\n \n /* Update the data in CUM to advance over an argument\n    of mode MODE and data type TYPE.\n    (TYPE is null for libcalls where that information may not be available.)  */\n \n-#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n-  (function_arg_advance (&CUM, MODE, TYPE, NAMED))\n+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED) \\\n+  function_arg_advance (&(CUM), (MODE), (TYPE), (NAMED))\n \n /* Define where to put the arguments to a function.\n    Value is zero to push the argument on the stack,\n@@ -1691,7 +1708,7 @@ typedef struct ix86_args {\n     (otherwise it is an extra parameter matching an ellipsis).  */\n \n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n-  (function_arg (&CUM, MODE, TYPE, NAMED))\n+  function_arg (&(CUM), (MODE), (TYPE), (NAMED))\n \n /* For an arg passed partly in registers and partly in memory,\n    this is the number of registers used.\n@@ -1704,11 +1721,11 @@ typedef struct ix86_args {\n    If we are returning floats on the register stack, we cannot make\n    sibling calls to functions that return floats.  (The stack adjust\n    instruction will wind up after the sibcall jump, and not be executed.) */\n-#define FUNCTION_OK_FOR_SIBCALL(DECL) \\\n-  (DECL \\\n-   && (! flag_pic || ! TREE_PUBLIC (DECL)) \\\n-   && (! TARGET_FLOAT_RETURNS_IN_80387 \\\n-       || ! FLOAT_MODE_P (TYPE_MODE (TREE_TYPE (TREE_TYPE (DECL)))) \\\n+#define FUNCTION_OK_FOR_SIBCALL(DECL)\t\t\t\t\t\\\n+  ((DECL)\t\t\t\t\t\t\t\t\\\n+   && (! flag_pic || ! TREE_PUBLIC (DECL))\t\t\t\t\\\n+   && (! TARGET_FLOAT_RETURNS_IN_80387\t\t\t\t\t\\\n+       || ! FLOAT_MODE_P (TYPE_MODE (TREE_TYPE (TREE_TYPE (DECL))))\t\\\n        || FLOAT_MODE_P (TYPE_MODE (TREE_TYPE (TREE_TYPE (cfun->decl))))))\n \n /* Perform any needed actions needed for a function that is receiving a\n@@ -1725,20 +1742,21 @@ typedef struct ix86_args {\n    Normally, this macro will push all remaining incoming registers on the\n    stack and set PRETEND_SIZE to the length of the registers pushed.  */\n \n-#define SETUP_INCOMING_VARARGS(CUM,MODE,TYPE,PRETEND_SIZE,NO_RTL) \\\n-  ix86_setup_incoming_varargs (&CUM, MODE, TYPE, &PRETEND_SIZE, NO_RTL)\n+#define SETUP_INCOMING_VARARGS(CUM, MODE, TYPE, PRETEND_SIZE, NO_RTL)\t\\\n+  ix86_setup_incoming_varargs (&(CUM), (MODE), (TYPE), &(PRETEND_SIZE), \\\n+\t\t\t       (NO_RTL))\n \n /* Define the `__builtin_va_list' type for the ABI.  */\n #define BUILD_VA_LIST_TYPE(VALIST) \\\n-  (VALIST) = ix86_build_va_list ()\n+  ((VALIST) = ix86_build_va_list ())\n \n /* Implement `va_start' for varargs and stdarg.  */\n-#define EXPAND_BUILTIN_VA_START(stdarg, valist, nextarg) \\\n-  ix86_va_start (stdarg, valist, nextarg)\n+#define EXPAND_BUILTIN_VA_START(STDARG, VALIST, NEXTARG) \\\n+  ix86_va_start ((STDARG), (VALIST), (NEXTARG))\n \n /* Implement `va_arg'.  */\n-#define EXPAND_BUILTIN_VA_ARG(valist, type) \\\n-  ix86_va_arg (valist, type)\n+#define EXPAND_BUILTIN_VA_ARG(VALIST, TYPE) \\\n+  ix86_va_arg ((VALIST), (TYPE))\n \n /* This macro is invoked at the end of compilation.  It is used here to\n    output code for -fpic that will load the return address into %ebx.  */\n@@ -1749,20 +1767,20 @@ typedef struct ix86_args {\n /* Output assembler code to FILE to increment profiler label # LABELNO\n    for profiling a function entry.  */\n \n-#define FUNCTION_PROFILER(FILE, LABELNO)  \\\n-{\t\t\t\t\t\t\t\t\t\\\n+#define FUNCTION_PROFILER(FILE, LABELNO)\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n   if (flag_pic)\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\tleal\\t%sP%d@GOTOFF(%%ebx),%%edx\\n\",\t\t\\\n+      fprintf ((FILE), \"\\tleal\\t%sP%d@GOTOFF(%%ebx),%%edx\\n\",\t\t\\\n \t       LPREFIX, (LABELNO));\t\t\t\t\t\\\n-      fprintf (FILE, \"\\tcall\\t*_mcount@GOT(%%ebx)\\n\");\t\t\t\\\n+      fprintf ((FILE), \"\\tcall\\t*_mcount@GOT(%%ebx)\\n\");\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n   else\t\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\tmovl\\t$%sP%d,%%edx\\n\", LPREFIX, (LABELNO));\t\\\n-      fprintf (FILE, \"\\tcall\\t_mcount\\n\");\t\t\t\t\\\n+      fprintf ((FILE), \"\\tmovl\\t$%sP%d,%%edx\\n\", LPREFIX, (LABELNO));\t\\\n+      fprintf ((FILE), \"\\tcall\\t_mcount\\n\");\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n-}\n+} while (0)\n \n /* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n    the stack pointer does not matter.  The value is tested only in\n@@ -1792,8 +1810,8 @@ typedef struct ix86_args {\n    FNADDR is an RTX for the address of the function's pure code.\n    CXT is an RTX for the static chain value for the function.  */\n \n-#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t\\\n-   x86_initialize_trampoline (TRAMP, FNADDR, CXT)\n+#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT) \\\n+  x86_initialize_trampoline ((TRAMP), (FNADDR), (CXT))\n \f\n /* Definitions for register eliminations.\n \n@@ -1825,8 +1843,8 @@ typedef struct ix86_args {\n /* Define the offset between two registers, one to be eliminated, and the other\n    its replacement, at the start of a routine.  */\n \n-#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t\t\t\\\n-  (OFFSET) = ix86_initial_elimination_offset (FROM, TO)\n+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) \\\n+  ((OFFSET) = ix86_initial_elimination_offset ((FROM), (TO)))\n \f\n /* Addressing modes, and classification of registers for them.  */\n \n@@ -1848,22 +1866,24 @@ typedef struct ix86_args {\n   ((REGNO) < STACK_POINTER_REGNUM \t\t\t\t\t\\\n    || (REGNO >= FIRST_REX_INT_REG\t\t\t\t\t\\\n        && (REGNO) <= LAST_REX_INT_REG)\t\t\t\t\t\\\n-   || ((unsigned) reg_renumber[REGNO] >= FIRST_REX_INT_REG\t\t\\\n-       && (unsigned) reg_renumber[REGNO] <= LAST_REX_INT_REG)\t\t\\\n-   || (unsigned) reg_renumber[REGNO] < STACK_POINTER_REGNUM)\n+   || ((unsigned) reg_renumber[(REGNO)] >= FIRST_REX_INT_REG\t\t\\\n+       && (unsigned) reg_renumber[(REGNO)] <= LAST_REX_INT_REG)\t\t\\\n+   || (unsigned) reg_renumber[(REGNO)] < STACK_POINTER_REGNUM)\n \n #define REGNO_OK_FOR_BASE_P(REGNO) \t\t\t\t\t\\\n   ((REGNO) <= STACK_POINTER_REGNUM \t\t\t\t\t\\\n    || (REGNO) == ARG_POINTER_REGNUM \t\t\t\t\t\\\n    || (REGNO) == FRAME_POINTER_REGNUM \t\t\t\t\t\\\n    || (REGNO >= FIRST_REX_INT_REG\t\t\t\t\t\\\n        && (REGNO) <= LAST_REX_INT_REG)\t\t\t\t\t\\\n-   || ((unsigned) reg_renumber[REGNO] >= FIRST_REX_INT_REG\t\t\\\n-       && (unsigned) reg_renumber[REGNO] <= LAST_REX_INT_REG)\t\t\\\n-   || (unsigned) reg_renumber[REGNO] <= STACK_POINTER_REGNUM)\n+   || ((unsigned) reg_renumber[(REGNO)] >= FIRST_REX_INT_REG\t\t\\\n+       && (unsigned) reg_renumber[(REGNO)] <= LAST_REX_INT_REG)\t\t\\\n+   || (unsigned) reg_renumber[(REGNO)] <= STACK_POINTER_REGNUM)\n \n-#define REGNO_OK_FOR_SIREG_P(REGNO) ((REGNO) == 4 || reg_renumber[REGNO] == 4)\n-#define REGNO_OK_FOR_DIREG_P(REGNO) ((REGNO) == 5 || reg_renumber[REGNO] == 5)\n+#define REGNO_OK_FOR_SIREG_P(REGNO) \\\n+  ((REGNO) == 4 || reg_renumber[(REGNO)] == 4)\n+#define REGNO_OK_FOR_DIREG_P(REGNO) \\\n+  ((REGNO) == 5 || reg_renumber[(REGNO)] == 5)\n \n /* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n    and check its validity for a certain class.\n@@ -1899,12 +1919,12 @@ typedef struct ix86_args {\n #define REG_OK_FOR_BASE_STRICT_P(X)  REGNO_OK_FOR_BASE_P (REGNO (X))\n \n #ifndef REG_OK_STRICT\n-#define REG_OK_FOR_INDEX_P(X)  REG_OK_FOR_INDEX_NONSTRICT_P(X)\n-#define REG_OK_FOR_BASE_P(X)   REG_OK_FOR_BASE_NONSTRICT_P(X)\n+#define REG_OK_FOR_INDEX_P(X)  REG_OK_FOR_INDEX_NONSTRICT_P (X)\n+#define REG_OK_FOR_BASE_P(X)   REG_OK_FOR_BASE_NONSTRICT_P (X)\n \n #else\n-#define REG_OK_FOR_INDEX_P(X)  REG_OK_FOR_INDEX_STRICT_P(X)\n-#define REG_OK_FOR_BASE_P(X)   REG_OK_FOR_BASE_STRICT_P(X)\n+#define REG_OK_FOR_INDEX_P(X)  REG_OK_FOR_INDEX_STRICT_P (X)\n+#define REG_OK_FOR_BASE_P(X)   REG_OK_FOR_BASE_STRICT_P (X)\n #endif\n \n /* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n@@ -1932,17 +1952,17 @@ typedef struct ix86_args {\n \n #ifdef REG_OK_STRICT\n #define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  if (legitimate_address_p (MODE, X, 1))\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  if (legitimate_address_p ((MODE), (X), 1))\t\t\t\t\\\n     goto ADDR;\t\t\t\t\t\t\t\t\\\n-}\n+} while (0)\n \n #else\n #define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  if (legitimate_address_p (MODE, X, 0))\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  if (legitimate_address_p ((MODE), (X), 0))\t\t\t\t\\\n     goto ADDR;\t\t\t\t\t\t\t\t\\\n-}\n+} while (0)\n \n #endif\n \n@@ -1955,7 +1975,7 @@ typedef struct ix86_args {\n    The typical use of this macro is to handle addresses containing\n    a label_ref or symbol_ref within an UNSPEC.  */\n \n-#define FIND_BASE_TERM(X) ix86_find_base_term (x)\n+#define FIND_BASE_TERM(X) ix86_find_base_term (X)\n \n /* Try machine-dependent ways of modifying an illegitimate address\n    to be legitimate.  If we find one, return the new, valid address.\n@@ -1979,13 +1999,13 @@ typedef struct ix86_args {\n    See comments by legitimize_pic_address in i386.c for details.  */\n \n #define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  (X) = legitimize_address (X, OLDX, MODE);\t\t\t\t\\\n-  if (memory_address_p (MODE, X))\t\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  (X) = legitimize_address ((X), (OLDX), (MODE));\t\t\t\\\n+  if (memory_address_p ((MODE), (X)))\t\t\t\t\t\\\n     goto WIN;\t\t\t\t\t\t\t\t\\\n-}\n+} while (0)\n \n-#define REWRITE_ADDRESS(x) rewrite_address(x)\n+#define REWRITE_ADDRESS(X) rewrite_address (X)\n \n /* Nonzero if the constant value X is a legitimate general operand\n    when generating PIC code.  It is given that flag_pic is on and \n@@ -1996,16 +2016,20 @@ typedef struct ix86_args {\n    || legitimate_pic_address_disp_p (X))\n \n #define SYMBOLIC_CONST(X)\t\\\n-(GET_CODE (X) == SYMBOL_REF\t\t\t\t\t\t\\\n- || GET_CODE (X) == LABEL_REF\t\t\t\t\t\t\\\n- || (GET_CODE (X) == CONST && symbolic_reference_mentioned_p (X)))\n+  (GET_CODE (X) == SYMBOL_REF\t\t\t\t\t\t\\\n+   || GET_CODE (X) == LABEL_REF\t\t\t\t\t\t\\\n+   || (GET_CODE (X) == CONST && symbolic_reference_mentioned_p (X)))\n \n /* Go to LABEL if ADDR (a legitimate address expression)\n    has an effect that depends on the machine mode it is used for.\n    On the 80386, only postdecrement and postincrement address depend thus\n    (the amount of decrement or increment being the length of the operand).  */\n-#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)\t\\\n- if (GET_CODE (ADDR) == POST_INC || GET_CODE (ADDR) == POST_DEC) goto LABEL\n+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR, LABEL)\t\\\n+do {\t\t\t\t\t\t\t\\\n+ if (GET_CODE (ADDR) == POST_INC\t\t\t\\\n+     || GET_CODE (ADDR) == POST_DEC)\t\t\t\\\n+   goto LABEL;\t\t\t\t\t\t\\\n+} while (0)\n \f\n /* Codes for all the SSE/MMX builtins.  */\n enum ix86_builtins\n@@ -2248,8 +2272,7 @@ enum ix86_builtins\n    so that we may access it directly in the GOT.  */\n \n #define ENCODE_SECTION_INFO(DECL)\t\t\t\t\\\n-do\t\t\t\t\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\\\n     if (flag_pic)\t\t\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\\\n \trtx rtl = (TREE_CODE_CLASS (TREE_CODE (DECL)) != 'd'\t\\\n@@ -2270,8 +2293,7 @@ do\t\t\t\t\t\t\t\t\\\n \t\t || ! TREE_PUBLIC (DECL));\t\t\t\\\n \t  }\t\t\t\t\t\t\t\\\n       }\t\t\t\t\t\t\t\t\\\n-  }\t\t\t\t\t\t\t\t\\\n-while (0)\n+} while (0)\n \n /* The `FINALIZE_PIC' macro serves as a hook to emit these special\n    codes once the function is being compiled into assembly code, but\n@@ -2280,12 +2302,8 @@ while (0)\n    prologues being included in functions which used inline functions\n    and were compiled to assembly language.)  */\n \n-#define FINALIZE_PIC\t\t\t\t\t\t\t\\\n-do\t\t\t\t\t\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\t\\\n-    current_function_uses_pic_offset_table |= current_function_profile; \\\n-  }\t\t\t\t\t\t\t\t\t\\\n-while (0)\n+#define FINALIZE_PIC \\\n+  (current_function_uses_pic_offset_table |= current_function_profile)\n \n \f\n /* Max number of args passed in registers.  If this is more than 3, we will\n@@ -2373,9 +2391,11 @@ while (0)\n    quantities to SImode.  The choice depends on target type.  */\n \n #define PROMOTE_MODE(MODE, UNSIGNEDP, TYPE) \t\t\\\n+do {\t\t\t\t\t\t\t\\\n   if (((MODE) == HImode && TARGET_PROMOTE_HI_REGS)\t\\\n       || ((MODE) == QImode && TARGET_PROMOTE_QI_REGS))\t\\\n-    (MODE) = SImode;\n+    (MODE) = SImode;\t\t\t\t\t\\\n+} while (0)\n \n /* Specify the machine mode that pointers have.\n    After generation of rtl, the compiler makes no further distinction\n@@ -2400,7 +2420,7 @@ while (0)\n    CODE is the expression code--redundant, since it can be obtained\n    with `GET_CODE (X)'.  */\n \n-#define CONST_COSTS(RTX,CODE,OUTER_CODE) \\\n+#define CONST_COSTS(RTX, CODE, OUTER_CODE)\t\t\t\\\n   case CONST_INT:\t\t\t\t\t\t\\\n   case CONST:\t\t\t\t\t\t\t\\\n   case LABEL_REF:\t\t\t\t\t\t\\\n@@ -2437,7 +2457,7 @@ while (0)\n    This macro is optional; do not define it if the default cost\n    assumptions are adequate for the target machine.  */\n \n-#define RTX_COSTS(X,CODE,OUTER_CODE)\t\t\t\t\t\\\n+#define RTX_COSTS(X, CODE, OUTER_CODE)\t\t\t\t\t\\\n   case ZERO_EXTEND:\t\t\t\t\t\t\t\\\n     /* The zero extensions is often completely free on x86_64, so make\t\\\n        it as cheap as possible.  */\t\t\t\t\t\\\n@@ -2536,9 +2556,11 @@ while (0)\n \t    if (val == 2 || val == 4 || val == 8)\t\t\t\\\n \t      {\t\t\t\t\t\t\t\t\\\n \t\treturn (COSTS_N_INSNS (ix86_cost->lea)\t\t\t\\\n-\t\t\t+ rtx_cost (XEXP (XEXP (X, 0), 1), OUTER_CODE)\t\\\n-\t\t\t+ rtx_cost (XEXP (XEXP (XEXP (X, 0), 0), 0), OUTER_CODE) \\\n-\t\t\t+ rtx_cost (XEXP (X, 1), OUTER_CODE));\t\t\\\n+\t\t\t+ rtx_cost (XEXP (XEXP (X, 0), 1),\t\t\\\n+\t\t\t\t    (OUTER_CODE))\t\t\t\\\n+\t\t\t+ rtx_cost (XEXP (XEXP (XEXP (X, 0), 0), 0),\t\\\n+\t\t\t\t    (OUTER_CODE))\t\t\t\\\n+\t\t\t+ rtx_cost (XEXP (X, 1), (OUTER_CODE)));\t\\\n \t      }\t\t\t\t\t\t\t\t\\\n \t  }\t\t\t\t\t\t\t\t\\\n \telse if (GET_CODE (XEXP (X, 0)) == MULT\t\t\t\t\\\n@@ -2548,16 +2570,17 @@ while (0)\n \t    if (val == 2 || val == 4 || val == 8)\t\t\t\\\n \t      {\t\t\t\t\t\t\t\t\\\n \t\treturn (COSTS_N_INSNS (ix86_cost->lea)\t\t\t\\\n-\t\t\t+ rtx_cost (XEXP (XEXP (X, 0), 0), OUTER_CODE)\t\\\n-\t\t\t+ rtx_cost (XEXP (X, 1), OUTER_CODE));\t\t\\\n+\t\t\t+ rtx_cost (XEXP (XEXP (X, 0), 0),\t\t\\\n+\t\t\t\t    (OUTER_CODE))\t\t\t\\\n+\t\t\t+ rtx_cost (XEXP (X, 1), (OUTER_CODE)));\t\\\n \t      }\t\t\t\t\t\t\t\t\\\n \t  }\t\t\t\t\t\t\t\t\\\n \telse if (GET_CODE (XEXP (X, 0)) == PLUS)\t\t\t\\\n \t  {\t\t\t\t\t\t\t\t\\\n \t    return (COSTS_N_INSNS (ix86_cost->lea)\t\t\t\\\n-\t\t    + rtx_cost (XEXP (XEXP (X, 0), 0), OUTER_CODE)\t\\\n-\t\t    + rtx_cost (XEXP (XEXP (X, 0), 1), OUTER_CODE)\t\\\n-\t\t    + rtx_cost (XEXP (X, 1), OUTER_CODE));\t\t\\\n+\t\t    + rtx_cost (XEXP (XEXP (X, 0), 0), (OUTER_CODE))\t\\\n+\t\t    + rtx_cost (XEXP (XEXP (X, 0), 1), (OUTER_CODE))\t\\\n+\t\t    + rtx_cost (XEXP (X, 1), (OUTER_CODE)));\t\t\\\n \t  }\t\t\t\t\t\t\t\t\\\n       }\t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n@@ -2568,9 +2591,9 @@ while (0)\n   case MINUS:\t\t\t\t\t\t\t\t\\\n     if (!TARGET_64BIT && GET_MODE (X) == DImode)\t\t\t\\\n       return (COSTS_N_INSNS (ix86_cost->add) * 2\t\t\t\\\n-\t      + (rtx_cost (XEXP (X, 0), OUTER_CODE)\t\t\t\\\n+\t      + (rtx_cost (XEXP (X, 0), (OUTER_CODE))\t\t\t\\\n \t         << (GET_MODE (XEXP (X, 0)) != DImode))\t\t\t\\\n-\t      + (rtx_cost (XEXP (X, 1), OUTER_CODE)\t\t\t\\\n+\t      + (rtx_cost (XEXP (X, 1), (OUTER_CODE))\t\t\t\\\n  \t         << (GET_MODE (XEXP (X, 1)) != DImode)));\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n     /* fall through */\t\t\t\t\t\t\t\\\n@@ -2643,7 +2666,7 @@ while (0)\n    general registers.  */\n \n #define REGISTER_MOVE_COST(MODE, CLASS1, CLASS2) \\\n-   ix86_register_move_cost (MODE, CLASS1, CLASS2)\n+   ix86_register_move_cost ((MODE), (CLASS1), (CLASS2))\n \n /* A C expression for the cost of moving data of mode M between a\n    register and memory.  A value of 2 is the default; this cost is\n@@ -2653,8 +2676,8 @@ while (0)\n    between two registers, you should define this macro to express the\n    relative cost.  */\n \n-#define MEMORY_MOVE_COST(MODE,CLASS,IN)\t\\\n-  ix86_memory_move_cost (MODE, CLASS, IN)\n+#define MEMORY_MOVE_COST(MODE, CLASS, IN)\t\\\n+  ix86_memory_move_cost ((MODE), (CLASS), (IN))\n \n /* A C expression for the cost of a branch instruction.  A value of 1\n    is the default; other values are interpreted relative to that.  */\n@@ -2747,13 +2770,13 @@ while (0)\n \n    Add CCZ to indicate that only the Zero flag is valid.  */\n \n-#define EXTRA_CC_MODES \\\n-\tCC(CCGCmode, \"CCGC\") \\\n-\tCC(CCGOCmode, \"CCGOC\") \\\n-\tCC(CCNOmode, \"CCNO\") \\\n-\tCC(CCZmode, \"CCZ\") \\\n-\tCC(CCFPmode, \"CCFP\") \\\n-\tCC(CCFPUmode, \"CCFPU\")\n+#define EXTRA_CC_MODES\t\t\\\n+\tCC (CCGCmode, \"CCGC\")\t\\\n+\tCC (CCGOCmode, \"CCGOC\")\t\\\n+\tCC (CCNOmode, \"CCNO\")\t\\\n+\tCC (CCZmode, \"CCZ\")\t\\\n+\tCC (CCFPmode, \"CCFP\")\t\\\n+\tCC (CCFPUmode, \"CCFPU\")\n \n /* Given a comparison code (EQ, NE, etc.) and the first operand of a COMPARE,\n    return the mode to be used for the comparison.\n@@ -2764,7 +2787,7 @@ while (0)\n    For integer comparisons against zero, reduce to CCNOmode or CCZmode if\n    possible, to allow for more combinations.  */\n \n-#define SELECT_CC_MODE(OP,X,Y) ix86_cc_mode (OP, X, Y)\n+#define SELECT_CC_MODE(OP, X, Y) ix86_cc_mode ((OP), (X), (Y))\n \n /* Return non-zero if MODE implies a floating point inequality can be\n    reversed.  */\n@@ -2830,8 +2853,8 @@ number as al, and ax.\n \n /* How to renumber registers for dbx and gdb.  */\n \n-#define DBX_REGISTER_NUMBER(n) \\\n-  (TARGET_64BIT ? dbx64_register_map[n] : dbx_register_map[n])\n+#define DBX_REGISTER_NUMBER(N) \\\n+  (TARGET_64BIT ? dbx64_register_map[(N)] : dbx_register_map[(N)])\n \n extern int const dbx_register_map[FIRST_PSEUDO_REGISTER];\n extern int const dbx64_register_map[FIRST_PSEUDO_REGISTER];\n@@ -2866,16 +2889,16 @@ extern int const svr4_dbx_register_map[FIRST_PSEUDO_REGISTER];\n    After all, the relocation needed is the same as for the call insn.\n    Whether or not a particular assembler allows us to enter such, I\n    guess we'll have to see.  */\n-#define ASM_PREFERRED_EH_DATA_FORMAT(CODE,GLOBAL)       \t\t\\\n+#define ASM_PREFERRED_EH_DATA_FORMAT(CODE, GLOBAL)       \t\t\\\n   (flag_pic\t\t\t\t\t\t\t\t\\\n-    ? (GLOBAL ? DW_EH_PE_indirect : 0) | DW_EH_PE_pcrel | DW_EH_PE_sdata4\\\n+    ? ((GLOBAL) ? DW_EH_PE_indirect : 0) | DW_EH_PE_pcrel | DW_EH_PE_sdata4\\\n    : DW_EH_PE_absptr)\n \n /* This is how to output the definition of a user-level label named NAME,\n    such as the label on a static function or variable NAME.  */\n \n-#define ASM_OUTPUT_LABEL(FILE,NAME)\t\\\n-  (assemble_name (FILE, NAME), fputs (\":\\n\", FILE))\n+#define ASM_OUTPUT_LABEL(FILE, NAME)\t\\\n+  (assemble_name ((FILE), (NAME)), fputs (\":\\n\", (FILE)))\n \n /* Store in OUTPUT a string (made with alloca) containing\n    an assembler-name for a local static variable named NAME.\n@@ -2888,24 +2911,24 @@ extern int const svr4_dbx_register_map[FIRST_PSEUDO_REGISTER];\n /* This is how to output an insn to push a register on the stack.\n    It need not be very fast code.  */\n \n-#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)  \\\n-  asm_fprintf (FILE, \"\\tpush{l}\\t%%e%s\\n\", reg_names[REGNO])\n+#define ASM_OUTPUT_REG_PUSH(FILE, REGNO)  \\\n+  asm_fprintf ((FILE), \"\\tpush{l}\\t%%e%s\\n\", reg_names[(REGNO)])\n \n /* This is how to output an insn to pop a register from the stack.\n    It need not be very fast code.  */\n \n-#define ASM_OUTPUT_REG_POP(FILE,REGNO)  \\\n-  asm_fprintf (FILE, \"\\tpop{l}\\t%%e%s\\n\", reg_names[REGNO])\n+#define ASM_OUTPUT_REG_POP(FILE, REGNO)  \\\n+  asm_fprintf ((FILE), \"\\tpop{l}\\t%%e%s\\n\", reg_names[(REGNO)])\n \n /* This is how to output an element of a case-vector that is absolute.  */\n \n #define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n-  ix86_output_addr_vec_elt (FILE, VALUE)\n+  ix86_output_addr_vec_elt ((FILE), (VALUE))\n \n /* This is how to output an element of a case-vector that is relative.  */\n \n #define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \\\n-  ix86_output_addr_diff_elt (FILE, VALUE, REL)\n+  ix86_output_addr_diff_elt ((FILE), (VALUE), (REL))\n \n /* Under some conditions we need jump tables in the text section, because\n    the assembler cannot handle label differences between sections.  */\n@@ -2916,20 +2939,20 @@ extern int const svr4_dbx_register_map[FIRST_PSEUDO_REGISTER];\n /* A C statement that outputs an address constant appropriate to \n    for DWARF debugging.  */\n \n-#define ASM_OUTPUT_DWARF_ADDR_CONST(FILE,X) \\\n-  i386_dwarf_output_addr_const((FILE),(X))\n+#define ASM_OUTPUT_DWARF_ADDR_CONST(FILE, X) \\\n+  i386_dwarf_output_addr_const ((FILE), (X))\n \n /* Either simplify a location expression, or return the original.  */\n \n #define ASM_SIMPLIFY_DWARF_ADDR(X) \\\n-  i386_simplify_dwarf_addr(X)\n+  i386_simplify_dwarf_addr (X)\n \f\n /* Print operand X (an rtx) in assembler syntax to file FILE.\n    CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n    Effect of various CODE letters is described in i386.c near\n    print_operand function.  */\n \n-#define PRINT_OPERAND_PUNCT_VALID_P(CODE)\t\t\t\t\\\n+#define PRINT_OPERAND_PUNCT_VALID_P(CODE) \\\n   ((CODE) == '*' || (CODE) == '+')\n \n /* Print the name of a register based on its machine mode and number.\n@@ -2941,13 +2964,13 @@ extern int const svr4_dbx_register_map[FIRST_PSEUDO_REGISTER];\n    If CODE is 'y', print \"st(0)\" instead of \"st\", if the reg is stack op.  */\n \n #define PRINT_REG(X, CODE, FILE)  \\\n-  print_reg (X, CODE, FILE)\n+  print_reg ((X), (CODE), (FILE))\n \n #define PRINT_OPERAND(FILE, X, CODE)  \\\n-  print_operand (FILE, X, CODE)\n+  print_operand ((FILE), (X), (CODE))\n \n #define PRINT_OPERAND_ADDRESS(FILE, ADDR)  \\\n-  print_operand_address (FILE, ADDR)\n+  print_operand_address ((FILE), (ADDR))\n \n /* Print the name of a register for based on its machine mode and number.\n    This macro is used to print debugging output.\n@@ -2957,40 +2980,40 @@ extern int const svr4_dbx_register_map[FIRST_PSEUDO_REGISTER];\n #define DEBUG_PRINT_REG(X, CODE, FILE)\t\t\t\\\n   do { static const char * const hi_name[] = HI_REGISTER_NAMES;\t\\\n        static const char * const qi_name[] = QI_REGISTER_NAMES;\t\\\n-       fprintf (FILE, \"%d \", REGNO (X));\t\t\\\n+       fprintf ((FILE), \"%d \", REGNO (X));\t\t\\\n        if (REGNO (X) == FLAGS_REG)\t\t\t\\\n-\t { fputs (\"flags\", FILE); break; }\t\t\\\n+\t { fputs (\"flags\", (FILE)); break; }\t\t\\\n        if (REGNO (X) == DIRFLAG_REG)\t\t\t\\\n-\t { fputs (\"dirflag\", FILE); break; }\t\t\\\n+\t { fputs (\"dirflag\", (FILE)); break; }\t\t\\\n        if (REGNO (X) == FPSR_REG)\t\t\t\\\n-\t { fputs (\"fpsr\", FILE); break; }\t\t\\\n+\t { fputs (\"fpsr\", (FILE)); break; }\t\t\\\n        if (REGNO (X) == ARG_POINTER_REGNUM)\t\t\\\n-\t { fputs (\"argp\", FILE); break; }\t\t\\\n+\t { fputs (\"argp\", (FILE)); break; }\t\t\\\n        if (REGNO (X) == FRAME_POINTER_REGNUM)\t\t\\\n-\t { fputs (\"frame\", FILE); break; }\t\t\\\n+\t { fputs (\"frame\", (FILE)); break; }\t\t\\\n        if (STACK_TOP_P (X))\t\t\t\t\\\n-\t { fputs (\"st(0)\", FILE); break; }\t\t\\\n+\t { fputs (\"st(0)\", (FILE)); break; }\t\t\\\n        if (FP_REG_P (X))\t\t\t\t\\\n-\t { fputs (hi_name[REGNO(X)], FILE); break; }\t\\\n+\t { fputs (hi_name[REGNO(X)], (FILE)); break; }\t\\\n        if (REX_INT_REG_P (X))\t\t\t\t\\\n \t {\t\t\t\t\t\t\\\n \t   switch (GET_MODE_SIZE (GET_MODE (X)))\t\\\n \t     {\t\t\t\t\t\t\\\n \t     default:\t\t\t\t\t\\\n \t     case 8:\t\t\t\t\t\\\n-\t       fprintf (FILE, \"r%i\", REGNO (X)\t\t\\\n+\t       fprintf ((FILE), \"r%i\", REGNO (X)\t\\\n \t\t\t- FIRST_REX_INT_REG + 8);\t\\\n \t       break;\t\t\t\t\t\\\n \t     case 4:\t\t\t\t\t\\\n-\t       fprintf (FILE, \"r%id\", REGNO (X)\t\t\\\n+\t       fprintf ((FILE), \"r%id\", REGNO (X)\t\\\n \t\t\t- FIRST_REX_INT_REG + 8);\t\\\n \t       break;\t\t\t\t\t\\\n \t     case 2:\t\t\t\t\t\\\n-\t       fprintf (FILE, \"r%iw\", REGNO (X)\t\t\\\n+\t       fprintf ((FILE), \"r%iw\", REGNO (X)\t\\\n \t\t\t- FIRST_REX_INT_REG + 8);\t\\\n \t       break;\t\t\t\t\t\\\n \t     case 1:\t\t\t\t\t\\\n-\t       fprintf (FILE, \"r%ib\", REGNO (X)\t\t\\\n+\t       fprintf ((FILE), \"r%ib\", REGNO (X)\t\\\n \t\t\t- FIRST_REX_INT_REG + 8);\t\\\n \t       break;\t\t\t\t\t\\\n \t     }\t\t\t\t\t\t\\\n@@ -2999,16 +3022,16 @@ extern int const svr4_dbx_register_map[FIRST_PSEUDO_REGISTER];\n        switch (GET_MODE_SIZE (GET_MODE (X)))\t\t\\\n \t {\t\t\t\t\t\t\\\n \t case 8:\t\t\t\t\t\\\n-\t   fputs (\"r\", FILE);\t\t\t\t\\\n-\t   fputs (hi_name[REGNO (X)], FILE);\t\t\\\n+\t   fputs (\"r\", (FILE));\t\t\t\t\\\n+\t   fputs (hi_name[REGNO (X)], (FILE));\t\t\\\n \t   break;\t\t\t\t\t\\\n \t default:\t\t\t\t\t\\\n-\t   fputs (\"e\", FILE);\t\t\t\t\\\n+\t   fputs (\"e\", (FILE));\t\t\t\t\\\n \t case 2:\t\t\t\t\t\\\n-\t   fputs (hi_name[REGNO (X)], FILE);\t\t\\\n+\t   fputs (hi_name[REGNO (X)], (FILE));\t\t\\\n \t   break;\t\t\t\t\t\\\n \t case 1:\t\t\t\t\t\\\n-\t   fputs (qi_name[REGNO (X)], FILE);\t\t\\\n+\t   fputs (qi_name[REGNO (X)], (FILE));\t\t\\\n \t   break;\t\t\t\t\t\\\n \t }\t\t\t\t\t\t\\\n      } while (0)\n@@ -3018,7 +3041,7 @@ extern int const svr4_dbx_register_map[FIRST_PSEUDO_REGISTER];\n \n #define ASM_OPERAND_LETTER '#'\n #define RET return \"\"\n-#define AT_SP(mode) (gen_rtx_MEM ((mode), stack_pointer_rtx))\n+#define AT_SP(MODE) (gen_rtx_MEM ((MODE), stack_pointer_rtx))\n \f\n /* Define the codes that are matched by predicates in i386.c.  */\n \n@@ -3137,8 +3160,8 @@ extern int ix86_regparm;\t\t\t/* ix86_regparm_string as a number */\n extern int ix86_preferred_stack_boundary;\t/* preferred stack boundary alignment in bits */\n extern int ix86_branch_cost;\t\t\t/* values 1-5: see jump.c */\n extern enum reg_class const regclass_map[FIRST_PSEUDO_REGISTER]; /* smalled class containing REGNO */\n-extern struct rtx_def *ix86_compare_op0;\t/* operand 0 for comparisons */\n-extern struct rtx_def *ix86_compare_op1;\t/* operand 1 for comparisons */\n+extern rtx ix86_compare_op0;\t/* operand 0 for comparisons */\n+extern rtx ix86_compare_op1;\t/* operand 1 for comparisons */\n \f\n /* To properly truncate FP values into integers, we need to set i387 control\n    word.  We can't emit proper mode switching code before reload, as spills\n@@ -3190,14 +3213,14 @@ enum fp_cw_mode {FP_CW_STORED, FP_CW_UNINITIALIZED, FP_CW_ANY};\n /* This macro specifies the order in which modes for ENTITY are\n    processed.  0 is the highest priority.  */\n \n-#define MODE_PRIORITY_TO_MODE(ENTITY, N) N\n+#define MODE_PRIORITY_TO_MODE(ENTITY, N) (N)\n \n /* Generate one or more insns to set ENTITY to MODE.  HARD_REG_LIVE\n    is the set of hard registers live at the point where the insn(s)\n    are to be inserted.  */\n \n #define EMIT_MODE_SET(ENTITY, MODE, HARD_REGS_LIVE) \t\t\t\\\n-  (MODE == FP_CW_STORED\t\t\t\t\t\t\t\\\n+  ((MODE) == FP_CW_STORED\t\t\t\t\t\t\\\n    ? emit_i387_cw_initialization (assign_386_stack_local (HImode, 1),\t\\\n \t\t\t\t  assign_386_stack_local (HImode, 2)), 0\\\n    : 0)\n@@ -3208,8 +3231,8 @@ enum fp_cw_mode {FP_CW_STORED, FP_CW_UNINITIALIZED, FP_CW_ANY};\n \n    ??? Maybe Pentium chips benefits from renaming, someone can try...  */\n \n-#define HARD_REGNO_RENAME_OK(src,target)  \\\n-   ((src) < FIRST_STACK_REG || (src) > LAST_STACK_REG)\n+#define HARD_REGNO_RENAME_OK(SRC, TARGET)  \\\n+   ((SRC) < FIRST_STACK_REG || (SRC) > LAST_STACK_REG)\n \n \f\n /*"}]}