{"sha": "1ea7e6ad84d890cc6d002e9e698055de85a28cfd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWVhN2U2YWQ4NGQ4OTBjYzZkMDAyZTllNjk4MDU1ZGU4NWEyOGNmZA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2004-05-30T07:12:58Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2004-05-30T07:12:58Z"}, "message": "c-common.c, [...]: Fix comment typos.\n\n\t* c-common.c, calls.c, cfgcleanup.c, cgraph.c, cgraphunit.c,\n\tddg.c, ddg.h, df.c, df.h, except.c, expr.c, flags.h,\n\tfold-const.c, gcc.c, gimplify.c, haifa-sched.c,\n\tmodulo-sched.c, tree-inline.c, tree-into-ssa.c, tree-nested.c,\n\ttree-nrv.c, tree-ssa-ccp.c, tree-ssa-dom.c, tree-ssa-live.c,\n\ttree-ssa-loop.c, tree-ssa-pre.c, tree-tailcall.c, tree.h: Fix\n\tcomment typos.  Follow spelling conventions.\n\nFrom-SVN: r82439", "tree": {"sha": "353029a3fd14257b6028935077f92705d8a886d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/353029a3fd14257b6028935077f92705d8a886d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1ea7e6ad84d890cc6d002e9e698055de85a28cfd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ea7e6ad84d890cc6d002e9e698055de85a28cfd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ea7e6ad84d890cc6d002e9e698055de85a28cfd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ea7e6ad84d890cc6d002e9e698055de85a28cfd/comments", "author": null, "committer": null, "parents": [{"sha": "b453c95fd3fa689a6d70e8878848e5d6531e9ac5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b453c95fd3fa689a6d70e8878848e5d6531e9ac5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b453c95fd3fa689a6d70e8878848e5d6531e9ac5"}], "stats": {"total": 124, "additions": 67, "deletions": 57}, "files": [{"sha": "79149e498d69c951de93bcc1bb40b752317175fe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea7e6ad84d890cc6d002e9e698055de85a28cfd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea7e6ad84d890cc6d002e9e698055de85a28cfd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1ea7e6ad84d890cc6d002e9e698055de85a28cfd", "patch": "@@ -1,3 +1,13 @@\n+2004-05-30  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* c-common.c, calls.c, cfgcleanup.c, cgraph.c, cgraphunit.c,\n+\tddg.c, ddg.h, df.c, df.h, except.c, expr.c, flags.h,\n+\tfold-const.c, gcc.c, gimplify.c, haifa-sched.c,\n+\tmodulo-sched.c, tree-inline.c, tree-into-ssa.c, tree-nested.c,\n+\ttree-nrv.c, tree-ssa-ccp.c, tree-ssa-dom.c, tree-ssa-live.c,\n+\ttree-ssa-loop.c, tree-ssa-pre.c, tree-tailcall.c, tree.h: Fix\n+\tcomment typos.  Follow spelling conventions.\n+\n 2004-05-29  Geoffrey Keating  <geoffk@apple.com>\n \n \t* gengtype-yacc.y: Add NESTED_PTR token."}, {"sha": "ef5af12bb98365ec1643bd50ea5b6646daab1f2e", "filename": "gcc/c-common.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea7e6ad84d890cc6d002e9e698055de85a28cfd/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea7e6ad84d890cc6d002e9e698055de85a28cfd/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=1ea7e6ad84d890cc6d002e9e698055de85a28cfd", "patch": "@@ -4215,7 +4215,7 @@ finish_label_address_expr (tree label)\n \n /* Hook used by expand_expr to expand language-specific tree codes.  */\n /* The only things that should go here are bits needed to expand \n-   constant initalizers.  Everything else should be handled by the\n+   constant initializers.  Everything else should be handled by the\n    gimplification routines.  */\n \n rtx"}, {"sha": "f5969feceb063b3ff585e2c7ead74faba2ce7d7c", "filename": "gcc/calls.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea7e6ad84d890cc6d002e9e698055de85a28cfd/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea7e6ad84d890cc6d002e9e698055de85a28cfd/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=1ea7e6ad84d890cc6d002e9e698055de85a28cfd", "patch": "@@ -3313,7 +3313,7 @@ expand_call (tree exp, rtx target, int ignore)\n \tbreak;\n     }\n \n-  /* If tail call production suceeded, we need to remove REG_EQUIV notes on\n+  /* If tail call production succeeded, we need to remove REG_EQUIV notes on\n      arguments too, as argument area is now clobbered by the call.  */\n   if (tail_call_insns)\n     {"}, {"sha": "af45527afbd6a5207dc3361e01c3b0bfb4543901", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea7e6ad84d890cc6d002e9e698055de85a28cfd/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea7e6ad84d890cc6d002e9e698055de85a28cfd/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=1ea7e6ad84d890cc6d002e9e698055de85a28cfd", "patch": "@@ -19,7 +19,7 @@ along with GCC; see the file COPYING.  If not, write to the Free\n Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n 02111-1307, USA.  */\n \n-/* This file contains optimizer of the control flow.  The main entrypoint is\n+/* This file contains optimizer of the control flow.  The main entry point is\n    cleanup_cfg.  Following optimizations are performed:\n \n    - Unreachable blocks removal"}, {"sha": "9f00f609deef7a37f68048ee005e41f3e9c38d68", "filename": "gcc/cgraph.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea7e6ad84d890cc6d002e9e698055de85a28cfd/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea7e6ad84d890cc6d002e9e698055de85a28cfd/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=1ea7e6ad84d890cc6d002e9e698055de85a28cfd", "patch": "@@ -61,7 +61,7 @@ The callgraph:\n       The function inlining information is decided in advance and maintained\n       in the callgraph as so called inline plan.\n       For each inlined call, the callee's node is cloned to represent the\n-      new function copy produced by inlininer.\n+      new function copy produced by inliner.\n       Each inlined call gets a unique corresponding clone node of the callee\n       and the data structure is updated while inlining is performed, so\n       the clones are eliminated and their callee edges redirected to the"}, {"sha": "cb21556ff443619991b7178c03313a5a3a86ade9", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea7e6ad84d890cc6d002e9e698055de85a28cfd/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea7e6ad84d890cc6d002e9e698055de85a28cfd/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=1ea7e6ad84d890cc6d002e9e698055de85a28cfd", "patch": "@@ -1020,7 +1020,7 @@ cgraph_estimate_growth (struct cgraph_node *node)\n \n /* E is expected to be an edge being inlined.  Clone destination node of\n    the edge and redirect it to the new clone.\n-   DUPLICATE is used for bookeeping on whether we are actually creating new\n+   DUPLICATE is used for bookkeeping on whether we are actually creating new\n    clones or re-using node originally representing out-of-line function call.\n    */\n void\n@@ -1191,7 +1191,7 @@ cgraph_recursive_inlining_p (struct cgraph_node *to,\n     recursive = what->decl == to->global.inlined_to->decl;\n   else\n     recursive = what->decl == to->decl;\n-  /* Marking recursive function inlinine has sane semantic and thus we should\n+  /* Marking recursive function inline has sane semantic and thus we should\n      not warn on it.  */\n   if (recursive && reason)\n     *reason = (what->local.disregard_inline_limits"}, {"sha": "377ad99d502d88ba53e66776cee3e40e56af83a9", "filename": "gcc/ddg.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea7e6ad84d890cc6d002e9e698055de85a28cfd/gcc%2Fddg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea7e6ad84d890cc6d002e9e698055de85a28cfd/gcc%2Fddg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fddg.c?ref=1ea7e6ad84d890cc6d002e9e698055de85a28cfd", "patch": "@@ -80,7 +80,7 @@ mark_mem_use_1 (rtx *x, void *data)\n   for_each_rtx (x, mark_mem_use, data);\n }\n \n-/* Returns non-zero if INSN reads from memory.  */\n+/* Returns nonzero if INSN reads from memory.  */\n static bool\n mem_read_insn_p (rtx insn)\n {\n@@ -96,7 +96,7 @@ mark_mem_store (rtx loc, rtx setter ATTRIBUTE_UNUSED, void *data ATTRIBUTE_UNUSE\n     mem_ref_p = true;\n }\n \n-/* Returns non-zero if INSN writes to memory.  */\n+/* Returns nonzero if INSN writes to memory.  */\n static bool\n mem_write_insn_p (rtx insn)\n {\n@@ -105,7 +105,7 @@ mem_write_insn_p (rtx insn)\n   return mem_ref_p;\n }\n \n-/* Returns non-zero if X has access to memory.  */\n+/* Returns nonzero if X has access to memory.  */\n static bool\n rtx_mem_access_p (rtx x)\n {\n@@ -138,7 +138,7 @@ rtx_mem_access_p (rtx x)\n   return false;\n }\n \n-/* Returns non-zero if INSN reads to or writes from memory.  */\n+/* Returns nonzero if INSN reads to or writes from memory.  */\n static bool\n mem_access_insn_p (rtx insn)\n {\n@@ -383,7 +383,7 @@ build_intra_loop_deps (ddg_ptr g)\n   get_block_head_tail (g->bb->index, &head, &tail);\n   sched_analyze (&tmp_deps, head, tail);\n \n-  /* Build intra-loop data dependecies using the schedular dependecy\n+  /* Build intra-loop data dependecies using the scheduler dependecy\n      analysis.  */\n   for (i = 0; i < g->num_nodes; i++)\n     {\n@@ -980,7 +980,7 @@ find_nodes_on_paths (sbitmap result, ddg_ptr g, sbitmap from, sbitmap to)\n /* Updates the counts of U_NODE's successors (that belong to NODES) to be\n    at-least as large as the count of U_NODE plus the latency between them.\n    Sets a bit in TMP for each successor whose count was changed (increased).\n-   Returns non-zero if any count was changed.  */\n+   Returns nonzero if any count was changed.  */\n static int\n update_dist_to_successors (ddg_node_ptr u_node, sbitmap nodes, sbitmap tmp)\n {"}, {"sha": "c2358039f13c2b2ef42db636d5a0421021a1a161", "filename": "gcc/ddg.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea7e6ad84d890cc6d002e9e698055de85a28cfd/gcc%2Fddg.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea7e6ad84d890cc6d002e9e698055de85a28cfd/gcc%2Fddg.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fddg.h?ref=1ea7e6ad84d890cc6d002e9e698055de85a28cfd", "patch": "@@ -51,10 +51,10 @@ struct ddg_node\n   /* The insn represented by the node.  */\n   rtx insn;\n \n-  /* A note preceeding INSN (or INSN itself), such that all insns linked\n+  /* A note preceding INSN (or INSN itself), such that all insns linked\n      from FIRST_NOTE until INSN (inclusive of both) are moved together\n      when reordering the insns.  This takes care of notes that should\n-     continue to preceed INSN.  */\n+     continue to precede INSN.  */\n   rtx first_note;\n \n   /* Incoming and outgoing dependency edges.  */"}, {"sha": "48a7151a0cd1192b0e9eb6801b13dd52d9e6a9ba", "filename": "gcc/df.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea7e6ad84d890cc6d002e9e698055de85a28cfd/gcc%2Fdf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea7e6ad84d890cc6d002e9e698055de85a28cfd/gcc%2Fdf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.c?ref=1ea7e6ad84d890cc6d002e9e698055de85a28cfd", "patch": "@@ -55,7 +55,7 @@ Here's an example of using the dataflow routines.\n \n df_init simply creates a poor man's object (df) that needs to be\n passed to all the dataflow routines.  df_finish destroys this\n-object and frees up any allocated memory.   DF_ALL says to analyse\n+object and frees up any allocated memory.   DF_ALL says to analyze\n everything.\n \n df_analyze performs the following:"}, {"sha": "fb5f9148eecd19f48ab77621e4e97b6608c26940", "filename": "gcc/df.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea7e6ad84d890cc6d002e9e698055de85a28cfd/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea7e6ad84d890cc6d002e9e698055de85a28cfd/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=1ea7e6ad84d890cc6d002e9e698055de85a28cfd", "patch": "@@ -229,7 +229,7 @@ struct df_map\n #define DF_INSN_USES(DF, INSN) ((DF)->insns[INSN_UID (INSN)].uses)\n \n \n-/* Functions to build and analyse dataflow information.  */\n+/* Functions to build and analyze dataflow information.  */\n \n extern struct df *df_init (void);\n "}, {"sha": "e3116952ff3ffd23c4a0ebfd118d7ededea6387e", "filename": "gcc/except.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea7e6ad84d890cc6d002e9e698055de85a28cfd/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea7e6ad84d890cc6d002e9e698055de85a28cfd/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=1ea7e6ad84d890cc6d002e9e698055de85a28cfd", "patch": "@@ -1187,7 +1187,7 @@ remove_unreachable_regions (rtx insns)\n \n \t    case ERT_MUST_NOT_THROW:\n \t      /* MUST_NOT_THROW regions are implementable solely in the\n-\t\t runtime, but their existance continues to affect calls\n+\t\t runtime, but their existence continues to affect calls\n \t\t within that region.  Never delete them here.  */\n \t      kill_it = false;\n \t      break;"}, {"sha": "a9e7eb9a384339a09f30177dd320dbf6d025219d", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea7e6ad84d890cc6d002e9e698055de85a28cfd/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea7e6ad84d890cc6d002e9e698055de85a28cfd/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=1ea7e6ad84d890cc6d002e9e698055de85a28cfd", "patch": "@@ -4387,7 +4387,7 @@ store_expr (tree exp, rtx target, int want_value)\n     return target;\n }\n \f\n-/* Examine CTOR.  Discover how many scalar fields are set to non-zero\n+/* Examine CTOR.  Discover how many scalar fields are set to nonzero\n    values and place it in *P_NZ_ELTS.  Discover how many scalar fields\n    are set to non-constant values and place it in  *P_NC_ELTS.  */\n "}, {"sha": "e5d3cd1f74ccaaa5ece25349d523584e9f131d78", "filename": "gcc/flags.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea7e6ad84d890cc6d002e9e698055de85a28cfd/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea7e6ad84d890cc6d002e9e698055de85a28cfd/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=1ea7e6ad84d890cc6d002e9e698055de85a28cfd", "patch": "@@ -424,7 +424,7 @@ extern int flag_gen_aux_info;\n \n extern int flag_shared_data;\n \n-/* Controls the activiation of SMS modulo scheduling. */\n+/* Controls the activation of SMS modulo scheduling. */\n extern int flag_modulo_sched;\n \n /* flag_schedule_insns means schedule insns within basic blocks (before"}, {"sha": "743f4ae47ee7da4beae41db465d4ddc9d082e9e0", "filename": "gcc/fold-const.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea7e6ad84d890cc6d002e9e698055de85a28cfd/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea7e6ad84d890cc6d002e9e698055de85a28cfd/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=1ea7e6ad84d890cc6d002e9e698055de85a28cfd", "patch": "@@ -2319,7 +2319,7 @@ truth_value_p (enum tree_code code)\n \f\n /* Return nonzero if two operands (typically of the same tree node)\n    are necessarily equal.  If either argument has side-effects this\n-   function returns zero.  FLAGS modifies behaviour as follows:\n+   function returns zero.  FLAGS modifies behavior as follows:\n \n    If OEP_ONLY_CONST is set, only return nonzero for constants.\n    This function tests whether the operands are indistinguishable;\n@@ -5243,7 +5243,7 @@ fold_inf_compare (enum tree_code code, tree type, tree arg0, tree arg1)\n }\n \n /* Subroutine of fold() that optimizes comparisons of a division by\n-   a non-zero integer constant against an integer constant, i.e.\n+   a nonzero integer constant against an integer constant, i.e.\n    X/C1 op C2.\n \n    CODE is the comparison operator: EQ_EXPR, NE_EXPR, GT_EXPR, LT_EXPR,"}, {"sha": "4e8f8cff4c89b2ad9dc33162722e8d576ac85b1f", "filename": "gcc/gcc.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea7e6ad84d890cc6d002e9e698055de85a28cfd/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea7e6ad84d890cc6d002e9e698055de85a28cfd/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=1ea7e6ad84d890cc6d002e9e698055de85a28cfd", "patch": "@@ -887,9 +887,9 @@ struct compiler\n   const char *cpp_spec;         /* If non-NULL, substitute this spec\n \t\t\t\t   for `%C', rather than the usual\n \t\t\t\t   cpp_spec.  */\n-  const int combinable;          /* If non-zero, compiler can deal with\n+  const int combinable;          /* If nonzero, compiler can deal with\n \t\t\t\t    multiple source files at once (IMA).  */\n-  const int needs_preprocessing; /* If non-zero, source files need to\n+  const int needs_preprocessing; /* If nonzero, source files need to\n \t\t\t\t    be run through a preprocessor.  */\n };\n "}, {"sha": "173ae28b29b4956d05fc7c0390a8350822f270a1", "filename": "gcc/gimplify.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea7e6ad84d890cc6d002e9e698055de85a28cfd/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea7e6ad84d890cc6d002e9e698055de85a28cfd/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=1ea7e6ad84d890cc6d002e9e698055de85a28cfd", "patch": "@@ -282,7 +282,7 @@ create_artificial_label (void)\n   return lab;\n }\n \n-/* Create a new temporary name with PREFIX.  Returns an indentifier.  */\n+/* Create a new temporary name with PREFIX.  Returns an identifier.  */\n \n static GTY(()) unsigned int tmp_var_id_num;\n \n@@ -797,7 +797,7 @@ voidify_wrapper_expr (tree wrapper)\n }\n \n /* Prepare calls to builtins to SAVE and RESTORE the stack as well as\n-   temporary through that they comunicate.  */\n+   a temporary through which they communicate.  */\n \n static void\n build_stack_save_restore (tree *save, tree *restore)\n@@ -1310,7 +1310,7 @@ gimplify_init_constructor (tree *expr_p, tree *pre_p,\n \t/* ??? This bit ought not be needed.  For any element not present\n \t   in the initializer, we should simply set them to zero.  Except\n \t   we'd need to *find* the elements that are not present, and that\n-\t   requires trickery to avoid quadratic compile-time behaviour in\n+\t   requires trickery to avoid quadratic compile-time behavior in\n \t   large cases or excessive memory use in small cases.  */\n \telse\n \t  {\n@@ -2600,7 +2600,7 @@ gimplify_compound_expr (tree *expr_p, tree *pre_p, bool want_value)\n }\n \n /* Gimplifies a statement list.  These may be created either by an\n-   enlightend front-end, or by shortcut_cond_expr.  */\n+   enlightened front-end, or by shortcut_cond_expr.  */\n \n static enum gimplify_status\n gimplify_statement_list (tree *expr_p)"}, {"sha": "af8b8a7015719a49f5664f63648c7a7240f3e6a9", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea7e6ad84d890cc6d002e9e698055de85a28cfd/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea7e6ad84d890cc6d002e9e698055de85a28cfd/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=1ea7e6ad84d890cc6d002e9e698055de85a28cfd", "patch": "@@ -259,7 +259,7 @@ static rtx note_list;\n    description interface, MAX_INSN_QUEUE_INDEX is a power of two minus\n    one which is larger than maximal time of instruction execution\n    computed by genattr.c on the base maximal time of functional unit\n-   reservations and geting a result.  This is the longest time an\n+   reservations and getting a result.  This is the longest time an\n    insn may be queued.  */\n \n #define MAX_INSN_QUEUE_INDEX max_insn_queue_index_macro_value"}, {"sha": "a9822e26d9056d0cbcd238d67408c9d47997e3d3", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea7e6ad84d890cc6d002e9e698055de85a28cfd/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea7e6ad84d890cc6d002e9e698055de85a28cfd/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=1ea7e6ad84d890cc6d002e9e698055de85a28cfd", "patch": "@@ -57,7 +57,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n        IEEE Trans. on Comps., 50(3), March 2001\n    [2] J. Llosa, A. Gonzalez, E. Ayguade, and M. Valero.\n        Swing Modulo Scheduling: A Lifetime Sensitive Approach.\n-       PACT '96 , pages 80-87, October 1996 (Boston - Massachussets - USA).\n+       PACT '96 , pages 80-87, October 1996 (Boston - Massachusetts - USA).\n \n    The basic structure is:\n    1. Build a data-dependence graph (DDG) for each loop.\n@@ -156,7 +156,7 @@ void rotate_partial_schedule (partial_schedule_ptr, int);\n void set_row_column_for_ps (partial_schedule_ptr);\n \n \f\n-/* This page defines constants and structures for the modulo scheduiing\n+/* This page defines constants and structures for the modulo scheduling\n    driver.  */\n \n /* As in haifa-sched.c:  */\n@@ -202,15 +202,15 @@ typedef struct node_sched_params\n      original register defined by the node.  */\n   rtx first_reg_move;\n \n-  /* The number of register-move instructions added, immediately preceeding\n+  /* The number of register-move instructions added, immediately preceding\n      first_reg_move.  */\n   int nreg_moves;\n \n   int row;    /* Holds time % ii.  */\n   int stage;  /* Holds time / ii.  */\n \n   /* The column of a node inside the ps.  If nodes u, v are on the same row,\n-     u will preceed v if column (u) < column (v).  */\n+     u will precede v if column (u) < column (v).  */\n   int column;\n } *node_sched_params_ptr;\n \n@@ -472,7 +472,7 @@ generate_reg_moves (partial_schedule_ptr ps)\n \t  {\n \t    int nreg_moves4e = (SCHED_TIME (e->dest) - SCHED_TIME (e->src)) / ii;\n \n-\t    /* If dest preceeds src in the schedule of the kernel, then dest\n+\t    /* If dest precedes src in the schedule of the kernel, then dest\n \t       will read before src writes and we can save one reg_copy.  */\n \t    if (SCHED_ROW (e->dest) == SCHED_ROW (e->src)\n \t\t&& SCHED_COLUMN (e->dest) < SCHED_COLUMN (e->src))\n@@ -605,7 +605,7 @@ duplicate_insns_of_cycles (partial_schedule_ptr ps, int from_stage,\n \tif (for_prolog)\n \t  {\n \t    /* SCHED_STAGE (u_node) >= from_stage == 0.  Generate increasing\n-\t       number of reg_moves starting with the second occurance of\n+\t       number of reg_moves starting with the second occurrence of\n \t       u_node, which is generated if its SCHED_STAGE <= to_stage.  */\n \t    i_reg_moves = to_stage - SCHED_STAGE (u_node);\n \t    i_reg_moves = MAX (i_reg_moves, 0);"}, {"sha": "58a1c07e072cfdbc10e30d09442f590f777ed3fd", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea7e6ad84d890cc6d002e9e698055de85a28cfd/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea7e6ad84d890cc6d002e9e698055de85a28cfd/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=1ea7e6ad84d890cc6d002e9e698055de85a28cfd", "patch": "@@ -1343,7 +1343,7 @@ estimate_num_insns_1 (tree *tp, int *walk_subtrees, void *data)\n       *count++;\n       break;\n \n-    /* Few special cases of expensive operations.  This is usefull\n+    /* Few special cases of expensive operations.  This is useful\n        to avoid inlining on functions having too many of these.  */\n     case TRUNC_DIV_EXPR:\n     case CEIL_DIV_EXPR:"}, {"sha": "7bb9c58f04686fb0a480de1ea0bea9886a07642b", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea7e6ad84d890cc6d002e9e698055de85a28cfd/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea7e6ad84d890cc6d002e9e698055de85a28cfd/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=1ea7e6ad84d890cc6d002e9e698055de85a28cfd", "patch": "@@ -473,7 +473,7 @@ rewrite_initialize_block_local_data (struct dom_walk_data *walk_data ATTRIBUTE_U\n                                                                                 \n   /* We get cleared memory from the allocator, so if the memory is\n      not cleared, then we are re-using a previously allocated entry.  In\n-     that case, we can also re-use the underlying virtal arrays.  Just\n+     that case, we can also re-use the underlying virtual arrays.  Just\n      make sure we clear them before using them!  */\n   if (recycled && bd->block_defs && VARRAY_ACTIVE_SIZE (bd->block_defs) > 0)\n     abort ();"}, {"sha": "24d3e74b74691ae95897cb8c1abcd1e3517c428f", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea7e6ad84d890cc6d002e9e698055de85a28cfd/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea7e6ad84d890cc6d002e9e698055de85a28cfd/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=1ea7e6ad84d890cc6d002e9e698055de85a28cfd", "patch": "@@ -474,7 +474,7 @@ get_nl_goto_field (struct nesting_info *info)\n \n       /* For __builtin_nonlocal_goto, we need N words.  The first is the\n \t frame pointer, the rest is for the target's stack pointer save\n-\t area.  The number of words is controled by STACK_SAVEAREA_MODE;\n+\t area.  The number of words is controlled by STACK_SAVEAREA_MODE;\n \t not the best interface, but it'll do for now.  */\n       if (Pmode == ptr_mode)\n \ttype = ptr_type_node;\n@@ -987,7 +987,7 @@ convert_nl_goto_reference (tree *tp, int *walk_subtrees, void *data)\n   /* The original user label may also be use for a normal goto, therefore\n      we must create a new label that will actually receive the abnormal\n      control transfer.  This new label will be marked LABEL_NONLOCAL; this\n-     mark will trigger proper behaviour in the cfg, as well as cause the\n+     mark will trigger proper behavior in the cfg, as well as cause the\n      (hairy target-specific) non-local goto receiver code to be generated\n      when we expand rtl.  */\n   new_label = create_artificial_label ();\n@@ -1316,7 +1316,7 @@ finalize_nesting_tree_1 (struct nesting_info *root)\n       sf->has_nonlocal_label = 1;\n     }\n \n-  /* Make sure all new local variables get insertted into the\n+  /* Make sure all new local variables get inserted into the\n      proper BIND_EXPR.  */\n   if (root->new_local_var_chain)\n     declare_tmp_vars (root->new_local_var_chain,"}, {"sha": "1768b3909b9092e621dbe12ecd88fe24ff8c0e97", "filename": "gcc/tree-nrv.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea7e6ad84d890cc6d002e9e698055de85a28cfd/gcc%2Ftree-nrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea7e6ad84d890cc6d002e9e698055de85a28cfd/gcc%2Ftree-nrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nrv.c?ref=1ea7e6ad84d890cc6d002e9e698055de85a28cfd", "patch": "@@ -54,7 +54,7 @@ struct nrv_data\n      this function's RETURN_EXPR statements.  */\n   tree var;\n \n-  /* This is the function's RESULT_DECL.  We will replace all occurences\n+  /* This is the function's RESULT_DECL.  We will replace all occurrences\n      of VAR with RESULT_DECL when we apply this optimization.  */\n   tree result;\n };\n@@ -84,7 +84,7 @@ finalize_nrv_r (tree *tp, int *walk_subtrees, void *data)\n      to RESULT.  */\n   else if (TREE_CODE (*tp) == RETURN_EXPR)\n     TREE_OPERAND (*tp, 0) = dp->result;\n-  /* Replace all occurences of VAR with RESULT.  */\n+  /* Replace all occurrences of VAR with RESULT.  */\n   else if (*tp == dp->var)\n     *tp = dp->result;\n "}, {"sha": "5b6d21e51391e5415c2a94848defbb0a99ef2a90", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea7e6ad84d890cc6d002e9e698055de85a28cfd/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea7e6ad84d890cc6d002e9e698055de85a28cfd/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=1ea7e6ad84d890cc6d002e9e698055de85a28cfd", "patch": "@@ -1578,7 +1578,7 @@ maybe_fold_offset_to_component_ref (tree record_type, tree base, tree offset,\n \n  found:\n   /* If we get here, we've got an aggregate field, and a possibly \n-     non-zero offset into them.  Recurse and hope for a valid match.  */\n+     nonzero offset into them.  Recurse and hope for a valid match.  */\n   if (base_is_ptr)\n     base = build1 (INDIRECT_REF, record_type, base);\n   base = build (COMPONENT_REF, field_type, base, f);"}, {"sha": "c74dd5d532553b860124bfe92398da2bc743fc0c", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea7e6ad84d890cc6d002e9e698055de85a28cfd/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea7e6ad84d890cc6d002e9e698055de85a28cfd/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=1ea7e6ad84d890cc6d002e9e698055de85a28cfd", "patch": "@@ -642,7 +642,7 @@ tree_ssa_dominator_optimize (void)\n   /* We emptyed the hash table earlier, now delete it completely.  */\n   htab_delete (avail_exprs);\n \n-  /* It is not nocessary to clear CURRDEFS, REDIRECTION_EDGES, VRP_DATA,\n+  /* It is not necessary to clear CURRDEFS, REDIRECTION_EDGES, VRP_DATA,\n      CONST_AND_COPIES, and NONZERO_VARS as they all get cleared at the bottom\n      of the do-while loop above.  */\n \n@@ -1076,7 +1076,7 @@ remove_local_expressions_from_table (varray_type locals,\n }\n \n /* Use the SSA_NAMES in LOCALS to restore TABLE to its original\n-   state, stopping when there are LIMIT entires left in LOCALs.  */\n+   state, stopping when there are LIMIT entries left in LOCALs.  */\n \n static void\n restore_nonzero_vars_to_original_value (varray_type locals,\n@@ -1095,7 +1095,7 @@ restore_nonzero_vars_to_original_value (varray_type locals,\n }\n \n /* Use the source/dest pairs in LOCALS to restore TABLE to its original\n-   state, stopping when there are LIMIT entires left in LOCALs.  */\n+   state, stopping when there are LIMIT entries left in LOCALs.  */\n \n static void\n restore_vars_to_original_value (varray_type locals,\n@@ -1365,7 +1365,7 @@ record_equivalences_from_phis (struct dom_walk_data *walk_data, basic_block bb)\n \t breaking out of the loop, then we have a PHI which may create\n \t a useful equivalence.  We do not need to record unwind data for\n \t this, since this is a true assignment and not an equivalence\n-\t infered from a comparison.  All uses of this ssa name are dominated\n+\t inferred from a comparison.  All uses of this ssa name are dominated\n \t by this assignment, so unwinding just costs time and space.  */\n       if (i == PHI_NUM_ARGS (phi)\n \t  && may_propagate_copy (lhs, rhs))\n@@ -1659,7 +1659,7 @@ record_equality (tree x, tree y, varray_type *block_const_and_copies_p)\n   /* For IEEE, -0.0 == 0.0, so we don't necessarily know the sign of a\n      variable compared against zero.  If we're honoring signed zeros,\n      then we cannot record this value unless we know that the value is\n-     non-zero.  */\n+     nonzero.  */\n   if (HONOR_SIGNED_ZEROS (TYPE_MODE (TREE_TYPE (x)))\n       && (TREE_CODE (y) != REAL_CST\n \t  || REAL_VALUES_EQUAL (dconst0, TREE_REAL_CST (y))))\n@@ -2405,7 +2405,7 @@ record_equivalences_from_stmt (tree stmt,\n       /* If the RHS of the assignment is a constant or another variable that\n \t may be propagated, register it in the CONST_AND_COPIES table.  We\n \t do not need to record unwind data for this, since this is a true\n-\t assignment and not an equivalence infered from a comparison.  All\n+\t assignment and not an equivalence inferred from a comparison.  All\n \t uses of this ssa name are dominated by this assignment, so unwinding\n \t just costs time and space.  */\n       if (may_optimize_p"}, {"sha": "38f4443de4d8852a855582876a5ca79ca875092c", "filename": "gcc/tree-ssa-live.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea7e6ad84d890cc6d002e9e698055de85a28cfd/gcc%2Ftree-ssa-live.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea7e6ad84d890cc6d002e9e698055de85a28cfd/gcc%2Ftree-ssa-live.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.c?ref=1ea7e6ad84d890cc6d002e9e698055de85a28cfd", "patch": "@@ -838,7 +838,7 @@ tpa_delete (tpa_p tpa)\n }\n \n \n-/* This function will remove any tree entires from TPA which have only a single\n+/* This function will remove any tree entries from TPA which have only a single\n    element.  This will help keep the size of the conflict graph down.  The \n    function returns the number of remaining tree lists.  */\n \n@@ -1419,7 +1419,7 @@ build_tree_conflict_graph (tree_live_info_p liveinfo, tpa_p tpa,\n       /* Anything which is still live at this point interferes.  \n \t In order to implement this efficiently, only conflicts between\n \t partitions which have the same TPA root need be added.\n-\t TPA roots which have been seen are tracked in 'tpa_nodes'.  A non-zero\n+\t TPA roots which have been seen are tracked in 'tpa_nodes'.  A nonzero\n \t entry points to an index into 'partition_link', which then indexes \n \t into itself forming a linked list of partitions sharing a tpa root \n \t which have been seen as live up to this point.  Since partitions start"}, {"sha": "58ee74623a0c6443be8b4428d63d3b85799dffaf", "filename": "gcc/tree-ssa-loop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea7e6ad84d890cc6d002e9e698055de85a28cfd/gcc%2Ftree-ssa-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea7e6ad84d890cc6d002e9e698055de85a28cfd/gcc%2Ftree-ssa-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop.c?ref=1ea7e6ad84d890cc6d002e9e698055de85a28cfd", "patch": "@@ -268,7 +268,7 @@ copy_loop_headers (void)\n \n   create_preheaders (loops, CP_SIMPLE_PREHEADERS);\n \n-  /* We do not try to keep the information about irreductible regions\n+  /* We do not try to keep the information about irreducible regions\n      up-to-date.  */\n   loops->state &= ~LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS;\n "}, {"sha": "5896953ca832055ed42aa3f7136fc117cf378694", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea7e6ad84d890cc6d002e9e698055de85a28cfd/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea7e6ad84d890cc6d002e9e698055de85a28cfd/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=1ea7e6ad84d890cc6d002e9e698055de85a28cfd", "patch": "@@ -1596,7 +1596,7 @@ process_delayed_rename (struct expr_info *ei, tree use, tree real_occ)\n /* For the uninitiated, the algorithm is a modified SSA renaming\n    algorithm (working on expressions rather than variables) .  We\n    attempt to determine which expression occurrences have the same\n-   ESSA version (we call it class, for equivalence/redunancy class,\n+   ESSA version (we call it class, for equivalence/redundancy class,\n    which is what the papers call it.  Open64 calls it e-version), and\n    which occurrences are actually operands for an EPHI (since this has\n    to be discovered from the program). \n@@ -2149,7 +2149,7 @@ insert_one_operand (struct expr_info *ei, tree ephi, int opnd_indx,\n \n /* First step of finalization.  Determine which expressions are being\n    saved and which are being deleted.\n-   This is done as a simple dominator based availabilty calculation,\n+   This is done as a simple dominator based availability calculation,\n    using the e-versions/redundancy classes.  */\n \n static bool"}, {"sha": "955394c89ec4f463a39307fa7c84d21447feb8d9", "filename": "gcc/tree-tailcall.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea7e6ad84d890cc6d002e9e698055de85a28cfd/gcc%2Ftree-tailcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea7e6ad84d890cc6d002e9e698055de85a28cfd/gcc%2Ftree-tailcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-tailcall.c?ref=1ea7e6ad84d890cc6d002e9e698055de85a28cfd", "patch": "@@ -37,7 +37,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"langhooks.h\"\n \n /* The file implements the tail recursion elimination.  It is also used to\n-   analyse the tail calls in general, passing the results to the rtl level\n+   analyze the tail calls in general, passing the results to the rtl level\n    where they are used for sibcall optimization.\n \n    In addition to the standard tail recursion elimination, we handle the most\n@@ -80,7 +80,7 @@ Boston, MA 02111-1307, USA.  */\n       We rewrite this to a gimple equivalent of return m_acc * x + a_acc.\n       \n    2) return f (...), where f is the current function, is rewritten in a\n-      clasical tail-recursion elimination way, into assignment of arguments\n+      classical tail-recursion elimination way, into assignment of arguments\n       and jump to the start of the function.  Values of the accumulators\n       are unchanged.\n \t       \n@@ -574,7 +574,7 @@ adjust_accumulator_values (block_stmt_iterator bsi, tree m, tree a, edge back)\n     }\n }\n \n-/* Adjust value of the return at the end of BB accodring to M and A\n+/* Adjust value of the return at the end of BB according to M and A\n    accumulators.  */\n \n static void"}, {"sha": "88223ca82c5a568b17a9c05d074f553fd8749129", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea7e6ad84d890cc6d002e9e698055de85a28cfd/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea7e6ad84d890cc6d002e9e698055de85a28cfd/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=1ea7e6ad84d890cc6d002e9e698055de85a28cfd", "patch": "@@ -1008,7 +1008,7 @@ struct tree_vec GTY(())\n \n /* Define fields and accessors for some nodes that represent expressions.  */\n \n-/* Non-zero if NODE is an emtpy statement (NOP_EXPR <0>).  */\n+/* Nonzero if NODE is an empty statement (NOP_EXPR <0>).  */\n #define IS_EMPTY_STMT(NODE)\t(TREE_CODE (NODE) == NOP_EXPR \\\n \t\t\t\t && VOID_TYPE_P (TREE_TYPE (NODE)) \\\n \t\t\t\t && integer_zerop (TREE_OPERAND (NODE, 0)))"}]}