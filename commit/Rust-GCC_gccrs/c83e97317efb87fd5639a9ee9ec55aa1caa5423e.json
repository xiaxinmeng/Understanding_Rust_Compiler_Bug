{"sha": "c83e97317efb87fd5639a9ee9ec55aa1caa5423e", "node_id": "C_kwDOANBUbNoAKGM4M2U5NzMxN2VmYjg3ZmQ1NjM5YTllZTllYzU1YWExY2FhNTQyM2U", "commit": {"author": {"name": "Tim Lange", "email": "mail@tim-lange.me", "date": "2022-08-18T09:36:08Z"}, "committer": {"name": "Tim Lange", "email": "mail@tim-lange.me", "date": "2022-08-18T14:41:56Z"}, "message": "analyzer: warn on the use of floating-points operands in the size argument [PR106181]\n\nThis patch fixes the ICE reported in PR106181 and adds a new warning to\nthe analyzer complaining about the use of floating-point operands.\n\nRegrtested on Linux x86_64.\n\n2022-08-17  Tim Lange  <mail@tim-lange.me>\n\ngcc/analyzer/ChangeLog:\n\n\tPR analyzer/106181\n\t* analyzer.opt: Add Wanalyzer-imprecise-floating-point-arithmetic.\n\t* region-model.cc (is_any_cast_p): Formatting.\n\t(region_model::check_region_size): Ensure precondition.\n\t(class imprecise_floating_point_arithmetic): New abstract\n\tdiagnostic class for all floating-point related warnings.\n\t(class float_as_size_arg): Concrete diagnostic class to complain\n\tabout floating-point operands inside the size argument.\n\t(class contains_floating_point_visitor):\n\tNew visitor to find floating-point operands inside svalues.\n\t(region_model::check_dynamic_size_for_floats): New function.\n\t(region_model::set_dynamic_extents):\n\tCall to check_dynamic_size_for_floats.\n\t* region-model.h (class region_model):\n\tAdd region_model::check_dynamic_size_for_floats.\n\ngcc/ChangeLog:\n\n\tPR analyzer/106181\n\t* doc/invoke.texi: Add Wanalyzer-imprecise-fp-arithmetic.\n\ngcc/testsuite/ChangeLog:\n\n\tPR analyzer/106181\n\t* gcc.dg/analyzer/allocation-size-1.c: New test.\n\t* gcc.dg/analyzer/imprecise-floating-point-1.c: New test.\n\t* gcc.dg/analyzer/pr106181.c: New test.", "tree": {"sha": "438c54d1f341f64f7397a25de6a919984f97df55", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/438c54d1f341f64f7397a25de6a919984f97df55"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c83e97317efb87fd5639a9ee9ec55aa1caa5423e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c83e97317efb87fd5639a9ee9ec55aa1caa5423e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c83e97317efb87fd5639a9ee9ec55aa1caa5423e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c83e97317efb87fd5639a9ee9ec55aa1caa5423e/comments", "author": {"login": "timll", "id": 10032775, "node_id": "MDQ6VXNlcjEwMDMyNzc1", "avatar_url": "https://avatars.githubusercontent.com/u/10032775?v=4", "gravatar_id": "", "url": "https://api.github.com/users/timll", "html_url": "https://github.com/timll", "followers_url": "https://api.github.com/users/timll/followers", "following_url": "https://api.github.com/users/timll/following{/other_user}", "gists_url": "https://api.github.com/users/timll/gists{/gist_id}", "starred_url": "https://api.github.com/users/timll/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/timll/subscriptions", "organizations_url": "https://api.github.com/users/timll/orgs", "repos_url": "https://api.github.com/users/timll/repos", "events_url": "https://api.github.com/users/timll/events{/privacy}", "received_events_url": "https://api.github.com/users/timll/received_events", "type": "User", "site_admin": false}, "committer": {"login": "timll", "id": 10032775, "node_id": "MDQ6VXNlcjEwMDMyNzc1", "avatar_url": "https://avatars.githubusercontent.com/u/10032775?v=4", "gravatar_id": "", "url": "https://api.github.com/users/timll", "html_url": "https://github.com/timll", "followers_url": "https://api.github.com/users/timll/followers", "following_url": "https://api.github.com/users/timll/following{/other_user}", "gists_url": "https://api.github.com/users/timll/gists{/gist_id}", "starred_url": "https://api.github.com/users/timll/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/timll/subscriptions", "organizations_url": "https://api.github.com/users/timll/orgs", "repos_url": "https://api.github.com/users/timll/repos", "events_url": "https://api.github.com/users/timll/events{/privacy}", "received_events_url": "https://api.github.com/users/timll/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "011d0a033ab370ea38b06b813ac62be8dde0801b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/011d0a033ab370ea38b06b813ac62be8dde0801b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/011d0a033ab370ea38b06b813ac62be8dde0801b"}], "stats": {"total": 294, "additions": 271, "deletions": 23}, "files": [{"sha": "437ea92e130af49786bffbd0898bf3840da3979f", "filename": "gcc/analyzer/analyzer.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c83e97317efb87fd5639a9ee9ec55aa1caa5423e/gcc%2Fanalyzer%2Fanalyzer.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c83e97317efb87fd5639a9ee9ec55aa1caa5423e/gcc%2Fanalyzer%2Fanalyzer.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer.opt?ref=c83e97317efb87fd5639a9ee9ec55aa1caa5423e", "patch": "@@ -98,6 +98,10 @@ Wanalyzer-free-of-non-heap\n Common Var(warn_analyzer_free_of_non_heap) Init(1) Warning\n Warn about code paths in which a non-heap pointer is freed.\n \n+Wanalyzer-imprecise-fp-arithmetic\n+Common Var(warn_analyzer_imprecise_fp_arithmetic) Init(1) Warning\n+Warn about code paths in which floating-point arithmetic is used in locations where precise computation is needed.\n+\n Wanalyzer-jump-through-null\n Common Var(warn_analyzer_jump_through_null) Init(1) Warning\n Warn about code paths in which a NULL function pointer is called."}, {"sha": "ec29be259b5e150d228fc281602b88629fadc535", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 156, "deletions": 23, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c83e97317efb87fd5639a9ee9ec55aa1caa5423e/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c83e97317efb87fd5639a9ee9ec55aa1caa5423e/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=c83e97317efb87fd5639a9ee9ec55aa1caa5423e", "patch": "@@ -3301,7 +3301,8 @@ class dubious_allocation_size\n     m.add_cwe (131);\n \n     return warning_meta (rich_loc, m, get_controlling_option (),\n-\t       \"allocated buffer size is not a multiple of the pointee's size\");\n+\t\t\t \"allocated buffer size is not a multiple\"\n+\t\t\t \" of the pointee's size\");\n   }\n \n   label_text\n@@ -3396,21 +3397,20 @@ capacity_compatible_with_type (tree cst, tree pointee_size_tree)\n class size_visitor : public visitor\n {\n public:\n-  size_visitor (tree size_cst, const svalue *sval, constraint_manager *cm)\n-  : m_size_cst (size_cst), m_sval (sval), m_cm (cm)\n+  size_visitor (tree size_cst, const svalue *root_sval, constraint_manager *cm)\n+  : m_size_cst (size_cst), m_root_sval (root_sval), m_cm (cm)\n   {\n-    sval->accept (this);\n+    m_root_sval->accept (this);\n   }\n \n   bool get_result ()\n   {\n-    return result_set.contains (m_sval);\n+    return result_set.contains (m_root_sval);\n   }\n \n   void visit_constant_svalue (const constant_svalue *sval) final override\n   {\n-    if (capacity_compatible_with_type (sval->get_constant (), m_size_cst))\n-      result_set.add (sval);\n+    check_constant (sval->get_constant (), sval);\n   }\n \n   void visit_unknown_svalue (const unknown_svalue *sval ATTRIBUTE_UNUSED)\n@@ -3478,15 +3478,10 @@ class size_visitor : public visitor\n     equiv_class_id id (-1);\n     if (m_cm->get_equiv_class_by_svalue (sval, &id))\n       {\n-\tif (tree cst_val = id.get_obj (*m_cm).get_any_constant ())\n-\t  {\n-\t    if (capacity_compatible_with_type (cst_val, m_size_cst))\n-\t      result_set.add (sval);\n-\t  }\n+\tif (tree cst = id.get_obj (*m_cm).get_any_constant ())\n+\t  check_constant (cst, sval);\n \telse\n-\t  {\n-\t    result_set.add (sval);\n-\t  }\n+\t  result_set.add (sval);\n       }\n   }\n \n@@ -3503,8 +3498,23 @@ class size_visitor : public visitor\n   }\n \n private:\n+  void check_constant (tree cst, const svalue *sval)\n+  {\n+    switch (TREE_CODE (cst))\n+      {\n+      default:\n+\t/* Assume all unhandled operands are compatible.  */\n+\tresult_set.add (sval);\n+\tbreak;\n+      case INTEGER_CST:\n+\tif (capacity_compatible_with_type (cst, m_size_cst))\n+\t  result_set.add (sval);\n+\tbreak;\n+      }\n+  }\n+\n   tree m_size_cst;\n-  const svalue *m_sval;\n+  const svalue *m_root_sval;\n   constraint_manager *m_cm;\n   svalue_set result_set; /* Used as a mapping of svalue*->bool.  */\n };\n@@ -3541,12 +3551,12 @@ struct_or_union_with_inheritance_p (tree struc)\n static bool\n is_any_cast_p (const gimple *stmt)\n {\n-  if (const gassign *assign = dyn_cast<const gassign *>(stmt))\n+  if (const gassign *assign = dyn_cast <const gassign *> (stmt))\n     return gimple_assign_cast_p (assign)\n \t   || !pending_diagnostic::same_tree_p (\n \t\t  TREE_TYPE (gimple_assign_lhs (assign)),\n \t\t  TREE_TYPE (gimple_assign_rhs1 (assign)));\n-  else if (const gcall *call = dyn_cast<const gcall *>(stmt))\n+  else if (const gcall *call = dyn_cast <const gcall *> (stmt))\n     {\n       tree lhs = gimple_call_lhs (call);\n       return lhs != NULL_TREE && !pending_diagnostic::same_tree_p (\n@@ -3606,10 +3616,11 @@ region_model::check_region_size (const region *lhs_reg, const svalue *rhs_sval,\n     case svalue_kind::SK_CONSTANT:\n       {\n \tconst constant_svalue *cst_cap_sval\n-\t\t= as_a <const constant_svalue *> (capacity);\n+\t  = as_a <const constant_svalue *> (capacity);\n \ttree cst_cap = cst_cap_sval->get_constant ();\n-\tif (!capacity_compatible_with_type (cst_cap, pointee_size_tree,\n-\t\t\t\t\t    is_struct))\n+\tif (TREE_CODE (cst_cap) == INTEGER_CST\n+\t    && !capacity_compatible_with_type (cst_cap, pointee_size_tree,\n+\t\t\t\t\t       is_struct))\n \t  ctxt->warn (new dubious_allocation_size (lhs_reg, rhs_reg,\n \t\t\t\t\t\t   cst_cap));\n       }\n@@ -5055,6 +5066,125 @@ region_model::append_regions_cb (const region *base_reg,\n     cb_data->out->safe_push (decl_reg);\n }\n \n+\n+/* Abstract class for diagnostics related to the use of\n+   floating-point arithmetic where precision is needed.  */\n+\n+class imprecise_floating_point_arithmetic : public pending_diagnostic\n+{\n+public:\n+  int get_controlling_option () const final override\n+  {\n+    return OPT_Wanalyzer_imprecise_fp_arithmetic;\n+  }\n+};\n+\n+/* Concrete diagnostic to complain about uses of floating-point arithmetic\n+   in the size argument of malloc etc.  */\n+\n+class float_as_size_arg : public imprecise_floating_point_arithmetic\n+{\n+public:\n+  float_as_size_arg (tree arg) : m_arg (arg)\n+  {}\n+\n+  const char *get_kind () const final override\n+  {\n+    return \"float_as_size_arg_diagnostic\";\n+  }\n+\n+  bool subclass_equal_p (const pending_diagnostic &other) const\n+  {\n+    return same_tree_p (m_arg, ((const float_as_size_arg &) other).m_arg);\n+  }\n+\n+  bool emit (rich_location *rich_loc) final override\n+  {\n+    diagnostic_metadata m;\n+    bool warned = warning_meta (rich_loc, m, get_controlling_option (),\n+\t\t\t\t\"use of floating-point arithmetic here might\"\n+\t\t\t\t\" yield unexpected results\");\n+    if (warned)\n+      inform (rich_loc->get_loc (), \"only use operands of an integer type\"\n+\t\t\t\t    \" inside the size argument\");\n+    return warned;\n+  }\n+\n+  label_text describe_final_event (const evdesc::final_event &ev) final\n+  override\n+  {\n+    if (m_arg)\n+      return ev.formatted_print (\"operand %qE is of type %qT\",\n+\t\t\t\t m_arg, TREE_TYPE (m_arg));\n+    return ev.formatted_print (\"at least one operand of the size argument is\"\n+\t\t\t       \" of a floating-point type\");\n+  }\n+\n+private:\n+  tree m_arg;\n+};\n+\n+/* Visitor to find uses of floating-point variables/constants in an svalue.  */\n+\n+class contains_floating_point_visitor : public visitor\n+{\n+public:\n+  contains_floating_point_visitor (const svalue *root_sval) : m_result (NULL)\n+  {\n+    root_sval->accept (this);\n+  }\n+\n+  const svalue *get_svalue_to_report ()\n+  {\n+    return m_result;\n+  }\n+\n+  void visit_constant_svalue (const constant_svalue *sval) final override\n+  {\n+    /* At the point the analyzer runs, constant integer operands in a floating\n+       point expression are already implictly converted to floating-points.\n+       Thus, we do prefer to report non-constants such that the diagnostic\n+       always reports a floating-point operand.  */\n+    tree type = sval->get_type ();\n+    if (type && FLOAT_TYPE_P (type) && !m_result)\n+      m_result = sval;\n+  }\n+\n+  void visit_conjured_svalue (const conjured_svalue *sval) final override\n+  {\n+    tree type = sval->get_type ();\n+    if (type && FLOAT_TYPE_P (type))\n+      m_result = sval;\n+  }\n+\n+  void visit_initial_svalue (const initial_svalue *sval) final override\n+  {\n+    tree type = sval->get_type ();\n+    if (type && FLOAT_TYPE_P (type))\n+      m_result = sval;\n+  }\n+\n+private:\n+  /* Non-null if at least one floating-point operand was found.  */\n+  const svalue *m_result;\n+};\n+\n+/* May complain about uses of floating-point operands in SIZE_IN_BYTES.  */\n+\n+void\n+region_model::check_dynamic_size_for_floats (const svalue *size_in_bytes,\n+\t\t\t\t\t     region_model_context *ctxt) const\n+{\n+  gcc_assert (ctxt);\n+\n+  contains_floating_point_visitor v (size_in_bytes);\n+  if (const svalue *float_sval = v.get_svalue_to_report ())\n+\t{\n+\t  tree diag_arg = get_representative_tree (float_sval);\n+\t  ctxt->warn (new float_as_size_arg (diag_arg));\n+\t}\n+}\n+\n /* Return a new region describing a heap-allocated block of memory.\n    Use CTXT to complain about tainted sizes.  */\n \n@@ -5092,8 +5222,11 @@ region_model::set_dynamic_extents (const region *reg,\n {\n   assert_compat_types (size_in_bytes->get_type (), size_type_node);\n   if (ctxt)\n-    check_dynamic_size_for_taint (reg->get_memory_space (), size_in_bytes,\n-\t\t\t\t  ctxt);\n+    {\n+      check_dynamic_size_for_taint (reg->get_memory_space (), size_in_bytes,\n+\t\t\t\t    ctxt);\n+      check_dynamic_size_for_floats (size_in_bytes, ctxt);\n+    }\n   m_dynamic_extents.put (reg, size_in_bytes);\n }\n "}, {"sha": "7ce832f6ce473950966c6956a7f9dc448379ac91", "filename": "gcc/analyzer/region-model.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c83e97317efb87fd5639a9ee9ec55aa1caa5423e/gcc%2Fanalyzer%2Fregion-model.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c83e97317efb87fd5639a9ee9ec55aa1caa5423e/gcc%2Fanalyzer%2Fregion-model.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.h?ref=c83e97317efb87fd5639a9ee9ec55aa1caa5423e", "patch": "@@ -853,6 +853,8 @@ class region_model\n   void check_dynamic_size_for_taint (enum memory_space mem_space,\n \t\t\t\t     const svalue *size_in_bytes,\n \t\t\t\t     region_model_context *ctxt) const;\n+  void check_dynamic_size_for_floats (const svalue *size_in_bytes,\n+\t\t\t\t      region_model_context *ctxt) const;\n \n   void check_region_for_taint (const region *reg,\n \t\t\t       enum access_direction dir,"}, {"sha": "f65d351a5fcdda31fc1bb0946108263ba17a609b", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c83e97317efb87fd5639a9ee9ec55aa1caa5423e/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c83e97317efb87fd5639a9ee9ec55aa1caa5423e/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=c83e97317efb87fd5639a9ee9ec55aa1caa5423e", "patch": "@@ -453,6 +453,7 @@ Objective-C and Objective-C++ Dialects}.\n -Wno-analyzer-fd-use-without-check @gol\n -Wno-analyzer-file-leak @gol\n -Wno-analyzer-free-of-non-heap @gol\n+-Wno-analyzer-imprecise-fp-arithmetic @gol\n -Wno-analyzer-jump-through-null @gol\n -Wno-analyzer-malloc-leak @gol\n -Wno-analyzer-mismatching-deallocation @gol\n@@ -9758,6 +9759,7 @@ Enabling this option effectively enables the following warnings:\n -Wanalyzer-fd-use-without-check @gol\n -Wanalyzer-file-leak @gol\n -Wanalyzer-free-of-non-heap @gol\n+-Wanalyzer-imprecise-fp-arithmetic @gol\n -Wanalyzer-jump-through-null @gol\n -Wanalyzer-malloc-leak @gol\n -Wanalyzer-mismatching-deallocation @gol\n@@ -9946,6 +9948,18 @@ is called on a non-heap pointer (e.g. an on-stack buffer, or a global).\n \n See @uref{https://cwe.mitre.org/data/definitions/590.html, CWE-590: Free of Memory not on the Heap}.\n \n+@item -Wno-analyzer-imprecise-fp-arithmetic\n+@opindex Wanalyzer-imprecise-fp-arithmetic\n+@opindex Wno-analyzer-imprecise-fp-arithmetic\n+This warning requires @option{-fanalyzer}, which enables it; use\n+@option{-Wno-analyzer-imprecise-fp-arithmetic}\n+to disable it.\n+\n+This diagnostic warns for paths through the code in which floating-point\n+arithmetic is used in locations where precise computation is needed.  This\n+diagnostic only warns on use of floating-point operands inside the\n+calculation of an allocation size at the moment.\n+\n @item -Wno-analyzer-jump-through-null\n @opindex Wanalyzer-jump-through-null\n @opindex Wno-analyzer-jump-through-null"}, {"sha": "003914ed96cd15729e807cddf98ba75b5c0d4756", "filename": "gcc/testsuite/gcc.dg/analyzer/allocation-size-1.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c83e97317efb87fd5639a9ee9ec55aa1caa5423e/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fallocation-size-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c83e97317efb87fd5639a9ee9ec55aa1caa5423e/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fallocation-size-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fallocation-size-1.c?ref=c83e97317efb87fd5639a9ee9ec55aa1caa5423e", "patch": "@@ -115,3 +115,13 @@ void test_10 (int32_t n)\n   char *ptr = malloc (7 * n);\n   free (ptr);\n }\n+\n+void test_11 ()\n+{\n+  /* 3.0 is folded to an int before the analyzer runs.  */\n+  int32_t *ptr = malloc (3.0); /* { dg-line malloc11 } */\n+  free (ptr);\n+\n+  /* { dg-warning \"allocated buffer size is not a multiple of the pointee's size \\\\\\[CWE-131\\\\\\]\" \"warning\" { target *-*-* } malloc11 } */\n+  /* { dg-message \"'int32_t \\\\*' (\\\\\\{aka '(long )?int \\\\*'\\\\\\})? here; 'sizeof \\\\(int32_t (\\\\\\{aka (long )?int\\\\\\})?\\\\)' is '4'\" \"note\" { target *-*-* } malloc11 } */\n+}"}, {"sha": "d8a3f4884d614d9391ce0a401c3d40a3f1f37ffc", "filename": "gcc/testsuite/gcc.dg/analyzer/imprecise-floating-point-1.c", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c83e97317efb87fd5639a9ee9ec55aa1caa5423e/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fimprecise-floating-point-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c83e97317efb87fd5639a9ee9ec55aa1caa5423e/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fimprecise-floating-point-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fimprecise-floating-point-1.c?ref=c83e97317efb87fd5639a9ee9ec55aa1caa5423e", "patch": "@@ -0,0 +1,74 @@\n+#include <stdlib.h>\n+\n+/* Tests warn on use of floating-point operands inside the calculation\n+   of an allocation size.\n+\n+   The test cases here only test for warnings.  The test cases inside\n+   allocation-size-X.c should be plently enough to test for false positives.  */\n+\n+void test_1 (float f)\n+{\n+  int *ptr = malloc (sizeof (int) * f); /* { dg-line test_1 } */\n+  free (ptr);\n+\n+  /* { dg-warning \"use of floating-point arithmetic here might yield unexpected results\" \"warning\" { target *-*-* } test_1 } */\n+  /* { dg-message \"operand 'f' is of type 'float'\" \"note\" { target *-*-* } test_1 } */\n+  /* { dg-message \"only use operands of an integer type inside the size argument\" \"note\" { target *-*-* } test_1 } */\n+}\n+\n+void test_2 (int n)\n+{\n+  int *ptr = malloc (n * 3.1); /* { dg-line test_2 } */\n+  free (ptr);\n+\n+  /* { dg-warning \"use of floating-point arithmetic here might yield unexpected results\" \"warning\" { target *-*-* } test_2 } */\n+  /* { dg-message \"operand '\\(\\\\d|e|f|\\\\.|\\\\+|\\)+' is of type 'double'\" \"note\" { target *-*-* } test_2 } */\n+  /* { dg-message \"only use operands of an integer type inside the size argument\" \"note\" { target *-*-* } test_2 } */\n+}\n+\n+void *alloc_me (size_t size)\n+{\n+  return malloc (size); /* { dg-line test_3 } */\n+\n+  /* { dg-warning \"use of floating-point arithmetic here might yield unexpected results\" \"warning\" { target *-*-* } test_3 } */\n+  /* { dg-message \"operand 'f' is of type 'float'\" \"note\" { target *-*-* } test_3 } */\n+  /* { dg-message \"only use operands of an integer type inside the size argument\" \"note\" { target *-*-* } test_3 } */\n+}\n+\n+void test_3 (float f)\n+{\n+  void *ptr = alloc_me (f); /* { dg-message \"calling 'alloc_me' from 'test_3'\" } */\n+  free (ptr);\n+}\n+\n+void test_4 (int n)\n+{\n+  int *ptr = calloc(1.7 * n, sizeof (int)); /* { dg-line test_4 } */\n+  free (ptr);\n+\n+  /* { dg-warning \"use of floating-point arithmetic here might yield unexpected results\" \"warning\" { target *-*-* } test_4 } */\n+  /* { dg-message \"operand '\\(\\\\d|e|f|\\\\.|\\\\+|\\)+' is of type 'double'\" \"note\" { target *-*-* } test_4 } */\n+  /* { dg-message \"only use operands of an integer type inside the size argument\" \"note\" { target *-*-* } test_4 } */\n+}\n+\n+int test_5 (float f)\n+{\n+  int *ptr = __builtin_alloca (sizeof (int) * f); /* { dg-line test_5 } */\n+  *ptr = 4;\n+  return *ptr;\n+\n+  /* { dg-warning \"use of floating-point arithmetic here might yield unexpected results\" \"warning\" { target *-*-* } test_5 } */\n+  /* { dg-message \"operand 'f' is of type 'float'\" \"note\" { target *-*-* } test_5 } */\n+  /* { dg-message \"only use operands of an integer type inside the size argument\" \"note\" { target *-*-* } test_5 } */\n+}\n+\n+int test_6 (float f)\n+{\n+  int *ptr = __builtin_alloca (1.7f * f * 2.3f); /* { dg-line test_6 } */\n+  *ptr = 4;\n+  return *ptr;\n+\n+  /* { dg-warning \"use of floating-point arithmetic here might yield unexpected results\" \"warning\" { target *-*-* } test_6 } */\n+  /* { dg-message \"operand 'f' is of type 'float'\" \"note\" { target *-*-* } test_6 } */\n+  /* { dg-message \"only use operands of an integer type inside the size argument\" \"note\" { target *-*-* } test_6 } */\n+}"}, {"sha": "6a78b78d35258ac4134e660600812ed7785e3855", "filename": "gcc/testsuite/gcc.dg/analyzer/pr106181.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c83e97317efb87fd5639a9ee9ec55aa1caa5423e/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr106181.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c83e97317efb87fd5639a9ee9ec55aa1caa5423e/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr106181.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr106181.c?ref=c83e97317efb87fd5639a9ee9ec55aa1caa5423e", "patch": "@@ -0,0 +1,11 @@\n+#include <stdint.h>\n+\n+void *\n+foo (int x)\n+{\n+  return __builtin_calloc (x * 1.1, 1); /* { dg-line calloc } */\n+\n+  /* { dg-warning \"use of floating-point arithmetic here might yield unexpected results\" \"warning\" { target *-*-* } calloc } */\n+  /* { dg-message \"operand '\\(\\\\d|e|f|\\\\.|\\\\+|\\)+' is of type 'double'\" \"note\" { target *-*-* } calloc } */\n+  /* { dg-message \"only use operands of an integer type inside the size argument\" \"note\" { target *-*-* } calloc } */\n+}"}]}