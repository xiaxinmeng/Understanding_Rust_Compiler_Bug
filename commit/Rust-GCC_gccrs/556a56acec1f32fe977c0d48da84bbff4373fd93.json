{"sha": "556a56acec1f32fe977c0d48da84bbff4373fd93", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTU2YTU2YWNlYzFmMzJmZTk3N2MwZDQ4ZGE4NGJiZmY0MzczZmQ5Mw==", "commit": {"author": {"name": "David S. Miller", "email": "davem@redhat.com", "date": "2002-06-24T10:08:38Z"}, "committer": {"name": "David S. Miller", "email": "davem@gcc.gnu.org", "date": "2002-06-24T10:08:38Z"}, "message": "sparc.c (INIT_TARGET_OPTABS): If ARCH64, set the 32-bit ABI libfuncs to NULL.\n\n2002-06-24  David S. Miller  <davem@redhat.com>\n\n\t* config/sparc/sparc.c (INIT_TARGET_OPTABS): If ARCH64, set the\n\t32-bit ABI libfuncs to NULL.\n\n\t* expmed.c (expand_divmod): Do not set optab1/optab2 to the shift\n\toptabs if op1 is const0_rtx.\n\nFrom-SVN: r54950", "tree": {"sha": "0b57b1ced0947668bcdbc374a39f118f0c2008e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0b57b1ced0947668bcdbc374a39f118f0c2008e8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/556a56acec1f32fe977c0d48da84bbff4373fd93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/556a56acec1f32fe977c0d48da84bbff4373fd93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/556a56acec1f32fe977c0d48da84bbff4373fd93", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/556a56acec1f32fe977c0d48da84bbff4373fd93/comments", "author": null, "committer": null, "parents": [{"sha": "2c35c7be14cfc9b9c515e5f4767c2f56e9217c44", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c35c7be14cfc9b9c515e5f4767c2f56e9217c44", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c35c7be14cfc9b9c515e5f4767c2f56e9217c44"}], "stats": {"total": 26, "additions": 24, "deletions": 2}, "files": [{"sha": "f3cdecc9a9e4a39fbe2ce5e36e85c6654e01974b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/556a56acec1f32fe977c0d48da84bbff4373fd93/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/556a56acec1f32fe977c0d48da84bbff4373fd93/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=556a56acec1f32fe977c0d48da84bbff4373fd93", "patch": "@@ -1,3 +1,11 @@\n+2002-06-24  David S. Miller  <davem@redhat.com>\n+\n+\t* config/sparc/sparc.c (INIT_TARGET_OPTABS): If ARCH64, set the\n+\t32-bit ABI libfuncs to NULL.\n+\n+\t* expmed.c (expand_divmod): Do not set optab1/optab2 to the shift\n+\toptabs if op1 is const0_rtx.\n+\n 2002-06-24  Neil Booth  <neil@daikokuya.co.uk>\n \n \t* cpptrad.c (scan_out_logical_line): Check recursing only when"}, {"sha": "97f1a2d260679c3659f923209777c5ae5b71796f", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/556a56acec1f32fe977c0d48da84bbff4373fd93/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/556a56acec1f32fe977c0d48da84bbff4373fd93/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=556a56acec1f32fe977c0d48da84bbff4373fd93", "patch": "@@ -2585,6 +2585,17 @@ do {                                                                    \\\n \t  sqrt_optab->handlers[(int) TFmode].libfunc\t\t\t\\\n \t    = init_one_libfunc (\"_Q_sqrt\");\t\t\t\t\\\n       }\t\t\t\t\t\t\t\t\t\\\n+    if (TARGET_ARCH64)\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+        /* In the SPARC 64bit ABI, these libfuncs do not exist in the\t\\\n+           library.  Make sure the compiler does not emit calls to them\t\\\n+\t   by accident.  */\t\t\t\t\t\t\\\n+\tsdiv_optab->handlers[(int) SImode].libfunc = NULL;\t\t\\\n+\tudiv_optab->handlers[(int) SImode].libfunc = NULL;\t\t\\\n+\tsmod_optab->handlers[(int) SImode].libfunc = NULL;\t\t\\\n+\tumod_optab->handlers[(int) SImode].libfunc = NULL;\t\t\\\n+        smul_optab->handlers[(int) SImode].libfunc = NULL;\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n     INIT_SUBTARGET_OPTABS;\t\t\t\t\t\t\\\n   } while (0)\n "}, {"sha": "317dcc4ab540499e8b0f2526377a8b0c5ec1bb61", "filename": "gcc/expmed.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/556a56acec1f32fe977c0d48da84bbff4373fd93/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/556a56acec1f32fe977c0d48da84bbff4373fd93/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=556a56acec1f32fe977c0d48da84bbff4373fd93", "patch": "@@ -3049,9 +3049,12 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n      not straightforward to generalize this.  Maybe we should make an array\n      of possible modes in init_expmed?  Save this for GCC 2.7.  */\n \n-  optab1 = (op1_is_pow2 ? (unsignedp ? lshr_optab : ashr_optab)\n+  optab1 = ((op1_is_pow2 && op1 != const0_rtx)\n+\t    ? (unsignedp ? lshr_optab : ashr_optab)\n \t    : (unsignedp ? udiv_optab : sdiv_optab));\n-  optab2 = (op1_is_pow2 ? optab1 : (unsignedp ? udivmod_optab : sdivmod_optab));\n+  optab2 = ((op1_is_pow2 && op1 != const0_rtx)\n+\t    ? optab1\n+\t    : (unsignedp ? udivmod_optab : sdivmod_optab));\n \n   for (compute_mode = mode; compute_mode != VOIDmode;\n        compute_mode = GET_MODE_WIDER_MODE (compute_mode))"}]}