{"sha": "374097963cec9c1142faf10b819aa28d1fb6f641", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzc0MDk3OTYzY2VjOWMxMTQyZmFmMTBiODE5YWEyOGQxZmI2ZjY0MQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2005-04-24T12:53:36Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2005-04-24T12:53:36Z"}, "message": "rs6000.c (rs6000_override_options): Use gcc_assert and gcc_unreachable as appropriate.\n\n\t* config/rs6000/rs6000.c (rs6000_override_options): Use gcc_assert\n\tand gcc_unreachable as appropriate.\n\t(num_insns_constant, output_vec_const_move,\n\tbuild_mask64_2_operands, rs6000_output_dwarf_dtprel,\n\trs6000_emit_set_const, rs6000_emit_move,\n\tspe_build_register_parallel, function_arg,\n\trs6000_move_block_from_reg, altivec_expand_predicate_builtin,\n\tspe_expand_predicate_builtin, spe_expand_evsel_builtin,\n\trs6000_expand_builtin, spe_init_builtins, altivec_init_builtins,\n\trs6000_common_init_builtins, expand_block_clear,\n\texpand_block_move, validate_condition_mode, ccr_bit, extract_MB,\n\textract_ME, rs6000_get_some_local_dynamic_name,\n\trs6000_output_function_entry, print_operand,\n\tprint_operand_address, rs6000_generate_compare, rs6000_emit_sCOND,\n\toutput_cbranch, output_e500_flip_gt_bit,\n\trs6000_emit_vector_compare, rs6000_emit_vector_compare,\n\trs6000_emit_cmove, rs6000_emit_minmax, rs6000_split_multireg_move,\n\tcompute_save_world_info, rs6000_stack_info,\n\trs6000_emit_load_toc_table, rs6000_frame_related,\n\tspe_synthesize_frame_save, rs6000_emit_epilogue,\n\trs6000_output_function_epilogue, rs6000_hash_constant, output_toc,\n\toutput_function_profiler, rs6000_trampoline_size,\n\trs6000_initialize_trampoline, find_addr_reg,\n\trs6000_machopic_legitimize_pic_address,\n\trs6000_initial_elimination_offset,\n\trs6000_dbx_register_number): Likewise.\n\t* config/rs6000/rs6000.md (*fix_truncdfsi2_internal,\n\t*movdf_hardfloat32, *movdf_softfloat32, *fix_trunctfsi2_internal,\n\t*movti_power, *movti_string, call, call_value, sibcall,\n\tsibcall_value): Likewise.\n\t* config/rs6000/spe.md (*movdf_e500_double,\n\t*movv2si_internal): Likewise.\n\t* config/rs6000/rs6000.h (PREFERRED_RELOAD_CLASS): Remove 'abort'\n\tfrom comment.\n\nFrom-SVN: r98658", "tree": {"sha": "8f72462f26ea2ea940622cd3d444dc13eab903e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8f72462f26ea2ea940622cd3d444dc13eab903e7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/374097963cec9c1142faf10b819aa28d1fb6f641", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/374097963cec9c1142faf10b819aa28d1fb6f641", "html_url": "https://github.com/Rust-GCC/gccrs/commit/374097963cec9c1142faf10b819aa28d1fb6f641", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/374097963cec9c1142faf10b819aa28d1fb6f641/comments", "author": null, "committer": null, "parents": [{"sha": "ea8261fbb1b4ee095e5ad57ed4cce887083696b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea8261fbb1b4ee095e5ad57ed4cce887083696b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea8261fbb1b4ee095e5ad57ed4cce887083696b7"}], "stats": {"total": 1006, "additions": 528, "deletions": 478}, "files": [{"sha": "8b1c9e7553c7674261f5d5c5e99ddc0915a1fc00", "filename": "gcc/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/374097963cec9c1142faf10b819aa28d1fb6f641/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/374097963cec9c1142faf10b819aa28d1fb6f641/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=374097963cec9c1142faf10b819aa28d1fb6f641", "patch": "@@ -1,3 +1,40 @@\n+2005-04-24  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* config/rs6000/rs6000.c (rs6000_override_options): Use gcc_assert\n+\tand gcc_unreachable as appropriate.\n+\t(num_insns_constant, output_vec_const_move,\n+\tbuild_mask64_2_operands, rs6000_output_dwarf_dtprel,\n+\trs6000_emit_set_const, rs6000_emit_move,\n+\tspe_build_register_parallel, function_arg,\n+\trs6000_move_block_from_reg, altivec_expand_predicate_builtin,\n+\tspe_expand_predicate_builtin, spe_expand_evsel_builtin,\n+\trs6000_expand_builtin, spe_init_builtins, altivec_init_builtins,\n+\trs6000_common_init_builtins, expand_block_clear,\n+\texpand_block_move, validate_condition_mode, ccr_bit, extract_MB,\n+\textract_ME, rs6000_get_some_local_dynamic_name,\n+\trs6000_output_function_entry, print_operand,\n+\tprint_operand_address, rs6000_generate_compare, rs6000_emit_sCOND,\n+\toutput_cbranch, output_e500_flip_gt_bit,\n+\trs6000_emit_vector_compare, rs6000_emit_vector_compare,\n+\trs6000_emit_cmove, rs6000_emit_minmax, rs6000_split_multireg_move,\n+\tcompute_save_world_info, rs6000_stack_info,\n+\trs6000_emit_load_toc_table, rs6000_frame_related,\n+\tspe_synthesize_frame_save, rs6000_emit_epilogue,\n+\trs6000_output_function_epilogue, rs6000_hash_constant, output_toc,\n+\toutput_function_profiler, rs6000_trampoline_size,\n+\trs6000_initialize_trampoline, find_addr_reg,\n+\trs6000_machopic_legitimize_pic_address,\n+\trs6000_initial_elimination_offset,\n+\trs6000_dbx_register_number): Likewise.\n+\t* config/rs6000/rs6000.md (*fix_truncdfsi2_internal,\n+\t*movdf_hardfloat32, *movdf_softfloat32, *fix_trunctfsi2_internal,\n+\t*movti_power, *movti_string, call, call_value, sibcall,\n+\tsibcall_value): Likewise.\n+\t* config/rs6000/spe.md (*movdf_e500_double,\n+\t*movv2si_internal): Likewise.\n+\t* config/rs6000/rs6000.h (PREFERRED_RELOAD_CLASS): Remove 'abort'\n+\tfrom comment.\n+\n 2005-04-24  Richard Henderson  <rth@redhat.com>\n \n \tPR target/21101"}, {"sha": "2397aee33e1c0d3fbf0bd2862af2af8c78a97505", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 452, "deletions": 441, "changes": 893, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/374097963cec9c1142faf10b819aa28d1fb6f641/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/374097963cec9c1142faf10b819aa28d1fb6f641/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=374097963cec9c1142faf10b819aa28d1fb6f641", "patch": "@@ -1589,7 +1589,7 @@ rs6000_override_options (const char *default_cpu)\n \tbreak;\n \n       default:\n-\tabort ();\n+\tgcc_unreachable ();\n       }\n }\n \n@@ -1849,74 +1849,69 @@ num_insns_constant_wide (HOST_WIDE_INT value)\n int\n num_insns_constant (rtx op, enum machine_mode mode)\n {\n-  if (GET_CODE (op) == CONST_INT)\n+  HOST_WIDE_INT low, high;\n+  \n+  switch (GET_CODE (op))\n     {\n+    case CONST_INT:\n #if HOST_BITS_PER_WIDE_INT == 64\n       if ((INTVAL (op) >> 31) != 0 && (INTVAL (op) >> 31) != -1\n \t  && mask64_operand (op, mode))\n \treturn 2;\n       else\n #endif\n \treturn num_insns_constant_wide (INTVAL (op));\n-    }\n-\n-  else if (GET_CODE (op) == CONST_DOUBLE && mode == SFmode)\n-    {\n-      long l;\n-      REAL_VALUE_TYPE rv;\n-\n-      REAL_VALUE_FROM_CONST_DOUBLE (rv, op);\n-      REAL_VALUE_TO_TARGET_SINGLE (rv, l);\n-      return num_insns_constant_wide ((HOST_WIDE_INT) l);\n-    }\n-\n-  else if (GET_CODE (op) == CONST_DOUBLE)\n-    {\n-      HOST_WIDE_INT low;\n-      HOST_WIDE_INT high;\n-      long l[2];\n-      REAL_VALUE_TYPE rv;\n-      int endian = (WORDS_BIG_ENDIAN == 0);\n \n-      if (mode == VOIDmode || mode == DImode)\n-\t{\n-\t  high = CONST_DOUBLE_HIGH (op);\n-\t  low  = CONST_DOUBLE_LOW (op);\n-\t}\n-      else\n-\t{\n-\t  REAL_VALUE_FROM_CONST_DOUBLE (rv, op);\n-\t  REAL_VALUE_TO_TARGET_DOUBLE (rv, l);\n-\t  high = l[endian];\n-\t  low  = l[1 - endian];\n-\t}\n-\n-      if (TARGET_32BIT)\n-\treturn (num_insns_constant_wide (low)\n-\t\t+ num_insns_constant_wide (high));\n-\n-      else\n-\t{\n-\t  if (high == 0 && low >= 0)\n-\t    return num_insns_constant_wide (low);\n-\n-\t  else if (high == -1 && low < 0)\n-\t    return num_insns_constant_wide (low);\n-\n-\t  else if (mask64_operand (op, mode))\n-\t    return 2;\n+      case CONST_DOUBLE:\n+\tif (mode == SFmode)\n+\t  {\n+\t    long l;\n+\t    REAL_VALUE_TYPE rv;\n+\t    \n+\t    REAL_VALUE_FROM_CONST_DOUBLE (rv, op);\n+\t    REAL_VALUE_TO_TARGET_SINGLE (rv, l);\n+\t    return num_insns_constant_wide ((HOST_WIDE_INT) l);\n+\t  }\n \n-\t  else if (low == 0)\n-\t    return num_insns_constant_wide (high) + 1;\n+\tif (mode == VOIDmode || mode == DImode)\n+\t  {\n+\t    high = CONST_DOUBLE_HIGH (op);\n+\t    low  = CONST_DOUBLE_LOW (op);\n+\t  }\n+\telse\n+\t  {\n+\t    long l[2];\n+\t    REAL_VALUE_TYPE rv;\n+\t    \n+\t    REAL_VALUE_FROM_CONST_DOUBLE (rv, op);\n+\t    REAL_VALUE_TO_TARGET_DOUBLE (rv, l);\n+\t    high = l[WORDS_BIG_ENDIAN == 0];\n+\t    low  = l[WORDS_BIG_ENDIAN != 0];\n+\t  }\n \n-\t  else\n-\t    return (num_insns_constant_wide (high)\n-\t\t    + num_insns_constant_wide (low) + 1);\n-\t}\n+\tif (TARGET_32BIT)\n+\t  return (num_insns_constant_wide (low)\n+\t\t  + num_insns_constant_wide (high));\n+\telse\n+\t  {\n+\t    if ((high == 0 && low >= 0)\n+\t\t|| (high == -1 && low < 0))\n+\t      return num_insns_constant_wide (low);\n+\t    \n+\t    else if (mask64_operand (op, mode))\n+\t      return 2;\n+\t    \n+\t    else if (low == 0)\n+\t      return num_insns_constant_wide (high) + 1;\n+\t    \n+\t    else\n+\t      return (num_insns_constant_wide (high)\n+\t\t      + num_insns_constant_wide (low) + 1);\n+\t  }\n+\t\n+    default:\n+      gcc_unreachable ();\n     }\n-\n-  else\n-    abort ();\n }\n \n /* Returns the constant for the splat instruction, if exists.  */\n@@ -2006,66 +2001,61 @@ output_vec_const_move (rtx *operands)\n     {\n       if (zero_constant (vec, mode))\n \treturn \"vxor %0,%0,%0\";\n-      else if (easy_vector_constant (vec, mode))\n+\n+      gcc_assert (easy_vector_constant (vec, mode));\n+      \n+      operands[1] = GEN_INT (cst);\n+      switch (mode)\n \t{\n-\t  operands[1] = GEN_INT (cst);\n-\t  switch (mode)\n+\tcase V4SImode:\n+\t  if (EASY_VECTOR_15 (cst))\n \t    {\n-\t    case V4SImode:\n-\t      if (EASY_VECTOR_15 (cst))\n-\t\t{\n-\t\t  operands[1] = GEN_INT (cst);\n-\t\t  return \"vspltisw %0,%1\";\n-\t\t}\n-\t      else if (EASY_VECTOR_15_ADD_SELF (cst))\n-\t\treturn \"#\";\n-\t      cst = cst >> 16;\n-\t      /* Fall thru */\n-\n-\t    case V8HImode:\n-\t      if (EASY_VECTOR_15 (cst))\n-\t\t{\n-\t\t  operands[1] = GEN_INT (cst);\n-\t\t  return \"vspltish %0,%1\";\n-\t\t}\n-\t      else if (EASY_VECTOR_15_ADD_SELF (cst))\n-\t\treturn \"#\";\n-\t      cst = cst >> 8;\n-\t      /* Fall thru */\n+\t      operands[1] = GEN_INT (cst);\n+\t      return \"vspltisw %0,%1\";\n+\t    }\n+\t  else if (EASY_VECTOR_15_ADD_SELF (cst))\n+\t    return \"#\";\n+\t  cst = cst >> 16;\n+\t  /* Fall thru */\n \n-\t    case V16QImode:\n-\t      if (EASY_VECTOR_15 (cst))\n-\t\t{\n-\t\t  operands[1] = GEN_INT (cst);\n-\t\t  return \"vspltisb %0,%1\";\n-\t\t}\n-\t      else if (EASY_VECTOR_15_ADD_SELF (cst))\n-\t\treturn \"#\";\n+\tcase V8HImode:\n+\t  if (EASY_VECTOR_15 (cst))\n+\t    {\n+\t      operands[1] = GEN_INT (cst);\n+\t      return \"vspltish %0,%1\";\n+\t    }\n+\t  else if (EASY_VECTOR_15_ADD_SELF (cst))\n+\t    return \"#\";\n+\t  cst = cst >> 8;\n+\t  /* Fall thru */\n \n-\t    default:\n-\t      abort ();\n+\tcase V16QImode:\n+\t  if (EASY_VECTOR_15 (cst))\n+\t    {\n+\t      operands[1] = GEN_INT (cst);\n+\t      return \"vspltisb %0,%1\";\n \t    }\n+\t  else if (EASY_VECTOR_15_ADD_SELF (cst))\n+\t    return \"#\";\n+\t  \n+\tdefault:\n+\t  gcc_unreachable ();\n \t}\n-      else\n-\tabort ();\n     }\n \n-  if (TARGET_SPE)\n-    {\n-      /* Vector constant 0 is handled as a splitter of V2SI, and in the\n-\t pattern of V1DI, V4HI, and V2SF.\n-\n-\t FIXME: We should probably return # and add post reload\n-\t splitters for these, but this way is so easy ;-).  */\n-      operands[1] = GEN_INT (cst);\n-      operands[2] = GEN_INT (cst2);\n-      if (cst == cst2)\n-\treturn \"li %0,%1\\n\\tevmergelo %0,%0,%0\";\n-      else\n-\treturn \"li %0,%1\\n\\tevmergelo %0,%0,%0\\n\\tli %0,%2\";\n-    }\n-\n-  abort ();\n+  gcc_assert (TARGET_SPE);\n+  \n+  /* Vector constant 0 is handled as a splitter of V2SI, and in the\n+     pattern of V1DI, V4HI, and V2SF.\n+\n+     FIXME: We should probably return # and add post reload\n+     splitters for these, but this way is so easy ;-).  */\n+  operands[1] = GEN_INT (cst);\n+  operands[2] = GEN_INT (cst2);\n+  if (cst == cst2)\n+    return \"li %0,%1\\n\\tevmergelo %0,%0,%0\";\n+  else\n+    return \"li %0,%1\\n\\tevmergelo %0,%0,%0\\n\\tli %0,%2\";\n }\n \n int\n@@ -2132,8 +2122,7 @@ build_mask64_2_operands (rtx in, rtx *out)\n   unsigned HOST_WIDE_INT c, lsb, m1, m2;\n   int shift;\n \n-  if (GET_CODE (in) != CONST_INT)\n-    abort ();\n+  gcc_assert (GET_CODE (in) == CONST_INT);\n \n   c = INTVAL (in);\n   if (c & 1)\n@@ -2189,7 +2178,7 @@ build_mask64_2_operands (rtx in, rtx *out)\n #else\n   (void)in;\n   (void)out;\n-  abort ();\n+  gcc_unreachable ();\n #endif\n }\n \n@@ -2671,7 +2660,7 @@ rs6000_output_dwarf_dtprel (FILE *file, int size, rtx x)\n       fputs (DOUBLE_INT_ASM_OP, file);\n       break;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n   output_addr_const (file, x);\n   fputs (\"@dtprel+0x8000\", file);\n@@ -3284,49 +3273,55 @@ rs6000_emit_set_const (rtx dest, enum machine_mode mode,\n   rtx result, insn, set;\n   HOST_WIDE_INT c0, c1;\n \n-  if (mode == QImode || mode == HImode)\n+  switch (mode)\n     {\n+      case  QImode:\n+    case HImode:\n       if (dest == NULL)\n \tdest = gen_reg_rtx (mode);\n       emit_insn (gen_rtx_SET (VOIDmode, dest, source));\n       return dest;\n-    }\n-  else if (mode == SImode)\n-    {\n+      \n+    case SImode:\n       result = no_new_pseudos ? dest : gen_reg_rtx (SImode);\n-\n+      \n       emit_insn (gen_rtx_SET (VOIDmode, result,\n \t\t\t      GEN_INT (INTVAL (source)\n \t\t\t\t       & (~ (HOST_WIDE_INT) 0xffff))));\n       emit_insn (gen_rtx_SET (VOIDmode, dest,\n \t\t\t      gen_rtx_IOR (SImode, result,\n \t\t\t\t\t   GEN_INT (INTVAL (source) & 0xffff))));\n       result = dest;\n-    }\n-  else if (mode == DImode)\n-    {\n-      if (GET_CODE (source) == CONST_INT)\n+      break;\n+\n+    case DImode:\n+      switch (GET_CODE (source))\n \t{\n+\tcase CONST_INT:\n \t  c0 = INTVAL (source);\n \t  c1 = -(c0 < 0);\n-\t}\n-      else if (GET_CODE (source) == CONST_DOUBLE)\n-\t{\n+\t  break;\n+\t  \n+\tcase CONST_DOUBLE:\n #if HOST_BITS_PER_WIDE_INT >= 64\n \t  c0 = CONST_DOUBLE_LOW (source);\n \t  c1 = -(c0 < 0);\n #else\n \t  c0 = CONST_DOUBLE_LOW (source);\n \t  c1 = CONST_DOUBLE_HIGH (source);\n #endif\n+\t  break;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n \t}\n-      else\n-\tabort ();\n \n       result = rs6000_emit_set_long_const (dest, c0, c1);\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n     }\n-  else\n-    abort ();\n \n   insn = get_last_insn ();\n   set = single_set (insn);\n@@ -3464,14 +3459,13 @@ rs6000_emit_move (rtx dest, rtx source, enum machine_mode mode)\n \t to a CONST_INT.  */\n       operands[1] = gen_int_mode (CONST_DOUBLE_LOW (operands[1]), mode);\n     }\n-  if (GET_CODE (operands[1]) == CONST_DOUBLE\n-      && ! FLOAT_MODE_P (mode)\n-      && ((CONST_DOUBLE_HIGH (operands[1]) == 0\n-\t   && CONST_DOUBLE_LOW (operands[1]) >= 0)\n-\t  || (CONST_DOUBLE_HIGH (operands[1]) == -1\n-\t      && CONST_DOUBLE_LOW (operands[1]) < 0)))\n-    abort ();\n-\n+  gcc_assert (GET_CODE (operands[1]) != CONST_DOUBLE\n+\t      || FLOAT_MODE_P (mode)\n+\t      || ((CONST_DOUBLE_HIGH (operands[1]) != 0\n+\t\t   || CONST_DOUBLE_LOW (operands[1]) < 0)\n+\t\t  && (CONST_DOUBLE_HIGH (operands[1]) != -1\n+\t\t      || CONST_DOUBLE_LOW (operands[1]) >= 0)));\n+  \n   /* Check if GCC is setting up a block move that will end up using FP\n      registers as temporaries.  We must make sure this is acceptable.  */\n   if (GET_CODE (operands[0]) == MEM\n@@ -3769,7 +3763,7 @@ rs6000_emit_move (rtx dest, rtx source, enum machine_mode mode)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   /* Above, we may have called force_const_mem which may have returned\n@@ -4329,22 +4323,23 @@ spe_build_register_parallel (enum machine_mode mode, int gregno)\n {\n   rtx r1, r3;\n \n-  if (mode == DFmode)\n+  switch (mode)\n     {\n+    case DFmode:\n       r1 = gen_rtx_REG (DImode, gregno);\n       r1 = gen_rtx_EXPR_LIST (VOIDmode, r1, const0_rtx);\n       return gen_rtx_PARALLEL (mode, gen_rtvec (1, r1));\n-    }\n-  else if (mode == DCmode)\n-    {\n+\n+    case DCmode:\n       r1 = gen_rtx_REG (DImode, gregno);\n       r1 = gen_rtx_EXPR_LIST (VOIDmode, r1, const0_rtx);\n       r3 = gen_rtx_REG (DImode, gregno + 2);\n       r3 = gen_rtx_EXPR_LIST (VOIDmode, r3, GEN_INT (8));\n       return gen_rtx_PARALLEL (mode, gen_rtvec (2, r1, r3));\n+\n+    default:\n+      gcc_unreachable ();\n     }\n-  abort ();\n-  return NULL_RTX;\n }\n \n /* Determine where to put a SIMD argument on the SPE.  */\n@@ -4825,8 +4820,7 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t    {\n \t      /* Currently, we only ever need one reg here because complex\n \t\t doubles are split.  */\n-\t      if (cum->fregno != FP_ARG_MAX_REG || fmode != TFmode)\n-\t\tabort ();\n+\t      gcc_assert (cum->fregno == FP_ARG_MAX_REG && fmode == TFmode);\n \n \t      /* Long double split over regs and memory.  */\n \t      fmode = DFmode;\n@@ -5061,8 +5055,7 @@ rs6000_move_block_from_reg (int regno, rtx x, int nregs)\n       else\n \ttem = replace_equiv_address (tem, XEXP (tem, 0));\n \n-      if (tem == NULL_RTX)\n-\tabort ();\n+      gcc_assert (tem);\n \n       emit_move_insn (tem, gen_rtx_REG (reg_mode, regno + i));\n     }\n@@ -6106,8 +6099,7 @@ altivec_expand_predicate_builtin (enum insn_code icode, const char *opcode,\n   else\n     cr6_form_int = TREE_INT_CST_LOW (cr6_form);\n \n-  if (mode0 != mode1)\n-    abort ();\n+  gcc_assert (mode0 == mode1);\n \n   /* If we have invalid arguments, bail out before generating bad rtl.  */\n   if (arg0 == error_mark_node || arg1 == error_mark_node)\n@@ -6856,8 +6848,7 @@ spe_expand_predicate_builtin (enum insn_code icode, tree arglist, rtx target)\n   else\n     form_int = TREE_INT_CST_LOW (form);\n \n-  if (mode0 != mode1)\n-    abort ();\n+  gcc_assert (mode0 == mode1);\n \n   if (arg0 == error_mark_node || arg1 == error_mark_node)\n     return const0_rtx;\n@@ -6958,8 +6949,7 @@ spe_expand_evsel_builtin (enum insn_code icode, tree arglist, rtx target)\n   enum machine_mode mode0 = insn_data[icode].operand[1].mode;\n   enum machine_mode mode1 = insn_data[icode].operand[2].mode;\n \n-  if (mode0 != mode1)\n-    abort ();\n+  gcc_assert (mode0 == mode1);\n \n   if (arg0 == error_mark_node || arg1 == error_mark_node\n       || arg2 == error_mark_node || arg3 == error_mark_node)\n@@ -7022,12 +7012,10 @@ rs6000_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n       tree arg;\n       rtx op, addr, pat;\n \n-      if (!TARGET_ALTIVEC)\n-\tabort ();\n+      gcc_assert (TARGET_ALTIVEC);\n \n       arg = TREE_VALUE (arglist);\n-      if (TREE_CODE (TREE_TYPE (arg)) != POINTER_TYPE)\n-\tabort ();\n+      gcc_assert (TREE_CODE (TREE_TYPE (arg)) == POINTER_TYPE);\n       op = expand_expr (arg, NULL_RTX, Pmode, EXPAND_NORMAL);\n       addr = memory_address (mode, op);\n       if (fcode == ALTIVEC_BUILTIN_MASK_FOR_STORE)\n@@ -7070,29 +7058,27 @@ rs6000_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n \treturn ret;\n     }\n \n-  if (TARGET_ALTIVEC || TARGET_SPE)\n-    {\n-      /* Handle simple unary operations.  */\n-      d = (struct builtin_description *) bdesc_1arg;\n-      for (i = 0; i < ARRAY_SIZE (bdesc_1arg); i++, d++)\n-\tif (d->code == fcode)\n-\t  return rs6000_expand_unop_builtin (d->icode, arglist, target);\n-\n-      /* Handle simple binary operations.  */\n-      d = (struct builtin_description *) bdesc_2arg;\n-      for (i = 0; i < ARRAY_SIZE (bdesc_2arg); i++, d++)\n-\tif (d->code == fcode)\n-\t  return rs6000_expand_binop_builtin (d->icode, arglist, target);\n-\n-      /* Handle simple ternary operations.  */\n-      d = (struct builtin_description *) bdesc_3arg;\n-      for (i = 0; i < ARRAY_SIZE  (bdesc_3arg); i++, d++)\n-\tif (d->code == fcode)\n-\t  return rs6000_expand_ternop_builtin (d->icode, arglist, target);\n-    }\n+  gcc_assert (TARGET_ALTIVEC || TARGET_SPE);\n+  \n+  /* Handle simple unary operations.  */\n+  d = (struct builtin_description *) bdesc_1arg;\n+  for (i = 0; i < ARRAY_SIZE (bdesc_1arg); i++, d++)\n+    if (d->code == fcode)\n+      return rs6000_expand_unop_builtin (d->icode, arglist, target);\n+  \n+  /* Handle simple binary operations.  */\n+  d = (struct builtin_description *) bdesc_2arg;\n+  for (i = 0; i < ARRAY_SIZE (bdesc_2arg); i++, d++)\n+    if (d->code == fcode)\n+      return rs6000_expand_binop_builtin (d->icode, arglist, target);\n \n-  abort ();\n-  return NULL_RTX;\n+  /* Handle simple ternary operations.  */\n+  d = (struct builtin_description *) bdesc_3arg;\n+  for (i = 0; i < ARRAY_SIZE  (bdesc_3arg); i++, d++)\n+    if (d->code == fcode)\n+      return rs6000_expand_ternop_builtin (d->icode, arglist, target);\n+  \n+  gcc_unreachable ();\n }\n \n static tree\n@@ -7413,7 +7399,7 @@ spe_init_builtins (void)\n \t  type = int_ftype_int_v2sf_v2sf;\n \t  break;\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n \n       def_builtin (d->mask, d->name, type, d->code);\n@@ -7434,7 +7420,7 @@ spe_init_builtins (void)\n \t  type = v2sf_ftype_4_v2sf;\n \t  break;\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n \n       def_builtin (d->mask, d->name, type, d->code);\n@@ -7610,7 +7596,7 @@ altivec_init_builtins (void)\n \t  type = int_ftype_int_v4sf_v4sf;\n \t  break;\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n \n       def_builtin (dp->mask, dp->name, type, dp->code);\n@@ -7640,7 +7626,7 @@ altivec_init_builtins (void)\n \t  type = v4sf_ftype_v4sf;\n \t  break;\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n \n       def_builtin (d->mask, d->name, type, d->code);\n@@ -7886,7 +7872,7 @@ rs6000_common_init_builtins (void)\n \t      type = v16qi_ftype_v16qi_v16qi_v16qi;\n \t      break;\n \t    default:\n-\t      abort ();\n+\t      gcc_unreachable ();\n \t    }\n \t}\n       else if (mode0 == mode1 && mode1 == mode2 && mode3 == V16QImode)\n@@ -7906,7 +7892,7 @@ rs6000_common_init_builtins (void)\n \t      type = v16qi_ftype_v16qi_v16qi_v16qi;\n \t      break;\n \t    default:\n-\t      abort ();\n+\t      gcc_unreachable ();\n \t    }\n \t}\n       else if (mode0 == V4SImode && mode1 == V16QImode && mode2 == V16QImode\n@@ -7940,7 +7926,7 @@ rs6000_common_init_builtins (void)\n \ttype = v4sf_ftype_v4sf_v4sf_int;\n \n       else\n-\tabort ();\n+\tgcc_unreachable ();\n \n       def_builtin (d->mask, d->name, type, d->code);\n     }\n@@ -7986,7 +7972,7 @@ rs6000_common_init_builtins (void)\n \t      type = int_ftype_int_int;\n \t      break;\n \t    default:\n-\t      abort ();\n+\t      gcc_unreachable ();\n \t    }\n \t}\n \n@@ -8053,9 +8039,10 @@ rs6000_common_init_builtins (void)\n       else if (mode0 == V2SImode && mode1 == SImode && mode2 == QImode)\n \ttype = v2si_ftype_int_char;\n \n-      /* int, x, x.  */\n-      else if (mode0 == SImode)\n+      else\n \t{\n+\t  /* int, x, x.  */\n+\t  gcc_assert (mode0 == SImode);\n \t  switch (mode1)\n \t    {\n \t    case V4SImode:\n@@ -8071,13 +8058,10 @@ rs6000_common_init_builtins (void)\n \t      type = int_ftype_v8hi_v8hi;\n \t      break;\n \t    default:\n-\t      abort ();\n+\t      gcc_unreachable ();\n \t    }\n \t}\n \n-      else\n-\tabort ();\n-\n       def_builtin (d->mask, d->name, type, d->code);\n     }\n \n@@ -8117,7 +8101,7 @@ rs6000_common_init_builtins (void)\n       else if (mode0 == V2SImode && mode1 == QImode)\n \ttype = v2si_ftype_char;\n       else\n-\tabort ();\n+\tgcc_unreachable ();\n \n       def_builtin (d->mask, d->name, type, d->code);\n     }\n@@ -8210,9 +8194,8 @@ expand_block_clear (rtx operands[])\n   if (! constp)\n     return 0;\n \n-  /* If this is not a fixed size alignment, abort */\n-  if (GET_CODE (align_rtx) != CONST_INT)\n-    abort ();\n+  /* This must be a fixed size alignment  */\n+  gcc_assert (GET_CODE (align_rtx) == CONST_INT);\n   align = INTVAL (align_rtx) * BITS_PER_UNIT;\n \n   /* Anything to clear? */\n@@ -8308,9 +8291,8 @@ expand_block_move (rtx operands[])\n   if (! constp)\n     return 0;\n \n-  /* If this is not a fixed size alignment, abort */\n-  if (GET_CODE (align_rtx) != CONST_INT)\n-    abort ();\n+  /* This must be a fixed size alignment */\n+  gcc_assert (GET_CODE (align_rtx) == CONST_INT);\n   align = INTVAL (align_rtx) * BITS_PER_UNIT;\n \n   /* Anything to move? */\n@@ -8526,40 +8508,33 @@ rs6000_output_load_multiple (rtx operands[3])\n void\n validate_condition_mode (enum rtx_code code, enum machine_mode mode)\n {\n-  if ((GET_RTX_CLASS (code) != RTX_COMPARE\n-       && GET_RTX_CLASS (code) != RTX_COMM_COMPARE)\n-      || GET_MODE_CLASS (mode) != MODE_CC)\n-    abort ();\n+  gcc_assert ((GET_RTX_CLASS (code) == RTX_COMPARE\n+\t       || GET_RTX_CLASS (code) == RTX_COMM_COMPARE)\n+\t      && GET_MODE_CLASS (mode) == MODE_CC);\n \n   /* These don't make sense.  */\n-  if ((code == GT || code == LT || code == GE || code == LE)\n-      && mode == CCUNSmode)\n-    abort ();\n+  gcc_assert ((code != GT && code != LT && code != GE && code != LE)\n+\t      || mode != CCUNSmode);\n \n-  if ((code == GTU || code == LTU || code == GEU || code == LEU)\n-      && mode != CCUNSmode)\n-    abort ();\n+  gcc_assert ((code != GTU && code != LTU && code != GEU && code != LEU)\n+\t      || mode == CCUNSmode);\n \n-  if (mode != CCFPmode\n-      && (code == ORDERED || code == UNORDERED\n-\t  || code == UNEQ || code == LTGT\n-\t  || code == UNGT || code == UNLT\n-\t  || code == UNGE || code == UNLE))\n-    abort ();\n+  gcc_assert (mode == CCFPmode\n+\t      || (code != ORDERED && code != UNORDERED\n+\t\t  && code != UNEQ && code != LTGT\n+\t\t  && code != UNGT && code != UNLT\n+\t\t  && code != UNGE && code != UNLE));\n \n   /* These should never be generated except for\n      flag_finite_math_only.  */\n-  if (mode == CCFPmode\n-      && ! flag_finite_math_only\n-      && (code == LE || code == GE\n-\t  || code == UNEQ || code == LTGT\n-\t  || code == UNGT || code == UNLT))\n-    abort ();\n+  gcc_assert (mode != CCFPmode\n+\t      || flag_finite_math_only\n+\t      || (code != LE && code != GE\n+\t\t  && code != UNEQ && code != LTGT\n+\t\t  && code != UNGT && code != UNLT));\n \n   /* These are invalid; the information is not there.  */\n-  if (mode == CCEQmode\n-      && code != EQ && code != NE)\n-    abort ();\n+  gcc_assert (mode != CCEQmode || code == EQ || code == NE);\n }\n \n \f\n@@ -8954,9 +8929,7 @@ ccr_bit (rtx op, int scc_p)\n \n   reg = XEXP (op, 0);\n \n-  if (GET_CODE (reg) != REG\n-      || ! CR_REGNO_P (REGNO (reg)))\n-    abort ();\n+  gcc_assert (GET_CODE (reg) == REG && CR_REGNO_P (REGNO (reg)));\n \n   cc_mode = GET_MODE (reg);\n   cc_regnum = REGNO (reg);\n@@ -8966,9 +8939,9 @@ ccr_bit (rtx op, int scc_p)\n \n   /* When generating a sCOND operation, only positive conditions are\n      allowed.  */\n-  if (scc_p && code != EQ && code != GT && code != LT && code != UNORDERED\n-      && code != GTU && code != LTU)\n-    abort ();\n+  gcc_assert (!scc_p\n+\t      || code == EQ || code == GT || code == LT || code == UNORDERED\n+\t      || code == GTU || code == LTU);\n \n   switch (code)\n     {\n@@ -8993,7 +8966,7 @@ ccr_bit (rtx op, int scc_p)\n       return scc_p ? base_bit + 3 : base_bit + 1;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \f\n@@ -9041,8 +9014,7 @@ extract_MB (rtx op)\n      from the left.  */\n   if ((val & 0x80000000) == 0)\n     {\n-      if ((val & 0xffffffff) == 0)\n-\tabort ();\n+      gcc_assert (val & 0xffffffff);\n \n       i = 1;\n       while (((val <<= 1) & 0x80000000) == 0)\n@@ -9074,8 +9046,7 @@ extract_ME (rtx op)\n      the right.  */\n   if ((val & 1) == 0)\n     {\n-      if ((val & 0xffffffff) == 0)\n-\tabort ();\n+      gcc_assert (val & 0xffffffff);\n \n       i = 30;\n       while (((val >>= 1) & 1) == 0)\n@@ -9115,7 +9086,7 @@ rs6000_get_some_local_dynamic_name (void)\n \t\t\t rs6000_get_some_local_dynamic_name_1, 0))\n       return cfun->machine->some_ld_name;\n \n-  abort ();\n+  gcc_unreachable ();\n }\n \n /* Helper function for rs6000_get_some_local_dynamic_name.  */\n@@ -9148,7 +9119,7 @@ rs6000_output_function_entry (FILE *file, const char *fname)\n       switch (DEFAULT_ABI)\n \t{\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \n \tcase ABI_AIX:\n \t  if (DOT_SYMBOLS)\n@@ -9234,8 +9205,7 @@ print_operand (FILE *file, rtx x, int code)\n \n     case 'D':\n       /* Like 'J' but get to the EQ bit.  */\n-      if (GET_CODE (x) != REG)\n-\tabort ();\n+      gcc_assert (GET_CODE (x) == REG);\n \n       /* Bit 1 is EQ bit.  */\n       i = 4 * (REGNO (x) - CR0_REGNO) + 2;\n@@ -9527,15 +9497,13 @@ print_operand (FILE *file, rtx x, int code)\n \t}\n       while (uval != 0)\n \t--i, uval >>= 1;\n-      if (i < 0)\n-\tabort ();\n+      gcc_assert (i >= 0);\n       fprintf (file, \"%d\", i);\n       return;\n \n     case 't':\n       /* Like 'J' but get to the OVERFLOW/UNORDERED bit.  */\n-      if (GET_CODE (x) != REG || GET_MODE (x) != CCmode)\n-\tabort ();\n+      gcc_assert (GET_CODE (x) == REG && GET_MODE (x) == CCmode);\n \n       /* Bit 3 is OV bit.  */\n       i = 4 * (REGNO (x) - CR0_REGNO) + 3;\n@@ -9616,7 +9584,7 @@ print_operand (FILE *file, rtx x, int code)\n \t  fputs (\"lge\", file);  /* 5 */\n \t  break;\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n       break;\n \n@@ -9649,9 +9617,8 @@ print_operand (FILE *file, rtx x, int code)\n \t{\n \t  val = CONST_DOUBLE_LOW (x);\n \n-\t  if (val == 0)\n-\t    abort ();\n-\t  else if (val < 0)\n+\t  gcc_assert (val);\n+\t  if (val < 0)\n \t    --i;\n \t  else\n \t    for ( ; i < 64; i++)\n@@ -9692,8 +9659,7 @@ print_operand (FILE *file, rtx x, int code)\n \t names.  If we are configured for System V (or the embedded ABI) on\n \t the PowerPC, do not emit the period, since those systems do not use\n \t TOCs and the like.  */\n-      if (GET_CODE (x) != SYMBOL_REF)\n-\tabort ();\n+      gcc_assert (GET_CODE (x) == SYMBOL_REF);\n \n       /* Mark the decl as referenced so that cgraph will output the\n \t function.  */\n@@ -9739,8 +9705,7 @@ print_operand (FILE *file, rtx x, int code)\n       {\n \trtx tmp;\n \n-\tif (GET_CODE (x) != MEM)\n-\t  abort ();\n+\tgcc_assert (GET_CODE (x) == MEM);\n \n \ttmp = XEXP (x, 0);\n \n@@ -9758,8 +9723,7 @@ print_operand (FILE *file, rtx x, int code)\n \t      {\n \t\tint x;\n \n-\t\tif (GET_CODE (XEXP (tmp, 0)) != REG)\n-\t\t  abort ();\n+\t\tgcc_assert (GET_CODE (XEXP (tmp, 0)) == REG);\n \n \t\tx = INTVAL (XEXP (tmp, 1));\n \t\tfprintf (file, \"%d(%s)\", x, reg_names[REGNO (XEXP (tmp, 0))]);\n@@ -9775,17 +9739,18 @@ print_operand (FILE *file, rtx x, int code)\n \t  tmp = XEXP (tmp, 0);\n \tif (GET_CODE (tmp) == REG)\n \t  fprintf (file, \"0,%s\", reg_names[REGNO (tmp)]);\n-\telse if (GET_CODE (tmp) == PLUS && GET_CODE (XEXP (tmp, 1)) == REG)\n+\telse\n \t  {\n+\t    gcc_assert (GET_CODE (tmp) == PLUS\n+\t\t\t&& GET_CODE (XEXP (tmp, 1)) == REG);\n+\t    \n \t    if (REGNO (XEXP (tmp, 0)) == 0)\n \t      fprintf (file, \"%s,%s\", reg_names[ REGNO (XEXP (tmp, 1)) ],\n \t\t       reg_names[ REGNO (XEXP (tmp, 0)) ]);\n \t    else\n \t      fprintf (file, \"%s,%s\", reg_names[ REGNO (XEXP (tmp, 0)) ],\n \t\t       reg_names[ REGNO (XEXP (tmp, 1)) ]);\n \t  }\n-\telse\n-\t  abort ();\n \tbreak;\n       }\n \n@@ -9832,8 +9797,8 @@ print_operand_address (FILE *file, rtx x)\n       if (small_data_operand (x, GET_MODE (x)))\n \tfprintf (file, \"@%s(%s)\", SMALL_DATA_RELOC,\n \t\t reg_names[SMALL_DATA_REG]);\n-      else if (TARGET_TOC)\n-\tabort ();\n+      else\n+\tgcc_assert (!TARGET_TOC);\n     }\n   else if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 1)) == REG)\n     {\n@@ -9901,7 +9866,7 @@ print_operand_address (FILE *file, rtx x)\n       fprintf (file, \"(%s)\", reg_names[REGNO (XEXP (x, 0))]);\n     }\n   else\n-    abort ();\n+    gcc_unreachable ();\n }\n \f\n /* Target hook for assembling integer objects.  The PowerPC version has\n@@ -10057,52 +10022,78 @@ rs6000_generate_compare (enum rtx_code code)\n       switch (code)\n \t{\n \tcase EQ: case UNEQ: case NE: case LTGT:\n-\t  if (op_mode == SFmode)\n-\t    cmp = flag_unsafe_math_optimizations\n-\t      ? gen_tstsfeq_gpr (compare_result, rs6000_compare_op0,\n-\t\t\t\t rs6000_compare_op1)\n-\t      : gen_cmpsfeq_gpr (compare_result, rs6000_compare_op0,\n-\t\t\t\t rs6000_compare_op1);\n-\t  else if (op_mode == DFmode)\n-\t    cmp = flag_unsafe_math_optimizations\n-\t      ? gen_tstdfeq_gpr (compare_result, rs6000_compare_op0,\n-\t\t\t\t rs6000_compare_op1)\n-\t      : gen_cmpdfeq_gpr (compare_result, rs6000_compare_op0,\n-\t\t\t\t rs6000_compare_op1);\n-\t  else abort ();\n+\t  switch (op_mode)\n+\t    {\n+\t    case SFmode:\n+\t      cmp = flag_unsafe_math_optimizations\n+\t\t? gen_tstsfeq_gpr (compare_result, rs6000_compare_op0,\n+\t\t\t\t   rs6000_compare_op1)\n+\t\t: gen_cmpsfeq_gpr (compare_result, rs6000_compare_op0,\n+\t\t\t\t   rs6000_compare_op1);\n+\t      break;\n+\n+\t    case DFmode:\n+\t      cmp = flag_unsafe_math_optimizations\n+\t\t? gen_tstdfeq_gpr (compare_result, rs6000_compare_op0,\n+\t\t\t\t   rs6000_compare_op1)\n+\t\t: gen_cmpdfeq_gpr (compare_result, rs6000_compare_op0,\n+\t\t\t\t   rs6000_compare_op1);\n+\t      break;\n+\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n \t  break;\n+\t  \n \tcase GT: case GTU: case UNGT: case UNGE: case GE: case GEU:\n-\t  if (op_mode == SFmode)\n-\t    cmp = flag_unsafe_math_optimizations\n-\t      ? gen_tstsfgt_gpr (compare_result, rs6000_compare_op0,\n-\t\t\t\t rs6000_compare_op1)\n-\t      : gen_cmpsfgt_gpr (compare_result, rs6000_compare_op0,\n-\t\t\t\t rs6000_compare_op1);\n-\t  else if (op_mode == DFmode)\n-\t    cmp = flag_unsafe_math_optimizations\n-\t      ? gen_tstdfgt_gpr (compare_result, rs6000_compare_op0,\n-\t\t\t\t rs6000_compare_op1)\n-\t      : gen_cmpdfgt_gpr (compare_result, rs6000_compare_op0,\n-\t\t\t\t rs6000_compare_op1);\n-\t  else abort ();\n+\t  switch (op_mode)\n+\t    {\n+\t    case SFmode:\n+\t      cmp = flag_unsafe_math_optimizations\n+\t\t? gen_tstsfgt_gpr (compare_result, rs6000_compare_op0,\n+\t\t\t\t   rs6000_compare_op1)\n+\t\t: gen_cmpsfgt_gpr (compare_result, rs6000_compare_op0,\n+\t\t\t\t   rs6000_compare_op1);\n+\t      break;\n+\t      \n+\t    case DFmode:\n+\t      cmp = flag_unsafe_math_optimizations\n+\t\t? gen_tstdfgt_gpr (compare_result, rs6000_compare_op0,\n+\t\t\t\t   rs6000_compare_op1)\n+\t\t: gen_cmpdfgt_gpr (compare_result, rs6000_compare_op0,\n+\t\t\t\t   rs6000_compare_op1);\n+\t      break;\n+\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n \t  break;\n+\t  \n \tcase LT: case LTU: case UNLT: case UNLE: case LE: case LEU:\n-\t  if (op_mode == SFmode)\n-\t    cmp = flag_unsafe_math_optimizations\n-\t      ? gen_tstsflt_gpr (compare_result, rs6000_compare_op0,\n-\t\t\t\t rs6000_compare_op1)\n-\t      : gen_cmpsflt_gpr (compare_result, rs6000_compare_op0,\n-\t\t\t\t rs6000_compare_op1);\n-\t  else if (op_mode == DFmode)\n-\t    cmp = flag_unsafe_math_optimizations\n-\t      ? gen_tstdflt_gpr (compare_result, rs6000_compare_op0,\n-\t\t\t\t rs6000_compare_op1)\n-\t      : gen_cmpdflt_gpr (compare_result, rs6000_compare_op0,\n-\t\t\t\t rs6000_compare_op1);\n-\t  else abort ();\n+\t  switch (op_mode)\n+\t    {\n+\t    case SFmode:\n+\t      cmp = flag_unsafe_math_optimizations\n+\t\t? gen_tstsflt_gpr (compare_result, rs6000_compare_op0,\n+\t\t\t\t   rs6000_compare_op1)\n+\t\t: gen_cmpsflt_gpr (compare_result, rs6000_compare_op0,\n+\t\t\t\t   rs6000_compare_op1);\n+\t      break;\n+\t      \n+\t    case DFmode:\n+\t      cmp = flag_unsafe_math_optimizations\n+\t\t? gen_tstdflt_gpr (compare_result, rs6000_compare_op0,\n+\t\t\t\t   rs6000_compare_op1)\n+\t\t: gen_cmpdflt_gpr (compare_result, rs6000_compare_op0,\n+\t\t\t\t   rs6000_compare_op1);\n+\t      break;\n+\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n \t  break;\n         default:\n-          abort ();\n+          gcc_unreachable ();\n \t}\n \n       /* Synthesize LE and GE from LT/GT || EQ.  */\n@@ -10116,25 +10107,33 @@ rs6000_generate_compare (enum rtx_code code)\n \t    case GE: code = GT; break;\n \t    case LEU: code = LT; break;\n \t    case GEU: code = GT; break;\n-\t    default: abort ();\n+\t    default: gcc_unreachable ();\n \t    }\n \n \t  compare_result2 = gen_reg_rtx (CCFPmode);\n \n \t  /* Do the EQ.  */\n-\t  if (op_mode == SFmode)\n-\t    cmp = flag_unsafe_math_optimizations\n-\t      ? gen_tstsfeq_gpr (compare_result2, rs6000_compare_op0,\n-\t\t\t\t rs6000_compare_op1)\n-\t      : gen_cmpsfeq_gpr (compare_result2, rs6000_compare_op0,\n-\t\t\t\t rs6000_compare_op1);\n-\t  else if (op_mode == DFmode)\n-\t    cmp = flag_unsafe_math_optimizations\n-\t      ? gen_tstdfeq_gpr (compare_result2, rs6000_compare_op0,\n-\t\t\t\t rs6000_compare_op1)\n-\t      : gen_cmpdfeq_gpr (compare_result2, rs6000_compare_op0,\n-\t\t\t\t rs6000_compare_op1);\n-\t  else abort ();\n+\t  switch (op_mode)\n+\t    {\n+\t    case SFmode:\n+\t      cmp = flag_unsafe_math_optimizations\n+\t\t? gen_tstsfeq_gpr (compare_result2, rs6000_compare_op0,\n+\t\t\t\t   rs6000_compare_op1)\n+\t\t: gen_cmpsfeq_gpr (compare_result2, rs6000_compare_op0,\n+\t\t\t\t   rs6000_compare_op1);\n+\t      break;\n+\n+\t    case DFmode:\n+\t      cmp = flag_unsafe_math_optimizations\n+\t\t? gen_tstdfeq_gpr (compare_result2, rs6000_compare_op0,\n+\t\t\t\t   rs6000_compare_op1)\n+\t\t: gen_cmpdfeq_gpr (compare_result2, rs6000_compare_op0,\n+\t\t\t\t   rs6000_compare_op1);\n+\t      break;\n+\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n \t  emit_insn (cmp);\n \n \t  /* OR them together.  */\n@@ -10205,7 +10204,7 @@ rs6000_generate_compare (enum rtx_code code)\n \tcase LTGT: or1 = LT;  or2 = GT;  break;\n \tcase UNGT: or1 = UNORDERED;  or2 = GT;  break;\n \tcase UNLT: or1 = UNORDERED;  or2 = LT;  break;\n-\tdefault:  abort ();\n+\tdefault:  gcc_unreachable ();\n \t}\n       validate_condition_mode (or1, comp_mode);\n       validate_condition_mode (or2, comp_mode);\n@@ -10246,8 +10245,7 @@ rs6000_emit_sCOND (enum rtx_code code, rtx result)\n       PUT_MODE (condition_rtx, SImode);\n       t = XEXP (condition_rtx, 0);\n \n-      if (cond_code != NE && cond_code != EQ)\n-\tabort ();\n+      gcc_assert (cond_code == NE || cond_code == EQ);\n \n       if (cond_code == NE)\n \temit_insn (gen_e500_flip_gt_bit (t, t));\n@@ -10350,13 +10348,20 @@ output_cbranch (rtx op, const char *label, int reversed, rtx insn)\n     {\n       /* The efscmp/tst* instructions twiddle bit 2, which maps nicely\n \t to the GT bit.  */\n-      if (code == EQ)\n-\t/* Opposite of GT.  */\n-\tcode = GT;\n-      else if (code == NE)\n-\tcode = UNLE;\n-      else\n-\tabort ();\n+      switch (code)\n+\t{\n+\tcase EQ:\n+\t  /* Opposite of GT.  */\n+\t  code = GT;\n+\t  break;\n+\n+\tcase NE:\n+\t  code = UNLE;\n+\t  break;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n     }\n \n   switch (code)\n@@ -10380,7 +10385,7 @@ output_cbranch (rtx op, const char *label, int reversed, rtx insn)\n     case UNGE: ccode = \"nl\"; break;\n     case UNLE: ccode = \"ng\"; break;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   /* Maybe we have a guess as to how likely the branch is.\n@@ -10440,9 +10445,8 @@ output_e500_flip_gt_bit (rtx dst, rtx src)\n   static char string[64];\n   int a, b;\n \n-  if (GET_CODE (dst) != REG || ! CR_REGNO_P (REGNO (dst))\n-      || GET_CODE (src) != REG || ! CR_REGNO_P (REGNO (src)))\n-    abort ();\n+  gcc_assert (GET_CODE (dst) == REG && CR_REGNO_P (REGNO (dst))\n+\t      && GET_CODE (src) == REG && CR_REGNO_P (REGNO (src)));\n \n   /* GT bit.  */\n   a = 4 * (REGNO (dst) - CR0_REGNO) + 1;\n@@ -10516,13 +10520,8 @@ rs6000_emit_vector_compare (enum rtx_code rcode,\n   enum machine_mode dest_mode;\n   enum machine_mode op_mode = GET_MODE (op1);\n \n-#ifdef ENABLE_CHECKING\n-  if (!TARGET_ALTIVEC)\n-    abort ();\n-\n-  if (GET_MODE (op0) != GET_MODE (op1))\n-    abort ();\n-#endif\n+  gcc_assert (TARGET_ALTIVEC);\n+  gcc_assert (GET_MODE (op0) == GET_MODE (op1));\n \n   /* Floating point vector compare instructions uses destination V4SImode.\n      Move destination to appropriate mode later.  */\n@@ -10558,8 +10557,7 @@ rs6000_emit_vector_compare (enum rtx_code rcode,\n \t\t\t\t\t\t     dest_mode);\n \n \t    nor_code = one_cmpl_optab->handlers[(int)dest_mode].insn_code;\n-\t    if (nor_code == CODE_FOR_nothing)\n-\t      abort ();\n+\t    gcc_assert (nor_code != CODE_FOR_nothing);\n \t    emit_insn (GEN_FCN (nor_code) (mask, eq_rtx));\n \n \t    if (dmode != dest_mode)\n@@ -10581,25 +10579,35 @@ rs6000_emit_vector_compare (enum rtx_code rcode,\n \t    enum insn_code ior_code;\n \t    enum rtx_code new_code;\n \n-\t    if (rcode == GE)\n-\t      new_code = GT;\n-\t    else if (rcode == GEU)\n-\t      new_code = GTU;\n-\t    else if (rcode == LE)\n-\t      new_code = LT;\n-\t    else if (rcode == LEU)\n-\t      new_code = LTU;\n-\t    else\n-\t      abort ();\n+\t    switch (rcode)\n+\t      {\n+\t      case  GE:\n+\t\tnew_code = GT;\n+\t\tbreak;\n+\n+\t      case GEU:\n+\t\tnew_code = GTU;\n+\t\tbreak;\n+\n+\t      case LE:\n+\t\tnew_code = LT;\n+\t\tbreak;\n+\n+\t      case LEU:\n+\t\tnew_code = LTU;\n+\t\tbreak;\n+\n+\t      default:\n+\t\tgcc_unreachable ();\n+\t      }\n \n \t    c_rtx = rs6000_emit_vector_compare (new_code,\n \t\t\t\t\t\top0, op1, dest_mode);\n \t    eq_rtx = rs6000_emit_vector_compare (EQ, op0, op1,\n \t\t\t\t\t\t dest_mode);\n \n \t    ior_code = ior_optab->handlers[(int)dest_mode].insn_code;\n-\t    if (ior_code == CODE_FOR_nothing)\n-\t      abort ();\n+\t    gcc_assert (ior_code != CODE_FOR_nothing);\n \t    emit_insn (GEN_FCN (ior_code) (mask, c_rtx, eq_rtx));\n \t    if (dmode != dest_mode)\n \t      {\n@@ -10611,15 +10619,14 @@ rs6000_emit_vector_compare (enum rtx_code rcode,\n \t  }\n \t  break;\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n \n       if (try_again)\n \t{\n \t  vec_cmp_insn = get_vec_cmp_insn (rcode, dest_mode, op_mode);\n-\t  if (vec_cmp_insn == INSN_NOT_AVAILABLE)\n-\t    /* You only get two chances.  */\n-\t    abort ();\n+\t  /* You only get two chances.  */\n+\t  gcc_assert (vec_cmp_insn != INSN_NOT_AVAILABLE);\n \t}\n \n       if (swap_operands)\n@@ -10892,7 +10899,7 @@ rs6000_emit_cmove (rtx dest, rtx op, rtx true_cond, rtx false_cond)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   emit_insn (gen_rtx_SET (VOIDmode, dest,\n@@ -10963,8 +10970,7 @@ rs6000_emit_minmax (rtx dest, enum rtx_code code, rtx op0, rtx op1)\n   else\n     target = emit_conditional_move (dest, c, op0, op1, mode,\n \t\t\t\t    op1, op0, mode, 0);\n-  if (target == NULL_RTX)\n-    abort ();\n+  gcc_assert (target);\n   if (target != dest)\n     emit_move_insn (dest, target);\n }\n@@ -11176,8 +11182,7 @@ rs6000_split_multireg_move (rtx dst, rtx src)\n     reg_mode = word_mode;\n   reg_mode_size = GET_MODE_SIZE (reg_mode);\n \n-  if (reg_mode_size * nregs != GET_MODE_SIZE (mode))\n-    abort ();\n+  gcc_assert (reg_mode_size * nregs == GET_MODE_SIZE (mode));\n \n   if (REG_P (src) && REG_P (dst) && (REGNO (src) < REGNO (dst)))\n     {\n@@ -11268,8 +11273,8 @@ rs6000_split_multireg_move (rtx dst, rtx src)\n \t\t\t   : gen_adddi3 (breg, breg, delta_rtx));\n \t      dst = gen_rtx_MEM (mode, breg);\n \t    }\n-\t  else if (! offsettable_memref_p (dst))\n-\t    abort ();\n+\t  else\n+\t    gcc_assert (offsettable_memref_p (dst));\n \t}\n \n       for (i = 0; i < nregs; i++)\n@@ -11440,9 +11445,9 @@ compute_save_world_info (rs6000_stack_t *info_ptr)\n       /* Because the Darwin register save/restore routines only handle\n \t F14 .. F31 and V20 .. V31 as per the ABI, perform a consistency\n \t check and abort if there's something worng.  */\n-      if (info_ptr->first_fp_reg_save < FIRST_SAVED_FP_REGNO\n-\t  || info_ptr->first_altivec_reg_save < FIRST_SAVED_ALTIVEC_REGNO)\n-\tabort ();\n+      gcc_assert (info_ptr->first_fp_reg_save >= FIRST_SAVED_FP_REGNO\n+\t\t  && (info_ptr->first_altivec_reg_save\n+\t\t      >= FIRST_SAVED_ALTIVEC_REGNO));\n     }\n   return;\n }\n@@ -11695,7 +11700,7 @@ rs6000_stack_info (void)\n     {\n     case ABI_NONE:\n     default:\n-      abort ();\n+      gcc_unreachable ();\n \n     case ABI_AIX:\n     case ABI_DARWIN:\n@@ -12245,17 +12250,17 @@ rs6000_emit_load_toc_table (int fromprolog)\n       if (fromprolog)\n \trs6000_maybe_dead (insn);\n     }\n-  else if (DEFAULT_ABI == ABI_AIX)\n+  else\n     {\n+      gcc_assert (DEFAULT_ABI == ABI_AIX);\n+      \n       if (TARGET_32BIT)\n \tinsn = emit_insn (gen_load_toc_aix_si (dest));\n       else\n \tinsn = emit_insn (gen_load_toc_aix_di (dest));\n       if (fromprolog)\n \trs6000_maybe_dead (insn);\n     }\n-  else\n-    abort ();\n }\n \n /* Emit instructions to restore the link register after determining where\n@@ -12538,9 +12543,11 @@ rs6000_frame_related (rtx insn, rtx reg, HOST_WIDE_INT val,\n \t    XEXP (SET_DEST (set), 0) = temp;\n \t}\n     }\n-  else if (GET_CODE (real) == PARALLEL)\n+  else\n     {\n       int i;\n+\n+      gcc_assert (GET_CODE (real) == PARALLEL);\n       for (i = 0; i < XVECLEN (real, 0); i++)\n \tif (GET_CODE (XVECEXP (real, 0, i)) == SET)\n \t  {\n@@ -12561,8 +12568,6 @@ rs6000_frame_related (rtx insn, rtx reg, HOST_WIDE_INT val,\n \t    RTX_FRAME_RELATED_P (set) = 1;\n \t  }\n     }\n-  else\n-    abort ();\n \n   if (TARGET_SPE)\n     real = spe_synthesize_frame_save (real);\n@@ -12591,10 +12596,9 @@ spe_synthesize_frame_save (rtx real)\n      This is so we can differentiate between 64-bit and 32-bit saves.\n      Words cannot describe this nastiness.  */\n \n-  if (GET_CODE (SET_DEST (real)) != MEM\n-      || GET_CODE (XEXP (SET_DEST (real), 0)) != PLUS\n-      || GET_CODE (SET_SRC (real)) != REG)\n-    abort ();\n+  gcc_assert (GET_CODE (SET_DEST (real)) == MEM\n+\t      && GET_CODE (XEXP (SET_DEST (real), 0)) == PLUS\n+\t      && GET_CODE (SET_SRC (real)) == REG);\n \n   /* Transform:\n        (set (mem (plus (reg x) (const y)))\n@@ -12849,16 +12853,16 @@ rs6000_emit_prologue (void)\n       /* The SAVE_WORLD and RESTORE_WORLD routines make a number of\n \t assumptions about the offsets of various bits of the stack\n \t frame.  Abort if things aren't what they should be.  */\n-      if (info->gp_save_offset != -220\n-\t  || info->fp_save_offset != -144\n-\t  || info->lr_save_offset != 8\n-\t  || info->cr_save_offset != 4\n-\t  || !info->push_p\n-\t  || !info->lr_save_p\n-\t  || (current_function_calls_eh_return && info->ehrd_offset != -432)\n-\t  || (info->vrsave_save_offset != -224\n-\t      || info->altivec_save_offset != (-224 -16 -192)))\n-\tabort ();\n+      gcc_assert (info->gp_save_offset == -220\n+\t\t  && info->fp_save_offset == -144\n+\t\t  && info->lr_save_offset == 8\n+\t\t  && info->cr_save_offset == 4\n+\t\t  && info->push_p\n+\t\t  && info->lr_save_p\n+\t\t  && (!current_function_calls_eh_return\n+\t\t       || info->ehrd_offset == -432)\n+\t\t  && info->vrsave_save_offset == -224\n+\t\t  && info->altivec_save_offset == (-224 -16 -192));\n \n       treg = gen_rtx_REG (SImode, 11);\n       emit_move_insn (treg, GEN_INT (-info->total_size));\n@@ -13752,8 +13756,7 @@ rs6000_emit_epilogue (int sibcall)\n \t  for (i = 0; i < 8; i++)\n \t    if (regs_ever_live[CR0_REGNO+i] && ! call_used_regs[CR0_REGNO+i])\n \t      count++;\n-\t  if (count == 0)\n-\t    abort ();\n+\t  gcc_assert (count);\n \t}\n \n       if (using_mfcr_multiple && count > 1)\n@@ -13776,8 +13779,7 @@ rs6000_emit_epilogue (int sibcall)\n \t\tndx++;\n \t      }\n \t  emit_insn (gen_rtx_PARALLEL (VOIDmode, p));\n-\t  if (ndx != count)\n-\t    abort ();\n+\t  gcc_assert (ndx == count);\n \t}\n       else\n \tfor (i = 0; i < 8; i++)\n@@ -14012,7 +14014,7 @@ rs6000_output_function_epilogue (FILE *file,\n       else if (! strcmp (language_string, \"GNU Objective-C\"))\n \ti = 14;\n       else\n-\tabort ();\n+\tgcc_unreachable ();\n       fprintf (file, \"%d,\", i);\n \n       /* 8 single bit fields: global linkage (not set for C extern linkage,\n@@ -14065,12 +14067,20 @@ rs6000_output_function_epilogue (FILE *file,\n \n \t\t      float_parms++;\n \n-\t\t      if (mode == SFmode)\n-\t\t\tbits = 0x2;\n-\t\t      else if (mode == DFmode || mode == TFmode)\n-\t\t\tbits = 0x3;\n-\t\t      else\n-\t\t\tabort ();\n+\t\t      switch (mode)\n+\t\t\t{\n+\t\t\tcase SFmode:\n+\t\t\t  bits = 0x2;\n+\t\t\t  break;\n+\n+\t\t\tcase DFmode:\n+\t\t\tcase TFmode:\n+\t\t\t  bits = 0x3;\n+\t\t\t  break;\n+\n+\t\t\tdefault:\n+\t\t\t  gcc_unreachable ();\n+\t\t\t}\n \n \t\t      /* If only one bit will fit, don't or in this entry.  */\n \t\t      if (next_parm_info_bit > 0)\n@@ -14384,7 +14394,7 @@ rs6000_hash_constant (rtx k)\n       case '0':\n \tbreak;\n       default:\n-\tabort ();\n+\tgcc_unreachable ();\n       }\n \n   return result;\n@@ -14456,8 +14466,7 @@ output_toc (FILE *file, rtx x, int labelno, enum machine_mode mode)\n   rtx base = x;\n   int offset = 0;\n \n-  if (TARGET_NO_TOC)\n-    abort ();\n+  gcc_assert (!TARGET_NO_TOC);\n \n   /* When the linker won't eliminate them, don't output duplicate\n      TOC entries (this happens on AIX if there is any kind of TOC,\n@@ -14636,8 +14645,8 @@ output_toc (FILE *file, rtx x, int labelno, enum machine_mode mode)\n \t For a 32-bit target, CONST_INT values are loaded and shifted\n \t entirely within `low' and can be stored in one TOC entry.  */\n \n-      if (TARGET_64BIT && POINTER_SIZE < GET_MODE_BITSIZE (mode))\n-\tabort ();/* It would be easy to make this work, but it doesn't now.  */\n+      /* It would be easy to make this work, but it doesn't now.  */\n+      gcc_assert (!TARGET_64BIT || POINTER_SIZE >= GET_MODE_BITSIZE (mode));\n \n       if (POINTER_SIZE > GET_MODE_BITSIZE (mode))\n \t{\n@@ -14689,21 +14698,30 @@ output_toc (FILE *file, rtx x, int labelno, enum machine_mode mode)\n \n   if (GET_CODE (x) == CONST)\n     {\n-      if (GET_CODE (XEXP (x, 0)) != PLUS)\n-\tabort ();\n+      gcc_assert (GET_CODE (XEXP (x, 0)) == PLUS);\n \n       base = XEXP (XEXP (x, 0), 0);\n       offset = INTVAL (XEXP (XEXP (x, 0), 1));\n     }\n \n-  if (GET_CODE (base) == SYMBOL_REF)\n-    name = XSTR (base, 0);\n-  else if (GET_CODE (base) == LABEL_REF)\n-    ASM_GENERATE_INTERNAL_LABEL (buf, \"L\", CODE_LABEL_NUMBER (XEXP (base, 0)));\n-  else if (GET_CODE (base) == CODE_LABEL)\n-    ASM_GENERATE_INTERNAL_LABEL (buf, \"L\", CODE_LABEL_NUMBER (base));\n-  else\n-    abort ();\n+  switch (GET_CODE (base))\n+    {\n+    case SYMBOL_REF:\n+      name = XSTR (base, 0);\n+      break;\n+\n+    case LABEL_REF:\n+      ASM_GENERATE_INTERNAL_LABEL (buf, \"L\",\n+\t\t\t\t   CODE_LABEL_NUMBER (XEXP (base, 0)));\n+      break;\n+\n+    case CODE_LABEL:\n+      ASM_GENERATE_INTERNAL_LABEL (buf, \"L\", CODE_LABEL_NUMBER (base));\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n \n   real_name = (*targetm.strip_name_encoding) (name);\n   if (TARGET_MINIMAL_TOC)\n@@ -14921,7 +14939,7 @@ output_function_profiler (FILE *file, int labelno)\n   switch (DEFAULT_ABI)\n     {\n     default:\n-      abort ();\n+      gcc_unreachable ();\n \n     case ABI_V4:\n       save_lr = 4;\n@@ -14981,8 +14999,7 @@ output_function_profiler (FILE *file, int labelno)\n \t}\n       else\n \t{\n-\t  if (TARGET_32BIT)\n-\t    abort ();\n+\t  gcc_assert (!TARGET_32BIT);\n \n \t  asm_fprintf (file, \"\\tmflr %s\\n\", reg_names[0]);\n \t  asm_fprintf (file, \"\\tstd %s,16(%s)\\n\", reg_names[0], reg_names[1]);\n@@ -15900,7 +15917,7 @@ rs6000_trampoline_size (void)\n   switch (DEFAULT_ABI)\n     {\n     default:\n-      abort ();\n+      gcc_unreachable ();\n \n     case ABI_AIX:\n       ret = (TARGET_32BIT) ? 12 : 24;\n@@ -15929,7 +15946,7 @@ rs6000_initialize_trampoline (rtx addr, rtx fnaddr, rtx cxt)\n   switch (DEFAULT_ABI)\n     {\n     default:\n-      abort ();\n+      gcc_unreachable ();\n \n /* Macros to shorten the code expansions below.  */\n #define MEM_DEREF(addr) gen_rtx_MEM (pmode, memory_address (pmode, addr))\n@@ -16309,11 +16326,10 @@ find_addr_reg (rtx addr)\n       else if (CONSTANT_P (XEXP (addr, 1)))\n \taddr = XEXP (addr, 0);\n       else\n-\tabort ();\n+\tgcc_unreachable ();\n     }\n-  if (GET_CODE (addr) == REG && REGNO (addr) != 0)\n-    return addr;\n-  abort ();\n+  gcc_assert (GET_CODE (addr) == REG && REGNO (addr) != 0);\n+  return addr;\n }\n \n void\n@@ -16586,26 +16602,23 @@ rs6000_machopic_legitimize_pic_address (rtx orig, enum machine_mode mode,\n \n   if (GET_CODE (orig) == CONST)\n     {\n+      rtx reg_temp;\n+\n       if (GET_CODE (XEXP (orig, 0)) == PLUS\n \t  && XEXP (XEXP (orig, 0), 0) == pic_offset_table_rtx)\n \treturn orig;\n \n-      if (GET_CODE (XEXP (orig, 0)) == PLUS)\n-\t{\n-\t  /* Use a different reg for the intermediate value, as\n-\t     it will be marked UNCHANGING.  */\n-\t  rtx reg_temp = no_new_pseudos ? reg : gen_reg_rtx (Pmode);\n-\n-\t  base =\n-\t    rs6000_machopic_legitimize_pic_address (XEXP (XEXP (orig, 0), 0),\n-\t\t\t\t\t\t    Pmode, reg_temp);\n-\t  offset =\n-\t    rs6000_machopic_legitimize_pic_address (XEXP (XEXP (orig, 0), 1),\n-\t\t\t\t\t\t    Pmode, reg);\n-\t}\n-      else\n-\tabort ();\n-\n+      gcc_assert (GET_CODE (XEXP (orig, 0)) == PLUS);\n+      \n+      /* Use a different reg for the intermediate value, as\n+\t it will be marked UNCHANGING.  */\n+      reg_temp = no_new_pseudos ? reg : gen_reg_rtx (Pmode);\n+      base = rs6000_machopic_legitimize_pic_address (XEXP (XEXP (orig, 0), 0),\n+\t\t\t\t\t\t     Pmode, reg_temp);\n+      offset =\n+\trs6000_machopic_legitimize_pic_address (XEXP (XEXP (orig, 0), 1),\n+\t\t\t\t\t\tPmode, reg);\n+      \n       if (GET_CODE (offset) == CONST_INT)\n \t{\n \t  if (SMALL_INT (offset))\n@@ -17611,7 +17624,7 @@ rs6000_initial_elimination_offset (int from, int to)\n   else if (from == RS6000_PIC_OFFSET_TABLE_REGNUM)\n     offset = 0;\n   else\n-    abort ();\n+    gcc_unreachable ();\n \n   return offset;\n }\n@@ -17684,10 +17697,8 @@ rs6000_dbx_register_number (unsigned int regno)\n     return 612;\n   /* SPE high reg number.  We get these values of regno from\n      rs6000_dwarf_register_span.  */\n-  if (regno >= 1200 && regno < 1232)\n-    return regno;\n-\n-  abort ();\n+  gcc_assert (regno >= 1200 && regno < 1232);\n+  return regno;\n }\n \n /* target hook eh_return_filter_mode */"}, {"sha": "137e6dd2c61ddb27e95cd83a50bacc6801867fa8", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/374097963cec9c1142faf10b819aa28d1fb6f641/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/374097963cec9c1142faf10b819aa28d1fb6f641/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=374097963cec9c1142faf10b819aa28d1fb6f641", "patch": "@@ -1393,7 +1393,7 @@ enum reg_class\n \n    We also don't want to reload integer values into floating-point\n    registers if we can at all help it.  In fact, this can\n-   cause reload to abort, if it tries to generate a reload of CTR\n+   cause reload to die, if it tries to generate a reload of CTR\n    into a FP register and discovers it doesn't have the memory location\n    required.\n "}, {"sha": "c40731ca7bad6c926090851e4d643ba0af4c981d", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 36, "deletions": 34, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/374097963cec9c1142faf10b819aa28d1fb6f641/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/374097963cec9c1142faf10b819aa28d1fb6f641/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=374097963cec9c1142faf10b819aa28d1fb6f641", "patch": "@@ -5194,8 +5194,7 @@\n   \"\n {\n   rtx lowword, highword;\n-  if (GET_CODE (operands[4]) != MEM)\n-    abort();\n+  gcc_assert (GET_CODE (operands[4]) == MEM);\n   highword = XEXP (operands[4], 0);\n   lowword = plus_constant (highword, 4);\n   if (! WORDS_BIG_ENDIAN)\n@@ -5278,8 +5277,7 @@\n   \"\n {\n   rtx lowword, highword;\n-  if (GET_CODE (operands[4]) != MEM)\n-    abort();\n+  gcc_assert (GET_CODE (operands[4]) == MEM);\n   highword = XEXP (operands[4], 0);\n   lowword = plus_constant (highword, 4);\n   if (! WORDS_BIG_ENDIAN)\n@@ -5338,8 +5336,7 @@\n   \"\n {\n   rtx lowword;\n-  if (GET_CODE (operands[3]) != MEM)\n-    abort();\n+  gcc_assert (GET_CODE (operands[3]) == MEM);\n   lowword = XEXP (operands[3], 0);\n   if (WORDS_BIG_ENDIAN)\n     lowword = plus_constant (lowword, 4);\n@@ -8149,7 +8146,7 @@\n   switch (which_alternative)\n     {\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     case 0:\n       /* We normally copy the low-numbered register first.  However, if\n \t the first register operand 0 is the same as the second register\n@@ -8246,7 +8243,7 @@\n   switch (which_alternative)\n     {\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     case 0:\n       /* We normally copy the low-numbered register first.  However, if\n \t the first register operand 0 is the same as the second register of\n@@ -8485,8 +8482,7 @@\n   rtx lowword;\n   emit_insn (gen_fix_trunc_helper (operands[2], operands[1], operands[3]));\n \n-  if (GET_CODE (operands[5]) != MEM)\n-    abort();\n+  gcc_assert (GET_CODE (operands[5]) == MEM);\n   lowword = XEXP (operands[5], 0);\n   if (WORDS_BIG_ENDIAN)\n     lowword = plus_constant (lowword, 4);\n@@ -8738,7 +8734,7 @@\n   switch (which_alternative)\n     {\n     default:\n-      abort ();\n+      gcc_unreachable ();\n \n     case 0:\n       if (TARGET_STRING)\n@@ -8770,7 +8766,7 @@\n   switch (which_alternative)\n     {\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     case 0:\n       if (TARGET_STRING)\n         return \\\"{stsi|stswi} %1,%P0,16\\\";\n@@ -10332,8 +10328,8 @@\n     operands[0] = machopic_indirect_call_target (operands[0]);\n #endif\n \n-  if (GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != CONST_INT)\n-    abort ();\n+  gcc_assert (GET_CODE (operands[0]) == MEM);\n+  gcc_assert (GET_CODE (operands[1]) == CONST_INT);\n \n   operands[0] = XEXP (operands[0], 0);\n \n@@ -10344,12 +10340,14 @@\n       if (INTVAL (operands[2]) & CALL_LONG)\n \toperands[0] = rs6000_longcall_ref (operands[0]);\n \n-      if (DEFAULT_ABI == ABI_V4\n-\t  || DEFAULT_ABI == ABI_DARWIN)\n-\toperands[0] = force_reg (Pmode, operands[0]);\n+      switch (DEFAULT_ABI)\n+        {\n+\tcase ABI_V4:\n+\tcase ABI_DARWIN:\n+\t  operands[0] = force_reg (Pmode, operands[0]);\n+\t  break;\n \n-      else if (DEFAULT_ABI == ABI_AIX)\n-\t{\n+\tcase ABI_AIX:\n \t  /* AIX function pointers are really pointers to a three word\n \t     area.  */\n \t  emit_call_insn (TARGET_32BIT\n@@ -10360,9 +10358,10 @@\n \t\t\t\t\t\t\t        operands[0]),\n \t\t\t\t\t\t     operands[1]));\n \t  DONE;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n \t}\n-      else\n-\tabort ();\n     }\n }\")\n \n@@ -10380,8 +10379,8 @@\n     operands[1] = machopic_indirect_call_target (operands[1]);\n #endif\n \n-  if (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != CONST_INT)\n-    abort ();\n+  gcc_assert (GET_CODE (operands[1]) == MEM);\n+  gcc_assert (GET_CODE (operands[2]) == CONST_INT);\n \n   operands[1] = XEXP (operands[1], 0);\n \n@@ -10392,12 +10391,14 @@\n       if (INTVAL (operands[3]) & CALL_LONG)\n \toperands[1] = rs6000_longcall_ref (operands[1]);\n \n-      if (DEFAULT_ABI == ABI_V4\n-\t  || DEFAULT_ABI == ABI_DARWIN)\n-\toperands[1] = force_reg (Pmode, operands[1]);\n+      switch (DEFAULT_ABI)\n+        {\n+\tcase ABI_V4:\n+\tcase ABI_DARWIN:\n+\t  operands[1] = force_reg (Pmode, operands[1]);\n+\t  break;\n \n-      else if (DEFAULT_ABI == ABI_AIX)\n-\t{\n+\tcase ABI_AIX:\n \t  /* AIX function pointers are really pointers to a three word\n \t     area.  */\n \t  emit_call_insn (TARGET_32BIT\n@@ -10410,9 +10411,10 @@\n \t\t\t\t\t\t\t\t      operands[1]),\n \t\t\t\t\t\t\t   operands[2]));\n \t  DONE;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n \t}\n-      else\n-\tabort ();\n     }\n }\")\n \n@@ -10749,8 +10751,8 @@\n     operands[0] = machopic_indirect_call_target (operands[0]);\n #endif\n \n-  if (GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != CONST_INT)\n-    abort ();\n+  gcc_assert (GET_CODE (operands[0]) == MEM);\n+  gcc_assert (GET_CODE (operands[1]) == CONST_INT);\n \n   operands[0] = XEXP (operands[0], 0);\n   operands[3] = gen_reg_rtx (SImode);\n@@ -10935,8 +10937,8 @@\n     operands[1] = machopic_indirect_call_target (operands[1]);\n #endif\n \n-  if (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != CONST_INT)\n-    abort ();\n+  gcc_assert (GET_CODE (operands[1]) == MEM);\n+  gcc_assert (GET_CODE (operands[2]) == CONST_INT);\n \n   operands[1] = XEXP (operands[1], 0);\n   operands[4] = gen_reg_rtx (SImode);"}, {"sha": "32c596548a92cabea29c282fef5ec853eb27bf90", "filename": "gcc/config/rs6000/spe.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/374097963cec9c1142faf10b819aa28d1fb6f641/gcc%2Fconfig%2Frs6000%2Fspe.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/374097963cec9c1142faf10b819aa28d1fb6f641/gcc%2Fconfig%2Frs6000%2Fspe.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fspe.md?ref=374097963cec9c1142faf10b819aa28d1fb6f641", "patch": "@@ -2247,7 +2247,7 @@\n      case 2:\n        return \\\"evstdd%X0 %1,%y0\\\";\n      default:\n-       abort ();\n+       gcc_unreachable ();\n      }\n  }\"\n   [(set_attr \"type\" \"*,vecload,vecstore\")\n@@ -2327,7 +2327,7 @@\n     case 1: return \\\"evldd%X1 %0,%y1\\\";\n     case 2: return \\\"evor %0,%1,%1\\\";\n     case 3: return output_vec_const_move (operands);\n-    default: abort ();\n+    default: gcc_unreachable ();\n     }\n }\"\n   [(set_attr \"type\" \"vecload,vecstore,*,*\")"}]}