{"sha": "1a7d452c092be42a892d00c19561af10f42410b0", "node_id": "C_kwDOANBUbNoAKDFhN2Q0NTJjMDkyYmU0MmE4OTJkMDBjMTk1NjFhZjEwZjQyNDEwYjA", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2021-10-07T14:21:19Z"}, "committer": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2021-10-07T14:21:36Z"}, "message": "ipa: Fix ICE when speculating calls from inlined functions (PR 102388)\n\nThe code handling various cases which lead to call graph edge\nduplication (in order to update reference descriptions used to track\nand remove no-longer needed references) has missed one important case.\n\nWhen edge duplication is an effect of creating a speculative edge for\nan indirect edge which carries a constant jump function which had been\ncreated from a pass-through function when the edge caller has was\ninlined into one of its callers, the reference description attached to\nthe function describes an edge higher up in the \"inlined\" clone tree\nand so even the new speculative edge will.  Therefore we should not\ntry to duplicate the reference description itself but rather just bump\nthe refcount of the existing one.\n\ngcc/ChangeLog:\n\n2021-09-22  Martin Jambor  <mjambor@suse.cz>\n\n\tPR ipa/102388\n\t* ipa-prop.c (ipa_edge_args_sum_t::duplicate): Also handle the\n\tcase when the source reference description corresponds to a\n\treferance taken in a function src->caller is inlined to.", "tree": {"sha": "1567b220cd7d81038ecf1de08ef8b41dd6b56477", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1567b220cd7d81038ecf1de08ef8b41dd6b56477"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a7d452c092be42a892d00c19561af10f42410b0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEE5elVTFt/d09Vsoczv2PBvD+kNUAFAmFfAnAACgkQv2PBvD+k\nNUB/Lg//f/9N0Xj2Ue25qUYtpn7lXtcKmCVjrHsT3DKLre0XNGBT05UBKSbwqv5o\nT08VGOsS25nQhGEpSHh8dh8UQl7gp+gNktsjaMJ2LbBzM8SzDAXBctLbW9fEyqAh\n+8FnFmjFYvNp+QluSTXjrmS2vd5DmpOTqChHs6R69XjJbwF17CBiWlycvK/qeFOv\nLB4Lbb24h2nCV/Osb4qUeokp1tFm6lwKSGeIj/1HPe9nL/Iumcq7lsqWsCIyXIL2\nKAcImyRPvSq5/HJw2UyoYOMGlO0WlRzWYsFc7EY84ETd3C7sSDxsexAySXgVrDD6\nJGp+6xZZ8OL9wvSAxIFLUS24pm/DqW4wHGwm2RwlUoe4P175aiGEn5Su70WCvqKW\nxW1z1IoXaALr9h80F+/cuQXtx/neYotq2ckKDmp6Mko+zIHVUJEEXLqCO41jAlxL\nl6+fQ4D8l88pM7ozB0CQYsVc4koJF6QBUgbFHdrzn9knbzco36KgGSURUNYkYlM0\nD3PeUTZ75Gzdzu22HTAqfNyy3c6ipyhwAncN7UVrg7bgWk+hRifSWwAXrcjW95mc\n2+WqS+gvRe83Zwa9uWuKKUmRFLP8N1lO3/8wYuIGyn4fowsH5z98tNTEoLh57HzH\npIxBGcUXF87svSdh3q6SDrNS10oFeULcBL3FsyBmoBxa00W6WN0=\n=Wt/4\n-----END PGP SIGNATURE-----", "payload": "tree 1567b220cd7d81038ecf1de08ef8b41dd6b56477\nparent 2e6e0d86a06389056d0e7fecc99c547420ad787a\nauthor Martin Jambor <mjambor@suse.cz> 1633616479 +0200\ncommitter Martin Jambor <mjambor@suse.cz> 1633616496 +0200\n\nipa: Fix ICE when speculating calls from inlined functions (PR 102388)\n\nThe code handling various cases which lead to call graph edge\nduplication (in order to update reference descriptions used to track\nand remove no-longer needed references) has missed one important case.\n\nWhen edge duplication is an effect of creating a speculative edge for\nan indirect edge which carries a constant jump function which had been\ncreated from a pass-through function when the edge caller has was\ninlined into one of its callers, the reference description attached to\nthe function describes an edge higher up in the \"inlined\" clone tree\nand so even the new speculative edge will.  Therefore we should not\ntry to duplicate the reference description itself but rather just bump\nthe refcount of the existing one.\n\ngcc/ChangeLog:\n\n2021-09-22  Martin Jambor  <mjambor@suse.cz>\n\n\tPR ipa/102388\n\t* ipa-prop.c (ipa_edge_args_sum_t::duplicate): Also handle the\n\tcase when the source reference description corresponds to a\n\treferance taken in a function src->caller is inlined to.\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a7d452c092be42a892d00c19561af10f42410b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a7d452c092be42a892d00c19561af10f42410b0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a7d452c092be42a892d00c19561af10f42410b0/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2e6e0d86a06389056d0e7fecc99c547420ad787a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e6e0d86a06389056d0e7fecc99c547420ad787a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e6e0d86a06389056d0e7fecc99c547420ad787a"}], "stats": {"total": 40, "additions": 27, "deletions": 13}, "files": [{"sha": "443f21ce61b38e9667066f77ba541ade767ffc6b", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 27, "deletions": 13, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a7d452c092be42a892d00c19561af10f42410b0/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a7d452c092be42a892d00c19561af10f42410b0/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=1a7d452c092be42a892d00c19561af10f42410b0", "patch": "@@ -4428,19 +4428,33 @@ ipa_edge_args_sum_t::duplicate (cgraph_edge *src, cgraph_edge *dst,\n \t    dst_jf->value.constant.rdesc = NULL;\n \t  else if (src->caller == dst->caller)\n \t    {\n-\t      struct ipa_ref *ref;\n-\t      symtab_node *n = symtab_node_for_jfunc (src_jf);\n-\t      gcc_checking_assert (n);\n-\t      ref = src->caller->find_reference (n, src->call_stmt,\n-\t\t\t\t\t\t src->lto_stmt_uid);\n-\t      gcc_checking_assert (ref);\n-\t      dst->caller->clone_reference (ref, ref->stmt);\n-\n-\t      struct ipa_cst_ref_desc *dst_rdesc = ipa_refdesc_pool.allocate ();\n-\t      dst_rdesc->cs = dst;\n-\t      dst_rdesc->refcount = src_rdesc->refcount;\n-\t      dst_rdesc->next_duplicate = NULL;\n-\t      dst_jf->value.constant.rdesc = dst_rdesc;\n+\t      /* Creation of a speculative edge.  If the source edge is the one\n+\t\t grabbing a reference, we must create a new (duplicate)\n+\t\t reference description.  Otherwise they refer to the same\n+\t\t description corresponding to a reference taken in a function\n+\t\t src->caller is inlined to.  In that case we just must\n+\t\t increment the refcount.  */\n+\t      if (src_rdesc->cs == src)\n+\t\t{\n+\t\t   symtab_node *n = symtab_node_for_jfunc (src_jf);\n+\t\t   gcc_checking_assert (n);\n+\t\t   ipa_ref *ref\n+\t\t     = src->caller->find_reference (n, src->call_stmt,\n+\t\t\t\t\t\t    src->lto_stmt_uid);\n+\t\t   gcc_checking_assert (ref);\n+\t\t   dst->caller->clone_reference (ref, ref->stmt);\n+\n+\t\t   ipa_cst_ref_desc *dst_rdesc = ipa_refdesc_pool.allocate ();\n+\t\t   dst_rdesc->cs = dst;\n+\t\t   dst_rdesc->refcount = src_rdesc->refcount;\n+\t\t   dst_rdesc->next_duplicate = NULL;\n+\t\t   dst_jf->value.constant.rdesc = dst_rdesc;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  src_rdesc->refcount++;\n+\t\t  dst_jf->value.constant.rdesc = src_rdesc;\n+\t\t}\n \t    }\n \t  else if (src_rdesc->cs == src)\n \t    {"}]}