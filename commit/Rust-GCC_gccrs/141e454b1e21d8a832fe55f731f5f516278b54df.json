{"sha": "141e454b1e21d8a832fe55f731f5f516278b54df", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTQxZTQ1NGIxZTIxZDhhODMyZmU1NWY3MzFmNWY1MTYyNzhiNTRkZg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-04-28T19:16:30Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-04-28T19:16:30Z"}, "message": "rtl.h (simplify_gen_relational): Add cmp_mode parameter.\n\n\t* rtl.h (simplify_gen_relational): Add cmp_mode parameter.\n\t* simplify-rtx.c (simplify_gen_relational): Likewise.\n\n\t* simplify-rtx.c (simplify_replace_rtx): Handle relationals and MEMs.\n\n\t* i386.h (VALID_SSE_REG_MODE): Accept MMX modes if SSE2\n\t* i386.md (movsi_1, movdi2, movdi_1_rex64): Handle SSE2 moves.\n\n\t* i386.md (negsf2, negdf2, abssf2, absdf2): Force operands to\n\tregisters in SSE case; fix handling of the immediates.\n\t(negsf2_ifs, abssf2_ifs): Tweak constraints; require\n\toperands to be in regsiters before reload.\n\t(negdf2_ifs, absdf2_ifs): Likewise; disable for 64bit\n\t(negdf2_ifs_rex64, absdf2_ifs_rtx64): New.\n\t(abstf,absxf,negtf,negxf splitters): Compute\n\tproperly the regnum for x86_64.\n\t(avsdf2_if_rex64): New.\n\nFrom-SVN: r41664", "tree": {"sha": "600f80e03a22ccdb9bfcc58f1635f187b941c104", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/600f80e03a22ccdb9bfcc58f1635f187b941c104"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/141e454b1e21d8a832fe55f731f5f516278b54df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/141e454b1e21d8a832fe55f731f5f516278b54df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/141e454b1e21d8a832fe55f731f5f516278b54df", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/141e454b1e21d8a832fe55f731f5f516278b54df/comments", "author": null, "committer": null, "parents": [{"sha": "5bb86bf23de91f8495c4c9d578cf702a81624633", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bb86bf23de91f8495c4c9d578cf702a81624633", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5bb86bf23de91f8495c4c9d578cf702a81624633"}], "stats": {"total": 273, "additions": 224, "deletions": 49}, "files": [{"sha": "c15c7ffd13948e9b3cd4297160731ec6d8e10ad6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/141e454b1e21d8a832fe55f731f5f516278b54df/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/141e454b1e21d8a832fe55f731f5f516278b54df/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=141e454b1e21d8a832fe55f731f5f516278b54df", "patch": "@@ -1,3 +1,23 @@\n+Sat Apr 28 21:02:58 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* rtl.h (simplify_gen_relational): Add cmp_mode parameter.\n+\t* simplify-rtx.c (simplify_gen_relational): Likewise.\n+\n+\t* simplify-rtx.c (simplify_replace_rtx): Handle relationals and MEMs.\n+\n+\t* i386.h (VALID_SSE_REG_MODE): Accept MMX modes if SSE2\n+\t* i386.md (movsi_1, movdi2, movdi_1_rex64): Handle SSE2 moves.\n+\n+\t* i386.md (negsf2, negdf2, abssf2, absdf2): Force operands to\n+\tregisters in SSE case; fix handling of the immediates.\n+\t(negsf2_ifs, abssf2_ifs): Tweak constraints; require\n+\toperands to be in regsiters before reload.\n+\t(negdf2_ifs, absdf2_ifs): Likewise; disable for 64bit\n+\t(negdf2_ifs_rex64, absdf2_ifs_rtx64): New.\n+\t(abstf,absxf,negtf,negxf splitters): Compute\n+\tproperly the regnum for x86_64.\n+\t(avsdf2_if_rex64): New.\n+\n Sat Apr 28 10:36:23 2001  Jeffrey A Law  (law@cygnus.com)\n \n \t* flow.c (propagate_block_delete_insn): Handle deletion of ADDR_VEC"}, {"sha": "626ca2777e702bc4b19631b7dd7cf66c76fc05f1", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/141e454b1e21d8a832fe55f731f5f516278b54df/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/141e454b1e21d8a832fe55f731f5f516278b54df/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=141e454b1e21d8a832fe55f731f5f516278b54df", "patch": "@@ -861,7 +861,8 @@ extern int ix86_arch;\n \n #define VALID_SSE_REG_MODE(MODE) \\\n     ((MODE) == TImode || (MODE) == V4SFmode || (MODE) == V4SImode \\\n-     || (MODE) == SFmode || (TARGET_SSE2 && (MODE) == DFmode))\n+     || (MODE) == SFmode \\\n+     || (TARGET_SSE2 && ((MODE) == DFmode || VALID_MMX_REG_MODE (MODE))))\n \n #define VALID_MMX_REG_MODE(MODE) \\\n     ((MODE) == DImode || (MODE) == V8QImode || (MODE) == V4HImode \\"}, {"sha": "7b55859c7b891a0a72ad402df200a6e8c04a6097", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 168, "deletions": 45, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/141e454b1e21d8a832fe55f731f5f516278b54df/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/141e454b1e21d8a832fe55f731f5f516278b54df/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=141e454b1e21d8a832fe55f731f5f516278b54df", "patch": "@@ -1733,13 +1733,18 @@\n    (set_attr \"length_immediate\" \"1\")])\n \n (define_insn \"*movsi_1\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=*a,r,*a,m,!*y,!r\")\n-\t(match_operand:SI 1 \"general_operand\" \"im,rinm,rinm,rin,r,*y\"))]\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=*a,r,*a,m,!*y,!rm,!*Y,!rm,!*Y\")\n+\t(match_operand:SI 1 \"general_operand\" \"im,rinm,rinm,rin,rm,*y,rm,*Y,*Y\"))]\n   \"GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM\"\n   \"*\n {\n   switch (get_attr_type (insn))\n     {\n+    case TYPE_SSE:\n+      if (get_attr_mode (insn) == TImode)\n+        return \\\"movdqa\\\\t{%1, %0|%0, %1}\\\";\n+      return \\\"movd\\\\t{%1, %0|%0, %1}\\\";\n+\n     case TYPE_MMX:\n       return \\\"movd\\\\t{%1, %0|%0, %1}\\\";\n \n@@ -1753,16 +1758,17 @@\n     }\n }\"\n   [(set (attr \"type\")\n-     (cond [(ior (match_operand:SI 0 \"mmx_reg_operand\" \"\")\n-\t\t (match_operand:SI 1 \"mmx_reg_operand\" \"\"))\n+     (cond [(eq_attr \"alternative\" \"4,5\")\n \t      (const_string \"mmx\")\n+\t    (eq_attr \"alternative\" \"6,7,8\")\n+\t      (const_string \"sse\")\n \t    (and (ne (symbol_ref \"flag_pic\") (const_int 0))\n \t\t (match_operand:SI 1 \"symbolic_operand\" \"\"))\n \t      (const_string \"lea\")\n \t   ]\n \t   (const_string \"imov\")))\n-   (set_attr \"modrm\" \"0,*,0,*,*,*\")\n-   (set_attr \"mode\" \"SI\")])\n+   (set_attr \"modrm\" \"0,*,0,*,*,*,*,*,*\")\n+   (set_attr \"mode\" \"SI,SI,SI,SI,SI,SI,TI,SI,SI\")])\n \n ;; Stores and loads of ax to arbitary constant address.\n ;; We fake an second form of instruction to force reload to load address\n@@ -2463,16 +2469,20 @@\n    (set_attr \"length_immediate\" \"1\")])\n \n (define_insn \"*movdi_2\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,o,!m*y,!*y\")\n-\t(match_operand:DI 1 \"general_operand\" \"riFo,riF,*y,m\"))]\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,o,!m*y,!*y,!m,*Y,!*Y\")\n+\t(match_operand:DI 1 \"general_operand\" \"riFo,riF,*y,m,*Y,*Y,m\"))]\n   \"!TARGET_64BIT\n    && (GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\"\n   \"@\n    #\n    #\n    movq\\\\t{%1, %0|%0, %1}\n+   movq\\\\t{%1, %0|%0, %1}\n+   movq\\\\t{%1, %0|%0, %1}\n+   movdqa\\\\t{%1, %0|%0, %1}\n    movq\\\\t{%1, %0|%0, %1}\"\n-  [(set_attr \"type\" \"*,*,mmx,mmx\")])\n+  [(set_attr \"type\" \"*,*,mmx,mmx,sse,sse,sse\")\n+   (set_attr \"mode\" \"DI,DI,DI,DI,DI,TI,DI\")])\n \n (define_split\n   [(set (match_operand:DI 0 \"push_operand\" \"\")\n@@ -2491,17 +2501,21 @@\n   \"ix86_split_long_move (operands); DONE;\")\n \n (define_insn \"*movdi_1_rex64\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,r,mr,!mr,!m*y,!*y,m*Y,*Y\")\n-\t(match_operand:DI 1 \"general_operand\" \"Z,rem,i,re,n,*y,m,*Y,*m\"))]\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,r,mr,!mr,!m*y,!*y,!*Y,!m,!*Y\")\n+\t(match_operand:DI 1 \"general_operand\" \"Z,rem,i,re,n,*y,m,*Y,*Y,*m\"))]\n   \"(GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\n    && TARGET_64BIT\"\n   \"*\n {\n   switch (get_attr_type (insn))\n     {\n     case TYPE_SSE:\n+      if (register_operand (operands[0], DImode)\n+\t  && register_operand (operands[1], DImode))\n+\t  return \\\"movdqa\\\\t{%1, %0|%0, %1}\\\";\n+      /* FALLTHRU */\n     case TYPE_MMX:\n-      return \\\"movd\\\\t{%1, %0|%0, %1}\\\";\n+      return \\\"movq\\\\t{%1, %0|%0, %1}\\\";\n     case TYPE_MULTI:\n       return \\\"#\\\";\n     case TYPE_LEA:\n@@ -2529,9 +2543,9 @@\n \t      (const_string \"lea\")\n \t   ]\n \t   (const_string \"imov\")))\n-   (set_attr \"modrm\" \"*,0,0,*,*,*,*,*,*\")\n-   (set_attr \"length_immediate\" \"*,4,8,*,*,*,*,*,*\")\n-   (set_attr \"mode\" \"SI,DI,DI,DI,SI,DI,DI,DI,DI\")])\n+   (set_attr \"modrm\" \"*,0,0,*,*,*,*,*,*,*\")\n+   (set_attr \"length_immediate\" \"*,4,8,*,*,*,*,*,*,*\")\n+   (set_attr \"mode\" \"SI,DI,DI,DI,SI,DI,DI,DI,TI,DI\")])\n \n ;; Stores and loads of ax to arbitary constant address.\n ;; We fake an second form of instruction to force reload to load address\n@@ -9337,11 +9351,17 @@\n \t  /* Using SSE is tricky, since we need bitwise negation of -0\n \t     in register.  */\n \t  rtx reg = gen_reg_rtx (SFmode);\n+\t  rtx dest = operands[0];\n+\n+\t  operands[1] = force_reg (SFmode, operands[1]);\n+\t  operands[0] = force_reg (SFmode, operands[0]);\n \t  emit_move_insn (reg,\n \t\t\t  gen_lowpart (SFmode,\n-\t\t\t\t       trunc_int_for_mode (0x80000000,\n-\t\t\t\t\t\t\t   SImode)));\n+\t\t\t\t       GEN_INT (trunc_int_for_mode (0x80000000,\n+\t\t\t\t\t\t\t            SImode))));\n \t  emit_insn (gen_negsf2_ifs (operands[0], operands[1], reg));\n+\t  if (dest != operands[0])\n+\t    emit_move_insn (dest, operands[0]);\n \t}\n        DONE;\n      }\n@@ -9355,11 +9375,14 @@\n   \"#\")\n \n (define_insn \"negsf2_ifs\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=x#fr,x#fr,f#xr,r#xf\")\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=x#fr,x#fr,f#xr,rm#xf\")\n \t(neg:SF (match_operand:SF 1 \"nonimmediate_operand\" \"0,x#fr,0,0\")))\n-   (use (match_operand:SF 2 \"nonmemory_operand\" \"x#x,0#x,*X#x,*X#x\"))\n+   (use (match_operand:SF 2 \"nonmemory_operand\" \"x,0#x,*g#x,*g#x\"))\n    (clobber (reg:CC 17))]\n-  \"TARGET_SSE\"\n+  \"TARGET_SSE\n+   && (reload_in_progress || reload_completed\n+       || (register_operand (operands[0], VOIDmode)\n+\t   && register_operand (operands[1], VOIDmode)))\"\n   \"#\")\n \n (define_split\n@@ -9457,7 +9480,7 @@\n \t\t   (neg:DF (match_operand:DF 1 \"nonimmediate_operand\" \"\")))\n \t      (clobber (reg:CC 17))])]\n   \"TARGET_80387\"\n-  \"if (TARGET_SSE)\n+  \"if (TARGET_SSE2)\n      {\n        /* In case operand is in memory,  we will not use SSE.  */\n        if (memory_operand (operands[0], VOIDmode)\n@@ -9469,12 +9492,19 @@\n \t     in register.  */\n \t  rtx reg = gen_reg_rtx (DFmode);\n #if HOST_BITS_PER_WIDE_INT >= 64\n-\t  rtx imm = GEN_INT (0x80000000);\n+\t  rtx imm = GEN_INT (trunc_int_for_mode(((HOST_WIDE_INT)1) << 63,\n+\t\t\t\t\t        DImode));\n #else\n \t  rtx imm = immed_double_const (0, 0x80000000, DImode);\n #endif\n+\t  rtx dest = operands[0];\n+\n+\t  operands[1] = force_reg (DFmode, operands[1]);\n+\t  operands[0] = force_reg (DFmode, operands[0]);\n \t  emit_move_insn (reg, gen_lowpart (DFmode, imm));\n \t  emit_insn (gen_negdf2_ifs (operands[0], operands[1], reg));\n+\t  if (dest != operands[0])\n+\t    emit_move_insn (dest, operands[0]);\n \t}\n        DONE;\n      }\n@@ -9488,11 +9518,25 @@\n   \"#\")\n \n (define_insn \"negdf2_ifs\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=x#fr,x#fr,f#xr,r#xf\")\n-\t(neg:DF (match_operand:DF 1 \"nonimmediate_operand\" \"0,x#fr,0,0\")))\n-   (use (match_operand:DF 2 \"nonmemory_operand\" \"x#x,0#x,*X#x,*X#x\"))\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=Y#fr,Y#fr,f#Yr,rm#Yf\")\n+\t(neg:DF (match_operand:DF 1 \"nonimmediate_operand\" \"0,Y#fr,0,0\")))\n+   (use (match_operand:DF 2 \"nonmemory_operand\" \"Y,0,*g#Y,*g#Y\"))\n    (clobber (reg:CC 17))]\n-  \"TARGET_SSE\"\n+  \"TARGET_SSE2 && !TARGET_64BIT\n+   && (reload_in_progress || reload_completed\n+       || (register_operand (operands[0], VOIDmode)\n+\t   && register_operand (operands[1], VOIDmode)))\"\n+  \"#\")\n+\n+(define_insn \"*negdf2_ifs_rex64\"\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=Y#fr,Y#fr,fm#Yr,r#Yf\")\n+\t(neg:DF (match_operand:DF 1 \"nonimmediate_operand\" \"0,Y#fr,0,0\")))\n+   (use (match_operand:DF 2 \"general_operand\" \"Y,0,*g#Yr,*rm\"))\n+   (clobber (reg:CC 17))]\n+  \"TARGET_SSE2 && TARGET_64BIT\n+   && (reload_in_progress || reload_completed\n+       || (register_operand (operands[0], VOIDmode)\n+\t   && register_operand (operands[1], VOIDmode)))\"\n   \"#\")\n \n (define_split\n@@ -9510,11 +9554,25 @@\n \t(neg:DF (match_operand:DF 1 \"register_operand\" \"\")))\n    (use (match_operand:DF 2 \"\" \"\"))\n    (clobber (reg:CC 17))]\n-  \"reload_completed && !SSE_REG_P (operands[0])\"\n+  \"reload_completed && !SSE_REG_P (operands[0])\n+   && (!TARGET_64BIT || FP_REG_P (operands[0]))\"\n   [(parallel [(set (match_dup 0)\n \t\t   (neg:DF (match_dup 1)))\n \t      (clobber (reg:CC 17))])])\n \n+(define_split\n+  [(set (match_operand:DF 0 \"register_operand\" \"\")\n+\t(neg:DF (match_operand:DF 1 \"register_operand\" \"\")))\n+   (use (match_operand:DF 2 \"\" \"\"))\n+   (clobber (reg:CC 17))]\n+  \"reload_completed && GENERAL_REG_P (operands[0]) && TARGET_64BIT\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (xor:DI (match_dup 1) (match_dup 2)))\n+\t      (clobber (reg:CC 17))])]\n+   \"operands[0] = gen_lowpart (DImode, operands[0]);\n+    operands[1] = gen_lowpart (DImode, operands[1]);\n+    operands[2] = gen_lowpart (DImode, operands[2]);\")\n+\n (define_split\n   [(set (match_operand:DF 0 \"register_operand\" \"\")\n \t(neg:DF (match_operand:DF 1 \"register_operand\" \"\")))\n@@ -9542,7 +9600,20 @@\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f#r,rm#f\")\n \t(neg:DF (match_operand:DF 1 \"nonimmediate_operand\" \"0,0\")))\n    (clobber (reg:CC 17))]\n-  \"TARGET_80387 && ix86_unary_operator_ok (NEG, DFmode, operands)\"\n+  \"TARGET_80387 && !TARGET_64BIT\n+   && ix86_unary_operator_ok (NEG, DFmode, operands)\"\n+  \"#\")\n+\n+;; FIXME: We should to allow integer registers here.  Problem is that\n+;; we need another scratch register to get constant from.\n+;; Forcing constant to mem if no register available in peep2 should be\n+;; safe even for PIC mode, because of RIP relative addressing.\n+(define_insn \"*negdf2_if_rex64\"\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f,mf\")\n+\t(neg:DF (match_operand:DF 1 \"nonimmediate_operand\" \"0,0\")))\n+   (clobber (reg:CC 17))]\n+  \"TARGET_80387 && TARGET_64BIT\n+   && ix86_unary_operator_ok (NEG, DFmode, operands)\"\n   \"#\")\n \n (define_split\n@@ -9558,7 +9629,8 @@\n   [(set (match_operand:DF 0 \"register_operand\" \"\")\n \t(neg:DF (match_operand:DF 1 \"register_operand\" \"\")))\n    (clobber (reg:CC 17))]\n-  \"TARGET_80387 && reload_completed && !FP_REGNO_P (REGNO (operands[0]))\"\n+  \"TARGET_80387 && reload_completed && !FP_REGNO_P (REGNO (operands[0]))\n+   && !TARGET_64BIT\"\n   [(parallel [(set (match_dup 3) (xor:SI (match_dup 3) (match_dup 4)))\n \t      (clobber (reg:CC 17))])]\n   \"operands[4] = GEN_INT (trunc_int_for_mode (0x80000000, SImode));\n@@ -9606,7 +9678,8 @@\n   [(parallel [(set (match_dup 0) (xor:SI (match_dup 0) (match_dup 1)))\n \t      (clobber (reg:CC 17))])]\n   \"operands[1] = GEN_INT (0x8000);\n-   operands[0] = gen_rtx_REG (SImode, true_regnum (operands[0]) + 2);\")\n+   operands[0] = gen_rtx_REG (SImode,\n+\t\t\t      true_regnum (operands[0]) + (TARGET_64BIT ? 1 : 2));\")\n \n ;; Keep 'f' and 'r' in separate alternatives to avoid reload problems\n ;; because of secondary memory needed to reload from class FLOAT_INT_REGS\n@@ -9635,7 +9708,8 @@\n   [(parallel [(set (match_dup 0) (xor:SI (match_dup 0) (match_dup 1)))\n \t      (clobber (reg:CC 17))])]\n   \"operands[1] = GEN_INT (0x8000);\n-   operands[0] = gen_rtx_REG (SImode, true_regnum (operands[0]) + 2);\")\n+   operands[0] = gen_rtx_REG (SImode,\n+\t\t\t      true_regnum (operands[0]) + (TARGET_64BIT ? 1 : 2));\")\n \n ;; Conditionize these after reload. If they matches before reload, we \n ;; lose the clobber and ability to use integer instructions.\n@@ -9744,8 +9818,17 @@\n \t  /* Using SSE is tricky, since we need bitwise negation of -0\n \t     in register.  */\n \t  rtx reg = gen_reg_rtx (SFmode);\n-\t  emit_move_insn (reg, gen_lowpart (SFmode, GEN_INT (0x80000000)));\n+\t  rtx dest = operands[0];\n+\n+\t  operands[1] = force_reg (SFmode, operands[1]);\n+\t  operands[0] = force_reg (SFmode, operands[0]);\n+\t  emit_move_insn (reg,\n+\t\t\t  gen_lowpart (SFmode,\n+\t\t\t\t       GEN_INT (trunc_int_for_mode (0x80000000,\n+\t\t\t\t\t\t\t            SImode))));\n \t  emit_insn (gen_abssf2_ifs (operands[0], operands[1], reg));\n+\t  if (dest != operands[0])\n+\t    emit_move_insn (dest, operands[0]);\n \t}\n        DONE;\n      }\n@@ -9759,11 +9842,14 @@\n   \"#\")\n \n (define_insn \"abssf2_ifs\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=x#fr,f#xr,r#xf\")\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=x#fr,f#xr,rm#xf\")\n \t(abs:SF (match_operand:SF 1 \"nonimmediate_operand\" \"x,0,0\")))\n-   (use (match_operand:SF 2 \"nonmemory_operand\" \"*0#x,*X#x,*X#x\"))\n+   (use (match_operand:SF 2 \"nonmemory_operand\" \"*0#x,*g#x,*g#x\"))\n    (clobber (reg:CC 17))]\n-  \"TARGET_SSE\"\n+  \"TARGET_SSE\n+   && (reload_in_progress || reload_completed\n+       || (register_operand (operands[0], VOIDmode)\n+\t   && register_operand (operands[1], VOIDmode)))\"\n   \"#\")\n \n (define_split\n@@ -9861,12 +9947,19 @@\n \t     in register.  */\n \t  rtx reg = gen_reg_rtx (DFmode);\n #if HOST_BITS_PER_WIDE_INT >= 64\n-\t  rtx imm = GEN_INT (0x80000000);\n+\t  rtx imm = GEN_INT (trunc_int_for_mode(((HOST_WIDE_INT)1) << 63,\n+\t\t\t\t\t        DImode));\n #else\n \t  rtx imm = immed_double_const (0, 0x80000000, DImode);\n #endif\n+\t  rtx dest = operands[0];\n+\n+\t  operands[1] = force_reg (DFmode, operands[1]);\n+\t  operands[0] = force_reg (DFmode, operands[0]);\n \t  emit_move_insn (reg, gen_lowpart (DFmode, imm));\n \t  emit_insn (gen_absdf2_ifs (operands[0], operands[1], reg));\n+\t  if (dest != operands[0])\n+\t    emit_move_insn (dest, operands[0]);\n \t}\n        DONE;\n      }\n@@ -9880,11 +9973,25 @@\n   \"#\")\n \n (define_insn \"absdf2_ifs\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=Y#fr,f#Yr,r#Yf\")\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=Y#fr,mf#Yr,mr#Yf\")\n \t(abs:DF (match_operand:DF 1 \"nonimmediate_operand\" \"Y,0,0\")))\n-   (use (match_operand:DF 2 \"nonmemory_operand\" \"*0#Y,*X#Y,*X#Y\"))\n+   (use (match_operand:DF 2 \"nonmemory_operand\" \"*0#Y,*g#Y,*g#Y\"))\n    (clobber (reg:CC 17))]\n-  \"TARGET_SSE2\"\n+  \"TARGET_SSE2 && !TARGET_64BIT\n+   && (reload_in_progress || reload_completed\n+       || (register_operand (operands[0], VOIDmode)\n+\t   && register_operand (operands[1], VOIDmode)))\"\n+  \"#\")\n+\n+(define_insn \"*absdf2_ifs_rex64\"\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=Y#fr,mf#Yr\")\n+\t(abs:DF (match_operand:DF 1 \"nonimmediate_operand\" \"Y,0\")))\n+   (use (match_operand:DF 2 \"nonmemory_operand\" \"*0#Y,*g#Y\"))\n+   (clobber (reg:CC 17))]\n+  \"TARGET_SSE2 && TARGET_64BIT\n+   && (reload_in_progress || reload_completed\n+       || (register_operand (operands[0], VOIDmode)\n+\t   && register_operand (operands[1], VOIDmode)))\"\n   \"#\")\n \n (define_split\n@@ -9925,7 +10032,20 @@\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f#r,rm#f\")\n \t(abs:DF (match_operand:DF 1 \"nonimmediate_operand\" \"0,0\")))\n    (clobber (reg:CC 17))]\n-  \"TARGET_80387 && ix86_unary_operator_ok (ABS, DFmode, operands)\"\n+  \"TARGET_80387 && !TARGET_64BIT\n+   && ix86_unary_operator_ok (ABS, DFmode, operands)\"\n+  \"#\")\n+\n+;; FIXME: We should to allow integer registers here.  Problem is that\n+;; we need another scratch register to get constant from.\n+;; Forcing constant to mem if no register available in peep2 should be\n+;; safe even for PIC mode, because of RIP relative addressing.\n+(define_insn \"*absdf2_if_rex64\"\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f,mf\")\n+\t(abs:DF (match_operand:DF 1 \"nonimmediate_operand\" \"0,0\")))\n+   (clobber (reg:CC 17))]\n+  \"TARGET_80387 && TARGET_64BIT\n+   && ix86_unary_operator_ok (ABS, DFmode, operands)\"\n   \"#\")\n \n (define_split\n@@ -9941,7 +10061,8 @@\n   [(set (match_operand:DF 0 \"register_operand\" \"\")\n \t(abs:DF (match_operand:DF 1 \"register_operand\" \"\")))\n    (clobber (reg:CC 17))]\n-  \"TARGET_80387 && reload_completed && !FP_REGNO_P (REGNO (operands[0]))\"\n+  \"TARGET_80387 && reload_completed && !FP_REGNO_P (REGNO (operands[0]))\n+   && !TARGET_64BIT\"\n   [(parallel [(set (match_dup 3) (and:SI (match_dup 3) (match_dup 4)))\n \t      (clobber (reg:CC 17))])]\n   \"operands[4] = GEN_INT (trunc_int_for_mode (~0x80000000, SImode));\n@@ -9988,8 +10109,9 @@\n   \"TARGET_80387 && reload_completed && !FP_REGNO_P (REGNO (operands[0]))\"\n   [(parallel [(set (match_dup 0) (and:SI (match_dup 0) (match_dup 1)))\n \t      (clobber (reg:CC 17))])]\n-  \"operands[1] = GEN_INT (trunc_int_for_mode (~0x8000, SImode));\n-   operands[0] = gen_rtx_REG (SImode, true_regnum (operands[0]) + 2);\")\n+  \"operands[1] = GEN_INT (~0x8000);\n+   operands[0] = gen_rtx_REG (SImode,\n+\t\t\t      true_regnum (operands[0]) + (TARGET_64BIT ? 1 : 2));\")\n \n (define_insn \"*abstf2_if\"\n   [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=f#r,rm#f\")\n@@ -10014,8 +10136,9 @@\n   \"TARGET_80387 && reload_completed && !FP_REGNO_P (REGNO (operands[0]))\"\n   [(parallel [(set (match_dup 0) (and:SI (match_dup 0) (match_dup 1)))\n \t      (clobber (reg:CC 17))])]\n-  \"operands[1] = GEN_INT (trunc_int_for_mode (~0x8000, SImode));\n-   operands[0] = gen_rtx_REG (SImode, true_regnum (operands[0]) + 2);\")\n+  \"operands[1] = GEN_INT (~0x8000);\n+   operands[0] = gen_rtx_REG (SImode,\n+\t\t\t      true_regnum (operands[0]) + (TARGET_64BIT ? 1 : 2));\")\n \n (define_insn \"*abssf2_1\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f\")"}, {"sha": "4b1051c0b53cbe3434f39b9ffb9481fcab3e08cb", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/141e454b1e21d8a832fe55f731f5f516278b54df/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/141e454b1e21d8a832fe55f731f5f516278b54df/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=141e454b1e21d8a832fe55f731f5f516278b54df", "patch": "@@ -1317,6 +1317,7 @@ extern rtx simplify_gen_ternary\t\tPARAMS ((enum rtx_code,\n \t\t\t\t\t\t enum machine_mode,\n \t\t\t\t\t\t rtx, rtx, rtx));\n extern rtx simplify_gen_relational\tPARAMS ((enum rtx_code,\n+\t\t\t\t\t\t enum machine_mode,\n \t\t\t\t\t\t enum machine_mode,\n \t\t\t\t\t\t rtx, rtx));\n extern rtx simplify_replace_rtx\t\tPARAMS ((rtx, rtx, rtx));"}, {"sha": "a5e09a75f9a9be6a930b662c1bde173dba6b928e", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 33, "deletions": 3, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/141e454b1e21d8a832fe55f731f5f516278b54df/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/141e454b1e21d8a832fe55f731f5f516278b54df/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=141e454b1e21d8a832fe55f731f5f516278b54df", "patch": "@@ -177,17 +177,20 @@ simplify_gen_ternary (code, mode, op0_mode, op0, op1, op2)\n   return gen_rtx_fmt_eee (code, mode, op0, op1, op2);\n }\n \f\n-/* Likewise, for relational operations.  */\n+/* Likewise, for relational operations.\n+   CMP_MODE specifies mode comparison is done in.\n+  */\n \n rtx\n-simplify_gen_relational (code, mode, op0, op1)\n+simplify_gen_relational (code, mode, cmp_mode, op0, op1)\n      enum rtx_code code;\n      enum machine_mode mode;\n+     enum machine_mode cmp_mode;\n      rtx op0, op1;\n {\n   rtx tem;\n \n-  if ((tem = simplify_relational_operation (code, mode, op0, op1)) != 0)\n+  if ((tem = simplify_relational_operation (code, cmp_mode, op0, op1)) != 0)\n     return tem;\n \n   /* Put complex operands first and constants second.  */\n@@ -238,6 +241,14 @@ simplify_replace_rtx (x, old, new)\n \tsimplify_gen_binary (code, mode,\n \t\t\t     simplify_replace_rtx (XEXP (x, 0), old, new),\n \t\t\t     simplify_replace_rtx (XEXP (x, 1), old, new));\n+    case '<':\n+      return\n+\tsimplify_gen_relational (code, mode,\n+\t\t\t\t (GET_MODE (XEXP (x, 0)) != VOIDmode\n+\t\t\t\t  ? GET_MODE (XEXP (x, 0))\n+\t\t\t\t  : GET_MODE (XEXP (x, 1))),\n+\t\t\t\t simplify_replace_rtx (XEXP (x, 0), old, new),\n+\t\t\t\t simplify_replace_rtx (XEXP (x, 1), old, new));\n \n     case '3':\n     case 'b':\n@@ -258,8 +269,27 @@ simplify_replace_rtx (x, old, new)\n       return x;\n \n     default:\n+      if (GET_CODE (x) == MEM)\n+\t{\n+\t  /* We can't use change_address here, since it verifies memory address\n+\t     for corectness.  We don't want such check, since we may handle\n+\t     addresses previously incorect (such as ones in push instructions)\n+\t     and it is caller's work to verify whether resulting insn match.  */\n+\t  rtx addr = simplify_replace_rtx (XEXP (x, 0), old, new);\n+\t  rtx mem;\n+\t  if (XEXP (x, 0) != addr)\n+\t    {\n+\t      mem = gen_rtx_MEM (GET_MODE (x), addr);\n+\t      MEM_COPY_ATTRIBUTES (mem, x);\n+\t    }\n+\t  else\n+\t    mem = x;\n+\t  return mem;\n+\t}\n+\n       return x;\n     }\n+  return x;\n }\n \f\n /* Try to simplify a unary operation CODE whose output mode is to be"}]}