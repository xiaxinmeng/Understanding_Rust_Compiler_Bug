{"sha": "ffe1468659b160f34f296a3879a0894e45e644ba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmZlMTQ2ODY1OWIxNjBmMzRmMjk2YTM4NzlhMDg5NGU0NWU2NDRiYQ==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@gmail.com", "date": "2011-11-09T01:20:14Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2011-11-09T01:20:14Z"}, "message": "function.c (bb_active_p): Delete.\n\n\t* function.c (bb_active_p): Delete.\n\t(dup_block_and_redirect, active_insn_between): New functions.\n\t(convert_jumps_to_returns, emit_return_for_exit): New functions,\n\tsplit out from..\n\t(thread_prologue_and_epilogue_insns): ..here.  Delete\n\tshadowing variables.  Don't do prologue register clobber tests\n\twhen shrink wrapping already failed.  Delete all last_bb_active\n\tcode.  Instead compute tail block candidates for duplicating\n\texit path.  Remove these from antic set.  Duplicate tails when\n\treached from both blocks needing a prologue/epilogue and\n\tblocks not needing such.\n\t* ifcvt.c (dead_or_predicable): Test both flag_shrink_wrap and\n\tHAVE_simple_return.\n\t* bb-reorder.c (get_uncond_jump_length): Make global.\n\t* bb-reorder.h (get_uncond_jump_length): Declare.\n\t* cfgrtl.c (rtl_create_basic_block): Comment typo fix.\n\t(rtl_split_edge): Likewise.  Warning fix.\n\t(rtl_duplicate_bb): New function.\n\t(rtl_cfg_hooks): Enable can_duplicate_block_p and duplicate_block.\n\t* Makefile.in (function.o): Update dependencies.\n\nFrom-SVN: r181188", "tree": {"sha": "baff6cd042f250e9fc891b81960ba3c328cc11eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/baff6cd042f250e9fc891b81960ba3c328cc11eb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ffe1468659b160f34f296a3879a0894e45e644ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffe1468659b160f34f296a3879a0894e45e644ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffe1468659b160f34f296a3879a0894e45e644ba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffe1468659b160f34f296a3879a0894e45e644ba/comments", "author": {"login": "amodra", "id": 6006325, "node_id": "MDQ6VXNlcjYwMDYzMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amodra", "html_url": "https://github.com/amodra", "followers_url": "https://api.github.com/users/amodra/followers", "following_url": "https://api.github.com/users/amodra/following{/other_user}", "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}", "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amodra/subscriptions", "organizations_url": "https://api.github.com/users/amodra/orgs", "repos_url": "https://api.github.com/users/amodra/repos", "events_url": "https://api.github.com/users/amodra/events{/privacy}", "received_events_url": "https://api.github.com/users/amodra/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "dce5eb107dfddc1c8bcd04d4f12f34fb7b72964e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dce5eb107dfddc1c8bcd04d4f12f34fb7b72964e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dce5eb107dfddc1c8bcd04d4f12f34fb7b72964e"}], "stats": {"total": 754, "additions": 511, "deletions": 243}, "files": [{"sha": "00f553278282a532825ae24b8f0086fb631923fc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffe1468659b160f34f296a3879a0894e45e644ba/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffe1468659b160f34f296a3879a0894e45e644ba/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ffe1468659b160f34f296a3879a0894e45e644ba", "patch": "@@ -1,3 +1,26 @@\n+2011-11-09  Alan Modra  <amodra@gmail.com>\n+\n+\t* function.c (bb_active_p): Delete.\n+\t(dup_block_and_redirect, active_insn_between): New functions.\n+\t(convert_jumps_to_returns, emit_return_for_exit): New functions,\n+\tsplit out from..\n+\t(thread_prologue_and_epilogue_insns): ..here.  Delete\n+\tshadowing variables.  Don't do prologue register clobber tests\n+\twhen shrink wrapping already failed.  Delete all last_bb_active\n+\tcode.  Instead compute tail block candidates for duplicating\n+\texit path.  Remove these from antic set.  Duplicate tails when\n+\treached from both blocks needing a prologue/epilogue and\n+\tblocks not needing such.\n+\t* ifcvt.c (dead_or_predicable): Test both flag_shrink_wrap and\n+\tHAVE_simple_return.\n+\t* bb-reorder.c (get_uncond_jump_length): Make global.\n+\t* bb-reorder.h (get_uncond_jump_length): Declare.\n+\t* cfgrtl.c (rtl_create_basic_block): Comment typo fix.\n+\t(rtl_split_edge): Likewise.  Warning fix.\n+\t(rtl_duplicate_bb): New function.\n+\t(rtl_cfg_hooks): Enable can_duplicate_block_p and duplicate_block.\n+\t* Makefile.in (function.o): Update dependencies.\n+\n 2011-11-08  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n \t    Georg-Johann Lay  <avr@gjlay.de>\n "}, {"sha": "ae4f4da2b3eafa7fa4819d177e64698933f7a98d", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffe1468659b160f34f296a3879a0894e45e644ba/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffe1468659b160f34f296a3879a0894e45e644ba/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=ffe1468659b160f34f296a3879a0894e45e644ba", "patch": "@@ -2807,7 +2807,8 @@ function.o : function.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_ERROR_\n    $(OPTABS_H) $(LIBFUNCS_H) $(REGS_H) hard-reg-set.h insn-config.h $(RECOG_H) \\\n    output.h  $(EXCEPT_H) $(HASHTAB_H) $(GGC_H) $(TM_P_H) langhooks.h \\\n    gt-function.h $(TARGET_H) $(BASIC_BLOCK_H) $(INTEGRATE_H) $(PREDICT_H) \\\n-   $(TREE_PASS_H) $(DF_H) $(TIMEVAR_H) vecprim.h $(COMMON_TARGET_H)\n+   $(TREE_PASS_H) $(DF_H) $(TIMEVAR_H) vecprim.h $(PARAMS_H) bb-reorder.h \\\n+   $(COMMON_TARGET_H)\n statistics.o : statistics.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TREE_PASS_H) $(TREE_DUMP_H) $(HASHTAB_H) statistics.h $(FUNCTION_H)\n stmt.o : stmt.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\"}, {"sha": "017c205d08653e70160f3ee72cb26812395b4938", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffe1468659b160f34f296a3879a0894e45e644ba/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffe1468659b160f34f296a3879a0894e45e644ba/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=ffe1468659b160f34f296a3879a0894e45e644ba", "patch": "@@ -181,7 +181,6 @@ static fibheapkey_t bb_to_key (basic_block);\n static bool better_edge_p (const_basic_block, const_edge, int, int, int, int, const_edge);\n static void connect_traces (int, struct trace *);\n static bool copy_bb_p (const_basic_block, int);\n-static int get_uncond_jump_length (void);\n static bool push_to_next_round_p (const_basic_block, int, int, int, gcov_type);\n \f\n /* Check to see if bb should be pushed into the next round of trace\n@@ -1193,7 +1192,7 @@ copy_bb_p (const_basic_block bb, int code_may_grow)\n \n /* Return the length of unconditional jump instruction.  */\n \n-static int\n+int\n get_uncond_jump_length (void)\n {\n   rtx label, jump;"}, {"sha": "13acdb0f31e6053b78d0bd53ecda60fe4be4e13a", "filename": "gcc/bb-reorder.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffe1468659b160f34f296a3879a0894e45e644ba/gcc%2Fbb-reorder.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffe1468659b160f34f296a3879a0894e45e644ba/gcc%2Fbb-reorder.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.h?ref=ffe1468659b160f34f296a3879a0894e45e644ba", "patch": "@@ -34,4 +34,6 @@ extern struct target_bb_reorder *this_target_bb_reorder;\n #define this_target_bb_reorder (&default_target_bb_reorder)\n #endif\n \n+extern int get_uncond_jump_length (void);\n+\n #endif"}, {"sha": "16e2eb30a6a77f371108b1809d46db5985a8713d", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffe1468659b160f34f296a3879a0894e45e644ba/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffe1468659b160f34f296a3879a0894e45e644ba/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=ffe1468659b160f34f296a3879a0894e45e644ba", "patch": "@@ -322,9 +322,9 @@ create_basic_block_structure (rtx head, rtx end, rtx bb_note, basic_block after)\n }\n \n /* Create new basic block consisting of instructions in between HEAD and END\n-   and place it to the BB chain after block AFTER.  END can be NULL in to\n-   create new empty basic block before HEAD.  Both END and HEAD can be NULL to\n-   create basic block at the end of INSN chain.  */\n+   and place it to the BB chain after block AFTER.  END can be NULL to\n+   create a new empty basic block before HEAD.  Both END and HEAD can be\n+   NULL to create basic block at the end of INSN chain.  */\n \n static basic_block\n rtl_create_basic_block (void *headp, void *endp, basic_block after)\n@@ -1411,8 +1411,8 @@ rtl_split_edge (edge edge_in)\n     before = NULL_RTX;\n \n   /* If this is a fall through edge to the exit block, the blocks might be\n-     not adjacent, and the right place is the after the source.  */\n-  if (edge_in->flags & EDGE_FALLTHRU && edge_in->dest == EXIT_BLOCK_PTR)\n+     not adjacent, and the right place is after the source.  */\n+  if ((edge_in->flags & EDGE_FALLTHRU) && edge_in->dest == EXIT_BLOCK_PTR)\n     {\n       before = NEXT_INSN (BB_END (edge_in->src));\n       bb = create_basic_block (before, NULL, edge_in->src);\n@@ -3177,6 +3177,21 @@ rtl_can_remove_branch_p (const_edge e)\n   return true;\n }\n \n+/* We do not want to declare these functions in a header file, since they\n+   should only be used through the cfghooks interface, and we do not want to\n+   move them here since it would require also moving quite a lot of related\n+   code.  They are in cfglayout.c.  */\n+extern bool cfg_layout_can_duplicate_bb_p (const_basic_block);\n+extern basic_block cfg_layout_duplicate_bb (basic_block);\n+\n+static basic_block\n+rtl_duplicate_bb (basic_block bb)\n+{\n+  bb = cfg_layout_duplicate_bb (bb);\n+  bb->aux = NULL;\n+  return bb;\n+}\n+\n /* Implementation of CFG manipulation for linearized RTL.  */\n struct cfg_hooks rtl_cfg_hooks = {\n   \"rtl\",\n@@ -3193,8 +3208,8 @@ struct cfg_hooks rtl_cfg_hooks = {\n   rtl_merge_blocks,\n   rtl_predict_edge,\n   rtl_predicted_by_p,\n-  NULL, /* can_duplicate_block_p */\n-  NULL, /* duplicate_block */\n+  cfg_layout_can_duplicate_bb_p,\n+  rtl_duplicate_bb,\n   rtl_split_edge,\n   rtl_make_forwarder_block,\n   rtl_tidy_fallthru_edge,\n@@ -3216,13 +3231,6 @@ struct cfg_hooks rtl_cfg_hooks = {\n    This representation will hopefully become the default one in future\n    version of the compiler.  */\n \n-/* We do not want to declare these functions in a header file, since they\n-   should only be used through the cfghooks interface, and we do not want to\n-   move them here since it would require also moving quite a lot of related\n-   code.  They are in cfglayout.c.  */\n-extern bool cfg_layout_can_duplicate_bb_p (const_basic_block);\n-extern basic_block cfg_layout_duplicate_bb (basic_block);\n-\n struct cfg_hooks cfg_layout_rtl_cfg_hooks = {\n   \"cfglayout mode\",\n   rtl_verify_flow_info_1,"}, {"sha": "0cbbbc5e40477c3c2f2d3649aa82998042d9987a", "filename": "gcc/function.c", "status": "modified", "additions": 458, "deletions": 225, "changes": 683, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffe1468659b160f34f296a3879a0894e45e644ba/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffe1468659b160f34f296a3879a0894e45e644ba/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=ffe1468659b160f34f296a3879a0894e45e644ba", "patch": "@@ -65,6 +65,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"df.h\"\n #include \"timevar.h\"\n #include \"vecprim.h\"\n+#include \"params.h\"\n+#include \"bb-reorder.h\"\n \n /* So we can assign to cfun in this file.  */\n #undef cfun\n@@ -5290,8 +5292,6 @@ requires_stack_frame_p (rtx insn, HARD_REG_SET prologue_used,\n   HARD_REG_SET hardregs;\n   unsigned regno;\n \n-  if (!INSN_P (insn) || DEBUG_INSN_P (insn))\n-    return false;\n   if (CALL_P (insn))\n     return !SIBLING_CALL_P (insn);\n \n@@ -5514,23 +5514,186 @@ set_return_jump_label (rtx returnjump)\n     JUMP_LABEL (returnjump) = ret_rtx;\n }\n \n-/* Return true if BB has any active insns.  */\n+#ifdef HAVE_simple_return\n+/* Create a copy of BB instructions and insert at BEFORE.  Redirect\n+   preds of BB to COPY_BB if they don't appear in NEED_PROLOGUE.  */\n+static void\n+dup_block_and_redirect (basic_block bb, basic_block copy_bb, rtx before,\n+\t\t\tbitmap_head *need_prologue)\n+{\n+  edge_iterator ei;\n+  edge e;\n+  rtx insn = BB_END (bb);\n+\n+  /* We know BB has a single successor, so there is no need to copy a\n+     simple jump at the end of BB.  */\n+  if (simplejump_p (insn))\n+    insn = PREV_INSN (insn);\n+\n+  start_sequence ();\n+  duplicate_insn_chain (BB_HEAD (bb), insn);\n+  if (dump_file)\n+    {\n+      unsigned count = 0;\n+      for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+\tif (active_insn_p (insn))\n+\t  ++count;\n+      fprintf (dump_file, \"Duplicating bb %d to bb %d, %u active insns.\\n\",\n+\t       bb->index, copy_bb->index, count);\n+    }\n+  insn = get_insns ();\n+  end_sequence ();\n+  emit_insn_before (insn, before);\n+\n+  /* Redirect all the paths that need no prologue into copy_bb.  */\n+  for (ei = ei_start (bb->preds); (e = ei_safe_edge (ei)); )\n+    if (!bitmap_bit_p (need_prologue, e->src->index))\n+      {\n+\tredirect_edge_and_branch_force (e, copy_bb);\n+\tcontinue;\n+      }\n+    else\n+      ei_next (&ei);\n+}\n+#endif\n+\n+#if defined (HAVE_return) || defined (HAVE_simple_return)\n+/* Return true if there are any active insns between HEAD and TAIL.  */\n static bool\n-bb_active_p (basic_block bb)\n+active_insn_between (rtx head, rtx tail)\n {\n+  while (tail)\n+    {\n+      if (active_insn_p (tail))\n+\treturn true;\n+      if (tail == head)\n+\treturn false;\n+      tail = PREV_INSN (tail);\n+    }\n+  return false;\n+}\n+\n+/* LAST_BB is a block that exits, and empty of active instructions.\n+   Examine its predecessors for jumps that can be converted to\n+   (conditional) returns.  */\n+static VEC (edge, heap) *\n+convert_jumps_to_returns (basic_block last_bb, bool simple_p,\n+\t\t\t  VEC (edge, heap) *unconverted ATTRIBUTE_UNUSED)\n+{\n+  int i;\n+  basic_block bb;\n   rtx label;\n+  edge_iterator ei;\n+  edge e;\n+  VEC(basic_block,heap) *src_bbs;\n+\n+  src_bbs = VEC_alloc (basic_block, heap, EDGE_COUNT (last_bb->preds));\n+  FOR_EACH_EDGE (e, ei, last_bb->preds)\n+    if (e->src != ENTRY_BLOCK_PTR)\n+      VEC_quick_push (basic_block, src_bbs, e->src);\n+\n+  label = BB_HEAD (last_bb);\n \n-  /* Test whether there are active instructions in BB.  */\n-  label = BB_END (bb);\n-  while (label && !LABEL_P (label))\n+  FOR_EACH_VEC_ELT (basic_block, src_bbs, i, bb)\n     {\n-      if (active_insn_p (label))\n-\tbreak;\n-      label = PREV_INSN (label);\n+      rtx jump = BB_END (bb);\n+\n+      if (!JUMP_P (jump) || JUMP_LABEL (jump) != label)\n+\tcontinue;\n+\n+      e = find_edge (bb, last_bb);\n+\n+      /* If we have an unconditional jump, we can replace that\n+\t with a simple return instruction.  */\n+      if (simplejump_p (jump))\n+\t{\n+\t  /* The use of the return register might be present in the exit\n+\t     fallthru block.  Either:\n+\t     - removing the use is safe, and we should remove the use in\n+\t     the exit fallthru block, or\n+\t     - removing the use is not safe, and we should add it here.\n+\t     For now, we conservatively choose the latter.  Either of the\n+\t     2 helps in crossjumping.  */\n+\t  emit_use_return_register_into_block (bb);\n+\n+\t  emit_return_into_block (simple_p, bb);\n+\t  delete_insn (jump);\n+\t}\n+\n+      /* If we have a conditional jump branching to the last\n+\t block, we can try to replace that with a conditional\n+\t return instruction.  */\n+      else if (condjump_p (jump))\n+\t{\n+\t  rtx dest;\n+\n+\t  if (simple_p)\n+\t    dest = simple_return_rtx;\n+\t  else\n+\t    dest = ret_rtx;\n+\t  if (!redirect_jump (jump, dest, 0))\n+\t    {\n+#ifdef HAVE_simple_return\n+\t      if (simple_p)\n+\t\t{\n+\t\t  if (dump_file)\n+\t\t    fprintf (dump_file,\n+\t\t\t     \"Failed to redirect bb %d branch.\\n\", bb->index);\n+\t\t  VEC_safe_push (edge, heap, unconverted, e);\n+\t\t}\n+#endif\n+\t      continue;\n+\t    }\n+\n+\t  /* See comment in simplejump_p case above.  */\n+\t  emit_use_return_register_into_block (bb);\n+\n+\t  /* If this block has only one successor, it both jumps\n+\t     and falls through to the fallthru block, so we can't\n+\t     delete the edge.  */\n+\t  if (single_succ_p (bb))\n+\t    continue;\n+\t}\n+      else\n+\t{\n+#ifdef HAVE_simple_return\n+\t  if (simple_p)\n+\t    {\n+\t      if (dump_file)\n+\t\tfprintf (dump_file,\n+\t\t\t \"Failed to redirect bb %d branch.\\n\", bb->index);\n+\t      VEC_safe_push (edge, heap, unconverted, e);\n+\t    }\n+#endif\n+\t  continue;\n+\t}\n+\n+      /* Fix up the CFG for the successful change we just made.  */\n+      redirect_edge_succ (e, EXIT_BLOCK_PTR);\n     }\n-  return BB_HEAD (bb) != label || !LABEL_P (label);\n+  VEC_free (basic_block, heap, src_bbs);\n+  return unconverted;\n }\n \n+/* Emit a return insn for the exit fallthru block.  */\n+static basic_block\n+emit_return_for_exit (edge exit_fallthru_edge, bool simple_p)\n+{\n+  basic_block last_bb = exit_fallthru_edge->src;\n+\n+  if (JUMP_P (BB_END (last_bb)))\n+    {\n+      last_bb = split_edge (exit_fallthru_edge);\n+      exit_fallthru_edge = single_succ_edge (last_bb);\n+    }\n+  emit_barrier_after (BB_END (last_bb));\n+  emit_return_into_block (simple_p, last_bb);\n+  exit_fallthru_edge->flags &= ~EDGE_FALLTHRU;\n+  return last_bb;\n+}\n+#endif\n+\n+\n /* Generate the prologue and epilogue RTL if the machine supports it.  Thread\n    this into place with notes indicating where the prologue ends and where\n    the epilogue begins.  Update the basic block information when possible.\n@@ -5583,20 +5746,17 @@ static void\n thread_prologue_and_epilogue_insns (void)\n {\n   bool inserted;\n-  basic_block last_bb;\n-  bool last_bb_active ATTRIBUTE_UNUSED;\n #ifdef HAVE_simple_return\n-  VEC (rtx, heap) *unconverted_simple_returns = NULL;\n-  basic_block simple_return_block_hot = NULL;\n-  basic_block simple_return_block_cold = NULL;\n+  VEC (edge, heap) *unconverted_simple_returns = NULL;\n   bool nonempty_prologue;\n+  bitmap_head bb_flags;\n+  unsigned max_grow_size;\n #endif\n-  rtx returnjump ATTRIBUTE_UNUSED;\n+  rtx returnjump;\n   rtx seq ATTRIBUTE_UNUSED, epilogue_end ATTRIBUTE_UNUSED;\n   rtx prologue_seq ATTRIBUTE_UNUSED, split_prologue_seq ATTRIBUTE_UNUSED;\n   edge e, entry_edge, orig_entry_edge, exit_fallthru_edge;\n   edge_iterator ei;\n-  bitmap_head bb_flags;\n \n   df_analyze ();\n \n@@ -5614,18 +5774,6 @@ thread_prologue_and_epilogue_insns (void)\n   entry_edge = single_succ_edge (ENTRY_BLOCK_PTR);\n   orig_entry_edge = entry_edge;\n \n-  exit_fallthru_edge = find_fallthru_edge (EXIT_BLOCK_PTR->preds);\n-  if (exit_fallthru_edge != NULL)\n-    {\n-      last_bb = exit_fallthru_edge->src;\n-      last_bb_active = bb_active_p (last_bb);\n-    }\n-  else\n-    {\n-      last_bb = NULL;\n-      last_bb_active = false;\n-    }\n-\n   split_prologue_seq = NULL_RTX;\n   if (flag_split_stack\n       && (lookup_attribute (\"no_split_stack\", DECL_ATTRIBUTES (cfun->decl))\n@@ -5675,9 +5823,9 @@ thread_prologue_and_epilogue_insns (void)\n     }\n #endif\n \n+#ifdef HAVE_simple_return\n   bitmap_initialize (&bb_flags, &bitmap_default_obstack);\n \n-#ifdef HAVE_simple_return\n   /* Try to perform a kind of shrink-wrapping, making sure the\n      prologue/epilogue is emitted only around those parts of the\n      function that require it.  */\n@@ -5697,11 +5845,11 @@ thread_prologue_and_epilogue_insns (void)\n       HARD_REG_SET prologue_clobbered, prologue_used, live_on_edge;\n       HARD_REG_SET set_up_by_prologue;\n       rtx p_insn;\n-\n       VEC(basic_block, heap) *vec;\n       basic_block bb;\n       bitmap_head bb_antic_flags;\n       bitmap_head bb_on_list;\n+      bitmap_head bb_tail;\n \n       if (dump_file)\n \tfprintf (dump_file, \"Attempting shrink-wrapping optimization.\\n\");\n@@ -5726,14 +5874,12 @@ thread_prologue_and_epilogue_insns (void)\n \n       prepare_shrink_wrap (entry_edge->dest);\n \n-      /* That may have inserted instructions into the last block.  */\n-      if (last_bb && !last_bb_active)\n-\tlast_bb_active = bb_active_p (last_bb);\n-\n       bitmap_initialize (&bb_antic_flags, &bitmap_default_obstack);\n       bitmap_initialize (&bb_on_list, &bitmap_default_obstack);\n+      bitmap_initialize (&bb_tail, &bitmap_default_obstack);\n \n-      /* Find the set of basic blocks that require a stack frame.  */\n+      /* Find the set of basic blocks that require a stack frame,\n+\t and blocks that are too big to be duplicated.  */\n \n       vec = VEC_alloc (basic_block, heap, n_basic_blocks);\n \n@@ -5747,66 +5893,80 @@ thread_prologue_and_epilogue_insns (void)\n \tadd_to_hard_reg_set (&set_up_by_prologue, Pmode,\n \t\t\t     PIC_OFFSET_TABLE_REGNUM);\n \n+      /* We don't use a different max size depending on\n+\t optimize_bb_for_speed_p because increasing shrink-wrapping\n+\t opportunities by duplicating tail blocks can actually result\n+\t in an overall decrease in code size.  */\n+      max_grow_size = get_uncond_jump_length ();\n+      max_grow_size *= PARAM_VALUE (PARAM_MAX_GROW_COPY_BB_INSNS);\n+\n       FOR_EACH_BB (bb)\n \t{\n \t  rtx insn;\n-\t  /* As a special case, check for jumps to the last bb that\n-\t     cannot successfully be converted to simple_returns later\n-\t     on, and mark them as requiring a frame.  These are\n-\t     conditional jumps that jump to their fallthru block, so\n-\t     it's not a case that is expected to occur often.  */\n-\t  if (JUMP_P (BB_END (bb)) && any_condjump_p (BB_END (bb))\n-\t      && single_succ_p (bb)\n-\t      && !last_bb_active\n-\t      && single_succ (bb) == last_bb)\n-\t    {\n-\t      bitmap_set_bit (&bb_flags, bb->index);\n-\t      VEC_quick_push (basic_block, vec, bb);\n-\t    }\n-\t  else\n-\t    FOR_BB_INSNS (bb, insn)\n-\t      if (requires_stack_frame_p (insn, prologue_used,\n-\t\t\t\t\t  set_up_by_prologue))\n-\t\t{\n-\t\t  bitmap_set_bit (&bb_flags, bb->index);\n-\t\t  VEC_quick_push (basic_block, vec, bb);\n-\t\t  break;\n-\t\t}\n+\t  unsigned size = 0;\n+\n+\t  FOR_BB_INSNS (bb, insn)\n+\t    if (NONDEBUG_INSN_P (insn))\n+\t      {\n+\t\tif (requires_stack_frame_p (insn, prologue_used,\n+\t\t\t\t\t    set_up_by_prologue))\n+\t\t  {\n+\t\t    if (bb == entry_edge->dest)\n+\t\t      goto fail_shrinkwrap;\n+\t\t    bitmap_set_bit (&bb_flags, bb->index);\n+\t\t    VEC_quick_push (basic_block, vec, bb);\n+\t\t    break;\n+\t\t  }\n+\t\telse if (size <= max_grow_size)\n+\t\t  {\n+\t\t    size += get_attr_min_length (insn);\n+\t\t    if (size > max_grow_size)\n+\t\t      bitmap_set_bit (&bb_on_list, bb->index);\n+\t\t  }\n+\t      }\n \t}\n \n+      /* Blocks that really need a prologue, or are too big for tails.  */\n+      bitmap_ior_into (&bb_on_list, &bb_flags);\n+\n       /* For every basic block that needs a prologue, mark all blocks\n \t reachable from it, so as to ensure they are also seen as\n \t requiring a prologue.  */\n       while (!VEC_empty (basic_block, vec))\n \t{\n \t  basic_block tmp_bb = VEC_pop (basic_block, vec);\n-\t  edge e;\n-\t  edge_iterator ei;\n+\n \t  FOR_EACH_EDGE (e, ei, tmp_bb->succs)\n \t    if (e->dest != EXIT_BLOCK_PTR\n \t\t&& bitmap_set_bit (&bb_flags, e->dest->index))\n \t      VEC_quick_push (basic_block, vec, e->dest);\n \t}\n-      /* If the last basic block contains only a label, we'll be able\n-\t to convert jumps to it to (potentially conditional) return\n-\t insns later.  This means we don't necessarily need a prologue\n-\t for paths reaching it.  */\n-      if (last_bb && optimize)\n+\n+      /* Find the set of basic blocks that need no prologue, have a\n+\t single successor, can be duplicated, meet a max size\n+\t requirement, and go to the exit via like blocks.  */\n+      VEC_quick_push (basic_block, vec, EXIT_BLOCK_PTR);\n+      while (!VEC_empty (basic_block, vec))\n \t{\n-\t  if (!last_bb_active)\n-\t    bitmap_clear_bit (&bb_flags, last_bb->index);\n-\t  else if (!bitmap_bit_p (&bb_flags, last_bb->index))\n-\t    goto fail_shrinkwrap;\n+\t  basic_block tmp_bb = VEC_pop (basic_block, vec);\n+\n+\t  FOR_EACH_EDGE (e, ei, tmp_bb->preds)\n+\t    if (single_succ_p (e->src)\n+\t\t&& !bitmap_bit_p (&bb_on_list, e->src->index)\n+\t\t&& can_duplicate_block_p (e->src)\n+\t\t&& bitmap_set_bit (&bb_tail, e->src->index))\n+\t      VEC_quick_push (basic_block, vec, e->src);\n \t}\n \n       /* Now walk backwards from every block that is marked as needing\n-\t a prologue to compute the bb_antic_flags bitmap.  */\n-      bitmap_copy (&bb_antic_flags, &bb_flags);\n+\t a prologue to compute the bb_antic_flags bitmap.  Exclude\n+\t tail blocks; They can be duplicated to be used on paths not\n+\t needing a prologue.  */\n+      bitmap_clear (&bb_on_list);\n+      bitmap_and_compl (&bb_antic_flags, &bb_flags, &bb_tail);\n       FOR_EACH_BB (bb)\n \t{\n-\t  edge e;\n-\t  edge_iterator ei;\n-\t  if (!bitmap_bit_p (&bb_flags, bb->index))\n+\t  if (!bitmap_bit_p (&bb_antic_flags, bb->index))\n \t    continue;\n \t  FOR_EACH_EDGE (e, ei, bb->preds)\n \t    if (!bitmap_bit_p (&bb_antic_flags, e->src->index)\n@@ -5816,8 +5976,6 @@ thread_prologue_and_epilogue_insns (void)\n       while (!VEC_empty (basic_block, vec))\n \t{\n \t  basic_block tmp_bb = VEC_pop (basic_block, vec);\n-\t  edge e;\n-\t  edge_iterator ei;\n \t  bool all_set = true;\n \n \t  bitmap_clear_bit (&bb_on_list, tmp_bb->index);\n@@ -5862,28 +6020,134 @@ thread_prologue_and_epilogue_insns (void)\n \t\t}\n \t  }\n \n-      /* Test whether the prologue is known to clobber any register\n-\t (other than FP or SP) which are live on the edge.  */\n-      CLEAR_HARD_REG_BIT (prologue_clobbered, STACK_POINTER_REGNUM);\n-      if (frame_pointer_needed)\n-\tCLEAR_HARD_REG_BIT (prologue_clobbered, HARD_FRAME_POINTER_REGNUM);\n-      CLEAR_HARD_REG_SET (live_on_edge);\n-      reg_set_to_hard_reg_set (&live_on_edge,\n-\t\t\t       df_get_live_in (entry_edge->dest));\n-      if (hard_reg_set_intersect_p (live_on_edge, prologue_clobbered))\n+      if (entry_edge != orig_entry_edge)\n \t{\n-\t  entry_edge = orig_entry_edge;\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \"Shrink-wrapping aborted due to clobber.\\n\");\n+\t  /* Test whether the prologue is known to clobber any register\n+\t     (other than FP or SP) which are live on the edge.  */\n+\t  CLEAR_HARD_REG_BIT (prologue_clobbered, STACK_POINTER_REGNUM);\n+\t  if (frame_pointer_needed)\n+\t    CLEAR_HARD_REG_BIT (prologue_clobbered, HARD_FRAME_POINTER_REGNUM);\n+\t  CLEAR_HARD_REG_SET (live_on_edge);\n+\t  reg_set_to_hard_reg_set (&live_on_edge,\n+\t\t\t\t   df_get_live_in (entry_edge->dest));\n+\t  if (hard_reg_set_intersect_p (live_on_edge, prologue_clobbered))\n+\t    {\n+\t      entry_edge = orig_entry_edge;\n+\t      if (dump_file)\n+\t\tfprintf (dump_file,\n+\t\t\t \"Shrink-wrapping aborted due to clobber.\\n\");\n+\t    }\n \t}\n-      else if (entry_edge != orig_entry_edge)\n+      if (entry_edge != orig_entry_edge)\n \t{\n \t  crtl->shrink_wrapped = true;\n \t  if (dump_file)\n \t    fprintf (dump_file, \"Performing shrink-wrapping.\\n\");\n+\n+\t  /* Find tail blocks reachable from both blocks needing a\n+\t     prologue and blocks not needing a prologue.  */\n+\t  if (!bitmap_empty_p (&bb_tail))\n+\t    FOR_EACH_BB (bb)\n+\t      {\n+\t\tbool some_pro, some_no_pro;\n+\t\tif (!bitmap_bit_p (&bb_tail, bb->index))\n+\t\t  continue;\n+\t\tsome_pro = some_no_pro = false;\n+\t\tFOR_EACH_EDGE (e, ei, bb->preds)\n+\t\t  {\n+\t\t    if (bitmap_bit_p (&bb_flags, e->src->index))\n+\t\t      some_pro = true;\n+\t\t    else\n+\t\t      some_no_pro = true;\n+\t\t  }\n+\t\tif (some_pro && some_no_pro)\n+\t\t  VEC_quick_push (basic_block, vec, bb);\n+\t\telse\n+\t\t  bitmap_clear_bit (&bb_tail, bb->index);\n+\t      }\n+\t  /* Find the head of each tail.  */\n+\t  while (!VEC_empty (basic_block, vec))\n+\t    {\n+\t      basic_block tbb = VEC_pop (basic_block, vec);\n+\n+\t      if (!bitmap_bit_p (&bb_tail, tbb->index))\n+\t\tcontinue;\n+\n+\t      while (single_succ_p (tbb))\n+\t\t{\n+\t\t  tbb = single_succ (tbb);\n+\t\t  bitmap_clear_bit (&bb_tail, tbb->index);\n+\t\t}\n+\t    }\n+\t  /* Now duplicate the tails.  */\n+\t  if (!bitmap_empty_p (&bb_tail))\n+\t    FOR_EACH_BB_REVERSE (bb)\n+\t      {\n+\t\tbasic_block copy_bb, tbb;\n+\t\trtx insert_point;\n+\t\tint eflags;\n+\n+\t\tif (!bitmap_clear_bit (&bb_tail, bb->index))\n+\t\t  continue;\n+\n+\t\t/* Create a copy of BB, instructions and all, for\n+\t\t   use on paths that don't need a prologue.\n+\t\t   Ideal placement of the copy is on a fall-thru edge\n+\t\t   or after a block that would jump to the copy.  */ \n+\t\tFOR_EACH_EDGE (e, ei, bb->preds)\n+\t\t  if (!bitmap_bit_p (&bb_flags, e->src->index)\n+\t\t      && single_succ_p (e->src))\n+\t\t    break;\n+\t\tif (e)\n+\t\t  {\n+\t\t    copy_bb = create_basic_block (NEXT_INSN (BB_END (e->src)),\n+\t\t\t\t\t\t  NULL_RTX, e->src);\n+\t\t    BB_COPY_PARTITION (copy_bb, e->src);\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    /* Otherwise put the copy at the end of the function.  */\n+\t\t    copy_bb = create_basic_block (NULL_RTX, NULL_RTX,\n+\t\t\t\t\t\t  EXIT_BLOCK_PTR->prev_bb);\n+\t\t    BB_COPY_PARTITION (copy_bb, bb);\n+\t\t  }\n+\n+\t\tinsert_point = emit_note_after (NOTE_INSN_DELETED,\n+\t\t\t\t\t\tBB_END (copy_bb));\n+\t\temit_barrier_after (BB_END (copy_bb));\n+\n+\t\ttbb = bb;\n+\t\twhile (1)\n+\t\t  {\n+\t\t    dup_block_and_redirect (tbb, copy_bb, insert_point,\n+\t\t\t\t\t    &bb_flags);\n+\t\t    tbb = single_succ (tbb);\n+\t\t    if (tbb == EXIT_BLOCK_PTR)\n+\t\t      break;\n+\t\t    e = split_block (copy_bb, PREV_INSN (insert_point));\n+\t\t    copy_bb = e->dest;\n+\t\t  }\n+\n+\t\t/* Quiet verify_flow_info by (ab)using EDGE_FAKE.\n+\t\t   We have yet to add a simple_return to the tails,\n+\t\t   as we'd like to first convert_jumps_to_returns in\n+\t\t   case the block is no longer used after that.  */\n+\t\teflags = EDGE_FAKE;\n+\t\tif (CALL_P (PREV_INSN (insert_point))\n+\t\t    && SIBLING_CALL_P (PREV_INSN (insert_point)))\n+\t\t  eflags = EDGE_SIBCALL | EDGE_ABNORMAL;\n+\t\tmake_single_succ_edge (copy_bb, EXIT_BLOCK_PTR, eflags);\n+\n+\t\t/* verify_flow_info doesn't like a note after a\n+\t\t   sibling call.  */\n+\t\tdelete_insn (insert_point);\n+\t\tif (bitmap_empty_p (&bb_tail))\n+\t\t  break;\n+\t      }\n \t}\n \n     fail_shrinkwrap:\n+      bitmap_clear (&bb_tail);\n       bitmap_clear (&bb_antic_flags);\n       bitmap_clear (&bb_on_list);\n       VEC_free (basic_block, heap, vec);\n@@ -5911,147 +6175,73 @@ thread_prologue_and_epilogue_insns (void)\n \n   rtl_profile_for_bb (EXIT_BLOCK_PTR);\n \n-#ifdef HAVE_return\n+  exit_fallthru_edge = find_fallthru_edge (EXIT_BLOCK_PTR->preds);\n+\n   /* If we're allowed to generate a simple return instruction, then by\n      definition we don't need a full epilogue.  If the last basic\n      block before the exit block does not contain active instructions,\n      examine its predecessors and try to emit (conditional) return\n      instructions.  */\n-  if (optimize && !last_bb_active\n-      && (HAVE_return || entry_edge != orig_entry_edge))\n+#ifdef HAVE_simple_return\n+  if (entry_edge != orig_entry_edge)\n     {\n-      edge_iterator ei2;\n-      int i;\n-      basic_block bb;\n-      rtx label;\n-      VEC(basic_block,heap) *src_bbs;\n-\n-      if (exit_fallthru_edge == NULL)\n-\tgoto epilogue_done;\n-      label = BB_HEAD (last_bb);\n-\n-      src_bbs = VEC_alloc (basic_block, heap, EDGE_COUNT (last_bb->preds));\n-      FOR_EACH_EDGE (e, ei2, last_bb->preds)\n-\tif (e->src != ENTRY_BLOCK_PTR)\n-\t  VEC_quick_push (basic_block, src_bbs, e->src);\n-\n-      FOR_EACH_VEC_ELT (basic_block, src_bbs, i, bb)\n+      if (optimize)\n \t{\n-\t  bool simple_p;\n-\t  rtx jump;\n-\t  e = find_edge (bb, last_bb);\n-\n-\t  jump = BB_END (bb);\n+\t  unsigned i, last;\n \n-#ifdef HAVE_simple_return\n-\t  simple_p = (entry_edge != orig_entry_edge\n-\t\t      && !bitmap_bit_p (&bb_flags, bb->index));\n-#else\n-\t  simple_p = false;\n-#endif\n-\n-\t  if (!simple_p\n-\t      && (!HAVE_return || !JUMP_P (jump)\n-\t\t  || JUMP_LABEL (jump) != label))\n-\t    continue;\n-\n-\t  /* If we have an unconditional jump, we can replace that\n-\t     with a simple return instruction.  */\n-\t  if (!JUMP_P (jump))\n-\t    {\n-\t      emit_barrier_after (BB_END (bb));\n-\t      emit_return_into_block (simple_p, bb);\n-\t    }\n-\t  else if (simplejump_p (jump))\n+\t  /* convert_jumps_to_returns may add to EXIT_BLOCK_PTR->preds\n+\t     (but won't remove).  Stop at end of current preds.  */\n+\t  last = EDGE_COUNT (EXIT_BLOCK_PTR->preds);\n+\t  for (i = 0; i < last; i++)\n \t    {\n-\t      /* The use of the return register might be present in the exit\n-\t         fallthru block.  Either:\n-\t         - removing the use is safe, and we should remove the use in\n-\t           the exit fallthru block, or\n-\t         - removing the use is not safe, and we should add it here.\n-\t         For now, we conservatively choose the latter.  Either of the\n-\t         2 helps in crossjumping.  */\n-\t      emit_use_return_register_into_block (bb);\n-\n-\t      emit_return_into_block (simple_p, bb);\n-\t      delete_insn (jump);\n+\t      e = EDGE_I (EXIT_BLOCK_PTR->preds, i);\n+\t      if (LABEL_P (BB_HEAD (e->src))\n+\t\t  && !bitmap_bit_p (&bb_flags, e->src->index)\n+\t\t  && !active_insn_between (BB_HEAD (e->src), BB_END (e->src)))\n+\t\tunconverted_simple_returns\n+\t\t  = convert_jumps_to_returns (e->src, true,\n+\t\t\t\t\t      unconverted_simple_returns);\n \t    }\n-\t  else if (condjump_p (jump) && JUMP_LABEL (jump) != label)\n-\t    {\n-\t      basic_block new_bb;\n-\t      edge new_e;\n+\t}\n \n-\t      gcc_assert (simple_p);\n-\t      new_bb = split_edge (e);\n-\t      emit_barrier_after (BB_END (new_bb));\n-\t      emit_return_into_block (simple_p, new_bb);\n-#ifdef HAVE_simple_return\n-\t      if (BB_PARTITION (new_bb) == BB_HOT_PARTITION)\n-\t\tsimple_return_block_hot = new_bb;\n-\t      else\n-\t\tsimple_return_block_cold = new_bb;\n-#endif\n-\t      new_e = single_succ_edge (new_bb);\n-\t      redirect_edge_succ (new_e, EXIT_BLOCK_PTR);\n+      if (exit_fallthru_edge != NULL\n+\t  && EDGE_COUNT (exit_fallthru_edge->src->preds) != 0\n+\t  && !bitmap_bit_p (&bb_flags, exit_fallthru_edge->src->index))\n+\t{\n+\t  basic_block last_bb;\n \n-\t      continue;\n-\t    }\n-\t  /* If we have a conditional jump branching to the last\n-\t     block, we can try to replace that with a conditional\n-\t     return instruction.  */\n-\t  else if (condjump_p (jump))\n-\t    {\n-\t      rtx dest;\n-\t      if (simple_p)\n-\t\tdest = simple_return_rtx;\n-\t      else\n-\t\tdest = ret_rtx;\n-\t      if (! redirect_jump (jump, dest, 0))\n-\t\t{\n-#ifdef HAVE_simple_return\n-\t\t  if (simple_p)\n-\t\t    VEC_safe_push (rtx, heap,\n-\t\t\t\t   unconverted_simple_returns, jump);\n+\t  last_bb = emit_return_for_exit (exit_fallthru_edge, true);\n+\t  returnjump = BB_END (last_bb);\n+\t  exit_fallthru_edge = NULL;\n+\t}\n+    }\n #endif\n-\t\t  continue;\n-\t\t}\n+#ifdef HAVE_return\n+  if (HAVE_return)\n+    {\n+      if (exit_fallthru_edge == NULL)\n+\tgoto epilogue_done;\n \n-\t      /* See comment in simple_jump_p case above.  */\n-\t      emit_use_return_register_into_block (bb);\n+      if (optimize)\n+\t{\n+\t  basic_block last_bb = exit_fallthru_edge->src;\n \n-\t      /* If this block has only one successor, it both jumps\n-\t\t and falls through to the fallthru block, so we can't\n-\t\t delete the edge.  */\n-\t      if (single_succ_p (bb))\n-\t\tcontinue;\n-\t    }\n-\t  else\n+\t  if (LABEL_P (BB_HEAD (last_bb))\n+\t      && !active_insn_between (BB_HEAD (last_bb), BB_END (last_bb)))\n+\t    convert_jumps_to_returns (last_bb, false, NULL);\n+\n+\t  if (EDGE_COUNT (exit_fallthru_edge->src->preds) != 0)\n \t    {\n+\t      last_bb = emit_return_for_exit (exit_fallthru_edge, false);\n+\t      epilogue_end = returnjump = BB_END (last_bb);\n #ifdef HAVE_simple_return\n-\t      if (simple_p)\n-\t\tVEC_safe_push (rtx, heap,\n-\t\t\t       unconverted_simple_returns, jump);\n+\t      /* Emitting the return may add a basic block.\n+\t\t Fix bb_flags for the added block.  */\n+\t      if (last_bb != exit_fallthru_edge->src)\n+\t\tbitmap_set_bit (&bb_flags, last_bb->index);\n #endif\n-\t      continue;\n+\t      goto epilogue_done;\n \t    }\n-\n-\t  /* Fix up the CFG for the successful change we just made.  */\n-\t  redirect_edge_succ (e, EXIT_BLOCK_PTR);\n-\t}\n-      VEC_free (basic_block, heap, src_bbs);\n-\n-      if (HAVE_return)\n-\t{\n-\t  /* Emit a return insn for the exit fallthru block.  Whether\n-\t     this is still reachable will be determined later.  */\n-\n-\t  emit_barrier_after (BB_END (last_bb));\n-\t  emit_return_into_block (false, last_bb);\n-\t  epilogue_end = BB_END (last_bb);\n-\t  if (JUMP_P (epilogue_end))\n-\t    set_return_jump_label (epilogue_end);\n-\t  single_succ_edge (last_bb)->flags &= ~EDGE_FALLTHRU;\n-\t  goto epilogue_done;\n \t}\n     }\n #endif\n@@ -6171,10 +6361,13 @@ thread_prologue_and_epilogue_insns (void)\n      convert to conditional simple_returns, but couldn't for some\n      reason, create a block to hold a simple_return insn and redirect\n      those remaining edges.  */\n-  if (!VEC_empty (rtx, unconverted_simple_returns))\n+  if (!VEC_empty (edge, unconverted_simple_returns))\n     {\n+      basic_block simple_return_block_hot = NULL;\n+      basic_block simple_return_block_cold = NULL;\n+      edge pending_edge_hot = NULL;\n+      edge pending_edge_cold = NULL;\n       basic_block exit_pred = EXIT_BLOCK_PTR->prev_bb;\n-      rtx jump;\n       int i;\n \n       gcc_assert (entry_edge != orig_entry_edge);\n@@ -6184,25 +6377,48 @@ thread_prologue_and_epilogue_insns (void)\n       if (returnjump != NULL_RTX\n \t  && JUMP_LABEL (returnjump) == simple_return_rtx)\n \t{\n-\t  edge e = split_block (exit_fallthru_edge->src,\n-\t\t\t\tPREV_INSN (returnjump));\n+\t  e = split_block (BLOCK_FOR_INSN (returnjump), PREV_INSN (returnjump));\n \t  if (BB_PARTITION (e->src) == BB_HOT_PARTITION)\n \t    simple_return_block_hot = e->dest;\n \t  else\n \t    simple_return_block_cold = e->dest;\n \t}\n \n-      FOR_EACH_VEC_ELT (rtx, unconverted_simple_returns, i, jump)\n+      /* Also check returns we might need to add to tail blocks.  */\n+      FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)\n+\tif (EDGE_COUNT (e->src->preds) != 0\n+\t    && (e->flags & EDGE_FAKE) != 0\n+\t    && !bitmap_bit_p (&bb_flags, e->src->index))\n+\t  {\n+\t    if (BB_PARTITION (e->src) == BB_HOT_PARTITION)\n+\t      pending_edge_hot = e;\n+\t    else\n+\t      pending_edge_cold = e;\n+\t  }\n+\n+      FOR_EACH_VEC_ELT (edge, unconverted_simple_returns, i, e)\n \t{\n-\t  basic_block src_bb = BLOCK_FOR_INSN (jump);\n-\t  edge e = find_edge (src_bb, last_bb);\n \t  basic_block *pdest_bb;\n+\t  edge pending;\n \n-\t  if (BB_PARTITION (src_bb) == BB_HOT_PARTITION)\n-\t    pdest_bb = &simple_return_block_hot;\n+\t  if (BB_PARTITION (e->src) == BB_HOT_PARTITION)\n+\t    {\n+\t      pdest_bb = &simple_return_block_hot;\n+\t      pending = pending_edge_hot;\n+\t    }\n \t  else\n-\t    pdest_bb = &simple_return_block_cold;\n-\t  if (*pdest_bb == NULL)\n+\t    {\n+\t      pdest_bb = &simple_return_block_cold;\n+\t      pending = pending_edge_cold;\n+\t    }\n+\n+\t  if (*pdest_bb == NULL && pending != NULL)\n+\t    {\n+\t      emit_return_into_block (true, pending->src);\n+\t      pending->flags &= ~(EDGE_FALLTHRU | EDGE_FAKE);\n+\t      *pdest_bb = pending->src;\n+\t    }\n+\t  else if (*pdest_bb == NULL)\n \t    {\n \t      basic_block bb;\n \t      rtx start;\n@@ -6219,7 +6435,19 @@ thread_prologue_and_epilogue_insns (void)\n \t    }\n \t  redirect_edge_and_branch_force (e, *pdest_bb);\n \t}\n-      VEC_free (rtx, heap, unconverted_simple_returns);\n+      VEC_free (edge, heap, unconverted_simple_returns);\n+    }\n+\n+  if (entry_edge != orig_entry_edge)\n+    {\n+      FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)\n+\tif (EDGE_COUNT (e->src->preds) != 0\n+\t    && (e->flags & EDGE_FAKE) != 0\n+\t    && !bitmap_bit_p (&bb_flags, e->src->index))\n+\t  {\n+\t    emit_return_into_block (true, e->src);\n+\t    e->flags &= ~(EDGE_FALLTHRU | EDGE_FAKE);\n+\t  }\n     }\n #endif\n \n@@ -6233,8 +6461,11 @@ thread_prologue_and_epilogue_insns (void)\n \n       if (!CALL_P (insn)\n \t  || ! SIBLING_CALL_P (insn)\n+#ifdef HAVE_simple_return\n \t  || (entry_edge != orig_entry_edge\n-\t      && !bitmap_bit_p (&bb_flags, bb->index)))\n+\t      && !bitmap_bit_p (&bb_flags, bb->index))\n+#endif\n+\t  )\n \t{\n \t  ei_next (&ei);\n \t  continue;\n@@ -6281,7 +6512,9 @@ thread_prologue_and_epilogue_insns (void)\n     }\n #endif\n \n+#ifdef HAVE_simple_return\n   bitmap_clear (&bb_flags);\n+#endif\n \n   /* Threading the prologue and epilogue changes the artificial refs\n      in the entry and exit blocks.  */"}, {"sha": "ce60ce27604e550df61edef619979964d150aa16", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffe1468659b160f34f296a3879a0894e45e644ba/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffe1468659b160f34f296a3879a0894e45e644ba/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=ffe1468659b160f34f296a3879a0894e45e644ba", "patch": "@@ -4167,13 +4167,14 @@ dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n \tif (NONDEBUG_INSN_P (insn))\n \t  df_simulate_find_defs (insn, merge_set);\n \n+#ifdef HAVE_simple_return\n       /* If shrink-wrapping, disable this optimization when test_bb is\n \t the first basic block and merge_bb exits.  The idea is to not\n \t move code setting up a return register as that may clobber a\n \t register used to pass function parameters, which then must be\n \t saved in caller-saved regs.  A caller-saved reg requires the\n \t prologue, killing a shrink-wrap opportunity.  */\n-      if ((flag_shrink_wrap && !epilogue_completed)\n+      if ((flag_shrink_wrap && HAVE_simple_return && !epilogue_completed)\n \t  && ENTRY_BLOCK_PTR->next_bb == test_bb\n \t  && single_succ_p (new_dest)\n \t  && single_succ (new_dest) == EXIT_BLOCK_PTR\n@@ -4224,6 +4225,7 @@ dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n \t    }\n \t  BITMAP_FREE (return_regs);\n \t}\n+#endif\n     }\n \n  no_body:"}]}