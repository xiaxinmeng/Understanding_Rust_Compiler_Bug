{"sha": "e63d44c2a9d2a95c7f23de189966be0a3dcc5923", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTYzZDQ0YzJhOWQyYTk1YzdmMjNkZTE4OTk2NmJlMGEzZGNjNTkyMw==", "commit": {"author": {"name": "Robin Dapp", "email": "rdapp@linux.vnet.ibm.com", "date": "2015-11-23T08:05:33Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2015-11-23T08:05:33Z"}, "message": "S/390: Fix symbol ref alignment\n\nThis patch fixes the treatment of symbol ref alignments for\narrays and structs in S390. Until now, the NOT_NATURALLY_ALIGNED flag\nwas not correctly set for array elements and structs larger than 8\nbytes. Therefore, load relative instructions that require a specific\nalignment would not always be generated. This patch uses separate flags\nfor 2-, 4-, and 8-byte alignment to fix the problem.\n\ngcc/testsuite/ChangeLog:\n\n2015-11-23  Robin Dapp  <rdapp@linux.vnet.ibm.com>\n\n        * gcc.target/s390/load-relative-check.c: New test to check\n        generation of load relative instructions.\n\n\ngcc/ChangeLog:\n\n2015-11-23  Robin Dapp  <rdapp@linux.vnet.ibm.com>\n\n        * config/s390/s390.h: Add new symref flags, _NOTALIGN2 etc.\n        * config/s390/s390.c (s390_check_symref_alignment): Use new\n        symref flags, early abort on wrong alignment\n        (s390_secondary_reload): Use new symref flags.\n        (s390_encode_section_info): Likewise.\n        * config/s390/predicates.md: Likewise.\n\nFrom-SVN: r230735", "tree": {"sha": "f06f2517d73d42a2b0cfdbbf9e92039a2fbf3069", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f06f2517d73d42a2b0cfdbbf9e92039a2fbf3069"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e63d44c2a9d2a95c7f23de189966be0a3dcc5923", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e63d44c2a9d2a95c7f23de189966be0a3dcc5923", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e63d44c2a9d2a95c7f23de189966be0a3dcc5923", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e63d44c2a9d2a95c7f23de189966be0a3dcc5923/comments", "author": {"login": "rdapp1", "id": 22046046, "node_id": "MDQ6VXNlcjIyMDQ2MDQ2", "avatar_url": "https://avatars.githubusercontent.com/u/22046046?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rdapp1", "html_url": "https://github.com/rdapp1", "followers_url": "https://api.github.com/users/rdapp1/followers", "following_url": "https://api.github.com/users/rdapp1/following{/other_user}", "gists_url": "https://api.github.com/users/rdapp1/gists{/gist_id}", "starred_url": "https://api.github.com/users/rdapp1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rdapp1/subscriptions", "organizations_url": "https://api.github.com/users/rdapp1/orgs", "repos_url": "https://api.github.com/users/rdapp1/repos", "events_url": "https://api.github.com/users/rdapp1/events{/privacy}", "received_events_url": "https://api.github.com/users/rdapp1/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6e9966e8303f5f39870a11d96a64b376a2fab347", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e9966e8303f5f39870a11d96a64b376a2fab347", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e9966e8303f5f39870a11d96a64b376a2fab347"}], "stats": {"total": 164, "additions": 136, "deletions": 28}, "files": [{"sha": "22cf2bd85faae105903a519a0858f74569f41f7a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e63d44c2a9d2a95c7f23de189966be0a3dcc5923/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e63d44c2a9d2a95c7f23de189966be0a3dcc5923/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e63d44c2a9d2a95c7f23de189966be0a3dcc5923", "patch": "@@ -1,3 +1,12 @@\n+2015-11-23  Robin Dapp  <rdapp@linux.vnet.ibm.com>\n+\n+        * config/s390/s390.h: Add new symref flags, _NOTALIGN2 etc.\n+        * config/s390/s390.c (s390_check_symref_alignment): Use new\n+        symref flags, early abort on wrong alignment\n+        (s390_secondary_reload): Use new symref flags.\n+        (s390_encode_section_info): Likewise.\n+        * config/s390/predicates.md: Likewise.\n+\n 2015-11-23  Kugan Vivekanandarajah  <kuganv@linaro.org>\n \n \tPR target/68390"}, {"sha": "893092b9f4696f7693265430bd7cde449fed313d", "filename": "gcc/config/s390/predicates.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e63d44c2a9d2a95c7f23de189966be0a3dcc5923/gcc%2Fconfig%2Fs390%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e63d44c2a9d2a95c7f23de189966be0a3dcc5923/gcc%2Fconfig%2Fs390%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fpredicates.md?ref=e63d44c2a9d2a95c7f23de189966be0a3dcc5923", "patch": "@@ -122,7 +122,7 @@\n   if (GET_CODE (op) == LABEL_REF)\n     return true;\n   if (GET_CODE (op) == SYMBOL_REF)\n-    return (!SYMBOL_REF_ALIGN1_P (op)\n+    return (!SYMBOL_FLAG_NOTALIGN2_P (op)\n \t    && SYMBOL_REF_TLS_MODEL (op) == 0\n \t    && (!flag_pic || SYMBOL_REF_LOCAL_P (op)));\n \n@@ -147,7 +147,7 @@\n   if (GET_CODE (op) == LABEL_REF)\n     return true;\n   if (GET_CODE (op) == SYMBOL_REF)\n-    return ((SYMBOL_REF_FLAGS (op) & SYMBOL_FLAG_ALIGN1) == 0\n+    return (!SYMBOL_FLAG_NOTALIGN2_P (op)\n \t    && SYMBOL_REF_TLS_MODEL (op) == 0\n \t    && (!flag_pic || SYMBOL_REF_LOCAL_P (op)));\n "}, {"sha": "5a7406c65ce702c23954eb4769a99b4e48b09c80", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 45, "deletions": 20, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e63d44c2a9d2a95c7f23de189966be0a3dcc5923/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e63d44c2a9d2a95c7f23de189966be0a3dcc5923/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=e63d44c2a9d2a95c7f23de189966be0a3dcc5923", "patch": "@@ -3922,15 +3922,30 @@ s390_check_symref_alignment (rtx addr, HOST_WIDE_INT alignment)\n   HOST_WIDE_INT addend;\n   rtx symref;\n \n+  /* The \"required alignment\" might be 0 (e.g. for certain structs\n+     accessed via BLKmode).  Early abort in this case, as well as when\n+     an alignment > 8 is required.  */\n+  if (alignment < 2 || alignment > 8)\n+    return false;\n+\n   if (!s390_loadrelative_operand_p (addr, &symref, &addend))\n     return false;\n \n   if (addend & (alignment - 1))\n     return false;\n \n-  if (GET_CODE (symref) == SYMBOL_REF\n-      && !SYMBOL_REF_NOT_NATURALLY_ALIGNED_P (symref))\n-    return true;\n+  if (GET_CODE (symref) == SYMBOL_REF)\n+    {\n+      /* We have load-relative instructions for 2-byte, 4-byte, and\n+         8-byte alignment so allow only these.  */\n+      switch (alignment)\n+\t{\n+\tcase 8:\treturn !SYMBOL_FLAG_NOTALIGN8_P (symref);\n+\tcase 4:\treturn !SYMBOL_FLAG_NOTALIGN4_P (symref);\n+\tcase 2:\treturn !SYMBOL_FLAG_NOTALIGN2_P (symref);\n+\tdefault: return false;\n+\t}\n+    }\n \n   if (GET_CODE (symref) == UNSPEC\n       && alignment <= UNITS_PER_LONG)\n@@ -4062,7 +4077,7 @@ s390_secondary_reload (bool in_p, rtx x, reg_class_t rclass_i,\n       if (in_p\n \t  && s390_loadrelative_operand_p (x, &symref, &offset)\n \t  && mode == Pmode\n-\t  && !SYMBOL_REF_ALIGN1_P (symref)\n+\t  && !SYMBOL_FLAG_NOTALIGN2_P (symref)\n \t  && (offset & 1) == 1)\n \tsri->icode = ((mode == DImode) ? CODE_FOR_reloaddi_larl_odd_addend_z10\n \t\t      : CODE_FOR_reloadsi_larl_odd_addend_z10);\n@@ -11813,29 +11828,39 @@ s390_encode_section_info (tree decl, rtx rtl, int first)\n \n   if (TREE_CODE (decl) == VAR_DECL)\n     {\n-      /* If a variable has a forced alignment to < 2 bytes, mark it\n-\t with SYMBOL_FLAG_ALIGN1 to prevent it from being used as LARL\n-\t operand.  */\n-      if (DECL_USER_ALIGN (decl) && DECL_ALIGN (decl) < 16)\n-\tSYMBOL_REF_FLAGS (XEXP (rtl, 0)) |= SYMBOL_FLAG_ALIGN1;\n-      if (!DECL_SIZE (decl)\n-\t  || !DECL_ALIGN (decl)\n-\t  || !tree_fits_shwi_p (DECL_SIZE (decl))\n-\t  || (DECL_ALIGN (decl) <= 64\n-\t      && DECL_ALIGN (decl) != tree_to_shwi (DECL_SIZE (decl))))\n-\tSYMBOL_REF_FLAGS (XEXP (rtl, 0)) |= SYMBOL_FLAG_NOT_NATURALLY_ALIGNED;\n+      /* Store the alignment to be able to check if we can use\n+\t a larl/load-relative instruction.  We only handle the cases\n+\t that can go wrong (i.e. no FUNC_DECLs).  If a symref does\n+\t not have any flag we assume it to be correctly aligned.  */\n+\n+      if (DECL_ALIGN (decl) % 64)\n+\tSYMBOL_FLAG_SET_NOTALIGN8 (XEXP (rtl, 0));\n+\n+      if (DECL_ALIGN (decl) % 32)\n+\tSYMBOL_FLAG_SET_NOTALIGN4 (XEXP (rtl, 0));\n+\n+      if (DECL_ALIGN (decl) == 0 || DECL_ALIGN (decl) % 16)\n+\tSYMBOL_FLAG_SET_NOTALIGN2 (XEXP (rtl, 0));\n     }\n \n   /* Literal pool references don't have a decl so they are handled\n      differently here.  We rely on the information in the MEM_ALIGN\n-     entry to decide upon natural alignment.  */\n+     entry to decide upon the alignment.  */\n   if (MEM_P (rtl)\n       && GET_CODE (XEXP (rtl, 0)) == SYMBOL_REF\n       && TREE_CONSTANT_POOL_ADDRESS_P (XEXP (rtl, 0))\n-      && (MEM_ALIGN (rtl) == 0\n-\t  || GET_MODE_BITSIZE (GET_MODE (rtl)) == 0\n-\t  || MEM_ALIGN (rtl) < GET_MODE_BITSIZE (GET_MODE (rtl))))\n-    SYMBOL_REF_FLAGS (XEXP (rtl, 0)) |= SYMBOL_FLAG_NOT_NATURALLY_ALIGNED;\n+      && MEM_ALIGN (rtl) != 0\n+      && GET_MODE_BITSIZE (GET_MODE (rtl)) != 0)\n+    {\n+      if (MEM_ALIGN (rtl) % 64)\n+\tSYMBOL_FLAG_SET_NOTALIGN8 (XEXP (rtl, 0));\n+\n+      if (MEM_ALIGN (rtl) % 32)\n+\tSYMBOL_FLAG_SET_NOTALIGN4 (XEXP (rtl, 0));\n+\n+      if (MEM_ALIGN (rtl) == 0 || MEM_ALIGN (rtl) % 16)\n+\tSYMBOL_FLAG_SET_NOTALIGN2 (XEXP (rtl, 0));\n+    }\n }\n \n /* Output thunk to FILE that implements a C++ virtual function call (with"}, {"sha": "0f9225c6f8446fbb2939f6322fe26b5173ff1c91", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 29, "deletions": 6, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e63d44c2a9d2a95c7f23de189966be0a3dcc5923/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e63d44c2a9d2a95c7f23de189966be0a3dcc5923/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=e63d44c2a9d2a95c7f23de189966be0a3dcc5923", "patch": "@@ -963,12 +963,35 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define CLZ_DEFINED_VALUE_AT_ZERO(MODE, VALUE) ((VALUE) = 64, 1)\n \n /* Machine-specific symbol_ref flags.  */\n-#define SYMBOL_FLAG_ALIGN1\t          (SYMBOL_FLAG_MACH_DEP << 0)\n-#define SYMBOL_REF_ALIGN1_P(X)\t\t\\\n-  ((SYMBOL_REF_FLAGS (X) & SYMBOL_FLAG_ALIGN1))\n-#define SYMBOL_FLAG_NOT_NATURALLY_ALIGNED (SYMBOL_FLAG_MACH_DEP << 1)\n-#define SYMBOL_REF_NOT_NATURALLY_ALIGNED_P(X) \\\n-  ((SYMBOL_REF_FLAGS (X) & SYMBOL_FLAG_NOT_NATURALLY_ALIGNED))\n+#define SYMBOL_FLAG_ALIGN_SHIFT\t  SYMBOL_FLAG_MACH_DEP_SHIFT\n+#define SYMBOL_FLAG_ALIGN_MASK    \\\n+  ((SYMBOL_FLAG_MACH_DEP << 0) | (SYMBOL_FLAG_MACH_DEP << 1))\n+\n+#define SYMBOL_FLAG_SET_ALIGN(X, A) \\\n+    (SYMBOL_REF_FLAGS (X) = (SYMBOL_REF_FLAGS (X) & ~SYMBOL_FLAG_ALIGN_MASK) \\\n+     | (A << SYMBOL_FLAG_ALIGN_SHIFT))\n+\n+#define SYMBOL_FLAG_GET_ALIGN(X) \\\n+    ((SYMBOL_REF_FLAGS (X) & SYMBOL_FLAG_ALIGN_MASK) >> SYMBOL_FLAG_ALIGN_SHIFT)\n+\n+/* Helpers to access symbol_ref flags.  They are used in\n+   check_symref_alignment() and larl_operand to detect if the\n+   available alignment matches the required one.  We do not use\n+   a positive check like _ALIGN2 because in that case we would have\n+   to annotate every symbol_ref.  However, we only want to touch\n+   the symbol_refs that can be misaligned and assume that the others\n+   are correctly aligned.  Hence, if a symbol_ref does not have\n+   a _NOTALIGN flag it is supposed to be correctly aligned.  */\n+#define SYMBOL_FLAG_SET_NOTALIGN2(X) SYMBOL_FLAG_SET_ALIGN(X, 1)\n+#define SYMBOL_FLAG_SET_NOTALIGN4(X) SYMBOL_FLAG_SET_ALIGN(X, 2)\n+#define SYMBOL_FLAG_SET_NOTALIGN8(X) SYMBOL_FLAG_SET_ALIGN(X, 3)\n+\n+#define SYMBOL_FLAG_NOTALIGN2_P(X) (SYMBOL_FLAG_GET_ALIGN(X) == 1)\n+#define SYMBOL_FLAG_NOTALIGN4_P(X) (SYMBOL_FLAG_GET_ALIGN(X) == 2 \\\n+\t\t\t\t    || SYMBOL_FLAG_GET_ALIGN(X) == 1)\n+#define SYMBOL_FLAG_NOTALIGN8_P(X) (SYMBOL_FLAG_GET_ALIGN(X) == 3 \\\n+\t\t\t\t    || SYMBOL_FLAG_GET_ALIGN(X) == 2 \\\n+\t\t\t\t    || SYMBOL_FLAG_GET_ALIGN(X) == 1)\n \n /* Check whether integer displacement is in range for a short displacement.  */\n #define SHORT_DISP_IN_RANGE(d) ((d) >= 0 && (d) <= 4095)"}, {"sha": "7a2484cd0a43bcd9d73ad4cd9b9dae0a730ea0d2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e63d44c2a9d2a95c7f23de189966be0a3dcc5923/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e63d44c2a9d2a95c7f23de189966be0a3dcc5923/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e63d44c2a9d2a95c7f23de189966be0a3dcc5923", "patch": "@@ -1,3 +1,8 @@\n+2015-11-23  Robin Dapp  <rdapp@linux.vnet.ibm.com>\n+\n+        * gcc.target/s390/load-relative-check.c: New test to check\n+        generation of load relative instructions.\n+\n 2015-11-22  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \t* gfortran.dg/fmt_t_8.f90: New test."}, {"sha": "5290045761bef373ea64ad377ea3650dce129a20", "filename": "gcc/testsuite/gcc.target/s390/load-relative-check.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e63d44c2a9d2a95c7f23de189966be0a3dcc5923/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fload-relative-check.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e63d44c2a9d2a95c7f23de189966be0a3dcc5923/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fload-relative-check.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fload-relative-check.c?ref=e63d44c2a9d2a95c7f23de189966be0a3dcc5923", "patch": "@@ -0,0 +1,46 @@\n+/* Check if load-relative instructions are created */\n+/* { dg-do compile { target { s390*-*-* } } } */\n+/* { dg-options \"-O2 -march=z10\" } */\n+\n+/* { dg-final { scan-assembler \"lgfrl\\t%r.?,b.4\" } } */\n+/* { dg-final { scan-assembler \"lgfrl\\t%r.?,s.12\" } } */\n+/* { dg-final { scan-assembler \"lgrl\\t%r.?,s\" } } */\n+/* { dg-final { scan-assembler \"larl\\t%r.?,.L.?\" } } */\n+\n+int b[20];\n+\n+struct s\n+{\n+  long a;\n+  int  b;\n+  int  c;\n+} s;\n+\n+struct __attribute__((packed)) s2\n+{\n+  char a;\n+  char b;\n+  char c;\n+} s2;\n+\n+char __attribute__((aligned(1))) arr[10];\n+\n+int foo()\n+  {\n+    return b[1];\n+  }\n+\n+int bar()\n+  {\n+    return s.c;\n+  }\n+\n+long bar2()\n+  {\n+    return s.a;\n+  }\n+\n+int baz()\n+  {\n+    return arr[1];\n+  }"}]}