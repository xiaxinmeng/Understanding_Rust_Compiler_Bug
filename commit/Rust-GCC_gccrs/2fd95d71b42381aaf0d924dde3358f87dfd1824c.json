{"sha": "2fd95d71b42381aaf0d924dde3358f87dfd1824c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmZkOTVkNzFiNDIzODFhYWYwZDkyNGRkZTMzNThmODdkZmQxODI0Yw==", "commit": {"author": {"name": "Jason Thorpe", "email": "thorpej@wasabisystems.com", "date": "2002-02-03T20:53:44Z"}, "committer": {"name": "Jason Thorpe", "email": "thorpej@gcc.gnu.org", "date": "2002-02-03T20:53:44Z"}, "message": "config.gcc: Set cpu_type to m68k for 68010, as well.\n\n* config.gcc: Set cpu_type to m68k for 68010, as well.\n(m68010-*-netbsdelf*): New...\n(m68k*-*-netbsdelf*): ...targets.\n* config/m68k/netbsd-elf.h: New file.\n\nFrom-SVN: r49464", "tree": {"sha": "2a4f1086b4cdfc5da3098b905a006bcbdb776f20", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2a4f1086b4cdfc5da3098b905a006bcbdb776f20"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2fd95d71b42381aaf0d924dde3358f87dfd1824c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fd95d71b42381aaf0d924dde3358f87dfd1824c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2fd95d71b42381aaf0d924dde3358f87dfd1824c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fd95d71b42381aaf0d924dde3358f87dfd1824c/comments", "author": null, "committer": null, "parents": [{"sha": "ffe80457ad349901ab46f53b92f9e380f2475be6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffe80457ad349901ab46f53b92f9e380f2475be6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffe80457ad349901ab46f53b92f9e380f2475be6"}], "stats": {"total": 541, "additions": 540, "deletions": 1}, "files": [{"sha": "4b3d7264a02d63fe8c9d233be5125d90ddb38e23", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd95d71b42381aaf0d924dde3358f87dfd1824c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd95d71b42381aaf0d924dde3358f87dfd1824c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2fd95d71b42381aaf0d924dde3358f87dfd1824c", "patch": "@@ -1,3 +1,10 @@\n+2002-02-03  Jason Thorpe  <thorpej@wasabisystems.com>\n+\n+\t* config.gcc: Set cpu_type to m68k for 68010, as well.\n+\t(m68010-*-netbsdelf*): New...\n+\t(m68k*-*-netbsdelf*): ...targets.\n+\t* config/m68k/netbsd-elf.h: New file.\n+\n 2002-02-02  Kazu Hirata  <kazu@hxi.com>\n \n \t* config/h8300/h8300.c (hand_list): Move inside function_arg."}, {"sha": "f043f790eb336bd61060d30020202eaf79dfca4d", "filename": "gcc/config.gcc", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd95d71b42381aaf0d924dde3358f87dfd1824c/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd95d71b42381aaf0d924dde3358f87dfd1824c/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=2fd95d71b42381aaf0d924dde3358f87dfd1824c", "patch": "@@ -243,7 +243,7 @@ ia64-*-*)\n hppa*-*-* | parisc*-*-*)\n \tcpu_type=pa\n \t;;\n-m680[02]0-*-*)\n+m680[012]0-*-*)\n \tcpu_type=m68k\n \textra_headers=math-68881.h\n \t;;\n@@ -1932,6 +1932,18 @@ m68k-*-lynxos*)\n \ttmake_file=m68k/t-lynx\n \tfloat_format=m68k\n \t;;\n+m68010-*-netbsdelf* | m68k*-*-netbsdelf*)\n+\ttm_file=\"${tm_file} dbxelf.h elfos.h netbsd.h netbsd-elf.h m68k/netbsd-elf.h\"\n+\tcase $machine in\n+\tm68010*)\n+\t\ttarget_cpu_default=\"0\"\n+\t\t;;\n+\t*)\n+\t\ttarget_cpu_default=\"MASK_68020|MASK_68881|MASK_BITFIELD\"\n+\t\t;;\n+\tesac\n+\tfloat_format=m68k\n+\t;;\n m68k*-*-netbsd*)\n \ttm_file=m68k/netbsd.h\n \ttmake_file=t-netbsd"}, {"sha": "eb155d30d4a42b9487e2280a3d88d0976883d76a", "filename": "gcc/config/m68k/netbsd-elf.h", "status": "added", "additions": 520, "deletions": 0, "changes": 520, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd95d71b42381aaf0d924dde3358f87dfd1824c/gcc%2Fconfig%2Fm68k%2Fnetbsd-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd95d71b42381aaf0d924dde3358f87dfd1824c/gcc%2Fconfig%2Fm68k%2Fnetbsd-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fnetbsd-elf.h?ref=2fd95d71b42381aaf0d924dde3358f87dfd1824c", "patch": "@@ -0,0 +1,520 @@\n+/* Definitions of target machine for GNU compiler,\n+   for m68k (including m68010) NetBSD platforms using the\n+   ELF object format.\n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Contributed by Wasabi Systems. Inc.\n+\n+   This file is derived from <m68k/m68kv4.h>, <m68k/m68kelf.h>,\n+   and <m68k/linux.h>.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 1, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+\n+/* Default target comes from config.gcc */\n+#undef TARGET_DEFAULT\n+#define TARGET_DEFAULT TARGET_CPU_DEFAULT\n+\n+\n+/* Don't try using XFmode on the 68010.  */ \n+#if TARGET_DEFAULT == 0\n+#undef LONG_DOUBLE_TYPE_SIZE\n+#define LONG_DOUBLE_TYPE_SIZE 64\n+\n+/* Use software floating point emulator for REAL_ARITHMETIC and\n+   decimal <-> binary conversion.  */\n+#define REAL_ARITHMETIC\n+#endif\n+\n+#ifdef __mc68010__\n+#define LIBGCC2_LONG_DOUBLE_TYPE_SIZE 64\n+#endif\n+\n+#define EXTRA_SPECS \\\n+  { \"cpp_cpu_default_spec\", CPP_CPU_DEFAULT_SPEC }, \\\n+  { \"cpp_cpu_spec\",         CPP_CPU_SPEC }, \\\n+  { \"cpp_fpu_spec\",         CPP_FPU_SPEC }, \\\n+  { \"asm_default_spec\",     ASM_DEFAULT_SPEC },\n+\n+\n+#define CPP_CPU_SPEC \\\n+  \"%{m68010:-D__mc68010__} \\\n+   %{m68020:-D__mc68020__} \\\n+   %{m68030:-D__mc68030__} \\\n+   %{m68040:-D__mc68040__} \\\n+   %(cpp_cpu_default_spec)\"\n+\n+\n+#undef TARGET_VERSION\n+#if TARGET_DEFAULT & MASK_68020\n+#define TARGET_VERSION fprintf (stderr, \" (NetBSD/m68k ELF)\");\n+#define CPP_CPU_DEFAULT_SPEC \"%{!m680*:-D__mc68020__}\"\n+#define ASM_DEFAULT_SPEC \"%{!m680*:-m68020}\"\n+#else\n+#define TARGET_VERSION fprintf (stderr, \" (NetBSD/68010 ELF)\");\n+#define CPP_CPU_DEFAULT_SPEC \"%{!m680*:-D__mc68010__}\"\n+#define ASM_DEFAULT_SPEC \"%{!m680*:-m68010}\"\n+#endif\n+\n+\n+#if TARGET_DEFAULT & MASK_68881\n+#define CPP_FPU_SPEC \"%{!msoft-float:-D__HAVE_68881__ -D__HAVE_FPU__}\"\n+#else\n+#define CPP_FPU_SPEC \"%{m68881:-D__HAVE_68881__ -D__HAVE_FPU__}\"\n+#endif\n+\n+\n+/* Provide a CPP_SPEC appropriate for NetBSD m68k targets.  Currently we\n+   deal with the GCC option '-posix', as well as an indication as to\n+   whether or not use of the FPU is allowed.  */\n+\n+#undef CPP_SPEC\n+#define CPP_SPEC \\\n+  \"%{posix:-D_POSIX_SOURCE} %(cpp_cpu_spec) %(cpp_fpu_spec)\"\n+\n+\n+/* Provide an ASM_SPEC appropriate for NetBSD m68k ELF targets.  We pass\n+   on some CPU options, as well as PIC code generation options.  */\n+\n+#undef ASM_SPEC\n+#define ASM_SPEC \\\n+  \" %| %(asm_default_spec) \\\n+    %{m68010} %{m68020} %{m68030} %{m68040} %{m68060} \\\n+    %{fpic:-k} %{fPIC:-k -K}\"\n+\n+\n+/* Provide a set of CPP pre-definitions and pre-assertions appropriate\n+   for NetBSD m68k ELF targets (using the SVR4 ABI).  */\n+\n+#undef CPP_PREDEFINES\n+#define CPP_PREDEFINES \\\n+  \"-D__NetBSD__ -D__ELF__ -D__m68k__ -D__SVR4_ABI__ -D__motorola__ \\\n+   -Asystem=unix -Asystem=NetBSD -Acpu=m68k -Amachine=m68k\"\n+\n+\n+/* Provide a LINK_SPEC appropriate for a NetBSD/m68k ELF target.\n+   This is a copy of LINK_SPEC from <netbsd-elf.h> tweaked for\n+   the m68k target.  */\n+\n+#undef LINK_SPEC\n+#define LINK_SPEC\t\t\t\t\t\t\t\\\n+  \"%{assert*} %{R*}\t\t\t\t\t\t\t\\\n+   %{shared:-shared}\t\t\t\t\t\t\t\\\n+   %{!shared:\t\t\t\t\t\t\t\t\\\n+     -dc -dp\t\t\t\t\t\t\t\t\\\n+     %{!nostdlib:\t\t\t\t\t\t\t\\\n+       %{!r*:\t\t\t\t\t\t\t\t\\\n+\t %{!e*:-e _start}}}\t\t\t\t\t\t\\\n+     %{!static:\t\t\t\t\t\t\t\t\\\n+       %{rdynamic:-export-dynamic}\t\t\t\t\t\\\n+       %{!dynamic-linker:-dynamic-linker /usr/libexec/ld.elf_so}}\t\\\n+     %{static:-static}}\"\n+\n+\n+/* Output assembler code to FILE to increment profiler label # LABELNO\n+   for profiling a function only.  */\n+\n+#undef FUNCTION_PROFILER\n+#define FUNCTION_PROFILER(FILE, LABELNO)\t\t\t\t\\\n+do\t\t\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    asm_fprintf (FILE, \"\\tlea (%LLP%d,%Rpc),%Ra1\\n\", (LABELNO));\t\\\n+    if (flag_pic)\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\tbsr.l __mcount@PLTPC\\n\");\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\tjbsr __mcount\\n\");\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+while (0)\n+\n+\n+/* Make gcc agree with <machine/ansi.h>  */\n+\n+#undef SIZE_TYPE\n+#define SIZE_TYPE \"unsigned int\"\n+\n+#undef PTRDIFF_TYPE\n+#define PTRDIFF_TYPE \"int\"\n+\n+#undef WCHAR_TYPE\n+#define WCHAR_TYPE \"int\"\n+\n+#undef WCHAR_UNSIGNED\n+#define WCHAR_UNSIGNED 0\n+\n+#undef WCHAR_TYPE_SIZE\n+#define WCHAR_TYPE_SIZE 32\n+\n+\n+/* XXX\n+   Here is a bunch of stuff lifted from m68kelf.h.  We don't use that\n+   file directly, because it has a lot of baggage we don't want.  */\n+\n+#define MOTOROLA\t/* Use Motorola syntax */\n+#define USE_GAS\t\t/* But GAS wants jbsr instead of jsr */\n+\n+\n+/* The prefix for register names.  Note that REGISTER_NAMES\n+   is supposed to include this prefix.  Also note that this is NOT an\n+   fprintf format string, it is a literal string.  */\n+\n+#undef REGISTER_PREFIX\n+#define REGISTER_PREFIX \"%\"\n+\n+\n+/* The prefix for local (compiler generated) lables.\n+   These labels will not appear in the symbol table.  */\n+\n+#undef LOCAL_LABEL_PREFIX\n+#define LOCAL_LABEL_PREFIX \".\"\n+\n+\n+/* The prefix to add to user-visible assembler symbols.  */\n+\n+#undef USER_LABEL_PREFIX\n+#define USER_LABEL_PREFIX \"\"\n+\n+\n+/* The prefix for immediate operands.  */\n+\n+#undef IMMEDIATE_PREFIX\n+#define IMMEDIATE_PREFIX \"#\"\n+\n+\n+#undef ASM_COMMENT_START\n+#define ASM_COMMENT_START \"|\"\n+\n+\n+/* How to refer to registers in assembler output.\n+   This sequence is indexed by compiler's hard-register-number.\n+   Motorola format uses different register names than defined in m68k.h.\n+   We also take this chance to convert 'a6' to 'fp' */\n+\n+#undef REGISTER_NAMES\n+\n+#ifndef SUPPORT_SUN_FPA\n+\n+#define REGISTER_NAMES\t\t\t\t\t\t\t\\\n+{\"%d0\",   \"%d1\",   \"%d2\",   \"%d3\",   \"%d4\",   \"%d5\",   \"%d6\",   \"%d7\",\t\\\n+ \"%a0\",   \"%a1\",   \"%a2\",   \"%a3\",   \"%a4\",   \"%a5\",   \"%fp\",   \"%sp\",\t\\\n+ \"%fp0\",  \"%fp1\",  \"%fp2\",  \"%fp3\",  \"%fp4\",  \"%fp5\",  \"%fp6\",  \"%fp7\" }\n+\n+#else /* SUPPORT_SUN_FPA */\n+\n+#define REGISTER_NAMES\t\t\t\t\t\t\t\\\n+{\"%d0\",   \"%d1\",   \"%d2\",   \"%d3\",   \"%d4\",   \"%d5\",   \"%d6\",   \"%d7\",\t\\\n+ \"%a0\",   \"%a1\",   \"%a2\",   \"%a3\",   \"%a4\",   \"%a5\",   \"%fp\",   \"%sp\",\t\\\n+ \"%fp0\",  \"%fp1\",  \"%fp2\",  \"%fp3\",  \"%fp4\",  \"%fp5\",  \"%fp6\",  \"%fp7\",\t\\\n+ \"%fpa0\", \"%fpa1\", \"%fpa2\", \"%fpa3\", \"%fpa4\", \"%fpa5\", \"%fpa6\",\"%fpa7\",\t\\\n+ \"%fpa8\", \"%fpa9\", \"%fpa10\",\"%fpa11\",\"%fpa12\",\"%fpa13\",\"%fpa14\",\"%fpa15\", \\\n+ \"%fpa16\",\"%fpa17\",\"%fpa18\",\"%fpa19\",\"%fpa20\",\"%fpa21\",\"%fpa22\",\"%fpa23\", \\\n+ \"%fpa24\",\"%fpa25\",\"%fpa26\",\"%fpa27\",\"%fpa28\",\"%fpa29\",\"%fpa30\",\"%fpa31\" }\n+\n+#endif /* ! SUPPORT_SUN_FPA */\n+\n+\n+/* Currently, JUMP_TABLES_IN_TEXT_SECTION must be defined in order to\n+   keep switch tables in the text section.  */\n+\n+#undef JUMP_TABLES_IN_TEXT_SECTION\n+#define JUMP_TABLES_IN_TEXT_SECTION 1\n+\n+\n+/* Use the default action for outputting the case label.  */\n+#undef ASM_OUTPUT_CASE_LABEL\n+#define ASM_RETURN_CASE_JUMP\t\t\t\t\t\t\\\n+do\t\t\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    if (TARGET_5200)\t\t\t\t\t\t\t\\\n+      return \"ext%.l %0\\n\\tjmp %%pc@(2,%0:l)\";\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      return \"jmp %%pc@(2,%0:w)\";\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+while (0)\n+\n+\n+/* This is how to output an assembler line that says to advance the\n+   location counter to a multiple of 2**LOG bytes.  */\n+\n+#undef ASM_OUTPUT_ALIGN\n+#define ASM_OUTPUT_ALIGN(FILE,LOG)\t\t\t\t\t\\\n+do\t\t\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    if ((LOG) > 0)\t\t\t\t\t\t\t\\\n+      fprintf ((FILE), \"%s%u\\n\", ALIGN_ASM_OP, 1 << (LOG));\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+while (0)\n+\n+\n+/* If defined, a C expression whose value is a string containing the\n+   assembler operation to identify the following data as uninitialized global\n+   data.  */\n+\n+#define BSS_SECTION_ASM_OP\t\".section\\t.bss\"\n+\n+\n+/* Like `ASM_OUTPUT_BSS' except takes the required alignment as a\n+   separate, explicit argument.  If you define this macro, it is used\n+   in place of `ASM_OUTPUT_BSS', and gives you more flexibility in\n+   handling the required alignment of the variable.  The alignment is\n+   specified as the number of bits.\n+\n+   Try to use function `asm_output_aligned_bss' defined in file\n+   `varasm.c' when defining this macro.  */\n+\n+#undef ASM_OUTPUT_ALIGNED_BSS\n+#define ASM_OUTPUT_ALIGNED_BSS(FILE, DECL, NAME, SIZE, ALIGN)\t\t\\\n+  asm_output_aligned_bss (FILE, DECL, NAME, SIZE, ALIGN)\n+\n+\n+#undef ASM_OUTPUT_COMMON\n+#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)\t\t\t\\\n+( fputs (\".comm \", (FILE)),\t\t\t\t\t\t\\\n+  assemble_name ((FILE), (NAME)),\t\t\t\t\t\\\n+  fprintf ((FILE), \",%u\\n\", (SIZE)))\n+\n+#undef ASM_OUTPUT_LOCAL\n+#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)\t\t\t\\\n+( fputs (\".lcomm \", (FILE)),\t\t\t\t\t\t\\\n+  assemble_name ((FILE), (NAME)),\t\t\t\t\t\\\n+  fprintf ((FILE), \",%u\\n\", (SIZE)))\n+\n+\n+/* Turn off function cse if we are doing PIC. We always want function\n+   call to be done as `bsr foo@PLTPC', so it will force the assembler\n+   to create the PLT entry for `foo'.  Doing function cse will cause\n+   the address of `foo' to be loaded into a register, which is exactly\n+   what we want to avoid when we are doing PIC on svr4 m68k.  */\n+\n+#undef SUBTARGET_OVERRIDE_OPTIONS\n+#define SUBTARGET_OVERRIDE_OPTIONS\t\t\t\t\t\\\n+  if (flag_pic) flag_no_function_cse = 1;\n+\n+\n+/* XXX\n+   This is the end of the chunk lifted from m68kelf.h  */\n+\n+\n+/* XXX\n+   The following chunk is more or less lifted from m68kv4.h.\n+   We'd like to just #include that file, but it has not yet\n+   been converted to the new include style.\n+\n+   Should there be a m68kv4-abi.h ??  */\n+\n+\n+/* Register in which address to store a structure value is passed to a\n+   function.  The default in m68k.h is a1.  For m68k/SVR4 it is a0. */\n+\n+#undef STRUCT_VALUE_REGNUM\n+#define STRUCT_VALUE_REGNUM 8\n+\n+\n+/* Register in which static-chain is passed to a function.  The\n+   default isn m68k.h is a0, but that is already the struct value\n+   regnum.  Make it a1 instead.  */\n+\n+#undef STATIC_CHAIN_REGNUM\n+#define STATIC_CHAIN_REGNUM 9\n+\n+\n+/* Now to renumber registers for dbx and gdb.\n+   We use the Sun-3 convention, which is:\n+   floating point registers have numbers 18 to 25, not\n+   16 to 23 as they do in the compiler.  */\n+\n+#undef DBX_REGISTER_NUMBER\n+#define DBX_REGISTER_NUMBER(REGNO) ((REGNO) < 16 ? (REGNO) : (REGNO) + 2)\n+\n+\n+/* 1 if N is a possible register number for a function value.  For\n+   m68k/SVR4 allow d0, a0, or fp0 as return registers, for integral,\n+   pointer, or floating types, respectively.  Reject fp0 if not using\n+   a 68881 coprocessor.  */\n+\n+#undef FUNCTION_VALUE_REGNO_P\n+#define FUNCTION_VALUE_REGNO_P(N)\t\t\t\t\t\\\n+  ((N) == 0 || (N) == 8 || (TARGET_68881 && (N) == 16))\n+\n+\n+/* Define this to be true when FUNCTION_VALUE_REGNO_P is true for\n+   more than one register.  */\n+\n+#undef NEEDS_UNTYPED_CALL\n+#define NEEDS_UNTYPED_CALL 1\n+\n+\n+/* Define how to generate (in the callee) the output value of a\n+   function and how to find (in the caller) the value returned by a\n+   function.  VALTYPE is the data type of the value (as a tree).  If\n+   the precise function being called is known, FUNC is its\n+   FUNCTION_DECL; otherwise, FUNC is 0.  For m68k/SVR4 generate the\n+   result in d0, a0, or fp0 as appropriate. */\n+\n+#undef FUNCTION_VALUE\n+#define FUNCTION_VALUE(VALTYPE, FUNC)\t\t\t\t\t\\\n+  (TREE_CODE (VALTYPE) == REAL_TYPE && TARGET_68881\t\t\t\\\n+   ? gen_rtx_REG (TYPE_MODE (VALTYPE), 16)\t\t\t\t\\\n+   : (POINTER_TYPE_P (VALTYPE)\t\t\t\t\t\t\\\n+      ? gen_rtx_REG (TYPE_MODE (VALTYPE), 8)\t\t\t\t\\\n+      : gen_rtx_REG (TYPE_MODE (VALTYPE), 0)))\n+\n+\n+/* For compatibility with the large body of existing code which does\n+   not always properly declare external functions returning pointer\n+   types, the m68k/SVR4 convention is to copy the value returned for\n+   pointer functions from a0 to d0 in the function epilogue, so that\n+   callers that have neglected to properly declare the callee can\n+   still find the correct return value.  */\n+\n+extern int current_function_returns_pointer;\n+#define FUNCTION_EXTRA_EPILOGUE(FILE, SIZE) \t\t\t\t\\\n+do\t\t\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    if (current_function_returns_pointer\t\t\t\t\\\n+\t&& ! find_equiv_reg (0, get_last_insn (), 0, 0, 0, 8, Pmode))\t\\\n+      asm_fprintf (FILE, \"\\tmove.l %Ra0,%Rd0\\n\");\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+while (0)\n+\n+\n+/* Define how to find the value returned by a library function\n+   assuming the value has mode MODE.\n+   For m68k/SVR4 look for integer values in d0, pointer values in d0\n+   (returned in both d0 and a0), and floating values in fp0.  */\n+\n+#undef LIBCALL_VALUE\n+#define LIBCALL_VALUE(MODE)\t\t\t\t\t\t\\\n+  ((((MODE) == SFmode || (MODE) == DFmode || (MODE) == XFmode)\t\t\\\n+    && TARGET_68881)\t\t\t\t\t\t\t\\\n+   ? gen_rtx_REG (MODE, 16)\t\t\t\t\t\t\\\n+   : gen_rtx_REG (MODE, 0))\n+\n+\n+/* Boundary (in *bits*) on which stack pointer should be aligned.\n+   The m68k/SVR4 convention is to keep the stack pointer longword aligned. */\n+\n+#undef STACK_BOUNDARY\n+#define STACK_BOUNDARY 32\n+\n+\n+/* Alignment of field after `int : 0' in a structure.\n+   For m68k/SVR4, this is the next longword boundary. */\n+\n+#undef EMPTY_FIELD_BOUNDARY\n+#define EMPTY_FIELD_BOUNDARY 32\n+\n+\n+/* No data type wants to be aligned rounder than this.\n+   For m68k/SVR4, some types (doubles for example) are aligned on 8 byte\n+   boundaries */\n+\n+#undef BIGGEST_ALIGNMENT\n+#define BIGGEST_ALIGNMENT 64\n+\n+\n+/* In m68k svr4, a symbol_ref rtx can be a valid PIC operand if it is\n+   an operand of a function call. */\n+\n+#undef LEGITIMATE_PIC_OPERAND_P\n+#define LEGITIMATE_PIC_OPERAND_P(X)\t\t\t\t\t\\\n+  ((! symbolic_operand (X, VOIDmode)\t\t\t\t\t\\\n+    && ! (GET_CODE (X) == CONST_DOUBLE && mem_for_const_double (X)\t\\\n+\t  && GET_CODE (mem_for_const_double (X)) == MEM\t\t\t\\\n+\t  && symbolic_operand (XEXP (mem_for_const_double (X), 0),\t\\\n+\t\t\t       VOIDmode)))\t\t\t\t\\\n+   || (GET_CODE (X) == SYMBOL_REF && SYMBOL_REF_FLAG (X))\t\t\\\n+   || PCREL_GENERAL_OPERAND_OK)\n+\n+\n+/* For m68k SVR4, structures are returned using the reentrant\n+   technique. */\n+\n+#undef PCC_STATIC_STRUCT_RETURN\n+\n+\n+/* The svr4 ABI for the m68k says that records and unions are returned\n+   in memory.  */\n+\n+#undef DEFAULT_PCC_STRUCT_RETURN\n+#define DEFAULT_PCC_STRUCT_RETURN 1\n+\n+\n+/* Output code to add DELTA to the first argument, and then jump to FUNCTION.\n+   Used for C++ multiple inheritance.  */\n+\n+#define ASM_OUTPUT_MI_THUNK(FILE, THUNK_FNDECL, DELTA, FUNCTION)\t\\\n+do\t\t\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    if (DELTA > 0 && DELTA <= 8)\t\t\t\t\t\\\n+      asm_fprintf (FILE, \"\\taddq.l %I%d,4(%Rsp)\\n\", DELTA);\t\t\\\n+    else if (DELTA < 0 && DELTA >= -8)\t\t\t\t\t\\\n+      asm_fprintf (FILE, \"\\tsubq.l %I%d,4(%Rsp)\\n\", -DELTA);\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      asm_fprintf (FILE, \"\\tadd.l %I%d,4(%Rsp)\\n\", DELTA);\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    if (flag_pic)\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tfprintf (FILE, \"\\tbra.l \");\t\t\t\t\t\\\n+\tassemble_name (FILE, XSTR (XEXP (DECL_RTL (FUNCTION), 0), 0));\t\\\n+\tfprintf (FILE, \"@PLTPC\\n\");\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tfprintf (FILE, \"\\tjmp \");\t\t\t\t\t\\\n+\tassemble_name (FILE, XSTR (XEXP (DECL_RTL (FUNCTION), 0), 0));\t\\\n+\tfprintf (FILE, \"\\n\");\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+while (0)\n+\n+\n+/* Output assembler code for a block containing the constant parts\n+   of a trampoline, leaving space for the variable parts.  */\n+\n+/* On m68k svr4, the trampoline is different from the generic version\n+   in that we use a1 as the static call chain.  */\n+\n+#undef TRAMPOLINE_TEMPLATE\n+#define TRAMPOLINE_TEMPLATE(FILE)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  assemble_aligned_integer (2, GEN_INT (0x227a));\t\t\t\\\n+  assemble_aligned_integer (2, GEN_INT (8));\t\t\t\t\\\n+  assemble_aligned_integer (2, GEN_INT (0x2f3a));\t\t\t\\\n+  assemble_aligned_integer (2, GEN_INT (8));\t\t\t\t\\\n+  assemble_aligned_integer (2, GEN_INT (0x4e75));\t\t\t\\\n+  assemble_aligned_integer (4, const0_rtx);\t\t\t\t\\\n+  assemble_aligned_integer (4, const0_rtx);\t\t\t\t\\\n+}\n+\n+/* Redefine since we are using a different trampoline */\n+#undef TRAMPOLINE_SIZE\n+#define TRAMPOLINE_SIZE 18\n+\n+/* Emit RTL insns to initialize the variable parts of a trampoline.\n+   FNADDR is an RTX for the address of the function's pure code.\n+   CXT is an RTX for the static chain value for the function.  */\n+\n+#undef INITIALIZE_TRAMPOLINE\n+#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (TRAMP, 10)), CXT); \\\n+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (TRAMP, 14)), FNADDR); \\\n+}\n+\n+\n+/* XXX\n+   This is the end of the chunk lifted from m68kv4.h  */"}]}