{"sha": "893306188659dafdd4fe386235039b0ec4b8c4c8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODkzMzA2MTg4NjU5ZGFmZGQ0ZmUzODYyMzUwMzliMGVjNGI4YzRjOA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-07-13T22:12:54Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-07-13T22:12:54Z"}, "message": "cgraph.h (symtab_node): Add nonzero_address.\n\n\n\t* cgraph.h (symtab_node): Add nonzero_address.\n\t(decl_in_symtab_p): Break out from ...\n\t(symtab_get_node): ... here.\n\t* fold-const.c: Include cgraph.h\n\t(tree_single_nonzero_warnv_p): Use symtab to determine\n\tif symbol is non-zero.\n\t* symtab.c (symtab_node::nonzero_address): New method.\n\n\t* gcc.dg/pr36901.h: Simplify because non-zero symbol folding no\n\tlonger happens during parsing.\n\t* gcc.dg/pr44024.c: Update template.\n\t* g++.dg/tree-ssa/nonzero-2.C: New testcase.\n\t* g++.dg/tree-ssa/nonzero-1.C: New testcase.\n\t* gcc.dg/tree-ssa/nonzero-1.c: New testcase.\n\nFrom-SVN: r212499", "tree": {"sha": "205f9c439effd6b0b1d8538404e92216504a3f4c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/205f9c439effd6b0b1d8538404e92216504a3f4c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/893306188659dafdd4fe386235039b0ec4b8c4c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/893306188659dafdd4fe386235039b0ec4b8c4c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/893306188659dafdd4fe386235039b0ec4b8c4c8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/893306188659dafdd4fe386235039b0ec4b8c4c8/comments", "author": null, "committer": null, "parents": [{"sha": "69dc8208ee905dbc2a6d04faa4cec7211874745e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69dc8208ee905dbc2a6d04faa4cec7211874745e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69dc8208ee905dbc2a6d04faa4cec7211874745e"}], "stats": {"total": 182, "additions": 161, "deletions": 21}, "files": [{"sha": "6017987531abb1baff7ae15547362e75c615a1c7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/893306188659dafdd4fe386235039b0ec4b8c4c8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/893306188659dafdd4fe386235039b0ec4b8c4c8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=893306188659dafdd4fe386235039b0ec4b8c4c8", "patch": "@@ -1,3 +1,13 @@\n+2014-07-13  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* cgraph.h (symtab_node): Add nonzero_address.\n+\t(decl_in_symtab_p): Break out from ...\n+\t(symtab_get_node): ... here.\n+\t* fold-const.c: Include cgraph.h\n+\t(tree_single_nonzero_warnv_p): Use symtab to determine\n+\tif symbol is non-zero.\n+\t* symtab.c (symtab_node::nonzero_address): New method.\n+\n 2014-07-12  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* ipa-devirt.c (odr_subtypes_equivalent_p): Disable temporary hack"}, {"sha": "e7332203978a4b9e7ffd40ffb8815fdd4ae70823", "filename": "gcc/c-family/cilk.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/893306188659dafdd4fe386235039b0ec4b8c4c8/gcc%2Fc-family%2Fcilk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/893306188659dafdd4fe386235039b0ec4b8c4c8/gcc%2Fc-family%2Fcilk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fcilk.c?ref=893306188659dafdd4fe386235039b0ec4b8c4c8", "patch": "@@ -314,6 +314,7 @@ create_cilk_helper_decl (struct wrapper_data *wd)\n   tree block = make_node (BLOCK);\n   DECL_INITIAL (fndecl) = block;\n   TREE_USED (block) = 1;\n+  BLOCK_SUPERCONTEXT (block) = fndecl;\n   gcc_assert (!DECL_SAVED_TREE (fndecl));\n \n   /* Inlining would defeat the purpose of this wrapper."}, {"sha": "b40769a0f44c0a5125df369e764e518579747f01", "filename": "gcc/cgraph.h", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/893306188659dafdd4fe386235039b0ec4b8c4c8/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/893306188659dafdd4fe386235039b0ec4b8c4c8/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=893306188659dafdd4fe386235039b0ec4b8c4c8", "patch": "@@ -282,6 +282,9 @@ class GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n \n   void set_init_priority (priority_type priority);\n   priority_type get_init_priority ();\n+\n+  /* Return true if symbol is known to be nonzero.  */\n+  bool nonzero_address ();\n };\n \n /* Walk all aliases for NODE.  */\n@@ -1148,19 +1151,25 @@ tree varpool_get_constructor (struct varpool_node *node);\n /* In cgraph.c */\n extern void change_decl_assembler_name (tree, tree);\n \n+/* Return true if DECL should have entry in symbol table if used.\n+   Those are functions and static & external veriables*/\n+\n+static bool\n+decl_in_symtab_p (const_tree decl)\n+{\n+  return (TREE_CODE (decl) == FUNCTION_DECL\n+          || (TREE_CODE (decl) == VAR_DECL\n+\t      && (TREE_STATIC (decl) || DECL_EXTERNAL (decl))));\n+}\n+\n /* Return symbol table node associated with DECL, if any,\n    and NULL otherwise.  */\n \n static inline symtab_node *\n symtab_get_node (const_tree decl)\n {\n #ifdef ENABLE_CHECKING\n-  /* Check that we are called for sane type of object - functions\n-     and static or external variables.  */\n-  gcc_checking_assert (TREE_CODE (decl) == FUNCTION_DECL\n-\t\t       || (TREE_CODE (decl) == VAR_DECL\n-\t\t\t   && (TREE_STATIC (decl) || DECL_EXTERNAL (decl)\n-\t\t\t       || in_lto_p)));\n+  gcc_checking_assert (decl_in_symtab_p (decl));\n   /* Check that the mapping is sane - perhaps this check can go away,\n      but at the moment frontends tends to corrupt the mapping by calling\n      memcpy/memset on the tree nodes.  */"}, {"sha": "6a1c50204bbeca262e5eedb12e7e44ed61a0ed87", "filename": "gcc/fold-const.c", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/893306188659dafdd4fe386235039b0ec4b8c4c8/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/893306188659dafdd4fe386235039b0ec4b8c4c8/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=893306188659dafdd4fe386235039b0ec4b8c4c8", "patch": "@@ -69,6 +69,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-dfa.h\"\n #include \"hash-table.h\"  /* Required for ENABLE_FOLD_CHECKING.  */\n #include \"builtins.h\"\n+#include \"cgraph.h\"\n \n /* Nonzero if we are folding constants inside an initializer; zero\n    otherwise.  */\n@@ -16020,21 +16021,33 @@ tree_single_nonzero_warnv_p (tree t, bool *strict_overflow_p)\n     case ADDR_EXPR:\n       {\n \ttree base = TREE_OPERAND (t, 0);\n+\n \tif (!DECL_P (base))\n \t  base = get_base_address (base);\n \n \tif (!base)\n \t  return false;\n \n-\t/* Weak declarations may link to NULL.  Other things may also be NULL\n-\t   so protect with -fdelete-null-pointer-checks; but not variables\n-\t   allocated on the stack.  */\n+\t/* For objects in symbol table check if we know they are non-zero.\n+\t   Don't do anything for variables and functions before symtab is built;\n+\t   it is quite possible that they will be declared weak later.  */\n+\tif (DECL_P (base) && decl_in_symtab_p (base))\n+\t  {\n+\t    struct symtab_node *symbol;\n+\n+\t    symbol = symtab_get_node (base);\n+\t    if (symbol)\n+\t      return symbol->nonzero_address ();\n+\t    else\n+\t      return false;\n+\t  }\n+\n+\t/* Function local objects are never NULL.  */\n \tif (DECL_P (base)\n-\t    && (flag_delete_null_pointer_checks\n-\t\t|| (DECL_CONTEXT (base)\n-\t\t    && TREE_CODE (DECL_CONTEXT (base)) == FUNCTION_DECL\n-\t\t    && auto_var_in_fn_p (base, DECL_CONTEXT (base)))))\n-\t  return !VAR_OR_FUNCTION_DECL_P (base) || !DECL_WEAK (base);\n+\t    && (DECL_CONTEXT (base)\n+\t\t&& TREE_CODE (DECL_CONTEXT (base)) == FUNCTION_DECL\n+\t\t&& auto_var_in_fn_p (base, DECL_CONTEXT (base))))\n+\t  return true;\n \n \t/* Constants are never weak.  */\n \tif (CONSTANT_CLASS_P (base))"}, {"sha": "3a59935d132e20811b40b341ccca970cf59a604c", "filename": "gcc/symtab.c", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/893306188659dafdd4fe386235039b0ec4b8c4c8/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/893306188659dafdd4fe386235039b0ec4b8c4c8/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=893306188659dafdd4fe386235039b0ec4b8c4c8", "patch": "@@ -1890,4 +1890,67 @@ symtab_get_symbol_partitioning_class (symtab_node *node)\n \n   return SYMBOL_PARTITION;\n }\n+\n+/* Return true when symbol is known to be non-zero.  */\n+\n+bool\n+symtab_node::nonzero_address ()\n+{\n+  /* Weakrefs may be NULL when their target is not defined.  */\n+  if (this->alias && this->weakref)\n+    {\n+      if (this->analyzed)\n+\t{\n+\t  symtab_node *target = symtab_alias_ultimate_target (this);\n+\n+\t  if (target->alias && target->weakref)\n+\t    return false;\n+\t  /* We can not recurse to target::nonzero.  It is possible that the\n+\t     target is used only via the alias.\n+\t     We may walk references and look for strong use, but we do not know\n+\t     if this strong use will survive to final binary, so be\n+\t     conservative here.  \n+\t     ??? Maybe we could do the lookup during late optimization that\n+\t     could be useful to eliminate the NULL pointer checks in LTO\n+\t     programs.  */\n+\t  if (target->definition && !DECL_EXTERNAL (target->decl))\n+\t    return true;\n+\t  if (target->resolution != LDPR_UNKNOWN\n+\t      && target->resolution != LDPR_UNDEF\n+\t      && flag_delete_null_pointer_checks)\n+\t    return true;\n+\t  return false;\n+\t}\n+      else\n+        return false;\n+    }\n+\n+  /* With !flag_delete_null_pointer_checks we assume that symbols may\n+     bind to NULL. This is on by default on embedded targets only.\n+\n+     Otherwise all non-WEAK symbols must be defined and thus non-NULL or\n+     linking fails.  Important case of WEAK we want to do well are comdats.\n+     Those are handled by later check for definition.\n+\n+     When parsing, beware the cases when WEAK attribute is added later.  */\n+  if (!DECL_WEAK (this->decl)\n+      && flag_delete_null_pointer_checks\n+      && cgraph_state > CGRAPH_STATE_PARSING)\n+    return true;\n+\n+  /* If target is defined and not extern, we know it will be output and thus\n+     it will bind to non-NULL.\n+     Play safe for flag_delete_null_pointer_checks where weak definition maye\n+     be re-defined by NULL.  */\n+  if (this->definition && !DECL_EXTERNAL (this->decl)\n+      && (flag_delete_null_pointer_checks || !DECL_WEAK (this->decl)))\n+    return true;\n+\n+  /* As the last resort, check the resolution info.  */\n+  if (this->resolution != LDPR_UNKNOWN\n+      && this->resolution != LDPR_UNDEF\n+      && flag_delete_null_pointer_checks)\n+    return true;\n+  return false;\n+}\n #include \"gt-symtab.h\""}, {"sha": "be579b6de971da9d71a630a7b964da69e3048801", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/893306188659dafdd4fe386235039b0ec4b8c4c8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/893306188659dafdd4fe386235039b0ec4b8c4c8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=893306188659dafdd4fe386235039b0ec4b8c4c8", "patch": "@@ -1,3 +1,12 @@\n+2014-07-13  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* gcc.dg/pr36901.h: Simplify because non-zero symbol folding no\n+\tlonger happens during parsing.\n+\t* gcc.dg/pr44024.c: Update template.\n+\t* g++.dg/tree-ssa/nonzero-2.C: New testcase.\n+\t* g++.dg/tree-ssa/nonzero-1.C: New testcase.\n+\t* gcc.dg/tree-ssa/nonzero-1.c: New testcase.\n+\n 2014-07-13  Tom de Vries  <tom@codesourcery.com>\n \n \t* gcc.target/i386/fuse-caller-save-xmm-run.c: New test."}, {"sha": "60da49dca3737ea35888a92dfa4eb9b0550d2393", "filename": "gcc/testsuite/g++.dg/tree-ssa/nonzero-1.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/893306188659dafdd4fe386235039b0ec4b8c4c8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fnonzero-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/893306188659dafdd4fe386235039b0ec4b8c4c8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fnonzero-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fnonzero-1.C?ref=893306188659dafdd4fe386235039b0ec4b8c4c8", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-ccp1\" } */\n+inline void t()\n+{\n+}\n+int m()\n+{\n+  void *q = (void *)&t;\n+  return q != 0;\n+}\n+/* { dg-final { scan-tree-dump \"return 1\" \"ccp1\"} } */\n+/* { dg-final { cleanup-tree-dump \"ccp1\" } } */"}, {"sha": "fdf4114188177f57a7552688173dd100b9fc09a2", "filename": "gcc/testsuite/g++.dg/tree-ssa/nonzero-2.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/893306188659dafdd4fe386235039b0ec4b8c4c8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fnonzero-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/893306188659dafdd4fe386235039b0ec4b8c4c8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fnonzero-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fnonzero-2.C?ref=893306188659dafdd4fe386235039b0ec4b8c4c8", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-ccp1 -fdelete-null-pointer-checks\" } */\n+struct t\n+{\n+  static inline void tt()\n+  {\n+  }\n+  virtual void q();\n+};\n+int m()\n+{\n+  void *q = (void *)&t::tt;\n+  return q != 0;\n+}\n+/* { dg-final { scan-tree-dump \"return 1\" \"ccp1\"} } */\n+/* { dg-final { cleanup-tree-dump \"ccp1\" } } */"}, {"sha": "cf61c993935d9cd73e327482d184b248cdfd020e", "filename": "gcc/testsuite/gcc.dg/pr36901.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/893306188659dafdd4fe386235039b0ec4b8c4c8/gcc%2Ftestsuite%2Fgcc.dg%2Fpr36901.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/893306188659dafdd4fe386235039b0ec4b8c4c8/gcc%2Ftestsuite%2Fgcc.dg%2Fpr36901.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr36901.h?ref=893306188659dafdd4fe386235039b0ec4b8c4c8", "patch": "@@ -1,6 +1,2 @@\n-#if defined(AVR) /* flag_delete_null_pointer_checks = 0  */\n int sc = (&sc >= 0);\n-#else\n-int sc = (&sc > 0);\n-#endif\n "}, {"sha": "740d04d48e02217803d511aef94c39b9b294979a", "filename": "gcc/testsuite/gcc.dg/pr44024.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/893306188659dafdd4fe386235039b0ec4b8c4c8/gcc%2Ftestsuite%2Fgcc.dg%2Fpr44024.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/893306188659dafdd4fe386235039b0ec4b8c4c8/gcc%2Ftestsuite%2Fgcc.dg%2Fpr44024.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr44024.c?ref=893306188659dafdd4fe386235039b0ec4b8c4c8", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do link } */\n-/* { dg-options \"-fdelete-null-pointer-checks -fdump-tree-original\" } */\n+/* { dg-options \"-fdelete-null-pointer-checks -fdump-tree-ccp1\" } */\n \n void foo();\n \n@@ -10,5 +10,5 @@ int main()\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-not \"foo\" \"original\" { target { ! avr*-*-* } } } } */\n-/* { dg-final { cleanup-tree-dump \"original\" } } */\n+/* { dg-final { scan-tree-dump-not \"foo\" \"ccp1\" { target { ! avr*-*-* } } } } */\n+/* { dg-final { cleanup-tree-dump \"ccp1\" } } */"}, {"sha": "c79811bccb894b19771529eac99da89e94415368", "filename": "gcc/testsuite/gcc.dg/tree-ssa/nonzero-1.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/893306188659dafdd4fe386235039b0ec4b8c4c8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fnonzero-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/893306188659dafdd4fe386235039b0ec4b8c4c8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fnonzero-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fnonzero-1.c?ref=893306188659dafdd4fe386235039b0ec4b8c4c8", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+extern int a;\n+t()\n+{\n+  return &a!=0;\n+}\n+extern int a __attribute__ ((weak));\n+\n+/* { dg-final { scan-tree-dump-not \"return 1\" \"optimized\"} } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}]}