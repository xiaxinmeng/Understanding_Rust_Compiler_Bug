{"sha": "7d7af38a4beb098888bab5d365c57c957033c900", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2Q3YWYzOGE0YmViMDk4ODg4YmFiNWQzNjVjNTdjOTU3MDMzYzkwMA==", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2007-12-13T10:48:09Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-12-13T10:48:09Z"}, "message": "sem_ch3.ads, [...] (Check_Abstract_Overriding): Avoid generation of spurious error if parent is an interface type...\n\n2007-12-06  Javier Miranda  <miranda@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch3.ads, sem_ch3.adb (Check_Abstract_Overriding): Avoid\n\tgeneration of spurious error if parent is an interface type; caused\n\tbecause predefined primitive bodies will be generated later by\n\tFreeze_Record_Type.\n\t(Process_Subtype): The subtype inherits the Known_To_Have_Preelab_Init\n\tflag.\n\t(Derive_Subprograms): Handle derivations of predefined primitives\n\tafter all the user-defined primitives to ensure that they are\n\tfound in proper order in instantiations.\n\t(Add_Interface_Tag_Components, Inherit_Components): Update occurrences\n\tof Related_Interface to Related_Type.\n\t(Record_Type_Declaration): Minor reordering of calls to decorate the\n\tTag component because the entity must have set its Ekind attribute\n\tbefore setting its Is_Tag attribute.\n\t(Analyze_Subtype_Declaration): In the case of subtypes with\n\tPrivate_Kind, inherit Known_To_Have_Preelab_Init from the parent.\n\nFrom-SVN: r130883", "tree": {"sha": "63a8d81a2d72713eadec60590e4714fa1864c3a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/63a8d81a2d72713eadec60590e4714fa1864c3a2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7d7af38a4beb098888bab5d365c57c957033c900", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d7af38a4beb098888bab5d365c57c957033c900", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d7af38a4beb098888bab5d365c57c957033c900", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d7af38a4beb098888bab5d365c57c957033c900/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2242f4ddc32a339aee5f44a36735dad9ae34e99a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2242f4ddc32a339aee5f44a36735dad9ae34e99a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2242f4ddc32a339aee5f44a36735dad9ae34e99a"}], "stats": {"total": 439, "additions": 245, "deletions": 194}, "files": [{"sha": "3be25a19fe000de161724c0816dd894b2955c26c", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 241, "deletions": 188, "changes": 429, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7af38a4beb098888bab5d365c57c957033c900/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7af38a4beb098888bab5d365c57c957033c900/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=7d7af38a4beb098888bab5d365c57c957033c900", "patch": "@@ -729,8 +729,8 @@ package body Sem_Ch3 is\n       --  function, scope is the current one, because it is the one of the\n       --  current type declaration.\n \n-      if Nkind (Related_Nod) = N_Object_Declaration\n-        or else Nkind (Related_Nod) = N_Access_Function_Definition\n+      if Nkind_In (Related_Nod, N_Object_Declaration,\n+                                N_Access_Function_Definition)\n       then\n          Anon_Scope := Current_Scope;\n \n@@ -743,7 +743,7 @@ package body Sem_Ch3 is\n       --  unit, we must traverse the the tree to retrieve the proper entity.\n \n       elsif Nkind (Related_Nod) = N_Function_Specification\n-         and then Nkind (Parent (N)) /= N_Parameter_Specification\n+        and then Nkind (Parent (N)) /= N_Parameter_Specification\n       then\n          --  If the current scope is a protected type, the anonymous access\n          --  is associated with one of the protected operations, and must\n@@ -789,6 +789,9 @@ package body Sem_Ch3 is\n               (Anon_Type, E_Anonymous_Access_Subprogram_Type);\n          end if;\n \n+         Set_Can_Use_Internal_Rep\n+           (Anon_Type, not Always_Compatible_Rep_On_Target);\n+\n          --  If the anonymous access is associated with a protected operation\n          --  create a reference to it after the enclosing protected definition\n          --  because the itype will be used in the subsequent bodies.\n@@ -932,39 +935,39 @@ package body Sem_Ch3 is\n       --                                   (Z : access T)))\n \n       D_Ityp := Associated_Node_For_Itype (Desig_Type);\n-      while Nkind (D_Ityp) /= N_Full_Type_Declaration\n-         and then Nkind (D_Ityp) /= N_Private_Type_Declaration\n-         and then Nkind (D_Ityp) /= N_Private_Extension_Declaration\n-         and then Nkind (D_Ityp) /= N_Procedure_Specification\n-         and then Nkind (D_Ityp) /= N_Function_Specification\n-         and then Nkind (D_Ityp) /= N_Object_Declaration\n-         and then Nkind (D_Ityp) /= N_Object_Renaming_Declaration\n-         and then Nkind (D_Ityp) /= N_Formal_Type_Declaration\n-         and then Nkind (D_Ityp) /= N_Task_Type_Declaration\n-         and then Nkind (D_Ityp) /= N_Protected_Type_Declaration\n+      while not (Nkind_In (D_Ityp, N_Full_Type_Declaration,\n+                                   N_Private_Type_Declaration,\n+                                   N_Private_Extension_Declaration,\n+                                   N_Procedure_Specification,\n+                                   N_Function_Specification)\n+                   or else\n+                 Nkind_In (D_Ityp, N_Object_Declaration,\n+                                   N_Object_Renaming_Declaration,\n+                                   N_Formal_Type_Declaration,\n+                                   N_Task_Type_Declaration,\n+                                   N_Protected_Type_Declaration))\n       loop\n          D_Ityp := Parent (D_Ityp);\n          pragma Assert (D_Ityp /= Empty);\n       end loop;\n \n       Set_Associated_Node_For_Itype (Desig_Type, D_Ityp);\n \n-      if Nkind (D_Ityp) = N_Procedure_Specification\n-        or else Nkind (D_Ityp) = N_Function_Specification\n+      if Nkind_In (D_Ityp, N_Procedure_Specification,\n+                           N_Function_Specification)\n       then\n          Set_Scope (Desig_Type, Scope (Defining_Entity (D_Ityp)));\n \n-      elsif Nkind (D_Ityp) = N_Full_Type_Declaration\n-        or else Nkind (D_Ityp) = N_Object_Declaration\n-        or else Nkind (D_Ityp) = N_Object_Renaming_Declaration\n-        or else Nkind (D_Ityp) = N_Formal_Type_Declaration\n+      elsif Nkind_In (D_Ityp, N_Full_Type_Declaration,\n+                              N_Object_Declaration,\n+                              N_Object_Renaming_Declaration,\n+                              N_Formal_Type_Declaration)\n       then\n          Set_Scope (Desig_Type, Scope (Defining_Identifier (D_Ityp)));\n       end if;\n \n       if Nkind (T_Def) = N_Access_Function_Definition then\n          if Nkind (Result_Definition (T_Def)) = N_Access_Definition then\n-\n             declare\n                Acc : constant Node_Id := Result_Definition (T_Def);\n \n@@ -1057,6 +1060,8 @@ package body Sem_Ch3 is\n          Set_Ekind (T_Name, E_Access_Subprogram_Type);\n       end if;\n \n+      Set_Can_Use_Internal_Rep (T_Name, not Always_Compatible_Rep_On_Target);\n+\n       Set_Etype                    (T_Name, T_Name);\n       Init_Size_Align              (T_Name);\n       Set_Directly_Designated_Type (T_Name, Desig_Type);\n@@ -1229,7 +1234,7 @@ package body Sem_Ch3 is\n          Set_Ekind               (Tag, E_Component);\n          Set_Is_Tag              (Tag);\n          Set_Is_Aliased          (Tag);\n-         Set_Related_Interface   (Tag, Iface);\n+         Set_Related_Type        (Tag, Iface);\n          Init_Component_Location (Tag);\n \n          pragma Assert (Is_Frozen (Iface));\n@@ -1271,7 +1276,7 @@ package body Sem_Ch3 is\n             Set_Analyzed (Decl);\n             Set_Ekind               (Offset, E_Component);\n             Set_Is_Aliased          (Offset);\n-            Set_Related_Interface   (Offset, Iface);\n+            Set_Related_Type        (Offset, Iface);\n             Init_Component_Location (Offset);\n             Insert_After (Last_Tag, Decl);\n             Last_Tag := Decl;\n@@ -1620,7 +1625,6 @@ package body Sem_Ch3 is\n          declare\n             Sindic : constant Node_Id :=\n                        Subtype_Indication (Component_Definition (N));\n-\n          begin\n             if Nkind (Sindic) = N_Subtype_Indication\n               and then Present (Constraint (Sindic))\n@@ -1764,9 +1768,9 @@ package body Sem_Ch3 is\n          --  (This is needed in any case for early instantiations ???).\n \n          if No (Next_Node) then\n-            if Nkind (Parent (L)) = N_Component_List\n-              or else Nkind (Parent (L)) = N_Task_Definition\n-              or else Nkind (Parent (L)) = N_Protected_Definition\n+            if Nkind_In (Parent (L), N_Component_List,\n+                                     N_Task_Definition,\n+                                     N_Protected_Definition)\n             then\n                null;\n \n@@ -1810,12 +1814,13 @@ package body Sem_Ch3 is\n          --  not cause unwanted freezing at that point.\n \n          elsif not Analyzed (Next_Node)\n-           and then (Nkind (Next_Node) = N_Subprogram_Body\n-             or else Nkind (Next_Node) = N_Entry_Body\n-             or else Nkind (Next_Node) = N_Package_Body\n-             or else Nkind (Next_Node) = N_Protected_Body\n-             or else Nkind (Next_Node) = N_Task_Body\n-             or else Nkind (Next_Node) in N_Body_Stub)\n+           and then (Nkind_In (Next_Node, N_Subprogram_Body,\n+                                          N_Entry_Body,\n+                                          N_Package_Body,\n+                                          N_Protected_Body,\n+                                          N_Task_Body)\n+                       or else\n+                     Nkind (Next_Node) in N_Body_Stub)\n          then\n             Adjust_D;\n             Freeze_All (Freeze_From, D);\n@@ -2070,9 +2075,7 @@ package body Sem_Ch3 is\n          return;\n       end if;\n \n-      if Nkind (E) = N_Integer_Literal\n-        or else Nkind (E) = N_Real_Literal\n-      then\n+      if Nkind_In (E, N_Integer_Literal, N_Real_Literal) then\n          Set_Etype (E, Etype (Id));\n       end if;\n \n@@ -2364,20 +2367,6 @@ package body Sem_Ch3 is\n \n          Set_Is_True_Constant (Id, True);\n \n-         --  If the initialization expression is an access to constant,\n-         --  it cannot be used with an access type.\n-\n-         if Is_Access_Type (Etype (E))\n-           and then Is_Access_Constant (Etype (E))\n-           and then Is_Access_Type (T)\n-           and then not Is_Access_Constant (T)\n-         then\n-            Error_Msg_NE (\"object of type& cannot be initialized with \" &\n-                          \"an access-to-constant expression\",\n-                          E,\n-                          T);\n-         end if;\n-\n          --  If we are analyzing a constant declaration, set its completion\n          --  flag after analyzing the expression.\n \n@@ -3277,6 +3266,8 @@ package body Sem_Ch3 is\n                Set_Is_Limited_Record  (Id, Is_Limited_Record     (T));\n                Set_Has_Unknown_Discriminants\n                                       (Id, Has_Unknown_Discriminants (T));\n+               Set_Known_To_Have_Preelab_Init\n+                                      (Id, Known_To_Have_Preelab_Init (T));\n \n                if Is_Tagged_Type (T) then\n                   Set_Is_Tagged_Type       (Id);\n@@ -4307,9 +4298,7 @@ package body Sem_Ch3 is\n       --  Temporarily remove the current scope from the stack to add the new\n       --  declarations to the enclosing scope\n \n-      if Nkind (N) = N_Object_Declaration\n-        or else Nkind (N) = N_Access_Function_Definition\n-      then\n+      if Nkind_In (N, N_Object_Declaration, N_Access_Function_Definition) then\n          Analyze (Decl);\n \n       else\n@@ -4320,6 +4309,7 @@ package body Sem_Ch3 is\n       end if;\n \n       Set_Ekind (Anon, E_Anonymous_Access_Protected_Subprogram_Type);\n+      Set_Can_Use_Internal_Rep (Anon, not Always_Compatible_Rep_On_Target);\n       return Anon;\n    end Replace_Anonymous_Access_To_Protected_Subprogram;\n \n@@ -4635,7 +4625,7 @@ package body Sem_Ch3 is\n \n                if Nkind (D_Constraint) = N_Identifier\n                  and then Chars (D_Constraint) /=\n-                   Chars (Defining_Identifier (Disc_Spec))\n+                          Chars (Defining_Identifier (Disc_Spec))\n                then\n                   Error_Msg_N (\"new discriminants must constrain old ones\",\n                     D_Constraint);\n@@ -4967,8 +4957,11 @@ package body Sem_Ch3 is\n       Set_First_Rep_Item (Implicit_Base, First_Rep_Item (Parent_Base));\n       Set_Parent         (Implicit_Base, Parent (Derived_Type));\n \n-      if Is_Discrete_Type (Parent_Base) or else\n-        Is_Decimal_Fixed_Point_Type (Parent_Base)\n+      --  Set RM Size for discrete type or decimal fixed-point type\n+      --  Ordinary fixed-point is excluded, why???\n+\n+      if Is_Discrete_Type (Parent_Base)\n+        or else Is_Decimal_Fixed_Point_Type (Parent_Base)\n       then\n          Set_RM_Size (Implicit_Base, RM_Size (Parent_Base));\n       end if;\n@@ -5314,8 +5307,8 @@ package body Sem_Ch3 is\n         and then  Has_Discriminants (Full_View (Parent_Type))\n       then\n          if Has_Unknown_Discriminants (Parent_Type)\n-           and then Nkind (Subtype_Indication (Type_Definition (N)))\n-             = N_Subtype_Indication\n+           and then Nkind (Subtype_Indication (Type_Definition (N))) =\n+                                                         N_Subtype_Indication\n          then\n             Error_Msg_N\n               (\"cannot constrain type with unknown discriminants\",\n@@ -5973,7 +5966,7 @@ package body Sem_Ch3 is\n       Discriminant_Specs : constant Boolean :=\n                              Present (Discriminant_Specifications (N));\n       Private_Extension  : constant Boolean :=\n-                             (Nkind (N) = N_Private_Extension_Declaration);\n+                             Nkind (N) = N_Private_Extension_Declaration;\n \n       Constraint_Present : Boolean;\n       Inherit_Discrims   : Boolean := False;\n@@ -7393,14 +7386,24 @@ package body Sem_Ch3 is\n             Set_Ekind (Def_Id, E_Record_Subtype);\n          end if;\n \n+         --  Inherit preelaboration flag from base, for types for which it\n+         --  may have been set: records, private types, protected types.\n+\n+         Set_Known_To_Have_Preelab_Init\n+           (Def_Id, Known_To_Have_Preelab_Init (T));\n+\n       elsif Ekind (T) = E_Task_Type then\n          Set_Ekind (Def_Id, E_Task_Subtype);\n \n       elsif Ekind (T) = E_Protected_Type then\n          Set_Ekind (Def_Id, E_Protected_Subtype);\n+         Set_Known_To_Have_Preelab_Init\n+           (Def_Id, Known_To_Have_Preelab_Init (T));\n \n       elsif Is_Private_Type (T) then\n          Set_Ekind (Def_Id, Subtype_Kind (Ekind (T)));\n+         Set_Known_To_Have_Preelab_Init\n+           (Def_Id, Known_To_Have_Preelab_Init (T));\n \n       elsif Is_Class_Wide_Type (T) then\n          Set_Ekind (Def_Id, E_Class_Wide_Subtype);\n@@ -7529,9 +7532,7 @@ package body Sem_Ch3 is\n \n       Analyze_And_Resolve (Bound, Base_Type (Par_T));\n \n-      if Nkind (Bound) = N_Integer_Literal\n-        or else Nkind (Bound) = N_Real_Literal\n-      then\n+      if Nkind_In (Bound, N_Integer_Literal, N_Real_Literal) then\n          New_Bound := New_Copy (Bound);\n          Set_Etype (New_Bound, Der_T);\n          Set_Analyzed (New_Bound);\n@@ -7826,31 +7827,30 @@ package body Sem_Ch3 is\n          --  overriding in Ada2005, but wrappers need to be built for them\n          --  (see exp_ch3, Build_Controlling_Function_Wrappers).\n \n-         --  Use elseif here and avoid above goto???\n-\n          if Is_Null_Extension (T)\n            and then Has_Controlling_Result (Subp)\n            and then Ada_Version >= Ada_05\n            and then Present (Alias (Subp))\n            and then not Comes_From_Source (Subp)\n            and then not Is_Abstract_Subprogram (Alias (Subp))\n          then\n-            goto Next_Subp;\n-         end if;\n+            null;\n \n-         if (Is_Abstract_Subprogram (Subp)\n+         elsif (Is_Abstract_Subprogram (Subp)\n               or else Requires_Overriding (Subp)\n-              or else (Has_Controlling_Result (Subp)\n-                        and then Present (Alias_Subp)\n-                        and then not Comes_From_Source (Subp)\n-                        and then Sloc (Subp) = Sloc (First_Subtype (T))))\n+              or else\n+                (Has_Controlling_Result (Subp)\n+                   and then Present (Alias_Subp)\n+                   and then not Comes_From_Source (Subp)\n+                   and then Sloc (Subp) = Sloc (First_Subtype (T))))\n            and then not Is_TSS (Subp, TSS_Stream_Input)\n            and then not Is_TSS (Subp, TSS_Stream_Output)\n            and then not Is_Abstract_Type (T)\n            and then Convention (T) /= Convention_CIL\n            and then Chars (Subp) /= Name_uDisp_Asynchronous_Select\n            and then Chars (Subp) /= Name_uDisp_Conditional_Select\n            and then Chars (Subp) /= Name_uDisp_Get_Prim_Op_Kind\n+           and then Chars (Subp) /= Name_uDisp_Requeue\n            and then Chars (Subp) /= Name_uDisp_Timed_Select\n \n             --  Ada 2005 (AI-251): Do not consider hidden entities associated\n@@ -7877,6 +7877,7 @@ package body Sem_Ch3 is\n                --  Exp_Ch3.Make_Controlling_Wrapper_Functions).\n \n                Type_Def := Type_Definition (Parent (T));\n+\n                if Nkind (Type_Def) = N_Derived_Type_Definition\n                  and then Present (Record_Extension_Part (Type_Def))\n                  and then\n@@ -7888,32 +7889,46 @@ package body Sem_Ch3 is\n                       or else Requires_Overriding (Subp)\n                       or else Is_Access_Type (Etype (Subp)))\n                then\n-                  Error_Msg_NE\n-                    (\"type must be declared abstract or & overridden\",\n-                     T, Subp);\n+                  --  The body of predefined primitives of tagged types derived\n+                  --  from interface types are generated later by Freeze_Type.\n \n-                  --  Traverse the whole chain of aliased subprograms to\n-                  --  complete the error notification. This is especially\n-                  --  useful for traceability of the chain of entities when the\n-                  --  subprogram corresponds with an interface subprogram\n-                  --  (which might be defined in another package)\n+                  if Is_Predefined_Dispatching_Operation (Subp)\n+                    and then Is_Abstract_Subprogram (Alias_Subp)\n+                    and then Is_Interface\n+                               (Root_Type (Find_Dispatching_Type (Subp)))\n+                  then\n+                     null;\n \n-                  if Present (Alias_Subp) then\n-                     declare\n-                        E : Entity_Id;\n+                  else\n+                     Error_Msg_NE\n+                       (\"type must be declared abstract or & overridden\",\n+                        T, Subp);\n \n-                     begin\n-                        E := Subp;\n-                        while Present (Alias (E)) loop\n-                           Error_Msg_Sloc := Sloc (E);\n-                           Error_Msg_NE (\"\\& has been inherited #\", T, Subp);\n-                           E := Alias (E);\n-                        end loop;\n+                     --  Traverse the whole chain of aliased subprograms to\n+                     --  complete the error notification. This is especially\n+                     --  useful for traceability of the chain of entities when\n+                     --  the subprogram corresponds with an interface\n+                     --  subprogram (which may be defined in another package).\n+\n+                     if Present (Alias_Subp) then\n+                        declare\n+                           E : Entity_Id;\n+\n+                        begin\n+                           E := Subp;\n+                           while Present (Alias (E)) loop\n+                              Error_Msg_Sloc := Sloc (E);\n+                              Error_Msg_NE\n+                                (\"\\& has been inherited #\", T, Subp);\n+                              E := Alias (E);\n+                           end loop;\n \n-                        Error_Msg_Sloc := Sloc (E);\n-                        Error_Msg_NE\n-                          (\"\\& has been inherited from subprogram #\", T, Subp);\n-                     end;\n+                           Error_Msg_Sloc := Sloc (E);\n+                           Error_Msg_NE\n+                             (\"\\& has been inherited from subprogram #\",\n+                              T, Subp);\n+                        end;\n+                     end if;\n                   end if;\n \n                --  Ada 2005 (AI-345): Protected or task type implementing\n@@ -7960,8 +7975,36 @@ package body Sem_Ch3 is\n             end if;\n          end if;\n \n-         <<Next_Subp>>\n-            Next_Elmt (Elmt);\n+         --  Ada 2005 (AI05-0030): Inspect hidden subprograms which provide\n+         --  the mapping between interface and implementing type primitives.\n+         --  If the interface alias is marked as Implemented_By_Entry, the\n+         --  alias must be an entry wrapper.\n+\n+         if Ada_Version >= Ada_05\n+           and then Is_Hidden (Subp)\n+           and then Present (Abstract_Interface_Alias (Subp))\n+           and then Implemented_By_Entry (Abstract_Interface_Alias (Subp))\n+           and then Present (Alias_Subp)\n+           and then\n+             (not Is_Primitive_Wrapper (Alias_Subp)\n+                or else Ekind (Wrapped_Entity (Alias_Subp)) /= E_Entry)\n+         then\n+            declare\n+               Error_Ent : Entity_Id := T;\n+\n+            begin\n+               if Is_Concurrent_Record_Type (Error_Ent) then\n+                  Error_Ent := Corresponding_Concurrent_Type (Error_Ent);\n+               end if;\n+\n+               Error_Msg_Node_2 := Abstract_Interface_Alias (Subp);\n+               Error_Msg_NE\n+                 (\"type & must implement abstract subprogram & with an entry\",\n+                  Error_Ent, Error_Ent);\n+            end;\n+         end if;\n+\n+         Next_Elmt (Elmt);\n       end loop;\n    end Check_Abstract_Overriding;\n \n@@ -8125,8 +8168,8 @@ package body Sem_Ch3 is\n                elsif Is_Overloadable (E)\n                  and then Current_Entity_In_Scope (E) /= E\n                then\n-                  --  It may be that the completion is mistyped and appears\n-                  --  as a  distinct overloading of the entity.\n+                  --  It may be that the completion is mistyped and appears as\n+                  --  a distinct overloading of the entity.\n \n                   declare\n                      Candidate : constant Entity_Id :=\n@@ -8163,18 +8206,17 @@ package body Sem_Ch3 is\n          if Is_Intrinsic_Subprogram (E) then\n             null;\n \n-         --  The following situation requires special handling: a child\n-         --  unit that appears in the context clause of the body of its\n-         --  parent:\n+         --  The following situation requires special handling: a child unit\n+         --  that appears in the context clause of the body of its parent:\n \n          --    procedure Parent.Child (...);\n \n          --    with Parent.Child;\n          --    package body Parent is\n \n-         --  Here Parent.Child appears as a local entity, but should not\n-         --  be flagged as requiring completion, because it is a\n-         --  compilation unit.\n+         --  Here Parent.Child appears as a local entity, but should not be\n+         --  flagged as requiring completion, because it is a compilation\n+         --  unit.\n \n          --  Ignore missing completion for a subprogram that does not come from\n          --  source (including the _Call primitive operation of RAS types,\n@@ -8359,7 +8401,7 @@ package body Sem_Ch3 is\n \n                else\n                   Error_Msg_N\n-                    (\"initialization of limited object requires agggregate \"\n+                    (\"initialization of limited object requires aggregate \"\n                       & \"or function call\",  Exp);\n                end if;\n             end if;\n@@ -11086,10 +11128,10 @@ package body Sem_Ch3 is\n          Next_Elmt (Elmt);\n       end loop;\n \n-      --  Complete the derivation of the interface subprograms. Assignate to\n-      --  each entity associated with abstract interfaces their aliased entity\n-      --  and complete their decoration as hidden interface entities that will\n-      --  be used later to build the secondary dispatch tables.\n+      --  Complete the derivation of the interface subprograms. Assign to each\n+      --  entity associated with abstract interfaces their aliased entity and\n+      --  complete their decoration as hidden interface entities that will be\n+      --  used later to build the secondary dispatch tables.\n \n       if not Is_Empty_Elmt_List (Ifaces_List) then\n          if Ekind (Parent_Type) = E_Record_Type_With_Private\n@@ -11605,13 +11647,14 @@ package body Sem_Ch3 is\n    ------------------------\n \n    procedure Derive_Subprograms\n-     (Parent_Type           : Entity_Id;\n-      Derived_Type          : Entity_Id;\n-      Generic_Actual        : Entity_Id := Empty)\n+     (Parent_Type    : Entity_Id;\n+      Derived_Type   : Entity_Id;\n+      Generic_Actual : Entity_Id := Empty)\n    is\n       Op_List      : constant Elist_Id :=\n                        Collect_Primitive_Operations (Parent_Type);\n       Ifaces_List  : constant Elist_Id := New_Elmt_List;\n+      Predef_Prims : constant Elist_Id := New_Elmt_List;\n       Act_List     : Elist_Id;\n       Act_Elmt     : Elmt_Id;\n       Elmt         : Elmt_Id;\n@@ -11629,7 +11672,9 @@ package body Sem_Ch3 is\n          Parent_Base := Parent_Type;\n       end if;\n \n-      --  Derive primitives inherited from the parent\n+      --  Derive primitives inherited from the parent. Note that if the generic\n+      --  actual is present, this is not really a type derivation, it is a\n+      --  completion within an instance.\n \n       if Present (Generic_Actual) then\n          Act_List := Collect_Primitive_Operations (Generic_Actual);\n@@ -11652,18 +11697,27 @@ package body Sem_Ch3 is\n             then\n                null;\n \n+            --  We derive predefined primitives in a later round to ensure that\n+            --  they are always added to the list of primitives after user\n+            --  defined primitives (because predefined primitives have to be\n+            --  skipped when matching the operations of a parent interface to\n+            --  those of a concrete type). However it is unclear why those\n+            --  primitives would be needed in an instantiation???\n+\n+            elsif Is_Predefined_Dispatching_Operation (Subp) then\n+               Append_Elmt (Subp, Predef_Prims);\n+\n             elsif No (Generic_Actual) then\n                Derive_Subprogram (New_Subp, Subp, Derived_Type, Parent_Base);\n \n-               --  Ada 2005 (AI-251): Add the derivation of an abstract\n-               --  interface primitive to the list of entities to which\n-               --  we have to associate an aliased entity.\n+               --  Ada 2005 (AI-251): Add derivation of an abstract interface\n+               --  primitive to the list of entities to which we have to\n+               --  associate an aliased entity.\n \n                if Ada_Version >= Ada_05\n                  and then Is_Dispatching_Operation (Subp)\n                  and then Present (Find_Dispatching_Type (Subp))\n                  and then Is_Interface (Find_Dispatching_Type (Subp))\n-                 and then not Is_Predefined_Dispatching_Operation (Subp)\n                then\n                   Append_Elmt (New_Subp, Ifaces_List);\n                end if;\n@@ -11714,20 +11768,30 @@ package body Sem_Ch3 is\n          Next_Elmt (Elmt);\n       end loop;\n \n-      --  Inherit additional operations from progenitor interfaces.\n-      --  However, if the derived type is a generic actual, there\n-      --  are not new primitive operations for the type, because\n-      --  it has those of the actual, so nothing needs to be done.\n-      --  The renamings generated above are not primitive operations,\n-      --  and their purpose is simply to make the proper operations\n-      --  visible within an instantiation.\n+      --  Inherit additional operations from progenitor interfaces. However,\n+      --  if the derived type is a generic actual, there are not new primitive\n+      --  operations for the type, because it has those of the actual, so\n+      --  nothing needs to be done. The renamings generated above are not\n+      --  primitive operations, and their purpose is simply to make the proper\n+      --  operations visible within an instantiation.\n \n       if Ada_Version >= Ada_05\n         and then Is_Tagged_Type (Derived_Type)\n         and then No (Generic_Actual)\n       then\n          Derive_Interface_Subprograms (Parent_Type, Derived_Type, Ifaces_List);\n       end if;\n+\n+      --  Derive predefined primitives\n+\n+      if not Is_Empty_Elmt_List (Predef_Prims) then\n+         Elmt := First_Elmt (Predef_Prims);\n+         while Present (Elmt) loop\n+            Derive_Subprogram\n+              (New_Subp, Node (Elmt), Derived_Type, Parent_Base);\n+            Next_Elmt (Elmt);\n+         end loop;\n+      end if;\n    end Derive_Subprograms;\n \n    --------------------------------\n@@ -11795,12 +11859,12 @@ package body Sem_Ch3 is\n \n       Convert_Scalar_Bounds (N, Parent_Type, Derived_Type, Loc);\n \n-      --  Because the implicit base is used in the conversion of the bounds,\n-      --  we have to freeze it now. This is similar to what is done for\n-      --  numeric types, and it equally suspicious, but otherwise a non-\n-      --  static bound will have a reference to an unfrozen type, which is\n-      --  rejected by Gigi (???). This requires specific care for definition\n-      --  of stream attributes. For details, see comments at the end of\n+      --  Because the implicit base is used in the conversion of the bounds, we\n+      --  have to freeze it now. This is similar to what is done for numeric\n+      --  types, and it equally suspicious, but otherwise a non-static bound\n+      --  will have a reference to an unfrozen type, which is rejected by Gigi\n+      --  (???). This requires specific care for definition of stream\n+      --  attributes. For details, see comments at the end of\n       --  Build_Derived_Numeric_Type.\n \n       Freeze_Before (N, Implicit_Base);\n@@ -12495,9 +12559,9 @@ package body Sem_Ch3 is\n             Enter_Name (Id);\n             New_Id := Id;\n \n-         elsif Nkind (N) /= N_Full_Type_Declaration\n-           and then Nkind (N) /= N_Task_Type_Declaration\n-           and then Nkind (N) /= N_Protected_Type_Declaration\n+         elsif not Nkind_In (N, N_Full_Type_Declaration,\n+                                N_Task_Type_Declaration,\n+                                N_Protected_Type_Declaration)\n          then\n             --  Completion must be a full type declarations (RM 7.3(4))\n \n@@ -12542,17 +12606,15 @@ package body Sem_Ch3 is\n                   New_Id := Id;\n \n                elsif Ekind (Prev) = E_Private_Type\n-                 and then\n-                   (Nkind (N) = N_Task_Type_Declaration\n-                     or else Nkind (N) = N_Protected_Type_Declaration)\n+                 and then Nkind_In (N, N_Task_Type_Declaration,\n+                                       N_Protected_Type_Declaration)\n                then\n                   Error_Msg_N\n                    (\"completion of nonlimited type cannot be limited\", N);\n \n                elsif Ekind (Prev) = E_Record_Type_With_Private\n-                 and then\n-                   (Nkind (N) = N_Task_Type_Declaration\n-                     or else Nkind (N) = N_Protected_Type_Declaration)\n+                 and then Nkind_In (N, N_Task_Type_Declaration,\n+                                       N_Protected_Type_Declaration)\n                then\n                   if not Is_Limited_Record (Prev) then\n                      Error_Msg_N\n@@ -12569,8 +12631,8 @@ package body Sem_Ch3 is\n             --  type or a protected type. This case arises when covering\n             --  interface types.\n \n-            elsif Nkind (N) = N_Task_Type_Declaration\n-              or else Nkind (N) = N_Protected_Type_Declaration\n+            elsif Nkind_In (N, N_Task_Type_Declaration,\n+                               N_Protected_Type_Declaration)\n             then\n                null;\n \n@@ -12643,8 +12705,8 @@ package body Sem_Ch3 is\n          if Is_Type (Prev)\n            and then (Is_Tagged_Type (Prev)\n                       or else Present (Class_Wide_Type (Prev)))\n-           and then (Nkind (N) /= N_Task_Type_Declaration\n-                      and then Nkind (N) /= N_Protected_Type_Declaration)\n+           and then not Nkind_In (N, N_Task_Type_Declaration,\n+                                     N_Protected_Type_Declaration)\n          then\n             --  The full declaration is either a tagged record or an\n             --  extension otherwise this is an error\n@@ -12706,8 +12768,8 @@ package body Sem_Ch3 is\n \n       --  Case of an anonymous array subtype\n \n-      if Def_Kind = N_Constrained_Array_Definition\n-        or else Def_Kind = N_Unconstrained_Array_Definition\n+      if Nkind_In (Def_Kind, N_Constrained_Array_Definition,\n+                             N_Unconstrained_Array_Definition)\n       then\n          T := Empty;\n          Array_Type_Declaration (T, Obj_Def);\n@@ -13457,7 +13519,7 @@ package body Sem_Ch3 is\n          --  secondary tags of the parent.\n \n          if Ekind (Component) = E_Component\n-           and then Present (Related_Interface (Component))\n+           and then Present (Related_Type (Component))\n          then\n             null;\n \n@@ -13568,22 +13630,16 @@ package body Sem_Ch3 is\n             return Constraint_Kind = N_Range_Constraint;\n \n          when Decimal_Fixed_Point_Kind =>\n-            return\n-              Constraint_Kind = N_Digits_Constraint\n-                or else\n-              Constraint_Kind = N_Range_Constraint;\n+            return Nkind_In (Constraint_Kind, N_Digits_Constraint,\n+                                              N_Range_Constraint);\n \n          when Ordinary_Fixed_Point_Kind =>\n-            return\n-              Constraint_Kind = N_Delta_Constraint\n-                or else\n-              Constraint_Kind = N_Range_Constraint;\n+            return Nkind_In (Constraint_Kind, N_Delta_Constraint,\n+                                              N_Range_Constraint);\n \n          when Float_Kind =>\n-            return\n-              Constraint_Kind = N_Digits_Constraint\n-                or else\n-              Constraint_Kind = N_Range_Constraint;\n+            return Nkind_In (Constraint_Kind, N_Digits_Constraint,\n+                                              N_Range_Constraint);\n \n          when Access_Kind       |\n               Array_Kind        |\n@@ -15520,19 +15576,14 @@ package body Sem_Ch3 is\n \n                Type_Decl := Parent (R);\n                while Present (Type_Decl) and then not\n-                 (Nkind (Type_Decl) = N_Full_Type_Declaration\n-                    or else\n-                  Nkind (Type_Decl) = N_Subtype_Declaration\n-                    or else\n-                  Nkind (Type_Decl) = N_Loop_Statement\n-                    or else\n-                  Nkind (Type_Decl) = N_Task_Type_Declaration\n-                    or else\n-                  Nkind (Type_Decl) = N_Single_Task_Declaration\n+                 (Nkind_In (Type_Decl, N_Full_Type_Declaration,\n+                                       N_Subtype_Declaration,\n+                                       N_Loop_Statement,\n+                                       N_Task_Type_Declaration)\n                     or else\n-                  Nkind (Type_Decl) = N_Protected_Type_Declaration\n-                    or else\n-                  Nkind (Type_Decl) = N_Single_Protected_Declaration)\n+                  Nkind_In (Type_Decl, N_Single_Task_Declaration,\n+                                       N_Protected_Type_Declaration,\n+                                       N_Single_Protected_Declaration))\n                loop\n                   Type_Decl := Parent (Type_Decl);\n                end loop;\n@@ -15550,8 +15601,8 @@ package body Sem_Ch3 is\n \n                      begin\n                         Indic := Parent (R);\n-                        while Present (Indic) and then not\n-                          (Nkind (Indic) = N_Subtype_Indication)\n+                        while Present (Indic)\n+                          and then Nkind (Indic) /= N_Subtype_Indication\n                         loop\n                            Indic := Parent (Indic);\n                         end loop;\n@@ -15694,7 +15745,6 @@ package body Sem_Ch3 is\n       --  Case of no constraints present\n \n       if Nkind (S) /= N_Subtype_Indication then\n-\n          Find_Type (S);\n          Check_Incomplete (S);\n          P := Parent (S);\n@@ -15710,18 +15760,21 @@ package body Sem_Ch3 is\n             Error_Msg_N (\"`NOT NULL` only allowed for an access type\", S);\n          end if;\n \n+         --  The following is ugly, can't we have a range or even a flag???\n+\n          May_Have_Null_Exclusion :=\n-           Nkind (P) = N_Access_Definition\n-           or else Nkind (P) = N_Access_Function_Definition\n-           or else Nkind (P) = N_Access_Procedure_Definition\n-           or else Nkind (P) = N_Access_To_Object_Definition\n-           or else Nkind (P) = N_Allocator\n-           or else Nkind (P) = N_Component_Definition\n-           or else Nkind (P) = N_Derived_Type_Definition\n-           or else Nkind (P) = N_Discriminant_Specification\n-           or else Nkind (P) = N_Object_Declaration\n-           or else Nkind (P) = N_Parameter_Specification\n-           or else Nkind (P) = N_Subtype_Declaration;\n+           Nkind_In (P, N_Access_Definition,\n+                        N_Access_Function_Definition,\n+                        N_Access_Procedure_Definition,\n+                        N_Access_To_Object_Definition,\n+                        N_Allocator,\n+                        N_Component_Definition)\n+             or else\n+           Nkind_In (P, N_Derived_Type_Definition,\n+                        N_Discriminant_Specification,\n+                        N_Object_Declaration,\n+                        N_Parameter_Specification,\n+                        N_Subtype_Declaration);\n \n          --  Create an Itype that is a duplicate of Entity (S) but with the\n          --  null-exclusion attribute\n@@ -16079,7 +16132,6 @@ package body Sem_Ch3 is\n       ------------------\n \n       function Designates_T (Subt : Node_Id) return Boolean is\n-\n          Type_Id : constant Name_Id := Chars (Typ);\n \n          function Names_T (Nam : Node_Id) return Boolean;\n@@ -16108,9 +16160,11 @@ package body Sem_Ch3 is\n                   else\n                      return False;\n                   end if;\n+\n                else\n                   return False;\n                end if;\n+\n             else\n                return False;\n             end if;\n@@ -16143,8 +16197,8 @@ package body Sem_Ch3 is\n                        or else\n                          (Is_Class_Wide_Type (Entity (Subt))\n                            and then\n-                           Chars (Etype (Base_Type (Entity (Subt))))\n-                             = Type_Id));\n+                           Chars (Etype (Base_Type (Entity (Subt)))) =\n+                                                                  Type_Id));\n             end if;\n \n          --  A reference to the current type may appear as the prefix of\n@@ -16168,7 +16222,7 @@ package body Sem_Ch3 is\n          Param_Spec : Node_Id;\n \n          Acc_Subprg : constant Node_Id :=\n-           Access_To_Subprogram_Definition (Acc_Def);\n+                        Access_To_Subprogram_Definition (Acc_Def);\n \n       begin\n          if No (Acc_Subprg) then\n@@ -16203,7 +16257,6 @@ package body Sem_Ch3 is\n          end if;\n \n          return False;\n-\n       end Mentions_T;\n \n    --  Start of processing for Check_Anonymous_Access_Components\n@@ -16445,9 +16498,9 @@ package body Sem_Ch3 is\n             Tag_Comp := Make_Defining_Identifier (Sloc (Def), Name_uTag);\n             Enter_Name (Tag_Comp);\n \n+            Set_Ekind                     (Tag_Comp, E_Component);\n             Set_Is_Tag                    (Tag_Comp);\n             Set_Is_Aliased                (Tag_Comp);\n-            Set_Ekind                     (Tag_Comp, E_Component);\n             Set_Etype                     (Tag_Comp, RTE (RE_Tag));\n             Set_DT_Entry_Count            (Tag_Comp, No_Uint);\n             Set_Original_Record_Component (Tag_Comp, Tag_Comp);"}, {"sha": "3afb0a2b2ab88d4a13e47d6db58a5f416e96587e", "filename": "gcc/ada/sem_ch3.ads", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7af38a4beb098888bab5d365c57c957033c900/gcc%2Fada%2Fsem_ch3.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7af38a4beb098888bab5d365c57c957033c900/gcc%2Fada%2Fsem_ch3.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.ads?ref=7d7af38a4beb098888bab5d365c57c957033c900", "patch": "@@ -120,18 +120,16 @@ package Sem_Ch3  is\n    --  subprogram of the parent type.\n \n    procedure Derive_Subprograms\n-     (Parent_Type           : Entity_Id;\n-      Derived_Type          : Entity_Id;\n-      Generic_Actual        : Entity_Id := Empty);\n+     (Parent_Type    : Entity_Id;\n+      Derived_Type   : Entity_Id;\n+      Generic_Actual : Entity_Id := Empty);\n    --  To complete type derivation, collect/retrieve the primitive operations\n    --  of the parent type, and replace the subsidiary subtypes with the derived\n    --  type, to build the specs of the inherited ops. For generic actuals, the\n    --  mapping of the primitive operations to those of the parent type is also\n    --  done by rederiving the operations within the instance. For tagged types,\n    --  the derived subprograms are aliased to those of the actual, not those of\n-   --  the ancestor. The last two params are used in case of derivation from\n-   --  abstract interface types: No_Predefined_Prims is used to avoid the\n-   --  derivation of predefined primitives from an abstract interface.\n+   --  the ancestor.\n    --\n    --  Note: one might expect this to be private to the package body, but\n    --  there is one rather unusual usage in package Exp_Dist."}]}