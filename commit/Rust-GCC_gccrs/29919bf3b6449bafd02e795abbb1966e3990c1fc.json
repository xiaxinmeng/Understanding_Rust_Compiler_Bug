{"sha": "29919bf3b6449bafd02e795abbb1966e3990c1fc", "node_id": "C_kwDOANBUbNoAKDI5OTE5YmYzYjY0NDliYWZkMDJlNzk1YWJiYjE5NjZlMzk5MGMxZmM", "commit": {"author": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2022-09-03T09:58:47Z"}, "committer": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2022-09-25T12:44:53Z"}, "message": "fortran: Move clobbers after evaluation of all arguments [PR106817]\n\nFor actual arguments whose dummy is INTENT(OUT), we used to generate\nclobbers on them at the same time we generated the argument reference\nfor the function call.  This was wrong if for an argument coming\nlater, the value expression was depending on the value of the just-\nclobbered argument, and we passed an undefined value in that case.\n\nWith this change, clobbers are collected separatedly and appended\nto the procedure call preliminary code after all the arguments have been\nevaluated.\n\n\tPR fortran/106817\n\ngcc/fortran/ChangeLog:\n\n\t* trans-expr.cc (gfc_conv_procedure_call): Collect all clobbers\n\tto their own separate block.  Append the block of clobbers to\n\tthe procedure preliminary block after the argument evaluation\n\tcodes for all the arguments.\n\ngcc/testsuite/ChangeLog:\n\n\t* gfortran.dg/intent_optimize_4.f90: New test.", "tree": {"sha": "9d7cb942bb55c967647750a6e632369b19ebda87", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9d7cb942bb55c967647750a6e632369b19ebda87"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/29919bf3b6449bafd02e795abbb1966e3990c1fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29919bf3b6449bafd02e795abbb1966e3990c1fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29919bf3b6449bafd02e795abbb1966e3990c1fc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29919bf3b6449bafd02e795abbb1966e3990c1fc/comments", "author": null, "committer": null, "parents": [{"sha": "edaf1e005c90b311c39b46d85cea17befbece112", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/edaf1e005c90b311c39b46d85cea17befbece112", "html_url": "https://github.com/Rust-GCC/gccrs/commit/edaf1e005c90b311c39b46d85cea17befbece112"}], "stats": {"total": 49, "additions": 47, "deletions": 2}, "files": [{"sha": "f93923b5bdb7a6e366a60c1c7f6e6c60653390e7", "filename": "gcc/fortran/trans-expr.cc", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29919bf3b6449bafd02e795abbb1966e3990c1fc/gcc%2Ffortran%2Ftrans-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29919bf3b6449bafd02e795abbb1966e3990c1fc/gcc%2Ffortran%2Ftrans-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.cc?ref=29919bf3b6449bafd02e795abbb1966e3990c1fc", "patch": "@@ -6018,7 +6018,6 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n   gfc_charlen cl;\n   gfc_expr *e;\n   gfc_symbol *fsym;\n-  stmtblock_t post;\n   enum {MISSING = 0, ELEMENTAL, SCALAR, SCALAR_POINTER, ARRAY};\n   gfc_component *comp = NULL;\n   int arglen;\n@@ -6062,7 +6061,9 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n   else\n     info = NULL;\n \n+  stmtblock_t post, clobbers;\n   gfc_init_block (&post);\n+  gfc_init_block (&clobbers);\n   gfc_init_interface_mapping (&mapping);\n   if (!comp)\n     {\n@@ -6531,7 +6532,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t\t  var = build_fold_indirect_ref_loc (input_location,\n \t\t\t\t\t\t\t     parmse.expr);\n \t\t\t  tree clobber = build_clobber (TREE_TYPE (var));\n-\t\t\t  gfc_add_modify (&se->pre, var, clobber);\n+\t\t\t  gfc_add_modify (&clobbers, var, clobber);\n \t\t\t}\n \t\t    }\n \t\t  /* Catch base objects that are not variables.  */\n@@ -7399,6 +7400,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \n       vec_safe_push (arglist, parmse.expr);\n     }\n+  gfc_add_block_to_block (&se->pre, &clobbers);\n   gfc_finish_interface_mapping (&mapping, &se->pre, &se->post);\n \n   if (comp)"}, {"sha": "effbaa12a2d95b72ada52e06c07f4d910f818b77", "filename": "gcc/testsuite/gfortran.dg/intent_optimize_4.f90", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29919bf3b6449bafd02e795abbb1966e3990c1fc/gcc%2Ftestsuite%2Fgfortran.dg%2Fintent_optimize_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29919bf3b6449bafd02e795abbb1966e3990c1fc/gcc%2Ftestsuite%2Fgfortran.dg%2Fintent_optimize_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fintent_optimize_4.f90?ref=29919bf3b6449bafd02e795abbb1966e3990c1fc", "patch": "@@ -0,0 +1,43 @@\n+! { dg-do run }\n+! { dg-additional-options \"-fdump-tree-original\" }\n+! { dg-final { scan-tree-dump-times \"CLOBBER\" 2 \"original\" } }\n+!\n+! PR fortran/106817\n+! Check that for an actual argument whose dummy is INTENT(OUT),\n+! the clobber that is emitted in the caller before a procedure call\n+! happens after any expression depending on the argument value has been\n+! evaluated.\n+! \n+\n+module m\n+  implicit none\n+contains\n+  subroutine copy1(out, in)\n+    integer, intent(in) :: in\n+    integer, intent(out) :: out\n+    out = in\n+  end subroutine copy1\n+  subroutine copy2(in, out)\n+    integer, intent(in) :: in\n+    integer, intent(out) :: out\n+    out = in\n+  end subroutine copy2\n+end module m\n+\n+program p\n+  use m\n+  implicit none\n+  integer :: a, b\n+\n+  ! Clobbering of a should happen after a+1 has been evaluated.\n+  a = 3\n+  call copy1(a, a+1)\n+  if (a /= 4) stop 1\n+\n+  ! Clobbering order does not depend on the order of arguments.\n+  ! It should also come last with reversed arguments.\n+  b = 12\n+  call copy2(b+1, b)\n+  if (b /= 13) stop 2\n+\n+end program p"}]}