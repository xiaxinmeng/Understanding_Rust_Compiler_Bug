{"sha": "88f48e2967ead9be262483618238efa9c7c842ec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODhmNDhlMjk2N2VhZDliZTI2MjQ4MzYxODIzOGVmYTljN2M4NDJlYw==", "commit": {"author": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2020-06-01T07:28:35Z"}, "committer": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2020-06-01T18:44:22Z"}, "message": "coroutines: Correct handling of references in parm copies [PR95350].\n\nAdjust to handle rvalue refs the same way as clang, and to correct\nthe handling of moves when a copy CTOR is present.  This is one area\nwhere we could make things easier for the end-user (as was implemented\nbefore this change), however there needs to be agreement about when the\nfull statement containing a coroutine call ends (i.e. when the ramp\nterminates or when the coroutine terminates).\n\ngcc/cp/ChangeLog:\n\n\tPR c++/95350\n\t* coroutines.cc (struct param_info): Remove rv_ref field.\n\t(build_actor_fn): Remove specifial rvalue ref handling.\n\t(morph_fn_to_coro): Likewise.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/95350\n\t* g++.dg/coroutines/torture/func-params-08.C: Adjust test to\n\treflect that all rvalue refs are dangling.\n\t* g++.dg/coroutines/torture/func-params-09-awaitable-parms.C:\n\tLikewise.\n\t* g++.dg/coroutines/pr95350.C: New test.", "tree": {"sha": "5f5e2d58a9ba4ceba801ad7913dbfb8163d080c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5f5e2d58a9ba4ceba801ad7913dbfb8163d080c1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/88f48e2967ead9be262483618238efa9c7c842ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88f48e2967ead9be262483618238efa9c7c842ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88f48e2967ead9be262483618238efa9c7c842ec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88f48e2967ead9be262483618238efa9c7c842ec/comments", "author": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "118158b646d402b0fb5d760e4827611b731fe6f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/118158b646d402b0fb5d760e4827611b731fe6f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/118158b646d402b0fb5d760e4827611b731fe6f3"}], "stats": {"total": 91, "additions": 50, "deletions": 41}, "files": [{"sha": "e90387b4c8d822d62a7415ecc45e44fa81464120", "filename": "gcc/cp/coroutines.cc", "status": "modified", "additions": 10, "deletions": 31, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f48e2967ead9be262483618238efa9c7c842ec/gcc%2Fcp%2Fcoroutines.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f48e2967ead9be262483618238efa9c7c842ec/gcc%2Fcp%2Fcoroutines.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcoroutines.cc?ref=88f48e2967ead9be262483618238efa9c7c842ec", "patch": "@@ -1803,7 +1803,6 @@ struct param_info\n   tree frame_type;   /* The type used to represent this parm in the frame.  */\n   tree orig_type;    /* The original type of the parm (not as passed).  */\n   bool by_ref;       /* Was passed by reference.  */\n-  bool rv_ref;       /* Was an rvalue reference.  */\n   bool pt_ref;       /* Was a pointer to object.  */\n   bool trivial_dtor; /* The frame type has a trivial DTOR.  */\n   bool this_ptr;     /* Is 'this' */\n@@ -2073,12 +2072,6 @@ build_actor_fn (location_t loc, tree coro_frame_type, tree actor, tree fnbody,\n \t  if (parm.pt_ref)\n \t    fld_idx = build1_loc (loc, CONVERT_EXPR, TREE_TYPE (arg), fld_idx);\n \n-\t  /* We expect an rvalue ref. here.  */\n-\t  if (parm.rv_ref)\n-\t    fld_idx = convert_to_reference (DECL_ARG_TYPE (arg), fld_idx,\n-\t\t\t\t\t    CONV_STATIC, LOOKUP_NORMAL,\n-\t\t\t\t\t    NULL_TREE, tf_warning_or_error);\n-\n \t  int i;\n \t  tree *puse;\n \t  FOR_EACH_VEC_ELT (*parm.body_uses, i, puse)\n@@ -3766,32 +3759,21 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n \t  if (actual_type == NULL_TREE)\n \t    actual_type = error_mark_node;\n \t  parm.orig_type = actual_type;\n-\t  parm.by_ref = parm.rv_ref = parm.pt_ref = false;\n-\t  if (TREE_CODE (actual_type) == REFERENCE_TYPE\n-\t      && TYPE_REF_IS_RVALUE (DECL_ARG_TYPE (arg)))\n-\t    {\n-\t      parm.rv_ref = true;\n-\t      actual_type = TREE_TYPE (actual_type);\n-\t      parm.frame_type = actual_type;\n-\t    }\n-\t  else if (TREE_CODE (actual_type) == REFERENCE_TYPE)\n+\t  parm.by_ref = parm.pt_ref = false;\n+\t  if (TREE_CODE (actual_type) == REFERENCE_TYPE)\n \t    {\n \t      /* If the user passes by reference, then we will save the\n \t\t pointer to the original.  As noted in\n \t\t [dcl.fct.def.coroutine] / 13, if the lifetime of the\n \t\t referenced item ends and then the coroutine is resumed,\n \t\t we have UB; well, the user asked for it.  */\n \t      actual_type = build_pointer_type (TREE_TYPE (actual_type));\n-\t      parm.frame_type = actual_type;\n \t      parm.pt_ref = true;\n \t    }\n \t  else if (TYPE_REF_P (DECL_ARG_TYPE (arg)))\n-\t    {\n-\t      parm.by_ref = true;\n-\t      parm.frame_type = actual_type;\n-\t    }\n-\t  else\n-\t    parm.frame_type = actual_type;\n+\t    parm.by_ref = true;\n+\n+\t  parm.frame_type = actual_type;\n \n \t  parm.this_ptr = is_this_parameter (arg);\n \t  /* See PR94807.  When a lambda is in a template instantiation, the\n@@ -4175,17 +4157,16 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n \t    }\n \t  else if (parm.by_ref)\n \t    vec_safe_push (promise_args, fld_idx);\n-\t  else if (parm.rv_ref)\n-\t    vec_safe_push (promise_args, rvalue (fld_idx));\n \t  else\n \t    vec_safe_push (promise_args, arg);\n \n \t  if (TYPE_NEEDS_CONSTRUCTING (parm.frame_type))\n \t    {\n \t      vec<tree, va_gc> *p_in;\n-\t      if (parm.by_ref\n-\t\t  && classtype_has_non_deleted_move_ctor (parm.frame_type)\n-\t\t  && !classtype_has_non_deleted_copy_ctor (parm.frame_type))\n+\t      if (CLASS_TYPE_P (parm.frame_type)\n+\t\t  && classtype_has_non_deleted_move_ctor (parm.frame_type))\n+\t\tp_in = make_tree_vector_single (move (arg));\n+\t      else if (lvalue_p (arg))\n \t\tp_in = make_tree_vector_single (rvalue (arg));\n \t      else\n \t\tp_in = make_tree_vector_single (arg);\n@@ -4198,9 +4179,7 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n \t    }\n \t  else\n \t    {\n-\t      if (parm.rv_ref)\n-\t\tr = convert_from_reference (arg);\n-\t      else if (!same_type_p (parm.frame_type, DECL_ARG_TYPE (arg)))\n+\t      if (!same_type_p (parm.frame_type, DECL_ARG_TYPE (arg)))\n \t\tr = build1_loc (DECL_SOURCE_LOCATION (arg), CONVERT_EXPR,\n \t\t\t\tparm.frame_type, arg);\n \t      else"}, {"sha": "1915032c471dd8e91f2d1b87578a02c65534f1ff", "filename": "gcc/testsuite/g++.dg/coroutines/pr95350.C", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f48e2967ead9be262483618238efa9c7c842ec/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr95350.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f48e2967ead9be262483618238efa9c7c842ec/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr95350.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr95350.C?ref=88f48e2967ead9be262483618238efa9c7c842ec", "patch": "@@ -0,0 +1,28 @@\n+#if __has_include(<coroutine>)\n+#include <coroutine>\n+#else\n+#include <experimental/coroutine>\n+namespace std { using namespace experimental; }\n+#endif\n+#include <utility>\n+\n+struct task {\n+    struct promise_type {\n+        task get_return_object();\n+        void return_void();\n+        void unhandled_exception();\n+        std::suspend_always initial_suspend() noexcept;\n+        std::suspend_always final_suspend() noexcept;\n+    };\n+};\n+\n+struct move_only {\n+    move_only();\n+    move_only(const move_only&) = delete;\n+    move_only(move_only&) = delete;\n+    move_only(move_only&&) = default;\n+};\n+\n+task f(move_only x) {\n+    co_return;\n+}"}, {"sha": "cce1521b226047945c7f34801eb1cec9f4c949f4", "filename": "gcc/testsuite/g++.dg/coroutines/torture/func-params-08.C", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f48e2967ead9be262483618238efa9c7c842ec/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Ffunc-params-08.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f48e2967ead9be262483618238efa9c7c842ec/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Ffunc-params-08.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Ffunc-params-08.C?ref=88f48e2967ead9be262483618238efa9c7c842ec", "patch": "@@ -69,8 +69,9 @@ my_coro (Foo t_lv, Foo& t_ref, Foo&& t_rv_ref)\n   PRINT (\"my_coro 1\");\n   sum += co_await t_ref;\n   PRINT (\"my_coro 2\");\n-  sum += co_await t_rv_ref;\n-  PRINT (\"my_coro 3\");\n+  // This can't work for the rvalue ref, it's always dangling.\n+  //sum += co_await t_rv_ref;\n+  //PRINT (\"my_coro 3\");\n   co_return sum;\n }\n \n@@ -90,17 +91,17 @@ int main ()\n   // now do the three co_awaits.\n   while(!x.handle.done())\n     x.handle.resume();\n-  PRINT (\"main: after resuming 3 co_awaits\");\n+  PRINT (\"main: after resuming 2 co_awaits\");\n \n   /* Now we should have the co_returned value.  */\n   int y = x.handle.promise().get_value();\n-  if (y != 14)\n+  if (y != 10)\n     {\n       PRINTF (\"main: wrong result (%d).\", y);\n       abort ();\n     }\n \n-  if (regular != 3 || copy != 1 || move != 1)\n+  if (regular != 3 || copy != 0 || move != 1)\n     {\n       PRINTF (\"main: unexpected ctor use (R:%d, C:%d, M:%d)\\n\",\n \t      regular, copy, move);"}, {"sha": "81430bf4d54632a1009fe5ab3d45980458a95b73", "filename": "gcc/testsuite/g++.dg/coroutines/torture/func-params-09-awaitable-parms.C", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f48e2967ead9be262483618238efa9c7c842ec/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Ffunc-params-09-awaitable-parms.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f48e2967ead9be262483618238efa9c7c842ec/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Ffunc-params-09-awaitable-parms.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Ffunc-params-09-awaitable-parms.C?ref=88f48e2967ead9be262483618238efa9c7c842ec", "patch": "@@ -62,8 +62,9 @@ my_coro (FooAwaitable t_lv, FooAwaitable& t_ref, FooAwaitable&& t_rv_ref)\n   PRINT (\"my_coro 1\");\n   sum += co_await t_ref;\n   PRINT (\"my_coro 2\");\n-  sum += co_await t_rv_ref;\n-  PRINT (\"my_coro 3\");\n+  // This can't work for the rvalue ref, it's always dangling.\n+  //sum += co_await t_rv_ref;\n+  //PRINT (\"my_coro 3\");\n   co_return sum;\n }\n \n@@ -83,17 +84,17 @@ int main ()\n   // now do the three co_awaits.\n   while(!x.handle.done())\n     x.handle.resume();\n-  PRINT (\"main: after resuming 3 co_awaits\");\n+  PRINT (\"main: after resuming 2 co_awaits\");\n \n   /* Now we should have the co_returned value.  */\n   int y = x.handle.promise().get_value();\n-  if (y != 14)\n+  if (y != 10)\n     {\n       PRINTF (\"main: wrong result (%d).\", y);\n       abort ();\n     }\n \n-  if (regular != 3 || copy != 1 || move != 1)\n+  if (regular != 3 || copy != 0 || move != 1)\n     {\n       PRINTF (\"main: unexpected ctor use (R:%d, C:%d, M:%d)\\n\",\n \t      regular, copy, move);"}]}