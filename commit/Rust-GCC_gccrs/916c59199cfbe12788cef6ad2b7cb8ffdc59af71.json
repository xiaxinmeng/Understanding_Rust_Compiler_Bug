{"sha": "916c59199cfbe12788cef6ad2b7cb8ffdc59af71", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTE2YzU5MTk5Y2ZiZTEyNzg4Y2VmNmFkMmI3Y2I4ZmZkYzU5YWY3MQ==", "commit": {"author": {"name": "Joseph Myers", "email": "jsm@polyomino.org.uk", "date": "2004-07-21T23:46:20Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2004-07-21T23:46:20Z"}, "message": "re PR c/11250 (-pedantic accepts `char a[] = (\"x\");')\n\n\tPR c/11250\n\t* c-parse.in (init): Change to exprtype.\n\t(primary): Set original_code for STRING to STRING_CST.\n\tCall maybe_warn_string_init for compound literals.\n\t(initdcl, notype_initdcl): Call maybe_warn_string_init.\n\t(initval): Update.\n\t* c-tree.h (maybe_warn_string_init): New.\n\t(pop_init_level, process_init_element): Use struct c_expr.\n\t(struct c_expr): Update comment.\n\t* c-typeck.c (maybe_warn_string_init): New function.\n\t(digest_init): Call it.  Additional parameter strict_string.  All\n\tcallers changed.\n\t(output_init_element): Likewise.\n\t(struct constructor_stack): Use struct c_expr for\n\treplacement_value.\n\t(really_start_incremental_init, push_init_level): Update.\n\t(pop_init_level): Update.  Return struct c_expr.\n\t(process_init_level): Update.  Take struct c_expr argument.\n\ntestsuite:\n\t* gcc.dg/init-string-1.c: New test.\n\nFrom-SVN: r85022", "tree": {"sha": "3445b1b5b70b8f6f28f797b70463fa6e393fa8e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3445b1b5b70b8f6f28f797b70463fa6e393fa8e1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/916c59199cfbe12788cef6ad2b7cb8ffdc59af71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/916c59199cfbe12788cef6ad2b7cb8ffdc59af71", "html_url": "https://github.com/Rust-GCC/gccrs/commit/916c59199cfbe12788cef6ad2b7cb8ffdc59af71", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/916c59199cfbe12788cef6ad2b7cb8ffdc59af71/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf6c40e92d589b24583ef6e5494bd17a78c13033", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf6c40e92d589b24583ef6e5494bd17a78c13033", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf6c40e92d589b24583ef6e5494bd17a78c13033"}], "stats": {"total": 296, "additions": 216, "deletions": 80}, "files": [{"sha": "16fa6573ca820c1a9eae3d8f5cff66e3c36fa18f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/916c59199cfbe12788cef6ad2b7cb8ffdc59af71/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/916c59199cfbe12788cef6ad2b7cb8ffdc59af71/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=916c59199cfbe12788cef6ad2b7cb8ffdc59af71", "patch": "@@ -1,3 +1,24 @@\n+2004-07-22  Joseph S. Myers  <jsm@polyomino.org.uk>\n+\n+\tPR c/11250\n+\t* c-parse.in (init): Change to exprtype.\n+\t(primary): Set original_code for STRING to STRING_CST.\n+\tCall maybe_warn_string_init for compound literals.\n+\t(initdcl, notype_initdcl): Call maybe_warn_string_init.\n+\t(initval): Update.\n+\t* c-tree.h (maybe_warn_string_init): New.\n+\t(pop_init_level, process_init_element): Use struct c_expr.\n+\t(struct c_expr): Update comment.\n+\t* c-typeck.c (maybe_warn_string_init): New function.\n+\t(digest_init): Call it.  Additional parameter strict_string.  All\n+\tcallers changed.\n+\t(output_init_element): Likewise.\n+\t(struct constructor_stack): Use struct c_expr for\n+\treplacement_value.\n+\t(really_start_incremental_init, push_init_level): Update.\n+\t(pop_init_level): Update.  Return struct c_expr.\n+\t(process_init_level): Update.  Take struct c_expr argument.\n+\n 2004-07-21  David S. Miller  <davem@nuts.davemloft.net>\n \n \t* config/sparc/sparc.c (sparc_rtx_costs): Fix typo in previous"}, {"sha": "4179243f24070c92526773d308eff4774e14ed4a", "filename": "gcc/c-parse.in", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/916c59199cfbe12788cef6ad2b7cb8ffdc59af71/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/916c59199cfbe12788cef6ad2b7cb8ffdc59af71/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=916c59199cfbe12788cef6ad2b7cb8ffdc59af71", "patch": "@@ -204,7 +204,8 @@ do {\t\t\t\t\t\t\t\t\t\\\n %type <ttype> offsetof_member_designator\n \n %type <ttype> scspec SCSPEC STATIC TYPESPEC TYPE_QUAL maybe_volatile\n-%type <ttype> initdecls notype_initdecls initdcl notype_initdcl init\n+%type <ttype> initdecls notype_initdecls initdcl notype_initdcl\n+%type <exprtype> init\n %type <ttype> simple_asm_expr maybeasm asm_stmt asm_argument\n %type <ttype> asm_operands nonnull_asm_operands asm_operand asm_clobbers\n %type <ttype> maybe_attribute attributes attribute attribute_list attrib\n@@ -631,7 +632,7 @@ primary:\n \t| CONSTANT\n \t\t{ $$.value = $1; $$.original_code = ERROR_MARK; }\n \t| STRING\n-\t\t{ $$.value = $1; $$.original_code = ERROR_MARK; }\n+\t\t{ $$.value = $1; $$.original_code = STRING_CST; }\n \t| FUNC_NAME\n \t\t{ $$.value = fname_decl (C_RID_CODE ($1), $1);\n \t\t  $$.original_code = ERROR_MARK; }\n@@ -640,9 +641,11 @@ primary:\n \t\t  $2 = groktypename ($2);\n \t\t  really_start_incremental_init ($2); }\n \t  initlist_maybe_comma '}'  %prec UNARY\n-\t\t{ tree constructor = pop_init_level (0);\n+\t\t{ struct c_expr init = pop_init_level (0);\n+\t\t  tree constructor = init.value;\n \t\t  tree type = $2;\n \t\t  finish_init ();\n+\t\t  maybe_warn_string_init (type, init);\n \n \t\t  if (pedantic && ! flag_isoc99)\n \t\t    pedwarn (\"ISO C90 forbids compound literals\");\n@@ -1391,7 +1394,8 @@ initdcl:\n \t  init\n /* Note how the declaration of the variable is in effect while its init is parsed! */\n \t\t{ finish_init ();\n-\t\t  finish_decl ($<ttype>5, $6, $2); }\n+\t\t  maybe_warn_string_init (TREE_TYPE ($<ttype>5), $6);\n+\t\t  finish_decl ($<ttype>5, $6.value, $2); }\n \t| declarator maybeasm maybe_attribute\n \t\t{ tree d = start_decl ($1, current_declspecs, 0,\n \t\t\t\t       chainon ($3, all_prefix_attributes));\n@@ -1407,7 +1411,8 @@ notype_initdcl:\n \t  init\n /* Note how the declaration of the variable is in effect while its init is parsed! */\n \t\t{ finish_init ();\n-\t\t  finish_decl ($<ttype>5, $6, $2); }\n+\t\t  maybe_warn_string_init (TREE_TYPE ($<ttype>5), $6);\n+\t\t  finish_decl ($<ttype>5, $6.value, $2); }\n \t| notype_declarator maybeasm maybe_attribute\n \t\t{ tree d = start_decl ($1, current_declspecs, 0,\n \t\t\t\t       chainon ($3, all_prefix_attributes));\n@@ -1476,13 +1481,13 @@ scspec:\n \n init:\n \texpr_no_commas\n-\t\t{ $$ = $1.value; }\n+\t\t{ $$ = $1; }\n \t| '{'\n \t\t{ really_start_incremental_init (NULL_TREE); }\n \t  initlist_maybe_comma '}'\n \t\t{ $$ = pop_init_level (0); }\n \t| error\n-\t\t{ $$ = error_mark_node; }\n+\t\t{ $$.value = error_mark_node; $$.original_code = ERROR_MARK; }\n \t;\n \n /* `initlist_maybe_comma' is the guts of an initializer in braces.  */\n@@ -1522,7 +1527,7 @@ initval:\n \t  initlist_maybe_comma '}'\n \t\t{ process_init_element (pop_init_level (0)); }\n \t| expr_no_commas\n-\t\t{ process_init_element ($1.value); }\n+\t\t{ process_init_element ($1); }\n \t| error\n \t;\n "}, {"sha": "9e249532a5e38be4e91bbbea808dceca602bd865", "filename": "gcc/c-tree.h", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/916c59199cfbe12788cef6ad2b7cb8ffdc59af71/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/916c59199cfbe12788cef6ad2b7cb8ffdc59af71/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=916c59199cfbe12788cef6ad2b7cb8ffdc59af71", "patch": "@@ -119,8 +119,9 @@ struct c_expr\n   /* The value of the expression.  */\n   tree value;\n   /* Record the original binary operator of an expression, which may\n-     have been changed by fold, or ERROR_MARK for other expressions\n-     (including parenthesized expressions).  */\n+     have been changed by fold, STRING_CST for unparenthesised string\n+     constants, or ERROR_MARK for other expressions (including\n+     parenthesized expressions).  */\n   enum tree_code original_code;\n };\n \n@@ -244,14 +245,15 @@ extern tree build_modify_expr (tree, enum tree_code, tree);\n extern void store_init_value (tree, tree);\n extern void error_init (const char *);\n extern void pedwarn_init (const char *);\n+extern void maybe_warn_string_init (tree, struct c_expr);\n extern void start_init (tree, tree, int);\n extern void finish_init (void);\n extern void really_start_incremental_init (tree);\n extern void push_init_level (int);\n-extern tree pop_init_level (int);\n+extern struct c_expr pop_init_level (int);\n extern void set_init_index (tree, tree);\n extern void set_init_label (tree);\n-extern void process_init_element (tree);\n+extern void process_init_element (struct c_expr);\n extern tree build_compound_literal (tree, tree);\n extern void pedwarn_c90 (const char *, ...) ATTRIBUTE_PRINTF_1;\n extern void pedwarn_c99 (const char *, ...) ATTRIBUTE_PRINTF_1;"}, {"sha": "9c22b8b0cf0d7f85ad625ebf9c8f8f8bc9655486", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 112, "deletions": 68, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/916c59199cfbe12788cef6ad2b7cb8ffdc59af71/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/916c59199cfbe12788cef6ad2b7cb8ffdc59af71/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=916c59199cfbe12788cef6ad2b7cb8ffdc59af71", "patch": "@@ -72,8 +72,8 @@ static void push_array_bounds (int);\n static int spelling_length (void);\n static char *print_spelling (char *);\n static void warning_init (const char *);\n-static tree digest_init (tree, tree, int);\n-static void output_init_element (tree, tree, tree, int);\n+static tree digest_init (tree, tree, bool, int);\n+static void output_init_element (tree, bool, tree, tree, int);\n static void output_pending_init_elements (int);\n static int set_designator (int);\n static void push_range_stack (tree);\n@@ -2960,7 +2960,7 @@ build_c_cast (tree type, tree expr)\n \t  t = digest_init (type,\n \t\t\t   build_constructor (type,\n \t\t\t\t\t      build_tree_list (field, value)),\n-\t\t\t   0);\n+\t\t\t   true, 0);\n \t  TREE_CONSTANT (t) = TREE_CONSTANT (value);\n \t  TREE_INVARIANT (t) = TREE_INVARIANT (value);\n \t  return t;\n@@ -3674,7 +3674,7 @@ store_init_value (tree decl, tree init)\n \n   /* Digest the specified initializer into an expression.  */\n \n-  value = digest_init (type, init, TREE_STATIC (decl));\n+  value = digest_init (type, init, true, TREE_STATIC (decl));\n \n   /* Store the expression if valid; else report error.  */\n \n@@ -3884,14 +3884,32 @@ warning_init (const char *msgid)\n     warning (\"(near initialization for `%s')\", ofwhat);\n }\n \f\n+/* If TYPE is an array type and EXPR is a parenthesized string\n+   constant, warn if pedantic that EXPR is being used to initialize an\n+   object of type TYPE.  */\n+\n+void\n+maybe_warn_string_init (tree type, struct c_expr expr)\n+{\n+  if (pedantic\n+      && TREE_CODE (type) == ARRAY_TYPE\n+      && TREE_CODE (expr.value) == STRING_CST\n+      && expr.original_code != STRING_CST)\n+    pedwarn_init (\"array initialized from parenthesized string constant\");\n+}\n+\n /* Digest the parser output INIT as an initializer for type TYPE.\n    Return a C expression of type TYPE to represent the initial value.\n \n+   If INIT is a string constant, STRICT_STRING is true if it is\n+   unparenthesized or we should not warn here for it being parenthesized.\n+   For other types of INIT, STRICT_STRING is not used.\n+\n    REQUIRE_CONSTANT requests an error if non-constant initializers or\n    elements are seen.  */\n \n static tree\n-digest_init (tree type, tree init, int require_constant)\n+digest_init (tree type, tree init, bool strict_string, int require_constant)\n {\n   enum tree_code code = TREE_CODE (type);\n   tree inside_init = init;\n@@ -3922,6 +3940,11 @@ digest_init (tree type, tree init, int require_constant)\n \t   || typ1 == signed_wchar_type_node)\n \t  && ((inside_init && TREE_CODE (inside_init) == STRING_CST)))\n \t{\n+\t  struct c_expr expr;\n+\t  expr.value = inside_init;\n+\t  expr.original_code = (strict_string ? STRING_CST : ERROR_MARK);\n+\t  maybe_warn_string_init (type, expr);\n+\n \t  if (comptypes (TYPE_MAIN_VARIANT (TREE_TYPE (inside_init)),\n \t\t\t TYPE_MAIN_VARIANT (type)))\n \t    return inside_init;\n@@ -4218,9 +4241,9 @@ struct constructor_stack\n   struct init_node *pending_elts;\n   int offset;\n   int depth;\n-  /* If nonzero, this value should replace the entire\n+  /* If value nonzero, this value should replace the entire\n      constructor at this level.  */\n-  tree replacement_value;\n+  struct c_expr replacement_value;\n   struct constructor_range_stack *range_stack;\n   char constant;\n   char simple;\n@@ -4399,7 +4422,8 @@ really_start_incremental_init (tree type)\n   p->erroneous = constructor_erroneous;\n   p->pending_elts = constructor_pending_elts;\n   p->depth = constructor_depth;\n-  p->replacement_value = 0;\n+  p->replacement_value.value = 0;\n+  p->replacement_value.original_code = ERROR_MARK;\n   p->implicit = 0;\n   p->range_stack = 0;\n   p->outer = 0;\n@@ -4528,7 +4552,8 @@ push_init_level (int implicit)\n   p->erroneous = constructor_erroneous;\n   p->pending_elts = constructor_pending_elts;\n   p->depth = constructor_depth;\n-  p->replacement_value = 0;\n+  p->replacement_value.value = 0;\n+  p->replacement_value.original_code = ERROR_MARK;\n   p->implicit = implicit;\n   p->outer = 0;\n   p->incremental = constructor_incremental;\n@@ -4665,18 +4690,23 @@ push_init_level (int implicit)\n }\n \n /* At the end of an implicit or explicit brace level,\n-   finish up that level of constructor.\n-   If we were outputting the elements as they are read, return 0\n+   finish up that level of constructor.  If a single expression\n+   with redundant braces initialized that level, return the\n+   c_expr structure for that expression.  Otherwise, the original_code\n+   element is set to ERROR_MARK.\n+   If we were outputting the elements as they are read, return 0 as the value\n    from inner levels (process_init_element ignores that),\n-   but return error_mark_node from the outermost level\n+   but return error_mark_node as the value from the outermost level\n    (that's what we want to put in DECL_INITIAL).\n-   Otherwise, return a CONSTRUCTOR expression.  */\n+   Otherwise, return a CONSTRUCTOR expression as the value.  */\n \n-tree\n+struct c_expr\n pop_init_level (int implicit)\n {\n   struct constructor_stack *p;\n-  tree constructor = 0;\n+  struct c_expr ret;\n+  ret.value = 0;\n+  ret.original_code = ERROR_MARK;\n \n   if (implicit == 0)\n     {\n@@ -4748,10 +4778,10 @@ pop_init_level (int implicit)\n     }\n \n   /* Pad out the end of the structure.  */\n-  if (p->replacement_value)\n+  if (p->replacement_value.value)\n     /* If this closes a superfluous brace pair,\n        just pass out the element between them.  */\n-    constructor = p->replacement_value;\n+    ret = p->replacement_value;\n   else if (constructor_type == 0)\n     ;\n   else if (TREE_CODE (constructor_type) != RECORD_TYPE\n@@ -4765,28 +4795,28 @@ pop_init_level (int implicit)\n \t{\n \t  if (!constructor_erroneous)\n \t    error_init (\"empty scalar initializer\");\n-\t  constructor = error_mark_node;\n+\t  ret.value = error_mark_node;\n \t}\n       else if (TREE_CHAIN (constructor_elements) != 0)\n \t{\n \t  error_init (\"extra elements in scalar initializer\");\n-\t  constructor = TREE_VALUE (constructor_elements);\n+\t  ret.value = TREE_VALUE (constructor_elements);\n \t}\n       else\n-\tconstructor = TREE_VALUE (constructor_elements);\n+\tret.value = TREE_VALUE (constructor_elements);\n     }\n   else\n     {\n       if (constructor_erroneous)\n-\tconstructor = error_mark_node;\n+\tret.value = error_mark_node;\n       else\n \t{\n-\t  constructor = build_constructor (constructor_type,\n-\t\t\t\t\t   nreverse (constructor_elements));\n+\t  ret.value = build_constructor (constructor_type,\n+\t\t\t\t\t nreverse (constructor_elements));\n \t  if (constructor_constant)\n-\t    TREE_CONSTANT (constructor) = TREE_INVARIANT (constructor) = 1;\n+\t    TREE_CONSTANT (ret.value) = TREE_INVARIANT (ret.value) = 1;\n \t  if (constructor_constant && constructor_simple)\n-\t    TREE_STATIC (constructor) = 1;\n+\t    TREE_STATIC (ret.value) = 1;\n \t}\n     }\n \n@@ -4812,13 +4842,16 @@ pop_init_level (int implicit)\n   constructor_stack = p->next;\n   free (p);\n \n-  if (constructor == 0)\n+  if (ret.value == 0)\n     {\n       if (constructor_stack == 0)\n-\treturn error_mark_node;\n-      return NULL_TREE;\n+\t{\n+\t  ret.value = error_mark_node;\n+\t  return ret;\n+\t}\n+      return ret;\n     }\n-  return constructor;\n+  return ret;\n }\n \n /* Common handling for both array range and field name designators.\n@@ -5415,13 +5448,17 @@ find_init_member (tree field)\n    Otherwise, collect it in a list from which we will make a CONSTRUCTOR.\n    TYPE is the data type that the containing data type wants here.\n    FIELD is the field (a FIELD_DECL) or the index that this element fills.\n+   If VALUE is a string constant, STRICT_STRING is true if it is\n+   unparenthesized or we should not warn here for it being parenthesized.\n+   For other types of VALUE, STRICT_STRING is not used.\n \n    PENDING if non-nil means output pending elements that belong\n    right after this element.  (PENDING is normally 1;\n    it is 0 while outputting pending elements, to avoid recursion.)  */\n \n static void\n-output_init_element (tree value, tree type, tree field, int pending)\n+output_init_element (tree value, bool strict_string, tree type, tree field,\n+\t\t     int pending)\n {\n   if (type == error_mark_node)\n     {\n@@ -5477,7 +5514,7 @@ output_init_element (tree value, tree type, tree field, int pending)\n \t\t  || TREE_CHAIN (field)))))\n     return;\n \n-  value = digest_init (type, value, require_constant_value);\n+  value = digest_init (type, value, strict_string, require_constant_value);\n   if (value == error_mark_node)\n     {\n       constructor_erroneous = 1;\n@@ -5597,7 +5634,7 @@ output_pending_init_elements (int all)\n \t{\n \t  if (tree_int_cst_equal (elt->purpose,\n \t\t\t\t  constructor_unfilled_index))\n-\t    output_init_element (elt->value,\n+\t    output_init_element (elt->value, true,\n \t\t\t\t TREE_TYPE (constructor_type),\n \t\t\t\t constructor_unfilled_index, 0);\n \t  else if (tree_int_cst_lt (constructor_unfilled_index,\n@@ -5651,7 +5688,7 @@ output_pending_init_elements (int all)\n \t  if (tree_int_cst_equal (elt_bitpos, ctor_unfilled_bitpos))\n \t    {\n \t      constructor_unfilled_fields = elt->purpose;\n-\t      output_init_element (elt->value, TREE_TYPE (elt->purpose),\n+\t      output_init_element (elt->value, true, TREE_TYPE (elt->purpose),\n \t\t\t\t   elt->purpose, 0);\n \t    }\n \t  else if (tree_int_cst_lt (ctor_unfilled_bitpos, elt_bitpos))\n@@ -5718,10 +5755,11 @@ output_pending_init_elements (int all)\n    it calls output_init_element.  */\n \n void\n-process_init_element (tree value)\n+process_init_element (struct c_expr value)\n {\n-  tree orig_value = value;\n-  int string_flag = value != 0 && TREE_CODE (value) == STRING_CST;\n+  tree orig_value = value.value;\n+  int string_flag = orig_value != 0 && TREE_CODE (orig_value) == STRING_CST;\n+  bool strict_string = value.original_code == STRING_CST;\n \n   designator_depth = 0;\n   designator_errorneous = 0;\n@@ -5734,13 +5772,13 @@ process_init_element (tree value)\n       && TREE_CODE (TREE_TYPE (constructor_type)) == INTEGER_TYPE\n       && integer_zerop (constructor_unfilled_index))\n     {\n-      if (constructor_stack->replacement_value)\n+      if (constructor_stack->replacement_value.value)\n         error_init (\"excess elements in char array initializer\");\n       constructor_stack->replacement_value = value;\n       return;\n     }\n \n-  if (constructor_stack->replacement_value != 0)\n+  if (constructor_stack->replacement_value.value != 0)\n     {\n       error_init (\"excess elements in struct initializer\");\n       return;\n@@ -5773,10 +5811,10 @@ process_init_element (tree value)\n     {\n       /* If value is a compound literal and we'll be just using its\n \t content, don't put it into a SAVE_EXPR.  */\n-      if (TREE_CODE (value) != COMPOUND_LITERAL_EXPR\n+      if (TREE_CODE (value.value) != COMPOUND_LITERAL_EXPR\n \t  || !require_constant_value\n \t  || flag_isoc99)\n-\tvalue = save_expr (value);\n+\tvalue.value = save_expr (value.value);\n     }\n \n   while (1)\n@@ -5808,27 +5846,28 @@ process_init_element (tree value)\n \t    }\n \n \t  /* Accept a string constant to initialize a subarray.  */\n-\t  if (value != 0\n+\t  if (value.value != 0\n \t      && fieldcode == ARRAY_TYPE\n \t      && TREE_CODE (TREE_TYPE (fieldtype)) == INTEGER_TYPE\n \t      && string_flag)\n-\t    value = orig_value;\n+\t    value.value = orig_value;\n \t  /* Otherwise, if we have come to a subaggregate,\n \t     and we don't have an element of its type, push into it.  */\n-\t  else if (value != 0 && !constructor_no_implicit\n-\t\t   && value != error_mark_node\n-\t\t   && TYPE_MAIN_VARIANT (TREE_TYPE (value)) != fieldtype\n+\t  else if (value.value != 0 && !constructor_no_implicit\n+\t\t   && value.value != error_mark_node\n+\t\t   && TYPE_MAIN_VARIANT (TREE_TYPE (value.value)) != fieldtype\n \t\t   && (fieldcode == RECORD_TYPE || fieldcode == ARRAY_TYPE\n \t\t       || fieldcode == UNION_TYPE))\n \t    {\n \t      push_init_level (1);\n \t      continue;\n \t    }\n \n-\t  if (value)\n+\t  if (value.value)\n \t    {\n \t      push_member_name (constructor_fields);\n-\t      output_init_element (value, fieldtype, constructor_fields, 1);\n+\t      output_init_element (value.value, strict_string,\n+\t\t\t\t   fieldtype, constructor_fields, 1);\n \t      RESTORE_SPELLING_DEPTH (constructor_depth);\n \t    }\n \t  else\n@@ -5890,31 +5929,33 @@ process_init_element (tree value)\n \t     __STDC__ anyway (and we've already complained about the\n \t     member-designator already).  */\n \t  if (warn_traditional && !in_system_header && !constructor_designated\n-\t      && !(value && (integer_zerop (value) || real_zerop (value))))\n+\t      && !(value.value && (integer_zerop (value.value)\n+\t\t\t\t   || real_zerop (value.value))))\n \t    warning (\"traditional C rejects initialization of unions\");\n \n \t  /* Accept a string constant to initialize a subarray.  */\n-\t  if (value != 0\n+\t  if (value.value != 0\n \t      && fieldcode == ARRAY_TYPE\n \t      && TREE_CODE (TREE_TYPE (fieldtype)) == INTEGER_TYPE\n \t      && string_flag)\n-\t    value = orig_value;\n+\t    value.value = orig_value;\n \t  /* Otherwise, if we have come to a subaggregate,\n \t     and we don't have an element of its type, push into it.  */\n-\t  else if (value != 0 && !constructor_no_implicit\n-\t\t   && value != error_mark_node\n-\t\t   && TYPE_MAIN_VARIANT (TREE_TYPE (value)) != fieldtype\n+\t  else if (value.value != 0 && !constructor_no_implicit\n+\t\t   && value.value != error_mark_node\n+\t\t   && TYPE_MAIN_VARIANT (TREE_TYPE (value.value)) != fieldtype\n \t\t   && (fieldcode == RECORD_TYPE || fieldcode == ARRAY_TYPE\n \t\t       || fieldcode == UNION_TYPE))\n \t    {\n \t      push_init_level (1);\n \t      continue;\n \t    }\n \n-\t  if (value)\n+\t  if (value.value)\n \t    {\n \t      push_member_name (constructor_fields);\n-\t      output_init_element (value, fieldtype, constructor_fields, 1);\n+\t      output_init_element (value.value, strict_string,\n+\t\t\t\t   fieldtype, constructor_fields, 1);\n \t      RESTORE_SPELLING_DEPTH (constructor_depth);\n \t    }\n \t  else\n@@ -5933,16 +5974,16 @@ process_init_element (tree value)\n \t  enum tree_code eltcode = TREE_CODE (elttype);\n \n \t  /* Accept a string constant to initialize a subarray.  */\n-\t  if (value != 0\n+\t  if (value.value != 0\n \t      && eltcode == ARRAY_TYPE\n \t      && TREE_CODE (TREE_TYPE (elttype)) == INTEGER_TYPE\n \t      && string_flag)\n-\t    value = orig_value;\n+\t    value.value = orig_value;\n \t  /* Otherwise, if we have come to a subaggregate,\n \t     and we don't have an element of its type, push into it.  */\n-\t  else if (value != 0 && !constructor_no_implicit\n-\t\t   && value != error_mark_node\n-\t\t   && TYPE_MAIN_VARIANT (TREE_TYPE (value)) != elttype\n+\t  else if (value.value != 0 && !constructor_no_implicit\n+\t\t   && value.value != error_mark_node\n+\t\t   && TYPE_MAIN_VARIANT (TREE_TYPE (value.value)) != elttype\n \t\t   && (eltcode == RECORD_TYPE || eltcode == ARRAY_TYPE\n \t\t       || eltcode == UNION_TYPE))\n \t    {\n@@ -5959,17 +6000,18 @@ process_init_element (tree value)\n \t    }\n \n \t  /* Now output the actual element.  */\n-\t  if (value)\n+\t  if (value.value)\n \t    {\n \t      push_array_bounds (tree_low_cst (constructor_index, 0));\n-\t      output_init_element (value, elttype, constructor_index, 1);\n+\t      output_init_element (value.value, strict_string,\n+\t\t\t\t   elttype, constructor_index, 1);\n \t      RESTORE_SPELLING_DEPTH (constructor_depth);\n \t    }\n \n \t  constructor_index\n \t    = size_binop (PLUS_EXPR, constructor_index, bitsize_one_node);\n \n-\t  if (! value)\n+\t  if (!value.value)\n \t    /* If we are doing the bookkeeping for an element that was\n \t       directly output as a constructor, we must update\n \t       constructor_unfilled_index.  */\n@@ -5988,13 +6030,14 @@ process_init_element (tree value)\n \t    }\n \n \t  /* Now output the actual element.  */\n-\t  if (value)\n-\t    output_init_element (value, elttype, constructor_index, 1);\n+\t  if (value.value)\n+\t    output_init_element (value.value, strict_string,\n+\t\t\t\t elttype, constructor_index, 1);\n \n \t  constructor_index\n \t    = size_binop (PLUS_EXPR, constructor_index, bitsize_one_node);\n \n-\t  if (! value)\n+\t  if (!value.value)\n \t    /* If we are doing the bookkeeping for an element that was\n \t       directly output as a constructor, we must update\n \t       constructor_unfilled_index.  */\n@@ -6010,8 +6053,9 @@ process_init_element (tree value)\n \t}\n       else\n \t{\n-\t  if (value)\n-\t    output_init_element (value, constructor_type, NULL_TREE, 1);\n+\t  if (value.value)\n+\t    output_init_element (value.value, strict_string,\n+\t\t\t\t constructor_type, NULL_TREE, 1);\n \t  constructor_fields = 0;\n \t}\n "}, {"sha": "d199ab1228bb394e99772311dd11d3e54a0215a6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/916c59199cfbe12788cef6ad2b7cb8ffdc59af71/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/916c59199cfbe12788cef6ad2b7cb8ffdc59af71/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=916c59199cfbe12788cef6ad2b7cb8ffdc59af71", "patch": "@@ -1,3 +1,8 @@\n+2004-07-22  Joseph S. Myers  <jsm@polyomino.org.uk>\n+\n+\tPR c/11250\n+\t* gcc.dg/init-string-1.c: New test.\n+\n 2004-07-21  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/15345"}, {"sha": "ace3b34562ee21420d18c5a5f6c12fe3a5e31eae", "filename": "gcc/testsuite/gcc.dg/init-string-1.c", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/916c59199cfbe12788cef6ad2b7cb8ffdc59af71/gcc%2Ftestsuite%2Fgcc.dg%2Finit-string-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/916c59199cfbe12788cef6ad2b7cb8ffdc59af71/gcc%2Ftestsuite%2Fgcc.dg%2Finit-string-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Finit-string-1.c?ref=916c59199cfbe12788cef6ad2b7cb8ffdc59af71", "patch": "@@ -0,0 +1,59 @@\n+/* String initializers for arrays must not be parenthesized.  Bug\n+   11250 from h.b.furuseth at usit.uio.no.  */\n+/* Origin: Joseph Myers <jsm@polyomino.org.uk> */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c99 -pedantic-errors\" } */\n+\n+#include <stddef.h>\n+\n+char *a = \"a\";\n+char *b = (\"b\");\n+char *c = ((\"c\"));\n+\n+char d[] = \"d\";\n+char e[] = (\"e\"); /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+/* { dg-error \"parenthesized|near init\" \"paren array\" { target *-*-* } 14 } */\n+char f[] = ((\"f\")); /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+/* { dg-error \"parenthesized|near init\" \"paren array\" { target *-*-* } 16 } */\n+\n+signed char g[] = { \"d\" };\n+unsigned char h[] = { (\"e\") }; /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+/* { dg-error \"parenthesized|near init\" \"paren array\" { target *-*-* } 20 } */\n+signed char i[] = { ((\"f\")) }; /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+/* { dg-error \"parenthesized|near init\" \"paren array\" { target *-*-* } 22 } */\n+\n+\n+struct s { char a[10]; int b; wchar_t c[10]; };\n+\n+struct s j = {\n+  \"j\",\n+  1,\n+  (L\"j\")\n+}; /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+/* { dg-error \"parenthesized|near init\" \"paren array\" { target *-*-* } 32 } */\n+struct s k = {\n+  ((\"k\")), /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+  /* { dg-error \"parenthesized|near init\" \"paren array\" { target *-*-* } 35 } */\n+  1,\n+  L\"k\"\n+};\n+\n+struct s l = {\n+  .c = (L\"l\"), /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+  /* { dg-error \"parenthesized|near init\" \"paren array\" { target *-*-* } 42 } */\n+  .a = \"l\"\n+};\n+\n+struct s m = {\n+  .c = L\"m\",\n+  .a = (\"m\")\n+}; /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+/* { dg-error \"parenthesized|near init\" \"paren array\" { target *-*-* } 50 } */\n+\n+char *n = (char []){ \"n\" };\n+\n+char *o = (char []){ (\"o\") }; /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+/* { dg-error \"parenthesized|near init\" \"paren array\" { target *-*-* } 55 } */\n+\n+wchar_t *p = (wchar_t [5]){ (L\"p\") }; /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+/* { dg-error \"parenthesized|near init\" \"paren array\" { target *-*-* } 58 } */"}]}