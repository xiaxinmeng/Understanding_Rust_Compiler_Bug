{"sha": "14d7d4be52585b624f1439388ab0dfd5bd3e72c7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTRkN2Q0YmU1MjU4NWI2MjRmMTQzOTM4OGFiMGRmZDViZDNlNzJjNw==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2016-03-18T19:30:20Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2016-03-18T19:30:20Z"}, "message": "re PR rtl-optimization/70263 (ICE at -O1 and above in both 32-bit and 64-bit modes on x86_64-linux-gnu (segmentation fault))\n\n\tPR rtl-optimization/70263\n\t* ira.c (memref_used_between_p): Assert we found END in the insn chain.\n\t(update_equiv_regs): When trying to move a store to after the insn\n\tthat sets the source of the store, make sure the store occurs after\n\tthe insn that sets the source of the store.  When successful note\n\tthe REG_EQUIV note created in the dump file.\n\n\tPR rtl-optimization/70263\n\t* gcc.c-torture/compile/pr70263-1.c: New test.\n\t* gcc.target/i386/pr70263-2.c: New test.\n\nFrom-SVN: r234344", "tree": {"sha": "9cf27aeaf9c3ecf44225affe3b9bc74e867405db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9cf27aeaf9c3ecf44225affe3b9bc74e867405db"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/14d7d4be52585b624f1439388ab0dfd5bd3e72c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14d7d4be52585b624f1439388ab0dfd5bd3e72c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14d7d4be52585b624f1439388ab0dfd5bd3e72c7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14d7d4be52585b624f1439388ab0dfd5bd3e72c7/comments", "author": null, "committer": null, "parents": [{"sha": "0249ef0bfafd5c8ffc2fcf368199dd62b91ea55e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0249ef0bfafd5c8ffc2fcf368199dd62b91ea55e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0249ef0bfafd5c8ffc2fcf368199dd62b91ea55e"}], "stats": {"total": 70, "additions": 68, "deletions": 2}, "files": [{"sha": "6f52c2d2787d4972415c4060a3291db705bec15c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14d7d4be52585b624f1439388ab0dfd5bd3e72c7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14d7d4be52585b624f1439388ab0dfd5bd3e72c7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=14d7d4be52585b624f1439388ab0dfd5bd3e72c7", "patch": "@@ -1,3 +1,12 @@\n+2016-03-18  Jeff Law  <law@redhat.com>\n+\n+\tPR rtl-optimization/70263\n+\t* ira.c (memref_used_between_p): Assert we found END in the insn chain.\n+\t(update_equiv_regs): When trying to move a store to after the insn\n+\tthat sets the source of the store, make sure the store occurs after\n+\tthe insn that sets the source of the store.  When successful note\n+\tthe REG_EQUIV note created in the dump file.\n+\n 2016-03-16  David Wohlferd  <dw@LimeGreenSocks.com>\n             Bernd Schmidt  <bschmidt@redhat.com>\n "}, {"sha": "c12318a6227ba25282a5cf59be7437df668b5622", "filename": "gcc/ira.c", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14d7d4be52585b624f1439388ab0dfd5bd3e72c7/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14d7d4be52585b624f1439388ab0dfd5bd3e72c7/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=14d7d4be52585b624f1439388ab0dfd5bd3e72c7", "patch": "@@ -3225,13 +3225,18 @@ memref_referenced_p (rtx memref, rtx x)\n }\n \n /* TRUE if some insn in the range (START, END] references a memory location\n-   that would be affected by a store to MEMREF.  */\n+   that would be affected by a store to MEMREF.\n+\n+   Callers should not call this routine if START is after END in the\n+   RTL chain.  */\n+\n static int\n memref_used_between_p (rtx memref, rtx_insn *start, rtx_insn *end)\n {\n   rtx_insn *insn;\n \n-  for (insn = NEXT_INSN (start); insn != NEXT_INSN (end);\n+  for (insn = NEXT_INSN (start);\n+       insn && insn != NEXT_INSN (end);\n        insn = NEXT_INSN (insn))\n     {\n       if (!NONDEBUG_INSN_P (insn))\n@@ -3245,6 +3250,7 @@ memref_used_between_p (rtx memref, rtx_insn *start, rtx_insn *end)\n \treturn 1;\n     }\n \n+  gcc_assert (insn == NEXT_INSN (end));\n   return 0;\n }\n \n@@ -3337,6 +3343,7 @@ update_equiv_regs (void)\n   int loop_depth;\n   bitmap cleared_regs;\n   bool *pdx_subregs;\n+  bitmap_head seen_insns;\n \n   /* Use pdx_subregs to show whether a reg is used in a paradoxical\n      subreg.  */\n@@ -3606,11 +3613,14 @@ update_equiv_regs (void)\n   /* A second pass, to gather additional equivalences with memory.  This needs\n      to be done after we know which registers we are going to replace.  */\n \n+  bitmap_initialize (&seen_insns, NULL);\n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     {\n       rtx set, src, dest;\n       unsigned regno;\n \n+      bitmap_set_bit (&seen_insns, INSN_UID (insn));\n+\n       if (! INSN_P (insn))\n \tcontinue;\n \n@@ -3651,6 +3661,7 @@ update_equiv_regs (void)\n \t  rtx_insn *init_insn =\n \t    as_a <rtx_insn *> (XEXP (reg_equiv[regno].init_insns, 0));\n \t  if (validate_equiv_mem (init_insn, src, dest)\n+\t      && bitmap_bit_p (&seen_insns, INSN_UID (init_insn))\n \t      && ! memref_used_between_p (dest, init_insn, insn)\n \t      /* Attaching a REG_EQUIV note will fail if INIT_INSN has\n \t\t multiple sets.  */\n@@ -3661,9 +3672,15 @@ update_equiv_regs (void)\n \t      ira_reg_equiv[regno].init_insns\n \t\t= gen_rtx_INSN_LIST (VOIDmode, insn, NULL_RTX);\n \t      df_notes_rescan (init_insn);\n+\t      if (dump_file)\n+\t\tfprintf (dump_file,\n+\t\t\t \"Adding REG_EQUIV to insn %d for source of insn %d\\n\",\n+\t\t\t INSN_UID (init_insn),\n+\t\t\t INSN_UID (insn));\n \t    }\n \t}\n     }\n+  bitmap_clear (&seen_insns);\n \n   cleared_regs = BITMAP_ALLOC (NULL);\n   /* Now scan all regs killed in an insn to see if any of them are"}, {"sha": "c043b4b8ec3d394d45debe4687674ff69390395f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14d7d4be52585b624f1439388ab0dfd5bd3e72c7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14d7d4be52585b624f1439388ab0dfd5bd3e72c7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=14d7d4be52585b624f1439388ab0dfd5bd3e72c7", "patch": "@@ -1,3 +1,9 @@\n+2016-03-18  Jeff Law  <law@redhat.com>\n+\n+\tPR rtl-optimization/70263\n+\t* gcc.c-torture/compile/pr70263-1.c: New test.\n+\t* gcc.target/i386/pr70263-2.c: New test.\n+\n 2016-03-18  Bernd Schmidt  <bschmidt@redhat.com>\n \n \tPR rtl-optimization/70278"}, {"sha": "d4bf28043f3eb91b941130c34ca36ece11a3e839", "filename": "gcc/testsuite/gcc.c-torture/compile/pr70263-1.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14d7d4be52585b624f1439388ab0dfd5bd3e72c7/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr70263-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14d7d4be52585b624f1439388ab0dfd5bd3e72c7/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr70263-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr70263-1.c?ref=14d7d4be52585b624f1439388ab0dfd5bd3e72c7", "patch": "@@ -0,0 +1,11 @@\n+int a[91];\n+int b, c;\n+void fn1() {\n+  int n, m;\n+  do {\n+    a[c--];\n+    a[--c] = m;\n+    a[--m] = b;\n+  } while (n);\n+}\n+"}, {"sha": "18ebbf05fb74819934b20b8f698843bdfbf9c81d", "filename": "gcc/testsuite/gcc.target/i386/pr70263-2.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14d7d4be52585b624f1439388ab0dfd5bd3e72c7/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr70263-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14d7d4be52585b624f1439388ab0dfd5bd3e72c7/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr70263-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr70263-2.c?ref=14d7d4be52585b624f1439388ab0dfd5bd3e72c7", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-rtl-ira\" } */\n+\n+/* { dg-final { scan-rtl-dump \"Adding REG_EQUIV to insn \\[0-9\\]+ for source of insn \\[0-9\\]+\" \"ira\" } } */\n+\n+typedef float XFtype __attribute__ ((mode (XF)));\n+typedef _Complex float XCtype __attribute__ ((mode (XC)));\n+XCtype\n+__mulxc3 (XFtype a, XFtype b, XFtype c, XFtype d)\n+{\n+  XFtype ac, bd, ad, bc, x, y;\n+  ac = a * c;\n+__asm__ (\"\": \"=m\" (ac):\"m\" (ac));\n+  if (x != x)\n+    {\n+      _Bool recalc = 0;\n+      if (((!(!(((ac) - (ac)) != ((ac) - (ac)))))))\n+\trecalc = 1;\n+      if (recalc)\n+\tx = __builtin_huge_vall () * (a * c - b * d);\n+    }\n+  return x;\n+}"}]}