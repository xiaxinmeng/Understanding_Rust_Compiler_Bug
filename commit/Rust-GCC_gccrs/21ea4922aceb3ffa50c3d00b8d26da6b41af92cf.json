{"sha": "21ea4922aceb3ffa50c3d00b8d26da6b41af92cf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjFlYTQ5MjJhY2ViM2ZmYTUwYzNkMDBiOGQyNmRhNmI0MWFmOTJjZg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2011-06-30T10:25:40Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2011-06-30T10:25:40Z"}, "message": "re PR fortran/49540 (Memory-hog with large DATA stmt)\n\n\tPR fortran/49540\n\t* gfortran.h (gfc_constructor): Add repeat field.\n\t* trans-array.c (gfc_conv_array_initializer): Handle repeat > 1.\n\t* array.c (current_expand): Add repeat field.\n\t(expand_constructor): Copy repeat.\n\t* constructor.c (node_free, node_copy, gfc_constructor_get,\n\tgfc_constructor_lookup): Handle repeat field.\n\t(gfc_constructor_lookup_next, gfc_constructor_remove): New functions.\n\t* data.h (gfc_assign_data_value): Add mpz_t * argument.\n\t(gfc_assign_data_value_range): Removed.\n\t* constructor.h (gfc_constructor_advance): Removed.\n\t(gfc_constructor_lookup_next, gfc_constructor_remove): New prototypes.\n\t* data.c (gfc_assign_data_value): Add REPEAT argument, handle it and\n\talso handle overwriting a range with a single entry.\n\t(gfc_assign_data_value_range): Removed.\n\t* resolve.c (check_data_variable): Adjust gfc_assign_data_value\n\tcall.  Use gfc_assign_data_value instead of\n\tgfc_assign_data_value_expr.\n\n\t* gfortran.dg/pr49540-1.f90: New test.\n\t* gfortran.dg/pr49540-2.f90: New test.\n\nFrom-SVN: r175693", "tree": {"sha": "f873fddb9973169bde2c078e90368a59e90983c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f873fddb9973169bde2c078e90368a59e90983c7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/21ea4922aceb3ffa50c3d00b8d26da6b41af92cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21ea4922aceb3ffa50c3d00b8d26da6b41af92cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21ea4922aceb3ffa50c3d00b8d26da6b41af92cf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21ea4922aceb3ffa50c3d00b8d26da6b41af92cf/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f7069d58f6b79b685000544981eb4d05d8261bf9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7069d58f6b79b685000544981eb4d05d8261bf9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7069d58f6b79b685000544981eb4d05d8261bf9"}], "stats": {"total": 321, "additions": 272, "deletions": 49}, "files": [{"sha": "055c15d29e1e2d985bcf013c21004a071a833d14", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21ea4922aceb3ffa50c3d00b8d26da6b41af92cf/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21ea4922aceb3ffa50c3d00b8d26da6b41af92cf/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=21ea4922aceb3ffa50c3d00b8d26da6b41af92cf", "patch": "@@ -1,3 +1,24 @@\n+2011-06-30  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR fortran/49540\n+\t* gfortran.h (gfc_constructor): Add repeat field.\n+\t* trans-array.c (gfc_conv_array_initializer): Handle repeat > 1.\n+\t* array.c (current_expand): Add repeat field.\n+\t(expand_constructor): Copy repeat.\n+\t* constructor.c (node_free, node_copy, gfc_constructor_get,\n+\tgfc_constructor_lookup): Handle repeat field.\n+\t(gfc_constructor_lookup_next, gfc_constructor_remove): New functions.\n+\t* data.h (gfc_assign_data_value): Add mpz_t * argument.\n+\t(gfc_assign_data_value_range): Removed.\n+\t* constructor.h (gfc_constructor_advance): Removed.\n+\t(gfc_constructor_lookup_next, gfc_constructor_remove): New prototypes.\n+\t* data.c (gfc_assign_data_value): Add REPEAT argument, handle it and\n+\talso handle overwriting a range with a single entry.\n+\t(gfc_assign_data_value_range): Removed.\n+\t* resolve.c (check_data_variable): Adjust gfc_assign_data_value\n+\tcall.  Use gfc_assign_data_value instead of\n+\tgfc_assign_data_value_expr.\n+\n 2011-06-27  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/49466"}, {"sha": "3074275a819a630c230af16737aadcf287ee37fc", "filename": "gcc/fortran/array.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21ea4922aceb3ffa50c3d00b8d26da6b41af92cf/gcc%2Ffortran%2Farray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21ea4922aceb3ffa50c3d00b8d26da6b41af92cf/gcc%2Ffortran%2Farray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farray.c?ref=21ea4922aceb3ffa50c3d00b8d26da6b41af92cf", "patch": "@@ -1322,6 +1322,7 @@ typedef struct\n \n   mpz_t *offset;\n   gfc_component *component;\n+  mpz_t *repeat;\n \n   gfc_try (*expand_work_function) (gfc_expr *);\n }\n@@ -1556,6 +1557,7 @@ expand_constructor (gfc_constructor_base base)\n \t  return FAILURE;\n \t}\n       current_expand.offset = &c->offset;\n+      current_expand.repeat = &c->repeat;\n       current_expand.component = c->n.component;\n       if (current_expand.expand_work_function (e) == FAILURE)\n \treturn FAILURE;"}, {"sha": "600488d640fe6d43891b1f9ba6daedbbc2e36bca", "filename": "gcc/fortran/constructor.c", "status": "modified", "additions": 46, "deletions": 3, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21ea4922aceb3ffa50c3d00b8d26da6b41af92cf/gcc%2Ffortran%2Fconstructor.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21ea4922aceb3ffa50c3d00b8d26da6b41af92cf/gcc%2Ffortran%2Fconstructor.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fconstructor.c?ref=21ea4922aceb3ffa50c3d00b8d26da6b41af92cf", "patch": "@@ -1,5 +1,5 @@\n /* Array and structure constructors\n-   Copyright (C) 2009, 2010\n+   Copyright (C) 2009, 2010, 2011\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -36,6 +36,7 @@ node_free (splay_tree_value value)\n     gfc_free_iterator (c->iterator, 1);\n \n   mpz_clear (c->offset);\n+  mpz_clear (c->repeat);\n \n   free (c);\n }\n@@ -54,6 +55,7 @@ node_copy (splay_tree_node node, void *base)\n   c->n.component = src->n.component;\n \n   mpz_init_set (c->offset, src->offset);\n+  mpz_init_set (c->repeat, src->repeat);\n \n   return c;\n }\n@@ -78,6 +80,7 @@ gfc_constructor_get (void)\n   c->iterator = NULL;\n \n   mpz_init_set_si (c->offset, 0);\n+  mpz_init_set_si (c->repeat, 1);\n \n   return c;\n }\n@@ -169,16 +172,32 @@ gfc_constructor_insert_expr (gfc_constructor_base *base,\n gfc_constructor *\n gfc_constructor_lookup (gfc_constructor_base base, int offset)\n {\n+  gfc_constructor *c;\n   splay_tree_node node;\n \n   if (!base)\n     return NULL;\n \n   node = splay_tree_lookup (base, (splay_tree_key) offset);\n   if (node)\n-    return (gfc_constructor*) node->value;\n+    return (gfc_constructor *) node->value;\n \n-  return NULL;\n+  /* Check if the previous node has a repeat count big enough to\n+     cover the offset looked for.  */\n+  node = splay_tree_predecessor (base, (splay_tree_key) offset);\n+  if (!node)\n+    return NULL;\n+\n+  c = (gfc_constructor *) node->value;\n+  if (mpz_cmp_si (c->repeat, 1) > 0)\n+    {\n+      if (mpz_get_si (c->offset) + mpz_get_si (c->repeat) <= offset)\n+\tc = NULL;\n+    }\n+  else\n+    c = NULL;\n+\n+  return c;\n }\n \n \n@@ -232,3 +251,27 @@ gfc_constructor_next (gfc_constructor *ctor)\n   else\n     return NULL;\n }\n+\n+\n+void\n+gfc_constructor_remove (gfc_constructor *ctor)\n+{\n+  if (ctor)\n+    splay_tree_remove (ctor->base, mpz_get_si (ctor->offset));\n+}\n+\n+\n+gfc_constructor *\n+gfc_constructor_lookup_next (gfc_constructor_base base, int offset)\n+{\n+  splay_tree_node node;\n+\n+  if (!base)\n+    return NULL;\n+\n+  node = splay_tree_successor (base, (splay_tree_key) offset);\n+  if (!node)\n+    return NULL;\n+\n+  return (gfc_constructor *) node->value;\n+}"}, {"sha": "6b4bab4dd8dd8b61ff7081c68ea7921d8cc4b148", "filename": "gcc/fortran/constructor.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21ea4922aceb3ffa50c3d00b8d26da6b41af92cf/gcc%2Ffortran%2Fconstructor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21ea4922aceb3ffa50c3d00b8d26da6b41af92cf/gcc%2Ffortran%2Fconstructor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fconstructor.h?ref=21ea4922aceb3ffa50c3d00b8d26da6b41af92cf", "patch": "@@ -1,5 +1,5 @@\n /* Array and structure constructors\n-   Copyright (C) 2009, 2010\n+   Copyright (C) 2009, 2010, 2011\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -81,6 +81,10 @@ gfc_constructor *gfc_constructor_first (gfc_constructor_base base);\n    Returns NULL if there is no next expression.  */\n gfc_constructor *gfc_constructor_next (gfc_constructor *ctor);\n \n-gfc_constructor *gfc_constructor_advance (gfc_constructor *ctor, int n);\n+/* Remove the gfc_constructor node from the splay tree.  */\n+void gfc_constructor_remove (gfc_constructor *);\n+\n+/* Return first constructor node after offset.  */\n+gfc_constructor *gfc_constructor_lookup_next (gfc_constructor_base, int);\n \n #endif /* GFC_CONSTRUCTOR_H */"}, {"sha": "67da371ad543ebbb2885f72e67095108374364f2", "filename": "gcc/fortran/data.c", "status": "modified", "additions": 127, "deletions": 33, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21ea4922aceb3ffa50c3d00b8d26da6b41af92cf/gcc%2Ffortran%2Fdata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21ea4922aceb3ffa50c3d00b8d26da6b41af92cf/gcc%2Ffortran%2Fdata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdata.c?ref=21ea4922aceb3ffa50c3d00b8d26da6b41af92cf", "patch": "@@ -1,5 +1,5 @@\n /* Supporting functions for resolving DATA statement.\n-   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n+   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011\n    Free Software Foundation, Inc.\n    Contributed by Lifang Zeng <zlf605@hotmail.com>\n \n@@ -189,10 +189,13 @@ create_character_initializer (gfc_expr *init, gfc_typespec *ts,\n \n /* Assign the initial value RVALUE to  LVALUE's symbol->value. If the\n    LVALUE already has an initialization, we extend this, otherwise we\n-   create a new one.  */\n+   create a new one.  If REPEAT is non-NULL, initialize *REPEAT\n+   consecutive values in LVALUE the same value in RVALUE.  In that case,\n+   LVALUE must refer to a full array, not an array section.  */\n \n gfc_try\n-gfc_assign_data_value (gfc_expr *lvalue, gfc_expr *rvalue, mpz_t index)\n+gfc_assign_data_value (gfc_expr *lvalue, gfc_expr *rvalue, mpz_t index,\n+\t\t       mpz_t *repeat)\n {\n   gfc_ref *ref;\n   gfc_expr *init;\n@@ -269,6 +272,100 @@ gfc_assign_data_value (gfc_expr *lvalue, gfc_expr *rvalue, mpz_t index)\n \t\t\t &lvalue->where);\n \t      goto abort;\n \t    }\n+\t  else if (repeat != NULL\n+\t\t   && ref->u.ar.type != AR_ELEMENT)\n+\t    {\n+\t      mpz_t size, end;\n+\t      gcc_assert (ref->u.ar.type == AR_FULL\n+\t\t\t  && ref->next == NULL);\n+\t      mpz_init_set (end, offset);\n+\t      mpz_add (end, end, *repeat);\n+\t      if (spec_size (ref->u.ar.as, &size) == SUCCESS)\n+\t\t{\n+\t\t  if (mpz_cmp (end, size) > 0)\n+\t\t    {\n+\t\t      mpz_clear (size);\n+\t\t      gfc_error (\"Data element above array upper bound at %L\",\n+\t\t\t\t &lvalue->where);\n+\t\t      goto abort;\n+\t\t    }\n+\t\t  mpz_clear (size);\n+\t\t}\n+\n+\t      con = gfc_constructor_lookup (expr->value.constructor,\n+\t\t\t\t\t    mpz_get_si (offset));\n+\t      if (!con)\n+\t\t{\n+\t\t  con = gfc_constructor_lookup_next (expr->value.constructor,\n+\t\t\t\t\t\t     mpz_get_si (offset));\n+\t\t  if (con != NULL && mpz_cmp (con->offset, end) >= 0)\n+\t\t    con = NULL;\n+\t\t}\n+\n+\t      /* Overwriting an existing initializer is non-standard but\n+\t\t usually only provokes a warning from other compilers.  */\n+\t      if (con != NULL && con->expr != NULL)\n+\t\t{\n+\t\t  /* Order in which the expressions arrive here depends on\n+\t\t     whether they are from data statements or F95 style\n+\t\t     declarations.  Therefore, check which is the most\n+\t\t     recent.  */\n+\t\t  gfc_expr *exprd;\n+\t\t  exprd = (LOCATION_LINE (con->expr->where.lb->location)\n+\t\t\t   > LOCATION_LINE (rvalue->where.lb->location))\n+\t\t\t  ? con->expr : rvalue;\n+\t\t  if (gfc_notify_std (GFC_STD_GNU,\"Extension: \"\n+\t\t\t\t      \"re-initialization of '%s' at %L\",\n+\t\t\t\t      symbol->name, &exprd->where) == FAILURE)\n+\t\t    return FAILURE;\n+\t\t}\n+\n+\t      while (con != NULL)\n+\t\t{\n+\t\t  gfc_constructor *next_con = gfc_constructor_next (con);\n+\n+\t\t  if (mpz_cmp (con->offset, end) >= 0)\n+\t\t    break;\n+\t\t  if (mpz_cmp (con->offset, offset) < 0)\n+\t\t    {\n+\t\t      gcc_assert (mpz_cmp_si (con->repeat, 1) > 0);\n+\t\t      mpz_sub (con->repeat, offset, con->offset);\n+\t\t    }\n+\t\t  else if (mpz_cmp_si (con->repeat, 1) > 0\n+\t\t\t   && mpz_get_si (con->offset)\n+\t\t\t      + mpz_get_si (con->repeat) > mpz_get_si (end))\n+\t\t    {\n+\t\t      int endi;\n+\t\t      splay_tree_node node\n+\t\t\t= splay_tree_lookup (con->base,\n+\t\t\t\t\t     mpz_get_si (con->offset));\n+\t\t      gcc_assert (node\n+\t\t\t\t  && con == (gfc_constructor *) node->value\n+\t\t\t\t  && node->key == (splay_tree_key)\n+\t\t\t\t\t\t  mpz_get_si (con->offset));\n+\t\t      endi = mpz_get_si (con->offset)\n+\t\t\t     + mpz_get_si (con->repeat);\n+\t\t      if (endi > mpz_get_si (end) + 1)\n+\t\t\tmpz_set_si (con->repeat, endi - mpz_get_si (end));\n+\t\t      else\n+\t\t\tmpz_set_si (con->repeat, 1);\n+\t\t      mpz_set (con->offset, end);\n+\t\t      node->key = (splay_tree_key) mpz_get_si (end);\n+\t\t      break;\n+\t\t    }\n+\t\t  else\n+\t\t    gfc_constructor_remove (con);\n+\t\t  con = next_con;\n+\t\t}\n+\n+\t      con = gfc_constructor_insert_expr (&expr->value.constructor,\n+\t\t\t\t\t\t NULL, &rvalue->where,\n+\t\t\t\t\t\t mpz_get_si (offset));\n+\t      mpz_set (con->repeat, *repeat);\n+\t      repeat = NULL;\n+\t      mpz_clear (end);\n+\t      break;\n+\t    }\n \t  else\n \t    {\n \t      mpz_t size;\n@@ -293,6 +390,32 @@ gfc_assign_data_value (gfc_expr *lvalue, gfc_expr *rvalue, mpz_t index)\n \t\t\t\t\t\t NULL, &rvalue->where,\n \t\t\t\t\t\t mpz_get_si (offset));\n \t    }\n+\t  else if (mpz_cmp_si (con->repeat, 1) > 0)\n+\t    {\n+\t      /* Need to split a range.  */\n+\t      if (mpz_cmp (con->offset, offset) < 0)\n+\t\t{\n+\t\t  gfc_constructor *pred_con = con;\n+\t\t  con = gfc_constructor_insert_expr (&expr->value.constructor,\n+\t\t\t\t\t\t     NULL, &con->where,\n+\t\t\t\t\t\t     mpz_get_si (offset));\n+\t\t  con->expr = gfc_copy_expr (pred_con->expr);\n+\t\t  mpz_add (con->repeat, pred_con->offset, pred_con->repeat);\n+\t\t  mpz_sub (con->repeat, con->repeat, offset);\n+\t\t  mpz_sub (pred_con->repeat, offset, pred_con->offset);\n+\t\t}\n+\t      if (mpz_cmp_si (con->repeat, 1) > 0)\n+\t\t{\n+\t\t  gfc_constructor *succ_con;\n+\t\t  succ_con\n+\t\t    = gfc_constructor_insert_expr (&expr->value.constructor,\n+\t\t\t\t\t\t   NULL, &con->where,\n+\t\t\t\t\t\t   mpz_get_si (offset) + 1);\n+\t\t  succ_con->expr = gfc_copy_expr (con->expr);\n+\t\t  mpz_sub_ui (succ_con->repeat, con->repeat, 1);\n+\t\t  mpz_set_si (con->repeat, 1);\n+\t\t}\n+\t    }\n \t  break;\n \n \tcase REF_COMPONENT:\n@@ -337,6 +460,7 @@ gfc_assign_data_value (gfc_expr *lvalue, gfc_expr *rvalue, mpz_t index)\n     }\n \n   mpz_clear (offset);\n+  gcc_assert (repeat == NULL);\n \n   if (ref || last_ts->type == BT_CHARACTER)\n     {\n@@ -380,36 +504,6 @@ gfc_assign_data_value (gfc_expr *lvalue, gfc_expr *rvalue, mpz_t index)\n }\n \n \n-/* Similarly, but initialize REPEAT consecutive values in LVALUE the same\n-   value in RVALUE.  */\n-\n-gfc_try\n-gfc_assign_data_value_range (gfc_expr *lvalue, gfc_expr *rvalue,\n-\t\t\t     mpz_t index, mpz_t repeat)\n-{\n-  mpz_t offset, last_offset;\n-  gfc_try t;\n-\n-  mpz_init (offset);\n-  mpz_init (last_offset);\n-  mpz_add (last_offset, index, repeat);\n-\n-  t = SUCCESS;\n-  for (mpz_set(offset, index) ; mpz_cmp(offset, last_offset) < 0;\n-\t\t   mpz_add_ui (offset, offset, 1))\n-    if (gfc_assign_data_value (lvalue, rvalue, offset) == FAILURE)\n-      {\n-\tt = FAILURE;\n-\tbreak;\n-      }\n-\n-  mpz_clear (offset);\n-  mpz_clear (last_offset);\n-\n-  return t;\n-}\n-\n-\n /* Modify the index of array section and re-calculate the array offset.  */\n \n void "}, {"sha": "a9687c45488f47c0524eb53a1171bc8dd9dea342", "filename": "gcc/fortran/data.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21ea4922aceb3ffa50c3d00b8d26da6b41af92cf/gcc%2Ffortran%2Fdata.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21ea4922aceb3ffa50c3d00b8d26da6b41af92cf/gcc%2Ffortran%2Fdata.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdata.h?ref=21ea4922aceb3ffa50c3d00b8d26da6b41af92cf", "patch": "@@ -1,5 +1,5 @@\n /* Header for functions resolving DATA statements.\n-   Copyright (C) 2007, 2008, 2010 Free Software Foundation, Inc.\n+   Copyright (C) 2007, 2008, 2010, 2011 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -19,6 +19,5 @@ along with GCC; see the file COPYING3.  If not see\n \n void gfc_formalize_init_value (gfc_symbol *);\n void gfc_get_section_index (gfc_array_ref *, mpz_t *, mpz_t *);\n-gfc_try gfc_assign_data_value (gfc_expr *, gfc_expr *, mpz_t);\n-gfc_try gfc_assign_data_value_range (gfc_expr *, gfc_expr *, mpz_t, mpz_t);\n+gfc_try gfc_assign_data_value (gfc_expr *, gfc_expr *, mpz_t, mpz_t *);\n void gfc_advance_section (mpz_t *, gfc_array_ref *, mpz_t *);"}, {"sha": "2eb497a20620ab9fe380fd1c3af8df4917875f98", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21ea4922aceb3ffa50c3d00b8d26da6b41af92cf/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21ea4922aceb3ffa50c3d00b8d26da6b41af92cf/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=21ea4922aceb3ffa50c3d00b8d26da6b41af92cf", "patch": "@@ -2271,6 +2271,8 @@ typedef struct gfc_constructor\n      gfc_component *component; /* Record the component being initialized.  */\n   }\n   n;\n+  mpz_t repeat; /* Record the repeat number of initial values in data\n+\t\t  statement like \"data a/5*10/\".  */\n }\n gfc_constructor;\n "}, {"sha": "8418c216c8378db257ee0ba057889a278585509c", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21ea4922aceb3ffa50c3d00b8d26da6b41af92cf/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21ea4922aceb3ffa50c3d00b8d26da6b41af92cf/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=21ea4922aceb3ffa50c3d00b8d26da6b41af92cf", "patch": "@@ -12752,8 +12752,8 @@ check_data_variable (gfc_data_variable *var, locus *where)\n \t      mpz_set_ui (size, 0);\n \t    }\n \n-\t  t = gfc_assign_data_value_range (var->expr, values.vnode->expr,\n-\t\t\t\t\t   offset, range);\n+\t  t = gfc_assign_data_value (var->expr, values.vnode->expr,\n+\t\t\t\t     offset, &range);\n \n \t  mpz_add (offset, offset, range);\n \t  mpz_clear (range);\n@@ -12768,7 +12768,8 @@ check_data_variable (gfc_data_variable *var, locus *where)\n \t  mpz_sub_ui (values.left, values.left, 1);\n \t  mpz_sub_ui (size, size, 1);\n \n-\t  t = gfc_assign_data_value (var->expr, values.vnode->expr, offset);\n+\t  t = gfc_assign_data_value (var->expr, values.vnode->expr,\n+\t\t\t\t     offset, NULL);\n \t  if (t == FAILURE)\n \t    break;\n "}, {"sha": "4c21389dcb3011500a3fdaaccacf6e8b8c24905f", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 33, "deletions": 5, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21ea4922aceb3ffa50c3d00b8d26da6b41af92cf/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21ea4922aceb3ffa50c3d00b8d26da6b41af92cf/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=21ea4922aceb3ffa50c3d00b8d26da6b41af92cf", "patch": "@@ -4555,7 +4555,7 @@ gfc_conv_array_initializer (tree type, gfc_expr * expr)\n   gfc_se se;\n   HOST_WIDE_INT hi;\n   unsigned HOST_WIDE_INT lo;\n-  tree index;\n+  tree index, range;\n   VEC(constructor_elt,gc) *v = NULL;\n \n   switch (expr->expr_type)\n@@ -4609,28 +4609,56 @@ gfc_conv_array_initializer (tree type, gfc_expr * expr)\n           else\n             index = NULL_TREE;\n \n+\t  if (mpz_cmp_si (c->repeat, 1) > 0)\n+\t    {\n+\t      tree tmp1, tmp2;\n+\t      mpz_t maxval;\n+\n+\t      mpz_init (maxval);\n+\t      mpz_add (maxval, c->offset, c->repeat);\n+\t      mpz_sub_ui (maxval, maxval, 1);\n+\t      tmp2 = gfc_conv_mpz_to_tree (maxval, gfc_index_integer_kind);\n+\t      if (mpz_cmp_si (c->offset, 0) != 0)\n+\t\t{\n+\t\t  mpz_add_ui (maxval, c->offset, 1);\n+\t\t  tmp1 = gfc_conv_mpz_to_tree (maxval, gfc_index_integer_kind);\n+\t\t}\n+\t      else\n+\t\ttmp1 = gfc_conv_mpz_to_tree (c->offset, gfc_index_integer_kind);\n+\n+\t      range = fold_build2 (RANGE_EXPR, gfc_array_index_type, tmp1, tmp2);\n+\t      mpz_clear (maxval);\n+\t    }\n+\t  else\n+\t    range = NULL;\n+\n           gfc_init_se (&se, NULL);\n \t  switch (c->expr->expr_type)\n \t    {\n \t    case EXPR_CONSTANT:\n \t      gfc_conv_constant (&se, c->expr);\n-\t      CONSTRUCTOR_APPEND_ELT (v, index, se.expr);\n \t      break;\n \n \t    case EXPR_STRUCTURE:\n               gfc_conv_structure (&se, c->expr, 1);\n-\t      CONSTRUCTOR_APPEND_ELT (v, index, se.expr);\n \t      break;\n \n-\n \t    default:\n \t      /* Catch those occasional beasts that do not simplify\n \t\t for one reason or another, assuming that if they are\n \t\t standard defying the frontend will catch them.  */\n \t      gfc_conv_expr (&se, c->expr);\n-\t      CONSTRUCTOR_APPEND_ELT (v, index, se.expr);\n \t      break;\n \t    }\n+\n+\t  if (range == NULL_TREE)\n+\t    CONSTRUCTOR_APPEND_ELT (v, index, se.expr);\n+\t  else\n+\t    {\n+\t      if (index != NULL_TREE)\n+\t\tCONSTRUCTOR_APPEND_ELT (v, index, se.expr);\n+\t      CONSTRUCTOR_APPEND_ELT (v, range, se.expr);\n+\t    }\n         }\n       break;\n "}, {"sha": "d2e9ee678755d614243cfc8f2bee3af8cafcad31", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21ea4922aceb3ffa50c3d00b8d26da6b41af92cf/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21ea4922aceb3ffa50c3d00b8d26da6b41af92cf/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=21ea4922aceb3ffa50c3d00b8d26da6b41af92cf", "patch": "@@ -1,3 +1,9 @@\n+2011-06-30  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR fortran/49540\n+\t* gfortran.dg/pr49540-1.f90: New test.\n+\t* gfortran.dg/pr49540-2.f90: New test.\n+\n 2011-06-30  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \tPR ada/49511"}, {"sha": "5a8218f0ffe900752d9d57c087b42dc32fff09c3", "filename": "gcc/testsuite/gfortran.dg/pr49540-1.f90", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21ea4922aceb3ffa50c3d00b8d26da6b41af92cf/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr49540-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21ea4922aceb3ffa50c3d00b8d26da6b41af92cf/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr49540-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr49540-1.f90?ref=21ea4922aceb3ffa50c3d00b8d26da6b41af92cf", "patch": "@@ -0,0 +1,6 @@\n+! PR fortran/49540\n+! { dg-do compile }\n+block data\n+  common /a/ b(100000,100)\n+  data b /10000000 * 0.0/\n+end block data"}, {"sha": "f9a3d6df68db0ddab5458bb9aa7f0e42e38c40b1", "filename": "gcc/testsuite/gfortran.dg/pr49540-2.f90", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21ea4922aceb3ffa50c3d00b8d26da6b41af92cf/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr49540-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21ea4922aceb3ffa50c3d00b8d26da6b41af92cf/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr49540-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr49540-2.f90?ref=21ea4922aceb3ffa50c3d00b8d26da6b41af92cf", "patch": "@@ -0,0 +1,17 @@\n+! PR fortran/49540\n+! { dg-do compile }\n+! { dg-options \"\" }\n+block data\n+  common /a/ i(5,5)\n+  data i /4, 23 * 5, 6/\n+  data i(:,2) /1, 3 * 2, 3/\n+  common /b/ j(5,5)\n+  data j(2,:) /1, 3 * 2, 3/\n+  data j /4, 23 * 5, 6/\n+  common /c/ k(5,5)\n+  data k(:,2) /1, 3 * 2, 3/\n+  data k /4, 23 * 5, 6/\n+  common /d/ l(5,5)\n+  data l /4, 23 * 5, 6/\n+  data l(2,:) /1, 3 * 2, 3/\n+end block data"}]}