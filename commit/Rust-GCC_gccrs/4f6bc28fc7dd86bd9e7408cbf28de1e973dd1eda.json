{"sha": "4f6bc28fc7dd86bd9e7408cbf28de1e973dd1eda", "node_id": "C_kwDOANBUbNoAKDRmNmJjMjhmYzdkZDg2YmQ5ZTc0MDhjYmYyOGRlMWU5NzNkZDFlZGE", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2020-03-05T20:50:45Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2022-01-07T00:23:17Z"}, "message": "c++: EH and partially constructed aggr temp [PR66139]\n\nNow that PR94041 is fixed, I can return to addressing PR66139, missing\ncleanups for partially constructed aggregate temporaries.  My previous\napproach of calling split_nonconstant_init in cp_gimplify_init_expr broke\nbecause gimplification is too late to be introducing destructor calls.  So\ninstead I now call it under cp_fold_function, just before cp_genericize;\ndoing it from cp_genericize itself ran into trouble with the rewriting of\ninvisible references.\n\nSo now the prediction in cp_gimplify_expr that cp_gimplify_init_expr\nmight need to replace references to TARGET_EXPR_SLOT within\nTARGET_EXPR_INITIAL has come to pass.  constexpr.c already had the simple\nsearch-and-replace tree walk I needed, but it needed to be fixed to actually\nreplace all occurrences instead of just the first one.\n\nHandling of VEC_INIT_EXPR at gimplify time had similar issues that we worked\naround with build_vec_init_elt, so I'm moving that to cp_fold_function as\nwell.  But it seems that build_vec_init_elt is still useful for setting the\nVEC_INIT_EXPR_IS_CONSTEXPR flag, so I'm leaving it alone.\n\nThis also fixes 52320, because build_aggr_init of each X from build_vec_init\nbuilds an INIT_EXPR rather than call split_nonconstant_init at that point,\nand now that INIT_EXPR gets split later.\n\n\tPR c++/66139\n\tPR c++/52320\n\ngcc/cp/ChangeLog:\n\n\t* constexpr.c (replace_decl): Rename from replace_result_decl.\n\t* cp-tree.h (replace_decl): Declare it.\n\t* cp-gimplify.c (cp_gimplify_init_expr): Call it.\n\t(cp_gimplify_expr): Don't handle VEC_INIT_EXPR.\n\t(cp_genericize_init, cp_genericize_init_expr)\n\t(cp_genericize_target_expr): New.\n\t(cp_fold_r): Call them.\n\t* tree.c (build_array_copy): Add a TARGET_EXPR.\n\t* typeck2.c (digest_init_r): Look through a TARGET_EXPR.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp0x/initlist116.C: New test.\n\t* g++.dg/cpp0x/initlist117.C: New test.\n\t* g++.dg/cpp0x/lambda/lambda-eh.C: New test.\n\t* g++.dg/eh/aggregate1.C: New test.", "tree": {"sha": "0a38c0720e5d43cd717dbef2244dad9d139dd830", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0a38c0720e5d43cd717dbef2244dad9d139dd830"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4f6bc28fc7dd86bd9e7408cbf28de1e973dd1eda", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f6bc28fc7dd86bd9e7408cbf28de1e973dd1eda", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f6bc28fc7dd86bd9e7408cbf28de1e973dd1eda", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f6bc28fc7dd86bd9e7408cbf28de1e973dd1eda/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "beaee0a871b6485d20573fe050b1fd425581e56a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/beaee0a871b6485d20573fe050b1fd425581e56a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/beaee0a871b6485d20573fe050b1fd425581e56a"}], "stats": {"total": 308, "additions": 265, "deletions": 43}, "files": [{"sha": "41594c782fccf132e0b0856e59b46bc5a3f1d265", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f6bc28fc7dd86bd9e7408cbf28de1e973dd1eda/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f6bc28fc7dd86bd9e7408cbf28de1e973dd1eda/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=4f6bc28fc7dd86bd9e7408cbf28de1e973dd1eda", "patch": "@@ -2251,49 +2251,52 @@ cxx_eval_dynamic_cast_fn (const constexpr_ctx *ctx, tree call,\n   return cp_build_addr_expr (obj, complain);\n }\n \n-/* Data structure used by replace_result_decl and replace_result_decl_r.  */\n+/* Data structure used by replace_decl and replace_decl_r.  */\n \n-struct replace_result_decl_data\n+struct replace_decl_data\n {\n-  /* The RESULT_DECL we want to replace.  */\n+  /* The _DECL we want to replace.  */\n   tree decl;\n   /* The replacement for DECL.  */\n   tree replacement;\n+  /* Trees we've visited.  */\n+  hash_set<tree> *pset;\n   /* Whether we've performed any replacements.  */\n   bool changed;\n };\n \n-/* Helper function for replace_result_decl, called through cp_walk_tree.  */\n+/* Helper function for replace_decl, called through cp_walk_tree.  */\n \n static tree\n-replace_result_decl_r (tree *tp, int *walk_subtrees, void *data)\n+replace_decl_r (tree *tp, int *walk_subtrees, void *data)\n {\n-  replace_result_decl_data *d = (replace_result_decl_data *) data;\n+  replace_decl_data *d = (replace_decl_data *) data;\n \n   if (*tp == d->decl)\n     {\n       *tp = unshare_expr (d->replacement);\n       d->changed = true;\n       *walk_subtrees = 0;\n     }\n-  else if (TYPE_P (*tp))\n+  else if (TYPE_P (*tp)\n+\t   || d->pset->add (*tp))\n     *walk_subtrees = 0;\n \n   return NULL_TREE;\n }\n \n-/* Replace every occurrence of DECL, a RESULT_DECL, with (an unshared copy of)\n-   REPLACEMENT within the reduced constant expression *TP.  Returns true iff a\n+/* Replace every occurrence of DECL with (an unshared copy of)\n+   REPLACEMENT within the expression *TP.  Returns true iff a\n    replacement was performed.  */\n \n-static bool\n-replace_result_decl (tree *tp, tree decl, tree replacement)\n+bool\n+replace_decl (tree *tp, tree decl, tree replacement)\n {\n-  gcc_checking_assert (TREE_CODE (decl) == RESULT_DECL\n-\t\t       && (same_type_ignoring_top_level_qualifiers_p\n-\t\t\t   (TREE_TYPE (decl), TREE_TYPE (replacement))));\n-  replace_result_decl_data data = { decl, replacement, false };\n-  cp_walk_tree_without_duplicates (tp, replace_result_decl_r, &data);\n+  gcc_checking_assert (same_type_ignoring_top_level_qualifiers_p\n+\t\t       (TREE_TYPE (decl), TREE_TYPE (replacement)));\n+  hash_set<tree> pset;\n+  replace_decl_data data = { decl, replacement, &pset, false };\n+  cp_walk_tree (tp, replace_decl_r, &data, NULL);\n   return data.changed;\n }\n \n@@ -2962,7 +2965,7 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n \t    if (!*non_constant_p && ctx->object\n \t\t&& CLASS_TYPE_P (TREE_TYPE (res))\n \t\t&& !is_empty_class (TREE_TYPE (res)))\n-\t      if (replace_result_decl (&result, res, ctx->object))\n+\t      if (replace_decl (&result, res, ctx->object))\n \t\tcacheable = false;\n \t}\n       else"}, {"sha": "114fa78b353065da39b26f26492c824d0e33f06d", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 74, "deletions": 19, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f6bc28fc7dd86bd9e7408cbf28de1e973dd1eda/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f6bc28fc7dd86bd9e7408cbf28de1e973dd1eda/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=4f6bc28fc7dd86bd9e7408cbf28de1e973dd1eda", "patch": "@@ -239,12 +239,21 @@ cp_gimplify_init_expr (tree *expr_p)\n   tree to = TREE_OPERAND (*expr_p, 0);\n   tree t;\n \n-  /* What about code that pulls out the temp and uses it elsewhere?  I\n-     think that such code never uses the TARGET_EXPR as an initializer.  If\n-     I'm wrong, we'll abort because the temp won't have any RTL.  In that\n-     case, I guess we'll need to replace references somehow.  */\n-  if (TREE_CODE (from) == TARGET_EXPR && TARGET_EXPR_INITIAL (from))\n-    from = TARGET_EXPR_INITIAL (from);\n+  if (TREE_CODE (from) == TARGET_EXPR)\n+    if (tree init = TARGET_EXPR_INITIAL (from))\n+      {\n+\tif (VOID_TYPE_P (TREE_TYPE (init))\n+\t    && TREE_CODE (init) != AGGR_INIT_EXPR)\n+\t  {\n+\t    /* If this was changed by cp_genericize_target_expr, we need to\n+\t       walk into it to replace uses of the slot.  */\n+\t    replace_decl (&init, TARGET_EXPR_SLOT (from), to);\n+\t    *expr_p = init;\n+\t    return;\n+\t  }\n+\telse\n+\t  from = init;\n+      }\n \n   /* Look through any COMPOUND_EXPRs, since build_compound_expr pushes them\n      inside the TARGET_EXPR.  */\n@@ -460,19 +469,6 @@ cp_gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n       ret = GS_OK;\n       break;\n \n-    case VEC_INIT_EXPR:\n-      {\n-\t*expr_p = expand_vec_init_expr (NULL_TREE, *expr_p,\n-\t\t\t\t\ttf_warning_or_error);\n-\n-\thash_set<tree> pset;\n-\tcp_walk_tree (expr_p, cp_fold_r, &pset, NULL);\n-\tcp_genericize_tree (expr_p, false);\n-\tcopy_if_shared (expr_p);\n-\tret = GS_OK;\n-      }\n-      break;\n-\n     case THROW_EXPR:\n       /* FIXME communicate throw type to back end, probably by moving\n \t THROW_EXPR into ../tree.def.  */\n@@ -868,6 +864,57 @@ omp_cxx_notice_variable (struct cp_genericize_omp_taskreg *omp_ctx, tree decl)\n     }\n }\n \n+/* If we might need to clean up a partially constructed object, break down the\n+   CONSTRUCTOR with split_nonconstant_init.  Also expand VEC_INIT_EXPR at this\n+   point.  If initializing TO with FROM is non-trivial, overwrite *REPLACE with\n+   the result.  */\n+\n+static void\n+cp_genericize_init (tree *replace, tree from, tree to)\n+{\n+  if (TREE_CODE (from) == VEC_INIT_EXPR)\n+    {\n+      tree init = expand_vec_init_expr (to, from, tf_warning_or_error);\n+\n+      /* Make cp_gimplify_init_expr call replace_decl.  */\n+      *replace = fold_convert (void_type_node, init);\n+    }\n+  else if (flag_exceptions\n+\t   && TREE_CODE (from) == CONSTRUCTOR\n+\t   && TREE_SIDE_EFFECTS (from)\n+\t   && TYPE_HAS_NONTRIVIAL_DESTRUCTOR (TREE_TYPE (from)))\n+    {\n+      to = cp_stabilize_reference (to);\n+      replace_placeholders (from, to);\n+      *replace = split_nonconstant_init (to, from);\n+    }\n+}\n+\n+/* For an INIT_EXPR, replace the INIT_EXPR itself.  */\n+\n+static void\n+cp_genericize_init_expr (tree *stmt_p)\n+{\n+  tree to = TREE_OPERAND (*stmt_p, 0);\n+  tree from = TREE_OPERAND (*stmt_p, 1);\n+  if (SIMPLE_TARGET_EXPR_P (from)\n+      /* Return gets confused if we clobber its INIT_EXPR this soon.  */\n+      && TREE_CODE (to) != RESULT_DECL)\n+    from = TARGET_EXPR_INITIAL (from);\n+  cp_genericize_init (stmt_p, from, to);\n+}\n+\n+/* For a TARGET_EXPR, change the TARGET_EXPR_INITIAL.  We will need to use\n+   replace_decl later when we know what we're initializing.  */\n+\n+static void\n+cp_genericize_target_expr (tree *stmt_p)\n+{\n+  cp_genericize_init (&TARGET_EXPR_INITIAL (*stmt_p),\n+\t\t      TARGET_EXPR_INITIAL (*stmt_p),\n+\t\t      TARGET_EXPR_SLOT (*stmt_p));\n+}\n+\n /* Genericization context.  */\n \n struct cp_genericize_data\n@@ -1007,6 +1054,14 @@ cp_fold_r (tree *stmt_p, int *walk_subtrees, void *data)\n \t}\n       break;\n \n+    case INIT_EXPR:\n+      cp_genericize_init_expr (stmt_p);\n+      break;\n+\n+    case TARGET_EXPR:\n+      cp_genericize_target_expr (stmt_p);\n+      break;\n+\n     default:\n       break;\n     }"}, {"sha": "56e6d66153747b8132785a9d8abea3938f94cb7c", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f6bc28fc7dd86bd9e7408cbf28de1e973dd1eda/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f6bc28fc7dd86bd9e7408cbf28de1e973dd1eda/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=4f6bc28fc7dd86bd9e7408cbf28de1e973dd1eda", "patch": "@@ -8385,6 +8385,7 @@ extern tree fold_sizeof_expr\t\t\t(tree);\n extern void clear_cv_and_fold_caches\t\t(void);\n extern tree unshare_constructor\t\t\t(tree CXX_MEM_STAT_INFO);\n extern bool decl_implicit_constexpr_p\t\t(tree);\n+extern bool replace_decl\t\t\t(tree *, tree, tree);\n \n /* An RAII sentinel used to restrict constexpr evaluation so that it\n    doesn't do anything that causes extra DECL_UID generation.  */"}, {"sha": "4c1135ba386c22107b2886580d9df62db5f98b67", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f6bc28fc7dd86bd9e7408cbf28de1e973dd1eda/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f6bc28fc7dd86bd9e7408cbf28de1e973dd1eda/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=4f6bc28fc7dd86bd9e7408cbf28de1e973dd1eda", "patch": "@@ -737,12 +737,12 @@ build_cplus_new (tree type, tree init, tsubst_flags_t complain)\n    intialization as a proxy for the full array initialization to get things\n    marked as used and any appropriate diagnostics.\n \n-   Since we're deferring building the actual constructor calls until\n-   gimplification time, we need to build one now and throw it away so\n-   that the relevant constructor gets mark_used before cgraph decides\n-   what functions are needed.  Here we assume that init is either\n-   NULL_TREE, void_type_node (indicating value-initialization), or\n-   another array to copy.  */\n+   This used to be necessary because we were deferring building the actual\n+   constructor calls until gimplification time; now we only do it to set\n+   VEC_INIT_EXPR_IS_CONSTEXPR.\n+\n+   We assume that init is either NULL_TREE, void_type_node (indicating\n+   value-initialization), or another array to copy.  */\n \n static tree\n build_vec_init_elt (tree type, tree init, tsubst_flags_t complain)\n@@ -858,7 +858,8 @@ diagnose_non_constexpr_vec_init (tree expr)\n tree\n build_array_copy (tree init)\n {\n-  return build_vec_init_expr (TREE_TYPE (init), init, tf_warning_or_error);\n+  return get_target_expr (build_vec_init_expr\n+\t\t\t  (TREE_TYPE (init), init, tf_warning_or_error));\n }\n \n /* Build a TARGET_EXPR using INIT to initialize a new temporary of the"}, {"sha": "7e7fc7f9f481bf9c75ee240d66b0537bc95caba1", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f6bc28fc7dd86bd9e7408cbf28de1e973dd1eda/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f6bc28fc7dd86bd9e7408cbf28de1e973dd1eda/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=4f6bc28fc7dd86bd9e7408cbf28de1e973dd1eda", "patch": "@@ -1282,6 +1282,9 @@ digest_init_r (tree type, tree init, int nested, int flags,\n \t}\n     }\n \n+  if (SIMPLE_TARGET_EXPR_P (stripped_init))\n+    stripped_init = TARGET_EXPR_INITIAL (stripped_init);\n+\n   if (BRACE_ENCLOSED_INITIALIZER_P (stripped_init)\n       && !TYPE_NON_AGGREGATE_CLASS (type))\n     return process_init_constructor (type, stripped_init, nested, flags,"}, {"sha": "90dd8d70d63afad1024f3b6d0130266f7474a731", "filename": "gcc/testsuite/g++.dg/cpp0x/initlist116.C", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f6bc28fc7dd86bd9e7408cbf28de1e973dd1eda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist116.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f6bc28fc7dd86bd9e7408cbf28de1e973dd1eda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist116.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist116.C?ref=4f6bc28fc7dd86bd9e7408cbf28de1e973dd1eda", "patch": "@@ -0,0 +1,29 @@\n+// PR c++/66139\n+// { dg-do run { target c++11 } }\n+\n+int constructed = 0;\n+\n+class lock_guard_ext{\n+public:\n+  lock_guard_ext() { ++constructed; }\n+  ~lock_guard_ext() { --constructed; }\n+};\n+ \n+struct Access {\n+  lock_guard_ext lock;\n+  int value;\n+};\n+ \n+int t() {\n+  throw 0;\n+}\n+\n+Access foo1() {\n+  return { {}, t() };\n+}\n+ \n+int main () {\n+  try { foo1(); } catch (int) {}\n+  if (constructed != 0)\n+    __builtin_abort();\n+}"}, {"sha": "415a5de2dd1d35cb72b6585bed69a2ede347451e", "filename": "gcc/testsuite/g++.dg/cpp0x/initlist117.C", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f6bc28fc7dd86bd9e7408cbf28de1e973dd1eda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist117.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f6bc28fc7dd86bd9e7408cbf28de1e973dd1eda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist117.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist117.C?ref=4f6bc28fc7dd86bd9e7408cbf28de1e973dd1eda", "patch": "@@ -0,0 +1,40 @@\n+// PR c++/66139\n+// { dg-do run { target c++11 } }\n+\n+#include <initializer_list>\n+\n+int c, d;\n+\n+struct a\n+{\n+  a (int i) { if (i) throw i; c++; }\n+  ~a () { d++; }\n+};\n+\n+void check (void (*f) ())\n+{\n+  try\n+  {\n+    c = d = 0;\n+    f ();\n+  }\n+  catch (int)\n+  {\n+    if (c != 1 || d != 1)\n+      __builtin_abort ();\n+    return;\n+  }\n+  __builtin_abort ();\n+}\n+\n+int main ()\n+{\n+  struct s { a x, y; };\n+  check ([] { s t { 0, 1 }; });\n+  check ([] { s { 0, 1 }; });\n+  check ([] { a t[2] { 0, 1 }; });\n+  using array = a[2];\n+  check ([] { array { 0, 1 }; });\n+  check ([] { std::initializer_list <a> t { 0, 1 }; });\n+  check ([] { std::initializer_list <a> { 0, 1 }; });\n+}"}, {"sha": "4d1f4f3edfc9d7a19e000f39dae06afd34b4a030", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-eh.C", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f6bc28fc7dd86bd9e7408cbf28de1e973dd1eda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-eh.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f6bc28fc7dd86bd9e7408cbf28de1e973dd1eda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-eh.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-eh.C?ref=4f6bc28fc7dd86bd9e7408cbf28de1e973dd1eda", "patch": "@@ -0,0 +1,34 @@\n+// Test that we properly clean up if we get an exception in the middle of\n+// constructing the closure object.\n+\n+// { dg-do run }\n+// { dg-require-effective-target c++11 }\n+\n+struct A\n+{\n+  A() {}\n+  A(const A&) { throw 1; }\n+};\n+\n+int bs;\n+struct B\n+{\n+  B() { ++bs; }\n+  B(const B&) { ++bs; }\n+  ~B() { --bs; }\n+};\n+\n+int main()\n+{\n+  {\n+    B b1, b2;\n+    A a;\n+\n+    try\n+      {\n+\t[b1, a, b2]{ };\n+      }\n+    catch(...) {}\n+  }\n+  return bs;\n+}"}, {"sha": "68d0ed74c9a41e22ef59fc2fc0280a0ddba5ce6e", "filename": "gcc/testsuite/g++.dg/eh/aggregate1.C", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f6bc28fc7dd86bd9e7408cbf28de1e973dd1eda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Faggregate1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f6bc28fc7dd86bd9e7408cbf28de1e973dd1eda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Faggregate1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Faggregate1.C?ref=4f6bc28fc7dd86bd9e7408cbf28de1e973dd1eda", "patch": "@@ -0,0 +1,56 @@\n+// PR c++/52320\n+// { dg-do run }\n+\n+#if DEBUG\n+extern \"C\" int printf (const char *, ...);\n+#define FUNCTION_NAME __PRETTY_FUNCTION__\n+#define TRACE_FUNCTION printf (\"%p->%s\\n\", this, FUNCTION_NAME);\n+#else\n+#define TRACE_FUNCTION \n+#endif\n+int c,d;\n+#define TRACE_CTOR TRACE_FUNCTION ++c\n+#define TRACE_DTOR TRACE_FUNCTION ++d\n+\n+int throw_at = 0;\n+\n+struct A {\n+  A() { int i = c+1; if (i == throw_at) throw i; TRACE_CTOR; }\n+  A(int i) { if (i == throw_at) throw i; TRACE_CTOR; }\n+  A(const A&) { throw 10; }\n+  A &operator=(const A&) { throw 11; return *this; }\n+  ~A() { TRACE_DTOR; }\n+};\n+\n+int fails;\n+\n+void try_idx (int i)\n+{\n+#if DEBUG\n+  printf (\"trying %d\\n\", i);\n+#endif\n+  throw_at = i;\n+  c = d = 0;\n+  int t = 10;\n+  try {\n+    struct X {\n+      A e1[2], e2;\n+    }\n+    x2[3] = { { 1, 2, 3 }, { 4, 5, 6 } };\n+  } catch (int x) { t = x; }\n+  if (t != i || c != d || c != i-1)\n+    {\n+#if DEBUG\n+      printf (\"%d FAIL\\n\", i);\n+#endif\n+      ++fails;\n+    }\n+}\n+\n+int main()\n+{\n+  for (int i = 1; i <= 10; ++i)\n+    try_idx (i);\n+\n+  return fails;\n+}"}]}