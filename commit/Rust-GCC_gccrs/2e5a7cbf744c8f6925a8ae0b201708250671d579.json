{"sha": "2e5a7cbf744c8f6925a8ae0b201708250671d579", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmU1YTdjYmY3NDRjOGY2OTI1YThhZTBiMjAxNzA4MjUwNjcxZDU3OQ==", "commit": {"author": {"name": "Ramakrishna Upadrasta", "email": "Ramakrishna.Upadrasta@inria.fr", "date": "2009-11-25T05:02:04Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2009-11-25T05:02:04Z"}, "message": "graphite-sese-to-poly.c (write_alias_graph_to_ascii_dimacs): Fix Comment.\n\n2009-10-14  Ramakrishna Upadrasta <Ramakrishna.Upadrasta@inria.fr>\n\n\t* graphite-sese-to-poly.c (write_alias_graph_to_ascii_dimacs): Fix Comment.\n\t(write_alias_graph_to_ascii_dot): New.\n\t(write_alias_graph_to_ascii_ecc): Ditto.\n\t(partition_drs_to_sets): Add testing of optimality of current method which\n\tassigns alias numbers according to DFS Comopnent number.\n\tused as heuristic for the upcoming ECC algorithm.\n\t(build_scop_drs): Write to file also with the ecc and dot format.\n\nFrom-SVN: r154577", "tree": {"sha": "441a5767d45eafc55761e1275d0f124c8a10c1f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/441a5767d45eafc55761e1275d0f124c8a10c1f1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2e5a7cbf744c8f6925a8ae0b201708250671d579", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e5a7cbf744c8f6925a8ae0b201708250671d579", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e5a7cbf744c8f6925a8ae0b201708250671d579", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e5a7cbf744c8f6925a8ae0b201708250671d579/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1e82de2a59f1cd2bc5faf3d606900191997136f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e82de2a59f1cd2bc5faf3d606900191997136f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e82de2a59f1cd2bc5faf3d606900191997136f2"}], "stats": {"total": 167, "additions": 149, "deletions": 18}, "files": [{"sha": "1a71d65dce054c97c41c595b58ed30abfe7fa89d", "filename": "gcc/ChangeLog.graphite", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e5a7cbf744c8f6925a8ae0b201708250671d579/gcc%2FChangeLog.graphite", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e5a7cbf744c8f6925a8ae0b201708250671d579/gcc%2FChangeLog.graphite", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog.graphite?ref=2e5a7cbf744c8f6925a8ae0b201708250671d579", "patch": "@@ -1,3 +1,13 @@\n+2009-10-14  Ramakrishna Upadrasta <Ramakrishna.Upadrasta@inria.fr>\n+\n+\t* graphite-sese-to-poly.c (write_alias_graph_to_ascii_dimacs): Fix Comment.\n+\t(write_alias_graph_to_ascii_dot): New.\n+\t(write_alias_graph_to_ascii_ecc): Ditto.\n+\t(partition_drs_to_sets): Add testing of optimality of current method which\n+\tassigns alias numbers according to DFS Comopnent number.\n+\tused as heuristic for the upcoming ECC algorithm.\n+\t(build_scop_drs): Write to file also with the ecc and dot format.\n+\n 2009-10-13  Sebastian Pop  <sebastian.pop@amd.com>\n \n \t* gfortran.dg/graphite/interchange-1.f: XFail."}, {"sha": "014557f03e4abc8001b547256bd6bc4c5bbbfb6e", "filename": "gcc/graphite-sese-to-poly.c", "status": "modified", "additions": 139, "deletions": 18, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e5a7cbf744c8f6925a8ae0b201708250671d579/gcc%2Fgraphite-sese-to-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e5a7cbf744c8f6925a8ae0b201708250671d579/gcc%2Fgraphite-sese-to-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-sese-to-poly.c?ref=2e5a7cbf744c8f6925a8ae0b201708250671d579", "patch": "@@ -1710,7 +1710,7 @@ build_poly_dr (data_reference_p dr, poly_bb_p pbb)\n \t       dr, DR_NUM_DIMENSIONS (dr));\n }\n \n-/* Write to FILE the alias graph of data references with DIMACS format.  */\n+/* Write to FILE the alias graph of data references in DIMACS format.  */\n \n static inline bool\n write_alias_graph_to_ascii_dimacs (FILE *file, char *comment,\n@@ -1744,31 +1744,134 @@ write_alias_graph_to_ascii_dimacs (FILE *file, char *comment,\n   return true;\n }\n \n-static void\n+/* Write to FILE the alias graph of data references in DOT format.  */\n+\n+static inline bool\n+write_alias_graph_to_ascii_dot (FILE *file, char *comment,\n+\t\t\t\tVEC (data_reference_p, heap) *drs)\n+{\n+  int num_vertex = VEC_length (data_reference_p, drs);\n+  data_reference_p dr1, dr2;\n+  int i, j;\n+\n+  if (num_vertex == 0)\n+    return true;\n+\n+  fprintf (file, \"$\\n\");\n+\n+  if (comment)\n+    fprintf (file, \"c %s\\n\", comment);\n+\n+  /* First print all the vertices.  */\n+  for (i = 0; VEC_iterate (data_reference_p, drs, i, dr1); i++)\n+    fprintf (file, \"n%d;\\n\", i);\n+\n+  for (i = 0; VEC_iterate (data_reference_p, drs, i, dr1); i++)\n+    for (j = i + 1; VEC_iterate (data_reference_p, drs, j, dr2); j++)\n+      if (dr_may_alias_p (dr1, dr2))\n+\tfprintf (file, \"n%d n%d\\n\", i, j);\n+\n+  return true;\n+}\n+\n+/* Write to FILE the alias graph of data references in ECC format.  */\n+\n+static inline bool\n+write_alias_graph_to_ascii_ecc (FILE *file, char *comment,\n+\t\t\t\tVEC (data_reference_p, heap) *drs)\n+{\n+  int num_vertex = VEC_length (data_reference_p, drs);\n+  data_reference_p dr1, dr2;\n+  int i, j;\n+\n+  if (num_vertex == 0)\n+    return true;\n+\n+  fprintf (file, \"$\\n\");\n+\n+  if (comment)\n+    fprintf (file, \"c %s\\n\", comment);\n+\n+  for (i = 0; VEC_iterate (data_reference_p, drs, i, dr1); i++)\n+    for (j = i + 1; VEC_iterate (data_reference_p, drs, j, dr2); j++)\n+      if (dr_may_alias_p (dr1, dr2))\n+\tfprintf (file, \"%d %d\\n\", i, j);\n+\n+  return true;\n+}\n+\n+\n+/* Uses DFS component number as representative of alias-sets. Also tests for\n+   optimality by verifying if every connected component is a clique. Returns\n+   true (1) if the above test is true, and false (0) otherwise.  */\n+\n+static int\n partition_drs_to_sets (VEC (data_reference_p, heap) *drs, int choice,\n \t\t       bool (* edge_exist_p) (const struct data_reference *,\n \t\t\t\t\t      const struct data_reference *))\n {\n-  int num_vertex = VEC_length (data_reference_p, drs);\n-  struct graph *g = new_graph (num_vertex);\n+\n+  int num_vertices = VEC_length (data_reference_p, drs);\n+  struct graph *g = new_graph (num_vertices);\n   data_reference_p dr1, dr2;\n   int i, j;\n-  int num_component;\n-  int *queue;\n+  int num_connected_components;\n+  int v_indx1, v_indx2, num_vertices_in_component;\n+  int *all_vertices;\n+  int *vertices;\n+  struct graph_edge *e;\n+  int this_component_is_clique, all_components_are_cliques;\n \n   for (i = 0; VEC_iterate (data_reference_p, drs, i, dr1); i++)\n-    for (j = i + 1; VEC_iterate (data_reference_p, drs, j, dr2); j++)\n-      if ((*edge_exist_p) (dr1, dr2))\n+    for (j = i+1; VEC_iterate (data_reference_p, drs, j, dr2); j++)\n+      if (edge_exist_p (dr1, dr2))\n \t{\n \t  add_edge (g, i, j);\n \t  add_edge (g, j, i);\n \t}\n \n-  queue = XNEWVEC (int, num_vertex);\n-  for (i = 0; i < num_vertex; i++)\n-    queue[i] = i;\n+  all_vertices = XNEWVEC (int, num_vertices);\n+  vertices = XNEWVEC (int, num_vertices);\n+  for (i = 0; i < num_vertices; i++)\n+    all_vertices[i] = i;\n+\n+  num_connected_components = graphds_dfs (g, all_vertices, num_vertices, NULL, true, NULL);\n \n-  num_component = graphds_dfs (g, queue, num_vertex, NULL, true, NULL);\n+  /* Verify if the DFS numbering results in optimal solution.  */\n+  for (i = 0; i < num_connected_components; i++)\n+    {\n+      num_vertices_in_component = 0;\n+      /* Get all vertices whose DFS component number is the same as i.  */\n+      for (j = 0; j < num_vertices; j++)\n+\tif (g->vertices[j].component == i)\n+\t  vertices[num_vertices_in_component++] = j;\n+\n+      /* Now test if the vertices in 'vertices' form a clique, by testing\n+\t for edges among each pair.  */\n+      this_component_is_clique = 1;\n+      for (v_indx1 = 0; v_indx1 < num_vertices_in_component; v_indx1++)\n+\t{\n+\t  for (v_indx2 = v_indx1+1; v_indx2 < num_vertices_in_component; v_indx2++)\n+\t    {\n+\t      /* Check if the two vertices are connected by iterating\n+\t\t through all the edges which have one of these are source.  */\n+\t      e = g->vertices[vertices[v_indx2]].pred;\n+\t      while (e)\n+\t\t{\n+\t\t  if (e->src == vertices[v_indx1])\n+\t\t    break;\n+\t\t  e = e->pred_next;\n+\t\t}\n+\t      if (!e)\n+\t\t{\n+\t\t  this_component_is_clique = 0;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t  if (!this_component_is_clique)\n+\t    all_components_are_cliques = 0;\n+\t}\n+    }\n \n   for (i = 0; i < g->n_vertices; i++)\n     {\n@@ -1778,8 +1881,10 @@ partition_drs_to_sets (VEC (data_reference_p, heap) *drs, int choice,\n       ((int *)(dr->aux))[choice] = g->vertices[i].component + 1;\n     }\n \n-  free (queue);\n+  free (all_vertices);\n+  free (vertices);\n   free_graph (g);\n+  return all_components_are_cliques;\n }\n \n static bool\n@@ -1841,15 +1946,31 @@ build_scop_drs (scop_p scop)\n #if 0\n   {\n     char comment[100];\n-    FILE *file;\n+    FILE *file_dimacs, *file_ecc, *file_dot;\n \n-    file = fopen (\"/tmp/dr_alias_graph\", \"ab\");\n-    if (file)\n+    file_dimacs = fopen (\"/tmp/dr_alias_graph_dimacs\", \"ab\");\n+    file_ecc = fopen (\"/tmp/dr_alias_graph_ecc\", \"ab\");\n+    file_dot = fopen (\"/tmp/dr_alias_graph_dot\", \"ab\");\n+    if (file_dimacs)\n+      {\n+\tsnprintf (comment, sizeof (comment), \"%s %s\", main_input_filename,\n+\t\t  current_function_name ());\n+\twrite_alias_graph_to_ascii_dimacs (file_dimacs, comment, drs);\n+\tfclose (file_dimacs);\n+      }\n+    if (file_ecc)\n+      {\n+\tsnprintf (comment, sizeof (comment), \"%s %s\", main_input_filename,\n+\t\t  current_function_name ());\n+\twrite_alias_graph_to_ascii_ecc (file_ecc, comment, drs);\n+\tfclose (file_ecc);\n+      }\n+    if (file_dot)\n       {\n \tsnprintf (comment, sizeof (comment), \"%s %s\", main_input_filename,\n \t\t  current_function_name ());\n-\twrite_alias_graph_to_ascii_dimacs (file, comment, drs);\n-\tfclose (file);\n+\twrite_alias_graph_to_ascii_dot (file_dot, comment, drs);\n+\tfclose (file_dot);\n       }\n   }\n #endif"}]}