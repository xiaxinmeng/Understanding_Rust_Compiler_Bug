{"sha": "cea83351a2a023a07ba5577cd91b5edcd690299b", "node_id": "C_kwDOANBUbNoAKGNlYTgzMzUxYTJhMDIzYTA3YmE1NTc3Y2Q5MWI1ZWRjZDY5MDI5OWI", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-09-30T10:50:38Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-10-11T13:38:11Z"}, "message": "[Ada] Fix internal error on fixed-point divide, multiply and scaling\n\ngcc/ada/\n\n\t* exp_fixd.adb (Get_Size_For_Value): New function returning a size\n\tsuitable for a non-negative integer value.\n\t(Get_Type_For_Size): New function returning a standard type suitable\n\tfor a size.\n\t(Build_Divide): Call both functions to compute the result type, but\n\tmake sure to pass a non-negative value to the first.\n\t(Build_Multiply): Likewise.\n\t(Do_Multiply_Fixed_Universal): Minor consistency tweak.\n\t(Integer_Literal): Call both functions to compute the type.", "tree": {"sha": "7d9bdec7801de0dfdbcb69d3c85ece87dfbc560d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7d9bdec7801de0dfdbcb69d3c85ece87dfbc560d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cea83351a2a023a07ba5577cd91b5edcd690299b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cea83351a2a023a07ba5577cd91b5edcd690299b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cea83351a2a023a07ba5577cd91b5edcd690299b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cea83351a2a023a07ba5577cd91b5edcd690299b/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "939b3a2ac672ec5792601ef096049302432d4689", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/939b3a2ac672ec5792601ef096049302432d4689", "html_url": "https://github.com/Rust-GCC/gccrs/commit/939b3a2ac672ec5792601ef096049302432d4689"}], "stats": {"total": 171, "additions": 92, "deletions": 79}, "files": [{"sha": "94a61df4511215440a47a1c84fb6b6620b2d1cf7", "filename": "gcc/ada/exp_fixd.adb", "status": "modified", "additions": 92, "deletions": 79, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cea83351a2a023a07ba5577cd91b5edcd690299b/gcc%2Fada%2Fexp_fixd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cea83351a2a023a07ba5577cd91b5edcd690299b/gcc%2Fada%2Fexp_fixd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_fixd.adb?ref=cea83351a2a023a07ba5577cd91b5edcd690299b", "patch": "@@ -190,6 +190,15 @@ package body Exp_Fixd is\n    --  The expression returned is neither analyzed nor resolved. The Etype\n    --  of the result is properly set (to Universal_Real).\n \n+   function Get_Size_For_Value (V : Uint) return Pos;\n+   --  Given a non-negative universal integer value, return the size of a small\n+   --  signed integer type covering -V .. V, or Pos'Max if no such type exists.\n+\n+   function Get_Type_For_Size (Siz : Pos; Force : Boolean) return Entity_Id;\n+   --  Return the smallest signed integer type containing at least Siz bits.\n+   --  If no such type exists, return Empty if Force is False or the largest\n+   --  signed integer type if Force is True.\n+\n    function Integer_Literal\n      (N        : Node_Id;\n       V        : Uint;\n@@ -324,7 +333,6 @@ package body Exp_Fixd is\n       Right_Type  : constant Entity_Id  := Base_Type (Etype (R));\n       Left_Size   : Int;\n       Right_Size  : Int;\n-      Rsize       : Int;\n       Result_Type : Entity_Id;\n       Rnode       : Node_Id;\n \n@@ -354,20 +362,17 @@ package body Exp_Fixd is\n          --  the effective size of an operand is the RM_Size of the operand.\n          --  But a special case arises with operands whose size is known at\n          --  compile time. In this case, we can use the actual value of the\n-         --  operand to get its size if it would fit in signed 8/16/32 bits.\n+         --  operand to get a size if it would fit in a small signed integer.\n \n          Left_Size := UI_To_Int (RM_Size (Left_Type));\n \n          if Compile_Time_Known_Value (L) then\n             declare\n-               Val : constant Uint := Expr_Value (L);\n+               Siz : constant Int :=\n+                       Get_Size_For_Value (UI_Abs (Expr_Value (L)));\n             begin\n-               if Val < Uint_2 ** 7 then\n-                  Left_Size := 8;\n-               elsif Val < Uint_2 ** 15 then\n-                  Left_Size := 16;\n-               elsif Val < Uint_2 ** 31 then\n-                  Left_Size := 32;\n+               if Siz < Left_Size then\n+                  Left_Size := Siz;\n                end if;\n             end;\n          end if;\n@@ -376,35 +381,19 @@ package body Exp_Fixd is\n \n          if Compile_Time_Known_Value (R) then\n             declare\n-               Val : constant Uint := Expr_Value (R);\n+               Siz : constant Int :=\n+                       Get_Size_For_Value (UI_Abs (Expr_Value (R)));\n             begin\n-               if Val <= Int'(2 ** 7) then\n-                  Right_Size := 8;\n-               elsif Val <= Int'(2 ** 15) then\n-                  Right_Size := 16;\n+               if Siz < Right_Size then\n+                  Right_Size := Siz;\n                end if;\n             end;\n          end if;\n \n          --  Do the operation using the longer of the two sizes\n \n-         Rsize := Int'Max (Left_Size, Right_Size);\n-\n-         if Rsize <= 8 then\n-            Result_Type := Standard_Integer_8;\n-\n-         elsif Rsize <= 16 then\n-            Result_Type := Standard_Integer_16;\n-\n-         elsif Rsize <= 32 then\n-            Result_Type := Standard_Integer_32;\n-\n-         elsif Rsize <= 64 or else System_Max_Integer_Size < 128 then\n-            Result_Type := Standard_Integer_64;\n-\n-         else\n-            Result_Type := Standard_Integer_128;\n-         end if;\n+         Result_Type :=\n+           Get_Type_For_Size (Int'Max (Left_Size, Right_Size), Force => True);\n \n          Rnode :=\n             Make_Op_Divide (Loc,\n@@ -664,7 +653,6 @@ package body Exp_Fixd is\n       Right_Type  : constant Entity_Id  := Etype (R);\n       Left_Size   : Int;\n       Right_Size  : Int;\n-      Rsize       : Int;\n       Result_Type : Entity_Id;\n       Rnode       : Node_Id;\n \n@@ -697,20 +685,17 @@ package body Exp_Fixd is\n          --  the effective size of an operand is the RM_Size of the operand.\n          --  But a special case arises with operands whose size is known at\n          --  compile time. In this case, we can use the actual value of the\n-         --  operand to get its size if it would fit in signed 8/16/32 bits.\n+         --  operand to get a size if it would fit in a small signed integer.\n \n          Left_Size := UI_To_Int (RM_Size (Left_Type));\n \n          if Compile_Time_Known_Value (L) then\n             declare\n-               Val : constant Uint := Expr_Value (L);\n+               Siz : constant Int :=\n+                       Get_Size_For_Value (UI_Abs (Expr_Value (L)));\n             begin\n-               if Val < Uint_2 ** 7 then\n-                  Left_Size := 8;\n-               elsif Val < Uint_2 ** 15 then\n-                  Left_Size := 16;\n-               elsif Val < Uint_2 ** 31 then\n-                  Left_Size := 32;\n+               if Siz < Left_Size then\n+                  Left_Size := Siz;\n                end if;\n             end;\n          end if;\n@@ -719,36 +704,20 @@ package body Exp_Fixd is\n \n          if Compile_Time_Known_Value (R) then\n             declare\n-               Val : constant Uint := Expr_Value (R);\n+               Siz : constant Int :=\n+                       Get_Size_For_Value (UI_Abs (Expr_Value (R)));\n             begin\n-               if Val <= Int'(2 ** 7) then\n-                  Right_Size := 8;\n-               elsif Val <= Int'(2 ** 15) then\n-                  Right_Size := 16;\n+               if Siz < Right_Size then\n+                  Right_Size := Siz;\n                end if;\n             end;\n          end if;\n \n          --  Now the result size must be at least the sum of the two sizes,\n          --  to accommodate all possible results.\n \n-         Rsize := Left_Size + Right_Size;\n-\n-         if Rsize <= 8 then\n-            Result_Type := Standard_Integer_8;\n-\n-         elsif Rsize <= 16 then\n-            Result_Type := Standard_Integer_16;\n-\n-         elsif Rsize <= 32 then\n-            Result_Type := Standard_Integer_32;\n-\n-         elsif Rsize <= 64 or else System_Max_Integer_Size < 128 then\n-            Result_Type := Standard_Integer_64;\n-\n-         else\n-            Result_Type := Standard_Integer_128;\n-         end if;\n+         Result_Type :=\n+           Get_Type_For_Size (Left_Size + Right_Size, Force => True);\n \n          Rnode :=\n             Make_Op_Multiply (Loc,\n@@ -1542,7 +1511,7 @@ package body Exp_Fixd is\n \n       else\n          Lit_Int := Integer_Literal (N, Frac_Den, UR_Is_Negative (Frac));\n-         Lit_K   := Integer_Literal (N, Frac_Num);\n+         Lit_K   := Integer_Literal (N, Frac_Num, False);\n \n          if Present (Lit_Int) and then Present (Lit_K) then\n             Set_Result (N, Build_Scaled_Divide (N, Left, Lit_K, Lit_Int));\n@@ -2422,6 +2391,64 @@ package body Exp_Fixd is\n       return Build_Conversion (N, Universal_Real, N);\n    end Fpt_Value;\n \n+   ------------------------\n+   -- Get_Size_For_Value --\n+   ------------------------\n+\n+   function Get_Size_For_Value (V : Uint) return Pos is\n+   begin\n+      pragma Assert (V >= Uint_0);\n+\n+      if V < Uint_2 ** 7 then\n+         return 8;\n+\n+      elsif V < Uint_2 ** 15 then\n+         return 16;\n+\n+      elsif V < Uint_2 ** 31 then\n+         return 32;\n+\n+      elsif V < Uint_2 ** 63 then\n+         return 64;\n+\n+      elsif V < Uint_2 ** 127 then\n+         return 128;\n+\n+      else\n+         return Pos'Last;\n+      end if;\n+   end Get_Size_For_Value;\n+\n+   -----------------------\n+   -- Get_Type_For_Size --\n+   -----------------------\n+\n+   function Get_Type_For_Size (Siz : Pos; Force : Boolean) return Entity_Id is\n+   begin\n+      if Siz <= 8 then\n+         return Standard_Integer_8;\n+\n+      elsif Siz <= 16 then\n+         return Standard_Integer_16;\n+\n+      elsif Siz <= 32 then\n+         return Standard_Integer_32;\n+\n+      elsif Siz <= 64\n+        or else (Force and then System_Max_Integer_Size < 128)\n+      then\n+         return Standard_Integer_64;\n+\n+      elsif (Siz <= 128 and then System_Max_Integer_Size = 128)\n+        or else Force\n+      then\n+         return Standard_Integer_128;\n+\n+      else\n+         return Empty;\n+      end if;\n+   end Get_Type_For_Size;\n+\n    ---------------------\n    -- Integer_Literal --\n    ---------------------\n@@ -2435,22 +2462,8 @@ package body Exp_Fixd is\n       L : Node_Id;\n \n    begin\n-      if V < Uint_2 ** 7 then\n-         T := Standard_Integer_8;\n-\n-      elsif V < Uint_2 ** 15 then\n-         T := Standard_Integer_16;\n-\n-      elsif V < Uint_2 ** 31 then\n-         T := Standard_Integer_32;\n-\n-      elsif V < Uint_2 ** 63 then\n-         T := Standard_Integer_64;\n-\n-      elsif V < Uint_2 ** 127 and then System_Max_Integer_Size = 128 then\n-         T := Standard_Integer_128;\n-\n-      else\n+      T := Get_Type_For_Size (Get_Size_For_Value (V), Force => False);\n+      if No (T) then\n          return Empty;\n       end if;\n "}]}