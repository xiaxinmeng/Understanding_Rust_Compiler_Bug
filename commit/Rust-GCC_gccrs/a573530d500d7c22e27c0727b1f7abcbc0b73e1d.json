{"sha": "a573530d500d7c22e27c0727b1f7abcbc0b73e1d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTU3MzUzMGQ1MDBkN2MyMmUyN2MwNzI3YjFmN2FiY2JjMGI3M2UxZA==", "commit": {"author": {"name": "Nikhil Benesch", "email": "nikhil.benesch@gmail.com", "date": "2020-10-26T17:48:32Z"}, "committer": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2020-10-26T22:04:16Z"}, "message": "syscall: import additional BSD-specific syscall wrappers\n\nImport additional code from upstream for handing system\ncalls on BSD systems. This makes the syscall package on\nNetBSD complete enough to compile the standard library.\n\nUpdates golang/go#38538.\n\nReviewed-on: https://go-review.googlesource.com/c/gofrontend/+/265123", "tree": {"sha": "1c866623421dc43728e68c0269304bc96bca05e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1c866623421dc43728e68c0269304bc96bca05e4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a573530d500d7c22e27c0727b1f7abcbc0b73e1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a573530d500d7c22e27c0727b1f7abcbc0b73e1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a573530d500d7c22e27c0727b1f7abcbc0b73e1d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a573530d500d7c22e27c0727b1f7abcbc0b73e1d/comments", "author": {"login": "benesch", "id": 882976, "node_id": "MDQ6VXNlcjg4Mjk3Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/882976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/benesch", "html_url": "https://github.com/benesch", "followers_url": "https://api.github.com/users/benesch/followers", "following_url": "https://api.github.com/users/benesch/following{/other_user}", "gists_url": "https://api.github.com/users/benesch/gists{/gist_id}", "starred_url": "https://api.github.com/users/benesch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/benesch/subscriptions", "organizations_url": "https://api.github.com/users/benesch/orgs", "repos_url": "https://api.github.com/users/benesch/repos", "events_url": "https://api.github.com/users/benesch/events{/privacy}", "received_events_url": "https://api.github.com/users/benesch/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "48722d158cbf692c24025e345ecbbbb570f66aa5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48722d158cbf692c24025e345ecbbbb570f66aa5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48722d158cbf692c24025e345ecbbbb570f66aa5"}], "stats": {"total": 143, "additions": 142, "deletions": 1}, "files": [{"sha": "c3a45c8a9591490d695e7ad1645c74c568005e0c", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a573530d500d7c22e27c0727b1f7abcbc0b73e1d/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a573530d500d7c22e27c0727b1f7abcbc0b73e1d/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=a573530d500d7c22e27c0727b1f7abcbc0b73e1d", "patch": "@@ -1,4 +1,4 @@\n-28f3df468666787f83f94220312383a7c267a8ce\n+66657f88f820f2b0cab3c1c0a7d8b7f8923af7fb\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "f13d3bcbe161ac327ec297f135c82d471a5ebdd1", "filename": "libgo/go/syscall/libcall_bsd.go", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a573530d500d7c22e27c0727b1f7abcbc0b73e1d/libgo%2Fgo%2Fsyscall%2Flibcall_bsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a573530d500d7c22e27c0727b1f7abcbc0b73e1d/libgo%2Fgo%2Fsyscall%2Flibcall_bsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Flibcall_bsd.go?ref=a573530d500d7c22e27c0727b1f7abcbc0b73e1d", "patch": "@@ -0,0 +1,113 @@\n+// Copyright 2020 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build darwin dragonfly freebsd netbsd openbsd solaris\n+\n+// BSD library calls.\n+\n+package syscall\n+\n+import (\n+\t\"unsafe\"\n+)\n+\n+//sys\tsysctl(mib []_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error)\n+//sysctl(mib *_C_int, miblen uintptr, old *byte, oldlen *uintptr, new *byte, newlen uintptr) _C_int\n+\n+//sysnb raw_ptrace(request int, pid int, addr uintptr, data uintptr) (err Errno)\n+//ptrace(request _C_int, pid Pid_t, addr *byte, data _C_int) _C_int\n+\n+//sys\tpaccept(fd int, rsa *RawSockaddrAny, addrlen *Socklen_t, sigmask *_sigset_t, flags int) (nfd int, err error)\n+//paccept(s _C_int, rsa *RawSockaddrAny, addrlen *Socklen_t, sigmask *_sigset_t, flags int) _C_int\n+\n+//sys\tFlock(fd int, how int) (err error)\n+//flock(fd _C_int, how _C_int) _C_int\n+\n+func ReadDirent(fd int, buf []byte) (n int, err error) {\n+\t// Final argument is (basep *uintptr) and the syscall doesn't take nil.\n+\t// 64 bits should be enough. (32 bits isn't even on 386). Since the\n+\t// actual system call is getdirentries64, 64 is a good guess.\n+\t// TODO(rsc): Can we use a single global basep for all calls?\n+\tvar base = (*uintptr)(unsafe.Pointer(new(uint64)))\n+\treturn Getdirentries(fd, buf, base)\n+}\n+\n+func Accept4(fd, flags int) (nfd int, sa Sockaddr, err error) {\n+\tvar rsa RawSockaddrAny\n+\tvar len Socklen_t = SizeofSockaddrAny\n+\tnfd, err = paccept(fd, &rsa, &len, nil, flags)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tif len > SizeofSockaddrAny {\n+\t\tpanic(\"RawSockaddrAny too small\")\n+\t}\n+\tsa, err = anyToSockaddr(&rsa)\n+\tif err != nil {\n+\t\tClose(nfd)\n+\t\tnfd = 0\n+\t}\n+\treturn\n+}\n+\n+//sysnb\tpipe2(p *[2]_C_int, flags int) (err error)\n+//pipe2(p *[2]_C_int, flags _C_int) _C_int\n+func Pipe2(p []int, flags int) (err error) {\n+\tif len(p) != 2 {\n+\t\treturn EINVAL\n+\t}\n+\tvar pp [2]_C_int\n+\terr = pipe2(&pp, flags)\n+\tp[0] = int(pp[0])\n+\tp[1] = int(pp[1])\n+\treturn\n+}\n+\n+func Sysctl(name string) (value string, err error) {\n+\t// Translate name to mib number.\n+\tmib, err := nametomib(name)\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\n+\t// Find size.\n+\tn := uintptr(0)\n+\tif err = sysctl(mib, nil, &n, nil, 0); err != nil {\n+\t\treturn \"\", err\n+\t}\n+\tif n == 0 {\n+\t\treturn \"\", nil\n+\t}\n+\n+\t// Read into buffer of that size.\n+\tbuf := make([]byte, n)\n+\tif err = sysctl(mib, &buf[0], &n, nil, 0); err != nil {\n+\t\treturn \"\", err\n+\t}\n+\n+\t// Throw away terminating NUL.\n+\tif n > 0 && buf[n-1] == '\\x00' {\n+\t\tn--\n+\t}\n+\treturn string(buf[0:n]), nil\n+}\n+\n+func SysctlUint32(name string) (value uint32, err error) {\n+\t// Translate name to mib number.\n+\tmib, err := nametomib(name)\n+\tif err != nil {\n+\t\treturn 0, err\n+\t}\n+\n+\t// Read into buffer of that size.\n+\tn := uintptr(4)\n+\tbuf := make([]byte, 4)\n+\tif err = sysctl(mib, &buf[0], &n, nil, 0); err != nil {\n+\t\treturn 0, err\n+\t}\n+\tif n != 4 {\n+\t\treturn 0, EIO\n+\t}\n+\treturn *(*uint32)(unsafe.Pointer(&buf[0])), nil\n+}"}, {"sha": "c3a79e3275c090d474e8f95e95f53ff44054ef89", "filename": "libgo/go/syscall/syscall_netbsd.go", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a573530d500d7c22e27c0727b1f7abcbc0b73e1d/libgo%2Fgo%2Fsyscall%2Fsyscall_netbsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a573530d500d7c22e27c0727b1f7abcbc0b73e1d/libgo%2Fgo%2Fsyscall%2Fsyscall_netbsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsyscall_netbsd.go?ref=a573530d500d7c22e27c0727b1f7abcbc0b73e1d", "patch": "@@ -18,6 +18,34 @@ func direntNamlen(buf []byte) (uint64, bool) {\n \treturn readInt(buf, unsafe.Offsetof(Dirent{}.Namlen), unsafe.Sizeof(Dirent{}.Namlen))\n }\n \n+//sys\tGetdents(fd int, buf []byte) (n int, err error)\n+//getdents(fd _C_int, buf *byte, nbytes uintptr) _C_int\n+\n+func Getdirentries(fd int, buf []byte, basep *uintptr) (n int, err error) {\n+\tn, err = Getdents(fd, buf)\n+\tif err != nil || basep == nil {\n+\t\treturn\n+\t}\n+\n+\tvar off int64\n+\toff, err = Seek(fd, 0, 1 /* SEEK_CUR */)\n+\tif err != nil {\n+\t\t*basep = ^uintptr(0)\n+\t\treturn\n+\t}\n+\t*basep = uintptr(off)\n+\tif unsafe.Sizeof(*basep) == 8 {\n+\t\treturn\n+\t}\n+\tif off>>32 != 0 {\n+\t\t// We can't stuff the offset back into a uintptr, so any\n+\t\t// future calls would be suspect. Generate an error.\n+\t\t// EIO is allowed by getdirentries.\n+\t\terr = EIO\n+\t}\n+\treturn\n+}\n+\n func sysctlNodes(mib []_C_int) (nodes []Sysctlnode, err error) {\n \tvar olen uintptr\n "}]}