{"sha": "cf22909ceee710ab2f61b4d689b02cff8d62ec79", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2YyMjkwOWNlZWU3MTBhYjJmNjFiNGQ2ODliMDJjZmY4ZDYyZWM3OQ==", "commit": {"author": {"name": "Kriang Lerdsuwanakij", "email": "lerdsuwa@users.sourceforge.net", "date": "2003-01-14T13:40:53Z"}, "committer": {"name": "Kriang Lerdsuwanakij", "email": "lerdsuwa@gcc.gnu.org", "date": "2003-01-14T13:40:53Z"}, "message": "config-lang.in: Add semantics.c to gtfiles.\n\n\t* config-lang.in: Add semantics.c to gtfiles.\n\t* cp-tree.h (flagged_type_tree_s): Remove lookups field.\n\t(saved_scope): Likewise.\n\t(type_lookups): Remove.\n\t(deferred_access): New structure.\n\t(type_access_control): Remove.\n\t(save_type_access_control): Likewise.\n\t(reset_type_access_control): Likewise.\n\t(decl_type_access_control): Likewise.\n\t(push_deferring_access_checks): Declare.\n\t(resume_deferring_access_checks): Likewise.\n\t(stop_deferring_access_checks): Likewise.\n\t(pop_deferring_access_checks): Likewise.\n\t(get_deferred_access_checks): Likewise.\n\t(pop_to_parent_deferring_access_checks): Likewise.\n\t(perform_deferred_access_checks): Likewise.\n\t(perform_or_defer_access_check): Likewise.\n\t* decl.c (make_typename_type): Use perform_or_defer_access_check.\n\t(make_unbound_class_template): Likewise.\n\t(grokdeclarator): Don't call decl_type_access_control.\n\t* parser.c (cp_parser_context): Remove deferred_access_checks\n\tand deferring_access_checks_p fields.\n\t(cp_parser_context_new): Adjust.\n\t(cp_parser): Remove access_checks_lists.\n\t(cp_parser_defer_access_check): Remove.\n\t(cp_parser_start_deferring_access_checks): Remove.\n\t(cp_parser_stop_deferring_access_checks): Remove.\n\t(cp_parser_perform_deferred_access_checks): Remove.\n\t(cp_parser_nested_name_specifier_opt): Use new deferred access\n\tfunctions.\n\t(cp_parser_simple_declaration): Likewise.\n\t(cp_parser_template_id): Likewise.\n\t(cp_parser_function_definition): Likewise.\n\t(cp_parser_class_specifier): Likewise.\n\t(cp_parser_lookup_name): Likewise.\n\t(cp_parser_single_declaration): Likewise.\n\t(cp_parser_pre_parsed_nested_name_specifier): Likewise.\n\t(cp_parser_parse_tentatively): Likewise.\n\t(cp_parser_parse_definitely): Likewise.\n\t(yyparse): Likewise.\n\t(cp_parser_init_declarator): Remove access_checks parameter.\n\tUse new deferred access functions.\n\t(cp_parser_function_definition_from_specifiers_and_declarator):\n\tLikewise.\n\t(cp_parser_class_head): Remove deferring_access_checks_p and\n\tsaved_access_checks parameters.  Use new deferred access functions.\n\t(cp_parser_member_specification_opt): Don't call\n\treset_type_access_control.\n\t* search.c (type_access_control): Remove.\n\t* semantics.c: Include \"gt-cp-semantics.h\".\n\t(deferred_type_access_control): Remove.\n\t(deferred_access_stack): New variable.\n\t(deferred_access_free_list): Likewise.\n\t(push_deferring_access_checks): New function.\n\t(resume_deferring_access_checks): Likewise.\n\t(stop_deferring_access_checks): Likewise.\n\t(pop_deferring_access_checks): Likewise.\n\t(get_deferred_access_checks): Likewise.\n\t(pop_to_parent_deferring_access_checks): Likewise.\n\t(perform_deferred_access_checks): New function, adapted from\n\tcp_parser_perform_deferred_access_checks.\n\t(perform_or_defer_access_check): New function, adapted from\n\tcp_parser_defer_access_check.\n\t(current_type_lookups): Remove.\n\t(deferred_type_access_control): Likewise.\n\t(decl_type_access_control): Likewise.\n\t(save_type_access_control): Likewise.\n\t(reset_type_access_control): Likewise.\n\t(begin_function_definition): Adjust.\n\t(begin_class_definiton): Likewise.\n\nFrom-SVN: r61283", "tree": {"sha": "90148a1690538fe0373d3e426aeda784a80a6a4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/90148a1690538fe0373d3e426aeda784a80a6a4f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cf22909ceee710ab2f61b4d689b02cff8d62ec79", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf22909ceee710ab2f61b4d689b02cff8d62ec79", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf22909ceee710ab2f61b4d689b02cff8d62ec79", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf22909ceee710ab2f61b4d689b02cff8d62ec79/comments", "author": null, "committer": null, "parents": [{"sha": "a686ea5ba7a26bb5c755b5d65d05155770e5de5a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a686ea5ba7a26bb5c755b5d65d05155770e5de5a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a686ea5ba7a26bb5c755b5d65d05155770e5de5a"}], "stats": {"total": 758, "additions": 343, "deletions": 415}, "files": [{"sha": "aad06b772592760828af85381ad4ec91fbf1b10f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf22909ceee710ab2f61b4d689b02cff8d62ec79/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf22909ceee710ab2f61b4d689b02cff8d62ec79/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=cf22909ceee710ab2f61b4d689b02cff8d62ec79", "patch": "@@ -1,3 +1,76 @@\n+2003-01-14  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n+\n+\t* config-lang.in: Add semantics.c to gtfiles.\n+\t* cp-tree.h (flagged_type_tree_s): Remove lookups field.\n+\t(saved_scope): Likewise.\n+\t(type_lookups): Remove.\n+\t(deferred_access): New structure.\n+\t(type_access_control): Remove.\n+\t(save_type_access_control): Likewise.\n+\t(reset_type_access_control): Likewise.\n+\t(decl_type_access_control): Likewise.\n+\t(push_deferring_access_checks): Declare.\n+\t(resume_deferring_access_checks): Likewise.\n+\t(stop_deferring_access_checks): Likewise.\n+\t(pop_deferring_access_checks): Likewise.\n+\t(get_deferred_access_checks): Likewise.\n+\t(pop_to_parent_deferring_access_checks): Likewise.\n+\t(perform_deferred_access_checks): Likewise.\n+\t(perform_or_defer_access_check): Likewise.\n+\t* decl.c (make_typename_type): Use perform_or_defer_access_check.\n+\t(make_unbound_class_template): Likewise.\n+\t(grokdeclarator): Don't call decl_type_access_control.\n+\t* parser.c (cp_parser_context): Remove deferred_access_checks\n+\tand deferring_access_checks_p fields.\n+\t(cp_parser_context_new): Adjust.\n+\t(cp_parser): Remove access_checks_lists.\n+\t(cp_parser_defer_access_check): Remove.\n+\t(cp_parser_start_deferring_access_checks): Remove.\n+\t(cp_parser_stop_deferring_access_checks): Remove.\n+\t(cp_parser_perform_deferred_access_checks): Remove.\n+\t(cp_parser_nested_name_specifier_opt): Use new deferred access\n+\tfunctions.\n+\t(cp_parser_simple_declaration): Likewise.\n+\t(cp_parser_template_id): Likewise.\n+\t(cp_parser_function_definition): Likewise.\n+\t(cp_parser_class_specifier): Likewise.\n+\t(cp_parser_lookup_name): Likewise.\n+\t(cp_parser_single_declaration): Likewise.\n+\t(cp_parser_pre_parsed_nested_name_specifier): Likewise.\n+\t(cp_parser_parse_tentatively): Likewise.\n+\t(cp_parser_parse_definitely): Likewise.\n+\t(yyparse): Likewise.\n+\t(cp_parser_init_declarator): Remove access_checks parameter.\n+\tUse new deferred access functions.\n+\t(cp_parser_function_definition_from_specifiers_and_declarator):\n+\tLikewise.\n+\t(cp_parser_class_head): Remove deferring_access_checks_p and\n+\tsaved_access_checks parameters.  Use new deferred access functions.\n+\t(cp_parser_member_specification_opt): Don't call\n+\treset_type_access_control.\n+\t* search.c (type_access_control): Remove.\n+\t* semantics.c: Include \"gt-cp-semantics.h\".\n+\t(deferred_type_access_control): Remove.\n+\t(deferred_access_stack): New variable.\n+\t(deferred_access_free_list): Likewise.\n+\t(push_deferring_access_checks): New function.\n+\t(resume_deferring_access_checks): Likewise.\n+\t(stop_deferring_access_checks): Likewise.\n+\t(pop_deferring_access_checks): Likewise.\n+\t(get_deferred_access_checks): Likewise.\n+\t(pop_to_parent_deferring_access_checks): Likewise.\n+\t(perform_deferred_access_checks): New function, adapted from\n+\tcp_parser_perform_deferred_access_checks.\n+\t(perform_or_defer_access_check): New function, adapted from\n+\tcp_parser_defer_access_check.\n+\t(current_type_lookups): Remove.\n+\t(deferred_type_access_control): Likewise.\n+\t(decl_type_access_control): Likewise.\n+\t(save_type_access_control): Likewise.\n+\t(reset_type_access_control): Likewise.\n+\t(begin_function_definition): Adjust.\n+\t(begin_class_definiton): Likewise.\n+\n 2003-01-13  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/8748"}, {"sha": "d230bc66236cf0dd53f96fe6441d1e9bb52b1a04", "filename": "gcc/cp/config-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf22909ceee710ab2f61b4d689b02cff8d62ec79/gcc%2Fcp%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf22909ceee710ab2f61b4d689b02cff8d62ec79/gcc%2Fcp%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconfig-lang.in?ref=cf22909ceee710ab2f61b4d689b02cff8d62ec79", "patch": "@@ -34,4 +34,4 @@ stagestuff=\"g++\\$(exeext) g++-cross\\$(exeext) cc1plus\\$(exeext)\"\n \n target_libs=\"${libstdcxx_version} target-gperf\"\n \n-gtfiles=\"\\$(srcdir)/cp/cp-tree.h \\$(srcdir)/cp/decl.h \\$(srcdir)/cp/lex.h \\$(srcdir)/cp/call.c \\$(srcdir)/cp/decl.c \\$(srcdir)/cp/decl2.c \\$(srcdir)/cp/pt.c \\$(srcdir)/cp/repo.c \\$(srcdir)/cp/tree.c \\$(srcdir)/cp/parser.c \\$(srcdir)/c-common.c \\$(srcdir)/c-common.h \\$(srcdir)/c-pragma.c\"\n+gtfiles=\"\\$(srcdir)/cp/cp-tree.h \\$(srcdir)/cp/decl.h \\$(srcdir)/cp/lex.h \\$(srcdir)/cp/call.c \\$(srcdir)/cp/decl.c \\$(srcdir)/cp/decl2.c \\$(srcdir)/cp/pt.c \\$(srcdir)/cp/repo.c \\$(srcdir)/cp/semantics.c \\$(srcdir)/cp/tree.c \\$(srcdir)/cp/parser.c \\$(srcdir)/c-common.c \\$(srcdir)/c-common.h \\$(srcdir)/c-pragma.c\""}, {"sha": "612fd568a735952fed5ebb91fa57e8597fa47f36", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 34, "deletions": 8, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf22909ceee710ab2f61b4d689b02cff8d62ec79/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf22909ceee710ab2f61b4d689b02cff8d62ec79/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=cf22909ceee710ab2f61b4d689b02cff8d62ec79", "patch": "@@ -257,7 +257,6 @@ typedef struct flagged_type_tree_s GTY(())\n {\n   tree t;\n   int new_type_flag;\n-  tree lookups;\n } flagged_type_tree;\n \n typedef struct template_parm_index_s GTY(())\n@@ -784,7 +783,6 @@ struct saved_scope GTY(())\n   tree x_previous_class_type;\n   tree x_previous_class_values;\n   tree x_saved_tree;\n-  tree lookups;\n   tree last_parms;\n \n   HOST_WIDE_INT x_processing_template_decl;\n@@ -851,8 +849,6 @@ struct saved_scope GTY(())\n \n /* A list of private types mentioned, for deferred access checking.  */\n \n-#define type_lookups scope_chain->lookups\n-\n extern GTY(()) struct saved_scope *scope_chain;\n \n /* Global state pertinent to the current function.  */\n@@ -3197,6 +3193,32 @@ extern GTY(()) tree anonymous_namespace_name;\n    function, two inside the body of a function in a local class, etc.)  */\n extern int function_depth;\n \n+typedef struct deferred_access GTY(())\n+{\n+  /* A TREE_LIST representing name-lookups for which we have deferred\n+     checking access controls.  We cannot check the accessibility of\n+     names used in a decl-specifier-seq until we know what is being\n+     declared because code like:\n+\n+       class A { \n+         class B {};\n+         B* f();\n+       }\n+\n+       A::B* A::f() { return 0; }\n+\n+     is valid, even though `A::B' is not generally accessible.  \n+\n+     The TREE_PURPOSE of each node is the scope used to qualify the\n+     name being looked up; the TREE_VALUE is the DECL to which the\n+     name was resolved.  */\n+  tree deferred_access_checks;\n+  /* TRUE iff we are deferring access checks.  */\n+  bool deferring_access_checks_p;\n+  /* The next deferred access data in stack or linked-list.  */\n+  struct deferred_access *next;\n+} deferred_access;\n+\n /* in pt.c  */\n \n /* These values are used for the `STRICT' parameter to type_unification and\n@@ -4097,7 +4119,6 @@ extern tree lookup_base (tree, tree, base_access, base_kind *);\n extern int types_overlap_p\t\t\t(tree, tree);\n extern tree get_vbase\t\t\t\t(tree, tree);\n extern tree get_dynamic_cast_base_type          (tree, tree);\n-extern void type_access_control\t\t\t(tree, tree);\n extern int accessible_p                         (tree, tree);\n extern tree lookup_field\t\t\t(tree, tree, int, int);\n extern int lookup_fnfields_1                    (tree, tree);\n@@ -4147,6 +4168,14 @@ extern tree build_baselink                      (tree, tree, tree, tree);\n extern tree adjust_result_of_qualified_name_lookup\n                                                 (tree, tree, tree);\n /* in semantics.c */\n+extern void push_deferring_access_checks\t(bool defer_p);\n+extern void resume_deferring_access_checks\t(void);\n+extern void stop_deferring_access_checks\t(void);\n+extern void pop_deferring_access_checks\t\t(void);\n+extern tree get_deferred_access_checks\t\t(void);\n+extern void pop_to_parent_deferring_access_checks\t(void);\n+extern void perform_deferred_access_checks\t(void);\n+extern void perform_or_defer_access_check\t(tree, tree);\n extern void init_cp_semantics                   (void);\n extern tree finish_expr_stmt                    (tree);\n extern tree begin_if_stmt                       (void);\n@@ -4207,9 +4236,6 @@ extern tree finish_pseudo_destructor_expr       (tree, tree, tree);\n extern tree finish_unary_op_expr                (enum tree_code, tree);\n extern tree finish_compound_literal             (tree, tree);\n extern tree finish_fname                        (tree);\n-extern void save_type_access_control\t\t(tree);\n-extern void reset_type_access_control           (void);\n-extern void decl_type_access_control\t\t(tree);\n extern int begin_function_definition            (tree, tree, tree);\n extern tree begin_constructor_declarator        (tree, tree);\n extern tree finish_declarator                   (tree, tree, tree, tree, int);"}, {"sha": "42bbdc87af2f4534512ca59cd6dc105753aabbb0", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf22909ceee710ab2f61b4d689b02cff8d62ec79/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf22909ceee710ab2f61b4d689b02cff8d62ec79/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=cf22909ceee710ab2f61b4d689b02cff8d62ec79", "patch": "@@ -5544,7 +5544,7 @@ make_typename_type (tree context, tree name, tsubst_flags_t complain)\n \t  if (complain & tf_error)\n \t    {\n \t      if (complain & tf_parsing)\n-\t\ttype_access_control (context, tmpl);\n+\t\tperform_or_defer_access_check (context, tmpl);\n \t      else\n \t\tenforce_access (context, tmpl);\n \t    }\n@@ -5579,7 +5579,7 @@ make_typename_type (tree context, tree name, tsubst_flags_t complain)\n \t      if (complain & tf_error)\n \t\t{\n \t      \t  if (complain & tf_parsing)\n-\t\t    type_access_control (context, t);\n+\t\t    perform_or_defer_access_check (context, t);\n \t\t  else\n \t\t    enforce_access (context, t);\n \t\t}\n@@ -5651,7 +5651,7 @@ make_unbound_class_template (tree context, tree name, tsubst_flags_t complain)\n       if (complain & tf_error)\n \t{\n \t  if (complain & tf_parsing)\n-\t    type_access_control (context, tmpl);\n+\t    perform_or_defer_access_check (context, tmpl);\n \t  else\n \t    enforce_access (context, tmpl);\n \t}\n@@ -9854,7 +9854,6 @@ grokdeclarator (tree declarator,\n \n \t\tdecl = start_decl (declarator, declspecs, 1,\n \t\t\t\t   attributes, NULL_TREE);\n-\t\tdecl_type_access_control (decl);\n \t\tif (decl)\n \t\t  {\n \t\t    /* Look for __unused__ attribute */\n@@ -11407,8 +11406,6 @@ grokdeclarator (tree declarator,\n \t  /* Only try to do this stuff if we didn't already give up.  */\n \t  if (type != integer_type_node)\n \t    {\n-\t      decl_type_access_control (TYPE_NAME (type));\n-\n \t      /* A friendly class?  */\n \t      if (current_class_type)\n \t\tmake_friend_class (current_class_type, TYPE_MAIN_VARIANT (type));"}, {"sha": "68997ad170b26d7059fab5131d4df4af8794ecd9", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 91, "deletions": 300, "changes": 391, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf22909ceee710ab2f61b4d689b02cff8d62ec79/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf22909ceee710ab2f61b4d689b02cff8d62ec79/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=cf22909ceee710ab2f61b4d689b02cff8d62ec79", "patch": "@@ -1194,26 +1194,6 @@ typedef struct cp_parser_context GTY (())\n      scope given by OBJECT_TYPE (the type of `x' or `*x') and also in\n      the context of the containing expression.  */\n   tree object_type;\n-  /* A TREE_LIST representing name-lookups for which we have deferred\n-     checking access controls.  We cannot check the accessibility of\n-     names used in a decl-specifier-seq until we know what is being\n-     declared because code like:\n-\n-       class A { \n-         class B {};\n-         B* f();\n-       }\n-\n-       A::B* A::f() { return 0; }\n-\n-     is valid, even though `A::B' is not generally accessible.  \n-\n-     The TREE_PURPOSE of each node is the scope used to qualify the\n-     name being looked up; the TREE_VALUE is the DECL to which the\n-     name was resolved.  */\n-  tree deferred_access_checks;\n-  /* TRUE iff we are deferring access checks.  */\n-  bool deferring_access_checks_p;\n   /* The next parsing context in the stack.  */\n   struct cp_parser_context *next;\n } cp_parser_context;\n@@ -1260,10 +1240,6 @@ cp_parser_context_new (next)\n       /* If, in the NEXT context, we are parsing an `x->' or `x.'\n \t expression, then we are parsing one in this context, too.  */\n       context->object_type = next->object_type;\n-      /* We are deferring access checks here if we were in the NEXT\n-\t context.  */\n-      context->deferring_access_checks_p \n-\t= next->deferring_access_checks_p;\n       /* Thread the stack.  */\n       context->next = next;\n     }\n@@ -1367,10 +1343,6 @@ typedef struct cp_parser GTY(())\n   /* The number of template parameter lists that apply directly to the\n      current declaration.  */\n   unsigned num_template_parameter_lists;\n-\n-  /* List of access checks lists, used to prevent GC collection while\n-     they are in use.  */\n-  tree access_checks_lists;\n } cp_parser;\n \n /* The type of a function that parses some kind of expression  */\n@@ -1562,7 +1534,7 @@ static void cp_parser_linkage_specification\n /* Declarators [gram.dcl.decl] */\n \n static tree cp_parser_init_declarator\n-  PARAMS ((cp_parser *, tree, tree, tree, bool, bool, bool *));\n+  PARAMS ((cp_parser *, tree, tree, bool, bool, bool *));\n static tree cp_parser_declarator\n   PARAMS ((cp_parser *, cp_parser_declarator_kind, bool *));\n static tree cp_parser_direct_declarator\n@@ -1606,7 +1578,7 @@ static tree cp_parser_class_name\n static tree cp_parser_class_specifier\n   PARAMS ((cp_parser *));\n static tree cp_parser_class_head\n-  PARAMS ((cp_parser *, bool *, bool *, tree *));\n+  PARAMS ((cp_parser *, bool *));\n static enum tag_types cp_parser_class_key\n   PARAMS ((cp_parser *));\n static void cp_parser_member_specification_opt\n@@ -1731,7 +1703,7 @@ static tree cp_parser_global_scope_opt\n static bool cp_parser_constructor_declarator_p\n   (cp_parser *, bool);\n static tree cp_parser_function_definition_from_specifiers_and_declarator\n-  PARAMS ((cp_parser *, tree, tree, tree, tree));\n+  PARAMS ((cp_parser *, tree, tree, tree));\n static tree cp_parser_function_definition_after_declarator\n   PARAMS ((cp_parser *, bool));\n static void cp_parser_template_declaration_after_export\n@@ -1818,14 +1790,6 @@ static bool cp_parser_dependent_template_id_p\n   (tree, tree);\n static bool cp_parser_dependent_template_p\n   (tree);\n-static void cp_parser_defer_access_check\n-  (cp_parser *, tree, tree);\n-static void cp_parser_start_deferring_access_checks\n-  (cp_parser *);\n-static tree cp_parser_stop_deferring_access_checks\n-  PARAMS ((cp_parser *));\n-static void cp_parser_perform_deferred_access_checks\n-  PARAMS ((tree));\n static tree cp_parser_scope_through_which_access_occurs\n   (tree, tree, tree);\n \n@@ -2134,79 +2098,6 @@ cp_parser_dependent_template_p (tree tmpl)\n   return false;\n }\n \n-/* Defer checking the accessibility of DECL, when looked up in\n-   CLASS_TYPE.  */\n-\n-static void\n-cp_parser_defer_access_check (cp_parser *parser, \n-\t\t\t      tree class_type,\n-\t\t\t      tree decl)\n-{\n-  tree check;\n-\n-  /* If we are not supposed to defer access checks, just check now.  */\n-  if (!parser->context->deferring_access_checks_p)\n-    {\n-      enforce_access (class_type, decl);\n-      return;\n-    }\n-\n-  /* See if we are already going to perform this check.  */\n-  for (check = parser->context->deferred_access_checks;\n-       check;\n-       check = TREE_CHAIN (check))\n-    if (TREE_VALUE (check) == decl\n-\t&& same_type_p (TREE_PURPOSE (check), class_type))\n-      return;\n-  /* If not, record the check.  */\n-  parser->context->deferred_access_checks\n-    = tree_cons (class_type, decl, parser->context->deferred_access_checks);\n-}\n-\n-/* Start deferring access control checks.  */\n-\n-static void\n-cp_parser_start_deferring_access_checks (cp_parser *parser)\n-{\n-  parser->context->deferring_access_checks_p = true;\n-}\n-\n-/* Stop deferring access control checks.  Returns a TREE_LIST\n-   representing the deferred checks.  The TREE_PURPOSE of each node is\n-   the type through which the access occurred; the TREE_VALUE is the\n-   declaration named.  */\n-\n-static tree\n-cp_parser_stop_deferring_access_checks (parser)\n-     cp_parser *parser;\n-{\n-  tree access_checks;\n-\n-  parser->context->deferring_access_checks_p = false;\n-  access_checks = parser->context->deferred_access_checks;\n-  parser->context->deferred_access_checks = NULL_TREE;\n-\n-  return access_checks;\n-}\n-\n-/* Perform the deferred ACCESS_CHECKS, whose representation is as\n-   documented with cp_parser_stop_deferrring_access_checks.  */\n-\n-static void\n-cp_parser_perform_deferred_access_checks (access_checks)\n-     tree access_checks;\n-{\n-  tree deferred_check;\n-\n-  /* Look through all the deferred checks.  */\n-  for (deferred_check = access_checks;\n-       deferred_check;\n-       deferred_check = TREE_CHAIN (deferred_check))\n-    /* Check access.  */\n-    enforce_access (TREE_PURPOSE (deferred_check), \n-\t\t    TREE_VALUE (deferred_check));\n-}\n-\n /* Returns the scope through which DECL is being accessed, or\n    NULL_TREE if DECL is not a member.  If OBJECT_TYPE is non-NULL, we\n    have just seen `x->' or `x.' and OBJECT_TYPE is the type of `*x',\n@@ -3487,11 +3378,12 @@ cp_parser_nested_name_specifier_opt (cp_parser *parser,\n       start = cp_lexer_token_difference (parser->lexer,\n \t\t\t\t\t parser->lexer->first_token,\n \t\t\t\t\t token);\n-      access_check = parser->context->deferred_access_checks;\n     }\n   else\n     start = -1;\n \n+  push_deferring_access_checks (true);\n+\n   while (true)\n     {\n       tree new_scope;\n@@ -3633,35 +3525,23 @@ cp_parser_nested_name_specifier_opt (cp_parser *parser,\n \tcomplete_type (parser->scope);\n     }\n \n+  /* Retrieve any deferred checks.  Do not pop this access checks yet\n+     so the memory will not be reclaimed during token replacing below.  */\n+  access_check = get_deferred_access_checks ();\n+\n   /* If parsing tentatively, replace the sequence of tokens that makes\n      up the nested-name-specifier with a CPP_NESTED_NAME_SPECIFIER\n      token.  That way, should we re-parse the token stream, we will\n      not have to repeat the effort required to do the parse, nor will\n      we issue duplicate error messages.  */\n   if (success && start >= 0)\n     {\n-      tree c;\n-\n       /* Find the token that corresponds to the start of the\n \t template-id.  */\n       token = cp_lexer_advance_token (parser->lexer, \n \t\t\t\t      parser->lexer->first_token,\n \t\t\t\t      start);\n \n-      /* Remember the access checks associated with this\n-\t nested-name-specifier.  */\n-      c = parser->context->deferred_access_checks;\n-      if (c == access_check)\n-\taccess_check = NULL_TREE;\n-      else\n-\t{\n-\t  while (TREE_CHAIN (c) != access_check)\n-\t    c = TREE_CHAIN (c);\n-\t  access_check = parser->context->deferred_access_checks;\n-\t  parser->context->deferred_access_checks = TREE_CHAIN (c);\n-\t  TREE_CHAIN (c) = NULL_TREE;\n-\t}\n-\n       /* Reset the contents of the START token.  */\n       token->type = CPP_NESTED_NAME_SPECIFIER;\n       token->value = build_tree_list (access_check, parser->scope);\n@@ -3671,6 +3551,7 @@ cp_parser_nested_name_specifier_opt (cp_parser *parser,\n       cp_lexer_purge_tokens_after (parser->lexer, token);\n     }\n \n+  pop_deferring_access_checks ();\n   return success ? parser->scope : NULL_TREE;\n }\n \n@@ -6748,14 +6629,14 @@ cp_parser_simple_declaration (parser, function_definition_allowed_p)\n {\n   tree decl_specifiers;\n   tree attributes;\n-  tree access_checks;\n   bool declares_class_or_enum;\n   bool saw_declarator;\n \n   /* Defer access checks until we know what is being declared; the\n      checks for names appearing in the decl-specifier-seq should be\n      done as if we were in the scope of the thing being declared.  */\n-  cp_parser_start_deferring_access_checks (parser);\n+  push_deferring_access_checks (true);\n+\n   /* Parse the decl-specifier-seq.  We have to keep track of whether\n      or not the decl-specifier-seq declares a named class or\n      enumeration type, since that is the only case in which the\n@@ -6773,11 +6654,7 @@ cp_parser_simple_declaration (parser, function_definition_allowed_p)\n \t\t\t\t    &attributes,\n \t\t\t\t    &declares_class_or_enum);\n   /* We no longer need to defer access checks.  */\n-  access_checks = cp_parser_stop_deferring_access_checks (parser);\n-\n-  /* Prevent access checks from being reclaimed by GC.  */\n-  parser->access_checks_lists = tree_cons (NULL_TREE, access_checks,\n-\t\t\t\t\t   parser->access_checks_lists);\n+  stop_deferring_access_checks ();\n \n   /* Keep going until we hit the `;' at the end of the simple\n      declaration.  */\n@@ -6791,7 +6668,6 @@ cp_parser_simple_declaration (parser, function_definition_allowed_p)\n       saw_declarator = true;\n       /* Parse the init-declarator.  */\n       cp_parser_init_declarator (parser, decl_specifiers, attributes,\n-\t\t\t\t access_checks,\n \t\t\t\t function_definition_allowed_p,\n \t\t\t\t /*member_p=*/false,\n \t\t\t\t &function_definition_p);\n@@ -6809,9 +6685,7 @@ cp_parser_simple_declaration (parser, function_definition_allowed_p)\n \t  /* Otherwise, we're done with the list of declarators.  */\n \t  else\n \t    {\n-\t      /* Discard access checks no longer in use. */\n-\t      parser->access_checks_lists\n-\t\t= TREE_CHAIN (parser->access_checks_lists);\n+\t      pop_deferring_access_checks ();\n \t      return;\n \t    }\n \t}\n@@ -6829,9 +6703,7 @@ cp_parser_simple_declaration (parser, function_definition_allowed_p)\n \t  cp_parser_error (parser, \"expected `,' or `;'\");\n \t  /* Skip tokens until we reach the end of the statement.  */\n \t  cp_parser_skip_to_end_of_statement (parser);\n-\t  /* Discard access checks no longer in use.  */\n-          parser->access_checks_lists\n-\t    = TREE_CHAIN (parser->access_checks_lists);\n+\t  pop_deferring_access_checks ();\n \t  return;\n \t}\n       /* After the first time around, a function-definition is not\n@@ -6851,18 +6723,17 @@ cp_parser_simple_declaration (parser, function_definition_allowed_p)\n       if (cp_parser_declares_only_class_p (parser))\n \tshadow_tag (decl_specifiers);\n       /* Perform any deferred access checks.  */\n-      cp_parser_perform_deferred_access_checks (access_checks);\n+      perform_deferred_access_checks ();\n     }\n \n+  pop_deferring_access_checks ();\n+\n   /* Consume the `;'.  */\n   cp_parser_require (parser, CPP_SEMICOLON, \"`;'\");\n \n   /* Mark all the classes that appeared in the decl-specifier-seq as\n      having received a `;'.  */\n   note_list_got_semicolon (decl_specifiers);\n-\n-  /* Discard access checks no longer in use.  */\n-  parser->access_checks_lists = TREE_CHAIN (parser->access_checks_lists);\n }\n \n /* Parse a decl-specifier-seq.\n@@ -8127,9 +7998,8 @@ cp_parser_template_id (cp_parser *parser,\n       value = cp_lexer_consume_token (parser->lexer)->value;\n       /* Perform any access checks that were deferred.  */\n       for (check = TREE_PURPOSE (value); check; check = TREE_CHAIN (check))\n-\tcp_parser_defer_access_check (parser, \n-\t\t\t\t      TREE_PURPOSE (check),\n-\t\t\t\t      TREE_VALUE (check));\n+\tperform_or_defer_access_check (TREE_PURPOSE (check),\n+\t\t\t\t       TREE_VALUE (check));\n       /* Return the stored value.  */\n       return TREE_VALUE (value);\n     }\n@@ -8152,20 +8022,27 @@ cp_parser_template_id (cp_parser *parser,\n       start_of_id = cp_lexer_token_difference (parser->lexer,\n \t\t\t\t\t       parser->lexer->first_token,\n \t\t\t\t\t       next_token);\n-      access_check = parser->context->deferred_access_checks;\n     }\n   else\n     start_of_id = -1;\n \n+  push_deferring_access_checks (true);\n+\n   /* Parse the template-name.  */\n   template = cp_parser_template_name (parser, template_keyword_p,\n \t\t\t\t      check_dependency_p);\n   if (template == error_mark_node)\n-    return error_mark_node;\n+    {\n+      pop_deferring_access_checks ();\n+      return error_mark_node;\n+    }\n \n   /* Look for the `<' that starts the template-argument-list.  */\n   if (!cp_parser_require (parser, CPP_LESS, \"`<'\"))\n-    return error_mark_node;\n+    {\n+      pop_deferring_access_checks ();\n+      return error_mark_node;\n+    }\n \n   /* [temp.names]\n \n@@ -8216,6 +8093,10 @@ cp_parser_template_id (cp_parser *parser,\n       template_id = lookup_template_function (template, arguments);\n     }\n   \n+  /* Retrieve any deferred checks.  Do not pop this access checks yet\n+     so the memory will not be reclaimed during token replacing below.  */\n+  access_check = get_deferred_access_checks ();\n+\n   /* If parsing tentatively, replace the sequence of tokens that makes\n      up the template-id with a CPP_TEMPLATE_ID token.  That way,\n      should we re-parse the token stream, we will not have to repeat\n@@ -8225,28 +8106,13 @@ cp_parser_template_id (cp_parser *parser,\n   if (start_of_id >= 0)\n     {\n       cp_token *token;\n-      tree c;\n \n       /* Find the token that corresponds to the start of the\n \t template-id.  */\n       token = cp_lexer_advance_token (parser->lexer, \n \t\t\t\t      parser->lexer->first_token,\n \t\t\t\t      start_of_id);\n \n-      /* Remember the access checks associated with this\n-\t nested-name-specifier.  */\n-      c = parser->context->deferred_access_checks;\n-      if (c == access_check)\n-\taccess_check = NULL_TREE;\n-      else\n-\t{\n-\t  while (TREE_CHAIN (c) != access_check)\n-\t    c = TREE_CHAIN (c);\n-\t  access_check = parser->context->deferred_access_checks;\n-\t  parser->context->deferred_access_checks = TREE_CHAIN (c);\n-\t  TREE_CHAIN (c) = NULL_TREE;\n-\t}\n-\n       /* Reset the contents of the START_OF_ID token.  */\n       token->type = CPP_TEMPLATE_ID;\n       token->value = build_tree_list (access_check, template_id);\n@@ -8255,6 +8121,7 @@ cp_parser_template_id (cp_parser *parser,\n       cp_lexer_purge_tokens_after (parser->lexer, token);\n     }\n \n+  pop_deferring_access_checks ();\n   return template_id;\n }\n \n@@ -9724,10 +9591,9 @@ cp_parser_asm_definition (parser)\n      declarator asm-specification [opt] attributes [opt] initializer [opt]\n \n    The DECL_SPECIFIERS and PREFIX_ATTRIBUTES apply to this declarator.\n-   Returns a reprsentation of the entity declared.  The ACCESS_CHECKS\n-   represent deferred access checks from the decl-specifier-seq.  If\n-   MEMBER_P is TRUE, then this declarator appears in a class scope.\n-   The new DECL created by this declarator is returned.\n+   Returns a reprsentation of the entity declared.  If MEMBER_P is TRUE,\n+   then this declarator appears in a class scope.  The new DECL created\n+   by this declarator is returned.\n \n    If FUNCTION_DEFINITION_ALLOWED_P then we handle the declarator and\n    for a function-definition here as well.  If the declarator is a\n@@ -9742,14 +9608,12 @@ static tree\n cp_parser_init_declarator (parser, \n \t\t\t   decl_specifiers, \n \t\t\t   prefix_attributes,\n-\t\t\t   access_checks,\n \t\t\t   function_definition_allowed_p,\n \t\t\t   member_p,\n \t\t\t   function_definition_p)\n      cp_parser *parser;\n      tree decl_specifiers;\n      tree prefix_attributes;\n-     tree access_checks;\n      bool function_definition_allowed_p;\n      bool member_p;\n      bool *function_definition_p;\n@@ -9761,7 +9625,6 @@ cp_parser_init_declarator (parser,\n   tree initializer;\n   tree decl = NULL_TREE;\n   tree scope;\n-  tree declarator_access_checks;\n   bool is_initialized;\n   bool is_parenthesized_init;\n   bool ctor_dtor_or_conv_p;\n@@ -9775,29 +9638,19 @@ cp_parser_init_declarator (parser,\n   /* Defer access checks while parsing the declarator; we cannot know\n      what names are accessible until we know what is being \n      declared.  */\n-  cp_parser_start_deferring_access_checks (parser);\n+  resume_deferring_access_checks ();\n+\n   /* Parse the declarator.  */\n   declarator \n     = cp_parser_declarator (parser, CP_PARSER_DECLARATOR_NAMED,\n \t\t\t    &ctor_dtor_or_conv_p);\n   /* Gather up the deferred checks.  */\n-  declarator_access_checks \n-    = cp_parser_stop_deferring_access_checks (parser);\n-\n-  /* Prevent the access checks from being reclaimed by GC.  */\n-  parser->access_checks_lists\n-    = tree_cons (NULL_TREE, declarator_access_checks,\n-\t\t parser->access_checks_lists);\n+  stop_deferring_access_checks ();\n \n   /* If the DECLARATOR was erroneous, there's no need to go\n      further.  */\n   if (declarator == error_mark_node)\n-    {\n-      /* Discard access checks no longer in use.  */\n-      parser->access_checks_lists\n-\t= TREE_CHAIN (parser->access_checks_lists);\n-      return error_mark_node;\n-    }\n+    return error_mark_node;\n \n   /* Figure out what scope the entity declared by the DECLARATOR is\n      located in.  `grokdeclarator' sometimes changes the scope, so\n@@ -9831,15 +9684,10 @@ cp_parser_init_declarator (parser,\n \t     error message.  */\n \t  cp_parser_error (parser,\n \t\t\t   \"a function-definition is not allowed here\");\n-\t  /* Discard access checks no longer in use.  */\n-\t  parser->access_checks_lists\n-\t    = TREE_CHAIN (parser->access_checks_lists);\n \t  return error_mark_node;\n \t}\n       else\n \t{\n-\t  tree *ac;\n-\n \t  /* Neither attributes nor an asm-specification are allowed\n \t     on a function-definition.  */\n \t  if (asm_specification)\n@@ -9849,23 +9697,9 @@ cp_parser_init_declarator (parser,\n \t  /* This is a function-definition.  */\n \t  *function_definition_p = true;\n \n-\t  /* Thread the access checks together.  */\n-\t  ac = &access_checks;\n-\t  while (*ac)\n-\t    ac = &TREE_CHAIN (*ac);\n-\t  *ac = declarator_access_checks;\n-\n \t  /* Parse the function definition.  */\n \t  decl = (cp_parser_function_definition_from_specifiers_and_declarator\n-\t\t  (parser, decl_specifiers, prefix_attributes, declarator,\n-\t\t   access_checks));\n-\n-\t  /* Pull the access-checks apart again.  */\n-\t  *ac = NULL_TREE;\n-\n-\t  /* Discard access checks no longer in use.  */\n-          parser->access_checks_lists\n-\t     = TREE_CHAIN (parser->access_checks_lists);\n+\t\t  (parser, decl_specifiers, prefix_attributes, declarator));\n \n \t  return decl;\n \t}\n@@ -9883,9 +9717,6 @@ cp_parser_init_declarator (parser,\n     {\n       cp_parser_error (parser, \n \t\t       \"expected constructor, destructor, or type conversion\");\n-      /* Discard access checks no longer in use.  */\n-      parser->access_checks_lists\n-\t= TREE_CHAIN (parser->access_checks_lists);\n       return error_mark_node;\n     }\n \n@@ -9899,9 +9730,6 @@ cp_parser_init_declarator (parser,\n       && token->type != CPP_SEMICOLON)\n     {\n       cp_parser_error (parser, \"expected init-declarator\");\n-      /* Discard access checks no longer in use.  */\n-      parser->access_checks_lists\n-\t = TREE_CHAIN (parser->access_checks_lists);\n       return error_mark_node;\n     }\n \n@@ -9916,12 +9744,7 @@ cp_parser_init_declarator (parser,\n   /* Check that the number of template-parameter-lists is OK.  */\n   if (!cp_parser_check_declarator_template_parameters (parser, \n \t\t\t\t\t\t       declarator))\n-    {\n-      /* Discard access checks no longer in use.  */\n-      parser->access_checks_lists\n-\t = TREE_CHAIN (parser->access_checks_lists);\n-      return error_mark_node;\n-    }\n+    return error_mark_node;\n \n   /* Enter the newly declared entry in the symbol table.  If we're\n      processing a declaration in a class-specifier, we wait until\n@@ -9962,10 +9785,9 @@ cp_parser_init_declarator (parser,\n \t  current_function_decl = decl;\n \t}\n \t\n-      /* Perform the access control checks for the decl-specifiers.  */\n-      cp_parser_perform_deferred_access_checks (access_checks);\n-      /* And for the declarator.  */\n-      cp_parser_perform_deferred_access_checks (declarator_access_checks);\n+      /* Perform the access control checks for the declarator and the\n+\t the decl-specifiers.  */\n+      perform_deferred_access_checks ();\n \n       /* Restore the saved value.  */\n       if (TREE_CODE (decl) == FUNCTION_DECL)\n@@ -10017,10 +9839,6 @@ cp_parser_init_declarator (parser,\n \t\t    ((is_parenthesized_init || !is_initialized)\n \t\t     ? 0 : LOOKUP_ONLYCONVERTING));\n \n-  /* Discard access checks no longer in use.  */\n-  parser->access_checks_lists\n-    = TREE_CHAIN (parser->access_checks_lists);\n-\n   return decl;\n }\n \n@@ -11167,7 +10985,6 @@ cp_parser_function_definition (parser, friend_p)\n   tree attributes;\n   tree declarator;\n   tree fn;\n-  tree access_checks;\n   cp_token *token;\n   bool declares_class_or_enum;\n   bool member_p;\n@@ -11198,8 +11015,8 @@ cp_parser_function_definition (parser, friend_p)\n      function is being defined.  There is no need to do this for the\n      definition of member functions; we cannot be defining a member\n      from another class.  */\n-  if (!member_p)\n-    cp_parser_start_deferring_access_checks (parser);\n+  push_deferring_access_checks (!member_p);\n+\n   /* Parse the decl-specifier-seq.  */\n   decl_specifiers \n     = cp_parser_decl_specifier_seq (parser,\n@@ -11215,10 +11032,7 @@ cp_parser_function_definition (parser, friend_p)\n \t\t\t\t     /*ctor_dtor_or_conv_p=*/NULL);\n \n   /* Gather up any access checks that occurred.  */\n-  if (!member_p)\n-    access_checks = cp_parser_stop_deferring_access_checks (parser);\n-  else\n-    access_checks = NULL_TREE;\n+  stop_deferring_access_checks ();\n \n   /* If something has already gone wrong, we may as well stop now.  */\n   if (declarator == error_mark_node)\n@@ -11227,6 +11041,7 @@ cp_parser_function_definition (parser, friend_p)\n \t like a function-definition, to a `;' in the hopes of finding\n \t a sensible place from which to continue parsing.  */\n       cp_parser_skip_to_end_of_block_or_statement (parser);\n+      pop_deferring_access_checks ();\n       return error_mark_node;\n     }\n \n@@ -11241,6 +11056,7 @@ cp_parser_function_definition (parser, friend_p)\n       /* Skip to the next `;'.  */\n       cp_parser_skip_to_end_of_block_or_statement (parser);\n \n+      pop_deferring_access_checks ();\n       return error_mark_node;\n     }\n \n@@ -11269,6 +11085,7 @@ cp_parser_function_definition (parser, friend_p)\n \t  if (cp_parser_token_starts_function_definition_p \n \t      (cp_lexer_peek_token (parser->lexer)))\n \t    cp_parser_skip_to_end_of_block_or_statement (parser);\n+\t  pop_deferring_access_checks ();\n \t  return error_mark_node;\n \t}\n \n@@ -11294,6 +11111,7 @@ cp_parser_function_definition (parser, friend_p)\n \t= tree_cons (NULL_TREE, fn, \n \t\t     TREE_VALUE (parser->unparsed_functions_queues));\n \n+      pop_deferring_access_checks ();\n       return fn;\n     }\n \n@@ -11302,11 +11120,14 @@ cp_parser_function_definition (parser, friend_p)\n \t\t\t\t\t\t       declarator))\n     {\n       cp_parser_skip_to_end_of_block_or_statement (parser);\n+      pop_deferring_access_checks ();\n       return error_mark_node;\n     }\n \n-  return (cp_parser_function_definition_from_specifiers_and_declarator\n-\t  (parser, decl_specifiers, attributes, declarator, access_checks));\n+  fn = cp_parser_function_definition_from_specifiers_and_declarator\n+\t  (parser, decl_specifiers, attributes, declarator);\n+  pop_deferring_access_checks ();\n+  return fn;\n }\n \n /* Parse a function-body.\n@@ -11670,25 +11491,29 @@ cp_parser_class_specifier (parser)\n   tree attributes = NULL_TREE;\n   int has_trailing_semicolon;\n   bool nested_name_specifier_p;\n-  bool deferring_access_checks_p;\n-  tree saved_access_checks;\n   unsigned saved_num_template_parameter_lists;\n \n+  push_deferring_access_checks (false);  \n+\n   /* Parse the class-head.  */\n   type = cp_parser_class_head (parser,\n-\t\t\t       &nested_name_specifier_p,\n-\t\t\t       &deferring_access_checks_p,\n-\t\t\t       &saved_access_checks);\n+\t\t\t       &nested_name_specifier_p);\n   /* If the class-head was a semantic disaster, skip the entire body\n      of the class.  */\n   if (!type)\n     {\n       cp_parser_skip_to_end_of_block_or_statement (parser);\n+      pop_deferring_access_checks ();\n       return error_mark_node;\n     }\n+\n   /* Look for the `{'.  */\n   if (!cp_parser_require (parser, CPP_OPEN_BRACE, \"`{'\"))\n-    return error_mark_node;\n+    {\n+      pop_deferring_access_checks ();\n+      return error_mark_node;\n+    }\n+\n   /* Issue an error message if type-definitions are forbidden here.  */\n   cp_parser_check_type_definition (parser);\n   /* Remember that we are defining one more class.  */\n@@ -11797,11 +11622,7 @@ cp_parser_class_specifier (parser)\n     }\n \n   /* Put back any saved access checks.  */\n-  if (deferring_access_checks_p)\n-    {\n-      cp_parser_start_deferring_access_checks (parser);\n-      parser->context->deferred_access_checks = saved_access_checks;\n-    }\n+  pop_deferring_access_checks ();\n \n   /* Restore the count of active template-parameter-lists.  */\n   parser->num_template_parameter_lists\n@@ -11827,24 +11648,16 @@ cp_parser_class_specifier (parser)\n    Returns the TYPE of the indicated class.  Sets\n    *NESTED_NAME_SPECIFIER_P to TRUE iff one of the productions\n    involving a nested-name-specifier was used, and FALSE otherwise.\n-   Sets *DEFERRING_ACCESS_CHECKS_P to TRUE iff we were deferring\n-   access checks before this class-head.  In that case,\n-   *SAVED_ACCESS_CHECKS is set to the current list of deferred access\n-   checks.  \n \n    Returns NULL_TREE if the class-head is syntactically valid, but\n    semantically invalid in a way that means we should skip the entire\n    body of the class.  */\n \n static tree\n cp_parser_class_head (parser, \n-\t\t      nested_name_specifier_p,\n-\t\t      deferring_access_checks_p,\n-\t\t      saved_access_checks)\n+\t\t      nested_name_specifier_p)\n      cp_parser *parser;\n      bool *nested_name_specifier_p;\n-     bool *deferring_access_checks_p;\n-     tree *saved_access_checks;\n {\n   cp_token *token;\n   tree nested_name_specifier;\n@@ -12004,14 +11817,6 @@ cp_parser_class_head (parser,\n        process the class-definition.  */\n     return NULL_TREE;\n \n-  /* We do not need to defer access checks for entities declared\n-     within the class.  But, we do need to save any access checks that\n-     are currently deferred and restore them later, in case we are in\n-     the middle of something else.  */\n-  *deferring_access_checks_p = parser->context->deferring_access_checks_p;\n-  if (*deferring_access_checks_p)\n-    *saved_access_checks = cp_parser_stop_deferring_access_checks (parser);\n-\n   /* Look up the type.  */\n   if (template_id_p)\n     {\n@@ -12165,7 +11970,6 @@ cp_parser_member_specification_opt (parser)\n \t  /* Otherwise, the next construction must be a\n \t     member-declaration.  */\n \t  cp_parser_member_declaration (parser);\n-\t  reset_type_access_control ();\n \t}\n     }\n }\n@@ -13659,15 +13463,7 @@ cp_parser_lookup_name (cp_parser *parser, tree name, bool check_access,\n \t\t\t\t\t\t       object_type,\n \t\t\t\t\t\t       parser->scope);\n       if (qualifying_type)\n-\t{\n-\t  /* If we are supposed to defer access checks, just record\n-\t     the information for later.  */\n-\t  if (parser->context->deferring_access_checks_p)\n-\t    cp_parser_defer_access_check (parser, qualifying_type, decl);\n-\t  /* Otherwise, check accessibility now.  */\n-\t  else\n-\t    enforce_access (qualifying_type, decl);\n-\t}\n+\tperform_or_defer_access_check (qualifying_type, decl);\n     }\n \n   return decl;\n@@ -14129,19 +13925,18 @@ cp_parser_constructor_declarator_p (cp_parser *parser, bool friend_p)\n }\n \n /* Parse the definition of the function given by the DECL_SPECIFIERS,\n-   ATTRIBUTES, and DECLARATOR.  The ACCESS_CHECKS have been deferred;\n+   ATTRIBUTES, and DECLARATOR.  The access checks have been deferred;\n    they must be performed once we are in the scope of the function.\n \n    Returns the function defined.  */\n \n static tree\n cp_parser_function_definition_from_specifiers_and_declarator\n-  (parser, decl_specifiers, attributes, declarator, access_checks)\n+  (parser, decl_specifiers, attributes, declarator)\n      cp_parser *parser;\n      tree decl_specifiers;\n      tree attributes;\n      tree declarator;\n-     tree access_checks;\n {\n   tree fn;\n   bool success_p;\n@@ -14155,7 +13950,7 @@ cp_parser_function_definition_from_specifiers_and_declarator\n      did not check, check them now.  We must wait until we are in the\n      scope of the function to perform the checks, since the function\n      might be a friend.  */\n-  cp_parser_perform_deferred_access_checks (access_checks);\n+  perform_deferred_access_checks ();\n \n   if (!success_p)\n     {\n@@ -14335,13 +14130,13 @@ cp_parser_single_declaration (parser,\n   tree decl = NULL_TREE;\n   tree decl_specifiers;\n   tree attributes;\n-  tree access_checks;\n \n   /* Parse the dependent declaration.  We don't know yet\n      whether it will be a function-definition.  */\n   cp_parser_parse_tentatively (parser);\n   /* Defer access checks until we know what is being declared.  */\n-  cp_parser_start_deferring_access_checks (parser);\n+  push_deferring_access_checks (true);\n+\n   /* Try the `decl-specifier-seq [opt] init-declarator [opt]'\n      alternative.  */\n   decl_specifiers \n@@ -14351,7 +14146,8 @@ cp_parser_single_declaration (parser,\n \t\t\t\t    &declares_class_or_enum);\n   /* Gather up the access checks that occurred the\n      decl-specifier-seq.  */\n-  access_checks = cp_parser_stop_deferring_access_checks (parser);\n+  stop_deferring_access_checks ();\n+\n   /* Check for the declaration of a template class.  */\n   if (declares_class_or_enum)\n     {\n@@ -14377,10 +14173,12 @@ cp_parser_single_declaration (parser,\n     decl = cp_parser_init_declarator (parser, \n \t\t\t\t      decl_specifiers,\n \t\t\t\t      attributes,\n-\t\t\t\t      access_checks,\n \t\t\t\t      /*function_definition_allowed_p=*/false,\n \t\t\t\t      member_p,\n \t\t\t\t      /*function_definition_p=*/NULL);\n+\n+  pop_deferring_access_checks ();\n+\n   /* Clear any current qualification; whatever comes next is the start\n      of something new.  */\n   parser->scope = NULL_TREE;\n@@ -14881,9 +14679,7 @@ cp_parser_pre_parsed_nested_name_specifier (cp_parser *parser)\n   value = cp_lexer_consume_token (parser->lexer)->value;\n   /* Perform any access checks that were deferred.  */\n   for (check = TREE_PURPOSE (value); check; check = TREE_CHAIN (check))\n-    cp_parser_defer_access_check (parser, \n-\t\t\t\t  TREE_PURPOSE (check),\n-\t\t\t\t  TREE_VALUE (check));\n+    perform_or_defer_access_check (TREE_PURPOSE (check), TREE_VALUE (check));\n   /* Set the scope from the stored value.  */\n   parser->scope = TREE_VALUE (value);\n   parser->qualifying_scope = TREE_TYPE (value);\n@@ -14942,7 +14738,7 @@ cp_parser_parse_tentatively (parser)\n   /* In order to avoid repetitive access control error messages,\n      access checks are queued up until we are no longer parsing\n      tentatively.  */\n-  cp_parser_start_deferring_access_checks (parser);\n+  push_deferring_access_checks (true);\n }\n \n /* Commit to the currently active tentative parse.  */\n@@ -15004,22 +14800,16 @@ cp_parser_parse_definitely (parser)\n \t already done.  */\n       if (context->status != CP_PARSER_STATUS_KIND_COMMITTED)\n \tcp_lexer_commit_tokens (parser->lexer);\n-      if (!parser->context->deferring_access_checks_p)\n-\t/* If in the parent context we are not deferring checks, then\n-\t   these perform these checks now.  */\n-\t(cp_parser_perform_deferred_access_checks \n-\t (context->deferred_access_checks));\n-      else\n-\t/* Any lookups that were deferred during the tentative parse are\n-\t   still deferred.  */\n-\tparser->context->deferred_access_checks \n-\t  = chainon (parser->context->deferred_access_checks,\n-\t\t     context->deferred_access_checks);\n+\n+      pop_to_parent_deferring_access_checks ();\n     }\n   /* Otherwise, if errors occurred, roll back our state so that things\n      are just as they were before we began the tentative parse.  */\n   else\n-    cp_lexer_rollback_tokens (parser->lexer);\n+    {\n+      cp_lexer_rollback_tokens (parser->lexer);\n+      pop_deferring_access_checks ();\n+    }\n   /* Add the context to the front of the free list.  */\n   context->next = cp_parser_context_free_list;\n   cp_parser_context_free_list = context;\n@@ -15074,6 +14864,7 @@ yyparse ()\n   bool error_occurred;\n \n   the_parser = cp_parser_new ();\n+  push_deferring_access_checks (false);\n   error_occurred = cp_parser_translation_unit (the_parser);\n   the_parser = NULL;\n   "}, {"sha": "0895a76567f920562babecdb0d01f8fcba5419fa", "filename": "gcc/cp/search.c", "status": "modified", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf22909ceee710ab2f61b4d689b02cff8d62ec79/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf22909ceee710ab2f61b4d689b02cff8d62ec79/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=cf22909ceee710ab2f61b4d689b02cff8d62ec79", "patch": "@@ -979,41 +979,6 @@ friend_accessible_p (scope, decl, binfo)\n   return 0;\n }\n \n-/* Perform access control on TYPE_DECL or TEMPLATE_DECL VAL, which was\n-   looked up in TYPE.  This is fairly complex, so here's the design:\n-\n-   The lang_extdef nonterminal sets type_lookups to NULL_TREE before we\n-     start to process a top-level declaration.\n-   As we process the decl-specifier-seq for the declaration, any types we\n-     see that might need access control are passed to type_access_control,\n-     which defers checking by adding them to type_lookups.\n-   When we are done with the decl-specifier-seq, we record the lookups we've\n-     seen in the lookups field of the typed_declspecs nonterminal.\n-   When we process the first declarator, either in parse_decl or\n-     begin_function_definition, we call save_type_access_control,\n-     which stores the lookups from the decl-specifier-seq in\n-     current_type_lookups.\n-   As we finish with each declarator, we process everything in type_lookups\n-     via decl_type_access_control, which resets type_lookups to the value of\n-     current_type_lookups for subsequent declarators.\n-   When we enter a function, we set type_lookups to error_mark_node, so all\n-     lookups are processed immediately.  */\n-\n-void\n-type_access_control (type, val)\n-     tree type, val;\n-{\n-  if (val == NULL_TREE\n-      || (TREE_CODE (val) != TEMPLATE_DECL && TREE_CODE (val) != TYPE_DECL)\n-      || ! DECL_CLASS_SCOPE_P (val))\n-    return;\n-\n-  if (type_lookups == error_mark_node)\n-    enforce_access (type, val);\n-  else if (! accessible_p (type, val))\n-    type_lookups = tree_cons (type, val, type_lookups);\n-}\n-\n /* DECL is a declaration from a base class of TYPE, which was the\n    class used to name DECL.  Return nonzero if, in the current\n    context, DECL is accessible.  If TYPE is actually a BINFO node,"}, {"sha": "e3ae9be7a9a32087df4b075d8e4e156663f8d8f9", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 141, "deletions": 65, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf22909ceee710ab2f61b4d689b02cff8d62ec79/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf22909ceee710ab2f61b4d689b02cff8d62ec79/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=cf22909ceee710ab2f61b4d689b02cff8d62ec79", "patch": "@@ -52,7 +52,6 @@\n \n static tree maybe_convert_cond PARAMS ((tree));\n static tree simplify_aggr_init_exprs_r PARAMS ((tree *, int *, void *));\n-static void deferred_type_access_control PARAMS ((void));\n static void emit_associated_thunks PARAMS ((tree));\n static void genrtl_try_block PARAMS ((tree));\n static void genrtl_eh_spec_block PARAMS ((tree));\n@@ -79,6 +78,145 @@ static tree clear_decl_rtl PARAMS ((tree *, int *, void *));\n       (SUBSTMT) = (COND);\t\t\t\t\\\n   } while (0)\n \n+/* Data for deferred access checking.  */\n+static GTY(()) deferred_access *deferred_access_stack;\n+static GTY(()) deferred_access *deferred_access_free_list;\n+\n+/* Save the current deferred access states and start deferred\n+   access checking iff DEFER_P is true.  */\n+\n+void push_deferring_access_checks (bool deferring_p)\n+{\n+  deferred_access *d;\n+\n+  /* Recycle previously used free store if available.  */\n+  if (deferred_access_free_list)\n+    {\n+      d = deferred_access_free_list;\n+      deferred_access_free_list = d->next;\n+    }\n+  else\n+    d = (deferred_access *) ggc_alloc (sizeof (deferred_access));\n+\n+  d->next = deferred_access_stack;\n+  d->deferred_access_checks = NULL_TREE;\n+  d->deferring_access_checks_p = deferring_p;\n+  deferred_access_stack = d;\n+}\n+\n+/* Resume deferring access checks again after we stopped doing\n+   this previously.  */\n+\n+void resume_deferring_access_checks (void)\n+{\n+  deferred_access_stack->deferring_access_checks_p = true;\n+}\n+\n+/* Stop deferring access checks.  */\n+\n+void stop_deferring_access_checks (void)\n+{\n+  deferred_access_stack->deferring_access_checks_p = false;\n+}\n+\n+/* Discard the current deferred access checks and restore the\n+   previous states.  */\n+\n+void pop_deferring_access_checks (void)\n+{\n+  deferred_access *d = deferred_access_stack;\n+  deferred_access_stack = d->next;\n+\n+  /* Remove references to access checks TREE_LIST.  */\n+  d->deferred_access_checks = NULL_TREE;\n+\n+  /* Store in free list for later use.  */\n+  d->next = deferred_access_free_list;\n+  deferred_access_free_list = d;\n+}\n+\n+/* Returns a TREE_LIST representing the deferred checks.  \n+   The TREE_PURPOSE of each node is the type through which the \n+   access occurred; the TREE_VALUE is the declaration named.\n+   */\n+\n+tree get_deferred_access_checks (void)\n+{\n+  return deferred_access_stack->deferred_access_checks;\n+}\n+\n+/* Take current deferred checks and combine with the\n+   previous states if we also defer checks previously.\n+   Otherwise perform checks now.  */\n+\n+void pop_to_parent_deferring_access_checks (void)\n+{\n+  tree deferred_check = get_deferred_access_checks ();\n+  deferred_access *d1 = deferred_access_stack;\n+  deferred_access *d2 = deferred_access_stack->next;\n+  deferred_access *d3 = deferred_access_stack->next->next;\n+\n+  /* Temporary swap the order of the top two states, just to make\n+     sure the garbage collector will not reclaim the memory during \n+     processing below.  */\n+  deferred_access_stack = d2;\n+  d2->next = d1;\n+  d1->next = d3;\n+\n+  for ( ; deferred_check; deferred_check = TREE_CHAIN (deferred_check))\n+    /* Perform deferred check if required.  */\n+    perform_or_defer_access_check (TREE_PURPOSE (deferred_check), \n+\t\t\t\t   TREE_VALUE (deferred_check));\n+\n+  deferred_access_stack = d1;\n+  d1->next = d2;\n+  d2->next = d3;\n+  pop_deferring_access_checks ();\n+}\n+\n+/* Perform the deferred access checks.  */\n+\n+void perform_deferred_access_checks (void)\n+{\n+  tree deferred_check;\n+  for (deferred_check = deferred_access_stack->deferred_access_checks;\n+       deferred_check;\n+       deferred_check = TREE_CHAIN (deferred_check))\n+    /* Check access.  */\n+    enforce_access (TREE_PURPOSE (deferred_check), \n+\t\t    TREE_VALUE (deferred_check));\n+\n+  /* No more deferred checks.  */\n+  deferred_access_stack->deferred_access_checks = NULL_TREE;\n+}\n+\n+/* Defer checking the accessibility of DECL, when looked up in\n+   CLASS_TYPE.  */\n+\n+void perform_or_defer_access_check (tree class_type, tree decl)\n+{\n+  tree check;\n+\n+  /* If we are not supposed to defer access checks, just check now.  */\n+  if (!deferred_access_stack->deferring_access_checks_p)\n+    {\n+      enforce_access (class_type, decl);\n+      return;\n+    }\n+\n+  /* See if we are already going to perform this check.  */\n+  for (check = deferred_access_stack->deferred_access_checks;\n+       check;\n+       check = TREE_CHAIN (check))\n+    if (TREE_VALUE (check) == decl\n+\t&& same_type_p (TREE_PURPOSE (check), class_type))\n+      return;\n+  /* If not, record the check.  */\n+  deferred_access_stack->deferred_access_checks\n+    = tree_cons (class_type, decl,\n+\t\t deferred_access_stack->deferred_access_checks);\n+}\n+\n /* Returns nonzero if the current statement is a full expression,\n    i.e. temporaries created during that statement should be destroyed\n    at the end of the statement.  */\n@@ -1506,63 +1644,6 @@ finish_fname (tree id)\n   return decl;\n }\n \n-static tree current_type_lookups;\n-\n-/* Perform deferred access control for types used in the type of a\n-   declaration.  */\n-\n-static void\n-deferred_type_access_control ()\n-{\n-  tree lookup = type_lookups;\n-\n-  if (lookup == error_mark_node)\n-    return;\n-\n-  for (; lookup; lookup = TREE_CHAIN (lookup))\n-    enforce_access (TREE_PURPOSE (lookup), TREE_VALUE (lookup));\n-}\n-\n-void\n-decl_type_access_control (decl)\n-     tree decl;\n-{\n-  tree save_fn;\n-\n-  if (type_lookups == error_mark_node)\n-    return;\n-\n-  save_fn = current_function_decl;\n-\n-  if (decl && TREE_CODE (decl) == FUNCTION_DECL)\n-    current_function_decl = decl;\n-\n-  deferred_type_access_control ();\n-\n-  current_function_decl = save_fn;\n-  \n-  /* Now strip away the checks for the current declarator; they were\n-     added to type_lookups after typed_declspecs saved the copy that\n-     ended up in current_type_lookups.  */\n-  type_lookups = current_type_lookups;\n-}\n-\n-void\n-save_type_access_control (lookups)\n-     tree lookups;\n-{\n-  current_type_lookups = lookups;\n-}\n-\n-/* Reset the deferred access control.  */\n-\n-void\n-reset_type_access_control ()\n-{\n-  type_lookups = NULL_TREE;\n-  current_type_lookups = NULL_TREE;\n-}\n-\n /* Begin a function definition declared with DECL_SPECS, ATTRIBUTES,\n    and DECLARATOR.  Returns nonzero if the function-declaration is\n    valid.  */\n@@ -1576,9 +1657,6 @@ begin_function_definition (decl_specs, attributes, declarator)\n   if (!start_function (decl_specs, declarator, attributes, SF_DEFAULT))\n     return 0;\n \n-  deferred_type_access_control ();\n-  type_lookups = error_mark_node;\n-\n   /* The things we're about to see are not directly qualified by any\n      template headers we've seen thus far.  */\n   reset_specialization ();\n@@ -1714,10 +1792,6 @@ begin_class_definition (t)\n   if (t == error_mark_node)\n     return error_mark_node;\n \n-  /* Check the bases are accessible.  */\n-  decl_type_access_control (TYPE_NAME (t));\n-  reset_type_access_control ();\n-  \n   if (processing_template_parmlist)\n     {\n       error (\"definition of `%#T' inside template parameter list\", t);\n@@ -2690,3 +2764,5 @@ init_cp_semantics ()\n {\n   lang_expand_stmt = cp_expand_stmt;\n }\n+\n+#include \"gt-cp-semantics.h\""}]}