{"sha": "1696fc1ea01d5c9dce96b5d3122921aab9308f59", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTY5NmZjMWVhMDFkNWM5ZGNlOTZiNWQzMTIyOTIxYWFiOTMwOGY1OQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-04-15T10:37:39Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-04-15T10:37:39Z"}, "message": "c++: Tweak merging of vector attributes that affect type identity [PR98852]\n\n<arm_neon.h> types are distinct from GNU vector types in at least\ntheir mangling.  However, there used to be nothing explicit in the\nVECTOR_TYPE itself to indicate the difference: we simply treated them\nas distinct TYPE_MAIN_VARIANTs.  This caused problems like the ones\nreported in PR95726.\n\nThe fix for that PR was to add type attributes to the <arm_neon.h>\ntypes, in order to maintain the distinction between them and GNU\nvectors.  However, this in turn caused PR98852, where cp_common_type\nwould merge the type attributes from the two source types and attach\nthe result to the common type.  For example:\n\n   unsigned vector with no attribute + signed vector with attribute X\n\nwould get converted to:\n\n   unsigned vector with attribute X\n\nThat isn't what we want in this case, since X describes the mangling\nof the original type.  But even if we dropped the mangling from X and\nworked it out from context, we would still have a situation in which\nthe common type was provably distinct from both of the source types:\nit would take its <arm_neon.h>-ness from one side and its signedness\nfrom the other.  I guess there are other cases where the common type\ndoesn't match either side, but I'm not sure it's the obvious behaviour\nhere.  It's also different from GCC 10.1 and earlier, where the unsigned\nvector \u201cwon\u201d in its original form.\n\nThis patch instead merges only the attributes that don't affect type\nidentity.  For now I've restricted it to vector types, since we're so\nclose to GCC 11, but it might make sense to use this elsewhere.\n\nI've tried to audit the C and target-specific attributes to look for\nother types that might be affected by this, but I couldn't see any.\nThe closest was s390_vector_bool, but the handler for that attribute\nchanges the type node and drops the attribute itself\n(*no_add_attrs = true).\n\ngcc/\n\tPR c++/98852\n\t* attribs.h (restrict_type_identity_attributes_to): Declare.\n\t* attribs.c (restrict_type_identity_attributes_to): New function.\n\ngcc/cp/\n\tPR c++/98852\n\t* typeck.c (merge_type_attributes_from): New function.\n\t(cp_common_type): Use it for vector types.", "tree": {"sha": "03a93ad7246ef1ee6eba98377f272be3c4314124", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/03a93ad7246ef1ee6eba98377f272be3c4314124"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1696fc1ea01d5c9dce96b5d3122921aab9308f59", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1696fc1ea01d5c9dce96b5d3122921aab9308f59", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1696fc1ea01d5c9dce96b5d3122921aab9308f59", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1696fc1ea01d5c9dce96b5d3122921aab9308f59/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a3317f7b3c02907a122f89879e5b6e90c386e64d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3317f7b3c02907a122f89879e5b6e90c386e64d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3317f7b3c02907a122f89879e5b6e90c386e64d"}], "stats": {"total": 221, "additions": 219, "deletions": 2}, "files": [{"sha": "3ffa1b6bc815f26618112f7f805a2ec8474eab1f", "filename": "gcc/attribs.c", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1696fc1ea01d5c9dce96b5d3122921aab9308f59/gcc%2Fattribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1696fc1ea01d5c9dce96b5d3122921aab9308f59/gcc%2Fattribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.c?ref=1696fc1ea01d5c9dce96b5d3122921aab9308f59", "patch": "@@ -1420,6 +1420,29 @@ affects_type_identity_attributes (tree attrs, bool value)\n   return remove_attributes_matching (attrs, predicate);\n }\n \n+/* Remove attributes that affect type identity from ATTRS unless the\n+   same attributes occur in OK_ATTRS.  */\n+\n+tree\n+restrict_type_identity_attributes_to (tree attrs, tree ok_attrs)\n+{\n+  auto predicate = [ok_attrs](const_tree attr,\n+\t\t\t      const attribute_spec *as) -> bool\n+    {\n+      if (!as || !as->affects_type_identity)\n+\treturn true;\n+\n+      for (tree ok_attr = lookup_attribute (as->name, ok_attrs);\n+\t   ok_attr;\n+\t   ok_attr = lookup_attribute (as->name, TREE_CHAIN (ok_attr)))\n+\tif (simple_cst_equal (TREE_VALUE (ok_attr), TREE_VALUE (attr)) == 1)\n+\t  return true;\n+\n+      return false;\n+    };\n+  return remove_attributes_matching (attrs, predicate);\n+}\n+\n /* Return a type like TTYPE except that its TYPE_ATTRIBUTE\n    is ATTRIBUTE.\n "}, {"sha": "df78eb152f9b6d4e502b93f06f11b3548998c037", "filename": "gcc/attribs.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1696fc1ea01d5c9dce96b5d3122921aab9308f59/gcc%2Fattribs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1696fc1ea01d5c9dce96b5d3122921aab9308f59/gcc%2Fattribs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.h?ref=1696fc1ea01d5c9dce96b5d3122921aab9308f59", "patch": "@@ -66,6 +66,7 @@ extern bool attribute_value_equal (const_tree, const_tree);\n extern int comp_type_attributes (const_tree, const_tree);\n \n extern tree affects_type_identity_attributes (tree, bool = true);\n+extern tree restrict_type_identity_attributes_to (tree, tree);\n \n /* Default versions of target-overridable functions.  */\n extern tree merge_decl_attributes (tree, tree);"}, {"sha": "50d0f1e6a62aa402c5f16626ec435073c753b009", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1696fc1ea01d5c9dce96b5d3122921aab9308f59/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1696fc1ea01d5c9dce96b5d3122921aab9308f59/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=1696fc1ea01d5c9dce96b5d3122921aab9308f59", "patch": "@@ -261,6 +261,17 @@ original_type (tree t)\n   return cp_build_qualified_type (t, quals);\n }\n \n+/* Merge the attributes of type OTHER_TYPE into the attributes of type TYPE\n+   and return a variant of TYPE with the merged attributes.  */\n+\n+static tree\n+merge_type_attributes_from (tree type, tree other_type)\n+{\n+  tree attrs = targetm.merge_type_attributes (type, other_type);\n+  attrs = restrict_type_identity_attributes_to (attrs, TYPE_ATTRIBUTES (type));\n+  return cp_build_type_attribute_variant (type, attrs);\n+}\n+\n /* Return the common type for two arithmetic types T1 and T2 under the\n    usual arithmetic conversions.  The default conversions have already\n    been applied, and enumerated types converted to their compatible\n@@ -320,9 +331,9 @@ cp_common_type (tree t1, tree t2)\n       /* When we get here we should have two vectors of the same size.\n \t Just prefer the unsigned one if present.  */\n       if (TYPE_UNSIGNED (t1))\n-\treturn build_type_attribute_variant (t1, attributes);\n+\treturn merge_type_attributes_from (t1, t2);\n       else\n-\treturn build_type_attribute_variant (t2, attributes);\n+\treturn merge_type_attributes_from (t2, t1);\n     }\n \n   /* If only one is real, use it as the result.  */"}, {"sha": "268e2213b1ff235b60077112d86e33f5d8cd2a73", "filename": "gcc/testsuite/g++.target/aarch64/advsimd-intrinsics/advsimd-intrinsics.exp", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1696fc1ea01d5c9dce96b5d3122921aab9308f59/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fadvsimd-intrinsics%2Fadvsimd-intrinsics.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1696fc1ea01d5c9dce96b5d3122921aab9308f59/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fadvsimd-intrinsics%2Fadvsimd-intrinsics.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fadvsimd-intrinsics%2Fadvsimd-intrinsics.exp?ref=1696fc1ea01d5c9dce96b5d3122921aab9308f59", "patch": "@@ -0,0 +1,72 @@\n+# Copyright (C) 2014-2021 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# GCC testsuite that uses the `dg.exp' driver.\n+\n+# Exit immediately if this isn't an ARM or AArch64 target.\n+if {![istarget arm*-*-*]\n+    && ![istarget aarch64*-*-*]} then {\n+  return\n+}\n+\n+# Load support procs.\n+load_lib g++-dg.exp\n+\n+# Initialize `dg'.\n+load_lib c-torture.exp\n+\n+dg-init\n+\n+# The default action for a test is 'run'.  Save current default.\n+global dg-do-what-default\n+set save-dg-do-what-default ${dg-do-what-default}\n+\n+# For ARM, make sure that we have a target compatible with NEON, and do\n+# not attempt to run execution tests if the hardware doesn't support it.\n+if {[istarget arm*-*-*]} then {\n+    if {![check_effective_target_arm_neon_ok]} then {\n+      return\n+    }\n+    if {![is-effective-target arm_neon_hw]} then {\n+        set dg-do-what-default compile\n+    } else {\n+        set dg-do-what-default run\n+    }\n+} else {\n+    set dg-do-what-default run\n+}\n+\n+torture-init\n+set-torture-options $C_TORTURE_OPTIONS {{}} $LTO_TORTURE_OPTIONS\n+\n+# Make sure Neon flags are provided, if necessary.  Use fp16 if we can.\n+# Use fp16 arithmetic operations if the hardware supports it.\n+if {[check_effective_target_arm_v8_2a_fp16_neon_hw]} then {\n+  set additional_flags [add_options_for_arm_v8_2a_fp16_neon \"\"]\n+} elseif {[check_effective_target_arm_neon_fp16_ok]} then {\n+  set additional_flags [add_options_for_arm_neon_fp16 \"\"]\n+} else {\n+  set additional_flags [add_options_for_arm_neon \"\"]\n+}\n+\n+# Main loop.\n+gcc-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.C]] \\\n+\t       \"\" ${additional_flags}\n+\n+# All done.\n+set dg-do-what-default ${save-dg-do-what-default}\n+torture-finish\n+dg-finish"}, {"sha": "0cb5c89c74f94638fef6b79edbb8af69add5a55f", "filename": "gcc/testsuite/g++.target/aarch64/advsimd-intrinsics/pr98852.C", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1696fc1ea01d5c9dce96b5d3122921aab9308f59/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fadvsimd-intrinsics%2Fpr98852.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1696fc1ea01d5c9dce96b5d3122921aab9308f59/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fadvsimd-intrinsics%2Fpr98852.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fadvsimd-intrinsics%2Fpr98852.C?ref=1696fc1ea01d5c9dce96b5d3122921aab9308f59", "patch": "@@ -0,0 +1,110 @@\n+/* { dg-do compile } */\n+\n+#include <arm_neon.h>\n+\n+using int32_elt = __typeof(((int32x4_t *) nullptr)[0][0]);\n+using uint32_elt = __typeof(((uint32x4_t *) nullptr)[0][0]);\n+\n+typedef int32_elt gnu_int32x4_t __attribute__((vector_size(16)));\n+typedef uint32_elt gnu_uint32x4_t __attribute__((vector_size(16)));\n+\n+template<typename T> struct id;\n+template<> struct id<gnu_int32x4_t> { static const int value = 1; };\n+template<> struct id<gnu_uint32x4_t> { static const int value = 2; };\n+template<> struct id<int32x4_t> { static const int value = 3; };\n+template<> struct id<uint32x4_t> { static const int value = 4; };\n+\n+#define CHECK_TYPE(EXPR, TYPE) \\\n+  static_assert(id<decltype(EXPR)>::value == id<TYPE>::value, \"foo\")\n+\n+void\n+f (gnu_int32x4_t sg, gnu_uint32x4_t ug, int32x4_t sn, uint32x4_t un, bool c)\n+{\n+  CHECK_TYPE (sg, gnu_int32x4_t);\n+  CHECK_TYPE (ug, gnu_uint32x4_t);\n+  CHECK_TYPE (sn, int32x4_t);\n+  CHECK_TYPE (un, uint32x4_t);\n+\n+  CHECK_TYPE (sg + 1, gnu_int32x4_t);\n+  CHECK_TYPE (ug + 1, gnu_uint32x4_t);\n+  CHECK_TYPE (sn + 1, int32x4_t);\n+  CHECK_TYPE (un + 1, uint32x4_t);\n+\n+  CHECK_TYPE (1 + sg, gnu_int32x4_t);\n+  CHECK_TYPE (1 + ug, gnu_uint32x4_t);\n+  CHECK_TYPE (1 + sn, int32x4_t);\n+  CHECK_TYPE (1 + un, uint32x4_t);\n+\n+  CHECK_TYPE (sg + sg, gnu_int32x4_t);\n+  CHECK_TYPE (ug + ug, gnu_uint32x4_t);\n+  CHECK_TYPE (sn + sn, int32x4_t);\n+  CHECK_TYPE (un + un, uint32x4_t);\n+\n+  // In C++, unlike C, the behavior is to prefer unsigned types over\n+  // signed types.\n+  CHECK_TYPE (sg + ug, gnu_uint32x4_t);\n+  CHECK_TYPE (ug + sg, gnu_uint32x4_t);\n+  CHECK_TYPE (sn + un, uint32x4_t);\n+  CHECK_TYPE (un + sn, uint32x4_t);\n+\n+  // That being the case, it seems more consistent to do the same thing\n+  // for mixed GNU and arm_neon.h operations.\n+  CHECK_TYPE (sg + un, uint32x4_t);\n+  CHECK_TYPE (un + sg, uint32x4_t);\n+  CHECK_TYPE (sn + ug, gnu_uint32x4_t);\n+  CHECK_TYPE (ug + sn, gnu_uint32x4_t);\n+\n+  // If the types have the same signedness, the traditional behavior is\n+  // to pick the first type if it is unsigned and the second type otherwise.\n+  // This is not necessarily sensible, but dates back to at least GCC 9.1.\n+  // We could probably change it.\n+  CHECK_TYPE (sg + sn, int32x4_t);\n+  CHECK_TYPE (sn + sg, gnu_int32x4_t);\n+  CHECK_TYPE (un + ug, uint32x4_t);\n+  CHECK_TYPE (ug + un, gnu_uint32x4_t);\n+\n+  CHECK_TYPE (c ? sg + sg : sg, gnu_int32x4_t);\n+  CHECK_TYPE (c ? ug + ug : ug, gnu_uint32x4_t);\n+  CHECK_TYPE (c ? sn + sn : sn, int32x4_t);\n+  CHECK_TYPE (c ? un + un : un, uint32x4_t);\n+\n+  CHECK_TYPE (c ? sg + 1 : sg, gnu_int32x4_t);\n+  CHECK_TYPE (c ? ug + 1 : ug, gnu_uint32x4_t);\n+  CHECK_TYPE (c ? sn + 1 : sn, int32x4_t);\n+  CHECK_TYPE (c ? un + 1 : un, uint32x4_t);\n+\n+  CHECK_TYPE (c ? 1 + sg : sg, gnu_int32x4_t);\n+  CHECK_TYPE (c ? 1 + ug : ug, gnu_uint32x4_t);\n+  CHECK_TYPE (c ? 1 + sn : sn, int32x4_t);\n+  CHECK_TYPE (c ? 1 + un : un, uint32x4_t);\n+\n+  CHECK_TYPE (c ? sg : sg + sg, gnu_int32x4_t);\n+  CHECK_TYPE (c ? ug : ug + ug, gnu_uint32x4_t);\n+  CHECK_TYPE (c ? sn : sn + sn, int32x4_t);\n+  CHECK_TYPE (c ? un : un + un, uint32x4_t);\n+\n+  CHECK_TYPE (c ? sg : sg + 1, gnu_int32x4_t);\n+  CHECK_TYPE (c ? ug : ug + 1, gnu_uint32x4_t);\n+  CHECK_TYPE (c ? sn : sn + 1, int32x4_t);\n+  CHECK_TYPE (c ? un : un + 1, uint32x4_t);\n+\n+  CHECK_TYPE (c ? sg : 1 + sg, gnu_int32x4_t);\n+  CHECK_TYPE (c ? ug : 1 + ug, gnu_uint32x4_t);\n+  CHECK_TYPE (c ? sn : 1 + sn, int32x4_t);\n+  CHECK_TYPE (c ? un : 1 + un, uint32x4_t);\n+\n+  CHECK_TYPE (c ? sg + sg : sg + sg, gnu_int32x4_t);\n+  CHECK_TYPE (c ? ug + ug : ug + ug, gnu_uint32x4_t);\n+  CHECK_TYPE (c ? sn + sn : sn + sn, int32x4_t);\n+  CHECK_TYPE (c ? un + un : un + un, uint32x4_t);\n+\n+  CHECK_TYPE (c ? sg + sg : sg + 1, gnu_int32x4_t);\n+  CHECK_TYPE (c ? ug + ug : ug + 1, gnu_uint32x4_t);\n+  CHECK_TYPE (c ? sn + sn : sn + 1, int32x4_t);\n+  CHECK_TYPE (c ? un + un : un + 1, uint32x4_t);\n+\n+  CHECK_TYPE (c ? 1 + sg : sg + sg, gnu_int32x4_t);\n+  CHECK_TYPE (c ? 1 + ug : ug + ug, gnu_uint32x4_t);\n+  CHECK_TYPE (c ? 1 + sn : sn + sn, int32x4_t);\n+  CHECK_TYPE (c ? 1 + un : un + un, uint32x4_t);\n+}"}]}