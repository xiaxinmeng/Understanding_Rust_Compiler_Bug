{"sha": "5456f30d92062d234208cd8634e54787f6e2664f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTQ1NmYzMGQ5MjA2MmQyMzQyMDhjZDg2MzRlNTQ3ODdmNmUyNjY0Zg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-11-28T18:08:21Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-11-28T18:08:21Z"}, "message": "compiler: inline functions with assignments and return statements\n    \n    Support inlining functions that contain only assignments and return\n    statements, with expressions of either constants or parameters.\n    Functions that contain other kinds of statements or expressions are\n    not yet inlined.  With this change, about 100 functions in the\n    standard library are inlinable.\n    \n    Reviewed-on: https://go-review.googlesource.com/c/150073\n\nFrom-SVN: r266573", "tree": {"sha": "023b9e1979b33d40c37b642607932fe34787f69a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/023b9e1979b33d40c37b642607932fe34787f69a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5456f30d92062d234208cd8634e54787f6e2664f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5456f30d92062d234208cd8634e54787f6e2664f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5456f30d92062d234208cd8634e54787f6e2664f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5456f30d92062d234208cd8634e54787f6e2664f/comments", "author": null, "committer": null, "parents": [{"sha": "85041a5b7755dc7b9d74b183e933d89152997886", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85041a5b7755dc7b9d74b183e933d89152997886", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85041a5b7755dc7b9d74b183e933d89152997886"}], "stats": {"total": 200, "additions": 193, "deletions": 7}, "files": [{"sha": "74806a23cbeedee124d53c8c2b98c778a90841a1", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5456f30d92062d234208cd8634e54787f6e2664f/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5456f30d92062d234208cd8634e54787f6e2664f/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=5456f30d92062d234208cd8634e54787f6e2664f", "patch": "@@ -1,4 +1,4 @@\n-b013405f2c66596c47cb9be493c798db1087c0f0\n+a8f768d68760768da5e86a8e63ef1ad5691c3ae8\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "7c464ce7f54dae73ece5169a9e46882faeafd1bc", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 100, "deletions": 2, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5456f30d92062d234208cd8634e54787f6e2664f/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5456f30d92062d234208cd8634e54787f6e2664f/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=5456f30d92062d234208cd8634e54787f6e2664f", "patch": "@@ -786,6 +786,31 @@ Var_expression::do_address_taken(bool escapes)\n     }\n }\n \n+// The cost to inline a variable reference.  We currently only support\n+// references to parameters.\n+\n+int\n+Var_expression::do_inlining_cost() const\n+{\n+  if (this->variable_->is_variable())\n+    {\n+      if (this->variable_->var_value()->is_parameter())\n+\treturn 1;\n+    }\n+  else if (this->variable_->is_result_variable())\n+    return 1;\n+\n+  return 0x100000;\n+}\n+\n+// Export a reference to a variable.\n+\n+void\n+Var_expression::do_export(Export_function_body* efb) const\n+{\n+  efb->write_string(Gogo::unpack_hidden_name(this->variable_->name()));\n+}\n+\n // Get the backend representation for a reference to a variable.\n \n Bexpression*\n@@ -1608,6 +1633,10 @@ class Boolean_expression : public Expression\n   do_get_backend(Translate_context* context)\n   { return context->backend()->boolean_constant_expression(this->val_); }\n \n+  int\n+  do_inlining_cost() const\n+  { return 1; }\n+\n   void\n   do_export(Export_function_body* efb) const\n   { efb->write_c_string(this->val_ ? \"$true\" : \"$false\"); }\n@@ -1997,6 +2026,10 @@ class Integer_expression : public Expression\n \t\t\t\t\tthis->location());\n   }\n \n+  int\n+  do_inlining_cost() const\n+  { return 1; }\n+\n   void\n   do_export(Export_function_body*) const;\n \n@@ -2408,6 +2441,10 @@ class Float_expression : public Expression\n   Bexpression*\n   do_get_backend(Translate_context*);\n \n+  int\n+  do_inlining_cost() const\n+  { return 1; }\n+\n   void\n   do_export(Export_function_body*) const;\n \n@@ -2617,6 +2654,10 @@ class Complex_expression : public Expression\n   Bexpression*\n   do_get_backend(Translate_context*);\n \n+  int\n+  do_inlining_cost() const\n+  { return 2; }\n+\n   void\n   do_export(Export_function_body*) const;\n \n@@ -3204,6 +3245,10 @@ class Nil_expression : public Expression\n   do_get_backend(Translate_context* context)\n   { return context->backend()->nil_pointer_expression(); }\n \n+  int\n+  do_inlining_cost() const\n+  { return 1; }\n+\n   void\n   do_export(Export_function_body* efb) const\n   { efb->write_c_string(\"$nil\"); }\n@@ -3654,6 +3699,25 @@ Type_conversion_expression::do_get_backend(Translate_context* context)\n     }\n }\n \n+// Cost of inlining a type conversion.\n+\n+int\n+Type_conversion_expression::do_inlining_cost() const\n+{\n+  Type* type = this->type_;\n+  Type* expr_type = this->expr_->type();\n+  if (type->interface_type() != NULL || expr_type->interface_type() != NULL)\n+    return 10;\n+  else if (type->is_string_type() && expr_type->integer_type() != NULL)\n+    return 10;\n+  else if (type->is_string_type() && expr_type->is_slice_type())\n+    return 10;\n+  else if (type->is_slice_type() && expr_type->is_string_type())\n+    return 10;\n+  else\n+    return 1;\n+}\n+\n // Output a type conversion in a constant expression.\n \n void\n@@ -4677,7 +4741,11 @@ Unary_expression::do_export(Export_function_body* efb) const\n       efb->write_c_string(\"^\");\n       break;\n     case OPERATOR_AND:\n+      efb->write_c_string(\"&\");\n+      break;\n     case OPERATOR_MULT:\n+      efb->write_c_string(\"*\");\n+      break;\n     default:\n       go_unreachable();\n     }\n@@ -4704,6 +4772,12 @@ Unary_expression::do_import(Import_expression* imp, Location loc)\n     case '^':\n       op = OPERATOR_XOR;\n       break;\n+    case '&':\n+      op = OPERATOR_AND;\n+      break;\n+    case '*':\n+      op = OPERATOR_MULT;\n+      break;\n     default:\n       go_unreachable();\n     }\n@@ -16195,7 +16269,7 @@ Expression*\n Expression::import_expression(Import_expression* imp, Location loc)\n {\n   int c = imp->peek_char();\n-  if (c == '+' || c == '-' || c == '!' || c == '^')\n+  if (c == '+' || c == '-' || c == '!' || c == '^' || c == '&' || c == '*')\n     return Unary_expression::do_import(imp, loc);\n   else if (c == '(')\n     return Binary_expression::do_import(imp, loc);\n@@ -16220,11 +16294,35 @@ Expression::import_expression(Import_expression* imp, Location loc)\n \t   || (imp->version() < EXPORT_FORMAT_V3\n \t       && imp->match_c_string(\"convert\")))\n     return Type_conversion_expression::do_import(imp, loc);\n-  else\n+\n+  Import_function_body* ifb = imp->ifb();\n+  if (ifb == NULL)\n     {\n       go_error_at(imp->location(), \"import error: expected expression\");\n       return Expression::make_error(loc);\n     }\n+  if (ifb->saw_error())\n+    return Expression::make_error(loc);\n+  std::string id = ifb->read_identifier();\n+  if (id.empty())\n+    {\n+      if (!ifb->saw_error())\n+\tgo_error_at(imp->location(),\n+\t\t    \"import error: expected identifier at %lu\",\n+\t\t    static_cast<unsigned long>(ifb->off()));\n+      ifb->set_saw_error();\n+      return Expression::make_error(loc);\n+    }\n+  Named_object* var = ifb->block()->bindings()->lookup(id);\n+  if (var == NULL)\n+    {\n+      if (!ifb->saw_error())\n+\tgo_error_at(imp->location(), \"import error: lookup of %qs failed\",\n+\t\t    id.c_str());\n+      ifb->set_saw_error();\n+      return Expression::make_error(loc);\n+    }\n+  return Expression::make_var_reference(var, loc);\n }\n \n // Class Expression_list."}, {"sha": "a18322cfb91a4866e3dc14f5a7b16ec50e962a80", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5456f30d92062d234208cd8634e54787f6e2664f/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5456f30d92062d234208cd8634e54787f6e2664f/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=5456f30d92062d234208cd8634e54787f6e2664f", "patch": "@@ -941,7 +941,7 @@ class Expression\n \n   // Return the cost of this statement for inlining purposes.\n   int\n-  inlining_cost()\n+  inlining_cost() const\n   { return this->do_inlining_cost(); }\n \n   // Return whether the expression is addressable--something which may\n@@ -1093,7 +1093,7 @@ class Expression\n   // inlining.  The default cost is high, so we only need to define\n   // this method for expressions that can be inlined.\n   virtual int\n-  do_inlining_cost()\n+  do_inlining_cost() const\n   { return 0x100000; }\n \n   // Child class implements whether the expression is addressable.\n@@ -1355,6 +1355,12 @@ class Var_expression : public Expression\n   do_copy()\n   { return this; }\n \n+  int\n+  do_inlining_cost() const;\n+\n+  void\n+  do_export(Export_function_body*) const;\n+\n   bool\n   do_is_addressable() const\n   { return true; }\n@@ -1602,6 +1608,12 @@ class String_expression : public Expression\n   static void\n   export_string(String_dump* exp, const String_expression* str);\n \n+  // Set the inlining cost a bit high since inlining may cause\n+  // duplicated string literals.\n+  int\n+  do_inlining_cost() const\n+  { return 5; }\n+\n   void\n   do_export(Export_function_body*) const;\n \n@@ -1686,6 +1698,9 @@ class Type_conversion_expression : public Expression\n   Bexpression*\n   do_get_backend(Translate_context* context);\n \n+  int\n+  do_inlining_cost() const;\n+\n   void\n   do_export(Export_function_body*) const;\n \n@@ -1877,6 +1892,10 @@ class Unary_expression : public Expression\n   Bexpression*\n   do_get_backend(Translate_context*);\n \n+  int\n+  do_inlining_cost() const\n+  { return 1; }\n+\n   void\n   do_export(Export_function_body*) const;\n \n@@ -2022,6 +2041,10 @@ class Binary_expression : public Expression\n   Bexpression*\n   do_get_backend(Translate_context*);\n \n+  int\n+  do_inlining_cost() const\n+  { return 1; }\n+\n   void\n   do_export(Export_function_body*) const;\n "}, {"sha": "4d10f60e6c201f878ef00b5ca1f21f30ccb3d0ed", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 53, "deletions": 2, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5456f30d92062d234208cd8634e54787f6e2664f/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5456f30d92062d234208cd8634e54787f6e2664f/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=5456f30d92062d234208cd8634e54787f6e2664f", "patch": "@@ -12,6 +12,7 @@\n #include \"expressions.h\"\n #include \"gogo.h\"\n #include \"export.h\"\n+#include \"import.h\"\n #include \"runtime.h\"\n #include \"backend.h\"\n #include \"statements.h\"\n@@ -124,9 +125,41 @@ Statement::determine_types()\n // Read a statement from export data.\n \n Statement*\n-Statement::import_statement(Import_function_body*, Location)\n+Statement::import_statement(Import_function_body* ifb, Location loc)\n {\n-  go_unreachable();\n+  if (ifb->match_c_string(\"{\"))\n+    {\n+      size_t nl = ifb->body().find('\\n', ifb->off());\n+      if (nl == std::string::npos)\n+\t{\n+\t  if (!ifb->saw_error())\n+\t    go_error_at(ifb->location(),\n+\t\t\t\"import error: no newline after { at %lu\",\n+\t\t\tstatic_cast<unsigned long>(ifb->off()));\n+\t  ifb->set_saw_error();\n+\t  return Statement::make_error_statement(loc);\n+\t}\n+      ifb->set_off(nl + 1);\n+      ifb->increment_indent();\n+      Block* block = new Block(ifb->block(), loc);\n+      bool ok = Block::import_block(block, ifb, loc);\n+      ifb->decrement_indent();\n+      if (!ok)\n+\treturn Statement::make_error_statement(loc);\n+      return Statement::make_block_statement(block, loc);\n+    }\n+  else if (ifb->match_c_string(\"return\"))\n+    {\n+      // After lowering return statements have no expressions.  The\n+      // return expressions are assigned to result parameters.\n+      ifb->advance(6);\n+      return Statement::make_return_statement(NULL, loc);\n+    }\n+\n+  Expression* lhs = Expression::import_expression(ifb, loc);\n+  ifb->require_c_string(\" = \");\n+  Expression* rhs = Expression::import_expression(ifb, loc);\n+  return Statement::make_assignment(lhs, rhs, loc);\n }\n \n // If this is a thunk statement, return it.\n@@ -834,6 +867,14 @@ Assignment_statement::do_check_types(Gogo*)\n     this->set_is_error();\n }\n \n+void\n+Assignment_statement::do_export_statement(Export_function_body* efb)\n+{\n+  this->lhs_->export_expression(efb);\n+  efb->write_c_string(\" = \");\n+  this->rhs_->export_expression(efb);\n+}\n+\n // Flatten an assignment statement.  We may need a temporary for\n // interface conversion.\n \n@@ -2844,6 +2885,16 @@ Return_statement::do_get_backend(Translate_context* context)\n \t\t\t\t\t      retvals, loc);\n }\n \n+// Export a return statement.  At this point all the expressions have\n+// been converted to assignments to the result variables, so this is\n+// simple.\n+\n+void\n+Return_statement::do_export_statement(Export_function_body* efb)\n+{\n+  efb->write_c_string(\"return\");\n+}\n+\n // Dump the AST representation for a return statement.\n \n void"}, {"sha": "621d301fb8229b96cdb81074f122f09503f4fffb", "filename": "gcc/go/gofrontend/statements.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5456f30d92062d234208cd8634e54787f6e2664f/gcc%2Fgo%2Fgofrontend%2Fstatements.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5456f30d92062d234208cd8634e54787f6e2664f/gcc%2Fgo%2Fgofrontend%2Fstatements.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.h?ref=5456f30d92062d234208cd8634e54787f6e2664f", "patch": "@@ -631,6 +631,13 @@ class Assignment_statement : public Statement\n   void\n   do_check_types(Gogo*);\n \n+  int\n+  do_inlining_cost()\n+  { return 1; }\n+\n+  void\n+  do_export_statement(Export_function_body*);\n+\n   Statement*\n   do_flatten(Gogo*, Named_object*, Block*, Statement_inserter*);\n \n@@ -792,6 +799,13 @@ class Return_statement : public Statement\n   do_may_fall_through() const\n   { return false; }\n \n+  int\n+  do_inlining_cost()\n+  { return 1; }\n+\n+  void\n+  do_export_statement(Export_function_body*);\n+\n   Bstatement*\n   do_get_backend(Translate_context*);\n "}]}