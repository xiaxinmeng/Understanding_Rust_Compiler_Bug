{"sha": "640019aa4895ac391004e6531d4b6d984d7ed76d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjQwMDE5YWE0ODk1YWMzOTEwMDRlNjUzMWQ0YjZkOTg0ZDdlZDc2ZA==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2005-01-12T20:01:38Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2005-01-12T20:01:38Z"}, "message": "function.c (assign_parm_setup_block): Relax condition on multi-register optimization.\n\n\t* function.c (assign_parm_setup_block): Relax condition on\n\tmulti-register optimization.\n\nFrom-SVN: r93233", "tree": {"sha": "751aa24e56badee11aabd22e90f4af5e94f6c541", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/751aa24e56badee11aabd22e90f4af5e94f6c541"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/640019aa4895ac391004e6531d4b6d984d7ed76d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/640019aa4895ac391004e6531d4b6d984d7ed76d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/640019aa4895ac391004e6531d4b6d984d7ed76d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/640019aa4895ac391004e6531d4b6d984d7ed76d/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "88910b6aed500381951290498ee07ac0e5551701", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88910b6aed500381951290498ee07ac0e5551701", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88910b6aed500381951290498ee07ac0e5551701"}], "stats": {"total": 66, "additions": 38, "deletions": 28}, "files": [{"sha": "61d48463dadb3536ed25b940385df109cb5496e3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/640019aa4895ac391004e6531d4b6d984d7ed76d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/640019aa4895ac391004e6531d4b6d984d7ed76d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=640019aa4895ac391004e6531d4b6d984d7ed76d", "patch": "@@ -1,3 +1,8 @@\n+2005-01-12  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* function.c (assign_parm_setup_block): Relax condition on\n+\tmulti-register optimization.\n+\n 2005-01-12  Nick Clifton  <nickc@redhat.com>\n \n \t* config/sh/sh.md (udivsi3_sh2a, divsi3_sh2a): Give these patterns"}, {"sha": "4f1fc1a5e7e56d59adb80e98326509dd167da4d8", "filename": "gcc/function.c", "status": "modified", "additions": 33, "deletions": 28, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/640019aa4895ac391004e6531d4b6d984d7ed76d/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/640019aa4895ac391004e6531d4b6d984d7ed76d/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=640019aa4895ac391004e6531d4b6d984d7ed76d", "patch": "@@ -2560,42 +2560,47 @@ assign_parm_setup_block (struct assign_parm_data_all *all,\n   /* If we've a non-block object that's nevertheless passed in parts,\n      reconstitute it in register operations rather than on the stack.  */\n   if (GET_CODE (entry_parm) == PARALLEL\n-      && data->nominal_mode != BLKmode\n-      && XVECLEN (entry_parm, 0) > 1\n-      && use_register_for_decl (parm))\n+      && data->nominal_mode != BLKmode)\n     {\n-      rtx parmreg = gen_reg_rtx (data->nominal_mode);\n+      rtx elt0 = XEXP (XVECEXP (entry_parm, 0, 0), 0);\n \n-      push_to_sequence (all->conversion_insns);\n+      if ((XVECLEN (entry_parm, 0) > 1\n+\t   || hard_regno_nregs[REGNO (elt0)][GET_MODE (elt0)] > 1)\n+\t  && use_register_for_decl (parm))\n+\t{\n+\t  rtx parmreg = gen_reg_rtx (data->nominal_mode);\n \n-      /* For values returned in multiple registers, handle possible\n-\t incompatible calls to emit_group_store.\n+\t  push_to_sequence (all->conversion_insns);\n \n-\t For example, the following would be invalid, and would have to\n-\t be fixed by the conditional below:\n+\t  /* For values returned in multiple registers, handle possible\n+\t     incompatible calls to emit_group_store.\n \n-\t   emit_group_store ((reg:SF), (parallel:DF))\n-\t   emit_group_store ((reg:SI), (parallel:DI))\n+\t     For example, the following would be invalid, and would have to\n+\t     be fixed by the conditional below:\n \n-\t An example of this are doubles in e500 v2:\n-\t   (parallel:DF (expr_list (reg:SI) (const_int 0))\n-\t                (expr_list (reg:SI) (const_int 4))).  */\n-      if (data->nominal_mode != data->passed_mode)\n-\t{\n-\t  rtx t = gen_reg_rtx (GET_MODE (entry_parm));\n-\t  emit_group_store (t, entry_parm, NULL_TREE,\n-\t\t\t    GET_MODE_SIZE (GET_MODE (entry_parm)));\n-\t  convert_move (parmreg, t, 0);\n-\t}\n-      else\n-\temit_group_store (parmreg, entry_parm, data->nominal_type,\n-\t\t\t  int_size_in_bytes (data->nominal_type));\n+\t     emit_group_store ((reg:SF), (parallel:DF))\n+\t     emit_group_store ((reg:SI), (parallel:DI))\n \n-      all->conversion_insns = get_insns ();\n-      end_sequence ();\n+\t     An example of this are doubles in e500 v2:\n+\t     (parallel:DF (expr_list (reg:SI) (const_int 0))\n+\t     (expr_list (reg:SI) (const_int 4))).  */\n+\t  if (data->nominal_mode != data->passed_mode)\n+\t    {\n+\t      rtx t = gen_reg_rtx (GET_MODE (entry_parm));\n+\t      emit_group_store (t, entry_parm, NULL_TREE,\n+\t\t\t\tGET_MODE_SIZE (GET_MODE (entry_parm)));\n+\t      convert_move (parmreg, t, 0);\n+\t    }\n+\t  else\n+\t    emit_group_store (parmreg, entry_parm, data->nominal_type,\n+\t\t\t      int_size_in_bytes (data->nominal_type));\n \n-      SET_DECL_RTL (parm, parmreg);\n-      return;\n+\t  all->conversion_insns = get_insns ();\n+\t  end_sequence ();\n+\n+\t  SET_DECL_RTL (parm, parmreg);\n+\t  return;\n+\t}\n     }\n \n   size = int_size_in_bytes (data->passed_type);"}]}