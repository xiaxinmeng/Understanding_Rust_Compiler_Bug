{"sha": "7185ec2cb42ab0a15d9c97122f6c55ebdc5d2971", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzE4NWVjMmNiNDJhYjBhMTVkOWM5NzEyMmY2YzU1ZWJkYzVkMjk3MQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-03-08T23:27:13Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-03-08T23:27:13Z"}, "message": "varasm.c (function_section_1): Use definition_alignment.\n\n\n\t* varasm.c (function_section_1): Use definition_alignment.\n\t(assemble_start_function): Likewise.\n\t(emit_local): likewise.\n\t(build_constant_desc): Likewsie.\n\t(output_constant_def_contents): Likewise.\n\t(place_block_symbol): Likewise.\n\t(output_object_block): Likewise.\n\nFrom-SVN: r221269", "tree": {"sha": "c51d6186380d90e2e922a5d6599235eca3f3c09b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c51d6186380d90e2e922a5d6599235eca3f3c09b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7185ec2cb42ab0a15d9c97122f6c55ebdc5d2971", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7185ec2cb42ab0a15d9c97122f6c55ebdc5d2971", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7185ec2cb42ab0a15d9c97122f6c55ebdc5d2971", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7185ec2cb42ab0a15d9c97122f6c55ebdc5d2971/comments", "author": null, "committer": null, "parents": [{"sha": "428f0c67ee75be486ccdbc83bae06cebec2bdb0f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/428f0c67ee75be486ccdbc83bae06cebec2bdb0f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/428f0c67ee75be486ccdbc83bae06cebec2bdb0f"}], "stats": {"total": 44, "additions": 32, "deletions": 12}, "files": [{"sha": "ddb3323ee60ec688e8c1bd71b201050f51f32def", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7185ec2cb42ab0a15d9c97122f6c55ebdc5d2971/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7185ec2cb42ab0a15d9c97122f6c55ebdc5d2971/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7185ec2cb42ab0a15d9c97122f6c55ebdc5d2971", "patch": "@@ -10,6 +10,13 @@\n \tcan_increase_alignment_p.\n \t* tree-vectorizer.c (increase_alignment): Use increase_alignment.\n \t* tree-vect-stmts.c (ensure_base_align): Likewise.\n+\t* varasm.c (function_section_1): Use definition_alignment.\n+\t(assemble_start_function): Likewise.\n+\t(emit_local): likewise.\n+\t(build_constant_desc): Likewsie.\n+\t(output_constant_def_contents): Likewise.\n+\t(place_block_symbol): Likewise.\n+\t(output_object_block): Likewise.\n \n 2015-03-05  Jan Hubicka  <hubicka@ucw.cz>\n "}, {"sha": "5fa6e4c3de479e070f886c960d5556ded8f970ff", "filename": "gcc/varasm.c", "status": "modified", "additions": 25, "deletions": 12, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7185ec2cb42ab0a15d9c97122f6c55ebdc5d2971/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7185ec2cb42ab0a15d9c97122f6c55ebdc5d2971/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=7185ec2cb42ab0a15d9c97122f6c55ebdc5d2971", "patch": "@@ -659,7 +659,7 @@ function_section_1 (tree decl, bool force_cold)\n   else\n     return targetm.asm_out.select_section\n \t    (decl, freq == NODE_FREQUENCY_UNLIKELY_EXECUTED,\n-\t     DECL_ALIGN (decl));\n+\t     symtab_node::get (decl)->definition_alignment ());\n #else\n   if (targetm.asm_out.function_section)\n     section = targetm.asm_out.function_section (decl, freq, startup, exit);\n@@ -1740,6 +1740,8 @@ assemble_start_function (tree decl, const char *fnname)\n   if (CONSTANT_POOL_BEFORE_FUNCTION)\n     output_constant_pool (fnname, decl);\n \n+  align = symtab_node::get (decl)->definition_alignment ();\n+\n   /* Make sure the not and cold text (code) sections are properly\n      aligned.  This is necessary here in the case where the function\n      has both hot and cold sections, because we don't want to re-set\n@@ -1750,7 +1752,7 @@ assemble_start_function (tree decl, const char *fnname)\n       first_function_block_is_cold = false;\n \n       switch_to_section (unlikely_text_section ());\n-      assemble_align (DECL_ALIGN (decl));\n+      assemble_align (align);\n       ASM_OUTPUT_LABEL (asm_out_file, crtl->subsections.cold_section_label);\n \n       /* When the function starts with a cold section, we need to explicitly\n@@ -1760,7 +1762,7 @@ assemble_start_function (tree decl, const char *fnname)\n \t  && BB_PARTITION (ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb) == BB_COLD_PARTITION)\n \t{\n \t  switch_to_section (text_section);\n-\t  assemble_align (DECL_ALIGN (decl));\n+\t  assemble_align (align);\n \t  ASM_OUTPUT_LABEL (asm_out_file, crtl->subsections.hot_section_label);\n \t  hot_label_written = true;\n \t  first_function_block_is_cold = true;\n@@ -1777,7 +1779,7 @@ assemble_start_function (tree decl, const char *fnname)\n     ASM_OUTPUT_LABEL (asm_out_file, crtl->subsections.hot_section_label);\n \n   /* Tell assembler to move to target machine's alignment for functions.  */\n-  align = floor_log2 (DECL_ALIGN (decl) / BITS_PER_UNIT);\n+  align = floor_log2 (align / BITS_PER_UNIT);\n   if (align > 0)\n     {\n       ASM_OUTPUT_ALIGN (asm_out_file, align);\n@@ -1931,17 +1933,18 @@ assemble_string (const char *p, int size)\n /* A noswitch_section_callback for lcomm_section.  */\n \n static bool\n-emit_local (tree decl ATTRIBUTE_UNUSED,\n+emit_local (tree decl,\n \t    const char *name ATTRIBUTE_UNUSED,\n \t    unsigned HOST_WIDE_INT size ATTRIBUTE_UNUSED,\n \t    unsigned HOST_WIDE_INT rounded ATTRIBUTE_UNUSED)\n {\n+  int align = symtab_node::get (decl)->definition_alignment ();\n #if defined ASM_OUTPUT_ALIGNED_DECL_LOCAL\n   ASM_OUTPUT_ALIGNED_DECL_LOCAL (asm_out_file, decl, name,\n-\t\t\t\t size, DECL_ALIGN (decl));\n+\t\t\t\t size, align);\n   return true;\n #elif defined ASM_OUTPUT_ALIGNED_LOCAL\n-  ASM_OUTPUT_ALIGNED_LOCAL (asm_out_file, name, size, DECL_ALIGN (decl));\n+  ASM_OUTPUT_ALIGNED_LOCAL (asm_out_file, name, size, align);\n   return true;\n #else\n   ASM_OUTPUT_LOCAL (asm_out_file, name, size, rounded);\n@@ -3295,7 +3298,12 @@ build_constant_desc (tree exp)\n   /* Now construct the SYMBOL_REF and the MEM.  */\n   if (use_object_blocks_p ())\n     {\n-      section *sect = get_constant_section (exp, DECL_ALIGN (decl));\n+      int align = (TREE_CODE (decl) == CONST_DECL\n+\t\t   || (TREE_CODE (decl) == VAR_DECL\n+\t\t       && DECL_IN_CONSTANT_POOL (decl))\n+\t\t   ? DECL_ALIGN (decl)\n+\t\t   : symtab_node::get (decl)->definition_alignment ());\n+      section *sect = get_constant_section (exp, align);\n       symbol = create_block_symbol (ggc_strdup (label),\n \t\t\t\t    get_block_for_section (sect), -1);\n     }\n@@ -3423,7 +3431,6 @@ output_constant_def_contents (rtx symbol)\n {\n   tree decl = SYMBOL_REF_DECL (symbol);\n   tree exp = DECL_INITIAL (decl);\n-  unsigned int align;\n   bool asan_protected = false;\n \n   /* Make sure any other constants whose addresses appear in EXP\n@@ -3449,7 +3456,11 @@ output_constant_def_contents (rtx symbol)\n     place_block_symbol (symbol);\n   else\n     {\n-      align = DECL_ALIGN (decl);\n+      int align = (TREE_CODE (decl) == CONST_DECL\n+\t\t   || (TREE_CODE (decl) == VAR_DECL\n+\t\t       && DECL_IN_CONSTANT_POOL (decl))\n+\t\t   ? DECL_ALIGN (decl)\n+\t\t   : symtab_node::get (decl)->definition_alignment ());\n       switch_to_section (get_constant_section (exp, align));\n       if (align > BITS_PER_UNIT)\n \tASM_OUTPUT_ALIGN (asm_out_file, floor_log2 (align / BITS_PER_UNIT));\n@@ -7159,6 +7170,7 @@ place_block_symbol (rtx symbol)\n   else if (TREE_CONSTANT_POOL_ADDRESS_P (symbol))\n     {\n       decl = SYMBOL_REF_DECL (symbol);\n+      gcc_checking_assert (DECL_IN_CONSTANT_POOL (decl));\n       alignment = DECL_ALIGN (decl);\n       size = get_constant_size (DECL_INITIAL (decl));\n       if ((flag_sanitize & SANITIZE_ADDRESS)\n@@ -7333,8 +7345,9 @@ output_object_block (struct object_block *block)\n \t{\n \t  HOST_WIDE_INT size;\n \t  decl = SYMBOL_REF_DECL (symbol);\n-\t  assemble_constant_contents (DECL_INITIAL (decl), XSTR (symbol, 0),\n-\t\t\t\t      DECL_ALIGN (decl));\n+\t  assemble_constant_contents\n+\t       (DECL_INITIAL (decl), XSTR (symbol, 0), DECL_ALIGN (decl));\n+\n \t  size = get_constant_size (DECL_INITIAL (decl));\n \t  offset += size;\n \t  if ((flag_sanitize & SANITIZE_ADDRESS)"}]}