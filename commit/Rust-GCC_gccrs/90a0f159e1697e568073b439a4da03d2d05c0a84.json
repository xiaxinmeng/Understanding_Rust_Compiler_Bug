{"sha": "90a0f159e1697e568073b439a4da03d2d05c0a84", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTBhMGYxNTllMTY5N2U1NjgwNzNiNDM5YTRkYTAzZDJkMDVjMGE4NA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@codesourcery.com", "date": "2006-12-28T06:44:53Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2006-12-28T06:44:53Z"}, "message": "Makefile.in (OBJS-common): Remove conflict.o\n\n\t* Makefile.in (OBJS-common): Remove conflict.o\n\t(conflict.o): Remove.\n\t* basic-block.h: Remove the prototypes for conflict.c.\n\t* conflict.c: Remove.\n\nFrom-SVN: r120238", "tree": {"sha": "94c8774639b2a1ad4fd43ee3064652e4f9ef9551", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/94c8774639b2a1ad4fd43ee3064652e4f9ef9551"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/90a0f159e1697e568073b439a4da03d2d05c0a84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90a0f159e1697e568073b439a4da03d2d05c0a84", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90a0f159e1697e568073b439a4da03d2d05c0a84", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90a0f159e1697e568073b439a4da03d2d05c0a84/comments", "author": null, "committer": null, "parents": [{"sha": "97508a6b314c76302a6b71f3ca8c09488a6f2850", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97508a6b314c76302a6b71f3ca8c09488a6f2850", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97508a6b314c76302a6b71f3ca8c09488a6f2850"}], "stats": {"total": 395, "additions": 8, "deletions": 387}, "files": [{"sha": "4d6a49c9929f9bc5dfc064a8c091e1b11a266d6c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90a0f159e1697e568073b439a4da03d2d05c0a84/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90a0f159e1697e568073b439a4da03d2d05c0a84/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=90a0f159e1697e568073b439a4da03d2d05c0a84", "patch": "@@ -1,3 +1,10 @@\n+2006-12-28  Kazu Hirata  <kazu@codesourcery.com>\n+\n+\t* Makefile.in (OBJS-common): Remove conflict.o\n+\t(conflict.o): Remove.\n+\t* basic-block.h: Remove the prototypes for conflict.c.\n+\t* conflict.c: Remove.\n+\n 2006-12-27  Daniel Berlin  <dberlin@dberlin.org>\n \n \t* sbitmap.c (BITMAP_DEBUGGING): New macro."}, {"sha": "0e8ad7cc5d84dd853b53fc1753e7ddf0e8e10bb9", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90a0f159e1697e568073b439a4da03d2d05c0a84/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90a0f159e1697e568073b439a4da03d2d05c0a84/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=90a0f159e1697e568073b439a4da03d2d05c0a84", "patch": "@@ -993,7 +993,7 @@ OBJS-common = \\\n  alias.o bb-reorder.o bitmap.o builtins.o caller-save.o calls.o\t  \t   \\\n  cfg.o cfganal.o cfgbuild.o cfgcleanup.o cfglayout.o cfgloop.o\t\t   \\\n  cfgloopanal.o cfgloopmanip.o loop-init.o loop-unswitch.o loop-unroll.o\t   \\\n- cfgrtl.o combine.o conflict.o convert.o coverage.o cse.o cselib.o \t   \\\n+ cfgrtl.o combine.o convert.o coverage.o cse.o cselib.o \t\t   \\\n  dbxout.o ddg.o tree-ssa-loop-ch.o loop-invariant.o tree-ssa-loop-im.o\t   \\\n  debug.o df-core.o df-problems.o df-scan.o dfp.o diagnostic.o dojump.o     \\\n  dominance.o loop-doloop.o\t   \t\t\t\t\t   \\\n@@ -2411,8 +2411,6 @@ var-tracking.o : var-tracking.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(TREE_H) hard-reg-set.h insn-config.h reload.h $(FLAGS_H) \\\n    $(BASIC_BLOCK_H) output.h sbitmap.h alloc-pool.h $(FIBHEAP_H) $(HASHTAB_H) \\\n    $(REGS_H) $(EXPR_H) $(TIMEVAR_H) tree-pass.h\n-conflict.o : conflict.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(OBSTACK_H) \\\n-   $(HASHTAB_H) $(RTL_H) hard-reg-set.h $(BASIC_BLOCK_H)\n profile.o : profile.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TREE_H) $(FLAGS_H) output.h $(REGS_H) $(EXPR_H) $(FUNCTION_H) \\\n    toplev.h $(COVERAGE_H) $(TREE_FLOW_H) value-prof.h cfghooks.h \\"}, {"sha": "fedd4bbc7b865df66c546bdc1f2b1cb171f6b4f4", "filename": "gcc/basic-block.h", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90a0f159e1697e568073b439a4da03d2d05c0a84/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90a0f159e1697e568073b439a4da03d2d05c0a84/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=90a0f159e1697e568073b439a4da03d2d05c0a84", "patch": "@@ -920,25 +920,6 @@ extern bool cleanup_cfg (int);\n extern bool delete_unreachable_blocks (void);\n extern bool merge_seq_blocks (void);\n \n-typedef struct conflict_graph_def *conflict_graph;\n-\n-/* Callback function when enumerating conflicts.  The arguments are\n-   the smaller and larger regno in the conflict.  Returns zero if\n-   enumeration is to continue, nonzero to halt enumeration.  */\n-typedef int (*conflict_graph_enum_fn) (int, int, void *);\n-\n-\n-/* Prototypes of operations on conflict graphs.  */\n-\n-extern conflict_graph conflict_graph_new\n- (int);\n-extern void conflict_graph_delete (conflict_graph);\n-extern int conflict_graph_add (conflict_graph, int, int);\n-extern int conflict_graph_conflict_p (conflict_graph, int, int);\n-extern void conflict_graph_enum (conflict_graph, int, conflict_graph_enum_fn,\n-\t\t\t\t void *);\n-extern void conflict_graph_merge_regs (conflict_graph, int, int);\n-extern void conflict_graph_print (conflict_graph, FILE*);\n extern bool mark_dfs_back_edges (void);\n extern void set_edge_can_fallthru_flag (void);\n extern void update_br_prob_note (basic_block);"}, {"sha": "43f7860820e5f5aac461115dce1fdb0c879e58c3", "filename": "gcc/conflict.c", "status": "removed", "additions": 0, "deletions": 365, "changes": 365, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97508a6b314c76302a6b71f3ca8c09488a6f2850/gcc%2Fconflict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97508a6b314c76302a6b71f3ca8c09488a6f2850/gcc%2Fconflict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconflict.c?ref=97508a6b314c76302a6b71f3ca8c09488a6f2850", "patch": "@@ -1,365 +0,0 @@\n-/* Register conflict graph computation routines.\n-   Copyright (C) 2000, 2003, 2004, 2005 Free Software Foundation, Inc.\n-   Contributed by CodeSourcery, LLC\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 2, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to the Free\n-Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n-02110-1301, USA.  */\n-\n-/* References:\n-\n-   Building an Optimizing Compiler\n-   Robert Morgan\n-   Butterworth-Heinemann, 1998 */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"obstack.h\"\n-#include \"hashtab.h\"\n-#include \"rtl.h\"\n-#include \"hard-reg-set.h\"\n-#include \"basic-block.h\"\n-\n-/* A register conflict graph is an undirected graph containing nodes\n-   for some or all of the regs used in a function.  Arcs represent\n-   conflicts, i.e. two nodes are connected by an arc if there is a\n-   point in the function at which the regs corresponding to the two\n-   nodes are both live.\n-\n-   The conflict graph is represented by the data structures described\n-   in Morgan section 11.3.1.  Nodes are not stored explicitly; only\n-   arcs are.  An arc stores the numbers of the regs it connects.\n-\n-   Arcs can be located by two methods:\n-\n-     - The two reg numbers for each arc are hashed into a single\n-       value, and the arc is placed in a hash table according to this\n-       value.  This permits quick determination of whether a specific\n-       conflict is present in the graph.  \n-\n-     - Additionally, the arc data structures are threaded by a set of\n-       linked lists by single reg number.  Since each arc references\n-       two regs, there are two next pointers, one for the\n-       smaller-numbered reg and one for the larger-numbered reg.  This\n-       permits the quick enumeration of conflicts for a single\n-       register.\n-\n-   Arcs are allocated from an obstack.  */\n-\n-/* An arc in a conflict graph.  */\n-\n-struct conflict_graph_arc_def\n-{\n-  /* The next element of the list of conflicts involving the\n-     smaller-numbered reg, as an index in the table of arcs of this\n-     graph.   Contains NULL if this is the tail.  */\n-  struct conflict_graph_arc_def *smaller_next;\n-\n-  /* The next element of the list of conflicts involving the\n-     larger-numbered reg, as an index in the table of arcs of this\n-     graph.  Contains NULL if this is the tail.  */\n-  struct conflict_graph_arc_def *larger_next;\n-\n-  /* The smaller-numbered reg involved in this conflict.  */\n-  int smaller;\n-\n-  /* The larger-numbered reg involved in this conflict.  */\n-  int larger;\n-};\n-\n-typedef struct conflict_graph_arc_def *conflict_graph_arc;\n-typedef const struct conflict_graph_arc_def *const_conflict_graph_arc;\n-\n-\n-/* A conflict graph.  */\n-\n-struct conflict_graph_def\n-{\n-  /* A hash table of arcs.  Used to search for a specific conflict.  */\n-  htab_t arc_hash_table;\n-\n-  /* The number of regs this conflict graph handles.  */\n-  int num_regs;\n-\n-  /* For each reg, the arc at the head of a list that threads through\n-     all the arcs involving that reg.  An entry is NULL if no\n-     conflicts exist involving that reg.  */\n-  conflict_graph_arc *neighbor_heads;\n-\n-  /* Arcs are allocated from here.  */\n-  struct obstack arc_obstack;\n-};\n-\n-/* The initial capacity (number of conflict arcs) for newly-created\n-   conflict graphs.  */\n-#define INITIAL_ARC_CAPACITY 64\n-\n-\n-/* Computes the hash value of the conflict graph arc connecting regs\n-   R1 and R2.  R1 is assumed to be smaller or equal to R2.  */\n-#define CONFLICT_HASH_FN(R1, R2) ((R2) * ((R2) - 1) / 2 + (R1))\n-\n-static hashval_t arc_hash (const void *);\n-static int arc_eq (const void *, const void *);\n-static int print_conflict (int, int, void *);\n-\f\n-/* Callback function to compute the hash value of an arc.  Uses\n-   current_graph to locate the graph to which the arc belongs.  */\n-\n-static hashval_t\n-arc_hash (const void *arcp)\n-{\n-  const_conflict_graph_arc arc = (const_conflict_graph_arc) arcp;\n-\n-  return CONFLICT_HASH_FN (arc->smaller, arc->larger);\n-}\n-\n-/* Callback function to determine the equality of two arcs in the hash\n-   table.  */\n-\n-static int\n-arc_eq (const void *arcp1, const void *arcp2)\n-{\n-  const_conflict_graph_arc arc1 = (const_conflict_graph_arc) arcp1;\n-  const_conflict_graph_arc arc2 = (const_conflict_graph_arc) arcp2;\n-\n-  return arc1->smaller == arc2->smaller && arc1->larger == arc2->larger;\n-}\n-\n-/* Creates an empty conflict graph to hold conflicts among NUM_REGS\n-   registers.  */\n-\n-conflict_graph\n-conflict_graph_new (int num_regs)\n-{\n-  conflict_graph graph = XNEW (struct conflict_graph_def);\n-  graph->num_regs = num_regs;\n-\n-  /* Set up the hash table.  No delete action is specified; memory\n-     management of arcs is through the obstack.  */\n-  graph->arc_hash_table\n-    = htab_create (INITIAL_ARC_CAPACITY, &arc_hash, &arc_eq, NULL);\n-\n-  /* Create an obstack for allocating arcs.  */\n-  obstack_init (&graph->arc_obstack);\n-\t     \n-  /* Create and zero the lookup table by register number.  */\n-  graph->neighbor_heads = XCNEWVEC (conflict_graph_arc, num_regs);\n-\n-  return graph;\n-}\n-\n-/* Deletes a conflict graph.  */\n-\n-void\n-conflict_graph_delete (conflict_graph graph)\n-{\n-  obstack_free (&graph->arc_obstack, NULL);\n-  htab_delete (graph->arc_hash_table);\n-  free (graph->neighbor_heads);\n-  free (graph);\n-}\n-\n-/* Adds a conflict to GRAPH between regs REG1 and REG2, which must be\n-   distinct.  Returns nonzero, unless the conflict is already present\n-   in GRAPH, in which case it does nothing and returns zero.  */\n-\n-int\n-conflict_graph_add (conflict_graph graph, int reg1, int reg2)\n-{\n-  int smaller = MIN (reg1, reg2);\n-  int larger = MAX (reg1, reg2);\n-  struct conflict_graph_arc_def dummy;\n-  conflict_graph_arc arc;\n-  void **slot;\n-\n-  /* A reg cannot conflict with itself.  */\n-  gcc_assert (reg1 != reg2);\n-\n-  dummy.smaller = smaller;\n-  dummy.larger = larger;\n-  slot = htab_find_slot (graph->arc_hash_table, (void *) &dummy, INSERT);\n-  \n-  /* If the conflict is already there, do nothing.  */\n-  if (*slot != NULL)\n-    return 0;\n-\n-  /* Allocate an arc.  */\n-  arc\n-    = obstack_alloc (&graph->arc_obstack,\n-\t\t     sizeof (struct conflict_graph_arc_def));\n-  \n-  /* Record the reg numbers.  */\n-  arc->smaller = smaller;\n-  arc->larger = larger;\n-\n-  /* Link the conflict into two lists, one for each reg.  */\n-  arc->smaller_next = graph->neighbor_heads[smaller];\n-  graph->neighbor_heads[smaller] = arc;\n-  arc->larger_next = graph->neighbor_heads[larger];\n-  graph->neighbor_heads[larger] = arc;\n-\n-  /* Put it in the hash table.  */\n-  *slot = (void *) arc;\n-\n-  return 1;\n-}\n-\n-/* Returns nonzero if a conflict exists in GRAPH between regs REG1\n-   and REG2.  */\n-\n-int\n-conflict_graph_conflict_p (conflict_graph graph, int reg1, int reg2)\n-{\n-  /* Build an arc to search for.  */\n-  struct conflict_graph_arc_def arc;\n-  arc.smaller = MIN (reg1, reg2);\n-  arc.larger = MAX (reg1, reg2);\n-\n-  return htab_find (graph->arc_hash_table, (void *) &arc) != NULL;\n-}\n-\n-/* Calls ENUM_FN for each conflict in GRAPH involving REG.  EXTRA is\n-   passed back to ENUM_FN.  */\n-\n-void\n-conflict_graph_enum (conflict_graph graph, int reg,\n-\t\t     conflict_graph_enum_fn enum_fn, void *extra)\n-{\n-  conflict_graph_arc arc = graph->neighbor_heads[reg];\n-  while (arc != NULL)\n-    {\n-      /* Invoke the callback.  */\n-      if ((*enum_fn) (arc->smaller, arc->larger, extra))\n-\t/* Stop if requested.  */\n-\tbreak;\n-      \n-      /* Which next pointer to follow depends on whether REG is the\n-\t smaller or larger reg in this conflict.  */\n-      if (reg < arc->larger)\n-\tarc = arc->smaller_next;\n-      else\n-\tarc = arc->larger_next;\n-    }\n-}\n-\n-/* For each conflict between a register x and SRC in GRAPH, adds a\n-   conflict to GRAPH between x and TARGET.  */\n-\n-void\n-conflict_graph_merge_regs (conflict_graph graph, int target, int src)\n-{\n-  conflict_graph_arc arc = graph->neighbor_heads[src];\n-\n-  if (target == src)\n-    return;\n-\n-  while (arc != NULL)\n-    {\n-      int other = arc->smaller;\n-\n-      if (other == src)\n-\tother = arc->larger;\n-\n-      conflict_graph_add (graph, target, other);\n-\n-      /* Which next pointer to follow depends on whether REG is the\n-\t smaller or larger reg in this conflict.  */\n-      if (src < arc->larger)\n-\tarc = arc->smaller_next;\n-      else\n-\tarc = arc->larger_next;\n-    }\n-}\n-\n-/* Holds context information while a conflict graph is being traversed\n-   for printing.  */\n-\n-struct print_context\n-{\n-  /* The file pointer to which we're printing.  */\n-  FILE *fp;\n-\n-  /* The reg whose conflicts we're printing.  */\n-  int reg;\n-\n-  /* Whether a conflict has already been printed for this reg.  */\n-  int started;\n-};\n-\n-/* Callback function when enumerating conflicts during printing.  */\n-\n-static int\n-print_conflict (int reg1, int reg2, void *contextp)\n-{\n-  struct print_context *context = (struct print_context *) contextp;\n-  int reg;\n-\n-  /* If this is the first conflict printed for this reg, start a new\n-     line.  */\n-  if (! context->started)\n-    {\n-      fprintf (context->fp, \" %d:\", context->reg);\n-      context->started = 1;\n-    }\n-\n-  /* Figure out the reg whose conflicts we're printing.  The other reg\n-     is the interesting one.  */\n-  if (reg1 == context->reg)\n-    reg = reg2;\n-  else\n-    {\n-      gcc_assert (reg2 == context->reg);\n-      reg = reg1;\n-    }\n-\n-  /* Print the conflict.  */\n-  fprintf (context->fp, \" %d\", reg);\n-\n-  /* Continue enumerating.  */\n-  return 0;\n-}\n-\n-/* Prints the conflicts in GRAPH to FP.  */\n-\n-void\n-conflict_graph_print (conflict_graph graph, FILE *fp)\n-{\n-  int reg;\n-  struct print_context context;\n-\n-  context.fp = fp;\n-  fprintf (fp, \"Conflicts:\\n\");\n-\n-  /* Loop over registers supported in this graph.  */\n-  for (reg = 0; reg < graph->num_regs; ++reg)\n-    {\n-      context.reg = reg;\n-      context.started = 0;\n-\n-      /* Scan the conflicts for reg, printing as we go.  A label for\n-\t this line will be printed the first time a conflict is\n-\t printed for the reg; we won't start a new line if this reg\n-\t has no conflicts.  */\n-      conflict_graph_enum (graph, reg, &print_conflict, &context);\n-\n-      /* If this reg does have conflicts, end the line.  */\n-      if (context.started)\n-\tfputc ('\\n', fp);\n-    }\n-}"}]}