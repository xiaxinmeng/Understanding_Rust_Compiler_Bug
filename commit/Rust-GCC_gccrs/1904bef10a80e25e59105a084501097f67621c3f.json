{"sha": "1904bef10a80e25e59105a084501097f67621c3f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTkwNGJlZjEwYTgwZTI1ZTU5MTA1YTA4NDUwMTA5N2Y2NzYyMWMzZg==", "commit": {"author": {"name": "Johannes Singler", "email": "singler@ira.uka.de", "date": "2007-10-08T15:17:28Z"}, "committer": {"name": "Johannes Singler", "email": "singler@gcc.gnu.org", "date": "2007-10-08T15:17:28Z"}, "message": "parallel_mode.html: Added reference to MCSTL.\n\n        * docs/html/parallel_mode.html: Added reference to MCSTL.\n        More documentation on compile-time settings and tuning.\n        * include/parallel/multiway_merge.h: Added reference to paper.\n        * include/parallel/multiseq_selection.h: Added reference to paper.\n        * include/parallel/workstealing.h: Added reference to paper.\n        * include/parallel/balanced_quicksort.h: Added reference to paper.\n        * include/parallel/tree.h: Added reference to paper.\n\nFrom-SVN: r129129", "tree": {"sha": "48da48cec9210a7c4a9dc2a8eb9b83efc7573341", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/48da48cec9210a7c4a9dc2a8eb9b83efc7573341"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1904bef10a80e25e59105a084501097f67621c3f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1904bef10a80e25e59105a084501097f67621c3f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1904bef10a80e25e59105a084501097f67621c3f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1904bef10a80e25e59105a084501097f67621c3f/comments", "author": null, "committer": null, "parents": [{"sha": "8174836f1ebff55e127300c942adf3e689d3d3d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8174836f1ebff55e127300c942adf3e689d3d3d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8174836f1ebff55e127300c942adf3e689d3d3d4"}], "stats": {"total": 117, "additions": 107, "deletions": 10}, "files": [{"sha": "29ab689857351cafdb08d43336606edeeed69e94", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1904bef10a80e25e59105a084501097f67621c3f/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1904bef10a80e25e59105a084501097f67621c3f/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=1904bef10a80e25e59105a084501097f67621c3f", "patch": "@@ -1,3 +1,13 @@\n+2007-10-08  Johannes Singler  <singler@ira.uka.de>\n+\n+        * include/parallel/multiway_merge.h: Added reference to paper.\n+        * include/parallel/multiseq_selection.h: Added reference to paper.\n+        * include/parallel/workstealing.h: Added reference to paper.\n+        * include/parallel/balanced_quicksort.h: Added reference to paper.\n+        * include/parallel/tree.h: Added reference to paper.\n+        * docs/html/parallel_mode.html: Added reference to MCSTL.\n+        More documentation on compile-time settings and tuning.\n+\n 2007-10-08  Paolo Carlini  <pcarlini@suse.de>\n \n \t* include/std/utility (identity, move, forward): Move to..."}, {"sha": "0ada39b6de69ccb11247ecd611c53e74ac345661", "filename": "libstdc++-v3/docs/html/parallel_mode.html", "status": "modified", "additions": 61, "deletions": 10, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1904bef10a80e25e59105a084501097f67621c3f/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fparallel_mode.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1904bef10a80e25e59105a084501097f67621c3f/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fparallel_mode.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fparallel_mode.html?ref=1904bef10a80e25e59105a084501097f67621c3f", "patch": "@@ -35,15 +35,15 @@ <h1 class=\"centered\"><a name=\"top\">The libstdc++ parallel mode</a></h1>\n \n <p>\n Several of the standard algorithms, for instance\n-<code>std::search</code>, are made parallel using OpenMP\n+<code>std::sort</code>, are made parallel using OpenMP\n annotations. These parallel mode constructs and can be invoked by\n explicit source declaration or by compiling existing sources with a\n specific compiler flag.\n </p>\n \n <h3 class=\"left\"><a name=\"parallel\">The libstdc++ parallel mode</a></h3>\n \n-<p>The libstdc++ parallel mode performs parallization of algorithms,\n+<p>The libstdc++ parallel mode performs parallelization of algorithms,\n function objects, classes, and functions in the C++ Standard.</p>\n \n <h4 class=\"left\">Using the libstdc++ parallel mode</h4>\n@@ -53,7 +53,7 @@ <h4 class=\"left\">Using the libstdc++ parallel mode</h4>\n   will link in <code>libgomp</code>, the GNU OpenMP <a\n   href=\"http://gcc.gnu.org/onlinedocs/libgomp\">implementation</a>,\n   whose presence is mandatory. In addition, hardware capable of atomic\n-  operations is de rigueur. Actually activating these atomic\n+  operations is mandatory. Actually activating these atomic\n   operations may require explicit compiler flags on some targets\n   (like sparc and x86), such as <code>-march=i686</code>,\n   <code>-march=native</code> or <code>-mcpu=v9</code>.\n@@ -113,6 +113,13 @@ <h4 class=\"left\">Using the libstdc++ parallel mode</h4>\n   <li><code>std::unique_copy</code></li>\n </ul>\n \n+<p>The following library components in the includes\n+<code>&lt;set&gt;</code> and <code>&lt;map&gt;</code> are included in the parallel mode:</p>\n+<ul>\n+  <li><code>std::(multi_)map/set&lt;T&gt;::(multi_)map/set(Iterator begin, Iterator end)</code> (bulk construction)</li>\n+  <li><code>std::(multi_)map/set&lt;T&gt;::insert(Iterator begin, Iterator end)</code> (bulk insertion)</li>\n+</ul>\n+\n \n <h4 class=\"left\">Using the parallel algorithms without parallel mode</h4>\n \n@@ -380,13 +387,47 @@ <h4 class=\"left\">Using the parallel algorithms without parallel mode</h4>\n \n \n <h4 class=\"left\">Parallel mode semantics</h4>\n-<p> Something about exception safety, interaction with threads,\n-etc. Goal is to have the usual constraints of the STL with respect to\n-exception safety and threads, but add in support for parallel\n-computing.</p>\n \n-<p> Something about compile-time settings and configuration, ie using\n-<code>__gnu_parallel::Settings</code>. XXX Up in the air.</p>\n+<p> The parallel mode STL algorithms are currently not exception-safe,\n+i. e. user-defined functors must not throw exceptions.\n+</p>\n+\n+<p> Since the current GCC OpenMP implementation does not support\n+OpenMP parallel regions in concurrent threads,\n+it is not possible to call parallel STL algorithm in\n+concurrent threads, either.\n+It might work with other compilers, though.</p>\n+\n+\n+<h4 class=\"left\">Configuration and Tuning</h4>\n+\n+<p> Some algorithm variants can be enabled/disabled/selected at compile-time.\n+See <a href=\"latest-doxygen/compiletime__settings_8h.html\">\n+<code>&lt;compiletime_settings.h&gt;</code></a> and\n+See <a href=\"latest-doxygen/compiletime__settings_8h.html\">\n+<code>&lt;features.h&gt;</code></a> for details.\n+</p>\n+\n+<p>\n+To specify the number of threads to be used for an algorithm,\n+use <code>omp_set_num_threads</code>.\n+To force a function to execute sequentially,\n+even though parallelism is switched on in general,\n+add <code>__gnu_parallel::sequential_tag()</code>\n+to the end of the argument list.\n+</p>\n+\n+<p>\n+Parallelism always incurs some overhead. Thus, it is not\n+helpful to parallelize operations on very small sets of data.\n+There are measures to avoid parallelizing stuff that is not worth it.\n+For each algorithm, a minimum problem size can be stated,\n+usually using the variable\n+<code>__gnu_parallel::Settings::[algorithm]_minimal_n</code>.\n+Please see <a href=\"latest-doxygen/settings_8h.html\">\n+<code>&lt;settings.h&gt;</code><a> for details.</p>\n+\n+\n \n <h4 class=\"left\">Interface basics and general design</h4>\n \n@@ -485,7 +526,7 @@ <h4 class=\"left\">Relevant namespaces</h4>\n &lt;algorithm&gt; has a parallel counterpart in\n <code>std::__parallel::transform</code> from\n &lt;parallel/algorithm&gt;. In addition, these parallel\n-implementatations are injected into <code>namespace\n+implementations are injected into <code>namespace\n __gnu_parallel</code> with using declarations.\n </p>\n \n@@ -526,6 +567,16 @@ <h4 class=\"left\">Testing</h4>\n </p>\n \n \n+<h4 class=\"left\">References / Further Reading</h4>\n+\n+<p>\n+Johannes Singler, Peter Sanders, Felix Putze. The Multi-Core Standard Template Library. Euro-Par 2007: Parallel Processing. (LNCS 4641)\n+</p>\n+\n+<p>\n+Leonor Frias, Johannes Singler: Parallelization of Bulk Operations for STL Dictionaries. Workshop on Highly Parallel Processing on a Chip (HPPC) 2007. (LNCS)\n+</p>\n+\n <!-- ####################################################### -->\n \n <hr />"}, {"sha": "c28277039c5827df0a4abe3f6113a8108a4c7bd5", "filename": "libstdc++-v3/include/parallel/balanced_quicksort.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1904bef10a80e25e59105a084501097f67621c3f/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbalanced_quicksort.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1904bef10a80e25e59105a084501097f67621c3f/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbalanced_quicksort.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbalanced_quicksort.h?ref=1904bef10a80e25e59105a084501097f67621c3f", "patch": "@@ -32,6 +32,14 @@\n  *  @brief Implementation of a dynamically load-balanced parallel quicksort.\n  *\n  *  It works in-place and needs only logarithmic extra memory.\n+ *  The algorithm is similar to the one proposed in\n+ *\n+ *  P. Tsigas and Y. Zhang.\n+ *  A simple, fast parallel implementation of quicksort and\n+ *  its performance evaluation on SUN enterprise 10000.\n+ *  In 11th Euromicro Conference on Parallel, Distributed and\n+ *  Network-Based Processing, page 372, 2003.\n+ *\n  *  This file is a GNU parallel extension to the Standard C++ Library.\n  */\n "}, {"sha": "208f4098f56706dec58bd3e5fec6ac1e5df7e9ad", "filename": "libstdc++-v3/include/parallel/multiseq_selection.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1904bef10a80e25e59105a084501097f67621c3f/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiseq_selection.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1904bef10a80e25e59105a084501097f67621c3f/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiseq_selection.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiseq_selection.h?ref=1904bef10a80e25e59105a084501097f67621c3f", "patch": "@@ -32,6 +32,13 @@\n  *  @brief Functions to find elements of a certain global rank in\n  *  multiple sorted sequences.  Also serves for splitting such\n  *  sequence sets.\n+ *\n+ *  The algorithm description can be found in \n+ *\n+ *  P. J. Varman, S. D. Scheufler, B. R. Iyer, and G. R. Ricard.\n+ *  Merging Multiple Lists on Hierarchical-Memory Multiprocessors.\n+ *  Journal of Parallel and Distributed Computing, 12(2):171\u2013177, 1991.\n+ *\n  *  This file is a GNU parallel extension to the Standard C++ Library.\n  */\n "}, {"sha": "c940e4578dca9621e26de77fe1d918d3b857597b", "filename": "libstdc++-v3/include/parallel/multiway_merge.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1904bef10a80e25e59105a084501097f67621c3f/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_merge.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1904bef10a80e25e59105a084501097f67621c3f/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_merge.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_merge.h?ref=1904bef10a80e25e59105a084501097f67621c3f", "patch": "@@ -30,6 +30,13 @@\n \n /** @file parallel/multiway_merge.h\n  *  @brief Implementation of sequential and parallel multiway merge.\n+ *\n+ *  Explanations on the high-speed merging routines in the appendix of\n+ *\n+ *  P. Sanders.\n+ *  Fast priority queues for cached memory.\n+ *  ACM Journal of Experimental Algorithmics, 5, 2000.\n+ *\n  *  This file is a GNU parallel extension to the Standard C++ Library.\n  */\n "}, {"sha": "5b7b41c6ef9fc55d7155911628c00acf6a2ed0d3", "filename": "libstdc++-v3/include/parallel/tree.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1904bef10a80e25e59105a084501097f67621c3f/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1904bef10a80e25e59105a084501097f67621c3f/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ftree.h?ref=1904bef10a80e25e59105a084501097f67621c3f", "patch": "@@ -30,6 +30,13 @@\n \n /** @file parallel/tree.h\n  *  @brief Parallel red-black tree operations.\n+ *\n+ *  This implementation is described in\n+ *\n+ *  Leonor Frias, Johannes Singler.\n+ *  Parallelization of Bulk Operations for STL Dictionaries.\n+ *  Workshop on Highly Parallel Processing on a Chip (HPPC) 2007.\n+ *\n  *  This file is a GNU parallel extension to the Standard C++ Library.\n  */\n "}, {"sha": "0b2102c45edc91768299e8962b88065b5d780549", "filename": "libstdc++-v3/include/parallel/workstealing.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1904bef10a80e25e59105a084501097f67621c3f/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fworkstealing.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1904bef10a80e25e59105a084501097f67621c3f/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fworkstealing.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fworkstealing.h?ref=1904bef10a80e25e59105a084501097f67621c3f", "patch": "@@ -31,6 +31,13 @@\n /** @file parallel/workstealing.h\n  *  @brief Parallelization of embarrassingly parallel execution by\n  *  means of work-stealing.\n+ *\n+ *  Work stealing is described in\n+ *\n+ *  R. D. Blumofe and C. E. Leiserson.\n+ *  Scheduling multithreaded computations by work stealing.\n+ *  Journal of the ACM, 46(5):720\u2013748, 1999.\n+ *\n  *  This file is a GNU parallel extension to the Standard C++ Library.\n  */\n "}]}