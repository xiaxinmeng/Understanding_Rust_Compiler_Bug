{"sha": "3b0c7324054b014b73bd7e1c82ed95ae306ef794", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2IwYzczMjQwNTRiMDE0YjczYmQ3ZTFjODJlZDk1YWUzMDZlZjc5NA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2013-02-14T08:40:13Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2013-02-14T08:40:13Z"}, "message": "dejagnu-gtest.h: Add multiple inclusion guards.\n\n\t* g++.dg/asan/dejagnu-gtest.h: Add multiple inclusion guards.\n\t* asan_globals_test-wrapper.cc: New file.\n\t* g++.dg/asan/asan_test.C: Use asan_globals_test-wrapper.cc\n\tinstead of asan_globals_test.cc as dg-additional-sources.\n\tInclude asan_mem_test.cc, asan_str_test.cc and asan_oob_test.cc.\n\t* g++.dg/asan/asan_test_utils.h: Synced from upstream.  Include\n\t\"sanitizer_test_utils.h\" instead of\n\t\"sanitizer_common/tests/sanitizer_test_utils.h\".\n\t* g++.dg/asan/asan_str_test.cc: New file, synced from upstream.\n\t* g++.dg/asan/asan_mem_test.cc: New file, synced from upstream.\n\t* g++.dg/asan/asan_oob_test.cc: New file, synced from upstream.\n\t* g++.dg/asan/asan_globals_test.cc: Synced from upstream.\n\t* g++.dg/asan/asan_test.cc: Synced from upstream.\n\t* g++.dg/asan/sanitizer_test_utils.h: New file, synced from upstream.\n\nFrom-SVN: r196045", "tree": {"sha": "eac7fd33000f326198f27b668d8f7661e200ba33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eac7fd33000f326198f27b668d8f7661e200ba33"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3b0c7324054b014b73bd7e1c82ed95ae306ef794", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b0c7324054b014b73bd7e1c82ed95ae306ef794", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b0c7324054b014b73bd7e1c82ed95ae306ef794", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b0c7324054b014b73bd7e1c82ed95ae306ef794/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8fb067263b60e184b2e0d303e1b8d40166e2bec4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fb067263b60e184b2e0d303e1b8d40166e2bec4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8fb067263b60e184b2e0d303e1b8d40166e2bec4"}], "stats": {"total": 2477, "additions": 1192, "deletions": 1285}, "files": [{"sha": "8d145390e8897b89ad44ffa4013b9312dc6d9e66", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b0c7324054b014b73bd7e1c82ed95ae306ef794/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b0c7324054b014b73bd7e1c82ed95ae306ef794/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3b0c7324054b014b73bd7e1c82ed95ae306ef794", "patch": "@@ -1,3 +1,20 @@\n+2013-02-14  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* g++.dg/asan/dejagnu-gtest.h: Add multiple inclusion guards.\n+\t* asan_globals_test-wrapper.cc: New file.\n+\t* g++.dg/asan/asan_test.C: Use asan_globals_test-wrapper.cc\n+\tinstead of asan_globals_test.cc as dg-additional-sources.\n+\tInclude asan_mem_test.cc, asan_str_test.cc and asan_oob_test.cc.\n+\t* g++.dg/asan/asan_test_utils.h: Synced from upstream.  Include\n+\t\"sanitizer_test_utils.h\" instead of\n+\t\"sanitizer_common/tests/sanitizer_test_utils.h\".\n+\t* g++.dg/asan/asan_str_test.cc: New file, synced from upstream.\n+\t* g++.dg/asan/asan_mem_test.cc: New file, synced from upstream.\n+\t* g++.dg/asan/asan_oob_test.cc: New file, synced from upstream.\n+\t* g++.dg/asan/asan_globals_test.cc: Synced from upstream.\n+\t* g++.dg/asan/asan_test.cc: Synced from upstream.\n+\t* g++.dg/asan/sanitizer_test_utils.h: New file, synced from upstream.\n+\n 2013-02-14  Dodji Seketeli  <dodji@redhat.com>\n \n \tFix an asan crash"}, {"sha": "97f53123f99504c64213f420f1de785b2a9a817f", "filename": "gcc/testsuite/g++.dg/asan/asan_globals_test-wrapper.cc", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b0c7324054b014b73bd7e1c82ed95ae306ef794/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_globals_test-wrapper.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b0c7324054b014b73bd7e1c82ed95ae306ef794/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_globals_test-wrapper.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_globals_test-wrapper.cc?ref=3b0c7324054b014b73bd7e1c82ed95ae306ef794", "patch": "@@ -0,0 +1,2 @@\n+#define DEJAGNU_GTEST_H 1\n+#include \"asan_globals_test.cc\""}, {"sha": "38e71360b6aa98714b4b00feadc8ce205d096a0c", "filename": "gcc/testsuite/g++.dg/asan/asan_globals_test.cc", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b0c7324054b014b73bd7e1c82ed95ae306ef794/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_globals_test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b0c7324054b014b73bd7e1c82ed95ae306ef794/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_globals_test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_globals_test.cc?ref=3b0c7324054b014b73bd7e1c82ed95ae306ef794", "patch": "@@ -9,8 +9,29 @@\n //\n // Some globals in a separate file.\n //===----------------------------------------------------------------------===//\n+#include \"asan_test_utils.h\"\n+\n+char glob1[1];\n+char glob2[2];\n+char glob3[3];\n+char glob4[4];\n+char glob5[5];\n+char glob6[6];\n+char glob7[7];\n+char glob8[8];\n+char glob9[9];\n+char glob10[10];\n+char glob11[11];\n+char glob12[12];\n+char glob13[13];\n+char glob14[14];\n+char glob15[15];\n+char glob16[16];\n+char glob17[17];\n+char glob1000[1000];\n+char glob10000[10000];\n+char glob100000[100000];\n \n-extern char glob5[5];\n static char static10[10];\n \n int GlobalsTest(int zero) {"}, {"sha": "5656aab0bac612511bcd89c79842db036b7d884b", "filename": "gcc/testsuite/g++.dg/asan/asan_mem_test.cc", "status": "added", "additions": 231, "deletions": 0, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b0c7324054b014b73bd7e1c82ed95ae306ef794/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_mem_test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b0c7324054b014b73bd7e1c82ed95ae306ef794/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_mem_test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_mem_test.cc?ref=3b0c7324054b014b73bd7e1c82ed95ae306ef794", "patch": "@@ -0,0 +1,231 @@\n+//===-- asan_mem_test.cc --------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+//===----------------------------------------------------------------------===//\n+#include \"asan_test_utils.h\"\n+\n+template<typename T>\n+void MemSetOOBTestTemplate(size_t length) {\n+  if (length == 0) return;\n+  size_t size = Ident(sizeof(T) * length);\n+  T *array = Ident((T*)malloc(size));\n+  int element = Ident(42);\n+  int zero = Ident(0);\n+  void *(*MEMSET)(void *s, int c, size_t n) = Ident(memset);\n+  // memset interval inside array\n+  MEMSET(array, element, size);\n+  MEMSET(array, element, size - 1);\n+  MEMSET(array + length - 1, element, sizeof(T));\n+  MEMSET(array, element, 1);\n+\n+  // memset 0 bytes\n+  MEMSET(array - 10, element, zero);\n+  MEMSET(array - 1, element, zero);\n+  MEMSET(array, element, zero);\n+  MEMSET(array + length, 0, zero);\n+  MEMSET(array + length + 1, 0, zero);\n+\n+  // try to memset bytes to the right of array\n+  EXPECT_DEATH(MEMSET(array, 0, size + 1),\n+               RightOOBWriteMessage(0));\n+  EXPECT_DEATH(MEMSET((char*)(array + length) - 1, element, 6),\n+               RightOOBWriteMessage(0));\n+  EXPECT_DEATH(MEMSET(array + 1, element, size + sizeof(T)),\n+               RightOOBWriteMessage(0));\n+  // whole interval is to the right\n+  EXPECT_DEATH(MEMSET(array + length + 1, 0, 10),\n+               RightOOBWriteMessage(sizeof(T)));\n+\n+  // try to memset bytes to the left of array\n+  EXPECT_DEATH(MEMSET((char*)array - 1, element, size),\n+               LeftOOBWriteMessage(1));\n+  EXPECT_DEATH(MEMSET((char*)array - 5, 0, 6),\n+               LeftOOBWriteMessage(5));\n+  if (length >= 100) {\n+    // Large OOB, we find it only if the redzone is large enough.\n+    EXPECT_DEATH(memset(array - 5, element, size + 5 * sizeof(T)),\n+                 LeftOOBWriteMessage(5 * sizeof(T)));\n+  }\n+  // whole interval is to the left\n+  EXPECT_DEATH(MEMSET(array - 2, 0, sizeof(T)),\n+               LeftOOBWriteMessage(2 * sizeof(T)));\n+\n+  // try to memset bytes both to the left & to the right\n+  EXPECT_DEATH(MEMSET((char*)array - 2, element, size + 4),\n+               LeftOOBWriteMessage(2));\n+\n+  free(array);\n+}\n+\n+TEST(AddressSanitizer, MemSetOOBTest) {\n+  MemSetOOBTestTemplate<char>(100);\n+  MemSetOOBTestTemplate<int>(5);\n+  MemSetOOBTestTemplate<double>(256);\n+  // We can test arrays of structres/classes here, but what for?\n+}\n+\n+// Try to allocate two arrays of 'size' bytes that are near each other.\n+// Strictly speaking we are not guaranteed to find such two pointers,\n+// but given the structure of asan's allocator we will.\n+static bool AllocateTwoAdjacentArrays(char **x1, char **x2, size_t size) {\n+  vector<char *> v;\n+  bool res = false;\n+  for (size_t i = 0; i < 1000U && !res; i++) {\n+    v.push_back(new char[size]);\n+    if (i == 0) continue;\n+    sort(v.begin(), v.end());\n+    for (size_t j = 1; j < v.size(); j++) {\n+      assert(v[j] > v[j-1]);\n+      if ((size_t)(v[j] - v[j-1]) < size * 2) {\n+        *x2 = v[j];\n+        *x1 = v[j-1];\n+        res = true;\n+        break;\n+      }\n+    }\n+  }\n+\n+  for (size_t i = 0; i < v.size(); i++) {\n+    if (res && v[i] == *x1) continue;\n+    if (res && v[i] == *x2) continue;\n+    delete [] v[i];\n+  }\n+  return res;\n+}\n+\n+TEST(AddressSanitizer, LargeOOBInMemset) {\n+  for (size_t size = 200; size < 100000; size += size / 2) {\n+    char *x1, *x2;\n+    if (!Ident(AllocateTwoAdjacentArrays)(&x1, &x2, size))\n+      continue;\n+    // fprintf(stderr, \"  large oob memset: %p %p %zd\\n\", x1, x2, size);\n+    // Do a memset on x1 with huge out-of-bound access that will end up in x2.\n+    EXPECT_DEATH(Ident(memset)(x1, 0, size * 2),\n+                 \"is located 0 bytes to the right\");\n+    delete [] x1;\n+    delete [] x2;\n+    return;\n+  }\n+  assert(0 && \"Did not find two adjacent malloc-ed pointers\");\n+}\n+\n+// Same test for memcpy and memmove functions\n+template <typename T, class M>\n+void MemTransferOOBTestTemplate(size_t length) {\n+  if (length == 0) return;\n+  size_t size = Ident(sizeof(T) * length);\n+  T *src = Ident((T*)malloc(size));\n+  T *dest = Ident((T*)malloc(size));\n+  int zero = Ident(0);\n+\n+  // valid transfer of bytes between arrays\n+  M::transfer(dest, src, size);\n+  M::transfer(dest + 1, src, size - sizeof(T));\n+  M::transfer(dest, src + length - 1, sizeof(T));\n+  M::transfer(dest, src, 1);\n+\n+  // transfer zero bytes\n+  M::transfer(dest - 1, src, 0);\n+  M::transfer(dest + length, src, zero);\n+  M::transfer(dest, src - 1, zero);\n+  M::transfer(dest, src, zero);\n+\n+  // try to change mem to the right of dest\n+  EXPECT_DEATH(M::transfer(dest + 1, src, size),\n+               RightOOBWriteMessage(0));\n+  EXPECT_DEATH(M::transfer((char*)(dest + length) - 1, src, 5),\n+               RightOOBWriteMessage(0));\n+\n+  // try to change mem to the left of dest\n+  EXPECT_DEATH(M::transfer(dest - 2, src, size),\n+               LeftOOBWriteMessage(2 * sizeof(T)));\n+  EXPECT_DEATH(M::transfer((char*)dest - 3, src, 4),\n+               LeftOOBWriteMessage(3));\n+\n+  // try to access mem to the right of src\n+  EXPECT_DEATH(M::transfer(dest, src + 2, size),\n+               RightOOBReadMessage(0));\n+  EXPECT_DEATH(M::transfer(dest, (char*)(src + length) - 3, 6),\n+               RightOOBReadMessage(0));\n+\n+  // try to access mem to the left of src\n+  EXPECT_DEATH(M::transfer(dest, src - 1, size),\n+               LeftOOBReadMessage(sizeof(T)));\n+  EXPECT_DEATH(M::transfer(dest, (char*)src - 6, 7),\n+               LeftOOBReadMessage(6));\n+\n+  // Generally we don't need to test cases where both accessing src and writing\n+  // to dest address to poisoned memory.\n+\n+  T *big_src = Ident((T*)malloc(size * 2));\n+  T *big_dest = Ident((T*)malloc(size * 2));\n+  // try to change mem to both sides of dest\n+  EXPECT_DEATH(M::transfer(dest - 1, big_src, size * 2),\n+               LeftOOBWriteMessage(sizeof(T)));\n+  // try to access mem to both sides of src\n+  EXPECT_DEATH(M::transfer(big_dest, src - 2, size * 2),\n+               LeftOOBReadMessage(2 * sizeof(T)));\n+\n+  free(src);\n+  free(dest);\n+  free(big_src);\n+  free(big_dest);\n+}\n+\n+class MemCpyWrapper {\n+ public:\n+  static void* transfer(void *to, const void *from, size_t size) {\n+    return Ident(memcpy)(to, from, size);\n+  }\n+};\n+\n+TEST(AddressSanitizer, MemCpyOOBTest) {\n+  MemTransferOOBTestTemplate<char, MemCpyWrapper>(100);\n+  MemTransferOOBTestTemplate<int, MemCpyWrapper>(1024);\n+}\n+\n+class MemMoveWrapper {\n+ public:\n+  static void* transfer(void *to, const void *from, size_t size) {\n+    return Ident(memmove)(to, from, size);\n+  }\n+};\n+\n+TEST(AddressSanitizer, MemMoveOOBTest) {\n+  MemTransferOOBTestTemplate<char, MemMoveWrapper>(100);\n+  MemTransferOOBTestTemplate<int, MemMoveWrapper>(1024);\n+}\n+\n+\n+TEST(AddressSanitizer, MemCmpOOBTest) {\n+  size_t size = Ident(100);\n+  char *s1 = MallocAndMemsetString(size);\n+  char *s2 = MallocAndMemsetString(size);\n+  // Normal memcmp calls.\n+  Ident(memcmp(s1, s2, size));\n+  Ident(memcmp(s1 + size - 1, s2 + size - 1, 1));\n+  Ident(memcmp(s1 - 1, s2 - 1, 0));\n+  // One of arguments points to not allocated memory.\n+  EXPECT_DEATH(Ident(memcmp)(s1 - 1, s2, 1), LeftOOBReadMessage(1));\n+  EXPECT_DEATH(Ident(memcmp)(s1, s2 - 1, 1), LeftOOBReadMessage(1));\n+  EXPECT_DEATH(Ident(memcmp)(s1 + size, s2, 1), RightOOBReadMessage(0));\n+  EXPECT_DEATH(Ident(memcmp)(s1, s2 + size, 1), RightOOBReadMessage(0));\n+  // Hit unallocated memory and die.\n+  EXPECT_DEATH(Ident(memcmp)(s1 + 1, s2 + 1, size), RightOOBReadMessage(0));\n+  EXPECT_DEATH(Ident(memcmp)(s1 + size - 1, s2, 2), RightOOBReadMessage(0));\n+  // Zero bytes are not terminators and don't prevent from OOB.\n+  s1[size - 1] = '\\0';\n+  s2[size - 1] = '\\0';\n+  EXPECT_DEATH(Ident(memcmp)(s1, s2, size + 1), RightOOBReadMessage(0));\n+  free(s1);\n+  free(s2);\n+}\n+\n+\n+"}, {"sha": "61d505537038669ea349dfc4d42c58fa1d8f550d", "filename": "gcc/testsuite/g++.dg/asan/asan_oob_test.cc", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b0c7324054b014b73bd7e1c82ed95ae306ef794/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_oob_test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b0c7324054b014b73bd7e1c82ed95ae306ef794/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_oob_test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_oob_test.cc?ref=3b0c7324054b014b73bd7e1c82ed95ae306ef794", "patch": "@@ -0,0 +1,126 @@\n+//===-- asan_oob_test.cc --------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+//===----------------------------------------------------------------------===//\n+#include \"asan_test_utils.h\"\n+\n+NOINLINE void asan_write_sized_aligned(uint8_t *p, size_t size) {\n+  EXPECT_EQ(0U, ((uintptr_t)p % size));\n+  if      (size == 1) asan_write((uint8_t*)p);\n+  else if (size == 2) asan_write((uint16_t*)p);\n+  else if (size == 4) asan_write((uint32_t*)p);\n+  else if (size == 8) asan_write((uint64_t*)p);\n+}\n+\n+template<typename T>\n+NOINLINE void oob_test(int size, int off) {\n+  char *p = (char*)malloc_aaa(size);\n+  // fprintf(stderr, \"writing %d byte(s) into [%p,%p) with offset %d\\n\",\n+  //        sizeof(T), p, p + size, off);\n+  asan_write((T*)(p + off));\n+  free_aaa(p);\n+}\n+\n+template<typename T>\n+void OOBTest() {\n+  char expected_str[100];\n+  for (int size = sizeof(T); size < 20; size += 5) {\n+    for (int i = -5; i < 0; i++) {\n+      const char *str =\n+          \"is located.*%d byte.*to the left\";\n+      sprintf(expected_str, str, abs(i));\n+      EXPECT_DEATH(oob_test<T>(size, i), expected_str);\n+    }\n+\n+    for (int i = 0; i < (int)(size - sizeof(T) + 1); i++)\n+      oob_test<T>(size, i);\n+\n+    for (int i = size - sizeof(T) + 1; i <= (int)(size + 2 * sizeof(T)); i++) {\n+      const char *str =\n+          \"is located.*%d byte.*to the right\";\n+      int off = i >= size ? (i - size) : 0;\n+      // we don't catch unaligned partially OOB accesses.\n+      if (i % sizeof(T)) continue;\n+      sprintf(expected_str, str, off);\n+      EXPECT_DEATH(oob_test<T>(size, i), expected_str);\n+    }\n+  }\n+\n+  EXPECT_DEATH(oob_test<T>(kLargeMalloc, -1),\n+          \"is located.*1 byte.*to the left\");\n+  EXPECT_DEATH(oob_test<T>(kLargeMalloc, kLargeMalloc),\n+          \"is located.*0 byte.*to the right\");\n+}\n+\n+// TODO(glider): the following tests are EXTREMELY slow on Darwin:\n+//   AddressSanitizer.OOB_char (125503 ms)\n+//   AddressSanitizer.OOB_int (126890 ms)\n+//   AddressSanitizer.OOBRightTest (315605 ms)\n+//   AddressSanitizer.SimpleStackTest (366559 ms)\n+\n+TEST(AddressSanitizer, OOB_char) {\n+  OOBTest<U1>();\n+}\n+\n+TEST(AddressSanitizer, OOB_int) {\n+  OOBTest<U4>();\n+}\n+\n+TEST(AddressSanitizer, OOBRightTest) {\n+  for (size_t access_size = 1; access_size <= 8; access_size *= 2) {\n+    for (size_t alloc_size = 1; alloc_size <= 8; alloc_size++) {\n+      for (size_t offset = 0; offset <= 8; offset += access_size) {\n+        void *p = malloc(alloc_size);\n+        // allocated: [p, p + alloc_size)\n+        // accessed:  [p + offset, p + offset + access_size)\n+        uint8_t *addr = (uint8_t*)p + offset;\n+        if (offset + access_size <= alloc_size) {\n+          asan_write_sized_aligned(addr, access_size);\n+        } else {\n+          int outside_bytes = offset > alloc_size ? (offset - alloc_size) : 0;\n+          const char *str =\n+              \"is located.%d *byte.*to the right\";\n+          char expected_str[100];\n+          sprintf(expected_str, str, outside_bytes);\n+          EXPECT_DEATH(asan_write_sized_aligned(addr, access_size),\n+                       expected_str);\n+        }\n+        free(p);\n+      }\n+    }\n+  }\n+}\n+\n+#if ASAN_ALLOCATOR_VERSION == 2  // Broken with the asan_allocator1\n+TEST(AddressSanitizer, LargeOOBRightTest) {\n+  size_t large_power_of_two = 1 << 19;\n+  for (size_t i = 16; i <= 256; i *= 2) {\n+    size_t size = large_power_of_two - i;\n+    char *p = Ident(new char[size]);\n+    EXPECT_DEATH(p[size] = 0, \"is located 0 bytes to the right\");\n+    delete [] p;\n+  }\n+}\n+#endif  // ASAN_ALLOCATOR_VERSION == 2\n+\n+TEST(AddressSanitizer, DISABLED_DemoOOBLeftLow) {\n+  oob_test<U1>(10, -1);\n+}\n+\n+TEST(AddressSanitizer, DISABLED_DemoOOBLeftHigh) {\n+  oob_test<U1>(kLargeMalloc, -1);\n+}\n+\n+TEST(AddressSanitizer, DISABLED_DemoOOBRightLow) {\n+  oob_test<U1>(10, 10);\n+}\n+\n+TEST(AddressSanitizer, DISABLED_DemoOOBRightHigh) {\n+  oob_test<U1>(kLargeMalloc, kLargeMalloc);\n+}"}, {"sha": "1b9805e8eb1971dcbbfd7efa9341e362417eef95", "filename": "gcc/testsuite/g++.dg/asan/asan_str_test.cc", "status": "added", "additions": 570, "deletions": 0, "changes": 570, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b0c7324054b014b73bd7e1c82ed95ae306ef794/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_str_test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b0c7324054b014b73bd7e1c82ed95ae306ef794/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_str_test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_str_test.cc?ref=3b0c7324054b014b73bd7e1c82ed95ae306ef794", "patch": "@@ -0,0 +1,570 @@\n+//=-- asan_str_test.cc ----------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+//===----------------------------------------------------------------------===//\n+#include \"asan_test_utils.h\"\n+\n+// Used for string functions tests\n+static char global_string[] = \"global\";\n+static size_t global_string_length = 6;\n+\n+// Input to a test is a zero-terminated string str with given length\n+// Accesses to the bytes to the left and to the right of str\n+// are presumed to produce OOB errors\n+void StrLenOOBTestTemplate(char *str, size_t length, bool is_global) {\n+  // Normal strlen calls\n+  EXPECT_EQ(strlen(str), length);\n+  if (length > 0) {\n+    EXPECT_EQ(length - 1, strlen(str + 1));\n+    EXPECT_EQ(0U, strlen(str + length));\n+  }\n+  // Arg of strlen is not malloced, OOB access\n+  if (!is_global) {\n+    // We don't insert RedZones to the left of global variables\n+    EXPECT_DEATH(Ident(strlen(str - 1)), LeftOOBReadMessage(1));\n+    EXPECT_DEATH(Ident(strlen(str - 5)), LeftOOBReadMessage(5));\n+  }\n+  EXPECT_DEATH(Ident(strlen(str + length + 1)), RightOOBReadMessage(0));\n+  // Overwrite terminator\n+  str[length] = 'a';\n+  // String is not zero-terminated, strlen will lead to OOB access\n+  EXPECT_DEATH(Ident(strlen(str)), RightOOBReadMessage(0));\n+  EXPECT_DEATH(Ident(strlen(str + length)), RightOOBReadMessage(0));\n+  // Restore terminator\n+  str[length] = 0;\n+}\n+TEST(AddressSanitizer, StrLenOOBTest) {\n+  // Check heap-allocated string\n+  size_t length = Ident(10);\n+  char *heap_string = Ident((char*)malloc(length + 1));\n+  char stack_string[10 + 1];\n+  break_optimization(&stack_string);\n+  for (size_t i = 0; i < length; i++) {\n+    heap_string[i] = 'a';\n+    stack_string[i] = 'b';\n+  }\n+  heap_string[length] = 0;\n+  stack_string[length] = 0;\n+  StrLenOOBTestTemplate(heap_string, length, false);\n+  // TODO(samsonov): Fix expected messages in StrLenOOBTestTemplate to\n+  //      make test for stack_string work. Or move it to output tests.\n+  // StrLenOOBTestTemplate(stack_string, length, false);\n+  StrLenOOBTestTemplate(global_string, global_string_length, true);\n+  free(heap_string);\n+}\n+\n+#ifndef __APPLE__\n+TEST(AddressSanitizer, StrNLenOOBTest) {\n+  size_t size = Ident(123);\n+  char *str = MallocAndMemsetString(size);\n+  // Normal strnlen calls.\n+  Ident(strnlen(str - 1, 0));\n+  Ident(strnlen(str, size));\n+  Ident(strnlen(str + size - 1, 1));\n+  str[size - 1] = '\\0';\n+  Ident(strnlen(str, 2 * size));\n+  // Argument points to not allocated memory.\n+  EXPECT_DEATH(Ident(strnlen(str - 1, 1)), LeftOOBReadMessage(1));\n+  EXPECT_DEATH(Ident(strnlen(str + size, 1)), RightOOBReadMessage(0));\n+  // Overwrite the terminating '\\0' and hit unallocated memory.\n+  str[size - 1] = 'z';\n+  EXPECT_DEATH(Ident(strnlen(str, size + 1)), RightOOBReadMessage(0));\n+  free(str);\n+}\n+#endif\n+\n+TEST(AddressSanitizer, StrDupOOBTest) {\n+  size_t size = Ident(42);\n+  char *str = MallocAndMemsetString(size);\n+  char *new_str;\n+  // Normal strdup calls.\n+  str[size - 1] = '\\0';\n+  new_str = strdup(str);\n+  free(new_str);\n+  new_str = strdup(str + size - 1);\n+  free(new_str);\n+  // Argument points to not allocated memory.\n+  EXPECT_DEATH(Ident(strdup(str - 1)), LeftOOBReadMessage(1));\n+  EXPECT_DEATH(Ident(strdup(str + size)), RightOOBReadMessage(0));\n+  // Overwrite the terminating '\\0' and hit unallocated memory.\n+  str[size - 1] = 'z';\n+  EXPECT_DEATH(Ident(strdup(str)), RightOOBReadMessage(0));\n+  free(str);\n+}\n+\n+TEST(AddressSanitizer, StrCpyOOBTest) {\n+  size_t to_size = Ident(30);\n+  size_t from_size = Ident(6);  // less than to_size\n+  char *to = Ident((char*)malloc(to_size));\n+  char *from = Ident((char*)malloc(from_size));\n+  // Normal strcpy calls.\n+  strcpy(from, \"hello\");\n+  strcpy(to, from);\n+  strcpy(to + to_size - from_size, from);\n+  // Length of \"from\" is too small.\n+  EXPECT_DEATH(Ident(strcpy(from, \"hello2\")), RightOOBWriteMessage(0));\n+  // \"to\" or \"from\" points to not allocated memory.\n+  EXPECT_DEATH(Ident(strcpy(to - 1, from)), LeftOOBWriteMessage(1));\n+  EXPECT_DEATH(Ident(strcpy(to, from - 1)), LeftOOBReadMessage(1));\n+  EXPECT_DEATH(Ident(strcpy(to, from + from_size)), RightOOBReadMessage(0));\n+  EXPECT_DEATH(Ident(strcpy(to + to_size, from)), RightOOBWriteMessage(0));\n+  // Overwrite the terminating '\\0' character and hit unallocated memory.\n+  from[from_size - 1] = '!';\n+  EXPECT_DEATH(Ident(strcpy(to, from)), RightOOBReadMessage(0));\n+  free(to);\n+  free(from);\n+}\n+\n+TEST(AddressSanitizer, StrNCpyOOBTest) {\n+  size_t to_size = Ident(20);\n+  size_t from_size = Ident(6);  // less than to_size\n+  char *to = Ident((char*)malloc(to_size));\n+  // From is a zero-terminated string \"hello\\0\" of length 6\n+  char *from = Ident((char*)malloc(from_size));\n+  strcpy(from, \"hello\");\n+  // copy 0 bytes\n+  strncpy(to, from, 0);\n+  strncpy(to - 1, from - 1, 0);\n+  // normal strncpy calls\n+  strncpy(to, from, from_size);\n+  strncpy(to, from, to_size);\n+  strncpy(to, from + from_size - 1, to_size);\n+  strncpy(to + to_size - 1, from, 1);\n+  // One of {to, from} points to not allocated memory\n+  EXPECT_DEATH(Ident(strncpy(to, from - 1, from_size)),\n+               LeftOOBReadMessage(1));\n+  EXPECT_DEATH(Ident(strncpy(to - 1, from, from_size)),\n+               LeftOOBWriteMessage(1));\n+  EXPECT_DEATH(Ident(strncpy(to, from + from_size, 1)),\n+               RightOOBReadMessage(0));\n+  EXPECT_DEATH(Ident(strncpy(to + to_size, from, 1)),\n+               RightOOBWriteMessage(0));\n+  // Length of \"to\" is too small\n+  EXPECT_DEATH(Ident(strncpy(to + to_size - from_size + 1, from, from_size)),\n+               RightOOBWriteMessage(0));\n+  EXPECT_DEATH(Ident(strncpy(to + 1, from, to_size)),\n+               RightOOBWriteMessage(0));\n+  // Overwrite terminator in from\n+  from[from_size - 1] = '!';\n+  // normal strncpy call\n+  strncpy(to, from, from_size);\n+  // Length of \"from\" is too small\n+  EXPECT_DEATH(Ident(strncpy(to, from, to_size)),\n+               RightOOBReadMessage(0));\n+  free(to);\n+  free(from);\n+}\n+\n+// Users may have different definitions of \"strchr\" and \"index\", so provide\n+// function pointer typedefs and overload RunStrChrTest implementation.\n+// We can't use macro for RunStrChrTest body here, as this macro would\n+// confuse EXPECT_DEATH gtest macro.\n+typedef char*(*PointerToStrChr1)(const char*, int);\n+typedef char*(*PointerToStrChr2)(char*, int);\n+\n+USED static void RunStrChrTest(PointerToStrChr1 StrChr) {\n+  size_t size = Ident(100);\n+  char *str = MallocAndMemsetString(size);\n+  str[10] = 'q';\n+  str[11] = '\\0';\n+  EXPECT_EQ(str, StrChr(str, 'z'));\n+  EXPECT_EQ(str + 10, StrChr(str, 'q'));\n+  EXPECT_EQ(NULL, StrChr(str, 'a'));\n+  // StrChr argument points to not allocated memory.\n+  EXPECT_DEATH(Ident(StrChr(str - 1, 'z')), LeftOOBReadMessage(1));\n+  EXPECT_DEATH(Ident(StrChr(str + size, 'z')), RightOOBReadMessage(0));\n+  // Overwrite the terminator and hit not allocated memory.\n+  str[11] = 'z';\n+  EXPECT_DEATH(Ident(StrChr(str, 'a')), RightOOBReadMessage(0));\n+  free(str);\n+}\n+USED static void RunStrChrTest(PointerToStrChr2 StrChr) {\n+  size_t size = Ident(100);\n+  char *str = MallocAndMemsetString(size);\n+  str[10] = 'q';\n+  str[11] = '\\0';\n+  EXPECT_EQ(str, StrChr(str, 'z'));\n+  EXPECT_EQ(str + 10, StrChr(str, 'q'));\n+  EXPECT_EQ(NULL, StrChr(str, 'a'));\n+  // StrChr argument points to not allocated memory.\n+  EXPECT_DEATH(Ident(StrChr(str - 1, 'z')), LeftOOBReadMessage(1));\n+  EXPECT_DEATH(Ident(StrChr(str + size, 'z')), RightOOBReadMessage(0));\n+  // Overwrite the terminator and hit not allocated memory.\n+  str[11] = 'z';\n+  EXPECT_DEATH(Ident(StrChr(str, 'a')), RightOOBReadMessage(0));\n+  free(str);\n+}\n+\n+TEST(AddressSanitizer, StrChrAndIndexOOBTest) {\n+  RunStrChrTest(&strchr);\n+  RunStrChrTest(&index);\n+}\n+\n+TEST(AddressSanitizer, StrCmpAndFriendsLogicTest) {\n+  // strcmp\n+  EXPECT_EQ(0, strcmp(\"\", \"\"));\n+  EXPECT_EQ(0, strcmp(\"abcd\", \"abcd\"));\n+  EXPECT_GT(0, strcmp(\"ab\", \"ac\"));\n+  EXPECT_GT(0, strcmp(\"abc\", \"abcd\"));\n+  EXPECT_LT(0, strcmp(\"acc\", \"abc\"));\n+  EXPECT_LT(0, strcmp(\"abcd\", \"abc\"));\n+\n+  // strncmp\n+  EXPECT_EQ(0, strncmp(\"a\", \"b\", 0));\n+  EXPECT_EQ(0, strncmp(\"abcd\", \"abcd\", 10));\n+  EXPECT_EQ(0, strncmp(\"abcd\", \"abcef\", 3));\n+  EXPECT_GT(0, strncmp(\"abcde\", \"abcfa\", 4));\n+  EXPECT_GT(0, strncmp(\"a\", \"b\", 5));\n+  EXPECT_GT(0, strncmp(\"bc\", \"bcde\", 4));\n+  EXPECT_LT(0, strncmp(\"xyz\", \"xyy\", 10));\n+  EXPECT_LT(0, strncmp(\"baa\", \"aaa\", 1));\n+  EXPECT_LT(0, strncmp(\"zyx\", \"\", 2));\n+\n+  // strcasecmp\n+  EXPECT_EQ(0, strcasecmp(\"\", \"\"));\n+  EXPECT_EQ(0, strcasecmp(\"zzz\", \"zzz\"));\n+  EXPECT_EQ(0, strcasecmp(\"abCD\", \"ABcd\"));\n+  EXPECT_GT(0, strcasecmp(\"aB\", \"Ac\"));\n+  EXPECT_GT(0, strcasecmp(\"ABC\", \"ABCd\"));\n+  EXPECT_LT(0, strcasecmp(\"acc\", \"abc\"));\n+  EXPECT_LT(0, strcasecmp(\"ABCd\", \"abc\"));\n+\n+  // strncasecmp\n+  EXPECT_EQ(0, strncasecmp(\"a\", \"b\", 0));\n+  EXPECT_EQ(0, strncasecmp(\"abCD\", \"ABcd\", 10));\n+  EXPECT_EQ(0, strncasecmp(\"abCd\", \"ABcef\", 3));\n+  EXPECT_GT(0, strncasecmp(\"abcde\", \"ABCfa\", 4));\n+  EXPECT_GT(0, strncasecmp(\"a\", \"B\", 5));\n+  EXPECT_GT(0, strncasecmp(\"bc\", \"BCde\", 4));\n+  EXPECT_LT(0, strncasecmp(\"xyz\", \"xyy\", 10));\n+  EXPECT_LT(0, strncasecmp(\"Baa\", \"aaa\", 1));\n+  EXPECT_LT(0, strncasecmp(\"zyx\", \"\", 2));\n+\n+  // memcmp\n+  EXPECT_EQ(0, memcmp(\"a\", \"b\", 0));\n+  EXPECT_EQ(0, memcmp(\"ab\\0c\", \"ab\\0c\", 4));\n+  EXPECT_GT(0, memcmp(\"\\0ab\", \"\\0ac\", 3));\n+  EXPECT_GT(0, memcmp(\"abb\\0\", \"abba\", 4));\n+  EXPECT_LT(0, memcmp(\"ab\\0cd\", \"ab\\0c\\0\", 5));\n+  EXPECT_LT(0, memcmp(\"zza\", \"zyx\", 3));\n+}\n+\n+typedef int(*PointerToStrCmp)(const char*, const char*);\n+void RunStrCmpTest(PointerToStrCmp StrCmp) {\n+  size_t size = Ident(100);\n+  int fill = 'o';\n+  char *s1 = MallocAndMemsetString(size, fill);\n+  char *s2 = MallocAndMemsetString(size, fill);\n+  s1[size - 1] = '\\0';\n+  s2[size - 1] = '\\0';\n+  // Normal StrCmp calls\n+  Ident(StrCmp(s1, s2));\n+  Ident(StrCmp(s1, s2 + size - 1));\n+  Ident(StrCmp(s1 + size - 1, s2 + size - 1));\n+  s1[size - 1] = 'z';\n+  s2[size - 1] = 'x';\n+  Ident(StrCmp(s1, s2));\n+  // One of arguments points to not allocated memory.\n+  EXPECT_DEATH(Ident(StrCmp)(s1 - 1, s2), LeftOOBReadMessage(1));\n+  EXPECT_DEATH(Ident(StrCmp)(s1, s2 - 1), LeftOOBReadMessage(1));\n+  EXPECT_DEATH(Ident(StrCmp)(s1 + size, s2), RightOOBReadMessage(0));\n+  EXPECT_DEATH(Ident(StrCmp)(s1, s2 + size), RightOOBReadMessage(0));\n+  // Hit unallocated memory and die.\n+  s1[size - 1] = fill;\n+  EXPECT_DEATH(Ident(StrCmp)(s1, s1), RightOOBReadMessage(0));\n+  EXPECT_DEATH(Ident(StrCmp)(s1 + size - 1, s2), RightOOBReadMessage(0));\n+  free(s1);\n+  free(s2);\n+}\n+\n+TEST(AddressSanitizer, StrCmpOOBTest) {\n+  RunStrCmpTest(&strcmp);\n+}\n+\n+TEST(AddressSanitizer, StrCaseCmpOOBTest) {\n+  RunStrCmpTest(&strcasecmp);\n+}\n+\n+typedef int(*PointerToStrNCmp)(const char*, const char*, size_t);\n+void RunStrNCmpTest(PointerToStrNCmp StrNCmp) {\n+  size_t size = Ident(100);\n+  char *s1 = MallocAndMemsetString(size);\n+  char *s2 = MallocAndMemsetString(size);\n+  s1[size - 1] = '\\0';\n+  s2[size - 1] = '\\0';\n+  // Normal StrNCmp calls\n+  Ident(StrNCmp(s1, s2, size + 2));\n+  s1[size - 1] = 'z';\n+  s2[size - 1] = 'x';\n+  Ident(StrNCmp(s1 + size - 2, s2 + size - 2, size));\n+  s2[size - 1] = 'z';\n+  Ident(StrNCmp(s1 - 1, s2 - 1, 0));\n+  Ident(StrNCmp(s1 + size - 1, s2 + size - 1, 1));\n+  // One of arguments points to not allocated memory.\n+  EXPECT_DEATH(Ident(StrNCmp)(s1 - 1, s2, 1), LeftOOBReadMessage(1));\n+  EXPECT_DEATH(Ident(StrNCmp)(s1, s2 - 1, 1), LeftOOBReadMessage(1));\n+  EXPECT_DEATH(Ident(StrNCmp)(s1 + size, s2, 1), RightOOBReadMessage(0));\n+  EXPECT_DEATH(Ident(StrNCmp)(s1, s2 + size, 1), RightOOBReadMessage(0));\n+  // Hit unallocated memory and die.\n+  EXPECT_DEATH(Ident(StrNCmp)(s1 + 1, s2 + 1, size), RightOOBReadMessage(0));\n+  EXPECT_DEATH(Ident(StrNCmp)(s1 + size - 1, s2, 2), RightOOBReadMessage(0));\n+  free(s1);\n+  free(s2);\n+}\n+\n+TEST(AddressSanitizer, StrNCmpOOBTest) {\n+  RunStrNCmpTest(&strncmp);\n+}\n+\n+TEST(AddressSanitizer, StrNCaseCmpOOBTest) {\n+  RunStrNCmpTest(&strncasecmp);\n+}\n+TEST(AddressSanitizer, StrCatOOBTest) {\n+  // strcat() reads strlen(to) bytes from |to| before concatenating.\n+  size_t to_size = Ident(100);\n+  char *to = MallocAndMemsetString(to_size);\n+  to[0] = '\\0';\n+  size_t from_size = Ident(20);\n+  char *from = MallocAndMemsetString(from_size);\n+  from[from_size - 1] = '\\0';\n+  // Normal strcat calls.\n+  strcat(to, from);\n+  strcat(to, from);\n+  strcat(to + from_size, from + from_size - 2);\n+  // Passing an invalid pointer is an error even when concatenating an empty\n+  // string.\n+  EXPECT_DEATH(strcat(to - 1, from + from_size - 1), LeftOOBAccessMessage(1));\n+  // One of arguments points to not allocated memory.\n+  EXPECT_DEATH(strcat(to - 1, from), LeftOOBAccessMessage(1));\n+  EXPECT_DEATH(strcat(to, from - 1), LeftOOBReadMessage(1));\n+  EXPECT_DEATH(strcat(to + to_size, from), RightOOBWriteMessage(0));\n+  EXPECT_DEATH(strcat(to, from + from_size), RightOOBReadMessage(0));\n+\n+  // \"from\" is not zero-terminated.\n+  from[from_size - 1] = 'z';\n+  EXPECT_DEATH(strcat(to, from), RightOOBReadMessage(0));\n+  from[from_size - 1] = '\\0';\n+  // \"to\" is not zero-terminated.\n+  memset(to, 'z', to_size);\n+  EXPECT_DEATH(strcat(to, from), RightOOBWriteMessage(0));\n+  // \"to\" is too short to fit \"from\".\n+  to[to_size - from_size + 1] = '\\0';\n+  EXPECT_DEATH(strcat(to, from), RightOOBWriteMessage(0));\n+  // length of \"to\" is just enough.\n+  strcat(to, from + 1);\n+\n+  free(to);\n+  free(from);\n+}\n+\n+TEST(AddressSanitizer, StrNCatOOBTest) {\n+  // strncat() reads strlen(to) bytes from |to| before concatenating.\n+  size_t to_size = Ident(100);\n+  char *to = MallocAndMemsetString(to_size);\n+  to[0] = '\\0';\n+  size_t from_size = Ident(20);\n+  char *from = MallocAndMemsetString(from_size);\n+  // Normal strncat calls.\n+  strncat(to, from, 0);\n+  strncat(to, from, from_size);\n+  from[from_size - 1] = '\\0';\n+  strncat(to, from, 2 * from_size);\n+  // Catenating empty string with an invalid string is still an error.\n+  EXPECT_DEATH(strncat(to - 1, from, 0), LeftOOBAccessMessage(1));\n+  strncat(to, from + from_size - 1, 10);\n+  // One of arguments points to not allocated memory.\n+  EXPECT_DEATH(strncat(to - 1, from, 2), LeftOOBAccessMessage(1));\n+  EXPECT_DEATH(strncat(to, from - 1, 2), LeftOOBReadMessage(1));\n+  EXPECT_DEATH(strncat(to + to_size, from, 2), RightOOBWriteMessage(0));\n+  EXPECT_DEATH(strncat(to, from + from_size, 2), RightOOBReadMessage(0));\n+\n+  memset(from, 'z', from_size);\n+  memset(to, 'z', to_size);\n+  to[0] = '\\0';\n+  // \"from\" is too short.\n+  EXPECT_DEATH(strncat(to, from, from_size + 1), RightOOBReadMessage(0));\n+  // \"to\" is not zero-terminated.\n+  EXPECT_DEATH(strncat(to + 1, from, 1), RightOOBWriteMessage(0));\n+  // \"to\" is too short to fit \"from\".\n+  to[0] = 'z';\n+  to[to_size - from_size + 1] = '\\0';\n+  EXPECT_DEATH(strncat(to, from, from_size - 1), RightOOBWriteMessage(0));\n+  // \"to\" is just enough.\n+  strncat(to, from, from_size - 2);\n+\n+  free(to);\n+  free(from);\n+}\n+\n+static string OverlapErrorMessage(const string &func) {\n+  return func + \"-param-overlap\";\n+}\n+\n+TEST(AddressSanitizer, StrArgsOverlapTest) {\n+  size_t size = Ident(100);\n+  char *str = Ident((char*)malloc(size));\n+\n+// Do not check memcpy() on OS X 10.7 and later, where it actually aliases\n+// memmove().\n+#if !defined(__APPLE__) || !defined(MAC_OS_X_VERSION_10_7) || \\\n+    (MAC_OS_X_VERSION_MAX_ALLOWED < MAC_OS_X_VERSION_10_7)\n+  // Check \"memcpy\". Use Ident() to avoid inlining.\n+  memset(str, 'z', size);\n+  Ident(memcpy)(str + 1, str + 11, 10);\n+  Ident(memcpy)(str, str, 0);\n+  EXPECT_DEATH(Ident(memcpy)(str, str + 14, 15), OverlapErrorMessage(\"memcpy\"));\n+  EXPECT_DEATH(Ident(memcpy)(str + 14, str, 15), OverlapErrorMessage(\"memcpy\"));\n+#endif\n+\n+  // We do not treat memcpy with to==from as a bug.\n+  // See http://llvm.org/bugs/show_bug.cgi?id=11763.\n+  // EXPECT_DEATH(Ident(memcpy)(str + 20, str + 20, 1),\n+  //              OverlapErrorMessage(\"memcpy\"));\n+\n+  // Check \"strcpy\".\n+  memset(str, 'z', size);\n+  str[9] = '\\0';\n+  strcpy(str + 10, str);\n+  EXPECT_DEATH(strcpy(str + 9, str), OverlapErrorMessage(\"strcpy\"));\n+  EXPECT_DEATH(strcpy(str, str + 4), OverlapErrorMessage(\"strcpy\"));\n+  strcpy(str, str + 5);\n+\n+  // Check \"strncpy\".\n+  memset(str, 'z', size);\n+  strncpy(str, str + 10, 10);\n+  EXPECT_DEATH(strncpy(str, str + 9, 10), OverlapErrorMessage(\"strncpy\"));\n+  EXPECT_DEATH(strncpy(str + 9, str, 10), OverlapErrorMessage(\"strncpy\"));\n+  str[10] = '\\0';\n+  strncpy(str + 11, str, 20);\n+  EXPECT_DEATH(strncpy(str + 10, str, 20), OverlapErrorMessage(\"strncpy\"));\n+\n+  // Check \"strcat\".\n+  memset(str, 'z', size);\n+  str[10] = '\\0';\n+  str[20] = '\\0';\n+  strcat(str, str + 10);\n+  EXPECT_DEATH(strcat(str, str + 11), OverlapErrorMessage(\"strcat\"));\n+  str[10] = '\\0';\n+  strcat(str + 11, str);\n+  EXPECT_DEATH(strcat(str, str + 9), OverlapErrorMessage(\"strcat\"));\n+  EXPECT_DEATH(strcat(str + 9, str), OverlapErrorMessage(\"strcat\"));\n+  EXPECT_DEATH(strcat(str + 10, str), OverlapErrorMessage(\"strcat\"));\n+\n+  // Check \"strncat\".\n+  memset(str, 'z', size);\n+  str[10] = '\\0';\n+  strncat(str, str + 10, 10);  // from is empty\n+  EXPECT_DEATH(strncat(str, str + 11, 10), OverlapErrorMessage(\"strncat\"));\n+  str[10] = '\\0';\n+  str[20] = '\\0';\n+  strncat(str + 5, str, 5);\n+  str[10] = '\\0';\n+  EXPECT_DEATH(strncat(str + 5, str, 6), OverlapErrorMessage(\"strncat\"));\n+  EXPECT_DEATH(strncat(str, str + 9, 10), OverlapErrorMessage(\"strncat\"));\n+\n+  free(str);\n+}\n+\n+void CallAtoi(const char *nptr) {\n+  Ident(atoi(nptr));\n+}\n+void CallAtol(const char *nptr) {\n+  Ident(atol(nptr));\n+}\n+void CallAtoll(const char *nptr) {\n+  Ident(atoll(nptr));\n+}\n+typedef void(*PointerToCallAtoi)(const char*);\n+\n+void RunAtoiOOBTest(PointerToCallAtoi Atoi) {\n+  char *array = MallocAndMemsetString(10, '1');\n+  // Invalid pointer to the string.\n+  EXPECT_DEATH(Atoi(array + 11), RightOOBReadMessage(1));\n+  EXPECT_DEATH(Atoi(array - 1), LeftOOBReadMessage(1));\n+  // Die if a buffer doesn't have terminating NULL.\n+  EXPECT_DEATH(Atoi(array), RightOOBReadMessage(0));\n+  // Make last symbol a terminating NULL or other non-digit.\n+  array[9] = '\\0';\n+  Atoi(array);\n+  array[9] = 'a';\n+  Atoi(array);\n+  Atoi(array + 9);\n+  // Sometimes we need to detect overflow if no digits are found.\n+  memset(array, ' ', 10);\n+  EXPECT_DEATH(Atoi(array), RightOOBReadMessage(0));\n+  array[9] = '-';\n+  EXPECT_DEATH(Atoi(array), RightOOBReadMessage(0));\n+  EXPECT_DEATH(Atoi(array + 9), RightOOBReadMessage(0));\n+  array[8] = '-';\n+  Atoi(array);\n+  free(array);\n+}\n+\n+TEST(AddressSanitizer, AtoiAndFriendsOOBTest) {\n+  RunAtoiOOBTest(&CallAtoi);\n+  RunAtoiOOBTest(&CallAtol);\n+  RunAtoiOOBTest(&CallAtoll);\n+}\n+\n+void CallStrtol(const char *nptr, char **endptr, int base) {\n+  Ident(strtol(nptr, endptr, base));\n+}\n+void CallStrtoll(const char *nptr, char **endptr, int base) {\n+  Ident(strtoll(nptr, endptr, base));\n+}\n+typedef void(*PointerToCallStrtol)(const char*, char**, int);\n+\n+void RunStrtolOOBTest(PointerToCallStrtol Strtol) {\n+  char *array = MallocAndMemsetString(3);\n+  char *endptr = NULL;\n+  array[0] = '1';\n+  array[1] = '2';\n+  array[2] = '3';\n+  // Invalid pointer to the string.\n+  EXPECT_DEATH(Strtol(array + 3, NULL, 0), RightOOBReadMessage(0));\n+  EXPECT_DEATH(Strtol(array - 1, NULL, 0), LeftOOBReadMessage(1));\n+  // Buffer overflow if there is no terminating null (depends on base).\n+  Strtol(array, &endptr, 3);\n+  EXPECT_EQ(array + 2, endptr);\n+  EXPECT_DEATH(Strtol(array, NULL, 0), RightOOBReadMessage(0));\n+  array[2] = 'z';\n+  Strtol(array, &endptr, 35);\n+  EXPECT_EQ(array + 2, endptr);\n+  EXPECT_DEATH(Strtol(array, NULL, 36), RightOOBReadMessage(0));\n+  // Add terminating zero to get rid of overflow.\n+  array[2] = '\\0';\n+  Strtol(array, NULL, 36);\n+  // Don't check for overflow if base is invalid.\n+  Strtol(array - 1, NULL, -1);\n+  Strtol(array + 3, NULL, 1);\n+  // Sometimes we need to detect overflow if no digits are found.\n+  array[0] = array[1] = array[2] = ' ';\n+  EXPECT_DEATH(Strtol(array, NULL, 0), RightOOBReadMessage(0));\n+  array[2] = '+';\n+  EXPECT_DEATH(Strtol(array, NULL, 0), RightOOBReadMessage(0));\n+  array[2] = '-';\n+  EXPECT_DEATH(Strtol(array, NULL, 0), RightOOBReadMessage(0));\n+  array[1] = '+';\n+  Strtol(array, NULL, 0);\n+  array[1] = array[2] = 'z';\n+  Strtol(array, &endptr, 0);\n+  EXPECT_EQ(array, endptr);\n+  Strtol(array + 2, NULL, 0);\n+  EXPECT_EQ(array, endptr);\n+  free(array);\n+}\n+\n+TEST(AddressSanitizer, StrtollOOBTest) {\n+  RunStrtolOOBTest(&CallStrtoll);\n+}\n+TEST(AddressSanitizer, StrtolOOBTest) {\n+  RunStrtolOOBTest(&CallStrtol);\n+}\n+\n+"}, {"sha": "e11531e07dee67144ad2222a8c7e47f7b774ccaf", "filename": "gcc/testsuite/g++.dg/asan/asan_test.C", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b0c7324054b014b73bd7e1c82ed95ae306ef794/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_test.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b0c7324054b014b73bd7e1c82ed95ae306ef794/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_test.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_test.C?ref=3b0c7324054b014b73bd7e1c82ed95ae306ef794", "patch": "@@ -1,7 +1,7 @@\n // { dg-do run { target { { i?86-*-linux* x86_64-*-linux* } && sse2_runtime } } }\n // { dg-skip-if \"\" { *-*-* } { \"*\" } { \"-O2\" } }\n // { dg-skip-if \"\" { *-*-* } { \"-flto\" } { \"\" } }\n-// { dg-additional-sources \"asan_globals_test.cc\" }\n+// { dg-additional-sources \"asan_globals_test-wrapper.cc\" }\n // { dg-options \"-fsanitize=address -fno-builtin -Wall -Wno-format -Werror -g -DASAN_UAR=0 -DASAN_HAS_EXCEPTIONS=1 -DASAN_HAS_BLACKLIST=0 -DASAN_USE_DEJAGNU_GTEST=1 -lasan -lpthread -ldl\" }\n // { dg-additional-options \"-DASAN_NEEDS_SEGV=1\" { target { ! arm*-*-* } } }\n // { dg-additional-options \"-DASAN_LOW_MEMORY=1 -DASAN_NEEDS_SEGV=0\" { target arm*-*-* } }\n@@ -11,3 +11,6 @@\n // { dg-final { asan-gtest } }\n \n #include \"asan_test.cc\"\n+#include \"asan_mem_test.cc\"\n+#include \"asan_str_test.cc\"\n+#include \"asan_oob_test.cc\""}, {"sha": "76b6e693498d5624c79635596659a0352eb6b7f8", "filename": "gcc/testsuite/g++.dg/asan/asan_test.cc", "status": "modified", "additions": 60, "deletions": 1242, "changes": 1302, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b0c7324054b014b73bd7e1c82ed95ae306ef794/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b0c7324054b014b73bd7e1c82ed95ae306ef794/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_test.cc?ref=3b0c7324054b014b73bd7e1c82ed95ae306ef794", "patch": "@@ -8,77 +8,8 @@\n // This file is a part of AddressSanitizer, an address sanity checker.\n //\n //===----------------------------------------------------------------------===//\n-#include <stdio.h>\n-#include <signal.h>\n-#include <stdlib.h>\n-#include <string.h>\n-#include <strings.h>\n-#include <pthread.h>\n-#include <stdint.h>\n-#include <setjmp.h>\n-#include <assert.h>\n-#include <algorithm>\n-\n-#ifdef __linux__\n-# include <sys/prctl.h>\n-# include <sys/types.h>\n-# include <sys/stat.h>\n-# include <fcntl.h>\n-#include <unistd.h>\n-#endif\n-\n-#if defined(__i386__) || defined(__x86_64__)\n-#include <emmintrin.h>\n-#endif\n-\n #include \"asan_test_utils.h\"\n \n-#ifndef __APPLE__\n-#include <malloc.h>\n-#else\n-#include <malloc/malloc.h>\n-#include <AvailabilityMacros.h>  // For MAC_OS_X_VERSION_*\n-#include <CoreFoundation/CFString.h>\n-#endif  // __APPLE__\n-\n-#if ASAN_HAS_EXCEPTIONS\n-# define ASAN_THROW(x) throw (x)\n-#else\n-# define ASAN_THROW(x)\n-#endif\n-\n-#include <sys/mman.h>\n-\n-typedef uint8_t   U1;\n-typedef uint16_t  U2;\n-typedef uint32_t  U4;\n-typedef uint64_t  U8;\n-\n-static const int kPageSize = 4096;\n-\n-// Simple stand-alone pseudorandom number generator.\n-// Current algorithm is ANSI C linear congruential PRNG.\n-static inline uint32_t my_rand(uint32_t* state) {\n-  return (*state = *state * 1103515245 + 12345) >> 16;\n-}\n-\n-static uint32_t global_seed = 0;\n-\n-const size_t kLargeMalloc = 1 << 24;\n-\n-template<typename T>\n-NOINLINE void asan_write(T *a) {\n-  *a = 0;\n-}\n-\n-NOINLINE void asan_write_sized_aligned(uint8_t *p, size_t size) {\n-  EXPECT_EQ(0U, ((uintptr_t)p % size));\n-  if      (size == 1) asan_write((uint8_t*)p);\n-  else if (size == 2) asan_write((uint16_t*)p);\n-  else if (size == 4) asan_write((uint32_t*)p);\n-  else if (size == 8) asan_write((uint64_t*)p);\n-}\n-\n NOINLINE void *malloc_fff(size_t size) {\n   void *res = malloc/**/(size); break_optimization(0); return res;}\n NOINLINE void *malloc_eee(size_t size) {\n@@ -112,15 +43,6 @@ NOINLINE void free_ccc(void *p) { free(p); break_optimization(0);}\n NOINLINE void free_bbb(void *p) { free_ccc(p); break_optimization(0);}\n NOINLINE void free_aaa(void *p) { free_bbb(p); break_optimization(0);}\n \n-template<typename T>\n-NOINLINE void oob_test(int size, int off) {\n-  char *p = (char*)malloc_aaa(size);\n-  // fprintf(stderr, \"writing %d byte(s) into [%p,%p) with offset %d\\n\",\n-  //        sizeof(T), p, p + size, off);\n-  asan_write((T*)(p + off));\n-  free_aaa(p);\n-}\n-\n \n template<typename T>\n NOINLINE void uaf_test(int size, int off) {\n@@ -237,88 +159,6 @@ TEST(AddressSanitizer, DISABLED_TSDTest) {\n   pthread_key_delete(test_key);\n }\n \n-template<typename T>\n-void OOBTest() {\n-  char expected_str[100];\n-  for (int size = sizeof(T); size < 20; size += 5) {\n-    for (int i = -5; i < 0; i++) {\n-      const char *str =\n-          \"is located.*%d byte.*to the left\";\n-      sprintf(expected_str, str, abs(i));\n-      EXPECT_DEATH(oob_test<T>(size, i), expected_str);\n-    }\n-\n-    for (int i = 0; i < (int)(size - sizeof(T) + 1); i++)\n-      oob_test<T>(size, i);\n-\n-    for (int i = size - sizeof(T) + 1; i <= (int)(size + 2 * sizeof(T)); i++) {\n-      const char *str =\n-          \"is located.*%d byte.*to the right\";\n-      int off = i >= size ? (i - size) : 0;\n-      // we don't catch unaligned partially OOB accesses.\n-      if (i % sizeof(T)) continue;\n-      sprintf(expected_str, str, off);\n-      EXPECT_DEATH(oob_test<T>(size, i), expected_str);\n-    }\n-  }\n-\n-  EXPECT_DEATH(oob_test<T>(kLargeMalloc, -1),\n-          \"is located.*1 byte.*to the left\");\n-  EXPECT_DEATH(oob_test<T>(kLargeMalloc, kLargeMalloc),\n-          \"is located.*0 byte.*to the right\");\n-}\n-\n-// TODO(glider): the following tests are EXTREMELY slow on Darwin:\n-//   AddressSanitizer.OOB_char (125503 ms)\n-//   AddressSanitizer.OOB_int (126890 ms)\n-//   AddressSanitizer.OOBRightTest (315605 ms)\n-//   AddressSanitizer.SimpleStackTest (366559 ms)\n-\n-TEST(AddressSanitizer, OOB_char) {\n-  OOBTest<U1>();\n-}\n-\n-TEST(AddressSanitizer, OOB_int) {\n-  OOBTest<U4>();\n-}\n-\n-TEST(AddressSanitizer, OOBRightTest) {\n-  for (size_t access_size = 1; access_size <= 8; access_size *= 2) {\n-    for (size_t alloc_size = 1; alloc_size <= 8; alloc_size++) {\n-      for (size_t offset = 0; offset <= 8; offset += access_size) {\n-        void *p = malloc(alloc_size);\n-        // allocated: [p, p + alloc_size)\n-        // accessed:  [p + offset, p + offset + access_size)\n-        uint8_t *addr = (uint8_t*)p + offset;\n-        if (offset + access_size <= alloc_size) {\n-          asan_write_sized_aligned(addr, access_size);\n-        } else {\n-          int outside_bytes = offset > alloc_size ? (offset - alloc_size) : 0;\n-          const char *str =\n-              \"is located.%d *byte.*to the right\";\n-          char expected_str[100];\n-          sprintf(expected_str, str, outside_bytes);\n-          EXPECT_DEATH(asan_write_sized_aligned(addr, access_size),\n-                       expected_str);\n-        }\n-        free(p);\n-      }\n-    }\n-  }\n-}\n-\n-#if ASAN_ALLOCATOR_VERSION == 2  // Broken with the asan_allocator1\n-TEST(AddressSanitizer, LargeOOBRightTest) {\n-  size_t large_power_of_two = 1 << 19;\n-  for (size_t i = 16; i <= 256; i *= 2) {\n-    size_t size = large_power_of_two - i;\n-    char *p = Ident(new char[size]);\n-    EXPECT_DEATH(p[size] = 0, \"is located 0 bytes to the right\");\n-    delete [] p;\n-  }\n-}\n-#endif  // ASAN_ALLOCATOR_VERSION == 2\n-\n TEST(AddressSanitizer, UAF_char) {\n   const char *uaf_string = \"AddressSanitizer:.*heap-use-after-free\";\n   EXPECT_DEATH(uaf_test<U1>(1, 0), uaf_string);\n@@ -415,21 +255,21 @@ TEST(AddressSanitizer, SignalTest) {\n #endif\n \n static void MallocStress(size_t n) {\n-  uint32_t seed = my_rand(&global_seed);\n+  uint32_t seed = my_rand();\n   for (size_t iter = 0; iter < 10; iter++) {\n     vector<void *> vec;\n     for (size_t i = 0; i < n; i++) {\n       if ((i % 3) == 0) {\n         if (vec.empty()) continue;\n-        size_t idx = my_rand(&seed) % vec.size();\n+        size_t idx = my_rand_r(&seed) % vec.size();\n         void *ptr = vec[idx];\n         vec[idx] = vec.back();\n         vec.pop_back();\n         free_aaa(ptr);\n       } else {\n-        size_t size = my_rand(&seed) % 1000 + 1;\n+        size_t size = my_rand_r(&seed) % 1000 + 1;\n #ifndef __APPLE__\n-        size_t alignment = 1 << (my_rand(&seed) % 7 + 3);\n+        size_t alignment = 1 << (my_rand_r(&seed) % 7 + 3);\n         char *ptr = (char*)memalign_aaa(alignment, size);\n #else\n         char *ptr = (char*) malloc_aaa(size);\n@@ -535,9 +375,36 @@ TEST(AddressSanitizer, ReallocTest) {\n   ptr[3] = 3;\n   for (int i = 0; i < 10000; i++) {\n     ptr = (int*)realloc(ptr,\n-        (my_rand(&global_seed) % 1000 + kMinElem) * sizeof(int));\n+        (my_rand() % 1000 + kMinElem) * sizeof(int));\n     EXPECT_EQ(3, ptr[3]);\n   }\n+  free(ptr);\n+  // Realloc pointer returned by malloc(0).\n+  int *ptr2 = Ident((int*)malloc(0));\n+  ptr2 = Ident((int*)realloc(ptr2, sizeof(*ptr2)));\n+  *ptr2 = 42;\n+  EXPECT_EQ(42, *ptr2);\n+  free(ptr2);\n+}\n+\n+TEST(AddressSanitizer, ZeroSizeMallocTest) {\n+  // Test that malloc(0) and similar functions don't return NULL.\n+  void *ptr = Ident(malloc(0));\n+  EXPECT_TRUE(NULL != ptr);\n+  free(ptr);\n+#if !defined(__APPLE__) && !defined(ANDROID) && !defined(__ANDROID__)\n+  int pm_res = posix_memalign(&ptr, 1<<20, 0);\n+  EXPECT_EQ(0, pm_res);\n+  EXPECT_TRUE(NULL != ptr);\n+  free(ptr);\n+#endif\n+  int *int_ptr = new int[0];\n+  int *int_ptr2 = new int[0];\n+  EXPECT_TRUE(NULL != int_ptr);\n+  EXPECT_TRUE(NULL != int_ptr2);\n+  EXPECT_NE(int_ptr, int_ptr2);\n+  delete[] int_ptr;\n+  delete[] int_ptr2;\n }\n \n #ifndef __APPLE__\n@@ -823,893 +690,78 @@ TEST(AddressSanitizer, Store128Test) {\n }\n #endif\n \n-static string RightOOBErrorMessage(int oob_distance, bool is_write) {\n+string RightOOBErrorMessage(int oob_distance, bool is_write) {\n   assert(oob_distance >= 0);\n   char expected_str[100];\n   sprintf(expected_str, ASAN_PCRE_DOTALL \"%s.*located %d bytes to the right\",\n           is_write ? \"WRITE\" : \"READ\", oob_distance);\n   return string(expected_str);\n }\n \n-static string RightOOBWriteMessage(int oob_distance) {\n+string RightOOBWriteMessage(int oob_distance) {\n   return RightOOBErrorMessage(oob_distance, /*is_write*/true);\n }\n \n-static string RightOOBReadMessage(int oob_distance) {\n+string RightOOBReadMessage(int oob_distance) {\n   return RightOOBErrorMessage(oob_distance, /*is_write*/false);\n }\n \n-static string LeftOOBErrorMessage(int oob_distance, bool is_write) {\n+string LeftOOBErrorMessage(int oob_distance, bool is_write) {\n   assert(oob_distance > 0);\n   char expected_str[100];\n   sprintf(expected_str, ASAN_PCRE_DOTALL \"%s.*located %d bytes to the left\",\n           is_write ? \"WRITE\" : \"READ\", oob_distance);\n   return string(expected_str);\n }\n \n-static string LeftOOBWriteMessage(int oob_distance) {\n+string LeftOOBWriteMessage(int oob_distance) {\n   return LeftOOBErrorMessage(oob_distance, /*is_write*/true);\n }\n \n-static string LeftOOBReadMessage(int oob_distance) {\n+string LeftOOBReadMessage(int oob_distance) {\n   return LeftOOBErrorMessage(oob_distance, /*is_write*/false);\n }\n \n-static string LeftOOBAccessMessage(int oob_distance) {\n+string LeftOOBAccessMessage(int oob_distance) {\n   assert(oob_distance > 0);\n   char expected_str[100];\n   sprintf(expected_str, \"located %d bytes to the left\", oob_distance);\n   return string(expected_str);\n }\n \n-template<typename T>\n-void MemSetOOBTestTemplate(size_t length) {\n-  if (length == 0) return;\n-  size_t size = Ident(sizeof(T) * length);\n-  T *array = Ident((T*)malloc(size));\n-  int element = Ident(42);\n-  int zero = Ident(0);\n-  void *(*MEMSET)(void *s, int c, size_t n) = Ident(memset);\n-  // memset interval inside array\n-  MEMSET(array, element, size);\n-  MEMSET(array, element, size - 1);\n-  MEMSET(array + length - 1, element, sizeof(T));\n-  MEMSET(array, element, 1);\n-\n-  // memset 0 bytes\n-  MEMSET(array - 10, element, zero);\n-  MEMSET(array - 1, element, zero);\n-  MEMSET(array, element, zero);\n-  MEMSET(array + length, 0, zero);\n-  MEMSET(array + length + 1, 0, zero);\n-\n-  // try to memset bytes to the right of array\n-  EXPECT_DEATH(MEMSET(array, 0, size + 1),\n-               RightOOBWriteMessage(0));\n-  EXPECT_DEATH(MEMSET((char*)(array + length) - 1, element, 6),\n-               RightOOBWriteMessage(0));\n-  EXPECT_DEATH(MEMSET(array + 1, element, size + sizeof(T)),\n-               RightOOBWriteMessage(0));\n-  // whole interval is to the right\n-  EXPECT_DEATH(MEMSET(array + length + 1, 0, 10),\n-               RightOOBWriteMessage(sizeof(T)));\n-\n-  // try to memset bytes to the left of array\n-  EXPECT_DEATH(MEMSET((char*)array - 1, element, size),\n-               LeftOOBWriteMessage(1));\n-  EXPECT_DEATH(MEMSET((char*)array - 5, 0, 6),\n-               LeftOOBWriteMessage(5));\n-  if (length >= 100) {\n-    // Large OOB, we find it only if the redzone is large enough.\n-    EXPECT_DEATH(memset(array - 5, element, size + 5 * sizeof(T)),\n-                 LeftOOBWriteMessage(5 * sizeof(T)));\n-  }\n-  // whole interval is to the left\n-  EXPECT_DEATH(MEMSET(array - 2, 0, sizeof(T)),\n-               LeftOOBWriteMessage(2 * sizeof(T)));\n-\n-  // try to memset bytes both to the left & to the right\n-  EXPECT_DEATH(MEMSET((char*)array - 2, element, size + 4),\n-               LeftOOBWriteMessage(2));\n-\n-  free(array);\n-}\n-\n-TEST(AddressSanitizer, MemSetOOBTest) {\n-  MemSetOOBTestTemplate<char>(100);\n-  MemSetOOBTestTemplate<int>(5);\n-  MemSetOOBTestTemplate<double>(256);\n-  // We can test arrays of structres/classes here, but what for?\n-}\n-\n-// Try to allocate two arrays of 'size' bytes that are near each other.\n-// Strictly speaking we are not guaranteed to find such two pointers,\n-// but given the structure of asan's allocator we will.\n-static bool AllocateTwoAdjacentArrays(char **x1, char **x2, size_t size) {\n-  vector<char *> v;\n-  bool res = false;\n-  for (size_t i = 0; i < 1000U && !res; i++) {\n-    v.push_back(new char[size]);\n-    if (i == 0) continue;\n-    sort(v.begin(), v.end());\n-    for (size_t j = 1; j < v.size(); j++) {\n-      assert(v[j] > v[j-1]);\n-      if ((size_t)(v[j] - v[j-1]) < size * 2) {\n-        *x2 = v[j];\n-        *x1 = v[j-1];\n-        res = true;\n-        break;\n-      }\n-    }\n-  }\n-\n-  for (size_t i = 0; i < v.size(); i++) {\n-    if (res && v[i] == *x1) continue;\n-    if (res && v[i] == *x2) continue;\n-    delete [] v[i];\n-  }\n-  return res;\n-}\n-\n-TEST(AddressSanitizer, LargeOOBInMemset) {\n-  for (size_t size = 200; size < 100000; size += size / 2) {\n-    char *x1, *x2;\n-    if (!Ident(AllocateTwoAdjacentArrays)(&x1, &x2, size))\n-      continue;\n-    // fprintf(stderr, \"  large oob memset: %p %p %zd\\n\", x1, x2, size);\n-    // Do a memset on x1 with huge out-of-bound access that will end up in x2.\n-    EXPECT_DEATH(Ident(memset)(x1, 0, size * 2),\n-                 \"is located 0 bytes to the right\");\n-    delete [] x1;\n-    delete [] x2;\n-    return;\n-  }\n-  assert(0 && \"Did not find two adjacent malloc-ed pointers\");\n-}\n-\n-// Same test for memcpy and memmove functions\n-template <typename T, class M>\n-void MemTransferOOBTestTemplate(size_t length) {\n-  if (length == 0) return;\n-  size_t size = Ident(sizeof(T) * length);\n-  T *src = Ident((T*)malloc(size));\n-  T *dest = Ident((T*)malloc(size));\n-  int zero = Ident(0);\n-\n-  // valid transfer of bytes between arrays\n-  M::transfer(dest, src, size);\n-  M::transfer(dest + 1, src, size - sizeof(T));\n-  M::transfer(dest, src + length - 1, sizeof(T));\n-  M::transfer(dest, src, 1);\n-\n-  // transfer zero bytes\n-  M::transfer(dest - 1, src, 0);\n-  M::transfer(dest + length, src, zero);\n-  M::transfer(dest, src - 1, zero);\n-  M::transfer(dest, src, zero);\n-\n-  // try to change mem to the right of dest\n-  EXPECT_DEATH(M::transfer(dest + 1, src, size),\n-               RightOOBWriteMessage(0));\n-  EXPECT_DEATH(M::transfer((char*)(dest + length) - 1, src, 5),\n-               RightOOBWriteMessage(0));\n-\n-  // try to change mem to the left of dest\n-  EXPECT_DEATH(M::transfer(dest - 2, src, size),\n-               LeftOOBWriteMessage(2 * sizeof(T)));\n-  EXPECT_DEATH(M::transfer((char*)dest - 3, src, 4),\n-               LeftOOBWriteMessage(3));\n-\n-  // try to access mem to the right of src\n-  EXPECT_DEATH(M::transfer(dest, src + 2, size),\n-               RightOOBReadMessage(0));\n-  EXPECT_DEATH(M::transfer(dest, (char*)(src + length) - 3, 6),\n-               RightOOBReadMessage(0));\n-\n-  // try to access mem to the left of src\n-  EXPECT_DEATH(M::transfer(dest, src - 1, size),\n-               LeftOOBReadMessage(sizeof(T)));\n-  EXPECT_DEATH(M::transfer(dest, (char*)src - 6, 7),\n-               LeftOOBReadMessage(6));\n-\n-  // Generally we don't need to test cases where both accessing src and writing\n-  // to dest address to poisoned memory.\n-\n-  T *big_src = Ident((T*)malloc(size * 2));\n-  T *big_dest = Ident((T*)malloc(size * 2));\n-  // try to change mem to both sides of dest\n-  EXPECT_DEATH(M::transfer(dest - 1, big_src, size * 2),\n-               LeftOOBWriteMessage(sizeof(T)));\n-  // try to access mem to both sides of src\n-  EXPECT_DEATH(M::transfer(big_dest, src - 2, size * 2),\n-               LeftOOBReadMessage(2 * sizeof(T)));\n-\n-  free(src);\n-  free(dest);\n-  free(big_src);\n-  free(big_dest);\n-}\n-\n-class MemCpyWrapper {\n- public:\n-  static void* transfer(void *to, const void *from, size_t size) {\n-    return Ident(memcpy)(to, from, size);\n-  }\n-};\n-TEST(AddressSanitizer, MemCpyOOBTest) {\n-  MemTransferOOBTestTemplate<char, MemCpyWrapper>(100);\n-  MemTransferOOBTestTemplate<int, MemCpyWrapper>(1024);\n-}\n-\n-class MemMoveWrapper {\n- public:\n-  static void* transfer(void *to, const void *from, size_t size) {\n-    return Ident(memmove)(to, from, size);\n-  }\n-};\n-TEST(AddressSanitizer, MemMoveOOBTest) {\n-  MemTransferOOBTestTemplate<char, MemMoveWrapper>(100);\n-  MemTransferOOBTestTemplate<int, MemMoveWrapper>(1024);\n-}\n-\n-// Tests for string functions\n-\n-// Used for string functions tests\n-static char global_string[] = \"global\";\n-static size_t global_string_length = 6;\n-\n-// Input to a test is a zero-terminated string str with given length\n-// Accesses to the bytes to the left and to the right of str\n-// are presumed to produce OOB errors\n-void StrLenOOBTestTemplate(char *str, size_t length, bool is_global) {\n-  // Normal strlen calls\n-  EXPECT_EQ(strlen(str), length);\n-  if (length > 0) {\n-    EXPECT_EQ(length - 1, strlen(str + 1));\n-    EXPECT_EQ(0U, strlen(str + length));\n-  }\n-  // Arg of strlen is not malloced, OOB access\n-  if (!is_global) {\n-    // We don't insert RedZones to the left of global variables\n-    EXPECT_DEATH(Ident(strlen(str - 1)), LeftOOBReadMessage(1));\n-    EXPECT_DEATH(Ident(strlen(str - 5)), LeftOOBReadMessage(5));\n-  }\n-  EXPECT_DEATH(Ident(strlen(str + length + 1)), RightOOBReadMessage(0));\n-  // Overwrite terminator\n-  str[length] = 'a';\n-  // String is not zero-terminated, strlen will lead to OOB access\n-  EXPECT_DEATH(Ident(strlen(str)), RightOOBReadMessage(0));\n-  EXPECT_DEATH(Ident(strlen(str + length)), RightOOBReadMessage(0));\n-  // Restore terminator\n-  str[length] = 0;\n-}\n-TEST(AddressSanitizer, StrLenOOBTest) {\n-  // Check heap-allocated string\n-  size_t length = Ident(10);\n-  char *heap_string = Ident((char*)malloc(length + 1));\n-  char stack_string[10 + 1];\n-  break_optimization(&stack_string);\n-  for (size_t i = 0; i < length; i++) {\n-    heap_string[i] = 'a';\n-    stack_string[i] = 'b';\n-  }\n-  heap_string[length] = 0;\n-  stack_string[length] = 0;\n-  StrLenOOBTestTemplate(heap_string, length, false);\n-  // TODO(samsonov): Fix expected messages in StrLenOOBTestTemplate to\n-  //      make test for stack_string work. Or move it to output tests.\n-  // StrLenOOBTestTemplate(stack_string, length, false);\n-  StrLenOOBTestTemplate(global_string, global_string_length, true);\n-  free(heap_string);\n-}\n-\n-static inline char* MallocAndMemsetString(size_t size, char ch) {\n+char* MallocAndMemsetString(size_t size, char ch) {\n   char *s = Ident((char*)malloc(size));\n   memset(s, ch, size);\n   return s;\n }\n-static inline char* MallocAndMemsetString(size_t size) {\n-  return MallocAndMemsetString(size, 'z');\n-}\n-\n-#ifndef __APPLE__\n-TEST(AddressSanitizer, StrNLenOOBTest) {\n-  size_t size = Ident(123);\n-  char *str = MallocAndMemsetString(size);\n-  // Normal strnlen calls.\n-  Ident(strnlen(str - 1, 0));\n-  Ident(strnlen(str, size));\n-  Ident(strnlen(str + size - 1, 1));\n-  str[size - 1] = '\\0';\n-  Ident(strnlen(str, 2 * size));\n-  // Argument points to not allocated memory.\n-  EXPECT_DEATH(Ident(strnlen(str - 1, 1)), LeftOOBReadMessage(1));\n-  EXPECT_DEATH(Ident(strnlen(str + size, 1)), RightOOBReadMessage(0));\n-  // Overwrite the terminating '\\0' and hit unallocated memory.\n-  str[size - 1] = 'z';\n-  EXPECT_DEATH(Ident(strnlen(str, size + 1)), RightOOBReadMessage(0));\n-  free(str);\n-}\n-#endif\n-\n-TEST(AddressSanitizer, StrDupOOBTest) {\n-  size_t size = Ident(42);\n-  char *str = MallocAndMemsetString(size);\n-  char *new_str;\n-  // Normal strdup calls.\n-  str[size - 1] = '\\0';\n-  new_str = strdup(str);\n-  free(new_str);\n-  new_str = strdup(str + size - 1);\n-  free(new_str);\n-  // Argument points to not allocated memory.\n-  EXPECT_DEATH(Ident(strdup(str - 1)), LeftOOBReadMessage(1));\n-  EXPECT_DEATH(Ident(strdup(str + size)), RightOOBReadMessage(0));\n-  // Overwrite the terminating '\\0' and hit unallocated memory.\n-  str[size - 1] = 'z';\n-  EXPECT_DEATH(Ident(strdup(str)), RightOOBReadMessage(0));\n-  free(str);\n-}\n-\n-TEST(AddressSanitizer, StrCpyOOBTest) {\n-  size_t to_size = Ident(30);\n-  size_t from_size = Ident(6);  // less than to_size\n-  char *to = Ident((char*)malloc(to_size));\n-  char *from = Ident((char*)malloc(from_size));\n-  // Normal strcpy calls.\n-  strcpy(from, \"hello\");\n-  strcpy(to, from);\n-  strcpy(to + to_size - from_size, from);\n-  // Length of \"from\" is too small.\n-  EXPECT_DEATH(Ident(strcpy(from, \"hello2\")), RightOOBWriteMessage(0));\n-  // \"to\" or \"from\" points to not allocated memory.\n-  EXPECT_DEATH(Ident(strcpy(to - 1, from)), LeftOOBWriteMessage(1));\n-  EXPECT_DEATH(Ident(strcpy(to, from - 1)), LeftOOBReadMessage(1));\n-  EXPECT_DEATH(Ident(strcpy(to, from + from_size)), RightOOBReadMessage(0));\n-  EXPECT_DEATH(Ident(strcpy(to + to_size, from)), RightOOBWriteMessage(0));\n-  // Overwrite the terminating '\\0' character and hit unallocated memory.\n-  from[from_size - 1] = '!';\n-  EXPECT_DEATH(Ident(strcpy(to, from)), RightOOBReadMessage(0));\n-  free(to);\n-  free(from);\n-}\n-\n-TEST(AddressSanitizer, StrNCpyOOBTest) {\n-  size_t to_size = Ident(20);\n-  size_t from_size = Ident(6);  // less than to_size\n-  char *to = Ident((char*)malloc(to_size));\n-  // From is a zero-terminated string \"hello\\0\" of length 6\n-  char *from = Ident((char*)malloc(from_size));\n-  strcpy(from, \"hello\");\n-  // copy 0 bytes\n-  strncpy(to, from, 0);\n-  strncpy(to - 1, from - 1, 0);\n-  // normal strncpy calls\n-  strncpy(to, from, from_size);\n-  strncpy(to, from, to_size);\n-  strncpy(to, from + from_size - 1, to_size);\n-  strncpy(to + to_size - 1, from, 1);\n-  // One of {to, from} points to not allocated memory\n-  EXPECT_DEATH(Ident(strncpy(to, from - 1, from_size)),\n-               LeftOOBReadMessage(1));\n-  EXPECT_DEATH(Ident(strncpy(to - 1, from, from_size)),\n-               LeftOOBWriteMessage(1));\n-  EXPECT_DEATH(Ident(strncpy(to, from + from_size, 1)),\n-               RightOOBReadMessage(0));\n-  EXPECT_DEATH(Ident(strncpy(to + to_size, from, 1)),\n-               RightOOBWriteMessage(0));\n-  // Length of \"to\" is too small\n-  EXPECT_DEATH(Ident(strncpy(to + to_size - from_size + 1, from, from_size)),\n-               RightOOBWriteMessage(0));\n-  EXPECT_DEATH(Ident(strncpy(to + 1, from, to_size)),\n-               RightOOBWriteMessage(0));\n-  // Overwrite terminator in from\n-  from[from_size - 1] = '!';\n-  // normal strncpy call\n-  strncpy(to, from, from_size);\n-  // Length of \"from\" is too small\n-  EXPECT_DEATH(Ident(strncpy(to, from, to_size)),\n-               RightOOBReadMessage(0));\n-  free(to);\n-  free(from);\n-}\n-\n-// Users may have different definitions of \"strchr\" and \"index\", so provide\n-// function pointer typedefs and overload RunStrChrTest implementation.\n-// We can't use macro for RunStrChrTest body here, as this macro would\n-// confuse EXPECT_DEATH gtest macro.\n-typedef char*(*PointerToStrChr1)(const char*, int);\n-typedef char*(*PointerToStrChr2)(char*, int);\n-\n-USED static void RunStrChrTest(PointerToStrChr1 StrChr) {\n-  size_t size = Ident(100);\n-  char *str = MallocAndMemsetString(size);\n-  str[10] = 'q';\n-  str[11] = '\\0';\n-  EXPECT_EQ(str, StrChr(str, 'z'));\n-  EXPECT_EQ(str + 10, StrChr(str, 'q'));\n-  EXPECT_EQ(NULL, StrChr(str, 'a'));\n-  // StrChr argument points to not allocated memory.\n-  EXPECT_DEATH(Ident(StrChr(str - 1, 'z')), LeftOOBReadMessage(1));\n-  EXPECT_DEATH(Ident(StrChr(str + size, 'z')), RightOOBReadMessage(0));\n-  // Overwrite the terminator and hit not allocated memory.\n-  str[11] = 'z';\n-  EXPECT_DEATH(Ident(StrChr(str, 'a')), RightOOBReadMessage(0));\n-  free(str);\n-}\n-USED static void RunStrChrTest(PointerToStrChr2 StrChr) {\n-  size_t size = Ident(100);\n-  char *str = MallocAndMemsetString(size);\n-  str[10] = 'q';\n-  str[11] = '\\0';\n-  EXPECT_EQ(str, StrChr(str, 'z'));\n-  EXPECT_EQ(str + 10, StrChr(str, 'q'));\n-  EXPECT_EQ(NULL, StrChr(str, 'a'));\n-  // StrChr argument points to not allocated memory.\n-  EXPECT_DEATH(Ident(StrChr(str - 1, 'z')), LeftOOBReadMessage(1));\n-  EXPECT_DEATH(Ident(StrChr(str + size, 'z')), RightOOBReadMessage(0));\n-  // Overwrite the terminator and hit not allocated memory.\n-  str[11] = 'z';\n-  EXPECT_DEATH(Ident(StrChr(str, 'a')), RightOOBReadMessage(0));\n-  free(str);\n-}\n-\n-TEST(AddressSanitizer, StrChrAndIndexOOBTest) {\n-  RunStrChrTest(&strchr);\n-  RunStrChrTest(&index);\n-}\n-\n-TEST(AddressSanitizer, StrCmpAndFriendsLogicTest) {\n-  // strcmp\n-  EXPECT_EQ(0, strcmp(\"\", \"\"));\n-  EXPECT_EQ(0, strcmp(\"abcd\", \"abcd\"));\n-  EXPECT_GT(0, strcmp(\"ab\", \"ac\"));\n-  EXPECT_GT(0, strcmp(\"abc\", \"abcd\"));\n-  EXPECT_LT(0, strcmp(\"acc\", \"abc\"));\n-  EXPECT_LT(0, strcmp(\"abcd\", \"abc\"));\n-\n-  // strncmp\n-  EXPECT_EQ(0, strncmp(\"a\", \"b\", 0));\n-  EXPECT_EQ(0, strncmp(\"abcd\", \"abcd\", 10));\n-  EXPECT_EQ(0, strncmp(\"abcd\", \"abcef\", 3));\n-  EXPECT_GT(0, strncmp(\"abcde\", \"abcfa\", 4));\n-  EXPECT_GT(0, strncmp(\"a\", \"b\", 5));\n-  EXPECT_GT(0, strncmp(\"bc\", \"bcde\", 4));\n-  EXPECT_LT(0, strncmp(\"xyz\", \"xyy\", 10));\n-  EXPECT_LT(0, strncmp(\"baa\", \"aaa\", 1));\n-  EXPECT_LT(0, strncmp(\"zyx\", \"\", 2));\n-\n-  // strcasecmp\n-  EXPECT_EQ(0, strcasecmp(\"\", \"\"));\n-  EXPECT_EQ(0, strcasecmp(\"zzz\", \"zzz\"));\n-  EXPECT_EQ(0, strcasecmp(\"abCD\", \"ABcd\"));\n-  EXPECT_GT(0, strcasecmp(\"aB\", \"Ac\"));\n-  EXPECT_GT(0, strcasecmp(\"ABC\", \"ABCd\"));\n-  EXPECT_LT(0, strcasecmp(\"acc\", \"abc\"));\n-  EXPECT_LT(0, strcasecmp(\"ABCd\", \"abc\"));\n-\n-  // strncasecmp\n-  EXPECT_EQ(0, strncasecmp(\"a\", \"b\", 0));\n-  EXPECT_EQ(0, strncasecmp(\"abCD\", \"ABcd\", 10));\n-  EXPECT_EQ(0, strncasecmp(\"abCd\", \"ABcef\", 3));\n-  EXPECT_GT(0, strncasecmp(\"abcde\", \"ABCfa\", 4));\n-  EXPECT_GT(0, strncasecmp(\"a\", \"B\", 5));\n-  EXPECT_GT(0, strncasecmp(\"bc\", \"BCde\", 4));\n-  EXPECT_LT(0, strncasecmp(\"xyz\", \"xyy\", 10));\n-  EXPECT_LT(0, strncasecmp(\"Baa\", \"aaa\", 1));\n-  EXPECT_LT(0, strncasecmp(\"zyx\", \"\", 2));\n-\n-  // memcmp\n-  EXPECT_EQ(0, memcmp(\"a\", \"b\", 0));\n-  EXPECT_EQ(0, memcmp(\"ab\\0c\", \"ab\\0c\", 4));\n-  EXPECT_GT(0, memcmp(\"\\0ab\", \"\\0ac\", 3));\n-  EXPECT_GT(0, memcmp(\"abb\\0\", \"abba\", 4));\n-  EXPECT_LT(0, memcmp(\"ab\\0cd\", \"ab\\0c\\0\", 5));\n-  EXPECT_LT(0, memcmp(\"zza\", \"zyx\", 3));\n-}\n-\n-typedef int(*PointerToStrCmp)(const char*, const char*);\n-void RunStrCmpTest(PointerToStrCmp StrCmp) {\n-  size_t size = Ident(100);\n-  int fill = 'o';\n-  char *s1 = MallocAndMemsetString(size, fill);\n-  char *s2 = MallocAndMemsetString(size, fill);\n-  s1[size - 1] = '\\0';\n-  s2[size - 1] = '\\0';\n-  // Normal StrCmp calls\n-  Ident(StrCmp(s1, s2));\n-  Ident(StrCmp(s1, s2 + size - 1));\n-  Ident(StrCmp(s1 + size - 1, s2 + size - 1));\n-  s1[size - 1] = 'z';\n-  s2[size - 1] = 'x';\n-  Ident(StrCmp(s1, s2));\n-  // One of arguments points to not allocated memory.\n-  EXPECT_DEATH(Ident(StrCmp)(s1 - 1, s2), LeftOOBReadMessage(1));\n-  EXPECT_DEATH(Ident(StrCmp)(s1, s2 - 1), LeftOOBReadMessage(1));\n-  EXPECT_DEATH(Ident(StrCmp)(s1 + size, s2), RightOOBReadMessage(0));\n-  EXPECT_DEATH(Ident(StrCmp)(s1, s2 + size), RightOOBReadMessage(0));\n-  // Hit unallocated memory and die.\n-  s1[size - 1] = fill;\n-  EXPECT_DEATH(Ident(StrCmp)(s1, s1), RightOOBReadMessage(0));\n-  EXPECT_DEATH(Ident(StrCmp)(s1 + size - 1, s2), RightOOBReadMessage(0));\n-  free(s1);\n-  free(s2);\n-}\n-\n-TEST(AddressSanitizer, StrCmpOOBTest) {\n-  RunStrCmpTest(&strcmp);\n-}\n-\n-TEST(AddressSanitizer, StrCaseCmpOOBTest) {\n-  RunStrCmpTest(&strcasecmp);\n-}\n-\n-typedef int(*PointerToStrNCmp)(const char*, const char*, size_t);\n-void RunStrNCmpTest(PointerToStrNCmp StrNCmp) {\n-  size_t size = Ident(100);\n-  char *s1 = MallocAndMemsetString(size);\n-  char *s2 = MallocAndMemsetString(size);\n-  s1[size - 1] = '\\0';\n-  s2[size - 1] = '\\0';\n-  // Normal StrNCmp calls\n-  Ident(StrNCmp(s1, s2, size + 2));\n-  s1[size - 1] = 'z';\n-  s2[size - 1] = 'x';\n-  Ident(StrNCmp(s1 + size - 2, s2 + size - 2, size));\n-  s2[size - 1] = 'z';\n-  Ident(StrNCmp(s1 - 1, s2 - 1, 0));\n-  Ident(StrNCmp(s1 + size - 1, s2 + size - 1, 1));\n-  // One of arguments points to not allocated memory.\n-  EXPECT_DEATH(Ident(StrNCmp)(s1 - 1, s2, 1), LeftOOBReadMessage(1));\n-  EXPECT_DEATH(Ident(StrNCmp)(s1, s2 - 1, 1), LeftOOBReadMessage(1));\n-  EXPECT_DEATH(Ident(StrNCmp)(s1 + size, s2, 1), RightOOBReadMessage(0));\n-  EXPECT_DEATH(Ident(StrNCmp)(s1, s2 + size, 1), RightOOBReadMessage(0));\n-  // Hit unallocated memory and die.\n-  EXPECT_DEATH(Ident(StrNCmp)(s1 + 1, s2 + 1, size), RightOOBReadMessage(0));\n-  EXPECT_DEATH(Ident(StrNCmp)(s1 + size - 1, s2, 2), RightOOBReadMessage(0));\n-  free(s1);\n-  free(s2);\n-}\n-\n-TEST(AddressSanitizer, StrNCmpOOBTest) {\n-  RunStrNCmpTest(&strncmp);\n-}\n-\n-TEST(AddressSanitizer, StrNCaseCmpOOBTest) {\n-  RunStrNCmpTest(&strncasecmp);\n-}\n-\n-TEST(AddressSanitizer, MemCmpOOBTest) {\n-  size_t size = Ident(100);\n-  char *s1 = MallocAndMemsetString(size);\n-  char *s2 = MallocAndMemsetString(size);\n-  // Normal memcmp calls.\n-  Ident(memcmp(s1, s2, size));\n-  Ident(memcmp(s1 + size - 1, s2 + size - 1, 1));\n-  Ident(memcmp(s1 - 1, s2 - 1, 0));\n-  // One of arguments points to not allocated memory.\n-  EXPECT_DEATH(Ident(memcmp)(s1 - 1, s2, 1), LeftOOBReadMessage(1));\n-  EXPECT_DEATH(Ident(memcmp)(s1, s2 - 1, 1), LeftOOBReadMessage(1));\n-  EXPECT_DEATH(Ident(memcmp)(s1 + size, s2, 1), RightOOBReadMessage(0));\n-  EXPECT_DEATH(Ident(memcmp)(s1, s2 + size, 1), RightOOBReadMessage(0));\n-  // Hit unallocated memory and die.\n-  EXPECT_DEATH(Ident(memcmp)(s1 + 1, s2 + 1, size), RightOOBReadMessage(0));\n-  EXPECT_DEATH(Ident(memcmp)(s1 + size - 1, s2, 2), RightOOBReadMessage(0));\n-  // Zero bytes are not terminators and don't prevent from OOB.\n-  s1[size - 1] = '\\0';\n-  s2[size - 1] = '\\0';\n-  EXPECT_DEATH(Ident(memcmp)(s1, s2, size + 1), RightOOBReadMessage(0));\n-  free(s1);\n-  free(s2);\n-}\n-\n-TEST(AddressSanitizer, StrCatOOBTest) {\n-  // strcat() reads strlen(to) bytes from |to| before concatenating.\n-  size_t to_size = Ident(100);\n-  char *to = MallocAndMemsetString(to_size);\n-  to[0] = '\\0';\n-  size_t from_size = Ident(20);\n-  char *from = MallocAndMemsetString(from_size);\n-  from[from_size - 1] = '\\0';\n-  // Normal strcat calls.\n-  strcat(to, from);\n-  strcat(to, from);\n-  strcat(to + from_size, from + from_size - 2);\n-  // Passing an invalid pointer is an error even when concatenating an empty\n-  // string.\n-  EXPECT_DEATH(strcat(to - 1, from + from_size - 1), LeftOOBAccessMessage(1));\n-  // One of arguments points to not allocated memory.\n-  EXPECT_DEATH(strcat(to - 1, from), LeftOOBAccessMessage(1));\n-  EXPECT_DEATH(strcat(to, from - 1), LeftOOBReadMessage(1));\n-  EXPECT_DEATH(strcat(to + to_size, from), RightOOBWriteMessage(0));\n-  EXPECT_DEATH(strcat(to, from + from_size), RightOOBReadMessage(0));\n-\n-  // \"from\" is not zero-terminated.\n-  from[from_size - 1] = 'z';\n-  EXPECT_DEATH(strcat(to, from), RightOOBReadMessage(0));\n-  from[from_size - 1] = '\\0';\n-  // \"to\" is not zero-terminated.\n-  memset(to, 'z', to_size);\n-  EXPECT_DEATH(strcat(to, from), RightOOBWriteMessage(0));\n-  // \"to\" is too short to fit \"from\".\n-  to[to_size - from_size + 1] = '\\0';\n-  EXPECT_DEATH(strcat(to, from), RightOOBWriteMessage(0));\n-  // length of \"to\" is just enough.\n-  strcat(to, from + 1);\n-\n-  free(to);\n-  free(from);\n-}\n-\n-TEST(AddressSanitizer, StrNCatOOBTest) {\n-  // strncat() reads strlen(to) bytes from |to| before concatenating.\n-  size_t to_size = Ident(100);\n-  char *to = MallocAndMemsetString(to_size);\n-  to[0] = '\\0';\n-  size_t from_size = Ident(20);\n-  char *from = MallocAndMemsetString(from_size);\n-  // Normal strncat calls.\n-  strncat(to, from, 0);\n-  strncat(to, from, from_size);\n-  from[from_size - 1] = '\\0';\n-  strncat(to, from, 2 * from_size);\n-  // Catenating empty string with an invalid string is still an error.\n-  EXPECT_DEATH(strncat(to - 1, from, 0), LeftOOBAccessMessage(1));\n-  strncat(to, from + from_size - 1, 10);\n-  // One of arguments points to not allocated memory.\n-  EXPECT_DEATH(strncat(to - 1, from, 2), LeftOOBAccessMessage(1));\n-  EXPECT_DEATH(strncat(to, from - 1, 2), LeftOOBReadMessage(1));\n-  EXPECT_DEATH(strncat(to + to_size, from, 2), RightOOBWriteMessage(0));\n-  EXPECT_DEATH(strncat(to, from + from_size, 2), RightOOBReadMessage(0));\n-\n-  memset(from, 'z', from_size);\n-  memset(to, 'z', to_size);\n-  to[0] = '\\0';\n-  // \"from\" is too short.\n-  EXPECT_DEATH(strncat(to, from, from_size + 1), RightOOBReadMessage(0));\n-  // \"to\" is not zero-terminated.\n-  EXPECT_DEATH(strncat(to + 1, from, 1), RightOOBWriteMessage(0));\n-  // \"to\" is too short to fit \"from\".\n-  to[0] = 'z';\n-  to[to_size - from_size + 1] = '\\0';\n-  EXPECT_DEATH(strncat(to, from, from_size - 1), RightOOBWriteMessage(0));\n-  // \"to\" is just enough.\n-  strncat(to, from, from_size - 2);\n-\n-  free(to);\n-  free(from);\n-}\n-\n-static string OverlapErrorMessage(const string &func) {\n-  return func + \"-param-overlap\";\n-}\n-\n-TEST(AddressSanitizer, StrArgsOverlapTest) {\n-  size_t size = Ident(100);\n-  char *str = Ident((char*)malloc(size));\n-\n-// Do not check memcpy() on OS X 10.7 and later, where it actually aliases\n-// memmove().\n-#if !defined(__APPLE__) || !defined(MAC_OS_X_VERSION_10_7) || \\\n-    (MAC_OS_X_VERSION_MAX_ALLOWED < MAC_OS_X_VERSION_10_7)\n-  // Check \"memcpy\". Use Ident() to avoid inlining.\n-  memset(str, 'z', size);\n-  Ident(memcpy)(str + 1, str + 11, 10);\n-  Ident(memcpy)(str, str, 0);\n-  EXPECT_DEATH(Ident(memcpy)(str, str + 14, 15), OverlapErrorMessage(\"memcpy\"));\n-  EXPECT_DEATH(Ident(memcpy)(str + 14, str, 15), OverlapErrorMessage(\"memcpy\"));\n-#endif\n-\n-  // We do not treat memcpy with to==from as a bug.\n-  // See http://llvm.org/bugs/show_bug.cgi?id=11763.\n-  // EXPECT_DEATH(Ident(memcpy)(str + 20, str + 20, 1),\n-  //              OverlapErrorMessage(\"memcpy\"));\n-\n-  // Check \"strcpy\".\n-  memset(str, 'z', size);\n-  str[9] = '\\0';\n-  strcpy(str + 10, str);\n-  EXPECT_DEATH(strcpy(str + 9, str), OverlapErrorMessage(\"strcpy\"));\n-  EXPECT_DEATH(strcpy(str, str + 4), OverlapErrorMessage(\"strcpy\"));\n-  strcpy(str, str + 5);\n-\n-  // Check \"strncpy\".\n-  memset(str, 'z', size);\n-  strncpy(str, str + 10, 10);\n-  EXPECT_DEATH(strncpy(str, str + 9, 10), OverlapErrorMessage(\"strncpy\"));\n-  EXPECT_DEATH(strncpy(str + 9, str, 10), OverlapErrorMessage(\"strncpy\"));\n-  str[10] = '\\0';\n-  strncpy(str + 11, str, 20);\n-  EXPECT_DEATH(strncpy(str + 10, str, 20), OverlapErrorMessage(\"strncpy\"));\n-\n-  // Check \"strcat\".\n-  memset(str, 'z', size);\n-  str[10] = '\\0';\n-  str[20] = '\\0';\n-  strcat(str, str + 10);\n-  EXPECT_DEATH(strcat(str, str + 11), OverlapErrorMessage(\"strcat\"));\n-  str[10] = '\\0';\n-  strcat(str + 11, str);\n-  EXPECT_DEATH(strcat(str, str + 9), OverlapErrorMessage(\"strcat\"));\n-  EXPECT_DEATH(strcat(str + 9, str), OverlapErrorMessage(\"strcat\"));\n-  EXPECT_DEATH(strcat(str + 10, str), OverlapErrorMessage(\"strcat\"));\n-\n-  // Check \"strncat\".\n-  memset(str, 'z', size);\n-  str[10] = '\\0';\n-  strncat(str, str + 10, 10);  // from is empty\n-  EXPECT_DEATH(strncat(str, str + 11, 10), OverlapErrorMessage(\"strncat\"));\n-  str[10] = '\\0';\n-  str[20] = '\\0';\n-  strncat(str + 5, str, 5);\n-  str[10] = '\\0';\n-  EXPECT_DEATH(strncat(str + 5, str, 6), OverlapErrorMessage(\"strncat\"));\n-  EXPECT_DEATH(strncat(str, str + 9, 10), OverlapErrorMessage(\"strncat\"));\n-\n-  free(str);\n-}\n-\n-void CallAtoi(const char *nptr) {\n-  Ident(atoi(nptr));\n-}\n-void CallAtol(const char *nptr) {\n-  Ident(atol(nptr));\n-}\n-void CallAtoll(const char *nptr) {\n-  Ident(atoll(nptr));\n-}\n-typedef void(*PointerToCallAtoi)(const char*);\n-\n-void RunAtoiOOBTest(PointerToCallAtoi Atoi) {\n-  char *array = MallocAndMemsetString(10, '1');\n-  // Invalid pointer to the string.\n-  EXPECT_DEATH(Atoi(array + 11), RightOOBReadMessage(1));\n-  EXPECT_DEATH(Atoi(array - 1), LeftOOBReadMessage(1));\n-  // Die if a buffer doesn't have terminating NULL.\n-  EXPECT_DEATH(Atoi(array), RightOOBReadMessage(0));\n-  // Make last symbol a terminating NULL or other non-digit.\n-  array[9] = '\\0';\n-  Atoi(array);\n-  array[9] = 'a';\n-  Atoi(array);\n-  Atoi(array + 9);\n-  // Sometimes we need to detect overflow if no digits are found.\n-  memset(array, ' ', 10);\n-  EXPECT_DEATH(Atoi(array), RightOOBReadMessage(0));\n-  array[9] = '-';\n-  EXPECT_DEATH(Atoi(array), RightOOBReadMessage(0));\n-  EXPECT_DEATH(Atoi(array + 9), RightOOBReadMessage(0));\n-  array[8] = '-';\n-  Atoi(array);\n-  free(array);\n-}\n-\n-TEST(AddressSanitizer, AtoiAndFriendsOOBTest) {\n-  RunAtoiOOBTest(&CallAtoi);\n-  RunAtoiOOBTest(&CallAtol);\n-  RunAtoiOOBTest(&CallAtoll);\n-}\n-\n-void CallStrtol(const char *nptr, char **endptr, int base) {\n-  Ident(strtol(nptr, endptr, base));\n-}\n-void CallStrtoll(const char *nptr, char **endptr, int base) {\n-  Ident(strtoll(nptr, endptr, base));\n-}\n-typedef void(*PointerToCallStrtol)(const char*, char**, int);\n-\n-void RunStrtolOOBTest(PointerToCallStrtol Strtol) {\n-  char *array = MallocAndMemsetString(3);\n-  char *endptr = NULL;\n-  array[0] = '1';\n-  array[1] = '2';\n-  array[2] = '3';\n-  // Invalid pointer to the string.\n-  EXPECT_DEATH(Strtol(array + 3, NULL, 0), RightOOBReadMessage(0));\n-  EXPECT_DEATH(Strtol(array - 1, NULL, 0), LeftOOBReadMessage(1));\n-  // Buffer overflow if there is no terminating null (depends on base).\n-  Strtol(array, &endptr, 3);\n-  EXPECT_EQ(array + 2, endptr);\n-  EXPECT_DEATH(Strtol(array, NULL, 0), RightOOBReadMessage(0));\n-  array[2] = 'z';\n-  Strtol(array, &endptr, 35);\n-  EXPECT_EQ(array + 2, endptr);\n-  EXPECT_DEATH(Strtol(array, NULL, 36), RightOOBReadMessage(0));\n-  // Add terminating zero to get rid of overflow.\n-  array[2] = '\\0';\n-  Strtol(array, NULL, 36);\n-  // Don't check for overflow if base is invalid.\n-  Strtol(array - 1, NULL, -1);\n-  Strtol(array + 3, NULL, 1);\n-  // Sometimes we need to detect overflow if no digits are found.\n-  array[0] = array[1] = array[2] = ' ';\n-  EXPECT_DEATH(Strtol(array, NULL, 0), RightOOBReadMessage(0));\n-  array[2] = '+';\n-  EXPECT_DEATH(Strtol(array, NULL, 0), RightOOBReadMessage(0));\n-  array[2] = '-';\n-  EXPECT_DEATH(Strtol(array, NULL, 0), RightOOBReadMessage(0));\n-  array[1] = '+';\n-  Strtol(array, NULL, 0);\n-  array[1] = array[2] = 'z';\n-  Strtol(array, &endptr, 0);\n-  EXPECT_EQ(array, endptr);\n-  Strtol(array + 2, NULL, 0);\n-  EXPECT_EQ(array, endptr);\n-  free(array);\n-}\n-\n-TEST(AddressSanitizer, StrtollOOBTest) {\n-  RunStrtolOOBTest(&CallStrtoll);\n-}\n-TEST(AddressSanitizer, StrtolOOBTest) {\n-  RunStrtolOOBTest(&CallStrtol);\n-}\n-\n-// At the moment we instrument memcpy/memove/memset calls at compile time so we\n-// can't handle OOB error if these functions are called by pointer, see disabled\n-// MemIntrinsicCallByPointerTest below\n-typedef void*(*PointerToMemTransfer)(void*, const void*, size_t);\n-typedef void*(*PointerToMemSet)(void*, int, size_t);\n-\n-void CallMemSetByPointer(PointerToMemSet MemSet) {\n-  size_t size = Ident(100);\n-  char *array = Ident((char*)malloc(size));\n-  EXPECT_DEATH(MemSet(array, 0, 101), RightOOBWriteMessage(0));\n-  free(array);\n-}\n-\n-void CallMemTransferByPointer(PointerToMemTransfer MemTransfer) {\n-  size_t size = Ident(100);\n-  char *src = Ident((char*)malloc(size));\n-  char *dst = Ident((char*)malloc(size));\n-  EXPECT_DEATH(MemTransfer(dst, src, 101), RightOOBWriteMessage(0));\n-  free(src);\n-  free(dst);\n-}\n \n-TEST(AddressSanitizer, DISABLED_MemIntrinsicCallByPointerTest) {\n-  CallMemSetByPointer(&memset);\n-  CallMemTransferByPointer(&memcpy);\n-  CallMemTransferByPointer(&memmove);\n+char* MallocAndMemsetString(size_t size) {\n+  return MallocAndMemsetString(size, 'z');\n }\n \n #if defined(__linux__) && !defined(ANDROID) && !defined(__ANDROID__)\n+#define READ_TEST(READ_N_BYTES)                                          \\\n+  char *x = new char[10];                                                \\\n+  int fd = open(\"/proc/self/stat\", O_RDONLY);                            \\\n+  ASSERT_GT(fd, 0);                                                      \\\n+  EXPECT_DEATH(READ_N_BYTES,                                             \\\n+               ASAN_PCRE_DOTALL                                          \\\n+               \"AddressSanitizer: heap-buffer-overflow\"                  \\\n+               \".* is located 0 bytes to the right of 10-byte region\");  \\\n+  close(fd);                                                             \\\n+  delete [] x;                                                           \\\n+\n TEST(AddressSanitizer, pread) {\n-  char *x = new char[10];\n-  int fd = open(\"/proc/self/stat\", O_RDONLY);\n-  ASSERT_GT(fd, 0);\n-  EXPECT_DEATH(pread(fd, x, 15, 0),\n-               ASAN_PCRE_DOTALL\n-               \"AddressSanitizer: heap-buffer-overflow\"\n-               \".* is located 0 bytes to the right of 10-byte region\");\n-  close(fd);\n-  delete [] x;\n+  READ_TEST(pread(fd, x, 15, 0));\n }\n \n TEST(AddressSanitizer, pread64) {\n-  char *x = new char[10];\n-  int fd = open(\"/proc/self/stat\", O_RDONLY);\n-  ASSERT_GT(fd, 0);\n-  EXPECT_DEATH(pread64(fd, x, 15, 0),\n-               ASAN_PCRE_DOTALL\n-               \"AddressSanitizer: heap-buffer-overflow\"\n-               \".* is located 0 bytes to the right of 10-byte region\");\n-  close(fd);\n-  delete [] x;\n+  READ_TEST(pread64(fd, x, 15, 0));\n }\n \n TEST(AddressSanitizer, read) {\n-  char *x = new char[10];\n-  int fd = open(\"/proc/self/stat\", O_RDONLY);\n-  ASSERT_GT(fd, 0);\n-  EXPECT_DEATH(read(fd, x, 15),\n-               ASAN_PCRE_DOTALL\n-               \"AddressSanitizer: heap-buffer-overflow\"\n-               \".* is located 0 bytes to the right of 10-byte region\");\n-  close(fd);\n-  delete [] x;\n+  READ_TEST(read(fd, x, 15));\n }\n-\n #endif  // defined(__linux__) && !defined(ANDROID) && !defined(__ANDROID__)\n \n // This test case fails\n@@ -1873,11 +925,9 @@ TEST(AddressSanitizer, StrDupTest) {\n }\n \n // Currently we create and poison redzone at right of global variables.\n-char glob5[5];\n static char static110[110];\n const char ConstGlob[7] = {1, 2, 3, 4, 5, 6, 7};\n static const char StaticConstGlob[3] = {9, 8, 7};\n-extern int GlobalsTest(int x);\n \n TEST(AddressSanitizer, GlobalTest) {\n   static char func_static15[15];\n@@ -2058,13 +1108,13 @@ TEST(AddressSanitizer, AttributeNoAddressSafetyTest) {\n   Ident(NoAddressSafety)();\n }\n \n+// It doesn't work on Android, as calls to new/delete go through malloc/free.\n+#if !defined(ANDROID) && !defined(__ANDROID__)\n static string MismatchStr(const string &str) {\n   return string(\"AddressSanitizer: alloc-dealloc-mismatch \\\\(\") + str;\n }\n \n-// This test is disabled until we enable alloc_dealloc_mismatch by default.\n-// The feature is also tested by lit tests.\n-TEST(AddressSanitizer, DISABLED_AllocDeallocMismatch) {\n+TEST(AddressSanitizer, AllocDeallocMismatch) {\n   EXPECT_DEATH(free(Ident(new int)),\n                MismatchStr(\"operator new vs free\"));\n   EXPECT_DEATH(free(Ident(new int[2])),\n@@ -2078,6 +1128,7 @@ TEST(AddressSanitizer, DISABLED_AllocDeallocMismatch) {\n   EXPECT_DEATH(delete [] (Ident((int*)malloc(2 * sizeof(int)))),\n                MismatchStr(\"malloc vs operator delete \\\\[\\\\]\"));\n }\n+#endif\n \n // ------------------ demo tests; run each one-by-one -------------\n // e.g. --gtest_filter=*DemoOOBLeftHigh --gtest_also_run_disabled_tests\n@@ -2115,22 +1166,6 @@ TEST(AddressSanitizer, DISABLED_DemoUAFHigh) {\n   uaf_test<U1>(kLargeMalloc, 0);\n }\n \n-TEST(AddressSanitizer, DISABLED_DemoOOBLeftLow) {\n-  oob_test<U1>(10, -1);\n-}\n-\n-TEST(AddressSanitizer, DISABLED_DemoOOBLeftHigh) {\n-  oob_test<U1>(kLargeMalloc, -1);\n-}\n-\n-TEST(AddressSanitizer, DISABLED_DemoOOBRightLow) {\n-  oob_test<U1>(10, 10);\n-}\n-\n-TEST(AddressSanitizer, DISABLED_DemoOOBRightHigh) {\n-  oob_test<U1>(kLargeMalloc, kLargeMalloc);\n-}\n-\n TEST(AddressSanitizer, DISABLED_DemoOOM) {\n   size_t size = SANITIZER_WORDSIZE == 64 ? (size_t)(1ULL << 40) : (0xf0000000);\n   printf(\"%p\\n\", malloc(size));\n@@ -2178,223 +1213,6 @@ TEST(AddressSanitizer, BufferOverflowAfterManyFrees) {\n   delete [] Ident(x);\n }\n \n-#ifdef __APPLE__\n-#include \"asan_mac_test.h\"\n-TEST(AddressSanitizerMac, CFAllocatorDefaultDoubleFree) {\n-  EXPECT_DEATH(\n-      CFAllocatorDefaultDoubleFree(NULL),\n-      \"attempting double-free\");\n-}\n-\n-void CFAllocator_DoubleFreeOnPthread() {\n-  pthread_t child;\n-  PTHREAD_CREATE(&child, NULL, CFAllocatorDefaultDoubleFree, NULL);\n-  PTHREAD_JOIN(child, NULL);  // Shouldn't be reached.\n-}\n-\n-TEST(AddressSanitizerMac, CFAllocatorDefaultDoubleFree_ChildPhread) {\n-  EXPECT_DEATH(CFAllocator_DoubleFreeOnPthread(), \"attempting double-free\");\n-}\n-\n-namespace {\n-\n-void *GLOB;\n-\n-void *CFAllocatorAllocateToGlob(void *unused) {\n-  GLOB = CFAllocatorAllocate(NULL, 100, /*hint*/0);\n-  return NULL;\n-}\n-\n-void *CFAllocatorDeallocateFromGlob(void *unused) {\n-  char *p = (char*)GLOB;\n-  p[100] = 'A';  // ASan should report an error here.\n-  CFAllocatorDeallocate(NULL, GLOB);\n-  return NULL;\n-}\n-\n-void CFAllocator_PassMemoryToAnotherThread() {\n-  pthread_t th1, th2;\n-  PTHREAD_CREATE(&th1, NULL, CFAllocatorAllocateToGlob, NULL);\n-  PTHREAD_JOIN(th1, NULL);\n-  PTHREAD_CREATE(&th2, NULL, CFAllocatorDeallocateFromGlob, NULL);\n-  PTHREAD_JOIN(th2, NULL);\n-}\n-\n-TEST(AddressSanitizerMac, CFAllocator_PassMemoryToAnotherThread) {\n-  EXPECT_DEATH(CFAllocator_PassMemoryToAnotherThread(),\n-               \"heap-buffer-overflow\");\n-}\n-\n-}  // namespace\n-\n-// TODO(glider): figure out whether we still need these tests. Is it correct\n-// to intercept the non-default CFAllocators?\n-TEST(AddressSanitizerMac, DISABLED_CFAllocatorSystemDefaultDoubleFree) {\n-  EXPECT_DEATH(\n-      CFAllocatorSystemDefaultDoubleFree(),\n-      \"attempting double-free\");\n-}\n-\n-// We're intercepting malloc, so kCFAllocatorMalloc is routed to ASan.\n-TEST(AddressSanitizerMac, CFAllocatorMallocDoubleFree) {\n-  EXPECT_DEATH(CFAllocatorMallocDoubleFree(), \"attempting double-free\");\n-}\n-\n-TEST(AddressSanitizerMac, DISABLED_CFAllocatorMallocZoneDoubleFree) {\n-  EXPECT_DEATH(CFAllocatorMallocZoneDoubleFree(), \"attempting double-free\");\n-}\n-\n-// For libdispatch tests below we check that ASan got to the shadow byte\n-// legend, i.e. managed to print the thread stacks (this almost certainly\n-// means that the libdispatch task creation has been intercepted correctly).\n-TEST(AddressSanitizerMac, GCDDispatchAsync) {\n-  // Make sure the whole ASan report is printed, i.e. that we don't die\n-  // on a CHECK.\n-  EXPECT_DEATH(TestGCDDispatchAsync(), \"Shadow byte legend\");\n-}\n-\n-TEST(AddressSanitizerMac, GCDDispatchSync) {\n-  // Make sure the whole ASan report is printed, i.e. that we don't die\n-  // on a CHECK.\n-  EXPECT_DEATH(TestGCDDispatchSync(), \"Shadow byte legend\");\n-}\n-\n-\n-TEST(AddressSanitizerMac, GCDReuseWqthreadsAsync) {\n-  // Make sure the whole ASan report is printed, i.e. that we don't die\n-  // on a CHECK.\n-  EXPECT_DEATH(TestGCDReuseWqthreadsAsync(), \"Shadow byte legend\");\n-}\n-\n-TEST(AddressSanitizerMac, GCDReuseWqthreadsSync) {\n-  // Make sure the whole ASan report is printed, i.e. that we don't die\n-  // on a CHECK.\n-  EXPECT_DEATH(TestGCDReuseWqthreadsSync(), \"Shadow byte legend\");\n-}\n-\n-TEST(AddressSanitizerMac, GCDDispatchAfter) {\n-  // Make sure the whole ASan report is printed, i.e. that we don't die\n-  // on a CHECK.\n-  EXPECT_DEATH(TestGCDDispatchAfter(), \"Shadow byte legend\");\n-}\n-\n-TEST(AddressSanitizerMac, GCDSourceEvent) {\n-  // Make sure the whole ASan report is printed, i.e. that we don't die\n-  // on a CHECK.\n-  EXPECT_DEATH(TestGCDSourceEvent(), \"Shadow byte legend\");\n-}\n-\n-TEST(AddressSanitizerMac, GCDSourceCancel) {\n-  // Make sure the whole ASan report is printed, i.e. that we don't die\n-  // on a CHECK.\n-  EXPECT_DEATH(TestGCDSourceCancel(), \"Shadow byte legend\");\n-}\n-\n-TEST(AddressSanitizerMac, GCDGroupAsync) {\n-  // Make sure the whole ASan report is printed, i.e. that we don't die\n-  // on a CHECK.\n-  EXPECT_DEATH(TestGCDGroupAsync(), \"Shadow byte legend\");\n-}\n-\n-void *MallocIntrospectionLockWorker(void *_) {\n-  const int kNumPointers = 100;\n-  int i;\n-  void *pointers[kNumPointers];\n-  for (i = 0; i < kNumPointers; i++) {\n-    pointers[i] = malloc(i + 1);\n-  }\n-  for (i = 0; i < kNumPointers; i++) {\n-    free(pointers[i]);\n-  }\n-\n-  return NULL;\n-}\n-\n-void *MallocIntrospectionLockForker(void *_) {\n-  pid_t result = fork();\n-  if (result == -1) {\n-    perror(\"fork\");\n-  }\n-  assert(result != -1);\n-  if (result == 0) {\n-    // Call malloc in the child process to make sure we won't deadlock.\n-    void *ptr = malloc(42);\n-    free(ptr);\n-    exit(0);\n-  } else {\n-    // Return in the parent process.\n-    return NULL;\n-  }\n-}\n-\n-TEST(AddressSanitizerMac, MallocIntrospectionLock) {\n-  // Incorrect implementation of force_lock and force_unlock in our malloc zone\n-  // will cause forked processes to deadlock.\n-  // TODO(glider): need to detect that none of the child processes deadlocked.\n-  const int kNumWorkers = 5, kNumIterations = 100;\n-  int i, iter;\n-  for (iter = 0; iter < kNumIterations; iter++) {\n-    pthread_t workers[kNumWorkers], forker;\n-    for (i = 0; i < kNumWorkers; i++) {\n-      PTHREAD_CREATE(&workers[i], 0, MallocIntrospectionLockWorker, 0);\n-    }\n-    PTHREAD_CREATE(&forker, 0, MallocIntrospectionLockForker, 0);\n-    for (i = 0; i < kNumWorkers; i++) {\n-      PTHREAD_JOIN(workers[i], 0);\n-    }\n-    PTHREAD_JOIN(forker, 0);\n-  }\n-}\n-\n-void *TSDAllocWorker(void *test_key) {\n-  if (test_key) {\n-    void *mem = malloc(10);\n-    pthread_setspecific(*(pthread_key_t*)test_key, mem);\n-  }\n-  return NULL;\n-}\n-\n-TEST(AddressSanitizerMac, DISABLED_TSDWorkqueueTest) {\n-  pthread_t th;\n-  pthread_key_t test_key;\n-  pthread_key_create(&test_key, CallFreeOnWorkqueue);\n-  PTHREAD_CREATE(&th, NULL, TSDAllocWorker, &test_key);\n-  PTHREAD_JOIN(th, NULL);\n-  pthread_key_delete(test_key);\n-}\n-\n-// Test that CFStringCreateCopy does not copy constant strings.\n-TEST(AddressSanitizerMac, CFStringCreateCopy) {\n-  CFStringRef str = CFSTR(\"Hello world!\\n\");\n-  CFStringRef str2 = CFStringCreateCopy(0, str);\n-  EXPECT_EQ(str, str2);\n-}\n-\n-TEST(AddressSanitizerMac, NSObjectOOB) {\n-  // Make sure that our allocators are used for NSObjects.\n-  EXPECT_DEATH(TestOOBNSObjects(), \"heap-buffer-overflow\");\n-}\n-\n-// Make sure that correct pointer is passed to free() when deallocating a\n-// NSURL object.\n-// See http://code.google.com/p/address-sanitizer/issues/detail?id=70.\n-TEST(AddressSanitizerMac, NSURLDeallocation) {\n-  TestNSURLDeallocation();\n-}\n-\n-// See http://code.google.com/p/address-sanitizer/issues/detail?id=109.\n-TEST(AddressSanitizerMac, Mstats) {\n-  malloc_statistics_t stats1, stats2;\n-  malloc_zone_statistics(/*all zones*/NULL, &stats1);\n-  const size_t kMallocSize = 100000;\n-  void *alloc = Ident(malloc(kMallocSize));\n-  malloc_zone_statistics(/*all zones*/NULL, &stats2);\n-  EXPECT_GT(stats2.blocks_in_use, stats1.blocks_in_use);\n-  EXPECT_GE(stats2.size_in_use - stats1.size_in_use, kMallocSize);\n-  free(alloc);\n-  // Even the default OSX allocator may not change the stats after free().\n-}\n-#endif  // __APPLE__\n \n // Test that instrumentation of stack allocations takes into account\n // AllocSize of a type, and not its StoreSize (16 vs 10 bytes for long double)."}, {"sha": "5ea7d4449f45653e95b182ed3c35f3c30e5db711", "filename": "gcc/testsuite/g++.dg/asan/asan_test_utils.h", "status": "modified", "additions": 77, "deletions": 41, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b0c7324054b014b73bd7e1c82ed95ae306ef794/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_test_utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b0c7324054b014b73bd7e1c82ed95ae306ef794/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_test_utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_test_utils.h?ref=3b0c7324054b014b73bd7e1c82ed95ae306ef794", "patch": "@@ -18,56 +18,92 @@\n # undef INCLUDED_FROM_ASAN_TEST_UTILS_H\n #endif\n \n-#if defined(_WIN32)\n-typedef unsigned __int8  uint8_t;\n-typedef unsigned __int16 uint16_t;\n-typedef unsigned __int32 uint32_t;\n-typedef unsigned __int64 uint64_t;\n-typedef __int8           int8_t;\n-typedef __int16          int16_t;\n-typedef __int32          int32_t;\n-typedef __int64          int64_t;\n-# define NOINLINE __declspec(noinline)\n-# define USED\n-#else  // defined(_WIN32)\n-# define NOINLINE __attribute__((noinline))\n-# define USED __attribute__((used))\n-#endif  // defined(_WIN32)\n-\n-#if !defined(__has_feature)\n-#define __has_feature(x) 0\n+#include \"sanitizer_test_utils.h\"\n+#include <stdio.h>\n+#include <signal.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <strings.h>\n+#include <pthread.h>\n+#include <stdint.h>\n+#include <setjmp.h>\n+#include <assert.h>\n+#include <algorithm>\n+#include <sys/mman.h>\n+\n+#ifdef __linux__\n+# include <sys/prctl.h>\n+# include <sys/types.h>\n+# include <sys/stat.h>\n+# include <fcntl.h>\n+#include <unistd.h>\n #endif\n \n-#if __has_feature(address_sanitizer) || defined(__SANITIZE_ADDRESS__)\n-# define ATTRIBUTE_NO_ADDRESS_SAFETY_ANALYSIS \\\n-    __attribute__((no_address_safety_analysis))\n-#else\n-# define ATTRIBUTE_NO_ADDRESS_SAFETY_ANALYSIS\n+#if defined(__i386__) || defined(__x86_64__)\n+#include <emmintrin.h>\n+#endif\n+\n+#ifndef __APPLE__\n+#include <malloc.h>\n #endif\n \n-#if __LP64__ || defined(_WIN64)\n-#  define SANITIZER_WORDSIZE 64\n+// Check that pthread_create/pthread_join return success.\n+#define PTHREAD_CREATE(a, b, c, d) ASSERT_EQ(0, pthread_create(a, b, c, d))\n+#define PTHREAD_JOIN(a, b) ASSERT_EQ(0, pthread_join(a, b))\n+\n+#if ASAN_HAS_EXCEPTIONS\n+# define ASAN_THROW(x) throw (x)\n #else\n-#  define SANITIZER_WORDSIZE 32\n+# define ASAN_THROW(x)\n #endif\n \n-// Make the compiler thinks that something is going on there.\n-inline void break_optimization(void *arg) {\n-  __asm__ __volatile__(\"\" : : \"r\" (arg) : \"memory\");\n-}\n+typedef uint8_t   U1;\n+typedef uint16_t  U2;\n+typedef uint32_t  U4;\n+typedef uint64_t  U8;\n+\n+static const int kPageSize = 4096;\n+\n+const size_t kLargeMalloc = 1 << 24;\n+\n+extern void free_aaa(void *p);\n+extern void *malloc_aaa(size_t size);\n \n-// This function returns its parameter but in such a way that compiler\n-// can not prove it.\n-template<class T>\n-NOINLINE\n-static T Ident(T t) {\n-  T ret = t;\n-  break_optimization(&ret);\n-  return ret;\n+template<typename T>\n+NOINLINE void asan_write(T *a) {\n+  *a = 0;\n }\n \n-// Check that pthread_create/pthread_join return success.\n-#define PTHREAD_CREATE(a, b, c, d) ASSERT_EQ(0, pthread_create(a, b, c, d))\n-#define PTHREAD_JOIN(a, b) ASSERT_EQ(0, pthread_join(a, b))\n+string RightOOBErrorMessage(int oob_distance, bool is_write);\n+string RightOOBWriteMessage(int oob_distance);\n+string RightOOBReadMessage(int oob_distance);\n+string LeftOOBErrorMessage(int oob_distance, bool is_write);\n+string LeftOOBWriteMessage(int oob_distance);\n+string LeftOOBReadMessage(int oob_distance);\n+string LeftOOBAccessMessage(int oob_distance);\n+char* MallocAndMemsetString(size_t size, char ch);\n+char* MallocAndMemsetString(size_t size);\n+\n+extern char glob1[1];\n+extern char glob2[2];\n+extern char glob3[3];\n+extern char glob4[4];\n+extern char glob5[5];\n+extern char glob6[6];\n+extern char glob7[7];\n+extern char glob8[8];\n+extern char glob9[9];\n+extern char glob10[10];\n+extern char glob11[11];\n+extern char glob12[12];\n+extern char glob13[13];\n+extern char glob14[14];\n+extern char glob15[15];\n+extern char glob16[16];\n+extern char glob17[17];\n+extern char glob1000[1000];\n+extern char glob10000[10000];\n+extern char glob100000[100000];\n+extern int GlobalsTest(int x);\n \n #endif  // ASAN_TEST_UTILS_H"}, {"sha": "2b4057c8503ea8011690f2e908ec49d79178051e", "filename": "gcc/testsuite/g++.dg/asan/dejagnu-gtest.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b0c7324054b014b73bd7e1c82ed95ae306ef794/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fdejagnu-gtest.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b0c7324054b014b73bd7e1c82ed95ae306ef794/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fdejagnu-gtest.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fdejagnu-gtest.h?ref=3b0c7324054b014b73bd7e1c82ed95ae306ef794", "patch": "@@ -1,3 +1,6 @@\n+#ifndef DEJAGNU_GTEST_H\n+#define DEJAGNU_GTEST_H 1\n+\n #include <stdio.h>\n #include <stdlib.h>\n #include <string.h>\n@@ -113,3 +116,5 @@ main (int argc, const char **argv)\n     }\n   return 0;\n }\n+\n+#endif"}, {"sha": "2184cc76788b674f308c9e4b8e32c08679d8fd79", "filename": "gcc/testsuite/g++.dg/asan/sanitizer_test_utils.h", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b0c7324054b014b73bd7e1c82ed95ae306ef794/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fsanitizer_test_utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b0c7324054b014b73bd7e1c82ed95ae306ef794/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fsanitizer_test_utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fsanitizer_test_utils.h?ref=3b0c7324054b014b73bd7e1c82ed95ae306ef794", "patch": "@@ -0,0 +1,78 @@\n+//===-- sanitizer_test_utils.h ----------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of *Sanitizer runtime.\n+// Common unit tests utilities.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef SANITIZER_TEST_UTILS_H\n+#define SANITIZER_TEST_UTILS_H\n+\n+#if defined(_WIN32)\n+typedef unsigned __int8  uint8_t;\n+typedef unsigned __int16 uint16_t;\n+typedef unsigned __int32 uint32_t;\n+typedef unsigned __int64 uint64_t;\n+typedef __int8           int8_t;\n+typedef __int16          int16_t;\n+typedef __int32          int32_t;\n+typedef __int64          int64_t;\n+# define NOINLINE __declspec(noinline)\n+# define USED\n+#else  // defined(_WIN32)\n+# define NOINLINE __attribute__((noinline))\n+# define USED __attribute__((used))\n+#include <stdint.h>\n+#endif  // defined(_WIN32)\n+\n+#if !defined(__has_feature)\n+#define __has_feature(x) 0\n+#endif\n+\n+#if __has_feature(address_sanitizer) || defined(__SANITIZE_ADDRESS__)\n+# define ATTRIBUTE_NO_ADDRESS_SAFETY_ANALYSIS \\\n+    __attribute__((no_address_safety_analysis))\n+#else\n+# define ATTRIBUTE_NO_ADDRESS_SAFETY_ANALYSIS\n+#endif\n+\n+#if __LP64__ || defined(_WIN64)\n+#  define SANITIZER_WORDSIZE 64\n+#else\n+#  define SANITIZER_WORDSIZE 32\n+#endif\n+\n+// Make the compiler thinks that something is going on there.\n+inline void break_optimization(void *arg) {\n+  __asm__ __volatile__(\"\" : : \"r\" (arg) : \"memory\");\n+}\n+\n+// This function returns its parameter but in such a way that compiler\n+// can not prove it.\n+template<class T>\n+NOINLINE\n+static T Ident(T t) {\n+  T ret = t;\n+  break_optimization(&ret);\n+  return ret;\n+}\n+\n+// Simple stand-alone pseudorandom number generator.\n+// Current algorithm is ANSI C linear congruential PRNG.\n+static inline uint32_t my_rand_r(uint32_t* state) {\n+  return (*state = *state * 1103515245 + 12345) >> 16;\n+}\n+\n+static uint32_t global_seed = 0;\n+\n+static inline uint32_t my_rand() {\n+  return my_rand_r(&global_seed);\n+}\n+\n+\n+#endif  // SANITIZER_TEST_UTILS_H"}]}