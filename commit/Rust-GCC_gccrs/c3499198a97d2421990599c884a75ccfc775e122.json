{"sha": "c3499198a97d2421990599c884a75ccfc775e122", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzM0OTkxOThhOTdkMjQyMTk5MDU5OWM4ODRhNzVjY2ZjNzc1ZTEyMg==", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-04-10T13:46:37Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-04-12T21:39:45Z"}, "message": "Seperate look for undetermined types post type resolution\n\nWhen we do full PathInExpression resolution we can end up with orphaned\nInference Variables which never get unified with real concrete types. This\nis to be expected. What we really care about are that all name declarations\nare fully typed before we move into the next pass.", "tree": {"sha": "a72c2bb9693ea8158f10800d9fb8b4dd83f42ece", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a72c2bb9693ea8158f10800d9fb8b4dd83f42ece"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c3499198a97d2421990599c884a75ccfc775e122", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3499198a97d2421990599c884a75ccfc775e122", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3499198a97d2421990599c884a75ccfc775e122", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3499198a97d2421990599c884a75ccfc775e122/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca8744db3e56bfcf0cf3f0e2a0bf76450aef9438", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca8744db3e56bfcf0cf3f0e2a0bf76450aef9438", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca8744db3e56bfcf0cf3f0e2a0bf76450aef9438"}], "stats": {"total": 73, "additions": 63, "deletions": 10}, "files": [{"sha": "681fb24d756ccfea4362fce206c89fb1780785c1", "filename": "gcc/rust/typecheck/rust-hir-type-check.cc", "status": "modified", "additions": 44, "deletions": 10, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3499198a97d2421990599c884a75ccfc775e122/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3499198a97d2421990599c884a75ccfc775e122/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc?ref=c3499198a97d2421990599c884a75ccfc775e122", "patch": "@@ -44,9 +44,11 @@ TypeResolution::Resolve (HIR::Crate &crate)\n   if (saw_errors ())\n     return;\n \n+  auto resolver = Resolver::Resolver::get ();\n   auto mappings = Analysis::Mappings::get ();\n   auto context = TypeCheckContext::get ();\n \n+  // default inference variables if possible\n   context->iterate ([&] (HirId id, TyTy::BaseType *ty) mutable -> bool {\n     if (ty->get_kind () == TyTy::TypeKind::ERROR)\n       {\n@@ -61,19 +63,51 @@ TypeResolution::Resolve (HIR::Crate &crate)\n     TyTy::InferType *infer_var = (TyTy::InferType *) ty;\n     TyTy::BaseType *default_type;\n     bool ok = infer_var->default_type (&default_type);\n-    if (!ok)\n+    if (ok)\n       {\n-\trust_error_at (mappings->lookup_location (id),\n-\t\t       \"unable to determine type: please give this a type: %u\",\n-\t\t       id);\n-\treturn true;\n+\tauto result = ty->unify (default_type);\n+\tresult->set_ref (id);\n+\tcontext->insert_type (\n+\t  Analysis::NodeMapping (mappings->get_current_crate (), 0, id,\n+\t\t\t\t UNKNOWN_LOCAL_DEFID),\n+\t  result);\n       }\n-    auto result = ty->unify (default_type);\n-    result->set_ref (id);\n-    context->insert_type (Analysis::NodeMapping (mappings->get_current_crate (),\n-\t\t\t\t\t\t 0, id, UNKNOWN_LOCAL_DEFID),\n-\t\t\t  result);\n+    return true;\n+  });\n+\n+  // scan the ribs to ensure the decls are all setup correctly\n+  resolver->iterate_name_ribs ([&] (Rib *r) -> bool {\n+    r->iterate_decls ([&] (NodeId decl_node_id, Location locus) -> bool {\n+      Definition def;\n+      if (!resolver->lookup_definition (decl_node_id, &def))\n+\t{\n+\t  rust_error_at (locus, \"failed to lookup decl def\");\n+\t  return true;\n+\t}\n+\n+      HirId hir_node = UNKNOWN_HIRID;\n+      if (!mappings->lookup_node_to_hir (mappings->get_current_crate (),\n+\t\t\t\t\t def.parent, &hir_node))\n+\t{\n+\t  rust_error_at (locus, \"failed to lookup type hir node id\");\n+\t  return true;\n+\t}\n \n+      // lookup the ty\n+      TyTy::BaseType *ty = nullptr;\n+      bool ok = context->lookup_type (hir_node, &ty);\n+      if (!ok)\n+\t{\n+\t  rust_error_at (locus, \"failed to lookup type for decl node_id: %u\",\n+\t\t\t decl_node_id);\n+\t  return true;\n+\t}\n+\n+      if (!ty->is_concrete ())\n+\trust_error_at (locus, \"unable to determine type\");\n+\n+      return true;\n+    });\n     return true;\n   });\n }"}, {"sha": "9cf75fafb83ee637c89ece7ce91517e3b537b60d", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3499198a97d2421990599c884a75ccfc775e122/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3499198a97d2421990599c884a75ccfc775e122/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=c3499198a97d2421990599c884a75ccfc775e122", "patch": "@@ -91,6 +91,8 @@ class BaseType\n \n   virtual bool is_unit () const { return false; }\n \n+  virtual bool is_concrete () const { return true; }\n+\n   TypeKind get_kind () const { return kind; }\n \n   /* Returns a pointer to a clone of this. The caller is responsible for\n@@ -194,6 +196,8 @@ class InferType : public BaseType\n \n   bool default_type (BaseType **type) const;\n \n+  bool is_concrete () const final override { return false; }\n+\n private:\n   InferTypeKind infer_kind;\n };\n@@ -321,6 +325,16 @@ class TupleType : public BaseType\n \n   BaseType *clone () final override;\n \n+  bool is_concrete () const override final\n+  {\n+    for (size_t i = 0; i < num_fields (); i++)\n+      {\n+\tif (!get_field (i)->is_concrete ())\n+\t  return false;\n+      }\n+    return true;\n+  }\n+\n   void iterate_fields (std::function<bool (BaseType *)> cb) const\n   {\n     for (size_t i = 0; i < num_fields (); i++)\n@@ -824,6 +838,11 @@ class ArrayType : public BaseType\n \n   BaseType *clone () final override;\n \n+  bool is_concrete () const final override\n+  {\n+    return get_element_type ()->is_concrete ();\n+  }\n+\n private:\n   size_t capacity;\n   TyVar element_type;"}]}