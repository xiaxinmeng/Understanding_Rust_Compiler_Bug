{"sha": "c876997fea9c48f53d567cc40f1b9a5fb2bdb97e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzg3Njk5N2ZlYTljNDhmNTNkNTY3Y2M0MGYxYjlhNWZiMmJkYjk3ZQ==", "commit": {"author": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2003-03-20T17:48:26Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2003-03-20T17:48:26Z"}, "message": "fold-const.c (fold_mathfn_compare): New function to simplify comparisons against built-in math functions.\n\n\n\t* fold-const.c (fold_mathfn_compare): New function to simplify\n\tcomparisons against built-in math functions.  Fold comparisons\n\tof sqrt against constants.\n\t(fold): Call fold_mathfn_compare when appropriate.\n\n\t* gcc.dg/builtins-6.c: New test case.\n\nFrom-SVN: r64619", "tree": {"sha": "f45adeca1c6fb404992477d56ce43566af94d381", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f45adeca1c6fb404992477d56ce43566af94d381"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c876997fea9c48f53d567cc40f1b9a5fb2bdb97e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c876997fea9c48f53d567cc40f1b9a5fb2bdb97e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c876997fea9c48f53d567cc40f1b9a5fb2bdb97e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c876997fea9c48f53d567cc40f1b9a5fb2bdb97e/comments", "author": null, "committer": null, "parents": [{"sha": "952a6df761f3faa54e0d35bc893f2f8a209049e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/952a6df761f3faa54e0d35bc893f2f8a209049e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/952a6df761f3faa54e0d35bc893f2f8a209049e5"}], "stats": {"total": 274, "additions": 260, "deletions": 14}, "files": [{"sha": "2b16b1b95f94f2e7cd79b12d0d014df1aac49585", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c876997fea9c48f53d567cc40f1b9a5fb2bdb97e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c876997fea9c48f53d567cc40f1b9a5fb2bdb97e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c876997fea9c48f53d567cc40f1b9a5fb2bdb97e", "patch": "@@ -1,3 +1,10 @@\n+2003-03-20  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* fold-const.c (fold_mathfn_compare): New function to simplify\n+\tcomparisons against built-in math functions.  Fold comparisons\n+\tof sqrt against constants.\n+\t(fold): Call fold_mathfn_compare when appropriate.\n+\n 2003-03-20 Richard Earnshaw  <rearnsha@arm.com>\n \n \t* ifcvt.c (find_if_case_1): If we add a new bb, update the dominance\n@@ -1542,24 +1549,24 @@ Sat Mar  8 14:13:35 CET 2003  Jan Hubicka  <jh@suse.cz>\n \tMEM, try loading the MEM into a register and taking the low-part\n \tof that, to help CSE see the use of the MEM in its true mode.\n \n-2002-03-05  Tom Tromey  <tromey@redhat.com>\n+2003-03-05  Tom Tromey  <tromey@redhat.com>\n \n \t* config/stormy16/stormy16.h (DWARF_LINE_MIN_INSTR_LENGTH):\n \tDefine.\n \n-2002-03-05  Nick Clifton  <nickc@cambridge.redhat.com>\n+2003-03-05  Nick Clifton  <nickc@cambridge.redhat.com>\n \n \t* config/stormy16/stormy16.md (\"*eqbranchsi\"): Remove '+' on\n \toperand 2.\n \t(\"*ineqbranchsi\"): Likewise.\n \n-2002-03-05  Andrew Haley  <aph@cambridge.redhat.com>\n+2003-03-05  Andrew Haley  <aph@cambridge.redhat.com>\n \n \t* config/stormy16/stormy16.c (xstormy16_expand_prologue): Delete\n \tmem_fake_push_rtx.  Instead construct a SEQUENCE to show the\n \tregister store followed by a stack increment.\n \n-2002-03-05  Chris Moller  <cmoller@redhat.com>\n+2003-03-05  Chris Moller  <cmoller@redhat.com>\n \n \t* config/stormy16/stormy16.c (REG_NEEDS_SAVE): added a term\n \tto inhibit saving CARRY_REGS.\n@@ -2328,7 +2335,7 @@ Mon Mar  3 19:07:21 CET 2003  Jan Hubicka  <jh@suse.cz>\n \t(*tst_extzv_memqi_1_n): Likewise.\n \t(a peephole2): New.\n \n-2002-02-28  Richard Sandiford  <rsandifo@redhat.com>\n+2003-02-28  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* config/mips/mips.h (CRT_CALL_STATIC_FUNCTION): Wrap in\n \t#ifndef __mips16.\n@@ -4123,7 +4130,7 @@ Sun Feb  9 23:54:59 CET 2003  Jan Hubicka  <jh@suse.cz>\n \tsimplify_binary_operation):  Deal with vector modes\n \t(simplify_ternary_operation):  Deal with no-op VEC_MERGE.\n \n-2002-02-09  Richard Sandiford  <rsandifo@redhat.com>\n+2003-02-09  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* toplev.c (rest_of_compilation): Recompute register usage after\n \tsplit_all_insns.\n@@ -4489,7 +4496,7 @@ Wed Feb  5 23:12:57 CET 2003  Jan Hubicka  <jh@suse.cz>\n \t* config/ia64/unwind-ia64.c: include coretypes.h, tm.h to get\n \t  config/ia64/linux.h\n \n-2002-02-05  Roger Sayle  <roger@eyesopen.com>\n+2003-02-05  Roger Sayle  <roger@eyesopen.com>\n \n \t* cfgloop.h (flow_bb_inside_loop_p): Correct prototype again.\n \n@@ -4605,7 +4612,7 @@ Mon Feb  3 21:19:11 CET 2003  Jan Hubicka  <jh@suse.cz>\n \t(movups/movupd/movdqu patterns): Force one of operands to not be\n \tmemory.\n \n-2002-02-03  Roger Sayle  <roger@eyesopen.com>\n+2003-02-03  Roger Sayle  <roger@eyesopen.com>\n \n \t* hooks.c (hook_rtx_rtx_identity): Generic hook function that\n \ttakes a single rtx and returns it unmodified.\n@@ -5624,11 +5631,11 @@ Sat Jan 25 21:04:33 CET 2003  Jan Hubicka  <jh@suse.cz>\n \t* config/h8300/h8300.c (h8300_shift_needs_scratch_p): Update a\n \tcomment.\n \n-2002-01-25  Richard Henderson  <rth@redhat.com>\n+2003-01-25  Richard Henderson  <rth@redhat.com>\n \n \t* config/m68k/m68k-none.h (ASM_SPEC): Adjust inter-option spacing.\n \n-2002-01-25  Kelley Cook <kelleycook@comcast.net>\n+2003-01-25  Kelley Cook <kelleycook@comcast.net>\n \n \t* ggc-simple.c (debug_ggc_tree): Add PTR cast.\n \n@@ -5646,7 +5653,7 @@ Sat Jan 25 21:04:33 CET 2003  Jan Hubicka  <jh@suse.cz>\n \t2002-02-19  Robert Lipe  <robertlipe@usa.net>\n \t* config/i386/t-sco5gas: (CRTSTUFF_T_CFLAGS_S): Delete -mcoff.\n \n-2002-01-25  Roger Sayle  <roger@eyesopen.com>\n+2003-01-25  Roger Sayle  <roger@eyesopen.com>\n \n \t* builtins.c (purge_builtin_constant_p): Scan insn stream\n \tsequentially rather than by basic block.\n@@ -5656,7 +5663,7 @@ Sat Jan 25 21:04:33 CET 2003  Jan Hubicka  <jh@suse.cz>\n \n \t* combine.c (simplify_comparison, case AND): Remove a redundant test.\n \n-2002-01-25  Roger Sayle  <roger@eyesopen.com>\n+2003-01-25  Roger Sayle  <roger@eyesopen.com>\n \n \t* function.h (struct function): New field calls_constant_p.\n \t(current_function_calls_constant_p): New macro for above.\n@@ -5668,7 +5675,7 @@ Sat Jan 25 21:04:33 CET 2003  Jan Hubicka  <jh@suse.cz>\n \t* integrate.c (expand_inline_function): Set calls_constant_p if\n \tthe function being inlined has calls_constant_p set.\n \n-2002-01-25  Roger Sayle  <roger@eyesopen.com>\n+2003-01-25  Roger Sayle  <roger@eyesopen.com>\n \n \t* cse.c (fold_rtx): Instantiate CONSTANT_P_RTX to 0 when not\n \toptimizing, even if flag_gcse is true.\n@@ -5728,7 +5735,7 @@ Sat Jan 25 11:10:03 CET 2003  Jan Hubicka  <jh@suse.cz>\n \n \t* builtins.c (fold_trunc_transparent_mathfn):  Undo accidental commit.\n \n-2002-01-24  Stuart Hastings  <stuart@apple.com>\n+2003-01-24  Stuart Hastings  <stuart@apple.com>\n \n \t* config/i386/i386.c (x86_output_mi_thunk): Add Darwin/x86 support.\n "}, {"sha": "74772690c310edb0dce4e49b6da9ad6468dc8d85", "filename": "gcc/fold-const.c", "status": "modified", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c876997fea9c48f53d567cc40f1b9a5fb2bdb97e/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c876997fea9c48f53d567cc40f1b9a5fb2bdb97e/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=c876997fea9c48f53d567cc40f1b9a5fb2bdb97e", "patch": "@@ -112,6 +112,8 @@ static int count_cond\t\tPARAMS ((tree, int));\n static tree fold_binary_op_with_conditional_arg\n   PARAMS ((enum tree_code, tree, tree, tree, int));\n static bool fold_real_zero_addition_p\tPARAMS ((tree, tree, int));\n+static tree fold_mathfn_compare\tPARAMS ((enum built_in_function,\n+\t\t\t\t\t enum tree_code, tree, tree, tree));\n \n /* The following constants represent a bit based encoding of GCC's\n    comparison operators.  This encoding simplifies transformations\n@@ -4661,6 +4663,144 @@ fold_real_zero_addition_p (type, addend, negate)\n   return negate && !HONOR_SIGN_DEPENDENT_ROUNDING (TYPE_MODE (type));\n }\n \n+/* Subroutine of fold() that checks comparisons of built-in math\n+   functions against real constants.\n+\n+   FCODE is the DECL_FUNCTION_CODE of the built-in, CODE is the comparison\n+   operator: EQ_EXPR, NE_EXPR, GT_EXPR, LT_EXPR, GE_EXPR or LE_EXPR.  TYPE\n+   is the type of the result and ARG0 and ARG1 are the operands of the\n+   comparison.  ARG1 must be a TREE_REAL_CST.\n+\n+   The function returns the constant folded tree if a simplification\n+   can be made, and NULL_TREE otherwise.  */\n+\n+static tree\n+fold_mathfn_compare (fcode, code, type, arg0, arg1)\n+     enum built_in_function fcode;\n+     enum tree_code code;\n+     tree type, arg0, arg1;\n+{\n+  REAL_VALUE_TYPE c;\n+\n+  if (fcode == BUILT_IN_SQRT\n+      || fcode == BUILT_IN_SQRTF\n+      || fcode == BUILT_IN_SQRTL)\n+    {\n+      tree arg = TREE_VALUE (TREE_OPERAND (arg0, 1));\n+      enum machine_mode mode = TYPE_MODE (TREE_TYPE (arg0));\n+\n+      c = TREE_REAL_CST (arg1);\n+      if (REAL_VALUE_NEGATIVE (c))\n+\t{\n+\t  /* sqrt(x) < y is always false, if y is negative.  */\n+\t  if (code == EQ_EXPR || code == LT_EXPR || code == LE_EXPR)\n+\t    return omit_one_operand (type,\n+\t\t\t\t     convert (type, integer_zero_node),\n+\t\t\t\t     arg);\n+\n+\t  /* sqrt(x) > y is always true, if y is negative and we\n+\t     don't care about NaNs, i.e. negative values of x.  */\n+\t  if (code == NE_EXPR || !HONOR_NANS (mode))\n+\t    return omit_one_operand (type,\n+\t\t\t\t     convert (type, integer_one_node),\n+\t\t\t\t     arg);\n+\n+\t  /* sqrt(x) > y is the same as x >= 0, if y is negative.  */\n+\t  return fold (build (GE_EXPR, type, arg,\n+\t\t\t      build_real (TREE_TYPE (arg), dconst0)));\n+\t}\n+      else if (code == GT_EXPR || code == GE_EXPR)\n+\t{\n+\t  REAL_VALUE_TYPE c2;\n+\n+\t  REAL_ARITHMETIC (c2, MULT_EXPR, c, c);\n+\t  real_convert (&c2, mode, &c2);\n+\n+\t  if (REAL_VALUE_ISINF (c2))\n+\t    {\n+\t      /* sqrt(x) > y is x == +Inf, when y is very large.  */\n+\t      if (HONOR_INFINITIES (mode))\n+\t\treturn fold (build (EQ_EXPR, type, arg,\n+\t\t\t\t    build_real (TREE_TYPE (arg), c2)));\n+\n+\t      /* sqrt(x) > y is always false, when y is very large\n+\t\t and we don't care about infinities.  */\n+\t      return omit_one_operand (type,\n+\t\t\t\t       convert (type, integer_zero_node),\n+\t\t\t\t       arg);\n+\t    }\n+\n+\t  /* sqrt(x) > c is the same as x > c*c.  */\n+\t  return fold (build (code, type, arg,\n+\t\t\t      build_real (TREE_TYPE (arg), c2)));\n+\t}\n+      else if (code == LT_EXPR || code == LE_EXPR)\n+\t{\n+\t  REAL_VALUE_TYPE c2;\n+\n+\t  REAL_ARITHMETIC (c2, MULT_EXPR, c, c);\n+\t  real_convert (&c2, mode, &c2);\n+\n+\t  if (REAL_VALUE_ISINF (c2))\n+\t    {\n+\t      /* sqrt(x) < y is always true, when y is a very large\n+\t\t value and we don't care about NaNs or Infinities.  */\n+\t      if (! HONOR_NANS (mode) && ! HONOR_INFINITIES (mode))\n+\t\treturn omit_one_operand (type,\n+\t\t\t\t\t convert (type, integer_one_node),\n+\t\t\t\t\t arg);\n+\n+\t      /* sqrt(x) < y is x != +Inf when y is very large and we\n+\t\t don't care about NaNs.  */\n+\t      if (! HONOR_NANS (mode))\n+\t\treturn fold (build (NE_EXPR, type, arg,\n+\t\t\t\t    build_real (TREE_TYPE (arg), c2)));\n+\n+\t      /* sqrt(x) < y is x >= 0 when y is very large and we\n+\t\t don't care about Infinities.  */\n+\t      if (! HONOR_INFINITIES (mode))\n+\t\treturn fold (build (GE_EXPR, type, arg,\n+\t\t\t\t    build_real (TREE_TYPE (arg), dconst0)));\n+\n+\t      /* sqrt(x) < y is x >= 0 && x != +Inf, when y is large.  */\n+\t      if ((*lang_hooks.decls.global_bindings_p) () != 0\n+\t\t  || contains_placeholder_p (arg))\n+\t\treturn NULL_TREE;\n+\n+\t      arg = save_expr (arg);\n+\t      return fold (build (TRUTH_ANDIF_EXPR, type,\n+\t\t\t\t  fold (build (GE_EXPR, type, arg,\n+\t\t\t\t\t       build_real (TREE_TYPE (arg),\n+\t\t\t\t\t\t\t   dconst0))),\n+\t\t\t\t  fold (build (NE_EXPR, type, arg,\n+\t\t\t\t\t       build_real (TREE_TYPE (arg),\n+\t\t\t\t\t\t\t   c2)))));\n+\t    }\n+\n+\t  /* sqrt(x) < c is the same as x < c*c, if we ignore NaNs.  */\n+\t  if (! HONOR_NANS (mode))\n+\t    return fold (build (code, type, arg,\n+\t\t\t\tbuild_real (TREE_TYPE (arg), c2)));\n+\n+\t  /* sqrt(x) < c is the same as x >= 0 && x < c*c.  */\n+\t  if ((*lang_hooks.decls.global_bindings_p) () == 0\n+\t      && ! contains_placeholder_p (arg))\n+\t    {\n+\t      arg = save_expr (arg);\n+\t      return fold (build (TRUTH_ANDIF_EXPR, type,\n+\t\t\t\t  fold (build (GE_EXPR, type, arg,\n+\t\t\t\t\t       build_real (TREE_TYPE (arg),\n+\t\t\t\t\t\t\t   dconst0))),\n+\t\t\t\t  fold (build (code, type, arg,\n+\t\t\t\t\t       build_real (TREE_TYPE (arg),\n+\t\t\t\t\t\t\t   c2)))));\n+\t    }\n+\t}\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n \n /* Perform constant folding and related simplification of EXPR.\n    The related simplifications include x*1 => x, x*0 => 0, etc.,\n@@ -6209,6 +6349,21 @@ fold (expr)\n \t\t\t\t\t  arg1, TREE_OPERAND (arg0, 1), 0))\n \t      && ! TREE_CONSTANT_OVERFLOW (tem))\n \t    return fold (build (code, type, TREE_OPERAND (arg0, 0), tem));\n+\n+\t  /* Fold comparisons against built-in math functions.  */\n+\t  if (TREE_CODE (arg1) == REAL_CST\n+\t      && flag_unsafe_math_optimizations\n+\t      && ! flag_errno_math)\n+\t    {\n+\t      enum built_in_function fcode = builtin_mathfn_code (arg0);\n+\n+\t      if (fcode != END_BUILTINS)\n+\t\t{\n+\t\t  tem = fold_mathfn_compare (fcode, code, type, arg0, arg1);\n+\t\t  if (tem != NULL_TREE)\n+\t\t    return tem;\n+\t\t}\n+\t    }\n \t}\n \n       /* Convert foo++ == CONST into ++foo == CONST + INCR."}, {"sha": "170886f1b5ea1e05c1d4b78659b9102215f341d0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c876997fea9c48f53d567cc40f1b9a5fb2bdb97e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c876997fea9c48f53d567cc40f1b9a5fb2bdb97e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c876997fea9c48f53d567cc40f1b9a5fb2bdb97e", "patch": "@@ -1,3 +1,7 @@\n+2003-03-20  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* gcc.dg/builtins-6.c: New test case.\n+\n 2003-03-19  Alan Modra  <amodra@bigpond.net.au>\n \n \tPR target/10073"}, {"sha": "2ebb0b2d86d8049451e06e7aa776d106ea181293", "filename": "gcc/testsuite/gcc.dg/builtins-6.c", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c876997fea9c48f53d567cc40f1b9a5fb2bdb97e/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c876997fea9c48f53d567cc40f1b9a5fb2bdb97e/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-6.c?ref=c876997fea9c48f53d567cc40f1b9a5fb2bdb97e", "patch": "@@ -0,0 +1,80 @@\n+/* Copyright (C) 2003  Free Software Foundation.\n+\n+   Verify that constant folding comparisons against built-in math functions\n+   don't cause any problems for the compiler, and produce expected results.\n+\n+   Written by Roger Sayle, 15th March 2003.  */\n+\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -ffast-math\" } */\n+\n+#include <float.h>\n+\n+extern void abort (void);\n+extern double sqrt (double);\n+\n+int test1(double x)\n+{\n+  return sqrt(x) < -9.0;\n+}\n+\n+int test2(double x)\n+{\n+  return sqrt(x) > -9.0;\n+}\n+\n+int test3(double x)\n+{\n+  return sqrt(x) < 9.0;\n+}\n+\n+int test4(double x)\n+{\n+  return sqrt(x) > 9.0;\n+}\n+\n+int test5(double x)\n+{\n+  return sqrt(x) < DBL_MAX;\n+}\n+\n+int test6(double x)\n+{\n+  return sqrt(x) > DBL_MAX;\n+}\n+\n+int main()\n+{\n+  double x;\n+\n+  x = 80.0;\n+  if (test1 (x))\n+    abort ();\n+  if (! test2 (x))\n+    abort ();\n+  if (! test3 (x))\n+    abort ();\n+  if (test4 (x))\n+    abort ();\n+  if (! test5 (x))\n+    abort ();\n+  if (test6 (x))\n+    abort ();\n+\n+  x = 100.0;\n+  if (test1 (x))\n+    abort ();\n+  if (! test2 (x))\n+    abort ();\n+  if (test3 (x))\n+    abort ();\n+  if (! test4 (x))\n+    abort ();\n+  if (! test5 (x))\n+    abort ();\n+  if (test6 (x))\n+    abort ();\n+\n+  return 0;\n+}\n+"}]}