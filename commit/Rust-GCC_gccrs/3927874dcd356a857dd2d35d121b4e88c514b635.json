{"sha": "3927874dcd356a857dd2d35d121b4e88c514b635", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzkyNzg3NGRjZDM1NmE4NTdkZDJkMzVkMTIxYjRlODhjNTE0YjYzNQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1999-07-28T00:45:12Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1999-07-28T00:45:12Z"}, "message": "cp-tree.h (DECL_VIRTUAL_CONTEXT): New macro.\n\n\t* cp-tree.h (DECL_VIRTUAL_CONTEXT): New macro.\n\t* typeck.c (expand_ptrmemfunc_cst): Calculate delta correctly for\n\tvirtual functions and MI.  Simplify.\n\nFrom-SVN: r28304", "tree": {"sha": "291d70577686f8a58a94575fb7ef5a4be75971b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/291d70577686f8a58a94575fb7ef5a4be75971b6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3927874dcd356a857dd2d35d121b4e88c514b635", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3927874dcd356a857dd2d35d121b4e88c514b635", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3927874dcd356a857dd2d35d121b4e88c514b635", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3927874dcd356a857dd2d35d121b4e88c514b635/comments", "author": null, "committer": null, "parents": [{"sha": "2401a452d83b88b0d2f441740ad159645ec131d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2401a452d83b88b0d2f441740ad159645ec131d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2401a452d83b88b0d2f441740ad159645ec131d6"}], "stats": {"total": 71, "additions": 44, "deletions": 27}, "files": [{"sha": "63adc40f37c8df855329b6e72cd3165245c71d8f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3927874dcd356a857dd2d35d121b4e88c514b635/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3927874dcd356a857dd2d35d121b4e88c514b635/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=3927874dcd356a857dd2d35d121b4e88c514b635", "patch": "@@ -1,5 +1,9 @@\n 1999-07-27  Jason Merrill  <jason@yorick.cygnus.com>\n \n+\t* cp-tree.h (DECL_VIRTUAL_CONTEXT): New macro.\n+\t* typeck.c (expand_ptrmemfunc_cst): Calculate delta correctly for\n+\tvirtual functions and MI.  Simplify.\n+\n \t* method.c: Remove prototype for largest_union_member.\n \t* pt.c (determine_specialization): Fix uninitialized warning.\n \t* lex.c (real_yylex): Likewise."}, {"sha": "55d94bb36a3aaf5b46d0ab0444d0edf90d387f37", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3927874dcd356a857dd2d35d121b4e88c514b635/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3927874dcd356a857dd2d35d121b4e88c514b635/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=3927874dcd356a857dd2d35d121b4e88c514b635", "patch": "@@ -212,12 +212,12 @@ struct tree_overload\n    indicating a particular base class, and whose TREE_VALUE is a\n    (possibly overloaded) function from that base class.  */\n #define BASELINK_P(NODE) \\\n-  (TREE_CODE ((NODE)) == TREE_LIST && TREE_LANG_FLAG_1 ((NODE)))\n+  (TREE_CODE (NODE) == TREE_LIST && TREE_LANG_FLAG_1 (NODE))\n #define SET_BASELINK_P(NODE) \\\n-  (TREE_LANG_FLAG_1 ((NODE)) = 1)\n+  (TREE_LANG_FLAG_1 (NODE) = 1)\n \n-#define WRAPPER_PTR(NODE) (((struct tree_wrapper*)NODE)->u.ptr)\n-#define WRAPPER_INT(NODE) (((struct tree_wrapper*)NODE)->u.i)\n+#define WRAPPER_PTR(NODE) (((struct tree_wrapper*)(NODE))->u.ptr)\n+#define WRAPPER_INT(NODE) (((struct tree_wrapper*)(NODE))->u.i)\n \n struct tree_wrapper\n {\n@@ -1404,6 +1404,10 @@ struct lang_decl\n   (DECL_CONTEXT (NODE) ? DECL_CONTEXT (NODE) : global_namespace)\n #define FROB_CONTEXT(NODE)   ((NODE) == global_namespace ? NULL_TREE : (NODE))\n \n+/* For a virtual function, the base where we find its vtable entry.\n+   For a non-virtual function, the base where it is defined.  */\n+#define DECL_VIRTUAL_CONTEXT(NODE) DECL_CONTEXT (NODE)\n+\n /* 1 iff NODE has namespace scope, including the global namespace.  */\n #define DECL_NAMESPACE_SCOPE_P(NODE) \\\n   (DECL_CONTEXT (NODE) == NULL_TREE \\"}, {"sha": "e62f7e34e3f67c7cd9cde09ae26f3fc1dd44dd89", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 32, "deletions": 23, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3927874dcd356a857dd2d35d121b4e88c514b635/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3927874dcd356a857dd2d35d121b4e88c514b635/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=3927874dcd356a857dd2d35d121b4e88c514b635", "patch": "@@ -6078,7 +6078,12 @@ build_x_modify_expr (lhs, modifycode, rhs)\n \f\n /* Get difference in deltas for different pointer to member function\n    types.  Return integer_zero_node, if FROM cannot be converted to a\n-   TO type.  If FORCE is true, then allow reverse conversions as well.  */\n+   TO type.  If FORCE is true, then allow reverse conversions as well.\n+\n+   Note that the naming of FROM and TO is kind of backwards; the return\n+   value is what we add to a TO in order to get a FROM.  They are named\n+   this way because we call this function to find out how to convert from\n+   a pointer to member of FROM to a pointer to member of TO.  */\n \n static tree\n get_delta_difference (from, to, force)\n@@ -6338,37 +6343,41 @@ expand_ptrmemfunc_cst (cst, delta, idx, pfn, delta2)\n {\n   tree type = TREE_TYPE (cst);\n   tree fn = PTRMEM_CST_MEMBER (cst);\n+  tree ptr_class, fn_class;\n \n   my_friendly_assert (TREE_CODE (fn) == FUNCTION_DECL, 0);\n-  \n-  *delta \n-    = get_delta_difference (TYPE_METHOD_BASETYPE (TREE_TYPE (fn)),\n-\t\t\t    TYPE_PTRMEMFUNC_OBJECT_TYPE (type),\n-\t\t\t    /*force=*/0);\n+\n+  /* The class that the function belongs to.  */\n+  fn_class = DECL_CLASS_CONTEXT (fn);\n+\n+  /* The class that we're creating a pointer to member of.  */\n+  ptr_class = TYPE_PTRMEMFUNC_OBJECT_TYPE (type);\n+\n+  /* First, calculate the adjustment to the function's class.  */\n+  *delta = get_delta_difference (fn_class, ptr_class, /*force=*/0);\n+\n   if (!DECL_VIRTUAL_P (fn))\n     {\n-      *idx = size_binop (MINUS_EXPR, integer_zero_node,\n-\t\t\t integer_one_node);\n-      *pfn = build_addr_func (fn);\n-      if (!same_type_p (TYPE_METHOD_BASETYPE (TREE_TYPE (fn)),\n-\t\t\tTYPE_PTRMEMFUNC_OBJECT_TYPE (type)))\n-\t*pfn = build1 (NOP_EXPR, TYPE_PTRMEMFUNC_FN_TYPE (type), \n-\t\t       *pfn);\n+      *idx = size_binop (MINUS_EXPR, integer_zero_node, integer_one_node);\n+      *pfn = convert (TYPE_PTRMEMFUNC_FN_TYPE (type), build_addr_func (fn));\n       *delta2 = NULL_TREE;\n     }\n   else\n     {\n-      *idx = size_binop (PLUS_EXPR, DECL_VINDEX (fn), \n-\t\t\t integer_one_node);\n+      /* If we're dealing with a virtual function, we have to adjust 'this'\n+         again, to point to the base which provides the vtable entry for\n+         fn; the call will do the opposite adjustment.  */\n+      tree orig_class = DECL_VIRTUAL_CONTEXT (fn);\n+      tree binfo = binfo_or_else (orig_class, fn_class);\n+      *delta = size_binop (PLUS_EXPR, *delta, BINFO_OFFSET (binfo));\n+\n+      /* Map everything down one to make room for the null PMF.  */\n+      *idx = size_binop (PLUS_EXPR, DECL_VINDEX (fn), integer_one_node);\n       *pfn = NULL_TREE;\n-      *delta2 = get_binfo (DECL_CONTEXT (fn),\n-\t\t\t  DECL_CLASS_CONTEXT (fn),\n-\t\t\t  0);\n-      *delta2 = get_vfield_offset (*delta2);\n-      *delta2 = size_binop (PLUS_EXPR, *delta2,\n-\t\t\t   build_binary_op (PLUS_EXPR,\n-\t\t\t\t\t    *delta, \n-\t\t\t\t\t    integer_zero_node));\n+\n+      /* Offset from an object of PTR_CLASS to the vptr for ORIG_CLASS.  */\n+      *delta2 = size_binop (PLUS_EXPR, *delta,\n+\t\t\t    get_vfield_offset (TYPE_BINFO (orig_class)));\n     }\n }\n "}]}