{"sha": "7e1bcce3711f5646ffc98652c20e988d55689041", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2UxYmNjZTM3MTFmNTY0NmZmYzk4NjUyYzIwZTk4OGQ1NTY4OTA0MQ==", "commit": {"author": {"name": "Kyrylo Tkachov", "email": "kyrylo.tkachov@arm.com", "date": "2015-04-24T14:52:47Z"}, "committer": {"name": "Kyrylo Tkachov", "email": "ktkachov@gcc.gnu.org", "date": "2015-04-24T14:52:47Z"}, "message": "[AArch64] Implement -m{cpu,tune,arch}=native using only /proc/cpuinfo\n\n\t* config.host (case ${host}): Add aarch64*-*-linux case.\n\t* config/aarch64/aarch64-cores.def: Add IMPLEMENTER_ID and PART_NUMBER\n\tfields to all the cores.\n\t* config/aarch64/aarch64-elf.h (DRIVER_SELF_SPECS):\n\tAdd MCPU_MTUNE_NATIVE_SPECS.\n\t* config/aarch64/aarch64-option-extensions.def: Add FEATURE_STRING\n\tfield to all extensions.\n\t* config/aarch64/aarch64-opts.h: Adjust definition of AARCH64_CORE.\n\t* config/aarch64/aarch64.c: Adjust definition of AARCH64_CORE.\n\tAdjust definition of AARCH64_OPT_EXTENSION.\n\t* config/aarch64/aarch64.h: Adjust definition of AARCH64_CORE.\n\t(MCPU_MTUNE_NATIVE_SPECS): Define.\n\t* config/aarch64/driver-aarch64.c: New file.\n\t* config/aarch64/x-arch64: New file.\n\t* doc/invoke.texi (AArch64 Options): Document native value for -mcpu,\n\t-mtune and -march.\n\nFrom-SVN: r222415", "tree": {"sha": "b4ffc12d1036577eda1baec7f5d6bbe152b867f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b4ffc12d1036577eda1baec7f5d6bbe152b867f1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7e1bcce3711f5646ffc98652c20e988d55689041", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e1bcce3711f5646ffc98652c20e988d55689041", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e1bcce3711f5646ffc98652c20e988d55689041", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e1bcce3711f5646ffc98652c20e988d55689041/comments", "author": {"login": "ktkachov-arm", "id": 74917949, "node_id": "MDQ6VXNlcjc0OTE3OTQ5", "avatar_url": "https://avatars.githubusercontent.com/u/74917949?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ktkachov-arm", "html_url": "https://github.com/ktkachov-arm", "followers_url": "https://api.github.com/users/ktkachov-arm/followers", "following_url": "https://api.github.com/users/ktkachov-arm/following{/other_user}", "gists_url": "https://api.github.com/users/ktkachov-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/ktkachov-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ktkachov-arm/subscriptions", "organizations_url": "https://api.github.com/users/ktkachov-arm/orgs", "repos_url": "https://api.github.com/users/ktkachov-arm/repos", "events_url": "https://api.github.com/users/ktkachov-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/ktkachov-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f8815f7a483ba1fa81d5d07b7a519cd3931fa701", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8815f7a483ba1fa81d5d07b7a519cd3931fa701", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8815f7a483ba1fa81d5d07b7a519cd3931fa701"}], "stats": {"total": 430, "additions": 404, "deletions": 26}, "files": [{"sha": "f29024a7e1e5b4297168242b00aee50cfef2a937", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e1bcce3711f5646ffc98652c20e988d55689041/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e1bcce3711f5646ffc98652c20e988d55689041/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7e1bcce3711f5646ffc98652c20e988d55689041", "patch": "@@ -1,3 +1,22 @@\n+2014-04-24  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n+\n+\t* config.host (case ${host}): Add aarch64*-*-linux case.\n+\t* config/aarch64/aarch64-cores.def: Add IMPLEMENTER_ID and PART_NUMBER\n+\tfields to all the cores.\n+\t* config/aarch64/aarch64-elf.h (DRIVER_SELF_SPECS):\n+\tAdd MCPU_MTUNE_NATIVE_SPECS.\n+\t* config/aarch64/aarch64-option-extensions.def: Add FEATURE_STRING\n+\tfield to all extensions.\n+\t* config/aarch64/aarch64-opts.h: Adjust definition of AARCH64_CORE.\n+\t* config/aarch64/aarch64.c: Adjust definition of AARCH64_CORE.\n+\tAdjust definition of AARCH64_OPT_EXTENSION.\n+\t* config/aarch64/aarch64.h: Adjust definition of AARCH64_CORE.\n+\t(MCPU_MTUNE_NATIVE_SPECS): Define.\n+\t* config/aarch64/driver-aarch64.c: New file.\n+\t* config/aarch64/x-arch64: New file.\n+\t* doc/invoke.texi (AArch64 Options): Document native value for -mcpu,\n+\t-mtune and -march.\n+\n 2015-04-24  Uros Bizjak  <ubizjak@gmail.com>\n \t    Wei Mi  <wmi@google.com>\n "}, {"sha": "a8896d1c382ea65e3101292b27b60e049094bec4", "filename": "gcc/config.host", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e1bcce3711f5646ffc98652c20e988d55689041/gcc%2Fconfig.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e1bcce3711f5646ffc98652c20e988d55689041/gcc%2Fconfig.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.host?ref=7e1bcce3711f5646ffc98652c20e988d55689041", "patch": "@@ -99,6 +99,14 @@ case ${host} in\n esac\n \n case ${host} in\n+  aarch64*-*-linux*)\n+    case ${target} in\n+      aarch64*-*-*)\n+\thost_extra_gcc_objs=\"driver-aarch64.o\"\n+\thost_xmake_file=\"${host_xmake_file} aarch64/x-aarch64\"\n+\t;;\n+    esac\n+    ;;\n   arm*-*-freebsd* | arm*-*-linux*)\n     case ${target} in\n       arm*-*-*)"}, {"sha": "7c285ba52cc27c770d21b18694fefffb6d62fe65", "filename": "gcc/config/aarch64/aarch64-cores.def", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e1bcce3711f5646ffc98652c20e988d55689041/gcc%2Fconfig%2Faarch64%2Faarch64-cores.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e1bcce3711f5646ffc98652c20e988d55689041/gcc%2Fconfig%2Faarch64%2Faarch64-cores.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-cores.def?ref=7e1bcce3711f5646ffc98652c20e988d55689041", "patch": "@@ -21,7 +21,7 @@\n \n    Before using #include to read this file, define a macro:\n \n-      AARCH64_CORE(CORE_NAME, CORE_IDENT, SCHEDULER_IDENT, ARCH, FLAGS, COSTS)\n+      AARCH64_CORE(CORE_NAME, CORE_IDENT, SCHEDULER_IDENT, ARCH, FLAGS, COSTS, IMP, PART)\n \n    The CORE_NAME is the name of the core, represented as a string constant.\n    The CORE_IDENT is the name of the core, represented as an identifier.\n@@ -30,18 +30,23 @@\n    ARCH is the architecture revision implemented by the chip.\n    FLAGS are the bitwise-or of the traits that apply to that core.\n    This need not include flags implied by the architecture.\n-   COSTS is the name of the rtx_costs routine to use.  */\n+   COSTS is the name of the rtx_costs routine to use.\n+   IMP is the implementer ID of the CPU vendor.  On a GNU/Linux system it can\n+   be found in /proc/cpuinfo.\n+   PART is the part number of the CPU.  On a GNU/Linux system it can be found\n+   in /proc/cpuinfo.  For big.LITTLE systems this should have the form at of\n+   \"<big core part number>.<LITTLE core part number>\".  */\n \n /* V8 Architecture Processors.  */\n \n-AARCH64_CORE(\"cortex-a53\",  cortexa53, cortexa53, 8,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC, cortexa53)\n-AARCH64_CORE(\"cortex-a57\",  cortexa57, cortexa57, 8,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC, cortexa57)\n-AARCH64_CORE(\"cortex-a72\",  cortexa72, cortexa57, 8,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC, cortexa57)\n-AARCH64_CORE(\"exynos-m1\",   exynosm1,  cortexa57, 8,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC | AARCH64_FL_CRYPTO, cortexa57)\n-AARCH64_CORE(\"thunderx\",    thunderx,  thunderx, 8,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC | AARCH64_FL_CRYPTO, thunderx)\n-AARCH64_CORE(\"xgene1\",      xgene1,    xgene1,    8,  AARCH64_FL_FOR_ARCH8, xgene1)\n+AARCH64_CORE(\"cortex-a53\",  cortexa53, cortexa53, 8,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC, cortexa53, \"0x41\", \"0xd03\")\n+AARCH64_CORE(\"cortex-a57\",  cortexa57, cortexa57, 8,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC, cortexa57, \"0x41\", \"0xd07\")\n+AARCH64_CORE(\"cortex-a72\",  cortexa72, cortexa57, 8,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC, cortexa57, \"0x41\", \"0xd08\")\n+AARCH64_CORE(\"exynos-m1\",   exynosm1,  cortexa57, 8,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC | AARCH64_FL_CRYPTO, cortexa57, \"0x53\", \"0x001\")\n+AARCH64_CORE(\"thunderx\",    thunderx,  thunderx,  8,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC | AARCH64_FL_CRYPTO, thunderx,  \"0x43\", \"0x0a1\")\n+AARCH64_CORE(\"xgene1\",      xgene1,    xgene1,    8,  AARCH64_FL_FOR_ARCH8, xgene1, \"0x50\", \"0x000\")\n \n /* V8 big.LITTLE implementations.  */\n \n-AARCH64_CORE(\"cortex-a57.cortex-a53\",  cortexa57cortexa53, cortexa53, 8,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC, cortexa57)\n-AARCH64_CORE(\"cortex-a72.cortex-a53\",  cortexa72cortexa53, cortexa53, 8,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC, cortexa57)\n+AARCH64_CORE(\"cortex-a57.cortex-a53\",  cortexa57cortexa53, cortexa53, 8,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC, cortexa57, \"0x41\", \"0xd07.0xd03\")\n+AARCH64_CORE(\"cortex-a72.cortex-a53\",  cortexa72cortexa53, cortexa53, 8,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC, cortexa57, \"0x41\", \"0xd08.0xd03\")"}, {"sha": "1ce6343632784cd568efb3151ce621b38b6c9e86", "filename": "gcc/config/aarch64/aarch64-elf.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e1bcce3711f5646ffc98652c20e988d55689041/gcc%2Fconfig%2Faarch64%2Faarch64-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e1bcce3711f5646ffc98652c20e988d55689041/gcc%2Fconfig%2Faarch64%2Faarch64-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-elf.h?ref=7e1bcce3711f5646ffc98652c20e988d55689041", "patch": "@@ -132,7 +132,8 @@\n #undef DRIVER_SELF_SPECS\n #define DRIVER_SELF_SPECS \\\n   \" %{!mbig-endian:%{!mlittle-endian:\" ENDIAN_SPEC \"}}\" \\\n-  \" %{!mabi=*:\" ABI_SPEC \"}\"\n+  \" %{!mabi=*:\" ABI_SPEC \"}\" \\\n+  MCPU_MTUNE_NATIVE_SPECS\n \n #ifdef HAVE_AS_MABI_OPTION\n #define ASM_MABI_SPEC\t\"%{mabi=*:-mabi=%*}\""}, {"sha": "f296296e9dbb8e3e90397085785ddd8676f7cdbd", "filename": "gcc/config/aarch64/aarch64-option-extensions.def", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e1bcce3711f5646ffc98652c20e988d55689041/gcc%2Fconfig%2Faarch64%2Faarch64-option-extensions.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e1bcce3711f5646ffc98652c20e988d55689041/gcc%2Fconfig%2Faarch64%2Faarch64-option-extensions.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-option-extensions.def?ref=7e1bcce3711f5646ffc98652c20e988d55689041", "patch": "@@ -21,18 +21,25 @@\n \n    Before using #include to read this file, define a macro:\n \n-      AARCH64_OPT_EXTENSION(EXT_NAME, FLAGS_ON, FLAGS_OFF)\n+      AARCH64_OPT_EXTENSION(EXT_NAME, FLAGS_ON, FLAGS_OFF, FEATURE_STRING)\n \n    EXT_NAME is the name of the extension, represented as a string constant.\n    FLAGS_ON are the bitwise-or of the features that the extension adds.\n-   FLAGS_OFF are the bitwise-or of the features that the extension removes.  */\n+   FLAGS_OFF are the bitwise-or of the features that the extension removes.\n+   FEAT_STRING is a string containing the entries in the 'Features' field of\n+   /proc/cpuinfo on a GNU/Linux system that correspond to this architecture\n+   extension being available.  Sometimes multiple entries are needed to enable\n+   the extension (for example, the 'crypto' extension depends on four\n+   entries: aes, pmull, sha1, sha2 being present).  In that case this field\n+   should contain a whitespace-separated list of the strings in 'Features'\n+   that are required.  Their order is not important.  */\n \n /* V8 Architecture Extensions.\n    This list currently contains example extensions for CPUs that implement\n    AArch64, and therefore serves as a template for adding more CPUs in the\n    future.  */\n \n-AARCH64_OPT_EXTENSION(\"fp\",\tAARCH64_FL_FP,\tAARCH64_FL_FPSIMD | AARCH64_FL_CRYPTO)\n-AARCH64_OPT_EXTENSION(\"simd\",\tAARCH64_FL_FPSIMD,\tAARCH64_FL_SIMD | AARCH64_FL_CRYPTO)\n-AARCH64_OPT_EXTENSION(\"crypto\",\tAARCH64_FL_CRYPTO | AARCH64_FL_FPSIMD,\tAARCH64_FL_CRYPTO)\n-AARCH64_OPT_EXTENSION(\"crc\",\tAARCH64_FL_CRC,\tAARCH64_FL_CRC)\n+AARCH64_OPT_EXTENSION(\"fp\",\tAARCH64_FL_FP,                          AARCH64_FL_FPSIMD | AARCH64_FL_CRYPTO, \"fp\")\n+AARCH64_OPT_EXTENSION(\"simd\",\tAARCH64_FL_FPSIMD,                      AARCH64_FL_SIMD | AARCH64_FL_CRYPTO,   \"asimd\")\n+AARCH64_OPT_EXTENSION(\"crypto\",\tAARCH64_FL_CRYPTO | AARCH64_FL_FPSIMD,  AARCH64_FL_CRYPTO,                     \"aes pmull sha1 sha2\")\n+AARCH64_OPT_EXTENSION(\"crc\",\tAARCH64_FL_CRC,                         AARCH64_FL_CRC,                        \"crc32\")"}, {"sha": "ea64cf4a1e7da6249b78649af0c37cc617a9b6b3", "filename": "gcc/config/aarch64/aarch64-opts.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e1bcce3711f5646ffc98652c20e988d55689041/gcc%2Fconfig%2Faarch64%2Faarch64-opts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e1bcce3711f5646ffc98652c20e988d55689041/gcc%2Fconfig%2Faarch64%2Faarch64-opts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-opts.h?ref=7e1bcce3711f5646ffc98652c20e988d55689041", "patch": "@@ -25,7 +25,7 @@\n /* The various cores that implement AArch64.  */\n enum aarch64_processor\n {\n-#define AARCH64_CORE(NAME, INTERNAL_IDENT, SCHED, ARCH, FLAGS, COSTS) \\\n+#define AARCH64_CORE(NAME, INTERNAL_IDENT, SCHED, ARCH, FLAGS, COSTS, IMP, PART) \\\n   INTERNAL_IDENT,\n #include \"aarch64-cores.def\"\n #undef AARCH64_CORE"}, {"sha": "dd92934bdec5a8e6b00ac10462f9086fe818c1a8", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e1bcce3711f5646ffc98652c20e988d55689041/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e1bcce3711f5646ffc98652c20e988d55689041/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=7e1bcce3711f5646ffc98652c20e988d55689041", "patch": "@@ -440,7 +440,7 @@ struct processor\n /* Processor cores implementing AArch64.  */\n static const struct processor all_cores[] =\n {\n-#define AARCH64_CORE(NAME, IDENT, SCHED, ARCH, FLAGS, COSTS) \\\n+#define AARCH64_CORE(NAME, IDENT, SCHED, ARCH, FLAGS, COSTS, IMP, PART) \\\n   {NAME, SCHED, #ARCH, ARCH, FLAGS, &COSTS##_tunings},\n #include \"aarch64-cores.def\"\n #undef AARCH64_CORE\n@@ -477,7 +477,7 @@ struct aarch64_option_extension\n /* ISA extensions in AArch64.  */\n static const struct aarch64_option_extension all_extensions[] =\n {\n-#define AARCH64_OPT_EXTENSION(NAME, FLAGS_ON, FLAGS_OFF) \\\n+#define AARCH64_OPT_EXTENSION(NAME, FLAGS_ON, FLAGS_OFF, FEATURE_STRING) \\\n   {NAME, FLAGS_ON, FLAGS_OFF},\n #include \"aarch64-option-extensions.def\"\n #undef AARCH64_OPT_EXTENSION"}, {"sha": "1f7187bab9b7b22b891d29ca83ce8b2d1f593d15", "filename": "gcc/config/aarch64/aarch64.h", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e1bcce3711f5646ffc98652c20e988d55689041/gcc%2Fconfig%2Faarch64%2Faarch64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e1bcce3711f5646ffc98652c20e988d55689041/gcc%2Fconfig%2Faarch64%2Faarch64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.h?ref=7e1bcce3711f5646ffc98652c20e988d55689041", "patch": "@@ -506,7 +506,7 @@ enum reg_class\n \n enum target_cpus\n {\n-#define AARCH64_CORE(NAME, INTERNAL_IDENT, SCHED, ARCH, FLAGS, COSTS) \\\n+#define AARCH64_CORE(NAME, INTERNAL_IDENT, SCHED, ARCH, FLAGS, COSTS, IMP, PART) \\\n   TARGET_CPU_##INTERNAL_IDENT,\n #include \"aarch64-cores.def\"\n #undef AARCH64_CORE\n@@ -929,11 +929,24 @@ extern const char *aarch64_rewrite_mcpu (int argc, const char **argv);\n #define BIG_LITTLE_CPU_SPEC_FUNCTIONS \\\n   { \"rewrite_mcpu\", aarch64_rewrite_mcpu },\n \n+#if defined(__aarch64__)\n+extern const char *host_detect_local_cpu (int argc, const char **argv);\n+# define EXTRA_SPEC_FUNCTIONS\t\t\t\t\t\t\\\n+  { \"local_cpu_detect\", host_detect_local_cpu },\t\t\t\\\n+  BIG_LITTLE_CPU_SPEC_FUNCTIONS\n+\n+# define MCPU_MTUNE_NATIVE_SPECS\t\t\t\t\t\\\n+   \" %{march=native:%<march=native %:local_cpu_detect(arch)}\"\t\t\\\n+   \" %{mcpu=native:%<mcpu=native %:local_cpu_detect(cpu)}\"\t\t\\\n+   \" %{mtune=native:%<mtune=native %:local_cpu_detect(tune)}\"\n+#else\n+# define MCPU_MTUNE_NATIVE_SPECS \"\"\n+# define EXTRA_SPEC_FUNCTIONS BIG_LITTLE_CPU_SPEC_FUNCTIONS\n+#endif\n+\n #define ASM_CPU_SPEC \\\n    BIG_LITTLE_SPEC\n \n-#define EXTRA_SPEC_FUNCTIONS BIG_LITTLE_CPU_SPEC_FUNCTIONS\n-\n #define EXTRA_SPECS\t\t\t\t\t\t\\\n   { \"asm_cpu_spec\",\t\tASM_CPU_SPEC }\n "}, {"sha": "d0be6db477cfb493c58c092cb0686ebbd3ff8aca", "filename": "gcc/config/aarch64/driver-aarch64.c", "status": "added", "additions": 307, "deletions": 0, "changes": 307, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e1bcce3711f5646ffc98652c20e988d55689041/gcc%2Fconfig%2Faarch64%2Fdriver-aarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e1bcce3711f5646ffc98652c20e988d55689041/gcc%2Fconfig%2Faarch64%2Fdriver-aarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fdriver-aarch64.c?ref=7e1bcce3711f5646ffc98652c20e988d55689041", "patch": "@@ -0,0 +1,307 @@\n+/* Native CPU detection for aarch64.\n+   Copyright (C) 2015 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+\n+struct arch_extension\n+{\n+  const char *ext;\n+  const char *feat_string;\n+};\n+\n+#define AARCH64_OPT_EXTENSION(EXT_NAME, FLAGS_ON, FLAGS_OFF, FEATURE_STRING) \\\n+  { EXT_NAME, FEATURE_STRING },\n+static struct arch_extension ext_to_feat_string[] =\n+{\n+#include \"aarch64-option-extensions.def\"\n+};\n+#undef AARCH64_OPT_EXTENSION\n+\n+\n+struct aarch64_core_data\n+{\n+  const char* name;\n+  const char* arch;\n+  const char* implementer_id;\n+  const char* part_no;\n+};\n+\n+#define AARCH64_CORE(CORE_NAME, CORE_IDENT, SCHED, ARCH, FLAGS, COSTS, IMP, PART) \\\n+  { CORE_NAME, #ARCH, IMP, PART },\n+\n+static struct aarch64_core_data cpu_data [] =\n+{\n+#include \"aarch64-cores.def\"\n+  { NULL, NULL, NULL, NULL }\n+};\n+\n+#undef AARCH64_CORE\n+\n+struct aarch64_arch\n+{\n+  const char* id;\n+  const char* name;\n+};\n+\n+#define AARCH64_ARCH(NAME, CORE, ARCH, FLAGS) \\\n+  { #ARCH, NAME  },\n+\n+static struct aarch64_arch aarch64_arches [] =\n+{\n+#include \"aarch64-arches.def\"\n+  {NULL, NULL}\n+};\n+\n+#undef AARCH64_ARCH\n+\n+/* Return the full architecture name string corresponding to the\n+   identifier ID.  */\n+\n+static const char*\n+get_arch_name_from_id (const char* id)\n+{\n+  unsigned int i = 0;\n+\n+  for (i = 0; aarch64_arches[i].id != NULL; i++)\n+    {\n+      if (strcmp (id, aarch64_arches[i].id) == 0)\n+        return aarch64_arches[i].name;\n+    }\n+\n+  return NULL;\n+}\n+\n+\n+/* Check wether the string CORE contains the same CPU part numbers\n+   as BL_STRING.  For example CORE=\"{0xd03, 0xd07}\" and BL_STRING=\"0xd07.0xd03\"\n+   should return true.  */\n+\n+static bool\n+valid_bL_string_p (const char** core, const char* bL_string)\n+{\n+  return strstr (bL_string, core[0]) != NULL\n+         && strstr (bL_string, core[1]) != NULL;\n+}\n+\n+/*  Return true iff ARR contains STR in one of its two elements.  */\n+\n+static bool\n+contains_string_p (const char** arr, const char* str)\n+{\n+  bool res = false;\n+\n+  if (arr[0] != NULL)\n+    {\n+      res = strstr (arr[0], str) != NULL;\n+      if (res)\n+        return res;\n+\n+      if (arr[1] != NULL)\n+        return strstr (arr[1], str) != NULL;\n+    }\n+\n+  return false;\n+}\n+\n+/* This will be called by the spec parser in gcc.c when it sees\n+   a %:local_cpu_detect(args) construct.  Currently it will be called\n+   with either \"arch\", \"cpu\" or \"tune\" as argument depending on if\n+   -march=native, -mcpu=native or -mtune=native is to be substituted.\n+\n+   It returns a string containing new command line parameters to be\n+   put at the place of the above two options, depending on what CPU\n+   this is executed.  E.g. \"-march=armv8-a\" on a Cortex-A57 for\n+   -march=native.  If the routine can't detect a known processor,\n+   the -march or -mtune option is discarded.\n+\n+   For -mtune and -mcpu arguments it attempts to detect the CPU or\n+   a big.LITTLE system.\n+   ARGC and ARGV are set depending on the actual arguments given\n+   in the spec.  */\n+\n+const char *\n+host_detect_local_cpu (int argc, const char **argv)\n+{\n+  const char *arch_id = NULL;\n+  const char *res = NULL;\n+  static const int num_exts = ARRAY_SIZE (ext_to_feat_string);\n+  char buf[128];\n+  FILE *f = NULL;\n+  bool arch = false;\n+  bool tune = false;\n+  bool cpu = false;\n+  unsigned int i = 0;\n+  unsigned int core_idx = 0;\n+  const char* imps[2] = { NULL, NULL };\n+  const char* cores[2] = { NULL, NULL };\n+  unsigned int n_cores = 0;\n+  unsigned int n_imps = 0;\n+  bool processed_exts = false;\n+  const char *ext_string = \"\";\n+\n+  gcc_assert (argc);\n+\n+  if (!argv[0])\n+    goto not_found;\n+\n+  /* Are we processing -march, mtune or mcpu?  */\n+  arch = strcmp (argv[0], \"arch\") == 0;\n+  if (!arch)\n+    tune = strcmp (argv[0], \"tune\") == 0;\n+\n+  if (!arch && !tune)\n+    cpu = strcmp (argv[0], \"cpu\") == 0;\n+\n+  if (!arch && !tune && !cpu)\n+    goto not_found;\n+\n+  f = fopen (\"/proc/cpuinfo\", \"r\");\n+\n+  if (f == NULL)\n+    goto not_found;\n+\n+  /* Look through /proc/cpuinfo to determine the implementer\n+     and then the part number that identifies a particular core.  */\n+  while (fgets (buf, sizeof (buf), f) != NULL)\n+    {\n+      if (strstr (buf, \"implementer\") != NULL)\n+\t{\n+\t  for (i = 0; cpu_data[i].name != NULL; i++)\n+\t    if (strstr (buf, cpu_data[i].implementer_id) != NULL\n+                && !contains_string_p (imps, cpu_data[i].implementer_id))\n+\t      {\n+                if (n_imps == 2)\n+                  goto not_found;\n+\n+                imps[n_imps++] = cpu_data[i].implementer_id;\n+\n+                break;\n+\t      }\n+          continue;\n+\t}\n+\n+      if (strstr (buf, \"part\") != NULL)\n+\t{\n+\t  for (i = 0; cpu_data[i].name != NULL; i++)\n+\t    if (strstr (buf, cpu_data[i].part_no) != NULL\n+                && !contains_string_p (cores, cpu_data[i].part_no))\n+\t      {\n+                if (n_cores == 2)\n+                  goto not_found;\n+\n+                cores[n_cores++] = cpu_data[i].part_no;\n+\t        core_idx = i;\n+\t        arch_id = cpu_data[i].arch;\n+\t        break;\n+\t      }\n+          continue;\n+        }\n+      if (!tune && !processed_exts && strstr (buf, \"Features\") != NULL)\n+        {\n+          for (i = 0; i < num_exts; i++)\n+            {\n+              bool enabled = true;\n+              char *p = NULL;\n+              char *feat_string = concat (ext_to_feat_string[i].feat_string, NULL);\n+\n+              p = strtok (feat_string, \" \");\n+\n+              while (p != NULL)\n+                {\n+                  if (strstr (buf, p) == NULL)\n+                    {\n+                      enabled = false;\n+                      break;\n+                    }\n+                  p = strtok (NULL, \" \");\n+                }\n+              ext_string = concat (ext_string, \"+\", enabled ? \"\" : \"no\",\n+                                   ext_to_feat_string[i].ext, NULL);\n+            }\n+          processed_exts = true;\n+        }\n+    }\n+\n+  fclose (f);\n+  f = NULL;\n+\n+  /* Weird cpuinfo format that we don't know how to handle.  */\n+  if (n_cores == 0 || n_cores > 2 || n_imps != 1)\n+    goto not_found;\n+\n+  if (arch && !arch_id)\n+    goto not_found;\n+\n+  if (arch)\n+    {\n+      const char* arch_name = get_arch_name_from_id (arch_id);\n+\n+      /* We got some arch indentifier that's not in aarch64-arches.def?  */\n+      if (!arch_name)\n+        goto not_found;\n+\n+      res = concat (\"-march=\", arch_name, NULL);\n+    }\n+  /* We have big.LITTLE.  */\n+  else if (n_cores == 2)\n+    {\n+      for (i = 0; cpu_data[i].name != NULL; i++)\n+        {\n+          if (strchr (cpu_data[i].part_no, '.') != NULL\n+              && strncmp (cpu_data[i].implementer_id, imps[0], strlen (imps[0]) - 1) == 0\n+              && valid_bL_string_p (cores, cpu_data[i].part_no))\n+            {\n+              res = concat (\"-m\", cpu ? \"cpu\" : \"tune\", \"=\", cpu_data[i].name, NULL);\n+              break;\n+            }\n+        }\n+      if (!res)\n+        goto not_found;\n+    }\n+  /* The simple, non-big.LITTLE case.  */\n+  else\n+    {\n+      if (strncmp (cpu_data[core_idx].implementer_id, imps[0],\n+                   strlen (imps[0]) - 1) != 0)\n+        goto not_found;\n+\n+      res = concat (\"-m\", cpu ? \"cpu\" : \"tune\", \"=\",\n+                      cpu_data[core_idx].name, NULL);\n+    }\n+\n+  if (tune)\n+    return res;\n+\n+  res = concat (res, ext_string, NULL);\n+\n+  return res;\n+\n+not_found:\n+  {\n+   /* If detection fails we ignore the option.\n+      Clean up and return empty string.  */\n+\n+    if (f)\n+      fclose (f);\n+\n+    return \"\";\n+  }\n+}\n+"}, {"sha": "8c09e042a5d95f4dc7f24c391aec3d52d9315ef6", "filename": "gcc/config/aarch64/x-aarch64", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e1bcce3711f5646ffc98652c20e988d55689041/gcc%2Fconfig%2Faarch64%2Fx-aarch64", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e1bcce3711f5646ffc98652c20e988d55689041/gcc%2Fconfig%2Faarch64%2Fx-aarch64", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fx-aarch64?ref=7e1bcce3711f5646ffc98652c20e988d55689041", "patch": "@@ -0,0 +1,3 @@\n+driver-aarch64.o: $(srcdir)/config/aarch64/driver-aarch64.c \\\n+  $(CONFIG_H) $(SYSTEM_H)\n+\t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $<"}, {"sha": "7d2f6e58a41e004a28ac410d80736246794c2b22", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e1bcce3711f5646ffc98652c20e988d55689041/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e1bcce3711f5646ffc98652c20e988d55689041/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=7e1bcce3711f5646ffc98652c20e988d55689041", "patch": "@@ -12329,8 +12329,12 @@ This involves inserting a NOP instruction between memory instructions and\n Specify the name of the target architecture, optionally suffixed by one or\n more feature modifiers.  This option has the form\n @option{-march=@var{arch}@r{@{}+@r{[}no@r{]}@var{feature}@r{@}*}}, where the\n-only permissible value for @var{arch} is @samp{armv8-a}.  The permissible\n-values for @var{feature} are documented in the sub-section below.\n+only permissible value for @var{arch} is @samp{armv8-a}.\n+The permissible values for @var{feature} are documented in the sub-section\n+below.  Additionally on native AArch64 GNU/Linux systems the value\n+@samp{native} is available.  This option causes the compiler to pick the\n+architecture of the host system.  If the compiler is unable to recognize the\n+architecture of the host system this option has no effect.\n \n Where conflicting feature modifiers are specified, the right-most feature is\n used.\n@@ -12354,6 +12358,13 @@ Additionally, this option can specify that GCC should tune the performance\n of the code for a big.LITTLE system.  Permissible values for this\n option are: @samp{cortex-a57.cortex-a53}, @samp{cortex-a72.cortex-a53}.\n \n+Additionally on native AArch64 GNU/Linux systems the value @samp{native}\n+is available.\n+This option causes the compiler to pick the architecture of and tune the\n+performance of the code for the processor of the host system.\n+If the compiler is unable to recognize the processor of the host system\n+this option has no effect.\n+\n Where none of @option{-mtune=}, @option{-mcpu=} or @option{-march=}\n are specified, the code is tuned to perform well across a range\n of target processors.\n@@ -12366,7 +12377,11 @@ Specify the name of the target processor, optionally suffixed by one or more\n feature modifiers.  This option has the form\n @option{-mcpu=@var{cpu}@r{@{}+@r{[}no@r{]}@var{feature}@r{@}*}}, where the\n permissible values for @var{cpu} are the same as those available for\n-@option{-mtune}.\n+@option{-mtune}.  Additionally on native AArch64 GNU/Linux systems the\n+value @samp{native} is available.\n+This option causes the compiler to tune the performance of the code for the\n+processor of the host system.  If the compiler is unable to recognize the\n+processor of the host system this option has no effect.\n \n The permissible values for @var{feature} are documented in the sub-section\n below."}]}