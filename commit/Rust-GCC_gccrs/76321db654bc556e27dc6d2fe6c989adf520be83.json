{"sha": "76321db654bc556e27dc6d2fe6c989adf520be83", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzYzMjFkYjY1NGJjNTU2ZTI3ZGM2ZDJmZTZjOTg5YWRmNTIwYmU4Mw==", "commit": {"author": {"name": "Michael Hayes", "email": "m.hayes@elec.canterbury.ac.nz", "date": "2001-06-10T22:49:40Z"}, "committer": {"name": "Michael Hayes", "email": "m.hayes@gcc.gnu.org", "date": "2001-06-10T22:49:40Z"}, "message": "emit-rtl.c (gen_lowpart_common): Do not assume that SFmode and DFmode are one and two words in size.\n\n\t* emit-rtl.c (gen_lowpart_common): Do not assume that SFmode and DFmode\n\tare one and two words in size.\n\nFrom-SVN: r43158", "tree": {"sha": "bba27da56c05987f22169c036eaff435c6117ef4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bba27da56c05987f22169c036eaff435c6117ef4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/76321db654bc556e27dc6d2fe6c989adf520be83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76321db654bc556e27dc6d2fe6c989adf520be83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76321db654bc556e27dc6d2fe6c989adf520be83", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76321db654bc556e27dc6d2fe6c989adf520be83/comments", "author": null, "committer": null, "parents": [{"sha": "2e246150217cf0b2d963c50e15a9a7ff0b3501b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e246150217cf0b2d963c50e15a9a7ff0b3501b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e246150217cf0b2d963c50e15a9a7ff0b3501b9"}], "stats": {"total": 43, "additions": 26, "deletions": 17}, "files": [{"sha": "60c9eabcb12f76c7a006b8b1492562867a20fa4e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76321db654bc556e27dc6d2fe6c989adf520be83/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76321db654bc556e27dc6d2fe6c989adf520be83/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=76321db654bc556e27dc6d2fe6c989adf520be83", "patch": "@@ -1,3 +1,8 @@\n+2001-06-11  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n+\n+\t* emit-rtl.c (gen_lowpart_common): Do not assume that SFmode and DFmode\n+\tare one and two words in size.\n+\n 2001-06-10  Richard Henderson  <rth@redhat.com>\n \n \t* doc/invoke.texi (Optimization Options): Document -fpeephole2."}, {"sha": "03bc62fafa5239d71bbbab559fcd23b019fd4fa2", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76321db654bc556e27dc6d2fe6c989adf520be83/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76321db654bc556e27dc6d2fe6c989adf520be83/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=76321db654bc556e27dc6d2fe6c989adf520be83", "patch": "@@ -772,7 +772,8 @@ gen_lowpart_common (mode, x)\n       else if (GET_MODE_SIZE (mode) < GET_MODE_SIZE (GET_MODE (x)))\n \treturn gen_rtx_fmt_e (GET_CODE (x), mode, XEXP (x, 0));\n     }\n-  else if (GET_CODE (x) == SUBREG || GET_CODE (x) == REG || GET_CODE (x) == CONCAT)\n+  else if (GET_CODE (x) == SUBREG || GET_CODE (x) == REG\n+\t   || GET_CODE (x) == CONCAT)\n     return simplify_gen_subreg (mode, x, GET_MODE (x), offset);\n   /* If X is a CONST_INT or a CONST_DOUBLE, extract the appropriate bits\n      from the low-order part of the constant.  */\n@@ -900,17 +901,19 @@ gen_lowpart_common (mode, x)\n      doesn't have to deal with constructs like (subreg:DI\n      (const_double:SF ...)) or (subreg:DF (const_int ...)).  */\n \n-  else if (mode == SFmode\n+  else if (GET_MODE_CLASS (mode) == MODE_FLOAT\n+\t   && GET_MODE_SIZE (mode) == UNITS_PER_WORD\n \t   && GET_CODE (x) == CONST_INT)\n-    {\n+  {\n       REAL_VALUE_TYPE r;\n       HOST_WIDE_INT i;\n \n       i = INTVAL (x);\n       r = REAL_VALUE_FROM_TARGET_SINGLE (i);\n       return CONST_DOUBLE_FROM_REAL_VALUE (r, mode);\n-    }\n-  else if (mode == DFmode\n+  }\n+  else if (GET_MODE_CLASS (mode) == MODE_FLOAT\n+\t   && GET_MODE_SIZE (mode) == 2 * UNITS_PER_WORD\n \t   && (GET_CODE (x) == CONST_INT || GET_CODE (x) == CONST_DOUBLE)\n \t   && GET_MODE (x) == VOIDmode)\n     {\n@@ -949,23 +952,21 @@ gen_lowpart_common (mode, x)\n       int endian = WORDS_BIG_ENDIAN ? 1 : 0;\n \n       REAL_VALUE_FROM_CONST_DOUBLE (r, x);\n-      switch (GET_MODE (x))\n+      switch (GET_MODE_SIZE (GET_MODE (x)) / UNITS_PER_WORD)\n \t{\n-\tcase SFmode:\n+\tcase 1:\n \t  REAL_VALUE_TO_TARGET_SINGLE (r, i[endian]);\n \t  i[1 - endian] = 0;\n \t  break;\n-\tcase DFmode:\n+\tcase 2:\n \t  REAL_VALUE_TO_TARGET_DOUBLE (r, i);\n \t  break;\n-#if LONG_DOUBLE_TYPE_SIZE == 96\n-\tcase XFmode:\n+\tcase 3:\n \t  REAL_VALUE_TO_TARGET_LONG_DOUBLE (r, i + endian);\n \t  i[3-3*endian] = 0;\n-#else\n-\tcase TFmode:\n+\t  break;\n+\tcase 4:\n \t  REAL_VALUE_TO_TARGET_LONG_DOUBLE (r, i);\n-#endif\n \t  break;\n \tdefault:\n \t  abort ();\n@@ -985,19 +986,22 @@ gen_lowpart_common (mode, x)\n \tfor (c = 0; c < 4; c++)\n \t  i[c] &= ~ (0L);\n \n-\tswitch (GET_MODE (x))\n+\tswitch (GET_MODE_SIZE (GET_MODE (x)) / UNITS_PER_WORD)\n \t  {\n-\t  case SFmode:\n-\t  case DFmode:\n+\t  case 1:\n+\t  case 2:\n \t    return immed_double_const (((unsigned long) i[endian]) |\n \t\t\t\t       (((HOST_WIDE_INT) i[1-endian]) << 32),\n \t\t\t\t       0, mode);\n-\t  default:\n+\t  case 3:\n+\t  case 4:\n \t    return immed_double_const (((unsigned long) i[endian*3]) |\n \t\t\t\t       (((HOST_WIDE_INT) i[1+endian]) << 32),\n \t\t\t\t       ((unsigned long) i[2-endian]) |\n \t\t\t\t       (((HOST_WIDE_INT) i[3-endian*3]) << 32),\n \t\t\t\t       mode);\n+\t  default:\n+\t    abort ();\n \t  }\n       }\n #endif"}]}