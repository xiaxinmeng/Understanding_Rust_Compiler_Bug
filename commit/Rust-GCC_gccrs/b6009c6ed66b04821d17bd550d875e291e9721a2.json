{"sha": "b6009c6ed66b04821d17bd550d875e291e9721a2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjYwMDljNmVkNjZiMDQ4MjFkMTdiZDU1MGQ4NzVlMjkxZTk3MjFhMg==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "1999-04-07T08:01:34Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "1999-04-07T08:01:34Z"}, "message": "Initial revision\n\nFrom-SVN: r26249", "tree": {"sha": "944a82c71cd4bd73a5b8af1fdd38af9a52b81847", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/944a82c71cd4bd73a5b8af1fdd38af9a52b81847"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b6009c6ed66b04821d17bd550d875e291e9721a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6009c6ed66b04821d17bd550d875e291e9721a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6009c6ed66b04821d17bd550d875e291e9721a2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6009c6ed66b04821d17bd550d875e291e9721a2/comments", "author": null, "committer": null, "parents": [{"sha": "2dc18012268aec5e9b1ccd40cb04c1758e46f017", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2dc18012268aec5e9b1ccd40cb04c1758e46f017", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2dc18012268aec5e9b1ccd40cb04c1758e46f017"}], "stats": {"total": 629, "additions": 629, "deletions": 0}, "files": [{"sha": "6c4b2ba56b9447bfc555c43231edccd10bcaf4f2", "filename": "boehm-gc/dbg_mlc.c", "status": "added", "additions": 629, "deletions": 0, "changes": 629, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6009c6ed66b04821d17bd550d875e291e9721a2/boehm-gc%2Fdbg_mlc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6009c6ed66b04821d17bd550d875e291e9721a2/boehm-gc%2Fdbg_mlc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdbg_mlc.c?ref=b6009c6ed66b04821d17bd550d875e291e9721a2", "patch": "@@ -0,0 +1,629 @@\n+/* \n+ * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers\n+ * Copyright (c) 1991-1995 by Xerox Corporation.  All rights reserved.\n+ * Copyright (c) 1997 by Silicon Graphics.  All rights reserved.\n+ *\n+ * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+ * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+ *\n+ * Permission is hereby granted to use or copy this program\n+ * for any purpose,  provided the above notices are retained on all copies.\n+ * Permission to modify the code and to distribute modified code is granted,\n+ * provided the above notices are retained, and a notice that the code was\n+ * modified is included with the above copyright notice.\n+ */\n+/* Boehm, October 9, 1995 1:16 pm PDT */\n+# include \"gc_priv.h\"\n+\n+/* Do we want to and know how to save the call stack at the time of\t*/\n+/* an allocation?  How much space do we want to use in each object?\t*/\n+\n+# define START_FLAG ((word)0xfedcedcb)\n+# define END_FLAG ((word)0xbcdecdef)\n+\t/* Stored both one past the end of user object, and one before\t*/\n+\t/* the end of the object as seen by the allocator.\t\t*/\n+\n+\n+/* Object header */\n+typedef struct {\n+    char * oh_string;\t\t/* object descriptor string\t*/\n+    word oh_int;\t\t/* object descriptor integers\t*/\n+#   ifdef NEED_CALLINFO\n+      struct callinfo oh_ci[NFRAMES];\n+#   endif\n+    word oh_sz;\t\t\t/* Original malloc arg.\t\t*/\n+    word oh_sf;\t\t\t/* start flag */\n+} oh;\n+/* The size of the above structure is assumed not to dealign things,\t*/\n+/* and to be a multiple of the word length.\t\t\t\t*/\n+\n+#define DEBUG_BYTES (sizeof (oh) + sizeof (word))\n+#undef ROUNDED_UP_WORDS\n+#define ROUNDED_UP_WORDS(n) BYTES_TO_WORDS((n) + WORDS_TO_BYTES(1) - 1)\n+\n+\n+#ifdef SAVE_CALL_CHAIN\n+#   define ADD_CALL_CHAIN(base, ra) GC_save_callers(((oh *)(base)) -> oh_ci)\n+#   define PRINT_CALL_CHAIN(base) GC_print_callers(((oh *)(base)) -> oh_ci)\n+#else\n+# ifdef GC_ADD_CALLER\n+#   define ADD_CALL_CHAIN(base, ra) ((oh *)(base)) -> oh_ci[0].ci_pc = (ra)\n+#   define PRINT_CALL_CHAIN(base) GC_print_callers(((oh *)(base)) -> oh_ci)\n+# else\n+#   define ADD_CALL_CHAIN(base, ra)\n+#   define PRINT_CALL_CHAIN(base)\n+# endif\n+#endif\n+\n+/* Check whether object with base pointer p has debugging info\t*/ \n+/* p is assumed to point to a legitimate object in our part\t*/\n+/* of the heap.\t\t\t\t\t\t\t*/\n+GC_bool GC_has_debug_info(p)\n+ptr_t p;\n+{\n+    register oh * ohdr = (oh *)p;\n+    register ptr_t body = (ptr_t)(ohdr + 1);\n+    register word sz = GC_size((ptr_t) ohdr);\n+    \n+    if (HBLKPTR((ptr_t)ohdr) != HBLKPTR((ptr_t)body)\n+        || sz < sizeof (oh)) {\n+        return(FALSE);\n+    }\n+    if (ohdr -> oh_sz == sz) {\n+    \t/* Object may have had debug info, but has been deallocated\t*/\n+    \treturn(FALSE);\n+    }\n+    if (ohdr -> oh_sf == (START_FLAG ^ (word)body)) return(TRUE);\n+    if (((word *)ohdr)[BYTES_TO_WORDS(sz)-1] == (END_FLAG ^ (word)body)) {\n+        return(TRUE);\n+    }\n+    return(FALSE);\n+}\n+\n+/* Store debugging info into p.  Return displaced pointer. */\n+/* Assumes we don't hold allocation lock.\t\t   */\n+ptr_t GC_store_debug_info(p, sz, string, integer)\n+register ptr_t p;\t/* base pointer */\n+word sz; \t/* bytes */\n+char * string;\n+word integer;\n+{\n+    register word * result = (word *)((oh *)p + 1);\n+    DCL_LOCK_STATE;\n+    \n+    /* There is some argument that we should dissble signals here.\t*/\n+    /* But that's expensive.  And this way things should only appear\t*/\n+    /* inconsistent while we're in the handler.\t\t\t\t*/\n+    LOCK();\n+    ((oh *)p) -> oh_string = string;\n+    ((oh *)p) -> oh_int = integer;\n+    ((oh *)p) -> oh_sz = sz;\n+    ((oh *)p) -> oh_sf = START_FLAG ^ (word)result;\n+    ((word *)p)[BYTES_TO_WORDS(GC_size(p))-1] =\n+         result[ROUNDED_UP_WORDS(sz)] = END_FLAG ^ (word)result;\n+    UNLOCK();\n+    return((ptr_t)result);\n+}\n+\n+/* Check the object with debugging info at p \t\t*/\n+/* return NIL if it's OK.  Else return clobbered\t*/\n+/* address.\t\t\t\t\t\t*/\n+ptr_t GC_check_annotated_obj(ohdr)\n+register oh * ohdr;\n+{\n+    register ptr_t body = (ptr_t)(ohdr + 1);\n+    register word gc_sz = GC_size((ptr_t)ohdr);\n+    if (ohdr -> oh_sz + DEBUG_BYTES > gc_sz) {\n+        return((ptr_t)(&(ohdr -> oh_sz)));\n+    }\n+    if (ohdr -> oh_sf != (START_FLAG ^ (word)body)) {\n+        return((ptr_t)(&(ohdr -> oh_sf)));\n+    }\n+    if (((word *)ohdr)[BYTES_TO_WORDS(gc_sz)-1] != (END_FLAG ^ (word)body)) {\n+        return((ptr_t)((word *)ohdr + BYTES_TO_WORDS(gc_sz)-1));\n+    }\n+    if (((word *)body)[ROUNDED_UP_WORDS(ohdr -> oh_sz)]\n+        != (END_FLAG ^ (word)body)) {\n+        return((ptr_t)((word *)body + ROUNDED_UP_WORDS(ohdr -> oh_sz)));\n+    }\n+    return(0);\n+}\n+\n+void GC_print_obj(p)\n+ptr_t p;\n+{\n+    register oh * ohdr = (oh *)GC_base(p);\n+    \n+    GC_err_printf1(\"0x%lx (\", (unsigned long)ohdr + sizeof(oh));\n+    GC_err_puts(ohdr -> oh_string);\n+    GC_err_printf2(\":%ld, sz=%ld)\\n\", (unsigned long)(ohdr -> oh_int),\n+        \t\t\t      (unsigned long)(ohdr -> oh_sz));\n+    PRINT_CALL_CHAIN(ohdr);\n+}\n+\n+void GC_debug_print_heap_obj_proc(p)\n+ptr_t p;\n+{\n+    if (GC_has_debug_info(p)) {\n+\tGC_print_obj(p);\n+    } else {\n+\tGC_default_print_heap_obj_proc(p);\n+    }\n+}\n+\n+void GC_print_smashed_obj(p, clobbered_addr)\n+ptr_t p, clobbered_addr;\n+{\n+    register oh * ohdr = (oh *)GC_base(p);\n+    \n+    GC_err_printf2(\"0x%lx in object at 0x%lx(\", (unsigned long)clobbered_addr,\n+    \t\t\t\t\t        (unsigned long)p);\n+    if (clobbered_addr <= (ptr_t)(&(ohdr -> oh_sz))\n+        || ohdr -> oh_string == 0) {\n+        GC_err_printf1(\"<smashed>, appr. sz = %ld)\\n\",\n+        \t       GC_size((ptr_t)ohdr) - DEBUG_BYTES);\n+    } else {\n+        if (ohdr -> oh_string[0] == '\\0') {\n+            GC_err_puts(\"EMPTY(smashed?)\");\n+        } else {\n+            GC_err_puts(ohdr -> oh_string);\n+        }\n+        GC_err_printf2(\":%ld, sz=%ld)\\n\", (unsigned long)(ohdr -> oh_int),\n+        \t\t\t          (unsigned long)(ohdr -> oh_sz));\n+        PRINT_CALL_CHAIN(ohdr);\n+    }\n+}\n+\n+void GC_check_heap_proc();\n+\n+void GC_start_debugging()\n+{\n+    GC_check_heap = GC_check_heap_proc;\n+    GC_print_heap_obj = GC_debug_print_heap_obj_proc;\n+    GC_debugging_started = TRUE;\n+    GC_register_displacement((word)sizeof(oh));\n+}\n+\n+# if defined(__STDC__) || defined(__cplusplus)\n+    void GC_debug_register_displacement(GC_word offset)\n+# else\n+    void GC_debug_register_displacement(offset) \n+    GC_word offset;\n+# endif\n+{\n+    GC_register_displacement(offset);\n+    GC_register_displacement((word)sizeof(oh) + offset);\n+}\n+\n+# ifdef GC_ADD_CALLER\n+#   define EXTRA_ARGS word ra, char * s, int i\n+#   define OPT_RA ra,\n+# else\n+#   define EXTRA_ARGS char * s, int i\n+#   define OPT_RA\n+# endif\n+\n+# ifdef __STDC__\n+    GC_PTR GC_debug_malloc(size_t lb, EXTRA_ARGS)\n+# else\n+    GC_PTR GC_debug_malloc(lb, s, i)\n+    size_t lb;\n+    char * s;\n+    int i;\n+#   ifdef GC_ADD_CALLER\n+\t--> GC_ADD_CALLER not implemented for K&R C\n+#   endif\n+# endif\n+{\n+    GC_PTR result = GC_malloc(lb + DEBUG_BYTES);\n+    \n+    if (result == 0) {\n+        GC_err_printf1(\"GC_debug_malloc(%ld) returning NIL (\",\n+        \t       (unsigned long) lb);\n+        GC_err_puts(s);\n+        GC_err_printf1(\":%ld)\\n\", (unsigned long)i);\n+        return(0);\n+    }\n+    if (!GC_debugging_started) {\n+    \tGC_start_debugging();\n+    }\n+    ADD_CALL_CHAIN(result, ra);\n+    return (GC_store_debug_info(result, (word)lb, s, (word)i));\n+}\n+\n+#ifdef STUBBORN_ALLOC\n+# ifdef __STDC__\n+    GC_PTR GC_debug_malloc_stubborn(size_t lb, EXTRA_ARGS)\n+# else\n+    GC_PTR GC_debug_malloc_stubborn(lb, s, i)\n+    size_t lb;\n+    char * s;\n+    int i;\n+# endif\n+{\n+    GC_PTR result = GC_malloc_stubborn(lb + DEBUG_BYTES);\n+    \n+    if (result == 0) {\n+        GC_err_printf1(\"GC_debug_malloc(%ld) returning NIL (\",\n+        \t       (unsigned long) lb);\n+        GC_err_puts(s);\n+        GC_err_printf1(\":%ld)\\n\", (unsigned long)i);\n+        return(0);\n+    }\n+    if (!GC_debugging_started) {\n+    \tGC_start_debugging();\n+    }\n+    ADD_CALL_CHAIN(result, ra);\n+    return (GC_store_debug_info(result, (word)lb, s, (word)i));\n+}\n+\n+void GC_debug_change_stubborn(p)\n+GC_PTR p;\n+{\n+    register GC_PTR q = GC_base(p);\n+    register hdr * hhdr;\n+    \n+    if (q == 0) {\n+        GC_err_printf1(\"Bad argument: 0x%lx to GC_debug_change_stubborn\\n\",\n+        \t       (unsigned long) p);\n+        ABORT(\"GC_debug_change_stubborn: bad arg\");\n+    }\n+    hhdr = HDR(q);\n+    if (hhdr -> hb_obj_kind != STUBBORN) {\n+        GC_err_printf1(\"GC_debug_change_stubborn arg not stubborn: 0x%lx\\n\",\n+        \t       (unsigned long) p);\n+        ABORT(\"GC_debug_change_stubborn: arg not stubborn\");\n+    }\n+    GC_change_stubborn(q);\n+}\n+\n+void GC_debug_end_stubborn_change(p)\n+GC_PTR p;\n+{\n+    register GC_PTR q = GC_base(p);\n+    register hdr * hhdr;\n+    \n+    if (q == 0) {\n+        GC_err_printf1(\"Bad argument: 0x%lx to GC_debug_end_stubborn_change\\n\",\n+        \t       (unsigned long) p);\n+        ABORT(\"GC_debug_end_stubborn_change: bad arg\");\n+    }\n+    hhdr = HDR(q);\n+    if (hhdr -> hb_obj_kind != STUBBORN) {\n+        GC_err_printf1(\"debug_end_stubborn_change arg not stubborn: 0x%lx\\n\",\n+        \t       (unsigned long) p);\n+        ABORT(\"GC_debug_end_stubborn_change: arg not stubborn\");\n+    }\n+    GC_end_stubborn_change(q);\n+}\n+\n+#endif /* STUBBORN_ALLOC */\n+\n+# ifdef __STDC__\n+    GC_PTR GC_debug_malloc_atomic(size_t lb, EXTRA_ARGS)\n+# else\n+    GC_PTR GC_debug_malloc_atomic(lb, s, i)\n+    size_t lb;\n+    char * s;\n+    int i;\n+# endif\n+{\n+    GC_PTR result = GC_malloc_atomic(lb + DEBUG_BYTES);\n+    \n+    if (result == 0) {\n+        GC_err_printf1(\"GC_debug_malloc_atomic(%ld) returning NIL (\",\n+        \t      (unsigned long) lb);\n+        GC_err_puts(s);\n+        GC_err_printf1(\":%ld)\\n\", (unsigned long)i);\n+        return(0);\n+    }\n+    if (!GC_debugging_started) {\n+        GC_start_debugging();\n+    }\n+    ADD_CALL_CHAIN(result, ra);\n+    return (GC_store_debug_info(result, (word)lb, s, (word)i));\n+}\n+\n+# ifdef __STDC__\n+    GC_PTR GC_debug_malloc_uncollectable(size_t lb, EXTRA_ARGS)\n+# else\n+    GC_PTR GC_debug_malloc_uncollectable(lb, s, i)\n+    size_t lb;\n+    char * s;\n+    int i;\n+# endif\n+{\n+    GC_PTR result = GC_malloc_uncollectable(lb + DEBUG_BYTES);\n+    \n+    if (result == 0) {\n+        GC_err_printf1(\"GC_debug_malloc_uncollectable(%ld) returning NIL (\",\n+        \t      (unsigned long) lb);\n+        GC_err_puts(s);\n+        GC_err_printf1(\":%ld)\\n\", (unsigned long)i);\n+        return(0);\n+    }\n+    if (!GC_debugging_started) {\n+        GC_start_debugging();\n+    }\n+    ADD_CALL_CHAIN(result, ra);\n+    return (GC_store_debug_info(result, (word)lb, s, (word)i));\n+}\n+\n+#ifdef ATOMIC_UNCOLLECTABLE\n+# ifdef __STDC__\n+    GC_PTR GC_debug_malloc_atomic_uncollectable(size_t lb, EXTRA_ARGS)\n+# else\n+    GC_PTR GC_debug_malloc_atomic_uncollectable(lb, s, i)\n+    size_t lb;\n+    char * s;\n+    int i;\n+# endif\n+{\n+    GC_PTR result = GC_malloc_atomic_uncollectable(lb + DEBUG_BYTES);\n+    \n+    if (result == 0) {\n+        GC_err_printf1(\n+\t\t\"GC_debug_malloc_atomic_uncollectable(%ld) returning NIL (\",\n+                (unsigned long) lb);\n+        GC_err_puts(s);\n+        GC_err_printf1(\":%ld)\\n\", (unsigned long)i);\n+        return(0);\n+    }\n+    if (!GC_debugging_started) {\n+        GC_start_debugging();\n+    }\n+    ADD_CALL_CHAIN(result, ra);\n+    return (GC_store_debug_info(result, (word)lb, s, (word)i));\n+}\n+#endif /* ATOMIC_UNCOLLECTABLE */\n+\n+# ifdef __STDC__\n+    void GC_debug_free(GC_PTR p)\n+# else\n+    void GC_debug_free(p)\n+    GC_PTR p;\n+# endif\n+{\n+    register GC_PTR base = GC_base(p);\n+    register ptr_t clobbered;\n+    \n+    if (base == 0) {\n+        GC_err_printf1(\"Attempt to free invalid pointer %lx\\n\",\n+        \t       (unsigned long)p);\n+        if (p != 0) ABORT(\"free(invalid pointer)\");\n+    }\n+    if ((ptr_t)p - (ptr_t)base != sizeof(oh)) {\n+        GC_err_printf1(\n+        \t  \"GC_debug_free called on pointer %lx wo debugging info\\n\",\n+        \t  (unsigned long)p);\n+    } else {\n+      clobbered = GC_check_annotated_obj((oh *)base);\n+      if (clobbered != 0) {\n+        if (((oh *)base) -> oh_sz == GC_size(base)) {\n+            GC_err_printf0(\n+                  \"GC_debug_free: found previously deallocated (?) object at \");\n+        } else {\n+            GC_err_printf0(\"GC_debug_free: found smashed object at \");\n+        }\n+        GC_print_smashed_obj(p, clobbered);\n+      }\n+      /* Invalidate size */\n+      ((oh *)base) -> oh_sz = GC_size(base);\n+    }\n+#   ifdef FIND_LEAK\n+        GC_free(base);\n+#   else\n+\t{\n+\t    register hdr * hhdr = HDR(p);\n+\t    GC_bool uncollectable = FALSE;\n+\n+\t    if (hhdr ->  hb_obj_kind == UNCOLLECTABLE) {\n+\t\tuncollectable = TRUE;\n+\t    }\n+#\t    ifdef ATOMIC_UNCOLLECTABLE\n+\t\tif (hhdr ->  hb_obj_kind == AUNCOLLECTABLE) {\n+\t\t    uncollectable = TRUE;\n+\t\t}\n+#\t    endif\n+\t    if (uncollectable) GC_free(base);\n+\t}\n+#   endif\n+}\n+\n+# ifdef __STDC__\n+    GC_PTR GC_debug_realloc(GC_PTR p, size_t lb, EXTRA_ARGS)\n+# else\n+    GC_PTR GC_debug_realloc(p, lb, s, i)\n+    GC_PTR p;\n+    size_t lb;\n+    char *s;\n+    int i;\n+# endif\n+{\n+    register GC_PTR base = GC_base(p);\n+    register ptr_t clobbered;\n+    register GC_PTR result;\n+    register size_t copy_sz = lb;\n+    register size_t old_sz;\n+    register hdr * hhdr;\n+    \n+    if (p == 0) return(GC_debug_malloc(lb, OPT_RA s, i));\n+    if (base == 0) {\n+        GC_err_printf1(\n+              \"Attempt to reallocate invalid pointer %lx\\n\", (unsigned long)p);\n+        ABORT(\"realloc(invalid pointer)\");\n+    }\n+    if ((ptr_t)p - (ptr_t)base != sizeof(oh)) {\n+        GC_err_printf1(\n+        \t\"GC_debug_realloc called on pointer %lx wo debugging info\\n\",\n+        \t(unsigned long)p);\n+        return(GC_realloc(p, lb));\n+    }\n+    hhdr = HDR(base);\n+    switch (hhdr -> hb_obj_kind) {\n+#    ifdef STUBBORN_ALLOC\n+      case STUBBORN:\n+        result = GC_debug_malloc_stubborn(lb, OPT_RA s, i);\n+        break;\n+#    endif\n+      case NORMAL:\n+        result = GC_debug_malloc(lb, OPT_RA s, i);\n+        break;\n+      case PTRFREE:\n+        result = GC_debug_malloc_atomic(lb, OPT_RA s, i);\n+        break;\n+      case UNCOLLECTABLE:\n+\tresult = GC_debug_malloc_uncollectable(lb, OPT_RA s, i);\n+ \tbreak;\n+#    ifdef ATOMIC_UNCOLLECTABLE\n+      case AUNCOLLECTABLE:\n+\tresult = GC_debug_malloc_atomic_uncollectable(lb, OPT_RA s, i);\n+\tbreak;\n+#    endif\n+      default:\n+        GC_err_printf0(\"GC_debug_realloc: encountered bad kind\\n\");\n+        ABORT(\"bad kind\");\n+    }\n+    clobbered = GC_check_annotated_obj((oh *)base);\n+    if (clobbered != 0) {\n+        GC_err_printf0(\"GC_debug_realloc: found smashed object at \");\n+        GC_print_smashed_obj(p, clobbered);\n+    }\n+    old_sz = ((oh *)base) -> oh_sz;\n+    if (old_sz < copy_sz) copy_sz = old_sz;\n+    if (result == 0) return(0);\n+    BCOPY(p, result,  copy_sz);\n+    GC_debug_free(p);\n+    return(result);\n+}\n+\n+/* Check all marked objects in the given block for validity */\n+/*ARGSUSED*/\n+void GC_check_heap_block(hbp, dummy)\n+register struct hblk *hbp;\t/* ptr to current heap block\t\t*/\n+word dummy;\n+{\n+    register struct hblkhdr * hhdr = HDR(hbp);\n+    register word sz = hhdr -> hb_sz;\n+    register int word_no;\n+    register word *p, *plim;\n+    \n+    p = (word *)(hbp->hb_body);\n+    word_no = HDR_WORDS;\n+    if (sz > MAXOBJSZ) {\n+\tplim = p;\n+    } else {\n+    \tplim = (word *)((((word)hbp) + HBLKSIZE) - WORDS_TO_BYTES(sz));\n+    }\n+    /* go through all words in block */\n+\twhile( p <= plim ) {\n+\t    if( mark_bit_from_hdr(hhdr, word_no)\n+\t        && GC_has_debug_info((ptr_t)p)) {\n+\t        ptr_t clobbered = GC_check_annotated_obj((oh *)p);\n+\t        \n+\t        if (clobbered != 0) {\n+\t            GC_err_printf0(\n+\t                \"GC_check_heap_block: found smashed object at \");\n+        \t    GC_print_smashed_obj((ptr_t)p, clobbered);\n+\t        }\n+\t    }\n+\t    word_no += sz;\n+\t    p += sz;\n+\t}\n+}\n+\n+\n+/* This assumes that all accessible objects are marked, and that\t*/\n+/* I hold the allocation lock.\tNormally called by collector.\t\t*/\n+void GC_check_heap_proc()\n+{\n+#   ifndef SMALL_CONFIG\n+\tif (sizeof(oh) & (2 * sizeof(word) - 1) != 0) {\n+\t    ABORT(\"Alignment problem: object header has inappropriate size\\n\");\n+\t}\n+#   endif\n+    GC_apply_to_all_blocks(GC_check_heap_block, (word)0);\n+}\n+\n+struct closure {\n+    GC_finalization_proc cl_fn;\n+    GC_PTR cl_data;\n+};\n+\n+# ifdef __STDC__\n+    void * GC_make_closure(GC_finalization_proc fn, void * data)\n+# else\n+    GC_PTR GC_make_closure(fn, data)\n+    GC_finalization_proc fn;\n+    GC_PTR data;\n+# endif\n+{\n+    struct closure * result =\n+    \t\t(struct closure *) GC_malloc(sizeof (struct closure));\n+    \n+    result -> cl_fn = fn;\n+    result -> cl_data = data;\n+    return((GC_PTR)result);\n+}\n+\n+# ifdef __STDC__\n+    void GC_debug_invoke_finalizer(void * obj, void * data)\n+# else\n+    void GC_debug_invoke_finalizer(obj, data)\n+    char * obj;\n+    char * data;\n+# endif\n+{\n+    register struct closure * cl = (struct closure *) data;\n+    \n+    (*(cl -> cl_fn))((GC_PTR)((char *)obj + sizeof(oh)), cl -> cl_data);\n+} \n+\n+\n+# ifdef __STDC__\n+    void GC_debug_register_finalizer(GC_PTR obj, GC_finalization_proc fn,\n+    \t\t\t\t     GC_PTR cd, GC_finalization_proc *ofn,\n+\t\t\t\t     GC_PTR *ocd)\n+# else\n+    void GC_debug_register_finalizer(obj, fn, cd, ofn, ocd)\n+    GC_PTR obj;\n+    GC_finalization_proc fn;\n+    GC_PTR cd;\n+    GC_finalization_proc *ofn;\n+    GC_PTR *ocd;\n+# endif\n+{\n+    ptr_t base = GC_base(obj);\n+    if (0 == base || (ptr_t)obj - base != sizeof(oh)) {\n+        GC_err_printf1(\n+\t    \"GC_register_finalizer called with non-base-pointer 0x%lx\\n\",\n+\t    obj);\n+    }\n+    GC_register_finalizer(base, GC_debug_invoke_finalizer,\n+    \t\t\t  GC_make_closure(fn,cd), ofn, ocd);\n+}\n+\n+# ifdef __STDC__\n+    void GC_debug_register_finalizer_ignore_self\n+    \t\t\t\t    (GC_PTR obj, GC_finalization_proc fn,\n+    \t\t\t\t     GC_PTR cd, GC_finalization_proc *ofn,\n+\t\t\t\t     GC_PTR *ocd)\n+# else\n+    void GC_debug_register_finalizer_ignore_self\n+    \t\t\t\t    (obj, fn, cd, ofn, ocd)\n+    GC_PTR obj;\n+    GC_finalization_proc fn;\n+    GC_PTR cd;\n+    GC_finalization_proc *ofn;\n+    GC_PTR *ocd;\n+# endif\n+{\n+    ptr_t base = GC_base(obj);\n+    if (0 == base || (ptr_t)obj - base != sizeof(oh)) {\n+        GC_err_printf1(\n+\t    \"GC_register_finalizer_ignore_self called with non-base-pointer 0x%lx\\n\",\n+\t    obj);\n+    }\n+    GC_register_finalizer_ignore_self(base, GC_debug_invoke_finalizer,\n+    \t\t\t  \t      GC_make_closure(fn,cd), ofn, ocd);\n+}"}]}