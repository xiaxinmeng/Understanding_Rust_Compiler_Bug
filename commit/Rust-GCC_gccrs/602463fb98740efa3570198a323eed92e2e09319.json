{"sha": "602463fb98740efa3570198a323eed92e2e09319", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjAyNDYzZmI5ODc0MGVmYTM1NzAxOThhMzIzZWVkOTJlMmUwOTMxOQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-05-28T17:40:47Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-06-03T10:41:20Z"}, "message": "Also generate DW_OP_GNU_variable_value at file scope\n\nBut only for the reference variant (dw_val_class_die_ref).  This is needed\nfor variable-sized types declared at library level in Ada.\n\ngcc/\n\t* dwarf2out.c (loc_list_from_tree_1) <FUNCTION_DECL>: Also generate\n\tDW_OP_GNU_variable_value referencing an existing DIE at file scope.\n\t(type_byte_size): Inline into...\n\t(add_byte_size_attribute): ...this and call add_scalar_info.", "tree": {"sha": "a78613a51f03eb6beaa57fe4f0c04688fefac770", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a78613a51f03eb6beaa57fe4f0c04688fefac770"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/602463fb98740efa3570198a323eed92e2e09319", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/602463fb98740efa3570198a323eed92e2e09319", "html_url": "https://github.com/Rust-GCC/gccrs/commit/602463fb98740efa3570198a323eed92e2e09319", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/602463fb98740efa3570198a323eed92e2e09319/comments", "author": null, "committer": null, "parents": [{"sha": "df741be17ee09974ad46750ebbbacf55f8e108a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df741be17ee09974ad46750ebbbacf55f8e108a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df741be17ee09974ad46750ebbbacf55f8e108a8"}], "stats": {"total": 70, "additions": 28, "deletions": 42}, "files": [{"sha": "88eb3f9c4558dfba5217e417e56c8be7dafe4e13", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 28, "deletions": 42, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/602463fb98740efa3570198a323eed92e2e09319/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/602463fb98740efa3570198a323eed92e2e09319/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=602463fb98740efa3570198a323eed92e2e09319", "patch": "@@ -18829,25 +18829,25 @@ loc_list_from_tree_1 (tree loc, int want_address,\n \t  {\n \t    if (TREE_CODE (loc) != FUNCTION_DECL\n \t\t&& early_dwarf\n-\t\t&& current_function_decl\n \t\t&& want_address != 1\n \t\t&& ! DECL_IGNORED_P (loc)\n \t\t&& (INTEGRAL_TYPE_P (TREE_TYPE (loc))\n \t\t    || POINTER_TYPE_P (TREE_TYPE (loc)))\n-\t\t&& DECL_CONTEXT (loc) == current_function_decl\n \t\t&& (GET_MODE_SIZE (SCALAR_INT_TYPE_MODE (TREE_TYPE (loc)))\n \t\t    <= DWARF2_ADDR_SIZE))\n \t      {\n \t\tdw_die_ref ref = lookup_decl_die (loc);\n-\t\tret = new_loc_descr (DW_OP_GNU_variable_value, 0, 0);\n \t\tif (ref)\n \t\t  {\n+\t\t    ret = new_loc_descr (DW_OP_GNU_variable_value, 0, 0);\n \t\t    ret->dw_loc_oprnd1.val_class = dw_val_class_die_ref;\n \t\t    ret->dw_loc_oprnd1.v.val_die_ref.die = ref;\n \t\t    ret->dw_loc_oprnd1.v.val_die_ref.external = 0;\n \t\t  }\n-\t\telse\n+\t\telse if (current_function_decl\n+\t\t\t && DECL_CONTEXT (loc) == current_function_decl)\n \t\t  {\n+\t\t    ret = new_loc_descr (DW_OP_GNU_variable_value, 0, 0);\n \t\t    ret->dw_loc_oprnd1.val_class = dw_val_class_decl_ref;\n \t\t    ret->dw_loc_oprnd1.v.val_decl_ref = loc;\n \t\t  }\n@@ -19588,32 +19588,6 @@ round_up_to_align (const offset_int &t, unsigned int align)\n   return wi::udiv_trunc (t + align - 1, align) * align;\n }\n \n-/* Compute the size of TYPE in bytes.  If possible, return NULL and store the\n-   size as an integer constant in CST_SIZE.  Otherwise, if possible, return a\n-   DWARF expression that computes the size.  Return NULL and set CST_SIZE to -1\n-   if we fail to return the size in one of these two forms.  */\n-\n-static dw_loc_descr_ref\n-type_byte_size (const_tree type, HOST_WIDE_INT *cst_size)\n-{\n-  /* Return a constant integer in priority, if possible.  */\n-  *cst_size = int_size_in_bytes (type);\n-  if (*cst_size != -1)\n-    return NULL;\n-\n-  struct loc_descr_context ctx = {\n-    const_cast<tree> (type),\t/* context_type */\n-    NULL_TREE,\t      \t\t/* base_decl */\n-    NULL,\t      \t\t/* dpi */\n-    false,\t      \t\t/* placeholder_arg */\n-    false,\t      \t\t/* placeholder_seen */\n-    false\t      \t\t/* strict_signedness */\n-  };\n-\n-  tree tree_size = TYPE_SIZE_UNIT (TYPE_MAIN_VARIANT (type));\n-  return tree_size ? loc_descriptor_from_tree (tree_size, 0, &ctx) : NULL;\n-}\n-\n /* Helper structure for RECORD_TYPE processing.  */\n struct vlr_context\n {\n@@ -21555,7 +21529,6 @@ add_byte_size_attribute (dw_die_ref die, tree tree_node)\n {\n   dw_die_ref decl_die;\n   HOST_WIDE_INT size;\n-  dw_loc_descr_ref size_expr = NULL;\n \n   switch (TREE_CODE (tree_node))\n     {\n@@ -21572,7 +21545,7 @@ add_byte_size_attribute (dw_die_ref die, tree tree_node)\n \t  add_AT_die_ref (die, DW_AT_byte_size, decl_die);\n \t  return;\n \t}\n-      size_expr = type_byte_size (tree_node, &size);\n+      size = int_size_in_bytes (tree_node);\n       break;\n     case FIELD_DECL:\n       /* For a data member of a struct or union, the DW_AT_byte_size is\n@@ -21585,19 +21558,32 @@ add_byte_size_attribute (dw_die_ref die, tree tree_node)\n       gcc_unreachable ();\n     }\n \n-  /* Support for dynamically-sized objects was introduced by DWARFv3.\n-     At the moment, GDB does not handle variable byte sizes very well,\n-     though.  */\n-  if ((dwarf_version >= 3 || !dwarf_strict)\n-      && gnat_encodings == DWARF_GNAT_ENCODINGS_MINIMAL\n-      && size_expr != NULL)\n-    add_AT_loc (die, DW_AT_byte_size, size_expr);\n-\n   /* Note that `size' might be -1 when we get to this point.  If it is, that\n-     indicates that the byte size of the entity in question is variable and\n-     that we could not generate a DWARF expression that computes it.  */\n+     indicates that the byte size of the entity in question is variable.  */\n   if (size >= 0)\n     add_AT_unsigned (die, DW_AT_byte_size, size);\n+\n+  /* Support for dynamically-sized objects was introduced in DWARF3.  */\n+  else if (TYPE_P (tree_node)\n+\t   && (dwarf_version >= 3 || !dwarf_strict)\n+\t   && gnat_encodings == DWARF_GNAT_ENCODINGS_MINIMAL)\n+    {\n+      struct loc_descr_context ctx = {\n+\tconst_cast<tree> (tree_node),\t/* context_type */\n+\tNULL_TREE,\t      \t\t/* base_decl */\n+\tNULL,\t      \t\t/* dpi */\n+\tfalse,\t      \t\t/* placeholder_arg */\n+\tfalse,\t      \t\t/* placeholder_seen */\n+\tfalse\t      \t\t/* strict_signedness */\n+      };\n+\n+      tree tree_size = TYPE_SIZE_UNIT (TYPE_MAIN_VARIANT (tree_node));\n+      add_scalar_info (die, DW_AT_byte_size, tree_size,\n+\t\t       dw_scalar_form_constant\n+\t\t       | dw_scalar_form_exprloc\n+\t\t       | dw_scalar_form_reference,\n+\t\t       &ctx);\n+    }\n }\n \n /* Add a DW_AT_alignment attribute to DIE with TREE_NODE's non-default"}]}