{"sha": "d9398dd2902a0142fa3b493cf61a340f1f5ab46f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDkzOThkZDI5MDJhMDE0MmZhM2I0OTNjZjYxYTM0MGYxZjVhYjQ2Zg==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.ibm.com", "date": "2021-04-30T16:32:08Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@linux.ibm.com", "date": "2021-04-30T16:32:08Z"}, "message": "Define target hook to emit KFmode constants for libgcc.\n\nThis patch defines a target hook so that the KFmode constants\n(__LIBGCC_KF_MAX__, __LIBGCC_KF_MIN__, and __LIBGCC_KF_EPSILON__) needed to\nbuild _divkc3.c in libgcc are defined.  The need for these constants were added\nin the April 28th changes to libgcc that added complex division optimizations.\n\nWe only define the KFmode constants if IEEE 128-bit floating point is\nsupported, but long double does not use the IEEE 128-bit format.  If long\ndouble uses the IEEE 128-bit format, it will use TFmode and not KFmode.\n\ngcc/\n2021-04-30  Michael Meissner  <meissner@linux.ibm.com>\n\n\tPR bootstrap/100327\n\t* config/rs6000/rs6000.c\n\t(TARGET_LIBGCC_FLOATING_MODE_SUPPORTED_P): Define.\n\t(rs6000_libgcc_floating_mode_supported_p): New target hook.", "tree": {"sha": "9ece24cab7bd3a847e9194366782661d0b444cc0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9ece24cab7bd3a847e9194366782661d0b444cc0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d9398dd2902a0142fa3b493cf61a340f1f5ab46f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9398dd2902a0142fa3b493cf61a340f1f5ab46f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9398dd2902a0142fa3b493cf61a340f1f5ab46f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9398dd2902a0142fa3b493cf61a340f1f5ab46f/comments", "author": null, "committer": null, "parents": [{"sha": "69e5544210e3c0e27df3e6590b646c13dcce24e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69e5544210e3c0e27df3e6590b646c13dcce24e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69e5544210e3c0e27df3e6590b646c13dcce24e3"}], "stats": {"total": 29, "additions": 29, "deletions": 0}, "files": [{"sha": "77181769e0b9951262899195b1ea228dc75f109f", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9398dd2902a0142fa3b493cf61a340f1f5ab46f/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9398dd2902a0142fa3b493cf61a340f1f5ab46f/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=d9398dd2902a0142fa3b493cf61a340f1f5ab46f", "patch": "@@ -1569,6 +1569,10 @@ static const struct attribute_spec rs6000_attribute_table[] =\n #undef TARGET_SCALAR_MODE_SUPPORTED_P\n #define TARGET_SCALAR_MODE_SUPPORTED_P rs6000_scalar_mode_supported_p\n \n+#undef TARGET_LIBGCC_FLOATING_MODE_SUPPORTED_P\n+#define TARGET_LIBGCC_FLOATING_MODE_SUPPORTED_P \\\n+  rs6000_libgcc_floating_mode_supported_p\n+\n #undef TARGET_VECTOR_MODE_SUPPORTED_P\n #define TARGET_VECTOR_MODE_SUPPORTED_P rs6000_vector_mode_supported_p\n \n@@ -23826,6 +23830,31 @@ rs6000_scalar_mode_supported_p (scalar_mode mode)\n     return default_scalar_mode_supported_p (mode);\n }\n \n+/* Target hook for libgcc_floating_mode_supported_p.  */\n+\n+static bool\n+rs6000_libgcc_floating_mode_supported_p (scalar_float_mode mode)\n+{\n+  switch (mode)\n+    {\n+    case E_SFmode:\n+    case E_DFmode:\n+    case E_TFmode:\n+      return true;\n+\n+      /* We only return true for KFmode if IEEE 128-bit types are supported, and\n+\t if long double does not use the IEEE 128-bit format.  If long double\n+\t uses the IEEE 128-bit format, it will use TFmode and not KFmode.\n+\t Because the code will not use KFmode in that case, there will be aborts\n+\t because it can't find KFmode in the Floatn types.  */\n+    case E_KFmode:\n+      return TARGET_FLOAT128_TYPE && !TARGET_IEEEQUAD;\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n /* Target hook for vector_mode_supported_p.  */\n static bool\n rs6000_vector_mode_supported_p (machine_mode mode)"}]}