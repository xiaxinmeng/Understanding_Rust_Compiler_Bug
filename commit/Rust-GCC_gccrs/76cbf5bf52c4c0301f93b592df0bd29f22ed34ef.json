{"sha": "76cbf5bf52c4c0301f93b592df0bd29f22ed34ef", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzZjYmY1YmY1MmM0YzAzMDFmOTNiNTkyZGYwYmQyOWYyMmVkMzRlZg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2004-04-18T08:22:38Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2004-04-18T08:22:38Z"}, "message": "mips-protos.h (m16_usym8_4, [...]): Delete.\n\n\t* config/mips/mips-protos.h (m16_usym8_4, m16_usym5_4): Delete.\n\t* config/mips/mips.h (mips_entry, mips_string_length): Delete.\n\t(CONSTANT_POOL_BEFORE_FUNCTION, ASM_OUTPUT_POOL_EPILOGUE): Undefine.\n\t* config/mips/mips.c (struct mips16_constant): Renamed from struct\n\tconstant.  Propogate change throughout file.\n\t(struct machine_function): Remove insns_len.\n\t(mips_string_length, mips16_strings, string_constants): Delete.\n\t(mips_classify_symbol): Return SYMBOL_CONSTANT_POOL for LABEL_REFs\n\twhen generating mips16 code.  Remove special mips16 treatment of\n\tstring constants.\n\t(mips_symbolic_constant_p): Allow mips16 constant pool accesses\n\tto have the form LABEL+CONSTANT.\n\t(mips_symbolic_address_p): Fix comment.\n\t(m16_usym8_4, m16_usym5_4): Delete.\n\t(mips_output_function_epilogue): Remove mips16 string handling.\n\t(mips_output_mi_thunk): Call mips16_lay_out_constants.\n\t(mips_select_section, mips_encode_section_info): Remove mips16\n\tstring handling.\n\t(struct mips16_constant_pool): New.\n\t(add_constant): Take a mips16_constant_pool structure.  Keep pool\n\tsorted into order of ascending mode size.  Keep track of the highest\n\tpossible start address, taking padding and the masking of the base PC\n\tvalue into account.\n\t(dump_constants_1): New function, split out from dump_constants.\n\tHandle vector constants.  Use gen_consttable_{int,float} rather than\n\tseparate functions for each mode.\n\t(dump_constants): Simplify.  Use GET_MODE_ALIGNMENT.  Use gen_align\n\trather than separate functions for each alignment.\n\t(mips_find_symbol): Delete.\n\t(mips16_insn_length): New function, split out from\n\tmips16_lay_out_constants.\n\t(mips16_rewrite_pool_refs): New function.\n\t(mips16_lay_out_constants): Rework. Remove string handling.\n\tAlways create an inline constant pool.\n\t* config/mips/mips.md (UNSPEC_CONSTTABLE_INT, UNSPEC_CONSTTABLE_FLOAT)\n\t(UNSPEC_ALIGN): New constants.\n\t(UNSPEC_CONSTTABLE_[QHSD]I, UNSPEC_CONSTTABLE_[SD]F): Delete.\n\t(UNSPEC_ALIGN_[248]): Delete.\n\t(consttable_int, consttable_float, align): New patterns.\n\t(consttable_[qhsd]i, consttable_[sd]f, align_[248]): Delete.\n\nFrom-SVN: r80814", "tree": {"sha": "54a308dbdeddd642eed1bfcbdd9ef02716daa68a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/54a308dbdeddd642eed1bfcbdd9ef02716daa68a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/76cbf5bf52c4c0301f93b592df0bd29f22ed34ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76cbf5bf52c4c0301f93b592df0bd29f22ed34ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76cbf5bf52c4c0301f93b592df0bd29f22ed34ef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76cbf5bf52c4c0301f93b592df0bd29f22ed34ef/comments", "author": null, "committer": null, "parents": [{"sha": "f178c2d6959fb186ca9ee2aa26d01bd3f9157986", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f178c2d6959fb186ca9ee2aa26d01bd3f9157986", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f178c2d6959fb186ca9ee2aa26d01bd3f9157986"}], "stats": {"total": 781, "additions": 263, "deletions": 518}, "files": [{"sha": "cad431e19bdd0d431f677a1468868467380561a9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76cbf5bf52c4c0301f93b592df0bd29f22ed34ef/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76cbf5bf52c4c0301f93b592df0bd29f22ed34ef/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=76cbf5bf52c4c0301f93b592df0bd29f22ed34ef", "patch": "@@ -1,3 +1,46 @@\n+2004-04-18  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* config/mips/mips-protos.h (m16_usym8_4, m16_usym5_4): Delete.\n+\t* config/mips/mips.h (mips_entry, mips_string_length): Delete.\n+\t(CONSTANT_POOL_BEFORE_FUNCTION, ASM_OUTPUT_POOL_EPILOGUE): Undefine.\n+\t* config/mips/mips.c (struct mips16_constant): Renamed from struct\n+\tconstant.  Propogate change throughout file.\n+\t(struct machine_function): Remove insns_len.\n+\t(mips_string_length, mips16_strings, string_constants): Delete.\n+\t(mips_classify_symbol): Return SYMBOL_CONSTANT_POOL for LABEL_REFs\n+\twhen generating mips16 code.  Remove special mips16 treatment of\n+\tstring constants.\n+\t(mips_symbolic_constant_p): Allow mips16 constant pool accesses\n+\tto have the form LABEL+CONSTANT.\n+\t(mips_symbolic_address_p): Fix comment.\n+\t(m16_usym8_4, m16_usym5_4): Delete.\n+\t(mips_output_function_epilogue): Remove mips16 string handling.\n+\t(mips_output_mi_thunk): Call mips16_lay_out_constants.\n+\t(mips_select_section, mips_encode_section_info): Remove mips16\n+\tstring handling.\n+\t(struct mips16_constant_pool): New.\n+\t(add_constant): Take a mips16_constant_pool structure.  Keep pool\n+\tsorted into order of ascending mode size.  Keep track of the highest\n+\tpossible start address, taking padding and the masking of the base PC\n+\tvalue into account.\n+\t(dump_constants_1): New function, split out from dump_constants.\n+\tHandle vector constants.  Use gen_consttable_{int,float} rather than\n+\tseparate functions for each mode.\n+\t(dump_constants): Simplify.  Use GET_MODE_ALIGNMENT.  Use gen_align\n+\trather than separate functions for each alignment.\n+\t(mips_find_symbol): Delete.\n+\t(mips16_insn_length): New function, split out from\n+\tmips16_lay_out_constants.\n+\t(mips16_rewrite_pool_refs): New function.\n+\t(mips16_lay_out_constants): Rework. Remove string handling.\n+\tAlways create an inline constant pool.\n+\t* config/mips/mips.md (UNSPEC_CONSTTABLE_INT, UNSPEC_CONSTTABLE_FLOAT)\n+\t(UNSPEC_ALIGN): New constants.\n+\t(UNSPEC_CONSTTABLE_[QHSD]I, UNSPEC_CONSTTABLE_[SD]F): Delete.\n+\t(UNSPEC_ALIGN_[248]): Delete.\n+\t(consttable_int, consttable_float, align): New patterns.\n+\t(consttable_[qhsd]i, consttable_[sd]f, align_[248]): Delete.\n+\n 2004-04-17  Aldy Hernandez  <aldyh@redhat.com>\n \n \t* config/rs6000/altivec.h (vec_any_numeric): Correct typo in"}, {"sha": "fac8246966277105f4d1d756842f19c8a09b63dd", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76cbf5bf52c4c0301f93b592df0bd29f22ed34ef/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76cbf5bf52c4c0301f93b592df0bd29f22ed34ef/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=76cbf5bf52c4c0301f93b592df0bd29f22ed34ef", "patch": "@@ -114,8 +114,6 @@ extern int m16_uimm8_4 (rtx, enum machine_mode);\n extern int m16_nuimm8_4 (rtx, enum machine_mode);\n extern int m16_simm8_8 (rtx, enum machine_mode);\n extern int m16_nsimm8_8 (rtx, enum machine_mode);\n-extern int m16_usym8_4 (rtx, enum machine_mode);\n-extern int m16_usym5_4 (rtx, enum machine_mode);\n \n extern struct rtx_def *embedded_pic_fnaddr_reg (void);\n extern struct rtx_def *embedded_pic_offset (rtx);"}, {"sha": "5368a1ba3c9ce3eba8ba3761c18a8ec6a60c8de7", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 198, "deletions": 407, "changes": 605, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76cbf5bf52c4c0301f93b592df0bd29f22ed34ef/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76cbf5bf52c4c0301f93b592df0bd29f22ed34ef/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=76cbf5bf52c4c0301f93b592df0bd29f22ed34ef", "patch": "@@ -134,7 +134,7 @@ enum mips_address_type {\n    register and the second is the stack slot.  */\n typedef void (*mips_save_restore_fn) (rtx, rtx);\n \n-struct constant;\n+struct mips16_constant;\n struct mips_arg_info;\n struct mips_address_info;\n struct mips_integer_op;\n@@ -215,9 +215,10 @@ static rtx mips_return_fpr_pair (enum machine_mode mode,\n static rtx mips16_gp_pseudo_reg (void);\n static void mips16_fp_args (FILE *, int, int);\n static void build_mips16_function_stub (FILE *);\n-static rtx add_constant\t(struct constant **, rtx, enum machine_mode);\n-static void dump_constants (struct constant *, rtx);\n-static rtx mips_find_symbol (rtx);\n+static rtx dump_constants_1 (enum machine_mode, rtx, rtx);\n+static void dump_constants (struct mips16_constant *, rtx);\n+static int mips16_insn_length (rtx);\n+static int mips16_rewrite_pool_refs (rtx *, void *);\n static void mips16_lay_out_constants (void);\n static void mips_avoid_hazard (rtx, rtx, int *, rtx *, rtx);\n static void mips_avoid_hazards (void);\n@@ -283,9 +284,6 @@ struct machine_function GTY(()) {\n   /* Current frame information, calculated by compute_frame_size.  */\n   struct mips_frame_info frame;\n \n-  /* Length of instructions in function; mips16 only.  */\n-  long insns_len;\n-\n   /* The register to use as the global pointer within this function.  */\n   unsigned int global_pointer;\n \n@@ -462,28 +460,6 @@ static enum machine_mode gpr_mode;\n    can support a given mode.  */\n char mips_hard_regno_mode_ok[(int)MAX_MACHINE_MODE][FIRST_PSEUDO_REGISTER];\n \n-/* The length of all strings seen when compiling for the mips16.  This\n-   is used to tell how many strings are in the constant pool, so that\n-   we can see if we may have an overflow.  This is reset each time the\n-   constant pool is output.  */\n-int mips_string_length;\n-\n-/* When generating mips16 code, a list of all strings that are to be\n-   output after the current function.  */\n-\n-static GTY(()) rtx mips16_strings;\n-\n-/* In mips16 mode, we build a list of all the string constants we see\n-   in a particular function.  */\n-\n-struct string_constant\n-{\n-  struct string_constant *next;\n-  const char *label;\n-};\n-\n-static struct string_constant *string_constants;\n-\n /* List of all MIPS punctuation characters used by print_operand.  */\n char mips_print_operand_punct[256];\n \n@@ -776,7 +752,13 @@ static enum mips_symbol_type\n mips_classify_symbol (rtx x)\n {\n   if (GET_CODE (x) == LABEL_REF)\n-    return (TARGET_ABICALLS ? SYMBOL_GOT_LOCAL : SYMBOL_GENERAL);\n+    {\n+      if (TARGET_MIPS16)\n+\treturn SYMBOL_CONSTANT_POOL;\n+      if (TARGET_ABICALLS)\n+\treturn SYMBOL_GOT_LOCAL;\n+      return SYMBOL_GENERAL;\n+    }\n \n   if (GET_CODE (x) != SYMBOL_REF)\n     abort ();\n@@ -798,11 +780,6 @@ mips_classify_symbol (rtx x)\n   if (SYMBOL_REF_SMALL_P (x))\n     return SYMBOL_SMALL_DATA;\n \n-  /* When generating mips16 code, SYMBOL_REF_FLAG indicates a string\n-     in the current function's constant pool.  */\n-  if (TARGET_MIPS16 && SYMBOL_REF_FLAG (x))\n-    return SYMBOL_CONSTANT_POOL;\n-\n   if (TARGET_ABICALLS)\n     {\n       if (SYMBOL_REF_DECL (x) == 0)\n@@ -919,8 +896,16 @@ mips_symbolic_constant_p (rtx x, enum mips_symbol_type *symbol_type)\n       /* In other cases the relocations can handle any offset.  */\n       return true;\n \n-    case SYMBOL_SMALL_DATA:\n     case SYMBOL_CONSTANT_POOL:\n+      /* Allow constant pool references to be converted to LABEL+CONSTANT.\n+\t In this case, we no longer have access to the underlying constant,\n+\t but the original symbol-based access was known to be valid.  */\n+      if (GET_CODE (x) == LABEL_REF)\n+\treturn true;\n+\n+      /* Fall through.  */\n+\n+    case SYMBOL_SMALL_DATA:\n       /* Make sure that the offset refers to something within the\n \t underlying object.  This should guarantee that the final\n \t PC- or GP-relative offset is within the 16-bit limit.  */\n@@ -1012,7 +997,7 @@ mips_symbolic_address_p (enum mips_symbol_type symbol_type,\n       return true;\n \n     case SYMBOL_CONSTANT_POOL:\n-      /* PC-relative addressing is only available for lw, sw, ld and sd.  */\n+      /* PC-relative addressing is only available for lw and ld.  */\n       return GET_MODE_SIZE (mode) == 4 || GET_MODE_SIZE (mode) == 8;\n \n     case SYMBOL_GOT_LOCAL:\n@@ -2125,55 +2110,6 @@ m16_nsimm8_8 (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return m16_check_op (op, (- 0x7f) << 3, 0x80 << 3, 7);\n }\n-\n-/* References to the string table on the mips16 only use a small\n-   offset if the function is small.  We can't check for LABEL_REF here,\n-   because the offset is always large if the label is before the\n-   referencing instruction.  */\n-\n-int\n-m16_usym8_4 (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  if (GET_CODE (op) == SYMBOL_REF\n-      && SYMBOL_REF_FLAG (op)\n-      && cfun->machine->insns_len > 0\n-      && (cfun->machine->insns_len + get_pool_size () + mips_string_length\n-\t  < 4 * 0x100))\n-    {\n-      struct string_constant *l;\n-\n-      /* Make sure this symbol is on thelist of string constants to be\n-         output for this function.  It is possible that it has already\n-         been output, in which case this requires a large offset.  */\n-      for (l = string_constants; l != NULL; l = l->next)\n-\tif (strcmp (l->label, XSTR (op, 0)) == 0)\n-\t  return 1;\n-    }\n-\n-  return 0;\n-}\n-\n-int\n-m16_usym5_4 (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  if (GET_CODE (op) == SYMBOL_REF\n-      && SYMBOL_REF_FLAG (op)\n-      && cfun->machine->insns_len > 0\n-      && (cfun->machine->insns_len + get_pool_size () + mips_string_length\n-\t  < 4 * 0x20))\n-    {\n-      struct string_constant *l;\n-\n-      /* Make sure this symbol is on thelist of string constants to be\n-         output for this function.  It is possible that it has already\n-         been output, in which case this requires a large offset.  */\n-      for (l = string_constants; l != NULL; l = l->next)\n-\tif (strcmp (l->label, XSTR (op, 0)) == 0)\n-\t  return 1;\n-    }\n-\n-  return 0;\n-}\n \f\n static bool\n mips_rtx_costs (rtx x, int code, int outer_code, int *total)\n@@ -6887,8 +6823,6 @@ static void\n mips_output_function_epilogue (FILE *file ATTRIBUTE_UNUSED,\n \t\t\t       HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n {\n-  rtx string;\n-\n   /* Reinstate the normal $gp.  */\n   REGNO (pic_offset_table_rtx) = GLOBAL_POINTER_REGNUM;\n   mips_output_cplocal ();\n@@ -6913,26 +6847,6 @@ mips_output_function_epilogue (FILE *file ATTRIBUTE_UNUSED,\n       assemble_name (file, fnname);\n       fputs (\"\\n\", file);\n     }\n-\n-  while (string_constants != NULL)\n-    {\n-      struct string_constant *next;\n-\n-      next = string_constants->next;\n-      free (string_constants);\n-      string_constants = next;\n-    }\n-\n-  /* If any following function uses the same strings as this one, force\n-     them to refer those strings indirectly.  Nearby functions could\n-     refer them using pc-relative addressing, but it isn't safe in\n-     general.  For instance, some functions may be placed in sections\n-     other than .text, and we don't know whether they be close enough\n-     to this one.  In large files, even other .text functions can be\n-     too far away.  */\n-  for (string = mips16_strings; string != 0; string = XEXP (string, 1))\n-    SYMBOL_REF_FLAG (XEXP (string, 0)) = 0;\n-  free_EXPR_LIST_list (&mips16_strings);\n }\n \f\n /* Emit instructions to restore register REG from slot MEM.  */\n@@ -7218,6 +7132,8 @@ mips_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n   insn = get_insns ();\n   insn_locators_initialize ();\n   split_all_insns_noflow ();\n+  if (TARGET_MIPS16)\n+    mips16_lay_out_constants ();\n   shorten_branches (insn);\n   final_start_function (insn, file, 1);\n   final (insn, file, 1, 0);\n@@ -7298,12 +7214,9 @@ static void\n mips_select_section (tree decl, int reloc,\n \t\t     unsigned HOST_WIDE_INT align ATTRIBUTE_UNUSED)\n {\n-  if ((TARGET_EMBEDDED_PIC || TARGET_MIPS16)\n-      && TREE_CODE (decl) == STRING_CST)\n+  if (TARGET_EMBEDDED_PIC && TREE_CODE (decl) == STRING_CST)\n     /* For embedded position independent code, put constant strings in the\n-       text section, because the data section is limited to 64K in size.\n-       For mips16 code, put strings in the text section so that a PC\n-       relative load instruction can be used to get their address.  */\n+       text section, because the data section is limited to 64K in size.  */\n     text_section ();\n   else if (targetm.have_named_sections)\n     default_elf_select_section (decl, reloc, align);\n@@ -7362,13 +7275,7 @@ mips_in_small_data_p (tree decl)\n \n \n /* When generating embedded PIC code, SYMBOL_REF_FLAG is set for\n-   symbols which are not in the .text section.\n-\n-   When generating mips16 code, SYMBOL_REF_FLAG is set for string\n-   constants which are put in the .text section.  We also record the\n-   total length of all such strings; this total is used to decide\n-   whether we need to split the constant table, and need not be\n-   precisely correct.  */\n+   symbols which are not in the .text section.  */\n \n static void\n mips_encode_section_info (tree decl, rtx rtl, int first)\n@@ -7383,29 +7290,6 @@ mips_encode_section_info (tree decl, rtx rtl, int first)\n   if (GET_CODE (symbol) != SYMBOL_REF)\n     return;\n \n-  if (TARGET_MIPS16)\n-    {\n-      if (first && TREE_CODE (decl) == STRING_CST\n-          /* If this string is from a function, and the function will\n-             go in a gnu linkonce section, then we can't directly\n-             access the string.  This gets an assembler error\n-             \"unsupported PC relative reference to different section\".\n-             If we modify SELECT_SECTION to put it in function_section\n-             instead of text_section, it still fails because\n-             DECL_SECTION_NAME isn't set until assemble_start_function.\n-             If we fix that, it still fails because strings are shared\n-             among multiple functions, and we have cross section\n-             references again.  We force it to work by putting string\n-             addresses in the constant pool and indirecting.  */\n-          && (! current_function_decl\n-              || ! DECL_ONE_ONLY (current_function_decl)))\n-        {\n-          mips16_strings = alloc_EXPR_LIST (0, symbol, mips16_strings);\n-          SYMBOL_REF_FLAG (symbol) = 1;\n-          mips_string_length += TREE_STRING_LENGTH (decl);\n-        }\n-    }\n-\n   if (TARGET_EMBEDDED_PIC)\n     {\n       if (TREE_CODE (decl) == VAR_DECL)\n@@ -8319,329 +8203,236 @@ build_mips16_call_stub (rtx retval, rtx fn, rtx arg_size, int fp_code)\n   return 0;\n }\n \n-/* We keep a list of constants we which we have to add to internal\n-   constant tables in the middle of large functions.  */\n+/* An entry in the mips16 constant pool.  VALUE is the pool constant,\n+   MODE is its mode, and LABEL is the CODE_LABEL associated with it.  */\n \n-struct constant\n-{\n-  struct constant *next;\n+struct mips16_constant {\n+  struct mips16_constant *next;\n   rtx value;\n   rtx label;\n   enum machine_mode mode;\n };\n \n-/* Add a constant to the list in *PCONSTANTS.  */\n+/* Information about an incomplete mips16 constant pool.  FIRST is the\n+   first constant, HIGHEST_ADDRESS is the highest address that the first\n+   byte of the pool can have, and INSN_ADDRESS is the current instruction\n+   address.  */\n+\n+struct mips16_constant_pool {\n+  struct mips16_constant *first;\n+  int highest_address;\n+  int insn_address;\n+};\n+\n+/* Add constant VALUE to POOL and return its label.  MODE is the\n+   value's mode (used for CONST_INTs, etc.).  */\n \n static rtx\n-add_constant (struct constant **pconstants, rtx val, enum machine_mode mode)\n+add_constant (struct mips16_constant_pool *pool,\n+\t      rtx value, enum machine_mode mode)\n {\n-  struct constant *c;\n+  struct mips16_constant **p, *c;\n+  bool first_of_size_p;\n \n-  for (c = *pconstants; c != NULL; c = c->next)\n-    if (mode == c->mode && rtx_equal_p (val, c->value))\n-      return c->label;\n+  /* See whether the constant is already in the pool.  If so, return the\n+     existing label, otherwise leave P pointing to the place where the\n+     constant should be added.\n \n-  c = (struct constant *) xmalloc (sizeof *c);\n-  c->value = val;\n+     Keep the pool sorted in increasing order of mode size so that we can\n+     reduce the number of alignments needed.  */\n+  first_of_size_p = true;\n+  for (p = &pool->first; *p != 0; p = &(*p)->next)\n+    {\n+      if (mode == (*p)->mode && rtx_equal_p (value, (*p)->value))\n+\treturn (*p)->label;\n+      if (GET_MODE_SIZE (mode) < GET_MODE_SIZE ((*p)->mode))\n+\tbreak;\n+      if (GET_MODE_SIZE (mode) == GET_MODE_SIZE ((*p)->mode))\n+\tfirst_of_size_p = false;\n+    }\n+\n+  /* In the worst case, the constant needed by the earliest instruction\n+     will end up at the end of the pool.  The entire pool must then be\n+     accessible from that instruction.\n+\n+     When adding the first constant, set the pool's highest address to\n+     the address of the first out-of-range byte.  Adjust this address\n+     downwards each time a new constant is added.  */\n+  if (pool->first == 0)\n+    /* For pc-relative lw, addiu and daddiu instructions, the base PC value\n+       is the address of the instruction with the lowest two bits clear.\n+       The base PC value for ld has the lowest three bits clear.  Assume\n+       the worst case here.  */\n+    pool->highest_address = pool->insn_address - (UNITS_PER_WORD - 2) + 0x8000;\n+  pool->highest_address -= GET_MODE_SIZE (mode);\n+  if (first_of_size_p)\n+    /* Take into account the worst possible padding due to alignment.  */\n+    pool->highest_address -= GET_MODE_SIZE (mode) - 1;\n+\n+  /* Create a new entry.  */\n+  c = (struct mips16_constant *) xmalloc (sizeof *c);\n+  c->value = value;\n   c->mode = mode;\n   c->label = gen_label_rtx ();\n-  c->next = *pconstants;\n-  *pconstants = c;\n+  c->next = *p;\n+  *p = c;\n+\n   return c->label;\n }\n \n+/* Output constant VALUE after instruction INSN and return the last\n+   instruction emitted.  MODE is the mode of the constant.  */\n+\n+static rtx\n+dump_constants_1 (enum machine_mode mode, rtx value, rtx insn)\n+{\n+  switch (GET_MODE_CLASS (mode))\n+    {\n+    case MODE_INT:\n+      {\n+\trtx size = GEN_INT (GET_MODE_SIZE (mode));\n+\treturn emit_insn_after (gen_consttable_int (value, size), insn);\n+      }\n+\n+    case MODE_FLOAT:\n+      return emit_insn_after (gen_consttable_float (value), insn);\n+\n+    case MODE_VECTOR_FLOAT:\n+    case MODE_VECTOR_INT:\n+      {\n+\tint i;\n+\tfor (i = 0; i < CONST_VECTOR_NUNITS (value); i++)\n+\t  insn = dump_constants_1 (GET_MODE_INNER (mode),\n+\t\t\t\t   CONST_VECTOR_ELT (value, i), insn);\n+\treturn insn;\n+      }\n+\n+    default:\n+      abort ();\n+    }\n+}\n+\n+\n /* Dump out the constants in CONSTANTS after INSN.  */\n \n static void\n-dump_constants (struct constant *constants, rtx insn)\n+dump_constants (struct mips16_constant *constants, rtx insn)\n {\n-  struct constant *c;\n+  struct mips16_constant *c, *next;\n   int align;\n \n-  c = constants;\n   align = 0;\n-  while (c != NULL)\n+  for (c = constants; c != NULL; c = next)\n     {\n-      rtx r;\n-      struct constant *next;\n-\n-      switch (GET_MODE_SIZE (c->mode))\n+      /* If necessary, increase the alignment of PC.  */\n+      if (align < GET_MODE_SIZE (c->mode))\n \t{\n-\tcase 1:\n-\t  align = 0;\n-\t  break;\n-\tcase 2:\n-\t  if (align < 1)\n-\t    insn = emit_insn_after (gen_align_2 (), insn);\n-\t  align = 1;\n-\t  break;\n-\tcase 4:\n-\t  if (align < 2)\n-\t    insn = emit_insn_after (gen_align_4 (), insn);\n-\t  align = 2;\n-\t  break;\n-\tdefault:\n-\t  if (align < 3)\n-\t    insn = emit_insn_after (gen_align_8 (), insn);\n-\t  align = 3;\n-\t  break;\n+\t  int align_log = floor_log2 (GET_MODE_SIZE (c->mode));\n+\t  insn = emit_insn_after (gen_align (GEN_INT (align_log)), insn);\n \t}\n+      align = GET_MODE_SIZE (c->mode);\n \n       insn = emit_label_after (c->label, insn);\n-\n-      switch (c->mode)\n-\t{\n-\tcase QImode:\n-\t  r = gen_consttable_qi (c->value);\n-\t  break;\n-\tcase HImode:\n-\t  r = gen_consttable_hi (c->value);\n-\t  break;\n-\tcase SImode:\n-\t  r = gen_consttable_si (c->value);\n-\t  break;\n-\tcase SFmode:\n-\t  r = gen_consttable_sf (c->value);\n-\t  break;\n-\tcase DImode:\n-\t  r = gen_consttable_di (c->value);\n-\t  break;\n-\tcase DFmode:\n-\t  r = gen_consttable_df (c->value);\n-\t  break;\n-\tdefault:\n-\t  abort ();\n-\t}\n-\n-      insn = emit_insn_after (r, insn);\n+      insn = dump_constants_1 (c->mode, c->value, insn);\n \n       next = c->next;\n       free (c);\n-      c = next;\n     }\n \n   emit_barrier_after (insn);\n }\n \n-/* Find the symbol in an address expression.  */\n+/* Return the length of instruction INSN.\n \n-static rtx\n-mips_find_symbol (rtx addr)\n+   ??? MIPS16 switch tables go in .text, but we don't define\n+   JUMP_TABLES_IN_TEXT_SECTION, so get_attr_length will not\n+   compute their lengths correctly.  */\n+\n+static int\n+mips16_insn_length (rtx insn)\n {\n-  if (GET_CODE (addr) == MEM)\n-    addr = XEXP (addr, 0);\n-  while (GET_CODE (addr) == CONST)\n-    addr = XEXP (addr, 0);\n-  if (GET_CODE (addr) == SYMBOL_REF || GET_CODE (addr) == LABEL_REF)\n-    return addr;\n-  if (GET_CODE (addr) == PLUS)\n+  if (GET_CODE (insn) == JUMP_INSN)\n     {\n-      rtx l1, l2;\n-\n-      l1 = mips_find_symbol (XEXP (addr, 0));\n-      l2 = mips_find_symbol (XEXP (addr, 1));\n-      if (l1 != NULL_RTX && l2 == NULL_RTX)\n-\treturn l1;\n-      else if (l1 == NULL_RTX && l2 != NULL_RTX)\n-\treturn l2;\n+      rtx body = PATTERN (insn);\n+      if (GET_CODE (body) == ADDR_VEC)\n+\treturn GET_MODE_SIZE (GET_MODE (body)) * XVECLEN (body, 0);\n+      if (GET_CODE (body) == ADDR_DIFF_VEC)\n+\treturn GET_MODE_SIZE (GET_MODE (body)) * XVECLEN (body, 1);\n     }\n-  return NULL_RTX;\n+  return get_attr_length (insn);\n }\n \n-/* In mips16 mode, we need to look through the function to check for\n-   PC relative loads that are out of range.  */\n+/* Rewrite *X so that constant pool references refer to the constant's\n+   label instead.  DATA points to the constant pool structure.  */\n \n-static void\n-mips16_lay_out_constants (void)\n+static int\n+mips16_rewrite_pool_refs (rtx *x, void *data)\n {\n-  int insns_len, max_internal_pool_size, pool_size, addr, first_constant_ref;\n-  rtx first, insn;\n-  struct constant *constants;\n+  struct mips16_constant_pool *pool = data;\n+  if (GET_CODE (*x) == SYMBOL_REF && CONSTANT_POOL_ADDRESS_P (*x))\n+    *x = gen_rtx_LABEL_REF (Pmode, add_constant (pool,\n+\t\t\t\t\t\t get_pool_constant (*x),\n+\t\t\t\t\t\t get_pool_mode (*x)));\n+  return 0;\n+}\n \n-  first = get_insns ();\n+/* Build MIPS16 constant pools.  */\n \n-  /* Scan the function looking for PC relative loads which may be out\n-     of range.  All such loads will either be from the constant table,\n-     or be getting the address of a constant string.  If the size of\n-     the function plus the size of the constant table is less than\n-     0x8000, then all loads are in range.  */\n+static void\n+mips16_lay_out_constants (void)\n+{\n+  struct mips16_constant_pool pool;\n+  rtx insn, barrier;\n \n-  insns_len = 0;\n-  for (insn = first; insn; insn = NEXT_INSN (insn))\n+  barrier = 0;\n+  memset (&pool, 0, sizeof (pool));\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     {\n-      insns_len += get_attr_length (insn);\n-\n-      /* ??? We put switch tables in .text, but we don't define\n-         JUMP_TABLES_IN_TEXT_SECTION, so get_attr_length will not\n-         compute their lengths correctly.  */\n-      if (GET_CODE (insn) == JUMP_INSN)\n-\t{\n-\t  rtx body;\n-\n-\t  body = PATTERN (insn);\n-\t  if (GET_CODE (body) == ADDR_VEC || GET_CODE (body) == ADDR_DIFF_VEC)\n-\t    insns_len += (XVECLEN (body, GET_CODE (body) == ADDR_DIFF_VEC)\n-\t\t\t  * GET_MODE_SIZE (GET_MODE (body)));\n-\t  insns_len += GET_MODE_SIZE (GET_MODE (body)) - 1;\n-\t}\n-    }\n-\n-  /* Store the original value of insns_len in cfun->machine, so\n-     that m16_usym8_4 and m16_usym5_4 can look at it.  */\n-  cfun->machine->insns_len = insns_len;\n+      /* Rewrite constant pool references in INSN.  */\n+      if (INSN_P (insn))\n+\tfor_each_rtx (&PATTERN (insn), mips16_rewrite_pool_refs, &pool);\n \n-  pool_size = get_pool_size ();\n-  if (insns_len + pool_size + mips_string_length < 0x8000)\n-    return;\n+      pool.insn_address += mips16_insn_length (insn);\n \n-  /* Loop over the insns and figure out what the maximum internal pool\n-     size could be.  */\n-  max_internal_pool_size = 0;\n-  for (insn = first; insn; insn = NEXT_INSN (insn))\n-    {\n-      if (GET_CODE (insn) == INSN\n-\t  && GET_CODE (PATTERN (insn)) == SET)\n+      if (pool.first != NULL)\n \t{\n-\t  rtx src;\n-\n-\t  src = mips_find_symbol (SET_SRC (PATTERN (insn)));\n-\t  if (src == NULL_RTX)\n-\t    continue;\n-\t  if (CONSTANT_POOL_ADDRESS_P (src))\n-\t    max_internal_pool_size += GET_MODE_SIZE (get_pool_mode (src));\n-\t  else if (SYMBOL_REF_FLAG (src))\n-\t    max_internal_pool_size += GET_MODE_SIZE (Pmode);\n-\t}\n-    }\n+\t  /* If there are no natural barriers between the first user of\n+\t     the pool and the highest acceptable address, we'll need to\n+\t     create a new instruction to jump around the constant pool.\n+\t     In the worst case, this instruction will be 4 bytes long.\n+\n+\t     If it's too late to do this transformation after INSN,\n+\t     do it immediately before INSN.  */\n+\t  if (barrier == 0 && pool.insn_address + 4 > pool.highest_address)\n+\t    {\n+\t      rtx label, jump;\n \n-  constants = NULL;\n-  addr = 0;\n-  first_constant_ref = -1;\n+\t      label = gen_label_rtx ();\n \n-  for (insn = first; insn; insn = NEXT_INSN (insn))\n-    {\n-      if (GET_CODE (insn) == INSN\n-\t  && GET_CODE (PATTERN (insn)) == SET)\n-\t{\n-\t  rtx val, src;\n-\t  enum machine_mode mode = VOIDmode;\n+\t      jump = emit_jump_insn_before (gen_jump (label), insn);\n+\t      JUMP_LABEL (jump) = label;\n+\t      LABEL_NUSES (label) = 1;\n+\t      barrier = emit_barrier_after (jump);\n \n-\t  val = NULL_RTX;\n-\t  src = mips_find_symbol (SET_SRC (PATTERN (insn)));\n-\t  if (src != NULL_RTX && CONSTANT_POOL_ADDRESS_P (src))\n-\t    {\n-\t      /* ??? This is very conservative, which means that we\n-                 will generate too many copies of the constant table.\n-                 The only solution would seem to be some form of\n-                 relaxing.  */\n-\t      if (((insns_len - addr)\n-\t\t   + max_internal_pool_size\n-\t\t   + get_pool_offset (src))\n-\t\t  >= 0x8000)\n-\t\t{\n-\t\t  val = get_pool_constant (src);\n-\t\t  mode = get_pool_mode (src);\n-\t\t}\n-\t      max_internal_pool_size -= GET_MODE_SIZE (get_pool_mode (src));\n-\t    }\n-\t  else if (src != NULL_RTX && SYMBOL_REF_FLAG (src))\n-\t    {\n-\t      /* Including all of mips_string_length is conservative,\n-                 and so is including all of max_internal_pool_size.  */\n-\t      if (((insns_len - addr)\n-\t\t   + max_internal_pool_size\n-\t\t   + pool_size\n-\t\t   + mips_string_length)\n-\t\t  >= 0x8000)\n-\t\t{\n-\t\t  val = src;\n-\t\t  mode = Pmode;\n-\t\t}\n-\t      max_internal_pool_size -= Pmode;\n+\t      emit_label_after (label, barrier);\n+\t      pool.insn_address += 4;\n \t    }\n \n-\t  if (val != NULL_RTX)\n+\t  /* See whether the constant pool is now out of range of the first\n+\t     user.  If so, output the constants after the previous barrier.\n+\t     Note that any instructions between BARRIER and INSN (inclusive)\n+\t     will use negative offsets to refer to the pool.  */\n+\t  if (pool.insn_address > pool.highest_address)\n \t    {\n-\t      rtx lab, newsrc;\n-\n-\t      /* This PC relative load is out of range.  ??? In the\n-\t\t case of a string constant, we are only guessing that\n-\t\t it is range, since we don't know the offset of a\n-\t\t particular string constant.  */\n-\n-\t      lab = add_constant (&constants, val, mode);\n-\t      newsrc = gen_rtx_MEM (mode,\n-\t\t\t\t    gen_rtx_LABEL_REF (VOIDmode, lab));\n-\t      RTX_UNCHANGING_P (newsrc) = 1;\n-\t      PATTERN (insn) = gen_rtx_SET (VOIDmode,\n-\t\t\t\t\t    SET_DEST (PATTERN (insn)),\n-\t\t\t\t\t    newsrc);\n-\t      INSN_CODE (insn) = -1;\n-\n-\t      if (first_constant_ref < 0)\n-\t\tfirst_constant_ref = addr;\n+\t      dump_constants (pool.first, barrier);\n+\t      pool.first = NULL;\n+\t      barrier = 0;\n \t    }\n+\t  else if (BARRIER_P (insn))\n+\t    barrier = insn;\n \t}\n-\n-      addr += get_attr_length (insn);\n-\n-      /* ??? We put switch tables in .text, but we don't define\n-         JUMP_TABLES_IN_TEXT_SECTION, so get_attr_length will not\n-         compute their lengths correctly.  */\n-      if (GET_CODE (insn) == JUMP_INSN)\n-\t{\n-\t  rtx body;\n-\n-\t  body = PATTERN (insn);\n-\t  if (GET_CODE (body) == ADDR_VEC || GET_CODE (body) == ADDR_DIFF_VEC)\n-\t    addr += (XVECLEN (body, GET_CODE (body) == ADDR_DIFF_VEC)\n-\t\t\t  * GET_MODE_SIZE (GET_MODE (body)));\n-\t  addr += GET_MODE_SIZE (GET_MODE (body)) - 1;\n-\t}\n-\n-      if (GET_CODE (insn) == BARRIER)\n-\t{\n-\t  /* Output any constants we have accumulated.  Note that we\n-             don't need to change ADDR, since its only use is\n-             subtraction from INSNS_LEN, and both would be changed by\n-             the same amount.\n-\t     ??? If the instructions up to the next barrier reuse a\n-\t     constant, it would often be better to continue\n-\t     accumulating.  */\n-\t  if (constants != NULL)\n-\t    dump_constants (constants, insn);\n-\t  constants = NULL;\n-\t  first_constant_ref = -1;\n-\t}\n-\n-      if (constants != NULL\n-\t       && (NEXT_INSN (insn) == NULL\n-\t\t   || (first_constant_ref >= 0\n-\t\t       && (((addr - first_constant_ref)\n-\t\t\t    + 2 /* for alignment */\n-\t\t\t    + 2 /* for a short jump insn */\n-\t\t\t    + pool_size)\n-\t\t\t   >= 0x8000))))\n-\t{\n-\t  /* If we haven't had a barrier within 0x8000 bytes of a\n-             constant reference or we are at the end of the function,\n-             emit a barrier now.  */\n-\n-\t  rtx label, jump, barrier;\n-\n-\t  label = gen_label_rtx ();\n-\t  jump = emit_jump_insn_after (gen_jump (label), insn);\n-\t  JUMP_LABEL (jump) = label;\n-\t  LABEL_NUSES (label) = 1;\n-\t  barrier = emit_barrier_after (jump);\n-\t  emit_label_after (label, barrier);\n-\t  first_constant_ref = -1;\n-\t}\n-     }\n-\n-  /* ??? If we output all references to a constant in internal\n-     constants table, we don't need to output the constant in the real\n-     constant table, but we have no way to prevent that.  */\n+    }\n+  dump_constants (pool.first, get_last_insn ());\n }\n \n "}, {"sha": "26775d4fbba1aa838c92740e6f85c9e51caec359", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76cbf5bf52c4c0301f93b592df0bd29f22ed34ef/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76cbf5bf52c4c0301f93b592df0bd29f22ed34ef/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=76cbf5bf52c4c0301f93b592df0bd29f22ed34ef", "patch": "@@ -117,13 +117,11 @@ extern enum processor_type mips_tune;   /* which cpu to schedule for */\n extern int mips_isa;\t\t\t/* architectural level */\n extern int mips_abi;\t\t\t/* which ABI to use */\n extern int mips16_hard_float;\t\t/* mips16 without -msoft-float */\n-extern int mips_entry;\t\t\t/* generate entry/exit for mips16 */\n extern const char *mips_arch_string;    /* for -march=<xxx> */\n extern const char *mips_tune_string;    /* for -mtune=<xxx> */\n extern const char *mips_isa_string;\t/* for -mips{1,2,3,4} */\n extern const char *mips_abi_string;\t/* for -mabi={32,n32,64} */\n extern const char *mips_cache_flush_func;/* for -mflush-func= and -mno-flush-func */\n-extern int mips_string_length;\t\t/* length of strings for mips16 */\n extern const struct mips_cpu_info mips_cpu_info_table[];\n extern const struct mips_cpu_info *mips_arch_info;\n extern const struct mips_cpu_info *mips_tune_info;\n@@ -2574,14 +2572,6 @@ typedef struct mips_args {\n \t\t XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0));\t\\\n   else\t\t\t\t\t\t\t\t\t\\\n     asm_fprintf ((FILE), \"%U%s\", (NAME))\n-\n-/* The mips16 wants the constant pool to be after the function,\n-   because the PC relative load instructions use unsigned offsets.  */\n-\n-#define CONSTANT_POOL_BEFORE_FUNCTION (! TARGET_MIPS16)\n-\n-#define ASM_OUTPUT_POOL_EPILOGUE(FILE, FNNAME, FNDECL, SIZE)\t\\\n-  mips_string_length = 0;\n \f\n /* Specify the machine mode that this machine uses\n    for the index in the tablejump instruction."}, {"sha": "84efc359e16161306e02db96a717d568e02fab7e", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 22, "deletions": 99, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76cbf5bf52c4c0301f93b592df0bd29f22ed34ef/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76cbf5bf52c4c0301f93b592df0bd29f22ed34ef/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=76cbf5bf52c4c0301f93b592df0bd29f22ed34ef", "patch": "@@ -35,15 +35,9 @@\n    (UNSPEC_CPRESTORE\t\t 5)\n    (UNSPEC_EH_RECEIVER\t\t 6)\n    (UNSPEC_EH_RETURN\t\t 7)\n-   (UNSPEC_CONSTTABLE_QI\t 8)\n-   (UNSPEC_CONSTTABLE_HI\t 9)\n-   (UNSPEC_CONSTTABLE_SI\t10)\n-   (UNSPEC_CONSTTABLE_DI\t11)\n-   (UNSPEC_CONSTTABLE_SF\t12)\n-   (UNSPEC_CONSTTABLE_DF\t13)\n-   (UNSPEC_ALIGN_2\t\t14)\n-   (UNSPEC_ALIGN_4\t\t15)\n-   (UNSPEC_ALIGN_8\t\t16)\n+   (UNSPEC_CONSTTABLE_INT\t 8)\n+   (UNSPEC_CONSTTABLE_FLOAT\t 9)\n+   (UNSPEC_ALIGN\t\t14)\n    (UNSPEC_HIGH\t\t\t17)\n    (UNSPEC_LWL\t\t\t18)\n    (UNSPEC_LWR\t\t\t19)\n@@ -9147,111 +9141,40 @@ ld\\\\t%2,%1-%S1(%2)\\;daddu\\\\t%2,%2,$31\\\\n\\\\t%*j\\\\t%2%/\"\n ;;  ....................\n ;;\n \n-(define_insn \"consttable_qi\"\n-  [(unspec_volatile [(match_operand:QI 0 \"consttable_operand\" \"=g\")]\n-\t\t    UNSPEC_CONSTTABLE_QI)]\n+(define_insn \"consttable_int\"\n+  [(unspec_volatile [(match_operand 0 \"consttable_operand\" \"\")\n+\t\t     (match_operand 1 \"const_int_operand\" \"\")]\n+\t\t    UNSPEC_CONSTTABLE_INT)]\n   \"TARGET_MIPS16\"\n {\n-  assemble_integer (operands[0], 1, BITS_PER_UNIT, 1);\n+  assemble_integer (operands[0], INTVAL (operands[1]),\n+\t\t    BITS_PER_UNIT * INTVAL (operands[1]), 1);\n   return \"\";\n }\n-  [(set_attr \"type\"\t\"unknown\")\n-   (set_attr \"mode\"\t\"QI\")\n-   (set_attr \"length\"\t\"8\")])\n-\n-(define_insn \"consttable_hi\"\n-  [(unspec_volatile [(match_operand:HI 0 \"consttable_operand\" \"=g\")]\n-\t\t    UNSPEC_CONSTTABLE_HI)]\n-  \"TARGET_MIPS16\"\n-{\n-  assemble_integer (operands[0], 2, BITS_PER_UNIT * 2, 1);\n-  return \"\";\n-}\n-  [(set_attr \"type\"\t\"unknown\")\n-   (set_attr \"mode\"\t\"HI\")\n-   (set_attr \"length\"\t\"8\")])\n-\n-(define_insn \"consttable_si\"\n-  [(unspec_volatile [(match_operand:SI 0 \"consttable_operand\" \"=g\")]\n-\t\t    UNSPEC_CONSTTABLE_SI)]\n-  \"TARGET_MIPS16\"\n-{\n-  assemble_integer (operands[0], 4, BITS_PER_UNIT * 4, 1);\n-  return \"\";\n-}\n-  [(set_attr \"type\"\t\"unknown\")\n-   (set_attr \"mode\"\t\"SI\")\n-   (set_attr \"length\"\t\"8\")])\n-\n-(define_insn \"consttable_di\"\n-  [(unspec_volatile [(match_operand:DI 0 \"consttable_operand\" \"=g\")]\n-\t\t    UNSPEC_CONSTTABLE_DI)]\n-  \"TARGET_MIPS16\"\n-{\n-  assemble_integer (operands[0], 8, BITS_PER_UNIT * 8, 1);\n-  return \"\";\n-}\n-  [(set_attr \"type\"\t\"unknown\")\n-   (set_attr \"mode\"\t\"DI\")\n-   (set_attr \"length\"\t\"16\")])\n-\n-(define_insn \"consttable_sf\"\n-  [(unspec_volatile [(match_operand:SF 0 \"consttable_operand\" \"=g\")]\n-\t\t    UNSPEC_CONSTTABLE_SF)]\n-  \"TARGET_MIPS16\"\n-{\n-  REAL_VALUE_TYPE d;\n+  [(set (attr \"length\") (symbol_ref \"INTVAL (operands[1])\"))])\n \n-  if (GET_CODE (operands[0]) != CONST_DOUBLE)\n-    abort ();\n-  REAL_VALUE_FROM_CONST_DOUBLE (d, operands[0]);\n-  assemble_real (d, SFmode, GET_MODE_ALIGNMENT (SFmode));\n-  return \"\";\n-}\n-  [(set_attr \"type\"\t\"unknown\")\n-   (set_attr \"mode\"\t\"SF\")\n-   (set_attr \"length\"\t\"8\")])\n-\n-(define_insn \"consttable_df\"\n-  [(unspec_volatile [(match_operand:DF 0 \"consttable_operand\" \"=g\")]\n-\t\t    UNSPEC_CONSTTABLE_DF)]\n+(define_insn \"consttable_float\"\n+  [(unspec_volatile [(match_operand 0 \"consttable_operand\" \"\")]\n+\t\t    UNSPEC_CONSTTABLE_FLOAT)]\n   \"TARGET_MIPS16\"\n {\n   REAL_VALUE_TYPE d;\n \n   if (GET_CODE (operands[0]) != CONST_DOUBLE)\n     abort ();\n   REAL_VALUE_FROM_CONST_DOUBLE (d, operands[0]);\n-  assemble_real (d, DFmode, GET_MODE_ALIGNMENT (DFmode));\n+  assemble_real (d, GET_MODE (operands[0]),\n+\t\t GET_MODE_BITSIZE (GET_MODE (operands[0])));\n   return \"\";\n }\n-  [(set_attr \"type\"\t\"unknown\")\n-   (set_attr \"mode\"\t\"DF\")\n-   (set_attr \"length\"\t\"16\")])\n+  [(set (attr \"length\")\n+\t(symbol_ref \"GET_MODE_SIZE (GET_MODE (operands[0]))\"))])\n \n-(define_insn \"align_2\"\n-  [(unspec_volatile [(const_int 0)] UNSPEC_ALIGN_2)]\n-  \"TARGET_MIPS16\"\n-  \".align 1\"\n-  [(set_attr \"type\"\t\"unknown\")\n-   (set_attr \"mode\"\t\"HI\")\n-   (set_attr \"length\"\t\"8\")])\n-\n-(define_insn \"align_4\"\n-  [(unspec_volatile [(const_int 0)] UNSPEC_ALIGN_4)]\n-  \"TARGET_MIPS16\"\n-  \".align 2\"\n-  [(set_attr \"type\"\t\"unknown\")\n-   (set_attr \"mode\"\t\"SI\")\n-   (set_attr \"length\"\t\"8\")])\n-\n-(define_insn \"align_8\"\n-  [(unspec_volatile [(const_int 0)] UNSPEC_ALIGN_8)]\n-  \"TARGET_MIPS16\"\n-  \".align 3\"\n-  [(set_attr \"type\"\t\"unknown\")\n-   (set_attr \"mode\"\t\"DI\")\n-   (set_attr \"length\"\t\"12\")])\n+(define_insn \"align\"\n+  [(unspec_volatile [(match_operand 0 \"const_int_operand\" \"\")] UNSPEC_ALIGN)]\n+  \"\"\n+  \".align\\t%0\"\n+  [(set (attr \"length\") (symbol_ref \"(1 << INTVAL (operands[0])) - 1\"))])\n \f\n ;;\n ;;  ...................."}]}