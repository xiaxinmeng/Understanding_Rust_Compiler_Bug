{"sha": "579f368704e340c47957d5fb5aca6ecda6624a69", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTc5ZjM2ODcwNGUzNDBjNDc5NTdkNWZiNWFjYTZlY2RhNjYyNGE2OQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-09-25T12:57:49Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-09-25T12:57:49Z"}, "message": "Update interface to TARGET_VECTORIZE_VEC_PERM_CONST_OK\n\nThis patch makes TARGET_VECTORIZE_VEC_PERM_CONST_OK take the permute\nvector in the form of a vec_perm_indices instead of an unsigned char *.\nIt follows on from the recent patch that did the same in target-independent\ncode.\n\nIt was easy to make ARM and AArch64 use vec_perm_indices internally\nas well, and converting AArch64 helps with SVE.  I did try doing the same\nfor the other ports, but the surgery needed was much more invasive and\nmuch less obviously correct.\n\n2017-09-22  Richard Sandiford  <richard.sandifird@linaro.org>\n\ngcc/\n\t* target.def (vec_perm_const_ok): Change sel parameter to\n\tvec_perm_indices.\n\t* optabs-query.c (can_vec_perm_p): Update accordingly.\n\t* doc/tm.texi: Regenerate.\n\t* config/aarch64/aarch64.c (expand_vec_perm_d): Change perm to\n\tauto_vec_perm_indices and remove separate nelt field.\n\t(aarch64_evpc_trn, aarch64_evpc_uzp, aarch64_evpc_zip)\n\t(aarch64_evpc_ext, aarch64_evpc_rev, aarch64_evpc_dup)\n\t(aarch64_evpc_tbl, aarch64_expand_vec_perm_const_1)\n\t(aarch64_expand_vec_perm_const): Update accordingly.\n\t(aarch64_vectorize_vec_perm_const_ok): Likewise.  Change sel\n\tto vec_perm_indices.\n\t* config/arm/arm.c (expand_vec_perm_d): Change perm to\n\tauto_vec_perm_indices and remove separate nelt field.\n\t(arm_evpc_neon_vuzp, arm_evpc_neon_vzip, arm_evpc_neon_vrev)\n\t(arm_evpc_neon_vtrn, arm_evpc_neon_vext, arm_evpc_neon_vtbl)\n\t(arm_expand_vec_perm_const_1, arm_expand_vec_perm_const): Update\n\taccordingly.\n\t(arm_vectorize_vec_perm_const_ok): Likewise.  Change sel\n\tto vec_perm_indices.\n\t* config/i386/i386.c (ix86_vectorize_vec_perm_const_ok): Change\n\tsel to vec_perm_indices.\n\t* config/ia64/ia64.c (ia64_vectorize_vec_perm_const_ok): Likewise.\n\t* config/mips/mips.c (mips_vectorize_vec_perm_const_ok): Likewise.\n\t* config/powerpcspe/powerpcspe.c (rs6000_vectorize_vec_perm_const_ok):\n\tLikewise.\n\t* config/rs6000/rs6000.c (rs6000_vectorize_vec_perm_const_ok):\n\tLikewise.\n\nFrom-SVN: r253148", "tree": {"sha": "98c3c05927d33eaae50459c94801c537ec7abec0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/98c3c05927d33eaae50459c94801c537ec7abec0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/579f368704e340c47957d5fb5aca6ecda6624a69", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/579f368704e340c47957d5fb5aca6ecda6624a69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/579f368704e340c47957d5fb5aca6ecda6624a69", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/579f368704e340c47957d5fb5aca6ecda6624a69/comments", "author": null, "committer": null, "parents": [{"sha": "504e0b5f2c7128a89f869ca984949d063bab52c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/504e0b5f2c7128a89f869ca984949d063bab52c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/504e0b5f2c7128a89f869ca984949d063bab52c4"}], "stats": {"total": 146, "additions": 83, "deletions": 63}, "files": [{"sha": "b6dd97832f67059a37c5a817307c74704b72e81a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579f368704e340c47957d5fb5aca6ecda6624a69/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579f368704e340c47957d5fb5aca6ecda6624a69/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=579f368704e340c47957d5fb5aca6ecda6624a69", "patch": "@@ -1,3 +1,34 @@\n+2017-09-25  Richard Sandiford  <richard.sandifird@linaro.org>\n+\n+\t* target.def (vec_perm_const_ok): Change sel parameter to\n+\tvec_perm_indices.\n+\t* optabs-query.c (can_vec_perm_p): Update accordingly.\n+\t* doc/tm.texi: Regenerate.\n+\t* config/aarch64/aarch64.c (expand_vec_perm_d): Change perm to\n+\tauto_vec_perm_indices and remove separate nelt field.\n+\t(aarch64_evpc_trn, aarch64_evpc_uzp, aarch64_evpc_zip)\n+\t(aarch64_evpc_ext, aarch64_evpc_rev, aarch64_evpc_dup)\n+\t(aarch64_evpc_tbl, aarch64_expand_vec_perm_const_1)\n+\t(aarch64_expand_vec_perm_const): Update accordingly.\n+\t(aarch64_vectorize_vec_perm_const_ok): Likewise.  Change sel\n+\tto vec_perm_indices.\n+\t* config/arm/arm.c (expand_vec_perm_d): Change perm to\n+\tauto_vec_perm_indices and remove separate nelt field.\n+\t(arm_evpc_neon_vuzp, arm_evpc_neon_vzip, arm_evpc_neon_vrev)\n+\t(arm_evpc_neon_vtrn, arm_evpc_neon_vext, arm_evpc_neon_vtbl)\n+\t(arm_expand_vec_perm_const_1, arm_expand_vec_perm_const): Update\n+\taccordingly.\n+\t(arm_vectorize_vec_perm_const_ok): Likewise.  Change sel\n+\tto vec_perm_indices.\n+\t* config/i386/i386.c (ix86_vectorize_vec_perm_const_ok): Change\n+\tsel to vec_perm_indices.\n+\t* config/ia64/ia64.c (ia64_vectorize_vec_perm_const_ok): Likewise.\n+\t* config/mips/mips.c (mips_vectorize_vec_perm_const_ok): Likewise.\n+\t* config/powerpcspe/powerpcspe.c (rs6000_vectorize_vec_perm_const_ok):\n+\tLikewise.\n+\t* config/rs6000/rs6000.c (rs6000_vectorize_vec_perm_const_ok):\n+\tLikewise.\n+\n 2017-09-25  Pierre-Marie de Rodat  <derodat@adacore.com>\n \n \tPR debug/82155"}, {"sha": "f38540b396aaf80d5c022a977977614673ec3725", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 19, "deletions": 21, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579f368704e340c47957d5fb5aca6ecda6624a69/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579f368704e340c47957d5fb5aca6ecda6624a69/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=579f368704e340c47957d5fb5aca6ecda6624a69", "patch": "@@ -141,8 +141,8 @@ static void aarch64_elf_asm_constructor (rtx, int) ATTRIBUTE_UNUSED;\n static void aarch64_elf_asm_destructor (rtx, int) ATTRIBUTE_UNUSED;\n static void aarch64_override_options_after_change (void);\n static bool aarch64_vector_mode_supported_p (machine_mode);\n-static bool aarch64_vectorize_vec_perm_const_ok (machine_mode vmode,\n-\t\t\t\t\t\t const unsigned char *sel);\n+static bool aarch64_vectorize_vec_perm_const_ok (machine_mode,\n+\t\t\t\t\t\t vec_perm_indices);\n static int aarch64_address_cost (rtx, machine_mode, addr_space_t, bool);\n static bool aarch64_builtin_support_vector_misalignment (machine_mode mode,\n \t\t\t\t\t\t\t const_tree type,\n@@ -13146,9 +13146,8 @@ aarch64_split_combinev16qi (rtx operands[3])\n struct expand_vec_perm_d\n {\n   rtx target, op0, op1;\n-  unsigned char perm[MAX_VECT_LEN];\n+  auto_vec_perm_indices perm;\n   machine_mode vmode;\n-  unsigned char nelt;\n   bool one_vector_p;\n   bool testing_p;\n };\n@@ -13231,7 +13230,7 @@ aarch64_expand_vec_perm (rtx target, rtx op0, rtx op1, rtx sel)\n static bool\n aarch64_evpc_trn (struct expand_vec_perm_d *d)\n {\n-  unsigned int i, odd, mask, nelt = d->nelt;\n+  unsigned int i, odd, mask, nelt = d->perm.length ();\n   rtx out, in0, in1, x;\n   rtx (*gen) (rtx, rtx, rtx);\n   machine_mode vmode = d->vmode;\n@@ -13319,7 +13318,7 @@ aarch64_evpc_trn (struct expand_vec_perm_d *d)\n static bool\n aarch64_evpc_uzp (struct expand_vec_perm_d *d)\n {\n-  unsigned int i, odd, mask, nelt = d->nelt;\n+  unsigned int i, odd, mask, nelt = d->perm.length ();\n   rtx out, in0, in1, x;\n   rtx (*gen) (rtx, rtx, rtx);\n   machine_mode vmode = d->vmode;\n@@ -13406,7 +13405,7 @@ aarch64_evpc_uzp (struct expand_vec_perm_d *d)\n static bool\n aarch64_evpc_zip (struct expand_vec_perm_d *d)\n {\n-  unsigned int i, high, mask, nelt = d->nelt;\n+  unsigned int i, high, mask, nelt = d->perm.length ();\n   rtx out, in0, in1, x;\n   rtx (*gen) (rtx, rtx, rtx);\n   machine_mode vmode = d->vmode;\n@@ -13499,7 +13498,7 @@ aarch64_evpc_zip (struct expand_vec_perm_d *d)\n static bool\n aarch64_evpc_ext (struct expand_vec_perm_d *d)\n {\n-  unsigned int i, nelt = d->nelt;\n+  unsigned int i, nelt = d->perm.length ();\n   rtx (*gen) (rtx, rtx, rtx, rtx);\n   rtx offset;\n \n@@ -13563,7 +13562,7 @@ aarch64_evpc_ext (struct expand_vec_perm_d *d)\n static bool\n aarch64_evpc_rev (struct expand_vec_perm_d *d)\n {\n-  unsigned int i, j, diff, nelt = d->nelt;\n+  unsigned int i, j, diff, nelt = d->perm.length ();\n   rtx (*gen) (rtx, rtx);\n \n   if (!d->one_vector_p)\n@@ -13641,7 +13640,7 @@ aarch64_evpc_dup (struct expand_vec_perm_d *d)\n   rtx out = d->target;\n   rtx in0;\n   machine_mode vmode = d->vmode;\n-  unsigned int i, elt, nelt = d->nelt;\n+  unsigned int i, elt, nelt = d->perm.length ();\n   rtx lane;\n \n   elt = d->perm[0];\n@@ -13686,7 +13685,7 @@ aarch64_evpc_tbl (struct expand_vec_perm_d *d)\n {\n   rtx rperm[MAX_VECT_LEN], sel;\n   machine_mode vmode = d->vmode;\n-  unsigned int i, nelt = d->nelt;\n+  unsigned int i, nelt = d->perm.length ();\n \n   if (d->testing_p)\n     return true;\n@@ -13720,12 +13719,11 @@ aarch64_expand_vec_perm_const_1 (struct expand_vec_perm_d *d)\n   /* The pattern matching functions above are written to look for a small\n      number to begin the sequence (0, 1, N/2).  If we begin with an index\n      from the second operand, we can swap the operands.  */\n-  if (d->perm[0] >= d->nelt)\n+  unsigned int nelt = d->perm.length ();\n+  if (d->perm[0] >= nelt)\n     {\n-      unsigned i, nelt = d->nelt;\n-\n       gcc_assert (nelt == (nelt & -nelt));\n-      for (i = 0; i < nelt; ++i)\n+      for (unsigned int i = 0; i < nelt; ++i)\n \td->perm[i] ^= nelt; /* Keep the same index, but in the other vector.  */\n \n       std::swap (d->op0, d->op1);\n@@ -13764,15 +13762,16 @@ aarch64_expand_vec_perm_const (rtx target, rtx op0, rtx op1, rtx sel)\n \n   d.vmode = GET_MODE (target);\n   gcc_assert (VECTOR_MODE_P (d.vmode));\n-  d.nelt = nelt = GET_MODE_NUNITS (d.vmode);\n   d.testing_p = false;\n \n+  nelt = GET_MODE_NUNITS (d.vmode);\n+  d.perm.reserve (nelt);\n   for (i = which = 0; i < nelt; ++i)\n     {\n       rtx e = XVECEXP (sel, 0, i);\n       int ei = INTVAL (e) & (2 * nelt - 1);\n       which |= (ei < nelt ? 1 : 2);\n-      d.perm[i] = ei;\n+      d.perm.quick_push (ei);\n     }\n \n   switch (which)\n@@ -13807,19 +13806,18 @@ aarch64_expand_vec_perm_const (rtx target, rtx op0, rtx op1, rtx sel)\n }\n \n static bool\n-aarch64_vectorize_vec_perm_const_ok (machine_mode vmode,\n-\t\t\t\t     const unsigned char *sel)\n+aarch64_vectorize_vec_perm_const_ok (machine_mode vmode, vec_perm_indices sel)\n {\n   struct expand_vec_perm_d d;\n   unsigned int i, nelt, which;\n   bool ret;\n \n   d.vmode = vmode;\n-  d.nelt = nelt = GET_MODE_NUNITS (d.vmode);\n   d.testing_p = true;\n-  memcpy (d.perm, sel, nelt);\n+  d.perm.safe_splice (sel);\n \n   /* Calculate whether all elements are in one vector.  */\n+  nelt = sel.length ();\n   for (i = which = 0; i < nelt; ++i)\n     {\n       unsigned char e = d.perm[i];"}, {"sha": "3671616cfa7adbaf8d7aa1e0ee582a881bf3c0ea", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579f368704e340c47957d5fb5aca6ecda6624a69/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579f368704e340c47957d5fb5aca6ecda6624a69/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=579f368704e340c47957d5fb5aca6ecda6624a69", "patch": "@@ -287,8 +287,7 @@ static int arm_cortex_a5_branch_cost (bool, bool);\n static int arm_cortex_m_branch_cost (bool, bool);\n static int arm_cortex_m7_branch_cost (bool, bool);\n \n-static bool arm_vectorize_vec_perm_const_ok (machine_mode vmode,\n-\t\t\t\t\t     const unsigned char *sel);\n+static bool arm_vectorize_vec_perm_const_ok (machine_mode, vec_perm_indices);\n \n static bool aarch_macro_fusion_pair_p (rtx_insn*, rtx_insn*);\n \n@@ -28657,9 +28656,8 @@ arm_split_atomic_op (enum rtx_code code, rtx old_out, rtx new_out, rtx mem,\n struct expand_vec_perm_d\n {\n   rtx target, op0, op1;\n-  unsigned char perm[MAX_VECT_LEN];\n+  auto_vec_perm_indices perm;\n   machine_mode vmode;\n-  unsigned char nelt;\n   bool one_vector_p;\n   bool testing_p;\n };\n@@ -28766,7 +28764,7 @@ neon_pair_endian_lane_map (machine_mode mode, int lane)\n static bool\n arm_evpc_neon_vuzp (struct expand_vec_perm_d *d)\n {\n-  unsigned int i, odd, mask, nelt = d->nelt;\n+  unsigned int i, odd, mask, nelt = d->perm.length ();\n   rtx out0, out1, in0, in1;\n   rtx (*gen)(rtx, rtx, rtx, rtx);\n   int first_elem;\n@@ -28778,7 +28776,7 @@ arm_evpc_neon_vuzp (struct expand_vec_perm_d *d)\n   /* arm_expand_vec_perm_const_1 () helpfully swaps the operands for the\n      big endian pattern on 64 bit vectors, so we correct for that.  */\n   swap_nelt = BYTES_BIG_ENDIAN && !d->one_vector_p\n-    && GET_MODE_SIZE (d->vmode) == 8 ? d->nelt : 0;\n+    && GET_MODE_SIZE (d->vmode) == 8 ? nelt : 0;\n \n   first_elem = d->perm[neon_endian_lane_map (d->vmode, 0)] ^ swap_nelt;\n \n@@ -28837,7 +28835,7 @@ arm_evpc_neon_vuzp (struct expand_vec_perm_d *d)\n static bool\n arm_evpc_neon_vzip (struct expand_vec_perm_d *d)\n {\n-  unsigned int i, high, mask, nelt = d->nelt;\n+  unsigned int i, high, mask, nelt = d->perm.length ();\n   rtx out0, out1, in0, in1;\n   rtx (*gen)(rtx, rtx, rtx, rtx);\n   int first_elem;\n@@ -28912,7 +28910,7 @@ arm_evpc_neon_vzip (struct expand_vec_perm_d *d)\n static bool\n arm_evpc_neon_vrev (struct expand_vec_perm_d *d)\n {\n-  unsigned int i, j, diff, nelt = d->nelt;\n+  unsigned int i, j, diff, nelt = d->perm.length ();\n   rtx (*gen)(rtx, rtx);\n \n   if (!d->one_vector_p)\n@@ -28988,7 +28986,7 @@ arm_evpc_neon_vrev (struct expand_vec_perm_d *d)\n static bool\n arm_evpc_neon_vtrn (struct expand_vec_perm_d *d)\n {\n-  unsigned int i, odd, mask, nelt = d->nelt;\n+  unsigned int i, odd, mask, nelt = d->perm.length ();\n   rtx out0, out1, in0, in1;\n   rtx (*gen)(rtx, rtx, rtx, rtx);\n \n@@ -29054,7 +29052,7 @@ arm_evpc_neon_vtrn (struct expand_vec_perm_d *d)\n static bool\n arm_evpc_neon_vext (struct expand_vec_perm_d *d)\n {\n-  unsigned int i, nelt = d->nelt;\n+  unsigned int i, nelt = d->perm.length ();\n   rtx (*gen) (rtx, rtx, rtx, rtx);\n   rtx offset;\n \n@@ -29128,7 +29126,7 @@ arm_evpc_neon_vtbl (struct expand_vec_perm_d *d)\n {\n   rtx rperm[MAX_VECT_LEN], sel;\n   machine_mode vmode = d->vmode;\n-  unsigned int i, nelt = d->nelt;\n+  unsigned int i, nelt = d->perm.length ();\n \n   /* TODO: ARM's VTBL indexing is little-endian.  In order to handle GCC's\n      numbering of elements for big-endian, we must reverse the order.  */\n@@ -29165,11 +29163,10 @@ arm_expand_vec_perm_const_1 (struct expand_vec_perm_d *d)\n   /* The pattern matching functions above are written to look for a small\n      number to begin the sequence (0, 1, N/2).  If we begin with an index\n      from the second operand, we can swap the operands.  */\n-  if (d->perm[0] >= d->nelt)\n+  unsigned int nelt = d->perm.length ();\n+  if (d->perm[0] >= nelt)\n     {\n-      unsigned i, nelt = d->nelt;\n-\n-      for (i = 0; i < nelt; ++i)\n+      for (unsigned int i = 0; i < nelt; ++i)\n \td->perm[i] = (d->perm[i] + nelt) & (2 * nelt - 1);\n \n       std::swap (d->op0, d->op1);\n@@ -29204,15 +29201,16 @@ arm_expand_vec_perm_const (rtx target, rtx op0, rtx op1, rtx sel)\n \n   d.vmode = GET_MODE (target);\n   gcc_assert (VECTOR_MODE_P (d.vmode));\n-  d.nelt = nelt = GET_MODE_NUNITS (d.vmode);\n   d.testing_p = false;\n \n+  nelt = GET_MODE_NUNITS (d.vmode);\n+  d.perm.reserve (nelt);\n   for (i = which = 0; i < nelt; ++i)\n     {\n       rtx e = XVECEXP (sel, 0, i);\n       int ei = INTVAL (e) & (2 * nelt - 1);\n       which |= (ei < nelt ? 1 : 2);\n-      d.perm[i] = ei;\n+      d.perm.quick_push (ei);\n     }\n \n   switch (which)\n@@ -29249,19 +29247,18 @@ arm_expand_vec_perm_const (rtx target, rtx op0, rtx op1, rtx sel)\n /* Implement TARGET_VECTORIZE_VEC_PERM_CONST_OK.  */\n \n static bool\n-arm_vectorize_vec_perm_const_ok (machine_mode vmode,\n-\t\t\t\t const unsigned char *sel)\n+arm_vectorize_vec_perm_const_ok (machine_mode vmode, vec_perm_indices sel)\n {\n   struct expand_vec_perm_d d;\n   unsigned int i, nelt, which;\n   bool ret;\n \n   d.vmode = vmode;\n-  d.nelt = nelt = GET_MODE_NUNITS (d.vmode);\n   d.testing_p = true;\n-  memcpy (d.perm, sel, nelt);\n+  d.perm.safe_splice (sel);\n \n   /* Categorize the set of elements in the selector.  */\n+  nelt = GET_MODE_NUNITS (d.vmode);\n   for (i = which = 0; i < nelt; ++i)\n     {\n       unsigned char e = d.perm[i];"}, {"sha": "29b5a9c1bd873e47e7982ec28b1ade16e8f1ab76", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579f368704e340c47957d5fb5aca6ecda6624a69/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579f368704e340c47957d5fb5aca6ecda6624a69/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=579f368704e340c47957d5fb5aca6ecda6624a69", "patch": "@@ -50032,8 +50032,7 @@ ix86_expand_vec_perm_const (rtx operands[4])\n /* Implement targetm.vectorize.vec_perm_const_ok.  */\n \n static bool\n-ix86_vectorize_vec_perm_const_ok (machine_mode vmode,\n-\t\t\t\t  const unsigned char *sel)\n+ix86_vectorize_vec_perm_const_ok (machine_mode vmode, vec_perm_indices sel)\n {\n   struct expand_vec_perm_d d;\n   unsigned int i, nelt, which;\n@@ -50104,11 +50103,11 @@ ix86_vectorize_vec_perm_const_ok (machine_mode vmode,\n \n   /* Extract the values from the vector CST into the permutation\n      array in D.  */\n-  memcpy (d.perm, sel, nelt);\n   for (i = which = 0; i < nelt; ++i)\n     {\n-      unsigned char e = d.perm[i];\n+      unsigned char e = sel[i];\n       gcc_assert (e < 2 * nelt);\n+      d.perm[i] = e;\n       which |= (e < nelt ? 1 : 2);\n     }\n "}, {"sha": "5573f27af37468c734d99eb5c5fecc6fa3f42aa4", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579f368704e340c47957d5fb5aca6ecda6624a69/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579f368704e340c47957d5fb5aca6ecda6624a69/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=579f368704e340c47957d5fb5aca6ecda6624a69", "patch": "@@ -333,8 +333,7 @@ static machine_mode ia64_get_reg_raw_mode (int regno);\n static section * ia64_hpux_function_section (tree, enum node_frequency,\n \t\t\t\t\t     bool, bool);\n \n-static bool ia64_vectorize_vec_perm_const_ok (machine_mode vmode,\n-\t\t\t\t\t      const unsigned char *sel);\n+static bool ia64_vectorize_vec_perm_const_ok (machine_mode, vec_perm_indices);\n \n static unsigned int ia64_hard_regno_nregs (unsigned int, machine_mode);\n static bool ia64_hard_regno_mode_ok (unsigned int, machine_mode);\n@@ -11824,8 +11823,7 @@ ia64_expand_vec_perm_const (rtx operands[4])\n /* Implement targetm.vectorize.vec_perm_const_ok.  */\n \n static bool\n-ia64_vectorize_vec_perm_const_ok (machine_mode vmode,\n-\t\t\t\t  const unsigned char *sel)\n+ia64_vectorize_vec_perm_const_ok (machine_mode vmode, vec_perm_indices sel)\n {\n   struct expand_vec_perm_d d;\n   unsigned int i, nelt, which;\n@@ -11837,10 +11835,10 @@ ia64_vectorize_vec_perm_const_ok (machine_mode vmode,\n \n   /* Extract the values from the vector CST into the permutation\n      array in D.  */\n-  memcpy (d.perm, sel, nelt);\n   for (i = which = 0; i < nelt; ++i)\n     {\n-      unsigned char e = d.perm[i];\n+      unsigned char e = sel[i];\n+      d.perm[i] = e;\n       gcc_assert (e < 2 * nelt);\n       which |= (e < nelt ? 1 : 2);\n     }"}, {"sha": "a71732e047b63f369348b4d06ef8a3fc837ad106", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579f368704e340c47957d5fb5aca6ecda6624a69/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579f368704e340c47957d5fb5aca6ecda6624a69/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=579f368704e340c47957d5fb5aca6ecda6624a69", "patch": "@@ -21470,8 +21470,7 @@ mips_sched_reassociation_width (unsigned int opc ATTRIBUTE_UNUSED,\n /* Implement TARGET_VECTORIZE_VEC_PERM_CONST_OK.  */\n \n static bool\n-mips_vectorize_vec_perm_const_ok (machine_mode vmode,\n-\t\t\t\t  const unsigned char *sel)\n+mips_vectorize_vec_perm_const_ok (machine_mode vmode, vec_perm_indices sel)\n {\n   struct expand_vec_perm_d d;\n   unsigned int i, nelt, which;\n@@ -21480,12 +21479,12 @@ mips_vectorize_vec_perm_const_ok (machine_mode vmode,\n   d.vmode = vmode;\n   d.nelt = nelt = GET_MODE_NUNITS (d.vmode);\n   d.testing_p = true;\n-  memcpy (d.perm, sel, nelt);\n \n   /* Categorize the set of elements in the selector.  */\n   for (i = which = 0; i < nelt; ++i)\n     {\n-      unsigned char e = d.perm[i];\n+      unsigned char e = sel[i];\n+      d.perm[i] = e;\n       gcc_assert (e < 2 * nelt);\n       which |= (e < nelt ? 1 : 2);\n     }"}, {"sha": "26692aa8a69ca0298f911f0ab9e1f5f1812ecb7b", "filename": "gcc/config/powerpcspe/powerpcspe.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579f368704e340c47957d5fb5aca6ecda6624a69/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579f368704e340c47957d5fb5aca6ecda6624a69/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c?ref=579f368704e340c47957d5fb5aca6ecda6624a69", "patch": "@@ -38731,8 +38731,7 @@ rs6000_expand_vec_perm_const (rtx operands[4])\n /* Test whether a constant permutation is supported.  */\n \n static bool\n-rs6000_vectorize_vec_perm_const_ok (machine_mode vmode,\n-\t\t\t\t    const unsigned char *sel)\n+rs6000_vectorize_vec_perm_const_ok (machine_mode vmode, vec_perm_indices sel)\n {\n   /* AltiVec (and thus VSX) can handle arbitrary permutations.  */\n   if (TARGET_ALTIVEC)"}, {"sha": "9198e9ebeba84370ad4060efb129b49408b78b57", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579f368704e340c47957d5fb5aca6ecda6624a69/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579f368704e340c47957d5fb5aca6ecda6624a69/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=579f368704e340c47957d5fb5aca6ecda6624a69", "patch": "@@ -35594,8 +35594,7 @@ rs6000_expand_vec_perm_const (rtx operands[4])\n /* Test whether a constant permutation is supported.  */\n \n static bool\n-rs6000_vectorize_vec_perm_const_ok (machine_mode vmode,\n-\t\t\t\t    const unsigned char *sel)\n+rs6000_vectorize_vec_perm_const_ok (machine_mode vmode, vec_perm_indices sel)\n {\n   /* AltiVec (and thus VSX) can handle arbitrary permutations.  */\n   if (TARGET_ALTIVEC)"}, {"sha": "c2493cf6251cd5dcbe08899de34e64c7d9a60f7c", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579f368704e340c47957d5fb5aca6ecda6624a69/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579f368704e340c47957d5fb5aca6ecda6624a69/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=579f368704e340c47957d5fb5aca6ecda6624a69", "patch": "@@ -5774,7 +5774,7 @@ correct for most targets.\n Return true if vector alignment is reachable (by peeling N iterations) for the given scalar type @var{type}.  @var{is_packed} is false if the scalar access using @var{type} is known to be naturally aligned.\n @end deftypefn\n \n-@deftypefn {Target Hook} bool TARGET_VECTORIZE_VEC_PERM_CONST_OK (machine_mode, const unsigned char *@var{sel})\n+@deftypefn {Target Hook} bool TARGET_VECTORIZE_VEC_PERM_CONST_OK (machine_mode, @var{vec_perm_indices})\n Return true if a vector created for @code{vec_perm_const} is valid.\n @end deftypefn\n "}, {"sha": "204ca60249f528348941c83717c90eeb450a4831", "filename": "gcc/optabs-query.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579f368704e340c47957d5fb5aca6ecda6624a69/gcc%2Foptabs-query.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579f368704e340c47957d5fb5aca6ecda6624a69/gcc%2Foptabs-query.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-query.c?ref=579f368704e340c47957d5fb5aca6ecda6624a69", "patch": "@@ -367,7 +367,7 @@ can_vec_perm_p (machine_mode mode, bool variable, vec_perm_indices *sel)\n       if (direct_optab_handler (vec_perm_const_optab, mode) != CODE_FOR_nothing\n \t  && (sel == NULL\n \t      || targetm.vectorize.vec_perm_const_ok == NULL\n-\t      || targetm.vectorize.vec_perm_const_ok (mode, &(*sel)[0])))\n+\t      || targetm.vectorize.vec_perm_const_ok (mode, *sel)))\n \treturn true;\n     }\n "}, {"sha": "42fd0b1854a70bbe188d9517127557f927ae6202", "filename": "gcc/target.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579f368704e340c47957d5fb5aca6ecda6624a69/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579f368704e340c47957d5fb5aca6ecda6624a69/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=579f368704e340c47957d5fb5aca6ecda6624a69", "patch": "@@ -1847,7 +1847,7 @@ DEFHOOK\n DEFHOOK\n (vec_perm_const_ok,\n  \"Return true if a vector created for @code{vec_perm_const} is valid.\",\n- bool, (machine_mode, const unsigned char *sel),\n+ bool, (machine_mode, vec_perm_indices),\n  NULL)\n \n /* Return true if the target supports misaligned store/load of a"}]}