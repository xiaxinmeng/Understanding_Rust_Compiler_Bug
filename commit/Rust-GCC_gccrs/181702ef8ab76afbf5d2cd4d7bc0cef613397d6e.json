{"sha": "181702ef8ab76afbf5d2cd4d7bc0cef613397d6e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTgxNzAyZWY4YWI3NmFmYmY1ZDJjZDRkN2JjMGNlZjYxMzM5N2Q2ZQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-10-06T13:47:15Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-10-08T14:07:15Z"}, "message": "SLP vectorize multiple BBs at once\n\nThis work from Martin Liska was motivated by gcc.dg/vect/bb-slp-22.c\nwhich shows how poorly we currently BB vectorize code like\n\n  a0 = in[0] + 23;\n  a1 = in[1] + 142;\n  a2 = in[2] + 2;\n  a3 = in[3] + 31;\n\n  if (x > y)\n    {\n      b[0] = a0;\n      b[1] = a1;\n      b[2] = a2;\n      b[3] = a3;\n    }\n  else\n    {\n      out[0] = a0 * (x + 1);\n      out[1] = a1 * (y + 1);\n      out[2] = a2 * (x + 1);\n      out[3] = a3 * (y + 1);\n    }\n\nnamely by vectorizing the stores but not the common load (and add)\nthey are feeded with.\n\nThus with the following patch we change the BB vectorizer from\noperating on a single basic-block at a time to consider somewhat\nlarger regions (but not the whole function yet because of issues\nwith vector size iteration).\n\nI took the opportunity to remove the fancy region iterations again\nnow that we operate on BB granularity and in the end need to visit\nPHI nodes as well.\n\n2020-10-08  Martin Liska  <mliska@suse.cz>\n\t    Richard Biener  <rguenther@suse.de>\n\n\t* tree-vectorizer.h (_bb_vec_info::const_iterator): Remove.\n\t(_bb_vec_info::const_reverse_iterator): Likewise.\n\t(_bb_vec_info::region_stmts): Likewise.\n\t(_bb_vec_info::reverse_region_stmts): Likewise.\n\t(_bb_vec_info::_bb_vec_info): Adjust.\n\t(_bb_vec_info::bb): Remove.\n\t(_bb_vec_info::region_begin): Remove.\n\t(_bb_vec_info::region_end): Remove.\n\t(_bb_vec_info::bbs): New vector of BBs.\n\t(vect_slp_function): Declare.\n\t* tree-vect-patterns.c (vect_determine_precisions): Use\n\tregular stmt iteration.\n\t(vect_pattern_recog): Likewise.\n\t* tree-vect-slp.c: Include cfganal.h, tree-eh.h and tree-cfg.h.\n\t(vect_build_slp_tree_1): Properly refuse to vectorize\n\tvolatile and throwing stmts.\n\t(vect_build_slp_tree_2): Pass group-size down to\n\tget_vectype_for_scalar_type.\n\t(_bb_vec_info::_bb_vec_info): Use regular stmt iteration,\n\tadjust for changed region specification.\n\t(_bb_vec_info::~_bb_vec_info): Likewise.\n\t(vect_slp_check_for_constructors): Likewise.\n\t(vect_slp_region): Likewise.\n\t(vect_slp_bbs): New worker operating on a vector of BBs.\n\t(vect_slp_bb): Wrap it.\n\t(vect_slp_function): New function splitting the function\n\tinto multi-BB regions.\n\t(vect_create_constant_vectors): Handle the case of inserting\n\tafter a throwing def.\n\t(vect_schedule_slp_instance): Adjust.\n\t* tree-vectorizer.c (vec_info::remove_stmt): Simplify again.\n\t(vec_info::insert_seq_on_entry): Adjust.\n\t(pass_slp_vectorize::execute): Also init PHIs.  Call\n\tvect_slp_function.\n\n\t* gcc.dg/vect/bb-slp-22.c: Adjust.\n\t* gfortran.dg/pr68627.f: Likewise.", "tree": {"sha": "47224d10f36c8f065c9fbe74346cb5f7cd3e838c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/47224d10f36c8f065c9fbe74346cb5f7cd3e838c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/181702ef8ab76afbf5d2cd4d7bc0cef613397d6e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/181702ef8ab76afbf5d2cd4d7bc0cef613397d6e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/181702ef8ab76afbf5d2cd4d7bc0cef613397d6e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/181702ef8ab76afbf5d2cd4d7bc0cef613397d6e/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f997b67550144c6c0562f94c9b9cb932125d0444", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f997b67550144c6c0562f94c9b9cb932125d0444", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f997b67550144c6c0562f94c9b9cb932125d0444"}], "stats": {"total": 382, "additions": 203, "deletions": 179}, "files": [{"sha": "92cc2a51abd0a2d004ada88512aa5a29e9e0e896", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-22.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/181702ef8ab76afbf5d2cd4d7bc0cef613397d6e/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-22.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/181702ef8ab76afbf5d2cd4d7bc0cef613397d6e/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-22.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-22.c?ref=181702ef8ab76afbf5d2cd4d7bc0cef613397d6e", "patch": "@@ -63,5 +63,5 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"optimized: basic block\" 2 \"slp2\" } } */\n+/* { dg-final { scan-tree-dump-times \"optimized: basic block\" 1 \"slp2\" } } */\n /* { dg-final { scan-tree-dump \"vectorizing SLP node starting from: _\\[0-9\\]+ = _\\[0-9\\]+ \\\\\\* a0\" \"slp2\" { target vect_int_mult  } } } */"}, {"sha": "2ff1f3c77c8f0718a62822c56328a4414cba7d42", "filename": "gcc/testsuite/gfortran.dg/pr68627.f", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/181702ef8ab76afbf5d2cd4d7bc0cef613397d6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr68627.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/181702ef8ab76afbf5d2cd4d7bc0cef613397d6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr68627.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr68627.f?ref=181702ef8ab76afbf5d2cd4d7bc0cef613397d6e", "patch": "@@ -1,6 +1,6 @@\n ! { dg-do compile { target { { i?86-*-* x86_64-*-* } && { ! { ia32 } } } } }\n \n-! { dg-options \"-Ofast -mavx512f -ffixed-xmm1 -ffixed-xmm2 -ffixed-xmm3 -ffixed-xmm4 -ffixed-xmm5 -ffixed-xmm6 -ffixed-xmm7 -ffixed-xmm8 -ffixed-xmm9 -ffixed-xmm10 -ffixed-xmm11 -ffixed-xmm12 -ffixed-xmm13 -ffixed-xmm14 -ffixed-xmm15\" }\n+! { dg-options \"-Ofast -fno-tree-slp-vectorize -mavx512f -ffixed-xmm1 -ffixed-xmm2 -ffixed-xmm3 -ffixed-xmm4 -ffixed-xmm5 -ffixed-xmm6 -ffixed-xmm7 -ffixed-xmm8 -ffixed-xmm9 -ffixed-xmm10 -ffixed-xmm11 -ffixed-xmm12 -ffixed-xmm13 -ffixed-xmm14 -ffixed-xmm15\" }\n \n       IMPLICIT REAL*8(A-H,O-Z)\n       ALLOCATABLE DD1(:), DD2(:), WY(:,:)"}, {"sha": "71e4e106202f93c7f2283821bae54ccf7596fafe", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/181702ef8ab76afbf5d2cd4d7bc0cef613397d6e/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/181702ef8ab76afbf5d2cd4d7bc0cef613397d6e/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=181702ef8ab76afbf5d2cd4d7bc0cef613397d6e", "patch": "@@ -5123,12 +5123,14 @@ vect_determine_precisions (vec_info *vinfo)\n   else\n     {\n       bb_vec_info bb_vinfo = as_a <bb_vec_info> (vinfo);\n-      for (gimple *stmt : bb_vinfo->reverse_region_stmts ())\n-\t{\n-\t  stmt_vec_info stmt_info = vinfo->lookup_stmt (stmt);\n-\t  if (stmt_info && STMT_VINFO_VECTORIZABLE (stmt_info))\n-\t    vect_determine_stmt_precisions (vinfo, stmt_info);\n-\t}\n+      for (int i = bb_vinfo->bbs.length () - 1; i != -1; --i)\n+\tfor (gimple_stmt_iterator gsi = gsi_last_bb (bb_vinfo->bbs[i]);\n+\t     !gsi_end_p (gsi); gsi_prev (&gsi))\n+\t  {\n+\t    stmt_vec_info stmt_info = vinfo->lookup_stmt (gsi_stmt (gsi));\n+\t    if (stmt_info && STMT_VINFO_VECTORIZABLE (stmt_info))\n+\t      vect_determine_stmt_precisions (vinfo, stmt_info);\n+\t  }\n     }\n }\n \n@@ -5487,17 +5489,19 @@ vect_pattern_recog (vec_info *vinfo)\n   else\n     {\n       bb_vec_info bb_vinfo = as_a <bb_vec_info> (vinfo);\n-      for (gimple *stmt : bb_vinfo->region_stmts ())\n-\t{\n-\t  stmt_vec_info stmt_info = bb_vinfo->lookup_stmt (stmt);\n-\t  if (!stmt_info || !STMT_VINFO_VECTORIZABLE (stmt_info))\n-\t    continue;\n-\n-\t  /* Scan over all generic vect_recog_xxx_pattern functions.  */\n-\t  for (j = 0; j < NUM_PATTERNS; j++)\n-\t    vect_pattern_recog_1 (vinfo,\n-\t\t\t\t  &vect_vect_recog_func_ptrs[j], stmt_info);\n-\t}\n+      for (unsigned i = 0; i < bb_vinfo->bbs.length (); ++i)\n+\tfor (gimple_stmt_iterator gsi = gsi_start_bb (bb_vinfo->bbs[i]);\n+\t     !gsi_end_p (gsi); gsi_next (&gsi))\n+\t  {\n+\t    stmt_vec_info stmt_info = bb_vinfo->lookup_stmt (gsi_stmt (gsi));\n+\t    if (!stmt_info || !STMT_VINFO_VECTORIZABLE (stmt_info))\n+\t      continue;\n+\n+\t    /* Scan over all generic vect_recog_xxx_pattern functions.  */\n+\t    for (j = 0; j < NUM_PATTERNS; j++)\n+\t      vect_pattern_recog_1 (vinfo,\n+\t\t\t\t    &vect_vect_recog_func_ptrs[j], stmt_info);\n+\t  }\n     }\n \n   /* After this no more add_stmt calls are allowed.  */"}, {"sha": "7e22506b49fac15ed90ab65efbd4b5026c5b8391", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 162, "deletions": 66, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/181702ef8ab76afbf5d2cd4d7bc0cef613397d6e/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/181702ef8ab76afbf5d2cd4d7bc0cef613397d6e/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=181702ef8ab76afbf5d2cd4d7bc0cef613397d6e", "patch": "@@ -45,7 +45,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-fold.h\"\n #include \"internal-fn.h\"\n #include \"dump-context.h\"\n-\n+#include \"cfganal.h\"\n+#include \"tree-eh.h\"\n+#include \"tree-cfg.h\"\n \n static bool vectorizable_slp_permutation (vec_info *, gimple_stmt_iterator *,\n \t\t\t\t\t  slp_tree, stmt_vector_for_cost *);\n@@ -761,8 +763,11 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, vect_location, \"Build SLP for %G\", stmt);\n \n-      /* Fail to vectorize statements marked as unvectorizable.  */\n-      if (!STMT_VINFO_VECTORIZABLE (stmt_info))\n+      /* Fail to vectorize statements marked as unvectorizable, throw\n+\t or are volatile.  */\n+      if (!STMT_VINFO_VECTORIZABLE (stmt_info)\n+\t  || stmt_can_throw_internal (cfun, stmt)\n+\t  || gimple_has_volatile_ops (stmt))\n         {\n           if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -1239,7 +1244,8 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n   if (gphi *stmt = dyn_cast <gphi *> (stmt_info->stmt))\n     {\n       tree scalar_type = TREE_TYPE (PHI_RESULT (stmt));\n-      tree vectype = get_vectype_for_scalar_type (vinfo, scalar_type);\n+      tree vectype = get_vectype_for_scalar_type (vinfo, scalar_type,\n+\t\t\t\t\t\t  group_size);\n       if (!vect_record_max_nunits (vinfo, stmt_info, group_size, vectype,\n \t\t\t\t   max_nunits))\n \treturn NULL;\n@@ -2728,26 +2734,31 @@ vect_detect_hybrid_slp (loop_vec_info loop_vinfo)\n }\n \n \n-/* Initialize a bb_vec_info struct for the statements between\n-   REGION_BEGIN_IN (inclusive) and REGION_END_IN (exclusive).  */\n+/* Initialize a bb_vec_info struct for the statements in BBS basic blocks.  */\n \n-_bb_vec_info::_bb_vec_info (gimple_stmt_iterator region_begin_in,\n-\t\t\t    gimple_stmt_iterator region_end_in,\n-\t\t\t    vec_info_shared *shared)\n-  : vec_info (vec_info::bb, init_cost (NULL), shared),\n-    bb (gsi_bb (region_begin_in)),\n-    region_begin (region_begin_in),\n-    region_end (region_end_in)\n+_bb_vec_info::_bb_vec_info (vec<basic_block> _bbs, vec_info_shared *shared)\n+  : vec_info (vec_info::bb, init_cost (NULL), shared), bbs (_bbs)\n {\n-  for (gimple *stmt : this->region_stmts ())\n+  for (unsigned i = 0; i < bbs.length (); ++i)\n     {\n-      gimple_set_uid (stmt, 0);\n-      if (is_gimple_debug (stmt))\n-\tcontinue;\n-      add_stmt (stmt);\n+      if (i != 0)\n+\tfor (gphi_iterator si = gsi_start_phis (bbs[i]); !gsi_end_p (si);\n+\t     gsi_next (&si))\n+\t  {\n+\t    gphi *phi = si.phi ();\n+\t    gimple_set_uid (phi, 0);\n+\t    add_stmt (phi);\n+\t  }\n+      for (gimple_stmt_iterator gsi = gsi_start_bb (bbs[i]);\n+\t   !gsi_end_p (gsi); gsi_next (&gsi))\n+\t{\n+\t  gimple *stmt = gsi_stmt (gsi);\n+\t  gimple_set_uid (stmt, 0);\n+\t  if (is_gimple_debug (stmt))\n+\t    continue;\n+\t  add_stmt (stmt);\n+\t}\n     }\n-\n-  bb->aux = this;\n }\n \n \n@@ -2756,11 +2767,23 @@ _bb_vec_info::_bb_vec_info (gimple_stmt_iterator region_begin_in,\n \n _bb_vec_info::~_bb_vec_info ()\n {\n-  for (gimple *stmt : this->region_stmts ())\n-    /* Reset region marker.  */\n-    gimple_set_uid (stmt, -1);\n-\n-  bb->aux = NULL;\n+  /* Reset region marker.  */\n+  for (unsigned i = 0; i < bbs.length (); ++i)\n+    {\n+      if (i != 0)\n+\tfor (gphi_iterator si = gsi_start_phis (bbs[i]); !gsi_end_p (si);\n+\t     gsi_next (&si))\n+\t  {\n+\t    gphi *phi = si.phi ();\n+\t    gimple_set_uid (phi, -1);\n+\t  }\n+      for (gimple_stmt_iterator gsi = gsi_start_bb (bbs[i]);\n+\t   !gsi_end_p (gsi); gsi_next (&gsi))\n+\t{\n+\t  gimple *stmt = gsi_stmt (gsi);\n+\t  gimple_set_uid (stmt, -1);\n+\t}\n+    }\n }\n \n /* Subroutine of vect_slp_analyze_node_operations.  Handle the root of NODE,\n@@ -3461,9 +3484,11 @@ vect_bb_vectorization_profitable_p (bb_vec_info bb_vinfo,\n static void\n vect_slp_check_for_constructors (bb_vec_info bb_vinfo)\n {\n-  for (gimple *stmt : bb_vinfo->region_stmts ())\n+  for (unsigned i = 0; i < bb_vinfo->bbs.length (); ++i)\n+    for (gimple_stmt_iterator gsi = gsi_start_bb (bb_vinfo->bbs[i]);\n+\t !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n-      gassign *assign = dyn_cast<gassign *> (stmt);\n+      gassign *assign = dyn_cast<gassign *> (gsi_stmt (gsi));\n       if (!assign || gimple_assign_rhs_code (assign) != CONSTRUCTOR)\n \tcontinue;\n \n@@ -3602,17 +3627,13 @@ vect_slp_analyze_bb_1 (bb_vec_info bb_vinfo, int n_stmts, bool &fatal,\n   return true;\n }\n \n-/* Subroutine of vect_slp_bb.  Try to vectorize the statements between\n-   REGION_BEGIN (inclusive) and REGION_END (exclusive), returning true\n-   on success.  The region has N_STMTS statements and has the datarefs\n-   given by DATAREFS.  */\n+/* Subroutine of vect_slp_bb.  Try to vectorize the statements for all\n+   basic blocks in BBS, returning true on success.\n+   The region has N_STMTS statements and has the datarefs given by DATAREFS.  */\n \n static bool\n-vect_slp_region (gimple_stmt_iterator region_begin,\n-\t\t gimple_stmt_iterator region_end,\n-\t\t vec<data_reference_p> datarefs,\n-\t\t vec<int> *dataref_groups,\n-\t\t unsigned int n_stmts)\n+vect_slp_region (vec<basic_block> bbs, vec<data_reference_p> datarefs,\n+\t\t vec<int> *dataref_groups, unsigned int n_stmts)\n {\n   bb_vec_info bb_vinfo;\n   auto_vector_modes vector_modes;\n@@ -3629,7 +3650,7 @@ vect_slp_region (gimple_stmt_iterator region_begin,\n     {\n       bool vectorized = false;\n       bool fatal = false;\n-      bb_vinfo = new _bb_vec_info (region_begin, region_end, &shared);\n+      bb_vinfo = new _bb_vec_info (bbs, &shared);\n \n       bool first_time_p = shared.datarefs.is_empty ();\n       BB_VINFO_DATAREFS (bb_vinfo) = datarefs;\n@@ -3754,50 +3775,113 @@ vect_slp_region (gimple_stmt_iterator region_begin,\n     }\n }\n \n-/* Main entry for the BB vectorizer.  Analyze and transform BB, returns\n+\n+/* Main entry for the BB vectorizer.  Analyze and transform BBS, returns\n    true if anything in the basic-block was vectorized.  */\n \n-bool\n-vect_slp_bb (basic_block bb)\n+static bool\n+vect_slp_bbs (vec<basic_block> bbs)\n {\n   vec<data_reference_p> datarefs = vNULL;\n   vec<int> dataref_groups = vNULL;\n   int insns = 0;\n   int current_group = 0;\n-  gimple_stmt_iterator region_begin = gsi_start_nondebug_after_labels_bb (bb);\n-  gimple_stmt_iterator region_end = gsi_last_bb (bb);\n-  if (!gsi_end_p (region_end))\n-    gsi_next (&region_end);\n \n-  for (gimple_stmt_iterator gsi = gsi_after_labels (bb); !gsi_end_p (gsi);\n-       gsi_next (&gsi))\n+  for (unsigned i = 0; i < bbs.length (); i++)\n     {\n-      gimple *stmt = gsi_stmt (gsi);\n-      if (is_gimple_debug (stmt))\n-\tcontinue;\n+      basic_block bb = bbs[i];\n+      for (gimple_stmt_iterator gsi = gsi_after_labels (bb); !gsi_end_p (gsi);\n+\t   gsi_next (&gsi))\n+\t{\n+\t  gimple *stmt = gsi_stmt (gsi);\n+\t  if (is_gimple_debug (stmt))\n+\t    continue;\n \n-      insns++;\n+\t  insns++;\n \n-      if (gimple_location (stmt) != UNKNOWN_LOCATION)\n-\tvect_location = stmt;\n+\t  if (gimple_location (stmt) != UNKNOWN_LOCATION)\n+\t    vect_location = stmt;\n \n-      if (!vect_find_stmt_data_reference (NULL, stmt, &datarefs,\n-\t\t\t\t\t  &dataref_groups, current_group))\n-\t++current_group;\n+\t  if (!vect_find_stmt_data_reference (NULL, stmt, &datarefs,\n+\t\t\t\t\t      &dataref_groups, current_group))\n+\t    ++current_group;\n \n-      if (insns > param_slp_max_insns_in_bb)\n-\t{\n-\t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"not vectorized: too many instructions in \"\n-\t\t\t     \"basic block.\\n\");\n+\t  if (insns > param_slp_max_insns_in_bb)\n+\t    {\n+\t      if (dump_enabled_p ())\n+\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t \"not vectorized: too many instructions in \"\n+\t\t\t\t \"region.\\n\");\n+\t    }\n \t}\n     }\n \n-  return vect_slp_region (region_begin, region_end, datarefs,\n-\t\t\t  &dataref_groups, insns);\n+  return vect_slp_region (bbs, datarefs, &dataref_groups, insns);\n }\n \n+/* Main entry for the BB vectorizer.  Analyze and transform BB, returns\n+   true if anything in the basic-block was vectorized.  */\n+\n+bool\n+vect_slp_bb (basic_block bb)\n+{\n+  auto_vec<basic_block> bbs;\n+  bbs.safe_push (bb);\n+  return vect_slp_bbs (bbs);\n+}\n+\n+/* Main entry for the BB vectorizer.  Analyze and transform BB, returns\n+   true if anything in the basic-block was vectorized.  */\n+\n+bool\n+vect_slp_function (function *fun)\n+{\n+  bool r = false;\n+  int *rpo = XNEWVEC (int, n_basic_blocks_for_fn (fun));\n+  unsigned n = pre_and_rev_post_order_compute_fn (fun, NULL, rpo, false);\n+\n+  /* For the moment split the function into pieces to avoid making\n+     the iteration on the vector mode moot.  Split at points we know\n+     to not handle well which is CFG merges (SLP discovery doesn't\n+     handle non-loop-header PHIs) and loop exits.  Since pattern\n+     recog requires reverse iteration to visit uses before defs\n+     simply chop RPO into pieces.  */\n+  auto_vec<basic_block> bbs;\n+  for (unsigned i = 0; i < n; i++)\n+    {\n+      basic_block bb = BASIC_BLOCK_FOR_FN (fun, rpo[i]);\n+\n+      /* Split when a basic block has multiple predecessors or when the\n+\t edge into it exits a loop (because of implementation issues with\n+\t respect to placement of CTORs for externals).  */\n+      bool split = false;\n+      edge e;\n+      if (!single_pred_p (bb)\n+\t  || ((e = single_pred_edge (bb)),\n+\t      loop_exit_edge_p (e->src->loop_father, e)))\n+\tsplit = true;\n+      /* Split when a BB is not dominated by the first block.  */\n+      else if (!bbs.is_empty ()\n+\t       && !dominated_by_p (CDI_DOMINATORS, bb, bbs[0]))\n+\tsplit = true;\n+\n+      if (split && !bbs.is_empty ())\n+\t{\n+\t  r |= vect_slp_bbs (bbs);\n+\t  bbs.truncate (0);\n+\t  bbs.quick_push (bb);\n+\t}\n+      else\n+\tbbs.safe_push (bb);\n+    }\n+\n+  if (!bbs.is_empty ())\n+    r |= vect_slp_bbs (bbs);\n+\n+  free (rpo);\n+\n+  return r;\n+}\n \n /* Build a variable-length vector in which the elements in ELTS are repeated\n    to a fill NRESULTS vectors of type VECTOR_TYPE.  Store the vectors in\n@@ -4059,8 +4143,19 @@ vect_create_constant_vectors (vec_info *vinfo, slp_tree op_node)\n \t\t{\n \t\t  if (insert_after)\n \t\t    {\n-\t\t      gimple_stmt_iterator gsi\n-\t\t\t= gsi_for_stmt (insert_after->stmt);\n+\t\t      gimple_stmt_iterator gsi;\n+\t\t      if (!stmt_ends_bb_p (insert_after->stmt))\n+\t\t\tgsi = gsi_for_stmt (insert_after->stmt);\n+\t\t      else\n+\t\t\t{\n+\t\t\t  /* When we want to insert after a def where the\n+\t\t\t     defining stmt throws then insert on the fallthru\n+\t\t\t     edge.  */\n+\t\t\t  edge e = find_fallthru_edge\n+\t\t\t\t     (gimple_bb (insert_after->stmt)->succs);\n+\t\t\t  gcc_assert (single_pred_p (e->dest));\n+\t\t\t  gsi = gsi_after_labels (e->dest);\n+\t\t\t}\n \t\t      gsi_insert_seq_after (&gsi, ctor_seq,\n \t\t\t\t\t    GSI_CONTINUE_LINKING);\n \t\t    }\n@@ -4674,7 +4769,8 @@ vect_schedule_slp_instance (vec_info *vinfo,\n \t       we do not insert before the region boundary.  */\n \t    if (SLP_TREE_SCALAR_OPS (child).is_empty ()\n \t\t&& !vinfo->lookup_def (SLP_TREE_VEC_DEFS (child)[0]))\n-\t      last_stmt = gsi_stmt (as_a <bb_vec_info> (vinfo)->region_begin);\n+\t      last_stmt = gsi_stmt (gsi_after_labels\n+\t\t\t\t      (as_a <bb_vec_info> (vinfo)->bbs[0]));\n \t    else\n \t      {\n \t\tunsigned j;"}, {"sha": "02da755f064d14c2ef017abf11ffe5b0b8ec1e3e", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/181702ef8ab76afbf5d2cd4d7bc0cef613397d6e/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/181702ef8ab76afbf5d2cd4d7bc0cef613397d6e/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=181702ef8ab76afbf5d2cd4d7bc0cef613397d6e", "patch": "@@ -605,11 +605,7 @@ vec_info::remove_stmt (stmt_vec_info stmt_info)\n   set_vinfo_for_stmt (stmt_info->stmt, NULL);\n   unlink_stmt_vdef (stmt_info->stmt);\n   gimple_stmt_iterator si = gsi_for_stmt (stmt_info->stmt);\n-  gimple_stmt_iterator *psi = &si;\n-  if (bb_vec_info bb_vinfo = dyn_cast <bb_vec_info> (this))\n-    if (gsi_stmt (bb_vinfo->region_begin) == stmt_info->stmt)\n-      psi = &bb_vinfo->region_begin;\n-  gsi_remove (psi, true);\n+  gsi_remove (&si, true);\n   release_defs (stmt_info->stmt);\n   free_stmt_vec_info (stmt_info);\n }\n@@ -653,7 +649,8 @@ vec_info::insert_seq_on_entry (stmt_vec_info context, gimple_seq seq)\n   else\n     {\n       bb_vec_info bb_vinfo = as_a <bb_vec_info> (this);\n-      gimple_stmt_iterator gsi_region_begin = bb_vinfo->region_begin;\n+      gimple_stmt_iterator gsi_region_begin\n+\t= gsi_after_labels (bb_vinfo->bbs[0]);\n       gsi_insert_seq_before (&gsi_region_begin, seq, GSI_SAME_STMT);\n     }\n }\n@@ -1416,6 +1413,13 @@ pass_slp_vectorize::execute (function *fun)\n   /* Mark all stmts as not belonging to the current region and unvisited.  */\n   FOR_EACH_BB_FN (bb, fun)\n     {\n+      for (gphi_iterator gsi = gsi_start_phis (bb); !gsi_end_p (gsi);\n+\t   gsi_next (&gsi))\n+\t{\n+\t  gphi *stmt = gsi.phi ();\n+\t  gimple_set_uid (stmt, -1);\n+\t  gimple_set_visited (stmt, false);\n+\t}\n       for (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi);\n \t   gsi_next (&gsi))\n \t{\n@@ -1425,8 +1429,7 @@ pass_slp_vectorize::execute (function *fun)\n \t}\n     }\n \n-  FOR_EACH_BB_FN (bb, fun)\n-    vect_slp_bb (bb);\n+  vect_slp_function (fun);\n \n   if (!in_loop_pipeline)\n     {"}, {"sha": "38daa05aebbf22bb3825458607784050cddd8604", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 7, "deletions": 86, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/181702ef8ab76afbf5d2cd4d7bc0cef613397d6e/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/181702ef8ab76afbf5d2cd4d7bc0cef613397d6e/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=181702ef8ab76afbf5d2cd4d7bc0cef613397d6e", "patch": "@@ -827,94 +827,14 @@ loop_vec_info_for_loop (class loop *loop)\n typedef class _bb_vec_info : public vec_info\n {\n public:\n-\n-  /* GIMPLE statement iterator going from region_begin to region_end.  */\n-\n-  struct const_iterator\n-  {\n-    const_iterator (gimple_stmt_iterator _gsi) : gsi (_gsi) {}\n-\n-    const const_iterator &\n-    operator++ ()\n-    {\n-      gsi_next (&gsi); return *this;\n-    }\n-\n-    gimple *operator* () const { return gsi_stmt (gsi); }\n-\n-    bool\n-    operator== (const const_iterator &other) const\n-    {\n-      return gsi_stmt (gsi) == gsi_stmt (other.gsi);\n-    }\n-\n-    bool\n-    operator!= (const const_iterator &other) const\n-    {\n-      return !(*this == other);\n-    }\n-\n-    gimple_stmt_iterator gsi;\n-  };\n-\n-  /* GIMPLE statement iterator going from region_end to region_begin.  */\n-\n-  struct const_reverse_iterator\n-  {\n-    const_reverse_iterator (gimple_stmt_iterator _gsi) : gsi (_gsi) {}\n-\n-    const const_reverse_iterator &\n-    operator++ ()\n-    {\n-      gsi_prev (&gsi); return *this;\n-    }\n-\n-    gimple *operator* () const { return gsi_stmt (gsi); }\n-\n-    bool\n-    operator== (const const_reverse_iterator &other) const\n-    {\n-      return gsi_stmt (gsi) == gsi_stmt (other.gsi);\n-    }\n-\n-    bool\n-    operator!= (const const_reverse_iterator &other) const\n-    {\n-      return !(*this == other);\n-    }\n-\n-    gimple_stmt_iterator gsi;\n-  };\n-\n-  _bb_vec_info (gimple_stmt_iterator, gimple_stmt_iterator, vec_info_shared *);\n+  _bb_vec_info (vec<basic_block> bbs, vec_info_shared *);\n   ~_bb_vec_info ();\n \n-  /* Returns iterator_range for range-based loop.  */\n-\n-  iterator_range<const_iterator>\n-  region_stmts ()\n-  {\n-    return iterator_range<const_iterator> (region_begin, region_end);\n-  }\n-\n-  /* Returns iterator_range for range-based loop in a reverse order.  */\n-\n-  iterator_range<const_reverse_iterator>\n-  reverse_region_stmts ()\n-  {\n-    const_reverse_iterator begin = region_end;\n-    if (*begin == NULL)\n-      begin = const_reverse_iterator (gsi_last_bb (gsi_bb (region_end)));\n-    else\n-      ++begin;\n-\n-    const_reverse_iterator end = region_begin;\n-    return iterator_range<const_reverse_iterator> (begin, ++end);\n-  }\n-\n-  basic_block bb;\n-  gimple_stmt_iterator region_begin;\n-  gimple_stmt_iterator region_end;\n+  /* The region we are operating on.  bbs[0] is the entry, excluding\n+     its PHI nodes.  In the future we might want to track an explicit\n+     entry edge to cover bbs[0] PHI nodes and have a region entry\n+     insert location.  */\n+  vec<basic_block> bbs;\n } *bb_vec_info;\n \n #define BB_VINFO_BB(B)               (B)->bb\n@@ -2035,6 +1955,7 @@ extern void vect_get_slp_defs (slp_tree, vec<tree> *);\n extern void vect_get_slp_defs (vec_info *, slp_tree, vec<vec<tree> > *,\n \t\t\t       unsigned n = -1U);\n extern bool vect_slp_bb (basic_block);\n+extern bool vect_slp_function (function *);\n extern stmt_vec_info vect_find_last_scalar_stmt_in_slp (slp_tree);\n extern stmt_vec_info vect_find_first_scalar_stmt_in_slp (slp_tree);\n extern bool is_simple_and_all_uses_invariant (stmt_vec_info, loop_vec_info);"}]}