{"sha": "a23225fb4f764dfc3e3e729c7d7238f03f282aaa", "node_id": "C_kwDOANBUbNoAKGEyMzIyNWZiNGY3NjRkZmMzZTNlNzI5YzdkNzIzOGYwM2YyODJhYWE", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-10-18T09:37:13Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-10-18T09:37:13Z"}, "message": "libstdc++: Partial library support for std::float{16,32,64,128}_t and std::bfloat16_t\n\nThe following patch is partial support for std::float{16,32,64,128}_t\nand std::bfloat16_t in libstdc++.\nhttps://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html\nsays that <ostream>, <istream>, <charconv> and <complex>\nneed changes toom, but that isn't implemented so far.\nIn <cmath> the only thing missing I'm aware of is\nstd::nextafter std::float16_t and std::bfloat16_t overloads (I think\nwe probably need to implement that out of line somewhere, or inline? - might\nneed inline asm barriers) and std::nexttoward overloads (those are\nintentional, you said there is a LWG issue about that).\nAlso, this patch has the glibc 2.26+ std::float128_t support for platforms\nwhere long double isn't IEEE quad format temporarily disabled\nbecause it depends on\nhttps://gcc.gnu.org/pipermail/gcc-patches/2022-October/603665.html\nchanges which aren't in yet.\n\nThe patch also doesn't include any testcases to cover the <type_traits>\nchanges, it isn't clear to me where to put that.\n\n2022-10-18  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR c++/106652\n\t* include/std/stdfloat: New file.\n\t* include/std/numbers (__glibcxx_numbers): Define and use it\n\tfor __float128 explicit instantiations as well as\n\t_Float{16,32,64,128} and __gnu_cxx::__bfloat16_t.\n\t* include/std/atomic (atomic<_Float16>, atomic<_Float32>,\n\tatomic<_Float64>, atomic<_Float128>, atomic<__gnu_cxx::__bfloat16_t>):\n\tNew explicit instantiations.\n\t* include/std/type_traits (__is_floating_point_helper<_Float16>,\n\t__is_floating_point_helper<_Float32>,\n\t__is_floating_point_helper<_Float64>,\n\t__is_floating_point_helper<_Float128>,\n\t__is_floating_point_helper<__gnu_cxx::__bfloat16_t>): Likewise.\n\t* include/std/limits (__glibcxx_concat3_, __glibcxx_concat3,\n\t__glibcxx_float_n): Define.\n\t(numeric_limits<_Float16>, numeric_limits<_Float32>,\n\tnumeric_limits<_Float64>, numeric_limits<_Float128>,\n\tnumeric_limits<__gnu_cxx::__bfloat16_t>): New explicit instantiations.\n\t* include/bits/std_abs.h (abs): New overloads for\n\t_Float{16,32,64,128} and __gnu_cxx::__bfloat16_t.\n\t* include/bits/c++config (_GLIBCXX_LDOUBLE_IS_IEEE_BINARY128): Define\n\tif long double is IEEE quad.\n\t(__gnu_cxx::__bfloat16_t): New using.\n\t* include/c_global/cmath (acos, asin, atan, atan2, ceil, cos, cosh,\n\texp, fabs, floor, fmod, frexp, ldexp, log, log10, modf, pow, sin,\n\tsinh, sqrt, tan, tanh, fpclassify, isfinite, isinf, isnan, isnormal,\n\tsignbit, isgreater, isgreaterequal, isless, islessequal,\n\tislessgreater, isunordered, acosh, asinh, atanh, cbrt, copysign, erf,\n\terfc, exp2, expm1, fdim, fma, fmax, fmin, hypot, ilogb, lgamma,\n\tllrint, llround, log1p, log2, logb, lrint, lround, nearbyint,\n\tnextafter, remainder, rint, round, scalbln, scalbn, tgamma, trunc,\n\tlerp): New overloads with _Float{16,32,64,128} or\n\t__gnu_cxx::__bfloat16_t types.\n\t* config/os/gnu-linux/os_defines.h (_GLIBCXX_HAVE_FLOAT128_MATH):\n\tPrepare for definition if glibc 2.26 and later implements *f128 APIs\n\tbut comment out the actual definition for now.\n\t* include/ext/type_traits.h (__promote<_Float16>, __promote<_Float32>,\n\t__promote<_Float64>, __promote<_Float128>,\n\t__promote<__gnu_cxx::__bfloat16_t>): New specializations.\n\t* include/Makefile.am (std_headers): Add stdfloat.\n\t* include/Makefile.in: Regenerated.\n\t* include/precompiled/stdc++.h: Include stdfloat.\n\t* testsuite/18_support/headers/stdfloat/types_std.cc: New test.\n\t* testsuite/18_support/headers/limits/synopsis_cxx23.cc: New test.\n\t* testsuite/26_numerics/headers/cmath/c99_classification_macros_c++23.cc:\n\tNew test.\n\t* testsuite/26_numerics/headers/cmath/functions_std_c++23.cc: New test.\n\t* testsuite/26_numerics/numbers/4.cc: New test.\n\t* testsuite/29_atomics/atomic_float/requirements_cxx23.cc: New test.", "tree": {"sha": "baec5306bacfffa31842bd6d26b5afa8c45114f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/baec5306bacfffa31842bd6d26b5afa8c45114f5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a23225fb4f764dfc3e3e729c7d7238f03f282aaa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a23225fb4f764dfc3e3e729c7d7238f03f282aaa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a23225fb4f764dfc3e3e729c7d7238f03f282aaa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a23225fb4f764dfc3e3e729c7d7238f03f282aaa/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4dda30e9910c4f04a6258b053401249e213f29be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4dda30e9910c4f04a6258b053401249e213f29be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4dda30e9910c4f04a6258b053401249e213f29be"}], "stats": {"total": 3047, "additions": 2885, "deletions": 162}, "files": [{"sha": "e5b640a073854f8f1f24d6ef517fda28b14ca8ce", "filename": "libstdc++-v3/config/os/gnu-linux/os_defines.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a23225fb4f764dfc3e3e729c7d7238f03f282aaa/libstdc%2B%2B-v3%2Fconfig%2Fos%2Fgnu-linux%2Fos_defines.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a23225fb4f764dfc3e3e729c7d7238f03f282aaa/libstdc%2B%2B-v3%2Fconfig%2Fos%2Fgnu-linux%2Fos_defines.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fos%2Fgnu-linux%2Fos_defines.h?ref=a23225fb4f764dfc3e3e729c7d7238f03f282aaa", "patch": "@@ -49,6 +49,17 @@\n // version dynamically in case it has changed since libstdc++ was configured.\n #define _GLIBCXX_NO_OBSOLETE_ISINF_ISNAN_DYNAMIC __GLIBC_PREREQ(2,23)\n \n+// Glibc 2.26 on i?86/x86-64/ia64/ppc64le added *f128 support.\n+// Glibc 2.27 added it also on many other arches but those have IEEE quad\n+// long double.\n+#if __GLIBC_PREREQ(2, 26) \\\n+    && (defined(__i386__) || defined(__x86_64__) || defined (__ia64__) \\\n+\t|| (defined(__powerpc__) && defined(_ARCH_PWR8) \\\n+\t    && defined(__LITTLE_ENDIAN__) && (_CALL_ELF == 2) \\\n+\t    && defined(__FLOAT128__)))\n+//# define _GLIBCXX_HAVE_FLOAT128_MATH 1\n+#endif\n+\n #if __GLIBC_PREREQ(2, 27)\n // Since glibc 2.27 pthread_self() is usable without linking to libpthread.\n # define _GLIBCXX_NATIVE_THREAD_ID pthread_self()"}, {"sha": "96137a6621ae2714bac42c980ab789fbe5ac07ae", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a23225fb4f764dfc3e3e729c7d7238f03f282aaa/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a23225fb4f764dfc3e3e729c7d7238f03f282aaa/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=a23225fb4f764dfc3e3e729c7d7238f03f282aaa", "patch": "@@ -95,6 +95,7 @@ std_headers = \\\n \t${std_srcdir}/stack \\\n \t${std_srcdir}/stacktrace \\\n \t${std_srcdir}/stdexcept \\\n+\t${std_srcdir}/stdfloat \\\n \t${std_srcdir}/stop_token \\\n \t${std_srcdir}/streambuf \\\n \t${std_srcdir}/string \\"}, {"sha": "dac77654bdf750b63f50aaaa88185591da4efda3", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a23225fb4f764dfc3e3e729c7d7238f03f282aaa/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a23225fb4f764dfc3e3e729c7d7238f03f282aaa/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=a23225fb4f764dfc3e3e729c7d7238f03f282aaa", "patch": "@@ -452,6 +452,7 @@ std_freestanding = \\\n @GLIBCXX_HOSTED_TRUE@\t${std_srcdir}/stack \\\n @GLIBCXX_HOSTED_TRUE@\t${std_srcdir}/stacktrace \\\n @GLIBCXX_HOSTED_TRUE@\t${std_srcdir}/stdexcept \\\n+@GLIBCXX_HOSTED_TRUE@\t${std_srcdir}/stdfloat \\\n @GLIBCXX_HOSTED_TRUE@\t${std_srcdir}/stop_token \\\n @GLIBCXX_HOSTED_TRUE@\t${std_srcdir}/streambuf \\\n @GLIBCXX_HOSTED_TRUE@\t${std_srcdir}/string \\"}, {"sha": "50406066afe00e93e6cc8f9dd463ad3838507c97", "filename": "libstdc++-v3/include/bits/c++config", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a23225fb4f764dfc3e3e729c7d7238f03f282aaa/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fc%2B%2Bconfig", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a23225fb4f764dfc3e3e729c7d7238f03f282aaa/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fc%2B%2Bconfig", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fc%2B%2Bconfig?ref=a23225fb4f764dfc3e3e729c7d7238f03f282aaa", "patch": "@@ -796,6 +796,20 @@ namespace std\n # define _GLIBCXX_DOUBLE_IS_IEEE_BINARY64 1\n #endif\n \n+// Define if long double has the IEEE binary128 format.\n+#if __LDBL_MANT_DIG__ == 113 \\\n+  && __LDBL_MIN_EXP__ == -16381 \\\n+  && __LDBL_MAX_EXP__ == 16384\n+# define _GLIBCXX_LDOUBLE_IS_IEEE_BINARY128 1\n+#endif\n+\n+#ifdef __STDCPP_BFLOAT16_T__\n+namespace __gnu_cxx\n+{\n+  using __bfloat16_t = decltype(0.0bf16);\n+}\n+#endif\n+\n #ifdef __has_builtin\n # ifdef __is_identifier\n // Intel and older Clang require !__is_identifier for some built-ins:"}, {"sha": "3363e71fd666f62f3d5e53381efa85754d1bcd99", "filename": "libstdc++-v3/include/bits/std_abs.h", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a23225fb4f764dfc3e3e729c7d7238f03f282aaa/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_abs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a23225fb4f764dfc3e3e729c7d7238f03f282aaa/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_abs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_abs.h?ref=a23225fb4f764dfc3e3e729c7d7238f03f282aaa", "patch": "@@ -97,6 +97,40 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   abs(__GLIBCXX_TYPE_INT_N_3 __x) { return __x >= 0 ? __x : -__x; }\n #endif\n \n+#if defined(__STDCPP_FLOAT16_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32)\n+  constexpr _Float16\n+  abs(_Float16 __x)\n+  { return _Float16(__builtin_fabsf(__x)); }\n+#endif\n+\n+#if defined(__STDCPP_FLOAT32_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32)\n+  constexpr _Float32\n+  abs(_Float32 __x)\n+  { return __builtin_fabsf(__x); }\n+#endif\n+\n+#if defined(__STDCPP_FLOAT64_T__) && defined(_GLIBCXX_DOUBLE_IS_IEEE_BINARY64)\n+  constexpr _Float64\n+  abs(_Float64 __x)\n+  { return __builtin_fabs(__x); }\n+#endif\n+\n+#if defined(__STDCPP_FLOAT128_T__) && defined(_GLIBCXX_LDOUBLE_IS_IEEE_BINARY128)\n+  constexpr _Float128\n+  abs(_Float128 __x)\n+  { return __builtin_fabsl(__x); }\n+#elif defined(__STDCPP_FLOAT128_T__) && defined(_GLIBCXX_HAVE_FLOAT128_MATH)\n+  constexpr _Float128\n+  abs(_Float128 __x)\n+  { return __builtin_fabsf128(__x); }\n+#endif\n+\n+#if defined(__STDCPP_BFLOAT16_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32)\n+  constexpr __gnu_cxx::__bfloat16_t\n+  abs(__gnu_cxx::__bfloat16_t __x)\n+  { return __gnu_cxx::__bfloat16_t(__builtin_fabsf(__x)); }\n+#endif\n+\n #if !defined(__STRICT_ANSI__) && defined(_GLIBCXX_USE_FLOAT128)\n   __extension__ inline _GLIBCXX_CONSTEXPR\n   __float128"}, {"sha": "81635a03f7ff34982c5c3bb2c6c15e76146e9110", "filename": "libstdc++-v3/include/c_global/cmath", "status": "modified", "additions": 1784, "deletions": 99, "changes": 1883, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a23225fb4f764dfc3e3e729c7d7238f03f282aaa/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcmath", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a23225fb4f764dfc3e3e729c7d7238f03f282aaa/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcmath", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcmath?ref=a23225fb4f764dfc3e3e729c7d7238f03f282aaa", "patch": "@@ -515,6 +515,564 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     tanh(_Tp __x)\n     { return __builtin_tanh(__x); }\n \n+#if defined(__STDCPP_FLOAT16_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32)\n+  constexpr _Float16\n+  acos(_Float16 __x)\n+  { return _Float16(__builtin_acosf(__x)); }\n+\n+  constexpr _Float16\n+  asin(_Float16 __x)\n+  { return _Float16(__builtin_asinf(__x)); }\n+\n+  constexpr _Float16\n+  atan(_Float16 __x)\n+  { return _Float16(__builtin_atanf(__x)); }\n+\n+  constexpr _Float16\n+  atan2(_Float16 __y, _Float16 __x)\n+  { return _Float16(__builtin_atan2f(__y, __x)); }\n+\n+  constexpr _Float16\n+  ceil(_Float16 __x)\n+  { return _Float16(__builtin_ceilf(__x)); }\n+\n+  constexpr _Float16\n+  cos(_Float16 __x)\n+  { return _Float16(__builtin_cosf(__x)); }\n+\n+  constexpr _Float16\n+  cosh(_Float16 __x)\n+  { return _Float16(__builtin_coshf(__x)); }\n+\n+  constexpr _Float16\n+  exp(_Float16 __x)\n+  { return _Float16(__builtin_expf(__x)); }\n+\n+  constexpr _Float16\n+  fabs(_Float16 __x)\n+  { return _Float16(__builtin_fabsf(__x)); }\n+\n+  constexpr _Float16\n+  floor(_Float16 __x)\n+  { return _Float16(__builtin_floorf(__x)); }\n+\n+  constexpr _Float16\n+  fmod(_Float16 __x, _Float16 __y)\n+  { return _Float16(__builtin_fmodf(__x, __y)); }\n+\n+  inline _Float16\n+  frexp(_Float16 __x, int* __exp)\n+  { return _Float16(__builtin_frexpf(__x, __exp)); }\n+\n+  constexpr _Float16\n+  ldexp(_Float16 __x, int __exp)\n+  { return _Float16(__builtin_ldexpf(__x, __exp)); }\n+\n+  constexpr _Float16\n+  log(_Float16 __x)\n+  { return _Float16(__builtin_logf(__x)); }\n+\n+  constexpr _Float16\n+  log10(_Float16 __x)\n+  { return _Float16(__builtin_log10f(__x)); }\n+\n+  inline _Float16\n+  modf(_Float16 __x, _Float16* __iptr)\n+  {\n+    float __i, __ret = __builtin_modff(__x, &__i);\n+    *__iptr = _Float16(__i);\n+    return _Float16(__ret);\n+  }\n+\n+  constexpr _Float16\n+  pow(_Float16 __x, _Float16 __y)\n+  { return _Float16(__builtin_powf(__x, __y)); }\n+\n+  constexpr _Float16\n+  sin(_Float16 __x)\n+  { return _Float16(__builtin_sinf(__x)); }\n+\n+  constexpr _Float16\n+  sinh(_Float16 __x)\n+  { return _Float16(__builtin_sinhf(__x)); }\n+\n+  constexpr _Float16\n+  sqrt(_Float16 __x)\n+  { return _Float16(__builtin_sqrtf(__x)); }\n+\n+  constexpr _Float16\n+  tan(_Float16 __x)\n+  { return _Float16(__builtin_tanf(__x)); }\n+\n+  constexpr _Float16\n+  tanh(_Float16 __x)\n+  { return _Float16(__builtin_tanhf(__x)); }\n+#endif\n+\n+#if defined(__STDCPP_FLOAT32_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32)\n+  constexpr _Float32\n+  acos(_Float32 __x)\n+  { return __builtin_acosf(__x); }\n+\n+  constexpr _Float32\n+  asin(_Float32 __x)\n+  { return __builtin_asinf(__x); }\n+\n+  constexpr _Float32\n+  atan(_Float32 __x)\n+  { return __builtin_atanf(__x); }\n+\n+  constexpr _Float32\n+  atan2(_Float32 __y, _Float32 __x)\n+  { return __builtin_atan2f(__y, __x); }\n+\n+  constexpr _Float32\n+  ceil(_Float32 __x)\n+  { return __builtin_ceilf(__x); }\n+\n+  constexpr _Float32\n+  cos(_Float32 __x)\n+  { return __builtin_cosf(__x); }\n+\n+  constexpr _Float32\n+  cosh(_Float32 __x)\n+  { return __builtin_coshf(__x); }\n+\n+  constexpr _Float32\n+  exp(_Float32 __x)\n+  { return __builtin_expf(__x); }\n+\n+  constexpr _Float32\n+  fabs(_Float32 __x)\n+  { return __builtin_fabsf(__x); }\n+\n+  constexpr _Float32\n+  floor(_Float32 __x)\n+  { return __builtin_floorf(__x); }\n+\n+  constexpr _Float32\n+  fmod(_Float32 __x, _Float32 __y)\n+  { return __builtin_fmodf(__x, __y); }\n+\n+  inline _Float32\n+  frexp(_Float32 __x, int* __exp)\n+  { return __builtin_frexpf(__x, __exp); }\n+\n+  constexpr _Float32\n+  ldexp(_Float32 __x, int __exp)\n+  { return __builtin_ldexpf(__x, __exp); }\n+\n+  constexpr _Float32\n+  log(_Float32 __x)\n+  { return __builtin_logf(__x); }\n+\n+  constexpr _Float32\n+  log10(_Float32 __x)\n+  { return __builtin_log10f(__x); }\n+\n+  inline _Float32\n+  modf(_Float32 __x, _Float32* __iptr)\n+  {\n+    float __i, __ret = __builtin_modff(__x, &__i);\n+    *__iptr = __i;\n+    return __ret;\n+  }\n+\n+  constexpr _Float32\n+  pow(_Float32 __x, _Float32 __y)\n+  { return __builtin_powf(__x, __y); }\n+\n+  constexpr _Float32\n+  sin(_Float32 __x)\n+  { return __builtin_sinf(__x); }\n+\n+  constexpr _Float32\n+  sinh(_Float32 __x)\n+  { return __builtin_sinhf(__x); }\n+\n+  constexpr _Float32\n+  sqrt(_Float32 __x)\n+  { return __builtin_sqrtf(__x); }\n+\n+  constexpr _Float32\n+  tan(_Float32 __x)\n+  { return __builtin_tanf(__x); }\n+\n+  constexpr _Float32\n+  tanh(_Float32 __x)\n+  { return __builtin_tanhf(__x); }\n+#endif\n+\n+#if defined(__STDCPP_FLOAT64_T__) && defined(_GLIBCXX_DOUBLE_IS_IEEE_BINARY64)\n+  constexpr _Float64\n+  acos(_Float64 __x)\n+  { return __builtin_acos(__x); }\n+\n+  constexpr _Float64\n+  asin(_Float64 __x)\n+  { return __builtin_asin(__x); }\n+\n+  constexpr _Float64\n+  atan(_Float64 __x)\n+  { return __builtin_atan(__x); }\n+\n+  constexpr _Float64\n+  atan2(_Float64 __y, _Float64 __x)\n+  { return __builtin_atan2(__y, __x); }\n+\n+  constexpr _Float64\n+  ceil(_Float64 __x)\n+  { return __builtin_ceil(__x); }\n+\n+  constexpr _Float64\n+  cos(_Float64 __x)\n+  { return __builtin_cos(__x); }\n+\n+  constexpr _Float64\n+  cosh(_Float64 __x)\n+  { return __builtin_cosh(__x); }\n+\n+  constexpr _Float64\n+  exp(_Float64 __x)\n+  { return __builtin_exp(__x); }\n+\n+  constexpr _Float64\n+  fabs(_Float64 __x)\n+  { return __builtin_fabs(__x); }\n+\n+  constexpr _Float64\n+  floor(_Float64 __x)\n+  { return __builtin_floor(__x); }\n+\n+  constexpr _Float64\n+  fmod(_Float64 __x, _Float64 __y)\n+  { return __builtin_fmod(__x, __y); }\n+\n+  inline _Float64\n+  frexp(_Float64 __x, int* __exp)\n+  { return __builtin_frexp(__x, __exp); }\n+\n+  constexpr _Float64\n+  ldexp(_Float64 __x, int __exp)\n+  { return __builtin_ldexp(__x, __exp); }\n+\n+  constexpr _Float64\n+  log(_Float64 __x)\n+  { return __builtin_log(__x); }\n+\n+  constexpr _Float64\n+  log10(_Float64 __x)\n+  { return __builtin_log10(__x); }\n+\n+  inline _Float64\n+  modf(_Float64 __x, _Float64* __iptr)\n+  {\n+    double __i, __ret = __builtin_modf(__x, &__i);\n+    *__iptr = __i;\n+    return __ret;\n+  }\n+\n+  constexpr _Float64\n+  pow(_Float64 __x, _Float64 __y)\n+  { return __builtin_pow(__x, __y); }\n+\n+  constexpr _Float64\n+  sin(_Float64 __x)\n+  { return __builtin_sin(__x); }\n+\n+  constexpr _Float64\n+  sinh(_Float64 __x)\n+  { return __builtin_sinh(__x); }\n+\n+  constexpr _Float64\n+  sqrt(_Float64 __x)\n+  { return __builtin_sqrt(__x); }\n+\n+  constexpr _Float64\n+  tan(_Float64 __x)\n+  { return __builtin_tan(__x); }\n+\n+  constexpr _Float64\n+  tanh(_Float64 __x)\n+  { return __builtin_tanh(__x); }\n+#endif\n+\n+#if defined(__STDCPP_FLOAT128_T__) && defined(_GLIBCXX_LDOUBLE_IS_IEEE_BINARY128)\n+  constexpr _Float128\n+  acos(_Float128 __x)\n+  { return __builtin_acosl(__x); }\n+\n+  constexpr _Float128\n+  asin(_Float128 __x)\n+  { return __builtin_asinl(__x); }\n+\n+  constexpr _Float128\n+  atan(_Float128 __x)\n+  { return __builtin_atanl(__x); }\n+\n+  constexpr _Float128\n+  atan2(_Float128 __y, _Float128 __x)\n+  { return __builtin_atan2l(__y, __x); }\n+\n+  constexpr _Float128\n+  ceil(_Float128 __x)\n+  { return __builtin_ceill(__x); }\n+\n+  constexpr _Float128\n+  cos(_Float128 __x)\n+  { return __builtin_cosl(__x); }\n+\n+  constexpr _Float128\n+  cosh(_Float128 __x)\n+  { return __builtin_coshl(__x); }\n+\n+  constexpr _Float128\n+  exp(_Float128 __x)\n+  { return __builtin_expl(__x); }\n+\n+  constexpr _Float128\n+  fabs(_Float128 __x)\n+  { return __builtin_fabsl(__x); }\n+\n+  constexpr _Float128\n+  floor(_Float128 __x)\n+  { return __builtin_floorl(__x); }\n+\n+  constexpr _Float128\n+  fmod(_Float128 __x, _Float128 __y)\n+  { return __builtin_fmodl(__x, __y); }\n+\n+  inline _Float128\n+  frexp(_Float128 __x, int* __exp)\n+  { return __builtin_frexpl(__x, __exp); }\n+\n+  constexpr _Float128\n+  ldexp(_Float128 __x, int __exp)\n+  { return __builtin_ldexpl(__x, __exp); }\n+\n+  constexpr _Float128\n+  log(_Float128 __x)\n+  { return __builtin_logl(__x); }\n+\n+  constexpr _Float128\n+  log10(_Float128 __x)\n+  { return __builtin_log10l(__x); }\n+\n+  inline _Float128\n+  modf(_Float128 __x, _Float128* __iptr)\n+  {\n+    long double __i, __ret = __builtin_modfl(__x, &__i);\n+    *__iptr = __i;\n+    return __ret;\n+  }\n+\n+  constexpr _Float128\n+  pow(_Float128 __x, _Float128 __y)\n+  { return __builtin_powl(__x, __y); }\n+\n+  constexpr _Float128\n+  sin(_Float128 __x)\n+  { return __builtin_sinl(__x); }\n+\n+  constexpr _Float128\n+  sinh(_Float128 __x)\n+  { return __builtin_sinhl(__x); }\n+\n+  constexpr _Float128\n+  sqrt(_Float128 __x)\n+  { return __builtin_sqrtl(__x); }\n+\n+  constexpr _Float128\n+  tan(_Float128 __x)\n+  { return __builtin_tanl(__x); }\n+\n+  constexpr _Float128\n+  tanh(_Float128 __x)\n+  { return __builtin_tanhl(__x); }\n+#elif defined(__STDCPP_FLOAT128_T__) && defined(_GLIBCXX_HAVE_FLOAT128_MATH)\n+  constexpr _Float128\n+  acos(_Float128 __x)\n+  { return __builtin_acosf128(__x); }\n+\n+  constexpr _Float128\n+  asin(_Float128 __x)\n+  { return __builtin_asinf128(__x); }\n+\n+  constexpr _Float128\n+  atan(_Float128 __x)\n+  { return __builtin_atanf128(__x); }\n+\n+  constexpr _Float128\n+  atan2(_Float128 __y, _Float128 __x)\n+  { return __builtin_atan2f128(__y, __x); }\n+\n+  constexpr _Float128\n+  ceil(_Float128 __x)\n+  { return __builtin_ceilf128(__x); }\n+\n+  constexpr _Float128\n+  cos(_Float128 __x)\n+  { return __builtin_cosf128(__x); }\n+\n+  constexpr _Float128\n+  cosh(_Float128 __x)\n+  { return __builtin_coshf128(__x); }\n+\n+  constexpr _Float128\n+  exp(_Float128 __x)\n+  { return __builtin_expf128(__x); }\n+\n+  constexpr _Float128\n+  fabs(_Float128 __x)\n+  { return __builtin_fabsf128(__x); }\n+\n+  constexpr _Float128\n+  floor(_Float128 __x)\n+  { return __builtin_floorf128(__x); }\n+\n+  constexpr _Float128\n+  fmod(_Float128 __x, _Float128 __y)\n+  { return __builtin_fmodf128(__x, __y); }\n+\n+  inline _Float128\n+  frexp(_Float128 __x, int* __exp)\n+  { return __builtin_frexpf128(__x, __exp); }\n+\n+  constexpr _Float128\n+  ldexp(_Float128 __x, int __exp)\n+  { return __builtin_ldexpf128(__x, __exp); }\n+\n+  constexpr _Float128\n+  log(_Float128 __x)\n+  { return __builtin_logf128(__x); }\n+\n+  constexpr _Float128\n+  log10(_Float128 __x)\n+  { return __builtin_log10f128(__x); }\n+\n+  inline _Float128\n+  modf(_Float128 __x, _Float128* __iptr)\n+  { return __builtin_modff128(__x, __iptr); }\n+\n+  constexpr _Float128\n+  pow(_Float128 __x, _Float128 __y)\n+  { return __builtin_powf128(__x, __y); }\n+\n+  constexpr _Float128\n+  sin(_Float128 __x)\n+  { return __builtin_sinf128(__x); }\n+\n+  constexpr _Float128\n+  sinh(_Float128 __x)\n+  { return __builtin_sinhf128(__x); }\n+\n+  constexpr _Float128\n+  sqrt(_Float128 __x)\n+  { return __builtin_sqrtf128(__x); }\n+\n+  constexpr _Float128\n+  tan(_Float128 __x)\n+  { return __builtin_tanf128(__x); }\n+\n+  constexpr _Float128\n+  tanh(_Float128 __x)\n+  { return __builtin_tanhf128(__x); }\n+#endif\n+\n+#if defined(__STDCPP_BFLOAT16_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32)\n+  constexpr __gnu_cxx::__bfloat16_t\n+  acos(__gnu_cxx::__bfloat16_t __x)\n+  { return __gnu_cxx::__bfloat16_t(__builtin_acosf(__x)); }\n+\n+  constexpr __gnu_cxx::__bfloat16_t\n+  asin(__gnu_cxx::__bfloat16_t __x)\n+  { return __gnu_cxx::__bfloat16_t(__builtin_asinf(__x)); }\n+\n+  constexpr __gnu_cxx::__bfloat16_t\n+  atan(__gnu_cxx::__bfloat16_t __x)\n+  { return __gnu_cxx::__bfloat16_t(__builtin_atanf(__x)); }\n+\n+  constexpr __gnu_cxx::__bfloat16_t\n+  atan2(__gnu_cxx::__bfloat16_t __y, __gnu_cxx::__bfloat16_t __x)\n+  { return __gnu_cxx::__bfloat16_t(__builtin_atan2f(__y, __x)); }\n+\n+  constexpr __gnu_cxx::__bfloat16_t\n+  ceil(__gnu_cxx::__bfloat16_t __x)\n+  { return __gnu_cxx::__bfloat16_t(__builtin_ceilf(__x)); }\n+\n+  constexpr __gnu_cxx::__bfloat16_t\n+  cos(__gnu_cxx::__bfloat16_t __x)\n+  { return __gnu_cxx::__bfloat16_t(__builtin_cosf(__x)); }\n+\n+  constexpr __gnu_cxx::__bfloat16_t\n+  cosh(__gnu_cxx::__bfloat16_t __x)\n+  { return __gnu_cxx::__bfloat16_t(__builtin_coshf(__x)); }\n+\n+  constexpr __gnu_cxx::__bfloat16_t\n+  exp(__gnu_cxx::__bfloat16_t __x)\n+  { return __gnu_cxx::__bfloat16_t(__builtin_expf(__x)); }\n+\n+  constexpr __gnu_cxx::__bfloat16_t\n+  fabs(__gnu_cxx::__bfloat16_t __x)\n+  { return __gnu_cxx::__bfloat16_t(__builtin_fabsf(__x)); }\n+\n+  constexpr __gnu_cxx::__bfloat16_t\n+  floor(__gnu_cxx::__bfloat16_t __x)\n+  { return __gnu_cxx::__bfloat16_t(__builtin_floorf(__x)); }\n+\n+  constexpr __gnu_cxx::__bfloat16_t\n+  fmod(__gnu_cxx::__bfloat16_t __x, __gnu_cxx::__bfloat16_t __y)\n+  { return __gnu_cxx::__bfloat16_t(__builtin_fmodf(__x, __y)); }\n+\n+  inline __gnu_cxx::__bfloat16_t\n+  frexp(__gnu_cxx::__bfloat16_t __x, int* __exp)\n+  { return __gnu_cxx::__bfloat16_t(__builtin_frexpf(__x, __exp)); }\n+\n+  constexpr __gnu_cxx::__bfloat16_t\n+  ldexp(__gnu_cxx::__bfloat16_t __x, int __exp)\n+  { return __gnu_cxx::__bfloat16_t(__builtin_ldexpf(__x, __exp)); }\n+\n+  constexpr __gnu_cxx::__bfloat16_t\n+  log(__gnu_cxx::__bfloat16_t __x)\n+  { return __gnu_cxx::__bfloat16_t(__builtin_logf(__x)); }\n+\n+  constexpr __gnu_cxx::__bfloat16_t\n+  log10(__gnu_cxx::__bfloat16_t __x)\n+  { return __gnu_cxx::__bfloat16_t(__builtin_log10f(__x)); }\n+\n+  inline __gnu_cxx::__bfloat16_t\n+  modf(__gnu_cxx::__bfloat16_t __x, __gnu_cxx::__bfloat16_t* __iptr)\n+  {\n+    float __i, __ret = __builtin_modff(__x, &__i);\n+    *__iptr = __gnu_cxx::__bfloat16_t(__i);\n+    return __gnu_cxx::__bfloat16_t(__ret);\n+  }\n+\n+  constexpr __gnu_cxx::__bfloat16_t\n+  pow(__gnu_cxx::__bfloat16_t __x, __gnu_cxx::__bfloat16_t __y)\n+  { return __gnu_cxx::__bfloat16_t(__builtin_powf(__x, __y)); }\n+\n+  constexpr __gnu_cxx::__bfloat16_t\n+  sin(__gnu_cxx::__bfloat16_t __x)\n+  { return __gnu_cxx::__bfloat16_t(__builtin_sinf(__x)); }\n+\n+  constexpr __gnu_cxx::__bfloat16_t\n+  sinh(__gnu_cxx::__bfloat16_t __x)\n+  { return __gnu_cxx::__bfloat16_t(__builtin_sinhf(__x)); }\n+\n+  constexpr __gnu_cxx::__bfloat16_t\n+  sqrt(__gnu_cxx::__bfloat16_t __x)\n+  { return __gnu_cxx::__bfloat16_t(__builtin_sqrtf(__x)); }\n+\n+  constexpr __gnu_cxx::__bfloat16_t\n+  tan(__gnu_cxx::__bfloat16_t __x)\n+  { return __gnu_cxx::__bfloat16_t(__builtin_tanf(__x)); }\n+\n+  constexpr __gnu_cxx::__bfloat16_t\n+  tanh(__gnu_cxx::__bfloat16_t __x)\n+  { return __gnu_cxx::__bfloat16_t(__builtin_tanhf(__x)); }\n+#endif\n+\n #if _GLIBCXX_USE_C99_MATH\n #if !_GLIBCXX_USE_C99_FP_MACROS_DYNAMIC\n \n@@ -948,84 +1506,340 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     }\n \n #endif // C++11\n-#endif /* _GLIBCXX_USE_C99_FP_MACROS_DYNAMIC */\n-#endif /* _GLIBCXX_USE_C99_MATH */\n \n-#if __cplusplus >= 201103L\n+#ifdef __STDCPP_FLOAT16_T__\n+  constexpr int\n+  fpclassify(_Float16 __x)\n+  { return __builtin_fpclassify(FP_NAN, FP_INFINITE, FP_NORMAL,\n+\t\t\t\tFP_SUBNORMAL, FP_ZERO, __x); }\n \n-#ifdef _GLIBCXX_USE_C99_MATH_TR1\n+  constexpr bool\n+  isfinite(_Float16 __x)\n+  { return __builtin_isfinite(__x); }\n \n-#undef acosh\n-#undef acoshf\n-#undef acoshl\n-#undef asinh\n-#undef asinhf\n-#undef asinhl\n-#undef atanh\n-#undef atanhf\n-#undef atanhl\n-#undef cbrt\n-#undef cbrtf\n-#undef cbrtl\n-#undef copysign\n-#undef copysignf\n-#undef copysignl\n-#undef erf\n-#undef erff\n-#undef erfl\n-#undef erfc\n-#undef erfcf\n-#undef erfcl\n-#undef exp2\n-#undef exp2f\n-#undef exp2l\n-#undef expm1\n-#undef expm1f\n-#undef expm1l\n-#undef fdim\n-#undef fdimf\n-#undef fdiml\n-#undef fma\n-#undef fmaf\n-#undef fmal\n-#undef fmax\n-#undef fmaxf\n-#undef fmaxl\n-#undef fmin\n-#undef fminf\n-#undef fminl\n-#undef hypot\n-#undef hypotf\n-#undef hypotl\n-#undef ilogb\n-#undef ilogbf\n-#undef ilogbl\n-#undef lgamma\n-#undef lgammaf\n-#undef lgammal\n-#ifndef _GLIBCXX_NO_C99_ROUNDING_FUNCS\n-#undef llrint\n-#undef llrintf\n-#undef llrintl\n-#undef llround\n-#undef llroundf\n-#undef llroundl\n+  constexpr bool\n+  isinf(_Float16 __x)\n+  { return __builtin_isinf(__x); }\n+\n+  constexpr bool\n+  isnan(_Float16 __x)\n+  { return __builtin_isnan(__x); }\n+\n+  constexpr bool\n+  isnormal(_Float16 __x)\n+  { return __builtin_isnormal(__x); }\n+\n+  constexpr bool\n+  signbit(_Float16 __x)\n+  { return __builtin_signbit(__x); }\n+\n+  constexpr bool\n+  isgreater(_Float16 __x, _Float16 __y)\n+  { return __builtin_isgreater(__x, __y); }\n+\n+  constexpr bool\n+  isgreaterequal(_Float16 __x, _Float16 __y)\n+  { return __builtin_isgreaterequal(__x, __y); }\n+\n+  constexpr bool\n+  isless(_Float16 __x, _Float16 __y)\n+  { return __builtin_isless(__x, __y); }\n+\n+  constexpr bool\n+  islessequal(_Float16 __x, _Float16 __y)\n+  { return __builtin_islessequal(__x, __y); }\n+\n+  constexpr bool\n+  islessgreater(_Float16 __x, _Float16 __y)\n+  { return __builtin_islessgreater(__x, __y); }\n+\n+  constexpr bool\n+  isunordered(_Float16 __x, _Float16 __y)\n+  { return __builtin_isunordered(__x, __y); }\n #endif\n-#undef log1p\n-#undef log1pf\n-#undef log1pl\n-#undef log2\n-#undef log2f\n-#undef log2l\n-#undef logb\n-#undef logbf\n-#undef logbl\n-#undef lrint\n-#undef lrintf\n-#undef lrintl\n-#undef lround\n-#undef lroundf\n-#undef lroundl\n+\n+#ifdef __STDCPP_FLOAT32_T__\n+  constexpr int\n+  fpclassify(_Float32 __x)\n+  { return __builtin_fpclassify(FP_NAN, FP_INFINITE, FP_NORMAL,\n+\t\t\t\tFP_SUBNORMAL, FP_ZERO, __x); }\n+\n+  constexpr bool\n+  isfinite(_Float32 __x)\n+  { return __builtin_isfinite(__x); }\n+\n+  constexpr bool\n+  isinf(_Float32 __x)\n+  { return __builtin_isinf(__x); }\n+\n+  constexpr bool\n+  isnan(_Float32 __x)\n+  { return __builtin_isnan(__x); }\n+\n+  constexpr bool\n+  isnormal(_Float32 __x)\n+  { return __builtin_isnormal(__x); }\n+\n+  constexpr bool\n+  signbit(_Float32 __x)\n+  { return __builtin_signbit(__x); }\n+\n+  constexpr bool\n+  isgreater(_Float32 __x, _Float32 __y)\n+  { return __builtin_isgreater(__x, __y); }\n+\n+  constexpr bool\n+  isgreaterequal(_Float32 __x, _Float32 __y)\n+  { return __builtin_isgreaterequal(__x, __y); }\n+\n+  constexpr bool\n+  isless(_Float32 __x, _Float32 __y)\n+  { return __builtin_isless(__x, __y); }\n+\n+  constexpr bool\n+  islessequal(_Float32 __x, _Float32 __y)\n+  { return __builtin_islessequal(__x, __y); }\n+\n+  constexpr bool\n+  islessgreater(_Float32 __x, _Float32 __y)\n+  { return __builtin_islessgreater(__x, __y); }\n+\n+  constexpr bool\n+  isunordered(_Float32 __x, _Float32 __y)\n+  { return __builtin_isunordered(__x, __y); }\n+#endif\n+\n+#ifdef __STDCPP_FLOAT64_T__\n+  constexpr int\n+  fpclassify(_Float64 __x)\n+  { return __builtin_fpclassify(FP_NAN, FP_INFINITE, FP_NORMAL,\n+\t\t\t\tFP_SUBNORMAL, FP_ZERO, __x); }\n+\n+  constexpr bool\n+  isfinite(_Float64 __x)\n+  { return __builtin_isfinite(__x); }\n+\n+  constexpr bool\n+  isinf(_Float64 __x)\n+  { return __builtin_isinf(__x); }\n+\n+  constexpr bool\n+  isnan(_Float64 __x)\n+  { return __builtin_isnan(__x); }\n+\n+  constexpr bool\n+  isnormal(_Float64 __x)\n+  { return __builtin_isnormal(__x); }\n+\n+  constexpr bool\n+  signbit(_Float64 __x)\n+  { return __builtin_signbit(__x); }\n+\n+  constexpr bool\n+  isgreater(_Float64 __x, _Float64 __y)\n+  { return __builtin_isgreater(__x, __y); }\n+\n+  constexpr bool\n+  isgreaterequal(_Float64 __x, _Float64 __y)\n+  { return __builtin_isgreaterequal(__x, __y); }\n+\n+  constexpr bool\n+  isless(_Float64 __x, _Float64 __y)\n+  { return __builtin_isless(__x, __y); }\n+\n+  constexpr bool\n+  islessequal(_Float64 __x, _Float64 __y)\n+  { return __builtin_islessequal(__x, __y); }\n+\n+  constexpr bool\n+  islessgreater(_Float64 __x, _Float64 __y)\n+  { return __builtin_islessgreater(__x, __y); }\n+\n+  constexpr bool\n+  isunordered(_Float64 __x, _Float64 __y)\n+  { return __builtin_isunordered(__x, __y); }\n+#endif\n+\n+#ifdef __STDCPP_FLOAT128_T__\n+  constexpr int\n+  fpclassify(_Float128 __x)\n+  { return __builtin_fpclassify(FP_NAN, FP_INFINITE, FP_NORMAL,\n+\t\t\t\tFP_SUBNORMAL, FP_ZERO, __x); }\n+\n+  constexpr bool\n+  isfinite(_Float128 __x)\n+  { return __builtin_isfinite(__x); }\n+\n+  constexpr bool\n+  isinf(_Float128 __x)\n+  { return __builtin_isinf(__x); }\n+\n+  constexpr bool\n+  isnan(_Float128 __x)\n+  { return __builtin_isnan(__x); }\n+\n+  constexpr bool\n+  isnormal(_Float128 __x)\n+  { return __builtin_isnormal(__x); }\n+\n+  constexpr bool\n+  signbit(_Float128 __x)\n+  { return __builtin_signbit(__x); }\n+\n+  constexpr bool\n+  isgreater(_Float128 __x, _Float128 __y)\n+  { return __builtin_isgreater(__x, __y); }\n+\n+  constexpr bool\n+  isgreaterequal(_Float128 __x, _Float128 __y)\n+  { return __builtin_isgreaterequal(__x, __y); }\n+\n+  constexpr bool\n+  isless(_Float128 __x, _Float128 __y)\n+  { return __builtin_isless(__x, __y); }\n+\n+  constexpr bool\n+  islessequal(_Float128 __x, _Float128 __y)\n+  { return __builtin_islessequal(__x, __y); }\n+\n+  constexpr bool\n+  islessgreater(_Float128 __x, _Float128 __y)\n+  { return __builtin_islessgreater(__x, __y); }\n+\n+  constexpr bool\n+  isunordered(_Float128 __x, _Float128 __y)\n+  { return __builtin_isunordered(__x, __y); }\n+#endif\n+\n+#ifdef __STDCPP_BFLOAT16_T__\n+  constexpr int\n+  fpclassify(__gnu_cxx::__bfloat16_t __x)\n+  { return __builtin_fpclassify(FP_NAN, FP_INFINITE, FP_NORMAL,\n+\t\t\t\tFP_SUBNORMAL, FP_ZERO, __x); }\n+\n+  constexpr bool\n+  isfinite(__gnu_cxx::__bfloat16_t __x)\n+  { return __builtin_isfinite(__x); }\n+\n+  constexpr bool\n+  isinf(__gnu_cxx::__bfloat16_t __x)\n+  { return __builtin_isinf(__x); }\n+\n+  constexpr bool\n+  isnan(__gnu_cxx::__bfloat16_t __x)\n+  { return __builtin_isnan(__x); }\n+\n+  constexpr bool\n+  isnormal(__gnu_cxx::__bfloat16_t __x)\n+  { return __builtin_isnormal(__x); }\n+\n+  constexpr bool\n+  signbit(__gnu_cxx::__bfloat16_t __x)\n+  { return __builtin_signbit(__x); }\n+\n+  constexpr bool\n+  isgreater(__gnu_cxx::__bfloat16_t __x, __gnu_cxx::__bfloat16_t __y)\n+  { return __builtin_isgreater(__x, __y); }\n+\n+  constexpr bool\n+  isgreaterequal(__gnu_cxx::__bfloat16_t __x, __gnu_cxx::__bfloat16_t __y)\n+  { return __builtin_isgreaterequal(__x, __y); }\n+\n+  constexpr bool\n+  isless(__gnu_cxx::__bfloat16_t __x, __gnu_cxx::__bfloat16_t __y)\n+  { return __builtin_isless(__x, __y); }\n+\n+  constexpr bool\n+  islessequal(__gnu_cxx::__bfloat16_t __x, __gnu_cxx::__bfloat16_t __y)\n+  { return __builtin_islessequal(__x, __y); }\n+\n+  constexpr bool\n+  islessgreater(__gnu_cxx::__bfloat16_t __x, __gnu_cxx::__bfloat16_t __y)\n+  { return __builtin_islessgreater(__x, __y); }\n+\n+  constexpr bool\n+  isunordered(__gnu_cxx::__bfloat16_t __x, __gnu_cxx::__bfloat16_t __y)\n+  { return __builtin_isunordered(__x, __y); }\n+#endif\n+\n+#endif /* _GLIBCXX_USE_C99_FP_MACROS_DYNAMIC */\n+#endif /* _GLIBCXX_USE_C99_MATH */\n+\n+#if __cplusplus >= 201103L\n+\n+#ifdef _GLIBCXX_USE_C99_MATH_TR1\n+\n+#undef acosh\n+#undef acoshf\n+#undef acoshl\n+#undef asinh\n+#undef asinhf\n+#undef asinhl\n+#undef atanh\n+#undef atanhf\n+#undef atanhl\n+#undef cbrt\n+#undef cbrtf\n+#undef cbrtl\n+#undef copysign\n+#undef copysignf\n+#undef copysignl\n+#undef erf\n+#undef erff\n+#undef erfl\n+#undef erfc\n+#undef erfcf\n+#undef erfcl\n+#undef exp2\n+#undef exp2f\n+#undef exp2l\n+#undef expm1\n+#undef expm1f\n+#undef expm1l\n+#undef fdim\n+#undef fdimf\n+#undef fdiml\n+#undef fma\n+#undef fmaf\n+#undef fmal\n+#undef fmax\n+#undef fmaxf\n+#undef fmaxl\n+#undef fmin\n+#undef fminf\n+#undef fminl\n+#undef hypot\n+#undef hypotf\n+#undef hypotl\n+#undef ilogb\n+#undef ilogbf\n+#undef ilogbl\n+#undef lgamma\n+#undef lgammaf\n+#undef lgammal\n+#ifndef _GLIBCXX_NO_C99_ROUNDING_FUNCS\n+#undef llrint\n+#undef llrintf\n+#undef llrintl\n+#undef llround\n+#undef llroundf\n+#undef llroundl\n+#endif\n+#undef log1p\n+#undef log1pf\n+#undef log1pl\n+#undef log2\n+#undef log2f\n+#undef log2l\n+#undef logb\n+#undef logbf\n+#undef logbl\n+#undef lrint\n+#undef lrintf\n+#undef lrintl\n+#undef lround\n+#undef lroundf\n+#undef lroundl\n #undef nan\n #undef nanf\n #undef nanl\n@@ -1843,36 +2657,841 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     { return __builtin_trunc(__x); }\n #endif\n \n-#endif // _GLIBCXX_USE_C99_MATH_TR1\n-#endif // C++11\n+#if defined(__STDCPP_FLOAT16_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32)\n+  constexpr _Float16\n+  acosh(_Float16 __x)\n+  { return _Float16(__builtin_acoshf(__x)); }\n \n-#if __cplusplus >= 201703L\n+  constexpr _Float16\n+  asinh(_Float16 __x)\n+  { return _Float16(__builtin_asinhf(__x)); }\n \n-  // [c.math.hypot3], three-dimensional hypotenuse\n-#define __cpp_lib_hypot 201603L\n+  constexpr _Float16\n+  atanh(_Float16 __x)\n+  { return _Float16(__builtin_atanhf(__x)); }\n \n-  template<typename _Tp>\n-    inline _Tp\n-    __hypot3(_Tp __x, _Tp __y, _Tp __z)\n-    {\n-      __x = std::abs(__x);\n-      __y = std::abs(__y);\n-      __z = std::abs(__z);\n-      if (_Tp __a = __x < __y ? __y < __z ? __z : __y : __x < __z ? __z : __x)\n-\treturn __a * std::sqrt((__x / __a) * (__x / __a)\n-\t\t\t       + (__y / __a) * (__y / __a)\n-\t\t\t       + (__z / __a) * (__z / __a));\n-      else\n-\treturn {};\n-    }\n+  constexpr _Float16\n+  cbrt(_Float16 __x)\n+  { return _Float16(__builtin_cbrtf(__x)); }\n \n-  inline float\n-  hypot(float __x, float __y, float __z)\n-  { return std::__hypot3<float>(__x, __y, __z); }\n+  constexpr _Float16\n+  copysign(_Float16 __x, _Float16 __y)\n+  { return __builtin_copysignf16(__x, __y); }\n \n-  inline double\n-  hypot(double __x, double __y, double __z)\n-  { return std::__hypot3<double>(__x, __y, __z); }\n+  constexpr _Float16\n+  erf(_Float16 __x)\n+  { return _Float16(__builtin_erff(__x)); }\n+\n+  constexpr _Float16\n+  erfc(_Float16 __x)\n+  { return _Float16(__builtin_erfcf(__x)); }\n+\n+  constexpr _Float16\n+  exp2(_Float16 __x)\n+  { return _Float16(__builtin_exp2f(__x)); }\n+\n+  constexpr _Float16\n+  expm1(_Float16 __x)\n+  { return _Float16(__builtin_expm1f(__x)); }\n+\n+  constexpr _Float16\n+  fdim(_Float16 __x, _Float16 __y)\n+  { return _Float16(__builtin_fdimf(__x, __y)); }\n+\n+  constexpr _Float16\n+  fma(_Float16 __x, _Float16 __y, _Float16 __z)\n+  { return _Float16(__builtin_fmaf(__x, __y, __z)); }\n+\n+  constexpr _Float16\n+  fmax(_Float16 __x, _Float16 __y)\n+  { return _Float16(__builtin_fmaxf(__x, __y)); }\n+\n+  constexpr _Float16\n+  fmin(_Float16 __x, _Float16 __y)\n+  { return _Float16(__builtin_fminf(__x, __y)); }\n+\n+  constexpr _Float16\n+  hypot(_Float16 __x, _Float16 __y)\n+  { return _Float16(__builtin_hypotf(__x, __y)); }\n+\n+  constexpr int\n+  ilogb(_Float16 __x)\n+  { return _Float16(__builtin_ilogbf(__x)); }\n+\n+  constexpr _Float16\n+  lgamma(_Float16 __x)\n+  { return _Float16(__builtin_lgammaf(__x)); }\n+\n+  constexpr long long\n+  llrint(_Float16 __x)\n+  { return _Float16(__builtin_llrintf(__x)); }\n+\n+  constexpr long long\n+  llround(_Float16 __x)\n+  { return _Float16(__builtin_llroundf(__x)); }\n+\n+  constexpr _Float16\n+  log1p(_Float16 __x)\n+  { return _Float16(__builtin_log1pf(__x)); }\n+\n+  // DR 568.\n+  constexpr _Float16\n+  log2(_Float16 __x)\n+  { return _Float16(__builtin_log2f(__x)); }\n+\n+  constexpr _Float16\n+  logb(_Float16 __x)\n+  { return _Float16(__builtin_logbf(__x)); }\n+\n+  constexpr long\n+  lrint(_Float16 __x)\n+  { return _Float16(__builtin_lrintf(__x)); }\n+\n+  constexpr long\n+  lround(_Float16 __x)\n+  { return _Float16(__builtin_lroundf(__x)); }\n+\n+  constexpr _Float16\n+  nearbyint(_Float16 __x)\n+  { return _Float16(__builtin_nearbyintf(__x)); }\n+\n+  // nextafter not implemented so far.\n+\n+  constexpr _Float16\n+  remainder(_Float16 __x, _Float16 __y)\n+  { return _Float16(__builtin_remainderf(__x, __y)); }\n+\n+  inline _Float16\n+  remquo(_Float16 __x, _Float16 __y, int* __pquo)\n+  { return _Float16(__builtin_remquof(__x, __y, __pquo)); }\n+\n+  constexpr _Float16\n+  rint(_Float16 __x)\n+  { return _Float16(__builtin_rintf(__x)); }\n+\n+  constexpr _Float16\n+  round(_Float16 __x)\n+  { return _Float16(__builtin_roundf(__x)); }\n+\n+  constexpr _Float16\n+  scalbln(_Float16 __x, long __ex)\n+  { return _Float16(__builtin_scalblnf(__x, __ex)); }\n+\n+  constexpr _Float16\n+  scalbn(_Float16 __x, int __ex)\n+  { return _Float16(__builtin_scalbnf(__x, __ex)); }\n+\n+  constexpr _Float16\n+  tgamma(_Float16 __x)\n+  { return _Float16(__builtin_tgammaf(__x)); }\n+\n+  constexpr _Float16\n+  trunc(_Float16 __x)\n+  { return _Float16(__builtin_truncf(__x)); }\n+#endif\n+\n+#if defined(__STDCPP_FLOAT32_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32)\n+  constexpr _Float32\n+  acosh(_Float32 __x)\n+  { return __builtin_acoshf(__x); }\n+\n+  constexpr _Float32\n+  asinh(_Float32 __x)\n+  { return __builtin_asinhf(__x); }\n+\n+  constexpr _Float32\n+  atanh(_Float32 __x)\n+  { return __builtin_atanhf(__x); }\n+\n+  constexpr _Float32\n+  cbrt(_Float32 __x)\n+  { return __builtin_cbrtf(__x); }\n+\n+  constexpr _Float32\n+  copysign(_Float32 __x, _Float32 __y)\n+  { return __builtin_copysignf(__x, __y); }\n+\n+  constexpr _Float32\n+  erf(_Float32 __x)\n+  { return __builtin_erff(__x); }\n+\n+  constexpr _Float32\n+  erfc(_Float32 __x)\n+  { return __builtin_erfcf(__x); }\n+\n+  constexpr _Float32\n+  exp2(_Float32 __x)\n+  { return __builtin_exp2f(__x); }\n+\n+  constexpr _Float32\n+  expm1(_Float32 __x)\n+  { return __builtin_expm1f(__x); }\n+\n+  constexpr _Float32\n+  fdim(_Float32 __x, _Float32 __y)\n+  { return __builtin_fdimf(__x, __y); }\n+\n+  constexpr _Float32\n+  fma(_Float32 __x, _Float32 __y, _Float32 __z)\n+  { return __builtin_fmaf(__x, __y, __z); }\n+\n+  constexpr _Float32\n+  fmax(_Float32 __x, _Float32 __y)\n+  { return __builtin_fmaxf(__x, __y); }\n+\n+  constexpr _Float32\n+  fmin(_Float32 __x, _Float32 __y)\n+  { return __builtin_fminf(__x, __y); }\n+\n+  constexpr _Float32\n+  hypot(_Float32 __x, _Float32 __y)\n+  { return __builtin_hypotf(__x, __y); }\n+\n+  constexpr int\n+  ilogb(_Float32 __x)\n+  { return __builtin_ilogbf(__x); }\n+\n+  constexpr _Float32\n+  lgamma(_Float32 __x)\n+  { return __builtin_lgammaf(__x); }\n+\n+  constexpr long long\n+  llrint(_Float32 __x)\n+  { return __builtin_llrintf(__x); }\n+\n+  constexpr long long\n+  llround(_Float32 __x)\n+  { return __builtin_llroundf(__x); }\n+\n+  constexpr _Float32\n+  log1p(_Float32 __x)\n+  { return __builtin_log1pf(__x); }\n+\n+  // DR 568.\n+  constexpr _Float32\n+  log2(_Float32 __x)\n+  { return __builtin_log2f(__x); }\n+\n+  constexpr _Float32\n+  logb(_Float32 __x)\n+  { return __builtin_logbf(__x); }\n+\n+  constexpr long\n+  lrint(_Float32 __x)\n+  { return __builtin_lrintf(__x); }\n+\n+  constexpr long\n+  lround(_Float32 __x)\n+  { return __builtin_lroundf(__x); }\n+\n+  constexpr _Float32\n+  nearbyint(_Float32 __x)\n+  { return __builtin_nearbyintf(__x); }\n+\n+  constexpr _Float32\n+  nextafter(_Float32 __x, _Float32 __y)\n+  { return __builtin_nextafterf(__x, __y); }\n+\n+  constexpr _Float32\n+  remainder(_Float32 __x, _Float32 __y)\n+  { return __builtin_remainderf(__x, __y); }\n+\n+  inline _Float32\n+  remquo(_Float32 __x, _Float32 __y, int* __pquo)\n+  { return __builtin_remquof(__x, __y, __pquo); }\n+\n+  constexpr _Float32\n+  rint(_Float32 __x)\n+  { return __builtin_rintf(__x); }\n+\n+  constexpr _Float32\n+  round(_Float32 __x)\n+  { return __builtin_roundf(__x); }\n+\n+  constexpr _Float32\n+  scalbln(_Float32 __x, long __ex)\n+  { return __builtin_scalblnf(__x, __ex); }\n+\n+  constexpr _Float32\n+  scalbn(_Float32 __x, int __ex)\n+  { return __builtin_scalbnf(__x, __ex); }\n+\n+  constexpr _Float32\n+  tgamma(_Float32 __x)\n+  { return __builtin_tgammaf(__x); }\n+\n+  constexpr _Float32\n+  trunc(_Float32 __x)\n+  { return __builtin_truncf(__x); }\n+#endif\n+\n+#if defined(__STDCPP_FLOAT64_T__) && defined(_GLIBCXX_DOUBLE_IS_IEEE_BINARY64)\n+  constexpr _Float64\n+  acosh(_Float64 __x)\n+  { return __builtin_acosh(__x); }\n+\n+  constexpr _Float64\n+  asinh(_Float64 __x)\n+  { return __builtin_asinh(__x); }\n+\n+  constexpr _Float64\n+  atanh(_Float64 __x)\n+  { return __builtin_atanh(__x); }\n+\n+  constexpr _Float64\n+  cbrt(_Float64 __x)\n+  { return __builtin_cbrt(__x); }\n+\n+  constexpr _Float64\n+  copysign(_Float64 __x, _Float64 __y)\n+  { return __builtin_copysign(__x, __y); }\n+\n+  constexpr _Float64\n+  erf(_Float64 __x)\n+  { return __builtin_erf(__x); }\n+\n+  constexpr _Float64\n+  erfc(_Float64 __x)\n+  { return __builtin_erfc(__x); }\n+\n+  constexpr _Float64\n+  exp2(_Float64 __x)\n+  { return __builtin_exp2(__x); }\n+\n+  constexpr _Float64\n+  expm1(_Float64 __x)\n+  { return __builtin_expm1(__x); }\n+\n+  constexpr _Float64\n+  fdim(_Float64 __x, _Float64 __y)\n+  { return __builtin_fdim(__x, __y); }\n+\n+  constexpr _Float64\n+  fma(_Float64 __x, _Float64 __y, _Float64 __z)\n+  { return __builtin_fma(__x, __y, __z); }\n+\n+  constexpr _Float64\n+  fmax(_Float64 __x, _Float64 __y)\n+  { return __builtin_fmax(__x, __y); }\n+\n+  constexpr _Float64\n+  fmin(_Float64 __x, _Float64 __y)\n+  { return __builtin_fmin(__x, __y); }\n+\n+  constexpr _Float64\n+  hypot(_Float64 __x, _Float64 __y)\n+  { return __builtin_hypot(__x, __y); }\n+\n+  constexpr int\n+  ilogb(_Float64 __x)\n+  { return __builtin_ilogb(__x); }\n+\n+  constexpr _Float64\n+  lgamma(_Float64 __x)\n+  { return __builtin_lgamma(__x); }\n+\n+  constexpr long long\n+  llrint(_Float64 __x)\n+  { return __builtin_llrint(__x); }\n+\n+  constexpr long long\n+  llround(_Float64 __x)\n+  { return __builtin_llround(__x); }\n+\n+  constexpr _Float64\n+  log1p(_Float64 __x)\n+  { return __builtin_log1p(__x); }\n+\n+  // DR 568.\n+  constexpr _Float64\n+  log2(_Float64 __x)\n+  { return __builtin_log2(__x); }\n+\n+  constexpr _Float64\n+  logb(_Float64 __x)\n+  { return __builtin_logb(__x); }\n+\n+  constexpr long\n+  lrint(_Float64 __x)\n+  { return __builtin_lrint(__x); }\n+\n+  constexpr long\n+  lround(_Float64 __x)\n+  { return __builtin_lround(__x); }\n+\n+  constexpr _Float64\n+  nearbyint(_Float64 __x)\n+  { return __builtin_nearbyint(__x); }\n+\n+  constexpr _Float64\n+  nextafter(_Float64 __x, _Float64 __y)\n+  { return __builtin_nextafter(__x, __y); }\n+\n+  constexpr _Float64\n+  remainder(_Float64 __x, _Float64 __y)\n+  { return __builtin_remainder(__x, __y); }\n+\n+  inline _Float64\n+  remquo(_Float64 __x, _Float64 __y, int* __pquo)\n+  { return __builtin_remquo(__x, __y, __pquo); }\n+\n+  constexpr _Float64\n+  rint(_Float64 __x)\n+  { return __builtin_rint(__x); }\n+\n+  constexpr _Float64\n+  round(_Float64 __x)\n+  { return __builtin_round(__x); }\n+\n+  constexpr _Float64\n+  scalbln(_Float64 __x, long __ex)\n+  { return __builtin_scalbln(__x, __ex); }\n+\n+  constexpr _Float64\n+  scalbn(_Float64 __x, int __ex)\n+  { return __builtin_scalbn(__x, __ex); }\n+\n+  constexpr _Float64\n+  tgamma(_Float64 __x)\n+  { return __builtin_tgamma(__x); }\n+\n+  constexpr _Float64\n+  trunc(_Float64 __x)\n+  { return __builtin_trunc(__x); }\n+#endif\n+\n+#if defined(__STDCPP_FLOAT128_T__) && defined(_GLIBCXX_LDOUBLE_IS_IEEE_BINARY128)\n+  constexpr _Float128\n+  acosh(_Float128 __x)\n+  { return __builtin_acoshl(__x); }\n+\n+  constexpr _Float128\n+  asinh(_Float128 __x)\n+  { return __builtin_asinhl(__x); }\n+\n+  constexpr _Float128\n+  atanh(_Float128 __x)\n+  { return __builtin_atanhl(__x); }\n+\n+  constexpr _Float128\n+  cbrt(_Float128 __x)\n+  { return __builtin_cbrtl(__x); }\n+\n+  constexpr _Float128\n+  copysign(_Float128 __x, _Float128 __y)\n+  { return __builtin_copysignl(__x, __y); }\n+\n+  constexpr _Float128\n+  erf(_Float128 __x)\n+  { return __builtin_erfl(__x); }\n+\n+  constexpr _Float128\n+  erfc(_Float128 __x)\n+  { return __builtin_erfcl(__x); }\n+\n+  constexpr _Float128\n+  exp2(_Float128 __x)\n+  { return __builtin_exp2l(__x); }\n+\n+  constexpr _Float128\n+  expm1(_Float128 __x)\n+  { return __builtin_expm1l(__x); }\n+\n+  constexpr _Float128\n+  fdim(_Float128 __x, _Float128 __y)\n+  { return __builtin_fdiml(__x, __y); }\n+\n+  constexpr _Float128\n+  fma(_Float128 __x, _Float128 __y, _Float128 __z)\n+  { return __builtin_fmal(__x, __y, __z); }\n+\n+  constexpr _Float128\n+  fmax(_Float128 __x, _Float128 __y)\n+  { return __builtin_fmaxl(__x, __y); }\n+\n+  constexpr _Float128\n+  fmin(_Float128 __x, _Float128 __y)\n+  { return __builtin_fminl(__x, __y); }\n+\n+  constexpr _Float128\n+  hypot(_Float128 __x, _Float128 __y)\n+  { return __builtin_hypotl(__x, __y); }\n+\n+  constexpr int\n+  ilogb(_Float128 __x)\n+  { return __builtin_ilogbl(__x); }\n+\n+  constexpr _Float128\n+  lgamma(_Float128 __x)\n+  { return __builtin_lgammal(__x); }\n+\n+  constexpr long long\n+  llrint(_Float128 __x)\n+  { return __builtin_llrintl(__x); }\n+\n+  constexpr long long\n+  llround(_Float128 __x)\n+  { return __builtin_llroundl(__x); }\n+\n+  constexpr _Float128\n+  log1p(_Float128 __x)\n+  { return __builtin_log1pl(__x); }\n+\n+  // DR 568.\n+  constexpr _Float128\n+  log2(_Float128 __x)\n+  { return __builtin_log2l(__x); }\n+\n+  constexpr _Float128\n+  logb(_Float128 __x)\n+  { return __builtin_logbl(__x); }\n+\n+  constexpr long\n+  lrint(_Float128 __x)\n+  { return __builtin_lrintl(__x); }\n+\n+  constexpr long\n+  lround(_Float128 __x)\n+  { return __builtin_lroundl(__x); }\n+\n+  constexpr _Float128\n+  nearbyint(_Float128 __x)\n+  { return __builtin_nearbyintl(__x); }\n+\n+  constexpr _Float128\n+  nextafter(_Float128 __x, _Float128 __y)\n+  { return __builtin_nextafterl(__x, __y); }\n+\n+  constexpr _Float128\n+  remainder(_Float128 __x, _Float128 __y)\n+  { return __builtin_remainderl(__x, __y); }\n+\n+  inline _Float128\n+  remquo(_Float128 __x, _Float128 __y, int* __pquo)\n+  { return __builtin_remquol(__x, __y, __pquo); }\n+\n+  constexpr _Float128\n+  rint(_Float128 __x)\n+  { return __builtin_rintl(__x); }\n+\n+  constexpr _Float128\n+  round(_Float128 __x)\n+  { return __builtin_roundl(__x); }\n+\n+  constexpr _Float128\n+  scalbln(_Float128 __x, long __ex)\n+  { return __builtin_scalblnl(__x, __ex); }\n+\n+  constexpr _Float128\n+  scalbn(_Float128 __x, int __ex)\n+  { return __builtin_scalbnl(__x, __ex); }\n+\n+  constexpr _Float128\n+  tgamma(_Float128 __x)\n+  { return __builtin_tgammal(__x); }\n+\n+  constexpr _Float128\n+  trunc(_Float128 __x)\n+  { return __builtin_truncl(__x); }\n+#elif defined(__STDCPP_FLOAT128_T__) && defined(_GLIBCXX_HAVE_FLOAT128_MATH)\n+  constexpr _Float128\n+  acosh(_Float128 __x)\n+  { return __builtin_acoshf128(__x); }\n+\n+  constexpr _Float128\n+  asinh(_Float128 __x)\n+  { return __builtin_asinhf128(__x); }\n+\n+  constexpr _Float128\n+  atanh(_Float128 __x)\n+  { return __builtin_atanhf128(__x); }\n+\n+  constexpr _Float128\n+  cbrt(_Float128 __x)\n+  { return __builtin_cbrtf128(__x); }\n+\n+  constexpr _Float128\n+  copysign(_Float128 __x, _Float128 __y)\n+  { return __builtin_copysignf128(__x, __y); }\n+\n+  constexpr _Float128\n+  erf(_Float128 __x)\n+  { return __builtin_erff128(__x); }\n+\n+  constexpr _Float128\n+  erfc(_Float128 __x)\n+  { return __builtin_erfcf128(__x); }\n+\n+  constexpr _Float128\n+  exp2(_Float128 __x)\n+  { return __builtin_exp2f128(__x); }\n+\n+  constexpr _Float128\n+  expm1(_Float128 __x)\n+  { return __builtin_expm1f128(__x); }\n+\n+  constexpr _Float128\n+  fdim(_Float128 __x, _Float128 __y)\n+  { return __builtin_fdimf128(__x, __y); }\n+\n+  constexpr _Float128\n+  fma(_Float128 __x, _Float128 __y, _Float128 __z)\n+  { return __builtin_fmaf128(__x, __y, __z); }\n+\n+  constexpr _Float128\n+  fmax(_Float128 __x, _Float128 __y)\n+  { return __builtin_fmaxf128(__x, __y); }\n+\n+  constexpr _Float128\n+  fmin(_Float128 __x, _Float128 __y)\n+  { return __builtin_fminf128(__x, __y); }\n+\n+  constexpr _Float128\n+  hypot(_Float128 __x, _Float128 __y)\n+  { return __builtin_hypotf128(__x, __y); }\n+\n+  constexpr int\n+  ilogb(_Float128 __x)\n+  { return __builtin_ilogbf128(__x); }\n+\n+  constexpr _Float128\n+  lgamma(_Float128 __x)\n+  { return __builtin_lgammaf128(__x); }\n+\n+  constexpr long long\n+  llrint(_Float128 __x)\n+  { return __builtin_llrintf128(__x); }\n+\n+  constexpr long long\n+  llround(_Float128 __x)\n+  { return __builtin_llroundf128(__x); }\n+\n+  constexpr _Float128\n+  log1p(_Float128 __x)\n+  { return __builtin_log1pf128(__x); }\n+\n+  // DR 568.\n+  constexpr _Float128\n+  log2(_Float128 __x)\n+  { return __builtin_log2f128(__x); }\n+\n+  constexpr _Float128\n+  logb(_Float128 __x)\n+  { return __builtin_logbf128(__x); }\n+\n+  constexpr long\n+  lrint(_Float128 __x)\n+  { return __builtin_lrintf128(__x); }\n+\n+  constexpr long\n+  lround(_Float128 __x)\n+  { return __builtin_lroundf128(__x); }\n+\n+  constexpr _Float128\n+  nearbyint(_Float128 __x)\n+  { return __builtin_nearbyintf128(__x); }\n+\n+  constexpr _Float128\n+  nextafter(_Float128 __x, _Float128 __y)\n+  { return __builtin_nextafterf128(__x, __y); }\n+\n+  constexpr _Float128\n+  remainder(_Float128 __x, _Float128 __y)\n+  { return __builtin_remainderf128(__x, __y); }\n+\n+  inline _Float128\n+  remquo(_Float128 __x, _Float128 __y, int* __pquo)\n+  { return __builtin_remquof128(__x, __y, __pquo); }\n+\n+  constexpr _Float128\n+  rint(_Float128 __x)\n+  { return __builtin_rintf128(__x); }\n+\n+  constexpr _Float128\n+  round(_Float128 __x)\n+  { return __builtin_roundf128(__x); }\n+\n+  constexpr _Float128\n+  scalbln(_Float128 __x, long __ex)\n+  { return __builtin_scalblnf128(__x, __ex); }\n+\n+  constexpr _Float128\n+  scalbn(_Float128 __x, int __ex)\n+  { return __builtin_scalbnf128(__x, __ex); }\n+\n+  constexpr _Float128\n+  tgamma(_Float128 __x)\n+  { return __builtin_tgammaf128(__x); }\n+\n+  constexpr _Float128\n+  trunc(_Float128 __x)\n+  { return __builtin_truncf128(__x); }\n+#endif\n+\n+#if defined(__STDCPP_BFLOAT16_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32)\n+  constexpr __gnu_cxx::__bfloat16_t\n+  acosh(__gnu_cxx::__bfloat16_t __x)\n+  { return __gnu_cxx::__bfloat16_t(__builtin_acoshf(__x)); }\n+\n+  constexpr __gnu_cxx::__bfloat16_t\n+  asinh(__gnu_cxx::__bfloat16_t __x)\n+  { return __gnu_cxx::__bfloat16_t(__builtin_asinhf(__x)); }\n+\n+  constexpr __gnu_cxx::__bfloat16_t\n+  atanh(__gnu_cxx::__bfloat16_t __x)\n+  { return __gnu_cxx::__bfloat16_t(__builtin_atanhf(__x)); }\n+\n+  constexpr __gnu_cxx::__bfloat16_t\n+  cbrt(__gnu_cxx::__bfloat16_t __x)\n+  { return __gnu_cxx::__bfloat16_t(__builtin_cbrtf(__x)); }\n+\n+  constexpr __gnu_cxx::__bfloat16_t\n+  copysign(__gnu_cxx::__bfloat16_t __x, __gnu_cxx::__bfloat16_t __y)\n+  { return __gnu_cxx::__bfloat16_t(__builtin_copysignf(__x, __y)); }\n+\n+  constexpr __gnu_cxx::__bfloat16_t\n+  erf(__gnu_cxx::__bfloat16_t __x)\n+  { return __gnu_cxx::__bfloat16_t(__builtin_erff(__x)); }\n+\n+  constexpr __gnu_cxx::__bfloat16_t\n+  erfc(__gnu_cxx::__bfloat16_t __x)\n+  { return __gnu_cxx::__bfloat16_t(__builtin_erfcf(__x)); }\n+\n+  constexpr __gnu_cxx::__bfloat16_t\n+  exp2(__gnu_cxx::__bfloat16_t __x)\n+  { return __gnu_cxx::__bfloat16_t(__builtin_exp2f(__x)); }\n+\n+  constexpr __gnu_cxx::__bfloat16_t\n+  expm1(__gnu_cxx::__bfloat16_t __x)\n+  { return __gnu_cxx::__bfloat16_t(__builtin_expm1f(__x)); }\n+\n+  constexpr __gnu_cxx::__bfloat16_t\n+  fdim(__gnu_cxx::__bfloat16_t __x, __gnu_cxx::__bfloat16_t __y)\n+  { return __gnu_cxx::__bfloat16_t(__builtin_fdimf(__x, __y)); }\n+\n+  constexpr __gnu_cxx::__bfloat16_t\n+  fma(__gnu_cxx::__bfloat16_t __x, __gnu_cxx::__bfloat16_t __y, __gnu_cxx::__bfloat16_t __z)\n+  { return __gnu_cxx::__bfloat16_t(__builtin_fmaf(__x, __y, __z)); }\n+\n+  constexpr __gnu_cxx::__bfloat16_t\n+  fmax(__gnu_cxx::__bfloat16_t __x, __gnu_cxx::__bfloat16_t __y)\n+  { return __gnu_cxx::__bfloat16_t(__builtin_fmaxf(__x, __y)); }\n+\n+  constexpr __gnu_cxx::__bfloat16_t\n+  fmin(__gnu_cxx::__bfloat16_t __x, __gnu_cxx::__bfloat16_t __y)\n+  { return __gnu_cxx::__bfloat16_t(__builtin_fminf(__x, __y)); }\n+\n+  constexpr __gnu_cxx::__bfloat16_t\n+  hypot(__gnu_cxx::__bfloat16_t __x, __gnu_cxx::__bfloat16_t __y)\n+  { return __gnu_cxx::__bfloat16_t(__builtin_hypotf(__x, __y)); }\n+\n+  constexpr int\n+  ilogb(__gnu_cxx::__bfloat16_t __x)\n+  { return __gnu_cxx::__bfloat16_t(__builtin_ilogbf(__x)); }\n+\n+  constexpr __gnu_cxx::__bfloat16_t\n+  lgamma(__gnu_cxx::__bfloat16_t __x)\n+  { return __gnu_cxx::__bfloat16_t(__builtin_lgammaf(__x)); }\n+\n+  constexpr long long\n+  llrint(__gnu_cxx::__bfloat16_t __x)\n+  { return __gnu_cxx::__bfloat16_t(__builtin_llrintf(__x)); }\n+\n+  constexpr long long\n+  llround(__gnu_cxx::__bfloat16_t __x)\n+  { return __gnu_cxx::__bfloat16_t(__builtin_llroundf(__x)); }\n+\n+  constexpr __gnu_cxx::__bfloat16_t\n+  log1p(__gnu_cxx::__bfloat16_t __x)\n+  { return __gnu_cxx::__bfloat16_t(__builtin_log1pf(__x)); }\n+\n+  // DR 568.\n+  constexpr __gnu_cxx::__bfloat16_t\n+  log2(__gnu_cxx::__bfloat16_t __x)\n+  { return __gnu_cxx::__bfloat16_t(__builtin_log2f(__x)); }\n+\n+  constexpr __gnu_cxx::__bfloat16_t\n+  logb(__gnu_cxx::__bfloat16_t __x)\n+  { return __gnu_cxx::__bfloat16_t(__builtin_logbf(__x)); }\n+\n+  constexpr long\n+  lrint(__gnu_cxx::__bfloat16_t __x)\n+  { return __gnu_cxx::__bfloat16_t(__builtin_lrintf(__x)); }\n+\n+  constexpr long\n+  lround(__gnu_cxx::__bfloat16_t __x)\n+  { return __gnu_cxx::__bfloat16_t(__builtin_lroundf(__x)); }\n+\n+  constexpr __gnu_cxx::__bfloat16_t\n+  nearbyint(__gnu_cxx::__bfloat16_t __x)\n+  { return __gnu_cxx::__bfloat16_t(__builtin_nearbyintf(__x)); }\n+\n+  // nextafter not implemented so far.\n+\n+  constexpr __gnu_cxx::__bfloat16_t\n+  remainder(__gnu_cxx::__bfloat16_t __x, __gnu_cxx::__bfloat16_t __y)\n+  { return __gnu_cxx::__bfloat16_t(__builtin_remainderf(__x, __y)); }\n+\n+  inline __gnu_cxx::__bfloat16_t\n+  remquo(__gnu_cxx::__bfloat16_t __x, __gnu_cxx::__bfloat16_t __y, int* __pquo)\n+  { return __gnu_cxx::__bfloat16_t(__builtin_remquof(__x, __y, __pquo)); }\n+\n+  constexpr __gnu_cxx::__bfloat16_t\n+  rint(__gnu_cxx::__bfloat16_t __x)\n+  { return __gnu_cxx::__bfloat16_t(__builtin_rintf(__x)); }\n+\n+  constexpr __gnu_cxx::__bfloat16_t\n+  round(__gnu_cxx::__bfloat16_t __x)\n+  { return __gnu_cxx::__bfloat16_t(__builtin_roundf(__x)); }\n+\n+  constexpr __gnu_cxx::__bfloat16_t\n+  scalbln(__gnu_cxx::__bfloat16_t __x, long __ex)\n+  { return __gnu_cxx::__bfloat16_t(__builtin_scalblnf(__x, __ex)); }\n+\n+  constexpr __gnu_cxx::__bfloat16_t\n+  scalbn(__gnu_cxx::__bfloat16_t __x, int __ex)\n+  { return __gnu_cxx::__bfloat16_t(__builtin_scalbnf(__x, __ex)); }\n+\n+  constexpr __gnu_cxx::__bfloat16_t\n+  tgamma(__gnu_cxx::__bfloat16_t __x)\n+  { return __gnu_cxx::__bfloat16_t(__builtin_tgammaf(__x)); }\n+\n+  constexpr __gnu_cxx::__bfloat16_t\n+  trunc(__gnu_cxx::__bfloat16_t __x)\n+  { return __gnu_cxx::__bfloat16_t(__builtin_truncf(__x)); }\n+#endif\n+\n+\n+#endif // _GLIBCXX_USE_C99_MATH_TR1\n+#endif // C++11\n+\n+#if __cplusplus >= 201703L\n+\n+  // [c.math.hypot3], three-dimensional hypotenuse\n+#define __cpp_lib_hypot 201603L\n+\n+  template<typename _Tp>\n+    inline _Tp\n+    __hypot3(_Tp __x, _Tp __y, _Tp __z)\n+    {\n+      __x = std::abs(__x);\n+      __y = std::abs(__y);\n+      __z = std::abs(__z);\n+      if (_Tp __a = __x < __y ? __y < __z ? __z : __y : __x < __z ? __z : __x)\n+\treturn __a * std::sqrt((__x / __a) * (__x / __a)\n+\t\t\t       + (__y / __a) * (__y / __a)\n+\t\t\t       + (__z / __a) * (__z / __a));\n+      else\n+\treturn {};\n+    }\n+\n+  inline float\n+  hypot(float __x, float __y, float __z)\n+  { return std::__hypot3<float>(__x, __y, __z); }\n+\n+  inline double\n+  hypot(double __x, double __y, double __z)\n+  { return std::__hypot3<double>(__x, __y, __z); }\n \n   inline long double\n   hypot(long double __x, long double __y, long double __z)\n@@ -1885,6 +3504,39 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       using __type = __gnu_cxx::__promoted_t<_Tp, _Up, _Vp>;\n       return std::__hypot3<__type>(__x, __y, __z);\n     }\n+\n+#if defined(__STDCPP_FLOAT16_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32)\n+  inline _Float16\n+  hypot(_Float16 __x, _Float16 __y, _Float16 __z)\n+  { return std::__hypot3<_Float16>(__x, __y, __z); }\n+#endif\n+\n+#if defined(__STDCPP_FLOAT32_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32)\n+  inline _Float32\n+  hypot(_Float32 __x, _Float32 __y, _Float32 __z)\n+  { return std::__hypot3<_Float32>(__x, __y, __z); }\n+#endif\n+\n+#if defined(__STDCPP_FLOAT64_T__) && defined(_GLIBCXX_DOUBLE_IS_IEEE_BINARY64)\n+  inline _Float64\n+  hypot(_Float64 __x, _Float64 __y, _Float64 __z)\n+  { return std::__hypot3<_Float64>(__x, __y, __z); }\n+#endif\n+\n+#if defined(__STDCPP_FLOAT128_T__) \\\n+    && (defined(_GLIBCXX_LDOUBLE_IS_IEEE_BINARY128) \\\n+\t|| defined(_GLIBCXX_HAVE_FLOAT128_MATH))\n+  inline _Float128\n+  hypot(_Float128 __x, _Float128 __y, _Float128 __z)\n+  { return std::__hypot3<_Float128>(__x, __y, __z); }\n+#endif\n+\n+#if defined(__STDCPP_BFLOAT16_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32)\n+  inline __gnu_cxx::__bfloat16_t\n+  hypot(__gnu_cxx::__bfloat16_t __x, __gnu_cxx::__bfloat16_t __y, __gnu_cxx::__bfloat16_t __z)\n+  { return std::__hypot3<__gnu_cxx::__bfloat16_t>(__x, __y, __z); }\n+#endif\n+\n #endif // C++17\n \n #if __cplusplus >= 202002L\n@@ -1928,6 +3580,39 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       using __type = __gnu_cxx::__promoted_t<_Tp, _Up, _Vp>;\n       return std::__lerp<__type>(__x, __y, __z);\n     }\n+\n+#if defined(__STDCPP_FLOAT16_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32)\n+  inline _Float16\n+  lerp(_Float16 __x, _Float16 __y, _Float16 __z) noexcept\n+  { return std::__lerp<_Float16>(__x, __y, __z); }\n+#endif\n+\n+#if defined(__STDCPP_FLOAT32_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32)\n+  inline _Float32\n+  lerp(_Float32 __x, _Float32 __y, _Float32 __z) noexcept\n+  { return std::__lerp<_Float32>(__x, __y, __z); }\n+#endif\n+\n+#if defined(__STDCPP_FLOAT64_T__) && defined(_GLIBCXX_DOUBLE_IS_IEEE_BINARY64)\n+  inline _Float64\n+  lerp(_Float64 __x, _Float64 __y, _Float64 __z) noexcept\n+  { return std::__lerp<_Float64>(__x, __y, __z); }\n+#endif\n+\n+#if defined(__STDCPP_FLOAT128_T__) \\\n+    && (defined(_GLIBCXX_LDOUBLE_IS_IEEE_BINARY128) \\\n+\t|| defined(_GLIBCXX_HAVE_FLOAT128_MATH))\n+  inline _Float128\n+  lerp(_Float128 __x, _Float128 __y, _Float128 __z) noexcept\n+  { return std::__lerp<_Float128>(__x, __y, __z); }\n+#endif\n+\n+#if defined(__STDCPP_BFLOAT16_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32)\n+  inline __gnu_cxx::__bfloat16_t\n+  lerp(__gnu_cxx::__bfloat16_t __x, __gnu_cxx::__bfloat16_t __y, __gnu_cxx::__bfloat16_t __z) noexcept\n+  { return std::__lerp<__gnu_cxx::__bfloat16_t>(__x, __y, __z); }\n+#endif\n+\n #endif // C++20\n \n _GLIBCXX_END_NAMESPACE_VERSION"}, {"sha": "a6321dfc216a1bd91be94cd29357851fea249735", "filename": "libstdc++-v3/include/ext/type_traits.h", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a23225fb4f764dfc3e3e729c7d7238f03f282aaa/libstdc%2B%2B-v3%2Finclude%2Fext%2Ftype_traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a23225fb4f764dfc3e3e729c7d7238f03f282aaa/libstdc%2B%2B-v3%2Finclude%2Fext%2Ftype_traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Ftype_traits.h?ref=a23225fb4f764dfc3e3e729c7d7238f03f282aaa", "patch": "@@ -190,6 +190,36 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     struct __promote<float>\n     { typedef float __type; };\n \n+#ifdef __STDCPP_FLOAT16_T__\n+  template<>\n+    struct __promote<_Float16>\n+    { typedef _Float16 __type; };\n+#endif\n+\n+#ifdef __STDCPP_FLOAT32_T__\n+  template<>\n+    struct __promote<_Float32>\n+    { typedef _Float32 __type; };\n+#endif\n+\n+#ifdef __STDCPP_FLOAT64_T__\n+  template<>\n+    struct __promote<_Float64>\n+    { typedef _Float64 __type; };\n+#endif\n+\n+#ifdef __STDCPP_FLOAT128_T__\n+  template<>\n+    struct __promote<_Float128>\n+    { typedef _Float128 __type; };\n+#endif\n+\n+#ifdef __STDCPP_BFLOAT16_T__\n+  template<>\n+    struct __promote<__gnu_cxx::__bfloat16_t>\n+    { typedef __gnu_cxx::__bfloat16_t __type; };\n+#endif\n+\n #if __cpp_fold_expressions\n \n   template<typename... _Tp>"}, {"sha": "815768994731fe33ee40db9d7d2732ed132c8865", "filename": "libstdc++-v3/include/precompiled/stdc++.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a23225fb4f764dfc3e3e729c7d7238f03f282aaa/libstdc%2B%2B-v3%2Finclude%2Fprecompiled%2Fstdc%2B%2B.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a23225fb4f764dfc3e3e729c7d7238f03f282aaa/libstdc%2B%2B-v3%2Finclude%2Fprecompiled%2Fstdc%2B%2B.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprecompiled%2Fstdc%2B%2B.h?ref=a23225fb4f764dfc3e3e729c7d7238f03f282aaa", "patch": "@@ -228,6 +228,7 @@\n # include <stacktrace>\n #endif\n #include <stdatomic.h>\n+#include <stdfloat>\n #endif\n \n #endif // HOSTED"}, {"sha": "356f1458f4463b3b30ec6ab674f1c447e9a3404e", "filename": "libstdc++-v3/include/std/atomic", "status": "modified", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a23225fb4f764dfc3e3e729c7d7238f03f282aaa/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fatomic", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a23225fb4f764dfc3e3e729c7d7238f03f282aaa/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fatomic", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fatomic?ref=a23225fb4f764dfc3e3e729c7d7238f03f282aaa", "patch": "@@ -1625,6 +1625,91 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       using __atomic_float<long double>::operator=;\n     };\n \n+#ifdef __STDCPP_FLOAT16_T__\n+  template<>\n+    struct atomic<_Float16> : __atomic_float<_Float16>\n+    {\n+      atomic() noexcept = default;\n+\n+      constexpr\n+      atomic(_Float16 __fp) noexcept : __atomic_float<_Float16>(__fp)\n+      { }\n+\n+      atomic& operator=(const atomic&) volatile = delete;\n+      atomic& operator=(const atomic&) = delete;\n+\n+      using __atomic_float<_Float16>::operator=;\n+    };\n+#endif\n+\n+#ifdef __STDCPP_FLOAT32_T__\n+  template<>\n+    struct atomic<_Float32> : __atomic_float<_Float32>\n+    {\n+      atomic() noexcept = default;\n+\n+      constexpr\n+      atomic(_Float32 __fp) noexcept : __atomic_float<_Float32>(__fp)\n+      { }\n+\n+      atomic& operator=(const atomic&) volatile = delete;\n+      atomic& operator=(const atomic&) = delete;\n+\n+      using __atomic_float<_Float32>::operator=;\n+    };\n+#endif\n+\n+#ifdef __STDCPP_FLOAT64_T__\n+  template<>\n+    struct atomic<_Float64> : __atomic_float<_Float64>\n+    {\n+      atomic() noexcept = default;\n+\n+      constexpr\n+      atomic(_Float64 __fp) noexcept : __atomic_float<_Float64>(__fp)\n+      { }\n+\n+      atomic& operator=(const atomic&) volatile = delete;\n+      atomic& operator=(const atomic&) = delete;\n+\n+      using __atomic_float<_Float64>::operator=;\n+    };\n+#endif\n+\n+#ifdef __STDCPP_FLOAT128_T__\n+  template<>\n+    struct atomic<_Float128> : __atomic_float<_Float128>\n+    {\n+      atomic() noexcept = default;\n+\n+      constexpr\n+      atomic(_Float128 __fp) noexcept : __atomic_float<_Float128>(__fp)\n+      { }\n+\n+      atomic& operator=(const atomic&) volatile = delete;\n+      atomic& operator=(const atomic&) = delete;\n+\n+      using __atomic_float<_Float128>::operator=;\n+    };\n+#endif\n+\n+#ifdef __STDCPP_BFLOAT16_T__\n+  template<>\n+    struct atomic<__gnu_cxx::__bfloat16_t> : __atomic_float<__gnu_cxx::__bfloat16_t>\n+    {\n+      atomic() noexcept = default;\n+\n+      constexpr\n+      atomic(__gnu_cxx::__bfloat16_t __fp) noexcept : __atomic_float<__gnu_cxx::__bfloat16_t>(__fp)\n+      { }\n+\n+      atomic& operator=(const atomic&) volatile = delete;\n+      atomic& operator=(const atomic&) = delete;\n+\n+      using __atomic_float<__gnu_cxx::__bfloat16_t>::operator=;\n+    };\n+#endif\n+\n #define __cpp_lib_atomic_ref 201806L\n \n   /// Class template to provide atomic operations on a non-atomic variable."}, {"sha": "61b6c3b0f2d4c06f4dc2e257751cb67adfb6147b", "filename": "libstdc++-v3/include/std/limits", "status": "modified", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a23225fb4f764dfc3e3e729c7d7238f03f282aaa/libstdc%2B%2B-v3%2Finclude%2Fstd%2Flimits", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a23225fb4f764dfc3e3e729c7d7238f03f282aaa/libstdc%2B%2B-v3%2Finclude%2Fstd%2Flimits", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Flimits?ref=a23225fb4f764dfc3e3e729c7d7238f03f282aaa", "patch": "@@ -1890,6 +1890,190 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n #undef __glibcxx_long_double_traps\n #undef __glibcxx_long_double_tinyness_before\n \n+#if __cplusplus > 202202L\n+\n+#define __glibcxx_concat3_(P,M,S) P ## M ## S\n+#define __glibcxx_concat3(P,M,S) __glibcxx_concat3_ (P,M,S)\n+\n+#define __glibcxx_float_n(BITSIZE)\t\t\t\t\t\\\n+  __extension__\t\t\t\t\t\t\t\t\\\n+  template<>\t\t\t\t\t\t\t\t\\\n+    struct numeric_limits<_Float##BITSIZE>\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      static constexpr bool is_specialized = true;\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      static constexpr _Float##BITSIZE\t\t\t\t\t\\\n+      min() noexcept\t\t\t\t\t\t\t\\\n+      { return __glibcxx_concat3 (__FLT, BITSIZE, _MIN__); }\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      static constexpr _Float##BITSIZE\t\t\t\t\t\\\n+      max() noexcept\t\t\t\t\t\t\t\\\n+      { return __glibcxx_concat3 (__FLT, BITSIZE, _MAX__); }\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      static constexpr _Float##BITSIZE\t\t\t\t\t\\\n+      lowest() noexcept\t\t\t\t\t\t\t\\\n+      { return -__glibcxx_concat3 (__FLT, BITSIZE, _MAX__); }\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      static constexpr int digits\t\t\t\t\t\\\n+\t= __glibcxx_concat3 (__FLT, BITSIZE, _MANT_DIG__);\t\t\\\n+      static constexpr int digits10\t\t\t\t\t\\\n+\t= __glibcxx_concat3 (__FLT, BITSIZE, _DIG__);\t\t\t\\\n+      static constexpr int max_digits10\t\t\t\t\t\\\n+\t= __glibcxx_max_digits10 (__glibcxx_concat3 (__FLT, BITSIZE,\t\\\n+\t\t\t\t\t\t     _MANT_DIG__));\t\\\n+      static constexpr bool is_signed = true;\t\t\t\t\\\n+      static constexpr bool is_integer = false;\t\t\t\t\\\n+      static constexpr bool is_exact = false;\t\t\t\t\\\n+      static constexpr int radix\t\t\t\t\t\\\n+\t= __glibcxx_concat3 (__FLT, BITSIZE, _RADIX__);\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      static constexpr _Float##BITSIZE\t\t\t\t\t\\\n+      epsilon() noexcept\t\t\t\t\t\t\\\n+      { return __glibcxx_concat3 (__FLT, BITSIZE, _EPSILON__); }\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      static constexpr _Float##BITSIZE \t\t\t\t\t\\\n+      round_error() noexcept { return 0.5F##BITSIZE; }\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      static constexpr int min_exponent\t\t\t\t\t\\\n+\t= __glibcxx_concat3 (__FLT, BITSIZE, _MIN_EXP__);\t\t\\\n+      static constexpr int min_exponent10\t\t\t\t\\\n+\t= __glibcxx_concat3 (__FLT, BITSIZE, _MIN_10_EXP__);\t\t\\\n+      static constexpr int max_exponent\t\t\t\t\t\\\n+\t= __glibcxx_concat3 (__FLT, BITSIZE, _MAX_EXP__);\t\t\\\n+      static constexpr int max_exponent10\t\t\t\t\\\n+\t= __glibcxx_concat3 (__FLT, BITSIZE, _MAX_10_EXP__);\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      static constexpr bool has_infinity\t\t\t\t\\\n+\t= __glibcxx_concat3 (__FLT, BITSIZE, _HAS_INFINITY__);\t\t\\\n+      static constexpr bool has_quiet_NaN\t\t\t\t\\\n+\t= __glibcxx_concat3 (__FLT, BITSIZE, _HAS_QUIET_NAN__);\t\t\\\n+      static constexpr bool has_signaling_NaN\t\t\t\t\\\n+\t= has_quiet_NaN;\t\t\t\t\t\t\\\n+      static constexpr float_denorm_style has_denorm\t\t\t\\\n+\t= bool(__glibcxx_concat3 (__FLT, BITSIZE, _HAS_DENORM__))\t\\\n+\t  ? denorm_present : denorm_absent;\t\t\t\t\\\n+      static constexpr bool has_denorm_loss = false;\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      static constexpr _Float##BITSIZE\t\t\t\t\t\\\n+      infinity() noexcept\t\t\t\t\t\t\\\n+      { return __builtin_huge_valf##BITSIZE(); }\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      static constexpr _Float##BITSIZE\t\t\t\t\t\\\n+      quiet_NaN() noexcept\t\t\t\t\t\t\\\n+      { return __builtin_nanf##BITSIZE(\"\"); }\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      static constexpr _Float##BITSIZE\t\t\t\t\t\\\n+      signaling_NaN() noexcept\t\t\t\t\t\t\\\n+      { return __builtin_nansf##BITSIZE(\"\"); }\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      static constexpr _Float##BITSIZE\t\t\t\t\t\\\n+      denorm_min() noexcept\t\t\t\t\t\t\\\n+      { return __glibcxx_concat3 (__FLT, BITSIZE, _DENORM_MIN__); }\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      static constexpr bool is_iec559\t\t\t\t\t\\\n+\t= has_infinity && has_quiet_NaN && has_denorm == denorm_present;\\\n+      static constexpr bool is_bounded = true; \t\t\t\t\\\n+      static constexpr bool is_modulo = false; \t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      static constexpr bool traps = false; \t\t\t\t\\\n+      static constexpr bool tinyness_before = false; \t\t\t\\\n+      static constexpr float_round_style round_style \t\t\t\\\n+\t= round_to_nearest; \t\t\t\t\t\t\\\n+    }; \t\t\t\t\t\t\t\t\t\\\n+\n+#ifdef __STDCPP_FLOAT16_T__\n+__glibcxx_float_n(16)\n+#endif\n+#ifdef __STDCPP_FLOAT32_T__\n+__glibcxx_float_n(32)\n+#endif\n+#ifdef __STDCPP_FLOAT64_T__\n+__glibcxx_float_n(64)\n+#endif\n+#ifdef __STDCPP_FLOAT128_T__\n+__glibcxx_float_n(128)\n+#endif\n+#undef __glibcxx_float_n\n+#undef __glibcxx_concat3\n+#undef __glibcxx_concat3_\n+\n+#ifdef __STDCPP_BFLOAT16_T__\n+  __extension__\n+  template<>\n+    struct numeric_limits<__gnu_cxx::__bfloat16_t>\n+    {\n+      static constexpr bool is_specialized = true;\n+\n+      static constexpr __gnu_cxx::__bfloat16_t\n+      min() noexcept\n+      { return __BFLT16_MIN__; }\n+\n+      static constexpr __gnu_cxx::__bfloat16_t\n+      max() noexcept\n+      { return __BFLT16_MAX__; }\n+\n+      static constexpr __gnu_cxx::__bfloat16_t\n+      lowest() noexcept\n+      { return -__BFLT16_MAX__; }\n+\n+      static constexpr int digits = __BFLT16_MANT_DIG__;\n+      static constexpr int digits10 = __BFLT16_DIG__;\n+      static constexpr int max_digits10\n+\t= __glibcxx_max_digits10 (__BFLT16_MANT_DIG__);\n+      static constexpr bool is_signed = true;\n+      static constexpr bool is_integer = false;\n+      static constexpr bool is_exact = false;\n+      static constexpr int radix = __BFLT16_RADIX__;\n+\n+      static constexpr __gnu_cxx::__bfloat16_t\n+      epsilon() noexcept\n+      { return __BFLT16_EPSILON__; }\n+\n+      static constexpr __gnu_cxx::__bfloat16_t\n+      round_error() noexcept { return 0.5BF16; }\n+\n+      static constexpr int min_exponent = __BFLT16_MIN_EXP__;\n+      static constexpr int min_exponent10 = __BFLT16_MIN_10_EXP__;\n+      static constexpr int max_exponent = __BFLT16_MAX_EXP__;\n+      static constexpr int max_exponent10 = __BFLT16_MAX_10_EXP__;\n+\n+      static constexpr bool has_infinity = __BFLT16_HAS_INFINITY__;\n+      static constexpr bool has_quiet_NaN = __BFLT16_HAS_QUIET_NAN__;\n+      static constexpr bool has_signaling_NaN = has_quiet_NaN;\n+      static constexpr float_denorm_style has_denorm\n+\t= bool(__BFLT16_HAS_DENORM__)\n+\t  ? denorm_present : denorm_absent;\n+      static constexpr bool has_denorm_loss = false;\n+\n+      static constexpr __gnu_cxx::__bfloat16_t\n+      infinity() noexcept\n+      { return __gnu_cxx::__bfloat16_t(__builtin_huge_valf()); }\n+\n+      static constexpr __gnu_cxx::__bfloat16_t\n+      quiet_NaN() noexcept\n+      { return __gnu_cxx::__bfloat16_t(__builtin_nanf(\"\")); }\n+\n+      static constexpr __gnu_cxx::__bfloat16_t\n+      signaling_NaN() noexcept\n+      { return __builtin_nansf16b(\"\"); }\n+\n+      static constexpr __gnu_cxx::__bfloat16_t\n+      denorm_min() noexcept\n+      { return __BFLT16_DENORM_MIN__; }\n+\n+      static constexpr bool is_iec559\n+\t= has_infinity && has_quiet_NaN && has_denorm == denorm_present;\n+      static constexpr bool is_bounded = true;\n+      static constexpr bool is_modulo = false;\n+\n+      static constexpr bool traps = false;\n+      static constexpr bool tinyness_before = false;\n+      static constexpr float_round_style round_style = round_to_nearest;\n+    };\n+#endif\n+\n+#endif\n+\n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace\n "}, {"sha": "6d3322808a3134166d723a4b1479cdaab1885d0e", "filename": "libstdc++-v3/include/std/numbers", "status": "modified", "additions": 89, "deletions": 63, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a23225fb4f764dfc3e3e729c7d7238f03f282aaa/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fnumbers", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a23225fb4f764dfc3e3e729c7d7238f03f282aaa/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fnumbers", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fnumbers?ref=a23225fb4f764dfc3e3e729c7d7238f03f282aaa", "patch": "@@ -133,72 +133,98 @@ namespace numbers\n   inline constexpr double egamma = egamma_v<double>;\n   inline constexpr double phi = phi_v<double>;\n \n-#if !defined(__STRICT_ANSI__) && defined(_GLIBCXX_USE_FLOAT128)\n-  template<>\n-    inline constexpr __float128 e_v<__float128>\n-      = 2.718281828459045235360287471352662498Q;\n-\n-  /// log_2 e\n-  template<>\n-    inline constexpr __float128 log2e_v<__float128>\n-      = 1.442695040888963407359924681001892137Q;\n-\n-  /// log_10 e\n-  template<>\n-    inline constexpr __float128 log10e_v<__float128>\n-      = 0.434294481903251827651128918916605082Q;\n-\n-  /// pi\n-  template<>\n-    inline constexpr __float128 pi_v<__float128>\n-      = 3.141592653589793238462643383279502884Q;\n-\n-  /// 1/pi\n-  template<>\n-    inline constexpr __float128 inv_pi_v<__float128>\n-      = 0.318309886183790671537767526745028724Q;\n-\n-  /// 1/sqrt(pi)\n-  template<>\n-    inline constexpr __float128 inv_sqrtpi_v<__float128>\n-      = 0.564189583547756286948079451560772586Q;\n-\n-  /// log_e 2\n-  template<>\n-    inline constexpr __float128 ln2_v<__float128>\n-      = 0.693147180559945309417232121458176568Q;\n+#define __glibcxx_numbers(TYPE, SUFFIX) \\\n+  /* e */\t\t\t\t\t\t\\\n+  template<>\t\t\t\t\t\t\\\n+    inline constexpr TYPE e_v<TYPE>\t\t\t\\\n+      = 2.718281828459045235360287471352662498##SUFFIX;\t\\\n+\t\t\t\t\t\t\t\\\n+  /* log_2 e */\t\t\t\t\t\t\\\n+  template<>\t\t\t\t\t\t\\\n+    inline constexpr TYPE log2e_v<TYPE>\t\t\t\\\n+      = 1.442695040888963407359924681001892137##SUFFIX;\t\\\n+\t\t\t\t\t\t\t\\\n+  /* log_10 e */\t\t\t\t\t\\\n+  template<>\t\t\t\t\t\t\\\n+    inline constexpr TYPE log10e_v<TYPE>\t\t\\\n+      = 0.434294481903251827651128918916605082##SUFFIX;\t\\\n+\t\t\t\t\t\t\t\\\n+  /* pi */\t\t\t\t\t\t\\\n+  template<>\t\t\t\t\t\t\\\n+    inline constexpr TYPE pi_v<TYPE>\t\t\t\\\n+      = 3.141592653589793238462643383279502884##SUFFIX;\t\\\n+\t\t\t\t\t\t\t\\\n+  /* 1/pi */\t\t\t\t\t\t\\\n+  template<>\t\t\t\t\t\t\\\n+    inline constexpr TYPE inv_pi_v<TYPE>\t\t\\\n+      = 0.318309886183790671537767526745028724##SUFFIX;\t\\\n+\t\t\t\t\t\t\t\\\n+  /* 1/sqrt(pi) */\t\t\t\t\t\\\n+  template<>\t\t\t\t\t\t\\\n+    inline constexpr TYPE inv_sqrtpi_v<TYPE>\t\t\\\n+      = 0.564189583547756286948079451560772586##SUFFIX;\t\\\n+\t\t\t\t\t\t\t\\\n+  /* log_e 2 */\t\t\t\t\t\t\\\n+  template<>\t\t\t\t\t\t\\\n+    inline constexpr TYPE ln2_v<TYPE>\t\t\t\\\n+      = 0.693147180559945309417232121458176568##SUFFIX;\t\\\n+\t\t\t\t\t\t\t\\\n+  /* log_e 10 */\t\t\t\t\t\\\n+  template<>\t\t\t\t\t\t\\\n+    inline constexpr TYPE ln10_v<TYPE>\t\t\t\\\n+      = 2.302585092994045684017991454684364208##SUFFIX;\t\\\n+\t\t\t\t\t\t\t\\\n+  /* sqrt(2) */\t\t\t\t\t\t\\\n+  template<>\t\t\t\t\t\t\\\n+    inline constexpr TYPE sqrt2_v<TYPE>\t\t\t\\\n+      = 1.414213562373095048801688724209698079##SUFFIX;\t\\\n+\t\t\t\t\t\t\t\\\n+  /* sqrt(3) */\t\t\t\t\t\t\\\n+  template<>\t\t\t\t\t\t\\\n+    inline constexpr TYPE sqrt3_v<TYPE>\t\t\t\\\n+      = 1.732050807568877293527446341505872367##SUFFIX;\t\\\n+\t\t\t\t\t\t\t\\\n+  /* 1/sqrt(3) */\t\t\t\t\t\\\n+  template<>\t\t\t\t\t\t\\\n+    inline constexpr TYPE inv_sqrt3_v<TYPE>\t\t\\\n+      = 0.577350269189625764509148780501957456##SUFFIX;\t\\\n+\t\t\t\t\t\t\t\\\n+  /* The Euler-Mascheroni constant */\t\t\t\\\n+  template<>\t\t\t\t\t\t\\\n+    inline constexpr TYPE egamma_v<TYPE>\t\t\\\n+      = 0.577215664901532860606512090082402431##SUFFIX;\t\\\n+\t\t\t\t\t\t\t\\\n+  /* The golden ratio, (1+sqrt(5))/2 */\t\t\t\\\n+  template<>\t\t\t\t\t\t\\\n+    inline constexpr TYPE phi_v<TYPE>\t\t\t\\\n+      = 1.618033988749894848204586834365638118##SUFFIX\n+\n+#ifdef __STDCPP_FLOAT16_T__\n+__glibcxx_numbers (_Float16, F16);\n+#endif\n+\n+#ifdef __STDCPP_FLOAT32_T__\n+__glibcxx_numbers (_Float32, F32);\n+#endif\n+\n+#ifdef __STDCPP_FLOAT64_T__\n+__glibcxx_numbers (_Float64, F64);\n+#endif\n+\n+#ifdef __STDCPP_FLOAT128_T__\n+__glibcxx_numbers (_Float128, F128);\n+#endif\n+\n+#ifdef __STDCPP_BFLOAT128_T__\n+__glibcxx_numbers (__gnu_cxx::__bfloat16_t, BF16);\n+#endif\n \n-  /// log_e 10\n-  template<>\n-    inline constexpr __float128 ln10_v<__float128>\n-      = 2.302585092994045684017991454684364208Q;\n-\n-  /// sqrt(2)\n-  template<>\n-    inline constexpr __float128 sqrt2_v<__float128>\n-      = 1.414213562373095048801688724209698079Q;\n-\n-  /// sqrt(3)\n-  template<>\n-    inline constexpr __float128 sqrt3_v<__float128>\n-      = 1.732050807568877293527446341505872367Q;\n-\n-  /// 1/sqrt(3)\n-  template<>\n-    inline constexpr __float128 inv_sqrt3_v<__float128>\n-      = 0.577350269189625764509148780501957456Q;\n-\n-  /// The Euler-Mascheroni constant\n-  template<>\n-    inline constexpr __float128 egamma_v<__float128>\n-      = 0.577215664901532860606512090082402431Q;\n-\n-  /// The golden ratio, (1+sqrt(5))/2\n-  template<>\n-    inline constexpr __float128 phi_v<__float128>\n-      = 1.618033988749894848204586834365638118Q;\n+#if !defined(__STRICT_ANSI__) && defined(_GLIBCXX_USE_FLOAT128)\n+__glibcxx_numbers (__float128, Q);\n #endif // USE_FLOAT128\n \n+#undef __glibcxx_numbers\n+\n } // namespace numbers\n /// @}\n _GLIBCXX_END_NAMESPACE_VERSION"}, {"sha": "5ab1fa07dbfd78d92abf327d57c6296c7ddcfdee", "filename": "libstdc++-v3/include/std/stdfloat", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a23225fb4f764dfc3e3e729c7d7238f03f282aaa/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstdfloat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a23225fb4f764dfc3e3e729c7d7238f03f282aaa/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstdfloat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstdfloat?ref=a23225fb4f764dfc3e3e729c7d7238f03f282aaa", "patch": "@@ -0,0 +1,62 @@\n+// <stdfloat> -*- C++ -*-\n+\n+// Copyright (C) 2022 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file include/stdfloat\n+ *  This is a Standard C++ Library header.\n+ */\n+\n+#ifndef _GLIBCXX_STDFLOAT\n+#define _GLIBCXX_STDFLOAT 1\n+\n+#if __cplusplus > 202002L\n+#include <bits/c++config.h>\n+\n+namespace std\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  #ifdef __STDCPP_FLOAT16_T__\n+  using float16_t = _Float16;\n+  #endif\n+\n+  #ifdef __STDCPP_FLOAT32_T__\n+  using float32_t = _Float32;\n+  #endif\n+\n+  #ifdef __STDCPP_FLOAT64_T__\n+  using float64_t = _Float64;\n+  #endif\n+\n+  #ifdef __STDCPP_FLOAT128_T__\n+  using float128_t = _Float128;\n+  #endif\n+\n+  #ifdef __STDCPP_BFLOAT16_T__\n+  using bfloat16_t = __gnu_cxx::__bfloat16_t;\n+  #endif\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace std\n+#endif // C++23\n+#endif // _GLIBCXX_STDFLOAT"}, {"sha": "5dc9e1b2921ce3c7a6c6d2daee43fc97492fe608", "filename": "libstdc++-v3/include/std/type_traits", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a23225fb4f764dfc3e3e729c7d7238f03f282aaa/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a23225fb4f764dfc3e3e729c7d7238f03f282aaa/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits?ref=a23225fb4f764dfc3e3e729c7d7238f03f282aaa", "patch": "@@ -459,6 +459,36 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     struct __is_floating_point_helper<long double>\n     : public true_type { };\n \n+#ifdef __STDCPP_FLOAT16_T__\n+  template<>\n+    struct __is_floating_point_helper<_Float16>\n+    : public true_type { };\n+#endif\n+\n+#ifdef __STDCPP_FLOAT32_T__\n+  template<>\n+    struct __is_floating_point_helper<_Float32>\n+    : public true_type { };\n+#endif\n+\n+#ifdef __STDCPP_FLOAT64_T__\n+  template<>\n+    struct __is_floating_point_helper<_Float64>\n+    : public true_type { };\n+#endif\n+\n+#ifdef __STDCPP_FLOAT128_T__\n+  template<>\n+    struct __is_floating_point_helper<_Float128>\n+    : public true_type { };\n+#endif\n+\n+#ifdef __STDCPP_BFLOAT16_T__\n+  template<>\n+    struct __is_floating_point_helper<__gnu_cxx::__bfloat16_t>\n+    : public true_type { };\n+#endif\n+\n #if !defined(__STRICT_ANSI__) && defined(_GLIBCXX_USE_FLOAT128)\n   template<>\n     struct __is_floating_point_helper<__float128>"}, {"sha": "c55100563b330f852edc83b7430aa4483725e617", "filename": "libstdc++-v3/testsuite/18_support/headers/limits/synopsis_cxx23.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a23225fb4f764dfc3e3e729c7d7238f03f282aaa/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fheaders%2Flimits%2Fsynopsis_cxx23.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a23225fb4f764dfc3e3e729c7d7238f03f282aaa/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fheaders%2Flimits%2Fsynopsis_cxx23.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fheaders%2Flimits%2Fsynopsis_cxx23.cc?ref=a23225fb4f764dfc3e3e729c7d7238f03f282aaa", "patch": "@@ -0,0 +1,43 @@\n+// { dg-options \"-std=gnu++2b\" }\n+// { dg-do compile { target c++23 } }\n+// { dg-require-normal-namespace \"\" }\n+\n+// Copyright (C) 2022 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <limits>\n+#include <stdfloat>\n+\n+namespace std {\n+  template<class T> class numeric_limits;\n+\n+#if defined(__STDCPP_FLOAT16_T__)\n+  template<> class numeric_limits<float16_t>;\n+#endif\n+#if defined(__STDCPP_FLOAT32_T__)\n+  template<> class numeric_limits<float32_t>;\n+#endif\n+#if defined(__STDCPP_FLOAT64_T__)\n+  template<> class numeric_limits<float64_t>;\n+#endif\n+#if defined(__STDCPP_FLOAT128_T__)\n+  template<> class numeric_limits<float128_t>;\n+#endif\n+#if defined(__STDCPP_BFLOAT16_T__)\n+  template<> class numeric_limits<bfloat16_t>;\n+#endif\n+}"}, {"sha": "d85280121891f9eb70e868e318478cd4716e5954", "filename": "libstdc++-v3/testsuite/18_support/headers/stdfloat/types_std.cc", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a23225fb4f764dfc3e3e729c7d7238f03f282aaa/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fheaders%2Fstdfloat%2Ftypes_std.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a23225fb4f764dfc3e3e729c7d7238f03f282aaa/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fheaders%2Fstdfloat%2Ftypes_std.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fheaders%2Fstdfloat%2Ftypes_std.cc?ref=a23225fb4f764dfc3e3e729c7d7238f03f282aaa", "patch": "@@ -0,0 +1,40 @@\n+// { dg-options \"-std=gnu++2b\" }\n+// { dg-do compile { target c++23 } }\n+\n+// Copyright (C) 2022 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <stdfloat>\n+\n+namespace gnu\n+{\n+#if defined(__STDCPP_FLOAT16_T__)\n+  typedef std::float16_t t1;\n+#endif\n+#if defined(__STDCPP_FLOAT32_T__)\n+  typedef std::float32_t t2;\n+#endif\n+#if defined(__STDCPP_FLOAT64_T__)\n+  typedef std::float64_t t3;\n+#endif\n+#if defined(__STDCPP_FLOAT128_T__)\n+  typedef std::float128_t t4;\n+#endif\n+#if defined(__STDCPP_BFLOAT16_T__)\n+  typedef std::bfloat16_t t5;\n+#endif\n+}"}, {"sha": "0fda6a7d061c18b3349bd31401e7cc9340c51ff3", "filename": "libstdc++-v3/testsuite/26_numerics/headers/cmath/c99_classification_macros_c++23.cc", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a23225fb4f764dfc3e3e729c7d7238f03f282aaa/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fheaders%2Fcmath%2Fc99_classification_macros_c%2B%2B23.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a23225fb4f764dfc3e3e729c7d7238f03f282aaa/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fheaders%2Fcmath%2Fc99_classification_macros_c%2B%2B23.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fheaders%2Fcmath%2Fc99_classification_macros_c%2B%2B23.cc?ref=a23225fb4f764dfc3e3e729c7d7238f03f282aaa", "patch": "@@ -0,0 +1,96 @@\n+// Copyright (C) 2022 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do link { target c++23 } }\n+// { dg-excess-errors \"\" { target uclibc } }\n+\n+#include <cmath>\n+#include <stdfloat>\n+\n+void fpclassify() { }\n+\n+void isfinite() { }\n+\n+void isinf() { }\n+\n+void isnan() { }\n+\n+void isnormal() { }\n+\n+void signbit() { }\n+\n+void isgreater() { }\n+\n+void isgreaterequal() { }\n+\n+void isless() { }\n+\n+void islessequal() { }\n+\n+void islessgreater() { }\n+\n+void isunordered() { }\n+\n+#if _GLIBCXX_USE_C99_MATH\n+template <typename _Tp, typename _Up = _Tp>\n+  void test_c99_classify()\n+  {\n+    typedef _Tp fp_type_one;\n+    typedef _Up fp_type_two;\n+    fp_type_one f1 = _Tp(1.0);\n+    fp_type_two f2 = _Up(3.0);\n+    int resi;\n+    volatile bool res;\n+\n+    resi = std::fpclassify(f1);\n+    res = std::isfinite(f2);\n+    res = std::isinf(f1);\n+    res = std::isnan(f2);\n+    res = std::isnormal(f1);\n+    res = std::signbit(f2);\n+    res = std::isgreater(f1, f2);\n+    res = std::isgreaterequal(f1, f2);\n+    res = std::isless(f1, f2);\n+    res = std::islessequal(f1,f2);\n+    res = std::islessgreater(f1, f2);\n+    res = std::isunordered(f1, f2);\n+    resi = resi; // Suppress unused warning.\n+    res = res;\n+  }\n+#endif\n+\n+int main()\n+{\n+#if _GLIBCXX_USE_C99_MATH\n+#ifdef __STDCPP_FLOAT16_T__\n+  test_c99_classify<std::float16_t>();\n+#endif\n+#ifdef __STDCPP_FLOAT32_T__\n+  test_c99_classify<std::float32_t>();\n+#endif\n+#ifdef __STDCPP_FLOAT64_T__\n+  test_c99_classify<std::float64_t>();\n+#endif\n+#ifdef __STDCPP_FLOAT128_T__\n+  test_c99_classify<std::float128_t>();\n+#endif\n+#ifdef __STDCPP_BFLOAT16_T__\n+  test_c99_classify<std::bfloat16_t>();\n+#endif\n+#endif\n+  return 0;\n+}"}, {"sha": "bc8866227ef1e9e079e080afcf3c81ddb8bf3fa4", "filename": "libstdc++-v3/testsuite/26_numerics/headers/cmath/functions_std_c++23.cc", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a23225fb4f764dfc3e3e729c7d7238f03f282aaa/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fheaders%2Fcmath%2Ffunctions_std_c%2B%2B23.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a23225fb4f764dfc3e3e729c7d7238f03f282aaa/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fheaders%2Fcmath%2Ffunctions_std_c%2B%2B23.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fheaders%2Fcmath%2Ffunctions_std_c%2B%2B23.cc?ref=a23225fb4f764dfc3e3e729c7d7238f03f282aaa", "patch": "@@ -0,0 +1,146 @@\n+// Copyright (C) 2022 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do link { target c++23 } }\n+\n+#include <stdfloat>\n+#include <cmath>\n+\n+template <typename T>\n+__attribute__((__noipa__)) void\n+test_functions (T *p, int *q, long int *r, long long int *s)\n+{\n+  p[0] = std::acos (p[0]);\n+  p[1] = std::asin (p[1]);\n+  p[2] = std::atan (p[2]);\n+  p[3] = std::cos (p[3]);\n+  p[4] = std::sin (p[4]);\n+  p[5] = std::tan (p[5]);\n+  p[6] = std::acosh (p[6]);\n+  p[7] = std::asinh (p[7]);\n+  p[8] = std::atanh (p[8]);\n+  p[9] = std::cosh (p[9]);\n+  p[10] = std::sinh (p[10]);\n+  p[11] = std::tanh (p[11]);\n+  p[12] = std::exp (p[12]);\n+  p[13] = std::exp2 (p[13]);\n+  p[14] = std::expm1 (p[14]);\n+  p[15] = std::log (p[15]);\n+  p[16] = std::log10 (p[16]);\n+  p[17] = std::log1p (p[17]);\n+  p[18] = std::log2 (p[18]);\n+  p[19] = std::logb (p[19]);\n+  p[20] = std::cbrt (p[20]);\n+  p[21] = std::fabs (p[21]);\n+  p[22] = std::sqrt (p[22]);\n+  p[23] = std::erf (p[23]);\n+  p[24] = std::erfc (p[24]);\n+  p[25] = std::lgamma (p[25]);\n+  p[26] = std::tgamma (p[26]);\n+  p[27] = std::ceil (p[27]);\n+  p[28] = std::floor (p[28]);\n+  p[29] = std::nearbyint (p[29]);\n+  p[30] = std::rint (p[30]);\n+  p[31] = std::round (p[31]);\n+  p[32] = std::trunc (p[32]);\n+  p[33] = std::atan2 (p[33], p[100]);\n+  p[34] = std::hypot (p[34], p[101]);\n+  p[35] = std::pow (p[35], p[102]);\n+  p[36] = std::fmod (p[36], p[103]);\n+  p[37] = std::remainder (p[37], p[104]);\n+  p[38] = std::copysign (p[38], p[105]);\n+//  p[39] = std::nextafter (p[39], p[106]);\n+  p[40] = std::fdim (p[40], p[107]);\n+  p[41] = std::fmax (p[41], p[108]);\n+  p[42] = std::fmin (p[42], p[109]);\n+  p[43] = std::atan2 (p[43], p[110]);\n+  p[44] = std::frexp (p[44], q + 0);\n+  q[1] = std::ilogb (p[45]);\n+  p[46] = std::ldexp (p[46], q[2]);\n+  p[47] = std::modf (p[47], p + 111);\n+  p[48] = std::scalbn (p[48], q[3]);\n+  p[49] = std::scalbln (p[49], r[0]);\n+  p[50] = std::hypot (p[50], p[111], p[112]);\n+  r[1] = std::lrint (p[51]);\n+  s[0] = std::llrint (p[52]);\n+  r[2] = std::lround (p[53]);\n+  s[1] = std::llround (p[54]);\n+  p[55] = std::remquo (p[55], p[113], q + 4);\n+  p[56] = std::fma (p[56], p[114], p[115]);\n+  p[57] = std::lerp (p[57], p[116], p[117]);\n+  p[58] = std::assoc_laguerre (q[5], q[6], p[58]);\n+  p[59] = std::assoc_legendre (q[7], q[8], p[59]);\n+  p[60] = std::beta (p[60], p[118]);\n+  p[61] = std::comp_ellint_1 (p[61]);\n+  p[62] = std::comp_ellint_2 (p[62]);\n+  p[63] = std::comp_ellint_3 (p[63], p[119]);\n+  p[64] = std::cyl_bessel_i (p[64], p[120]);\n+  p[65] = std::cyl_bessel_j (p[65], p[121]);\n+  p[66] = std::cyl_bessel_k (p[66], p[122]);\n+  p[67] = std::cyl_neumann (p[67], p[123]);\n+  p[68] = std::ellint_1 (p[68], p[124]);\n+  p[69] = std::ellint_2 (p[69], p[125]);\n+  p[70] = std::ellint_3 (p[70], p[126], p[127]);\n+  p[71] = std::expint (p[71]);\n+  p[72] = std::hermite (q[9], p[72]);\n+  p[73] = std::laguerre (q[10], p[73]);\n+  p[74] = std::legendre (q[11], p[72]);\n+  p[75] = std::riemann_zeta (p[75]);\n+  p[76] = std::sph_bessel (q[12], p[76]);\n+  p[77] = std::sph_legendre (q[13], q[14], p[77]);\n+  p[78] = std::sph_neumann (q[15], q[16], p[78]);\n+}\n+\n+int\n+main ()\n+{\n+  int q[17] = {};\n+  long int r[16] = {};\n+  long long int s[16] = {};\n+#if defined(__STDCPP_FLOAT16_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32)\n+  {\n+    std::float16_t p[128] = {};\n+    test_functions (p, q, r, s);\n+  }\n+#endif\n+#if defined(__STDCPP_FLOAT32_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32)\n+  {\n+    std::float32_t p[128] = {};\n+    test_functions (p, q, r, s);\n+  }\n+#endif\n+#if defined(__STDCPP_FLOAT64_T__) && defined(_GLIBCXX_DOUBLE_IS_IEEE_BINARY64)\n+  {\n+    std::float64_t p[128] = {};\n+    test_functions (p, q, r, s);\n+  }\n+#endif\n+#if defined(__STDCPP_FLOAT128_T__) \\\n+    && (defined(_GLIBCXX_DOUBLE_IS_IEEE_BINARY128) \\\n+\t|| defined(_GLIBCXX_HAVE_FLOAT128_MATH))\n+  {\n+    std::float128_t p[128] = {};\n+    test_functions (p, q, r, s);\n+  }\n+#endif\n+#if defined(__STDCPP_BFLOAT16_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32)\n+  {\n+    std::bfloat16_t p[128] = {};\n+    test_functions (p, q, r, s);\n+  }\n+#endif\n+}"}, {"sha": "4a599887acd7988131a11dd5392e66a60d9a9963", "filename": "libstdc++-v3/testsuite/26_numerics/numbers/4.cc", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a23225fb4f764dfc3e3e729c7d7238f03f282aaa/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fnumbers%2F4.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a23225fb4f764dfc3e3e729c7d7238f03f282aaa/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fnumbers%2F4.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fnumbers%2F4.cc?ref=a23225fb4f764dfc3e3e729c7d7238f03f282aaa", "patch": "@@ -0,0 +1,122 @@\n+// Copyright (C) 2022 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2b\" }\n+// { dg-do compile { target c++23 } }\n+\n+#include <numbers>\n+#include <stdfloat>\n+\n+#if defined(__STDCPP_FLOAT16_T__)\n+void\n+test01()\n+{\n+  const std::float16_t* d1  = &std::numbers::e_v<std::float16_t>;\n+  const std::float16_t* d2  = &std::numbers::log2e_v<std::float16_t>;\n+  const std::float16_t* d3  = &std::numbers::log10e_v<std::float16_t>;\n+  const std::float16_t* d4  = &std::numbers::pi_v<std::float16_t>;\n+  const std::float16_t* d5  = &std::numbers::inv_pi_v<std::float16_t>;\n+  const std::float16_t* d6  = &std::numbers::inv_sqrtpi_v<std::float16_t>;\n+  const std::float16_t* d7  = &std::numbers::ln2_v<std::float16_t>;\n+  const std::float16_t* d8  = &std::numbers::ln10_v<std::float16_t>;\n+  const std::float16_t* d9  = &std::numbers::sqrt2_v<std::float16_t>;\n+  const std::float16_t* d10 = &std::numbers::sqrt3_v<std::float16_t>;\n+  const std::float16_t* d11 = &std::numbers::inv_sqrt3_v<std::float16_t>;\n+  const std::float16_t* d12 = &std::numbers::egamma_v<std::float16_t>;\n+  const std::float16_t* d13 = &std::numbers::phi_v<std::float16_t>;\n+}\n+#endif\n+\n+#if defined(__STDCPP_FLOAT32_T__)\n+void\n+test02()\n+{\n+  const std::float32_t* d1  = &std::numbers::e_v<std::float32_t>;\n+  const std::float32_t* d2  = &std::numbers::log2e_v<std::float32_t>;\n+  const std::float32_t* d3  = &std::numbers::log10e_v<std::float32_t>;\n+  const std::float32_t* d4  = &std::numbers::pi_v<std::float32_t>;\n+  const std::float32_t* d5  = &std::numbers::inv_pi_v<std::float32_t>;\n+  const std::float32_t* d6  = &std::numbers::inv_sqrtpi_v<std::float32_t>;\n+  const std::float32_t* d7  = &std::numbers::ln2_v<std::float32_t>;\n+  const std::float32_t* d8  = &std::numbers::ln10_v<std::float32_t>;\n+  const std::float32_t* d9  = &std::numbers::sqrt2_v<std::float32_t>;\n+  const std::float32_t* d10 = &std::numbers::sqrt3_v<std::float32_t>;\n+  const std::float32_t* d11 = &std::numbers::inv_sqrt3_v<std::float32_t>;\n+  const std::float32_t* d12 = &std::numbers::egamma_v<std::float32_t>;\n+  const std::float32_t* d13 = &std::numbers::phi_v<std::float32_t>;\n+}\n+#endif\n+\n+#if defined(__STDCPP_FLOAT64_T__)\n+void\n+test03()\n+{\n+  const std::float64_t* d1  = &std::numbers::e_v<std::float64_t>;\n+  const std::float64_t* d2  = &std::numbers::log2e_v<std::float64_t>;\n+  const std::float64_t* d3  = &std::numbers::log10e_v<std::float64_t>;\n+  const std::float64_t* d4  = &std::numbers::pi_v<std::float64_t>;\n+  const std::float64_t* d5  = &std::numbers::inv_pi_v<std::float64_t>;\n+  const std::float64_t* d6  = &std::numbers::inv_sqrtpi_v<std::float64_t>;\n+  const std::float64_t* d7  = &std::numbers::ln2_v<std::float64_t>;\n+  const std::float64_t* d8  = &std::numbers::ln10_v<std::float64_t>;\n+  const std::float64_t* d9  = &std::numbers::sqrt2_v<std::float64_t>;\n+  const std::float64_t* d10 = &std::numbers::sqrt3_v<std::float64_t>;\n+  const std::float64_t* d11 = &std::numbers::inv_sqrt3_v<std::float64_t>;\n+  const std::float64_t* d12 = &std::numbers::egamma_v<std::float64_t>;\n+  const std::float64_t* d13 = &std::numbers::phi_v<std::float64_t>;\n+}\n+#endif\n+\n+#if defined(__STDCPP_FLOAT128_T__)\n+void\n+test04()\n+{\n+  const std::float128_t* d1  = &std::numbers::e_v<std::float128_t>;\n+  const std::float128_t* d2  = &std::numbers::log2e_v<std::float128_t>;\n+  const std::float128_t* d3  = &std::numbers::log10e_v<std::float128_t>;\n+  const std::float128_t* d4  = &std::numbers::pi_v<std::float128_t>;\n+  const std::float128_t* d5  = &std::numbers::inv_pi_v<std::float128_t>;\n+  const std::float128_t* d6  = &std::numbers::inv_sqrtpi_v<std::float128_t>;\n+  const std::float128_t* d7  = &std::numbers::ln2_v<std::float128_t>;\n+  const std::float128_t* d8  = &std::numbers::ln10_v<std::float128_t>;\n+  const std::float128_t* d9  = &std::numbers::sqrt2_v<std::float128_t>;\n+  const std::float128_t* d10 = &std::numbers::sqrt3_v<std::float128_t>;\n+  const std::float128_t* d11 = &std::numbers::inv_sqrt3_v<std::float128_t>;\n+  const std::float128_t* d12 = &std::numbers::egamma_v<std::float128_t>;\n+  const std::float128_t* d13 = &std::numbers::phi_v<std::float128_t>;\n+}\n+#endif\n+\n+#if defined(__STDCPP_BFLOAT16_T__)\n+void\n+test05()\n+{\n+  const std::bfloat16_t* d1  = &std::numbers::e_v<std::bfloat16_t>;\n+  const std::bfloat16_t* d2  = &std::numbers::log2e_v<std::bfloat16_t>;\n+  const std::bfloat16_t* d3  = &std::numbers::log10e_v<std::bfloat16_t>;\n+  const std::bfloat16_t* d4  = &std::numbers::pi_v<std::bfloat16_t>;\n+  const std::bfloat16_t* d5  = &std::numbers::inv_pi_v<std::bfloat16_t>;\n+  const std::bfloat16_t* d6  = &std::numbers::inv_sqrtpi_v<std::bfloat16_t>;\n+  const std::bfloat16_t* d7  = &std::numbers::ln2_v<std::bfloat16_t>;\n+  const std::bfloat16_t* d8  = &std::numbers::ln10_v<std::bfloat16_t>;\n+  const std::bfloat16_t* d9  = &std::numbers::sqrt2_v<std::bfloat16_t>;\n+  const std::bfloat16_t* d10 = &std::numbers::sqrt3_v<std::bfloat16_t>;\n+  const std::bfloat16_t* d11 = &std::numbers::inv_sqrt3_v<std::bfloat16_t>;\n+  const std::bfloat16_t* d12 = &std::numbers::egamma_v<std::bfloat16_t>;\n+  const std::bfloat16_t* d13 = &std::numbers::phi_v<std::bfloat16_t>;\n+}\n+#endif"}, {"sha": "9c33b2597daade47577bfa802f2bca99159632a0", "filename": "libstdc++-v3/testsuite/29_atomics/atomic_float/requirements_cxx23.cc", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a23225fb4f764dfc3e3e729c7d7238f03f282aaa/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_float%2Frequirements_cxx23.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a23225fb4f764dfc3e3e729c7d7238f03f282aaa/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_float%2Frequirements_cxx23.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_float%2Frequirements_cxx23.cc?ref=a23225fb4f764dfc3e3e729c7d7238f03f282aaa", "patch": "@@ -0,0 +1,112 @@\n+// Copyright (C) 2022 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2b\" }\n+// { dg-do compile { target c++23 } }\n+\n+#include <atomic>\n+#include <stdfloat>\n+\n+#if defined(__STDCPP_FLOAT16_T__)\n+void\n+test01()\n+{\n+  using A = std::atomic<std::float16_t>;\n+  static_assert( std::is_standard_layout_v<A> );\n+  static_assert( !std::is_trivially_default_constructible_v<A> );\n+  static_assert( std::is_trivially_destructible_v<A> );\n+  static_assert( std::is_same_v<A::value_type, std::float16_t> );\n+  static_assert( std::is_same_v<A::difference_type, A::value_type> );\n+  static_assert( !std::is_copy_constructible_v<A> );\n+  static_assert( !std::is_move_constructible_v<A> );\n+  static_assert( !std::is_copy_assignable_v<A> );\n+  static_assert( !std::is_move_assignable_v<A> );\n+  static_assert( !std::is_assignable_v<volatile A&, const A&> );\n+}\n+#endif\n+\n+#if defined(__STDCPP_FLOAT32_T__)\n+void\n+test02()\n+{\n+  using A = std::atomic<std::float32_t>;\n+  static_assert( std::is_standard_layout_v<A> );\n+  static_assert( !std::is_trivially_default_constructible_v<A> );\n+  static_assert( std::is_trivially_destructible_v<A> );\n+  static_assert( std::is_same_v<A::value_type, std::float32_t> );\n+  static_assert( std::is_same_v<A::difference_type, A::value_type> );\n+  static_assert( !std::is_copy_constructible_v<A> );\n+  static_assert( !std::is_move_constructible_v<A> );\n+  static_assert( !std::is_copy_assignable_v<A> );\n+  static_assert( !std::is_move_assignable_v<A> );\n+  static_assert( !std::is_assignable_v<volatile A&, const A&> );\n+}\n+#endif\n+\n+#if defined(__STDCPP_FLOAT64_T__)\n+void\n+test03()\n+{\n+  using A = std::atomic<std::float64_t>;\n+  static_assert( std::is_standard_layout_v<A> );\n+  static_assert( !std::is_trivially_default_constructible_v<A> );\n+  static_assert( std::is_trivially_destructible_v<A> );\n+  static_assert( std::is_same_v<A::value_type, std::float64_t> );\n+  static_assert( std::is_same_v<A::difference_type, A::value_type> );\n+  static_assert( !std::is_copy_constructible_v<A> );\n+  static_assert( !std::is_move_constructible_v<A> );\n+  static_assert( !std::is_copy_assignable_v<A> );\n+  static_assert( !std::is_move_assignable_v<A> );\n+  static_assert( !std::is_assignable_v<volatile A&, const A&> );\n+}\n+#endif\n+\n+#if defined(__STDCPP_FLOAT128_T__)\n+void\n+test04()\n+{\n+  using A = std::atomic<std::float128_t>;\n+  static_assert( std::is_standard_layout_v<A> );\n+  static_assert( !std::is_trivially_default_constructible_v<A> );\n+  static_assert( std::is_trivially_destructible_v<A> );\n+  static_assert( std::is_same_v<A::value_type, std::float128_t> );\n+  static_assert( std::is_same_v<A::difference_type, A::value_type> );\n+  static_assert( !std::is_copy_constructible_v<A> );\n+  static_assert( !std::is_move_constructible_v<A> );\n+  static_assert( !std::is_copy_assignable_v<A> );\n+  static_assert( !std::is_move_assignable_v<A> );\n+  static_assert( !std::is_assignable_v<volatile A&, const A&> );\n+}\n+#endif\n+\n+#if defined(__STDCPP_BFLOAT16_T__)\n+void\n+test05()\n+{\n+  using A = std::atomic<std::bfloat16_t>;\n+  static_assert( std::is_standard_layout_v<A> );\n+  static_assert( !std::is_trivially_default_constructible_v<A> );\n+  static_assert( std::is_trivially_destructible_v<A> );\n+  static_assert( std::is_same_v<A::value_type, std::bfloat16_t> );\n+  static_assert( std::is_same_v<A::difference_type, A::value_type> );\n+  static_assert( !std::is_copy_constructible_v<A> );\n+  static_assert( !std::is_move_constructible_v<A> );\n+  static_assert( !std::is_copy_assignable_v<A> );\n+  static_assert( !std::is_move_assignable_v<A> );\n+  static_assert( !std::is_assignable_v<volatile A&, const A&> );\n+}\n+#endif"}]}