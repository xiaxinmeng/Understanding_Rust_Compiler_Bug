{"sha": "132c7dd3d966066e2c031b7ed31690b5ec933705", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTMyYzdkZDNkOTY2MDY2ZTJjMDMxYjdlZDMxNjkwYjVlYzkzMzcwNQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2004-07-15T15:06:26Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-07-15T15:06:26Z"}, "message": "class.c (finish_struct_bits): Don't set TYPE_HAS_CONVERSION here.\n\n\t* class.c(finish_struct_bits): Don't set TYPE_HAS_CONVERSION here.\n\t* decl.c (xref_basetypes): Set it here.\n\nFrom-SVN: r84756", "tree": {"sha": "d0bcfe2d119966b5f8e0d007d0cce4496738ad27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d0bcfe2d119966b5f8e0d007d0cce4496738ad27"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/132c7dd3d966066e2c031b7ed31690b5ec933705", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/132c7dd3d966066e2c031b7ed31690b5ec933705", "html_url": "https://github.com/Rust-GCC/gccrs/commit/132c7dd3d966066e2c031b7ed31690b5ec933705", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/132c7dd3d966066e2c031b7ed31690b5ec933705/comments", "author": null, "committer": null, "parents": [{"sha": "769d99d9cdc419ccc801f369f0043281054b5452", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/769d99d9cdc419ccc801f369f0043281054b5452", "html_url": "https://github.com/Rust-GCC/gccrs/commit/769d99d9cdc419ccc801f369f0043281054b5452"}], "stats": {"total": 47, "additions": 18, "deletions": 29}, "files": [{"sha": "75ae59c4b9b2978866697859cdcc825b9fa4e3da", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/132c7dd3d966066e2c031b7ed31690b5ec933705/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/132c7dd3d966066e2c031b7ed31690b5ec933705/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=132c7dd3d966066e2c031b7ed31690b5ec933705", "patch": "@@ -1,5 +1,8 @@\n 2004-07-15  Nathan Sidwell  <nathan@codesourcery.com>\n \n+\t* class.c(finish_struct_bits): Don't set TYPE_HAS_CONVERSION here.\n+\t* decl.c (xref_basetypes): Set it here.\n+\n \t* class.c (check_bases): Don't set CLASSTYPE_NON_AGGREGATE here.\n \tDon't check for incomplete base.\n \t(get_vfield_name): Simplify while loop."}, {"sha": "2957ac1be149f60baf829fb4bb118dc41692cc4a", "filename": "gcc/cp/class.c", "status": "modified", "additions": 14, "deletions": 29, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/132c7dd3d966066e2c031b7ed31690b5ec933705/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/132c7dd3d966066e2c031b7ed31690b5ec933705/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=132c7dd3d966066e2c031b7ed31690b5ec933705", "patch": "@@ -1464,7 +1464,7 @@ determine_primary_base (tree t)\n static void\n finish_struct_bits (tree t)\n {\n-  int i, n_baseclasses = BINFO_N_BASE_BINFOS (TYPE_BINFO (t));\n+  int n_baseclasses = BINFO_N_BASE_BINFOS (TYPE_BINFO (t));\n \n   /* Fix up variants (if any).  */\n   tree variants = TYPE_NEXT_VARIANT (t);\n@@ -1497,34 +1497,19 @@ finish_struct_bits (tree t)\n \n   if (n_baseclasses && TYPE_POLYMORPHIC_P (t))\n     /* For a class w/o baseclasses, `finish_struct' has set\n-       CLASS_TYPE_ABSTRACT_VIRTUALS correctly (by\n-       definition). Similarly for a class whose base classes do not\n-       have vtables. When neither of these is true, we might have\n-       removed abstract virtuals (by providing a definition), added\n-       some (by declaring new ones), or redeclared ones from a base\n-       class. We need to recalculate what's really an abstract virtual\n-       at this point (by looking in the vtables).  */\n-      get_pure_virtuals (t);\n-\n-  if (n_baseclasses)\n-    {\n-      /* Notice whether this class has type conversion functions defined.  */\n-      tree binfo = TYPE_BINFO (t);\n-      tree binfos = BINFO_BASE_BINFOS (binfo);\n-      tree basetype;\n-\n-      for (i = n_baseclasses-1; i >= 0; i--)\n-\t{\n-\t  basetype = BINFO_TYPE (TREE_VEC_ELT (binfos, i));\n-\n-\t  TYPE_HAS_CONVERSION (t) |= TYPE_HAS_CONVERSION (basetype);\n-\t}\n-    }\n-\n-  /* If this type has a copy constructor or a destructor, force its mode to\n-     be BLKmode, and force its TREE_ADDRESSABLE bit to be nonzero.  This\n-     will cause it to be passed by invisible reference and prevent it from\n-     being returned in a register.  */\n+       CLASS_TYPE_ABSTRACT_VIRTUALS correctly (by definition).\n+       Similarly for a class whose base classes do not have vtables.\n+       When neither of these is true, we might have removed abstract\n+       virtuals (by providing a definition), added some (by declaring\n+       new ones), or redeclared ones from a base class.  We need to\n+       recalculate what's really an abstract virtual at this point (by\n+       looking in the vtables).  */\n+    get_pure_virtuals (t);\n+\n+  /* If this type has a copy constructor or a destructor, force its\n+     mode to be BLKmode, and force its TREE_ADDRESSABLE bit to be\n+     nonzero.  This will cause it to be passed by invisible reference\n+     and prevent it from being returned in a register.  */\n   if (! TYPE_HAS_TRIVIAL_INIT_REF (t) || TYPE_HAS_NONTRIVIAL_DESTRUCTOR (t))\n     {\n       tree variants;"}, {"sha": "1c547f641f9a83707666a96f1dcb85f28abd1f07", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/132c7dd3d966066e2c031b7ed31690b5ec933705/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/132c7dd3d966066e2c031b7ed31690b5ec933705/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=132c7dd3d966066e2c031b7ed31690b5ec933705", "patch": "@@ -9170,6 +9170,7 @@ xref_basetypes (tree ref, tree base_list)\n \t     \t base as well.  */\n \t      TYPE_BASE_CONVS_MAY_REQUIRE_CODE_P (ref)\n \t\t|= TYPE_BASE_CONVS_MAY_REQUIRE_CODE_P (basetype);\n+\t      TYPE_HAS_CONVERSION (ref) |= TYPE_HAS_CONVERSION (basetype);\n \t      max_vbases += VEC_length\n \t\t(tree, CLASSTYPE_VBASECLASSES (basetype));\n \t    }"}]}