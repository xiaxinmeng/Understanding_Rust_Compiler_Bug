{"sha": "224aaa4139918fa03e1a490f99bcb8bfb35c91be", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjI0YWFhNDEzOTkxOGZhMDNlMWE0OTBmOTliY2I4YmZiMzVjOTFiZQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2006-08-03T17:13:51Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2006-08-03T17:13:51Z"}, "message": "jvmti.cc (REQUIRE_PHASE): New macro.\n\n\t* jvmti.cc (REQUIRE_PHASE): New macro.\n\t(_Jv_JVMTI_InterruptThread): New function.\n\t(_Jv_JVMTI_CreateRawMonitor): Likewise.\n\t(_Jv_JVMTI_DestroyRawMonitor): Likewise.\n\t(_Jv_JVMTI_RawMonitorEnter): Likewise.\n\t(_Jv_JVMTI_RawMonitorExit): Likewise.\n\t(_Jv_JVMTI_RawMonitorWait): Likewise.\n\t(_Jv_JVMTI_RawMonitorNotify): Likewise.\n\t(_Jv_JVMTI_RawMonitorNotifyAll): Likewise.\n\t(_Jv_JVMTI_Allocate): Likewise.\n\t(_Jv_JVMTI_Deallocate): Likewise.\n\t(_Jv_JVMTI_GetClassModifiers): Likewise.\n\t(_Jv_JVMTI_GetClassMethods): Likewise.\n\t(_Jv_JVMTI_IsInterface): Likewise.\n\t(_Jv_JVMTI_IsArrayClass): Likewise.\n\t(_Jv_JVMTI_GetClassLoader): Likewise.\n\t(_Jv_JVMTI_GetObjectHashCode): Likewise.\n\t(_Jv_JVMTI_GetFieldModifiers): Likewise.\n\t(_Jv_JVMTI_IsFieldSynthetic): Likewise.\n\t(_Jv_JVMTI_GetMethodModifiers): Likewise.\n\t(_Jv_JVMTI_IsMethodNative): Likewise.\n\t(_Jv_JVMTI_IsMethodSynthetic): Likewise.\n\t(_Jv_JVMTI_GetClassLoaderClasses): Likewise.\n\t(_Jv_JVMTI_ForceGarbageCollection): Likewise.\n\t(_Jv_JVMTI_GetSystemProperty): Likewise.\n\t(_Jv_JVMTI_SetSystemProperty): Likewise.\n\t(_Jv_JVMTI_GetTime): Likewise.\n\t(_Jv_JVMTI_GetAvailableProcessors): Likewise.\n\t(_Jv_JVMTI_AddToBootstrapClassLoaderSearch): Likewise.\n\t(_Jv_JVMTI_SetVerboseFlag): Likewise.\n\t(_Jv_JVMTI_GetObjectSize): Likewise.\n\t(_Jv_JVMTI_SetJNIFunctionTable): Likewise.\n\t(_Jv_JVMTI_GetJNIFunctionTable): Likewise.\n\t(_Jv_JVMTI_Interface): Updated.\n\t(NULL_CHECK): New macro.\n\nFrom-SVN: r115907", "tree": {"sha": "c178983d39a142724a349e519fc4e0cfcad9a9f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c178983d39a142724a349e519fc4e0cfcad9a9f3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/224aaa4139918fa03e1a490f99bcb8bfb35c91be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/224aaa4139918fa03e1a490f99bcb8bfb35c91be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/224aaa4139918fa03e1a490f99bcb8bfb35c91be", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/224aaa4139918fa03e1a490f99bcb8bfb35c91be/comments", "author": null, "committer": null, "parents": [{"sha": "00643d1ce2adb916eefdf112b1a86fb120679f0f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00643d1ce2adb916eefdf112b1a86fb120679f0f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00643d1ce2adb916eefdf112b1a86fb120679f0f"}], "stats": {"total": 609, "additions": 574, "deletions": 35}, "files": [{"sha": "8b10aab53c05e0ae0c574c31d3014bbbec158dec", "filename": "libjava/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/224aaa4139918fa03e1a490f99bcb8bfb35c91be/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/224aaa4139918fa03e1a490f99bcb8bfb35c91be/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=224aaa4139918fa03e1a490f99bcb8bfb35c91be", "patch": "@@ -1,3 +1,41 @@\n+2006-08-03  Tom Tromey  <tromey@redhat.com>\n+\n+\t* jvmti.cc (REQUIRE_PHASE): New macro.\n+\t(_Jv_JVMTI_InterruptThread): New function.\n+\t(_Jv_JVMTI_CreateRawMonitor): Likewise.\n+\t(_Jv_JVMTI_DestroyRawMonitor): Likewise.\n+\t(_Jv_JVMTI_RawMonitorEnter): Likewise.\n+\t(_Jv_JVMTI_RawMonitorExit): Likewise.\n+\t(_Jv_JVMTI_RawMonitorWait): Likewise.\n+\t(_Jv_JVMTI_RawMonitorNotify): Likewise.\n+\t(_Jv_JVMTI_RawMonitorNotifyAll): Likewise.\n+\t(_Jv_JVMTI_Allocate): Likewise.\n+\t(_Jv_JVMTI_Deallocate): Likewise.\n+\t(_Jv_JVMTI_GetClassModifiers): Likewise.\n+\t(_Jv_JVMTI_GetClassMethods): Likewise.\n+\t(_Jv_JVMTI_IsInterface): Likewise.\n+\t(_Jv_JVMTI_IsArrayClass): Likewise.\n+\t(_Jv_JVMTI_GetClassLoader): Likewise.\n+\t(_Jv_JVMTI_GetObjectHashCode): Likewise.\n+\t(_Jv_JVMTI_GetFieldModifiers): Likewise.\n+\t(_Jv_JVMTI_IsFieldSynthetic): Likewise.\n+\t(_Jv_JVMTI_GetMethodModifiers): Likewise.\n+\t(_Jv_JVMTI_IsMethodNative): Likewise.\n+\t(_Jv_JVMTI_IsMethodSynthetic): Likewise.\n+\t(_Jv_JVMTI_GetClassLoaderClasses): Likewise.\n+\t(_Jv_JVMTI_ForceGarbageCollection): Likewise.\n+\t(_Jv_JVMTI_GetSystemProperty): Likewise.\n+\t(_Jv_JVMTI_SetSystemProperty): Likewise.\n+\t(_Jv_JVMTI_GetTime): Likewise.\n+\t(_Jv_JVMTI_GetAvailableProcessors): Likewise.\n+\t(_Jv_JVMTI_AddToBootstrapClassLoaderSearch): Likewise.\n+\t(_Jv_JVMTI_SetVerboseFlag): Likewise.\n+\t(_Jv_JVMTI_GetObjectSize): Likewise.\n+\t(_Jv_JVMTI_SetJNIFunctionTable): Likewise.\n+\t(_Jv_JVMTI_GetJNIFunctionTable): Likewise.\n+\t(_Jv_JVMTI_Interface): Updated.\n+\t(NULL_CHECK): New macro.\n+\n 2006-08-02  Andreas Tobler  <a.tobler@schweiz.ch>\n \n \tPR libgcj/28546"}, {"sha": "f0d7e57c938265f41cd55d7ce9e7bc6387a86ae9", "filename": "libjava/jvmti.cc", "status": "modified", "additions": 536, "deletions": 35, "changes": 571, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/224aaa4139918fa03e1a490f99bcb8bfb35c91be/libjava%2Fjvmti.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/224aaa4139918fa03e1a490f99bcb8bfb35c91be/libjava%2Fjvmti.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjvmti.cc?ref=224aaa4139918fa03e1a490f99bcb8bfb35c91be", "patch": "@@ -9,13 +9,33 @@ Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n details.  */\n \n #include <config.h>\n+#include <platform.h>\n \n #include <jvm.h>\n #include <java-threads.h>\n #include <java-gc.h>\n #include <jvmti.h>\n \n+#include <gnu/classpath/SystemProperties.h>\n+#include <gnu/gcj/runtime/BootClassLoader.h>\n+#include <java/lang/Class.h>\n+#include <java/lang/ClassLoader.h>\n #include <java/lang/Thread.h>\n+#include <java/lang/Throwable.h>\n+#include <java/lang/VMClassLoader.h>\n+#include <java/lang/reflect/Field.h>\n+#include <java/lang/reflect/Modifier.h>\n+#include <java/util/Collection.h>\n+#include <java/util/HashMap.h>\n+#include <java/net/URL.h>\n+\n+extern struct JNINativeInterface _Jv_JNIFunctions;\n+\n+struct _Jv_rawMonitorID\n+{\n+  _Jv_Mutex_t mutex;\n+  _Jv_ConditionVariable_t condition;\n+};\n \n // Some commonly-used checks\n \n@@ -29,6 +49,13 @@ details.  */\n #define THREAD_CHECK_IS_ALIVE(thread)\t\t\t\t\\\n   if (!thread->isAlive ()) return JVMTI_ERROR_THREAD_NOT_ALIVE;\n \n+// FIXME: if current phase is not set in Phases,\n+// return JVMTI_ERROR_WRONG_PHASE\n+#define REQUIRE_PHASE(Env, Phases)\n+\n+#define NULL_CHECK(Ptr)\t\t\t\t\t\\\n+  if (Ptr == NULL) return JVMTI_ERROR_NULL_POINTER;\n+\n static jvmtiError JNICALL\n _Jv_JVMTI_SuspendThread (MAYBE_UNUSED jvmtiEnv *env, jthread thread)\n {\n@@ -61,8 +88,340 @@ _Jv_JVMTI_ResumeThread (MAYBE_UNUSED jvmtiEnv *env, jthread thread)\n   return JVMTI_ERROR_NONE;\n }\n \n-#define RESERVED NULL\n-#define UNIMPLEMENTED NULL\n+static jvmtiError JNICALL\n+_Jv_JVMTI_InterruptThread (MAYBE_UNUSED jvmtiEnv *env, jthread thread)\n+{\n+  using namespace java::lang;\n+\n+  REQUIRE_PHASE (env, JVMTI_PHASE_LIVE);\n+  // FIXME: capability handling?  'can_signal_thread'\n+  if (thread == NULL)\n+    return JVMTI_ERROR_INVALID_THREAD;\n+  THREAD_CHECK_VALID (thread);\n+  Thread *real_thread = reinterpret_cast<Thread *> (thread);\n+  THREAD_CHECK_IS_ALIVE (real_thread);\n+  real_thread->interrupt();\n+  return JVMTI_ERROR_NONE;\n+}\n+\n+static jvmtiError JNICALL\n+_Jv_JVMTI_CreateRawMonitor (MAYBE_UNUSED jvmtiEnv *env, const char *name,\n+\t\t\t    jrawMonitorID *result)\n+{\n+  REQUIRE_PHASE (env, JVMTI_PHASE_ONLOAD | JVMTI_PHASE_LIVE);\n+  NULL_CHECK (name);\n+  NULL_CHECK (result);\n+  *result = (jrawMonitorID) _Jv_Malloc (sizeof (_Jv_rawMonitorID));\n+  _Jv_MutexInit (&(*result)->mutex);\n+  _Jv_CondInit (&(*result)->condition);\n+  return JVMTI_ERROR_NONE;\n+}\n+\n+static jvmtiError JNICALL\n+_Jv_JVMTI_DestroyRawMonitor (MAYBE_UNUSED jvmtiEnv *env, jrawMonitorID monitor)\n+{\n+  REQUIRE_PHASE (env, JVMTI_PHASE_ONLOAD | JVMTI_PHASE_LIVE);\n+  // Note we have no better way of knowing whether this object is\n+  // really a raw monitor.\n+  if (monitor == NULL)\n+    return JVMTI_ERROR_INVALID_MONITOR;\n+  // FIXME: perform checks on monitor, release it if this thread owns\n+  // it.\n+#ifdef _Jv_HaveMutexDestroy\n+  _Jv_MutexDestroy (&monitor->mutex);\n+#endif\n+  _Jv_Free (monitor);\n+  return JVMTI_ERROR_NONE;\n+}\n+\n+static jvmtiError JNICALL\n+_Jv_JVMTI_RawMonitorEnter (MAYBE_UNUSED jvmtiEnv *env, jrawMonitorID monitor)\n+{\n+  if (monitor == NULL)\n+    return JVMTI_ERROR_INVALID_MONITOR;\n+  _Jv_MutexLock (&monitor->mutex);\n+  return JVMTI_ERROR_NONE;\n+}\n+\n+static jvmtiError JNICALL\n+_Jv_JVMTI_RawMonitorExit (MAYBE_UNUSED jvmtiEnv *env, jrawMonitorID monitor)\n+{\n+  if (monitor == NULL)\n+    return JVMTI_ERROR_INVALID_MONITOR;\n+  if (_Jv_MutexUnlock (&monitor->mutex))\n+    return JVMTI_ERROR_NOT_MONITOR_OWNER;\n+  return JVMTI_ERROR_NONE;\n+}\n+\n+static jvmtiError JNICALL\n+_Jv_JVMTI_RawMonitorWait (MAYBE_UNUSED jvmtiEnv *env, jrawMonitorID monitor)\n+{\n+  if (monitor == NULL)\n+    return JVMTI_ERROR_INVALID_MONITOR;\n+  int r = _Jv_CondWait (&monitor->condition, &monitor->mutex, 0, 0);\n+  if (r == _JV_NOT_OWNER)\n+    return JVMTI_ERROR_NOT_MONITOR_OWNER;\n+  if (r == _JV_INTERRUPTED)\n+    return JVMTI_ERROR_INTERRUPT;\n+  return JVMTI_ERROR_NONE;\n+}\n+\n+static jvmtiError JNICALL\n+_Jv_JVMTI_RawMonitorNotify (MAYBE_UNUSED jvmtiEnv *env, jrawMonitorID monitor)\n+{\n+  if (monitor == NULL)\n+    return JVMTI_ERROR_INVALID_MONITOR;\n+  if (_Jv_CondNotify (&monitor->condition, &monitor->mutex) == _JV_NOT_OWNER)\n+    return JVMTI_ERROR_NOT_MONITOR_OWNER;\n+  return JVMTI_ERROR_NONE;\n+}\n+\n+static jvmtiError JNICALL\n+_Jv_JVMTI_RawMonitorNotifyAll (MAYBE_UNUSED jvmtiEnv *env,\n+\t\t\t       jrawMonitorID monitor)\n+{\n+  if (monitor == NULL)\n+    return JVMTI_ERROR_INVALID_MONITOR;\n+  if (_Jv_CondNotifyAll (&monitor->condition, &monitor->mutex)\n+      == _JV_NOT_OWNER)\n+    return JVMTI_ERROR_NOT_MONITOR_OWNER;\n+  return JVMTI_ERROR_NONE;\n+}\n+\n+static jvmtiError JNICALL\n+_Jv_JVMTI_Allocate (MAYBE_UNUSED jvmtiEnv *env, jlong size,\n+\t\t    unsigned char **result)\n+{\n+  if (size < 0)\n+    return JVMTI_ERROR_ILLEGAL_ARGUMENT;\n+  NULL_CHECK (result);\n+  if (size == 0)\n+    *result = NULL;\n+  else\n+    {\n+      *result = (unsigned char *) _Jv_MallocUnchecked (size);\n+      if (*result == NULL)\n+\treturn JVMTI_ERROR_OUT_OF_MEMORY;\n+    }\n+  return JVMTI_ERROR_NONE;\n+}\n+\n+static jvmtiError JNICALL\n+_Jv_JVMTI_Deallocate (MAYBE_UNUSED jvmtiEnv *env, unsigned char *mem)\n+{\n+  if (mem != NULL)\n+    _Jv_Free (mem);\n+  return JVMTI_ERROR_NONE;\n+}\n+\n+static jvmtiError JNICALL\n+_Jv_JVMTI_GetClassModifiers (jvmtiEnv *env, jclass klass, jint *mods)\n+{\n+  REQUIRE_PHASE (env, JVMTI_PHASE_START | JVMTI_PHASE_LIVE);\n+  // Don't bother checking KLASS' type.\n+  if (klass == NULL)\n+    return JVMTI_ERROR_INVALID_CLASS;\n+  NULL_CHECK (mods);\n+  *mods = klass->getModifiers();\n+  return JVMTI_ERROR_NONE;\n+}\n+\n+static jvmtiError JNICALL\n+_Jv_JVMTI_GetClassMethods (jvmtiEnv *env, jclass klass, jint *count_ptr,\n+\t\t\t   jmethodID **methods_ptr)\n+{\n+  REQUIRE_PHASE (env, JVMTI_PHASE_START | JVMTI_PHASE_LIVE);\n+  // FIXME: capability can_maintain_original_method_order\n+  // Don't bother checking KLASS' type.\n+  if (klass == NULL)\n+    return JVMTI_ERROR_INVALID_CLASS;\n+  NULL_CHECK (count_ptr);\n+  NULL_CHECK (methods_ptr);\n+  *count_ptr = JvNumMethods(klass);\n+\n+  *methods_ptr = (jmethodID *) _Jv_Malloc (*count_ptr * sizeof (jmethodID));\n+  jmethodID start = JvGetFirstMethod (klass);\n+  for (jint i = 0; i < *count_ptr; ++i)\n+    // FIXME: correct?\n+    (*methods_ptr)[i] = start + i;\n+\n+  return JVMTI_ERROR_NONE;\n+}\n+\n+static jvmtiError JNICALL\n+_Jv_JVMTI_IsInterface (jvmtiEnv *env, jclass klass, jboolean *result)\n+{\n+  REQUIRE_PHASE (env, JVMTI_PHASE_START | JVMTI_PHASE_LIVE);\n+  if (klass == NULL)\n+    return JVMTI_ERROR_INVALID_CLASS;\n+  NULL_CHECK (result);\n+  *result = klass->isInterface();\n+  return JVMTI_ERROR_NONE;\n+}\n+\n+static jvmtiError JNICALL\n+_Jv_JVMTI_IsArrayClass (jvmtiEnv *env, jclass klass, jboolean *result)\n+{\n+  REQUIRE_PHASE (env, JVMTI_PHASE_START | JVMTI_PHASE_LIVE);\n+  if (klass == NULL)\n+    return JVMTI_ERROR_INVALID_CLASS;\n+  NULL_CHECK (result);\n+  *result = klass->isArray();\n+  return JVMTI_ERROR_NONE;\n+}\n+\n+static jvmtiError JNICALL\n+_Jv_JVMTI_GetClassLoader (jvmtiEnv *env, jclass klass, jobject *result)\n+{\n+  REQUIRE_PHASE (env, JVMTI_PHASE_START | JVMTI_PHASE_LIVE);\n+  if (klass == NULL)\n+    return JVMTI_ERROR_INVALID_CLASS;\n+  NULL_CHECK (result);\n+  *result = klass->getClassLoaderInternal();\n+  return JVMTI_ERROR_NONE;\n+}\n+\n+static jvmtiError JNICALL\n+_Jv_JVMTI_GetObjectHashCode (jvmtiEnv *env, jobject obj, jint *result)\n+{\n+  REQUIRE_PHASE (env, JVMTI_PHASE_START | JVMTI_PHASE_LIVE);\n+  if (obj == NULL)\n+    return JVMTI_ERROR_INVALID_OBJECT;\n+  NULL_CHECK (result);\n+  *result = _Jv_HashCode (obj);\n+  return JVMTI_ERROR_NONE;\n+}\n+\n+static jvmtiError JNICALL\n+_Jv_JVMTI_GetFieldModifiers (jvmtiEnv *env, jclass klass, jfieldID field,\n+\t\t\t     jint *result)\n+{\n+  REQUIRE_PHASE (env, JVMTI_PHASE_START | JVMTI_PHASE_LIVE);\n+  if (klass == NULL)\n+    return JVMTI_ERROR_INVALID_CLASS;\n+  if (field == NULL)\n+    return JVMTI_ERROR_INVALID_FIELDID;\n+  NULL_CHECK (result);\n+  *result = field->getModifiers();\n+  return JVMTI_ERROR_NONE;\n+}\n+\n+static jvmtiError JNICALL\n+_Jv_JVMTI_IsFieldSynthetic (jvmtiEnv *env, jclass klass, jfieldID field,\n+\t\t\t    jboolean *result)\n+{\n+  REQUIRE_PHASE (env, JVMTI_PHASE_START | JVMTI_PHASE_LIVE);\n+  if (klass == NULL)\n+    return JVMTI_ERROR_INVALID_CLASS;\n+  if (field == NULL)\n+    return JVMTI_ERROR_INVALID_FIELDID;\n+  NULL_CHECK (result);\n+\n+  // FIXME: capability can_get_synthetic_attribute\n+  *result = ((field->getModifiers() & java::lang::reflect::Modifier::SYNTHETIC)\n+\t     != 0);\n+  return JVMTI_ERROR_NONE;\n+}\n+\n+static jvmtiError JNICALL\n+_Jv_JVMTI_GetMethodModifiers (jvmtiEnv *env, jmethodID method, jint *result)\n+{\n+  REQUIRE_PHASE (env, JVMTI_PHASE_START | JVMTI_PHASE_LIVE);\n+  if (method == NULL)\n+    return JVMTI_ERROR_INVALID_METHODID;\n+  NULL_CHECK (result);\n+\n+  // FIXME: mask off some internal bits...\n+  *result = method->accflags;\n+  return JVMTI_ERROR_NONE;\n+}\n+\n+static jvmtiError JNICALL\n+_Jv_JVMTI_IsMethodNative (jvmtiEnv *env, jmethodID method, jboolean *result)\n+{\n+  REQUIRE_PHASE (env, JVMTI_PHASE_START | JVMTI_PHASE_LIVE);\n+  if (method == NULL)\n+    return JVMTI_ERROR_INVALID_METHODID;\n+  NULL_CHECK (result);\n+\n+  *result = ((method->accflags & java::lang::reflect::Modifier::NATIVE) != 0);\n+  return JVMTI_ERROR_NONE;\n+}\n+\n+static jvmtiError JNICALL\n+_Jv_JVMTI_IsMethodSynthetic (jvmtiEnv *env, jmethodID method, jboolean *result)\n+{\n+  REQUIRE_PHASE (env, JVMTI_PHASE_START | JVMTI_PHASE_LIVE);\n+  if (method == NULL)\n+    return JVMTI_ERROR_INVALID_METHODID;\n+  NULL_CHECK (result);\n+\n+  // FIXME capability can_get_synthetic_attribute\n+\n+  *result = ((method->accflags & java::lang::reflect::Modifier::SYNTHETIC)\n+\t     != 0);\n+  return JVMTI_ERROR_NONE;\n+}\n+\n+static jvmtiError JNICALL\n+_Jv_JVMTI_GetClassLoaderClasses (jvmtiEnv *env,\n+\t\t\t\t jobject init_loader,\n+\t\t\t\t jint *count_ptr,\n+\t\t\t\t jclass **result_ptr)\n+{\n+  using namespace java::lang;\n+  using namespace java::util;\n+\n+  REQUIRE_PHASE (env, JVMTI_PHASE_LIVE);\n+  NULL_CHECK (count_ptr);\n+  NULL_CHECK (result_ptr);\n+\n+  ClassLoader *loader = (ClassLoader *) init_loader;\n+  if (loader == NULL)\n+    loader = VMClassLoader::bootLoader;\n+\n+  Collection *values = loader->loadedClasses->values();\n+  jobjectArray array = values->toArray();\n+  *count_ptr = array->length;\n+  jobject *elts = elements (array);\n+  jclass *result = (jclass *) _Jv_Malloc (*count_ptr * sizeof (jclass));\n+  // FIXME: JNI references...\n+  memcpy (result, elts, *count_ptr * sizeof (jclass));\n+\n+  *result_ptr = result;\n+\n+  return JVMTI_ERROR_NONE;\n+}\n+\n+static jvmtiError JNICALL\n+_Jv_JVMTI_ForceGarbageCollection (jvmtiEnv *env)\n+{\n+  REQUIRE_PHASE (env, JVMTI_PHASE_LIVE);\n+  _Jv_RunGC();\n+  return JVMTI_ERROR_NONE;\n+}\n+\n+static jvmtiError JNICALL\n+_Jv_JVMTI_SetJNIFunctionTable (jvmtiEnv *env,\n+\t\t\t       const jniNativeInterface *function_table)\n+{\n+  REQUIRE_PHASE (env, JVMTI_PHASE_START | JVMTI_PHASE_LIVE);\n+  NULL_CHECK (function_table);\n+  memcpy (&_Jv_JNIFunctions, function_table, sizeof (jniNativeInterface));\n+  return JVMTI_ERROR_NONE;\n+}\n+\n+static jvmtiError JNICALL\n+_Jv_JVMTI_GetJNIFunctionTable (jvmtiEnv *env,\n+\t\t\t       jniNativeInterface **function_table)\n+{\n+  REQUIRE_PHASE (env, JVMTI_PHASE_START | JVMTI_PHASE_LIVE);\n+  NULL_CHECK (function_table);\n+  *function_table\n+    = (jniNativeInterface *) _Jv_Malloc (sizeof (jniNativeInterface));\n+  memcpy (*function_table, &_Jv_JNIFunctions, sizeof (jniNativeInterface));\n+  return JVMTI_ERROR_NONE;\n+}\n \n static jvmtiError JNICALL\n _Jv_JVMTI_DisposeEnvironment (jvmtiEnv *env)\n@@ -72,6 +431,148 @@ _Jv_JVMTI_DisposeEnvironment (jvmtiEnv *env)\n   return JVMTI_ERROR_NONE;\n }\n \n+static jvmtiError JNICALL\n+_Jv_JVMTI_GetSystemProperty (jvmtiEnv *env, const char *property,\n+\t\t\t     char **result)\n+{\n+  REQUIRE_PHASE (env, JVMTI_PHASE_ONLOAD | JVMTI_PHASE_LIVE);\n+  NULL_CHECK (property);\n+  NULL_CHECK (result);\n+\n+  jstring name = JvNewStringUTF(property);\n+  jstring result_str = gnu::classpath::SystemProperties::getProperty(name);\n+\n+  if (result_str == NULL)\n+    return JVMTI_ERROR_NOT_AVAILABLE;\n+\n+  int len = JvGetStringUTFLength (result_str);\n+  *result = (char *) _Jv_Malloc (len + 1);\n+  JvGetStringUTFRegion (result_str, 0, result_str->length(), *result);\n+  (*result)[len] = '\\0';\n+\n+  return JVMTI_ERROR_NONE;\n+}\n+\n+static jvmtiError JNICALL\n+_Jv_JVMTI_SetSystemProperty (jvmtiEnv *env, const char *property,\n+\t\t\t     const char *value)\n+{\n+  REQUIRE_PHASE (env, JVMTI_PHASE_ONLOAD);\n+\n+  NULL_CHECK (property);\n+  if (value == NULL)\n+    {\n+      // FIXME: When would a property not be writeable?\n+      return JVMTI_ERROR_NONE;\n+    }\n+\n+  jstring prop_str = JvNewStringUTF(property);\n+  jstring value_str = JvNewStringUTF(value);\n+  gnu::classpath::SystemProperties::setProperty(prop_str, value_str);\n+  return JVMTI_ERROR_NONE;\n+}\n+\n+static jvmtiError JNICALL\n+_Jv_JVMTI_GetTime (MAYBE_UNUSED jvmtiEnv *env, jlong *nanos_ptr)\n+{\n+  NULL_CHECK (nanos_ptr);\n+  *nanos_ptr = _Jv_platform_nanotime();\n+  return JVMTI_ERROR_NONE;\n+}\n+\n+static jvmtiError JNICALL\n+_Jv_JVMTI_GetAvailableProcessors (MAYBE_UNUSED jvmtiEnv *env,\n+\t\t\t\t  jint *nprocessors_ptr)\n+{\n+  NULL_CHECK (nprocessors_ptr);\n+#ifdef _SC_NPROCESSORS_ONLN\n+  *nprocessors_ptr = sysconf(_SC_NPROCESSORS_ONLN);\n+#else\n+  *nprocessors_ptr = 1;\n+#endif\n+  return JVMTI_ERROR_NONE;\n+}\n+\n+static jvmtiError JNICALL\n+_Jv_JVMTI_AddToBootstrapClassLoaderSearch (jvmtiEnv *env, const char *segment)\n+{\n+  using namespace java::lang;\n+  using namespace java::net;\n+  using namespace gnu::gcj::runtime;\n+\n+  REQUIRE_PHASE (env, JVMTI_PHASE_ONLOAD);\n+  NULL_CHECK (segment);\n+\n+  jstring str_segment = JvNewStringUTF(segment);\n+  URL *url;\n+  try\n+    {\n+      url = new URL(JvNewStringUTF(\"file\"), NULL, str_segment);\n+    }\n+  catch (jthrowable ignore)\n+    {\n+      return JVMTI_ERROR_ILLEGAL_ARGUMENT;\n+    }\n+\n+  BootClassLoader *loader = VMClassLoader::bootLoader;\n+  // Don't call this too early.\n+  // assert (loader != NULL);\n+  loader->addURL(url);\n+  return JVMTI_ERROR_NONE;\n+}\n+\n+static jvmtiError JNICALL\n+_Jv_JVMTI_SetVerboseFlag (MAYBE_UNUSED jvmtiEnv *env, jvmtiVerboseFlag flag,\n+\t\t\t  jboolean value)\n+{\n+  switch (flag)\n+    {\n+    case JVMTI_VERBOSE_OTHER:\n+    case JVMTI_VERBOSE_GC:\n+    case JVMTI_VERBOSE_JNI:\n+      // Ignore.\n+      break;\n+    case JVMTI_VERBOSE_CLASS:\n+      gcj::verbose_class_flag = value;\n+      break;\n+    default:\n+      return JVMTI_ERROR_ILLEGAL_ARGUMENT;\n+    }\n+  return JVMTI_ERROR_NONE;\n+}\n+\n+static jvmtiError JNICALL\n+_Jv_JVMTI_GetObjectSize (jvmtiEnv *env, jobject object, jlong *result)\n+{\n+  REQUIRE_PHASE (env, JVMTI_PHASE_START | JVMTI_PHASE_LIVE);\n+  if (object == NULL)\n+    return JVMTI_ERROR_INVALID_OBJECT;\n+  NULL_CHECK (result);\n+\n+  jclass klass = object->getClass();\n+  if (klass->isArray())\n+    {\n+      jclass comp = klass->getComponentType();\n+      jint base\n+\t= (jint) _Jv_GetArrayElementFromElementType(NULL,\n+\t\t\t\t\t\t    klass->getComponentType());\n+      // FIXME: correct for primitive types?\n+      jint compSize = comp->size();\n+      __JArray *array = (__JArray *) object;\n+      *result = base + array->length * compSize;\n+    }\n+  else\n+    {\n+      // Note that if OBJECT is a String then it may (if\n+      // str->data==str) take more space.  Do we care?\n+      *result = klass->size();\n+    }\n+  return JVMTI_ERROR_NONE;\n+}\n+\n+#define RESERVED NULL\n+#define UNIMPLEMENTED NULL\n+\n struct _Jv_jvmtiEnv _Jv_JVMTI_Interface =\n {\n   RESERVED,\t\t\t// reserved1\n@@ -81,7 +582,7 @@ struct _Jv_jvmtiEnv _Jv_JVMTI_Interface =\n   _Jv_JVMTI_SuspendThread,\t// SuspendThread\n   _Jv_JVMTI_ResumeThread,\t// ResumeThread\n   UNIMPLEMENTED,\t\t// StopThread\n-  UNIMPLEMENTED,\t\t// InterruptThread\n+  _Jv_JVMTI_InterruptThread,\t// InterruptThread\n   UNIMPLEMENTED,\t\t// GetThreadInfo\n   UNIMPLEMENTED,\t\t// GetOwnedMonitorInfo\n   UNIMPLEMENTED,\t\t// GetCurrentContendedMonitor\n@@ -104,42 +605,42 @@ struct _Jv_jvmtiEnv _Jv_JVMTI_Interface =\n   UNIMPLEMENTED,\t\t// SetLocalLong\n   UNIMPLEMENTED,\t\t// SetLocalFloat\n   UNIMPLEMENTED,\t\t// SetLocalDouble\n-  UNIMPLEMENTED,\t\t// CreateRawMonitor\n-  UNIMPLEMENTED,\t\t// DestroyRawMonitor\n-  UNIMPLEMENTED,\t\t// RawMonitorEnter\n-  UNIMPLEMENTED,\t\t// RawMonitorExit\n-  UNIMPLEMENTED,\t\t// RawMonitorWait\n-  UNIMPLEMENTED,\t\t// RawMonitorNotify\n-  UNIMPLEMENTED,\t\t// RawMonitorNotifyAll\n+  _Jv_JVMTI_CreateRawMonitor,\t// CreateRawMonitor\n+  _Jv_JVMTI_DestroyRawMonitor,\t// DestroyRawMonitor\n+  _Jv_JVMTI_RawMonitorEnter,\t// RawMonitorEnter\n+  _Jv_JVMTI_RawMonitorExit,\t// RawMonitorExit\n+  _Jv_JVMTI_RawMonitorWait,\t// RawMonitorWait\n+  _Jv_JVMTI_RawMonitorNotify,\t// RawMonitorNotify\n+  _Jv_JVMTI_RawMonitorNotifyAll, // RawMonitorNotifyAll\n   UNIMPLEMENTED,\t\t// SetBreakpoint\n-  UNIMPLEMENTED,\t\t// CleareBreakpoint\n+  UNIMPLEMENTED,\t\t// ClearBreakpoint\n   RESERVED,\t\t\t// reserved40\n   UNIMPLEMENTED,\t\t// SetFieldAccessWatch\n   UNIMPLEMENTED,\t\t// ClearFieldAccessWatch\n   UNIMPLEMENTED,\t\t// SetFieldModificationWatch\n   UNIMPLEMENTED,\t\t// ClearFieldModificationWatch\n   RESERVED,\t\t\t// reserved45\n-  UNIMPLEMENTED,\t\t// Allocate\n-  UNIMPLEMENTED,\t\t// Deallocate\n+  _Jv_JVMTI_Allocate,\t\t// Allocate\n+  _Jv_JVMTI_Deallocate,\t\t// Deallocate\n   UNIMPLEMENTED,\t\t// GetClassSignature\n   UNIMPLEMENTED,\t\t// GetClassStatus\n   UNIMPLEMENTED,\t\t// GetSourceFileName\n-  UNIMPLEMENTED,\t\t// GetClassModifiers\n-  UNIMPLEMENTED,\t\t// GetClassMethods\n+  _Jv_JVMTI_GetClassModifiers,\t// GetClassModifiers\n+  _Jv_JVMTI_GetClassMethods,\t// GetClassMethods\n   UNIMPLEMENTED,\t\t// GetClassFields\n   UNIMPLEMENTED,\t\t// GetImplementedInterfaces\n-  UNIMPLEMENTED,\t\t// IsInterface\n-  UNIMPLEMENTED,\t\t// IsArrayClass\n-  UNIMPLEMENTED,\t\t// GetClassLoader\n-  UNIMPLEMENTED,\t\t// GetObjectHashCode\n+  _Jv_JVMTI_IsInterface,\t// IsInterface\n+  _Jv_JVMTI_IsArrayClass,\t// IsArrayClass\n+  _Jv_JVMTI_GetClassLoader,\t// GetClassLoader\n+  _Jv_JVMTI_GetObjectHashCode,\t// GetObjectHashCode\n   UNIMPLEMENTED,\t\t// GetObjectMonitorUsage\n   UNIMPLEMENTED,\t\t// GetFieldName\n   UNIMPLEMENTED,\t\t// GetFieldDeclaringClass\n-  UNIMPLEMENTED,\t\t// GetFieldModifiers\n-  UNIMPLEMENTED,\t\t// IsFieldSynthetic\n+  _Jv_JVMTI_GetFieldModifiers,\t// GetFieldModifiers\n+  _Jv_JVMTI_IsFieldSynthetic,\t// IsFieldSynthetic\n   UNIMPLEMENTED,\t\t// GetMethodName\n   UNIMPLEMENTED,\t\t// GetMethodDeclaringClass\n-  UNIMPLEMENTED,\t\t// GetMethodModiifers\n+  _Jv_JVMTI_GetMethodModifiers,\t// GetMethodModifers\n   RESERVED,\t\t\t// reserved67\n   UNIMPLEMENTED,\t\t// GetMaxLocals\n   UNIMPLEMENTED,\t\t// GetArgumentsSize\n@@ -149,10 +650,10 @@ struct _Jv_jvmtiEnv _Jv_JVMTI_Interface =\n   RESERVED,\t\t\t// reserved73\n   RESERVED,\t\t\t// reserved74\n   UNIMPLEMENTED,\t\t// GetBytecodes\n-  UNIMPLEMENTED,\t\t// IsMethodNative\n-  UNIMPLEMENTED,\t\t// IsMethodSynthetic\n+  _Jv_JVMTI_IsMethodNative,\t// IsMethodNative\n+  _Jv_JVMTI_IsMethodSynthetic,\t// IsMethodSynthetic\n   UNIMPLEMENTED,\t\t// GetLoadedClasses\n-  UNIMPLEMENTED,\t\t// GetClassLoaderClasses\n+  _Jv_JVMTI_GetClassLoaderClasses, // GetClassLoaderClasses\n   UNIMPLEMENTED,\t\t// PopFrame\n   RESERVED,\t\t\t// reserved81\n   RESERVED,\t\t\t// reserved82\n@@ -181,7 +682,7 @@ struct _Jv_jvmtiEnv _Jv_JVMTI_Interface =\n   RESERVED,\t\t\t// reserved105\n   UNIMPLEMENTED,\t\t// GetTag\n   UNIMPLEMENTED,\t\t// SetTag\n-  UNIMPLEMENTED,\t\t// ForceGarbageCollection\n+  _Jv_JVMTI_ForceGarbageCollection, // ForceGarbageCollection\n   UNIMPLEMENTED,\t\t// IterateOverObjectsReachable\n   UNIMPLEMENTED,\t\t// IterateOverReachableObjects\n   UNIMPLEMENTED,\t\t// IterateOverHeap\n@@ -193,8 +694,8 @@ struct _Jv_jvmtiEnv _Jv_JVMTI_Interface =\n   RESERVED,\t\t\t// reserved117\n   RESERVED,\t\t\t// reserved118\n   RESERVED,\t\t\t// reserved119\n-  UNIMPLEMENTED,\t\t// SetJNIFunctionTable\n-  UNIMPLEMENTED,\t\t// GetJNIFunctionTable\n+  _Jv_JVMTI_SetJNIFunctionTable, // SetJNIFunctionTable\n+  _Jv_JVMTI_GetJNIFunctionTable, // GetJNIFunctionTable\n   UNIMPLEMENTED,\t\t// SetEventCallbacks\n   UNIMPLEMENTED,\t\t// GenerateEvents\n   UNIMPLEMENTED,\t\t// GetExtensionFunctions\n@@ -204,30 +705,30 @@ struct _Jv_jvmtiEnv _Jv_JVMTI_Interface =\n   UNIMPLEMENTED,\t\t// GetErrorName\n   UNIMPLEMENTED,\t\t// GetJLocationFormat\n   UNIMPLEMENTED,\t\t// GetSystemProperties\n-  UNIMPLEMENTED,\t\t// GetSystemProperty\n-  UNIMPLEMENTED,\t\t// SetSystemProperty\n+  _Jv_JVMTI_GetSystemProperty,\t// GetSystemProperty\n+  _Jv_JVMTI_SetSystemProperty,\t// SetSystemProperty\n   UNIMPLEMENTED,\t\t// GetPhase\n   UNIMPLEMENTED,\t\t// GetCurrentThreadCpuTimerInfo\n   UNIMPLEMENTED,\t\t// GetCurrentThreadCpuTime\n   UNIMPLEMENTED,\t\t// GetThreadCpuTimerInfo\n   UNIMPLEMENTED,\t\t// GetThreadCpuTime\n   UNIMPLEMENTED,\t\t// GetTimerInfo\n-  UNIMPLEMENTED,\t\t// GetTime\n+  _Jv_JVMTI_GetTime,\t\t// GetTime\n   UNIMPLEMENTED,\t\t// GetPotentialCapabilities\n   RESERVED,\t\t\t// reserved141\n   UNIMPLEMENTED,\t\t// AddCapabilities\n   UNIMPLEMENTED,\t\t// RelinquishCapabilities\n-  UNIMPLEMENTED,\t\t// GetAvailableProcessors\n+  _Jv_JVMTI_GetAvailableProcessors, // GetAvailableProcessors\n   RESERVED,\t\t\t// reserved145\n   RESERVED,\t\t\t// reserved146\n   UNIMPLEMENTED,\t\t// GetEnvironmentLocalStorage\n   UNIMPLEMENTED,\t\t// SetEnvironmentLocalStorage\n-  UNIMPLEMENTED,\t\t// AddToBootstrapClassLoaderSearch\n-  UNIMPLEMENTED,\t\t// SetVerboseFlag\n+  _Jv_JVMTI_AddToBootstrapClassLoaderSearch, // AddToBootstrapClassLoaderSearch\n+  _Jv_JVMTI_SetVerboseFlag,\t// SetVerboseFlag\n   RESERVED,\t\t\t// reserved151\n   RESERVED,\t\t\t// reserved152\n   RESERVED,\t\t\t// reserved153\n-  UNIMPLEMENTED\t\t\t// GetObjectSize\n+  _Jv_JVMTI_GetObjectSize\t// GetObjectSize\n };\n \n _Jv_JVMTIEnv *"}]}