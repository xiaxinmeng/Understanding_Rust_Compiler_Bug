{"sha": "01f5295df1c1cf5eaddfd787519dae6587cffbeb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDFmNTI5NWRmMWMxY2Y1ZWFkZGZkNzg3NTE5ZGFlNjU4N2NmZmJlYg==", "commit": {"author": {"name": "Yury Gribov", "email": "tetra2005@gmail.com", "date": "2017-08-02T21:01:08Z"}, "committer": {"name": "Yury Gribov", "email": "ygribov@gcc.gnu.org", "date": "2017-08-02T21:01:08Z"}, "message": "Added Python implementation of mklog.\n\nFrom-SVN: r250836", "tree": {"sha": "056b330f67ca787eb8b895a55f53237bdb88197f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/056b330f67ca787eb8b895a55f53237bdb88197f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/01f5295df1c1cf5eaddfd787519dae6587cffbeb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01f5295df1c1cf5eaddfd787519dae6587cffbeb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01f5295df1c1cf5eaddfd787519dae6587cffbeb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01f5295df1c1cf5eaddfd787519dae6587cffbeb/comments", "author": {"login": "yugr", "id": 1101391, "node_id": "MDQ6VXNlcjExMDEzOTE=", "avatar_url": "https://avatars.githubusercontent.com/u/1101391?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yugr", "html_url": "https://github.com/yugr", "followers_url": "https://api.github.com/users/yugr/followers", "following_url": "https://api.github.com/users/yugr/following{/other_user}", "gists_url": "https://api.github.com/users/yugr/gists{/gist_id}", "starred_url": "https://api.github.com/users/yugr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yugr/subscriptions", "organizations_url": "https://api.github.com/users/yugr/orgs", "repos_url": "https://api.github.com/users/yugr/repos", "events_url": "https://api.github.com/users/yugr/events{/privacy}", "received_events_url": "https://api.github.com/users/yugr/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e1df0c913438d2247f0d627d83e3b33ba183e13c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1df0c913438d2247f0d627d83e3b33ba183e13c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1df0c913438d2247f0d627d83e3b33ba183e13c"}], "stats": {"total": 474, "additions": 474, "deletions": 0}, "files": [{"sha": "5fa6e032be463f71543d064f9c6b2f358db65248", "filename": "contrib/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01f5295df1c1cf5eaddfd787519dae6587cffbeb/contrib%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01f5295df1c1cf5eaddfd787519dae6587cffbeb/contrib%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2FChangeLog?ref=01f5295df1c1cf5eaddfd787519dae6587cffbeb", "patch": "@@ -1,3 +1,7 @@\n+2017-08-02  Yury Gribov  <tetra2005@gmail.com>\n+\n+\t* mklog: Added new implementation.\n+\n 2017-08-02  Yury Gribov  <tetra2005@gmail.com>\n \n \t* mklog: Rename to ..."}, {"sha": "0622d2e2e3db9019687941d22a7d3648ec197d23", "filename": "contrib/mklog", "status": "added", "additions": 470, "deletions": 0, "changes": 470, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01f5295df1c1cf5eaddfd787519dae6587cffbeb/contrib%2Fmklog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01f5295df1c1cf5eaddfd787519dae6587cffbeb/contrib%2Fmklog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fmklog?ref=01f5295df1c1cf5eaddfd787519dae6587cffbeb", "patch": "@@ -0,0 +1,470 @@\n+#!/usr/bin/python\n+\n+# Copyright (C) 2017 Free Software Foundation, Inc.\n+#\n+# This file is part of GCC.\n+#\n+# GCC is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3, or (at your option)\n+# any later version.\n+#\n+# GCC is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING.  If not, write to\n+# the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+# Boston, MA 02110-1301, USA.\n+\n+# This script parses a .diff file generated with 'diff -up' or 'diff -cp'\n+# and adds a skeleton ChangeLog file to the file. It does not try to be\n+# too smart when parsing function names, but it produces a reasonable\n+# approximation.\n+#\n+# This is a straightforward adaptation of original Perl script.\n+#\n+# Author: Yury Gribov <tetra2005@gmail.com>\n+\n+import sys\n+import re\n+import os.path\n+import os\n+import getopt\n+import tempfile\n+import time\n+import shutil\n+from subprocess import Popen, PIPE\n+\n+me = os.path.basename(sys.argv[0])\n+\n+def error(msg):\n+  sys.stderr.write(\"%s: error: %s\\n\" % (me, msg))\n+  sys.exit(1)\n+\n+def warn(msg):\n+  sys.stderr.write(\"%s: warning: %s\\n\" % (me, msg))\n+\n+class RegexCache(object):\n+  \"\"\"Simple trick to Perl-like combined match-and-bind.\"\"\"\n+\n+  def __init__(self):\n+    self.last_match = None\n+\n+  def match(self, p, s):\n+    self.last_match = re.match(p, s) if isinstance(p, str) else p.match(s)\n+    return self.last_match\n+\n+  def search(self, p, s):\n+    self.last_match = re.search(p, s) if isinstance(p, str) else p.search(s)\n+    return self.last_match\n+\n+  def group(self, n):\n+    return self.last_match.group(n)\n+\n+cache = RegexCache()\n+\n+def print_help_and_exit():\n+    print \"\"\"\\\n+Usage: %s [-i | --inline] [PATCH]\n+Generate ChangeLog template for PATCH.\n+PATCH must be generated using diff(1)'s -up or -cp options\n+(or their equivalent in Subversion/git).\n+\n+When PATCH is - or missing, read standard input.\n+\n+When -i is used, prepends ChangeLog to PATCH.\n+If PATCH is not stdin, modifies PATCH in-place, otherwise writes\n+to stdout.\n+\"\"\" % me\n+    sys.exit(1)\n+\n+def run(cmd, die_on_error):\n+  \"\"\"Simple wrapper for Popen.\"\"\"\n+  proc = Popen(cmd.split(' '), stderr = PIPE, stdout = PIPE)\n+  (out, err) = proc.communicate()\n+  if die_on_error and proc.returncode != 0:\n+    error(\"`%s` failed:\\n\" % (cmd, proc.stderr))\n+  return proc.returncode, out, err\n+\n+def read_user_info():\n+  dot_mklog_format_msg = \"\"\"\\\n+The .mklog format is:\n+NAME = ...\n+EMAIL = ...\n+\"\"\"\n+\n+  # First try to read .mklog config\n+  mklog_conf = os.path.expanduser('~/.mklog')\n+  if os.path.exists(mklog_conf):\n+    attrs = {}\n+    f = open(mklog_conf, 'rb')\n+    for s in f:\n+      if cache.match(r'^\\s*([a-zA-Z0-9_]+)\\s*=\\s*(.*?)\\s*$', s):\n+        attrs[cache.group(1)] = cache.group(2)\n+    f.close()\n+    if 'NAME' not in attrs:\n+      error(\"'NAME' not present in .mklog\")\n+    if 'EMAIL' not in attrs:\n+      error(\"'EMAIL' not present in .mklog\")\n+    return attrs['NAME'], attrs['EMAIL']\n+\n+  # Otherwise go with git\n+\n+  rc1, name, _ = run('git config user.name', False)\n+  name = name.rstrip()\n+  rc2, email, _ = run('git config user.email', False)\n+  email = email.rstrip()\n+\n+  if rc1 != 0 or rc2 != 0:\n+    error(\"\"\"\\\n+Could not read git user.name and user.email settings.\n+Please add missing git settings, or create a %s.\n+\"\"\" % mklog_conf)\n+\n+  return name, email\n+\n+def get_parent_changelog (s):\n+  \"\"\"See which ChangeLog this file change should go to.\"\"\"\n+\n+  if s.find('\\\\') == -1 and s.find('/') == -1:\n+    return \"ChangeLog\", s\n+\n+  gcc_root = os.path.dirname(os.path.dirname(os.path.realpath(__file__)))\n+\n+  d = s\n+  while d:\n+    clname = d + \"/ChangeLog\"\n+    if os.path.exists(gcc_root + '/' + clname) or os.path.exists(clname):\n+      relname = s[len(d)+1:]\n+      return clname, relname\n+    d, _ = os.path.split(d)\n+\n+  return \"Unknown ChangeLog\", s\n+\n+class FileDiff:\n+  \"\"\"Class to represent changes in a single file.\"\"\"\n+\n+  def __init__(self, filename):\n+    self.filename = filename\n+    self.hunks = []\n+    self.clname, self.relname = get_parent_changelog(filename);\n+\n+  def dump(self):\n+    print \"Diff for %s:\\n  ChangeLog = %s\\n  rel name = %s\\n\" % (self.filename, self.clname, self.relname)\n+    for i, h in enumerate(self.hunks):\n+      print \"Next hunk %d:\" % i\n+      h.dump()\n+\n+class Hunk:\n+  \"\"\"Class to represent a single hunk of changes.\"\"\"\n+\n+  def __init__(self, hdr):\n+    self.hdr = hdr\n+    self.lines = []\n+    self.ctx_diff = is_ctx_hunk_start(hdr)\n+\n+  def dump(self):\n+    print '%s' % self.hdr\n+    print '%s' % '\\n'.join(self.lines)\n+\n+  def is_file_addition(self):\n+    \"\"\"Does hunk describe addition of file?\"\"\"\n+    if self.ctx_diff:\n+      for line in self.lines:\n+        if re.match(r'^\\*\\*\\* 0 \\*\\*\\*\\*', line):\n+          return True\n+    else:\n+      return re.match(r'^@@ -0,0 \\+1.* @@', self.hdr)\n+\n+  def is_file_removal(self):\n+    \"\"\"Does hunk describe removal of file?\"\"\"\n+    if self.ctx_diff:\n+      for line in self.lines:\n+        if re.match(r'^--- 0 ----', line):\n+          return True\n+    else:\n+      return re.match(r'^@@ -1.* \\+0,0 @@', self.hdr)\n+\n+def is_file_diff_start(s):\n+  # Don't be fooled by context diff line markers:\n+  #   *** 385,391 ****\n+  return ((s.startswith('***') and not s.endswith('***'))\n+          or (s.startswith('---') and not s.endswith('---')))\n+\n+def is_ctx_hunk_start(s):\n+  return re.match(r'^\\*\\*\\*\\*\\*\\**', s)\n+\n+def is_uni_hunk_start(s):\n+  return re.match(r'^@@ .* @@', s)\n+\n+def is_hunk_start(s):\n+  return is_ctx_hunk_start(s) or is_uni_hunk_start(s)\n+\n+def remove_suffixes(s):\n+  if s.startswith('a/') or s.startswith('b/'):\n+    s = s[2:]\n+  if s.endswith('.jj'):\n+    s = s[:-3]\n+  return s\n+\n+def find_changed_funs(hunk):\n+  \"\"\"Find all functions touched by hunk.  We don't try too hard\n+     to find good matches.  This should return a superset\n+     of the actual set of functions in the .diff file.\n+  \"\"\"\n+\n+  fns = []\n+  fn = None\n+\n+  if (cache.match(r'^\\*\\*\\*\\*\\*\\** ([a-zA-Z0-9_].*)', hunk.hdr)\n+      or cache.match(r'^@@ .* @@ ([a-zA-Z0-9_].*)', hunk.hdr)):\n+    fn = cache.group(1)\n+\n+  for i, line in enumerate(hunk.lines):\n+    # Context diffs have extra whitespace after first char;\n+    # remove it to make matching easier.\n+    if hunk.ctx_diff:\n+      line = re.sub(r'^([-+! ]) ', r'\\1', line)\n+\n+    # Remember most recent identifier in hunk\n+    # that might be a function name.\n+    if cache.match(r'^[-+! ]([a-zA-Z0-9_#].*)', line):\n+      fn = cache.group(1)\n+\n+    change = line and re.match(r'^[-+!][^-]', line)\n+\n+    # Top-level comment can not belong to function\n+    if re.match(r'^[-+! ]\\/\\*', line):\n+      fn = None\n+\n+    if change and fn:\n+      if cache.match(r'^((class|struct|union|enum)\\s+[a-zA-Z0-9_]+)', fn):\n+        # Struct declaration\n+        fn = cache.group(1)\n+      elif cache.search(r'#\\s*define\\s+([a-zA-Z0-9_]+)', fn):\n+        # Macro definition\n+        fn = cache.group(1)\n+      elif cache.match('^DEF[A-Z0-9_]+\\s*\\(([a-zA-Z0-9_]+)', fn):\n+        # Supermacro\n+        fn = cache.group(1)\n+      elif cache.search(r'([a-zA-Z_][^()\\s]*)\\s*\\([^*]', fn):\n+        # Discard template and function parameters.\n+        fn = cache.group(1)\n+        fn = re.sub(r'<[^<>]*>', '', fn)\n+        fn = fn.rstrip()\n+      else:\n+        fn = None\n+\n+      if fn and fn not in fns:  # Avoid dups\n+        fns.append(fn)\n+\n+      fn = None\n+\n+  return fns\n+\n+def parse_patch(contents):\n+  \"\"\"Parse patch contents to a sequence of FileDiffs.\"\"\"\n+\n+  diffs = []\n+\n+  lines = contents.split('\\n')\n+\n+  i = 0\n+  while i < len(lines):\n+    line = lines[i]\n+\n+    # Diff headers look like\n+    #   --- a/gcc/tree.c\n+    #   +++ b/gcc/tree.c\n+    # or\n+    #   *** gcc/cfgexpand.c     2013-12-25 20:07:24.800350058 +0400\n+    #   --- gcc/cfgexpand.c     2013-12-25 20:06:30.612350178 +0400\n+\n+    if is_file_diff_start(line):\n+      left = re.split(r'\\s+', line)[1]\n+    else:\n+      i += 1\n+      continue\n+\n+    left = remove_suffixes(left);\n+\n+    i += 1\n+    line = lines[i]\n+\n+    if not cache.match(r'^[+-][+-][+-] +(\\S+)', line):\n+      error(\"expected filename in line %d\" % i)\n+    right = remove_suffixes(cache.group(1));\n+\n+    # Extract real file name from left and right names.\n+    filename = None\n+    if left == right:\n+      filename = left\n+    elif left == '/dev/null':\n+      filename = right;\n+    elif right == '/dev/null':\n+      filename = left;\n+    else:\n+      comps = []\n+      while left and right:\n+        left, l = os.path.split(left)\n+        right, r = os.path.split(right)\n+        if l != r:\n+          break\n+        comps.append(l)\n+    \n+      if not comps:\n+        error(\"failed to extract common name for %s and %s\" % (left, right))\n+\n+      comps.reverse()\n+      filename = '/'.join(comps)\n+\n+    d = FileDiff(filename)\n+    diffs.append(d)\n+\n+    # Collect hunks for current file.\n+    hunk = None\n+    i += 1\n+    while i < len(lines):\n+      line = lines[i]\n+\n+      # Create new hunk when we see hunk header\n+      if is_hunk_start(line):\n+        if hunk is not None:\n+          d.hunks.append(hunk)\n+        hunk = Hunk(line)\n+        i += 1\n+        continue\n+\n+      # Stop when we reach next diff\n+      if (is_file_diff_start(line)\n+          or line.startswith('diff ')\n+          or line.startswith('Index: ')):\n+        i -= 1\n+        break\n+\n+      if hunk is not None:\n+        hunk.lines.append(line)\n+      i += 1\n+\n+    d.hunks.append(hunk)\n+\n+  return diffs\n+\n+def main():\n+  name, email = read_user_info()\n+\n+  try:\n+    opts, args = getopt.getopt(sys.argv[1:], 'hiv', ['help', 'verbose', 'inline'])\n+  except getopt.GetoptError, err:\n+    error(str(err))\n+\n+  inline = False\n+  verbose = 0\n+\n+  for o, a in opts:\n+    if o in ('-h', '--help'):\n+      print_help_and_exit()\n+    elif o in ('-i', '--inline'):\n+      inline = True\n+    elif o in ('-v', '--verbose'):\n+      verbose += 1\n+    else:\n+      assert False, \"unhandled option\"\n+\n+  if len(args) == 0:\n+    args = ['-']\n+\n+  if len(args) == 1 and args[0] == '-':\n+    input = sys.stdin\n+  elif len(args) == 1:\n+    input = open(args[0], 'rb')\n+  else:\n+    error(\"too many arguments; for more details run with -h\")\n+\n+  contents = input.read()\n+  diffs = parse_patch(contents)\n+\n+  if verbose:\n+    print \"Parse results:\"\n+    for d in diffs:\n+      d.dump()\n+\n+  # Generate template ChangeLog.\n+\n+  logs = {}\n+  for d in diffs:\n+    log_name = d.clname\n+\n+    logs.setdefault(log_name, '')\n+    logs[log_name] += '\\t* %s' % d.relname\n+\n+    change_msg = ''\n+\n+    # Check if file was removed or added.\n+    # Two patterns for context and unified diff.\n+    if len(d.hunks) == 1:\n+      hunk0 = d.hunks[0]\n+      if hunk0.is_file_addition():\n+        if re.search(r'testsuite.*(?<!\\.exp)$', d.filename):\n+          change_msg = ': New test.\\n'\n+        else:\n+          change_msg = \": New file.\\n\"\n+      elif hunk0.is_file_removal():\n+        change_msg = \": Remove.\\n\"\n+\n+    _, ext = os.path.splitext(d.filename)\n+    if not change_msg and ext in ['.c', '.cpp', '.C', '.cc', '.h', '.inc', '.def']:\n+      fns = []\n+      for hunk in d.hunks:\n+        for fn in find_changed_funs(hunk):\n+          if fn not in fns:\n+            fns.append(fn)\n+\n+      for fn in fns:\n+        if change_msg:\n+          change_msg += \"\\t(%s):\\n\" % fn\n+        else:\n+          change_msg = \" (%s):\\n\" % fn\n+\n+    logs[log_name] += change_msg if change_msg else \":\\n\"\n+\n+  if inline and args[0] != '-':\n+    # Get a temp filename, rather than an open filehandle, because we use\n+    # the open to truncate.\n+    fd, tmp = tempfile.mkstemp(\"tmp.XXXXXXXX\")\n+    os.close(fd)\n+\n+    # Copy permissions to temp file\n+    # (old Pythons do not support shutil.copymode)\n+    shutil.copymode(args[0], tmp)\n+\n+    # Open the temp file, clearing contents.\n+    out = open(tmp, 'wb')\n+  else:\n+    tmp = None\n+    out = sys.stdout\n+\n+  # Print log\n+  date = time.strftime('%Y-%m-%d')\n+  for log_name, msg in sorted(logs.iteritems()):\n+    out.write(\"\"\"\\\n+%s:\n+\n+%s  %s  <%s>\n+\n+%s\\n\"\"\" % (log_name, date, name, email, msg))\n+\n+  if inline:\n+    # Append patch body\n+    out.write(contents)\n+\n+    if args[0] != '-':\n+      # Write new contents atomically\n+      out.close()\n+      shutil.move(tmp, args[0])\n+\n+if __name__ == '__main__':\n+    main()"}]}