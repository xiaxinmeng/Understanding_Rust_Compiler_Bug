{"sha": "2ed941ecd0ad232cf5813d0342bb3fd69407622c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmVkOTQxZWNkMGFkMjMyY2Y1ODEzZDAzNDJiYjNmZDY5NDA3NjIyYw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2007-03-23T16:34:51Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2007-03-23T16:34:51Z"}, "message": "i386.c: Remove unnecessary function declarations.\n\n        * config/i386/i386.c: Remove unnecessary function declarations.\n        Move targetm definition, and all related macros, to the end of\n        the file.  Resort some functions to put definitions before uses.\n        (ix86_attribute_table): Make static.  Move to end of file.\n        (ix86_gimplify_va_arg): Make static.\n\nFrom-SVN: r123159", "tree": {"sha": "bc7851cd126a07c5e47eade8c99566606e01f531", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bc7851cd126a07c5e47eade8c99566606e01f531"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2ed941ecd0ad232cf5813d0342bb3fd69407622c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ed941ecd0ad232cf5813d0342bb3fd69407622c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ed941ecd0ad232cf5813d0342bb3fd69407622c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ed941ecd0ad232cf5813d0342bb3fd69407622c/comments", "author": null, "committer": null, "parents": [{"sha": "dec93f9008e6329e8f64083c96c7ee77f60c1927", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dec93f9008e6329e8f64083c96c7ee77f60c1927", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dec93f9008e6329e8f64083c96c7ee77f60c1927"}], "stats": {"total": 1138, "additions": 529, "deletions": 609}, "files": [{"sha": "5ad2226c1b92d2499eb5dadd678b1b7a2d648e34", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ed941ecd0ad232cf5813d0342bb3fd69407622c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ed941ecd0ad232cf5813d0342bb3fd69407622c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2ed941ecd0ad232cf5813d0342bb3fd69407622c", "patch": "@@ -1,3 +1,11 @@\n+2007-03-22  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/i386/i386.c: Remove unnecessary function declarations.\n+\tMove targetm definition, and all related macros, to the end of\n+\tthe file.  Resort some functions to put definitions before uses.\n+\t(ix86_attribute_table): Make static.  Move to end of file.\n+\t(ix86_gimplify_va_arg): Make static.\n+\n 2007-03-22  Richard Henderson  <rth@redhat.com>\n \n \t* config/i386/i386.c (ix86_function_regparm): Early exit for 64-bit;"}, {"sha": "c5a82a8b76cd58f780c0a84067d2c44f448df8f4", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 521, "deletions": 609, "changes": 1130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ed941ecd0ad232cf5813d0342bb3fd69407622c/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ed941ecd0ad232cf5813d0342bb3fd69407622c/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=2ed941ecd0ad232cf5813d0342bb3fd69407622c", "patch": "@@ -1486,117 +1486,14 @@ int ix86_section_threshold = 65536;\n /* Prefix built by ASM_GENERATE_INTERNAL_LABEL.  */\n char internal_label_prefix[16];\n int internal_label_prefix_len;\n-\f\n-static bool ix86_handle_option (size_t, const char *, int);\n-static void output_pic_addr_const (FILE *, rtx, int);\n-static void put_condition_code (enum rtx_code, enum machine_mode,\n-\t\t\t\tint, int, FILE *);\n-static const char *get_some_local_dynamic_name (void);\n-static int get_some_local_dynamic_name_1 (rtx *, void *);\n-static rtx ix86_expand_int_compare (enum rtx_code, rtx, rtx);\n-static enum rtx_code ix86_prepare_fp_compare_args (enum rtx_code, rtx *,\n-\t\t\t\t\t\t   rtx *);\n-static bool ix86_fixed_condition_code_regs (unsigned int *, unsigned int *);\n-static enum machine_mode ix86_cc_modes_compatible (enum machine_mode,\n-\t\t\t\t\t\t   enum machine_mode);\n-static rtx get_thread_pointer (int);\n-static rtx legitimize_tls_address (rtx, enum tls_model, int);\n-static void get_pc_thunk_name (char [32], unsigned int);\n-static rtx gen_push (rtx);\n-static int ix86_flags_dependent (rtx, rtx, enum attr_type);\n-static int ix86_agi_dependent (rtx, rtx, enum attr_type);\n-static struct machine_function * ix86_init_machine_status (void);\n-static int ix86_split_to_parts (rtx, rtx *, enum machine_mode);\n-static int ix86_nsaved_regs (void);\n-static void ix86_emit_save_regs (void);\n-static void ix86_emit_save_regs_using_mov (rtx, HOST_WIDE_INT);\n-static void ix86_emit_restore_regs_using_mov (rtx, HOST_WIDE_INT, int);\n-static void ix86_output_function_epilogue (FILE *, HOST_WIDE_INT);\n-static HOST_WIDE_INT ix86_GOT_alias_set (void);\n-static void ix86_adjust_counter (rtx, HOST_WIDE_INT);\n-static void ix86_expand_strlensi_unroll_1 (rtx, rtx, rtx);\n-static int ix86_issue_rate (void);\n-static int ix86_adjust_cost (rtx, rtx, rtx, int);\n-static int ia32_multipass_dfa_lookahead (void);\n-static void ix86_init_mmx_sse_builtins (void);\n-static rtx x86_this_parameter (tree);\n-static void x86_output_mi_thunk (FILE *, tree, HOST_WIDE_INT,\n-\t\t\t\t HOST_WIDE_INT, tree);\n-static bool x86_can_output_mi_thunk (tree, HOST_WIDE_INT, HOST_WIDE_INT, tree);\n-static void x86_file_start (void);\n-static void ix86_reorg (void);\n-static bool ix86_expand_carry_flag_compare (enum rtx_code, rtx, rtx, rtx*);\n-static tree ix86_build_builtin_va_list (void);\n-static void ix86_setup_incoming_varargs (CUMULATIVE_ARGS *, enum machine_mode,\n-\t\t\t\t\t tree, int *, int);\n-static tree ix86_gimplify_va_arg (tree, tree, tree *, tree *);\n-static bool ix86_scalar_mode_supported_p (enum machine_mode);\n-static bool ix86_vector_mode_supported_p (enum machine_mode);\n-\n-static int ix86_address_cost (rtx);\n-static bool ix86_cannot_force_const_mem (rtx);\n-static rtx ix86_delegitimize_address (rtx);\n-\n-static void i386_output_dwarf_dtprel (FILE *, int, rtx) ATTRIBUTE_UNUSED;\n-\n-struct builtin_description;\n-static rtx ix86_expand_sse_comi (const struct builtin_description *,\n-\t\t\t\t tree, rtx);\n-static rtx ix86_expand_sse_compare (const struct builtin_description *,\n-\t\t\t\t    tree, rtx);\n-static rtx ix86_expand_unop1_builtin (enum insn_code, tree, rtx);\n-static rtx ix86_expand_unop_builtin (enum insn_code, tree, rtx, int);\n-static rtx ix86_expand_binop_builtin (enum insn_code, tree, rtx);\n-static rtx ix86_expand_store_builtin (enum insn_code, tree);\n-static rtx safe_vector_operand (rtx, enum machine_mode);\n-static rtx ix86_expand_fp_compare (enum rtx_code, rtx, rtx, rtx, rtx *, rtx *);\n-static int ix86_fp_comparison_arithmetics_cost (enum rtx_code code);\n-static int ix86_fp_comparison_fcomi_cost (enum rtx_code code);\n-static int ix86_fp_comparison_sahf_cost (enum rtx_code code);\n-static int ix86_fp_comparison_cost (enum rtx_code code);\n-static unsigned int ix86_select_alt_pic_regnum (void);\n-static int ix86_save_reg (unsigned int, int);\n-static void ix86_compute_frame_layout (struct ix86_frame *);\n-static int ix86_comp_type_attributes (tree, tree);\n-static int ix86_function_regparm (tree, tree);\n-const struct attribute_spec ix86_attribute_table[];\n-static bool ix86_function_ok_for_sibcall (tree, tree);\n-static tree ix86_handle_cconv_attribute (tree *, tree, tree, int, bool *);\n-static bool contains_128bit_aligned_vector_p (tree);\n-static rtx ix86_struct_value_rtx (tree, int);\n-static bool ix86_ms_bitfield_layout_p (tree);\n-static tree ix86_handle_struct_attribute (tree *, tree, tree, int, bool *);\n-static int extended_reg_mentioned_1 (rtx *, void *);\n-static bool ix86_rtx_costs (rtx, int, int, int *);\n-static int min_insn_size (rtx);\n-static tree ix86_md_asm_clobbers (tree outputs, tree inputs, tree clobbers);\n-static bool ix86_must_pass_in_stack (enum machine_mode mode, tree type);\n-static bool ix86_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode,\n-\t\t\t\t    tree, bool);\n-static void ix86_init_builtins (void);\n-static rtx ix86_expand_builtin (tree, rtx, rtx, enum machine_mode, int);\n-static tree ix86_builtin_vectorized_function (enum built_in_function, tree, tree);\n-static tree ix86_builtin_conversion (enum tree_code, tree);\n-static const char *ix86_mangle_fundamental_type (tree);\n-static tree ix86_stack_protect_fail (void);\n-static rtx ix86_internal_arg_pointer (void);\n-static void ix86_dwarf_handle_frame_unspec (const char *, rtx, int);\n-static bool ix86_expand_vector_init_one_nonzero (bool, enum machine_mode,\n-\t\t\t\t\t\t rtx, rtx, int);\n-static rtx ix86_function_value (tree, tree, bool);\n-\n-/* This function is only used on Solaris.  */\n-static void i386_solaris_elf_named_section (const char *, unsigned int, tree)\n-  ATTRIBUTE_UNUSED;\n \n /* Register class used for passing given 64bit part of the argument.\n    These represent classes as documented by the PS ABI, with the exception\n    of SSESF, SSEDF classes, that are basically SSE class, just gcc will\n    use SF or DFmode move instead of DImode to avoid reformatting penalties.\n \n    Similarly we play games with INTEGERSI_CLASS to use cheaper SImode moves\n-   whenever possible (upper half does contain padding).\n- */\n+   whenever possible (upper half does contain padding).  */\n enum x86_64_reg_class\n   {\n     X86_64_NO_CLASS,\n@@ -1611,7 +1508,8 @@ enum x86_64_reg_class\n     X86_64_COMPLEX_X87_CLASS,\n     X86_64_MEMORY_CLASS\n   };\n-static const char * const x86_64_reg_class_name[] = {\n+static const char * const x86_64_reg_class_name[] =\n+{\n   \"no\", \"integer\", \"integerSI\", \"sse\", \"sseSF\", \"sseDF\",\n   \"sseup\", \"x87\", \"x87up\", \"cplx87\", \"no\"\n };\n@@ -1621,178 +1519,14 @@ static const char * const x86_64_reg_class_name[] = {\n /* Table of constants used by fldpi, fldln2, etc....  */\n static REAL_VALUE_TYPE ext_80387_constants_table [5];\n static bool ext_80387_constants_init = 0;\n-static void init_ext_80387_constants (void);\n-static bool ix86_in_large_data_p (tree) ATTRIBUTE_UNUSED;\n-static void ix86_encode_section_info (tree, rtx, int) ATTRIBUTE_UNUSED;\n-static void x86_64_elf_unique_section (tree decl, int reloc) ATTRIBUTE_UNUSED;\n-static section *x86_64_elf_select_section (tree decl, int reloc,\n-\t\t\t\t\t   unsigned HOST_WIDE_INT align)\n-\t\t\t\t\t     ATTRIBUTE_UNUSED;\n-\f\n-/* Initialize the GCC target structure.  */\n-#undef TARGET_ATTRIBUTE_TABLE\n-#define TARGET_ATTRIBUTE_TABLE ix86_attribute_table\n-#if TARGET_DLLIMPORT_DECL_ATTRIBUTES\n-#  undef TARGET_MERGE_DECL_ATTRIBUTES\n-#  define TARGET_MERGE_DECL_ATTRIBUTES merge_dllimport_decl_attributes\n-#endif\n-\n-#undef TARGET_COMP_TYPE_ATTRIBUTES\n-#define TARGET_COMP_TYPE_ATTRIBUTES ix86_comp_type_attributes\n-\n-#undef TARGET_INIT_BUILTINS\n-#define TARGET_INIT_BUILTINS ix86_init_builtins\n-#undef TARGET_EXPAND_BUILTIN\n-#define TARGET_EXPAND_BUILTIN ix86_expand_builtin\n-\n-#undef TARGET_VECTORIZE_BUILTIN_VECTORIZED_FUNCTION\n-#define TARGET_VECTORIZE_BUILTIN_VECTORIZED_FUNCTION ix86_builtin_vectorized_function\n-#undef TARGET_VECTORIZE_BUILTIN_CONVERSION\n-#define TARGET_VECTORIZE_BUILTIN_CONVERSION ix86_builtin_conversion\n-\n-#undef TARGET_ASM_FUNCTION_EPILOGUE\n-#define TARGET_ASM_FUNCTION_EPILOGUE ix86_output_function_epilogue\n-\n-#undef TARGET_ENCODE_SECTION_INFO\n-#ifndef SUBTARGET_ENCODE_SECTION_INFO\n-#define TARGET_ENCODE_SECTION_INFO ix86_encode_section_info\n-#else\n-#define TARGET_ENCODE_SECTION_INFO SUBTARGET_ENCODE_SECTION_INFO\n-#endif\n-\n-#undef TARGET_ASM_OPEN_PAREN\n-#define TARGET_ASM_OPEN_PAREN \"\"\n-#undef TARGET_ASM_CLOSE_PAREN\n-#define TARGET_ASM_CLOSE_PAREN \"\"\n-\n-#undef TARGET_ASM_ALIGNED_HI_OP\n-#define TARGET_ASM_ALIGNED_HI_OP ASM_SHORT\n-#undef TARGET_ASM_ALIGNED_SI_OP\n-#define TARGET_ASM_ALIGNED_SI_OP ASM_LONG\n-#ifdef ASM_QUAD\n-#undef TARGET_ASM_ALIGNED_DI_OP\n-#define TARGET_ASM_ALIGNED_DI_OP ASM_QUAD\n-#endif\n-\n-#undef TARGET_ASM_UNALIGNED_HI_OP\n-#define TARGET_ASM_UNALIGNED_HI_OP TARGET_ASM_ALIGNED_HI_OP\n-#undef TARGET_ASM_UNALIGNED_SI_OP\n-#define TARGET_ASM_UNALIGNED_SI_OP TARGET_ASM_ALIGNED_SI_OP\n-#undef TARGET_ASM_UNALIGNED_DI_OP\n-#define TARGET_ASM_UNALIGNED_DI_OP TARGET_ASM_ALIGNED_DI_OP\n-\n-#undef TARGET_SCHED_ADJUST_COST\n-#define TARGET_SCHED_ADJUST_COST ix86_adjust_cost\n-#undef TARGET_SCHED_ISSUE_RATE\n-#define TARGET_SCHED_ISSUE_RATE ix86_issue_rate\n-#undef TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD\n-#define TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD \\\n-  ia32_multipass_dfa_lookahead\n-\n-#undef TARGET_FUNCTION_OK_FOR_SIBCALL\n-#define TARGET_FUNCTION_OK_FOR_SIBCALL ix86_function_ok_for_sibcall\n-\n-#ifdef HAVE_AS_TLS\n-#undef TARGET_HAVE_TLS\n-#define TARGET_HAVE_TLS true\n-#endif\n-#undef TARGET_CANNOT_FORCE_CONST_MEM\n-#define TARGET_CANNOT_FORCE_CONST_MEM ix86_cannot_force_const_mem\n-#undef TARGET_USE_BLOCKS_FOR_CONSTANT_P\n-#define TARGET_USE_BLOCKS_FOR_CONSTANT_P hook_bool_mode_rtx_true\n-\n-#undef TARGET_DELEGITIMIZE_ADDRESS\n-#define TARGET_DELEGITIMIZE_ADDRESS ix86_delegitimize_address\n-\n-#undef TARGET_MS_BITFIELD_LAYOUT_P\n-#define TARGET_MS_BITFIELD_LAYOUT_P ix86_ms_bitfield_layout_p\n-\n-#if TARGET_MACHO\n-#undef TARGET_BINDS_LOCAL_P\n-#define TARGET_BINDS_LOCAL_P darwin_binds_local_p\n-#endif\n-\n-#undef TARGET_ASM_OUTPUT_MI_THUNK\n-#define TARGET_ASM_OUTPUT_MI_THUNK x86_output_mi_thunk\n-#undef TARGET_ASM_CAN_OUTPUT_MI_THUNK\n-#define TARGET_ASM_CAN_OUTPUT_MI_THUNK x86_can_output_mi_thunk\n-\n-#undef TARGET_ASM_FILE_START\n-#define TARGET_ASM_FILE_START x86_file_start\n-\n-#undef TARGET_DEFAULT_TARGET_FLAGS\n-#define TARGET_DEFAULT_TARGET_FLAGS\t\\\n-  (TARGET_DEFAULT\t\t\t\\\n-   | TARGET_64BIT_DEFAULT\t\t\\\n-   | TARGET_SUBTARGET_DEFAULT\t\t\\\n-   | TARGET_TLS_DIRECT_SEG_REFS_DEFAULT)\n-\n-#undef TARGET_HANDLE_OPTION\n-#define TARGET_HANDLE_OPTION ix86_handle_option\n-\n-#undef TARGET_RTX_COSTS\n-#define TARGET_RTX_COSTS ix86_rtx_costs\n-#undef TARGET_ADDRESS_COST\n-#define TARGET_ADDRESS_COST ix86_address_cost\n-\n-#undef TARGET_FIXED_CONDITION_CODE_REGS\n-#define TARGET_FIXED_CONDITION_CODE_REGS ix86_fixed_condition_code_regs\n-#undef TARGET_CC_MODES_COMPATIBLE\n-#define TARGET_CC_MODES_COMPATIBLE ix86_cc_modes_compatible\n-\n-#undef TARGET_MACHINE_DEPENDENT_REORG\n-#define TARGET_MACHINE_DEPENDENT_REORG ix86_reorg\n-\n-#undef TARGET_BUILD_BUILTIN_VA_LIST\n-#define TARGET_BUILD_BUILTIN_VA_LIST ix86_build_builtin_va_list\n-\n-#undef TARGET_MD_ASM_CLOBBERS\n-#define TARGET_MD_ASM_CLOBBERS ix86_md_asm_clobbers\n-\n-#undef TARGET_PROMOTE_PROTOTYPES\n-#define TARGET_PROMOTE_PROTOTYPES hook_bool_tree_true\n-#undef TARGET_STRUCT_VALUE_RTX\n-#define TARGET_STRUCT_VALUE_RTX ix86_struct_value_rtx\n-#undef TARGET_SETUP_INCOMING_VARARGS\n-#define TARGET_SETUP_INCOMING_VARARGS ix86_setup_incoming_varargs\n-#undef TARGET_MUST_PASS_IN_STACK\n-#define TARGET_MUST_PASS_IN_STACK ix86_must_pass_in_stack\n-#undef TARGET_PASS_BY_REFERENCE\n-#define TARGET_PASS_BY_REFERENCE ix86_pass_by_reference\n-#undef TARGET_INTERNAL_ARG_POINTER\n-#define TARGET_INTERNAL_ARG_POINTER ix86_internal_arg_pointer\n-#undef TARGET_DWARF_HANDLE_FRAME_UNSPEC\n-#define TARGET_DWARF_HANDLE_FRAME_UNSPEC ix86_dwarf_handle_frame_unspec\n-\n-#undef TARGET_GIMPLIFY_VA_ARG_EXPR\n-#define TARGET_GIMPLIFY_VA_ARG_EXPR ix86_gimplify_va_arg\n-\n-#undef TARGET_SCALAR_MODE_SUPPORTED_P\n-#define TARGET_SCALAR_MODE_SUPPORTED_P ix86_scalar_mode_supported_p\n-\n-#undef TARGET_VECTOR_MODE_SUPPORTED_P\n-#define TARGET_VECTOR_MODE_SUPPORTED_P ix86_vector_mode_supported_p\n-\n-#ifdef HAVE_AS_TLS\n-#undef TARGET_ASM_OUTPUT_DWARF_DTPREL\n-#define TARGET_ASM_OUTPUT_DWARF_DTPREL i386_output_dwarf_dtprel\n-#endif\n-\n-#ifdef SUBTARGET_INSERT_ATTRIBUTES\n-#undef TARGET_INSERT_ATTRIBUTES\n-#define TARGET_INSERT_ATTRIBUTES SUBTARGET_INSERT_ATTRIBUTES\n-#endif\n-\n-#undef TARGET_MANGLE_FUNDAMENTAL_TYPE\n-#define TARGET_MANGLE_FUNDAMENTAL_TYPE ix86_mangle_fundamental_type\n-\n-#undef TARGET_STACK_PROTECT_FAIL\n-#define TARGET_STACK_PROTECT_FAIL ix86_stack_protect_fail\n-\n-#undef TARGET_FUNCTION_VALUE\n-#define TARGET_FUNCTION_VALUE ix86_function_value\n \n-struct gcc_target targetm = TARGET_INITIALIZER;\n+\f\n+static struct machine_function * ix86_init_machine_status (void);\n+static rtx ix86_function_value (tree, tree, bool);\n+static int ix86_function_regparm (tree, tree);\n+static void ix86_compute_frame_layout (struct ix86_frame *);\n+static bool ix86_expand_vector_init_one_nonzero (bool, enum machine_mode,\n+\t\t\t\t\t\t rtx, rtx, int);\n \n \f\n /* The svr4 ABI for the i386 says that records and unions are returned\n@@ -2518,11 +2252,47 @@ override_options (void)\n     set_param_value (\"l1-cache-line-size\", ix86_cost->prefetch_block);\n }\n \f\n-/* switch to the appropriate section for output of DECL.\n+/* Return true if this goes in large data/bss.  */\n+\n+static bool\n+ix86_in_large_data_p (tree exp)\n+{\n+  if (ix86_cmodel != CM_MEDIUM && ix86_cmodel != CM_MEDIUM_PIC)\n+    return false;\n+\n+  /* Functions are never large data.  */\n+  if (TREE_CODE (exp) == FUNCTION_DECL)\n+    return false;\n+\n+  if (TREE_CODE (exp) == VAR_DECL && DECL_SECTION_NAME (exp))\n+    {\n+      const char *section = TREE_STRING_POINTER (DECL_SECTION_NAME (exp));\n+      if (strcmp (section, \".ldata\") == 0\n+\t  || strcmp (section, \".lbss\") == 0)\n+\treturn true;\n+      return false;\n+    }\n+  else\n+    {\n+      HOST_WIDE_INT size = int_size_in_bytes (TREE_TYPE (exp));\n+\n+      /* If this is an incomplete type with size 0, then we can't put it\n+\t in data because it might be too big when completed.  */\n+      if (!size || size > ix86_section_threshold)\n+\treturn true;\n+    }\n+\n+  return false;\n+}\n+\n+/* Switch to the appropriate section for output of DECL.\n    DECL is either a `VAR_DECL' node or a constant of some sort.\n    RELOC indicates whether forming the initial value of DECL requires\n    link-time relocations.  */\n \n+static section * x86_64_elf_select_section (tree, int, unsigned HOST_WIDE_INT)\n+\tATTRIBUTE_UNUSED;\n+\n static section *\n x86_64_elf_select_section (tree decl, int reloc,\n \t\t\t   unsigned HOST_WIDE_INT align)\n@@ -2589,7 +2359,7 @@ x86_64_elf_select_section (tree decl, int reloc,\n    RELOC indicates whether the initial value of EXP requires\n    link-time relocations.  */\n \n-static void\n+static void ATTRIBUTE_UNUSED\n x86_64_elf_unique_section (tree decl, int reloc)\n {\n   if ((ix86_cmodel == CM_MEDIUM || ix86_cmodel == CM_MEDIUM_PIC)\n@@ -2671,6 +2441,7 @@ x86_elf_aligned_common (FILE *file,\n \t   size, align / BITS_PER_UNIT);\n }\n #endif\n+\n /* Utility function for targets to use in implementing\n    ASM_OUTPUT_ALIGNED_BSS.  */\n \n@@ -2723,40 +2494,6 @@ optimization_options (int level, int size ATTRIBUTE_UNUSED)\n #endif\n }\n \f\n-/* Table of valid machine attributes.  */\n-const struct attribute_spec ix86_attribute_table[] =\n-{\n-  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n-  /* Stdcall attribute says callee is responsible for popping arguments\n-     if they are not variable.  */\n-  { \"stdcall\",   0, 0, false, true,  true,  ix86_handle_cconv_attribute },\n-  /* Fastcall attribute says callee is responsible for popping arguments\n-     if they are not variable.  */\n-  { \"fastcall\",  0, 0, false, true,  true,  ix86_handle_cconv_attribute },\n-  /* Cdecl attribute says the callee is a normal C declaration */\n-  { \"cdecl\",     0, 0, false, true,  true,  ix86_handle_cconv_attribute },\n-  /* Regparm attribute specifies how many integer arguments are to be\n-     passed in registers.  */\n-  { \"regparm\",   1, 1, false, true,  true,  ix86_handle_cconv_attribute },\n-  /* Sseregparm attribute says we are using x86_64 calling conventions\n-     for FP arguments.  */\n-  { \"sseregparm\", 0, 0, false, true, true, ix86_handle_cconv_attribute },\n-  /* force_align_arg_pointer says this function realigns the stack at entry.  */\n-  { (const char *)&ix86_force_align_arg_pointer_string, 0, 0,\n-    false, true,  true, ix86_handle_cconv_attribute },\n-#if TARGET_DLLIMPORT_DECL_ATTRIBUTES\n-  { \"dllimport\", 0, 0, false, false, false, handle_dll_attribute },\n-  { \"dllexport\", 0, 0, false, false, false, handle_dll_attribute },\n-  { \"shared\",    0, 0, true,  false, false, ix86_handle_shared_attribute },\n-#endif\n-  { \"ms_struct\", 0, 0, false, false,  false, ix86_handle_struct_attribute },\n-  { \"gcc_struct\", 0, 0, false, false,  false, ix86_handle_struct_attribute },\n-#ifdef SUBTARGET_ATTRIBUTE_TABLE\n-  SUBTARGET_ATTRIBUTE_TABLE,\n-#endif\n-  { NULL,        0, 0, false, false, false, NULL }\n-};\n-\n /* Decide whether we can make a sibling call to a function.  DECL is the\n    declaration of the function being targeted by the call and EXP is the\n    CALL_EXPR representing the call.  */\n@@ -4760,7 +4497,7 @@ ix86_va_start (tree valist, rtx nextarg)\n \n /* Implement va_arg.  */\n \n-tree\n+static tree\n ix86_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n {\n   static const int intreg[6] = { 0, 1, 2, 3, 4, 5 };\n@@ -6512,49 +6249,9 @@ ix86_address_cost (rtx x)\n   return cost;\n }\n \f\n-/* If X is a machine specific address (i.e. a symbol or label being\n-   referenced as a displacement from the GOT implemented using an\n-   UNSPEC), then return the base term.  Otherwise return X.  */\n-\n-rtx\n-ix86_find_base_term (rtx x)\n-{\n-  rtx term;\n-\n-  if (TARGET_64BIT)\n-    {\n-      if (GET_CODE (x) != CONST)\n-\treturn x;\n-      term = XEXP (x, 0);\n-      if (GET_CODE (term) == PLUS\n-\t  && (CONST_INT_P (XEXP (term, 1))\n-\t      || GET_CODE (XEXP (term, 1)) == CONST_DOUBLE))\n-\tterm = XEXP (term, 0);\n-      if (GET_CODE (term) != UNSPEC\n-\t  || XINT (term, 1) != UNSPEC_GOTPCREL)\n-\treturn x;\n-\n-      term = XVECEXP (term, 0, 0);\n-\n-      if (GET_CODE (term) != SYMBOL_REF\n-\t  && GET_CODE (term) != LABEL_REF)\n-\treturn x;\n-\n-      return term;\n-    }\n-\n-  term = ix86_delegitimize_address (x);\n-\n-  if (GET_CODE (term) != SYMBOL_REF\n-      && GET_CODE (term) != LABEL_REF)\n-    return x;\n-\n-  return term;\n-}\n-\n-/* Allow {LABEL | SYMBOL}_REF - SYMBOL_REF-FOR-PICBASE for Mach-O as\n-   this is used for to form addresses to local data when -fPIC is in\n-   use.  */\n+/* Allow {LABEL | SYMBOL}_REF - SYMBOL_REF-FOR-PICBASE for Mach-O as\n+   this is used for to form addresses to local data when -fPIC is in\n+   use.  */\n \n static bool\n darwin_local_data_pic (rtx disp)\n@@ -6573,7 +6270,7 @@ darwin_local_data_pic (rtx disp)\n \n   return false;\n }\n-\f\n+\n /* Determine if a given RTX is a valid constant.  We already know this\n    satisfies CONSTANT_P.  */\n \n@@ -7831,7 +7528,7 @@ output_pic_addr_const (FILE *file, rtx x, int code)\n /* This is called from dwarf2out.c via TARGET_ASM_OUTPUT_DWARF_DTPREL.\n    We need to emit DTP-relative relocations.  */\n \n-static void\n+static void ATTRIBUTE_UNUSED\n i386_output_dwarf_dtprel (FILE *file, int size, rtx x)\n {\n   fputs (ASM_LONG, file);\n@@ -7937,6 +7634,46 @@ ix86_delegitimize_address (rtx orig_x)\n     result = gen_rtx_PLUS (Pmode, reg_addend, result);\n   return result;\n }\n+\n+/* If X is a machine specific address (i.e. a symbol or label being\n+   referenced as a displacement from the GOT implemented using an\n+   UNSPEC), then return the base term.  Otherwise return X.  */\n+\n+rtx\n+ix86_find_base_term (rtx x)\n+{\n+  rtx term;\n+\n+  if (TARGET_64BIT)\n+    {\n+      if (GET_CODE (x) != CONST)\n+\treturn x;\n+      term = XEXP (x, 0);\n+      if (GET_CODE (term) == PLUS\n+\t  && (CONST_INT_P (XEXP (term, 1))\n+\t      || GET_CODE (XEXP (term, 1)) == CONST_DOUBLE))\n+\tterm = XEXP (term, 0);\n+      if (GET_CODE (term) != UNSPEC\n+\t  || XINT (term, 1) != UNSPEC_GOTPCREL)\n+\treturn x;\n+\n+      term = XVECEXP (term, 0, 0);\n+\n+      if (GET_CODE (term) != SYMBOL_REF\n+\t  && GET_CODE (term) != LABEL_REF)\n+\treturn x;\n+\n+      return term;\n+    }\n+\n+  term = ix86_delegitimize_address (x);\n+\n+  if (GET_CODE (term) != SYMBOL_REF\n+      && GET_CODE (term) != LABEL_REF)\n+    return x;\n+\n+  return term;\n+}\n \f\n static void\n put_condition_code (enum rtx_code code, enum machine_mode mode, int reverse,\n@@ -8138,6 +7875,21 @@ print_reg (rtx x, int code, FILE *file)\n    so that we can print its name in some tls_local_dynamic_base\n    pattern.  */\n \n+static int\n+get_some_local_dynamic_name_1 (rtx *px, void *data ATTRIBUTE_UNUSED)\n+{\n+  rtx x = *px;\n+\n+  if (GET_CODE (x) == SYMBOL_REF\n+      && SYMBOL_REF_TLS_MODEL (x) == TLS_MODEL_LOCAL_DYNAMIC)\n+    {\n+      cfun->machine->some_ld_name = XSTR (x, 0);\n+      return 1;\n+    }\n+\n+  return 0;\n+}\n+\n static const char *\n get_some_local_dynamic_name (void)\n {\n@@ -8154,21 +7906,6 @@ get_some_local_dynamic_name (void)\n   gcc_unreachable ();\n }\n \n-static int\n-get_some_local_dynamic_name_1 (rtx *px, void *data ATTRIBUTE_UNUSED)\n-{\n-  rtx x = *px;\n-\n-  if (GET_CODE (x) == SYMBOL_REF\n-      && SYMBOL_REF_TLS_MODEL (x) == TLS_MODEL_LOCAL_DYNAMIC)\n-    {\n-      cfun->machine->some_ld_name = XSTR (x, 0);\n-      return 1;\n-    }\n-\n-  return 0;\n-}\n-\n /* Meaning of CODE:\n    L,W,B,Q,S,T -- print the opcode suffix for specified size of operand.\n    C -- print opcode suffix for set/cmov insn.\n@@ -10732,131 +10469,6 @@ ix86_cc_modes_compatible (enum machine_mode m1, enum machine_mode m2)\n     }\n }\n \n-/* Return true if we should use an FCOMI instruction for this fp comparison.  */\n-\n-int\n-ix86_use_fcomi_compare (enum rtx_code code ATTRIBUTE_UNUSED)\n-{\n-  enum rtx_code swapped_code = swap_condition (code);\n-  return ((ix86_fp_comparison_cost (code) == ix86_fp_comparison_fcomi_cost (code))\n-\t  || (ix86_fp_comparison_cost (swapped_code)\n-\t      == ix86_fp_comparison_fcomi_cost (swapped_code)));\n-}\n-\n-/* Swap, force into registers, or otherwise massage the two operands\n-   to a fp comparison.  The operands are updated in place; the new\n-   comparison code is returned.  */\n-\n-static enum rtx_code\n-ix86_prepare_fp_compare_args (enum rtx_code code, rtx *pop0, rtx *pop1)\n-{\n-  enum machine_mode fpcmp_mode = ix86_fp_compare_mode (code);\n-  rtx op0 = *pop0, op1 = *pop1;\n-  enum machine_mode op_mode = GET_MODE (op0);\n-  int is_sse = TARGET_SSE_MATH && SSE_FLOAT_MODE_P (op_mode);\n-\n-  /* All of the unordered compare instructions only work on registers.\n-     The same is true of the fcomi compare instructions.  The XFmode\n-     compare instructions require registers except when comparing\n-     against zero or when converting operand 1 from fixed point to\n-     floating point.  */\n-\n-  if (!is_sse\n-      && (fpcmp_mode == CCFPUmode\n-\t  || (op_mode == XFmode\n-\t      && ! (standard_80387_constant_p (op0) == 1\n-\t\t    || standard_80387_constant_p (op1) == 1)\n-\t      && GET_CODE (op1) != FLOAT)\n-\t  || ix86_use_fcomi_compare (code)))\n-    {\n-      op0 = force_reg (op_mode, op0);\n-      op1 = force_reg (op_mode, op1);\n-    }\n-  else\n-    {\n-      /* %%% We only allow op1 in memory; op0 must be st(0).  So swap\n-\t things around if they appear profitable, otherwise force op0\n-\t into a register.  */\n-\n-      if (standard_80387_constant_p (op0) == 0\n-\t  || (MEM_P (op0)\n-\t      && ! (standard_80387_constant_p (op1) == 0\n-\t\t    || MEM_P (op1))))\n-\t{\n-\t  rtx tmp;\n-\t  tmp = op0, op0 = op1, op1 = tmp;\n-\t  code = swap_condition (code);\n-\t}\n-\n-      if (!REG_P (op0))\n-\top0 = force_reg (op_mode, op0);\n-\n-      if (CONSTANT_P (op1))\n-\t{\n-\t  int tmp = standard_80387_constant_p (op1);\n-\t  if (tmp == 0)\n-\t    op1 = validize_mem (force_const_mem (op_mode, op1));\n-\t  else if (tmp == 1)\n-\t    {\n-\t      if (TARGET_CMOVE)\n-\t\top1 = force_reg (op_mode, op1);\n-\t    }\n-\t  else\n-\t    op1 = force_reg (op_mode, op1);\n-\t}\n-    }\n-\n-  /* Try to rearrange the comparison to make it cheaper.  */\n-  if (ix86_fp_comparison_cost (code)\n-      > ix86_fp_comparison_cost (swap_condition (code))\n-      && (REG_P (op1) || !no_new_pseudos))\n-    {\n-      rtx tmp;\n-      tmp = op0, op0 = op1, op1 = tmp;\n-      code = swap_condition (code);\n-      if (!REG_P (op0))\n-\top0 = force_reg (op_mode, op0);\n-    }\n-\n-  *pop0 = op0;\n-  *pop1 = op1;\n-  return code;\n-}\n-\n-/* Convert comparison codes we use to represent FP comparison to integer\n-   code that will result in proper branch.  Return UNKNOWN if no such code\n-   is available.  */\n-\n-enum rtx_code\n-ix86_fp_compare_code_to_integer (enum rtx_code code)\n-{\n-  switch (code)\n-    {\n-    case GT:\n-      return GTU;\n-    case GE:\n-      return GEU;\n-    case ORDERED:\n-    case UNORDERED:\n-      return code;\n-      break;\n-    case UNEQ:\n-      return EQ;\n-      break;\n-    case UNLT:\n-      return LTU;\n-      break;\n-    case UNLE:\n-      return LEU;\n-      break;\n-    case LTGT:\n-      return NE;\n-      break;\n-    default:\n-      return UNKNOWN;\n-    }\n-}\n-\n /* Split comparison code CODE into comparisons we can do using branch\n    instructions.  BYPASS_CODE is comparison code for branch that will\n    branch around FIRST_CODE and SECOND_CODE.  If some of branches\n@@ -11009,6 +10621,134 @@ ix86_fp_comparison_cost (enum rtx_code code)\n   return min;\n }\n \n+/* Return true if we should use an FCOMI instruction for this\n+   fp comparison.  */\n+\n+int\n+ix86_use_fcomi_compare (enum rtx_code code ATTRIBUTE_UNUSED)\n+{\n+  enum rtx_code swapped_code = swap_condition (code);\n+\n+  return ((ix86_fp_comparison_cost (code)\n+\t   == ix86_fp_comparison_fcomi_cost (code))\n+\t  || (ix86_fp_comparison_cost (swapped_code)\n+\t      == ix86_fp_comparison_fcomi_cost (swapped_code)));\n+}\n+\n+/* Swap, force into registers, or otherwise massage the two operands\n+   to a fp comparison.  The operands are updated in place; the new\n+   comparison code is returned.  */\n+\n+static enum rtx_code\n+ix86_prepare_fp_compare_args (enum rtx_code code, rtx *pop0, rtx *pop1)\n+{\n+  enum machine_mode fpcmp_mode = ix86_fp_compare_mode (code);\n+  rtx op0 = *pop0, op1 = *pop1;\n+  enum machine_mode op_mode = GET_MODE (op0);\n+  int is_sse = TARGET_SSE_MATH && SSE_FLOAT_MODE_P (op_mode);\n+\n+  /* All of the unordered compare instructions only work on registers.\n+     The same is true of the fcomi compare instructions.  The XFmode\n+     compare instructions require registers except when comparing\n+     against zero or when converting operand 1 from fixed point to\n+     floating point.  */\n+\n+  if (!is_sse\n+      && (fpcmp_mode == CCFPUmode\n+\t  || (op_mode == XFmode\n+\t      && ! (standard_80387_constant_p (op0) == 1\n+\t\t    || standard_80387_constant_p (op1) == 1)\n+\t      && GET_CODE (op1) != FLOAT)\n+\t  || ix86_use_fcomi_compare (code)))\n+    {\n+      op0 = force_reg (op_mode, op0);\n+      op1 = force_reg (op_mode, op1);\n+    }\n+  else\n+    {\n+      /* %%% We only allow op1 in memory; op0 must be st(0).  So swap\n+\t things around if they appear profitable, otherwise force op0\n+\t into a register.  */\n+\n+      if (standard_80387_constant_p (op0) == 0\n+\t  || (MEM_P (op0)\n+\t      && ! (standard_80387_constant_p (op1) == 0\n+\t\t    || MEM_P (op1))))\n+\t{\n+\t  rtx tmp;\n+\t  tmp = op0, op0 = op1, op1 = tmp;\n+\t  code = swap_condition (code);\n+\t}\n+\n+      if (!REG_P (op0))\n+\top0 = force_reg (op_mode, op0);\n+\n+      if (CONSTANT_P (op1))\n+\t{\n+\t  int tmp = standard_80387_constant_p (op1);\n+\t  if (tmp == 0)\n+\t    op1 = validize_mem (force_const_mem (op_mode, op1));\n+\t  else if (tmp == 1)\n+\t    {\n+\t      if (TARGET_CMOVE)\n+\t\top1 = force_reg (op_mode, op1);\n+\t    }\n+\t  else\n+\t    op1 = force_reg (op_mode, op1);\n+\t}\n+    }\n+\n+  /* Try to rearrange the comparison to make it cheaper.  */\n+  if (ix86_fp_comparison_cost (code)\n+      > ix86_fp_comparison_cost (swap_condition (code))\n+      && (REG_P (op1) || !no_new_pseudos))\n+    {\n+      rtx tmp;\n+      tmp = op0, op0 = op1, op1 = tmp;\n+      code = swap_condition (code);\n+      if (!REG_P (op0))\n+\top0 = force_reg (op_mode, op0);\n+    }\n+\n+  *pop0 = op0;\n+  *pop1 = op1;\n+  return code;\n+}\n+\n+/* Convert comparison codes we use to represent FP comparison to integer\n+   code that will result in proper branch.  Return UNKNOWN if no such code\n+   is available.  */\n+\n+enum rtx_code\n+ix86_fp_compare_code_to_integer (enum rtx_code code)\n+{\n+  switch (code)\n+    {\n+    case GT:\n+      return GTU;\n+    case GE:\n+      return GEU;\n+    case ORDERED:\n+    case UNORDERED:\n+      return code;\n+      break;\n+    case UNEQ:\n+      return EQ;\n+      break;\n+    case UNLT:\n+      return LTU;\n+      break;\n+    case UNLE:\n+      return LEU;\n+      break;\n+    case LTGT:\n+      return NE;\n+      break;\n+    default:\n+      return UNKNOWN;\n+    }\n+}\n+\n /* Generate insn patterns to do a floating point compare of OPERANDS.  */\n \n static rtx\n@@ -14770,77 +14510,6 @@ ix86_expand_setmem (rtx dst, rtx count_exp, rtx val_exp, rtx align_exp,\n   return 1;\n }\n \n-/* Expand strlen.  */\n-int\n-ix86_expand_strlen (rtx out, rtx src, rtx eoschar, rtx align)\n-{\n-  rtx addr, scratch1, scratch2, scratch3, scratch4;\n-\n-  /* The generic case of strlen expander is long.  Avoid it's\n-     expanding unless TARGET_INLINE_ALL_STRINGOPS.  */\n-\n-  if (TARGET_UNROLL_STRLEN && eoschar == const0_rtx && optimize > 1\n-      && !TARGET_INLINE_ALL_STRINGOPS\n-      && !optimize_size\n-      && (!CONST_INT_P (align) || INTVAL (align) < 4))\n-    return 0;\n-\n-  addr = force_reg (Pmode, XEXP (src, 0));\n-  scratch1 = gen_reg_rtx (Pmode);\n-\n-  if (TARGET_UNROLL_STRLEN && eoschar == const0_rtx && optimize > 1\n-      && !optimize_size)\n-    {\n-      /* Well it seems that some optimizer does not combine a call like\n-         foo(strlen(bar), strlen(bar));\n-         when the move and the subtraction is done here.  It does calculate\n-         the length just once when these instructions are done inside of\n-         output_strlen_unroll().  But I think since &bar[strlen(bar)] is\n-         often used and I use one fewer register for the lifetime of\n-         output_strlen_unroll() this is better.  */\n-\n-      emit_move_insn (out, addr);\n-\n-      ix86_expand_strlensi_unroll_1 (out, src, align);\n-\n-      /* strlensi_unroll_1 returns the address of the zero at the end of\n-         the string, like memchr(), so compute the length by subtracting\n-         the start address.  */\n-      if (TARGET_64BIT)\n-\temit_insn (gen_subdi3 (out, out, addr));\n-      else\n-\temit_insn (gen_subsi3 (out, out, addr));\n-    }\n-  else\n-    {\n-      rtx unspec;\n-      scratch2 = gen_reg_rtx (Pmode);\n-      scratch3 = gen_reg_rtx (Pmode);\n-      scratch4 = force_reg (Pmode, constm1_rtx);\n-\n-      emit_move_insn (scratch3, addr);\n-      eoschar = force_reg (QImode, eoschar);\n-\n-      src = replace_equiv_address_nv (src, scratch3);\n-\n-      /* If .md starts supporting :P, this can be done in .md.  */\n-      unspec = gen_rtx_UNSPEC (Pmode, gen_rtvec (4, src, eoschar, align,\n-\t\t\t\t\t\t scratch4), UNSPEC_SCAS);\n-      emit_insn (gen_strlenqi_1 (scratch1, scratch3, unspec));\n-      if (TARGET_64BIT)\n-\t{\n-\t  emit_insn (gen_one_cmpldi2 (scratch2, scratch1));\n-\t  emit_insn (gen_adddi3 (out, scratch2, constm1_rtx));\n-\t}\n-      else\n-\t{\n-\t  emit_insn (gen_one_cmplsi2 (scratch2, scratch1));\n-\t  emit_insn (gen_addsi3 (out, scratch2, constm1_rtx));\n-\t}\n-    }\n-  return 1;\n-}\n-\n /* Expand the appropriate insns for doing strlen if not just doing\n    repnz; scasb\n \n@@ -15032,6 +14701,78 @@ ix86_expand_strlensi_unroll_1 (rtx out, rtx src, rtx align_rtx)\n   emit_label (end_0_label);\n }\n \n+/* Expand strlen.  */\n+\n+int\n+ix86_expand_strlen (rtx out, rtx src, rtx eoschar, rtx align)\n+{\n+  rtx addr, scratch1, scratch2, scratch3, scratch4;\n+\n+  /* The generic case of strlen expander is long.  Avoid it's\n+     expanding unless TARGET_INLINE_ALL_STRINGOPS.  */\n+\n+  if (TARGET_UNROLL_STRLEN && eoschar == const0_rtx && optimize > 1\n+      && !TARGET_INLINE_ALL_STRINGOPS\n+      && !optimize_size\n+      && (!CONST_INT_P (align) || INTVAL (align) < 4))\n+    return 0;\n+\n+  addr = force_reg (Pmode, XEXP (src, 0));\n+  scratch1 = gen_reg_rtx (Pmode);\n+\n+  if (TARGET_UNROLL_STRLEN && eoschar == const0_rtx && optimize > 1\n+      && !optimize_size)\n+    {\n+      /* Well it seems that some optimizer does not combine a call like\n+         foo(strlen(bar), strlen(bar));\n+         when the move and the subtraction is done here.  It does calculate\n+         the length just once when these instructions are done inside of\n+         output_strlen_unroll().  But I think since &bar[strlen(bar)] is\n+         often used and I use one fewer register for the lifetime of\n+         output_strlen_unroll() this is better.  */\n+\n+      emit_move_insn (out, addr);\n+\n+      ix86_expand_strlensi_unroll_1 (out, src, align);\n+\n+      /* strlensi_unroll_1 returns the address of the zero at the end of\n+         the string, like memchr(), so compute the length by subtracting\n+         the start address.  */\n+      if (TARGET_64BIT)\n+\temit_insn (gen_subdi3 (out, out, addr));\n+      else\n+\temit_insn (gen_subsi3 (out, out, addr));\n+    }\n+  else\n+    {\n+      rtx unspec;\n+      scratch2 = gen_reg_rtx (Pmode);\n+      scratch3 = gen_reg_rtx (Pmode);\n+      scratch4 = force_reg (Pmode, constm1_rtx);\n+\n+      emit_move_insn (scratch3, addr);\n+      eoschar = force_reg (QImode, eoschar);\n+\n+      src = replace_equiv_address_nv (src, scratch3);\n+\n+      /* If .md starts supporting :P, this can be done in .md.  */\n+      unspec = gen_rtx_UNSPEC (Pmode, gen_rtvec (4, src, eoschar, align,\n+\t\t\t\t\t\t scratch4), UNSPEC_SCAS);\n+      emit_insn (gen_strlenqi_1 (scratch1, scratch3, unspec));\n+      if (TARGET_64BIT)\n+\t{\n+\t  emit_insn (gen_one_cmpldi2 (scratch2, scratch1));\n+\t  emit_insn (gen_adddi3 (out, scratch2, constm1_rtx));\n+\t}\n+      else\n+\t{\n+\t  emit_insn (gen_one_cmplsi2 (scratch2, scratch1));\n+\t  emit_insn (gen_addsi3 (out, scratch2, constm1_rtx));\n+\t}\n+    }\n+  return 1;\n+}\n+\n /* For given symbol (function) construct code to compute address of it's PLT\n    entry in large x86-64 PIC model.  */\n rtx\n@@ -16727,13 +16468,6 @@ static const struct builtin_description bdesc_1arg[] =\n   { MASK_SSSE3, CODE_FOR_absv2si2, \"__builtin_ia32_pabsd\", IX86_BUILTIN_PABSD, 0, 0 },\n };\n \n-static void\n-ix86_init_builtins (void)\n-{\n-  if (TARGET_MMX)\n-    ix86_init_mmx_sse_builtins ();\n-}\n-\n /* Set up all the MMX/SSE builtins.  This is not called if TARGET_MMX\n    is zero.  Otherwise, if TARGET_SSE is not set, only expand the MMX\n    builtins.  */\n@@ -17461,6 +17195,13 @@ ix86_init_mmx_sse_builtins (void)\n \t       ftype, IX86_BUILTIN_VEC_SET_V4HI);\n }\n \n+static void\n+ix86_init_builtins (void)\n+{\n+  if (TARGET_MMX)\n+    ix86_init_mmx_sse_builtins ();\n+}\n+\n /* Errors in the source file can cause expand_expr to return const0_rtx\n    where we expect a vector.  To avoid crashing, use one of the vector\n    clear instructions.  */\n@@ -20934,39 +20675,10 @@ ix86_md_asm_clobbers (tree outputs ATTRIBUTE_UNUSED,\n   return clobbers;\n }\n \n-/* Return true if this goes in small data/bss.  */\n-\n-static bool\n-ix86_in_large_data_p (tree exp)\n-{\n-  if (ix86_cmodel != CM_MEDIUM && ix86_cmodel != CM_MEDIUM_PIC)\n-    return false;\n-\n-  /* Functions are never large data.  */\n-  if (TREE_CODE (exp) == FUNCTION_DECL)\n-    return false;\n-\n-  if (TREE_CODE (exp) == VAR_DECL && DECL_SECTION_NAME (exp))\n-    {\n-      const char *section = TREE_STRING_POINTER (DECL_SECTION_NAME (exp));\n-      if (strcmp (section, \".ldata\") == 0\n-\t  || strcmp (section, \".lbss\") == 0)\n-\treturn true;\n-      return false;\n-    }\n-  else\n-    {\n-      HOST_WIDE_INT size = int_size_in_bytes (TREE_TYPE (exp));\n-\n-      /* If this is an incomplete type with size 0, then we can't put it\n-\t in data because it might be too big when completed.  */\n-      if (!size || size > ix86_section_threshold)\n-\treturn true;\n-    }\n+/* Implementes target vector targetm.asm.encode_section_info.  This\n+   is not used by netware.  */\n \n-  return false;\n-}\n-static void\n+static void ATTRIBUTE_UNUSED\n ix86_encode_section_info (tree decl, rtx rtl, int first)\n {\n   default_encode_section_info (decl, rtl, first);\n@@ -21072,7 +20784,7 @@ void ix86_emit_i387_log1p (rtx op0, rtx op1)\n \n /* Solaris implementation of TARGET_ASM_NAMED_SECTION.  */\n \n-static void\n+static void ATTRIBUTE_UNUSED\n i386_solaris_elf_named_section (const char *name, unsigned int flags,\n \t\t\t\ttree decl)\n {\n@@ -21722,4 +21434,204 @@ ix86_expand_round (rtx operand0, rtx operand1)\n   emit_move_insn (operand0, res);\n }\n \n+\f\n+/* Table of valid machine attributes.  */\n+static const struct attribute_spec ix86_attribute_table[] =\n+{\n+  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n+  /* Stdcall attribute says callee is responsible for popping arguments\n+     if they are not variable.  */\n+  { \"stdcall\",   0, 0, false, true,  true,  ix86_handle_cconv_attribute },\n+  /* Fastcall attribute says callee is responsible for popping arguments\n+     if they are not variable.  */\n+  { \"fastcall\",  0, 0, false, true,  true,  ix86_handle_cconv_attribute },\n+  /* Cdecl attribute says the callee is a normal C declaration */\n+  { \"cdecl\",     0, 0, false, true,  true,  ix86_handle_cconv_attribute },\n+  /* Regparm attribute specifies how many integer arguments are to be\n+     passed in registers.  */\n+  { \"regparm\",   1, 1, false, true,  true,  ix86_handle_cconv_attribute },\n+  /* Sseregparm attribute says we are using x86_64 calling conventions\n+     for FP arguments.  */\n+  { \"sseregparm\", 0, 0, false, true, true, ix86_handle_cconv_attribute },\n+  /* force_align_arg_pointer says this function realigns the stack at entry.  */\n+  { (const char *)&ix86_force_align_arg_pointer_string, 0, 0,\n+    false, true,  true, ix86_handle_cconv_attribute },\n+#if TARGET_DLLIMPORT_DECL_ATTRIBUTES\n+  { \"dllimport\", 0, 0, false, false, false, handle_dll_attribute },\n+  { \"dllexport\", 0, 0, false, false, false, handle_dll_attribute },\n+  { \"shared\",    0, 0, true,  false, false, ix86_handle_shared_attribute },\n+#endif\n+  { \"ms_struct\", 0, 0, false, false,  false, ix86_handle_struct_attribute },\n+  { \"gcc_struct\", 0, 0, false, false,  false, ix86_handle_struct_attribute },\n+#ifdef SUBTARGET_ATTRIBUTE_TABLE\n+  SUBTARGET_ATTRIBUTE_TABLE,\n+#endif\n+  { NULL,        0, 0, false, false, false, NULL }\n+};\n+\n+/* Initialize the GCC target structure.  */\n+#undef TARGET_ATTRIBUTE_TABLE\n+#define TARGET_ATTRIBUTE_TABLE ix86_attribute_table\n+#if TARGET_DLLIMPORT_DECL_ATTRIBUTES\n+#  undef TARGET_MERGE_DECL_ATTRIBUTES\n+#  define TARGET_MERGE_DECL_ATTRIBUTES merge_dllimport_decl_attributes\n+#endif\n+\n+#undef TARGET_COMP_TYPE_ATTRIBUTES\n+#define TARGET_COMP_TYPE_ATTRIBUTES ix86_comp_type_attributes\n+\n+#undef TARGET_INIT_BUILTINS\n+#define TARGET_INIT_BUILTINS ix86_init_builtins\n+#undef TARGET_EXPAND_BUILTIN\n+#define TARGET_EXPAND_BUILTIN ix86_expand_builtin\n+\n+#undef TARGET_VECTORIZE_BUILTIN_VECTORIZED_FUNCTION\n+#define TARGET_VECTORIZE_BUILTIN_VECTORIZED_FUNCTION ix86_builtin_vectorized_function\n+#undef TARGET_VECTORIZE_BUILTIN_CONVERSION\n+#define TARGET_VECTORIZE_BUILTIN_CONVERSION ix86_builtin_conversion\n+\n+#undef TARGET_ASM_FUNCTION_EPILOGUE\n+#define TARGET_ASM_FUNCTION_EPILOGUE ix86_output_function_epilogue\n+\n+#undef TARGET_ENCODE_SECTION_INFO\n+#ifndef SUBTARGET_ENCODE_SECTION_INFO\n+#define TARGET_ENCODE_SECTION_INFO ix86_encode_section_info\n+#else\n+#define TARGET_ENCODE_SECTION_INFO SUBTARGET_ENCODE_SECTION_INFO\n+#endif\n+\n+#undef TARGET_ASM_OPEN_PAREN\n+#define TARGET_ASM_OPEN_PAREN \"\"\n+#undef TARGET_ASM_CLOSE_PAREN\n+#define TARGET_ASM_CLOSE_PAREN \"\"\n+\n+#undef TARGET_ASM_ALIGNED_HI_OP\n+#define TARGET_ASM_ALIGNED_HI_OP ASM_SHORT\n+#undef TARGET_ASM_ALIGNED_SI_OP\n+#define TARGET_ASM_ALIGNED_SI_OP ASM_LONG\n+#ifdef ASM_QUAD\n+#undef TARGET_ASM_ALIGNED_DI_OP\n+#define TARGET_ASM_ALIGNED_DI_OP ASM_QUAD\n+#endif\n+\n+#undef TARGET_ASM_UNALIGNED_HI_OP\n+#define TARGET_ASM_UNALIGNED_HI_OP TARGET_ASM_ALIGNED_HI_OP\n+#undef TARGET_ASM_UNALIGNED_SI_OP\n+#define TARGET_ASM_UNALIGNED_SI_OP TARGET_ASM_ALIGNED_SI_OP\n+#undef TARGET_ASM_UNALIGNED_DI_OP\n+#define TARGET_ASM_UNALIGNED_DI_OP TARGET_ASM_ALIGNED_DI_OP\n+\n+#undef TARGET_SCHED_ADJUST_COST\n+#define TARGET_SCHED_ADJUST_COST ix86_adjust_cost\n+#undef TARGET_SCHED_ISSUE_RATE\n+#define TARGET_SCHED_ISSUE_RATE ix86_issue_rate\n+#undef TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD\n+#define TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD \\\n+  ia32_multipass_dfa_lookahead\n+\n+#undef TARGET_FUNCTION_OK_FOR_SIBCALL\n+#define TARGET_FUNCTION_OK_FOR_SIBCALL ix86_function_ok_for_sibcall\n+\n+#ifdef HAVE_AS_TLS\n+#undef TARGET_HAVE_TLS\n+#define TARGET_HAVE_TLS true\n+#endif\n+#undef TARGET_CANNOT_FORCE_CONST_MEM\n+#define TARGET_CANNOT_FORCE_CONST_MEM ix86_cannot_force_const_mem\n+#undef TARGET_USE_BLOCKS_FOR_CONSTANT_P\n+#define TARGET_USE_BLOCKS_FOR_CONSTANT_P hook_bool_mode_rtx_true\n+\n+#undef TARGET_DELEGITIMIZE_ADDRESS\n+#define TARGET_DELEGITIMIZE_ADDRESS ix86_delegitimize_address\n+\n+#undef TARGET_MS_BITFIELD_LAYOUT_P\n+#define TARGET_MS_BITFIELD_LAYOUT_P ix86_ms_bitfield_layout_p\n+\n+#if TARGET_MACHO\n+#undef TARGET_BINDS_LOCAL_P\n+#define TARGET_BINDS_LOCAL_P darwin_binds_local_p\n+#endif\n+\n+#undef TARGET_ASM_OUTPUT_MI_THUNK\n+#define TARGET_ASM_OUTPUT_MI_THUNK x86_output_mi_thunk\n+#undef TARGET_ASM_CAN_OUTPUT_MI_THUNK\n+#define TARGET_ASM_CAN_OUTPUT_MI_THUNK x86_can_output_mi_thunk\n+\n+#undef TARGET_ASM_FILE_START\n+#define TARGET_ASM_FILE_START x86_file_start\n+\n+#undef TARGET_DEFAULT_TARGET_FLAGS\n+#define TARGET_DEFAULT_TARGET_FLAGS\t\\\n+  (TARGET_DEFAULT\t\t\t\\\n+   | TARGET_64BIT_DEFAULT\t\t\\\n+   | TARGET_SUBTARGET_DEFAULT\t\t\\\n+   | TARGET_TLS_DIRECT_SEG_REFS_DEFAULT)\n+\n+#undef TARGET_HANDLE_OPTION\n+#define TARGET_HANDLE_OPTION ix86_handle_option\n+\n+#undef TARGET_RTX_COSTS\n+#define TARGET_RTX_COSTS ix86_rtx_costs\n+#undef TARGET_ADDRESS_COST\n+#define TARGET_ADDRESS_COST ix86_address_cost\n+\n+#undef TARGET_FIXED_CONDITION_CODE_REGS\n+#define TARGET_FIXED_CONDITION_CODE_REGS ix86_fixed_condition_code_regs\n+#undef TARGET_CC_MODES_COMPATIBLE\n+#define TARGET_CC_MODES_COMPATIBLE ix86_cc_modes_compatible\n+\n+#undef TARGET_MACHINE_DEPENDENT_REORG\n+#define TARGET_MACHINE_DEPENDENT_REORG ix86_reorg\n+\n+#undef TARGET_BUILD_BUILTIN_VA_LIST\n+#define TARGET_BUILD_BUILTIN_VA_LIST ix86_build_builtin_va_list\n+\n+#undef TARGET_MD_ASM_CLOBBERS\n+#define TARGET_MD_ASM_CLOBBERS ix86_md_asm_clobbers\n+\n+#undef TARGET_PROMOTE_PROTOTYPES\n+#define TARGET_PROMOTE_PROTOTYPES hook_bool_tree_true\n+#undef TARGET_STRUCT_VALUE_RTX\n+#define TARGET_STRUCT_VALUE_RTX ix86_struct_value_rtx\n+#undef TARGET_SETUP_INCOMING_VARARGS\n+#define TARGET_SETUP_INCOMING_VARARGS ix86_setup_incoming_varargs\n+#undef TARGET_MUST_PASS_IN_STACK\n+#define TARGET_MUST_PASS_IN_STACK ix86_must_pass_in_stack\n+#undef TARGET_PASS_BY_REFERENCE\n+#define TARGET_PASS_BY_REFERENCE ix86_pass_by_reference\n+#undef TARGET_INTERNAL_ARG_POINTER\n+#define TARGET_INTERNAL_ARG_POINTER ix86_internal_arg_pointer\n+#undef TARGET_DWARF_HANDLE_FRAME_UNSPEC\n+#define TARGET_DWARF_HANDLE_FRAME_UNSPEC ix86_dwarf_handle_frame_unspec\n+\n+#undef TARGET_GIMPLIFY_VA_ARG_EXPR\n+#define TARGET_GIMPLIFY_VA_ARG_EXPR ix86_gimplify_va_arg\n+\n+#undef TARGET_SCALAR_MODE_SUPPORTED_P\n+#define TARGET_SCALAR_MODE_SUPPORTED_P ix86_scalar_mode_supported_p\n+\n+#undef TARGET_VECTOR_MODE_SUPPORTED_P\n+#define TARGET_VECTOR_MODE_SUPPORTED_P ix86_vector_mode_supported_p\n+\n+#ifdef HAVE_AS_TLS\n+#undef TARGET_ASM_OUTPUT_DWARF_DTPREL\n+#define TARGET_ASM_OUTPUT_DWARF_DTPREL i386_output_dwarf_dtprel\n+#endif\n+\n+#ifdef SUBTARGET_INSERT_ATTRIBUTES\n+#undef TARGET_INSERT_ATTRIBUTES\n+#define TARGET_INSERT_ATTRIBUTES SUBTARGET_INSERT_ATTRIBUTES\n+#endif\n+\n+#undef TARGET_MANGLE_FUNDAMENTAL_TYPE\n+#define TARGET_MANGLE_FUNDAMENTAL_TYPE ix86_mangle_fundamental_type\n+\n+#undef TARGET_STACK_PROTECT_FAIL\n+#define TARGET_STACK_PROTECT_FAIL ix86_stack_protect_fail\n+\n+#undef TARGET_FUNCTION_VALUE\n+#define TARGET_FUNCTION_VALUE ix86_function_value\n+\n+struct gcc_target targetm = TARGET_INITIALIZER;\n+\f\n #include \"gt-i386.h\""}]}