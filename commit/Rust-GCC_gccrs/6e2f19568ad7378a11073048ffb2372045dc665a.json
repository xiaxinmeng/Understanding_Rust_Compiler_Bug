{"sha": "6e2f19568ad7378a11073048ffb2372045dc665a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmUyZjE5NTY4YWQ3Mzc4YTExMDczMDQ4ZmZiMjM3MjA0NWRjNjY1YQ==", "commit": {"author": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2010-06-20T21:02:46Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2010-06-20T21:02:46Z"}, "message": "re PR other/32998 (-frecord-gcc-switches issues)\n\n\tPR other/32998\n\t* opth-gen.awk: Generate definitions of OPT_SPECIAL_unknown,\n\tOPT_SPECIAL_program_name and OPT_SPECIAL_input_file.\n\t* opts-common.c (find_opt): Return OPT_SPECIAL_unknown on failure.\n\t(decode_cmdline_option): Update for this return value.  Set\n\torig_option_with_args_text field.  Set arg field for unknown\n\toptions.  Make static.\n\t(decode_cmdline_options_to_array): New.\n\t(prune_options): Update handling of find_opt return value.\n\t* opts.c (read_cmdline_option): Take decoded option.  Return void.\n\t(read_cmdline_options): Take decoded options.\n\t(decode_options): Add parameters for decoded options.  Use\n\tdecode_cmdline_options_to_array.  Use decoded options for -O\n\tscan.  Use integral_argument for -O parameters.  Update call to\n\tread_cmdline_options.\n\t(enable_warning_as_error): Update handling of find_opt return\n\tvalue.\n\t* opts.h: Update comment on unknown options.\n\t(struct cl_decoded_option): Update comments on opt_index and arg.\n\tAdd orig_option_with_args_text.\n\t(decode_cmdline_option): Remove.\n\t(decode_cmdline_options_to_array): Declare.\n\t(decode_options): Update prototype.\n\t* toplev.c (save_argv): Remove.\n\t(save_decoded_options, save_decoded_options_count): New.\n\t(read_integral_parameter): Remove.\n\t(print_switch_values): Use decoded options.\n\t(toplev_main): Don't set save_argv.  Update call to\n\tdecode_options.\n\t* toplev.h (read_integral_parameter): Remove.\n\t* varasm.c (elf_record_gcc_switches): Don't handle holding back\n\tnames.\n\nc-family:\n\t* c-common.c (parse_optimize_options): Update call to\n\tdecode_options.\n\nfortran:\n\t* options.c (gfc_handle_option): Don't handle N_OPTS.\n\ntestsuite:\n\t* gcc.dg/opts-2.c: New test.\n\nFrom-SVN: r161053", "tree": {"sha": "2c4f1fab67e1d031a842bdda5d4777aed748b3b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2c4f1fab67e1d031a842bdda5d4777aed748b3b5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e2f19568ad7378a11073048ffb2372045dc665a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e2f19568ad7378a11073048ffb2372045dc665a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e2f19568ad7378a11073048ffb2372045dc665a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e2f19568ad7378a11073048ffb2372045dc665a/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d63e3de09ef2a47b63f29db8da5289404cec4d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d63e3de09ef2a47b63f29db8da5289404cec4d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d63e3de09ef2a47b63f29db8da5289404cec4d1"}], "stats": {"total": 464, "additions": 264, "deletions": 200}, "files": [{"sha": "a0cbd409b17ff4772067ff9f53a4c8212700aac5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2f19568ad7378a11073048ffb2372045dc665a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2f19568ad7378a11073048ffb2372045dc665a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6e2f19568ad7378a11073048ffb2372045dc665a", "patch": "@@ -1,3 +1,38 @@\n+2010-06-20  Joseph Myers  <joseph@codesourcery.com>\n+\n+\tPR other/32998\n+\t* opth-gen.awk: Generate definitions of OPT_SPECIAL_unknown,\n+\tOPT_SPECIAL_program_name and OPT_SPECIAL_input_file.\n+\t* opts-common.c (find_opt): Return OPT_SPECIAL_unknown on failure.\n+\t(decode_cmdline_option): Update for this return value.  Set\n+\torig_option_with_args_text field.  Set arg field for unknown\n+\toptions.  Make static.\n+\t(decode_cmdline_options_to_array): New.\n+\t(prune_options): Update handling of find_opt return value.\n+\t* opts.c (read_cmdline_option): Take decoded option.  Return void.\n+\t(read_cmdline_options): Take decoded options.\n+\t(decode_options): Add parameters for decoded options.  Use\n+\tdecode_cmdline_options_to_array.  Use decoded options for -O\n+\tscan.  Use integral_argument for -O parameters.  Update call to\n+\tread_cmdline_options.\n+\t(enable_warning_as_error): Update handling of find_opt return\n+\tvalue.\n+\t* opts.h: Update comment on unknown options.\n+\t(struct cl_decoded_option): Update comments on opt_index and arg.\n+\tAdd orig_option_with_args_text.\n+\t(decode_cmdline_option): Remove.\n+\t(decode_cmdline_options_to_array): Declare.\n+\t(decode_options): Update prototype.\n+\t* toplev.c (save_argv): Remove.\n+\t(save_decoded_options, save_decoded_options_count): New.\n+\t(read_integral_parameter): Remove.\n+\t(print_switch_values): Use decoded options.\n+\t(toplev_main): Don't set save_argv.  Update call to\n+\tdecode_options.\n+\t* toplev.h (read_integral_parameter): Remove.\n+\t* varasm.c (elf_record_gcc_switches): Don't handle holding back\n+\tnames.\n+\n 2010-06-19  Richard Earnshaw  <rearnsha@arm.com>\n \n \tPR target/44072"}, {"sha": "68c11653c62eaa0d758945aa2e26c6cd9f72c446", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2f19568ad7378a11073048ffb2372045dc665a/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2f19568ad7378a11073048ffb2372045dc665a/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=6e2f19568ad7378a11073048ffb2372045dc665a", "patch": "@@ -1,3 +1,8 @@\n+2010-06-20  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* c-common.c (parse_optimize_options): Update call to\n+\tdecode_options.\n+\n 2010-06-18  Nathan Froyd  <froydnj@codesourcery.com>\n \n \t* c-common.c (record_types_used_by_current_var_decl): Adjust for"}, {"sha": "86c3802b0d2e4184ea0c13da519481f01bb311f8", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2f19568ad7378a11073048ffb2372045dc665a/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2f19568ad7378a11073048ffb2372045dc665a/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=6e2f19568ad7378a11073048ffb2372045dc665a", "patch": "@@ -7624,6 +7624,8 @@ parse_optimize_options (tree args, bool attr_p)\n   unsigned i;\n   int saved_flag_strict_aliasing;\n   const char **opt_argv;\n+  struct cl_decoded_option *decoded_options;\n+  unsigned int decoded_options_count;\n   tree ap;\n \n   /* Build up argv vector.  Just in case the string is stored away, use garbage\n@@ -7716,7 +7718,8 @@ parse_optimize_options (tree args, bool attr_p)\n   saved_flag_strict_aliasing = flag_strict_aliasing;\n \n   /* Now parse the options.  */\n-  decode_options (opt_argc, opt_argv);\n+  decode_options (opt_argc, opt_argv, &decoded_options,\n+\t\t  &decoded_options_count);\n \n   targetm.override_options_after_change();\n "}, {"sha": "077c42e8706658cc62dd9bf36f7f71d9bd1f9941", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2f19568ad7378a11073048ffb2372045dc665a/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2f19568ad7378a11073048ffb2372045dc665a/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=6e2f19568ad7378a11073048ffb2372045dc665a", "patch": "@@ -1,3 +1,7 @@\n+2010-06-20  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* options.c (gfc_handle_option): Don't handle N_OPTS.\n+\n 2010-06-19  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/44584"}, {"sha": "3b8b8dc1667c9dcc7e20ca51d9208410d7f410b3", "filename": "gcc/fortran/options.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2f19568ad7378a11073048ffb2372045dc665a/gcc%2Ffortran%2Foptions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2f19568ad7378a11073048ffb2372045dc665a/gcc%2Ffortran%2Foptions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Foptions.c?ref=6e2f19568ad7378a11073048ffb2372045dc665a", "patch": "@@ -541,10 +541,6 @@ gfc_handle_option (size_t scode, const char *arg, int value,\n   int result = 1;\n   enum opt_code code = (enum opt_code) scode;\n \n-  /* Ignore file names.  */\n-  if (code == N_OPTS)\n-    return 1;\n-\n   if (gfc_cpp_handle_option (scode, arg, value) == 1)\n     return 1;\n "}, {"sha": "19af0ef0f0c6bd9c69be6fa357c818c8e46d9e91", "filename": "gcc/opth-gen.awk", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2f19568ad7378a11073048ffb2372045dc665a/gcc%2Fopth-gen.awk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2f19568ad7378a11073048ffb2372045dc665a/gcc%2Fopth-gen.awk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopth-gen.awk?ref=6e2f19568ad7378a11073048ffb2372045dc665a", "patch": "@@ -358,7 +358,10 @@ for (i = 0; i < n_opts; i++) {\n \tprint \"  \" enum \",\" s \"/* -\" opts[i] \" */\"\n }\n \n-print \"  N_OPTS\"\n+print \"  N_OPTS,\"\n+print \"  OPT_SPECIAL_unknown,\"\n+print \"  OPT_SPECIAL_program_name,\"\n+print \"  OPT_SPECIAL_input_file\"\n print \"};\"\n print \"\"\n print \"#endif /* OPTIONS_H */\""}, {"sha": "cde8ccfe29b3a43c4c109eecad965696a93decd5", "filename": "gcc/opts-common.c", "status": "modified", "additions": 84, "deletions": 13, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2f19568ad7378a11073048ffb2372045dc665a/gcc%2Fopts-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2f19568ad7378a11073048ffb2372045dc665a/gcc%2Fopts-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts-common.c?ref=6e2f19568ad7378a11073048ffb2372045dc665a", "patch": "@@ -25,8 +25,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"options.h\"\n \n /* Perform a binary search to find which option the command-line INPUT\n-   matches.  Returns its index in the option array, and N_OPTS\n-   (cl_options_count) on failure.\n+   matches.  Returns its index in the option array, and\n+   OPT_SPECIAL_unknown on failure.\n \n    This routine is quite subtle.  A normal binary search is not good\n    enough because some options can be suffixed with an argument, and\n@@ -73,8 +73,8 @@ find_opt (const char *input, int lang_mask)\n     }\n \n   /* This is the switch that is the best match but for a different\n-     front end, or cl_options_count if there is no match at all.  */\n-  match_wrong_lang = cl_options_count;\n+     front end, or OPT_SPECIAL_unknown if there is no match at all.  */\n+  match_wrong_lang = OPT_SPECIAL_unknown;\n \n   /* Backtrace the chain of possible matches, returning the longest\n      one, if any, that fits best.  With current GCC switches, this\n@@ -94,7 +94,7 @@ find_opt (const char *input, int lang_mask)\n \n \t  /* If we haven't remembered a prior match, remember this\n \t     one.  Any prior match is necessarily better.  */\n-\t  if (match_wrong_lang == cl_options_count)\n+\t  if (match_wrong_lang == OPT_SPECIAL_unknown)\n \t    match_wrong_lang = mn;\n \t}\n \n@@ -104,7 +104,7 @@ find_opt (const char *input, int lang_mask)\n     }\n   while (mn != cl_options_count);\n \n-  /* Return the best wrong match, or cl_options_count if none.  */\n+  /* Return the best wrong match, or OPT_SPECIAL_unknown if none.  */\n   return match_wrong_lang;\n }\n \n@@ -129,7 +129,7 @@ integral_argument (const char *arg)\n    LANG_MASK, into the structure *DECODED.  Returns the number of\n    switches consumed.  */\n \n-unsigned int\n+static unsigned int\n decode_cmdline_option (const char **argv, unsigned int lang_mask,\n \t\t       struct cl_decoded_option *decoded)\n {\n@@ -144,7 +144,7 @@ decode_cmdline_option (const char **argv, unsigned int lang_mask,\n   opt = argv[0];\n \n   opt_index = find_opt (opt + 1, lang_mask | CL_COMMON | CL_TARGET);\n-  if (opt_index == cl_options_count\n+  if (opt_index == OPT_SPECIAL_unknown\n       && (opt[1] == 'W' || opt[1] == 'f' || opt[1] == 'm')\n       && opt[2] == 'n' && opt[3] == 'o' && opt[4] == '-')\n     {\n@@ -160,16 +160,20 @@ decode_cmdline_option (const char **argv, unsigned int lang_mask,\n       opt_index = find_opt (opt + 1, lang_mask | CL_COMMON | CL_TARGET);\n     }\n \n-  if (opt_index == cl_options_count)\n-    goto done;\n+  if (opt_index == OPT_SPECIAL_unknown)\n+    {\n+      arg = argv[0];\n+      goto done;\n+    }\n \n   option = &cl_options[opt_index];\n \n   /* Reject negative form of switches that don't take negatives as\n      unrecognized.  */\n   if (!value && (option->flags & CL_REJECT_NEGATIVE))\n     {\n-      opt_index = cl_options_count;\n+      opt_index = OPT_SPECIAL_unknown;\n+      arg = argv[0];\n       goto done;\n     }\n \n@@ -237,9 +241,76 @@ decode_cmdline_option (const char **argv, unsigned int lang_mask,\n   decoded->arg = arg;\n   decoded->value = value;\n   decoded->errors = errors;\n+  switch (result)\n+    {\n+    case 1:\n+      decoded->orig_option_with_args_text = argv[0];\n+      break;\n+    case 2:\n+      decoded->orig_option_with_args_text = concat (argv[0], \" \",\n+\t\t\t\t\t\t    argv[1], NULL);\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n   return result;\n }\n \n+/* Decode command-line options (ARGC and ARGV being the arguments of\n+   main) into an array, setting *DECODED_OPTIONS to a pointer to that\n+   array and *DECODED_OPTIONS_COUNT to the number of entries in the\n+   array.  The first entry in the array is always one for the program\n+   name (OPT_SPECIAL_program_name).  LANG_MASK indicates the language\n+   applicable for decoding.  Do not produce any diagnostics or set\n+   state outside of these variables.  */\n+\n+void\n+decode_cmdline_options_to_array (unsigned int argc, const char **argv, \n+\t\t\t\t unsigned int lang_mask,\n+\t\t\t\t struct cl_decoded_option **decoded_options,\n+\t\t\t\t unsigned int *decoded_options_count)\n+{\n+  unsigned int n, i;\n+  struct cl_decoded_option *opt_array;\n+  unsigned int num_decoded_options;\n+\n+  opt_array = XNEWVEC (struct cl_decoded_option, argc);\n+\n+  opt_array[0].opt_index = OPT_SPECIAL_program_name;\n+  opt_array[0].arg = argv[0];\n+  opt_array[0].orig_option_with_args_text = argv[0];\n+  opt_array[0].value = 1;\n+  opt_array[0].errors = 0;\n+  num_decoded_options = 1;\n+\n+  for (i = 1; i < argc; i += n)\n+    {\n+      const char *opt = argv[i];\n+\n+      /* Interpret \"-\" or a non-switch as a file name.  */\n+      if (opt[0] != '-' || opt[1] == '\\0')\n+\t{\n+\t  opt_array[num_decoded_options].opt_index = OPT_SPECIAL_input_file;\n+\t  opt_array[num_decoded_options].arg = opt;\n+\t  opt_array[num_decoded_options].orig_option_with_args_text = opt;\n+\t  opt_array[num_decoded_options].value = 1;\n+\t  opt_array[num_decoded_options].errors = 0;\n+\t  num_decoded_options++;\n+\t  n = 1;\n+\t  continue;\n+\t}\n+\n+      n = decode_cmdline_option (argv + i, lang_mask,\n+\t\t\t\t &opt_array[num_decoded_options]);\n+      num_decoded_options++;\n+    }\n+\n+  opt_array = XRESIZEVEC (struct cl_decoded_option, opt_array,\n+\t\t\t  num_decoded_options);\n+  *decoded_options = opt_array;\n+  *decoded_options_count = num_decoded_options;\n+}\n+\n /* Return true if NEXT_OPT_IDX cancels OPT_IDX.  Return false if the\n    next one is the same as ORIG_NEXT_OPT_IDX.  */\n \n@@ -281,7 +352,7 @@ prune_options (int *argcp, char ***argvp)\n       const char *opt = (*argvp) [i];\n \n       opt_index = find_opt (opt + 1, -1);\n-      if (opt_index == cl_options_count\n+      if (opt_index == OPT_SPECIAL_unknown\n \t  && (opt[1] == 'W' || opt[1] == 'f' || opt[1] == 'm')\n \t  && opt[2] == 'n' && opt[3] == 'o' && opt[4] == '-')\n \t{\n@@ -300,7 +371,7 @@ prune_options (int *argcp, char ***argvp)\n \t  free (dup);\n \t}\n \n-      if (opt_index == cl_options_count)\n+      if (opt_index == OPT_SPECIAL_unknown)\n \t{\n cont:\n \t  options [i] = 0;"}, {"sha": "006e0f18b16dc8a6ec86e6fdaadc4ed5c425da6f", "filename": "gcc/opts.c", "status": "modified", "additions": 77, "deletions": 70, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2f19568ad7378a11073048ffb2372045dc665a/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2f19568ad7378a11073048ffb2372045dc665a/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=6e2f19568ad7378a11073048ffb2372045dc665a", "patch": "@@ -515,67 +515,63 @@ handle_option (int opt_index, int value, const char *arg,\n   return true;\n }\n \n-/* Handle the switch beginning at ARGV for the language indicated by\n-   LANG_MASK.  Returns the number of switches consumed.  */\n-static unsigned int\n-read_cmdline_option (const char **argv, unsigned int lang_mask)\n+/* Handle the switch DECODED for the language indicated by\n+   LANG_MASK.  */\n+static void\n+read_cmdline_option (struct cl_decoded_option *decoded,\n+\t\t     unsigned int lang_mask)\n {\n-  struct cl_decoded_option decoded;\n-  unsigned int result;\n-  const char *opt;\n   const struct cl_option *option;\n+  const char *opt;\n \n-  opt = argv[0];\n-\n-  result = decode_cmdline_option (argv, lang_mask, &decoded);\n-  if (decoded.opt_index == cl_options_count)\n+  if (decoded->opt_index == OPT_SPECIAL_unknown)\n     {\n+      opt = decoded->arg;\n+\n       if (opt[1] == 'W' && opt[2] == 'n' && opt[3] == 'o' && opt[4] == '-')\n \t/* We don't generate warnings for unknown -Wno-* options\n \t   unless we issue diagnostics.  */\n-\t  postpone_unknown_option_warning (argv[0]);\n+\t  postpone_unknown_option_warning (opt);\n       else\n \terror (\"unrecognized command line option %qs\", opt);\n-      return result;\n+      return;\n     }\n \n-  option = &cl_options[decoded.opt_index];\n+  option = &cl_options[decoded->opt_index];\n+  opt = decoded->orig_option_with_args_text;\n \n-  if (decoded.errors & CL_ERR_DISABLED)\n+  if (decoded->errors & CL_ERR_DISABLED)\n     {\n       error (\"command line option %qs\"\n \t     \" is not supported by this configuration\", opt);\n-      goto done;\n+      return;\n     }\n \n-  if (decoded.errors & CL_ERR_WRONG_LANG)\n+  if (decoded->errors & CL_ERR_WRONG_LANG)\n     {\n-      complain_wrong_lang (argv[0], option, lang_mask);\n-      goto done;\n+      complain_wrong_lang (opt, option, lang_mask);\n+      return;\n     }\n \n-  if (decoded.errors & CL_ERR_MISSING_ARG)\n+  if (decoded->errors & CL_ERR_MISSING_ARG)\n     {\n-      if (!lang_hooks.missing_argument (opt, decoded.opt_index))\n+      if (!lang_hooks.missing_argument (opt, decoded->opt_index))\n \terror (\"missing argument to %qs\", opt);\n-      goto done;\n+      return;\n     }\n \n-  if (decoded.errors & CL_ERR_UINT_ARG)\n+  if (decoded->errors & CL_ERR_UINT_ARG)\n     {\n       error (\"argument to %qs should be a non-negative integer\",\n \t     option->opt_text);\n-      goto done;\n+      return;\n     }\n \n-  gcc_assert (!decoded.errors);\n+  gcc_assert (!decoded->errors);\n \n-  if (!handle_option (decoded.opt_index, decoded.value, decoded.arg,\n+  if (!handle_option (decoded->opt_index, decoded->value, decoded->arg,\n \t\t      lang_mask, DK_UNSPECIFIED))\n     error (\"unrecognized command line option %qs\", opt);\n-\n- done:\n-  return result;\n }\n \n /* Handle FILENAME from the command line.  */\n@@ -667,40 +663,41 @@ flag_instrument_functions_exclude_p (tree fndecl)\n }\n \n \n-/* Decode and handle the vector of command line options.  LANG_MASK\n+/* Handle the vector of command line options.  LANG_MASK\n    contains has a single bit set representing the current\n    language.  */\n static void\n-read_cmdline_options (unsigned int argc, const char **argv, unsigned int lang_mask)\n+read_cmdline_options (struct cl_decoded_option *decoded_options,\n+\t\t      unsigned int decoded_options_count,\n+\t\t      unsigned int lang_mask)\n {\n-  unsigned int n, i;\n+  unsigned int i;\n \n-  for (i = 1; i < argc; i += n)\n+  for (i = 1; i < decoded_options_count; i++)\n     {\n-      const char *opt = argv[i];\n-\n-      /* Interpret \"-\" or a non-switch as a file name.  */\n-      if (opt[0] != '-' || opt[1] == '\\0')\n+      if (decoded_options[i].opt_index == OPT_SPECIAL_input_file)\n \t{\n \t  if (main_input_filename == NULL)\n \t    {\n-\t      main_input_filename = opt;\n+\t      main_input_filename = decoded_options[i].arg;\n \t      main_input_baselength\n \t\t= base_of_path (main_input_filename, &main_input_basename);\n \t    }\n-\t  add_input_filename (opt);\n-\t  n = 1;\n+\t  add_input_filename (decoded_options[i].arg);\n \t  continue;\n \t}\n \n-      n = read_cmdline_option (argv + i, lang_mask);\n+      read_cmdline_option (decoded_options + i, lang_mask);\n     }\n }\n \n /* Parse command line options and set default flag values.  Do minimal\n-   options processing.  */\n+   options processing.  The decoded options are placed in *DECODED_OPTIONS\n+   and *DECODED_OPTIONS_COUNT.  */\n void\n-decode_options (unsigned int argc, const char **argv)\n+decode_options (unsigned int argc, const char **argv,\n+\t\tstruct cl_decoded_option **decoded_options,\n+\t\tunsigned int *decoded_options_count)\n {\n   static bool first_time_p = true;\n   static int initial_min_crossjump_insns;\n@@ -733,40 +730,30 @@ decode_options (unsigned int argc, const char **argv)\n   else\n     lang_mask = initial_lang_mask;\n \n+  decode_cmdline_options_to_array (argc, argv, lang_mask,\n+\t\t\t\t   decoded_options, decoded_options_count);\n+\n   /* Scan to see what optimization level has been specified.  That will\n      determine the default value of many flags.  */\n-  for (i = 1; i < argc; i++)\n+  for (i = 1; i < *decoded_options_count; i++)\n     {\n-      if (!strcmp (argv[i], \"-O\"))\n-\t{\n-\t  optimize = 1;\n-\t  optimize_size = 0;\n-\t  ofast = 0;\n-\t}\n-      else if (argv[i][0] == '-' && argv[i][1] == 'O')\n+      struct cl_decoded_option *opt = &(*decoded_options)[i];\n+      switch (opt->opt_index)\n \t{\n-\t  /* Handle -Os, -O2, -O3, -O69, ...  */\n-\t  const char *p = &argv[i][2];\n-\n-\t  if ((p[0] == 's') && (p[1] == 0))\n-\t    {\n-\t      optimize_size = 1;\n-\n-\t      /* Optimizing for size forces optimize to be 2.  */\n-\t      optimize = 2;\n-\t      ofast = 0;\n-\t    }\n-\t  else if (strcmp (p, \"fast\") == 0)\n+\tcase OPT_O:\n+\t  if (*opt->arg == '\\0')\n \t    {\n-\t      /* -Ofast only adds flags to -O3.  */\n+\t      optimize = 1;\n \t      optimize_size = 0;\n-\t      optimize = 3;\n-\t      ofast = 1;\n+\t      ofast = 0;\n \t    }\n \t  else\n \t    {\n-\t      const int optimize_val = read_integral_parameter (p, p - 2, -1);\n-\t      if (optimize_val != -1)\n+\t      const int optimize_val = integral_argument (opt->arg);\n+\t      if (optimize_val == -1)\n+\t\terror (\"argument to %qs should be a non-negative integer\",\n+\t\t       \"-O\");\n+\t      else\n \t\t{\n \t\t  optimize = optimize_val;\n \t\t  if ((unsigned int) optimize > 255)\n@@ -775,6 +762,26 @@ decode_options (unsigned int argc, const char **argv)\n \t\t  ofast = 0;\n \t\t}\n \t    }\n+\t  break;\n+\n+\tcase OPT_Os:\n+\t  optimize_size = 1;\n+\n+\t  /* Optimizing for size forces optimize to be 2.  */\n+\t  optimize = 2;\n+\t  ofast = 0;\n+\t  break;\n+\n+\tcase OPT_Ofast:\n+\t  /* -Ofast only adds flags to -O3.  */\n+\t  optimize_size = 0;\n+\t  optimize = 3;\n+\t  ofast = 1;\n+\t  break;\n+\n+\tdefault:\n+\t  /* Ignore other options in this prescan.  */\n+\t  break;\n \t}\n     }\n \n@@ -927,7 +934,7 @@ decode_options (unsigned int argc, const char **argv)\n   OPTIMIZATION_OPTIONS (optimize, optimize_size);\n #endif\n \n-  read_cmdline_options (argc, argv, lang_mask);\n+  read_cmdline_options (*decoded_options, *decoded_options_count, lang_mask);\n \n   if (dump_base_name && ! IS_ABSOLUTE_PATH (dump_base_name))\n     {\n@@ -2419,7 +2426,7 @@ enable_warning_as_error (const char *arg, int value, unsigned int lang_mask)\n   new_option[0] = 'W';\n   strcpy (new_option + 1, arg);\n   option_index = find_opt (new_option, lang_mask);\n-  if (option_index == N_OPTS)\n+  if (option_index == OPT_SPECIAL_unknown)\n     {\n       error (\"-Werror=%s: No option -%s\", arg, new_option);\n     }"}, {"sha": "554bb235b3dab1ba2606bb5ecd5460cbe68064e7", "filename": "gcc/opts.h", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2f19568ad7378a11073048ffb2372045dc665a/gcc%2Fopts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2f19568ad7378a11073048ffb2372045dc665a/gcc%2Fopts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.h?ref=6e2f19568ad7378a11073048ffb2372045dc665a", "patch": "@@ -92,7 +92,7 @@ extern const unsigned int cl_lang_count;\n \n /* Possible ways in which a command-line option may be erroneous.\n    These do not include not being known at all; an option index of\n-   cl_options_count is used for that.  */\n+   OPT_SPECIAL_unknown is used for that.  */\n \n #define CL_ERR_DISABLED\t\t(1 << 0) /* Disabled in this configuration.  */\n #define CL_ERR_MISSING_ARG\t(1 << 1) /* Argument required but missing.  */\n@@ -103,12 +103,20 @@ extern const unsigned int cl_lang_count;\n \n struct cl_decoded_option\n {\n-  /* The index of this option, or cl_options_count if not known.  */\n+  /* The index of this option, or an OPT_SPECIAL_* value for\n+     non-options and unknown options.  */\n   size_t opt_index;\n \n-  /* The string argument, or NULL if none.  */\n+  /* The string argument, or NULL if none.  For OPT_SPECIAL_* cases,\n+     the option or non-option command-line argument.  */\n   const char *arg;\n \n+  /* The original text of option plus arguments, with separate argv\n+     elements concatenated into one string with spaces separating\n+     them.  This is for such uses as diagnostics and\n+     -frecord-gcc-switches.  */\n+  const char *orig_option_with_args_text;\n+\n   /* For a boolean option, 1 for the true case and 0 for the \"no-\"\n      case.  For an unsigned integer option, the value of the\n      argument.  1 in all other cases.  */\n@@ -128,11 +136,15 @@ extern unsigned num_in_fnames;\n \n size_t find_opt (const char *input, int lang_mask);\n extern int integral_argument (const char *arg);\n-extern unsigned int decode_cmdline_option (const char **argv,\n-\t\t\t\t\t   unsigned int lang_mask,\n-\t\t\t\t\t   struct cl_decoded_option *decoded);\n+extern void decode_cmdline_options_to_array (unsigned int argc,\n+\t\t\t\t\t     const char **argv, \n+\t\t\t\t\t     unsigned int lang_mask,\n+\t\t\t\t\t     struct cl_decoded_option **decoded_options,\n+\t\t\t\t\t     unsigned int *decoded_options_count);\n extern void prune_options (int *argcp, char ***argvp);\n-extern void decode_options (unsigned int argc, const char **argv);\n+extern void decode_options (unsigned int argc, const char **argv,\n+\t\t\t    struct cl_decoded_option **decoded_options,\n+\t\t\t    unsigned int *decoded_options_count);\n extern int option_enabled (int opt_idx);\n extern bool get_option_state (int, struct cl_option_state *);\n extern void set_option (int opt_index, int value, const char *arg, int);"}, {"sha": "922073a03b002e41e55e5fb19c4686be602e3793", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2f19568ad7378a11073048ffb2372045dc665a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2f19568ad7378a11073048ffb2372045dc665a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6e2f19568ad7378a11073048ffb2372045dc665a", "patch": "@@ -1,3 +1,7 @@\n+2010-06-20  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* gcc.dg/opts-2.c: New test.\n+\n 2010-06-19  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/44584"}, {"sha": "f7683635a0e5cc8172cad2c56235e44bf3760d68", "filename": "gcc/testsuite/gcc.dg/opts-2.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2f19568ad7378a11073048ffb2372045dc665a/gcc%2Ftestsuite%2Fgcc.dg%2Fopts-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2f19568ad7378a11073048ffb2372045dc665a/gcc%2Ftestsuite%2Fgcc.dg%2Fopts-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fopts-2.c?ref=6e2f19568ad7378a11073048ffb2372045dc665a", "patch": "@@ -0,0 +1,8 @@\n+/* -O as an operand to another option should not take effect as an\n+    optimization option.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-I -O\" } */\n+\n+#ifdef __OPTIMIZE__\n+#error \"__OPTIMIZE__ defined\"\n+#endif"}, {"sha": "220c1f777f0e7db103ffa94d0150d4a73336155f", "filename": "gcc/toplev.c", "status": "modified", "additions": 17, "deletions": 53, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2f19568ad7378a11073048ffb2372045dc665a/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2f19568ad7378a11073048ffb2372045dc665a/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=6e2f19568ad7378a11073048ffb2372045dc665a", "patch": "@@ -126,8 +126,9 @@ static bool no_backend;\n /* Length of line when printing switch values.  */\n #define MAX_LINE 75\n \n-/* Copy of argument vector to toplev_main.  */\n-static const char **save_argv;\n+/* Decoded options, and number of such options.  */\n+static struct cl_decoded_option *save_decoded_options;\n+static unsigned int save_decoded_options_count;\n \n /* Name of top-level original source file (what was input to cpp).\n    This comes from the #-command at the beginning of the actual input.\n@@ -488,34 +489,6 @@ set_random_seed (const char *val)\n   return old;\n }\n \n-/* Decode the string P as an integral parameter.\n-   If the string is indeed an integer return its numeric value else\n-   issue an Invalid Option error for the option PNAME and return DEFVAL.\n-   If PNAME is zero just return DEFVAL, do not call error.  */\n-\n-int\n-read_integral_parameter (const char *p, const char *pname, const int  defval)\n-{\n-  const char *endp = p;\n-\n-  while (*endp)\n-    {\n-      if (ISDIGIT (*endp))\n-\tendp++;\n-      else\n-\tbreak;\n-    }\n-\n-  if (*endp != 0)\n-    {\n-      if (pname != 0)\n-\terror (\"invalid option argument %qs\", pname);\n-      return defval;\n-    }\n-\n-  return atoi (p);\n-}\n-\n #if GCC_VERSION < 3004\n \n /* The functions floor_log2 and exact_log2 are defined as inline\n@@ -1338,7 +1311,6 @@ print_switch_values (print_switch_fn_type print_fn)\n {\n   int pos = 0;\n   size_t j;\n-  const char **p;\n \n   /* Fill in the -frandom-seed option, if the user didn't pass it, so\n      that it can be printed below.  This helps reproducibility.  */\n@@ -1349,30 +1321,23 @@ print_switch_values (print_switch_fn_type print_fn)\n   pos = print_single_switch (print_fn, pos,\n \t\t\t     SWITCH_TYPE_DESCRIPTIVE, _(\"options passed: \"));\n \n-  for (p = &save_argv[1]; *p != NULL; p++)\n+  for (j = 1; j < save_decoded_options_count; j++)\n     {\n-      if (**p == '-')\n+      switch (save_decoded_options[j].opt_index)\n \t{\n+\tcase OPT_o:\n+\tcase OPT_d:\n+\tcase OPT_dumpbase:\n+\tcase OPT_dumpdir:\n+\tcase OPT_auxbase:\n+\tcase OPT_quiet:\n+\tcase OPT_version:\n \t  /* Ignore these.  */\n-\t  if (strcmp (*p, \"-o\") == 0\n-\t      || strcmp (*p, \"-dumpbase\") == 0\n-\t      || strcmp (*p, \"-dumpdir\") == 0\n-\t      || strcmp (*p, \"-auxbase\") == 0)\n-\t    {\n-\t      if (p[1] != NULL)\n-\t\tp++;\n-\t      continue;\n-\t    }\n-\n-\t  if (strcmp (*p, \"-quiet\") == 0\n-\t      || strcmp (*p, \"-version\") == 0)\n-\t    continue;\n-\n-\t  if ((*p)[1] == 'd')\n-\t    continue;\n+\t  continue;\n \t}\n \n-      pos = print_single_switch (print_fn, pos, SWITCH_TYPE_PASSED, *p);\n+      pos = print_single_switch (print_fn, pos, SWITCH_TYPE_PASSED,\n+\t\t\t\t save_decoded_options[j].orig_option_with_args_text);\n     }\n \n   if (pos > 0)\n@@ -2395,14 +2360,13 @@ toplev_main (int argc, char **argv)\n {\n   expandargv (&argc, &argv);\n \n-  save_argv = CONST_CAST2 (const char **, char **, argv);\n-\n   /* Initialization of GCC's environment, and diagnostics.  */\n   general_init (argv[0]);\n \n   /* Parse the options and do minimal processing; basically just\n      enough to default flags appropriately.  */\n-  decode_options (argc, CONST_CAST2 (const char **, char **, argv));\n+  decode_options (argc, CONST_CAST2 (const char **, char **, argv),\n+\t\t  &save_decoded_options, &save_decoded_options_count);\n \n   init_local_tick ();\n "}, {"sha": "a7ded4c47ad154a692bf9140747638c8b35dd73d", "filename": "gcc/toplev.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2f19568ad7378a11073048ffb2372045dc665a/gcc%2Ftoplev.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2f19568ad7378a11073048ffb2372045dc665a/gcc%2Ftoplev.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.h?ref=6e2f19568ad7378a11073048ffb2372045dc665a", "patch": "@@ -31,7 +31,6 @@ along with GCC; see the file COPYING3.  If not see\n    (strncmp (whole, part, strlen (part)) ? NULL : whole + strlen (part))\n \n extern int toplev_main (int, char **);\n-extern int read_integral_parameter (const char *, const char *, const int);\n extern void strip_off_ending (char *, int);\n extern void _fatal_insn_not_found (const_rtx, const char *, int, const char *)\n      ATTRIBUTE_NORETURN;"}, {"sha": "98187c13cf283c8145f8759ff5a8ead4916bcadc", "filename": "gcc/varasm.c", "status": "modified", "additions": 3, "deletions": 50, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2f19568ad7378a11073048ffb2372045dc665a/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2f19568ad7378a11073048ffb2372045dc665a/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=6e2f19568ad7378a11073048ffb2372045dc665a", "patch": "@@ -7199,50 +7199,11 @@ output_object_blocks (void)\n int\n elf_record_gcc_switches (print_switch_type type, const char * name)\n {\n-  static char buffer[1024];\n-\n-  /* This variable is used as part of a simplistic heuristic to detect\n-     command line switches which take an argument:\n-\n-       \"If a command line option does not start with a dash then\n-        it is an argument for the previous command line option.\"\n-\n-     This fails in the case of the command line option which is the name\n-     of the file to compile, but otherwise it is pretty reasonable.  */\n-  static bool previous_name_held_back = FALSE;\n-\n   switch (type)\n     {\n     case SWITCH_TYPE_PASSED:\n-      if (* name != '-')\n-\t{\n-\t  if (previous_name_held_back)\n-\t    {\n-\t      unsigned int len = strlen (buffer);\n-\n-\t      snprintf (buffer + len, sizeof buffer - len, \" %s\", name);\n-\t      ASM_OUTPUT_ASCII (asm_out_file, buffer, strlen (buffer));\n-\t      ASM_OUTPUT_SKIP (asm_out_file, (unsigned HOST_WIDE_INT) 1);\n-\t      previous_name_held_back = FALSE;\n-\t    }\n-\t  else\n-\t    {\n-\t      strncpy (buffer, name, sizeof buffer);\n-\t      ASM_OUTPUT_ASCII (asm_out_file, buffer, strlen (buffer));\n-\t      ASM_OUTPUT_SKIP (asm_out_file, (unsigned HOST_WIDE_INT) 1);\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  if (previous_name_held_back)\n-\t    {\n-\t      ASM_OUTPUT_ASCII (asm_out_file, buffer, strlen (buffer));\n-\t      ASM_OUTPUT_SKIP (asm_out_file, (unsigned HOST_WIDE_INT) 1);\n-\t    }\n-\n-\t  strncpy (buffer, name, sizeof buffer);\n-\t  previous_name_held_back = TRUE;\n-\t}\n+      ASM_OUTPUT_ASCII (asm_out_file, name, strlen (name));\n+      ASM_OUTPUT_SKIP (asm_out_file, (unsigned HOST_WIDE_INT) 1);\n       break;\n \n     case SWITCH_TYPE_DESCRIPTIVE:\n@@ -7251,15 +7212,7 @@ elf_record_gcc_switches (print_switch_type type, const char * name)\n \t  /* Distinguish between invocations where name is NULL.  */\n \t  static bool started = false;\n \n-\t  if (started)\n-\t    {\n-\t      if (previous_name_held_back)\n-\t\t{\n-\t\t  ASM_OUTPUT_ASCII (asm_out_file, buffer, strlen (buffer));\n-\t\t  ASM_OUTPUT_SKIP (asm_out_file, (unsigned HOST_WIDE_INT) 1);\n-\t\t}\n-\t    }\n-\t  else\n+\t  if (!started)\n \t    {\n \t      section * sec;\n "}]}