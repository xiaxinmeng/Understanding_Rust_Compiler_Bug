{"sha": "0ae26533b3e26866f4130d40ec0659c273552643", "node_id": "C_kwDOANBUbNoAKDBhZTI2NTMzYjNlMjY4NjZmNDEzMGQ0MGVjMDY1OWMyNzM1NTI2NDM", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-11-01T12:40:05Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-11-01T12:40:05Z"}, "message": "libstdc++: std::to_chars std::{,b}float16_t support\n\nThe following patch on top of\nhttps://gcc.gnu.org/pipermail/libstdc++/2022-October/054849.html\nadds std::{,b}float16_t support for std::to_chars.\nWhen precision is specified (or for std::bfloat16_t for hex mode even if not),\nI believe we can just use the std::to_chars float (when float is mode\ncompatible with std::float32_t) overloads, both formats are proper subsets\nof std::float32_t.\nUnfortunately when precision is not specified and we are supposed to emit\nshortest string, the std::{,b}float16_t strings are usually much shorter.\nE.g. 1.e7p-14f16 shortest fixed representation is\n0.0001161 and shortest scientific representation is\n1.161e-04 while 1.e7p-14f32 (same number promoted to std::float32_t)\n0.00011610985 and\n1.1610985e-04.\nSimilarly for 1.38p-112bf16,\n0.000000000000000000000000000000000235\n2.35e-34 vs. 1.38p-112f32\n0.00000000000000000000000000000000023472271\n2.3472271e-34\nFor std::float16_t there are differences even in the shortest hex, say:\n0.01p-14 vs. 1p-22\nbut only for denormal std::float16_t values (where all std::float16_t\ndenormals converted to std::float32_t are normal), __FLT16_MIN__ and\neverything larger in absolute value than that is the same.  Unless\nthat is a bug and we should try to discover shorter representations\neven for denormals...\nstd::bfloat16_t has the same exponent range as std::float32_t, so all\nstd::bfloat16_t denormals are also std::float32_t denormals and thus\nthe shortest hex representations are the same.\nAs documented, ryu can handle arbitrary IEEE like floating point formats\n(probably not wider than IEEE quad) using the generic_128 handling, but\nryu is hidden in libstdc++.so.  As only few architectures support\nstd::float16_t right now and some of them have special ISA requirements\nfor those (e.g. on i?86 one needs -msse2) and std::bfloat16_t is right\nnow supported only on x86 (again with -msse2), perhaps with aarch64/arm\ncoming next if ARM is interested, but I think it is possible that more\nwill be added later, instead of exporting APIs from the library to handle\ndirectly the std::{,b}float16_t overloads this patch instead exports\nfunctions which take a float which is a superset of those and expects\nthe inline overloads to promote the 16-bit formats to 32-bit, then inside\nof the library it ensures they are printed right.\nWith the added [[gnu::cold]] attribute because I think most users\nwill primarily use these formats as storage formats and perform arithmetics\nin the excess precision for them and print also as std::float32_t the\nadded support doesn't seem to be too large, on x86_64:\nreadelf -Ws libstdc++.so.6.0.31 | grep float16_t\n   912: 00000000000ae824   950 FUNC    GLOBAL DEFAULT   13 _ZSt21__to_chars_bfloat16_tPcS_fSt12chars_format@@GLIBCXX_3.4.31\n  5767: 00000000000ae4a1   899 FUNC    GLOBAL DEFAULT   13 _ZSt20__to_chars_float16_tPcS_fSt12chars_format@@GLIBCXX_3.4.31\n   842: 000000000016d430   106 FUNC    LOCAL  DEFAULT   13 _ZN12_GLOBAL__N_113get_ieee_reprINS_23floating_type_float16_tEEENS_6ieee_tIT_EES3_\n   865: 0000000000170980  1613 FUNC    LOCAL  DEFAULT   13\n+_ZSt23__floating_to_chars_hexIN12_GLOBAL__N_123floating_type_float16_tEESt15to_chars_resultPcS3_T_St8optionalIiE.constprop.0.isra.0\n  7205: 00000000000ae824   950 FUNC    GLOBAL DEFAULT   13 _ZSt21__to_chars_bfloat16_tPcS_fSt12chars_format\n  7985: 00000000000ae4a1   899 FUNC    GLOBAL DEFAULT   13 _ZSt20__to_chars_float16_tPcS_fSt12chars_format\nso 3568 code bytes together or so.\n\nTested with the attached test (which doesn't prove the shortest\nrepresentation, just prints std::{,b}float16_t and std::float32_t\nshortest strings side by side, then tries to verify it can be\nemitted even into the exact sized range and can't be into range\none smaller than that and tries to read what is printed\nback using from_chars float32_t overload (so there could be\ndouble rounding, but apparently there is none for the shortest strings).\nThe only differences printed are for NaNs, where sNaNs are canonicalized\nto canonical qNaNs and as to_chars doesn't print NaN mantissa, even qNaNs\nother than the canonical one are read back just as the canonical NaN.\n\nAlso attaching what Patrick wrote to generate the pow10_adjustment_tab,\nfor std::float16_t only 1.0, 10.0, 100.0, 1000.0 and 10000.0 are powers\nof 10 in the range because __FLT16_MAX__ is 65504.0, and all of the above\nare exactly representable in std::float16_t, so we want to use 0 in\npow10_adjustment_tab.\n\n2022-11-01  Jakub Jelinek  <jakub@redhat.com>\n\n\t* include/std/charconv (__to_chars_float16_t, __to_chars_bfloat16_t):\n\tDeclare.\n\t(to_chars): Add _Float16 and __gnu_cxx::__bfloat16_t overloads.\n\t* config/abi/pre/gnu.ver (GLIBCXX_3.4.31): Export\n\t_ZSt20__to_chars_float16_tPcS_fSt12chars_format and\n\t_ZSt21__to_chars_bfloat16_tPcS_fSt12chars_format.\n\t* src/c++17/floating_to_chars.cc (floating_type_float16_t,\n\tfloating_type_bfloat16_t): New types.\n\t(floating_type_traits<floating_type_float16_t>,\n\tfloating_type_traits<floating_type_bfloat16_t>,\n\tget_ieee_repr<floating_type_float16_t>,\n\tget_ieee_repr<floating_type_bfloat16_t>,\n\t__handle_special_value<floating_type_float16_t>,\n\t__handle_special_value<floating_type_bfloat16_t>): New specializations.\n\t(floating_to_shortest_scientific): Handle floating_type_float16_t\n\tand floating_type_bfloat16_t like IEEE quad.\n\t(__floating_to_chars_shortest): For floating_type_bfloat16_t call\n\t__floating_to_chars_hex<float> rather than\n\t__floating_to_chars_hex<floating_type_bfloat16_t> to avoid\n\tinstantiating the latter.\n\t(__to_chars_float16_t, __to_chars_bfloat16_t): New functions.", "tree": {"sha": "b4a1ba28638599f3feb200f396480f9d8355dd08", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b4a1ba28638599f3feb200f396480f9d8355dd08"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0ae26533b3e26866f4130d40ec0659c273552643", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ae26533b3e26866f4130d40ec0659c273552643", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ae26533b3e26866f4130d40ec0659c273552643", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ae26533b3e26866f4130d40ec0659c273552643/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "29ef50b6bc609130a1550cdfc3997d1e501ffb28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29ef50b6bc609130a1550cdfc3997d1e501ffb28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29ef50b6bc609130a1550cdfc3997d1e501ffb28"}], "stats": {"total": 210, "additions": 208, "deletions": 2}, "files": [{"sha": "729e0cf9391036ce43fa6de9a9f76b7c5b5284be", "filename": "libstdc++-v3/config/abi/pre/gnu.ver", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ae26533b3e26866f4130d40ec0659c273552643/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ae26533b3e26866f4130d40ec0659c273552643/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver?ref=0ae26533b3e26866f4130d40ec0659c273552643", "patch": "@@ -2446,6 +2446,8 @@ GLIBCXX_3.4.30 {\n \n GLIBCXX_3.4.31 {\n     _ZNSt7__cxx1112basic_stringI[cw]St11char_traitsI[cw]ESaI[cw]EE15_M_replace_cold*;\n+    _ZSt20__to_chars_float16_tPcS_fSt12chars_format;\n+    _ZSt21__to_chars_bfloat16_tPcS_fSt12chars_format;\n } GLIBCXX_3.4.30;\n \n # Symbols in the support library (libsupc++) have their own tag."}, {"sha": "e391a2780873e3953a3ea29b696eb9dded0ea0a9", "filename": "libstdc++-v3/include/std/charconv", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ae26533b3e26866f4130d40ec0659c273552643/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcharconv", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ae26533b3e26866f4130d40ec0659c273552643/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcharconv", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcharconv?ref=0ae26533b3e26866f4130d40ec0659c273552643", "patch": "@@ -738,6 +738,32 @@ namespace __detail\n   to_chars_result to_chars(char* __first, char* __last, long double __value,\n \t\t\t   chars_format __fmt, int __precision) noexcept;\n \n+  // Library routines for 16-bit extended floating point formats\n+  // using float as interchange format.\n+  to_chars_result __to_chars_float16_t(char* __first, char* __last,\n+\t\t\t\t       float __value,\n+\t\t\t\t       chars_format __fmt) noexcept;\n+  to_chars_result __to_chars_bfloat16_t(char* __first, char* __last,\n+\t\t\t\t\tfloat __value,\n+\t\t\t\t\tchars_format __fmt) noexcept;\n+\n+#if defined(__STDCPP_FLOAT16_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32)\n+  inline to_chars_result\n+  to_chars(char* __first, char* __last, _Float16 __value) noexcept\n+  {\n+    return __to_chars_float16_t(__first, __last, float(__value),\n+\t\t\t\tchars_format{});\n+  }\n+  inline to_chars_result\n+  to_chars(char* __first, char* __last, _Float16 __value,\n+\t   chars_format __fmt) noexcept\n+  { return __to_chars_float16_t(__first, __last, float(__value), __fmt); }\n+  inline to_chars_result\n+  to_chars(char* __first, char* __last, _Float16 __value,\n+\t   chars_format __fmt, int __precision) noexcept\n+  { return to_chars(__first, __last, float(__value), __fmt, __precision); }\n+#endif\n+\n #if defined(__STDCPP_FLOAT32_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32)\n   inline to_chars_result\n   to_chars(char* __first, char* __last, _Float32 __value) noexcept\n@@ -784,6 +810,24 @@ namespace __detail\n \t\t    __precision);\n   }\n #endif\n+\n+#if defined(__STDCPP_BFLOAT16_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32)\n+  inline to_chars_result\n+  to_chars(char* __first, char* __last,\n+\t   __gnu_cxx::__bfloat16_t __value) noexcept\n+  {\n+    return __to_chars_bfloat16_t(__first, __last, float(__value),\n+\t\t\t\t chars_format{});\n+  }\n+  inline to_chars_result\n+  to_chars(char* __first, char* __last, __gnu_cxx::__bfloat16_t __value,\n+\t   chars_format __fmt) noexcept\n+  { return __to_chars_bfloat16_t(__first, __last, float(__value), __fmt); }\n+  inline to_chars_result\n+  to_chars(char* __first, char* __last, __gnu_cxx::__bfloat16_t __value,\n+\t   chars_format __fmt, int __precision) noexcept\n+  { return to_chars(__first, __last, float(__value), __fmt, __precision); }\n+#endif\n #endif\n \n _GLIBCXX_END_NAMESPACE_VERSION"}, {"sha": "43e1ff351197cc69b732ead973ce57c3d7ed6006", "filename": "libstdc++-v3/src/c++17/floating_to_chars.cc", "status": "modified", "additions": 162, "deletions": 2, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ae26533b3e26866f4130d40ec0659c273552643/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffloating_to_chars.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ae26533b3e26866f4130d40ec0659c273552643/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffloating_to_chars.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffloating_to_chars.cc?ref=0ae26533b3e26866f4130d40ec0659c273552643", "patch": "@@ -374,6 +374,44 @@ namespace\n     };\n #endif\n \n+  // Wrappers around float for std::{,b}float16_t promoted to float.\n+  struct floating_type_float16_t\n+  {\n+    float x;\n+    operator float() const { return x; }\n+  };\n+  struct floating_type_bfloat16_t\n+  {\n+    float x;\n+    operator float() const { return x; }\n+  };\n+\n+  template<>\n+    struct floating_type_traits<floating_type_float16_t>\n+    {\n+      static constexpr int mantissa_bits = 10;\n+      static constexpr int exponent_bits = 5;\n+      static constexpr bool has_implicit_leading_bit = true;\n+      using mantissa_t = uint32_t;\n+      using shortest_scientific_t = ryu::floating_decimal_128;\n+\n+      static constexpr uint64_t pow10_adjustment_tab[]\n+\t= { 0 };\n+    };\n+\n+  template<>\n+    struct floating_type_traits<floating_type_bfloat16_t>\n+    {\n+      static constexpr int mantissa_bits = 7;\n+      static constexpr int exponent_bits = 8;\n+      static constexpr bool has_implicit_leading_bit = true;\n+      using mantissa_t = uint32_t;\n+      using shortest_scientific_t = ryu::floating_decimal_128;\n+\n+      static constexpr uint64_t pow10_adjustment_tab[]\n+\t= { 0b0000111001110001101010010110100101010010000000000000000000000000 };\n+    };\n+\n   // An IEEE-style decomposition of a floating-point value of type T.\n   template<typename T>\n     struct ieee_t\n@@ -482,6 +520,79 @@ namespace\n     }\n #endif\n \n+  template<>\n+    ieee_t<floating_type_float16_t>\n+    get_ieee_repr(const floating_type_float16_t value)\n+    {\n+      using mantissa_t = typename floating_type_traits<float>::mantissa_t;\n+      constexpr int mantissa_bits = floating_type_traits<float>::mantissa_bits;\n+      constexpr int exponent_bits = floating_type_traits<float>::exponent_bits;\n+\n+      uint32_t value_bits = 0;\n+      memcpy(&value_bits, &value.x, sizeof(value));\n+\n+      ieee_t<floating_type_float16_t> ieee_repr;\n+      ieee_repr.mantissa\n+\t= static_cast<mantissa_t>(value_bits & ((uint32_t{1} << mantissa_bits) - 1u));\n+      value_bits >>= mantissa_bits;\n+      ieee_repr.biased_exponent\n+\t= static_cast<uint32_t>(value_bits & ((uint32_t{1} << exponent_bits) - 1u));\n+      value_bits >>= exponent_bits;\n+      ieee_repr.sign = (value_bits & 1) != 0;\n+      // We have mantissa and biased_exponent from the float (originally\n+      // float16_t converted to float).\n+      // Transform that to float16_t mantissa and biased_exponent.\n+      // If biased_exponent is 0, then value is +-0.0.\n+      // If biased_exponent is 0x67..0x70, then it is a float16_t denormal.\n+      if (ieee_repr.biased_exponent >= 0x67\n+\t  && ieee_repr.biased_exponent <= 0x70)\n+\t{\n+\t  int n = ieee_repr.biased_exponent - 0x67;\n+\t  ieee_repr.mantissa = ((uint32_t{1} << n)\n+\t\t\t\t| (ieee_repr.mantissa >> (mantissa_bits - n)));\n+\t  ieee_repr.biased_exponent = 0;\n+\t}\n+      // If biased_exponent is 0xff, then it is a float16_t inf or NaN.\n+      else if (ieee_repr.biased_exponent == 0xff)\n+\t{\n+\t  ieee_repr.mantissa >>= 13;\n+\t  ieee_repr.biased_exponent = 0x1f;\n+\t}\n+      // If biased_exponent is 0x71..0x8e, then it is a float16_t normal number.\n+      else if (ieee_repr.biased_exponent > 0x70)\n+\t{\n+\t  ieee_repr.mantissa >>= 13;\n+\t  ieee_repr.biased_exponent -= 0x70;\n+\t}\n+      return ieee_repr;\n+    }\n+\n+  template<>\n+    ieee_t<floating_type_bfloat16_t>\n+    get_ieee_repr(const floating_type_bfloat16_t value)\n+    {\n+      using mantissa_t = typename floating_type_traits<float>::mantissa_t;\n+      constexpr int mantissa_bits = floating_type_traits<float>::mantissa_bits;\n+      constexpr int exponent_bits = floating_type_traits<float>::exponent_bits;\n+\n+      uint32_t value_bits = 0;\n+      memcpy(&value_bits, &value.x, sizeof(value));\n+\n+      ieee_t<floating_type_bfloat16_t> ieee_repr;\n+      ieee_repr.mantissa\n+\t= static_cast<mantissa_t>(value_bits & ((uint32_t{1} << mantissa_bits) - 1u));\n+      value_bits >>= mantissa_bits;\n+      ieee_repr.biased_exponent\n+\t= static_cast<uint32_t>(value_bits & ((uint32_t{1} << exponent_bits) - 1u));\n+      value_bits >>= exponent_bits;\n+      ieee_repr.sign = (value_bits & 1) != 0;\n+      // We have mantissa and biased_exponent from the float (originally\n+      // bfloat16_t converted to float).\n+      // Transform that to bfloat16_t mantissa and biased_exponent.\n+      ieee_repr.mantissa >>= 16;\n+      return ieee_repr;\n+    }\n+\n   // Invoke Ryu to obtain the shortest scientific form for the given\n   // floating-point number.\n   template<typename T>\n@@ -493,7 +604,9 @@ namespace\n       else if constexpr (std::is_same_v<T, double>)\n \treturn ryu::floating_to_fd64(value);\n       else if constexpr (std::is_same_v<T, long double>\n-\t\t\t || std::is_same_v<T, F128_type>)\n+\t\t\t || std::is_same_v<T, F128_type>\n+\t\t\t || std::is_same_v<T, floating_type_float16_t>\n+\t\t\t || std::is_same_v<T, floating_type_bfloat16_t>)\n \t{\n \t  constexpr int mantissa_bits\n \t    = floating_type_traits<T>::mantissa_bits;\n@@ -678,6 +791,28 @@ template<typename T>\n     return {{first, errc{}}};\n   }\n \n+template<>\n+  optional<to_chars_result>\n+  __handle_special_value<floating_type_float16_t>(char* first,\n+\t\t\t\t\t\t  char* const last,\n+\t\t\t\t\t\t  const floating_type_float16_t value,\n+\t\t\t\t\t\t  const chars_format fmt,\n+\t\t\t\t\t\t  const int precision)\n+  {\n+    return __handle_special_value(first, last, value.x, fmt, precision);\n+  }\n+\n+template<>\n+  optional<to_chars_result>\n+  __handle_special_value<floating_type_bfloat16_t>(char* first,\n+\t\t\t\t\t\t   char* const last,\n+\t\t\t\t\t\t   const floating_type_bfloat16_t value,\n+\t\t\t\t\t\t   const chars_format fmt,\n+\t\t\t\t\t\t   const int precision)\n+  {\n+    return __handle_special_value(first, last, value.x, fmt, precision);\n+  }\n+\n // This subroutine of the floating-point to_chars overloads performs\n // hexadecimal formatting.\n template<typename T>\n@@ -922,7 +1057,15 @@ template<typename T>\n \t\t\t       chars_format fmt)\n   {\n     if (fmt == chars_format::hex)\n-      return __floating_to_chars_hex(first, last, value, nullopt);\n+      {\n+\t// std::bfloat16_t has the same exponent range as std::float32_t\n+\t// and so we can avoid instantiation of __floating_to_chars_hex\n+\t// for bfloat16_t.  Shortest hex will be the same as for float.\n+\tif constexpr (is_same_v<T, floating_type_bfloat16_t>)\n+\t  return __floating_to_chars_hex(first, last, value.x, nullopt);\n+\telse\n+\t  return __floating_to_chars_hex(first, last, value, nullopt);\n+      }\n \n     __glibcxx_assert(fmt == chars_format::fixed\n \t\t     || fmt == chars_format::scientific\n@@ -1662,6 +1805,23 @@ to_chars(char* first, char* last, __float128 value, chars_format fmt,\n }\n #endif\n \n+// Entrypoints for 16-bit floats.\n+[[gnu::cold]] to_chars_result\n+__to_chars_float16_t(char* first, char* last, float value,\n+\t\t     chars_format fmt) noexcept\n+{\n+  return __floating_to_chars_shortest(first, last,\n+\t\t\t\t      floating_type_float16_t{ value }, fmt);\n+}\n+\n+[[gnu::cold]] to_chars_result\n+__to_chars_bfloat16_t(char* first, char* last, float value,\n+\t\t      chars_format fmt) noexcept\n+{\n+  return __floating_to_chars_shortest(first, last,\n+\t\t\t\t      floating_type_bfloat16_t{ value }, fmt);\n+}\n+\n #ifdef _GLIBCXX_LONG_DOUBLE_COMPAT\n // Map the -mlong-double-64 long double overloads to the double overloads.\n extern \"C\" to_chars_result"}]}