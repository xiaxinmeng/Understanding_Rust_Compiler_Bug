{"sha": "d5e4ff48146169795c31246ac5547df56bd799a8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDVlNGZmNDgxNDYxNjk3OTVjMzEyNDZhYzU1NDdkZjU2YmQ3OTlhOA==", "commit": {"author": {"name": "Michael Hayes", "email": "m.hayes@elec.canterbury.ac.nz", "date": "1998-10-13T03:04:59Z"}, "committer": {"name": "Michael Hayes", "email": "m.hayes@gcc.gnu.org", "date": "1998-10-13T03:04:59Z"}, "message": "c4x.c: Convert to gen_rtx_FOO.\n\n\t* config/c4x/c4x.c:  Convert to gen_rtx_FOO.\n\tAdded ATTRIBUTE_UNUSED to unused function arguments.\n\t(rc_reg_operand): New predicate.\n\t(c4x_rptb_insert): New function.\n\t(c4x_rptb_nop_p): Recognize modified rptb_top pattern.\n\t(c4x_optimization_options): New function.\n\t* config/c4x/c4x.md: Convert to gen_rtx_FOO.\n\t (decrement_and_branch_on_count): New pattern.\n\t (rptb_top): Modified pattern to work with BCT optimization.\n\t* config/c4x/c4x.h (RC_REG): New register class.\n\t(rc_reg_operand): Define prototype.\n\t(IS_RC_REG): New macro.\n\t(IS_RC_OR_PSEUDO_REG): New macro.\n\t(IS_RC_OR_PSEUDO_REGNO): New macro.\n\t(OPTIMIZATION_OPTIONS): Define.\n\nFrom-SVN: r23037", "tree": {"sha": "556e7fd4dcda8ff34c6dddd021744bfac6eb2a2b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/556e7fd4dcda8ff34c6dddd021744bfac6eb2a2b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d5e4ff48146169795c31246ac5547df56bd799a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5e4ff48146169795c31246ac5547df56bd799a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5e4ff48146169795c31246ac5547df56bd799a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5e4ff48146169795c31246ac5547df56bd799a8/comments", "author": null, "committer": null, "parents": [{"sha": "df3f6b6df49373d856f14f2429b197b449498600", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df3f6b6df49373d856f14f2429b197b449498600", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df3f6b6df49373d856f14f2429b197b449498600"}], "stats": {"total": 407, "additions": 261, "deletions": 146}, "files": [{"sha": "26df069c7759acbc23d28dab508fe82a09a147bf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e4ff48146169795c31246ac5547df56bd799a8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e4ff48146169795c31246ac5547df56bd799a8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d5e4ff48146169795c31246ac5547df56bd799a8", "patch": "@@ -1,3 +1,23 @@\n+Tue Oct 13 21:38:35 1998  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n+\n+\t* config/c4x/c4x.c:  Convert to gen_rtx_FOO.\n+\tAdded ATTRIBUTE_UNUSED to unused function arguments.\n+\t(rc_reg_operand): New predicate.\n+\t(c4x_rptb_insert): New function.\n+\t(c4x_rptb_nop_p): Recognize modified rptb_top pattern.\n+\t(c4x_optimization_options): New function.\n+\n+\t* config/c4x/c4x.md: Convert to gen_rtx_FOO.\n+\t (decrement_and_branch_on_count): New pattern.\n+\t (rptb_top): Modified pattern to work with BCT optimization.\n+\t\n+\t* config/c4x/c4x.h (RC_REG): New register class.\n+\t(rc_reg_operand): Define prototype.\n+\t(IS_RC_REG): New macro.\n+\t(IS_RC_OR_PSEUDO_REG): New macro.\n+\t(IS_RC_OR_PSEUDO_REGNO): New macro.\n+\t(OPTIMIZATION_OPTIONS): Define.\n+\n Mon Oct 12 19:57:34 1998  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* collect2.c (extract_init_priority): No priority is 65535."}, {"sha": "b471e3758d20faad37ab7db26159ec8d2e8277db", "filename": "gcc/config/c4x/c4x.c", "status": "modified", "additions": 152, "deletions": 102, "changes": 254, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e4ff48146169795c31246ac5547df56bd799a8/gcc%2Fconfig%2Fc4x%2Fc4x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e4ff48146169795c31246ac5547df56bd799a8/gcc%2Fconfig%2Fc4x%2Fc4x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.c?ref=d5e4ff48146169795c31246ac5547df56bd799a8", "patch": "@@ -87,7 +87,7 @@ enum reg_class c4x_regclass_map[FIRST_PSEUDO_REGISTER] =\n   NO_REGS,\t\t\t/* IIF/IOF                      No  */\n   INT_REGS,\t\t\t/* RS           QI              No  */\n   INT_REGS,\t\t\t/* RE           QI              No  */\n-  INT_REGS,\t\t\t/* RC           QI              No  */\n+  RC_REG,\t\t\t/* RC           QI              No  */\n   EXT_REGS,\t\t\t/* R8           QI, QF, HF      QI  */\n   EXT_REGS,\t\t\t/* R9           QI, QF, HF      No  */\n   EXT_REGS,\t\t\t/* R10          QI, QF, HF      No  */\n@@ -246,6 +246,15 @@ c4x_override_options ()\n \n }\n \n+void\n+c4x_optimization_options (level, size)\n+     int level;\n+     int size ATTRIBUTE_UNUSED;\n+{\n+  /* When optimizing, enable use of RPTB instruction.  */\n+  if (level >= 1)\n+      flag_branch_on_count_reg = 1;\n+}\n \n /* Write an ASCII string.  */\n \n@@ -591,7 +600,7 @@ c4x_function_arg (cum, mode, type, named)\n       fprintf (stderr, \")\\n\");\n     }\n   if (reg)\n-    return gen_rtx (REG, mode, reg);\n+    return gen_rtx_REG (mode, reg);\n   else\n     return NULL_RTX;\n }\n@@ -1042,7 +1051,7 @@ c4x_null_epilogue_p ()\n \n void\n c4x_emit_libcall (name, code, dmode, smode, noperands, operands)\n-     const char *name;\n+     char *name;\n      enum rtx_code code;\n      enum machine_mode dmode;\n      enum machine_mode smode;\n@@ -1055,7 +1064,7 @@ c4x_emit_libcall (name, code, dmode, smode, noperands, operands)\n   rtx equiv;\n \n   start_sequence ();\n-  libcall = gen_rtx (SYMBOL_REF, Pmode, name);\n+  libcall = gen_rtx_SYMBOL_REF (Pmode, name);\n   switch (noperands)\n     {\n     case 2:\n@@ -1092,7 +1101,7 @@ c4x_emit_libcall3 (name, code, mode, operands)\n \n void\n c4x_emit_libcall_mulhi (name, code, mode, operands)\n-     const char *name;\n+     char *name;\n      enum rtx_code code;\n      enum machine_mode mode;\n      rtx *operands;\n@@ -1103,15 +1112,15 @@ c4x_emit_libcall_mulhi (name, code, mode, operands)\n   rtx equiv;\n \n   start_sequence ();\n-  libcall = gen_rtx (SYMBOL_REF, Pmode, name);\n+  libcall = gen_rtx_SYMBOL_REF (Pmode, name);\n   ret = emit_library_call_value (libcall, NULL_RTX, 1, mode, 2,\n                                  operands[1], mode, operands[2], mode);\n-  equiv = gen_rtx (TRUNCATE, mode,\n-                   gen_rtx (LSHIFTRT, HImode,\n-                            gen_rtx (MULT, HImode,\n+  equiv = gen_rtx_TRUNCATE (mode,\n+                   gen_rtx_LSHIFTRT (HImode,\n+                            gen_rtx_MULT (HImode,\n                                      gen_rtx (code, HImode, operands[1]),\n                                      gen_rtx (code, HImode, operands[2])),\n-                            gen_rtx (CONST_INT, VOIDmode, 32)));\n+                                     gen_rtx_CONST_INT (VOIDmode, 32)));\n   insns = get_insns ();\n   end_sequence ();\n   emit_libcall_block (insns, operands[0], ret, equiv);\n@@ -1144,7 +1153,7 @@ c4x_preferred_reload_class (x, class)\n \n enum reg_class\n c4x_limit_reload_class (mode, class)\n-     enum machine_mode mode;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n      enum reg_class class;\n {\n   return class;\n@@ -1153,9 +1162,9 @@ c4x_limit_reload_class (mode, class)\n \n enum reg_class\n c4x_secondary_memory_needed (class1, class2, mode)\n-     enum reg_class class1;\n-     enum reg_class class2;\n-     enum machine_mode mode;\n+     enum reg_class class1 ATTRIBUTE_UNUSED;\n+     enum reg_class class2 ATTRIBUTE_UNUSED;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   return 0;\n }\n@@ -1349,8 +1358,8 @@ c4x_check_legit_addr (mode, addr, strict)\n \n rtx\n c4x_legitimize_address (orig, mode)\n-     rtx orig;\n-     enum machine_mode mode;\n+     rtx orig ATTRIBUTE_UNUSED;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   return NULL_RTX;\n }\n@@ -1443,9 +1452,9 @@ c4x_gen_compare_reg (code, x, y)\n       && (code == LE || code == GE || code == LT || code == GT))\n     return NULL_RTX;\n \n-  cc_reg = gen_rtx (REG, mode, ST_REGNO);\n-  emit_insn (gen_rtx (SET, VOIDmode, cc_reg,\n-\t\t      gen_rtx (COMPARE, mode, x, y)));\n+  cc_reg = gen_rtx_REG (mode, ST_REGNO);\n+  emit_insn (gen_rtx_SET (VOIDmode, cc_reg,\n+\t\t\t  gen_rtx_COMPARE (mode, x, y)));\n   return cc_reg;\n }\n \n@@ -1901,9 +1910,9 @@ c4x_scan_for_ldp (newop, insn, operand0)\n \t      addr = XEXP (addr, 0);\n \t      if (GET_CODE (addr) == CONST_INT)\n \t\t{\n-\t\t  op1 = gen_rtx (CONST_INT, VOIDmode, INTVAL (addr) & ~0xffff);\n+\t\t  op1 = gen_rtx_CONST_INT (VOIDmode, INTVAL (addr) & ~0xffff);\n \t\t  emit_insn_before (gen_movqi (operand0, op1), insn);\n-\t\t  op1 = gen_rtx (CONST_INT, VOIDmode, INTVAL (addr) & 0xffff);\n+\t\t  op1 = gen_rtx_CONST_INT (VOIDmode, INTVAL (addr) & 0xffff);\n \t\t  emit_insn_before (gen_iorqi3_noclobber (operand0,\n \t\t\t\t\t\t      operand0, op1), insn);\n \t\t  delete_insn (insn);\n@@ -1932,13 +1941,14 @@ c4x_scan_for_ldp (newop, insn, operand0)\n \t\t}\n \t    }\n \t  if (!TARGET_SMALL)\n-\t    emit_insn_before (gen_set_ldp (gen_rtx (REG, Pmode, DP_REGNO),\n+\t    emit_insn_before (gen_set_ldp (gen_rtx_REG (Pmode, DP_REGNO),\n \t\t\t\t\t   operand), insn);\n \n \t  /* Replace old memory reference with direct reference.  */\n-\t  *newop = gen_rtx (MEM, GET_MODE (operand),\n-\t\t\t    gen_rtx (PLUS, Pmode,\n-\t\t\t\t     gen_rtx (REG, Pmode, DP_REGNO), op0));\n+\t  *newop = gen_rtx_MEM (GET_MODE (operand),\n+\t\t\t\tgen_rtx_PLUS (Pmode,\n+\t\t\t\t\t      gen_rtx_REG (Pmode, DP_REGNO),\n+\t\t\t\t\t      op0));\n \n \t  /* Use change_address?  */\n \t  MEM_VOLATILE_P (*newop) = MEM_VOLATILE_P (operand);\n@@ -1977,15 +1987,15 @@ c4x_scan_for_ldp (newop, insn, operand0)\n \tbreak;\n \n       op0 = XEXP (force_const_mem (Pmode, operand), 0);\n-      *newop = gen_rtx (MEM, GET_MODE (operand),\n-\t\t\tgen_rtx (PLUS, Pmode,\n-\t\t\t\t gen_rtx (PLUS, Pmode,\n-\t\t\t\t\t  gen_rtx (USE, VOIDmode, operand),\n-\t\t\t\t\t  gen_rtx (REG, Pmode, DP_REGNO)),\n-\t\t\t\t op0));\n-\n+      *newop = gen_rtx_MEM (GET_MODE (operand),\n+\t\t\t    gen_rtx_PLUS (Pmode,\n+\t\t\t\t\t  gen_rtx_PLUS (Pmode,\n+\t\t\t\t\t      gen_rtx_USE (VOIDmode, operand),\n+\t\t\t\t\t      gen_rtx_REG (Pmode, DP_REGNO)),\n+\t\t\t\t\t  op0));\n+      \n       if (!TARGET_SMALL)\n-\temit_insn_before (gen_set_ldp_use (gen_rtx (REG, Pmode, DP_REGNO),\n+\temit_insn_before (gen_set_ldp_use (gen_rtx_REG (Pmode, DP_REGNO),\n \t\t\t\t\t   *newop, operand), insn);\n       return 0;\n \n@@ -2021,14 +2031,20 @@ c4x_scan_for_ldp (newop, insn, operand0)\n \n    Note that we cannot have a call insn, since we don't generate\n    repeat loops with calls in them (although I suppose we could, but\n-   there's no benefit.)  */\n+   there's no benefit.)  \n+\n+   !!! FIXME.  The rptb_top insn may be sucked into a SEQUENCE.  */\n \n int\n c4x_rptb_nop_p (insn)\n      rtx insn;\n {\n+  rtx start_label;\n   int i;\n \n+  /* Extract the start label from the jump pattern (rptb_end).  */\n+  start_label = XEXP (XEXP (SET_SRC (XVECEXP (PATTERN (insn), 0, 0)), 1), 0);\n+\n   /* If there is a label at the end of the loop we must insert\n      a NOP.  */\n   insn = prev_nonnote_insn (insn);\n@@ -2040,21 +2056,48 @@ c4x_rptb_nop_p (insn)\n       /* Search back for prev non-note and non-label insn.  */\n       while (GET_CODE (insn) == NOTE || GET_CODE (insn) == CODE_LABEL\n \t     || GET_CODE (insn) == USE || GET_CODE (insn) == CLOBBER)\n-\tinsn = PREV_INSN (insn);\n+\t{\n+\t  if (insn == start_label)\n+\t    return i == 0;\n+\n+\t  insn = PREV_INSN (insn);\n+\t};\n \n-      /* I we have a jump instruction we should insert a NOP. If we\n+      /* If we have a jump instruction we should insert a NOP. If we\n \t hit repeat block top we should only insert a NOP if the loop\n \t is empty. */\n       if (GET_CODE (insn) == JUMP_INSN)\n \treturn 1;\n-      else if (recog_memoized (insn) == CODE_FOR_rptb_top)\n-\treturn i == 0;\n       insn = PREV_INSN (insn);\n     }\n   return 0;\n }\n \n \n+void\n+c4x_rptb_insert (insn)\n+     rtx insn;\n+{\n+  rtx end_label;\n+  rtx start_label;\n+  \n+  /* Extract the start label from the jump pattern (rptb_end).  */\n+  start_label = XEXP (XEXP (SET_SRC (XVECEXP (PATTERN (insn), 0, 0)), 1), 0);\n+\n+  /* We'll have to update the basic blocks.  */\n+  end_label = gen_label_rtx ();\n+  emit_label_after (end_label, insn);\n+\n+  for (; insn; insn = PREV_INSN (insn))\n+    if (insn == start_label)\n+      break;\n+  if (!insn)\n+    fatal_insn (\"c4x_rptb_insert: Cannot find start label\", start_label);\n+\n+  /* We'll have to update the basic blocks.  */\n+  emit_insn_before (gen_rptb_top (start_label, end_label), insn);\n+}\n+\n /* This function is a C4x special. It scans through all the insn\n    operands looking for places where the DP register needs to be\n    reloaded and for large immediate operands that need to be converted\n@@ -2067,7 +2110,6 @@ void\n c4x_process_after_reload (first)\n      rtx first;\n {\n-  rtx operand0;\n   rtx insn;\n   int i;\n \n@@ -2076,14 +2118,18 @@ c4x_process_after_reload (first)\n       /* Look for insn.  */\n       if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n \t{\n-\t  int noperands;\n \t  int insn_code_number;\n \n \t  insn_code_number = recog_memoized (insn);\n \n \t  if (insn_code_number < 0)\n \t    continue;\n \n+\t  /* Insert the RTX for RPTB at the top of the loop\n+\t     and a label at the end of the loop. */\n+\t  if (insn_code_number == CODE_FOR_rptb_end)\n+\t    c4x_rptb_insert(insn);\n+\n \t  /* We split all insns here if they have a # for the output\n \t     template if we are using the big memory model since there\n \t     is a chance that we might be accessing memory across a\n@@ -2109,7 +2155,7 @@ c4x_process_after_reload (first)\n \t\t  /* Do we have to update the basic block info here? \n \t\t     Maybe reorg wants it sorted out... */\n \n-\t\t  /* Continue with the first of the new insns gnerated\n+\t\t  /* Continue with the first of the new insns generated\n                      by the split. */\n \t\t  insn = new;\n \n@@ -2121,20 +2167,13 @@ c4x_process_after_reload (first)\n \t    }\n \n \t  /* Ignore jumps and calls.  */\n-\t  if (GET_CODE (insn) == CALL_INSN\n-\t      || GET_CODE (insn) == JUMP_INSN)\n-\t    {\n-\t      continue;\t\t/* Hopefully we are not hosed here.  */\n-\t    }\n-\n-\t  noperands = insn_n_operands[insn_code_number];\n+\t  if (GET_CODE (insn) == CALL_INSN || GET_CODE (insn) == JUMP_INSN)\n+\t      continue;\t\n \n \t  insn_extract (insn);\n-\n-\t  operand0 = recog_operand[0];\n-\n-\t  for (i = 0; i < noperands; i++)\n-\t    if (c4x_scan_for_ldp (recog_operand_loc[i], insn, operand0))\n+\t  for (i = 0; i < insn_n_operands[insn_code_number]; i++)\n+\t    if (c4x_scan_for_ldp (recog_operand_loc[i], insn, \n+\t\t\t\t  recog_operand[0]))\n \t      break;\n \t}\n     }\n@@ -2555,7 +2594,7 @@ c4x_T_constraint (op)\n int\n c4x_autoinc_operand (op, mode)\n      rtx op;\n-     enum machine_mode mode;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   if (GET_CODE (op) == MEM)\n     {\n@@ -2578,8 +2617,8 @@ c4x_autoinc_operand (op, mode)\n \n int\n any_operand (op, mode)\n-     register rtx op;\n-     enum machine_mode mode;\n+     register rtx op ATTRIBUTE_UNUSED;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   return 1;\n }\n@@ -2637,7 +2676,7 @@ const_operand (op, mode)\n int\n stik_const_operand (op, mode)\n      rtx op;\n-     enum machine_mode mode;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   return c4x_K_constant (op);\n }\n@@ -2646,7 +2685,7 @@ stik_const_operand (op, mode)\n int\n not_const_operand (op, mode)\n      rtx op;\n-     enum machine_mode mode;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   return c4x_N_constant (op);\n }\n@@ -2663,7 +2702,7 @@ reg_operand (op, mode)\n int\n reg_imm_operand (op, mode)\n      rtx op;\n-     enum machine_mode mode;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   if (REG_P (op) || CONSTANT_P (op))\n     return 1;\n@@ -2673,7 +2712,7 @@ reg_imm_operand (op, mode)\n int\n not_modify_reg (op, mode)\n      rtx op;\n-     enum machine_mode mode;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   if (REG_P (op) || CONSTANT_P (op))\n     return 1;\n@@ -2709,7 +2748,7 @@ not_modify_reg (op, mode)\n int\n not_rc_reg (op, mode)\n      rtx op;\n-     enum machine_mode mode;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   if (REG_P (op) && REGNO (op) == RC_REGNO)\n     return 0;\n@@ -2826,7 +2865,7 @@ index_reg_operand (op, mode)\n int\n dp_reg_operand (op, mode)\n      rtx op;\n-     enum machine_mode mode;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   return REG_P (op) && IS_DP_OR_PSEUDO_REGNO (op);\n }\n@@ -2837,7 +2876,7 @@ dp_reg_operand (op, mode)\n int\n sp_reg_operand (op, mode)\n      rtx op;\n-     enum machine_mode mode;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   return REG_P (op) && IS_SP_OR_PSEUDO_REGNO (op);\n }\n@@ -2848,16 +2887,27 @@ sp_reg_operand (op, mode)\n int\n st_reg_operand (op, mode)\n      register rtx op;\n-     enum machine_mode mode;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   return REG_P (op) && IS_ST_OR_PSEUDO_REGNO (op);\n }\n \n \n+/* RC register.  */\n+\n+int\n+rc_reg_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n+{\n+  return REG_P (op) && IS_RC_OR_PSEUDO_REGNO (op);\n+}\n+\n+\n int\n call_operand (op, mode)\n      rtx op;\n-     enum machine_mode mode;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   if (GET_CODE (op) != MEM)\n     return 0;\n@@ -3197,7 +3247,7 @@ c4x_label_conflict (insn, jump, db)\n int\n valid_parallel_operands_4 (operands, mode)\n      rtx *operands;\n-     enum machine_mode mode;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   rtx op0 = operands[0];\n   rtx op1 = operands[1];\n@@ -3246,7 +3296,7 @@ valid_parallel_operands_4 (operands, mode)\n int\n valid_parallel_operands_5 (operands, mode)\n      rtx *operands;\n-     enum machine_mode mode;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   int regs = 0;\n   rtx op0 = operands[1];\n@@ -3272,7 +3322,7 @@ valid_parallel_operands_5 (operands, mode)\n int\n valid_parallel_operands_6 (operands, mode)\n      rtx *operands;\n-     enum machine_mode mode;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   int regs = 0;\n   rtx op0 = operands[1];\n@@ -3544,7 +3594,7 @@ legitimize_operands (code, operands, mode)\n      a positive count, so we emit a NEG.  */\n   if ((code == ASHIFTRT || code == LSHIFTRT)\n       && (GET_CODE (operands[2]) != CONST_INT))\n-    operands[2] = gen_rtx (NEG, mode, negate_rtx (mode, operands[2]));\n+    operands[2] = gen_rtx_NEG (mode, negate_rtx (mode, operands[2]));\n   \n   return 1;\n }\n@@ -3882,7 +3932,7 @@ c4x_operand_subword (op, i, validate_address, mode)\n \t    mode = QImode;\n \t  else if (mode == HFmode)\n \t    mode = QFmode;\n-\t  return gen_rtx (MEM, mode, XEXP (op, 0));\n+\t  return gen_rtx_MEM (mode, XEXP (op, 0));\n \t  \n \tcase POST_DEC:\n \tcase PRE_DEC:\n@@ -3921,7 +3971,7 @@ c4x_operand_subword (op, i, validate_address, mode)\n int\n c4x_handle_pragma (p_getc, p_ungetc, pname)\n      int (*  p_getc) PROTO ((void));\n-     void (* p_ungetc) PROTO ((int));\n+     void (* p_ungetc) PROTO ((int)) ATTRIBUTE_UNUSED;\n      char *pname;\n {\n   int i;\n@@ -3987,7 +4037,6 @@ c4x_handle_pragma (p_getc, p_ungetc, pname)\n         }\n       name[i] = 0;\n       sect = build_string (i, name);\n-      TREE_TYPE (sect) = char_array_type_node;\n       free (name);\n       sect = build_tree_list (NULL_TREE, sect);\n       \n@@ -4083,9 +4132,9 @@ c4x_set_default_attributes(decl, attributes)\n int\n c4x_valid_type_attribute_p (type, attributes, identifier, args)\n      tree type;\n-     tree attributes;\n+     tree attributes ATTRIBUTE_UNUSED;\n      tree identifier;\n-     tree args;\n+     tree args ATTRIBUTE_UNUSED;\n {\n   if (TREE_CODE (type) != FUNCTION_TYPE)\n     return 0;\n@@ -4295,7 +4344,7 @@ c4x_parallel_pack (insn1, insn2, depend)\n \treturn 0;\n     }\n \n-  pack = gen_rtx (PARALLEL, VOIDmode, gen_rtvec (2, set1, set2));\n+  pack = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, set1, set2));\n   num_clobbers = 0;\n   if ((insn_code_number = recog (pack, pack, &num_clobbers)) < 0)\n     return 0;\n@@ -4305,8 +4354,8 @@ c4x_parallel_pack (insn1, insn2, depend)\n       rtx newpack;\n       int i;\n \n-      newpack = gen_rtx (PARALLEL, VOIDmode,\n-\t\t\t gen_rtvec (GET_CODE (pack) == PARALLEL\n+      newpack = gen_rtx_PARALLEL (VOIDmode,\n+\t\t\t\t  gen_rtvec (GET_CODE (pack) == PARALLEL\n \t\t\t\t    ? XVECLEN (pack, 0) + num_clobbers\n \t\t\t\t    : num_clobbers + 1));\n \n@@ -4471,10 +4520,10 @@ c4x_copy_insn_after(insn, prev, bb)\n \n   /* Copy the REG_NOTES from insn to the new insn.  */\n   for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n-    REG_NOTES (new) = gen_rtx (GET_CODE (note), \n-\t\t\t\t REG_NOTE_KIND (note),\n-\t\t\t\t XEXP (note, 0),\n-\t\t\t\t REG_NOTES (new));\n+    REG_NOTES (new) = gen_rtx (GET_CODE (note),\n+\t\t\t       REG_NOTE_KIND (note),\n+\t\t\t       XEXP (note, 0),\n+\t\t\t       REG_NOTES (new));\n \n   /* Handle all the registers within insn and update the reg info.  */\n   c4x_update_info_regs (PATTERN (insn), bb);\n@@ -4529,7 +4578,7 @@ c4x_merge_notes(insn, insn2)\n \t  remove_note (insn, note);\n     }\n   for (note = REG_NOTES (insn2); note; note = XEXP (note, 1))\n-    REG_NOTES (insn) = gen_rtx (GET_CODE (note), \n+    REG_NOTES (insn) = gen_rtx (GET_CODE (note),\n \t\t\t\tREG_NOTE_KIND (note),\n \t\t\t\tXEXP (note, 0),\n \t\t\t\tREG_NOTES (insn));\n@@ -4736,25 +4785,25 @@ c4x_parallel_process (loop_start, loop_end)\n \t\t{\n \t\t  /* The loop count must be more than 1 surely?  */\n \t\t  SET_SRC (loop_count_set) \n-\t\t    = gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t       INTVAL (SET_SRC (loop_count_set)) -1);\n+\t\t    = gen_rtx_CONST_INT (VOIDmode,\n+\t\t\t\t\t INTVAL (SET_SRC (loop_count_set)) -1);\n \t\t}\n \t      else if (GET_CODE (SET_SRC (loop_count_set)) == PLUS\n \t\t       && GET_CODE (XEXP (SET_SRC (loop_count_set), 1))\n \t\t       == CONST_INT)\n \t\t{\n \t\t  XEXP (SET_SRC (loop_count_set), 1)\n-\t\t    = gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t       INTVAL (XEXP (SET_SRC (loop_count_set), 1))\n-\t\t\t       - 1);\n+\t\t    = gen_rtx_CONST_INT (VOIDmode,\n+\t\t\t\t    INTVAL (XEXP (SET_SRC (loop_count_set), 1))\n+\t\t\t\t\t - 1);\n \t\t}\n \t      else\n \t\t{\n \t\t  start_sequence ();\n \t\t  expand_binop (QImode, sub_optab,\n-\t\t\t\tgen_rtx (REG, QImode, RC_REGNO),\n-\t\t\t\tgen_rtx (CONST_INT, VOIDmode, 1),\n-\t\t\t\tgen_rtx (REG, QImode, RC_REGNO),\n+\t\t\t\tgen_rtx_REG (QImode, RC_REGNO),\n+\t\t\t\tgen_rtx_CONST_INT (VOIDmode, 1),\n+\t\t\t\tgen_rtx_REG (QImode, RC_REGNO),\n \t\t\t\t1, OPTAB_DIRECT);\n \t\t  seq_start = get_insns ();\n \t\t  end_sequence ();\n@@ -4763,13 +4812,13 @@ c4x_parallel_process (loop_start, loop_end)\n \t\t  /* Check this.  What if we emit more than one insn?\n \t\t     Can we emit more than one insn? */\n \t\t  REG_NOTES (seq_start)\n-\t\t    = gen_rtx (EXPR_LIST, REG_UNUSED,\n-\t\t\t       gen_rtx (REG, QImode, RC_REGNO),\n+\t\t    = gen_rtx_EXPR_LIST (REG_UNUSED,\n+\t\t\t       gen_rtx_REG (QImode, RC_REGNO),\n \t\t\t       REG_NOTES (seq_start));\n \t\t}\n \n \t      start_sequence ();\n-\t      emit_cmp_insn (gen_rtx (REG, QImode, RC_REGNO),\n+\t      emit_cmp_insn (gen_rtx_REG (QImode, RC_REGNO),\n \t\t\t     const0_rtx, LT, NULL_RTX, QImode, 0, 0);\n \t      emit_jump_insn (gen_blt (end_label));\n \t      seq_start = get_insns ();\n@@ -4778,8 +4827,8 @@ c4x_parallel_process (loop_start, loop_end)\n \t      \n \t      /* This is a bit of a hack... */\n \t      REG_NOTES (NEXT_INSN (seq_start))\n-\t\t= gen_rtx (EXPR_LIST, REG_DEAD,\n-\t\t\t   gen_rtx (REG, QImode, RC_REGNO),\n+\t\t= gen_rtx_EXPR_LIST (REG_DEAD,\n+\t\t\t   gen_rtx_REG (QImode, RC_REGNO),\n \t\t\t   REG_NOTES (NEXT_INSN (seq_start)));\n \n \t      if (TARGET_DEVEL)\n@@ -4804,7 +4853,7 @@ c4x_parallel_process (loop_start, loop_end)\n \n static void\n c4x_combine_parallel_independent (insns)\n-     rtx insns;\n+     rtx insns ATTRIBUTE_UNUSED;\n {\n   /* Combine independent insns like\n      (set (mem (reg 0)) (reg 1))\n@@ -5182,7 +5231,7 @@ c4x_rptb_loop_info_get (loop_start, loop_end, loop_info)\n     }\n \n   loop_info->off_by_one = (cc == LT || cc == LTU || cc == GT || cc == GTU);\n-  loop_info->unsigned_p |= (cc == LTU || cc == LEU || cc == GTU || cc == GEU);\n+\n \n   /* We have a switch to allow an unsigned loop counter.\n      We'll normally disallow this case since the the repeat\n@@ -5209,7 +5258,7 @@ c4x_rptb_emit_init (loop_info)\n \n   /* If have a known constant loop count, things are easy...  */\n   if (loop_info->loop_count > 0)\n-    return gen_rtx (CONST_INT, VOIDmode, loop_info->loop_count - 1);\n+    return gen_rtx_CONST_INT (VOIDmode, loop_info->loop_count - 1);\n \n   if (loop_info->shift < 0)\n     abort ();\n@@ -5239,14 +5288,14 @@ c4x_rptb_emit_init (loop_info)\n       /* (end_value - start_value + adjust) >> shift */\n       result = expand_binop (QImode, loop_info->unsigned_p ?\n \t\t\t     lshr_optab : ashr_optab, result,\n-\t\t\t     gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t     gen_rtx_CONST_INT (VOIDmode,\n \t\t\t\t      loop_info->shift),\n \t\t\t     0, loop_info->unsigned_p, OPTAB_DIRECT);\n     }\n \n   /* ((end_value - start_value + adjust) >> shift) - 1 */\n   result = expand_binop (QImode, sub_optab,\n-\t\t\t result, gen_rtx (CONST_INT, VOIDmode, 1),\n+\t\t\t result, gen_rtx_CONST_INT (VOIDmode, 1),\n \t\t\t 0, loop_info->unsigned_p, OPTAB_DIRECT);\n \n   seq_start = get_insns ();\n@@ -5326,9 +5375,9 @@ c4x_rptb_process (loop_start, loop_end)\n \n       bypass_label = NEXT_INSN (loop_end);\n #if 0\n-      forced_labels = gen_rtx (EXPR_LIST, VOIDmode,\n+      forced_labels = gen_rtx_EXPR_LIST (VOIDmode,\n \t\t\t       end_label, forced_labels);\n-      forced_labels = gen_rtx (EXPR_LIST, VOIDmode,\n+      forced_labels = gen_rtx_EXPR_LIST (VOIDmode,\n \t\t\t       bypass_label, forced_labels);\n #endif\n       emit_insn_after (gen_repeat_block_filler (), end_label);\n@@ -5363,6 +5412,7 @@ c4x_rptb_process (loop_start, loop_end)\n }\n \n \n+/* !!! FIXME to emit RPTS correctly.  */\n int\n c4x_rptb_rpts_p (insn, op)\n      rtx insn, op;"}, {"sha": "d68427d326131174019c9f7e1290ea1fadff7357", "filename": "gcc/config/c4x/c4x.h", "status": "modified", "additions": 25, "deletions": 7, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e4ff48146169795c31246ac5547df56bd799a8/gcc%2Fconfig%2Fc4x%2Fc4x.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e4ff48146169795c31246ac5547df56bd799a8/gcc%2Fconfig%2Fc4x%2Fc4x.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.h?ref=d5e4ff48146169795c31246ac5547df56bd799a8", "patch": "@@ -300,6 +300,9 @@ extern char *c4x_rpts_cycles_string, *c4x_cpu_version_string;\n extern void c4x_override_options ();\n #define OVERRIDE_OPTIONS c4x_override_options ()\n \n+/* Define this to change the optimizations performed by default.  */\n+extern void c4x_optimization_options ();\n+#define OPTIMIZATION_OPTIONS(LEVEL,SIZE) c4x_optimization_options(LEVEL,SIZE)\n \n /* Run Time Target Specification  */\n \n@@ -431,6 +434,7 @@ extern void c4x_override_options ();\n /* Misc registers */\n \n #define IS_ST_REG(r)     ((r) == ST_REGNO)\n+#define IS_RC_REG(r)     ((r) == RC_REGNO)\n #define IS_REPEAT_REG(r) (((r) >= RS_REGNO) && ((r) <= RC_REGNO))\n \n /* Composite register sets */\n@@ -455,6 +459,7 @@ extern void c4x_override_options ();\n #define IS_DP_OR_PSEUDO_REG(r)      (IS_DP_REG(r) || IS_PSEUDO_REG(r))\n #define IS_SP_OR_PSEUDO_REG(r)      (IS_SP_REG(r) || IS_PSEUDO_REG(r))\n #define IS_ST_OR_PSEUDO_REG(r)      (IS_ST_REG(r) || IS_PSEUDO_REG(r))\n+#define IS_RC_OR_PSEUDO_REG(r)      (IS_RC_REG(r) || IS_PSEUDO_REG(r))\n \n #define IS_PSEUDO_REGNO(op)          (IS_PSEUDO_REG(REGNO(op)))\n #define IS_ADDR_REGNO(op)            (IS_ADDR_REG(REGNO(op)))\n@@ -473,6 +478,7 @@ extern void c4x_override_options ();\n #define IS_DP_OR_PSEUDO_REGNO(op)    (IS_DP_OR_PSEUDO_REG(REGNO(op)))\n #define IS_SP_OR_PSEUDO_REGNO(op)    (IS_SP_OR_PSEUDO_REG(REGNO(op)))\n #define IS_ST_OR_PSEUDO_REGNO(op)    (IS_ST_OR_PSEUDO_REG(REGNO(op)))\n+#define IS_RC_OR_PSEUDO_REGNO(op)    (IS_RC_OR_PSEUDO_REG(REGNO(op)))\n \n /* 1 for registers that have pervasive standard uses\n    and are not available for the register allocator. */\n@@ -628,8 +634,9 @@ enum reg_class\n     EXT_REGS,\t\t\t/* 'f' */\n     ADDR_REGS,\t\t\t/* 'a' */\n     INDEX_REGS,\t\t\t/* 'x' */\n-    SP_REG,\t\t\t/* 'b' */\n     BK_REG,\t\t\t/* 'k' */\n+    SP_REG,\t\t\t/* 'b' */\n+    RC_REG,\t\t\t/* 'v' */\n     INT_REGS,\t\t\t/* 'c' */\n     GENERAL_REGS,\t\t/* 'r' */\n     DP_REG,\t\t\t/* 'z' */\n@@ -649,14 +656,15 @@ enum reg_class\n    \"EXT_REGS\",\t\t\\\n    \"ADDR_REGS\",\t\t\\\n    \"INDEX_REGS\",\t\\\n-   \"SP_REG\",\t\t\\\n    \"BK_REG\",\t\t\\\n+   \"SP_REG\",\t\t\\\n+   \"RC_REG\",\t\t\\\n    \"INT_REGS\",\t\t\\\n    \"GENERAL_REGS\",\t\\\n    \"DP_REG\",\t\t\\\n    \"ST_REG\",\t\t\\\n    \"ALL_REGS\"\t\t\\\n-};\n+}\n \n /* Define which registers fit in which classes.\n    This is an initializer for a vector of HARD_REG_SET\n@@ -672,8 +680,9 @@ enum reg_class\n  0xf00000ff, /* 'f' R0-R11       */\t\t\\\n  0x0000ff00, /* 'a' AR0-AR7 */\t\t\t\\\n  0x00060000, /* 'x' IR0-IR1 */\t\t\t\\\n- 0x00100000, /* 'b' SP */\t\t\t\\\n  0x00080000, /* 'k' BK */\t\t\t\\\n+ 0x00100000, /* 'b' SP */\t\t\t\\\n+ 0x08000000, /* 'v' RC */\t\t\t\\\n  0x0e1eff00, /* 'c' AR0-AR7, IR0-IR1, RC, RS, RE, BK, SP */\t\\\n  0xfe1effff, /* 'r' R0-R11, AR0-AR7, IR0-IR1, RC, RS, RE, BK, SP */\\\n  0x00010000, /* 'z' DP */\t\t\t\\\n@@ -723,6 +732,7 @@ spill registers.  */\n   q - r0-r7\n   t - r0-r1\n   u - r2-r3\n+  v - repeat count (rc)\n   x - index register (ir0-ir1)\n   y - status register (st)\n   z - dp reg (dp) \n@@ -756,6 +766,7 @@ spill registers.  */\n      : ((CC) == 'q') ? EXT_LOW_REGS\t\t\t\t\\\n      : ((CC) == 't') ? R0R1_REGS\t\t\t\t\\\n      : ((CC) == 'u') ? R2R3_REGS\t\t\t\t\\\n+     : ((CC) == 'v') ? RC_REG\t\t\t\t\t\\\n      : ((CC) == 'x') ? INDEX_REGS\t\t\t\t\\\n      : ((CC) == 'y') ? ST_REG\t\t\t\t\t\\\n      : ((CC) == 'z') ? DP_REG\t\t\t\t\t\\\n@@ -1604,8 +1615,8 @@ extern struct rtx_def *c4x_legitimize_address ();\n    LABEL_REF, SYMBOL_REF, CONST, and HIGH codes.  */\n \n #define LEGITIMATE_CONSTANT_P(X)\t\t\t\t\\\n-  (GET_CODE (X) == CONST_DOUBLE && c4x_H_constant (X)\t\t\\\n-  || GET_CODE (X) == CONST_INT && c4x_I_constant (X))\n+  ((GET_CODE (X) == CONST_DOUBLE && c4x_H_constant (X))\t\t\\\n+  || (GET_CODE (X) == CONST_INT && c4x_I_constant (X)))\n \n \n #define LEGITIMATE_DISPLACEMENT_P(X) IS_DISP8_CONST (INTVAL (X))\n@@ -1774,7 +1785,7 @@ do {\t\t\t\t\t\t\t\t\\\n } while (0)\n \n /* The TI tooling uses atexit. */\n-#define\tON_EXIT(FUNC,ARG)\tatexit (FUNC)\n+#define\tHAVE_ATEXIT\n \n #undef EXTRA_SECTIONS\n #define EXTRA_SECTIONS in_const, in_init, in_fini, in_ctors, in_dtors\n@@ -2475,6 +2486,7 @@ extern void c4x_rptb_process ();\n   {\"dp_reg_operand\", {REG}},\t\t\t\t\t\\\n   {\"sp_reg_operand\", {REG}},\t\t\t\t\t\\\n   {\"st_reg_operand\", {REG}},\t\t\t\t\t\\\n+  {\"rc_reg_operand\", {REG}},\t\t\t\t\t\\\n   {\"call_operand\", {REG, SYMBOL_REF}},\t\t\t\t\\\n   {\"src_operand\", {SUBREG, REG, MEM, CONST_INT, CONST_DOUBLE}}, \\\n   {\"src_hi_operand\", {SUBREG, REG, MEM, CONST_DOUBLE}}, \t\\\n@@ -2535,6 +2547,10 @@ extern int stik_const_operand ();\n \n extern int not_const_operand ();\n \n+extern int parallel_operand ();\n+\n+extern int reg_or_const_operand ();\n+\n extern int reg_operand ();\n \n extern int reg_imm_operand ();\n@@ -2551,6 +2567,8 @@ extern int std_reg_operand ();\n \n extern int src_operand ();\n \n+extern int src_hi_operand ();\n+\n extern int lsrc_operand ();\n \n extern int tsrc_operand ();"}, {"sha": "ccccdeb12d97f08732671a600464e00d32ec5f03", "filename": "gcc/config/c4x/c4x.md", "status": "modified", "additions": 64, "deletions": 34, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e4ff48146169795c31246ac5547df56bd799a8/gcc%2Fconfig%2Fc4x%2Fc4x.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e4ff48146169795c31246ac5547df56bd799a8/gcc%2Fconfig%2Fc4x%2Fc4x.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.md?ref=d5e4ff48146169795c31246ac5547df56bd799a8", "patch": "@@ -1134,8 +1134,8 @@\n \n    if (!TARGET_C3X && which_alternative == 3)\n      {\n-       operands[1] = gen_rtx (CONST_INT, VOIDmode,\n-                              (INTVAL (operands[1]) >> 16) & 0xffff);\n+       operands[1] = gen_rtx_CONST_INT (VOIDmode, \n+                                        (INTVAL (operands[1]) >> 16) & 0xffff);\n        return \\\"ldhi\\\\t%1,%0\\\";\n      }\n \n@@ -2639,10 +2639,10 @@\n   \"*\n    if (INTVAL (operands[2]) == 8)\n      {\n-       operands[3] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[3]) / 8);\n+       operands[3] = gen_rtx_CONST_INT (VOIDmode, INTVAL (operands[3]) / 8);\n        return \\\"lb%3\\\\t%1,%0\\\";\n      }\n-   operands[3] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[3]) / 16);\n+   operands[3] = gen_rtx_CONST_INT (VOIDmode, INTVAL (operands[3]) / 16);\n    return \\\"lh%3\\\\t%1,%0\\\";\n   \"\n   [(set_attr \"type\" \"binarycc,binary\")\n@@ -2661,10 +2661,10 @@\n   \"*\n    if (INTVAL (operands[2]) == 8)\n      {\n-       operands[3] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[3]) / 8);\n+       operands[3] = gen_rtx_CONST_INT (VOIDmode, INTVAL (operands[3]) / 8);\n        return \\\"lb%3\\\\t%1,%0\\\";\n      }\n-   operands[3] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[3]) / 16);\n+   operands[3] = gen_rtx_CONST_INT (VOIDmode, INTVAL (operands[3]) / 16);\n    return \\\"lh%3\\\\t%1,%0\\\";\n   \"\n   [(set_attr \"type\" \"binarycc\")\n@@ -2686,10 +2686,10 @@\n   \"*\n    if (INTVAL (operands[2]) == 8)\n      {\n-       operands[3] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[3]) / 8);\n+       operands[3] = gen_rtx_CONST_INT (VOIDmode, INTVAL (operands[3]) / 8);\n        return \\\"lb%3\\\\t%1,%0\\\";\n      }\n-   operands[3] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[3]) / 16);\n+   operands[3] = gen_rtx_CONST_INT (VOIDmode, INTVAL (operands[3]) / 16);\n    return \\\"lh%3\\\\t%1,%0\\\";\n   \"\n   [(set_attr \"type\" \"binarycc\")\n@@ -2722,10 +2722,10 @@\n   \"*\n    if (INTVAL (operands[2]) == 8)\n      {\n-       operands[3] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[3]) / 8);\n+       operands[3] = gen_rtx_CONST_INT (VOIDmode, INTVAL (operands[3]) / 8);\n        return \\\"lbu%3\\\\t%1,%0\\\";\n      }\n-   operands[3] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[3]) / 16);\n+   operands[3] = gen_rtx_CONST_INT (VOIDmode, INTVAL (operands[3]) / 16);\n    return \\\"lhu%3\\\\t%1,%0\\\";\n   \"\n   [(set_attr \"type\" \"binarycc,binary\")\n@@ -2744,10 +2744,10 @@\n   \"*\n    if (INTVAL (operands[2]) == 8)\n      {\n-       operands[3] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[3]) / 8);\n+       operands[3] = gen_rtx_CONST_INT (VOIDmode, INTVAL (operands[3]) / 8);\n        return \\\"lbu%3\\\\t%1,%0\\\";\n      }\n-   operands[3] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[3]) / 16);\n+   operands[3] = gen_rtx_CONST_INT (VOIDmode, INTVAL (operands[3]) / 16);\n    return \\\"lhu%3\\\\t%1,%0\\\";\n   \"\n   [(set_attr \"type\" \"binarycc\")\n@@ -2769,10 +2769,10 @@\n   \"*\n    if (INTVAL (operands[2]) == 8)\n      {\n-       operands[3] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[3]) / 8);\n+       operands[3] = gen_rtx_CONST_INT (VOIDmode, INTVAL (operands[3]) / 8);\n        return \\\"lbu%3\\\\t%1,%0\\\";\n      }\n-   operands[3] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[3]) / 16);\n+   operands[3] = gen_rtx_CONST_INT (VOIDmode, INTVAL (operands[3]) / 16);\n    return \\\"lhu%3\\\\t%1,%0\\\";\n   \"\n   [(set_attr \"type\" \"binarycc\")\n@@ -2807,12 +2807,12 @@\n   \"*\n    if (INTVAL (operands[1]) == 8)\n      {\n-       operands[2] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[2]) / 8);\n+       operands[2] = gen_rtx_CONST_INT (VOIDmode, INTVAL (operands[2]) / 8);\n        return \\\"mb%2\\\\t%3,%0\\\";\n      }\n    else if (INTVAL (operands[1]) == 16)\n      {\n-       operands[2] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[2]) / 16);\n+       operands[2] = gen_rtx_CONST_INT (VOIDmode, INTVAL (operands[2]) / 16);\n        return \\\"mh%2\\\\t%3,%0\\\";\n      }\n    return \\\"lwl1\\\\t%3,%0\\\";\n@@ -2834,10 +2834,10 @@\n   \"*\n    if (INTVAL (operands[1]) == 8)\n      {\n-       operands[2] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[2]) / 8);\n+       operands[2] = gen_rtx_CONST_INT (VOIDmode, INTVAL (operands[2]) / 8);\n        return \\\"mb%2\\\\t%3,%0\\\";\n      }\n-   operands[2] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[2]) / 16);\n+   operands[2] = gen_rtx_CONST_INT (VOIDmode, INTVAL (operands[2]) / 16);\n    return \\\"mh%2\\\\t%3,%0\\\";\n   \"\n   [(set_attr \"type\" \"binarycc\")\n@@ -3555,8 +3555,8 @@\n     enum rtx_code code = GET_CODE (operands[1]);\n     rtx ccreg = c4x_gen_compare_reg (code, c4x_compare_op0, c4x_compare_op1);\n     if (ccreg == NULL_RTX) FAIL;\n-    emit_insn (gen_rtx (SET, QImode, operands[0],\n-                        gen_rtx (IF_THEN_ELSE, QImode,\n+    emit_insn (gen_rtx_SET (QImode, operands[0],\n+                            gen_rtx_IF_THEN_ELSE (QImode,\n                                  gen_rtx (code, VOIDmode, ccreg, const0_rtx),\n                                           operands[2], operands[3])));\n     DONE;}\")\n@@ -3598,8 +3598,8 @@\n     enum rtx_code code = GET_CODE (operands[1]);\n     rtx ccreg = c4x_gen_compare_reg (code, c4x_compare_op0, c4x_compare_op1);\n     if (ccreg == NULL_RTX) FAIL;\n-    emit_insn (gen_rtx (SET, QFmode, operands[0],\n-                        gen_rtx (IF_THEN_ELSE, QFmode,\n+    emit_insn (gen_rtx_SET (QFmode, operands[0],\n+                            gen_rtx_IF_THEN_ELSE (QFmode,\n                                  gen_rtx (code, VOIDmode, ccreg, const0_rtx),\n                                           operands[2], operands[3])));\n     DONE;}\")\n@@ -4294,7 +4294,7 @@\n        else\n          return \\\"call\\\\t%C0\\\";\n      }\n-   if (which_alternative == 1)\n+   else\n      {\n        if (final_sequence)\n          return \\\"laju\\\\t%R0\\\";\n@@ -4341,7 +4341,7 @@\n        else\n          return \\\"call\\\\t%C1\\\";\n      }\n-   if (which_alternative == 1)\n+   else\n      {\n        if (final_sequence)\n          return \\\"laju\\\\t%R1\\\";\n@@ -4523,6 +4523,8 @@\n \n ; operand 0 is the loop depth\n ; operand 1 is the loop count\n+; operand 2 is the start label\n+; operand 3 is the end label\n (define_expand \"repeat_block_top\"\n   [(set (reg:QI 27) (match_operand:QI 1 \"src_operand\" \"\"))\n    (use (match_operand:QI 0 \"immediate_operand\" \"\"))\n@@ -4560,6 +4562,36 @@\n   [(set_attr \"type\" \"repeat\")])\n \n \n+(define_insn \"rptb_end\"\n+  [(set (pc)\n+        (if_then_else (ne (match_operand:QI 0 \"rc_reg_operand\" \"v\")\n+                          (const_int 0))\n+                      (label_ref (match_operand 1 \"\" \"\"))\n+                      (pc)))\n+   (use (reg:QI 25))\n+   (use (reg:QI 26))\n+   (set (match_dup 0)\n+        (plus:QI (match_dup 0)\n+                 (const_int -1)))]\n+  \"\"\n+  \"*\n+   return c4x_rptb_nop_p(insn) ? \\\"nop\\\" : \\\"\\\";\"\n+  [(set_attr \"type\" \"repeat\")])\n+\n+\n+(define_expand \"decrement_and_branch_on_count\"\n+  [(parallel [(set (pc)\n+                   (if_then_else (ne (match_operand:QI 0 \"rc_reg_operand\" \"v\")\n+                                     (const_int 0))\n+                                 (label_ref (match_operand 1 \"\" \"\"))\n+                                 (pc)))\n+              (use (reg:QI 25))\n+              (use (reg:QI 26))\n+              (set (match_dup 0) (plus:QI (match_dup 0) (const_int -1)))])]\n+  \"\"\n+  \"\")\n+\n+\n (define_expand \"movstrqi_small2\"\n   [(parallel [(set (mem:BLK (match_operand:BLK 0 \"src_operand\" \"\"))\n                    (mem:BLK (match_operand:BLK 1 \"src_operand\" \"\")))\n@@ -4579,8 +4611,8 @@\n     len = INTVAL (operands[2]);\n     tmp = operands[4];\n \n-    src_mem = gen_rtx (MEM, QImode, src);\n-    dst_mem = gen_rtx (MEM, QImode, dst);\n+    src_mem = gen_rtx_MEM (QImode, src);\n+    dst_mem = gen_rtx_MEM (QImode, dst);\n \n     emit_insn (gen_movqi (tmp, src_mem));\t\n     emit_insn (gen_addqi3_noclobber (src, src, const1_rtx));\t\n@@ -4719,6 +4751,7 @@\n     output_asm_insn (\\\"ldi\\\\t%3-1,%5\\\", operands);\n     output_asm_insn (\\\"$1:\\tsubi3\\\\t*%1++,*%2++,%0\\\", operands);\n     output_asm_insn (\\\"dbeq\\\\t%5,$1\\\", operands);\n+    return \\\"\\\";\n  }\")\n \n (define_expand \"cmpstrqi\"\n@@ -5698,8 +5731,7 @@\n        rtx op0hi = operand_subword (operands[0], 1, 0, HImode);\n        rtx op0lo = operand_subword (operands[0], 0, 0, HImode);\n        rtx op1lo = operand_subword (operands[1], 0, 0, HImode);\n-       rtx count = gen_rtx (CONST_INT, VOIDmode, \n-                            (INTVAL (operands[2]) - 32));\n+       rtx count = gen_rtx_CONST_INT (VOIDmode, (INTVAL (operands[2]) - 32));\n \n        if (INTVAL (count))\n          emit_insn (gen_ashlqi3 (op0hi, op1lo, count));\n@@ -5761,8 +5793,7 @@\n        rtx op0hi = operand_subword (operands[0], 1, 0, HImode);\n        rtx op0lo = operand_subword (operands[0], 0, 0, HImode);\n        rtx op1hi = operand_subword (operands[1], 1, 0, HImode);\n-       rtx count = gen_rtx (CONST_INT, VOIDmode, \n-                            (INTVAL (operands[2]) - 32));\n+       rtx count = gen_rtx_CONST_INT (VOIDmode, (INTVAL (operands[2]) - 32));\n \n        if (INTVAL (count))\n          emit_insn (gen_lshrqi3 (op0lo, op1hi, count));\n@@ -5830,15 +5861,14 @@\n        rtx op0hi = operand_subword (operands[0], 1, 0, HImode);\n        rtx op0lo = operand_subword (operands[0], 0, 0, HImode);\n        rtx op1hi = operand_subword (operands[1], 1, 0, HImode);\n-       rtx count = gen_rtx (CONST_INT, VOIDmode, \n-                            (INTVAL (operands[2]) - 32));\n+       rtx count = gen_rtx_CONST_INT (VOIDmode, (INTVAL (operands[2]) - 32));\n \n        if (INTVAL (count))\n          emit_insn (gen_ashrqi3 (op0lo, op1hi, count));\n        else\n          emit_insn (gen_movqi (op0lo, op1hi));\n-       emit_insn (gen_ashrqi3 (op0hi, op1hi, gen_rtx (CONST_INT,\n-                                                      VOIDmode, 31)));\n+       emit_insn (gen_ashrqi3 (op0hi, op1hi, \n+                               gen_rtx_CONST_INT (VOIDmode, 31)));\n        DONE;\n     }\n     emit_insn (gen_ashrhi3_reg (operands[0], operands[1], operands[2]));"}, {"sha": "1a16b90444c82f24c2e9486a2b4c5a8024d4265a", "filename": "gcc/config/c4x/t-c4x", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e4ff48146169795c31246ac5547df56bd799a8/gcc%2Fconfig%2Fc4x%2Ft-c4x", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e4ff48146169795c31246ac5547df56bd799a8/gcc%2Fconfig%2Fc4x%2Ft-c4x", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Ft-c4x?ref=d5e4ff48146169795c31246ac5547df56bd799a8", "patch": "@@ -21,9 +21,6 @@ INSTALL_LIBGCC = install-multilib\n # Don't make libgcc1-test since require crt0.o\n LIBGCC1_TEST =\n \n-# Don't make objective C because we can't compile the libraries.\n-LANGUAGES = c proto  c++\n-\n # C[34]x has its own float and limits.h\n TARGET_FLOAT_H=config/c4x/c4x-float.h\n TARGET_LIMITS_H=config/c4x/c4x-limits.h"}]}