{"sha": "419677348e1c1e6092e74f55b3a7326a595d6114", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDE5Njc3MzQ4ZTFjMWU2MDkyZTc0ZjU1YjNhNzMyNmE1OTVkNjExNA==", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-01-29T17:15:14Z"}, "committer": {"name": "Philip Herron", "email": "herron.philip@googlemail.com", "date": "2021-02-03T10:38:13Z"}, "message": "Add support for impl blocks for functions and constants.\n\nThis is the building block in adding support for methods and the self\nkeyword.\n\nFixes: #111", "tree": {"sha": "ff230e7c4ae08febd95e2f77d8313cf68da23db4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff230e7c4ae08febd95e2f77d8313cf68da23db4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/419677348e1c1e6092e74f55b3a7326a595d6114", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/419677348e1c1e6092e74f55b3a7326a595d6114", "html_url": "https://github.com/Rust-GCC/gccrs/commit/419677348e1c1e6092e74f55b3a7326a595d6114", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/419677348e1c1e6092e74f55b3a7326a595d6114/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "36ac7b79717b580a9adbbb07383d17fe6d63be2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36ac7b79717b580a9adbbb07383d17fe6d63be2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36ac7b79717b580a9adbbb07383d17fe6d63be2f"}], "stats": {"total": 1226, "additions": 993, "deletions": 233}, "files": [{"sha": "392c36aeced3b4d144388e2ee9911575a66d4cf6", "filename": "gcc/rust/ast/rust-ast.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.h?ref=419677348e1c1e6092e74f55b3a7326a595d6114", "patch": "@@ -1333,6 +1333,8 @@ class InherentImplItem\n \n   virtual void mark_for_strip () = 0;\n   virtual bool is_marked_for_strip () const = 0;\n+\n+  virtual Location get_locus_slow () const = 0;\n };\n \n // Abstract base class for items used in a trait impl\n@@ -1459,6 +1461,10 @@ class MacroInvocationSemi : public MacroItem,\n   const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n   std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n \n+  Location get_locus () const { return locus; }\n+\n+  Location get_locus_slow () const override { return get_locus (); }\n+\n protected:\n   MacroInvocationSemi *clone_macro_invocation_semi_impl () const\n   {"}, {"sha": "ecfc310c6fb4649f9e2448cd9df54260d38111dc", "filename": "gcc/rust/ast/rust-item.h", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Fast%2Frust-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Fast%2Frust-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-item.h?ref=419677348e1c1e6092e74f55b3a7326a595d6114", "patch": "@@ -698,6 +698,8 @@ class Method : public InherentImplItem, public TraitImplItem\n \n   Location locus;\n \n+  NodeId node_id;\n+\n public:\n   // Returns whether the method is in an error state.\n   bool is_error () const\n@@ -746,7 +748,8 @@ class Method : public InherentImplItem, public TraitImplItem\n       function_params (std::move (function_params)),\n       return_type (std::move (return_type)),\n       where_clause (std::move (where_clause)),\n-      function_body (std::move (function_body)), locus (locus)\n+      function_body (std::move (function_body)), locus (locus),\n+      node_id (Analysis::Mappings::get ()->get_next_node_id ())\n   {}\n \n   // TODO: add constructor with less fields\n@@ -769,6 +772,8 @@ class Method : public InherentImplItem, public TraitImplItem\n     generic_params.reserve (other.generic_params.size ());\n     for (const auto &e : other.generic_params)\n       generic_params.push_back (e->clone_generic_param ());\n+\n+    node_id = other.node_id;\n   }\n \n   // Overloaded assignment operator to clone\n@@ -799,6 +804,8 @@ class Method : public InherentImplItem, public TraitImplItem\n     for (const auto &e : other.generic_params)\n       generic_params.push_back (e->clone_generic_param ());\n \n+    node_id = other.node_id;\n+\n     return *this;\n   }\n \n@@ -860,6 +867,14 @@ class Method : public InherentImplItem, public TraitImplItem\n     return where_clause;\n   }\n \n+  Identifier get_method_name () const { return method_name; }\n+\n+  NodeId get_node_id () const { return node_id; }\n+\n+  Location get_locus () const { return locus; }\n+\n+  Location get_locus_slow () const override { return get_locus (); }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n@@ -1503,6 +1518,8 @@ class Function : public VisItem, public InherentImplItem, public TraitImplItem\n \n   Location get_locus () const { return locus; }\n \n+  Location get_locus_slow () const override { return get_locus (); }\n+\n   void accept_vis (ASTVisitor &vis) override;\n \n   // Invalid if block is null, so base stripping on that.\n@@ -2536,6 +2553,8 @@ class ConstantItem : public VisItem,\n \n   Location get_locus () const { return locus; }\n \n+  Location get_locus_slow () const override { return get_locus (); }\n+\n   void accept_vis (ASTVisitor &vis) override;\n \n   // Invalid if type or expression are null, so base stripping on that."}, {"sha": "fdc5ad95e70962c903eae1c544ab0ff5d6510436", "filename": "gcc/rust/backend/rust-compile-base.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-base.h?ref=419677348e1c1e6092e74f55b3a7326a595d6114", "patch": "@@ -51,7 +51,6 @@ class HIRCompileBase : public HIR::HIRVisitor\n   // virtual void visit(TraitItem& trait_item) {}\n   // virtual void visit(InherentImplItem& inherent_impl_item) {}\n   // virtual void visit(TraitImplItem& trait_impl_item) {}\n-  virtual void visit (HIR::MacroInvocationSemi &macro) {}\n \n   // rust-path.h\n   virtual void visit (HIR::PathInExpression &path) {}"}, {"sha": "ccff51ac05c7c48b125ec3676b6b043061bfd128", "filename": "gcc/rust/backend/rust-compile-expr.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.h?ref=419677348e1c1e6092e74f55b3a7326a595d6114", "patch": "@@ -481,6 +481,11 @@ class CompileExpr : public HIRCompileBase\n \t\t\t\t\t\t      expr.get_locus ());\n   }\n \n+  void visit (HIR::PathInExpression &expr)\n+  {\n+    translated = ResolvePathRef::Compile (&expr, ctx);\n+  }\n+\n private:\n   CompileExpr (Context *ctx) : HIRCompileBase (ctx), translated (nullptr) {}\n "}, {"sha": "fe2abf1af96506f1ce1ea55278b6e8f9124697a9", "filename": "gcc/rust/backend/rust-compile-implitem.h", "status": "added", "additions": 264, "deletions": 0, "changes": 264, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h?ref=419677348e1c1e6092e74f55b3a7326a595d6114", "patch": "@@ -0,0 +1,264 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_COMPILE_IMPLITEM_H\n+#define RUST_COMPILE_IMPLITEM_H\n+\n+#include \"rust-compile-base.h\"\n+#include \"rust-compile-tyty.h\"\n+#include \"rust-compile-var-decl.h\"\n+#include \"rust-compile-stmt.h\"\n+#include \"rust-compile-expr.h\"\n+#include \"rust-compile-fnparam.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+class CompileInherentImplItem : public HIRCompileBase\n+{\n+public:\n+  static void Compile (HIR::Type *base, HIR::InherentImplItem *item,\n+\t\t       Context *ctx, bool compile_fns)\n+  {\n+    CompileInherentImplItem compiler (base, ctx, compile_fns);\n+    item->accept_vis (compiler);\n+  }\n+\n+  void visit (HIR::ConstantItem &constant)\n+  {\n+    TyTy::TyBase *resolved_type = nullptr;\n+    bool ok\n+      = ctx->get_tyctx ()->lookup_type (constant.get_mappings ().get_hirid (),\n+\t\t\t\t\t&resolved_type);\n+    rust_assert (ok);\n+\n+    ::Btype *type = TyTyResolveCompile::compile (ctx, resolved_type);\n+    Bexpression *value = CompileExpr::Compile (constant.get_expr (), ctx);\n+\n+    std::string ident = base->as_string () + \"::\" + constant.get_identifier ();\n+    Bexpression *const_expr = ctx->get_backend ()->named_constant_expression (\n+      type, constant.get_identifier (), value, constant.get_locus ());\n+\n+    ctx->push_const (const_expr);\n+    ctx->insert_const_decl (constant.get_mappings ().get_hirid (), const_expr);\n+  }\n+\n+  void visit (HIR::Function &function)\n+  {\n+    if (!compile_fns)\n+      return;\n+\n+    // items can be forward compiled which means we may not need to invoke this\n+    // code\n+    Bfunction *lookup = nullptr;\n+    if (ctx->lookup_function_decl (function.get_mappings ().get_hirid (),\n+\t\t\t\t   &lookup))\n+      {\n+\t// has this been added to the list then it must be finished\n+\tif (ctx->function_completed (lookup))\n+\t  return;\n+      }\n+\n+    TyTy::TyBase *fntype_tyty;\n+    if (!ctx->get_tyctx ()->lookup_type (function.get_mappings ().get_hirid (),\n+\t\t\t\t\t &fntype_tyty))\n+      {\n+\trust_fatal_error (function.locus, \"failed to lookup function type\");\n+\treturn;\n+      }\n+\n+    if (fntype_tyty->get_kind () != TyTy::TypeKind::FNDEF)\n+      {\n+\trust_error_at (function.get_locus (), \"invalid TyTy for function item\");\n+\treturn;\n+      }\n+\n+    TyTy::FnType *fntype = (TyTy::FnType *) fntype_tyty;\n+    // convert to the actual function type\n+    ::Btype *compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n+\n+    unsigned int flags = 0;\n+    bool is_main_fn = function.function_name.compare (\"main\") == 0;\n+\n+    std::string fn_identifier\n+      = base->as_string () + \"::\" + function.function_name;\n+\n+    // if its the main fn or pub visibility mark its as DECL_PUBLIC\n+    // please see https://github.com/Rust-GCC/gccrs/pull/137\n+    if (is_main_fn || function.has_visibility ())\n+      flags |= Backend::function_is_visible;\n+\n+    std::string asm_name = fn_identifier;\n+    if (!is_main_fn)\n+      {\n+\t// FIXME need name mangling\n+\tasm_name = \"__\" + function.function_name;\n+      }\n+\n+    Bfunction *fndecl\n+      = ctx->get_backend ()->function (compiled_fn_type, fn_identifier,\n+\t\t\t\t       asm_name, flags, function.get_locus ());\n+    ctx->insert_function_decl (function.get_mappings ().get_hirid (), fndecl);\n+\n+    // setup the params\n+\n+    TyTy::TyBase *tyret = fntype->return_type ();\n+    std::vector<Bvariable *> param_vars;\n+\n+    size_t i = 0;\n+    for (auto &it : fntype->get_params ())\n+      {\n+\tHIR::FunctionParam &referenced_param = function.function_params.at (i);\n+\tauto param_tyty = it.second;\n+\tauto compiled_param_type\n+\t  = TyTyResolveCompile::compile (ctx, param_tyty);\n+\n+\tLocation param_locus\n+\t  = ctx->get_mappings ()->lookup_location (param_tyty->get_ref ());\n+\tBvariable *compiled_param_var\n+\t  = CompileFnParam::compile (ctx, fndecl, &referenced_param,\n+\t\t\t\t     compiled_param_type, param_locus);\n+\tif (compiled_param_var == nullptr)\n+\t  {\n+\t    rust_error_at (param_locus, \"failed to compile parameter variable\");\n+\t    return;\n+\t  }\n+\n+\tparam_vars.push_back (compiled_param_var);\n+\n+\tctx->insert_var_decl (referenced_param.get_mappings ().get_hirid (),\n+\t\t\t      compiled_param_var);\n+\ti++;\n+      }\n+\n+    if (!ctx->get_backend ()->function_set_parameters (fndecl, param_vars))\n+      {\n+\trust_fatal_error (function.get_locus (),\n+\t\t\t  \"failed to setup parameter variables\");\n+\treturn;\n+      }\n+\n+    // lookup locals\n+    auto block_expr = function.function_body.get ();\n+    auto body_mappings = block_expr->get_mappings ();\n+\n+    Resolver::Rib *rib = nullptr;\n+    if (!ctx->get_resolver ()->find_name_rib (body_mappings.get_nodeid (),\n+\t\t\t\t\t      &rib))\n+      {\n+\trust_fatal_error (function.get_locus (),\n+\t\t\t  \"failed to setup locals per block\");\n+\treturn;\n+      }\n+\n+    std::vector<Bvariable *> locals;\n+    rib->iterate_decls ([&] (NodeId n, Location) mutable -> bool {\n+      Resolver::Definition d;\n+      bool ok = ctx->get_resolver ()->lookup_definition (n, &d);\n+      rust_assert (ok);\n+\n+      HIR::Stmt *decl = nullptr;\n+      ok = ctx->get_mappings ()->resolve_nodeid_to_stmt (d.parent, &decl);\n+      rust_assert (ok);\n+\n+      Bvariable *compiled = CompileVarDecl::compile (fndecl, decl, ctx);\n+      locals.push_back (compiled);\n+\n+      return true;\n+    });\n+\n+    bool toplevel_item\n+      = function.get_mappings ().get_local_defid () != UNKNOWN_LOCAL_DEFID;\n+    Bblock *enclosing_scope\n+      = toplevel_item ? NULL : ctx->peek_enclosing_scope ();\n+\n+    HIR::BlockExpr *function_body = function.function_body.get ();\n+    Location start_location = function_body->get_locus ();\n+    Location end_location = function_body->get_closing_locus ();\n+\n+    Bblock *code_block\n+      = ctx->get_backend ()->block (fndecl, enclosing_scope, locals,\n+\t\t\t\t    start_location, end_location);\n+    ctx->push_block (code_block);\n+\n+    Bvariable *return_address = nullptr;\n+    if (function.has_function_return_type ())\n+      {\n+\tBtype *return_type = TyTyResolveCompile::compile (ctx, tyret);\n+\n+\tbool address_is_taken = false;\n+\tBstatement *ret_var_stmt = nullptr;\n+\n+\treturn_address = ctx->get_backend ()->temporary_variable (\n+\t  fndecl, code_block, return_type, NULL, address_is_taken,\n+\t  function.get_locus (), &ret_var_stmt);\n+\n+\tctx->add_statement (ret_var_stmt);\n+      }\n+\n+    ctx->push_fn (fndecl, return_address);\n+\n+    // compile the block\n+    function_body->iterate_stmts ([&] (HIR::Stmt *s) mutable -> bool {\n+      CompileStmt::Compile (s, ctx);\n+      return true;\n+    });\n+\n+    if (function_body->has_expr () && function_body->tail_expr_reachable ())\n+      {\n+\t// the previous passes will ensure this is a valid return\n+\t// dead code elimination should remove any bad trailing expressions\n+\tBexpression *compiled_expr\n+\t  = CompileExpr::Compile (function_body->expr.get (), ctx);\n+\trust_assert (compiled_expr != nullptr);\n+\n+\tauto fncontext = ctx->peek_fn ();\n+\n+\tstd::vector<Bexpression *> retstmts;\n+\tretstmts.push_back (compiled_expr);\n+\tauto s = ctx->get_backend ()->return_statement (\n+\t  fncontext.fndecl, retstmts, function_body->expr->get_locus_slow ());\n+\tctx->add_statement (s);\n+      }\n+\n+    ctx->pop_block ();\n+    auto body = ctx->get_backend ()->block_statement (code_block);\n+    if (!ctx->get_backend ()->function_set_body (fndecl, body))\n+      {\n+\trust_error_at (function.get_locus (), \"failed to set body to function\");\n+\treturn;\n+      }\n+\n+    ctx->pop_fn ();\n+\n+    ctx->push_function (fndecl);\n+  }\n+\n+private:\n+  CompileInherentImplItem (HIR::Type *base, Context *ctx, bool compile_fns)\n+    : HIRCompileBase (ctx), base (base), compile_fns (compile_fns)\n+  {}\n+\n+  HIR::Type *base;\n+  bool compile_fns;\n+};\n+\n+} // namespace Compile\n+} // namespace Rust\n+\n+#endif // RUST_COMPILE_IMPLITEM_H"}, {"sha": "83e4451d63a697b90fa035f21e4399edc7885815", "filename": "gcc/rust/backend/rust-compile-item.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-item.h?ref=419677348e1c1e6092e74f55b3a7326a595d6114", "patch": "@@ -21,6 +21,7 @@\n \n #include \"rust-compile-base.h\"\n #include \"rust-compile-tyty.h\"\n+#include \"rust-compile-implitem.h\"\n #include \"rust-compile-var-decl.h\"\n #include \"rust-compile-stmt.h\"\n #include \"rust-compile-expr.h\"\n@@ -300,6 +301,13 @@ class CompileItem : public HIRCompileBase\n     ctx->push_function (fndecl);\n   }\n \n+  void visit (HIR::InherentImpl &impl_block)\n+  {\n+    for (auto &impl_item : impl_block.get_impl_items ())\n+      CompileInherentImplItem::Compile (impl_block.get_type ().get (),\n+\t\t\t\t\timpl_item.get (), ctx, compile_fns);\n+  }\n+\n private:\n   CompileItem (Context *ctx, bool compile_fns)\n     : HIRCompileBase (ctx), compile_fns (compile_fns)"}, {"sha": "de325fa659319b7e0603a238ab9c20e1d8c20e41", "filename": "gcc/rust/backend/rust-compile-resolve-path.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc?ref=419677348e1c1e6092e74f55b3a7326a595d6114", "patch": "@@ -55,6 +55,10 @@ ResolvePathRef::visit (HIR::PathInExpression &expr)\n       return;\n     }\n \n+  // might be a constant\n+  if (ctx->lookup_const_decl (ref, &resolved))\n+    return;\n+\n   // this might be a variable reference or a function reference\n   Bvariable *var = nullptr;\n   if (ctx->lookup_var_decl (ref, &var))"}, {"sha": "e701b15938e382743425039f92ec325165f14779", "filename": "gcc/rust/backend/rust-compile-var-decl.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Fbackend%2Frust-compile-var-decl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Fbackend%2Frust-compile-var-decl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-var-decl.h?ref=419677348e1c1e6092e74f55b3a7326a595d6114", "patch": "@@ -38,8 +38,6 @@ class CompileVarDecl : public HIRCompileBase\n     return compiler.translated;\n   }\n \n-  virtual ~CompileVarDecl () {}\n-\n   void visit (HIR::LetStmt &stmt)\n   {\n     locus = stmt.get_locus ();"}, {"sha": "550d104b2ffe349982226c4a147346971e5f9f5f", "filename": "gcc/rust/hir/README.md", "status": "removed", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36ac7b79717b580a9adbbb07383d17fe6d63be2f/gcc%2Frust%2Fhir%2FREADME.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36ac7b79717b580a9adbbb07383d17fe6d63be2f/gcc%2Frust%2Fhir%2FREADME.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2FREADME.md?ref=36ac7b79717b580a9adbbb07383d17fe6d63be2f", "patch": "@@ -1,40 +0,0 @@\n-# GCCRS HIR\n-\n-Working with the AST has proved to become difficult. To overcome non lexical scoping\n-a toplevel scan pass was added to provide lookups for functioins. To get ready for the\n-gimple conversion pass, type resolution scanned blocks to create the list of locals per\n-block. Type Conversion had to create awkward getters/setters on LetStmts to have a Type or\n-InferedType which was more of a hack that what should really be there. ArrayExprs get checked\n-and create their own type to be checked against a possible LetStmt type. All of these things\n-started to become hard to manage.\n-\n-HIR from the RFC defines how they create lookups and IDs for all the nodes which solves the toplevel\n-scan pass. The lowering to HIR allows for cleanup in how types are resolved. Without using\n-the HIR and IDs implementing the shadowing rules was going to become very difficult.\n-\n-\n-## IMPL:\n-\n-* AST-lower - move down to HIR classes - generate mappings and IDs\n-\n-* Name Resolution - Check for path segments naming and map to HirIDS\n-  This should in theory map for example a call expression to already have the HirID to the function ready\n-  Dyn dispatch may need some help here if its a method the receiver could be bound the local name hirid\n-  the resoltion would need to be fixed up in type resolution pass\n-  \n-* Expand - Gather locals per block and fix up returns is it possible to generate return expressions\n-  at this pass?\n-  \n-* Type Resolution - Port over work from AST Type resolver\n-  generate mir from this pass?\n-\n-\n-For now this can then port over to the existing GIMPLE conversion faily easily. But after more\n-of the core data structures work MIR will be needed for all the glue that will need to be generated.\n-\n-\n-## Returns\n-\n-looks like its implemented by an implicit mutable return variable for the function. If were processing\n-a block expression and the last element on the block is an expression we can try to bind it to the mutable\n-return variable."}, {"sha": "dab32089617dff23fac1dd081acaf02d32d791f1", "filename": "gcc/rust/hir/rust-ast-lower-implitem.h", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Fhir%2Frust-ast-lower-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Fhir%2Frust-ast-lower-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-implitem.h?ref=419677348e1c1e6092e74f55b3a7326a595d6114", "patch": "@@ -0,0 +1,156 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_LOWER_IMPLITEM_H\n+#define RUST_AST_LOWER_IMPLITEM_H\n+\n+#include \"rust-diagnostics.h\"\n+#include \"rust-ast-lower-type.h\"\n+#include \"rust-ast-lower-stmt.h\"\n+#include \"rust-ast-lower-expr.h\"\n+#include \"rust-ast-lower-pattern.h\"\n+#include \"rust-ast-lower-block.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+\n+class ASTLowerImplItem : public ASTLoweringBase\n+{\n+public:\n+  static HIR::InherentImplItem *translate (AST::InherentImplItem *item)\n+  {\n+    ASTLowerImplItem resolver;\n+    item->accept_vis (resolver);\n+    rust_assert (resolver.translated != nullptr);\n+    return resolver.translated;\n+  }\n+\n+  void visit (AST::ConstantItem &constant)\n+  {\n+    std::vector<HIR::Attribute> outer_attrs;\n+    HIR::Visibility vis = HIR::Visibility::create_public ();\n+\n+    HIR::Type *type = ASTLoweringType::translate (constant.get_type ().get ());\n+    HIR::Expr *expr = ASTLoweringExpr::translate (constant.get_expr ().get ());\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, constant.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    translated = new HIR::ConstantItem (mapping, constant.get_identifier (),\n+\t\t\t\t\tvis, std::unique_ptr<HIR::Type> (type),\n+\t\t\t\t\tstd::unique_ptr<HIR::Expr> (expr),\n+\t\t\t\t\touter_attrs, constant.get_locus ());\n+\n+    mappings->insert_hir_implitem (mapping.get_crate_num (),\n+\t\t\t\t   mapping.get_hirid (), translated);\n+    mappings->insert_location (crate_num, mapping.get_hirid (),\n+\t\t\t       constant.get_locus ());\n+  }\n+\n+  void visit (AST::Function &function)\n+  {\n+    // ignore for now and leave empty\n+    std::vector<std::unique_ptr<HIR::GenericParam> > generic_params;\n+    std::vector<HIR::Attribute> outer_attrs;\n+    std::vector<std::unique_ptr<HIR::WhereClauseItem> > where_clause_items;\n+    HIR::WhereClause where_clause (std::move (where_clause_items));\n+    HIR::FunctionQualifiers qualifiers (\n+      HIR::FunctionQualifiers::AsyncConstStatus::NONE, false);\n+    HIR::Visibility vis = HIR::Visibility::create_public ();\n+\n+    // need\n+    Identifier function_name = function.get_function_name ();\n+    Location locus = function.get_locus ();\n+\n+    std::unique_ptr<HIR::Type> return_type\n+      = function.has_return_type () ? std::unique_ptr<HIR::Type> (\n+\t  ASTLoweringType::translate (function.get_return_type ().get ()))\n+\t\t\t\t    : nullptr;\n+\n+    std::vector<HIR::FunctionParam> function_params;\n+    for (auto &param : function.get_function_params ())\n+      {\n+\tauto translated_pattern = std::unique_ptr<HIR::Pattern> (\n+\t  ASTLoweringPattern::translate (param.get_pattern ().get ()));\n+\tauto translated_type = std::unique_ptr<HIR::Type> (\n+\t  ASTLoweringType::translate (param.get_type ().get ()));\n+\n+\tauto crate_num = mappings->get_current_crate ();\n+\tAnalysis::NodeMapping mapping (crate_num, param.get_node_id (),\n+\t\t\t\t       mappings->get_next_hir_id (crate_num),\n+\t\t\t\t       UNKNOWN_LOCAL_DEFID);\n+\n+\tauto hir_param\n+\t  = HIR::FunctionParam (mapping, std::move (translated_pattern),\n+\t\t\t\tstd::move (translated_type),\n+\t\t\t\tparam.get_locus ());\n+\tfunction_params.push_back (hir_param);\n+      }\n+\n+    bool terminated = false;\n+    std::unique_ptr<HIR::BlockExpr> function_body\n+      = std::unique_ptr<HIR::BlockExpr> (\n+\tASTLoweringBlock::translate (function.get_definition ().get (),\n+\t\t\t\t     &terminated));\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, function.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    mappings->insert_location (crate_num,\n+\t\t\t       function_body->get_mappings ().get_hirid (),\n+\t\t\t       function.get_locus ());\n+\n+    auto fn\n+      = new HIR::Function (mapping, std::move (function_name),\n+\t\t\t   std::move (qualifiers), std::move (generic_params),\n+\t\t\t   std::move (function_params), std::move (return_type),\n+\t\t\t   std::move (where_clause), std::move (function_body),\n+\t\t\t   std::move (vis), std::move (outer_attrs), locus);\n+\n+    mappings->insert_hir_implitem (mapping.get_crate_num (),\n+\t\t\t\t   mapping.get_hirid (), fn);\n+    mappings->insert_location (crate_num, mapping.get_hirid (),\n+\t\t\t       function.get_locus ());\n+\n+    // add the mappings for the function params at the end\n+    for (auto &param : fn->function_params)\n+      {\n+\tmappings->insert_hir_param (mapping.get_crate_num (),\n+\t\t\t\t    param.get_mappings ().get_hirid (), &param);\n+\tmappings->insert_location (crate_num, mapping.get_hirid (),\n+\t\t\t\t   param.get_locus ());\n+      }\n+\n+    translated = fn;\n+  }\n+\n+private:\n+  ASTLowerImplItem () : translated (nullptr) {}\n+\n+  HIR::InherentImplItem *translated;\n+};\n+\n+} // namespace HIR\n+\n+} // namespace Rust\n+\n+#endif // RUST_AST_LOWER_IMPLITEM_H"}, {"sha": "1e48e8292c03c882cd2e9c8e372325e899e54484", "filename": "gcc/rust/hir/rust-ast-lower-item.h", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h?ref=419677348e1c1e6092e74f55b3a7326a595d6114", "patch": "@@ -23,6 +23,7 @@\n \n #include \"rust-ast-lower-base.h\"\n #include \"rust-ast-lower-type.h\"\n+#include \"rust-ast-lower-implitem.h\"\n #include \"rust-ast-lower-stmt.h\"\n #include \"rust-ast-lower-expr.h\"\n #include \"rust-ast-lower-pattern.h\"\n@@ -282,6 +283,46 @@ class ASTLoweringItem : public ASTLoweringBase\n     translated = fn;\n   }\n \n+  void visit (AST::InherentImpl &impl_block)\n+  {\n+    std::vector<HIR::Attribute> inner_attrs;\n+    std::vector<HIR::Attribute> outer_attrs;\n+    std::vector<std::unique_ptr<HIR::GenericParam> > generic_params;\n+    std::vector<std::unique_ptr<HIR::WhereClauseItem> > where_clause_items;\n+\n+    HIR::WhereClause where_clause (std::move (where_clause_items));\n+    HIR::Visibility vis = HIR::Visibility::create_public ();\n+    HIR::Type *trait_type\n+      = ASTLoweringType::translate (impl_block.get_type ().get ());\n+\n+    std::vector<std::unique_ptr<HIR::InherentImplItem> > impl_items;\n+    for (auto &impl_item : impl_block.get_impl_items ())\n+      {\n+\tHIR::InherentImplItem *lowered\n+\t  = ASTLowerImplItem::translate (impl_item.get ());\n+\timpl_items.push_back (std::unique_ptr<HIR::InherentImplItem> (lowered));\n+      }\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, impl_block.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    translated\n+      = new HIR::InherentImpl (mapping, std::move (impl_items),\n+\t\t\t       std::move (generic_params),\n+\t\t\t       std::unique_ptr<HIR::Type> (trait_type),\n+\t\t\t       where_clause, vis, std::move (inner_attrs),\n+\t\t\t       std::move (outer_attrs),\n+\t\t\t       impl_block.get_locus ());\n+\n+    mappings->insert_defid_mapping (mapping.get_defid (), translated);\n+    mappings->insert_hir_item (mapping.get_crate_num (), mapping.get_hirid (),\n+\t\t\t       translated);\n+    mappings->insert_location (crate_num, mapping.get_hirid (),\n+\t\t\t       impl_block.get_locus ());\n+  }\n+\n private:\n   ASTLoweringItem () : translated (nullptr) {}\n "}, {"sha": "c1ea01a8805fb0897af2d70043b456e53045a387", "filename": "gcc/rust/hir/rust-ast-lower.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Fhir%2Frust-ast-lower.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Fhir%2Frust-ast-lower.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower.cc?ref=419677348e1c1e6092e74f55b3a7326a595d6114", "patch": "@@ -18,6 +18,7 @@\n \n #include \"rust-ast-lower.h\"\n #include \"rust-ast-lower-item.h\"\n+#include \"rust-ast-lower-implitem.h\"\n #include \"rust-ast-lower-expr.h\"\n #include \"rust-ast-lower-block.h\"\n "}, {"sha": "8295e89f3dec8a7e371a0432ce544fbd0fe1fed6", "filename": "gcc/rust/hir/tree/rust-hir-full-decls.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-decls.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-decls.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-decls.h?ref=419677348e1c1e6092e74f55b3a7326a595d6114", "patch": "@@ -53,7 +53,6 @@ class MacroItem;\n class TraitItem;\n class InherentImplItem;\n class TraitImplItem;\n-class MacroInvocationSemi;\n struct Crate;\n class PathExpr;\n "}, {"sha": "8502c9c844953fb972ac3b2c062b96b3464ab665", "filename": "gcc/rust/hir/tree/rust-hir-full-test.cc", "status": "modified", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc?ref=419677348e1c1e6092e74f55b3a7326a595d6114", "patch": "@@ -1376,47 +1376,6 @@ TypeAlias::as_string () const\n   return str;\n }\n \n-std::string\n-MacroInvocationSemi::as_string () const\n-{\n-  // get outer attrs\n-  std::string str = MacroItem::as_string ();\n-\n-  str += \"\\n\" + path.as_string () + \"!\";\n-\n-  std::string tok_trees;\n-  if (token_trees.empty ())\n-    {\n-      tok_trees = \"none\";\n-    }\n-  else\n-    {\n-      auto i = token_trees.begin ();\n-      auto e = token_trees.end ();\n-\n-      // DEBUG: null pointer check\n-      if (i == e)\n-\t{\n-\t  fprintf (stderr,\n-\t\t   \"something really terrible has gone wrong - null pointer \"\n-\t\t   \"token tree in macro invocation semi.\");\n-\t  return \"nullptr_POINTER_MARK\";\n-\t}\n-\n-      std::string s;\n-      for (; i != e; i++)\n-\t{\n-\t  s += (*i)->as_string ();\n-\t  if (e != i + 1)\n-\t    s += \", \";\n-\t}\n-\n-      tok_trees += get_string_in_delims (s, delim_type);\n-    }\n-\n-  return str;\n-}\n-\n std::string\n ExternBlock::as_string () const\n {\n@@ -5045,12 +5004,6 @@ LifetimeParam::accept_vis (HIRVisitor &vis)\n   vis.visit (*this);\n }\n \n-void\n-MacroInvocationSemi::accept_vis (HIRVisitor &vis)\n-{\n-  vis.visit (*this);\n-}\n-\n void\n PathInExpression::accept_vis (HIRVisitor &vis)\n {"}, {"sha": "e90dbb4fe1b3c5d9a1b4aef4bb8baf2e3eb18963", "filename": "gcc/rust/hir/tree/rust-hir-item.h", "status": "modified", "additions": 40, "deletions": 8, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h?ref=419677348e1c1e6092e74f55b3a7326a595d6114", "patch": "@@ -27,7 +27,6 @@ namespace HIR {\n // forward decls\n class BlockExpr;\n class TypePath;\n-class MacroInvocationSemi;\n \n // A type generic parameter (as opposed to a lifetime generic parameter)\n class TypeParam : public GenericParam\n@@ -569,6 +568,8 @@ class Method : public InherentImplItem, public TraitImplItem\n \n   std::unique_ptr<BlockExpr> expr;\n \n+  Analysis::NodeMapping mappings;\n+\n   Location locus;\n \n public:\n@@ -588,14 +589,15 @@ class Method : public InherentImplItem, public TraitImplItem\n   bool has_visibility () const { return !vis.is_error (); }\n \n   // Mega-constructor with all possible fields\n-  Method (Identifier method_name, FunctionQualifiers qualifiers,\n+  Method (Analysis::NodeMapping mappings, Identifier method_name,\n+\t  FunctionQualifiers qualifiers,\n \t  std::vector<std::unique_ptr<GenericParam> > generic_params,\n \t  SelfParam self_param, std::vector<FunctionParam> function_params,\n \t  std::unique_ptr<Type> return_type, WhereClause where_clause,\n \t  std::unique_ptr<BlockExpr> function_body, Visibility vis,\n \t  std::vector<Attribute> outer_attrs, Location locus = Location ())\n-    : outer_attrs (std::move (outer_attrs)), vis (std::move (vis)),\n-      qualifiers (std::move (qualifiers)),\n+    : mappings (mappings), outer_attrs (std::move (outer_attrs)),\n+      vis (std::move (vis)), qualifiers (std::move (qualifiers)),\n       method_name (std::move (method_name)),\n       generic_params (std::move (generic_params)),\n       self_param (std::move (self_param)),\n@@ -609,9 +611,10 @@ class Method : public InherentImplItem, public TraitImplItem\n \n   // Copy constructor with clone\n   Method (Method const &other)\n-    : outer_attrs (other.outer_attrs), vis (other.vis),\n-      qualifiers (other.qualifiers), method_name (other.method_name),\n-      self_param (other.self_param), function_params (other.function_params),\n+    : mappings (other.mappings), outer_attrs (other.outer_attrs),\n+      vis (other.vis), qualifiers (other.qualifiers),\n+      method_name (other.method_name), self_param (other.self_param),\n+      function_params (other.function_params),\n       return_type (other.return_type->clone_type ()),\n       where_clause (other.where_clause), expr (other.expr->clone_block_expr ()),\n       locus (other.locus)\n@@ -624,6 +627,7 @@ class Method : public InherentImplItem, public TraitImplItem\n   // Overloaded assignment operator to clone\n   Method &operator= (Method const &other)\n   {\n+    mappings = other.mappings;\n     method_name = other.method_name;\n     outer_attrs = other.outer_attrs;\n     vis = other.vis;\n@@ -650,6 +654,13 @@ class Method : public InherentImplItem, public TraitImplItem\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  Analysis::NodeMapping get_mappings () const { return mappings; };\n+\n+  Analysis::NodeMapping get_impl_mappings () const override\n+  {\n+    return get_mappings ();\n+  };\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n@@ -1267,6 +1278,11 @@ class Function : public VisItem, public InherentImplItem, public TraitImplItem\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  Analysis::NodeMapping get_impl_mappings () const override\n+  {\n+    return get_mappings ();\n+  };\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n@@ -2096,6 +2112,11 @@ class ConstantItem : public VisItem,\n \n   std::string get_identifier () { return identifier; }\n \n+  Analysis::NodeMapping get_impl_mappings () const override\n+  {\n+    return get_mappings ();\n+  };\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n@@ -2767,6 +2788,8 @@ class Impl : public VisItem\n \n   Location get_locus () const { return locus; }\n \n+  std::unique_ptr<Type> &get_type () { return trait_type; };\n+\n protected:\n   // Mega-constructor\n   Impl (Analysis::NodeMapping mappings,\n@@ -2864,6 +2887,16 @@ class InherentImpl : public Impl\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  std::vector<std::unique_ptr<InherentImplItem> > &get_impl_items ()\n+  {\n+    return impl_items;\n+  };\n+\n+  const std::vector<std::unique_ptr<InherentImplItem> > &get_impl_items () const\n+  {\n+    return impl_items;\n+  };\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n@@ -3300,7 +3333,6 @@ class ExternBlock : public VisItem\n \n // Replaced with forward decls - defined in \"rust-macro.h\"\n class MacroItem;\n-class MacroInvocationSemi;\n class MacroRulesDefinition;\n } // namespace HIR\n } // namespace Rust"}, {"sha": "13f0d22b7272ff974766d5a7e2633638b71ef19c", "filename": "gcc/rust/hir/tree/rust-hir-macro.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-macro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-macro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-macro.h?ref=419677348e1c1e6092e74f55b3a7326a595d6114", "patch": "@@ -25,7 +25,6 @@ namespace Rust {\n namespace HIR {\n // Decls as definitions moved to rust-ast.h\n class MacroItem;\n-class MacroInvocationSemi;\n \n enum MacroFragSpec\n {"}, {"sha": "3384aaac9ac02c695bc5bc4fd7106a3528799c8f", "filename": "gcc/rust/hir/tree/rust-hir-stmt.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-stmt.h?ref=419677348e1c1e6092e74f55b3a7326a595d6114", "patch": "@@ -233,9 +233,6 @@ class ExprStmtWithBlock : public ExprStmt\n   }\n };\n \n-/* Replaced definition of MacroInvocationSemi with forward decl - defined in\n- * rust-macro.h */\n-class MacroInvocationSemi;\n } // namespace HIR\n } // namespace Rust\n "}, {"sha": "a7b979137d2d6731c62f41281e3802da03b82029", "filename": "gcc/rust/hir/tree/rust-hir-visitor.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-visitor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-visitor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-visitor.h?ref=419677348e1c1e6092e74f55b3a7326a595d6114", "patch": "@@ -52,7 +52,6 @@ class HIRVisitor\n   // virtual void visit(TraitItem& trait_item) = 0;\n   // virtual void visit(InherentImplItem& inherent_impl_item) = 0;\n   // virtual void visit(TraitImplItem& trait_impl_item) = 0;\n-  virtual void visit (MacroInvocationSemi &macro) = 0;\n \n   // rust-path.h\n   virtual void visit (PathInExpression &path) = 0;"}, {"sha": "6fd6297c0a3f508067935597d058053736b68e5b", "filename": "gcc/rust/hir/tree/rust-hir.h", "status": "modified", "additions": 2, "deletions": 116, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h?ref=419677348e1c1e6092e74f55b3a7326a595d6114", "patch": "@@ -1256,6 +1256,8 @@ class InherentImplItem\n   virtual std::string as_string () const = 0;\n \n   virtual void accept_vis (HIRVisitor &vis) = 0;\n+\n+  virtual Analysis::NodeMapping get_impl_mappings () const = 0;\n };\n \n // Abstract base class for items used in a trait impl\n@@ -1278,122 +1280,6 @@ class TraitImplItem\n   virtual void accept_vis (HIRVisitor &vis) = 0;\n };\n \n-/* A macro invocation item (or statement) HIR node (i.e. semi-coloned macro\n- * invocation) */\n-class MacroInvocationSemi : public MacroItem,\n-\t\t\t    public TraitItem,\n-\t\t\t    public InherentImplItem,\n-\t\t\t    public TraitImplItem\n-{\n-  SimplePath path;\n-  // all delim types except curly must have invocation end with a semicolon\n-  DelimType delim_type;\n-  std::vector<std::unique_ptr<TokenTree> > token_trees;\n-  Location locus;\n-\n-public:\n-  std::string as_string () const override;\n-\n-  MacroInvocationSemi (Analysis::NodeMapping mappings, SimplePath macro_path,\n-\t\t       DelimType delim_type,\n-\t\t       std::vector<std::unique_ptr<TokenTree> > token_trees,\n-\t\t       std::vector<Attribute> outer_attribs, Location locus)\n-    : MacroItem (std::move (mappings), std::move (outer_attribs)),\n-      path (std::move (macro_path)), delim_type (delim_type),\n-      token_trees (std::move (token_trees)), locus (locus)\n-  {}\n-  /* TODO: possible issue with Item and TraitItem hierarchies both having outer\n-   * attributes\n-   * - storage inefficiency at least.\n-   * Best current idea is to make Item preferred and have TraitItem get virtual\n-   * functions for attributes or something. Or just redo the \"composition\"\n-   * approach, but then this prevents polymorphism and would entail redoing\n-   * quite a bit of the parser. */\n-\n-  // Move constructors\n-  MacroInvocationSemi (MacroInvocationSemi &&other) = default;\n-  MacroInvocationSemi &operator= (MacroInvocationSemi &&other) = default;\n-\n-  void accept_vis (HIRVisitor &vis) override;\n-\n-  // Clones this macro invocation semi.\n-  std::unique_ptr<MacroInvocationSemi> clone_macro_invocation_semi () const\n-  {\n-    return std::unique_ptr<MacroInvocationSemi> (\n-      clone_macro_invocation_semi_impl ());\n-  }\n-\n-protected:\n-  // Copy constructor with vector clone\n-  MacroInvocationSemi (MacroInvocationSemi const &other)\n-    : MacroItem (other), TraitItem (other), InherentImplItem (other),\n-      TraitImplItem (other), path (other.path), delim_type (other.delim_type),\n-      locus (other.locus)\n-  {\n-    token_trees.reserve (other.token_trees.size ());\n-    for (const auto &e : other.token_trees)\n-      token_trees.push_back (e->clone_token_tree ());\n-  }\n-\n-  // Overloaded assignment operator to vector clone\n-  MacroInvocationSemi &operator= (MacroInvocationSemi const &other)\n-  {\n-    MacroItem::operator= (other);\n-    TraitItem::operator= (other);\n-    InherentImplItem::operator= (other);\n-    TraitImplItem::operator= (other);\n-    path = other.path;\n-    delim_type = other.delim_type;\n-    locus = other.locus;\n-\n-    token_trees.reserve (other.token_trees.size ());\n-    for (const auto &e : other.token_trees)\n-      token_trees.push_back (e->clone_token_tree ());\n-\n-    return *this;\n-  }\n-\n-  MacroInvocationSemi *clone_macro_invocation_semi_impl () const\n-  {\n-    return new MacroInvocationSemi (*this);\n-  }\n-\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  MacroInvocationSemi *clone_item_impl () const override\n-  {\n-    return clone_macro_invocation_semi_impl ();\n-  }\n-\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  MacroInvocationSemi *clone_inherent_impl_item_impl () const override\n-  {\n-    return clone_macro_invocation_semi_impl ();\n-  }\n-\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  MacroInvocationSemi *clone_trait_impl_item_impl () const override\n-  {\n-    return clone_macro_invocation_semi_impl ();\n-  }\n-\n-  // FIXME: remove if item impl virtual override works properly\n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  /*MacroInvocationSemi* clone_statement_impl() const override {\n-      return clone_macro_invocation_semi_impl ();\n-  }*/\n-\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  MacroInvocationSemi *clone_trait_item_impl () const override\n-  {\n-    return clone_macro_invocation_semi_impl ();\n-  }\n-};\n-\n // A crate HIR object - holds all the data for a single compilation unit\n struct Crate\n {"}, {"sha": "74f2cdc40f609affef49884955b00cc4b5035e43", "filename": "gcc/rust/resolve/rust-ast-resolve-implitem.h", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Fresolve%2Frust-ast-resolve-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Fresolve%2Frust-ast-resolve-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-implitem.h?ref=419677348e1c1e6092e74f55b3a7326a595d6114", "patch": "@@ -0,0 +1,82 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_RESOLVE_IMPLITEM_H\n+#define RUST_AST_RESOLVE_IMPLITEM_H\n+\n+#include \"rust-ast-resolve-base.h\"\n+#include \"rust-ast-resolve-type.h\"\n+#include \"rust-ast-full.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class ResolveToplevelImplItem : public ResolverBase\n+{\n+public:\n+  static void go (AST::InherentImplItem *item, AST::Type *base)\n+  {\n+    ResolveToplevelImplItem resolver (base);\n+    item->accept_vis (resolver);\n+  };\n+\n+  void visit (AST::ConstantItem &constant)\n+  {\n+    std::string identifier\n+      = base->as_string () + \"::\" + constant.get_identifier ();\n+    resolver->get_name_scope ().insert (identifier, constant.get_node_id (),\n+\t\t\t\t\tconstant.get_locus ());\n+    resolver->insert_new_definition (constant.get_node_id (),\n+\t\t\t\t     Definition{constant.get_node_id (),\n+\t\t\t\t\t\tconstant.get_node_id ()});\n+  }\n+\n+  void visit (AST::Function &function)\n+  {\n+    std::string identifier\n+      = base->as_string () + \"::\" + function.get_function_name ();\n+    resolver->get_name_scope ().insert (identifier, function.get_node_id (),\n+\t\t\t\t\tfunction.get_locus ());\n+    resolver->insert_new_definition (function.get_node_id (),\n+\t\t\t\t     Definition{function.get_node_id (),\n+\t\t\t\t\t\tfunction.get_node_id ()});\n+  }\n+\n+  void visit (AST::Method &method)\n+  {\n+    std::string identifier\n+      = base->as_string () + \"::\" + method.get_method_name ();\n+    resolver->get_name_scope ().insert (identifier, method.get_node_id (),\n+\t\t\t\t\tmethod.get_locus ());\n+    resolver->insert_new_definition (method.get_node_id (),\n+\t\t\t\t     Definition{method.get_node_id (),\n+\t\t\t\t\t\tmethod.get_node_id ()});\n+  }\n+\n+private:\n+  ResolveToplevelImplItem (AST::Type *base)\n+    : ResolverBase (UNKNOWN_NODEID), base (base)\n+  {}\n+\n+  AST::Type *base;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_AST_RESOLVE_IMPLITEM_H"}, {"sha": "74b5f8d36813208bf3ced6e9f3b5cc8d579f79d2", "filename": "gcc/rust/resolve/rust-ast-resolve-item.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h?ref=419677348e1c1e6092e74f55b3a7326a595d6114", "patch": "@@ -117,6 +117,12 @@ class ResolveItem : public ResolverBase\n     resolver->get_type_scope ().pop ();\n   }\n \n+  void visit (AST::InherentImpl &impl_block)\n+  {\n+    for (auto &impl_item : impl_block.get_impl_items ())\n+      impl_item->accept_vis (*this);\n+  }\n+\n private:\n   ResolveItem () : ResolverBase (UNKNOWN_NODEID) {}\n };"}, {"sha": "7ca827573784b51630c0f5086f3a4a97c4eba443", "filename": "gcc/rust/resolve/rust-ast-resolve-toplevel.h", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h?ref=419677348e1c1e6092e74f55b3a7326a595d6114", "patch": "@@ -20,6 +20,8 @@\n #define RUST_AST_RESOLVE_TOPLEVEL_H\n \n #include \"rust-ast-resolve-base.h\"\n+#include \"rust-ast-resolve-type.h\"\n+#include \"rust-ast-resolve-implitem.h\"\n #include \"rust-ast-full.h\"\n \n namespace Rust {\n@@ -34,8 +36,6 @@ class ResolveTopLevel : public ResolverBase\n     item->accept_vis (resolver);\n   };\n \n-  ~ResolveTopLevel () {}\n-\n   void visit (AST::TupleStruct &struct_decl)\n   {\n     resolver->get_type_scope ().insert (struct_decl.get_identifier (),\n@@ -88,6 +88,17 @@ class ResolveTopLevel : public ResolverBase\n       }\n   }\n \n+  void visit (AST::InherentImpl &impl_block)\n+  {\n+    if (!ResolveType::go (impl_block.get_type ().get (),\n+\t\t\t  impl_block.get_node_id ()))\n+      return;\n+\n+    for (auto &impl_item : impl_block.get_impl_items ())\n+      ResolveToplevelImplItem::go (impl_item.get (),\n+\t\t\t\t   impl_block.get_type ().get ());\n+  }\n+\n private:\n   ResolveTopLevel () : ResolverBase (UNKNOWN_NODEID) {}\n };"}, {"sha": "258524b8a928367798bacec68849392f3bd2bcb1", "filename": "gcc/rust/resolve/rust-ast-resolve-type.h", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h?ref=419677348e1c1e6092e74f55b3a7326a595d6114", "patch": "@@ -28,14 +28,19 @@ namespace Resolver {\n class ResolveType : public ResolverBase\n {\n public:\n-  static void go (AST::Type *type, NodeId parent)\n+  static bool go (AST::Type *type, NodeId parent)\n   {\n     ResolveType resolver (parent);\n     type->accept_vis (resolver);\n+    if (!resolver.ok)\n+      rust_error_at (type->get_locus_slow (), \"unresolved type\");\n+\n+    return resolver.ok;\n   };\n \n   void visit (AST::BareFunctionType &fntype)\n   {\n+    ok = true;\n     for (auto &param : fntype.get_function_params ())\n       ResolveType::go (param.get_type ().get (), fntype.get_node_id ());\n \n@@ -45,6 +50,7 @@ class ResolveType : public ResolverBase\n \n   void visit (AST::TupleType &tuple)\n   {\n+    ok = true;\n     if (tuple.is_unit_type ())\n       {\n \tresolved_node = resolver->get_unit_type_node_id ();\n@@ -65,6 +71,8 @@ class ResolveType : public ResolverBase\n \t\t       path.as_string ().c_str ());\n \treturn;\n       }\n+\n+    ok = true;\n     resolver->insert_resolved_type (path.get_node_id (), resolved_node);\n     resolver->insert_new_definition (path.get_node_id (),\n \t\t\t\t     Definition{path.get_node_id (), parent});\n@@ -76,7 +84,9 @@ class ResolveType : public ResolverBase\n   }\n \n private:\n-  ResolveType (NodeId parent) : ResolverBase (parent) {}\n+  ResolveType (NodeId parent) : ResolverBase (parent), ok (false) {}\n+\n+  bool ok;\n };\n \n } // namespace Resolver"}, {"sha": "281049dceb03e1c75541d0cbc8a98351d619e8db", "filename": "gcc/rust/rust-session-manager.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Frust-session-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Frust-session-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.cc?ref=419677348e1c1e6092e74f55b3a7326a595d6114", "patch": "@@ -550,8 +550,8 @@ Session::parse_file (const char *filename)\n   type_resolution (hir);\n \n   // FIXME this needs an option of itself\n-  auto buf = Resolver::TypeResolverDump::go (hir);\n-  fprintf (stderr, \"%s\\n\", buf.c_str ());\n+  // auto buf = Resolver::TypeResolverDump::go (hir);\n+  // fprintf (stderr, \"%s\\n\", buf.c_str ());\n \n   if (saw_errors ())\n     return;"}, {"sha": "8de1474a055d5e336ee39b3c3b8ec8adf1987988", "filename": "gcc/rust/typecheck/rust-hir-type-check-base.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h?ref=419677348e1c1e6092e74f55b3a7326a595d6114", "patch": "@@ -55,7 +55,6 @@ class TypeCheckBase : public HIR::HIRVisitor\n   //  virtual void visit(TraitItem& trait_item) {}\n   //  virtual void visit(InherentImplItem& inherent_impl_item) {}\n   //  virtual void visit(TraitImplItem& trait_impl_item) {}\n-  virtual void visit (HIR::MacroInvocationSemi &macro) {}\n \n   // rust-path.h\n   virtual void visit (HIR::PathInExpression &path) {}"}, {"sha": "1df02d11c85a011c6d6f96ce328677a18ea2ac2e", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 33, "deletions": 2, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=419677348e1c1e6092e74f55b3a7326a595d6114", "patch": "@@ -38,8 +38,10 @@ class TypeCheckExpr : public TypeCheckBase\n \n     if (resolver.infered == nullptr)\n       {\n-\tresolver.infered\n-\t  = new TyTy::UnitType (expr->get_mappings ().get_hirid ());\n+\trust_error_at (expr->get_locus_slow (),\n+\t\t       \"failed to resolve type for %s\\n\",\n+\t\t       expr->as_string ().c_str ());\n+\treturn nullptr;\n       }\n \n     auto ref = expr->get_mappings ().get_hirid ();\n@@ -769,6 +771,35 @@ class TypeCheckExpr : public TypeCheckBase\n     infered = resolved->get_field_type ();\n   }\n \n+  void visit (HIR::PathInExpression &expr)\n+  {\n+    NodeId ast_node_id = expr.get_mappings ().get_nodeid ();\n+\n+    // then lookup the reference_node_id\n+    NodeId ref_node_id;\n+    if (!resolver->lookup_resolved_name (ast_node_id, &ref_node_id))\n+      {\n+\tif (!resolver->lookup_resolved_type (ast_node_id, &ref_node_id))\n+\t  {\n+\t    rust_error_at (expr.get_locus (),\n+\t\t\t   \"Failed to lookup reference for node: %s\",\n+\t\t\t   expr.as_string ().c_str ());\n+\t    return;\n+\t  }\n+      }\n+\n+    // node back to HIR\n+    HirId ref;\n+    if (!mappings->lookup_node_to_hir (expr.get_mappings ().get_crate_num (),\n+\t\t\t\t       ref_node_id, &ref))\n+      {\n+\trust_error_at (expr.get_locus (), \"reverse lookup failure\");\n+\treturn;\n+      }\n+\n+    context->lookup_type (ref, &infered);\n+  }\n+\n private:\n   TypeCheckExpr (bool is_final_expr)\n     : TypeCheckBase (), infered (nullptr), infered_array_elems (nullptr),"}, {"sha": "abaee73aa242d59c36ef1795e9be6a74b709e616", "filename": "gcc/rust/typecheck/rust-hir-type-check-implitem.h", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h?ref=419677348e1c1e6092e74f55b3a7326a595d6114", "patch": "@@ -0,0 +1,149 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_TYPE_CHECK_IMPLITEM_H\n+#define RUST_HIR_TYPE_CHECK_IMPLITEM_H\n+\n+#include \"rust-hir-type-check-base.h\"\n+#include \"rust-hir-full.h\"\n+#include \"rust-hir-type-check-type.h\"\n+#include \"rust-hir-type-check-expr.h\"\n+#include \"rust-tyty.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class TypeCheckTopLevelImplItem : public TypeCheckBase\n+{\n+public:\n+  static void Resolve (HIR::InherentImplItem *item)\n+  {\n+    TypeCheckTopLevelImplItem resolver;\n+    item->accept_vis (resolver);\n+  }\n+\n+  void visit (HIR::ConstantItem &constant)\n+  {\n+    TyTy::TyBase *type = TypeCheckType::Resolve (constant.get_type ());\n+    TyTy::TyBase *expr_type = TypeCheckExpr::Resolve (constant.get_expr ());\n+\n+    context->insert_type (constant.get_mappings (), type->combine (expr_type));\n+  }\n+\n+  void visit (HIR::Function &function)\n+  {\n+    TyTy::TyBase *ret_type = nullptr;\n+    if (!function.has_function_return_type ())\n+      ret_type = new TyTy::UnitType (function.get_mappings ().get_hirid ());\n+    else\n+      {\n+\tauto resolved = TypeCheckType::Resolve (function.return_type.get ());\n+\tif (resolved == nullptr)\n+\t  {\n+\t    rust_error_at (function.get_locus (),\n+\t\t\t   \"failed to resolve return type\");\n+\t    return;\n+\t  }\n+\n+\tret_type = resolved->clone ();\n+\tret_type->set_ref (function.return_type->get_mappings ().get_hirid ());\n+      }\n+\n+    std::vector<std::pair<HIR::Pattern *, TyTy::TyBase *> > params;\n+    for (auto &param : function.function_params)\n+      {\n+\t// get the name as well required for later on\n+\tauto param_tyty = TypeCheckType::Resolve (param.get_type ());\n+\tparams.push_back (\n+\t  std::pair<HIR::Pattern *, TyTy::TyBase *> (param.get_param_name (),\n+\t\t\t\t\t\t     param_tyty));\n+\n+\tcontext->insert_type (param.get_mappings (), param_tyty);\n+      }\n+\n+    auto fnType = new TyTy::FnType (function.get_mappings ().get_hirid (),\n+\t\t\t\t    params, ret_type);\n+    context->insert_type (function.get_mappings (), fnType);\n+  }\n+\n+private:\n+  TypeCheckTopLevelImplItem () : TypeCheckBase () {}\n+};\n+\n+class TypeCheckImplItem : public TypeCheckBase\n+{\n+public:\n+  static void Resolve (HIR::InherentImplItem *item, TyTy::TyBase *self)\n+  {\n+    TypeCheckImplItem resolver (self);\n+    item->accept_vis (resolver);\n+  }\n+\n+  void visit (HIR::Function &function)\n+  {\n+    TyTy::TyBase *lookup;\n+    if (!context->lookup_type (function.get_mappings ().get_hirid (), &lookup))\n+      {\n+\trust_error_at (function.locus, \"failed to lookup function type\");\n+\treturn;\n+      }\n+\n+    if (lookup->get_kind () != TyTy::TypeKind::FNDEF)\n+      {\n+\trust_error_at (function.get_locus (),\n+\t\t       \"found invalid type for function [%s]\",\n+\t\t       lookup->as_string ().c_str ());\n+\treturn;\n+      }\n+\n+    // need to get the return type from this\n+    TyTy::FnType *resolve_fn_type = (TyTy::FnType *) lookup;\n+    auto expected_ret_tyty = resolve_fn_type->return_type ();\n+    context->push_return_type (expected_ret_tyty);\n+\n+    TypeCheckExpr::Resolve (function.function_body.get ());\n+    if (function.function_body->has_expr ())\n+      {\n+\tauto resolved\n+\t  = TypeCheckExpr::Resolve (function.function_body->expr.get ());\n+\n+\tauto ret_resolved = expected_ret_tyty->combine (resolved);\n+\tif (ret_resolved == nullptr)\n+\t  {\n+\t    rust_error_at (function.function_body->expr->get_locus_slow (),\n+\t\t\t   \"failed to resolve final expression\");\n+\t    return;\n+\t  }\n+\n+\tcontext->peek_return_type ()->append_reference (\n+\t  ret_resolved->get_ref ());\n+      }\n+\n+    context->pop_return_type ();\n+  }\n+\n+private:\n+  TypeCheckImplItem (TyTy::TyBase *self) : TypeCheckBase (), self (self) {}\n+\n+  TyTy::TyBase *self;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_HIR_TYPE_CHECK_IMPLITEM_H"}, {"sha": "571d998548d3779c72ce9caf9ba7d6f125f3e838", "filename": "gcc/rust/typecheck/rust-hir-type-check-item.h", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h?ref=419677348e1c1e6092e74f55b3a7326a595d6114", "patch": "@@ -21,6 +21,7 @@\n \n #include \"rust-hir-type-check-base.h\"\n #include \"rust-hir-full.h\"\n+#include \"rust-hir-type-check-implitem.h\"\n #include \"rust-hir-type-check-type.h\"\n #include \"rust-hir-type-check-stmt.h\"\n #include \"rust-tyty-visitor.h\"\n@@ -37,6 +38,21 @@ class TypeCheckItem : public TypeCheckBase\n     item->accept_vis (resolver);\n   }\n \n+  void visit (HIR::InherentImpl &impl_block)\n+  {\n+    TyTy::TyBase *self = nullptr;\n+    if (!context->lookup_type (\n+\t  impl_block.get_type ()->get_mappings ().get_hirid (), &self))\n+      {\n+\trust_error_at (impl_block.get_locus (),\n+\t\t       \"failed to resolve Self for InherentImpl\");\n+\treturn;\n+      }\n+\n+    for (auto &impl_item : impl_block.get_impl_items ())\n+      TypeCheckImplItem::Resolve (impl_item.get (), self);\n+  }\n+\n   void visit (HIR::Function &function)\n   {\n     TyTy::TyBase *lookup;"}, {"sha": "e04284ed9f8fb2779b57172b634381b7aa4d886b", "filename": "gcc/rust/typecheck/rust-hir-type-check-stmt.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h?ref=419677348e1c1e6092e74f55b3a7326a595d6114", "patch": "@@ -56,6 +56,8 @@ class TypeCheckStmt : public TypeCheckBase\n       {\n \tinit_expr_ty\n \t  = TypeCheckExpr::Resolve (stmt.get_init_expr (), is_final_stmt);\n+\tif (init_expr_ty == nullptr)\n+\t  return;\n \n \tinit_expr_ty = init_expr_ty->clone ();\n \tauto ref = init_expr_ty->get_ref ();"}, {"sha": "46b3b0f968e65e1eb11c581f9318cd5a2d440f0b", "filename": "gcc/rust/typecheck/rust-hir-type-check-toplevel.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h?ref=419677348e1c1e6092e74f55b3a7326a595d6114", "patch": "@@ -21,6 +21,7 @@\n \n #include \"rust-hir-type-check-base.h\"\n #include \"rust-hir-full.h\"\n+#include \"rust-hir-type-check-implitem.h\"\n #include \"rust-hir-type-check-type.h\"\n #include \"rust-hir-type-check-expr.h\"\n #include \"rust-tyty.h\"\n@@ -134,6 +135,15 @@ class TypeCheckTopLevel : public TypeCheckBase\n     context->insert_type (function.get_mappings (), fnType);\n   }\n \n+  void visit (HIR::InherentImpl &impl_block)\n+  {\n+    TypeCheckType::Resolve (impl_block.get_type ().get ());\n+    for (auto &impl_item : impl_block.get_impl_items ())\n+      {\n+\tTypeCheckTopLevelImplItem::Resolve (impl_item.get ());\n+      }\n+  }\n+\n private:\n   TypeCheckTopLevel () : TypeCheckBase () {}\n };"}, {"sha": "435af79df7ec436daba99ee1aab83db4f2f0a737", "filename": "gcc/rust/typecheck/rust-hir-type-check.cc", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc?ref=419677348e1c1e6092e74f55b3a7326a595d6114", "patch": "@@ -39,6 +39,13 @@ TypeResolution::Resolve (HIR::Crate &crate)\n   auto context = TypeCheckContext::get ();\n \n   context->iterate ([&] (HirId id, TyTy::TyBase *ty) mutable -> bool {\n+    if (ty->get_kind () == TyTy::TypeKind::ERROR)\n+      {\n+\trust_error_at (mappings->lookup_location (id),\n+\t\t       \"failure in type resolution\");\n+\treturn false;\n+      }\n+\n     // nothing to do\n     if (ty->get_kind () != TyTy::TypeKind::INFER)\n       return true;"}, {"sha": "0d8fffc59633e1ff464d0e30b6460d91b09c9d6c", "filename": "gcc/rust/typecheck/rust-tycheck-dump.h", "status": "modified", "additions": 33, "deletions": 3, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Ftypecheck%2Frust-tycheck-dump.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Ftypecheck%2Frust-tycheck-dump.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tycheck-dump.h?ref=419677348e1c1e6092e74f55b3a7326a595d6114", "patch": "@@ -37,6 +37,30 @@ class TypeResolverDump : public TypeCheckBase\n     return dumper.dump;\n   }\n \n+  void visit (HIR::InherentImpl &impl_block)\n+  {\n+    dump += indent () + \"impl \"\n+\t    + type_string (impl_block.get_type ()->get_mappings ()) + \" {\\n\";\n+    indentation_level++;\n+\n+    for (auto &impl_item : impl_block.get_impl_items ())\n+      {\n+\timpl_item->accept_vis (*this);\n+\tdump += \"\\n\";\n+      }\n+\n+    indentation_level--;\n+    dump += indent () + \"}\\n\";\n+  }\n+\n+  void visit (HIR::ConstantItem &constant)\n+  {\n+    dump += indent () + \"constant \" + constant.get_identifier () + \":\"\n+\t    + type_string (constant.get_mappings ()) + \" = \";\n+    constant.get_expr ()->accept_vis (*this);\n+    dump += \";\\n\";\n+  }\n+\n   void visit (HIR::Function &function)\n   {\n     dump += indent () + \"fn \" + function.function_name + \" \"\n@@ -54,13 +78,15 @@ class TypeResolverDump : public TypeCheckBase\n     indentation_level++;\n \n     expr.iterate_stmts ([&] (HIR::Stmt *s) mutable -> bool {\n+      dump += indent ();\n       s->accept_vis (*this);\n       dump += \";\\n\";\n       return true;\n     });\n \n     if (expr.has_expr () && expr.tail_expr_reachable ())\n       {\n+\tdump += indent ();\n \texpr.expr->accept_vis (*this);\n \tdump += \";\\n\";\n       }\n@@ -70,7 +96,7 @@ class TypeResolverDump : public TypeCheckBase\n \n   void visit (HIR::LetStmt &stmt)\n   {\n-    dump += indent () + \"let \" + stmt.get_pattern ()->as_string () + \":\"\n+    dump += \"let \" + stmt.get_pattern ()->as_string () + \":\"\n \t    + type_string (stmt.get_mappings ());\n     if (stmt.has_init_expr ())\n       {\n@@ -81,13 +107,11 @@ class TypeResolverDump : public TypeCheckBase\n \n   void visit (HIR::ExprStmtWithBlock &stmt)\n   {\n-    dump += indent ();\n     stmt.get_expr ()->accept_vis (*this);\n   }\n \n   void visit (HIR::ExprStmtWithoutBlock &stmt)\n   {\n-    dump += indent ();\n     stmt.get_expr ()->accept_vis (*this);\n   }\n \n@@ -136,6 +160,11 @@ class TypeResolverDump : public TypeCheckBase\n     dump += \")\";\n   }\n \n+  void visit (HIR::PathInExpression &expr)\n+  {\n+    dump += type_string (expr.get_mappings ());\n+  }\n+\n protected:\n   std::string type_string (const Analysis::NodeMapping &mappings)\n   {\n@@ -152,6 +181,7 @@ class TypeResolverDump : public TypeCheckBase\n     buf += \"]\";\n \n     return \"<\" + lookup->as_string ()\n+\t   + \" HIRID: \" + std::to_string (mappings.get_hirid ())\n \t   + \" RF:\" + std::to_string (lookup->get_ref ()) + \" TF:\"\n \t   + std::to_string (lookup->get_ty_ref ()) + +\" - \" + buf + \">\";\n   }"}, {"sha": "eb55581a450d7822abb70f23b4cc1195ead5d8fc", "filename": "gcc/rust/util/rust-hir-map.cc", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Futil%2Frust-hir-map.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Futil%2Frust-hir-map.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-hir-map.cc?ref=419677348e1c1e6092e74f55b3a7326a595d6114", "patch": "@@ -258,6 +258,30 @@ Mappings::lookup_hir_item (CrateNum crateNum, HirId id)\n   return iy->second;\n }\n \n+void\n+Mappings::insert_hir_implitem (CrateNum crateNum, HirId id,\n+\t\t\t       HIR::InherentImplItem *item)\n+{\n+  rust_assert (lookup_hir_implitem (crateNum, id) == nullptr);\n+\n+  hirImplItemMappings[crateNum][id] = item;\n+  nodeIdToHirMappings[crateNum][item->get_impl_mappings ().get_nodeid ()] = id;\n+}\n+\n+HIR::InherentImplItem *\n+Mappings::lookup_hir_implitem (CrateNum crateNum, HirId id)\n+{\n+  auto it = hirImplItemMappings.find (crateNum);\n+  if (it == hirImplItemMappings.end ())\n+    return nullptr;\n+\n+  auto iy = it->second.find (id);\n+  if (iy == it->second.end ())\n+    return nullptr;\n+\n+  return iy->second;\n+}\n+\n void\n Mappings::insert_hir_expr (CrateNum crateNum, HirId id, HIR::Expr *expr)\n {"}, {"sha": "f81cee6403e95bdd73769d2166c7a8c4bd8f42b1", "filename": "gcc/rust/util/rust-hir-map.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Futil%2Frust-hir-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Frust%2Futil%2Frust-hir-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-hir-map.h?ref=419677348e1c1e6092e74f55b3a7326a595d6114", "patch": "@@ -109,6 +109,10 @@ class Mappings\n   void insert_hir_item (CrateNum crateNum, HirId id, HIR::Item *item);\n   HIR::Item *lookup_hir_item (CrateNum crateNum, HirId id);\n \n+  void insert_hir_implitem (CrateNum crateNum, HirId id,\n+\t\t\t    HIR::InherentImplItem *item);\n+  HIR::InherentImplItem *lookup_hir_implitem (CrateNum crateNum, HirId id);\n+\n   void insert_hir_expr (CrateNum crateNum, HirId id, HIR::Expr *expr);\n   HIR::Expr *lookup_hir_expr (CrateNum crateNum, HirId id);\n \n@@ -170,6 +174,8 @@ class Mappings\n   std::map<CrateNum, std::map<HirId, HIR::FunctionParam *> > hirParamMappings;\n   std::map<CrateNum, std::map<HirId, HIR::StructExprField *> >\n     hirStructFieldMappings;\n+  std::map<CrateNum, std::map<HirId, HIR::InherentImplItem *> >\n+    hirImplItemMappings;\n \n   // location info\n   std::map<CrateNum, std::map<NodeId, Location> > locations;"}, {"sha": "d67afa187b1574c3baa36e017d6b5d7466d36c67", "filename": "gcc/testsuite/rust.test/compilable/impl_block1.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fimpl_block1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fimpl_block1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fimpl_block1.rs?ref=419677348e1c1e6092e74f55b3a7326a595d6114", "patch": "@@ -0,0 +1,23 @@\n+struct Foo(i32, bool);\n+\n+impl Foo {\n+    fn new(a: i32, b: bool) -> Foo {\n+        Foo(a, b)\n+    }\n+\n+    fn test2() -> i32 {\n+        test_forward_decl()\n+    }\n+}\n+\n+fn test_forward_decl() -> i32 {\n+    123\n+}\n+\n+fn main() {\n+    let a;\n+    a = Foo::new(1, true);\n+\n+    let b;\n+    b = Foo::test2();\n+}"}, {"sha": "0ed592d07be1cec800ff6a81081432a95363445e", "filename": "gcc/testsuite/rust.test/compilable/impl_block2.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fimpl_block2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/419677348e1c1e6092e74f55b3a7326a595d6114/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fimpl_block2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fimpl_block2.rs?ref=419677348e1c1e6092e74f55b3a7326a595d6114", "patch": "@@ -0,0 +1,28 @@\n+struct Foo(i32, bool);\n+\n+impl Foo {\n+    const number: i32 = 456;\n+\n+    fn new(a: i32, b: bool) -> Foo {\n+        Foo(a, b)\n+    }\n+\n+    fn test2() -> i32 {\n+        test_forward_decl()\n+    }\n+}\n+\n+fn test_forward_decl() -> i32 {\n+    123\n+}\n+\n+fn main() {\n+    let a;\n+    a = Foo::new(1, true);\n+\n+    let b;\n+    b = Foo::test2();\n+\n+    let c;\n+    c = Foo::new(Foo::number, true);\n+}"}]}