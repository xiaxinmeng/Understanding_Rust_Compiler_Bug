{"sha": "b697aed40f6fd83d37a81bdaece4369b434b9555", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjY5N2FlZDQwZjZmZDgzZDM3YTgxYmRhZWNlNDM2OWI0MzRiOTU1NQ==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2007-01-12T00:30:38Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2007-01-12T00:30:38Z"}, "message": "tree-ssa-loop-ivopts.c (extract_cond_operands): Split from find_interesting_uses_cond.\n\n\t* tree-ssa-loop-ivopts.c (extract_cond_operands): Split from\n\tfind_interesting_uses_cond.\n\t(find_interesting_uses_cond): Use extract_cond_operands.\n\t(rewrite_use_compare): Use extract_cond_operands and\n\tforce_gimple_operand_bsi.  Do not call update_stmt.\n\t(determine_use_iv_cost_condition): Use extract_cond_operands.\n\tReturn cheaper of using original bound and changing the exit bound.\n\n\t* gcc.dg/tree-ssa/loop-22.c: New test.\n\nFrom-SVN: r120697", "tree": {"sha": "aed9d0f595d8828a2ea41ab83bbc721e5a71ea58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aed9d0f595d8828a2ea41ab83bbc721e5a71ea58"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b697aed40f6fd83d37a81bdaece4369b434b9555", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b697aed40f6fd83d37a81bdaece4369b434b9555", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b697aed40f6fd83d37a81bdaece4369b434b9555", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b697aed40f6fd83d37a81bdaece4369b434b9555/comments", "author": null, "committer": null, "parents": [{"sha": "662c02b33c9ae617f9b25934c6221fa16ad61a05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/662c02b33c9ae617f9b25934c6221fa16ad61a05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/662c02b33c9ae617f9b25934c6221fa16ad61a05"}], "stats": {"total": 239, "additions": 149, "deletions": 90}, "files": [{"sha": "5c4277df79dc46657557240c6ff757062e1046b2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b697aed40f6fd83d37a81bdaece4369b434b9555/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b697aed40f6fd83d37a81bdaece4369b434b9555/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b697aed40f6fd83d37a81bdaece4369b434b9555", "patch": "@@ -1,3 +1,13 @@\n+2007-01-11  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\t* tree-ssa-loop-ivopts.c (extract_cond_operands): Split from\n+\tfind_interesting_uses_cond.\n+\t(find_interesting_uses_cond): Use extract_cond_operands.\n+\t(rewrite_use_compare): Use extract_cond_operands and\n+\tforce_gimple_operand_bsi.  Do not call update_stmt.\n+\t(determine_use_iv_cost_condition): Use extract_cond_operands.\n+\tReturn cheaper of using original bound and changing the exit bound.\n+\n 2007-01-11  Zdenek Dvorak <dvorakz@suse.cz>\n \n \tPR tree-optimization/29516"}, {"sha": "1ad561da6c74c59b6afa2a0d7b6bd244c17d65f4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b697aed40f6fd83d37a81bdaece4369b434b9555/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b697aed40f6fd83d37a81bdaece4369b434b9555/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b697aed40f6fd83d37a81bdaece4369b434b9555", "patch": "@@ -1,3 +1,7 @@\n+2007-01-11  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\t* gcc.dg/tree-ssa/loop-22.c: New test.\n+\n 2007-01-11  Zdenek Dvorak <dvorakz@suse.cz>\n \n \tPR tree-optimization/29516"}, {"sha": "be8cdcc77d42bd551ba02051da6663f1fc4a216f", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-22.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b697aed40f6fd83d37a81bdaece4369b434b9555/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-22.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b697aed40f6fd83d37a81bdaece4369b434b9555/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-22.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-22.c?ref=b697aed40f6fd83d37a81bdaece4369b434b9555", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-options \"-O2 -fdump-tree-final_cleanup\" } */\n+\n+int a[100];\n+\n+void test (int n)\n+{\n+  int i;\n+\n+  for (i = 0; i < n; i += 3)\n+    a[i] = i;\n+}\n+\n+/* We used to replace the exit test \"i < n\" by \"i != ((n-1)/3) * 3 + 1\".  Although\n+   correct, this transformation is obviously harmful.  */\n+\n+/* { dg-final { scan-tree-dump-times \"/\" 0 \"final_cleanup\" } } */\n+/* { dg-final { cleanup-tree-dump \"final_cleanup\" } } */"}, {"sha": "65f1b84df14e99f602408e9e77e04f2eb2a0de7e", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 118, "deletions": 90, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b697aed40f6fd83d37a81bdaece4369b434b9555/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b697aed40f6fd83d37a81bdaece4369b434b9555/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=b697aed40f6fd83d37a81bdaece4369b434b9555", "patch": "@@ -1183,67 +1183,96 @@ find_interesting_uses_op (struct ivopts_data *data, tree op)\n   return use;\n }\n \n-/* Checks whether the condition *COND_P in STMT is interesting\n-   and if so, records it.  */\n-\n-static void\n-find_interesting_uses_cond (struct ivopts_data *data, tree stmt, tree *cond_p)\n-{\n-  tree *op0_p;\n-  tree *op1_p;\n-  struct iv *iv0 = NULL, *iv1 = NULL, *civ;\n-  struct iv const_iv;\n-  tree zero = integer_zero_node;\n+/* Given a condition *COND_P, checks whether it is a compare of an induction\n+   variable and an invariant.  If this is the case, CONTROL_VAR is set\n+   to location of the iv, BOUND to the location of the invariant,\n+   IV_VAR and IV_BOUND are set to the corresponding induction variable\n+   descriptions, and true is returned.  If this is not the case,\n+   CONTROL_VAR and BOUND are set to the arguments of the condition and\n+   false is returned.  */\n \n+static bool\n+extract_cond_operands (struct ivopts_data *data, tree *cond_p,\n+\t\t       tree **control_var, tree **bound,\n+\t\t       struct iv **iv_var, struct iv **iv_bound)\n+{\n+  /* The nodes returned when COND has just one operand.  Note that you should\n+     not modify anything in BOUND or IV_BOUND because of this.  */\n+  static struct iv const_iv;\n+  static tree zero;\n+  tree cond = *cond_p;\n+  tree *op0 = &zero, *op1 = &zero, *tmp_op;\n+  struct iv *iv0 = &const_iv, *iv1 = &const_iv, *tmp_iv;\n+  bool ret = false;\n+\n+  zero = integer_zero_node;\n   const_iv.step = integer_zero_node;\n \n-  if (TREE_CODE (*cond_p) != SSA_NAME\n-      && !COMPARISON_CLASS_P (*cond_p))\n-    return;\n-\n-  if (TREE_CODE (*cond_p) == SSA_NAME)\n+  if (TREE_CODE (cond) == SSA_NAME)\n     {\n-      op0_p = cond_p;\n-      op1_p = &zero;\n+      op0 = cond_p;\n+      iv0 = get_iv (data, cond);\n+      ret = (iv0 && !integer_zerop (iv0->step));\n+      goto end;\n     }\n-  else\n+\n+  if (!COMPARISON_CLASS_P (cond))\n     {\n-      op0_p = &TREE_OPERAND (*cond_p, 0);\n-      op1_p = &TREE_OPERAND (*cond_p, 1);\n+      op0 = cond_p;\n+      goto end;\n     }\n \n-  if (TREE_CODE (*op0_p) == SSA_NAME)\n-    iv0 = get_iv (data, *op0_p);\n-  else\n-    iv0 = &const_iv;\n+  op0 = &TREE_OPERAND (cond, 0);\n+  op1 = &TREE_OPERAND (cond, 1);\n+  if (TREE_CODE (*op0) == SSA_NAME)\n+    iv0 = get_iv (data, *op0);\n+  if (TREE_CODE (*op1) == SSA_NAME)\n+    iv1 = get_iv (data, *op1);\n \n-  if (TREE_CODE (*op1_p) == SSA_NAME)\n-    iv1 = get_iv (data, *op1_p);\n-  else\n-    iv1 = &const_iv;\n-\n-  if (/* When comparing with non-invariant value, we may not do any senseful\n-\t induction variable elimination.  */\n-      (!iv0 || !iv1)\n-      /* Eliminating condition based on two ivs would be nontrivial.\n-\t ??? TODO -- it is not really important to handle this case.  */\n-      || (!integer_zerop (iv0->step)\n-\t  && !integer_zerop (iv1->step)))\n-    {\n-      find_interesting_uses_op (data, *op0_p);\n-      find_interesting_uses_op (data, *op1_p);\n-      return;\n+  /* Exactly one of the compared values must be an iv, and the other one must\n+     be an invariant.  */\n+  if (!iv0 || !iv1)\n+    goto end;\n+\n+  if (integer_zerop (iv0->step))\n+    {\n+      /* Control variable may be on the other side.  */\n+      tmp_op = op0; op0 = op1; op1 = tmp_op;\n+      tmp_iv = iv0; iv0 = iv1; iv1 = tmp_iv;\n     }\n+  ret = !integer_zerop (iv0->step) && integer_zerop (iv1->step);\n+\n+end:\n+  if (control_var)\n+    *control_var = op0;;\n+  if (iv_var)\n+    *iv_var = iv0;;\n+  if (bound)\n+    *bound = op1;\n+  if (iv_bound)\n+    *iv_bound = iv1;\n+\n+  return ret;\n+}\n+\n+/* Checks whether the condition *COND_P in STMT is interesting\n+   and if so, records it.  */\n+\n+static void\n+find_interesting_uses_cond (struct ivopts_data *data, tree stmt, tree *cond_p)\n+{\n+  tree *var_p, *bound_p;\n+  struct iv *var_iv, *civ;\n \n-  if (integer_zerop (iv0->step)\n-      && integer_zerop (iv1->step))\n+  if (!extract_cond_operands (data, cond_p, &var_p, &bound_p, &var_iv, NULL))\n     {\n-      /* If both are invariants, this is a work for unswitching.  */\n+      find_interesting_uses_op (data, *var_p);\n+      find_interesting_uses_op (data, *bound_p);\n       return;\n     }\n \n   civ = XNEW (struct iv);\n-  *civ = integer_zerop (iv0->step) ? *iv1: *iv0;\n+  *civ = *var_iv;\n   record_use (data, cond_p, civ, stmt, USE_COMPARE);\n }\n \n@@ -3672,9 +3701,11 @@ static bool\n determine_use_iv_cost_condition (struct ivopts_data *data,\n \t\t\t\t struct iv_use *use, struct iv_cand *cand)\n {\n-  tree bound = NULL_TREE, op, cond;\n-  bitmap depends_on = NULL;\n-  unsigned cost;\n+  tree bound = NULL_TREE;\n+  struct iv *cmp_iv;\n+  bitmap depends_on_elim = NULL, depends_on_express = NULL, depends_on;\n+  unsigned elim_cost, express_cost, cost;\n+  bool ok;\n \n   /* Only consider real candidates.  */\n   if (!cand->iv)\n@@ -3683,35 +3714,44 @@ determine_use_iv_cost_condition (struct ivopts_data *data,\n       return false;\n     }\n \n+  /* Try iv elimination.  */\n   if (may_eliminate_iv (data, use, cand, &bound))\n-    {\n-      cost = force_var_cost (data, bound, &depends_on);\n+    elim_cost = force_var_cost (data, bound, &depends_on_elim);\n+  else\n+    elim_cost = INFTY;\n \n-      set_use_iv_cost (data, use, cand, cost, depends_on, bound);\n-      return cost != INFTY;\n-    }\n+  /* Try expressing the original giv.  If it is compared with an invariant,\n+     note that we cannot get rid of it.  */\n+  ok = extract_cond_operands (data, use->op_p, NULL, NULL, NULL, &cmp_iv);\n+  gcc_assert (ok);\n \n-  /* The induction variable elimination failed; just express the original\n-     giv.  If it is compared with an invariant, note that we cannot get\n-     rid of it.  */\n-  cost = get_computation_cost (data, use, cand, false, &depends_on);\n+  express_cost = get_computation_cost (data, use, cand, false,\n+\t\t\t\t       &depends_on_express);\n+  fd_ivopts_data = data;\n+  walk_tree (&cmp_iv->base, find_depends, &depends_on_express, NULL);\n \n-  cond = *use->op_p;\n-  if (TREE_CODE (cond) != SSA_NAME)\n+  /* Choose the better approach.  */\n+  if (elim_cost < express_cost)\n     {\n-      op = TREE_OPERAND (cond, 0);\n-      if (TREE_CODE (op) == SSA_NAME\n-\t  && !integer_zerop (get_iv (data, op)->step))\n-\top = TREE_OPERAND (cond, 1);\n-      if (TREE_CODE (op) == SSA_NAME)\n-\t{\n-\t  op = get_iv (data, op)->base;\n-\t  fd_ivopts_data = data;\n-\t  walk_tree (&op, find_depends, &depends_on, NULL);\n-\t}\n+      cost = elim_cost;\n+      depends_on = depends_on_elim;\n+      depends_on_elim = NULL;\n+    }\n+  else\n+    {\n+      cost = express_cost;\n+      depends_on = depends_on_express;\n+      depends_on_express = NULL;\n+      bound = NULL_TREE;\n     }\n \n-  set_use_iv_cost (data, use, cand, cost, depends_on, NULL);\n+  set_use_iv_cost (data, use, cand, cost, depends_on, bound);\n+\n+  if (depends_on_elim)\n+    BITMAP_FREE (depends_on_elim);\n+  if (depends_on_express)\n+    BITMAP_FREE (depends_on_express);\n+\n   return cost != INFTY;\n }\n \n@@ -5087,28 +5127,23 @@ static void\n rewrite_use_compare (struct ivopts_data *data,\n \t\t     struct iv_use *use, struct iv_cand *cand)\n {\n-  tree comp;\n-  tree *op_p, cond, op, stmts, bound;\n+  tree comp, *var_p, op, bound;\n   block_stmt_iterator bsi = bsi_for_stmt (use->stmt);\n   enum tree_code compare;\n   struct cost_pair *cp = get_use_iv_cost (data, use, cand);\n-  \n+  bool ok;\n+\n   bound = cp->value;\n   if (bound)\n     {\n       tree var = var_at_stmt (data->current_loop, cand, use->stmt);\n       tree var_type = TREE_TYPE (var);\n \n       compare = iv_elimination_compare (data, use);\n-      bound = fold_convert (var_type, bound);\n-      op = force_gimple_operand (unshare_expr (bound), &stmts,\n-\t\t\t\t true, NULL_TREE);\n-\n-      if (stmts)\n-\tbsi_insert_before (&bsi, stmts, BSI_SAME_STMT);\n+      bound = unshare_expr (fold_convert (var_type, bound));\n+      op = force_gimple_operand_bsi (&bsi, bound, true, NULL_TREE);\n \n       *use->op_p = build2 (compare, boolean_type_node, var, op);\n-      update_stmt (use->stmt);\n       return;\n     }\n \n@@ -5117,17 +5152,10 @@ rewrite_use_compare (struct ivopts_data *data,\n   comp = get_computation (data->current_loop, use, cand);\n   gcc_assert (comp != NULL_TREE);\n \n-  cond = *use->op_p;\n-  op_p = &TREE_OPERAND (cond, 0);\n-  if (TREE_CODE (*op_p) != SSA_NAME\n-      || integer_zerop (get_iv (data, *op_p)->step))\n-    op_p = &TREE_OPERAND (cond, 1);\n-\n-  op = force_gimple_operand (comp, &stmts, true, SSA_NAME_VAR (*op_p));\n-  if (stmts)\n-    bsi_insert_before (&bsi, stmts, BSI_SAME_STMT);\n+  ok = extract_cond_operands (data, use->op_p, &var_p, NULL, NULL, NULL);\n+  gcc_assert (ok);\n \n-  *op_p = op;\n+  *var_p = force_gimple_operand_bsi (&bsi, comp, true, SSA_NAME_VAR (*var_p));\n }\n \n /* Rewrites USE using candidate CAND.  */"}]}