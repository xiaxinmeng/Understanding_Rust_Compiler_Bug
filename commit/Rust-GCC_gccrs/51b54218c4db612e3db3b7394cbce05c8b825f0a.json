{"sha": "51b54218c4db612e3db3b7394cbce05c8b825f0a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTFiNTQyMThjNGRiNjEyZTNkYjNiNzM5NGNiY2UwNWM4YjgyNWYwYQ==", "commit": {"author": {"name": "Bernd Edlinger", "email": "bernd.edlinger@hotmail.de", "date": "2019-10-04T16:21:11Z"}, "committer": {"name": "Bernd Edlinger", "email": "edlinger@gcc.gnu.org", "date": "2019-10-04T16:21:11Z"}, "message": "expr.c (convert_mode_scalar): Remove shadowing local var.\n\n2019-10-04  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n\n        * expr.c (convert_mode_scalar): Remove shadowing local var.\n        (emit_block_move): Rename local vars.\n        (block_move_libcall_safe_for_call_parm): Remove shadowing local var.\n        (emit_push_insn): Rename local vars.\n        (expand_assignment): Fix wrong mode in assign_stack_temp.  Remove\n        shadowing local vars.\n        (store_constructor): Remove shadowing local vars.  Rename local var.\n        (store_field, expand_cond_expr_using_cmove,\n        expand_expr_real_2): Remove shadowing local vars.\n        (expand_expr_real_1,\n        do_store_flag): Remove shadowing local vars.  Rename local vars.\n\nFrom-SVN: r276591", "tree": {"sha": "6b227b7efd4b682c605188ae366ca86f172e82eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6b227b7efd4b682c605188ae366ca86f172e82eb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/51b54218c4db612e3db3b7394cbce05c8b825f0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51b54218c4db612e3db3b7394cbce05c8b825f0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51b54218c4db612e3db3b7394cbce05c8b825f0a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51b54218c4db612e3db3b7394cbce05c8b825f0a/comments", "author": {"login": "bernd-edlinger", "id": 17638929, "node_id": "MDQ6VXNlcjE3NjM4OTI5", "avatar_url": "https://avatars.githubusercontent.com/u/17638929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bernd-edlinger", "html_url": "https://github.com/bernd-edlinger", "followers_url": "https://api.github.com/users/bernd-edlinger/followers", "following_url": "https://api.github.com/users/bernd-edlinger/following{/other_user}", "gists_url": "https://api.github.com/users/bernd-edlinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/bernd-edlinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bernd-edlinger/subscriptions", "organizations_url": "https://api.github.com/users/bernd-edlinger/orgs", "repos_url": "https://api.github.com/users/bernd-edlinger/repos", "events_url": "https://api.github.com/users/bernd-edlinger/events{/privacy}", "received_events_url": "https://api.github.com/users/bernd-edlinger/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b51a085b32f2dae08113e513b4fb1f24071009df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b51a085b32f2dae08113e513b4fb1f24071009df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b51a085b32f2dae08113e513b4fb1f24071009df"}], "stats": {"total": 88, "additions": 47, "deletions": 41}, "files": [{"sha": "2e60943a65c02c0b062bf352a8e76b8e619df3b4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51b54218c4db612e3db3b7394cbce05c8b825f0a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51b54218c4db612e3db3b7394cbce05c8b825f0a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=51b54218c4db612e3db3b7394cbce05c8b825f0a", "patch": "@@ -1,3 +1,17 @@\n+2019-10-04  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n+\n+\t* expr.c (convert_mode_scalar): Remove shadowing local var.\n+\t(emit_block_move): Rename local vars.\n+\t(block_move_libcall_safe_for_call_parm): Remove shadowing local var.\n+\t(emit_push_insn): Rename local vars.\n+\t(expand_assignment): Fix wrong mode in assign_stack_temp.  Remove\n+\tshadowing local vars.\n+\t(store_constructor): Remove shadowing local vars.  Rename local var.\n+\t(store_field, expand_cond_expr_using_cmove,\n+\texpand_expr_real_2): Remove shadowing local vars.\n+\t(expand_expr_real_1,\n+\tdo_store_flag): Remove shadowing local vars.  Rename local vars.\n+\n 2019-10-04  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n \n \t* cgraph.h (FOR_EACH_ALIAS): Avoid shadowing the loop variable."}, {"sha": "124144d9b1e2d6ba1e2186f7fbcce19da780f4ba", "filename": "gcc/expr.c", "status": "modified", "additions": 33, "deletions": 41, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51b54218c4db612e3db3b7394cbce05c8b825f0a/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51b54218c4db612e3db3b7394cbce05c8b825f0a/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=51b54218c4db612e3db3b7394cbce05c8b825f0a", "patch": "@@ -560,7 +560,6 @@ convert_mode_scalar (rtx to, rtx from, int unsignedp)\n \t}\n       else\n \t{\n-\t  scalar_mode intermediate;\n \t  rtx tmp;\n \t  int shift_amount;\n \n@@ -1695,9 +1694,7 @@ emit_block_move (rtx x, rtx y, rtx size, enum block_op_methods method)\n static bool\n block_move_libcall_safe_for_call_parm (void)\n {\n-#if defined (REG_PARM_STACK_SPACE)\n   tree fn;\n-#endif\n \n   /* If arguments are pushed on the stack, then they're safe.  */\n   if (PUSH_ARGS)\n@@ -1720,7 +1717,7 @@ block_move_libcall_safe_for_call_parm (void)\n   {\n     CUMULATIVE_ARGS args_so_far_v;\n     cumulative_args_t args_so_far;\n-    tree fn, arg;\n+    tree arg;\n \n     fn = builtin_decl_implicit (BUILT_IN_MEMCPY);\n     INIT_CUMULATIVE_ARGS (args_so_far_v, TREE_TYPE (fn), NULL_RTX, 0, 3);\n@@ -4482,16 +4479,16 @@ emit_push_insn (rtx x, machine_mode mode, tree type, rtx size,\n \t  /* Get the address of the stack space.\n \t     In this case, we do not deal with EXTRA separately.\n \t     A single stack adjust will do.  */\n-\t  poly_int64 offset;\n+\t  poly_int64 const_args_so_far;\n \t  if (! args_addr)\n \t    {\n \t      temp = push_block (size, extra, where_pad == PAD_DOWNWARD);\n \t      extra = 0;\n \t    }\n-\t  else if (poly_int_rtx_p (args_so_far, &offset))\n+\t  else if (poly_int_rtx_p (args_so_far, &const_args_so_far))\n \t    temp = memory_address (BLKmode,\n \t\t\t\t   plus_constant (Pmode, args_addr,\n-\t\t\t\t\t\t  skip + offset));\n+\t\t\t\t\t\t  skip + const_args_so_far));\n \t  else\n \t    temp = memory_address (BLKmode,\n \t\t\t\t   plus_constant (Pmode,\n@@ -4566,8 +4563,8 @@ emit_push_insn (rtx x, machine_mode mode, tree type, rtx size,\n     {\n       /* Scalar partly in registers.  This case is only supported\n \t for fixed-wdth modes.  */\n-      int size = GET_MODE_SIZE (mode).to_constant ();\n-      size /= UNITS_PER_WORD;\n+      int num_words = GET_MODE_SIZE (mode).to_constant ();\n+      num_words /= UNITS_PER_WORD;\n       int i;\n       int not_stack;\n       /* # bytes of start of argument\n@@ -4614,7 +4611,7 @@ emit_push_insn (rtx x, machine_mode mode, tree type, rtx size,\n       /* Loop over all the words allocated on the stack for this arg.  */\n       /* We can do it by words, because any scalar bigger than a word\n \t has a size a multiple of a word.  */\n-      for (i = size - 1; i >= not_stack; i--)\n+      for (i = num_words - 1; i >= not_stack; i--)\n \tif (i >= not_stack + offset)\n \t  if (!emit_push_insn (operand_subword_force (x, i, mode),\n \t\t\t  word_mode, NULL_TREE, NULL_RTX, align, 0, NULL_RTX,\n@@ -5277,8 +5274,7 @@ expand_assignment (tree to, tree from, bool nontemporal)\n \t\t    }\n \t\t  else\n \t\t    {\n-\t\t      machine_mode to_mode\n-\t\t\t= GET_MODE_INNER (GET_MODE (to_rtx));\n+\t\t      to_mode = GET_MODE_INNER (to_mode);\n \t\t      rtx from_real\n \t\t\t= simplify_gen_subreg (to_mode, result,\n \t\t\t\t\t       TYPE_MODE (TREE_TYPE (from)),\n@@ -5297,7 +5293,7 @@ expand_assignment (tree to, tree from, bool nontemporal)\n \t  else\n \t    {\n \t    concat_store_slow:;\n-\t      rtx temp = assign_stack_temp (to_mode,\n+\t      rtx temp = assign_stack_temp (GET_MODE (to_rtx),\n \t\t\t\t\t    GET_MODE_SIZE (GET_MODE (to_rtx)));\n \t      write_complex_part (temp, XEXP (to_rtx, 0), false);\n \t      write_complex_part (temp, XEXP (to_rtx, 1), true);\n@@ -6461,7 +6457,7 @@ store_constructor (tree exp, rtx target, int cleared, poly_int64 size,\n \t\t&& exp_size >= 0\n \t\t&& bitpos + BITS_PER_WORD <= exp_size * BITS_PER_UNIT)\n \t      {\n-\t\ttree type = TREE_TYPE (value);\n+\t\ttype = TREE_TYPE (value);\n \n \t\tif (TYPE_PRECISION (type) < BITS_PER_WORD)\n \t\t  {\n@@ -6538,7 +6534,6 @@ store_constructor (tree exp, rtx target, int cleared, poly_int64 size,\n \telse\n \t  {\n \t    unsigned HOST_WIDE_INT idx;\n-\t    tree index, value;\n \t    HOST_WIDE_INT count = 0, zero_count = 0;\n \t    need_to_clear = ! const_bounds_p;\n \n@@ -6827,16 +6822,16 @@ store_constructor (tree exp, rtx target, int cleared, poly_int64 size,\n \t    icode = convert_optab_handler (vec_init_optab, mode, emode);\n \t    if (icode != CODE_FOR_nothing)\n \t      {\n-\t\tunsigned int i, n = const_n_elts;\n+\t\tunsigned int n = const_n_elts;\n \n \t\tif (emode != eltmode)\n \t\t  {\n \t\t    n = CONSTRUCTOR_NELTS (exp);\n \t\t    vec_vec_init_p = true;\n \t\t  }\n \t\tvector = rtvec_alloc (n);\n-\t\tfor (i = 0; i < n; i++)\n-\t\t  RTVEC_ELT (vector, i) = CONST0_RTX (emode);\n+\t\tfor (unsigned int k = 0; k < n; k++)\n+\t\t  RTVEC_ELT (vector, k) = CONST0_RTX (emode);\n \t      }\n \t  }\n \n@@ -7157,7 +7152,7 @@ store_field (rtx target, poly_int64 bitsize, poly_int64 bitpos,\n \t word size, we need to load the value (see again store_bit_field).  */\n       if (GET_MODE (temp) == BLKmode && known_le (bitsize, BITS_PER_WORD))\n \t{\n-\t  scalar_int_mode temp_mode = smallest_int_mode_for_size (bitsize);\n+\t  temp_mode = smallest_int_mode_for_size (bitsize);\n \t  temp = extract_bit_field (temp, bitsize, 0, 1, NULL_RTX, temp_mode,\n \t\t\t\t    temp_mode, false, NULL);\n \t}\n@@ -8380,7 +8375,7 @@ expand_cond_expr_using_cmove (tree treeop0 ATTRIBUTE_UNUSED,\n   if (TREE_CODE (treeop0) == SSA_NAME\n       && (srcstmt = get_def_for_expr_class (treeop0, tcc_comparison)))\n     {\n-      tree type = TREE_TYPE (gimple_assign_rhs1 (srcstmt));\n+      type = TREE_TYPE (gimple_assign_rhs1 (srcstmt));\n       enum tree_code cmpcode = gimple_assign_rhs_code (srcstmt);\n       op00 = expand_normal (gimple_assign_rhs1 (srcstmt));\n       op01 = expand_normal (gimple_assign_rhs2 (srcstmt));\n@@ -8390,7 +8385,7 @@ expand_cond_expr_using_cmove (tree treeop0 ATTRIBUTE_UNUSED,\n     }\n   else if (COMPARISON_CLASS_P (treeop0))\n     {\n-      tree type = TREE_TYPE (TREE_OPERAND (treeop0, 0));\n+      type = TREE_TYPE (TREE_OPERAND (treeop0, 0));\n       enum tree_code cmpcode = TREE_CODE (treeop0);\n       op00 = expand_normal (TREE_OPERAND (treeop0, 0));\n       op01 = expand_normal (TREE_OPERAND (treeop0, 1));\n@@ -9684,7 +9679,6 @@ expand_expr_real_2 (sepops ops, rtx target, machine_mode tmode,\n \ttree oprnd0 = treeop0;\n \ttree oprnd1 = treeop1;\n \ttree oprnd2 = treeop2;\n-\trtx op2;\n \n \texpand_operands (oprnd0, oprnd1, NULL_RTX, &op0, &op1, EXPAND_NORMAL);\n \top2 = expand_normal (oprnd2);\n@@ -9698,7 +9692,6 @@ expand_expr_real_2 (sepops ops, rtx target, machine_mode tmode,\n \ttree oprnd0 = treeop0;\n \ttree oprnd1 = treeop1;\n \ttree oprnd2 = treeop2;\n-\trtx op2;\n \n \texpand_operands (oprnd0, oprnd1, NULL_RTX, &op0, &op1, EXPAND_NORMAL);\n \top2 = expand_normal (oprnd2);\n@@ -9712,7 +9705,6 @@ expand_expr_real_2 (sepops ops, rtx target, machine_mode tmode,\n         tree oprnd0 = treeop0;\n         tree oprnd1 = treeop1;\n         tree oprnd2 = treeop2;\n-        rtx op2;\n \n         this_optab = optab_for_tree_code (code, type, optab_default);\n         expand_operands (oprnd0, oprnd1, NULL_RTX, &op0, &op1, EXPAND_NORMAL);\n@@ -9802,8 +9794,8 @@ expand_expr_real_2 (sepops ops, rtx target, machine_mode tmode,\n \t  bitsize = TYPE_PRECISION (TREE_TYPE (treeop1));\n \telse\n \t  bitsize = tree_to_uhwi (TYPE_SIZE (TREE_TYPE (treeop1)));\n-\trtx op0 = expand_normal (treeop0);\n-\trtx op1 = expand_normal (treeop1);\n+\top0 = expand_normal (treeop0);\n+\top1 = expand_normal (treeop1);\n \trtx dst = gen_reg_rtx (mode);\n \temit_move_insn (dst, op0);\n \tstore_bit_field (dst, bitsize, bitpos, 0, 0,\n@@ -10002,7 +9994,7 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n \t{\n \t  rtx r;\n \t  location_t saved_loc = curr_insn_location ();\n-\t  location_t loc = gimple_location (g);\n+\t  loc = gimple_location (g);\n \t  if (loc != UNKNOWN_LOCATION)\n \t    set_curr_insn_location (loc);\n \t  ops.code = gimple_assign_rhs_code (g);\n@@ -10201,9 +10193,9 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n \t   GET_MODE_PRECISION (TYPE_MODE (type)), we need to extend from\n \t   the former to the latter according to the signedness of the\n \t   type.  */\n-\tscalar_int_mode mode = SCALAR_INT_TYPE_MODE (type);\n+\tscalar_int_mode int_mode = SCALAR_INT_TYPE_MODE (type);\n \ttemp = immed_wide_int_const\n-\t  (wi::to_wide (exp, GET_MODE_PRECISION (mode)), mode);\n+\t  (wi::to_wide (exp, GET_MODE_PRECISION (int_mode)), int_mode);\n \treturn temp;\n       }\n \n@@ -10278,9 +10270,9 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n       /* Handle evaluating a complex constant in a CONCAT target.  */\n       if (original_target && GET_CODE (original_target) == CONCAT)\n \t{\n-\t  machine_mode mode = TYPE_MODE (TREE_TYPE (TREE_TYPE (exp)));\n \t  rtx rtarg, itarg;\n \n+\t  mode = TYPE_MODE (TREE_TYPE (TREE_TYPE (exp)));\n \t  rtarg = XEXP (original_target, 0);\n \t  itarg = XEXP (original_target, 1);\n \n@@ -10584,14 +10576,14 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n \t\tif (tree_fits_uhwi_p (index1)\n \t\t    && compare_tree_int (index1, TREE_STRING_LENGTH (init)) < 0)\n \t\t  {\n-\t\t    tree type = TREE_TYPE (TREE_TYPE (init));\n-\t\t    scalar_int_mode mode;\n+\t\t    tree char_type = TREE_TYPE (TREE_TYPE (init));\n+\t\t    scalar_int_mode char_mode;\n \n-\t\t    if (is_int_mode (TYPE_MODE (type), &mode)\n-\t\t\t&& GET_MODE_SIZE (mode) == 1)\n+\t\t    if (is_int_mode (TYPE_MODE (char_type), &char_mode)\n+\t\t\t&& GET_MODE_SIZE (char_mode) == 1)\n \t\t      return gen_int_mode (TREE_STRING_POINTER (init)\n \t\t\t\t\t   [TREE_INT_CST_LOW (index1)],\n-\t\t\t\t\t   mode);\n+\t\t\t\t\t   char_mode);\n \t\t  }\n \t      }\n \t  }\n@@ -10745,8 +10737,7 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n \t\t\trtx op = read_complex_part (op0, i != 0);\n \t\t\tif (GET_CODE (op) == SUBREG)\n \t\t\t  op = force_reg (GET_MODE (op), op);\n-\t\t\trtx temp = gen_lowpart_common (GET_MODE_INNER (mode1),\n-\t\t\t\t\t\t       op);\n+\t\t\ttemp = gen_lowpart_common (GET_MODE_INNER (mode1), op);\n \t\t\tif (temp)\n \t\t\t  op = temp;\n \t\t\telse\n@@ -12138,11 +12129,12 @@ do_store_flag (sepops ops, rtx target, machine_mode mode)\n       && TREE_CODE (arg0) == SSA_NAME\n       && TREE_CODE (arg1) == INTEGER_CST)\n     {\n-      enum tree_code code = maybe_optimize_mod_cmp (ops->code, &arg0, &arg1);\n-      if (code != ops->code)\n+      enum tree_code new_code = maybe_optimize_mod_cmp (ops->code,\n+\t\t\t\t\t\t\t&arg0, &arg1);\n+      if (new_code != ops->code)\n \t{\n \t  struct separate_ops nops = *ops;\n-\t  nops.code = ops->code = code;\n+\t  nops.code = ops->code = new_code;\n \t  nops.op0 = arg0;\n \t  nops.op1 = arg1;\n \t  nops.type = TREE_TYPE (arg0);\n@@ -12245,7 +12237,7 @@ do_store_flag (sepops ops, rtx target, machine_mode mode)\n \t  && integer_pow2p (gimple_assign_rhs2 (srcstmt)))\n \t{\n \t  enum tree_code tcode = code == NE ? NE_EXPR : EQ_EXPR;\n-\t  tree type = lang_hooks.types.type_for_mode (mode, unsignedp);\n+\t  type = lang_hooks.types.type_for_mode (mode, unsignedp);\n \t  tree temp = fold_build2_loc (loc, BIT_AND_EXPR, TREE_TYPE (arg1),\n \t\t\t\t       gimple_assign_rhs1 (srcstmt),\n \t\t\t\t       gimple_assign_rhs2 (srcstmt));"}]}