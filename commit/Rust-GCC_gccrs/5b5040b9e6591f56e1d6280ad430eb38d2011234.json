{"sha": "5b5040b9e6591f56e1d6280ad430eb38d2011234", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWI1MDQwYjllNjU5MWY1NmUxZDYyODBhZDQzMGViMzhkMjAxMTIzNA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-10-20T22:44:58Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-10-20T22:44:58Z"}, "message": "(float_conv_temp): Delete global variable.\n\n(stack_temps): New static array to hold stack temps.\n(offsettable_mem_operand): Delete function.\n(offsettable_addr_operand, rs6000_stack_temp): New functions.\n(output_epilog): Zero stack_temps.\n\nFrom-SVN: r10485", "tree": {"sha": "88922707c62024f2f5ec4d3aef5d0708bf72978d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/88922707c62024f2f5ec4d3aef5d0708bf72978d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5b5040b9e6591f56e1d6280ad430eb38d2011234", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b5040b9e6591f56e1d6280ad430eb38d2011234", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b5040b9e6591f56e1d6280ad430eb38d2011234", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b5040b9e6591f56e1d6280ad430eb38d2011234/comments", "author": null, "committer": null, "parents": [{"sha": "9fe320d7933404a9dd3f2d6a4ecdb849c4ef3fae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fe320d7933404a9dd3f2d6a4ecdb849c4ef3fae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fe320d7933404a9dd3f2d6a4ecdb849c4ef3fae"}], "stats": {"total": 67, "additions": 55, "deletions": 12}, "files": [{"sha": "ad7872d2d5ebb371613fa3b43ea51f33b4e4fcfc", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 55, "deletions": 12, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b5040b9e6591f56e1d6280ad430eb38d2011234/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b5040b9e6591f56e1d6280ad430eb38d2011234/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=5b5040b9e6591f56e1d6280ad430eb38d2011234", "patch": "@@ -75,7 +75,7 @@ int rs6000_pic_labelno;\n int rs6000_sysv_varargs_p;\n \n /* Temporary memory used to convert integer -> float */\n-struct rtx_def *float_conv_temp;\n+static rtx stack_temps[NUM_MACHINE_MODES];\n \n \f\n /* Print the options used in the assembly file.  */\n@@ -486,21 +486,15 @@ easy_fp_constant (op, mode)\n \t  || (low != 0 && input_operand (low, word_mode)));\n }\n \n-/* Return 1 if the operand is an offsettable memory operand.  */\n+/* Return 1 if the operand is an offsettable memory address.  */\n \n int\n-offsettable_mem_operand (op, mode)\n+offsettable_addr_operand (op, mode)\n      register rtx op;\n      enum machine_mode mode;\n {\n-  if (GET_CODE (op) != MEM)\n-    return 0;\n-\n-  if (mode != GET_MODE (op))\n-    return 0;\n-\n   return offsettable_address_p (reload_completed | reload_in_progress,\n-\t\t\t\tmode, XEXP (op, 0));\n+\t\t\t\tmode, op);\n }\n \n /* Return 1 if the operand is either a floating-point register, a pseudo\n@@ -1131,6 +1125,53 @@ expand_builtin_saveregs (args)\n }\n \n \f\n+/* Allocate a stack temp.  Only allocate one stack temp per type for a\n+   function.  */\n+\n+struct rtx_def *\n+rs6000_stack_temp (mode, size)\n+     enum machine_mode mode;\n+     int size;\n+{\n+  rtx temp = stack_temps[ (int)mode ];\n+  rtx addr;\n+\n+  if (temp == NULL_RTX)\n+    {\n+      temp = assign_stack_local (mode, size, 0);\n+      addr = XEXP (temp, 0);\n+\n+      if ((size > 4 && !offsettable_address_p (0, mode, addr))\n+\t  || (size <= 4 && !memory_address_p (mode, addr)))\n+\t{\n+\t  XEXP (temp, 0) = copy_addr_to_reg (addr);\n+\t}\n+\n+      stack_temps[ (int)mode ] = temp;\n+    }\n+\n+  return temp;\n+}\n+\n+\f\n+/* Generate a memory reference for expand_block_move, copying volatile,\n+   and other bits from an original memory reference.  */\n+\n+static rtx\n+expand_block_move_mem (mode, addr, orig_mem)\n+     enum machine_mode mode;\n+     rtx addr;\n+     rtx orig_mem;\n+{\n+  rtx mem = gen_rtx (MEM, mode, addr);\n+  MEM_VOLATILE_P (mem) = MEM_VOLATILE_P (orig_mem);\n+  MEM_IN_STRUCT_P (mem) = MEM_IN_STRUCT_P (orig_mem);\n+  /* CYGNUS LOCAL unaligned-pointers */\n+  MEM_UNALIGNED_P (mem) = MEM_UNALIGNED_P (orig_mem);\n+  /* END CYGNUS LOCAL unaligned-pointers */\n+  return mem;\n+}\n+\n /* Expand a block move operation, and return 1 if successful.  Return 0\n    if we should let the compiler generate normal code.\n \n@@ -2753,9 +2794,11 @@ output_epilog (file, size)\n   rs6000_stack_t *info = rs6000_stack_info ();\n   char *load_reg = (TARGET_64BIT) ? \"\\tld %s,%d(%s)\" : \"\\t{l|lwz} %s,%d(%s)\\n\";\n   rtx insn = get_last_insn ();\n+  int i;\n \n-  /* Forget about the float conversion temporary used.  */\n-  float_conv_temp = NULL_RTX;\n+  /* Forget about any temporaries created */\n+  for (i = 0; i < NUM_MACHINE_MODES; i++)\n+    stack_temps[i] = NULL_RTX;\n \n   /* If the last insn was a BARRIER, we don't have to write anything except\n      the trace table.  */"}]}