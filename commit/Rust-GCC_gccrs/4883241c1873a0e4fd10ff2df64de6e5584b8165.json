{"sha": "4883241c1873a0e4fd10ff2df64de6e5584b8165", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDg4MzI0MWMxODczYTBlNGZkMTBmZjJkZjY0ZGU2ZTU1ODRiODE2NQ==", "commit": {"author": {"name": "Steve Ellcey", "email": "sje@cup.hp.com", "date": "2007-07-25T20:09:07Z"}, "committer": {"name": "Steve Ellcey", "email": "sje@gcc.gnu.org", "date": "2007-07-25T20:09:07Z"}, "message": "ia64.h (HARD_REGNO_NREGS): Handle RFmode.\n\n\t* config/ia64/ia64.h (HARD_REGNO_NREGS): Handle RFmode.\n\t(HARD_REGNO_MODE_OK): Ditto.\n\t(MODES_TIEABLE_P): Ditto.\n\t(HARD_REGNO_CALLER_SAVE_MODE): Ditto.\n\t(CLASS_MAX_NREGS): Ditto.\n\t* config/ia64/ia64.c (ia64_print_operand_address): Add R format.\n\t* config/ia64/ia64.md (divsf3_internal_thr): Removed.\n\t(divdf3_internal_thr): Removed.\n\t* config/ia64/div.md: New file.\n\t* config/ia64/constraints.md: Add H constraint.\n\nFrom-SVN: r126930", "tree": {"sha": "343c461f448bbc8f916d0616c89f86f9bec9c06b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/343c461f448bbc8f916d0616c89f86f9bec9c06b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4883241c1873a0e4fd10ff2df64de6e5584b8165", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4883241c1873a0e4fd10ff2df64de6e5584b8165", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4883241c1873a0e4fd10ff2df64de6e5584b8165", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4883241c1873a0e4fd10ff2df64de6e5584b8165/comments", "author": null, "committer": null, "parents": [{"sha": "be5b01f39353fd3983e7579910d61d4c5a9582de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be5b01f39353fd3983e7579910d61d4c5a9582de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be5b01f39353fd3983e7579910d61d4c5a9582de"}], "stats": {"total": 475, "additions": 351, "deletions": 124}, "files": [{"sha": "0a6bb35696dd714a0a9b89a8dd60ee5f43accb91", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4883241c1873a0e4fd10ff2df64de6e5584b8165/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4883241c1873a0e4fd10ff2df64de6e5584b8165/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4883241c1873a0e4fd10ff2df64de6e5584b8165", "patch": "@@ -1,3 +1,16 @@\n+2007-07-25  Steve Ellcey  <sje@cup.hp.com>\n+\n+\t* config/ia64/ia64.h (HARD_REGNO_NREGS): Handle RFmode.\n+\t(HARD_REGNO_MODE_OK): Ditto.\n+\t(MODES_TIEABLE_P): Ditto.\n+\t(HARD_REGNO_CALLER_SAVE_MODE): Ditto.\n+\t(CLASS_MAX_NREGS): Ditto.\n+\t* config/ia64/ia64.c (ia64_print_operand_address): Add R format.\n+\t* config/ia64/ia64.md (divsf3_internal_thr): Removed.\n+\t(divdf3_internal_thr): Removed.\n+\t* config/ia64/div.md: New file.\n+\t* config/ia64/constraints.md: Add H constraint.\n+\n 2007-07-25  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* sbitmap.c (sbitmap_verify_popcount, sbitmap_alloc_with_popcount,"}, {"sha": "59ee4efd372cbbfd80739195287c3366867f0254", "filename": "gcc/config/ia64/constraints.md", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4883241c1873a0e4fd10ff2df64de6e5584b8165/gcc%2Fconfig%2Fia64%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4883241c1873a0e4fd10ff2df64de6e5584b8165/gcc%2Fconfig%2Fia64%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fconstraints.md?ref=4883241c1873a0e4fd10ff2df64de6e5584b8165", "patch": "@@ -90,6 +90,11 @@\n   (and (match_code \"const_double\")\n        (match_test \"op == CONST0_RTX (mode) || op == CONST1_RTX (mode)\")))\n \n+(define_constraint \"H\"\n+  \"0.0\"\n+  (and (match_code \"const_double\")\n+       (match_test \"op == CONST0_RTX (mode)\")))\n+\n ;; Extra constraints\n \n ;; Note that while this accepts mem, it only accepts non-volatile mem,"}, {"sha": "a4c4721291eb05a583e5c093d6cc3a269f1f51e2", "filename": "gcc/config/ia64/div.md", "status": "added", "additions": 313, "deletions": 0, "changes": 313, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4883241c1873a0e4fd10ff2df64de6e5584b8165/gcc%2Fconfig%2Fia64%2Fdiv.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4883241c1873a0e4fd10ff2df64de6e5584b8165/gcc%2Fconfig%2Fia64%2Fdiv.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fdiv.md?ref=4883241c1873a0e4fd10ff2df64de6e5584b8165", "patch": "@@ -0,0 +1,313 @@\n+\n+;; For the internal conditional math routines:\n+\n+;; operand 0 is always the result\n+;; operand 1 is always the predicate\n+;; operand 2, 3, and sometimes 4 are the input values.\n+;; operand 4 or 5 is the floating point status register to use.\n+;; operand 5 or 6 is the rounding to do. (0 = single, 1 = double, 2 = none)\n+;;\n+;; addrf3_cond   - F0 = F2 + F3\n+;; subrf3_cond   - F0 = F2 - F3\n+;; mulrf3_cond   - F0 = F2 * F3\n+;; nmulrf3_cond  - F0 = - (F2 * F3)\n+;; m1addrf4_cond - F0 = (F2 * F3) + F4\n+;; m1subrf4_cond - F0 = (F2 * F3) - F4\n+;; m2addrf4_cond - F0 = F2 + (F3 * F4)\n+;; m2subrf4_cond - F0 = F2 - (F3 * F4)\n+\n+;; Basic plus/minus/mult operations\n+\n+(define_insn \"addrf3_cond\"\n+  [(set (match_operand:RF 0 \"fr_register_operand\" \"=f,f\")\n+        (if_then_else:RF (ne:RF (match_operand:BI 1 \"register_operand\"  \"c,c\")\n+                                (const_int 0))\n+          (plus:RF\n+            (match_operand:RF 2 \"fr_reg_or_fp01_operand\" \"fG,fG\")\n+            (match_operand:RF 3 \"fr_reg_or_fp01_operand\" \"fG,fG\"))\n+          (match_operand:RF 4 \"fr_reg_or_0_operand\" \"0,H\")))\n+   (use (match_operand:SI 5 \"const_int_operand\" \"\"))\n+   (use (match_operand:SI 6 \"const_int_operand\" \"\"))]\n+  \"\"\n+  \"(%1) fadd%R6.s%5 %0 = %F2, %F3\"\n+  [(set_attr \"itanium_class\" \"fmac\")\n+   (set_attr \"predicable\" \"no\")])\n+\n+(define_insn \"subrf3_cond\"\n+  [(set (match_operand:RF 0 \"fr_register_operand\" \"=f,f\")\n+        (if_then_else:RF (ne:RF (match_operand:BI 1 \"register_operand\"  \"c,c\")\n+                                (const_int 0))\n+          (minus:RF\n+            (match_operand:RF 2 \"fr_reg_or_fp01_operand\" \"fG,fG\")\n+            (match_operand:RF 3 \"fr_reg_or_fp01_operand\" \"fG,fG\"))\n+          (match_operand:RF 4 \"fr_reg_or_0_operand\" \"0,H\")))\n+   (use (match_operand:SI 5 \"const_int_operand\" \"\"))\n+   (use (match_operand:SI 6 \"const_int_operand\" \"\"))]\n+  \"\"\n+  \"(%1) fsub%R6.s%5 %0 = %F2, %F3\"\n+  [(set_attr \"itanium_class\" \"fmac\")\n+   (set_attr \"predicable\" \"no\")])\n+\n+(define_insn \"mulrf3_cond\"\n+  [(set (match_operand:RF 0 \"fr_register_operand\" \"=f,f\")\n+        (if_then_else:RF (ne:RF (match_operand:BI 1 \"register_operand\"  \"c,c\")\n+                                (const_int 0))\n+          (mult:RF\n+            (match_operand:RF 2 \"fr_reg_or_fp01_operand\" \"fG,fG\")\n+            (match_operand:RF 3 \"fr_reg_or_fp01_operand\" \"fG,fG\"))\n+          (match_operand:RF 4 \"fr_reg_or_0_operand\" \"0,H\")))\n+   (use (match_operand:SI 5 \"const_int_operand\" \"\"))\n+   (use (match_operand:SI 6 \"const_int_operand\" \"\"))]\n+  \"\"\n+  \"(%1) fmpy%R6.s%5 %0 = %F2, %F3\"\n+  [(set_attr \"itanium_class\" \"fmac\")\n+   (set_attr \"predicable\" \"no\")])\n+\n+;; neg-mult operation\n+\n+(define_insn \"nmulrf3_cond\"\n+  [(set (match_operand:RF 0 \"fr_register_operand\" \"=f,f\")\n+        (if_then_else:RF (ne:RF (match_operand:BI 1 \"register_operand\"  \"c,c\")\n+                                (const_int 0))\n+          (neg:RF (mult:RF\n+            (match_operand:RF 2 \"fr_reg_or_fp01_operand\" \"fG,fG\")\n+            (match_operand:RF 3 \"fr_reg_or_fp01_operand\" \"fG,fG\")))\n+          (match_operand:RF 4 \"fr_reg_or_0_operand\" \"0,H\")))\n+   (use (match_operand:SI 5 \"const_int_operand\" \"\"))\n+   (use (match_operand:SI 6 \"const_int_operand\" \"\"))]\n+  \"\"\n+  \"(%1) fnmpy%R6.s%5 %0 = %F2, %F3\"\n+  [(set_attr \"itanium_class\" \"fmac\")\n+   (set_attr \"predicable\" \"no\")])\n+\n+;; add-mult/sub-mult operations (mult as op1)\n+\n+(define_insn \"m1addrf4_cond\"\n+  [(set (match_operand:RF 0 \"fr_register_operand\" \"=f,f\")\n+        (if_then_else:RF (ne:RF (match_operand:BI 1 \"register_operand\"  \"c,c\")\n+                                (const_int 0))\n+          (plus:RF\n+            (mult:RF\n+              (match_operand:RF 2 \"fr_reg_or_fp01_operand\" \"fG,fG\")\n+              (match_operand:RF 3 \"fr_reg_or_fp01_operand\" \"fG,fG\"))\n+            (match_operand:RF 4 \"fr_reg_or_fp01_operand\" \"fG,fG\"))\n+          (match_operand:RF 5 \"fr_reg_or_0_operand\" \"0,H\")))\n+   (use (match_operand:SI 6 \"const_int_operand\" \"\"))\n+   (use (match_operand:SI 7 \"const_int_operand\" \"\"))]\n+  \"\"\n+  \"(%1) fma%R7.s%6 %0 = %F2, %F3, %F4\"\n+  [(set_attr \"itanium_class\" \"fmac\")\n+   (set_attr \"predicable\" \"no\")])\n+\n+(define_insn \"m1subrf4_cond\"\n+  [(set (match_operand:RF 0 \"fr_register_operand\" \"=f,f\")\n+        (if_then_else:RF (ne:RF (match_operand:BI 1 \"register_operand\"  \"c,c\")\n+                                (const_int 0))\n+          (minus:RF\n+            (mult:RF\n+              (match_operand:RF 2 \"fr_reg_or_fp01_operand\" \"fG,fG\")\n+              (match_operand:RF 3 \"fr_reg_or_fp01_operand\" \"fG,fG\"))\n+            (match_operand:RF 4 \"fr_reg_or_fp01_operand\" \"fG,fG\"))\n+          (match_operand:RF 5 \"fr_reg_or_0_operand\" \"0,H\")))\n+   (use (match_operand:SI 6 \"const_int_operand\" \"\"))\n+   (use (match_operand:SI 7 \"const_int_operand\" \"\"))]\n+  \"\"\n+  \"(%1) fms%R7.s%6 %0 = %F2, %F3, %F4\"\n+  [(set_attr \"itanium_class\" \"fmac\")\n+   (set_attr \"predicable\" \"no\")])\n+\n+;; add-mult/sub-mult operations (mult as op2)\n+\n+(define_insn \"m2addrf4_cond\"\n+  [(set (match_operand:RF 0 \"fr_register_operand\" \"=f,f\")\n+        (if_then_else:RF (ne:RF (match_operand:BI 1 \"register_operand\"  \"c,c\")\n+                                (const_int 0))\n+          (plus:RF\n+            (match_operand:RF 2 \"fr_reg_or_fp01_operand\" \"fG,fG\")\n+            (mult:RF\n+              (match_operand:RF 3 \"fr_reg_or_fp01_operand\" \"fG,fG\")\n+              (match_operand:RF 4 \"fr_reg_or_fp01_operand\" \"fG,fG\")))\n+          (match_operand:RF 5 \"fr_reg_or_0_operand\" \"0,H\")))\n+   (use (match_operand:SI 6 \"const_int_operand\" \"\"))\n+   (use (match_operand:SI 7 \"const_int_operand\" \"\"))]\n+  \"\"\n+  \"(%1) fma%R7.s%6 %0 = %F3, %F4, %F2\"\n+  [(set_attr \"itanium_class\" \"fmac\")\n+   (set_attr \"predicable\" \"no\")])\n+\n+(define_insn \"m2subrf4_cond\"\n+  [(set (match_operand:RF 0 \"fr_register_operand\" \"=f,f\")\n+        (if_then_else:RF (ne:RF (match_operand:BI 1 \"register_operand\"  \"c,c\")\n+                                (const_int 0))\n+          (minus:RF\n+            (match_operand:RF 2 \"fr_reg_or_fp01_operand\" \"fg,fG\")\n+            (mult:RF\n+              (match_operand:RF 3 \"fr_reg_or_fp01_operand\" \"fg,fG\")\n+              (match_operand:RF 4 \"fr_reg_or_fp01_operand\" \"fg,fG\")))\n+          (match_operand:RF 5 \"fr_reg_or_0_operand\" \"0,H\")))\n+   (use (match_operand:SI 6 \"const_int_operand\" \"\"))\n+   (use (match_operand:SI 7 \"const_int_operand\" \"\"))]\n+  \"\"\n+  \"(%1) fnma%R7.s%6 %0 = %F3, %F4, %F2\"\n+  [(set_attr \"itanium_class\" \"fmac\")\n+   (set_attr \"predicable\" \"no\")])\n+\n+;; Conversions to/from RF and SF/DF/XF\n+;; These conversions should not generate any code but make it possible\n+;; for all the instructions used to implement floating point division\n+;; to be written for RFmode only and to not have to handle multiple\n+;; modes or to have to handle a register in more than one mode.\n+\n+(define_mode_macro SDX_F [SF DF XF])\n+\n+(define_insn \"extend<mode>rf2\"\n+  [(set (match_operand:RF 0 \"fr_register_operand\" \"=f\")\n+        (float_extend:RF (match_operand:SDX_F 1 \"fr_register_operand\" \"f\")))]\n+  \"\"\n+  \"#\"\n+  [(set_attr \"itanium_class\" \"fmisc\")\n+   (set_attr \"predicable\" \"yes\")])\n+\n+(define_split\n+  [(set (match_operand:RF 0 \"fr_register_operand\" \"\")\n+        (float_extend:RF (match_operand:SDX_F 1 \"fr_register_operand\" \"\")))]\n+   \"reload_completed\"\n+   [(set (match_dup 0) (match_dup 2))]\n+{\n+   operands[2] = gen_rtx_REG (RFmode, REGNO (operands[1]));\n+})\n+\n+\n+(define_insn \"truncrf<mode>2\"\n+  [(set (match_operand:SDX_F 0 \"fr_register_operand\" \"=f\")\n+        (float_truncate:SDX_F (match_operand:RF 1 \"fr_register_operand\" \"f\")))]\n+  \"\"\n+  \"#\"\n+  [(set_attr \"itanium_class\" \"fmisc\")\n+   (set_attr \"predicable\" \"yes\")])\n+\n+(define_split\n+  [(set (match_operand:SDX_F 0 \"fr_register_operand\" \"\")\n+        (float_truncate:SDX_F (match_operand:RF 1 \"fr_register_operand\" \"\")))]\n+   \"reload_completed\"\n+   [(set (match_dup 0) (match_dup 2))]\n+{\n+   operands[2] = gen_rtx_REG (<MODE>mode, REGNO (operands[1]));\n+})\n+\n+;; Reciprical approximation\n+\n+(define_insn \"recip_approx_rf\"\n+  [(set (match_operand:RF 0 \"fr_register_operand\" \"=f\")\n+        (div:RF (match_operand:RF 1 \"fr_register_operand\" \"f\")\n+                (match_operand:RF 2 \"fr_register_operand\" \"f\")))\n+   (set (match_operand:BI 3 \"register_operand\" \"=c\")\n+        (unspec:BI [(match_dup 1) (match_dup 2)] UNSPEC_FR_RECIP_APPROX))\n+   (use (match_operand:SI 4 \"const_int_operand\" \"\"))]\n+  \"\"\n+  \"frcpa.s%4 %0, %3 = %1, %2\"\n+  [(set_attr \"itanium_class\" \"fmisc\")\n+   (set_attr \"predicable\" \"no\")])\n+\n+;; Single precision floating point division (maximum throughput algorithm).\n+\n+(define_expand \"divsf3_internal_thr\"\n+  [(set (match_operand:SF 0 \"fr_register_operand\" \"\")\n+        (div:SF (match_operand:SF 1 \"fr_register_operand\" \"\")\n+                (match_operand:SF 2 \"fr_register_operand\" \"\")))]\n+  \"TARGET_INLINE_FLOAT_DIV\"\n+{\n+  rtx y     = gen_reg_rtx (RFmode);\n+  rtx a     = gen_reg_rtx (RFmode);\n+  rtx b     = gen_reg_rtx (RFmode);\n+  rtx e     = gen_reg_rtx (RFmode);\n+  rtx y1    = gen_reg_rtx (RFmode);\n+  rtx y2    = gen_reg_rtx (RFmode);\n+  rtx q     = gen_reg_rtx (RFmode);\n+  rtx r     = gen_reg_rtx (RFmode);\n+  rtx q_res = gen_reg_rtx (RFmode);\n+  rtx cond  = gen_reg_rtx (BImode);\n+  rtx zero    = CONST0_RTX (RFmode);\n+  rtx one     = CONST1_RTX (RFmode);\n+  rtx status0 = CONST0_RTX (SImode);\n+  rtx status1 = CONST1_RTX (SImode);\n+  rtx trunc_sgl = CONST0_RTX (SImode);\n+  rtx trunc_off    = CONST2_RTX (SImode);\n+\n+  /* Empty conversions to put inputs into RFmode.  */\n+  emit_insn (gen_extendsfrf2 (a, operands[1]));\n+  emit_insn (gen_extendsfrf2 (b, operands[2]));\n+  /* y = 1 / b\t\t\t\t*/\n+  emit_insn (gen_recip_approx_rf (y, a, b, cond, status0));\n+  /* e = 1 - (b * y)\t\t\t*/\n+  emit_insn (gen_m2subrf4_cond (e, cond, one, b, y, zero, status1, trunc_off));\n+  /* y1 = y + (y * e)\t\t\t*/\n+  emit_insn (gen_m2addrf4_cond (y1, cond, y, y, e, zero, status1, trunc_off));\n+  /* y2 = y + (y1 * e)\t\t\t*/\n+  emit_insn (gen_m2addrf4_cond (y2, cond, y, y1, e, zero, status1, trunc_off));\n+  /* q = single(a * y2)\t\t\t*/\n+  emit_insn (gen_mulrf3_cond (q, cond, a, y2, zero, status1, trunc_sgl));\n+  /* r = a - (q * b)\t\t\t*/\n+  emit_insn (gen_m2subrf4_cond (r, cond, a, q, b, zero, status1, trunc_off));\n+  /* Q = single (q + (r * y2))\t\t*/\n+  emit_insn (gen_m2addrf4_cond (q_res, cond, q, r, y2, y, status0, trunc_sgl));\n+  /* Conversion back into SFmode.\t*/\n+  emit_insn (gen_truncrfsf2 (operands[0], q_res));\n+  DONE;\n+})\n+\n+\n+;; Double precision floating point division (maximum throughput algorithm).\n+\n+(define_expand \"divdf3_internal_thr\"\n+  [(set (match_operand:DF 0 \"fr_register_operand\" \"\")\n+        (div:DF (match_operand:DF 1 \"fr_register_operand\" \"\")\n+                (match_operand:DF 2 \"fr_register_operand\" \"\")))]\n+  \"TARGET_INLINE_FLOAT_DIV\"\n+{\n+  rtx q_res = gen_reg_rtx (RFmode);\n+  rtx a     = gen_reg_rtx (RFmode);\n+  rtx b     = gen_reg_rtx (RFmode);\n+  rtx y     = gen_reg_rtx (RFmode);\n+  rtx e     = gen_reg_rtx (RFmode);\n+  rtx y1    = gen_reg_rtx (RFmode);\n+  rtx e1    = gen_reg_rtx (RFmode);\n+  rtx y2    = gen_reg_rtx (RFmode);\n+  rtx e2    = gen_reg_rtx (RFmode);\n+  rtx y3    = gen_reg_rtx (RFmode);\n+  rtx q     = gen_reg_rtx (RFmode);\n+  rtx r     = gen_reg_rtx (RFmode);\n+  rtx cond  = gen_reg_rtx (BImode);\n+  rtx zero    = CONST0_RTX (RFmode);\n+  rtx one     = CONST1_RTX (RFmode);\n+  rtx status0 = CONST0_RTX (SImode);\n+  rtx status1 = CONST1_RTX (SImode);\n+  rtx trunc_dbl = CONST1_RTX (SImode);\n+  rtx trunc_off = CONST2_RTX (SImode);\n+  /* Empty conversions to put inputs into RFmode */\n+  emit_insn (gen_extenddfrf2 (a, operands[1]));\n+  emit_insn (gen_extenddfrf2 (b, operands[2]));\n+  /* y  = 1 / b\t\t\t*/\n+  emit_insn (gen_recip_approx_rf (y, a, b, cond, status0));\n+  /* e  = 1 - (b * y)\t\t*/\n+  emit_insn (gen_m2subrf4_cond (e, cond, one, b, y, zero, status1, trunc_off));\n+  /* y1 = y + (y * e)\t\t*/\n+  emit_insn (gen_m2addrf4_cond (y1, cond, y, y, e, zero, status1, trunc_off));\n+  /* e1 = e * e\t\t\t*/\n+  emit_insn (gen_mulrf3_cond (e1, cond, e, e, zero, status1, trunc_off));\n+  /* y2 = y1 + (y1 * e1)\t*/\n+  emit_insn (gen_m2addrf4_cond (y2, cond, y1, y1, e1, zero, status1, trunc_off));\n+  /* e2 = e1 * e1\t\t*/\n+  emit_insn (gen_mulrf3_cond (e2, cond, e1, e1, zero, status1, trunc_off));\n+  /* y3 = y2 + (y2 * e2)\t*/\n+  emit_insn (gen_m2addrf4_cond (y3, cond, y2, y2, e2, zero, status1, trunc_off));\n+  /* q  = double (a * y3)\t*/\n+  emit_insn (gen_mulrf3_cond (q, cond, a, y3, zero, status1, trunc_dbl));\n+  /* r  = a - (b * q)\t\t*/\n+  emit_insn (gen_m2subrf4_cond (r, cond, a, b, q, zero, status1, trunc_off));\n+  /* Q  = double (q + (r * y3))\t*/\n+  emit_insn (gen_m2addrf4_cond (q_res, cond, q, r, y3, y, status0, trunc_dbl));\n+  /* Conversion back into DFmode */\n+  emit_insn (gen_truncrfdf2 (operands[0], q_res));\n+  DONE;\n+})"}, {"sha": "b3e0325d38431ce82ac6ce29ebe700a7998904d3", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4883241c1873a0e4fd10ff2df64de6e5584b8165/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4883241c1873a0e4fd10ff2df64de6e5584b8165/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=4883241c1873a0e4fd10ff2df64de6e5584b8165", "patch": "@@ -4496,6 +4496,7 @@ ia64_print_operand_address (FILE * stream ATTRIBUTE_UNUSED,\n    O\tAppend .acq for volatile load.\n    P\tPostincrement of a MEM.\n    Q\tAppend .rel for volatile store.\n+   R\tPrint .s .d or nothing for a single, double or no truncation.\n    S\tShift amount for shladd instruction.\n    T\tPrint an 8-bit sign extended number (K) as a 32-bit unsigned number\n \tfor Intel assembler.\n@@ -4636,6 +4637,17 @@ ia64_print_operand (FILE * file, rtx x, int code)\n \tfputs(\".rel\", file);\n       return;\n \n+    case 'R':\n+      if (x == CONST0_RTX (GET_MODE (x)))\n+\tfputs(\".s\", file);\n+      else if (x == CONST1_RTX (GET_MODE (x)))\n+\tfputs(\".d\", file);\n+      else if (x == CONST2_RTX (GET_MODE (x)))\n+\t;\n+      else\n+\toutput_operand_lossage (\"invalid %%R value\");\n+      return;\n+\n     case 'S':\n       fprintf (file, \"%d\", exact_log2 (INTVAL (x)));\n       return;"}, {"sha": "fd6577669c7d70297b188576b1ba6806fe45eb57", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4883241c1873a0e4fd10ff2df64de6e5584b8165/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4883241c1873a0e4fd10ff2df64de6e5584b8165/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=4883241c1873a0e4fd10ff2df64de6e5584b8165", "patch": "@@ -645,6 +645,7 @@ while (0)\n    : PR_REGNO_P (REGNO) && (MODE) == BImode ? 2\t\t\t\t\\\n    : PR_REGNO_P (REGNO) && (MODE) == CCImode ? 1\t\t\t\\\n    : FR_REGNO_P (REGNO) && (MODE) == XFmode ? 1\t\t\t\t\\\n+   : FR_REGNO_P (REGNO) && (MODE) == RFmode ? 1\t\t\t\t\\\n    : FR_REGNO_P (REGNO) && (MODE) == XCmode ? 2\t\t\t\t\\\n    : (GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n@@ -660,7 +661,7 @@ while (0)\n    : PR_REGNO_P (REGNO) ?\t\t\t\t\t\\\n      (MODE) == BImode || GET_MODE_CLASS (MODE) == MODE_CC\t\\\n    : GR_REGNO_P (REGNO) ?\t\t\t\t\t\\\n-     (MODE) != CCImode && (MODE) != XFmode && (MODE) != XCmode\t\\\n+     (MODE) != CCImode && (MODE) != XFmode && (MODE) != XCmode && (MODE) != RFmode \\\n    : AR_REGNO_P (REGNO) ? (MODE) == DImode\t\t\t\\\n    : BR_REGNO_P (REGNO) ? (MODE) == DImode\t\t\t\\\n    : 0)\n@@ -677,15 +678,15 @@ while (0)\n    we can't tie it with any other modes.  */\n #define MODES_TIEABLE_P(MODE1, MODE2)\t\t\t\\\n   (GET_MODE_CLASS (MODE1) == GET_MODE_CLASS (MODE2)\t\\\n-   && ((((MODE1) == XFmode) || ((MODE1) == XCmode))\t\\\n-       == (((MODE2) == XFmode) || ((MODE2) == XCmode)))\t\\\n+   && ((((MODE1) == XFmode) || ((MODE1) == XCmode) || ((MODE1) == RFmode))\t\\\n+       == (((MODE2) == XFmode) || ((MODE2) == XCmode) || ((MODE1) == RFmode)))\t\\\n    && (((MODE1) == BImode) == ((MODE2) == BImode)))\n \n /* Specify the modes required to caller save a given hard regno.\n    We need to ensure floating pt regs are not saved as DImode.  */\n \n #define HARD_REGNO_CALLER_SAVE_MODE(REGNO, NREGS, MODE) \\\n-  ((FR_REGNO_P (REGNO) && (NREGS) == 1) ? XFmode        \\\n+  ((FR_REGNO_P (REGNO) && (NREGS) == 1) ? RFmode        \\\n    : choose_hard_reg_mode ((REGNO), (NREGS), false))\n \f\n /* Handling Leaf Functions */\n@@ -883,6 +884,7 @@ enum reg_class\n #define CLASS_MAX_NREGS(CLASS, MODE) \\\n   ((MODE) == BImode && (CLASS) == PR_REGS ? 2\t\t\t\\\n    : (((CLASS) == FR_REGS || (CLASS) == FP_REGS) && (MODE) == XFmode) ? 1 \\\n+   : (((CLASS) == FR_REGS || (CLASS) == FP_REGS) && (MODE) == RFmode) ? 1 \\\n    : (((CLASS) == FR_REGS || (CLASS) == FP_REGS) && (MODE) == XCmode) ? 2 \\\n    : (GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n "}, {"sha": "f41afc107c77dcc31f19f8d28afa5e2c8bf6158f", "filename": "gcc/config/ia64/ia64.md", "status": "modified", "additions": 2, "deletions": 120, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4883241c1873a0e4fd10ff2df64de6e5584b8165/gcc%2Fconfig%2Fia64%2Fia64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4883241c1873a0e4fd10ff2df64de6e5584b8165/gcc%2Fconfig%2Fia64%2Fia64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.md?ref=4883241c1873a0e4fd10ff2df64de6e5584b8165", "patch": "@@ -3109,60 +3109,6 @@\n }\n   [(set_attr \"predicable\" \"no\")])\n \n-(define_insn_and_split \"divsf3_internal_thr\"\n-  [(set (match_operand:SF 0 \"fr_register_operand\" \"=&f\")\n-\t(div:SF (match_operand:SF 1 \"fr_register_operand\" \"f\")\n-\t\t(match_operand:SF 2 \"fr_register_operand\" \"f\")))\n-   (clobber (match_scratch:XF 3 \"=&f\"))\n-   (clobber (match_scratch:XF 4 \"=f\"))\n-   (clobber (match_scratch:BI 5 \"=c\"))]\n-  \"TARGET_INLINE_FLOAT_DIV == INL_MAX_THR\"\n-  \"#\"\n-  \"&& reload_completed\"\n-  [(parallel [(set (match_dup 6) (div:XF (const_int 1) (match_dup 8)))\n-\t      (set (match_dup 5) (unspec:BI [(match_dup 7) (match_dup 8)]\n-\t\t\t\t\t    UNSPEC_FR_RECIP_APPROX))\n-\t      (use (const_int 0))])\n-   (cond_exec (ne (match_dup 5) (const_int 0))\n-     (parallel [(set (match_dup 3)\n-\t\t     (minus:XF (match_dup 10)\n-\t\t\t       (mult:XF (match_dup 8) (match_dup 6))))\n-\t\t(use (const_int 1))]))\n-   (cond_exec (ne (match_dup 5) (const_int 0))\n-     (parallel [(set (match_dup 3)\n-\t\t     (plus:XF (mult:XF (match_dup 3) (match_dup 3))\n-\t\t\t      (match_dup 3)))\n-\t\t(use (const_int 1))]))\n-   (cond_exec (ne (match_dup 5) (const_int 0))\n-     (parallel [(set (match_dup 6)\n-\t\t     (plus:XF (mult:XF (match_dup 3) (match_dup 6))\n-\t\t\t      (match_dup 6)))\n-\t\t(use (const_int 1))]))\n-   (cond_exec (ne (match_dup 5) (const_int 0))\n-     (parallel [(set (match_dup 9)\n-\t\t     (float_truncate:SF\n-\t\t       (mult:XF (match_dup 7) (match_dup 6))))\n-\t\t(use (const_int 1))]))\n-   (cond_exec (ne (match_dup 5) (const_int 0))\n-     (parallel [(set (match_dup 4)\n-\t\t     (minus:XF (match_dup 7)\n-\t\t\t       (mult:XF (match_dup 8) (match_dup 3))))\n-\t\t(use (const_int 1))]))\n-   (cond_exec (ne (match_dup 5) (const_int 0))\n-     (set (match_dup 0)\n-\t  (float_truncate:SF\n-\t    (plus:XF (mult:XF (match_dup 4) (match_dup 6))\n-\t\t\t      (match_dup 3)))))\n-  ] \n-{\n-  operands[6] = gen_rtx_REG (XFmode, REGNO (operands[0]));\n-  operands[7] = gen_rtx_REG (XFmode, REGNO (operands[1]));\n-  operands[8] = gen_rtx_REG (XFmode, REGNO (operands[2]));\n-  operands[9] = gen_rtx_REG (SFmode, REGNO (operands[3]));\n-  operands[10] = CONST1_RTX (XFmode);\n-}\n-  [(set_attr \"predicable\" \"no\")])\n-\n ;; Inline square root.\n \n (define_insn \"*sqrt_approx\"\n@@ -3615,72 +3561,6 @@\n }\n   [(set_attr \"predicable\" \"no\")])\n \n-(define_insn_and_split \"divdf3_internal_thr\"\n-  [(set (match_operand:DF 0 \"fr_register_operand\" \"=&f\")\n-\t(div:DF (match_operand:DF 1 \"fr_register_operand\" \"f\")\n-\t\t(match_operand:DF 2 \"fr_register_operand\" \"f\")))\n-   (clobber (match_scratch:XF 3 \"=&f\"))\n-   (clobber (match_scratch:DF 4 \"=f\"))\n-   (clobber (match_scratch:BI 5 \"=c\"))]\n-  \"TARGET_INLINE_FLOAT_DIV == INL_MAX_THR\"\n-  \"#\"\n-  \"&& reload_completed\"\n-  [(parallel [(set (match_dup 6) (div:XF (const_int 1) (match_dup 8)))\n-\t      (set (match_dup 5) (unspec:BI [(match_dup 7) (match_dup 8)]\n-\t\t\t\t\t    UNSPEC_FR_RECIP_APPROX))\n-\t      (use (const_int 0))])\n-   (cond_exec (ne (match_dup 5) (const_int 0))\n-     (parallel [(set (match_dup 3)\n-\t\t     (minus:XF (match_dup 10)\n-\t\t\t       (mult:XF (match_dup 8) (match_dup 6))))\n-\t\t(use (const_int 1))]))\n-   (cond_exec (ne (match_dup 5) (const_int 0))\n-     (parallel [(set (match_dup 6)\n-\t\t     (plus:XF (mult:XF (match_dup 3) (match_dup 6))\n-\t\t\t      (match_dup 6)))\n-\t\t(use (const_int 1))]))\n-   (cond_exec (ne (match_dup 5) (const_int 0))\n-     (parallel [(set (match_dup 3)\n-\t\t     (mult:XF (match_dup 3) (match_dup 3)))\n-\t\t(use (const_int 1))]))\n-   (cond_exec (ne (match_dup 5) (const_int 0))\n-     (parallel [(set (match_dup 6)\n-\t\t     (plus:XF (mult:XF (match_dup 3) (match_dup 6))\n-\t\t\t      (match_dup 6)))\n-\t\t(use (const_int 1))]))\n-   (cond_exec (ne (match_dup 5) (const_int 0))\n-     (parallel [(set (match_dup 3)\n-\t\t     (mult:XF (match_dup 3) (match_dup 3)))\n-\t\t(use (const_int 1))]))\n-   (cond_exec (ne (match_dup 5) (const_int 0))\n-     (parallel [(set (match_dup 6)\n-\t\t     (plus:XF (mult:XF (match_dup 3) (match_dup 6))\n-\t\t\t      (match_dup 6)))\n-\t\t(use (const_int 1))]))\n-   (cond_exec (ne (match_dup 5) (const_int 0))\n-     (parallel [(set (match_dup 9)\n-\t\t     (float_truncate:DF\n-\t\t       (mult:XF (match_dup 7) (match_dup 6))))\n-\t\t(use (const_int 1))]))\n-   (cond_exec (ne (match_dup 5) (const_int 0))\n-     (parallel [(set (match_dup 4)\n-\t\t     (minus:DF (match_dup 1)\n-\t\t\t       (mult:DF (match_dup 2) (match_dup 9))))\n-\t\t(use (const_int 1))]))\n-   (cond_exec (ne (match_dup 5) (const_int 0))\n-     (set (match_dup 0)\n-\t  (plus:DF (mult:DF (match_dup 4) (match_dup 0))\n-\t\t\t    (match_dup 9))))\n-  ] \n-{\n-  operands[6] = gen_rtx_REG (XFmode, REGNO (operands[0]));\n-  operands[7] = gen_rtx_REG (XFmode, REGNO (operands[1]));\n-  operands[8] = gen_rtx_REG (XFmode, REGNO (operands[2]));\n-  operands[9] = gen_rtx_REG (DFmode, REGNO (operands[3]));\n-  operands[10] = CONST1_RTX (XFmode);\n-}\n-  [(set_attr \"predicable\" \"no\")])\n-\n ;; Inline square root.\n \n (define_expand \"sqrtdf2\"\n@@ -6541,3 +6421,5 @@\n (include \"vect.md\")\n ;; Atomic operations\n (include \"sync.md\")\n+;; New division operations\n+(include \"div.md\")"}]}