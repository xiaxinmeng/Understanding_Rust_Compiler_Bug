{"sha": "b1dd92fd59d73a819f1109333b69047bcb4e4f58", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjFkZDkyZmQ1OWQ3M2E4MTlmMTEwOTMzM2I2OTA0N2JjYjRlNGY1OA==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernd.schmidt@analog.com", "date": "2006-11-15T17:54:55Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2006-11-15T17:54:55Z"}, "message": "tree-ssa-loop-ivopts.c (get_address_cost): Make sure memory addresses we generate for testing are aligned.\n\n\t* tree-ssa-loop-ivopts.c (get_address_cost): Make sure memory\n\taddresses we generate for testing are aligned.\n\nFrom-SVN: r118863", "tree": {"sha": "ed7bccbea173d8f793358c56f13750e14c5d0c65", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ed7bccbea173d8f793358c56f13750e14c5d0c65"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b1dd92fd59d73a819f1109333b69047bcb4e4f58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1dd92fd59d73a819f1109333b69047bcb4e4f58", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1dd92fd59d73a819f1109333b69047bcb4e4f58", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1dd92fd59d73a819f1109333b69047bcb4e4f58/comments", "author": null, "committer": null, "parents": [{"sha": "f9f63ff2153c3b281c17e3de313f9c83ff08f04c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9f63ff2153c3b281c17e3de313f9c83ff08f04c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9f63ff2153c3b281c17e3de313f9c83ff08f04c"}], "stats": {"total": 22, "additions": 15, "deletions": 7}, "files": [{"sha": "a36144b6c60f07e474b177e60fab5b56fee8447f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1dd92fd59d73a819f1109333b69047bcb4e4f58/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1dd92fd59d73a819f1109333b69047bcb4e4f58/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b1dd92fd59d73a819f1109333b69047bcb4e4f58", "patch": "@@ -1,3 +1,8 @@\n+2006-11-15  Bernd Schmidt  <bernd.schmidt@analog.com>\n+\n+\t* tree-ssa-loop-ivopts.c (get_address_cost): Make sure memory\n+\taddresses we generate for testing are aligned.\n+\n 2006-11-15  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n \n \tPR tree-opt/29788"}, {"sha": "29885f2fac7e0165103f64657c4985582787a245", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1dd92fd59d73a819f1109333b69047bcb4e4f58/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1dd92fd59d73a819f1109333b69047bcb4e4f58/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=b1dd92fd59d73a819f1109333b69047bcb4e4f58", "patch": "@@ -3318,7 +3318,8 @@ multiply_by_cost (HOST_WIDE_INT cst, enum machine_mode mode)\n   return cost;\n }\n \n-/* Returns true if multiplying by RATIO is allowed in address.  */\n+/* Returns true if multiplying by RATIO is allowed in an address.  Test the\n+   validity for a memory reference accessing memory of mode MODE.  */\n \n bool\n multiplier_allowed_in_address_p (HOST_WIDE_INT ratio, enum machine_mode mode)\n@@ -3361,8 +3362,9 @@ multiplier_allowed_in_address_p (HOST_WIDE_INT ratio, enum machine_mode mode)\n \n /* Returns cost of address in shape symbol + var + OFFSET + RATIO * index.\n    If SYMBOL_PRESENT is false, symbol is omitted.  If VAR_PRESENT is false,\n-   variable is omitted.  The created memory accesses MODE.\n-   \n+   variable is omitted.  Compute the cost for a memory reference that accesses\n+   a memory location of mode MEM_MODE.\n+\n    TODO -- there must be some better way.  This all is quite crude.  */\n \n static unsigned\n@@ -3383,6 +3385,7 @@ get_address_cost (bool symbol_present, bool var_present,\n   if (!initialized[mem_mode])\n     {\n       HOST_WIDE_INT i;\n+      HOST_WIDE_INT start = BIGGEST_ALIGNMENT / BITS_PER_UNIT;\n       int old_cse_not_expected;\n       unsigned sym_p, var_p, off_p, rat_p, add_c;\n       rtx seq, addr, base;\n@@ -3393,22 +3396,22 @@ get_address_cost (bool symbol_present, bool var_present,\n       reg1 = gen_raw_REG (Pmode, LAST_VIRTUAL_REGISTER + 1);\n \n       addr = gen_rtx_fmt_ee (PLUS, Pmode, reg1, NULL_RTX);\n-      for (i = 1; i <= 1 << 20; i <<= 1)\n+      for (i = start; i <= 1 << 20; i <<= 1)\n \t{\n \t  XEXP (addr, 1) = gen_int_mode (i, Pmode);\n \t  if (!memory_address_p (mem_mode, addr))\n \t    break;\n \t}\n-      max_offset[mem_mode] = i >> 1;\n+      max_offset[mem_mode] = i == start ? 0 : i >> 1;\n       off[mem_mode] = max_offset[mem_mode];\n \n-      for (i = 1; i <= 1 << 20; i <<= 1)\n+      for (i = start; i <= 1 << 20; i <<= 1)\n \t{\n \t  XEXP (addr, 1) = gen_int_mode (-i, Pmode);\n \t  if (!memory_address_p (mem_mode, addr))\n \t    break;\n \t}\n-      min_offset[mem_mode] = -(i >> 1);\n+      min_offset[mem_mode] = i == start ? 0 : -(i >> 1);\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{"}]}