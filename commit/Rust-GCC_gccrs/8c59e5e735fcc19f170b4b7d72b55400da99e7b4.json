{"sha": "8c59e5e735fcc19f170b4b7d72b55400da99e7b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGM1OWU1ZTczNWZjYzE5ZjE3MGI0YjdkNzJiNTU0MDBkYTk5ZTdiNA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-12-20T12:54:01Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-12-20T12:54:01Z"}, "message": "poly_int: C++ bitfield regions\n\nThis patch changes C++ bitregion_start/end values from constants to\npoly_ints.  Although it's unlikely that the size needs to be polynomial\nin practice, the offset could be with future language extensions.\n\n2017-12-20  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* expmed.h (store_bit_field): Change bitregion_start and\n\tbitregion_end from unsigned HOST_WIDE_INT to poly_uint64.\n\t* expmed.c (adjust_bit_field_mem_for_reg, strict_volatile_bitfield_p)\n\t(store_bit_field_1, store_integral_bit_field, store_bit_field)\n\t(store_fixed_bit_field, store_split_bit_field): Likewise.\n\t* expr.c (store_constructor_field, store_field): Likewise.\n\t(optimize_bitfield_assignment_op): Likewise.  Make the same change\n\tto bitsize and bitpos.\n\t* machmode.h (bit_field_mode_iterator): Change m_bitregion_start\n\tand m_bitregion_end from HOST_WIDE_INT to poly_int64.  Make the\n\tsame change in the constructor arguments.\n\t(get_best_mode): Change bitregion_start and bitregion_end from\n\tunsigned HOST_WIDE_INT to poly_uint64.\n\t* stor-layout.c (bit_field_mode_iterator::bit_field_mode_iterator):\n\tChange bitregion_start and bitregion_end from HOST_WIDE_INT to\n\tpoly_int64.\n\t(bit_field_mode_iterator::next_mode): Update for new types\n\tof m_bitregion_start and m_bitregion_end.\n\t(get_best_mode): Change bitregion_start and bitregion_end from\n\tunsigned HOST_WIDE_INT to poly_uint64.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r255879", "tree": {"sha": "970495d1af2f273a8cc5044cb312cb2cd6f24fa2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/970495d1af2f273a8cc5044cb312cb2cd6f24fa2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8c59e5e735fcc19f170b4b7d72b55400da99e7b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c59e5e735fcc19f170b4b7d72b55400da99e7b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c59e5e735fcc19f170b4b7d72b55400da99e7b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c59e5e735fcc19f170b4b7d72b55400da99e7b4/comments", "author": null, "committer": null, "parents": [{"sha": "fc60a41612bad379060969b6ed3a78eb160aae8a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc60a41612bad379060969b6ed3a78eb160aae8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc60a41612bad379060969b6ed3a78eb160aae8a"}], "stats": {"total": 132, "additions": 73, "deletions": 59}, "files": [{"sha": "e4f5430f3969cb2247a348f95a38d132cbe205a4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c59e5e735fcc19f170b4b7d72b55400da99e7b4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c59e5e735fcc19f170b4b7d72b55400da99e7b4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8c59e5e735fcc19f170b4b7d72b55400da99e7b4", "patch": "@@ -1,3 +1,28 @@\n+2017-12-20  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* expmed.h (store_bit_field): Change bitregion_start and\n+\tbitregion_end from unsigned HOST_WIDE_INT to poly_uint64.\n+\t* expmed.c (adjust_bit_field_mem_for_reg, strict_volatile_bitfield_p)\n+\t(store_bit_field_1, store_integral_bit_field, store_bit_field)\n+\t(store_fixed_bit_field, store_split_bit_field): Likewise.\n+\t* expr.c (store_constructor_field, store_field): Likewise.\n+\t(optimize_bitfield_assignment_op): Likewise.  Make the same change\n+\tto bitsize and bitpos.\n+\t* machmode.h (bit_field_mode_iterator): Change m_bitregion_start\n+\tand m_bitregion_end from HOST_WIDE_INT to poly_int64.  Make the\n+\tsame change in the constructor arguments.\n+\t(get_best_mode): Change bitregion_start and bitregion_end from\n+\tunsigned HOST_WIDE_INT to poly_uint64.\n+\t* stor-layout.c (bit_field_mode_iterator::bit_field_mode_iterator):\n+\tChange bitregion_start and bitregion_end from HOST_WIDE_INT to\n+\tpoly_int64.\n+\t(bit_field_mode_iterator::next_mode): Update for new types\n+\tof m_bitregion_start and m_bitregion_end.\n+\t(get_best_mode): Change bitregion_start and bitregion_end from\n+\tunsigned HOST_WIDE_INT to poly_uint64.\n+\n 2017-12-20  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "3a6a9ba0643eef9c9736790785d61708d6352b3b", "filename": "gcc/expmed.c", "status": "modified", "additions": 21, "deletions": 30, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c59e5e735fcc19f170b4b7d72b55400da99e7b4/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c59e5e735fcc19f170b4b7d72b55400da99e7b4/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=8c59e5e735fcc19f170b4b7d72b55400da99e7b4", "patch": "@@ -50,14 +50,12 @@ struct target_expmed *this_target_expmed = &default_target_expmed;\n static bool store_integral_bit_field (rtx, opt_scalar_int_mode,\n \t\t\t\t      unsigned HOST_WIDE_INT,\n \t\t\t\t      unsigned HOST_WIDE_INT,\n-\t\t\t\t      unsigned HOST_WIDE_INT,\n-\t\t\t\t      unsigned HOST_WIDE_INT,\n+\t\t\t\t      poly_uint64, poly_uint64,\n \t\t\t\t      machine_mode, rtx, bool, bool);\n static void store_fixed_bit_field (rtx, opt_scalar_int_mode,\n \t\t\t\t   unsigned HOST_WIDE_INT,\n \t\t\t\t   unsigned HOST_WIDE_INT,\n-\t\t\t\t   unsigned HOST_WIDE_INT,\n-\t\t\t\t   unsigned HOST_WIDE_INT,\n+\t\t\t\t   poly_uint64, poly_uint64,\n \t\t\t\t   rtx, scalar_int_mode, bool);\n static void store_fixed_bit_field_1 (rtx, scalar_int_mode,\n \t\t\t\t     unsigned HOST_WIDE_INT,\n@@ -66,8 +64,7 @@ static void store_fixed_bit_field_1 (rtx, scalar_int_mode,\n static void store_split_bit_field (rtx, opt_scalar_int_mode,\n \t\t\t\t   unsigned HOST_WIDE_INT,\n \t\t\t\t   unsigned HOST_WIDE_INT,\n-\t\t\t\t   unsigned HOST_WIDE_INT,\n-\t\t\t\t   unsigned HOST_WIDE_INT,\n+\t\t\t\t   poly_uint64, poly_uint64,\n \t\t\t\t   rtx, scalar_int_mode, bool);\n static rtx extract_integral_bit_field (rtx, opt_scalar_int_mode,\n \t\t\t\t       unsigned HOST_WIDE_INT,\n@@ -472,8 +469,8 @@ static rtx\n adjust_bit_field_mem_for_reg (enum extraction_pattern pattern,\n \t\t\t      rtx op0, HOST_WIDE_INT bitsize,\n \t\t\t      HOST_WIDE_INT bitnum,\n-\t\t\t      unsigned HOST_WIDE_INT bitregion_start,\n-\t\t\t      unsigned HOST_WIDE_INT bitregion_end,\n+\t\t\t      poly_uint64 bitregion_start,\n+\t\t\t      poly_uint64 bitregion_end,\n \t\t\t      machine_mode fieldmode,\n \t\t\t      unsigned HOST_WIDE_INT *new_bitnum)\n {\n@@ -537,8 +534,8 @@ static bool\n strict_volatile_bitfield_p (rtx op0, unsigned HOST_WIDE_INT bitsize,\n \t\t\t    unsigned HOST_WIDE_INT bitnum,\n \t\t\t    scalar_int_mode fieldmode,\n-\t\t\t    unsigned HOST_WIDE_INT bitregion_start,\n-\t\t\t    unsigned HOST_WIDE_INT bitregion_end)\n+\t\t\t    poly_uint64 bitregion_start,\n+\t\t\t    poly_uint64 bitregion_end)\n {\n   unsigned HOST_WIDE_INT modesize = GET_MODE_BITSIZE (fieldmode);\n \n@@ -565,9 +562,10 @@ strict_volatile_bitfield_p (rtx op0, unsigned HOST_WIDE_INT bitsize,\n     return false;\n \n   /* Check for cases where the C++ memory model applies.  */\n-  if (bitregion_end != 0\n-      && (bitnum - bitnum % modesize < bitregion_start\n-\t  || bitnum - bitnum % modesize + modesize - 1 > bitregion_end))\n+  if (maybe_ne (bitregion_end, 0U)\n+      && (maybe_lt (bitnum - bitnum % modesize, bitregion_start)\n+\t  || maybe_gt (bitnum - bitnum % modesize + modesize - 1,\n+\t\t       bitregion_end)))\n     return false;\n \n   return true;\n@@ -731,8 +729,7 @@ store_bit_field_using_insv (const extraction_insn *insv, rtx op0,\n \n static bool\n store_bit_field_1 (rtx str_rtx, poly_uint64 bitsize, poly_uint64 bitnum,\n-\t\t   unsigned HOST_WIDE_INT bitregion_start,\n-\t\t   unsigned HOST_WIDE_INT bitregion_end,\n+\t\t   poly_uint64 bitregion_start, poly_uint64 bitregion_end,\n \t\t   machine_mode fieldmode,\n \t\t   rtx value, bool reverse, bool fallback_p)\n {\n@@ -859,8 +856,8 @@ static bool\n store_integral_bit_field (rtx op0, opt_scalar_int_mode op0_mode,\n \t\t\t  unsigned HOST_WIDE_INT bitsize,\n \t\t\t  unsigned HOST_WIDE_INT bitnum,\n-\t\t\t  unsigned HOST_WIDE_INT bitregion_start,\n-\t\t\t  unsigned HOST_WIDE_INT bitregion_end,\n+\t\t\t  poly_uint64 bitregion_start,\n+\t\t\t  poly_uint64 bitregion_end,\n \t\t\t  machine_mode fieldmode,\n \t\t\t  rtx value, bool reverse, bool fallback_p)\n {\n@@ -1086,8 +1083,7 @@ store_integral_bit_field (rtx op0, opt_scalar_int_mode op0_mode,\n \n void\n store_bit_field (rtx str_rtx, poly_uint64 bitsize, poly_uint64 bitnum,\n-\t\t unsigned HOST_WIDE_INT bitregion_start,\n-\t\t unsigned HOST_WIDE_INT bitregion_end,\n+\t\t poly_uint64 bitregion_start, poly_uint64 bitregion_end,\n \t\t machine_mode fieldmode,\n \t\t rtx value, bool reverse)\n {\n@@ -1134,15 +1130,12 @@ store_bit_field (rtx str_rtx, poly_uint64 bitsize, poly_uint64 bitnum,\n   /* Under the C++0x memory model, we must not touch bits outside the\n      bit region.  Adjust the address to start at the beginning of the\n      bit region.  */\n-  if (MEM_P (str_rtx) && bitregion_start > 0)\n+  if (MEM_P (str_rtx) && maybe_ne (bitregion_start, 0U))\n     {\n       scalar_int_mode best_mode;\n       machine_mode addr_mode = VOIDmode;\n-      HOST_WIDE_INT offset;\n-\n-      gcc_assert ((bitregion_start % BITS_PER_UNIT) == 0);\n \n-      offset = bitregion_start / BITS_PER_UNIT;\n+      poly_uint64 offset = exact_div (bitregion_start, BITS_PER_UNIT);\n       bitnum -= bitregion_start;\n       poly_int64 size = bits_to_bytes_round_up (bitnum + bitsize);\n       bitregion_end -= bitregion_start;\n@@ -1175,8 +1168,7 @@ static void\n store_fixed_bit_field (rtx op0, opt_scalar_int_mode op0_mode,\n \t\t       unsigned HOST_WIDE_INT bitsize,\n \t\t       unsigned HOST_WIDE_INT bitnum,\n-\t\t       unsigned HOST_WIDE_INT bitregion_start,\n-\t\t       unsigned HOST_WIDE_INT bitregion_end,\n+\t\t       poly_uint64 bitregion_start, poly_uint64 bitregion_end,\n \t\t       rtx value, scalar_int_mode value_mode, bool reverse)\n {\n   /* There is a case not handled here:\n@@ -1331,8 +1323,7 @@ static void\n store_split_bit_field (rtx op0, opt_scalar_int_mode op0_mode,\n \t\t       unsigned HOST_WIDE_INT bitsize,\n \t\t       unsigned HOST_WIDE_INT bitpos,\n-\t\t       unsigned HOST_WIDE_INT bitregion_start,\n-\t\t       unsigned HOST_WIDE_INT bitregion_end,\n+\t\t       poly_uint64 bitregion_start, poly_uint64 bitregion_end,\n \t\t       rtx value, scalar_int_mode value_mode, bool reverse)\n {\n   unsigned int unit, total_bits, bitsdone = 0;\n@@ -1380,9 +1371,9 @@ store_split_bit_field (rtx op0, opt_scalar_int_mode op0_mode,\n \t UNIT close to the end of the region as needed.  If op0 is a REG\n \t or SUBREG of REG, don't do this, as there can't be data races\n \t on a register and we can expand shorter code in some cases.  */\n-      if (bitregion_end\n+      if (maybe_ne (bitregion_end, 0U)\n \t  && unit > BITS_PER_UNIT\n-\t  && bitpos + bitsdone - thispos + unit > bitregion_end + 1\n+\t  && maybe_gt (bitpos + bitsdone - thispos + unit, bitregion_end + 1)\n \t  && !REG_P (op0)\n \t  && (GET_CODE (op0) != SUBREG || !REG_P (SUBREG_REG (op0))))\n \t{"}, {"sha": "c806cd60e951bc949700b5ec063446dd683f460a", "filename": "gcc/expmed.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c59e5e735fcc19f170b4b7d72b55400da99e7b4/gcc%2Fexpmed.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c59e5e735fcc19f170b4b7d72b55400da99e7b4/gcc%2Fexpmed.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.h?ref=8c59e5e735fcc19f170b4b7d72b55400da99e7b4", "patch": "@@ -719,8 +719,7 @@ extern rtx expand_divmod (int, enum tree_code, machine_mode, rtx, rtx,\n #endif\n \n extern void store_bit_field (rtx, poly_uint64, poly_uint64,\n-\t\t\t     unsigned HOST_WIDE_INT,\n-\t\t\t     unsigned HOST_WIDE_INT,\n+\t\t\t     poly_uint64, poly_uint64,\n \t\t\t     machine_mode, rtx, bool);\n extern rtx extract_bit_field (rtx, poly_uint64, poly_uint64, int, rtx,\n \t\t\t      machine_mode, machine_mode, bool, rtx *);"}, {"sha": "2791268eab7e674e4415739231262388e655d6fe", "filename": "gcc/expr.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c59e5e735fcc19f170b4b7d72b55400da99e7b4/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c59e5e735fcc19f170b4b7d72b55400da99e7b4/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=8c59e5e735fcc19f170b4b7d72b55400da99e7b4", "patch": "@@ -79,13 +79,9 @@ static void emit_block_move_via_loop (rtx, rtx, rtx, unsigned);\n static void clear_by_pieces (rtx, unsigned HOST_WIDE_INT, unsigned int);\n static rtx_insn *compress_float_constant (rtx, rtx);\n static rtx get_subtarget (rtx);\n-static void store_constructor_field (rtx, unsigned HOST_WIDE_INT,\n-\t\t\t\t     HOST_WIDE_INT, unsigned HOST_WIDE_INT,\n-\t\t\t\t     unsigned HOST_WIDE_INT, machine_mode,\n-\t\t\t\t     tree, int, alias_set_type, bool);\n static void store_constructor (tree, rtx, int, HOST_WIDE_INT, bool);\n static rtx store_field (rtx, HOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t\tunsigned HOST_WIDE_INT, unsigned HOST_WIDE_INT,\n+\t\t\tpoly_uint64, poly_uint64,\n \t\t\tmachine_mode, tree, alias_set_type, bool, bool);\n \n static unsigned HOST_WIDE_INT highest_pow2_factor_for_target (const_tree, const_tree);\n@@ -4616,10 +4612,10 @@ get_subtarget (rtx x)\n    and there's nothing else to do.  */\n \n static bool\n-optimize_bitfield_assignment_op (unsigned HOST_WIDE_INT bitsize,\n-\t\t\t\t unsigned HOST_WIDE_INT bitpos,\n-\t\t\t\t unsigned HOST_WIDE_INT bitregion_start,\n-\t\t\t\t unsigned HOST_WIDE_INT bitregion_end,\n+optimize_bitfield_assignment_op (poly_uint64 pbitsize,\n+\t\t\t\t poly_uint64 pbitpos,\n+\t\t\t\t poly_uint64 pbitregion_start,\n+\t\t\t\t poly_uint64 pbitregion_end,\n \t\t\t\t machine_mode mode1, rtx str_rtx,\n \t\t\t\t tree to, tree src, bool reverse)\n {\n@@ -4631,7 +4627,12 @@ optimize_bitfield_assignment_op (unsigned HOST_WIDE_INT bitsize,\n   gimple *srcstmt;\n   enum tree_code code;\n \n+  unsigned HOST_WIDE_INT bitsize, bitpos, bitregion_start, bitregion_end;\n   if (mode1 != VOIDmode\n+      || !pbitsize.is_constant (&bitsize)\n+      || !pbitpos.is_constant (&bitpos)\n+      || !pbitregion_start.is_constant (&bitregion_start)\n+      || !pbitregion_end.is_constant (&bitregion_end)\n       || bitsize >= BITS_PER_WORD\n       || str_bitsize > BITS_PER_WORD\n       || TREE_SIDE_EFFECTS (to)\n@@ -6104,8 +6105,8 @@ all_zeros_p (const_tree exp)\n static void\n store_constructor_field (rtx target, unsigned HOST_WIDE_INT bitsize,\n \t\t\t HOST_WIDE_INT bitpos,\n-\t\t\t unsigned HOST_WIDE_INT bitregion_start,\n-\t\t\t unsigned HOST_WIDE_INT bitregion_end,\n+\t\t\t poly_uint64 bitregion_start,\n+\t\t\t poly_uint64 bitregion_end,\n \t\t\t machine_mode mode,\n \t\t\t tree exp, int cleared,\n \t\t\t alias_set_type alias_set, bool reverse)\n@@ -6784,8 +6785,7 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size,\n \n static rtx\n store_field (rtx target, HOST_WIDE_INT bitsize, HOST_WIDE_INT bitpos,\n-\t     unsigned HOST_WIDE_INT bitregion_start,\n-\t     unsigned HOST_WIDE_INT bitregion_end,\n+\t     poly_uint64 bitregion_start, poly_uint64 bitregion_end,\n \t     machine_mode mode, tree exp,\n \t     alias_set_type alias_set, bool nontemporal,  bool reverse)\n {"}, {"sha": "963fbb6c56927cb31120aa072213c9704bda5b96", "filename": "gcc/machmode.h", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c59e5e735fcc19f170b4b7d72b55400da99e7b4/gcc%2Fmachmode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c59e5e735fcc19f170b4b7d72b55400da99e7b4/gcc%2Fmachmode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.h?ref=8c59e5e735fcc19f170b4b7d72b55400da99e7b4", "patch": "@@ -760,7 +760,7 @@ class bit_field_mode_iterator\n {\n public:\n   bit_field_mode_iterator (HOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t\t   HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t   poly_int64, poly_int64,\n \t\t\t   unsigned int, bool);\n   bool next_mode (scalar_int_mode *);\n   bool prefer_smaller_modes ();\n@@ -771,17 +771,16 @@ class bit_field_mode_iterator\n      for invalid input such as gcc.dg/pr48335-8.c.  */\n   HOST_WIDE_INT m_bitsize;\n   HOST_WIDE_INT m_bitpos;\n-  HOST_WIDE_INT m_bitregion_start;\n-  HOST_WIDE_INT m_bitregion_end;\n+  poly_int64 m_bitregion_start;\n+  poly_int64 m_bitregion_end;\n   unsigned int m_align;\n   bool m_volatilep;\n   int m_count;\n };\n \n /* Find the best mode to use to access a bit field.  */\n \n-extern bool get_best_mode (int, int, unsigned HOST_WIDE_INT,\n-\t\t\t   unsigned HOST_WIDE_INT, unsigned int,\n+extern bool get_best_mode (int, int, poly_uint64, poly_uint64, unsigned int,\n \t\t\t   unsigned HOST_WIDE_INT, bool, scalar_int_mode *);\n \n /* Determine alignment, 1<=result<=BIGGEST_ALIGNMENT.  */"}, {"sha": "b91b455fac4cb5332e08d6cc67a62f3ba0bbd2bd", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c59e5e735fcc19f170b4b7d72b55400da99e7b4/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c59e5e735fcc19f170b4b7d72b55400da99e7b4/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=8c59e5e735fcc19f170b4b7d72b55400da99e7b4", "patch": "@@ -2751,15 +2751,15 @@ fixup_unsigned_type (tree type)\n \n bit_field_mode_iterator\n ::bit_field_mode_iterator (HOST_WIDE_INT bitsize, HOST_WIDE_INT bitpos,\n-\t\t\t   HOST_WIDE_INT bitregion_start,\n-\t\t\t   HOST_WIDE_INT bitregion_end,\n+\t\t\t   poly_int64 bitregion_start,\n+\t\t\t   poly_int64 bitregion_end,\n \t\t\t   unsigned int align, bool volatilep)\n : m_mode (NARROWEST_INT_MODE), m_bitsize (bitsize),\n   m_bitpos (bitpos), m_bitregion_start (bitregion_start),\n   m_bitregion_end (bitregion_end), m_align (align),\n   m_volatilep (volatilep), m_count (0)\n {\n-  if (!m_bitregion_end)\n+  if (known_eq (m_bitregion_end, 0))\n     {\n       /* We can assume that any aligned chunk of ALIGN bits that overlaps\n \t the bitfield is mapped and won't trap, provided that ALIGN isn't\n@@ -2769,8 +2769,8 @@ ::bit_field_mode_iterator (HOST_WIDE_INT bitsize, HOST_WIDE_INT bitpos,\n \t= MIN (align, MAX (BIGGEST_ALIGNMENT, BITS_PER_WORD));\n       if (bitsize <= 0)\n \tbitsize = 1;\n-      m_bitregion_end = bitpos + bitsize + units - 1;\n-      m_bitregion_end -= m_bitregion_end % units + 1;\n+      HOST_WIDE_INT end = bitpos + bitsize + units - 1;\n+      m_bitregion_end = end - end % units - 1;\n     }\n }\n \n@@ -2807,10 +2807,11 @@ bit_field_mode_iterator::next_mode (scalar_int_mode *out_mode)\n \n       /* Stop if the mode goes outside the bitregion.  */\n       HOST_WIDE_INT start = m_bitpos - substart;\n-      if (m_bitregion_start && start < m_bitregion_start)\n+      if (maybe_ne (m_bitregion_start, 0)\n+\t  && maybe_lt (start, m_bitregion_start))\n \tbreak;\n       HOST_WIDE_INT end = start + unit;\n-      if (end > m_bitregion_end + 1)\n+      if (maybe_gt (end, m_bitregion_end + 1))\n \tbreak;\n \n       /* Stop if the mode requires too much alignment.  */\n@@ -2866,8 +2867,7 @@ bit_field_mode_iterator::prefer_smaller_modes ()\n \n bool\n get_best_mode (int bitsize, int bitpos,\n-\t       unsigned HOST_WIDE_INT bitregion_start,\n-\t       unsigned HOST_WIDE_INT bitregion_end,\n+\t       poly_uint64 bitregion_start, poly_uint64 bitregion_end,\n \t       unsigned int align,\n \t       unsigned HOST_WIDE_INT largest_mode_bitsize, bool volatilep,\n \t       scalar_int_mode *best_mode)"}]}