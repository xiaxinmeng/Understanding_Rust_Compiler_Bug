{"sha": "8d9bfdc59dbb0ac947b27c22b8cf12a6e757bc64", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGQ5YmZkYzU5ZGJiMGFjOTQ3YjI3YzIyYjhjZjEyYTZlNzU3YmM2NA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-07-06T22:35:53Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-07-06T22:35:53Z"}, "message": "Changes to support execution on 64-bit machines.\n\nFrom-SVN: r1484", "tree": {"sha": "5b7c70b81320626a5b9a6abe6ecb5a6ab3bbcc9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5b7c70b81320626a5b9a6abe6ecb5a6ab3bbcc9b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d9bfdc59dbb0ac947b27c22b8cf12a6e757bc64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d9bfdc59dbb0ac947b27c22b8cf12a6e757bc64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d9bfdc59dbb0ac947b27c22b8cf12a6e757bc64", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d9bfdc59dbb0ac947b27c22b8cf12a6e757bc64/comments", "author": null, "committer": null, "parents": [{"sha": "9e4223f212806f6aacec980b6613dd1be1ea93f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e4223f212806f6aacec980b6613dd1be1ea93f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e4223f212806f6aacec980b6613dd1be1ea93f0"}], "stats": {"total": 263, "additions": 159, "deletions": 104}, "files": [{"sha": "c9d2815b3af3ca003fa5a014fd1203ca365d4b94", "filename": "gcc/c-decl.c", "status": "modified", "additions": 72, "deletions": 56, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d9bfdc59dbb0ac947b27c22b8cf12a6e757bc64/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d9bfdc59dbb0ac947b27c22b8cf12a6e757bc64/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=8d9bfdc59dbb0ac947b27c22b8cf12a6e757bc64", "patch": "@@ -41,9 +41,6 @@ enum decl_context\n   BITFIELD,\t\t\t/* Likewise but with specified width */\n   TYPENAME};\t\t\t/* Typename (inside cast or sizeof)  */\n \n-#undef NULL\n-#define NULL 0\n-\n #ifndef CHAR_TYPE_SIZE\n #define CHAR_TYPE_SIZE BITS_PER_UNIT\n #endif\n@@ -864,8 +861,8 @@ poplevel (keep, reverse, functionbody)\n \n   if (keep || functionbody\n       || (current_binding_level->keep_if_subblocks && subblocks != 0))\n-    block = build_block (keep ? decls : 0, keep ? tags : 0,\n-\t\t\t subblocks, 0, 0);\n+    block = build_block (keep ? decls : NULL_TREE, keep ? tags : NULL_TREE,\n+\t\t\t subblocks, NULL_TREE, NULL_TREE);\n \n   /* In each subblock, record that this is its superior.  */\n \n@@ -1108,7 +1105,7 @@ pushtag (name, type)\n      us a convenient place to record the \"scope start\" address for the\n      tagged type.  */\n \n-  TYPE_STUB_DECL (type) = pushdecl (build_decl (TYPE_DECL, NULL, type));\n+  TYPE_STUB_DECL (type) = pushdecl (build_decl (TYPE_DECL, NULL_TREE, type));\n }\n \f\n /* Handle when a new declaration NEWDECL\n@@ -1974,7 +1971,7 @@ implicitly_declare (functionid)\n   /* This is a no-op in c-lang.c or something real in objc-actions.c.  */\n   maybe_objc_check_decl (decl);\n \n-  rest_of_decl_compilation (decl, 0, 0, 0);\n+  rest_of_decl_compilation (decl, NULL_PTR, 0, 0);\n \n   if (warn_implicit && implicit_warning)\n     warning (\"implicit declaration of function `%s'\",\n@@ -2509,7 +2506,7 @@ init_decl_processing ()\n   endlink = tree_cons (NULL_TREE, void_type_node, NULL_TREE);\n \n   void_ftype_any\n-    = build_function_type (void_type_node, 0);\n+    = build_function_type (void_type_node, NULL_TREE);\n \n   double_ftype_double\n     = build_function_type (double_type_node,\n@@ -2587,21 +2584,21 @@ init_decl_processing ()\n   /* ``integer_tpe_node'' misspelling corrected: North-Keys 30 Mar 91 */\n   builtin_function (\"__builtin_constant_p\",\n \t\t    build_function_type (integer_type_node, endlink),\n-\t\t    BUILT_IN_CONSTANT_P, 0);\n+\t\t    BUILT_IN_CONSTANT_P, NULL_PTR);\n \n   builtin_function (\"__builtin_return_address\",\n \t\t    build_function_type (integer_type_node, \n \t\t\t\t\t tree_cons (NULL_TREE,\n \t\t\t\t\t\t    unsigned_type_node,\n \t\t\t\t\t\t    endlink)),\n-\t\t    BUILT_IN_RETURN_ADDRESS, 0);\n+\t\t    BUILT_IN_RETURN_ADDRESS, NULL_PTR);\n \n   builtin_function (\"__builtin_frame_address\",\n \t\t    build_function_type (integer_type_node, \n \t\t\t\t\t tree_cons (NULL_TREE,\n \t\t\t\t\t\t    unsigned_type_node,\n \t\t\t\t\t\t    endlink)),\n-\t\t    BUILT_IN_FRAME_ADDRESS, 0);\n+\t\t    BUILT_IN_FRAME_ADDRESS, NULL_PTR);\n \n   builtin_function (\"__builtin_alloca\",\n \t\t    build_function_type (ptr_type_node,\n@@ -2616,42 +2613,45 @@ init_decl_processing ()\n \t\t\t\t\t\t    tree_cons (NULL_TREE,\n \t\t\t\t\t\t\t       sizetype,\n \t\t\t\t\t\t\t       endlink)),\n-\t\t\t       BUILT_IN_ALLOCA, 0);\n+\t\t\t       BUILT_IN_ALLOCA, NULL_PTR);\n       /* Suppress error if redefined as a non-function.  */\n       DECL_BUILT_IN_NONANSI (temp) = 1;\n-      temp = builtin_function (\"_exit\", void_ftype_any, NOT_BUILT_IN, 0);\n+      temp = builtin_function (\"_exit\", void_ftype_any, NOT_BUILT_IN,\n+\t\t\t       NULL_PTR);\n       TREE_THIS_VOLATILE (temp) = 1;\n       TREE_SIDE_EFFECTS (temp) = 1;\n       /* Suppress error if redefined as a non-function.  */\n       DECL_BUILT_IN_NONANSI (temp) = 1;\n     }\n \n-  builtin_function (\"__builtin_abs\", int_ftype_int, BUILT_IN_ABS, 0);\n-  builtin_function (\"__builtin_fabs\", double_ftype_double, BUILT_IN_FABS, 0);\n-  builtin_function (\"__builtin_labs\", long_ftype_long, BUILT_IN_LABS, 0);\n-  builtin_function (\"__builtin_ffs\", int_ftype_int, BUILT_IN_FFS, 0);\n+  builtin_function (\"__builtin_abs\", int_ftype_int, BUILT_IN_ABS, NULL_PTR);\n+  builtin_function (\"__builtin_fabs\", double_ftype_double, BUILT_IN_FABS,\n+\t\t    NULL_PTR);\n+  builtin_function (\"__builtin_labs\", long_ftype_long, BUILT_IN_LABS,\n+\t\t    NULL_PTR);\n+  builtin_function (\"__builtin_ffs\", int_ftype_int, BUILT_IN_FFS, NULL_PTR);\n   builtin_function (\"__builtin_saveregs\", default_function_type,\n-\t\t    BUILT_IN_SAVEREGS, 0);\n+\t\t    BUILT_IN_SAVEREGS, NULL_PTR);\n /* EXPAND_BUILTIN_VARARGS is obsolete.  */\n #if 0\n   builtin_function (\"__builtin_varargs\",\n \t\t    build_function_type (ptr_type_node,\n \t\t\t\t\t tree_cons (NULL_TREE,\n \t\t\t\t\t\t    integer_type_node,\n \t\t\t\t\t\t    endlink)),\n-\t\t    BUILT_IN_VARARGS, 0);\n+\t\t    BUILT_IN_VARARGS, NULL_PTR);\n #endif\n   builtin_function (\"__builtin_classify_type\", default_function_type,\n-\t\t    BUILT_IN_CLASSIFY_TYPE, 0);\n+\t\t    BUILT_IN_CLASSIFY_TYPE, NULL_PTR);\n   builtin_function (\"__builtin_next_arg\",\n \t\t    build_function_type (ptr_type_node, endlink),\n-\t\t    BUILT_IN_NEXT_ARG, 0);\n+\t\t    BUILT_IN_NEXT_ARG, NULL_PTR);\n   builtin_function (\"__builtin_args_info\",\n \t\t    build_function_type (integer_type_node,\n \t\t\t\t\t tree_cons (NULL_TREE,\n \t\t\t\t\t\t    integer_type_node,\n \t\t\t\t\t\t    endlink)),\n-\t\t    BUILT_IN_ARGS_INFO, 0);\n+\t\t    BUILT_IN_ARGS_INFO, NULL_PTR);\n \n   /* Currently under experimentation.  */\n   builtin_function (\"__builtin_memcpy\", memcpy_ftype,\n@@ -2672,40 +2672,51 @@ init_decl_processing ()\n      However, honor the -fno-builtin option.  */\n   if (!flag_no_builtin)\n     {\n-      builtin_function (\"abs\", int_ftype_int, BUILT_IN_ABS, 0);\n-      builtin_function (\"fabs\", double_ftype_double, BUILT_IN_FABS, 0);\n-      builtin_function (\"labs\", long_ftype_long, BUILT_IN_LABS, 0);\n-      builtin_function (\"memcpy\", memcpy_ftype, BUILT_IN_MEMCPY, 0);\n-      builtin_function (\"memcmp\", int_ftype_cptr_cptr_sizet, BUILT_IN_MEMCMP, 0);\n-      builtin_function (\"strcmp\", int_ftype_string_string, BUILT_IN_STRCMP, 0);\n-      builtin_function (\"strcpy\", string_ftype_ptr_ptr, BUILT_IN_STRCPY, 0);\n-      builtin_function (\"strlen\", strlen_ftype, BUILT_IN_STRLEN, 0);\n-      builtin_function (\"sqrt\", double_ftype_double, BUILT_IN_FSQRT, 0);\n+      builtin_function (\"abs\", int_ftype_int, BUILT_IN_ABS, NULL_PTR);\n+      builtin_function (\"fabs\", double_ftype_double, BUILT_IN_FABS, NULL_PTR);\n+      builtin_function (\"labs\", long_ftype_long, BUILT_IN_LABS, NULL_PTR);\n+      builtin_function (\"memcpy\", memcpy_ftype, BUILT_IN_MEMCPY, NULL_PTR);\n+      builtin_function (\"memcmp\", int_ftype_cptr_cptr_sizet, BUILT_IN_MEMCMP,\n+\t\t\tNULL_PTR);\n+      builtin_function (\"strcmp\", int_ftype_string_string, BUILT_IN_STRCMP,\n+\t\t\tNULL_PTR);\n+      builtin_function (\"strcpy\", string_ftype_ptr_ptr, BUILT_IN_STRCPY,\n+\t\t\tNULL_PTR);\n+      builtin_function (\"strlen\", strlen_ftype, BUILT_IN_STRLEN, NULL_PTR);\n+      builtin_function (\"sqrt\", double_ftype_double, BUILT_IN_FSQRT, NULL_PTR);\n \n       /* Declare these functions volatile\n \t to avoid spurious \"control drops through\" warnings.  */\n       /* Don't specify the argument types, to avoid errors\n \t from certain code which isn't valid in ANSI but which exists.  */\n-      temp = builtin_function (\"abort\", void_ftype_any, NOT_BUILT_IN, 0);\n+      temp = builtin_function (\"abort\", void_ftype_any, NOT_BUILT_IN,\n+\t\t\t       NULL_PTR);\n       TREE_THIS_VOLATILE (temp) = 1;\n       TREE_SIDE_EFFECTS (temp) = 1;\n-      temp = builtin_function (\"exit\", void_ftype_any, NOT_BUILT_IN, 0);\n+      temp = builtin_function (\"exit\", void_ftype_any, NOT_BUILT_IN, NULL_PTR);\n       TREE_THIS_VOLATILE (temp) = 1;\n       TREE_SIDE_EFFECTS (temp) = 1;\n     }\n \n #if 0\n   /* Support for these has not been written in either expand_builtin\n      or build_function_call.  */\n-  builtin_function (\"__builtin_div\", default_ftype, BUILT_IN_DIV, 0);\n-  builtin_function (\"__builtin_ldiv\", default_ftype, BUILT_IN_LDIV, 0);\n-  builtin_function (\"__builtin_ffloor\", double_ftype_double, BUILT_IN_FFLOOR, 0);\n-  builtin_function (\"__builtin_fceil\", double_ftype_double, BUILT_IN_FCEIL, 0);\n-  builtin_function (\"__builtin_fmod\", double_ftype_double_double, BUILT_IN_FMOD, 0);\n-  builtin_function (\"__builtin_frem\", double_ftype_double_double, BUILT_IN_FREM, 0);\n-  builtin_function (\"__builtin_memset\", ptr_ftype_ptr_int_int, BUILT_IN_MEMSET, 0);\n-  builtin_function (\"__builtin_getexp\", double_ftype_double, BUILT_IN_GETEXP, 0);\n-  builtin_function (\"__builtin_getman\", double_ftype_double, BUILT_IN_GETMAN, 0);\n+  builtin_function (\"__builtin_div\", default_ftype, BUILT_IN_DIV, NULL_PTR);\n+  builtin_function (\"__builtin_ldiv\", default_ftype, BUILT_IN_LDIV, NULL_PTR);\n+  builtin_function (\"__builtin_ffloor\", double_ftype_double, BUILT_IN_FFLOOR,\n+\t\t    NULL_PTR);\n+  builtin_function (\"__builtin_fceil\", double_ftype_double, BUILT_IN_FCEIL,\n+\t\t    NULL_PTR);\n+  builtin_function (\"__builtin_fmod\", double_ftype_double_double,\n+\t\t    BUILT_IN_FMOD, NULL_PTR);\n+  builtin_function (\"__builtin_frem\", double_ftype_double_double,\n+\t\t    BUILT_IN_FREM, NULL_PTR);\n+  builtin_function (\"__builtin_memset\", ptr_ftype_ptr_int_int,\n+\t\t    BUILT_IN_MEMSET, NULL_PTR);\n+  builtin_function (\"__builtin_getexp\", double_ftype_double, BUILT_IN_GETEXP,\n+\t\t    NULL_PTR);\n+  builtin_function (\"__builtin_getman\", double_ftype_double, BUILT_IN_GETMAN,\n+\t\t    NULL_PTR);\n #endif\n \n   /* Create the global bindings for __FUNCTION__ and __PRETTY_FUNCTION__.  */\n@@ -2741,7 +2752,7 @@ builtin_function (name, type, function_code, library_name)\n     DECL_BUILT_IN_NONANSI (decl) = 1;\n   if (library_name)\n     DECL_ASSEMBLER_NAME (decl) = get_identifier (library_name);\n-  make_decl_rtl (decl, 0, 1);\n+  make_decl_rtl (decl, NULL_PTR, 1);\n   pushdecl (decl);\n   if (function_code != NOT_BUILT_IN)\n     {\n@@ -3151,7 +3162,7 @@ finish_decl (decl, init, asmspec_tree)\n     {\n       /* This is a no-op in c-lang.c or something real in objc-actions.c.  */\n       maybe_objc_check_decl (decl);\n-      rest_of_decl_compilation (decl, 0,\n+      rest_of_decl_compilation (decl, NULL_PTR,\n \t\t\t\tcurrent_binding_level == global_binding_level,\n \t\t\t\t0);\n     }\n@@ -3843,7 +3854,9 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \n \t  /* Omit the arg types if -traditional, since the arg types\n \t     and the list links might not be permanent.  */\n-\t  type = build_function_type (type, flag_traditional ? 0 : arg_types);\n+\t  type = build_function_type (type,\n+\t\t\t\t      flag_traditional \n+\t\t\t\t      ? NULL_TREE : arg_types);\n #endif\n \t  type = build_function_type (type, arg_types);\n \t  declarator = TREE_OPERAND (declarator, 0);\n@@ -4551,7 +4564,7 @@ grokfield (filename, line, declarator, declspecs, width)\n \n   value = grokdeclarator (declarator, declspecs, width ? BITFIELD : FIELD, 0);\n \n-  finish_decl (value, NULL, NULL);\n+  finish_decl (value, NULL_TREE, NULL_TREE);\n   DECL_INITIAL (value) = width;\n \n   return value;\n@@ -4674,7 +4687,8 @@ finish_struct (t, fieldlist)\n \t      error_with_decl (x, \"zero width for bit-field `%s'\");\n \t      DECL_INITIAL (x) = NULL;\n \t    }\n-\t  else if (width > TYPE_PRECISION (TREE_TYPE (x)))\n+\t  else if (width > TYPE_PRECISION (TREE_TYPE (x))\n+\t\t   || TREE_INT_CST_HIGH (DECL_INITIAL (x)) != 0)\n \t    {\n \t      DECL_INITIAL (x) = NULL;\n \t      pedwarn_with_decl (x, \"width of `%s' exceeds its type\");\n@@ -4829,7 +4843,7 @@ finish_struct (t, fieldlist)\n \t      layout_decl (decl, 0);\n \t      /* This is a no-op in c-lang.c or something real in objc-actions.c.  */\n \t      maybe_objc_check_decl (decl);\n-\t      rest_of_decl_compilation (decl, 0, toplevel, 0);\n+\t      rest_of_decl_compilation (decl, NULL_PTR, toplevel, 0);\n \t      if (! toplevel)\n \t\texpand_decl (decl);\n \t      --current_binding_level->n_incomplete;\n@@ -4919,8 +4933,8 @@ finish_enum (enumtype, values)\n {\n   register tree pair;\n   tree minnode = 0, maxnode = 0;\n-  register long maxvalue = 0;\n-  register long minvalue = 0;\n+  register HOST_WIDE_INT maxvalue = 0;\n+  register HOST_WIDE_INT minvalue = 0;\n   register int i;\n   unsigned precision = 0;\n   int toplevel = global_binding_level == current_binding_level;\n@@ -4956,8 +4970,8 @@ finish_enum (enumtype, values)\n     precision = TYPE_PRECISION (long_long_integer_type_node);\n   else\n     {\n-      int maxvalue = TREE_INT_CST_LOW (maxnode);\n-      int minvalue = TREE_INT_CST_LOW (minnode);\n+      maxvalue = TREE_INT_CST_LOW (maxnode);\n+      minvalue = TREE_INT_CST_LOW (minnode);\n \n       if (maxvalue > 0)\n \tprecision = floor_log2 (maxvalue) + 1;\n@@ -5065,7 +5079,7 @@ build_enumerator (name, value)\n   TREE_TYPE (value) = integer_type_node;\n   pushdecl (decl);\n \n-  return saveable_tree_cons (decl, value, NULL);\n+  return saveable_tree_cons (decl, value, NULL_TREE);\n }\n \f\n /* Create the FUNCTION_DECL for a function definition.\n@@ -5186,7 +5200,8 @@ start_function (declspecs, declarator, nested)\n   if (TREE_CODE (restype) == INTEGER_TYPE\n       && TYPE_PRECISION (restype) < TYPE_PRECISION (integer_type_node))\n     restype = integer_type_node;\n-  DECL_RESULT (current_function_decl) = build_decl (RESULT_DECL, 0, restype);\n+  DECL_RESULT (current_function_decl)\n+    = build_decl (RESULT_DECL, NULL_TREE, restype);\n \n   if (!nested)\n     /* Allocate further tree nodes temporarily during compilation\n@@ -5518,14 +5533,15 @@ store_parm_decls ()\n \n \t  for (parm = DECL_ARGUMENTS (fndecl); parm; parm = TREE_CHAIN (parm))\n \t    {\n-\t      type = perm_tree_cons (NULL, DECL_ARG_TYPE (parm), NULL);\n+\t      type = perm_tree_cons (NULL_TREE, DECL_ARG_TYPE (parm),\n+\t\t\t\t     NULL_TREE);\n \t      if (last)\n \t\tTREE_CHAIN (last) = type;\n \t      else\n \t\tactual = type;\n \t      last = type;\n \t    }\n-\t  type = perm_tree_cons (NULL, void_type_node, NULL);\n+\t  type = perm_tree_cons (NULL_TREE, void_type_node, NULL_TREE);\n \t  if (last)\n \t    TREE_CHAIN (last) = type;\n \t  else"}, {"sha": "e53eb9dfb7428916a1fca5bf1cc6f181eaafd1e7", "filename": "gcc/c-lex.c", "status": "modified", "additions": 34, "deletions": 16, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d9bfdc59dbb0ac947b27c22b8cf12a6e757bc64/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d9bfdc59dbb0ac947b27c22b8cf12a6e757bc64/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=8d9bfdc59dbb0ac947b27c22b8cf12a6e757bc64", "patch": "@@ -343,8 +343,21 @@ yyprint (file, yychar, yylval)\n     case CONSTANT:\n       t = yylval.ttype;\n       if (TREE_CODE (t) == INTEGER_CST)\n-\tfprintf (file, \" 0x%8x%8x\", TREE_INT_CST_HIGH (t),\n-\t\t TREE_INT_CST_LOW (t));\n+\tfprintf (file,\n+#if HOST_BITS_PER_WIDE_INT == 64\n+#if HOST_BITS_PER_WIDE_INT != HOST_BITS_PER_INT\n+\t\t \" 0x%lx%016lx\",\n+#else\n+\t\t \" 0x%x%016x\",\n+#endif\n+#else\n+#if HOST_BITS_PER_WIDE_INT != HOST_BITS_PER_INT\n+\t\t \" 0x%lx%08lx\",\n+#else\n+\t\t \" 0x%x%08x\",\n+#endif\n+#endif\n+\t\t TREE_INT_CST_HIGH (t), TREE_INT_CST_LOW (t));\n       break;\n     }\n }\n@@ -1344,7 +1357,7 @@ yylex ()\n \t      {\n \t\tset_float_handler (handler);\n \t\tvalue = REAL_VALUE_ATOF (token_buffer);\n-\t\tset_float_handler (0);\n+\t\tset_float_handler (NULL_PTR);\n \t      }\n #ifdef ERANGE\n \t    if (errno == ERANGE && !flag_traditional && pedantic)\n@@ -1424,6 +1437,7 @@ yylex ()\n \telse\n \t  {\n \t    tree traditional_type, ansi_type, type;\n+\t    HOST_WIDE_INT high, low;\n \t    int spec_unsigned = 0;\n \t    int spec_long = 0;\n \t    int spec_long_long = 0;\n@@ -1496,14 +1510,18 @@ yylex ()\n \n \t    /* This is simplified by the fact that our constant\n \t       is always positive.  */\n-\t    /* The casts in the following statement should not be\n-\t       needed, but they get around bugs in some C compilers.  */\n-\t    yylval.ttype\n-\t      = (build_int_2\n-\t\t ((((long)parts[3]<<24) + ((long)parts[2]<<16)\n-\t\t   + ((long)parts[1]<<8) + (long)parts[0]),\n-\t\t  (((long)parts[7]<<24) + ((long)parts[6]<<16)\n-\t\t   + ((long)parts[5]<<8) + (long)parts[4])));\n+\n+\t    high = low = 0;\n+\n+\t    for (i = 0; i < HOST_BITS_PER_WIDE_INT / HOST_BITS_PER_CHAR; i++)\n+\t      {\n+\t\thigh |= ((HOST_WIDE_INT) parts[i + (HOST_BITS_PER_WIDE_INT\n+\t\t\t\t\t\t    / HOST_BITS_PER_CHAR)]\n+\t\t\t << (i * HOST_BITS_PER_CHAR));\n+\t\tlow |= (HOST_WIDE_INT) parts[i] << (i * HOST_BITS_PER_CHAR);\n+\t      }\n+\t    \n+\t    yylval.ttype = build_int_2 (low, high);\n \n \t    /* If warn_traditional, calculate both the ANSI type and the\n \t       traditional type, then see if they disagree.\n@@ -1665,13 +1683,13 @@ yylex ()\n \t    if (TREE_UNSIGNED (char_type_node)\n \t\t|| ((result >> (num_bits - 1)) & 1) == 0)\n \t      yylval.ttype\n-\t\t= build_int_2 (result & ((unsigned) ~0\n-\t\t\t\t\t >> (HOST_BITS_PER_INT - num_bits)),\n+\t\t= build_int_2 (result & ((unsigned HOST_WIDE_INT) ~0\n+\t\t\t\t\t >> (HOST_BITS_PER_WIDE_INT - num_bits)),\n \t\t\t       0);\n \t    else\n \t      yylval.ttype\n-\t\t= build_int_2 (result | ~((unsigned) ~0\n-\t\t\t\t\t  >> (HOST_BITS_PER_INT - num_bits)),\n+\t\t= build_int_2 (result | ~((unsigned HOST_WIDE_INT) ~0\n+\t\t\t\t\t  >> (HOST_BITS_PER_WIDE_INT - num_bits)),\n \t\t\t       -1);\n \t  }\n \telse\n@@ -1685,7 +1703,7 @@ yylex ()\n \t\t|| (num_chars == 1 && token_buffer[1] != '\\0'))\n \t      {\n \t\twchar_t wc;\n-\t\t(void) mbtowc (NULL, NULL, 0);\n+\t\t(void) mbtowc (NULL_PTR, NULL_PTR, 0);\n \t\tif (mbtowc (& wc, token_buffer + 1, num_chars) == num_chars)\n \t\t  result = wc;\n \t\telse"}, {"sha": "95f7c4970d1593e8818fd674cea685e98857fdda", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 24, "deletions": 19, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d9bfdc59dbb0ac947b27c22b8cf12a6e757bc64/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d9bfdc59dbb0ac947b27c22b8cf12a6e757bc64/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=8d9bfdc59dbb0ac947b27c22b8cf12a6e757bc64", "patch": "@@ -287,7 +287,7 @@ common_type (t1, t2)\n \tnewargs = 0;\n \n \tfor (i = 0; i < len; i++)\n-\t  newargs = tree_cons (0, 0, newargs);\n+\t  newargs = tree_cons (NULL_TREE, NULL_TREE, newargs);\n \n \tn = newargs;\n \n@@ -1011,7 +1011,7 @@ build_component_ref (datum, component)\n     {\n       if (TYPE_SIZE (type) == 0)\n \t{\n-\t  incomplete_type_error (0, type);\n+\t  incomplete_type_error (NULL_TREE, type);\n \t  return error_mark_node;\n \t}\n \n@@ -2027,7 +2027,7 @@ convert_arguments (typelist, values, name)\n \t\tparmval = default_conversion (parmval);\n #endif\n \t    }\n-\t  result = tree_cons (0, parmval, result);\n+\t  result = tree_cons (NULL_TREE, parmval, result);\n \t}\n       else if (TREE_CODE (TREE_TYPE (val)) == REAL_TYPE\n                && (TYPE_PRECISION (TREE_TYPE (val))\n@@ -3676,7 +3676,7 @@ build_c_cast (type, expr)\n \t    name = \"\";\n \t  return digest_init (type, build_nt (CONSTRUCTOR, NULL_TREE,\n \t\t\t\t\t      build_tree_list (field, value)),\n-\t\t\t      0, 0, 0, name);\n+\t\t\t      NULL_PTR, 0, 0, name);\n \t}\n       error (\"cast to union type from type not present in union\");\n       return error_mark_node;\n@@ -4200,7 +4200,7 @@ store_init_value (decl, init)\n \n   /* Digest the specified initializer into an expression.  */\n \n-  value = digest_init (type, init, 0, TREE_STATIC (decl),\n+  value = digest_init (type, init, NULL_PTR, TREE_STATIC (decl),\n \t\t       TREE_STATIC (decl) || pedantic, \n \t\t       IDENTIFIER_POINTER (DECL_NAME (decl)));\n \n@@ -4667,13 +4667,13 @@ digest_init (type, init, tail, require_constant, constructor_constant, ofwhat)\n \t}\n \n       if (raw_constructor)\n-\tresult = process_init_constructor (type, inside_init, 0,\n+\tresult = process_init_constructor (type, inside_init, NULL_PTR,\n \t\t\t\t\t   require_constant,\n \t\t\t\t\t   constructor_constant, ofwhat);\n       else if (tail != 0)\n \t{\n \t  *tail = old_tail_contents;\n-\t  result = process_init_constructor (type, 0, tail,\n+\t  result = process_init_constructor (type, NULL_TREE, tail,\n \t\t\t\t\t     require_constant,\n \t\t\t\t\t     constructor_constant, ofwhat);\n \t}\n@@ -4751,20 +4751,23 @@ digest_init (type, init, tail, require_constant, constructor_constant, ofwhat)\n     {\n       if (raw_constructor)\n \treturn process_init_constructor (type, inside_init,\n-\t\t\t\t\t 0, constructor_constant,\n+\t\t\t\t\t NULL_PTR, constructor_constant,\n \t\t\t\t\t constructor_constant, ofwhat);\n       else if (tail != 0)\n \t{\n \t  *tail = old_tail_contents;\n-\t  return process_init_constructor (type, 0, tail, constructor_constant,\n+\t  return process_init_constructor (type, NULL_TREE, tail,\n+\t\t\t\t\t   constructor_constant,\n \t\t\t\t\t   constructor_constant, ofwhat);\n \t}\n       else if (flag_traditional)\n \t/* Traditionally one can say `char x[100] = 0;'.  */\n \treturn process_init_constructor (type,\n-\t\t\t\t\t build_nt (CONSTRUCTOR, 0,\n-\t\t\t\t\t\t   tree_cons (0, inside_init, 0)),\n-\t\t\t\t\t 0, constructor_constant,\n+\t\t\t\t\t build_nt (CONSTRUCTOR, NULL_TREE,\n+\t\t\t\t\t\t   tree_cons (NULL_TREE,\n+\t\t\t\t\t\t\t      inside_init,\n+\t\t\t\t\t\t\t      NULL_TREE)),\n+\t\t\t\t\t NULL_PTR, constructor_constant,\n \t\t\t\t\t constructor_constant, ofwhat);\n     }\n \n@@ -4906,7 +4909,8 @@ process_init_constructor (type, init, elts, constant_value, constant_element,\n \t\t\t\t       TREE_VALUE (tail), &tail1,\n \t\t\t\t       /* Both of these are the same because\n \t\t\t\t\t  a value here is an elt overall.  */\n-\t\t\t\t       constant_element, constant_element, 0);\n+\t\t\t\t       constant_element, constant_element,\n+\t\t\t\t       NULL_PTR);\n \t\t});\n \n \t      if (tail1 != 0 && TREE_CODE (tail1) != TREE_LIST)\n@@ -4915,7 +4919,7 @@ process_init_constructor (type, init, elts, constant_value, constant_element,\n \t\t{\n \t\t  error_init (\n \t\t    \"non-empty initializer for array%s of empty elements\",\n-\t\t    \" `%s'\", 0);\n+\t\t    \" `%s'\", NULL_PTR);\n \t\t  /* Just ignore what we were supposed to use.  */\n \t\t  tail1 = 0;\n \t\t}\n@@ -5015,7 +5019,8 @@ process_init_constructor (type, init, elts, constant_value, constant_element,\n \t\t  push_member_name (IDENTIFIER_POINTER (DECL_NAME (field)));\n \t\t  next1 = digest_init (TREE_TYPE (field),\n \t\t\t\t       TREE_VALUE (tail), &tail1,\n-\t\t\t\t       constant_element, constant_element, 0);\n+\t\t\t\t       constant_element, constant_element,\n+\t\t\t\t       NULL_PTR);\n \t\t});\n \t      if (tail1 != 0 && TREE_CODE (tail1) != TREE_LIST)\n \t\tabort ();\n@@ -5103,7 +5108,7 @@ process_init_constructor (type, init, elts, constant_value, constant_element,\n \t      push_member_name (IDENTIFIER_POINTER (DECL_NAME (field)));\n \t      next1 = digest_init (TREE_TYPE (field),\n \t\t\t\t   TREE_VALUE (tail), &tail1,\n-\t\t\t\t   constant_value, constant_element, 0);\n+\t\t\t\t   constant_value, constant_element, NULL_PTR);\n \t    });\n \t  if (tail1 != 0 && TREE_CODE (tail1) != TREE_LIST)\n \t    abort ();\n@@ -5134,12 +5139,12 @@ process_init_constructor (type, init, elts, constant_value, constant_element,\n       if (TREE_CODE (type) == UNION_TYPE)\n \t{\n \t  pedwarn_init (\"excess elements in union initializer%s\",\n-\t\t\t\" after `%s'\", 0);\n+\t\t\t\" after `%s'\", NULL_PTR);\n \t}\n       else\n \t{\n \t  pedwarn_init (\"excess elements in aggregate initializer%s\",\n-\t\t\t\" after `%s'\", 0);\n+\t\t\t\" after `%s'\", NULL_PTR);\n \t}\n     }\n \n@@ -5293,7 +5298,7 @@ c_expand_start_case (exp)\n \n       exp = default_conversion (exp);\n       type = TREE_TYPE (exp);\n-      index = get_unwidened (exp, 0);\n+      index = get_unwidened (exp, NULL_TREE);\n       /* We can't strip a conversion from a signed type to an unsigned,\n \t because if we did, int_fits_type_p would do the wrong thing\n \t when checking case values for being in range,"}, {"sha": "a9e2f94f4028eac8a1d0631721016bc65a7f02fa", "filename": "gcc/cccp.c", "status": "modified", "additions": 29, "deletions": 13, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d9bfdc59dbb0ac947b27c22b8cf12a6e757bc64/gcc%2Fcccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d9bfdc59dbb0ac947b27c22b8cf12a6e757bc64/gcc%2Fcccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcccp.c?ref=8d9bfdc59dbb0ac947b27c22b8cf12a6e757bc64", "patch": "@@ -120,6 +120,14 @@ typedef struct { unsigned :16, :16, :16; } vms_ino_t;\n #define S_ISREG(m) (((m) & S_IFMT) == S_IFREG)\n #endif\n \n+#ifndef NULL\n+#define NULL 0\n+#endif\n+\n+#ifndef NULL_PTR\n+#define NULL_PTR (char *) NULL\n+#endif\n+\n /* Exported declarations.  */\n \n char *xmalloc ();\n@@ -1589,7 +1597,7 @@ main (argc, argv)\n \tperror_with_name (pend_files[i]);\n \treturn FAILURE_EXIT_CODE;\n       }\n-      finclude (fd, pend_files[i], &outbuf, 0, 0);\n+      finclude (fd, pend_files[i], &outbuf, 0, NULL_PTR);\n     }\n   no_output--;\n \n@@ -1773,7 +1781,7 @@ main (argc, argv)\n \tperror_with_name (pend_includes[i]);\n \treturn FAILURE_EXIT_CODE;\n       }\n-      finclude (fd, pend_includes[i], &outbuf, 0, 0);\n+      finclude (fd, pend_includes[i], &outbuf, 0, NULL_PTR);\n     }\n \n   /* Scan the input, processing macros and directives.  */\n@@ -3329,7 +3337,8 @@ handle_directive (ip, op)\n \t  case '\\\"':\n \t    {\n \t      register U_CHAR *bp1\n-\t\t= skip_quoted_string (xp - 1, bp, ip->lineno, 0, 0, 0);\n+\t\t= skip_quoted_string (xp - 1, bp, ip->lineno,\n+\t\t\t\t      NULL_PTR, NULL_PTR, NULL_PTR);\n \t      while (xp != bp1)\n \t\tif (*xp == '\\\\') {\n \t\t  if (*++xp != '\\n')\n@@ -4307,8 +4316,8 @@ check_preconditions (prec)\n       HASHNODE *hp;\n       \n       prec += 6;\n-      mdef = create_definition (prec, lineend, 0);\n-      \n+      mdef = create_definition (prec, lineend, NULL_PTR);\n+\n       if (mdef.defn == 0)\n \tabort();\n       \n@@ -4695,7 +4704,7 @@ create_definition (buf, limit, op)\n     if (is_hor_space[*bp])\n       ++bp;\t\t/* skip exactly one blank/tab char */\n     /* now everything from bp before limit is the definition. */\n-    defn = collect_expansion (bp, limit, -1, 0);\n+    defn = collect_expansion (bp, limit, -1, NULL_PTR);\n     defn->args.argnames = (U_CHAR *) \"\";\n   }\n \n@@ -5452,7 +5461,7 @@ read_token_list (bpp, limit, error_flag)\n \tbreak;\n       bp++;\n     } else if (*bp == '\"' || *bp == '\\'')\n-      bp = skip_quoted_string (bp, limit, 0, 0, 0, &eofp);\n+      bp = skip_quoted_string (bp, limit, 0, NULL_PTR, NULL_PTR, &eofp);\n     else\n       while (! is_hor_space[*bp] && *bp != '(' && *bp != ')'\n \t     && *bp != '\"' && *bp != '\\'' && bp != limit)\n@@ -5911,7 +5920,7 @@ do_if (buf, limit, op, keyword)\n   FILE_BUF *ip = &instack[indepth];\n \n   value = eval_if_expression (buf, limit - buf);\n-  conditional_skip (ip, value == 0, T_IF, 0);\n+  conditional_skip (ip, value == 0, T_IF, NULL_PTR);\n   return 0;\n }\n \n@@ -6142,7 +6151,8 @@ skip_if_group (ip, any)\n       break;\n     case '\\\"':\n     case '\\'':\n-      bp = skip_quoted_string (bp - 1, endb, ip->lineno, &ip->lineno, 0, 0);\n+      bp = skip_quoted_string (bp - 1, endb, ip->lineno, &ip->lineno,\n+\t\t\t       NULL_PTR, NULL_PTR);\n       break;\n     case '\\\\':\n       /* Char after backslash loses its special meaning.  */\n@@ -6674,7 +6684,7 @@ skip_paren_group (ip)\n     case '\\'':\n       {\n \tint eofp = 0;\n-\tp = skip_quoted_string (p - 1, limit, 0, 0, 0, &eofp);\n+\tp = skip_quoted_string (p - 1, limit, 0, NULL_PTR, NULL_PTR, &eofp);\n \tif (eofp)\n \t  return ip->bufp = p;\n       }\n@@ -6844,7 +6854,7 @@ macroexpand (hp, op)\n \tparse_error = macarg (&args[i], rest_args);\n       }\n       else\n-\tparse_error = macarg (0, 0);\n+\tparse_error = macarg (NULL_PTR, 0);\n       if (parse_error) {\n \terror_with_line (line_for_error (start_line), parse_error);\n \tbreak;\n@@ -7505,6 +7515,7 @@ delete_newlines (start, length)\n void\n error (msg, arg1, arg2, arg3)\n      char *msg;\n+     char *arg1, *arg2, *arg3;\n {\n   int i;\n   FILE_BUF *ip = NULL;\n@@ -7557,6 +7568,7 @@ error_from_errno (name)\n void\n warning (msg, arg1, arg2, arg3)\n      char *msg;\n+     char *arg1, *arg2, *arg3;\n {\n   int i;\n   FILE_BUF *ip = NULL;\n@@ -7586,6 +7598,7 @@ static void\n error_with_line (line, msg, arg1, arg2, arg3)\n      int line;\n      char *msg;\n+     char *arg1, *arg2, *arg3;\n {\n   int i;\n   FILE_BUF *ip = NULL;\n@@ -7610,6 +7623,7 @@ error_with_line (line, msg, arg1, arg2, arg3)\n void\n pedwarn (msg, arg1, arg2, arg3)\n      char *msg;\n+     char *arg1, *arg2, *arg3;\n {\n   if (pedantic_errors)\n     error (msg, arg1, arg2, arg3);\n@@ -7625,6 +7639,7 @@ pedwarn_with_file_and_line (file, line, msg, arg1, arg2, arg3)\n      char *file;\n      int line;\n      char *msg;\n+     char *arg1, *arg2, *arg3;\n {\n   int i;\n   if (!pedantic_errors && inhibit_warnings)\n@@ -8001,7 +8016,8 @@ dump_defn_1 (base, start, length, of)\n     if (*p != '\\n')\n       putc (*p, of);\n     else if (*p == '\\\"' || *p =='\\'') {\n-      U_CHAR *p1 = skip_quoted_string (p, limit, 0, 0, 0, 0);\n+      U_CHAR *p1 = skip_quoted_string (p, limit, 0, NULL_PTR,\n+\t\t\t\t       NULL_PTR, NULL_PTR);\n       fwrite (p, p1 - p, 1, of);\n       p = p1 - 1;\n     }\n@@ -8314,7 +8330,7 @@ make_assertion (option, str)\n \n   /* pass NULL as output ptr to do_define since we KNOW it never\n      does any output.... */\n-  do_assert (buf, buf + strlen (buf) , NULL, kt);\n+  do_assert (buf, buf + strlen (buf) , NULL_PTR, kt);\n   --indepth;\n }\n \f"}]}