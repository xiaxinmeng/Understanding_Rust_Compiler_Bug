{"sha": "57aaef66e54574a9ae1740491516066e8eddc64b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTdhYWVmNjZlNTQ1NzRhOWFlMTc0MDQ5MTUxNjA2NmU4ZWRkYzY0Yg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-12-26T03:59:28Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-12-26T03:59:28Z"}, "message": "expr.c (clear_storage): Validate CONST0_RTX extant.\n\n        * expr.c (clear_storage): Validate CONST0_RTX extant.  Special case\n        complex modes.\n\nFrom-SVN: r92615", "tree": {"sha": "4403a3fcc0caca4650a778eef642eaae7575c16d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4403a3fcc0caca4650a778eef642eaae7575c16d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/57aaef66e54574a9ae1740491516066e8eddc64b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57aaef66e54574a9ae1740491516066e8eddc64b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57aaef66e54574a9ae1740491516066e8eddc64b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57aaef66e54574a9ae1740491516066e8eddc64b/comments", "author": null, "committer": null, "parents": [{"sha": "798e3fe5a033121d06c9e17f871aaabf3c35dfbd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/798e3fe5a033121d06c9e17f871aaabf3c35dfbd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/798e3fe5a033121d06c9e17f871aaabf3c35dfbd"}], "stats": {"total": 58, "additions": 41, "deletions": 17}, "files": [{"sha": "4e9c2834539763960934769d1bad20571566b656", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57aaef66e54574a9ae1740491516066e8eddc64b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57aaef66e54574a9ae1740491516066e8eddc64b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=57aaef66e54574a9ae1740491516066e8eddc64b", "patch": "@@ -1,3 +1,8 @@\n+2004-12-25  Richard Henderson  <rth@redhat.com>\n+\n+\t* expr.c (clear_storage): Validate CONST0_RTX extant.  Special case\n+\tcomplex modes.\n+\n 2004-12-25  Zdenek Dvorak  <dvorakz@suse.cz>\n \n \tPR rtl-optimization/19078"}, {"sha": "6782feb0bfc230309aad51e9dd2c9f20ddcbd107", "filename": "gcc/expr.c", "status": "modified", "additions": 36, "deletions": 17, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57aaef66e54574a9ae1740491516066e8eddc64b/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57aaef66e54574a9ae1740491516066e8eddc64b/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=57aaef66e54574a9ae1740491516066e8eddc64b", "patch": "@@ -159,6 +159,7 @@ static void emit_single_push_insn (enum machine_mode, rtx, tree);\n #endif\n static void do_tablejump (rtx, enum machine_mode, rtx, rtx, rtx);\n static rtx const_vector_from_tree (tree);\n+static void write_complex_part (rtx, rtx, bool);\n \n /* Record for each mode whether we can move a register directly to or\n    from an object of that mode in memory.  If we can't, we won't try\n@@ -2405,30 +2406,48 @@ store_by_pieces_2 (rtx (*genfun) (rtx, ...), enum machine_mode mode,\n rtx\n clear_storage (rtx object, rtx size)\n {\n-  rtx retval = 0;\n-  unsigned int align = (MEM_P (object) ? MEM_ALIGN (object)\n-\t\t\t: GET_MODE_ALIGNMENT (GET_MODE (object)));\n+  enum machine_mode mode = GET_MODE (object);\n+  unsigned int align;\n \n   /* If OBJECT is not BLKmode and SIZE is the same size as its mode,\n      just move a zero.  Otherwise, do this a piece at a time.  */\n-  if (GET_MODE (object) != BLKmode\n+  if (mode != BLKmode\n       && GET_CODE (size) == CONST_INT\n-      && INTVAL (size) == (HOST_WIDE_INT) GET_MODE_SIZE (GET_MODE (object)))\n-    emit_move_insn (object, CONST0_RTX (GET_MODE (object)));\n-  else\n+      && INTVAL (size) == (HOST_WIDE_INT) GET_MODE_SIZE (mode))\n     {\n-      if (size == const0_rtx)\n-\t;\n-      else if (GET_CODE (size) == CONST_INT\n-\t  && CLEAR_BY_PIECES_P (INTVAL (size), align))\n-\tclear_by_pieces (object, INTVAL (size), align);\n-      else if (clear_storage_via_clrmem (object, size, align))\n-\t;\n-      else\n-\tretval = clear_storage_via_libcall (object, size);\n+      rtx zero = CONST0_RTX (mode);\n+      if (zero != NULL)\n+\t{\n+\t  emit_move_insn (object, zero);\n+\t  return NULL;\n+\t}\n+\n+      if (COMPLEX_MODE_P (mode))\n+\t{\n+\t  zero = CONST0_RTX (GET_MODE_INNER (mode));\n+\t  if (zero != NULL)\n+\t    {\n+\t      write_complex_part (object, zero, 0);\n+\t      write_complex_part (object, zero, 1);\n+\t      return NULL;\n+\t    }\n+\t}\n     }\n \n-  return retval;\n+  if (size == const0_rtx)\n+    return NULL;\n+\n+  align = MEM_ALIGN (object);\n+\n+  if (GET_CODE (size) == CONST_INT\n+      && CLEAR_BY_PIECES_P (INTVAL (size), align))\n+    clear_by_pieces (object, INTVAL (size), align);\n+  else if (clear_storage_via_clrmem (object, size, align))\n+    ;\n+  else\n+    return clear_storage_via_libcall (object, size);\n+\n+  return NULL;\n }\n \n /* A subroutine of clear_storage.  Expand a clrmem pattern;"}]}