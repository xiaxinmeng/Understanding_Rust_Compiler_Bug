{"sha": "a10d35a8ba450c7b83f17c27f43a08e3568c6c57", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTEwZDM1YThiYTQ1MGM3YjgzZjE3YzI3ZjQzYTA4ZTM1NjhjNmM1Nw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2014-03-03T20:14:52Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2014-03-03T20:14:52Z"}, "message": "libgo: Update to Go 1.2.1 release.\n\nFrom-SVN: r208286", "tree": {"sha": "fb0eb29cec9de27ca80e274d703ef63dd94e37c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fb0eb29cec9de27ca80e274d703ef63dd94e37c3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a10d35a8ba450c7b83f17c27f43a08e3568c6c57", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a10d35a8ba450c7b83f17c27f43a08e3568c6c57", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a10d35a8ba450c7b83f17c27f43a08e3568c6c57", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a10d35a8ba450c7b83f17c27f43a08e3568c6c57/comments", "author": null, "committer": null, "parents": [{"sha": "8c92028ea1afe080a34c7540363587b49aeddb2b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c92028ea1afe080a34c7540363587b49aeddb2b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c92028ea1afe080a34c7540363587b49aeddb2b"}], "stats": {"total": 82, "additions": 70, "deletions": 12}, "files": [{"sha": "cc27a7997766d8dcaf9bd13ddc6fa7c273545a1e", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a10d35a8ba450c7b83f17c27f43a08e3568c6c57/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a10d35a8ba450c7b83f17c27f43a08e3568c6c57/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=a10d35a8ba450c7b83f17c27f43a08e3568c6c57", "patch": "@@ -1,4 +1,4 @@\n-65bf677ab8d8\n+0ddbdc3c7ce2\n \n The first line of this file holds the Mercurial revision number of the\n last merge done from the master library sources."}, {"sha": "84a096513221bc197aa148ea5de34cfede84b28b", "filename": "libgo/go/database/sql/sql.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a10d35a8ba450c7b83f17c27f43a08e3568c6c57/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a10d35a8ba450c7b83f17c27f43a08e3568c6c57/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql.go?ref=a10d35a8ba450c7b83f17c27f43a08e3568c6c57", "patch": "@@ -620,8 +620,8 @@ func (db *DB) conn() (*driverConn, error) {\n \t}\n \n \t// If db.maxOpen > 0 and the number of open connections is over the limit\n-\t// or there are no free connection, then make a request and wait.\n-\tif db.maxOpen > 0 && (db.numOpen >= db.maxOpen || db.freeConn.Len() == 0) {\n+\t// and there are no free connection, make a request and wait.\n+\tif db.maxOpen > 0 && db.numOpen >= db.maxOpen && db.freeConn.Len() == 0 {\n \t\t// Make the connRequest channel. It's buffered so that the\n \t\t// connectionOpener doesn't block while waiting for the req to be read.\n \t\tch := make(chan interface{}, 1)"}, {"sha": "787a5c9f74423aeeda907390ee6979285a210f15", "filename": "libgo/go/database/sql/sql_test.go", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a10d35a8ba450c7b83f17c27f43a08e3568c6c57/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a10d35a8ba450c7b83f17c27f43a08e3568c6c57/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql_test.go?ref=a10d35a8ba450c7b83f17c27f43a08e3568c6c57", "patch": "@@ -1005,6 +1005,29 @@ func TestMaxOpenConns(t *testing.T) {\n \t}\n }\n \n+func TestSingleOpenConn(t *testing.T) {\n+\tdb := newTestDB(t, \"people\")\n+\tdefer closeDB(t, db)\n+\n+\tdb.SetMaxOpenConns(1)\n+\n+\trows, err := db.Query(\"SELECT|people|name|\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif err = rows.Close(); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\t// shouldn't deadlock\n+\trows, err = db.Query(\"SELECT|people|name|\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif err = rows.Close(); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+}\n+\n // golang.org/issue/5323\n func TestStmtCloseDeps(t *testing.T) {\n \tif testing.Short() {"}, {"sha": "630fc5e6f7192bdb6b563519a4bff408d1355f78", "filename": "libgo/go/net/fd_windows.go", "status": "modified", "additions": 40, "deletions": 8, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a10d35a8ba450c7b83f17c27f43a08e3568c6c57/libgo%2Fgo%2Fnet%2Ffd_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a10d35a8ba450c7b83f17c27f43a08e3568c6c57/libgo%2Fgo%2Fnet%2Ffd_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffd_windows.go?ref=a10d35a8ba450c7b83f17c27f43a08e3568c6c57", "patch": "@@ -513,12 +513,7 @@ func (fd *netFD) WriteTo(buf []byte, sa syscall.Sockaddr) (int, error) {\n \t})\n }\n \n-func (fd *netFD) accept(toAddr func(syscall.Sockaddr) Addr) (*netFD, error) {\n-\tif err := fd.readLock(); err != nil {\n-\t\treturn nil, err\n-\t}\n-\tdefer fd.readUnlock()\n-\n+func (fd *netFD) acceptOne(toAddr func(syscall.Sockaddr) Addr, rawsa []syscall.RawSockaddrAny, o *operation) (*netFD, error) {\n \t// Get new socket.\n \ts, err := sysSocket(fd.family, fd.sotype, 0)\n \tif err != nil {\n@@ -537,9 +532,7 @@ func (fd *netFD) accept(toAddr func(syscall.Sockaddr) Addr) (*netFD, error) {\n \t}\n \n \t// Submit accept request.\n-\to := &fd.rop\n \to.handle = s\n-\tvar rawsa [2]syscall.RawSockaddrAny\n \to.rsan = int32(unsafe.Sizeof(rawsa[0]))\n \t_, err = rsrv.ExecIO(o, \"AcceptEx\", func(o *operation) error {\n \t\treturn syscall.AcceptEx(o.fd.sysfd, o.handle, (*byte)(unsafe.Pointer(&rawsa[0])), 0, uint32(o.rsan), uint32(o.rsan), &o.qty, &o.o)\n@@ -556,6 +549,45 @@ func (fd *netFD) accept(toAddr func(syscall.Sockaddr) Addr) (*netFD, error) {\n \t\treturn nil, &OpError{\"Setsockopt\", fd.net, fd.laddr, err}\n \t}\n \n+\treturn netfd, nil\n+}\n+\n+func (fd *netFD) accept(toAddr func(syscall.Sockaddr) Addr) (*netFD, error) {\n+\tif err := fd.readLock(); err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer fd.readUnlock()\n+\n+\to := &fd.rop\n+\tvar netfd *netFD\n+\tvar err error\n+\tvar rawsa [2]syscall.RawSockaddrAny\n+\tfor {\n+\t\tnetfd, err = fd.acceptOne(toAddr, rawsa[:], o)\n+\t\tif err == nil {\n+\t\t\tbreak\n+\t\t}\n+\t\t// Sometimes we see WSAECONNRESET and ERROR_NETNAME_DELETED is\n+\t\t// returned here. These happen if connection reset is received\n+\t\t// before AcceptEx could complete. These errors relate to new\n+\t\t// connection, not to AcceptEx, so ignore broken connection and\n+\t\t// try AcceptEx again for more connections.\n+\t\toperr, ok := err.(*OpError)\n+\t\tif !ok {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\terrno, ok := operr.Err.(syscall.Errno)\n+\t\tif !ok {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tswitch errno {\n+\t\tcase syscall.ERROR_NETNAME_DELETED, syscall.WSAECONNRESET:\n+\t\t\t// ignore these and try again\n+\t\tdefault:\n+\t\t\treturn nil, err\n+\t\t}\n+\t}\n+\n \t// Get local and peer addr out of AcceptEx buffer.\n \tvar lrsa, rrsa *syscall.RawSockaddrAny\n \tvar llen, rlen int32"}, {"sha": "f963686e31359f8fa074b66e6b859d059d3f0d7d", "filename": "libgo/runtime/mgc0.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a10d35a8ba450c7b83f17c27f43a08e3568c6c57/libgo%2Fruntime%2Fmgc0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a10d35a8ba450c7b83f17c27f43a08e3568c6c57/libgo%2Fruntime%2Fmgc0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmgc0.c?ref=a10d35a8ba450c7b83f17c27f43a08e3568c6c57", "patch": "@@ -1770,6 +1770,8 @@ runtime_memorydump(void)\n void\n runtime_gchelper(void)\n {\n+\tuint32 nproc;\n+\n \tgchelperstart();\n \n \t// parallel mark for over gc roots\n@@ -1786,7 +1788,8 @@ runtime_gchelper(void)\n \n \truntime_parfordo(work.sweepfor);\n \tbufferList[runtime_m()->helpgc].busy = 0;\n-\tif(runtime_xadd(&work.ndone, +1) == work.nproc-1)\n+\tnproc = work.nproc;  // work.nproc can change right after we increment work.ndone\n+\tif(runtime_xadd(&work.ndone, +1) == nproc-1)\n \t\truntime_notewakeup(&work.alldone);\n }\n "}]}