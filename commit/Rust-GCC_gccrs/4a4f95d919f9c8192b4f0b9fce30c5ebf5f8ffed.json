{"sha": "4a4f95d919f9c8192b4f0b9fce30c5ebf5f8ffed", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGE0Zjk1ZDkxOWY5YzgxOTJiNGYwYjlmY2UzMGM1ZWJmNWY4ZmZlZA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-02-26T01:45:32Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-02-26T01:45:32Z"}, "message": "explow.c (force_reg): Call mark_reg_pointer as appropriate.\n\n        * explow.c (force_reg): Call mark_reg_pointer as appropriate.\n        * config/alpha/alpha.c (alpha_emit_conditional_branch): Don't\n        use (op0-op1) == 0 if op0 is a pointer.\n        * config/alpha/alpha.md (cmpdi): Use some_operand.\n        (three comparison combine splits): Remove.\n\nFrom-SVN: r78475", "tree": {"sha": "7d8ba2cbd41196e09164dbcd3753c2b0f9f360d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7d8ba2cbd41196e09164dbcd3753c2b0f9f360d4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4a4f95d919f9c8192b4f0b9fce30c5ebf5f8ffed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a4f95d919f9c8192b4f0b9fce30c5ebf5f8ffed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a4f95d919f9c8192b4f0b9fce30c5ebf5f8ffed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a4f95d919f9c8192b4f0b9fce30c5ebf5f8ffed/comments", "author": null, "committer": null, "parents": [{"sha": "0d593f318b033a47ef61d90ecbd85895dd811378", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d593f318b033a47ef61d90ecbd85895dd811378", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d593f318b033a47ef61d90ecbd85895dd811378"}], "stats": {"total": 148, "additions": 51, "deletions": 97}, "files": [{"sha": "4e1d24895e42f6adfac29085d7ad70fc1d2fe407", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a4f95d919f9c8192b4f0b9fce30c5ebf5f8ffed/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a4f95d919f9c8192b4f0b9fce30c5ebf5f8ffed/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4a4f95d919f9c8192b4f0b9fce30c5ebf5f8ffed", "patch": "@@ -1,3 +1,11 @@\n+2004-02-25  Richard Henderson  <rth@redhat.com>\n+\n+\t* explow.c (force_reg): Call mark_reg_pointer as appropriate.\n+\t* config/alpha/alpha.c (alpha_emit_conditional_branch): Don't\n+\tuse (op0-op1) == 0 if op0 is a pointer.\n+\t* config/alpha/alpha.md (cmpdi): Use some_operand.\n+\t(three comparison combine splits): Remove.\n+\n 2004-02-25  Richard Henderson  <rth@redhat.com>\n \n \tPR c/12794"}, {"sha": "5b78e62800062b610eae736ac08782af86acbd06", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a4f95d919f9c8192b4f0b9fce30c5ebf5f8ffed/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a4f95d919f9c8192b4f0b9fce30c5ebf5f8ffed/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=4a4f95d919f9c8192b4f0b9fce30c5ebf5f8ffed", "patch": "@@ -3179,7 +3179,13 @@ alpha_emit_conditional_branch (enum rtx_code code)\n \t  /* If the constants doesn't fit into an immediate, but can\n  \t     be generated by lda/ldah, we adjust the argument and\n  \t     compare against zero, so we can use beq/bne directly.  */\n-\t  else if (GET_CODE (op1) == CONST_INT && (code == EQ || code == NE))\n+\t  /* ??? Don't do this when comparing against symbols, otherwise\n+\t     we'll reduce (&x == 0x1234) to (&x-0x1234 == 0), which will\n+\t     be declared false out of hand (at least for non-weak).  */\n+\t  else if (GET_CODE (op1) == CONST_INT\n+\t\t   && (code == EQ || code == NE)\n+\t\t   && !(symbolic_operand (op0, VOIDmode)\n+\t\t\t|| (GET_CODE (op0) == REG && REG_POINTER (op0))))\n \t    {\n \t      HOST_WIDE_INT v = INTVAL (op1), n = -v;\n "}, {"sha": "79ae42214536a8b2b3959fcb7847f8f91271ffd7", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 2, "deletions": 96, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a4f95d919f9c8192b4f0b9fce30c5ebf5f8ffed/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a4f95d919f9c8192b4f0b9fce30c5ebf5f8ffed/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=4a4f95d919f9c8192b4f0b9fce30c5ebf5f8ffed", "patch": "@@ -3827,8 +3827,8 @@\n })\n \n (define_expand \"cmpdi\"\n-  [(set (cc0) (compare (match_operand:DI 0 \"general_operand\" \"\")\n-\t\t       (match_operand:DI 1 \"general_operand\" \"\")))]\n+  [(set (cc0) (compare (match_operand:DI 0 \"some_operand\" \"\")\n+\t\t       (match_operand:DI 1 \"some_operand\" \"\")))]\n   \"\"\n {\n   alpha_compare.op0 = operands[0];\n@@ -4160,100 +4160,6 @@\n \t\t\t\toperands[6], const0_rtx);\n })\n \n-(define_split\n-  [(set (pc)\n-\t(if_then_else\n-\t (match_operator 1 \"comparison_operator\"\n-\t\t\t [(match_operand:DI 2 \"reg_or_0_operand\" \"\")\n-\t\t\t  (match_operand:DI 3 \"reg_or_cint_operand\" \"\")])\n-\t (label_ref (match_operand 0 \"\" \"\"))\n-\t (pc)))\n-   (clobber (match_operand:DI 4 \"register_operand\" \"\"))]\n-  \"operands[3] != const0_rtx\"\n-  [(set (match_dup 4) (match_dup 5))\n-   (set (pc) (if_then_else (match_dup 6) (label_ref (match_dup 0)) (pc)))]\n-{\n-  enum rtx_code code = GET_CODE (operands[1]);\n-  int unsignedp = (code == GEU || code == LEU || code == GTU || code == LTU);\n-\n-  if (code == NE || code == EQ\n-      || (extended_count (operands[2], DImode, unsignedp) >= 1\n-\t  && extended_count (operands[3], DImode, unsignedp) >= 1))\n-    {\n-      if (GET_CODE (operands[3]) == CONST_INT)\n-\toperands[5] = gen_rtx_PLUS (DImode, operands[2],\n-\t\t\t\t    GEN_INT (- INTVAL (operands[3])));\n-      else\n-\toperands[5] = gen_rtx_MINUS (DImode, operands[2], operands[3]);\n-\n-      operands[6] = gen_rtx_fmt_ee (code, VOIDmode, operands[4], const0_rtx);\n-    }\n-\n-  else if (code == EQ || code == LE || code == LT\n-\t   || code == LEU || code == LTU)\n-    {\n-      operands[5] = gen_rtx_fmt_ee (code, DImode, operands[2], operands[3]);\n-      operands[6] = gen_rtx_NE (VOIDmode, operands[4], const0_rtx);\n-    }\n-  else\n-    {\n-      operands[5] = gen_rtx_fmt_ee (reverse_condition (code), DImode,\n-\t\t\t\t    operands[2], operands[3]);\n-      operands[6] = gen_rtx_EQ (VOIDmode, operands[4], const0_rtx);\n-    }\n-})\n-\n-(define_split\n-  [(set (pc)\n-\t(if_then_else\n-\t (match_operator 1 \"comparison_operator\"\n-\t\t\t [(match_operand:SI 2 \"reg_or_0_operand\" \"\")\n-\t\t\t  (match_operand:SI 3 \"const_int_operand\" \"\")])\n-\t (label_ref (match_operand 0 \"\" \"\"))\n-\t (pc)))\n-   (clobber (match_operand:DI 4 \"register_operand\" \"\"))]\n-  \"operands[3] != const0_rtx\n-   && (GET_CODE (operands[1]) == EQ || GET_CODE (operands[1]) == NE)\"\n-  [(set (match_dup 4) (match_dup 5))\n-   (set (pc) (if_then_else (match_dup 6) (label_ref (match_dup 0)) (pc)))]\n-{\n-  rtx tem;\n-\n-  if (GET_CODE (operands[3]) == CONST_INT)\n-    tem = gen_rtx_PLUS (SImode, operands[2],\n-\t\t\tGEN_INT (- INTVAL (operands[3])));\n-  else\n-    tem = gen_rtx_MINUS (SImode, operands[2], operands[3]);\n-\n-  operands[5] = gen_rtx_SIGN_EXTEND (DImode, tem);\n-  operands[6] = gen_rtx_fmt_ee (GET_CODE (operands[1]), VOIDmode,\n-\t\t\t\toperands[4], const0_rtx);\n-})\n-\n-;; We can convert such things as \"a > 0xffff\" to \"t = a & ~ 0xffff; t != 0\".\n-;; This eliminates one, and sometimes two, insns when the AND can be done\n-;; with a ZAP.\n-(define_split\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(match_operator:DI 1 \"comparison_operator\"\n-\t\t\t[(match_operand:DI 2 \"register_operand\" \"\")\n-\t\t\t (match_operand:DI 3 \"const_int_operand\" \"\")]))\n-   (clobber (match_operand:DI 4 \"register_operand\" \"\"))]\n-  \"exact_log2 (INTVAL (operands[3]) + 1) >= 0\n-   && (GET_CODE (operands[1]) == GTU\n-       || GET_CODE (operands[1]) == LEU\n-       || ((GET_CODE (operands[1]) == GT || GET_CODE (operands[1]) == LE)\n-\t   && extended_count (operands[2], DImode, 1) > 0))\"\n-  [(set (match_dup 4) (and:DI (match_dup 2) (match_dup 5)))\n-   (set (match_dup 0) (match_dup 6))]\n-{\n-  operands[5] = GEN_INT (~ INTVAL (operands[3]));\n-  operands[6] = gen_rtx_fmt_ee (((GET_CODE (operands[1]) == GTU\n-\t\t\t\t  || GET_CODE (operands[1]) == GT)\n-\t\t\t\t ? NE : EQ),\n-\t\t\t\tDImode, operands[4], const0_rtx);\n-})\n-\n ;; Prefer to use cmp and arithmetic when possible instead of a cmove.\n \n (define_split"}, {"sha": "d3f8c211ea2bc80040d6b01ef7ef732189dadf1e", "filename": "gcc/explow.c", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a4f95d919f9c8192b4f0b9fce30c5ebf5f8ffed/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a4f95d919f9c8192b4f0b9fce30c5ebf5f8ffed/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=4a4f95d919f9c8192b4f0b9fce30c5ebf5f8ffed", "patch": "@@ -721,6 +721,40 @@ force_reg (enum machine_mode mode, rtx x)\n       && ! rtx_equal_p (x, SET_SRC (set)))\n     set_unique_reg_note (insn, REG_EQUAL, x);\n \n+  /* Let optimizers know that TEMP is a pointer, and if so, the\n+     known alignment of that pointer.  */\n+  {\n+    unsigned align = 0;\n+    if (GET_CODE (x) == SYMBOL_REF)\n+      {\n+        align = BITS_PER_UNIT;\n+\tif (SYMBOL_REF_DECL (x) && DECL_P (SYMBOL_REF_DECL (x)))\n+\t  align = DECL_ALIGN (SYMBOL_REF_DECL (x));\n+      }\n+    else if (GET_CODE (x) == LABEL_REF)\n+      align = BITS_PER_UNIT;\n+    else if (GET_CODE (x) == CONST\n+\t     && GET_CODE (XEXP (x, 0)) == PLUS\n+\t     && GET_CODE (XEXP (XEXP (x, 0), 0)) == SYMBOL_REF\n+\t     && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT)\n+      {\n+\trtx s = XEXP (XEXP (x, 0), 0);\n+\trtx c = XEXP (XEXP (x, 0), 1);\n+\tunsigned sa, ca;\n+\n+\tsa = BITS_PER_UNIT;\n+\tif (SYMBOL_REF_DECL (s) && DECL_P (SYMBOL_REF_DECL (s)))\n+\t  sa = DECL_ALIGN (SYMBOL_REF_DECL (s));\n+\n+\tca = exact_log2 (INTVAL (c) & -INTVAL (c)) * BITS_PER_UNIT;\n+\n+\talign = MIN (sa, ca);\n+      }\n+\n+    if (align)\n+      mark_reg_pointer (temp, align);\n+  }\n+\n   return temp;\n }\n "}]}