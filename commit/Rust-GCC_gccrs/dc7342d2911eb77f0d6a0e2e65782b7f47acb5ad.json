{"sha": "dc7342d2911eb77f0d6a0e2e65782b7f47acb5ad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGM3MzQyZDI5MTFlYjc3ZjBkNmEwZTJlNjU3ODJiN2Y0N2FjYjVhZA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2016-12-05T09:30:57Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2016-12-05T09:30:57Z"}, "message": "sparc-protos.h (sparc_splitdi_legitimate): Rename to...\n\n\t* config/sparc/sparc-protos.h (sparc_splitdi_legitimate): Rename to...\n\t(sparc_split_reg_mem_legitimate): ...this.\n\t(sparc_split_reg_mem): Declare.\n\t(sparc_split_mem_reg): Likewise.\n\t(sparc_split_regreg_legitimate): Rename to...\n\t(sparc_split_reg_reg_legitimate): ...this.\n\t* config/sparc/sparc.c (sparc_splitdi_legitimate): Rename to...\n\t(sparc_split_reg_mem_legitimate): ...this.\n\t(sparc_split_reg_mem): New function.\n\t(sparc_split_mem_reg): Likewise.\n\t(sparc_split_regreg_legitimate): Rename to...\n\t(sparc_split_reg_reg_legitimate): ...this.\n\t(sparc_split_reg_reg): New function.\n\t* config/sparc/sparc.md (lra): Remove \"none\" value.\n\t(enabled): Adjust to above change.\n\t(*movdi_insn_sp32): Remove new (r,T) alternative and reorder others.\n\t(DImode splitters): Adjust to above renamings and use new functions.\n\t(*movdf_insn_sp32): Remove new (r,T) alternative and reorder others.\n\t(DFmode splitters): Adjust to above renamings and use new functions.\n\t(*mov<VM64:mode>_insn_sp64): Replace C with Z constraint and use W\n\tconstraint in conjunction with e.\n\t(*mov<VM64:mode>_insn_sp32): Remove new (r,T) alternative, add (o,Y)\n\talternative and reorder others.\n\t(VM64:mode splitters): Adjust to above renamings and use new functions.\n\nFrom-SVN: r243238", "tree": {"sha": "f105d6a81a25cdc711773103117943ce614b4413", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f105d6a81a25cdc711773103117943ce614b4413"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc7342d2911eb77f0d6a0e2e65782b7f47acb5ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc7342d2911eb77f0d6a0e2e65782b7f47acb5ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc7342d2911eb77f0d6a0e2e65782b7f47acb5ad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc7342d2911eb77f0d6a0e2e65782b7f47acb5ad/comments", "author": null, "committer": null, "parents": [{"sha": "b2a8d083c5f5a0484a1a228e0db7fa7b8cf59473", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2a8d083c5f5a0484a1a228e0db7fa7b8cf59473", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2a8d083c5f5a0484a1a228e0db7fa7b8cf59473"}], "stats": {"total": 497, "additions": 242, "deletions": 255}, "files": [{"sha": "730044c70861ffea9a3115d64656ef4b9a41f6fe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc7342d2911eb77f0d6a0e2e65782b7f47acb5ad/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc7342d2911eb77f0d6a0e2e65782b7f47acb5ad/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dc7342d2911eb77f0d6a0e2e65782b7f47acb5ad", "patch": "@@ -1,3 +1,30 @@\n+2016-12-05  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* config/sparc/sparc-protos.h (sparc_splitdi_legitimate): Rename to...\n+\t(sparc_split_reg_mem_legitimate): ...this.\n+\t(sparc_split_reg_mem): Declare.\n+\t(sparc_split_mem_reg): Likewise.\n+\t(sparc_split_regreg_legitimate): Rename to...\n+\t(sparc_split_reg_reg_legitimate): ...this.\n+\t* config/sparc/sparc.c (sparc_splitdi_legitimate): Rename to...\n+\t(sparc_split_reg_mem_legitimate): ...this.\n+\t(sparc_split_reg_mem): New function.\n+\t(sparc_split_mem_reg): Likewise.\n+\t(sparc_split_regreg_legitimate): Rename to...\n+\t(sparc_split_reg_reg_legitimate): ...this.\n+\t(sparc_split_reg_reg): New function.\n+\t* config/sparc/sparc.md (lra): Remove \"none\" value.\n+\t(enabled): Adjust to above change.\n+\t(*movdi_insn_sp32): Remove new (r,T) alternative and reorder others.\n+\t(DImode splitters): Adjust to above renamings and use new functions.\n+\t(*movdf_insn_sp32): Remove new (r,T) alternative and reorder others.\n+\t(DFmode splitters): Adjust to above renamings and use new functions.\n+\t(*mov<VM64:mode>_insn_sp64): Replace C with Z constraint and use W\n+\tconstraint in conjunction with e.\n+\t(*mov<VM64:mode>_insn_sp32): Remove new (r,T) alternative, add (o,Y)\n+\talternative and reorder others.\n+\t(VM64:mode splitters): Adjust to above renamings and use new functions.\n+\n 2016-12-04  Martin Sebor  <msebor@redhat.com>\n \n \tPR c/78668"}, {"sha": "931e69325750672b1c2c676f127e47bb3a05b7f8", "filename": "gcc/config/sparc/sparc-protos.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc7342d2911eb77f0d6a0e2e65782b7f47acb5ad/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc7342d2911eb77f0d6a0e2e65782b7f47acb5ad/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h?ref=dc7342d2911eb77f0d6a0e2e65782b7f47acb5ad", "patch": "@@ -68,8 +68,11 @@ extern void sparc_emit_call_insn (rtx, rtx);\n extern void sparc_defer_case_vector (rtx, rtx, int);\n extern bool sparc_expand_move (machine_mode, rtx *);\n extern void sparc_emit_set_symbolic_const64 (rtx, rtx, rtx);\n-extern int sparc_splitdi_legitimate (rtx, rtx);\n-extern int sparc_split_regreg_legitimate (rtx, rtx);\n+extern int sparc_split_reg_mem_legitimate (rtx, rtx);\n+extern void sparc_split_reg_mem (rtx, rtx, machine_mode);\n+extern void sparc_split_mem_reg (rtx, rtx, machine_mode);\n+extern int sparc_split_reg_reg_legitimate (rtx, rtx);\n+extern void sparc_split_reg_reg (rtx, rtx, machine_mode);\n extern const char *output_ubranch (rtx, rtx_insn *);\n extern const char *output_cbranch (rtx, rtx, int, int, int, rtx_insn *);\n extern const char *output_return (rtx_insn *);"}, {"sha": "a5537a136d5bc17da9281bc7c1d4d5421de071bf", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 70, "deletions": 10, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc7342d2911eb77f0d6a0e2e65782b7f47acb5ad/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc7342d2911eb77f0d6a0e2e65782b7f47acb5ad/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=dc7342d2911eb77f0d6a0e2e65782b7f47acb5ad", "patch": "@@ -8484,46 +8484,82 @@ order_regs_for_local_alloc (void)\n }\n \f\n /* Return 1 if REG and MEM are legitimate enough to allow the various\n-   mem<-->reg splits to be run.  */\n+   MEM<-->REG splits to be run.  */\n \n int\n-sparc_splitdi_legitimate (rtx reg, rtx mem)\n+sparc_split_reg_mem_legitimate (rtx reg, rtx mem)\n {\n   /* Punt if we are here by mistake.  */\n   gcc_assert (reload_completed);\n \n   /* We must have an offsettable memory reference.  */\n-  if (! offsettable_memref_p (mem))\n+  if (!offsettable_memref_p (mem))\n     return 0;\n \n   /* If we have legitimate args for ldd/std, we do not want\n      the split to happen.  */\n-  if ((REGNO (reg) % 2) == 0\n-      && mem_min_alignment (mem, 8))\n+  if ((REGNO (reg) % 2) == 0 && mem_min_alignment (mem, 8))\n     return 0;\n \n   /* Success.  */\n   return 1;\n }\n \n-/* Like sparc_splitdi_legitimate but for REG <--> REG moves.  */\n+/* Split a REG <-- MEM move into a pair of moves in MODE.  */\n+\n+void\n+sparc_split_reg_mem (rtx dest, rtx src, machine_mode mode)\n+{\n+  rtx high_part = gen_highpart (mode, dest);\n+  rtx low_part = gen_lowpart (mode, dest);\n+  rtx word0 = adjust_address (src, mode, 0);\n+  rtx word1 = adjust_address (src, mode, 4);\n+\n+  if (reg_overlap_mentioned_p (high_part, word1))\n+    {\n+      emit_move_insn_1 (low_part, word1);\n+      emit_move_insn_1 (high_part, word0);\n+    }\n+  else\n+    {\n+      emit_move_insn_1 (high_part, word0);\n+      emit_move_insn_1 (low_part, word1);\n+    }\n+}\n+\n+/* Split a MEM <-- REG move into a pair of moves in MODE.  */\n+\n+void\n+sparc_split_mem_reg (rtx dest, rtx src, machine_mode mode)\n+{\n+  rtx word0 = adjust_address (dest, mode, 0);\n+  rtx word1 = adjust_address (dest, mode, 4);\n+  rtx high_part = gen_highpart (mode, src);\n+  rtx low_part = gen_lowpart (mode, src);\n+\n+  emit_move_insn_1 (word0, high_part);\n+  emit_move_insn_1 (word1, low_part);\n+}\n+\n+/* Like sparc_split_reg_mem_legitimate but for REG <--> REG moves.  */\n \n int\n-sparc_split_regreg_legitimate (rtx reg1, rtx reg2)\n+sparc_split_reg_reg_legitimate (rtx reg1, rtx reg2)\n {\n-  int regno1, regno2;\n+  /* Punt if we are here by mistake.  */\n+  gcc_assert (reload_completed);\n \n   if (GET_CODE (reg1) == SUBREG)\n     reg1 = SUBREG_REG (reg1);\n   if (GET_CODE (reg1) != REG)\n     return 0;\n-  regno1 = REGNO (reg1);\n+  const int regno1 = REGNO (reg1);\n \n   if (GET_CODE (reg2) == SUBREG)\n     reg2 = SUBREG_REG (reg2);\n   if (GET_CODE (reg2) != REG)\n     return 0;\n-  regno2 = REGNO (reg2);\n+  const int regno2 = REGNO (reg2);\n \n   if (SPARC_INT_REG_P (regno1) && SPARC_INT_REG_P (regno2))\n     return 1;\n@@ -8538,6 +8574,30 @@ sparc_split_regreg_legitimate (rtx reg1, rtx reg2)\n   return 0;\n }\n \n+/* Split a REG <--> REG move into a pair of moves in MODE.  */\n+\n+void\n+sparc_split_reg_reg (rtx dest, rtx src, machine_mode mode)\n+{\n+  rtx dest1 = gen_highpart (mode, dest);\n+  rtx dest2 = gen_lowpart (mode, dest);\n+  rtx src1 = gen_highpart (mode, src);\n+  rtx src2 = gen_lowpart (mode, src);\n+\n+  /* Now emit using the real source and destination we found, swapping\n+     the order if we detect overlap.  */\n+  if (reg_overlap_mentioned_p (dest1, src2))\n+    {\n+      emit_move_insn_1 (dest2, src2);\n+      emit_move_insn_1 (dest1, src1);\n+    }\n+  else\n+    {\n+      emit_move_insn_1 (dest1, src1);\n+      emit_move_insn_1 (dest2, src2);\n+    }\n+}\n+\n /* Return 1 if REGNO (reg1) is even and REGNO (reg1) == REGNO (reg2) - 1.\n    This makes them candidates for using ldd and std insns.\n "}, {"sha": "767d50844dff30eea75f0f1d4619c23f7592a899", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 140, "deletions": 243, "changes": 383, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc7342d2911eb77f0d6a0e2e65782b7f47acb5ad/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc7342d2911eb77f0d6a0e2e65782b7f47acb5ad/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=dc7342d2911eb77f0d6a0e2e65782b7f47acb5ad", "patch": "@@ -254,14 +254,12 @@\n (define_attr \"cpu_feature\" \"none,fpu,fpunotv9,v9,vis,vis3,vis4\"\n   (const_string \"none\"))\n \n-(define_attr \"lra\" \"none,disabled,enabled\"\n-  (const_string \"none\"))\n+(define_attr \"lra\" \"disabled,enabled\"\n+  (const_string \"enabled\"))\n \n (define_attr \"enabled\" \"\"\n   (cond [(eq_attr \"cpu_feature\" \"none\")\n-\t   (cond [(eq_attr \"lra\" \"disabled\") (symbol_ref \"!TARGET_LRA\")\n-\t\t  (eq_attr \"lra\" \"enabled\") (symbol_ref \"TARGET_LRA\")]\n-\t\t (const_int 1))\n+           (cond [(eq_attr \"lra\" \"disabled\") (symbol_ref \"!TARGET_LRA\")] (const_int 1))\n          (eq_attr \"cpu_feature\" \"fpu\") (symbol_ref \"TARGET_FPU\")\n          (eq_attr \"cpu_feature\" \"fpunotv9\") (symbol_ref \"TARGET_FPU && !TARGET_V9\")\n          (eq_attr \"cpu_feature\" \"v9\") (symbol_ref \"TARGET_V9\")\n@@ -1707,25 +1705,23 @@\n \n (define_insn \"*movdi_insn_sp32\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\"\n-\t\t\t    \"=T,o,T,T,U,r,o,r,r,r,?T,?*f,?*f,?o,?*e,?*e,  r,?*f,?*e,?W,b,b\")\n+\t\t\t    \"=T,o,U,T,r,o,r,r,?*f,?T,?*f,?o,?*e,?*e,  r,?*f,?*e,?W,*b,*b\")\n         (match_operand:DI 1 \"input_operand\"\n-\t\t\t    \" J,J,U,r,T,T,r,o,i,r,*f,  T,  o,*f, *e, *e,?*f,  r,  W,*e,J,P\"))]\n+\t\t\t    \" J,J,T,U,o,r,i,r,  T,*f,  o,*f, *e, *e,?*f,  r,  W,*e, J, P\"))]\n   \"TARGET_ARCH32\n    && (register_operand (operands[0], DImode)\n        || register_or_zero_operand (operands[1], DImode))\"\n   \"@\n-   stx\\t%%g0, %0\n+   stx\\t%r1, %0\n    #\n-   std\\t%1, %0\n-   std\\t%1, %0\n    ldd\\t%1, %0\n+   std\\t%1, %0\n    ldd\\t%1, %0\n+   std\\t%1, %0\n    #\n    #\n-   #\n-   #\n-   std\\t%1, %0\n    ldd\\t%1, %0\n+   std\\t%1, %0\n    #\n    #\n    fmovd\\t%1, %0\n@@ -1736,12 +1732,12 @@\n    std\\t%1, %0\n    fzero\\t%0\n    fone\\t%0\"\n-  [(set_attr \"type\" \"store,store,store,store,load,load,*,*,*,*,fpstore,fpload,*,*,fpmove,*,*,*,fpload,fpstore,visl,visl\")\n-   (set_attr \"length\" \"*,2,*,*,*,*,2,2,2,2,*,*,2,2,*,2,2,2,*,*,*,*\")\n-   (set_attr \"fptype\" \"*,*,*,*,*,*,*,*,*,*,*,*,*,*,double,*,*,*,*,*,double,double\")\n-   (set_attr \"cpu_feature\" \"v9,*,*,*,*,*,*,*,*,*,fpu,fpu,fpu,fpu,v9,fpunotv9,vis3,vis3,fpu,fpu,vis,vis\")\n-   (set_attr \"v3pipe\" \"*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,true,true\")\n-   (set_attr \"lra\" \"*,*,disabled,enabled,disabled,enabled,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*\")])\n+  [(set_attr \"type\" \"store,*,load,store,load,store,*,*,fpload,fpstore,*,*,fpmove,*,*,*,fpload,fpstore,visl,visl\")\n+   (set_attr \"length\" \"*,2,*,*,*,*,2,2,*,*,2,2,*,2,2,2,*,*,*,*\")\n+   (set_attr \"fptype\" \"*,*,*,*,*,*,*,*,*,*,*,*,double,*,*,*,*,*,double,double\")\n+   (set_attr \"cpu_feature\" \"v9,*,*,*,*,*,*,*,fpu,fpu,fpu,fpu,v9,fpunotv9,vis3,vis3,fpu,fpu,vis,vis\")\n+   (set_attr \"v3pipe\" \"*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,true,true\")\n+   (set_attr \"lra\" \"*,*,disabled,disabled,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*\")])\n \n (define_insn \"*movdi_insn_sp64\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,r, m, r,*e,?*e,?*e,?W,b,b\")\n@@ -1997,30 +1993,27 @@\n (define_split\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n         (match_operand:DI 1 \"const_int_operand\" \"\"))]\n-  \"TARGET_ARCH32\n+  \"reload_completed\n+   && TARGET_ARCH32\n    && ((GET_CODE (operands[0]) == REG\n         && SPARC_INT_REG_P (REGNO (operands[0])))\n        || (GET_CODE (operands[0]) == SUBREG\n            && GET_CODE (SUBREG_REG (operands[0])) == REG\n-           && SPARC_INT_REG_P (REGNO (SUBREG_REG (operands[0])))))\n-   && reload_completed\"\n+           && SPARC_INT_REG_P (REGNO (SUBREG_REG (operands[0])))))\"\n   [(clobber (const_int 0))]\n {\n-  HOST_WIDE_INT low, high;\n+  HOST_WIDE_INT low = trunc_int_for_mode (INTVAL (operands[1]), SImode);\n+  HOST_WIDE_INT high = trunc_int_for_mode (INTVAL (operands[1]) >> 32, SImode);\n+  rtx high_part = gen_highpart (SImode, operands[0]);\n+  rtx low_part = gen_lowpart (SImode, operands[0]);\n \n-  low = trunc_int_for_mode (INTVAL (operands[1]), SImode);\n-  high = trunc_int_for_mode (INTVAL (operands[1]) >> 32, SImode);\n-  emit_insn (gen_movsi (gen_highpart (SImode, operands[0]), GEN_INT (high)));\n+  emit_move_insn_1 (high_part, GEN_INT (high));\n \n-  /* Slick... but this trick loses if this subreg constant part\n-     can be done in one insn.  */\n-  if (low == high\n-      && !SPARC_SETHI32_P (high)\n-      && !SPARC_SIMM13_P (high))\n-    emit_insn (gen_movsi (gen_lowpart (SImode, operands[0]),\n-\t\t\t  gen_highpart (SImode, operands[0])));\n+  /* Slick... but this loses if the constant can be done in one insn.  */\n+  if (low == high && !SPARC_SETHI32_P (high) && !SPARC_SIMM13_P (high))\n+    emit_move_insn_1 (low_part, high_part);\n   else\n-    emit_insn (gen_movsi (gen_lowpart (SImode, operands[0]), GEN_INT (low)));\n+    emit_move_insn_1 (low_part, GEN_INT (low));\n \n   DONE;\n })\n@@ -2031,31 +2024,10 @@\n   \"reload_completed\n    && (!TARGET_V9\n        || (TARGET_ARCH32\n-           && sparc_split_regreg_legitimate (operands[0], operands[1])))\"\n+           && sparc_split_reg_reg_legitimate (operands[0], operands[1])))\"\n   [(clobber (const_int 0))]\n {\n-  rtx set_dest = operands[0];\n-  rtx set_src = operands[1];\n-  rtx dest1, dest2;\n-  rtx src1, src2;\n-\n-  dest1 = gen_highpart (SImode, set_dest);\n-  dest2 = gen_lowpart (SImode, set_dest);\n-  src1 = gen_highpart (SImode, set_src);\n-  src2 = gen_lowpart (SImode, set_src);\n-\n-  /* Now emit using the real source and destination we found, swapping\n-     the order if we detect overlap.  */\n-  if (reg_overlap_mentioned_p (dest1, src2))\n-    {\n-      emit_insn (gen_movsi (dest2, src2));\n-      emit_insn (gen_movsi (dest1, src1));\n-    }\n-  else\n-    {\n-      emit_insn (gen_movsi (dest1, src1));\n-      emit_insn (gen_movsi (dest2, src2));\n-    }\n+  sparc_split_reg_reg (operands[0], operands[1], SImode);\n   DONE;\n })\n \n@@ -2064,41 +2036,24 @@\n (define_split\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n         (match_operand:DI 1 \"memory_operand\" \"\"))]\n-  \"(TARGET_ARCH32\n-    && reload_completed\n-    && sparc_splitdi_legitimate (operands[0], operands[1]))\"\n+  \"reload_completed\n+   && TARGET_ARCH32\n+   && sparc_split_reg_mem_legitimate (operands[0], operands[1])\"\n   [(clobber (const_int 0))]\n {\n-  rtx word0 = adjust_address (operands[1], SImode, 0);\n-  rtx word1 = adjust_address (operands[1], SImode, 4);\n-  rtx high_part = gen_highpart (SImode, operands[0]);\n-  rtx low_part = gen_lowpart (SImode, operands[0]);\n-\n-  if (reg_overlap_mentioned_p (high_part, word1))\n-    {\n-      emit_insn (gen_movsi (low_part, word1));\n-      emit_insn (gen_movsi (high_part, word0));\n-    }\n-  else\n-    {\n-      emit_insn (gen_movsi (high_part, word0));\n-      emit_insn (gen_movsi (low_part, word1));\n-    }\n+  sparc_split_reg_mem (operands[0], operands[1], SImode);\n   DONE;\n })\n \n (define_split\n   [(set (match_operand:DI 0 \"memory_operand\" \"\")\n         (match_operand:DI 1 \"register_operand\" \"\"))]\n-  \"(TARGET_ARCH32\n-    && reload_completed\n-    && sparc_splitdi_legitimate (operands[1], operands[0]))\"\n+  \"reload_completed\n+   && TARGET_ARCH32\n+   && sparc_split_reg_mem_legitimate (operands[1], operands[0])\"\n   [(clobber (const_int 0))]\n {\n-  emit_insn (gen_movsi (adjust_address (operands[0], SImode, 0),\n-\t\t\tgen_highpart (SImode, operands[1])));\n-  emit_insn (gen_movsi (adjust_address (operands[0], SImode, 4),\n-\t\t\tgen_lowpart (SImode, operands[1])));\n+  sparc_split_mem_reg (operands[0], operands[1], SImode);\n   DONE;\n })\n \n@@ -2112,8 +2067,8 @@\n    && offsettable_memref_p (operands[0])\"\n   [(clobber (const_int 0))]\n {\n-  emit_insn (gen_movsi (adjust_address (operands[0], SImode, 0), const0_rtx));\n-  emit_insn (gen_movsi (adjust_address (operands[0], SImode, 4), const0_rtx));\n+  emit_move_insn_1 (adjust_address (operands[0], SImode, 0), const0_rtx);\n+  emit_move_insn_1 (adjust_address (operands[0], SImode, 4), const0_rtx);\n   DONE;\n })\n \n@@ -2381,36 +2336,36 @@\n \n (define_insn \"*movdf_insn_sp32\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\"\n-\t\t\t    \"=b,b,e,e,*r, f,  e,T,W,U,r,T,T,  f,  *r,  o,o\")\n+\t\t\t    \"=T,o,b,b,e,e,*r, f,  e,W,U,T,  f,o, *r,*r, o\")\n \t(match_operand:DF 1 \"input_operand\"\n-\t\t\t    \" G,C,e,e, f,*r,W#F,G,e,T,T,U,r,o#F,*roF,*rG,f\"))]\n+\t\t\t    \" G,G,G,C,e,e, f,*r,W#F,e,T,U,o#F,f,*rF, o,*r\"))]\n   \"TARGET_ARCH32\n    && (register_operand (operands[0], DFmode)\n        || register_or_zero_or_all_ones_operand (operands[1], DFmode))\"\n   \"@\n+  stx\\t%r1, %0\n+  #\n   fzero\\t%0\n   fone\\t%0\n   fmovd\\t%1, %0\n   #\n   #\n   #\n   ldd\\t%1, %0\n-  stx\\t%r1, %0\n   std\\t%1, %0\n   ldd\\t%1, %0\n-  ldd\\t%1, %0\n-  std\\t%1, %0\n   std\\t%1, %0\n   #\n   #\n   #\n-  #\"\n-  [(set_attr \"type\" \"visl,visl,fpmove,*,*,*,fpload,store,fpstore,load,load,store,store,*,*,*,*\")\n-   (set_attr \"length\" \"*,*,*,2,2,2,*,*,*,*,*,*,*,2,2,2,2\")\n-   (set_attr \"fptype\" \"double,double,double,*,*,*,*,*,*,*,*,*,*,*,*,*,*\")\n-   (set_attr \"cpu_feature\" \"vis,vis,v9,fpunotv9,vis3,vis3,fpu,v9,fpu,*,*,*,*,fpu,*,*,fpu\")\n-   (set_attr \"v3pipe\" \"true,true,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*\")\n-   (set_attr \"lra\" \"*,*,*,*,*,*,*,*,*,disabled,enabled,disabled,enabled,*,*,*,*\")])\n+  ldd\\t%1, %0\n+  std\\t%1, %0\"\n+  [(set_attr \"type\" \"store,*,visl,visl,fpmove,*,*,*,fpload,fpstore,load,store,*,*,*,load,store\")\n+   (set_attr \"length\" \"*,2,*,*,*,2,2,2,*,*,*,*,2,2,2,*,*\")\n+   (set_attr \"fptype\" \"*,*,double,double,double,*,*,*,*,*,*,*,*,*,*,*,*\")\n+   (set_attr \"cpu_feature\" \"v9,*,vis,vis,v9,fpunotv9,vis3,vis3,fpu,fpu,*,*,fpu,fpu,*,*,*\")\n+   (set_attr \"v3pipe\" \"*,*,true,true,*,*,*,*,*,*,*,*,*,*,*,*,*\")\n+   (set_attr \"lra\" \"*,*,*,*,*,*,*,*,*,*,disabled,disabled,*,*,*,*,*\")])\n \n (define_insn \"*movdf_insn_sp64\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=b,b,e,*r, e,  e,W, *r,*r,  m,*r\")\n@@ -2440,44 +2395,38 @@\n (define_split\n   [(set (match_operand:DF 0 \"register_operand\" \"\")\n         (match_operand:DF 1 \"const_double_operand\" \"\"))]\n-  \"REG_P (operands[0])\n+  \"reload_completed\n+   && REG_P (operands[0])\n    && SPARC_INT_REG_P (REGNO (operands[0]))\n-   && !const_zero_operand (operands[1], GET_MODE (operands[0]))\n-   && reload_completed\"\n+   && !const_zero_operand (operands[1], GET_MODE (operands[0]))\"\n   [(clobber (const_int 0))]\n {\n   operands[0] = gen_raw_REG (DImode, REGNO (operands[0]));\n \n   if (TARGET_ARCH64)\n     {\n-      machine_mode mode = GET_MODE (operands[1]);\n-      rtx tem = simplify_subreg (DImode, operands[1], mode, 0);\n+      rtx tem = simplify_subreg (DImode, operands[1], DFmode, 0);\n       emit_insn (gen_movdi (operands[0], tem));\n     }\n   else\n     {\n-      machine_mode mode = GET_MODE (operands[1]);\n-      rtx hi = simplify_subreg (SImode, operands[1], mode, 0);\n-      rtx lo = simplify_subreg (SImode, operands[1], mode, 4);\n+      rtx hi = simplify_subreg (SImode, operands[1], DFmode, 0);\n+      rtx lo = simplify_subreg (SImode, operands[1], DFmode, 4);\n+      rtx high_part = gen_highpart (SImode, operands[0]);\n+      rtx low_part = gen_lowpart (SImode, operands[0]);\n \n       gcc_assert (GET_CODE (hi) == CONST_INT);\n       gcc_assert (GET_CODE (lo) == CONST_INT);\n \n-      emit_insn (gen_movsi (gen_highpart (SImode, operands[0]), hi));\n+      emit_move_insn_1 (high_part, hi);\n \n-      /* Slick... but this trick loses if this subreg constant part\n-         can be done in one insn.  */\n+      /* Slick... but this loses if the constant can be done in one insn.  */\n       if (lo == hi\n \t  && !SPARC_SETHI32_P (INTVAL (hi))\n \t  && !SPARC_SIMM13_P (INTVAL (hi)))\n-        {\n-          emit_insn (gen_movsi (gen_lowpart (SImode, operands[0]),\n-\t\t\t        gen_highpart (SImode, operands[0])));\n-        }\n+\temit_move_insn_1 (low_part, high_part);\n       else\n-        {\n-          emit_insn (gen_movsi (gen_lowpart (SImode, operands[0]), lo));\n-        }\n+\temit_move_insn_1 (low_part, lo);\n     }\n   DONE;\n })\n@@ -2489,35 +2438,31 @@\n ;; register DFmode cases must be handled.\n (define_split\n   [(set (match_operand:DF 0 \"register_operand\" \"\")\n-        (match_operand:DF 1 \"register_operand\" \"\"))]\n-  \"(!TARGET_V9\n-    || (TARGET_ARCH32\n-        && sparc_split_regreg_legitimate (operands[0], operands[1])))\n-   && reload_completed\"\n+        (match_operand:DF 1 \"const_zero_operand\" \"\"))]\n+  \"reload_completed\n+   && TARGET_ARCH32\n+   && ((GET_CODE (operands[0]) == REG\n+\t&& SPARC_INT_REG_P (REGNO (operands[0])))\n+       || (GET_CODE (operands[0]) == SUBREG\n+\t   && GET_CODE (SUBREG_REG (operands[0])) == REG\n+\t   && SPARC_INT_REG_P (REGNO (SUBREG_REG (operands[0])))))\"\n   [(clobber (const_int 0))]\n {\n-  rtx set_dest = operands[0];\n-  rtx set_src = operands[1];\n-  rtx dest1, dest2;\n-  rtx src1, src2;\n-\n-  dest1 = gen_highpart (SFmode, set_dest);\n-  dest2 = gen_lowpart (SFmode, set_dest);\n-  src1 = gen_highpart (SFmode, set_src);\n-  src2 = gen_lowpart (SFmode, set_src);\n+  emit_move_insn_1 (gen_highpart (SFmode, operands[0]), CONST0_RTX (SFmode));\n+  emit_move_insn_1 (gen_lowpart (SFmode, operands[0]), CONST0_RTX (SFmode));\n+  DONE;\n+})\n \n-  /* Now emit using the real source and destination we found, swapping\n-     the order if we detect overlap.  */\n-  if (reg_overlap_mentioned_p (dest1, src2))\n-    {\n-      emit_move_insn_1 (dest2, src2);\n-      emit_move_insn_1 (dest1, src1);\n-    }\n-  else\n-    {\n-      emit_move_insn_1 (dest1, src1);\n-      emit_move_insn_1 (dest2, src2);\n-    }\n+(define_split\n+  [(set (match_operand:DF 0 \"register_operand\" \"\")\n+        (match_operand:DF 1 \"register_operand\" \"\"))]\n+  \"reload_completed\n+   && (!TARGET_V9\n+       || (TARGET_ARCH32\n+\t   && sparc_split_reg_reg_legitimate (operands[0], operands[1])))\"\n+  [(clobber (const_int 0))]\n+{\n+  sparc_split_reg_reg (operands[0], operands[1], SFmode);\n   DONE;\n })\n \n@@ -2526,26 +2471,10 @@\n \t(match_operand:DF 1 \"memory_operand\" \"\"))]\n   \"reload_completed\n    && TARGET_ARCH32\n-   && (((REGNO (operands[0]) % 2) != 0)\n-       || !mem_min_alignment (operands[1], 8))\n-   && offsettable_memref_p (operands[1])\"\n+   && sparc_split_reg_mem_legitimate (operands[0], operands[1])\"\n   [(clobber (const_int 0))]\n {\n-  rtx word0, word1;\n-\n-  word0 = adjust_address (operands[1], SFmode, 0);\n-  word1 = adjust_address (operands[1], SFmode, 4);\n-\n-  if (reg_overlap_mentioned_p (gen_highpart (SFmode, operands[0]), word1))\n-    {\n-      emit_move_insn_1 (gen_lowpart (SFmode, operands[0]), word1);\n-      emit_move_insn_1 (gen_highpart (SFmode, operands[0]), word0);\n-    }\n-  else\n-    {\n-      emit_move_insn_1 (gen_highpart (SFmode, operands[0]), word0);\n-      emit_move_insn_1 (gen_lowpart (SFmode, operands[0]), word1);\n-    }\n+  sparc_split_reg_mem (operands[0], operands[1], SFmode);\n   DONE;\n })\n \n@@ -2554,18 +2483,10 @@\n \t(match_operand:DF 1 \"register_operand\" \"\"))]\n   \"reload_completed\n    && TARGET_ARCH32\n-   && (((REGNO (operands[1]) % 2) != 0)\n-       || !mem_min_alignment (operands[0], 8))\n-   && offsettable_memref_p (operands[0])\"\n+   && sparc_split_reg_mem_legitimate (operands[1], operands[0])\"\n   [(clobber (const_int 0))]\n {\n-  rtx word0, word1;\n-\n-  word0 = adjust_address (operands[0], SFmode, 0);\n-  word1 = adjust_address (operands[0], SFmode, 4);\n-\n-  emit_move_insn_1 (word0, gen_highpart (SFmode, operands[1]));\n-  emit_move_insn_1 (word1, gen_lowpart (SFmode, operands[1]));\n+  sparc_split_mem_reg (operands[0], operands[1], SFmode);\n   DONE;\n })\n \n@@ -2579,35 +2500,8 @@\n    && offsettable_memref_p (operands[0])\"\n   [(clobber (const_int 0))]\n {\n-  rtx dest1, dest2;\n-\n-  dest1 = adjust_address (operands[0], SFmode, 0);\n-  dest2 = adjust_address (operands[0], SFmode, 4);\n-\n-  emit_move_insn_1 (dest1, CONST0_RTX (SFmode));\n-  emit_move_insn_1 (dest2, CONST0_RTX (SFmode));\n-  DONE;\n-})\n-\n-(define_split\n-  [(set (match_operand:DF 0 \"register_operand\" \"\")\n-        (match_operand:DF 1 \"const_zero_operand\" \"\"))]\n-  \"reload_completed\n-   && TARGET_ARCH32\n-   && ((GET_CODE (operands[0]) == REG\n-\t&& SPARC_INT_REG_P (REGNO (operands[0])))\n-       || (GET_CODE (operands[0]) == SUBREG\n-\t   && GET_CODE (SUBREG_REG (operands[0])) == REG\n-\t   && SPARC_INT_REG_P (REGNO (SUBREG_REG (operands[0])))))\"\n-  [(clobber (const_int 0))]\n-{\n-  rtx set_dest = operands[0];\n-  rtx dest1, dest2;\n-\n-  dest1 = gen_highpart (SFmode, set_dest);\n-  dest2 = gen_lowpart (SFmode, set_dest);\n-  emit_move_insn_1 (dest1, CONST0_RTX (SFmode));\n-  emit_move_insn_1 (dest2, CONST0_RTX (SFmode));\n+  emit_move_insn_1 (adjust_address (operands[0], SFmode, 0), CONST0_RTX (SFmode));\n+  emit_move_insn_1 (adjust_address (operands[0], SFmode, 4), CONST0_RTX (SFmode));\n   DONE;\n })\n \n@@ -8625,8 +8519,8 @@\n    (set_attr \"v3pipe\" \"true,true,true,*,*,*,*,*,*,true,true\")])\n \n (define_insn \"*mov<VM64:mode>_insn_sp64\"\n-  [(set (match_operand:VM64 0 \"nonimmediate_operand\" \"=e,e,e,e,m,m,*r, m,*r, e,*r\")\n-\t(match_operand:VM64 1 \"input_operand\"         \"Y,C,e,m,e,Y, m,*r, e,*r,*r\"))]\n+  [(set (match_operand:VM64 0 \"nonimmediate_operand\" \"=e,e,e,e,W,m,*r, m,*r, e,*r\")\n+\t(match_operand:VM64 1 \"input_operand\"         \"Y,Z,e,W,e,Y, m,*r, e,*r,*r\"))]\n   \"TARGET_VIS\n    && TARGET_ARCH64\n    && (register_operand (operands[0], <VM64:MODE>mode)\n@@ -8648,85 +8542,88 @@\n    (set_attr \"v3pipe\" \"true,true,true,*,*,*,*,*,*,*,*\")])\n \n (define_insn \"*mov<VM64:mode>_insn_sp32\"\n-  [(set (match_operand:VM64 0 \"nonimmediate_operand\" \"=e,e,e,*r, f,e,m,m,U,r,T,T, o,*r\")\n-\t(match_operand:VM64 1 \"input_operand\"         \"Y,C,e, f,*r,m,e,Y,T,T,U,r,*r,*r\"))]\n+  [(set (match_operand:VM64 0 \"nonimmediate_operand\"\n+\t\t\t      \"=T,o,e,e,e,*r, f,e,W,U,T,e,o,*r,*r, o\")\n+\t(match_operand:VM64 1 \"input_operand\"\n+\t\t\t      \" Y,Y,Y,Z,e, f,*r,W,e,T,U,o,e,*r, o,*r\"))]\n   \"TARGET_VIS\n    && TARGET_ARCH32\n    && (register_operand (operands[0], <VM64:MODE>mode)\n        || register_or_zero_or_all_ones_operand (operands[1], <VM64:MODE>mode))\"\n   \"@\n+  stx\\t%r1, %0\n+  #\n   fzero\\t%0\n   fone\\t%0\n   fsrc2\\t%1, %0\n   #\n   #\n   ldd\\t%1, %0\n   std\\t%1, %0\n-  stx\\t%r1, %0\n-  ldd\\t%1, %0\n   ldd\\t%1, %0\n   std\\t%1, %0\n-  std\\t%1, %0\n   #\n-  #\"\n-  [(set_attr \"type\" \"visl,visl,vismv,*,*,fpload,fpstore,store,load,load,store,store,*,*\")\n-   (set_attr \"length\" \"*,*,*,2,2,*,*,*,*,*,*,*,2,2\")\n-   (set_attr \"cpu_feature\" \"vis,vis,vis,vis3,vis3,*,*,*,*,*,*,*,*,*\")\n-   (set_attr \"v3pipe\" \"true,true,true,*,*,*,*,*,*,*,*,*,*,*\")\n-   (set_attr \"lra\" \"*,*,*,*,*,*,*,*,disabled,enabled,disabled,enabled,*,*\")])\n+  #\n+  #\n+  ldd\\t%1, %0\n+  std\\t%1, %0\"\n+  [(set_attr \"type\" \"store,*,visl,visl,vismv,*,*,fpload,fpstore,load,store,*,*,*,load,store\")\n+   (set_attr \"length\" \"*,2,*,*,*,2,2,*,*,*,*,2,2,2,*,*\")\n+   (set_attr \"cpu_feature\" \"*,*,vis,vis,vis,vis3,vis3,*,*,*,*,*,*,*,*,*\")\n+   (set_attr \"v3pipe\" \"*,*,true,true,true,*,*,*,*,*,*,*,*,*,*,*\")\n+   (set_attr \"lra\" \"*,*,*,*,*,*,*,*,*,disabled,disabled,*,*,*,*,*\")])\n \n (define_split\n-  [(set (match_operand:VM64 0 \"memory_operand\" \"\")\n+  [(set (match_operand:VM64 0 \"register_operand\" \"\")\n         (match_operand:VM64 1 \"register_operand\" \"\"))]\n   \"reload_completed\n    && TARGET_VIS\n    && TARGET_ARCH32\n-   && (((REGNO (operands[1]) % 2) != 0)\n-       || !mem_min_alignment (operands[0], 8))\n-   && offsettable_memref_p (operands[0])\"\n+   && sparc_split_reg_reg_legitimate (operands[0], operands[1])\"\n   [(clobber (const_int 0))]\n {\n-  rtx word0, word1;\n-\n-  word0 = adjust_address (operands[0], SImode, 0);\n-  word1 = adjust_address (operands[0], SImode, 4);\n-\n-  emit_move_insn_1 (word0, gen_highpart (SImode, operands[1]));\n-  emit_move_insn_1 (word1, gen_lowpart (SImode, operands[1]));\n+  sparc_split_reg_reg (operands[0], operands[1], SImode);\n   DONE;\n })\n \n (define_split\n   [(set (match_operand:VM64 0 \"register_operand\" \"\")\n-        (match_operand:VM64 1 \"register_operand\" \"\"))]\n+        (match_operand:VM64 1 \"memory_operand\" \"\"))]\n   \"reload_completed\n    && TARGET_VIS\n    && TARGET_ARCH32\n-   && sparc_split_regreg_legitimate (operands[0], operands[1])\"\n+   && sparc_split_reg_mem_legitimate (operands[0], operands[1])\"\n   [(clobber (const_int 0))]\n {\n-  rtx set_dest = operands[0];\n-  rtx set_src = operands[1];\n-  rtx dest1, dest2;\n-  rtx src1, src2;\n+  sparc_split_reg_mem (operands[0], operands[1], SImode);\n+  DONE;\n+})\n \n-  dest1 = gen_highpart (SImode, set_dest);\n-  dest2 = gen_lowpart (SImode, set_dest);\n-  src1 = gen_highpart (SImode, set_src);\n-  src2 = gen_lowpart (SImode, set_src);\n+(define_split\n+  [(set (match_operand:VM64 0 \"memory_operand\" \"\")\n+        (match_operand:VM64 1 \"register_operand\" \"\"))]\n+  \"reload_completed\n+   && TARGET_VIS\n+   && TARGET_ARCH32\n+   && sparc_split_reg_mem_legitimate (operands[1], operands[0])\"\n+  [(clobber (const_int 0))]\n+{\n+  sparc_split_mem_reg (operands[0], operands[1], SImode);\n+  DONE;\n+})\n \n-  /* Now emit using the real source and destination we found, swapping\n-     the order if we detect overlap.  */\n-  if (reg_overlap_mentioned_p (dest1, src2))\n-    {\n-      emit_insn (gen_movsi (dest2, src2));\n-      emit_insn (gen_movsi (dest1, src1));\n-    }\n-  else\n-    {\n-      emit_insn (gen_movsi (dest1, src1));\n-      emit_insn (gen_movsi (dest2, src2));\n-    }\n+(define_split\n+  [(set (match_operand:VM64 0 \"memory_operand\" \"\")\n+        (match_operand:VM64 1 \"const_zero_operand\" \"\"))]\n+  \"reload_completed\n+   && TARGET_VIS\n+   && TARGET_ARCH32\n+   && !mem_min_alignment (operands[0], 8)\n+   && offsettable_memref_p (operands[0])\"\n+  [(clobber (const_int 0))]\n+{\n+  emit_move_insn_1 (adjust_address (operands[0], SImode, 0), const0_rtx);\n+  emit_move_insn_1 (adjust_address (operands[0], SImode, 4), const0_rtx);\n   DONE;\n })\n "}]}