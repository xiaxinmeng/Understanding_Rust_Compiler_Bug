{"sha": "346ab5a54a831ad9c78afcbd8dfe98e0e07e3070", "node_id": "C_kwDOANBUbNoAKDM0NmFiNWE1NGE4MzFhZDljNzhhZmNiZDhkZmU5OGUwZTA3ZTMwNzA", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2022-03-22T05:10:44Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2022-03-24T18:31:16Z"}, "message": "c++: delayed parse DMI [PR96645]\n\nWith the changes for PR81359 and PR88368 to make get_nsdmi errors be treated\nas substitution failure, we have the problem that if we check\nstd::is_default_constructible for a complete class that still has unparsed\ndefault member initializers, we get an answer (false) that will be wrong\nonce the DMIs have been parsed.  The traits avoid this problem for regular\nincomplete classes by giving an error if the operand is incomplete; we\nshould do the same if get_nsdmi is going to fail due to unparsed DMI.\n\n\tPR c++/96645\n\ngcc/cp/ChangeLog:\n\n\t* cp-tree.h (type_has_default_ctor_to_be_synthesized): Declare.\n\t* class.cc (type_has_default_ctor_to_be_synthesized): New.\n\t(type_has_non_user_provided_default_constructor_1): Support it.\n\t(type_has_non_user_provided_default_constructor): Now a wrapper.\n\t* method.cc (complain_about_unparsed_dmi): New.\n\t(constructible_expr): Call it.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/ext/is_constructible3.C: Expect error.\n\t* g++.dg/ext/is_constructible7.C: New test.", "tree": {"sha": "36735be4a7405f057480072aef7ba5231740aaef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/36735be4a7405f057480072aef7ba5231740aaef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/346ab5a54a831ad9c78afcbd8dfe98e0e07e3070", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/346ab5a54a831ad9c78afcbd8dfe98e0e07e3070", "html_url": "https://github.com/Rust-GCC/gccrs/commit/346ab5a54a831ad9c78afcbd8dfe98e0e07e3070", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/346ab5a54a831ad9c78afcbd8dfe98e0e07e3070/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f0530882d99abc410bb080051aa04e5cea848f18", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0530882d99abc410bb080051aa04e5cea848f18", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0530882d99abc410bb080051aa04e5cea848f18"}], "stats": {"total": 80, "additions": 75, "deletions": 5}, "files": [{"sha": "c75b889cb84d5e7d65486620d6a738ae3ecdd3a8", "filename": "gcc/cp/class.cc", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/346ab5a54a831ad9c78afcbd8dfe98e0e07e3070/gcc%2Fcp%2Fclass.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/346ab5a54a831ad9c78afcbd8dfe98e0e07e3070/gcc%2Fcp%2Fclass.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.cc?ref=346ab5a54a831ad9c78afcbd8dfe98e0e07e3070", "patch": "@@ -5415,10 +5415,11 @@ type_has_user_provided_or_explicit_constructor (tree t)\n \n /* Returns true iff class T has a non-user-provided (i.e. implicitly\n    declared or explicitly defaulted in the class body) default\n-   constructor.  */\n+   constructor.  If SYNTH, only return true if it hasn't been\n+   implicitly defined yet.  */\n \n-bool\n-type_has_non_user_provided_default_constructor (tree t)\n+static bool\n+type_has_non_user_provided_default_constructor_1 (tree t, bool synth)\n {\n   if (!TYPE_HAS_DEFAULT_CONSTRUCTOR (t))\n     return false;\n@@ -5431,12 +5432,28 @@ type_has_non_user_provided_default_constructor (tree t)\n       if (TREE_CODE (fn) == FUNCTION_DECL\n \t  && default_ctor_p (fn)\n \t  && !user_provided_p (fn))\n-\treturn true;\n+\t{\n+\t  if (synth)\n+\t    return !DECL_INITIAL (fn);\n+\t  return true;\n+\t}\n     }\n \n   return false;\n }\n \n+bool\n+type_has_non_user_provided_default_constructor (tree t)\n+{\n+  return type_has_non_user_provided_default_constructor_1 (t, false);\n+}\n+\n+bool\n+type_has_default_ctor_to_be_synthesized (tree t)\n+{\n+  return type_has_non_user_provided_default_constructor_1 (t, true);\n+}\n+\n /* TYPE is being used as a virtual base, and has a non-trivial move\n    assignment.  Return true if this is due to there being a user-provided\n    move assignment in TYPE or one of its subobjects; if there isn't, then"}, {"sha": "02734a42f1b81687a615fa609ce2072c1387d452", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/346ab5a54a831ad9c78afcbd8dfe98e0e07e3070/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/346ab5a54a831ad9c78afcbd8dfe98e0e07e3070/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=346ab5a54a831ad9c78afcbd8dfe98e0e07e3070", "patch": "@@ -6720,6 +6720,7 @@ extern tree in_class_defaulted_default_constructor (tree);\n extern bool user_provided_p\t\t\t(tree);\n extern bool type_has_user_provided_constructor  (tree);\n extern bool type_has_non_user_provided_default_constructor (tree);\n+extern bool type_has_default_ctor_to_be_synthesized (tree);\n extern bool vbase_has_user_provided_move_assign (tree);\n extern tree default_init_uninitialized_part (tree);\n extern bool trivial_default_constructor_is_constexpr (tree);"}, {"sha": "e0fe21777302d555a9e96e77a40c9a937b511050", "filename": "gcc/cp/method.cc", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/346ab5a54a831ad9c78afcbd8dfe98e0e07e3070/gcc%2Fcp%2Fmethod.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/346ab5a54a831ad9c78afcbd8dfe98e0e07e3070/gcc%2Fcp%2Fmethod.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.cc?ref=346ab5a54a831ad9c78afcbd8dfe98e0e07e3070", "patch": "@@ -2056,6 +2056,28 @@ assignable_expr (tree to, tree from)\n   return r;\n }\n \n+/* An unparsed default member initializer prevents calling a defaulted default\n+   constructor; make checking std::is_constructible ill-formed until the DMI\n+   has been parsed, to avoid caching the wrong value.  */\n+\n+static bool\n+complain_about_unparsed_dmi (tree t)\n+{\n+  if (type_has_default_ctor_to_be_synthesized (t)\n+      && TYPE_HAS_COMPLEX_DFLT (t))\n+    for (tree f = TYPE_FIELDS (t); f; f = DECL_CHAIN (f))\n+      if (TREE_CODE (f) == FIELD_DECL\n+\t  && DECL_INITIAL (f)\n+\t  && TREE_CODE (DECL_INITIAL (f)) == DEFERRED_PARSE)\n+\t{\n+\t  error (\"default member initializer for %qD required by %qs before \"\n+\t\t \"the end of its enclosing class\", f, \"std::is_constructible\");\n+\t  inform (location_of (f), \"defined here\");\n+\t  return true;\n+\t}\n+  return false;\n+}\n+\n /* The predicate condition for a template specialization\n    is_constructible<T, Args...> shall be satisfied if and only if the\n    following variable definition would be well-formed for some invented\n@@ -2070,6 +2092,8 @@ constructible_expr (tree to, tree from)\n   cp_unevaluated cp_uneval_guard;\n   if (CLASS_TYPE_P (to))\n     {\n+      if (!from && complain_about_unparsed_dmi (to))\n+\treturn error_mark_node;\n       tree ctype = to;\n       vec<tree, va_gc> *args = NULL;\n       if (!TYPE_REF_P (to))"}, {"sha": "305751d28e2a79906ef6937476e8909b7273dc08", "filename": "gcc/testsuite/g++.dg/ext/is_constructible3.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/346ab5a54a831ad9c78afcbd8dfe98e0e07e3070/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_constructible3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/346ab5a54a831ad9c78afcbd8dfe98e0e07e3070/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_constructible3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_constructible3.C?ref=346ab5a54a831ad9c78afcbd8dfe98e0e07e3070", "patch": "@@ -8,7 +8,7 @@ struct A {\n     B() = default;\n   };\n \n-  static constexpr bool v = __is_constructible (B);\n+  static constexpr bool v = __is_constructible (B); // { dg-error \"member initializer\" }\n \n };\n "}, {"sha": "76a63bba5d05a86a4750f8f261887feb86d2f80d", "filename": "gcc/testsuite/g++.dg/ext/is_constructible7.C", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/346ab5a54a831ad9c78afcbd8dfe98e0e07e3070/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_constructible7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/346ab5a54a831ad9c78afcbd8dfe98e0e07e3070/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_constructible7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_constructible7.C?ref=346ab5a54a831ad9c78afcbd8dfe98e0e07e3070", "patch": "@@ -0,0 +1,28 @@\n+// PR c++/96645\n+// { dg-do compile { target c++11 } }\n+\n+template<bool B>\n+struct bool_constant\n+{\n+  static constexpr bool value = B;\n+  using type = bool_constant;\n+};\n+\n+using true_type = bool_constant<true>;\n+\n+template<typename T>\n+struct is_default_constructible\n+  : bool_constant<__is_constructible(T)> // { dg-error \"default member init\" }\n+{ };\n+\n+void testVarStruct()\n+{\n+  struct DataWithStruct {\n+    struct A {\n+      int number = 5; // compiles, if remove initialization\n+    };\n+\n+    // { dg-prune-output \"could not convert\" }\n+    is_default_constructible<A>::type t = true_type{};\n+  };\n+}"}]}