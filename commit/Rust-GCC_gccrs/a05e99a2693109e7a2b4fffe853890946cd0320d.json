{"sha": "a05e99a2693109e7a2b4fffe853890946cd0320d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTA1ZTk5YTI2OTMxMDllN2EyYjRmZmZlODUzODkwOTQ2Y2QwMzIwZA==", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2006-02-15T09:38:00Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-02-15T09:38:00Z"}, "message": "exp_ch3.adb (Component_Needs_Simple_Initialization): Add check for availability of RE_Interface_Tag.\n\n2006-02-13  Javier Miranda  <miranda@adacore.com>\n\t    Gary Dismukes  <dismukes@adacore.com>\n\n\t* exp_ch3.adb (Component_Needs_Simple_Initialization): Add check for\n\tavailability of RE_Interface_Tag.\n\t(Build_Initialization_Call): Fix wrong access to the discriminant value.\n\t(Freeze_Record_Type): Do not generate the tables associated with\n\ttimed and conditional dispatching calls through synchronized\n\tinterfaces if compiling under No_Dispatching_Calls restriction.\n\tWhen compiling for Ada 2005, for a nonabstract\n\ttype with a null extension, call Make_Controlling_Function_Wrappers\n\tand insert the wrapper function declarations and bodies (the latter\n\tbeing appended as freeze actions).\n\t(Predefined_Primitive_Bodies): Do not generate the bodies of the\n\tpredefined primitives associated with timed and conditional\n\tdispatching calls through synchronized interfaces if we are\n\tcompiling under No_Dispatching_Calls.\n\t(Build_Init_Procedure):  Use RTE_Available to check if a run-time\n\tservice is available before generating a call.\n\t(Make_Controlling_Function_Wrappers): New procedure.\n\t(Expand_N_Full_Type_Declaration): Create a class-wide master for\n\taccess-to-limited-interfaces because they can be used to reference\n\ttasks that implement such limited interface.\n\t(Build_Offset_To_Top_Functions): Build the tree corresponding to the\n\tprocedure spec and body of the Offset_To_Top function that is generated\n\twhen the parent of a type with discriminants has secondary dispatch\n\ttables.\n\t(Init_Secondary_Tags): Handle the case in which the parent of the type\n\tcontaining secondary dispatch tables has discriminants to generate the\n\tcorrect arguments to call Set_Offset_To_Top.\n\t(Build_Record_Init_Proc): Add call to Build_Offset_To_Top_Functions.\n\n\t* a-tags.ads, a-tags.adb: (Check_Index): Removed.\n\tAdd Wide_[Wide_]Expanded_Name.\n\t(Get_Predefined_Prim_Op_Address): New subprogram that provides exactly\n\tthe same functionality of Get_Prim_Op_Address but applied to predefined\n\tprimitive operations because the pointers to the predefined primitives\n\tare now saved in a separate table.\n\t(Parent_Size): Modified to get access to the separate table of primitive\n\toperations or the parent type.\n\t(Set_Predefined_Prim_Op_Address): New subprogram that provides the same\n\tfunctionality of Set_Prim_Op_Address but applied to predefined primitive\n\toperations.\n\t(Set_Signature): New subprogram used to store the signature of a DT.\n\t(Displace): If the Offset_To_Top value is not static then call the\n\tfunction generated by the expander to get such value; otherwise use\n\tthe value stored in the table of interfaces.\n\t(Offset_To_Top): The type of the actual has been changed to Address to\n\tgive the correct support to tagged types with discriminants. In this\n\tcase this value is stored just immediately after the tag field.\n\t(Set_Offset_To_Top): Two new formals have been added to indicate if the\n\toffset_to_top value is static and hence pass this value to the run-time\n\tto store it in the table of interfaces, or else if this value is dynamic\n\tand then pass to the run-time the address of a function that is\n\tgenerated by the expander to provide this value for each object of the\n\ttype.\n\n\t* rtsfind.ads (Default_Prin_Op_Count): Removed.\n\t(Default_Prim_Op_Count): New entity\n\t(Get_Predefined_Prim_Op_Address): New entity\n\t(Set_Predefined_Prim_Op_Address): New entity\n\t(RE_Set_Signature): New entity\n\nFrom-SVN: r111059", "tree": {"sha": "20310562d97b1530165e6f9980e07e7470bf0d34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/20310562d97b1530165e6f9980e07e7470bf0d34"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a05e99a2693109e7a2b4fffe853890946cd0320d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a05e99a2693109e7a2b4fffe853890946cd0320d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a05e99a2693109e7a2b4fffe853890946cd0320d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a05e99a2693109e7a2b4fffe853890946cd0320d/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "80d4224f5b0b90b4f3da875043512003342d6f01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80d4224f5b0b90b4f3da875043512003342d6f01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80d4224f5b0b90b4f3da875043512003342d6f01"}], "stats": {"total": 1010, "additions": 817, "deletions": 193}, "files": [{"sha": "cfce83451b5270d7c625999ba9bd46f9ef67974c", "filename": "gcc/ada/a-tags.adb", "status": "modified", "additions": 178, "deletions": 70, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a05e99a2693109e7a2b4fffe853890946cd0320d/gcc%2Fada%2Fa-tags.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a05e99a2693109e7a2b4fffe853890946cd0320d/gcc%2Fada%2Fa-tags.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tags.adb?ref=a05e99a2693109e7a2b4fffe853890946cd0320d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -34,13 +34,19 @@\n with Ada.Exceptions;\n with System.HTable;\n with System.Storage_Elements; use System.Storage_Elements;\n+with System.WCh_Con;          use System.WCh_Con;\n+with System.WCh_StW;          use System.WCh_StW;\n \n pragma Elaborate_All (System.HTable);\n \n package body Ada.Tags is\n \n --  Structure of the GNAT Primary Dispatch Table\n \n+--           +----------------------+\n+--           |       table of       |\n+--           : predefined primitive :\n+--           |     ops pointers     |\n --           +----------------------+\n --           |       Signature      |\n --           +----------------------+\n@@ -66,8 +72,6 @@ package body Ada.Tags is\n --                                      +-------------------+\n --                                      |   num prim ops    |\n --                                      +-------------------+\n---                                      |  num interfaces   |\n---                                      +-------------------+\n --                                      |  Ifaces_Table_Ptr --> Interface Data\n --                                      +-------------------+   +------------+\n --            Select Specific Data  <----     SSD_Ptr       |   |  table     |\n@@ -83,6 +87,10 @@ package body Ada.Tags is\n \n --  Structure of the GNAT Secondary Dispatch Table\n \n+--           +-----------------------+\n+--           |       table of        |\n+--           :  predefined primitive :\n+--           |     ops pointers      |\n --           +-----------------------+\n --           |       Signature       |\n --           +-----------------------+\n@@ -126,9 +134,9 @@ package body Ada.Tags is\n    --     Field_Type_Ptr in A-Tags.ads.\n \n    --     Define the specifications of Get_<Field_Name> and Set_<Field_Name>\n-   --     in A-Tags.ads.\n+   --     in a-tags.ads.\n \n-   --     Update the GNAT Dispatch Table structure in A-Tags.adb\n+   --     Update the GNAT Dispatch Table structure in a-tags.adb\n \n    --     Provide bodies to the Get_<Field_Name> and Set_<Field_Name> routines.\n    --     The profile of a Get_<Field_Name> routine should resemble:\n@@ -184,9 +192,16 @@ package body Ada.Tags is\n    --  Declarations for the table of interfaces\n \n    type Interface_Data_Element is record\n-      Iface_Tag : Tag;\n-      Offset    : System.Storage_Elements.Storage_Offset;\n+      Iface_Tag            : Tag;\n+      Static_Offset_To_Top : Boolean;\n+      Offset_To_Top_Value  : System.Storage_Elements.Storage_Offset;\n+      Offset_To_Top_Func   : System.Address;\n    end record;\n+   --  If some ancestor of the tagged type has discriminants the field\n+   --  Static_Offset_To_Top is False and the field Offset_To_Top_Func\n+   --  is used to store the address of the function generated by the\n+   --  expander which provides this value; otherwise Static_Offset_To_Top\n+   --  is True and such value is stored in the Offset_To_Top_Value field.\n \n    type Interfaces_Array is\n      array (Natural range <>) of Interface_Data_Element;\n@@ -322,9 +337,6 @@ package body Ada.Tags is\n       --  only to declare the corresponding access type.\n    end record;\n \n-   --  Run-time check types and subprograms: These subprograms are used only\n-   --  when the run-time is compiled with assertions enabled.\n-\n    type Signature_Type is\n       (Must_Be_Primary_DT,\n        Must_Be_Secondary_DT,\n@@ -356,6 +368,17 @@ package body Ada.Tags is\n    function To_Acc_Size is new Unchecked_Conversion (System.Address, Acc_Size);\n    --  The profile of the implicitly defined _size primitive\n \n+   type Offset_To_Top_Function_Ptr is\n+      access function (This : System.Address)\n+               return System.Storage_Elements.Storage_Offset;\n+   --  Type definition used to call the function that is generated by the\n+   --  expander in case of tagged types with discriminants that have secondary\n+   --  dispatch tables. This function provides the Offset_To_Top value in this\n+   --  specific case.\n+\n+   function To_Offset_To_Top_Function_Ptr is\n+      new Unchecked_Conversion (System.Address, Offset_To_Top_Function_Ptr);\n+\n    type Storage_Offset_Ptr is access System.Storage_Elements.Storage_Offset;\n \n    function To_Storage_Offset_Ptr is\n@@ -365,11 +388,6 @@ package body Ada.Tags is\n    -- Local Subprograms --\n    -----------------------\n \n-   function Check_Index\n-     (T     : Tag;\n-      Index : Natural) return Boolean;\n-   --  Check that Index references a valid entry of the dispatch table of T\n-\n    function Check_Signature (T : Tag; Kind : Signature_Type) return Boolean;\n    --  Check that the signature of T is valid and corresponds with the subset\n    --  specified by the signature Kind.\n@@ -489,20 +507,6 @@ package body Ada.Tags is\n \n    end HTable_Subprograms;\n \n-   -----------------\n-   -- Check_Index --\n-   -----------------\n-\n-   function Check_Index\n-     (T     : Tag;\n-      Index : Natural) return Boolean\n-   is\n-      Max_Entries : constant Natural := Get_Num_Prim_Ops (T);\n-\n-   begin\n-      return Index /= 0 and then Index <= Max_Entries;\n-   end Check_Index;\n-\n    ---------------------\n    -- Check_Signature --\n    ---------------------\n@@ -624,7 +628,7 @@ package body Ada.Tags is\n       pragma Assert\n         (Check_Signature (T, Must_Be_Interface));\n \n-      Obj_Base    := This - Offset_To_Top (Curr_DT);\n+      Obj_Base    := This - Offset_To_Top (This);\n       Obj_DT      := To_Tag_Ptr (Obj_Base).all;\n \n       pragma Assert\n@@ -636,8 +640,25 @@ package body Ada.Tags is\n       if Iface_Table /= null then\n          for Id in 1 .. Iface_Table.Nb_Ifaces loop\n             if Iface_Table.Table (Id).Iface_Tag = T then\n-               Obj_Base := Obj_Base + Iface_Table.Table (Id).Offset;\n-               Obj_DT   := To_Tag_Ptr (Obj_Base).all;\n+\n+               --  Case of Static value of Offset_To_Top\n+\n+               if Iface_Table.Table (Id).Static_Offset_To_Top then\n+                  Obj_Base :=\n+                    Obj_Base + Iface_Table.Table (Id).Offset_To_Top_Value;\n+\n+               --  Otherwise we call the function generated by the expander\n+               --  to provide us with this value\n+\n+               else\n+                  Obj_Base :=\n+                    Obj_Base +\n+                      To_Offset_To_Top_Function_Ptr\n+                        (Iface_Table.Table (Id).Offset_To_Top_Func).all\n+                          (Obj_Base);\n+               end if;\n+\n+               Obj_DT := To_Tag_Ptr (Obj_Base).all;\n \n                pragma Assert\n                  (Check_Signature (Obj_DT, Must_Be_Secondary_DT));\n@@ -680,7 +701,7 @@ package body Ada.Tags is\n       pragma Assert\n         (Check_Signature (T, Must_Be_Primary_Or_Interface));\n \n-      Obj_Base := This - Offset_To_Top (Curr_DT);\n+      Obj_Base := This - Offset_To_Top (This);\n       Obj_DT   := To_Tag_Ptr (Obj_Base).all;\n \n       pragma Assert\n@@ -782,12 +803,10 @@ package body Ada.Tags is\n    ---------------------\n \n    function Get_Entry_Index (T : Tag; Position : Positive) return Positive is\n-      Index : constant Integer := Position - Default_Prim_Op_Count;\n    begin\n       pragma Assert (Check_Signature (T, Must_Be_Primary_DT));\n-      pragma Assert (Check_Index (T, Position));\n-      pragma Assert (Index > 0);\n-      return SSD (T).SSD_Table (Index).Index;\n+      pragma Assert (Position <= Get_Num_Prim_Ops (T));\n+      return SSD (T).SSD_Table (Position).Index;\n    end Get_Entry_Index;\n \n    ----------------------\n@@ -815,6 +834,21 @@ package body Ada.Tags is\n       end if;\n    end Get_Num_Prim_Ops;\n \n+   --------------------------------\n+   -- Get_Predef_Prim_Op_Address --\n+   --------------------------------\n+\n+   function Get_Predefined_Prim_Op_Address\n+     (T        : Tag;\n+      Position : Positive) return System.Address\n+   is\n+      Prim_Ops_DT : constant Tag := To_Tag (To_Address (T) - DT_Prologue_Size);\n+   begin\n+      pragma Assert (Check_Signature (T, Must_Be_Primary_Or_Secondary_DT));\n+      pragma Assert (Position <= Default_Prim_Op_Count);\n+      return Prim_Ops_DT.Prims_Ptr (Position);\n+   end Get_Predefined_Prim_Op_Address;\n+\n    -------------------------\n    -- Get_Prim_Op_Address --\n    -------------------------\n@@ -825,7 +859,7 @@ package body Ada.Tags is\n    is\n    begin\n       pragma Assert (Check_Signature (T, Must_Be_Primary_Or_Secondary_DT));\n-      pragma Assert (Check_Index (T, Position));\n+      pragma Assert (Position <= Get_Num_Prim_Ops (T));\n       return T.Prims_Ptr (Position);\n    end Get_Prim_Op_Address;\n \n@@ -837,12 +871,10 @@ package body Ada.Tags is\n      (T        : Tag;\n       Position : Positive) return Prim_Op_Kind\n    is\n-      Index : constant Integer := Position - Default_Prim_Op_Count;\n    begin\n       pragma Assert (Check_Signature (T, Must_Be_Primary_DT));\n-      pragma Assert (Check_Index (T, Position));\n-      pragma Assert (Index > 0);\n-      return SSD (T).SSD_Table (Index).Kind;\n+      pragma Assert (Position <= Get_Num_Prim_Ops (T));\n+      return SSD (T).SSD_Table (Position).Kind;\n    end Get_Prim_Op_Kind;\n \n    ----------------------\n@@ -853,12 +885,10 @@ package body Ada.Tags is\n      (T        : Tag;\n       Position : Positive) return Positive\n    is\n-      Index : constant Integer := Position - Default_Prim_Op_Count;\n    begin\n       pragma Assert (Check_Signature (T, Must_Be_Secondary_DT));\n-      pragma Assert (Check_Index (T, Position));\n-      pragma Assert (Index > 0);\n-      return OSD (T).OSD_Table (Index);\n+      pragma Assert (Position <= Get_Num_Prim_Ops (T));\n+      return OSD (T).OSD_Table (Position);\n    end Get_Offset_Index;\n \n    -------------------\n@@ -898,6 +928,9 @@ package body Ada.Tags is\n    ----------------\n \n    procedure Inherit_DT (Old_T : Tag; New_T : Tag; Entry_Count : Natural) is\n+      Old_T_Prim_Ops : Tag;\n+      New_T_Prim_Ops : Tag;\n+      Size           : Positive;\n    begin\n       pragma Assert (Check_Signature (Old_T, Must_Be_Primary_Or_Secondary_DT));\n       pragma Assert (Check_Signature (New_T, Must_Be_Primary_Or_Secondary_DT));\n@@ -906,6 +939,11 @@ package body Ada.Tags is\n       if Old_T /= null then\n          New_T.Prims_Ptr (1 .. Entry_Count) :=\n            Old_T.Prims_Ptr (1 .. Entry_Count);\n+         Old_T_Prim_Ops := To_Tag (To_Address (Old_T) - DT_Prologue_Size);\n+         New_T_Prim_Ops := To_Tag (To_Address (New_T) - DT_Prologue_Size);\n+         Size := Default_Prim_Op_Count;\n+         New_T_Prim_Ops.Prims_Ptr (1 .. Size) :=\n+           Old_T_Prim_Ops.Prims_Ptr (1 .. Size);\n       end if;\n    end Inherit_DT;\n \n@@ -1034,12 +1072,18 @@ package body Ada.Tags is\n    -------------------\n \n    function Offset_To_Top\n-     (T : Tag) return System.Storage_Elements.Storage_Offset\n+     (This : System.Address) return System.Storage_Elements.Storage_Offset\n    is\n-      Offset_To_Top : constant Storage_Offset_Ptr :=\n-                        To_Storage_Offset_Ptr\n-                          (To_Address (T) - K_Offset_To_Top);\n+      Curr_DT       : constant Tag := To_Tag_Ptr (This).all;\n+      Offset_To_Top : Storage_Offset_Ptr;\n    begin\n+      Offset_To_Top := To_Storage_Offset_Ptr\n+                         (To_Address (Curr_DT) - K_Offset_To_Top);\n+\n+      if Offset_To_Top.all = SSE.Storage_Offset'Last then\n+         Offset_To_Top := To_Storage_Offset_Ptr (This + Tag_Size);\n+      end if;\n+\n       return Offset_To_Top.all;\n    end Offset_To_Top;\n \n@@ -1066,14 +1110,18 @@ package body Ada.Tags is\n       Parent_Tag : Tag;\n       --  The tag of the parent type through the dispatch table\n \n+      Prim_Ops_DT : Tag;\n+      --  The table of primitive operations of the parent\n+\n       F : Acc_Size;\n       --  Access to the _size primitive of the parent. We assume that it is\n       --  always in the first slot of the dispatch table.\n \n    begin\n       pragma Assert (Check_Signature (T, Must_Be_Primary_DT));\n-      Parent_Tag := TSD (T).Tags_Table (1);\n-      F := To_Acc_Size (Parent_Tag.Prims_Ptr (1));\n+      Parent_Tag  := TSD (T).Tags_Table (1);\n+      Prim_Ops_DT := To_Tag (To_Address (Parent_Tag) - DT_Prologue_Size);\n+      F           := To_Acc_Size (Prim_Ops_DT.Prims_Ptr (1));\n \n       --  Here we compute the size of the _parent field of the object\n \n@@ -1156,12 +1204,10 @@ package body Ada.Tags is\n       Position : Positive;\n       Value    : Positive)\n    is\n-      Index : constant Integer := Position - Default_Prim_Op_Count;\n    begin\n       pragma Assert (Check_Signature (T, Must_Be_Primary_DT));\n-      pragma Assert (Check_Index (T, Position));\n-      pragma Assert (Index > 0);\n-      SSD (T).SSD_Table (Index).Index := Value;\n+      pragma Assert (Position <= Get_Num_Prim_Ops (T));\n+      SSD (T).SSD_Table (Position).Index := Value;\n    end Set_Entry_Index;\n \n    -----------------------\n@@ -1219,12 +1265,10 @@ package body Ada.Tags is\n       Position : Positive;\n       Value    : Positive)\n    is\n-      Index : constant Integer := Position - Default_Prim_Op_Count;\n    begin\n       pragma Assert (Check_Signature (T, Must_Be_Secondary_DT));\n-      pragma Assert (Check_Index (T, Position));\n-      pragma Assert (Index > 0);\n-      OSD (T).OSD_Table (Index) := Value;\n+      pragma Assert (Position <= Get_Num_Prim_Ops (T));\n+      OSD (T).OSD_Table (Position) := Value;\n    end Set_Offset_Index;\n \n    -----------------------\n@@ -1234,7 +1278,9 @@ package body Ada.Tags is\n    procedure Set_Offset_To_Top\n      (This          : System.Address;\n       Interface_T   : Tag;\n-      Offset_Value  : System.Storage_Elements.Storage_Offset)\n+      Is_Static     : Boolean;\n+      Offset_Value  : System.Storage_Elements.Storage_Offset;\n+      Offset_Func   : System.Address)\n    is\n       Prim_DT       : Tag;\n       Sec_Base      : System.Address;\n@@ -1257,7 +1303,7 @@ package body Ada.Tags is\n       --  \"This\" points to the primary DT and we must save Offset_Value in the\n       --  Offset_To_Top field of the corresponding secondary dispatch table.\n \n-      Prim_DT := To_Tag_Ptr (This).all;\n+      Prim_DT  := To_Tag_Ptr (This).all;\n \n       pragma Assert\n         (Check_Signature (Prim_DT, Must_Be_Primary_DT));\n@@ -1268,9 +1314,13 @@ package body Ada.Tags is\n         To_Storage_Offset_Ptr (To_Address (Sec_DT) - K_Offset_To_Top);\n \n       pragma Assert\n-        (Check_Signature (Sec_DT, Must_Be_Primary_Or_Secondary_DT));\n+        (Check_Signature (Sec_DT, Must_Be_Secondary_DT));\n \n-      Offset_To_Top.all := Offset_Value;\n+      if Is_Static then\n+         Offset_To_Top.all := Offset_Value;\n+      else\n+         Offset_To_Top.all := SSE.Storage_Offset'Last;\n+      end if;\n \n       --  Save Offset_Value in the table of interfaces of the primary DT. This\n       --  data will be used by the subprogram \"Displace\" to give support to\n@@ -1284,7 +1334,14 @@ package body Ada.Tags is\n       if Iface_Table /= null then\n          for Id in 1 .. Iface_Table.Nb_Ifaces loop\n             if Iface_Table.Table (Id).Iface_Tag = Interface_T then\n-               Iface_Table.Table (Id).Offset := Offset_Value;\n+               Iface_Table.Table (Id).Static_Offset_To_Top := Is_Static;\n+\n+               if Is_Static then\n+                  Iface_Table.Table (Id).Offset_To_Top_Value := Offset_Value;\n+               else\n+                  Iface_Table.Table (Id).Offset_To_Top_Func := Offset_Func;\n+               end if;\n+\n                return;\n             end if;\n          end loop;\n@@ -1307,6 +1364,22 @@ package body Ada.Tags is\n       OSD_Ptr.all := Value;\n    end Set_OSD;\n \n+   ------------------------------------\n+   -- Set_Predefined_Prim_Op_Address --\n+   ------------------------------------\n+\n+   procedure Set_Predefined_Prim_Op_Address\n+     (T        : Tag;\n+      Position : Positive;\n+      Value    : System.Address)\n+   is\n+      Prim_Ops_DT : constant Tag := To_Tag (To_Address (T) - DT_Prologue_Size);\n+   begin\n+      pragma Assert (Check_Signature (T, Must_Be_Primary_Or_Secondary_DT));\n+      pragma Assert (Position >= 1 and then Position <= Default_Prim_Op_Count);\n+      Prim_Ops_DT.Prims_Ptr (Position) := Value;\n+   end Set_Predefined_Prim_Op_Address;\n+\n    -------------------------\n    -- Set_Prim_Op_Address --\n    -------------------------\n@@ -1318,7 +1391,7 @@ package body Ada.Tags is\n    is\n    begin\n       pragma Assert (Check_Signature (T, Must_Be_Primary_Or_Secondary_DT));\n-      pragma Assert (Check_Index (T, Position));\n+      pragma Assert (Position <= Get_Num_Prim_Ops (T));\n       T.Prims_Ptr (Position) := Value;\n    end Set_Prim_Op_Address;\n \n@@ -1331,12 +1404,10 @@ package body Ada.Tags is\n       Position : Positive;\n       Value    : Prim_Op_Kind)\n    is\n-      Index : constant Integer := Position - Default_Prim_Op_Count;\n    begin\n       pragma Assert (Check_Signature (T, Must_Be_Primary_DT));\n-      pragma Assert (Check_Index (T, Position));\n-      pragma Assert (Index > 0);\n-      SSD (T).SSD_Table (Index).Kind := Value;\n+      pragma Assert (Position <= Get_Num_Prim_Ops (T));\n+      SSD (T).SSD_Table (Position).Kind := Value;\n    end Set_Prim_Op_Kind;\n \n    -------------------\n@@ -1359,6 +1430,19 @@ package body Ada.Tags is\n       TSD (T).Remotely_Callable := Value;\n    end Set_Remotely_Callable;\n \n+   -------------------\n+   -- Set_Signature --\n+   -------------------\n+\n+   procedure Set_Signature (T : Tag; Value : Signature_Kind) is\n+      Signature : constant System.Address := To_Address (T) - K_Signature;\n+      Sig_Ptr   : constant Signature_Values_Ptr :=\n+                    To_Signature_Values_Ptr (Signature);\n+   begin\n+      Sig_Ptr.all (1) := Valid_Signature;\n+      Sig_Ptr.all (2) := Value;\n+   end Set_Signature;\n+\n    -------------\n    -- Set_SSD --\n    -------------\n@@ -1426,4 +1510,28 @@ package body Ada.Tags is\n       return To_Type_Specific_Data_Ptr (TSD_Ptr.all);\n    end TSD;\n \n+   ------------------------\n+   -- Wide_Expanded_Name --\n+   ------------------------\n+\n+   WC_Encoding : Character;\n+   pragma Import (C, WC_Encoding, \"__gl_wc_encoding\");\n+   --  Encoding method for source, as exported by binder\n+\n+   function Wide_Expanded_Name (T : Tag) return Wide_String is\n+   begin\n+      return String_To_Wide_String\n+        (Expanded_Name (T), Get_WC_Encoding_Method (WC_Encoding));\n+   end Wide_Expanded_Name;\n+\n+   -----------------------------\n+   -- Wide_Wide_Expanded_Name --\n+   -----------------------------\n+\n+   function Wide_Wide_Expanded_Name (T : Tag) return Wide_Wide_String is\n+   begin\n+      return String_To_Wide_Wide_String\n+        (Expanded_Name (T), Get_WC_Encoding_Method (WC_Encoding));\n+   end Wide_Wide_Expanded_Name;\n+\n end Ada.Tags;"}, {"sha": "bb69544a9d3b6c384fb2ff4c470722147b00300c", "filename": "gcc/ada/a-tags.ads", "status": "modified", "additions": 86, "deletions": 34, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a05e99a2693109e7a2b4fffe853890946cd0320d/gcc%2Fada%2Fa-tags.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a05e99a2693109e7a2b4fffe853890946cd0320d/gcc%2Fada%2Fa-tags.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tags.ads?ref=a05e99a2693109e7a2b4fffe853890946cd0320d", "patch": "@@ -68,6 +68,12 @@ package Ada.Tags is\n \n    Tag_Error : exception;\n \n+   function Wide_Expanded_Name (T : Tag) return Wide_String;\n+   pragma Ada_05 (Wide_Expanded_Name);\n+\n+   function Wide_Wide_Expanded_Name (T : Tag) return Wide_Wide_String;\n+   pragma Ada_05 (Wide_Wide_Expanded_Name);\n+\n private\n    --  The following subprogram specifications are placed here instead of\n    --  the package body to see them from the frontend through rtsfind.\n@@ -151,11 +157,25 @@ private\n \n    Default_Prim_Op_Count : constant Positive := 15;\n    --  Number of predefined primitive operations added by the Expander for a\n-   --  tagged type. It is utilized for indexing in the two auxiliary tables\n-   --  used for dispatching asynchronous, conditional and timed selects. In\n-   --  order to be space efficient, indexing is performed by subtracting this\n-   --  constant value from the provided position in the auxiliary tables (must\n-   --  match Exp_Disp.Default_Prim_Op_Count).\n+   --  tagged type (must match Exp_Disp.Default_Prim_Op_Count).\n+\n+   type Signature_Kind is\n+      (Unknown,\n+       Valid_Signature,\n+       Primary_DT,\n+       Secondary_DT,\n+       Abstract_Interface);\n+   for Signature_Kind'Size use 8;\n+   --  Kind of signature found in the header of the dispatch table. These\n+   --  signatures are generated by the frontend and are used by the Check_XXX\n+   --  routines to ensure that the kind of dispatch table managed by each of\n+   --  the routines in this package is correct. This additional check is only\n+   --  performed with this run-time package is compiled with assertions enabled\n+\n+   --  The signature is a sequence of two bytes. The first byte must have the\n+   --  value Valid_Signature, and the second byte must have a value in the\n+   --  range Primary_DT .. Abstract_Interface. The Unknown value is used by\n+   --  the Check_XXX routines to indicate that the signature is wrong.\n \n    package SSE renames System.Storage_Elements;\n \n@@ -200,6 +220,13 @@ private\n    --  operation in the DT, retrieve the corresponding operation's position in\n    --  the primary dispatch table from the Offset Specific Data table of T.\n \n+   function Get_Predefined_Prim_Op_Address\n+     (T        : Tag;\n+      Position : Positive) return System.Address;\n+   --  Given a pointer to a dispatch table (T) and a position in the DT\n+   --  this function returns the address of the virtual function stored\n+   --  in it (used for dispatching calls).\n+\n    function Get_Prim_Op_Address\n      (T        : Tag;\n       Position : Positive) return System.Address;\n@@ -239,9 +266,11 @@ private\n    --  Initialize the TSD of a type knowing the tag of the direct ancestor\n \n    function Offset_To_Top\n-     (T : Tag) return System.Storage_Elements.Storage_Offset;\n+     (This : System.Address) return System.Storage_Elements.Storage_Offset;\n    --  Returns the current value of the offset_to_top component available in\n-   --  the prologue of the dispatch table.\n+   --  the prologue of the dispatch table. If the parent of the tagged type\n+   --  has discriminants this value is stored in a record component just\n+   --  immediately after the tag component.\n \n    function OSD (T : Tag) return Object_Specific_Data_Ptr;\n    --  Ada 2005 (AI-251): Given a pointer T to a secondary dispatch table,\n@@ -305,7 +334,9 @@ private\n    procedure Set_Offset_To_Top\n      (This         : System.Address;\n       Interface_T  : Tag;\n-      Offset_Value : System.Storage_Elements.Storage_Offset);\n+      Is_Static    : Boolean;\n+      Offset_Value : System.Storage_Elements.Storage_Offset;\n+      Offset_Func  : System.Address);\n    --  Ada 2005 (AI-251): Initialize the Offset_To_Top field in the prologue of\n    --  the dispatch table. In primary dispatch tables the value of \"This\" is\n    --  not required (and the compiler passes always the Null_Address value) and\n@@ -319,6 +350,14 @@ private\n    --  Given a pointer T to a secondary dispatch table, store the pointer to\n    --  the record containing the Object Specific Data generated by GNAT.\n \n+   procedure Set_Predefined_Prim_Op_Address\n+     (T        : Tag;\n+      Position : Positive;\n+      Value    : System.Address);\n+   --  Given a pointer to a dispatch Table (T) and a position in the dispatch\n+   --  table associated with a predefined primitive operation, put the address\n+   --  of the virtual function in it (used for overriding).\n+\n    procedure Set_Prim_Op_Address\n      (T        : Tag;\n       Position : Positive;\n@@ -342,6 +381,9 @@ private\n    --  Set to true if the type has been declared in a context described\n    --  in E.4 (18).\n \n+   procedure Set_Signature (T : Tag; Value : Signature_Kind);\n+   --  Given a pointer T to a dispatch table, store the signature id\n+\n    procedure Set_SSD (T : Tag; Value : System.Address);\n    --  Given a pointer T to a dispatch Table, stores the pointer to the record\n    --  containing the Select Specific Data generated by GNAT.\n@@ -363,35 +405,51 @@ private\n    --  record containing the Type Specific Data generated by GNAT.\n \n    DT_Prologue_Size : constant SSE.Storage_Count :=\n-     SSE.Storage_Count (4 * (Standard'Address_Size / System.Storage_Unit));\n-   --  Size of the first part of the dispatch table\n+                        SSE.Storage_Count\n+                          ((Default_Prim_Op_Count + 4) *\n+                            (Standard'Address_Size / System.Storage_Unit));\n+   --  Size of the hidden part of the dispatch table. It contains the table of\n+   --  predefined primitive operations plus the C++ ABI header.\n \n    DT_Signature_Size : constant SSE.Storage_Count :=\n-     SSE.Storage_Count (1 * (Standard'Address_Size / System.Storage_Unit));\n+                         SSE.Storage_Count\n+                           (1 * (Standard'Address_Size / System.Storage_Unit));\n    --  Size of the Signature field of the dispatch table\n \n    DT_Tagged_Kind_Size : constant SSE.Storage_Count :=\n      SSE.Storage_Count (1 * (Standard'Address_Size / System.Storage_Unit));\n    --  Size of the Tagged_Type_Kind field of the dispatch table\n \n    DT_Offset_To_Top_Size : constant SSE.Storage_Count :=\n-     SSE.Storage_Count (1 * (Standard'Address_Size / System.Storage_Unit));\n+                             SSE.Storage_Count\n+                               (1 * (Standard'Address_Size /\n+                                       System.Storage_Unit));\n    --  Size of the Offset_To_Top field of the Dispatch Table\n \n    DT_Typeinfo_Ptr_Size : constant SSE.Storage_Count :=\n-     SSE.Storage_Count (1 * (Standard'Address_Size / System.Storage_Unit));\n+                            SSE.Storage_Count\n+                              (1 * (Standard'Address_Size /\n+                                      System.Storage_Unit));\n    --  Size of the Typeinfo_Ptr field of the Dispatch Table\n \n    DT_Entry_Size : constant SSE.Storage_Count :=\n-     SSE.Storage_Count (1 * (Standard'Address_Size / System.Storage_Unit));\n+                     SSE.Storage_Count\n+                       (1 * (Standard'Address_Size / System.Storage_Unit));\n    --  Size of each primitive operation entry in the Dispatch Table\n \n+   Tag_Size : constant SSE.Storage_Count :=\n+     SSE.Storage_Count (1 * (Standard'Address_Size / System.Storage_Unit));\n+   --  Size of each tag\n+\n    TSD_Prologue_Size : constant SSE.Storage_Count :=\n-     SSE.Storage_Count (10 * (Standard'Address_Size / System.Storage_Unit));\n+                         SSE.Storage_Count\n+                           (10 * (Standard'Address_Size /\n+                                   System.Storage_Unit));\n    --  Size of the first part of the type specific data\n \n    TSD_Entry_Size : constant SSE.Storage_Count :=\n-     SSE.Storage_Count (1 * (Standard'Address_Size / System.Storage_Unit));\n+                      SSE.Storage_Count\n+                        (1 * (Standard'Address_Size / System.Storage_Unit));\n    --  Size of each ancestor tag entry in the TSD\n \n    type Address_Array is array (Natural range <>) of System.Address;\n@@ -400,24 +458,6 @@ private\n    --  of this type are declared with a dummy size of 1, the actual size\n    --  depending on the number of primitive operations.\n \n-   type Signature_Kind is\n-      (Unknown,\n-       Valid_Signature,\n-       Primary_DT,\n-       Secondary_DT,\n-       Abstract_Interface);\n-   for Signature_Kind'Size use 8;\n-   --  Kind of signature found in the header of the dispatch table. These\n-   --  signatures are generated by the frontend and are used by the Check_XXX\n-   --  routines to ensure that the kind of dispatch table managed by each of\n-   --  the routines in this package is correct. This additional check is only\n-   --  performed with this run-time package is compiled with assertions enabled\n-\n-   --  The signature is a sequence of two bytes. The first byte must have the\n-   --  value Valid_Signature, and the second byte must have a value in the\n-   --  range Primary_DT .. Abstract_Interface. The Unknown value is used by\n-   --  the Check_XXX routines to indicate that the signature is wrong.\n-\n    --  Unchecked Conversions\n \n    type Addr_Ptr is access System.Address;\n@@ -427,6 +467,8 @@ private\n       array (1 .. DT_Signature_Size) of Signature_Kind;\n    --  Type used to see the signature as a sequence of Signature_Kind values\n \n+   type Signature_Values_Ptr is access all Signature_Values;\n+\n    function To_Addr_Ptr is\n       new Unchecked_Conversion (System.Address, Addr_Ptr);\n \n@@ -455,6 +497,13 @@ private\n      new Unchecked_Conversion (System.Storage_Elements.Storage_Offset,\n                                Signature_Values);\n \n+   function To_Signature_Values_Ptr is\n+     new Unchecked_Conversion (System.Address,\n+                               Signature_Values_Ptr);\n+\n+   function To_Tag is\n+     new Unchecked_Conversion (System.Address, Tag);\n+\n    function To_Tag_Ptr is\n      new Unchecked_Conversion (System.Address, Tag_Ptr);\n \n@@ -470,6 +519,7 @@ private\n    pragma Inline_Always (Get_Access_Level);\n    pragma Inline_Always (Get_Entry_Index);\n    pragma Inline_Always (Get_Offset_Index);\n+   pragma Inline_Always (Get_Predefined_Prim_Op_Address);\n    pragma Inline_Always (Get_Prim_Op_Address);\n    pragma Inline_Always (Get_Prim_Op_Kind);\n    pragma Inline_Always (Get_RC_Offset);\n@@ -488,10 +538,12 @@ private\n    pragma Inline_Always (Set_Num_Prim_Ops);\n    pragma Inline_Always (Set_Offset_Index);\n    pragma Inline_Always (Set_Offset_To_Top);\n+   pragma Inline_Always (Set_Predefined_Prim_Op_Address);\n    pragma Inline_Always (Set_Prim_Op_Address);\n    pragma Inline_Always (Set_Prim_Op_Kind);\n    pragma Inline_Always (Set_RC_Offset);\n    pragma Inline_Always (Set_Remotely_Callable);\n+   pragma Inline_Always (Set_Signature);\n    pragma Inline_Always (Set_OSD);\n    pragma Inline_Always (Set_SSD);\n    pragma Inline_Always (Set_TSD);"}, {"sha": "62cfb4ed4d9a752912c83df5c7964427e724e1e2", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 547, "deletions": 89, "changes": 636, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a05e99a2693109e7a2b4fffe853890946cd0320d/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a05e99a2693109e7a2b4fffe853890946cd0320d/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=a05e99a2693109e7a2b4fffe853890946cd0320d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -51,6 +51,7 @@ with Sem;      use Sem;\n with Sem_Attr; use Sem_Attr;\n with Sem_Ch3;  use Sem_Ch3;\n with Sem_Ch8;  use Sem_Ch8;\n+with Sem_Disp; use Sem_Disp;\n with Sem_Eval; use Sem_Eval;\n with Sem_Mech; use Sem_Mech;\n with Sem_Res;  use Sem_Res;\n@@ -237,6 +238,17 @@ package body Exp_Ch3 is\n    --  discriminant_checking functions of the parent can be reused by\n    --  a derived type.\n \n+   procedure Make_Controlling_Function_Wrappers\n+     (Tag_Typ   : Entity_Id;\n+      Decl_List : out List_Id;\n+      Body_List : out List_Id);\n+   --  Ada 2005 (AI-391): Makes specs and bodies for the wrapper functions\n+   --  associated with inherited functions with controlling results which\n+   --  are not overridden. The body of each wrapper function consists solely\n+   --  of a return statement whose expression is an extension aggregate\n+   --  invoking the inherited subprogram's parent subprogram and extended\n+   --  with a null association list.\n+\n    function Predef_Spec_Or_Body\n      (Loc      : Source_Ptr;\n       Tag_Typ  : Entity_Id;\n@@ -1097,6 +1109,7 @@ package body Exp_Ch3 is\n       --  honest. Actually it isn't quite type honest, because there can be\n       --  conflicts of views in the private type case. That is why we set\n       --  Conversion_OK in the conversion node.\n+\n       if (Is_Record_Type (Typ)\n            or else Is_Array_Type (Typ)\n            or else Is_Private_Type (Typ))\n@@ -1241,6 +1254,7 @@ package body Exp_Ch3 is\n \n             if With_Default_Init\n               and then Nkind (Id_Ref) = N_Selected_Component\n+              and then Nkind (Arg) = N_Identifier\n             then\n                Append_To (Args,\n                  Make_Selected_Component (Loc,\n@@ -1403,6 +1417,11 @@ package body Exp_Ch3 is\n       --  of the initialization procedure (by calling all the preceding\n       --  auxiliary routines), and install it as the _init TSS.\n \n+      procedure Build_Offset_To_Top_Functions;\n+      --  Ada 2005 (AI-251): Build the tree corresponding to the procedure spec\n+      --  and body of the Offset_To_Top function that is generated when the\n+      --  parent of a type with discriminants has secondary dispatch tables.\n+\n       procedure Build_Record_Checks (S : Node_Id; Check_List : List_Id);\n       --  Add range checks to components of disciminated records. S is a\n       --  subtype indication of a record component. Check_List is a list\n@@ -1577,7 +1596,7 @@ package body Exp_Ch3 is\n             while Present (D) loop\n                --  Don't generate the assignment for discriminants in derived\n                --  tagged types if the discriminant is a renaming of some\n-               --  ancestor discriminant.  This initialization will be done\n+               --  ancestor discriminant. This initialization will be done\n                --  when initializing the _parent field of the derived record.\n \n                if Is_Tagged and then\n@@ -1726,6 +1745,127 @@ package body Exp_Ch3 is\n          return Res;\n       end Build_Init_Call_Thru;\n \n+      -----------------------------------\n+      -- Build_Offset_To_Top_Functions --\n+      -----------------------------------\n+\n+      procedure Build_Offset_To_Top_Functions is\n+         ADT       : Elmt_Id;\n+         Body_Node : Node_Id;\n+         Func_Id   : Entity_Id;\n+         Spec_Node : Node_Id;\n+         E         : Entity_Id;\n+\n+         procedure Build_Offset_To_Top_Internal (Typ : Entity_Id);\n+         --  Internal subprogram used to recursively traverse all the ancestors\n+\n+         ----------------------------------\n+         -- Build_Offset_To_Top_Internal --\n+         ----------------------------------\n+\n+         procedure Build_Offset_To_Top_Internal (Typ : Entity_Id) is\n+         begin\n+            --  Climb to the ancestor (if any) handling private types\n+\n+            if Present (Full_View (Etype (Typ))) then\n+               if Full_View (Etype (Typ)) /= Typ then\n+                  Build_Offset_To_Top_Internal (Full_View (Etype (Typ)));\n+               end if;\n+\n+            elsif Etype (Typ) /= Typ then\n+               Build_Offset_To_Top_Internal (Etype (Typ));\n+            end if;\n+\n+            if Present (Abstract_Interfaces (Typ))\n+              and then not Is_Empty_Elmt_List (Abstract_Interfaces (Typ))\n+            then\n+               E := First_Entity (Typ);\n+               while Present (E) loop\n+                  if Is_Tag (E)\n+                    and then Chars (E) /= Name_uTag\n+                  then\n+                     if Typ = Rec_Type then\n+                        Body_Node := New_Node (N_Subprogram_Body, Loc);\n+\n+                        Func_Id := Make_Defining_Identifier (Loc,\n+                                     New_Internal_Name ('F'));\n+\n+                        Set_DT_Offset_To_Top_Func (E, Func_Id);\n+\n+                        Spec_Node := New_Node (N_Function_Specification, Loc);\n+                        Set_Defining_Unit_Name (Spec_Node, Func_Id);\n+                        Set_Parameter_Specifications (Spec_Node, New_List (\n+                           Make_Parameter_Specification (Loc,\n+                             Defining_Identifier =>\n+                               Make_Defining_Identifier (Loc, Name_uO),\n+                             In_Present => True,\n+                             Parameter_Type => New_Reference_To (Typ, Loc))));\n+                        Set_Result_Definition (Spec_Node,\n+                          New_Reference_To (RTE (RE_Storage_Offset), Loc));\n+\n+                        Set_Specification (Body_Node, Spec_Node);\n+                        Set_Declarations (Body_Node, New_List);\n+                        Set_Handled_Statement_Sequence (Body_Node,\n+                          Make_Handled_Sequence_Of_Statements (Loc,\n+                            Statements => New_List (\n+                              Make_Return_Statement (Loc,\n+                                Expression =>\n+                                  Make_Attribute_Reference (Loc,\n+                                    Prefix =>\n+                                      Make_Selected_Component (Loc,\n+                                        Prefix => Make_Identifier (Loc,\n+                                                    Name_uO),\n+                                        Selector_Name => New_Reference_To\n+                                                           (E, Loc)),\n+                                    Attribute_Name => Name_Position)))));\n+\n+                        Set_Ekind       (Func_Id, E_Function);\n+                        Set_Mechanism   (Func_Id, Default_Mechanism);\n+                        Set_Is_Internal (Func_Id, True);\n+\n+                        if not Debug_Generated_Code then\n+                           Set_Debug_Info_Off (Func_Id);\n+                        end if;\n+\n+                        Analyze (Body_Node);\n+\n+                        Append_Freeze_Action (Rec_Type, Body_Node);\n+                     end if;\n+\n+                     Next_Elmt (ADT);\n+                  end if;\n+\n+                  Next_Entity (E);\n+               end loop;\n+            end if;\n+         end Build_Offset_To_Top_Internal;\n+\n+      --  Start of processing for Build_Offset_To_Top_Functions\n+\n+      begin\n+         if Etype (Rec_Type) = Rec_Type\n+           or else not Has_Discriminants (Etype (Rec_Type))\n+           or else No (Abstract_Interfaces (Rec_Type))\n+           or else Is_Empty_Elmt_List (Abstract_Interfaces (Rec_Type))\n+         then\n+            return;\n+         end if;\n+\n+         --  Skip the first _Tag, which is the main tag of the\n+         --  tagged type. Following tags correspond with abstract\n+         --  interfaces.\n+\n+         ADT := Next_Elmt (First_Elmt (Access_Disp_Table (Rec_Type)));\n+\n+         --  Handle private types\n+\n+         if Present (Full_View (Rec_Type)) then\n+            Build_Offset_To_Top_Internal (Full_View (Rec_Type));\n+         else\n+            Build_Offset_To_Top_Internal (Rec_Type);\n+         end if;\n+      end Build_Offset_To_Top_Functions;\n+\n       --------------------------\n       -- Build_Init_Procedure --\n       --------------------------\n@@ -1758,9 +1898,10 @@ package body Exp_Ch3 is\n             ----------------------------------\n \n             procedure Init_Secondary_Tags_Internal (Typ : Entity_Id) is\n-               E     : Entity_Id;\n-               Aux_N : Node_Id;\n-               Iface : Entity_Id;\n+               Aux_N  : Node_Id;\n+               E      : Entity_Id;\n+               Iface  : Entity_Id;\n+               Prev_E : Entity_Id;\n \n             begin\n                --  Climb to the ancestor (if any) handling private types\n@@ -1800,33 +1941,132 @@ package body Exp_Ch3 is\n                             Expression =>\n                               New_Reference_To (Aux_N, Loc)));\n \n-                        --  Generate:\n-                        --    Set_Offset_To_Top (Init, Iface'Tag, n);\n+                        --  Issue error if Set_Offset_To_Top is not available\n+                        --  in a configurable run-time environment.\n \n-                        Append_To (Body_Stmts,\n-                          Make_Procedure_Call_Statement (Loc,\n-                            Name => New_Reference_To\n-                                      (RTE (RE_Set_Offset_To_Top), Loc),\n-                            Parameter_Associations => New_List (\n-                              Make_Attribute_Reference (Loc,\n-                                Prefix => Make_Identifier (Loc, Name_uInit),\n-                                Attribute_Name => Name_Address),\n-\n-                              Unchecked_Convert_To (RTE (RE_Tag),\n-                                New_Reference_To\n-                                  (Node (First_Elmt\n-                                         (Access_Disp_Table (Iface))),\n-                                   Loc)),\n-\n-                              Unchecked_Convert_To (RTE (RE_Storage_Offset),\n-                                Make_Attribute_Reference (Loc,\n-                                  Prefix         =>\n-                                   Make_Selected_Component (Loc,\n-                                     Prefix         => Make_Identifier (Loc,\n-                                                         Name_uInit),\n-                                     Selector_Name  => New_Reference_To\n-                                                         (E, Loc)),\n-                                 Attribute_Name => Name_Position)))));\n+                        if not RTE_Available (RE_Set_Offset_To_Top) then\n+                           Error_Msg_CRT (\"abstract interface types\", Typ);\n+                           return;\n+                        end if;\n+\n+                        --  We generate a different call to Set_Offset_To_Top\n+                        --  when the parent of the type has discriminants\n+\n+                        if Typ /= Etype (Typ)\n+                          and then Has_Discriminants (Etype (Typ))\n+                        then\n+                           pragma Assert (Present (DT_Offset_To_Top_Func (E)));\n+\n+                           --  Generate:\n+                           --    Set_Offset_To_Top\n+                           --      (This         => Init,\n+                           --       Interface_T  => Iface'Tag,\n+                           --       Is_Constant  => False,\n+                           --       Offset_Value => n,\n+                           --       Offset_Func  => Fn'Address)\n+\n+                           Append_To (Body_Stmts,\n+                             Make_Procedure_Call_Statement (Loc,\n+                               Name => New_Reference_To\n+                                         (RTE (RE_Set_Offset_To_Top), Loc),\n+                               Parameter_Associations => New_List (\n+                                 Make_Attribute_Reference (Loc,\n+                                   Prefix => Make_Identifier (Loc,\n+                                               Name_uInit),\n+                                   Attribute_Name => Name_Address),\n+\n+                                 Unchecked_Convert_To (RTE (RE_Tag),\n+                                   New_Reference_To\n+                                     (Node (First_Elmt\n+                                            (Access_Disp_Table (Iface))),\n+                                      Loc)),\n+\n+                                 New_Occurrence_Of (Standard_False, Loc),\n+\n+                                 Unchecked_Convert_To (RTE (RE_Storage_Offset),\n+                                   Make_Attribute_Reference (Loc,\n+                                     Prefix         =>\n+                                       Make_Selected_Component (Loc,\n+                                         Prefix => Make_Identifier (Loc,\n+                                                     Name_uInit),\n+                                         Selector_Name => New_Reference_To\n+                                                            (E, Loc)),\n+                                     Attribute_Name => Name_Position)),\n+\n+                                 Unchecked_Convert_To (RTE (RE_Address),\n+                                   Make_Attribute_Reference (Loc,\n+                                     Prefix => New_Reference_To\n+                                                 (DT_Offset_To_Top_Func (E),\n+                                                  Loc),\n+                                     Attribute_Name =>\n+                                       Name_Address)))));\n+\n+                           --  In this case the next component stores the value\n+                           --  of the offset to the top\n+\n+                           Prev_E := E;\n+                           Next_Entity (E);\n+                           pragma Assert (Present (E));\n+\n+                           Append_To (Body_Stmts,\n+                             Make_Assignment_Statement (Loc,\n+                               Name =>\n+                                 Make_Selected_Component (Loc,\n+                                   Prefix => Make_Identifier (Loc,\n+                                               Name_uInit),\n+                                   Selector_Name =>\n+                                     New_Reference_To (E, Loc)),\n+                               Expression =>\n+                                 Make_Attribute_Reference (Loc,\n+                                   Prefix         =>\n+                                     Make_Selected_Component (Loc,\n+                                       Prefix => Make_Identifier (Loc,\n+                                                   Name_uInit),\n+                                       Selector_Name => New_Reference_To\n+                                                          (Prev_E, Loc)),\n+                                 Attribute_Name => Name_Position)));\n+\n+                        --  Normal case: No discriminants in the parent type\n+\n+                        else\n+                           --  Generate:\n+                           --    Set_Offset_To_Top\n+                           --      (This         => Init,\n+                           --       Interface_T  => Iface'Tag,\n+                           --       Is_Constant  => True,\n+                           --       Offset_Value => n,\n+                           --       Offset_Func  => null);\n+\n+                           Append_To (Body_Stmts,\n+                             Make_Procedure_Call_Statement (Loc,\n+                               Name => New_Reference_To\n+                                         (RTE (RE_Set_Offset_To_Top), Loc),\n+                               Parameter_Associations => New_List (\n+                                 Make_Attribute_Reference (Loc,\n+                                   Prefix => Make_Identifier (Loc, Name_uInit),\n+                                   Attribute_Name => Name_Address),\n+\n+                                 Unchecked_Convert_To (RTE (RE_Tag),\n+                                   New_Reference_To\n+                                     (Node (First_Elmt\n+                                            (Access_Disp_Table (Iface))),\n+                                      Loc)),\n+\n+                                 New_Occurrence_Of (Standard_True, Loc),\n+\n+                                 Unchecked_Convert_To (RTE (RE_Storage_Offset),\n+                                   Make_Attribute_Reference (Loc,\n+                                     Prefix         =>\n+                                      Make_Selected_Component (Loc,\n+                                        Prefix         => Make_Identifier (Loc,\n+                                                            Name_uInit),\n+                                        Selector_Name  => New_Reference_To\n+                                                            (E, Loc)),\n+                                    Attribute_Name => Name_Position)),\n+\n+                                 New_Reference_To\n+                                   (RTE (RE_Null_Address), Loc))));\n+                        end if;\n \n                         Next_Elmt (ADT);\n                      end if;\n@@ -1897,8 +2137,9 @@ package body Exp_Ch3 is\n          if Parent_Subtype_Renaming_Discrims then\n \n             --  N is a Derived_Type_Definition that renames the parameters\n-            --  of the ancestor type.  We init it by expanding our discrims\n-            --  and call the ancestor _init_proc with a type-converted object\n+            --  of the ancestor type. We initialize it by expanding our\n+            --  discriminants and call the ancestor _init_proc with a\n+            --  type-converted object\n \n             Append_List_To (Body_Stmts,\n               Build_Init_Call_Thru (Parameters));\n@@ -1945,7 +2186,9 @@ package body Exp_Ch3 is\n          --     _Init._Tag := Typ'Tag;\n \n          --  Suppress the tag assignment when Java_VM because JVM tags are\n-         --  represented implicitly in objects.\n+         --  represented implicitly in objects. It is also suppressed in\n+         --  case of CPP_Class types because in this case the tag is\n+         --  initialized in the C++ side.\n \n          if Is_Tagged_Type (Rec_Type)\n            and then not Is_CPP_Class (Rec_Type)\n@@ -2375,7 +2618,10 @@ package body Exp_Ch3 is\n            Needs_Simple_Initialization (T)\n              and then not Is_RTE (T, RE_Tag)\n              and then not Is_RTE (T, RE_Vtable_Ptr)\n-             and then not Is_RTE (T, RE_Interface_Tag); --  Ada 2005 (AI-251)\n+\n+               --  Ada 2005 (AI-251): Check also the tag of abstract interfaces\n+\n+             and then not Is_RTE (T, RE_Interface_Tag);\n       end Component_Needs_Simple_Initialization;\n \n       ---------------------\n@@ -2552,7 +2798,8 @@ package body Exp_Ch3 is\n          --     since the call is generated, there had better be a routine\n          --     at the other end of the call, even if it does nothing!)\n \n-         --  Note: the reason we exclude the CPP_Class case is ???\n+         --  Note: the reason we exclude the CPP_Class case is because in this\n+         --  case the initialization is performed in the C++ side.\n \n          if Is_CPP_Class (Rec_Id) then\n             return False;\n@@ -2647,6 +2894,7 @@ package body Exp_Ch3 is\n       elsif Requires_Init_Proc (Rec_Type)\n         or else Is_Unchecked_Union (Rec_Type)\n       then\n+         Build_Offset_To_Top_Functions;\n          Build_Init_Procedure;\n          Set_Is_Public (Proc_Id, Is_Public (Pe));\n \n@@ -3342,7 +3590,7 @@ package body Exp_Ch3 is\n       if Is_Access_Type (Def_Id) then\n \n          --  Anonymous access types are created for the components of the\n-         --  record parameter for an entry declaration.  No master is created\n+         --  record parameter for an entry declaration. No master is created\n          --  for such a type.\n \n          if Has_Task (Designated_Type (Def_Id))\n@@ -3352,25 +3600,30 @@ package body Exp_Ch3 is\n             Build_Master_Renaming (Parent (Def_Id), Def_Id);\n \n          --  Create a class-wide master because a Master_Id must be generated\n-         --  for access-to-limited-class-wide types, whose root may be extended\n-         --  with task components.\n+         --  for access-to-limited-class-wide types whose root may be extended\n+         --  with task components, and for access-to-limited-interfaces because\n+         --  they can be used to reference tasks implementing such interface.\n \n          elsif Is_Class_Wide_Type (Designated_Type (Def_Id))\n-           and then Is_Limited_Type (Designated_Type (Def_Id))\n+           and then (Is_Limited_Type (Designated_Type (Def_Id))\n+                       or else\n+                        (Is_Interface (Designated_Type (Def_Id))\n+                           and then\n+                             Is_Limited_Interface (Designated_Type (Def_Id))))\n            and then Tasking_Allowed\n \n-            --  Don't create a class-wide master for types whose convention is\n+            --  Do not create a class-wide master for types whose convention is\n             --  Java since these types cannot embed Ada tasks anyway. Note that\n             --  the following test cannot catch the following case:\n-            --\n+\n             --      package java.lang.Object is\n             --         type Typ is tagged limited private;\n             --         type Ref is access all Typ'Class;\n             --      private\n             --         type Typ is tagged limited ...;\n             --         pragma Convention (Typ, Java)\n             --      end;\n-            --\n+\n             --  Because the convention appears after we have done the\n             --  processing for type Ref.\n \n@@ -3487,7 +3740,7 @@ package body Exp_Ch3 is\n \n       if No (Expr) then\n \n-         --  Expand Initialize call for controlled objects.  One may wonder why\n+         --  Expand Initialize call for controlled objects. One may wonder why\n          --  the Initialize Call is not done in the regular Init procedure\n          --  attached to the record type. That's because the init procedure is\n          --  recursively called on each component, including _Parent, thus the\n@@ -3591,21 +3844,27 @@ package body Exp_Ch3 is\n \n          --  Generate attribute for Persistent_BSS if needed\n \n-         declare\n-            Prag : Node_Id;\n-         begin\n-            if Persistent_BSS_Mode\n-              and then Comes_From_Source (N)\n-              and then Is_Potentially_Persistent_Type (Typ)\n-              and then Is_Library_Level_Entity (Def_Id)\n-            then\n+         if Persistent_BSS_Mode\n+           and then Comes_From_Source (N)\n+           and then Is_Potentially_Persistent_Type (Typ)\n+           and then Is_Library_Level_Entity (Def_Id)\n+         then\n+            declare\n+               Prag : Node_Id;\n+            begin\n                Prag :=\n                  Make_Linker_Section_Pragma\n                    (Def_Id, Sloc (N), \".persistent.bss\");\n                Insert_After (N, Prag);\n                Analyze (Prag);\n-            end if;\n-         end;\n+            end;\n+         end if;\n+\n+         --  If access type, then we know it is null if not initialized\n+\n+         if Is_Access_Type (Typ) then\n+            Set_Is_Known_Null (Def_Id);\n+         end if;\n \n       --  Explicit initialization present\n \n@@ -3618,23 +3877,23 @@ package body Exp_Ch3 is\n             Expr_Q := Expr;\n          end if;\n \n-         --  When we have the appropriate type of aggregate in the\n-         --  expression (it has been determined during analysis of the\n-         --  aggregate by setting the delay flag), let's perform in\n-         --  place assignment and thus avoid creating a temporary.\n+         --  When we have the appropriate type of aggregate in the expression\n+         --  (it has been determined during analysis of the aggregate by\n+         --  setting the delay flag), let's perform in place assignment and\n+         --  thus avoid creating a temporary.\n \n          if Is_Delayed_Aggregate (Expr_Q) then\n             Convert_Aggr_In_Object_Decl (N);\n \n          else\n-            --  In most cases, we must check that the initial value meets\n-            --  any constraint imposed by the declared type. However, there\n-            --  is one very important exception to this rule. If the entity\n-            --  has an unconstrained nominal subtype, then it acquired its\n-            --  constraints from the expression in the first place, and not\n-            --  only does this mean that the constraint check is not needed,\n-            --  but an attempt to perform the constraint check can\n-            --  cause order of elaboration problems.\n+            --  In most cases, we must check that the initial value meets any\n+            --  constraint imposed by the declared type. However, there is one\n+            --  very important exception to this rule. If the entity has an\n+            --  unconstrained nominal subtype, then it acquired its constraints\n+            --  from the expression in the first place, and not only does this\n+            --  mean that the constraint check is not needed, but an attempt to\n+            --  perform the constraint check can cause order order of\n+            --  elaboration problems.\n \n             if not Is_Constr_Subt_For_U_Nominal (Typ) then\n \n@@ -3653,6 +3912,7 @@ package body Exp_Ch3 is\n \n             --  If the type is controlled we attach the object to the final\n             --  list and adjust the target after the copy. This\n+            --  ??? incomplete sentence\n \n             if Controlled_Type (Typ) then\n                declare\n@@ -3662,10 +3922,10 @@ package body Exp_Ch3 is\n                begin\n                   --  Attach the result to a dummy final list which will never\n                   --  be finalized if Delay_Finalize_Attachis set. It is\n-                  --  important to attach to a dummy final list rather than\n-                  --  not attaching at all in order to reset the pointers\n-                  --  coming from the initial value. Equivalent code exists\n-                  --  in the sec-stack case in Exp_Ch4.Expand_N_Allocator.\n+                  --  important to attach to a dummy final list rather than not\n+                  --  attaching at all in order to reset the pointers coming\n+                  --  from the initial value. Equivalent code exists in the\n+                  --  sec-stack case in Exp_Ch4.Expand_N_Allocator.\n \n                   if Delay_Finalize_Attach (N) then\n                      F :=\n@@ -3694,20 +3954,20 @@ package body Exp_Ch3 is\n             --  For tagged types, when an init value is given, the tag has to\n             --  be re-initialized separately in order to avoid the propagation\n             --  of a wrong tag coming from a view conversion unless the type\n-            --  is class wide (in this case the tag comes from the init\n-            --  value). Suppress the tag assignment when Java_VM because JVM\n-            --  tags are represented implicitly in objects. Ditto for types\n-            --  that are CPP_CLASS, and for initializations that are\n-            --  aggregates, because they have to have the right tag.\n+            --  is class wide (in this case the tag comes from the init value).\n+            --  Suppress the tag assignment when Java_VM because JVM tags are\n+            --  represented implicitly in objects. Ditto for types that are\n+            --  CPP_CLASS, and for initializations that are aggregates, because\n+            --  they have to have the right tag.\n \n             if Is_Tagged_Type (Typ)\n               and then not Is_Class_Wide_Type (Typ)\n               and then not Is_CPP_Class (Typ)\n               and then not Java_VM\n               and then Nkind (Expr) /= N_Aggregate\n             then\n-               --  The re-assignment of the tag has to be done even if\n-               --  the object is a constant\n+               --  The re-assignment of the tag has to be done even if the\n+               --  object is a constant.\n \n                New_Ref :=\n                  Make_Selected_Component (Loc,\n@@ -3731,9 +3991,7 @@ package body Exp_Ch3 is\n             --  For discrete types, set the Is_Known_Valid flag if the\n             --  initializing value is known to be valid.\n \n-            elsif Is_Discrete_Type (Typ)\n-              and then Expr_Known_Valid (Expr)\n-            then\n+            elsif Is_Discrete_Type (Typ) and then Expr_Known_Valid (Expr) then\n                Set_Is_Known_Valid (Def_Id);\n \n             elsif Is_Access_Type (Typ) then\n@@ -3743,7 +4001,7 @@ package body Exp_Ch3 is\n                --  Can_Never_Be_Null if this is a constant.\n \n                if Known_Non_Null (Expr) then\n-                  Set_Is_Known_Non_Null (Def_Id);\n+                  Set_Is_Known_Non_Null (Def_Id, True);\n \n                   if Constant_Present (N) then\n                      Set_Can_Never_Be_Null (Def_Id);\n@@ -3761,19 +4019,19 @@ package body Exp_Ch3 is\n             end if;\n          end if;\n \n-         --  Cases where the back end cannot handle the initialization\n-         --  directly. In such cases, we expand an assignment that will\n-         --  be appropriately handled by Expand_N_Assignment_Statement.\n+         --  Cases where the back end cannot handle the initialization directly\n+         --  In such cases, we expand an assignment that will be appropriately\n+         --  handled by Expand_N_Assignment_Statement.\n \n-         --  The exclusion of the unconstrained case is wrong, but for\n-         --  now it is too much trouble ???\n+         --  The exclusion of the unconstrained case is wrong, but for now it\n+         --  is too much trouble ???\n \n          if (Is_Possibly_Unaligned_Slice (Expr)\n                or else (Is_Possibly_Unaligned_Object (Expr)\n                           and then not Represented_As_Scalar (Etype (Expr))))\n \n-            --  The exclusion of the unconstrained case is wrong, but for\n-            --  now it is too much trouble ???\n+            --  The exclusion of the unconstrained case is wrong, but for now\n+            --  it is too much trouble ???\n \n            and then not (Is_Array_Type (Etype (Expr))\n                            and then not Is_Constrained (Etype (Expr)))\n@@ -4427,6 +4685,9 @@ package body Exp_Ch3 is\n       Renamed_Eq  : Node_Id := Empty;\n       --  Could use some comments ???\n \n+      Wrapper_Decl_List : List_Id := No_List;\n+      Wrapper_Body_List : List_Id := No_List;\n+\n    begin\n       --  Build discriminant checking functions if not a derived type (for\n       --  derived types that are not tagged types, we always use the\n@@ -4508,6 +4769,17 @@ package body Exp_Ch3 is\n       if Is_Tagged_Type (Def_Id) then\n \n          if Is_CPP_Class (Def_Id) then\n+\n+            --  Because of the new C++ ABI compatibility we now allow the\n+            --  programer to use the Ada tag (and in this case we must do\n+            --  the normal expansion of the tag)\n+\n+            if Etype (First_Component (Def_Id)) = RTE (RE_Tag)\n+              and then Underlying_Type (Etype (Def_Id)) = Def_Id\n+            then\n+               Expand_Tagged_Root (Def_Id);\n+            end if;\n+\n             Set_All_DT_Position (Def_Id);\n             Set_Default_Constructor (Def_Id);\n \n@@ -4562,6 +4834,21 @@ package body Exp_Ch3 is\n               (Def_Id, Predef_List, Renamed_Eq);\n             Insert_List_Before_And_Analyze (N, Predef_List);\n \n+            --  Ada 2005 (AI-391): For a nonabstract null extension, create\n+            --  wrapper functions for each nonoverridden inherited function\n+            --  with a controlling result of the type. The wrapper for such\n+            --  a function returns an extension aggregate that invokes the\n+            --  the parent function.\n+\n+            if Ada_Version >= Ada_05\n+              and then not Is_Abstract (Def_Id)\n+              and then Is_Null_Extension (Def_Id)\n+            then\n+               Make_Controlling_Function_Wrappers\n+                 (Def_Id, Wrapper_Decl_List, Wrapper_Body_List);\n+               Insert_List_Before_And_Analyze (N, Wrapper_Decl_List);\n+            end if;\n+\n             Set_Is_Frozen (Def_Id, True);\n             Set_All_DT_Position (Def_Id);\n \n@@ -4752,11 +5039,19 @@ package body Exp_Ch3 is\n          Predef_List := Predefined_Primitive_Bodies (Def_Id, Renamed_Eq);\n          Append_Freeze_Actions (Def_Id, Predef_List);\n \n+         --  Ada 2005 (AI-391): If any wrappers were created for nonoverridden\n+         --  inherited functions, then add their bodies to the freeze actions.\n+\n+         if Present (Wrapper_Body_List) then\n+            Append_Freeze_Actions (Def_Id, Wrapper_Body_List);\n+         end if;\n+\n          --  Populate the two auxiliary tables used for dispatching\n          --  asynchronous, conditional and timed selects for synchronized\n          --  types that implement a limited interface.\n \n          if Ada_Version >= Ada_05\n+           and then not Restriction_Active (No_Dispatching_Calls)\n            and then Is_Concurrent_Record_Type (Def_Id)\n            and then Implements_Interface (\n                       Typ          => Def_Id,\n@@ -5022,7 +5317,7 @@ package body Exp_Ch3 is\n                   --  code requires both those types to be frozen\n \n                   if Is_Frozen (Desig_Type)\n-                    and then (not Present (Freeze_Node (Desig_Type))\n+                    and then (No (Freeze_Node (Desig_Type))\n                                or else Analyzed (Freeze_Node (Desig_Type)))\n                   then\n                      Freeze_Action_Typ := Def_Id;\n@@ -5608,6 +5903,167 @@ package body Exp_Ch3 is\n          return Empty_List;\n    end Init_Formals;\n \n+   -------------------------------------\n+   -- Make_Predefined_Primitive_Specs --\n+   -------------------------------------\n+\n+   procedure Make_Controlling_Function_Wrappers\n+     (Tag_Typ   : Entity_Id;\n+      Decl_List : out List_Id;\n+      Body_List : out List_Id)\n+   is\n+      Loc         : constant Source_Ptr := Sloc (Tag_Typ);\n+      Prim_Elmt   : Elmt_Id;\n+      Subp        : Entity_Id;\n+      Actual_List : List_Id;\n+      Formal_List : List_Id;\n+      Formal      : Entity_Id;\n+      Par_Formal  : Entity_Id;\n+      Formal_Node : Node_Id;\n+      Func_Spec   : Node_Id;\n+      Func_Decl   : Node_Id;\n+      Func_Body   : Node_Id;\n+      Return_Stmt : Node_Id;\n+\n+   begin\n+      Decl_List := New_List;\n+      Body_List := New_List;\n+\n+      Prim_Elmt := First_Elmt (Primitive_Operations (Tag_Typ));\n+\n+      while Present (Prim_Elmt) loop\n+         Subp := Node (Prim_Elmt);\n+\n+         --  If a primitive function with a controlling result of the type has\n+         --  not been overridden by the user, then we must create a wrapper\n+         --  function here that effectively overrides it and invokes the\n+         --  abstract inherited function's nonabstract parent. This can only\n+         --  occur for a null extension. Note that functions with anonymous\n+         --  controlling access results don't qualify and must be overridden.\n+         --  We also exclude Input attributes, since each type will have its\n+         --  own version of Input constructed by the expander. The test for\n+         --  Comes_From_Source is needed to distinguish inherited operations\n+         --  from renamings (which also have Alias set).\n+\n+         if Is_Abstract (Subp)\n+           and then Present (Alias (Subp))\n+           and then not Comes_From_Source (Subp)\n+           and then Ekind (Subp) = E_Function\n+           and then Has_Controlling_Result (Subp)\n+           and then not Is_Access_Type (Etype (Subp))\n+           and then not Is_TSS (Subp, TSS_Stream_Input)\n+         then\n+            Formal_List := No_List;\n+            Formal := First_Formal (Subp);\n+\n+            if Present (Formal) then\n+               Formal_List := New_List;\n+\n+               while Present (Formal) loop\n+                  Append\n+                    (Make_Parameter_Specification\n+                       (Loc,\n+                        Defining_Identifier =>\n+                          Make_Defining_Identifier (Sloc (Formal),\n+                            Chars => Chars (Formal)),\n+                        In_Present  => In_Present (Parent (Formal)),\n+                        Out_Present => Out_Present (Parent (Formal)),\n+                        Parameter_Type =>\n+                          New_Reference_To (Etype (Formal), Loc),\n+                        Expression =>\n+                          New_Copy_Tree (Expression (Parent (Formal)))),\n+                     Formal_List);\n+\n+                  Next_Formal (Formal);\n+               end loop;\n+            end if;\n+\n+            Func_Spec :=\n+              Make_Function_Specification (Loc,\n+                Defining_Unit_Name =>\n+                  Make_Defining_Identifier (Loc, Chars (Subp)),\n+                Parameter_Specifications =>\n+                  Formal_List,\n+                Result_Definition =>\n+                  New_Reference_To (Etype (Subp), Loc));\n+\n+            Func_Decl := Make_Subprogram_Declaration (Loc, Func_Spec);\n+            Append_To (Decl_List, Func_Decl);\n+\n+            --  Build a wrapper body that calls the parent function. The body\n+            --  contains a single return statement that returns an extension\n+            --  aggregate whose ancestor part is a call to the parent function,\n+            --  passing the formals as actuals (with any controlling arguments\n+            --  converted to the types of the corresponding formals of the\n+            --  parent function, which might be anonymous access types), and\n+            --  having a null extension.\n+\n+            Formal      := First_Formal (Subp);\n+            Par_Formal  := First_Formal (Alias (Subp));\n+            Formal_Node := First (Formal_List);\n+\n+            if Present (Formal) then\n+               Actual_List := New_List;\n+            else\n+               Actual_List := No_List;\n+            end if;\n+\n+            while Present (Formal) loop\n+               if Is_Controlling_Formal (Formal) then\n+                  Append_To (Actual_List,\n+                    Make_Type_Conversion (Loc,\n+                      Subtype_Mark =>\n+                        New_Occurrence_Of (Etype (Par_Formal), Loc),\n+                      Expression   =>\n+                        New_Reference_To\n+                          (Defining_Identifier (Formal_Node), Loc)));\n+               else\n+                  Append_To\n+                    (Actual_List,\n+                     New_Reference_To\n+                       (Defining_Identifier (Formal_Node), Loc));\n+               end if;\n+\n+               Next_Formal (Formal);\n+               Next_Formal (Par_Formal);\n+               Next (Formal_Node);\n+            end loop;\n+\n+            Return_Stmt :=\n+              Make_Return_Statement (Loc,\n+                Expression =>\n+                  Make_Extension_Aggregate (Loc,\n+                    Ancestor_Part =>\n+                      Make_Function_Call (Loc,\n+                        Name => New_Reference_To (Alias (Subp), Loc),\n+                        Parameter_Associations => Actual_List),\n+                    Null_Record_Present => True));\n+\n+            Func_Body :=\n+              Make_Subprogram_Body (Loc,\n+                Specification => New_Copy_Tree (Func_Spec),\n+                Declarations => Empty_List,\n+                Handled_Statement_Sequence =>\n+                  Make_Handled_Sequence_Of_Statements (Loc,\n+                    Statements => New_List (Return_Stmt)));\n+\n+            Set_Defining_Unit_Name\n+              (Specification (Func_Body),\n+                Make_Defining_Identifier (Loc, Chars (Subp)));\n+\n+            Append_To (Body_List, Func_Body);\n+\n+            --  Replace the inherited function with the wrapper function\n+            --  in the primitive operations list.\n+\n+            Override_Dispatching_Operation\n+              (Tag_Typ, Subp, New_Op => Defining_Unit_Name (Func_Spec));\n+         end if;\n+\n+         Next_Elmt (Prim_Elmt);\n+      end loop;\n+   end Make_Controlling_Function_Wrappers;\n+\n    ------------------\n    -- Make_Eq_Case --\n    ------------------\n@@ -6370,6 +6826,8 @@ package body Exp_Ch3 is\n       --  limited interface. The interface versions will have null bodies.\n \n       if Ada_Version >= Ada_05\n+        and then\n+          not Restriction_Active (No_Dispatching_Calls)\n         and then\n           ((Is_Interface (Tag_Typ) and then Is_Limited_Record (Tag_Typ))\n               or else"}, {"sha": "acc7ac925dbd92438876125b4cbaacafa2d54510", "filename": "gcc/ada/rtsfind.ads", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a05e99a2693109e7a2b4fffe853890946cd0320d/gcc%2Fada%2Frtsfind.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a05e99a2693109e7a2b4fffe853890946cd0320d/gcc%2Fada%2Frtsfind.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.ads?ref=a05e99a2693109e7a2b4fffe853890946cd0320d", "patch": "@@ -502,6 +502,7 @@ package Rtsfind is\n      RE_Get_Entry_Index,                 -- Ada.Tags\n      RE_Get_External_Tag,                -- Ada.Tags\n      RE_Get_Offset_Index,                -- Ada.Tags\n+     RE_Get_Predefined_Prim_Op_Address,  -- Ada.Tags\n      RE_Get_Prim_Op_Address,             -- Ada.Tags\n      RE_Get_Prim_Op_Kind,                -- Ada.Tags\n      RE_Get_RC_Offset,                   -- Ada.Tags\n@@ -539,11 +540,13 @@ package Rtsfind is\n      RE_Set_Offset_Index,                -- Ada.Tags\n      RE_Set_Offset_To_Top,               -- Ada.Tags\n      RE_Set_OSD,                         -- Ada.Tags\n+     RE_Set_Predefined_Prim_Op_Address,  -- Ada.Tags\n      RE_Set_Prim_Op_Address,             -- Ada.Tags\n      RE_Set_Prim_Op_Kind,                -- Ada.Tags\n      RE_Set_RC_Offset,                   -- Ada.Tags\n      RE_Set_Remotely_Callable,           -- Ada.Tags\n      RE_Set_SSD,                         -- Ada.Tags\n+     RE_Set_Signature,                   -- Ada.Tags\n      RE_Set_Tagged_Kind,                 -- Ada.Tags\n      RE_Set_TSD,                         -- Ada.Tags\n      RE_Tag,                             -- Ada.Tags\n@@ -1656,6 +1659,7 @@ package Rtsfind is\n      RE_Get_Entry_Index                  => Ada_Tags,\n      RE_Get_External_Tag                 => Ada_Tags,\n      RE_Get_Offset_Index                 => Ada_Tags,\n+     RE_Get_Predefined_Prim_Op_Address   => Ada_Tags,\n      RE_Get_Prim_Op_Address              => Ada_Tags,\n      RE_Get_Prim_Op_Kind                 => Ada_Tags,\n      RE_Get_RC_Offset                    => Ada_Tags,\n@@ -1693,11 +1697,13 @@ package Rtsfind is\n      RE_Set_Offset_Index                 => Ada_Tags,\n      RE_Set_Offset_To_Top                => Ada_Tags,\n      RE_Set_OSD                          => Ada_Tags,\n+     RE_Set_Predefined_Prim_Op_Address   => Ada_Tags,\n      RE_Set_Prim_Op_Address              => Ada_Tags,\n      RE_Set_Prim_Op_Kind                 => Ada_Tags,\n      RE_Set_RC_Offset                    => Ada_Tags,\n      RE_Set_Remotely_Callable            => Ada_Tags,\n      RE_Set_SSD                          => Ada_Tags,\n+     RE_Set_Signature                    => Ada_Tags,\n      RE_Set_Tagged_Kind                  => Ada_Tags,\n      RE_Set_TSD                          => Ada_Tags,\n      RE_Tag                              => Ada_Tags,"}]}