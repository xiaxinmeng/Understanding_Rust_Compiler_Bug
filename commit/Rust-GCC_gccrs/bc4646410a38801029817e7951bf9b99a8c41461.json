{"sha": "bc4646410a38801029817e7951bf9b99a8c41461", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmM0NjQ2NDEwYTM4ODAxMDI5ODE3ZTc5NTFiZjliOTlhOGM0MTQ2MQ==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-01-10T22:11:07Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-02-07T01:08:34Z"}, "message": "libstdc++: Implement C++20 constrained algorithms\n\nThis patch implements the C++20 ranges overloads for the algorithms in\n[algorithms].  Most of the algorithms were reimplemented, with each of their\nimplementations very closely following the existing implementation in\nbits/stl_algo.h and bits/stl_algobase.h.  The reason for reimplementing most of\nthe algorithms instead of forwarding to their STL-style overload is because\nforwarding cannot be conformantly and efficiently performed for algorithms that\noperate on non-random-access iterators.  But algorithms that operate on random\naccess iterators can safely and efficiently be forwarded to the STL-style\nimplementation, and this patch does so for push_heap, pop_heap, make_heap,\nsort_heap, sort, stable_sort, nth_element, inplace_merge and stable_partition.\n\nWhat's missing from this patch is debug-iterator and container specializations\nthat are present for some of the STL-style algorithms that need to be ported\nover to the ranges algos.  I marked them missing at TODO comments.  There are\nalso some other minor outstanding TODOs.\n\nThe code that could use the most thorough review is ranges::__copy_or_move,\nranges::__copy_or_move_backward, ranges::__equal and\nranges::__lexicographical_compare.  In the tests, I tried to test the interface\nof each new overload, as well as the correctness of the new implementation.\n\nlibstdc++-v3/ChangeLog:\n\n\tImplement C++20 constrained algorithms\n\t* include/Makefile.am: Add new header.\n\t* include/Makefile.in: Regenerate.\n\t* include/std/algorithm: Include <bits/ranges_algo.h>.\n\t* include/bits/ranges_algo.h: New file.\n\t* testsuite/25_algorithms/adjacent_find/constrained.cc: New test.\n\t* testsuite/25_algorithms/all_of/constrained.cc: New test.\n\t* testsuite/25_algorithms/any_of/constrained.cc: New test.\n\t* testsuite/25_algorithms/binary_search/constrained.cc: New test.\n\t* testsuite/25_algorithms/copy/constrained.cc: New test.\n\t* testsuite/25_algorithms/copy_backward/constrained.cc: New test.\n\t* testsuite/25_algorithms/copy_if/constrained.cc: New test.\n\t* testsuite/25_algorithms/copy_n/constrained.cc: New test.\n\t* testsuite/25_algorithms/count/constrained.cc: New test.\n\t* testsuite/25_algorithms/count_if/constrained.cc: New test.\n\t* testsuite/25_algorithms/equal/constrained.cc: New test.\n\t* testsuite/25_algorithms/equal_range/constrained.cc: New test.\n\t* testsuite/25_algorithms/fill/constrained.cc: New test.\n\t* testsuite/25_algorithms/fill_n/constrained.cc: New test.\n\t* testsuite/25_algorithms/find/constrained.cc: New test.\n\t* testsuite/25_algorithms/find_end/constrained.cc: New test.\n\t* testsuite/25_algorithms/find_first_of/constrained.cc: New test.\n\t* testsuite/25_algorithms/find_if/constrained.cc: New test.\n\t* testsuite/25_algorithms/find_if_not/constrained.cc: New test.\n\t* testsuite/25_algorithms/for_each/constrained.cc: New test.\n\t* testsuite/25_algorithms/generate/constrained.cc: New test.\n\t* testsuite/25_algorithms/generate_n/constrained.cc: New test.\n\t* testsuite/25_algorithms/heap/constrained.cc: New test.\n\t* testsuite/25_algorithms/includes/constrained.cc: New test.\n\t* testsuite/25_algorithms/inplace_merge/constrained.cc: New test.\n\t* testsuite/25_algorithms/is_partitioned/constrained.cc: New test.\n\t* testsuite/25_algorithms/is_permutation/constrained.cc: New test.\n\t* testsuite/25_algorithms/is_sorted/constrained.cc: New test.\n\t* testsuite/25_algorithms/is_sorted_until/constrained.cc: New test.\n\t* testsuite/25_algorithms/lexicographical_compare/constrained.cc: New\n\ttest.\n\t* testsuite/25_algorithms/lower_bound/constrained.cc: New test.\n\t* testsuite/25_algorithms/max/constrained.cc: New test.\n\t* testsuite/25_algorithms/max_element/constrained.cc: New test.\n\t* testsuite/25_algorithms/merge/constrained.cc: New test.\n\t* testsuite/25_algorithms/min/constrained.cc: New test.\n\t* testsuite/25_algorithms/min_element/constrained.cc: New test.\n\t* testsuite/25_algorithms/minmax/constrained.cc: New test.\n\t* testsuite/25_algorithms/minmax_element/constrained.cc: New test.\n\t* testsuite/25_algorithms/mismatch/constrained.cc: New test.\n\t* testsuite/25_algorithms/move/constrained.cc: New test.\n\t* testsuite/25_algorithms/move_backward/constrained.cc: New test.\n\t* testsuite/25_algorithms/next_permutation/constrained.cc: New test.\n\t* testsuite/25_algorithms/none_of/constrained.cc: New test.\n\t* testsuite/25_algorithms/nth_element/constrained.cc: New test.\n\t* testsuite/25_algorithms/partial_sort/constrained.cc: New test.\n\t* testsuite/25_algorithms/partial_sort_copy/constrained.cc: New test.\n\t* testsuite/25_algorithms/partition/constrained.cc: New test.\n\t* testsuite/25_algorithms/partition_copy/constrained.cc: New test.\n\t* testsuite/25_algorithms/partition_point/constrained.cc: New test.\n\t* testsuite/25_algorithms/prev_permutation/constrained.cc: New test.\n\t* testsuite/25_algorithms/remove/constrained.cc: New test.\n\t* testsuite/25_algorithms/remove_copy/constrained.cc: New test.\n\t* testsuite/25_algorithms/remove_copy_if/constrained.cc: New test.\n\t* testsuite/25_algorithms/remove_if/constrained.cc: New test.\n\t* testsuite/25_algorithms/replace/constrained.cc: New test.\n\t* testsuite/25_algorithms/replace_copy/constrained.cc: New test.\n\t* testsuite/25_algorithms/replace_copy_if/constrained.cc: New test.\n\t* testsuite/25_algorithms/replace_if/constrained.cc: New test.\n\t* testsuite/25_algorithms/reverse/constrained.cc: New test.\n\t* testsuite/25_algorithms/reverse_copy/constrained.cc: New test.\n\t* testsuite/25_algorithms/rotate/constrained.cc: New test.\n\t* testsuite/25_algorithms/rotate_copy/constrained.cc: New test.\n\t* testsuite/25_algorithms/search/constrained.cc: New test.\n\t* testsuite/25_algorithms/search_n/constrained.cc: New test.\n\t* testsuite/25_algorithms/set_difference/constrained.cc: New test.\n\t* testsuite/25_algorithms/set_intersection/constrained.cc: New test.\n\t* testsuite/25_algorithms/set_symmetric_difference/constrained.cc: New\n\ttest.\n\t* testsuite/25_algorithms/set_union/constrained.cc: New test.\n\t* testsuite/25_algorithms/shuffle/constrained.cc: New test.\n\t* testsuite/25_algorithms/sort/constrained.cc: New test.\n\t* testsuite/25_algorithms/stable_partition/constrained.cc: New test.\n\t* testsuite/25_algorithms/stable_sort/constrained.cc: New test.\n\t* testsuite/25_algorithms/swap_ranges/constrained.cc: New test.\n\t* testsuite/25_algorithms/transform/constrained.cc: New test.\n\t* testsuite/25_algorithms/unique/constrained.cc: New test.\n\t* testsuite/25_algorithms/unique_copy/constrained.cc: New test.\n\t* testsuite/25_algorithms/upper_bound/constrained.cc: New test.", "tree": {"sha": "2a2905527c501b436a94d51f7d15ae6a8bd501e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2a2905527c501b436a94d51f7d15ae6a8bd501e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bc4646410a38801029817e7951bf9b99a8c41461", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc4646410a38801029817e7951bf9b99a8c41461", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc4646410a38801029817e7951bf9b99a8c41461", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc4646410a38801029817e7951bf9b99a8c41461/comments", "author": null, "committer": null, "parents": [{"sha": "13f5b93e6453d121abc15c718dfcc588aca976c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13f5b93e6453d121abc15c718dfcc588aca976c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13f5b93e6453d121abc15c718dfcc588aca976c3"}], "stats": {"total": 10876, "additions": 10876, "deletions": 0}, "files": [{"sha": "b9c7f436a810ba774c5dccea1cb3d5524bbe8d28", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -1,3 +1,91 @@\n+2020-02-07  Patrick Palka  <ppalka@redhat.com>\n+\t    Jonathan Wakely  <jwakely@redhat.com>\n+\n+\tImplement C++20 constrained algorithms\n+\t* include/Makefile.am: Add new header.\n+\t* include/Makefile.in: Regenerate.\n+\t* include/std/algorithm: Include <bits/ranges_algo.h>.\n+\t* include/bits/ranges_algo.h: New file.\n+\t* testsuite/25_algorithms/adjacent_find/constrained.cc: New test.\n+\t* testsuite/25_algorithms/all_of/constrained.cc: New test.\n+\t* testsuite/25_algorithms/any_of/constrained.cc: New test.\n+\t* testsuite/25_algorithms/binary_search/constrained.cc: New test.\n+\t* testsuite/25_algorithms/copy/constrained.cc: New test.\n+\t* testsuite/25_algorithms/copy_backward/constrained.cc: New test.\n+\t* testsuite/25_algorithms/copy_if/constrained.cc: New test.\n+\t* testsuite/25_algorithms/copy_n/constrained.cc: New test.\n+\t* testsuite/25_algorithms/count/constrained.cc: New test.\n+\t* testsuite/25_algorithms/count_if/constrained.cc: New test.\n+\t* testsuite/25_algorithms/equal/constrained.cc: New test.\n+\t* testsuite/25_algorithms/equal_range/constrained.cc: New test.\n+\t* testsuite/25_algorithms/fill/constrained.cc: New test.\n+\t* testsuite/25_algorithms/fill_n/constrained.cc: New test.\n+\t* testsuite/25_algorithms/find/constrained.cc: New test.\n+\t* testsuite/25_algorithms/find_end/constrained.cc: New test.\n+\t* testsuite/25_algorithms/find_first_of/constrained.cc: New test.\n+\t* testsuite/25_algorithms/find_if/constrained.cc: New test.\n+\t* testsuite/25_algorithms/find_if_not/constrained.cc: New test.\n+\t* testsuite/25_algorithms/for_each/constrained.cc: New test.\n+\t* testsuite/25_algorithms/generate/constrained.cc: New test.\n+\t* testsuite/25_algorithms/generate_n/constrained.cc: New test.\n+\t* testsuite/25_algorithms/heap/constrained.cc: New test.\n+\t* testsuite/25_algorithms/includes/constrained.cc: New test.\n+\t* testsuite/25_algorithms/inplace_merge/constrained.cc: New test.\n+\t* testsuite/25_algorithms/is_partitioned/constrained.cc: New test.\n+\t* testsuite/25_algorithms/is_permutation/constrained.cc: New test.\n+\t* testsuite/25_algorithms/is_sorted/constrained.cc: New test.\n+\t* testsuite/25_algorithms/is_sorted_until/constrained.cc: New test.\n+\t* testsuite/25_algorithms/lexicographical_compare/constrained.cc: New\n+\ttest.\n+\t* testsuite/25_algorithms/lower_bound/constrained.cc: New test.\n+\t* testsuite/25_algorithms/max/constrained.cc: New test.\n+\t* testsuite/25_algorithms/max_element/constrained.cc: New test.\n+\t* testsuite/25_algorithms/merge/constrained.cc: New test.\n+\t* testsuite/25_algorithms/min/constrained.cc: New test.\n+\t* testsuite/25_algorithms/min_element/constrained.cc: New test.\n+\t* testsuite/25_algorithms/minmax/constrained.cc: New test.\n+\t* testsuite/25_algorithms/minmax_element/constrained.cc: New test.\n+\t* testsuite/25_algorithms/mismatch/constrained.cc: New test.\n+\t* testsuite/25_algorithms/move/constrained.cc: New test.\n+\t* testsuite/25_algorithms/move_backward/constrained.cc: New test.\n+\t* testsuite/25_algorithms/next_permutation/constrained.cc: New test.\n+\t* testsuite/25_algorithms/none_of/constrained.cc: New test.\n+\t* testsuite/25_algorithms/nth_element/constrained.cc: New test.\n+\t* testsuite/25_algorithms/partial_sort/constrained.cc: New test.\n+\t* testsuite/25_algorithms/partial_sort_copy/constrained.cc: New test.\n+\t* testsuite/25_algorithms/partition/constrained.cc: New test.\n+\t* testsuite/25_algorithms/partition_copy/constrained.cc: New test.\n+\t* testsuite/25_algorithms/partition_point/constrained.cc: New test.\n+\t* testsuite/25_algorithms/prev_permutation/constrained.cc: New test.\n+\t* testsuite/25_algorithms/remove/constrained.cc: New test.\n+\t* testsuite/25_algorithms/remove_copy/constrained.cc: New test.\n+\t* testsuite/25_algorithms/remove_copy_if/constrained.cc: New test.\n+\t* testsuite/25_algorithms/remove_if/constrained.cc: New test.\n+\t* testsuite/25_algorithms/replace/constrained.cc: New test.\n+\t* testsuite/25_algorithms/replace_copy/constrained.cc: New test.\n+\t* testsuite/25_algorithms/replace_copy_if/constrained.cc: New test.\n+\t* testsuite/25_algorithms/replace_if/constrained.cc: New test.\n+\t* testsuite/25_algorithms/reverse/constrained.cc: New test.\n+\t* testsuite/25_algorithms/reverse_copy/constrained.cc: New test.\n+\t* testsuite/25_algorithms/rotate/constrained.cc: New test.\n+\t* testsuite/25_algorithms/rotate_copy/constrained.cc: New test.\n+\t* testsuite/25_algorithms/search/constrained.cc: New test.\n+\t* testsuite/25_algorithms/search_n/constrained.cc: New test.\n+\t* testsuite/25_algorithms/set_difference/constrained.cc: New test.\n+\t* testsuite/25_algorithms/set_intersection/constrained.cc: New test.\n+\t* testsuite/25_algorithms/set_symmetric_difference/constrained.cc: New\n+\ttest.\n+\t* testsuite/25_algorithms/set_union/constrained.cc: New test.\n+\t* testsuite/25_algorithms/shuffle/constrained.cc: New test.\n+\t* testsuite/25_algorithms/sort/constrained.cc: New test.\n+\t* testsuite/25_algorithms/stable_partition/constrained.cc: New test.\n+\t* testsuite/25_algorithms/stable_sort/constrained.cc: New test.\n+\t* testsuite/25_algorithms/swap_ranges/constrained.cc: New test.\n+\t* testsuite/25_algorithms/transform/constrained.cc: New test.\n+\t* testsuite/25_algorithms/unique/constrained.cc: New test.\n+\t* testsuite/25_algorithms/unique_copy/constrained.cc: New test.\n+\t* testsuite/25_algorithms/upper_bound/constrained.cc: New test.\n+\n 2020-02-06  Jonathan Wakely  <jwakely@redhat.com>\n \n \t* include/bits/stl_iterator.h (__detail::__common_iter_ptr): Fix PR"}, {"sha": "1d342cecbccfbf0e4b60632f5efa3306eb93d9b6", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -157,6 +157,7 @@ bits_headers = \\\n \t${bits_srcdir}/random.tcc \\\n \t${bits_srcdir}/range_access.h \\\n \t${bits_srcdir}/range_cmp.h \\\n+\t${bits_srcdir}/ranges_algo.h \\\n \t${bits_srcdir}/refwrap.h \\\n \t${bits_srcdir}/regex.h \\\n \t${bits_srcdir}/regex.tcc \\"}, {"sha": "c735d67a5d30f5e0f054ba496ae42cf1816ced50", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -502,6 +502,7 @@ bits_headers = \\\n \t${bits_srcdir}/random.tcc \\\n \t${bits_srcdir}/range_access.h \\\n \t${bits_srcdir}/range_cmp.h \\\n+\t${bits_srcdir}/ranges_algo.h \\\n \t${bits_srcdir}/refwrap.h \\\n \t${bits_srcdir}/regex.h \\\n \t${bits_srcdir}/regex.tcc \\"}, {"sha": "a9b87283f87853a526c5caf5cee439a365df3e44", "filename": "libstdc++-v3/include/bits/ranges_algo.h", "status": "added", "additions": 3640, "deletions": 0, "changes": 3640, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algo.h?ref=bc4646410a38801029817e7951bf9b99a8c41461"}, {"sha": "4b956b894035992e339321af2c3b05ef383c4b33", "filename": "libstdc++-v3/include/std/algorithm", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Finclude%2Fstd%2Falgorithm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Finclude%2Fstd%2Falgorithm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Falgorithm?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -60,6 +60,9 @@\n #include <utility> // UK-300.\n #include <bits/stl_algobase.h>\n #include <bits/stl_algo.h>\n+#if __cplusplus > 201703L\n+# include <bits/ranges_algo.h>\n+#endif\n \n #if __cplusplus > 201402L\n // Parallel STL algorithms"}, {"sha": "d56ac5a19dbbbbfdeb0a8734ceff9ea6530f7cd2", "filename": "libstdc++-v3/testsuite/25_algorithms/adjacent_find/constrained.cc", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fadjacent_find%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fadjacent_find%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fadjacent_find%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,68 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::input_iterator_wrapper;\n+using __gnu_test::forward_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+struct X { int i; };\n+\n+void\n+test01()\n+{\n+  X x[] = { {2}, {2}, {6}, {8}, {10}, {11} };\n+  int y[] = { 2, 7, 8, 8, 9 };\n+\n+  VERIFY( ranges::adjacent_find(x, x+6, {}, &X::i) == x+0 );\n+  VERIFY( ranges::adjacent_find(x+1, x+6, {}, &X::i) == x+6 );\n+  VERIFY( ranges::adjacent_find(y) == y+2 );\n+  VERIFY( ranges::adjacent_find(y, y+4) == y+2 );\n+\n+  test_container<X, forward_iterator_wrapper> c(x);\n+  VERIFY( ranges::adjacent_find(c, {}, &X::i) == ranges::begin(c) );\n+\n+  test_range<int, forward_iterator_wrapper> r(y);\n+  auto res = ranges::adjacent_find(r);\n+  VERIFY( *res == 8 && *++res == 8 );\n+}\n+\n+void\n+test02()\n+{\n+  static constexpr X x[] = { {2}, {2}, {6}, {8}, {10}, {11} };\n+  static constexpr X y[] = { {2}, {6}, {8}, {10}, {11} };\n+  static_assert(ranges::adjacent_find(x, {}, &X::i) == x+0);\n+  static_assert(ranges::adjacent_find(y, {}, &X::i) == y+5);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}\n+"}, {"sha": "e35a1016764cb61b0d42b135fa490921c6a99766", "filename": "libstdc++-v3/testsuite/25_algorithms/all_of/constrained.cc", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fall_of%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fall_of%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fall_of%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,90 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::input_iterator_wrapper;\n+using __gnu_test::forward_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+struct X { int i; };\n+\n+struct XLess\n+{\n+  int val;\n+  bool operator()(X& x) const { return x.i < val; }\n+};\n+\n+struct ILess\n+{\n+  int val;\n+  bool operator()(int& i) const { return i < val; }\n+};\n+\n+template<typename T>\n+struct NotZero\n+{\n+  bool operator()(T& t) const { return t != 0; }\n+};\n+\n+void\n+test01()\n+{\n+  X x[] = { {2}, {4}, {6}, {8}, {10}, {11} };\n+\n+  VERIFY( ranges::all_of(x, x+5, XLess{11}) );\n+  VERIFY( ranges::all_of(x, x+5, ILess{11}, &X::i) );\n+  VERIFY( !ranges::all_of(x, x+6, ILess{11}, &X::i) );\n+  VERIFY( !ranges::all_of(x, XLess{11}) );\n+  VERIFY( ranges::all_of(x, XLess{12}) );\n+  VERIFY( ranges::all_of(x, ILess{12}, &X::i) );\n+  VERIFY( !ranges::all_of(x, ILess{11}, &X::i) );\n+\n+  test_container<X, forward_iterator_wrapper> c(x);\n+  VERIFY( ranges::all_of(c, NotZero<int>{}, &X::i) );\n+\n+  test_range<X, input_iterator_wrapper> r(x);\n+  VERIFY( ranges::all_of(r, NotZero<int>{}, &X::i) );\n+\n+  r.bounds.first = x;\n+  VERIFY( ranges::all_of(r, NotZero<X* const>{}, [](X& x) { return &x; }) );\n+}\n+\n+struct Y { int i; int j; };\n+\n+void\n+test02()\n+{\n+  static constexpr Y y[] = { {1,2}, {2,4}, {3,6} };\n+  static_assert(ranges::all_of(y, [](int j) { return j%2 == 0; }, &Y::j));\n+  static_assert(ranges::all_of(y, [](const Y& y) { return y.j == y.i * 2; }));\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "b234692d2c79c1e7e2398394a0fb8db079b330c0", "filename": "libstdc++-v3/testsuite/25_algorithms/any_of/constrained.cc", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fany_of%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fany_of%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fany_of%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,88 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::input_iterator_wrapper;\n+using __gnu_test::forward_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+struct X { int i; };\n+\n+struct XLess\n+{\n+  int val;\n+  bool operator()(X& x) const { return x.i < val; }\n+};\n+\n+struct ILess\n+{\n+  int val;\n+  bool operator()(int& i) const { return i < val; }\n+};\n+\n+template<typename T>\n+struct NotZero\n+{\n+  bool operator()(T& t) const { return t != 0; }\n+};\n+\n+void\n+test01()\n+{\n+  X x[] = { {2}, {4}, {6}, {8}, {10}, {11} };\n+\n+  VERIFY( ranges::any_of(x, x+6, XLess{3}) );\n+  VERIFY( ranges::any_of(x, x+6, ILess{3}, &X::i) );\n+  VERIFY( !ranges::any_of(x+1, x+6, XLess{3}) );\n+  VERIFY( !ranges::any_of(x+1, x+6, ILess{3}, &X::i) );\n+  VERIFY( ranges::any_of(x, XLess{5}) );\n+  VERIFY( ranges::any_of(x, ILess{5}, &X::i) );\n+\n+  test_container<X, forward_iterator_wrapper> c(x);\n+  VERIFY( ranges::any_of(c, NotZero<int>{}, &X::i) );\n+\n+  test_range<X, input_iterator_wrapper> r(x);\n+  VERIFY( ranges::any_of(r, NotZero<int>{}, &X::i) );\n+  VERIFY( ranges::any_of(r, NotZero<X* const>{}, [](X& x) { return &x; }) );\n+}\n+\n+struct Y { int i; int j; };\n+\n+void\n+test02()\n+{\n+  static constexpr Y y[] = { {1,2}, {2,4}, {3,6} };\n+  static_assert(ranges::any_of(y, [](int i) { return i%2 == 0; }, &Y::i));\n+  static_assert(ranges::any_of(y, [](const Y& y) { return y.i + y.j == 3; }));\n+  static_assert(!ranges::any_of(y, [](const Y& y) { return y.i == y.j; }));\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "42aaa8ef2f7d70fe28cebe45059acf41f8275b87", "filename": "libstdc++-v3/testsuite/25_algorithms/binary_search/constrained.cc", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fbinary_search%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fbinary_search%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fbinary_search%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,61 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::forward_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+void\n+test01()\n+{\n+  float x[] = {1, 2, 3, 4, 5, 5, 6, 7};\n+  test_container<float, forward_iterator_wrapper> cx(x);\n+  for (int i = 0; i < 7; i++)\n+    {\n+      VERIFY( ranges::binary_search(cx, i, {}, [] (int a) { return a-1; }) );\n+      VERIFY( !ranges::binary_search(cx.begin(), cx.end(), i+0.5) );\n+    }\n+  VERIFY( !ranges::binary_search(cx, 0) );\n+\n+  ranges::reverse(x);\n+  test_range<float, forward_iterator_wrapper> rx(x);\n+  VERIFY( ranges::binary_search(rx, 5, ranges::greater{}) );\n+}\n+\n+constexpr bool\n+test02()\n+{\n+  int x[] = {1, 2, 3};\n+  return (ranges::binary_search(x, 3)\n+\t  && !ranges::binary_search(x, x, 3));\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  static_assert(test02());\n+}"}, {"sha": "85f7d649608f5c4ac42164a7c7c5100762d161b7", "filename": "libstdc++-v3/testsuite/25_algorithms/copy/constrained.cc", "status": "added", "additions": 225, "deletions": 0, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,225 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::input_iterator_wrapper;\n+using __gnu_test::output_iterator_wrapper;\n+using __gnu_test::forward_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+void\n+test01()\n+{\n+    {\n+      int x[7] = { 1, 2, 3, 4, 5, 6, 7 };\n+      int y[7] = { 0 };\n+      int z[7] = { 1, 2, 3, 4, 5, 6, 7 };\n+      auto [in, out] = ranges::copy(x, y);\n+      VERIFY( ranges::equal(x, y) && in == x+7 && out == y+7 );\n+      VERIFY( ranges::equal(x, z) );\n+    }\n+\n+    {\n+      int x[3] = { 1, 2, 3 };\n+      char y[4] = { 0 };\n+      int z[3] = { 1, 2, 3 };\n+      test_container<int, forward_iterator_wrapper> cx(x);\n+      test_container<char, forward_iterator_wrapper> cy(y);\n+      auto [in, out] = ranges::copy(cx, ranges::begin(cy));\n+      VERIFY( ranges::equal(x, x+3, y, y+3) && in.ptr == x+3 && out.ptr == y+3 );\n+      VERIFY( ranges::equal(x, z) );\n+    }\n+\n+    {\n+      char x[3] = { 1, 2, 3 };\n+      int y[4] = { 0 };\n+      int z[3] = { 1, 2, 3 };\n+      test_range<char, input_iterator_wrapper> rx(x);\n+      test_range<int, output_iterator_wrapper> ry(y);\n+      auto [in, out] = ranges::copy(rx, ranges::begin(ry));\n+      VERIFY( ranges::equal(x, x+3, y, y+3) && in.ptr == x+3 && out.ptr == y+3 );\n+      VERIFY( ranges::equal(x, z) );\n+    }\n+\n+    {\n+      std::vector<char> x = {1,2,3};\n+      std::vector<int> y(3);\n+      const int z[3] = { 1, 2, 3 };\n+      auto [in, out] = ranges::copy(x, ranges::begin(y));\n+      VERIFY( in.base() == x.data()+3 );\n+      VERIFY( out.base() == y.data()+3 );\n+      VERIFY( ranges::equal(y, z) && ranges::equal(x, z) );\n+    }\n+\n+\n+    {\n+      std::vector<int> x = {1,2,3};\n+      std::vector<int> y(3);\n+      const int z[3] = { 1, 2, 3 };\n+      auto [in, out] = ranges::copy(x, ranges::begin(y));\n+      VERIFY( in.base() == x.data()+3 );\n+      VERIFY( out.base() == y.data()+3 );\n+      VERIFY( ranges::equal(y, z) && ranges::equal(x, z) );\n+    }\n+\n+    {\n+      std::vector<int> x = {1,2,3};\n+      std::vector<int> y(3);\n+      const int z[3] = { 1, 2, 3 };\n+      auto [in,out] = ranges::copy(make_reverse_iterator(x.end()),\n+\t\t\t\t   make_reverse_iterator(x.begin()),\n+\t\t\t\t   make_reverse_iterator(y.end()));\n+      VERIFY( in.base().base() == x.data()+3 );\n+      VERIFY( out.base().base() == y.data() );\n+      VERIFY( ranges::equal(y, z) && ranges::equal(x, z) );\n+    }\n+\n+    {\n+      std::vector<char> x = {1,2,3};\n+      std::vector<int> y(3);\n+      const int z[3] = { 1, 2, 3 };\n+      auto [in,out] = ranges::copy(make_reverse_iterator(x.end()),\n+\t\t\t\t   make_reverse_iterator(x.begin()),\n+\t\t\t\t   make_reverse_iterator(y.end()));\n+      VERIFY( in.base().base() == x.data()+3 );\n+      VERIFY( out.base().base() == y.data() );\n+      VERIFY( ranges::equal(y, z) && ranges::equal(x, z) );\n+    }\n+}\n+\n+struct X\n+{\n+  int i;\n+  constexpr X (int a) : i(a) { }\n+};\n+\n+void\n+test02()\n+{\n+  int x[] = { {2}, {2}, {6}, {8}, {10} };\n+  X y[] = { {2}, {6}, {8}, {10}, {11}, {2} };\n+  int z[] = { {2}, {2}, {6}, {8}, {10} };\n+  auto [in, out] = ranges::copy(x, y);\n+  VERIFY( ranges::equal(x, x+5, y, y+5, {}, {}, &X::i) );\n+  VERIFY( in == x+5 );\n+  VERIFY( out == y+5 );\n+  VERIFY( y[5].i == 2 );\n+  VERIFY( ranges::equal(x, z) );\n+}\n+\n+constexpr bool\n+test03()\n+{\n+  bool ok = true;\n+  int x[] = { {2}, {2}, {6}, {8}, {10} };\n+  X y[] = { {2}, {6}, {8}, {10}, {11}, {2} };\n+  int z[] = { {2}, {2}, {6}, {8}, {10} };\n+  auto [in, out] = ranges::copy(x, y);\n+  ok &= ranges::equal(x, x+5, y, y+5, {}, {}, &X::i);\n+  ok &= (in == x+5);\n+  ok &= (out == y+5);\n+  ok &= (y[5].i == 2);\n+  ok &= ranges::equal(x, z);\n+  return ok;\n+}\n+\n+struct Y\n+{\n+  int i;\n+  int moved = 0;\n+\n+  constexpr Y(int a) : i(a) { }\n+\n+  constexpr Y(const Y&) = delete;\n+  constexpr Y& operator=(const Y&) = delete;\n+\n+  constexpr Y(Y&& other)\n+  {\n+    *this = std::move(other);\n+  }\n+\n+  constexpr Y&\n+  operator=(Y&& other)\n+  {\n+    other.moved++;\n+    i = other.i;\n+    return *this;\n+  }\n+\n+  friend constexpr bool\n+  operator==(const Y& a, const Y& b)\n+  { return a.i == b.i; }\n+};\n+\n+void\n+test04()\n+{\n+  Y x[7] = { 1, 2, 3, 4, 5, 6, 7 };\n+  Y y[7] = { 0, 0, 0, 0, 0, 0, 0 };\n+  Y z[7] = { 1, 2, 3, 4, 5, 6, 7 };\n+  test_range<Y, input_iterator_wrapper> rx(x);\n+  auto [in, out] = ranges::copy(std::move_iterator{ranges::begin(rx)},\n+\t\t\t\tstd::move_sentinel{ranges::end(rx)},\n+\t\t\t\tranges::begin(y));\n+  VERIFY( ranges::equal(x, y) && std::move(in).base().ptr == x+7 && out == y+7 );\n+  VERIFY( ranges::equal(x, z) );\n+  for (const auto& v : x)\n+    VERIFY( v.moved == 1 );\n+  for (const auto& v : y)\n+    VERIFY( v.moved == 0 );\n+}\n+\n+constexpr bool\n+test05()\n+{\n+  bool ok = true;\n+  Y x[7] = { 1, 2, 3, 4, 5, 6, 7 };\n+  Y y[7] = { 0, 0, 0, 0, 0, 0, 0 };\n+  Y z[7] = { 1, 2, 3, 4, 5, 6, 7 };\n+  auto [in, out] = ranges::copy(std::move_iterator{ranges::begin(x)},\n+\t\t\t\tstd::move_sentinel{ranges::end(x)},\n+\t\t\t\tranges::begin(y));\n+  ok &= ranges::equal(x, y);\n+  ok &= in.base() == x+7;\n+  ok &= out == y+7;\n+  ok &= ranges::equal(x, z);\n+  for (const auto& v : x)\n+    ok &= v.moved == 1;\n+  for (const auto& v : y)\n+    ok &= v.moved == 0;\n+  return ok;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  static_assert(test03());\n+  test04();\n+  static_assert(test05());\n+}"}, {"sha": "900f78aaa7383d89da6119efc185f2dbe9d84f5f", "filename": "libstdc++-v3/testsuite/25_algorithms/copy_backward/constrained.cc", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy_backward%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy_backward%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy_backward%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,193 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::bidirectional_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+void\n+test01()\n+{\n+    {\n+      int x[7] = { 1, 2, 3, 4, 5, 6, 7 };\n+      int y[7] = { 0 };\n+      int z[7] = { 1, 2, 3, 4, 5, 6, 7 };\n+      auto [in, out] = ranges::copy_backward(x, ranges::end(y));\n+      VERIFY( ranges::equal(x, y) && in == x+7 && out == y);\n+      VERIFY( ranges::equal(x, z) );\n+    }\n+\n+    {\n+      int x[3] = { 1, 2, 3 };\n+      char y[4] = { 0 };\n+      int z[3] = { 1, 2, 3 };\n+      test_container<int, bidirectional_iterator_wrapper> cx(x);\n+      test_container<char, bidirectional_iterator_wrapper> cy(y);\n+      auto [in, out] = ranges::copy_backward(cx, ranges::end(cy));\n+      VERIFY( ranges::equal(x, x+3, y+1, y+4) && in.ptr == x+3 && out.ptr == y+1 );\n+      VERIFY( ranges::equal(x, z) );\n+    }\n+\n+    {\n+      std::vector<char> x = {1,2,3};\n+      std::vector<int> y(3);\n+      const int z[3] = { 1, 2, 3 };\n+      auto [in, out] = ranges::copy_backward(x, ranges::end(y));\n+      VERIFY( in.base() == x.data()+3 );\n+      VERIFY( out.base() == y.data() );\n+      VERIFY( ranges::equal(y, z) && ranges::equal(x, z) );\n+    }\n+\n+\n+    {\n+      std::vector<int> x = {1,2,3};\n+      std::vector<int> y(3);\n+      const int z[3] = { 1, 2, 3 };\n+      auto [in, out] = ranges::copy_backward(x, ranges::end(y));\n+      VERIFY( in.base() == x.data()+3 );\n+      VERIFY( out.base() == y.data() );\n+      VERIFY( ranges::equal(y, z) && ranges::equal(x, z) );\n+    }\n+\n+    {\n+      std::vector<int> x = {1,2,3};\n+      std::vector<int> y(3);\n+      const int z[3] = { 1, 2, 3 };\n+      auto [in,out] = ranges::copy_backward(make_reverse_iterator(x.end()),\n+\t\t\t\t\t    make_reverse_iterator(x.begin()),\n+\t\t\t\t\t    make_reverse_iterator(y.begin()));\n+      VERIFY( in.base().base() == x.data()+3 );\n+      VERIFY( out.base().base() == y.data()+3 );\n+      VERIFY( ranges::equal(y, z) && ranges::equal(x, z) );\n+    }\n+\n+    {\n+      std::vector<char> x = {1,2,3};\n+      std::vector<int> y(3);\n+      const int z[3] = { 1, 2, 3 };\n+      auto [in,out] = ranges::copy_backward(make_reverse_iterator(x.end()),\n+\t\t\t\t\t    make_reverse_iterator(x.begin()),\n+\t\t\t\t\t    make_reverse_iterator(y.begin()));\n+      VERIFY( in.base().base() == x.data()+3 );\n+      VERIFY( out.base().base() == y.data()+3 );\n+      VERIFY( ranges::equal(y, z) && ranges::equal(x, z) );\n+    }\n+}\n+\n+constexpr bool\n+test02()\n+{\n+  bool ok = true;\n+  int x[] = { {2}, {2}, {6}, {8}, {10} };\n+  int y[] = { {2}, {6}, {8}, {10}, {11}, {2} };\n+  const int z[] = { {2}, {2}, {6}, {8}, {10} };\n+  auto [in, out] = ranges::copy_backward(x, ranges::end(y));\n+  ok &= ranges::equal(x, x+5, y+1, y+6);\n+  ok &= (in == x+5);\n+  ok &= (out == y+1);\n+  ok &= (y[0] == 2);\n+  ok &= ranges::equal(x, z);\n+  return ok;\n+}\n+\n+/*  move_iterators are always input_iterators and therefore do not model\n+ *  bidirectional_iterator, so I think the following tests are rightly invalid.\n+\n+struct Y\n+{\n+  int i;\n+  int moved = 0;\n+\n+  constexpr Y(int a) : i(a) { }\n+\n+  constexpr Y(const Y&) = delete;\n+  constexpr Y& operator=(const Y&) = delete;\n+\n+  constexpr Y(Y&& other)\n+  {\n+    *this = std::move(other);\n+  }\n+\n+  constexpr Y&\n+  operator=(Y&& other)\n+  {\n+    other.moved++;\n+    i = other.i;\n+    return *this;\n+  }\n+\n+  friend constexpr bool\n+  operator==(const Y& a, const Y& b)\n+  { return a.i == b.i; }\n+};\n+\n+void\n+test02()\n+{\n+  Y x[7] = { 1, 2, 3, 4, 5, 6, 7 };\n+  Y y[7] = { 0, 0, 0, 0, 0, 0, 0 };\n+  Y z[7] = { 1, 2, 3, 4, 5, 6, 7 };\n+  test_range<Y, bidirectional_iterator_wrapper> rx(x);\n+  auto [in, out] = ranges::copy_backward(std::move_iterator{ranges::begin(rx)},\n+\t\t\t\t\t std::move_sentinel{ranges::end(rx)},\n+\t\t\t\t\t ranges::end(y));\n+  VERIFY( ranges::equal(x, y) && std::move(in).base().ptr == x+7 && out == y );\n+  VERIFY( ranges::equal(x, z) );\n+  for (const auto& v : x)\n+    VERIFY( v.moved == 1 );\n+  for (const auto& v : y)\n+    VERIFY( v.moved == 0 );\n+}\n+\n+constexpr bool\n+test03()\n+{\n+  bool ok = true;\n+  Y x[7] = { 1, 2, 3, 4, 5, 6, 7 };\n+  Y y[7] = { 0, 0, 0, 0, 0, 0, 0 };\n+  Y z[7] = { 1, 2, 3, 4, 5, 6, 7 };\n+  auto [in, out] = ranges::copy_backward(std::move_iterator{ranges::begin(x)},\n+\t\t\t\t\t std::move_sentinel{ranges::end(x)},\n+\t\t\t\t\t ranges::end(y));\n+  ok &= ranges::equal(x, y);\n+  ok &= in.base() == x+7;\n+  ok &= out == y;\n+  ok &= ranges::equal(x, z);\n+  for (const auto& v : x)\n+    ok &= v.moved == 1;\n+  for (const auto& v : y)\n+    ok &= v.moved == 0;\n+  return ok;\n+}\n+*/\n+\n+int\n+main()\n+{\n+  test01();\n+  static_assert(test02());\n+}"}, {"sha": "8a92d227f164358be148c7167fa9c6c8a164ea02", "filename": "libstdc++-v3/testsuite/25_algorithms/copy_if/constrained.cc", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy_if%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy_if%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy_if%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,77 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::input_iterator_wrapper;\n+using __gnu_test::output_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+void\n+test01()\n+{\n+  int x[] = {1,2,3,4,5,6,7};\n+\n+    {\n+      const int y[] = {2,4,6};\n+      int w[7];\n+      test_range<int, input_iterator_wrapper> rx(x);\n+      test_range<int, output_iterator_wrapper> rw(w);\n+      auto [in,out] = ranges::copy_if(rx, rw.begin(),\n+\t\t\t\t      [] (int a) { return (a%2)==0; });\n+      VERIFY( in == rx.end() && out.ptr == w+3 );\n+      VERIFY( ranges::equal(w, w+3, y, y+3) );\n+    }\n+\n+    {\n+      const int y[] = {1,3,5,7};\n+      int w[7];\n+      test_range<int, input_iterator_wrapper> rx(x);\n+      test_range<int, output_iterator_wrapper> rw(w);\n+      auto [in,out] = ranges::copy_if(rx, rw.begin(),\n+\t\t\t\t      [] (int a) { return (a%2)==0; },\n+\t\t\t\t      [] (int a) { return a+1; });\n+      VERIFY( in == rx.end() && out.ptr == w+4 );\n+      VERIFY( ranges::equal(w, w+4, y, y+4) );\n+    }\n+}\n+\n+constexpr bool\n+test02()\n+{\n+  int x[] = {1,2,3};\n+  const int y[] = {1,3};\n+  int w[3];\n+  auto [in,out] = ranges::copy_if(x, w, [] (int a) { return (a%2)==1; });\n+  return ranges::equal(w, out, y, y+2);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  static_assert(test02());\n+}"}, {"sha": "78a4539826a59dfb90145f5e471b4469b9ab5ad4", "filename": "libstdc++-v3/testsuite/25_algorithms/copy_n/constrained.cc", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy_n%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy_n%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy_n%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,72 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::input_iterator_wrapper;\n+using __gnu_test::output_iterator_wrapper;\n+using __gnu_test::random_access_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+template<template<typename> typename in_wrapper,\n+\t template<typename> typename out_wrapper>\n+void\n+test01()\n+{\n+  int x[] = {1,2,3,4,5,6,7};\n+  for (int i = -1; i <= 7; i++)\n+    {\n+      test_range<int, in_wrapper> rx(x);\n+      int w[7];\n+      test_range<int, out_wrapper> rw(w);\n+      ranges::copy_n(rx.begin(), i, rw.begin());\n+      if (i >= 0)\n+\tVERIFY( ranges::equal(x, x+i, w, w+i) );\n+    }\n+}\n+\n+constexpr bool\n+test02()\n+{\n+  int x[] = {1,2,3};\n+  int y[2];\n+  auto [in,out] = ranges::copy_n(x, 2, y);\n+  return (in == x+2\n+\t  && out == y+2\n+\t  && ranges::equal(x, x+2, y, y+2));\n+}\n+\n+int\n+main()\n+{\n+  test01<input_iterator_wrapper,\n+\t output_iterator_wrapper>();\n+  test01<random_access_iterator_wrapper,\n+\t output_iterator_wrapper>();\n+  test01<random_access_iterator_wrapper,\n+\t random_access_iterator_wrapper>();\n+  static_assert(test02());\n+}"}, {"sha": "2a9bb27de5e53c3df799d4e3c6240761d3175f88", "filename": "libstdc++-v3/testsuite/25_algorithms/count/constrained.cc", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcount%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcount%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcount%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,75 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::input_iterator_wrapper;\n+using __gnu_test::forward_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+struct X { int i; };\n+\n+void\n+test01()\n+{\n+  X x[] = { {2}, {2}, {6}, {8}, {10}, {11}, {2} };\n+  auto res = ranges::count(x, x+7, 2, &X::i);\n+  VERIFY( res == 3 );\n+  res = ranges::count(x, x+7, 8, &X::i);\n+  VERIFY( res == 1 );\n+  res = ranges::count(x, x+7, 9, &X::i);\n+  VERIFY( res == 0 );\n+\n+  test_container<X, forward_iterator_wrapper> c(x);\n+  res = ranges::count(c, 6, &X::i);\n+  VERIFY( res == 1 );\n+  res = ranges::count(c, 9, &X::i);\n+  VERIFY( res == 0 );\n+\n+  test_range<X, input_iterator_wrapper> r(x);\n+  res = ranges::count(r, 2, &X::i);\n+  VERIFY( res == 3 );\n+\n+  r.bounds.first = x;\n+  res = ranges::count(r, 9, &X::i);\n+  VERIFY( res == 0 );\n+}\n+\n+struct Y { int i; int j; };\n+\n+void\n+test02()\n+{\n+  static constexpr Y y[] = { {1,2}, {2,4}, {3,6}, {1,6} };\n+  static_assert(ranges::count(y, 6, &Y::j) == 2);\n+  static_assert(ranges::count(y, 5, &Y::j) == 0);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "79cdae31826e3e97e0f845175e0864ed408bf6a8", "filename": "libstdc++-v3/testsuite/25_algorithms/count_if/constrained.cc", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcount_if%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcount_if%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcount_if%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,73 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::input_iterator_wrapper;\n+using __gnu_test::forward_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+struct X { int i; };\n+\n+void\n+test01()\n+{\n+  X x[] = { {2}, {2}, {6}, {8}, {10}, {11}, {2} };\n+  auto res = ranges::count_if(x, x+7, [] (int i) { return i % 2 == 0; }, &X::i);\n+  VERIFY( res == 6 );\n+  res = ranges::count_if(x, x+7, [] (int i) { return i % 2 == 1; }, &X::i);\n+  VERIFY( res == 1 );\n+  res = ranges::count_if(x, x+7, [] (int i) { return i < 0; }, &X::i);\n+  VERIFY( res == 0 );\n+\n+  test_container<X, forward_iterator_wrapper> c(x);\n+  res = ranges::count_if(c, [] (int i) { return i == 2; }, &X::i);\n+  VERIFY( res == 3 );\n+  res = ranges::count_if(c, [] (int i) { return i < 0; }, &X::i);\n+  VERIFY( res == 0 );\n+\n+  test_range<X, input_iterator_wrapper> r(x);\n+  res = ranges::count_if(c, [] (int i) { return i == 2; }, &X::i);\n+  VERIFY( res == 3 );\n+  res = ranges::count_if(c, [] (int i) { return i < 0; }, &X::i);\n+  VERIFY( res == 0 );\n+}\n+\n+struct Y { int i; int j; };\n+\n+void\n+test02()\n+{\n+  static constexpr Y y[] = { {1,2}, {2,4}, {3,6}, {1,6} };\n+  static_assert(ranges::count_if(y, [] (int i) { return i < 5; }, &Y::j) == 2);\n+  static_assert(ranges::count_if(y, [] (int i) { return i != 4; }, &Y::j) == 3);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "231bd8cfeaa7d38421b15b1ce44f9a9c79bc86ac", "filename": "libstdc++-v3/testsuite/25_algorithms/equal/constrained.cc", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fequal%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fequal%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fequal%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,96 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::input_iterator_wrapper;\n+using __gnu_test::forward_iterator_wrapper;\n+using __gnu_test::bidirectional_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+struct X { int i; };\n+\n+void\n+test01()\n+{\n+  int x[] = { {2}, {2}, {6}, {8}, {10}, {11}, {11} };\n+  int y[] = { {2}, {2}, {6}, {8}, {10}, {11}, {11} };\n+  X   z[] = { {2}, {6}, {8}, {10}, {2}, {2} };\n+  int w[] = { {1}, {1}, {1}, {1}, {1} };\n+\n+  VERIFY( ranges::equal(w, w+4, w+1, w+5) );\n+  VERIFY( ranges::equal(w, w+5, w, w+5, ranges::greater{},\n+\t\t\t[] (int a) { return a+1; }) );\n+\n+  test_container<int, forward_iterator_wrapper> cx(x), cy(y);\n+  test_container<X, forward_iterator_wrapper> cz(z);\n+  VERIFY( ranges::equal(cx, cy) );\n+  VERIFY( !ranges::equal(cx, cy, {}, [] (int a) { return a+1; }) );\n+  VERIFY( !ranges::equal(cx, cz, {}, {}, &X::i) );\n+\n+  test_range<int, input_iterator_wrapper> rx(x), ry(y);\n+  test_range<X, input_iterator_wrapper> rz(z);\n+  VERIFY( ranges::equal(rx, ry) );\n+\n+  rx.bounds.first = x;\n+  ry.bounds.first = y;\n+  VERIFY( !ranges::equal(rx, ry, {}, {}, [] (int a) { return a+1; }) );\n+\n+  rx.bounds.first = x;\n+  rz.bounds.first = z;\n+  VERIFY( !ranges::equal(rx, rz, {}, {}, &X::i) );\n+}\n+\n+void\n+test02()\n+{\n+  static constexpr X x[] = { {2}, {2}, {6}, {8}, {10}, {11} };\n+  static constexpr X y[] = { {2}, {6}, {8}, {10}, {11}, {2} };\n+  static constexpr int z[] = { {2}, {6}, {8}, {10}, {2}, {2} };\n+  static constexpr int w[] = { {2}, {6}, {8}, {10}, {2}, {2} };\n+\n+  static_assert(ranges::equal(z, w));\n+  static_assert(!ranges::equal(z, z+5, w+1, w+6));\n+  static_assert(!ranges::equal(z, z, {}, {}, [] (int a) { return a+1; }));\n+  static_assert(!ranges::equal(x, y, {}, &X::i, &X::i));\n+}\n+\n+void\n+test03()\n+{\n+  std::vector<int> x = { {2}, {2}, {6}, {8}, {10}, {11} };\n+  std::vector<int> y = { {2}, {2}, {6}, {8}, {10}, {11} };\n+  std::vector<int> z = { {2}, {2}, {6}, {8}, {10}, {12} };\n+  VERIFY( ranges::equal(x, y) );\n+  VERIFY( !ranges::equal(x, z) );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+}"}, {"sha": "4ddf4590c21bb7283971c067c9d2ba7332322a11", "filename": "libstdc++-v3/testsuite/25_algorithms/equal_range/constrained.cc", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fequal_range%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fequal_range%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fequal_range%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,69 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::forward_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+void\n+test01()\n+{\n+  int x[] = {1, 2, 3, 4, 5, 5, 6, 7};\n+  for (unsigned i = 0; i < 5; i++)\n+    for (unsigned j = 6; j < 8; j++)\n+      {\n+\ttest_container<int, forward_iterator_wrapper> cx(x);\n+\tauto range = ranges::equal_range(std::next(cx.begin(), i),\n+\t\t\t\t\t std::next(cx.begin(), j),\n+\t\t\t\t\t 4, {}, [] (int a) { return a-1; });\n+\tVERIFY( range.begin().ptr == x+4 && range.end().ptr == x+6 );\n+      }\n+\n+  ranges::reverse(x);\n+  test_range<int, forward_iterator_wrapper> rx(x);\n+  auto range = ranges::equal_range(rx, 5, ranges::greater{},\n+\t\t\t\t   [] (int a) { return a+1; });\n+  VERIFY( range.begin().ptr == x+4 && range.end().ptr == x+5 );\n+}\n+\n+constexpr bool\n+test02()\n+{\n+  int x[] = {1, 2, 3, 4, 5};\n+  auto range1 = ranges::equal_range(x, 6);\n+  auto range2 = ranges::equal_range(x, x, 6);\n+  auto range3 = ranges::equal_range(x, 1);\n+  return (range1.begin() == x+5 && range1.end() == x+5\n+\t  && range2.begin() == x && range2.end() == x\n+\t  && range3.begin() == x && range3.end() == x+1);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  static_assert(test02());\n+}"}, {"sha": "4813b8302ce50a691993e8fe46a882a6f01d635b", "filename": "libstdc++-v3/testsuite/25_algorithms/fill/constrained.cc", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffill%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffill%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffill%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,92 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+#include <list>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::input_iterator_wrapper;\n+using __gnu_test::output_iterator_wrapper;\n+using __gnu_test::forward_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+struct X\n+{\n+  int i;\n+};\n+\n+void\n+test01()\n+{\n+  const int c[6] = { 17, 17, 17, 17, 17, 17 };\n+    {\n+      X x[6];\n+      VERIFY( ranges::fill(x, X{17}) == x+6 );\n+      VERIFY( ranges::equal(x, c, {}, &X::i) );\n+    }\n+\n+    {\n+      char x[6];\n+      VERIFY( ranges::fill(x, 17) == x+6 );\n+      VERIFY( ranges::equal(x, c) );\n+    }\n+\n+    {\n+      X x[6];\n+      test_container<X, forward_iterator_wrapper> cx(x);\n+      VERIFY( ranges::fill(cx, X{17}) == cx.end() );\n+      VERIFY( ranges::equal(cx, c, {}, &X::i) );\n+    }\n+\n+    {\n+      int x[6];\n+      test_range<int, output_iterator_wrapper> rx(x);\n+      VERIFY( ranges::fill(rx, 17) == rx.end() );\n+      VERIFY( ranges::equal(x, c) );\n+    }\n+\n+    {\n+      std::list<int> list(6);\n+      ranges::fill(list, 17);\n+      VERIFY( ranges::equal(list, c) );\n+    }\n+}\n+\n+constexpr bool\n+test02()\n+{\n+  bool ok = true;\n+  int x[5];\n+  ranges::fill(x, 17);\n+  for (auto v : x)\n+    ok &= v == 17;\n+  return ok;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  static_assert(test02());\n+}"}, {"sha": "e9ce8e8fb0aed9ce2aac054cc480b025acc94cd7", "filename": "libstdc++-v3/testsuite/25_algorithms/fill_n/constrained.cc", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffill_n%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffill_n%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffill_n%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,98 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+#include <list>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::input_iterator_wrapper;\n+using __gnu_test::output_iterator_wrapper;\n+using __gnu_test::forward_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+struct X\n+{\n+  int i;\n+};\n+\n+void\n+test01()\n+{\n+  const int c[6] = { 17, 17, 17, 4, 5, 6 };\n+    {\n+      X x[6] = { {1}, {2}, {3}, {4}, {5}, {6} };\n+      VERIFY( ranges::fill_n(x, 3, X{17}) == x+3 );\n+      VERIFY( ranges::equal(x, c, {}, &X::i) );\n+    }\n+\n+    {\n+      char x[6];\n+      VERIFY( ranges::fill_n(x, 3, 17) == x+3 );\n+      VERIFY( ranges::equal(x, x+3, c, c+3) );\n+    }\n+\n+    {\n+      X x[6] = { 1, 2, 3, 4, 5, 6 };\n+      test_container<X, forward_iterator_wrapper> cx(x);\n+      VERIFY( ranges::fill_n(cx.begin(), 3, X{17})->i == 4 );\n+      VERIFY( ranges::equal(cx, c, {}, &X::i) );\n+    }\n+\n+    {\n+      int x[6] = { 1, 2, 3, 4, 5, 6 };;\n+      test_range<int, output_iterator_wrapper> rx(x);\n+      ranges::fill_n(ranges::begin(rx), 3, 17);\n+      VERIFY( ranges::equal(x, c) );\n+    }\n+\n+    {\n+      std::list<int> list({1, 2, 3, 4, 5, 6});\n+      ranges::fill_n(list.begin(), 3, 17);\n+      VERIFY( ranges::equal(list, c) );\n+    }\n+}\n+\n+constexpr bool\n+test02()\n+{\n+  bool ok = true;\n+  int x[6] = { 1, 2, 3, 4, 5, 6 };\n+  const int y[6] = { 1, 2, 3, 4, 5, 6 };\n+  const int z[6] = { 17, 17, 17, 4, 5, 6 };\n+\n+  ranges::fill_n(x, 0, 17);\n+  ranges::fill_n(x, -1, 17);\n+  ok &= ranges::equal(x, y);\n+\n+  ranges::fill_n(x, 3, 17);\n+  ok &= ranges::equal(x, z);\n+  return ok;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  static_assert(test02());\n+}"}, {"sha": "6f6b9547e67d091d1496d15eb71c2b150a81a44b", "filename": "libstdc++-v3/testsuite/25_algorithms/find/constrained.cc", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffind%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffind%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffind%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,75 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::input_iterator_wrapper;\n+using __gnu_test::forward_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+struct X { int i; };\n+\n+void\n+test01()\n+{\n+  X x[] = { {2}, {2}, {6}, {8}, {10}, {11} };\n+  auto res = ranges::find(x, x+6, 8, &X::i);\n+  VERIFY( res == x+3 );\n+  res = ranges::find(x, x+6, 2, &X::i);\n+  VERIFY( res == x+0 );\n+  res = ranges::find(x, x+6, 9, &X::i);\n+  VERIFY( res == x+6 );\n+\n+  test_container<X, forward_iterator_wrapper> c(x);\n+  auto res2 = ranges::find(c, 8, &X::i);\n+  VERIFY( res2 != ranges::end(c) && res2->i == 8 );\n+  res2 = ranges::find(c, 9, &X::i);\n+  VERIFY( res2 == ranges::end(c) );\n+\n+  test_range<X, input_iterator_wrapper> r(x);\n+  auto res3 = ranges::find(r, 8, &X::i);\n+  VERIFY( res3 != ranges::end(r) && res3->i == 8 );\n+\n+  r.bounds.first = x;\n+  res3 = ranges::find(r, 9, &X::i);\n+  VERIFY( res3 == ranges::end(r) );\n+}\n+\n+struct Y { int i; int j; };\n+\n+void\n+test02()\n+{\n+  static constexpr Y y[] = { {1,2}, {2,4}, {3,6} };\n+  static_assert(ranges::find(y, 4, &Y::j) == y+1);\n+  static_assert(ranges::find(y, 5, &Y::j) == y+3);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "b51e4a734fbcc1f6d29624cce23d098a2aca30e2", "filename": "libstdc++-v3/testsuite/25_algorithms/find_end/constrained.cc", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffind_end%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffind_end%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffind_end%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,98 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::input_iterator_wrapper;\n+using __gnu_test::forward_iterator_wrapper;\n+using __gnu_test::bidirectional_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+struct X { int i; };\n+\n+void\n+test01()\n+{\n+  X x[] = { {10}, {11}, {2}, {6}, {8}, {10}, {11} };\n+  X y[] = { {10}, {11} };\n+  {\n+\n+    test_container<X, forward_iterator_wrapper> c(x);\n+    auto res = ranges::find_end(c, y, {}, &X::i, &X::i);\n+    VERIFY( std::get<0>(res)->i == 10 && std::get<1>(res) == ranges::end(c) );\n+    res = ranges::find_end(c, c, {}, &X::i, &X::i);\n+    VERIFY( std::get<0>(res) == ranges::begin(c)\n+\t    && std::get<1>(res) == ranges::end(c) );\n+  }\n+\n+  {\n+    test_range<X, forward_iterator_wrapper> r(x);\n+    auto res = ranges::find_end(r, y, {}, &X::i, &X::i);\n+    VERIFY( std::get<0>(res)->i == 10 && std::get<1>(res) == ranges::end(r) );\n+    res = ranges::find_end(r, r, {}, &X::i, &X::i);\n+    VERIFY( std::get<0>(res) == ranges::begin(r)\n+\t    && std::get<1>(res) == ranges::end(r) );\n+  }\n+\n+  {\n+    test_range<X, bidirectional_iterator_wrapper> r(x);\n+    auto res = ranges::find_end(r, y, {}, &X::i, &X::i);\n+    VERIFY( std::get<0>(res)->i == 10 && std::get<1>(res) == ranges::end(r) );\n+    res = ranges::find_end(r, r, {}, &X::i, &X::i);\n+    VERIFY( std::get<0>(res) == ranges::begin(r)\n+\t    && std::get<1>(res) == ranges::end(r) );\n+  }\n+}\n+\n+void\n+test02()\n+{\n+  static constexpr X x[] = { {2}, {2}, {6}, {8}, {10}, {6}, {8}, {11} };\n+  static constexpr X y[] = { {6}, {8} };\n+  static constexpr int z[] = { 2, 8 };\n+  static constexpr int w[] = { 2 };\n+\n+  static_assert(std::get<0>(ranges::find_end(x, y, {}, &X::i, &X::i)) == x+5);\n+  static_assert(std::get<1>(ranges::find_end(x, y, {}, &X::i, &X::i)) == x+7);\n+\n+  static_assert(std::get<0>(ranges::find_end(x, z, {}, &X::i)) == x+8);\n+  static_assert(std::get<1>(ranges::find_end(x, z, {}, &X::i)) == x+8);\n+\n+  static_assert(std::get<0>(ranges::find_end(x, w, {}, &X::i)) == x+1);\n+  static_assert(std::get<1>(ranges::find_end(x, w, {}, &X::i)) == x+2);\n+\n+  static_assert(std::get<0>(ranges::find_end(x, x+6, w, w, {}, &X::i)) == x+6);\n+  static_assert(std::get<1>(ranges::find_end(x, x+6, w, w, {}, &X::i)) == x+6);\n+\n+  static_assert(std::get<0>(ranges::find_end(x, x, w, w+1, {}, &X::i)) == x+0);\n+  static_assert(std::get<1>(ranges::find_end(x, x, w, w+1, {}, &X::i)) == x+0);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "81a15761fa083d2a4a415bb450f6f49086da3b11", "filename": "libstdc++-v3/testsuite/25_algorithms/find_first_of/constrained.cc", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffind_first_of%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffind_first_of%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffind_first_of%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,83 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::input_iterator_wrapper;\n+using __gnu_test::forward_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+struct X { int i; };\n+\n+void\n+test01()\n+{\n+  X x[] = { {2}, {2}, {6}, {8}, {10}, {11} };\n+  int y[] = { 2, 7, 8, 9 };\n+  X w[] = { {2}, {7}, {8}, {9} };\n+\n+  auto res = ranges::find_first_of(x, x+6, y+1, y+4, {}, &X::i);\n+  VERIFY( res == x+3 );\n+  res = ranges::find_first_of(x, x+6, w, w+4, {}, &X::i, &X::i);\n+  VERIFY( res == x+0 );\n+  res = ranges::find_first_of(x, x+6, y+3, y+4, {}, &X::i);\n+  VERIFY( res == x+6 );\n+\n+  test_container<X, forward_iterator_wrapper> c(x);\n+  test_container<int, forward_iterator_wrapper> d1(y+1, y+4);\n+  auto res2 = ranges::find_first_of(c, d1, {}, &X::i);\n+  VERIFY( res2 != ranges::end(c) && res2->i == 8 );\n+\n+  test_container<X, forward_iterator_wrapper> d2(w+3, w+4);\n+  res2 = ranges::find_first_of(c, d2, {}, &X::i, &X::i);\n+  VERIFY( res2 == ranges::end(c) );\n+\n+  test_range<X, input_iterator_wrapper> r(x);\n+  test_range<int, forward_iterator_wrapper> s1(y+1, y+4);\n+  auto res3 = ranges::find_first_of(r, s1, {}, &X::i);\n+  VERIFY( res3 != ranges::end(r) && res3->i == 8 );\n+\n+  test_range<X, forward_iterator_wrapper> s2(w+3, w+4);\n+  r.bounds.first = x;\n+  res3 = ranges::find_first_of(r, s2, {}, &X::i, &X::i);\n+  VERIFY( res3 == ranges::end(r) );\n+}\n+\n+struct Y { int i; int j; };\n+\n+void\n+test02()\n+{\n+  static constexpr Y y[] = { {1,2}, {2,4}, {3,6} };\n+  static_assert(ranges::find_first_of(y, y, {}, &Y::j, &Y::i) == y);\n+  static_assert(ranges::find_first_of(y, y, {}, &Y::i, &Y::j) == y+1);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "299bdd0fceb7ff14552492824f1630ee201b066f", "filename": "libstdc++-v3/testsuite/25_algorithms/find_if/constrained.cc", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffind_if%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffind_if%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffind_if%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,77 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::input_iterator_wrapper;\n+using __gnu_test::forward_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+struct X { int i; };\n+\n+void\n+test01()\n+{\n+  X x[] = { {2}, {2}, {6}, {8}, {10}, {11} };\n+  auto res = ranges::find_if(x, x+6, [] (X& v) { return v.i == 8; });\n+  VERIFY( res == x+3 );\n+  res = ranges::find_if(x, x+6, [] (X& v) { return v.i % 2 == 0; });\n+  VERIFY( res == x+0 );\n+  res = ranges::find_if(x, x+6, [] (X& v) { return v.i == 9; });\n+  VERIFY( res == x+6 );\n+\n+  test_container<X, forward_iterator_wrapper> c(x);\n+  auto res2 = ranges::find_if(c, [] (int i) { return i > 7; }, &X::i);\n+  VERIFY( res2 != ranges::end(c) && res2->i == 8 );\n+  res2 = ranges::find_if(c, [] (int i) { return i > 11; }, &X::i);\n+  VERIFY( res2 == ranges::end(c) );\n+\n+  test_range<X, input_iterator_wrapper> r(x);\n+  auto res3 = ranges::find_if(r, [] (int i) { return i > 10; }, &X::i);\n+  VERIFY( res3 != ranges::end(r) && res3->i == 11 );\n+\n+  r.bounds.first = x;\n+  res3 = ranges::find_if(r, [] (int i) { return i == 9; }, &X::i);\n+  VERIFY( res3 == ranges::end(r) );\n+}\n+\n+struct Y { int i; int j; };\n+\n+void\n+test02()\n+{\n+  static constexpr Y y[] = { {1,2}, {2,4}, {3,6} };\n+  static_assert(ranges::find_if(y, [] (int i) { return i > 3; }, &Y::j)\n+\t\t== y+1);\n+  static_assert(ranges::find_if(y, [] (int i) { return i == 5; }, &Y::j)\n+\t\t== y+3);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "838434aa7e07a3f7492bd6ac60b87bddf2a3b6a8", "filename": "libstdc++-v3/testsuite/25_algorithms/find_if_not/constrained.cc", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffind_if_not%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffind_if_not%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffind_if_not%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,77 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::input_iterator_wrapper;\n+using __gnu_test::forward_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+struct X { int i; };\n+\n+void\n+test01()\n+{\n+  X x[] = { {2}, {2}, {6}, {8}, {10}, {11} };\n+  auto res = ranges::find_if_not(x, x+6, [] (X& v) { return v.i != 8; });\n+  VERIFY( res == x+3 );\n+  res = ranges::find_if_not(x, x+6, [] (X& v) { return v.i % 2 == 1; });\n+  VERIFY( res == x+0 );\n+  res = ranges::find_if_not(x, x+6, [] (X& v) { return v.i != 9; });\n+  VERIFY( res == x+6 );\n+\n+  test_container<X, forward_iterator_wrapper> c(x);\n+  auto res2 = ranges::find_if_not(c, [] (int i) { return i <= 7; }, &X::i);\n+  VERIFY( res2 != ranges::end(c) && res2->i == 8 );\n+  res2 = ranges::find_if_not(c, [] (int i) { return i <= 11; }, &X::i);\n+  VERIFY( res2 == ranges::end(c) );\n+\n+  test_range<X, input_iterator_wrapper> r(x);\n+  auto res3 = ranges::find_if_not(r, [] (int i) { return i <= 10; }, &X::i);\n+  VERIFY( res3 != ranges::end(r) && res3->i == 11 );\n+\n+  r.bounds.first = x;\n+  res3 = ranges::find_if_not(r, [] (int i) { return i != 9; }, &X::i);\n+  VERIFY( res3 == ranges::end(r) );\n+}\n+\n+struct Y { int i; int j; };\n+\n+void\n+test02()\n+{\n+  static constexpr Y y[] = { {1,2}, {2,4}, {3,6} };\n+  static_assert(ranges::find_if_not(y, [] (int i) { return i <= 3; }, &Y::j)\n+\t\t== y+1);\n+  static_assert(ranges::find_if_not(y, [] (int i) { return i != 5; }, &Y::j)\n+\t\t== y+3);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "142ad2e57da90a6d0b40149490248319591ec135", "filename": "libstdc++-v3/testsuite/25_algorithms/for_each/constrained.cc", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffor_each%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffor_each%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffor_each%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,83 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::input_iterator_wrapper;\n+using __gnu_test::forward_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+struct X { int i; };\n+\n+static int a;\n+\n+void\n+f(int& i)\n+{\n+  a += i;\n+}\n+\n+void\n+test01()\n+{\n+  X x[] = { {2}, {4}, {6}, {8}, {10}, {11} };\n+\n+  auto res = ranges::for_each(x, x+6, f, &X::i);\n+  VERIFY( res.in == x+6 );\n+  VERIFY( res.fun == &f );\n+  VERIFY( a == 41 );\n+\n+  test_container<X, forward_iterator_wrapper> c(x);\n+  int p = 0;\n+  ranges::for_each(c, [&p](int i) { ++p; }, &X::i);\n+  VERIFY( p == 6 );\n+\n+  test_range<X, input_iterator_wrapper> r(x);\n+  int q = 0;\n+  ranges::for_each(r, [&q](X&) { ++q; });\n+  VERIFY( q == 6 );\n+}\n+\n+struct Y { int i; int j; };\n+\n+void\n+test02()\n+{\n+  auto f = []\n+  {\n+    Y y[] = { {1,2}, {2,4}, {3,6} };\n+    int a = 0;\n+    ranges::for_each(y, [&a](int i) { a += i; }, &Y::i);\n+    return a;\n+  };\n+  static_assert(f() == 6);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "71bcbaa616deb32f147aea8d3cdf53b3a5eb295e", "filename": "libstdc++-v3/testsuite/25_algorithms/generate/constrained.cc", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fgenerate%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fgenerate%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fgenerate%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,77 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::input_iterator_wrapper;\n+using __gnu_test::output_iterator_wrapper;\n+using __gnu_test::forward_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+void\n+test01()\n+{\n+  const int c[6] = { 1, 2, 3, 4, 5, 6 };\n+\n+    {\n+      int x[6];\n+      int a = 1;\n+      VERIFY( ranges::generate(x, [&] { return a++; }) == x+6 );\n+      VERIFY( ranges::equal(x, c) );\n+    }\n+\n+    {\n+      int x[6];\n+      int a = 1;\n+      test_container<int, forward_iterator_wrapper> cx(x);\n+      VERIFY( ranges::generate(cx, [&] { return a++; }) == cx.end() );\n+      VERIFY( ranges::equal(cx, c) );\n+    }\n+\n+    {\n+      int x[6];\n+      int a = 1;\n+      test_range<int, output_iterator_wrapper> rx(x);\n+      VERIFY( ranges::generate(rx, [&] { return a++; }) == rx.end() );\n+      VERIFY( ranges::equal(x, c) );\n+    }\n+}\n+\n+constexpr bool\n+test02()\n+{\n+  const int c[6] = { 1, 2, 3, 4, 5, 6 };\n+  int x[6];\n+  int a = 1;\n+  ranges::generate(x, [&] { return a++; });\n+  return ranges::equal(x, c);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  static_assert(test02());\n+}"}, {"sha": "ff894addeccb8a6050fd25d55e04157eaeb0ea74", "filename": "libstdc++-v3/testsuite/25_algorithms/generate_n/constrained.cc", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fgenerate_n%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fgenerate_n%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fgenerate_n%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,84 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::input_iterator_wrapper;\n+using __gnu_test::output_iterator_wrapper;\n+using __gnu_test::forward_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+void\n+test01()\n+{\n+  const int c[6] = { 1, 2, 3, 4, 5, 6 };\n+\n+    {\n+      int x[6] = { 7, 8, 9, 4, 5, 6 };\n+      int a = 1;\n+      VERIFY( ranges::generate_n(x, 3, [&] { return a++; }) == x+3 );\n+      VERIFY( ranges::equal(x, c) );\n+    }\n+\n+    {\n+      int x[6] = { 7, 8, 9, 4, 5, 6 };\n+      int a = 1;\n+      test_container<int, forward_iterator_wrapper> cx(x);\n+      VERIFY( *ranges::generate_n(cx.begin(), 3, [&] { return a++; })\n+\t       == 4 );\n+      VERIFY( ranges::equal(cx, c) );\n+    }\n+\n+    {\n+      int x[6] = { 7, 8, 9, 4, 5, 6 };\n+      int a = 1;\n+      test_range<int, output_iterator_wrapper> rx(x);\n+      ranges::generate_n(ranges::begin(rx), 3, [&] { return a++; });\n+      VERIFY( ranges::equal(x, c) );\n+    }\n+}\n+\n+constexpr bool\n+test02()\n+{\n+  bool ok = true;\n+  int c[6] = { 1, 2, 3, 4, 5, 6 };\n+  int x[6];\n+  int a = 1;\n+  ranges::generate_n(x, 6, [&] { return a++; });\n+  ok &= ranges::equal(x, c);\n+  ranges::generate_n(c, 0, [] { return -1; });\n+  ok &= ranges::equal(x, c);\n+  ranges::generate_n(c, -2, [] { return -1; });\n+  ok &= ranges::equal(x, c);\n+  return ok;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  static_assert(test02());\n+}"}, {"sha": "eacf2906371e4a07a4474f2e578a5e864d3315e3", "filename": "libstdc++-v3/testsuite/25_algorithms/heap/constrained.cc", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fheap%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fheap%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fheap%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,107 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+// { dg-require-cstdint \"\" }\n+\n+#include <algorithm>\n+#include <random>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::random_access_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+template<template<typename, template<typename> typename> typename container>\n+void\n+test01()\n+{\n+  int x[50];\n+\n+  auto pred = std::greater{};\n+  auto proj = [] (int a) { return -a; };\n+  for (int i = 0; i < 50; i++)\n+    {\n+      std::iota(x, x+50, 1);\n+      container<int, random_access_iterator_wrapper> rx(x);\n+\n+      std::ranlux48_base g(i);\n+      ranges::shuffle(rx, g);\n+\n+      auto iter = ranges::make_heap(rx, pred, proj);\n+      VERIFY( iter == rx.end() );\n+      VERIFY( ranges::is_heap(rx, pred, proj) );\n+      VERIFY( ranges::is_heap_until(rx, pred, proj) == rx.end() );\n+\n+      iter = ranges::pop_heap(rx, pred, proj);\n+      VERIFY( iter == rx.end() );\n+      VERIFY( *(iter-1) == 50 );\n+      VERIFY( ranges::is_heap_until(rx, pred, proj) == iter-1 );\n+\n+      iter = ranges::pop_heap(rx.begin(), iter-1, pred, proj);\n+      VERIFY( iter+1 == rx.end() );\n+      VERIFY( *(iter-1) == 49 );\n+      VERIFY( ranges::is_heap_until(rx, pred, proj) == iter-1 );\n+\n+      *(iter-1) = i;\n+      iter = ranges::push_heap(rx.begin(), iter, pred, proj);\n+      VERIFY( iter+1 == rx.end() );\n+      VERIFY( ranges::is_heap_until(rx, pred, proj) == iter );\n+\n+      *iter = 2*i;\n+      iter = ranges::push_heap(rx.begin(), rx.end(), pred, proj);\n+      VERIFY( iter == rx.end() );\n+      VERIFY( ranges::is_heap_until(rx, pred, proj) == iter );\n+\n+      *(rx.begin()+1) *= -1;\n+      VERIFY( !ranges::is_heap(rx, pred, proj) );\n+      *(rx.begin()+1) *= -1;\n+      VERIFY( ranges::is_heap(rx, pred, proj) );\n+\n+      iter = ranges::sort_heap(rx, pred, proj);\n+      VERIFY( iter == rx.end() );\n+      VERIFY( ranges::is_sorted(rx, pred, proj) );\n+    }\n+}\n+\n+constexpr bool\n+test02()\n+{\n+  bool ok = true;\n+  int x[] = {1,2,3,4,5};\n+  ranges::make_heap(x);\n+  ranges::pop_heap(x);\n+  x[4] = 7;\n+  ranges::push_heap(x);\n+  ok &= ranges::is_heap(x);\n+  ok &= ranges::is_heap_until(x) == x+5;\n+  ranges::sort_heap(x);\n+  ok &= ranges::equal(x, (int[]){1,2,3,4,7});\n+  return ok;\n+}\n+\n+int\n+main()\n+{\n+  test01<test_range>();\n+  test01<test_container>();\n+  static_assert(test02());\n+}"}, {"sha": "f959a1d60a45daad43644372d3cf8ab7f5b2c3dd", "filename": "libstdc++-v3/testsuite/25_algorithms/includes/constrained.cc", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fincludes%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fincludes%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fincludes%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,74 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::input_iterator_wrapper;\n+using __gnu_test::forward_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+void\n+test01()\n+{\n+  int x[] = {1,2,3,4,5,6,7};\n+  int y[] = {2,4,6};\n+  test_range<int, input_iterator_wrapper> rx(x), ry(y);\n+\n+  VERIFY( ranges::includes(rx, ry) );\n+\n+  rx.bounds.first = x;\n+  ry.bounds.first = y;\n+  VERIFY( ranges::includes(rx, ry,\n+\t\t\t   ranges::greater{},\n+\t\t\t   std::negate<>{},\n+\t\t\t   std::negate<>{}) );\n+\n+  test_container<int, forward_iterator_wrapper> cx(x), cy(y);\n+  VERIFY( ranges::includes(cx.begin(), cx.end(),\n+\t\t\t   cy.begin(), cy.end(),\n+\t\t\t   {},\n+\t\t\t   [] (int a) { return a+1; },\n+\t\t\t   [] (int a) { return a+2; }) );\n+\n+  VERIFY( ranges::includes(x, x+1, y, y) );\n+}\n+\n+constexpr bool\n+test03()\n+{\n+  bool ok = true;\n+  ok &= ranges::includes((int[]){1,2,3},\n+\t\t\t (int[]){1});\n+  ok &= !ranges::includes((int[]){1,2,3},\n+\t\t\t  (int[]){1,2,3,4});\n+  return true;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  static_assert(test03());\n+}"}, {"sha": "856056865d980cf4184b1387db62b373d59ef7cb", "filename": "libstdc++-v3/testsuite/25_algorithms/inplace_merge/constrained.cc", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Finplace_merge%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Finplace_merge%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Finplace_merge%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,69 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::bidirectional_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+void\n+test01()\n+{\n+  int x[] = {1,2,3,4,5};\n+  for (int i = 0; i <= 5; i++)\n+    for (int j = 0; j <= 5; j++)\n+      {\n+\tstd::vector<int> v(x, x+i);\n+\tv.insert(v.end(), x, x+j);\n+\tranges::sort(v);\n+\n+\ttest_range<int, bidirectional_iterator_wrapper> rz(&v[0], &v[0]+i+j);\n+\tauto result = ranges::inplace_merge(rz, next(ranges::begin(rz), i));\n+\tVERIFY( result == rz.end() );\n+\n+\tVERIFY( ranges::is_sorted(rz) );\n+      }\n+}\n+\n+void\n+test02()\n+{\n+  struct X { int i, j; };\n+  X x[] = { {1, 1}, {3, 4}, {5, 5}, {2, 2}, {2, 3} };\n+  auto comp = ranges::greater{};\n+  auto proj = [] (X a) { return -a.i; };\n+  ranges::inplace_merge(x, x+3, x+5, comp, proj);\n+  VERIFY( ranges::is_sorted(x, {}, &X::i) );\n+  VERIFY( ranges::is_sorted(x, {}, &X::j) );\n+}\n+\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "8035667b38d385208ccca951de9dd475d26840a2", "filename": "libstdc++-v3/testsuite/25_algorithms/is_partitioned/constrained.cc", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fis_partitioned%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fis_partitioned%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fis_partitioned%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,58 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::input_iterator_wrapper;\n+using __gnu_test::forward_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+void\n+test01()\n+{\n+  int x[] = {2,4,6,1,3,5};\n+  test_container<int, forward_iterator_wrapper> cx(x);\n+  VERIFY( ranges::is_partitioned(cx, [] (int a) { return a%2==0; }) );\n+\n+  test_range<int, input_iterator_wrapper> rx(x);\n+  VERIFY( ranges::is_partitioned(rx,\n+\t\t\t\t [] (int a) { return a%2==1; },\n+\t\t\t\t [] (int a) { return a+1; }) );\n+}\n+\n+constexpr bool\n+test02()\n+{\n+  int x[] = {1,2,3,4,5,6,1};\n+  return (ranges::is_partitioned(x, x+6, [] (int a) { return a<=2; })\n+\t  && !ranges::is_partitioned(x, x+7, [] (int a) { return a<=2; }));\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  static_assert(test02());\n+}"}, {"sha": "c5393becc8dc6bcc22adf655de3a0f943a8daf58", "filename": "libstdc++-v3/testsuite/25_algorithms/is_permutation/constrained.cc", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fis_permutation%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fis_permutation%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fis_permutation%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,85 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::input_iterator_wrapper;\n+using __gnu_test::forward_iterator_wrapper;\n+using __gnu_test::bidirectional_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+struct X { int i; };\n+\n+void\n+test01()\n+{\n+  int x[] = { {2}, {2}, {6}, {8}, {10}, {11} };\n+  int y[] = { {2}, {6}, {8}, {10}, {11}, {2} };\n+  int z[] = { {2}, {6}, {8}, {10}, {2}, {2} };\n+\n+  VERIFY( ranges::is_permutation(x, x+6, y, y+6) );\n+  VERIFY( !ranges::is_permutation(x, x+6, y, y+5) );\n+\n+  test_container<int, forward_iterator_wrapper> cx(x), cy(y), cz(z);\n+  test_range<int, forward_iterator_wrapper> rx(x), ry(y), rz(z);\n+  VERIFY( ranges::is_permutation(cx, ry) );\n+  VERIFY( !ranges::is_permutation(rx, cz) );\n+  VERIFY( ranges::is_permutation(rx, cy) );\n+  VERIFY( !ranges::is_permutation(cx, rz) );\n+}\n+\n+void\n+test02()\n+{\n+  static constexpr X x[] = { {2}, {2}, {6}, {8}, {10}, {11} };\n+  static constexpr X y[] = { {2}, {6}, {8}, {10}, {11}, {2} };\n+  static constexpr int z[] = { {2}, {6}, {8}, {10}, {2}, {2} };\n+  static_assert(ranges::is_permutation(x, y, {}, &X::i, &X::i));\n+  static_assert(!ranges::is_permutation(x, z, {}, &X::i));\n+  static_assert(!ranges::is_permutation(z, y, {}, {}, &X::i));\n+}\n+\n+void\n+test03()\n+{\n+  int x[] = { 1, 2, 3, 4 };\n+  int y[] = { 1, 2, 3, 3 };\n+  test_container<int, bidirectional_iterator_wrapper> cx(x);\n+  do\n+    do\n+      {\n+\tVERIFY( ranges::is_permutation(cx, x) );\n+\tVERIFY( !ranges::is_permutation(y, cx) );\n+      } while (std::next_permutation(y, y+4));\n+  while (std::next_permutation(std::begin(cx), std::end(cx)));\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+}"}, {"sha": "af00afe48e8975f62c1b3e750994aff670803997", "filename": "libstdc++-v3/testsuite/25_algorithms/is_sorted/constrained.cc", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fis_sorted%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fis_sorted%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fis_sorted%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,67 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::forward_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+void\n+test01()\n+{\n+  int x[] = {3,4,5,1};\n+  test_container<int, forward_iterator_wrapper> cx(x);\n+  VERIFY( ranges::is_sorted(cx.begin(), ranges::next(cx.begin(), 3)) );\n+  VERIFY( !ranges::is_sorted(cx) );\n+  VERIFY( !ranges::is_sorted(cx, ranges::greater{}) );\n+  VERIFY( ranges::is_sorted(cx, {}, [] (int a) { return 0; }) );\n+}\n+\n+void\n+test02()\n+{\n+  int x[] = {1,2,3,4,5};\n+  test_range<int, forward_iterator_wrapper> rx(x);\n+  VERIFY( ranges::is_sorted(rx) );\n+  VERIFY( !ranges::is_sorted(ranges::begin(rx),\n+\t\t\t     next(ranges::begin(rx), 2),\n+\t\t\t     ranges::greater{}) );\n+}\n+\n+constexpr bool\n+test03()\n+{\n+  int x[] = { 1,2 };\n+  return (ranges::is_sorted(x)\n+\t  && ranges::is_sorted(x, x) );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  static_assert(test03());\n+}"}, {"sha": "a81aa49ee94ce3ee3e1625d35fc024a8504b825b", "filename": "libstdc++-v3/testsuite/25_algorithms/is_sorted_until/constrained.cc", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fis_sorted_until%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fis_sorted_until%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fis_sorted_until%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,72 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::forward_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+void\n+test01()\n+{\n+  int x[] = {3,4,5,1};\n+  test_container<int, forward_iterator_wrapper> cx(x);\n+  VERIFY( ranges::is_sorted_until(cx.begin(),\n+\t\t\t\t  ranges::next(cx.begin(), 3))\n+\t  == ranges::next(cx.begin(), 3) );\n+  VERIFY( ranges::is_sorted_until(cx) == ranges::next(cx.begin(), 3) );\n+  VERIFY( ranges::is_sorted_until(cx, ranges::greater{})\n+\t  == ranges::next(cx.begin(), 1) );\n+  VERIFY( ranges::is_sorted_until(cx, {}, [] (int a) { return 0; })\n+\t  == cx.end() );\n+}\n+\n+void\n+test02()\n+{\n+  int x[] = {1,2,3,4,5};\n+  test_range<int, forward_iterator_wrapper> rx(x);\n+  VERIFY( ranges::is_sorted_until(rx) == ranges::end(rx) );\n+  VERIFY( ranges::is_sorted_until(ranges::begin(rx),\n+\t\t\t\t  next(ranges::begin(rx), 2),\n+\t\t\t\t  ranges::greater{})\n+\t  == next(ranges::begin(rx), 1) );\n+}\n+\n+constexpr bool\n+test03()\n+{\n+  int x[] = { 1,2 };\n+  return (ranges::is_sorted_until(x) == x+2\n+\t  && ranges::is_sorted_until(x, x) == x );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  static_assert(test03());\n+}"}, {"sha": "b82c872bbbbeedc20682d4b62960cc64817c085b", "filename": "libstdc++-v3/testsuite/25_algorithms/lexicographical_compare/constrained.cc", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Flexicographical_compare%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Flexicographical_compare%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Flexicographical_compare%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,164 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::input_iterator_wrapper;\n+using __gnu_test::forward_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+void\n+test01()\n+{\n+  int x[] = {1, 2, 3, 4, 5};\n+  char y[] = {1, 2, 3, 5};\n+  long z[] = {1, 2, 3, 4, 5, 6};\n+\n+    {\n+      test_range<int, input_iterator_wrapper> rx(x);\n+      test_range<char, input_iterator_wrapper> ry(y);\n+      test_range<long, input_iterator_wrapper> rz(z);\n+\n+      VERIFY( ranges::lexicographical_compare(rx, ry) );\n+      rx.bounds.first = x;\n+      ry.bounds.first = y;\n+      VERIFY( !ranges::lexicographical_compare(ry, rx) );\n+    }\n+\n+  test_range<int, forward_iterator_wrapper> rx(x);\n+  test_range<char, forward_iterator_wrapper> ry(y);\n+  test_range<long, forward_iterator_wrapper> rz(z);\n+\n+  VERIFY( ranges::lexicographical_compare(rx, rz) );\n+  VERIFY( !ranges::lexicographical_compare(rz, rx) );\n+\n+  VERIFY( !ranges::lexicographical_compare(rx, rx) );\n+  VERIFY( ranges::lexicographical_compare(rx, rx, {}, std::negate<>{}) );\n+  VERIFY( ranges::lexicographical_compare(rx, rx, std::greater{},\n+\t\t\t\t\t  {}, std::negate<>{}) );\n+\n+  VERIFY( !ranges::lexicographical_compare(rx, ry, {},\n+\t\t\t\t\t   std::negate<>{},\n+\t\t\t\t\t   std::negate<>{}) );\n+  VERIFY( ranges::lexicographical_compare(ry, rx, {},\n+\t\t\t\t\t  std::negate<>{},\n+\t\t\t\t\t  std::negate<>{}) );\n+\n+  VERIFY( ranges::lexicographical_compare(rx, rz, ranges::greater{}) );\n+  VERIFY( !ranges::lexicographical_compare(rz, rx, ranges::greater{}) );\n+\n+  VERIFY( ranges::lexicographical_compare(rx, ry, ranges::greater{},\n+\t\t\t\t\t  std::negate<>{},\n+\t\t\t\t\t  std::negate<>{}) );\n+  VERIFY( !ranges::lexicographical_compare(ry, rx, ranges::greater{},\n+\t\t\t\t\t   std::negate<>{},\n+\t\t\t\t\t   std::negate<>{}) );\n+}\n+\n+void\n+test02()\n+{\n+  int x[] = {1, 2, 3, 4, 5};\n+  int y[] = {1, 2, 3, 5};\n+  int z[] = {1, 2, 3, 4, 5, 6};\n+\n+  VERIFY( ranges::lexicographical_compare(x, y) );\n+  VERIFY( !ranges::lexicographical_compare(y, x) );\n+\n+  VERIFY( ranges::lexicographical_compare(x, z) );\n+  VERIFY( !ranges::lexicographical_compare(z, x) );\n+\n+  VERIFY( !ranges::lexicographical_compare(x, x) );\n+\n+  VERIFY( !ranges::lexicographical_compare(x, y, {},\n+\t\t\t\t\t   std::negate<>{},\n+\t\t\t\t\t   std::negate<>{}) );\n+  VERIFY( ranges::lexicographical_compare(y, x, {},\n+\t\t\t\t\t  std::negate<>{},\n+\t\t\t\t\t  std::negate<>{}) );\n+\n+  VERIFY( ranges::lexicographical_compare(x, z, ranges::greater{}) );\n+  VERIFY( !ranges::lexicographical_compare(z, x, ranges::greater{}) );\n+\n+  VERIFY( ranges::lexicographical_compare(x, y, ranges::greater{},\n+\t\t\t\t\t  std::negate<>{},\n+\t\t\t\t\t  std::negate<>{}) );\n+  VERIFY( !ranges::lexicographical_compare(y, x, ranges::greater{},\n+\t\t\t\t\t   std::negate<>{},\n+\t\t\t\t\t   std::negate<>{}) );\n+}\n+\n+void\n+test03()\n+{\n+  int x[] = {1, 2, 3, 4, 5};\n+  int y[] = {1, 2, 5, 3};\n+  int z[] = {1, 2, 3, 5};\n+\n+  do\n+    {\n+      VERIFY( ranges::lexicographical_compare(x, y) );\n+      VERIFY( !ranges::lexicographical_compare(x, y, ranges::greater{}) );\n+      VERIFY( !ranges::lexicographical_compare(y, x) );\n+      VERIFY( ranges::lexicographical_compare(y, x, ranges::greater{}) );\n+\n+      test_container<int, forward_iterator_wrapper> cy(y);\n+      VERIFY( ranges::lexicographical_compare(x, cy) );\n+      VERIFY( !ranges::lexicographical_compare(x, cy, ranges::greater{}) );\n+      VERIFY( !ranges::lexicographical_compare(cy, x) );\n+      VERIFY( ranges::lexicographical_compare(cy, x, ranges::greater{}) );\n+\n+      test_container<int, forward_iterator_wrapper> cz(z);\n+      VERIFY( ranges::lexicographical_compare(cz.begin(), cz.end(),\n+\t\t\t\t\t      cy.begin(), cy.end()) );\n+      VERIFY( !ranges::lexicographical_compare(cy.begin(), cy.end(),\n+\t\t\t\t\t       cz.begin(), cz.end()) );\n+\n+      std::vector<int> vx(x, x+5), vy(y, y+5);\n+      VERIFY( ranges::lexicographical_compare(vx, vy) );\n+      VERIFY( !ranges::lexicographical_compare(vx, vy, ranges::greater{}) );\n+      VERIFY( !ranges::lexicographical_compare(vy, vx) );\n+      VERIFY( ranges::lexicographical_compare(vy, vx, ranges::greater{}) );\n+    } while (ranges::next_permutation(y).found);\n+}\n+\n+constexpr bool\n+test04()\n+{\n+  int x[] = {1};\n+  int y[] = {1};\n+  return (ranges::lexicographical_compare((int[]){1,2,3,5},\n+\t\t\t\t\t  (int[]){1,2,4})\n+\t  && !ranges::lexicographical_compare(x, x, y, y));\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  static_assert(test04());\n+}"}, {"sha": "df93f41e82349fcc5d5d071acf3947205f8a8a0c", "filename": "libstdc++-v3/testsuite/25_algorithms/lower_bound/constrained.cc", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Flower_bound%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Flower_bound%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Flower_bound%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,66 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::forward_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+void\n+test01()\n+{\n+  int x[] = {1, 2, 3, 4, 5, 5, 6, 7};\n+  for (unsigned i = 0; i < 5; i++)\n+    for (unsigned j = 5; j < 8; j++)\n+      {\n+\ttest_container<int, forward_iterator_wrapper> cx(x);\n+\tauto result = ranges::lower_bound(std::next(cx.begin(), i),\n+\t\t\t\t\t  std::next(cx.begin(), j),\n+\t\t\t\t\t  4, {}, [] (int a) { return a-1; });\n+\tVERIFY( result.ptr == x+4 );\n+      }\n+\n+  ranges::reverse(x);\n+  test_range<int, forward_iterator_wrapper> rx(x);\n+  auto result = ranges::lower_bound(rx, 5, ranges::greater{},\n+\t\t\t\t    [] (int a) { return a+1; });\n+  VERIFY( result.ptr == x+4 );\n+}\n+\n+constexpr bool\n+test02()\n+{\n+  int x[] = {1, 2, 3, 4, 5};\n+  return (ranges::lower_bound(x, 6) == x+5\n+\t  && ranges::lower_bound(x, x, 6) == x\n+\t  && ranges::lower_bound(x, 1) == x);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  static_assert(test02());\n+}"}, {"sha": "3fcdb3a366c1dd5b6e43f54fe3208d8f3fb9f63d", "filename": "libstdc++-v3/testsuite/25_algorithms/max/constrained.cc", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fmax%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fmax%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fmax%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,82 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::input_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+struct X\n+{\n+  int i, j;\n+};\n+\n+void\n+test01()\n+{\n+  VERIFY( ranges::max(1, 2) == 2);\n+  VERIFY( ranges::max(2, 1) == 2);\n+  VERIFY( ranges::max(1, 2, ranges::greater{}) == 1);\n+  VERIFY( ranges::max(1, 2, ranges::greater{}, std::negate<>{}) == 2);\n+  VERIFY( ranges::max(1, 2, {}, std::negate<>{}) == 1);\n+  VERIFY( ranges::max(X{1,2}, X{1,3}, {}, &X::i).j == 2 );\n+}\n+\n+void\n+test02()\n+{\n+  int x[] = {1,2,3,4};\n+  do\n+    {\n+      test_range<int, input_iterator_wrapper> cx(x);\n+      VERIFY( ranges::max(cx) == 4 );\n+      cx.bounds.first = x;\n+      VERIFY( ranges::max(cx, ranges::greater{}) == 1 );\n+      cx.bounds.first = x;\n+      VERIFY( ranges::max(cx, {}, std::negate<>{}) == 1);\n+      cx.bounds.first = x;\n+      VERIFY( ranges::max(cx, ranges::greater{}, std::negate<>{}) == 4 );\n+    } while (ranges::next_permutation(x).found);\n+\n+  constexpr X y[] = {{0,5},{1,2},{1,3}};\n+  static_assert(ranges::max(y, {}, &X::i).j == 2);\n+}\n+\n+void\n+test03()\n+{\n+  VERIFY( ranges::max({2,3,1,4}) == 4 );\n+  VERIFY( ranges::max({2,3,1,4}, ranges::greater{}) == 1 );\n+  VERIFY( ranges::max({2,3,1,4}, {}, std::negate<>{}) == 1 );\n+  VERIFY( ranges::max({2,3,1,4}, ranges::greater{}, std::negate<>{}) == 4 );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+}"}, {"sha": "427faedbc444a669a667a0ba203e0e56d3f14b87", "filename": "libstdc++-v3/testsuite/25_algorithms/max_element/constrained.cc", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fmax_element%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fmax_element%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fmax_element%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,60 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::forward_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+struct X\n+{\n+  int i, j;\n+};\n+\n+void\n+test01()\n+{\n+  int x[] = {1,2,3,4};\n+  do\n+    {\n+      test_range<int, forward_iterator_wrapper> cx(x);\n+      VERIFY( *ranges::max_element(cx) == 4 );\n+      VERIFY( *ranges::max_element(cx, ranges::greater{}) == 1 );\n+      VERIFY( *ranges::max_element(cx, {}, std::negate<>{}) == 1);\n+      VERIFY( *ranges::max_element(cx, ranges::greater{}, std::negate<>{}) == 4 );\n+    } while (ranges::next_permutation(x).found);\n+\n+  test_container<int, forward_iterator_wrapper> cx(x);\n+  VERIFY( ranges::max_element(cx.begin(), cx.begin()) == cx.begin() );\n+\n+  constexpr X y[] = {{0,5},{1,2},{1,3}};\n+  static_assert(ranges::max_element(y, y+3, {}, &X::i)->j == 2);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "3f3a0f79f9bf7872bde0b7ce8f187315e97b15e6", "filename": "libstdc++-v3/testsuite/25_algorithms/merge/constrained.cc", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fmerge%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fmerge%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fmerge%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,75 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::input_iterator_wrapper;\n+using __gnu_test::output_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+void\n+test01()\n+{\n+  int x[] = {1,2,3,4,5};\n+  for (int i = 0; i <= 5; i++)\n+    for (int j = 0; j <= 5; j++)\n+      {\n+\tint z[10];\n+\ttest_range<int, input_iterator_wrapper> rx(x, x+i), ry(x, x+j);\n+\ttest_range<int, output_iterator_wrapper> rz(z, z+i+j);\n+\tauto [in1,in2,out] = ranges::merge(rx, ry, rz.begin());\n+\tVERIFY( in1 == rx.end() );\n+\tVERIFY( in2 == ry.end() );\n+\tVERIFY( out == rz.end() );\n+\n+\tstd::vector<int> v(x, x+i);\n+\tv.insert(v.end(), x, x+j);\n+\tranges::sort(v);\n+\n+\tVERIFY( ranges::equal(v.begin(), v.end(), z, z+i+j) );\n+      }\n+}\n+\n+constexpr bool\n+test02()\n+{\n+  int x[] = {-1,-3,-5};\n+  int y[] = {2,4,6};\n+  int z[6];\n+  ranges::merge(x, x+3, y, y+3, z,\n+\t\tranges::greater{}, {}, [] (int a) { return -a; });\n+\n+  const int w[6] = {-1, 2, -3, 4, -5, 6};\n+  return ranges::equal(w, z);\n+}\n+\n+\n+int\n+main()\n+{\n+  test01();\n+  static_assert(test02());\n+}"}, {"sha": "c3a83b975c909838e9990bf3fd9825e75044ba85", "filename": "libstdc++-v3/testsuite/25_algorithms/min/constrained.cc", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fmin%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fmin%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fmin%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,82 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::input_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+struct X\n+{\n+  int i, j;\n+};\n+\n+void\n+test01()\n+{\n+  VERIFY( ranges::min(1, 2) == 1);\n+  VERIFY( ranges::min(2, 1) == 1);\n+  VERIFY( ranges::min(1, 2, ranges::greater{}) == 2);\n+  VERIFY( ranges::min(1, 2, ranges::greater{}, std::negate<>{}) == 1);\n+  VERIFY( ranges::min(1, 2, {}, std::negate<>{}) == 2);\n+  VERIFY( ranges::min(X{1,2}, X{1,3}, {}, &X::i).j == 2 );\n+}\n+\n+void\n+test02()\n+{\n+  int x[] = {1,2,3,4};\n+  do\n+    {\n+      test_range<int, input_iterator_wrapper> cx(x);\n+      VERIFY( ranges::min(cx) == 1 );\n+      cx.bounds.first = x;\n+      VERIFY( ranges::min(cx, ranges::greater{}) == 4 );\n+      cx.bounds.first = x;\n+      VERIFY( ranges::min(cx, {}, std::negate<>{}) == 4);\n+      cx.bounds.first = x;\n+      VERIFY( ranges::min(cx, ranges::greater{}, std::negate<>{}) == 1 );\n+    } while (ranges::next_permutation(x).found);\n+\n+  constexpr X y[] = {{5,0},{1,2},{1,3}};\n+  static_assert(ranges::min(y, {}, &X::i).j == 2);\n+}\n+\n+void\n+test03()\n+{\n+  VERIFY( ranges::min({2,3,1,4}) == 1 );\n+  VERIFY( ranges::min({2,3,1,4}, ranges::greater{}) == 4 );\n+  VERIFY( ranges::min({2,3,1,4}, {}, std::negate<>{}) == 4 );\n+  VERIFY( ranges::min({2,3,1,4}, ranges::greater{}, std::negate<>{}) == 1 );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+}"}, {"sha": "518060522a3428899545555c6573987a8589f068", "filename": "libstdc++-v3/testsuite/25_algorithms/min_element/constrained.cc", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fmin_element%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fmin_element%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fmin_element%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,60 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::forward_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+struct X\n+{\n+  int i, j;\n+};\n+\n+void\n+test01()\n+{\n+  int x[] = {1,2,3,4};\n+  do\n+    {\n+      test_range<int, forward_iterator_wrapper> cx(x);\n+      VERIFY( *ranges::min_element(cx) == 1 );\n+      VERIFY( *ranges::min_element(cx, ranges::greater{}) == 4 );\n+      VERIFY( *ranges::min_element(cx, {}, std::negate<>{}) == 4);\n+      VERIFY( *ranges::min_element(cx, ranges::greater{}, std::negate<>{}) == 1 );\n+    } while (ranges::next_permutation(x).found);\n+\n+  test_container<int, forward_iterator_wrapper> cx(x);\n+  VERIFY( ranges::min_element(cx.begin(), cx.begin()) == cx.begin() );\n+\n+  constexpr X y[] = {{5,0},{1,2},{1,3}};\n+  static_assert(ranges::min_element(y, y+3, {}, &X::i)->j == 2);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "aa9364ab04c752f660eaa2dfaccac17622a77c88", "filename": "libstdc++-v3/testsuite/25_algorithms/minmax/constrained.cc", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fminmax%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fminmax%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fminmax%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,98 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::input_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+template<typename T1, typename T2>\n+constexpr bool\n+operator==(const ranges::minmax_result<T1>& lhs,\n+\t   const ranges::minmax_result<T2>& rhs)\n+{\n+  return (lhs.min == rhs.min\n+\t  && rhs.max == rhs.max);\n+}\n+\n+\n+struct X\n+{\n+  int i, j;\n+};\n+\n+using res_t = ranges::minmax_result<int>;\n+\n+void\n+test01()\n+{\n+  VERIFY( ranges::minmax(1, 2) == res_t(1,2) );\n+  VERIFY( ranges::minmax(2, 1) == res_t(1,2) );\n+  VERIFY( ranges::minmax(1, 2, ranges::greater{}) == res_t(2,1) );\n+  VERIFY( ranges::minmax(1, 2, ranges::greater{}, std::negate<>{}) == res_t(1,2) );\n+  VERIFY( ranges::minmax(1, 2, {}, std::negate<>{}) == res_t(2,1) );\n+  VERIFY( ranges::minmax(X{1,2}, X{1,3}, {}, &X::i).min.j == 2 );\n+  VERIFY( ranges::minmax(X{1,2}, X{1,3}, {}, &X::i).max.j == 3 );\n+}\n+\n+void\n+test02()\n+{\n+  int x[] = {1,2,3,4};\n+  do\n+    {\n+      test_range<int, input_iterator_wrapper> cx(x);\n+      VERIFY( ranges::minmax(cx) == res_t(1,4) );\n+      cx.bounds.first = x;\n+      VERIFY( ranges::minmax(cx, ranges::greater{}) == res_t(4,1) );\n+      cx.bounds.first = x;\n+      VERIFY( ranges::minmax(cx, {}, std::negate<>{}) == res_t(4,1));\n+      cx.bounds.first = x;\n+      VERIFY( ranges::minmax(cx, ranges::greater{}, std::negate<>{})\n+\t      == res_t(1,4) );\n+    } while (ranges::next_permutation(x).found);\n+\n+  constexpr X y[] = {{1,5},{1,2},{1,3}};\n+  static_assert(ranges::minmax(y, {}, &X::i).min.j == 5);\n+  static_assert(ranges::minmax(y, {}, &X::i).max.j == 3);\n+}\n+\n+void\n+test03()\n+{\n+  VERIFY( ranges::minmax({2,3,1,4}) == res_t(1,4) );\n+  VERIFY( ranges::minmax({2,3,1,4}, ranges::greater{}) == res_t(4,1) );\n+  VERIFY( ranges::minmax({2,3,1,4}, {}, std::negate<>{}) == res_t(4,1) );\n+  VERIFY( ranges::minmax({2,3,1,4}, ranges::greater{}, std::negate<>{})\n+\t  == res_t(1,4) );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+}"}, {"sha": "40019c43326f6af2669b6f4302affa576ea253fe", "filename": "libstdc++-v3/testsuite/25_algorithms/minmax_element/constrained.cc", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fminmax_element%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fminmax_element%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fminmax_element%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,68 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::forward_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+struct X\n+{\n+  int i, j;\n+};\n+\n+void\n+test01()\n+{\n+  int x[] = {1,2,3,4};\n+  do\n+    {\n+      test_range<int, forward_iterator_wrapper> cx(x);\n+      VERIFY( *ranges::minmax_element(cx).min == 1 );\n+      VERIFY( *ranges::minmax_element(cx).max == 4 );\n+      VERIFY( *ranges::minmax_element(cx, ranges::greater{}).min == 4 );\n+      VERIFY( *ranges::minmax_element(cx, ranges::greater{}).max == 1 );\n+      VERIFY( *ranges::minmax_element(cx, {}, std::negate<>{}).min == 4);\n+      VERIFY( *ranges::minmax_element(cx, {}, std::negate<>{}).max == 1);\n+      VERIFY( *ranges::minmax_element(cx, ranges::greater{}, std::negate<>{}).min\n+\t      == 1 );\n+      VERIFY( *ranges::minmax_element(cx, ranges::greater{}, std::negate<>{}).max\n+\t      == 4 );\n+    } while (ranges::next_permutation(x).found);\n+\n+  test_container<int, forward_iterator_wrapper> cx(x);\n+  VERIFY( ranges::minmax_element(cx.begin(), cx.begin()).min == cx.begin() );\n+  VERIFY( ranges::minmax_element(cx.begin(), cx.begin()).max == cx.begin() );\n+\n+  constexpr X y[] = {{1,5},{1,2},{1,3}};\n+  static_assert(ranges::minmax_element(y, y+3, {}, &X::i).min->j == 5);\n+  static_assert(ranges::minmax_element(y, y+3, {}, &X::i).max->j == 3);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "37e79a2d62f19d7150d4bf7059ea9d8997c1ee88", "filename": "libstdc++-v3/testsuite/25_algorithms/mismatch/constrained.cc", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fmismatch%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fmismatch%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fmismatch%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,76 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::input_iterator_wrapper;\n+using __gnu_test::forward_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+struct X { int i; };\n+\n+void\n+test01()\n+{\n+  X xa[] = { {1}, {2}, {3}, {4}, {5}, {6} };\n+  X xb[] = { {1}, {2}, {3}, {3}, {5}, {6} };\n+  auto res = ranges::mismatch(xa, xa+6, xb, xb+6, {}, &X::i, &X::i);\n+  VERIFY( res.in1 == xa+3 && res.in2 == xb+3 );\n+\n+  test_container<X, forward_iterator_wrapper> ca(xa);\n+  test_container<X, forward_iterator_wrapper> cb(xb);\n+  auto res2 = ranges::mismatch(ca, cb, {}, &X::i, &X::i);\n+  VERIFY( res2.in1->i == 4 && res2.in2->i == 3 );\n+  res2 = ranges::mismatch(ca, ca, {}, &X::i, &X::i);\n+  VERIFY( res2.in1 == ranges::end(ca) && res2.in2 == ranges::end(ca) );\n+\n+  test_range<X, input_iterator_wrapper> ra(xa);\n+  test_range<X, input_iterator_wrapper> rb(xb);\n+  auto res3 = ranges::mismatch(ra, rb, {}, &X::i, &X::i);\n+  VERIFY( res3.in1->i == 4 && res3.in2->i == 3 );\n+\n+  test_range<X, input_iterator_wrapper> ra2(xa);\n+  ra.bounds.first = xa;\n+  res3 = ranges::mismatch(ra, ra2, {}, &X::i, &X::i);\n+  VERIFY( res3.in1 == ranges::end(ra) && res3.in2 == ranges::end(ra2) );\n+}\n+\n+struct Y { int i; int j; };\n+\n+void\n+test02()\n+{\n+  static constexpr Y ya[] = { {1,2}, {2,4}, {3,6}, {1,6} };\n+  static constexpr Y yb[] = { {2,1}, {4,2}, {4,2}, {7,1} };\n+  static_assert(ranges::mismatch(ya, yb, {}, &Y::i, &Y::j).in1 == ya+2);\n+  static_assert(ranges::mismatch(ya, yb, {}, &Y::i, &Y::j).in2 == yb+2);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "d205b3572a1ad0411353c3a5073e4bb51663b2eb", "filename": "libstdc++-v3/testsuite/25_algorithms/move/constrained.cc", "status": "added", "additions": 203, "deletions": 0, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fmove%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fmove%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fmove%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,203 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::input_iterator_wrapper;\n+using __gnu_test::output_iterator_wrapper;\n+using __gnu_test::forward_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+struct X\n+{\n+  int i;\n+  int moved = 0;\n+\n+  constexpr X() : i(0) { }\n+  constexpr X(int a) : i(a) { }\n+\n+  constexpr X(const X&) = delete;\n+  constexpr X& operator=(const X&) = delete;\n+\n+  constexpr X(X&& other)\n+  {\n+    *this = std::move(other);\n+  }\n+\n+  constexpr X&\n+  operator=(X&& other)\n+  {\n+    other.moved++;\n+    i = other.i;\n+    return *this;\n+  }\n+\n+  friend constexpr bool\n+  operator==(const X& a, const X& b)\n+  { return a.i == b.i; }\n+};\n+\n+void\n+test01()\n+{\n+    {\n+      X x[7] = { 1, 2, 3, 4, 5, 6, 7 };\n+      X y[7] = { 0, 0, 0, 0, 0, 0, 0 };\n+      X z[7] = { 1, 2, 3, 4, 5, 6, 7 };\n+      auto [in, out] = ranges::move(x, y);\n+      VERIFY( ranges::equal(x, y) && in == x+7 && out == y+7 );\n+      VERIFY( ranges::equal(x, z) );\n+    }\n+\n+    {\n+      int x[3] = { 1, 2, 3 };\n+      char y[4] = { 0 };\n+      int z[3] = { 1, 2, 3 };\n+      test_container<int, forward_iterator_wrapper> cx(x);\n+      test_container<char, forward_iterator_wrapper> cy(y);\n+      auto [in, out] = ranges::move(cx, cy.begin());\n+      VERIFY( ranges::equal(x, x+3, y, y+3) && in.ptr == x+3 && out.ptr == y+3 );\n+      VERIFY( ranges::equal(x, z) );\n+    }\n+\n+    {\n+      char x[3] = { 1, 2, 3 };\n+      int y[4] = { 0 };\n+      int z[3] = { 1, 2, 3 };\n+      test_range<char, input_iterator_wrapper> cx(x);\n+      test_range<int, output_iterator_wrapper> cy(y);\n+      auto [in, out] = ranges::move(cx, ranges::begin(cy));\n+      VERIFY( ranges::equal(x, x+3, y, y+3) && in.ptr == x+3 && out.ptr == y+3 );\n+      VERIFY( ranges::equal(x, z) );\n+    }\n+\n+    {\n+      std::vector<char> x= {1,2,3};\n+      std::vector<int> y(3);\n+      const int z[3] = { 1, 2, 3 };\n+      auto [in, out] = ranges::move(x, ranges::begin(y));\n+      VERIFY( in.base() == x.data()+3 );\n+      VERIFY( out.base() == y.data()+3 );\n+      VERIFY( ranges::equal(y, z) && ranges::equal(x, z) );\n+    }\n+\n+\n+    {\n+      std::vector<int> x = {1,2,3};\n+      std::vector<int> y(3);\n+      const int z[3] = { 1, 2, 3 };\n+      auto [in, out] = ranges::move(x, ranges::begin(y));\n+      VERIFY( in.base() == x.data()+3 );\n+      VERIFY( out.base() == y.data()+3 );\n+      VERIFY( ranges::equal(y, z) && ranges::equal(x, z) );\n+    }\n+\n+    {\n+      std::vector<int> x = {1,2,3};\n+      std::vector<int> y(3);\n+      const int z[3] = { 1, 2, 3 };\n+      auto [in,out] = ranges::move(make_reverse_iterator(x.end()),\n+\t\t\t\t   make_reverse_iterator(x.begin()),\n+\t\t\t\t   make_reverse_iterator(y.end()));\n+      VERIFY( in.base().base() == x.data()+3 );\n+      VERIFY( out.base().base() == y.data() );\n+      VERIFY( ranges::equal(y, z) && ranges::equal(x, z) );\n+    }\n+\n+    {\n+      std::vector<char> x = {1,2,3};\n+      std::vector<int> y(3);\n+      const int z[3] = { 1, 2, 3 };\n+      auto [in,out] = ranges::move(make_reverse_iterator(x.end()),\n+\t\t\t\t   make_reverse_iterator(x.begin()),\n+\t\t\t\t   make_reverse_iterator(y.end()));\n+      VERIFY( in.base().base() == x.data()+3 );\n+      VERIFY( out.base().base() == y.data() );\n+      VERIFY( ranges::equal(y, z) && ranges::equal(x, z) );\n+    }\n+}\n+\n+void\n+test02()\n+{\n+  X x[] = { {2}, {2}, {6}, {8}, {10} };\n+  X y[] = { {2}, {6}, {8}, {10}, {11}, {2} };\n+  X z[] = { {2}, {2}, {6}, {8}, {10} };\n+  auto [in, out] = ranges::move(x, y);\n+  VERIFY( ranges::equal(x, x+5, y, y+5) );\n+  VERIFY( in == x+5 );\n+  VERIFY( out == y+5 );\n+  VERIFY( y[5].i == 2 );\n+  VERIFY( ranges::equal(x, z) );\n+  VERIFY( ranges::count(x, 1, &X::moved) == 5 );\n+  VERIFY( ranges::count(y, 0, &X::moved) == 6 );\n+}\n+\n+constexpr bool\n+test03()\n+{\n+  bool ok = true;\n+  X x[] = { {2}, {2}, {6}, {8}, {10} };\n+  X y[] = { {2}, {6}, {8}, {10}, {11}, {2} };\n+  X z[] = { {2}, {2}, {6}, {8}, {10} };\n+  auto [in, out] = ranges::move(x, y);\n+  ok &= ranges::equal(x, x+5, y, y+5);\n+  ok &= (in == x+5);\n+  ok &= (out == y+5);\n+  ok &= (y[5].i == 2);\n+  ok &= ranges::equal(x, z);\n+  ok &= ranges::count(x, 1, &X::moved) == 5;\n+  ok &= ranges::count(y, 0, &X::moved) == 6;\n+  return ok;\n+}\n+\n+void\n+test04()\n+{\n+  X x[] = { {2}, {2}, {6}, {8}, {10} };\n+  X y[] = { {2}, {6}, {8}, {10}, {11}, {2} };\n+  X z[] = { {2}, {2}, {6}, {8}, {10} };\n+  test_range<X, input_iterator_wrapper> rx(x);\n+  auto [in, out] = ranges::move(std::move_iterator{ranges::begin(rx)},\n+\t\t\t\tstd::move_sentinel{ranges::end(rx)},\n+\t\t\t\tranges::begin(y));\n+  VERIFY( ranges::equal(x, x+5, y, y+5) );\n+  VERIFY( std::move(in).base().ptr == x+5 );\n+  VERIFY( out == y+5 );\n+  VERIFY( y[5].i == 2 );\n+  VERIFY( ranges::equal(x, z) );\n+  VERIFY( ranges::count(x, 1, &X::moved) == 5 );\n+  VERIFY( ranges::count(y, 0, &X::moved) == 6 );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  static_assert(test03());\n+  test04();\n+}"}, {"sha": "3c4aa5dc70d3c7eea2d321b93d2c845e34db90d2", "filename": "libstdc++-v3/testsuite/25_algorithms/move_backward/constrained.cc", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fmove_backward%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fmove_backward%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fmove_backward%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,170 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::bidirectional_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+struct X\n+{\n+  int i;\n+  int moved = 0;\n+\n+  constexpr X() : i(0) { }\n+  constexpr X(int a) : i(a) { }\n+\n+  constexpr X(const X&) = delete;\n+  constexpr X& operator=(const X&) = delete;\n+\n+  constexpr X(X&& other)\n+  {\n+    *this = std::move(other);\n+  }\n+\n+  constexpr X&\n+  operator=(X&& other)\n+  {\n+    other.moved++;\n+    i = other.i;\n+    return *this;\n+  }\n+\n+  friend constexpr bool\n+  operator==(const X& a, const X& b)\n+  { return a.i == b.i; }\n+};\n+\n+void\n+test01()\n+{\n+    {\n+      X x[7] = { 1, 2, 3, 4, 5, 6, 7 };\n+      X y[7] = { 0, 0, 0, 0, 0, 0, 0 };\n+      X z[7] = { 1, 2, 3, 4, 5, 6, 7 };\n+      auto [in, out] = ranges::move_backward(x, y+7);\n+      VERIFY( ranges::equal(x, y) && in == x+7 && out == y );\n+      VERIFY( ranges::equal(x, z) );\n+    }\n+\n+    {\n+      int x[3] = { 1, 2, 3 };\n+      char y[4] = { 0 };\n+      int z[3] = { 1, 2, 3 };\n+      test_container<int, bidirectional_iterator_wrapper> cx(x);\n+      test_container<char, bidirectional_iterator_wrapper> cy(y);\n+      auto [in, out] = ranges::move_backward(cx, cy.end());\n+      VERIFY( ranges::equal(x, x+3, y+1, y+4) && in.ptr == x+3 && out.ptr == y+1 );\n+      VERIFY( ranges::equal(x, z) );\n+    }\n+\n+    {\n+      std::vector<char> x= {1,2,3};\n+      std::vector<int> y(3);\n+      const int z[3] = { 1, 2, 3 };\n+      auto [in, out] = ranges::move_backward(x, ranges::end(y));\n+      VERIFY( in.base() == x.data()+3 );\n+      VERIFY( out.base() == y.data() );\n+      VERIFY( ranges::equal(y, z) && ranges::equal(x, z) );\n+    }\n+\n+\n+    {\n+      std::vector<int> x = {1,2,3};\n+      std::vector<int> y(3);\n+      const int z[3] = { 1, 2, 3 };\n+      auto [in, out] = ranges::move_backward(x, ranges::end(y));\n+      VERIFY( in.base() == x.data()+3 );\n+      VERIFY( out.base() == y.data() );\n+      VERIFY( ranges::equal(y, z) && ranges::equal(x, z) );\n+    }\n+\n+    {\n+      std::vector<int> x = {1,2,3};\n+      std::vector<int> y(3);\n+      const int z[3] = { 1, 2, 3 };\n+      auto [in,out] = ranges::move_backward(make_reverse_iterator(x.end()),\n+\t\t\t\t\t    make_reverse_iterator(x.begin()),\n+\t\t\t\t\t    make_reverse_iterator(y.begin()));\n+      VERIFY( in.base().base() == x.data()+3 );\n+      VERIFY( out.base().base() == y.data()+3 );\n+      VERIFY( ranges::equal(y, z) && ranges::equal(x, z) );\n+    }\n+\n+    {\n+      std::vector<char> x = {1,2,3};\n+      std::vector<int> y(3);\n+      const int z[3] = { 1, 2, 3 };\n+      auto [in,out] = ranges::move_backward(make_reverse_iterator(x.end()),\n+\t\t\t\t\t    make_reverse_iterator(x.begin()),\n+\t\t\t\t\t    make_reverse_iterator(y.begin()));\n+      VERIFY( in.base().base() == x.data()+3 );\n+      VERIFY( out.base().base() == y.data()+3 );\n+      VERIFY( ranges::equal(y, z) && ranges::equal(x, z) );\n+    }\n+}\n+\n+void\n+test02()\n+{\n+  X x[] = { {2}, {2}, {6}, {8}, {10} };\n+  X y[] = { {2}, {6}, {8}, {10}, {11}, {2} };\n+  const X z[] = { {2}, {2}, {6}, {8}, {10} };\n+  auto [in, out] = ranges::move_backward(x, ranges::end(y));\n+  VERIFY( ranges::equal(x, x+5, y+1, y+6) );\n+  VERIFY( in == x+5 );\n+  VERIFY( out == y+1 );\n+  VERIFY( y[0].i == 2 );\n+  VERIFY( ranges::equal(x, z) );\n+  VERIFY( ranges::count(x, 1, &X::moved) == 5 );\n+  VERIFY( ranges::count(y, 0, &X::moved) == 6 );\n+}\n+\n+constexpr bool\n+test03()\n+{\n+  bool ok = true;\n+  X x[] = { {2}, {2}, {6}, {8}, {10} };\n+  X y[] = { {2}, {6}, {8}, {10}, {11}, {2} };\n+  const X z[] = { {2}, {2}, {6}, {8}, {10} };\n+  auto [in, out] = ranges::move_backward(x, ranges::end(y));\n+  ok &= ranges::equal(x, x+5, y+1, y+6);\n+  ok &= (in == x+5);\n+  ok &= (out == y+1);\n+  ok &= (y[0].i == 2);\n+  ok &= ranges::equal(x, z);\n+  ok &= ranges::count(x, 1, &X::moved) == 5;\n+  ok &= ranges::count(y, 0, &X::moved) == 6;\n+  return ok;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  static_assert(test03());\n+}"}, {"sha": "e69b551a56bed741fae06948bf84f33514eafd01", "filename": "libstdc++-v3/testsuite/25_algorithms/next_permutation/constrained.cc", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fnext_permutation%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fnext_permutation%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fnext_permutation%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,83 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::bidirectional_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+void\n+test01()\n+{\n+  int x[] = {1, 2, 3, 4, 5};\n+  int y[] = {1, 2, 3, 4, 5};\n+\n+  for (int i = 0; i <= 5; i++)\n+    {\n+      test_container<int, bidirectional_iterator_wrapper> cx(x, x+i);\n+      test_container<int, bidirectional_iterator_wrapper> cy(y, y+i);\n+      for (int j = 0; ; j++)\n+\t{\n+\t  auto found1 = std::next_permutation(cx.begin(), cx.end());\n+\t  auto [found2,last] = ranges::next_permutation(cy.begin(), cy.end());\n+\t  VERIFY( found1 == found2 );\n+\t  VERIFY( ranges::equal(cx, cy) );\n+\t  if (!found2)\n+\t    break;\n+\t}\n+    }\n+}\n+\n+void\n+test02()\n+{\n+  int x[] = {5, 4, 3, 2, 1};\n+  test_range<int, bidirectional_iterator_wrapper> rx(x);\n+  auto [found,last] = ranges::next_permutation(rx, ranges::greater{});\n+  VERIFY( found && last == rx.end() );\n+  VERIFY( last == rx.end() );\n+  VERIFY( ranges::equal(rx, (int[]){5,4,3,1,2}) );\n+  ranges::next_permutation(rx, {}, [] (int a) { return -a; });\n+  VERIFY( ranges::equal(rx, (int[]){5,4,2,3,1}) );\n+\n+  VERIFY( !ranges::next_permutation(x, x).found );\n+  VERIFY( !ranges::next_permutation(x, x+1).found );\n+}\n+\n+constexpr bool\n+test03()\n+{\n+  int x[] = {1,2,3};\n+  ranges::next_permutation(x);\n+  return ranges::equal(x, (int[]){1,3,2});\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  static_assert(test03());\n+}"}, {"sha": "55617a97a7b7b31d4c6221a70950beeb63fcef74", "filename": "libstdc++-v3/testsuite/25_algorithms/none_of/constrained.cc", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fnone_of%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fnone_of%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fnone_of%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,88 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::input_iterator_wrapper;\n+using __gnu_test::forward_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+struct X { int i; };\n+\n+struct XLess\n+{\n+  int val;\n+  bool operator()(X& x) const { return x.i < val; }\n+};\n+\n+struct ILess\n+{\n+  int val;\n+  bool operator()(int& i) const { return i < val; }\n+};\n+\n+template<typename T>\n+struct NotZero\n+{\n+  bool operator()(T& t) const { return t != 0; }\n+};\n+\n+void\n+test01()\n+{\n+  X x[] = { {2}, {4}, {6}, {8}, {10}, {11} };\n+\n+  VERIFY( !ranges::none_of(x, x+6, XLess{3}) );\n+  VERIFY( !ranges::none_of(x, x+6, ILess{3}, &X::i) );\n+  VERIFY( ranges::none_of(x+1, x+6, XLess{3}) );\n+  VERIFY( ranges::none_of(x+1, x+6, ILess{3}, &X::i) );\n+  VERIFY( !ranges::none_of(x, XLess{5}) );\n+  VERIFY( !ranges::none_of(x, ILess{5}, &X::i) );\n+\n+  test_container<X, forward_iterator_wrapper> c(x);\n+  VERIFY( !ranges::none_of(c, NotZero<int>{}, &X::i) );\n+\n+  test_range<X, input_iterator_wrapper> r(x);\n+  VERIFY( !ranges::none_of(r, NotZero<int>{}, &X::i) );\n+  VERIFY( !ranges::none_of(r, NotZero<X* const>{}, [](X& x) { return &x; }) );\n+}\n+\n+struct Y { int i; int j; };\n+\n+void\n+test02()\n+{\n+  static constexpr Y y[] = { {1,2}, {2,4}, {3,6} };\n+  static_assert(!ranges::none_of(y, [](int i) { return i%2 == 0; }, &Y::i));\n+  static_assert(!ranges::none_of(y, [](const Y& y) { return y.i + y.j == 3; }));\n+  static_assert(ranges::none_of(y, [](const Y& y) { return y.i == y.j; }));\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "34f3013b199dfbc4f6fedbb722f0f7bb57fa1500", "filename": "libstdc++-v3/testsuite/25_algorithms/nth_element/constrained.cc", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fnth_element%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fnth_element%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fnth_element%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,76 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+// { dg-require-cstdint \"\" }\n+\n+#include <algorithm>\n+#include <random>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::random_access_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+void\n+test01()\n+{\n+  int x[50];\n+  std::iota(x, x+50, 0);\n+\n+  auto pred = std::greater{};\n+  auto proj = [] (int a) { return -a; };\n+  for (int i = 0; i < 50; i++)\n+    {\n+      test_range<int, random_access_iterator_wrapper> rx(x);\n+      std::ranlux48_base g(i);\n+      ranges::shuffle(rx, g);\n+\n+      auto result = ranges::nth_element(rx, rx.begin()+i, pred, proj);\n+      VERIFY( result == rx.end() );\n+      VERIFY( x[i] == i );\n+      for (int j = 0; j < i; j++)\n+\tfor (int k = i; k < 50; k++)\n+\t  VERIFY( !pred(proj(x[k]), proj(x[j])) );\n+\n+      result = ranges::nth_element(rx, rx.begin()+i, pred);\n+      VERIFY( result == rx.end() );\n+      VERIFY( x[i] == 49-i );\n+      for (int j = 0; j < i; j++)\n+\tfor (int k = i; k < 50; k++)\n+\t  VERIFY( !pred(x[k], x[j]) );\n+    }\n+}\n+\n+constexpr bool\n+test02()\n+{\n+  int x[] = {5,2,1,3,4};\n+  ranges::nth_element(x, x+3);\n+  return x[3] == 4;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  static_assert(test02());\n+}"}, {"sha": "430e3c0b61bbf40857aa5c746f2f269a9602ad2b", "filename": "libstdc++-v3/testsuite/25_algorithms/partial_sort/constrained.cc", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpartial_sort%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpartial_sort%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpartial_sort%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,84 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+// { dg-require-cstdint \"\" }\n+\n+#include <algorithm>\n+#include <random>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::random_access_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+void\n+test01()\n+{\n+  for (unsigned size = 0; size < 50; ++size)\n+    {\n+      std::vector<int> vref(size);\n+      std::iota(vref.begin(), vref.end(), 0);\n+      std::vector<int> v1(vref), v2(vref);\n+      test_container<int, random_access_iterator_wrapper> c\n+\t= {&v1[0], &v1[0] + size};\n+      test_range<int, random_access_iterator_wrapper> r\n+\t= {&v2[0], &v2[0] + size};\n+\n+      std::ranlux48_base g1(size), g2(size + 1);\n+      ranges::shuffle(c, g1);\n+      ranges::shuffle(ranges::begin(r), ranges::end(r), g2);\n+\n+      for (unsigned middle = 0; middle < std::min(size, 10U); ++middle)\n+\t{\n+\t  auto res1 = ranges::partial_sort(c.begin(), c.begin()+middle, c.end(),\n+\t\t\t\t\t   {}, std::negate<>{});\n+\t  VERIFY( res1 == c.end() );\n+\n+\t  auto res2 = ranges::partial_sort(r,\n+\t\t\t\t\t   ranges::begin(r)+middle,\n+\t\t\t\t\t   ranges::greater{});\n+\t  VERIFY( res2 == ranges::end(r) );\n+\n+\t  VERIFY( ranges::equal(c.begin(), c.begin()+middle,\n+\t\t\t\tr.begin(), r.begin()+middle) );\n+\t  VERIFY( ranges::equal(c.begin(), c.begin()+middle,\n+\t\t\t\tvref.rbegin(), vref.rbegin()+middle) );\n+\t}\n+    }\n+}\n+\n+constexpr bool\n+test02()\n+{\n+  int x[] = { 5,4,1,3,2 };\n+  const int y[] = { 1,2,3 };\n+  ranges::partial_sort(x, x+3, x+5);\n+  return ranges::equal(x, x+3, y, y+3);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  static_assert(test02());\n+}"}, {"sha": "6b586f885dd352aa96c73b04c883e49a367b942a", "filename": "libstdc++-v3/testsuite/25_algorithms/partial_sort_copy/constrained.cc", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpartial_sort_copy%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpartial_sort_copy%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpartial_sort_copy%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,97 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+// { dg-require-cstdint \"\" }\n+\n+#include <algorithm>\n+#include <random>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::input_iterator_wrapper;\n+using __gnu_test::forward_iterator_wrapper;\n+using __gnu_test::random_access_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+void\n+test01()\n+{\n+  for (unsigned size = 0; size < 50; ++size)\n+    {\n+      std::vector<int> vref(size);\n+      std::iota(vref.begin(), vref.end(), 0);\n+      std::vector<int> v1(vref), v2(vref);\n+\n+      std::ranlux48_base g1(size), g2(size + 1);\n+      ranges::shuffle(v1, g1);\n+      ranges::shuffle(v2, g2);\n+\n+      for (unsigned middle = 0; middle < 10; ++middle)\n+\t{\n+\t  test_container<int, forward_iterator_wrapper> c\n+\t    = {&v1[0], &v1[0] + size};\n+\t  test_range<int, input_iterator_wrapper> r\n+\t    = {&v2[0], &v2[0] + size};\n+\n+\t  std::vector<int> o1(middle), o2(middle);\n+\t  test_range<int, random_access_iterator_wrapper> w1\n+\t    = {&o1[0], &o1[0]+middle};\n+\t  test_range<int, random_access_iterator_wrapper> w2\n+\t    = {&o2[0], &o2[0]+middle};\n+\n+\t  auto [in1, out1] = ranges::partial_sort_copy(c.begin(), c.end(),\n+\t\t\t\t\t\t       w1.begin(), w1.end(),\n+\t\t\t\t\t\t       {},\n+\t\t\t\t\t\t       std::negate<>{},\n+\t\t\t\t\t\t       std::negate<>{});\n+\t  VERIFY( in1 == c.end() );\n+\t  VERIFY( out1 == w1.begin() + std::min(size, middle) );\n+\n+\t  auto [in2,out2] = ranges::partial_sort_copy(r, w2, ranges::greater{});\n+\t  VERIFY( in2 == ranges::end(r) );\n+\t  VERIFY( out2 == w2.begin() + std::min(size, middle) );\n+\n+\t  VERIFY( ranges::equal(w1.begin(), out1, w2.begin(), out2) );\n+\t  VERIFY( ranges::equal(w1.begin(), out1,\n+\t\t\t\tvref.rbegin(),\n+\t\t\t\tvref.rbegin()+(out1-w1.begin())) );\n+\t}\n+    }\n+}\n+\n+constexpr bool\n+test02()\n+{\n+  int x[] = { 5,4,1,3,2 };\n+  int w[3];\n+  const int y[] = { 1,2,3 };\n+  ranges::partial_sort_copy(x, x+5, w, w+3);\n+  return ranges::equal(w, y);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  static_assert(test02());\n+}"}, {"sha": "4e5fa5e32cdf69b928a8d5c565f509e1546563ca", "filename": "libstdc++-v3/testsuite/25_algorithms/partition/constrained.cc", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpartition%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpartition%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpartition%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,71 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::forward_iterator_wrapper;\n+using __gnu_test::bidirectional_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+template<template<typename> typename wrapper>\n+void\n+test01()\n+{\n+    {\n+      int x[] = {1,2,3,4,5,6,7,8,9,10};\n+      test_container<int, wrapper> cx(x);\n+      auto range = ranges::partition(cx, [] (int a) { return a%2==0; });\n+      VERIFY( range.begin().ptr == x+5 );\n+      VERIFY( range.end().ptr == x+10 );\n+      VERIFY( ranges::is_partitioned(cx, [] (int a) { return a%2==0; }) );\n+    }\n+\n+    {\n+      int x[] = {1,2,3,4,5,6,7,8};\n+      test_range<int, wrapper> rx(x);\n+      auto range = ranges::partition(rx,\n+\t\t\t\t     [] (int a) { return a%2==0; },\n+\t\t\t\t     [] (int a) { return a+1; });\n+      VERIFY( range.begin().ptr == x+4 );\n+      VERIFY( range.end().ptr == x+8 );\n+      VERIFY( ranges::is_partitioned(rx, [] (int a) { return a%2==1; }) );\n+    }\n+}\n+\n+constexpr bool\n+test02()\n+{\n+  int x[] = {1,2,3,4,5,6,7,8,9,10};\n+  auto range = ranges::partition(x, x+9, [] (int a) { return a < 100; });\n+  return (range.begin() == x+9 && range.end() == x+9);\n+}\n+\n+int\n+main()\n+{\n+  test01<forward_iterator_wrapper>();\n+  test01<bidirectional_iterator_wrapper>();\n+  static_assert(test02());\n+}"}, {"sha": "8ed6e24d451e30eedf2f42b8de723594dc90ef85", "filename": "libstdc++-v3/testsuite/25_algorithms/partition_copy/constrained.cc", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpartition_copy%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpartition_copy%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpartition_copy%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,81 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::input_iterator_wrapper;\n+using __gnu_test::output_iterator_wrapper;\n+using __gnu_test::forward_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+void\n+test01()\n+{\n+    {\n+      int x[] = {1,2,3,4,5,6,7,8,9,10,11};\n+      int y[5], z[6];\n+      test_container<int, forward_iterator_wrapper> cx(x);\n+      test_container<int, forward_iterator_wrapper> cy(y), cz(z);\n+      auto pred = [] (int a) { return a%2==0; };\n+      auto [in,out_true,out_false]\n+\t= ranges::partition_copy(cx, cy.begin(), cz.begin(), pred);\n+      VERIFY( in.ptr == x+11 );\n+      VERIFY( out_true.ptr == y+5 );\n+      VERIFY( out_false.ptr == z+6 );\n+      VERIFY( ranges::all_of(cy, pred) );\n+      VERIFY( ranges::none_of(cz, pred) );\n+    }\n+\n+    {\n+      int x[] = {1,2,3,4,5,6,7,8,9,10,11};\n+      int y[6], z[5];\n+      test_range<int, input_iterator_wrapper> cx(x);\n+      test_range<int, output_iterator_wrapper> cy(y), cz(z);\n+      auto pred = [] (int a) { return a%2==0; };\n+      auto proj = [] (int a) { return a+1; };\n+      auto [in,out_true,out_false]\n+\t= ranges::partition_copy(cx, cy.begin(), cz.begin(), pred, proj);\n+      VERIFY( in.ptr == x+11 );\n+      VERIFY( out_true.ptr == y+6 );\n+      VERIFY( out_false.ptr == z+5 );\n+      VERIFY( ranges::none_of(y, pred) );\n+      VERIFY( ranges::all_of(z, pred) );\n+    }\n+}\n+\n+constexpr bool\n+test02()\n+{\n+  int x[] = {1,2,3,4,5,6,7,8,9,10};\n+  auto range = ranges::partition(x, x+9, [] (int a) { return a < 100; });\n+  return (range.begin() == x+9 && range.end() == x+9);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  static_assert(test02());\n+}"}, {"sha": "2a430f234381a9f6088240ed677472ec1bea285a", "filename": "libstdc++-v3/testsuite/25_algorithms/partition_point/constrained.cc", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpartition_point%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpartition_point%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpartition_point%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,67 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::forward_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+void\n+test01()\n+{\n+  for (int k = 1; k <= 7; k++)\n+    {\n+      int x[] = {1,2,3,4,5,6,7};\n+      test_container<int, forward_iterator_wrapper> cx(x);\n+      auto pred = [&] (int a) { return a <= k; };\n+      auto middle = ranges::partition_point(cx, pred);\n+      VERIFY( middle.ptr == x+k );\n+    }\n+\n+  for (int k = 1; k <= 8; k++)\n+    {\n+      int x[] = {1,2,3,4,5,6,7,8};\n+      test_range<int, forward_iterator_wrapper> rx(x);\n+      auto pred = [&] (int a) { return a > -k; };\n+      auto proj = [] (int a) { return -a; };\n+      auto middle = ranges::partition_point(rx, pred, proj);\n+      VERIFY( middle.ptr == x+k-1 );\n+    }\n+}\n+\n+constexpr bool\n+test02()\n+{\n+  int x[] = {1,2,3,4,5};\n+  return (ranges::partition_point(x, x+5, [] (int a) { return a < 6; }) == x+5\n+\t  && ranges::partition_point(x, x+5, [] (int a) { return a < 0; }) == x);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  static_assert(test02());\n+}"}, {"sha": "25bbad9be0ce2522115757e65c613579552a6443", "filename": "libstdc++-v3/testsuite/25_algorithms/prev_permutation/constrained.cc", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fprev_permutation%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fprev_permutation%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fprev_permutation%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,84 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::bidirectional_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+void\n+test01()\n+{\n+  int x[] = {5, 4, 3, 2, 1};\n+  int y[] = {5, 4, 3, 2, 1};\n+\n+  for (int i = 0; i <= 5; i++)\n+    {\n+      test_container<int, bidirectional_iterator_wrapper> cx(x, x+i);\n+      test_container<int, bidirectional_iterator_wrapper> cy(y, y+i);\n+      for (int j = 0; ; j++)\n+\t{\n+\t  auto found1 = std::prev_permutation(cx.begin(), cx.end());\n+\t  auto [found2,last] = ranges::prev_permutation(cy.begin(), cy.end());\n+\t  VERIFY( found1 == found2 );\n+\t  VERIFY( ranges::equal(cx, cy) );\n+\t  if (!found2)\n+\t    break;\n+\t}\n+    }\n+}\n+\n+void\n+test02()\n+{\n+  int x[] = {1, 2, 3, 4, 5};\n+  test_range<int, bidirectional_iterator_wrapper> rx(x);\n+  auto [found,last] = ranges::prev_permutation(rx, ranges::greater{});\n+  VERIFY( found && last == rx.end() );\n+  VERIFY( last == rx.end() );\n+  VERIFY( ranges::equal(rx, (int[]){1,2,3,5,4}) );\n+  ranges::prev_permutation(rx, {}, [] (int a) { return -a; });\n+  VERIFY( ranges::equal(rx, (int[]){1,2,4,3,5}) );\n+\n+  VERIFY( !ranges::prev_permutation(x, x).found );\n+  VERIFY( !ranges::prev_permutation(x, x+1).found );\n+}\n+\n+constexpr bool\n+test03()\n+{\n+  int x[] = {3,2,1};\n+  ranges::prev_permutation(x);\n+  return ranges::equal(x, (int[]){3,1,2});\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  static_assert(test03());\n+}\n+"}, {"sha": "39a002f3cb6d4376a7284b5217b1a8092c1fa633", "filename": "libstdc++-v3/testsuite/25_algorithms/remove/constrained.cc", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fremove%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fremove%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fremove%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,97 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::input_iterator_wrapper;\n+using __gnu_test::output_iterator_wrapper;\n+using __gnu_test::forward_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+struct X\n+{\n+  int i;\n+};\n+\n+void\n+test01()\n+{\n+  int x[5] = { 1, 2, 3, 4, 5 };\n+  const int y[4] = { 1, 2, 4, 5 };\n+  auto res = ranges::remove(x, 3);\n+  VERIFY( res.begin() == x+4 && res.end() == x+5 );\n+  VERIFY( ranges::equal(x, x+4, y, y+4) );\n+}\n+\n+void\n+test02()\n+{\n+  int x[1];\n+  test_container<int, forward_iterator_wrapper> c(x, x);\n+  auto res = ranges::remove(c, 1);\n+  VERIFY( res.begin().ptr == x && res.end().ptr == x );\n+}\n+\n+void\n+test03()\n+{\n+  int x[1] = {1};\n+  test_container<int, forward_iterator_wrapper> c(x);\n+  auto res = ranges::remove(c, 0);\n+  VERIFY( res.begin().ptr == x+1 && res.end().ptr == x+1 );\n+  res = ranges::remove(c, 1);\n+  VERIFY( res.begin().ptr == x && res.end().ptr == x+1 );\n+}\n+\n+void\n+test04()\n+{\n+  X x[8] = { {0}, {1}, {0}, {1}, {0}, {0}, {1}, {1} };\n+  const int y[4] = { 0, 0, 0, 0 };\n+  test_container<X, forward_iterator_wrapper> c(x);\n+  auto res = ranges::remove(c, 1, &X::i);\n+  VERIFY( res.begin().ptr == x+4 && res.end().ptr == x+8 );\n+  VERIFY( ranges::equal(x, x+4, y, y+4, {}, &X::i) );\n+}\n+\n+constexpr bool\n+test05()\n+{\n+  int x[6] = { 3, 2, 3, 3, 5, 3 };\n+  const int y[2] = { 2, 5 };\n+  auto res = ranges::remove(x, 3);\n+  return ranges::equal(x, res.begin(), y, y+2);\n+}\n+\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+  static_assert(test05());\n+}"}, {"sha": "0cf65a727b8acbcc9c43b37828d24278610ae3fb", "filename": "libstdc++-v3/testsuite/25_algorithms/remove_copy/constrained.cc", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fremove_copy%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fremove_copy%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fremove_copy%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,109 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::input_iterator_wrapper;\n+using __gnu_test::output_iterator_wrapper;\n+using __gnu_test::forward_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+struct X\n+{\n+  int i;\n+\n+  friend constexpr bool\n+  operator==(const X& a, const X& b)\n+  {\n+    return a.i == b.i;\n+  }\n+};\n+\n+void\n+test01()\n+{\n+    {\n+      const X x[6] = { {2}, {2}, {6}, {8}, {10}, {11} };\n+      X y[4];\n+      X z[4] = { {2}, {2}, {6}, {10} };\n+      auto [in,out] = ranges::remove_copy(x, x+5, y, 8, &X::i);\n+      VERIFY( in == x+5 && out == y+4 );\n+      VERIFY( ranges::equal(y, z) );\n+    }\n+\n+    {\n+      const X x[6] = { {2}, {2}, {6}, {8}, {10}, {11} };\n+      X y[5];\n+      X z[5] = { {2}, {2}, {6}, {8}, {10} };\n+      auto [in,out] = ranges::remove_copy(x, x+5, y, 11, &X::i);\n+      VERIFY( in == x+5 && out == y+5 );\n+      VERIFY( ranges::equal(x, x+5, y, y+5) && ranges::equal(y, z) );\n+    }\n+\n+    {\n+      X x[6] = { {2}, {2}, {6}, {8}, {10}, {2} };\n+      X y[3];\n+      X z[3] = { {6}, {8}, {10} };\n+      test_container<X, forward_iterator_wrapper> cx(x), cy(y), cz(z);\n+      auto [in, out] = ranges::remove_copy(cx, cy.begin(), 2, &X::i);\n+      VERIFY( in == cx.end() && out == cy.end() );\n+      VERIFY( ranges::equal(cy, cz) );\n+    }\n+\n+    {\n+      X x[6] = { {2}, {2}, {6}, {8}, {10}, {11} };\n+      X y[4];\n+      const X z[4] = { {6}, {8}, {10}, {11} };\n+      test_range<X, input_iterator_wrapper> cx(x);\n+      test_range<X, output_iterator_wrapper> cy(y);\n+      auto [in, out] = ranges::remove_copy(cx, cy.begin(), 2, &X::i);\n+      VERIFY( in == cx.end() && out == cy.end() );\n+      VERIFY( ranges::equal(y, z) );\n+    }\n+}\n+\n+struct Y { int i; int j; };\n+\n+constexpr bool\n+test02()\n+{\n+  bool ok = true;\n+  Y x[3] = { {3,2}, {2,4}, {3,6} };\n+  Y y[1];\n+  Y z[1] = { {2,4} };\n+  auto [in, out] = ranges::remove_copy(x, y, 3, &Y::i);\n+  ok &= in == x+3;\n+  ok &= out == y+1;\n+  ok &= ranges::equal(y, z, {}, &Y::i, &Y::i);\n+  ok &= ranges::equal(y, z, {}, &Y::j, &Y::j);\n+  return ok;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  static_assert(test02());\n+}"}, {"sha": "b7c239ff39784244e1a6d37a297e1bcce5fe46bc", "filename": "libstdc++-v3/testsuite/25_algorithms/remove_copy_if/constrained.cc", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fremove_copy_if%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fremove_copy_if%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fremove_copy_if%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,113 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::input_iterator_wrapper;\n+using __gnu_test::output_iterator_wrapper;\n+using __gnu_test::forward_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+struct X\n+{\n+  int i;\n+\n+  friend constexpr bool\n+  operator==(const X& a, const X& b)\n+  {\n+    return a.i == b.i;\n+  }\n+};\n+\n+void\n+test01()\n+{\n+  auto is_negative_p = [] (int a) { return a < 0; };\n+  auto is_two_p = [] (int a) { return a == 2; };\n+\n+    {\n+      const X x[6] = { {2}, {2}, {6}, {8}, {2}, {11} };\n+      X y[2];\n+      X z[2] = { {6}, {8} };\n+      auto [in, out] = ranges::remove_copy_if(x, x+5, y, is_two_p, &X::i);\n+      VERIFY( in == x+5 && out == y+2 );\n+      VERIFY( ranges::equal(y, z) );\n+    }\n+\n+    {\n+      const X x[6] = { {2}, {2}, {6}, {8}, {10}, {11} };\n+      X y[5];\n+      X z[5] = { {2}, {2}, {6}, {8}, {10} };\n+      auto [in, out] = ranges::remove_copy_if(x, x+5, y, is_negative_p, &X::i);\n+      VERIFY( in == x+5 && out == y+5 );\n+      VERIFY( ranges::equal(x, x+5, y, y+5) && ranges::equal(y, z) );\n+    }\n+\n+    {\n+      X x[6] = { {2}, {2}, {6}, {8}, {10}, {11} };\n+      X y[4];\n+      X z[4] = { {6}, {8}, {10}, {11} };\n+      test_container<X, forward_iterator_wrapper> cx(x), cy(y), cz(z);\n+      auto [in, out] = ranges::remove_copy_if(cx, cy.begin(), is_two_p, &X::i);\n+      VERIFY( in == cx.end() && out == cy.end() );\n+      VERIFY( ranges::equal(cy, cz) );\n+    }\n+\n+    {\n+      X x[6] = { {2}, {2}, {6}, {8}, {10}, {11} };\n+      X y[4];\n+      const X z[4] = { {6}, {8}, {10}, {11} };\n+      test_range<X, input_iterator_wrapper> cx(x);\n+      test_range<X, output_iterator_wrapper> cy(y);\n+      auto [in, out] = ranges::remove_copy_if(cx, cy.begin(), is_two_p, &X::i);\n+      VERIFY( in == cx.end() && out == cy.end() );\n+      VERIFY( ranges::equal(y, z) );\n+    }\n+}\n+\n+struct Y { int i; int j; };\n+\n+constexpr bool\n+test02()\n+{\n+  bool ok = true;\n+  Y x[3] = { {3,2}, {2,4}, {3,6} };\n+  Y y[1];\n+  Y z[1] = { {2,4} };\n+  auto [in, out]\n+    = ranges::remove_copy_if(x, y, [] (int a) { return a%2 == 1; }, &Y::i);\n+  ok &= in == x+3;\n+  ok &= out == y+1;\n+  ok &= ranges::equal(y, z, {}, &Y::i, &Y::i);\n+  ok &= ranges::equal(y, z, {}, &Y::j, &Y::j);\n+  return ok;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  static_assert(test02());\n+}"}, {"sha": "1abc231ab93a18fc652fdaf359d53c488ba1334a", "filename": "libstdc++-v3/testsuite/25_algorithms/remove_if/constrained.cc", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fremove_if%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fremove_if%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fremove_if%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,97 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::input_iterator_wrapper;\n+using __gnu_test::output_iterator_wrapper;\n+using __gnu_test::forward_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+struct X\n+{\n+  int i;\n+};\n+\n+void\n+test01()\n+{\n+  int x[5] = { 1, 2, 3, 4, 5 };\n+  const int y[4] = { 1, 2, 4, 5 };\n+  auto res = ranges::remove_if(x, [] (int a) { return a == 3; });\n+  VERIFY( res.begin() == x+4 && res.end() == x+5 );\n+  VERIFY( ranges::equal(x, x+4, y, y+4) );\n+}\n+\n+void\n+test02()\n+{\n+  int x[1];\n+  test_container<int, forward_iterator_wrapper> c(x, x);\n+  auto res = ranges::remove_if(c, [] (int a) { return a == 1; });\n+  VERIFY( res.begin().ptr == x && res.end().ptr == x );\n+}\n+\n+void\n+test03()\n+{\n+  int x[1] = {1};\n+  test_container<int, forward_iterator_wrapper> c(x);\n+  auto res = ranges::remove_if(c, [] (int a) { return a == 0; });\n+  VERIFY( res.begin().ptr == x+1 && res.end().ptr == x+1 );\n+  res = ranges::remove_if(c, [] (int a) { return a == 1; });\n+  VERIFY( res.begin().ptr == x && res.end().ptr == x+1 );\n+}\n+\n+void\n+test04()\n+{\n+  X x[8] = { {0}, {1}, {0}, {1}, {0}, {0}, {1}, {1} };\n+  const int y[4] = { 0, 0, 0, 0 };\n+  test_range<X, forward_iterator_wrapper> c(x);\n+  auto res = ranges::remove_if(c, [] (int a) { return a == 1; }, &X::i);\n+  VERIFY( res.begin().ptr == x+4 && res.end().ptr == x+8 );\n+  VERIFY( ranges::equal(x, x+4, y, y+4, {}, &X::i) );\n+}\n+\n+constexpr bool\n+test05()\n+{\n+  int x[6] = { 3, 2, 3, 3, 5, 3 };\n+  const int y[2] = { 2, 5 };\n+  auto res = ranges::remove_if(x, [] (int a) { return a == 3; });\n+  return ranges::equal(x, res.begin(), y, y+2);\n+}\n+\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+  static_assert(test05());\n+}"}, {"sha": "3546872b72ff7ccc29c556b82fd3cba2959a78c5", "filename": "libstdc++-v3/testsuite/25_algorithms/replace/constrained.cc", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Freplace%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Freplace%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Freplace%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,104 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::input_iterator_wrapper;\n+using __gnu_test::forward_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+struct X\n+{\n+  int i;\n+\n+  friend constexpr bool\n+  operator==(const X& a, const X& b)\n+  {\n+    return a.i == b.i;\n+  }\n+};\n+\n+void\n+test01()\n+{\n+    {\n+      X x[6] = { {2}, {2}, {6}, {8}, {10}, {11} };\n+      X y[6] = { {2}, {2}, {6}, {9}, {10}, {11} };\n+      auto res = ranges::replace(x, x+5, 8, X{9}, &X::i);\n+      VERIFY( res == x+5 );\n+      VERIFY( ranges::equal(x, y) );\n+    }\n+\n+    {\n+      X x[6] = { {2}, {2}, {6}, {8}, {10}, {11} };\n+      X y[6] = { {2}, {2}, {6}, {8}, {10}, {11} };\n+      auto res = ranges::replace(x, x+5, 7, X{9}, &X::i);\n+      VERIFY( res == x+5 );\n+      VERIFY( ranges::equal(x, y) );\n+    }\n+\n+    {\n+      X x[6] = { {2}, {2}, {6}, {8}, {10}, {11} };\n+      X y[6] = { {7}, {7}, {6}, {8}, {10}, {11} };\n+      test_container<X, forward_iterator_wrapper> cx(x), cy(y);\n+      auto res = ranges::replace(cx, 2, X{7}, &X::i);\n+      VERIFY( res == cx.end() );\n+      VERIFY( ranges::equal(cx, cy) );\n+    }\n+\n+    {\n+      int x[6] = { {2}, {2}, {6}, {8}, {10}, {2} };\n+      int y[6] = { {7}, {7}, {6}, {8}, {10}, {7} };\n+      test_range<int, input_iterator_wrapper> rx(x), ry(y);\n+      auto res = ranges::replace(rx, 2, 7);\n+      VERIFY( res == rx.end() );\n+\n+      rx.bounds.first = x;\n+      ry.bounds.first = y;\n+      VERIFY( ranges::equal(rx, ry) );\n+    }\n+}\n+\n+struct Y { int i; int j; };\n+\n+constexpr bool\n+test02()\n+{\n+  bool ok = true;\n+  Y x[] = { {3,2}, {2,4}, {3,6} };\n+  Y y[] = { {4,5}, {2,4}, {4,5} };\n+  auto res = ranges::replace(x, 3, Y{4,5}, &Y::i);\n+  ok &= res == x+3;\n+  ok &= ranges::equal(x, y, {}, &Y::i, &Y::i);\n+  ok &= ranges::equal(x, y, {}, &Y::j, &Y::j);\n+  return ok;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  static_assert(test02());\n+}"}, {"sha": "12e76a4cfdf3e62bfb856ce704b95a22119bbe97", "filename": "libstdc++-v3/testsuite/25_algorithms/replace_copy/constrained.cc", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Freplace_copy%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Freplace_copy%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Freplace_copy%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,109 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::input_iterator_wrapper;\n+using __gnu_test::output_iterator_wrapper;\n+using __gnu_test::forward_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+struct X\n+{\n+  int i;\n+\n+  friend constexpr bool\n+  operator==(const X& a, const X& b)\n+  {\n+    return a.i == b.i;\n+  }\n+};\n+\n+void\n+test01()\n+{\n+    {\n+      const X x[6] = { {2}, {2}, {6}, {8}, {10}, {11} };\n+      X y[5];\n+      X z[5] = { {2}, {2}, {6}, {9}, {10} };\n+      auto [in,out] = ranges::replace_copy(x, x+5, y, 8, X{9}, &X::i);\n+      VERIFY( in == x+5 && out == y+5 );\n+      VERIFY( ranges::equal(y, z) );\n+    }\n+\n+    {\n+      const X x[6] = { {2}, {2}, {6}, {8}, {10}, {11} };\n+      X y[5];\n+      X z[5] = { {2}, {2}, {6}, {8}, {10} };\n+      auto [in,out] = ranges::replace_copy(x, x+5, y, 7, X{9}, &X::i);\n+      VERIFY( in == x+5 && out == y+5 );\n+      VERIFY( ranges::equal(x, x+5, y, y+5) && ranges::equal(y, z) );\n+    }\n+\n+    {\n+      X x[6] = { {2}, {2}, {6}, {8}, {10}, {11} };\n+      X y[6];\n+      X z[6] = { {7}, {7}, {6}, {8}, {10}, {11} };\n+      test_container<X, forward_iterator_wrapper> cx(x), cy(y), cz(z);\n+      auto [in, out] = ranges::replace_copy(cx, cy.begin(), 2, X{7}, &X::i);\n+      VERIFY( in == cx.end() && out == cy.end() );\n+      VERIFY( ranges::equal(cy, cz) );\n+    }\n+\n+    {\n+      X x[6] = { {2}, {2}, {6}, {8}, {10}, {11} };\n+      X y[6];\n+      const X z[6] = { {7}, {7}, {6}, {8}, {10}, {11} };\n+      test_range<X, input_iterator_wrapper> cx(x);\n+      test_range<X, output_iterator_wrapper> cy(y);\n+      auto [in, out] = ranges::replace_copy(cx, cy.begin(), 2, X{7}, &X::i);\n+      VERIFY( in == cx.end() && out == cy.end() );\n+      VERIFY( ranges::equal(y, z) );\n+    }\n+}\n+\n+struct Y { int i; int j; };\n+\n+constexpr bool\n+test02()\n+{\n+  bool ok = true;\n+  Y x[] = { {3,2}, {2,4}, {3,6} };\n+  Y y[] = { {4,5}, {2,4}, {4,5} };\n+  Y z[] = { {4,5}, {2,4}, {4,5} };\n+  auto [in, out] = ranges::replace_copy(x, y, 3, Y{4,5}, &Y::i);\n+  ok &= in == x+3;\n+  ok &= out == y+3;\n+  ok &= ranges::equal(y, z, {}, &Y::i, &Y::i);\n+  ok &= ranges::equal(y, z, {}, &Y::j, &Y::j);\n+  return ok;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  static_assert(test02());\n+}"}, {"sha": "9186a0a3d6ca5324c4760aa497f37f409a1baaf8", "filename": "libstdc++-v3/testsuite/25_algorithms/replace_copy_if/constrained.cc", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Freplace_copy_if%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Freplace_copy_if%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Freplace_copy_if%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,118 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::input_iterator_wrapper;\n+using __gnu_test::output_iterator_wrapper;\n+using __gnu_test::forward_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+struct X\n+{\n+  int i;\n+\n+  friend constexpr bool\n+  operator==(const X& a, const X& b)\n+  {\n+    return a.i == b.i;\n+  }\n+};\n+\n+void\n+test01()\n+{\n+  auto is_negative_p = [] (int a) { return a < 0; };\n+  auto is_two_p = [] (int a) { return a == 2; };\n+\n+    {\n+      const X x[6] = { {2}, {2}, {6}, {8}, {10}, {11} };\n+      X y[5];\n+      X z[5] = { {9}, {9}, {6}, {8}, {10} };\n+      auto [in, out] = ranges::replace_copy_if(x, x+5, y,\n+\t\t\t\t\t       is_two_p, X{9}, &X::i);\n+      VERIFY( in == x+5 && out == y+5 );\n+      VERIFY( ranges::equal(y, z) );\n+    }\n+\n+    {\n+      const X x[6] = { {2}, {2}, {6}, {8}, {10}, {11} };\n+      X y[5];\n+      X z[5] = { {2}, {2}, {6}, {8}, {10} };\n+      auto [in, out] = ranges::replace_copy_if(x, x+5, y,\n+\t\t\t\t\t       is_negative_p, X{9}, &X::i);\n+      VERIFY( in == x+5 && out == y+5 );\n+      VERIFY( ranges::equal(x, x+5, y, y+5) && ranges::equal(y, z) );\n+    }\n+\n+    {\n+      X x[6] = { {2}, {2}, {6}, {8}, {10}, {11} };\n+      X y[6];\n+      X z[6] = { {7}, {7}, {6}, {8}, {10}, {11} };\n+      test_container<X, forward_iterator_wrapper> cx(x), cy(y), cz(z);\n+      auto [in, out] = ranges::replace_copy_if(cx, cy.begin(),\n+\t\t\t\t\t       is_two_p, X{7}, &X::i);\n+      VERIFY( in == cx.end() && out == cy.end() );\n+      VERIFY( ranges::equal(cy, cz) );\n+    }\n+\n+    {\n+      X x[6] = { {2}, {2}, {6}, {8}, {10}, {11} };\n+      X y[6];\n+      const X z[6] = { {7}, {7}, {6}, {8}, {10}, {11} };\n+      test_range<X, input_iterator_wrapper> cx(x);\n+      test_range<X, output_iterator_wrapper> cy(y);\n+      auto [in, out] = ranges::replace_copy_if(cx, cy.begin(),\n+\t\t\t\t\t       is_two_p, X{7}, &X::i);\n+      VERIFY( in == cx.end() && out == cy.end() );\n+      VERIFY( ranges::equal(y, z) );\n+    }\n+}\n+\n+struct Y { int i; int j; };\n+\n+constexpr bool\n+test02()\n+{\n+  bool ok = true;\n+  Y x[] = { {3,2}, {2,4}, {3,6} };\n+  Y y[] = { {4,5}, {2,4}, {4,5} };\n+  Y z[] = { {4,5}, {2,4}, {4,5} };\n+  auto [in, out]\n+    = ranges::replace_copy_if(x, y,\n+\t\t\t      [] (int a) { return a%2 == 1; }, Y{4,5}, &Y::i);\n+  ok &= in == x+3;\n+  ok &= out == y+3;\n+  ok &= ranges::equal(y, z, {}, &Y::i, &Y::i);\n+  ok &= ranges::equal(y, z, {}, &Y::j, &Y::j);\n+  return ok;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  static_assert(test02());\n+}"}, {"sha": "8ebcc411997290436da5a9341b28ff37699634fc", "filename": "libstdc++-v3/testsuite/25_algorithms/replace_if/constrained.cc", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Freplace_if%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Freplace_if%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Freplace_if%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,109 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::input_iterator_wrapper;\n+using __gnu_test::forward_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+struct X\n+{\n+  int i;\n+\n+  friend constexpr bool\n+  operator==(const X& a, const X& b)\n+  {\n+    return a.i == b.i;\n+  }\n+};\n+\n+void\n+test01()\n+{\n+  auto is_even_p = [] (int a) { return a%2 == 0; };\n+  auto is_negative_p = [] (int a) { return a < 0; };\n+  auto is_two_p = [] (int a) { return a == 2; };\n+    {\n+      X x[6] = { {1}, {2}, {6}, {8}, {10}, {11} };\n+      X y[6] = { {1}, {9}, {9}, {9}, {9}, {11} };\n+      auto res = ranges::replace_if(x, x+5, is_even_p, X{9}, &X::i);\n+      VERIFY( res == x+5 );\n+      VERIFY( ranges::equal(x, y) );\n+    }\n+\n+    {\n+      X x[6] = { {2}, {2}, {6}, {8}, {10}, {11} };\n+      X y[6] = { {2}, {2}, {6}, {8}, {10}, {11} };\n+      auto res = ranges::replace_if(x, x+5, is_negative_p, X{9}, &X::i);\n+      VERIFY( res == x+5 );\n+      VERIFY( ranges::equal(x, y) );\n+    }\n+\n+    {\n+      X x[6] = { {2}, {2}, {6}, {8}, {10}, {11} };\n+      X y[6] = { {7}, {7}, {6}, {8}, {10}, {11} };\n+      test_container<X, forward_iterator_wrapper> cx(x), cy(y);\n+      auto res = ranges::replace_if(cx, is_two_p, X{7}, &X::i);\n+      VERIFY( res == cx.end() );\n+      VERIFY( ranges::equal(cx, cy) );\n+    }\n+\n+    {\n+      int x[6] = { {2}, {2}, {6}, {8}, {10}, {2} };\n+      int y[6] = { {7}, {7}, {6}, {8}, {10}, {7} };\n+      test_range<int, input_iterator_wrapper> rx(x), ry(y);\n+      auto res = ranges::replace_if(rx, is_two_p, 7);\n+      VERIFY( res == rx.end() );\n+\n+      rx.bounds.first = x;\n+      ry.bounds.first = y;\n+      VERIFY( ranges::equal(rx, ry) );\n+    }\n+}\n+\n+struct Y { int i; int j; };\n+\n+constexpr bool\n+test02()\n+{\n+  bool ok = true;\n+  Y x[] = { {3,2}, {2,4}, {3,6} };\n+  Y y[] = { {4,5}, {2,4}, {4,5} };\n+  auto res = ranges::replace_if(x, [] (int a) { return a%2 == 1; },\n+\t\t\t\tY{4,5}, &Y::i);\n+  ok &= res == x+3;\n+  ok &= ranges::equal(x, y, {}, &Y::i, &Y::i);\n+  ok &= ranges::equal(x, y, {}, &Y::j, &Y::j);\n+  return ok;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  static_assert(test02());\n+}\n+"}, {"sha": "58cec27b5a0bfbbabd3059862dfc944c48902e54", "filename": "libstdc++-v3/testsuite/25_algorithms/reverse/constrained.cc", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Freverse%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Freverse%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Freverse%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,77 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_range;\n+using __gnu_test::test_container;\n+using __gnu_test::bidirectional_iterator_wrapper;\n+using __gnu_test::random_access_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+template<template<typename> typename wrapper>\n+void\n+test01()\n+{\n+  int x[] = { 1, 2, 3, 4 };\n+  test_container<int, wrapper> cx(x);\n+  const int y[] = { 4, 3, 2, 1 };\n+\n+  auto res = ranges::reverse(cx);\n+  VERIFY( res == ranges::end(cx) );\n+  VERIFY( ranges::equal(cx, y) );\n+}\n+\n+template<template<typename> typename wrapper>\n+void\n+test02()\n+{\n+  int x[] = { 1, 2, 3, 4, 5 };\n+  test_range<int, wrapper> rx(x);\n+  const int y[] = { 5, 4, 3, 2, 1 };\n+\n+  auto res = ranges::reverse(rx);\n+  VERIFY( res == ranges::end(rx) );\n+  VERIFY( ranges::equal(rx, y) );\n+}\n+\n+constexpr bool\n+test03()\n+{\n+  int x[] = { 1, 2, 3 };\n+  const int y[] = { 2, 1, 3 };\n+  ranges::reverse(x, x+2);\n+  return ranges::equal(x, y);\n+}\n+\n+int\n+main()\n+{\n+  test01<bidirectional_iterator_wrapper>();\n+  test02<bidirectional_iterator_wrapper>();\n+\n+  test01<random_access_iterator_wrapper>();\n+  test02<random_access_iterator_wrapper>();\n+\n+  static_assert(test03());\n+}"}, {"sha": "1ee40bedb39e2d22580d635f7b65d9eefb26d13a", "filename": "libstdc++-v3/testsuite/25_algorithms/reverse_copy/constrained.cc", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Freverse_copy%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Freverse_copy%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Freverse_copy%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,74 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_range;\n+using __gnu_test::test_container;\n+using __gnu_test::bidirectional_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+void\n+test01()\n+{\n+  int x[] = { 1, 2, 3, 4 };\n+  int w[4];\n+  test_container<int, bidirectional_iterator_wrapper> cx(x), cw(w);\n+  const int y[] = { 4, 3, 2, 1 };\n+\n+  auto [in,out] = ranges::reverse_copy(cx, cw.begin());\n+  VERIFY( in == ranges::end(cx) && out == cw.end() );\n+  VERIFY( ranges::equal(cw, y) );\n+}\n+\n+void\n+test02()\n+{\n+  int x[] = { 1, 2, 3, 4, 5 };\n+  int w[5];\n+  test_range<int, bidirectional_iterator_wrapper> rx(x), rw(w);\n+  const int y[] = { 5, 4, 3, 2, 1 };\n+\n+  auto [in,out] = ranges::reverse_copy(rx, ranges::begin(rw));\n+  VERIFY( in == ranges::end(rx) && out == ranges::end(rw) );\n+  VERIFY( ranges::equal(rw, y) );\n+}\n+\n+constexpr bool\n+test03()\n+{\n+  const int x[] = { 1, 2, 3 };\n+  int w[2];\n+  const int y[] = { 2, 1 };\n+  ranges::reverse_copy(x, x+2, w);\n+  return ranges::equal(w, y);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+\n+  static_assert(test03());\n+}"}, {"sha": "34095e743ada11c41b36ee029fe72130cbcc874e", "filename": "libstdc++-v3/testsuite/25_algorithms/rotate/constrained.cc", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Frotate%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Frotate%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Frotate%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,97 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::forward_iterator_wrapper;\n+using __gnu_test::bidirectional_iterator_wrapper;\n+using __gnu_test::random_access_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+struct X\n+{\n+  int i;\n+  X (int a) : i(a) { }\n+\n+  friend bool\n+  operator==(const X& lhs, const X& rhs)\n+  {\n+    return lhs.i == rhs.i;\n+  }\n+};\n+\n+static_assert(!std::is_trivial_v<X>);\n+\n+template<template<typename, template<typename> typename> typename container,\n+\t template<typename> typename wrapper,\n+\t typename T = int>\n+void\n+test01()\n+{\n+  for (int a = 0; a <= 7; a++)\n+    {\n+      T x[] = {1, 2, 3, 4, 5, 6, 7};\n+      container<T, wrapper> rx(x);\n+      auto i = ranges::begin(rx);\n+      std::advance(i, a);\n+      auto res = ranges::rotate(rx, i);\n+      if (a == 0)\n+\tVERIFY( ranges::begin(res) == ranges::end(rx) );\n+      else\n+\tVERIFY( ranges::begin(res)\n+\t\t == std::next(ranges::begin(rx),\n+\t\t\t      ranges::distance(i, ranges::end(rx))) );\n+      VERIFY( ranges::end(res) == ranges::end(rx) );\n+      for (int k = 0; k < 7; k++)\n+\tVERIFY( x[k] == (k+a)%7 + 1 );\n+    }\n+}\n+\n+constexpr bool\n+test02()\n+{\n+  int x[] = {1, 2, 3, 4};\n+  const int y[] = { 2, 3, 1, 4 };\n+  ranges::rotate(x, x+1, x+3);\n+  return ranges::equal(x, y);\n+}\n+\n+int\n+main()\n+{\n+  test01<test_container, forward_iterator_wrapper>();\n+  test01<test_range, forward_iterator_wrapper>();\n+\n+  test01<test_container, bidirectional_iterator_wrapper>();\n+  test01<test_range, bidirectional_iterator_wrapper>();\n+\n+  test01<test_container, random_access_iterator_wrapper>();\n+  test01<test_range, random_access_iterator_wrapper>();\n+\n+  test01<test_container, random_access_iterator_wrapper, X>();\n+  test01<test_range, random_access_iterator_wrapper, X>();\n+\n+  static_assert(test02());\n+}"}, {"sha": "f036377817bf95d1cf214f28cdd271b70745b939", "filename": "libstdc++-v3/testsuite/25_algorithms/rotate_copy/constrained.cc", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Frotate_copy%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Frotate_copy%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Frotate_copy%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,93 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::forward_iterator_wrapper;\n+using __gnu_test::random_access_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+struct X\n+{\n+  int i;\n+  X () : i(0) { }\n+  X (int a) : i(a) { }\n+\n+  friend bool\n+  operator==(const X& lhs, const X& rhs)\n+  {\n+    return lhs.i == rhs.i;\n+  }\n+};\n+\n+static_assert(!std::is_trivial_v<X>);\n+\n+template<template<typename, template<typename> typename> typename container,\n+\t template<typename> typename wrapper,\n+\t typename T = int>\n+void\n+test01()\n+{\n+  for (int a = 0; a <= 7; a++)\n+    {\n+      T x[] = {1, 2, 3, 4, 5, 6, 7};\n+      T w[7];\n+      container<T, wrapper> rx(x), rw(w);\n+      auto i = ranges::begin(rx);\n+      std::advance(i, a);\n+      auto [in,out] = ranges::rotate_copy(rx, i, ranges::begin(rw));\n+      VERIFY( in == ranges::end(rx) );\n+      VERIFY( out == ranges::end(rw) );\n+      for (int k = 0; k < 7; k++)\n+\tVERIFY( w[k] == (k+a)%7 + 1 );\n+    }\n+}\n+\n+constexpr bool\n+test02()\n+{\n+  const int x[] = {1, 2, 3, 4};\n+  int w[3];\n+  const int y[] = { 2, 3, 1};\n+  auto [in,out] = ranges::rotate_copy(x, x+1, x+3, w);\n+  return (in == x+3\n+\t  && out == w+3\n+\t  && ranges::equal(w, y));\n+}\n+\n+int\n+main()\n+{\n+  test01<test_container, forward_iterator_wrapper>();\n+  test01<test_range, forward_iterator_wrapper>();\n+\n+  test01<test_container, random_access_iterator_wrapper>();\n+  test01<test_range, random_access_iterator_wrapper>();\n+\n+  test01<test_container, random_access_iterator_wrapper, X>();\n+  test01<test_range, random_access_iterator_wrapper, X>();\n+\n+  static_assert(test02());\n+}"}, {"sha": "314d9d2acf0d81248e77203bb64420899aff46d4", "filename": "libstdc++-v3/testsuite/25_algorithms/search/constrained.cc", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fsearch%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fsearch%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fsearch%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,88 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::input_iterator_wrapper;\n+using __gnu_test::forward_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+struct X { int i; };\n+\n+void\n+test01()\n+{\n+  X x[] = { {2}, {6}, {8}, {10}, {11} };\n+  X y[] = { {10}, {11} };\n+  {\n+\n+    test_container<X, forward_iterator_wrapper> c(x);\n+    auto res = ranges::search(c, y, {}, &X::i, &X::i);\n+    VERIFY( std::get<0>(res)->i == 10 && std::get<1>(res) == ranges::end(c) );\n+    res = ranges::search(c, c, {}, &X::i, &X::i);\n+    VERIFY( std::get<0>(res) == ranges::begin(c)\n+\t    && std::get<1>(res) == ranges::end(c) );\n+  }\n+\n+  {\n+    test_range<X, forward_iterator_wrapper> r(x);\n+    auto res = ranges::search(r, y, {}, &X::i, &X::i);\n+    VERIFY( std::get<0>(res)->i == 10 && std::get<1>(res) == ranges::end(r) );\n+    res = ranges::search(r, r, {}, &X::i, &X::i);\n+    VERIFY( std::get<0>(res) == ranges::begin(r)\n+\t    && std::get<1>(res) == ranges::end(r) );\n+  }\n+}\n+\n+void\n+test02()\n+{\n+  static constexpr X x[] = { {2}, {2}, {6}, {8}, {10}, {11} };\n+  static constexpr X y[] = { {6}, {8} };\n+  static constexpr int z[] = { 2, 8 };\n+  static constexpr int w[] = { 2 };\n+\n+  static_assert(std::get<0>(ranges::search(x, y, {}, &X::i, &X::i)) == x+2);\n+  static_assert(std::get<1>(ranges::search(x, y, {}, &X::i, &X::i)) == x+4);\n+\n+  static_assert(std::get<0>(ranges::search(x, z, {}, &X::i)) == x+6);\n+  static_assert(std::get<1>(ranges::search(x, z, {}, &X::i)) == x+6);\n+\n+  static_assert(std::get<0>(ranges::search(x, w, {}, &X::i)) == x+0);\n+  static_assert(std::get<1>(ranges::search(x, w, {}, &X::i)) == x+1);\n+\n+  static_assert(std::get<0>(ranges::search(x, x+6, w, w, {}, &X::i)) == x+0);\n+  static_assert(std::get<1>(ranges::search(x, x+6, w, w, {}, &X::i)) == x+0);\n+\n+  static_assert(std::get<0>(ranges::search(x, x, w, w+1, {}, &X::i)) == x+0);\n+  static_assert(std::get<1>(ranges::search(x, x, w, w+1, {}, &X::i)) == x+0);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "c1ac6da4bf860112f91f10c57c26f7e96eaa6718", "filename": "libstdc++-v3/testsuite/25_algorithms/search_n/constrained.cc", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fsearch_n%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fsearch_n%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fsearch_n%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,80 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::input_iterator_wrapper;\n+using __gnu_test::forward_iterator_wrapper;\n+using __gnu_test::bidirectional_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+struct X { int i; };\n+\n+void\n+test01()\n+{\n+  int x[] = { {2}, {2}, {6}, {8}, {10}, {11} };\n+  auto res = ranges::search_n(x+0, x+6, 2, 2);\n+  VERIFY( res.begin() == x+0 && res.end() == x+2 );\n+\n+  int z[] = { {1}, {2}, {2}, {4}, {5}, {6} };\n+  res = ranges::search_n(z, 3, 3, std::greater<int>());\n+  VERIFY( res.begin() == z+3 && res.end() == z+6 );\n+\n+  test_container<int, forward_iterator_wrapper> cx(x);\n+  auto res2 = ranges::search_n(cx, 2, 2);\n+  VERIFY( res2.begin() == cx.begin() && *res2.end() == 6 );\n+\n+  int y[] = { {2}, {2}, {8}, {2}, {2}, {2}, {5} };\n+  test_range<int, forward_iterator_wrapper> ry(y);\n+  auto res3 = ranges::search_n(ry, 3, 2);\n+  VERIFY( *res3.begin() == 2 && *res3.end() == 5 );\n+\n+  auto res4 = ranges::search_n(ry, 1, 8);\n+  VERIFY( res4.begin().ptr == y+2 && res4.end().ptr == y+3 );\n+}\n+\n+void\n+test02()\n+{\n+  static constexpr X x[] = { {2}, {2}, {6}, {8}, {10}, {2} };\n+  static constexpr X y[] = { {2}, {6}, {8}, {8}, {8}, {2} };\n+  static constexpr int z[] = { {2}, {6}, {8}, {10}, {2}, {2} };\n+\n+  static_assert(ranges::search_n(z, 0, 5).end() == z+0);\n+  static_assert(ranges::search_n(z, 1, 5).begin() == z+6);\n+  static_assert(ranges::search_n(x, 2, 3, {}, &X::i).begin() == x+6);\n+  static_assert(ranges::search_n(x, 2, 2, {}, &X::i).end() == x+2);\n+  static_assert(ranges::search_n(y, 3, 8, {}, &X::i).begin() == y+2);\n+  static_assert(ranges::search_n(y, 3, 8, {}, &X::i).end() == y+5);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}\n+"}, {"sha": "3f46a9b523e981d3c815dc702a60925d427b14e5", "filename": "libstdc++-v3/testsuite/25_algorithms/set_difference/constrained.cc", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fset_difference%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fset_difference%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fset_difference%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,87 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::input_iterator_wrapper;\n+using __gnu_test::output_iterator_wrapper;\n+using __gnu_test::forward_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+void\n+test01()\n+{\n+  int x[] = {4,2,1,1,0};\n+  int y[] = {3,2,1};\n+  int z[3];\n+  test_range<int, input_iterator_wrapper> rx(x), ry(y);\n+  test_range<int, output_iterator_wrapper> rz(z);\n+  auto [in,out]\n+    = ranges::set_difference(rx, ry, rz.begin(), ranges::greater{});\n+  VERIFY( in.ptr == x+5 );\n+  VERIFY( out.ptr == z+3 );\n+  VERIFY( ranges::equal(z, (int[]){4,1,0}) );\n+}\n+\n+void\n+test02()\n+{\n+  int x[] = {3,2,1,1,0};\n+  int y[] = {3,2,2,1,0};\n+  int z[1];\n+  test_container<int, forward_iterator_wrapper> rx(x), ry(y);\n+  test_container<int, forward_iterator_wrapper> rz(z);\n+  auto [in,out]\n+    = ranges::set_difference(rx.begin(), rx.end(),\n+\t\t\t     ry.begin(), ry.end(),\n+\t\t\t     rz.begin(),\n+\t\t\t     {},\n+\t\t\t     std::negate<>{},\n+\t\t\t     std::negate<>{});\n+  VERIFY( in.ptr == x+5 );\n+  VERIFY( out.ptr == z+1 );\n+  VERIFY( ranges::equal(z, (int[]){1}) );\n+}\n+\n+constexpr bool\n+test03()\n+{\n+  bool ok = true;\n+  int x[1] = {0};\n+  int y[1] = {1};\n+  int z[1];\n+  ok &= ranges::set_difference(x, x, y, y+1, z).out == z;\n+  ok &= ranges::set_difference(x, x+1, y, y, z).out == z+1;\n+  ok &= z[0] == 0;\n+  return ok;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  static_assert(test03());\n+}"}, {"sha": "0db3e411871a95c65b84ca17e7a1f693b153ef07", "filename": "libstdc++-v3/testsuite/25_algorithms/set_intersection/constrained.cc", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fset_intersection%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fset_intersection%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fset_intersection%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,88 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::input_iterator_wrapper;\n+using __gnu_test::output_iterator_wrapper;\n+using __gnu_test::forward_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+void\n+test01()\n+{\n+  int x[] = {4,2,1,1,0};\n+  int y[] = {3,2,1};\n+  int z[2];\n+  test_range<int, input_iterator_wrapper> rx(x), ry(y);\n+  test_range<int, output_iterator_wrapper> rz(z);\n+  auto [in1,in2,out]\n+    = ranges::set_intersection(rx, ry, rz.begin(), ranges::greater{});\n+  VERIFY( in1.ptr == x+5 );\n+  VERIFY( in2.ptr == y+3 );\n+  VERIFY( out.ptr == z+2 );\n+  VERIFY( ranges::equal(z, (int[]){2,1}) );\n+}\n+\n+void\n+test02()\n+{\n+  int x[] = {3,2,1,1,0};\n+  int y[] = {3,2,1,0};\n+  int z[4];\n+  test_container<int, forward_iterator_wrapper> rx(x), ry(y);\n+  test_container<int, forward_iterator_wrapper> rz(z);\n+  auto [in1,in2,out]\n+    = ranges::set_intersection(rx.begin(), rx.end(),\n+\t\t\t       ry.begin(), ry.end(),\n+\t\t\t       rz.begin(),\n+\t\t\t       {},\n+\t\t\t       std::negate<>{},\n+\t\t\t       std::negate<>{});\n+  VERIFY( in1.ptr == x+5 );\n+  VERIFY( in2.ptr == y+4 );\n+  VERIFY( out.ptr == z+4 );\n+  VERIFY( ranges::equal(z, (int[]){3,2,1,0}) );\n+}\n+\n+constexpr bool\n+test03()\n+{\n+  bool ok = true;\n+  int x[1] = {0};\n+  int y[1] = {1};\n+  int z[1];\n+  ok &= ranges::set_intersection(x, x, y, y+1, z).out == z;\n+  ok &= ranges::set_intersection(x, x+1, y, y, z).out == z;\n+  return ok;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  static_assert(test03());\n+}"}, {"sha": "b138aee3adbc3f4c7c5d8fddc7dba4d2326757f4", "filename": "libstdc++-v3/testsuite/25_algorithms/set_symmetric_difference/constrained.cc", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fset_symmetric_difference%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fset_symmetric_difference%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fset_symmetric_difference%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,123 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+// { dg-require-cstdint \"\" }\n+\n+#include <algorithm>\n+#include <random>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::input_iterator_wrapper;\n+using __gnu_test::output_iterator_wrapper;\n+using __gnu_test::forward_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+void\n+test01()\n+{\n+  int x[] = {4,2,1,1,0};\n+  int y[] = {3,2,2,1};\n+  int z[5];\n+  test_range<int, input_iterator_wrapper> rx(x), ry(y);\n+  test_range<int, output_iterator_wrapper> rz(z);\n+  auto [in1,in2,out]\n+    = ranges::set_symmetric_difference(rx, ry, rz.begin(), ranges::greater{});\n+  VERIFY( in1.ptr == x+5 );\n+  VERIFY( in2.ptr == y+4 );\n+  VERIFY( out.ptr == z+5 );\n+  VERIFY( ranges::equal(z, (int[]){4,3,2,1,0}) );\n+}\n+\n+void\n+test02()\n+{\n+  int x[] = {3,2,1,1,0};\n+  int y[] = {3,2,1,0};\n+  int z[1];\n+  test_container<int, forward_iterator_wrapper> rx(x), ry(y);\n+  test_container<int, forward_iterator_wrapper> rz(z);\n+  auto [in1,in2,out]\n+    = ranges::set_symmetric_difference(rx.begin(), rx.end(),\n+\t\t\t\t       ry.begin(), ry.end(),\n+\t\t\t\t       rz.begin(),\n+\t\t\t\t       {},\n+\t\t\t\t       std::negate<>{},\n+\t\t\t\t       std::negate<>{});\n+  VERIFY( in1.ptr == x+5 );\n+  VERIFY( in2.ptr == y+4 );\n+  VERIFY( out.ptr == z+1 );\n+  VERIFY( ranges::equal(z, (int[]){1}) );\n+}\n+\n+constexpr bool\n+test03()\n+{\n+  bool ok = true;\n+  int x[1] = {0};\n+  int y[1] = {1};\n+  int z[1];\n+  ok &= ranges::set_symmetric_difference(x, x, y, y+1, z).out == z+1;\n+  ok &= z[0] == 1;\n+  ok &= ranges::set_symmetric_difference(x, x+1, y, y, z).out == z+1;\n+  ok &= z[0] == 0;\n+  return ok;\n+}\n+\n+void\n+test04()\n+{\n+  int x[15] = {5,5,5,5,5,4,4,4,4,3,3,3,2,2,1};\n+  int y[15] = {5,5,5,5,5,4,4,4,4,3,3,3,2,2,1};\n+  for (int k = 0; k < 100; k++)\n+    {\n+      std::ranlux48_base g(k);\n+      ranges::shuffle(x, g);\n+      ranges::shuffle(y, g);\n+      ranges::sort(x, x+10);\n+      ranges::sort(y, y+10);\n+\n+      int z[15];\n+      auto z_out = ranges::set_symmetric_difference(x, x+10, y, y+10, z).out;\n+\n+      int w1[15];\n+      auto w1_out = ranges::set_difference(x, x+10, y, y+10, w1).out;\n+\n+      int w2[15];\n+      auto w2_out = ranges::set_difference(y, y+10, x, x+10, w2).out;\n+\n+      int w3[15];\n+      auto w3_out = ranges::set_union(w1, w1_out, w2, w2_out, w3).out;\n+\n+      VERIFY( ranges::equal(z, z_out, w3, w3_out) );\n+    }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  static_assert(test03());\n+  test04();\n+}"}, {"sha": "19bcd7aab9f6e470cbc5cb71a51e7ec2f9a86269", "filename": "libstdc++-v3/testsuite/25_algorithms/set_union/constrained.cc", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fset_union%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fset_union%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fset_union%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,91 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::input_iterator_wrapper;\n+using __gnu_test::output_iterator_wrapper;\n+using __gnu_test::forward_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+void\n+test01()\n+{\n+  int x[] = {4,2,1,1,0};\n+  int y[] = {3,2,1};\n+  int z[6];\n+  test_range<int, input_iterator_wrapper> rx(x), ry(y);\n+  test_range<int, output_iterator_wrapper> rz(z);\n+  auto [in1,in2,out]\n+    = ranges::set_union(rx, ry, rz.begin(),\n+\t\t\tranges::greater{});\n+  VERIFY( in1.ptr == x+5 );\n+  VERIFY( in2.ptr == y+3 );\n+  VERIFY( out.ptr == z+6 );\n+  VERIFY( ranges::equal(z, (int[]){4,3,2,1,1,0}) );\n+}\n+\n+void\n+test02()\n+{\n+  int x[] = {4,2,1,1,0};\n+  int y[] = {3,2,1,1,0};\n+  int z[6];\n+  test_container<int, forward_iterator_wrapper> rx(x), ry(y);\n+  test_container<int, forward_iterator_wrapper> rz(z);\n+  auto [in1,in2,out]\n+    = ranges::set_union(rx.begin(), rx.end(),\n+\t\t\try.begin(), ry.end(),\n+\t\t\trz.begin(),\n+\t\t\t{},\n+\t\t\tstd::negate<>{},\n+\t\t\tstd::negate<>{});\n+  VERIFY( in1.ptr == x+5 );\n+  VERIFY( in2.ptr == y+5 );\n+  VERIFY( out.ptr == z+6 );\n+  VERIFY( ranges::equal(z, (int[]){4,3,2,1,1,0}) );\n+}\n+\n+constexpr bool\n+test03()\n+{\n+  bool ok = true;\n+  int x[1] = {0};\n+  int y[1] = {1};\n+  int z[1];\n+  ranges::set_union(x, x, y, y+1, z);\n+  ok &= z[0] == 1;\n+  ranges::set_union(x, x+1, y, y, z);\n+  ok &= z[0] == 0;\n+  return ok;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  static_assert(test03());\n+}"}, {"sha": "b96343aecceac2c28935a599f8dc612b1368e484", "filename": "libstdc++-v3/testsuite/25_algorithms/shuffle/constrained.cc", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fshuffle%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fshuffle%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fshuffle%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,70 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+// { dg-require-cstdint \"\" }\n+\n+#include <algorithm>\n+#include <random>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::random_access_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+// This test is adapted from 25_algorithms/shuffle/1.cc.\n+\n+void\n+test01()\n+{\n+  for (unsigned size = 0; size < 50; ++size)\n+    {\n+      std::vector<int> vref(size);\n+      std::iota(vref.begin(), vref.end(), 0);\n+      std::vector<int> v1(vref), v2(vref);\n+      test_container<int, random_access_iterator_wrapper> c\n+\t= {&v1[0], &v1[0] + size};\n+      test_range<int, random_access_iterator_wrapper> r\n+\t= {&v2[0], &v2[0] + size};\n+\n+      std::ranlux48_base g1(size), g2(size + 1);\n+      VERIFY( ranges::shuffle(c, g1) == c.end() );\n+      VERIFY( ranges::shuffle(ranges::begin(r), ranges::end(r), g2)\n+\t      == ranges::end(r) );\n+\n+      if (size >= 10)\n+\t{\n+\t  VERIFY( !ranges::equal(c, vref) );\n+\t  VERIFY( !ranges::equal(r, vref) );\n+\t  VERIFY( !ranges::equal(c, r) );\n+\t}\n+\n+      VERIFY( ranges::is_permutation(c, vref) );\n+      VERIFY( ranges::is_permutation(r, vref) );\n+    }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "d8227773ccb11ca4d5240ac8b90a80ae0640fdb1", "filename": "libstdc++-v3/testsuite/25_algorithms/sort/constrained.cc", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fsort%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fsort%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fsort%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,81 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+// { dg-require-cstdint \"\" }\n+\n+#include <algorithm>\n+#include <random>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::random_access_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+void\n+test01()\n+{\n+  for (unsigned size = 0; size < 50; ++size)\n+    {\n+      std::vector<int> vref(size);\n+      std::iota(vref.begin(), vref.end(), 0);\n+      std::vector<int> v1(vref), v2(vref);\n+      test_container<int, random_access_iterator_wrapper> c\n+\t= {&v1[0], &v1[0] + size};\n+      test_range<int, random_access_iterator_wrapper> r\n+\t= {&v2[0], &v2[0] + size};\n+\n+      std::ranlux48_base g1(size), g2(size + 1);\n+      ranges::shuffle(c, g1);\n+      ranges::shuffle(ranges::begin(r), ranges::end(r), g2);\n+\n+      VERIFY( ranges::sort(c) == c.end() );\n+      VERIFY( ranges::sort(r) == ranges::end(r) );\n+\n+      VERIFY( ranges::equal(c, vref) );\n+      VERIFY( ranges::equal(r, vref) );\n+    }\n+}\n+\n+struct X\n+{\n+  int i;\n+  constexpr X(int a) : i(a) { }\n+};\n+\n+constexpr bool\n+test02()\n+{\n+  X x[] = {3,4,2,1,5};\n+  const X y[] = {4,3,2,1,5};\n+\n+  auto res = ranges::sort(x, x+4, ranges::greater{}, &X::i);\n+  return (res == x+4\n+\t  && ranges::equal(x, y, {}, &X::i, &X::i));\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  static_assert(test02());\n+}"}, {"sha": "761e3dd32d49bdedf21ef190fa4857093ba9770e", "filename": "libstdc++-v3/testsuite/25_algorithms/stable_partition/constrained.cc", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fstable_partition%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fstable_partition%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fstable_partition%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,76 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::bidirectional_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+void\n+test01()\n+{\n+    {\n+      int x[] = {1,2,3,4,5,6,7,8,9,10};\n+      test_container<int, bidirectional_iterator_wrapper> cx(x);\n+      auto pred = [] (int a) { return a%2==0; };\n+      auto range = ranges::stable_partition(cx, pred);\n+      VERIFY( ranges::all_of(cx.begin(), range.begin(), pred) );\n+      VERIFY( ranges::none_of(range, pred) );\n+    }\n+\n+    {\n+      int x[] = {1,2,3,4,5,6,7,8,9,10,11};\n+      test_range<int, bidirectional_iterator_wrapper> cx(x);\n+      auto pred = [] (int a) { return a%2==0; };\n+      auto range = ranges::stable_partition(cx, pred);\n+      VERIFY( ranges::all_of(cx.begin(), range.begin(), pred) );\n+      VERIFY( ranges::none_of(range, pred) );\n+    }\n+}\n+\n+void\n+test02()\n+{\n+  for (int k = 1; k <= 10; k++)\n+    {\n+      int x[] = {1,2,3,4,5,6,7,8,9,10};\n+      auto pred = [&] (int a) { return a >= k; };\n+      auto proj = [] (int a) { return a-1; };\n+      auto range = ranges::stable_partition(x, x+10, pred, proj);\n+      VERIFY( ranges::all_of(x, range.begin(), pred, proj) );\n+      VERIFY( ranges::none_of(range, pred, proj) );\n+\n+      int y[] = {0,1,2,3,4,5,6,7,8,9};\n+      ranges::rotate(y, y+k);\n+      VERIFY( ranges::equal(x, y, {}, proj) );\n+    }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "23a8c03b519368b34920bef0cfd9ff65a746b95c", "filename": "libstdc++-v3/testsuite/25_algorithms/stable_sort/constrained.cc", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fstable_sort%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fstable_sort%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fstable_sort%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,70 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+// { dg-require-cstdint \"\" }\n+\n+#include <algorithm>\n+#include <random>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::random_access_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+// This test doesn't verify the stability property of ranges::stable_sort,\n+// because at the moment it's just defined to be a wrapper over\n+// std::stable_sort.\n+\n+void\n+test01()\n+{\n+  for (unsigned size = 0; size < 50; ++size)\n+    {\n+      std::vector<int> vref(size);\n+      std::iota(vref.begin(), vref.end(), 0);\n+      std::vector<int> v1(vref), v2(vref);\n+      test_container<int, random_access_iterator_wrapper> c\n+\t= {&v1[0], &v1[0] + size};\n+      test_range<int, random_access_iterator_wrapper> r\n+\t= {&v2[0], &v2[0] + size};\n+\n+      std::ranlux48_base g1(size), g2(size + 1);\n+      ranges::shuffle(c, g1);\n+      ranges::shuffle(ranges::begin(r), ranges::end(r), g2);\n+\n+      auto res1 = ranges::stable_sort(c.begin(), c.end(), {}, std::negate<>{});\n+      VERIFY( res1 == c.end() );\n+\n+      auto res2 = ranges::stable_sort(r, ranges::greater{});\n+      VERIFY( res2 == ranges::end(r) );\n+\n+      VERIFY( ranges::equal(c, r) );\n+      VERIFY( ranges::equal(c.begin(), c.end(), vref.rbegin(), vref.rend()) );\n+    }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "338b6a435f9807654da2794ebf31abd7c73123ec", "filename": "libstdc++-v3/testsuite/25_algorithms/swap_ranges/constrained.cc", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fswap_ranges%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fswap_ranges%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fswap_ranges%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,124 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::input_iterator_wrapper;\n+using __gnu_test::forward_iterator_wrapper;\n+using __gnu_test::bidirectional_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+struct X\n+{\n+  int i;\n+  int moved = 0;\n+\n+  constexpr X(int a) : i(a) { }\n+\n+  constexpr X(const X&) = delete;\n+  constexpr X& operator=(const X&) = delete;\n+\n+  constexpr X(X&& other)\n+  {\n+    *this = std::move(other);\n+  }\n+\n+  constexpr X&\n+  operator=(X&& other)\n+  {\n+    other.moved++;\n+    i = other.i;\n+    return *this;\n+  }\n+\n+  friend constexpr bool\n+  operator==(const X& a, const X& b)\n+  { return a.i == b.i; }\n+};\n+\n+void\n+test01()\n+{\n+    {\n+      X x[7] = { 1, 2, 3, 4, 5, 6, 7 };\n+      X y[7] = { 2, 4, 3, 5, 8, 9, 1 };\n+      X z[7] = { 1, 2, 3, 4, 5, 6, 7 };\n+      X w[7] = { 2, 4, 3, 5, 8, 9, 1 };\n+      auto [x_iter, y_iter] = ranges::swap_ranges(x, y);\n+      VERIFY( ranges::equal(y, z) && x_iter == x+7 && y_iter == y+7 );\n+      VERIFY( ranges::equal(x, w) );\n+    }\n+\n+    {\n+      int x[3] = { 1, 2, 3 };\n+      int y[4] = { 2, 4, 6, 0 };\n+      int z[3] = { 1, 2, 3 };\n+      int w[3] = { 2, 4, 6 };\n+      test_container<int, forward_iterator_wrapper> cx(x);\n+      test_container<int, forward_iterator_wrapper> cy(y);\n+      auto [x_iter, y_iter] = ranges::swap_ranges(cx, cy);\n+      VERIFY( ranges::equal(y, y+3, z, z+3) );\n+      VERIFY( x_iter.ptr == x+3 && y_iter.ptr == y+3 );\n+      VERIFY( y[3] == 0 );\n+      VERIFY( ranges::equal(x, w) );\n+    }\n+\n+    {\n+      int x[3] = { 1, 2, 3 };\n+      int y[4] = { 2, 4, 6, 0 };\n+      int z[3] = { 1, 2, 3 };\n+      int w[3] = { 2, 4, 6 };\n+      test_range<int, input_iterator_wrapper> cx(x);\n+      test_range<int, input_iterator_wrapper> cy(y);\n+      auto [y_iter, x_iter] = ranges::swap_ranges(cy, cx);\n+      VERIFY( ranges::equal(y, y+3, z, z+3) );\n+      VERIFY( x_iter.ptr == x+3 && y_iter.ptr == y+3 );\n+      VERIFY( y[3] == 0 );\n+      VERIFY( ranges::equal(x, w) );\n+    }\n+}\n+\n+constexpr bool\n+test02()\n+{\n+  bool ok = true;\n+  X x[7] = { 1, 2, 3, 4, 5, 6, 7 };\n+  X y[7] = { 2, 4, 3, 5, 8, 9, 1 };\n+  X z[7] = { 1, 2, 3, 4, 5, 6, 7 };\n+  X w[7] = { 2, 4, 3, 5, 8, 9, 1 };\n+  auto [x_iter, y_iter] = ranges::swap_ranges(x, y);\n+  ok &= ranges::equal(y, z) && x_iter == x+7 && y_iter == y+7;\n+  ok &= ranges::equal(x, w);\n+  return ok;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  static_assert(test02());\n+}\n+\n+"}, {"sha": "da8b7f2be0761091ac0e499c45b29156e15b7232", "filename": "libstdc++-v3/testsuite/25_algorithms/transform/constrained.cc", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ftransform%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ftransform%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ftransform%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,148 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::input_iterator_wrapper;\n+using __gnu_test::output_iterator_wrapper;\n+using __gnu_test::forward_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+struct X { int i; };\n+\n+void\n+test01()\n+{\n+    {\n+      int x[6] = { {2}, {4}, {6}, {8}, {10}, {11} };\n+      int y[6] = { {3}, {5}, {7}, {9}, {11}, {12} };\n+      auto [in, out] = ranges::transform(x, x, [] (int a) { return a+1; });\n+      VERIFY( in == x+6 && out == x+6 );\n+      VERIFY( ranges::equal(x, y) );\n+    }\n+\n+    {\n+      X x[6] = { {2}, {4}, {6}, {8}, {10}, {11} };\n+      int y[7] = { {3}, {5}, {7}, {9}, {11}, {12}, {0} };\n+      int z[7] = { {0}, {0}, {0}, {0}, {0}, {0}, {0} };\n+      test_container<X, forward_iterator_wrapper> cx(x);\n+      test_container<int, forward_iterator_wrapper> cy(y), cz(z);\n+      auto [in, out]\n+\t= ranges::transform(cx, cz.begin(), [] (int a) { return a+1; }, &X::i);\n+      VERIFY( ranges::equal(cy, cz) );\n+      VERIFY( in == cx.end() && ++out == cz.end() );\n+    }\n+\n+    {\n+      X x[6] = { {2}, {4}, {6}, {8}, {10}, {11} };\n+      X y[7] = { {3}, {5}, {7}, {9}, {11}, {12}, {0} };\n+      int z[7] = { {0}, {0}, {0}, {0}, {0}, {0}, {0} };\n+      test_range<X, input_iterator_wrapper> rx(x), ry(y);\n+      test_range<int, output_iterator_wrapper> rz(z);\n+      auto [in, out]\n+\t= ranges::transform(rx, rz.begin(), [] (int a) { return a+1; }, &X::i);\n+      VERIFY( ranges::equal(ry, z, {}, &X::i) );\n+      VERIFY( in == rx.end() && out.ptr == z+6 );\n+    }\n+}\n+\n+struct Y { int i; int j; };\n+\n+constexpr bool\n+test02()\n+{\n+  int x[] = { 1, 2, 3 };\n+  Y y[] = { {1,2}, {2,4}, {3,6} };\n+  ranges::transform(y, y+3, x, [] (int a) { return -a; }, &Y::i);\n+  return x[0] == -1 && x[1] == -2 && x[2] == -3;\n+}\n+\n+void\n+test03()\n+{\n+    {\n+      int x[6] = { {2}, {4}, {6}, {8}, {10}, {11} };\n+      const int y[6] = { {3}, {5}, {7}, {9}, {11}, {12} };\n+      int z[6] = { {5}, {9}, {13}, {17}, {21}, {23} };\n+      auto [in1, in2, out] = ranges::transform(x, y, x, std::plus<>{});\n+      VERIFY( in1 == x+6 && in2 == y+6 && out == x+6 );\n+      VERIFY( ranges::equal(x, z) );\n+    }\n+\n+    {\n+      int x[6] = { {2}, {4}, {6}, {8}, {10}, {11} };\n+      const int y[6] = { {3}, {5}, {7}, {9}, {11}, {12} };\n+      int z[6] = { {5}, {9}, {13}, {17}, {21}, {23} };\n+      auto [in1, in2, out] = ranges::transform(y, x, x, std::plus<>{});\n+      VERIFY( in1 == y+6 && in2 == x+6 && out == x+6 );\n+      VERIFY( ranges::equal(x, z) );\n+    }\n+\n+    {\n+      X x[6] = { {2}, {4}, {6}, {8}, {10}, {11} };\n+      int y[7] = { {3}, {5}, {7}, {9}, {11}, {12}, {0} };\n+      int z[6] = { {5}, {9}, {13}, {17}, {21}, {23} };\n+      int w[6];\n+      test_container<X, forward_iterator_wrapper> cx(x);\n+      test_container<int, forward_iterator_wrapper> cy(y), cz(z), cw(w);\n+      auto [in1, in2, out]\n+\t= ranges::transform(cx, cy, cw.begin(), std::plus<>{}, &X::i);\n+      VERIFY( in1 == cx.end() && ++in2 == cy.end() && out == cw.end() );\n+      VERIFY( ranges::equal(cw, cz) );\n+    }\n+\n+    {\n+      X x[6] = { {2}, {4}, {6}, {8}, {10}, {11} };\n+      int y[7] = { {3}, {5}, {7}, {9}, {11}, {12}, {0} };\n+      int z[6] = { {5}, {9}, {13}, {17}, {21}, {23} };\n+      int w[6];\n+      test_range<X, input_iterator_wrapper> rx(x);\n+      test_range<int, input_iterator_wrapper> ry(y), rz(z);\n+      test_range<int, output_iterator_wrapper> rw(w);\n+      auto [in1, in2, out]\n+\t= ranges::transform(rx, ry, rw.begin(), std::plus<>{}, &X::i);\n+      VERIFY( in1 == rx.end() && ++in2 == ry.end() && out.ptr == w+6 );\n+      VERIFY( ranges::equal(w, rz) );\n+    }\n+}\n+\n+constexpr bool\n+test04()\n+{\n+  int x[3];\n+  const Y y[3] = { {1,2}, {2,4}, {3,6} };\n+  ranges::transform(y, y+3, y, y+3, x, std::plus<>{}, &Y::i, &Y::j);\n+  return x[0] == 3 && x[1] == 6 && x[2] == 9;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  static_assert(test02());\n+  test03();\n+  static_assert(test04());\n+}\n+"}, {"sha": "e863a601dddf1c6dd702d53335d2a0b6e3a1f9a2", "filename": "libstdc++-v3/testsuite/25_algorithms/unique/constrained.cc", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Funique%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Funique%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Funique%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,143 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <list>\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::input_iterator_wrapper;\n+using __gnu_test::forward_iterator_wrapper;\n+\n+\n+namespace ranges = std::ranges;\n+\n+struct X\n+{\n+  int i;\n+};\n+\n+void\n+test01()\n+{\n+    {\n+      X x[6] = { {2}, {2}, {6}, {8}, {2}, {11} };\n+      const int y[5] = { {2}, {6}, {8}, {2}, {11} };\n+      test_container<X, forward_iterator_wrapper> cx(x);\n+      auto res = ranges::unique(cx, {}, &X::i);\n+      VERIFY( res.end() == cx.end() );\n+      VERIFY( ranges::equal(cx.begin(), res.begin(), y, y+5, {}, &X::i) );\n+    }\n+\n+    {\n+      X x[6] = { {2}, {2}, {6}, {8}, {2}, {11} };\n+      const int y[5] = { {2}, {6}, {8}, {2}, {11} };\n+      test_range<X, forward_iterator_wrapper> rx(x);\n+      auto res = ranges::unique(rx, {}, &X::i);\n+      VERIFY( res.end() == rx.end() );\n+      VERIFY( ranges::equal(rx.begin(), res.begin(), y, y+5, {}, &X::i) );\n+    }\n+}\n+\n+constexpr bool\n+test02()\n+{\n+  int x[2] = {2, 2};\n+  const int y[1] = {2};\n+  auto res = ranges::unique(x);\n+  return ranges::equal(x, res.begin(), y, y+1, ranges::equal_to{});\n+}\n+\n+/* The following is adapted from 25_algorithms/unique/2.cc.  */\n+\n+namespace two_dot_cc\n+{\n+  const int T1[] = {1, 4, 4, 6, 1, 2, 2, 3, 1, 6, 6, 6, 5, 7, 5, 4, 4};\n+  const int T2[] = {1, 1, 1, 2, 2, 1, 1, 7, 6, 6, 7, 8, 8, 8, 8, 9, 9};\n+  const int N = sizeof(T1) / sizeof(int);\n+\n+  const int A1[] = {1, 4, 6, 1, 2, 3, 1, 6, 5, 7, 5, 4};\n+  const int A2[] = {1, 4, 4, 6, 6, 6, 6, 7};\n+  const int A3[] = {1, 1, 1};\n+\n+  const int B1[] = {1, 2, 1, 7, 6, 7, 8, 9};\n+  const int B2[] = {1, 1, 1, 2, 2, 7, 7, 8, 8, 8, 8, 9, 9};\n+  const int B3[] = {9, 9, 8, 8, 8, 8, 7, 6, 6, 1, 1, 1, 1, 1};\n+\n+  void test01()\n+  {\n+    using namespace std;\n+\n+    list<int>::iterator pos;\n+\n+    list<int> coll(T1, T1 + N);\n+    pos = ranges::unique(coll.begin(), coll.end()).begin();\n+    VERIFY( equal(coll.begin(), pos, A1) );\n+\n+    list<int> coll2(T2, T2 + N);\n+    pos = ranges::unique(coll2.begin(), coll2.end()).begin();\n+    VERIFY( equal(coll2.begin(), pos, B1) );\n+  }\n+\n+  void test02()\n+  {\n+    using namespace std;\n+\n+    list<int>::iterator pos;\n+\n+    list<int> coll(T1, T1 + N);\n+    pos = ranges::unique(coll.begin(), coll.end(), greater<int>()).begin();\n+    VERIFY( equal(coll.begin(), pos, A2) );\n+\n+    list<int> coll2(T2, T2 + N);\n+    pos = ranges::unique(coll2.begin(), coll2.end(), greater<int>()).begin();\n+    VERIFY( equal(coll2.begin(), pos, B2) );\n+  }\n+\n+  void test03()\n+  {\n+    using namespace std;\n+\n+    list<int>::iterator pos;\n+\n+    list<int> coll(T1, T1 + N);\n+    pos = ranges::unique(coll.begin(), coll.end(), less<int>()).begin();\n+    VERIFY( equal(coll.begin(), pos, A3) );\n+\n+    list<int> coll2(T2, T2 + N);\n+    reverse(coll2.begin(), coll2.end());\n+    pos = ranges::unique(coll2.begin(), coll2.end(), less<int>()).begin();\n+    VERIFY( equal(coll2.begin(), pos, B3) );\n+  }\n+} // namespace two_dot_cc\n+\n+int main()\n+{\n+  test01();\n+  static_assert(test02());\n+\n+  two_dot_cc::test01();\n+  two_dot_cc::test02();\n+  two_dot_cc::test03();\n+\n+  return 0;\n+}"}, {"sha": "bf16cdc4ee9c72b73dc01300cd214dadfa4aff5c", "filename": "libstdc++-v3/testsuite/25_algorithms/unique_copy/constrained.cc", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Funique_copy%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Funique_copy%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Funique_copy%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,113 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_range;\n+using __gnu_test::input_iterator_wrapper;\n+using __gnu_test::output_iterator_wrapper;\n+using __gnu_test::forward_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+template<template<typename> typename source_wrapper,\n+\t template<typename> typename dest_wrapper>\n+void\n+test01()\n+{\n+  int x[6] = {0, 0, 0, 1, 1, 1};\n+  int y[2];\n+  const int z[2] = {0, 1};\n+\n+  test_range<int, source_wrapper> rx(x);\n+  test_range<int, dest_wrapper> ry(y);\n+  auto [in,out] = ranges::unique_copy(rx, ry.begin());\n+  VERIFY( in == ranges::end(rx) && out == ranges::end(ry) );\n+  VERIFY( ranges::equal(y, z) );\n+}\n+\n+template<template<typename> typename source_wrapper,\n+\t template<typename> typename dest_wrapper>\n+void\n+test02()\n+{\n+  int x[6] = {0, 0, 0, 1, 1, 1};\n+  int y[2] = {0, 0};\n+  const int z[2] = {0, 0};\n+\n+  test_range<int, source_wrapper> rx(x, x);\n+  test_range<int, dest_wrapper> ry(y, y);\n+  auto [in, out] = ranges::unique_copy(rx.begin(), rx.end(), ry.begin());\n+  VERIFY( in.ptr == x && out.ptr == y );\n+  VERIFY( ranges::equal(y, z) );\n+}\n+\n+template<template<typename> typename source_wrapper,\n+\t template<typename> typename dest_wrapper>\n+void\n+test03()\n+{\n+  struct X { int i; };\n+  X x[6] = { {1}, {2}, {2}, {4}, {4}, {6} };\n+  X y[4] = { {1}, {2}, {4}, {6} };\n+  const X z[4] = { {1}, {2}, {4}, {6} };\n+\n+  test_range<X, source_wrapper> rx(x);\n+  test_range<X, dest_wrapper> ry(y);\n+  auto [in, out]\n+    = ranges::unique_copy(rx, ry.begin(), ranges::equal_to{}, &X::i);\n+  VERIFY( in == ranges::end(rx) && out == ranges::end(ry) );\n+  VERIFY( ranges::equal(y, z, {}, &X::i, &X::i) );\n+}\n+\n+constexpr bool\n+test04()\n+{\n+  struct X { int i; };\n+  X x[7] = { {1}, {2}, {2}, {2}, {4}, {4}, {6} };\n+  X y[4] = { {1}, {2}, {4}, {6} };\n+  const X z[4] = { {1}, {2}, {4}, {6} };\n+\n+  auto [in, out]\n+    = ranges::unique_copy(x, x+7, y, ranges::equal_to{}, &X::i);\n+  return (in == ranges::end(x)\n+\t  && out == ranges::end(y)\n+\t  && ranges::equal(y, z, {}, &X::i, &X::i));\n+}\n+\n+int\n+main()\n+{\n+  test01<input_iterator_wrapper, output_iterator_wrapper>();\n+  test01<input_iterator_wrapper, forward_iterator_wrapper>();\n+  test01<forward_iterator_wrapper, output_iterator_wrapper>();\n+\n+  test02<input_iterator_wrapper, output_iterator_wrapper>();\n+  test02<input_iterator_wrapper, forward_iterator_wrapper>();\n+  test02<forward_iterator_wrapper, output_iterator_wrapper>();\n+\n+  test03<input_iterator_wrapper, output_iterator_wrapper>();\n+  test03<input_iterator_wrapper, forward_iterator_wrapper>();\n+  test03<forward_iterator_wrapper, output_iterator_wrapper>();\n+\n+  static_assert(test04());\n+}"}, {"sha": "5182431f68fab3f4483cf7430d6a37709d164fbd", "filename": "libstdc++-v3/testsuite/25_algorithms/upper_bound/constrained.cc", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fupper_bound%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4646410a38801029817e7951bf9b99a8c41461/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fupper_bound%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fupper_bound%2Fconstrained.cc?ref=bc4646410a38801029817e7951bf9b99a8c41461", "patch": "@@ -0,0 +1,66 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::forward_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+void\n+test01()\n+{\n+  int x[] = {1, 2, 3, 4, 5, 5, 6, 7};\n+  for (unsigned i = 0; i < 5; i++)\n+    for (unsigned j = 6; j < 8; j++)\n+      {\n+\ttest_container<int, forward_iterator_wrapper> cx(x);\n+\tauto result = ranges::upper_bound(std::next(cx.begin(), i),\n+\t\t\t\t\t  std::next(cx.begin(), j),\n+\t\t\t\t\t  4, {}, [] (int a) { return a-1; });\n+\tVERIFY( result.ptr == x+6 );\n+      }\n+\n+  ranges::reverse(x);\n+  test_range<int, forward_iterator_wrapper> rx(x);\n+  auto result = ranges::upper_bound(rx, 5, ranges::greater{},\n+\t\t\t\t    [] (int a) { return a+1; });\n+  VERIFY( result.ptr == x+5 );\n+}\n+\n+constexpr bool\n+test02()\n+{\n+  int x[] = {1, 2, 3, 4, 5};\n+  return (ranges::upper_bound(x, 6) == x+5\n+\t  && ranges::upper_bound(x, x, 6) == x\n+\t  && ranges::upper_bound(x, 1) == x+1);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  static_assert(test02());\n+}"}]}