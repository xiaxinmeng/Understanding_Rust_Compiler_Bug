{"sha": "d63b5e9f25067b433a4dec4dea8539170761fcd6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDYzYjVlOWYyNTA2N2I0MzNhNGRlYzRkZWE4NTM5MTcwNzYxZmNkNg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2003-12-16T19:50:54Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2003-12-16T19:50:54Z"}, "message": "re PR c++/9043 ([ABI] incorrect name mangling for array dimension in template function)\n\ncp:\n\tPR c++/9043\n\tC++ ABI change: Mangling array indices in templates.\n\t* decl.c (compute_array_index_type): Reorganize for earlier\n\ttemplate errors. Use value_dependent_expression_p for abi-2.\n\t* mangle.c (write_array_type): Check broken mangling for\n\texpression indices on abi-1\ntestsuite:\n\tPR c++/9043\n\t* g++.dg/abi/mangle20-1.C: New test.\n\t* g++.dg/abi/mangle20-2.C: New test.\n\nFrom-SVN: r74707", "tree": {"sha": "0fc4b9688b90a52b69a422edafa5f8c65e65968e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0fc4b9688b90a52b69a422edafa5f8c65e65968e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d63b5e9f25067b433a4dec4dea8539170761fcd6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d63b5e9f25067b433a4dec4dea8539170761fcd6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d63b5e9f25067b433a4dec4dea8539170761fcd6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d63b5e9f25067b433a4dec4dea8539170761fcd6/comments", "author": null, "committer": null, "parents": [{"sha": "28690784e2e718c23f02e4e8ec1a18417dd41e08", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28690784e2e718c23f02e4e8ec1a18417dd41e08", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28690784e2e718c23f02e4e8ec1a18417dd41e08"}], "stats": {"total": 202, "additions": 125, "deletions": 77}, "files": [{"sha": "3e6d1b2e9dcfbb41beb0bc854f4f93e8f2db093f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d63b5e9f25067b433a4dec4dea8539170761fcd6/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d63b5e9f25067b433a4dec4dea8539170761fcd6/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=d63b5e9f25067b433a4dec4dea8539170761fcd6", "patch": "@@ -1,3 +1,12 @@\n+2003-12-16  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/9043\n+\tC++ ABI change: Mangling array indices in templates.\n+\t* decl.c (compute_array_index_type): Reorganize for earlier\n+\ttemplate errors. Use value_dependent_expression_p for abi-2.\n+\t* mangle.c (write_array_type): Check broken mangling for\n+\texpression indices on abi-1\n+\n 2003-12-16  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/13275\n@@ -10,18 +19,18 @@\n \t(cp_parser_unary_expression): Allow the use of \"&\" in a constant\n \texpression if implementing offsetof.\n \n-2003-12-16  Giovanni Bajo  <giovannibajo@gcc.gnu.org>\r\n-\r\n-\tPR c++/2294\r\n+2003-12-16  Giovanni Bajo  <giovannibajo@gcc.gnu.org>\n+\n+\tPR c++/2294\n \t* name-lookup.c (push_overloaded_decl): always construct an OVERLOAD\r\n-\tif the declaration comes from an using declaration.\r\n+\tif the declaration comes from an using declaration.\n \n 2003-12-16  Giovanni Bajo  <giovannibajo@gcc.gnu.org>\n \n \t* semantics.c (finish_id_expression): Refactor the code to handle\n \ttemplate parameters, and emit a more informative error message\n \twhen they are used within an integral constant expression.\n-\r\n+\n 2003-12-16  Nathan Sidwell  <nathan@codesourcery.com>\n \n \tPR c++/13387\n@@ -17403,7 +17412,7 @@\n \t* parse.y (member_init): Just pass in the type.\n \t* init.c (expand_member_init): Handle getting a type.\n \n-2000-07-04  Martin v. L\u00f6wis  <loewis@informatik.hu-berlin.de>\n+2000-07-04  Martin v. L\ufffdwis  <loewis@informatik.hu-berlin.de>\n \t    Jason Merrill  <jason@redhat.com>\n \n \t* decl.c (finish_function): Warn if a function has no return\n@@ -17749,7 +17758,7 @@\n \t* decl.c (pushdecl): Don't set DECL_CONTEXT from current_namespace.\n \t(push_namespace): Set DECL_CONTEXT for a new NAMESPACE_DECL.\n \n-2000-06-24  Martin v. L\u00f6wis  <loewis@informatik.hu-berlin.de>\n+2000-06-24  Martin v. L\ufffdwis  <loewis@informatik.hu-berlin.de>\n \n \t* parse.y (complex_direct_notype_declarator): Support global_scope.\n \t* Makefile.in: Adjust conflict count.\n@@ -18934,7 +18943,7 @@\n \t* semantics.c (finish_member_declaration): Don't mark members of\n \tclasses declared in an extern \"C\" region as extern \"C\".\n \n-2000-05-22  Martin v. L\u00f6wis  <loewis@informatik.hu-berlin.de>\n+2000-05-22  Martin v. L\ufffdwis  <loewis@informatik.hu-berlin.de>\n \n \t* decl2.c (qualified_lookup_using_namespace): Look through\n \tnamespace aliases.\n@@ -19388,7 +19397,7 @@\n \n \t* ir.texi: Correct typo.\n \n-2000-04-25  Martin v. L\u00f6wis  <loewis@informatik.hu-berlin.de>\n+2000-04-25  Martin v. L\ufffdwis  <loewis@informatik.hu-berlin.de>\n \n \t* decl.c (grokdeclarator): Reject VLAs as members.\n \n@@ -19687,7 +19696,7 @@\n \t(interface_only): Don't declare.\n \t(interface_unknown): Likewise.\n \n-2000-04-11  Martin v. L\u00f6wis  <loewis@informatik.hu-berlin.de>\n+2000-04-11  Martin v. L\ufffdwis  <loewis@informatik.hu-berlin.de>\n \n \t* tree.h (HAVE_TEMPLATES): Remove definition.\n \t* lang-options.h (-fthis-is-variable): Remove documentation.\n@@ -19742,7 +19751,7 @@\n \t(__pointer_to_member_type_info::__do_catch): Remove.\n \t(__pointer_to_member_type_info::__pointer_catch): Implement.\n \n-2000-04-10  Martin v. L\u00f6wis  <loewis@informatik.hu-berlin.de>\n+2000-04-10  Martin v. L\ufffdwis  <loewis@informatik.hu-berlin.de>\n \n \t* lex.c (init_parse): Remove traces of classof and headof.\n \t* decl2.c (flag_operator_names): Default to 1.\n@@ -20455,7 +20464,7 @@ Wed Apr  5 15:12:18 MET DST 2000  Jan Hubicka  <jh@suse.cz>\n \t* init.c (build_offset_ref): Handle the case of a templated member\n \tfunction.\n \n-2000-03-19  Martin v. L\u00f6wis  <loewis@informatik.hu-berlin.de>\n+2000-03-19  Martin v. L\ufffdwis  <loewis@informatik.hu-berlin.de>\n \n \t* except.c (expand_exception_blocks): Clear catch_clauses_last.\n \n@@ -20481,7 +20490,7 @@ Wed Apr  5 15:12:18 MET DST 2000  Jan Hubicka  <jh@suse.cz>\n \t(layout_class_type): Implement new ABI handling of bitfields\n \tlonger than their types.\n \n-2000-03-18  Martin v. L\u00f6wis  <loewis@informatik.hu-berlin.de>\n+2000-03-18  Martin v. L\ufffdwis  <loewis@informatik.hu-berlin.de>\n \n \t* parse.y (extdefs): Call ggc_collect.\n \t* parse.c: Regenerated.\n@@ -21091,7 +21100,7 @@ Wed Apr  5 15:12:18 MET DST 2000  Jan Hubicka  <jh@suse.cz>\n \n \t* decl.c (decls_match): Remove obsolete static member nadgering.\n \n-2000-02-21  Martin v. L\u00f6wis  <loewis@informatik.hu-berlin.de>\n+2000-02-21  Martin v. L\ufffdwis  <loewis@informatik.hu-berlin.de>\n \n \t* decl.c (grokdeclarator): Change ANSI to ISO.\n \t* lex.c (consume_string, readescape, do_identifier): Likewise.\n@@ -22118,7 +22127,7 @@ Wed Apr  5 15:12:18 MET DST 2000  Jan Hubicka  <jh@suse.cz>\n \t* optimize.c (copy_body_r): Clear the operand three of a\n \tTARGET_EXPR when copying it.\n \n-2000-01-14  Martin v. L\u00f6wis  <loewis@informatik.hu-berlin.de>\n+2000-01-14  Martin v. L\ufffdwis  <loewis@informatik.hu-berlin.de>\n \n \t* method.c (build_decl_overload_real): Check whether we are in ::\n \tbefore returning __builtin_new/delete.\n@@ -22415,6 +22424,6 @@ Wed Apr  5 15:12:18 MET DST 2000  Jan Hubicka  <jh@suse.cz>\n \t(fixup_vtable_deltas1): Likewise.\n \t(finish_struct_1): Likewise.\n \n-2000-01-01  Martin v. L\u00f6wis  <loewis@informatik.hu-berlin.de>\n+2000-01-01  Martin v. L\ufffdwis  <loewis@informatik.hu-berlin.de>\n \n \t* call.c (build_new_method_call): Also check destructors."}, {"sha": "c054bfbe8f5b5f6d33cbe1daf2f4ed92a000ae9e", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 45, "deletions": 60, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d63b5e9f25067b433a4dec4dea8539170761fcd6/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d63b5e9f25067b433a4dec4dea8539170761fcd6/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=d63b5e9f25067b433a4dec4dea8539170761fcd6", "patch": "@@ -5982,48 +5982,35 @@ check_static_variable_definition (tree decl, tree type)\n tree\n compute_array_index_type (tree name, tree size)\n {\n+  tree type = TREE_TYPE (size);\n   tree itype;\n \n-  /* If this involves a template parameter, it will be a constant at\n-     instantiation time, but we don't know what the value is yet.\n-     Even if no template parameters are involved, we may an expression\n-     that is not a constant; we don't even simplify `1 + 2' when\n-     processing a template.  */\n-  if (processing_template_decl)\n+  /* The array bound must be an integer type.  */\n+  if (!dependent_type_p (type) && !INTEGRAL_TYPE_P (type))\n     {\n-      /* Resolve a qualified reference to an enumerator or static\n-\t const data member of ours.  */\n-      if (TREE_CODE (size) == SCOPE_REF\n-\t  && TREE_OPERAND (size, 0) == current_class_type)\n-\t{\n-\t  tree t = lookup_field (current_class_type,\n-\t\t\t\t TREE_OPERAND (size, 1), 0, false);\n-\t  if (t)\n-\t    size = t;\n-\t}\n-\n-      return build_index_type (build_min (MINUS_EXPR, sizetype,\n-\t\t\t\t\t  size, integer_one_node));\n+      if (name)\n+\terror (\"size of array `%D' has non-integral type `%T'\", name, type);\n+      else\n+\terror (\"size of array has non-integral type `%T'\", type);\n+      size = integer_one_node;\n+      type = TREE_TYPE (size);\n     }\n \n+  if (abi_version_at_least (2)\n+      /* We should only handle value dependent expressions specially.  */\n+      ? value_dependent_expression_p (size)\n+      /* But for abi-1, we handled all instances in templates. This\n+\t effects the manglings produced.  */\n+      : processing_template_decl)\n+    return build_index_type (build_min (MINUS_EXPR, sizetype,\n+\t\t\t\t\tsize, integer_one_node));\n+\n   /* The size might be the result of a cast.  */\n   STRIP_TYPE_NOPS (size);\n \n   /* It might be a const variable or enumeration constant.  */\n   size = decl_constant_value (size);\n \n-  /* The array bound must be an integer type.  */\n-  if (TREE_CODE (TREE_TYPE (size)) != INTEGER_TYPE\n-      && TREE_CODE (TREE_TYPE (size)) != ENUMERAL_TYPE\n-      && TREE_CODE (TREE_TYPE (size)) != BOOLEAN_TYPE)\n-    {\n-      if (name)\n-\terror (\"size of array `%D' has non-integer type\", name);\n-      else\n-\terror (\"size of array has non-integer type\");\n-      size = integer_one_node;\n-    }\n-\n   /* Normally, the array-bound will be a constant.  */\n   if (TREE_CODE (size) == INTEGER_CST)\n     {\n@@ -6065,38 +6052,36 @@ compute_array_index_type (tree name, tree size)\n       else\n \terror (\"size of array is not an integral constant-expression\");\n     }\n-\n-  /* Compute the index of the largest element in the array.  It is\n-     one less than the number of elements in the array.  */\n-  itype\n-    = fold (cp_build_binary_op (MINUS_EXPR,\n-\t\t\t\tcp_convert (ssizetype, size),\n-\t\t\t\tcp_convert (ssizetype,\n-\t\t\t\t\t    integer_one_node)));\n-\n-  /* Check for variable-sized arrays.  We allow such things as an\n-     extension, even though they are not allowed in ANSI/ISO C++.  */\n-  if (!TREE_CONSTANT (itype))\n+  else if (pedantic)\n     {\n-      if (pedantic)\n-\t{\n-\t  if (name)\n-\t    pedwarn (\"ISO C++ forbids variable-size array `%D'\",\n-\t\t\tname);\n-\t  else\n-\t    pedwarn (\"ISO C++ forbids variable-size array\");\n-\t}\n-\n-      /* Create a variable-sized array index type.  */\n-      itype = variable_size (itype);\n+      if (name)\n+\tpedwarn (\"ISO C++ forbids variable-size array `%D'\", name);\n+      else\n+\tpedwarn (\"ISO C++ forbids variable-size array\");\n     }\n-  /* Make sure that there was no overflow when creating to a signed\n-     index type.  (For example, on a 32-bit machine, an array with\n-     size 2^32 - 1 is too big.)  */\n-  else if (TREE_OVERFLOW (itype))\n+\n+  if (processing_template_decl && !TREE_CONSTANT (size))\n+    /* A variable sized array.  */\n+    itype = build_min (MINUS_EXPR, sizetype, size, integer_one_node);\n+  else\n     {\n-      error (\"overflow in array dimension\");\n-      TREE_OVERFLOW (itype) = 0;\n+      /* Compute the index of the largest element in the array.  It is\n+     \t one less than the number of elements in the array.  */\n+      itype\n+\t= fold (cp_build_binary_op (MINUS_EXPR,\n+\t\t\t\t    cp_convert (ssizetype, size),\n+\t\t\t\t    cp_convert (ssizetype, integer_one_node)));\n+      if (!TREE_CONSTANT (itype))\n+\t/* A variable sized array. */\n+\titype = variable_size (itype);\n+      /* Make sure that there was no overflow when creating to a signed\n+     \t index type.  (For example, on a 32-bit machine, an array with\n+     \t size 2^32 - 1 is too big.)  */\n+      else if (TREE_OVERFLOW (itype))\n+\t{\n+\t  error (\"overflow in array dimension\");\n+\t  TREE_OVERFLOW (itype) = 0;\n+\t}\n     }\n \n   /* Create and return the appropriate index type.  */"}, {"sha": "b34c309c82708b64962c9da88bf0de08d4445553", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d63b5e9f25067b433a4dec4dea8539170761fcd6/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d63b5e9f25067b433a4dec4dea8539170761fcd6/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=d63b5e9f25067b433a4dec4dea8539170761fcd6", "patch": "@@ -2242,7 +2242,20 @@ write_array_type (const tree type)\n \t  write_unsigned_number (tree_low_cst (max, 1));\n \t}\n       else\n-\twrite_expression (TREE_OPERAND (max, 0));\n+\t{\n+\t  max = TREE_OPERAND (max, 0);\n+\t  if (!abi_version_at_least (2))\n+\t    {\n+\t      /* value_dependent_expression_p presumes nothing is\n+\t         dependent when PROCESSING_TEMPLATE_DECL is zero.  */\n+\t      ++processing_template_decl;\n+\t      if (!value_dependent_expression_p (max))\n+\t\tG.need_abi_warning = 1;\n+\t      --processing_template_decl;\n+\t    }\n+\t  write_expression (max);\n+\t}\n+      \n     }\n   write_char ('_');\n   write_type (TREE_TYPE (type));"}, {"sha": "a2d9eaf2047de5a7067c2aae2ac67199d91b0a69", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d63b5e9f25067b433a4dec4dea8539170761fcd6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d63b5e9f25067b433a4dec4dea8539170761fcd6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d63b5e9f25067b433a4dec4dea8539170761fcd6", "patch": "@@ -1,3 +1,9 @@\n+2003-12-16  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/9043\n+\t* g++.dg/abi/mangle20-1.C: New test.\n+\t* g++.dg/abi/mangle20-2.C: New test.\n+\n 2003-12-16  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/13275"}, {"sha": "09cf51bcfb559e640031bb22951bdb9901f35986", "filename": "gcc/testsuite/g++.dg/abi/mangle20-1.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d63b5e9f25067b433a4dec4dea8539170761fcd6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle20-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d63b5e9f25067b433a4dec4dea8539170761fcd6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle20-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle20-1.C?ref=d63b5e9f25067b433a4dec4dea8539170761fcd6", "patch": "@@ -0,0 +1,19 @@\n+// { dg-do compile }\n+// { dg-options \"-fabi-version=2\" }\n+\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 15 Dec 2003 <nathan@codesourcery.com>\n+\n+// PR 9043\n+// mangled array types in templates\n+\n+template <int I> void f(int (*)[2]) {}\n+template <int I> void g(int (*)[I+2]) {}\n+\n+static const int I=1;\n+static const int J=2;\n+\n+template void f<1>(int (*)[2]);\n+//  { dg-final { scan-assembler \"\\n_Z1fILi1EEvPA2_i:\" } }\n+template void g<1>(int (*)[3]);\n+//  { dg-final { scan-assembler \"\\n_Z1gILi1EEvPAplT_Li2E_i:\" } }"}, {"sha": "44d3afefb54ad2d05887afc02096bb1a0004b6d8", "filename": "gcc/testsuite/g++.dg/abi/mangle20-2.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d63b5e9f25067b433a4dec4dea8539170761fcd6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle20-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d63b5e9f25067b433a4dec4dea8539170761fcd6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle20-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle20-2.C?ref=d63b5e9f25067b433a4dec4dea8539170761fcd6", "patch": "@@ -0,0 +1,16 @@\n+// { dg-do compile }\n+// { dg-options \"-fabi-version=1 -Wabi\" }\n+\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 15 Dec 2003 <nathan@codesourcery.com>\n+\n+// PR 9043\n+// mangled array types in templates\n+\n+template <int I> void f(int (*)[2]) {}\n+template <int I> void g(int (*)[I+2]) {}\n+\n+template void f<1>(int (*)[2]);  // { dg-warning \"mangled name\" }\n+//  { dg-final { scan-assembler \"\\n_Z1fILi1EEvPALi2E_i:\" } }\n+template void g<1>(int (*)[3]);\n+//  { dg-final { scan-assembler \"\\n_Z1gILi1EEvPAplT_Li2E_i:\" } }"}]}