{"sha": "e5f6a288fb94fa9ca3bf7408fc03146fbd292003", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTVmNmEyODhmYjk0ZmE5Y2EzYmY3NDA4ZmMwMzE0NmZiZDI5MjAwMw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-04-19T02:12:25Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-04-19T02:12:25Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r790", "tree": {"sha": "8401d620c8eacb58c37ae5edd4ff87330b5098ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8401d620c8eacb58c37ae5edd4ff87330b5098ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e5f6a288fb94fa9ca3bf7408fc03146fbd292003", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5f6a288fb94fa9ca3bf7408fc03146fbd292003", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5f6a288fb94fa9ca3bf7408fc03146fbd292003", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5f6a288fb94fa9ca3bf7408fc03146fbd292003/comments", "author": null, "committer": null, "parents": [{"sha": "c8332879d817e0d98faafef982099d9c963789df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8332879d817e0d98faafef982099d9c963789df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8332879d817e0d98faafef982099d9c963789df"}], "stats": {"total": 170, "additions": 153, "deletions": 17}, "files": [{"sha": "7c3057be69d3ed26a88cff3710222ba18d793d1a", "filename": "gcc/cse.c", "status": "modified", "additions": 93, "deletions": 7, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5f6a288fb94fa9ca3bf7408fc03146fbd292003/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5f6a288fb94fa9ca3bf7408fc03146fbd292003/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=e5f6a288fb94fa9ca3bf7408fc03146fbd292003", "patch": "@@ -453,7 +453,7 @@ struct table_elt\n       : (FIXED_REGNO_P (REGNO (X))\t\t\t\\\n \t && REGNO_REG_CLASS (REGNO (X)) != NO_REGS) ? 0\t\\\n       : 2)\t\t\t\t\t\t\\\n-   : rtx_cost (X) * 2)\t\t\t\t\t\\\n+   : rtx_cost (X, SET) * 2)\n \n /* Determine if the quantity number for register X represents a valid index\n    into the `qty_...' variables.  */\n@@ -569,8 +569,9 @@ static void cse_set_around_loop ();\n #define COSTS_N_INSNS(N) ((N) * 4 - 2)\n \n int\n-rtx_cost (x)\n+rtx_cost (x, outer_code)\n      rtx x;\n+     enum rtx_code outer_code;\n {\n   register int i, j;\n   register enum rtx_code code;\n@@ -627,9 +628,9 @@ rtx_cost (x)\n \t\t\t      + GET_MODE_SIZE (GET_MODE (x)) / UNITS_PER_WORD);\n       return 2;\n #ifdef RTX_COSTS\n-      RTX_COSTS (x, code);\n+      RTX_COSTS (x, code, outer_code);\n #endif \n-      CONST_COSTS (x, code);\n+      CONST_COSTS (x, code, outer_code);\n     }\n \n   /* Sum the costs of the sub-rtx's, plus cost of this operation,\n@@ -638,10 +639,10 @@ rtx_cost (x)\n   fmt = GET_RTX_FORMAT (code);\n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n     if (fmt[i] == 'e')\n-      total += rtx_cost (XEXP (x, i));\n+      total += rtx_cost (XEXP (x, i), code);\n     else if (fmt[i] == 'E')\n       for (j = 0; j < XVECLEN (x, i); j++)\n-\ttotal += rtx_cost (XVECEXP (x, i, j));\n+\ttotal += rtx_cost (XVECEXP (x, i, j), code);\n \n   return total;\n }\n@@ -815,7 +816,7 @@ mention_regs (x)\n   register int changed = 0;\n \n   if (x == 0)\n-    return;\n+    return 0;\n \n   code = GET_CODE (x);\n   if (code == REG)\n@@ -4157,6 +4158,11 @@ fold_rtx (x, insn)\n \t  && (new = lookup_as_function (x, CONST_INT)) != 0)\n \treturn new;\n \n+      /* If this is a paradoxical SUBREG, we can't do anything with\n+\t it because we have no idea what value the extra bits would have.  */\n+      if (GET_MODE_SIZE (mode) > GET_MODE_SIZE (GET_MODE (SUBREG_REG (x))))\n+\treturn x;\n+\n       /* Fold SUBREG_REG.  If it changed, see if we can simplify the SUBREG.\n \t We might be able to if the SUBREG is extracting a single word in an\n \t integral mode or extracting the low part.  */\n@@ -4180,6 +4186,86 @@ fold_rtx (x, insn)\n \t  if (new)\n \t    return new;\n \t}\n+\n+      /* If this is a narrowing SUBREG and our operand is a REG, see if\n+\t we can find an equivalence for REG that is a arithmetic operation\n+\t in a wider mode where both operands are paradoxical SUBREGs\n+\t from objects of our result mode.  In that case, we couldn't report\n+\t an equivalent value for that operation, since we don't know what the\n+\t extra bits will be.  But we can find an equivalence for this SUBREG\n+\t by folding that operation is the narrow mode.  This allows us to\n+\t fold arithmetic in narrow modes when the machine only supports\n+\t word-sized arithmetic.  */\n+\n+      if (GET_CODE (folded_arg0) == REG\n+\t  && GET_MODE_SIZE (mode) < GET_MODE_SIZE (GET_MODE (folded_arg0)))\n+\t{\n+\t  struct table_elt *elt;\n+\n+\t  /* We can use HASH here since we know that canon_hash won't be\n+\t     called.  */\n+\t  elt = lookup (folded_arg0,\n+\t\t\tHASH (folded_arg0, GET_MODE (folded_arg0)),\n+\t\t\tGET_MODE (folded_arg0));\n+\n+\t  if (elt)\n+\t    elt = elt->first_same_value;\n+\n+\t  for (; elt; elt = elt->next_same_value)\n+\t    {\n+\t      /* Just check for unary and binary operations.  */\n+\t      if (GET_RTX_CLASS (GET_CODE (elt->exp)) == '1'\n+\t\t  && GET_CODE (elt->exp) != SIGN_EXTEND\n+\t\t  && GET_CODE (elt->exp) != ZERO_EXTEND\n+\t\t  && GET_CODE (XEXP (elt->exp, 0)) == SUBREG\n+\t\t  && GET_MODE (SUBREG_REG (XEXP (elt->exp, 0))) == mode)\n+\t\t{\n+\t\t  rtx op0 = SUBREG_REG (XEXP (elt->exp, 0));\n+\n+\t\t  if (GET_CODE (op0) != REG && ! CONSTANT_P (op0))\n+\t\t    op0 = fold_rtx (op0, 0);\n+\n+\t\t  op0 = equiv_constant (op0);\n+\t\t  if (op0)\n+\t\t    new = simplify_unary_operation (GET_CODE (elt->exp), mode,\n+\t\t\t\t\t\t    op0, mode);\n+\t\t}\n+\t      else if ((GET_RTX_CLASS (GET_CODE (elt->exp)) == '2'\n+\t\t\t|| GET_RTX_CLASS (GET_CODE (elt->exp)) == 'c')\n+\t\t       && ((GET_CODE (XEXP (elt->exp, 0)) == SUBREG\n+\t\t\t    && (GET_MODE (SUBREG_REG (XEXP (elt->exp, 0)))\n+\t\t\t\t== mode))\n+\t\t\t   || CONSTANT_P (XEXP (elt->exp, 0)))\n+\t\t       && ((GET_CODE (XEXP (elt->exp, 1)) == SUBREG\n+\t\t\t    && (GET_MODE (SUBREG_REG (XEXP (elt->exp, 1)))\n+\t\t\t\t== mode))\n+\t\t\t   || CONSTANT_P (XEXP (elt->exp, 1))))\n+\t\t{\n+\t\t  rtx op0 = gen_lowpart_common (mode, XEXP (elt->exp, 0));\n+\t\t  rtx op1 = gen_lowpart_common (mode, XEXP (elt->exp, 1));\n+\n+\t\t  if (op0 && GET_CODE (op0) != REG && ! CONSTANT_P (op0))\n+\t\t    op0 = fold_rtx (op0, 0);\n+\n+\t\t  if (op0)\n+\t\t    op0 = equiv_constant (op0);\n+\n+\t\t  if (op1 && GET_CODE (op1) != REG && ! CONSTANT_P (op1))\n+\t\t    op1 = fold_rtx (op1, 0);\n+\n+\t\t  if (op1)\n+\t\t    op1 = equiv_constant (op1);\n+\n+\t\t  if (op0 && op1)\n+\t\t    new = simplify_binary_operation (GET_CODE (elt->exp), mode,\n+\t\t\t\t\t\t     op0, op1);\n+\t\t}\n+\n+\t      if (new)\n+\t\treturn new;\n+\t    }\n+\t}\n+\n       return x;\n \n     case NOT:"}, {"sha": "f85444da4a41cd4dcec9e0b1d94f07fbd6470d2b", "filename": "gcc/genemit.c", "status": "modified", "additions": 60, "deletions": 10, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5f6a288fb94fa9ca3bf7408fc03146fbd292003/gcc%2Fgenemit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5f6a288fb94fa9ca3bf7408fc03146fbd292003/gcc%2Fgenemit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenemit.c?ref=e5f6a288fb94fa9ca3bf7408fc03146fbd292003", "patch": "@@ -47,12 +47,20 @@ static int insn_index_number;\n \n struct clobber_pat\n {\n-  int code_number;\t\t/* Counts only insns.  */\n+  struct clobber_ent *insns;\n   rtx pattern;\n   int first_clobber;\n   struct clobber_pat *next;\n } *clobber_list;\n \n+/* Records one insn that uses the clobber list.  */\n+\n+struct clobber_ent\n+{\n+  int code_number;\t\t/* Counts only insns.  */\n+  struct clobber_ent *next;\n+};\n+\n static void\n max_operand_1 (x)\n      rtx x;\n@@ -271,14 +279,54 @@ gen_insn (insn)\n \n       if (i != XVECLEN (insn, 1) - 1)\n \t{\n-\t  register struct clobber_pat *new\n-\t    = (struct clobber_pat *) xmalloc (sizeof (struct clobber_pat));\n+\t  register struct clobber_pat *p;\n+\t  register struct clobber_ent *link\n+\t    = (struct clobber_ent *) xmalloc (sizeof (struct clobber_ent));\n+\t  register int j;\n+\n+\t  link->code_number = insn_code_number;\n+\n+\t  /* See if any previous CLOBBER_LIST entry is the same as this\n+\t     one.  */\n+\n+\t  for (p = clobber_list; p; p = p->next)\n+\t    {\n+\t      if (p->first_clobber != i + 1\n+\t\t  || XVECLEN (p->pattern, 1) != XVECLEN (insn, 1))\n+\t\tcontinue;\n+\n+\t      for (j = i + 1; j < XVECLEN (insn, 1); j++)\n+\t\t{\n+\t\t  rtx old = XEXP (XVECEXP (p->pattern, 1, j), 0);\n+\t\t  rtx new = XEXP (XVECEXP (insn, 1, j), 0);\n+\n+\t\t  /* OLD and NEW are the same if both are to be a SCRATCH\n+\t\t     or if both are registers of the same mode and number.  */\n+\t\t  if (! ((GET_CODE (old) == MATCH_SCRATCH\n+\t\t\t  && GET_CODE (new) == MATCH_SCRATCH)\n+\t\t\t || (GET_CODE (old) == REG && GET_CODE (new) == REG\n+\t\t\t     && GET_MODE (old) == GET_MODE (new)\n+\t\t\t     && REGNO (old) == REGNO (new))))\n+\t\t    break;\n+\t\t}\n+      \n+\t      if (j == XVECLEN (insn, 1))\n+\t\tbreak;\n+\t    }\n+\n+\t  if (p == 0)\n+\t    {\n+\t      p = (struct clobber_pat *) xmalloc (sizeof (struct clobber_pat));\n \t  \n-\t  new->code_number = insn_code_number;\n-\t  new->pattern = insn;\n-\t  new->first_clobber = i + 1;\n-\t  new->next = clobber_list;\n-\t  clobber_list = new;\n+\t      p->insns = 0;\n+\t      p->pattern = insn;\n+\t      p->first_clobber = i + 1;\n+\t      p->next = clobber_list;\n+\t      clobber_list = p;\n+\t    }\n+\n+\t  link->next = p->insns;\n+\t  p->insns = link;\n \t}\n     }\n \n@@ -547,6 +595,7 @@ static void\n output_add_clobbers ()\n {\n   struct clobber_pat *clobber;\n+  struct clobber_ent *ent;\n   int i;\n \n   printf (\"\\n\\nvoid\\nadd_clobbers (pattern, insn_code_number)\\n\");\n@@ -558,7 +607,8 @@ output_add_clobbers ()\n \n   for (clobber = clobber_list; clobber; clobber = clobber->next)\n     {\n-      printf (\"    case %d:\\n\", clobber->code_number);\n+      for (ent = clobber->insns; ent; ent = ent->next)\n+\tprintf (\"    case %d:\\n\", ent->code_number);\n \n       for (i = clobber->first_clobber; i < XVECLEN (clobber->pattern, 1); i++)\n \t{\n@@ -567,7 +617,7 @@ output_add_clobbers ()\n \t  printf (\";\\n\");\n \t}\n \n-      printf (\"      break;\\n\");\n+      printf (\"      break;\\n\\n\");\n     }\n \n   printf (\"    default:\\n\");"}]}