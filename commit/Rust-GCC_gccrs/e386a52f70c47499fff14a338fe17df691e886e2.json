{"sha": "e386a52f70c47499fff14a338fe17df691e886e2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTM4NmE1MmY3MGM0NzQ5OWZmZjE0YTMzOGZlMTdkZjY5MWU4ODZlMg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-08-30T11:09:10Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-08-30T11:09:10Z"}, "message": "[7/77] Add scalar_float_mode\n\nThis patch adds a scalar_float_mode class, which wraps a mode enum\nthat is known to satisfy SCALAR_FLOAT_MODE_P.  Things like \"SFmode\"\nnow give a scalar_float_mode object instead of a machine_mode.\nThis in turn needs a change to the real.h format_helper, so that\nit can accept both machine_modes and scalar_float_modes.\n\n2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* coretypes.h (scalar_float_mode): New type.\n\t* machmode.h (mode_traits::from_int): Use machine_mode if\n\tUSE_ENUM_MODES is defined.\n\t(is_a): New function.\n\t(as_a): Likewise.\n\t(dyn_cast): Likewise.\n\t(scalar_float_mode): New class.\n\t(scalar_float_mode::includes_p): New function.\n\t(is_float_mode): Likewise.\n\t* gdbhooks.py (MachineModePrinter): New class.\n\t(build_pretty_printer): Use it for scalar_float_mode.\n\t* real.h (FLOAT_MODE_FORMAT): Use as_a <scalar_float_mode>.\n\t(format_helper::format_helper): Turn into a template.\n\t* genmodes.c (get_mode_class): New function.\n\t(emit_insn_modes_h): Give modes the class returned by get_mode_class,\n\tor machine_mode if none.\n\t* config/aarch64/aarch64.c (aarch64_simd_valid_immediate): Use\n\tas_a <scalar_float_mode>.\n\t* dwarf2out.c (mem_loc_descriptor): Likewise.\n\t(insert_float): Likewise.\n\t(add_const_value_attribute): Likewise.\n\t* simplify-rtx.c (simplify_immed_subreg): Likewise.\n\t* optabs.c (expand_absneg_bit): Take a scalar_float_mode.\n\t(expand_unop): Update accordingly.\n\t(expand_abs_nojump): Likewise.\n\t(expand_copysign_absneg): Take a scalar_float_mode.\n\t(expand_copysign_bit): Likewise.\n\t(expand_copysign): Update accordingly.\n\ngcc/ada/\n\t* gcc-interface/utils.c (gnat_type_for_mode): Use is_a\n\t<scalar_float_mode> instead of SCALAR_FLOAT_MODE_P.\n\ngcc/go/\n\t* go-lang.c (go_langhook_type_for_mode): Use is_float_mode.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r251458", "tree": {"sha": "bf21dc05503e220cd0d838c391f028ef314c252b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf21dc05503e220cd0d838c391f028ef314c252b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e386a52f70c47499fff14a338fe17df691e886e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e386a52f70c47499fff14a338fe17df691e886e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e386a52f70c47499fff14a338fe17df691e886e2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e386a52f70c47499fff14a338fe17df691e886e2/comments", "author": null, "committer": null, "parents": [{"sha": "490d0f6c91c0c4fef57a5ffe438629b0687113de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/490d0f6c91c0c4fef57a5ffe438629b0687113de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/490d0f6c91c0c4fef57a5ffe438629b0687113de"}], "stats": {"total": 272, "additions": 228, "deletions": 44}, "files": [{"sha": "6f5107fb4464fd849abdbc87803913fc66425bd5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e386a52f70c47499fff14a338fe17df691e886e2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e386a52f70c47499fff14a338fe17df691e886e2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e386a52f70c47499fff14a338fe17df691e886e2", "patch": "@@ -1,3 +1,36 @@\n+2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* coretypes.h (scalar_float_mode): New type.\n+\t* machmode.h (mode_traits::from_int): Use machine_mode if\n+\tUSE_ENUM_MODES is defined.\n+\t(is_a): New function.\n+\t(as_a): Likewise.\n+\t(dyn_cast): Likewise.\n+\t(scalar_float_mode): New class.\n+\t(scalar_float_mode::includes_p): New function.\n+\t(is_float_mode): Likewise.\n+\t* gdbhooks.py (MachineModePrinter): New class.\n+\t(build_pretty_printer): Use it for scalar_float_mode.\n+\t* real.h (FLOAT_MODE_FORMAT): Use as_a <scalar_float_mode>.\n+\t(format_helper::format_helper): Turn into a template.\n+\t* genmodes.c (get_mode_class): New function.\n+\t(emit_insn_modes_h): Give modes the class returned by get_mode_class,\n+\tor machine_mode if none.\n+\t* config/aarch64/aarch64.c (aarch64_simd_valid_immediate): Use\n+\tas_a <scalar_float_mode>.\n+\t* dwarf2out.c (mem_loc_descriptor): Likewise.\n+\t(insert_float): Likewise.\n+\t(add_const_value_attribute): Likewise.\n+\t* simplify-rtx.c (simplify_immed_subreg): Likewise.\n+\t* optabs.c (expand_absneg_bit): Take a scalar_float_mode.\n+\t(expand_unop): Update accordingly.\n+\t(expand_abs_nojump): Likewise.\n+\t(expand_copysign_absneg): Take a scalar_float_mode.\n+\t(expand_copysign_bit): Likewise.\n+\t(expand_copysign): Update accordingly.\n+\n 2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "9aab1314575005fa6245737d3c0138c0b0c15920", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e386a52f70c47499fff14a338fe17df691e886e2/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e386a52f70c47499fff14a338fe17df691e886e2/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=e386a52f70c47499fff14a338fe17df691e886e2", "patch": "@@ -1,3 +1,10 @@\n+2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* gcc-interface/utils.c (gnat_type_for_mode): Use is_a\n+\t<scalar_float_mode> instead of SCALAR_FLOAT_MODE_P.\n+\n 2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "23127aa6896d2bd3322033b15b3319321710c449", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e386a52f70c47499fff14a338fe17df691e886e2/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e386a52f70c47499fff14a338fe17df691e886e2/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=e386a52f70c47499fff14a338fe17df691e886e2", "patch": "@@ -3464,8 +3464,10 @@ gnat_type_for_mode (machine_mode mode, int unsignedp)\n   if (COMPLEX_MODE_P (mode))\n     return NULL_TREE;\n \n-  if (SCALAR_FLOAT_MODE_P (mode))\n-    return float_type_for_precision (GET_MODE_PRECISION (mode), mode);\n+  scalar_float_mode float_mode;\n+  if (is_a <scalar_float_mode> (mode, &float_mode))\n+    return float_type_for_precision (GET_MODE_PRECISION (float_mode),\n+\t\t\t\t     float_mode);\n \n   if (SCALAR_INT_MODE_P (mode))\n     return gnat_type_for_size (GET_MODE_BITSIZE (mode), unsignedp);"}, {"sha": "88373dd812c8693adc08ee82766429e5adfdc584", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e386a52f70c47499fff14a338fe17df691e886e2/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e386a52f70c47499fff14a338fe17df691e886e2/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=e386a52f70c47499fff14a338fe17df691e886e2", "patch": "@@ -11473,8 +11473,12 @@ aarch64_simd_valid_immediate (rtx op, machine_mode mode, bool inverse,\n \n       if (info)\n \t{\n-\t  info->value = CONST_VECTOR_ELT (op, 0);\n-\t  info->element_width = GET_MODE_BITSIZE (GET_MODE (info->value));\n+\t  rtx elt = CONST_VECTOR_ELT (op, 0);\n+\t  scalar_float_mode elt_mode\n+\t    = as_a <scalar_float_mode> (GET_MODE (elt));\n+\n+\t  info->value = elt;\n+\t  info->element_width = GET_MODE_BITSIZE (elt_mode);\n \t  info->mvn = false;\n \t  info->shift = 0;\n \t}"}, {"sha": "216c29f6f1e0ce500373e097a6678f455fd243b7", "filename": "gcc/coretypes.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e386a52f70c47499fff14a338fe17df691e886e2/gcc%2Fcoretypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e386a52f70c47499fff14a338fe17df691e886e2/gcc%2Fcoretypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoretypes.h?ref=e386a52f70c47499fff14a338fe17df691e886e2", "patch": "@@ -55,6 +55,7 @@ typedef const struct simple_bitmap_def *const_sbitmap;\n struct rtx_def;\n typedef struct rtx_def *rtx;\n typedef const struct rtx_def *const_rtx;\n+class scalar_float_mode;\n template<typename> class opt_mode;\n \n /* Subclasses of rtx_def, using indentation to show the class\n@@ -311,6 +312,8 @@ union _dont_use_tree_here_;\n #define tree union _dont_use_tree_here_ *\n #define const_tree union _dont_use_tree_here_ *\n \n+typedef struct scalar_float_mode scalar_float_mode;\n+\n #endif\n \n /* Classes of functions that compiler needs to check"}, {"sha": "aafacf475cda11d19b15bb5fb7a5a43ddb7ad6ca", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e386a52f70c47499fff14a338fe17df691e886e2/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e386a52f70c47499fff14a338fe17df691e886e2/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=e386a52f70c47499fff14a338fe17df691e886e2", "patch": "@@ -15324,7 +15324,8 @@ mem_loc_descriptor (rtx rtl, machine_mode mode,\n \t  else\n #endif\n \t    {\n-\t      unsigned int length = GET_MODE_SIZE (mode);\n+\t      scalar_float_mode float_mode = as_a <scalar_float_mode> (mode);\n+\t      unsigned int length = GET_MODE_SIZE (float_mode);\n \t      unsigned char *array = ggc_vec_alloc<unsigned char> (length);\n \n \t      insert_float (rtl, array);\n@@ -18621,11 +18622,12 @@ insert_float (const_rtx rtl, unsigned char *array)\n {\n   long val[4];\n   int i;\n+  scalar_float_mode mode = as_a <scalar_float_mode> (GET_MODE (rtl));\n \n-  real_to_target (val, CONST_DOUBLE_REAL_VALUE (rtl), GET_MODE (rtl));\n+  real_to_target (val, CONST_DOUBLE_REAL_VALUE (rtl), mode);\n \n   /* real_to_target puts 32-bit pieces in each long.  Pack them.  */\n-  for (i = 0; i < GET_MODE_SIZE (GET_MODE (rtl)) / 4; i++)\n+  for (i = 0; i < GET_MODE_SIZE (mode) / 4; i++)\n     {\n       insert_int (val[i], 4, array);\n       array += 4;\n@@ -18669,21 +18671,19 @@ add_const_value_attribute (dw_die_ref die, rtx rtl)\n \t floating-point constant.  A CONST_DOUBLE is used whenever the\n \t constant requires more than one word in order to be adequately\n \t represented.  */\n-      {\n-\tmachine_mode mode = GET_MODE (rtl);\n-\n-\tif (TARGET_SUPPORTS_WIDE_INT == 0 && !SCALAR_FLOAT_MODE_P (mode))\n-\t  add_AT_double (die, DW_AT_const_value,\n-\t\t\t CONST_DOUBLE_HIGH (rtl), CONST_DOUBLE_LOW (rtl));\n-\telse\n-\t  {\n-\t    unsigned int length = GET_MODE_SIZE (mode);\n-\t    unsigned char *array = ggc_vec_alloc<unsigned char> (length);\n+      if (TARGET_SUPPORTS_WIDE_INT == 0\n+\t  && !SCALAR_FLOAT_MODE_P (GET_MODE (rtl)))\n+\tadd_AT_double (die, DW_AT_const_value,\n+\t\t       CONST_DOUBLE_HIGH (rtl), CONST_DOUBLE_LOW (rtl));\n+      else\n+\t{\n+\t  scalar_float_mode mode = as_a <scalar_float_mode> (GET_MODE (rtl));\n+\t  unsigned int length = GET_MODE_SIZE (mode);\n+\t  unsigned char *array = ggc_vec_alloc<unsigned char> (length);\n \n-\t    insert_float (rtl, array);\n-\t    add_AT_vec (die, DW_AT_const_value, length / 4, 4, array);\n-\t  }\n-      }\n+\t  insert_float (rtl, array);\n+\t  add_AT_vec (die, DW_AT_const_value, length / 4, 4, array);\n+\t}\n       return true;\n \n     case CONST_VECTOR:"}, {"sha": "4cbcefc4fc48410b455910ec2e21062f27d874e1", "filename": "gcc/gdbhooks.py", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e386a52f70c47499fff14a338fe17df691e886e2/gcc%2Fgdbhooks.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e386a52f70c47499fff14a338fe17df691e886e2/gcc%2Fgdbhooks.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgdbhooks.py?ref=e386a52f70c47499fff14a338fe17df691e886e2", "patch": "@@ -422,6 +422,16 @@ def children (self):\n \n ######################################################################\n \n+class MachineModePrinter:\n+    def __init__(self, gdbval):\n+        self.gdbval = gdbval\n+\n+    def to_string (self):\n+        name = str(self.gdbval['m_mode'])\n+        return name[2:] if name.startswith('E_') else name\n+\n+######################################################################\n+\n class OptMachineModePrinter:\n     def __init__(self, gdbval):\n         self.gdbval = gdbval\n@@ -532,6 +542,8 @@ def build_pretty_printer():\n \n     pp.add_printer_for_regex(r'opt_mode<(\\S+)>',\n                              'opt_mode', OptMachineModePrinter)\n+    pp.add_printer_for_types(['scalar_float_mode'],\n+                             'scalar_float_mode', MachineModePrinter)\n \n     return pp\n "}, {"sha": "8c27b42305428f834158b9801564c86ff97e084b", "filename": "gcc/genmodes.c", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e386a52f70c47499fff14a338fe17df691e886e2/gcc%2Fgenmodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e386a52f70c47499fff14a338fe17df691e886e2/gcc%2Fgenmodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmodes.c?ref=e386a52f70c47499fff14a338fe17df691e886e2", "patch": "@@ -1129,6 +1129,23 @@ mode_unit_precision_inline (machine_mode mode)\\n\\\n }\\n\");\n }\n \n+/* Return the best machine mode class for MODE, or null if machine_mode\n+   should be used.  */\n+\n+static const char *\n+get_mode_class (struct mode_data *mode)\n+{\n+  switch (mode->cl)\n+    {\n+    case MODE_FLOAT:\n+    case MODE_DECIMAL_FLOAT:\n+      return \"scalar_float_mode\";\n+\n+    default:\n+      return NULL;\n+    }\n+}\n+\n static void\n emit_insn_modes_h (void)\n {\n@@ -1158,8 +1175,12 @@ enum machine_mode\\n{\");\n \tprintf (\"#ifdef USE_ENUM_MODES\\n\");\n \tprintf (\"#define %smode E_%smode\\n\", m->name, m->name);\n \tprintf (\"#else\\n\");\n-\tprintf (\"#define %smode ((void) 0, E_%smode)\\n\",\n-\t\tm->name, m->name);\n+\tif (const char *mode_class = get_mode_class (m))\n+\t  printf (\"#define %smode (%s ((%s::from_int) E_%smode))\\n\",\n+\t\t  m->name, mode_class, mode_class, m->name);\n+\telse\n+\t  printf (\"#define %smode ((void) 0, E_%smode)\\n\",\n+\t\t  m->name, m->name);\n \tprintf (\"#endif\\n\");\n       }\n "}, {"sha": "f65a1d47ce01c8448a412a80dac978ddfb4a7407", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e386a52f70c47499fff14a338fe17df691e886e2/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e386a52f70c47499fff14a338fe17df691e886e2/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=e386a52f70c47499fff14a338fe17df691e886e2", "patch": "@@ -1,3 +1,9 @@\n+2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* go-lang.c (go_langhook_type_for_mode): Use is_float_mode.\n+\n 2017-08-07  Martin Liska  <mliska@suse.cz>\n \n \t* go-gcc.cc (Gcc_backend::function): Look up for no_split_stack"}, {"sha": "614d89029534a24f24e2b5b3dc2cfcc7310d5f77", "filename": "gcc/go/go-lang.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e386a52f70c47499fff14a338fe17df691e886e2/gcc%2Fgo%2Fgo-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e386a52f70c47499fff14a338fe17df691e886e2/gcc%2Fgo%2Fgo-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-lang.c?ref=e386a52f70c47499fff14a338fe17df691e886e2", "patch": "@@ -382,12 +382,13 @@ go_langhook_type_for_mode (machine_mode mode, int unsignedp)\n       return NULL_TREE;\n     }\n \n+  scalar_float_mode fmode;\n   enum mode_class mc = GET_MODE_CLASS (mode);\n   if (mc == MODE_INT)\n     return go_langhook_type_for_size (GET_MODE_BITSIZE (mode), unsignedp);\n-  else if (mc == MODE_FLOAT)\n+  else if (is_float_mode (mode, &fmode))\n     {\n-      switch (GET_MODE_BITSIZE (mode))\n+      switch (GET_MODE_BITSIZE (fmode))\n \t{\n \tcase 32:\n \t  return float_type_node;\n@@ -396,7 +397,7 @@ go_langhook_type_for_mode (machine_mode mode, int unsignedp)\n \tdefault:\n \t  // We have to check for long double in order to support\n \t  // i386 excess precision.\n-\t  if (mode == TYPE_MODE(long_double_type_node))\n+\t  if (fmode == TYPE_MODE(long_double_type_node))\n \t    return long_double_type_node;\n \t}\n     }"}, {"sha": "3b71b9da5ccb823e63af438426092092bbc4fc9e", "filename": "gcc/machmode.h", "status": "modified", "additions": 94, "deletions": 3, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e386a52f70c47499fff14a338fe17df691e886e2/gcc%2Fmachmode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e386a52f70c47499fff14a338fe17df691e886e2/gcc%2Fmachmode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.h?ref=e386a52f70c47499fff14a338fe17df691e886e2", "patch": "@@ -46,9 +46,15 @@ struct mode_traits\n        res = T (typename mode_traits<T>::from_int (mode));\n \n      when assigning to a value RES that must be assignment-compatible\n-     with (but possibly not the same as) T.\n-\n-     Here we use an enum type distinct from machine_mode but with the\n+     with (but possibly not the same as) T.  */\n+#ifdef USE_ENUM_MODES\n+  /* Allow direct conversion of enums to specific mode classes only\n+     when USE_ENUM_MODES is defined.  This is only intended for use\n+     by gencondmd, so that it can tell more easily when .md conditions\n+     are always false.  */\n+  typedef machine_mode from_int;\n+#else\n+  /* Here we use an enum type distinct from machine_mode but with the\n      same range as machine_mode.  T should have a constructor that\n      accepts this enum type; it should not have a constructor that\n      accepts machine_mode.\n@@ -58,6 +64,7 @@ struct mode_traits\n      unoptimized code, the return statement above would construct the\n      returned T directly from the numerical value of MODE.  */\n   enum from_int { dummy = MAX_MACHINE_MODE };\n+#endif\n };\n \n template<>\n@@ -286,6 +293,75 @@ opt_mode<T>::exists (U *mode) const\n   return false;\n }\n \n+/* Return true if mode M has type T.  */\n+\n+template<typename T>\n+inline bool\n+is_a (machine_mode m)\n+{\n+  return T::includes_p (m);\n+}\n+\n+/* Assert that mode M has type T, and return it in that form.  */\n+\n+template<typename T>\n+inline T\n+as_a (machine_mode m)\n+{\n+  gcc_checking_assert (T::includes_p (m));\n+  return typename mode_traits<T>::from_int (m);\n+}\n+\n+/* Convert M to an opt_mode<T>.  */\n+\n+template<typename T>\n+inline opt_mode<T>\n+dyn_cast (machine_mode m)\n+{\n+  if (T::includes_p (m))\n+    return T (typename mode_traits<T>::from_int (m));\n+  return opt_mode<T> ();\n+}\n+\n+/* Return true if mode M has type T, storing it as a T in *RESULT\n+   if so.  */\n+\n+template<typename T, typename U>\n+inline bool\n+is_a (machine_mode m, U *result)\n+{\n+  if (T::includes_p (m))\n+    {\n+      *result = T (typename mode_traits<T>::from_int (m));\n+      return true;\n+    }\n+  return false;\n+}\n+\n+/* Represents a machine mode that is known to be a SCALAR_FLOAT_MODE_P.  */\n+class scalar_float_mode\n+{\n+public:\n+  typedef mode_traits<scalar_float_mode>::from_int from_int;\n+\n+  ALWAYS_INLINE scalar_float_mode () {}\n+  ALWAYS_INLINE scalar_float_mode (from_int m) : m_mode (machine_mode (m)) {}\n+  ALWAYS_INLINE operator machine_mode () const { return m_mode; }\n+\n+  static bool includes_p (machine_mode);\n+\n+protected:\n+  machine_mode m_mode;\n+};\n+\n+/* Return true if M is a scalar_float_mode.  */\n+\n+inline bool\n+scalar_float_mode::includes_p (machine_mode m)\n+{\n+  return SCALAR_FLOAT_MODE_P (m);\n+}\n+\n /* Return the base GET_MODE_SIZE value for MODE.  */\n \n ALWAYS_INLINE unsigned short\n@@ -547,6 +623,21 @@ struct int_n_data_t {\n extern bool int_n_enabled_p[NUM_INT_N_ENTS];\n extern const int_n_data_t int_n_data[NUM_INT_N_ENTS];\n \n+/* Return true if MODE has class MODE_FLOAT, storing it as a\n+   scalar_float_mode in *FLOAT_MODE if so.  */\n+\n+template<typename T>\n+inline bool\n+is_float_mode (machine_mode mode, T *float_mode)\n+{\n+  if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n+    {\n+      *float_mode = scalar_float_mode (scalar_float_mode::from_int (mode));\n+      return true;\n+    }\n+  return false;\n+}\n+\n namespace mode_iterator\n {\n   /* Start mode iterator *ITER at the first mode in class MCLASS, if any.  */"}, {"sha": "5c9cd34a26e6e32c50ae72306aefa35b9793e0ef", "filename": "gcc/optabs.c", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e386a52f70c47499fff14a338fe17df691e886e2/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e386a52f70c47499fff14a338fe17df691e886e2/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=e386a52f70c47499fff14a338fe17df691e886e2", "patch": "@@ -2552,7 +2552,7 @@ lowpart_subreg_maybe_copy (machine_mode omode, rtx val,\n    logical operation on the sign bit.  */\n \n static rtx\n-expand_absneg_bit (enum rtx_code code, machine_mode mode,\n+expand_absneg_bit (enum rtx_code code, scalar_float_mode mode,\n \t\t   rtx op0, rtx target)\n {\n   const struct real_format *fmt;\n@@ -2698,6 +2698,7 @@ expand_unop (machine_mode mode, optab unoptab, rtx op0, rtx target,\n {\n   enum mode_class mclass = GET_MODE_CLASS (mode);\n   machine_mode wider_mode;\n+  scalar_float_mode float_mode;\n   rtx temp;\n   rtx libfunc;\n \n@@ -2888,9 +2889,9 @@ expand_unop (machine_mode mode, optab unoptab, rtx op0, rtx target,\n   if (optab_to_code (unoptab) == NEG)\n     {\n       /* Try negating floating point values by flipping the sign bit.  */\n-      if (SCALAR_FLOAT_MODE_P (mode))\n+      if (is_a <scalar_float_mode> (mode, &float_mode))\n \t{\n-\t  temp = expand_absneg_bit (NEG, mode, op0, target);\n+\t  temp = expand_absneg_bit (NEG, float_mode, op0, target);\n \t  if (temp)\n \t    return temp;\n \t}\n@@ -3087,9 +3088,10 @@ expand_abs_nojump (machine_mode mode, rtx op0, rtx target,\n     return temp;\n \n   /* For floating point modes, try clearing the sign bit.  */\n-  if (SCALAR_FLOAT_MODE_P (mode))\n+  scalar_float_mode float_mode;\n+  if (is_a <scalar_float_mode> (mode, &float_mode))\n     {\n-      temp = expand_absneg_bit (ABS, mode, op0, target);\n+      temp = expand_absneg_bit (ABS, float_mode, op0, target);\n       if (temp)\n \treturn temp;\n     }\n@@ -3244,7 +3246,7 @@ expand_one_cmpl_abs_nojump (machine_mode mode, rtx op0, rtx target)\n    and not playing with subregs so much, will help the register allocator.  */\n \n static rtx\n-expand_copysign_absneg (machine_mode mode, rtx op0, rtx op1, rtx target,\n+expand_copysign_absneg (scalar_float_mode mode, rtx op0, rtx op1, rtx target,\n \t\t        int bitpos, bool op0_is_abs)\n {\n   machine_mode imode;\n@@ -3328,7 +3330,7 @@ expand_copysign_absneg (machine_mode mode, rtx op0, rtx op1, rtx target,\n    is true if op0 is known to have its sign bit clear.  */\n \n static rtx\n-expand_copysign_bit (machine_mode mode, rtx op0, rtx op1, rtx target,\n+expand_copysign_bit (scalar_float_mode mode, rtx op0, rtx op1, rtx target,\n \t\t     int bitpos, bool op0_is_abs)\n {\n   machine_mode imode;\n@@ -3426,12 +3428,12 @@ expand_copysign_bit (machine_mode mode, rtx op0, rtx op1, rtx target,\n rtx\n expand_copysign (rtx op0, rtx op1, rtx target)\n {\n-  machine_mode mode = GET_MODE (op0);\n+  scalar_float_mode mode;\n   const struct real_format *fmt;\n   bool op0_is_abs;\n   rtx temp;\n \n-  gcc_assert (SCALAR_FLOAT_MODE_P (mode));\n+  mode = as_a <scalar_float_mode> (GET_MODE (op0));\n   gcc_assert (GET_MODE (op1) == mode);\n \n   /* First try to do it with a special instruction.  */"}, {"sha": "95104b066ce8eb23ccc9bdbc5323182fcbbd27cc", "filename": "gcc/real.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e386a52f70c47499fff14a338fe17df691e886e2/gcc%2Freal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e386a52f70c47499fff14a338fe17df691e886e2/gcc%2Freal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.h?ref=e386a52f70c47499fff14a338fe17df691e886e2", "patch": "@@ -183,8 +183,7 @@ extern const struct real_format *\n \t\t\t: (gcc_unreachable (), 0)])\n \n #define FLOAT_MODE_FORMAT(MODE) \\\n-  (REAL_MODE_FORMAT (SCALAR_FLOAT_MODE_P (MODE)? (MODE) \\\n-\t\t\t\t\t       : GET_MODE_INNER (MODE)))\n+  (REAL_MODE_FORMAT (as_a <scalar_float_mode> (GET_MODE_INNER (MODE))))\n \n /* The following macro determines whether the floating point format is\n    composite, i.e. may contain non-consecutive mantissa bits, in which\n@@ -212,7 +211,7 @@ class format_helper\n {\n public:\n   format_helper (const real_format *format) : m_format (format) {}\n-  format_helper (machine_mode m);\n+  template<typename T> format_helper (const T &);\n   const real_format *operator-> () const { return m_format; }\n   operator const real_format *() const { return m_format; }\n \n@@ -222,7 +221,8 @@ class format_helper\n   const real_format *m_format;\n };\n \n-inline format_helper::format_helper (machine_mode m)\n+template<typename T>\n+inline format_helper::format_helper (const T &m)\n   : m_format (m == VOIDmode ? 0 : REAL_MODE_FORMAT (m))\n {}\n "}, {"sha": "60ffdbdb36440c0097eb9a9376c5ab3a80734ddf", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e386a52f70c47499fff14a338fe17df691e886e2/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e386a52f70c47499fff14a338fe17df691e886e2/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=e386a52f70c47499fff14a338fe17df691e886e2", "patch": "@@ -5811,9 +5811,11 @@ simplify_immed_subreg (machine_mode outermode, rtx op,\n \t    {\n \t      /* This is big enough for anything on the platform.  */\n \t      long tmp[MAX_BITSIZE_MODE_ANY_MODE / 32];\n-\t      int bitsize = GET_MODE_BITSIZE (GET_MODE (el));\n+\t      scalar_float_mode el_mode;\n+\n+\t      el_mode = as_a <scalar_float_mode> (GET_MODE (el));\n+\t      int bitsize = GET_MODE_BITSIZE (el_mode);\n \n-\t      gcc_assert (SCALAR_FLOAT_MODE_P (GET_MODE (el)));\n \t      gcc_assert (bitsize <= elem_bitsize);\n \t      gcc_assert (bitsize % value_bit == 0);\n "}]}