{"sha": "b288f2b3393ffdce4b2b9b70203d1804d202c529", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjI4OGYyYjMzOTNmZmRjZTRiMmI5YjcwMjAzZDE4MDRkMjAyYzUyOQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-05-07T16:16:15Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-05-07T16:16:15Z"}, "message": "(sched_analyze_insn, attach_deaths_insn): Look at\nCALL_INSN_FUNCTION_USAGE.\n\nFrom-SVN: r7263", "tree": {"sha": "82b31f1567ae4f71669421b692c56b124f82586e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/82b31f1567ae4f71669421b692c56b124f82586e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b288f2b3393ffdce4b2b9b70203d1804d202c529", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b288f2b3393ffdce4b2b9b70203d1804d202c529", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b288f2b3393ffdce4b2b9b70203d1804d202c529", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b288f2b3393ffdce4b2b9b70203d1804d202c529/comments", "author": null, "committer": null, "parents": [{"sha": "ac8ec8c0c9a31eff3eee3cf8e5cedcb7eee17cca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac8ec8c0c9a31eff3eee3cf8e5cedcb7eee17cca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac8ec8c0c9a31eff3eee3cf8e5cedcb7eee17cca"}], "stats": {"total": 17, "additions": 17, "deletions": 0}, "files": [{"sha": "f31a7ad9b4543343de98e437a3bc81b5ae69f668", "filename": "gcc/sched.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b288f2b3393ffdce4b2b9b70203d1804d202c529/gcc%2Fsched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b288f2b3393ffdce4b2b9b70203d1804d202c529/gcc%2Fsched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched.c?ref=b288f2b3393ffdce4b2b9b70203d1804d202c529", "patch": "@@ -2038,6 +2038,16 @@ sched_analyze_insn (x, insn)\n   else\n     sched_analyze_2 (x, insn);\n \n+  /* Mark registers CLOBBERED or used by called function.  */\n+  if (GET_CODE (insn) == CALL_INSN)\n+    for (link = CALL_INSN_FUNCTION_USAGE (insn); link; link = XEXP (link, 1))\n+      {\n+\tif (GET_CODE (XEXP (link, 0)) == CLOBBER)\n+\t  sched_analyze_1 (XEXP (XEXP (link, 0), 0), insn);\n+\telse\n+\t  sched_analyze_2 (XEXP (XEXP (link, 0), 0), insn);\n+      }\n+\n   /* After reload, it is possible for an instruction to have a REG_DEAD note\n      for a register that actually dies a few instructions earlier.  For\n      example, this can happen with SECONDARY_MEMORY_NEEDED reloads.\n@@ -2906,6 +2916,7 @@ attach_deaths_insn (insn)\n {\n   rtx x = PATTERN (insn);\n   register RTX_CODE code = GET_CODE (x);\n+  rtx link;\n \n   if (code == SET)\n     {\n@@ -2941,6 +2952,12 @@ attach_deaths_insn (insn)\n   /* Otherwise don't add a death note to things being clobbered.  */\n   else if (code != CLOBBER)\n     attach_deaths (x, insn, 0);\n+\n+  /* Make death notes for things used in the called function.  */\n+  if (GET_CODE (insn) == CALL_INSN)\n+    for (link = CALL_INSN_FUNCTION_USAGE (insn); link; link = XEXP (link, 1))\n+      attach_deaths (XEXP (XEXP (link, 0), 0), insn,\n+\t\t     GET_CODE (XEXP (link, 0)) == CLOBBER);\n }\n \n /* Delete notes beginning with INSN and maybe put them in the chain"}]}