{"sha": "c5c60e15bccccf2462a8b6593035399585ebd386", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzVjNjBlMTViY2NjY2YyNDYyYThiNjU5MzAzNTM5OTU4NWViZDM4Ng==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@cygnus.co.uk", "date": "1999-08-23T16:09:52Z"}, "committer": {"name": "Bernd Schmidt", "email": "crux@gcc.gnu.org", "date": "1999-08-23T16:09:52Z"}, "message": "Fix sparc compilation failure\n\nFrom-SVN: r28807", "tree": {"sha": "c7aa79cb5a8ac00d2be7a8f82e08df44d2c5a819", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c7aa79cb5a8ac00d2be7a8f82e08df44d2c5a819"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c5c60e15bccccf2462a8b6593035399585ebd386", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5c60e15bccccf2462a8b6593035399585ebd386", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5c60e15bccccf2462a8b6593035399585ebd386", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5c60e15bccccf2462a8b6593035399585ebd386/comments", "author": null, "committer": null, "parents": [{"sha": "34e456768c9c91b8dd5ee41ddf747b4719bc67db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34e456768c9c91b8dd5ee41ddf747b4719bc67db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34e456768c9c91b8dd5ee41ddf747b4719bc67db"}], "stats": {"total": 141, "additions": 49, "deletions": 92}, "files": [{"sha": "7d0ed0b8b7e8c86db7ceb72c6552d9e1f7d60b08", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c60e15bccccf2462a8b6593035399585ebd386/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c60e15bccccf2462a8b6593035399585ebd386/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c5c60e15bccccf2462a8b6593035399585ebd386", "patch": "@@ -1,3 +1,16 @@\n+Mon Aug 23 16:04:13 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n+\n+\t* optabs.c (prepare_cmp_insn): Turn COMPARISON arg into a pointer.\n+\tAll callers changed.\n+\t(prepare_float_lib_cmp): Likewise.\n+\tUse FLOAT_LIB_COMPARE_RETURNS_BOOL.\n+\t* expr.h (emit_float_lib_cmp): Delete declaration.\n+\t* tm.texi (FLOAT_LIB_COMPARE_RETURNS_BOOL): Document.\n+\t* sparc.h (FLOAT_LIB_COMPARE_RETURNS_BOOL): Define.\n+\t* sparc.md (bcc and scc patterns): Don't handle TFmode comparisons\n+\tspecially.\n+\t(cmptf): Now conditional on TARGET_HARD_QUAD.\n+\n Fri Aug 20 17:52:27 1999  Jim Wilson  <wilson@cygnus.com>\n \n \t* resource.c (mark_target_live_regs): Use"}, {"sha": "82e3727c8c5876cf485bfb4a82ee3130ab930da3", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c60e15bccccf2462a8b6593035399585ebd386/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c60e15bccccf2462a8b6593035399585ebd386/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=c5c60e15bccccf2462a8b6593035399585ebd386", "patch": "@@ -2676,6 +2676,11 @@ do {                                                                    \\\n /* This is meant to be redefined in the host dependent files */\n #define INIT_SUBTARGET_OPTABS\n \n+/* Nonzero if a floating point comparison library call for\n+   mode MODE that will return a boolean value.  Zero if one\n+   of the libgcc2 functions is used.  */\n+#define FLOAT_LIB_COMPARE_RETURNS_BOOL(MODE, COMPARISON) ((MODE) == TFmode)\n+\n /* Compute the cost of computing a constant rtl expression RTX\n    whose rtx-code is CODE.  The body of this macro is a portion\n    of a switch statement.  If the code is computed here,"}, {"sha": "eff6b2939adc46ba897c1fdcef22bc6775837035", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 5, "deletions": 77, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c60e15bccccf2462a8b6593035399585ebd386/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c60e15bccccf2462a8b6593035399585ebd386/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=c5c60e15bccccf2462a8b6593035399585ebd386", "patch": "@@ -606,7 +606,7 @@\n   [(set (reg:CCFP 96)\n \t(compare:CCFP (match_operand:TF 0 \"register_operand\" \"\")\n \t\t      (match_operand:TF 1 \"register_operand\" \"\")))]\n-  \"TARGET_FPU\"\n+  \"TARGET_FPU && TARGET_HARD_QUAD\"\n   \"\n {\n   sparc_compare_op0 = operands[0];\n@@ -834,12 +834,6 @@\n       emit_insn (pat);\n       DONE;\n     }\n-  else if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n-    {\n-      emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, EQ);\n-      emit_insn (gen_sne (operands[0]));\n-      DONE;\n-    }      \n   else if (TARGET_V9)\n     {\n       if (gen_v9_scc (EQ, operands))\n@@ -887,12 +881,6 @@\n       emit_insn (pat);\n       DONE;\n     }\n-  else if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n-    {\n-      emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, NE);\n-      emit_insn (gen_sne (operands[0]));\n-      DONE;\n-    }      \n   else if (TARGET_V9)\n     {\n       if (gen_v9_scc (NE, operands))\n@@ -908,13 +896,7 @@\n   \"! TARGET_LIVE_G0\"\n   \"\n {\n-  if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n-    {\n-      emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, GT);\n-      emit_insn (gen_sne (operands[0]));\n-      DONE;\n-    }\n-  else if (TARGET_V9)\n+  if (TARGET_V9)\n     {\n       if (gen_v9_scc (GT, operands))\n \tDONE;\n@@ -929,13 +911,7 @@\n   \"! TARGET_LIVE_G0\"\n   \"\n {\n-  if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n-    {\n-      emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, LT);\n-      emit_insn (gen_sne (operands[0]));\n-      DONE;\n-    }\n-  else if (TARGET_V9)\n+  if (TARGET_V9)\n     {\n       if (gen_v9_scc (LT, operands))\n \tDONE;\n@@ -950,13 +926,7 @@\n   \"! TARGET_LIVE_G0\"\n   \"\n {\n-  if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n-    {\n-      emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, GE);\n-      emit_insn (gen_sne (operands[0]));\n-      DONE;\n-    }\n-  else if (TARGET_V9)\n+  if (TARGET_V9)\n     {\n       if (gen_v9_scc (GE, operands))\n \tDONE;\n@@ -971,13 +941,7 @@\n   \"! TARGET_LIVE_G0\"\n   \"\n {\n-  if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n-    {\n-      emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, LE);\n-      emit_insn (gen_sne (operands[0]));\n-      DONE;\n-    }\n-  else if (TARGET_V9)\n+  if (TARGET_V9)\n     {\n       if (gen_v9_scc (LE, operands))\n \tDONE;\n@@ -1605,12 +1569,6 @@\n       emit_v9_brxx_insn (EQ, sparc_compare_op0, operands[0]);\n       DONE;\n     }\n-  else if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n-    {\n-      emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, EQ);\n-      emit_jump_insn (gen_bne (operands[0]));\n-      DONE;\n-    }      \n   operands[1] = gen_compare_reg (EQ, sparc_compare_op0, sparc_compare_op1);\n }\")\n \n@@ -1629,12 +1587,6 @@\n       emit_v9_brxx_insn (NE, sparc_compare_op0, operands[0]);\n       DONE;\n     }\n-  else if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n-    {\n-      emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, NE);\n-      emit_jump_insn (gen_bne (operands[0]));\n-      DONE;\n-    }      \n   operands[1] = gen_compare_reg (NE, sparc_compare_op0, sparc_compare_op1);\n }\")\n \n@@ -1653,12 +1605,6 @@\n       emit_v9_brxx_insn (GT, sparc_compare_op0, operands[0]);\n       DONE;\n     }\n-  else if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n-    {\n-      emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, GT);\n-      emit_jump_insn (gen_bne (operands[0]));\n-      DONE;\n-    }      \n   operands[1] = gen_compare_reg (GT, sparc_compare_op0, sparc_compare_op1);\n }\")\n \n@@ -1687,12 +1633,6 @@\n       emit_v9_brxx_insn (LT, sparc_compare_op0, operands[0]);\n       DONE;\n     }\n-  else if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n-    {\n-      emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, LT);\n-      emit_jump_insn (gen_bne (operands[0]));\n-      DONE;\n-    }      \n   operands[1] = gen_compare_reg (LT, sparc_compare_op0, sparc_compare_op1);\n }\")\n \n@@ -1721,12 +1661,6 @@\n       emit_v9_brxx_insn (GE, sparc_compare_op0, operands[0]);\n       DONE;\n     }\n-  else if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n-    {\n-      emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, GE);\n-      emit_jump_insn (gen_bne (operands[0]));\n-      DONE;\n-    }      \n   operands[1] = gen_compare_reg (GE, sparc_compare_op0, sparc_compare_op1);\n }\")\n \n@@ -1755,12 +1689,6 @@\n       emit_v9_brxx_insn (LE, sparc_compare_op0, operands[0]);\n       DONE;\n     }\n-  else if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n-    {\n-      emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, LE);\n-      emit_jump_insn (gen_bne (operands[0]));\n-      DONE;\n-    }      \n   operands[1] = gen_compare_reg (LE, sparc_compare_op0, sparc_compare_op1);\n }\")\n "}, {"sha": "54eb3274b041d4b3d7f24c29a6c16528d8811223", "filename": "gcc/expr.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c60e15bccccf2462a8b6593035399585ebd386/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c60e15bccccf2462a8b6593035399585ebd386/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=c5c60e15bccccf2462a8b6593035399585ebd386", "patch": "@@ -567,10 +567,6 @@ extern void emit_cmp_and_jump_insns PROTO((rtx, rtx, enum rtx_code, rtx,\n    (without splitting it into pieces).  */\n extern int can_compare_p PROTO((enum machine_mode));\n \n-/* Emit a library call comparison between floating point X and Y.\n-   COMPARISON is the rtl operator to compare with (EQ, NE, GT, etc.).  */\n-extern void emit_float_lib_cmp PROTO((rtx, rtx, enum rtx_code));\n-\n /* Generate code to indirectly jump to a location given in the rtx LOC.  */\n extern void emit_indirect_jump PROTO((rtx));\n "}, {"sha": "dc742627a77e41639ac9315e1de6c26a03e5f2d4", "filename": "gcc/optabs.c", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c60e15bccccf2462a8b6593035399585ebd386/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c60e15bccccf2462a8b6593035399585ebd386/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=c5c60e15bccccf2462a8b6593035399585ebd386", "patch": "@@ -270,11 +270,11 @@ static void init_traps PROTO((void));\n static int cmp_available_p PROTO((enum machine_mode, enum rtx_code, int));\n static void emit_cmp_and_jump_insn_1 PROTO((rtx, rtx, enum machine_mode,\n \t\t\t\t\t    enum rtx_code, int, rtx));\n-static void prepare_cmp_insn PROTO((rtx *, rtx *, enum rtx_code, rtx,\n+static void prepare_cmp_insn PROTO((rtx *, rtx *, enum rtx_code *, rtx,\n \t\t\t\t    enum machine_mode *, int *, int));\n static rtx prepare_operand PROTO((int, rtx, int, enum machine_mode,\n \t\t\t\t  enum machine_mode, int));\n-static void prepare_float_lib_cmp PROTO((rtx *, rtx *, enum rtx_code,\n+static void prepare_float_lib_cmp PROTO((rtx *, rtx *, enum rtx_code *,\n \t\t\t\t\t enum machine_mode *, int *));\n \f\n /* Add a REG_EQUAL note to the last insn in SEQ.  TARGET is being set to\n@@ -3019,15 +3019,16 @@ cmp_available_p (mode, code, can_use_tst_p)\n    The values which are passed in through pointers can be modified; the caller\n    should perform the comparison on the modified values.  */\n \n-void\n-prepare_cmp_insn (px, py, comparison, size, pmode, punsignedp, align)\n+static void\n+prepare_cmp_insn (px, py, pcomparison, size, pmode, punsignedp, align)\n      rtx *px, *py;\n-     enum rtx_code comparison;\n+     enum rtx_code *pcomparison;\n      rtx size;\n      enum machine_mode *pmode;\n      int *punsignedp;\n      int align;\n {\n+  enum rtx_code comparison = *pcomparison;\n   enum machine_mode mode = *pmode;\n   rtx x = *px, y = *py;\n   int unsignedp = *punsignedp;\n@@ -3181,7 +3182,7 @@ prepare_cmp_insn (px, py, comparison, size, pmode, punsignedp, align)\n     }\n \n   if (class == MODE_FLOAT)\n-    prepare_float_lib_cmp (px, py, comparison, pmode, punsignedp);\n+    prepare_float_lib_cmp (px, py, pcomparison, pmode, punsignedp);\n \n   else\n     abort ();\n@@ -3322,7 +3323,7 @@ emit_cmp_and_jump_insns (x, y, comparison, size, mode, unsignedp, align, label)\n   emit_queue ();\n   if (unsignedp)\n     comparison = unsigned_condition (comparison);\n-  prepare_cmp_insn (&op0, &op1, comparison, size, &mode, &unsignedp, align);\n+  prepare_cmp_insn (&op0, &op1, &comparison, size, &mode, &unsignedp, align);\n   emit_cmp_and_jump_insn_1 (op0, op1, mode, comparison, unsignedp, label);\n }\n \n@@ -3360,13 +3361,14 @@ can_compare_p (mode)\n /* Emit a library call comparison between floating point X and Y.\n    COMPARISON is the rtl operator to compare with (EQ, NE, GT, etc.).  */\n \n-void\n-prepare_float_lib_cmp (px, py, comparison, pmode, punsignedp)\n+static void\n+prepare_float_lib_cmp (px, py, pcomparison, pmode, punsignedp)\n      rtx *px, *py;\n-     enum rtx_code comparison;\n+     enum rtx_code *pcomparison;\n      enum machine_mode *pmode;\n      int *punsignedp;\n {\n+  enum rtx_code comparison = *pcomparison;\n   rtx x = *px, y = *py;\n   enum machine_mode mode = GET_MODE (x);\n   rtx libfunc = 0;\n@@ -3537,7 +3539,7 @@ prepare_float_lib_cmp (px, py, comparison, pmode, punsignedp)\n \t      y = protect_from_queue (y, 0);\n \t      *px = convert_to_mode (wider_mode, x, 0);\n \t      *py = convert_to_mode (wider_mode, y, 0);\n-\t      prepare_float_lib_cmp (px, py, comparison, pmode, punsignedp);\n+\t      prepare_float_lib_cmp (px, py, pcomparison, pmode, punsignedp);\n \t      return;\n \t    }\n \t}\n@@ -3558,6 +3560,10 @@ prepare_float_lib_cmp (px, py, comparison, pmode, punsignedp)\n   *px = result;\n   *py = const0_rtx;\n   *pmode = word_mode;\n+#ifdef FLOAT_LIB_COMPARE_RETURNS_BOOL\n+  if (FLOAT_LIB_COMPARE_RETURNS_BOOL (mode, comparison))\n+    *pcomparison = NE;\n+#endif\n   *punsignedp = 0;\n }\n \f"}, {"sha": "70dc6d0d3180507c7d036190ccaacf46f2aaac6a", "filename": "gcc/tm.texi", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c60e15bccccf2462a8b6593035399585ebd386/gcc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c60e15bccccf2462a8b6593035399585ebd386/gcc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftm.texi?ref=c5c60e15bccccf2462a8b6593035399585ebd386", "patch": "@@ -4046,6 +4046,15 @@ Define this macro as a C statement that declares additional library\n routines renames existing ones. @code{init_optabs} calls this macro after\n initializing all the normal library routines.\n \n+@findex FLOAT_LIB_COMPARE_RETURNS_BOOL (@var{mode}, @var{comparison})\n+@item FLOAT_LIB_COMPARE_RETURNS_BOOL\n+Define this macro as a C statement that returns nonzero if a call to\n+the floating point comparison library function will return a boolean\n+value that indicates the result of the comparison.  It should return\n+zero if one of gcc's own libgcc functions is called.\n+\n+Most ports don't need to define this macro.\n+\n @findex TARGET_EDOM\n @cindex @code{EDOM}, implicit usage\n @item TARGET_EDOM"}]}