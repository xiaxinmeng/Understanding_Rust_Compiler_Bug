{"sha": "3ac7348b6613e97c09c3dc1a6e103a6679beee6f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2FjNzM0OGI2NjEzZTk3YzA5YzNkYzFhNmUxMDNhNjY3OWJlZWU2Zg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-07-11T22:52:46Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-07-11T22:52:46Z"}, "message": "(output_move_double): Fix typos in Jun 28 change.\n\nOnly set highest_first if first reg\nof dest overlaps memory src address.  Otherwise, if addreg1 set and\nis same as second reg of dest, suppress trailing decrement.\n\nFrom-SVN: r4907", "tree": {"sha": "583607ecb889ed3f856a34dbb546e3e865069d20", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/583607ecb889ed3f856a34dbb546e3e865069d20"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ac7348b6613e97c09c3dc1a6e103a6679beee6f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ac7348b6613e97c09c3dc1a6e103a6679beee6f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ac7348b6613e97c09c3dc1a6e103a6679beee6f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ac7348b6613e97c09c3dc1a6e103a6679beee6f/comments", "author": null, "committer": null, "parents": [{"sha": "4bbbc5d906d1363fa6ca5fdf587c579120756a71", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bbbc5d906d1363fa6ca5fdf587c579120756a71", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4bbbc5d906d1363fa6ca5fdf587c579120756a71"}], "stats": {"total": 32, "additions": 22, "deletions": 10}, "files": [{"sha": "7201f059d1ac605a55ce1e9209a162d5b2ec6466", "filename": "gcc/config/i860/i860.c", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ac7348b6613e97c09c3dc1a6e103a6679beee6f/gcc%2Fconfig%2Fi860%2Fi860.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ac7348b6613e97c09c3dc1a6e103a6679beee6f/gcc%2Fconfig%2Fi860%2Fi860.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fi860.c?ref=3ac7348b6613e97c09c3dc1a6e103a6679beee6f", "patch": "@@ -573,6 +573,7 @@ output_move_double (operands)\n   rtx latehalf[2];\n   rtx addreg0 = 0, addreg1 = 0;\n   int highest_first = 0;\n+  int no_addreg1_decrement = 0;\n \n   /* First classify both operands.  */\n \n@@ -681,22 +682,33 @@ output_move_double (operands)\n   else if (optype0 == REGOP && optype1 != REGOP\n \t   && reg_overlap_mentioned_p (operands[0], operands[1]))\n     {\n-      if (reg_mentioned_p (op0, XEXP (op1, 0))\n-\t  && reg_mentioned_p (latehalf[0], XEXP (op1, 0)))\n+      /* If both halves of dest are used in the src memory address,\n+\t add the two regs and put them in the low reg (operands[0]).\n+\t Then it works to load latehalf first.  */\n+      if (reg_mentioned_p (operands[0], XEXP (operands[1], 0))\n+\t  && reg_mentioned_p (latehalf[0], XEXP (operands[1], 0)))\n \t{\n-\t  /* If both halves of dest are used in the src memory address,\n-\t     add the two regs and put them in the low reg (op0).\n-\t     Then it works to load latehalf first.  */\n \t  rtx xops[2];\n \t  xops[0] = latehalf[0];\n-\t  xops[1] = op0;\n+\t  xops[1] = operands[0];\n \t  output_asm_insn (\"adds %1,%0,%1\", xops);\n-\t  operands[1] = gen_rtx (MEM, DImode, op0);\n+\t  operands[1] = gen_rtx (MEM, DImode, operands[0]);\n \t  latehalf[1] = adj_offsettable_operand (operands[1], 4);\n \t  addreg1 = 0;\n+\t  highest_first = 1;\n \t}\n-      /* Do the late half first.  */\n-      highest_first = 1;\n+      /* Only one register in the dest is used in the src memory address,\n+\t and this is the first register of the dest, so we want to do\n+\t the late half first here also.  */\n+      else if (! reg_mentioned_p (latehalf[0], XEXP (operands[1], 0)))\n+\thighest_first = 1;\n+      /* Only one register in the dest is used in the src memory address,\n+\t and this is the second register of the dest, so we want to do\n+\t the late half last.  If addreg1 is set, and addreg1 is the same\n+\t register as latehalf, then we must suppress the trailing decrement,\n+\t because it would clobber the value just loaded.  */\n+      else if (addreg1 && reg_mentioned_p (addreg1, latehalf[0]))\n+\tno_addreg1_decrement = 1;\n     }\n \n   /* Normal case: do the two words, low-numbered first.\n@@ -718,7 +730,7 @@ output_move_double (operands)\n   /* Undo the adds we just did.  */\n   if (addreg0)\n     output_asm_insn (\"adds -0x4,%0,%0\", &addreg0);\n-  if (addreg1)\n+  if (addreg1 && !no_addreg1_decrement)\n     output_asm_insn (\"adds -0x4,%0,%0\", &addreg1);\n \n   if (highest_first)"}]}