{"sha": "6b24c25948265c30431460146bc6f43ee9a34c23", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmIyNGMyNTk0ODI2NWMzMDQzMTQ2MDE0NmJjNmY0M2VlOWEzNGMyMw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-07-22T21:42:35Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-07-22T21:42:35Z"}, "message": "basic-block.h (redirect_edge_and_branch_force, [...]): Declare.\n\n\t* basic-block.h (redirect_edge_and_branch_force,\n\tredirect_edge_and_branch, block_label, forwarder_block_p): Declare.\n\t* flow.c (redirect_edge_and_branch_force,\n\tredirect_edge_and_branch, block_label, forwarder_block_p): Make global.\n\t(redirect_edge_and_branch_force): Fix copying of lifeness information.\n\t(block_label): Handle EXIT_BLOCK_PTR by returning NULL.\n\t* ifcvt.c (dead_or_predictable): Take BB as an new destionation\n\tinstead of label; update CFG after transformation.\n\t(find_if_case_1): Update call, use redirect_edge_and_branch_force\n\tfor finishing the transformation; handle even case where ELSE\n\tdoes not follow THEN.\n\t(find_if_case_2): Update call of dead_or_predictable; simplify\n\tCFG update.\n\n\t* emit-rtl.c (split_branch_probability): New global variable.\n\t(try_split): Take care to set split_branch_probability and\n\tcreate REG_BR_PROB note for new jump insns.\n\t* md.texi (define_split): Document new feature.\n\n\t* i386.c (ix86_split_fp_branch): Redistribute branch probability notes.\n\nFrom-SVN: r44249", "tree": {"sha": "27b2cf8174b04c2db114b181f4e7c30ca578775e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/27b2cf8174b04c2db114b181f4e7c30ca578775e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6b24c25948265c30431460146bc6f43ee9a34c23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b24c25948265c30431460146bc6f43ee9a34c23", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b24c25948265c30431460146bc6f43ee9a34c23", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b24c25948265c30431460146bc6f43ee9a34c23/comments", "author": null, "committer": null, "parents": [{"sha": "544f03b403827808cb0ee9e061979f891b777f3b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/544f03b403827808cb0ee9e061979f891b777f3b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/544f03b403827808cb0ee9e061979f891b777f3b"}], "stats": {"total": 265, "additions": 178, "deletions": 87}, "files": [{"sha": "989808499310ed39094c26bbc82ec277f420fc49", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b24c25948265c30431460146bc6f43ee9a34c23/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b24c25948265c30431460146bc6f43ee9a34c23/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6b24c25948265c30431460146bc6f43ee9a34c23", "patch": "@@ -1,3 +1,26 @@\n+Sun Jul 22 23:28:56 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* basic-block.h (redirect_edge_and_branch_force,\n+\tredirect_edge_and_branch, block_label, forwarder_block_p): Declare.\n+\t* flow.c (redirect_edge_and_branch_force,\n+\tredirect_edge_and_branch, block_label, forwarder_block_p): Make global.\n+\t(redirect_edge_and_branch_force): Fix copying of lifeness information.\n+\t(block_label): Handle EXIT_BLOCK_PTR by returning NULL.\n+\t* ifcvt.c (dead_or_predictable): Take BB as an new destionation\n+\tinstead of label; update CFG after transformation.\n+\t(find_if_case_1): Update call, use redirect_edge_and_branch_force\n+\tfor finishing the transformation; handle even case where ELSE\n+\tdoes not follow THEN.\n+\t(find_if_case_2): Update call of dead_or_predictable; simplify\n+\tCFG update.\n+\n+\t* emit-rtl.c (split_branch_probability): New global variable.\n+\t(try_split): Take care to set split_branch_probability and\n+\tcreate REG_BR_PROB note for new jump insns.\n+\t* md.texi (define_split): Document new feature.\n+\n+\t* i386.c (ix86_split_fp_branch): Redistribute branch probability notes.\n+\n 2001-07-22  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n \t* varasm.c: Don't inlcude dbxout.h, sdbout.h or xcoffout.h."}, {"sha": "6a6039eff044aa9767c39bfe3d3a08ffa3cf0bc1", "filename": "gcc/basic-block.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b24c25948265c30431460146bc6f43ee9a34c23/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b24c25948265c30431460146bc6f43ee9a34c23/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=6b24c25948265c30431460146bc6f43ee9a34c23", "patch": "@@ -597,6 +597,11 @@ extern void debug_regset\t\tPARAMS ((regset));\n extern void allocate_reg_life_data      PARAMS ((void));\n extern void allocate_bb_life_data\tPARAMS ((void));\n extern void find_unreachable_blocks\tPARAMS ((void));\n+extern basic_block redirect_edge_and_branch_force PARAMS ((edge, basic_block));\n+extern bool redirect_edge_and_branch\tPARAMS ((edge, basic_block));\n+extern rtx block_label\t\t\tPARAMS ((basic_block));\n+extern bool forwarder_block_p\t\tPARAMS ((basic_block));\n+\n \n /* This function is always defined so it can be called from the\n    debugger, and it is declared extern so we don't get warnings about"}, {"sha": "821daa696f26964ae7985a6a0a8197b810bbdf70", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 49, "deletions": 23, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b24c25948265c30431460146bc6f43ee9a34c23/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b24c25948265c30431460146bc6f43ee9a34c23/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=6b24c25948265c30431460146bc6f43ee9a34c23", "patch": "@@ -6267,6 +6267,8 @@ ix86_split_fp_branch (code, op1, op2, target1, target2, tmp)\n   rtx second, bypass;\n   rtx label = NULL_RTX;\n   rtx condition;\n+  int bypass_probability = -1, second_probability = -1, probability = -1;\n+  rtx i;\n \n   if (target2 != pc_rtx)\n     {\n@@ -6278,35 +6280,59 @@ ix86_split_fp_branch (code, op1, op2, target1, target2, tmp)\n \n   condition = ix86_expand_fp_compare (code, op1, op2,\n \t\t\t\t      tmp, &second, &bypass);\n+\n+  if (split_branch_probability >= 0)\n+    {\n+      /* Distribute the probabilities across the jumps.\n+\t Assume the BYPASS and SECOND to be always test\n+\t for UNORDERED.  */\n+      probability = split_branch_probability;\n+\n+      /* Value of 1 is low enought to make no need for probability\n+\t to be updated.  Later we may run some experiments and see\n+\t if unordered values are more frequent in practice.  */\n+      if (bypass)\n+\tbypass_probability = 1;\n+      if (second)\n+\tsecond_probability = 1;\n+    }\n   if (bypass != NULL_RTX)\n     {\n       label = gen_label_rtx ();\n-      emit_jump_insn (gen_rtx_SET\n+      i = emit_jump_insn (gen_rtx_SET\n+\t\t\t  (VOIDmode, pc_rtx,\n+\t\t\t   gen_rtx_IF_THEN_ELSE (VOIDmode,\n+\t\t\t\t\t\t bypass,\n+\t\t\t\t\t\t gen_rtx_LABEL_REF (VOIDmode,\n+\t\t\t\t\t\t\t\t    label),\n+\t\t\t\t\t\t pc_rtx)));\n+      if (bypass_probability >= 0)\n+\tREG_NOTES (i)\n+\t  = gen_rtx_EXPR_LIST (REG_BR_PROB,\n+\t\t\t       GEN_INT (bypass_probability),\n+\t\t\t       REG_NOTES (i));\n+    }\n+  i = emit_jump_insn (gen_rtx_SET\n \t\t      (VOIDmode, pc_rtx,\n \t\t       gen_rtx_IF_THEN_ELSE (VOIDmode,\n-\t\t\t\t\t     bypass,\n-\t\t\t\t\t     gen_rtx_LABEL_REF (VOIDmode,\n-\t\t\t\t\t\t\t\tlabel),\n-\t\t\t\t\t     pc_rtx)));\n-    }\n-  /* AMD Athlon and probably other CPUs too have fast bypass path between the\n-     comparison and first branch.  The second branch takes longer to execute\n-     so place first branch the worse predicable one if possible.  */\n-  if (second != NULL_RTX\n-      && (GET_CODE (second) == UNORDERED || GET_CODE (second) == ORDERED))\n-    {\n-      rtx tmp = condition;\n-      condition = second;\n-      second = tmp;\n-    }\n-  emit_jump_insn (gen_rtx_SET\n-\t\t  (VOIDmode, pc_rtx,\n-\t\t   gen_rtx_IF_THEN_ELSE (VOIDmode,\n-\t\t\t\t\t condition, target1, target2)));\n+\t\t\t\t\t     condition, target1, target2)));\n+  if (probability >= 0)\n+    REG_NOTES (i)\n+      = gen_rtx_EXPR_LIST (REG_BR_PROB,\n+\t\t\t   GEN_INT (probability),\n+\t\t\t   REG_NOTES (i));\n   if (second != NULL_RTX)\n-    emit_jump_insn (gen_rtx_SET\n-\t\t    (VOIDmode, pc_rtx,\n-\t\t     gen_rtx_IF_THEN_ELSE (VOIDmode, second, target1, target2)));\n+    {\n+      i = emit_jump_insn (gen_rtx_SET\n+\t\t\t  (VOIDmode, pc_rtx,\n+\t\t\t   gen_rtx_IF_THEN_ELSE (VOIDmode, second, target1,\n+\t\t\t\t\t\t target2)));\n+      if (second_probability >= 0)\n+\tREG_NOTES (i)\n+\t  = gen_rtx_EXPR_LIST (REG_BR_PROB,\n+\t\t\t       GEN_INT (second_probability),\n+\t\t\t       REG_NOTES (i));\n+    }\n   if (label != NULL_RTX)\n     emit_label (label);\n }"}, {"sha": "0a79f3471fffa56173cde9dece998d24a9468828", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b24c25948265c30431460146bc6f43ee9a34c23/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b24c25948265c30431460146bc6f43ee9a34c23/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=6b24c25948265c30431460146bc6f43ee9a34c23", "patch": "@@ -3805,6 +3805,22 @@ insns that don't.  Instead, write two separate @code{define_split}\n definitions, one for the insns that are valid and one for the insns that\n are not valid.\n \n+The splitter is allowed to split jump instructions into sequence of\n+jumps or create new jumps in while splitting non-jump instructions.  As\n+the central flowgraph and branch prediction information needs to be updated,\n+several restriction apply. \n+\n+Splitting of jump instruction into sequence that over by another jump\n+instruction is always valid, as compiler expect identical behaviour of new\n+jump.  When new sequence contains multiple jump instructions or new labels,\n+more assistance is needed.  Splitter is required to create only unconditional\n+jumps, or simple conditional jump instructions.  Additionally it must attach a\n+@code{REG_BR_PROB} note to each conditional jump. An global variable\n+@code{split_branch_probability} hold the probability of original branch in case\n+it was an simple conditional jump, @minus{}1 otherwise.  To simplify\n+recomputing of edge frequencies, new sequence is required to have only\n+forward jumps to the newly created labels.\n+\n For the common case where the pattern of a define_split exactly matches the\n pattern of a define_insn, use @code{define_insn_and_split}.  It looks like\n this:"}, {"sha": "5c021772a347d5d6b8cc231da35eb01883cc6f47", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 39, "deletions": 7, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b24c25948265c30431460146bc6f43ee9a34c23/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b24c25948265c30431460146bc6f43ee9a34c23/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=6b24c25948265c30431460146bc6f43ee9a34c23", "patch": "@@ -185,6 +185,10 @@ static int const_int_htab_eq            PARAMS ((const void *,\n static int rtx_htab_mark_1              PARAMS ((void **, void *));\n static void rtx_htab_mark               PARAMS ((void *));\n \n+/* Probability of the conditional branch currently proceeded by try_split.\n+   Set to -1 otherwise.  */\n+int split_branch_probability = -1;\n+\n \f\n /* Returns a hash code for X (which is a really a CONST_INT).  */\n \n@@ -2486,9 +2490,19 @@ try_split (pat, trial, last)\n {\n   rtx before = PREV_INSN (trial);\n   rtx after = NEXT_INSN (trial);\n-  rtx seq = split_insns (pat, trial);\n   int has_barrier = 0;\n   rtx tem;\n+  rtx note, seq;\n+  int probability;\n+\n+  if (any_condjump_p (trial)\n+      && (note = find_reg_note (trial, REG_BR_PROB, 0)))\n+    split_branch_probability = INTVAL (XEXP (note, 0));\n+  probability = split_branch_probability;\n+\n+  seq = split_insns (pat, trial);\n+\n+  split_branch_probability = -1;\n \n   /* If we are splitting a JUMP_INSN, it might be followed by a BARRIER.\n      We may need to handle this specially.  */\n@@ -2505,7 +2519,7 @@ try_split (pat, trial, last)\n \t it, in turn, will be split (SFmode on the 29k is an example).  */\n       if (GET_CODE (seq) == SEQUENCE)\n \t{\n-\t  int i;\n+\t  int i, njumps = 0;\n \t  rtx eh_note;\n \n \t  /* Avoid infinite loop if any insn of the result matches\n@@ -2518,9 +2532,27 @@ try_split (pat, trial, last)\n \t  /* Mark labels.  */\n \t  for (i = XVECLEN (seq, 0) - 1; i >= 0; i--)\n \t    if (GET_CODE (XVECEXP (seq, 0, i)) == JUMP_INSN)\n-\t      mark_jump_label (PATTERN (XVECEXP (seq, 0, i)),\n-\t\t\t       XVECEXP (seq, 0, i), 0);\n-\n+\t      {\n+\t\trtx insn = XVECEXP (seq, 0, i);\n+\t\tmark_jump_label (PATTERN (insn),\n+\t\t\t\t XVECEXP (seq, 0, i), 0);\n+\t\tnjumps++;\n+\t\tif (probability != -1\n+\t\t    && any_condjump_p (insn)\n+\t\t    && !find_reg_note (insn, REG_BR_PROB, 0))\n+\t\t  {\n+\t\t    /* We can preserve the REG_BR_PROB notes only if exactly\n+\t\t       one jump is created, otherwise the machinde description\n+\t\t       is responsible for this step using\n+\t\t       split_branch_probability variable.  */\n+\t\t    if (njumps != 1)\n+\t\t      abort ();\n+\t\t    REG_NOTES (insn)\n+\t\t      = gen_rtx_EXPR_LIST (REG_BR_PROB,\n+\t\t\t\t\t   GEN_INT (probability),\n+\t\t\t\t\t   REG_NOTES (insn));\n+\t\t  }\n+\t      }\n \t  /* If we are splitting a CALL_INSN, look for the CALL_INSN\n \t     in SEQ and copy our CALL_INSN_FUNCTION_USAGE to it.  */\n \t  if (GET_CODE (trial) == CALL_INSN)\n@@ -2577,8 +2609,8 @@ try_split (pat, trial, last)\n       /* Return either the first or the last insn, depending on which was\n \t requested.  */\n       return last\n-\t\t? (after ? prev_active_insn (after) : last_insn)\n-\t\t: next_active_insn (before);\n+\t\t? (after ? PREV_INSN (after) : last_insn)\n+\t\t: NEXT_INSN (before);\n     }\n \n   return trial;"}, {"sha": "a6a63e5a3ae45d390635bb603839c2ac039d303a", "filename": "gcc/flow.c", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b24c25948265c30431460146bc6f43ee9a34c23/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b24c25948265c30431460146bc6f43ee9a34c23/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=6b24c25948265c30431460146bc6f43ee9a34c23", "patch": "@@ -393,7 +393,6 @@ static int merge_blocks_move_successor_nojumps PARAMS ((basic_block,\n static int merge_blocks\t\t\tPARAMS ((edge,basic_block,basic_block,\n \t\t\t\t\t\t int));\n static bool try_optimize_cfg\t\tPARAMS ((int));\n-static bool forwarder_block_p\t\tPARAMS ((basic_block));\n static bool can_fallthru\t\tPARAMS ((basic_block, basic_block));\n static bool try_redirect_by_replacing_jump PARAMS ((edge, basic_block));\n static bool try_simplify_condjump\tPARAMS ((basic_block));\n@@ -485,9 +484,6 @@ static void flow_loops_tree_build\tPARAMS ((struct loops *));\n static int flow_loop_level_compute\tPARAMS ((struct loop *, int));\n static int flow_loops_level_compute\tPARAMS ((struct loops *));\n static void find_sub_basic_blocks\tPARAMS ((basic_block));\n-static bool redirect_edge_and_branch \tPARAMS ((edge, basic_block));\n-static basic_block redirect_edge_and_branch_force PARAMS ((edge, basic_block));\n-static rtx block_label\t\t\tPARAMS ((basic_block));\n \f\n /* Find basic blocks of the current function.\n    F is the first insn of the function and NREGS the number of register\n@@ -1598,18 +1594,20 @@ split_block (bb, insn)\n }\n \n /* Return label in the head of basic block.  Create one if it doesn't exist.  */\n-static rtx\n+rtx\n block_label (block)\n      basic_block block;\n {\n+  if (block == EXIT_BLOCK_PTR)\n+    return NULL_RTX;\n   if (GET_CODE (block->head) != CODE_LABEL)\n     block->head = emit_label_before (gen_label_rtx (), block->head);\n   return block->head;\n }\n \n /* Return true if the block has no effect and only forwards control flow to\n    its single destination.  */\n-static bool\n+bool\n forwarder_block_p (bb)\n      basic_block bb;\n {\n@@ -1759,7 +1757,7 @@ try_redirect_by_replacing_jump (e, target)\n    Return true if transformation suceeded.  We still return flase in case\n    E already destinated TARGET and we didn't managed to simplify instruction\n    stream.  */\n-static bool\n+bool\n redirect_edge_and_branch (e, target)\n      edge e;\n      basic_block target;\n@@ -1867,7 +1865,7 @@ redirect_edge_and_branch (e, target)\n /* Redirect edge even at the expense of creating new jump insn or\n    basic block.  Return new basic block if created, NULL otherwise.\n    Abort if converison is impossible.  */\n-static basic_block\n+basic_block\n redirect_edge_and_branch_force (e, target)\n      edge e;\n      basic_block target;\n@@ -1937,7 +1935,7 @@ redirect_edge_and_branch_force (e, target)\n       new_bb->global_live_at_start = OBSTACK_ALLOC_REG_SET (&flow_obstack);\n       new_bb->global_live_at_end = OBSTACK_ALLOC_REG_SET (&flow_obstack);\n       COPY_REG_SET (new_bb->global_live_at_start,\n-\t\t    e->dest->global_live_at_start);\n+\t\t    target->global_live_at_start);\n       COPY_REG_SET (new_bb->global_live_at_end, new_bb->global_live_at_start);\n     }\n "}, {"sha": "08ec087e4ca562a235c779d22d3b6deb00388042", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 38, "deletions": 48, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b24c25948265c30431460146bc6f43ee9a34c23/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b24c25948265c30431460146bc6f43ee9a34c23/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=6b24c25948265c30431460146bc6f43ee9a34c23", "patch": "@@ -106,7 +106,7 @@ static int find_if_case_2\t\tPARAMS ((basic_block, edge, edge));\n static int find_cond_trap\t\tPARAMS ((basic_block, edge, edge));\n static int find_memory\t\t\tPARAMS ((rtx *, void *));\n static int dead_or_predicable\t\tPARAMS ((basic_block, basic_block,\n-\t\t\t\t\t\t basic_block, rtx, int));\n+\t\t\t\t\t\t basic_block, basic_block, int));\n static void noce_emit_move_insn\t\tPARAMS ((rtx, rtx));\n \f\n /* Abuse the basic_block AUX field to store the original block index,\n@@ -2183,9 +2183,8 @@ find_if_case_1 (test_bb, then_edge, else_edge)\n       edge then_edge, else_edge;\n {\n   basic_block then_bb = then_edge->dest;\n-  basic_block else_bb = else_edge->dest;\n+  basic_block else_bb = else_edge->dest, new_bb;\n   edge then_succ = then_bb->succ;\n-  rtx new_lab;\n \n   /* THEN has one successor.  */\n   if (!then_succ || then_succ->succ_next != NULL)\n@@ -2199,8 +2198,8 @@ find_if_case_1 (test_bb, then_edge, else_edge)\n   if (then_bb->pred->pred_next != NULL)\n     return FALSE;\n \n-  /* ELSE follows THEN.  (??? could be moved)  */\n-  if (else_bb->index != then_bb->index + 1)\n+  /* THEN must do something.  */\n+  if (forwarder_block_p (then_bb))\n     return FALSE;\n \n   num_possible_if_blocks++;\n@@ -2213,18 +2212,9 @@ find_if_case_1 (test_bb, then_edge, else_edge)\n   if (count_bb_insns (then_bb) > BRANCH_COST)\n     return FALSE;\n \n-  /* Find the label for THEN's destination.  */\n-  if (then_succ->dest == EXIT_BLOCK_PTR)\n-    new_lab = NULL_RTX;\n-  else\n-    {\n-      new_lab = JUMP_LABEL (then_bb->end);\n-      if (! new_lab)\n-\tabort ();\n-    }\n-\n   /* Registers set are dead, or are predicable.  */\n-  if (! dead_or_predicable (test_bb, then_bb, else_bb, new_lab, 1))\n+  if (! dead_or_predicable (test_bb, then_bb, else_bb, \n+\t\t\t    then_bb->succ->dest, 1))\n     return FALSE;\n \n   /* Conversion went ok, including moving the insns and fixing up the\n@@ -2235,9 +2225,17 @@ find_if_case_1 (test_bb, then_edge, else_edge)\n \t\t    else_bb->global_live_at_start,\n \t\t    then_bb->global_live_at_end, BITMAP_IOR);\n   \n-  make_edge (NULL, test_bb, then_succ->dest, 0);\n+  new_bb = redirect_edge_and_branch_force (FALLTHRU_EDGE (test_bb), else_bb);\n+  /* Make rest of code believe that the newly created block is the THEN_BB\n+     block we are going to remove.  */\n+  if (new_bb)\n+    {\n+      new_bb->aux = then_bb->aux;\n+      SET_UPDATE_LIFE (then_bb);\n+    }\n   flow_delete_block (then_bb);\n-  tidy_fallthru_edge (else_edge, test_bb, else_bb);\n+  /* We've possibly created jump to next insn, cleanup_cfg will solve that\n+     later.  */\n \n   num_removed_blocks++;\n   num_updated_if_blocks++;\n@@ -2255,7 +2253,7 @@ find_if_case_2 (test_bb, then_edge, else_edge)\n   basic_block then_bb = then_edge->dest;\n   basic_block else_bb = else_edge->dest;\n   edge else_succ = else_bb->succ;\n-  rtx new_lab, note;\n+  rtx note;\n \n   /* ELSE has one successor.  */\n   if (!else_succ || else_succ->succ_next != NULL)\n@@ -2294,27 +2292,8 @@ find_if_case_2 (test_bb, then_edge, else_edge)\n   if (count_bb_insns (then_bb) > BRANCH_COST)\n     return FALSE;\n \n-  /* Find the label for ELSE's destination.  */\n-  if (else_succ->dest == EXIT_BLOCK_PTR)\n-    new_lab = NULL_RTX;\n-  else\n-    {\n-      if (else_succ->flags & EDGE_FALLTHRU)\n-\t{\n-\t  new_lab = else_succ->dest->head;\n-\t  if (GET_CODE (new_lab) != CODE_LABEL)\n-\t    abort ();\n-\t}\n-      else\n-\t{\n-\t  new_lab = JUMP_LABEL (else_bb->end);\n-\t  if (! new_lab)\n-\t    abort ();\n-\t}\n-    }\n-\n   /* Registers set are dead, or are predicable.  */\n-  if (! dead_or_predicable (test_bb, else_bb, then_bb, new_lab, 0))\n+  if (! dead_or_predicable (test_bb, else_bb, then_bb, else_succ->dest, 0))\n     return FALSE;\n \n   /* Conversion went ok, including moving the insns and fixing up the\n@@ -2325,8 +2304,6 @@ find_if_case_2 (test_bb, then_edge, else_edge)\n \t\t    then_bb->global_live_at_start,\n \t\t    else_bb->global_live_at_end, BITMAP_IOR);\n   \n-  remove_edge (else_edge);\n-  make_edge (NULL, test_bb, else_succ->dest, 0);\n   flow_delete_block (else_bb);\n \n   num_removed_blocks++;\n@@ -2360,10 +2337,10 @@ find_memory (px, data)\n static int\n dead_or_predicable (test_bb, merge_bb, other_bb, new_dest, reversep)\n      basic_block test_bb, merge_bb, other_bb;\n-     rtx new_dest;\n+     basic_block new_dest;\n      int reversep;\n {\n-  rtx head, end, jump, earliest, old_dest;\n+  rtx head, end, jump, earliest, old_dest, new_label;\n \n   jump = test_bb->end;\n \n@@ -2548,23 +2525,36 @@ dead_or_predicable (test_bb, merge_bb, other_bb, new_dest, reversep)\n      change group management.  */\n \n   old_dest = JUMP_LABEL (jump);\n+  new_label = block_label (new_dest);\n   if (reversep\n-      ? ! invert_jump_1 (jump, new_dest)\n-      : ! redirect_jump_1 (jump, new_dest))\n+      ? ! invert_jump_1 (jump, new_label)\n+      : ! redirect_jump_1 (jump, new_label))\n     goto cancel;\n \n   if (! apply_change_group ())\n     return FALSE;\n \n   if (old_dest)\n     LABEL_NUSES (old_dest) -= 1;\n-  if (new_dest)\n-    LABEL_NUSES (new_dest) += 1;\n-  JUMP_LABEL (jump) = new_dest;\n+  if (new_label)\n+    LABEL_NUSES (new_label) += 1;\n+  JUMP_LABEL (jump) = new_label;\n \n   if (reversep)\n     invert_br_probabilities (jump);\n \n+  redirect_edge_succ (BRANCH_EDGE (test_bb), new_dest);\n+  if (reversep)\n+    {\n+      gcov_type count, probability;\n+      count = BRANCH_EDGE (test_bb)->count;\n+      BRANCH_EDGE (test_bb)->count = FALLTHRU_EDGE (test_bb)->count;\n+      FALLTHRU_EDGE (test_bb)->count = count;\n+      probability = BRANCH_EDGE (test_bb)->probability;\n+      BRANCH_EDGE (test_bb)->probability = FALLTHRU_EDGE (test_bb)->probability;\n+      FALLTHRU_EDGE (test_bb)->probability = probability;\n+    }\n+\n   /* Move the insns out of MERGE_BB to before the branch.  */\n   if (head != NULL)\n     {"}, {"sha": "e9227b14079dbb6d867ff1052aa3cff8009ac3b2", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b24c25948265c30431460146bc6f43ee9a34c23/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b24c25948265c30431460146bc6f43ee9a34c23/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=6b24c25948265c30431460146bc6f43ee9a34c23", "patch": "@@ -1301,6 +1301,7 @@ extern rtx *find_constant_term_loc\tPARAMS ((rtx *));\n \n /* In emit-rtl.c  */\n extern rtx try_split\t\t\tPARAMS ((rtx, rtx, int));\n+extern int split_branch_probability;\n \n /* In unknown file  */\n extern rtx split_insns\t\t\tPARAMS ((rtx, rtx));"}]}