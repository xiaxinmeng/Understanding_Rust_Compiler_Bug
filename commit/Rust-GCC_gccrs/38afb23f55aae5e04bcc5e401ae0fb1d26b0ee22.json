{"sha": "38afb23f55aae5e04bcc5e401ae0fb1d26b0ee22", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzhhZmIyM2Y1NWFhZTVlMDRiY2M1ZTQwMWFlMGZiMWQyNmIwZWUyMg==", "commit": {"author": {"name": "Olivier Hainque", "email": "hainque@act-europe.fr", "date": "2003-04-18T22:20:55Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2003-04-18T22:20:55Z"}, "message": "calls.c (expand_call): Move special case for constructor calls to right place.\n\n\t* calls.c (expand_call): Move special case for constructor calls\n\tto right place. Ensures constructor calls used to initialize\n\targuments get a clean outgoing argument block for themselves.\n\tMove check for stack deallocation completeness until after last\n\tdeallocation.  Add stack_pointer_delta to set of state\n\tvariables saved and restored along with current stack_level.\n\nFrom-SVN: r65795", "tree": {"sha": "704b899798a4f8f6d32c2d5504f9f23b2f2cb366", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/704b899798a4f8f6d32c2d5504f9f23b2f2cb366"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/38afb23f55aae5e04bcc5e401ae0fb1d26b0ee22", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38afb23f55aae5e04bcc5e401ae0fb1d26b0ee22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38afb23f55aae5e04bcc5e401ae0fb1d26b0ee22", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38afb23f55aae5e04bcc5e401ae0fb1d26b0ee22/comments", "author": null, "committer": null, "parents": [{"sha": "e59baa1f83fd053979c637f12f89cdf04d1d5ed5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e59baa1f83fd053979c637f12f89cdf04d1d5ed5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e59baa1f83fd053979c637f12f89cdf04d1d5ed5"}], "stats": {"total": 120, "additions": 72, "deletions": 48}, "files": [{"sha": "0847ad9610ddfb7aed47d8c18e51d5a5205cb11c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38afb23f55aae5e04bcc5e401ae0fb1d26b0ee22/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38afb23f55aae5e04bcc5e401ae0fb1d26b0ee22/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=38afb23f55aae5e04bcc5e401ae0fb1d26b0ee22", "patch": "@@ -1,5 +1,12 @@\n 2003-04-18  Olivier Hainque <hainque@act-europe.fr>\n \n+\t* calls.c (expand_call): Move special case for constructor calls\n+\tto right place. Ensures constructor calls used to initialize\n+\targuments get a clean outgoing argument block for themselves. \n+\tMove check for stack deallocation completeness until after last\n+\tdeallocation.  Add stack_pointer_delta to set of state\n+\tvariables saved and restored along with current stack_level.\n+\t\n         * integrate.c (expand_inline_function): Ensure non-const actuals\n         don't end up const in the caller's flow after conversion to possibly\n         const formal type."}, {"sha": "42e2bf79ac5749abeca5707e136183fbd2dfec4a", "filename": "gcc/calls.c", "status": "modified", "additions": 65, "deletions": 48, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38afb23f55aae5e04bcc5e401ae0fb1d26b0ee22/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38afb23f55aae5e04bcc5e401ae0fb1d26b0ee22/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=38afb23f55aae5e04bcc5e401ae0fb1d26b0ee22", "patch": "@@ -2200,12 +2200,20 @@ expand_call (exp, target, ignore)\n \n   int initial_highest_arg_in_use = highest_outgoing_arg_in_use;\n   char *initial_stack_usage_map = stack_usage_map;\n-  int old_stack_arg_under_construction = 0;\n \n+  int old_stack_allocated;\n+\n+  /* State variables to track stack modifications.  */\n   rtx old_stack_level = 0;\n+  int old_stack_arg_under_construction = 0;\n   int old_pending_adj = 0;\n   int old_inhibit_defer_pop = inhibit_defer_pop;\n-  int old_stack_allocated;\n+\n+  /* Some stack pointer alterations we make are performed via\n+     allocate_dynamic_stack_space. This modifies the stack_pointer_delta,\n+     which we then also need to save/restore along the way.  */\n+  int old_stack_pointer_delta;\n+\n   rtx call_fusage;\n   tree p = TREE_OPERAND (exp, 0);\n   tree addr = TREE_OPERAND (exp, 0);\n@@ -2751,6 +2759,7 @@ expand_call (exp, target, ignore)\n \t  if (old_stack_level == 0)\n \t    {\n \t      emit_stack_save (SAVE_BLOCK, &old_stack_level, NULL_RTX);\n+\t      old_stack_pointer_delta = stack_pointer_delta;\n \t      old_pending_adj = pending_stack_adjust;\n \t      pending_stack_adjust = 0;\n \t      /* stack_arg_under_construction says whether a stack arg is\n@@ -2877,53 +2886,58 @@ expand_call (exp, target, ignore)\n \t\t     VIRTUAL_OUTGOING_ARGS_RTX changes as well.  But might\n \t\t     as well always do it.  */\n \t\t  argblock = copy_to_reg (argblock);\n+\t\t}\n+\t    }\n+\t}\n \n-\t\t  /* The save/restore code in store_one_arg handles all\n-\t\t     cases except one: a constructor call (including a C\n-\t\t     function returning a BLKmode struct) to initialize\n-\t\t     an argument.  */\n-\t\t  if (stack_arg_under_construction)\n-\t\t    {\n+      if (ACCUMULATE_OUTGOING_ARGS)\n+\t{\n+\t  /* The save/restore code in store_one_arg handles all\n+\t     cases except one: a constructor call (including a C\n+\t     function returning a BLKmode struct) to initialize\n+\t     an argument.  */\n+\t  if (stack_arg_under_construction)\n+\t    {\n #ifndef OUTGOING_REG_PARM_STACK_SPACE\n-\t\t      rtx push_size = GEN_INT (reg_parm_stack_space\n-\t\t\t\t\t       + adjusted_args_size.constant);\n+\t      rtx push_size = GEN_INT (reg_parm_stack_space\n+\t\t\t\t       + adjusted_args_size.constant);\n #else\n-\t\t      rtx push_size = GEN_INT (adjusted_args_size.constant);\n+\t      rtx push_size = GEN_INT (adjusted_args_size.constant);\n #endif\n-\t\t      if (old_stack_level == 0)\n-\t\t\t{\n-\t\t\t  emit_stack_save (SAVE_BLOCK, &old_stack_level,\n-\t\t\t\t\t   NULL_RTX);\n-\t\t\t  old_pending_adj = pending_stack_adjust;\n-\t\t\t  pending_stack_adjust = 0;\n-\t\t\t  /* stack_arg_under_construction says whether a stack\n-\t\t\t     arg is being constructed at the old stack level.\n-\t\t\t     Pushing the stack gets a clean outgoing argument\n-\t\t\t     block.  */\n-\t\t\t  old_stack_arg_under_construction\n-\t\t\t    = stack_arg_under_construction;\n-\t\t\t  stack_arg_under_construction = 0;\n-\t\t\t  /* Make a new map for the new argument list.  */\n-\t\t\t  stack_usage_map = (char *)\n-\t\t\t    alloca (highest_outgoing_arg_in_use);\n-\t\t\t  memset (stack_usage_map, 0, highest_outgoing_arg_in_use);\n-\t\t\t  highest_outgoing_arg_in_use = 0;\n-\t\t\t}\n-\t\t      allocate_dynamic_stack_space (push_size, NULL_RTX,\n-\t\t\t\t\t\t    BITS_PER_UNIT);\n-\t\t    }\n-\t\t  /* If argument evaluation might modify the stack pointer,\n-\t\t     copy the address of the argument list to a register.  */\n-\t\t  for (i = 0; i < num_actuals; i++)\n-\t\t    if (args[i].pass_on_stack)\n-\t\t      {\n-\t\t\targblock = copy_addr_to_reg (argblock);\n-\t\t\tbreak;\n-\t\t      }\n+\t      if (old_stack_level == 0)\n+\t\t{\n+\t\t  emit_stack_save (SAVE_BLOCK, &old_stack_level,\n+\t\t\t\t   NULL_RTX);\n+\t\t  old_stack_pointer_delta = stack_pointer_delta;\n+\t\t  old_pending_adj = pending_stack_adjust;\n+\t\t  pending_stack_adjust = 0;\n+\t\t  /* stack_arg_under_construction says whether a stack\n+\t\t     arg is being constructed at the old stack level.\n+\t\t     Pushing the stack gets a clean outgoing argument\n+\t\t     block.  */\n+\t\t  old_stack_arg_under_construction\n+\t\t    = stack_arg_under_construction;\n+\t\t  stack_arg_under_construction = 0;\n+\t\t  /* Make a new map for the new argument list.  */\n+\t\t  stack_usage_map = (char *)\n+\t\t    alloca (highest_outgoing_arg_in_use);\n+\t\t  memset (stack_usage_map, 0, highest_outgoing_arg_in_use);\n+\t\t  highest_outgoing_arg_in_use = 0;\n \t\t}\n+\t      allocate_dynamic_stack_space (push_size, NULL_RTX,\n+\t\t\t\t\t    BITS_PER_UNIT);\n \t    }\n-\t}\n \n+\t  /* If argument evaluation might modify the stack pointer,\n+\t     copy the address of the argument list to a register.  */\n+\t  for (i = 0; i < num_actuals; i++)\n+\t    if (args[i].pass_on_stack)\n+\t      {\n+\t\targblock = copy_addr_to_reg (argblock);\n+\t\tbreak;\n+\t      }\n+\t}\n+      \n       compute_argument_addresses (args, argblock, num_actuals);\n \n       /* If we push args individually in reverse order, perform stack alignment\n@@ -3087,11 +3101,6 @@ expand_call (exp, target, ignore)\n \t\t   next_arg_reg, valreg, old_inhibit_defer_pop, call_fusage,\n \t\t   flags, & args_so_far);\n \n-      /* Verify that we've deallocated all the stack we used.  */\n-      if (pass\n-\t  && old_stack_allocated != stack_pointer_delta - pending_stack_adjust)\n-\tabort ();\n-\n       /* If call is cse'able, make appropriate pair of reg-notes around it.\n \t Test valreg so we don't crash; may safely ignore `const'\n \t if return type is void.  Disable for PARALLEL return values, because\n@@ -3313,6 +3322,7 @@ expand_call (exp, target, ignore)\n       if (old_stack_level && ! (flags & ECF_SP_DEPRESSED))\n \t{\n \t  emit_stack_restore (SAVE_BLOCK, old_stack_level, NULL_RTX);\n+\t  stack_pointer_delta = old_stack_pointer_delta;\n \t  pending_stack_adjust = old_pending_adj;\n \t  stack_arg_under_construction = old_stack_arg_under_construction;\n \t  highest_outgoing_arg_in_use = initial_highest_arg_in_use;\n@@ -3393,7 +3403,14 @@ expand_call (exp, target, ignore)\n \t  sbitmap_free (stored_args_map);\n \t}\n       else\n-\tnormal_call_insns = insns;\n+\t{\n+\t  normal_call_insns = insns;\n+\n+\t  /* Verify that we've deallocated all the stack we used.  */\n+\t  if (old_stack_allocated !=\n+\t      stack_pointer_delta - pending_stack_adjust)\n+\t    abort ();\n+\t}\n \n       /* If something prevents making this a sibling call,\n \t zero out the sequence.  */"}]}