{"sha": "9f2b860bed25db61d9093d87fb85ab2740823346", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWYyYjg2MGJlZDI1ZGI2MWQ5MDkzZDg3ZmI4NWFiMjc0MDgyMzM0Ng==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2013-11-06T15:00:16Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2013-11-06T15:00:16Z"}, "message": "re PR tree-optimization/58653 (wrong code (segfaults) at -O3 on x86_64-linux-gnu in 64-bit mode (affecting gcc 4.6 to trunk))\n\n2013-11-06  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/58653\n\t* tree-predcom.c (ref_at_iteration): Rewrite to generate\n\ta MEM_REF.\n\t(prepare_initializers_chain): Adjust.\n\n\t* gcc.dg/tree-ssa/predcom-6.c: New testcase.\n\t* gcc.dg/tree-ssa/predcom-7.c: Likewise.\n\nFrom-SVN: r204458", "tree": {"sha": "d7d1b4b83b4cb7b6059802f4ddfa490e22fd8041", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d7d1b4b83b4cb7b6059802f4ddfa490e22fd8041"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9f2b860bed25db61d9093d87fb85ab2740823346", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f2b860bed25db61d9093d87fb85ab2740823346", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f2b860bed25db61d9093d87fb85ab2740823346", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f2b860bed25db61d9093d87fb85ab2740823346/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "28d31e407447df98a843559b204bc01c40577555", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28d31e407447df98a843559b204bc01c40577555", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28d31e407447df98a843559b204bc01c40577555"}], "stats": {"total": 155, "additions": 67, "deletions": 88}, "files": [{"sha": "9d45b0ca4fd5bbf008d0d05edbcec87d13990a7e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f2b860bed25db61d9093d87fb85ab2740823346/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f2b860bed25db61d9093d87fb85ab2740823346/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9f2b860bed25db61d9093d87fb85ab2740823346", "patch": "@@ -1,3 +1,10 @@\n+2013-11-06  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/58653\n+\t* tree-predcom.c (ref_at_iteration): Rewrite to generate\n+\ta MEM_REF.\n+\t(prepare_initializers_chain): Adjust.\n+\n 2013-11-06  Andrew MacLeod  <amacleod@redhat.com>\n \n \t* gimple.h (block_in_transaction): Move to basic-block.h and rename."}, {"sha": "9d19eb10231f3a2a19c953cff571381dcb799ed6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f2b860bed25db61d9093d87fb85ab2740823346/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f2b860bed25db61d9093d87fb85ab2740823346/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9f2b860bed25db61d9093d87fb85ab2740823346", "patch": "@@ -1,3 +1,9 @@\n+2013-11-06  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/58653\n+\t* gcc.dg/tree-ssa/predcom-6.c: New testcase.\n+\t* gcc.dg/tree-ssa/predcom-7.c: Likewise.\n+\n 2013-11-05  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n \n \t* c-c++-common/cilk-plus/CK/fib.c: Reduced the iteration from"}, {"sha": "96d9bf93ef7b5c2e5007edce3367a262cd434c83", "filename": "gcc/testsuite/gcc.dg/tree-ssa/predcom-6.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f2b860bed25db61d9093d87fb85ab2740823346/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpredcom-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f2b860bed25db61d9093d87fb85ab2740823346/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpredcom-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpredcom-6.c?ref=9f2b860bed25db61d9093d87fb85ab2740823346", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do run } */\n+\n+int a, c, e[5][2]; \n+unsigned int d;\n+\n+int\n+main ()\n+{\n+  for (d = 0; d < 2; d++)\n+    if (a ? 0 : e[c + 3][d] & e[c + 4][d])\n+      break;\n+  return 0;\n+}"}, {"sha": "e7ae87ccc7a88b44094ecac42076c6346005b20d", "filename": "gcc/testsuite/gcc.dg/tree-ssa/predcom-7.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f2b860bed25db61d9093d87fb85ab2740823346/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpredcom-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f2b860bed25db61d9093d87fb85ab2740823346/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpredcom-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpredcom-7.c?ref=9f2b860bed25db61d9093d87fb85ab2740823346", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -fdump-tree-pcom-details\" } */\n+\n+int b, f, d[5][2];\n+unsigned int c;\n+\n+int\n+main ()\n+{\n+  for (c = 0; c < 2; c++)\n+    if (d[b + 3][c] & d[b + 4][c])\n+      if (f)\n+\tbreak;\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump \"Executing predictive commoning\" \"pcom\" } } */\n+/* { dg-final { cleanup-tree-dump \"pcom\" } } */"}, {"sha": "3358f8b9331fdd7a32f565e4f00acb38a978424b", "filename": "gcc/tree-predcom.c", "status": "modified", "additions": 23, "deletions": 88, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f2b860bed25db61d9093d87fb85ab2740823346/gcc%2Ftree-predcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f2b860bed25db61d9093d87fb85ab2740823346/gcc%2Ftree-predcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-predcom.c?ref=9f2b860bed25db61d9093d87fb85ab2740823346", "patch": "@@ -1334,90 +1334,29 @@ replace_ref_with (gimple stmt, tree new_tree, bool set, bool in_lhs)\n   gsi_insert_after (&bsi, new_stmt, GSI_NEW_STMT);\n }\n \n-/* Returns the reference to the address of REF in the ITER-th iteration of\n-   LOOP, or NULL if we fail to determine it (ITER may be negative).  We\n-   try to preserve the original shape of the reference (not rewrite it\n-   as an indirect ref to the address), to make tree_could_trap_p in\n-   prepare_initializers_chain return false more often.  */\n-\n-static tree\n-ref_at_iteration (struct loop *loop, tree ref, int iter)\n-{\n-  tree idx, *idx_p, type, val, op0 = NULL_TREE, ret;\n-  affine_iv iv;\n-  bool ok;\n-\n-  if (handled_component_p (ref))\n-    {\n-      op0 = ref_at_iteration (loop, TREE_OPERAND (ref, 0), iter);\n-      if (!op0)\n-\treturn NULL_TREE;\n-    }\n-  else if (!INDIRECT_REF_P (ref)\n-\t   && TREE_CODE (ref) != MEM_REF)\n-    return unshare_expr (ref);\n-\n-  if (TREE_CODE (ref) == MEM_REF)\n-    {\n-      ret = unshare_expr (ref);\n-      idx = TREE_OPERAND (ref, 0);\n-      idx_p = &TREE_OPERAND (ret, 0);\n-    }\n-  else if (TREE_CODE (ref) == COMPONENT_REF)\n-    {\n-      /* Check that the offset is loop invariant.  */\n-      if (TREE_OPERAND (ref, 2)\n-\t  && !expr_invariant_in_loop_p (loop, TREE_OPERAND (ref, 2)))\n-\treturn NULL_TREE;\n-\n-      return build3 (COMPONENT_REF, TREE_TYPE (ref), op0,\n-\t\t     unshare_expr (TREE_OPERAND (ref, 1)),\n-\t\t     unshare_expr (TREE_OPERAND (ref, 2)));\n-    }\n-  else if (TREE_CODE (ref) == ARRAY_REF)\n-    {\n-      /* Check that the lower bound and the step are loop invariant.  */\n-      if (TREE_OPERAND (ref, 2)\n-\t  && !expr_invariant_in_loop_p (loop, TREE_OPERAND (ref, 2)))\n-\treturn NULL_TREE;\n-      if (TREE_OPERAND (ref, 3)\n-\t  && !expr_invariant_in_loop_p (loop, TREE_OPERAND (ref, 3)))\n-\treturn NULL_TREE;\n-\n-      ret = build4 (ARRAY_REF, TREE_TYPE (ref), op0, NULL_TREE,\n-\t\t    unshare_expr (TREE_OPERAND (ref, 2)),\n-\t\t    unshare_expr (TREE_OPERAND (ref, 3)));\n-      idx = TREE_OPERAND (ref, 1);\n-      idx_p = &TREE_OPERAND (ret, 1);\n-    }\n-  else\n-    return NULL_TREE;\n-\n-  ok = simple_iv (loop, loop, idx, &iv, true);\n-  if (!ok)\n-    return NULL_TREE;\n-  iv.base = expand_simple_operations (iv.base);\n-  if (integer_zerop (iv.step))\n-    *idx_p = unshare_expr (iv.base);\n+/* Returns a memory reference to DR in the ITER-th iteration of\n+   the loop it was analyzed in.  Append init stmts to STMTS.  */\n+\n+static tree \n+ref_at_iteration (data_reference_p dr, int iter, gimple_seq *stmts)\n+{\n+  tree off = DR_OFFSET (dr);\n+  tree coff = DR_INIT (dr);\n+  if (iter == 0)\n+    ;\n+  else if (TREE_CODE (DR_STEP (dr)) == INTEGER_CST)\n+    coff = size_binop (PLUS_EXPR, coff,\n+\t\t       size_binop (MULT_EXPR, DR_STEP (dr), ssize_int (iter)));\n   else\n-    {\n-      type = TREE_TYPE (iv.base);\n-      if (POINTER_TYPE_P (type))\n-\t{\n-\t  val = fold_build2 (MULT_EXPR, sizetype, iv.step,\n-\t\t\t     size_int (iter));\n-\t  val = fold_build_pointer_plus (iv.base, val);\n-\t}\n-      else\n-\t{\n-\t  val = fold_build2 (MULT_EXPR, type, iv.step,\n-\t\t\t     build_int_cst_type (type, iter));\n-\t  val = fold_build2 (PLUS_EXPR, type, iv.base, val);\n-\t}\n-      *idx_p = unshare_expr (val);\n-    }\n-\n-  return ret;\n+    off = size_binop (PLUS_EXPR, off,\n+\t\t      size_binop (MULT_EXPR, DR_STEP (dr), ssize_int (iter)));\n+  tree addr = fold_build_pointer_plus (DR_BASE_ADDRESS (dr), off);\n+  addr = force_gimple_operand_1 (addr, stmts, is_gimple_mem_ref_addr,\n+\t\t\t\t NULL_TREE);\n+  return fold_build2 (MEM_REF, TREE_TYPE (DR_REF (dr)),\n+\t\t      addr,\n+\t\t      fold_convert (reference_alias_ptr_type (DR_REF (dr)),\n+\t\t\t\t    coff));\n }\n \n /* Get the initialization expression for the INDEX-th temporary variable\n@@ -2376,14 +2315,10 @@ prepare_initializers_chain (struct loop *loop, chain_p chain)\n       if (chain->inits[i] != NULL_TREE)\n \tcontinue;\n \n-      init = ref_at_iteration (loop, DR_REF (dr), (int) i - n);\n-      if (!init)\n-\treturn false;\n-\n+      init = ref_at_iteration (dr, (int) i - n, &stmts);\n       if (!chain->all_always_accessed && tree_could_trap_p (init))\n \treturn false;\n \n-      init = force_gimple_operand (init, &stmts, false, NULL_TREE);\n       if (stmts)\n \tgsi_insert_seq_on_edge_immediate (entry, stmts);\n "}]}